# Blocking main page to steal postmessage

{{#include ../../banners/hacktricks-training.md}}

## Winning RCs with Iframes

According to this [**Terjanq writeup**](https://gist.github.com/terjanq/7c1a71b83db5e02253c218765f96a710) blob documents created from null origins are isolated for security benefits, which means that if you maintain busy the main page, the iframe page is going to be executed.

基本的に、このチャレンジでは、**孤立したiframeが実行され**、その**読み込み**の**直後**に**親**ページが**フラグ**を含む**ポスト**メッセージを**送信**します。\
しかし、そのpostmessage通信は**XSSに脆弱**です（**iframe**はJSコードを実行できます）。

したがって、攻撃者の目標は、**親がiframeを作成させる**ことですが、**親**ページが**機密データ（**フラグ**）を**送信**する前に**それを**忙しく**させ、**ペイロードをiframeに送信**することです。**親が忙しい間**、**iframeはペイロードを実行**し、**親のpostmessageメッセージをリッスンしてフラグを漏洩**します。\
最終的に、iframeはペイロードを実行し、親ページは忙しさをやめるので、フラグを送信し、ペイロードがそれを漏洩します。

しかし、親が**iframeを生成した直後に、機密データを送信するためにiframeが準備できるのを待っている間、どのように忙しくさせることができるでしょうか？** 基本的に、**親が実行**できる**非同期**の**アクション**を見つける必要があります。例えば、このチャレンジでは、親はこのように**postmessages**を**リッスン**していました：
```javascript
window.addEventListener("message", (e) => {
if (e.data == "blob loaded") {
$("#previewModal").modal()
}
})
```
そのため、**postmessageで大きな整数を送信する**ことが可能であり、その比較で**文字列に変換される**ため、時間がかかります：
```bash
const buffer = new Uint8Array(1e7);
win?.postMessage(buffer, '*', [buffer.buffer]);
```
正確にし、**postmessage**を**iframe**が作成された**後**、しかし親からデータを受け取る準備ができる**前**に送信するためには、`setTimeout`のミリ秒を**調整**する必要があります。

{{#include ../../banners/hacktricks-training.md}}
