# Blocking main page to steal postmessage

{{#include ../../banners/hacktricks-training.md}}

## Winning RCs with Iframes

この[**Terjanqの解説**](https://gist.github.com/terjanq/7c1a71b83db5e02253c218765f96a710)によると、null originから作成されたblobドキュメントはセキュリティ上の利点のために隔離されており、つまり、メインページを忙しく保つと、iframeページが実行されることになります。

基本的に、このチャレンジでは**隔離されたiframeが実行され**、その**読み込み**の**直後**に**親**ページが**フラグ**を含む**post**メッセージを**送信**します。\
しかし、そのpostmessage通信は**XSSに脆弱**です（**iframe**はJSコードを実行できます）。

したがって、攻撃者の目標は**親にiframeを作成させる**ことですが、**親**ページが**機密データ（**フラグ**）を**送信**する**前に**、それを**忙しく保ち**、**payloadをiframeに送信**することです。**親が忙しい間**、**iframeはpayloadを実行**し、これは**親のpostmessageメッセージをリッスンし、フラグを漏洩させる**JSになります。\
最終的に、iframeはpayloadを実行し、親ページは忙しさをやめるので、フラグを送信し、payloadがそれを漏洩させます。

では、どのようにして親を**iframeを生成した直後に忙しくさせ、機密データを送信するためにiframeが準備できるのを待っている間だけ忙しくさせることができるでしょうか？** 基本的に、親に**実行**させることができる**非同期**の**アクション**を見つける必要があります。例えば、このチャレンジでは親がこのように**postmessages**を**リッスン**していました：
```javascript
window.addEventListener("message", (e) => {
if (e.data == "blob loaded") {
$("#previewModal").modal()
}
})
```
そのため、**postmessageで大きな整数を送信する**ことが可能であり、その比較で**文字列に変換される**ため、時間がかかります：
```bash
const buffer = new Uint8Array(1e7);
win?.postMessage(buffer, '*', [buffer.buffer]);
```
正確にし、**postmessage**を**iframe**が作成された**後**、しかし親からデータを受け取る準備ができる**前**に送信するためには、`setTimeout`のミリ秒を**調整**する必要があります。

{{#include ../../banners/hacktricks-training.md}}
