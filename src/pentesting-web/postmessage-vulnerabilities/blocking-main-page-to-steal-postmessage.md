# Blocking main page to steal postmessage

{{#include ../../banners/hacktricks-training.md}}

## Winning RCs with Iframes

Σύμφωνα με αυτήν την [**Terjanq writeup**](https://gist.github.com/terjanq/7c1a71b83db5e02253c218765f96a710), τα blob έγγραφα που δημιουργούνται από null origins είναι απομονωμένα για λόγους ασφαλείας, που σημαίνει ότι αν κρατήσετε απασχολημένη την κύρια σελίδα, η σελίδα iframe θα εκτελείται.

Βασικά, σε αυτή την πρόκληση, ένα **απομονωμένο iframe εκτελείται** και αμέσως **μετά** που **φορτώνεται**, η **γονική** σελίδα θα **στείλει ένα post** μήνυμα με τη **σημαία**.\
Ωστόσο, αυτή η επικοινωνία postmessage είναι **ευάλωτη σε XSS** (το **iframe** μπορεί να εκτελέσει κώδικα JS).

Επομένως, ο στόχος του επιτιθέμενου είναι να **επιτρέψει στην γονική σελίδα να δημιουργήσει το iframe**, αλλά **πριν** επιτρέψει στην **γονική** σελίδα να **στείλει** τα ευαίσθητα δεδομένα (**σημαία**) **να την κρατήσει απασχολημένη** και να στείλει το **payload στο iframe**. Ενώ η **γονική είναι απασχολημένη**, το **iframe εκτελεί το payload** που θα είναι κάποιος JS που θα ακούει για το **μήνυμα postmessage της γονικής και θα διαρρεύσει τη σημαία**.\
Τέλος, το iframe έχει εκτελέσει το payload και η γονική σελίδα σταματά να είναι απασχολημένη, οπότε στέλνει τη σημαία και το payload τη διαρρέει.

Αλλά πώς θα μπορούσατε να κάνετε την γονική να είναι **απασχολημένη αμέσως μετά που δημιούργησε το iframe και μόλις περιμένει το iframe να είναι έτοιμο να στείλει τα ευαίσθητα δεδομένα;** Βασικά, πρέπει να βρείτε μια **ασύγχρονη** **ενέργεια** που θα μπορούσατε να κάνετε την γονική **να εκτελέσει**. Για παράδειγμα, σε αυτή την πρόκληση, η γονική **άκουγε** για **postmessages** όπως αυτό:
```javascript
window.addEventListener("message", (e) => {
if (e.data == "blob loaded") {
$("#previewModal").modal()
}
})
```
έτσι ήταν δυνατό να σταλεί ένα **μεγάλο ακέραιο σε ένα postmessage** που θα **μετατραπεί σε συμβολοσειρά** σε αυτή τη σύγκριση, η οποία θα πάρει κάποιο χρόνο:
```bash
const buffer = new Uint8Array(1e7);
win?.postMessage(buffer, '*', [buffer.buffer]);
```
Και για να είστε ακριβείς και να **στείλετε** εκείνο το **postmessage** ακριβώς **μετά** τη δημιουργία του **iframe** αλλά **πριν** είναι **έτοιμο** να λάβει τα δεδομένα από τον γονέα, θα χρειαστεί να **παίξετε με τα χιλιοστά του δευτερολέπτου ενός `setTimeout`**.

{{#include ../../banners/hacktricks-training.md}}
