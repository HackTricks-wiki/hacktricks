# Bloquer la page principale pour voler le postmessage

{{#include ../../banners/hacktricks-training.md}}

## Gagner des RC avec des Iframes

Selon ce [**rapport de Terjanq**](https://gist.github.com/terjanq/7c1a71b83db5e02253c218765f96a710), les documents blob créés à partir d'origines nulles sont isolés pour des raisons de sécurité, ce qui signifie que si vous maintenez occupée la page principale, la page iframe va être exécutée.

Fondamentalement, dans ce défi, un **iframe isolé est exécuté** et juste **après** qu'il soit **chargé**, la **page parente** va **envoyer un post** message avec le **flag**.\
Cependant, cette communication postmessage est **vulnérable à XSS** (l'**iframe** peut exécuter du code JS).

Par conséquent, l'objectif de l'attaquant est de **laisser la page parente créer l'iframe**, mais **avant** de laisser la **page parente** **envoyer** les données sensibles (**flag**), **la garder occupée** et envoyer le **payload à l'iframe**. Pendant que la **page parente est occupée**, l'**iframe exécute le payload** qui sera un JS qui écoutera le **message postmessage de la page parente et volera le flag**.\
Enfin, l'iframe a exécuté le payload et la page parente cesse d'être occupée, donc elle envoie le flag et le payload le vole.

Mais comment pourriez-vous faire en sorte que la page parente soit **occupée juste après avoir généré l'iframe et juste pendant qu'elle attend que l'iframe soit prête à envoyer les données sensibles ?** Fondamentalement, vous devez trouver une **action** **async** que vous pourriez faire exécuter à la page parente. Par exemple, dans ce défi, la page parente était **à l'écoute** des **postmessages** comme ceci :
```javascript
window.addEventListener("message", (e) => {
if (e.data == "blob loaded") {
$("#previewModal").modal()
}
})
```
il était donc possible d'envoyer un **grand entier dans un postmessage** qui sera **converti en chaîne** dans cette comparaison, ce qui prendra un certain temps :
```bash
const buffer = new Uint8Array(1e7);
win?.postMessage(buffer, '*', [buffer.buffer]);
```
Et pour être précis et **envoyer** ce **postmessage** juste **après** la création de l'**iframe** mais **avant** qu'il soit **prêt** à recevoir les données du parent, vous devrez **jouer avec les millisecondes d'un `setTimeout`**.

{{#include ../../banners/hacktricks-training.md}}
