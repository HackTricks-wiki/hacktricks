# Blocking main page to steal postmessage

{{#include ../../banners/hacktricks-training.md}}

## Winning RCs with Iframes

이 [**Terjanq writeup**](https://gist.github.com/terjanq/7c1a71b83db5e02253c218765f96a710)에 따르면, null origin에서 생성된 blob 문서는 보안상의 이점으로 격리되어 있으며, 이는 메인 페이지를 바쁘게 유지하면 iframe 페이지가 실행된다는 것을 의미합니다.

기본적으로 이 도전에서 **격리된 iframe이 실행**되고, **로드된 직후** **부모** 페이지가 **플래그**와 함께 **post** 메시지를 **전송**합니다.\
그러나 그 postmessage 통신은 **XSS에 취약**합니다( **iframe**이 JS 코드를 실행할 수 있습니다).

따라서 공격자의 목표는 **부모가 iframe을 생성하게** 하되, **부모** 페이지가 **민감한 데이터(플래그)**를 **전송하기 전에** **바쁘게 유지**하고 **payload를 iframe으로 전송**하는 것입니다. **부모가 바쁠 때** **iframe은 payload를 실행**하며, 이는 **부모 postmessage 메시지를 듣고 플래그를 유출하는** JS가 될 것입니다.\
마지막으로, iframe은 payload를 실행하고 부모 페이지는 바쁘지 않게 되므로 플래그를 전송하고 payload가 이를 유출합니다.

그렇다면 부모가 **iframe을 생성한 직후에 민감한 데이터를 전송하기 위해 iframe이 준비되기를 기다리는 동안 어떻게 바쁘게 만들 수 있을까요?** 기본적으로 부모가 **실행할 수 있는** **비동기** **작업**을 찾아야 합니다. 예를 들어, 이 도전에서 부모는 다음과 같이 **postmessages**를 **듣고** 있었습니다:
```javascript
window.addEventListener("message", (e) => {
if (e.data == "blob loaded") {
$("#previewModal").modal()
}
})
```
그래서 **postmessage에서 큰 정수를 보내는** 것이 가능했으며, 이는 그 비교에서 **문자열로 변환될** 것이고, 시간이 좀 걸릴 것입니다:
```bash
const buffer = new Uint8Array(1e7);
win?.postMessage(buffer, '*', [buffer.buffer]);
```
정확하게 **전송**하고 **postmessage**를 **iframe**이 생성된 **후**이지만 부모로부터 데이터를 받을 준비가 **되기 전**에 하려면, **`setTimeout`의 밀리초를 조정**해야 합니다.

{{#include ../../banners/hacktricks-training.md}}
