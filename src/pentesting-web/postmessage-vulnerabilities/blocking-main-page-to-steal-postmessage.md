# 阻止主页面以窃取 postmessage

{{#include ../../banners/hacktricks-training.md}}

## 使用 Iframes 赢得 RCs

根据这个 [**Terjanq writeup**](https://gist.github.com/terjanq/7c1a71b83db5e02253c218765f96a710)，从空源创建的 blob 文档出于安全考虑是隔离的，这意味着如果你让主页面保持忙碌，iframe 页面将会被执行。

基本上，在这个挑战中，一个 **隔离的 iframe 被执行**，并且在它 **加载后**，**父**页面将会 **发送一个 post** 消息，包含 **标志**。\
然而，这种 postmessage 通信是 **易受 XSS 攻击的**（**iframe** 可以执行 JS 代码）。

因此，攻击者的目标是 **让父页面创建 iframe**，但 **在** 让 **父**页面 **发送** 敏感数据（**标志**）之前 **保持它忙碌**，并将 **有效载荷发送到 iframe**。当 **父页面忙碌时**，**iframe 执行有效载荷**，这将是一些 JS 代码，用于监听 **父 postmessage 消息并泄露标志**。\
最后，iframe 执行了有效载荷，父页面停止忙碌，因此它发送标志，而有效载荷泄露了它。

但是你如何能让父页面在生成 iframe 后 **立即忙碌，并且在等待 iframe 准备好发送敏感数据时保持忙碌呢？** 基本上，你需要找到 **异步** **操作**，让父页面 **执行**。例如，在这个挑战中，父页面 **监听** **postmessages**，如下所示：
```javascript
window.addEventListener("message", (e) => {
if (e.data == "blob loaded") {
$("#previewModal").modal()
}
})
```
因此，可以在 postmessage 中发送一个 **大整数**，在该比较中将被 **转换为字符串**，这将需要一些时间：
```bash
const buffer = new Uint8Array(1e7);
win?.postMessage(buffer, '*', [buffer.buffer]);
```
为了精确地**发送**该**postmessage**，在**iframe**创建后但在其**准备好**接收来自父级的数据之前，您需要**调整`setTimeout`的毫秒数**。 

{{#include ../../banners/hacktricks-training.md}}
