# Захоплення облікового запису

{{#include ../banners/hacktricks-training.md}}

## **Проблема авторизації**

Слід спробувати змінити email облікового запису і **ретельно перевірити** процес підтвердження. Якщо він виявиться **слабким**, змініть email на той, що належить жертві, і підтвердіть його.

## **Проблема нормалізації Unicode**

1. Обліковий запис цілі `victim@gmail.com`
2. Слід створити обліковий запис, використовуючи Unicode,  
наприклад: `vićtim@gmail.com`

Як пояснюється в [**this talk**](https://www.youtube.com/watch?v=CiIyaZ3x49c), попередню атаку також можна виконати, зловживаючи third party identity providers:

- Create an account in the third party identity with similar email to the victim using some unicode character (`vićtim@company.com`).
- The third party provider shouldn't verify the email
- If the identity provider verifies the email, maybe you can attack the domain part like: `victim@ćompany.com` and register that domain and hope that the identity provider generates the ascii version of the domain while the victim platform normalize the domain name.
- Login via this identity provider in the victim platform who should normalize the unicode character and allow you to access the victim account.

Для детальнішої інформації див. документ про Unicode Normalization:


{{#ref}}
unicode-injection/unicode-normalization.md
{{#endref}}

## **Повторне використання токена скидання**

Якщо цільова система дозволяє **повторне використання reset link**, слід намагатися **знайти більше посилань для скидання** за допомогою інструментів, таких як `gau`, `wayback` або `scan.io`.

## **Перед захопленням облікового запису**

1. Використайте email жертви для реєстрації на платформі та встановіть пароль (слід спробувати підтвердити обліковий запис, хоча відсутність доступу до пошти жертви може зробити це неможливим).
2. Очікуйте, поки жертва зареєструється через OAuth і підтвердить обліковий запис.
3. Є надія, що звичайна реєстрація буде підтверджена, що дозволить отримати доступ до облікового запису жертви.

## **Неправильна конфігурація CORS для захоплення облікового запису**

Якщо сторінка містить **CORS misconfigurations**, ви можете змогти **викрасти чутливу інформацію** від користувача, щоб **захопити його обліковий запис**, або змусити його змінити auth-дані з тією самою метою:


{{#ref}}
cors-bypass.md
{{#endref}}

## **CSRF для захоплення облікового запису**

Якщо сторінка вразлива до CSRF, ви можете змусити **користувача змінити свій пароль**, email або методи автентифікації, щоб потім отримати доступ до його облікового запису:


{{#ref}}
csrf-cross-site-request-forgery.md
{{#endref}}

## **XSS для захоплення облікового запису**

Якщо ви знаходите XSS в додатку, ви можете викрасти cookies, local storage або інформацію зі сторінки, що може дозволити вам захопити обліковий запис:


{{#ref}}
xss-cross-site-scripting/
{{#endref}}

- Attribute-only reflected payloads on login pages can hook `document.onkeypress`, exfiltrate keystrokes through `new Image().src`, and steal credentials without submitting the form. See [Attribute-only login XSS behind WAFs](xss-cross-site-scripting/README.md#attribute-only-login-xss-behind-wafs) for a practical workflow.

## **Same Origin + Cookies**

Якщо ви знаходите обмежений XSS або піддомен було захоплено, ви можете маніпулювати cookies (наприклад, фіксуючи їх), щоб спробувати скомпрометувати обліковий запис жертви:


{{#ref}}
hacking-with-cookies/
{{#endref}}

## **Атака на механізм скидання пароля**


{{#ref}}
reset-password.md
{{#endref}}

## Скидання через контрольні питання, що довіряють іменам користувачів, наданим клієнтом
Якщо процес "update security questions" приймає параметр `username`, хоча виконавець уже автентифікований, ви можете перезаписати recovery-дані будь-якого облікового запису (включно з адміністраторами), оскільки бекенд зазвичай виконує `UPDATE ... WHERE user_name = ?` з вашим ненадійним значенням. Схема така:

1. Увійдіть під тимчасовим користувачем і перехопіть session cookie.
2. Надішліть ім'я користувача жертви та нові відповіді через форму скидання.
3. Негайно автентифікуйтесь через endpoint входу за допомогою контрольних питань, використовуючи відповіді, які ви щойно інжектували, щоб успадкувати привілеї жертви.
```http
POST /reset.php HTTP/1.1
Host: file.era.htb
Cookie: PHPSESSID=<low-priv>
Content-Type: application/x-www-form-urlencoded

username=admin_ef01cab31aa&new_answer1=A&new_answer2=B&new_answer3=C
```
Усе, що захищено контекстом жертви `$_SESSION` (admin dashboards, небезпечні stream-wrapper features тощо), тепер відкрито без доступу до реальних відповідей.

Перераховані імена користувачів потім можна націлити за допомогою наведеної вище overwrite technique або повторно використати проти допоміжних сервісів (FTP/SSH password spraying).

## **Response Manipulation**

Якщо authentication response можна **звести до простого булевого значення — просто спробуйте змінити false на true** і перевірте, чи отримаєте доступ.

## OAuth to Account takeover


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

## Host Header Injection

1. Host header змінюється після ініціації запиту на скидання пароля.
2. Заголовок проксі `X-Forwarded-For` змінюється на `attacker.com`.
3. Host, Referrer та Origin заголовки одночасно змінюються на `attacker.com`.
4. Після ініціювання скидання пароля та повторної відправки листа застосовуються всі три вищеописані методи.

## Response Manipulation

1. **Code Manipulation**: статусний код змінюється на `200 OK`.
2. **Code and Body Manipulation**:
- Статусний код змінюється на `200 OK`.
- Тіло відповіді змінюється на `{"success":true}` або на порожній об'єкт `{}`.

Ці методи маніпуляції ефективні у сценаріях, де JSON використовується для передачі й отримання даних.

## Change email of current session

From [this report](https://dynnyd20.medium.com/one-click-account-take-over-e500929656ea):

- Attacker робить запит на зміну своєї email на нову.
- Attacker отримує посилання для підтвердження зміни email.
- Attacker відправляє victim це посилання, і той клікає його.
- Email victim змінюється на той, який вказав Attacker.
- Атака дозволяє відновити пароль і захопити обліковий запис.

This also happened in [**this report**](https://dynnyd20.medium.com/one-click-account-take-over-e500929656ea).


### Bypass email verification for Account Takeover
- Attacker входить під attacker@test.com і підтверджує email при реєстрації.
- Attacker змінює підтверджений email на victim@test.com (немає вторинної верифікації при зміні email).
- Тепер сайт дозволяє victim@test.com входити, і ми обійшли перевірку email для victim-користувача.

### Old Cookies

As explained [**in this post**](https://medium.com/@niraj1mahajan/uncovering-the-hidden-vulnerability-how-i-found-an-authentication-bypass-on-shopifys-exchange-cc2729ea31a9), було можливо увійти в акаунт, зберегти cookies як автентифікований користувач, вийти, а потім увійти знову.\
При новому логіні, хоча могли бути згенеровані інші cookies, старі знову почали працювати.

### Trusted device cookies + batch API leakage

*Long-lived device identifiers that gate recovery can be stolen when a batch API lets you copy unreadable subresponses into writable sinks.*

- Identify a **trusted-device cookie** (`SameSite=None`, long-lived) used to relax recovery checks.
- Find a **first-party endpoint** that returns that device ID in JSON (e.g., an OAuth `code` exchange returning `machine_id`) but is not readable cross-origin.
- Use a **batch/chained API** that allows referencing earlier subresponses (`{result=name:$.path}`) and writing them to an attacker-visible sink (page post, upload-by-URL, etc.). Example with Facebook Graph API:
```http
POST https://graph.facebook.com/
batch=[
{"method":"post","omit_response_on_success":0,"relative_url":"/oauth/access_token?client_id=APP_ID%26redirect_uri=REDIRECT_URI","body":"code=SINGLE_USE_CODE","name":"leaker"},
{"method":"post","relative_url":"PAGE_ID/posts","body":"message={result=leaker:$.machine_id}"}
]
access_token=PAGE_ACCESS_TOKEN&method=post
```
- Завантажте batch URL у прихований `<iframe>`, щоб жертва відправила trusted-device cookie; JSON-path reference копіює `machine_id` у attacker-controlled post, навіть якщо OAuth response недоступна для сторінки.
- Replay: встановіть stolen device cookie у новій сесії. Recovery тепер вважає браузер trusted, часто відкриваючи слабші “no email/phone” flows (e.g., automated document upload), що дозволяє додати attacker email без пароля або 2FA.

## Посилання

- [https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [https://infosecwriteups.com/firing-8-account-takeover-methods-77e892099050](https://infosecwriteups.com/firing-8-account-takeover-methods-77e892099050)
- [https://dynnyd20.medium.com/one-click-account-take-over-e500929656ea](https://dynnyd20.medium.com/one-click-account-take-over-e500929656ea)
- [0xdf – HTB Era: security-question IDOR & username oracle](https://0xdf.gitlab.io/2025/11/29/htb-era.html)
- [Steal DATR Cookie](https://ysamm.com/uncategorized/2026/01/15/steal-dtsg-cookie.html)
{{#include ../banners/hacktricks-training.md}}
