# OAuth vers la prise de contrôle de compte

{{#include ../banners/hacktricks-training.md}}

## Informations de base <a href="#d4a8" id="d4a8"></a>

OAuth propose différentes versions, avec des informations fondamentales accessibles dans la [documentation OAuth 2.0](https://oauth.net/2/). Cette discussion se concentre principalement sur le [type de code d'autorisation OAuth 2.0](https://oauth.net/2/grant-types/authorization-code/), fournissant un **cadre d'autorisation qui permet à une application d'accéder ou d'effectuer des actions sur le compte d'un utilisateur dans une autre application** (le serveur d'autorisation).

Considérons un site web hypothétique _**https://example.com**_, conçu pour **présenter tous vos posts sur les réseaux sociaux**, y compris les privés. Pour ce faire, OAuth 2.0 est utilisé. _https://example.com_ demandera votre permission pour **accéder à vos posts sur les réseaux sociaux**. Par conséquent, un écran de consentement apparaîtra sur _https://socialmedia.com_, décrivant les **permissions demandées et le développeur faisant la demande**. Après votre autorisation, _https://example.com_ obtient la capacité d'**accéder à vos posts en votre nom**.

Il est essentiel de comprendre les composants suivants dans le cadre OAuth 2.0 :

- **propriétaire de la ressource** : Vous, en tant que **utilisateur/entité**, autorisez l'accès à votre ressource, comme vos posts de compte sur les réseaux sociaux.
- **serveur de ressources** : Le **serveur gérant les demandes authentifiées** après que l'application a sécurisé un `access token` au nom du `propriétaire de la ressource`, par exemple, **https://socialmedia.com**.
- **application cliente** : L'**application cherchant à obtenir l'autorisation** du `propriétaire de la ressource`, comme **https://example.com**.
- **serveur d'autorisation** : Le **serveur qui délivre des `access tokens`** à l'`application cliente` après l'authentification réussie du `propriétaire de la ressource` et l'obtention de l'autorisation, par exemple, **https://socialmedia.com**.
- **client_id** : Un identifiant public et unique pour l'application.
- **client_secret** : Une clé confidentielle, connue uniquement de l'application et du serveur d'autorisation, utilisée pour générer des `access_tokens`.
- **response_type** : Une valeur spécifiant **le type de token demandé**, comme `code`.
- **scope** : Le **niveau d'accès** que l'`application cliente` demande au `propriétaire de la ressource`.
- **redirect_uri** : L'**URL vers laquelle l'utilisateur est redirigé après l'autorisation**. Cela doit généralement correspondre à l'URL de redirection préenregistrée.
- **state** : Un paramètre pour **maintenir des données lors de la redirection de l'utilisateur vers et depuis le serveur d'autorisation**. Son unicité est cruciale pour servir de **mécanisme de protection CSRF**.
- **grant_type** : Un paramètre indiquant **le type de subvention et le type de token à retourner**.
- **code** : Le code d'autorisation du `serveur d'autorisation`, utilisé en tandem avec `client_id` et `client_secret` par l'application cliente pour acquérir un `access_token`.
- **access_token** : Le **token que l'application cliente utilise pour les requêtes API** au nom du `propriétaire de la ressource`.
- **refresh_token** : Permet à l'application de **obtenir un nouveau `access_token` sans redemander à l'utilisateur**.

### Flux

Le **flux OAuth réel** se déroule comme suit :

1. Vous naviguez vers [https://example.com](https://example.com) et sélectionnez le bouton “Intégrer avec les réseaux sociaux”.
2. Le site envoie ensuite une demande à [https://socialmedia.com](https://socialmedia.com) demandant votre autorisation pour permettre à l'application de https://example.com d'accéder à vos posts. La demande est structurée comme suit :
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Vous êtes ensuite présenté avec une page de consentement.  
4. Suite à votre approbation, le réseau social envoie une réponse à l'`redirect_uri` avec les paramètres `code` et `state` :
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com utilise ce `code`, ainsi que son `client_id` et `client_secret`, pour effectuer une requête côté serveur afin d'obtenir un `access_token` en votre nom, permettant l'accès aux autorisations auxquelles vous avez consenti :
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Enfin, le processus se termine lorsque https://example.com utilise votre `access_token` pour effectuer un appel API à Social Media pour accéder

## Vulnérabilités <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Le `redirect_uri` est crucial pour la sécurité dans les implémentations OAuth et OpenID, car il dirige où les données sensibles, comme les codes d'autorisation, sont envoyées après l'autorisation. S'il est mal configuré, cela pourrait permettre aux attaquants de rediriger ces demandes vers des serveurs malveillants, permettant ainsi la prise de contrôle de compte.

Les techniques d'exploitation varient en fonction de la logique de validation du serveur d'autorisation. Elles peuvent aller d'une correspondance stricte des chemins à l'acceptation de n'importe quelle URL dans le domaine ou le sous-répertoire spécifié. Les méthodes d'exploitation courantes incluent les redirections ouvertes, le parcours de chemin, l'exploitation de regex faibles et l'injection HTML pour le vol de jetons.

En plus de `redirect_uri`, d'autres paramètres OAuth et OpenID comme `client_uri`, `policy_uri`, `tos_uri` et `initiate_login_uri` sont également susceptibles aux attaques de redirection. Ces paramètres sont optionnels et leur support varie selon les serveurs.

Pour ceux qui ciblent un serveur OpenID, le point de découverte (`**.well-known/openid-configuration**`) liste souvent des détails de configuration précieux comme `registration_endpoint`, `request_uri_parameter_supported`, et "`require_request_uri_registration`. Ces détails peuvent aider à identifier le point de terminaison d'enregistrement et d'autres spécificités de configuration du serveur.

### XSS dans l'implémentation de redirection <a href="#bda5" id="bda5"></a>

Comme mentionné dans ce rapport de bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), il pourrait être possible que l'**URL de redirection soit reflétée dans la réponse** du serveur après que l'utilisateur s'authentifie, étant **vulnérable à XSS**. Charge utile possible à tester :
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Mauvaise gestion du paramètre d'état <a href="#bda5" id="bda5"></a>

Dans les implémentations OAuth, l'utilisation incorrecte ou l'omission du **`state` parameter** peut considérablement augmenter le risque d'attaques de **Cross-Site Request Forgery (CSRF)**. Cette vulnérabilité survient lorsque le paramètre `state` est soit **non utilisé, utilisé comme une valeur statique, ou pas correctement validé ou associé à la session de l'utilisateur** lors de la connexion, permettant aux attaquants de contourner les protections CSRF.

Les attaquants peuvent exploiter cela en interceptant le processus d'autorisation pour lier leur compte à celui d'une victime, conduisant à de potentielles **prises de contrôle de compte** en faisant en sorte qu'un utilisateur se connecte avec un flux oauth presque finalisé appartenant à l'attaquant. Cela est particulièrement critique dans les applications où OAuth est utilisé à des fins **d'authentification**.

Des exemples concrets de cette vulnérabilité ont été documentés dans divers **défis CTF** et **plateformes de hacking**, soulignant ses implications pratiques. Le problème s'étend également aux intégrations avec des services tiers comme **Slack**, **Stripe**, et **PayPal**, où les attaquants peuvent rediriger des notifications ou des paiements vers leurs comptes.

Une gestion et une validation appropriées du **`state` parameter** sont cruciales pour se protéger contre le CSRF et sécuriser le flux OAuth.

### Pré Prise de Contrôle de Compte <a href="#ebe4" id="ebe4"></a>

1. **Sans Vérification d'Email lors de la Création de Compte** : Les attaquants peuvent créer préventivement un compte en utilisant l'email de la victime. Si la victime utilise plus tard un service tiers pour se connecter, l'application pourrait involontairement lier ce compte tiers au compte pré-créé de l'attaquant, conduisant à un accès non autorisé.
2. **Exploitation d'une Vérification d'Email OAuth Laxiste** : Les attaquants peuvent exploiter des services OAuth qui ne vérifient pas les emails en s'inscrivant avec leur service puis en changeant l'email du compte pour celui de la victime. Cette méthode présente également un risque d'accès non autorisé au compte, semblable au premier scénario mais par un vecteur d'attaque différent.

### Divulgation de Secrets <a href="#e177" id="e177"></a>

Identifier et protéger les paramètres secrets OAuth est crucial. Bien que le **`client_id`** puisse être divulgué en toute sécurité, révéler le **`client_secret`** pose des risques significatifs. Si le `client_secret` est compromis, les attaquants peuvent exploiter l'identité et la confiance de l'application pour **voler des `access_tokens` d'utilisateur** et des informations privées.

Une vulnérabilité courante survient lorsque les applications gèrent par erreur l'échange du `code` d'autorisation contre un `access_token` côté client plutôt que côté serveur. Cette erreur conduit à l'exposition du `client_secret`, permettant aux attaquants de générer des `access_tokens` sous le couvert de l'application. De plus, par ingénierie sociale, les attaquants pourraient élever leurs privilèges en ajoutant des scopes supplémentaires à l'autorisation OAuth, exploitant davantage le statut de confiance de l'application.

### Bruteforce du Client Secret

Vous pouvez essayer de **bruteforcer le client_secret** d'un fournisseur de services avec le fournisseur d'identité afin d'essayer de voler des comptes.\
La requête pour le BF peut ressembler à :
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Fuite du code + état dans l'en-tête Referer

Une fois que le client a le **code et l'état**, s'ils sont **réfléchis dans l'en-tête Referer** lorsqu'il navigue vers une autre page, alors il est vulnérable.

### Jeton d'accès stocké dans l'historique du navigateur

Allez dans **l'historique du navigateur et vérifiez si le jeton d'accès y est enregistré**.

### Code d'autorisation éternel

Le **code d'autorisation ne devrait vivre que pendant un certain temps pour limiter la fenêtre temporelle où un attaquant peut le voler et l'utiliser**.

### Jeton d'autorisation/rafraîchissement non lié au client

Si vous pouvez obtenir le **code d'autorisation et l'utiliser avec un client différent, alors vous pouvez prendre le contrôle d'autres comptes**.

### Chemins heureux, XSS, Iframes et messages post pour fuir les valeurs de code et d'état

[**Vérifiez ce post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

Dans ce rapport de bug bounty : [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) vous pouvez voir que le **jeton** que **AWS Cognito** renvoie à l'utilisateur pourrait avoir **suffisamment de permissions pour écraser les données de l'utilisateur**. Par conséquent, si vous pouvez **changer l'email de l'utilisateur pour un autre email d'utilisateur**, vous pourriez être en mesure de **prendre le contrôle** d'autres comptes.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Pour plus d'informations détaillées sur la façon d'abuser d'AWS cognito, consultez :

{{#ref}}
https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html
{{#endref}}

### Abus des tokens d'autres applications <a href="#bda5" id="bda5"></a>

Comme [**mentionné dans cet article**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), les flux OAuth qui s'attendent à recevoir le **token** (et non un code) pourraient être vulnérables s'ils ne vérifient pas que le token appartient à l'application.

C'est parce qu'un **attaquant** pourrait créer une **application supportant OAuth et se connecter avec Facebook** (par exemple) dans sa propre application. Ensuite, une fois qu'une victime se connecte avec Facebook dans l'**application de l'attaquant**, l'attaquant pourrait obtenir le **token OAuth de l'utilisateur donné à son application, et l'utiliser pour se connecter dans l'application OAuth de la victime en utilisant le token utilisateur de la victime**.

> [!CAUTION]
> Par conséquent, si l'attaquant parvient à faire accéder l'utilisateur à sa propre application OAuth, il pourra prendre le contrôle du compte de la victime dans les applications qui s'attendent à un token et ne vérifient pas si le token a été accordé à leur ID d'application.

### Deux liens & cookie <a href="#bda5" id="bda5"></a>

Selon [**cet article**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), il était possible de faire ouvrir à une victime une page avec un **returnUrl** pointant vers l'hôte de l'attaquant. Cette info serait **stockée dans un cookie (RU)** et à une **étape ultérieure**, le **prompt** demandera à l'**utilisateur** s'il souhaite donner accès à cet hôte de l'attaquant.

Pour contourner ce prompt, il était possible d'ouvrir un onglet pour initier le **flux Oauth** qui définirait ce cookie RU en utilisant le **returnUrl**, de fermer l'onglet avant que le prompt ne soit affiché, et d'ouvrir un nouvel onglet sans cette valeur. Ensuite, le **prompt n'informera pas sur l'hôte de l'attaquant**, mais le cookie serait défini pour cela, donc le **token sera envoyé à l'hôte de l'attaquant** dans la redirection.

### Contournement de l'interaction du prompt <a href="#bda5" id="bda5"></a>

Comme expliqué dans [**cette vidéo**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), certaines implémentations OAuth permettent d'indiquer le paramètre **`prompt`** GET comme None (**`&prompt=none`**) pour **empêcher les utilisateurs d'être invités à confirmer** l'accès donné dans un prompt sur le web s'ils sont déjà connectés à la plateforme.

### response_mode

Comme [**expliqué dans cette vidéo**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), il pourrait être possible d'indiquer le paramètre **`response_mode`** pour indiquer où vous souhaitez que le code soit fourni dans l'URL finale :

- `response_mode=query` -> Le code est fourni à l'intérieur d'un paramètre GET : `?code=2397rf3gu93f`
- `response_mode=fragment` -> Le code est fourni à l'intérieur du paramètre de fragment d'URL `#code=2397rf3gu93f`
- `response_mode=form_post` -> Le code est fourni à l'intérieur d'un formulaire POST avec un input appelé `code` et la valeur
- `response_mode=web_message` -> Le code est envoyé dans un message post : `window.opener.postMessage({"code": "asdasdasd...`

### Flux OAuth ROPC - contournement de 2 FA <a href="#b440" id="b440"></a>

Selon [**cet article de blog**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), il s'agit d'un flux OAuth qui permet de se connecter à OAuth via **nom d'utilisateur** et **mot de passe**. Si, au cours de ce flux simple, un **token** avec accès à toutes les actions que l'utilisateur peut effectuer est retourné, alors il est possible de contourner 2FA en utilisant ce token.

### ATO sur une page web redirigeant en fonction de la redirection ouverte vers le référent <a href="#bda5" id="bda5"></a>

Ce [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) commente comment il était possible d'abuser d'une **redirection ouverte** vers la valeur du **référent** pour abuser d'OAuth pour ATO. L'attaque était :

1. La victime accède à la page web de l'attaquant
2. La victime ouvre le lien malveillant et un opener démarre le flux OAuth de Google avec `response_type=id_token,code&prompt=none` comme paramètres supplémentaires en utilisant comme **référent le site web de l'attaquant**.
3. Dans l'opener, après que le fournisseur autorise la victime, il les renvoie à la valeur du paramètre `redirect_uri` (site web de la victime) avec un code 30X qui garde toujours le site web de l'attaquant dans le référent.
4. Le **site web de la victime déclenche la redirection ouverte basée sur le référent**, redirigeant l'utilisateur victime vers le site web de l'attaquant, comme le **`respose_type`** était **`id_token,code`**, le code sera renvoyé à l'attaquant dans le **fragment** de l'URL lui permettant de prendre le contrôle du compte de l'utilisateur via Google sur le site de la victime.

### Paramètres SSRFs <a href="#bda5" id="bda5"></a>

[**Vérifiez cette recherche**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Pour plus de détails sur cette technique.**

L'enregistrement dynamique de clients dans OAuth sert de vecteur moins évident mais critique pour les vulnérabilités de sécurité, spécifiquement pour les attaques de **Server-Side Request Forgery (SSRF)**. Ce point de terminaison permet aux serveurs OAuth de recevoir des détails sur les applications clientes, y compris des URL sensibles qui pourraient être exploitées.

**Points clés :**

- L'**enregistrement dynamique de clients** est souvent mappé à `/register` et accepte des détails comme `client_name`, `client_secret`, `redirect_uris`, et des URL pour des logos ou des ensembles de clés JSON Web (JWKs) via des requêtes POST.
- Cette fonctionnalité adhère aux spécifications énoncées dans **RFC7591** et **OpenID Connect Registration 1.0**, qui incluent des paramètres potentiellement vulnérables aux SSRF.
- Le processus d'enregistrement peut involontairement exposer les serveurs aux SSRF de plusieurs manières :
- **`logo_uri`** : Une URL pour le logo de l'application cliente qui pourrait être récupérée par le serveur, déclenchant un SSRF ou menant à un XSS si l'URL est mal gérée.
- **`jwks_uri`** : Une URL vers le document JWK du client, qui, si elle est malicieusement conçue, peut amener le serveur à effectuer des requêtes sortantes vers un serveur contrôlé par un attaquant.
- **`sector_identifier_uri`** : Fait référence à un tableau JSON de `redirect_uris`, que le serveur pourrait récupérer, créant une opportunité de SSRF.
- **`request_uris`** : Liste les URI de requête autorisées pour le client, qui peuvent être exploitées si le serveur récupère ces URI au début du processus d'autorisation.

**Stratégie d'exploitation :**

- Le SSRF peut être déclenché en enregistrant un nouveau client avec des URL malicieuses dans des paramètres comme `logo_uri`, `jwks_uri`, ou `sector_identifier_uri`.
- Bien que l'exploitation directe via `request_uris` puisse être atténuée par des contrôles de liste blanche, fournir un `request_uri` préenregistré, contrôlé par un attaquant, peut faciliter le SSRF pendant la phase d'autorisation.

## Conditions de course des fournisseurs OAuth

Si la plateforme que vous testez est un fournisseur OAuth [**lisez ceci pour tester les éventuelles conditions de course**](race-condition.md).

## Attaque sur les revendications mutables

Dans OAuth, le champ sub identifie de manière unique un utilisateur, mais son format varie selon le serveur d'autorisation. Pour standardiser l'identification des utilisateurs, certains clients utilisent des e-mails ou des identifiants d'utilisateur. Cependant, cela est risqué car :

- Certains serveurs d'autorisation ne garantissent pas que ces propriétés (comme l'e-mail) restent immuables.
- Dans certaines implémentations—comme **"Se connecter avec Microsoft"**—le client s'appuie sur le champ e-mail, qui est **contrôlé par l'utilisateur dans Entra ID** et non vérifié.
- Un attaquant peut exploiter cela en créant sa propre organisation Azure AD (par exemple, doyensectestorg) et en l'utilisant pour effectuer une connexion Microsoft.
- Même si l'ID d'objet (stocké dans sub) est immuable et sécurisé, la dépendance à un champ e-mail mutable peut permettre une prise de contrôle de compte (par exemple, le détournement d'un compte comme victim@gmail.com).

## Attaque de confusion de client

Dans une **attaque de confusion de client**, une application utilisant le flux implicite OAuth ne parvient pas à vérifier que le token d'accès final est spécifiquement généré pour son propre ID de client. Un attaquant met en place un site web public qui utilise le flux implicite OAuth de Google, trompant des milliers d'utilisateurs pour se connecter et récoltant ainsi des tokens d'accès destinés au site de l'attaquant. Si ces utilisateurs ont également des comptes sur un autre site vulnérable qui ne valide pas l'ID de client du token, l'attaquant peut réutiliser les tokens récoltés pour usurper l'identité des victimes et prendre le contrôle de leurs comptes.

## Attaque de mise à niveau de portée

Le type **Authorization Code Grant** implique une communication sécurisée entre serveurs pour transmettre des données utilisateur. Cependant, si le **serveur d'autorisation** fait implicitement confiance à un paramètre de portée dans la demande de token d'accès (un paramètre non défini dans le RFC), une application malveillante pourrait augmenter les privilèges d'un code d'autorisation en demandant une portée plus élevée. Après que le **token d'accès** soit généré, le **serveur de ressources** doit le vérifier : pour les tokens JWT, cela implique de vérifier la signature JWT et d'extraire des données telles que client_id et scope, tandis que pour les tokens de chaîne aléatoire, le serveur doit interroger le serveur d'autorisation pour récupérer les détails du token.

## Détournement de schéma de redirection

Dans les implémentations mobiles OAuth, les applications utilisent des **schémas URI personnalisés** pour recevoir des redirections avec des codes d'autorisation. Cependant, parce que plusieurs applications peuvent enregistrer le même schéma sur un appareil, l'hypothèse selon laquelle seul le client légitime contrôle l'URI de redirection est violée. Sur Android, par exemple, un URI d'intention comme `com.example.app://` oauth est capturé en fonction du schéma et des filtres optionnels définis dans le filtre d'intention d'une application. Étant donné que la résolution d'intention d'Android peut être large—surtout si seul le schéma est spécifié—un attaquant peut enregistrer une application malveillante avec un filtre d'intention soigneusement conçu pour détourner le code d'autorisation. Cela peut **permettre une prise de contrôle de compte** soit par interaction utilisateur (lorsque plusieurs applications sont éligibles pour gérer l'intention) ou via des techniques de contournement qui exploitent des filtres trop spécifiques, comme détaillé par le diagramme de flux d'évaluation d'Ostorlab.

## Références

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)

{{#include ../banners/hacktricks-training.md}}
