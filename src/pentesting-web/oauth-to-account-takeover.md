# OAuth ile Hesap Ele Geçirme

{{#include ../banners/hacktricks-training.md}}

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Temel Bilgiler <a href="#d4a8" id="d4a8"></a>

OAuth, temel bilgilerin erişilebilir olduğu çeşitli sürümler sunar; [OAuth 2.0 belgeleri](https://oauth.net/2/) bu konuda bilgi sağlar. Bu tartışma, yaygın olarak kullanılan [OAuth 2.0 yetkilendirme kodu grant türü](https://oauth.net/2/grant-types/authorization-code/) etrafında dönmektedir ve **bir uygulamanın başka bir uygulamadaki bir kullanıcının hesabına erişmesini veya eylemler gerçekleştirmesini sağlayan bir yetkilendirme çerçevesi** sunar (yetkilendirme sunucusu).

Hayali bir web sitesi _**https://example.com**_ düşünün; bu site, **tüm sosyal medya paylaşımlarınızı**, özel olanlar da dahil, **sergilemek** için tasarlanmıştır. Bunu başarmak için OAuth 2.0 kullanılmaktadır. _https://example.com_, **sosyal medya paylaşımlarınıza erişim** izni talep edecektir. Sonuç olarak, _https://socialmedia.com_ üzerinde **talep edilen izinler ve talebi yapan geliştirici** hakkında bilgi veren bir onay ekranı belirecektir. Onayınızla, _https://example.com_, **sizin adınıza paylaşımlarınıza erişim** yetkisi kazanır.

OAuth 2.0 çerçevesindeki aşağıdaki bileşenleri anlamak önemlidir:

- **resource owner**: Siz, **kullanıcı/varlık** olarak, sosyal medya hesabınızdaki paylaşımlar gibi kaynaklarınıza erişim izni verirsiniz.
- **resource server**: Uygulamanın `access token` almasının ardından **kimlik doğrulama isteklerini yöneten sunucu**, örneğin, **https://socialmedia.com**.
- **client application**: `resource owner`dan yetkilendirme talep eden **uygulama**, örneğin, **https://example.com**.
- **authorization server**: `resource owner`ın başarılı bir şekilde kimlik doğrulamasını yaptıktan sonra `client application`a `access tokens` veren **sunucu**, örneğin, **https://socialmedia.com**.
- **client_id**: Uygulama için kamuya açık, benzersiz bir tanımlayıcı.
- **client_secret:** Sadece uygulama ve yetkilendirme sunucusu tarafından bilinen, `access_tokens` oluşturmak için kullanılan gizli bir anahtar.
- **response_type**: **Talep edilen token türünü** belirten bir değer, örneğin `code`.
- **scope**: `client application`ın `resource owner`dan talep ettiği **erişim seviyesi**.
- **redirect_uri**: Kullanıcının yetkilendirmeden sonra yönlendirileceği **URL**. Bu genellikle önceden kaydedilmiş yönlendirme URL'si ile uyumlu olmalıdır.
- **state**: Kullanıcının yetkilendirme sunucusuna yönlendirilmesi sırasında **verileri korumak için bir parametre**. Benzersizliği, **CSRF koruma mekanizması** olarak hizmet etmesi açısından kritik öneme sahiptir.
- **grant_type**: **Verilecek token türünü ve grant türünü** belirten bir parametre.
- **code**: `authorization server`dan alınan yetkilendirme kodu; `client application` tarafından `access_token` almak için `client_id` ve `client_secret` ile birlikte kullanılır.
- **access_token**: `resource owner` adına API istekleri için `client application`ın kullandığı **token**.
- **refresh_token**: Uygulamanın **kullanıcıyı yeniden istemeden yeni bir `access_token` almasını** sağlar.

### Akış

**Gerçek OAuth akışı** şu şekilde ilerler:

1. [https://example.com](https://example.com) adresine gidersiniz ve “Sosyal Medya ile Entegre Ol” butonunu seçersiniz.
2. Site, https://example.com uygulamasının paylaşımlarınıza erişim izni talep etmek için [https://socialmedia.com](https://socialmedia.com) adresine bir istek gönderir. İstek şu şekilde yapılandırılmıştır:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Ardından bir onay sayfası ile karşılaşırsınız.  
4. Onayınızın ardından, Sosyal Medya `code` ve `state` parametreleri ile `redirect_uri`'ye bir yanıt gönderir:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com bu `code`'u, `client_id` ve `client_secret` ile birlikte kullanarak, sizin adınıza bir sunucu tarafı isteği yapar ve sizin onayladığınız izinlere erişim sağlayan bir `access_token` alır:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Son olarak, süreç https://example.com `access_token`'ınızı kullanarak Sosyal Medya'ya API çağrısı yaparak sona erer.

## Güvenlik Açıkları <a href="#id-323a" id="id-323a"></a>

### Açık redirect_uri <a href="#cc36" id="cc36"></a>

`redirect_uri`, OAuth ve OpenID uygulamalarında güvenlik için kritik öneme sahiptir, çünkü yetkilendirme kodları gibi hassas verilerin yetkilendirme sonrası nereye gönderileceğini yönlendirir. Yanlış yapılandırıldığında, saldırganların bu istekleri kötü niyetli sunuculara yönlendirmesine izin verebilir ve hesap ele geçirme olanağı tanır.

Sömürü teknikleri, yetkilendirme sunucusunun doğrulama mantığına bağlı olarak değişir. Katı yol eşleşmesinden, belirtilen alan veya alt dizin içindeki herhangi bir URL'yi kabul etmeye kadar değişebilir. Yaygın sömürü yöntemleri arasında açık yönlendirmeler, yol geçişi, zayıf regex'lerin sömürülmesi ve token hırsızlığı için HTML enjeksiyonu yer alır.

`redirect_uri` dışında, `client_uri`, `policy_uri`, `tos_uri` ve `initiate_login_uri` gibi diğer OAuth ve OpenID parametreleri de yönlendirme saldırılarına karşı hassastır. Bu parametreler isteğe bağlıdır ve destekleri sunucular arasında değişiklik gösterir.

OpenID sunucusunu hedef alanlar için, keşif uç noktası (`**.well-known/openid-configuration**`) genellikle `registration_endpoint`, `request_uri_parameter_supported` ve "`require_request_uri_registration`" gibi değerli yapılandırma ayrıntılarını listeler. Bu ayrıntılar, kayıt uç noktasını ve sunucunun diğer yapılandırma özelliklerini belirlemede yardımcı olabilir.

### Yönlendirme uygulamasında XSS <a href="#bda5" id="bda5"></a>

Bu hata ödülü raporunda belirtildiği gibi [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) yönlendirme **URL'sinin, kullanıcı kimlik doğruladıktan sonra sunucunun yanıtında yansıtılması** mümkün olabilir ve **XSS'ye karşı savunmasızdır**. Test etmek için olası yük:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - State parametresinin yanlış yönetimi <a href="#bda5" id="bda5"></a>

OAuth uygulamalarında, **`state` parametresinin** kötüye kullanımı veya atlanması, **Cross-Site Request Forgery (CSRF)** saldırılarının riskini önemli ölçüde artırabilir. Bu zafiyet, `state` parametresinin **kullanılmaması, statik bir değer olarak kullanılması veya düzgün bir şekilde doğrulanmaması** durumunda ortaya çıkar ve saldırganların CSRF korumalarını aşmasına olanak tanır.

Saldırganlar, yetkilendirme sürecini keserek kendi hesaplarını bir mağdurun hesabıyla ilişkilendirebilir, bu da potansiyel **hesap ele geçirmelerine** yol açar. Bu, OAuth'un **kimlik doğrulama amaçları** için kullanıldığı uygulamalarda özellikle kritik öneme sahiptir.

Bu zafiyetin gerçek dünya örnekleri, çeşitli **CTF yarışmaları** ve **hackleme platformları** üzerinde belgelenmiştir ve pratik etkilerini vurgulamaktadır. Sorun, **Slack**, **Stripe** ve **PayPal** gibi üçüncü taraf hizmetlerle entegrasyonlara da uzanmakta, burada saldırganlar bildirimleri veya ödemeleri kendi hesaplarına yönlendirebilmektedir.

**`state` parametresinin** doğru bir şekilde yönetimi ve doğrulanması, CSRF'ye karşı korunmak ve OAuth akışını güvence altına almak için kritik öneme sahiptir.

### Hesap Ele Geçirmeden Önce <a href="#ebe4" id="ebe4"></a>

1. **Hesap Oluşturma sırasında E-posta Doğrulaması Olmadan**: Saldırganlar, mağdurun e-posta adresini kullanarak önceden bir hesap oluşturabilir. Eğer mağdur daha sonra bir üçüncü taraf hizmeti ile giriş yaparsa, uygulama bu üçüncü taraf hesabını saldırganın önceden oluşturduğu hesapla yanlışlıkla ilişkilendirebilir ve yetkisiz erişime yol açabilir.
2. **Gevşek OAuth E-posta Doğrulamasını Kötüye Kullanma**: Saldırganlar, e-postaları doğrulamayan OAuth hizmetlerini kötüye kullanarak kendi hizmetleriyle kaydolabilir ve ardından hesap e-posta adresini mağdurunki ile değiştirebilir. Bu yöntem, ilk senaryoya benzer şekilde yetkisiz hesap erişimi riski taşır, ancak farklı bir saldırı vektörü aracılığıyla gerçekleşir.

### Gizli Bilgilerin Açığa Çıkması <a href="#e177" id="e177"></a>

Gizli OAuth parametrelerini tanımlamak ve korumak çok önemlidir. **`client_id`** güvenle ifşa edilebilirken, **`client_secret`** ifşa edilmesi önemli riskler taşır. Eğer `client_secret` ele geçirilirse, saldırganlar uygulamanın kimliğini ve güvenini kötüye kullanarak **kullanıcı `access_tokens`** ve özel bilgileri çalabilir.

Uygulamaların yetkilendirme `code`'unu `access_token` ile istemci tarafında değil, sunucu tarafında yanlışlıkla yönetmesi durumunda yaygın bir zafiyet ortaya çıkar. Bu hata, `client_secret`'in açığa çıkmasına yol açar ve saldırganların uygulamanın kimliğini kullanarak `access_tokens` oluşturmasına olanak tanır. Ayrıca, sosyal mühendislik yoluyla, saldırganlar OAuth yetkilendirmesine ek kapsamlar ekleyerek ayrıcalıkları artırabilir ve uygulamanın güvenilir durumunu daha da kötüye kullanabilir.

### Client Secret Bruteforce

Bir hizmet sağlayıcının client_secret'ını çalmak için kimlik sağlayıcı ile **bruteforce** yapmayı deneyebilirsiniz.\
BF isteği şu şekilde görünebilir:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header sızdıran Kod + State

Müşteri **kod ve state**'e sahip olduğunda, eğer bu **Referer header içinde yansıyorsa** ve farklı bir sayfaya gittiğinde, o zaman savunmasızdır.

### Tarayıcı Geçmişinde Saklanan Erişim Token'ı

**Tarayıcı geçmişine gidin ve erişim token'ının orada kaydedilip kaydedilmediğini kontrol edin**.

### Sürekli Yetkilendirme Kodu

**Yetkilendirme kodu, bir saldırganın onu çalabileceği ve kullanabileceği zaman penceresini sınırlamak için sadece bir süre boyunca geçerli olmalıdır**.

### Yetkilendirme/Yenileme Token'ı istemciye bağlı değil

Eğer **yetkilendirme kodunu alabilir ve farklı bir istemci ile kullanabilirseniz, diğer hesapları ele geçirebilirsiniz**.

### Mutlu Yollar, XSS, Iframe'ler ve Kod & State değerlerini sızdırmak için Post Mesajları

[**Bu gönderiyi kontrol edin**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

Bu hata ödül raporunda: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) **AWS Cognito**'nun kullanıcıya geri verdiği **token**'ın **kullanıcı verilerini üzerine yazmak için yeterli izinlere sahip olabileceğini** görebilirsiniz. Bu nedenle, eğer **bir kullanıcı e-posta adresini farklı bir kullanıcı e-posta adresi ile değiştirebilirseniz**, diğer hesapları **ele geçirebilirsiniz**.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
AWS cognito'yu nasıl kötüye kullanacağınız hakkında daha ayrıntılı bilgi için kontrol edin:

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### Diğer Uygulama token'larını Kötüye Kullanma <a href="#bda5" id="bda5"></a>

[**bu yazıda bahsedildiği gibi**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), **token** (ve kod değil) almayı bekleyen OAuth akışları, token'ın uygulamaya ait olduğunu kontrol etmedikleri takdirde savunmasız olabilir.

Bu, bir **saldırganın** kendi uygulamasında **OAuth destekleyen ve Facebook ile giriş yapan bir uygulama** oluşturabileceği anlamına gelir. Daha sonra, bir kurban Facebook ile **saldırganın uygulamasına** giriş yaptığında, saldırgan **kullanıcının uygulamasına verilen OAuth token'ını alabilir ve bunu kurbanın OAuth uygulamasında kurbanın kullanıcı token'ı ile giriş yapmak için kullanabilir**.

> [!CAUTION]
> Bu nedenle, eğer saldırgan kullanıcıyı kendi OAuth uygulamasına eriştirmeyi başarırsa, token bekleyen ve token'ın kendi uygulama kimliğine verilip verilmediğini kontrol etmeyen uygulamalarda kurbanın hesabını ele geçirebilir.

### İki Bağlantı & Çerez <a href="#bda5" id="bda5"></a>

[**bu yazıya göre**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), bir kurbanın saldırganın ana bilgisayarına işaret eden bir **returnUrl** ile bir sayfa açması sağlanabiliyordu. Bu bilgi **bir çerezde (RU)** saklanacak ve **sonraki adımda** **istem** **kullanıcıya** o saldırganın ana bilgisayarına erişim vermek isteyip istemediğini **soracaktır**.

Bu istemi atlatmak için, **returnUrl** kullanarak bu RU çerezini ayarlayacak şekilde **Oauth akışını başlatmak için** bir sekme açmak, istem gösterilmeden önce sekmeyi kapatmak ve o değeri içermeyen yeni bir sekme açmak mümkündü. Böylece, **istem saldırganın ana bilgisayarından bahsetmeyecek**, ancak çerez ona ayarlanacak, bu nedenle **token saldırganın ana bilgisayarına** yönlendirme sırasında gönderilecektir.

### İstem Etkileşimi Atlatma <a href="#bda5" id="bda5"></a>

[**bu videoda açıklandığı gibi**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), bazı OAuth uygulamaları, kullanıcıların platformda zaten giriş yapmışlarsa webde verilen erişimi onaylamaları için **`prompt`** GET parametresini None (**`&prompt=none`**) olarak belirtmelerine izin verir.

### response_mode

[**bu videoda açıklandığı gibi**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), **`response_mode`** parametresini, kodun son URL'de nerede sağlanmasını istediğinizi belirtmek için kullanmak mümkün olabilir:

- `response_mode=query` -> Kod bir GET parametresi içinde sağlanır: `?code=2397rf3gu93f`
- `response_mode=fragment` -> Kod URL parçası parametresi içinde sağlanır `#code=2397rf3gu93f`
- `response_mode=form_post` -> Kod, `code` adında bir girdi ile bir POST formu içinde sağlanır ve değer
- `response_mode=web_message` -> Kod bir post mesajında gönderilir: `window.opener.postMessage({"code": "asdasdasd...`

### OAuth ROPC akışı - 2 FA atlatma <a href="#b440" id="b440"></a>

[**bu blog yazısına göre**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), bu, OAuth üzerinden **kullanıcı adı** ve **şifre** ile giriş yapmayı sağlayan bir OAuth akışıdır. Bu basit akış sırasında, kullanıcının gerçekleştirebileceği tüm eylemlere erişim sağlayan bir **token** dönerse, bu token kullanılarak 2FA atlatılabilir.

### Açık yönlendirmeye dayalı web sayfasında ATO <a href="#bda5" id="bda5"></a>

Bu [**blog yazısı**](https://blog.voorivex.team/oauth-non-happy-path-to-ato), bir **açık yönlendirmeyi** referans değerinden yararlanarak OAuth'u ATO'ya kötüye kullanmanın nasıl mümkün olduğunu yorumlamaktadır. Saldırı şu şekildedir:

1. Kurban saldırganın web sayfasına erişir
2. Kurban kötü niyetli bağlantıyı açar ve bir açıcı, **saldırganın web sitesi** referansını kullanarak `response_type=id_token,code&prompt=none` ek parametreleri ile Google OAuth akışını başlatır.
3. Açıcıda, sağlayıcı kurbanı yetkilendirdikten sonra, onları `redirect_uri` parametresinin değerine (kurban web) 30X kodu ile geri gönderir ve bu hala saldırganın web sitesini referans olarak tutar.
4. Kurban **web sitesi, referansa dayalı açık yönlendirmeyi tetikler** ve kurban kullanıcıyı saldırganın web sitesine yönlendirir, çünkü **`respose_type`** **`id_token,code`** olduğundan, kod saldırgana **URL'nin parçasında** geri gönderilecektir, bu da onun kurbanın sitesinde Google aracılığıyla kullanıcının hesabını ele geçirmesine olanak tanır.

### SSRF'lerin parametreleri <a href="#bda5" id="bda5"></a>

[**Bu araştırmayı kontrol edin**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Bu tekniğin daha fazla ayrıntısı için.**

OAuth'taki Dinamik İstemci Kaydı, güvenlik açıkları için daha az belirgin ama kritik bir vektör olarak hizmet eder, özellikle **Sunucu Tarafı İstek Sahteciliği (SSRF)** saldırıları için. Bu uç nokta, OAuth sunucularının istemci uygulamaları hakkında, kötüye kullanılabilecek hassas URL'ler de dahil olmak üzere ayrıntılar almasına olanak tanır.

**Ana Noktalar:**

- **Dinamik İstemci Kaydı**, genellikle `/register` ile eşleştirilir ve `client_name`, `client_secret`, `redirect_uris` ve POST istekleri aracılığıyla logolar veya JSON Web Anahtar Setleri (JWK'ler) için URL'ler gibi ayrıntıları kabul eder.
- Bu özellik, **RFC7591** ve **OpenID Connect Kaydı 1.0**'da belirtilen spesifikasyonlara uyar; bu, SSRF'ye karşı potansiyel olarak savunmasız parametreleri içerir.
- Kayıt süreci, birkaç şekilde sunucuları SSRF'ye maruz bırakabilir:
- **`logo_uri`**: Sunucu tarafından alınabilecek istemci uygulamasının logosu için bir URL, bu da SSRF'yi tetikleyebilir veya URL yanlış yönetilirse XSS'ye yol açabilir.
- **`jwks_uri`**: Kötü niyetle oluşturulursa, sunucunun saldırgan kontrolündeki bir sunucuya dışa dönük istekler yapmasına neden olabilecek istemcinin JWK belgesine bir URL.
- **`sector_identifier_uri`**: Sunucunun alabileceği `redirect_uris` JSON dizisini referans alır ve bu da SSRF fırsatı yaratır.
- **`request_uris`**: İstemci için izin verilen istek URI'lerini listeler; bu, sunucu bu URI'leri yetkilendirme sürecinin başında alırsa kötüye kullanılabilir.

**Kötüye Kullanım Stratejisi:**

- SSRF, `logo_uri`, `jwks_uri` veya `sector_identifier_uri` gibi parametrelerde kötü niyetli URL'lerle yeni bir istemci kaydederek tetiklenebilir.
- `request_uris` aracılığıyla doğrudan kötüye kullanım, beyaz liste kontrolleri ile azaltılabilirken, önceden kaydedilmiş, saldırgan kontrolündeki bir `request_uri` sağlamak, yetkilendirme aşamasında SSRF'yi kolaylaştırabilir.

## OAuth sağlayıcıları Yarış Koşulları

Test ettiğiniz platform bir OAuth sağlayıcısıysa [**olası Yarış Koşullarını test etmek için bunu okuyun**](race-condition.md).

## Referanslar

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

{{#include ../banners/hacktricks-training.md}}
