# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Basic Information <a href="#d4a8" id="d4a8"></a>

OAuth, çeşitli versiyonlar sunar ve temel bilgiler [OAuth 2.0 belgeleri](https://oauth.net/2/) adresinde mevcuttur. Bu tartışma, yaygın olarak kullanılan [OAuth 2.0 yetkilendirme kodu hibe türü](https://oauth.net/2/grant-types/authorization-code/) etrafında dönmektedir ve **bir uygulamanın başka bir uygulamadaki bir kullanıcının hesabına erişmesini veya eylemler gerçekleştirmesini sağlayan bir yetkilendirme çerçevesi** sunmaktadır (yetkilendirme sunucusu).

Hayali bir web sitesi _**https://example.com**_ düşünün; bu site, **tüm sosyal medya paylaşımlarınızı**, özel olanlar da dahil, **sergilemek** için tasarlanmıştır. Bunu başarmak için OAuth 2.0 kullanılmaktadır. _https://example.com_, **sosyal medya paylaşımlarınıza erişim** izni talep edecektir. Sonuç olarak, _https://socialmedia.com_ üzerinde, **talep edilen izinler ve talebi yapan geliştirici** hakkında bilgi veren bir onay ekranı belirecektir. Onayınızla, _https://example.com_, **paylaşımlarınıza sizin adınıza erişim** sağlama yetkisi kazanır.

OAuth 2.0 çerçevesi içindeki aşağıdaki bileşenleri anlamak önemlidir:

- **resource owner**: Siz, **kullanıcı/varlık** olarak, sosyal medya hesabı paylaşımlarınız gibi kaynaklarınıza erişim izni verirsiniz.
- **resource server**: **Kimlik doğrulama isteklerini yöneten sunucu**, uygulama `access token` alındıktan sonra, `resource owner` adına, örneğin, **https://socialmedia.com**.
- **client application**: `resource owner`'dan yetkilendirme talep eden **uygulama**, örneğin, **https://example.com**.
- **authorization server**: `resource owner`'ın başarılı bir şekilde kimlik doğrulamasını yaptıktan sonra `client application`'a `access tokens` veren **sunucu**, örneğin, **https://socialmedia.com**.
- **client_id**: Uygulama için kamuya açık, benzersiz bir tanımlayıcı.
- **client_secret:** Sadece uygulama ve yetkilendirme sunucusu tarafından bilinen, `access_tokens` oluşturmak için kullanılan gizli bir anahtar.
- **response_type**: **Talep edilen token türünü** belirten bir değer, örneğin `code`.
- **scope**: `client application`'ın `resource owner`'dan talep ettiği **erişim seviyesi**.
- **redirect_uri**: **Kullanıcının yetkilendirmeden sonra yönlendirileceği URL**. Bu genellikle önceden kaydedilmiş yönlendirme URL'si ile uyumlu olmalıdır.
- **state**: **Kullanıcının yetkilendirme sunucusuna yönlendirilmesi sırasında verileri korumak için** bir parametre. Benzersizliği, **CSRF koruma mekanizması** olarak hizmet etmesi açısından kritik öneme sahiptir.
- **grant_type**: **Hibe türünü ve döndürülecek token türünü** belirten bir parametre.
- **code**: `authorization server`'dan alınan yetkilendirme kodu, `client application` tarafından `access_token` almak için `client_id` ve `client_secret` ile birlikte kullanılır.
- **access_token**: `resource owner` adına API istekleri için **client application** tarafından kullanılan token.
- **refresh_token**: Uygulamanın **kullanıcıyı yeniden istemeden yeni bir `access_token` almasını** sağlar.

### Flow

**Gerçek OAuth akışı** şu şekilde ilerler:

1. [https://example.com](https://example.com) adresine gidersiniz ve “Sosyal Medya ile Entegre Ol” butonunu seçersiniz.
2. Site, https://example.com uygulamasının paylaşımlarınıza erişim izni talep etmek için [https://socialmedia.com](https://socialmedia.com) adresine bir istek gönderir. İstek şu şekilde yapılandırılmıştır:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Ardından bir onay sayfası ile karşılaşırsınız.  
4. Onayınızı takiben, Sosyal Medya `code` ve `state` parametreleri ile `redirect_uri`'ye bir yanıt gönderir:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com bu `code`'u, `client_id` ve `client_secret` ile birlikte, sizin adınıza bir `access_token` almak için sunucu tarafında bir istek yapmak üzere kullanır ve onayladığınız izinlere erişim sağlar:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Son olarak, süreç https://example.com `access_token`'ınızı kullanarak Sosyal Medya'ya API çağrısı yaparak sona erer.

## Güvenlik Açıkları <a href="#id-323a" id="id-323a"></a>

### Açık redirect_uri <a href="#cc36" id="cc36"></a>

`redirect_uri`, OAuth ve OpenID uygulamalarında güvenlik için kritik öneme sahiptir, çünkü yetkilendirme kodları gibi hassas verilerin yetkilendirme sonrası nereye gönderileceğini yönlendirir. Yanlış yapılandırıldığında, saldırganların bu istekleri kötü niyetli sunuculara yönlendirmesine izin verebilir, bu da hesap ele geçirmeye yol açabilir.

Sömürü teknikleri, yetkilendirme sunucusunun doğrulama mantığına bağlı olarak değişir. Katı yol eşleşmesinden, belirtilen alan veya alt dizin içindeki herhangi bir URL'yi kabul etmeye kadar değişebilir. Yaygın sömürü yöntemleri arasında açık yönlendirmeler, yol geçişi, zayıf regexlerin istismarı ve token hırsızlığı için HTML enjeksiyonu bulunmaktadır.

`redirect_uri` dışında, `client_uri`, `policy_uri`, `tos_uri` ve `initiate_login_uri` gibi diğer OAuth ve OpenID parametreleri de yönlendirme saldırılarına karşı hassastır. Bu parametreler isteğe bağlıdır ve destekleri sunucular arasında değişiklik gösterir.

OpenID sunucusunu hedef alanlar için, keşif uç noktası (`**.well-known/openid-configuration**`) genellikle `registration_endpoint`, `request_uri_parameter_supported` ve "`require_request_uri_registration`" gibi değerli yapılandırma ayrıntılarını listeler. Bu ayrıntılar, kayıt uç noktasını ve sunucunun diğer yapılandırma özelliklerini belirlemede yardımcı olabilir.

### Yönlendirme uygulamasında XSS <a href="#bda5" id="bda5"></a>

Bu hata ödülü raporunda belirtildiği gibi [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) yönlendirme **URL'sinin, kullanıcı kimlik doğruladıktan sonra sunucunun yanıtında yansıtılması** mümkün olabilir, bu da **XSS'ye karşı savunmasızdır**. Test etmek için olası yük:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - State parametresinin yanlış yönetimi <a href="#bda5" id="bda5"></a>

OAuth uygulamalarında, **`state` parametresinin** kötüye kullanımı veya atlanması, **Cross-Site Request Forgery (CSRF)** saldırılarının riskini önemli ölçüde artırabilir. Bu zafiyet, `state` parametresinin **kullanılmaması, statik bir değer olarak kullanılması veya kullanıcı oturumu ile doğru bir şekilde doğrulanmaması veya ilişkilendirilmemesi** durumunda ortaya çıkar ve saldırganların CSRF korumalarını aşmasına olanak tanır.

Saldırganlar, yetkilendirme sürecini keserek kendi hesaplarını bir mağdurun hesabıyla ilişkilendirebilir, bu da bir kullanıcının saldırgana ait neredeyse tamamlanmış bir oauth akışıyla giriş yapmasını sağlayarak potansiyel **hesap ele geçirmelerine** yol açar. Bu, OAuth'un **kimlik doğrulama amaçları** için kullanıldığı uygulamalarda özellikle kritik öneme sahiptir.

Bu zafiyetin gerçek dünya örnekleri, çeşitli **CTF yarışmaları** ve **hackleme platformlarında** belgelenmiştir ve pratik etkilerini vurgulamaktadır. Sorun, saldırganların bildirimleri veya ödemeleri kendi hesaplarına yönlendirebileceği **Slack**, **Stripe** ve **PayPal** gibi üçüncü taraf hizmetlerle entegrasyonlara da uzanmaktadır.

**`state` parametresinin** doğru yönetimi ve doğrulanması, CSRF'ye karşı korunmak ve OAuth akışını güvence altına almak için kritik öneme sahiptir.

### Hesap Ele Geçirmeden Önce <a href="#ebe4" id="ebe4"></a>

1. **Hesap Oluşturma sırasında E-posta Doğrulaması Olmadan**: Saldırganlar, mağdurun e-posta adresini kullanarak önceden bir hesap oluşturabilir. Eğer mağdur daha sonra bir üçüncü taraf hizmeti ile giriş yaparsa, uygulama bu üçüncü taraf hesabını saldırganın önceden oluşturduğu hesapla yanlışlıkla ilişkilendirebilir ve yetkisiz erişime yol açabilir.
2. **Gevşek OAuth E-posta Doğrulamasını Kötüye Kullanma**: Saldırganlar, e-postaları doğrulamayan OAuth hizmetlerini kötüye kullanarak kendi hizmetleriyle kaydolabilir ve ardından hesap e-posta adresini mağdurunki ile değiştirebilir. Bu yöntem, ilk senaryoya benzer şekilde yetkisiz hesap erişimi riski taşır, ancak farklı bir saldırı vektörü aracılığıyla.

### Gizli Bilgilerin Açığa Çıkması <a href="#e177" id="e177"></a>

Gizli OAuth parametrelerini tanımlamak ve korumak çok önemlidir. **`client_id`** güvenle ifşa edilebilirken, **`client_secret`** ifşa edilmesi önemli riskler taşır. Eğer `client_secret` ele geçirilirse, saldırganlar uygulamanın kimliğini ve güvenini kötüye kullanarak **kullanıcı `access_tokens`** ve özel bilgileri çalabilir.

Uygulamaların yetkilendirme `code`'unu `access_token` ile istemci tarafında değil, sunucu tarafında yanlışlıkla ele alması durumunda yaygın bir zafiyet ortaya çıkar. Bu hata, `client_secret`'in açığa çıkmasına yol açar ve saldırganların uygulamanın kılığına girerek `access_tokens` üretmesine olanak tanır. Ayrıca, sosyal mühendislik yoluyla, saldırganlar OAuth yetkilendirmesine ek kapsamlar ekleyerek ayrıcalıkları artırabilir ve uygulamanın güvenilir durumunu daha da kötüye kullanabilir.

### Client Secret Bruteforce

Bir hizmet sağlayıcının client_secret'ını çalmak için kimlik sağlayıcı ile **bruteforce** yapmayı deneyebilirsiniz.\
BF isteği şu şekilde görünebilir:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header sızdıran Kod + Durum

Müşteri **kod ve duruma** sahip olduğunda, eğer bu **Referer başlığında yansıtılıyorsa** ve farklı bir sayfaya gittiğinde, o zaman savunmasızdır.

### Tarayıcı Geçmişinde Saklanan Erişim Token'ı

**Tarayıcı geçmişine gidin ve erişim token'ının orada kaydedilip kaydedilmediğini kontrol edin**.

### Sürekli Yetkilendirme Kodu

**Yetkilendirme kodu, bir saldırganın onu çalabileceği ve kullanabileceği zaman penceresini sınırlamak için sadece bir süre boyunca geçerli olmalıdır**.

### Yetkilendirme/Yenileme Token'ı istemciye bağlı değil

Eğer **yetkilendirme kodunu alabilir ve bunu farklı bir istemci ile kullanabilirseniz, diğer hesapları ele geçirebilirsiniz**.

### Mutlu Yollar, XSS, Iframe'ler ve Kod & Durum değerlerini sızdırmak için Post Mesajları

[**Bu gönderiyi kontrol edin**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

Bu hata ödül raporunda: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) **AWS Cognito** tarafından kullanıcıya geri verilen **token'ın** **kullanıcı verilerini üzerine yazmak için yeterli izinlere sahip olabileceğini** görebilirsiniz. Bu nedenle, eğer **bir kullanıcı e-posta adresini farklı bir kullanıcı e-posta adresi ile değiştirebilirseniz**, diğer hesapları **ele geçirebilirsiniz**.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Daha fazla bilgi için AWS cognito'yu nasıl kötüye kullanacağınızı kontrol edin:

{{#ref}}
https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html
{{#endref}}

### Diğer Uygulama token'larını Kötüye Kullanma <a href="#bda5" id="bda5"></a>

[**bu yazıda bahsedildiği gibi**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), **token** (ve kod değil) almayı bekleyen OAuth akışları, token'ın uygulamaya ait olduğunu kontrol etmedikleri takdirde savunmasız olabilir.

Bu, bir **saldırganın** kendi uygulamasında **OAuth destekleyen bir uygulama oluşturup Facebook ile giriş yapması** (örneğin) nedeniyle mümkündür. Daha sonra, bir kurban Facebook ile **saldırganın uygulamasında** giriş yaptığında, saldırgan **kullanıcının uygulamasına verilen OAuth token'ını alabilir ve bunu kurbanın OAuth uygulamasında kurbanın kullanıcı token'ı ile giriş yapmak için kullanabilir**.

> [!CAUTION]
> Bu nedenle, eğer saldırgan kullanıcıyı kendi OAuth uygulamasına eriştirmeyi başarırsa, token bekleyen ve token'ın kendi uygulama kimliğine verilip verilmediğini kontrol etmeyen uygulamalarda kurbanın hesabını ele geçirebilir.

### İki bağlantı & çerez <a href="#bda5" id="bda5"></a>

[**bu yazıya göre**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), bir kurbanın saldırganın ana bilgisayarına işaret eden bir **returnUrl** ile bir sayfa açması sağlanabiliyordu. Bu bilgi **bir çerezde (RU)** saklanacak ve **sonraki adımda** **istem** kullanıcının o saldırgan ana bilgisayara erişim vermek isteyip istemediğini **soracaktır**.

Bu istemi atlatmak için, **returnUrl** kullanarak bu RU çerezini ayarlamak için **Oauth akışını başlatmak** amacıyla bir sekme açmak, istem gösterilmeden önce sekmeyi kapatmak ve bu değeri içermeyen yeni bir sekme açmak mümkündü. Böylece, **istem saldırganın ana bilgisayarından bahsetmeyecek**, ancak çerez ona ayarlanacak, bu nedenle **token saldırganın ana bilgisayarına** yönlendirme sırasında gönderilecektir.

### İstem Etkileşimi Atlatma <a href="#bda5" id="bda5"></a>

[**bu videoda açıklandığı gibi**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), bazı OAuth uygulamaları, kullanıcıların platformda zaten giriş yapmışlarsa webde verilen erişimi onaylamaları için bir istemde sorulmasını **önlemek** amacıyla **`prompt`** GET parametresini None (**`&prompt=none`**) olarak belirtmeye izin verir.

### response_mode

[**bu videoda açıklandığı gibi**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), **`response_mode`** parametresini, kodun son URL'de nerede sağlanmasını istediğinizi belirtmek için kullanmak mümkün olabilir:

- `response_mode=query` -> Kod bir GET parametresi içinde sağlanır: `?code=2397rf3gu93f`
- `response_mode=fragment` -> Kod URL parça parametresi içinde sağlanır `#code=2397rf3gu93f`
- `response_mode=form_post` -> Kod, `code` adında bir girdi ile bir POST formu içinde sağlanır ve değer
- `response_mode=web_message` -> Kod bir post mesajında gönderilir: `window.opener.postMessage({"code": "asdasdasd...`

### OAuth ROPC akışı - 2 FA atlatma <a href="#b440" id="b440"></a>

[**bu blog yazısına göre**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), bu, OAuth üzerinden **kullanıcı adı** ve **şifre** ile giriş yapmayı sağlayan bir OAuth akışıdır. Bu basit akış sırasında, kullanıcının gerçekleştirebileceği tüm eylemlere erişim sağlayan bir **token** dönerse, bu token kullanılarak 2FA atlatılabilir.

### Açık yönlendirmeye dayalı web sayfasında ATO <a href="#bda5" id="bda5"></a>

Bu [**blog yazısı**](https://blog.voorivex.team/oauth-non-happy-path-to-ato), bir **açık yönlendirmeyi** kullanarak **referrer** değerini kötüye kullanarak OAuth'u ATO'ya nasıl kötüye kullanabileceğinizi anlatıyor. Saldırı şu şekildeydi:

1. Kurban saldırganın web sayfasına erişir.
2. Kurban kötü niyetli bağlantıyı açar ve bir açıcı, `response_type=id_token,code&prompt=none` ek parametreleri ile Google OAuth akışını başlatır, **referrer olarak saldırganın web sitesini** kullanarak.
3. Açıcıda, sağlayıcı kurbanı yetkilendirdikten sonra, onları `redirect_uri` parametresinin değerine (kurban web) 30X kodu ile geri gönderir, bu da hala saldırganın web sitesini referans olarak tutar.
4. Kurban **web sitesi, referere dayalı açık yönlendirmeyi tetikler** ve kurban kullanıcıyı saldırganın web sitesine yönlendirir, çünkü **`respose_type`** **`id_token,code`** olduğundan, kod saldırgana **URL'nin parçasında** geri gönderilecektir, bu da onun kurbanın hesabını Google üzerinden ele geçirmesine olanak tanır.

### SSRF'lerin parametreleri <a href="#bda5" id="bda5"></a>

[**Bu araştırmayı kontrol edin**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Bu tekniğin daha fazla ayrıntısı için.**

OAuth'taki Dinamik İstemci Kaydı, güvenlik açıkları için daha az belirgin ama kritik bir vektör olarak, özellikle **Sunucu Tarafı İstek Sahteciliği (SSRF)** saldırıları için hizmet eder. Bu uç nokta, OAuth sunucularının istemci uygulamaları hakkında, kötüye kullanılabilecek hassas URL'ler de dahil olmak üzere ayrıntılar almasına olanak tanır.

**Ana Noktalar:**

- **Dinamik İstemci Kaydı**, genellikle `/register` ile eşleştirilir ve `client_name`, `client_secret`, `redirect_uris` ve POST istekleri aracılığıyla logolar veya JSON Web Anahtar Setleri (JWK'ler) için URL'ler gibi ayrıntıları kabul eder.
- Bu özellik, **RFC7591** ve **OpenID Connect Kaydı 1.0**'da belirtilen spesifikasyonlara uyar ve SSRF'ye potansiyel olarak savunmasız olabilecek parametreleri içerir.
- Kayıt süreci, birkaç şekilde sunucuları SSRF'ye maruz bırakabilir:
- **`logo_uri`**: Sunucu tarafından alınabilecek istemci uygulamasının logosu için bir URL, SSRF'yi tetikleyebilir veya URL yanlış yönetilirse XSS'ye yol açabilir.
- **`jwks_uri`**: İstemcinin JWK belgesine giden bir URL, kötü niyetle oluşturulursa, sunucunun saldırgan kontrolündeki bir sunucuya dışa dönük istekler yapmasına neden olabilir.
- **`sector_identifier_uri`**: Sunucunun alabileceği `redirect_uris` JSON dizisini referans alır ve bu, SSRF fırsatı yaratabilir.
- **`request_uris`**: İstemci için izin verilen istek URI'lerini listeler, bu da sunucunun yetkilendirme sürecinin başında bu URI'leri alması durumunda kötüye kullanılabilir.

**Kötüye Kullanım Stratejisi:**

- SSRF, `logo_uri`, `jwks_uri` veya `sector_identifier_uri` gibi parametrelerde kötü niyetli URL'ler ile yeni bir istemci kaydederek tetiklenebilir.
- `request_uris` aracılığıyla doğrudan kötüye kullanım, beyaz liste kontrolleri ile azaltılabilirken, önceden kaydedilmiş, saldırgan kontrolündeki bir `request_uri` sağlamak, yetkilendirme aşamasında SSRF'yi kolaylaştırabilir.

## OAuth sağlayıcıları Yarış Koşulları

Test ettiğiniz platform bir OAuth sağlayıcısıysa [**olası Yarış Koşullarını test etmek için bunu okuyun**](race-condition.md).

## Değişken İddialar Saldırısı

OAuth'ta, sub alanı bir kullanıcıyı benzersiz olarak tanımlar, ancak formatı Yetkilendirme Sunucusuna göre değişir. Kullanıcı tanımlamasını standart hale getirmek için bazı istemciler e-posta veya kullanıcı tanıtıcıları kullanır. Ancak bu risklidir çünkü:

- Bazı Yetkilendirme Sunucuları, bu özelliklerin (örneğin e-posta) değişmez kalmasını sağlamaz.
- Bazı uygulamalarda—**"Microsoft ile Giriş"** gibi—istemci e-posta alanına dayanır, bu da **Entra ID'de kullanıcı tarafından kontrol edilir** ve doğrulanmaz.
- Bir saldırgan, kendi Azure AD organizasyonunu (örneğin, doyensectestorg) oluşturarak bunu kötüye kullanabilir ve Microsoft girişi gerçekleştirebilir.
- Sub'da saklanan Nesne Kimliği (Object ID) değişmez ve güvenli olsa da, değişken bir e-posta alanına dayanmak, bir hesap ele geçirmeye olanak tanıyabilir (örneğin, victim@gmail.com gibi bir hesabı ele geçirmek).

## İstemci Karışıklığı Saldırısı

Bir **İstemci Karışıklığı Saldırısı**'nda, OAuth İkili Akışını kullanan bir uygulama, nihai erişim token'ının özel olarak kendi İstemci Kimliği için oluşturulduğunu doğrulamakta başarısız olur. Bir saldırgan, Google’ın OAuth İkili Akışını kullanan bir kamu web sitesi kurar, binlerce kullanıcıyı giriş yapmaya kandırarak saldırganın sitesine yönelik erişim token'larını toplar. Bu kullanıcıların, token'ın İstemci Kimliğini doğrulamayan başka bir savunmasız web sitesinde de hesapları varsa, saldırgan topladığı token'ları kurbanları taklit etmek ve hesaplarını ele geçirmek için yeniden kullanabilir.

## Kapsam Yükseltme Saldırısı

**Yetkilendirme Kodu Grant** türü, kullanıcı verilerini iletmek için güvenli sunucu-sunucu iletişimini içerir. Ancak, eğer **Yetkilendirme Sunucusu**, Erişim Token'ı İsteği'ndeki bir kapsam parametresine dolaylı olarak güveniyorsa (RFC'de tanımlanmayan bir parametre), kötü niyetli bir uygulama, daha yüksek bir kapsam talep ederek bir yetkilendirme kodunun ayrıcalıklarını yükseltebilir. **Erişim Token'ı** oluşturulduktan sonra, **Kaynak Sunucusu** bunu doğrulamalıdır: JWT token'ları için, bu JWT imzasını kontrol etmeyi ve client_id ve scope gibi verileri çıkarmayı içerir, rastgele dize token'ları için ise sunucu, token’ın ayrıntılarını almak için Yetkilendirme Sunucusunu sorgulamalıdır.

## Yönlendirme Şeması Kaçırma

Mobil OAuth uygulamalarında, uygulamalar **özel URI şemaları** kullanarak Yetkilendirme Kodları ile yönlendirmeleri alır. Ancak, bir cihazda birden fazla uygulama aynı şemayı kaydedebileceğinden, yalnızca meşru istemcinin yönlendirme URI'sini kontrol ettiği varsayımı ihlal edilir. Örneğin Android'de, `com.example.app://` gibi bir Intent URI, şemaya ve bir uygulamanın intent-filter'ında tanımlanan isteğe bağlı filtrelere göre yakalanır. Android’in intent çözümlemesi geniş olabileceğinden—özellikle yalnızca şema belirtilmişse—bir saldırgan, yetkilendirme kodunu kaçırmak için dikkatlice hazırlanmış bir intent filtresi ile kötü niyetli bir uygulama kaydedebilir. Bu, ya kullanıcı etkileşimi yoluyla (birden fazla uygulama intent'i işlemek için uygun olduğunda) ya da aşırı spesifik filtreleri kötüye kullanan atlatma teknikleri aracılığıyla **bir hesap ele geçirmeye** olanak tanıyabilir.

## Referanslar

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)

{{#include ../banners/hacktricks-training.md}}
