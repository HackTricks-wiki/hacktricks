# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Basic Information <a href="#d4a8" id="d4a8"></a>

OAuth propose plusieurs versions, avec des informations de base disponibles sur [OAuth 2.0 documentation](https://oauth.net/2/). Cette discussion se concentre principalement sur le [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), fournissant un **cadre d'autorisation qui permet à une application d'accéder ou d'effectuer des actions sur le compte d'un utilisateur dans une autre application** (le authorization server).

Considérons un site hypothétique _**https://example.com**_, conçu pour **afficher tous vos posts sur les réseaux sociaux**, y compris les privés. Pour cela, OAuth 2.0 est utilisé. _https://example.com_ demandera votre permission pour **accéder à vos posts sur les réseaux sociaux**. En conséquence, un écran de consentement apparaîtra sur _https://socialmedia.com_, détaillant les **permissions demandées et le développeur effectuant la requête**. Après votre autorisation, _https://example.com_ obtient la capacité de **consulter vos posts en votre nom**.

Il est essentiel de comprendre les composants suivants dans le cadre OAuth 2.0 :

- **resource owner**: Vous, en tant qu'utilisateur/entité, autorisez l'accès à votre ressource, comme les posts de votre compte sur les réseaux sociaux.
- **resource server**: Le serveur qui gère les requêtes authentifiées après que l'application a obtenu un `access token` pour le compte du `resource owner`, par exemple **https://socialmedia.com**.
- **client application**: L'application qui cherche à obtenir l'autorisation du `resource owner`, comme **https://example.com**.
- **authorization server**: Le serveur qui émet des `access tokens` à la `client application` après l'authentification réussie du `resource owner` et l'obtention de l'autorisation, par exemple **https://socialmedia.com**.
- **client_id**: Un identifiant public et unique pour l'application.
- **client_secret:** Une clé confidentielle, connue uniquement de l'application et du authorization server, utilisée pour générer des `access_tokens`.
- **response_type**: Une valeur spécifiant **le type de token demandé**, comme `code`.
- **scope**: Le **niveau d'accès** que la `client application` demande au `resource owner`.
- **redirect_uri**: L'URL vers laquelle l'utilisateur est redirigé après l'autorisation. Cela doit généralement correspondre à l'URL de redirection pré-enregistrée.
- **state**: Un paramètre pour **conserver des données lors de la redirection de l'utilisateur vers et depuis le authorization server**. Son unicité est critique pour servir de **mécanisme de protection contre le CSRF**.
- **grant_type**: Un paramètre indiquant **le type de grant et le type de token à retourner**.
- **code**: Le code d'autorisation émis par le authorization server, utilisé conjointement avec `client_id` et `client_secret` par la client application pour acquérir un `access_token`.
- **access_token**: Le **token que la client application utilise pour les requêtes API** au nom du `resource owner`.
- **refresh_token**: Permet à l'application d'**obtenir un nouveau `access_token` sans redemander l'utilisateur**.

### Flow

Le flux OAuth réel se déroule comme suit :

1. Vous naviguez vers [https://example.com](https://example.com) et sélectionnez le bouton « Integrate with Social Media ».
2. Le site envoie ensuite une requête à [https://socialmedia.com](https://socialmedia.com) demandant votre autorisation pour permettre à l'application de https://example.com d'accéder à vos posts. La requête est structurée comme :
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Une page de consentement vous est alors présentée.
4. Après votre approbation, Social Media envoie une réponse au `redirect_uri` avec les paramètres `code` et `state` :
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com utilise ce `code`, ainsi que son `client_id` et son `client_secret`, pour effectuer une requête côté serveur afin d'obtenir un `access_token` en votre nom, permettant l'accès aux autorisations auxquelles vous avez consenti:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Enfin, le processus se termine lorsque https://example.com utilise votre `access_token` pour effectuer un appel API vers Social Media afin d'accéder

## Vulnérabilités <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Conformément à [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), le serveur d'autorisation doit rediriger le navigateur uniquement vers des redirect URIs exactes et préenregistrées. Toute faiblesse ici permet à un attaquant d'envoyer une victime via une URL d'autorisation malveillante afin que l'IdP délivre le `code` (et le `state`) de la victime directement vers un endpoint contrôlé par l'attaquant, qui peut ensuite l'échanger et récolter les tokens.

Workflow d'attaque typique :

1. Craft `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` et l'envoyer à la victime.
2. La victime s'authentifie et approuve les scopes.
3. L'IdP redirige vers `attacker.tld/callback?code=<victim-code>&state=...` où l'attaquant logge la requête et échange immédiatement le code.

Bugs de validation courants à tester :

- **Aucune validation** – any absolute URL is accepted, resulting in instant code theft.
- **Vérifications faibles par sous-chaîne/regex sur l'hôte** – contournement avec des domaines similaires tels que `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, ou `match.com@evil.com`.
- **Incompatibilités homographes IDN** – la validation se fait sur la forme punycode (`xn--`), mais le navigateur redirige vers le domaine Unicode contrôlé par l'attaquant.
- **Chemins arbitraires sur un hôte autorisé** – pointer `redirect_uri` vers `/openredirect?next=https://attacker.tld` ou tout endpoint XSS/user-content fait fuiter le code soit via des redirections en chaîne, les en-têtes Referer, ou du JavaScript injecté.
- **Contraintes de répertoire sans normalisation** – des patterns comme `/oauth/*` peuvent être contournés avec `/oauth/../anything`.
- **Sous-domaines wildcard** – accepter `*.example.com` signifie que tout takeover (dangling DNS, S3 bucket, etc.) fournit immédiatement un callback valide.
- **Callbacks non-HTTPS** – laisser passer des URIs `http://` donne aux attaquants réseau (Wi‑Fi, proxy d'entreprise) l'opportunité de snatcher le code en transit.

Passez aussi en revue les paramètres auxiliaires de type redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, etc.) et le document de découverte OpenID (`/.well-known/openid-configuration`) pour d'autres endpoints qui pourraient hériter des mêmes bugs de validation.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Comme mentionné dans ce rapport de bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), il se peut que l'URL de redirection soit reflétée dans la réponse du serveur après que l'utilisateur s'authentifie, rendant l'implémentation **vulnérable à XSS**. Payload possible à tester :
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Mauvaise gestion du paramètre state <a href="#bda5" id="bda5"></a>

Le paramètre `state` est le token CSRF du flux Authorization Code : le client doit générer une **valeur cryptographiquement aléatoire par instance de navigateur**, la stocker quelque part que seul ce navigateur peut lire (cookie, local storage, etc.), l'envoyer dans la requête d'autorisation, et rejeter toute réponse qui ne retourne pas la même valeur. Dès que la valeur est statique, prévisible, optionnelle ou non liée à la session de l’utilisateur, l’attaquant peut terminer son propre flux OAuth, capturer la requête finale `?code=` (sans l’envoyer), puis contraindre plus tard le navigateur de la victime à rejouer cette requête pour que le compte de la victime soit lié au profil de l’IdP de l’attaquant.

Le schéma de replay est toujours le même :

1. L’attaquant s’authentifie auprès de l’IdP avec son compte et intercepte la dernière redirection contenant `code` (et éventuellement `state`).
2. Il abandonne cette requête, conserve l’URL, et abuse plus tard d’un primitive CSRF (lien, iframe, formulaire auto-soumis) pour forcer le navigateur de la victime à la charger.
3. Si le client n’enforce pas `state`, l’application consomme le résultat d’autorisation de l’attaquant et connecte l’attaquant au compte de la victime dans l’app.

Checklist pratique pour la gestion du `state` pendant les tests :

- **Absence totale de `state`** – si le paramètre n’apparaît jamais, tout le login est vulnérable au CSRF.
- **`state` non requis** – retirez-le de la requête initiale ; si l’IdP émet toujours des codes que le client accepte, la défense est opt-in.
- **`state` retourné non validé** – modifiez la valeur dans la réponse (Burp, MITM proxy). Accepter des valeurs non concordantes signifie que le token stocké n’est jamais comparé.
- **`state` prévisible ou purement basé sur des données** – beaucoup d’apps insèrent des chemins de redirection ou des blobs JSON dans `state` sans y mêler d’entropie, permettant aux attaquants de deviner des valeurs valides et de rejouer les flows. Toujours préfixer/suffixer avec une forte entropie avant d’encoder les données.
- **Fixation de `state`** – si l’app permet aux utilisateurs de fournir la valeur `state` (p.ex. via des authorization URLs spécialement créées) et la réutilise tout au long du flow, un attaquant peut verrouiller une valeur connue et la réutiliser sur plusieurs victimes.

PKCE peut compléter `state` (surtout pour les public clients) en liant le authorization code à un code_verifier, mais les web clients doivent toujours suivre `state` pour prévenir les bugs CSRF/liaison-de-compte entre utilisateurs.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Sans vérification d’email lors de la création de compte** : Les attaquants peuvent créer proactivement un compte en utilisant l’email de la victime. Si la victime utilise ensuite un service tiers pour se connecter, l’application peut involontairement lier ce compte tiers au compte pré-créé par l’attaquant, entraînant un accès non autorisé.
2. **Exploitation d’une vérification d’email laxiste par OAuth** : Les attaquants peuvent abuser de services OAuth qui ne vérifient pas les emails en s’enregistrant sur le service puis en changeant l’email du compte pour celui de la victime. Cette méthode présente le même risque d’accès non autorisé que le premier scénario, mais via un vecteur différent.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

Le `client_id` est intentionnellement public, mais le **`client_secret` ne doit jamais être récupérable par des utilisateurs finaux**. Les déploiements Authorization Code qui embarquent le secret dans des **APKs mobiles, desktop clients, ou single-page apps** remettent en pratique cette crédential à quiconque peut télécharger le package. Inspectez toujours les clients publics en :

- Dépaquetant l’APK/IPA, l’installateur desktop ou l’app Electron et en recherchant (`grep`) `client_secret`, des blobs Base64 qui décodent en JSON, ou des endpoints OAuth codés en dur.
- Passant en revue les fichiers de config inclus (plist, JSON, XML) ou les chaînes décompilées pour y trouver des identifiants client.

Une fois que l’attaquant extrait le secret, il lui suffit de voler n’importe quel `code` d’autorisation de la victime (via un `redirect_uri` faible, des logs, etc.) pour appeler indépendamment `/token` et générer des access/refresh tokens sans impliquer l’app légitime. Considérez les clients publics/natifs comme **incapables de conserver des secrets** — ils devraient plutôt s’appuyer sur PKCE (RFC 7636) pour prouver la possession d’un code_verifier par instance au lieu d’un secret statique. Pendant les tests, confirmez si PKCE est obligatoire et si le backend rejette effectivement les échanges de token qui omettent soit le `client_secret` **ou** un `code_verifier` valide.

### Client Secret Bruteforce

Vous pouvez tenter de **bruteforcer le `client_secret`** d’un service provider auprès de l’IdP afin d’essayer de voler des comptes.  
La requête pour le BF peut ressembler à :
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Une fois que le client a le **code and state**, si ceux-ci sont **réfléchis dans l’en-tête Referer** lorsqu'il navigue vers une autre page, alors c'est vulnérable.

### Access Token Stored in Browser History

Le principe fondamental du Authorization Code grant est que **les access tokens n'atteignent jamais le navigateur du propriétaire de la ressource**. Quand des implémentations leak tokens côté client, n'importe quel bug mineur (XSS, Referer leak, proxy logging) devient une compromission instantanée de compte. Vérifiez toujours :

- **Tokens in URLs** – si `access_token` apparaît dans la query/fragment, il se retrouve dans l'historique du navigateur, les logs serveur, les analytics et les en-têtes Referer envoyés à des tiers.
- **Tokens transiting untrusted middleboxes** – renvoyer des tokens via HTTP ou à travers des proxies de debug/corporate permet aux observateurs réseau de les capturer directement.
- **Tokens stored in JavaScript state** – les stores React/Vue, variables globales ou blobs JSON sérialisés exposent les tokens à tous les scripts de l'origine (y compris les payloads XSS ou les extensions malveillantes).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` conservent les tokens longtemps après la déconnexion sur des appareils partagés et sont accessibles par script.

Toute découverte de ce type transforme généralement des bugs autrement « faibles » (comme un contournement CSP ou un DOM XSS) en prise de contrôle complète de l'API, car l'attaquant peut simplement lire et rejouer le leaked bearer token.

### Everlasting Authorization Code

Les Authorization codes doivent être **éphémères, à usage unique et résistants au replay**. Lors de l'évaluation d'un flux, capturez un `code` et :

- **Test the lifetime** – RFC 6749 recommande des minutes, pas des heures. Essayez d'échanger le code après 5–10 minutes ; s'il fonctionne toujours, la fenêtre d'exposition d'un leaked code est excessive.
- **Test sequential reuse** – envoyez deux fois le même `code`. Si la deuxième requête donne un autre token, les attaquants peuvent cloner des sessions indéfiniment.
- **Test concurrent redemption/race conditions** – lancez deux requêtes de token en parallèle (Burp intruder, turbo intruder). Certains émetteurs faibles accordent parfois les deux.
- **Observe replay handling** – une tentative de réutilisation ne doit pas seulement échouer mais aussi révoquer tout token déjà émis pour ce code. Sinon, un replay détecté laisse le premier token de l'attaquant actif.

Combiner un code permissif au replay avec n'importe quel `redirect_uri` ou bug de logging permet un accès persistant au compte même après que la victime ait terminé la connexion légitime.

### Authorization/Refresh Token not bound to client

Si vous pouvez obtenir le **authorization code** et l'utiliser avec un client différent, vous pouvez alors takeover d'autres comptes.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Consultez cet article**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

Dans ce rapport bug bounty : [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) vous pouvez voir que le **token** que **AWS Cognito** renvoie à l'utilisateur peut avoir **suffisamment de permissions pour écraser les données utilisateur**. Par conséquent, si vous pouvez **changer l'email d'un utilisateur pour l'email d'un autre utilisateur**, vous pourriez être capable de **take over** les comptes d'autres personnes.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Pour des informations plus détaillées sur la manière d'abuser d'AWS Cognito, consultez [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abusing other Apps tokens <a href="#bda5" id="bda5"></a>

Comme [**mentionné dans ce writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), les flows OAuth qui s'attendent à recevoir le **token** (et non un code) peuvent être vulnérables si ils ne vérifient pas que le token appartient à l'app.

Ceci s'explique parce qu'un **attacker** pourrait créer une **application supportant OAuth et le login avec Facebook** (par exemple) dans sa propre application. Ensuite, une fois qu'une **victim** se connecte avec Facebook dans l'application du **attacker**, ce dernier pourrait obtenir le **token OAuth de l'utilisateur donné à son application**, et l'utiliser pour se connecter dans l'application OAuth de la **victim** en utilisant le token de l'utilisateur victime.

> [!CAUTION]
> Ainsi, si le **attacker** parvient à faire accéder l'utilisateur à sa propre application OAuth, il pourra prendre le contrôle du compte de la **victim** dans des applications qui attendent un token et qui ne vérifient pas si le token a été accordé à leur app ID.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Selon [**ce writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), il était possible de faire ouvrir à une **victim** une page avec un **returnUrl** pointant vers l'host du **attacker**. Cette information serait **stockée dans un cookie (RU)** et, à une **étape ultérieure**, le **prompt** demandera à l'**user** s'il veut accorder l'accès à cet host du **attacker**.

Pour bypasser ce prompt, il était possible d'ouvrir un onglet pour initier le **Oauth flow** qui définirait ce cookie RU en utilisant le **returnUrl**, fermer l'onglet avant que le prompt ne soit affiché, puis ouvrir un nouvel onglet sans cette valeur. Ensuite, le **prompt n'informera pas sur l'host du attacker**, mais le cookie sera défini sur celui-ci, de sorte que le **token sera envoyé à l'host du attacker** lors de la redirection.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Comme expliqué dans [**cette vidéo**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), certaines implémentations OAuth permettent d'indiquer le paramètre GET **`prompt`** à None (**`&prompt=none`**) pour **éviter que les utilisateurs soient invités à confirmer** l'accès donné dans un prompt sur le web s'ils sont déjà connectés à la plateforme.

### response_mode

Comme [**expliqué dans cette vidéo**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), il peut être possible d'indiquer le paramètre **`response_mode`** pour indiquer où vous voulez que le code soit fourni dans l'URL finale :

- `response_mode=query` -> Le code est fourni dans un paramètre GET : `?code=2397rf3gu93f`
- `response_mode=fragment` -> Le code est fourni dans le fragment de l'URL `#code=2397rf3gu93f`
- `response_mode=form_post` -> Le code est fourni dans un formulaire POST avec un input appelé `code` et la valeur
- `response_mode=web_message` -> Le code est envoyé via un post message : `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

Les dialogues de consentement/login OAuth sont des cibles idéales pour le clickjacking : si ils peuvent être encadrés, un attacker peut superposer des éléments graphiques personnalisés, cacher les vrais boutons, et tromper les utilisateurs pour qu'ils approuvent des scopes dangereux ou lient des comptes. Construisez des PoC qui :

1. Chargent l'URL d'autorisation de l'IdP à l'intérieur d'un `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Utilisent du positionnement absolu/astuces d'opacité pour aligner des faux boutons avec les contrôles **Allow**/**Approve** cachés.
3. Optionnellement pré-remplissent des paramètres (scopes, redirect URI) afin que l'approbation volée bénéficie immédiatement à l'attacker.

Lors des tests, vérifiez que les pages IdP émettent soit `X-Frame-Options: DENY/SAMEORIGIN` soit une `Content-Security-Policy: frame-ancestors 'none'` restrictive. Si aucune n'est présente, démontrez le risque avec des outils comme [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) et enregistrez la facilité avec laquelle une victime autorise l'app de l'attacker. Pour d'autres idées de payload voir [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

Selon [**cet article de blog**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), il s'agit d'un flow OAuth qui permet de se logger via **username** et **password**. Si durant ce flow simple un **token** avec accès à toutes les actions que l'utilisateur peut effectuer est retourné, alors il est possible de bypasser la 2FA en utilisant ce token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Ce [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) explique comment il était possible d'abuser d'un **open redirect** basé sur la valeur du **referrer** pour abuser OAuth en vue d'un ATO. L'attaque était :

1. La victim accède à la page web de l'attacker
2. La victim ouvre le lien malveillant et un opener démarre le Google OAuth flow avec `response_type=id_token,code&prompt=none` comme paramètres additionnels en utilisant comme **referrer le site de l'attacker**.
3. Dans l'opener, après que le provider autorise la victim, il les renvoie vers la valeur du paramètre `redirect_uri` (site de la victim) avec un code 30X qui garde toujours le site de l'attacker dans le referer.
4. Le site de la victim **déclenche l'open redirect basé sur le referrer** redirigeant l'utilisateur vers le site de l'attacker ; comme le **`respose_type`** était **`id_token,code`**, le code sera envoyé à l'attacker dans le **fragment** de l'URL lui permettant de takeover le compte de l'utilisateur via Google sur le site de la victim.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

Dynamic Client Registration en OAuth sert de vecteur moins évident mais critique pour des vulnérabilités de sécurité, en particulier pour les attaques **SSRF**. Cet endpoint permet aux serveurs OAuth de recevoir des détails sur les applications clientes, incluant des URLs sensibles qui pourraient être exploitées.

Points clés :

- **Dynamic Client Registration** est souvent mappé sur `/register` et accepte des détails comme `client_name`, `client_secret`, `redirect_uris`, et des URLs pour des logos ou des JSON Web Key Sets (JWKs) via des requêtes POST.
- Cette fonctionnalité adhère aux spécifications définies dans **RFC7591** et **OpenID Connect Registration 1.0**, qui incluent des paramètres potentiellement vulnérables aux SSRF.
- Le processus d'enregistrement peut involontairement exposer les serveurs au SSRF de plusieurs façons :
  - **`logo_uri`** : Une URL pour le logo de l'application cliente qui pourrait être fetchée par le serveur, déclenchant un SSRF ou conduisant à du XSS si l'URL est mal gérée.
  - **`jwks_uri`** : Une URL vers le document JWK du client, qui si elle est malicieusement construite, peut amener le serveur à faire des requêtes sortantes vers un serveur contrôlé par l'attacker.
  - **`sector_identifier_uri`** : Référence un tableau JSON de `redirect_uris`, que le serveur pourrait récupérer, créant une opportunité SSRF.
  - **`request_uris`** : Liste des request URIs autorisés pour le client, qui peut être exploité si le serveur fetch ces URIs au début du processus d'autorisation.

Stratégie d'exploitation :

- Le SSRF peut être déclenché en enregistrant un nouveau client avec des URLs malveillantes dans des paramètres comme `logo_uri`, `jwks_uri` ou `sector_identifier_uri`.
- Alors que l'exploitation directe via `request_uris` peut être atténuée par des contrôles de whitelist, fournir un `request_uri` pré-enregistré et contrôlé par l'attacker peut faciliter le SSRF durant la phase d'autorisation.

## OAuth providers Race Conditions

Si la plateforme que vous testez est un OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

En OAuth, le champ sub identifie de manière unique un utilisateur, mais son format varie selon l'Authorization Server. Pour standardiser l'identification utilisateur, certains clients utilisent des emails ou des handles utilisateur. Cependant, cela est risqué parce que :

- Certains Authorization Servers n'assurent pas que ces propriétés (comme l'email) restent immuables.
- Dans certaines implémentations — comme **"Login with Microsoft"** — le client s'appuie sur le champ email, qui est **contrôlé par l'utilisateur dans Entra ID** et non vérifié.
- Un attacker peut exploiter cela en créant sa propre organisation Azure AD (par ex. doyensectestorg) et l'utiliser pour effectuer un login Microsoft.
- Même si l'Object ID (stocké dans sub) est immuable et sécurisé, la dépendance à un champ email mutable peut permettre un takeover de compte (par exemple, le détournement d'un compte comme victim@gmail.com).

## Client Confusion Attack

Dans une **Client Confusion Attack**, une application utilisant l'OAuth Implicit Flow ne vérifie pas que le token final a été généré spécifiquement pour son propre Client ID. Un attacker met en place un site public qui utilise Google’s OAuth Implicit Flow, trompant des milliers d'utilisateurs pour qu'ils se connectent et récolte ainsi des access tokens destinés au site de l'attacker. Si ces utilisateurs ont aussi des comptes sur un autre site vulnérable qui ne valide pas le Client ID du token, l'attacker peut réutiliser les tokens récoltés pour usurper les victimes et prendre le contrôle de leurs comptes.

## Scope Upgrade Attack

Le type **Authorization Code Grant** implique une communication sécurisée server-to-server pour transmettre les données utilisateur. Cependant, si l'**Authorization Server** fait implicitement confiance à un paramètre scope dans l'Access Token Request (un paramètre non défini dans le RFC), une application malveillante pourrait upgrader les privilèges d'un code d'autorisation en demandant un scope plus élevé. Après la génération de l'**Access Token**, le **Resource Server** doit le vérifier : pour des tokens JWT, cela implique de vérifier la signature JWT et d'extraire des données comme client_id et scope, tandis que pour des tokens sous forme de chaînes aléatoires, le serveur doit interroger l'Authorization Server pour récupérer les détails du token.

## Redirect Scheme Hijacking

Dans les implémentations OAuth mobiles, les apps utilisent des **custom URI schemes** pour recevoir les redirects avec des Authorization Codes. Cependant, comme plusieurs apps peuvent enregistrer le même scheme sur un appareil, l'hypothèse que seul le client légitime contrôle le redirect URI est violée. Sur Android, par exemple, un Intent URI comme `com.example.app://` est attrapé en fonction du scheme et des filtres optionnels définis dans l'intent-filter d'une app. Étant donné que la résolution d'intent d'Android peut être large — surtout si seul le scheme est spécifié — un attacker peut enregistrer une app malveillante avec un intent-filter soigneusement conçu pour hijacker le authorization code. Cela peut **permettre un account takeover** soit via interaction utilisateur (lorsque plusieurs apps sont éligibles pour gérer l'intent) soit via des techniques de contournement qui exploitent des filtres trop permissifs, comme détaillé par le flowchart d'évaluation d'Ostorlab.

## Références

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)

{{#include ../banners/hacktricks-training.md}}
