# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Información básica <a href="#d4a8" id="d4a8"></a>

OAuth ofrece varias versiones, con conocimientos fundamentales disponibles en [OAuth 2.0 documentation](https://oauth.net/2/). Esta discusión se centra principalmente en el ampliamente utilizado [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), que proporciona un **marco de autorización que permite a una aplicación acceder o realizar acciones en la cuenta de un usuario en otra aplicación** (el servidor de autorización).

Considera un sitio hipotético _**https://example.com**_, diseñado para **mostrar todas tus publicaciones de social media**, incluidas las privadas. Para lograr esto se emplea OAuth 2.0. _https://example.com_ solicitará tu permiso para **acceder a tus publicaciones de social media**. En consecuencia, en _https://socialmedia.com_ aparecerá una pantalla de consentimiento que describirá las **permisos solicitados y el desarrollador que hace la solicitud**. Tras tu autorización, _https://example.com_ obtiene la capacidad de **acceder a tus publicaciones en tu nombre**.

Es esencial comprender los siguientes componentes dentro del marco de OAuth 2.0:

- **propietario del recurso**: Tú, como **usuario/entidad**, autorizas el acceso a tu recurso, como las publicaciones de tu cuenta en la red social.
- **servidor de recursos**: El **servidor que gestiona las peticiones autenticadas** después de que la aplicación haya obtenido un `access token` en nombre del `resource owner`, p.ej., **https://socialmedia.com**.
- **aplicación cliente**: La **aplicación que busca autorización** del `resource owner`, como **https://example.com**.
- **servidor de autorización**: El **servidor que emite `access tokens`** a la aplicación cliente tras la autenticación exitosa del `resource owner` y la obtención de la autorización, p.ej., **https://socialmedia.com**.
- **client_id**: Un identificador público y único para la aplicación.
- **client_secret:** Una clave confidencial, conocida solo por la aplicación y el servidor de autorización, utilizada para generar `access_tokens`.
- **response_type**: Un valor que especifica **el tipo de token solicitado**, como `code`.
- **scope**: El **nivel de acceso** que la aplicación cliente está solicitando al `resource owner`.
- **redirect_uri**: La **URL a la que se redirige al usuario tras la autorización**. Normalmente debe coincidir con la URL de redirección pre-registrada.
- **state**: Un parámetro para **mantener datos durante la redirección del usuario hacia y desde el servidor de autorización**. Su unicidad es crítica para funcionar como **mecanismo de protección contra CSRF**.
- **grant_type**: Un parámetro que indica **el tipo de grant y el tipo de token que se devolverá**.
- **code**: El código de autorización del servidor de autorización, usado junto con `client_id` y `client_secret` por la aplicación cliente para adquirir un `access_token`.
- **access_token**: El **token que la aplicación cliente usa para las peticiones API** en nombre del `resource owner`.
- **refresh_token**: Permite a la aplicación **obtener un nuevo `access_token` sin volver a solicitar la intervención del usuario**.

### Flujo

El **flujo real de OAuth** procede de la siguiente manera:

1. Navegas a [https://example.com](https://example.com) y seleccionas el botón “Integrarse con la red social”.
2. El sitio envía entonces una solicitud a [https://socialmedia.com](https://socialmedia.com) pidiendo tu autorización para permitir que la aplicación de https://example.com acceda a tus publicaciones. La solicitud está estructurada como:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Se te presenta una página de consentimiento.
4. Tras tu aprobación, Social Media envía una respuesta al `redirect_uri` con los parámetros `code` y `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com utiliza este `code`, junto con su `client_id` y `client_secret`, para realizar una solicitud del lado del servidor para obtener un `access_token` en tu nombre, permitiendo el acceso a los permisos a los que diste tu consentimiento:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Finalmente, el proceso concluye cuando https://example.com emplea tu `access_token` para realizar una llamada API a Social Media para acceder

## Vulnerabilities <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), el servidor de autorización debe redirigir el navegador únicamente a **redirect URIs exactas y pre-registradas**. Cualquier debilidad aquí permite que un atacante envíe a una víctima a través de una URL de autorización maliciosa, de modo que el IdP entregue el `code` (y el `state`) de la víctima directamente a un endpoint controlado por el atacante, que puede entonces canjearlo y obtener tokens.

Flujo de ataque típico:

1. Construir `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` y enviarlo a la víctima.
2. La víctima se autentica y aprueba los scopes.
3. El IdP redirige a `attacker.tld/callback?code=<victim-code>&state=...` donde el atacante registra la petición y canjea inmediatamente el code.

Errores comunes de validación a investigar:

- **No validation** – any absolute URL is accepted, resulting in instant code theft.
- **Weak substring/regex checks on the host** – bypass con imitadores como `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, o `match.com@evil.com`.
- **IDN homograph mismatches** – la validación ocurre en la forma punycode (`xn--`), pero el navegador redirige al dominio Unicode controlado por el atacante.
- **Arbitrary paths on an allowed host** – apuntar `redirect_uri` a `/openredirect?next=https://attacker.tld` o a cualquier endpoint de XSS/contenido de usuario leaks the code ya sea mediante redirecciones encadenadas, cabeceras Referer, o JavaScript inyectado.
- **Directory constraints without normalization** – patrones como `/oauth/*` pueden ser bypassed con `/oauth/../anything`.
- **Wildcard subdomains** – aceptar `*.example.com` significa que cualquier takeover (dangling DNS, S3 bucket, etc.) inmediatamente produce un callback válido.
- **Non-HTTPS callbacks** – permitir URIs `http://` da a los atacantes en la red (Wi-Fi, proxy corporativo) la oportunidad de interceptar el code en tránsito.

También revisa parámetros auxiliares de tipo redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, etc.) y el documento de descubrimiento OpenID (`/.well-known/openid-configuration`) en busca de endpoints adicionales que puedan heredar los mismos bugs de validación.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Como se menciona en este bug bounty report [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) podría ser posible que la redirect **URL se refleje en la respuesta** del servidor después de que el usuario se autentique, siendo **vulnerable a XSS**. Payload posible para probar:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Manejo incorrecto del parámetro `state` <a href="#bda5" id="bda5"></a>

El parámetro `state` es el CSRF token del Authorization Code flow: el cliente debe generar un **valor criptográficamente aleatorio por instancia de navegador**, persistirlo en un lugar que solo ese navegador pueda leer (cookie, local storage, etc.), enviarlo en la solicitud de autorización y rechazar cualquier respuesta que no devuelva el mismo valor. Siempre que el valor sea estático, predecible, opcional o no esté ligado a la sesión del usuario, el atacante puede completar su propio flujo OAuth, capturar la petición final `?code=` (sin enviarla) y más tarde forzar al navegador de la víctima a reproducir esa petición para que la cuenta de la víctima quede vinculada al perfil del atacante en el IdP.

El patrón de replay es siempre el mismo:

1. El atacante se autentica contra el IdP con su cuenta e intercepta el último redirect que contiene `code` (y cualquier `state`).
2. Deja caer esa petición, guarda la URL y más tarde abusa de cualquier primitiva CSRF (link, iframe, formulario que se autoenvía) para forzar al navegador de la víctima a cargarla.
3. Si el cliente no aplica `state`, la aplicación consume el resultado de autorización del atacante y autentica al atacante en la cuenta de la víctima.

Una checklist práctica para el manejo de `state` durante las pruebas:

- **Falta de `state` por completo** – si el parámetro nunca aparece, todo el login es CSRFable.
- **`state` no obligatorio** – elimínalo de la petición inicial; si el IdP aún emite codes que el cliente acepta, la defensa es opt-in.
- **`state` devuelto no validado** – manipula el valor en la respuesta (Burp, MITM proxy). Aceptar valores que no coinciden significa que el token almacenado nunca se compara.
- **`state` predecible o puramente orientado a datos** – muchas apps meten rutas de redirect o blobs JSON en `state` sin mezclar entropía, lo que permite a atacantes adivinar valores válidos y reproducir flujos. Siempre antepone/anexa entropía fuerte antes de codificar los datos.
- **Fijación de `state`** – si la app permite a usuarios suministrar el valor de `state` (p. ej., vía URLs de autorización crafted) y lo reutiliza durante el flujo, un atacante puede fijar un valor conocido y reutilizarlo entre víctimas.

PKCE puede complementar `state` (especialmente para public clients) ligando el authorization code a un code verifier, pero los web clients aún deben trackear `state` para prevenir bugs de CSRF/ligado-de-cuentas entre usuarios.

### Antes del Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Sin verificación de email en la creación de cuentas**: Los atacantes pueden crear anticipadamente una cuenta usando el email de la víctima. Si la víctima luego usa un servicio third-party para iniciar sesión, la aplicación podría vincular inadvertidamente esa cuenta third-party a la cuenta pre-creada del atacante, permitiendo acceso no autorizado.
2. **Explotando verificación de email laxas en OAuth**: Los atacantes pueden explotar servicios OAuth que no verifican emails registrándose con su servicio y luego cambiando el email de la cuenta al de la víctima. Este método presenta un riesgo similar de acceso no autorizado, análogo al primer escenario pero mediante otro vector de ataque.

### Divulgación de secretos <a href="#e177" id="e177"></a>

El `client_id` es intencionalmente público, pero el **`client_secret` nunca debe ser recuperable por usuarios finales**. Despliegues de Authorization Code que incrustan el secret en **APKs móviles, clientes de escritorio o single-page apps** efectivamente entregan esa credencial a cualquiera que pueda descargar el paquete. Siempre inspecciona public clients mediante:

- Desempaquetar el APK/IPA, instalador de escritorio o la app Electron y buscar (`grep`) `client_secret`, blobs Base64 que decodifican a JSON, o endpoints OAuth hard-coded.
- Revisar archivos de configuración incluidos (plist, JSON, XML) o strings decompiladas en busca de credenciales de cliente.

Una vez que el atacante extrae el secret, solo necesita robar cualquier `code` de autorización de la víctima (vía un `redirect_uri` débil, logs, etc.) para golpear `/token` de forma independiente y acuñar access/refresh tokens sin involucrar la app legítima. Trata a public/native clients como **incapaces de guardar secretos** — en su lugar deberían confiar en PKCE (RFC 7636) para probar la posesión de un code verifier por instancia en vez de un secret estático. Durante las pruebas, confirma si PKCE es obligatorio y si el backend realmente rechaza intercambios de token que omiten ya sea el `client_secret` **o** un `code_verifier` válido.

### Bruteforce del `client_secret`

Puedes intentar **bruteforcear el `client_secret`** de un proveedor de servicio con el IdP para intentar robar cuentas.\
La petición para BF puede verse similar a:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Una vez que el cliente tiene el **code and state**, si se **refleja dentro del Referer header** cuando navega a otra página, entonces es vulnerable.

### Access Token Stored in Browser History

La garantía principal del Authorization Code grant es que **access tokens never reach the resource owner’s browser**. Cuando las implementaciones leak tokens del lado del cliente, cualquier bug menor (XSS, Referer leak, proxy logging) se convierte en una compromisión instantánea de la cuenta. Siempre verifica:

- **Tokens in URLs** – si `access_token` aparece en la query/fragment, queda en el historial del navegador, logs del servidor, analytics y en los Referer headers enviados a terceros.
- **Tokens transiting untrusted middleboxes** – devolver tokens sobre HTTP o a través de debugging/corporate proxies permite que observadores de la red los capturen directamente.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, o blobs JSON serializados exponen tokens a cualquier script en el origin (incluyendo payloads XSS o extensiones maliciosas).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` retienen tokens mucho después del logout en dispositivos compartidos y son accesibles por scripts.

Cualquiera de estos hallazgos suele elevar bugs “bajos” (como un CSP bypass o DOM XSS) a un full API takeover porque el atacante puede leer y reproducir el bearer token filtrado.

### Everlasting Authorization Code

Los Authorization codes deben ser **de corta duración, de un solo uso y conscientes de replays**. Al evaluar un flujo, captura un `code` y:

- **Test the lifetime** – RFC 6749 recomienda minutos, no horas. Intenta canjear el code después de 5–10 minutos; si aún funciona, la ventana de exposición para cualquier code filtrado es excesiva.
- **Test sequential reuse** – envía el mismo `code` dos veces. Si la segunda solicitud genera otro token, los atacantes pueden clonar sesiones indefinidamente.
- **Test concurrent redemption/race conditions** – dispara dos requests de token en paralelo (Burp intruder, turbo intruder). Emisores débiles a veces conceden ambos.
- **Observe replay handling** – un intento de reuso no solo debería fallar sino también revocar cualquier token ya emitido a partir de ese code. De lo contrario, un replay detectado deja activo el primer token del atacante.

Combinar un code que admite replays con cualquier `redirect_uri` o un bug de logging permite acceso persistente a la cuenta incluso después de que la víctima complete el login legítimo.

### Authorization/Refresh Token not bound to client

Si puedes obtener el **authorization code y usarlo con un cliente diferente**, entonces puedes takeover otras cuentas.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

En este bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) puedes ver que el **token** que **AWS Cognito** devuelve al usuario podría tener **permisos suficientes para sobrescribir los datos del usuario**. Por tanto, si puedes **cambiar el email de usuario por otro email**, podrías **tomar control de** las cuentas de otros.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
For more detailed info about how to abuse AWS Cognito check [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abusing other Apps tokens <a href="#bda5" id="bda5"></a>

As [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth flows that expect to receive the **token** (and not a code) could be vulnerable if they not check that the token belongs to the app.

This is because an **attacker** could create an **application supporting OAuth and login with Facebook** (for example) in his own application. Then, once a victim logins with Facebook in the **attackers application**, the attacker could get the **OAuth token of the user given to his application, and use it to login in the victim OAuth application using the victims user token**.

> [!CAUTION]
> Therefore, if the attacker manages to get the user access his own OAuth application, he will be able to take over the victims account in applications that are expecting a token and aren't checking if the token was granted to their app ID.

### Two links & cookie <a href="#bda5" id="bda5"></a>

According to [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), it was possible to make a victim open a page with a **returnUrl** pointing to the attackers host. This info would be **stored in a cookie (RU)** and in a **later step** the **prompt** will **ask** the **user** if he wants to give access to that attackers host.

To bypass this prompt, it was possible to open a tab to initiate the **Oauth flow** that would set this RU cookie using the **returnUrl**, close the tab before the prompt is shown, and open a new tab without that value. Then, the **prompt won't inform about the attackers host**, but the cookie would be set to it, so the **token will be sent to the attackers host** in the redirection.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

As explained in [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), some OAuth implementations allows to indicate the **`prompt`** GET parameter as None (**`&prompt=none`**) to **prevent users being asked to confirm** the given access in a prompt in the web if they are already logged in the platform.

### response_mode

As [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), it might be possible to indicate the parameter **`response_mode`** to indicate where do you want the code to be provided in the final URL:

- `response_mode=query` -> The code is provided inside a GET parameter: `?code=2397rf3gu93f`
- `response_mode=fragment` -> The code is provided inside the URL fragment parameter `#code=2397rf3gu93f`
- `response_mode=form_post` -> The code is provided inside a POST form with an input called `code` and the value
- `response_mode=web_message` -> The code is send in a post message: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth consent/login dialogs are ideal clickjacking targets: if they can be framed, an attacker can overlay custom graphics, hide the real buttons, and trick users into approving dangerous scopes or linking accounts. Build PoCs that:

1. Load the IdP authorization URL inside an `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Use absolute positioning/opacity tricks to align fake buttons with the hidden **Allow**/**Approve** controls.
3. Optionally pre-fill parameters (scopes, redirect URI) so the stolen approval immediately benefits the attacker.

During testing verify that IdP pages emit either `X-Frame-Options: DENY/SAMEORIGIN` or a restrictive `Content-Security-Policy: frame-ancestors 'none'`. If neither is present, demonstrate the risk with tooling like [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) and record how easily a victim authorizes the attacker’s app. For additional payload ideas see [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

According to [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), this is an OAuth flow that allows to login in OAuth via **username** and **password**. If during this simple flow a **token** with access to all the actions the user can perform is returned then it's possible to bypass 2FA using that token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

This [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) comments how it was possible to abuse an **open redirect** to the value from the **referrer** to abuse OAuth to ATO. The attack was:

1. Victim access the attackers web page
2. The victim opens the malicious link and an opener starts the Google OAuth flow with `response_type=id_token,code&prompt=none` as additional parameters using as **referrer the attackers website**.
3. In the opener, after the provider authorizes the victim, it sends them back to the value of the `redirect_uri` parameter (victim web) with 30X code which still keeps the attackers website in the referer.
4. The victim **website trigger the open redirect based on the referrer** redirecting the victim user to the attackers website, as the **`respose_type`** was **`id_token,code`**, the code will be sent back to the attacker in the **fragment** of the URL allowing him to tacke over the account of the user via Google in the victims site.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

Dynamic Client Registration in OAuth serves as a less obvious but critical vector for security vulnerabilities, specifically for **Server-Side Request Forgery (SSRF)** attacks. This endpoint allows OAuth servers to receive details about client applications, including sensitive URLs that could be exploited.

**Key Points:**

- **Dynamic Client Registration** is often mapped to `/register` and accepts details like `client_name`, `client_secret`, `redirect_uris`, and URLs for logos or JSON Web Key Sets (JWKs) via POST requests.
- This feature adheres to specifications laid out in **RFC7591** and **OpenID Connect Registration 1.0**, which include parameters potentially vulnerable to SSRF.
- The registration process can inadvertently expose servers to SSRF in several ways:
- **`logo_uri`**: A URL for the client application's logo that might be fetched by the server, triggering SSRF or leading to XSS if the URL is mishandled.
- **`jwks_uri`**: A URL to the client's JWK document, which if maliciously crafted, can cause the server to make outbound requests to an attacker-controlled server.
- **`sector_identifier_uri`**: References a JSON array of `redirect_uris`, which the server might fetch, creating an SSRF opportunity.
- **`request_uris`**: Lists allowed request URIs for the client, which can be exploited if the server fetches these URIs at the start of the authorization process.

**Exploitation Strategy:**

- SSRF can be triggered by registering a new client with malicious URLs in parameters like `logo_uri`, `jwks_uri`, or `sector_identifier_uri`.
- While direct exploitation via `request_uris` may be mitigated by whitelist controls, supplying a pre-registered, attacker-controlled `request_uri` can facilitate SSRF during the authorization phase.

## OAuth providers Race Conditions

If the platform you are testing is an OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

In OAuth, the sub field uniquely identifies a user, but its format varies by Authorization Server. To standardize user identification, some clients use emails or user handles. However, this is risky because:

- Some Authorization Servers do not ensure that these properties (like email) remain immutable.
- In certain implementations—such as **"Login with Microsoft"**—the client relies on the email field, which is **user-controlled by the user in Entra ID** and not verified.
- An attacker can exploit this by creating their own Azure AD organization (e.g., doyensectestorg) and using it to perform a Microsoft login.
- Even though the Object ID (stored in sub) is immutable and secure, the reliance on a mutable email field can enable an account takeover (for example, hijacking an account like victim@gmail.com).

## Client Confusion Attack

In a **Client Confusion Attack**, an application using the OAuth Implicit Flow fails to verify that the final access token is specifically generated for its own Client ID. An attacker sets up a public website that uses Google’s OAuth Implicit Flow, tricking thousands of users into logging in and thereby harvesting access tokens intended for the attacker’s site. If these users also have accounts on another vulnerable website that does not validate the token's Client ID, the attacker can reuse the harvested tokens to impersonate the victims and take over their accounts.

## Scope Upgrade Attack

The **Authorization Code Grant** type involves secure server-to-server communication for transmitting user data. However, if the **Authorization Server** implicitly trusts a scope parameter in the Access Token Request (a parameter not defined in the RFC), a malicious application could upgrade the privileges of an authorization code by requesting a higher scope. After the **Access Token** is generated, the **Resource Server** must verify it: for JWT tokens, this involves checking the JWT signature and extracting data such as client_id and scope, while for random string tokens, the server must query the Authorization Server to retrieve the token’s details.

## Redirect Scheme Hijacking

In mobile OAuth implementations, apps use **custom URI schemes** to receive redirects with Authorization Codes. However, because multiple apps can register the same scheme on a device, the assumption that only the legitimate client controls the redirect URI is violated. On Android, for instance, an Intent URI like `com.example.app://` oauth is caught based on the scheme and optional filters defined in an app’s intent-filter. Since Android’s intent resolution can be broad—especially if only the scheme is specified—an attacker can register a malicious app with a carefully crafted intent filter to hijack the authorization code. This can **enable an account takeover** either through user interaction (when multiple apps are eligible to handle the intent) or via bypass techniques that exploit overly specific filters, as detailed by Ostorlab's assessment flowchart.



## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)

{{#include ../banners/hacktricks-training.md}}
