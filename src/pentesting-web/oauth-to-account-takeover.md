# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Basic Information <a href="#d4a8" id="d4a8"></a>

OAuth inatoa matoleo mbalimbali, huku maarifa ya msingi yanapatikana katika [OAuth 2.0 documentation](https://oauth.net/2/). Majadiliano haya yanazingatia hasa [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), ikitoa **mfumo wa ruhusa unaowezesha programu kufikia au kufanya vitendo kwenye akaunti ya mtumiaji katika programu nyingine** (seva ya ruhusa).

Fikiria tovuti ya mfano _**https://example.com**_, iliyoundwa ili **kuonyesha machapisho yako yote ya mitandao ya kijamii**, ikiwa ni pamoja na ya faragha. Ili kufanikisha hili, OAuth 2.0 inatumika. _https://example.com_ itahitaji ruhusa yako ili **kufikia machapisho yako ya mitandao ya kijamii**. Kwa hivyo, skrini ya idhini itaonekana kwenye _https://socialmedia.com_, ikielezea **ruhusa zinazohitajika na mtengenezaji anayefanya ombi**. Baada ya idhini yako, _https://example.com_ inapata uwezo wa **kufikia machapisho yako kwa niaba yako**.

Ni muhimu kuelewa vipengele vifuatavyo ndani ya mfumo wa OAuth 2.0:

- **resource owner**: Wewe, kama **mtumiaji/kiungo**, unaruhusu ufikiaji wa rasilimali yako, kama vile machapisho ya akaunti yako ya mitandao ya kijamii.
- **resource server**: **seva inayosimamia maombi yaliyothibitishwa** baada ya programu kupata `access token` kwa niaba ya `resource owner`, mfano, **https://socialmedia.com**.
- **client application**: **programu inayotafuta ruhusa** kutoka kwa `resource owner`, kama **https://example.com**.
- **authorization server**: **seva inayotoa `access tokens`** kwa `client application` baada ya uthibitisho wa mafanikio wa `resource owner` na kupata ruhusa, mfano, **https://socialmedia.com**.
- **client_id**: Kitambulisho cha umma, cha kipekee kwa programu.
- **client_secret:** Funguo ya siri, inayojulikana pekee kwa programu na seva ya ruhusa, inayotumika kwa ajili ya kuzalisha `access_tokens`.
- **response_type**: Thamani inayobainisha **aina ya token inayohitajika**, kama `code`.
- **scope**: **ngazi ya ufikiaji** ambayo `client application` inahitaji kutoka kwa `resource owner`.
- **redirect_uri**: **URL ambayo mtumiaji anarejeshwa baada ya ruhusa**. Hii kwa kawaida inapaswa kuendana na URL ya kuhamasisha iliyosajiliwa awali.
- **state**: Kigezo cha **kuhifadhi data wakati wa kuelekeza mtumiaji kwenda na kurudi kutoka kwa seva ya ruhusa**. Upekee wake ni muhimu kwa ajili ya kutumikia kama **mekanismu ya ulinzi wa CSRF**.
- **grant_type**: Kigezo kinachoashiria **aina ya ruhusa na aina ya token itakayorejeshwa**.
- **code**: Kodu ya ruhusa kutoka kwa `authorization server`, inayotumika pamoja na `client_id` na `client_secret` na `client application` ili kupata `access_token`.
- **access_token**: **token ambayo `client application` inatumia kwa maombi ya API** kwa niaba ya `resource owner`.
- **refresh_token**: Inaruhusu programu **kupata `access_token` mpya bila kumlazimisha mtumiaji tena**.

### Flow

**mchakato halisi wa OAuth** unaendelea kama ifuatavyo:

1. Unatembelea [https://example.com](https://example.com) na kuchagua kitufe cha “Integrate with Social Media”.
2. Tovuti hiyo kisha inatuma ombi kwa [https://socialmedia.com](https://socialmedia.com) ikitafuta ruhusa yako ili kuruhusu programu ya https://example.com kufikia machapisho yako. Ombi limeundwa kama:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Kisha unawasilishwa na ukurasa wa idhini.  
4. Kufuatia idhini yako, Social Media inatuma jibu kwa `redirect_uri` pamoja na vigezo vya `code` na `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com inatumia `code` hii, pamoja na `client_id` na `client_secret` yake, kufanya ombi la upande wa seva ili kupata `access_token` kwa niaba yako, ikiruhusu ufikiaji wa ruhusa ulizokubali:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Hatimaye, mchakato unamalizika wakati https://example.com inatumia `access_token` yako kufanya wito wa API kwa Social Media ili kufikia

## Vulnerabilities <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

`redirect_uri` ni muhimu kwa usalama katika utekelezaji wa OAuth na OpenID, kwani inaelekeza mahali ambapo data nyeti, kama vile nambari za idhini, zinatumwa baada ya idhini. Ikiwa imewekwa vibaya, inaweza kuruhusu washambuliaji kuelekeza maombi haya kwa seva mbaya, na kuwezesha kuchukuliwa kwa akaunti.

Mbinu za unyakuzi zinatofautiana kulingana na mantiki ya uthibitishaji ya seva ya idhini. Zinweza kutofautiana kutoka kwa mechi kali ya njia hadi kukubali URL yoyote ndani ya eneo lililotajwa au saraka ndogo. Mbinu za kawaida za unyakuzi ni pamoja na mwelekeo wazi, kupita njia, kutumia regex dhaifu, na kuingiza HTML kwa wizi wa token.

Mbali na `redirect_uri`, vigezo vingine vya OAuth na OpenID kama `client_uri`, `policy_uri`, `tos_uri`, na `initiate_login_uri` pia vinahatarishwa kwa mashambulizi ya mwelekeo. Vigezo hivi ni hiari na msaada wao unatofautiana kati ya seva.

Kwa wale wanaolenga seva ya OpenID, mwisho wa ugunduzi (`**.well-known/openid-configuration**`) mara nyingi huorodhesha maelezo muhimu ya usanidi kama vile `registration_endpoint`, `request_uri_parameter_supported`, na "`require_request_uri_registration`. Maelezo haya yanaweza kusaidia katika kubaini mwisho wa usajili na maelezo mengine ya usanidi wa seva.

### XSS katika utekelezaji wa mwelekeo <a href="#bda5" id="bda5"></a>

Kama ilivyotajwa katika ripoti hii ya bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) inaweza kuwa inawezekana kwamba **URL ya mwelekeo inarudishwa katika jibu** la seva baada ya mtumiaji kuthibitisha, ikiwa **hatarini kwa XSS**. Payload inay posible kujaribu:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Usimamizi mbaya wa parameter ya hali <a href="#bda5" id="bda5"></a>

Katika utekelezaji wa OAuth, matumizi mabaya au kukosekana kwa **`state` parameter** kunaweza kuongeza hatari ya mashambulizi ya **Cross-Site Request Forgery (CSRF)** kwa kiasi kikubwa. Uthibitisho huu unatokea wakati `state` parameter haijatumiwa, imetumiwa kama thamani ya kudumu, au haijathibitishwa ipasavyo au kuhusishwa na kikao cha watumiaji wakati wa kuingia, ikiruhusu washambuliaji kupita ulinzi wa CSRF.

Washambuliaji wanaweza kutumia hii kwa kukamata mchakato wa uthibitisho ili kuunganisha akaunti yao na akaunti ya mwathirika, na kusababisha **uchukuaji wa akaunti** kwa kumfanya mtumiaji aingie na mchakato wa oauth ulio karibu kukamilika unaomilikiwa na mshambuliaji. Hii ni muhimu hasa katika programu ambapo OAuth inatumika kwa **malengo ya uthibitishaji**.

Mifano halisi ya udhaifu huu imeandikwa katika changamoto mbalimbali za **CTF** na **majukwaa ya udukuzi**, ikionyesha athari zake za vitendo. Tatizo hili pia linapanuka kwa ushirikiano na huduma za tatu kama **Slack**, **Stripe**, na **PayPal**, ambapo washambuliaji wanaweza kuelekeza arifa au malipo kwa akaunti zao.

Usimamizi na uthibitisho sahihi wa **`state` parameter** ni muhimu kwa kulinda dhidi ya CSRF na kuhakikisha mchakato wa OAuth.

### Kabla ya Uchukuaji wa Akaunti <a href="#ebe4" id="ebe4"></a>

1. **Bila Uthibitisho wa Barua Pepe kwenye Uundaji wa Akaunti**: Washambuliaji wanaweza kuunda akaunti kabla kwa kutumia barua pepe ya mwathirika. Ikiwa mwathirika baadaye anatumia huduma ya tatu kuingia, programu inaweza bila kukusudia kuunganisha akaunti hii ya tatu na akaunti iliyoundwa na mshambuliaji, na kusababisha ufikiaji usioidhinishwa.
2. **Kutatua Uthibitisho wa Barua Pepe wa OAuth**: Washambuliaji wanaweza kutumia huduma za OAuth ambazo hazithibitishi barua pepe kwa kujiandikisha na huduma yao na kisha kubadilisha barua pepe ya akaunti kuwa ya mwathirika. Njia hii pia ina hatari ya ufikiaji usioidhinishwa wa akaunti, sawa na hali ya kwanza lakini kupitia njia tofauti ya shambulio.

### Ufunuo wa Siri <a href="#e177" id="e177"></a>

Kutambua na kulinda vigezo vya siri vya OAuth ni muhimu. Ingawa **`client_id`** inaweza kufichuliwa kwa usalama, kufichua **`client_secret`** kuna hatari kubwa. Ikiwa `client_secret` itavunjwa, washambuliaji wanaweza kutumia utambulisho na imani ya programu ili **kuiba `access_tokens` za mtumiaji** na taarifa binafsi.

Udhaifu wa kawaida unatokea wakati programu zinashughulikia kwa makosa kubadilishana `code` ya uthibitisho kwa `access_token` upande wa mteja badala ya upande wa seva. Makosa haya yanapelekea kufichuliwa kwa `client_secret`, ikiruhusu washambuliaji kuunda `access_tokens` chini ya kivuli cha programu. Zaidi ya hayo, kupitia uhandisi wa kijamii, washambuliaji wanaweza kuongeza mamlaka kwa kuongeza maeneo mengine kwenye uthibitisho wa OAuth, wakitumia zaidi hadhi ya kuaminika ya programu.

### Bruteforce ya Siri ya Mteja

Unaweza kujaribu **bruteforce the client_secret** ya mtoa huduma na mtoa kitambulisho ili kujaribu kuiba akaunti.\
Ombi la BF linaweza kuonekana kama:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Mara tu mteja ana **code and state**, ikiwa inatolewa ndani ya **Referer header** anapovinjari kwenye ukurasa tofauti, basi iko hatarini.

### Access Token Stored in Browser History

Nenda kwenye **browser history na uangalie kama access token imehifadhiwa huko**.

### Everlasting Authorization Code

**Authorization code inapaswa kuishi kwa muda fulani tu ili kupunguza dirisha la muda ambapo mshambuliaji anaweza kuiba na kuitumia**.

### Authorization/Refresh Token not bound to client

Ikiwa unaweza kupata **authorization code na kuifanya na mteja tofauti basi unaweza kuchukua akaunti nyingine**.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

Katika ripoti hii ya bug bounty: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) unaweza kuona kwamba **token** ambayo **AWS Cognito** inarudisha kwa mtumiaji inaweza kuwa na **idhini za kutosha kubadilisha data za mtumiaji**. Hivyo, ikiwa unaweza **kubadilisha barua pepe ya mtumiaji kwa barua pepe tofauti ya mtumiaji**, unaweza kuwa na uwezo wa **kuchukua** akaunti za wengine.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Kwa maelezo ya kina zaidi kuhusu jinsi ya kutumia AWS cognito, angalia:

{{#ref}}
https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html
{{#endref}}

### Kutumia token za Apps nyingine <a href="#bda5" id="bda5"></a>

Kama [**ilivyotajwa katika andiko hili**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), mchakato wa OAuth unaotarajia kupokea **token** (na si nambari) unaweza kuwa na hatari ikiwa hauhakiki kwamba token inamhusu mtumiaji wa programu.

Hii ni kwa sababu **mshambuliaji** anaweza kuunda **programu inayounga mkono OAuth na kuingia kwa Facebook** (kwa mfano) katika programu yake mwenyewe. Kisha, mara tu mwathirika anapoingia kwa Facebook katika **programu ya mshambuliaji**, mshambuliaji anaweza kupata **token ya OAuth ya mtumiaji iliyotolewa kwa programu yake, na kuitumia kuingia katika programu ya OAuth ya mwathirika kwa kutumia token ya mtumiaji wa mwathirika**.

> [!CAUTION]
> Hivyo, ikiwa mshambuliaji atafanikiwa kumfanya mtumiaji aingie katika programu yake ya OAuth, atakuwa na uwezo wa kuchukua akaunti ya mwathirika katika programu zinazotarajia token na hazikaguzi kama token hiyo ilitolewa kwa ID ya programu yao.

### Viungo viwili & cookie <a href="#bda5" id="bda5"></a>

Kulingana na [**andiko hili**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), ilikuwa inawezekana kumfanya mwathirika afungue ukurasa wenye **returnUrl** unaoelekeza kwenye mwenyeji wa mshambuliaji. Taarifa hii ingekuwa **imehifadhiwa katika cookie (RU)** na katika **hatua ya baadaye** **prompt** itakuwa **inauliza** **mtumiaji** kama anataka kutoa ufikiaji kwa mwenyeji wa mshambuliaji.

Ili kupita prompt hii, ilikuwa inawezekana kufungua tab ili kuanzisha **Oauth flow** ambayo ingeiweka cookie hii ya RU kwa kutumia **returnUrl**, kufunga tab kabla ya prompt kuonyeshwa, na kufungua tab mpya bila thamani hiyo. Kisha, **prompt haitatoa taarifa kuhusu mwenyeji wa mshambuliaji**, lakini cookie itakuwa imewekwa kwake, hivyo **token itatumwa kwa mwenyeji wa mshambuliaji** katika uelekezaji.

### Kupita Mwingiliano wa Prompt <a href="#bda5" id="bda5"></a>

Kama ilivyoelezwa katika [**video hii**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), baadhi ya utekelezaji wa OAuth huruhusu kuashiria **`prompt`** GET parameter kama None (**`&prompt=none`**) ili **kuzuia watumiaji kuulizwa kuthibitisha** ufikiaji uliopewa katika prompt kwenye wavuti ikiwa tayari wameingia kwenye jukwaa.

### response_mode

Kama [**ilivyoelezwa katika video hii**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), inaweza kuwa inawezekana kuashiria parameter **`response_mode`** ili kuashiria unataka nambari ipatikane wapi katika URL ya mwisho:

- `response_mode=query` -> Nambari inapatikana ndani ya parameter ya GET: `?code=2397rf3gu93f`
- `response_mode=fragment` -> Nambari inapatikana ndani ya parameter ya fragment ya URL `#code=2397rf3gu93f`
- `response_mode=form_post` -> Nambari inapatikana ndani ya fomu ya POST yenye input inayoitwa `code` na thamani
- `response_mode=web_message` -> Nambari inatumwa katika ujumbe wa posta: `window.opener.postMessage({"code": "asdasdasd...`

### Mchakato wa OAuth ROPC - kupita 2 FA <a href="#b440" id="b440"></a>

Kulingana na [**andiko hili**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), huu ni mchakato wa OAuth unaoruhusu kuingia katika OAuth kupitia **jina la mtumiaji** na **nenosiri**. Ikiwa wakati wa mchakato huu rahisi **token** yenye ufikiaji wa vitendo vyote ambavyo mtumiaji anaweza kufanya inarudishwa, basi inawezekana kupita 2FA kwa kutumia token hiyo.

### ATO kwenye ukurasa wa wavuti unaoelekeza kulingana na uelekezaji wazi kwa referrer <a href="#bda5" id="bda5"></a>

Huu [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) unazungumzia jinsi ilivyowezekana kutumia **upelelezi wazi** kwa thamani kutoka kwa **referrer** ili kutumia OAuth kwa ATO. Shambulio lilikuwa:

1. Mwathirika anafikia ukurasa wa wavuti wa mshambuliaji
2. Mwathirika anafungua kiungo kibaya na opener inaanzisha mchakato wa Google OAuth na `response_type=id_token,code&prompt=none` kama vigezo vya ziada kwa kutumia kama **referrer tovuti ya mshambuliaji**.
3. Katika opener, baada ya mtoa huduma kumruhusu mwathirika, inawapelekea nyuma kwa thamani ya parameter ya `redirect_uri` (wavuti ya mwathirika) kwa nambari ya 30X ambayo bado inashikilia tovuti ya mshambuliaji katika referrer.
4. Tovuti ya mwathirika **inasababisha uelekezaji wazi kulingana na referrer** ikielekeza mtumiaji wa mwathirika kwenye tovuti ya mshambuliaji, kwani **`respose_type`** ilikuwa **`id_token,code`**, nambari itarudishwa kwa mshambuliaji katika **fragment** ya URL ikimruhusu kuchukua akaunti ya mtumiaji kupitia Google kwenye tovuti ya mwathirika.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Angalia utafiti huu**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Kwa maelezo zaidi ya mbinu hii.**

Usajili wa Wateja wa Kijadi katika OAuth unatumika kama vector isiyo wazi lakini muhimu kwa udhaifu wa usalama, haswa kwa mashambulizi ya **Server-Side Request Forgery (SSRF)**. Endpoint hii inaruhusu seva za OAuth kupokea maelezo kuhusu programu za wateja, ikiwa ni pamoja na URLs nyeti ambazo zinaweza kutumika vibaya.

**Mambo Muhimu:**

- **Usajili wa Wateja wa Kijadi** mara nyingi unahusishwa na `/register` na unakubali maelezo kama `client_name`, `client_secret`, `redirect_uris`, na URLs za alama au JSON Web Key Sets (JWKs) kupitia maombi ya POST.
- Kipengele hiki kinazingatia vipimo vilivyowekwa katika **RFC7591** na **OpenID Connect Registration 1.0**, ambavyo vinajumuisha vigezo ambavyo vinaweza kuwa na hatari kwa SSRF.
- Mchakato wa usajili unaweza bila kukusudia kufichua seva kwa SSRF kwa njia kadhaa:
- **`logo_uri`**: URL ya alama ya programu ya mteja ambayo inaweza kupatikana na seva, ikisababisha SSRF au kupelekea XSS ikiwa URL itashughulikiwa vibaya.
- **`jwks_uri`**: URL ya hati ya JWK ya mteja, ambayo ikiwa imeundwa kwa njia mbaya, inaweza kusababisha seva kufanya maombi ya nje kwa seva inayodhibitiwa na mshambuliaji.
- **`sector_identifier_uri`**: Inarejelea orodha ya JSON ya `redirect_uris`, ambayo seva inaweza kupakua, ikisababisha fursa ya SSRF.
- **`request_uris`**: Inataja URIs za maombi zinazoruhusiwa kwa mteja, ambazo zinaweza kutumika vibaya ikiwa seva itachukua URIs hizi mwanzoni mwa mchakato wa uthibitishaji.

**Mkakati wa Kutumia:**

- SSRF inaweza kuanzishwa kwa kujiandikisha mteja mpya na URLs mbaya katika vigezo kama `logo_uri`, `jwks_uri`, au `sector_identifier_uri`.
- Ingawa matumizi ya moja kwa moja kupitia `request_uris` yanaweza kupunguziliwa mbali na udhibiti wa orodha ya ruhusa, kutoa `request_uri` iliyosajiliwa awali, inayodhibitiwa na mshambuliaji kunaweza kuwezesha SSRF wakati wa hatua ya uthibitishaji.

## Masharti ya Mshindani wa OAuth

Ikiwa jukwaa unalojaribu ni mtoa huduma wa OAuth [**soma hii ili kujaribu uwezekano wa Masharti ya Mshindani**](race-condition.md).

## Shambulio la Mutable Claims

Katika OAuth, uwanja wa sub unamfanya mtumiaji kuwa wa kipekee, lakini muundo wake hutofautiana na Seva ya Uidhinishaji. Ili kuimarisha utambulisho wa mtumiaji, baadhi ya wateja hutumia barua pepe au vitambulisho vya mtumiaji. Hata hivyo, hii ni hatari kwa sababu:

- Baadhi ya Seva za Uidhinishaji hazihakikishi kwamba mali hizi (kama barua pepe) zinabaki kuwa zisizobadilika.
- Katika utekelezaji fulani—kama **"Ingia na Microsoft"**—mteja anategemea uwanja wa barua pepe, ambao ni **unaodhibitiwa na mtumiaji katika Entra ID** na hauhakikishwi.
- Mshambuliaji anaweza kutumia hii kwa kuunda shirika lake la Azure AD (kwa mfano, doyensectestorg) na kulitumika kufanya kuingia kwa Microsoft.
- Ingawa Kitambulisho cha Kitu (kilichohifadhiwa katika sub) ni kisichobadilika na salama, kutegemea uwanja wa barua pepe unaoweza kubadilika kunaweza kuwezesha kuchukuliwa kwa akaunti (kwa mfano, kuiba akaunti kama victim@gmail.com).

## Shambulio la Kichanganyiko cha Mteja

Katika **Shambulio la Kichanganyiko cha Mteja**, programu inayotumia Mchakato wa OAuth Implicit inashindwa kuthibitisha kwamba token ya mwisho ya ufikiaji imeundwa mahsusi kwa ID yake ya Mteja. Mshambuliaji anaunda tovuti ya umma inayotumia Mchakato wa OAuth Implicit wa Google, akiwadanganya maelfu ya watumiaji kuingia na hivyo kukusanya token za ufikiaji zilizokusudiwa kwa tovuti ya mshambuliaji. Ikiwa watumiaji hawa pia wana akaunti kwenye tovuti nyingine iliyo hatarini ambayo haithibitishi ID ya token, mshambuliaji anaweza kutumia tena token zilizokusanywa ili kujifanya kuwa waathirika na kuchukua akaunti zao.

## Shambulio la Kuongeza Mipaka

Aina ya **Authorization Code Grant** inahusisha mawasiliano salama ya seva kwa seva kwa kuhamasisha data ya mtumiaji. Hata hivyo, ikiwa **Seva ya Uidhinishaji** inategemea kwa siri parameter ya mipaka katika Maombi ya Token ya Ufikiaji (parameter ambayo haijafafanuliwa katika RFC), programu mbaya inaweza kuongeza mamlaka ya nambari ya uidhinishaji kwa kuomba mipaka ya juu. Baada ya **Token ya Ufikiaji** kuundwa, **Seva ya Rasilimali** inapaswa kuithibitisha: kwa token za JWT, hii inahusisha kuangalia saini ya JWT na kutoa data kama client_id na scope, wakati kwa token za mfuatano wa nasibu, seva inapaswa kuuliza Seva ya Uidhinishaji ili kupata maelezo ya token.

## Hijacking ya Mpango wa Uelekezaji

Katika utekelezaji wa OAuth wa simu, programu hutumia **mifumo ya URI maalum** kupokea uelekezaji wenye Nambari za Uidhinishaji. Hata hivyo, kwa sababu programu nyingi zinaweza kujiandikisha mfumo sawa kwenye kifaa, dhana kwamba mteja halali pekee ndiye anayekontrola URI ya uelekezaji inavunjwa. Kwenye Android, kwa mfano, URI ya Intent kama `com.example.app://` oauth inakamatwa kulingana na mfumo na filters za hiari zilizofafanuliwa katika intent-filter ya programu. Kwa kuwa ufumbuzi wa nia ya Android unaweza kuwa mpana—hasa ikiwa tu mfumo umeainishwa—mshambuliaji anaweza kujiandikisha programu mbaya yenye filter ya nia iliyoundwa kwa uangalifu ili kuiba nambari ya uidhinishaji. Hii inaweza **kuwezesha kuchukuliwa kwa akaunti** ama kupitia mwingiliano wa mtumiaji (wakati programu nyingi zinastahili kushughulikia nia hiyo) au kupitia mbinu za kupita zinazotumia filters zisizo sahihi, kama ilivyoelezwa na mchoro wa tathmini wa Ostorlab.

## Marejeleo

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)

{{#include ../banners/hacktricks-training.md}}
