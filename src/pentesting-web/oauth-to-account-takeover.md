# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Basic Information <a href="#d4a8" id="d4a8"></a>

OAuth inatoa toleo mbalimbali, huku maarifa ya msingi yanapatikana katika [OAuth 2.0 documentation](https://oauth.net/2/). Majadiliano haya yanazingatia hasa [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), ikitoa **mfumo wa idhini unaowezesha programu kufikia au kufanya vitendo kwenye akaunti ya mtumiaji katika programu nyingine** (seva ya idhini).

Fikiria tovuti ya mfano _**https://example.com**_, iliyoundwa ili **kuonyesha machapisho yako yote ya mitandao ya kijamii**, ikiwa ni pamoja na ya faragha. Ili kufanikisha hili, OAuth 2.0 inatumika. _https://example.com_ itahitaji ruhusa yako ili **kufikia machapisho yako ya mitandao ya kijamii**. Kwa hivyo, skrini ya idhini itaonekana kwenye _https://socialmedia.com_, ikielezea **ruhusa zinazohitajika na mtengenezaji anayefanya ombi**. Baada ya idhini yako, _https://example.com_ inapata uwezo wa **kufikia machapisho yako kwa niaba yako**.

Ni muhimu kuelewa vipengele vifuatavyo ndani ya mfumo wa OAuth 2.0:

- **mwenye rasilimali**: Wewe, kama **mtumiaji/kitengo**, unaruhusu ufikiaji wa rasilimali yako, kama vile machapisho ya akaunti yako ya mitandao ya kijamii.
- **seva ya rasilimali**: **seva inayosimamia maombi yaliyothibitishwa** baada ya programu kupata `access token` kwa niaba ya `mwenye rasilimali`, mfano, **https://socialmedia.com**.
- **programu ya mteja**: **programu inayotafuta idhini** kutoka kwa `mwenye rasilimali`, kama **https://example.com**.
- **seva ya idhini**: **seva inayotoa `access tokens`** kwa `programu ya mteja` baada ya uthibitisho wa mafanikio wa `mwenye rasilimali` na kupata idhini, mfano, **https://socialmedia.com**.
- **client_id**: Kitambulisho cha umma, cha kipekee kwa programu.
- **client_secret:** Funguo ya siri, inayojulikana pekee kwa programu na seva ya idhini, inayotumika kwa ajili ya kuzalisha `access_tokens`.
- **response_type**: Thamani inayobainisha **aina ya token inayohitajika**, kama `code`.
- **scope**: **ngazi ya ufikiaji** ambayo `programu ya mteja` inahitaji kutoka kwa `mwenye rasilimali`.
- **redirect_uri**: **URL ambayo mtumiaji anarejeshwa baada ya idhini**. Hii kwa kawaida inapaswa kuendana na URL ya kuhamasisha iliyosajiliwa awali.
- **state**: Kigezo cha **kuhifadhi data wakati wa kuelekeza mtumiaji kwenda na kurudi kutoka kwa seva ya idhini**. Upekee wake ni muhimu kwa ajili ya kutumikia kama **mekanismu ya ulinzi wa CSRF**.
- **grant_type**: Kigezo kinachoashiria **aina ya idhini na aina ya token itakayorejeshwa**.
- **code**: Kodu ya idhini kutoka kwa `seva ya idhini`, inayotumika pamoja na `client_id` na `client_secret` na programu ya mteja ili kupata `access_token`.
- **access_token**: **token ambayo programu ya mteja inatumia kwa maombi ya API** kwa niaba ya `mwenye rasilimali`.
- **refresh_token**: Inaruhusu programu **kupata `access_token` mpya bila kumlazimisha mtumiaji tena**.

### Flow

**mchakato halisi wa OAuth** unaendelea kama ifuatavyo:

1. Unatembelea [https://example.com](https://example.com) na kuchagua kitufe cha “Integrate with Social Media”.
2. Tovuti hiyo kisha inatuma ombi kwa [https://socialmedia.com](https://socialmedia.com) ikitaka ruhusa yako ili kuruhusu programu ya https://example.com kufikia machapisho yako. Ombi limeandikwa kama:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Kisha unawasilishwa na ukurasa wa idhini.  
4. Kufuatia idhini yako, Social Media inatuma jibu kwa `redirect_uri` pamoja na vigezo vya `code` na `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com inatumia `code` hii, pamoja na `client_id` na `client_secret`, kufanya ombi la upande wa seva ili kupata `access_token` kwa niaba yako, ikiruhusu ufikiaji wa ruhusa ulizokubali:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Hatimaye, mchakato unamalizika wakati https://example.com inatumia `access_token` yako kufanya wito wa API kwa Social Media ili kufikia

## Vulnerabilities <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

`redirect_uri` ni muhimu kwa usalama katika utekelezaji wa OAuth na OpenID, kwani inaelekeza mahali ambapo data nyeti, kama vile nambari za idhini, zinatumwa baada ya idhini. Ikiwa imewekwa vibaya, inaweza kuruhusu washambuliaji kuelekeza maombi haya kwa seva mbaya, na kuwezesha kuchukuliwa kwa akaunti.

Mbinu za unyakuzi zinatofautiana kulingana na mantiki ya uthibitishaji ya seva ya idhini. Zinweza kutofautiana kutoka kwa mechi kali ya njia hadi kukubali URL yoyote ndani ya kikoa kilichotajwa au saraka ndogo. Mbinu za kawaida za unyakuzi ni pamoja na mwelekeo wazi, kupita njia, kutumia regex dhaifu, na kuingiza HTML kwa wizi wa token.

Mbali na `redirect_uri`, vigezo vingine vya OAuth na OpenID kama `client_uri`, `policy_uri`, `tos_uri`, na `initiate_login_uri` pia vinahatarishwa kwa mashambulizi ya kuelekeza. Vigezo hivi ni hiari na msaada wao unategemea seva.

Kwa wale wanaolenga seva ya OpenID, kiunganishi cha ugunduzi (`**.well-known/openid-configuration**`) mara nyingi huorodhesha maelezo muhimu ya usanidi kama vile `registration_endpoint`, `request_uri_parameter_supported`, na "`require_request_uri_registration`. Maelezo haya yanaweza kusaidia katika kubaini kiunganishi cha usajili na maelezo mengine ya usanidi ya seva.

### XSS katika utekelezaji wa kuelekeza <a href="#bda5" id="bda5"></a>

Kama ilivyotajwa katika ripoti hii ya bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) inaweza kuwa inawezekana kwamba **URL ya kuelekeza inarudiwa katika jibu** la seva baada ya mtumiaji kuthibitisha, ikiwa **hatarini kwa XSS**. Payload inay posible kujaribu:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Usimamizi mbaya wa parameter ya hali <a href="#bda5" id="bda5"></a>

Katika utekelezaji wa OAuth, matumizi mabaya au kukosekana kwa **`state` parameter** kunaweza kuongeza hatari ya mashambulizi ya **Cross-Site Request Forgery (CSRF)** kwa kiasi kikubwa. Uthibitisho huu unatokea wakati **`state` parameter** haijatumiwa, imetumiwa kama thamani ya kudumu, au haijathibitishwa ipasavyo au kuhusishwa na kikao cha watumiaji** wakati wa kuingia, ikiruhusu washambuliaji kupita ulinzi wa CSRF.

Washambuliaji wanaweza kutumia hii kwa kukamata mchakato wa uthibitisho ili kuunganisha akaunti yao na akaunti ya mwathirika, na kusababisha **uchukuaji wa akaunti** kwa kumfanya mtumiaji aingie na mtiririko wa oauth ulio karibu kukamilika unaomilikiwa na mshambuliaji. Hii ni muhimu hasa katika programu ambapo OAuth inatumika kwa **malengo ya uthibitishaji**.

Mifano halisi ya udhaifu huu imeandikwa katika changamoto mbalimbali za **CTF** na **majukwaa ya hacking**, ikionyesha athari zake za vitendo. Tatizo hili pia linapanuka kwa ushirikiano na huduma za upande wa tatu kama **Slack**, **Stripe**, na **PayPal**, ambapo washambuliaji wanaweza kuelekeza arifa au malipo kwa akaunti zao.

Usimamizi na uthibitisho sahihi wa **`state` parameter** ni muhimu kwa kulinda dhidi ya CSRF na kuhakikisha mchakato wa OAuth.

### Kabla ya Uchukuaji wa Akaunti <a href="#ebe4" id="ebe4"></a>

1. **Bila Uthibitisho wa Barua Pepe kwenye Uundaji wa Akaunti**: Washambuliaji wanaweza kuunda akaunti kabla kwa kutumia barua pepe ya mwathirika. Ikiwa mwathirika baadaye anatumia huduma ya upande wa tatu kuingia, programu inaweza bila kukusudia kuunganisha akaunti hii ya upande wa tatu na akaunti iliyoundwa mapema na mshambuliaji, na kusababisha ufikiaji usioidhinishwa.
2. **Kutatua Uthibitisho wa Barua Pepe wa OAuth**: Washambuliaji wanaweza kutumia huduma za OAuth ambazo hazithibitishi barua pepe kwa kujiandikisha na huduma yao na kisha kubadilisha barua pepe ya akaunti kuwa ya mwathirika. Njia hii pia ina hatari ya ufikiaji usioidhinishwa wa akaunti, sawa na hali ya kwanza lakini kupitia njia tofauti ya shambulio.

### Ufunuo wa Siri <a href="#e177" id="e177"></a>

Kutambua na kulinda vigezo vya siri vya OAuth ni muhimu. Ingawa **`client_id`** inaweza kufichuliwa kwa usalama, kufichua **`client_secret`** kuna hatari kubwa. Ikiwa **`client_secret`** itavunjwa, washambuliaji wanaweza kutumia utambulisho na imani ya programu ili **kuiba `access_tokens` za mtumiaji** na taarifa binafsi.

Udhaifu wa kawaida unatokea wakati programu zinashughulikia kwa makosa kubadilishana `code` ya uthibitisho kwa `access_token` upande wa mteja badala ya upande wa seva. Makosa haya yanapelekea kufichuliwa kwa **`client_secret`**, ikiruhusu washambuliaji kuunda `access_tokens` chini ya kivuli cha programu. Zaidi ya hayo, kupitia uhandisi wa kijamii, washambuliaji wanaweza kuongeza mamlaka kwa kuongeza maeneo mengine kwenye uthibitisho wa OAuth, wakitumia zaidi hadhi ya kuaminika ya programu.

### Bruteforce ya Siri ya Mteja

Unaweza kujaribu **bruteforce the client_secret** ya mtoa huduma na mtoa kitambulisho ili kujaribu kuiba akaunti.\
Ombi la BF linaweza kuonekana kama:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Mara tu mteja ana **code and state**, ikiwa inatolewa ndani ya **Referer header** anapovinjari kwenye ukurasa tofauti, basi iko hatarini.

### Access Token Stored in Browser History

Nenda kwenye **browser history na uangalie kama access token imehifadhiwa huko**.

### Everlasting Authorization Code

**Authorization code inapaswa kuishi kwa muda fulani tu ili kupunguza muda ambao mshambuliaji anaweza kuiba na kuitumia**.

### Authorization/Refresh Token not bound to client

Ikiwa unaweza kupata **authorization code na kuifanya na mteja tofauti basi unaweza kuchukua akaunti nyingine**.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

Katika ripoti hii ya bug bounty: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) unaweza kuona kwamba **token** ambayo **AWS Cognito** inarudisha kwa mtumiaji inaweza kuwa na **idhini za kutosha kubadilisha data za mtumiaji**. Hivyo, ikiwa unaweza **kubadilisha barua pepe ya mtumiaji kwa barua pepe tofauti ya mtumiaji**, unaweza kuwa na uwezo wa **kuchukua** akaunti za wengine.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Kwa maelezo ya kina zaidi kuhusu jinsi ya kutumia AWS cognito, angalia:

{{#ref}}
https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html
{{#endref}}

### Kutumia token za Apps nyingine <a href="#bda5" id="bda5"></a>

Kama [**ilivyotajwa katika andiko hili**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), mchakato wa OAuth unaotarajia kupokea **token** (na si nambari) unaweza kuwa na hatari ikiwa hauhakiki kwamba token inamhusu mtumiaji wa programu.

Hii ni kwa sababu **mshambuliaji** anaweza kuunda **programu inayounga mkono OAuth na kuingia kwa Facebook** (kwa mfano) katika programu yake mwenyewe. Kisha, mara tu mwathirika anapoingia kwa Facebook katika **programu ya mshambuliaji**, mshambuliaji anaweza kupata **token ya OAuth ya mtumiaji iliyotolewa kwa programu yake, na kuitumia kuingia katika programu ya OAuth ya mwathirika kwa kutumia token ya mtumiaji wa mwathirika**.

> [!CAUTION]
> Hivyo, ikiwa mshambuliaji atafanikiwa kumfanya mtumiaji aingie katika programu yake ya OAuth, atakuwa na uwezo wa kuchukua akaunti ya mwathirika katika programu zinazotarajia token na hazikaguzi kama token hiyo ilitolewa kwa ID ya programu yao.

### Viungo viwili & cookie <a href="#bda5" id="bda5"></a>

Kulingana na [**andiko hili**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), ilikuwa inawezekana kumfanya mwathirika afungue ukurasa wenye **returnUrl** unaoelekeza kwenye mwenyeji wa mshambuliaji. Taarifa hii ingekuwa **imehifadhiwa katika cookie (RU)** na katika **hatua ya baadaye** **prompt** itakuwa **inauliza** **mtumiaji** kama anataka kutoa ufikiaji kwa mwenyeji wa mshambuliaji.

Ili kupita prompt hii, ilikuwa inawezekana kufungua tab ili kuanzisha **Oauth flow** ambayo ingeiweka cookie hii RU kwa kutumia **returnUrl**, kufunga tab kabla ya prompt kuonyeshwa, na kufungua tab mpya bila thamani hiyo. Kisha, **prompt haitatoa taarifa kuhusu mwenyeji wa mshambuliaji**, lakini cookie ingekuwa imewekwa kwake, hivyo **token itatumwa kwa mwenyeji wa mshambuliaji** katika uelekezaji.

### Kupita Mwingiliano wa Prompt <a href="#bda5" id="bda5"></a>

Kama ilivyoelezwa katika [**video hii**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), baadhi ya utekelezaji wa OAuth huruhusu kuashiria **`prompt`** GET parameter kama None (**`&prompt=none`**) ili **kuzuia watumiaji kuombwa kuthibitisha** ufikiaji uliopewa katika prompt kwenye wavuti ikiwa tayari wameingia kwenye jukwaa.

### response_mode

Kama [**ilivyoelezwa katika video hii**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), inaweza kuwa inawezekana kuashiria parameter **`response_mode`** kuonyesha unataka nambari ipi itolewe katika URL ya mwisho:

- `response_mode=query` -> Nambari inatolewa ndani ya parameter ya GET: `?code=2397rf3gu93f`
- `response_mode=fragment` -> Nambari inatolewa ndani ya parameter ya URL fragment `#code=2397rf3gu93f`
- `response_mode=form_post` -> Nambari inatolewa ndani ya fomu ya POST yenye input inayoitwa `code` na thamani
- `response_mode=web_message` -> Nambari inatumwa katika ujumbe wa posta: `window.opener.postMessage({"code": "asdasdasd...`

### Mchakato wa OAuth ROPC - kupita 2 FA <a href="#b440" id="b440"></a>

Kulingana na [**andiko hili**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), huu ni mchakato wa OAuth unaoruhusu kuingia katika OAuth kupitia **jina la mtumiaji** na **nenosiri**. Ikiwa wakati wa mchakato huu rahisi **token** yenye ufikiaji kwa vitendo vyote ambavyo mtumiaji anaweza kufanya inarudishwa, basi inawezekana kupita 2FA kwa kutumia token hiyo.

### ATO kwenye ukurasa wa wavuti unaoelekeza kulingana na uelekezaji wazi kwa referrer <a href="#bda5" id="bda5"></a>

Hii [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) inaelezea jinsi ilivyowezekana kutumia **upelelezi wazi** kwa thamani kutoka kwa **referrer** ili kutumia OAuth kwa ATO. Shambulio lilikuwa:

1. Mwathirika anafikia ukurasa wa wavuti wa mshambuliaji
2. Mwathirika anafungua kiungo kibaya na opener inaanzisha mchakato wa Google OAuth na `response_type=id_token,code&prompt=none` kama vigezo vya ziada kwa kutumia kama **referrer tovuti ya mshambuliaji**.
3. Katika opener, baada ya mtoa huduma kumruhusu mwathirika, inawapelekea nyuma kwa thamani ya parameter ya `redirect_uri` (wavuti ya mwathirika) kwa nambari ya 30X ambayo bado inashikilia tovuti ya mshambuliaji katika referrer.
4. Tovuti ya mwathirika **inasababisha uelekezaji wazi kulingana na referrer** ikielekeza mtumiaji wa mwathirika kwenye tovuti ya mshambuliaji, kwani **`respose_type`** ilikuwa **`id_token,code`**, nambari itarudishwa kwa mshambuliaji katika **fragment** ya URL ikimruhusu kuchukua akaunti ya mtumiaji kupitia Google kwenye tovuti ya mwathirika.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Angalia utafiti huu**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Kwa maelezo zaidi ya mbinu hii.**

Usajili wa Wateja wa Kijivu katika OAuth unatumika kama njia isiyo wazi lakini muhimu kwa udhaifu wa usalama, haswa kwa mashambulizi ya **Server-Side Request Forgery (SSRF)**. Endpoint hii inaruhusu seva za OAuth kupokea maelezo kuhusu programu za wateja, ikiwa ni pamoja na URLs nyeti ambazo zinaweza kutumika vibaya.

**Mambo Muhimu:**

- **Usajili wa Wateja wa Kijivu** mara nyingi unahusishwa na `/register` na unakubali maelezo kama `client_name`, `client_secret`, `redirect_uris`, na URLs za alama au JSON Web Key Sets (JWKs) kupitia maombi ya POST.
- Kipengele hiki kinatii viwango vilivyowekwa katika **RFC7591** na **OpenID Connect Registration 1.0**, ambavyo vinajumuisha vigezo ambavyo vinaweza kuwa na hatari kwa SSRF.
- Mchakato wa usajili unaweza bila kukusudia kufichua seva kwa SSRF kwa njia kadhaa:
- **`logo_uri`**: URL ya alama ya programu ya mteja ambayo inaweza kupatikana na seva, ikisababisha SSRF au kupelekea XSS ikiwa URL itashughulikiwa vibaya.
- **`jwks_uri`**: URL ya hati ya JWK ya mteja, ambayo ikiwa imeundwa kwa njia mbaya, inaweza kusababisha seva kufanya maombi ya nje kwa seva inayodhibitiwa na mshambuliaji.
- **`sector_identifier_uri`**: Inarejelea orodha ya JSON ya `redirect_uris`, ambayo seva inaweza kupakua, ikisababisha fursa ya SSRF.
- **`request_uris`**: Inataja URIs za maombi zinazoruhusiwa kwa mteja, ambazo zinaweza kutumika vibaya ikiwa seva itachukua URIs hizi mwanzoni mwa mchakato wa uthibitishaji.

**Mkakati wa Kutumia Vibaya:**

- SSRF inaweza kusababishwa kwa kujiandikisha mteja mpya na URLs mbaya katika vigezo kama `logo_uri`, `jwks_uri`, au `sector_identifier_uri`.
- Ingawa matumizi ya moja kwa moja kupitia `request_uris` yanaweza kupunguziliwa mbali na udhibiti wa orodha ya ruhusa, kutoa `request_uri` iliyosajiliwa awali, inayodhibitiwa na mshambuliaji kunaweza kuwezesha SSRF wakati wa hatua ya uthibitishaji.

## Mashindano ya Watoa huduma wa OAuth

Ikiwa jukwaa unalojaribu ni mtoa huduma wa OAuth [**soma hii ili kujaribu uwezekano wa Mashindano ya Wakati**](race-condition.md).

## Shambulio la Mutable Claims

Katika OAuth, uwanja wa sub unamfanya mtumiaji kuwa wa kipekee, lakini muundo wake hutofautiana kulingana na Seva ya Uidhinishaji. Ili kuimarisha utambulisho wa mtumiaji, baadhi ya wateja hutumia barua pepe au vitambulisho vya watumiaji. Hata hivyo, hii ni hatari kwa sababu:

- Baadhi ya Seva za Uidhinishaji hazihakikishi kwamba mali hizi (kama barua pepe) zinabaki kuwa zisizobadilika.
- Katika utekelezaji fulani—kama **"Ingia na Microsoft"**—mteja anategemea uwanja wa barua pepe, ambao ni **udhibitiwa na mtumiaji katika Entra ID** na hauhakikishwi.
- Mshambuliaji anaweza kutumia hii kwa kuunda shirika lake la Azure AD (kwa mfano, doyensectestorg) na kulitumika kufanya kuingia kwa Microsoft.
- Ingawa Kitambulisho cha Kitu (kilichohifadhiwa katika sub) ni kisichobadilika na salama, kutegemea uwanja wa barua pepe unaoweza kubadilika kunaweza kuwezesha kuchukuliwa kwa akaunti (kwa mfano, kuiba akaunti kama victim@gmail.com).

## Shambulio la Kichanganyiko cha Wateja

Katika **Shambulio la Kichanganyiko cha Wateja**, programu inayotumia Mchakato wa OAuth Implicit inashindwa kuthibitisha kwamba token ya mwisho ya ufikiaji imeundwa mahsusi kwa ID yake ya Mteja. Mshambuliaji anaanzisha tovuti ya umma inayotumia Mchakato wa OAuth Implicit wa Google, akiwadanganya maelfu ya watumiaji kuingia na hivyo kukusanya token za ufikiaji zilizokusudiwa kwa tovuti ya mshambuliaji. Ikiwa watumiaji hawa pia wana akaunti kwenye tovuti nyingine yenye hatari ambayo haithibitishi ID ya token, mshambuliaji anaweza kutumia tena token zilizokusanywa ili kujifanya kuwa waathirika na kuchukua akaunti zao.

## Shambulio la Kuongeza Mipaka

Aina ya **Authorization Code Grant** inahusisha mawasiliano salama ya seva kwa seva kwa kuhamasisha data ya mtumiaji. Hata hivyo, ikiwa **Seva ya Uidhinishaji** inategemea kwa siri parameter ya mipaka katika Maombi ya Token ya Ufikiaji (parameter ambayo haijafafanuliwa katika RFC), programu mbaya inaweza kuongeza mamlaka ya nambari ya uidhinishaji kwa kuomba mipaka ya juu. Baada ya **Token ya Ufikiaji** kutolewa, **Seva ya Rasilimali** inapaswa kuithibitisha: kwa token za JWT, hii inahusisha kuangalia saini ya JWT na kutoa data kama client_id na mipaka, wakati kwa token za nambari za nasibu, seva inapaswa kuuliza Seva ya Uidhinishaji ili kupata maelezo ya token.

## Utekelezaji wa Mpango wa Uelekezaji

Katika utekelezaji wa OAuth wa simu, programu hutumia **mipango ya URI maalum** kupokea uelekezaji na Nambari za Uidhinishaji. Hata hivyo, kwa sababu programu nyingi zinaweza kujiandikisha mipango sawa kwenye kifaa, dhana kwamba mteja halali pekee ndiye anayekontrol uelekezi wa URI inavunjwa. Kwenye Android, kwa mfano, URI ya Intent kama `com.example.app://` oauth inakamatwa kulingana na mpango na filters za hiari zilizofafanuliwa katika intent-filter ya programu. Kwa kuwa ufumbuzi wa intent wa Android unaweza kuwa mpana—hasa ikiwa mpango pekee umeainishwa—mshambuliaji anaweza kujiandikisha programu mbaya yenye filter ya intent iliyoundwa kwa uangalifu ili kuchukua nambari ya uidhinishaji. Hii inaweza **kuwezesha kuchukuliwa kwa akaunti** ama kupitia mwingiliano wa mtumiaji (wakati programu nyingi zinastahili kushughulikia intent) au kupitia mbinu za kupita ambazo zinatumia filters zisizo za kawaida, kama ilivyoelezwa na mchoro wa tathmini wa Ostorlab.

## Marejeleo

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)

{{#include ../banners/hacktricks-training.md}}
