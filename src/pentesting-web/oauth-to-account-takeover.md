# OAuth до захоплення облікового запису

{{#include ../banners/hacktricks-training.md}}

## Основна інформація <a href="#d4a8" id="d4a8"></a>

OAuth offers various versions, with foundational insights accessible at [OAuth 2.0 documentation](https://oauth.net/2/). This discussion primarily centers on the widely used [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), providing an **authorization framework that enables an application to access or perform actions on a user's account in another application** (the authorization server).

Розглянемо гіпотетичний сайт _**https://example.com**_, створений для **відображення всіх ваших публікацій у соціальних мережах**, включно з приватними. Для цього використовується OAuth 2.0. _https://example.com_ запросить ваш дозвіл на **доступ до ваших публікацій у соціальних мережах**. Внаслідок цього на _https://socialmedia.com_ з'явиться екран згоди, де буде вказано **запитувані дозволи та розробника, який робить запит**. Після вашого схвалення _https://example.com_ отримає можливість **доступатися до ваших публікацій від вашого імені**.

Слід розуміти такі компоненти в рамках OAuth 2.0:

- **resource owner**: Ви, як **користувач/суб'єкт**, надаєте дозвіл на доступ до свого ресурсу, наприклад до публікацій у вашому акаунті соціальної мережі.
- **resource server**: Сервер, що обробляє аутентифіковані запити після того, як додаток отримав `access token` від імені `resource owner`, напр., **https://socialmedia.com**.
- **client application**: Додаток, що **запитує авторизацію** у `resource owner`, наприклад **https://example.com**.
- **authorization server**: Сервер, що **видає `access tokens`** `client application` після успішної аутентифікації `resource owner` і надання дозволу, напр., **https://socialmedia.com**.
- **client_id**: Публічний унікальний ідентифікатор додатка.
- **client_secret:** Конфіденційний ключ, відомий лише додатку та authorization server, що використовується для отримання `access_tokens`.
- **response_type**: Значення, що вказує **тип запитуваного токена**, наприклад `code`.
- **scope**: Рівень доступу, який `client application` запитує у `resource owner`.
- **redirect_uri**: URL, на який користувача буде перенаправлено після авторизації. Зазвичай має збігатися з попередньо зареєстрованою redirect URL.
- **state**: Параметр для **збереження даних під час перенаправлення користувача до та від authorization server**. Унікальність цього значення важлива для виконання ролі **захисту від CSRF**.
- **grant_type**: Параметр, що вказує **тип гранту та тип токена, який має бути повернутий**.
- **code**: Код авторизації від `authorization server`, який використовується разом з `client_id` та `client_secret` клієнтським додатком для отримання `access_token`.
- **access_token**: Токен, яким `client application` користується для API-запитів від імені `resource owner`.
- **refresh_token**: Дозволяє додатку **отримати новий `access_token` без повторного запиту дозволу у користувача**.

### Flow

The **actual OAuth flow** proceeds as follows:

1. Ви переходите на [https://example.com](https://example.com) і натискаєте кнопку “Integrate with Social Media”.
2. Сайт надсилає запит до [https://socialmedia.com](https://socialmedia.com), просячи вашого дозволу, щоб додаток https://example.com отримав доступ до ваших публікацій. Запит має таку структуру:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Потім вам показують сторінку згоди.
4. Після вашого підтвердження, Social Media надсилає відповідь на `redirect_uri` з параметрами `code` та `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com використовує цей `code`, разом зі своїм `client_id` та `client_secret`, щоб зробити серверний запит і отримати `access_token` від вашого імені, що дає доступ до дозволів, на які ви погодилися:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Нарешті, процес завершується тим, що https://example.com використовує ваш `access_token` для виконання API-запиту до соціальної мережі для доступу

## Vulnerabilities <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Згідно з [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), authorization server повинен перенаправляти браузер лише на попередньо зареєстровані, точні redirect URI. Будь-яка слабкість тут дозволяє атакуючому направити жертву через зловмисний authorization URL так, що IdP доставляє `code` (і `state`) жертви безпосередньо на endpoint атакуючого, який потім може його обміняти та зібрати токени.

Типовий сценарій атаки:

1. Сконструювати `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` і надіслати його жертві.
2. Жертва аутентифікується та погоджується на scopes.
3. IdP редиректить на `attacker.tld/callback?code=<victim-code>&state=...`, де атакуючий логуює запит і негайно обмінює code.

Поширені помилки валідації для перевірки:

- **No validation** – приймається будь-який абсолютний URL, що призводить до миттєвого крадіжки code.
- **Weak substring/regex checks on the host** – обійти можна за допомогою lookalike-ів, таких як `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, або `match.com@evil.com`.
- **IDN homograph mismatches** – валідація відбувається у punycode-формі (`xn--`), але браузер редиректить на Unicode-домен, контрольований атакуючим.
- **Arbitrary paths on an allowed host** – вказавши `redirect_uri` на `/openredirect?next=https://attacker.tld` або будь-який XSS/user-content endpoint, це leaks the code або через ланцюжки редиректів, Referer headers, або вбудований JavaScript.
- **Directory constraints without normalization** – шаблони на кшталт `/oauth/*` можна обійти за допомогою `/oauth/../anything`.
- **Wildcard subdomains** – прийняття `*.example.com` означає, що будь-яке takeover (dangling DNS, S3 bucket, тощо) миттєво дає дійсний callback.
- **Non-HTTPS callbacks** – пропуск `http://` URI дає мережевим атакуючим (Wi-Fi, корпоративний проксі) можливість вкрасти code під час передачі.

Також перевірте допоміжні параметри у стилі redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, тощо) та OpenID discovery document (`/.well-known/openid-configuration`) на наявність додаткових endpoint-ів, які можуть успадкувати ті самі помилки валідації.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Як зазначено в цьому bug bounty звіті [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), можливо, що redirect **URL відображається у відповіді** сервера після аутентифікації користувача і є **vulnerable to XSS**. Можливий payload для тестування:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Неправильна обробка параметра `state` <a href="#bda5" id="bda5"></a>

Параметр `state` — це CSRF-токен Authorization Code flow: клієнт має згенерувати **криптографічно випадкове значення для кожного екземпляра браузера**, зберегти його в місці, до якого має доступ тільки цей браузер (cookie, local storage тощо), відправити в запиті авторизації і відкидати будь-яку відповідь, яка не повертає те саме значення. Якщо значення статичне, передбачуване, необов’язкове або не прив’язане до сесії користувача, атакуючий може завершити власний OAuth-потік, перехопити фінальний запит з `?code=` (без його відправлення), а пізніше примусити браузер жертви відтворити цей запит, внаслідок чого акаунт жертви прив’яжеться до профілю атакуючого в identity provider.

Шаблон повторного відтворення завжди однаковий:

1. Атакуючий аутентифікується в IdP зі своїм акаунтом і перехоплює останнє перенаправлення, що містить `code` (і будь-який `state`).
2. Він скидає цей запит, зберігає URL і пізніше зловживає будь-яким CSRF-примітивом (link, iframe, auto-submitting form), щоб змусити браузер жертви його завантажити.
3. Якщо клієнт не перевіряє `state`, додаток приймає результат авторизації атакуючого і залогінює атакуючого в акаунт жертви в додатку.

Практичний чекліст для обробки `state` під час тестування:

- **Missing `state` entirely** – якщо параметр ніколи не з'являється, увесь процес логіну вразливий до CSRF.
- **`state` not required** – видаліть його з початкового запиту; якщо IdP все ще видає коди, які клієнт приймає, захист є опційним.
- **Returned `state` not validated** – підміняйте значення в відповіді (Burp, MITM proxy). Прийняття невідповідних значень означає, що збережений токен ніколи не порівнюється.
- **Predictable or purely data-driven `state`** – багато додатків кладуть redirect paths або JSON-блоби в `state` без додавання випадковості, дозволяючи атакуючим вгадувати валідні значення і відтворювати потоки. Завжди додавайте сильну ентропію перед кодуванням даних (prepend/append).
- **`state` fixation** – якщо додаток дозволяє користувачам задавати значення `state` (наприклад, через сконструйовані authorization URLs) і повторно використовує його протягом потоку, атакуючий може зафіксувати відоме значення і повторно використовувати його проти інших жертв.

PKCE може доповнювати `state` (особливо для public clients), прив’язуючи authorization code до code verifier, але web-клієнти все одно повинні відслідковувати `state`, щоб запобігти міжкористувацьким CSRF/прив’язці акаунтів.

### Перед захопленням облікового запису <a href="#ebe4" id="ebe4"></a>

1. **Без перевірки email при створенні акаунта**: Атакуючі можуть заздалегідь створити акаунт, використавши email жертви. Якщо згодом жертва використовує сторонній сервіс для входу, додаток може випадково прив’язати цей сторонній акаунт до заздалегідь створеного акаунта атакуючого, що призведе до несанкціонованого доступу.
2. **Використання слабкої верифікації email в OAuth**: Атакуючі можуть зловживати OAuth-сервісами, що не перевіряють email: зареєструвати акаунт і потім змінити email на email жертви. Цей метод аналогічно загрожує несанкціонованим доступом, як і перший сценарій, але через інший вектор атаки.

### Розкриття секретів <a href="#e177" id="e177"></a>

`client_id` навмисно публічний, але **`client_secret` ніколи не повинен бути відновлюваним кінцевими користувачами**. Деплойменти Authorization Code, які вбудовують секрет у **mobile APKs, desktop clients, або single-page apps**, фактично віддають ці облікові дані будь-кому, хто може завантажити пакет. Завжди перевіряйте public clients шляхом:

- Розпаковки APK/IPA, інсталятора для desktop або Electron app і grep-ування на `client_secret`, Base64-блоки, що декодуються в JSON, або жорстко закодовані OAuth endpoints.
- Перегляду бандлених конфігураційних файлів (plist, JSON, XML) або декомпільованих рядків на предмет клієнтських облікових даних.

Як тільки атакуючий витягує секрет, йому достатньо вкрасти будь-який authorization `code` жертви (через слабкий `redirect_uri`, логи тощо), щоб незалежно звернутися до `/token` і згенерувати access/refresh tokens без залучення легітимного додатку. Вважайте public/native clients **нездатними тримати секрети** — вони повинні покладатися на PKCE (RFC 7636), щоб підтвердити володіння per-instance code verifier замість статичного секрету. Під час тестування підтвердіть, чи PKCE є обов’язковим і чи бекенд дійсно відхиляє token exchanges, які опускають або `client_secret` **або** валідний `code_verifier`.

### Client Secret Bruteforce

You can try to **bruteforce the `client_secret`** of a service provider with the identity provider in order to be try to steal accounts.\
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Once the client has the **code and state**, if it's **reflected inside the Referer header** when he browses to a different page, then it's vulnerable.

### Access Token Stored in Browser History

Основна гарантія Authorization Code grant полягає в тому, що **access tokens ніколи не потрапляють у браузер власника ресурсу**. Коли реалізації leak tokens на боці клієнта, будь-яка дрібна помилка (XSS, Referer leak, proxy logging) миттєво призводить до компрометації облікового запису. Завжди перевіряйте:

- **Tokens in URLs** – if `access_token` appears in the query/fragment, it lands in browser history, server logs, analytics, and Referer headers sent to third parties.
- **Tokens transiting untrusted middleboxes** – returning tokens over HTTP or through debugging/corporate proxies lets network observers capture them directly.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, or serialized JSON blobs expose tokens to every script on the origin (including XSS payloads or malicious extensions).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` retain tokens long after logout on shared devices and are script-accessible.

Будь-яке з цих виявлень зазвичай піднімає інакше «низькі» баги (наприклад CSP bypass або DOM XSS) до повного API takeover, тому що атакуючий може просто прочитати і відтворити the leaked bearer token.

### Everlasting Authorization Code

Authorization codes must be **short-lived, single-use, and replay-aware**. Під час оцінки flow захопіть `code` і:

- **Test the lifetime** – RFC 6749 recommends minutes, not hours. Try redeeming the code after 5–10 minutes; if it still works, the exposure window for any leaked code is excessive.
- **Test sequential reuse** – send the same `code` twice. If the second request yields another token, attackers can clone sessions indefinitely.
- **Test concurrent redemption/race conditions** – fire two token requests in parallel (Burp intruder, turbo intruder). Weak issuers sometimes grant both.
- **Observe replay handling** – a reuse attempt should not only fail but also revoke any tokens already minted from that code. Otherwise, a detected replay leaves the attacker’s first token active.

Combining a replay-friendly code with any `redirect_uri` or logging bug allows persistent account access even after the victim completes the legitimate login.

### Authorization/Refresh Token not bound to client

If you can get the **authorization code and use it with a different client then you can takeover other accounts**.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) you can see that the **token** that **AWS Cognito** gives back to the user might have **enough permissions to overwrite the user data**. Therefore, if you can **change the user email for a different user email**, you might be able to **take over** others accounts.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
For more detailed info about how to abuse AWS Cognito check [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abusing other Apps tokens <a href="#bda5" id="bda5"></a>

As [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth flows that expect to receive the **token** (and not a code) could be vulnerable if they not check that the token belongs to the app.

This is because an **attacker** could create an **application supporting OAuth and login with Facebook** (for example) in his own application. Then, once a victim logins with Facebook in the **attackers application**, the attacker could get the **OAuth token of the user given to his application, and use it to login in the victim OAuth application using the victims user token**.

> [!CAUTION]
> Therefore, if the attacker manages to get the user access his own OAuth application, he will be able to take over the victims account in applications that are expecting a token and aren't checking if the token was granted to their app ID.

### Two links & cookie <a href="#bda5" id="bda5"></a>

According to [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), it was possible to make a victim open a page with a **returnUrl** pointing to the attackers host. This info would be **stored in a cookie (RU)** and in a **later step** the **prompt** will **ask** the **user** if he wants to give access to that attackers host.

To bypass this prompt, it was possible to open a tab to initiate the **Oauth flow** that would set this RU cookie using the **returnUrl**, close the tab before the prompt is shown, and open a new tab without that value. Then, the **prompt won't inform about the attackers host**, but the cookie would be set to it, so the **token will be sent to the attackers host** in the redirection.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

As explained in [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), some OAuth implementations allows to indicate the **`prompt`** GET parameter as None (**`&prompt=none`**) to **prevent users being asked to confirm** the given access in a prompt in the web if they are already logged in the platform.

### response_mode

As [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), it might be possible to indicate the parameter **`response_mode`** to indicate where do you want the code to be provided in the final URL:

- `response_mode=query` -> The code is provided inside a GET parameter: `?code=2397rf3gu93f`
- `response_mode=fragment` -> The code is provided inside the URL fragment parameter `#code=2397rf3gu93f`
- `response_mode=form_post` -> The code is provided inside a POST form with an input called `code` and the value
- `response_mode=web_message` -> The code is send in a post message: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth consent/login dialogs are ideal clickjacking targets: if they can be framed, an attacker can overlay custom graphics, hide the real buttons, and trick users into approving dangerous scopes or linking accounts. Build PoCs that:

1. Load the IdP authorization URL inside an `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Use absolute positioning/opacity tricks to align fake buttons with the hidden **Allow**/**Approve** controls.
3. Optionally pre-fill parameters (scopes, redirect URI) so the stolen approval immediately benefits the attacker.

During testing verify that IdP pages emit either `X-Frame-Options: DENY/SAMEORIGIN` or a restrictive `Content-Security-Policy: frame-ancestors 'none'`. If neither is present, demonstrate the risk with tooling like [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) and record how easily a victim authorizes the attacker’s app. For additional payload ideas see [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

According to [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), this is an OAuth flow that allows to login in OAuth via **username** and **password**. If during this simple flow a **token** with access to all the actions the user can perform is returned then it's possible to bypass 2FA using that token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

This [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) comments how it was possible to abuse an **open redirect** to the value from the **referrer** to abuse OAuth to ATO. The attack was:

1. Victim access the attackers web page
2. The victim opens the malicious link and an opener starts the Google OAuth flow with `response_type=id_token,code&prompt=none` as additional parameters using as **referrer the attackers website**.
3. In the opener, after the provider authorizes the victim, it sends them back to the value of the `redirect_uri` parameter (victim web) with 30X code which still keeps the attackers website in the referer.
4. The victim **website trigger the open redirect based on the referrer** redirecting the victim user to the attackers website, as the **`respose_type`** was **`id_token,code`**, the code will be sent back to the attacker in the **fragment** of the URL allowing him to tacke over the account of the user via Google in the victims site.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

Dynamic Client Registration in OAuth serves as a less obvious but critical vector for security vulnerabilities, specifically for **Server-Side Request Forgery (SSRF)** attacks. This endpoint allows OAuth servers to receive details about client applications, including sensitive URLs that could be exploited.

**Key Points:**

- **Dynamic Client Registration** is often mapped to `/register` and accepts details like `client_name`, `client_secret`, `redirect_uris`, and URLs for logos or JSON Web Key Sets (JWKs) via POST requests.
- This feature adheres to specifications laid out in **RFC7591** and **OpenID Connect Registration 1.0**, which include parameters potentially vulnerable to SSRF.
- The registration process can inadvertently expose servers to SSRF in several ways:
- **`logo_uri`**: A URL for the client application's logo that might be fetched by the server, triggering SSRF or leading to XSS if the URL is mishandled.
- **`jwks_uri`**: A URL to the client's JWK document, which if maliciously crafted, can cause the server to make outbound requests to an attacker-controlled server.
- **`sector_identifier_uri`**: References a JSON array of `redirect_uris`, which the server might fetch, creating an SSRF opportunity.
- **`request_uris`**: Lists allowed request URIs for the client, which can be exploited if the server fetches these URIs at the start of the authorization process.

**Exploitation Strategy:**

- SSRF can be triggered by registering a new client with malicious URLs in parameters like `logo_uri`, `jwks_uri`, or `sector_identifier_uri`.
- While direct exploitation via `request_uris` may be mitigated by whitelist controls, supplying a pre-registered, attacker-controlled `request_uri` can facilitate SSRF during the authorization phase.

## OAuth providers Race Conditions

If the platform you are testing is an OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

In OAuth, the sub field uniquely identifies a user, but its format varies by Authorization Server. To standardize user identification, some clients use emails or user handles. However, this is risky because:

- Some Authorization Servers do not ensure that these properties (like email) remain immutable.
- In certain implementations—such as **"Login with Microsoft"**—the client relies on the email field, which is **user-controlled by the user in Entra ID** and not verified.
- An attacker can exploit this by creating their own Azure AD organization (e.g., doyensectestorg) and using it to perform a Microsoft login.
- Even though the Object ID (stored in sub) is immutable and secure, the reliance on a mutable email field can enable an account takeover (for example, hijacking an account like victim@gmail.com).

## Client Confusion Attack

In a **Client Confusion Attack**, an application using the OAuth Implicit Flow fails to verify that the final access token is specifically generated for its own Client ID. An attacker sets up a public website that uses Google’s OAuth Implicit Flow, tricking thousands of users into logging in and thereby harvesting access tokens intended for the attacker’s site. If these users also have accounts on another vulnerable website that does not validate the token's Client ID, the attacker can reuse the harvested tokens to impersonate the victims and take over their accounts.

## Scope Upgrade Attack

The **Authorization Code Grant** type involves secure server-to-server communication for transmitting user data. However, if the **Authorization Server** implicitly trusts a scope parameter in the Access Token Request (a parameter not defined in the RFC), a malicious application could upgrade the privileges of an authorization code by requesting a higher scope. After the **Access Token** is generated, the **Resource Server** must verify it: for JWT tokens, this involves checking the JWT signature and extracting data such as client_id and scope, while for random string tokens, the server must query the Authorization Server to retrieve the token’s details.

## Redirect Scheme Hijacking

In mobile OAuth implementations, apps use **custom URI schemes** to receive redirects with Authorization Codes. However, because multiple apps can register the same scheme on a device, the assumption that only the legitimate client controls the redirect URI is violated. On Android, for instance, an Intent URI like `com.example.app://` oauth is caught based on the scheme and optional filters defined in an app’s intent-filter. Since Android’s intent resolution can be broad—especially if only the scheme is specified—an attacker can register a malicious app with a carefully crafted intent filter to hijack the authorization code. This can **enable an account takeover** either through user interaction (when multiple apps are eligible to handle the intent) or via bypass techniques that exploit overly specific filters, as detailed by Ostorlab's assessment flowchart.



## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)

{{#include ../banners/hacktricks-training.md}}
