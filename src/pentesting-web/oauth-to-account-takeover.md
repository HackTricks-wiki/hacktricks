# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Maelezo ya Msingi <a href="#d4a8" id="d4a8"></a>

OAuth ina matoleo mbalimbali, na maarifa ya msingi yanapatikana kwenye [OAuth 2.0 documentation](https://oauth.net/2/). Huu mjadala unazingatia hasa [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), ukitoa mfumo wa **idhinishaji unaowezesha programu kupata au kufanya vitendo kwenye akaunti ya mtumiaji katika programu nyingine** (seva ya idhini).

Fikiria tovuti ya kubahatisha _**https://example.com**_, iliyoundwa kwa ajili ya **kuonyesha machapisho yako yote ya mitandao ya kijamii**, ikiwa ni pamoja na yale ya kibinafsi. Ili kufanikisha hili, OAuth 2.0 inatumiwa. _https://example.com_ itakuomba idhini yako ya **kupata machapisho yako ya mitandao ya kijamii**. Matokeo yake, skrini ya ruhusa itaonekana kwenye _https://socialmedia.com_, ikielezea **idhini zinazotakiwa na msanidi anayefanya ombi**. Baada ya wewe kutoa idhini, _https://example.com_ inapata uwezo wa **kupata machapisho yako kwa niaba yako**.

Ni muhimu kuelewa vipengele vifuatavyo ndani ya mfumo wa OAuth 2.0:

- **resource owner**: Wewe, kama **mtumiaji/entiti**, unaidhinisha ufikiaji kwa rasilimali yako, kama machapisho ya akaunti yako ya mitandao ya kijamii.
- **resource server**: Seva inayosimamia maombi yaliyothibitishwa baada ya programu kupata `access token` kwa niaba ya `resource owner`, mfano, **https://socialmedia.com**.
- **client application**: Programu inayotafuta idhini kutoka kwa `resource owner`, kama **https://example.com**.
- **authorization server**: Seva inayotoa `access token` kwa `client application` baada ya mafanikio ya uthibitisho wa `resource owner` na kupata idhini, mfano, **https://socialmedia.com**.
- **client_id**: Kitambulisho cha umma, cha kipekee kwa programu.
- **client_secret:** Kitufe cha siri, kinachojulikana tu kwa programu na seva ya idhini, kinachotumika kutengeneza `access_tokens`.
- **response_type**: Thamani inayoonyesha aina ya token inayohitajika, kama `code`.
- **scope**: Kiwango cha ufikiaji ambacho `client application` inachoomba kutoka kwa `resource owner`.
- **redirect_uri**: URL ambayo mtumiaji anarudishwa baada ya idhini. Hii kawaida lazima iwe sawa na URL ya redirect iliyosajiliwa mapema.
- **state**: Kigezo cha kuhifadhi data wakati mtumiaji anarudishwa kwenda na kurudi kutoka kwa seva ya idhini. Uwe wa kipekee ni muhimu kama mekanismi ya ulinzi dhidi ya CSRF.
- **grant_type**: Kigezo kinachoonyesha aina ya grant na aina ya token itakayorejeshwa.
- **code**: Msimbo wa idhini kutoka kwa `authorization server`, unaotumika pamoja na `client_id` na `client_secret` na `client application` kupata `access_token`.
- **access_token**: Token ambayo `client application` hutumia kwa maombi ya API kwa niaba ya `resource owner`.
- **refresh_token**: Inaiwezesha programu kupata `access_token` mpya bila kuuliza mtumiaji tena.

### Mtiririko

Mtiririko halisi wa OAuth unaendelea kama ifuatavyo:

1. Unaenda kwenye [https://example.com](https://example.com) na kubonyeza kitufe “Unganisha na Mitandao ya Kijamii”.
2. Tovuti basi itatuma ombi kwa [https://socialmedia.com](https://socialmedia.com) ikikuomba idhini yako ili kuruhusu programu ya https://example.com kupata machapisho yako. Ombi limeundwa kama ifuatavyo:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Kisha unaonyeshwa ukurasa wa idhini.
4. Baada ya idhini yako, Mitandao ya Kijamii inatuma jibu kwa `redirect_uri` pamoja na vigezo `code` na `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com inatumia `code` hii, pamoja na `client_id` na `client_secret` yake, kutuma ombi upande wa seva ili kupata `access_token` kwa niaba yako, ikiruhusu upatikanaji wa ruhusa uliyoruhusu:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Mwishowe, mchakato unafungwa huku https://example.com ikitumia `access_token` yako kufanya mwito wa API kwa Social Media ili kupata

## Udhaifu <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Kulingana na [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), authorization server lazima irudishe browser tu kwa **pre-registered, exact redirect URIs**. Udhaifu wowote hapa unampa mshambuliaji uwezo wa kumtuma mwathiriwa kupitia URL hatarishi ya authorization ili IdP itume `code` (na `state`) ya mwathiriwa moja kwa moja kwa endpoint ya mshambuliaji, ambaye kisha anaweza kuitumia kuredeem na kuvuna tokens.

Mtiririko wa kawaida wa shambulio:

1. Tengeneza `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` na uitume kwa mwathiriwa.
2. Mwathiriwa anathibitisha utambulisho na kuidhinisha scopes.
3. IdP inamrudisha kwa `attacker.tld/callback?code=<victim-code>&state=...` ambapo mshambuliaji anarekodi ombi na mara moja kubadilisha code.

Hitilafu za kawaida za validation za kuchunguza:

- **No validation** – url yoyote ya absolute inakubaliwa, ikisababisha wizi wa code mara moja.
- **Weak substring/regex checks on the host** – vuka kwa lookalikes kama `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, au `match.com@evil.com`.
- **IDN homograph mismatches** – validation inafanyika kwenye form ya punycode (`xn--`), lakini browser inarudisha kwa domain ya Unicode inayodhibitiwa na mshambuliaji.
- **Arbitrary paths on an allowed host** – kuonyesha `redirect_uri` kwa `/openredirect?next=https://attacker.tld` au endpoint yoyote ya XSS/user-content leaks the code kupitia chained redirects, Referer headers, au injected JavaScript.
- **Directory constraints without normalization** – pattern kama `/oauth/*` inaweza kupitishwa kwa `/oauth/../anything`.
- **Wildcard subdomains** – kukubali `*.example.com` kunamaanisha takeover yoyote (dangling DNS, S3 bucket, n.k.) mara moja huleta callback halali.
- **Non-HTTPS callbacks** – kuruhusu `http://` URIs kunawaongezea washambuliaji wa mtandao (Wi-Fi, corporate proxy) fursa ya kuchukua code wakati wa transit.

Pitia pia vigezo vingine vinavyofanya kazi kama redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, n.k.) na OpenID discovery document (`/.well-known/openid-configuration`) kwa endpoints za ziada ambazo zinaweza kurithi hitilafu zile zile za validation.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Kama ilivyoelezwa katika ripoti ya bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) inaweza kuwa inawezekana kwamba redirect **URL inatolewa tena katika response** ya server baada ya mtumiaji kuthibitishwa, ikionyesha kuwa **vulnerable to XSS**. Possible payload to test:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Kutokushughulikiwa vizuri kwa parameter ya state <a href="#bda5" id="bda5"></a>

Kigezo cha `state` ni Authorization Code flow CSRF token: client lazima itengeneze **thamani ya nasibu kwa njia ya cryptography kwa kila mfano wa kivinjari**, kiihifadhi mahali ambapo kivinjari hicho pekee kinaweza kusoma (cookie, local storage, n.k.), kuipeleka katika ombi la authorization, na kukataa majibu yoyote yasiyorudisha thamani ile ile. Wakati thamani ni static, inayoweza kutabiriwa, ya hiari, au isiyounganishwa na session ya mtumiaji, mshambuliaji anaweza kumaliza flow yake ya OAuth, kapte ombi la mwisho la `?code=` (bila kulitumia), kisha baadaye kulazimisha kivinjari cha mwathirika kurudia ombi hilo ili akaunti ya mwathirika iunganishwe na profile ya mshambuliaji kwenye IdP.

Mfumo wa replay ni mara zote ule ule:

1. Mshambuliaji anathibitishwa dhidi ya IdP na akaunti yao na anakata ombi la redirect la mwisho linalojumuisha `code` (na `state` yoyote).
2. Wanadharau ombi hilo, wanahifadhi URL, na baadaye wanatumia primitive yoyote ya CSRF (link, iframe, form inayojisubmit yenyewe) kulazimisha kivinjari cha mwathirika kukibeba.
3. Ikiwa client haitekelezi `state`, application inatumia matokeo ya authorization ya mshambuliaji na kumuingiza mshambuliaji ndani ya akaunti ya app ya mwathirika.

Orodha ya ukaguzi ya vitendo kwa utunzaji wa `state` wakati wa tests:

- **Missing `state` entirely** – ikiwa kigezo hakionekani kabisa, hela ya login inaweza kufanyiwa CSRF.
- **`state` not required** – tofautisha kutoka kwenye ombi la mwanzo; ikiwa IdP bado inatoa codes ambazo client inakubali, ulinzi ni opt-in.
- **Returned `state` not validated** – badilisha thamani kwenye jibu (Burp, MITM proxy). Kukubali thamani zisizolingana ina maana token iliyohifadhiwa haisakabiwi.
- **Predictable or purely data-driven `state`** – apps nyingi zinaingiza redirect paths au JSON blobs ndani ya `state` bila kuchanganya nasibu, na kuruhusu washambuliaji kujua thamani halali na kurudia flows. Daima tanga/ongeza entropy thabiti kabla ya kuencoding data.
- **`state` fixation** – ikiwa app inaruhusu watumiaji kusambaza thamani ya `state` (mfano, kupitia crafted authorization URLs) na kuitumia tena katika flow, mshambuliaji anaweza kuweka thamani inayojulikana na kuitumia kwa waathiri wawili au zaidi.

PKCE inaweza kuongezea `state` (hasa kwa public clients) kwa kuunganisha authorization code na code verifier, lakini web clients lazima bado zifuatilie `state` ili kuzuia CSRF/kuunganisha akaunti kwa watumiaji tofauti.

### Kabla ya Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Bila Uthibitisho wa Email wakati wa Kuunda Akaunti**: Washambuliaji wanaweza kuunda akaunti mapema wakitumia email ya mwathirika. Ikiwa mwathirika baadaye anatumia huduma ya upande wa tatu kuingia, application inaweza bila kukisia kuunganisha akaunti ya upande wa tatu na akaunti iliyotengenezwa kabla na mshambuliaji, na kusababisha ufikiaji usioidhinishwa.
2. **Kutumia Udhaifu wa Uthibitisho wa Email wa OAuth**: Washambuliaji wanaweza kutumia huduma za OAuth ambazo hazothibitishi emails kwa kujisajili kisha kubadilisha email ya akaunti kuwa ya mwathirika. Njia hii pia ina hatari ya ufikiaji usioidhinishwa wa akaunti, sawa na tukio la kwanza lakini kupitia njia tofauti ya shambulio.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

`client_id` ni ya umma kwa makusudi, lakini **`client_secret` must never be recoverable by end users**. Authorization Code deployments ambazo zinaweka secret ndani ya **mobile APKs, desktop clients, au single-page apps** kwa ufanisi zinampa msimbo huyo mtu yeyote anayesakinisha kifurushi. Daima angalia public clients kwa:

- Kufungua APK/IPA, desktop installer, au Electron app na kutafuta kwa grep `client_secret`, Base64 blobs zinazodecode kuwa JSON, au OAuth endpoints zilizowekwa kimsingi.
- Kurejea mafaili ya config yaliyobundled (plist, JSON, XML) au nystrings zilizodecompiled kwa credenciales za client.

Mara mshambuliaji atakapovextract secret wakahitaji tu kunyakua `code` ya authorization ya mwathirika (kupitia weak `redirect_uri`, logs, n.k.) ili kushambulia `/token` kwa kujitegemea na kutengeneza access/refresh tokens bila kushirikisha app halali. Tibu public/native clients kama **zisizoweza kushikilia secrets**—badala yake zinapaswa kutumia PKCE (RFC 7636) kuthibitisha umiliki wa code verifier kwa mfano badala ya secret static. Wakati wa testing, thibitisha kama PKCE ni lazima na kama backend kwa kweli inakataa token exchanges zinazokosa ama `client_secret` **au** valid `code_verifier`.

### Client Secret Bruteforce

Unaweza kujaribu kufanya **bruteforce ya client_secret** ya service provider kwa identity provider ili kujaribu kuiba akaunti.\
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Mara mteja anapokuwa na **code and state**, ikiwa inarudishwa ndani ya **Referer header** anapotembelea ukurasa mwingine, basi ni hatarishi.

### Access Token Iliyohifadhiwa katika Historia ya Kivinjari

Dhamana kuu ya Authorization Code grant ni kwamba **access tokens never reach the resource owner’s browser**. When implementations leak tokens client-side, any minor bug (XSS, Referer leak, proxy logging) becomes instant account compromise. Daima angalia:

- **Tokens in URLs** – if `access_token` appears in the query/fragment, it lands in browser history, server logs, analytics, and Referer headers sent to third parties.
- **Tokens transiting untrusted middleboxes** – returning tokens over HTTP or through debugging/corporate proxies lets network observers capture them directly.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, or serialized JSON blobs expose tokens to every script on the origin (including XSS payloads or malicious extensions).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` retain tokens long after logout on shared devices and are script-accessible.

Matokeo yoyote ya aina hizi mara nyingi hubadilisha mende ambazo zingekuwa “low” (kama CSP bypass au DOM XSS) kuwa takeover kamili ya API kwa sababu mshambuliaji anaweza kusoma na kuirudia tu bearer token iliyoleak.

### Everlasting Authorization Code

Authorization codes lazima ziwe **short-lived, single-use, and replay-aware**. Unapothamini flow, chukua `code` na:

- **Test the lifetime** – RFC 6749 recommends minutes, not hours. Jaribu ku-redeem `code` baada ya dakika 5–10; ikiwa bado inafanya kazi, dirisha la exposure kwa code yoyote iliyoleak ni kubwa.
- **Test sequential reuse** – tuma `code` ile ile mara mbili. Ikiwa ombi la pili linatoa token nyingine, washambuliaji wanaweza ku-clone sessions kwa muda usiotamwa.
- **Test concurrent redemption/race conditions** – tuma maombi mawili ya token kwa wakati mmoja (Burp intruder, turbo intruder). Watoaji dhaifu mara nyingine wanatoa zote mbili.
- **Observe replay handling** – jaribio la reuse halipaswi tu kushindwa bali pia linapaswa ku-revoke token zozote tayari zilizotolewa kutoka kwa code hiyo. Vinginevyo, replay iliyogunduliwa inawaacha mshambuliaji token yake ya kwanza ikifanya kazi.

Kuchanganya code inayoruhusu replay na `redirect_uri` yoyote au tatizo la logging kunaruhusu ufikiaji wa akaunti kwa muda hata baada ya mwathiriwa kumaliza login halali.

### Authorization/Refresh Token not bound to client

Ikiwa unaweza kupata **authorization code** na kuitumia na client tofauti basi unaweza takeover akaunti za wengine.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Angalia chapisho hili**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) unaweza kuona kwamba **token** ambayo **AWS Cognito** inarudisha kwa mtumiaji inaweza kuwa na **idhini za kutosha kuandika upya data za mtumiaji**. Kwa hiyo, ikiwa unaweza **kubadilisha user email kwa user email tofauti**, unaweza kuwa uwezo wa **take over** akaunti za wengine.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Kwa maelezo zaidi kuhusu jinsi ya kutumia vibaya AWS Cognito angalia [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abusing other Apps tokens <a href="#bda5" id="bda5"></a>

Kama ilivyotajwa katika [**this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth flows zinazotarajia kupokea **token** (na si code) zinaweza kuwa hatarini ikiwa hazikagua kwamba token inamilikiwa na app yao.

Hii ni kwa sababu **mshambuliaji** anaweza kuunda **application** inayounga mkono OAuth na kuruhusu login kwa Facebook (kwa mfano) katika application yake mwenyewe. Kisha, mara baada ya **mwanaathiriwa** kuingia na Facebook kwenye **application ya mshambuliaji**, mshambuliaji anaweza kupata **OAuth token ya mtumiaji iliyotolewa kwa application yake**, na kuitumia kuingia kwenye application ya OAuth ya mwanaathiriwa akitumia token ya mtumiaji wa mwanaathiriwa.

> [!CAUTION]
> Kwa hivyo, kama mshambuliaji anafanikiwa kumfanya mtumiaji akipitie kwenye OAuth application yake mwenyewe, ataweza kuchukua udhibiti wa akaunti ya mwanaathiriwa katika applications zinazotarajia token na zisizokagua kama token ilitolewa kwa app ID yao.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Kulingana na [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), kulikuwa inawezekana kumfanya mwanaathiriwa afungue ukurasa uliokuwa na **returnUrl** unaorejelea mwenyeji wa mshambuliaji. Taarifa hii ilihifadhiwa kwenye cookie (RU) na katika hatua ya baadaye **prompt** itauliza **mtumiaji** kama anataka kumpa ufikiaji mwenyeji huyo wa mshambuliaji.

Ili kuepuka prompt hii, ilikuwa inawezekana kufungua tab ili kuanzisha **Oauth flow** ambayo itapanga cookie ya RU kwa kutumia **returnUrl**, kufunga tab kabla ya prompt kuonyeshwa, na kufungua tab mpya bila thamani hiyo. Kisha, **prompt haitataja mwenyeji wa mshambuliaji**, lakini cookie itakuwa imesetwa kwa mwenyeji huyo, hivyo **token itatumwa kwa mwenyeji wa mshambuliaji** kupitia redirect.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Kama ilivyoelezwa katika [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), utekelezaji zingine za OAuth huruhusu kuashiria parameter ya GET **`prompt`** kama None (**`&prompt=none`**) ili **kuzuia watumiaji kuulizwa kuthibitisha** ufikiaji uliotolewa kwenye prompt katika wavuti ikiwa tayari wameingia kwenye jukwaa.

### response_mode

Kama ilivyoelezwa katika [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), inaweza kuwa inawezekana kuainisha parameter **`response_mode`** kuonyesha wapi ungependa code itolewe kwenye URL ya mwisho:

- `response_mode=query` -> The `code` is provided inside a GET parameter: `?code=2397rf3gu93f`
- `response_mode=fragment` -> The `code` is provided inside the URL fragment parameter `#code=2397rf3gu93f`
- `response_mode=form_post` -> The `code` is provided inside a POST form with an input called `code` and the value
- `response_mode=web_message` -> The `code` is send in a post message: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth consent/login dialogs ni malengo mazuri ya clickjacking: ikiwa yanaweza kuingizwa ndani ya frame, mshambuliaji anaweza kuweka grafiki za uongo juu, kuficha vitufe halisi, na kudanganya watumiaji kuidhinisha scopes hatari au kuunganisha akaunti. Tengeneza PoCs zinazofanya:

1. Load the IdP authorization URL inside an `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Use absolute positioning/opacity tricks to align fake buttons with the hidden **Allow**/**Approve** controls.
3. Optionally pre-fill parameters (scopes, redirect URI) so the stolen approval immediately benefits the attacker.

Wakati wa upimaji hakikisha kurasa za IdP zitatoa ama `X-Frame-Options: DENY/SAMEORIGIN` au restrictive `Content-Security-Policy: frame-ancestors 'none'`. Ikiwa hakuna, onyesha hatari kwa kutumia zana kama [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) na rekodi jinsi mwanaathiriwa anavyoweza kumtengoza kuidhinisha app ya mshambuliaji kwa urahisi. Kwa mawazo ya payload ya ziada angalia [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

Kulingana na [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), hii ni OAuth flow inayoruhusu kuingia kwenye OAuth kwa kutumia **username** na **password**. Ikiwa katika flow hii rahisi token yenye ufikiaji wa vitendo vyote mtumiaji anaweza kufanya inarudishwa, basi inawezekana kuzunguka 2FA kwa kutumia token hiyo.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Makala hii [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) inaelezea jinsi ilivyowezekana kutumia **open redirect** kwa thamani ya **referrer** kuudhi OAuth hadi ATO. Shambulio lilikuwa:

1. Mwanaathiriwa anafikia ukurasa wa wavuti wa mshambuliaji
2. Mwanaathiriwa afungua linku hatarishi na opener inaanzisha Google OAuth flow na `response_type=id_token,code&prompt=none` kama parameters za ziada kwa kutumia kama **referrer tovuti ya mshambuliaji**.
3. Katika opener, baada ya provider kumtumia mwanaathiriwa ruhusa, inawarejesha kwa thamani ya `redirect_uri` (wavuti ya mwanaathiriwa) kwa 30X code ambayo bado inahifadhi tovuti ya mshambuliaji kwenye referer.
4. Tovuti ya mwanaathiriwa **inandesha open redirect kulingana na referrer** ikirejesha mtumiaji kwa tovuti ya mshambuliaji, na kwa kuwa **`response_type`** ilikuwa **`id_token,code`**, code itatumwa kwa mshambuliaji kwenye **fragment** ya URL kumruhusu kuchukua akaunti ya mtumiaji kupitia Google kwenye tovuti ya mwanaathiriwa.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Kwa maelezo zaidi ya mbinu hii.**

Dynamic Client Registration katika OAuth inatumikia kama vector isiyoonekana lakini muhimu kwa udhaifu wa usalama, hasa kwa mashambulizi ya **Server-Side Request Forgery (SSRF)**. Endpoint hii inaruhusu servers za OAuth kupokea maelezo kuhusu client applications, ikiwa ni pamoja na URLs nyeti ambazo zinaweza kutumika vibaya.

Mambo Muhimu:

- **Dynamic Client Registration** mara nyingi imewekwa kwenye `/register` na inakubali maelezo kama `client_name`, `client_secret`, `redirect_uris`, na URLs za logos au JSON Web Key Sets (JWKs) kupitia POST requests.
- Kipengele hiki kinafuata specs za **RFC7591** na **OpenID Connect Registration 1.0**, ambazo zinajumuisha parameter ambazo zinaweza kuwa hatarini kwa SSRF.
- Mchakato wa usajili unaweza kumuweka server hatarini kwa SSRF kwa njia kadhaa:
  - **`logo_uri`**: URL ya logo ya client application ambayo server inaweza kuichukua, ikasababisha SSRF au XSS ikiwa URL inashughulikiwa vibaya.
  - **`jwks_uri`**: URL ya nyaraka ya JWK ya client, ambayo ikiwa imeundwa vibaya inaweza kusababisha server kufanya requests kwenda kwa server inayoendeshwa na mshambuliaji.
  - **`sector_identifier_uri`**: Inarejelea array ya JSON ya `redirect_uris`, ambayo server inaweza kuichukua, kuunda fursa ya SSRF.
  - **`request_uris`**: Inaorodhesha request URIs zilizoruhusiwa kwa client, ambazo zinaweza kutumiwa ikiwa server inazichukua wakati wa mwanzo wa mchakato wa authorization.

Mikakati ya Utekelezaji:

- SSRF inaweza kuchochewa kwa kusajili client mpya na URLs hatarishi katika parameter kama `logo_uri`, `jwks_uri`, au `sector_identifier_uri`.
- Ingawa utekaji wa moja kwa moja kupitia `request_uris` unaweza kuzuiawa kwa udhibiti wa whitelist, kusambaza `request_uri` iliyosajiliwa kabla na kudhibitiwa na mshambuliaji kunaweza kuwezesha SSRF wakati wa hatua ya authorization.

## OAuth providers Race Conditions

Ikiwa jukwaa unalolitathmini ndilo OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

Katika OAuth, field ya sub inatambua mtumiaji kwa kipekee, lakini muundo wake hutofautiana kwa kila Authorization Server. Ili kuweka utambulisho wa mtumiaji kuwa thabiti, baadhi ya clients hutumia barua pepe au user handles. Hata hivyo, hii ni hatari kwa sababu:

- Baadhi ya Authorization Servers hawahakiki kwamba mali hizi (kama email) hazibadiliki.
- Katika utekelezaji fulani—kama **"Login with Microsoft"**—client inategemea field ya email, ambayo ni **inayodhibitiwa na mtumiaji katika Entra ID** na haijathibitishwa.
- Mshambuliaji anaweza kutumia hili kwa kuunda shirika lake la Azure AD (mfano, doyensectestorg) na kulitumia kufanya login ya Microsoft.
- Ingawa Object ID (iliyohifadhiwa katika sub) ni isiyobadilika na salama, kutegemea field ya email inayoweza kubadilika kunaweza kuruhusu account takeover (kwa mfano, kunyongwa akaunti kama victim@gmail.com).

## Client Confusion Attack

Katika **Client Confusion Attack**, application inayotumia OAuth Implicit Flow inashindwa kuthibitisha kwamba access token ya mwisho imetengenezwa mahsusi kwa Client ID yake mwenyewe. Mshambuliaji anaweka tovuti ya umma inayotumia Google’s OAuth Implicit Flow, akidanganya mamia ya watumiaji kuingia na hivyo kuvuna access tokens zilizokusudiwa kwa tovuti ya mshambuliaji. Ikiwa watumiaji hao pia wana akaunti kwenye tovuti nyingine iliyo hatarini ambayo haisahihishi Client ID ya token, mshambuliaji anaweza kutumia tena tokens zilizokusanywa kuigiza watumiaji na kuchukua udhibiti wa akaunti zao.

## Scope Upgrade Attack

Aina ya **Authorization Code Grant** inahusisha mawasiliano salama server-to-server kwa ajili ya kusafirisha data za mtumiaji. Hata hivyo, ikiwa **Authorization Server** inaamini kwa ukimya parameter ya scope katika Access Token Request (parameter ambayo haijazuiwa na RFC), application yenye nia mbaya inaweza kuongeza wazee wa code kwa kuomba scope kubwa zaidi. Baada ya **Access Token** kutengenezwa, **Resource Server** lazima iithibitishe: kwa JWT tokens, hii inahusisha kuchunguza signature ya JWT na kutoa data kama client_id na scope, wakati kwa tokens za random string, server lazima iulize Authorization Server kupata maelezo ya token.

## Redirect Scheme Hijacking

Katika utekelezaji wa mobile OAuth, apps hutumia **custom URI schemes** kupokea redirects zenye Authorization Codes. Hata hivyo, kwa sababu apps nyingi zinaweza kusajili scheme ileile kwenye kifaa, dhana kwamba mteja halali tu ndiye anayeudhibiti redirect URI inavunjika. Kwa mfano kwenye Android, Intent URI kama `com.example.app://` oauth inachukuliwa kwa msingi wa scheme na filters za ziada zilizoainishwa katika intent-filter ya app. Kwa kuwa Android intent resolution inaweza kuwa pana—hasa kama hanya imeainishwa tu kwa scheme—mshambuliaji anaweza kusajili app ya kibaya yenye intent filter iliyoundwa kwa ustadi ili kuiba authorization code. Hii inaweza **kuwezesha account takeover** kwa njia ya mwingiliano wa mtumiaji (wakati apps nyingi zinastahili kushughulikia intent) au kupitia mbinu za kuepuka ambazo zinatumia filters zilizobuniwa kupita kiasi, kama ilivyoelezwa na mtiririko wa tathmini wa Ostorlab.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)

{{#include ../banners/hacktricks-training.md}}
