# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Podstawowe informacje <a href="#d4a8" id="d4a8"></a>

OAuth oferuje różne wersje, z podstawowymi informacjami dostępnymi na [OAuth 2.0 documentation](https://oauth.net/2/). Niniejsza dyskusja skupia się głównie na powszechnie stosowanym [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), dostarczając **framework autoryzacji, który umożliwia aplikacji dostęp do konta użytkownika lub wykonywanie akcji w imieniu tego konta w innej aplikacji** (serwer autoryzacji).

Rozważmy hipotetyczną stronę _**https://example.com**_, zaprojektowaną tak, by **wyświetlać wszystkie Twoje posty w social media**, włączając posty prywatne. Do tego celu używany jest OAuth 2.0. _https://example.com_ poprosi o Twoją zgodę na **dostęp do Twoich postów w social media**. W rezultacie na _https://socialmedia.com_ pojawi się ekran zgody, przedstawiający **żądane uprawnienia oraz dewelopera dokonującego żądania**. Po udzieleniu zgody _https://example.com_ uzyskuje możliwość **dostępu do Twoich postów w Twoim imieniu**.

Warto zrozumieć następujące komponenty w ramach OAuth 2.0:

- **resource owner**: Ty, jako **użytkownik/jednostka**, udzielasz dostępu do swojego zasobu, takiego jak posty na koncie w social media.
- **resource server**: **serwer obsługujący uwierzytelnione żądania** po tym, jak aplikacja uzyska `access token` w imieniu `resource owner`, np. **https://socialmedia.com**.
- **client application**: **aplikacja, która ubiega się o autoryzację** od `resource owner`, taka jak **https://example.com**.
- **authorization server**: **serwer wydający `access tokens`** aplikacji klienckiej po pomyślnym uwierzytelnieniu `resource owner` i uzyskaniu autoryzacji, np. **https://socialmedia.com**.
- **client_id**: Publiczny, unikalny identyfikator aplikacji.
- **client_secret:** Poufny klucz, znany wyłącznie aplikacji i serwerowi autoryzacji, wykorzystywany do generowania `access_tokens`.
- **response_type**: Wartość określająca **typ żądanego tokena**, np. `code`.
- **scope**: **Poziom dostępu**, o który `client application` prosi `resource owner`.
- **redirect_uri**: **URL, na który użytkownik zostaje przekierowany po autoryzacji**. Zazwyczaj musi być zgodny z wcześniej zarejestrowanym adresem przekierowania.
- **state**: Parametr służący do **utrzymania danych podczas przekierowania użytkownika do i z serwera autoryzacji**. Jego unikalność jest krytyczna, ponieważ pełni rolę **mechanizmu ochrony przed CSRF**.
- **grant_type**: Parametr wskazujący **typ grantu i typ zwracanego tokena**.
- **code**: Kod autoryzacyjny od `authorization server`, wykorzystywany wraz z `client_id` i `client_secret` przez aplikację klienta do pozyskania `access_token`.
- **access_token**: **token, którego aplikacja klienta używa do żądań API** w imieniu `resource owner`.
- **refresh_token**: Umożliwia aplikacji **uzyskanie nowego `access_token` bez ponownego pytania użytkownika o zgodę**.

### Przebieg

Rzeczywisty przepływ OAuth przebiega następująco:

1. Wchodzisz na [https://example.com](https://example.com) i klikasz przycisk „Integrate with Social Media”.
2. Strona wysyła żądanie do [https://socialmedia.com](https://socialmedia.com), prosząc o Twoją autoryzację, aby aplikacja https://example.com miała dostęp do Twoich postów. Żądanie ma strukturę:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Następnie wyświetlana jest strona zgody.
4. Po Twojej akceptacji serwis społecznościowy wysyła odpowiedź na `redirect_uri` z parametrami `code` i `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com wykorzystuje ten `code`, wraz ze swoim `client_id` i `client_secret`, aby wykonać żądanie po stronie serwera w celu uzyskania `access_token` w Twoim imieniu, umożliwiając dostęp do uprawnień, na które wyraziłeś zgodę:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Na koniec proces kończy się, gdy https://example.com używa twojego `access_token`, aby wykonać wywołanie API do serwisu społecznościowego w celu uzyskania dostępu

## Vulnerabilities <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), serwer autoryzacji musi przekierowywać przeglądarkę tylko do **wcześniej zarejestrowanych, dokładnych redirect URI**. Każda słabość tutaj pozwala atakującemu wysłać ofiarę przez złośliwy authorization URL tak, że IdP dostarczy ofiary `code` (i `state`) bezpośrednio na endpoint atakującego, który może go zrealizować i zebrać tokeny.

Typowy przebieg ataku:

1. Skomponuj `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` i wyślij go do ofiary.
2. Ofiara się uwierzytelnia i zatwierdza scopes.
3. IdP przekierowuje na `attacker.tld/callback?code=<victim-code>&state=...`, gdzie atakujący loguje żądanie i natychmiast wymienia code.

Typowe błędy walidacji do sprawdzenia:

- **No validation** – dowolny absolutny URL jest akceptowany, co skutkuje natychmiastową kradzieżą code.
- **Weak substring/regex checks on the host** – obejście za pomocą lookalike’ów takich jak `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, lub `match.com@evil.com`.
- **IDN homograph mismatches** – walidacja odbywa się na formie punycode (`xn--`), ale przeglądarka przekierowuje na domenę Unicode kontrolowaną przez atakującego.
- **Arbitrary paths on an allowed host** – skierowanie `redirect_uri` na `/openredirect?next=https://attacker.tld` lub dowolny endpoint XSS/wyświetlający treści użytkownika powoduje wyciek code przez łańcuch przekierowań, nagłówki Referer lub wstrzyknięty JavaScript.
- **Directory constraints without normalization** – wzorce takie jak `/oauth/*` można obejść poprzez `/oauth/../anything`.
- **Wildcard subdomains** – akceptowanie `*.example.com` oznacza, że każde przejęcie (dangling DNS, S3 bucket, itd.) natychmiast daje prawidłowy callback.
- **Non-HTTPS callbacks** – przepuszczenie URI `http://` daje sieciowym atakującym (Wi‑Fi, corporate proxy) możliwość przechwycenia code w tranzycie.

Przejrzyj także pomocnicze parametry w stylu redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, itd.) oraz OpenID discovery document (`/.well-known/openid-configuration`) pod kątem dodatkowych endpointów, które mogą dziedziczyć te same błędy walidacji.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Jak wspomniano w tym raporcie bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), możliwe, że redirect **URL jest odzwierciedlany w odpowiedzi** serwera po uwierzytelnieniu użytkownika, będąc **podatnym na XSS**. Możliwy payload do przetestowania:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Nieprawidłowe obsługiwanie parametru `state` <a href="#bda5" id="bda5"></a>

Parametr `state` jest tokenem CSRF w Authorization Code flow: klient musi wygenerować **kryptograficznie losową wartość dla każdej instancji przeglądarki**, zapisać ją w miejscu czytelnym tylko tej przeglądarce (cookie, local storage itp.), wysłać ją w żądaniu autoryzacyjnym i odrzucić każdą odpowiedź, która nie zwróci tej samej wartości. Jeśli wartość jest statyczna, przewidywalna, opcjonalna lub niezwiązana z sesją użytkownika, atakujący może dokończyć własny flow OAuth, przechwycić końcowe żądanie `?code=` (bez jego wysyłania) i później zmusić przeglądarkę ofiary do odtworzenia tego żądania, tak że konto ofiary zostanie powiązane z profilem atakującego w identity provider.

Schemat odtwarzania jest zawsze taki sam:

1. Atakujący uwierzytelnia się w IdP używając swojego konta i przechwytuje ostatnie przekierowanie zawierające `code` (i ewentualnie `state`).
2. Porzucają to żądanie, zachowują URL i później nadużywają dowolnego CSRF-owego prymitywu (link, iframe, formularz auto-submit), aby zmusić przeglądarkę ofiary do jego załadowania.
3. Jeśli klient nie wymusza walidacji `state`, aplikacja przyjmie wynik autoryzacji atakującego i zaloguje atakującego do konta aplikacji ofiary.

Praktyczna lista kontrolna dotycząca obsługi `state` podczas testów:

- **Brak `state` całkowicie** – jeśli parametr nigdy się nie pojawia, cały proces logowania jest podatny na CSRF.
- **`state` nieobowiązkowy** – usuń go z początkowego żądania; jeśli IdP nadal wydaje kody, które klient akceptuje, obrona jest opcjonalna.
- **Zwracany `state` niewalidowany** – modyfikuj wartość w odpowiedzi (Burp, MITM proxy). Akceptowanie niezgodnych wartości oznacza, że przechowywany token nigdy nie jest porównywany.
- **Przewidywalny lub czysto oparty na danych `state`** – wiele aplikacji umieszcza ścieżki redirect lub bloby JSON w `state` bez dodania losowości, co pozwala atakującym zgadnąć prawidłowe wartości i odtworzyć przepływy. Zawsze poprzedzaj/dodawaj silną entropię przed kodowaniem danych.
- **`state` fixation** – jeśli aplikacja pozwala użytkownikom podać wartość `state` (np. poprzez spreparowane authorization URLs) i ponownie jej używa w całym flow, atakujący może zablokować znaną wartość i wykorzystywać ją przeciwko ofiarom.

PKCE może uzupełniać `state` (szczególnie dla public clients) poprzez powiązanie authorization code z code_verifier, ale web clients wciąż muszą śledzić `state`, aby zapobiec cross-user CSRF / account-linking błędom.

### Przed przejęciem konta <a href="#ebe4" id="ebe4"></a>

1. **Brak weryfikacji e-mail przy tworzeniu konta**: Atakujący mogą uprzednio utworzyć konto używając e-maila ofiary. Jeśli ofiara później użyje zewnętrznej usługi do logowania, aplikacja może przypadkowo powiązać to konto z wcześniej utworzonym kontem atakującego, prowadząc do nieautoryzowanego dostępu.
2. **Wykorzystanie luźnej weryfikacji e-mail przez OAuth**: Atakujący mogą wykorzystać serwisy OAuth, które nie weryfikują e-maili, rejestrując się i potem zmieniając adres e-mail konta na e-mail ofiary. Ta metoda stwarza podobne ryzyko nieautoryzowanego dostępu jak pierwszy scenariusz, lecz poprzez inny wektor ataku.

### Ujawnienie sekretów <a href="#e177" id="e177"></a>

`client_id` jest celowo publiczny, ale **`client_secret` nigdy nie powinien być możliwy do odzyskania przez końcowych użytkowników**. Deploymenty Authorization Code, które osadzają sekret w **mobile APKs, desktop clients, or single-page apps** w praktyce oddają to poświadczenie każdemu, kto może pobrać paczkę. Zawsze sprawdzaj public clients poprzez:

- Rozpakowanie APK/IPA, instalatora desktopowego lub aplikacji Electron i przeszukanie (grep) w poszukiwaniu `client_secret`, Base64 blobów, które dekodują do JSON, lub zakodowanych na stałe endpointów OAuth.
- Przejrzenie dołączonych plików konfiguracyjnych (plist, JSON, XML) lub zdekompilowanych stringów pod kątem credentiali klienta.

Po wydobyciu sekretu atakujący musi tylko ukraść dowolny authorization `code` ofiary (przez słabe `redirect_uri`, logi itp.), aby samodzielnie wywołać `/token` i wygenerować access/refresh tokens bez udziału legitnej aplikacji. Traktuj public/native clients jako **niezdolne do przechowywania sekretów** — powinny zamiast tego polegać na PKCE (RFC 7636) do udowodnienia posiadania per-instance code_verifier zamiast statycznego sekretu. Podczas testów potwierdź, czy PKCE jest obowiązkowe i czy backend faktycznie odrzuca wymiany tokenów, które pomijają albo `client_secret` **albo** prawidłowy `code_verifier`.

### Client Secret Bruteforce

Możesz spróbować **bruteforce'ować `client_secret`** dostawcy tożsamości (identity provider), aby próbować przejąć konta.\
Żądanie do BF może wyglądać podobnie do:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Once the client has the **code and state**, if it's **reflected inside the Referer header** when he browses to a different page, then it's vulnerable.

### Access Token Stored in Browser History

The core guarantee of the Authorization Code grant is that **access tokens never reach the resource owner’s browser**. When implementations leak tokens client-side, any minor bug (XSS, Referer leak, proxy logging) becomes instant account compromise. Always check for:

- **Tokens in URLs** – if `access_token` appears in the query/fragment, it lands in browser history, server logs, analytics, and Referer headers sent to third parties.
- **Tokens transiting untrusted middleboxes** – returning tokens over HTTP or through debugging/corporate proxies lets network observers capture them directly.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, or serialized JSON blobs expose tokens to every script on the origin (including XSS payloads or malicious extensions).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` retain tokens long after logout on shared devices and are script-accessible.

Any of these findings usually upgrades otherwise “low” bugs (like a CSP bypass or DOM XSS) into full API takeover because the attacker can simply read and replay the leaked bearer token.

### Everlasting Authorization Code

Authorization codes must be **short-lived, single-use, and replay-aware**. When assessing a flow, capture a `code` and:

- **Test the lifetime** – RFC 6749 recommends minutes, not hours. Try redeeming the code after 5–10 minutes; if it still works, the exposure window for any leaked code is excessive.
- **Test sequential reuse** – send the same `code` twice. If the second request yields another token, attackers can clone sessions indefinitely.
- **Test concurrent redemption/race conditions** – fire two token requests in parallel (Burp intruder, turbo intruder). Weak issuers sometimes grant both.
- **Observe replay handling** – a reuse attempt should not only fail but also revoke any tokens already minted from that code. Otherwise, a detected replay leaves the attacker’s first token active.

Combining a replay-friendly code with any `redirect_uri` or logging bug allows persistent account access even after the victim completes the legitimate login.

### Authorization/Refresh Token not bound to client

If you can get the **authorization code and use it with a different client then you can takeover other accounts**.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) you can see that the **token** that **AWS Cognito** gives back to the user might have **enough permissions to overwrite the user data**. Therefore, if you can **change the user email for a different user email**, you might be able to **take over** others accounts.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
For more detailed info about how to abuse AWS Cognito check [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Nadużywanie other Apps tokens <a href="#bda5" id="bda5"></a>

Jak [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), przepływy OAuth, które oczekują otrzymania **token** (a nie kodu) mogą być podatne, jeśli nie sprawdzają, czy token należy do danej aplikacji.

Jest tak dlatego, że **atakujący** może stworzyć **aplikację wspierającą OAuth i logowanie z Facebook** (na przykład) jako własną aplikację. Następnie, gdy ofiara zaloguje się przez Facebook w aplikacji **atakującego**, atakujący może otrzymać **OAuth token użytkownika przyznany jego aplikacji i użyć go do zalogowania się w podatnej aplikacji OAuth ofiary korzystając z tokenu użytkownika ofiary**.

> [!CAUTION]
> Dlatego, jeśli atakującemu uda się doprowadzić do tego, że użytkownik uzyska dostęp do jego własnej aplikacji OAuth, będzie on w stanie przejąć konto ofiary w aplikacjach, które oczekują token i nie sprawdzają, czy token został przyznany dla ich app ID.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Zgodnie z [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), możliwe było zmuszenie ofiary do otwarcia strony z parametrem **returnUrl** wskazującym na host atakującego. Ta informacja byłaby **zapamiętana w cookie (RU)** i w **kolejnym kroku** **prompt** zapyta **użytkownika**, czy chce dać dostęp temu hostowi atakującego.

Aby ominąć ten prompt, możliwe było otworzenie karty inicjującej **Oauth flow**, która ustawiłaby to cookie RU używając **returnUrl**, zamknięcie karty zanim prompt zostanie pokazany i otwarcie nowej karty bez tej wartości. Wtedy **prompt nie poinformuje o hoście atakującego**, ale cookie będzie ustawione na ten host, więc **token zostanie wysłany do hosta atakującego** w przekierowaniu.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Jak wyjaśniono w [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), niektóre implementacje OAuth pozwalają wskazać GET parametr **`prompt`** jako None (**`&prompt=none`**) aby **zapobiec wyświetlaniu użytkownikom monitów potwierdzających** przyznany dostęp w przeglądarce, jeśli są już zalogowani na platformie.

### response_mode

Jak [**wyjaśniono w tym wideo**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), może być możliwe wskazanie parametru **`response_mode`** aby określić, gdzie ma zostać dostarczony kod w końcowym URL:

- `response_mode=query` -> Kod jest dostarczany w parametrze GET: `?code=2397rf3gu93f`
- `response_mode=fragment` -> Kod jest dostarczany w fragmencie URL: `#code=2397rf3gu93f`
- `response_mode=form_post` -> Kod jest dostarczany w formularzu POST jako input o nazwie `code` z wartością
- `response_mode=web_message` -> Kod jest wysyłany w post message: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

Dialogi zgody/logowania OAuth są idealnymi celami do clickjackingu: jeśli można je umieścić w ramce, atakujący może nakładać własne grafiki, ukrywać prawdziwe przyciski i oszukiwać użytkowników, by zatwierdzili niebezpieczne scope'y lub powiązali konta. Twórz PoC które:

1. Ładują URL autoryzacji IdP wewnątrz `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Używają pozycjonowania absolutnego/opacity, aby wyrównać fałszywe przyciski z ukrytymi kontrolkami **Allow**/**Approve**.
3. Opcjonalnie wstępnie ustawiają parametry (scopes, redirect URI), tak aby skradzione zatwierdzenie natychmiast przyniosło korzyść atakującemu.

Podczas testów zweryfikuj, czy strony IdP emitują nagłówki `X-Frame-Options: DENY/SAMEORIGIN` lub restrykcyjne `Content-Security-Policy: frame-ancestors 'none'`. Jeśli żaden z nich nie występuje, zademonstruj ryzyko przy użyciu narzędzi takich jak [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) i nagraj, jak łatwo ofiara autoryzuje aplikację atakującego. Dla dodatkowych pomysłów na payloady zobacz [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

Zgodnie z [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), jest to przepływ OAuth, który pozwala na logowanie do OAuth za pomocą **username** i **password**. Jeśli w trakcie tego prostego przepływu zwracany jest **token** z dostępem do wszystkich akcji użytkownika, możliwe jest obejście 2FA używając tego tokena.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Ten [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) opisuje, jak można było nadużyć **open redirect** na podstawie wartości **referrer** aby wykorzystać OAuth do ATO. Atak wyglądał następująco:

1. Ofiara wchodzi na stronę atakującego
2. Ofiara otwiera złośliwy link i opener uruchamia Google OAuth flow z dodatkowymi parametrami `response_type=id_token,code&prompt=none` używając jako **referrer** strony atakującego.
3. W openerze, po autoryzacji dostawcy, użytkownik jest wysyłany z powrotem na wartość parametru `redirect_uri` (strona ofiary) z kodem 30X, co wciąż pozostawia stronę atakującego w refererze.
4. Strona ofiary **triggeruje open redirect bazując na referrerze** przekierowując użytkownika do strony atakującego; ponieważ **`respose_type`** było **`id_token,code`**, kod zostanie wysłany do atakującego w **fragmencie** URL, co pozwala mu przejąć konto użytkownika przez Google na stronie ofiary.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

Dynamic Client Registration w OAuth działa jako mniej oczywisty, lecz krytyczny wektor dla podatności bezpieczeństwa, szczególnie dla ataków typu **Server-Side Request Forgery (SSRF)**. Ten endpoint pozwala serwerom OAuth przyjmować szczegóły o klientach aplikacji, w tym wrażliwe URL-e, które można wykorzystać.

Kluczowe punkty:

- **Dynamic Client Registration** jest często mapowany na `/register` i przyjmuje szczegóły takie jak `client_name`, `client_secret`, `redirect_uris` oraz URL-e do logo lub JSON Web Key Sets (JWKs) przez żądania POST.
- Funkcja ta podąża za specyfikacjami w **RFC7591** i **OpenID Connect Registration 1.0**, które zawierają parametry potencjalnie podatne na SSRF.
- Proces rejestracji może mimowolnie wystawić serwery na SSRF na kilka sposobów:
  - **`logo_uri`**: URL do logo klienta, który serwer może pobrać, wywołując SSRF lub prowadząc do XSS, jeśli URL jest niewłaściwie obsłużony.
  - **`jwks_uri`**: URL do dokumentu JWK klienta, który jeśli jest złośliwie spreparowany, może spowodować, że serwer wykona outbound request do serwera kontrolowanego przez atakującego.
  - **`sector_identifier_uri`**: Odnosi się do tablicy JSON z `redirect_uris`, którą serwer może pobrać, tworząc możliwość SSRF.
  - **`request_uris`**: Lista dozwolonych request URI dla klienta, które można wykorzystać jeśli serwer pobiera te URI na początku procesu autoryzacji.

Strategia eksploatacji:

- SSRF można wywołać rejestrując nowego klienta z złośliwymi URL-ami w parametrach takich jak `logo_uri`, `jwks_uri` lub `sector_identifier_uri`.
- Chociaż bezpośrednia eksploatacja przez `request_uris` może być ograniczona przez mechanizmy whitelist, dostarczenie uprzednio zarejestrowanego, kontrolowanego przez atakującego `request_uri` może ułatwić SSRF podczas fazy autoryzacji.

## OAuth providers Race Conditions

Jeśli platforma, którą testujesz, jest dostawcą OAuth [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

W OAuth pole sub identyfikuje użytkownika unikatowo, ale jego format różni się w zależności od Authorization Servera. Aby ustandaryzować identyfikację użytkownika, niektórzy klienci używają emaili lub user handle. To jest ryzykowne, ponieważ:

- Niektóre Authorization Servers nie zapewniają, że te właściwości (jak email) pozostaną niezmienne.
- W niektórych implementacjach — takich jak **"Login with Microsoft"** — klient polega na polu email, które jest **kontrolowane przez użytkownika w Entra ID** i nie jest weryfikowane.
- Atakujący może to wykorzystać tworząc własną organizację Azure AD (np. doyensectestorg) i użyć jej do logowania Microsoft.
- Chociaż Object ID (przechowywany w sub) jest niezmienny i bezpieczny, poleganie na mutowalnym polu email może umożliwić przejęcie konta (np. przejęcie konta typu victim@gmail.com).

## Client Confusion Attack

W **Client Confusion Attack**, aplikacja używająca OAuth Implicit Flow nie weryfikuje, czy końcowy access token został wygenerowany specjalnie dla jej własnego Client ID. Atakujący tworzy publiczną stronę używającą Google’s OAuth Implicit Flow, oszukując tysiące użytkowników do logowania i zbierając access tokeny przeznaczone dla strony atakującego. Jeśli ci użytkownicy mają również konta na innej podatnej stronie, która nie weryfikuje Client ID tokenu, atakujący może ponownie użyć zebranych tokenów, by podszyć się pod ofiary i przejąć ich konta.

## Scope Upgrade Attack

Authorization Code Grant obejmuje bezpieczną komunikację serwer-do-serwera do przesyłania danych użytkownika. Jednak jeśli **Authorization Server** implicitnie ufa parametrowi scope w Access Token Request (parametr nie zdefiniowany w RFC), złośliwa aplikacja mogłaby podwyższyć uprawnienia kodu autoryzacyjnego żądając wyższego scope. Po wygenerowaniu **Access Token**, **Resource Server** musi go zweryfikować: dla tokenów JWT oznacza to sprawdzenie podpisu JWT i wydobycie danych takich jak client_id i scope, podczas gdy dla tokenów będących losowymi ciągami, serwer musi zapytać Authorization Server o szczegóły tokena.

## Redirect Scheme Hijacking

W mobilnych implementacjach OAuth aplikacje używają **custom URI schemes** aby odbierać przekierowania z Authorization Codes. Jednak ponieważ na urządzeniu może zarejestrować ten sam scheme wiele aplikacji, założenie, że tylko prawidłowy klient kontroluje redirect URI zostaje naruszone. Na Androidzie, na przykład, Intent URI takie jak `com.example.app://` oauth jest łapane na podstawie scheme i opcjonalnych filtrów zdefiniowanych w intent-filter aplikacji. Ponieważ rozwiązywanie intentów w Androidzie może być szerokie — zwłaszcza jeśli określony jest tylko scheme — atakujący może zarejestrować złośliwą aplikację z precyzyjnie przygotowanym intent filterem, aby przechwycić authorization code. To może **umożliwić przejęcie konta** zarówno poprzez interakcję użytkownika (gdy wiele aplikacji kwalifikuje się do obsługi intentu), jak i poprzez techniki obejścia wykorzystujące zbyt specyficzne filtry, jak opisano w flowcharcie oceny Ostorlab.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)

{{#include ../banners/hacktricks-training.md}}
