# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}


## Basic Information <a href="#d4a8" id="d4a8"></a>

OAuth inatoa toleo mbalimbali, huku maarifa ya msingi yanapatikana katika [OAuth 2.0 documentation](https://oauth.net/2/). Majadiliano haya yanazingatia hasa [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), ikitoa **mfumo wa idhini unaowezesha programu kufikia au kufanya vitendo kwenye akaunti ya mtumiaji katika programu nyingine** (seva ya idhini).

Fikiria tovuti ya mfano _**https://example.com**_, iliyoundwa ili **kuonyesha machapisho yako yote ya mitandao ya kijamii**, ikiwa ni pamoja na ya faragha. Ili kufanikisha hili, OAuth 2.0 inatumika. _https://example.com_ itahitaji ruhusa yako ili **kufikia machapisho yako ya mitandao ya kijamii**. Kwa hivyo, skrini ya idhini itaonekana kwenye _https://socialmedia.com_, ikielezea **ruhusa zinazohitajika na mtengenezaji anayefanya ombi**. Baada ya idhini yako, _https://example.com_ inapata uwezo wa **kufikia machapisho yako kwa niaba yako**.

Ni muhimu kuelewa vipengele vifuatavyo ndani ya mfumo wa OAuth 2.0:

- **resource owner**: Wewe, kama **mtumiaji/kitengo**, unaruhusu ufikiaji wa rasilimali yako, kama vile machapisho ya akaunti yako ya mitandao ya kijamii.
- **resource server**: **seva inayosimamia maombi yaliyothibitishwa** baada ya programu kupata `access token` kwa niaba ya `resource owner`, e.g., **https://socialmedia.com**.
- **client application**: **programu inayotafuta idhini** kutoka kwa `resource owner`, kama **https://example.com**.
- **authorization server**: **seva inayotoa `access tokens`** kwa `client application` baada ya uthibitisho wa mafanikio wa `resource owner` na kupata idhini, e.g., **https://socialmedia.com**.
- **client_id**: Kitambulisho cha umma, cha kipekee kwa programu.
- **client_secret:** Funguo ya siri, inayojulikana pekee kwa programu na seva ya idhini, inayotumika kwa ajili ya kuzalisha `access_tokens`.
- **response_type**: Thamani inayobainisha **aina ya token inayohitajika**, kama `code`.
- **scope**: **ngazi ya ufikiaji** ambayo `client application` inahitaji kutoka kwa `resource owner`.
- **redirect_uri**: **URL ambayo mtumiaji anarejeshwa baada ya idhini**. Hii kwa kawaida inapaswa kuendana na URL ya kuhamasisha iliyosajiliwa awali.
- **state**: Kigezo cha **kuhifadhi data wakati wa kuelekea na kurudi kwa mtumiaji kwenye seva ya idhini**. Upekee wake ni muhimu kwa ajili ya kutumikia kama **mekanismu ya ulinzi wa CSRF**.
- **grant_type**: Kigezo kinachoashiria **aina ya grant na aina ya token itakayorejeshwa**.
- **code**: Kodu ya idhini kutoka kwa `authorization server`, inayotumika pamoja na `client_id` na `client_secret` na `client application` ili kupata `access_token`.
- **access_token**: **token ambayo `client application` inatumia kwa maombi ya API** kwa niaba ya `resource owner`.
- **refresh_token**: Inaruhusu programu **kupata `access_token` mpya bila kumlazimisha mtumiaji tena**.

### Flow

**mchakato halisi wa OAuth** unafanyika kama ifuatavyo:

1. Unatembelea [https://example.com](https://example.com) na kuchagua kitufe cha “Integrate with Social Media”.
2. Tovuti hiyo kisha inatuma ombi kwa [https://socialmedia.com](https://socialmedia.com) ikitaka ruhusa yako ili kuruhusu programu ya https://example.com kufikia machapisho yako. Ombi limeundwa kama:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Kisha unawasilishwa na ukurasa wa idhini.  
4. Kufuatia idhini yako, Social Media inatuma jibu kwa `redirect_uri` pamoja na vigezo vya `code` na `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com inatumia `code` hii, pamoja na `client_id` na `client_secret` yake, kufanya ombi la upande wa seva ili kupata `access_token` kwa niaba yako, ikiruhusu ufikiaji wa ruhusa ulizokubali:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Hatimaye, mchakato unamalizika wakati https://example.com inatumia `access_token` yako kufanya wito wa API kwa Social Media ili kufikia

## Uthibitisho wa Usalama <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

`redirect_uri` ni muhimu kwa usalama katika utekelezaji wa OAuth na OpenID, kwani inaelekeza mahali ambapo data nyeti, kama vile nambari za idhini, zinatumwa baada ya idhini. Ikiwa imewekwa vibaya, inaweza kuruhusu washambuliaji kuelekeza maombi haya kwa seva mbaya, na kuwezesha kuchukuliwa kwa akaunti.

Mbinu za unyakuzi zinatofautiana kulingana na mantiki ya uthibitisho wa seva. Zinweza kutofautiana kutoka kwa mechi kali ya njia hadi kukubali URL yoyote ndani ya eneo lililotajwa au saraka ndogo. Mbinu za kawaida za unyakuzi ni pamoja na redirects wazi, kupita njia, kutumia regex dhaifu, na kuingiza HTML kwa ajili ya wizi wa token.

Mbali na `redirect_uri`, vigezo vingine vya OAuth na OpenID kama `client_uri`, `policy_uri`, `tos_uri`, na `initiate_login_uri` pia vinaweza kuathiriwa na mashambulizi ya kuelekeza. Vigezo hivi ni hiari na msaada wao unatofautiana kati ya seva.

Kwa wale wanaolenga seva ya OpenID, mwisho wa ugunduzi (`**.well-known/openid-configuration**`) mara nyingi huorodhesha maelezo muhimu ya usanidi kama vile `registration_endpoint`, `request_uri_parameter_supported`, na "`require_request_uri_registration`. Maelezo haya yanaweza kusaidia katika kubaini mwisho wa usajili na maelezo mengine ya usanidi wa seva.

### XSS katika utekelezaji wa kuelekeza <a href="#bda5" id="bda5"></a>

Kama ilivyotajwa katika ripoti hii ya bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) inaweza kuwa inawezekana kwamba **URL ya kuelekeza inajitokeza katika jibu** la seva baada ya mtumiaji kuthibitisha, ikiwa **inaweza kuathiriwa na XSS**. Payload inayowezekana ya kujaribu:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Usimamizi mbaya wa parameter ya hali <a href="#bda5" id="bda5"></a>

Katika utekelezaji wa OAuth, matumizi mabaya au kukosekana kwa **`state` parameter** kunaweza kuongeza hatari ya mashambulizi ya **Cross-Site Request Forgery (CSRF)** kwa kiasi kikubwa. Uthibitisho huu unatokea wakati **`state` parameter** haijatumiwa, imetumiwa kama thamani ya kudumu, au haijathibitishwa ipasavyo, ikiruhusu washambuliaji kupita ulinzi wa CSRF.

Washambuliaji wanaweza kutumia hii kwa kukamata mchakato wa uthibitishaji ili kuunganisha akaunti yao na akaunti ya mwathirika, na kusababisha uwezekano wa **uchukuaji wa akaunti**. Hii ni muhimu hasa katika programu ambapo OAuth inatumika kwa **malengo ya uthibitishaji**.

Mifano halisi ya udhaifu huu imeandikwa katika changamoto mbalimbali za **CTF** na **majukwaa ya udukuzi**, ikionyesha athari zake za vitendo. Tatizo hili pia linapanuka kwa ushirikiano na huduma za upande wa tatu kama **Slack**, **Stripe**, na **PayPal**, ambapo washambuliaji wanaweza kuelekeza arifa au malipo kwa akaunti zao.

Usimamizi na uthibitisho sahihi wa **`state` parameter** ni muhimu kwa kulinda dhidi ya CSRF na kuhakikisha mchakato wa OAuth.

### Kabla ya Uchukuaji wa Akaunti <a href="#ebe4" id="ebe4"></a>

1. **Bila Uthibitisho wa Barua Pepe kwenye Uundaji wa Akaunti**: Washambuliaji wanaweza kuunda akaunti kabla kwa kutumia barua pepe ya mwathirika. Ikiwa mwathirika baadaye anatumia huduma ya upande wa tatu kuingia, programu inaweza bila kukusudia kuunganisha akaunti hii ya upande wa tatu na akaunti iliyoundwa na mshambuliaji, na kusababisha ufikiaji usioidhinishwa.
2. **Kutatua Uthibitisho wa Barua Pepe wa OAuth**: Washambuliaji wanaweza kutumia huduma za OAuth ambazo hazithibitishi barua pepe kwa kujiandikisha na huduma yao na kisha kubadilisha barua pepe ya akaunti kuwa ya mwathirika. Njia hii pia ina hatari ya ufikiaji usioidhinishwa wa akaunti, sawa na hali ya kwanza lakini kupitia njia tofauti ya shambulio.

### Ufunuo wa Siri <a href="#e177" id="e177"></a>

Kutambua na kulinda vigezo vya siri vya OAuth ni muhimu. Ingawa **`client_id`** inaweza kufichuliwa kwa usalama, kufichua **`client_secret`** kuna hatari kubwa. Ikiwa **`client_secret`** itakabiliwa, washambuliaji wanaweza kutumia utambulisho na imani ya programu ili **kuiba `access_tokens` za mtumiaji** na taarifa binafsi.

Udhaifu wa kawaida unatokea wakati programu zinashughulikia kwa makosa kubadilishana `code` ya uthibitisho kwa `access_token` upande wa mteja badala ya upande wa seva. Makosa haya yanapelekea kufichuliwa kwa **`client_secret`**, ikiruhusu washambuliaji kuunda `access_tokens` chini ya kivuli cha programu. Zaidi ya hayo, kupitia uhandisi wa kijamii, washambuliaji wanaweza kuongeza mamlaka kwa kuongeza maeneo mengine kwenye uthibitisho wa OAuth, wakitumia hali ya kuaminika ya programu.

### Mshindo wa Siri ya Mteja

Unaweza kujaribu **kushinda siri ya mteja** ya mtoa huduma na mtoa kitambulisho ili kujaribu kuiba akaunti.\
Ombi la BF linaweza kuonekana kama:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Mara tu mteja ana **code na state**, ikiwa inatolewa ndani ya **Referer header** anapovinjari kwenye ukurasa tofauti, basi iko hatarini.

### Access Token Stored in Browser History

Nenda kwenye **historia ya kivinjari na angalia kama access token imehifadhiwa humo**.

### Everlasting Authorization Code

**Authorization code inapaswa kuishi kwa muda fulani tu ili kupunguza dirisha la muda ambapo mshambuliaji anaweza kuiba na kuitumia**.

### Authorization/Refresh Token not bound to client

Ikiwa unaweza kupata **authorization code na kuifanya na mteja tofauti basi unaweza kuchukua akaunti nyingine**.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

Katika ripoti hii ya bug bounty: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) unaweza kuona kwamba **token** ambayo **AWS Cognito** inarudisha kwa mtumiaji inaweza kuwa na **idhini za kutosha kubadilisha data za mtumiaji**. Hivyo, ikiwa unaweza **kubadilisha barua pepe ya mtumiaji kwa barua pepe tofauti ya mtumiaji**, unaweza kuwa na uwezo wa **kuchukua** akaunti za wengine.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Kwa maelezo ya kina zaidi kuhusu jinsi ya kutumia AWS cognito angalia:

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### Kutumia token za Apps nyingine <a href="#bda5" id="bda5"></a>

Kama [**ilivyotajwa katika andiko hili**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), mchakato wa OAuth unaotarajia kupokea **token** (na si nambari) unaweza kuwa na hatari ikiwa hawakagui kwamba token inamhusu app.

Hii ni kwa sababu **mshambuliaji** anaweza kuunda **programu inayounga mkono OAuth na kuingia na Facebook** (kwa mfano) katika programu yake mwenyewe. Kisha, mara tu mwathirika anapoingia na Facebook katika **programu ya mshambuliaji**, mshambuliaji anaweza kupata **token ya OAuth ya mtumiaji iliyotolewa kwa programu yake, na kuitumia kuingia katika programu ya OAuth ya mwathirika kwa kutumia token ya mtumiaji wa mwathirika**.

> [!CAUTION]
> Hivyo, ikiwa mshambuliaji atafanikiwa kumfanya mtumiaji aingie katika programu yake ya OAuth, ataweza kuchukua akaunti ya mwathirika katika programu zinazotarajia token na hazikagui ikiwa token ilitolewa kwa ID ya programu yao.

### Viungo viwili & cookie <a href="#bda5" id="bda5"></a>

Kulingana na [**andiko hili**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), ilikuwa inawezekana kumfanya mwathirika afungue ukurasa wenye **returnUrl** unaoelekeza kwenye mwenyeji wa mshambuliaji. Habari hii ingekuwa **imehifadhiwa katika cookie (RU)** na katika **hatua ya baadaye** **prompt** itakuwa **inauliza** **mtumiaji** ikiwa anataka kutoa ufikiaji kwa mwenyeji wa mshambuliaji.

Ili kupita prompt hii, ilikuwa inawezekana kufungua tab ili kuanzisha **Oauth flow** ambayo ingeiweka cookie hii ya RU kwa kutumia **returnUrl**, kufunga tab kabla ya prompt kuonyeshwa, na kufungua tab mpya bila thamani hiyo. Kisha, **prompt haitatoa taarifa kuhusu mwenyeji wa mshambuliaji**, lakini cookie itakuwa imewekwa kwake, hivyo **token itatumwa kwa mwenyeji wa mshambuliaji** katika uelekezaji.

### Kupita Mwingiliano wa Prompt <a href="#bda5" id="bda5"></a>

Kama ilivyoelezwa katika [**video hii**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), baadhi ya utekelezaji wa OAuth huruhusu kuashiria **`prompt`** GET parameter kama None (**`&prompt=none`**) ili **kuzuia watumiaji kuulizwa kuthibitisha** ufikiaji uliopewa katika prompt kwenye wavuti ikiwa tayari wameingia kwenye jukwaa.

### response_mode

Kama [**ilivyoelezwa katika video hii**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), inaweza kuwa inawezekana kuashiria parameter **`response_mode`** kuonyesha unataka nambari ipatikane wapi katika URL ya mwisho:

- `response_mode=query` -> Nambari inapatikana ndani ya parameter ya GET: `?code=2397rf3gu93f`
- `response_mode=fragment` -> Nambari inapatikana ndani ya parameter ya URL fragment `#code=2397rf3gu93f`
- `response_mode=form_post` -> Nambari inapatikana ndani ya fomu ya POST yenye input inayoitwa `code` na thamani
- `response_mode=web_message` -> Nambari inatumwa katika ujumbe wa posta: `window.opener.postMessage({"code": "asdasdasd...`

### Mchakato wa OAuth ROPC - kupita 2 FA <a href="#b440" id="b440"></a>

Kulingana na [**andiko hili**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), huu ni mchakato wa OAuth unaoruhusu kuingia katika OAuth kupitia **jina la mtumiaji** na **nenosiri**. Ikiwa wakati wa mchakato huu rahisi **token** yenye ufikiaji kwa vitendo vyote ambavyo mtumiaji anaweza kufanya inarudishwa basi inawezekana kupita 2FA kwa kutumia token hiyo.

### ATO kwenye ukurasa wa wavuti unaoelekeza kulingana na uelekezaji wazi kwa referrer <a href="#bda5" id="bda5"></a>

Hii [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) inaelezea jinsi ilivyowezekana kutumia **upelelezi wazi** kwa thamani kutoka kwa **referrer** kutumia OAuth kwa ATO. Shambulio lilikuwa:

1. Mwathirika anafikia ukurasa wa wavuti wa mshambuliaji
2. Mwathirika anafungua kiungo kibaya na opener inaanzisha mchakato wa Google OAuth na `response_type=id_token,code&prompt=none` kama vigezo vya ziada kwa kutumia kama **referrer tovuti ya mshambuliaji**.
3. Katika opener, baada ya mtoa huduma kumthibitisha mwathirika, inawapelekea nyuma kwa thamani ya parameter ya `redirect_uri` (wavuti ya mwathirika) kwa nambari ya 30X ambayo bado inashikilia tovuti ya mshambuliaji katika referrer.
4. Tovuti ya mwathirika **inasababisha uelekezaji wazi kulingana na referrer** ikielekeza mtumiaji wa mwathirika kwenye tovuti ya mshambuliaji, kwani **`respose_type`** ilikuwa **`id_token,code`**, nambari itarudishwa kwa mshambuliaji katika **fragment** ya URL ikimruhusu kuchukua akaunti ya mtumiaji kupitia Google kwenye tovuti ya mwathirika.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Angalia utafiti huu**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Kwa maelezo zaidi ya mbinu hii.**

Usajili wa Wateja wa Kijadi katika OAuth unatumika kama njia isiyo wazi lakini muhimu kwa udhaifu wa usalama, haswa kwa mashambulizi ya **Server-Side Request Forgery (SSRF)**. Endpoint hii inaruhusu seva za OAuth kupokea maelezo kuhusu programu za wateja, ikiwa ni pamoja na URLs nyeti ambazo zinaweza kutumika vibaya.

**Mambo Muhimu:**

- **Usajili wa Wateja wa Kijadi** mara nyingi unahusishwa na `/register` na unakubali maelezo kama `client_name`, `client_secret`, `redirect_uris`, na URLs za alama au JSON Web Key Sets (JWKs) kupitia maombi ya POST.
- Kipengele hiki kinazingatia viwango vilivyowekwa katika **RFC7591** na **OpenID Connect Registration 1.0**, ambavyo vinajumuisha vigezo ambavyo vinaweza kuwa na hatari kwa SSRF.
- Mchakato wa usajili unaweza bila kukusudia kufichua seva kwa SSRF kwa njia kadhaa:
- **`logo_uri`**: URL ya alama ya programu ya mteja ambayo inaweza kupatikana na seva, ikisababisha SSRF au kupelekea XSS ikiwa URL itashughulikiwa vibaya.
- **`jwks_uri`**: URL ya hati ya JWK ya mteja, ambayo ikiwa imeundwa kwa njia mbaya, inaweza kusababisha seva kufanya maombi ya nje kwa seva inayodhibitiwa na mshambuliaji.
- **`sector_identifier_uri`**: Inarejelea orodha ya JSON ya `redirect_uris`, ambayo seva inaweza kupakua, ikisababisha fursa ya SSRF.
- **`request_uris`**: Inataja URIs za maombi zinazoruhusiwa kwa mteja, ambazo zinaweza kutumika vibaya ikiwa seva itazipakua mwanzoni mwa mchakato wa uthibitishaji.

**Mkakati wa Kutumia:**

- SSRF inaweza kusababishwa kwa kujiandikisha mteja mpya na URLs mbaya katika vigezo kama `logo_uri`, `jwks_uri`, au `sector_identifier_uri`.
- Ingawa matumizi ya moja kwa moja kupitia `request_uris` yanaweza kupunguziliwa mbali na udhibiti wa orodha ya ruhusa, kutoa `request_uri` iliyosajiliwa awali, inayodhibitiwa na mshambuliaji kunaweza kuwezesha SSRF wakati wa hatua ya uthibitishaji.

## Mipangilio ya Watoa huduma wa OAuth

Ikiwa jukwaa unalojaribu ni mtoa huduma wa OAuth [**soma hii ili kujaribu uwezekano wa Mipangilio ya Mbio**](race-condition.md).

## Marejeleo

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)


{{#include ../banners/hacktricks-training.md}}
