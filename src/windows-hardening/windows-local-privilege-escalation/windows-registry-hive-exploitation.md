# Primitivas de Exploração de Hives do Registro do Windows

{{#include ../../banners/hacktricks-training.md}}

## Por que a corrupção de hive é especial

As hives do registro do Windows são **arquivos `.regf` mapeados em memória** gerenciados por um alocador customizado (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`). O alocador:

- **Não randomiza alocações** – o posicionamento das cells depende apenas da ordem/tamanho das chamadas de API do Registry anteriores, então os layouts são reprodutíveis entre hosts.
- **Não possui verificações de integridade** – campos de header/data alterados manualmente são confiáveis pelos consumidores do kernel (rotinas `Cmp*`) e pelo próprio processo Registry.
- **Compartilha espaço de endereço com hives privilegiados** – em muitos casos hives controlados por um atacante são mapeados na mesma faixa de endereços em user-mode que os hives HKLM/HKU, permitindo overflows entre hives.

Isso torna bugs de corrupção de memória baseados em hives (por exemplo, CVE-2023-23420 / CVE-2023-23423) exclusivamente confiáveis para LPE.

## Grooming de layout determinístico com as APIs do Registry

Como a alocação de hive é determinística, você pode groomar o posicionamento de cells puramente via Win32 APIs. Um fluxo de trabalho típico é:

1. **Reset the target key** (excluir/recriar) para que o hive bin contenha apenas cells conhecidas.
2. **Allocate predictable runs of cells** criando valores com tamanhos cuidadosamente selecionados:
- As cells de metadados de Key/value são múltiplos de 8 bytes.
- Escrever valores de `0x3FD8` bytes força um novo bin de `0x4000` bytes (`0x3FD8` dados + header/padding `_HBIN`), ideal para intercalar bins depois.
3. **Use resize-friendly types** (por exemplo, `REG_BINARY`) para que você possa liberar/estender cells individuais apenas chamando `RegSetValueEx` com tamanhos diferentes.
4. **Record the sequence** de operações (create/delete/resize). Reproduzir a sequência gera o mesmo layout em outros sistemas porque o alocador não tem aleatoriedade.

<details>
<summary>Exemplo de modelador de layout (C simplificado)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Uma primitiva de corrupção (overwrite/fill) está disponível, o groom garante que a **target cell resides next to the sprayed holes**, permitindo overwrites precisos sem heap spraying.

## API-only access to privileged hives via misconfigured descendants

O Windows avalia apenas a **ACL no componente final** de um caminho de registro. Se qualquer descendente sob HKLM/HKU conceder `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY` ou `WRITE_DAC` a usuários de baixo privilégio, você pode alcançá-lo mesmo quando todas as chaves pai estão bloqueadas. Project Zero encontrou **>1000 chaves graváveis em HKLM no Windows 11**, incluindo entradas de longa duração como `HKLM\SOFTWARE\Microsoft\DRM` e vários ramos de `HKLM\SYSTEM`.

Estratégia prática de enumeração:

1. A partir de um contexto elevado, percorra `\Registry\Machine` e `\Registry\User`, fazendo dump do security descriptor de cada chave. Armazene itens cuja DACL permite SIDs não privilegiados.
2. Como usuário normal, tente `RegOpenKeyEx` com `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` contra os caminhos registrados. Aberturas bem-sucedidas são alvos viáveis para bugs de corrupção de hive que requerem dados controlados pelo atacante em system hives.
3. Mantenha um cache de handles abertos para **localizações graváveis estáveis** para que PoCs possam implantar diretamente metadata corrompida.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Once such a path is known, the exploit never needs offline hive tampering—**APIs padrão do Registry são suficientes** para colocar as células corrompidas dentro de hives privilegiadas tocadas por serviços SYSTEM.

## Abuso de hive entre usuários via `HKCU\Software\Microsoft\Input\TypingInsights`

Every user hive contém `HKCU\Software\Microsoft\Input\TypingInsights`, cuja ACL concede `KEY_ALL_ACCESS` ao **Everyone (S-1-1-0).** Enquanto a Microsoft não corrigir, qualquer usuário pode:

- **Preencher o hive de outro usuário** até o limite de 2 GiB, causando falhas de logon ou forçando truncamento do hive (útil para coagir comportamento do alocador ou DoS).
- **Inserir células corrompidas** no `NTUSER.DAT` de outros usuários, preparando exploits laterais que disparam quando o processo vítima lê a chave comprometida.
- **Modificar differencing hives** para apps em sandbox que dependem de hives de overlay por usuário, forçando-os a consumir metadados maliciosos.

Isso torna vulnerabilidades de corrupção de hive aplicáveis a **movimentação lateral**, não apenas elevação dentro da mesma conta.

## Transformando corrupção de metadados em overflows no paged pool

Large registry values são armazenados em registros `_CM_BIG_DATA`:

- `_CM_KEY_VALUE.DataLength` contém o tamanho lógico. Seu bit alto indica se o payload vive dentro da célula ou no armazenamento big-data.
- `_CM_BIG_DATA.Count` conta **chunks de 16 KiB** (16384 bytes menos metadata) referenciados via uma tabela de chunks.

Quando qualquer componente chama `CmpGetValueData`:

1. O kernel aloca um **buffer no paged pool** dimensionado estritamente a partir de `DataLength`.
2. Ele copia `Count * 0x4000` bytes do armazenamento do hive para esse buffer.

Se você consegue corromper a célula de modo que `DataLength < 16344 * (Count - 1)`, a cópia **ultrapassa linearmente o destino** para objetos adjacentes no paged pool. Uma cadeia confiável de exploit é:

1. Use o groom determinístico para posicionar o `_CM_KEY_VALUE` vulnerável perto de metadata controlável.
2. Inverta `DataLength` para um número pequeno (ex.: 0x100) mantendo `_CM_BIG_DATA.Count` intacto.
3. Faça pool-groom a partir do modo usuário (pipes, ALPC ports, section objects) para que um objeto escolhido (como o dono de `EPROCESS->Token` ou `SRVNET_BUFFER`) ocupe o próximo chunk após a alocação do passo 1.
4. Dispare uma leitura (ex.: `RegQueryValueEx`, `NtQueryValueKey`) para que `CmpGetValueData` copie todos os chunks e **sobrescreva os campos do vizinho** com dados controlados pelo atacante vindos do hive.
5. Use o objeto kernel corrompido para pivotar para leitura/gravação arbitrária ou roubo direto do token SYSTEM.

Porque o comprimento do overflow é `(Count * 0x4000) - DataLength`, você obtém um **orçamento preciso de bytes** e controle total sobre os bytes escritos, superando muitos overflows de pool baseados em drivers.

## Overflows lineares inter-hive via HBINs fortemente empacotados

Hives montados pelo processo Registry são mapeados em visualizações **alinhadas a 2 MiB** sem **gaps de proteção**. Você pode forçar dois hives diferentes a crescer em sincronia até que suas faixas `_HBIN` se toquem:

1. Escolha um hive gravável pelo atacante (app hive ou user hive) e um alvo privilegiado (ex.: `HKLM\SOFTWARE`).
2. Crie/exclua continuamente valores de `0x3FD8` bytes em ambos os hives. Cada alocação adiciona um bin de `0x4000` bytes, então rodar ambos os escritores em paralelo entrelaça seus bins na memória virtual (observado com `!process Registry` + `!vad`).
3. Uma vez que o bin final do hive do atacante estiver imediatamente antes de um HBIN pertencente ao HKLM, use o bug de corrupção do hive para **transbordar para fora do hive do atacante**, destruindo headers HBIN ou células dentro do HKLM.
4. Com a metadata do HKLM sob controle você pode:
- Preparar uma primitiva de inconsistência big-data diretamente no hive privilegiado.
- Corromper dados de configuração consumidos por serviços SYSTEM antes que saiam do kernel.

A ausência de guard pages significa que uma sobrescrita linear de um hive não privilegiado pode **corromper diretamente estruturas de hive pertencentes ao SYSTEM**, permitindo ataques apenas-de-dados ou preparando o overflow de pool descrito acima dentro de HKLM/HKU.

## Dicas operacionais

- Monitore o posicionamento dos hives com `!vad` (user-mode) e `!reg view` / `!pool` (kernel) para confirmar adjacência antes de disparar o overflow.
- Cache caminhos HKLM graváveis descobertos durante a enumeração para que primitivas de corrupção possam ser implantadas rapidamente mesmo após reboots.
- Combine hive grooming com o feng shui padrão de pool (freelists de pares de pipe, `NtAllocateVirtualMemory` no processo `Registry`) para estabilizar primitivas pós-overflow.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
