# Primitive per lo sfruttamento degli hive del Windows Registry

{{#include ../../banners/hacktricks-training.md}}

## Perché la corruzione degli hive è speciale

Gli hive del registro di Windows sono **file `.regf` mappati in memoria** gestiti da un allocatore personalizzato (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`). L'allocatore:

- **Non randomizza le allocazioni** – la posizione delle celle dipende solo dall'ordine/dalle dimensioni delle chiamate alle Win32 APIs del registro precedenti, quindi i layout sono riproducibili su diversi host.
- **Mancano controlli d'integrità** – header/campi dati alterati manualmente vengono considerati affidabili dai consumer del kernel (`Cmp*` routines) e dallo stesso processo Registry.
- **Condivide lo spazio degli indirizzi con hive privilegiati** – in molti casi gli hive controllati dall'attaccante sono mappati nello stesso intervallo di indirizzi in user-mode degli hive HKLM/HKU, permettendo overflow inter-hive.

Questo rende i bug di corruzione di memoria basati su hive (es., CVE-2023-23420 / CVE-2023-23423) particolarmente affidabili per LPE.

## Grooming deterministico del layout con le Win32 APIs del registro

Poiché l'allocazione degli hive è deterministica, è possibile groomare il posizionamento delle celle esclusivamente tramite Win32 APIs. Un flusso tipico è:

1. **Reimposta la chiave target** (elimina/ricrea) in modo che il bin dell'hive contenga solo celle note.
2. **Alloca sequenze prevedibili di celle** creando valori con dimensioni accuratamente selezionate:
- Le celle di metadata di chiave/valore sono multipli di 8 byte.
- Scrivere valori di `0x3FD8` byte forza un nuovo `0x4000`-byte bin (`0x3FD8` data + `_HBIN` header/padding), ideale per intercalare i bin successivamente.
3. **Usa tipi che supportano il ridimensionamento** (es., `REG_BINARY`) in modo da poter liberare/estendere celle individuali semplicemente chiamando `RegSetValueEx` con lunghezze diverse.
4. **Registra la sequenza** di operazioni (crea/elimina/ridimensiona). Riprovarla riproduce lo stesso layout su altri sistemi perché l'allocatore non ha casualità.

<details>
<summary>Esempio di layout shaper (C semplificato)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Una volta disponibile una primitiva di corruzione (overwrite/fill), il groom garantisce che la target cell si trovi accanto ai buchi spruzzati, consentendo overwrite precisi senza heap spraying.

## Accesso solo via API agli hive privilegiati tramite discendenti mal configurati

Windows valuta solo la **ACL sull'ultima componente** di un percorso del registro. Se un qualsiasi discendente sotto HKLM/HKU concede `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY`, o `WRITE_DAC` a utenti con pochi privilegi, puoi raggiungerlo anche quando ogni chiave parent è bloccata. Project Zero ha trovato **>1000 chiavi scrivibili di questo tipo in HKLM su Windows 11**, incluse voci di lunga durata come `HKLM\SOFTWARE\Microsoft\DRM` e diverse diramazioni di `HKLM\SYSTEM`.

Strategia pratica di enumerazione:

1. Da un contesto elevato, percorri `\Registry\Machine` e `\Registry\User`, estraendo il security descriptor di ogni chiave. Conserva gli elementi la cui DACL autorizza SIDs non privilegiati.
2. Come utente normale, prova `RegOpenKeyEx` con `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` sui percorsi registrati. Le aperture riuscite sono target praticabili per bug di corruzione delle hive che richiedono dati controllati dall'attaccante nelle hive di sistema.
3. Mantieni una cache di handle aperti verso posizioni scrivibili stabili in modo che i PoC possano distribuire direttamente metadata corrotti.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Once such a path is known, the exploit never needs offline hive tampering—**standard registry APIs are enough** to stage the corrupt cells inside privileged hives touched by SYSTEM services.

## Abuso dei hive tra utenti tramite `HKCU\Software\Microsoft\Input\TypingInsights`

Every user hive contains `HKCU\Software\Microsoft\Input\TypingInsights`, whose ACL grants `KEY_ALL_ACCESS` to **Everyone (S-1-1-0).** Until Microsoft tightens it, any user can:

- **Fill another user’s hive** up to the 2 GiB limit, causing logon failures or forcing hive truncation (useful to coerce allocator behavior or DoS).
- **Drop corrupted cells** into other users’ `NTUSER.DAT`, setting up lateral exploits that trigger when the victim process reads the compromised key.
- **Modify differencing hives** for sandboxed apps that rely on per-user overlay hives, forcing them to consume malicious metadata.

This makes hive corruption vulnerabilities applicable to **lateral movement**, not just elevation within the same account.

## Turning metadata corruption into paged pool overflows

Large registry values are stored in `_CM_BIG_DATA` records:

- `_CM_KEY_VALUE.DataLength` holds the logical size. Its high bit indicates whether the payload lives inside the cell or in big-data storage.
- `_CM_BIG_DATA.Count` counts **16 KiB chunks** (16384 bytes minus metadata) referenced via a chunk table.

When any component calls `CmpGetValueData`:

1. The kernel allocates a **paged pool buffer** sized strictly from `DataLength`.
2. It copies `Count * 0x4000` bytes from hive storage into that buffer.

If you can corrupt the cell so `DataLength < 16344 * (Count - 1)`, the copy **overruns the destination linearly** into adjacent paged-pool objects. A reliable exploit chain is:

1. Use the deterministic groom to place the vulnerable `_CM_KEY_VALUE` near controllable metadata.
2. Flip `DataLength` to a small number (e.g., 0x100) while leaving `_CM_BIG_DATA.Count` intact.
3. Pool-groom from user mode (pipes, ALPC ports, section objects) so a chosen object (like `EPROCESS->Token` owner or `SRVNET_BUFFER`) occupies the next chunk after the allocation from step 1.
4. Trigger a read (e.g., `RegQueryValueEx`, `NtQueryValueKey`) so `CmpGetValueData` copies all chunks and **overwrites the neighbor’s fields** with attacker-controlled data from the hive.
5. Use the corrupted kernel object to pivot to arbitrary read/write or direct SYSTEM token theft.

Because the overflow length equals `(Count * 0x4000) - DataLength`, you get a **precise byte budget** and full control over the bytes written, outperforming many driver-based pool overflows.

## Inter-hive linear overflows via tightly packed HBINs

Hives mounted by the Registry process are mapped in **2 MiB-aligned views** with **no guard gaps**. You can force two different hives to grow in lockstep until their `_HBIN` ranges touch:

1. Choose an attacker-writable hive (app hive or user hive) and a privileged target (e.g., `HKLM\SOFTWARE`).
2. Continuously create/delete `0x3FD8`-byte values in both hives. Each allocation adds a `0x4000`-byte bin, so running both writers in parallel interleaves their bins in virtual memory (observed with `!process Registry` + `!vad`).
3. Once the final bin of the attacker hive sits immediately before an HBIN belonging to HKLM, use the hive corruption bug to **overflow out of the attacker hive**, smashing HBIN headers or cells inside HKLM.
4. With HKLM metadata under control you can:
- Stage a big-data inconsistency primitive directly in the privileged hive.
- Corrupt configuration data consumed by SYSTEM services before it ever leaves the kernel.

The absence of guard pages means a linear overwrite from an unprivileged hive can **directly corrupt SYSTEM-owned hive structures**, enabling data-only attacks or setting up the pool overflow described above inside HKLM/HKU.

## Operational tips

- Monitor hive placement with `!vad` (user-mode) and `!reg view` / `!pool` (kernel) to confirm adjacency before triggering the overflow.
- Cache writable HKLM paths discovered during enumeration so corruption primitives can be deployed quickly even after reboots.
- Combine hive grooming with standard pool feng shui (pipe pair freelists, `NtAllocateVirtualMemory` on `
Registry` process) to stabilize post-overflow primitives.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
