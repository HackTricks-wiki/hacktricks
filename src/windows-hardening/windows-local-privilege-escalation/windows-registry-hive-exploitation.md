# Windows Registry Hive Exploitation Primitives

{{#include ../../banners/hacktricks-training.md}}

## 为什么 hive 损坏很特殊

Windows 注册表 hive 是由自定义分配器（`HvAllocateCell`、`HvReallocateCell`、`HvFreeCell`）管理的**内存映射 `.regf` 文件**。该分配器：

- **不会随机化分配** – 单元的放置仅依赖于先前注册表 API 调用的顺序/大小，因此布局可以在不同主机上重现。
- **缺乏完整性检查** – 手动修改的头/数据字段会被内核消费者（`Cmp*` 例程）和注册表进程本身信任。
- **与特权 hives 共享地址空间** – 在许多情况下，攻击者控制的 hives 会被映射到与 HKLM/HKU hives 相同的用户模式地址范围，从而使 inter-hive overflows 成为可能。

这使得基于 hive 的内存损坏漏洞（例如 CVE-2023-23420 / CVE-2023-23423）在进行 LPE 时具有独特的可靠性。

## 使用注册表 API 进行确定性布局操控

由于 hive 分配是确定性的，你可以仅通过 Win32 APIs 来调整单元的放置。典型工作流程是：

1. **重置目标键**（删除/重新创建），使 hive bin 仅包含已知单元。
2. **分配可预测的单元序列**，方法是创建具有精心选择大小的值：
- 键/值元数据单元是 8 字节的倍数。
- 写入 `0x3FD8` 字节的值会触发一个新的 `0x4000` 字节的 bin（`0x3FD8` 数据 + `_HBIN` 头/填充），这对之后交错 bins 非常理想。
3. **使用易于调整大小的类型**（例如 `REG_BINARY`），这样你只需用不同长度调用 `RegSetValueEx` 就能释放/扩展单个单元。
4. **记录操作序列**（创建/删除/调整大小）。重放它会在其他系统上重现相同布局，因为分配器没有随机性。

<details>
<summary>示例布局整形器（简化 C）</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

一旦 corruption primitive (overwrite/fill) 可用，groom 就能保证 **target cell resides next to the sprayed holes**，从而在无需 heap spraying 的情况下实现精确覆盖。

## API-only access to privileged hives via misconfigured descendants

Windows 只会对注册表路径的最终组件评估 ACL。如果 HKLM/HKU 下的任意 descendant 授予低权限用户 KEY_SET_VALUE、KEY_CREATE_SUB_KEY 或 WRITE_DAC，你仍然可以访问该项，即便每个父键都被锁定。Project Zero 在 Windows 11 的 HKLM 中发现了超过 1000 个此类可写键，包括长期存在的条目如 HKLM\SOFTWARE\Microsoft\DRM 和若干 HKLM\SYSTEM 分支。

Practical enumeration strategy:

1. 从提升权限的上下文，遍历 \Registry\Machine 和 \Registry\User，导出每个键的 security descriptor。保存那些其 DACL 允许非特权 SIDs 的项。
2. 作为普通用户，针对记录的路径尝试使用 RegOpenKeyEx（权限：KEY_SET_VALUE|KEY_CREATE_SUB_KEY）。成功打开的项是针对需要攻击者可控数据写入 system hives 的 hive corruption 漏洞的可行目标。
3. 对稳定的可写位置维护打开句柄的缓存，以便 PoCs 能直接部署损坏的元数据。
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
一旦知道了这样的路径，exploit 再也不需要离线 hive 篡改——**standard registry APIs are enough** 来在由 SYSTEM 服务触及的特权 hive 中部署损坏的 cells。

## Cross-user hive abuse via `HKCU\Software\Microsoft\Input\TypingInsights`

每个用户 hive 都包含 `HKCU\Software\Microsoft\Input\TypingInsights`，其 ACL 授予 **Everyone (S-1-1-0)** `KEY_ALL_ACCESS`。在 Microsoft 加固之前，任意用户可以：

- **将另一个用户的 hive 填满** 到 2 GiB 限制，导致登录失败或迫使 hive 被截断（可用于强制分配器行为或 DoS）。
- **向其他用户的 `NTUSER.DAT` 投放损坏的 cells**，设置横向利用链，在受害进程读取被破坏的键时触发。
- **修改 differencing hives**（用于依赖每用户 overlay hive 的沙箱应用），迫使它们消耗恶意元数据。

这使得 hive 损坏漏洞适用于 **lateral movement**，而不仅仅是在同一账号内提权。

## Turning metadata corruption into paged pool overflows

Large registry values are stored in `_CM_BIG_DATA` records:

- `_CM_KEY_VALUE.DataLength` 保存逻辑大小。其高位指示 payload 是存放在 cell 内还是在 big-data 存储中。
- `_CM_BIG_DATA.Count` 计数通过 chunk 表引用的 **16 KiB chunks**（16384 字节减去元数据）。

当任何组件调用 `CmpGetValueData` 时：

1. 内核分配一个大小严格取自 `DataLength` 的 **paged pool buffer**。
2. 它从 hive 存储中将 `Count * 0x4000` 字节复制到该缓冲区。

如果你能破坏 cell 使得 `DataLength < 16344 * (Count - 1)`，该复制会**线性地越界写入目标**，侵入相邻的 paged-pool 对象。一个可靠的利用链是：

1. 使用确定性 groom 将易受攻击的 `_CM_KEY_VALUE` 放置在可控元数据附近。
2. 将 `DataLength` 翻小（例如 0x100），同时保持 `_CM_BIG_DATA.Count` 不变。
3. 从用户态进行 pool-groom（pipes、ALPC ports、section objects），使选定对象（如 `EPROCESS->Token` 所在者或 `SRVNET_BUFFER`）占据步骤 1 中分配后的下一个 chunk。
4. 触发一次读取（例如 `RegQueryValueEx`、`NtQueryValueKey`），让 `CmpGetValueData` 复制所有 chunk 并用来自 hive 的攻击者控制数据**覆盖邻居的字段**。
5. 利用被破坏的内核对象进行任意读写或直接窃取 SYSTEM token。

由于 overflow 长度等于 `(Count * 0x4000) - DataLength`，你得到一个**精确的字节预算**并对写入字节拥有完全控制，优于许多基于驱动的 pool overflow。

## Inter-hive linear overflows via tightly packed HBINs

由 Registry process 挂载的 hives 以 **2 MiB 对齐的视图** 映射，并且 **没有 guard gaps**。你可以迫使两个不同的 hive 同步增长，直到它们的 `_HBIN` 范围相邻：

1. 选择一个可被攻击者写入的 hive（app hive 或 user hive）和一个特权目标（例如 `HKLM\SOFTWARE`）。
2. 在两个 hive 中持续创建/删除 0x3FD8 字节的值。每次分配会增加一个 0x4000 字节的 bin，所以并行运行两个写入器会在虚拟内存中交错它们的 bins（可通过 `!process Registry` + `!vad` 观察到）。
3. 一旦攻击者 hive 的最后一个 bin 紧挨着属于 HKLM 的 HBIN，利用 hive 损坏 bug **从攻击者 hive 溢出**，破坏 HKLM 中的 HBIN 头或 cell。
4. 在控制了 HKLM 元数据后你可以：
- 直接在特权 hive 中布置一个 big-data 不一致性原语。
- 在配置数据离开内核之前破坏被 SYSTEM 服务消费的配置数据。

缺少 guard pages 意味着来自非特权 hive 的线性覆盖可以**直接破坏 SYSTEM 拥有的 hive 结构**，从而启用仅数据攻击或在 HKLM/HKU 内部设置上述的 pool overflow。

## Operational tips

- 使用 `!vad`（user-mode）和 `!reg view` / `!pool`（kernel）监控 hive 放置以在触发溢出前确认邻接性。
- 缓存在枚举期间发现的可写 HKLM 路径，以便即使重启后也能快速部署损坏原语。
- 将 hive grooming 与标准的 pool feng shui（pipe pair freelists、在 `Registry` process 上的 `NtAllocateVirtualMemory`）结合，以稳定溢出后的原语。

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
