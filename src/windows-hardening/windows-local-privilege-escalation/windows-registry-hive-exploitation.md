# Windows Registry Hive Exploitation Primitives

{{#include ../../banners/hacktricks-training.md}}

## Waarom hive corruption spesiaal is

Windows registry hives are **memory-mapped `.regf` files** managed by a custom allocator (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`). Die allocator:

- **Does not randomize allocations** – sel-plasing hang slegs af van die volgorde/grootte van vorige registry API-aanroepe, sodat uitlegte op verskeie hosts herproduseerbaar is.
- **Lacks integrity checks** – met die hand veranderde header/data-velde word deur kernel-konsumente (`Cmp*` routines) en deur die Registry-proses self vertrou.
- **Shares address space with privileged hives** – in baie gevalle word attacker-controlled hives in dieselfde user-mode adresreeks as HKLM/HKU hives gemap, wat inter-hive overflows moontlik maak.

Dit maak hive-based memory corruption bugs (bv. CVE-2023-23420 / CVE-2023-23423) uiters betroubaar vir LPE.

## Deterministiese layout grooming met registry APIs

Omdat hive-toewysing deterministies is, kan jy sel-plasing slegs deur Win32 APIs groom. 'n Tipiese werkvloei is:

1. **Reset the target key** (verwyder/herskep) sodat die hive bin slegs bekende selle bevat.
2. **Allocate predictable runs of cells** deur waardes te skep met noukeurig geselekteerde groottes:
- Key/value metadata-selle is veelvoude van 8 bytes.
- Die skryf van `0x3FD8`-byte waardes dwing 'n vars `0x4000`-byte bin af (`0x3FD8` data + `_HBIN` header/padding), ideaal om bins later te interleave.
3. **Use resize-friendly types** (bv. `REG_BINARY`) sodat jy individuele selle kan vrymaak/verleng net deur `RegSetValueEx` met verskillende lengtes aan te roep.
4. **Record the sequence** van operasies (create/delete/resize). Die her-afspeel daarvan reproduseer dieselfde uitleg op ander stelsels omdat die allocator geen willekeur het nie.

<details>
<summary>Voorbeeld layout shaper (vereenvoudigde C)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Sodra 'n corruption primitive (overwrite/fill) beskikbaar is, verseker die groom dat die **target cell resides next to the sprayed holes**, wat presiese overwrites moontlik maak sonder heap spraying.

## API-only access to privileged hives via misconfigured descendants

Windows evalueer slegs die **ACL on the final component** van 'n registry path. If any descendant under HKLM/HKU grants `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY`, or `WRITE_DAC` to low-privileged users, you can reach it even when every parent key is locked down. Project Zero found **>1000 such writable keys in HKLM on Windows 11**, including long-lived entries like `HKLM\SOFTWARE\Microsoft\DRM` and several `HKLM\SYSTEM` branches.

Praktiese enumerasie-strategie:

1. From an elevated context, walk `\Registry\Machine` and `\Registry\User`, dumping each key’s security descriptor. Stoor items whose DACL allows unprivileged SIDs.
2. As a normal user, attempt `RegOpenKeyEx` with `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` against the recorded paths. Successful opens are viable targets for hive corruption bugs that require attacker-controlled data in system hives.
3. Maintain a cache of open handles to **stable writable locations** so PoCs can directly deploy corrupted metadata.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Sodra so 'n pad bekend is, hoef die exploit nooit offline hive-wysiging te doen nie — **standaard registry APIs is genoeg** om die korrupte selle binne geprivilegieerde hives wat deur SYSTEM-dienste aangeraak word, te plaas.

## Cross-user hive abuse via `HKCU\Software\Microsoft\Input\TypingInsights`

Elke gebruikers-hive bevat `HKCU\Software\Microsoft\Input\TypingInsights`, waarvan die ACL `KEY_ALL_ACCESS` aan **Everyone (S-1-1-0).** toeken. Totdat Microsoft dit verskerp, kan enige gebruiker:

- **Vul 'n ander gebruiker se hive** tot die 2 GiB-grens, wat aanmeldfoute veroorsaak of hive-truncation afdwing (nuttig om allocator-gedrag of DoS te dwing).
- **Plaas gekorrupte selle** in ander gebruikers se `NTUSER.DAT`, en laterale exploits opstel wat ontlok word wanneer die slagofferproses die gekompromitteerde sleutel lees.
- **Wysig differencing hives** vir sandboxed apps wat op per-user overlay hives staatmaak, sodat hulle kwaadwillige metadata gebruik.

Dit maak hive-korrupsie-kwesbaarhede toepaslik vir **lateral movement**, nie net verhoging binne dieselfde rekening nie.

## Turning metadata corruption into paged pool overflows

Groot registry-waardes word gestoor in `_CM_BIG_DATA` rekords:

- `_CM_KEY_VALUE.DataLength` bevat die logiese grootte. Sy hoë bit dui aan of die payload binne die sel woon of in big-data stoorplek.
- `_CM_BIG_DATA.Count` tel **16 KiB chunks** (16384 bytes minus metadata) wat via 'n chunk tabel verwys word.

Wanneer enige komponent `CmpGetValueData` aanroep:

1. Die kernel allokeer 'n **paged pool buffer** streng uit `DataLength`.
2. Dit kopieer `Count * 0x4000` bytes vanaf hive-stoorplek in daardie buffer.

As jy die sel kan korrupteer sodat `DataLength < 16344 * (Count - 1)`, sal die kopieeroperasie **lineêr die bestemming oorloop** in aangrensende paged-pool-objekte. 'n Betroubare exploit-ketting is:

1. Gebruik die deterministic groom om die kwesbare `_CM_KEY_VALUE` naby beheerbare metadata te plaas.
2. Draai `DataLength` na 'n klein getal (bv. 0x100) terwyl `_CM_BIG_DATA.Count` ongeskonde bly.
3. Pool-groom vanaf user mode (pipes, ALPC ports, section objects) sodat 'n gekose objek (soos `EPROCESS->Token` owner of `SRVNET_BUFFER`) die volgende chunk ná die allokasie uit stap 1 beset.
4. Trig 'n lees (bv. `RegQueryValueEx`, `NtQueryValueKey`) sodat `CmpGetValueData` al die chunks kopieer en **oor-skryf die buur se velde** met aanvallergbeheerdata uit die hive.
5. Gebruik die gekorrupte kernel-objek om te pivot na arbitrêre read/write of direkte SYSTEM token-diefstal.

Omdat die overflow-lengte gelyk is aan `(Count * 0x4000) - DataLength`, kry jy 'n **presiese byte-begroting** en volle beheer oor die geskryfde bytes, wat baie driver-gebaseerde pool overflows oortrumf.

## Inter-hive linear overflows via tightly packed HBINs

Hives wat deur die Registry-proses gemount is, word in **2 MiB-aligned views** gekarteer met **no guard gaps**. Jy kan twee verskillende hives dwing om in lockstep te groei totdat hul `_HBIN` reekse mekaar raak:

1. Kies 'n attacker-writable hive (app hive of user hive) en 'n geprivilegieerde teiken (bv. `HKLM\SOFTWARE`).
2. Skep/verwyder voortdurend `0x3FD8`-byte waardes in beide hives. Elke allokasie voeg 'n `0x4000`-byte bin by, so om beide skrywers parallel te laat loop verweef hul bins in virtuele geheue (waargeneem met `!process Registry` + `!vad`).
3. Sodra die finale bin van die attacker hive direk voor 'n HBIN wat aan HKLM behoort sit, gebruik die hive-korrupsie-bug om **uit die attacker hive oor te loop**, en HBIN-headers of selle binne HKLM te vernietig.
4. Met HKLM-metadata onder beheer kan jy:
   - Stage 'n big-data inconsistentie-primitive direk in die geprivilegieerde hive.
   - Korrupteer konfigurasiedata wat deur SYSTEM-dienste gebruik word voordat dit ooit die kernel verlaat.

Die afwesigheid van guard pages beteken 'n lineêre oor-skryf vanaf 'n nie-geprivilegieerde hive kan **direk SYSTEM-beheerde hive-strukture korrupteer**, wat data-only-aanvalle moontlik maak of die pool overflow wat hierbo beskryf is binne HKLM/HKU opstel.

## Operational tips

- Monitor hive-plasing met `!vad` (user-mode) en `!reg view` / `!pool` (kernel) om nabyskheid te bevestig voordat jy die overflow ontlok.
- Kas skryfbare HKLM-paaie wat tydens enumerasie ontdek is sodat korrupsie-primitiewe vinnig ontplooi kan word selfs ná reboots.
- Kombineer hive grooming met standaard pool feng shui (pipe pair freelists, `NtAllocateVirtualMemory` on `Registry` process) om post-overflow primitives te stabiliseer.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
