# Windows Registry Hive Exploitation Primitives

{{#include ../../banners/hacktricks-training.md}}

## Γιατί η καταστροφή hive είναι ιδιαίτερη

Τα Windows registry hives είναι **memory-mapped `.regf` files`** που διαχειρίζονται από έναν προσαρμοσμένο allocator (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`). Ο allocator:

- **Δεν τυχαιοποιεί τις κατανομές** – η τοποθέτηση των cell εξαρτάται μόνο από τη σειρά/μέγεθος προηγούμενων κλήσεων των registry API, οπότε οι διατάξεις αναπαράγονται σταθερά μεταξύ hosts.
- **Διαθέτει έλλειψη ελέγχων ακεραιότητας** – χειροκίνητα τροποποιημένα header/data πεδία εμπιστεύονται οι kernel consumers (`Cmp*` routines) και η ίδια η Registry process.
- **Μοιράζεται το address space με privileged hives** – σε πολλές περιπτώσεις τα attacker-controlled hives κάνουν map στο ίδιο user-mode address range με τα HKLM/HKU hives, επιτρέποντας inter-hive overflows.

Αυτό κάνει σφάλματα memory corruption που βασίζονται σε hive (π.χ. CVE-2023-23420 / CVE-2023-23423) ιδιαίτερα αξιόπιστα για LPE.

## Ντετερμινιστική διαμόρφωση διάταξης με registry APIs

Εφόσον η κατανομή hive είναι ντετερμινιστική, μπορείτε να διαμορφώσετε την τοποθέτηση των cell αποκλειστικά μέσω Win32 APIs. Ένα τυπικό workflow είναι:

1. **Reset του target key** (delete/recreate) ώστε το hive bin να περιέχει μόνο γνωστά cells.
2. **Κατανομή προβλέψιμων ακολουθιών cell** δημιουργώντας values με προσεκτικά επιλεγμένα μεγέθη:
- Τα key/value metadata cells είναι πολλαπλάσια των 8 bytes.
- Η εγγραφή `0x3FD8`-byte values αναγκάζει ένα νέο `0x4000`-byte bin (`0x3FD8` data + `_HBIN` header/padding), ιδανικό για interleaving bins αργότερα.
3. **Χρήση τύπων φιλικών προς resizing** (π.χ. `REG_BINARY`) ώστε να μπορείτε να ελευθερώσετε/επεκτείνετε μεμονωμένα cells απλώς καλώντας `RegSetValueEx` με διαφορετικά μήκη.
4. **Καταγραφή της ακολουθίας** των operations (create/delete/resize). Η επανάληψή της αναπαράγει την ίδια διάταξη σε άλλα συστήματα επειδή ο allocator δεν έχει τυχαιότητα.

<details>
<summary>Παράδειγμα διαμορφωτή διάταξης (απλοποιημένο C)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Μόλις είναι διαθέσιμο ένα corruption primitive (overwrite/fill), το groom εγγυάται ότι το **target cell βρίσκεται δίπλα στις sprayed holes**, επιτρέποντας ακριβείς overwrites χωρίς heap spraying.

## API-only access to privileged hives via misconfigured descendants

Τα Windows αξιολογούν μόνο την **ACL στο τελικό συστατικό** μιας registry path. Εάν οποιοσδήποτε descendant κάτω από HKLM/HKU παραχωρεί `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY`, ή `WRITE_DAC` σε low-privileged users, μπορείτε να τον προσεγγίσετε ακόμα κι όταν κάθε parent key είναι κλειδωμένο. Το Project Zero εντόπισε **>1000 τέτοια εγράψιμα κλειδιά στο HKLM στα Windows 11**, συμπεριλαμβανομένων μακροχρόνιων καταχωρήσεων όπως `HKLM\SOFTWARE\Microsoft\DRM` και αρκετών κλάδων `HKLM\SYSTEM`.

Πρακτική στρατηγική απαρίθμησης:

1. Από ένα elevated context, περπατήστε `\Registry\Machine` και `\Registry\User`, κάνοντας dump το security descriptor κάθε κλειδιού. Αποθηκεύστε στοιχεία των οποίων η DACL επιτρέπει unprivileged SIDs.
2. Ως normal user, δοκιμάστε `RegOpenKeyEx` με `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` απέναντι στα καταγεγραμμένα paths. Επιτυχημένα opens είναι βιώσιμοι στόχοι για hive corruption bugs που απαιτούν attacker-controlled data σε system hives.
3. Διατηρήστε ένα cache ανοιχτών handles σε **stable writable locations** ώστε PoCs να μπορούν να αναπτύξουν απευθείας corrupted metadata.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Μόλις γίνει γνωστή μια τέτοια διαδρομή, το exploit δεν χρειάζεται ποτέ offline τροποποίηση των hive — **standard registry APIs are enough** για να τοποθετήσει τα διεφθαρμένα cells μέσα σε privileged hives που αγγίζονται από υπηρεσίες του SYSTEM.

## Cross-user hive abuse via `HKCU\Software\Microsoft\Input\TypingInsights`

Κάθε user hive περιέχει `HKCU\Software\Microsoft\Input\TypingInsights`, του οποίου το ACL χορηγεί `KEY_ALL_ACCESS` σε **Everyone (S-1-1-0).** Μέχρι η Microsoft να το σφίξει, οποιοσδήποτε χρήστης μπορεί:

- Να **γεμίσει το hive άλλου χρήστη** μέχρι το όριο των 2 GiB, προκαλώντας αποτυχίες logon ή αναγκάζοντας truncation του hive (χρήσιμο για εξαναγκασμό συμπεριφοράς allocator ή DoS).
- Να **τοποθετήσει corrupted cells** στο `NTUSER.DAT` άλλων χρηστών, στήνοντας lateral exploits που ενεργοποιούνται όταν η διεργασία του θύματος διαβάζει το συμβιβασμένο κλειδί.
- Να **τροποποιήσει differencing hives** για sandboxed apps που βασίζονται σε per-user overlay hives, αναγκάζοντάς τες να καταναλώσουν κακόβουλα metadata.

Αυτό κάνει τις ευπάθειες corruption των hive εφαρμόσιμες για **lateral movement**, όχι μόνο για elevation εντός του ίδιου λογαριασμού.

## Turning metadata corruption into paged pool overflows

Large registry values αποθηκεύονται σε `_CM_BIG_DATA` records:

- `_CM_KEY_VALUE.DataLength` κρατάει το λογικό μέγεθος. Το υψηλό bit του δείχνει αν το payload ζει μέσα στο cell ή στο big-data storage.
- `_CM_BIG_DATA.Count` μετράει **16 KiB chunks** (16384 bytes μείον metadata) που αναφέρονται μέσω ενός chunk table.

Όταν οποιοδήποτε component καλέσει `CmpGetValueData`:

1. Ο kernel δεσμεύει ένα **paged pool buffer** μεγέθους αυστηρά από `DataLength`.
2. Αντιγράφει `Count * 0x4000` bytes από το hive storage σε αυτό το buffer.

Αν μπορείτε να αλλοιώσετε το cell έτσι ώστε `DataLength < 16344 * (Count - 1)`, το copy **υπερχειλίζει γραμμικά τον προορισμό** σε γειτονικά paged-pool objects. Μια αξιόπιστη αλυσίδα exploit είναι:

1. Χρησιμοποιήστε το deterministic groom για να τοποθετήσετε το ευάλωτο `_CM_KEY_VALUE` κοντά σε controllable metadata.
2. Αναποδογυρίστε (`flip`) το `DataLength` σε μικρό αριθμό (π.χ. 0x100) αφήνοντας το `_CM_BIG_DATA.Count` αναλλοίωτο.
3. Pool-groom από user mode (pipes, ALPC ports, section objects) ώστε ένα επιλεγμένο object (όπως `EPROCESS->Token` owner ή `SRVNET_BUFFER`) να καταλάβει το επόμενο chunk μετά την allocation του βήματος 1.
4. Trigger ένα read (π.χ. `RegQueryValueEx`, `NtQueryValueKey`) ώστε `CmpGetValueData` να αντιγράψει όλα τα chunks και **να υπεργράψει πεδία του γείτονα** με δεδομένα ελεγχόμενα από τον attacker μέσα στο hive.
5. Χρησιμοποιήστε το διεφθαρμένο kernel object για pivot σε arbitrary read/write ή άμεση κλοπή SYSTEM token.

Επειδή το μήκος του overflow ισούται με `(Count * 0x4000) - DataLength`, έχετε ένα **ακριβές byte budget** και πλήρη έλεγχο των bytes που γράφονται, υπερέχοντας πολλών driver-based pool overflows.

## Inter-hive linear overflows via tightly packed HBINs

Τα hives που mountάρει η Registry process προβάλλονται σε **2 MiB-aligned views** χωρίς **guard gaps**. Μπορείτε να αναγκάσετε δύο διαφορετικά hives να αναπτυχθούν παράλληλα μέχρι οι περιοχές `_HBIN` τους να αγγίξουν:

1. Επιλέξτε ένα attacker-writable hive (app hive ή user hive) και έναν privileged target (π.χ. `HKLM\SOFTWARE`).
2. Συνεχίστε να δημιουργείτε/διαγράφετε `0x3FD8`-byte values και στα δύο hives. Κάθε allocation προσθέτει ένα `0x4000`-byte bin, έτσι τρέχοντας τους writers παράλληλα εισάγονται τα bins τους σε interleaved διάταξη στη virtual μνήμη (παρατηρήθηκε με `!process Registry` + `!vad`).
3. Μόλις το τελικό bin του attacker hive βρεθεί αμέσως πριν από ένα HBIN που ανήκει στο HKLM, χρησιμοποιήστε το hive corruption bug για να **overflow έξω από το attacker hive**, συντρίβοντας HBIN headers ή cells μέσα στο HKLM.
4. Με τα metadata του HKLM υπό έλεγχο μπορείτε να:
- Στήσετε ένα big-data inconsistency primitive απευθείας στο privileged hive.
- Καταστρέψετε configuration data που καταναλώνεται από SYSTEM services πριν ακόμα βγει από τον kernel.

Η απουσία guard pages σημαίνει ότι μια γραμμική υπερχείλιση από ένα unprivileged hive μπορεί **να διαφθείρει απευθείας δομές hive ιδιοκτησίας SYSTEM**, επιτρέποντας data-only επιθέσεις ή την προετοιμασία του pool overflow που περιγράφεται παραπάνω μέσα στο HKLM/HKU.

## Operational tips

- Παρακολουθήστε την τοποθέτηση των hive με `!vad` (user-mode) και `!reg view` / `!pool` (kernel) για να επιβεβαιώσετε την εγγύτητα πριν ενεργοποιήσετε το overflow.
- Cacheάρετε writable HKLM paths που βρέθηκαν κατά την enumeration ώστε τα corruption primitives να μπορούν να αναπτυχθούν γρήγορα ακόμα και μετά από reboots.
- Συνδυάστε hive grooming με standard pool feng shui (pipe pair freelists, `NtAllocateVirtualMemory` στη `Registry` process) για σταθεροποίηση των primitives μετά το overflow.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
