# Primitive eksploatacji hive rejestru Windows

{{#include ../../banners/hacktricks-training.md}}

## Dlaczego uszkodzenie hive jest wyjątkowe

Windows registry hives to **pliki `.regf` mapowane w pamięci** zarządzane przez niestandardowy alokator (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`). Alokator:

- **Nie wprowadza losowości przydziałów** – rozmieszczenie komórek zależy tylko od kolejności/rozmiarów wcześniejszych wywołań API rejestru, więc układy są powtarzalne między maszynami.
- **Brak kontroli integralności** – ręcznie zmodyfikowane pola nagłówka/danych są akceptowane przez konsumentów jądra (`Cmp*` routines) i przez sam proces Registry.
- **Dzieli przestrzeń adresową z uprzywilejowanymi hive'ami** – w wielu przypadkach hive kontrolowane przez atakującego są mapowane w tym samym zakresie adresów trybu użytkownika co hive HKLM/HKU, umożliwiając overflow między hive'ami.

To sprawia, że błędy korupcji pamięci oparte na hive (np. CVE-2023-23420 / CVE-2023-23423) są wyjątkowo niezawodne do LPE.

## Deterministyczne kształtowanie układu za pomocą API rejestru

Ponieważ alokacja hive jest deterministyczna, możesz kształtować rozmieszczenie komórek wyłącznie za pomocą Win32 APIs. Typowy workflow to:

1. **Zresetuj docelowy klucz** (usuń/utwórz ponownie), aby bin hive zawierał tylko znane komórki.
2. **Zaalokuj przewidywalne ciągi komórek** przez tworzenie wartości o starannie dobranych rozmiarach:
- Komórki metadanych klucza/wartości są wielokrotnością 8 bajtów.
- Zapis wartości o rozmiarze `0x3FD8` bajtów wymusza świeży bin `0x4000` bajtów (`0x3FD8` danych + nagłówek/padding `_HBIN`), idealny do późniejszego przeplatania binów.
3. **Używaj typów przyjaznych skalowaniu** (np. `REG_BINARY`), aby móc zwalniać/rozszerzać pojedyncze komórki po prostu wywołując `RegSetValueEx` z różnymi długościami.
4. **Zarejestruj sekwencję** operacji (create/delete/resize). Odtworzenie jej reprodukuje ten sam układ na innych systemach, ponieważ alokator nie ma losowości.

<details>
<summary>Przykład kształtowania układu (uproszczone C)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Po uzyskaniu corruption primitive (overwrite/fill), groom gwarantuje, że **target cell resides next to the sprayed holes**, co umożliwia precyzyjne nadpisania bez heap spraying.

## Dostęp wyłącznie przez API do uprzywilejowanych hives przez źle skonfigurowane klucze potomne

Windows ocenia tylko **ACL na ostatnim komponencie** ścieżki rejestru. Jeśli którykolwiek klucz potomny pod HKLM/HKU przyznaje `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY` lub `WRITE_DAC` użytkownikom o niskich uprawnieniach, możesz uzyskać do niego dostęp nawet gdy wszystkie klucze nadrzędne są zablokowane. Project Zero znalazł **>1000 takich zapisywalnych kluczy w HKLM na Windows 11**, w tym długożyjące wpisy takie jak `HKLM\SOFTWARE\Microsoft\DRM` oraz kilka gałęzi `HKLM\SYSTEM`.

Praktyczna strategia enumeracji:

1. Z uprzywilejowanego kontekstu, przeglądaj `\Registry\Machine` i `\Registry\User`, zrzucając security descriptor każdego klucza. Zapisuj elementy, których DACL pozwala nieuprzywilejowanym SID-om.
2. Jako zwykły użytkownik, spróbuj wywołać `RegOpenKeyEx` z `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` dla zapisanych ścieżek. Udane otwarcia są możliwymi celami dla hive corruption bugs, które wymagają danych kontrolowanych przez atakującego w system hives.
3. Utrzymuj cache otwartych uchwytów do **stable writable locations**, aby PoCs mogły bezpośrednio wdrożyć corrupted metadata.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Once such a path is known, the exploit never needs offline hive tampering—**standard registry APIs are enough** to stage the corrupt cells inside privileged hives touched by SYSTEM services.

## Cross-user hive abuse via `HKCU\Software\Microsoft\Input\TypingInsights`

Every user hive contains `HKCU\Software\Microsoft\Input\TypingInsights`, whose ACL grants `KEY_ALL_ACCESS` to **Everyone (S-1-1-0).** Until Microsoft tightens it, any user can:

- **Fill another user’s hive** up to the 2 GiB limit, causing logon failures or forcing hive truncation (useful to coerce allocator behavior or DoS).
- **Drop corrupted cells** into other users’ `NTUSER.DAT`, setting up lateral exploits that trigger when the victim process reads the compromised key.
- **Modify differencing hives** for sandboxed apps that rely on per-user overlay hives, forcing them to consume malicious metadata.

This makes hive corruption vulnerabilities applicable to **lateral movement**, not just elevation within the same account.

## Turning metadata corruption into paged pool overflows

Large registry values are stored in `_CM_BIG_DATA` records:

- `_CM_KEY_VALUE.DataLength` holds the logical size. Its high bit indicates whether the payload lives inside the cell or in big-data storage.
- `_CM_BIG_DATA.Count` counts **16 KiB chunks** (16384 bytes minus metadata) referenced via a chunk table.

When any component calls `CmpGetValueData`:

1. The kernel allocates a **paged pool buffer** sized strictly from `DataLength`.
2. It copies `Count * 0x4000` bytes from hive storage into that buffer.

If you can corrupt the cell so `DataLength < 16344 * (Count - 1)`, the copy **overruns the destination linearly** into adjacent paged-pool objects. A reliable exploit chain is:

1. Use the deterministic groom to place the vulnerable `_CM_KEY_VALUE` near controllable metadata.
2. Flip `DataLength` to a small number (e.g., 0x100) while leaving `_CM_BIG_DATA.Count` intact.
3. Pool-groom from user mode (pipes, ALPC ports, section objects) so a chosen object (like `EPROCESS->Token` owner or `SRVNET_BUFFER`) occupies the next chunk after the allocation from step 1.
4. Trigger a read (e.g., `RegQueryValueEx`, `NtQueryValueKey`) so `CmpGetValueData` copies all chunks and **overwrites the neighbor’s fields** with attacker-controlled data from the hive.
5. Use the corrupted kernel object to pivot to arbitrary read/write or direct SYSTEM token theft.

Because the overflow length equals `(Count * 0x4000) - DataLength`, you get a **precise byte budget** and full control over the bytes written, outperforming many driver-based pool overflows.

## Inter-hive linear overflows via tightly packed HBINs

Hives mounted by the Registry process are mapped in **2 MiB-aligned views** with **no guard gaps**. You can force two different hives to grow in lockstep until their `_HBIN` ranges touch:

1. Choose an attacker-writable hive (app hive or user hive) and a privileged target (e.g., `HKLM\SOFTWARE`).
2. Continuously create/delete `0x3FD8`-byte values in both hives. Each allocation adds a `0x4000`-byte bin, so running both writers in parallel interleaves their bins in virtual memory (observed with `!process Registry` + `!vad`).
3. Once the final bin of the attacker hive sits immediately before an HBIN belonging to HKLM, use the hive corruption bug to **overflow out of the attacker hive**, smashing HBIN headers or cells inside HKLM.
4. With HKLM metadata under control you can:
- Stage a big-data inconsistency primitive directly in the privileged hive.
- Corrupt configuration data consumed by SYSTEM services before it ever leaves the kernel.

The absence of guard pages means a linear overwrite from an unprivileged hive can **directly corrupt SYSTEM-owned hive structures**, enabling data-only attacks or setting up the pool overflow described above inside HKLM/HKU.

## Operational tips

- Monitor hive placement with `!vad` (user-mode) and `!reg view` / `!pool` (kernel) to confirm adjacency before triggering the overflow.
- Cache writable HKLM paths discovered during enumeration so corruption primitives can be deployed quickly even after reboots.
- Combine hive grooming with standard pool feng shui (pipe pair freelists, `NtAllocateVirtualMemory` on `
Registry` process) to stabilize post-overflow primitives.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
