# Windows Registry Hive Exploitation Primitives

{{#include ../../banners/hacktricks-training.md}}

## Warum Hive-Korruption etwas Besonderes ist

Windows registry hives sind **memory-mapped `.regf` files**, die von einem custom allocator (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`) verwaltet werden. Der Allocator:

- **Randomisiert Zuweisungen nicht** – die Platzierung von Zellen hängt nur von Reihenfolge/Größe vorheriger Registry-API-Aufrufe ab, daher sind Layouts auf verschiedenen Hosts reproduzierbar.
- **Fehlt es an Integritätsprüfungen** – manuell veränderte Header-/Datenfelder werden von Kernel-Consumern (`Cmp*`-Routinen) und vom Registry-Prozess selbst vertraut.
- **Teilt den Adressraum mit privilegierten Hives** – in vielen Fällen werden von Angreifern kontrollierte Hives in denselben User-Mode-Adressbereich wie HKLM/HKU gemappt, was inter-hive overflows ermöglicht.

Das macht hive-basierte Speicherkorruptionsfehler (z. B. CVE-2023-23420 / CVE-2023-23423) besonders zuverlässig für LPE.

## Deterministische Layout-Gestaltung mit Registry-APIs

Da die Hive-Allokation deterministisch ist, kann man die Platzierung von Zellen rein über Win32 APIs groomen. Ein typischer Workflow ist:

1. **Reset des Ziel-Keys** (delete/recreate), sodass der Hive-Bin nur bekannte Zellen enthält.
2. **Vorhersagbare Zellenreihen allozieren** durch Erstellen von Values mit sorgfältig gewählten Größen:
- Key/value-Metadatenzellen sind Vielfache von 8 Bytes.
- Das Schreiben von `0x3FD8`-Byte-Values erzwingt eine frische `0x4000`-Byte-Bin (`0x3FD8` data + `_HBIN` header/padding), ideal zum späteren Ineinanderlegen von Bins.
3. **Resize-freundliche Typen verwenden** (z. B. `REG_BINARY`), sodass einzelne Zellen einfach durch Aufruf von `RegSetValueEx` mit unterschiedlichen Längen freigegeben/erweitert werden können.
4. **Die Reihenfolge aufzeichnen** der Operationen (create/delete/resize). Das Reproduzieren dieser Abfolge erzeugt auf anderen Systemen dasselbe Layout, weil der Allocator keine Randomness hat.

<details>
<summary>Beispiel Layout-Shaper (vereinfachtes C)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Sobald ein corruption primitive (overwrite/fill) verfügbar ist, garantiert das groom, dass die **target cell resides next to the sprayed holes**, wodurch präzise overwrites ohne heap spraying möglich werden.

## Nur-API-Zugriff auf privilegierte hives über falsch konfigurierte untergeordnete Schlüssel

Windows bewertet nur die **ACL auf der letzten Komponente** eines Registry-Pfads. Wenn irgendein untergeordneter Schlüssel unter HKLM/HKU `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY` oder `WRITE_DAC` an niedrig privilegierte Benutzer gewährt, kann man ihn erreichen, selbst wenn alle übergeordneten Schlüssel gesperrt sind. Project Zero found **>1000 such writable keys in HKLM on Windows 11**, einschließlich langlebiger Einträge wie `HKLM\SOFTWARE\Microsoft\DRM` und mehrere `HKLM\SYSTEM`-Zweige.

Praktische Enumerierungsstrategie:

1. Aus einem erhöhten Kontext `\Registry\Machine` und `\Registry\User` durchlaufen und den Sicherheitsdeskriptor jedes Schlüssels dumpen. Speichere Einträge, deren DACL unprivilegierten SIDs Zugriff gewährt.
2. Als normaler Benutzer `RegOpenKeyEx` mit `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` gegen die aufgezeichneten Pfade versuchen. Erfolgreiche Opens sind verwertbare Ziele für hive corruption bugs, die angreifer-kontrollierte Daten in system hives benötigen.
3. Pflege einen Cache geöffneter Handles zu **stabilen schreibbaren Speicherorten**, damit PoCs korrupte Metadaten direkt bereitstellen können.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Sobald ein solcher Pfad bekannt ist, benötigt der Exploit niemals Offline-Manipulationen an Hives — **standard registry APIs are enough** — um die korrupten Zellen in privilegierten Hives zu platzieren, die von SYSTEM‑Diensten verwendet werden.

## Missbrauch von Hives zwischen Benutzern via `HKCU\Software\Microsoft\Input\TypingInsights`

Jede Benutzer‑Hive enthält `HKCU\Software\Microsoft\Input\TypingInsights`, dessen ACL `KEY_ALL_ACCESS` für **Everyone (S-1-1-0)** gewährt. Bis Microsoft das einschränkt, kann jeder Benutzer:

- Die Hive eines anderen Benutzers bis zum 2 GiB‑Limit füllen, was zu Anmeldefehlern oder zur erzwungenen Hive‑Trunkation führt (nützlich, um allocator‑Verhalten zu beeinflussen oder DoS).
- Korrupte Zellen in die `NTUSER.DAT` anderer Benutzer ablegen, um lateral exploits vorzubereiten, die ausgelöst werden, wenn ein betroffenes Prozess den kompromittierten Key liest.
- Differencing hives für sandboxed apps verändern, die auf per‑user overlay hives setzen, sodass sie bösartige Metadaten konsumieren.

Das macht Hive‑Korruptions‑Vulnerabilities für **lateral movement** relevant, nicht nur für eine Erhöhung innerhalb desselben Kontos.

## Umwandlung von Metadaten‑Korruption in paged pool overflows

Große Registry‑Werte werden in `_CM_BIG_DATA`‑Records gespeichert:

- `_CM_KEY_VALUE.DataLength` enthält die logische Größe. Sein höchstes Bit zeigt an, ob die Nutzlast im Cell liegt oder in Big‑Data‑Speicherung.
- `_CM_BIG_DATA.Count` zählt **16 KiB chunks** (16384 bytes minus metadata), die über eine Chunk‑Tabelle referenziert werden.

Wenn eine Komponente `CmpGetValueData` aufruft:

1. Der Kernel allokiert einen **paged pool buffer**, dessen Größe strikt aus `DataLength` abgeleitet wird.
2. Er kopiert `Count * 0x4000` bytes aus der Hive‑Speicherung in diesen Buffer.

Wenn du die Zelle so korrumpieren kannst, dass `DataLength < 16344 * (Count - 1)`, überläuft der Kopiervorgang **linear das Ziel** in angrenzende paged‑pool‑Objekte. Eine zuverlässige Exploit‑Kette ist:

1. Verwende das deterministic groom, um den verwundbaren `_CM_KEY_VALUE` in die Nähe kontrollierbarer Metadaten zu platzieren.
2. Setze `DataLength` auf eine kleine Zahl (z. B. 0x100), während `_CM_BIG_DATA.Count` unverändert bleibt.
3. Führe Pool‑groom aus dem User‑Modus durch (pipes, ALPC ports, section objects), sodass ein gewähltes Objekt (z. B. `EPROCESS->Token` owner oder `SRVNET_BUFFER`) den nächsten Chunk nach der Allokation aus Schritt 1 belegt.
4. Löse einen Lesevorgang aus (z. B. `RegQueryValueEx`, `NtQueryValueKey`), sodass `CmpGetValueData` alle Chunks kopiert und **die Felder des Nachbarn überschreibt** mit angreiferkontrollierten Daten aus der Hive.
5. Nutze das korrumpierte Kernel‑Objekt, um zu beliebigem read/write zu pivotieren oder direkten SYSTEM‑Token‑Diebstahl durchzuführen.

Da die Overflow‑Länge `(Count * 0x4000) - DataLength` entspricht, erhält man ein **präzises Byte‑Budget** und volle Kontrolle über die geschriebenen Bytes, wodurch viele driver‑basierte Pool‑Overflows übertroffen werden.

## Inter‑hive lineare Overflows via dicht gepackte HBINs

Von dem Registry‑Prozess gemountete Hives werden in **2 MiB‑ausgerichteten Views** ohne **no guard gaps** abgebildet. Man kann zwei verschiedene Hives dazu zwingen, synchron zu wachsen, bis ihre `_HBIN`‑Bereiche sich berühren:

1. Wähle eine angreifer‑beschreibbare Hive (app hive oder user hive) und ein privilegiertes Ziel (z. B. `HKLM\SOFTWARE`).
2. Erzeuge/entferne fortlaufend `0x3FD8`‑Byte‑Werte in beiden Hives. Jede Allokation fügt ein `0x4000`‑Byte‑Bin hinzu, sodass das gleichzeitige Ausführen beider Writer ihre Bins im virtuellen Speicher ineinander verschachtelt (beobachtbar mit `!process Registry` + `!vad`).
3. Sitzt das letzte Bin der Angreifer‑Hive unmittelbar vor einem HBIN von HKLM, nutze den Hive‑Korruptions‑Bug, um **aus der Angreifer‑Hive heraus zu überlaufen**, und zerstöre HBIN‑Header oder Cells innerhalb von HKLM.
4. Mit unter Kontrolle gebrachtem HKLM‑Metadaten kannst du:
- Direkt in der privilegierten Hive eine big‑data‑Inkonsistenz‑Primitive platzieren.
- Konfigurationsdaten korrumpieren, die von SYSTEM‑Diensten konsumiert werden, bevor sie jemals den Kernel verlassen.

Das Fehlen von Guard‑Pages bedeutet, dass ein linearer Overwrite aus einer unprivilegierten Hive **direkt SYSTEM‑eigene Hive‑Strukturen korrumpieren** kann, wodurch datenbasierte Angriffe möglich werden oder das oben beschriebene Pool‑Overflow innerhalb von HKLM/HKU vorbereitet wird.

## Betriebliche Tipps

- Überwache die Hive‑Platzierung mit `!vad` (User‑Mode) und `!reg view` / `!pool` (Kernel), um die Adjazenz zu bestätigen, bevor du den Overflow auslöst.
- Speichere beschreibbare HKLM‑Pfade, die während der Enumeration entdeckt wurden, damit Korruptions‑Primitiven auch nach Reboots schnell eingesetzt werden können.
- Kombiniere Hive‑Grooming mit standardmäßiger pool feng shui (pipe pair freelists, `NtAllocateVirtualMemory` im `Registry`‑Prozess), um Post‑Overflow‑Primitiven zu stabilisieren.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
