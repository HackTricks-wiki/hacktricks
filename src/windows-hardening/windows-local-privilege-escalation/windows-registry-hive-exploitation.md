# Windows Registry Hive Exploitation Primitives

{{#include ../../banners/hacktricks-training.md}}

## Zašto je korupcija hive-a posebna

Windows registry hives su **memory-mapped `.regf` fajlovi** koje upravlja custom allocator (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`). Allocator:

- **Ne nasumično raspoređuje alokacije** – pozicioniranje ćelija zavisi samo od redosleda/veličine prethodnih poziva registry API-ja, pa su rasporedi reproducibilni na različitim hostovima.
- **Nema provere integriteta** – ručno izmenjena header/data polja se veruju od strane kernel potrošača (`Cmp*` rutine) i samog Registry procesa.
- **Deli adresni prostor sa privilegovanim hive-ovima** – u mnogim slučajevima hives pod kontrolom napadača mapiraju se u isti user-mode adresni opseg kao HKLM/HKU hive-ovi, omogućavajući inter-hive overflove.

Zbog toga su propusti memorijske korupcije zasnovani na hive-ovima (npr. CVE-2023-23420 / CVE-2023-23423) posebno pouzdani za LPE.

## Determinističko oblikovanje rasporeda pomoću registry API-ja

Pošto je alokacija u hive-u deterministička, možete oblikovati pozicioniranje ćelija isključivo preko Win32 APIs. Tipičan tok poslova je:

1. **Resetuj ciljni ključ** (delete/recreate) tako da hive bin sadrži samo poznate ćelije.
2. **Alociraj predvidive nizove ćelija** kreiranjem vrednosti sa pažljivo izabranim veličinama:
- Key/value metadata ćelije su višekratnici od 8 bajtova.
- Pisanje `0x3FD8`-bajt vrednosti prisiljava svež `0x4000`-bajt bin (`0x3FD8` data + `_HBIN` header/padding), idealno za kasnije preplitanje bin-ova.
3. **Koristi tipove koji se lako resize-uju** (npr. `REG_BINARY`) tako da možete osloboditi/produžiti pojedinačne ćelije jednostavnim pozivom `RegSetValueEx` sa različitim dužinama.
4. **Zabeleži sekvencu** operacija (create/delete/resize). Reprodukcija te sekvence ponovo generiše isti raspored na drugim sistemima jer allocator nema nasumičnost.

<details>
<summary>Primer oblikovača rasporeda (pojednostavljen C)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Kada je dostupan corruption primitive (overwrite/fill), groom garantuje da se **target cell resides next to the sprayed holes**, omogućavajući precizna prepisivanja bez heap spraying-a.

## API-only pristup privilegovanim hives preko pogrešno konfigurisanih potomaka

Windows procenjuje samo **ACL on the final component** putanje registra. Ako bilo koji potomak ispod HKLM/HKU dodeli `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY` ili `WRITE_DAC` niskoprivilegovanim korisnicima, možete mu pristupiti čak i kada su svi roditeljski ključevi zaključani. Project Zero je pronašao **>1000 such writable keys in HKLM on Windows 11**, uključujući dugotrajne unose kao što su `HKLM\SOFTWARE\Microsoft\DRM` i nekoliko grana `HKLM\SYSTEM`.

Praktična strategija enumeracije:

1. Iz povišenog konteksta, prođite kroz `\Registry\Machine` i `\Registry\User`, dump-ujte security descriptor svakog ključa. Sačuvajte stavke čiji DACL dozvoljava neprivilegovanim SIDs.
2. Kao običan korisnik, pokušajte `RegOpenKeyEx` sa `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` nad zabeleženim putanjama. Uspesna otvaranja su pogodni ciljevi za hive corruption bugs koji zahtevaju podatke kontrolisane od napadača u sistemskim hives.
3. Održavajte keš otvorenih handles ka **stable writable locations** tako da PoCs mogu direktno da deploy-uju corrupted metadata.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Kada je takav put poznat, exploit više ne zahteva offline manipulaciju hive-om — **standard registry APIs su dovoljni** da se postave korumpirane ćelije unutar privilegovanih hive-ova koje koriste SYSTEM servisi.

## Zloupotreba hive-a između korisnika preko `HKCU\Software\Microsoft\Input\TypingInsights`

Svaka korisnička hive sadrži `HKCU\Software\Microsoft\Input\TypingInsights`, čiji ACL dodeljuje `KEY_ALL_ACCESS` za **Everyone (S-1-1-0).** Dok Microsoft to ne učvrsti, bilo koji korisnik može:

- **Popuniti hive drugog korisnika** do limita od 2 GiB, prouzrokujući greške pri logovanju ili prisiljavajući skraćivanje hive-a (korisno za navođenje ponašanja allocator-a ili DoS).
- **Ubaciti korumpirane ćelije** u `NTUSER.DAT` drugih korisnika, pripremajući lateralne exploite koji se aktiviraju kada žrtvin proces pročita kompromitovani ključ.
- **Izmeniti differencing hive-ove** za sandboxed aplikacije koje se oslanjaju na per-user overlay hive-ove, prisiljavajući ih da učitaju maliciozne metapodatke.

Ovo čini ranjivosti korupcije hive-a primenljivim za **lateral movement**, a ne samo za eskalaciju privilegija unutar istog naloga.

## Pretvaranje korupcije metapodataka u paged pool overflows

Velike registry vrednosti se čuvaju u `_CM_BIG_DATA` zapisima:

- `_CM_KEY_VALUE.DataLength` drži logičku veličinu. Njegov visoki bit ukazuje da li payload živi unutar ćelije ili u big-data skladištu.
- `_CM_BIG_DATA.Count` broji **16 KiB chunks** (16384 bajtova minus metapodaci) referencirane preko chunk tabele.

Kada bilo koja komponenta pozove `CmpGetValueData`:

1. Kernel alocira **paged pool buffer** čija veličina se strogo određuje iz `DataLength`.
2. Kopira `Count * 0x4000` bajtova iz hive skladišta u taj buffer.

Ako možete korumpirati ćeliju tako da `DataLength < 16344 * (Count - 1)`, kopiranje linearno prepisuje susedne paged-pool objekte. Pouzdan exploit lanac je:

1. Koristite deterministic groom da postavite ranjivi `_CM_KEY_VALUE` blizu kontrolisanih metapodataka.
2. Promenite `DataLength` na mali broj (npr. 0x100) dok `_CM_BIG_DATA.Count` ostane netaknut.
3. Pool-groom iz user mode-a (pipes, ALPC ports, section objects) tako da izabrani objekat (npr. vlasnik `EPROCESS->Token` ili `SRVNET_BUFFER`) zauzme sledeći chunk nakon alokacije iz koraka 1.
4. Pokrenite read (npr. `RegQueryValueEx`, `NtQueryValueKey`) tako da `CmpGetValueData` kopira sve chunke i **prepiše polja suseda** podacima koje napadač kontroliše iz hive-a.
5. Iskoristite korumpirani kernel objekat da pivotirate na proizvoljno čitanje/pisanje ili direktno krađu SYSTEM tokena.

Pošto dužina overflow-a iznosi `(Count * 0x4000) - DataLength`, dobijate **precizni budžet bajtova** i potpunu kontrolu nad upisanim bajtovima, nadmašujući mnoge driver-bazirane pool overflows.

## Inter-hive linear overflows preko gusto raspoređenih HBIN-ova

Hive-ovi montirani od strane Registry procesa mapirani su u **2 MiB-aligned views** bez **guard gaps**. Možete primorati dve različite hive da rastu u istom ritmu dok se njihovi `_HBIN` opsezi ne dotaknu:

1. Odaberite hive u koji napadač može pisati (app hive ili user hive) i privilegovani cilj (npr. `HKLM\SOFTWARE`).
2. Kontinuirano kreirajte/brisite `0x3FD8`-bait vrednosti u oba hive-a. Svaka alokacija dodaje `0x4000`-bait bin, tako da pokretanje oba writer-a paralelno isprepliće njihove bin-ove u virtuelnoj memoriji (uočeno sa `!process Registry` + `!vad`).
3. Kada se poslednji bin attacker hive-a nađe neposredno pre HBIN-a koji pripada HKLM, iskoristite bug korupcije hive-a da **prelivate iz attacker hive-a**, rušeći HBIN zaglavlja ili ćelije unutar HKLM.
4. Sa HKLM metapodacima pod kontrolom možete:
   - Postaviti big-data inconsistency primitive direktno u privilegovani hive.
   - Korumpirati konfiguracione podatke koje koriste SYSTEM servisi pre nego što uopšte napuste kernel.

Odsustvo guard pages znači da linearno prepisivanje iz neprivilegovanog hive-a može **direktno korumpirati hive strukture u vlasništvu SYSTEM-a**, omogućavajući data-only attacks ili postavljanje pool overflow-a opisanog gore unutar HKLM/HKU.

## Operativni saveti

- Pratite pozicioniranje hive-a sa `!vad` (user-mode) i `!reg view` / `!pool` (kernel) da potvrdite susedstvo pre pokretanja overflow-a.
- Keširajte writable HKLM putanje otkrivene tokom enumeracije tako da korupcioni primitive mogu biti brzo raspoređene čak i posle reboot-ova.
- Kombinujte hive grooming sa standardnim pool feng shui (pipe pair freelists, `NtAllocateVirtualMemory` na `Registry` procesu) da stabilizujete post-overflow primitive.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
