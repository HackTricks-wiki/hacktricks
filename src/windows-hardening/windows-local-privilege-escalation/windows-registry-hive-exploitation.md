# Primitivas de explotación de Windows Registry Hive

{{#include ../../banners/hacktricks-training.md}}

## Por qué la corrupción de hives es especial

Windows registry hives son **archivos `.regf` mapeados en memoria** gestionados por un allocator personalizado (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`). El allocator:

- **Does not randomize allocations** – la colocación de celdas depende sólo del orden/tamaño de llamadas previas a registry API, por lo que los layouts son reproducibles entre hosts.
- **Lacks integrity checks** – los campos de header/data alterados manualmente son confiables por los consumidores del kernel (`Cmp*` routines) y por el proceso Registry mismo.
- **Shares address space with privileged hives** – en muchos casos los hives controlados por el atacante se mapean en el mismo rango de direcciones de user-mode que los hives HKLM/HKU, permitiendo inter-hive overflows.

Esto hace que los bugs de corrupción de memoria basados en hives (p. ej., CVE-2023-23420 / CVE-2023-23423) sean excepcionalmente fiables para LPE.

## Deterministic layout grooming with registry APIs

Como la allocation de hives es determinista, puedes groomear la colocación de celdas puramente vía Win32 APIs. Un flujo típico es:

1. **Reset the target key** (delete/recreate) para que el hive bin contenga sólo celdas conocidas.
2. **Allocate predictable runs of cells** creando values con tamaños cuidadosamente seleccionados:
- Las celdas de metadata de key/value son múltiplos de 8 bytes.
- Escribir valores de `0x3FD8` bytes fuerza un nuevo bin de `0x4000` bytes (`0x3FD8` data + `_HBIN` header/padding), ideal para intercalar bins más tarde.
3. **Use resize-friendly types** (p. ej., `REG_BINARY`) para que puedas free/extend celdas individuales simplemente llamando a `RegSetValueEx` con longitudes diferentes.
4. **Record the sequence** de operaciones (create/delete/resize). Reproducirla reproduce el mismo layout en otros sistemas porque el allocator no tiene aleatoriedad.

<details>
<summary>Example layout shaper (simplified C)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Una vez que se dispone de una corruption primitive (overwrite/fill), el groom garantiza que la **target cell resides next to the sprayed holes**, permitiendo sobrescrituras precisas sin heap spraying.

## API-only access to privileged hives via misconfigured descendants

Windows solo evalúa la **ACL en el componente final** de una ruta de registro. Si algún descendiente bajo HKLM/HKU concede `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY` o `WRITE_DAC` a usuarios de bajo privilegio, puedes acceder a él incluso cuando todas las claves padre están bloqueadas. Project Zero encontró **>1000 de estas claves escribibles en HKLM en Windows 11**, incluyendo entradas de larga duración como `HKLM\SOFTWARE\Microsoft\DRM` y varias ramas de `HKLM\SYSTEM`.

Estrategia de enumeración práctica:

1. Desde un contexto elevado, recorre `\Registry\Machine` y `\Registry\User`, volcando el security descriptor de cada clave. Almacena los elementos cuya DACL permita SIDs no privilegiados.
2. Como usuario normal, intenta `RegOpenKeyEx` con `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` sobre las rutas registradas. Las aperturas exitosas son objetivos viables para bugs de hive corruption que requieren datos controlados por el atacante en system hives.
3. Mantén una caché de open handles a **ubicaciones escribibles estables** para que los PoCs puedan desplegar directamente metadatos corrompidos.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Una vez conocido dicho camino, el exploit ya no necesita manipular hives sin conexión—**las APIs estándar del registry son suficientes** para colocar las celdas corruptas dentro de hives privilegiados utilizados por servicios SYSTEM.

## Abuso de hive entre usuarios vía `HKCU\Software\Microsoft\Input\TypingInsights`

Cada hive de usuario contiene `HKCU\Software\Microsoft\Input\TypingInsights`, cuyo ACL otorga `KEY_ALL_ACCESS` a **Everyone (S-1-1-0).** Hasta que Microsoft lo corrija, cualquier usuario puede:

- **Llenar el hive de otro usuario** hasta el límite de 2 GiB, provocando fallos de inicio de sesión o forzando la truncación del hive (útil para coaccionar el comportamiento del allocator o DoS).
- **Introducir celdas corruptas** en el `NTUSER.DAT` de otros usuarios, preparando exploits laterales que se disparan cuando el proceso víctima lee la clave comprometida.
- **Modificar differencing hives** para apps sandboxed que dependen de hives de overlay por usuario, forzándolas a consumir metadata maliciosa.

Esto hace que las vulnerabilidades de corrupción de hives sean aplicables al **lateral movement**, no solo a la elevación dentro de la misma cuenta.

## Convertir la corrupción de metadata en overflows del paged pool

Los valores grandes del registry se almacenan en registros `_CM_BIG_DATA`:

- `_CM_KEY_VALUE.DataLength` contiene el tamaño lógico. Su bit alto indica si el payload reside dentro de la celda o en el almacenamiento de big-data.
- `_CM_BIG_DATA.Count` cuenta **chunks de 16 KiB** (16384 bytes menos metadata) referenciados mediante una tabla de chunks.

Cuando cualquier componente llama a `CmpGetValueData`:

1. El kernel asigna un **paged pool buffer** cuyo tamaño se calcula estrictamente a partir de `DataLength`.
2. Copia `Count * 0x4000` bytes desde el almacenamiento del hive a ese buffer.

Si puedes corromper la celda de forma que `DataLength < 16344 * (Count - 1)`, la copia **desborda linealmente el destino** hacia objetos adyacentes del paged-pool. Una cadena de explotación fiable es:

1. Usar el groom determinista para colocar el `_CM_KEY_VALUE` vulnerable cerca de metadata controlable.
2. Cambiar `DataLength` a un número pequeño (p.ej., 0x100) dejando `_CM_BIG_DATA.Count` intacto.
3. Hacer pool-groom desde user mode (pipes, ALPC ports, section objects) de modo que un objeto elegido (como el dueño de `EPROCESS->Token` o un `SRVNET_BUFFER`) ocupe el siguiente chunk tras la asignación del paso 1.
4. Provocar una lectura (p.ej., `RegQueryValueEx`, `NtQueryValueKey`) para que `CmpGetValueData` copie todos los chunks y **sobreescriba los campos del vecino** con datos controlados por el atacante extraídos del hive.
5. Usar el objeto kernel corrupto para pivotar a lectura/escritura arbitraria o robo directo del token SYSTEM.

Como la longitud del overflow es `(Count * 0x4000) - DataLength`, obtienes un **presupuesto de bytes preciso** y control total sobre los bytes escritos, superando a muchos overflows de pool basados en drivers.

## Overflows lineales entre hives vía HBINs empaquetados estrechamente

Los hives montados por el Registry process se mapean en **vistas alineadas a 2 MiB** sin **guard gaps**. Puedes forzar que dos hives diferentes crezcan en sincronía hasta que sus rangos de `_HBIN` se toquen:

1. Elige un hive escribible por el atacante (app hive o user hive) y un objetivo privilegiado (p.ej., `HKLM\SOFTWARE`).
2. Crear/borrar continuamente valores de `0x3FD8` bytes en ambos hives. Cada asignación añade un bin de `0x4000` bytes, así que ejecutar ambos escritores en paralelo entrelaza sus bins en memoria virtual (observado con `!process Registry` + `!vad`).
3. Una vez que el bin final del hive atacante quede inmediatamente antes de un HBIN perteneciente a HKLM, usa el bug de corrupción de hive para **desbordar fuera del hive atacante**, destrozando headers de HBIN o celdas dentro de HKLM.
4. Con la metadata de HKLM bajo control puedes:
- Implantar una primitiva de inconsistencia de big-data directamente en el hive privilegiado.
- Corromper datos de configuración consumidos por servicios SYSTEM antes de que salgan del kernel.

La ausencia de guard pages significa que un overwrite lineal desde un hive no privilegiado puede **corromper directamente estructuras de hive propiedad de SYSTEM**, permitiendo ataques solo de datos o preparando el overflow de pool descrito arriba dentro de HKLM/HKU.

## Consejos operativos

- Monitoriza la colocación de hives con `!vad` (user-mode) y `!reg view` / `!pool` (kernel) para confirmar la adyacencia antes de desencadenar el overflow.
- Cachea rutas HKLM escribibles descubiertas durante la enumeración para que las primitivas de corrupción puedan desplegarse rápidamente incluso tras reinicios.
- Combina el hive grooming con el estándar pool feng shui (pipe pair freelists, `NtAllocateVirtualMemory` on `
Registry` process) para estabilizar las primitivas post-overflow.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
