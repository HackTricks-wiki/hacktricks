# Windows Registry Hive Sömürme Primitifleri

{{#include ../../banners/hacktricks-training.md}}

## Neden hive bozulması özeldir

Windows kayıt defteri hive'leri, özel bir hafıza ayırıcı tarafından yönetilen **bellek-eşlenmiş `.regf` dosyaları**dır (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`). Bu ayırıcı:

- **Tahsisleri rastgeleleştirmez** – hücre yerleşimi yalnızca önceki kayıt defteri API çağrılarının sıra/boyutuna bağlıdır, bu yüzden düzenler hostlar arasında yeniden üretilebilir.
- **Bütünlük kontrolleri yok** – elle değiştirilmiş üstbilgi/veri alanları kernel tüketicileri (`Cmp*` rutinleri) ve Registry işlemi tarafından güvenilir sayılır.
- **Ayrıcalıklı hivelerle adres alanını paylaşır** – birçok durumda saldırgan tarafından kontrol edilen hive'ler HKLM/HKU hive'leri ile aynı kullanıcı-modu adres aralığına eşlenir, bu da hive'lar arası taşma imkanı verir.

Bu, hive tabanlı bellek bozulması hatalarını (ör. CVE-2023-23420 / CVE-2023-23423) LPE için benzersiz derecede güvenilir kılar.

## Kayıt Defteri API'leri ile deterministik yerleşim şekillendirme

Hive tahsisi deterministik olduğundan, hücre yerleşimini tamamen Win32 API'leri aracılığıyla şekillendirebilirsiniz. Tipik bir iş akışı:

1. **Hedef anahtarı sıfırla** (sil/yeniden oluştur) böylece hive bin yalnızca bilinen hücreleri içerir.
2. **Öngörülebilir hücre dizilerini tahsis et** — dikkatle seçilmiş boyutlarda değerler oluşturarak:
- Anahtar/değer meta veri hücreleri 8 baytın katlarıdır.
- `0x3FD8` bayt değerler yazmak temiz bir `0x4000` baytlık bin zorlar (`0x3FD8` veri + `_HBIN` üstbilgisi/dolgusu), daha sonra binleri iç içe geçirmek için idealdir.
3. **Boyutlandırmaya uygun türler kullan** (örn. `REG_BINARY`) böylece farklı uzunluklarla `RegSetValueEx` çağırarak bireysel hücreleri serbest bırakabilir/uzatabilirsiniz.
4. **İşlem sırasını kaydet** (oluştur/sil/değiştir). Tekrar oynatmak aynı düzeni diğer sistemlerde yeniden üretir çünkü ayırıcı rastgelelik içermez.

<details>
<summary>Örnek düzen şekillendirici (basitleştirilmiş C)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Bir corruption primitive (overwrite/fill) kullanılabilir hale geldiğinde, groom, **target cell resides next to the sprayed holes** olmasını garanti eder; bu, heap spraying yapmadan hassas overwrite'lara olanak sağlar.

## API-only access to privileged hives via misconfigured descendants

Windows, bir registry yolunun yalnızca son bileşeni üzerindeki **ACL**'yi değerlendirir. HKLM/HKU altındaki herhangi bir descendant düşük ayrıcalıklı kullanıcılara `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY` veya `WRITE_DAC` veriyorsa, tüm üst anahtarlar kilitli olsa bile ona erişebilirsiniz. Project Zero, Windows 11'de HKLM içinde **>1000 such writable keys in HKLM on Windows 11** buldu; bunlar arasında uzun ömürlü girdiler olan `HKLM\SOFTWARE\Microsoft\DRM` ve birkaç `HKLM\SYSTEM` dalı yer alır.

Pratik tarama stratejisi:

1. Yükseltilmiş bir bağlamdan `\Registry\Machine` ve `\Registry\User` üzerinde gezerek her anahtarın security descriptor'ını dökün. DACL'si unprivileged SIDs'e izin veren öğeleri kaydedin.
2. Normal bir kullanıcı olarak, kaydedilen yollar üzerinde `RegOpenKeyEx`'i `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` ile deneyin. Başarılı açılışlar, system hives içinde attacker-controlled data gerektiren hive corruption bugs için uygun hedeflerdir.
3. PoC'ların doğrudan bozuk metadata'yı yerleştirebilmesi için **stable writable locations** için açık handle'ların bir önbelleğini tutun.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Once such a path is known, the exploit never needs offline hive tampering—**standard registry APIs are enough** to stage the corrupt cells inside privileged hives touched by SYSTEM services.

## `HKCU\Software\Microsoft\Input\TypingInsights` üzerinden kullanıcılar arası hive suistimali

Her kullanıcı hive'i `HKCU\Software\Microsoft\Input\TypingInsights` anahtarını içerir; bunun ACL'si **Everyone (S-1-1-0)** için `KEY_ALL_ACCESS` verir. Microsoft bunu sıkılaştırana kadar herhangi bir kullanıcı:

- Başka bir kullanıcının hive'ını 2 GiB sınırına kadar **doldurabilir**, oturum açma hatalarına veya hive'ın kesilmesine (allocator davranışını zorlamak veya DoS için kullanışlı) neden olabilir.
- Diğer kullanıcıların `NTUSER.DAT` dosyalarına **bozuk hücreler bırakabilir**, kurban sürecin zarar görmüş anahtarı okumasıyla tetiklenen lateral exploitler hazırlayabilir.
- Per-user overlay hive'larına güvenen sandbox edilmiş uygulamalar için **differencing hive'ları değiştirebilir**, onların kötü amaçlı metadata tüketmelerini sağlayabilir.

Bu, hive bozulması güvenlik açıklarını yalnızca aynı hesap içindeki yükseltme için değil, **lateral movement** için de uygulanabilir kılar.

## Metadata bozulmasını paged pool overflows'a dönüştürme

Büyük registry değerleri `_CM_BIG_DATA` kayıtlarında saklanır:

- `_CM_KEY_VALUE.DataLength` mantıksal boyutu tutar. Yüksek biti, payload'un hücre içinde mi yoksa big-data depolamada mı yaşadığını belirtir.
- `_CM_BIG_DATA.Count` chunk tablosu aracılığıyla referans verilen **16 KiB chunk**'ları (16384 byte eksi metadata) sayar.

Herhangi bir bileşen `CmpGetValueData` çağırdığında:

1. Kernel, `DataLength`'den katı şekilde türetilen bir **paged pool buffer** ayırır.
2. Hive depolamasından bu buﬀer'a `Count * 0x4000` byte kopyalanır.

Hücreyi bozup `DataLength < 16344 * (Count - 1)` olacak şekilde ayarlayabilirseniz, kopyalama hedefi doğrusal olarak **komşu paged-pool objelerine taşır**. Güvenilir bir exploit zinciri şöyle işler:

1. Deterministik groom ile savunmasız `_CM_KEY_VALUE`'yi kontrol edilebilir metadata yakınlarına yerleştirin.
2. `_CM_BIG_DATA.Count`'ı sağlam bırakırken `DataLength`'i küçük bir sayıya (ör. 0x100) çevirin.
3. Kullanıcı modundan pool-groom (pipe'lar, ALPC portları, section objeleri) yaparak seçilmiş bir objenin (ör. `EPROCESS->Token` sahibi veya `SRVNET_BUFFER`) adım 1'deki tahsisin hemen ardından gelen chunk'ta yer almasını sağlayın.
4. Bir okuma tetikleyin (ör. `RegQueryValueEx`, `NtQueryValueKey`) ki `CmpGetValueData` tüm chunk'ları kopyalasın ve hive içindeki saldırgan kontrollü verilerle **komşunun alanlarını ezsin**.
5. Bozulmuş kernel objesini kullanarak keyfi read/write'e ya da doğrudan SYSTEM token hırsızlığına pivot edin.

Overflow uzunluğu `(Count * 0x4000) - DataLength` olduğu için **kesin bir byte bütçesi** elde eder ve yazılan byte'lar üzerinde tam kontrol sahibi olursunuz; bu, birçok driver tabanlı pool overflow'tan daha üstün bir doğruluk sağlar.

## Sık paketlenmiş HBIN'ler aracılığıyla inter-hive lineer overflow'lar

Registry işlemi tarafından mount edilen hive'ler **2 MiB hizalı görünüm** (2 MiB-aligned views) içinde ve **koruyucu boşluk (guard gaps) olmadan** eşlenir. İki farklı hive'ın `_HBIN` aralıkları dokunana kadar birlikte büyümesini zorlayabilirsiniz:

1. Yazılabilir bir attacker hive (uygulama hive'ı veya kullanıcı hive'ı) ve ayrıcalıklı bir hedef (ör. `HKLM\SOFTWARE`) seçin.
2. Her iki hive'da sürekli olarak `0x3FD8`-byte değerler oluşturup silin. Her tahsis bir `0x4000`-byte bin ekler, bu yüzden her iki yazıcıyı paralel çalıştırmak sanal bellekte bin'lerin iç içe geçmesini sağlar (gözlemlendi: `!process Registry` + `!vad`).
3. Attacker hive'ın son bin'i HKLM'ye ait bir HBIN'in hemen önünde oturduğunda, hive bozulma hatasını kullanarak **attacker hive'dan taşma** yapın ve HKLM içindeki HBIN başlıklarını veya hücreleri parçalayın.
4. HKLM metadata kontrol altına alındığında şunları yapabilirsiniz:
- Privileged hive içinde doğrudan bir big-data tutarsızlığı primi sahneleyin.
- SYSTEM servisleri tarafından kernel'den çıkmadan önce tüketilen yapılandırma verilerini bozun.

Koruyucu sayfa yokluğu, ayrıcalıksız bir hive'dan gelen lineer bir overwrite'ın **doğrudan SYSTEM'e ait hive yapıları**nı bozabileceği anlamına gelir; bu da yalnızca veri-temelli saldırıları değil, yukarıda HKLM/HKU içinde tarif edilen pool overflow'u hazırlamayı da mümkün kılar.

## Operasyonel ipuçları

- Taşma tetiklemeden önce adjacency'yi doğrulamak için `!vad` (user-mode) ve `!reg view` / `!pool` (kernel) ile hive yerleşimini izleyin.
- Keşif sırasında bulunan yazılabilir HKLM yollarını önbelleğe alın ki bozulma primitifleri yeniden başlatmalardan sonra bile hızla dağıtılabilsin.
- Hive grooming'i standart pool feng shui ile (pipe pair freelists, `NtAllocateVirtualMemory` üzerinde `Registry` process) birleştirerek taşma sonrası primitifleri stabilize edin.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
