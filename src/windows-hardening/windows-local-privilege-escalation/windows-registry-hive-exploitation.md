# Primitive di sfruttamento delle hive del registro di Windows

{{#include ../../banners/hacktricks-training.md}}

## Perché la corruzione delle hive è speciale

Le hive del registro di Windows sono **file `.regf` mappati in memoria** gestiti da un allocator custom (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`). L'allocator:

- **Non randomizza le allocazioni** – il posizionamento delle celle dipende solo dall'ordine/dalla dimensione delle chiamate precedenti alle API del registro, quindi i layout sono riproducibili su più host.
- **Mancano controlli di integrità** – campi header/data modificati manualmente sono considerati attendibili dai consumer del kernel (`Cmp*` routines) e dallo stesso processo Registry.
- **Condivide lo spazio d'indirizzi con hive privilegiate** – in molti casi le hive controllate dall'attaccante vengono mappate nello stesso intervallo di indirizzi in user-mode delle hive HKLM/HKU, permettendo overflow inter-hive.

Questo rende i bug di corruzione della memoria basati sulle hive (e.g., CVE-2023-23420 / CVE-2023-23423) unicamente affidabili per LPE.

## Modellazione deterministica del layout con le API del registro

Poiché l'allocazione delle hive è deterministica, puoi modellare il posizionamento delle celle esclusivamente tramite le Win32 APIs. Un tipico flusso di lavoro è:

1. **Resettare la chiave target** (delete/recreate) in modo che il bin della hive contenga solo celle note.
2. **Allocare sequenze prevedibili di celle** creando valori con dimensioni accuratamente selezionate:
- Le celle di metadata di key/value sono multipli di 8 byte.
- Scrivere valori di `0x3FD8` byte forza un nuovo bin da `0x4000` byte (`0x3FD8` data + `_HBIN` header/padding), ideale per intercalare i bin in seguito.
3. **Usare tipi che supportano il resize** (e.g., `REG_BINARY`) in modo da poter liberare/estendere celle individuali semplicemente chiamando `RegSetValueEx` con lunghezze diverse.
4. **Registrare la sequenza** di operazioni (create/delete/resize). Eseguirla di nuovo riproduce lo stesso layout su altri sistemi perché l'allocator non ha casualità.

<details>
<summary>Esempio di layout shaper (C semplificato)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Una volta disponibile una primitive di corruzione (overwrite/fill), il groom garantisce che la **target cell si trovi accanto alle sprayed holes**, consentendo sovrascritture precise senza heap spraying.

## Accesso solo via API agli hives privilegiati tramite discendenti mal configurati

Windows valuta solo la **ACL sull'ultimo componente** di un percorso del registro. Se un qualsiasi discendente sotto HKLM/HKU concede `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY`, o `WRITE_DAC` ad utenti a basso privilegio, puoi raggiungerlo anche quando ogni chiave padre è bloccata. Project Zero ha trovato **>1000 such writable keys in HKLM on Windows 11**, incluse voci di lunga durata come `HKLM\SOFTWARE\Microsoft\DRM` e diverse branche di `HKLM\SYSTEM`.

Strategia pratica di enumerazione:

1. Da un contesto elevato, percorri `\Registry\Machine` e `\Registry\User`, scaricando il security descriptor di ogni chiave. Memorizza gli elementi la cui DACL consente SIDs non privilegiati.
2. Come utente normale, prova `RegOpenKeyEx` con `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` sui percorsi registrati. Aperture riuscite sono obiettivi validi per bug di corruzione degli hive che richiedono dati controllati dall'attaccante negli hive di sistema.
3. Mantieni una cache di handle aperti verso **posizioni scrivibili stabili** in modo che i PoCs possano distribuire direttamente metadati corrotti.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Una volta noto un tale percorso, l'exploit non ha più bisogno di manomissioni offline dell'hive—**standard registry APIs are enough** per posizionare le celle corrotte all'interno degli hive privilegiati toccati dai servizi SYSTEM.

## Cross-user hive abuse via `HKCU\Software\Microsoft\Input\TypingInsights`

Ogni hive utente contiene `HKCU\Software\Microsoft\Input\TypingInsights`, la cui ACL concede `KEY_ALL_ACCESS` a **Everyone (S-1-1-0).** Finché Microsoft non lo correggerà, qualsiasi utente può:

- Riempire l'hive di un altro utente fino al limite di 2 GiB, causando errori di accesso o forzando la troncatura dell'hive (utile per coercire il comportamento dell'allocator o per DoS).
- Inserire celle corrotte in altri `NTUSER.DAT`, predisponendo exploit laterali che si attivano quando il processo vittima legge la chiave compromessa.
- Modificare i differencing hives per app sandboxed che si basano su overlay hive per utente, costringendole a consumare metadata maligni.

Questo rende le vulnerabilità di corruzione degli hive applicabili al **lateral movement**, non solo all'elevazione di privilegi nello stesso account.

## Turning metadata corruption into paged pool overflows

Large registry values are stored in `_CM_BIG_DATA` records:

- `_CM_KEY_VALUE.DataLength` contains the logical size. Il suo bit alto indica se il payload risiede all'interno della cella o nello storage big-data.
- `_CM_BIG_DATA.Count` conta **chunk da 16 KiB** (16384 bytes meno metadata) referenziati tramite una tabella dei chunk.

When any component calls `CmpGetValueData`:

1. Il kernel alloca un **buffer del paged pool** la cui dimensione è determinata strettamente da `DataLength`.
2. Copia `Count * 0x4000` byte dallo storage dell'hive in quel buffer.

Se puoi corrompere la cella in modo che `DataLength < 16344 * (Count - 1)`, la copia **sovrascrive linearmente** la destinazione nei oggetti adiacenti del paged-pool. Una catena di exploit affidabile è:

1. Usare il deterministic groom per posizionare il vulnerabile `_CM_KEY_VALUE` vicino a metadata controllabili.
2. Modificare `DataLength` a un numero piccolo (es., 0x100) lasciando intatto `_CM_BIG_DATA.Count`.
3. Eseguire pool-groom da user mode (pipes, ALPC ports, section objects) in modo che un oggetto scelto (come il proprietario di `EPROCESS->Token` o `SRVNET_BUFFER`) occupi il chunk successivo dopo l'allocazione del passo 1.
4. Innescare una lettura (es., `RegQueryValueEx`, `NtQueryValueKey`) affinché `CmpGetValueData` copi tutti i chunk e **sovrascriva i campi del vicino** con dati controllati dall'attaccante provenienti dall'hive.
5. Usare l'oggetto kernel corrotto per pivotare verso read/write arbitrari o il furto diretto del token SYSTEM.

Poiché la lunghezza dell'overflow è `(Count * 0x4000) - DataLength`, ottieni un **preciso budget di byte** e il pieno controllo sui byte scritti, superando molti overflow del pool basati su driver.

## Inter-hive linear overflows via tightly packed HBINs

Gli hive montati dal processo Registry sono mappati in **2 MiB-aligned views** senza **guard gaps**. Puoi forzare due hive diverse a crescere in modo sincrono finché i loro range `_HBIN` non si toccano:

1. Scegliere un hive scrivibile dall'attaccante (app hive o user hive) e un target privilegiato (es., `HKLM\SOFTWARE`).
2. Creare/eliminare continuamente valori da `0x3FD8` byte in entrambi gli hive. Ogni allocazione aggiunge un bin da `0x4000` byte, quindi eseguire entrambi gli scrittori in parallelo intreccia i loro bin nella memoria virtuale (osservabile con `!process Registry` + `!vad`).
3. Una volta che il bin finale dell'hive dell'attaccante si trova immediatamente prima di un HBIN appartenente a HKLM, usare il bug di corruzione dell'hive per eseguire un overflow fuori dall'hive dell'attaccante, distruggendo header HBIN o celle all'interno di HKLM.
4. Con i metadata di HKLM sotto controllo puoi:
   - Allestire una primitiva di inconsistenza big-data direttamente nell'hive privilegiato.
   - Corrompere dati di configurazione consumati dai servizi SYSTEM prima che escano mai dal kernel.

L'assenza di pagine di guardia significa che una sovrascrittura lineare da un hive non privilegiato può **corrompere direttamente le strutture degli hive possedute da SYSTEM**, permettendo attacchi solo-dati o predisponendo l'overflow del pool descritto sopra all'interno di HKLM/HKU.

## Operational tips

- Monitorare il posizionamento degli hive con `!vad` (user-mode) e `!reg view` / `!pool` (kernel) per confermare l'adiacenza prima di innescare l'overflow.
- Mettere in cache i percorsi HKLM scrivibili scoperti durante l'enumerazione in modo che le primitive di corruzione possano essere dispiegate rapidamente anche dopo i reboot.
- Combina hive grooming con il classico pool feng shui (pipe pair freelists, `NtAllocateVirtualMemory` on `\nRegistry` process) per stabilizzare le primitive post-overflow.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
