# Windows 레지스트리 하이브 익스플로잇 프리미티브

{{#include ../../banners/hacktricks-training.md}}

## 왜 하이브 손상이 특별한가

Windows registry hives는 **메모리 매핑된 `.regf` 파일**이며 커스텀 할당자(`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`)로 관리됩니다. 이 할당자는:

- **할당을 무작위화하지 않는다** – 셀 배치는 이전 registry API 호출의 순서/크기에만 의존하므로 레이아웃은 호스트 간에 재현 가능합니다.
- **무결성 검사 없음** – 수동으로 변경된 헤더/데이터 필드는 커널 소비자(`Cmp*` 루틴)와 Registry 프로세스 자체에서 신뢰됩니다.
- **권한 있는 하이브와 주소 공간을 공유한다** – 많은 경우 공격자가 제어하는 하이브는 HKLM/HKU 하이브와 동일한 사용자 모드 주소 범위에 매핑되어 하이브 간 오버플로우를 가능하게 합니다.

이로 인해 하이브 기반 메모리 손상 취약점(예: CVE-2023-23420 / CVE-2023-23423)은 LPE에 대해 특히 신뢰할 수 있습니다.

## 레지스트리 API로 결정론적 레이아웃 조작

하이브 할당이 결정론적이기 때문에 순수하게 Win32 APIs만으로 셀 배치를 조작할 수 있습니다. 일반적인 워크플로우는:

1. **대상 키를 리셋한다** (삭제/재생성) — 하이브 빈이 알려진 셀만 포함하게 합니다.
2. **예측 가능한 셀 연속을 할당한다** by creating values with carefully selected sizes:
- 키/값 메타데이터 셀은 8바이트의 배수입니다.
- `0x3FD8`-바이트 값을 쓰면 새로운 `0x4000`-바이트 빈이 생성됩니다 (`0x3FD8` 데이터 + `_HBIN` 헤더/패딩), 이후 빈을 교차 배치하기에 이상적입니다.
3. **리사이즈 친화적 타입을 사용한다** (예: `REG_BINARY`) — 서로 다른 길이로 `RegSetValueEx`를 호출하는 것만으로 개별 셀을 해제/확장할 수 있습니다.
4. **작업 순서를 기록한다** (생성/삭제/리사이즈). 할당자에 무작위성이 없기 때문에 이를 재실행하면 다른 시스템에서도 동일한 레이아웃이 재현됩니다.

<details>
<summary>예제 레이아웃 셰이퍼 (단순화된 C)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

corruption primitive (overwrite/fill)이 사용 가능해지면, groom은 **타깃 셀이 sprayed holes 옆에 위치**하도록 보장하여 heap spraying 없이도 정밀한 덮어쓰기를 가능하게 합니다.

## API-only로 잘못 구성된 하위 키를 통해 특권 하이브에 접근하기

Windows는 레지스트리 경로의 **마지막 구성 요소의 ACL**만 평가합니다. HKLM/HKU 아래의 어떤 하위 키든 `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY`, 또는 `WRITE_DAC`를 낮은 권한 사용자에게 부여하면, 모든 부모 키가 잠겨 있어도 해당 키에 접근할 수 있습니다. Project Zero는 Windows 11의 HKLM에서 **이와 같은 쓰기 가능한 키가 >1000개 있음**을 발견했으며, `HKLM\SOFTWARE\Microsoft\DRM` 같은 장기 존재 항목과 여러 `HKLM\SYSTEM` 분기들이 포함됩니다.

실용적인 열거 전략:

1. 권한 상승된 컨텍스트에서 `\Registry\Machine`와 `\Registry\User`를 순회하며 각 키의 security descriptor를 덤프합니다. DACL이 unprivileged SIDs를 허용하는 항목을 저장하세요.
2. 일반 사용자 권한으로 기록한 경로들에 대해 `KEY_SET_VALUE|KEY_CREATE_SUB_KEY`로 `RegOpenKeyEx`를 시도합니다. 열기에 성공한 대상은 시스템 하이브에 공격자 제어 데이터를 필요로 하는 hive corruption 버그의 실험 대상이 됩니다.
3. PoCs가 손상된 메타데이터를 직접 배치할 수 있도록, 열린 핸들의 캐시를 **안정적인 쓰기 가능한 위치들**에 대해 유지하세요.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Once such a path is known, the exploit never needs offline hive tampering—**표준 레지스트리 API로 충분하다** to stage the corrupt cells inside privileged hives touched by SYSTEM services.

## Cross-user hive abuse via `HKCU\Software\Microsoft\Input\TypingInsights`

Every user hive contains `HKCU\Software\Microsoft\Input\TypingInsights`, whose ACL grants `KEY_ALL_ACCESS` to **Everyone (S-1-1-0).** Until Microsoft tightens it, any user can:

- **Fill another user’s hive** up to the 2 GiB limit, causing logon failures or forcing hive truncation (useful to coerce allocator behavior or DoS).
- **Drop corrupted cells** into other users’ `NTUSER.DAT`, setting up lateral exploits that trigger when the victim process reads the compromised key.
- **Modify differencing hives** for sandboxed apps that rely on per-user overlay hives, forcing them to consume malicious metadata.

This makes hive corruption vulnerabilities applicable to **lateral movement**, not just elevation within the same account.

## Turning metadata corruption into paged pool overflows

Large registry values are stored in `_CM_BIG_DATA` records:

- `_CM_KEY_VALUE.DataLength` holds the logical size. Its high bit indicates whether the payload lives inside the cell or in big-data storage.
- `_CM_BIG_DATA.Count` counts **16 KiB chunks** (16384 bytes minus metadata) referenced via a chunk table.

When any component calls `CmpGetValueData`:

1. The kernel allocates a **paged pool buffer** sized strictly from `DataLength`.
2. It copies `Count * 0x4000` bytes from hive storage into that buffer.

If you can corrupt the cell so `DataLength < 16344 * (Count - 1)`, the copy **overruns the destination linearly** into adjacent paged-pool objects. A reliable exploit chain is:

1. Use the deterministic groom to place the vulnerable `_CM_KEY_VALUE` near controllable metadata.
2. Flip `DataLength` to a small number (e.g., 0x100) while leaving `_CM_BIG_DATA.Count` intact.
3. Pool-groom from user mode (pipes, ALPC ports, section objects) so a chosen object (like `EPROCESS->Token` owner or `SRVNET_BUFFER`) occupies the next chunk after the allocation from step 1.
4. Trigger a read (e.g., `RegQueryValueEx`, `NtQueryValueKey`) so `CmpGetValueData` copies all chunks and **overwrites the neighbor’s fields** with attacker-controlled data from the hive.
5. Use the corrupted kernel object to pivot to arbitrary read/write or direct SYSTEM token theft.

Because the overflow length equals `(Count * 0x4000) - DataLength`, you get a **precise byte budget** and full control over the bytes written, outperforming many driver-based pool overflows.

## Inter-hive linear overflows via tightly packed HBINs

Hives mounted by the Registry process are mapped in **2 MiB-aligned views** with **no guard gaps**. You can force two different hives to grow in lockstep until their `_HBIN` ranges touch:

1. Choose an attacker-writable hive (app hive or user hive) and a privileged target (e.g., `HKLM\SOFTWARE`).
2. Continuously create/delete `0x3FD8`-byte values in both hives. Each allocation adds a `0x4000`-byte bin, so running both writers in parallel interleaves their bins in virtual memory (observed with `!process Registry` + `!vad`).
3. Once the final bin of the attacker hive sits immediately before an HBIN belonging to HKLM, use the hive corruption bug to **overflow out of the attacker hive**, smashing HBIN headers or cells inside HKLM.
4. With HKLM metadata under control you can:
- Stage a big-data inconsistency primitive directly in the privileged hive.
- Corrupt configuration data consumed by SYSTEM services before it ever leaves the kernel.

The absence of guard pages means a linear overwrite from an unprivileged hive can **directly corrupt SYSTEM-owned hive structures**, enabling data-only attacks or setting up the pool overflow described above inside HKLM/HKU.

## Operational tips

- Monitor hive placement with `!vad` (user-mode) and `!reg view` / `!pool` (kernel) to confirm adjacency before triggering the overflow.
- Cache writable HKLM paths discovered during enumeration so corruption primitives can be deployed quickly even after reboots.
- Combine hive grooming with standard pool feng shui (pipe pair freelists, `NtAllocateVirtualMemory` on `
Registry` process) to stabilize post-overflow primitives.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
