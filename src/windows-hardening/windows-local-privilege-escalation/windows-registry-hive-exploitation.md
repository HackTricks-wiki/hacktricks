# Windows Registry Hive Exploitation Primitives

{{#include ../../banners/hacktricks-training.md}}

## Why hive corruption is special

Windows registry hives are **memory-mapped `.regf` files** managed by a custom allocator (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`). The allocator:

- **Does not randomize allocations** – cell placement depends only on the order/size of prior registry API calls, so layouts are reproducible across hosts.
- **Lacks integrity checks** – manually altered header/data fields are trusted by kernel consumers (`Cmp*` routines) and by the Registry process itself.
- **Shares address space with privileged hives** – in many cases attacker-controlled hives are mapped into the same user-mode address range as HKLM/HKU hives, enabling inter-hive overflows.

This makes hive-based memory corruption bugs (e.g., CVE-2023-23420 / CVE-2023-23423) uniquely reliable for LPE.

## Deterministic layout grooming with registry APIs

Because hive allocation is deterministic, you can groom cell placement purely via Win32 APIs. A typical workflow is:

1. **Reset the target key** (delete/recreate) so the hive bin contains only known cells.
2. **Allocate predictable runs of cells** by creating values with carefully selected sizes:
- Key/value metadata cells are multiples of 8 bytes.
- Writing `0x3FD8`-byte values forces a fresh `0x4000`-byte bin (`0x3FD8` data + `_HBIN` header/padding), ideal for interleaving bins later.
3. **Use resize-friendly types** (e.g., `REG_BINARY`) so you can free/extend individual cells just by calling `RegSetValueEx` with different lengths.
4. **Record the sequence** of operations (create/delete/resize). Replaying it reproduces the same layout on other systems because the allocator has no randomness.

<details>
<summary>Exemple de mise en forme de la disposition (C simplifié)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

## Accès uniquement via l'API aux hives privilégiés via des descendants mal configurés

Windows n'évalue que l'**ACL sur le composant final** d'un chemin de registre. Si un descendant sous HKLM/HKU accorde `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY`, ou `WRITE_DAC` à des utilisateurs peu privilégiés, vous pouvez y accéder même si chaque clé parente est verrouillée. Project Zero a trouvé **>1000 clés modifiables dans HKLM sur Windows 11**, y compris des entrées de longue durée comme `HKLM\SOFTWARE\Microsoft\DRM` et plusieurs branches `HKLM\SYSTEM`.

Stratégie d'énumération pratique :

1. Depuis un contexte élevé, parcourez `\Registry\Machine` et `\Registry\User`, en exportant le descripteur de sécurité de chaque clé. Stockez les éléments dont le DACL autorise des SIDs non privilégiés.
2. En tant qu'utilisateur normal, tentez `RegOpenKeyEx` avec `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` sur les chemins enregistrés. Les ouvertures réussies sont des cibles exploitables pour des bugs de corruption de hive nécessitant des données contrôlées par l'attaquant dans les hives système.
3. Maintenez un cache de handles ouverts vers des **emplacements stables et modifiables** afin que les PoCs puissent déployer directement des métadonnées corrompues.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Une fois ce chemin connu, l'exploit n'a plus besoin de manipuler les hives hors ligne — **les API standard du Registry suffisent** pour placer les cellules corrompues à l'intérieur des hives privilégiés consultés par les services SYSTEM.

## Abus de hive entre utilisateurs via `HKCU\Software\Microsoft\Input\TypingInsights`

Chaque user hive contient `HKCU\Software\Microsoft\Input\TypingInsights`, dont l'ACL accorde `KEY_ALL_ACCESS` à **Everyone (S-1-1-0).** Tant que Microsoft ne resserre pas cela, n'importe quel utilisateur peut :

- **Remplir le hive d’un autre utilisateur** jusqu'à la limite de 2 GiB, provoquant des échecs de connexion ou forçant la troncation du hive (utile pour contraindre le comportement de l'allocator ou provoquer un DoS).
- **Insérer des cellules corrompues** dans le `NTUSER.DAT` d'autres utilisateurs, préparant des exploits latéraux qui se déclenchent lorsque le processus victime lit la clé compromise.
- **Modifier les differencing hives** pour des apps sandboxed qui s'appuient sur des overlay hives par utilisateur, les forçant à consommer des métadonnées malveillantes.

Cela rend les vulnérabilités de corruption de hive applicables au **lateral movement**, pas seulement à l'élévation au sein du même compte.

## Transformer la corruption de métadonnées en débordements du paged pool

Les grandes valeurs du registry sont stockées dans des enregistrements `_CM_BIG_DATA` :

- `_CM_KEY_VALUE.DataLength` contient la taille logique. Son bit de poids fort indique si le payload vit à l'intérieur de la cellule ou dans le stockage big-data.
- `_CM_BIG_DATA.Count` compte des **chunks de 16 KiB** (16384 bytes moins les métadonnées) référencés via une table de chunks.

Quand n'importe quel composant appelle `CmpGetValueData` :

1. Le kernel alloue un **buffer dans le paged pool** dimensionné strictement d'après `DataLength`.
2. Il copie `Count * 0x4000` bytes depuis le stockage du hive vers ce buffer.

Si vous pouvez corrompre la cellule de sorte que `DataLength < 16344 * (Count - 1)`, la copie **dépasse linéairement la destination** dans des objets adjacents du paged-pool. Une chaîne d'exploitation fiable est :

1. Utiliser le groom déterministe pour placer le `_CM_KEY_VALUE` vulnérable à proximité de métadonnées contrôlables.
2. Modifier `DataLength` pour une petite valeur (p.ex. 0x100) tout en laissant `_CM_BIG_DATA.Count` intact.
3. Pool-groom depuis le mode utilisateur (pipes, ALPC ports, section objects) de sorte qu'un objet choisi (comme le propriétaire du `EPROCESS->Token` ou `SRVNET_BUFFER`) occupe le chunk suivant après l'allocation de l'étape 1.
4. Déclencher une lecture (p.ex. `RegQueryValueEx`, `NtQueryValueKey`) pour que `CmpGetValueData` copie tous les chunks et **écrase les champs du voisin** avec des données contrôlées par l'attaquant depuis le hive.
5. Utiliser l'objet kernel corrompu pour pivoter vers des read/write arbitraires ou pour voler directement le token SYSTEM.

Puisque la longueur du overflow est `(Count * 0x4000) - DataLength`, vous obtenez un **budget d'octets précis** et un contrôle total sur les octets écrits, dépassant de nombreux débordements de pool basés sur des drivers.

## Débordements linéaires inter-hive via des HBINs densément empaquetés

Les hives montés par le process Registry sont mappés dans des vues **alignées sur 2 MiB** sans **gaps de guard**. Vous pouvez forcer deux hives différentes à croître en synchronisation jusqu'à ce que leurs plages `_HBIN` se touchent :

1. Choisir un hive écrivable par l'attaquant (app hive ou user hive) et une cible privilégiée (p.ex. `HKLM\SOFTWARE`).
2. Créer/supprimer en continu des valeurs de `0x3FD8` bytes dans les deux hives. Chaque allocation ajoute un bin de `0x4000` bytes, donc lancer les deux writers en parallèle entrelace leurs bins en mémoire virtuelle (observé avec `!process Registry` + `!vad`).
3. Une fois que le bin final du hive attaquant se situe immédiatement avant un HBIN appartenant à HKLM, utiliser le bug de corruption de hive pour **déborder hors du hive attaquant**, écrasant des headers HBIN ou des cellules à l'intérieur de HKLM.
4. Avec les métadonnées HKLM sous contrôle vous pouvez :
- Mettre en place une primitive d'inconsistance big-data directement dans le hive privilégié.
- Corrompre des données de configuration consommées par les services SYSTEM avant même qu'elles ne quittent le kernel.

L'absence de guard pages signifie qu'un overwrite linéaire depuis un hive non-privilégié peut **corrompre directement des structures de hive appartenant à SYSTEM**, permettant des attaques purement basées sur les données ou préparant le pool overflow décrit ci-dessus à l'intérieur de HKLM/HKU.

## Conseils opérationnels

- Surveiller le placement des hives avec `!vad` (user-mode) et `!reg view` / `!pool` (kernel) pour confirmer l'adjacence avant de déclencher le overflow.
- Mettre en cache les chemins HKLM écrivables découverts durant l'énumération afin que les primitives de corruption puissent être déployées rapidement même après des reboots.
- Combiner le grooming des hives avec le pool feng shui standard (pipe pair freelists, `NtAllocateVirtualMemory` sur le process `Registry`) pour stabiliser les primitives post-overflow.

## Références

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
