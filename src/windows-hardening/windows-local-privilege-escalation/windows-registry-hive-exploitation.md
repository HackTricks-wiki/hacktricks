# Windows Registry Hive Exploitation Primitives

{{#include ../../banners/hacktricks-training.md}}

## Kwa nini uharibifu wa hive ni maalum

Hives za Windows Registry ni **faili `.regf` zilizopangwa kwenye memory (memory-mapped)** zinazodhibitiwa na allocator maalum (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`). Allocator hilo:

- **Halirandomezi allocations** – nafasi za cells zinategemea tu mpangilio/ukubwa wa wito wa API za registry uliofanywa kabla, hivyo layouts zinarudishika kwa urahisi kati ya hosts.
- **Hakuna ukaguzi wa integriti** – vigezo vya header/data vilivyobadilishwa kwa mkono vinatambuliwa kama sahihi na kernel consumers (`Cmp*` routines) na pia na mchakato wa Registry.
- **Inashare address space na hives zilizo na privileges** – katika visa vingi hives zinazosimamiwa na mshambuliaji zimepangwa kwenye range ile ile ya user-mode kama HKLM/HKU hives, kuruhusu inter-hive overflows.

Hii inafanya bugs za memory corruption zinazotokana na hive (mfano, CVE-2023-23420 / CVE-2023-23423) kuwa za kuaminika kihususi kwa LPE.

## Deterministic layout grooming with registry APIs

Kwa kuwa allocation ya hive ni deterministic, unaweza kufanya grooming ya placement ya cells kwa kutumia tu Win32 APIs. Mwendo wa kawaida ni:

1. **Reset the target key** (delete/recreate) ili hive bin iwe na cells zinazojulikana pekee.
2. **Allocate predictable runs of cells** kwa kuunda values zenye sizes zilizochaguliwa kwa uangalifu:
- Key/value metadata cells ni multiples za 8 bytes.
- Kuandika `0x3FD8`-byte values kunalazimisha bin mpya ya `0x4000`-byte (`0x3FD8` data + `_HBIN` header/padding), nzuri kwa kuingiliana kwa bins baadaye.
3. **Use resize-friendly types** (mfano, `REG_BINARY`) ili uweze kufree/extend cells binafsi kwa kuitisha tu `RegSetValueEx` kwa lengths tofauti.
4. **Record the sequence** ya operations (create/delete/resize). Kuireplay hufanya layout ile ile ionekane kwenye mifumo mingine kwa sababu allocator haina randomness.

<details>
<summary>Mfano wa layout shaper (C iliyorahisishwa)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Mara tu corruption primitive (overwrite/fill) inapopatikana, groom inahakikisha kwamba **target cell resides next to the sprayed holes**, ikiruhusu precise overwrites bila heap spraying.

## API-only access to privileged hives via misconfigured descendants

Windows huangalia tu **ACL on the final component** ya registry path. Ikiwa descendant yoyote chini ya HKLM/HKU inampa `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY`, au `WRITE_DAC` watumiaji walio na ruhusa ndogo, unaweza kufikia hiyo hata pale parent key zote zikiwa zimefungwa. Project Zero iligundua **>1000 such writable keys in HKLM on Windows 11**, ikijumuisha entries za muda mrefu kama `HKLM\SOFTWARE\Microsoft\DRM` na matawi kadhaa ya `HKLM\SYSTEM`.

Mbinu ya vitendo ya kuorodhesha:

1. Kutoka kwa muktadha uliopandishwa, pitaa `\Registry\Machine` na `\Registry\User`, ukitoa nakala (dump) ya security descriptor ya kila key. Hifadhi vitu ambavyo DACL inaruhusu SIDs zisizo na ruhusa.
2. Kama mtumiaji wa kawaida, jaribu `RegOpenKeyEx` kwa `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` dhidi ya paths zilizorekodiwa. Ufunguzi unaofaulu ni malengo yanayowezekana kwa hive corruption bugs zinazohitaji data inayodhibitiwa na mwashambuliaji katika system hives.
3. Hifadhi cache ya open handles kwa **stable writable locations** ili PoCs ziweze kuweka moja kwa moja corrupted metadata.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Once such a path is known, the exploit never needs offline hive tampering—**standard registry APIs are enough** to stage the corrupt cells inside privileged hives touched by SYSTEM services.

## Ukatili wa hive kati ya watumiaji kupitia `HKCU\Software\Microsoft\Input\TypingInsights`

Kila user hive ina `HKCU\Software\Microsoft\Input\TypingInsights`, ambayo ACL yake inampa `KEY_ALL_ACCESS` kwa **Everyone (S-1-1-0).** Hadi Microsoft iweze kuifunga, mtumiaji yeyote anaweza:

- **Jaza hive ya mtumiaji mwingine** hadi kikomo cha 2 GiB, kusababisha kushindwa kuingia au kulazimisha kukatwa kwa hive (inayofaa kuhamasisha tabia ya allocator au DoS).
- **Achia seli zilizoharibika** ndani ya `NTUSER.DAT` za watumiaji wengine, kuandaa lateral exploits ambazo zinaanza pale mchakato wa mwathiriwa utakaposomea key iliyoharibiwa.
- **Badilisha differencing hives** za sandboxed apps zinazotegemea per-user overlay hives, kuwalazimisha watumie metadata hatarishi.

Hii inafanya hive corruption vulnerabilities zifae kwa **lateral movement**, si tu kwa elevation ndani ya akaunti ile ile.

## Kubadilisha metadata corruption kuwa paged pool overflows

Viwango vikubwa vya rejista vinahifadhiwa katika rekodi za `_CM_BIG_DATA`:

- `_CM_KEY_VALUE.DataLength` ina ukubwa wa kimantiki. Bit yake ya juu inaonyesha kama payload iko ndani ya cell au kwenye big-data storage.
- `_CM_BIG_DATA.Count` inaonyesha idadi ya **16 KiB chunks** (16384 bytes minus metadata) inayorejelewa kupitia jedwali la chunks.

Wakati kipengele chochote kinapoitisha `CmpGetValueData`:

1. Kernel hupanga buffer ya **paged pool buffer** ambayo ukubwa wake unategemea tu `DataLength`.
2. Inanakili `Count * 0x4000` bytes kutoka kuhifadhi hive hadi buffer hiyo.
3. Ikiwa unaweza kuharibu cell hivyo `DataLength < 16344 * (Count - 1)`, nakili hiyo **inavuka kikomo kwa mstari** hadi kwenye vitu vya paged-pool vinavyopakana. Mlolongo wa exploit wa kuaminika ni:
   1. Tumia deterministic groom ili kuweka `_CM_KEY_VALUE` dhaifu karibu na metadata inayoweza kudhibitiwa.
   2. Badilisha `DataLength` kuwa namba ndogo (mf., 0x100) ukiwaacha `_CM_BIG_DATA.Count` bila kubadilishwa.
   3. Pool-groom kutoka user mode (pipes, ALPC ports, section objects) ili kitu ulichochagua (kama `EPROCESS->Token` owner au `SRVNET_BUFFER`) kikitekeleza chunk inayofuata baada ya allocation ya hatua 1.
   4. Chochea kusoma (mf., `RegQueryValueEx`, `NtQueryValueKey`) ili `CmpGetValueData` inanakili chunks zote na **kuandika juu ya fields za jirani** kwa data inayodhibitiwa na mwandishi kutoka hive.
   5. Tumia kernel object iliyoharibika kuhamia kwa arbitrary read/write au kuiba token ya SYSTEM moja kwa moja.

Kwa sababu urefu wa overflow ni `(Count * 0x4000) - DataLength`, unapata **bajeti ya byte sahihi** na udhibiti kamili juu ya bytes zinazoandikwa, ukizidi uwezo wa overflows nyingi za pool zinazotokana na driver.

## Inter-hive linear overflows via tightly packed HBINs

Hives zilizo mount na mchakato wa Registry zimepangwa katika **2 MiB-aligned views** bila **no guard gaps**. Unaweza kulazimisha hives mbili tofauti kukua pamoja hadi ranges zao za `_HBIN` zifikie:

1. Chagua hive ambayo attacker anaweza kuandika (app hive au user hive) na lengo lenye hadhi (mf., `HKLM\SOFTWARE`).
2. Endelea kuunda/kuondoa values za `0x3FD8` bytes katika hives zote mbili. Kila allocation inaongeza `0x4000`-byte bin, hivyo kuendesha waandishi wote wawili sambamba kunachanganya bins zao katika virtual memory (kuonekana kwa `!process Registry` + `!vad`).
3. Mara bin ya mwisho ya attacker hive inapokuwa mara moja kabla ya HBIN inayomilikiwa na HKLM, tumia bug ya hive corruption ili **kufanya overflow kutoka attacker hive**, kubomoa HBIN headers au seli ndani ya HKLM.
4. Ukishokuwa umedhibiti metadata ya HKLM unaweza:
   - Kuweka primitive ya big-data inconsistency moja kwa moja ndani ya hive lenye hadhi.
   - Haribu data za usanidi zinazotumiwa na SYSTEM services kabla hata hazijaondoka kernel.

Kutokuwepo kwa guard pages kunamaanisha overwrite ya mstari kutoka hive isiyo na ruhusa inaweza **kuharibu moja kwa moja miundo ya hive inayomilikiwa na SYSTEM**, kuziwezesha mashambulio ya data pekee au kuandaa pool overflow iliyoelezwa hapo juu ndani ya HKLM/HKU.

## Vidokezo vya uendeshaji

- Fuatilia nafasi ya hive kwa `!vad` (user-mode) na `!reg view` / `!pool` (kernel) ili kuthibitisha ukaribu kabla ya kuchochea overflow.
- Hifadhi njia za writable HKLM zilizogunduliwa wakati wa enumeration ili corruption primitives ziweze kutumika haraka hata baada ya reboots.
- Changanya hive grooming na standard pool feng shui (pipe pair freelists, `NtAllocateVirtualMemory` kwenye `Registry` process) ili kutuliza primitives baada ya overflow.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
