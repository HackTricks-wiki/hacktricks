# Windows Registry Hive Exploitation Primitives

{{#include ../../banners/hacktricks-training.md}}

## Zašto je korupcija hive-a posebna

Windows registry hives su mapirane u memoriju `.regf` datoteke kojima upravlja prilagođeni alokator (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`). Alokator:

- **Ne randomizuje alokacije** – pozicioniranje ćelija zavisi samo od redosleda/veličine prethodnih registry API poziva, pa su rasporedi reproducibilni na različitim hostovima.
- **Nedostaju provere integriteta** – ručno izmenjena polja zaglavlja/podataka se prihvataju od strane kernel potrošača (`Cmp*` routines) i samog Registry procesa.
- **Deli adresni prostor sa privilegovanim hive-ovima** – u mnogim slučajevima hive-ovi pod kontrolom napadača su mapirani u isti adresni opseg user-mode-a kao HKLM/HKU hive-ovi, što omogućava inter-hive preliva.

To čini bugove bazirane na hive-ovima koji dovode do oštećenja memorije (npr. CVE-2023-23420 / CVE-2023-23423) posebno pouzdanim za LPE.

## Determinističko oblikovanje rasporeda pomoću registry API-ja

Pošto je alokacija hive-a deterministička, možete oblikovati pozicioniranje ćelija isključivo putem Win32 APIs. Tipičan workflow je:

1. **Reset the target key** (delete/recreate) tako da hive bin sadrži samo poznate ćelije.
2. **Allocate predictable runs of cells** kreiranjem vrednosti sa pažljivo izabranim veličinama:
- Key/value metadata ćelije su veličine koje su višekratnici od 8 bajtova.
- Pisanje `0x3FD8`-bajt vrednosti forsira novu `0x4000`-bajt bin (`0x3FD8` data + `_HBIN` header/padding), idealnu za naknadno međusobno isprepletanje bin-ova.
3. **Use resize-friendly types** (npr. `REG_BINARY`) tako da možete osloboditi/proširiti pojedinačne ćelije samo pozivom `RegSetValueEx` sa različitim dužinama.
4. **Record the sequence** operacija (create/delete/resize). Reprodukovanje te sekvence rekreira isti raspored na drugim sistemima zato što alokator ne koristi nasumičnost.

<details>
<summary>Primer oblikovača rasporeda (pojednostavljeni C)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Jednom kada je dostupan corruption primitive (overwrite/fill), groom garantuje da se **target cell resides next to the sprayed holes**, omogućavajući precizna prepisivanja bez heap spraying.

## API-only access to privileged hives via misconfigured descendants

Windows procenjuje samo **ACL on the final component** registry puta. Ako bilo koji descendant ispod HKLM/HKU dodeli `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY`, ili `WRITE_DAC` low-privileged korisnicima, možete mu pristupiti čak i kada su svi parent ključevi zaključani. Project Zero je našao **>1000 such writable keys in HKLM on Windows 11**, uključujući dugotrajne unose kao što su `HKLM\SOFTWARE\Microsoft\DRM` i nekoliko `HKLM\SYSTEM` grana.

Praktična strategija enumeracije:

1. Iz elevated konteksta, iterirajte `\Registry\Machine` i `\Registry\User`, dumping-ujte security descriptor svakog ključa. Sačuvajte stavke čiji DACL allows unprivileged SIDs.
2. Kao normalan korisnik, pokušajte `RegOpenKeyEx` sa `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` protiv snimljenih path-ova. Uspesni opens su validne mete za hive corruption bugs koje zahtevaju attacker-controlled podatke u system hives.
3. Održavajte cache otvorenih handles za **stable writable locations** tako da PoCs mogu direktno da deploy-uju corrupted metadata.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Once such a path is known, the exploit never needs offline hive tampering—**standard registry APIs are enough** to stage the corrupt cells inside privileged hives touched by SYSTEM services.

## Zloupotreba hive-a između korisnika preko `HKCU\Software\Microsoft\Input\TypingInsights`

Svaki korisnički hive sadrži `HKCU\Software\Microsoft\Input\TypingInsights`, čiji ACL dodeljuje `KEY_ALL_ACCESS` za **Everyone (S-1-1-0).** Dok Microsoft to ne učvrsti, bilo koji korisnik može:

- **Ispuniti hive drugog korisnika** do granice od 2 GiB, što može izazvati greške pri prijavljivanju ili prisiliti skraćivanje hive-a (korisno za prisiljavanje ponašanja allocator-a ili DoS).
- **Ubaciti korumpirane ćelije** u `NTUSER.DAT` drugih korisnika, postavljajući lateral exploits koji se aktiviraju kada proces žrtve pročita kompromitovani ključ.
- **Izmeniti differencing hives** za sandboxed apps koji se oslanjaju na per-user overlay hives, prisiljavajući ih da učitaju malicious metadata.

To čini ranjivosti u korupciji hive-a primenljivim za **lateral movement**, a ne samo za eskalaciju privilegija unutar istog naloga.

## Pretvaranje korupcije metapodataka u paged pool overflows

Velike registry vrednosti se čuvaju u `_CM_BIG_DATA` zapisima:

- `_CM_KEY_VALUE.DataLength` sadrži logičku veličinu. Njegov najviši bit označava da li payload živi unutar ćelije ili u big-data skladištu.
- `_CM_BIG_DATA.Count` broji **16 KiB chunks** (16384 bajta minus metapodaci) referencirane putem chunk table.

Kada bilo koja komponenta pozove `CmpGetValueData`:

1. Kernel alocira a **paged pool buffer** čija veličina je strogo određena iz `DataLength`.
2. Kopira `Count * 0x4000` bajtova iz hive skladišta u taj buffer.

Ako možete korumpirati ćeliju tako da `DataLength < 16344 * (Count - 1)`, kopija će **linearno prepisati destinaciju** u susedne paged-pool objekte. Pouzdan exploit lanac je:

1. Koristite deterministic groom da postavite ranjivi `_CM_KEY_VALUE` blizu kontrolisane metadata.
2. Promenite `DataLength` na mali broj (npr. 0x100) dok ostavljate `_CM_BIG_DATA.Count` netaknut.
3. Pool-groom iz user mode (pipes, ALPC ports, section objects) tako da izabrani objekat (kao `EPROCESS->Token` owner ili `SRVNET_BUFFER`) zauzme sledeći chunk nakon alokacije iz koraka 1.
4. Pokrenite čitanje (npr. `RegQueryValueEx`, `NtQueryValueKey`) da `CmpGetValueData` kopira sve chunke i **prepiše polja suseda** podacima kontrolisanim od strane napadača iz hive-a.
5. Iskoristite korumpirani kernel objekat da pivotirate ka proizvoljnom read/write ili direktnoj krađi SYSTEM token-a.

Pošto je dužina overflow-a jednaka `(Count * 0x4000) - DataLength`, dobijate **precizan budžet bajtova** i potpunu kontrolu nad upisanim bajtovima, nadmašujući mnoge driver-based pool overflows.

## Inter-hive linear overflows preko gusto upakovanih HBINs

Hive-ovi koje montira Registry process mapirani su u **2 MiB-aligned views** bez **no guard gaps**. Možete primorati dva različita hive-a da rastu sinhronizovano dok se njihovi `_HBIN` opsezi ne dodirnu:

1. Izaberite attacker-writable hive (app hive ili user hive) i privilegovani target (npr. `HKLM\SOFTWARE`).
2. Kontinuirano kreirajte/brisite `0x3FD8`-bajt vrednosti u oba hive-a. Svaka alokacija dodaje `0x4000`-bajt bin, tako da pokretanje oba pisca paralelno isprepliće njihove bin-ove u virtuelnoj memoriji (posmatrano sa `!process Registry` + `!vad`).
3. Kad konačni bin attacker hive-a sedne odmah pre HBIN-a koji pripada HKLM, upotrebite hive corruption bug da **overflownete iz attacker hive-a**, razbijajući HBIN headere ili ćelije unutar HKLM.
4. Sa HKLM metadata pod kontrolom možete:
- Postaviti big-data inconsistency primitive direktno u privilegovani hive.
- Korumpirati konfiguracione podatke koje SYSTEM services koriste pre nego što napuste kernel.

Nedostatak guard pages znači da linearni overwrite iz neprivilegovanog hive-a može **direktno korumpirati SYSTEM-owned hive strukture**, omogućavajući data-only napade ili postavljanje pool overflow-a opisanog gore unutar HKLM/HKU.

## Operativni saveti

- Pratite pozicioniranje hive-a sa `!vad` (user-mode) i `!reg view` / `!pool` (kernel) da potvrdite susedstvo pre pokretanja overflow-a.
- Keširajte writable HKLM putanje otkrivene tokom enumeration da bi corruption primitives mogli brzo da se primene čak i posle reboot-a.
- Kombinujte hive grooming sa standardnim pool feng shui (pipe pair freelists, `NtAllocateVirtualMemory` na `Registry` process) da stabilizujete post-overflow primitive.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
