# Windows Registry Hive Exploitation Primitives

{{#include ../../banners/hacktricks-training.md}}

## Neden hive bozulması özeldir

Windows registry hives, özel bir allocator (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`) tarafından yönetilen **bellek-haritalı `.regf` dosyaları**dır. Allocator:

- **Tahsisleri randomize etmez** – hücre yerleşimi sadece önceki registry API çağrılarının sırası/ boyutuna bağlıdır, bu yüzden düzenler hostlar arasında yeniden üretilebilir.
- **Bütünlük kontrolleri yoktur** – elle değiştirilen header/veri alanları kernel tüketicileri (`Cmp*` rutinleri) ve Registry işlemi tarafından güvenilir kabul edilir.
- **ayırt edilmiş hivelerle adres alanı paylaşır** – birçok durumda saldırgan kontrollü hiveler, HKLM/HKU hiveleriyle aynı user-mode adres aralığına map edilir, bu da hivelar arası overflowlara olanak tanır.

Bu, hive-tabanlı bellek bozulması açıklarını (ör. CVE-2023-23420 / CVE-2023-23423) LPE için benzersiz şekilde güvenilir kılar.

## Registry API'leri ile deterministik düzen hazırlama

Hive tahsisi deterministik olduğu için hücre yerleşimini sadece Win32 APIs kullanarak şekillendirebilirsiniz. Tipik bir iş akışı:

1. **Hedef anahtarı resetleyin** (sil/yeniden oluştur) böylece hive bin yalnızca bilinen hücreleri içerir.
2. **Öngörülebilir hücre dizileri tahsis edin** dikkatle seçilmiş boyutlarda değerler oluşturarak:
- Key/value metadata hücreleri 8 byte katlarıdır.
- `0x3FD8`-byte değerler yazmak taze bir `0x4000`-byte bin'i zorlar (`0x3FD8` veri + `_HBIN` header/dolgu), daha sonra bin'leri içiçe geçirmek için idealdir.
3. **Resize-dostu tipler kullanın** (örn. `REG_BINARY`) böylece farklı uzunluklarla `RegSetValueEx` çağırarak bireysel hücreleri serbest/kumarlayabilirsiniz.
4. **İşlem sırasını kaydedin** (oluştur/sil/yeniden boyutlandır). Aynı diziyi yeniden oynatmak, allocator'ın rastgelelik kullanmaması nedeniyle diğer sistemlerde aynı düzeni yeniden üretir.

<details>
<summary>Örnek düzen şekillendirici (basitleştirilmiş C)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Once a corruption primitive (overwrite/fill) is available, the groom guarantees that the **target cell resides next to the sprayed holes**, enabling precise overwrites without heap spraying.

## Yanlış yapılandırılmış alt anahtarlar aracılığıyla ayrıcalıklı hivelere sadece API erişimi

Windows yalnızca bir registry yolunun **son bileşenindeki ACL'yi** değerlendirir. Eğer HKLM/HKU altındaki herhangi bir descendant düşük ayrıcalıklı kullanıcılara `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY` veya `WRITE_DAC` veriyorsa, her ebeveyn anahtar kilitli olsa bile ona erişebilirsiniz. Project Zero, Windows 11'de HKLM içinde **>1000 böyle yazılabilir anahtar** buldu; uzun ömürlü girdiler arasında `HKLM\SOFTWARE\Microsoft\DRM` ve birkaç `HKLM\SYSTEM` dalı yer alıyor.

Pratik tarama stratejisi:

1. Yükseltilmiş bir bağlamdan, `\Registry\Machine` ve `\Registry\User` içinde dolaşarak her anahtarın güvenlik tanımlayıcısını dökün. DACL'si unprivileged SIDs'e izin veren öğeleri saklayın.
2. Normal bir kullanıcı olarak, kaydedilmiş path'lere karşı `RegOpenKeyEx`'i `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` ile deneyin. Başarılı açılışlar, sistem hivelarında attacker-controlled data gerektiren hive corruption bug'ları için uygun hedeflerdir.
3. PoC'lerin bozuk metadata'yı doğrudan dağıtabilmesi için açık handle'ların kararlı yazılabilir konumlara ait bir önbelleğini tutun.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Once such a path is known, the exploit never needs offline hive tampering—**standart registry API'leri yeterlidir** to stage the corrupt cells inside privileged hives touched by SYSTEM services.

## Cross-user hive abuse via `HKCU\Software\Microsoft\Input\TypingInsights`

Her kullanıcı hive'i `HKCU\Software\Microsoft\Input\TypingInsights` içerir; bu anahtarın ACL'si **Everyone (S-1-1-0)** için `KEY_ALL_ACCESS` verir. Microsoft bunu sıkılaştırana kadar herhangi bir kullanıcı şunları yapabilir:

- **Başka bir kullanıcının hive'ını** 2 GiB sınırına kadar doldurup oturum açma hatalarına veya hive'ın kırpılmasına (truncation) neden olabilir — allocator davranışını zorlamak veya DoS için kullanılabilir.
- Başka kullanıcıların `NTUSER.DAT` dosyalarına **bozulmuş hücreler** bırakıp, mağdur sürecin bozuk anahtarı okumasıyla tetiklenen lateral exploits hazırlayabilir.
- Per-user overlay hivelere güvenen sandboxed apps için differencing hiveları değiştirip onların zararlı metadata tüketmelerini sağlayabilir.

Bu, hive bozulması zafiyetlerini sadece aynı hesap içindeki elevation için değil, **lateral movement** için de uygulanabilir hale getirir.

## Turning metadata corruption into paged pool overflows

Büyük registry değerleri `_CM_BIG_DATA` kayıtlarında saklanır:

- `_CM_KEY_VALUE.DataLength` mantıksal boyutu tutar. Yüksek biti payload'un hücre içinde mi yoksa big-data depolamasında mı olduğunu gösterir.
- `_CM_BIG_DATA.Count` bir chunk tablosu aracılığıyla referans verilen **16 KiB chunk'ları** () sayar (16384 byte eksi metadata).

Herhangi bir bileşen `CmpGetValueData` çağırdığında:

1. Kernel, `DataLength`'den kesin boyutta bir **paged pool buffer** ayırır.
2. Hive depolamasından buffer'a `Count * 0x4000` byte kopyalar.

Eğer hücreyi bozup `DataLength < 16344 * (Count - 1)` olacak şekilde ayarlayabilirseniz, kopyalama hedefi doğrusal olarak **adjacent paged-pool nesnelerine** taşır. Güvenilir bir exploit zinciri:

1. Deterministik groom ile zayıf `_CM_KEY_VALUE`'yi kontrol edilebilir metadata'nın yanına yerleştirin.
2. `_CM_BIG_DATA.Count`'ı sağlam bırakıp `DataLength`'i küçük bir değere (ör. 0x100) çevirin.
3. Kullanıcı modu pool-groom (pipe'lar, ALPC portları, section objeleri) ile seçilmiş bir nesnenin (ör. `EPROCESS->Token` sahibi veya `SRVNET_BUFFER` gibi) adım 1'deki tahsisattan hemen sonraki chunk'ı işgal etmesini sağlayın.
4. Bir okuma tetikleyin (ör. `RegQueryValueEx`, `NtQueryValueKey`) böylece `CmpGetValueData` tüm chunk'ları kopyalar ve **komşunun alanlarını** hive'dan gelen saldırgan kontrollü verilerle ezerek överwriteler.
5. Bozulmuş kernel nesnesini arbitrary read/write'e pivotlamak veya doğrudan SYSTEM token hırsızlığı için kullanın.

Overflow uzunluğu `(Count * 0x4000) - DataLength` olduğundan, **kesin bir byte bütçesi** elde eder ve yazılan byte'lar üzerinde tam kontrol sağlarsınız; bu birçok driver tabanlı pool overflow'tan daha üstündür.

## Inter-hive linear overflows via tightly packed HBINs

Registry süreci tarafından mount edilen hivelar **2 MiB hizalı view'lar** içinde haritalanır ve **guard gap** yoktur. İki farklı hivenin `_HBIN` aralıkları dokunana kadar birlikte büyümesini zorlayabilirsiniz:

1. Yazılabilir bir attacker-hive (app hive veya user hive) ve ayrıcalıklı bir hedef (ör. `HKLM\SOFTWARE`) seçin.
2. Her iki hive'da da sürekli olarak `0x3FD8`-byte değerler oluşturup silin. Her tahsis bir `0x4000`-byte bin ekler, bu yüzden her iki yazıcıyı paralel çalıştırmak virtual memory'de onların bin'lerini iç içe geçirir (gözlemlenebilir with `!process Registry` + `!vad`).
3. Attacker hive'ının son bin'i HKLM'ye ait bir HBIN'den hemen önce oturduğunda, hive bozulma bug'ını kullanarak **attacker hive'ından taşma** başlatın ve HKLM içindeki HBIN header'larını veya hücreleri parçalayın.
4. HKLM metadata kontrol altına alındığında şunları yapabilirsiniz:
- Privileged hive içinde doğrudan big-data tutarsızlık (inconsistency) primitive'ini stage etmek.
- SYSTEM servisleri tarafından tüketilmeden önce kernel içinde kullanılan konfigürasyon verilerini bozmak.

Guard page yokluğu, unprivileged hive'dan lineer overwrite'ın **doğrudan SYSTEM sahipli hive yapılarını** bozmasına izin verir; bu da data-only saldırıları mümkün kılar veya yukarıda HKLM/HKU içinde tarif edilen pool overflow'ı kurar.

## Operational tips

- Overflow'ı tetiklemeden önce bitişikliğin doğrulanması için hive yerleşimini `!vad` (user-mode) ve `!reg view` / `!pool` (kernel) ile izleyin.
- Enumeration sırasında bulunan yazılabilir HKLM yollarını cache'leyin ki corruption primitive'leri reboot sonrası bile hızla deploy edilebilsin.
- Hive grooming'i standart pool feng shui ile (pipe pair freelists, `NtAllocateVirtualMemory` on `Registry` process) birleştirerek post-overflow primitive'lerini stabilize edin.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
