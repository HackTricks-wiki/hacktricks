# Πρωταρχικές τεχνικές εκμετάλλευσης του Windows Registry Hive

{{#include ../../banners/hacktricks-training.md}}

## Γιατί η διαφθορά ενός hive είναι ιδιαίτερη

Τα Windows registry hives είναι **μνήμη-χαρτογραφημένα `.regf` αρχεία** που διαχειρίζονται από έναν προσαρμοσμένο allocator (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`). Ο allocator:

- **Δεν τυχατοποιεί τις κατανομές** – η τοποθέτηση των cell εξαρτάται μόνο από τη σειρά/το μέγεθος των προηγούμενων κλήσεων API του registry, οπότε οι διατάξεις είναι αναπαραγώγιμες μεταξύ μηχανών.
- **Δεν διαθέτει ελέγχους ακεραιότητας** – πεδία header/data που τροποποιούνται χειροκίνητα γίνονται αποδεκτά από τους kernel consumers (`Cmp*` routines) και από τη διεργασία Registry η ίδια.
- **Μοιράζεται χώρο διευθύνσεων με privileged hives** – σε πολλές περιπτώσεις τα attacker-controlled hives χαρτογραφούνται στο ίδιο user-mode εύρος διευθύνσεων με τα HKLM/HKU hives, επιτρέποντας inter-hive overflows.

Αυτό καθιστά τα bugs μνήμης που βασίζονται σε hive (π.χ. CVE-2023-23420 / CVE-2023-23423) ιδιαίτερα αξιόπιστα για LPE.

## Ντετερμινιστική διαμόρφωση της διάταξης με registry APIs

Επειδή η κατανομή hive είναι ντετερμινιστική, μπορείτε να διαμορφώσετε τη θέση των cell αποκλειστικά μέσω Win32 APIs. Ένα τυπικό workflow είναι:

1. **Επαναφέρετε το target key** (διαγραφή/επανδημιουργία) ώστε το hive bin να περιέχει μόνο γνωστά cells.
2. **Κατανείμετε προβλέψιμες σειρές cells** δημιουργώντας values με προσεκτικά επιλεγμένα μεγέθη:
- Τα metadata cells των key/value είναι πολλαπλάσια των 8 bytes.
- Η εγγραφή `0x3FD8`-byte values αναγκάζει ένα νέο `0x4000`-byte bin (`0x3FD8` data + `_HBIN` header/padding), ιδανικό για interleaving bins αργότερα.
3. **Χρησιμοποιήστε τύπους φιλικούς στο resizing** (π.χ. `REG_BINARY`) ώστε να μπορείτε να απελευθερώνετε/επεκτείνετε μεμονωμένα cells απλά καλώντας `RegSetValueEx` με διαφορετικά μήκη.
4. **Καταγράψτε τη σειρά** των λειτουργιών (create/delete/resize). Η αναπαραγωγή της αναπαράγει την ίδια διάταξη σε άλλα συστήματα επειδή ο allocator δεν έχει τυχαιότητα.

<details>
<summary>Example layout shaper (simplified C)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Μόλις ένα corruption primitive (overwrite/fill) είναι διαθέσιμο, το groom εξασφαλίζει ότι το **target cell resides next to the sprayed holes**, επιτρέποντας precise overwrites χωρίς heap spraying.

## Πρόσβαση μόνο μέσω API σε privileged hives μέσω misconfigured descendants

Τα Windows αξιολογούν μόνο το **ACL στο τελικό component** μιας registry path. Αν οποιοσδήποτε descendant κάτω από HKLM/HKU παραχωρεί `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY` ή `WRITE_DAC` σε low-privileged users, μπορείτε να τον προσεγγίσετε ακόμα και όταν όλα τα parent keys είναι κλειδωμένα. Project Zero εντόπισε **>1000 τέτοια writable keys στο HKLM σε Windows 11**, συμπεριλαμβανομένων μακροχρόνιων εγγραφών όπως `HKLM\SOFTWARE\Microsoft\DRM` και αρκετών κλάδων `HKLM\SYSTEM`.

Practical enumeration strategy:

1. Από ένα elevated context, διασχίστε `\Registry\Machine` και `\Registry\User`, κάνοντας dump το security descriptor κάθε key. Αποθηκεύστε τα στοιχεία των οποίων το DACL επιτρέπει unprivileged SIDs.
2. Ως normal user, δοκιμάστε `RegOpenKeyEx` με `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` για τις καταγεγραμμένες διαδρομές. Επιτυχείς ανοίγματα είναι βιώσιμοι στόχοι για hive corruption bugs που απαιτούν attacker-controlled data σε system hives.
3. Διατηρήστε cache ανοιχτών handles προς **stable writable locations** ώστε PoCs να μπορούν να αναπτύξουν απευθείας corrupted metadata.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Once such a path is known, the exploit never needs offline hive tampering—**standard registry APIs are enough** to stage the corrupt cells inside privileged hives touched by SYSTEM services.

## Κατάχρηση hive μεταξύ χρηστών μέσω `HKCU\Software\Microsoft\Input\TypingInsights`

Κάθε user hive περιλαμβάνει το `HKCU\Software\Microsoft\Input\TypingInsights`, του οποίου το ACL δίνει `KEY_ALL_ACCESS` στο **Everyone (S-1-1-0).** Μέχρι να το σφίξει η Microsoft, οποιοσδήποτε χρήστης μπορεί:

- **Να γεμίσει το hive άλλου χρήστη** μέχρι το όριο των 2 GiB, προκαλώντας αποτυχίες συνόδου ή αναγκάζοντας truncation του hive (χρήσιμο για να παρακινήσει συμπεριφορά allocator ή DoS).
- **Να ρίξει κατεστραμμένα cells** στο `NTUSER.DAT` άλλων χρηστών, στήνοντας lateral exploits που ενεργοποιούνται όταν η διαδικασία θύμα διαβάσει το συμβιβασμένο κλειδί.
- **Να τροποποιήσει differencing hives** για sandboxed apps που βασίζονται σε per-user overlay hives, αναγκάζοντάς τα να καταναλώσουν κακόβουλα metadata.

Αυτό κάνει τις ευπάθειες διαφθοράς hive εφαρμόσιμες για **lateral movement**, όχι μόνο για elevation μέσα στον ίδιο λογαριασμό.

## Μετατροπή της διαφθοράς μεταδεδομένων σε paged pool overflows

Large registry values αποθηκεύονται σε `_CM_BIG_DATA` records:

- `_CM_KEY_VALUE.DataLength` κρατάει το λογικό μέγεθος. Το υψηλό bit του δείχνει αν το payload βρίσκεται μέσα στο cell ή στο big-data storage.
- `_CM_BIG_DATA.Count` μετράει **16 KiB chunks** (16384 bytes minus metadata) που αναφέρονται μέσω ενός chunk table.

Όταν οποιοδήποτε component καλεί `CmpGetValueData`:

1. Ο kernel κάνει allocate ένα **paged pool buffer** με μέγεθος αυστηρά από `DataLength`.
2. Αντιγράφει `Count * 0x4000` bytes από το hive storage μέσα σε αυτό το buffer.

Αν μπορείτε να χακάρoυτε το cell ώστε `DataLength < 16344 * (Count - 1)`, η αντιγραφή **υπερχείλιζει γραμμικά** τον προορισμό προς γειτονικά paged-pool objects. Μια αξιόπιστη αλυσίδα exploit είναι:

1. Χρησιμοποιήστε deterministic groom για να τοποθετήσετε το ευάλωτο `_CM_KEY_VALUE` κοντά σε controllable metadata.
2. Γυρίστε το `DataLength` σε έναν μικρό αριθμό (π.χ. 0x100) ενώ αφήνετε το `_CM_BIG_DATA.Count` ανεπηρέαστο.
3. Pool-groom από user mode (pipes, ALPC ports, section objects) ώστε ένα επιλεγμένο object (όπως ο κάτοχος `EPROCESS->Token` ή `SRVNET_BUFFER`) να καταλάβει το επόμενο chunk μετά την allocation του βήματος 1.
4. Προκαλέστε ένα read (π.χ., `RegQueryValueEx`, `NtQueryValueKey`) ώστε `CmpGetValueData` να αντιγράψει όλα τα chunks και **να αντικαταστήσει τα πεδία του γείτονα** με δεδομένα υπό τον έλεγχο του επιτιθέμενου από το hive.
5. Χρησιμοποιήστε το κατεστραμμένο kernel object για pivot σε arbitrary read/write ή άμεση κλοπή SYSTEM token.

Επειδή το μήκος του overflow ισούται με `(Count * 0x4000) - DataLength`, έχετε ένα **ακριβές byte budget** και πλήρη έλεγχο πάνω στα bytes που γράφονται, ξεπερνώντας πολλά driver-based pool overflows.

## Inter-hive linear overflows μέσω tightly packed HBINs

Hives που mountάρονται από τη Registry process mapάρονται σε **2 MiB-aligned views** χωρίς **guard gaps**. Μπορείτε να αναγκάσετε δύο διαφορετικά hives να αναπτυχθούν παράλληλα μέχρι να ακουμπήσουν οι `_HBIN` περιοχές τους:

1. Επιλέξτε ένα attacker-writable hive (app hive ή user hive) και έναν privileged target (π.χ., `HKLM\SOFTWARE`).
2. Συνεχώς δημιουργείτε/διαγράφετε `0x3FD8`-byte values και στα δύο hives. Κάθε allocation προσθέτει ένα `0x4000`-byte bin, έτσι τρέχοντας τους δύο writers παράλληλα, τα bins τους ενδιάμεσα τοποθετούνται στη virtual memory (παρατηρήθηκε με `!process Registry` + `!vad`).
3. Μόλις το τελικό bin του attacker hive βρεθεί ακριβώς πριν από ένα HBIN που ανήκει στο HKLM, χρησιμοποιήστε το hive corruption bug για να **υπερχείλίσετε έξω από το attacker hive**, καταστρέφοντας HBIN headers ή cells μέσα στο HKLM.
4. Με το metadata του HKLM υπό έλεγχο μπορείτε:
- Να στήσετε ένα big-data inconsistency primitive απευθείας στο privileged hive.
- Να διαφθείρετε configuration data που καταναλώνονται από SYSTEM services πριν ακόμα φύγουν από τον kernel.

Η απουσία guard pages σημαίνει ότι μια γραμμική υπερχείλιση από ένα unprivileged hive μπορεί **άμεσα να καταστρέψει δομές hive που ανήκουν στο SYSTEM**, επιτρέποντας data-only επιθέσεις ή τη δημιουργία του pool overflow που περιγράφηκε παραπάνω μέσα στο HKLM/HKU.

## Επιχειρησιακές συμβουλές

- Παρακολουθείτε την τοποθέτηση των hive με `!vad` (user-mode) και `!reg view` / `!pool` (kernel) για να επιβεβαιώσετε την γειτονία πριν πυροδοτήσετε το overflow.
- Cacheάρετε writable HKLM paths που εντοπίζετε κατά την enumeration ώστε τα corruption primitives να μπορούν να αναπτυχθούν γρήγορα ακόμα και μετά από reboots.
- Συνδυάστε hive grooming με standard pool feng shui (pipe pair freelists, `NtAllocateVirtualMemory` στο `Registry` process) για να σταθεροποιήσετε post-overflow primitives.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
