# Windows Registry Hive Exploitation Primitiven

{{#include ../../banners/hacktricks-training.md}}

## Warum Hive-Korruption besonders ist

Windows-Registry-Hives sind **im Speicher abgebildete `.regf`-Dateien**, verwaltet von einem benutzerdefinierten Allocator (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`). Der Allocator:

- **Randomisiert Zuweisungen nicht** – die Platzierung von Zellen hängt nur von der Reihenfolge/Größe vorheriger Registry-API-Aufrufe ab, daher sind Layouts auf verschiedenen Hosts reproduzierbar.
- **Hat keine Integritätsprüfungen** – manuell veränderte Header-/Datenfelder werden von Kernel-Konsumenten (`Cmp*`-Routinen) und vom Registry-Prozess selbst vertraut.
- **Teilt den Adressraum mit privilegierten Hives** – in vielen Fällen werden von Angreifern kontrollierte Hives in denselben User-Mode-Adressbereich wie HKLM/HKU gemappt, was inter-hive Overflows ermöglicht.

Das macht hive-basierte Memory-Corruption-Bugs (z. B. CVE-2023-23420 / CVE-2023-23423) besonders zuverlässig für LPE.

## Deterministisches Layout-Grooming mit Registry-APIs

Weil die Hive-Allokation deterministisch ist, kann man die Platzierung von Zellen ausschließlich über Win32 APIs steuern. Ein typischer Ablauf ist:

1. **Den Zielschlüssel zurücksetzen** (löschen/neu erstellen), sodass das Hive-Bin nur bekannte Zellen enthält.
2. **Vorhersehbare Zellenreihen allozieren**, indem man Werte mit sorgfältig gewählten Größen erstellt:
- Schlüssel-/Wert-Metadatenzellen sind Vielfache von 8 Bytes.
- Das Schreiben von `0x3FD8`-Byte-Werten erzwingt ein neues `0x4000`-Byte-Bin (`0x3FD8` data + `_HBIN` header/padding), ideal zum späteren Ineinanderfädeln von Bins.
3. **Resize-freundliche Typen verwenden** (z. B. `REG_BINARY`), damit man einzelne Zellen nur durch Aufrufen von `RegSetValueEx` mit unterschiedlichen Längen freigeben/erweitern kann.
4. **Die Sequenz aufzeichnen** der Operationen (create/delete/resize). Das Reproduzieren dieser Sequenz stellt auf anderen Systemen dasselbe Layout her, da der Allocator keine Randomisierung verwendet.

<details>
<summary>Beispiel eines Layout-Shapers (vereinfachtes C)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Sobald eine corruption primitive (overwrite/fill) verfügbar ist, stellt das groom sicher, dass die **target cell resides next to the sprayed holes**, wodurch präzise Overwrites ohne heap spraying möglich werden.

## Nur API-Zugriff auf privilegierte hives durch falsch konfigurierte Nachkommen

Windows wertet nur die **ACL on the final component** eines Registry-Pfads aus. Wenn irgendein Nachkomme unter HKLM/HKU `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY` oder `WRITE_DAC` an niedrig privilegierte Benutzer gewährt, kannst du darauf zugreifen, selbst wenn jeder Elternschlüssel gesperrt ist. Project Zero found **>1000 such writable keys in HKLM on Windows 11**, einschließlich langlebiger Einträge wie `HKLM\SOFTWARE\Microsoft\DRM` und mehreren `HKLM\SYSTEM`-Zweigen.

Praktische Enumerationsstrategie:

1. Aus einem erhöhten Kontext `\Registry\Machine` und `\Registry\User` durchlaufen und den security descriptor jedes Schlüssels dumpen. Speichere Einträge, deren DACL unprivilegierten SIDs Zugriff erlaubt.
2. Als normaler Benutzer `RegOpenKeyEx` mit `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` gegen die aufgezeichneten Pfade versuchen. Erfolgreiche Opens sind brauchbare Ziele für hive corruption bugs, die angreiferkontrollierte Daten in system hives erfordern.
3. Pflege einen Cache offener Handles zu **stable writable locations**, sodass PoCs korrumpierte Metadaten direkt bereitstellen können.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Sobald ein solcher Pfad bekannt ist, benötigt der Exploit niemals Offline-Manipulation der Hive—**Standard-Registry-APIs reichen aus**, um die korrupten Zellen in privilegierten Hives zu platzieren, die von SYSTEM-Diensten verwendet werden.

## Missbrauch von Hives zwischen Benutzern über `HKCU\Software\Microsoft\Input\TypingInsights`

Jede Benutzerhive enthält `HKCU\Software\Microsoft\Input\TypingInsights`, dessen ACL `KEY_ALL_ACCESS` an **Everyone (S-1-1-0)** gewährt. Bis Microsoft das einschränkt, kann jeder Benutzer:

- **Eine andere Benutzer-Hive füllen** bis zum 2 GiB-Limit, was zu Anmeldefehlern führen oder eine Hive-Trunkierung erzwingen kann (nützlich, um das Allocator-Verhalten zu beeinflussen oder DoS).
- **Beschädigte Zellen ablegen** in die `NTUSER.DAT` anderer Benutzer, um laterale Exploits vorzubereiten, die ausgelöst werden, wenn der Opferprozess den kompromittierten Schlüssel liest.
- **Differencing-Hives modifizieren** für sandboxed Apps, die auf per-user Overlay-Hives angewiesen sind, sodass sie bösartige Metadaten konsumieren.

Das macht Hive-Korruptions-Schwachstellen auf **lateral movement** anwendbar, nicht nur zur Eskalation innerhalb desselben Kontos.

## Metadatenkorruption in paged pool overflows verwandeln

Große Registry-Werte werden in `_CM_BIG_DATA`-Records gespeichert:

- `_CM_KEY_VALUE.DataLength` enthält die logische Größe. Sein High-Bit zeigt an, ob die Nutzlast innerhalb der Zelle oder im Big-Data-Speicher liegt.
- `_CM_BIG_DATA.Count` zählt **16 KiB chunks** (16384 bytes minus metadata), die über eine Chunk-Tabelle referenziert werden.

Wenn eine Komponente `CmpGetValueData` aufruft:

1. Der Kernel alloziert einen **paged pool buffer**, dessen Größe strikt aus `DataLength` abgeleitet wird.
2. Er kopiert `Count * 0x4000` bytes aus dem Hive-Speicher in diesen Buffer.

Wenn Sie die Zelle so korrumpieren können, dass `DataLength < 16344 * (Count - 1)`, überläuft der Kopiervorgang **linear das Ziel** in benachbarte paged-pool-Objekte. Eine zuverlässige Exploit-Kette ist:

1. Verwenden Sie das deterministic groom, um den verwundbaren `_CM_KEY_VALUE` in die Nähe kontrollierbarer Metadaten zu platzieren.
2. Setzen Sie `DataLength` auf eine kleine Zahl (z. B. 0x100), während `_CM_BIG_DATA.Count` intakt bleibt.
3. Pool-groom aus dem User-Modus (pipes, ALPC ports, section objects), sodass ein gewähltes Objekt (z. B. `EPROCESS->Token` owner oder `SRVNET_BUFFER`) den nächsten Chunk nach der Allokation aus Schritt 1 belegt.
4. Lösen Sie einen Lesevorgang aus (z. B. `RegQueryValueEx`, `NtQueryValueKey`), sodass `CmpGetValueData` alle Chunks kopiert und **die Felder des Nachbarn** mit vom Angreifer kontrollierten Daten aus der Hive überschreibt.
5. Nutzen Sie das korrupte Kernel-Objekt, um auf beliebiges read/write umzuschwenken oder direkt den SYSTEM-Token zu stehlen.

Da die Overflow-Länge `(Count * 0x4000) - DataLength` entspricht, erhält man ein **präzises Byte-Budget** und die volle Kontrolle über die geschriebenen Bytes, wodurch viele treiberbasierte Pool-Overflows übertroffen werden.

## Inter-Hive lineare Overflows durch eng gepackte HBINs

Von Registry-Prozess gemountete Hives werden in **2 MiB-aligned views** ohne **no guard gaps** abgebildet. Sie können zwei verschiedene Hives dazu zwingen, im Gleichschritt zu wachsen, bis sich ihre `_HBIN`-Bereiche berühren:

1. Wählen Sie eine vom Angreifer beschreibbare Hive (app hive oder user hive) und ein privilegiertes Ziel (z. B. `HKLM\SOFTWARE`).
2. Erstellen/Löschen Sie kontinuierlich `0x3FD8`-byte Werte in beiden Hives. Jede Allokation fügt einen `0x4000`-byte bin hinzu, sodass das parallele Ausführen beider Schreiber ihre Bins im virtuellen Speicher verwebt (beobachtbar mit `!process Registry` + `!vad`).
3. Sobald der letzte Bin der Angreifer-Hive unmittelbar vor einem HBIN liegt, der zu HKLM gehört, nutzen Sie den Hive-Korruptions-Bug, um **aus der Angreifer-Hive heraus zu überlaufen**, und zerstören HBIN-Header oder Zellen innerhalb von HKLM.
4. Mit HKLM-Metadaten unter Kontrolle können Sie:
- Eine Big-Data-Inkonsistenz-Primitive direkt in der privilegierten Hive platzieren.
- Konfigurationsdaten, die von SYSTEM-Diensten konsumiert werden, korrumpieren, noch bevor sie den Kernel verlassen.

Das Fehlen von Guard-Pages bedeutet, dass ein linearer Überschreibvorgang aus einer unprivilegierten Hive **direkt SYSTEM-eigene Hive-Strukturen korrumpieren** kann, was datenbasierte Angriffe ermöglicht oder den oben beschriebenen Pool-Overflow innerhalb von HKLM/HKU vorbereitet.

## Praktische Hinweise

- Überwachen Sie die Hive-Platzierung mit `!vad` (User-Modus) und `!reg view` / `!pool` (Kernel), um die Benachbartheit zu bestätigen, bevor Sie den Overflow auslösen.
- Cachen Sie während der Enumeration entdeckte beschreibbare HKLM-Pfade, sodass Korruptions-Primitives schnell bereitgestellt werden können, sogar nach Neustarts.
- Kombinieren Sie Hive-Grooming mit standardmäßigem Pool feng shui (pipe pair freelists, `NtAllocateVirtualMemory` on `Registry` process) um Post-Overflow-Primitives zu stabilisieren.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
