# Windows Registry Hive Exploitation Primitives

{{#include ../../banners/hacktricks-training.md}}

## क्यों hive करप्शन खास है

Windows registry hives **memory-mapped `.regf` files** हैं, जिन्हें एक कस्टम एलोकेटर (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`) द्वारा मैनेज किया जाता है। एलोकेटर:

- **आलोकेशनों को रैंडमाइज़ नहीं करता** – सेल प्लेसमेंट केवल पिछले registry API कॉल्स के क्रम/आकार पर निर्भर करता है, इसलिए लेआउट होस्ट्स पर पुनरुत्पादनीय होते हैं।
- **इंटीग्रिटी चेक्स की कमी है** – मैन्युअली बदले गए header/data फील्ड्स को kernel consumers (`Cmp*` routines) और Registry प्रक्रिया स्वयं ट्रस्ट करती है।
- **प्रिविलेज्ड हाइव्स के साथ address space साझा करता है** – कई मामलों में attacker-controlled hives को उसी user-mode address range में मैप किया जाता है जो HKLM/HKU hives के लिए है, जिससे inter-hive overflows संभव होते हैं।

इससे hive-आधारित मेमोरी करप्शन बग्स (उदा., CVE-2023-23420 / CVE-2023-23423) LPE के लिए अनूठे रूप से विश्वसनीय बन जाते हैं।

## Registry APIs के साथ deterministic लेआउट ग्रूमिंग

क्योंकि hive allocation deterministic है, आप सिर्फ़ Win32 APIs के माध्यम से सेल प्लेसमेंट ग्रूम कर सकते हैं। एक सामान्य वर्कफ़्लो है:

1. **टार्गेट की को रिसेट करें** (delete/recreate) ताकि hive bin में केवल ज्ञात सेल्स हों।
2. **प्रीडिक्टेबल रन ऑफ़ सेल्स अलोकेट करें** carefully चुने हुए साइज़ के साथ वैल्यूज़ बनाकर:
- Key/value metadata cells 8 bytes के गुणज होते हैं।
- `0x3FD8`-बाइट वैल्यूज़ लिखने से एक नया `0x4000`-बाइट bin बनता है (`0x3FD8` data + `_HBIN` header/padding), जो बाद में बिन्स को interleave करने के लिए आदर्श है।
3. **resize-friendly टाइप्स का उपयोग करें** (उदा., `REG_BINARY`) ताकि आप अलग-अलग लंबाइयों के साथ `RegSetValueEx` कॉल करके व्यक्तिगत सेल्स को free/extend कर सकें।
4. **ऑपरेशन्स का सीक्वेंस रिकॉर्ड करें** (create/delete/resize)। इसे रिप्ले करने से वही लेआउट अन्य सिस्टम्स पर पुन: प्राप्त होता है क्योंकि एलोकेटर में कोई randomness नहीं होता।

<details>
<summary>उदाहरण लेआउट शेपर (सरलीकृत C)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Once a corruption primitive (overwrite/fill) is available, the groom guarantees that the **target cell resides next to the sprayed holes**, enabling precise overwrites without heap spraying.

## API-only access to privileged hives via misconfigured descendants

Windows केवल registry path के अंतिम component पर स्थित **ACL** का मूल्यांकन करता है। अगर HKLM/HKU के किसी भी descendant को low-privileged users को `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY`, या `WRITE_DAC` दिया गया है, तो आप उस तक पहुँच सकते हैं भले ही उसके सभी parent keys लॉक हों। Project Zero ने Windows 11 पर HKLM में **>1000 ऐसे writable keys** पाए, जिनमें लंबे समय से मौजूद entries जैसे `HKLM\SOFTWARE\Microsoft\DRM` और कई `HKLM\SYSTEM` branches शामिल हैं।

Practical enumeration strategy:

1. उच्च context से `\Registry\Machine` और `\Registry\User` को वॉक करें, और प्रत्येक key का security descriptor डंप करें। उन items को स्टोर करें जिनकी DACL unprivileged SIDs को अनुमति देती है।
2. एक सामान्य user के रूप में रिकॉर्ड किए गए paths के खिलाफ `RegOpenKeyEx` को `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` के साथ प्रयास करें। सफल opens उन targets के लिए उपयुक्त होते हैं जिन पर hive corruption bugs लागू किए जा सकते हैं और जिन्हें system hives में attacker-controlled data की आवश्यकता होती है।
3. PoCs को सीधे corrupted metadata तैनात करने में सक्षम बनाने के लिए **stable writable locations** के खुले handles का एक cache बनाए रखें।
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Once such a path is known, the exploit never needs offline hive tampering—**standard registry APIs are enough** to stage the corrupt cells inside privileged hives touched by SYSTEM services.

## Cross-user hive abuse via `HKCU\Software\Microsoft\Input\TypingInsights`

Every user hive contains `HKCU\Software\Microsoft\Input\TypingInsights`, whose ACL grants `KEY_ALL_ACCESS` to **Everyone (S-1-1-0).** Until Microsoft tightens it, any user can:

- Fill another user’s hive up to the 2 GiB limit, causing logon failures or forcing hive truncation (useful to coerce allocator behavior or DoS).
- Drop corrupted cells into other users’ `NTUSER.DAT`, setting up lateral exploits that trigger when the victim process reads the compromised key.
- Modify differencing hives for sandboxed apps that rely on per-user overlay hives, forcing them to consume malicious metadata.

This makes hive corruption vulnerabilities applicable to **lateral movement**, not just elevation within the same account.

## Turning metadata corruption into paged pool overflows

Large registry values are stored in `_CM_BIG_DATA` records:

- `_CM_KEY_VALUE.DataLength` holds the logical size. Its high bit indicates whether the payload lives inside the cell or in big-data storage.
- `_CM_BIG_DATA.Count` counts **16 KiB chunks** (16384 bytes minus metadata) referenced via a chunk table.

When any component calls `CmpGetValueData`:

1. The kernel allocates a **paged pool buffer** sized strictly from `DataLength`.
2. It copies `Count * 0x4000` bytes from hive storage into that buffer.

If you can corrupt the cell so `DataLength < 16344 * (Count - 1)`, the copy **overruns the destination linearly** into adjacent paged-pool objects. A reliable exploit chain is:

1. Use the deterministic groom to place the vulnerable `_CM_KEY_VALUE` near controllable metadata.
2. Flip `DataLength` to a small number (e.g., 0x100) while leaving `_CM_BIG_DATA.Count` intact.
3. Pool-groom from user mode (pipes, ALPC ports, section objects) so a chosen object (like `EPROCESS->Token` owner or `SRVNET_BUFFER`) occupies the next chunk after the allocation from step 1.
4. Trigger a read (e.g., `RegQueryValueEx`, `NtQueryValueKey`) so `CmpGetValueData` copies all chunks and **overwrites the neighbor’s fields** with attacker-controlled data from the hive.
5. Use the corrupted kernel object to pivot to arbitrary read/write or direct SYSTEM token theft.

Because the overflow length equals `(Count * 0x4000) - DataLength`, you get a **precise byte budget** and full control over the bytes written, outperforming many driver-based pool overflows.

## Inter-hive linear overflows via tightly packed HBINs

Hives mounted by the Registry process are mapped in **2 MiB-aligned views** with **no guard gaps**. You can force two different hives to grow in lockstep until their `_HBIN` ranges touch:

1. Choose an attacker-writable hive (app hive or user hive) and a privileged target (e.g., `HKLM\SOFTWARE`).
2. Continuously create/delete `0x3FD8`-byte values in both hives. Each allocation adds a `0x4000`-byte bin, so running both writers in parallel interleaves their bins in virtual memory (observed with `!process Registry` + `!vad`).
3. Once the final bin of the attacker hive sits immediately before an HBIN belonging to HKLM, use the hive corruption bug to **overflow out of the attacker hive**, smashing HBIN headers or cells inside HKLM.
4. With HKLM metadata under control you can:
- Stage a big-data inconsistency primitive directly in the privileged hive.
- Corrupt configuration data consumed by SYSTEM services before it ever leaves the kernel.

The absence of guard pages means a linear overwrite from an unprivileged hive can **directly corrupt SYSTEM-owned hive structures**, enabling data-only attacks or setting up the pool overflow described above inside HKLM/HKU.

## Operational tips

- Monitor hive placement with `!vad` (user-mode) and `!reg view` / `!pool` (kernel) to confirm adjacency before triggering the overflow.
- Cache writable HKLM paths discovered during enumeration so corruption primitives can be deployed quickly even after reboots.
- Combine hive grooming with standard pool feng shui (pipe pair freelists, `NtAllocateVirtualMemory` on `Registry` process) to stabilize post-overflow primitives.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
