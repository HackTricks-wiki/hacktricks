# Примітиви експлуатації Windows Registry Hive

{{#include ../../banners/hacktricks-training.md}}

## Чому пошкодження hive є особливим

Windows registry hives are **memory-mapped `.regf` files** managed by a custom allocator (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`). The allocator:

- **Не рандомізує розподіл** – розташування клітин залежить лише від порядку/розміру попередніх викликів API реєстру, тому розмітки відтворюються на різних хостах.
- **Не має перевірок цілісності** – вручну змінені поля заголовка/даних довіряються споживачами ядра (`Cmp*` routines) та самому процесу Registry.
- **Ділить адресний простір з привілейованими hive** – у багатьох випадках hive, контрольовані атакуючим, відображуються в той самий діапазон адрес в режимі користувача, що й HKLM/HKU hives, що дозволяє між-hive переповнення.

Це робить баги корупції пам'яті, пов'язані з hive (наприклад, CVE-2023-23420 / CVE-2023-23423), винятково надійними для LPE.

## Детерміноване формування макета за допомогою API реєстру

Оскільки алокація hive детермінована, ви можете формувати розташування клітин виключно за допомогою Win32 API. Типовий робочий процес:

1. **Скинути цільовий ключ** (видалити/створити заново), щоб hive bin містив лише відомі клітини.
2. **Виділяти передбачувані послідовності клітин** шляхом створення значень з ретельно підібраними розмірами:
- Клітини метаданих ключа/значення кратні 8 байтам.
- Запис значень розміром `0x3FD8` байтів змушує виділити новий `0x4000`-байтний bin (`0x3FD8` даних + `_HBIN` заголовок/відступ), ідеальний для подальшого чергування bin-ів.
3. **Використовуйте типи, зручні для зміни розміру** (наприклад, `REG_BINARY`), щоб ви могли звільняти/розширювати окремі клітини просто викликом `RegSetValueEx` з різними довжинами.
4. **Записуйте послідовність** операцій (створити/видалити/змінити розмір). Відтворення її відтворює ту саму розмітку на інших системах, тому що аллокатор не має випадковості.

<details>
<summary>Приклад формувача макета (спрощено, C)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Once a corruption primitive (overwrite/fill) is available, the groom гарантує, що **target cell знаходиться поруч зі sprayed holes**, що дозволяє виконувати точні overwrites без heap spraying.

## Доступ лише через API до привілейованих hives через неправильно налаштовані дочірні ключі

Windows оцінює лише **ACL на останньому компоненті** шляху реєстру. Якщо будь-який нащадок під HKLM/HKU надає `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY` або `WRITE_DAC` користувачам з низькими привілеями, ви можете дістатися до нього навіть коли всі батьківські ключі заблоковані. Project Zero знайшли **>1000 таких записуваних ключів у HKLM на Windows 11**, включно з довгоживучими записами на кшталт `HKLM\SOFTWARE\Microsoft\DRM` та кількома гілками `HKLM\SYSTEM`.

Практична стратегія переліку:

1. З підвищеного контексту пройдіть `\Registry\Machine` і `\Registry\User`, зберігаючи дескриптор безпеки кожного ключа. Збережіть записи, у яких DACL надає права неповноваженим SID.
2. Як звичайний користувач, спробуйте `RegOpenKeyEx` з `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` проти зафіксованих шляхів. Успішні відкриття — це придатні цілі для hive corruption bugs, які вимагають attacker-controlled data у системних hives.
3. Підтримуйте кеш відкритих handles до **стабільних writable locations**, щоб PoCs могли напряму розміщувати пошкоджені метадані.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Once such a path is known, the exploit never needs offline hive tampering—**standard registry APIs are enough** to stage the corrupt cells inside privileged hives touched by SYSTEM services.

## Cross-user hive abuse via `HKCU\Software\Microsoft\Input\TypingInsights`

Кожен user hive містить `HKCU\Software\Microsoft\Input\TypingInsights`, ACL якого дає `KEY_ALL_ACCESS` для **Everyone (S-1-1-0).** Поки Microsoft цього не виправить, будь-який користувач може:

- **Заповнити hive іншого користувача** до ліміту в 2 GiB, спричиняючи помилки входу або примусове обрізання hive (корисно для примусу поведінки allocator або DoS).
- **Вставити пошкоджені cells** у `NTUSER.DAT` іншого користувача, готуючи латеральні експлойти, що спрацьовують під час читання скомпрометованого ключа жертвою.
- **Змінити differencing hives** для sandboxed додатків, які залежать від per-user overlay hives, змушуючи їх споживати шкідливі метадані.

Це робить уразливості корупції hive застосовними до **lateral movement**, а не тільки для підвищення привілеїв в межах того ж облікового запису.

## Turning metadata corruption into paged pool overflows

Large registry values are stored in `_CM_BIG_DATA` records:

- `_CM_KEY_VALUE.DataLength` містить логічний розмір. Його старший біт вказує, чи payload знаходиться всередині cell або в big-data storage.
- `_CM_BIG_DATA.Count` рахує **16 KiB chunks** (16384 bytes minus metadata), на які посилаються через chunk table.

When any component calls `CmpGetValueData`:

1. The kernel allocates a **paged pool buffer** sized strictly from `DataLength`.
2. It copies `Count * 0x4000` bytes from hive storage into that buffer.

Якщо ви можете пошкодити cell так, що `DataLength < 16344 * (Count - 1)`, копіювання **переповнить призначення лінійно** у сусідні paged-pool objects. Надійний exploit chain:

1. Використати детерміністичний groom, щоб помістити вразливий `_CM_KEY_VALUE` поруч із контрольованими метаданими.
2. Змінити `DataLength` на мале значення (наприклад, 0x100), залишивши `_CM_BIG_DATA.Count` недоторканим.
3. Провести pool-groom з user mode (pipes, ALPC ports, section objects), щоб обраний об’єкт (наприклад, `EPROCESS->Token` owner або `SRVNET_BUFFER`) зайняв наступний chunk після алокації з кроку 1.
4. Тригернути читання (наприклад, `RegQueryValueEx`, `NtQueryValueKey`), щоб `CmpGetValueData` скопіював всі chunks і **перезаписав поля сусіда** даними з hive під контролем атакуючого.
5. Використати пошкоджений kernel object для pivot до довільного read/write або прямого викрадення SYSTEM token.

Оскільки довжина overflow дорівнює `(Count * 0x4000) - DataLength`, ви отримуєте **точний байт-бюджет** і повний контроль над записуваними байтами, випереджаючи багато driver-based pool overflows.

## Inter-hive linear overflows via tightly packed HBINs

Hives, змонтовані процесом Registry, відображаються у **2 MiB-алігновані view** без guard gaps. Ви можете змусити два різні hives рости синхронно, поки їхні `_HBIN` діапазони не торкнуться:

1. Оберіть attacker-writable hive (app hive або user hive) і привілейований тарґет (наприклад, `HKLM\SOFTWARE`).
2. Постійно створюйте/видаляйте значення розміром `0x3FD8` байт в обох hives. Кожна алокація додає `0x4000`-байт bin, тож запуск обох writer-ів паралельно чергує їхні bins у віртуальній пам’яті (спостерігається через `!process Registry` + `!vad`).
3. Коли фінальний bin attacker hive сидить безпосередньо перед HBIN, що належить HKLM, використайте bug корупції hive, щоб **переповнити attacker hive**, нищачи HBIN headers або cells всередині HKLM.
4. З контролем метаданих HKLM ви можете:
- Розгорнути big-data inconsistency primitive безпосередньо в привілейованому hive.
- Пошкодити конфігураційні дані, які споживають SYSTEM services, ще до того, як вони покинуть kernel.

Відсутність guard pages означає, що лінійний overwrite з unprivileged hive може **безпосередньо пошкодити структури hive, що належать SYSTEM**, відкриваючи можливості data-only атак або підготовки pool overflow, описаного вище, всередині HKLM/HKU.

## Operational tips

- Моніторте розміщення hive за допомогою `!vad` (user-mode) та `!reg view` / `!pool` (kernel), щоб підтвердити суміжність перед тригером overflow.
- Кешуйте writable HKLM paths, виявлені під час enumeration, щоб corruption primitives можна було швидко застосувати навіть після reboot.
- Поєднуйте hive grooming зі стандартним pool feng shui (pipe pair freelists, `NtAllocateVirtualMemory` на `Registry` process), щоб стабілізувати примітиви після overflow.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
