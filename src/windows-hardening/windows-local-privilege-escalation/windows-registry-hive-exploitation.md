# Primitivas de explotación de hives del Registro de Windows

{{#include ../../banners/hacktricks-training.md}}

## Por qué la corrupción de hive es especial

Los hives del registro de Windows son **archivos `.regf` mapeados en memoria** gestionados por un asignador personalizado (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`). El asignador:

- **No aleatoriza las asignaciones** – la colocación de las celdas depende solo del orden/tamaño de llamadas previas a la API del registro, por lo que los layouts son reproducibles entre hosts.
- **Carece de comprobaciones de integridad** – los campos de encabezado/datos alterados manualmente son confiados por los consumidores del kernel (`Cmp*` routines) y por el propio proceso del Registry.
- **Comparte espacio de direcciones con hives privilegiados** – en muchos casos los hives controlados por un atacante se mapean en el mismo rango de direcciones de modo usuario que los hives HKLM/HKU, habilitando inter-hive overflows.

Esto hace que los bugs de corrupción de memoria basados en hives (p. ej., CVE-2023-23420 / CVE-2023-23423) sean especialmente fiables para LPE.

## Deterministic layout grooming with registry APIs

Debido a que la asignación de hives es determinista, puedes groomear la colocación de celdas puramente mediante las APIs de Win32. Un flujo de trabajo típico es:

1. **Reset the target key** (delete/recreate) so the hive bin contains only known cells.
2. **Allocate predictable runs of cells** by creating values with carefully selected sizes:
- Key/value metadata cells are multiples of 8 bytes.
- Writing `0x3FD8`-byte values forces a fresh `0x4000`-byte bin (`0x3FD8` data + `_HBIN` header/padding), ideal for interleaving bins later.
3. **Use resize-friendly types** (e.g., `REG_BINARY`) so you can free/extend individual cells just by calling `RegSetValueEx` with different lengths.
4. **Record the sequence** of operations (create/delete/resize). Replaying it reproduces the same layout on other systems because the allocator has no randomness.

<details>
<summary>Ejemplo de layout shaper (C simplificado)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Una vez que se dispone de una corruption primitive (overwrite/fill), el groom garantiza que la **celda objetivo se sitúa junto a los sprayed holes**, permitiendo sobrescrituras precisas sin heap spraying.

## Acceso solo por API a hives privilegiados vía descendientes mal configurados

Windows solo evalúa la **ACL en el componente final** de una ruta del registro. Si cualquier descendiente bajo HKLM/HKU concede `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY` o `WRITE_DAC` a usuarios con pocos privilegios, puedes alcanzarlo incluso cuando todas las claves padre están restringidas. Project Zero encontró **>1000 claves escribibles así en HKLM en Windows 11**, incluidas entradas de larga duración como `HKLM\SOFTWARE\Microsoft\DRM` y varias ramas de `HKLM\SYSTEM`.

Estrategia práctica de enumeración:

1. Desde un contexto elevado, recorre `\Registry\Machine` y `\Registry\User`, volcando el security descriptor de cada clave. Almacena los elementos cuya DACL permita SIDs no privilegiados.
2. Como usuario normal, intenta `RegOpenKeyEx` con `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` contra las rutas registradas. Las aperturas exitosas son objetivos viables para bugs de hive corruption que requieren datos controlados por el atacante en los hives del sistema.
3. Mantén una caché de handles abiertos a ubicaciones escribibles estables para que los PoCs puedan desplegar directamente metadatos corrompidos.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Once such a path is known, the exploit never needs offline hive tampering—**las APIs estándar del registro son suficientes** para colocar las celdas corruptas dentro de hives privilegiados tocados por los servicios SYSTEM.

## Abuso entre usuarios del hive vía `HKCU\Software\Microsoft\Input\TypingInsights`

Every user hive contains `HKCU\Software\Microsoft\Input\TypingInsights`, whose ACL grants `KEY_ALL_ACCESS` to **Everyone (S-1-1-0).** Until Microsoft tightens it, any user can:

- **Llenar el hive de otro usuario** hasta el límite de 2 GiB, provocando fallos de inicio de sesión o forzando la truncación del hive (útil para coaccionar el comportamiento del asignador o DoS).
- **Insertar celdas corruptas** en el `NTUSER.DAT` de otros usuarios, preparando exploits laterales que se activan cuando el proceso víctima lee la clave comprometida.
- **Modificar differencing hives** para sandboxed apps que dependen de per-user overlay hives, obligándolas a consumir metadata maliciosa.

This makes hive corruption vulnerabilities applicable to **lateral movement**, not just elevation within the same account.

## Convirtiendo la corrupción de metadata en overflows del paged pool

Large registry values are stored in `_CM_BIG_DATA` records:

- `_CM_KEY_VALUE.DataLength` contiene el tamaño lógico. Su bit alto indica si el payload vive dentro de la celda o en almacenamiento big-data.
- `_CM_BIG_DATA.Count` cuenta **16 KiB chunks** (16384 bytes menos metadata) referenciados vía una tabla de chunks.

When any component calls `CmpGetValueData`:

1. El kernel asigna un **buffer de paged pool** dimensionado estrictamente a partir de `DataLength`.
2. Copia `Count * 0x4000` bytes desde el almacenamiento del hive hacia ese buffer.

If you can corrupt the cell so `DataLength < 16344 * (Count - 1)`, the copy **overruns the destination linearly** into adjacent paged-pool objects. A reliable exploit chain is:

1. Usar el deterministic groom para colocar el vulnerable `_CM_KEY_VALUE` cerca de metadata controlable.
2. Cambiar `DataLength` a un número pequeño (por ejemplo, 0x100) dejando `_CM_BIG_DATA.Count` intacto.
3. Pool-groom desde user mode (pipes, ALPC ports, section objects) para que un objeto elegido (como el propietario de `EPROCESS->Token` o un `SRVNET_BUFFER`) ocupe el siguiente chunk tras la asignación del paso 1.
4. Provocar una lectura (p. ej., `RegQueryValueEx`, `NtQueryValueKey`) para que `CmpGetValueData` copie todos los chunks y **sobrescriba los campos del objeto vecino** con datos controlados por el atacante desde el hive.
5. Usar el objeto kernel corrupto para pivotar a lectura/escritura arbitraria o robo directo del token de SYSTEM.

Because the overflow length equals `(Count * 0x4000) - DataLength`, you get a **precise byte budget** and full control over the bytes written, outperforming many driver-based pool overflows.

## Overflows lineales entre hives vía HBINs empaquetados estrechamente

Hives mounted by the Registry process are mapped in **2 MiB-aligned views** with **no guard gaps**. You can force two different hives to grow in lockstep until their `_HBIN` ranges touch:

1. Elige un attacker-writable hive (app hive o user hive) y un objetivo privilegiado (p. ej., `HKLM\SOFTWARE`).
2. Crear/eliminar continuamente valores de `0x3FD8` bytes en ambos hives. Cada asignación añade un bin de `0x4000` bytes, así que ejecutar ambos escritores en paralelo entrelaza sus bins en memoria virtual (observado con `!process Registry` + `!vad`).
3. Una vez que el bin final del hive atacante esté inmediatamente antes de un HBIN perteneciente a HKLM, usa el bug de corrupción de hive para **desbordar fuera del hive atacante**, destrozando headers de HBIN o celdas dentro de HKLM.
4. Con la metadata de HKLM bajo control puedes:
   - Preparar una primitiva de inconsistencia de big-data directamente en el hive privilegiado.
   - Corromper datos de configuración consumidos por los servicios SYSTEM antes de que salgan del kernel.

La ausencia de guard pages significa que una sobrescritura lineal desde un hive no privilegiado puede **corromper directamente estructuras de hive propiedad de SYSTEM**, permitiendo ataques solo de datos o preparando el overflow de pool descrito arriba dentro de HKLM/HKU.

## Consejos operativos

- Monitoriza la colocación de hives con `!vad` (user-mode) y `!reg view` / `!pool` (kernel) para confirmar la adyacencia antes de disparar el overflow.
- Cachea rutas HKLM escribibles descubiertas durante la enumeración para que las primitivas de corrupción puedan desplegarse rápidamente incluso después de reboots.
- Combina hive grooming con el feng shui estándar de pool (pipe pair freelists, `NtAllocateVirtualMemory` on `
Registry` process) para estabilizar las primitivas post-overflow.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
