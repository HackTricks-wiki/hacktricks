# Windows Registry Hive Exploitation Primitives

{{#include ../../banners/hacktricks-training.md}}

## Dlaczego korupcja hive jest wyjątkowa

Windows registry hives to **mapowane do pamięci pliki `.regf`** zarządzane przez niestandardowy alokator (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`). Alokator:

- **Nie losuje przydziałów** – położenie komórek zależy wyłącznie od kolejności/rozmiaru wcześniejszych wywołań API rejestru, więc układy są powtarzalne między hostami.
- **Brak kontroli integralności** – ręcznie zmodyfikowane pola nagłówka/danych są ufane przez konsumenci jądra (`Cmp*` routines) oraz przez proces Registry.
- **Dzieli przestrzeń adresową z uprzywilejowanymi hive'ami** – w wielu przypadkach hive'y kontrolowane przez atakującego są mapowane w tym samym zakresie adresów trybu użytkownika co HKLM/HKU, co umożliwia przepełnienia między hive'ami.

To sprawia, że błędy korupcji pamięci oparte na hive (np. CVE-2023-23420 / CVE-2023-23423) są wyjątkowo niezawodne dla LPE.

## Deterministyczne przygotowanie układu przy użyciu API rejestru

Ponieważ alokacja hive jest deterministyczna, możesz przygotować rozmieszczenie komórek wyłącznie przy użyciu Win32 APIs. Typowy przebieg pracy to:

1. **Zresetuj docelowy klucz** (usuń/odtwórz), tak aby hive bin zawierał tylko znane komórki.
2. **Zalokuj przewidywalne sekwencje komórek** przez tworzenie wartości o starannie dobranych rozmiarach:
- Komórki metadanych klucza/wartości mają rozmiary będące wielokrotnością 8 bajtów.
- Zapis wartości o rozmiarze `0x3FD8` bajtów wymusza świeży `0x4000`-bajtowy bin (`0x3FD8` danych + nagłówek/padding `_HBIN`), idealny do późniejszego przeplatania binów.
3. **Używaj typów przyjaznych zmianie rozmiaru** (np. `REG_BINARY`), dzięki czemu możesz zwalniać/rozszerzać pojedyncze komórki po prostu wywołując `RegSetValueEx` z różnymi długościami.
4. **Zarejestruj sekwencję** operacji (tworzenie/usuwanie/zmiana rozmiaru). Odtworzenie jej reprodukuje ten sam układ na innych systemach, ponieważ alokator nie ma losowości.

<details>
<summary>Przykład kształtowania układu (uproszczony C)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Once a corruption primitive (overwrite/fill) is available, the groom guarantees that the **target cell resides next to the sprayed holes**, enabling precise overwrites without heap spraying.

## API-only access to privileged hives via misconfigured descendants

Windows only evaluates the **ACL on the final component** of a registry path. If any descendant under HKLM/HKU grants `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY`, or `WRITE_DAC` to low-privileged users, you can reach it even when every parent key is locked down. Project Zero found **>1000 such writable keys in HKLM on Windows 11**, including long-lived entries like `HKLM\SOFTWARE\Microsoft\DRM` and several `HKLM\SYSTEM` branches.

Practical enumeration strategy:

1. From an elevated context, walk `\Registry\Machine` and `\Registry\User`, dumping each key’s security descriptor. Store items whose DACL allows unprivileged SIDs.
2. As a normal user, attempt `RegOpenKeyEx` with `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` against the recorded paths. Successful opens are viable targets for hive corruption bugs that require attacker-controlled data in system hives.
3. Maintain a cache of open handles to **stable writable locations** so PoCs can directly deploy corrupted metadata.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Once such a path is known, the exploit never needs offline hive tampering—**standard registry APIs are enough** to stage the corrupt cells inside privileged hives touched by SYSTEM services.

## Cross-user hive abuse via `HKCU\Software\Microsoft\Input\TypingInsights`

Każdy hive użytkownika zawiera `HKCU\Software\Microsoft\Input\TypingInsights`, którego ACL przyznaje `KEY_ALL_ACCESS` dla **Everyone (S-1-1-0).** Dopóki Microsoft tego nie zaostrzy, dowolny użytkownik może:

- **Wypełnić hive innego użytkownika** do limitu 2 GiB, powodując błędy logowania lub wymuszając obcięcie hive (przydatne do wymuszenia zachowania alokatora lub DoS).
- **Upuścić uszkodzone cele (corrupted cells)** w `NTUSER.DAT` innego użytkownika, przygotowując lateralne eksploity, które uruchomią się, gdy proces ofiary odczyta skompromitowany klucz.
- **Modyfikować differencing hives** dla aplikacji w sandboxie, które polegają na per-user overlay hives, zmuszając je do użycia złośliwych metadanych.

To sprawia, że podatności na korupcję hive są użyteczne do **lateral movement**, nie tylko do eskalacji w obrębie tego samego konta.

## Turning metadata corruption into paged pool overflows

Large registry values are stored in `_CM_BIG_DATA` records:

- `_CM_KEY_VALUE.DataLength` holds the logical size. Its high bit indicates whether the payload lives inside the cell or in big-data storage.
- `_CM_BIG_DATA.Count` counts **16 KiB chunks** (16384 bytes minus metadata) referenced via a chunk table.

When any component calls `CmpGetValueData`:

1. The kernel allocates a **paged pool buffer** sized strictly from `DataLength`.
2. It copies `Count * 0x4000` bytes from hive storage into that buffer.

If you can corrupt the cell so `DataLength < 16344 * (Count - 1)`, the copy **overruns the destination linearly** into adjacent paged-pool objects. A reliable exploit chain is:

1. Use the deterministic groom to place the vulnerable `_CM_KEY_VALUE` near controllable metadata.
2. Flip `DataLength` to a small number (e.g., 0x100) while leaving `_CM_BIG_DATA.Count` intact.
3. Pool-groom from user mode (pipes, ALPC ports, section objects) so a chosen object (like `EPROCESS->Token` owner or `SRVNET_BUFFER`) occupies the next chunk after the allocation from step 1.
4. Trigger a read (e.g., `RegQueryValueEx`, `NtQueryValueKey`) so `CmpGetValueData` copies all chunks and **overwrites the neighbor’s fields** with attacker-controlled data from the hive.
5. Use the corrupted kernel object to pivot to arbitrary read/write or direct SYSTEM token theft.

Because the overflow length equals `(Count * 0x4000) - DataLength`, you get a **precise byte budget** and full control over the bytes written, outperforming many driver-based pool overflows.

## Inter-hive linear overflows via tightly packed HBINs

Hives mounted by the Registry process are mapped in **2 MiB-aligned views** with **no guard gaps**. You can force two different hives to grow in lockstep until their `_HBIN` ranges touch:

1. Choose an attacker-writable hive (app hive or user hive) and a privileged target (e.g., `HKLM\SOFTWARE`).
2. Continuously create/delete `0x3FD8`-byte values in both hives. Each allocation adds a `0x4000`-byte bin, so running both writers in parallel interleaves their bins in virtual memory (observed with `!process Registry` + `!vad`).
3. Once the final bin of the attacker hive sits immediately before an HBIN belonging to HKLM, use the hive corruption bug to **overflow out of the attacker hive**, smashing HBIN headers or cells inside HKLM.
4. With HKLM metadata under control you can:
- Stage a big-data inconsistency primitive directly in the privileged hive.
- Corrupt configuration data consumed by SYSTEM services before it ever leaves the kernel.

The absence of guard pages means a linear overwrite from an unprivileged hive can **directly corrupt SYSTEM-owned hive structures**, enabling data-only attacks or setting up the pool overflow described above inside HKLM/HKU.

## Operational tips

- Monitor hive placement with `!vad` (user-mode) and `!reg view` / `!pool` (kernel) to confirm adjacency before triggering the overflow.
- Cache writable HKLM paths discovered during enumeration so corruption primitives can be deployed quickly even after reboots.
- Combine hive grooming with standard pool feng shui (pipe pair freelists, `NtAllocateVirtualMemory` on `
Registry` process) to stabilize post-overflow primitives.

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
