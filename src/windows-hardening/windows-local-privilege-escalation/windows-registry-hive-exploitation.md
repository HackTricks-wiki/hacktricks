# Windows Registry Hive Exploitation Primitives

{{#include ../../banners/hacktricks-training.md}}

## Why hive corruption is special

Windows registry hives are **memory-mapped `.regf` files** managed by a custom allocator (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`). The allocator:

- **Does not randomize allocations** – सेल प्लेसमेंट केवल पिछले registry API कॉल्स के क्रम/आकार पर निर्भर करता है, इसलिए लेआउट अन्य होस्ट्स पर दोहराए जा सकते हैं।
- **Lacks integrity checks** – मैन्युअली बदले गए header/data फ़ील्ड्स को kernel consumers (`Cmp*` routines) और Registry process स्वयं द्वारा ट्रस्ट किया जाता है।
- **Shares address space with privileged hives** – कई मामलों में attacker-controlled hives वही user-mode address range में map होते हैं जैसा HKLM/HKU hives, जिससे inter-hive overflows संभव होते हैं।

यह hive-based memory corruption बग्स (उदा., CVE-2023-23420 / CVE-2023-23423) को LPE के लिए विशिष्ट रूप से विश्वसनीय बनाता है।

## Deterministic layout grooming with registry APIs

Because hive allocation is deterministic, you can groom cell placement purely via Win32 APIs. A typical workflow is:

1. **Reset the target key** (delete/recreate) ताकि hive bin में सिर्फ ज्ञात cells रहें।
2. **Allocate predictable runs of cells** by creating values with carefully selected sizes:
- Key/value metadata cells are multiples of 8 bytes.
- Writing `0x3FD8`-byte values forces a fresh `0x4000`-byte bin (`0x3FD8` data + `_HBIN` header/padding), ideal for interleaving bins later.
3. **Use resize-friendly types** (e.g., `REG_BINARY`) ताकि आप अलग-अलग lengths के साथ `RegSetValueEx` कॉल करके व्यक्तिगत cells को free/extend कर सकें।
4. **Record the sequence** of operations (create/delete/resize). Replaying it reproduces the same layout on other systems because the allocator has no randomness.

<details>
<summary>उदाहरण लेआउट शैपर (सरलीकृत C)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

एक बार corruption primitive (overwrite/fill) उपलब्ध हो जाने पर, groom यह सुनिश्चित करता है कि **target cell resides next to the sprayed holes**, जिससे सटीक overwrites बिना heap spraying के संभव होते हैं।

## API-only access to privileged hives via misconfigured descendants

Windows केवल registry path के अंतिम component पर मौजूद **ACL on the final component** का ही मूल्यांकन करता है। यदि HKLM/HKU के किसी descendant ने low-privileged users को `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY`, या `WRITE_DAC` दिया हुआ है, तो आप उस key तक पहुँच सकते हैं भले ही प्रत्येक parent key लॉक हो। Project Zero ने Windows 11 पर HKLM में **>1000 such writable keys in HKLM on Windows 11** पाए, जिनमें लंबे समय तक रहने वाले एंट्रीज़ जैसे `HKLM\SOFTWARE\Microsoft\DRM` और कई `HKLM\SYSTEM` ब्रांच शामिल हैं।

Practical enumeration strategy:

1. एक elevated context से `\Registry\Machine` और `\Registry\User` को चलाएँ, और प्रत्येक key का security descriptor dump करें। उन items को स्टोर करें जिनकी DACL unprivileged SIDs को अनुमति देती है।
2. सामान्य user के रूप में रिकॉर्ड किए गए paths के खिलाफ `RegOpenKeyEx` को `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` के साथ आजमाएँ। सफल opens उन hive corruption bugs के लिए उपयुक्त लक्ष्य होते हैं जिनके लिए system hives में attacker-controlled data की आवश्यकता होती है।
3. PoCs सीधे corrupted metadata तैनात कर सकें, इसके लिए open handles का cache **stable writable locations** के लिए बनाए रखें।
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
एक बार ऐसा पथ ज्ञात हो जाने पर, exploit को कभी भी offline hive छेड़छाड़ की जरूरत नहीं पड़ती—**standard registry APIs पर्याप्त हैं** ताकि corrupt cells को privileged hives में stage किया जा सके जो SYSTEM सेवाओं द्वारा छुए जाते हैं।

## Cross-user hive दुरुपयोग `HKCU\Software\Microsoft\Input\TypingInsights` के माध्यम से

हर उपयोगकर्ता hive में `HKCU\Software\Microsoft\Input\TypingInsights` होता है, जिसकी ACL `KEY_ALL_ACCESS` **Everyone (S-1-1-0)** को देती है। जब तक Microsoft इसे कड़ा नहीं करती, कोई भी उपयोगकर्ता कर सकता है:

- **Fill another user’s hive** up to the 2 GiB limit, causing logon failures or forcing hive truncation (useful to coerce allocator behavior or DoS).
- **Drop corrupted cells** into other users’ `NTUSER.DAT`, setting up lateral exploits that trigger when the victim process reads the compromised key.
- **Modify differencing hives** for sandboxed apps that rely on per-user overlay hives, forcing them to consume malicious metadata.

यह hive corruption vulnerabilities को केवल उसी खाते में elevation तक सीमित नहीं रखता, बल्कि **lateral movement** के लिए भी लागू बनाता है।

## मेटाडेटा करप्शन को paged pool overflows में बदलना

Large registry values `_CM_BIG_DATA` records में स्टोर होते हैं:

- `_CM_KEY_VALUE.DataLength` तर्कसंगत आकार (logical size) रखता है। इसका high bit दर्शाता है कि payload cell के अंदर रहता है या big-data storage में।
- `_CM_BIG_DATA.Count` संदर्भित chunk table के माध्यम से गिने गए **16 KiB chunks** (16384 bytes minus metadata) की गिनती करता है।

जब कोई component `CmpGetValueData` कॉल करता है:

1. कर्नेल `DataLength` से सख्ती से प्राप्त आकार के एक **paged pool buffer** को allocate करता है।
2. यह hive storage से `Count * 0x4000` bytes को उस buffer में copy करता है।

यदि आप cell को इस तरह corrupt कर सकते हैं कि `DataLength < 16344 * (Count - 1)`, तो copy लक्ष्य को linear रूप से overrun कर देगा और adjacent paged-pool objects में फैल जाएगा। एक विश्वसनीय exploit chain है:

1. Deterministic groom का उपयोग करके vulnerable `_CM_KEY_VALUE` को controllable metadata के पास रखें।
2. `DataLength` को छोटे मान (उदा., 0x100) में बदलें जबकि `_CM_BIG_DATA.Count` को बरकरार रखें।
3. User mode से pool-groom (pipes, ALPC ports, section objects) करें ताकि एक चुना हुआ object (जैसे `EPROCESS->Token` owner या `SRVNET_BUFFER`) allocation (step 1) के बाद अगले chunk में आ जाए।
4. एक read trigger करें (उदा., `RegQueryValueEx`, `NtQueryValueKey`) ताकि `CmpGetValueData` सभी chunks को copy करे और hive से attacker-controlled data के साथ **neighbor के fields को overwrite कर दे**।
5. Corrupted kernel object का उपयोग arbitrary read/write या सीधे SYSTEM token चोरी के लिए pivot करने में करें।

क्योंकि overflow लंबाई `(Count * 0x4000) - DataLength` के बराबर होती है, आपको एक **निश्चित byte बजट** मिलता है और लिखे गए bytes पर पूरी काबू रहती है, जो कई driver-based pool overflows से बेहतर होता है।

## टाइटली-पैक्ड HBINs के माध्यम से इंटर-hive linear overflows

Registry process द्वारा mount किए गए hives **2 MiB-aligned views** में map होते हैं और उनमें **no guard gaps** होते हैं। आप दो अलग hives को lockstep में बढ़ने के लिए मजबूर कर सकते हैं जब तक उनके `_HBIN` रेंज आपस में नहीं छूते:

1. एक attacker-writable hive चुनें (app hive या user hive) और एक privileged target (उदा., `HKLM\SOFTWARE`)।
2. दोनों hives में लगातार `0x3FD8`-byte values बनाएं/हटाएं। हर allocation एक `0x4000`-byte bin जोड़ता है, इसलिए दोनों writers को पैरेलल में चलाने से उनकी bins virtual memory में इंटरलीव हो जाती हैं (देखा गया `!process Registry` + `!vad` के साथ)।
3. जब attacker hive का अंतिम bin तुरंत HKLM के HBIN से पहले आ जाए, तो hive corruption bug का उपयोग करके **attacker hive से overflow करें**, HBIN headers या HKLM के अंदर cells को नष्ट करते हुए।
4. HKLM metadata पर नियंत्रण होने पर आप कर सकते हैं:
- privileged hive में सीधे एक big-data inconsistency primitive स्टेज करें।
- SYSTEM services द्वारा उपयोग की जाने वाली configuration data को kernel से बाहर जाने से पहले corrupt करें।

guard pages की अनुपस्थिति का मतलब है कि unprivileged hive से linear overwrite सीधे **SYSTEM-owned hive structures को corrupt** कर सकता है, जिससे data-only attacks सक्षम होते हैं या ऊपर वर्णित pool overflow को HKLM/HKU के अंदर सेटअप किया जा सकता है।

## ऑपरेशनल टिप्स

- overflow trigger करने से पहले adjacency की पुष्टि के लिए `!vad` (user-mode) और `!reg view` / `!pool` (kernel) के साथ hive placement की निगरानी करें।
- enumeration के दौरान मिले writable HKLM paths को cache करें ताकि corruption primitives reboots के बाद भी जल्दी तैनात किए जा सकें।
- hive grooming को standard pool feng shui (pipe pair freelists, `NtAllocateVirtualMemory` on `
Registry` process) के साथ मिलाएं ताकि post-overflow primitives स्थिर रहें।

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
