# Windows Registry Hive Exploitation Primitives

{{#include ../../banners/hacktricks-training.md}}

## Waarom hive-korrupsie spesiaal is

Windows registry-hives is **geheue-gemappeerde `.regf`-lêers** wat bestuur word deur 'n pasgemaakte allocator (`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`). Die allocator:

- **Randomiseer nie toewysings nie** – selplasing hang slegs af van die volgorde/grootte van vorige registry API-oproepe, so uitlegte is reproduseerbaar oor gashere.
- **Ontbreek integriteitskontroles** – handmatig veranderde header-/data-velde word vertrou deur kernel-konsumptors (`Cmp*` routines) en deur die Registry-proses self.
- **Deel adresruimte met geprivilegieerde hives** – in baie gevalle word aanvaller-beheerde hives in dieselfde user-mode adresreeks as HKLM/HKU hives gemap, wat inter-hive overflows moontlik maak.

Dit maak hive-gebaseerde geheuekorrupsie-foute (bv. CVE-2023-23420 / CVE-2023-23423) uiters betroubaar vir LPE.

## Deterministiese uitleg-grooming met registry API's

Omdat hive-toewysing deterministies is, kan jy die selplasing uitsluitlik met Win32 API's vorm. 'n Tipiese werkvloei is:

1. **Reset die teiken-sleutel** (verwyder/herskep) sodat die hive-bin slegs bekende selle bevat.
2. **Wys voorspelbare reekse selle toe** deur waardes te skep met sorgvuldig gekose groottes:
- Sleutel/waarde metadata-selle is veelvoude van 8 bytes.
- Skryf van `0x3FD8`-byte waardes dwing 'n vars `0x4000`-byte bin af (`0x3FD8` data + `_HBIN` header/padding), ideaal om later bins te interleaf.
3. **Gebruik resize-vriendelike tipes** (bv. `REG_BINARY`) sodat jy individuele selle net kan vrystel/uitbrei deur `RegSetValueEx` met verskillende lengtes aan te roep.
4. **Neem die volgorde van operasies op** (create/delete/resize). Deur dit te herhaal reproduseer jy dieselfde uitleg op ander stelsels omdat die allocator geen ewekansigheid het nie.

<details>
<summary>Voorbeeld layout-shaper (vereenvoudigde C)</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Sodra 'n corruption primitive (overwrite/fill) beskikbaar is, verseker die groom dat die **target cell resides next to the sprayed holes**, wat akkurate overwrites moontlik maak sonder heap spraying.

## API-only access to privileged hives via misconfigured descendants

Windows evalueer slegs die **ACL op die finale komponent** van 'n registry path. If any descendant under HKLM/HKU grants `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY`, or `WRITE_DAC` to low-privileged users, you can reach it even when every parent key is locked down. Project Zero found **>1000 such writable keys in HKLM on Windows 11**, including long-lived entries like `HKLM\SOFTWARE\Microsoft\DRM` and several `HKLM\SYSTEM` branches.

Praktiese enumerasie-strategie:

1. Vanaf 'n elevated context, loop deur `\Registry\Machine` en `\Registry\User`, en dump elke sleutel se security descriptor. Stoor items waarvan die DACL unprivileged SIDs toelaat.
2. As 'n normal user, probeer `RegOpenKeyEx` met `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` teen die aangetekende paths. Suksesvolle opens is geskikte teikens vir hive corruption bugs wat attacker-controlled data in system hives vereis.
3. Behou 'n cache van open handles na **stable writable locations** sodat PoCs direk gecorrupteerde metadata kan ontplooi.
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
Sodra so 'n pad bekend is, hoef die exploit nooit offline hive tampering te doen nie—**standaard registry APIs is genoeg** om die gekorrupte selle binne geprivilegieerde hives wat deur SYSTEM-dienste aangeraak word, te posisioneer.

## Kruisgebruiker-hive-misbruik via `HKCU\Software\Microsoft\Input\TypingInsights`

Elke gebruiker-hive bevat `HKCU\Software\Microsoft\Input\TypingInsights`, waarvan die ACL `KEY_ALL_ACCESS` aan **Everyone (S-1-1-0).** toeken. Tot Microsoft dit verskerp, kan enige gebruiker:

- **Vul 'n ander gebruiker se hive** tot die 2 GiB-grens, wat aanmeldingsfoute veroorsaak of hive-trunkering afdwing (nuttig om allocator-gedrag te dwing of DoS).
- **Drop corrupted cells** into other users’ `NTUSER.DAT`, setting up lateral exploits that trigger when the victim process reads the compromised key.
- **Wysig differencing hives** vir sandboxed apps wat op per-user overlay hives staatmaak, en dwing hulle om kwaadwillige metadata te gebruik.

Dit maak hive-korruptie kwesbaarhede toepaslik vir **lateral movement**, nie net opgradering binne dieselfde rekening nie.

## Omskep metadata-korruptie in paged pool overflows

Groot registry-waardes word gestoor in `_CM_BIG_DATA` rekords:

- `_CM_KEY_VALUE.DataLength` hou die logiese grootte. Die hoë bit dui aan of die payload binne die sel bly of in big-data stoorplek.
- `_CM_BIG_DATA.Count` tel **16 KiB chunks** (16384 bytes minus metadata) wat via 'n chunk table verwys word.

Wanneer enige komponent `CmpGetValueData` aanroep:

1. Die kernel ken 'n **paged pool buffer** toe wat presies op `DataLength` geskaal is.
2. Dit kopieer `Count * 0x4000` bytes uit die hive-stoorplek na daardie buffer.

As jy die sel kan korrupteer sodat `DataLength < 16344 * (Count - 1)`, oorloop die kopieeroperasie **lineêr die bestemming** in aangrensende paged-pool-objekte. 'n betroubare exploit chain is:

1. Gebruik die deterministic groom om die kwesbare `_CM_KEY_VALUE` naby beheerbare metadata te plaas.
2. Flip `DataLength` na 'n klein getal (bv. 0x100) terwyl `_CM_BIG_DATA.Count` onaangeraak bly.
3. Pool-groom vanaf user mode (pipes, ALPC ports, section objects) sodat 'n gekose objek (soos `EPROCESS->Token` owner of `SRVNET_BUFFER`) die volgende chunk ná die toewysing uit stap 1 beset.
4. Trigger 'n lees (bv. `RegQueryValueEx`, `NtQueryValueKey`) sodat `CmpGetValueData` al die chunks kopieer en **oor-skryf die buurman se velde** met aanvaller-beheerde data uit die hive.
5. Gebruik die gekorrupte kernel-objek om te pivot na arbitraire read/write of direkte SYSTEM token-diefstal.

Omdat die overflow-lengte gelyk is aan `(Count * 0x4000) - DataLength`, kry jy 'n **presiese byte-begroting** en volle beheer oor die geskryfde bytes, wat baie driver-gebaseerde pool overflows oortrump.

## Inter-hive lineêre overflows via diggepakte HBINs

Hives wat deur die Registry-proses gemount is, word in **2 MiB-gealigneerde views** gemap met **no guard gaps**. Jy kan twee verskillende hives dwing om sinchronies te groei totdat hul `_HBIN`-reekse mekaar raak:

1. Kies 'n attacker-writable hive (app hive of user hive) en 'n geprivilegieerde teiken (bv. `HKLM\SOFTWARE`).
2. Skep/verwyder deurlopend `0x3FD8`-byte waardes in beide hives. Elke toewysing voeg 'n `0x4000`-byte bin by, so om albei skrywers parallel te laat loop sal hul bins in virtuele geheue afwissel (waargeneem met `!process Registry` + `!vad`).
3. Sodra die finale bin van die attacker hive onmiddellik voor 'n HBIN wat aan HKLM behoort sit, gebruik die hive corruption bug om **uit die attacker hive te overflow**, en HBIN-headers of selle binne HKLM te vernietig.
4. Met HKLM-metadata onder beheer kan jy:
- Stage a big-data inconsistency primitive directly in the privileged hive.
- Corrupt configuration data consumed by SYSTEM services before it ever leaves the kernel.

Die afwesigheid van guard pages beteken 'n lineêre oorskryding vanaf 'n ongeprivilegieerde hive kan **direk hive-strukture wat deur SYSTEM besit word korrupteer**, wat data-only aanvalle moontlik maak of die pool overflow wat hierbo beskryf is in HKLM/HKU opstel.

## Operasionele wenke

- Monitor hive-plaatsing met `!vad` (user-mode) en `!reg view` / `!pool` (kernel) om buurnabydheid te bevestig voordat die overflow getrigger word.
- Cache writable HKLM-paaie wat tydens enumerasie ontdek is sodat korrupsie-primitives vinnig ontplooi kan word selfs na herstart.
- Kombineer hive grooming met standaard pool feng shui (pipe pair freelists, `NtAllocateVirtualMemory` op die `Registry` proses) om post-overflow primitives te stabiliseer.

## Verwysings

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
