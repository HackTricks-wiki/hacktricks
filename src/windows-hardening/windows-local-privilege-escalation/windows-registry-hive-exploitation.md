# Windows Registry Hive Exploitation Primitives

{{#include ../../banners/hacktricks-training.md}}

## なぜ hive の破損が特別なのか

Windows のレジストリハイブは **メモリマップされた `.regf` ファイル** で、カスタムアロケータ（`HvAllocateCell`, `HvReallocateCell`, `HvFreeCell`）によって管理されます。アロケータは次の特徴を持ちます:

- **割り当てをランダム化しない** – セルの配置は以前の registry API 呼び出しの順序やサイズにのみ依存するため、レイアウトはホスト間で再現可能です。
- **整合性チェックが欠けている** – 手動で変更したヘッダ/データフィールドはカーネル側の消費者（`Cmp*` ルーチン）や Registry プロセス自体によって信用されます。
- **特権ハイブとアドレス空間を共有する** – 多くの場合、攻撃者が制御するハイブは HKLM/HKU ハイブと同じユーザーモードのアドレス範囲にマップされ、ハイブ間オーバーフローが可能になります。

これにより、hive ベースのメモリ破損バグ（例: CVE-2023-23420 / CVE-2023-23423）は LPE に対して非常に信頼性の高い手法になります。

## レジストリ API を使った決定論的レイアウト整形

ハイブの割り当てが決定論的であるため、Win32 API のみでセルの配置を整形できます。典型的なワークフローは次のとおりです:

1. **ターゲットキーをリセット**（削除/再作成）して、hive bin が既知のセルのみを含むようにする。
2. **慎重に選んだサイズの値を作成して予測可能なセルの連続を割り当てる**:
   - キー/値のメタデータセルは 8 バイトの倍数です。
   - `0x3FD8` バイトの値を書き込むと、新しい `0x4000` バイトの bin（`0x3FD8` データ + `_HBIN` ヘッダ/パディング）が作られ、後で bin をインターリーブするのに最適です。
3. **リサイズに適した型を使用する**（例: `REG_BINARY`）。こうすることで、`RegSetValueEx` を異なる長さで呼ぶだけで個々のセルを解放/拡張できます。
4. **操作のシーケンスを記録する**（作成/削除/リサイズ）。アロケータにランダム性がないため、それを再生すると他のシステム上でも同じレイアウトが再現されます。

<details>
<summary>レイアウト整形の例（簡易 C）</summary>
```c
void MakeBin(HKEY base, const wchar_t *name, size_t bytes) {
std::vector<uint8_t> buf(bytes, 0x41);
RegSetKeyValueW(base, NULL, name, REG_BINARY, buf.data(), (DWORD)buf.size());
}

void Groom(HKEY hive) {
for (int i = 0; i < 0x20; ++i) {
wchar_t value[32];
swprintf(value, L"bin_%02d", i);
MakeBin(hive, value, 0x3FD8);
RegDeleteKeyValueW(hive, NULL, value); // leaves holes for victim cells
}
}
```
</details>

Once a corruption primitive (overwrite/fill) is available, the groom guarantees that the **target cell resides next to the sprayed holes**, enabling precise overwrites without heap spraying.

## 誤設定された子孫キーを介した API-only アクセスによる特権ハイブ

Windows はレジストリパスの**最終コンポーネントの ACL のみを評価**します。HKLM/HKU の下位にあるいずれかの descendant が `KEY_SET_VALUE`, `KEY_CREATE_SUB_KEY`, または `WRITE_DAC` を低権限ユーザーに付与している場合、親キーがすべてロックダウンされていてもそこに到達できます。Project Zero は `HKLM` に **>1000 such writable keys in HKLM on Windows 11** を発見しており、`HKLM\SOFTWARE\Microsoft\DRM` のような長期間存在するエントリやいくつかの `HKLM\SYSTEM` ブランチが含まれます。

Practical enumeration strategy:

1. 昇格したコンテキストから `\Registry\Machine` と `\Registry\User` を辿り、各キーのセキュリティ記述子をダンプする。DACL が unprivileged SIDs を許可しているアイテムを保存する。
2. 通常ユーザーとして、記録したパスに対して `KEY_SET_VALUE|KEY_CREATE_SUB_KEY` 指定で `RegOpenKeyEx` を試みる。オープンに成功したものは、システムハイブ内の攻撃者制御データを必要とする hive corruption バグに対する有効なターゲットとなる。
3. PoC が破損したメタデータを直接展開できるよう、open handles のキャッシュを **stable writable locations** に対して維持する。
```powershell
$targets = Get-ChildItem Registry::HKEY_LOCAL_MACHINE -Recurse |
Where-Object { (Get-Acl $_.PsPath).Access.IdentityReference -match 'S-1-5-32-545' } |
Select-Object -ExpandProperty PsPath

foreach ($path in $targets) {
try { Get-Item -Path $path -ErrorAction Stop | Out-Null }
catch {}
}
```
一旦そのようなパスが判明すれば、エクスプロイトはオフラインでのハイブ改変を行う必要はなく、**標準のレジストリ API だけで** SYSTEM サービスが触る特権ハイブ内に破損セルを仕込める。

## Cross-user hive abuse via `HKCU\Software\Microsoft\Input\TypingInsights`

各ユーザーハイブには `HKCU\Software\Microsoft\Input\TypingInsights` が含まれており、その ACL は `KEY_ALL_ACCESS` を **Everyone (S-1-1-0).** に付与している。Microsoft がこれを締め付けるまでは、任意のユーザーが以下を実行できる：

- 別ユーザーのハイブを 2 GiB の上限まで埋め、ログオン失敗やハイブの切詰めを引き起こす（アロケータ挙動の誘導や DoS に有用）。
- 他ユーザーの `NTUSER.DAT` に破損セルを挿入し、被害者プロセスが改ざんされたキーを読むと発動する横移動用のエクスプロイトを仕込む。
- per-user overlay ハイブに依存するサンドボックス化アプリの差分ハイブを改変し、悪意あるメタデータを読み込ませる。

これによりハイブ破損脆弱性は同一アカウント内の権限昇格だけでなく、**横移動**にも応用可能になる。

## Turning metadata corruption into paged pool overflows

大きなレジストリ値は `_CM_BIG_DATA` レコードに格納される：

- `_CM_KEY_VALUE.DataLength` は論理サイズを保持する。上位ビットはペイロードがセル内部にあるかビッグデータ領域にあるかを示す。
- `_CM_BIG_DATA.Count` はチャンクテーブルで参照される **16 KiB チャンク**（メタデータを除いた16384バイト）を数える。

任意のコンポーネントが `CmpGetValueData` を呼ぶと：

1. カーネルは `DataLength` から厳密に決定されたサイズの**paged pool バッファ**を割り当てる。
2. ハイブストレージから `Count * 0x4000` バイトをそのバッファにコピーする。

セルを破損させて `DataLength < 16344 * (Count - 1)` とできれば、コピーは宛先を線形に越えて隣接する paged-pool オブジェクトへ**オーバーラン**する。信頼できるエクスプロイトチェーンは以下の通り：

1. 決定論的グルーミングを使い、脆弱な `_CM_KEY_VALUE` を制御可能なメタデータの近傍に配置する。
2. `_CM_BIG_DATA.Count` をそのままにして `DataLength` を小さな値（例: 0x100）に書き換える。
3. ユーザーモードからパイプ、ALPC ポート、セクションオブジェクトなどでプールグルーミングを行い、選択したオブジェクト（`EPROCESS->Token` 所有者や `SRVNET_BUFFER` など）がステップ1の割当て直後のチャンクを占有するようにする。
4. 読み取りをトリガー（例: `RegQueryValueEx`, `NtQueryValueKey`）して `CmpGetValueData` が全チャンクをコピーさせ、ハイブ由来の攻撃者制御データで隣接オブジェクトのフィールドを**上書き**させる。
5. 破損したカーネルオブジェクトを利用して任意の読み書きにピボットするか、直接 SYSTEM トークンの窃取を行う。

オーバーフロー長は `(Count * 0x4000) - DataLength` に等しいため、**正確なバイト予算**が得られ、書き込まれるバイトを完全に制御できる。多くのドライバベースのプールオーバーフローよりも優位である。

## Inter-hive linear overflows via tightly packed HBINs

Registry プロセスがマウントするハイブは **2 MiB アラインされたビュー** としてマップされ、**ガードギャップが存在しない**。二つの異なるハイブをロックステップで成長させ、彼らの `_HBIN` 範囲が接触するまで強制することができる：

1. 攻撃者が書き込み可能なハイブ（アプリハイブやユーザーハイブ）と、特権のターゲット（例: `HKLM\SOFTWARE`）を選ぶ。
2. 両ハイブで連続して `0x3FD8` バイトの値を作成/削除する。各割当は `0x4000` バイトの bin を追加するため、両方のライターを並行して動かすと仮想メモリ上で彼らの bin が交互に並ぶ（`!process Registry` + `!vad` で観察できる）。
3. 攻撃者ハイブの最後の bin が HKLM に属する HBIN の直前に位置したら、ハイブ破損バグを使って攻撃者ハイブから**オーバーフロー**させ、HKLM 内の HBIN ヘッダやセルを破壊する。
4. HKLM のメタデータを制御下に置けば：
   - 特権ハイブ内に直接ビッグデータ不整合のプリミティブを仕込む。
   - SYSTEM サービスがカーネルを出る前に消費する設定データを破壊する。

ガードページが存在しないため、非特権ハイブからの線形上書きは **SYSTEM 所有のハイブ構造を直接破壊** でき、データのみの攻撃や上記の HKLM/HKU 内でのプールオーバーフローの準備を可能にする。

## Operational tips

- オーバーフローをトリガーする前に隣接を確認するため、`!vad`（ユーザーモード）と `!reg view` / `!pool`（カーネル）でハイブ配置を監視する。
- 列挙中に見つけた書込可能な HKLM パスをキャッシュしておき、再起動後でも迅速に破壊プリミティブを展開できるようにする。
- ハイブグルーミングを標準的なプール整列（pipe pair freelists, `NtAllocateVirtualMemory` on `
Registry` process）と組み合わせてオーバーフロー後のプリミティブを安定化させる。

## References

- [Project Zero – The Windows Registry Adventure #8: Practical exploitation of hive memory corruption](https://projectzero.google/2025/05/the-windows-registry-adventure-8-exploitation.html)

{{#include ../../banners/hacktricks-training.md}}
