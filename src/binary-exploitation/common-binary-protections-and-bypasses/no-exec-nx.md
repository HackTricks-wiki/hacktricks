# No-exec / NX

{{#include ../../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

Το **No-Execute (NX)** bit, γνωστό επίσης ως **Execute Disable (XD)** στην ορολογία της Intel, είναι μια hardware-based λειτουργία ασφαλείας σχεδιασμένη να **mitigate** τις επιπτώσεις επιθέσεων **buffer overflow**. Όταν εφαρμόζεται και είναι ενεργοποιημένο, διαχωρίζει περιοχές μνήμης που προορίζονται για **εκτελέσιμο κώδικα** από αυτές που προορίζονται για **δεδομένα**, όπως το **stack** και **heap**. Η βασική ιδέα είναι να αποτραπεί ένας attacker από το να εκτελέσει κακόβουλο κώδικα μέσω ευπαθειών buffer overflow τοποθετώντας τον κακόβουλο κώδικα στο stack για παράδειγμα και κατευθύνοντας εκεί τη ροή εκτέλεσης.

Τα σύγχρονα λειτουργικά συστήματα εφαρμόζουν το NX μέσω των attributes του page table που υποστηρίζουν τα ELF program headers. Για παράδειγμα, το `PT_GNU_STACK` header σε συνδυασμό με τις ιδιότητες `GNU_PROPERTY_X86_FEATURE_1_SHSTK` ή `GNU_PROPERTY_X86_FEATURE_1_IBT` ενημερώνουν τον loader για το αν το stack πρέπει να είναι **RW** ή **RWX**. Όταν το NX είναι ενεργοποιημένο και το binary συνδέθηκε με μη εκτελέσιμο stack (`-z noexecstack`), οποιαδήποτε προσπάθεια να περιστραφεί η εκτέλεση σε attacker-controlled σελίδες δεδομένων (stack, heap, mmap'ed buffers, κ.λπ.) θα προκαλέσει σφάλμα εκτός εάν αυτές οι σελίδες είχαν ρητά σημειωθεί ως εκτελέσιμες.

### Γρήγορος εντοπισμός του NX

- `checksec --file ./vuln` θα εμφανίσει `NX enabled` ή `NX disabled` βάσει του `GNU_STACK` program header.
- `readelf -W -l ./vuln | grep GNU_STACK` εμφανίζει τα permissions του stack· η παρουσία της σημαίας `E` υποδηλώνει ότι το stack είναι εκτελέσιμο. Παράδειγμα:
```bash
$ readelf -W -l ./vuln | grep GNU_STACK
GNU_STACK      0x000000 0x000000 0x000000 0x000000 0x000000 RW  0x10
```
- `execstack -q ./vuln` (from `prelink`) είναι χρήσιμο όταν ελέγχετε μεγάλες συλλογές binaries γιατί εκτυπώνει `X` για binaries που εξακολουθούν να έχουν executable stack.
- Σε runtime, `/proc/<pid>/maps` θα δείξει αν μια κατανομή είναι `rwx`, `rw-`, `r-x`, κ.λπ., κάτι που είναι χρήσιμο όταν επαληθεύετε JIT engines ή custom allocators.

## Παρακάμψεις

### Code-reuse primitives

It's possible to use techniques such as [**ROP**](../rop-return-oriented-programing/index.html) **to bypass** this protection by executing chunks of executable code already present in the binary. Typical chains include:

- [**Ret2libc**](../rop-return-oriented-programing/ret2lib/index.html)
- [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv/index.html)
- [**Ret2dlresolve**](../rop-return-oriented-programing/ret2dlresolve.md) when the binary does not import `system`/`execve`
- [**Ret2csu**](../rop-return-oriented-programing/ret2csu.md) or [**Ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) to synthesize syscalls
- **Ret2...** — any dispatcher that lets you stitch controlled register state with existing executable code to invoke syscalls or library gadgets.

The workflow is usually: (1) leak a code or libc pointer through an info leak, (2) resolve function bases, and (3) craft a chain that never needs attacker-controlled executable bytes.

### Sigreturn Oriented Programming (SROP)

SROP builds a fake `sigframe` on a writable page and pivots execution to `sys_rt_sigreturn` (or the relevant ABI equivalent). The kernel then “restores” the crafted context, instantly granting full control over all general-purpose registers, `rip`, and `eflags`. Recent CTF challenges (e.g., the *Hostel* task in n00bzCTF 2023) show how SROP chains first invoke `mprotect` to flip the stack to `RWX`, then reuse the same stack for shellcode, effectively bypassing NX even when only a single `syscall; ret` gadget is available. Check the dedicated [SROP page](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/README.md) for more architecture-specific tricks.

### Ret2mprotect / ret2syscall to flip permissions

If you can call `mprotect`, `pkey_mprotect`, or even `dlopen`, you can legitimately request an executable mapping before running shellcode. A small `pwntools` skeleton looks like:
```python
from pwn import *
elf = ELF("./vuln")
rop = ROP(elf)
rop.mprotect(elf.bss(), 0x1000, 7)
payload = flat({offset: rop.chain(), offset+len(rop.chain()): asm(shellcraft.sh())})
```
Η ίδια ιδέα εφαρμόζεται σε `ret2syscall` chains που θέτουν `rax=__NR_mprotect`, δείχνουν το `rdi` σε σελίδα `mmap`/`.bss`, αποθηκεύουν το επιθυμητό μήκος στο `rsi`, και θέτουν `rdx=7` (`PROT_RWX`). Μόλις υπάρξει περιοχή RWX, η εκτέλεση μπορεί με ασφάλεια να πηδήξει σε attacker-controlled bytes.

### RWX primitives από JIT engines και kernels

JIT engines, interpreters, GPU drivers, και υποσυστήματα του kernel που εκπέμπουν δυναμικά κώδικα είναι ένας κοινός τρόπος να ανακτηθεί εκτελέσιμη μνήμη ακόμα και υπό αυστηρές NX πολιτικές. Η ευπάθεια του Linux kernel του 2024 **CVE-2024-42067** έδειξε ότι σφάλματα στο `set_memory_rox()` άφηναν τις eBPF JIT σελίδες εγγράψιμες *και* εκτελέσιμες, επιτρέποντας σε επιτιθέμενους να ψεκάσουν gadgets ή ολόκληρα shellcode blobs μέσα στον kernel παρά τις προσδοκίες NX/W^X. Εκμεταλλεύσεις που αποκτούν τον έλεγχο ενός JIT compiler (BPF, JavaScript, Lua, κ.λπ.) μπορούν επομένως να τοποθετήσουν το payload τους σε αυτές τις RWX περιοχές και να χρειαστούν μόνο ένα function pointer overwrite για να πηδήξουν σε αυτές.

### Non-return code reuse (JOP/COP)

Αν οι εντολές `ret` έχουν ενισχυθεί (π.χ. CET/IBT) ή το binary στερείται εκφραστικών `ret` gadgets, στρέψτε την προσέγγιση σε **Jump-Oriented Programming (JOP)** ή **Call-Oriented Programming (COP)**. Αυτές οι τεχνικές κατασκευάζουν dispatchers που χρησιμοποιούν ακολουθίες `jmp [reg]` ή `call [reg]` που υπάρχουν στο binary ή στις φορτωμένες βιβλιοθήκες. Σεβάζονται ακόμα το NX επειδή επαναχρησιμοποιούν υπάρχοντα εκτελέσιμο κώδικα, αλλά παρακάμπτουν mitigations που ειδικά παρακολουθούν μεγάλες αλυσίδες εντολών `ret`.

{{#ref}}
../rop-return-oriented-programing/README.md
{{#endref}}

## References

- [CVE-2024-42067 - Linux kernel eBPF JIT set\_memory\_rox failure](https://nvd.nist.gov/vuln/detail/CVE-2024-42067)
- [n00bzCTF 2023 - Hostel (SROP) writeup](https://ctftime.org/writeup/37315)

{{#include ../../banners/hacktricks-training.md}}
