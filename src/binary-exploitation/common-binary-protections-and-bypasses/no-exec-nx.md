# No-exec / NX

{{#include ../../banners/hacktricks-training.md}}

## 基本情報

The **No-Execute (NX)** bit, also known as **Execute Disable (XD)** in Intel terminology, is a hardware-based security feature designed to **軽減** the effects of **buffer overflow** attacks. When implemented and enabled, it distinguishes between memory regions that are intended for **executable code** and those meant for **data**, such as the **stack** and **heap**. The core idea is to prevent an attacker from executing malicious code through buffer overflow vulnerabilities by putting the malicious code in the stack for example and directing the execution flow to it.

Modern operating systems enforce NX through the page table attributes that back the ELF program headers. For example, the `PT_GNU_STACK` header combined with the `GNU_PROPERTY_X86_FEATURE_1_SHSTK` or `GNU_PROPERTY_X86_FEATURE_1_IBT` properties let the loader know whether the stack should be **RW** or **RWX**. When NX is enabled and the binary was linked with a non-executable stack (`-z noexecstack`), any attempt to pivot execution into attacker-controlled data pages (stack, heap, mmap'ed buffers, etc.) will raise a fault unless those pages were explicitly marked as executable.

### NX を素早く検出する

- `checksec --file ./vuln` は `GNU_STACK` プログラムヘッダに基づき `NX enabled` または `NX disabled` を表示します。
- `readelf -W -l ./vuln | grep GNU_STACK` は stack の権限を表示します。`E` フラグが存在する場合、`stack` が実行可能であることを示します。例：
```bash
$ readelf -W -l ./vuln | grep GNU_STACK
GNU_STACK      0x000000 0x000000 0x000000 0x000000 0x000000 RW  0x10
```
- `execstack -q ./vuln` (from `prelink`) は、大量のバイナリを監査する際に便利で、実行可能なスタックを持つバイナリには `X` を表示します。
- 実行時、`/proc/<pid>/maps` は割り当てが `rwx`、`rw-`、`r-x` などかを示します。これは JIT engines や custom allocators を検証する際に有用です。

## 回避

### Code-reuse primitives

バイナリ内に既に存在する実行可能コードの断片を実行することで、この保護を回避するために [**ROP**](../rop-return-oriented-programing/index.html) のような手法を使用することが可能です。典型的なチェーンには次が含まれます:

- [**Ret2libc**](../rop-return-oriented-programing/ret2lib/index.html)
- [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv/index.html)
- [**Ret2dlresolve**](../rop-return-oriented-programing/ret2dlresolve.md) — バイナリが `system`/`execve` をインポートしていない場合
- [**Ret2csu**](../rop-return-oriented-programing/ret2csu.md) または [**Ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) — syscalls を合成するため
- **Ret2...** — コントロールされたレジスタ状態を既存の実行可能コードとつなぎ合わせて syscalls や library gadgets を呼び出すことを可能にする任意のディスパッチャ

ワークフローは通常: (1) info leak を通じてコードや libc ポインタを leak し、(2) 関数のベースを解決し、(3) 攻撃者が制御する実行可能バイトを必要としないチェーンを作成します。

### Sigreturn Oriented Programming (SROP)

SROP は writable ページ上に偽の `sigframe` を構築し、`sys_rt_sigreturn`（または該当する ABI の同等機能）へ実行をピボットします。カーネルはその後、作成されたコンテキストを「復元」し、全ての汎用レジスタ、`rip`、および `eflags` の完全な制御を即座に与えます。最近の CTF チャレンジ（例: n00bzCTF 2023 の *Hostel* タスク）は、SROP チェーンがまず `mprotect` を呼び出してスタックを `RWX` に反転させ、同じスタックを shellcode に再利用することで、`syscall; ret` ガジェットが1つしか利用できない場合でも NX を事実上回避する方法を示しています。アーキテクチャ固有のトリックについては専用の [SROP page](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/README.md) を参照してください。

### Ret2mprotect / ret2syscall to flip permissions

もし `mprotect`、`pkey_mprotect`、あるいは `dlopen` を呼び出せるなら、shellcode を実行する前に正当に実行可能なマッピングを要求できます。小さな `pwntools` スケルトンは次のようになります:
```python
from pwn import *
elf = ELF("./vuln")
rop = ROP(elf)
rop.mprotect(elf.bss(), 0x1000, 7)
payload = flat({offset: rop.chain(), offset+len(rop.chain()): asm(shellcraft.sh())})
```
同じ考えは `ret2syscall` チェーンにも当てはまります。これらは `rax=__NR_mprotect` を設定し、`rdi` を `mmap`/`.bss` ページに向け、目的の長さを `rsi` に格納し、`rdx=7` (`PROT_RWX`) を設定します。RWX 領域が一度存在すれば、実行は攻撃者制御のバイトに安全にジャンプできます。

### JITエンジンとカーネルからの RWX プリミティブ

JIT engines、インタプリタ、GPU drivers、動的にコードを生成するカーネルサブシステムは、厳しい NX ポリシー下でも実行可能メモリを取り戻す一般的な手段です。2024年の Linux カーネル脆弱性 **CVE-2024-42067** は `set_memory_rox()` の失敗により eBPF JIT ページが writable *and* executable のままになり、攻撃者が NX/W^X の期待にもかかわらずカーネル内にガジェットやシェルコードの塊を配置できることを示しました。したがって、JIT コンパイラ（BPF, JavaScript, Lua など）を制御するエクスプロイトは、ペイロードをそれらの RWX 領域に置き、単一の関数ポインタ上書きでそこへジャンプするだけで済むように仕組めます。

### 非リターン型コード再利用 (JOP/COP)

`ret` 命令が強化されている（例: CET/IBT）か、バイナリに表現力のある `ret` ガジェットが不足している場合は、Jump-Oriented Programming (JOP) や Call-Oriented Programming (COP) に切り替えます。これらの技術は、バイナリやロードされたライブラリ内にある `jmp [reg]` や `call [reg]` シーケンスを使ってディスパッチャを構築します。既存の実行可能コードを再利用するため NX を尊重しますが、大量の `ret` 命令チェーンを特に監視する緩和策を回避できます。

{{#ref}}
../rop-return-oriented-programing/README.md
{{#endref}}

## 参考文献

- [CVE-2024-42067 - Linux kernel eBPF JIT set\_memory\_rox failure](https://nvd.nist.gov/vuln/detail/CVE-2024-42067)
- [n00bzCTF 2023 - Hostel (SROP) writeup](https://ctftime.org/writeup/37315)

{{#include ../../banners/hacktricks-training.md}}
