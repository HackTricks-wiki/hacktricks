# Libc-beskermings

{{#include ../../banners/hacktricks-training.md}}

## Handhawing van chunk-uitlyning

**Malloc** ken geheue toe in **8-byte (32-bit) of 16-byte (64-bit) groepe**. Dit beteken die einde van chunks in 32-bit stelsels moet op **0x8** uitlyn, en in 64-bit stelsels op **0x0**. Die sekuriteitsfunksie kontroleer dat elke chunk **korrek uitlyn** by hierdie spesifieke plekke voordat 'n pointer uit 'n bin gebruik word.

### Sekuriteitsvoordele

Die afdwinging van chunk-uitlyning in 64-bit stelsels verbeter Malloc se sekuriteit aansienlik deur die plasing van fake chunks te beperk tot slegs 1 uit elke 16 adresse. Dit bemoeilik uitbuitingspogings, veral in scenario's waar die gebruiker beperkte beheer oor insetwaardes het, en maak aanvalle meer kompleks en moeiliker om suksesvol uit te voer.

- **Fastbin Attack on `__malloc_hook`**

Die nuwe uitlynreëls in Malloc keer ook 'n klassieke aanval raak wat by `__malloc_hook` betrokke is. Voorheen kon aanvallers chunk-groottes manipuleer om hierdie function pointer te oor-skryf en code execution te verkry. Nou verseker die streng uitlynvereiste dat sulke manipulasies nie meer lewensvatbaar is nie, wat 'n algemene uitbuitingsroete sluit en die algehele sekuriteit verbeter.

> **Note:** Sedert glibc **2.34** is die legacy hooks (`__malloc_hook`, `__free_hook`, ens.) verwyder uit die uitgevoerde ABI. Moderne exploits mik nou na ander skryfbare function pointers (bv. tcache per-thread struct, vtable-style callbacks) of vertrou op `setcontext`, `_IO_list_all` primitives, ens.

## Pointer Mangling on fastbins and tcache

**Pointer Mangling** is 'n sekuriteitsverbetering wat gebruik word om **fastbin en tcache Fd pointers** in geheuebestuur te beskerm. Hierdie tegniek help om sekere tipes geheue-uitbuitings, spesifiek dié wat nie 'n leak van geheue-inligting vereis nie of wat geheue-locaties direk relatief tot bekende posisies manipuleer (relative **overwrites**), te voorkom.

Die kern van hierdie tegniek is 'n obfuskasie-formule:

**`New_Ptr = (L >> 12) XOR P`**

- **L** is die **Storage Location** van die pointer.
- **P** is die werklike **fastbin/tcache Fd Pointer**.

Die redes vir die bit-verskuiwing van die stoorplek (L) met 12 bisse na regs voor die XOR-operasie is krities. Hierdie manipulering spreek 'n kwesbaarheid aan wat ingebed is in die deterministiese aard van die laaste 12 bisse van geheueadresse, wat tipies voorspelbaar is weens stelselargitektuurbeperkings. Deur die bisse te verskuif, word die voorspelbare gedeelte uit die vergelyking verwyder, wat die willekeur van die nuwe, gemanglede pointer verhoog en sodoende beskerming bied teen uitbuitings wat op die voorspelbaarheid van hierdie bisse staatmaak.

Hierdie gemanglede pointer maak gebruik van die bestaande willekeurigheid wat deur **Address Space Layout Randomization (ASLR)** verskaf word, wat adresse wat deur programme gebruik word randomiseer om dit moeilik te maak vir aanvallers om die geheue-indeling van 'n proses te voorspel.

**Demangling** van die pointer om die oorspronklike adres te herwin behels die gebruik van dieselfde XOR-operasie. Hier word die gemanglede pointer as P in die formule hanteer, en wanneer XOR met die onveranderde stoorplek (L) uitgevoer word, word die oorspronklike pointer onthul. Hierdie simmetrie in mangling en demangling verseker dat die stelsel pointers effektief kan enkodeer en dekodeer sonder aansienlike oorhoofse koste, terwyl dit substantieel die sekuriteit teen memory-pointer-manipulasies verhoog.

### Sekuriteitsvoordele

Pointer mangling poog om **gedeeltelike en volledige pointer-oor-skrywings in heap** bestuur te voorkom, 'n beduidende sekuriteitsverbetering. Hierdie funksie beïnvloed uitbuitingstegnieke op verskeie maniere:

1. **Voorkoming van Byte-vir-Byte Relative Overwrites**: Voorheen kon aanvallers deel van 'n pointer verander om heap chunks na verskillende plekke te herlei sonder om presiese adresse te ken, 'n tegniek wat te sien is in die leakless **House of Roman** exploit. Met pointer mangling vereis sulke relatiewe overskrywings **sonder 'n heap leak nou brute forcing**, wat hul kans op sukses drasties verlaag.
2. **Meer Moeilikheid met Tcache Bin/Fastbin Aanvalle**: Algemene aanvalle wat function pointers (soos `__malloc_hook`) oor-skryf deur fastbin of tcache inskrywings te manipuleer word belemmer. Byvoorbeeld, 'n aanval kan behels dat 'n LibC adres geleak word, 'n chunk in die tcache bin vrygestel word, en dan die Fd pointer oor-skryf om dit na `__malloc_hook` te herlei vir arbitrary code execution. Met pointer mangling moet hierdie pointers korrek gemangle wees, wat 'n heap leak vereis vir akkurate manipulering, en sodoende die uitbuitingsdrempel verhoog.
3. **Heap Leaks Vereis in Nie-Heap Ligginge**: Om 'n fake chunk in nie-heap areas (soos die stack, .bss-seksie, of PLT/GOT) te skep, vereis nou ook 'n heap leak as gevolg van die behoefte aan pointer mangling. Dit vergroot die kompleksiteit om hierdie areas uit te buit, soortgelyk aan die vereiste om LibC-adresse te manipuleer.
4. **Leaking van Heap Addresses Word Moeilik**: Pointer mangling beperk die bruikbaarheid van Fd pointers in fastbin en tcache bins as bronne vir heap address leaks. Pointers in unsorted, small, en large bins bly egter ongemangeld en bly dus bruikbaar vir adresse-leaks. Hierdie skuif dwing aanvallers om hierdie bins te ondersoek vir uitbuitbare inligting, al bestaan daar steeds tegnieke wat demangling van pointers voor 'n leak toelaat, wel met beperkings.

### **Safe-Linking Bypass (page-aligned leak scenario)**

Selfs met safe-linking geaktiveer (glibc ≥ 2.32), as jy die mangled pointer kan leak en beide die corrupted chunk en victim chunk dieselfde 4KB page deel, kan die oorspronklike pointer herkry word slegs met die page-offset:
```c
// leaked_fd is the mangled Fd read from the chunk on the same page
uintptr_t l = (uintptr_t)&chunk->fd;           // storage location
uintptr_t original = (leaked_fd ^ (l >> 12));  // demangle
```
Dit herstel die Fd en maak klassieke tcache/fastbin poisoning moontlik. As die chunks op verskillende bladsye lê, is dit dikwels uitvoerbaar om die 12-bit bladsyverskuiwing (0x1000 moontlikhede) te brute-forse wanneer toewysingspatrone deterministies is of wanneer crashes aanvaarbaar is (bv., CTF-style exploits).

### **Demangling Pointers with a Heap Leak**

> [!CAUTION]
> Vir 'n beter verduideliking van die proses [**check the original post from here**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Algorithm Overview

The formula used for mangling and demangling pointers is:

**`New_Ptr = (L >> 12) XOR P`**

Where **L** is the storage location and **P** is the Fd pointer. When **L** is shifted right by 12 bits, it exposes the most significant bits of **P**, due to the nature of **XOR**, which outputs 0 when bits are XORed with themselves.

**Belangrike stappe in die algoritme:**

1. **Initial Leak of the Most Significant Bits:** Deur die geskuifde **L** met **P** te XOR kry jy effektief die boonste 12 bits van **P**, omdat die geskuifde gedeelte van **L** nul sal wees en dus **P** se ooreenstemmende bits onaangeraak laat.
2. **Recovery of Pointer Bits:** Aangesien **XOR** omkeerbaar is, laat die kennis van die resultaat en een van die operande jou toe om die ander operan te bereken. Hierdie eienskap word gebruik om die volledige stel bits vir **P** af te lei deur opeenvolgend bekende bitstelle met dele van die mangled pointer te XOR.
3. **Iterative Demangling:** Die proses word herhaal, elke keer met behulp van die pas ontdekte bits van **P** van die vorige stap om die volgende segment van die mangled pointer te dekodeer, totdat alle bits herstel is.
4. **Handling Deterministic Bits:** Die finale 12 bits van **L** gaan verlore as gevolg van die skuif, maar hulle is deterministies en kan nà die proses herbou word.

Jy kan 'n implementering van hierdie algoritme hier vind: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer Guard is 'n exploit mitigation-tegniek wat in glibc gebruik word om gestoorde function pointers te beskerm, veral dié wat deur biblioteekoproepe soos `atexit()` geregistreer word. Hierdie beskerming draai die pointers deur hulle met 'n geheim in die thread data (`fs:0x30`) te XOR en 'n bitwise rotasie toe te pas. Die meganisme is daarop gemik om te verhoed dat aanvalle kontrolevloei kap deur function pointers oor te skryf.

### **Bypassing Pointer Guard with a leak**

1. **Understanding Pointer Guard Operations:** Die scrambling (mangling) van pointers word gedoen met die `PTR_MANGLE` macro wat die pointer met 'n 64-bit geheim XOR en dan 'n linker rotasie van 0x11 bits uitvoer. Die omgekeerde operasie om die oorspronklike pointer te herstel word hanteer deur `PTR_DEMANGLE`.
2. **Attack Strategy:** Die aanval is gebaseer op 'n known-plaintext benadering, waar die aanvaller beide die oorspronklike en die mangled weergawes van 'n pointer moet ken om die geheime wat vir die mangling gebruik is af te lei.
3. **Exploiting Known Plaintexts:**
- **Identifying Fixed Function Pointers:** Deur glibc-bronkode of geïnisialiseerde function pointer-tabelle (soos `__libc_pthread_functions`) te ondersoek, kan 'n aanvaller voorspelbare function pointers vind.
- **Computing the Secret:** Deur 'n bekende function pointer soos `__pthread_attr_destroy` en sy mangled weergawe uit die function pointer-tabel te gebruik, kan die geheim bereken word deur die mangled pointer regs-rotasie (reverse rotating) toe te pas en dan te XOR met die adres van die funksie.
4. **Alternative Plaintexts:** Die aanvaller kan ook eksperimenteer met die mangling van pointers met bekende waardes soos 0 of -1 om te sien of dit identifiseerbare patrone in geheue produseer, wat moontlik die geheim kan openbaar as hierdie patrone in geheue dumps gevind word.
5. **Practical Application:** Nadat die geheim bereken is, kan 'n aanvaller pointers op 'n beheerde wyse manipuleer en sodoende Pointer Guard in 'n multithreaded toepassing omseil, mits die libc-basisadres bekend is en daar die vermoë is om arbitrêre geheue-lokasies te lees.

## GLIBC Tunables & Recent Loader Bugs

Die dinamiese loader parse `GLIBC_TUNABLES` voor program-start. Mis-parsing bugs hier beïnvloed direk **libc** voordat meeste mitigasies in werking tree. Die 2023 "Looney Tunables" bug (CVE-2023-4911) is 'n voorbeeld: 'n oorlang `GLIBC_TUNABLES` waarde oorloop interne buffers in `ld.so`, wat **privilege escalation** op baie distros moontlik maak wanneer dit met SUID-binaries gekombineer word. Eksploitasie vereis net die kunsmatig samestel van die omgewing en herhaaldelik die teiken-binary aan te roep; pointer guard of safe-linking voorkom dit nie omdat die korrupsie in die loader plaasvind voordat die heap opgestel is.

## References

- [Safe-Linking bypass explanation (shellphish/how2heap)](https://deepwiki.com/shellphish/how2heap/5.2-safe-linking-bypass)
- [Looney Tunables (CVE-2023-4911) write-up](https://www.wiz.io/vulnerability-database/cve/cve-2023-4911)

{{#include ../../banners/hacktricks-training.md}}
