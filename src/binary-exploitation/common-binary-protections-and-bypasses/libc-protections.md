# Захисти Libc

{{#include ../../banners/hacktricks-training.md}}

## Примус вирівнювання блоків

**Malloc** виділяє пам'ять у **групах по 8 байт (32-біт) або 16 байт (64-біт)**. Це означає, що кінець блоків у 32-бітних системах повинен вирівнюватися з **0x8**, а в 64-бітних системах з **0x0**. Функція безпеки перевіряє, що кожен блок **правильно вирівняний** у цих конкретних місцях перед використанням вказівника з контейнера.

### Переваги безпеки

Примус вирівнювання блоків у 64-бітних системах значно підвищує безпеку Malloc, **обмежуючи розміщення підроблених блоків лише 1 з кожних 16 адрес**. Це ускладнює зусилля з експлуатації, особливо в сценаріях, де користувач має обмежений контроль над вхідними значеннями, ускладнюючи атаки та роблячи їх важчими для успішного виконання.

- **Атака Fastbin на \_\_malloc_hook**

Нові правила вирівнювання в Malloc також заважають класичній атаці, що стосується `__malloc_hook`. Раніше зловмисники могли маніпулювати розмірами блоків, щоб **перезаписати цей вказівник функції** та отримати **виконання коду**. Тепер сувора вимога вирівнювання забезпечує, що такі маніпуляції більше не є життєздатними, закриваючи загальний шлях експлуатації та підвищуючи загальну безпеку.

## Переплутування вказівників на fastbins і tcache

**Переплутування вказівників** є вдосконаленням безпеки, яке використовується для захисту **вказівників Fd fastbin і tcache** в операціях управління пам'яттю. Ця техніка допомагає запобігти певним типам тактик експлуатації пам'яті, зокрема тим, які не вимагають витоку інформації про пам'ять або які маніпулюють місцями пам'яті безпосередньо відносно відомих позицій (відносні **перезаписи**).

Суть цієї техніки полягає в формулі обфускації:

**`New_Ptr = (L >> 12) XOR P`**

- **L** - це **Місце зберігання** вказівника.
- **P** - це фактичний **вказівник fastbin/tcache Fd**.

Причина бітового зсуву місця зберігання (L) на 12 біт вправо перед операцією XOR є критично важливою. Ця маніпуляція вирішує вразливість, властиву детерміністичній природі найменш значущих 12 біт адрес пам'яті, які зазвичай є передбачуваними через обмеження архітектури системи. Зміщуючи біти, передбачувана частина виводиться з рівняння, підвищуючи випадковість нового, переплутаного вказівника і, таким чином, захищаючи від експлуатацій, які покладаються на передбачуваність цих біт.

Цей переплутаний вказівник використовує існуючу випадковість, надану **Випадковим розташуванням адресного простору (ASLR)**, яке випадковизує адреси, що використовуються програмами, ускладнюючи зловмисникам передбачити розташування пам'яті процесу.

**Деманглінг** вказівника для отримання оригінальної адреси передбачає використання тієї ж операції XOR. Тут переплутаний вказівник розглядається як P у формулі, і коли він XOR'иться з незмінним місцем зберігання (L), це призводить до розкриття оригінального вказівника. Ця симетрія в переплутуванні та деманглінгу забезпечує, що система може ефективно кодувати та декодувати вказівники без значних витрат, одночасно суттєво підвищуючи безпеку проти атак, які маніпулюють вказівниками пам'яті.

### Переваги безпеки

Переплутування вказівників має на меті **запобігти частковим і повним перезаписам вказівників у купі**, що є значним вдосконаленням безпеки. Ця функція впливає на техніки експлуатації кількома способами:

1. **Запобігання відносним перезаписам байт за байтом**: Раніше зловмисники могли змінювати частину вказівника, щоб **перенаправити блоки купи на різні місця без знання точних адрес**, техніка, очевидна в безвитковій **House of Roman** експлуатації. Завдяки переплутуванню вказівників такі відносні перезаписи **без витоку купи тепер вимагають брутфорс**, що різко знижує ймовірність їх успіху.
2. **Збільшення складності атак Tcache Bin/Fastbin**: Загальні атаки, які перезаписують вказівники функцій (як `__malloc_hook`) шляхом маніпуляції з записами fastbin або tcache, ускладнені. Наприклад, атака може включати витік адреси LibC, звільнення блоку в контейнер tcache, а потім перезапис вказівника Fd, щоб перенаправити його на `__malloc_hook` для виконання довільного коду. Завдяки переплутуванню вказівників ці вказівники повинні бути правильно переплутані, **вимагаючи витоку купи для точної маніпуляції**, підвищуючи бар'єр експлуатації.
3. **Вимога витоків купи в некупових місцях**: Створення підробленого блоку в некупових областях (як стек, секція .bss або PLT/GOT) тепер також **вимагає витоку купи** через необхідність переплутування вказівників. Це розширює складність експлуатації цих областей, подібно до вимоги маніпулювати адресами LibC.
4. **Витік адрес купи стає більш складним**: Переплутування вказівників обмежує корисність вказівників Fd у fastbin і tcache bins як джерел для витоків адрес купи. Однак вказівники в неупорядкованих, малих і великих контейнерах залишаються непереплутаними, отже, все ще можуть використовуватися для витоків адрес. Ця зміна змушує зловмисників досліджувати ці контейнери для отримання експлуатованої інформації, хоча деякі техніки все ще можуть дозволити деманглінг вказівників перед витоком, хоча з обмеженнями.

### **Деманглінг вказівників з витоком купи**

> [!CAUTION]
> Для кращого пояснення процесу [**перевірте оригінальний пост звідси**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Огляд алгоритму

Формула, що використовується для переплутування та деманглінгу вказівників, є:&#x20;

**`New_Ptr = (L >> 12) XOR P`**

Де **L** - це місце зберігання, а **P** - це вказівник Fd. Коли **L** зсувається вправо на 12 біт, він відкриває найзначніші біти **P**, через природу **XOR**, яка виводить 0, коли біти XOR'яться самі з собою.

**Ключові етапи в алгоритмі:**

1. **Початковий витік найзначніших бітів**: XOR'ючи зсунутий **L** з **P**, ви фактично отримуєте верхні 12 бітів **P**, оскільки зсунутий фрагмент **L** буде нульовим, залишаючи відповідні біти **P** незмінними.
2. **Відновлення бітів вказівника**: Оскільки XOR є оборотним, знання результату та одного з операндів дозволяє вам обчислити інший операнд. Ця властивість використовується для виведення всього набору бітів для **P**, послідовно XOR'ючи відомі набори бітів з частинами переплутаного вказівника.
3. **Ітеративний деманглінг**: Процес повторюється, кожного разу використовуючи нововиявлені біти **P** з попереднього кроку для декодування наступного сегмента переплутаного вказівника, поки всі біти не будуть відновлені.
4. **Обробка детерміністичних бітів**: Останні 12 бітів **L** втрачаються через зсув, але вони є детерміністичними і можуть бути відновлені після процесу.

Ви можете знайти реалізацію цього алгоритму тут: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Захист вказівників

Захист вказівників - це техніка пом'якшення експлуатації, що використовується в glibc для захисту збережених вказівників функцій, особливо тих, що реєструються бібліотечними викликами, такими як `atexit()`. Цей захист передбачає перемішування вказівників шляхом XOR'ування їх з секретом, збереженим у даних потоку (`fs:0x30`), і застосуванням бітового зсуву. Цей механізм має на меті запобігти зловмисникам перехоплення контролю потоку шляхом перезапису вказівників функцій.

### **Обхід захисту вказівників з витоком**

1. **Розуміння операцій захисту вказівників:** Перемішування (переплутування) вказівників виконується за допомогою макроса `PTR_MANGLE`, який XOR'ує вказівник з 64-бітним секретом, а потім виконує лівий зсув на 0x11 біт. Зворотна операція для відновлення оригінального вказівника обробляється `PTR_DEMANGLE`.
2. **Стратегія атаки:** Атака базується на підході з відомим відкритим текстом, де зловмисник повинен знати як оригінальну, так і переплутану версії вказівника, щоб вивести секрет, використаний для переплутування.
3. **Експлуатація відомих відкритих текстів:**
- **Ідентифікація фіксованих вказівників функцій:** Вивчаючи вихідний код glibc або ініціалізовані таблиці вказівників функцій (як `__libc_pthread_functions`), зловмисник може знайти передбачувані вказівники функцій.
- **Обчислення секрету:** Використовуючи відомий вказівник функції, такий як `__pthread_attr_destroy`, і його переплутану версію з таблиці вказівників функцій, секрет може бути обчислений шляхом зворотного зсуву (правого зсуву) переплутаного вказівника, а потім XOR'ування його з адресою функції.
4. **Альтернативні відкриті тексти:** Зловмисник також може експериментувати з переплутуванням вказівників з відомими значеннями, такими як 0 або -1, щоб перевірити, чи ці значення створюють впізнавані шаблони в пам'яті, потенційно розкриваючи секрет, коли ці шаблони виявляються в дампах пам'яті.
5. **Практичне застосування:** Після обчислення секрету зловмисник може маніпулювати вказівниками контрольованим чином, фактично обходячи захист вказівників у багатопотоковому додатку з знанням базової адреси libc та можливістю читати довільні адреси пам'яті.

## Посилання

- [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
- [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)

{{#include ../../banners/hacktricks-training.md}}
