# Libc Protections

{{#include ../../banners/hacktricks-training.md}}

## Chunk Alignment Enforcement

**Malloc** δεσμεύει μνήμη σε **ομάδες των 8 byte (32-bit) ή 16 byte (64-bit)**. Αυτό σημαίνει ότι το τέλος των chunks σε συστήματα 32-bit πρέπει να συγχρονίζεται με **0x8**, και σε συστήματα 64-bit με **0x0**. Η λειτουργία ασφαλείας ελέγχει ότι κάθε chunk **ευθυγραμμίζεται σωστά** σε αυτές τις συγκεκριμένες θέσεις πριν χρησιμοποιήσει έναν pointer από ένα bin.

### Οφέλη Ασφαλείας

Η επιβολή της ευθυγράμμισης των chunks σε συστήματα 64-bit ενισχύει σημαντικά την ασφάλεια της Malloc περιορίζοντας την τοποθέτηση ψεύτικων chunks σε μόλις 1 από κάθε 16 διευθύνσεις. Αυτό περιπλέκει τις προσπάθειες εκμετάλλευσης, ιδιαίτερα σε σενάρια όπου ο χρήστης έχει περιορισμένο έλεγχο στις τιμές εισόδου, καθιστώντας τις επιθέσεις πιο πολύπλοκες και δυσκολότερες στην επιτυχή εκτέλεση.

- **Fastbin Attack on `__malloc_hook`**

Οι νέοι κανόνες ευθυγράμμισης στη Malloc επίσης αποτρέπουν μια κλασική επίθεση που εμπλέκει το `__malloc_hook`. Προηγουμένως, οι επιτιθέμενοι μπορούσαν να χειριστούν τα μεγέθη των chunks για να **επιγράψουν αυτόν τον function pointer** και να αποκτήσουν **εκτέλεση κώδικα**. Τώρα, η αυστηρή απαίτηση ευθυγράμμισης εξασφαλίζει ότι τέτοιες χειρισμοί δεν είναι πλέον εφικτοί, κλείνοντας μια κοινή οδό εκμετάλλευσης και ενισχύοντας τη συνολική ασφάλεια.

> **Note:** Since glibc **2.34** the legacy hooks (`__malloc_hook`, `__free_hook`, etc.) are removed from the exported ABI. Modern exploits now target other writable function pointers (e.g. tcache per-thread struct, vtable-style callbacks) or rely on `setcontext`, `_IO_list_all` primitives, etc.

## Pointer Mangling on fastbins and tcache

**Pointer Mangling** είναι μια βελτίωση ασφάλειας που χρησιμοποιείται για να προστατεύει τους **fastbin και tcache Fd pointers** στις λειτουργίες διαχείρισης μνήμης. Αυτή η τεχνική βοηθά στην πρόληψη ορισμένων τύπων τεχνικών εκμετάλλευσης μνήμης, ειδικά εκείνων που δεν απαιτούν leaked πληροφορίες μνήμης ή που χειρίζονται θέσεις μνήμης άμεσα σε σχέση με γνωστές θέσεις (relative **overwrites**).

Ο πυρήνας αυτής της τεχνικής είναι μια φόρμουλα εξομάλυνσης:

**`New_Ptr = (L >> 12) XOR P`**

- **L** είναι η **θέση αποθήκευσης (Storage Location)** του pointer.
- **P** είναι ο πραγματικός **fastbin/tcache Fd Pointer**.

Ο λόγος για τη bitwise μετατόπιση της θέσης αποθήκευσης (L) κατά 12 bits προς τα δεξιά πριν την πράξη XOR είναι κρίσιμος. Αυτή η χειραγώγηση αντιμετωπίζει μια ευπάθεια που έγκειται στη ντετερμινιστική φύση των 12 λιγότερο σημαντικών bits των διευθύνσεων μνήμης, τα οποία είναι τυπικά προβλέψιμα λόγω των περιορισμών της αρχιτεκτονικής του συστήματος. Με τη μετατόπιση των bits, το προβλέψιμο μέρος μετακινείται εκτός της εξίσωσης, ενισχύοντας την τυχαιότητα του νέου, mangled pointer και έτσι προστατεύοντας από επιθέσεις που βασίζονται στην προβλεψιμότητα αυτών των bits.

Αυτός ο mangled pointer αξιοποιεί την υπάρχουσα τυχαιότητα που παρέχει η **Address Space Layout Randomization (ASLR)**, η οποία τυχοποιεί τις διευθύνσεις που χρησιμοποιούνται από προγράμματα για να καταστήσει δύσκολη την πρόβλεψη της διάταξης μνήμης μιας διεργασίας από επιτιθέμενους.

Η **απο-μάγκλευσή** (Demangling) του pointer για την ανάκτηση της αρχικής διεύθυνσης γίνεται χρησιμοποιώντας την ίδια πράξη XOR. Εδώ, ο mangled pointer θεωρείται ως P στη φόρμουλα, και όταν XOR-αριστεί με την αμετάβλητη θέση αποθήκευσης (L), αποκαλύπτεται ο αρχικός pointer. Αυτή η συμμετρία στο mangling και demangling εξασφαλίζει ότι το σύστημα μπορεί να κωδικοποιεί και να αποκωδικοποιεί pointers αποδοτικά χωρίς σημαντικό overhead, ενώ αυξάνει κατά πολύ την ασφάλεια απέναντι σε επιθέσεις που χειρίζονται pointers μνήμης.

### Οφέλη Ασφαλείας

Το pointer mangling στοχεύει στην **πρόληψη μερικών και πλήρων overwrites των pointers στο heap**, μια σημαντική βελτίωση ασφάλειας. Αυτή η λειτουργία επηρεάζει τεχνικές εκμετάλλευσης με αρκετούς τρόπους:

1. **Αποτροπή Byte-by-Byte Relative Overwrites:** Προηγουμένως, οι επιτιθέμενοι μπορούσαν να αλλάξουν μέρος ενός pointer για να **ανακατευθύνουν heap chunks σε διαφορετικές τοποθεσίες χωρίς να γνωρίζουν ακριβείς διευθύνσεις**, μια τεχνική που φαίνεται στο leakless **House of Roman** exploit. Με το pointer mangling, τέτοιες σχετικές overwrites **χωρίς heap leak πλέον απαιτούν brute forcing**, μειώνοντας δραματικά την πιθανότητα επιτυχίας.
2. **Αυξημένη Δυσκολία Επιθέσεων σε Tcache Bin/Fastbin:** Συνηθισμένες επιθέσεις που επιγράφουν function pointers (όπως το `__malloc_hook`) χειριζόμενοι καταχωρήσεις fastbin ή tcache δυσχεραίνονται. Για παράδειγμα, μια επίθεση μπορεί να περιλαμβάνει leaking μιας LibC διεύθυνσης, την απελευθέρωση ενός chunk στο tcache bin, και στη συνέχεια την επιγραφή του Fd pointer για ανακατεύθυνση προς `__malloc_hook` για arbitrary code execution. Με το pointer mangling, αυτοί οι pointers πρέπει να είναι σωστά mangled, **απαιτώντας heap leak για ακριβή χειρισμό**, αυξάνοντας έτσι το φράγμα εκμετάλλευσης.
3. **Απαίτηση για Heap Leaks σε Non-Heap Τοποθεσίες:** Η δημιουργία ενός ψεύτικου chunk σε μη-heap περιοχές (όπως το stack, .bss section, ή PLT/GOT) πλέον επίσης **απαιτεί heap leak** λόγω της ανάγκης για pointer mangling. Αυτό επεκτείνει την πολυπλοκότητα της εκμετάλλευσης αυτών των περιοχών, παρόμοια με την απαίτηση για χειρισμό LibC διευθύνσεων.
4. **Η Διαρροή Διευθύνσεων Heap Γίνεται Πιο Δύσκολη:** Το pointer mangling περιορίζει τη χρησιμότητα των Fd pointers σε fastbin και tcache bins ως πηγές για leak διευθύνσεων heap. Ωστόσο, pointers σε unsorted, small, και large bins παραμένουν unmangled και επομένως ακόμα χρήσιμοι για leak διευθύνσεων. Αυτή η αλλαγή ωθεί τους επιτιθέμενους να διερευνήσουν αυτά τα bins για εκμεταλλεύσιμες πληροφορίες, αν και ορισμένες τεχνικές μπορεί να επιτρέπουν την demangling pointers πριν από ένα leak, με περιορισμούς.

### **Safe-Linking Bypass (page-aligned leak scenario)**

Ακόμη και με το safe-linking ενεργοποιημένο (glibc ≥ 2.32), εάν μπορείτε να leak τον mangled pointer και τόσο το corrupted chunk όσο και το victim chunk μοιράζονται την ίδια σελίδα 4KB, ο αρχικός pointer μπορεί να ανακτηθεί με μόνο το page offset:
```c
// leaked_fd is the mangled Fd read from the chunk on the same page
uintptr_t l = (uintptr_t)&chunk->fd;           // storage location
uintptr_t original = (leaked_fd ^ (l >> 12));  // demangle
```
Αυτό επαναφέρει το Fd και επιτρέπει το κλασικό tcache/fastbin poisoning. Αν τα chunks βρίσκονται σε διαφορετικές σελίδες, το brute-forcing του 12-bit page offset (0x1000 possibilities) είναι συχνά εφικτό όταν τα allocation patterns είναι deterministic ή όταν τα crashes είναι αποδεκτά (π.χ., CTF-style exploits).

### **Demangling Pointers with a Heap Leak**

> [!CAUTION]
> Για μια καλύτερη εξήγηση της διαδικασίας [**check the original post from here**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Algorithm Overview

Ο τύπος που χρησιμοποιείται για mangling και demangling pointers είναι:

**`New_Ptr = (L >> 12) XOR P`**

Όπου **L** είναι η θέση αποθήκευσης και **P** είναι ο Fd pointer. Όταν **L** μετατοπίζεται δεξιά κατά 12 bits, αποκαλύπτει τα πιο σημαντικά bits του **P**, λόγω της φύσης του **XOR**, που παράγει 0 όταν bits XORed μεταξύ τους είναι ίδια.

**Βασικά Βήματα του Αλγορίθμου:**

1. **Initial Leak of the Most Significant Bits:** Με το XORing του μετατοπισμένου **L** με **P**, ουσιαστικά παίρνετε τα κορυφαία 12 bits του **P** επειδή το μετατοπισμένο τμήμα του **L** θα είναι μηδέν, αφήνοντας τα αντίστοιχα bits του **P** αμετάβλητα.
2. **Recovery of Pointer Bits:** Εφόσον το XOR είναι αντιστρέψιμο, γνωρίζοντας το αποτέλεσμα και έναν από τους τελεστέους μπορείτε να υπολογίσετε τον άλλο. Αυτή η ιδιότητα χρησιμοποιείται για να εξαχθεί ολόκληρο το σύνολο των bits του **P** με διαδοχικά XORing γνωστών σετ bits με μέρη του mangled pointer.
3. **Iterative Demangling:** Η διαδικασία επαναλαμβάνεται, κάθε φορά χρησιμοποιώντας τα νεοανακαλυφθέντα bits του **P** από το προηγούμενο βήμα για να αποκωδικοποιηθεί το επόμενο τμήμα του mangled pointer, μέχρι να ανακτηθούν όλα τα bits.
4. **Handling Deterministic Bits:** Τα τελικά 12 bits του **L** χάνoνται λόγω της μετατόπισης, αλλά είναι deterministic και μπορούν να ανακατασκευαστούν μετά τη διαδικασία.

Μπορείτε να βρείτε μια υλοποίηση αυτού του αλγορίθμου εδώ: https://github.com/mdulin2/mangle

## Pointer Guard

Το Pointer Guard είναι μια τεχνική mitigation που χρησιμοποιείται στο glibc για την προστασία αποθηκευμένων function pointers, ιδιαίτερα αυτών που εγγράφονται από κλήσεις βιβλιοθήκης όπως `atexit()`. Αυτή η προστασία περιλαμβάνει το scrambling των pointers με XORing τους με ένα secret αποθηκευμένο στα thread data (`fs:0x30`) και την εφαρμογή bitwise rotation. Ο μηχανισμός αυτός στοχεύει στο να αποτρέψει attackers από το να hijack το control flow με το να αντικαταστήσουν function pointers.

### **Bypassing Pointer Guard with a leak**

1. **Understanding Pointer Guard Operations:** Το scrambling (mangling) των pointers γίνεται χρησιμοποιώντας το macro `PTR_MANGLE` το οποίο XORs τον pointer με ένα 64-bit secret και στη συνέχεια εκτελεί μια left rotation κατά 0x11 bits. Η αντίστροφη λειτουργία για την ανάκτηση του αρχικού pointer γίνεται από το `PTR_DEMANGLE`.
2. **Attack Strategy:** Η επίθεση βασίζεται σε μια known-plaintext προσέγγιση, όπου ο attacker χρειάζεται να γνωρίζει τόσο την αρχική όσο και τη mangled έκδοση ενός pointer για να εξαχθεί το secret που χρησιμοποιήθηκε για το mangling.
3. **Exploiting Known Plaintexts:**
- **Identifying Fixed Function Pointers:** Εξετάζοντας τον κώδικα του glibc ή τον πίνακα αρχικοποιημένων function pointers (όπως `__libc_pthread_functions`), ο attacker μπορεί να βρει προβλέψιμους function pointers.
- **Computing the Secret:** Χρησιμοποιώντας έναν γνωστό function pointer όπως `__pthread_attr_destroy` και την mangled έκδοσή του από τον πίνακα function pointers, το secret μπορεί να υπολογιστεί με το να γίνει reverse rotating (right rotation) της mangled τιμής και στη συνέχεια XORing με τη διεύθυνση της συνάρτησης.
4. **Alternative Plaintexts:** Ο attacker μπορεί επίσης να πειραματιστεί με mangling pointers με γνωστές τιμές όπως 0 ή -1 για να δει αν αυτές παράγουν αναγνωρίσιμα patterns στη μνήμη, πιθανώς αποκαλύπτοντας το secret όταν αυτά τα patterns βρεθούν σε memory dumps.
5. **Practical Application:** Αφού υπολογιστεί το secret, ο attacker μπορεί να χειριστεί pointers με ελεγχόμενο τρόπο, ουσιαστικά παρακάμπτοντας την προστασία Pointer Guard σε μια multithreaded εφαρμογή με γνώση της libc base address και ικανότητα να διαβάζει arbitrary memory locations.

## GLIBC Tunables & Recent Loader Bugs

Ο dynamic loader κάνει parse τα `GLIBC_TUNABLES` πριν την εκκίνηση του προγράμματος. Τα bugs στο mis-parsing εδώ επηρεάζουν άμεσα τη **libc** πριν ενεργοποιηθούν τα περισσότερα mitigations. Το 2023 "Looney Tunables" bug (CVE-2023-4911) είναι ένα παράδειγμα: μια overlong `GLIBC_TUNABLES` τιμή overflow-άρει εσωτερικά buffers στο `ld.so`, επιτρέποντας **privilege escalation** σε πολλές distros όταν συνδυαστεί με SUID binaries. Η εκμετάλλευση απαιτεί μόνο το crafted environment και την επαναλαμβανόμενη κλήση του target binary· pointer guard ή safe-linking δεν το αποτρέπουν επειδή η καταστροφή γίνεται στο loader πριν την εγκατάσταση του heap.

## References

- [Safe-Linking bypass explanation (shellphish/how2heap)](https://deepwiki.com/shellphish/how2heap/5.2-safe-linking-bypass)
- [Looney Tunables (CVE-2023-4911) write-up](https://www.wiz.io/vulnerability-database/cve/cve-2023-4911)

{{#include ../../banners/hacktricks-training.md}}
