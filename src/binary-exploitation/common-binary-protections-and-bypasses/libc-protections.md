# Προστασίες Libc

{{#include ../../banners/hacktricks-training.md}}

## Επιβολή Ευθυγράμμισης Chunk

**Malloc** εκχωρεί μνήμη σε **ομαδοποιήσεις των 8-byte (32-bit) ή 16-byte (64-bit)**. Αυτό σημαίνει ότι το τέλος των chunks σε συστήματα 32-bit πρέπει να ευθυγραμμίζεται με **0x8**, και σε συστήματα 64-bit με **0x0**. Το χαρακτηριστικό ασφαλείας ελέγχει ότι κάθε chunk **ευθυγραμμίζεται σωστά** σε αυτές τις συγκεκριμένες θέσεις πριν χρησιμοποιήσει έναν δείκτη από ένα bin.

### Οφέλη Ασφαλείας

Η επιβολή ευθυγράμμισης chunk σε συστήματα 64-bit ενισχύει σημαντικά την ασφάλεια της **Malloc** περιορίζοντας την τοποθέτηση ψεύτικων chunks σε **μόλις 1 ανά κάθε 16 διευθύνσεις**. Αυτό περιπλέκει τις προσπάθειες εκμετάλλευσης, ιδίως σε σενάρια όπου ο χρήστης έχει περιορισμένο έλεγχο στις τιμές εισόδου, καθιστώντας τις επιθέσεις πιο πολύπλοκες και δυσκολότερες στην επιτυχία.

- **Fastbin Attack on `__malloc_hook`**

Οι νέοι κανόνες ευθυγράμμισης στην **Malloc** επίσης αποτρέπουν μια κλασική επίθεση που εμπλέκει το `__malloc_hook`. Παλαιότερα, οι επιτιθέμενοι μπορούσαν να χειριστούν τα μεγέθη των chunks για να **overwrite this function pointer** και να αποκτήσουν **code execution**. Τώρα, η αυστηρή απαίτηση ευθυγράμμισης διασφαλίζει ότι τέτοιοι χειρισμοί δεν είναι πλέον βιώσιμοι, κλείνοντας μια κοινή οδό εκμετάλλευσης και ενισχύοντας συνολικά την ασφάλεια.

> **Note:** Since glibc **2.34** the legacy hooks (`__malloc_hook`, `__free_hook`, etc.) are removed from the exported ABI. Τα σύγχρονα exploits στοχεύουν τώρα άλλους εγγράψιμους δείκτες συνάρτησης (π.χ. tcache per-thread struct, vtable-style callbacks) ή βασίζονται σε `setcontext`, `_IO_list_all` primitives, κ.λπ.

## Pointer Mangling σε fastbins και tcache

**Pointer Mangling** είναι μια βελτίωση ασφάλειας που χρησιμοποιείται για να προστατεύσει **fastbin και tcache Fd pointers** στις λειτουργίες διαχείρισης μνήμης. Αυτή η τεχνική βοηθά στην αποτροπή ορισμένων τύπων τακτικών εκμετάλλευσης μνήμης, ειδικά εκείνων που δεν απαιτούν leaked πληροφορίες μνήμης ή που χειρίζονται θέσεις μνήμης άμεσα σχετικώς προς γνωστές τοποθεσίες (relative **overwrites**).

Ο πυρήνας αυτής της τεχνικής είναι μια φόρμουλα απομυστικοποίησης:

**`New_Ptr = (L >> 12) XOR P`**

- **L** είναι η **θέση αποθήκευσης** του δείκτη.
- **P** είναι ο πραγματικός **fastbin/tcache Fd Pointer**.

Ο λόγος για τη μετατόπιση της θέσης αποθήκευσης (L) κατά 12 bits προς τα δεξιά πριν την πράξη XOR είναι κρίσιμος. Αυτή η επεξεργασία αντιμετωπίζει μια ευπάθεια εγγενή στη ντετερμινιστική φύση των 12 λιγότερο σημαντικών bit των διευθύνσεων μνήμης, τα οποία συνήθως είναι προβλέψιμα λόγω περιορισμών της αρχιτεκτονικής του συστήματος. Με τη μετατόπιση των bit, το προβλέψιμο μέρος εξέρχεται της εξίσωσης, ενισχύοντας την τυχαιότητα του νέου, παραμορφωμένου δείκτη και προστατεύοντας έτσι καλύτερα ενάντια σε εκμεταλλεύσεις που βασίζονται στην προβλεψιμότητα αυτών των bit.

Αυτός ο παραμορφωμένος δείκτης αξιοποιεί την υπάρχουσα τυχαιότητα που παρέχει το **Address Space Layout Randomization (ASLR)**, η οποία τυχαροποιεί τις διευθύνσεις που χρησιμοποιούν τα προγράμματα, κάνοντας δύσκολη την πρόβλεψη της διάταξης μνήμης μιας διεργασίας.

Η απο-μάγγιση (demangling) του δείκτη για την ανάκτηση της αρχικής διεύθυνσης γίνεται με την ίδια πράξη XOR. Εδώ, ο παραμορφωμένος δείκτης θεωρείται ως P στη φόρμουλα, και όταν XOR-αριστεί με τη μη τροποποιημένη θέση αποθήκευσης (L), αποκαλύπτει τον αρχικό δείκτη. Αυτή η συμμετρία στη mangling και την demangling εξασφαλίζει ότι το σύστημα μπορεί να κωδικοποιεί και να αποκωδικοποιεί δείκτες αποδοτικά χωρίς σημαντικό overhead, ενώ αυξάνει ουσιωδώς την ασφάλεια απέναντι σε επιθέσεις που χειρίζονται δείκτες μνήμης.

### Οφέλη Ασφαλείας

Το pointer mangling στοχεύει στο να **αποτρέψει μερικές και πλήρεις επαναγραφές δεικτών στον heap**, μια σημαντική βελτίωση στην ασφάλεια. Αυτό επηρεάζει τεχνικές εκμετάλλευσης με πολλούς τρόπους:

1. **Prevention of Bye Byte Relative Overwrites**: Παλαιότερα, οι επιτιθέμενοι μπορούσαν να αλλάξουν μέρος ενός δείκτη για να **redirect heap chunks to different locations without knowing exact addresses**, μια τεχνική εμφανής στο leakless **House of Roman** exploit. Με το pointer mangling, τέτοιες relative overwrites **χωρίς heap leak τώρα απαιτούν brute forcing**, μειώνοντας δραστικά τις πιθανότητες επιτυχίας.
2. **Increased Difficulty of Tcache Bin/Fastbin Attacks**: Κοινές επιθέσεις που overwrite δείκτες συνάρτησης (όπως το `__malloc_hook`) μέσω χειρισμού fastbin ή tcache εγγραφών παρεμποδίζονται. Για παράδειγμα, μια επίθεση μπορεί να περιλαμβάνει leaking μιας LibC διεύθυνσης, freeing ενός chunk στο tcache bin, και μετά overwrite του Fd pointer για να το ανακατευθύνει στο `__malloc_hook` για arbitrary code execution. Με το pointer mangling, αυτοί οι δείκτες πρέπει να είναι σωστά mangled, **απαιτώντας ένα heap leak για ακριβή χειρισμό**, αυξάνοντας έτσι το εμπόδιο στην εκμετάλλευση.
3. **Requirement for Heap Leaks in Non-Heap Locations**: Η δημιουργία ενός fake chunk σε μη-heap περιοχές (όπως το stack, η .bss section, ή PLT/GOT) τώρα επίσης **απαιτεί ένα heap leak** λόγω της ανάγκης για pointer mangling. Αυτό αυξάνει την πολυπλοκότητα της εκμετάλλευσης αυτών των περιοχών, παρόμοια με την απαίτηση για χειρισμό διευθύνσεων LibC.
4. **Leaking Heap Addresses Becomes More Challenging**: Το pointer mangling περιορίζει τη χρησιμότητα των Fd pointers σε fastbin και tcache bins ως πηγές για heap address leaks. Ωστόσο, δείκτες σε unsorted, small, και large bins παραμένουν unmangled, και επομένως εξακολουθούν να είναι χρήσιμοι για leaking διευθύνσεων. Αυτή η μετατόπιση ωθεί τους επιτιθέμενους να εξερευνήσουν αυτά τα bins για εκμεταλλεύσιμες πληροφορίες, αν και μερικές τεχνικές μπορεί ακόμα να επιτρέπουν demangling δεικτών πριν από ένα leak, με περιορισμούς.

### **Παράκαμψη Safe-Linking (page-aligned leak scenario)**

Ακόμα και με το safe-linking ενεργοποιημένο (glibc ≥ 2.32), αν μπορείτε να leak τον mangled pointer και τόσο το corrupted chunk όσο και το victim chunk μοιράζονται την ίδια σελίδα 4KB, ο αρχικός δείκτης μπορεί να ανακτηθεί μόνο με το page offset:
```c
// leaked_fd is the mangled Fd read from the chunk on the same page
uintptr_t l = (uintptr_t)&chunk->fd;           // storage location
uintptr_t original = (leaked_fd ^ (l >> 12));  // demangle
```
Αυτό επαναφέρει το Fd και επιτρέπει το κλασικό tcache/fastbin poisoning. Αν τα chunks βρίσκονται σε διαφορετικές σελίδες, το brute-forcing του 12-bit page offset (0x1000 possibilities) είναι συχνά εφικτό όταν τα allocation patterns είναι deterministic ή όταν τα crashes είναι αποδεκτά (π.χ., CTF-style exploits).

### **Demangling Pointers with a Heap Leak**

> [!CAUTION]
> For a better explanation of the process [**check the original post from here**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Algorithm Overview

Ο τύπος που χρησιμοποιείται για το mangling και demangling pointers είναι:

**`New_Ptr = (L >> 12) XOR P`**

Όπου **L** είναι η θέση αποθήκευσης και **P** είναι ο Fd pointer. Όταν **L** γίνεται shift δεξιά κατά 12 bits, αποκαλύπτει τα πιο σημαντικά bits του **P**, λόγω της φύσης του **XOR**, που επιστρέφει 0 όταν bits XORαριστούν με τα ίδια.

**Κύρια Βήματα του Αλγορίθμου:**

1. **Αρχικό leak των πιο σημαντικών bits:** Με το XORing του shifted **L** με **P**, παίρνετε ουσιαστικά τα πάνω 12 bits του **P** γιατί το shifted μέρος του **L** θα είναι μηδενικό, αφήνοντας τα αντίστοιχα bits του **P** αμετάβλητα.
2. **Ανάκτηση των bits του pointer:** Εφόσον το XOR είναι αντιστρέψιμο, γνωρίζοντας το αποτέλεσμα και έναν από τους τελεστές μπορείτε να υπολογίσετε τον άλλο. Αυτή η ιδιότητα χρησιμοποιείται για να συναχθεί το σύνολο των bits για το **P** με το διαδοχικό XORing γνωστών συνόλων bits με μέρη του mangled pointer.
3. **Επαναληπτικό Demangling:** Η διαδικασία επαναλαμβάνεται, κάθε φορά χρησιμοποιώντας τα νεοανακαλυφθέντα bits του **P** από το προηγούμενο βήμα για να αποκωδικοποιηθεί το επόμενο τμήμα του mangled pointer, μέχρι να ανακτηθούν όλα τα bits.
4. **Διαχείριση των deterministic bits:** Τα τελικά 12 bits του **L** χάνονται λόγω του shift, αλλά είναι deterministic και μπορούν να ανακατασκευαστούν μετά τη διαδικασία.

Μπορείτε να βρείτε μια υλοποίηση αυτού του αλγορίθμου εδώ: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer Guard είναι ένα exploit mitigation που χρησιμοποιείται σε glibc για να προστατεύει αποθηκευμένους function pointers, ιδιαίτερα αυτούς που καταχωρούνται από κλήσεις βιβλιοθήκης όπως `atexit()`. Αυτή η προστασία περιλαμβάνει το scrambling των pointers με XORing τους με ένα secret αποθηκευμένο στα thread data (`fs:0x30`) και την εφαρμογή ενός bitwise rotation. Αυτός ο μηχανισμός στοχεύει στο να εμποδίσει τους επιτιθέμενους να προσπαθήσουν να hijack-άρουν το control flow με την υπερχείλιση function pointers.

### **Bypassing Pointer Guard with a leak**

1. **Κατανόηση των λειτουργιών του Pointer Guard:** Το scrambling (mangling) των pointers γίνεται με το macro `PTR_MANGLE` που XORαρει τον pointer με ένα 64-bit secret και στη συνέχεια εκτελεί left rotation κατά 0x11 bits. Η αντίστροφη λειτουργία για την ανάκτηση του αρχικού pointer γίνεται από `PTR_DEMANGLE`.
2. **Στρατηγική επίθεσης:** Η επίθεση βασίζεται σε μια known-plaintext προσέγγιση, όπου ο επιτιθέμενος χρειάζεται να γνωρίζει τόσο την αρχική όσο και τη mangled έκδοση ενός pointer για να συναγάγει το secret που χρησιμοποιήθηκε για το mangling.
3. **Εκμετάλλευση γνωστών plaintexts:**
- **Αναγνώριση σταθερών function pointers:** Εξετάζοντας τον κώδικα του glibc ή τους αρχικοποιημένους πίνακες function pointers (όπως `__libc_pthread_functions`), ένας επιτιθέμενος μπορεί να βρει προβλέψιμους function pointers.
- **Υπολογισμός του secret:** Χρησιμοποιώντας έναν γνωστό function pointer όπως `__pthread_attr_destroy` και την mangled έκδοσή του από τον πίνακα function pointers, το secret μπορεί να υπολογιστεί με reverse rotating (right rotation) του mangled pointer και στη συνέχεια XORing με τη διεύθυνση της function.
4. **Εναλλακτικά plaintexts:** Ο επιτιθέμενος μπορεί επίσης να δοκιμάσει να mangle-άρει pointers με γνωστές τιμές όπως 0 ή -1 για να δεί αν αυτά παράγουν αναγνωρίσιμα patterns στη μνήμη, πιθανώς αποκαλύπτοντας το secret όταν αυτά τα patterns βρεθούν σε dumps μνήμης.
5. **Πρακτική εφαρμογή:** Αφού υπολογιστεί το secret, ένας επιτιθέμενος μπορεί να χειριστεί pointers με ελεγχόμενο τρόπο, ουσιαστικά παρακάμπτοντας την Pointer Guard προστασία σε μια multithreaded εφαρμογή με γνώση της libc base address και τη δυνατότητα να διαβάσει arbitrary memory locations.

## GLIBC Tunables & Recent Loader Bugs

Ο dynamic loader κάνει parse τα `GLIBC_TUNABLES` πριν την εκκίνηση του προγράμματος. Τα mis-parsing bugs εδώ επηρεάζουν άμεσα τη **libc** πριν ενεργοποιηθούν οι περισσότερες mitigations. Το 2023 bug "Looney Tunables" (CVE-2023-4911) είναι ένα παράδειγμα: μια υπερβολικά μεγάλη τιμή `GLIBC_TUNABLES` υπερχειλίζει εσωτερικά buffers στο `ld.so`, επιτρέποντας privilege escalation σε πολλές διανομές όταν συνδυάζεται με SUID binaries. Η εκμετάλλευση απαιτεί μόνο το crafting του περιβάλλοντος και την επαναλαμβανόμενη κλήση του στόχου binary· το pointer guard ή το safe-linking δεν το αποτρέπουν επειδή η καταστροφή συμβαίνει στον loader πριν τη ρύθμιση του heap.

## References

- [Safe-Linking bypass explanation (shellphish/how2heap)](https://deepwiki.com/shellphish/how2heap/5.2-safe-linking-bypass)
- [Looney Tunables (CVE-2023-4911) write-up](https://www.wiz.io/vulnerability-database/cve/cve-2023-4911)

{{#include ../../banners/hacktricks-training.md}}
