# Libc Koruma

{{#include ../../banners/hacktricks-training.md}}

## Parça Hizalama Zorunluluğu

**Malloc**, belleği **8 bayt (32-bit) veya 16 bayt (64-bit) gruplar halinde** ayırır. Bu, 32-bit sistemlerde parçaların sonlarının **0x8** ile, 64-bit sistemlerde ise **0x0** ile hizalanması gerektiği anlamına gelir. Güvenlik özelliği, her parçanın bir bin'den bir işaretçi kullanmadan önce bu belirli konumlarda **doğru hizalandığını** kontrol eder.

### Güvenlik Faydaları

64-bit sistemlerde parça hizalama zorunluluğu, Malloc'un güvenliğini önemli ölçüde artırarak **sahte parçaların yerleştirilmesini yalnızca her 16 adresten 1'ine sınırlamaktadır**. Bu, özellikle kullanıcının girdi değerleri üzerinde sınırlı kontrolü olduğu senaryolarda istismar çabalarını karmaşıklaştırır ve saldırıları daha karmaşık ve başarılı bir şekilde gerçekleştirilmesi zor hale getirir.

- **\_\_malloc_hook Üzerinde Fastbin Saldırısı**

Malloc'daki yeni hizalama kuralları, `__malloc_hook` ile ilgili klasik bir saldırıyı da engeller. Önceden, saldırganlar parça boyutlarını manipüle ederek **bu işlev işaretçisini** geçersiz kılabilir ve **kod yürütme** elde edebilirlerdi. Artık, katı hizalama gereksinimi, bu tür manipülasyonların geçerli olmamasını sağlar, yaygın bir istismar yolunu kapatır ve genel güvenliği artırır.

## Fastbin ve Tcache Üzerinde İşaretçi Karıştırma

**İşaretçi Karıştırma**, bellek yönetim işlemlerinde **fastbin ve tcache Fd işaretçilerini** korumak için kullanılan bir güvenlik geliştirmesidir. Bu teknik, sızdırılmış bellek bilgisi gerektirmeyen veya bellek konumlarını doğrudan bilinen konumlara göre manipüle eden belirli türde bellek istismar taktiklerini önlemeye yardımcı olur (göreli **geçersiz kılmalar**).

Bu tekniğin özü bir obfuscation formülüdür:

**`New_Ptr = (L >> 12) XOR P`**

- **L**, işaretçinin **Depolama Yeri**dir.
- **P**, gerçek **fastbin/tcache Fd İşaretçisidir**.

Depolama yerinin (L) 12 bit sağa kaydırılması, XOR işlemi öncesinde kritik bir öneme sahiptir. Bu manipülasyon, bellek adreslerinin en az anlamlı 12 bitinin belirleyici doğasında var olan bir zayıflığı ele alır; bu bitler genellikle sistem mimarisi kısıtlamaları nedeniyle tahmin edilebilir. Bitlerin kaydırılması, tahmin edilebilir kısmı denklemin dışına çıkararak yeni, karıştırılmış işaretçinin rastgeleliğini artırır ve böylece bu bitlerin tahmin edilebilirliğine dayanan istismarlara karşı koruma sağlar.

Bu karıştırılmış işaretçi, programlar tarafından kullanılan adresleri rastgeleleştiren **Adres Alanı Düzeni Rastgeleleştirmesi (ASLR)** tarafından sağlanan mevcut rastgeleliği kullanır, bu da saldırganların bir sürecin bellek düzenini tahmin etmesini zorlaştırır.

**İşaretçiyi demangling** etmek, orijinal adresi geri almak için aynı XOR işlemini kullanmayı içerir. Burada, karıştırılmış işaretçi formülde P olarak ele alınır ve değişmemiş depolama yeri (L) ile XORlandığında, orijinal işaretçi ortaya çıkar. Karıştırma ve demangling'deki bu simetri, sistemin işaretçileri önemli bir ek yük olmadan verimli bir şekilde kodlayıp çözmesini sağlar ve bellek işaretçilerini manipüle eden saldırılara karşı güvenliği önemli ölçüde artırır.

### Güvenlik Faydaları

İşaretçi karıştırma, **yığın yönetiminde kısmi ve tam işaretçi geçersiz kılmalarını önlemeyi** amaçlar, bu da güvenlikte önemli bir geliştirmedir. Bu özellik, istismar tekniklerini birkaç şekilde etkiler:

1. **Bayt Göreli Geçersiz Kılmaların Önlenmesi**: Önceden, saldırganlar bir işaretçinin bir kısmını değiştirerek **yığın parçalarını farklı konumlara yönlendirebilirlerdi**, bu teknik sızdırmasız **Roman Evi** istismarında belirgindi. İşaretçi karıştırma ile, böyle göreli geçersiz kılmalar **şimdi bir yığın sızıntısı gerektiriyor**, başarı olasılıklarını önemli ölçüde azaltıyor.
2. **Tcache Bin/Fastbin Saldırıların Zorluğunun Artması**: İşlev işaretçilerini (örneğin, `__malloc_hook`) fastbin veya tcache girişlerini manipüle ederek geçersiz kılmayı hedefleyen yaygın saldırılar engellenir. Örneğin, bir saldırı, bir LibC adresini sızdırmayı, bir parçayı tcache bin'ine serbest bırakmayı ve ardından Fd işaretçisini `__malloc_hook`'a yönlendirmek için geçersiz kılmayı içerebilir. İşaretçi karıştırma ile, bu işaretçilerin doğru bir şekilde karıştırılması gerekir, **doğru manipülasyon için bir yığın sızıntısı gerektirir**, böylece istismar engelini yükseltir.
3. **Yığın Dışı Konumlarda Yığın Sızıntıları Gereksinimi**: Yığın dışı alanlarda (yığın, .bss bölümü veya PLT/GOT gibi) sahte bir parça oluşturmak da **işaretçi karıştırma gereksinimi nedeniyle bir yığın sızıntısı gerektirir**. Bu, bu alanları istismar etmenin karmaşıklığını artırır, LibC adreslerini manipüle etme gereksinimiyle benzerlik gösterir.
4. **Yığın Adreslerini Sızdırmak Daha Zor Hale Gelir**: İşaretçi karıştırma, fastbin ve tcache binlerindeki Fd işaretçilerinin yığın adres sızıntıları için kaynak olarak kullanılabilirliğini kısıtlar. Ancak, sıralanmamış, küçük ve büyük binlerdeki işaretçiler karıştırılmamış kalır, bu nedenle adres sızdırmak için hala kullanılabilir. Bu değişim, saldırganları istismar edilebilir bilgileri keşfetmek için bu binleri araştırmaya yönlendirir, ancak bazı teknikler hala bir sızıntıdan önce işaretçileri demangling yapmaya izin verebilir, ancak kısıtlamalarla birlikte.

### **Yığın Sızıntısı ile İşaretçileri Demangling**

> [!CAUTION]
> Sürecin daha iyi bir açıklaması için [**orijinal gönderiyi buradan kontrol edin**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Algoritma Genel Görünümü

İşaretçileri karıştırma ve demangling için kullanılan formül:&#x20;

**`New_Ptr = (L >> 12) XOR P`**

Burada **L**, depolama yeridir ve **P**, Fd işaretçisidir. **L** 12 bit sağa kaydırıldığında, **P**'nin en anlamlı bitlerini açığa çıkarır; çünkü **XOR**'un doğası gereği, bitler kendileriyle XORlandığında 0 çıktısı verir.

**Algoritmadaki Ana Adımlar:**

1. **En Anlamlı Bitlerin İlk Sızıntısı**: Kaydırılmış **L**'yi **P** ile XORlayarak, etkili bir şekilde **P**'nin en üst 12 bitini elde edersiniz çünkü kaydırılan **L** kısmı sıfır olacak ve **P**'nin karşılık gelen bitleri değişmeden kalacaktır.
2. **İşaretçi Bitlerinin Kurtarılması**: XOR'un tersinir olması nedeniyle, sonucu ve operandlardan birini bilmek, diğer operandı hesaplamanızı sağlar. Bu özellik, bilinen bit setlerini karıştırılmış işaretçinin parçalarıyla ardışık olarak XORlayarak **P** için tüm bit setini çıkarmak için kullanılır.
3. **İteratif Demangling**: Süreç tekrarlanır, her seferinde bir önceki adımdan elde edilen **P**'nin yeni keşfedilen bitlerini kullanarak karıştırılmış işaretçinin bir sonraki segmentini çözmek için, tüm bitler kurtarılana kadar.
4. **Belirleyici Bitlerin İşlenmesi**: **L**'nin son 12 biti kaydırma nedeniyle kaybolur, ancak bunlar belirleyicidir ve işlem sonrası yeniden inşa edilebilir.

Bu algoritmanın bir uygulamasını burada bulabilirsiniz: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## İşaretçi Koruma

İşaretçi koruma, glibc'de saklanan işlev işaretçilerini korumak için kullanılan bir istismar azaltma tekniğidir, özellikle `atexit()` gibi kütüphane çağrılarıyla kaydedilenler. Bu koruma, işaretçileri bir sır ile XORlayarak ve bit kaydırma uygulayarak karıştırmayı içerir. Bu mekanizma, saldırganların işlev işaretçilerini geçersiz kılarak kontrol akışını ele geçirmesini önlemeyi amaçlar.

### **Bir sızıntı ile İşaretçi Korumasını Aşma**

1. **İşaretçi Koruma İşlemlerini Anlamak:** İşaretçilerin karıştırılması (mangling), işaretçiyi 64-bit bir sır ile XORlayarak ve ardından 0x11 bit sola kaydırarak yapılan `PTR_MANGLE` makrosu kullanılarak gerçekleştirilir. Orijinal işaretçiyi geri almak için ters işlem `PTR_DEMANGLE` ile yapılır.
2. **Saldırı Stratejisi:** Saldırı, saldırganın karıştırılmış bir işaretçinin hem orijinal hem de karıştırılmış versiyonunu bilmesi gereken bilinen-düz metin yaklaşımına dayanır.
3. **Bilinen Düz Metinleri İstismar Etme:**
- **Sabit İşlev İşaretçilerini Belirleme:** glibc kaynak kodunu veya başlatılmış işlev işaretçi tablolarını (örneğin, `__libc_pthread_functions`) inceleyerek, bir saldırgan tahmin edilebilir işlev işaretçilerini bulabilir.
- **Sırrı Hesaplama:** `__pthread_attr_destroy` gibi bilinen bir işlev işaretçisini ve işlev işaretçi tablosundaki karıştırılmış versiyonunu kullanarak, sır, karıştırılmış işaretçiyi ters kaydırarak (sağa kaydırma) ve ardından işlevin adresi ile XORlayarak hesaplanabilir.
4. **Alternatif Düz Metinler:** Saldırgan, 0 veya -1 gibi bilinen değerlerle işaretçileri karıştırmayı deneyerek, bunların bellek içinde tanınabilir desenler üretip üretmediğini görmek için deney yapabilir; bu desenler bellek dökümlerinde bulunduğunda sırrı açığa çıkarabilir.
5. **Pratik Uygulama:** Sırrı hesapladıktan sonra, bir saldırgan işaretçileri kontrollü bir şekilde manipüle edebilir, bu da libc temel adresi bilgisi ve rastgele bellek konumlarını okuma yeteneği ile çoklu iş parçacıklı bir uygulamada İşaretçi Koruma korumasını aşmayı sağlar.

## Referanslar

- [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
- [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)

{{#include ../../banners/hacktricks-training.md}}
