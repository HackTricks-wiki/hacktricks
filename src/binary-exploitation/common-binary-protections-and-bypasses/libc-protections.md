# Protezioni di libc

{{#include ../../banners/hacktricks-training.md}}

## Applicazione dell'allineamento dei chunk

**Malloc** alloca memoria in **raggruppamenti da 8 byte (32-bit) o 16 byte (64-bit)**. Questo significa che la fine dei chunk nei sistemi 32-bit deve essere allineata su **0x8**, e nei sistemi 64-bit su **0x0**. La funzionalità di sicurezza verifica che ogni chunk **sia correttamente allineato** in queste posizioni specifiche prima di usare un puntatore da un bin.

### Vantaggi di sicurezza

L'applicazione dell'allineamento dei chunk nei sistemi 64-bit migliora significativamente la sicurezza di Malloc limitando la collocazione di fake chunk a **solo 1 indirizzo su 16**. Questo rende più complessi gli sforzi di exploitation, specialmente in scenari dove l'input controllabile è limitato, rendendo gli attacchi più difficili da eseguire con successo.

- **Fastbin Attack on `__malloc_hook`**

Le nuove regole di allineamento in Malloc ostacolano anche un attacco classico che coinvolge `__malloc_hook`. In passato gli attaccanti potevano manipolare le dimensioni dei chunk per **sovrascrivere questo puntatore a funzione** e ottenere **esecuzione di codice**. Ora, il requisito di allineamento rigoroso assicura che tali manipolazioni non siano più praticabili, chiudendo una via comune di exploitation e potenziando la sicurezza complessiva.

> **Nota:** Da glibc **2.34** i legacy hooks (`__malloc_hook`, `__free_hook`, ecc.) sono stati rimossi dall'ABI esportata. Gli exploit moderni ora prendono di mira altri puntatori a funzione scrivibili (es. tcache per-thread struct, callback in stile vtable) oppure si affidano a `setcontext`, `_IO_list_all` primitives, ecc.

## Pointer Mangling su fastbins e tcache

**Pointer Mangling** è un miglioramento della sicurezza usato per proteggere i puntatori Fd di **fastbin e tcache** nelle operazioni di gestione della memoria. Questa tecnica aiuta a prevenire certi tipi di tattiche di memory exploit, specificamente quelle che non richiedono informazioni di leak della memoria o che manipolano posizioni di memoria direttamente in modo relativo (relative **overwrites**).

Il nucleo di questa tecnica è una formula di offuscamento:

**`New_Ptr = (L >> 12) XOR P`**

- **L** è la **Storage Location** del puntatore.
- **P** è il reale **fastbin/tcache Fd Pointer**.

La ragione dello shift a destra della Storage Location (L) di 12 bit prima dell'operazione XOR è critica. Questa manipolazione affronta una vulnerabilità intrinseca nella natura deterministica dei 12 bit meno significativi degli indirizzi di memoria, tipicamente prevedibili a causa dei vincoli dell'architettura di sistema. Spostando i bit, la porzione prevedibile viene rimossa dall'equazione, incrementando la casualità del nuovo puntatore offuscato e quindi proteggendo contro exploit che sfruttano la prevedibilità di questi bit.

Questo puntatore mangled sfrutta la casualità già fornita da **Address Space Layout Randomization (ASLR)**, che randomizza gli indirizzi usati dai programmi rendendo difficile per un attacker predire il layout di memoria di un processo.

**Demangling** del puntatore per recuperare l'indirizzo originale implica l'uso della stessa operazione XOR. Qui, il puntatore mangled è trattato come P nella formula e, quando XORato con la Storage Location non modificata (L), rivela il puntatore originale. Questa simmetria tra mangling e demangling permette al sistema di codificare e decodificare i puntatori senza overhead significativo, aumentando però notevolmente la sicurezza contro attacchi che manipolano i puntatori di memoria.

### Vantaggi di sicurezza

Pointer mangling mira a **impedire overwrite parziali e completi dei puntatori nell'heap**, un miglioramento significativo della sicurezza. Questa caratteristica impatta le tecniche di exploitation in diversi modi:

1. **Prevenzione dei Bye Byte Relative Overwrites**: In precedenza gli attaccanti potevano modificare parte di un puntatore per **reindirizzare chunk heap verso posizioni diverse senza conoscere gli indirizzi esatti**, una tecnica evidente nell'exploit leakless **House of Roman**. Con pointer mangling, tali relative overwrites **senza un heap leak ora richiedono brute forcing**, riducendo drasticamente la probabilità di successo.
2. **Maggiore difficoltà negli attacchi su tcache bin/fastbin**: Attacchi comuni che sovrascrivono puntatori a funzione (come `__malloc_hook`) manipolando le voci di fastbin o tcache sono ostacolati. Per esempio, un attacco potrebbe implicare il leak di un indirizzo LibC, il free di un chunk nel tcache bin e poi la sovrascrittura del puntatore Fd per reindirizzarlo a `__malloc_hook` per ottenere esecuzione arbitraria di codice. Con pointer mangling, questi puntatori devono essere correttamente mangled, **richiedendo un heap leak per una manipolazione accurata**, elevando così la barriera per l'exploit.
3. **Richiesta di Heap Leaks per location non-heap**: Creare un fake chunk in aree non-heap (come la stack, la sezione .bss, o PLT/GOT) ora **richiede un heap leak** a causa della necessità del pointer mangling. Questo estende la complessità nel colpire queste aree, similmente alla necessità di manipolare indirizzi LibC.
4. **Estrapolare indirizzi heap tramite leak diventa più difficile**: Pointer mangling limita l'utilità dei puntatori Fd nei fastbin e tcache bin come fonte per leak di indirizzi heap. Tuttavia, i puntatori negli unsorted, small e large bin restano non mangled, quindi ancora utilizzabili per ottenere indirizzi. Questo spinge gli attaccanti a esplorare questi bin per informazioni sfruttabili, sebbene alcune tecniche possano ancora permettere il demangling dei puntatori prima di un leak, seppur con vincoli.

### **Safe-Linking Bypass (page-aligned leak scenario)**

Anche con safe-linking abilitato (glibc ≥ 2.32), se riesci a leakare il puntatore mangled e sia il chunk corrotto che il chunk vittima condividono la stessa pagina da 4KB, il puntatore originale può essere recuperato usando solo l'offset di pagina:
```c
// leaked_fd is the mangled Fd read from the chunk on the same page
uintptr_t l = (uintptr_t)&chunk->fd;           // storage location
uintptr_t original = (leaked_fd ^ (l >> 12));  // demangle
```
This restores the Fd and permits classic tcache/fastbin poisoning. If the chunks sit on different pages, brute-forcing the 12-bit page offset (0x1000 possibilities) is often feasible when allocation patterns are deterministic or when crashes are acceptable (e.g., CTF-style exploits).

### **Demangling Pointers with a Heap Leak**

> [!CAUTION]
> For a better explanation of the process [**check the original post from here**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Panoramica dell'algoritmo

La formula usata per mangling e demangling dei puntatori è:

**`New_Ptr = (L >> 12) XOR P`**

Dove **L** è la location di storage e **P** è il puntatore Fd. Quando **L** viene shiftato a destra di 12 bit, espone i bit più significativi di **P**, a causa della natura dell'operazione **XOR**, che restituisce 0 quando bit identici vengono XORati.

Passaggi chiave nell'algoritmo:

1. **Leak iniziale dei bit più significativi**: XORando lo **L** shiftato con **P**, si ottengono di fatto i top 12 bit di **P** perché la porzione shiftata di **L** sarà zero, lasciando i bit corrispondenti di **P** invariati.
2. **Recupero dei bit del puntatore**: Siccome XOR è reversibile, conoscendo il risultato e uno degli operandi è possibile ricavare l'altro. Questa proprietà viene usata per dedurre l'intero insieme di bit di **P** successivamente XORando insiemi di bit noti con parti del puntatore mangled.
3. **Demangling iterativo**: Il processo viene ripetuto, usando ogni volta i bit appena scoperti di **P** dal passo precedente per decodificare il segmento successivo del puntatore mangled, fino al recupero completo di tutti i bit.
4. **Gestione dei bit deterministici**: Gli ultimi 12 bit di **L** vanno persi a causa dello shift, ma sono deterministici e possono essere ricostruiti dopo il processo.

Puoi trovare un'implementazione di questo algoritmo qui: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer Guard è una tecnica di mitigazione degli exploit usata in glibc per proteggere function pointer memorizzati, in particolare quelli registrati tramite chiamate di libreria come `atexit()`. Questa protezione comporta lo scrambling dei puntatori XORandoli con un segreto memorizzato nei dati del thread (`fs:0x30`) e applicando una rotazione bitwise. Questo meccanismo mira a impedire che un attacker dirotti il controllo sovrascrivendo function pointer.

### **Bypassare Pointer Guard con un leak**

1. **Comprendere le operazioni di Pointer Guard:** Lo scrambling (mangling) dei puntatori è effettuato usando la macro `PTR_MANGLE` che XORa il puntatore con un segreto a 64 bit e poi esegue una rotazione a sinistra di 0x11 bit. L'operazione inversa per recuperare il puntatore originale è gestita da `PTR_DEMANGLE`.
2. **Strategia d'attacco:** L'attacco si basa su un approccio known-plaintext, dove l'attacker deve conoscere sia la versione originale sia quella mangled di un puntatore per dedurre il segreto usato per il mangling.
3. **Sfruttare plaintext noti:**
   - **Identificare function pointer fissi:** Esaminando il codice sorgente di glibc o le tabelle di function pointer inizializzate (come `__libc_pthread_functions`), un attacker può trovare function pointer prevedibili.
   - **Calcolare il segreto:** Utilizzando un function pointer noto come `__pthread_attr_destroy` e la sua versione mangled dalla tabella di function pointer, il segreto può essere calcolato effettuando una rotazione inversa (right rotation) del puntatore mangled e poi XORandolo con l'indirizzo della funzione.
4. **Plaintext alternativi:** L'attacker può anche sperimentare mangling di puntatori con valori noti come 0 o -1 per vedere se questi producono pattern identificabili in memoria, rivelando potenzialmente il segreto quando tali pattern vengono trovati nei dump di memoria.
5. **Applicazione pratica:** Dopo aver calcolato il segreto, un attacker può manipolare i puntatori in modo controllato, bypassando essenzialmente la protezione Pointer Guard in un'applicazione multithreaded conoscendo la base di libc e avendo la capacità di leggere posizioni di memoria arbitrarie.

## GLIBC Tunables & Recent Loader Bugs

Il dynamic loader interpreta `GLIBC_TUNABLES` prima dell'avvio del programma. Bug di mis-parsing qui influenzano direttamente **libc** prima che la maggior parte delle mitigazioni entri in gioco. Il bug "Looney Tunables" del 2023 (CVE-2023-4911) è un esempio: un valore `GLIBC_TUNABLES` troppo lungo overflowa buffer interni in `ld.so`, permettendo privilege escalation su molte distro quando combinato con binari SUID. L'exploitation richiede solo la creazione dell'ambiente e l'invocazione ripetuta del binario target; pointer guard o safe-linking non lo impediscono perché la corruzione avviene nel loader prima della configurazione dell'heap.

## Riferimenti

- [Safe-Linking bypass explanation (shellphish/how2heap)](https://deepwiki.com/shellphish/how2heap/5.2-safe-linking-bypass)
- [Looney Tunables (CVE-2023-4911) write-up](https://www.wiz.io/vulnerability-database/cve/cve-2023-4911)

{{#include ../../banners/hacktricks-training.md}}
