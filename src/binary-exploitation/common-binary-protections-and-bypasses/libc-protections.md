# Libc 보호

{{#include ../../banners/hacktricks-training.md}}

## Chunk Alignment Enforcement

**Malloc**는 메모리를 **8바이트(32-bit) 또는 16바이트(64-bit) 단위**로 할당합니다. 이는 32-bit 시스템에서 청크의 끝이 **0x8**에 정렬되어야 하고, 64-bit 시스템에서는 **0x0**에 정렬되어야 함을 의미합니다. 이 보안 기능은 bin에서 포인터를 사용하기 전에 각 청크가 이러한 특정 위치에 **올바르게 정렬되어 있는지** 확인합니다.

### Security Benefits

64-bit 시스템에서의 청크 정렬 강제는 Malloc의 보안을 크게 향상시켜, 가짜 청크를 특정 주소들 중 **16개 중 1개만** 배치할 수 있도록 제한합니다. 이는 특히 입력값에 대한 제어가 제한된 상황에서 익스플로잇 시도를 복잡하고 어렵게 만듭니다.

- **Fastbin Attack on `__malloc_hook`**

Malloc의 새로운 정렬 규칙은 `__malloc_hook`을 대상으로 한 고전적인 공격도 방해합니다. 이전에는 공격자가 청크 크기를 조작해 이 함수 포인터를 **덮어쓰기**하고 **코드 실행**을 얻을 수 있었지만, 이제 엄격한 정렬 요구사항으로 인해 이러한 조작이 더 이상 실용적이지 않아 일반적인 익스플로잇 경로가 차단되고 전반적인 보안이 향상됩니다.

> **Note:** glibc **2.34** 이후로 레거시 훅들(`__malloc_hook`, `__free_hook`, 등)은 exported ABI에서 제거되었습니다. 현대의 익스플로잇은 이제 다른 쓰기 가능한 함수 포인터들(예: tcache per-thread struct, vtable-style callbacks)을 목표로 하거나 `setcontext`, `_IO_list_all` 프리미티브 등을 이용합니다.

## Pointer Mangling on fastbins and tcache

**Pointer Mangling**은 메모리 관리 작업에서 **fastbin 및 tcache Fd 포인터**를 보호하기 위해 사용되는 보안 향상 기법입니다. 이 기법은 특히 메모리 정보를 요구하지 않거나 상대적 덮어쓰기(relative **overwrites**)로 메모리 위치를 직접 조작하는 특정 유형의 익스플로잇 전술을 방지하는 데 도움이 됩니다.

이 기법의 핵심은 난독화 수식입니다:

**`New_Ptr = (L >> 12) XOR P`**

- **L**은 포인터의 **저장 위치(Storage Location)** 입니다.
- **P**는 실제 **fastbin/tcache Fd Pointer** 입니다.

저장 위치(L)를 오른쪽으로 12비트 시프트한 후 XOR 연산을 수행하는 이유는 중요합니다. 이 조작은 일반적으로 시스템 아키텍처 제약으로 인해 예측 가능한 메모리 주소의 하위 12비트의 결정론적 특성에서 비롯된 취약점을 다룹니다. 비트를 시프트함으로써 예측 가능한 부분을 식에서 제거하여 새로운 난독화된 포인터의 무작위성을 높이고, 하위 비트의 예측성에 의존하는 익스플로잇을 방지합니다.

이 난독화된 포인터는 프로세스의 메모리 레이아웃 예측을 어렵게 만드는 기존의 무작위성인 Address Space Layout Randomization (ASLR)을 활용합니다.

**Demangling**된 포인터를 원래 주소로 복원하려면 동일한 XOR 연산을 사용합니다. 여기서 난독화된 포인터가 수식에서의 P로 취급되며, 변경되지 않은 저장 위치(L)와 XOR하면 원래 포인터가 드러납니다. 이러한 맹글링/디망글링의 대칭성은 시스템이 큰 오버헤드 없이 포인터를 인코딩/디코딩할 수 있게 하면서 포인터 조작 공격에 대한 방어를 크게 향상시킵니다.

### Security Benefits

Pointer mangling은 힙 관리에서의 부분적 및 전체 포인터 덮어쓰기를 **방지**하려는 목적을 가지고 있으며, 이는 보안에 큰 향상을 줍니다. 이 기능은 익스플로잇 기법에 다음과 같은 영향을 미칩니다:

1. 부분 바이트 상대 덮어쓰기(Bye Byte Relative Overwrites) 방지: 이전에는 공격자가 포인터의 일부를 변경하여 **정확한 주소를 모르는 상태에서도** 힙 청크를 다른 위치로 리다이렉트할 수 있었습니다(예: leakless **House of Roman** 익스플로잇). Pointer mangling이 적용되면, heap leak 없이 이러한 상대적 덮어쓰기는 이제 **무차별 대입(bruteforce)**을 요구하게 되어 성공 가능성이 크게 줄어듭니다.
2. Tcache Bin/Fastbin 공격 난이도 상승: fastbin이나 tcache 엔트리를 조작해 함수 포인터들(예: `__malloc_hook`)을 덮어써서 임의 코드 실행을 얻는 흔한 공격들이 더 어려워집니다. 예를 들어, LibC 주소를 leak한 뒤 청크를 tcache에 free하고 Fd 포인터를 덮어써 `__malloc_hook`으로 리다이렉트하는 시나리오는, pointer mangling 때문에 포인터들을 올바르게 맹글링해야 하므로 **정확한 조작을 위해 heap leak이 필요**하게 되어 익스플로잇 장벽이 높아집니다.
3. 비힙 영역에서의 가짜 청크 생성에도 Heap Leaks 필요: 스택, .bss 섹션, 또는 PLT/GOT 같은 비힙 영역에 가짜 청크를 만드는 경우에도 포인터 맹글링 때문에 이제 **heap leak이 요구**됩니다. 이는 LibC 주소 조작과 유사하게 이러한 영역을 익스플로잇하는 복잡성을 증가시킵니다.
4. 힙 주소 유출(Leaking Heap Addresses) 난이도 상승: Pointer mangling은 fastbin 및 tcache 빈의 Fd 포인터를 힙 주소 누출 소스로서 사용하는 것을 제한합니다. 다만 unsorted, small, large bin에 있는 포인터들은 맹글링되지 않으므로 여전히 주소 유출에 사용할 수 있습니다. 이 변화는 공격자가 exploitable 정보를 찾기 위해 이러한 빈들을 더 탐색하도록 만들며, 일부 기법은 제한이 있으나 누출 전에 포인터를 디망글링할 수 있는 방법을 제공할 수도 있습니다.

### **Safe-Linking Bypass (page-aligned leak scenario)**

Even with safe-linking enabled (glibc ≥ 2.32), if you can leak the mangled pointer and both the corrupted chunk and victim chunk share the same 4KB page, the original pointer can be recovered with just the page offset:
```c
// leaked_fd is the mangled Fd read from the chunk on the same page
uintptr_t l = (uintptr_t)&chunk->fd;           // storage location
uintptr_t original = (leaked_fd ^ (l >> 12));  // demangle
```
이렇게 하면 Fd가 복원되어 고전적인 tcache/fastbin poisoning이 가능해진다. 청크들이 서로 다른 페이지에 위치한다면, allocation 패턴이 결정적이거나 충돌(crashes)이 허용되는 경우(예: CTF-style exploits) 12비트 페이지 오프셋(0x1000 possibilities)을 brute-forcing하는 것이 종종 실현 가능하다.

### **힙 leak으로 포인터 디맹글링**

> [!CAUTION]
> 더 나은 설명을 원하면 [**check the original post from here**](https://maxwelldulin.com/BlogPost?post=5445977088)를 참조하라.

### Algorithm Overview

포인터를 mangling/demangling하는 데 사용되는 공식은 다음과 같다:

**`New_Ptr = (L >> 12) XOR P`**

여기서 **L**은 저장 위치(storage location)이고 **P**는 Fd 포인터이다. **L**을 12비트만큼 오른쪽으로 시프트하면 XOR의 특성상 동일한 비트는 0을 만들어내므로 **P**의 최상위 비트들이 드러난다.

**알고리즘의 주요 단계:**

1. **최상위 비트 초기 누출(leak):** 시프트된 **L**을 **P**와 XOR하면, 시프트된 부분이 0이 되어 **P**의 상위 12비트를 효과적으로 얻을 수 있다.
2. **포인터 비트 복구:** XOR은 가역적이므로 결과와 한 쪽 피연산자를 알고 있으면 다른 피연산자를 계산할 수 있다. 이 성질을 이용해 mangled 포인터의 부분들과 알려진 비트들을 successive하게 XOR하여 **P**의 전체 비트들을 유추한다.
3. **반복적 디맹글링:** 이전 단계에서 새로 발견한 **P**의 비트들을 이용해 mangled 포인터의 다음 세그먼트를 해독하는 과정을 반복하여 모든 비트를 복원한다.
4. **결정적 비트 처리:** **L**의 마지막 12비트는 시프트 때문에 손실되지만, 이 비트들은 결정적(deterministic)이므로 후처리로 재구성할 수 있다.

이 알고리즘의 구현은 여기에서 확인할 수 있다: https://github.com/mdulin2/mangle

## Pointer Guard

Pointer Guard는 glibc에서 atexit()와 같은 라이브러리 호출로 등록된 저장된 함수 포인터들을 보호하기 위해 사용되는 exploit mitigation 기법이다. 이 보호는 포인터들을 thread data(`fs:0x30`)에 저장된 비밀값과 XOR하고 비트 회전(rotation)을 적용하여 스크램블하는 방식으로 이루어진다. 이 메커니즘은 공격자가 함수 포인터를 덮어써서 제어 흐름을 탈취하는 것을 방지하는 것을 목적으로 한다.

### **leak으로 Pointer Guard 우회**

1. **Pointer Guard 동작 이해:** 포인터의 스크램블(mangling)은 64비트 비밀값과 포인터를 XOR한 뒤 0x11 비트만큼 왼쪽 회전하는 `PTR_MANGLE` 매크로로 수행된다. 원래 포인터를 복구하는 역연산은 `PTR_DEMANGLE`에 의해 처리된다.
2. **공격 전략:** 공격은 known-plaintext 접근법에 기반하며, 공격자는 mangling에 사용된 비밀(secret)을 유추하기 위해 포인터의 원본과 mangled 버전 둘 다를 알아야 한다.
3. **Known Plaintexts 악용:**
- **고정된 함수 포인터 식별:** glibc 소스 코드를 조사하거나 초기화된 함수 포인터 테이블(예: `__libc_pthread_functions`)을 보면 예측 가능한 함수 포인터들을 찾을 수 있다.
- **비밀 계산:** `__pthread_attr_destroy`와 같은 알려진 함수 포인터와 함수 포인터 테이블에서의 그 mangled 버전을 사용해, mangled 포인터를 오른쪽으로 역회전(reverse rotating)한 뒤 함수의 주소와 XOR하면 비밀을 계산할 수 있다.
4. **대체 가능한 Plaintexts:** 공격자는 0이나 -1 같은 알려진 값으로 포인터를 mangling해 보고, 메모리에서 식별 가능한 패턴을 생성하는지 실험할 수 있으며, 메모리 덤프에서 이러한 패턴이 발견되면 비밀이 드러날 수 있다.
5. **실전 적용:** 비밀을 계산한 후에는 포인터를 통제된 방식으로 조작할 수 있어, libc base 주소를 알고 임의 메모리 읽기가 가능한 경우 멀티스레드 애플리케이션에서 Pointer Guard 보호를 실질적으로 우회할 수 있다.

## GLIBC Tunables & Recent Loader Bugs

dynamic loader는 프로그램 시작 전에 `GLIBC_TUNABLES`를 파싱한다. 여기서의 잘못된 파싱 버그는 대부분의 완화 기법들이 활성화되기 전에 **libc**에 직접적인 영향을 미친다. 2023년의 "Looney Tunables" 버그(CVE-2023-4911)는 그 예로, 과도하게 긴 `GLIBC_TUNABLES` 값이 `ld.so`의 내부 버퍼를 오버플로우시켜 SUID binaries와 결합될 경우 많은 배포판에서 privilege escalation을 가능하게 한다. Exploitation은 환경 변수를 조작하고 타깃 바이너리를 반복적으로 호출하는 것만으로도 가능하며, corruption이 loader에서 발생해 heap 설정 이전에 일어나기 때문에 pointer guard나 safe-linking으로는 방지되지 않는다.

## References

- [Safe-Linking bypass explanation (shellphish/how2heap)](https://deepwiki.com/shellphish/how2heap/5.2-safe-linking-bypass)
- [Looney Tunables (CVE-2023-4911) write-up](https://www.wiz.io/vulnerability-database/cve/cve-2023-4911)

{{#include ../../banners/hacktricks-training.md}}
