# Libc Korumaları

{{#include ../../banners/hacktricks-training.md}}

## Chunk Hizalama Denetimi

**Malloc** belleği **8-byte (32-bit) veya 16-byte (64-bit) gruplar** halinde ayırır. Bu, 32-bit sistemlerde chunk sonlarının **0x8** ile, 64-bit sistemlerde ise **0x0** ile hizalanması gerektiği anlamına gelir. Güvenlik özelliği, bir bin içinden alınan işaretçi kullanılmadan önce her bir chunk'ın bu belirli konumlarda **doğru şekilde hizalanıp hizalanmadığını** kontrol eder.

### Güvenlik Faydaları

64-bit sistemlerde chunk hizalama denetiminin uygulanması, Malloc'ın güvenliğini önemli ölçüde artırır; çünkü sahte chunk'ların yerleştirilebileceği adresleri **her 16 adresten yalnızca 1'iyle** sınırlar. Bu, özellikle kullanıcı giriş değerleri üzerinde sınırlı kontrole sahip durumlarda istismar çabalarını zorlaştırır ve saldırıları daha karmaşık hale getirir.

- **Fastbin Attack on `__malloc_hook`**

Malloc'taki yeni hizalama kuralları, `__malloc_hook` ile ilgili klasik bir saldırıyı da engeller. Önceden saldırganlar chunk boyutlarını manipüle ederek bu fonksiyon işaretçisini **overwrite** edebilir ve **code execution** elde edebilirdi. Artık sıkı hizalama gereksinimi, bu tür manipülasyonların uygulanabilir olmasını engelleyerek yaygın bir istismar yolunu kapatır ve genel güvenliği artırır.

> **Not:** glibc **2.34**'ten itibaren legacy hook'lar (`__malloc_hook`, `__free_hook`, vb.) exported ABI'den kaldırılmıştır. Modern exploit'ler artık diğer yazılabilir fonksiyon işaretçilerini (ör. tcache per-thread struct, vtable-style callbacks) hedef alır veya `setcontext`, `_IO_list_all` primitiflerine dayanır.

## fastbins ve tcache üzerinde Pointer Mangling

**Pointer Mangling**, bellek yönetimi işlemlerinde **fastbin ve tcache Fd pointer'larını** korumak için kullanılan bir güvenlik iyileştirmesidir. Bu teknik, özellikle heap üzerinde leaked bilgi gerektirmeyen veya bilinen konumlara göre doğrudan manipülasyon yapan (nispi **overwrites**) bazı bellek istismar taktiklerini önlemeye yardımcı olur.

Tekniğin özü bir karıştırma formülüdür:

**`New_Ptr = (L >> 12) XOR P`**

- **L** işaretçinin bulunduğu **Depolama Konumu**dur.
- **P** gerçek **fastbin/tcache Fd Pointer**dır.

Depolama konumunun (L) 12 bit sağa kaydırılmasının ve ardından XOR işlemi uygulanmasının gerekçesi kritiktir. Bu manipülasyon, adreslerin en düşük anlamlı 12 bitinin deterministik doğasında bulunan bir zayıflığı ele alır; bu bitler genellikle sistem mimarisi kısıtlamaları nedeniyle öngörülebilirdir. Bitleri kaydırarak, öngörülebilir kısım denklem dışına taşınır, böylece yeni, mangled işaretçi daha rastgele hale gelir ve bu bitlerin öngörülebilirliğine dayanan istismarları zorlaştırır.

Bu mangled işaretçi, programların kullandığı adresleri tahmin etmeyi zorlaştıran mevcut rastgelelikten yararlanır: Address Space Layout Randomization (ASLR).

**Demangling** ile orijinal adresi elde etmek, aynı XOR işlemini kullanmayı gerektirir. Burada mangled işaretçi formülde P gibi ele alınır ve değişmemiş depolama konumu (L) ile XORlandığında orijinal işaretçi ortaya çıkar. Mangling ve demangling'deki bu simetri, sistemin işaretçileri önemli bir yük getirmeden verimli biçimde kodlayıp çözmesine olanak tanırken, bellek işaretçilerini manipüle eden saldırılara karşı önemli bir güvenlik artışı sağlar.

### Güvenlik Faydaları

Pointer mangling, heap yönetiminde **kısmi ve tam işaretçi overwrite'larını önlemeyi** amaçlar; bu, güvenlik açısından önemli bir geliştirmedir. Bu özellik, istismar tekniklerini birkaç şekilde etkiler:

1. **Byte-by-byte Nispi Overwrite'ların Önlenmesi**: Önceden saldırganlar bir işaretçinin bir kısmını değiştirerek **tam adresi bilmeden** heap chunk'ları farklı yerlere yönlendirebiliyordu; bu, leakless **House of Roman** istismarı gibi tekniklerde görülür. Pointer mangling ile, heap leak olmadan yapılan bu tür nispi overwrite'lar artık brute forcing gerektirir ve başarı olasılığını ciddi şekilde düşürür.
2. **Tcache Bin/Fastbin Saldırılarının Zorluğu Artar**: Fastbin veya tcache girdilerini manipüle ederek fonksiyon işaretçilerini (ör. `__malloc_hook`) overwrite etmeye dayanan yaygın saldırılar zorlaşır. Örneğin, bir saldırı LibC adresini leak edip bir chunk'ı tcache bin'e free ettikten sonra Fd işaretçisini overwrite ederek `__malloc_hook`'a yönlendirip arbitrary code execution elde etmeyi hedefleyebilir. Pointer mangling ile bu işaretçilerin doğru şekilde mangled olması gerekir; bu da doğru manipülasyon için bir heap leak gerektirir ve istismar bariyerini yükseltir.
3. **Heap Dışı Konumlarda Sahte Chunk Oluşturma İçin Heap leak Gerekliliği**: Yığından farklı yerlerde (stack, .bss bölümü veya PLT/GOT gibi) sahte chunk yaratmak artık pointer mangling yüzünden bir heap leak gerektirir. Bu, bu alanların istismarını LibC adreslerini manipüle etme gereksinimine benzer şekilde daha karmaşık hale getirir.
4. **Heap Adreslerini Leak Etme Daha Zor Hale Gelir**: Pointer mangling, fastbin ve tcache binlerindeki Fd işaretçilerini heap adresi leak kaynağı olarak kullanılmasını kısıtlar. Bununla birlikte, unsorted, small ve large binlerdeki işaretçiler mangled olmadığından hala adres leak için kullanılabilir. Bu durum saldırganları bu binleri hedeflemeye iter, ancak bazı teknikler leak öncesinde işaretçileri demangle etmeyi mümkün kılabilir; yine de kısıtlamalar mevcuttur.

### **Safe-Linking Bypass (page-aligned leak scenario)**

Safe-Linking etkin olsa bile (glibc ≥ 2.32), eğer mangled işaretçiyi leak edebiliyor ve bozulmuş chunk ile victim chunk aynı 4KB sayfayı paylaşıyorsa, orijinal işaretçi yalnızca sayfa offset'i ile geri elde edilebilir:
```c
// leaked_fd is the mangled Fd read from the chunk on the same page
uintptr_t l = (uintptr_t)&chunk->fd;           // storage location
uintptr_t original = (leaked_fd ^ (l >> 12));  // demangle
```
Bu, Fd'yi geri yükler ve klasik tcache/fastbin poisoning'e izin verir. Eğer chunks farklı sayfalarda yer alıyorsa, allocation patterns deterministik olduğunda veya çökme kabul edilebilirse (ör. CTF-style exploits), 12-bit sayfa offset'ini (0x1000 olasılık) brute-forcing ile denemek genellikle mümkündür.

### **Demangling Pointers with a Heap Leak**

> [!CAUTION]
> Sürecin daha iyi açıklaması için [**check the original post from here**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Algorithm Overview

The formula used for mangling and demangling pointers is:

**`New_Ptr = (L >> 12) XOR P`**

Where **L** is the storage location and **P** is the Fd pointer. When **L** is shifted right by 12 bits, it exposes the most significant bits of **P**, due to the nature of **XOR**, which outputs 0 when bits are XORed with themselves.

**Key Steps in the Algorithm:**

1. **Initial Leak of the Most Significant Bits**: SHIFTED L ile P'nin XOR'lanması sonucunda, L'nin kaydırılmış kısmı sıfır olacağından P'nin üst 12 biti etkili şekilde elde edilir; böylece P'nin en anlamlı bitleri açığa çıkar.
2. **Recovery of Pointer Bits**: XOR tersinir olduğundan, sonucu ve operandlardan birini bilmek diğer operandı hesaplamaya olanak verir. Bu özellik, bilinen bit kümelerini mangled pointer'ın parçaları ile sırasıyla XORlayarak P'nin tüm bit setini çıkarmakta kullanılır.
3. **Iterative Demangling**: İşlem tekrarlanır; her adımda önceki adımda keşfedilen P bitleri, mangled pointer'ın bir sonraki segmentini çözmek için kullanılır; bu, tüm bitler kurtarılana kadar sürdürülür.
4. **Handling Deterministic Bits**: L'nin son 12 biti kaydırma nedeniyle kaybolur, ancak bu bitler deterministik olduğundan işlem sonrası yeniden inşa edilebilir.

You can find an implementation of this algorithm here: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer guard, glibc'de saklanan function pointer'ları, özellikle `atexit()` gibi kütüphane çağrılarıyla kayıt edilenleri korumak için kullanılan bir exploit mitigation tekniğidir. Bu koruma, pointer'ları thread verisinde (`fs:0x30`) saklanan bir gizli değerle XOR'layıp ardından 0x11 bit sola rotasyon uygulamayı içerir. Orijinal pointer'ı geri elde etmek için ters işlem PTR_DEMANGLE tarafından gerçekleştirilir. Bu mekanizma, function pointer'ları üzerine yazarak kontrol akışını ele geçirme girişimlerini engellemeyi amaçlar.

### **Bypassing Pointer Guard with a leak**

1. **Understanding Pointer Guard Operations:** Pointer'ların scrambling (mangling) işlemi PTR_MANGLE makrosu ile yapılır; bu makro pointer'ı 64-bit bir gizli değerle XOR'lar ve sonra 0x11 bitlik bir left rotation uygular. Orijinal pointer'ın kurtarılması için ters işlem PTR_DEMANGLE ile yapılır.
2. **Attack Strategy:** Saldırı, known-plaintext yaklaşımına dayanır; saldırgan, mangling için kullanılan sırrı çıkarmak üzere bir pointer'ın hem orijinal hem de mangled versiyonlarını bilmek zorundadır.
3. **Exploiting Known Plaintexts:**
- **Identifying Fixed Function Pointers:** glibc kaynak kodunu veya başlatılmış function pointer tablolarını (ör. `__libc_pthread_functions`) inceleyerek saldırgan, öngörülebilir function pointer'lar bulabilir.
- **Computing the Secret:** `__pthread_attr_destroy` gibi bilinen bir function pointer ile function pointer tablosundaki mangled versiyonunu kullanarak, mangled pointer'ı ters döndürüp (right rotation) ardından function adresi ile XORlayarak sırrı hesaplayabilir.
4. **Alternative Plaintexts:** Saldırgan ayrıca pointer'ları 0 veya -1 gibi bilinen değerlerle mangling yapmayı deneyebilir; bu değerlerin bellek dökümlerinde tanınabilir desenler oluşturup oluşturmadığını kontrol ederek sırrın açığa çıkmasını sağlayabilir.
5. **Practical Application:** Sırrı hesapladıktan sonra, saldırgan kontrollü bir şekilde pointer'ları manipüle edebilir; böylece libc base adresinin bilinmesi ve rasgele bellek lokasyonlarını okuma yeteneği ile çoklu iş parçacıklı bir uygulamada Pointer Guard koruması bypass edilebilir.

## GLIBC Tunables & Recent Loader Bugs

Dinamik loader program başlatılmadan önce `GLIBC_TUNABLES`'ı parse eder. Buradaki mis-parse bug'ları, most mitigations devreye girmeden önce doğrudan **libc**'yi etkiler. 2023 "Looney Tunables" hatası (CVE-2023-4911) buna bir örnektir: aşırı uzun bir `GLIBC_TUNABLES` değeri `ld.so` içindeki iç buffer'ları taşırarak, SUID ikili dosyalarla birleştirildiğinde birçok dağıtımda **privilege escalation**'a imkan verir. Exploitation yalnızca ortamın oluşturulmasını ve hedef ikili dosyanın tekrar tekrar çalıştırılmasını gerektirir; pointer guard veya safe-linking bunu engellemez çünkü bozulma heap kurulmadan önce loader içinde gerçekleşir.

## References

- [Safe-Linking bypass explanation (shellphish/how2heap)](https://deepwiki.com/shellphish/how2heap/5.2-safe-linking-bypass)
- [Looney Tunables (CVE-2023-4911) write-up](https://www.wiz.io/vulnerability-database/cve/cve-2023-4911)

{{#include ../../banners/hacktricks-training.md}}
