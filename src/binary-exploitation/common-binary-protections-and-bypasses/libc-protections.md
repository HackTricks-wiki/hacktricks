# Libc zaštite

{{#include ../../banners/hacktricks-training.md}}

## Chunk Alignment Enforcement

**Malloc** dodeljuje memoriju u grupama od **8 bajta (32-bit) ili 16 bajta (64-bit)**. To znači da krajevi chunk-ova na 32-bitnim sistemima treba da budu poravnati sa **0x8**, a na 64-bitnim sistemima sa **0x0**. Bezbednosna funkcija proverava da li se svaki chunk **ispravno poravnava** na ovim specifičnim lokacijama pre korišćenja pokazivača iz binned strukture.

### Sigurnosne prednosti

Sprovodjenje poravnanja chunk-ova na 64-bitnim sistemima značajno poboljšava sigurnost Malloc-a tako što **ograničava postavljanje lažnih chunk-ova na samo 1 od svakih 16 adresa**. Ovo komplikuje napade, naročito u scenarijima gde korisnik ima ograničenu kontrolu nad ulaznim vrednostima, čineći exploite složenijim i teže izvodljivim.

- **Fastbin Attack on `__malloc_hook`**

Novi zahtevi za poravnanjem u Malloc-u takođe onemogućavaju klasičan napad koji targetira `__malloc_hook`. Ranije su napadači mogli manipulisati veličinama chunk-ova da bi **prepisali ovaj pokazivač na funkciju** i dobili **izvršavanje koda**. Sada, strogi zahtev za poravnanjem osigurava da takve manipulacije više nisu izvodljive, zatvarajući uobičajen put za eksploataciju i poboljšavajući ukupnu sigurnost.

> **Napomena:** Počevši od glibc **2.34**, legacy hooks (`__malloc_hook`, `__free_hook`, itd.) su uklonjeni iz eksportovanog ABI-ja. Moderni exploit-i sada targetiraju druge writable pokazivače na funkcije (npr. tcache per-thread struct, vtable-style callbacks) ili se oslanjaju na `setcontext`, `_IO_list_all` primitiva, itd.

## Pointer Mangling on fastbins and tcache

**Pointer Mangling** je bezbednosno poboljšanje koje se koristi za zaštitu **fastbin i tcache Fd pokazivača** u operacijama upravljanja memorijom. Ova tehnika pomaže da se spreče određene vrste taktika za exploataciju memorije, posebno one koje ne zahtevaju leak-ovanje memorijskih informacija ili koje manipulišu lokacijama memorije direktno relativno poznatih pozicija (relativni **overwrites**).

Osnova ove tehnike je formula za obfuskaciju:

**`New_Ptr = (L >> 12) XOR P`**

- **L** je **Storage Location** pokazivača.
- **P** je stvarni **fastbin/tcache Fd Pointer**.

Razlog za bit-shift of Storage Location (L) za 12 bita udesno pre XOR operacije je ključan. Ova manipulacija rešava ranjivost ugrađenu u determinističku prirodu najmanje značajnih 12 bita memorijskih adresa, koji su tipično predvidivi zbog arhitekturnih ograničenja sistema. Pomeranjem bitova, predvidivi deo se izbacuje iz jednačine, povećavajući nasumičnost novog, mangled pokazivača i time štiteći protiv eksploata koji se oslanjaju na predvidivost tih bitova.

Ovaj mangled pokazivač koristi postojeću nasumičnost koju obezbeđuje **Address Space Layout Randomization (ASLR)**, koja randomizuje adrese koje programi koriste kako bi otežala napadačima predviđanje memorijskog rasporeda procesa.

Demanglovanje pokazivača da bi se dobila originalna adresa podrazumeva korišćenje iste XOR operacije. U tom slučaju, mangled pokazivač se tretira kao P u formuli, i kada se XOR-uje sa nepromenjenom Storage Location (L), rezultat je otkrivanje originalnog pokazivača. Ova simetrija u manglingu i demanglingu omogućava sistemu efikasno kodiranje i dekodiranje pokazivača bez značajnog overhead-a, istovremeno znatno povećavajući sigurnost protiv napada koji manipulišu pokazivačima memorije.

### Sigurnosne prednosti

Pointer mangling ima za cilj da **spreči parcijalne i potpune overwrite-ove pokazivača u heap-u**, što je značajno poboljšanje sigurnosti. Ova funkcija utiče na tehnike exploita na nekoliko načina:

1. **Prevencija Bye Byte Relative Overwrites**: Ranije su napadači mogli promeniti deo pokazivača da bi **preusmerili heap chunk-ove na različite lokacije bez poznavanja tačnih adresa**, tehnika vidljiva u leakless exploit-u **House of Roman**. Sa pointer mangling-om, takvi relativni overwrite-ovi **bez heap leak-a sada zahtevaju brute forcing**, što znatno smanjuje verovatnoću uspeha.
2. **Povećana težina napada na Tcache Bin/Fastbin**: Uobičajeni napadi koji prepisuju pokazivače na funkcije (kao `__malloc_hook`) manipulisanjem fastbin ili tcache unosa su otežani. Na primer, napad može uključivati leak-ovanje LibC adrese, free-ovanje chunka u tcache bin, i zatim overwrite Fd pokazivača da bi ga preusmerio na `__malloc_hook` radi arbitrarne eksekucije koda. Sa pointer mangling-om, ti pokazivači moraju biti pravilno mangled, **zahtevajući heap leak za tačnu manipulaciju**, čime se podiže barijera za exploataciju.
3. **Zahtev za heap leak-om pri kreiranju fake chunk-ova u ne-heap lokacijama**: Kreiranje lažnog chunka u ne-heap oblastima (kao stack, .bss sekcija, ili PLT/GOT) sada takođe **zahteva heap leak** zbog potrebe za pointer mangling-om. Ovo proširuje kompleksnost exploata na tim oblastima, slično zahtevu za manipulaciju LibC adresa.
4. **Leak-ovanje heap adresa postaje izazovnije**: Pointer mangling ograničava upotrebljivost Fd pokazivača u fastbin i tcache bin-ovima kao izvora leak-ova heap adresa. Međutim, pokazivači u unsorted, small i large bin-ovima ostaju nemangled, pa su i dalje upotrebljivi za leak-ovanje adresa. Ova promena tera napadače da istraže te bin-ove za eksploatabilne informacije, iako neke tehnike i dalje mogu omogućiti demanglovanje pokazivača pre leak-a, uz ograničenja.

### **Safe-Linking Bypass (page-aligned leak scenario)**

Čak i sa safe-linking omogućenim (glibc ≥ 2.32), ako možete leak-ovati mangled pokazivač i ako i korumpirani chunk i victim chunk dele istu 4KB stranicu, originalni pokazivač se može rekonstruisati samo pomoću page offset-a:
```c
// leaked_fd is the mangled Fd read from the chunk on the same page
uintptr_t l = (uintptr_t)&chunk->fd;           // storage location
uintptr_t original = (leaked_fd ^ (l >> 12));  // demangle
```
Ovo vraća Fd i omogućava klasično tcache/fastbin poisoning. Ako se chunk-ovi nalaze na različitim stranicama, brute-force 12-bitnog page offset-a (0x1000 mogućnosti) je često izvodljiv kada su obrasci alokacije deterministički ili kada su crash-evi prihvatljivi (npr. CTF-style exploits).

### **Demanglovanje pokazivača pomoću heap leak-a**

> [!CAUTION]
> Za bolje objašnjenje procesa [**pogledajte originalni post ovde**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Pregled algoritma

Formula koja se koristi za mangling i demangling pokazivača je:

**`New_Ptr = (L >> 12) XOR P`**

Gde su **L** mesto skladištenja, a **P** Fd pokazivač. Kada se **L** pomeri desno za 12 bita, otkriva najznačajnije bitove **P** zbog prirode **XOR**, koji daje 0 kada se isti bitovi XOR-uju sami sa sobom.

Ključni koraci u algoritmu:

1. Početni leak najznačajnijih bitova: XOR-ovanjem pomerenog **L** sa **P** dobijaju se top 12 bitova od **P**, jer će pomereni deo **L** biti nula, ostavljajući odgovarajuće bitove **P** neizmenjene.
2. Obnavljanje bitova pokazivača: Pošto je XOR reverzibilan, poznavanje rezultata i jednog operanda omogućava izračunavanje drugog operanda. Ova osobina se koristi za dedukciju celog skupa bitova za **P** sukcesivnim XOR-ovanjem poznatih skupova bitova sa delovima manglovanog pokazivača.
3. Iterativno demanglovanje: Proces se ponavlja, svaki put koristeći novo otkrivene bitove **P** iz prethodnog koraka za dekodiranje sledećeg segmenta manglovanog pokazivača, dok se svi bitovi ne obnove.
4. Rukovanje determinističkim bitovima: Poslednjih 12 bitova **L** se gubi zbog pomeranja, ali su deterministički i mogu se rekonstruisati nakon procesa.

Implementaciju ovog algoritma možete pronaći ovde: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer Guard je tehnika mitigacije eksploata koja se koristi u glibc-u za zaštitu uskladištenih funkcijskih pokazivača, naročito onih registrovanih pozivima biblioteke poput `atexit()`. Ova zaštita uključuje skrambovanje pokazivača XOR-ovanjem sa tajnom koja se čuva u thread podacima (`fs:0x30`) i primenu bitwise rotacije. Mekanizam ima za cilj da spreči napadače da preuzmu kontrolu nad tokom izvršenja prepisivanjem funkcijskih pokazivača.

### **Zaobilaženje Pointer Guard-a pomoću leak-a**

1. Razumevanje operacija Pointer Guard-a: Scrambling (mangling) pokazivača se vrši pomoću makroa `PTR_MANGLE` koji XOR-uje pokazivač sa 64-bitnom tajnom i zatim vrši left rotation od 0x11 bita. Reverzna operacija za vraćanje originalnog pokazivača se obavlja pomoću `PTR_DEMANGLE`.
2. Strategija napada: Napad se zasniva na pristupu poznatog-plaintext-a, gde napadač treba da zna i originalnu i manglovanu verziju pokazivača da bi izvukao tajnu korišćenu za mangling.
3. Eksploatisanje poznatih plaintext-a:
- Identifikacija fiksnih funkcijskih pokazivača: Pregledom izvornog koda glibc-a ili inicijalizovanih tabela funkcijskih pokazivača (kao što je `__libc_pthread_functions`), napadač može naći predvidljive funkcijske pokazivače.
- Izračunavanje tajne: Koristeći poznati funkcijski pokazivač poput `__pthread_attr_destroy` i njegovu manglovanu verziju iz tabele funkcijskih pokazivača, tajna se može izračunati reverznom rotacijom (right rotation) manglovanog pokazivača i zatim XOR-ovanjem sa adresom funkcije.
4. Alternativni plaintext-i: Napadač takođe može eksperimentisati sa manglovanjem pokazivača poznatim vrednostima kao što su 0 ili -1 da vidi da li to proizvodi prepoznatljive obrasce u memoriji, što potencijalno može otkriti tajnu kada se ti obrasci pronađu u dump-ovima memorije.
5. Praktična primena: Nakon izračunavanja tajne, napadač može manipulisati pokazivačima na kontrolisan način, praktično zaobilazeći Pointer Guard zaštitu u multithreaded aplikaciji uz poznavanje libc base address i mogućnost čitanja proizvoljnih memorijskih lokacija.

## GLIBC Tunables & Recent Loader Bugs

Dinamički loader parsira `GLIBC_TUNABLES` pre pokretanja programa. Greške u parsiranju ovde utiču direktno na **libc** pre nego što većina mitigacija postane aktivna. Bug iz 2023. poznat kao "Looney Tunables" (CVE-2023-4911) je primer: predugačka vrednost `GLIBC_TUNABLES` prelivala je interne bafer-e u `ld.so`, omogućavajući privilege escalation na mnogim distro-ima kada se kombinuje sa SUID binarima. Eksploatacija zahteva samo kreiranje okruženja i ponovljeno pozivanje ciljne binarne; pointer guard ili safe-linking ne sprečavaju ovo jer se korupcija dešava u loader-u pre nego što heap bude postavljen.

## References

- [Safe-Linking bypass explanation (shellphish/how2heap)](https://deepwiki.com/shellphish/how2heap/5.2-safe-linking-bypass)
- [Looney Tunables (CVE-2023-4911) write-up](https://www.wiz.io/vulnerability-database/cve/cve-2023-4911)

{{#include ../../banners/hacktricks-training.md}}
