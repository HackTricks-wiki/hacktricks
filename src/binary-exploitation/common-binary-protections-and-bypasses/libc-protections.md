# Protections Libc

{{#include ../../banners/hacktricks-training.md}}

## Application de l'Alignement des Chunks

**Malloc** alloue de la mémoire en **groupes de 8 octets (32 bits) ou 16 octets (64 bits)**. Cela signifie que la fin des chunks dans les systèmes 32 bits doit s'aligner avec **0x8**, et dans les systèmes 64 bits avec **0x0**. La fonctionnalité de sécurité vérifie que chaque chunk **s'aligne correctement** à ces emplacements spécifiques avant d'utiliser un pointeur d'un bin.

### Avantages Sécuritaires

L'application de l'alignement des chunks dans les systèmes 64 bits améliore considérablement la sécurité de Malloc en **limitant le placement de faux chunks à seulement 1 sur 16 adresses**. Cela complique les efforts d'exploitation, en particulier dans les scénarios où l'utilisateur a un contrôle limité sur les valeurs d'entrée, rendant les attaques plus complexes et plus difficiles à exécuter avec succès.

- **Attaque Fastbin sur \_\_malloc_hook**

Les nouvelles règles d'alignement dans Malloc contrecarrent également une attaque classique impliquant le `__malloc_hook`. Auparavant, les attaquants pouvaient manipuler les tailles de chunks pour **écraser ce pointeur de fonction** et obtenir **l'exécution de code**. Maintenant, l'exigence stricte d'alignement garantit que de telles manipulations ne sont plus viables, fermant une voie d'exploitation courante et améliorant la sécurité globale.

## Mangling de Pointeur sur fastbins et tcache

**Mangling de Pointeur** est une amélioration de sécurité utilisée pour protéger les **pointeurs Fd de fastbin et tcache** dans les opérations de gestion de mémoire. Cette technique aide à prévenir certains types de tactiques d'exploitation de mémoire, spécifiquement celles qui ne nécessitent pas d'informations de mémoire divulguées ou qui manipulent directement les emplacements de mémoire par rapport à des positions connues (écritures **relatives**).

Le cœur de cette technique est une formule d'obfuscation :

**`New_Ptr = (L >> 12) XOR P`**

- **L** est la **Localisation de Stockage** du pointeur.
- **P** est le **Pointeur Fd de fastbin/tcache**.

La raison du décalage binaire de la localisation de stockage (L) de 12 bits vers la droite avant l'opération XOR est critique. Cette manipulation traite une vulnérabilité inhérente à la nature déterministe des 12 bits de poids faible des adresses mémoire, qui sont généralement prévisibles en raison des contraintes d'architecture système. En décalant les bits, la portion prévisible est déplacée hors de l'équation, améliorant l'aléatoire du nouveau pointeur manglé et protégeant ainsi contre les exploits qui s'appuient sur la prévisibilité de ces bits.

Ce pointeur manglé tire parti de l'aléatoire existant fourni par **Address Space Layout Randomization (ASLR)**, qui randomise les adresses utilisées par les programmes pour rendre difficile pour les attaquants de prédire la disposition mémoire d'un processus.

**Démangling** du pointeur pour récupérer l'adresse originale implique d'utiliser la même opération XOR. Ici, le pointeur manglé est traité comme P dans la formule, et lorsqu'il est XORé avec la localisation de stockage inchangée (L), cela révèle le pointeur original. Cette symétrie dans le mangling et le démangling garantit que le système peut encoder et décoder efficacement les pointeurs sans surcharge significative, tout en augmentant considérablement la sécurité contre les attaques qui manipulent les pointeurs de mémoire.

### Avantages Sécuritaires

Le mangling de pointeur vise à **prévenir les écrasements partiels et complets de pointeur dans la gestion de heap**, une amélioration significative de la sécurité. Cette fonctionnalité impacte les techniques d'exploitation de plusieurs manières :

1. **Prévention des Écritures Relatives Bye Byte** : Auparavant, les attaquants pouvaient changer une partie d'un pointeur pour **rediriger les chunks de heap vers différentes localisations sans connaître les adresses exactes**, une technique évidente dans l'exploitation sans fuite **House of Roman**. Avec le mangling de pointeur, de telles écritures relatives **sans fuite de heap nécessitent maintenant un bruteforce**, réduisant considérablement leur probabilité de succès.
2. **Difficulté Accrue des Attaques Tcache Bin/Fastbin** : Les attaques courantes qui écrasent les pointeurs de fonction (comme `__malloc_hook`) en manipulant les entrées fastbin ou tcache sont entravées. Par exemple, une attaque pourrait impliquer de divulguer une adresse LibC, de libérer un chunk dans le bin tcache, puis d'écraser le pointeur Fd pour le rediriger vers `__malloc_hook` pour une exécution de code arbitraire. Avec le mangling de pointeur, ces pointeurs doivent être correctement manglés, **nécessitant une fuite de heap pour une manipulation précise**, augmentant ainsi la barrière d'exploitation.
3. **Exigence de Fuites de Heap dans des Localisations Non-Heap** : Créer un faux chunk dans des zones non-heap (comme la pile, la section .bss, ou PLT/GOT) nécessite également **une fuite de heap** en raison de la nécessité de mangling de pointeur. Cela étend la complexité d'exploitation de ces zones, similaire à l'exigence de manipulation des adresses LibC.
4. **Les Fuites d'Adresses de Heap Devenant Plus Difficiles** : Le mangling de pointeur restreint l'utilité des pointeurs Fd dans les bins fastbin et tcache comme sources de fuites d'adresses de heap. Cependant, les pointeurs dans les bins non triés, petits et grands restent non manglés, donc toujours utilisables pour des fuites d'adresses. Ce changement pousse les attaquants à explorer ces bins pour des informations exploitables, bien que certaines techniques puissent encore permettre de démangler les pointeurs avant une fuite, bien que sous contraintes.

### **Démangling des Pointeurs avec une Fuite de Heap**

> [!CAUTION]
> Pour une meilleure explication du processus [**vérifiez le post original ici**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Aperçu de l'Algorithme

La formule utilisée pour le mangling et le démangling des pointeurs est :

**`New_Ptr = (L >> 12) XOR P`**

Où **L** est la localisation de stockage et **P** est le pointeur Fd. Lorsque **L** est décalé vers la droite de 12 bits, il expose les bits les plus significatifs de **P**, en raison de la nature de **XOR**, qui produit 0 lorsque les bits sont XORés avec eux-mêmes.

**Étapes Clés de l'Algorithme :**

1. **Fuite Initiale des Bits les Plus Significatifs** : En XORant le **L** décalé avec **P**, vous obtenez effectivement les 12 bits supérieurs de **P** car la portion décalée de **L** sera zéro, laissant les bits correspondants de **P** inchangés.
2. **Récupération des Bits de Pointeur** : Puisque XOR est réversible, connaître le résultat et l'un des opérandes vous permet de calculer l'autre opérande. Cette propriété est utilisée pour déduire l'ensemble des bits pour **P** en XORant successivement des ensembles de bits connus avec des parties du pointeur manglé.
3. **Démangling Itératif** : Le processus est répété, chaque fois en utilisant les nouveaux bits découverts de **P** de l'étape précédente pour décoder le segment suivant du pointeur manglé, jusqu'à ce que tous les bits soient récupérés.
4. **Gestion des Bits Déterministes** : Les 12 derniers bits de **L** sont perdus en raison du décalage, mais ils sont déterministes et peuvent être reconstruits après le processus.

Vous pouvez trouver une implémentation de cet algorithme ici : [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Protection de Pointeur

La protection de pointeur est une technique d'atténuation des exploits utilisée dans glibc pour protéger les pointeurs de fonction stockés, en particulier ceux enregistrés par des appels de bibliothèque tels que `atexit()`. Cette protection implique de brouiller les pointeurs en les XORant avec un secret stocké dans les données du thread (`fs:0x30`) et en appliquant une rotation binaire. Ce mécanisme vise à empêcher les attaquants de détourner le flux de contrôle en écrasant les pointeurs de fonction.

### **Contournement de la Protection de Pointeur avec une fuite**

1. **Compréhension des Opérations de Protection de Pointeur :** Le brouillage (mangling) des pointeurs est effectué à l'aide de la macro `PTR_MANGLE` qui XOR le pointeur avec un secret de 64 bits et effectue ensuite une rotation à gauche de 0x11 bits. L'opération inverse pour récupérer le pointeur original est gérée par `PTR_DEMANGLE`.
2. **Stratégie d'Attaque :** L'attaque est basée sur une approche de texte clair connu, où l'attaquant doit connaître à la fois les versions originales et manglées d'un pointeur pour déduire le secret utilisé pour le mangling.
3. **Exploitation des Textes Clairs Connus :**
- **Identification des Pointeurs de Fonction Fixes :** En examinant le code source de glibc ou les tables de pointeurs de fonction initialisées (comme `__libc_pthread_functions`), un attaquant peut trouver des pointeurs de fonction prévisibles.
- **Calcul du Secret :** En utilisant un pointeur de fonction connu tel que `__pthread_attr_destroy` et sa version manglée à partir de la table de pointeurs de fonction, le secret peut être calculé en effectuant une rotation inverse (rotation à droite) du pointeur manglé, puis en le XORant avec l'adresse de la fonction.
4. **Textes Clairs Alternatifs :** L'attaquant peut également expérimenter avec le mangling de pointeurs avec des valeurs connues comme 0 ou -1 pour voir si cela produit des motifs identifiables en mémoire, révélant potentiellement le secret lorsque ces motifs sont trouvés dans des dumps mémoire.
5. **Application Pratique :** Après avoir calculé le secret, un attaquant peut manipuler les pointeurs de manière contrôlée, contournant essentiellement la protection de la Protection de Pointeur dans une application multithreadée avec connaissance de l'adresse de base de libc et la capacité de lire des emplacements mémoire arbitraires.

## Références

- [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
- [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)

{{#include ../../banners/hacktricks-training.md}}
