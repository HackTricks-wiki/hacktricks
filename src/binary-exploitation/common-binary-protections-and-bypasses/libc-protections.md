# Ulinzi za Libc

{{#include ../../banners/hacktricks-training.md}}

## Utekelezaji wa Ulinganifu wa Vipande

**Malloc** inatoa nafasi ya kumbukumbu kwa vikundi vya **8-byte (32-bit) au 16-byte (64-bit)**. Hii ina maana mwisho wa vipande katika mifumo ya 32-bit unapaswa kulingana na **0x8**, na katika mifumo ya 64-bit na **0x0**. Kipengele cha usalama hukagua kwamba kila chunk **inalingana kwa usahihi** katika maeneo haya maalum kabla ya kutumia pointer kutoka kwa bin.

### Manufaa ya Usalama

Utekelezaji wa ulinganifu wa vipande katika mifumo ya 64-bit unaimarisha kwa kiasi kikubwa usalama wa Malloc kwa **kuweka mipaka ya kuweka fake chunks hadi 1 tu kati ya anwani 16**. Hii inafanya mashambulizi kuwa magumu zaidi, hasa katika nyaya ambapo mtumiaji ana udhibiti mdogo juu ya thamani za input, na hivyo kufanya mashambulizi kuwa tata na magumu kutekeleza kwa mafanikio.

- **Fastbin Attack on `__malloc_hook`**

Sheria mpya za ulinganifu katika Malloc pia zinazuia shambulizi la kale linalohusisha `__malloc_hook`. Hapo awali, wadukuzi waliweza kubadilisha ukubwa wa chunks ili **kuandika juu ya function pointer hii** na kupata **code execution**. Sasa, sharti kali la ulinganifu linahakikisha kwamba udanganyifu huo hauwezi kutumika tena, likifunga njia ya kawaida ya exploitation na kuongeza usalama kwa ujumla.

> **Kumbuka:** Tangu glibc **2.34** legacy hooks (`__malloc_hook`, `__free_hook`, nk.) zimetolewa kutoka kwenye exported ABI. Modern exploits sasa zinawalenga pointers nyingine za kazi zinazoweza kuandikwa (mfano tcache per-thread struct, vtable-style callbacks) au hutegemea `setcontext`, `_IO_list_all` primitives, nk.

## Pointer Mangling on fastbins and tcache

**Pointer Mangling** ni uboreshaji wa usalama unaotumika kulinda **fastbin na tcache Fd pointers** katika operesheni za usimamizi wa kumbukumbu. Mbinu hii husaidia kuzuia aina fulani za mbinu za exploitation za kumbukumbu, hasa zile ambazo hazihitaji taarifa za leaked memory au ambazo zinabadili maeneo ya kumbukumbu moja kwa moja kulingana na nafasi zinazojulikana (relative **overwrites**).

Kiini cha mbinu hii ni fomula ya obfuscation:

**`New_Ptr = (L >> 12) XOR P`**

- **L** ni **Eneo la Uhifadhi (Storage Location)** la pointer.
- **P** ni halisi **fastbin/tcache Fd Pointer**.

Sababu ya kushoto kwa bitwise shift ya eneo la uhifadhi (L) kwa bits 12 kabla ya operesheni ya XOR ni muhimu. Ubadilishaji huu unashughulikia udhaifu uliokuwepo katika muundo wa deterministic wa bits 12 za chini kabisa za anwani za kumbukumbu, ambazo kwa kawaida zinaweza kutabirika kutokana na vizingiti vya usanifu wa mfumo. Kwa kusogeza bits hizo, sehemu inayotabirika inaondolewa kutoka katika hesabu, ikiongeza randomness ya pointer mpya iliyomanguliwa na hivyo kuimarisha ulinzi dhidi ya exploits zinazoegemea utabiri wa bits hizi.

Pointer iliyomanguliwa inatumia randomness iliyopo ya Address Space Layout Randomization (ASLR), ambayo inabadilisha anwani zinazotumika na programu ili kufanya iwe vigumu kwa wadukuzi kutabiri muundo wa kumbukumbu wa mchakato.

Demangling ya pointer ili kupata anwani ya awali inajumuisha kutumia operesheni ile ile ya XOR. Hapa, pointer iliyomanguliwa inachukuliwa kama P katika fomula, na inapofanywa XOR na eneo la uhifadhi (L) lisilobadilika inarudisha pointer ya awali. Ulinganifu huu katika mangling na demangling unahakikisha mfumo unaweza kusimba na kufumbua pointers kwa ufanisi bila mzigo mkubwa wa kiutendaji, wakati pia ukiongezea kwa kiasi kikubwa usalama dhidi ya mashambulizi yanayobadilisha pointers za kumbukumbu.

### Manufaa ya Usalama

Pointer mangling inalenga **kuzuia partial na full pointer overwrites katika usimamizi wa heap**, kuboresha kwa kiasi kikubwa usalama. Kipengele hiki kinaathiri mbinu za exploitation kwa njia kadhaa:

1. **Prevention of Bye Byte Relative Overwrites**: Hapo awali, wadukuzi wangeweza kubadilisha sehemu ya pointer ili **kupeleka heap chunks kwa maeneo tofauti bila kujua anwani kamili**, mbinu iliyojulikana katika leakless **House of Roman** exploit. Kwa pointer mangling, overwritten za aina hiyo **bila heap leak sasa zinahitaji brute forcing**, kupunguza sana nafasi yao ya kufanikiwa.
2. **Increased Difficulty of Tcache Bin/Fastbin Attacks**: Mashambulizi ya kawaida yanayobarizi function pointers (kama `__malloc_hook`) kwa kuathiri fastbin au tcache entries yanazoroteshwa. Kwa mfano, shambulizi linaweza kujumuisha ku-leak anwani ya LibC, ku-release chunk katika tcache bin, kisha kuandika juu ya Fd pointer ili kuielekeza kwenye `__malloc_hook` kwa arbitrary code execution. Kwa pointer mangling, pointers hizi lazima ziwe correctly mangled, **zikihitaji heap leak kwa uandishi sahihi**, hivyo kuongeza kizingiti cha exploitation.
3. **Requirement for Heap Leaks in Non-Heap Locations**: Kuunda fake chunk katika maeneo yasiyo-heap (kama stack, .bss section, au PLT/GOT) sasa pia **kunahitaji heap leak** kutokana na lazima kwa pointer mangling. Hii inaongeza ugumu wa kushambulia maeneo haya, sawa na kanuni ya kuathiri anwani za LibC.
4. **Leaking Heap Addresses Becomes More Challenging**: Pointer mangling inapunguza matumizi ya Fd pointers katika fastbin na tcache bins kama vyanzo vya heap address leaks. Hata hivyo, pointers katika unsorted, small, na large bins hubaki bila mangle, hivyo bado zinatumika kwa ku-leak anwani. Mabadiliko haya yanazua wadukuzi kuchunguza bins hizi kwa taarifa za kuweza kutumiwa, ingawa mbinu fulani bado zinaweza kuruhusu demangling ya pointers kabla ya leak, ila kwa vizingiti vinavyowekwa.

### **Safe-Linking Bypass (page-aligned leak scenario)**
```c
// leaked_fd is the mangled Fd read from the chunk on the same page
uintptr_t l = (uintptr_t)&chunk->fd;           // storage location
uintptr_t original = (leaked_fd ^ (l >> 12));  // demangle
```
Hii inarejesha Fd na kuruhusu classic tcache/fastbin poisoning. Ikiwa chunks ziko kwenye pages tofauti, brute-forcing ofseti ya ukurasa wa 12-bit (uwezekano 0x1000) mara nyingi inawezekana wakati patterns za allocation ni deterministic au wakati crashes zinakubalika (mf., CTF-style exploits).

### **Kurejesha pointers kwa kutumia Heap Leak**

> [!CAUTION]
> Kwa ufafanuzi bora wa mchakato [**angalia chapisho la asili hapa**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Muhtasari wa Algorithmu

The formula used for mangling and demangling pointers is:

**`New_Ptr = (L >> 12) XOR P`**

Where **L** is the storage location and **P** is the Fd pointer. When **L** is shifted right by 12 bits, it exposes the most significant bits of **P**, due to the nature of **XOR**, which outputs 0 when bits are XORed with themselves.

Hatua Muhimu katika Algorithmu:

1. Initial Leak ya bits muhimu zaidi: Kwa XORing the shifted **L** na **P**, unapata kwa ufanisi top 12 bits za **P** kwa sababu sehemu iliyosogezwa ya **L** itakuwa zero, ikiacha bits zinazolingana za **P** zikibaki bila kubadilika.
2. Urejeshaji wa Bits za Pointer: Kwa kuwa XOR ni reversible, kujua matokeo na mmoja wa operands kunakuwezesha kuhesabu operand mwingine. Sifa hii inatumiwa kukisia seti nzima ya bits za **P** kwa successive XORing ya seti za bits zinazojulikana na sehemu za pointer iliyo mangled.
3. Demangling kwa mfululizo: Mchakato unarudiwa, kila mara ukitumia bits mpya za **P** zilizopatikana kutoka hatua ya awali decode sehemu inayofuata ya pointer iliyo mangled, hadi bits zote zirudishwe.
4. Kushughulikia bits za deterministic: Bits za mwisho 12 za **L** hupotea kutokana na shift, lakini ni deterministic na zinaweza kujenguliwa tena baada ya mchakato.

Unaweza kupata utekelezaji wa algorithmu hii hapa: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer Guard ni mbinu ya kupunguza exploit inayotumika katika glibc kulinda stored function pointers, hasa zile zilizoorodheshwa na library calls kama `atexit()`. Ulinzi huu unahusisha kuchanganya pointers kwa kuzi-XOR na siri iliyohifadhiwa katika thread data (`fs:0x30`) na kisha kutumia rotation ya bitwise. Utaratibu huu unalenga kuzuia wadukuzi kutoka kuiba control flow kwa kuandika juu function pointers.

### **Kuvuka Pointer Guard kwa kutumia leak**

1. Kuelewa Operesheni za Pointer Guard: Kuchanganya (mangling) kwa pointers hufanywa kwa kutumia macro `PTR_MANGLE` ambayo ina-XOR pointer na siri ya 64-bit kisha kufanya left rotation ya 0x11 bits. Operesheni ya kuirejesha pointer asilia inafanywa na `PTR_DEMANGLE`.
2. Mkakati wa Attack: Shambulio linategemea approche ya known-plaintext, ambapo mshambuliaji anahitaji kujua toleo la asili na toleo lililomangled la pointer ili kubaini siri iliyotumika kwa mangling.
3. Kutumia Known Plaintexts:
- Kutambua Fixed Function Pointers: Kwa kuchunguza source code ya glibc au jedwali za function pointer zilizowekwa (kama `__libc_pthread_functions`), mshambuliaji anaweza kupata function pointers zinazotabirika.
- Kuhesabu Siri: Kwa kutumia function pointer inayojulikana kama `__pthread_attr_destroy` na toleo lake lililomangled kutoka kwenye jedwali la function pointers, siri inaweza kuhesabiwa kwa ku-rotate nyuma (right rotation) pointer iliyo mangled na kisha ku-XOR na anwani ya function.
4. Plaintexts Mbadala: Mshambuliaji pia anaweza kujaribu kuchanga pointers zikiwa na thamani zinazojulikana kama 0 au -1 kuona ikiwa hizi zinatoa mifumo inayotambulika katika memory, pengine kufichua siri wakati mifumo hiyo inapatikana katika dumps za memory.
5. Matumizi ya Kivitendo: Baada ya kuhesabu siri, mshambuliaji anaweza kudhibiti pointers kwa njia iliyoratibiwa, kwa msingi huo kuvuka ulinzi wa Pointer Guard katika programu yenye multithreading kwa kujua libc base address na uwezo wa kusoma maeneo yoyote ya memory.

## GLIBC Tunables & Recent Loader Bugs

The dynamic loader parses `GLIBC_TUNABLES` before program startup. Mis-parsing bugs here directly affect **libc** before most mitigations kick in. The 2023 "Looney Tunables" bug (CVE-2023-4911) is an example: an overlong `GLIBC_TUNABLES` value overflows internal buffers in `ld.so`, enabling **privilege escalation** on many distros when combined with SUID binaries. Exploitation requires only crafting the environment and repeatedly invoking the target binary; pointer guard or safe-linking do not prevent it because corruption happens in the loader prior to heap setup.

## Marejeo

- [Safe-Linking bypass explanation (shellphish/how2heap)](https://deepwiki.com/shellphish/how2heap/5.2-safe-linking-bypass)
- [Looney Tunables (CVE-2023-4911) write-up](https://www.wiz.io/vulnerability-database/cve/cve-2023-4911)

{{#include ../../banners/hacktricks-training.md}}
