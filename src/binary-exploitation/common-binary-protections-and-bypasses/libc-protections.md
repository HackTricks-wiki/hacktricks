# Libc zaštite

{{#include ../../banners/hacktricks-training.md}}

## Sprovođenje poravnanja delova

**Malloc** alocira memoriju u **8-bajtnih (32-bitnih) ili 16-bajtnih (64-bitnih) grupama**. To znači da se kraj delova u 32-bitnim sistemima treba poravnati sa **0x8**, a u 64-bitnim sistemima sa **0x0**. Bezbednosna funkcija proverava da li se svaki deo **ispravno poravnava** na ovim specifičnim mestima pre nego što se koristi pokazivač iz kontejnera.

### Bezbednosne prednosti

Sprovođenje poravnanja delova u 64-bitnim sistemima značajno poboljšava bezbednost Malloc-a tako što **ograničava postavljanje lažnih delova na samo 1 od svake 16 adresa**. To otežava napade, posebno u scenarijima gde korisnik ima ograničenu kontrolu nad ulaznim vrednostima, čineći napade složenijim i težim za uspešnu realizaciju.

- **Fastbin napad na \_\_malloc_hook**

Nova pravila poravnanja u Malloc-u takođe sprečavaju klasičan napad koji uključuje `__malloc_hook`. Prethodno su napadači mogli manipulisati veličinama delova da **prepišu ovu funkciju pokazivača** i dobiju **izvršenje koda**. Sada, strogi zahtevi za poravnanjem osiguravaju da takve manipulacije više nisu moguće, zatvarajući uobičajenu rutu eksploatacije i poboljšavajući ukupnu bezbednost.

## Manipulacija pokazivačima na fastbins i tcache

**Manipulacija pokazivačima** je bezbednosno poboljšanje koje se koristi za zaštitu **fastbin i tcache Fd pokazivača** u operacijama upravljanja memorijom. Ova tehnika pomaže u sprečavanju određenih vrsta taktika eksploatacije memorije, posebno onih koje ne zahtevaju informacije o propuštenoj memoriji ili koje direktno manipulišu memorijskim lokacijama u odnosu na poznate pozicije (relativni **prepisivanja**).

Osnova ove tehnike je formula obfuscacije:

**`New_Ptr = (L >> 12) XOR P`**

- **L** je **lokacija skladištenja** pokazivača.
- **P** je stvarni **fastbin/tcache Fd pokazivač**.

Razlog za pomeranje lokacije skladištenja (L) za 12 bita udesno pre XOR operacije je ključan. Ova manipulacija se bavi ranjivošću inherentnom determinističkoj prirodi najmanje značajnih 12 bita memorijskih adresa, koje su obično predvidljive zbog ograničenja arhitekture sistema. Pomeraanjem bitova, predvidljivi deo se izbacuje iz jednačine, povećavajući nasumičnost novog, izmenjenog pokazivača i time štiteći od eksploatacija koje se oslanjaju na predvidljivost ovih bitova.

Ovaj izmenjeni pokazivač koristi postojeću nasumičnost koju pruža **Randomizacija rasporeda adresnog prostora (ASLR)**, koja randomizuje adrese koje koriste programi kako bi otežala napadačima da predviđaju raspored memorije procesa.

**Demangling** pokazivača za vraćanje originalne adrese uključuje korišćenje iste XOR operacije. Ovde se izmenjeni pokazivač tretira kao P u formuli, a kada se XOR-uje sa nepromenjenom lokacijom skladištenja (L), rezultira otkrivanjem originalnog pokazivača. Ova simetrija u manipulaciji i demanipulaciji osigurava da sistem može efikasno kodirati i dekodirati pokazivače bez značajnog preopterećenja, dok značajno povećava bezbednost protiv napada koji manipulišu pokazivačima memorije.

### Bezbednosne prednosti

Manipulacija pokazivačima ima za cilj da **spreči delimična i potpuna prepisivanja pokazivača u heap-u**, što je značajno poboljšanje u bezbednosti. Ova funkcija utiče na tehnike eksploatacije na nekoliko načina:

1. **Sprečavanje relativnih prepisivanja po bajtovima**: Prethodno su napadači mogli promeniti deo pokazivača da **preusmere delove heap-a na različite lokacije bez poznavanja tačnih adresa**, tehnika koja je očigledna u eksploataciji bez propuštanja **House of Roman**. Sa manipulacijom pokazivačima, takva relativna prepisivanja **bez propuštanja heap-a sada zahtevaju brute forcing**, drastično smanjujući verovatnoću uspeha.
2. **Povećana težina napada na Tcache Bin/Fastbin**: Uobičajeni napadi koji prepisuju funkcijske pokazivače (poput `__malloc_hook`) manipulacijom fastbin ili tcache unosa su otežani. Na primer, napad može uključivati propuštanje LibC adrese, oslobađanje dela u tcache bin, a zatim prepisivanje Fd pokazivača da ga preusmeri na `__malloc_hook` za proizvoljno izvršenje koda. Sa manipulacijom pokazivačima, ovi pokazivači moraju biti ispravno izmenjeni, **što zahteva propuštanje heap-a za tačnu manipulaciju**, čime se povećava barijera za eksploataciju.
3. **Zahtev za propuštanjem heap-a u ne-heap lokacijama**: Kreiranje lažnog dela u ne-heap oblastima (poput steka, .bss sekcije ili PLT/GOT) sada takođe **zahteva propuštanje heap-a** zbog potrebe za manipulacijom pokazivačima. Ovo povećava složenost eksploatacije ovih oblasti, slično zahtevu za manipulaciju LibC adresama.
4. **Propuštanje adresa heap-a postaje teže**: Manipulacija pokazivačima ograničava korisnost Fd pokazivača u fastbin i tcache binovima kao izvora za propuštanje adresa heap-a. Međutim, pokazivači u nesortiranim, malim i velikim binovima ostaju neizmenjeni, pa su i dalje upotrebljivi za propuštanje adresa. Ova promena podstiče napadače da istražuju ove binove za eksploatabilne informacije, iako neke tehnike mogu i dalje omogućiti demanipulaciju pokazivača pre propuštanja, iako sa ograničenjima.

### **Demanipulacija pokazivača sa propuštanjem heap-a**

> [!CAUTION]
> Za bolje objašnjenje procesa [**proverite originalni post ovde**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Pregled algoritma

Formula koja se koristi za manipulaciju i demanipulaciju pokazivača je:&#x20;

**`New_Ptr = (L >> 12) XOR P`**

Gde je **L** lokacija skladištenja, a **P** Fd pokazivač. Kada se **L** pomeri udesno za 12 bita, otkriva najznačajnije bitove **P**, zbog prirode **XOR**, koja daje 0 kada se bitovi XOR-uju sami sa sobom.

**Ključni koraci u algoritmu:**

1. **Početno propuštanje najznačajnijih bitova**: XOR-ovanjem pomerene **L** sa **P**, efikasno dobijate gornjih 12 bitova **P** jer će pomerena deo **L** biti nula, ostavljajući odgovarajuće bitove **P** nepromenjenim.
2. **Obnova bitova pokazivača**: Pošto je XOR reverzibilan, poznavanje rezultata i jednog od operanada omogućava vam da izračunate drugi operand. Ova osobina se koristi za dedukciju celog skupa bitova za **P** sukcesivnim XOR-ovanjem poznatih skupova bitova sa delovima izmenjenog pokazivača.
3. **Iterativna demanipulacija**: Proces se ponavlja, svaki put koristeći novo otkrivene bitove **P** iz prethodnog koraka za dekodiranje sledećeg segmenta izmenjenog pokazivača, sve dok se svi bitovi ne obnove.
4. **Rukovanje determinističkim bitovima**: Poslednjih 12 bitova **L** se gubi zbog pomeranja, ali su deterministički i mogu se rekonstruisati nakon procesa.

Možete pronaći implementaciju ovog algoritma ovde: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Zaštita pokazivača

Zaštita pokazivača je tehnika mitigacije eksploatacije koja se koristi u glibc-u za zaštitu skladištenih funkcijskih pokazivača, posebno onih registrovanih pozivima biblioteka kao što je `atexit()`. Ova zaštita uključuje mešanje pokazivača XOR-ovanjem sa tajnom koja se čuva u podacima niti (`fs:0x30`) i primenom bitovne rotacije. Ovaj mehanizam ima za cilj da spreči napadače da preuzmu kontrolu nad tokom izvršenja prepisivanjem funkcijskih pokazivača.

### **Obilaženje zaštite pokazivača sa propuštanjem**

1. **Razumevanje operacija zaštite pokazivača:** Mešanje (manipulacija) pokazivača se vrši korišćenjem makroa `PTR_MANGLE` koji XOR-uje pokazivač sa 64-bitnom tajnom i zatim vrši levo pomeranje od 0x11 bitova. Obrnuta operacija za vraćanje originalnog pokazivača se obavlja pomoću `PTR_DEMANGLE`.
2. **Strategija napada:** Napad se zasniva na pristupu poznatom plain textu, gde napadač treba da zna i originalne i izmenjene verzije pokazivača da bi dedukovao tajnu korišćenu za mešanje.
3. **Eksploatacija poznatih plain textova:**
- **Identifikacija fiksnih funkcijskih pokazivača:** Istražujući izvorni kod glibc-a ili inicijalizovane tabele funkcijskih pokazivača (poput `__libc_pthread_functions`), napadač može pronaći predvidljive funkcijske pokazivače.
- **Izračunavanje tajne:** Koristeći poznati funkcijski pokazivač kao što je `__pthread_attr_destroy` i njegovu izmenjenu verziju iz tabele funkcijskih pokazivača, tajna se može izračunati obrnuto rotirajući (desno rotiranje) izmenjeni pokazivač i zatim XOR-ujući ga sa adresom funkcije.
4. **Alternativni plain textovi:** Napadač može takođe eksperimentisati sa mešanjem pokazivača sa poznatim vrednostima kao što su 0 ili -1 da vidi da li ove proizvode prepoznatljive obrasce u memoriji, potencijalno otkrivajući tajnu kada se ovi obrasci pronađu u dump-ovima memorije.
5. **Praktična primena:** Nakon izračunavanja tajne, napadač može manipulirati pokazivačima na kontrolisan način, suštinski obilažeći zaštitu pokazivača u višedretvenoj aplikaciji sa znanjem o osnovnoj adresi libc-a i sposobnošću čitanja proizvoljnih memorijskih lokacija.

## Reference

- [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
- [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)

{{#include ../../banners/hacktricks-training.md}}
