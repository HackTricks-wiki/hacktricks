# Libc Protections

{{#include ../../banners/hacktricks-training.md}}

## Chunk Alignment Enforcement

**Malloc** allocates memory in **8-byte (32-bit) or 16-byte (64-bit) groupings**. Hii inamaanisha kwamba mwisho wa chunks katika mifumo ya 32-bit unapaswa kulingana na **0x8**, na katika mifumo ya 64-bit na **0x0**. Kipengele cha usalama huthibitisha kwamba kila chunk **inalingana kwa usahihi** katika maeneo haya maalum kabla ya kutumia pointer kutoka kwa bin.

### Security Benefits

Utekaji wa kanuni za alignment katika mifumo ya 64-bit unaimarisha usalama wa Malloc kwa kiasi kikubwa kwa **kupuuzia uwezekano wa kuweka fake chunks katika anwani 1 tu kati ya 16**. Hii inafanya unyonyaji (exploitation) kuwa mgumu zaidi, hasa katika hali ambapo mtumiaji ana udhibiti mdogo wa thamani za input, na kufanya mashambulizi kuwa ngumu na magumu kuyafanikiwa.

- **Fastbin Attack on `__malloc_hook`**

Kanuni mpya za alignment katika Malloc pia zinazuia shambulio la kizamani linalohusiana na `__malloc_hook`. Hapo awali, washambuliaji wangeweza kubadili ukubwa wa chunks ili **kuandika juu ya function pointer hii** na kupata **code execution**. Sasa, sharti kali la alignment linahakikisha kwamba mabadiliko kama hayo hayawezi kutumika tena, kukanusha njia ya kawaida ya exploitation na kuboresha usalama kwa ujumla.

> **Kumbuka:** Tangu glibc **2.34** legacy hooks (`__malloc_hook`, `__free_hook`, etc.) zimetolewa kutoka kwenye exported ABI. Modern exploits sasa hulenga function pointers nyingine zinazoandika (mfano tcache per-thread struct, vtable-style callbacks) au hutegemea `setcontext`, `_IO_list_all` primitives, n.k.

## Pointer Mangling on fastbins and tcache

Pointer Mangling ni enhancement ya usalama inayotumika kulinda fastbin na tcache Fd pointers katika operesheni za memory management. Teknik hii husaidia kuzuia aina fulani za tactics za memory exploit, hasa zile ambazo hazihitaji leaked memory information au zinazobadilisha maeneo ya memory moja kwa moja kwa kuhusiana na positions zinazojulikana (relative **overwrites**).

The core of this technique is an obfuscation formula:

**`New_Ptr = (L >> 12) XOR P`**

- **L** is the **Storage Location** of the pointer.
- **P** is the actual **fastbin/tcache Fd Pointer**.

Sababu ya kusogeza (shift) storage location (L) kwa bits 12 kushoto kabla ya kufanya XOR ni muhimu. Uendeshaji huu unashughulikia udhaifu uliokuwepo kwa tabia ya deterministic ya least significant 12 bits za anwani za memory, ambazo kwa kawaida zinaweza kutabirika kutokana na vizingiti vya architecture ya mfumo. Kwa kusogeza bits hizi, sehemu inayotabirika inaondolewa kwenye hesabu, ikiongeza nasibu ya pointer mpya iliyomanguliwa na hivyo kulinda dhidi ya exploits zinazotegemea utabirika wa bits hizo.

Pointer iliyomanguliwa inatumia randomness iliyopo inayotolewa na Address Space Layout Randomization (ASLR), ambayo inarandamiza anwani zinazotumika na programu ili kuifanya iwe ngumu kwa washambuliaji kutabiri layout ya memory ya process.

Demangling ya pointer ili kupata anwani ya awali inahusisha kutumia operesheni ile ile ya XOR. Hapa, pointer iliyomanguliwa inachukuliwa kama P katika formula, na wakati inapo-XOR-ishwa na storage location (L) isiyobadilika, inapelekea pointer ya awali kufunuliwa. Ulinganifu huu katika mangling na demangling unahakikisha kwamba mfumo unaweza encode na decode pointers kwa ufanisi bila overhead kubwa, huku ukiongeza kwa kiasi kikubwa usalama dhidi ya mashambulizi yanayobadilisha pointers za memory.

### Security Benefits

Pointer mangling inalenga **kuzuia partial na full pointer overwrites katika heap**, ni kuboresha kubwa ya usalama. Kipengele hiki kinaathiri tekniki za exploitation kwa njia kadhaa:

1. **Kuzuia Bye Byte Relative Overwrites**: Hapo awali, washambuliaji wangeweza kubadilisha sehemu ya pointer ili **kupeleka chunks za heap kwenye maeneo tofauti bila kujua anwani za kweli**, tekniki inayoonekana katika leakless House of Roman exploit. Kwa pointer mangling, relative overwrites kama hizo bila heap leak sasa zinahitaji brute forcing, kupunguza kwa kiasi kikubwa uwezekano wa mafanikio.
2. **Kuongeza Ugumu wa Tcache Bin/Fastbin Attacks**: Shambulio za kawaida zinazowandika juu ya function pointers (kama `__malloc_hook`) kwa kuingilia fastbin au tcache entries zinaingiliwa. Kwa mfano, shambulio linaweza kuhusisha leaking LibC address, ku-release chunk kwenye tcache bin, na kisha kuandika juu ya Fd pointer ili kuielekeza kwenye `__malloc_hook` kwa ajili ya arbitrary code execution. Kwa pointer mangling, pointers hizi zinapaswa kuwa mangled kwa usahihi, ziitashauri heap leak ili kufanya manipulation kwa usahihi, hivyo kuinua kizuizi cha exploitation.
3. **Mahitaji ya Heap Leaks katika Maeneo Yasiyo ya Heap**: Kuunda fake chunk katika maeneo yasiyo ya heap (kama stack, .bss section, au PLT/GOT) sasa pia kunahitaji heap leak kutokana na haja ya pointer mangling. Hii inaongeza ugumu wa ku-exploit maeneo haya, sawa na nafasi ilivyo kwa kuingilia LibC addresses.
4. **Leaking Heap Addresses Inakuwa Ngumu Zaidi**: Pointer mangling inapunguza ufanisi wa Fd pointers katika fastbin na tcache bins kama vyanzo vya heap address leaks. Hata hivyo, pointers katika unsorted, small, na large bins hubaki zisizomanguliwa, hivyo bado zinatumika kwa leaking addresses. Mabadiliko haya yanasukuma washambuliaji kuchunguza bins hizi kwa taarifa zinazoweza kutumika, ingawa baadhi ya techniques bado zinaweza kuruhusu demangling ya pointers kabla ya leak, lakini kwa vizingiti.

### **Safe-Linking Bypass (page-aligned leak scenario)**

Hata kwa safe-linking ikiwa imewezeshwa (glibc â‰¥ 2.32), ikiwa unaweza leak pointer iliyomanguliwa na chunk iliyoharibika na victim chunk zote mbili zinashare ukurasa sawa wa 4KB, pointer ya awali inaweza kupongezwa kwa kutumia tu page offset:
```c
// leaked_fd is the mangled Fd read from the chunk on the same page
uintptr_t l = (uintptr_t)&chunk->fd;           // storage location
uintptr_t original = (leaked_fd ^ (l >> 12));  // demangle
```
This restores the Fd and permits classic tcache/fastbin poisoning. If the chunks sit on different pages, brute-forcing the 12-bit page offset (0x1000 possibilities) is often feasible when allocation patterns are deterministic or when crashes are acceptable (e.g., CTF-style exploits).

### **Kurejesha pointer zilizomanganywa kwa Heap Leak**

> [!CAUTION]
> Kwa ufafanuzi bora wa mchakato [**check the original post from here**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Algorithm Overview

The formula used for mangling and demangling pointers is:

**`New_Ptr = (L >> 12) XOR P`**

Where **L** is the storage location and **P** is the Fd pointer. When **L** is shifted right by 12 bits, it exposes the most significant bits of **P**, due to the nature of **XOR**, which outputs 0 when bits are XORed with themselves.

**Key Steps in the Algorithm:**

1. **Initial Leak of the Most Significant Bits:** Kwa kufanya XOR ya L iliyosogezwa na P, unapata kwa ufanisi bits 12 za juu za P kwa sababu sehemu iliyosogezwa ya L itakuwa sifuri, ikiacha bits zinazolingana za P zisibadilike.
2. **Recovery of Pointer Bits:** Urejesho wa bits za pointer: Kwa kuwa XOR ni reversible, kujua matokeo na mmoja wa waendeshaji kunakuwezesha kuhesabu waendeshaji mwingine. Mali hii inatumiwa kukisia seti nzima ya bits za P kwa kufanya XOR kwa mfululizo kwa seti za bits zinazojulikana na sehemu za pointer iliyomanganywa.
3. **Iterative Demangling:** Mchakato unaarudiwa, kila mara ukitumia bits mpya za P zilizogunduliwa katika hatua iliyopita ili kufichua sehemu inayofuata ya pointer iliyomanganywa, hadi bits zote zirejeshwe.
4. **Handling Deterministic Bits:** Bits 12 za mwisho za L hupotea kutokana na shift, lakini ni deterministic na zinaweza kujengwa upya baada ya mchakato.

Unaweza kupata utekelezaji wa algorithm hii hapa: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer guard ni mbinu ya kuzuia exploit inayotumika katika glibc kulinda stored function pointers, hasa zile zilizosajiliwa na simu za library kama `atexit()`. Ulinzi huu unahusisha kuchanganya pointers kwa kufanya XOR nao na siri iliyohifadhiwa katika thread data (`fs:0x30`) na kisha kutekeleza rotation ya bitwise. Utaratibu huu unalenga kuzuia mshambuliaji kuchukua control flow kwa kuandika juu function pointers.

### **Bypassing Pointer Guard with a leak**

1. **Understanding Pointer Guard Operations:** Kuchanganya (mangling) pointers kunafanywa kwa kutumia macro `PTR_MANGLE` ambayo inafanya XOR ya pointer na siri ya 64-bit kisha inafanya left rotation ya 0x11 bits. Operesheni ya kinyume ya kupata pointer ya asili inasimamiwa na `PTR_DEMANGLE`.
2. **Attack Strategy:** Shambulio linategemea mbinu ya known-plaintext, ambapo mshambuliaji anahitaji kujua toleo la asili na toleo lililomanganywa la pointer ili kukisia siri iliyotumika kwa mangling.
3. **Exploiting Known Plaintexts:**
- **Identifying Fixed Function Pointers:** Kwa kuchunguza msimbo wa glibc au jedwali za initialized function pointers (kama `__libc_pthread_functions`), mshambuliaji anaweza kupata function pointers zinazotabirika.
- **Computing the Secret:** Kutumia function pointer inayojulikana kama `__pthread_attr_destroy` na toleo lake lililomanganywa kutoka kwenye jedwali la function pointers, siri inaweza kuhesabiwa kwa kufanya reverse rotating (right rotation) ya pointer iliyomanganywa kisha kufanya XOR nayo na anwani ya function.
4. **Alternative Plaintexts:** Mshambuliaji anaweza pia kujaribu mangling pointers na thamani zinazojulikana kama 0 au -1 ili kuona kama hizi zinatoa mifumo inayoonekana katika memory, na hivyo kufichua siri pale mifumo hiyo inapopatikana katika memory dumps.
5. **Practical Application:** Baada ya kuhesabu siri, mshambuliaji anaweza kudhibiti pointers kwa njia iliyodhibitiwa, na kwa msingi huo kuvuka ulinzi wa Pointer Guard katika application yenye multithreading akiwa na ujuzi wa libc base address na uwezo wa kusoma maeneo yoyote ya memory.

## GLIBC Tunables & Recent Loader Bugs

The dynamic loader parses `GLIBC_TUNABLES` before program startup. Mis-parsing bugs here directly affect **libc** before most mitigations kick in. The 2023 "Looney Tunables" bug (CVE-2023-4911) is an example: an overlong `GLIBC_TUNABLES` value overflows internal buffers in `ld.so`, enabling **privilege escalation** on many distros when combined with SUID binaries. Exploitation requires only crafting the environment and repeatedly invoking the target binary; pointer guard or safe-linking do not prevent it because corruption happens in the loader prior to heap setup.

## Marejeo

- [Safe-Linking bypass explanation (shellphish/how2heap)](https://deepwiki.com/shellphish/how2heap/5.2-safe-linking-bypass)
- [Looney Tunables (CVE-2023-4911) write-up](https://www.wiz.io/vulnerability-database/cve/cve-2023-4911)

{{#include ../../banners/hacktricks-training.md}}
