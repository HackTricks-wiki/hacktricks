# Libc Protections

{{#include ../../banners/hacktricks-training.md}}

## Chunk Alignment Enforcement

**Malloc** εκχωρεί μνήμη σε **ομαδοποιήσεις 8-byte (32-bit) ή 16-byte (64-bit)**. Αυτό σημαίνει ότι το τέλος των κομματιών σε συστήματα 32-bit θα πρέπει να ευθυγραμμίζεται με **0x8**, και σε συστήματα 64-bit με **0x0**. Η λειτουργία ασφαλείας ελέγχει ότι κάθε κομμάτι **ευθυγραμμίζεται σωστά** σε αυτές τις συγκεκριμένες τοποθεσίες πριν χρησιμοποιήσει έναν δείκτη από ένα bin.

### Security Benefits

Η επιβολή ευθυγράμμισης κομματιών σε συστήματα 64-bit ενισχύει σημαντικά την ασφάλεια του Malloc περιορίζοντας **την τοποθέτηση ψεύτικων κομματιών σε μόνο 1 από κάθε 16 διευθύνσεις**. Αυτό περιπλέκει τις προσπάθειες εκμετάλλευσης, ειδικά σε σενάρια όπου ο χρήστης έχει περιορισμένο έλεγχο στις τιμές εισόδου, καθιστώντας τις επιθέσεις πιο περίπλοκες και δύσκολες στην επιτυχία.

- **Fastbin Attack on \_\_malloc_hook**

Οι νέοι κανόνες ευθυγράμμισης στο Malloc αποτρέπουν επίσης μια κλασική επίθεση που περιλαμβάνει τον `__malloc_hook`. Προηγουμένως, οι επιτιθέμενοι μπορούσαν να χειραγωγήσουν τα μεγέθη των κομματιών για να **επικαλύψουν αυτόν τον δείκτη συνάρτησης** και να αποκτήσουν **εκτέλεση κώδικα**. Τώρα, η αυστηρή απαίτηση ευθυγράμμισης διασφαλίζει ότι τέτοιες χειραγωγήσεις δεν είναι πλέον βιώσιμες, κλείνοντας μια κοινή διαδρομή εκμετάλλευσης και ενισχύοντας τη συνολική ασφάλεια.

## Pointer Mangling on fastbins and tcache

**Pointer Mangling** είναι μια βελτίωση ασφαλείας που χρησιμοποιείται για την προστασία των **fastbin και tcache Fd pointers** σε λειτουργίες διαχείρισης μνήμης. Αυτή η τεχνική βοηθά στην αποτροπή ορισμένων τύπων τακτικών εκμετάλλευσης μνήμης, συγκεκριμένα αυτών που δεν απαιτούν διαρροή πληροφοριών μνήμης ή που χειραγωγούν άμεσα τις τοποθεσίες μνήμης σε σχέση με γνωστές θέσεις (σχετικές **επικαλύψεις**).

Ο πυρήνας αυτής της τεχνικής είναι μια φόρμουλα απόκρυψης:

**`New_Ptr = (L >> 12) XOR P`**

- **L** είναι η **Τοποθεσία Αποθήκευσης** του δείκτη.
- **P** είναι ο πραγματικός **fastbin/tcache Fd Pointer**.

Ο λόγος για τη μετατόπιση των bit της τοποθεσίας αποθήκευσης (L) κατά 12 bit προς τα δεξιά πριν από τη λειτουργία XOR είναι κρίσιμος. Αυτή η χειραγώγηση αντιμετωπίζει μια ευπάθεια που είναι εγγενής στη ντετερμινιστική φύση των 12 λιγότερο σημαντικών bit των διευθύνσεων μνήμης, οι οποίες είναι συνήθως προβλέψιμες λόγω περιορισμών αρχιτεκτονικής συστήματος. Με τη μετατόπιση των bit, το προβλέψιμο τμήμα απομακρύνεται από την εξίσωση, ενισχύοντας την τυχαιότητα του νέου, παραμορφωμένου δείκτη και έτσι προστατεύοντας από εκμεταλλεύσεις που βασίζονται στην προβλεψιμότητα αυτών των bit.

Αυτός ο παραμορφωμένος δείκτης εκμεταλλεύεται την υπάρχουσα τυχαιότητα που παρέχεται από **Address Space Layout Randomization (ASLR)**, η οποία τυχαίνει τις διευθύνσεις που χρησιμοποιούνται από προγράμματα για να δυσκολεύει τους επιτιθέμενους να προβλέψουν τη διάταξη μνήμης μιας διαδικασίας.

**Demangling** του δείκτη για να ανακτηθεί η αρχική διεύθυνση περιλαμβάνει τη χρήση της ίδιας λειτουργίας XOR. Εδώ, ο παραμορφωμένος δείκτης αντιμετωπίζεται ως P στη φόρμουλα, και όταν XORαριστεί με την αμετάβλητη τοποθεσία αποθήκευσης (L), αποκαλύπτεται ο αρχικός δείκτης. Αυτή η συμμετρία στην παραμόρφωση και αποπαραμόρφωση διασφαλίζει ότι το σύστημα μπορεί να κωδικοποιεί και να αποκωδικοποιεί αποτελεσματικά τους δείκτες χωρίς σημαντικό κόστος, ενώ αυξάνει σημαντικά την ασφάλεια κατά των επιθέσεων που χειραγωγούν τους δείκτες μνήμης.

### Security Benefits

Ο παραμορφωμένος δείκτης στοχεύει να **αποτρέψει μερικές και πλήρεις επικαλύψεις δείκτων στη διαχείριση heap**, μια σημαντική βελτίωση στην ασφάλεια. Αυτή η δυνατότητα επηρεάζει τις τεχνικές εκμετάλλευσης με διάφορους τρόπους:

1. **Αποτροπή Σχετικών Επικαλύψεων Byte Byte**: Προηγουμένως, οι επιτιθέμενοι μπορούσαν να αλλάξουν μέρος ενός δείκτη για να **ανακατευθύνουν τα κομμάτια heap σε διαφορετικές τοποθεσίες χωρίς να γνωρίζουν ακριβείς διευθύνσεις**, μια τεχνική που είναι προφανής στην εκμετάλλευση χωρίς διαρροές **House of Roman**. Με τον παραμορφωμένο δείκτη, τέτοιες σχετικές επικαλύψεις **χωρίς διαρροή heap απαιτούν τώρα βίαιη δύναμη**, μειώνοντας δραστικά την πιθανότητα επιτυχίας τους.
2. **Αυξημένη Δυσκολία Επιθέσεων Tcache Bin/Fastbin**: Κοινές επιθέσεις που επικαλύπτουν δείκτες συναρτήσεων (όπως `__malloc_hook`) με τη χειραγώγηση των fastbin ή tcache καταχωρήσεων εμποδίζονται. Για παράδειγμα, μια επίθεση μπορεί να περιλαμβάνει τη διαρροή μιας διεύθυνσης LibC, την απελευθέρωση ενός κομματιού στο bin tcache και στη συνέχεια την επικαλυπτική του δείκτη Fd για να το ανακατευθύνει στο `__malloc_hook` για αυθαίρετη εκτέλεση κώδικα. Με τον παραμορφωμένο δείκτη, αυτοί οι δείκτες πρέπει να είναι σωστά παραμορφωμένοι, **απαιτώντας μια διαρροή heap για ακριβή χειραγώγηση**, αυξάνοντας έτσι το εμπόδιο εκμετάλλευσης.
3. **Απαίτηση Διαρροών Heap σε Μη-Heap Τοποθεσίες**: Η δημιουργία ενός ψεύτικου κομματιού σε μη-heap περιοχές (όπως η στοίβα, η ενότητα .bss ή το PLT/GOT) απαιτεί επίσης **μια διαρροή heap** λόγω της ανάγκης για παραμόρφωση δείκτη. Αυτό επεκτείνει την πολυπλοκότητα της εκμετάλλευσης αυτών των περιοχών, παρόμοια με την απαίτηση για χειραγώγηση διευθύνσεων LibC.
4. **Η Διαρροή Διευθύνσεων Heap Γίνεται Πιο Δύσκολη**: Ο παραμορφωμένος δείκτης περιορίζει τη χρησιμότητα των δεικτών Fd σε fastbin και tcache bins ως πηγές για διαρροές διευθύνσεων heap. Ωστόσο, οι δείκτες σε αταξινόμητα, μικρά και μεγάλα bins παραμένουν μη παραμορφωμένοι, επομένως είναι ακόμα χρήσιμοι για διαρροές διευθύνσεων. Αυτή η αλλαγή ωθεί τους επιτιθέμενους να εξερευνήσουν αυτά τα bins για εκμεταλλεύσιμες πληροφορίες, αν και ορισμένες τεχνικές μπορεί να επιτρέπουν ακόμα την αποπαραμόρφωση δεικτών πριν από μια διαρροή, αν και με περιορισμούς.

### **Demangling Pointers with a Heap Leak**

> [!CAUTION]
> Για μια καλύτερη εξήγηση της διαδικασίας [**ελέγξτε την αρχική ανάρτηση από εδώ**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Algorithm Overview

Η φόρμουλα που χρησιμοποιείται για την παραμόρφωση και αποπαραμόρφωση δεικτών είναι:&#x20;

**`New_Ptr = (L >> 12) XOR P`**

Όπου **L** είναι η τοποθεσία αποθήκευσης και **P** είναι ο δείκτης Fd. Όταν **L** μετατοπίζεται προς τα δεξιά κατά 12 bit, εκθέτει τα πιο σημαντικά bit του **P**, λόγω της φύσης του **XOR**, το οποίο επιστρέφει 0 όταν τα bit XORαριστούν με τον εαυτό τους.

**Key Steps in the Algorithm:**

1. **Αρχική Διαρροή των Πιο Σημαντικών Bit**: Με το XORαρισμα του μετατοπισμένου **L** με **P**, αποκτάτε αποτελεσματικά τα 12 πιο σημαντικά bit του **P** επειδή το μετατοπισμένο τμήμα του **L** θα είναι μηδέν, αφήνοντας τα αντίστοιχα bit του **P** αμετάβλητα.
2. **Ανάκτηση των Bit του Δείκτη**: Δεδομένου ότι το XOR είναι αναστρέψιμο, γνωρίζοντας το αποτέλεσμα και έναν από τους τελεστές σας επιτρέπει να υπολογίσετε τον άλλο τελεστή. Αυτή η ιδιότητα χρησιμοποιείται για να υπολογίσει το σύνολο των bit για **P** με διαδοχικό XORαρισμα γνωστών συνόλων bit με μέρη του παραμορφωμένου δείκτη.
3. **Επαναληπτική Αποπαραμόρφωση**: Η διαδικασία επαναλαμβάνεται, κάθε φορά χρησιμοποιώντας τα νέα ανακαλυφθέντα bit του **P** από το προηγούμενο βήμα για να αποκωδικοποιήσει το επόμενο τμήμα του παραμορφωμένου δείκτη, μέχρι να ανακτηθούν όλα τα bit.
4. **Διαχείριση Ντετερμινιστικών Bit**: Τα τελικά 12 bit του **L** χάνονται λόγω της μετατόπισης, αλλά είναι ντετερμινιστικά και μπορούν να ανακατασκευαστούν μετά τη διαδικασία.

Μπορείτε να βρείτε μια υλοποίηση αυτού του αλγορίθμου εδώ: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Ο δείκτης φρουρού είναι μια τεχνική μετριασμού εκμετάλλευσης που χρησιμοποιείται στη glibc για την προστασία των αποθηκευμένων δεικτών συναρτήσεων, ιδιαίτερα αυτών που καταχωρούνται από κλήσεις βιβλιοθήκης όπως το `atexit()`. Αυτή η προστασία περιλαμβάνει την ανακατεύθυνση των δεικτών με XORαρισμα τους με ένα μυστικό που αποθηκεύεται στα δεδομένα νήματος (`fs:0x30`) και την εφαρμογή μιας μετατόπισης bit. Αυτός ο μηχανισμός στοχεύει να αποτρέψει τους επιτιθέμενους από το να αναλάβουν τον έλεγχο της ροής εκτέλεσης επικαλύπτοντας τους δείκτες συναρτήσεων.

### **Bypassing Pointer Guard with a leak**

1. **Κατανόηση των Λειτουργιών του Pointer Guard:** Η ανακατεύθυνση (παραμόρφωση) των δεικτών γίνεται χρησιμοποιώντας το μακροεντολή `PTR_MANGLE` που XORαριστεί τον δείκτη με ένα 64-bit μυστικό και στη συνέχεια εκτελεί μια αριστερή μετατόπιση 0x11 bit. Η αντίστροφη λειτουργία για την ανάκτηση του αρχικού δείκτη διαχειρίζεται από το `PTR_DEMANGLE`.
2. **Στρατηγική Επίθεσης:** Η επίθεση βασίζεται σε μια προσέγγιση γνωστού κειμένου, όπου ο επιτιθέμενος πρέπει να γνωρίζει τόσο την αρχική όσο και την παραμορφωμένη έκδοση ενός δείκτη για να deduce το μυστικό που χρησιμοποιήθηκε για την παραμόρφωση.
3. **Εκμετάλλευση Γνωστών Κειμένων:**
- **Εντοπισμός Σταθερών Δεικτών Συναρτήσεων:** Εξετάζοντας τον πηγαίο κώδικα της glibc ή τους πίνακες δεικτών συναρτήσεων που έχουν αρχικοποιηθεί (όπως `__libc_pthread_functions`), ένας επιτιθέμενος μπορεί να βρει προβλέψιμους δείκτες συναρτήσεων.
- **Υπολογισμός του Μυστικού:** Χρησιμοποιώντας έναν γνωστό δείκτη συναρτήσεων όπως το `__pthread_attr_destroy` και την παραμορφωμένη έκδοση του από τον πίνακα δεικτών συναρτήσεων, το μυστικό μπορεί να υπολογιστεί με την αντίστροφη μετατόπιση (δεξιά μετατόπιση) του παραμορφωμένου δείκτη και στη συνέχεια XORαρισμα του με τη διεύθυνση της συνάρτησης.
4. **Εναλλακτικά Κείμενα:** Ο επιτιθέμενος μπορεί επίσης να πειραματιστεί με την παραμόρφωση δεικτών με γνωστές τιμές όπως 0 ή -1 για να δει αν αυτές παράγουν αναγνωρίσιμα μοτίβα στη μνήμη, αποκαλύπτοντας ενδεχομένως το μυστικό όταν αυτά τα μοτίβα βρεθούν σε εκφορτώσεις μνήμης.
5. **Πρακτική Εφαρμογή:** Αφού υπολογιστεί το μυστικό, ένας επιτιθέμενος μπορεί να χειραγωγήσει τους δείκτες με ελεγχόμενο τρόπο, ουσιαστικά παρακάμπτοντας την προστασία Pointer Guard σε μια πολυνηματική εφαρμογή με γνώση της διεύθυνσης βάσης libc και ικανότητα ανάγνωσης αυθαίρετων τοποθεσιών μνήμης.

## References

- [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
- [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)

{{#include ../../banners/hacktricks-training.md}}
