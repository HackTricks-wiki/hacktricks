# Libc-Schutzmechanismen

{{#include ../../banners/hacktricks-training.md}}

## Durchsetzung der Chunk-Ausrichtung

**Malloc** alloziert Speicher in **8-Byte-Gruppen (32-Bit) oder 16-Byte-Gruppen (64-Bit)**. Das bedeutet, dass das Ende von Chunks in 32-Bit-Systemen mit **0x8** ausgerichtet sein sollte und in 64-Bit-Systemen mit **0x0**. Die Sicherheitsfunktion überprüft, dass jeder Chunk an diesen spezifischen Positionen **korrekt ausgerichtet** ist, bevor ein Pointer aus einer bin verwendet wird.

### Sicherheitsvorteile

Die Durchsetzung der Chunk-Ausrichtung in 64-Bit-Systemen verbessert die Sicherheit von Malloc erheblich, indem sie die Platzierung gefälschter Chunks auf **nur 1 von jeweils 16 Adressen** einschränkt. Dadurch werden Exploit-Versuche erschwert, besonders in Szenarien, in denen der Angreifer nur begrenzte Kontrolle über Eingabewerte hat, was Angriffe komplexer und schwerer auszuführen macht.

- **Fastbin Attack on `__malloc_hook`**

Die neuen Ausrichtungsregeln in Malloc vereiteln auch einen klassischen Angriff, der `__malloc_hook` betrifft. Früher konnten Angreifer Chunk-Größen manipulieren, um diesen Funktionszeiger zu überschreiben und dadurch Codeausführung zu erlangen. Jetzt sorgt die strikte Ausrichtungsanforderung dafür, dass solche Manipulationen nicht mehr praktikabel sind, womit eine übliche Exploit-Route geschlossen und die Gesamtsicherheit erhöht wird.

> **Hinweis:** Seit glibc **2.34** wurden die legacy hooks (`__malloc_hook`, `__free_hook`, etc.) aus dem exportierten ABI entfernt. Moderne Exploits zielen jetzt auf andere beschreibbare Funktionszeiger (z. B. tcache per-thread struct, vtable-style callbacks) oder verlassen sich auf `setcontext`, `_IO_list_all` primitives, etc.

## Pointer Mangling on fastbins and tcache

**Pointer Mangling** ist eine Sicherheitsverbesserung, die zum Schutz der fastbin- und tcache Fd Pointer in Speicherverwaltungsoperationen eingesetzt wird. Diese Technik hilft, bestimmte Arten von Memory-Exploit-Taktiken zu verhindern, insbesondere solche, die keine leaked Speicherinformationen benötigen oder Speicherorte direkt relativ zu bekannten Positionen manipulieren (relative **overwrites**).

Der Kern dieser Technik ist eine Verschleierungsformel:

**`New_Ptr = (L >> 12) XOR P`**

- **L** ist der **Speicherort** des Zeigers.
- **P** ist der tatsächliche **fastbin/tcache Fd Pointer**.

Der Grund für die bitweise Rechtsverschiebung des Speicherorts (L) um 12 Bits vor der XOR-Operation ist entscheidend. Diese Manipulation behebt eine Schwachstelle, die in der deterministischen Natur der 12 niederwertigsten Bits von Speicheradressen liegt, welche aufgrund architekturbedingter Einschränkungen typischerweise vorhersehbar sind. Durch das Verschieben der Bits wird der vorhersehbare Anteil aus der Gleichung entfernt, wodurch die Zufälligkeit des neuen, gemangelten Pointers erhöht und somit gegen Exploits geschützt wird, die sich auf die Vorhersagbarkeit dieser Bits verlassen.

Dieser gemangelte Pointer nutzt die vorhandene Zufälligkeit, die durch **Address Space Layout Randomization (ASLR)** bereitgestellt wird, welche die von Programmen verwendeten Adressen randomisiert, um es Angreifern zu erschweren, das Speicherlayout eines Prozesses vorherzusagen.

Das **Demangling** des Pointers, um die ursprüngliche Adresse wiederherzustellen, erfolgt mittels derselben XOR-Operation. Dabei wird der gemangelte Pointer als P in der Formel behandelt und bei XOR mit dem unveränderten Speicherort (L) wird der originale Pointer wieder sichtbar. Diese Symmetrie zwischen Mangling und Demangling stellt sicher, dass das System Pointer effizient kodieren und dekodieren kann, ohne nennenswerten Overhead, während die Sicherheit gegen Angriffe, die Speicherzeiger manipulieren, deutlich erhöht wird.

### Sicherheitsvorteile

Pointer Mangling zielt darauf ab, partielle und vollständige Pointer-Überschreibungen im Heap-Management zu verhindern — eine bedeutende Sicherheitsverbesserung. Dieses Feature beeinflusst Exploit-Techniken auf mehrere Weisen:

1. Verhinderung von byteweisen relativen Overwrites: Früher konnten Angreifer Teile eines Zeigers ändern, um Heap-Chunks auf andere Orte umzuleiten, ohne die exakten Adressen zu kennen — eine Technik, die im leakless **House of Roman** exploit sichtbar ist. Mit Pointer Mangling erfordern solche relativen Overwrites **ohne einen heap leak nun Brute-Forcing**, wodurch ihre Erfolgswahrscheinlichkeit drastisch sinkt.
2. Erhöhte Schwierigkeit von Tcache-Bin/Fastbin-Angriffen: Gängige Angriffe, die Funktionszeiger (wie `__malloc_hook`) durch Manipulation von fastbin- oder tcache-Einträgen überschreiben, werden behindert. Zum Beispiel könnte ein Angriff das Leaken einer LibC-Adresse, das Freeen eines Chunks in die tcache bin und anschließend das Überschreiben des Fd-Pointers umfassen, um diesen auf `__malloc_hook` umzuleiten und beliebige Codeausführung zu erlangen. Mit Pointer Mangling müssen diese Pointer korrekt gemangelt werden, **was ein heap leak für eine genaue Manipulation erforderlich macht**, und erhöht damit die Exploit-Hürde.
3. Anforderung von heap leaks für Nicht-Heap-Orte: Das Erstellen eines gefälschten Chunks in Nicht-Heap-Bereichen (wie dem stack, der .bss-Sektion oder PLT/GOT) erfordert jetzt ebenfalls einen heap leak aufgrund der Pointer-Mangling-Anforderung. Das erhöht die Komplexität, diese Bereiche zu exploiten, ähnlich wie bei der Manipulation von LibC-Adressen.
4. Das Leaken von Heap-Adressen wird schwieriger: Pointer Mangling schränkt die Nützlichkeit von Fd-Pointern in fastbin- und tcache-bins als Quelle für heap address leaks ein. Pointer in unsorted, small und large bins bleiben jedoch ungemangelt und sind daher weiterhin zum Leaken von Adressen nutzbar. Diese Veränderung zwingt Angreifer dazu, diese bins nach verwertbaren Informationen zu durchsuchen, obwohl einige Techniken möglicherweise erlauben, Pointer vor einem leak zu demangeln, allerdings mit Einschränkungen.

### **Safe-Linking Bypass (page-aligned leak scenario)**

Selbst mit aktiviertem safe-linking (glibc ≥ 2.32) gilt: Wenn du den gemangelten Pointer leaken kannst und sowohl der beschädigte Chunk als auch der Victim-Chunk dieselbe 4KB-Seite teilen, kann der ursprüngliche Pointer allein anhand des Page-Offsets wiederhergestellt werden:
```c
// leaked_fd is the mangled Fd read from the chunk on the same page
uintptr_t l = (uintptr_t)&chunk->fd;           // storage location
uintptr_t original = (leaked_fd ^ (l >> 12));  // demangle
```
Dies stellt das Fd wieder her und erlaubt klassisches tcache/fastbin poisoning. Wenn die chunks auf verschiedenen pages liegen, ist das Bruteforcen des 12-bit page offsets (0x1000 Möglichkeiten) oft praktikabel, wenn die allocation patterns deterministisch sind oder Abstürze akzeptabel sind (z. B. CTF-style exploits).

### **Demangling Pointers with a Heap Leak**

> [!CAUTION]
> Für eine bessere Erklärung des Vorgangs [**siehe den Originalbeitrag hier**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Algorithm Overview

Die zur Mangelierung und Demangelierung von Pointern verwendete Formel lautet:

**`New_Ptr = (L >> 12) XOR P`**

Wobei **L** der Speicherort und **P** der Fd-Pointer ist. Wenn **L** um 12 Bits nach rechts verschoben wird, legt das die höchstwertigen Bits von **P** frei, aufgrund der Natur von **XOR**, das 0 ausgibt, wenn Bits mit sich selbst XORed werden.

**Wichtige Schritte des Algorithmus:**

1. **Erster Leak der höchstwertigen Bits:** Durch das XORen des verschobenen **L** mit **P** erhält man effektiv die oberen 12 Bits von **P**, weil der verschobene Teil von **L** null sein wird und somit die entsprechenden Bits von **P** unverändert bleiben.
2. **Wiedergewinnung von Pointer-Bits:** Da XOR umkehrbar ist, erlaubt das Kennen des Ergebnisses und eines der Operanden, den anderen Operanden zu berechnen. Diese Eigenschaft wird genutzt, um die vollständige Bitfolge von **P** zu erschließen, indem sukzessive bekannte Bitmengen mit Teilen des gemangelten Pointers XORed werden.
3. **Iterative Demangelierung:** Der Prozess wird wiederholt, wobei jedes Mal die neu entdeckten Bits von **P** aus dem vorherigen Schritt verwendet werden, um das nächste Segment des gemangelten Pointers zu dekodieren, bis alle Bits rekonstruiert sind.
4. **Umgang mit deterministischen Bits:** Die letzten 12 Bits von **L** gehen durch die Verschiebung verloren, sind jedoch deterministisch und können nachträglich rekonstruiert werden.

Eine Implementierung dieses Algorithmus findet sich hier: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer Guard ist eine Exploit-Mitigations-Technik in glibc zum Schutz gespeicherter Function Pointers, insbesondere solcher, die durch Bibliotheksaufrufe wie `atexit()` registriert werden. Diese Schutzmaßnahme verschleiert die Pointer, indem sie sie mit einem Geheimnis xoriert, das in den Thread-Daten (`fs:0x30`) gespeichert ist, und zusätzlich eine Bit-Rotation anwendet. Dieser Mechanismus soll verhindern, dass Angreifer die Kontrolle über den Ablauf übernehmen, indem sie Function Pointers überschreiben.

### **Bypassing Pointer Guard with a leak**

1. **Verständnis der Pointer Guard-Operationen:** Die Verschleierung (mangling) von Pointern erfolgt mit dem `PTR_MANGLE`-Macro, das den Pointer mit einem 64-Bit-Geheimnis XORt und dann eine Linksdrehung um 0x11 Bits ausführt. Die Umkehrung zur Wiederherstellung des ursprünglichen Pointers wird von `PTR_DEMANGLE` übernommen.
2. **Angriffsstrategie:** Der Angriff basiert auf einem Known-Plaintext-Ansatz, bei dem der Angreifer sowohl die originale als auch die gemangelte Version eines Pointers kennen muss, um das zum Mangling verwendete Geheimnis zu ermitteln.
3. **Ausnutzung bekannter Plaintexts:**
- **Identifizieren fester Function Pointers:** Durch Untersuchung des glibc-Quellcodes oder initialisierter Function-Pointer-Tabellen (wie `__libc_pthread_functions`) kann ein Angreifer vorhersehbare Function Pointers finden.
- **Berechnung des Geheimnisses:** Mithilfe eines bekannten Function Pointers wie `__pthread_attr_destroy` und seiner gemangelten Version aus der Function-Pointer-Tabelle kann das Geheimnis berechnet werden, indem man den gemangelten Pointer rechts rotiert (reverse rotating) und dann mit der Adresse der Funktion XORt.
4. **Alternative Plaintexts:** Der Angreifer kann auch experimentieren, Pointer mit bekannten Werten wie 0 oder -1 zu mangeln, um zu prüfen, ob diese in Memory-Dumps erkennbare Muster erzeugen, die potenziell das Geheimnis offenbaren, wenn diese Muster gefunden werden.
5. **Praktische Anwendung:** Nach Berechnung des Geheimnisses kann ein Angreifer Pointer kontrolliert manipulieren und damit Pointer Guard in einer multithreaded Anwendung umgehen, sofern die libc-Basisadresse bekannt ist und das Lesen beliebiger Speicherstellen möglich ist.

## GLIBC Tunables & Recent Loader Bugs

Der dynamische Loader parsed `GLIBC_TUNABLES` vor dem Programmstart. Fehler beim Parsen hier wirken sich direkt auf **libc** aus, noch bevor die meisten Mitigations greifen. Der Fehler 2023 "Looney Tunables" (CVE-2023-4911) ist ein Beispiel: ein überlanger `GLIBC_TUNABLES`-Wert überläuft interne Puffer in `ld.so` und ermöglicht in Kombination mit SUID-Binaries eine weitreichende privilege escalation auf vielen Distributionen. Die Ausnutzung erfordert nur das Manipulieren der Umgebung und wiederholtes Aufrufen des Zielbinaries; Pointer Guard oder safe-linking verhindern dies nicht, da die Korruption bereits im Loader vor dem Heap-Setup auftritt.

## Quellen

- [Safe-Linking bypass explanation (shellphish/how2heap)](https://deepwiki.com/shellphish/how2heap/5.2-safe-linking-bypass)
- [Looney Tunables (CVE-2023-4911) write-up](https://www.wiz.io/vulnerability-database/cve/cve-2023-4911)

{{#include ../../banners/hacktricks-training.md}}
