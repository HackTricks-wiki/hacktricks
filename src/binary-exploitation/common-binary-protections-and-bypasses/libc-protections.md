# Захисти Libc

{{#include ../../banners/hacktricks-training.md}}

## Примусове вирівнювання чанків

**Malloc** виділяє пам'ять у групах по **8 байт (32-bit) або 16 байт (64-bit)**. Це означає, що кінці чанків у 32-бітних системах повинні вирівнюватися за **0x8**, а в 64-бітних системах — за **0x0**. Ця функція безпеки перевіряє, що кожен чанк **правильно вирівняний** у цих конкретних місцях перед використанням вказівника з bin.

### Переваги безпеки

Примусове вирівнювання чанків у 64-бітних системах суттєво підвищує безпеку Malloc, обмежуючи можливі місця для підроблених чанків до **лише 1 із кожних 16 адрес**. Це ускладнює експлуати, особливо в сценаріях, де користувач має обмежений контроль над значеннями на вході, роблячи атаки більш складними та менш ймовірними для успіху.

- **Fastbin Attack on `__malloc_hook`**

Нові правила вирівнювання в Malloc також ускладнюють класичну атаку, що використовує `__malloc_hook`. Раніше зловмисники могли маніпулювати розмірами чанків, щоб **перезаписати цей вказівник на функцію** і отримати **виконання коду**. Тепер суворе вимога вирівнювання гарантує, що такі маніпуляції більше не є життєздатними, закриваючи поширений шлях експлуатації та підвищуючи загальну безпеку.

> **Note:** Since glibc **2.34** the legacy hooks (`__malloc_hook`, `__free_hook`, etc.) are removed from the exported ABI. Modern exploits now target other writable function pointers (e.g. tcache per-thread struct, vtable-style callbacks) or rely on `setcontext`, `_IO_list_all` primitives, etc.

## Pointer Mangling on fastbins and tcache

**Pointer Mangling** — це покращення безпеки, яке використовується для захисту **fastbin та tcache Fd pointers** у операціях управління пам'яттю. Ця техніка допомагає запобігти певним видам тактик експлуатації пам'яті, зокрема тим, що не вимагають leaked memory information або маніпулюють місцями в пам'яті безпосередньо відносно відомих позицій (відносні **overwrites**).

Серцевина цієї техніки — формула обфускації:

**`New_Ptr = (L >> 12) XOR P`**

- **L** — це **Storage Location** вказівника.
- **P** — фактичний **fastbin/tcache Fd Pointer**.

Причина побітового зсуву місця зберігання (L) на 12 біт праворуч перед операцією XOR є критичною. Це усуває вразливість, притаманну детерміністичній природі найменш значущих 12 біт адрес пам'яті, які зазвичай передбачувані через обмеження архітектури системи. Зсув цих бітів виводить передбачувану частину з рівняння, підвищуючи випадковість нового, замаскованого вказівника і, тим самим, захищаючи від експлоїтів, що покладаються на передбачуваність цих бітів.

Цей замаскований вказівник використовує наявну випадковість, яку забезпечує **ASLR**, що рандомізує адреси, використовувані програмами, щоб ускладнити прогнозування планування пам'яті процесу.

Деманглінг вказівника для відновлення оригінальної адреси виконується за допомогою тієї ж операції XOR. Тут замаскований вказівник розглядається як P у формулі, і при XOR з незмінним місцем зберігання (L) повертається оригінальний вказівник. Ця симетрія в mangling і demangling дозволяє системі ефективно кодувати і декодувати вказівники без значних витрат, при цьому істотно підвищуючи захист від атак, що маніпулюють вказівниками пам'яті.

### Переваги безпеки

Pointer mangling має на меті **запобігти частковим та повним перезаписам вказівників у керуванні heap**, що є значним підвищенням безпеки. Ця функція впливає на техніки експлуатації кількома способами:

1. **Запобігання побайтовим відносним перезаписам**: Раніше зловмисники могли змінювати частину вказівника, щоб **перенаправити heap чанки в інші місця без точного знання адрес**, техніка, помітна в leakless **House of Roman** exploit. З pointer mangling такі відносні перезаписи **без heap leak тепер вимагають brute forcing**, що значно знижує ймовірність їх успіху.
2. **Ускладнення атак на tcache bin / fastbin**: Звичайні атаки, що перезаписують вказівники функцій (наприклад, `__malloc_hook`) шляхом маніпулювання записами fastbin або tcache, ускладнені. Наприклад, атака може включати отримання leaked LibC адреси, звільнення чанку в tcache bin, а потім перезапис Fd вказівника, щоб перенаправити його на `__malloc_hook` для довільного виконання коду. З pointer mangling ці вказівники повинні бути правильно замасковані, **що вимагає heap leak для коректної маніпуляції**, підвищуючи бар'єр для експлуатації.
3. **Вимога heap leak для створення фейкового чанку в не-heap областях**: Створення фейкового чанку в не-heap областях (наприклад, на stack, секції .bss або PLT/GOT) тепер також **вимагає heap leak** через необхідність pointer mangling. Це ускладнює експлуатацію цих областей, подібно до вимоги для маніпуляції LibC адресами.
4. **Ускладнення отримання heap адрес**: Pointer mangling обмежує корисність Fd вказівників у fastbin та tcache бінках як джерел для heap address leaks. Однак вказівники в unsorted, small та large bins залишаються незамаскованими і тому все ще придатні для отримання адрес. Це штовхає атакуючих досліджувати ці бінки в пошуках експлуатованої інформації, хоча деякі техніки все ще можуть дозволяти деманглити вказівники перед leak, але з обмеженнями.

### **Safe-Linking Bypass (page-aligned leak scenario)**

Навіть з увімкненим safe-linking (glibc ≥ 2.32), якщо ви можете leak замаскований вказівник і як пошкоджений чанк, так і victim chunk знаходяться на одній 4KB сторінці, оригінальний вказівник можна відновити лише за допомогою page offset:
```c
// leaked_fd is the mangled Fd read from the chunk on the same page
uintptr_t l = (uintptr_t)&chunk->fd;           // storage location
uintptr_t original = (leaked_fd ^ (l >> 12));  // demangle
```
This restores the Fd and permits classic tcache/fastbin poisoning. If the chunks sit on different pages, brute-forcing the 12-bit page offset (0x1000 possibilities) is often feasible when allocation patterns are deterministic or when crashes are acceptable (e.g., CTF-style exploits).

### **Деманглінг вказівників з heap leak**

> [!CAUTION]
> For a better explanation of the process [**check the original post from here**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Algorithm Overview

The formula used for mangling and demangling pointers is:

**`New_Ptr = (L >> 12) XOR P`**

Where **L** is the storage location and **P** is the Fd pointer. When **L** is shifted right by 12 bits, it exposes the most significant bits of **P**, due to the nature of **XOR**, which outputs 0 when bits are XORed with themselves.

**Key Steps in the Algorithm:**

1. **Initial Leak of the Most Significant Bits**: By XORing the shifted **L** with **P**, you effectively get the top 12 bits of **P** because the shifted portion of **L** will be zero, leaving **P's** corresponding bits unchanged.
2. **Recovery of Pointer Bits**: Since XOR is reversible, knowing the result and one of the operands allows you to compute the other operand. This property is used to deduce the entire set of bits for **P** by successively XORing known sets of bits with parts of the mangled pointer.
3. **Iterative Demangling**: The process is repeated, each time using the newly discovered bits of **P** from the previous step to decode the next segment of the mangled pointer, until all bits are recovered.
4. **Handling Deterministic Bits**: The final 12 bits of **L** are lost due to the shift, but they are deterministic and can be reconstructed post-process.

You can find an implementation of this algorithm here: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer guard is an exploit mitigation technique used in glibc to protect stored function pointers, particularly those registered by library calls such as `atexit()`. This protection involves scrambling the pointers by XORing them with a secret stored in the thread data (`fs:0x30`) and applying a bitwise rotation. This mechanism aims to prevent attackers from hijacking control flow by overwriting function pointers.

### **Bypassing Pointer Guard with a leak**

1. **Understanding Pointer Guard Operations:** The scrambling (mangling) of pointers is done using the `PTR_MANGLE` macro which XORs the pointer with a 64-bit secret and then performs a left rotation of 0x11 bits. The reverse operation for recovering the original pointer is handled by `PTR_DEMANGLE`.
2. **Attack Strategy:** The attack is based on a known-plaintext approach, where the attacker needs to know both the original and the mangled versions of a pointer to deduce the secret used for mangling.
3. **Exploiting Known Plaintexts:**
- **Identifying Fixed Function Pointers:** By examining glibc source code or initialized function pointer tables (like `__libc_pthread_functions`), an attacker can find predictable function pointers.
- **Computing the Secret:** Using a known function pointer such as `__pthread_attr_destroy` and its mangled version from the function pointer table, the secret can be calculated by reverse rotating (right rotation) the mangled pointer and then XORing it with the address of the function.
4. **Alternative Plaintexts:** The attacker can also experiment with mangling pointers with known values like 0 or -1 to see if these produce identifiable patterns in memory, potentially revealing the secret when these patterns are found in memory dumps.
5. **Practical Application:** After computing the secret, an attacker can manipulate pointers in a controlled manner, essentially bypassing the Pointer Guard protection in a multithreaded application with knowledge of the libc base address and an ability to read arbitrary memory locations.

## GLIBC Tunables & Recent Loader Bugs

The dynamic loader parses `GLIBC_TUNABLES` before program startup. Mis-parsing bugs here directly affect **libc** before most mitigations kick in. The 2023 "Looney Tunables" bug (CVE-2023-4911) is an example: an overlong `GLIBC_TUNABLES` value overflows internal buffers in `ld.so`, enabling **privilege escalation** on many distros when combined with SUID binaries. Exploitation requires only crafting the environment and repeatedly invoking the target binary; pointer guard or safe-linking do not prevent it because corruption happens in the loader prior to heap setup.

## References

- [Safe-Linking bypass explanation (shellphish/how2heap)](https://deepwiki.com/shellphish/how2heap/5.2-safe-linking-bypass)
- [Looney Tunables (CVE-2023-4911) write-up](https://www.wiz.io/vulnerability-database/cve/cve-2023-4911)

{{#include ../../banners/hacktricks-training.md}}
