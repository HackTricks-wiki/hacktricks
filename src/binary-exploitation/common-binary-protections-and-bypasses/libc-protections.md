# Libc Protections

{{#include ../../banners/hacktricks-training.md}}

## Chunk Alignment Enforcement

**Malloc** inatoa kumbukumbu katika **8-byte (32-bit) au 16-byte (64-bit) makundi**. Hii inamaanisha kwamba mwisho wa chunks katika mifumo ya 32-bit inapaswa kuendana na **0x8**, na katika mifumo ya 64-bit na **0x0**. Kipengele hiki cha usalama kinathibitisha kwamba kila chunk **inaendana vizuri** katika maeneo haya maalum kabla ya kutumia pointer kutoka kwa bin.

### Faida za Usalama

Utekelezaji wa kuendana kwa chunks katika mifumo ya 64-bit huongeza usalama wa Malloc kwa **kudhibiti uwekaji wa chunks za uongo kuwa 1 tu kati ya anwani 16**. Hii inafanya juhudi za unyakuzi kuwa ngumu, hasa katika hali ambapo mtumiaji ana udhibiti mdogo juu ya thamani za pembejeo, na kufanya mashambulizi kuwa magumu zaidi na yasiyoweza kutekelezwa kwa mafanikio.

- **Fastbin Attack on \_\_malloc_hook**

Sheria mpya za kuendana katika Malloc pia zinakabili shambulio la jadi linalohusisha `__malloc_hook`. Awali, washambuliaji wangeweza kubadilisha saizi za chunks ili **kuandika tena pointer hii ya kazi** na kupata **utendaji wa msimbo**. Sasa, hitaji kali la kuendana linahakikisha kwamba manipulasi kama hizo hazifai tena, na kufunga njia ya kawaida ya unyakuzi na kuongeza usalama kwa ujumla.

## Pointer Mangling on fastbins and tcache

**Pointer Mangling** ni uboreshaji wa usalama unaotumika kulinda **fastbin na tcache Fd pointers** katika operesheni za usimamizi wa kumbukumbu. Tekni hii husaidia kuzuia aina fulani za mbinu za unyakuzi wa kumbukumbu, hasa zile ambazo hazihitaji taarifa za kumbukumbu zilizovuja au ambazo zinabadilisha maeneo ya kumbukumbu moja kwa moja kulingana na nafasi zilizojulikana (kuandika **relative**).

Msingi wa mbinu hii ni formula ya kuficha:

**`New_Ptr = (L >> 12) XOR P`**

- **L** ni **Mahali pa Hifadhi** ya pointer.
- **P** ni **fastbin/tcache Fd Pointer** halisi.

Sababu ya kuhamasisha mahali pa hifadhi (L) kwa bits 12 kwenda kulia kabla ya operesheni ya XOR ni muhimu. Manipulasi hii inashughulikia udhaifu ulio ndani ya asili ya kimaamuzi ya bits 12 za chini zaidi za anwani za kumbukumbu, ambazo kwa kawaida zinatabirika kutokana na vikwazo vya usanifu wa mfumo. Kwa kuhamasisha bits, sehemu inayotabirika inahamishwa nje ya hesabu, ikiongeza nasibu ya pointer mpya, iliyofichwa na hivyo kulinda dhidi ya unyakuzi unaotegemea utabiri wa bits hizi.

Pointer hii iliyofichwa inatumia nasibu iliyopo iliyotolewa na **Address Space Layout Randomization (ASLR)**, ambayo inafanya anwani zinazotumiwa na programu kuwa ngumu kwa washambuliaji kutabiri mpangilio wa kumbukumbu wa mchakato.

**Demangling** pointer ili kupata anwani ya asili inahusisha kutumia operesheni ile ile ya XOR. Hapa, pointer iliyofichwa inachukuliwa kama P katika formula, na wakati inapo XORed na mahali pa hifadhi (L) isiyobadilika, inasababisha pointer ya asili kufichuliwa. Hii symmetry katika mangling na demangling inahakikisha kwamba mfumo unaweza kwa ufanisi kuandika na kufichua pointers bila mzigo mkubwa, huku ikiongeza usalama dhidi ya mashambulizi yanayobadilisha pointers za kumbukumbu.

### Faida za Usalama

Maimara ya pointer yanakusudia **kuzuia kuandika tena kwa sehemu na kamili za pointer katika usimamizi wa heap**, uboreshaji muhimu katika usalama. Kipengele hiki kinaathiri mbinu za unyakuzi kwa njia kadhaa:

1. **Kuzuia Kuandika kwa Bye Byte Relative**: Awali, washambuliaji wangeweza kubadilisha sehemu ya pointer ili **kuhamasisha chunks za heap kwa maeneo tofauti bila kujua anwani sahihi**, mbinu ambayo inaonekana katika unyakuzi wa **House of Roman** bila uvujaji. Kwa maimara ya pointer, kuandika tena kama hizo **bila uvujaji wa heap sasa kunahitaji nguvu ya kikatili**, na kupunguza sana uwezekano wa mafanikio yao.
2. **Kuongeza Ugumu wa Mashambulizi ya Tcache Bin/Fastbin**: Mashambulizi ya kawaida yanayoandika tena pointers za kazi (kama `__malloc_hook`) kwa kubadilisha fastbin au tcache entries yanakabiliwa. Kwa mfano, shambulio linaweza kujumuisha kuvujisha anwani ya LibC, kuachilia chunk katika tcache bin, na kisha kuandika tena pointer ya Fd ili kuhamasisha kwa `__malloc_hook` kwa utendaji wa msimbo wa kiholela. Kwa maimara ya pointer, pointers hizi lazima ziwe zimefichwa vizuri, **zinahitaji uvujaji wa heap kwa usahihi wa manipulasi**, hivyo kuongeza kizuizi cha unyakuzi.
3. **Hitaji la Uvujaji wa Heap katika Maeneo Yasiyo ya Heap**: Kuunda chunk ya uongo katika maeneo yasiyo ya heap (kama stack, sehemu ya .bss, au PLT/GOT) sasa pia **kunahitaji uvujaji wa heap** kutokana na hitaji la maimara ya pointer. Hii inapanua ugumu wa unyakuzi katika maeneo haya, sawa na hitaji la kubadilisha anwani za LibC.
4. **Kuvuja kwa Anwani za Heap Kunakuwa Ngumu Zaidi**: Maimara ya pointer yanapunguza matumizi ya pointers za Fd katika fastbin na tcache bins kama vyanzo vya uvujaji wa anwani za heap. Hata hivyo, pointers katika bins zisizopangwa, ndogo, na kubwa zinabaki kuwa hazijafichwa, hivyo bado zinatumika kwa uvujaji wa anwani. Mabadiliko haya yanawasukuma washambuliaji kuchunguza bins hizi kwa taarifa zinazoweza kutumika, ingawa mbinu zingine zinaweza bado kuruhusu kufichua pointers kabla ya uvujaji, ingawa kwa vikwazo.

### **Demangling Pointers with a Heap Leak**

> [!CAUTION]
> Kwa maelezo bora ya mchakato [**angalia chapisho la asili kutoka hapa**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Muhtasari wa Algorithm

Formula inayotumika kwa maimara na demangling pointers ni:&#x20;

**`New_Ptr = (L >> 12) XOR P`**

Ambapo **L** ni mahali pa hifadhi na **P** ni pointer ya Fd. Wakati **L** inahamishwa kulia kwa bits 12, inafichua bits muhimu zaidi za **P**, kutokana na asili ya **XOR**, ambayo inatoa 0 wakati bits zinapofanywa XOR na wenyewe.

**Hatua Muhimu katika Algorithm:**

1. **Uvujaji wa Awali wa Bits Muhimu Zaidi**: Kwa XORing **L** iliyohamishwa na **P**, unapata kwa ufanisi bits 12 za juu za **P** kwa sababu sehemu iliyohamishwa ya **L** itakuwa sifuri, ikiacha bits zinazohusiana za **P** zisibadilishwe.
2. **Kurejesha Bits za Pointer**: Kwa kuwa XOR ni reversible, kujua matokeo na mmoja wa operandi kunakuruhusu kuhesabu operandi nyingine. Mali hii inatumika kudhibitisha seti nzima ya bits za **P** kwa kufuatilia bits zinazojulikana na sehemu za pointer iliyofichwa.
3. **Demangling ya Kiteremka**: Mchakato unarudiwa, kila wakati ukitumia bits mpya zilizogunduliwa za **P** kutoka hatua ya awali kufichua sehemu inayofuata ya pointer iliyofichwa, hadi bits zote zirejeshwe.
4. **Kushughulikia Bits za Kimaamuzi**: Bits za mwisho 12 za **L** zinapotea kutokana na kuhamasisha, lakini ni za kimaamuzi na zinaweza kujengwa tena baada ya mchakato.

Unaweza kupata utekelezaji wa algorithm hii hapa: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer guard ni mbinu ya kupunguza unyakuzi inayotumika katika glibc kulinda pointers za kazi zilizohifadhiwa, hasa zile zilizosajiliwa na wito wa maktaba kama `atexit()`. Ulinzi huu unahusisha kuchanganya pointers kwa kuwasilisha na XORing na siri iliyohifadhiwa katika data ya thread (`fs:0x30`) na kufanya mzunguko wa bits. Mekanismu hii inalenga kuzuia washambuliaji kuiba mtiririko wa udhibiti kwa kuandika tena pointers za kazi.

### **Kupita Pointer Guard kwa uvujaji**

1. **Kuelewa Operesheni za Pointer Guard:** Kuchanganya (mangling) kwa pointers kunafanywa kwa kutumia macro ya `PTR_MANGLE` ambayo inafanya XOR pointer na siri ya bits 64 na kisha inafanya mzunguko wa kushoto wa bits 0x11. Operesheni ya kinyume ya kurejesha pointer ya asili inashughulikiwa na `PTR_DEMANGLE`.
2. **Mkakati wa Shambulio:** Shambulio linategemea mbinu ya plaintext inayojulikana, ambapo mshambuliaji anahitaji kujua toleo la asili na la kuchanganywa la pointer ili kudhibitisha siri iliyotumika kwa kuchanganya.
3. **Kunutumia Plaintexts Zinazojulikana:**
- **Kutambua Pointers za Kazi Zilizowekwa:** Kwa kuchunguza msimbo wa chanzo wa glibc au meza za pointers za kazi zilizowekwa (kama `__libc_pthread_functions`), mshambuliaji anaweza kupata pointers za kazi zinazoweza kutabirika.
- **Kuhesabu Siri:** Kwa kutumia pointer ya kazi inayojulikana kama `__pthread_attr_destroy` na toleo lake lililochanganywa kutoka kwenye meza ya pointer za kazi, siri inaweza kuhesabiwa kwa kuhamasisha pointer iliyochanganywa na kisha kuifanya XOR na anwani ya kazi.
4. **Plaintexts Mbadala:** Mshambuliaji anaweza pia kujaribu kuchanganya pointers na thamani zinazojulikana kama 0 au -1 ili kuona kama hizi zinatoa mifumo inayoweza kutambulika katika kumbukumbu, huenda zikafichua siri wakati mifumo hii inapatikana katika dump za kumbukumbu.
5. **Matumizi ya Vitendo:** Baada ya kuhesabu siri, mshambuliaji anaweza kubadilisha pointers kwa njia iliyo na udhibiti, kimsingi akipita ulinzi wa Pointer Guard katika programu nyingi za nyuzi kwa maarifa ya anwani ya msingi ya libc na uwezo wa kusoma maeneo ya kumbukumbu ya kiholela.

## Marejeleo

- [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
- [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)

{{#include ../../banners/hacktricks-training.md}}
