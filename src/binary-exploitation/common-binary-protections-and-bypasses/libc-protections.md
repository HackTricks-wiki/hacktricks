# Protecciones de libc

{{#include ../../banners/hacktricks-training.md}}

## Chunk Alignment Enforcement

**Malloc** asigna memoria en **agrupaciones de 8 bytes (32-bit) o 16 bytes (64-bit)**. Esto significa que el final de los chunks en sistemas de 32-bit debe alinearse con **0x8**, y en sistemas de 64-bit con **0x0**. La característica de seguridad comprueba que cada chunk **esté correctamente alineado** en estas ubicaciones específicas antes de usar un puntero desde un bin.

### Beneficios de seguridad

La aplicación de la alineación de chunks en sistemas de 64-bit mejora significativamente la seguridad de Malloc al **limitar la colocación de fake chunks a solo 1 de cada 16 direcciones**. Esto complica los esfuerzos de explotación, especialmente en escenarios donde el usuario tiene control limitado sobre los valores de entrada, haciendo los ataques más complejos y difíciles de ejecutar con éxito.

- **Fastbin Attack on `__malloc_hook`**

Las nuevas reglas de alineación en Malloc también frustran un ataque clásico que involucra `__malloc_hook`. Anteriormente, los atacantes podían manipular tamaños de chunk para **sobrescribir este puntero de función** y obtener **ejecución de código**. Ahora, el requisito estricto de alineación asegura que tales manipulaciones ya no sean viables, cerrando una ruta común de explotación y mejorando la seguridad general.

> **Nota:** Since glibc **2.34** the legacy hooks (`__malloc_hook`, `__free_hook`, etc.) are removed from the exported ABI. Modern exploits now target other writable function pointers (e.g. tcache per-thread struct, vtable-style callbacks) or rely on `setcontext`, `_IO_list_all` primitives, etc.

## Pointer Mangling on fastbins and tcache

**Pointer Mangling** es una mejora de seguridad usada para proteger los punteros Fd de **fastbin y tcache** en operaciones de gestión de memoria. Esta técnica ayuda a prevenir ciertos tipos de tácticas de explotación de memoria, específicamente aquellas que no requieren leaked memory information o que manipulan ubicaciones de memoria directamente relativas a posiciones conocidas (relative **overwrites**).

El núcleo de esta técnica es una fórmula de ofuscación:

**`New_Ptr = (L >> 12) XOR P`**

- **L** es la **Storage Location** del puntero.
- **P** es el verdadero **fastbin/tcache Fd Pointer**.

La razón del desplazamiento a la derecha de 12 bits de la Storage Location (L) antes de la operación XOR es crítica. Esta manipulación aborda una vulnerabilidad inherente a la naturaleza determinista de los 12 bits menos significativos de las direcciones de memoria, que típicamente son predecibles debido a las restricciones de la arquitectura del sistema. Al desplazar los bits, la porción predecible se mueve fuera de la ecuación, mejorando la aleatoriedad del nuevo puntero ofuscado y, por tanto, protegiendo contra exploits que dependen de la predictibilidad de estos bits.

Este puntero mangled aprovecha la aleatoriedad existente provista por **Address Space Layout Randomization (ASLR)**, que randomiza las direcciones usadas por los programas para dificultar que los atacantes predigan el layout de memoria de un proceso.

El **Demangling** del puntero para recuperar la dirección original implica usar la misma operación XOR. Aquí, el puntero mangled se trata como P en la fórmula, y cuando se XORea con la Storage Location (L) sin cambios, resulta en la revelación del puntero original. Esta simetría en mangling y demangling asegura que el sistema puede codificar y decodificar punteros eficientemente sin sobrecarga significativa, mientras incrementa sustancialmente la seguridad contra ataques que manipulan punteros de memoria.

### Beneficios de seguridad

Pointer mangling tiene como objetivo **prevenir overwrites parciales y completos de punteros en la gestión del heap**, una mejora significativa en seguridad. Esta característica impacta las técnicas de explotación de varias maneras:

1. **Prevención de Bye Byte Relative Overwrites**: Anteriormente, los atacantes podían cambiar parte de un puntero para **redirigir chunks del heap a diferentes ubicaciones sin conocer direcciones exactas**, una técnica evidente en el leakless **House of Roman** exploit. Con pointer mangling, tales overwrites relativos **sin un heap leak ahora requieren brute forcing**, reduciendo drásticamente su probabilidad de éxito.
2. **Mayor dificultad en ataques sobre Tcache Bin/Fastbin**: Los ataques comunes que sobrescriben punteros de función (como `__malloc_hook`) manipulando entradas de fastbin o tcache se ven obstaculizados. Por ejemplo, un ataque podría implicar filtrar una LibC address, liberar un chunk en tcache bin y luego sobrescribir el puntero Fd para redirigirlo a `__malloc_hook` para ejecución arbitraria de código. Con pointer mangling, estos punteros deben estar correctamente mangled, **lo que hace necesario un heap leak para manipularlos con precisión**, elevando así la barrera de explotación.
3. **Requisito de heap leaks en ubicaciones no-heap**: Crear un fake chunk en áreas no-heap (como la stack, la sección .bss, o PLT/GOT) ahora también **requiere un heap leak** debido a la necesidad del pointer mangling. Esto extiende la complejidad de explotar estas áreas, similar al requisito para manipular LibC addresses.
4. **Filtrar direcciones del heap se vuelve más desafiante**: Pointer mangling restringe la utilidad de los punteros Fd en fastbin y tcache bins como fuentes para leaks de direcciones del heap. Sin embargo, los punteros en unsorted, small y large bins permanecen unmangled, por lo que aún son utilizables para filtrar direcciones. Este cambio empuja a los atacantes a explorar esos bins para obtener información explotable, aunque algunas técnicas aún pueden permitir demanglar punteros antes de un leak, aunque con restricciones.

### **Safe-Linking Bypass (page-aligned leak scenario)**

Even with safe-linking enabled (glibc ≥ 2.32), if you can leak the mangled pointer and both the corrupted chunk and victim chunk share the same 4KB page, the original pointer can be recovered with just the page offset:
```c
// leaked_fd is the mangled Fd read from the chunk on the same page
uintptr_t l = (uintptr_t)&chunk->fd;           // storage location
uintptr_t original = (leaked_fd ^ (l >> 12));  // demangle
```
Esto restaura el Fd y permite el clásico tcache/fastbin poisoning. Si los chunks están en páginas diferentes, el brute-forcing del page offset de 12 bits (0x1000 posibilidades) suele ser factible cuando los patrones de allocation son deterministas o cuando los crashes son aceptables (p. ej., exploits estilo CTF).

### **Demangling Pointers with a Heap Leak**

> [!CAUTION]
> Para una mejor explicación del proceso [**check the original post from here**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Algorithm Overview

La fórmula usada para mangling y demangling de pointers es:

**`New_Ptr = (L >> 12) XOR P`**

Donde **L** es la ubicación de almacenamiento y **P** es el puntero Fd. Cuando **L** se desplaza a la derecha 12 bits, expone los bits más significativos de **P**, debido a la naturaleza del **XOR**, que devuelve 0 cuando bits iguales se XORean entre sí.

**Pasos clave en el algoritmo:**

1. **Initial Leak of the Most Significant Bits:** Al XORear el **L** desplazado con **P**, efectivamente se obtienen los 12 bits superiores de **P** porque la porción desplazada de **L** será cero, dejando los bits correspondientes de **P** sin cambios.
2. **Recovery of Pointer Bits:** Dado que XOR es reversible, conocer el resultado y uno de los operandos permite calcular el otro operando. Esta propiedad se utiliza para deducir el conjunto completo de bits de **P** al XORear sucesivamente conjuntos conocidos de bits con partes del puntero mangled.
3. **Iterative Demangling:** El proceso se repite, cada vez usando los bits recién descubiertos de **P** del paso anterior para decodificar el siguiente segmento del puntero mangled, hasta recuperar todos los bits.
4. **Handling Deterministic Bits:** Los 12 bits finales de **L** se pierden debido al shift, pero son deterministas y pueden reconstruirse tras el proceso.

Puedes encontrar una implementación de este algoritmo aquí: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer Guard es una técnica de mitigación de exploits usada en glibc para proteger punteros a funciones almacenados, particularmente los registrados por llamadas de librería como `atexit()`. Esta protección implica scrambling de los pointers mediante XOR con un secreto almacenado en los datos del hilo (`fs:0x30`) y aplicando una rotación de bits. Este mecanismo busca evitar que un atacante secuestre el control de ejecución sobrescribiendo punteros a funciones.

### **Bypassing Pointer Guard with a leak**

1. **Understanding Pointer Guard Operations:** El scrambling (mangling) de pointers se realiza usando la macro `PTR_MANGLE`, que XORea el pointer con un secreto de 64 bits y luego realiza una rotación a la izquierda de 0x11 bits. La operación inversa para recuperar el pointer original la maneja `PTR_DEMANGLE`.
2. **Attack Strategy:** El ataque se basa en un enfoque known-plaintext, donde el atacante necesita conocer tanto la versión original como la mangled de un pointer para deducir el secreto usado en el mangling.
3. **Exploiting Known Plaintexts:**
- **Identifying Fixed Function Pointers:** Al examinar el código fuente de glibc o tablas de punteros a funciones inicializadas (como `__libc_pthread_functions`), un atacante puede encontrar punteros a funciones predecibles.
- **Computing the Secret:** Usando un puntero a función conocido como `__pthread_attr_destroy` y su versión mangled desde la tabla de punteros a funciones, el secreto se puede calcular rotando inversamente (rotación a la derecha) el puntero mangled y luego XOReándolo con la dirección de la función.
4. **Alternative Plaintexts:** El atacante también puede experimentar mangling de pointers con valores conocidos como 0 o -1 para ver si estos producen patrones identificables en memoria, pudiendo revelar el secreto cuando dichos patrones se encuentran en dumps de memoria.
5. **Practical Application:** Tras calcular el secreto, un atacante puede manipular pointers de forma controlada, esencialmente bypassing la protección Pointer Guard en una aplicación multihilo si conoce la base de libc y tiene la capacidad de leer ubicaciones arbitrarias de memoria.

## GLIBC Tunables & Recent Loader Bugs

El dynamic loader parsea `GLIBC_TUNABLES` antes del arranque del programa. Bugs de mis-parsing aquí afectan directamente a **libc** antes de que entren en acción la mayoría de las mitigaciones. El bug de 2023 "Looney Tunables" (CVE-2023-4911) es un ejemplo: un valor overlong en `GLIBC_TUNABLES` desborda buffers internos en `ld.so`, permitiendo **privilege escalation** en muchas distros cuando se combina con binarios SUID. La explotación requiere únicamente construir el entorno y invocar repetidamente el binario objetivo; pointer guard o safe-linking no lo previenen porque la corrupción ocurre en el loader antes del setup del heap.

## References

- [Safe-Linking bypass explanation (shellphish/how2heap)](https://deepwiki.com/shellphish/how2heap/5.2-safe-linking-bypass)
- [Looney Tunables (CVE-2023-4911) write-up](https://www.wiz.io/vulnerability-database/cve/cve-2023-4911)

{{#include ../../banners/hacktricks-training.md}}
