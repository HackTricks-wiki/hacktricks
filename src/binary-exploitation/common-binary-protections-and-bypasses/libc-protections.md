# Libc zaštite

{{#include ../../banners/hacktricks-training.md}}

## Sprovođenje poravnanja chunk-ova

**Malloc** alocira memoriju u **8-byte (32-bit) or 16-byte (64-bit) groupings**. To znači da kraj chunk-ova na 32-bit sistemima treba da bude poravnat sa **0x8**, a na 64-bit sistemima sa **0x0**. Bezbednosna funkcija proverava da li je svaki chunk **ispravno poravnat** na tim tačnim lokacijama pre nego što upotrebi pointer iz bina.

### Bezbednosne koristi

Sprovođenje poravnanja chunk-ova na 64-bit sistemima značajno poboljšava sigurnost Malloc-a tako što **ograničava postavljanje lažnih chunk-ova na samo 1 od svakih 16 adresa**. To otežava napade, naročito u scenarijima gde napadač ima ograničenu kontrolu nad ulaznim vrednostima, čineći exploit-e složenijim i teže izvodljivim.

- **Fastbin Attack on `__malloc_hook`**

Novi zahtevi za poravnanjem u Malloc-u takođe onemogućavaju klasičan napad koji uključuje `__malloc_hook`. Ranije su napadači mogli manipulisati veličinama chunk-ova da bi **prepisali ovaj pokazivač funkcije** i dobili **izvršavanje koda**. Sada, strogi zahtev za poravnanjem osigurava da takve manipulacije više nisu izvedive, zatvarajući uobičajen put za eksploataciju i povećavajući ukupnu sigurnost.

> **Note:** Since glibc **2.34** the legacy hooks (`__malloc_hook`, `__free_hook`, etc.) are removed from the exported ABI. Modern exploits now target other writable function pointers (e.g. tcache per-thread struct, vtable-style callbacks) or rely on `setcontext`, `_IO_list_all` primitives, etc.

## Pointer Mangling na fastbins i tcache

**Pointer Mangling** je sigurnosno poboljšanje koje se koristi za zaštitu **fastbin i tcache Fd pointers** tokom operacija upravljanja memorijom. Ova tehnika pomaže u sprečavanju određenih tipova memoriјskih eksploatacija, posebno onih koje ne zahtevaju leak-ovane informacije iz memorije ili koje manipulišu lokacijama u memoriji direktno relativno u odnosu na poznate pozicije (relativna **overwrites**).

Suština ove tehnike je formula za obfuskaciju:

**`New_Ptr = (L >> 12) XOR P`**

- **L** je **Storage Location** pokazivača.
- **P** je stvarni **fastbin/tcache Fd Pointer**.

Razlog za bit-shift lokacije skladištenja (L) za 12 bita udesno pre XOR operacije je kritičan. Ova manipulacija adresira ranjivost koja proizilazi iz determinističke prirode 12 najmanje značajnih bitova memorijskih adresa, koji su obično predvidivi zbog ograničenja arhitekture sistema. Pomeranjem bitova, predvidivi deo se izbacuje iz jednačine, povećavajući nasumičnost novog, zamanglovanog pointera i time štiteći od eksploata koji se oslanjaju na predvidljivost tih bitova.

Ovaj zamanglovani pointer koristi postojeću nasumičnost koju pruža **Address Space Layout Randomization (ASLR)**, koja randomizuje adrese koje programi koriste kako bi otežala napadačima da predvide raspored memorije procesa.

Razmanglovanje pointera kako bi se dobila originalna adresa uključuje upotrebu iste XOR operacije. Ovde se zamanglovani pointer tretira kao P u formuli, i kada se XOR-uje sa nepromenjenom lokacijom skladištenja (L), dobija se originalni pointer. Ova simetrija u manglovanju i razmanglovanju osigurava da sistem može efikasno kodirati i dekodirati pointere bez značajnog overhead-a, dok značajno povećava zaštitu protiv napada koji manipulišu pokazivačima u memoriji.

### Bezbednosne koristi

Pointer mangling ima za cilj da **spreči delimična i potpuna prepisivanja pointera u heap-u**, što je značajno poboljšanje bezbednosti. Ova funkcija utiče na tehnike eksploatacije na nekoliko načina:

1. **Prevention of Bye Byte Relative Overwrites**: Ranije su napadači mogli promeniti deo pointera da bi **preusmerili heap chunk-ove na druge lokacije bez poznavanja tačnih adresa**, tehnika vidljiva u leakless exploit-u **House of Roman**. Sa pointer mangling-om, takva relativna overwrites **bez heap leaka sada zahtevaju brute forcing**, što drastično smanjuje verovatnoću njihovog uspeha.
2. **Increased Difficulty of Tcache Bin/Fastbin Attacks**: Uobičajeni napadi koji prepisuju pokazivače funkcija (kao što je `__malloc_hook`) manipulacijom fastbin ili tcache unosa su otežani. Na primer, napad može uključivati leak-ovanje LibC adrese, oslobađanje chunka u tcache bin, i zatim prepisivanje Fd pointera da ga preusmeri na `__malloc_hook` radi proizvoljnog izvršavanja koda. Sa pointer mangling-om, ti pointeri moraju biti ispravno manglovani, **što zahteva heap leak za tačnu manipulaciju**, čime se povećava prepreka za eksploataciju.
3. **Requirement for Heap Leaks in Non-Heap Locations**: Kreiranje lažnog chunka u non-heap oblastima (kao što su stack, .bss sekcija, ili PLT/GOT) sada takođe **zahteva heap leak** zbog potrebe za pointer mangling-om. Ovo proširuje kompleksnost eksploatacije tih oblasti, slično zahtevu za manipulaciju LibC adresa.
4. **Leaking Heap Addresses Becomes More Challenging**: Pointer mangling ograničava korisnost Fd pointera u fastbin i tcache bin-ovima kao izvora za heap address leak-ove. Međutim, pointeri u unsorted, small, i large bin-ovima ostaju nemanglovani, pa su i dalje upotrebljivi za leak-ovanje adresa. Ova promena tera napadače da istražuju te bine za eksploatabilne informacije, iako neke tehnike i dalje mogu omogućiti razmanglovanje pointera pre leak-a, ali uz ograničenja.

### **Safe-Linking Bypass (page-aligned leak scenario)**
```c
// leaked_fd is the mangled Fd read from the chunk on the same page
uintptr_t l = (uintptr_t)&chunk->fd;           // storage location
uintptr_t original = (leaked_fd ^ (l >> 12));  // demangle
```
Ovo vraća Fd i omogućava klasično tcache/fastbin poisoning. Ako se chunks nalaze na različitim stranicama, brute-forcing 12-bit page offset-a (0x1000 mogućnosti) često je izvodljivo kada su obrasci alokacija deterministički ili kada su padovi aplikacije prihvatljivi (npr. CTF-style exploits).

### **Demanglovanje pokazivača uz Heap leak**

> [!CAUTION]
> Za bolje objašnjenje procesa [**check the original post from here**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Pregled algoritma

Formula koja se koristi za mangling i demangling pokazivača je:

**`New_Ptr = (L >> 12) XOR P`**

Gde je **L** lokacija skladištenja, a **P** Fd pointer. Kada se **L** pomeri udesno za 12 bita, otkriva najznačajnije bitove **P**, zbog prirode **XOR**, koji daje 0 kada se bitovi XOR-uju sa samim sobom.

Ključni koraci u algoritmu:

1. **Initial Leak of the Most Significant Bits:** XOR-ovanjem pomerenog **L** sa **P** efektivno se dobijaju gornjih 12 bita **P** jer će pomereni deo **L** biti nula, ostavljajući odgovarajuće bitove **P** nepromenjene.
2. **Recovery of Pointer Bits:** Pošto je **XOR** reverzibilan, poznavanje rezultata i jednog od operanada omogućava izračunavanje drugog operanda. Ova osobina se koristi da se dedukuju ostali bitovi **P** sukcesivnim XOR-ovanjem poznatih skupova bitova sa delovima manglovanog pokazivača.
3. **Iterative Demangling:** Proces se ponavlja, svaki put koristeći novootkrivene bitove **P** iz prethodnog koraka da dekodira naredni segment manglovanog pokazivača, sve dok svi bitovi ne budu obnovljeni.
4. **Handling Deterministic Bits:** Poslednjih 12 bita **L** se gube zbog shift-a, ali su deterministički i mogu se rekonstruisati nakon procesa.

Implementaciju ovog algoritma možete pronaći ovde: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer Guard je exploit mitigacija u glibc koja štiti uskladištene function pointers, naročito one registrovane pozivima biblioteke kao što je `atexit()`. Ova zaštita uključuje raspoređivanje pokazivača tako što se XOR-uju sa tajnom koja je smeštena u thread data (`fs:0x30`) i primenjuje bitwise rotacija. Mehanizam ima za cilj da spreči napadače da preuzmu kontrolu toka izvršavanja prepisivanjem function pointers.

### **Bypassing Pointer Guard with a leak**

1. **Understanding Pointer Guard Operations:** Scrambling (mangling) pokazivača se radi pomoću `PTR_MANGLE` makroa koji XOR-uje pokazivač sa 64-bitnom tajnom i zatim vrši left rotation od 0x11 bita. Reverzna operacija za vraćanje originalnog pokazivača obavlja se pomoću `PTR_DEMANGLE`.
2. **Attack Strategy:** Napad se zasniva na known-plaintext pristupu, gde napadač treba da zna i originalnu i manglovanu verziju pokazivača da bi izveo dedukciju tajne korišćene za mangling.
3. **Exploiting Known Plaintexts:**
- **Identifying Fixed Function Pointers:** Pregledom glibc izvornog koda ili inicijalizovanih tabela function pointer-a (kao što je `__libc_pthread_functions`), napadač može naći predvidljive function pointers.
- **Computing the Secret:** Koristeći poznat function pointer kao što je `__pthread_attr_destroy` i njegovu manglovanu verziju iz tabele, tajna se može izračunati reverznom rotacijom (right rotation) manglovanog pokazivača i zatim XOR-ovanjem sa adresom funkcije.
4. **Alternative Plaintexts:** Napadač može takođe eksperimentisati sa manglovanjem pokazivača poznatih vrednosti kao što su 0 ili -1 da vidi da li to proizvodi prepoznatljive obrasce u memoriji, što potencijalno otkriva tajnu kada se ti obrasci nađu u memory dump-ovima.
5. **Practical Application:** Nakon izračunavanja tajne, napadač može manipulisati pokazivačima na kontrolisan način, praktično zaobilazeći Pointer Guard zaštitu u multithreaded aplikaciji uz poznavanje libc base address i mogućnost čitanja proizvoljnih memorijskih lokacija.

## GLIBC Tunables & Recent Loader Bugs

Dynamic loader parsira `GLIBC_TUNABLES` pre pokretanja programa. Pogrešno parsiranje ovde direktno utiče na **libc** pre nego što većina mitigacija stupi na snagu. Bug iz 2023. poznat kao "Looney Tunables" (CVE-2023-4911) je primer: predugačak `GLIBC_TUNABLES` vrednost prelivava interne bafer-e u `ld.so`, omogućavajući **privilege escalation** na mnogim distro-ima kada se kombinuje sa SUID binarnim fajlovima. Eksploatacija zahteva samo kreiranje okruženja i višestruko pokretanje ciljne binarke; pointer guard ili safe-linking ne sprečavaju ovo jer korupcija nastaje u loader-u pre podešavanja heap-a.

## References

- [Safe-Linking bypass explanation (shellphish/how2heap)](https://deepwiki.com/shellphish/how2heap/5.2-safe-linking-bypass)
- [Looney Tunables (CVE-2023-4911) write-up](https://www.wiz.io/vulnerability-database/cve/cve-2023-4911)

{{#include ../../banners/hacktricks-training.md}}
