# Libc Protections

{{#include ../../banners/hacktricks-training.md}}

## Chunk Alignment Enforcement

**Malloc** alokuje pamięć w **grupach po 8 bajtów (32-bit) lub 16 bajtów (64-bit)**. Oznacza to, że końce chunków w systemach 32-bit powinny być wyrównane do **0x8**, a w systemach 64-bit do **0x0**. Funkcja zabezpieczająca sprawdza, czy każdy chunk **jest poprawnie wyrównany** w tych konkretnych lokalizacjach przed użyciem wskaźnika z bin.

### Security Benefits

Wymuszanie wyrównania chunków w systemach 64-bit znacząco zwiększa bezpieczeństwo Malloca przez **ograniczenie możliwości umieszczania fałszywych chunków do zaledwie 1 na każde 16 adresów**. Utrudnia to działania exploitacyjne, szczególnie w scenariuszach, gdzie użytkownik ma ograniczoną kontrolę nad wartościami wejściowymi, co sprawia, że ataki stają się bardziej skomplikowane i trudniejsze do przeprowadzenia skutecznie.

- **Fastbin Attack on `__malloc_hook`**

Nowe zasady wyrównania w Malloc dodatkowo niweczą klasyczny atak związany z `__malloc_hook`. Wcześniej atakujący mogli manipulować rozmiarami chunków, aby **nadpisać ten wskaźnik funkcji** i uzyskać **wykonanie kodu**. Teraz ścisły wymóg wyrównania sprawia, że takie manipulacje nie są już możliwe, zamykając powszechną drogę eksploatacji i zwiększając ogólne bezpieczeństwo.

> **Note:** Since glibc **2.34** the legacy hooks (`__malloc_hook`, `__free_hook`, etc.) are removed from the exported ABI. Modern exploits now target other writable function pointers (e.g. tcache per-thread struct, vtable-style callbacks) or rely on `setcontext`, `_IO_list_all` primitives, etc.

## Pointer Mangling on fastbins and tcache

**Pointer Mangling** to ulepszenie bezpieczeństwa używane do ochrony **fastbin and tcache Fd pointers** w operacjach zarządzania pamięcią. Technika ta zapobiega pewnym typom taktyk exploitacyjnych, szczególnie tym, które nie wymagają leaked informacji z pamięci lub które manipulują lokalizacjami pamięci bezpośrednio względem znanych pozycji (względne **overwrites**).

Rdzeń tej techniki to formuła zaciemniająca:

**`New_Ptr = (L >> 12) XOR P`**

- **L** to **Storage Location** wskaźnika.
- **P** to faktyczny **fastbin/tcache Fd Pointer**.

Powód przesunięcia bitowego lokalizacji przechowywania (L) o 12 bitów w prawo przed operacją XOR jest kluczowy. Ta manipulacja rozwiązuje podatność wynikającą z deterministycznego charakteru najmniej znaczących 12 bitów adresów pamięci, które zazwyczaj są przewidywalne ze względu na ograniczenia architektury systemu. Przesuwając bity, przewidywalna część jest usuwana z równania, zwiększając losowość nowego, zagmatwanego wskaźnika, a tym samym chroniąc przed exploitami opartymi na przewidywalności tych bitów.

Ten zagmatwany wskaźnik wykorzystuje istniejącą losowość zapewnianą przez **Address Space Layout Randomization (ASLR)**, która losuje adresy używane przez programy, utrudniając atakującym przewidzenie układu pamięci procesu.

Demangling wskaźnika w celu odzyskania oryginalnego adresu polega na użyciu tej samej operacji XOR. W takim przypadku zagmatwany wskaźnik traktowany jest jako P w formule i po XOR z niezmienioną lokalizacją przechowywania (L) otrzymuje się ujawnienie oryginalnego wskaźnika. Ta symetria w manglingu i demanglingu zapewnia systemowi efektywne kodowanie i dekodowanie wskaźników bez znaczącego narzutu, jednocześnie znacząco zwiększając bezpieczeństwo przed atakami manipulującymi wskaźnikami pamięci.

### Security Benefits

Pointer mangling ma na celu **zapobieganie częściowym i pełnym nadpisaniom wskaźników w heap** zarządzaniu pamięcią, co stanowi istotne wzmocnienie bezpieczeństwa. Funkcja ta wpływa na techniki exploitacyjne na kilka sposobów:

1. **Zapobieganie Bye Byte Relative Overwrites**: Wcześniej atakujący mogli zmienić część wskaźnika, aby **przekierować chunki heap do innych lokalizacji bez znajomości dokładnych adresów**, technika widoczna w leakless **House of Roman**. Z pointer mangling, takie względne nadpisania **bez heap leak teraz wymagają brute forcingu**, co drastycznie zmniejsza ich szansę powodzenia.
2. **Zwiększona trudność ataków na tcache bin/Fastbin**: Powszechne ataki polegające na nadpisywaniu wskaźników funkcji (jak `__malloc_hook`) przez manipulację wpisami fastbin lub tcache są utrudnione. Na przykład atak może polegać na odczytaniu adresu LibC, zwolnieniu chunka do binu tcache, a następnie nadpisaniu wskaźnika Fd, by przekierować go do `__malloc_hook` w celu arbitralnego wykonania kodu. Z pointer mangling, te wskaźniki muszą być poprawnie zmanglowane, **co wymaga heap leak dla dokładnej manipulacji**, podnosząc tym samym barierę eksploatacji.
3. **Wymóg heap leaks przy tworzeniu fałszywych chunków w lokalizacjach spoza heap**: Tworzenie fałszywego chunka w obszarach nie-heap (jak stack, sekcja .bss, lub PLT/GOT) teraz również **wymaga heap leak** z powodu potrzeby pointer mangling. To rozszerza złożoność eksploatacji tych obszarów, podobnie jak wymóg manipulacji adresami LibC.
4. **Ujawnianie adresów heap staje się trudniejsze**: Pointer mangling ogranicza przydatność wskaźników Fd w fastbin i tcache jako źródeł leaków adresów heap. Jednak wskaźniki w unsorted, small i large bins pozostają niezmanglowane, więc nadal mogą być użyteczne do ujawniania adresów. Ta zmiana skłania atakujących do poszukiwania informacji w tych binach, choć niektóre techniki mogą wciąż pozwalać na demangling wskaźników przed leak, choć z pewnymi ograniczeniami.

### **Safe-Linking Bypass (page-aligned leak scenario)**

Nawet z włączonym safe-linking (glibc ≥ 2.32), jeśli możesz wyciekować zmanglowany wskaźnik i zarówno skorygowany chunk jak i chunk ofiary znajdują się na tej samej stronie 4KB, oryginalny wskaźnik można odzyskać mając jedynie offset strony:
```c
// leaked_fd is the mangled Fd read from the chunk on the same page
uintptr_t l = (uintptr_t)&chunk->fd;           // storage location
uintptr_t original = (leaked_fd ^ (l >> 12));  // demangle
```
This restores the Fd and permits classic tcache/fastbin poisoning. If the chunks sit on different pages, brute-forcing the 12-bit page offset (0x1000 possibilities) is often feasible when allocation patterns are deterministic or when crashes are acceptable (e.g., CTF-style exploits).

### **Demangling Pointers with a Heap Leak**

> [!CAUTION]
> Dla lepszego wyjaśnienia procesu [**check the original post from here**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Algorithm Overview

The formula used for mangling and demangling pointers is:

**`New_Ptr = (L >> 12) XOR P`**

Where **L** is the storage location and **P** is the Fd pointer. When **L** is shifted right by 12 bits, it exposes the most significant bits of **P**, due to the nature of **XOR**, which outputs 0 when bits are XORed with themselves.

**Key Steps in the Algorithm:**

1. **Initial Leak of the Most Significant Bits:** Poprzez XORowanie przesuniętego **L** z **P** otrzymuje się w praktyce górne 12 bitów **P**, ponieważ przesunięta część **L** będzie zerowa, pozostawiając odpowiadające bity **P** bez zmian.
2. **Recovery of Pointer Bits:** Ponieważ XOR jest odwracalny, znając wynik i jeden z operandów można obliczyć drugi operand. Ta właściwość jest wykorzystywana do wyprowadzenia pełnego zestawu bitów dla **P** przez kolejno XORowanie znanych zestawów bitów z częściami zmanglowanego wskaźnika.
3. **Iterative Demangling:** Proces jest powtarzany iteracyjnie — za każdym razem używa się nowo odkrytych bitów **P** z poprzedniego kroku, aby odszyfrować następny segment zmanglowanego wskaźnika, aż wszystkie bity zostaną odzyskane.
4. **Handling Deterministic Bits:** Ostateczne 12 bitów **L** ginie z powodu przesunięcia, ale są deterministyczne i można je zrekonstruować po procesie.

You can find an implementation of this algorithm here: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer guard is an exploit mitigation technique used in glibc to protect stored function pointers, particularly those registered by library calls such as `atexit()`. This protection involves scrambling the pointers by XORing them with a secret stored in the thread data (`fs:0x30`) and applying a bitwise rotation. This mechanism aims to prevent attackers from hijacking control flow by overwriting function pointers.

### **Bypassing Pointer Guard with a leak**

1. **Understanding Pointer Guard Operations:** The scrambling (mangling) of pointers is done using the `PTR_MANGLE` macro which XORs the pointer with a 64-bit secret and then performs a left rotation of 0x11 bits. The reverse operation for recovering the original pointer is handled by `PTR_DEMANGLE`.
2. **Attack Strategy:** The attack is based on a known-plaintext approach, where the attacker needs to know both the original and the mangled versions of a pointer to deduce the secret used for mangling.
3. **Exploiting Known Plaintexts:**
- **Identifying Fixed Function Pointers:** By examining glibc source code or initialized function pointer tables (like `__libc_pthread_functions`), an attacker can find predictable function pointers.
- **Computing the Secret:** Using a known function pointer such as `__pthread_attr_destroy` and its mangled version from the function pointer table, the secret can be calculated by reverse rotating (right rotation) the mangled pointer and then XORing it with the address of the function.
4. **Alternative Plaintexts:** The attacker can also experiment with mangling pointers with known values like 0 or -1 to see if these produce identifiable patterns in memory, potentially revealing the secret when these patterns are found in memory dumps.
5. **Practical Application:** After computing the secret, an attacker can manipulate pointers in a controlled manner, essentially bypassing the Pointer Guard protection in a multithreaded application with knowledge of the libc base address and an ability to read arbitrary memory locations.

## GLIBC Tunables & Recent Loader Bugs

The dynamic loader parses `GLIBC_TUNABLES` before program startup. Mis-parsing bugs here directly affect **libc** before most mitigations kick in. The 2023 "Looney Tunables" bug (CVE-2023-4911) is an example: an overlong `GLIBC_TUNABLES` value overflows internal buffers in `ld.so`, enabling **privilege escalation** on many distros when combined with SUID binaries. Exploitation requires only crafting the environment and repeatedly invoking the target binary; pointer guard or safe-linking do not prevent it because corruption happens in the loader prior to heap setup.

## References

- [Safe-Linking bypass explanation (shellphish/how2heap)](https://deepwiki.com/shellphish/how2heap/5.2-safe-linking-bypass)
- [Looney Tunables (CVE-2023-4911) write-up](https://www.wiz.io/vulnerability-database/cve/cve-2023-4911)

{{#include ../../banners/hacktricks-training.md}}
