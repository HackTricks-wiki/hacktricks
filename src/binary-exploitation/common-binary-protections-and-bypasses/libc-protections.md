# Libc Protections

{{#include ../../banners/hacktricks-training.md}}

## Chunk Alignment Enforcement

**Malloc** 在 **8字节（32位）或16字节（64位）分组**中分配内存。这意味着在32位系统中，块的结束应与 **0x8** 对齐，而在64位系统中应与 **0x0** 对齐。安全特性检查每个块在使用来自 bin 的指针之前是否在这些特定位置 **正确对齐**。

### Security Benefits

在64位系统中强制块对齐显著增强了 Malloc 的安全性，通过 **将假块的放置限制为每16个地址中的1个**。这使得利用攻击变得更加复杂，尤其是在用户对输入值的控制有限的情况下，使攻击更复杂且更难成功执行。

- **Fastbin Attack on \_\_malloc_hook**

Malloc 中的新对齐规则也阻止了涉及 `__malloc_hook` 的经典攻击。之前，攻击者可以操纵块大小以 **覆盖此函数指针** 并获得 **代码执行**。现在，严格的对齐要求确保此类操纵不再可行，关闭了一个常见的利用途径，增强了整体安全性。

## Pointer Mangling on fastbins and tcache

**Pointer Mangling** 是一种安全增强，用于保护内存管理操作中的 **fastbin 和 tcache Fd 指针**。该技术有助于防止某些类型的内存利用战术，特别是那些不需要泄漏内存信息或直接相对于已知位置操纵内存位置（相对 **覆盖**）的战术。

该技术的核心是一个混淆公式：

**`New_Ptr = (L >> 12) XOR P`**

- **L** 是指针的 **存储位置**。
- **P** 是实际的 **fastbin/tcache Fd 指针**。

在 XOR 操作之前将存储位置 (L) 向右移动12位的位移是关键。这种操纵解决了内存地址最低有效12位的确定性特性所固有的漏洞，这些位通常由于系统架构限制而可预测。通过移动位，预测部分被移出方程，从而增强了新混淆指针的随机性，从而保护免受依赖这些位可预测性的利用。

这个混淆指针利用了 **地址空间布局随机化（ASLR）** 提供的现有随机性，ASLR 随机化程序使用的地址，使攻击者难以预测进程的内存布局。

**Demangling** 指针以检索原始地址涉及使用相同的 XOR 操作。在这里，混淆指针被视为公式中的 P，当与未更改的存储位置 (L) 进行 XOR 时，结果是原始指针被揭示。这种混淆和解混淆的对称性确保系统能够高效地编码和解码指针，而不会产生显著的开销，同时大幅提高了对操纵内存指针攻击的安全性。

### Security Benefits

指针混淆旨在 **防止堆管理中的部分和完整指针覆盖**，这是安全性的重要增强。此功能以多种方式影响利用技术：

1. **防止字节相对覆盖**：之前，攻击者可以更改指针的一部分以 **在不知道确切地址的情况下将堆块重定向到不同位置**，这种技术在无泄漏的 **House of Roman** 利用中显而易见。通过指针混淆，此类相对覆盖 **在没有堆泄漏的情况下现在需要暴力破解**，大幅降低了成功的可能性。
2. **增加 Tcache Bin/Fastbin 攻击的难度**：通过操纵 fastbin 或 tcache 条目来覆盖函数指针（如 `__malloc_hook`）的常见攻击受到阻碍。例如，一种攻击可能涉及泄漏 LibC 地址，将一个块释放到 tcache bin 中，然后覆盖 Fd 指针以将其重定向到 `__malloc_hook` 以进行任意代码执行。通过指针混淆，这些指针必须正确混淆，**需要堆泄漏以进行准确操纵**，从而提高了利用的门槛。
3. **在非堆位置需要堆泄漏**：在非堆区域（如栈、.bss 段或 PLT/GOT）创建假块现在也 **需要堆泄漏**，因为需要指针混淆。这增加了利用这些区域的复杂性，类似于操纵 LibC 地址的要求。
4. **泄漏堆地址变得更加困难**：指针混淆限制了 Fd 指针在 fastbin 和 tcache bins 中作为堆地址泄漏源的有效性。然而，未排序、小型和大型 bins 中的指针仍然未混淆，因此仍可用于泄漏地址。这一变化迫使攻击者探索这些 bins 以获取可利用的信息，尽管某些技术仍可能允许在泄漏之前解混淆指针，但有一定的限制。

### **Demangling Pointers with a Heap Leak**

> [!CAUTION]
> For a better explanation of the process [**check the original post from here**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Algorithm Overview

用于混淆和解混淆指针的公式是：&#x20;

**`New_Ptr = (L >> 12) XOR P`**

其中 **L** 是存储位置，**P** 是 Fd 指针。当 **L** 向右移动12位时，它暴露了 **P** 的最高有效位，由于 **XOR** 的特性，当位与自身进行 XOR 时输出为0。

**Key Steps in the Algorithm:**

1. **初始泄漏最高有效位**：通过将移位的 **L** 与 **P** 进行 XOR，您有效地获得了 **P** 的前12位，因为移位部分的 **L** 将为零，留下 **P** 的相应位不变。
2. **恢复指针位**：由于 XOR 是可逆的，知道结果和其中一个操作数可以让您计算另一个操作数。这个特性用于通过将已知的位集与混淆指针的部分进行逐步 XOR 来推导出 **P** 的整个位集。
3. **迭代解混淆**：该过程重复进行，每次使用从上一步中发现的 **P** 的新位来解码混淆指针的下一个部分，直到所有位都被恢复。
4. **处理确定性位**：由于移位，**L** 的最后12位丢失，但它们是确定性的，可以在后处理时重建。

您可以在这里找到该算法的实现：[https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer guard 是一种在 glibc 中使用的利用缓解技术，用于保护存储的函数指针，特别是那些由库调用（如 `atexit()`）注册的指针。该保护涉及通过将指针与存储在线程数据中的秘密（`fs:0x30`）进行 XOR 并应用位旋转来打乱指针。该机制旨在防止攻击者通过覆盖函数指针来劫持控制流。

### **Bypassing Pointer Guard with a leak**

1. **理解 Pointer Guard 操作**：指针的打乱（混淆）是使用 `PTR_MANGLE` 宏完成的，该宏将指针与64位秘密进行 XOR，然后执行0x11位的左旋转。恢复原始指针的反操作由 `PTR_DEMANGLE` 处理。
2. **攻击策略**：该攻击基于已知明文的方法，攻击者需要知道指针的原始版本和混淆版本，以推导出用于混淆的秘密。
3. **利用已知明文**：
- **识别固定函数指针**：通过检查 glibc 源代码或初始化的函数指针表（如 `__libc_pthread_functions`），攻击者可以找到可预测的函数指针。
- **计算秘密**：使用已知的函数指针（如 `__pthread_attr_destroy`）及其来自函数指针表的混淆版本，可以通过反向旋转（右旋转）混淆指针，然后与函数的地址进行 XOR 来计算秘密。
4. **替代明文**：攻击者还可以尝试使用已知值（如0或-1）混淆指针，以查看这些是否在内存中产生可识别的模式，当这些模式在内存转储中找到时，可能会揭示秘密。
5. **实际应用**：在计算出秘密后，攻击者可以以受控的方式操纵指针，从而在了解 libc 基地址和能够读取任意内存位置的情况下，基本上绕过多线程应用中的 Pointer Guard 保护。

## References

- [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
- [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)

{{#include ../../banners/hacktricks-training.md}}
