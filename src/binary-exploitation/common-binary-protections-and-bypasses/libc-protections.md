# Libc Beskermings

{{#include ../../banners/hacktricks-training.md}}

## Uitlyningsafdwinging van chunks

**Malloc** allokeer geheue in **8-byte (32-bit) of 16-byte (64-bit) groepe**. Dit beteken dat die einde van chunks in 32-bit stelsels by **0x8** moet uitlyn, en in 64-bit stelsels by **0x0**. Die sekuriteitsfunksie kontroleer dat elke chunk by hierdie spesifieke plekke **korrek uitgelê** is voordat ’n pointer uit ’n bin gebruik word.

### Sekuriteitsvoordele

Die afdwinging van chunk-uitlyning in 64-bit stelsels verbeter Malloc se veiligheid aansienlik deur die plasing van fake chunks te beperk tot slegs 1 uit elke 16 adresse. Dit bemoeilik eksploitasiepogings, veral in scenario’s waar die aanvaller beperkte beheer oor invoerwaardes het, wat aanvalle meer kompleks en moeiliker maak om suksesvol uit te voer.

- **Fastbin Attack on `__malloc_hook`**

Die nuwe uitlyningsreëls in Malloc keer ook ’n klassieke aanval wat `__malloc_hook` betrek. Voorheen kon aanvallers chunk-groottes manipuleer om hierdie funksie-wyser te oor-skryf en sodoende kode-uitvoering te kry. Nou verseker die streng uitlyningsvereiste dat sulke manipulasies nie meer lewensvatbaar is nie, wat ’n algemene eksploitasieroute toesluit en die algehele sekuriteit verhoog.

> **Note:** Since glibc **2.34** the legacy hooks (`__malloc_hook`, `__free_hook`, etc.) are removed from the exported ABI. Modern exploits now target other writable function pointers (e.g. tcache per-thread struct, vtable-style callbacks) or rely on `setcontext`, `_IO_list_all` primitives, etc.

## Pointer Mangling on fastbins and tcache

**Pointer Mangling** is ’n sekuriteitsverbetering wat gebruik word om **fastbin en tcache Fd pointers** in geheuebestuur te beskerm. Hierdie tegniek help om sekere soorte geheue-eksploitasietegnieke te voorkom, spesifiek dié wat nie ’n leaked memory-inligting benodig nie of wat geheue-lokasies direk relatief tot bekende posisies manipuleer (relatiewe **overwrites**).

Die kern van hierdie tegniek is ’n verwarringsformule:

**`New_Ptr = (L >> 12) XOR P`**

- **L** is die **Storage Location** van die pointer.
- **P** is die werklike **fastbin/tcache Fd Pointer**.

Die rede vir die bitverskuiwing van die stoorplek (L) met 12 bitrate na regs voordat die XOR-operasie toegepas word, is kritiek. Hierdie manipulering spreek ’n kwesbaarheid aan wat ingebed is in die deterministiese aard van die minste beduidende 12 bits van geheueadresse, wat tipies voorspelbaar is as gevolg van stelselargitektuurbeperkings. Deur die bits te verskuif, word die voorspelbare gedeelte uit die vergelyking verwyder, wat die willekeur van die nuwe, gemanglede pointer verhoog en sodoende beskerming bied teen eksploite wat op die voorspelbaarheid van hierdie bits staatmaak.

Hierdie gemanglede pointer benut die bestaande willekeur wat deur **Address Space Layout Randomization (ASLR)** verskaf word, wat adresse wat deur programme gebruik word randomiseer om dit moeilik te maak vir aanvallers om die geheue-ontwerp van ’n proses te voorspel.

Die **Demangling** van die pointer om die oorspronklike adres te herwin, behels die gebruik van dieselfde XOR-operasie. Hier word die gemanglede pointer as P in die formule behandel, en wanneer dit met die onveranderde stoorplek (L) XOR word, word die oorspronklike pointer blootgelê. Hierdie simmetrie in mangling en demangling verseker dat die stelsel pointers effektief kan enkodeer en dekodeer sonder noemenswaardige oorhoofse koste, terwyl dit die veiligheid teen aanvalle wat geheue-pointers manipuleer aansienlik verhoog.

### Sekuriteitsvoordele

Pointer mangling beoog om gedeeltelike en volledige pointer-overwrites in heap-bestuur te voorkom, ’n belangrike verbetering in sekuriteit. Hierdie kenmerk beïnvloed eksploitasietegnieke op verskeie maniere:

1. Voorkoming van Byte-by-Byte Relative Overwrites: Voorheen kon aanvallers ’n deel van ’n pointer verander om heap-chunks na verskillende lokasies te herlei sonder om presiese adresse te ken, ’n tegniek wat in die leakless **House of Roman** eksploit sigbaar is. Met pointer mangling vereis sulke relatiewe overwrites **sonder ’n heap leak** nou brute-forcing, wat hul kans op sukses drasties verminder.
2. Verhoogde Moeilikheid van Tcache Bin/Fastbin Attacks: Algemene aanvalle wat funksie-wysers (soos `__malloc_hook`) oor-skryf deur fastbin- of tcache_entries te manipuleer, word belemmer. Byvoorbeeld, ’n aanval kan ’n LibC adres leegmaak, ’n chunk in die tcache-bin vrylaat en dan die Fd-pointer oor-skryf om dit na `__malloc_hook` te herlei vir arbitraire code execution. Met pointer mangling moet hierdie pointers korrek gemangle wees, wat ’n heap leak vereis vir akkurate manipulasie, en sodoende die eksploitasieperd verhoog.
3. Vereiste vir heap leaks in nie-heap lokasies: Om ’n fake chunk in nie-heap areas te skep (soos die stack, .bss-segment, of PLT/GOT) vereis nou ook ’n heap leak as gevolg van die behoefte aan pointer mangling. Dit verhoog die kompleksiteit om hierdie areas te eksploiteer, soortgelyk aan die vereiste by die manipulasie van LibC adresse.
4. Leaking Heap Addresses Becomes More Challenging: Pointer mangling beperk die bruikbaarheid van Fd pointers in fastbin en tcache bins as bronne vir heap address leaks. Pointers in unsorted, small, en large bins bly egter ongemangeld en dus steeds bruikbaar om adresse te leaker. Hierdie skuif dwing aanvallers om hierdie bins te ondersoek vir eksploiteerbare inligting, alhoewel sommige tegnieke steeds toelaat dat pointers ontmangeld word voor ’n leak, maar met beperkings.

### **Safe-Linking Bypass (page-aligned leak scenario)**

Even with safe-linking enabled (glibc ≥ 2.32), if you can leak the mangled pointer and both the corrupted chunk and victim chunk share the same 4KB page, the original pointer can be recovered with just the page offset:
```c
// leaked_fd is the mangled Fd read from the chunk on the same page
uintptr_t l = (uintptr_t)&chunk->fd;           // storage location
uintptr_t original = (leaked_fd ^ (l >> 12));  // demangle
```
Dit herstel die Fd en maak klassieke tcache/fastbin poisoning moontlik. As die chunks op verskillende bladsye lê, is brute-forcing van die 12-bit bladsyverskuiwing (0x1000 moontlikhede) dikwels uitvoerbaar wanneer toekenningpatrone deterministies is of wanneer crashes aanvaarbaar is (bv., CTF-style exploits).

### **Demangling Pointers with a Heap Leak**

> [!CAUTION]
> Vir 'n beter verduideliking van die proses [**sien die oorspronklike pos hier**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Algoritme Oorsig

Die formule wat gebruik word vir mangling en demangling van aanwysers is:

**`New_Ptr = (L >> 12) XOR P`**

Waar **L** die stoorplek is en **P** die Fd pointer. Wanneer **L** 12 bis regs geskuif word, maak dit die mees beduidende bits van **P** sigbaar, as gevolg van die aard van **XOR**, wat 0 teruggee wanneer bits met hul eie XOR word.

**Sleutelstappe in die algoritme:**

1. **Initial Leak of the Most Significant Bits:** Deur die verskuifde **L** met **P** te XOR kry jy effektief die boonste 12 bits van **P** omdat die verskuifde deel van **L** nul sal wees, wat die ooreenstemmende bits van **P** onveranderd laat.
2. **Recovery of Pointer Bits:** Omdat XOR reversibel is, maak kennis van die resultaat en een van die operande dit moontlik om die ander operand te bereken. Hierdie eienskap word gebruik om die volledige stel bits vir **P** af te lei deur bekende bitstelle suksesiewelik met dele van die mangled pointer te XOR.
3. **Iterative Demangling:** Die proses word herhaal, elke keer gebruikend die pas ontdekte bits van **P** van die vorige stap om die volgende segment van die mangled pointer te dekodeer, totdat alle bits herstel is.
4. **Handling Deterministic Bits:** Die laaste 12 bits van **L** gaan verlore as gevolg van die skuif, maar hulle is deterministies en kan na die proses herkonstitueer word.

Jy kan 'n implementering van hierdie algoritme hier vind: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer Guard is 'n exploit mitigation tegniek wat in glibc gebruik word om gestoorde function pointers te beskerm, veral dié wat deur biblioteek-oproepe soos `atexit()` geregistreer is. Hierdie beskerming behels die scrambling van pointers deur hulle met 'n geheim wat in die thread data (`fs:0x30`) gestoor is te XOR en 'n bitwise rotasie toe te pas. Hierdie meganisme is daarop gemik om te verhoed dat aanvallers control flow kap deur function pointers te oorskryf.

### **Bypassing Pointer Guard with a leak**

1. **Understanding Pointer Guard Operations:** Die scrambling (mangling) van pointers word gedoen deur die `PTR_MANGLE` macro wat die pointer met 'n 64-bit geheim XOR en dan 'n linker-rotasie van 0x11 bits uitvoer. Die omgekeerde operasie om die oorspronklike pointer te herstel word deur `PTR_DEMANGLE` hanteer.
2. **Attack Strategy:** Die aanval is gebaseer op 'n known-plaintext benadering, waar die aanvaller beide die oorspronklike en die mangled weergawes van 'n pointer moet ken om die geheim wat vir mangling gebruik is af te lei.
3. **Exploiting Known Plaintexts:**
- **Identifying Fixed Function Pointers:** Deur die glibc bronkode of geïnitialiseerde function pointer tabelle (soos `__libc_pthread_functions`) te ondersoek, kan 'n aanvaller voorspelbare function pointers vind.
- **Computing the Secret:** Deur 'n bekende function pointer soos `__pthread_attr_destroy` en sy mangled weergawe uit die function pointer tabel te gebruik, kan die geheim bereken word deur die mangled pointer omgekeerd te roteer (regsrotasie) en dan met die adres van die funksie te XOR.
4. **Alternative Plaintexts:** Die aanvaller kan ook eksperimenteer deur pointers met bekende waardes soos 0 of -1 te mangle om te sien of dit identifiseerbare patrone in geheue produseer, wat moontlik die geheim kan openbaar wanneer hierdie patrone in geheue-dumps gevind word.
5. **Practical Application:** Nadat die geheim bereken is, kan 'n aanvaller pointers op 'n beheerlike wyse manipuleer, en in effek die Pointer Guard beskerming omseil in 'n multithreaded toepassing met kennis van die libc base adres en die vermoë om arbitrêre geheue-ligginge te lees.

## GLIBC Tunables & Recent Loader Bugs

Die dinamiese lader parse `GLIBC_TUNABLES` voor program-opstart. Mis-parsing-bugs hier raak **libc** direk voordat meeste mitigations in werking tree. Die 2023 "Looney Tunables" fout (CVE-2023-4911) is 'n voorbeeld: 'n oorlange `GLIBC_TUNABLES` waarde oorloop interne buffers in `ld.so`, wat **privilege escalation** op baie distros moontlik maak wanneer dit met SUID binaries gekombineer word. Exploitasie vereis slegs die vervaardiging van die omgewing en herhaaldelike aanroep van die teiken-binary; pointer guard of safe-linking voorkom dit nie omdat die korrupsie in die loader gebeur vóór heap-opstelling.

## References

- [Safe-Linking bypass explanation (shellphish/how2heap)](https://deepwiki.com/shellphish/how2heap/5.2-safe-linking-bypass)
- [Looney Tunables (CVE-2023-4911) write-up](https://www.wiz.io/vulnerability-database/cve/cve-2023-4911)

{{#include ../../banners/hacktricks-training.md}}
