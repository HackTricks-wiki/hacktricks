# Libc Protections

{{#include ../../banners/hacktricks-training.md}}

## Chunk Alignment Enforcement

**Malloc** alocira memoriju u **8-bajtnih (32-bitnih) ili 16-bajtnih (64-bitnih) grupama**. To znači da se kraj chunk-ova u 32-bitnim sistemima treba uskladiti sa **0x8**, a u 64-bitnim sistemima sa **0x0**. Bezbednosna funkcija proverava da li se svaki chunk **ispravno usklađuje** na ovim specifičnim mestima pre nego što koristi pokazivač iz bin-a.

### Security Benefits

Sprovođenje usklađivanja chunk-ova u 64-bitnim sistemima značajno poboljšava bezbednost Malloc-a tako što **ograničava postavljanje lažnih chunk-ova na samo 1 od svake 16 adresa**. To otežava napade, posebno u scenarijima gde korisnik ima ograničenu kontrolu nad ulaznim vrednostima, čineći napade složenijim i težim za uspešno izvršavanje.

- **Fastbin Attack on \_\_malloc_hook**

Nova pravila usklađivanja u Malloc-u takođe sprečavaju klasičan napad koji uključuje `__malloc_hook`. Prethodno su napadači mogli manipulisati veličinama chunk-ova da **prepišu ovu funkciju pokazivača** i dobiju **izvršenje koda**. Sada, strogi zahtev za usklađivanje osigurava da takve manipulacije više nisu moguće, zatvarajući uobičajenu rutu za eksploataciju i poboljšavajući ukupnu bezbednost.

## Pointer Mangling on fastbins and tcache

**Pointer Mangling** je bezbednosno poboljšanje koje se koristi za zaštitu **fastbin i tcache Fd pokazivača** u operacijama upravljanja memorijom. Ova tehnika pomaže u sprečavanju određenih vrsta taktika eksploatacije memorije, posebno onih koje ne zahtevaju informacije o propuštenoj memoriji ili koje direktno manipulišu memorijskim lokacijama u odnosu na poznate pozicije (relativni **overwrites**).

Osnova ove tehnike je formula za obfuscation:

**`New_Ptr = (L >> 12) XOR P`**

- **L** je **lokacija skladištenja** pokazivača.
- **P** je stvarni **fastbin/tcache Fd pokazivač**.

Razlog za pomeranje lokacije skladištenja (L) za 12 bita udesno pre XOR operacije je kritičan. Ova manipulacija se bavi ranjivošću inherentnom determinističkoj prirodi najmanje značajnih 12 bita memorijskih adresa, koje su obično predvidljive zbog ograničenja arhitekture sistema. Pomeraanjem bitova, predvidljivi deo se izbacuje iz jednačine, povećavajući nasumičnost novog, izmenjenog pokazivača i time štiteći od eksploatacija koje se oslanjaju na predvidljivost ovih bitova.

Ovaj izmenjeni pokazivač koristi postojeću nasumičnost koju pruža **Randomizacija rasporeda adresnog prostora (ASLR)**, koja randomizuje adrese koje koriste programi kako bi otežala napadačima da predviđaju raspored memorije procesa.

**Demangling** pokazivača za vraćanje originalne adrese uključuje korišćenje iste XOR operacije. Ovde se izmenjeni pokazivač tretira kao P u formuli, a kada se XOR-uje sa nepromenjenom lokacijom skladištenja (L), rezultira otkrivanjem originalnog pokazivača. Ova simetrija u izmeni i demanipulaciji osigurava da sistem može efikasno kodirati i dekodirati pokazivače bez značajnog preopterećenja, dok značajno povećava bezbednost protiv napada koji manipulišu pokazivačima memorije.

### Security Benefits

Cilj izmenjivanja pokazivača je da **spreči delimična i potpuna prepisivanja pokazivača u heap-u**, što je značajno poboljšanje u bezbednosti. Ova funkcija utiče na tehnike eksploatacije na nekoliko načina:

1. **Sprečavanje Bye Byte Relativnih Overwrites**: Prethodno su napadači mogli promeniti deo pokazivača da **preusmere heap chunk-ove na različite lokacije bez poznavanja tačnih adresa**, tehnika koja je očigledna u eksploataciji bez propuštanja **House of Roman**. Sa izmenjivanjem pokazivača, takvi relativni overwrites **bez propuštanja heap-a sada zahtevaju brute forcing**, drastično smanjujući verovatnoću uspeha.
2. **Povećana Težina Tcache Bin/Fastbin Napada**: Uobičajeni napadi koji prepisuju funkcijske pokazivače (poput `__malloc_hook`) manipulacijom fastbin ili tcache unosa su otežani. Na primer, napad bi mogao uključivati propuštanje LibC adrese, oslobađanje chunk-a u tcache bin, a zatim prepisivanje Fd pokazivača da ga preusmeri na `__malloc_hook` za proizvoljno izvršenje koda. Sa izmenjivanjem pokazivača, ovi pokazivači moraju biti ispravno izmenjeni, **što zahteva propuštanje heap-a za tačnu manipulaciju**, čime se povećava barijera za eksploataciju.
3. **Zahtev za Propuštanjem Heap-a u Ne-Heap Lokacijama**: Kreiranje lažnog chunk-a u ne-heap oblastima (poput steka, .bss sekcije ili PLT/GOT) sada takođe **zahteva propuštanje heap-a** zbog potrebe za izmenjivanjem pokazivača. Ovo produžava složenost eksploatacije ovih oblasti, slično zahtevu za manipulaciju LibC adresama.
4. **Propuštanje Heap Adresa Postaje Teže**: Izmenjivanje pokazivača ograničava korisnost Fd pokazivača u fastbin i tcache bin-ovima kao izvora za propuštanje heap adresa. Međutim, pokazivači u neuređenim, malim i velikim binovima ostaju neizmenjeni, pa su i dalje upotrebljivi za propuštanje adresa. Ova promena podstiče napadače da istražuju ove binove za eksploatabilne informacije, iako neke tehnike mogu i dalje omogućiti demanipulaciju pokazivača pre propuštanja, iako sa ograničenjima.

### **Demangling Pointers with a Heap Leak**

> [!CAUTION]
> Za bolje objašnjenje procesa [**proverite originalni post ovde**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Algorithm Overview

Formula koja se koristi za izmenjivanje i demanipulaciju pokazivača je:

**`New_Ptr = (L >> 12) XOR P`**

Gde je **L** lokacija skladištenja, a **P** je Fd pokazivač. Kada se **L** pomeri udesno za 12 bita, izlaže najznačajnije bitove **P**, zbog prirode **XOR**, koja daje 0 kada se bitovi XOR-uju sa samima sobom.

**Key Steps in the Algorithm:**

1. **Početno Propuštanje Najznačajnijih Bitova**: XOR-ovanjem pomerene **L** sa **P**, efikasno dobijate gornjih 12 bitova **P** jer će pomerena deo **L** biti nula, ostavljajući odgovarajuće bitove **P** nepromenjenim.
2. **Obnova Bitova Pokazivača**: Pošto je XOR reverzibilan, poznavanje rezultata i jednog od operanada omogućava vam da izračunate drugi operand. Ova osobina se koristi za dedukciju celog skupa bitova za **P** sukcesivnim XOR-ovanjem poznatih skupova bitova sa delovima izmenjenog pokazivača.
3. **Iterativna Demanipulacija**: Proces se ponavlja, svaki put koristeći novo otkrivene bitove **P** iz prethodnog koraka za dekodiranje sledećeg segmenta izmenjenog pokazivača, sve dok se svi bitovi ne obnove.
4. **Rukovanje Determinističkim Bitovima**: Poslednjih 12 bitova **L** se gubi zbog pomeranja, ali su deterministički i mogu se rekonstruisati nakon procesa.

Možete pronaći implementaciju ovog algoritma ovde: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer guard je tehnika mitigacije eksploatacije koja se koristi u glibc-u za zaštitu skladištenih funkcijskih pokazivača, posebno onih registrovanih pozivima biblioteka kao što je `atexit()`. Ova zaštita uključuje mešanje pokazivača XOR-ovanjem sa tajnom koja se čuva u podacima niti (`fs:0x30`) i primenom bitovne rotacije. Ovaj mehanizam ima za cilj da spreči napadače da preuzmu kontrolu nad tokom izvršavanja prepisivanjem funkcijskih pokazivača.

### **Bypassing Pointer Guard with a leak**

1. **Razumevanje Operacija Pointer Guard:** Mešanje (izmenjivanje) pokazivača se vrši korišćenjem makroa `PTR_MANGLE` koji XOR-uje pokazivač sa 64-bitnom tajnom i zatim vrši levo pomeranje od 0x11 bitova. Obrnuta operacija za vraćanje originalnog pokazivača se obavlja pomoću `PTR_DEMANGLE`.
2. **Strategija Napada:** Napad se zasniva na pristupu poznatom plain text-u, gde napadač treba da zna i originalne i izmenjene verzije pokazivača da bi dedukovao tajnu korišćenu za izmenjivanje.
3. **Eksploatacija Poznatih Plaintext-a:**
- **Identifikacija Fiksnih Funkcijskih Pokazivača:** Istražujući izvorni kod glibc-a ili inicijalizovane tabele funkcijskih pokazivača (poput `__libc_pthread_functions`), napadač može pronaći predvidljive funkcijske pokazivače.
- **Izračunavanje Tajne:** Koristeći poznati funkcijski pokazivač kao što je `__pthread_attr_destroy` i njegovu izmenjenu verziju iz tabele funkcijskih pokazivača, tajna se može izračunati obrnuto rotirajući (desno rotiranje) izmenjeni pokazivač i zatim XOR-ujući ga sa adresom funkcije.
4. **Alternativni Plaintext-i:** Napadač može takođe eksperimentisati sa izmenjivanjem pokazivača poznatim vrednostima kao što su 0 ili -1 da vidi da li ove proizvode prepoznatljive obrasce u memoriji, potencijalno otkrivajući tajnu kada se ovi obrasci pronađu u dump-ovima memorije.
5. **Praktična Primena:** Nakon izračunavanja tajne, napadač može manipulirati pokazivačima na kontrolisan način, suštinski zaobilazeći zaštitu Pointer Guard u višedretvenoj aplikaciji sa znanjem o osnovnoj adresi libc-a i sposobnošću čitanja proizvoljnih memorijskih lokacija.

## References

- [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
- [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)

{{#include ../../banners/hacktricks-training.md}}
