# Libc सुरक्षा

{{#include ../../banners/hacktricks-training.md}}

## Chunk संरेखण प्रवर्तन

**Malloc** मेमोरी को **8-byte (32-bit) or 16-byte (64-bit) groupings** में आवंटित करता है। इसका मतलब है कि 32-bit सिस्टम में chunks का अंत **0x8** पर align होना चाहिए, और 64-bit सिस्टम में **0x0** पर। सुरक्षा फ़ीचर यह जांचता है कि किसी bin से pointer उपयोग करने से पहले हर chunk इन विशिष्ट स्थानों पर **सही तरीके से align** है।

### सुरक्षा लाभ

64-bit सिस्टम में chunk alignment लागू करने से Malloc की सुरक्षा काफी बढ़ जाती है क्योंकि यह **नकली chunks को केवल हर 16 पते में से 1 पर रखने तक सीमित कर देता है**। इससे शोषण (exploitation) कठिन हो जाता है, खासकर उन परिदृश्यों में जहाँ उपयोगकर्ता के पास इनपुट मानों पर सीमित नियंत्रण होता है, जिससे हमले अधिक जटिल और सफलतापूर्वक निष्पादित करना कठिन हो जाते हैं।

- **Fastbin Attack on `__malloc_hook`**

Malloc में नए alignment नियम `__malloc_hook` से संबंधित एक क्लासिक attack को भी विफल करते हैं। पहले, attackers chunk sizes को बदलकर **इस फ़ंक्शन पॉइंटर को overwrite** कर सकते थे और **code execution** प्राप्त कर सकते थे। अब, कड़े alignment आवश्यकताओं के कारण ऐसे बदलाव संभव नहीं रहे, जिससे एक सामान्य शोषण मार्ग बंद हो गया और समग्र सुरक्षा बढ़ी।

> **ध्यान:** glibc **2.34** से लेगसी hooks (`__malloc_hook`, `__free_hook`, आदि) exported ABI से हटा दिए गए हैं। आधुनिक exploits अब अन्य writable function pointers (उदा. tcache per-thread struct, vtable-style callbacks) को target करते हैं या `setcontext`, `_IO_list_all` primitives आदि पर निर्भर करते हैं।

## fastbins और tcache पर Pointer Mangling

**Pointer Mangling** एक security enhancement है जो memory management ऑपरेशन्स में **fastbin और tcache Fd pointers** की सुरक्षा के लिए उपयोग होता है। यह तकनीक उन प्रकार के memory exploit तरीकों को रोकने में मदद करती है, विशेषतः उन तरीकों को जो leaked memory information की आवश्यकता नहीं लेते या जो memory स्थानों को सीधे known positions के सापेक्ष manipulate करते हैं (रिलेटिव **overwrites**)।

इस तकनीक का मूल एक obfuscation formula है:

**`New_Ptr = (L >> 12) XOR P`**

- **L** pointer का **Storage Location** है।
- **P** असल **fastbin/tcache Fd Pointer** है।

Storage location (L) को XOR ऑपरेशन से पहले 12 बिट दाईं ओर shift करने का कारण महत्वपूर्ण है। यह परिवर्तन उस vulnerability को संबोधित करता है जो memory addresses के least significant 12 bits की deterministic प्रकृति में निहित होती है, जो अक्सर system architecture constraints की वजह से predictable रहती है। बिट्स को shift करके, predictable हिस्सा समीकरण से हटा दिया जाता है, जिससे नए mangled pointer की randomness बढ़ती है और ऐसे exploits के खिलाफ सुरक्षा होती है जो इन बिट्स की predictability पर निर्भर करते हैं।

यह mangled pointer मौजूदा randomness का लाभ उठाता है जो **Address Space Layout Randomization (ASLR)** द्वारा प्रदान की जाती है, जो प्रोग्रामों द्वारा उपयोग किए जाने वाले पते randomize करती है ताकि attackers के लिए किसी process के memory layout की भविष्यवाणी करना कठिन हो जाए।

**Demangling** का मतलब original address को प्राप्त करने के लिए वही XOR ऑपरेशन इस्तेमाल करना है। यहाँ mangled pointer को फार्मूला में P माना जाता है, और जब इसे unchanged storage location (L) के साथ XOR किया जाता है, तो original pointer प्रकट हो जाता है। mangling और demangling में यह symmetry सुनिश्चित करती है कि सिस्टम pointers को बिना बड़े overhead के कुशलता से encode और decode कर सके, साथ ही memory pointers को manipulate करने वाले हमलों के खिलाफ सुरक्षा काफी बढ़ जाती है।

### सुरक्षा लाभ

Pointer mangling का उद्देश्य heap management में **pointer के partial और full overwrites को रोकना** है, जो सुरक्षा में एक महत्वपूर्ण सुधार है। यह फीचर exploitation तकनीकों को कई तरह से प्रभावित करता है:

1. **Prevention of Bye Byte Relative Overwrites**: पहले attackers pointer के एक हिस्से को बदलकर heap chunks को exact addresses जाने बिना ही अलग locations पर redirect कर सकते थे — यह तकनीक leakless **House of Roman** exploit में देखी गई थी। Pointer mangling के साथ, ऐसे relative overwrites **बिना heap leak के अब brute forcing की माँग करते हैं**, जिससे इनके सफल होने की संभावना नाटकीय रूप से घट जाती है।
2. **Tcache Bin/Fastbin हमलों की कठिनाई में वृद्धि**: fastbin या tcache entries को manipulate करके function pointers (जैसे `__malloc_hook`) को overwrite करने वाले सामान्य हमले बाधित होते हैं। उदाहरण के लिए, एक हमला LibC address को leaking, एक chunk को tcache bin में free करने, और फिर Fd pointer को overwrite करके उसे `__malloc_hook` की ओर redirect करने पर आधारित हो सकता है ताकि arbitrary code execution हो सके। Pointer mangling के साथ, इन pointers को सही तरीके से mangled होना आवश्यक है, **जिसके लिए सटीक manipulation में heap leak की आवश्यकता होती है**, जिससे exploitation की बाधा बढ़ जाती है।
3. **Non-Heap स्थानों में Heap Leaks की आवश्यकता**: non-heap क्षेत्रों (जैसे stack, .bss section, या PLT/GOT) में fake chunk बनाना अब pointer mangling की आवश्यकता के कारण भी **heap leak की मांग करता है**। इससे इन क्षेत्रों को exploit करने की जटिलता बढ़ जाती है, जैसा कि LibC addresses को manipulate करने में होता है।
4. **Heap Addresses का leak करना अधिक चुनौतीपूर्ण होता है**: Pointer mangling fastbin और tcache bins में Fd pointers की उपयोगिता को heap address leaks के स्रोत के रूप में सीमित कर देता है। हालांकि, unsorted, small, और large bins में pointers unmangled रहते हैं, इसलिए वे अभी भी addresses leak करने के लिए उपयोगी हैं। यह बदलाव attackers को इन bins में exploitable जानकारी खोजने के लिए प्रेरित करता है, हालांकि कुछ तकनीकें leak से पहले pointers को demangle करने की अनुमति दे सकती हैं, पर सीमाओं के साथ।

### **Safe-Linking Bypass (page-aligned leak scenario)**

Safe-linking enabled (glibc ≥ 2.32) के साथ भी, अगर आप mangled pointer को leak कर सकते हैं और corrupted chunk तथा victim chunk दोनों एक ही 4KB page साझा करते हैं, तो original pointer केवल page offset से recover किया जा सकता है:
```c
// leaked_fd is the mangled Fd read from the chunk on the same page
uintptr_t l = (uintptr_t)&chunk->fd;           // storage location
uintptr_t original = (leaked_fd ^ (l >> 12));  // demangle
```
This restores the Fd and permits classic tcache/fastbin poisoning. If the chunks sit on different pages, brute-forcing the 12-bit page offset (0x1000 possibilities) is often feasible when allocation patterns are deterministic or when crashes are acceptable (e.g., CTF-style exploits).

### **Demangling Pointers with a Heap Leak**

> [!CAUTION]
> For a better explanation of the process [**check the original post from here**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Algorithm Overview

The formula used for mangling and demangling pointers is:

**`New_Ptr = (L >> 12) XOR P`**

Where **L** is the storage location and **P** is the Fd pointer. When **L** is shifted right by 12 bits, it exposes the most significant bits of **P**, due to the nature of **XOR**, which outputs 0 when bits are XORed with themselves.

**Key Steps in the Algorithm:**

1. **Initial Leak of the Most Significant Bits**: By XORing the shifted **L** with **P**, you effectively get the top 12 bits of **P** because the shifted portion of **L** will be zero, leaving **P's** corresponding bits unchanged.
2. **Recovery of Pointer Bits**: Since XOR is reversible, knowing the result and one of the operands allows you to compute the other operand. This property is used to deduce the entire set of bits for **P** by successively XORing known sets of bits with parts of the mangled pointer.
3. **Iterative Demangling**: The process is repeated, each time using the newly discovered bits of **P** from the previous step to decode the next segment of the mangled pointer, until all bits are recovered.
4. **Handling Deterministic Bits**: The final 12 bits of **L** are lost due to the shift, but they are deterministic and can be reconstructed post-process.

You can find an implementation of this algorithm here: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer guard एक exploit mitigation technique है जिसे glibc में stored function pointers (विशेषकर उन pointers को जो library calls जैसे `atexit()` द्वारा registered होते हैं) की सुरक्षा के लिए इस्तेमाल किया जाता है। यह protection pointers को scramble करने के लिए उपयोग करता है—पहले इन्हें thread data (`fs:0x30`) में रखे गए secret के साथ XOR किया जाता है और फिर एक bitwise rotation लागू किया जाता है। इस मेकैनिज़्म का उद्देश्य attackers को function pointers overwrite करके control flow hijack करने से रोकना है।

### **Bypassing Pointer Guard with a leak**

1. **Understanding Pointer Guard Operations:** pointers की scrambling (mangling) `PTR_MANGLE` macro से की जाती है जो pointer को एक 64-bit secret के साथ XOR करती है और फिर 0x11 बिट्स की left rotation करती है। मूल pointer recovery के लिए reverse operation `PTR_DEMANGLE` द्वारा संभाला जाता है।
2. **Attack Strategy:** यह attack एक known-plaintext approach पर आधारित है, जहाँ attacker को mangling में प्रयुक्त secret निकालने के लिए किसी pointer के original और mangled दोनों versions पता होने चाहिए।
3. **Exploiting Known Plaintexts:**
- **Identifying Fixed Function Pointers:** glibc source को देखकर या initialized function pointer tables (जैसे `__libc_pthread_functions`) का निरीक्षण करके, attacker predictable function pointers ढूंढ सकता है।
- **Computing the Secret:** किसी known function pointer जैसे `__pthread_attr_destroy` और function pointer table से उसका mangled संस्करण लेकर, secret को मापा जा सकता है—पहले mangled pointer को reverse rotate (right rotation) करें और फिर उसे function के address के साथ XOR करें।
4. **Alternative Plaintexts:** attacker उन pointers को known values जैसे 0 या -1 से mangling करके भी प्रयोग कर सकता है ताकि वे memory में identifiable patterns पैदा करते हैं; अगर ये patterns memory dumps में मिलते हैं तो secret उजागर हो सकता है।
5. **Practical Application:** secret की गणना करने के बाद, attacker pointers को नियंत्रित तरीके से manipulate कर सकता है, बुनियादी तौर पर multithreaded application में Pointer Guard protection को bypass कर सकता है जब libc base address ज्ञात हो और arbitrary memory locations पढ़ने की क्षमता मौजूद हो।

## GLIBC Tunables & Recent Loader Bugs

dynamic loader `GLIBC_TUNABLES` को program startup से पहले parse करता है। यहाँ की mis-parsing bugs सीधे **libc** को प्रभावित करती हैं इससे पहले कि अधिकांश mitigations सक्रिय हों। 2023 का "Looney Tunables" bug (CVE-2023-4911) इसका एक उदाहरण है: एक overlong `GLIBC_TUNABLES` value `ld.so` के internal buffers में overflow कर देता है, जिससे कई distros पर SUID binaries के साथ मिलकर **privilege escalation** संभव हो जाता है। Exploitation के लिए केवल environment को craft करना और target binary को बार-बार invoke करना आवश्यक है; pointer guard या safe-linking इसे रोकते नहीं क्योंकि corruption loader में heap setup से पहले होता है।

## References

- [Safe-Linking bypass explanation (shellphish/how2heap)](https://deepwiki.com/shellphish/how2heap/5.2-safe-linking-bypass)
- [Looney Tunables (CVE-2023-4911) write-up](https://www.wiz.io/vulnerability-database/cve/cve-2023-4911)

{{#include ../../banners/hacktricks-training.md}}
