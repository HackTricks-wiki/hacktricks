# Proteções do libc

{{#include ../../banners/hacktricks-training.md}}

## Chunk Alignment Enforcement

**Malloc** aloca memória em **grupos de 8 bytes (32-bit) ou 16 bytes (64-bit)**. Isso significa que o fim dos chunks em sistemas 32-bit deve alinhar com **0x8**, e em sistemas 64-bit com **0x0**. A funcionalidade de segurança verifica que cada chunk **esteja corretamente alinhado** nesses locais específicos antes de usar um ponteiro vindo de um bin.

### Benefícios de Segurança

A aplicação do alinhamento de chunks em sistemas 64-bit aumenta significativamente a segurança do Malloc ao **limitar a colocação de fake chunks para apenas 1 a cada 16 endereços**. Isso complica os esforços de exploração, especialmente em cenários onde o usuário tem controle limitado sobre valores de entrada, tornando ataques mais complexos e difíceis de executar com sucesso.

- **Fastbin Attack on `__malloc_hook`**

As novas regras de alinhamento no Malloc também impedem um ataque clássico envolvendo o `__malloc_hook`. Antes, atacantes podiam manipular tamanhos de chunk para **sobrescrever esse ponteiro de função** e obter **execução de código**. Agora, o requisito estrito de alinhamento garante que tais manipulações não sejam mais viáveis, fechando uma rota comum de exploração e melhorando a segurança geral.

> **Nota:** Desde o glibc **2.34** os legacy hooks (`__malloc_hook`, `__free_hook`, etc.) foram removidos da ABI exportada. Exploits modernos agora miram outros ponteiros de função graváveis (por ex. tcache per-thread struct, vtable-style callbacks) ou dependem de `setcontext`, `_IO_list_all` primitives, etc.

## Pointer Mangling on fastbins and tcache

**Pointer Mangling** é um aprimoramento de segurança usado para proteger **fastbin e tcache Fd pointers** nas operações de gerenciamento de memória. Essa técnica ajuda a prevenir certos tipos de táticas de exploração de memória, especificamente aquelas que não requerem leaked memory information ou que manipulam locais de memória diretamente relativos a posições conhecidas (relative **overwrites**).

O núcleo dessa técnica é uma fórmula de ofuscação:

**`New_Ptr = (L >> 12) XOR P`**

- **L** é a **Storage Location** do ponteiro.
- **P** é o real **fastbin/tcache Fd Pointer**.

A razão para o deslocamento bit a bit (shift) da storage location (L) em 12 bits para a direita antes da operação XOR é crítica. Essa manipulação trata uma vulnerabilidade inerente à natureza determinística dos 12 bits menos significativos dos endereços de memória, que tipicamente são previsíveis devido a restrições da arquitetura do sistema. Ao deslocar os bits, a porção previsível é movida para fora da equação, aumentando a aleatoriedade do novo ponteiro ofuscado e assim protegendo contra exploits que dependem da previsibilidade desses bits.

Esse ponteiro mangled aproveita a aleatoriedade já existente fornecida pelo Address Space Layout Randomization (ASLR), que randomiza endereços usados por programas para tornar difícil para atacantes preverem o layout de memória de um processo.

Desofuscar o ponteiro para recuperar o endereço original envolve usar a mesma operação XOR. Aqui, o ponteiro mangled é tratado como P na fórmula, e quando XORed com a storage location (L) sem alteração, resulta na revelação do ponteiro original. Essa simetria na mangling e demangling garante que o sistema possa codificar e decodificar ponteiros eficientemente sem overhead significativo, enquanto aumenta substancialmente a segurança contra ataques que manipulam ponteiros de memória.

### Benefícios de Segurança

Pointer mangling visa **prevenir overwrites parciais e completos de ponteiros no heap**, um aumento significativo na segurança. Essa feature impacta técnicas de exploração de várias formas:

1. **Prevention of Bye Byte Relative Overwrites**: Antes, atacantes podiam alterar parte de um ponteiro para **redirecionar heap chunks para locais diferentes sem saber endereços exatos**, técnica evidente no exploit leakless **House of Roman**. Com pointer mangling, tais relative overwrites **sem um heap leak agora exigem brute forcing**, reduzindo drasticamente a probabilidade de sucesso.
2. **Increased Difficulty of Tcache Bin/Fastbin Attacks**: Ataques comuns que sobrescrevem ponteiros de função (como `__malloc_hook`) manipulando entradas de fastbin ou tcache são dificultados. Por exemplo, um ataque pode envolver vazar um LibC address, dar free em um chunk para o tcache bin, e então sobrescrever o Fd pointer para redirecioná-lo a `__malloc_hook` para execução arbitrária de código. Com pointer mangling, esses ponteiros precisam estar corretamente mangled, **exigindo um heap leak para manipulação precisa**, elevando assim a barreira de exploração.
3. **Requirement for Heap Leaks in Non-Heap Locations**: Criar um fake chunk em áreas não-heap (como stack, seção .bss, ou PLT/GOT) agora também **requer um heap leak** devido à necessidade de pointer mangling. Isso aumenta a complexidade de explorar essas áreas, similar ao requisito para manipular endereços do LibC.
4. **Leaking Heap Addresses Becomes More Challenging**: Pointer mangling restringe a utilidade dos Fd pointers em fastbin e tcache bins como fontes para heap address leaks. Entretanto, ponteiros em unsorted, small e large bins permanecem unmangled, portanto ainda utilizáveis para vazar endereços. Essa mudança força atacantes a explorar esses bins em busca de informação explorável, embora algumas técnicas ainda possam permitir desmangling de ponteiros antes de um leak, com certas limitações.

### **Safe-Linking Bypass (page-aligned leak scenario)**

Mesmo com safe-linking habilitado (glibc ≥ 2.32), se você puder leak o ponteiro mangled e tanto o chunk corrompido quanto o chunk vítima compartilharem a mesma página de 4KB, o ponteiro original pode ser recuperado usando apenas o page offset:
```c
// leaked_fd is the mangled Fd read from the chunk on the same page
uintptr_t l = (uintptr_t)&chunk->fd;           // storage location
uintptr_t original = (leaked_fd ^ (l >> 12));  // demangle
```
Isso restaura o Fd e permite o clássico tcache/fastbin poisoning. Se os chunks estiverem em páginas diferentes, brute-forcing o deslocamento de página de 12 bits (0x1000 possibilidades) é frequentemente viável quando os padrões de alocação são determinísticos ou quando crashes são aceitáveis (por exemplo, exploits estilo CTF).

### **Desofuscação de Pointers com um Heap Leak**

> [!CAUTION]
> For a better explanation of the process [**check the original post from here**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Algorithm Overview

A fórmula usada para mangling e demangling de pointers é:

**`New_Ptr = (L >> 12) XOR P`**

Onde **L** é o local de armazenamento e **P** é o ponteiro Fd. Quando **L** é deslocado 12 bits para a direita, ele expõe os bits mais significativos de **P**, devido à natureza do **XOR**, que produz 0 quando bits são XORed com eles mesmos.

**Passos-chave no algoritmo:**

1. **Initial Leak of the Most Significant Bits:** Ao XORar o **L** deslocado com **P**, você efetivamente obtém os 12 bits mais altos de **P** porque a parte deslocada de **L** será zero, deixando os bits correspondentes de **P** inalterados.
2. **Recovery of Pointer Bits:** Como XOR é reversível, conhecer o resultado e um dos operandos permite calcular o outro operando. Essa propriedade é usada para deduzir todo o conjunto de bits de **P** sucessivamente XORando conjuntos conhecidos de bits com partes do ponteiro mangled.
3. **Iterative Demangling:** O processo é repetido, cada vez usando os bits recém-descobertos de **P** do passo anterior para decodificar o próximo segmento do ponteiro mangled, até que todos os bits sejam recuperados.
4. **Handling Deterministic Bits:** Os 12 bits finais de **L** são perdidos devido ao deslocamento, mas são determinísticos e podem ser reconstruídos após o processo.

Você pode encontrar uma implementação deste algoritmo aqui: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer guard é uma técnica de mitigação de exploit usada no glibc para proteger function pointers armazenados, particularmente aqueles registrados por chamadas de biblioteca como `atexit()`. Essa proteção envolve embaralhar (scrambling) os pointers XORando-os com um segredo armazenado nos dados da thread (`fs:0x30`) e aplicando uma rotação bit a bit. Esse mecanismo visa impedir que atacantes sequestrarem o fluxo de controle sobrescrevendo function pointers.

### **Bypassando Pointer Guard com um leak**

1. **Understanding Pointer Guard Operations:** O scrambling (mangling) de pointers é feito usando a macro `PTR_MANGLE` que XORa o ponteiro com um segredo de 64 bits e então realiza uma rotação à esquerda de 0x11 bits. A operação inversa para recuperar o ponteiro original é feita por `PTR_DEMANGLE`.
2. **Attack Strategy:** O ataque baseia-se em uma abordagem known-plaintext, onde o atacante precisa conhecer tanto a versão original quanto a versão mangled de um pointer para deduzir o segredo usado no mangling.
3. **Exploiting Known Plaintexts:**
- **Identifying Fixed Function Pointers:** Ao examinar o código-fonte do glibc ou tabelas de function pointers inicializadas (como `__libc_pthread_functions`), um atacante pode encontrar ponteiros de função previsíveis.
- **Computing the Secret:** Usando um ponteiro de função conhecido como `__pthread_attr_destroy` e sua versão mangled na tabela de function pointers, o segredo pode ser calculado rotacionando reversamente (right rotation) o ponteiro mangled e então XORando-o com o endereço da função.
4. **Alternative Plaintexts:** O atacante também pode experimentar mangling de pointers com valores conhecidos como 0 ou -1 para ver se isso produz padrões identificáveis na memória, potencialmente revelando o segredo quando esses padrões forem encontrados em memory dumps.
5. **Practical Application:** Depois de calcular o segredo, um atacante pode manipular pointers de forma controlada, essencialmente bypassando a proteção Pointer Guard em uma aplicação multithread com conhecimento da base do libc e a capacidade de ler locais arbitrários de memória.

## GLIBC Tunables & Recent Loader Bugs

O dynamic loader analisa `GLIBC_TUNABLES` antes do startup do programa. Bugs de mis-parsing aqui afetam diretamente o **libc** antes que a maioria das mitigações entre em ação. O bug de 2023 "Looney Tunables" (CVE-2023-4911) é um exemplo: um valor excessivamente longo em `GLIBC_TUNABLES` transborda buffers internos em `ld.so`, possibilitando privilege escalation em muitas distros quando combinado com binários SUID. A exploração requer apenas a construção do ambiente e a invocação repetida do binário alvo; pointer guard ou safe-linking não previnem porque a corrupção ocorre no loader antes da configuração do heap.

## Referências

- [Safe-Linking bypass explanation (shellphish/how2heap)](https://deepwiki.com/shellphish/how2heap/5.2-safe-linking-bypass)
- [Looney Tunables (CVE-2023-4911) write-up](https://www.wiz.io/vulnerability-database/cve/cve-2023-4911)

{{#include ../../banners/hacktricks-training.md}}
