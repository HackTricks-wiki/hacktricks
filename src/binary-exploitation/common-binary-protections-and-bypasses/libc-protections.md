# Libc Protections

{{#include ../../banners/hacktricks-training.md}}

## Chunk Alignment Enforcement

**Malloc** मेमोरी को **8-बाइट (32-बिट) या 16-बाइट (64-बिट) समूहों** में आवंटित करता है। इसका मतलब है कि 32-बिट सिस्टम में चंक्स का अंत **0x8** के साथ संरेखित होना चाहिए, और 64-बिट सिस्टम में **0x0** के साथ। सुरक्षा सुविधा यह सुनिश्चित करती है कि प्रत्येक चंक इन विशिष्ट स्थानों पर **सही ढंग से संरेखित** है, इससे पहले कि बिन से एक पॉइंटर का उपयोग किया जाए।

### Security Benefits

64-बिट सिस्टम में चंक संरेखण का प्रवर्तन Malloc की सुरक्षा को **हर 16 पते में केवल 1 नकली चंक के स्थान को सीमित करके** काफी बढ़ाता है। यह शोषण प्रयासों को जटिल बनाता है, विशेष रूप से उन परिदृश्यों में जहां उपयोगकर्ता के पास इनपुट मानों पर सीमित नियंत्रण होता है, जिससे हमलों को अधिक जटिल और सफलतापूर्वक निष्पादित करना कठिन हो जाता है।

- **Fastbin Attack on \_\_malloc_hook**

Malloc में नए संरेखण नियम भी `__malloc_hook` से संबंधित एक क्लासिक हमले को विफल करते हैं। पहले, हमलावर चंक के आकार को **इस फ़ंक्शन पॉइंटर को ओवरराइट करने के लिए हेरफेर कर सकते थे** और **कोड निष्पादन** प्राप्त कर सकते थे। अब, सख्त संरेखण आवश्यकता यह सुनिश्चित करती है कि ऐसी हेरफेर अब संभव नहीं हैं, एक सामान्य शोषण मार्ग को बंद कर देती है और समग्र सुरक्षा को बढ़ाती है।

## Pointer Mangling on fastbins and tcache

**Pointer Mangling** एक सुरक्षा सुधार है जिसका उपयोग **फास्टबिन और टकैश एफडी पॉइंटर्स** को मेमोरी प्रबंधन संचालन में सुरक्षित रखने के लिए किया जाता है। यह तकनीक कुछ प्रकार की मेमोरी शोषण रणनीतियों को रोकने में मदद करती है, विशेष रूप से उन जो लीक की गई मेमोरी जानकारी की आवश्यकता नहीं होती या जो ज्ञात स्थानों के सापेक्ष सीधे मेमोरी स्थानों में हेरफेर करती हैं (सापेक्ष **ओवरराइट** )।

इस तकनीक का मूल एक ओबफस्केशन फॉर्मूला है:

**`New_Ptr = (L >> 12) XOR P`**

- **L** पॉइंटर का **स्टोरेज स्थान** है।
- **P** वास्तविक **फास्टबिन/टकैश एफडी पॉइंटर** है।

स्टोरेज स्थान (L) के बिटवाइज शिफ्ट को 12 बिट्स दाईं ओर XOR ऑपरेशन से पहले करना महत्वपूर्ण है। यह हेरफेर मेमोरी पते के सबसे कम महत्वपूर्ण 12 बिट्स की पूर्वानुमानित प्रकृति में अंतर्निहित एक भेद्यता को संबोधित करता है, जो आमतौर पर सिस्टम आर्किटेक्चर की सीमाओं के कारण पूर्वानुमानित होते हैं। बिट्स को शिफ्ट करके, पूर्वानुमानित भाग समीकरण से बाहर हो जाता है, नए, मंगले हुए पॉइंटर की यादृच्छिकता को बढ़ाता है और इस प्रकार उन शोषणों के खिलाफ सुरक्षा करता है जो इन बिट्स की पूर्वानुमानितता पर निर्भर करते हैं।

यह मंगला हुआ पॉइंटर **एड्रेस स्पेस लेआउट रैंडमाइजेशन (ASLR)** द्वारा प्रदान की गई मौजूदा यादृच्छिकता का लाभ उठाता है, जो कार्यक्रमों द्वारा उपयोग किए जाने वाले पते को यादृच्छिक बनाता है ताकि हमलावरों के लिए किसी प्रक्रिया के मेमोरी लेआउट की भविष्यवाणी करना कठिन हो जाए।

**Demangling** पॉइंटर को मूल पते को पुनः प्राप्त करने के लिए उसी XOR ऑपरेशन का उपयोग करना शामिल है। यहाँ, मंगला हुआ पॉइंटर फॉर्मूला में P के रूप में माना जाता है, और जब इसे अपरिवर्तित स्टोरेज स्थान (L) के साथ XOR किया जाता है, तो यह मूल पॉइंटर को प्रकट करता है। मंगलीकरण और डेमंगलीकरण में यह सममिति सुनिश्चित करती है कि सिस्टम बिना महत्वपूर्ण ओवरहेड के प्रभावी ढंग से पॉइंटर्स को एन्कोड और डिकोड कर सकता है, जबकि मेमोरी पॉइंटर्स में हेरफेर करने वाले हमलों के खिलाफ सुरक्षा को काफी बढ़ाता है।

### Security Benefits

पॉइंटर मंगलीकरण का उद्देश्य **हीप में आंशिक और पूर्ण पॉइंटर ओवरराइट्स को रोकना** है, जो सुरक्षा में एक महत्वपूर्ण सुधार है। यह विशेषता कई तरीकों से शोषण तकनीकों को प्रभावित करती है:

1. **Bye Byte सापेक्ष ओवरराइट्स की रोकथाम**: पहले, हमलावर एक पॉइंटर के भाग को बदल सकते थे ताकि **हीप चंक्स को विभिन्न स्थानों पर पुनर्निर्देशित किया जा सके बिना सटीक पते को जाने**, यह तकनीक लीकलेस **हाउस ऑफ रोमन** शोषण में स्पष्ट है। पॉइंटर मंगलीकरण के साथ, ऐसी सापेक्ष ओवरराइट्स **बिना हीप लीक के अब ब्रूट फोर्सिंग की आवश्यकता होती है**, जिससे उनकी सफलता की संभावना में भारी कमी आती है।
2. **Tcache Bin/Fastbin हमलों की बढ़ती कठिनाई**: सामान्य हमले जो फ़ंक्शन पॉइंटर्स (जैसे `__malloc_hook`) को ओवरराइट करते हैं, फास्टबिन या टकैश प्रविष्टियों में हेरफेर करके बाधित होते हैं। उदाहरण के लिए, एक हमला एक LibC पते को लीक करने, एक चंक को टकैश बिन में मुक्त करने, और फिर Fd पॉइंटर को `__malloc_hook` पर पुनर्निर्देशित करने के लिए ओवरराइट करने में शामिल हो सकता है। पॉइंटर मंगलीकरण के साथ, इन पॉइंटर्स को सही ढंग से मंगला जाना चाहिए, **सटीक हेरफेर के लिए हीप लीक की आवश्यकता होती है**, जिससे शोषण की बाधा बढ़ जाती है।
3. **गैर-हीप स्थानों में हीप लीक की आवश्यकता**: गैर-हीप क्षेत्रों (जैसे स्टैक, .bss सेक्शन, या PLT/GOT) में एक नकली चंक बनाना अब भी **हीप लीक की आवश्यकता होती है** क्योंकि पॉइंटर मंगलीकरण की आवश्यकता होती है। यह इन क्षेत्रों का शोषण करने की जटिलता को बढ़ाता है, LibC पते में हेरफेर करने की आवश्यकता के समान।
4. **हीप पते लीक करना अधिक चुनौतीपूर्ण हो जाता है**: पॉइंटर मंगलीकरण फास्टबिन और टकैश बिन में Fd पॉइंटर्स के उपयोगिता को हीप पते लीक के स्रोत के रूप में सीमित करता है। हालाँकि, असंरचित, छोटे और बड़े बिन में पॉइंटर्स बिना मंगले हुए रहते हैं, इसलिए अभी भी पते लीक करने के लिए उपयोगी हैं। यह बदलाव हमलावरों को इन बिनों में शोषण योग्य जानकारी के लिए खोजने के लिए प्रेरित करता है, हालाँकि कुछ तकनीकें अभी भी लीक से पहले पॉइंटर्स को डेमंग्लिंग की अनुमति दे सकती हैं, हालाँकि सीमाओं के साथ।

### **Demangling Pointers with a Heap Leak**

> [!CAUTION]
> प्रक्रिया के बेहतर स्पष्टीकरण के लिए [**यहाँ से मूल पोस्ट देखें**](https://maxwelldulin.com/BlogPost?post=5445977088)।

### Algorithm Overview

पॉइंटर्स को मंगलीकरण और डेमंगलीकरण के लिए उपयोग किया जाने वाला फॉर्मूला है:

**`New_Ptr = (L >> 12) XOR P`**

जहाँ **L** स्टोरेज स्थान है और **P** Fd पॉइंटर है। जब **L** को 12 बिट्स दाईं ओर शिफ्ट किया जाता है, तो यह **P** के सबसे महत्वपूर्ण बिट्स को उजागर करता है, **XOR** की प्रकृति के कारण, जो तब 0 आउटपुट करता है जब बिट्स को अपने आप के साथ XOR किया जाता है।

**Algorithm में मुख्य चरण:**

1. **सबसे महत्वपूर्ण बिट्स का प्रारंभिक लीक**: शिफ्ट किए गए **L** को **P** के साथ XOR करके, आप प्रभावी रूप से **P** के शीर्ष 12 बिट्स प्राप्त करते हैं क्योंकि **L** का शिफ्ट किया गया भाग शून्य होगा, जिससे **P** के संबंधित बिट्स अपरिवर्तित रहेंगे।
2. **पॉइंटर बिट्स की पुनर्प्राप्ति**: चूंकि XOR उलटा होता है, परिणाम और एक ऑपरेटर को जानने से आपको दूसरे ऑपरेटर की गणना करने की अनुमति मिलती है। इस गुण का उपयोग **P** के बिट्स के पूरे सेट को डेड्यूस करने के लिए किया जाता है, मंगले हुए पॉइंटर के भागों के साथ ज्ञात बिट्स के सेट को क्रमशः XOR करके।
3. **आवर्ती डेमंगलीकरण**: यह प्रक्रिया दोहराई जाती है, प्रत्येक बार पिछले चरण से **P** के नए खोजे गए बिट्स का उपयोग करके मंगले हुए पॉइंटर के अगले खंड को डिकोड करने के लिए, जब तक सभी बिट्स पुनर्प्राप्त नहीं हो जाते।
4. **निर्धारणात्मक बिट्स को संभालना**: **L** के अंतिम 12 बिट्स शिफ्ट के कारण खो जाते हैं, लेकिन वे निर्धारणात्मक होते हैं और प्रक्रिया के बाद पुनर्निर्माण किया जा सकता है।

आप इस एल्गोरिदम का एक कार्यान्वयन यहाँ पा सकते हैं: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer guard एक शोषण शमन तकनीक है जिसका उपयोग glibc में संग्रहीत फ़ंक्शन पॉइंटर्स की सुरक्षा के लिए किया जाता है, विशेष रूप से उन फ़ंक्शन पॉइंटर्स की जो `atexit()` जैसे पुस्तकालय कॉल द्वारा पंजीकृत होते हैं। यह सुरक्षा पॉइंटर्स को एक गुप्त के साथ XOR करके और फिर बिटवाइज रोटेशन लागू करके स्क्रैम्बल करने में शामिल होती है। यह तंत्र हमलावरों को फ़ंक्शन पॉइंटर्स को ओवरराइट करके नियंत्रण प्रवाह को हाईजैक करने से रोकने का लक्ष्य रखता है।

### **Bypassing Pointer Guard with a leak**

1. **Pointer Guard ऑपरेशनों को समझना:** पॉइंटर्स का स्क्रैम्बलिंग (मंगलीकरण) `PTR_MANGLE` मैक्रो का उपयोग करके किया जाता है जो पॉइंटर को 64-बिट गुप्त के साथ XOR करता है और फिर 0x11 बिट्स का बायां रोटेशन करता है। मूल पॉइंटर को पुनः प्राप्त करने के लिए उलटा ऑपरेशन `PTR_DEMANGLE` द्वारा संभाला जाता है।
2. **हमला रणनीति:** यह हमला एक ज्ञात-प्लेनटेक्स्ट दृष्टिकोण पर आधारित है, जहाँ हमलावर को मंगले हुए पॉइंटर के मूल और मंगले हुए संस्करण दोनों को जानने की आवश्यकता होती है ताकि मंगलीकरण के लिए उपयोग किए गए गुप्त को डेड्यूस किया जा सके।
3. **ज्ञात प्लेनटेक्स्ट का शोषण:**
- **फिक्स्ड फ़ंक्शन पॉइंटर्स की पहचान करना:** glibc स्रोत कोड या प्रारंभिक फ़ंक्शन पॉइंटर तालिकाओं (जैसे `__libc_pthread_functions`) की जांच करके, एक हमलावर पूर्वानुमानित फ़ंक्शन पॉइंटर्स पा सकता है।
- **गुप्त की गणना करना:** एक ज्ञात फ़ंक्शन पॉइंटर जैसे `__pthread_attr_destroy` और फ़ंक्शन पॉइंटर तालिका से इसके मंगले हुए संस्करण का उपयोग करके, गुप्त को मंगले हुए पॉइंटर को उलटा घुमाकर (दाईं ओर घुमाना) और फिर फ़ंक्शन के पते के साथ XOR करके गणना की जा सकती है।
4. **वैकल्पिक प्लेनटेक्स्ट:** हमलावर ज्ञात मानों जैसे 0 या -1 के साथ पॉइंटर्स को मंगला करके यह देखने के लिए प्रयोग कर सकता है कि क्या ये मेमोरी में पहचानने योग्य पैटर्न उत्पन्न करते हैं, संभावित रूप से जब ये पैटर्न मेमोरी डंप में पाए जाते हैं तो गुप्त को प्रकट करते हैं।
5. **व्यावहारिक अनुप्रयोग:** गुप्त की गणना करने के बाद, एक हमलावर नियंत्रित तरीके से पॉइंटर्स में हेरफेर कर सकता है, मूल रूप से एक मल्टीथ्रेडेड एप्लिकेशन में Pointer Guard सुरक्षा को बायपास कर सकता है, libc बेस पते के ज्ञान और मनमाने मेमोरी स्थानों को पढ़ने की क्षमता के साथ।

## References

- [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
- [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)

{{#include ../../banners/hacktricks-training.md}}
