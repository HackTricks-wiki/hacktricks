# Libc Protections

{{#include ../../banners/hacktricks-training.md}}

## Chunk Alignment Enforcement

**Malloc** मेमोरी को **8-byte (32-bit) या 16-byte (64-bit) groupings** में आवंटित करता है। इसका मतलब है कि 32-bit सिस्टम में chunks के अंत को **0x8** के साथ और 64-bit सिस्टम में **0x0** के साथ संरेखित होना चाहिए। यह सुरक्षा फ़ीचर bin से pointer का उपयोग करने से पहले यह जांचता है कि प्रत्येक chunk इन विशिष्ट स्थानों पर सही ढंग से **align** है।

### Security Benefits

64-bit सिस्टम में chunk alignment का प्रवर्तन Malloc की सुरक्षा को काफी बढ़ाता है क्योंकि यह fake chunks की जगह को केवल हर 16 पतों में से 1 तक सीमित कर देता है। यह उन परिस्थितियों में exploitation को जटिल बनाता है जहाँ उपयोगकर्ता के पास इनपुट मानों पर सीमित नियंत्रण होता है, और हमलों को सफलतापूर्वक निष्पादित करना कठिन कर देता है।

- **Fastbin Attack on `__malloc_hook`**

नए alignment नियम Malloc में एक क्लासिक हमले को भी नाकाम कर देते हैं जो `__malloc_hook` से संबंधित था। पहले, attackers chunk sizes को manipulate करके इस function pointer को overwrite कर सकते थे और `code execution` प्राप्त कर सकते थे। अब, कड़े alignment की आवश्यकता सुनिश्चित करती है कि ऐसे हेरफेर संभव नहीं हैं, जिससे एक सामान्य exploitation मार्ग बंद हो जाता है और समग्र सुरक्षा बढ़ती है।

> **Note:** Since glibc **2.34** the legacy hooks (`__malloc_hook`, `__free_hook`, etc.) are removed from the exported ABI. Modern exploits now target other writable function pointers (e.g. tcache per-thread struct, vtable-style callbacks) or rely on `setcontext`, `_IO_list_all` primitives, etc.

## Pointer Mangling on fastbins and tcache

**Pointer Mangling** एक सुरक्षा सुधार है जो मेमोरी मैनेजमेंट ऑपरेशन्स में **fastbin और tcache Fd pointers** की सुरक्षा के लिए उपयोग किया जाता है। यह तकनीक कुछ प्रकार की memory exploit रणनीतियों को रोकने में मदद करती है, विशेषकर उन तरीकों को जो leaked memory जानकारी की आवश्यकता नहीं रखते या जो ज्ञात स्थानों के सापेक्ष सीधे memory locations को manipulate करते हैं (relative **overwrites**)।

इसके मूल में एक obfuscation सूत्र है:

**`New_Ptr = (L >> 12) XOR P`**

- **L** pointer का **Storage Location** है।
- **P** वास्तविक **fastbin/tcache Fd Pointer** है।

storage location (L) को right में 12 बिट्स shift करने का कारण महत्वपूर्ण है। यह हेरफेर memory addresses के least significant 12 बिट्स की deterministic प्रकृति से पैदा होने वाली एक vulnerability को संबोधित करता है, जो सामान्यतः सिस्टम आर्किटेक्चर प्रतिबंधों के कारण predictable होते हैं। बिट्स को shift करके, predictable हिस्सा समीकरण से बाहर कर दिया जाता है, जिससे नया mangled pointer अधिक यादृच्छिक हो जाता है और उन exploits के खिलाफ सुरक्षा बढ़ती है जो इन बिट्स की predictability पर निर्भर करते हैं।

यह mangled pointer Address Space Layout Randomization (ASLR) द्वारा प्रदान की गई मौजूदा randomness का उपयोग करता है, जो प्रक्रियाओं के memory layout की भविष्यवाणी को कठिन बना देता है।

**Demangling** करके मूल पते को पुनः प्राप्त करना उसी XOR ऑपरेशन का उपयोग करके किया जाता है। यहाँ, mangled pointer को सूत्र में P के रूप में माना जाता है, और जब इसे unchanged storage location (L) के साथ XOR किया जाता है तो मूल pointer प्रकट हो जाता है। Mangling और demangling में यह सममिति सुनिश्चित करती है कि सिस्टम बिना बड़े ओवरहेड के pointers को encode और decode कर सके, जबकि pointer-manipulation के खिलाफ सुरक्षा काफी बढ़ जाती है।

### Security Benefits

Pointer mangling का उद्देश्य heap प्रबंधन में **partial और full pointer overwrites** को रोकना है, जो सुरक्षा में एक महत्वपूर्ण सुधार है। यह फ़ीचर exploit तकनीकों को कई तरीकों से प्रभावित करता है:

1. **Prevention of Bye Byte Relative Overwrites**: पहले, attackers pointer के हिस्से को बदलकर heap chunks को अलग स्थानों पर redirect कर सकते थे बिना सही addresses जाने — यह तकनीक leakless **House of Roman** exploit में स्पष्ट है। Pointer mangling के साथ, ऐसे relative overwrites अब **heap leak** के बिना brute forcing की मांग करते हैं, जिससे उनकी सफलता की संभावना बहुत घट जाती है।
2. **Increased Difficulty of Tcache Bin/Fastbin Attacks**: fastbin या tcache entries को manipulate करके function pointers (जैसे `__malloc_hook`) को overwrite करने वाले सामान्य हमले बाधित होते हैं। उदाहरण के लिए, एक हमला LibC पता leak करना, chunk को tcache bin में free करना, और फिर Fd pointer को overwrite करके इसे `__malloc_hook` की ओर redirect करने पर निर्भर हो सकता है। Pointer mangling के साथ, इन pointers को सही ढंग से mangled होना चाहिए, यानी सटीक manipulation के लिए **heap leak** की आवश्यकता होती है, जिससे exploitation की बाधा बढ़ जाती है।
3. **Requirement for Heap Leaks in Non-Heap Locations**: non-heap क्षेत्रों में fake chunk (जैसे stack, .bss section, या PLT/GOT) बनाना अब भी pointer mangling के कारण **heap leak** की मांग करता है। इससे इन क्षेत्रों का exploit करना भी पहले की तुलना में ज्यादा जटिल हो जाता है, ठीक वैसे ही जैसे LibC पतों के लिए होता है।
4. **Leaking Heap Addresses Becomes More Challenging**: Pointer mangling fastbin और tcache bins में Fd pointers को heap address leaks के स्रोत के रूप में उपयोगी बनने से रोकता है। हालांकि, unsorted, small, और large bins में pointers unmangled रहते हैं, इसलिए वे अभी भी addresses लीक करने के लिए उपयोग किए जा सकते हैं। इस बदलाव के कारण attackers को exploitable जानकारी के लिए इन bins की खोज करने के लिए प्रेरित किया जाता है, हालाँकि कुछ तकनीकें अभी भी demangling करके leak से पहले pointers को उपयोग में ला सकती हैं, पर सीमाओं के साथ।

### **Safe-Linking Bypass (page-aligned leak scenario)**

Even with safe-linking enabled (glibc ≥ 2.32), if you can leak the mangled pointer and both the corrupted chunk and victim chunk share the same 4KB page, the original pointer can be recovered with just the page offset:
```c
// leaked_fd is the mangled Fd read from the chunk on the same page
uintptr_t l = (uintptr_t)&chunk->fd;           // storage location
uintptr_t original = (leaked_fd ^ (l >> 12));  // demangle
```
This restores the Fd and permits classic tcache/fastbin poisoning. If the chunks sit on different pages, brute-forcing the 12-bit page offset (0x1000 possibilities) is often feasible when allocation patterns are deterministic or when crashes are acceptable (e.g., CTF-style exploits).

### **Demangling Pointers with a Heap Leak**

> [!CAUTION]
> For a better explanation of the process [**check the original post from here**](https://maxwelldulin.com/BlogPost?post=5445977088).

### एल्गोरिथ्म अवलोकन

The formula used for mangling and demangling pointers is:

**`New_Ptr = (L >> 12) XOR P`**

Where **L** is the storage location and **P** is the Fd pointer. When **L** is shifted right by 12 bits, it exposes the most significant bits of **P**, due to the nature of **XOR**, which outputs 0 when bits are XORed with themselves.

**एल्गोरिथ्म में मुख्य कदम:**

1. **Initial leak of the Most Significant Bits:** shifted **L** को **P** के साथ XOR करने पर आप प्रभावी रूप से **P** के शीर्ष 12 bits प्राप्त कर लेते हैं क्योंकि shifted भाग शून्य होगा और **P** के संबंधित bits अपरिवर्तित रहेंगे।
2. **Recovery of Pointer Bits:** चूँकि XOR reversible है, परिणाम और एक operand ज्ञात होने पर दूसरा operand गणना किया जा सकता है। इस गुण का उपयोग करके **P** के पूरे बिट्स को क्रमिक रूप से ज्ञात बिट सेटों के साथ mangled pointer के भागों पर XOR करके निकाला जाता है।
3. **Iterative Demangling:** यह प्रक्रिया दोहराई जाती है, हर कदम पर पिछले चरण से प्राप्त किए गए **P** के नए बिट्स का उपयोग अगले segmento को decode करने के लिए किया जाता है, जब तक सभी bits recover न हो जाएँ।
4. **Handling Deterministic Bits:** शिफ्ट के कारण **L** के अंतिम 12 बिट्स खो जाते हैं, लेकिन वे deterministic होते हैं और पोस्ट-प्रोसेस में पुनर्निर्मित किए जा सकते हैं।

You can find an implementation of this algorithm here: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)

## Pointer Guard

Pointer guard glibc में stored function pointers की सुरक्षा के लिए उपयोग की जाने वाली एक exploit mitigation तकनीक है, विशेष रूप से उन pointers के लिए जो library calls जैसे `atexit()` द्वारा register होते हैं। यह सुरक्षा pointers को scramble करने में शामिल है, जिन्हें thread data (`fs:0x30`) में संग्रहित एक secret के साथ XOR करके और एक bitwise rotation लागू करके किया जाता है। यह तंत्र attackers को function pointers overwrite करके control flow hijack करने से रोकने का लक्ष्य रखता है।

### **Bypassing Pointer Guard with a leak**

1. **Understanding Pointer Guard Operations:** pointers का scrambling (mangling) `PTR_MANGLE` macro के उपयोग से किया जाता है जो pointer को एक 64-bit secret के साथ XOR करता है और फिर 0x11 bits की left rotation करता है। original pointer को recover करने की reverse operation `PTR_DEMANGLE` द्वारा संभाली जाती है।
2. **Attack Strategy:** यह हमला known-plaintext approach पर आधारित है, जहाँ attacker को mangling में प्रयुक्त secret का पता लगाने के लिए pointer के original और mangled दोनों versions ज्ञात होने चाहिए।
3. **Exploiting Known Plaintexts:**
- **Identifying Fixed Function Pointers:** glibc source को देखकर या initialized function pointer tables (जैसे `__libc_pthread_functions`) की जाँच करके attacker predictable function pointers पा सकता है।
- **Computing the Secret:** किसी ज्ञात function pointer जैसे `__pthread_attr_destroy` और function pointer table से उसके mangled version का उपयोग करके secret की गणना की जा सकती है—mangled pointer को reverse rotate (right rotation) करके और फिर उसे function के address के साथ XOR करके।
4. **Alternative Plaintexts:** attacker ज्ञात मानों जैसे 0 या -1 के साथ pointers को mangling करके यह देख सकता है कि क्या ये memory में पहचानने योग्य पैटर्न उत्पन्न करते हैं; ऐसे पैटर्न memory dumps में मिलने पर यह secret उजागर कर सकता है।
5. **Practical Application:** secret की गणना के बाद, attacker pointers को नियंत्रित तरीके से manipulate कर सकता है, जिससे multithreaded application में Pointer Guard सुरक्षा को effectively bypass किया जा सकता है, बशर्ते attacker के पास libc base address का ज्ञान और arbitrary memory locations पढ़ने की क्षमता हो।

## GLIBC Tunables & Recent Loader Bugs

The dynamic loader parses `GLIBC_TUNABLES` before program startup. Mis-parsing bugs here directly affect **libc** before most mitigations kick in. The 2023 "Looney Tunables" bug (CVE-2023-4911) is an example: an overlong `GLIBC_TUNABLES` value overflows internal buffers in `ld.so`, enabling **privilege escalation** on many distros when combined with SUID binaries. Exploitation requires only crafting the environment and repeatedly invoking the target binary; pointer guard or safe-linking do not prevent it because corruption happens in the loader prior to heap setup.

## References

- [Safe-Linking bypass explanation (shellphish/how2heap)](https://deepwiki.com/shellphish/how2heap/5.2-safe-linking-bypass)
- [Looney Tunables (CVE-2023-4911) write-up](https://www.wiz.io/vulnerability-database/cve/cve-2023-4911)

{{#include ../../banners/hacktricks-training.md}}
