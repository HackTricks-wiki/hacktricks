# Ochrony libc

{{#include ../../banners/hacktricks-training.md}}

## Chunk Alignment Enforcement

**Malloc** przydziela pamięć w **grupach po 8 bajtów (32-bit)** lub **16 bajtów (64-bit)**. Oznacza to, że koniec chunków w systemach 32-bit powinien być wyrównany do **0x8**, a w systemach 64-bit do **0x0**. Funkcja bezpieczeństwa sprawdza, czy każdy chunk **jest poprawnie wyrównany** w tych konkretnych miejscach, zanim użyje wskaźnika z binku.

### Korzyści bezpieczeństwa

Wymuszanie wyrównania chunków w systemach 64-bit znacząco zwiększa bezpieczeństwo Malloc przez **ograniczenie możliwości umieszczania fake chunks do tylko 1 z każdej 16 adresów**. Utrudnia to działania exploitacyjne, zwłaszcza gdy atakujący ma ograniczoną kontrolę nad wartościami wejściowymi, czyniąc ataki bardziej skomplikowanymi i trudniejszymi do wykonania pomyślnie.

- **Fastbin Attack on `__malloc_hook`**

Nowe zasady wyrównania w Malloc także uniemożliwiają klasyczny atak wykorzystujący `__malloc_hook`. Wcześniej atakujący mogli manipulować rozmiarami chunków, aby **nadpisać ten wskaźnik funkcji** i uzyskać **wykonanie kodu**. Teraz ścisły wymóg wyrównania sprawia, że takie manipulacje nie są już możliwe, zamykając typową ścieżkę eksploatacji i zwiększając ogólne bezpieczeństwo.

> **Uwaga:** Od glibc **2.34** legacy hooks (`__malloc_hook`, `__free_hook`, itd.) zostały usunięte z eksportowanego ABI. Modern exploits teraz celują w inne zapisywalne wskaźniki funkcji (np. tcache per-thread struct, vtable-style callbacks) lub polegają na `setcontext`, `_IO_list_all` primitives, itd.

## Pointer Mangling on fastbins and tcache

**Pointer Mangling** to mechanizm bezpieczeństwa używany do ochrony wskaźników Fd w fastbin i tcache podczas operacji zarządzania pamięcią. Ta technika pomaga zapobiegać pewnym typom taktyk eksploatacji pamięci, szczególnie tym, które nie wymagają leaked memory information lub które manipulują lokalizacjami pamięci bezpośrednio względem znanych pozycji (relative **overwrites**).

Rdzeniem tej techniki jest formuła obfuskacji:

**`New_Ptr = (L >> 12) XOR P`**

- **L** to **Storage Location** wskaźnika.
- **P** to rzeczywisty **fastbin/tcache Fd Pointer**.

Powód przesunięcia bitów lokalizacji przechowywania (L) o 12 bitów w prawo przed operacją XOR jest kluczowy. Ta manipulacja usuwa przewidywalną część najmniej znaczących 12 bitów adresów pamięci — które zwykle są przewidywalne ze względu na ograniczenia architektury systemu. Przesunięcie bitów przesuwa przewidywalną część poza równanie, zwiększając losowość nowego, zmanglowanego wskaźnika i w ten sposób chroniąc przed exploitami bazującymi na przewidywalności tych bitów.

Ten zmanglowany wskaźnik wykorzystuje istniejącą losowość dostarczaną przez Address Space Layout Randomization (ASLR), która losuje adresy używane przez programy, aby utrudnić atakującym przewidzenie układu pamięci procesu.

Demangling wskaźnika, aby odzyskać oryginalny adres, polega na użyciu tej samej operacji XOR. W tym przypadku zmanglowany wskaźnik traktowany jest jako P w formule, a po XOR z niezmienioną lokalizacją przechowywania (L) ujawnia oryginalny wskaźnik. Ta symetria w manglowaniu i demanglowaniu zapewnia, że system może efektywnie kodować i dekodować wskaźniki bez znaczącego narzutu, jednocześnie znacznie zwiększając bezpieczeństwo przeciwko atakom manipulującym wskaźnikami pamięci.

### Korzyści bezpieczeństwa

Pointer mangling ma na celu **zapobieganie częściowym i pełnym nadpisaniom wskaźników w zarządzaniu heap**, co stanowi istotne wzmocnienie bezpieczeństwa. Funkcja ta wpływa na techniki eksploatacji na kilka sposobów:

1. **Prewencja Bye Byte Relative Overwrites**: Wcześniej atakujący mogli zmienić część wskaźnika, aby **przekierować chunki heap do innych lokalizacji bez znajomości dokładnych adresów**, technika widoczna w leakless **House of Roman**. Z pointer mangling, takie relative overwrites **bez heap leak teraz wymagają brute forcingu**, co drastycznie zmniejsza prawdopodobieństwo ich sukcesu.
2. **Zwiększona trudność ataków na tcache Bin/Fastbin**: Typowe ataki polegające na nadpisaniu wskaźników funkcji (jak `__malloc_hook`) poprzez manipulację wpisami fastbin lub tcache są utrudnione. Na przykład atak mógł polegać na ujawnieniu LibC address, zwolnieniu chunka do tcache bin, a następnie nadpisaniu Fd, aby przekierować go do `__malloc_hook` w celu dowolnego wykonania kodu. Z pointer mangling, te wskaźniki muszą być poprawnie zmanglowane, **wymagając heap leak dla dokładnej manipulacji**, podnosząc szczebel trudności eksploatacji.
3. **Wymóg heap leak przy tworzeniu fake chunk w lokalizacjach nie-heap**: Stworzenie fake chunk w obszarach nie należących do heap (jak stack, .bss, lub PLT/GOT) teraz także **wymaga heap leak** ze względu na konieczność pointer mangling. To zwiększa złożoność eksploatacji tych obszarów, podobnie do wymogu manipulacji LibC addresses.
4. **Ujawnianie adresów heap staje się trudniejsze**: Pointer mangling ogranicza użyteczność wskaźników Fd w fastbin i tcache jako źródeł do ujawniania adresów heap. Jednak wskaźniki w unsorted, small i large binach pozostają niemanglowane, więc wciąż nadają się do leakowania adresów. Ta zmiana skłania atakujących do eksploracji tych binów w poszukiwaniu eksploatowalnej informacji, chociaż niektóre techniki nadal mogą pozwolić na demanglowanie wskaźników przed leak, choć z ograniczeniami.

### **Safe-Linking Bypass (page-aligned leak scenario)**

Nawet z włączonym Safe-Linking (glibc ≥ 2.32), jeśli potrafisz wyeksponować zmanglowany wskaźnik i zarówno skorygowany chunk jak i chunk ofiary znajdują się na tej samej stronie 4KB, oryginalny wskaźnik można odzyskać używając jedynie offsetu strony:
```c
// leaked_fd is the mangled Fd read from the chunk on the same page
uintptr_t l = (uintptr_t)&chunk->fd;           // storage location
uintptr_t original = (leaked_fd ^ (l >> 12));  // demangle
```
This restores the Fd and permits classic tcache/fastbin poisoning. If the chunks sit on different pages, brute-forcing the 12-bit page offset (0x1000 possibilities) is often feasible when allocation patterns are deterministic or when crashes are acceptable (e.g., CTF-style exploits).

### **Demangling wskaźników przy użyciu Heap Leak**

> [!CAUTION]
> Dla lepszego wyjaśnienia procesu [**sprawdź oryginalny post tutaj**](https://maxwelldulin.com/BlogPost?post=5445977088).

### Algorithm Overview

The formula used for mangling and demangling pointers is:

**`New_Ptr = (L >> 12) XOR P`**

Where **L** is the storage location and **P** is the Fd pointer. When **L** is shifted right by 12 bits, it exposes the most significant bits of **P**, due to the nature of **XOR**, which outputs 0 when bits are XORed with themselves.

**Key Steps in the Algorithm:**

1. **Initial leak of the most significant bits**: By XORing the shifted **L** with **P**, you effectively get the top 12 bits of **P** because the shifted portion of **L** will be zero, leaving **P's** corresponding bits unchanged.
2. **Recovery of pointer bits**: Since XOR is reversible, knowing the result and one of the operands allows you to compute the other operand. This property is used to deduce the entire set of bits for **P** by successively XORing known sets of bits with parts of the mangled pointer.
3. **Iterative demangling**: The process is repeated, each time using the newly discovered bits of **P** from the previous step to decode the next segment of the mangled pointer, until all bits are recovered.
4. **Handling deterministic bits**: The final 12 bits of **L** are lost due to the shift, but they are deterministic and can be reconstructed post-process.

You can find an implementation of this algorithm here: https://github.com/mdulin2/mangle

## Pointer Guard

Pointer Guard to technika łagodzenia exploitów stosowana w glibc do ochrony przechowywanych wskaźników do funkcji, szczególnie tych zarejestrowanych przez wywołania biblioteczne takie jak `atexit()`. Ta ochrona polega na scramblingu wskaźników poprzez XOR z sekretem przechowywanym w danych wątku (`fs:0x30`) oraz na zastosowaniu rotacji bitowej. Mechanizm ten ma na celu uniemożliwienie atakującym przejęcia kontroli przepływu przez nadpisanie wskaźników do funkcji.

### **Omijanie Pointer Guard za pomocą leak**

1. **Understanding Pointer Guard Operations:** The scrambling (mangling) of pointers is done using the `PTR_MANGLE` macro which XORs the pointer with a 64-bit secret and then performs a left rotation of 0x11 bits. The reverse operation for recovering the original pointer is handled by `PTR_DEMANGLE`.
2. **Attack Strategy:** The attack is based on a known-plaintext approach, where the attacker needs to know both the original and the mangled versions of a pointer to deduce the secret used for mangling.
3. **Exploiting Known Plaintexts:**
- **Identifying Fixed Function Pointers:** By examining glibc source code or initialized function pointer tables (like `__libc_pthread_functions`), an attacker can find predictable function pointers.
- **Computing the Secret:** Using a known function pointer such as `__pthread_attr_destroy` and its mangled version from the function pointer table, the secret can be calculated by reverse rotating (right rotation) the mangled pointer and then XORing it with the address of the function.
4. **Alternative Plaintexts:** The attacker can also experiment with mangling pointers with known values like 0 or -1 to see if these produce identifiable patterns in memory, potentially revealing the secret when these patterns are found in memory dumps.
5. **Practical Application:** After computing the secret, an attacker can manipulate pointers in a controlled manner, essentially bypassing the Pointer Guard protection in a multithreaded application with knowledge of the libc base address and an ability to read arbitrary memory locations.

## GLIBC Tunables & Recent Loader Bugs

The dynamic loader parses `GLIBC_TUNABLES` before program startup. Mis-parsing bugs here directly affect **libc** before most mitigations kick in. The 2023 "Looney Tunables" bug (CVE-2023-4911) is an example: an overlong `GLIBC_TUNABLES` value overflows internal buffers in `ld.so`, enabling **privilege escalation** on many distros when combined with SUID binaries. Exploitation requires only crafting the environment and repeatedly invoking the target binary; pointer guard or safe-linking do not prevent it because corruption happens in the loader prior to heap setup.

## References

- [Safe-Linking bypass explanation (shellphish/how2heap)](https://deepwiki.com/shellphish/how2heap/5.2-safe-linking-bypass)
- [Looney Tunables (CVE-2023-4911) write-up](https://www.wiz.io/vulnerability-database/cve/cve-2023-4911)

{{#include ../../banners/hacktricks-training.md}}
