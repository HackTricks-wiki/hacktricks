# Memory Tagging Extension (MTE)

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

**Memory Tagging Extension (MTE)** έχει σχεδιαστεί για να ενισχύει την αξιοπιστία και την ασφάλεια του λογισμικού με την **ανίχνευση και την πρόληψη σφαλμάτων που σχετίζονται με τη μνήμη**, όπως οι υπερβάσεις buffer και οι ευπάθειες use-after-free. Το MTE, ως μέρος της **ARM** αρχιτεκτονικής, παρέχει έναν μηχανισμό για την προσθήκη ενός **μικρού tag σε κάθε κατανομή μνήμης** και ενός **αντίστοιχου tag σε κάθε δείκτη** που αναφέρεται σε αυτή τη μνήμη. Αυτή η προσέγγιση επιτρέπει την ανίχνευση παράνομων προσβάσεων μνήμης κατά την εκτέλεση, μειώνοντας σημαντικά τον κίνδυνο εκμετάλλευσης τέτοιων ευπαθειών για την εκτέλεση αυθαίρετου κώδικα.

### **How Memory Tagging Extension Works**

Το MTE λειτουργεί με **διαίρεση της μνήμης σε μικρές, σταθερού μεγέθους μπλοκ, με κάθε μπλοκ να έχει ανατεθεί ένα tag,** συνήθως μερικά bits σε μέγεθος.&#x20;

Όταν δημιουργείται ένας δείκτης για να δείξει σε αυτή τη μνήμη, αποκτά το ίδιο tag. Αυτό το tag αποθηκεύεται στα **αχρησιμοποίητα bits ενός δείκτη μνήμης**, συνδέοντας αποτελεσματικά τον δείκτη με το αντίστοιχο μπλοκ μνήμης.

<figure><img src="../../images/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Όταν ένα πρόγραμμα προσπελάσει τη μνήμη μέσω ενός δείκτη, το υλικό MTE ελέγχει ότι το **tag του δείκτη ταιριάζει με το tag του μπλοκ μνήμης**. Εάν τα tags **δεν ταιριάζουν**, αυτό υποδεικνύει μια **παράνομη πρόσβαση μνήμης.**

### MTE Pointer Tags

Τα tags μέσα σε έναν δείκτη αποθηκεύονται σε 4 bits μέσα στο ανώτερο byte:

<figure><img src="../../images/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Επομένως, αυτό επιτρέπει έως **16 διαφορετικές τιμές tag**.

### MTE Memory Tags

Κάθε **16B φυσικής μνήμης** έχει ένα αντίστοιχο **tag μνήμης**.

Τα tags μνήμης αποθηκεύονται σε μια **αφιερωμένη περιοχή RAM** (μη προσβάσιμη για κανονική χρήση). Έχοντας 4 bits tags για κάθε 16B tags μνήμης έως 3% της RAM.

Η ARM εισάγει τις παρακάτω εντολές για να χειριστεί αυτά τα tags στη αφιερωμένη μνήμη RAM:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Έλεγχος Λειτουργιών

### Συγχρονισμένος

Ο CPU ελέγχει τις ετικέτες **κατά την εκτέλεση της εντολής**, αν υπάρχει ασυμφωνία, προκαλεί μια εξαίρεση.\
Αυτός είναι ο πιο αργός και ασφαλής τρόπος.

### Ασύγχρονος

Ο CPU ελέγχει τις ετικέτες **ασύγχρονα**, και όταν βρεθεί μια ασυμφωνία, θέτει ένα bit εξαίρεσης σε μία από τις καταχωρήσεις του συστήματος. Είναι **ταχύτερος** από τον προηγούμενο αλλά είναι **ανίκανος να υποδείξει** την ακριβή εντολή που προκαλεί την ασυμφωνία και δεν προκαλεί την εξαίρεση αμέσως, δίνοντας λίγο χρόνο στον επιτιθέμενο να ολοκληρώσει την επίθεσή του.

### Μικτός

???

## Παραδείγματα Υλοποίησης & Ανίχνευσης

Ονομάζεται Hardware Tag-Based KASAN, MTE-based KASAN ή in-kernel MTE.\
Οι αλγόριθμοι του πυρήνα (όπως το `kmalloc`) θα **καλέσουν αυτό το module** το οποίο θα προετοιμάσει την ετικέτα για χρήση (τυχαία) και θα την επισυνάψει στη μνήμη του πυρήνα που έχει εκχωρηθεί και στον επιστρεφόμενο δείκτη.

Σημειώστε ότι θα **σημειώσει μόνο αρκετές μνήμες** (16B η καθεμία) για το ζητούμενο μέγεθος. Έτσι, αν το ζητούμενο μέγεθος ήταν 35 και δόθηκε μια πλάκα 60B, θα σημειώσει τα πρώτα 16\*3 = 48B με αυτή την ετικέτα και το **υπόλοιπο** θα είναι **σημειωμένο** με μια λεγόμενη **άκυρη ετικέτα (0xE)**.

Η ετικέτα **0xF** είναι η **ετικέτα που ταιριάζει σε όλους τους δείκτες**. Μια μνήμη με αυτόν τον δείκτη επιτρέπει **οποιαδήποτε ετικέτα να χρησιμοποιηθεί** για την πρόσβαση στη μνήμη της (χωρίς ασυμφωνίες). Αυτό θα μπορούσε να αποτρέψει το MET από το να ανιχνεύσει μια επίθεση αν αυτή η ετικέτα χρησιμοποιείται στη μνήμη που δέχεται την επίθεση.

Επομένως, υπάρχουν μόνο **14 τιμές** που μπορούν να χρησιμοποιηθούν για τη δημιουργία ετικετών καθώς οι 0xE και 0xF είναι δεσμευμένες, δίνοντας πιθανότητα **επανάχρησης ετικετών** 1/17 -> περίπου **7%**.

Αν ο πυρήνας έχει πρόσβαση στην **άκυρη μνήμη**, η **ασυμφωνία** θα **ανιχνευθεί**. Αν έχει πρόσβαση σε άλλη τοποθεσία μνήμης, αν η **μνήμη έχει διαφορετική ετικέτα** (ή την άκυρη ετικέτα) η ασυμφωνία θα **ανιχνευθεί**. Αν ο επιτιθέμενος είναι τυχερός και η μνήμη χρησιμοποιεί την ίδια ετικέτα, δεν θα ανιχνευθεί. Οι πιθανότητες είναι περίπου 7%.

Ένα άλλο σφάλμα συμβαίνει στην **τελευταία μνήμη** της εκχωρημένης μνήμης. Αν η εφαρμογή ζητήσει 35B, θα της δοθεί η μνήμη από 32 έως 48. Επομένως, τα **bytes από 36 έως 47 χρησιμοποιούν την ίδια ετικέτα** αλλά δεν ζητήθηκαν. Αν ο επιτιθέμενος έχει πρόσβαση **σε αυτά τα επιπλέον bytes, αυτό δεν ανιχνεύεται**.

Όταν εκτελείται το **`kfree()`**, η μνήμη επανασημαίνεται με την άκυρη ετικέτα μνήμης, έτσι σε μια **χρήση μετά την απελευθέρωση**, όταν η μνήμη προσπελαστεί ξανά, η **ασυμφωνία ανιχνεύεται**.

Ωστόσο, σε μια χρήση μετά την απελευθέρωση, αν το ίδιο **κομμάτι επανακατανεμηθεί ξανά με την ΙΔΙΑ ετικέτα** όπως προηγουμένως, ένας επιτιθέμενος θα μπορέσει να χρησιμοποιήσει αυτή την πρόσβαση και αυτό δεν θα ανιχνευθεί (περίπου 7% πιθανότητα).

Επιπλέον, μόνο οι **`slab` και `page_alloc`** χρησιμοποιούν ετικετοποιημένη μνήμη αλλά στο μέλλον αυτό θα χρησιμοποιηθεί επίσης σε `vmalloc`, `stack` και `globals` (τη στιγμή του βίντεο αυτά μπορούν ακόμα να καταχραστούν).

Όταν ανιχνεύεται μια **ασυμφωνία**, ο πυρήνας θα **πανικοβληθεί** για να αποτρέψει περαιτέρω εκμετάλλευση και επαναλήψεις της εκμετάλλευσης (το MTE δεν έχει ψευδώς θετικά).

## Αναφορές

- [https://www.youtube.com/watch?v=UwMt0e_dC_Q](https://www.youtube.com/watch?v=UwMt0e_dC_Q)

{{#include ../../banners/hacktricks-training.md}}
