# Memory Tagging Extension (MTE)

{{#include ../../banners/hacktricks-training.md}}

## Taarifa za Msingi

**Memory Tagging Extension (MTE)** imeundwa kuboresha uaminifu na usalama wa programu kwa **kugundua na kuzuia makosa yanayohusiana na memory**, kama buffer overflows na use-after-free vulnerabilities. MTE, kama sehemu ya **ARM** architecture, hutoa mekanismi ya kuambatisha **small tag kwa kila memory allocation** na **corresponding tag kwa kila pointer** inayorejelea memory hiyo. Mbinu hii inaruhusu kugundua illegal memory accesses wakati wa runtime, ikipunguza kwa kiasi kikubwa hatari ya kutumika kwa vulnerabilities hizo kwa ajili ya executing arbitrary code.

### Jinsi Memory Tagging Extension Inavyofanya Kazi

MTE hufanya kazi kwa **kugawa memory kwenye blocks ndogo za ukubwa uliowekwa, ambapo kila block inapangiwa tag,** kawaida chache bits kwa ukubwa.

Wakati pointer inapotengenezwa ili kurejelea memory hiyo, inapata tag ile ile. Tag hii inahifadhiwa kwenye **unused bits of a memory pointer**, ikiunganisha pointer na memory block inayolingana.

<figure><img src="../../images/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Wakati programu inapofikia memory kupitia pointer, hardware ya MTE inakagua kwamba **pointer's tag inafanana na memory block's tag**. Ikiwa tags **hazifani**, inaonyesha **illegal memory access.**

### MTE Pointer Tags

Tags ndani ya pointer zinahifadhiwa kwenye 4 bits ndani ya top byte:

<figure><img src="../../images/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Hivyo, hii inaruhusu hadi **16 different tag values**.

### MTE Memory Tags

Kila **16B of physical memory** ina corresponding **memory tag**.

Memory tags zinahifadhiwa katika **dedicated RAM region** (not accessible for normal usage). Kuwa na 4bits tags kwa kila 16B ya memory kunachukua hadi 3% ya RAM.

ARM introduces the following instructions to manipulate these tags in the dedicated RAM memory:
```asm
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Checking Modes

### Sync

The CPU huangalia tags **wakati wa utekelezaji wa maelekezo**, ikiwa kuna kutofautiana, inatoa exception (SIGSEGV na `SEGV_MTESERR`) na unapata mara moja kujua maelekezo na anwani kamili.\
Hii ni ya polepole zaidi na yenye usalama zaidi kwa sababu load/store iliyoathirika inazuumiwa.

### Async

The CPU huangalia tags **asynchronously**, na wakati kutofautiana kunapogundulika inaweka bit ya exception katika moja ya rejista za mfumo. Ni **haraka zaidi** kuliko ile ya awali lakini hawezi **kuonyesha** maelekezo maalum yaliyosababisha kutofautiana na haileti exception mara moja (`SIGSEGV` na `SEGV_MTEAERR`), ikimpa mkolaji muda wa kumaliza shambulio lake.

### Mixed

Mapendeleo kwa kila-core (kwa mfano kuandika `sync`, `async` au `asymm` kwenye `/sys/devices/system/cpu/cpu*/mte_tcf_preferred`) huruhusu kernels kuboresha au kupunguza kwa kimya ombi la kila-process, hivyo builds za uzalishaji kwa kawaida huomba ASYNC wakati cores zilizo na ruhusa zinawalazimisha SYNC wakati mzigo wa kazi unaruhusu.

## Implementation & Detection Examples

Inaitwa Hardware Tag-Based KASAN, MTE-based KASAN au in-kernel MTE.\
The kernel allocators (kama `kmalloc`) wata **call this module** ambayo itatayarisha tag ya kutumika (kwa nasibu) kuiweka kwenye nafasi ya kernel iliyotolewa na kwenye pointer iliyorejeshwa.

Kumbuka kuwa itataja **tu granules za kumbukumbu za kutosha** (16B kila moja) kwa ukubwa uliotakiwa. Hivyo kama ukubwa uliotakiwa ulikuwa 35 na slab ya 60B ilitolewa, itataja 16\*3 = 48B za kwanza na tag hii na **mabaki** yatakuwa **meja** na tag inayoitwa **invalid tag (0xE)**.

Tag **0xF** ni **match all pointer**. Kumbukumbu yenye pointer hii inaruhusu **tag yoyote kutumika** kufikia kumbukumbu yake (hakuna kutofautiana). Hii inaweza kuzuia MTE kugundua shambulio ikiwa tag hiyo inatumika kwenye kumbukumbu iliyoshambuliwa.

Kwa hivyo kuna tu **thamani 14** zinazoweza kutumika kuzalisha tags kwa kuwa 0xE na 0xF zimehifadhiwa, ikitoa uwezekano wa **kutumika tena kwa tags** wa 1/17 -> karibu **7%**.

Ikiwa kernel inafanya access kwenye granule ya tag isiyo halali, **kutofautiana** kuta **gunduliwa**. Ikiwa inafanya access kwenye eneo lingine la kumbukumbu na kumbukumbu hiyo ina tag tofauti (au tag isiyo halali) kutofautiana pia kutaonekana. Ikiwa mchapishaji ni mwenye bahati na kumbukumbu inatumia tag ile ile, haitagunduliwa. Nafasi ni karibu 7%.

Hitilafu nyingine hutokea kwenye **granule ya mwisho** ya kumbukumbu iliyotengewa. Ikiwa programu ilitaka 35B, ilipata granule kutoka 32 hadi 48. Kwa hivyo, **bytes kutoka 36 hadi 47 zinatumia tag ile ile** lakini hazikutokwa. Ikiwa mkolaji atafanya access kwa **bytes hizi za ziada, hili halitagunduliwa**.

Wakati **`kfree()`** inatekelezwa, kumbukumbu inaretagged na invalid memory tag, hivyo katika use-after-free, wakati kumbukumbu inafikiwa tena, **kutofautiana kutaonekana**.

Hata hivyo, katika use-after-free, ikiwa chunk ile ile inatengwa tena tena na tag ILE ILE kama awali, mkolaji ataweza kutumia access hii na hii haitagunduliwa (karibu 7% nafasi).

Zaidi ya hayo, ni **`slab` na `page_alloc`** tu zinazotumia tagged memory lakini siku za usoni hili pia litatumika katika `vmalloc`, `stack` na `globals` (wakati wa video hizi bado zinaweza kutumiwa vibaya).

Wakati **kutofautiana kunapotambulika** kernel ita **panic** kuzuia matumizi zaidi ya udanganyifu na jaribio la kushindwa la exploit (MTE haina false positives).

### Speculative Tag Leakage (TikTag)

*TikTag* (2024) ilionyesha gadgets mbili za speculative execution (TIKTAG-v1/v2) zenye uwezo wa leak tag ya utoaji ya 4-bit ya anwani yoyote ndani ya <4 sekunde kwa >95% mafanikio. Kwa kugusa kwa mtazamo cache lines zilizochaguliwa na attacker na kuangalia timing iliyosababishwa na prefetch, mkolaji anaweza derandomize tag iliyotengwa kwa michakato ya Chrome, huduma za mfumo za Android, au Linux kernel kisha kutengeneza pointers zinabeba the leaked value. Mara nafasi ya tag ikifukuzwa kwa brute-force, dhana za probabilistic granule reuse (`â‰ˆ7%` false-negative rate) zinavunjika na classic heap exploits (UAF, OOB) kurudi karibu 100% uaminifu hata wakati MTE imewezeshwa. Paper pia ina proof-of-concept exploits zinazobadilisha kutoka kwa tags zilizo leaked hadi retagging fake slabs, zikionyesha kuwa speculative side channels bado ni njia ya bypass ya mipango ya hardware tagging.

## References

- [https://www.youtube.com/watch?v=UwMt0e_dC_Q](https://www.youtube.com/watch?v=UwMt0e_dC_Q)
- [TikTag: Breaking ARM's Memory Tagging Extension with Speculative Execution](https://arxiv.org/abs/2406.08719)

{{#include ../../banners/hacktricks-training.md}}
