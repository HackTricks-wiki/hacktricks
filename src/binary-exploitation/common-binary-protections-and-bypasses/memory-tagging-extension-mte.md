# Memory Tagging Extension (MTE)

{{#include ../../banners/hacktricks-training.md}}

## Informazioni di Base

**Memory Tagging Extension (MTE)** è progettato per migliorare l'affidabilità e la sicurezza del software **rilevando e prevenendo errori legati alla memoria**, come buffer overflow e vulnerabilità use-after-free. MTE, come parte dell'architettura **ARM**, fornisce un meccanismo per allegare un **piccolo tag a ciascuna allocazione di memoria** e un **tag corrispondente a ciascun puntatore** che fa riferimento a quella memoria. Questo approccio consente di rilevare accessi illegali alla memoria durante l'esecuzione, riducendo significativamente il rischio di sfruttare tali vulnerabilità per eseguire codice arbitrario.

### **Come Funziona la Memory Tagging Extension**

MTE opera **dividendo la memoria in piccoli blocchi di dimensioni fisse, a ciascun blocco viene assegnato un tag,** tipicamente di pochi bit.

Quando viene creato un puntatore per puntare a quella memoria, riceve lo stesso tag. Questo tag è memorizzato nei **bit non utilizzati di un puntatore di memoria**, collegando efficacemente il puntatore al suo corrispondente blocco di memoria.

<figure><img src="../../images/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Quando un programma accede alla memoria tramite un puntatore, l'hardware MTE verifica che il **tag del puntatore corrisponda al tag del blocco di memoria**. Se i tag **non corrispondono**, indica un **accesso illegale alla memoria.**

### Tag dei Puntatori MTE

I tag all'interno di un puntatore sono memorizzati in 4 bit all'interno del byte superiore:

<figure><img src="../../images/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Pertanto, questo consente fino a **16 valori di tag diversi**.

### Tag di Memoria MTE

Ogni **16B di memoria fisica** ha un corrispondente **tag di memoria**.

I tag di memoria sono memorizzati in una **regione RAM dedicata** (non accessibile per uso normale). Avere tag di 4 bit per ogni 16B di tag di memoria fino al 3% della RAM.

ARM introduce le seguenti istruzioni per manipolare questi tag nella memoria RAM dedicata:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Controllo delle modalità

### Sync

La CPU controlla i tag **durante l'esecuzione dell'istruzione**, se c'è una discrepanza, solleva un'eccezione.\
Questo è il più lento e il più sicuro.

### Async

La CPU controlla i tag **in modo asincrono**, e quando viene trovata una discrepanza imposta un bit di eccezione in uno dei registri di sistema. È **più veloce** rispetto al precedente ma è **incapace di indicare** l'istruzione esatta che causa la discrepanza e non solleva immediatamente l'eccezione, dando un po' di tempo all'attaccante per completare il suo attacco.

### Mixed

???

## Esempi di implementazione e rilevamento

Chiamato Hardware Tag-Based KASAN, MTE-based KASAN o in-kernel MTE.\
Gli allocatori del kernel (come `kmalloc`) **chiameranno questo modulo** che preparerà il tag da utilizzare (in modo casuale) per attaccarlo allo spazio del kernel allocato e al puntatore restituito.

Nota che **contrassegnerà solo granuli di memoria sufficienti** (16B ciascuno) per la dimensione richiesta. Quindi, se la dimensione richiesta era 35 e un blocco di 60B è stato fornito, contrassegnerà i primi 16\*3 = 48B con questo tag e il **resto** sarà **contrassegnato** con un cosiddetto **tag non valido (0xE)**.

Il tag **0xF** è il **puntatore che corrisponde a tutti**. Una memoria con questo puntatore consente **di utilizzare qualsiasi tag** per accedere alla sua memoria (nessuna discrepanza). Questo potrebbe impedire a MET di rilevare un attacco se questo tag viene utilizzato nella memoria attaccata.

Pertanto ci sono solo **14 valori** che possono essere utilizzati per generare tag poiché 0xE e 0xF sono riservati, dando una probabilità di **riutilizzo dei tag** di 1/17 -> circa **7%**.

Se il kernel accede al **granulo di tag non valido**, la **discrepanza** sarà **rilevata**. Se accede a un'altra posizione di memoria, se la **memoria ha un tag diverso** (o il tag non valido) la discrepanza sarà **rilevata**. Se l'attaccante è fortunato e la memoria utilizza lo stesso tag, non sarà rilevata. Le probabilità sono circa 7%.

Un altro bug si verifica nell'**ultimo granulo** della memoria allocata. Se l'applicazione ha richiesto 35B, le è stato dato il granulo da 32 a 48. Pertanto, i **byte da 36 a 47 utilizzano lo stesso tag** ma non erano stati richiesti. Se l'attaccante accede a **questi byte extra, questo non viene rilevato**.

Quando viene eseguito **`kfree()`**, la memoria viene contrassegnata di nuovo con il tag di memoria non valido, quindi in un **use-after-free**, quando la memoria viene accessibile di nuovo, la **discrepanza viene rilevata**.

Tuttavia, in un use-after-free, se lo stesso **chunk viene riallocato di nuovo con lo STESSO tag** di prima, un attaccante sarà in grado di utilizzare questo accesso e questo non sarà rilevato (circa 7% di probabilità).

Inoltre, solo **`slab` e `page_alloc`** utilizzano memoria contrassegnata ma in futuro questo sarà utilizzato anche in `vmalloc`, `stack` e `globals` (al momento del video questi possono ancora essere abusati).

Quando una **discrepanza viene rilevata**, il kernel andrà in **panic** per prevenire ulteriori sfruttamenti e tentativi di sfruttamento (MTE non ha falsi positivi).

## Riferimenti

- [https://www.youtube.com/watch?v=UwMt0e_dC_Q](https://www.youtube.com/watch?v=UwMt0e_dC_Q)

{{#include ../../banners/hacktricks-training.md}}
