# Memory Tagging Extension (MTE)

{{#include ../../banners/hacktricks-training.md}}

## Osnovne Informacije

**Memory Tagging Extension (MTE)** je dizajniran da poboljša pouzdanost i sigurnost softvera tako što **otkriva i sprečava greške povezane sa memorijom**, kao što su buffer overflows i use-after-free ranjivosti. MTE, kao deo **ARM** arhitekture, pruža mehanizam za pridruživanje **malog taga svakoj alokaciji memorije** i **odgovarajućeg taga svakom pokazivaču** koji referencira tu memoriju. Ovaj pristup omogućava otkrivanje ilegalnih pristupa memoriji u vreme izvođenja, značajno smanjujući rizik od iskorišćavanja takvih ranjivosti za izvršavanje proizvoljnog koda.

### **Kako funkcioniše Memory Tagging Extension**

MTE funkcioniše tako što **deliti memoriju na male, fiksne blokove, pri čemu je svakom bloku dodeljen tag,** obično veličine nekoliko bita.

Kada se kreira pokazivač koji ukazuje na tu memoriju, dobija isti tag. Ovaj tag se čuva u **neiskorišćenim bitovima pokazivača u memoriji**, efektivno povezujući pokazivač sa odgovarajućim memorijskim blokom.

<figure><img src="../../images/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Kada program pristupa memoriji putem pokazivača, MTE hardver proverava da li **tag pokazivača odgovara tagu memorijskog bloka**. Ako se tagovi **ne poklapaju**, to ukazuje na **ilegalan pristup memoriji.**

### MTE Tagovi Pokazivača

Tagovi unutar pokazivača se čuvaju u 4 bita unutar gornjeg bajta:

<figure><img src="../../images/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Stoga, ovo omogućava do **16 različitih vrednosti taga**.

### MTE Tagovi Memorije

Svaka **16B fizičke memorije** ima odgovarajući **tag memorije**.

Tagovi memorije se čuvaju u **posvećenoj RAM oblasti** (koja nije dostupna za normalnu upotrebu). Imajući 4bita tagove za svaki 16B tag memorije do 3% RAM-a.

ARM uvodi sledeće instrukcije za manipulaciju ovim tagovima u posvećenoj RAM memoriji:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Proveravanje režima

### Sinhrono

CPU proverava oznake **tokom izvršavanja instrukcija**, ako dođe do neslaganja, podiže izuzetak.\
Ovo je najsporije i najbezbednije.

### Asinhrono

CPU proverava oznake **asinhrono**, i kada se pronađe neslaganje, postavlja bit izuzetka u jednom od sistemskih registara. To je **brže** od prethodnog, ali je **nesposobno da ukaže** na tačnu instrukciju koja je izazvala neslaganje i ne podiže izuzetak odmah, dajući malo vremena napadaču da završi svoj napad.

### Mešano

???

## Primeri implementacije i detekcije

Naziva se Hardware Tag-Based KASAN, MTE-based KASAN ili in-kernel MTE.\
Kernel alokatori (kao što je `kmalloc`) će **pozvati ovaj modul** koji će pripremiti oznaku za korišćenje (slučajno) i prikačiti je na alocirani kernel prostor i na vraćeni pokazivač.

Napomena da će **označiti samo dovoljno memorijskih granula** (16B svaka) za traženu veličinu. Dakle, ako je tražena veličina bila 35, a data je granula od 60B, označiće prvih 16\*3 = 48B ovom oznakom, a **ostatak** će biti **označen** takozvanom **nevažećom oznakom (0xE)**.

Oznaka **0xF** je **pokazivač koji se poklapa sa svime**. Memorija sa ovom oznakom omogućava **bilo koju oznaku da se koristi** za pristup njenoj memoriji (nema neslaganja). Ovo bi moglo sprečiti MET da detektuje napad ako se ove oznake koriste u napadnutoj memoriji.

Stoga postoji samo **14 vrednosti** koje se mogu koristiti za generisanje oznaka, jer su 0xE i 0xF rezervisane, što daje verovatnoću **ponovne upotrebe oznaka** od 1/17 -> oko **7%**.

Ako kernel pristupi **nevažećoj granuli**, **neslaganje** će biti **detektovano**. Ako pristupi drugoj memorijskoj lokaciji, ako **memorija ima drugačiju oznaku** (ili nevažeću oznaku), neslaganje će biti **detektovano**. Ako je napadač srećan i memorija koristi istu oznaku, to neće biti detektovano. Šanse su oko 7%.

Još jedna greška se javlja u **poslednjoj granuli** alocirane memorije. Ako je aplikacija tražila 35B, data je granula od 32 do 48. Stoga, **bajti od 36 do 47 koriste istu oznaku** ali nisu traženi. Ako napadač pristupi **ovim dodatnim bajtovima, to nije detektovano**.

Kada se izvrši **`kfree()`**, memorija se ponovo označava nevažećom memorijskom oznakom, tako da u **use-after-free**, kada se memorija ponovo pristupi, **neslaganje se detektuje**.

Međutim, u use-after-free, ako se isti **deo ponovo alocira sa ISTOM oznakom** kao prethodno, napadač će moći da iskoristi ovaj pristup i to neće biti detektovano (oko 7% šanse).

Štaviše, samo **`slab` i `page_alloc`** koriste označenu memoriju, ali će se u budućnosti ovo takođe koristiti u `vmalloc`, `stack` i `globals` (u trenutku snimanja videa, ove se još uvek mogu zloupotrebiti).

Kada se **neslaganje detektuje**, kernel će **panikovati** kako bi sprečio dalju eksploataciju i ponovne pokušaje eksploata. (MTE nema lažnih pozitivnih rezultata).

## Reference

- [https://www.youtube.com/watch?v=UwMt0e_dC_Q](https://www.youtube.com/watch?v=UwMt0e_dC_Q)

{{#include ../../banners/hacktricks-training.md}}
