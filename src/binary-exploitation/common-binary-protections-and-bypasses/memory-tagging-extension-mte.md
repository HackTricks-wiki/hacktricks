# Memory Tagging Extension (MTE)

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

**Memory Tagging Extension (MTE)** imeundwa ili kuboresha uaminifu na usalama wa programu kwa **kubaini na kuzuia makosa yanayohusiana na kumbukumbu**, kama vile buffer overflows na matumizi baada ya kuachiliwa. MTE, kama sehemu ya **ARM** architecture, inatoa mekanizma ya kuambatanisha **lebo ndogo kwa kila allocation ya kumbukumbu** na **lebo inayolingana kwa kila pointer** inayorejelea kumbukumbu hiyo. Njia hii inaruhusu kubaini upatikanaji haramu wa kumbukumbu wakati wa utekelezaji, ikipunguza kwa kiasi kikubwa hatari ya kutumia udhaifu kama huo kutekeleza msimbo usio na mipaka.

### **How Memory Tagging Extension Works**

MTE inafanya kazi kwa **kugawanya kumbukumbu katika blocks ndogo, zenye ukubwa thabiti, ambapo kila block inapata lebo,** kwa kawaida bits chache kwa ukubwa.

Wakati pointer inaundwa kuashiria kumbukumbu hiyo, inapata lebo hiyo hiyo. Lebo hii inahifadhiwa katika **bits zisizotumika za pointer ya kumbukumbu**, ikifunga pointer hiyo na block yake inayolingana ya kumbukumbu.

<figure><img src="../../images/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Wakati programu inapata kumbukumbu kupitia pointer, vifaa vya MTE vinakagua kwamba **lebo ya pointer inalingana na lebo ya block ya kumbukumbu**. Ikiwa lebo hizo **hazilingani**, inaashiria **upatikanaji haramu wa kumbukumbu.**

### MTE Pointer Tags

Lebos ndani ya pointer zinahifadhiwa katika bits 4 ndani ya byte ya juu:

<figure><img src="../../images/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Hivyo, hii inaruhusu hadi **maadili tofauti 16 ya lebo.**

### MTE Memory Tags

Kila **16B ya kumbukumbu halisi** ina lebo inayolingana ya **kumbukumbu.**

Lebos za kumbukumbu zinahifadhiwa katika **eneo maalum la RAM** (lisilopatikana kwa matumizi ya kawaida). Kuwa na lebo za bits 4 kwa kila lebo ya kumbukumbu ya 16B hadi 3% ya RAM.

ARM inintroduce maagizo yafuatayo ili kudhibiti lebo hizi katika kumbukumbu maalum ya RAM:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Checking Modes

### Sync

CPU inakagua lebo **wakati wa kutekeleza maagizo**, ikiwa kuna tofauti, inainua kivunjaji.\
Hii ni polepole zaidi na salama zaidi.

### Async

CPU inakagua lebo **kwa njia isiyo ya kawaida**, na wakati tofauti inapatikana inaset kivunjaji katika moja ya register za mfumo. Ni **haraka** kuliko ile ya awali lakini haiwezi **kuonyesha** maagizo halisi yanayosababisha tofauti na haionyeshi kivunjaji mara moja, ikitoa muda kwa mshambuliaji kukamilisha shambulio lake.

### Mixed

???

## Implementation & Detection Examples

Inaitwa Hardware Tag-Based KASAN, MTE-based KASAN au in-kernel MTE.\
Wagawaji wa kernel (kama `kmalloc`) wata **ita moduli hii** ambayo itajiandaa lebo ya kutumia (kwa bahati nasibu) kuunganisha na nafasi ya kernel iliyotolewa na pointer iliyorejeshwa.

Kumbuka kwamba itakuwa **inaashiria granules za kumbukumbu za kutosha** (16B kila moja) kwa saizi iliyohitajika. Hivyo ikiwa saizi iliyohitajika ilikuwa 35 na slab ya 60B ilitolewa, itashiria 16\*3 = 48B na lebo hii na **zingine** zitakuwa **zimeashiriwa** na lebo inayoitwa **lebo isiyo sahihi (0xE)**.

Lebo **0xF** ni **pointer inayolingana na zote**. Kumbukumbu yenye pointer hii inaruhusu **lebo yoyote kutumika** kufikia kumbukumbu yake (hakuna tofauti). Hii inaweza kuzuia MET kugundua shambulio ikiwa lebo hizi zinatumika katika kumbukumbu iliyoshambuliwa.

Kwa hivyo kuna **thamani 14** tu zinazoweza kutumika kuunda lebo kwani 0xE na 0xF zimehifadhiwa, ikitoa uwezekano wa **kurudia lebo** kuwa 1/17 -> karibu **7%**.

Ikiwa kernel inapata **granule ya lebo isiyo sahihi**, **tofauti** itagunduliwa. Ikiwa inapata eneo lingine la kumbukumbu, ikiwa **kumbukumbu ina lebo tofauti** (au lebo isiyo sahihi) tofauti itagunduliwa. Ikiwa mshambuliaji ana bahati na kumbukumbu inatumia lebo ile ile, haitagunduliwa. Uwezekano ni karibu 7%

Kosa lingine linatokea katika **granule ya mwisho** ya kumbukumbu iliyotolewa. Ikiwa programu ilihitaji 35B, ilipatiwa granule kutoka 32 hadi 48. Kwa hivyo, **bytes kutoka 36 hadi 47 zinatumia lebo ile ile** lakini hazikuhitajika. Ikiwa mshambuliaji anapata **bytes hizi za ziada, hii haitagunduliwa**.

Wakati **`kfree()`** inatekelezwa, kumbukumbu inarejeshwa na lebo isiyo sahihi, hivyo katika **matumizi baada ya uhuru**, wakati kumbukumbu inapata tena, **tofauti inagunduliwa**.

Hata hivyo, katika matumizi baada ya uhuru, ikiwa **kipande kile kile kinarejeshwa tena na lebo ILE ILE** kama awali, mshambuliaji ataweza kutumia ufikiaji huu na hii haitagunduliwa (karibu 7% uwezekano).

Zaidi ya hayo, ni **`slab` na `page_alloc`** pekee zinazotumia kumbukumbu iliyo na lebo lakini katika siku zijazo hii pia itatumika katika `vmalloc`, `stack` na `globals` (wakati wa video hizi bado zinaweza kutumiwa vibaya).

Wakati **tofauti inagunduliwa** kernel itakuwa **na wasiwasi** ili kuzuia unyonyaji zaidi na majaribio ya unyonyaji (MTE haina matokeo ya uwongo).

## References

- [https://www.youtube.com/watch?v=UwMt0e_dC_Q](https://www.youtube.com/watch?v=UwMt0e_dC_Q)

{{#include ../../banners/hacktricks-training.md}}
