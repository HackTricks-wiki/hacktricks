# Επέκταση Επισήμανσης Μνήμης (MTE)

{{#include ../../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

**Memory Tagging Extension (MTE)** έχει σχεδιαστεί για να αυξήσει την αξιοπιστία και την ασφάλεια του λογισμικού με **τον εντοπισμό και την πρόληψη σφαλμάτων που σχετίζονται με τη μνήμη**, όπως buffer overflows και use-after-free ευπάθειες. Το MTE, ως μέρος της **ARM** αρχιτεκτονικής, παρέχει έναν μηχανισμό για να επισυνάπτεται ένα **μικρό tag σε κάθε κατανομή μνήμης** και ένα **αντίστοιχο tag σε κάθε pointer** που αναφέρεται σε αυτή τη μνήμη. Αυτή η προσέγγιση επιτρέπει τον εντοπισμό παράνομων προσβάσεων μνήμης κατά το runtime, μειώνοντας σημαντικά τον κίνδυνο εκμετάλλευσης τέτοιων ευπαθειών για την εκτέλεση arbitrary code.

### **Πώς λειτουργεί η Memory Tagging Extension**

Το MTE λειτουργεί διαιρώντας τη μνήμη σε μικρές, σταθερού μεγέθους περιοχές, με κάθε block να αντιστοιχίζεται σε ένα tag, συνήθως μερικά bits σε μέγεθος.

Όταν δημιουργείται ένας pointer που δείχνει σε αυτή τη μνήμη, αποκτά τον ίδιο tag. Αυτό το tag αποθηκεύεται στα **μη χρησιμοποιούμενα bits ενός memory pointer**, συνδέοντας πρακτικά τον pointer με το αντίστοιχο memory block του.

<figure><img src="../../images/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Όταν ένα πρόγραμμα προσπελάζει τη μνήμη μέσω ενός pointer, το MTE hardware ελέγχει ότι το **tag του pointer ταιριάζει με το tag του memory block**. Εάν τα tags **δεν ταιριάζουν**, αυτό υποδηλώνει μια **παράνομη πρόσβαση μνήμης.**

### MTE Pointer Tags

Τα tags μέσα σε έναν pointer αποθηκεύονται σε 4 bits μέσα στο υψηλότερο byte:

<figure><img src="../../images/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Επομένως, αυτό επιτρέπει έως και **16 διαφορετικές τιμές tag**.

### MTE Memory Tags

Κάθε **16B φυσικής μνήμης** έχει ένα αντίστοιχο **memory tag**.

Τα memory tags αποθηκεύονται σε μια **αφιερωμένη περιοχή RAM** (μη προσβάσιμη για κανονική χρήση). Η ύπαρξη 4-bit tags για κάθε 16B μνήμης μπορεί να καταλάβει έως και 3% της RAM.

ARM εισάγει τις ακόλουθες instructions για να χειριστεί αυτά τα tags στην αφιερωμένη περιοχή RAM:
```asm
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Checking Modes

### Sync

Η CPU ελέγχει τα tags **during the instruction executing**, αν υπάρχει mismatch, προκαλεί exception (SIGSEGV με `SEGV_MTESERR`) και γνωρίζεις αμέσως την ακριβή εντολή και διεύθυνση.\
Αυτός είναι ο πιο αργός αλλά και ο πιο ασφαλής τρόπος γιατί το προβληματικό load/store μπλοκάρεται.

### Async

Η CPU ελέγχει τα tags **asynchronously**, και όταν βρεθεί mismatch θέτει ένα bit exception σε ένα από τα system registers. Είναι **πιο γρήγορο** από το προηγούμενο αλλά **δεν μπορεί να υποδείξει** την ακριβή εντολή που προκάλεσε το mismatch και δεν σηκώνει αμέσως το exception (`SIGSEGV` με `SEGV_MTEAERR`), δίνοντας χρόνο στον attacker να ολοκληρώσει την επίθεση.

### Mixed

Οι per-core προτιμήσεις (για παράδειγμα γράφοντας `sync`, `async` ή `asymm` σε `/sys/devices/system/cpu/cpu*/mte_tcf_preferred`) επιτρέπουν στους kernels να αναβαθμίζουν ή να υποβαθμίζουν αθόρυβα τα per-process αιτήματα, έτσι τα production builds συνήθως ζητούν ASYNC ενώ οι privileged cores επιβάλλουν SYNC όταν το workload το επιτρέπει.

## Implementation & Detection Examples

Called Hardware Tag-Based KASAN, MTE-based KASAN or in-kernel MTE.\
Οι kernel allocators (όπως `kmalloc`) θα **call this module** το οποίο θα προετοιμάσει τυχαία το tag, θα το συσχετίσει με την allocated kernel memory και με τον returned pointer.

Σημειώστε ότι θα **σημειώσει μόνο αρκετά memory granules** (16B το καθένα) για το ζητούμενο μέγεθος. Οπότε αν το ζητούμενο μέγεθος ήταν 35 και δόθηκε ένα slab των 60B, θα σηματοδοτήσει τα πρώτα 16\*3 = 48B με αυτό το tag και το **υπόλοιπο** θα **σημειωθεί** με ένα λεγόμενο **invalid tag (0xE)**.

Το tag **0xF** είναι ο **match all pointer**. Μνήμη με αυτό το pointer επιτρέπει **οποιοδήποτε tag** να χρησιμοποιηθεί για πρόσβαση στη μνήμη της (χωρίς mismatches). Αυτό μπορεί να εμποδίσει το MTE από το να ανιχνεύσει μια επίθεση αν το συγκεκριμένο tag χρησιμοποιείται στη στοχευόμενη μνήμη.

Επομένως υπάρχουν μόνο **14 τιμές** που μπορούν να χρησιμοποιηθούν για τη δημιουργία tags καθώς τα 0xE και 0xF είναι reserved, δίνοντας πιθανότητα **επανάχρησης tags** 1/17 -> περίπου **7%**.

Αν ο kernel προσπελάσει ένα **invalid tag granule**, το **mismatch** θα **ανιχνευτεί**. Αν προσπελάσει άλλη θέση μνήμης και η **μνήμη έχει διαφορετικό tag** (ή το invalid tag) το mismatch επίσης θα ανιχνευτεί. Αν ο attacker είναι τυχερός και η μνήμη χρησιμοποιεί το ίδιο tag, δεν θα ανιχνευτεί. Οι πιθανότητες είναι περίπου 7%.

Ένα άλλο bug εμφανίζεται στο **τελευταίο granule** της allocated μνήμης. Αν η εφαρμογή ζήτησε 35B, της δόθηκε το granule από 32 έως 48. Επομένως, τα **bytes από 36 έως 47 χρησιμοποιούν το ίδιο tag** αλλά δεν είχαν ζητηθεί. Αν ο attacker προσπελάσει **αυτά τα επιπλέον bytes, αυτό δεν ανιχνεύεται**.

Όταν εκτελείται **`kfree()`**, η μνήμη retagged με το invalid memory tag, οπότε σε ένα **use-after-free**, όταν η μνήμη προσπελαστεί ξανά, το **mismatch ανιχνεύεται**.

Ωστόσο, σε ένα use-after-free, αν το ίδιο **chunk επανα-κατανεμηθεί με το ΙΔΙΟ tag** όπως προηγουμένως, ένας attacker θα μπορέσει να χρησιμοποιήσει αυτή την πρόσβαση και αυτό δεν θα ανιχνευτεί (περίπου 7% πιθανότητα).

Επιπλέον, μόνο **`slab` και `page_alloc`** χρησιμοποιούν tagged memory αλλά στο μέλλον αυτό θα χρησιμοποιηθεί και σε `vmalloc`, `stack` και `globals` (την στιγμή του video αυτά μπορούν ακόμα να κακοποιηθούν).

Όταν ένα **mismatch ανιχνεύεται** ο kernel θα **panic** για να αποτρέψει περαιτέρω exploitation και retries του exploit (MTE δεν έχει false positives).

### Speculative Tag Leakage (TikTag)

*TikTag* (2024) demonstrated two speculative execution gadgets (TIKTAG-v1/v2) able to leak the 4-bit allocation tag of any address in <4 seconds with >95% success. Με το speculative touching attacker-chosen cache lines και παρατηρώντας prefetch-induced timing, ένας attacker μπορεί να derandomize το tag που αντιστοιχίστηκε σε Chrome processes, Android system services, ή τον Linux kernel και στη συνέχεια να κατασκευάσει pointers που φέρουν την leaked τιμή. Μόλις ο χώρος των tags brute-forced away, οι probabilistic granule reuse υποθέσεις (`≈7%` false-negative rate) καταρρέουν και τα κλασικά heap exploits (UAF, OOB) ανακτούν σχεδόν 100% αξιοπιστία ακόμη και όταν MTE είναι ενεργοποιημένο. Το paper επίσης περιλαμβάνει proof-of-concept exploits που κάνουν pivot από leaked tags σε retagging fake slabs, δείχνοντας ότι speculative side channels παραμένουν ένα βιώσιμο bypass path για hardware tagging schemes.

## References

- [https://www.youtube.com/watch?v=UwMt0e_dC_Q](https://www.youtube.com/watch?v=UwMt0e_dC_Q)
- [TikTag: Breaking ARM's Memory Tagging Extension with Speculative Execution](https://arxiv.org/abs/2406.08719)

{{#include ../../banners/hacktricks-training.md}}
