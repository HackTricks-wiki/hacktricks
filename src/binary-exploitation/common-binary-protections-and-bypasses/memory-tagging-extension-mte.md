# Memory Tagging Extension (MTE)

{{#include ../../banners/hacktricks-training.md}}

## 基本信息

**Memory Tagging Extension (MTE)** 旨在通过 **检测和防止与内存相关的错误** 来增强软件的可靠性和安全性，例如缓冲区溢出和使用后释放漏洞。MTE 作为 **ARM** 架构的一部分，提供了一种机制，将 **小标签附加到每个内存分配** 上，并为引用该内存的 **每个指针分配一个相应的标签**。这种方法允许在运行时检测非法内存访问，显著降低利用这些漏洞执行任意代码的风险。

### **Memory Tagging Extension 的工作原理**

MTE 通过 **将内存划分为小的固定大小块，每个块分配一个标签** 来操作，通常标签的大小为几位。&#x20;

当创建一个指针指向该内存时，它会获得相同的标签。这个标签存储在 **内存指针的未使用位中**，有效地将指针与其对应的内存块链接起来。

<figure><img src="../../images/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

当程序通过指针访问内存时，MTE 硬件会检查 **指针的标签是否与内存块的标签匹配**。如果标签 **不匹配**，则表示 **非法内存访问**。

### MTE 指针标签

指针内部的标签存储在顶部字节的 4 位中：

<figure><img src="../../images/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

因此，这允许最多 **16 种不同的标签值**。

### MTE 内存标签

每 **16B 的物理内存** 都有一个相应的 **内存标签**。

内存标签存储在 **专用 RAM 区域**（不供正常使用）。每 16B 内存标签有 4 位标签，最多占用 3% 的 RAM。

ARM 引入了以下指令来操作这些专用 RAM 内存中的标签：
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## 检查模式

### 同步

CPU 在 **指令执行期间** 检查标签，如果存在不匹配，它会引发异常。\
这是最慢且最安全的模式。

### 异步

CPU **异步** 检查标签，当发现不匹配时，它会在系统寄存器之一中设置异常位。它比前一种模式 **更快**，但 **无法指出** 导致不匹配的确切指令，并且不会立即引发异常，给攻击者一些时间来完成攻击。

### 混合

???

## 实现与检测示例

称为硬件标签基础的 KASAN、基于 MTE 的 KASAN 或内核中的 MTE。\
内核分配器（如 `kmalloc`）将 **调用此模块**，该模块将准备使用的标签（随机）附加到分配的内核空间和返回的指针。

请注意，它将 **仅标记足够的内存粒度**（每个 16B）以满足请求的大小。因此，如果请求的大小为 35，而给定的块为 60B，它将用此标签标记前 16\*3 = 48B，**其余部分**将被 **标记** 为所谓的 **无效标签 (0xE)**。

标签 **0xF** 是 **匹配所有指针**。具有此指针的内存允许 **使用任何标签** 访问其内存（没有不匹配）。如果在被攻击的内存中使用此标签，可能会阻止 MET 检测到攻击。

因此，只有 **14 个值** 可以用于生成标签，因为 0xE 和 0xF 是保留的，这使得 **重用标签** 的概率为 1/17 -> 大约 **7%**。

如果内核访问 **无效标签粒度**，将会 **检测到不匹配**。如果访问另一个内存位置，如果 **内存有不同的标签**（或无效标签），将会 **检测到不匹配**。如果攻击者运气好，内存使用相同的标签，则不会被检测到。几率大约为 7%。

另一个错误发生在分配内存的 **最后粒度**。如果应用程序请求 35B，它将获得从 32 到 48 的粒度。因此，**从 36 到 47 的字节使用相同的标签**，但它们并未被请求。如果攻击者访问 **这些额外字节，将不会被检测到**。

当 **`kfree()`** 被执行时，内存会被重新标记为无效内存标签，因此在 **使用后释放** 的情况下，当再次访问内存时，将会 **检测到不匹配**。

然而，在使用后释放的情况下，如果同一 **块再次以相同的标签** 重新分配，攻击者将能够利用此访问，并且不会被检测到（大约 7% 的机会）。

此外，只有 **`slab` 和 `page_alloc`** 使用标记内存，但将来这也将在 `vmalloc`、`stack` 和 `globals` 中使用（在视频时，这些仍然可以被滥用）。

当 **检测到不匹配** 时，内核将 **恐慌** 以防止进一步的利用和攻击重试（MTE 没有误报）。

## 参考文献

- [https://www.youtube.com/watch?v=UwMt0e_dC_Q](https://www.youtube.com/watch?v=UwMt0e_dC_Q)

{{#include ../../banners/hacktricks-training.md}}
