# Memory Tagging Extension (MTE)

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

**Memory Tagging Extension (MTE)** призначена для підвищення надійності та безпеки програмного забезпечення шляхом **виявлення та запобігання помилкам, пов'язаним з пам'яттю**, таким як переповнення буфера та вразливості використання після звільнення. MTE, як частина архітектури **ARM**, надає механізм для прикріплення **малого тегу до кожного виділення пам'яті** та **відповідного тегу до кожного вказівника**, що посилається на цю пам'ять. Цей підхід дозволяє виявляти незаконні доступи до пам'яті під час виконання, значно зменшуючи ризик експлуатації таких вразливостей для виконання довільного коду.

### **How Memory Tagging Extension Works**

MTE працює, **ділячи пам'ять на маленькі блоки фіксованого розміру, кожному блоку присвоюється тег,** зазвичай розміром кілька біт.&#x20;

Коли створюється вказівник, що вказує на цю пам'ять, він отримує той же тег. Цей тег зберігається в **невикористаних бітах вказівника пам'яті**, ефективно пов'язуючи вказівник з відповідним блоком пам'яті.

<figure><img src="../../images/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Коли програма отримує доступ до пам'яті через вказівник, апаратне забезпечення MTE перевіряє, чи **збігається тег вказівника з тегом блоку пам'яті**. Якщо теги **не збігаються**, це вказує на **незаконний доступ до пам'яті.**

### MTE Pointer Tags

Теги всередині вказівника зберігаються в 4 бітах у верхньому байті:

<figure><img src="../../images/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Отже, це дозволяє мати до **16 різних значень тегів**.

### MTE Memory Tags

Кожні **16B фізичної пам'яті** мають відповідний **тег пам'яті**.

Теги пам'яті зберігаються в **призначеній області RAM** (недоступній для звичайного використання). Маючи 4 біти тегів для кожних 16B тегів пам'яті, до 3% RAM.

ARM вводить наступні інструкції для маніпуляції цими тегами в призначеній пам'яті RAM:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Перевірка режимів

### Синхронний

ЦП перевіряє теги **під час виконання інструкції**, якщо є невідповідність, він викликає виключення.\
Це найповільніший і найнадійніший режим.

### Асинхронний

ЦП перевіряє теги **асинхронно**, і коли виявляється невідповідність, він встановлює біт виключення в одному з системних регістрів. Це **швидше** за попередній режим, але **не може вказати** на точну інструкцію, яка викликала невідповідність, і не викликає виключення негайно, даючи деякий час атакуючому для завершення атаки.

### Змішаний

???

## Приклади реалізації та виявлення

Називається Hardware Tag-Based KASAN, MTE-based KASAN або in-kernel MTE.\
Аллокатори ядра (як `kmalloc`) **викликатимуть цей модуль**, який підготує тег для використання (випадковим чином) і прикріпить його до виділеного простору ядра та до повернутого вказівника.

Зверніть увагу, що він **позначить лише достатню кількість гранул пам'яті** (по 16B кожна) для запитуваного розміру. Тож, якщо запитуваний розмір становив 35, а був наданий блок розміром 60B, він позначить перші 16\*3 = 48B цим тегом, а **решта** буде **позначена** так званим **недійсним тегом (0xE)**.

Тег **0xF** є **вказівником, що відповідає всім**. Пам'ять з цим вказівником дозволяє **використовувати будь-який тег** для доступу до її пам'яті (без невідповідностей). Це може запобігти виявленню атаки MET, якщо цей тег використовується в атакованій пам'яті.

Отже, існує лише **14 значень**, які можна використовувати для генерації тегів, оскільки 0xE і 0xF зарезервовані, що дає ймовірність **повторного використання тегів** 1/17 -> близько **7%**.

Якщо ядро отримує доступ до **недійсної гранули тегу**, **невідповідність** буде **виявлена**. Якщо воно отримує доступ до іншого місця пам'яті, якщо **пам'ять має інший тег** (або недійсний тег), невідповідність буде **виявлена**. Якщо атакуючий щасливий і пам'ять використовує той самий тег, це не буде виявлено. Ймовірність близько 7%.

Ще одна помилка виникає в **останній гранулі** виділеної пам'яті. Якщо програма запитала 35B, їй була надана гранула з 32 до 48. Тому **байти з 36 до 47 використовують той самий тег**, але їх не запитували. Якщо атакуючий отримує доступ до **цих додаткових байтів, це не виявляється**.

Коли виконується **`kfree()`**, пам'ять повторно позначається недійсним тегом пам'яті, тому в **використанні після звільнення**, коли пам'ять знову доступна, **невідповідність виявляється**.

Однак у випадку використання після звільнення, якщо той самий **блок повторно виділяється з ТИМ ЖЕ тегом**, як раніше, атакуючий зможе використовувати цей доступ, і це не буде виявлено (близько 7% ймовірності).

Більше того, лише **`slab` і `page_alloc`** використовують теговану пам'ять, але в майбутньому це також буде використовуватися в `vmalloc`, `stack` і `globals` (на момент відео їх все ще можна зловживати).

Коли **виявляється невідповідність**, ядро **панікує**, щоб запобігти подальшій експлуатації та повторним спробам експлуатації (MTE не має хибнопозитивних результатів).

## Посилання

- [https://www.youtube.com/watch?v=UwMt0e_dC_Q](https://www.youtube.com/watch?v=UwMt0e_dC_Q)

{{#include ../../banners/hacktricks-training.md}}
