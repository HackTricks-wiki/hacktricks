# Memory Tagging Extension (MTE)

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

**Memory Tagging Extension (MTE)** को सॉफ़्टवेयर की विश्वसनीयता और सुरक्षा को बढ़ाने के लिए डिज़ाइन किया गया है, **मेमोरी से संबंधित त्रुटियों** का **पता लगाने और रोकने** के लिए, जैसे कि बफर ओवरफ्लो और उपयोग के बाद मुक्त होने वाली कमजोरियाँ। MTE, **ARM** आर्किटेक्चर का एक हिस्सा, प्रत्येक मेमोरी आवंटन के लिए एक **छोटा टैग संलग्न करने** और उस मेमोरी को संदर्भित करने वाले प्रत्येक पॉइंटर के लिए एक **संबंधित टैग** प्रदान करता है। यह दृष्टिकोण रनटाइम पर अवैध मेमोरी एक्सेस का पता लगाने की अनुमति देता है, जिससे ऐसे कमजोरियों का शोषण करके मनमाने कोड को निष्पादित करने का जोखिम काफी कम हो जाता है।

### **How Memory Tagging Extension Works**

MTE **मेमोरी को छोटे, निश्चित आकार के ब्लॉकों में विभाजित करके काम करता है, प्रत्येक ब्लॉक को एक टैग सौंपा जाता है,** जो आमतौर पर कुछ बिट्स का आकार होता है।

जब एक पॉइंटर उस मेमोरी की ओर इशारा करने के लिए बनाया जाता है, तो उसे वही टैग मिलता है। यह टैग **मेमोरी पॉइंटर के अप्रयुक्त बिट्स में** संग्रहीत होता है, प्रभावी रूप से पॉइंटर को उसके संबंधित मेमोरी ब्लॉक से जोड़ता है।

<figure><img src="../../images/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

जब एक प्रोग्राम पॉइंटर के माध्यम से मेमोरी तक पहुँचता है, तो MTE हार्डवेयर यह जांचता है कि **पॉइंटर का टैग मेमोरी ब्लॉक के टैग से मेल खाता है**। यदि टैग **मेल नहीं खाते**, तो यह एक **अवैध मेमोरी एक्सेस** को इंगित करता है।

### MTE Pointer Tags

पॉइंटर के अंदर टैग 4 बिट्स में शीर्ष बाइट के अंदर संग्रहीत होते हैं:

<figure><img src="../../images/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

इसलिए, यह **16 विभिन्न टैग मानों** की अनुमति देता है।

### MTE Memory Tags

हर **16B भौतिक मेमोरी** का एक संबंधित **मेमोरी टैग** होता है।

मेमोरी टैग को **समर्पित RAM क्षेत्र** में संग्रहीत किया जाता है (सामान्य उपयोग के लिए सुलभ नहीं)। हर 16B मेमोरी टैग के लिए 4 बिट्स टैग होने से RAM का 3% तक हो सकता है।

ARM इन टैग्स को समर्पित RAM मेमोरी में प्रबंधित करने के लिए निम्नलिखित निर्देश पेश करता है:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Checking Modes

### Sync

CPU टैग को **निर्देश निष्पादन के दौरान** चेक करता है, यदि कोई असंगति होती है, तो यह एक अपवाद उठाता है।\
यह सबसे धीमा और सबसे सुरक्षित है।

### Async

CPU टैग को **असिंक्रोनसली** चेक करता है, और जब कोई असंगति पाई जाती है, तो यह सिस्टम रजिस्टर में एक अपवाद बिट सेट करता है। यह पिछले तरीके से **तेज़** है लेकिन यह **सटीक निर्देश को इंगित करने में असमर्थ** है जो असंगति का कारण बनता है और यह तुरंत अपवाद नहीं उठाता, जिससे हमलावर को अपने हमले को पूरा करने के लिए कुछ समय मिलता है।

### Mixed

???

## Implementation & Detection Examples

इसे हार्डवेयर टैग-आधारित KASAN, MTE-आधारित KASAN या इन-कर्नेल MTE कहा जाता है।\
कर्नेल आवंटक (जैसे `kmalloc`) इस **मॉड्यूल को कॉल करेंगे** जो उपयोग के लिए टैग तैयार करेगा (यादृच्छिक रूप से) इसे कर्नेल स्पेस आवंटित और लौटाए गए पॉइंटर से जोड़ने के लिए।

ध्यान दें कि यह **केवल पर्याप्त मेमोरी ग्रेन्यूल्स** (प्रत्येक 16B) को अनुरोधित आकार के लिए चिह्नित करेगा। इसलिए यदि अनुरोधित आकार 35 था और 60B का एक स्लैब दिया गया, तो यह पहले 16\*3 = 48B को इस टैग के साथ चिह्नित करेगा और **बाकी** को एक तथाकथित **अमान्य टैग (0xE)** के साथ **चिह्नित** करेगा।

टैग **0xF** **सभी पॉइंटर से मेल खाता है**। इस पॉइंटर के साथ एक मेमोरी **किसी भी टैग का उपयोग** करने की अनुमति देती है ताकि इसकी मेमोरी तक पहुंचा जा सके (कोई असंगति नहीं)। यदि इस टैग का उपयोग हमले की गई मेमोरी में किया जा रहा है, तो यह MET को हमले का पता लगाने से रोक सकता है।

इसलिए केवल **14 मान** हैं जो टैग उत्पन्न करने के लिए उपयोग किए जा सकते हैं क्योंकि 0xE और 0xF आरक्षित हैं, जिससे टैग **पुन: उपयोग** की संभावना 1/17 -> लगभग **7%** हो जाती है।

यदि कर्नेल **अमान्य टैग ग्रेन्यूल** तक पहुंचता है, तो **असंगति** **पता लगाई जाएगी**। यदि यह किसी अन्य मेमोरी स्थान तक पहुंचता है, यदि **मेमोरी में एक अलग टैग** (या अमान्य टैग) है तो असंगति **पता लगाई जाएगी।** यदि हमलावर भाग्यशाली है और मेमोरी उसी टैग का उपयोग कर रही है, तो यह पता नहीं चलेगा। संभावनाएँ लगभग 7% हैं।

एक और बग आवंटित मेमोरी के **अंतिम ग्रेन्यूल** में होता है। यदि एप्लिकेशन ने 35B का अनुरोध किया, तो इसे 32 से 48 तक का ग्रेन्यूल दिया गया। इसलिए, **36 से 47 तक के बाइट्स उसी टैग का उपयोग कर रहे हैं** लेकिन उन्हें अनुरोध नहीं किया गया था। यदि हमलावर **इन अतिरिक्त बाइट्स तक पहुंचता है, तो यह पता नहीं चलेगा**।

जब **`kfree()`** निष्पादित होता है, तो मेमोरी को अमान्य मेमोरी टैग के साथ फिर से टैग किया जाता है, इसलिए एक **यूज़-आफ्टर-फ्री** में, जब मेमोरी को फिर से एक्सेस किया जाता है, तो **असंगति का पता लगाया जाता है**।

हालांकि, एक यूज़-आफ्टर-फ्री में, यदि वही **चंक फिर से उसी टैग के साथ आवंटित किया जाता है** जैसा पहले था, तो एक हमलावर इस एक्सेस का उपयोग कर सकेगा और यह पता नहीं चलेगा (लगभग 7% संभावना)।

इसके अलावा, केवल **`slab` और `page_alloc`** टैग की गई मेमोरी का उपयोग करते हैं लेकिन भविष्य में इसका उपयोग `vmalloc`, `stack` और `globals` में भी किया जाएगा (वीडियो के समय ये अभी भी दुरुपयोग किए जा सकते हैं)।

जब **असंगति का पता लगाया जाता है**, तो कर्नेल **पैनिक** करेगा ताकि आगे के शोषण और शोषण के पुनः प्रयासों को रोका जा सके (MTE में झूठे सकारात्मक नहीं होते)।

## References

- [https://www.youtube.com/watch?v=UwMt0e_dC_Q](https://www.youtube.com/watch?v=UwMt0e_dC_Q)

{{#include ../../banners/hacktricks-training.md}}
