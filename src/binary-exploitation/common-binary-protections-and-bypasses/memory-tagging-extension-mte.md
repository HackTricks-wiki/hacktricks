# Extensión de Etiquetado de Memoria (MTE)

{{#include ../../banners/hacktricks-training.md}}

## Información Básica

**Extensión de Etiquetado de Memoria (MTE)** está diseñada para mejorar la fiabilidad y seguridad del software al **detectar y prevenir errores relacionados con la memoria**, como desbordamientos de búfer y vulnerabilidades de uso después de liberar. MTE, como parte de la **arquitectura ARM**, proporciona un mecanismo para adjuntar una **pequeña etiqueta a cada asignación de memoria** y una **etiqueta correspondiente a cada puntero** que referencia esa memoria. Este enfoque permite la detección de accesos ilegales a la memoria en tiempo de ejecución, reduciendo significativamente el riesgo de explotar tales vulnerabilidades para ejecutar código arbitrario.

### **Cómo Funciona la Extensión de Etiquetado de Memoria**

MTE opera **dividiendo la memoria en bloques pequeños de tamaño fijo, con cada bloque asignado a una etiqueta,** típicamente de unos pocos bits de tamaño.&#x20;

Cuando se crea un puntero para apuntar a esa memoria, recibe la misma etiqueta. Esta etiqueta se almacena en los **bits no utilizados de un puntero de memoria**, vinculando efectivamente el puntero a su bloque de memoria correspondiente.

<figure><img src="../../images/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Cuando un programa accede a la memoria a través de un puntero, el hardware de MTE verifica que la **etiqueta del puntero coincida con la etiqueta del bloque de memoria**. Si las etiquetas **no coinciden**, indica un **acceso ilegal a la memoria.**

### Etiquetas de Puntero MTE

Las etiquetas dentro de un puntero se almacenan en 4 bits dentro del byte superior:

<figure><img src="../../images/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Por lo tanto, esto permite hasta **16 valores de etiqueta diferentes**.

### Etiquetas de Memoria MTE

Cada **16B de memoria física** tiene una **etiqueta de memoria** correspondiente.

Las etiquetas de memoria se almacenan en una **región de RAM dedicada** (no accesible para uso normal). Tener etiquetas de 4 bits para cada 16B de etiquetas de memoria ocupa hasta el 3% de la RAM.

ARM introduce las siguientes instrucciones para manipular estas etiquetas en la memoria RAM dedicada:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Comprobación de Modos

### Sincronizado

La CPU verifica las etiquetas **durante la ejecución de la instrucción**, si hay una discrepancia, genera una excepción.\
Este es el más lento y seguro.

### Asincronizado

La CPU verifica las etiquetas **asincrónicamente**, y cuando se encuentra una discrepancia, establece un bit de excepción en uno de los registros del sistema. Es **más rápido** que el anterior, pero es **incapaz de señalar** la instrucción exacta que causó la discrepancia y no genera la excepción de inmediato, dando algo de tiempo al atacante para completar su ataque.

### Mixto

???

## Ejemplos de Implementación y Detección

Llamado KASAN basado en etiquetas de hardware, KASAN basado en MTE o MTE en el núcleo.\
Los asignadores del núcleo (como `kmalloc`) **llamarán a este módulo** que preparará la etiqueta para usar (aleatoriamente) adjuntarla al espacio del núcleo asignado y al puntero devuelto.

Ten en cuenta que **solo marcará suficientes granulos de memoria** (16B cada uno) para el tamaño solicitado. Así que si el tamaño solicitado fue 35 y se dio un bloque de 60B, marcará los primeros 16\*3 = 48B con esta etiqueta y el **resto** será **marcado** con una llamada **etiqueta inválida (0xE)**.

La etiqueta **0xF** es el **puntero que coincide con todos**. Una memoria con este puntero permite **cualquier etiqueta para ser usada** para acceder a su memoria (sin discrepancias). Esto podría prevenir que MET detecte un ataque si esta etiqueta se está utilizando en la memoria atacada.

Por lo tanto, solo hay **14 valores** que se pueden usar para generar etiquetas, ya que 0xE y 0xF están reservados, dando una probabilidad de **reutilizar etiquetas** de 1/17 -> alrededor del **7%**.

Si el núcleo accede al **granulo de etiqueta inválida**, la **discrepancia** será **detectada**. Si accede a otra ubicación de memoria, si la **memoria tiene una etiqueta diferente** (o la etiqueta inválida) la discrepancia será **detectada**. Si el atacante tiene suerte y la memoria está usando la misma etiqueta, no será detectada. Las probabilidades son alrededor del 7%.

Otro error ocurre en el **último granulo** de la memoria asignada. Si la aplicación solicitó 35B, se le dio el granulo de 32 a 48. Por lo tanto, los **bytes del 36 al 47 están usando la misma etiqueta** pero no fueron solicitados. Si el atacante accede a **estos bytes extra, esto no se detecta**.

Cuando se ejecuta **`kfree()`**, la memoria se vuelve a etiquetar con la etiqueta de memoria inválida, por lo que en un **uso después de liberar**, cuando la memoria se accede nuevamente, la **discrepancia se detecta**.

Sin embargo, en un uso después de liberar, si el mismo **bloque se vuelve a asignar nuevamente con la MISMA etiqueta** que anteriormente, un atacante podrá usar este acceso y esto no será detectado (alrededor del 7% de probabilidad).

Además, solo **`slab` y `page_alloc`** utilizan memoria etiquetada, pero en el futuro esto también se utilizará en `vmalloc`, `stack` y `globals` (en el momento del video, estos aún pueden ser abusados).

Cuando se **detecta una discrepancia**, el núcleo **se bloqueará** para prevenir una mayor explotación y reintentos del exploit (MTE no tiene falsos positivos).

## Referencias

- [https://www.youtube.com/watch?v=UwMt0e_dC_Q](https://www.youtube.com/watch?v=UwMt0e_dC_Q)

{{#include ../../banners/hacktricks-training.md}}
