# Memory Tagging Extension (MTE)

{{#include ../../banners/hacktricks-training.md}}

## Osnovne informacije

**Memory Tagging Extension (MTE)** je dizajniran da unapredi pouzdanost i bezbednost softvera kroz **otkrivanje i sprečavanje grešaka vezanih za memoriju**, kao što su buffer overflows i use-after-free ranjivosti. MTE, kao deo **ARM** arhitekture, obezbeđuje mehanizam za pridruživanje **male oznake svakoj memorijskoj alokaciji** i **odgovarajuće oznake svakom pokazivaču** koji referencira tu memoriju. Ovakav pristup omogućava otkrivanje nelegalnih pristupa memoriji u toku izvršavanja, značajno smanjujući rizik od iskorišćavanja takvih ranjivosti za izvršavanje proizvoljnog koda.

### **Kako Memory Tagging Extension radi**

MTE funkcioniše tako što **deli memoriju na male blokove fiksne veličine, gde je svakom bloku dodeljena oznaka,** obično veličine nekoliko bitova.

Kada se kreira pokazivač koji pokazuje na tu memoriju, on dobija istu oznaku. Ta oznaka se čuva u **neiskorišćenim bitovima memorijskog pokazivača**, efektivno povezujući pokazivač sa odgovarajućim memorijskim blokom.

<figure><img src="../../images/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Kada program pristupa memoriji preko pokazivača, MTE hardver proverava da li se **oznaka pokazivača poklapa sa oznakom memorijskog bloka**. Ako se oznake **ne poklapaju**, to ukazuje na **nelegalan pristup memoriji.**

### MTE oznake pokazivača

Oznake unutar pokazivača se čuvaju u 4 bita u okviru gornjeg bajta:

<figure><img src="../../images/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

To omogućava do **16 različitih vrednosti oznaka**.

### MTE oznake memorije

Svakih **16B fizičke memorije** ima odgovarajuću **memorijsku oznaku**.

Memorijske oznake se čuvaju u **posvećenom RAM regionu** (nije dostupan za normalnu upotrebu). Sa 4-bitnim oznakama za svakih 16B, memorijske oznake zauzimaju do 3% RAM-a.

ARM uvodi sledeće instrukcije za manipulaciju ovim oznakama u posvećenom RAM regionu:
```asm
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Režimi provere

### Sync

CPU proverava tagove **tokom izvršavanja instrukcije**, ako postoji nepoklapanje, podigne se izuzetak (SIGSEGV sa `SEGV_MTESERR`) i odmah znate tačnu instrukciju i adresu.\
Ovo je najsporije ali najsigurnije jer se problematičan load/store blokira.

### Async

CPU proverava tagove **asinhrono**, i kada se pronađe nepodudaranje postavlja bit izuzetka u jedan od sistemskih registara. To je **brže** od prethodnog ali **nije u stanju da ukaže** na tačnu instrukciju koja je izazvala nepodudaranje i ne podiže izuzetak odmah (`SIGSEGV` sa `SEGV_MTEAERR`), dajući napadaču malo vremena da dovrši napad.

### Mixed

Per-core podešavanja (na primer upisivanje `sync`, `async` ili `asymm` u `/sys/devices/system/cpu/cpu*/mte_tcf_preferred`) dopuštaju kernelu da tiho nadogradi ili umanji per-process zahteve, pa produkcioni buildovi obično zahtevaju ASYNC dok privilegovana jezgra forsiraju SYNC kada opterećenje to dozvoljava.

## Implementacija i primeri detekcije

Nazvan Hardware Tag-Based KASAN, MTE-based KASAN ili in-kernel MTE.\
Kernel allocatori (kao `kmalloc`) će **pozvati ovaj modul** koji će pripremiti tag koji će se koristiti (nasumično), pridružiti ga alociranom kernel prostoru i vraćenom pokazivaču.

Napomena: on će **označiti samo dovoljan broj granula memorije** (po 16B) za traženu veličinu. Dakle, ako je tražena veličina bila 35 i dodeljen slab od 60B, on će označiti prvih 16*3 = 48B tim tagom, a **ostatak** će biti **označen** tzv. **invalid tag (0xE)**.

Tag **0xF** je **match all pointer**. Memorija sa ovim tagom dozvoljava da se **bilo koji tag koristi** za pristup njenoj memoriji (nema nepodudaranja). Ovo može sprečiti MTE da detektuje napad ako se taj tag koristi u ciljanom regionu.

Zbog toga postoji samo **14 vrednosti** koje se mogu koristiti za generisanje tagova jer su 0xE i 0xF rezervisani, što daje verovatnoću **ponovnog korišćenja tagova** od 1/17 -> oko **7%**.

Ako kernel pristupi granuli sa **invalid tagom**, **nepodudaranje** će biti **detektovano**. Ako pristupi drugoj lokaciji u memoriji i **memorija ima drugačiji tag** (ili invalid tag) nepodudaranje će takođe biti detektovano. Ako je napadaču sreća pa memorija koristi isti tag, neće biti detektovano. Šanse su oko 7%.

Drugi bug se javlja u **poslednjoj granuli** dodeljene memorije. Ako je aplikacija zahtevala 35B, dodeljena je granula od 32 do 48. Dakle, ** bajtovi od 36 do 47 koriste isti tag** ali nisu bili traženi. Ako napadač pristupi **ovim dodatnim bajtovima, to neće biti detektovano**.

Kada se izvrši **`kfree()`**, memorija se ponovo taguje invalid memory tag-om, tako da u slučaju use-after-free, kada se memorija ponovo pristupi, **nepodudaranje će biti detektovano**.

Međutim, u use-after-free slučaju, ako se ista **chunk ponovo alocira sa ISTIM tagom** kao ranije, napadač će moći da iskoristi taj pristup i to neće biti detektovano (oko 7% šanse).

Pored toga, samo **`slab` i `page_alloc`** trenutno koriste tagged memory, ali u budućnosti će se ovo koristiti i u `vmalloc`, `stack` i `globals` (u trenutku snimanja videa ovo se još uvek može zloupotrebiti).

Kada se **detektuje nepodudaranje** kernel će **panic-ovati** kako bi sprečio dalju eksploataciju i ponovljene pokušaje (MTE nema false positives).

### Speculative Tag Leakage (TikTag)

*TikTag* (2024) je demonstrirao dva speculative execution gadget-a (TIKTAG-v1/v2) sposobna da leak the 4-bit allocation tag of any address in <4 seconds with >95% success. Spekulativnim dodirom cache linija koje napadač izabere i posmatranjem prefetch-indukovanog timinga, napadač može derandomizovati tag dodeljen Chrome procesima, Android system services, ili Linux kernelu i zatim konstruisati pokazivače koji nose procurenu vrednost. Kada se tag prostor bruteforce-uje, pretpostavke o probabilističkom ponovnom korišćenju granula (`≈7%` false-negative rate) se urušavaju i klasične heap eksploatacije (UAF, OOB) ponovo dostižu skoro 100% pouzdanost čak i kada je MTE omogućen. Rad takođe sadrži proof-of-concept eksploite koji pivotiraju od procurelih tagova ka retagovanju lažnih slab-ova, ilustrujući da spekulativni side kanali ostaju izvodljiv put za zaobilaženje hardverskih tagging šema.

## References

- [https://www.youtube.com/watch?v=UwMt0e_dC_Q](https://www.youtube.com/watch?v=UwMt0e_dC_Q)
- [TikTag: Breaking ARM's Memory Tagging Extension with Speculative Execution](https://arxiv.org/abs/2406.08719)

{{#include ../../banners/hacktricks-training.md}}
