# Memory Tagging Extension (MTE)

{{#include ../../banners/hacktricks-training.md}}

## 기본 정보

**Memory Tagging Extension (MTE)**는 **buffer overflows** 및 **use-after-free** 같은 메모리 관련 오류를 **감지하고 방지**하여 소프트웨어 신뢰성과 보안을 향상시키도록 설계되었습니다. MTE는 **ARM** 아키텍처의 일부로, 각 메모리 할당에 **작은 tag를 붙이고** 해당 메모리를 참조하는 각 **pointer**에도 **일치하는 tag를 부여**하는 메커니즘을 제공합니다. 이 방식은 런타임에 불법적인 메모리 접근을 탐지할 수 있게 하여, 그런 취약점을 악용해 임의의 코드를 실행할 위험을 크게 줄입니다.

### **How Memory Tagging Extension Works**

MTE는 메모리를 **작고 고정된 크기의 블록으로 나누고, 각 블록에 tag를 할당**하는 방식으로 동작하며, 이 tag는 보통 몇 비트 크기입니다.

pointer가 해당 메모리를 가리키도록 생성되면 동일한 tag를 갖습니다. 이 tag는 **메모리 pointer의 사용되지 않는 비트들**에 저장되어 포인터를 해당 메모리 블록과 연결합니다.

<figure><img src="../../images/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

프로그램이 pointer를 통해 메모리에 접근하면 MTE 하드웨어는 **pointer의 tag가 메모리 블록의 tag와 일치하는지** 검사합니다. tag가 **일치하지 않으면**, 이는 **불법적인 메모리 접근**을 의미합니다.

### MTE Pointer Tags

pointer 내부의 tag는 최상위 바이트의 4비트에 저장됩니다:

<figure><img src="../../images/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

따라서 최대 **16개의 서로 다른 tag 값**을 사용할 수 있습니다.

### MTE Memory Tags

물리 메모리의 **16B마다** 대응하는 **memory tag**가 존재합니다.

메모리 태그는 **전용 RAM 영역**에 저장되며(일반 용도로 접근 불가), 16B마다 4비트 태그를 가지므로 전체 RAM의 최대 약 3%를 차지합니다.

ARM은 전용 RAM에 있는 이러한 태그를 조작하기 위해 다음과 같은 명령어들을 도입합니다:
```asm
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Checking Modes

### Sync

CPU는 명령어가 실행되는 **동안** 태그를 검사하며, 불일치가 발생하면 예외(SIGSEGV with `SEGV_MTESERR`)를 발생시켜 정확한 명령어와 주소를 즉시 파악할 수 있습니다.\
이 방식은 offending load/store가 차단되므로 가장 느리지만 가장 안전합니다.

### Async

CPU는 **비동기적으로** 태그를 검사하며, 불일치가 발견되면 시스템 레지스터 중 하나에 예외 비트를 설정합니다. 이전 방식보다 **빠르지만**, 불일치를 발생시킨 정확한 명령어를 **지목할 수 없고** 예외를 즉시 발생시키지 않습니다(`SIGSEGV` with `SEGV_MTEAERR`), 공격자가 공격을 완료할 시간을 제공합니다.

### Mixed

코어별 선호도(예: `/sys/devices/system/cpu/cpu*/mte_tcf_preferred`에 `sync`, `async` 또는 `asymm`을 쓰는 것)는 커널이 프로세스별 요청을 조용히 업그레이드하거나 다운그레이드하게 하므로, production 빌드는 보통 ASYNC를 요청하는 반면 특권 코어는 작업량이 허용할 때 SYNC를 강제합니다.

## Implementation & Detection Examples

Called Hardware Tag-Based KASAN, MTE-based KASAN or in-kernel MTE.\
커널 할당자(예: `kmalloc`)는 이 모듈을 **호출**하여 사용할 태그를 준비하고(무작위), 커널 공간에 할당된 메모리와 반환된 포인터에 태그를 붙입니다.

요청된 크기에 대해 **충분한 메모리 단위(각 16B)**만 표시된다는 점에 유의하세요. 따라서 요청 크기가 35이고 60B 슬랩이 제공되면, 첫 번째 16\*3 = 48B만 이 태그로 표시되고 **나머지**는 **invalid tag (0xE)**로 **표시됩니다**.

태그 **0xF**는 **match all pointer**입니다. 이 포인터를 가진 메모리는 접근에 **아무 태그나 사용 가능**하므로(태그 불일치 없음) 공격자가 해당 태그를 사용하는 메모리를 공격하면 MTE가 공격을 탐지하지 못할 수 있습니다.

따라서 0xE와 0xF가 예약되어 있으므로 태그를 생성할 수 있는 값은 **14개**뿐이며, 태그 재사용 확률은 1/17 -> 약 **7%**입니다.

커널이 **invalid tag granule**에 접근하면 **mismatch**가 **탐지**됩니다. 다른 메모리 위치에 접근했는데 메모리가 다른 태그(또는 invalid tag)를 가지고 있다면 불일치가 역시 탐지됩니다. 공격자가 운이 좋게 메모리가 동일한 태그를 사용하고 있다면 탐지되지 않습니다. 확률은 약 7%입니다.

또 다른 버그는 할당된 메모리의 **마지막 granule**에서 발생합니다. 애플리케이션이 35B를 요청하면 32에서 48까지의 granule을 받습니다. 따라서 36에서 47 바이트는 동일한 태그를 사용하지만 요청된 바이트는 아닙니다. 공격자가 **이 추가 바이트들**에 접근하면 **탐지되지 않습니다**.

`kfree()`가 실행되면 메모리는 invalid memory tag로 재태깅되므로, use-after-free에서 메모리에 다시 접근하면 **불일치가 탐지**됩니다.

그러나 use-after-free 상황에서 동일한 **청크가 이전과 동일한 태그로 재할당**되면 공격자는 이 접근을 이용할 수 있으며(약 7% 확률) 탐지되지 않습니다.

또한 현재는 **`slab`과 `page_alloc`**만 태그된 메모리를 사용하지만, 향후에는 `vmalloc`, `stack` 및 `globals`에서도 사용될 예정입니다(이 문서 작성 시점에서는 여전히 남용 가능).

불일치가 **탐지되면** 커널은 추가적인 악용과 재시도를 방지하기 위해 **panic**합니다(MTE는 false positives가 없습니다).

### Speculative Tag Leakage (TikTag)

*TikTag* (2024)는 두 개의 speculative execution gadget(TIKTAG-v1/v2)을 통해 어떤 주소의 4-bit allocation tag를 <4초 이내, >95% 성공률로 leak할 수 있음을 보였습니다. 공격자는 공격자가 선택한 캐시 라인을 speculative하게 터치하고 prefetch-induced timing을 관찰하여 Chrome 프로세스, Android system services, 또는 Linux kernel에 할당된 태그를 역난수화한 뒤, 누출된 값을 담은 포인터를 제작할 수 있습니다. 태그 공간이 brute-forced되면 probabilistic granule reuse 가정(`≈7%` false-negative rate)은 무너지고, 고전적 힙 익스플로잇(UAF, OOB)은 MTE가 활성화되어 있더라도 거의 100% 신뢰도로 복구됩니다. 논문은 또한 누출된 태그에서 fake slab을 retag하는 PoC 익스플로잇을 제공하여, speculative side channel이 하드웨어 태깅 방식을 우회하는 유효한 경로임을 보여줍니다.

## References

- [https://www.youtube.com/watch?v=UwMt0e_dC_Q](https://www.youtube.com/watch?v=UwMt0e_dC_Q)
- [TikTag: Breaking ARM's Memory Tagging Extension with Speculative Execution](https://arxiv.org/abs/2406.08719)

{{#include ../../banners/hacktricks-training.md}}
