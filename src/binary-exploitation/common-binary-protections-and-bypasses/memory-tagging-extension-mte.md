# Geheue Etikettering Uitbreiding (MTE)

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

**Geheue Etikettering Uitbreiding (MTE)** is ontwerp om sagteware se betroubaarheid en sekuriteit te verbeter deur **geheue-verwante foute** te **detecteer en te voorkom**, soos buffer oorgroeisels en gebruik-na-vry kwesbaarhede. MTE, as deel van die **ARM** argitektuur, bied 'n mekanisme om 'n **klein etiket aan elke geheue toewysing** te heg en 'n **ooreenstemmende etiket aan elke pointeur** wat na daardie geheue verwys. Hierdie benadering maak dit moontlik om onwettige geheue-toegang tydens uitvoering te detecteer, wat die risiko om sulke kwesbaarhede te benut om arbitrÃªre kode uit te voer, aansienlik verminder.

### **Hoe Geheue Etikettering Uitbreiding Werk**

MTE werk deur **geheue in klein, vaste-grootte blokke te verdeel, met elke blok wat 'n etiket toegeken word,** tipies 'n paar bits groot.&#x20;

Wanneer 'n pointeur geskep word om na daardie geheue te verwys, ontvang dit dieselfde etiket. Hierdie etiket word in die **onbenutte bits van 'n geheue pointeur** gestoor, wat effektief die pointeur aan sy ooreenstemmende geheueblok koppel.

<figure><img src="../../images/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Wanneer 'n program geheue deur 'n pointeur benader, kontroleer die MTE-hardware of die **pointeur se etiket ooreenstem met die geheueblok se etiket**. As die etikette **nie ooreenstem nie**, dui dit op 'n **onwettige geheue-toegang.**

### MTE Pointeur Etikette

Etikette binne 'n pointeur word in 4 bits binne die boonste byte gestoor:

<figure><img src="../../images/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Daarom laat dit tot **16 verskillende etiketwaardes** toe.

### MTE Geheue Etikette

Elke **16B fisiese geheue** het 'n ooreenstemmende **geheue etiket**.

Die geheue etikette word in 'n **toegewyde RAM streek** gestoor (nie toeganklik vir normale gebruik nie). Met 4bits etikette vir elke 16B geheue etikette tot 3% van RAM.

ARM stel die volgende instruksies bekend om hierdie etikette in die toegewyde RAM geheue te manipuleer:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Kontrole Modusse

### Sinkronies

Die CPU kontroleer die etikette **tydens die uitvoering van die instruksie**, as daar 'n wanverhouding is, word 'n uitsondering opgewek.\
Dit is die stadigste en mees veilige.

### Asinkronies

Die CPU kontroleer die etikette **asinkronies**, en wanneer 'n wanverhouding gevind word, stel dit 'n uitsondering-bietjie in een van die stelsels registre. Dit is **vinniger** as die vorige een, maar dit is **nie in staat om** die presiese instruksie aan te dui wat die wanverhouding veroorsaak nie en dit wek nie die uitsondering onmiddellik nie, wat 'n bietjie tyd aan die aanvaller gee om sy aanval te voltooi.

### Gemengde

???

## Implementasie & Opsporing Voorbeelde

Genoem Hardeware Tag-gebaseerde KASAN, MTE-gebaseerde KASAN of in-kernel MTE.\
Die kernel toewysers (soos `kmalloc`) sal **hierdie module aanroep** wat die etiket sal voorberei om te gebruik (ewekansig) en dit aan die kernruimte wat toegeken is en aan die teruggegee pointer te heg.

Let daarop dat dit **slegs genoeg geheue korrels** (16B elk) vir die aangevraagde grootte sal merk. So as die aangevraagde grootte 35 was en 'n slab van 60B gegee is, sal dit die eerste 16\*3 = 48B met hierdie etiket merk en die **res** sal **gemerk** word met 'n sogenaamde **ongeldige etiket (0xE)**.

Die etiket **0xF** is die **pas alle pointer**. 'n Geheue met hierdie pointer laat **enige etiket toe** om toegang tot sy geheue te verkry (geen wanverhoudings nie). Dit kan voorkom dat MET 'n aanval opspoor as hierdie etikette in die aangevalde geheue gebruik word.

Daarom is daar slegs **14 waardes** wat gebruik kan word om etikette te genereer, aangesien 0xE en 0xF gereserveer is, wat 'n waarskynlikheid van **hergebruik van etikette** tot 1/17 -> rondom **7%** gee.

As die kernel toegang tot die **ongeldige etiket korrel** het, sal die **wanverhouding** **opgespoor** word. As dit toegang tot 'n ander geheue ligging het, as die **geheue 'n ander etiket het** (of die ongeldige etiket) sal die wanverhouding **opgespoor** word. As die aanvaller gelukkig is en die geheue dieselfde etiket gebruik, sal dit nie opgespoor word nie. Die kanse is rondom 7%.

Nog 'n fout gebeur in die **laaste korrel** van die toegeken geheue. As die aansoek 35B aangevra het, is die korrel van 32 tot 48 gegee. Daarom gebruik die **bytes van 36 tot 47 dieselfde etiket**, maar hulle is nie aangevra nie. As die aanvaller **hierdie ekstra bytes toegang**, sal dit **nie opgespoor** word nie.

Wanneer **`kfree()`** uitgevoer word, word die geheue weer met die ongeldige geheue etiket gemerk, so in 'n **gebruik-na-vry**, wanneer die geheue weer toegang word, sal die **wanverhouding opgespoor** word.

Echter, in 'n gebruik-na-vry, as die selfde **stuk weer toegeken word met die SELFDE etiket** soos voorheen, sal 'n aanvaller in staat wees om hierdie toegang te gebruik en dit sal nie opgespoor word nie (ongeveer 7% kans).

Boonop gebruik slegs **`slab` en `page_alloc`** gemerkte geheue, maar in die toekoms sal dit ook in `vmalloc`, `stack` en `globals` gebruik word (op die oomblik van die video kan hierdie steeds misbruik word).

Wanneer 'n **wanverhouding opgespoor** word, sal die kernel **paniek** om verdere uitbuiting en herhalings van die uitbuiting te voorkom (MTE het nie vals positiewe nie).

## Verwysings

- [https://www.youtube.com/watch?v=UwMt0e_dC_Q](https://www.youtube.com/watch?v=UwMt0e_dC_Q)

{{#include ../../banners/hacktricks-training.md}}
