# Relro

{{#include ../../banners/hacktricks-training.md}}

## Relro

**RELRO** significa **Relocation Read-Only** e √© uma mitiga√ß√£o implementada pelo linker (`ld`) que torna um subconjunto dos segmentos de dados do ELF **somente leitura depois que todas as relocations foram aplicadas**. O objetivo √© impedir que um atacante sobrescreva entradas na **GOT (Global Offset Table)** ou outras tabelas relacionadas a relocations que s√£o desreferenciadas durante a execu√ß√£o do programa (ex.: `__fini_array`).

Linkers modernos implementam RELRO **reordenando** a **GOT** (e algumas outras se√ß√µes) para que elas fiquem **antes** da **.bss** e ‚Äî mais importante ‚Äî criando um segmento dedicado `PT_GNU_RELRO` que √© remapeado `R‚ÄìX` logo ap√≥s o loader din√¢mico terminar de aplicar as relocations. Consequentemente, estouros de buffer t√≠picos na **.bss** n√£o conseguem mais alcan√ßar a GOT e primitivos de escrita arbitr√°ria n√£o podem ser usados para sobrescrever ponteiros de fun√ß√£o que residem dentro de uma p√°gina protegida por RELRO.

Existem **dois n√≠veis** de prote√ß√£o que o linker pode emitir:

### Partial RELRO

* Produzido com a flag `-Wl,-z,relro` (ou apenas `-z relro` quando invocando `ld` diretamente).
* Apenas a parte **non-PLT** da **GOT** (a parte usada para relocations de dados) √© colocada no segmento somente leitura. Se√ß√µes que precisam ser modificadas em tempo de execu√ß√£o ‚Äì mais importante **.got.plt**, que suporta **lazy binding** ‚Äì permanecem grav√°veis.
* Por causa disso, um primitivo de **arbitrary write** ainda pode redirecionar o fluxo de execu√ß√£o sobrescrevendo uma entrada da PLT (ou realizando **ret2dlresolve**).
* O impacto em performance √© neglig√≠vel e, portanto, **quase todas as distribui√ß√µes v√™m empacotando pacotes com pelo menos Partial RELRO h√° anos (√© o default do GCC/Binutils desde 2016)**.

### Full RELRO

* Produzido com **ambas** as flags `-Wl,-z,relro,-z,now` (a.k.a. `-z relro -z now`). `-z now` for√ßa o loader din√¢mico a resolver **todos** os s√≠mbolos antecipadamente (eager binding) de modo que **.got.plt** nunca precise ser escrita novamente e possa ser mapeada seguramente como somente leitura.
* A **GOT** inteira, **.got.plt**, **.fini_array**, **.init_array**, **.preinit_array** e algumas tabelas internas adicionais do glibc terminam dentro de um segmento `PT_GNU_RELRO` somente leitura.
* Adiciona overhead mensur√°vel no start-up (todas as relocations din√¢micas s√£o processadas no lan√ßamento) mas **sem overhead em tempo de execu√ß√£o**.

Desde 2023 v√°rias distribui√ß√µes mainstream mudaram para compilar a **system tool-chain** (e a maioria dos pacotes) com **Full RELRO por padr√£o** ‚Äì ex.: **Debian 12 ‚Äúbookworm‚Äù (dpkg-buildflags 13.0.0)** e **Fedora 35+**. Como pentester, voc√™ deve portanto esperar encontrar bin√°rios onde **toda entrada da GOT √© somente leitura**.

---

## How to Check the RELRO status of a binary
```bash
$ checksec --file ./vuln
[*] '/tmp/vuln'
Arch:     amd64-64-little
RELRO:    Full
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```
`checksec` (parte do [pwntools](https://github.com/pwncollege/pwntools) e muitas distribui√ß√µes) analisa os cabe√ßalhos `ELF` e imprime o n√≠vel de prote√ß√£o. Se voc√™ n√£o puder usar `checksec`, use `readelf`:
```bash
# Partial RELRO ‚Üí PT_GNU_RELRO is present but BIND_NOW is *absent*
$ readelf -l ./vuln | grep -E "GNU_RELRO|BIND_NOW"
GNU_RELRO      0x0000000000600e20 0x0000000000600e20
```

```bash
# Full RELRO ‚Üí PT_GNU_RELRO *and* the DF_BIND_NOW flag
$ readelf -d ./vuln | grep BIND_NOW
0x0000000000000010 (FLAGS)              FLAGS: BIND_NOW
```
Se o bin√°rio estiver em execu√ß√£o (por exemplo, um set-uid root helper), voc√™ ainda pode inspecionar o execut√°vel **via `/proc/$PID/exe`**:
```bash
readelf -l /proc/$(pgrep helper)/exe | grep GNU_RELRO
```
---

## Habilitando RELRO ao compilar seu pr√≥prio code
```bash
# GCC example ‚Äì create a PIE with Full RELRO and other common hardenings
$ gcc -fPIE -pie -z relro -z now -Wl,--as-needed -D_FORTIFY_SOURCE=2 main.c -o secure
```
`-z relro -z now` funciona tanto para **GCC/clang** (passado ap√≥s `-Wl,`) quanto para **ld** diretamente. Ao usar **CMake 3.18+** voc√™ pode solicitar Full RELRO com o preset embutido:
```cmake
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON) # LTO
set(CMAKE_ENABLE_EXPORTS OFF)
set(CMAKE_BUILD_RPATH_USE_ORIGIN ON)
set(CMAKE_EXE_LINKER_FLAGS "-Wl,-z,relro,-z,now")
```
---

## T√©cnicas de Bypass

| RELRO level | Primitiva t√≠pica | T√©cnicas de explora√ß√£o poss√≠veis |
|-------------|-------------------|----------------------------------|
| Nenhum / Parcial | Arbitrary write | 1. Sobrescrever **.got.plt** entry e pivotar execu√ß√£o.<br>2. **ret2dlresolve** ‚Äì craft fake `Elf64_Rela` & `Elf64_Sym` in a writable segment and call `_dl_runtime_resolve`.<br>3. Sobrescrever function pointers em **.fini_array** / **atexit()** list. |
| Full | GOT √© somente leitura | 1. Procure por **outros ponteiros de c√≥digo grav√°veis** (C++ vtables, `__malloc_hook` < glibc 2.34, `__free_hook`, callbacks em se√ß√µes `.data` customizadas, p√°ginas JIT).<br>2. Abuse *relative read* primitives para leak libc e perform **SROP/ROP into libc**.<br>3. Injete um shared object malicioso via **DT_RPATH**/`LD_PRELOAD` (se o ambiente for controlado pelo atacante) ou **`ld_audit`**.<br>4. Explore **format-string** ou overwrite parcial de ponteiro para desviar o control-flow sem tocar no GOT. |

> üí° Mesmo com Full RELRO a **GOT of loaded shared libraries (e.g. libc itself)** √© **only Partial RELRO** porque esses objetos j√° est√£o mapeados quando o loader aplica as relocations. Se voc√™ ganhar uma primitiva de **arbitrary write** que possa mirar as p√°ginas de outro shared object voc√™ ainda pode pivotar a execu√ß√£o sobrescrevendo entradas da GOT do libc ou a stack `__rtld_global`, uma t√©cnica regularmente explorada em CTFs modernos.

### Exemplo de bypass no mundo real (2024 CTF ‚Äì *pwn.college ‚Äúenlightened‚Äù*)

O desafio veio com Full RELRO. O exploit usou um **off-by-one** para corromper o tamanho de um chunk do heap, leaked libc com `tcache poisoning`, e finalmente sobrescreveu `__free_hook` (fora do segmento RELRO) com um one-gadget para obter execu√ß√£o de c√≥digo. Nenhuma escrita na GOT foi necess√°ria.

---

## Pesquisas recentes & vulnerabilidades (2022-2025)

* **glibc hook removal (2.34 ‚Üí present)** ‚Äì os malloc/free hooks foram extra√≠dos do libc principal para o opcional `libc_malloc_debug.so`, eliminando uma primitiva comum de bypass de Full‚ÄëRELRO; exploits modernos devem mirar outros ponteiros grav√°veis.
* **GNU ld RELRO page‚Äëalignment fix (binutils 2.39+/2.41)** ‚Äì o bug do linker 30612 fazia com que os √∫ltimos bytes de `PT_GNU_RELRO` compartilhassem uma p√°gina grav√°vel em sistemas com p√°ginas de 64‚ÄØKiB; as binutils atuais alinham RELRO ao `max-page-size`, fechando essa ‚ÄúRELRO gap‚Äù.

---

## Refer√™ncias

* [Why malloc hooks were removed from glibc](https://developers.redhat.com/articles/2021/08/25/securing-malloc-glibc-why-malloc-hooks-had-go)
* [Binutils bug 30612 ‚Äì RELRO end alignment](https://lists.gnu.org/archive/html/bug-binutils/2023-08/msg00305.html)

{{#include ../../banners/hacktricks-training.md}}
