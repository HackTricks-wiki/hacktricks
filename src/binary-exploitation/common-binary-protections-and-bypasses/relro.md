# Relro

{{#include ../../banners/hacktricks-training.md}}

## Relro

**RELRO** oznacza **Relocation Read-Only** i jest to Å›rodek zaradczy wdroÅ¼ony przez linker (`ld`), ktÃ³ry zmienia podzbiÃ³r segmentÃ³w danych ELF na **tylko do odczytu po zastosowaniu wszystkich relokacji**. Celem jest uniemoÅ¼liwienie atakujÄ…cemu nadpisania wpisÃ³w w **GOT (Global Offset Table)** lub innych tabelach zwiÄ…zanych z relokacjÄ…, ktÃ³re sÄ… dereferencjonowane podczas wykonywania programu (np. `__fini_array`).

Nowoczesne linkery implementujÄ… RELRO poprzez **przestawienie** **GOT** (i kilku innych sekcji) tak, aby znajdowaÅ‚y siÄ™ **przed** **.bss** i â€“ co najwaÅ¼niejsze â€“ poprzez utworzenie dedykowanego segmentu `PT_GNU_RELRO`, ktÃ³ry jest mapowany jako `Râ€“X` zaraz po tym, jak dynamiczny loader zakoÅ„czy stosowanie relokacji. W konsekwencji typowe przepeÅ‚nienia bufora w **.bss** nie mogÄ… juÅ¼ dotrzeÄ‡ do GOT, a prymitywy do nadpisywania nie mogÄ… byÄ‡ uÅ¼ywane do nadpisywania wskaÅºnikÃ³w funkcji, ktÃ³re znajdujÄ… siÄ™ w chronionej stronie RELRO.

IstniejÄ… **dwa poziomy** ochrony, ktÃ³re linker moÅ¼e wygenerowaÄ‡:

### Partial RELRO

* Wytwarzany z flagÄ… `-Wl,-z,relro` (lub po prostu `-z relro`, gdy wywoÅ‚uje siÄ™ `ld` bezpoÅ›rednio).
* Tylko **nie-PLT** czÄ™Å›Ä‡ **GOT** (czÄ™Å›Ä‡ uÅ¼ywana do relokacji danych) jest umieszczana w segmencie tylko do odczytu. Sekcje, ktÃ³re muszÄ… byÄ‡ modyfikowane w czasie wykonywania â€“ co najwaÅ¼niejsze **.got.plt**, ktÃ³ra wspiera **lazy binding** â€“ pozostajÄ… zapisywalne.
* Z tego powodu prymityw **arbitrary write** moÅ¼e nadal przekierowaÄ‡ przepÅ‚yw wykonania, nadpisujÄ…c wpis PLT (lub wykonujÄ…c **ret2dlresolve**).
* WpÅ‚yw na wydajnoÅ›Ä‡ jest znikomy i dlatego **prawie kaÅ¼da dystrybucja od lat dostarcza pakiety z przynajmniej Partial RELRO (jest to domyÅ›lne ustawienie GCC/Binutils od 2016 roku)**.

### Full RELRO

* Wytwarzany z **obu** flag `-Wl,-z,relro,-z,now` (znany rÃ³wnieÅ¼ jako `-z relro -z now`). `-z now` zmusza dynamiczny loader do rozwiÄ…zania **wszystkich** symboli z gÃ³ry (eager binding), aby **.got.plt** nigdy nie musiaÅ‚ byÄ‡ ponownie zapisywany i mÃ³gÅ‚ byÄ‡ bezpiecznie mapowany jako tylko do odczytu.
* CaÅ‚y **GOT**, **.got.plt**, **.fini_array**, **.init_array**, **.preinit_array** oraz kilka dodatkowych wewnÄ™trznych tabel glibc trafia do segmentu `PT_GNU_RELRO` tylko do odczytu.
* Dodaje mierzalny narzut przy uruchamianiu (wszystkie dynamiczne relokacje sÄ… przetwarzane przy uruchomieniu), ale **nie ma narzutu w czasie wykonywania**.

Od 2023 roku kilka gÅ‚Ã³wnych dystrybucji przeszÅ‚o na kompilowanie **system tool-chain** (i wiÄ™kszoÅ›ci pakietÃ³w) z **Full RELRO domyÅ›lnie** â€“ np. **Debian 12 â€œbookwormâ€ (dpkg-buildflags 13.0.0)** i **Fedora 35+**. Jako pentester powinieneÅ› zatem spodziewaÄ‡ siÄ™ napotkania binarnych plikÃ³w, w ktÃ³rych **kaÅ¼dy wpis GOT jest tylko do odczytu**.

---

## Jak sprawdziÄ‡ status RELRO binarnego pliku
```bash
$ checksec --file ./vuln
[*] '/tmp/vuln'
Arch:     amd64-64-little
RELRO:    Full
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```
`checksec` (czÄ™Å›Ä‡ [pwntools](https://github.com/pwncollege/pwntools) i wielu dystrybucji) analizuje nagÅ‚Ã³wki `ELF` i wyÅ›wietla poziom ochrony. JeÅ›li nie moÅ¼esz uÅ¼yÄ‡ `checksec`, polegaj na `readelf`:
```bash
# Partial RELRO â†’ PT_GNU_RELRO is present but BIND_NOW is *absent*
$ readelf -l ./vuln | grep -E "GNU_RELRO|BIND_NOW"
GNU_RELRO      0x0000000000600e20 0x0000000000600e20
```

```bash
# Full RELRO â†’ PT_GNU_RELRO *and* the DF_BIND_NOW flag
$ readelf -d ./vuln | grep BIND_NOW
0x0000000000000010 (FLAGS)              FLAGS: BIND_NOW
```
JeÅ›li binarny program jest uruchomiony (np. pomocnik z ustawionym uid root), nadal moÅ¼esz sprawdziÄ‡ plik wykonywalny **via `/proc/$PID/exe`**:
```bash
readelf -l /proc/$(pgrep helper)/exe | grep GNU_RELRO
```
---

## WÅ‚Ä…czanie RELRO podczas kompilacji wÅ‚asnego kodu
```bash
# GCC example â€“ create a PIE with Full RELRO and other common hardenings
$ gcc -fPIE -pie -z relro -z now -Wl,--as-needed -D_FORTIFY_SOURCE=2 main.c -o secure
```
`-z relro -z now` dziaÅ‚a zarÃ³wno dla **GCC/clang** (przekazane po `-Wl,`), jak i bezpoÅ›rednio dla **ld**. UÅ¼ywajÄ…c **CMake 3.18+** moÅ¼esz zaÅ¼Ä…daÄ‡ peÅ‚nego RELRO za pomocÄ… wbudowanego preset:
```cmake
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON) # LTO
set(CMAKE_ENABLE_EXPORTS OFF)
set(CMAKE_BUILD_RPATH_USE_ORIGIN ON)
set(CMAKE_EXE_LINKER_FLAGS "-Wl,-z,relro,-z,now")
```
---

## Techniki omijania

| Poziom RELRO | Typowy prymityw | MoÅ¼liwe techniki eksploatacji |
|--------------|------------------|-------------------------------|
| Brak / CzÄ™Å›ciowy | Dowolny zapis | 1. Nadpisanie wpisu **.got.plt** i zmiana wykonania.<br>2. **ret2dlresolve** â€“ stworzenie faÅ‚szywego `Elf64_Rela` i `Elf64_Sym` w zapisywalnym segmencie i wywoÅ‚anie `_dl_runtime_resolve`.<br>3. Nadpisanie wskaÅºnikÃ³w funkcji w **.fini_array** / liÅ›cie **atexit()**. |
| PeÅ‚ny | GOT jest tylko do odczytu | 1. Szukaj **innych zapisywalnych wskaÅºnikÃ³w kodu** (C++ vtables, `__malloc_hook` < glibc 2.34, `__free_hook`, wywoÅ‚ania zwrotne w niestandardowych sekcjach `.data`, strony JIT).<br>2. Wykorzystaj prymitywy *relatywnego odczytu* do wycieku libc i wykonania **SROP/ROP w libc**.<br>3. Wstrzyknij zÅ‚oÅ›liwy obiekt wspÃ³Å‚dzielony za pomocÄ… **DT_RPATH**/`LD_PRELOAD` (jeÅ›li Å›rodowisko jest kontrolowane przez atakujÄ…cego) lub **`ld_audit`**.<br>4. Wykorzystaj **format-string** lub czÄ™Å›ciowe nadpisanie wskaÅºnika, aby zmieniÄ‡ przepÅ‚yw kontroli bez dotykania GOT. |

> ğŸ’¡ Nawet przy PeÅ‚nym RELRO **GOT zaÅ‚adowanych bibliotek wspÃ³Å‚dzielonych (np. sama libc)** jest **tylko CzÄ™Å›ciowy RELRO**, poniewaÅ¼ te obiekty sÄ… juÅ¼ mapowane, gdy loader stosuje relokacje. JeÅ›li uzyskasz prymityw **dowolnego zapisu**, ktÃ³ry moÅ¼e celowaÄ‡ w strony innego obiektu wspÃ³Å‚dzielonego, nadal moÅ¼esz zmieniÄ‡ wykonanie, nadpisujÄ…c wpisy GOT libc lub stos `__rtld_global`, technikÄ™ regularnie wykorzystywanÄ… w nowoczesnych wyzwaniach CTF.

### PrzykÅ‚ad omijania w rzeczywistoÅ›ci (2024 CTF â€“ *pwn.college â€œenlightenedâ€*)

Wyzwanie dostarczono z PeÅ‚nym RELRO. Eksploatacja wykorzystaÅ‚a **off-by-one** do uszkodzenia rozmiaru fragmentu sterty, wyciekÅ‚a libc za pomocÄ… `tcache poisoning`, a na koniec nadpisaÅ‚a `__free_hook` (poza segmentem RELRO) za pomocÄ… jednego gadÅ¼etu, aby uzyskaÄ‡ wykonanie kodu. Nie byÅ‚o wymagane Å¼adne zapisanie do GOT.

---

## Ostatnie badania i luki (2022-2025)

* **glibc 2.40 deprecjonuje `__malloc_hook` / `__free_hook` (2025)** â€“ WiÄ™kszoÅ›Ä‡ nowoczesnych eksploatacji sterty, ktÃ³re wykorzystywaÅ‚y te symbole, musi teraz przejÅ›Ä‡ do alternatywnych wektorÃ³w, takich jak **`rtld_global._dl_load_jump`** lub tabele wyjÄ…tkÃ³w C++. PoniewaÅ¼ haki znajdujÄ… siÄ™ **poza** RELRO, ich usuniÄ™cie zwiÄ™ksza trudnoÅ›Ä‡ omijania PeÅ‚nego RELRO.
* **Poprawka â€œmax-page-sizeâ€ w Binutils 2.41 (2024)** â€“ BÅ‚Ä…d pozwalaÅ‚ ostatnim kilku bajtom segmentu RELRO dzieliÄ‡ stronÄ™ z zapisywalnymi danymi w niektÃ³rych kompilacjach ARM64, pozostawiajÄ…c maÅ‚y **RELRO gap**, ktÃ³ry mÃ³gÅ‚ byÄ‡ zapisany po `mprotect`. Teraz upstream wyrÃ³wnuje `PT_GNU_RELRO` do granic stron, eliminujÄ…c ten przypadek brzegowy.

---

## Odniesienia

* Dokumentacja Binutils â€“ *`-z relro`, `-z now` i `PT_GNU_RELRO`*
* *â€œRELRO â€“ PeÅ‚ny, CzÄ™Å›ciowy i Techniki Omijaniaâ€* â€“ post na blogu @ wolfslittlered 2023

{{#include ../../banners/hacktricks-training.md}}
