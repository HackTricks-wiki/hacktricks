# Relro

{{#include ../../banners/hacktricks-training.md}}

## Relro

**RELRO** significa **Relocation Read-Only** y es una mitigaci√≥n implementada por el linker (`ld`) que convierte un subconjunto de los segmentos de datos ELF en **solo lectura despu√©s de que se hayan aplicado todas las relocaciones**. El objetivo es impedir que un atacante sobrescriba entradas en la **GOT (Global Offset Table)** u otras tablas relacionadas con relocaciones que se desreferencian durante la ejecuci√≥n del programa (p. ej. `__fini_array`).

Los linkers modernos implementan RELRO re‚Äìordenando la **GOT** (y algunas otras secciones) para que vivan **antes** de la **.bss** y ‚Äîlo m√°s importante‚Äî creando un segmento dedicado `PT_GNU_RELRO` que se remapea `R‚ÄìX` justo despu√©s de que el cargador din√°mico termina de aplicar las relocaciones. En consecuencia, los t√≠picos buffer overflows en la **.bss** ya no pueden alcanzar la GOT y los primitivos de escritura arbitraria no pueden usarse para sobrescribir punteros a funciones que residen dentro de una p√°gina protegida por RELRO.

Hay **dos niveles** de protecci√≥n que el linker puede emitir:

### Partial RELRO

* Producido con la bandera `-Wl,-z,relro` (o simplemente `-z relro` cuando se invoca `ld` directamente).
* Solo la parte **no-PLT** de la **GOT** (la parte usada para relocaciones de datos) se coloca en el segmento de solo lectura. Las secciones que necesitan modificarse en tiempo de ejecuci√≥n ‚Äîlo m√°s importante **.got.plt** que soporta **lazy binding**‚Äî permanecen escribibles.
* Debido a eso, un primitivo de **arbitrary write** a√∫n puede redirigir el flujo de ejecuci√≥n sobrescribiendo una entrada de la PLT (o realizando un **ret2dlresolve**).
* El impacto en rendimiento es insignificante y por lo tanto **casi todas las distribuciones han estado entregando paquetes con al menos Partial RELRO durante a√±os (es el default de GCC/Binutils desde 2016)**.

### Full RELRO

* Producido con **ambas** banderas `-Wl,-z,relro,-z,now` (a.k.a. `-z relro -z now`). `-z now` fuerza al cargador din√°mico a resolver **todos** los s√≠mbolos al inicio (eager binding) de modo que **.got.plt** nunca necesita volver a escribirse y puede mapearse de forma segura como solo lectura.
* Toda la **GOT**, **.got.plt**, **.fini_array**, **.init_array**, **.preinit_array** y algunas tablas internas adicionales de glibc terminan dentro de un segmento `PT_GNU_RELRO` de solo lectura.
* A√±ade una sobrecarga medible al inicio (todas las relocaciones din√°micas se procesan al lanzar) pero **sin sobrecarga en tiempo de ejecuci√≥n**.

Desde 2023 varias distribuciones mainstream han cambiado a compilar la **system tool-chain** (y la mayor√≠a de paquetes) con **Full RELRO por defecto** ‚Äì p. ej. **Debian 12 ‚Äúbookworm‚Äù (dpkg-buildflags 13.0.0)** y **Fedora 35+**. Como pentester deber√≠as, por tanto, esperar encontrar binarios donde **toda entrada de la GOT sea de solo lectura**.

---

## How to Check the RELRO status of a binary
```bash
$ checksec --file ./vuln
[*] '/tmp/vuln'
Arch:     amd64-64-little
RELRO:    Full
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```
`checksec` (parte de [pwntools](https://github.com/pwncollege/pwntools) y muchas distribuciones) analiza las cabeceras `ELF` e imprime el nivel de protecci√≥n. Si no puedes usar `checksec`, usa `readelf`:
```bash
# Partial RELRO ‚Üí PT_GNU_RELRO is present but BIND_NOW is *absent*
$ readelf -l ./vuln | grep -E "GNU_RELRO|BIND_NOW"
GNU_RELRO      0x0000000000600e20 0x0000000000600e20
```

```bash
# Full RELRO ‚Üí PT_GNU_RELRO *and* the DF_BIND_NOW flag
$ readelf -d ./vuln | grep BIND_NOW
0x0000000000000010 (FLAGS)              FLAGS: BIND_NOW
```
Si el binario est√° en ejecuci√≥n (p. ej. un set-uid root helper), a√∫n puedes inspeccionar el ejecutable **a trav√©s de `/proc/$PID/exe`**:
```bash
readelf -l /proc/$(pgrep helper)/exe | grep GNU_RELRO
```
---

## Habilitar RELRO al compilar tu propio c√≥digo
```bash
# GCC example ‚Äì create a PIE with Full RELRO and other common hardenings
$ gcc -fPIE -pie -z relro -z now -Wl,--as-needed -D_FORTIFY_SOURCE=2 main.c -o secure
```
`-z relro -z now` funciona tanto para **GCC/clang** (pasado despu√©s de `-Wl,`) como directamente para **ld**.  Al usar **CMake 3.18+** puedes solicitar Full RELRO con el preset incorporado:
```cmake
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON) # LTO
set(CMAKE_ENABLE_EXPORTS OFF)
set(CMAKE_BUILD_RPATH_USE_ORIGIN ON)
set(CMAKE_EXE_LINKER_FLAGS "-Wl,-z,relro,-z,now")
```
---

## T√©cnicas de bypass

| RELRO level | Typical primitive | Possible exploitation techniques |
|-------------|-------------------|----------------------------------|
| Ninguno / Parcial | Escritura arbitraria | 1. Sobrescribir la entrada **.got.plt** y pivotar la ejecuci√≥n.<br>2. **ret2dlresolve** ‚Äì construir `Elf64_Rela` & `Elf64_Sym` falsos en un segmento escribible y llamar a `_dl_runtime_resolve`.<br>3. Sobrescribir punteros a funciones en **.fini_array** / la lista de **atexit()**. |
| Completo | GOT es de solo lectura | 1. Buscar **otros punteros de c√≥digo escribibles** (C++ vtables, `__malloc_hook` < glibc 2.34, `__free_hook`, callbacks en secciones `.data` personalizadas, p√°ginas JIT).<br>2. Abusar de primitivas de *relative read* para leak libc y realizar **SROP/ROP into libc**.<br>3. Inyectar un objeto compartido malicioso v√≠a **DT_RPATH**/`LD_PRELOAD` (si el entorno est√° controlado por el atacante) o **`ld_audit`**.<br>4. Explotar **format-string** o una sobrescritura parcial de puntero para desviar el flujo de control sin tocar el GOT. |

> üí° Incluso con Full RELRO la **GOT of loaded shared libraries (e.g. libc itself)** es **only Partial RELRO** porque esos objetos ya est√°n mapeados cuando el loader aplica las relocations. Si consigues una primitiva de **arbitrary write** que pueda apuntar a las p√°ginas de otro objeto compartido, todav√≠a puedes pivotar la ejecuci√≥n sobrescribiendo las entradas GOT de libc o la pila `__rtld_global`, una t√©cnica explotada regularmente en desaf√≠os CTF modernos.

### Real-world bypass example (2024 CTF ‚Äì *pwn.college ‚Äúenlightened‚Äù*)

El reto se entreg√≥ con Full RELRO. El exploit us√≥ un **off-by-one** para corromper el tama√±o de un chunk del heap, leaked libc con `tcache poisoning`, y finalmente sobrescribi√≥ `__free_hook` (fuera del segmento RELRO) con un one-gadget para obtener ejecuci√≥n de c√≥digo. No se requiri√≥ escribir en el GOT.

---

## Investigaci√≥n reciente & vulnerabilidades (2022-2025)

* **glibc hook removal (2.34 ‚Üí present)** ‚Äì los hooks de malloc/free fueron extra√≠dos de la libc principal hacia el opcional `libc_malloc_debug.so`, eliminando una primitiva com√∫n de bypass de Full‚ÄëRELRO; los exploits modernos deben apuntar a otros punteros escribibles.
* **GNU ld RELRO page‚Äëalignment fix (binutils 2.39+/2.41)** ‚Äì el bug del linker 30612 causaba que los √∫ltimos bytes de `PT_GNU_RELRO` compartieran una p√°gina escribible en sistemas con p√°ginas de 64‚ÄØKiB; los binutils actuales alinean RELRO a `max-page-size`, cerrando esa ‚ÄúRELRO gap‚Äù.

---

## References

* [Why malloc hooks were removed from glibc](https://developers.redhat.com/articles/2021/08/25/securing-malloc-glibc-why-malloc-hooks-had-go)
* [Binutils bug 30612 ‚Äì RELRO end alignment](https://lists.gnu.org/archive/html/bug-binutils/2023-08/msg00305.html)

{{#include ../../banners/hacktricks-training.md}}
