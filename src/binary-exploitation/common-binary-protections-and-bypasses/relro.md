# Relro

{{#include ../../banners/hacktricks-training.md}}

## Relro

**RELRO** oznaÄava **Relocation Read-Only** i to je mitigacija koju implementira linker (`ld`) koja pretvara podskup ELF-ovih segmenata podataka u **samo za Äitanje nakon Å¡to su sve relokacije primenjene**. Cilj je spreÄiti napadaÄa da prepisuje unose u **GOT (Global Offset Table)** ili druge tabele povezane sa relokacijom koje se dereferenciraju tokom izvrÅ¡avanja programa (npr. `__fini_array`).

Moderni linkeri implementiraju RELRO tako Å¡to **preureÄ‘uju** **GOT** (i nekoliko drugih sekcija) tako da se nalaze **pre** **.bss** i â€“ Å¡to je najvaÅ¾nije â€“ kreiraju posveÄ‡en `PT_GNU_RELRO` segment koji se premapira `Râ€“X` odmah nakon Å¡to dinamiÄki uÄitaÄ zavrÅ¡i sa primenom relokacija. Kao rezultat, tipiÄni preljevi bafera u **.bss** viÅ¡e ne mogu da doÄ‘u do GOT-a i primitivne operacije za proizvoljno pisanje ne mogu se koristiti za prepisivanje pokazivaÄa funkcija koji se nalaze unutar stranice zaÅ¡tiÄ‡ene RELRO-om.

Postoje **dva nivoa** zaÅ¡tite koje linker moÅ¾e da generiÅ¡e:

### Partial RELRO

* Proizvedeno sa flagom `-Wl,-z,relro` (ili samo `-z relro` kada se direktno poziva `ld`).
* Samo **ne-PLT** deo **GOT**-a (deo koji se koristi za relokacije podataka) se stavlja u segment samo za Äitanje. Sekcije koje treba da se modifikuju u vreme izvrÅ¡avanja â€“ najvaÅ¾nije **.got.plt** koja podrÅ¾ava **lazy binding** â€“ ostaju zapisive.
* Zbog toga, **primitivna operacija za proizvoljno pisanje** joÅ¡ uvek moÅ¾e preusmeriti tok izvrÅ¡avanja prepisivanjem PLT unosa (ili izvoÄ‘enjem **ret2dlresolve**).
* Uticaj na performanse je zanemarljiv i stoga **skoro svaka distribucija veÄ‡ godinama isporuÄuje pakete sa barem Partial RELRO (to je podrazumevano u GCC/Binutils od 2016)**.

### Full RELRO

* Proizvedeno sa **oba** flaga `-Wl,-z,relro,-z,now` (poznato i kao `-z relro -z now`). `-z now` prisiljava dinamiÄki uÄitaÄ da reÅ¡i **sve** simbole unapred (eager binding) tako da **.got.plt** nikada ne mora ponovo da se piÅ¡e i moÅ¾e sigurno da se mapira kao samo za Äitanje.
* Ceo **GOT**, **.got.plt**, **.fini_array**, **.init_array**, **.preinit_array** i nekoliko dodatnih internih glibc tabela zavrÅ¡avaju unutar segmenta samo za Äitanje `PT_GNU_RELRO`.
* Dodaje merljiv poÄetni prekorak (sve dinamiÄke relokacije se obraÄ‘uju pri pokretanju) ali **nema prekoraka u vreme izvrÅ¡avanja**.

Od 2023. godine nekoliko mainstream distribucija preÅ¡lo je na kompajliranje **sistemskog alata** (i veÄ‡ine paketa) sa **Full RELRO podrazumevano** â€“ npr. **Debian 12 â€œbookwormâ€ (dpkg-buildflags 13.0.0)** i **Fedora 35+**. Kao pentester, stoga treba da oÄekujete da se susretnete sa binarnim datotekama gde je **svaki GOT unos samo za Äitanje**.

---

## Kako proveriti RELRO status binarne datoteke
```bash
$ checksec --file ./vuln
[*] '/tmp/vuln'
Arch:     amd64-64-little
RELRO:    Full
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```
`checksec` (deo [pwntools](https://github.com/pwncollege/pwntools) i mnogih distribucija) analizira `ELF` zaglavlja i prikazuje nivo zaÅ¡tite. Ako ne moÅ¾ete koristiti `checksec`, oslonite se na `readelf`:
```bash
# Partial RELRO â†’ PT_GNU_RELRO is present but BIND_NOW is *absent*
$ readelf -l ./vuln | grep -E "GNU_RELRO|BIND_NOW"
GNU_RELRO      0x0000000000600e20 0x0000000000600e20
```

```bash
# Full RELRO â†’ PT_GNU_RELRO *and* the DF_BIND_NOW flag
$ readelf -d ./vuln | grep BIND_NOW
0x0000000000000010 (FLAGS)              FLAGS: BIND_NOW
```
Ako se binarni program izvrÅ¡ava (npr. set-uid root pomoÄ‡nik), joÅ¡ uvek moÅ¾ete pregledati izvrÅ¡ni fajl **putem `/proc/$PID/exe`**:
```bash
readelf -l /proc/$(pgrep helper)/exe | grep GNU_RELRO
```
---

## OmoguÄ‡avanje RELRO prilikom kompajliranja vlastitog koda
```bash
# GCC example â€“ create a PIE with Full RELRO and other common hardenings
$ gcc -fPIE -pie -z relro -z now -Wl,--as-needed -D_FORTIFY_SOURCE=2 main.c -o secure
```
`-z relro -z now` Ñ€Ğ°Ğ´Ğ¸ Ğ·Ğ° Ğ¾Ğ±Ğ° **GCC/clang** (prolazi nakon `-Wl,`) i **ld** direktno. Kada koristite **CMake 3.18+** moÅ¾ete zatraÅ¾iti Full RELRO sa ugraÄ‘enim presetom:
```cmake
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON) # LTO
set(CMAKE_ENABLE_EXPORTS OFF)
set(CMAKE_BUILD_RPATH_USE_ORIGIN ON)
set(CMAKE_EXE_LINKER_FLAGS "-Wl,-z,relro,-z,now")
```
---

## Tehnike zaobilaÅ¾enja

| RELRO nivo | TipiÄna primitivna | MoguÄ‡e tehnike eksploatacije |
|-------------|-------------------|----------------------------------|
| Nema / DelimiÄna | Arbitrarna pisanja | 1. Prepisivanje **.got.plt** unosa i preusmeravanje izvrÅ¡enja.<br>2. **ret2dlresolve** â€“ kreirati laÅ¾ni `Elf64_Rela` & `Elf64_Sym` u segmentu koji se moÅ¾e pisati i pozvati `_dl_runtime_resolve`.<br>3. Prepisivanje pokazivaÄa funkcija u **.fini_array** / **atexit()** listi. |
| Potpuna | GOT je samo za Äitanje | 1. PotraÅ¾iti **druge pokazivaÄe na kod koji se moÅ¾e pisati** (C++ vtables, `__malloc_hook` < glibc 2.34, `__free_hook`, povratni pozivi u prilagoÄ‘enim `.data` sekcijama, JIT stranice).<br>2. Zloupotreba *relativnih Äitanja* primitiva za curenje libc i izvoÄ‘enje **SROP/ROP u libc**.<br>3. Umetanje zlonamerne deljene biblioteke putem **DT_RPATH**/`LD_PRELOAD` (ako je okruÅ¾enje pod kontrolom napadaÄa) ili **`ld_audit`**.<br>4. Eksploatacija **format-string** ili delimiÄno prepisivanje pokazivaÄa za preusmeravanje toka kontrole bez dodirivanja GOT-a. |

> ğŸ’¡ ÄŒak i sa Potpunim RELRO, **GOT uÄitanih deljenih biblioteka (npr. libc sama)** je **samo DelimiÄni RELRO** jer su ti objekti veÄ‡ mapirani kada uÄitavaÄ primeni relokacije. Ako dobijete **arbitrarnu pisanje** primitivu koja moÅ¾e ciljati stranice druge deljene biblioteke, joÅ¡ uvek moÅ¾ete preusmeriti izvrÅ¡enje prepisivanjem libc-ovih GOT unosa ili `__rtld_global` steka, tehnika koja se redovno koristi u modernim CTF izazovima.

### Primer zaobilaÅ¾enja iz stvarnog sveta (2024 CTF â€“ *pwn.college â€œenlightenedâ€*)

Izazov je isporuÄen sa Potpunim RELRO. Eksploit je koristio **off-by-one** za korupciju veliÄine heap chunk-a, iscurio libc sa `tcache poisoning`, i konaÄno prepisao `__free_hook` (van RELRO segmenta) sa jednim gadgetom za dobijanje izvrÅ¡enja koda. Nije bilo potrebno pisanje u GOT.

---

## Nedavna istraÅ¾ivanja i ranjivosti (2022-2025)

* **glibc 2.40 deprecira `__malloc_hook` / `__free_hook` (2025)** â€“ VeÄ‡ina modernih heap eksploata koji su zloupotrebljavali ove simbole sada mora preÄ‡i na alternativne vektore kao Å¡to su **`rtld_global._dl_load_jump`** ili C++ tabele izuzetaka. Zbog toga Å¡to hook-ovi Å¾ive **van** RELRO, njihovo uklanjanje poveÄ‡ava teÅ¾inu zaobilaÅ¾enja Potpunog RELRO-a.
* **Binutils 2.41 â€œmax-page-sizeâ€ ispravka (2024)** â€“ GreÅ¡ka je omoguÄ‡ila poslednjih nekoliko bajtova RELRO segmenta da dele stranicu sa podacima koji se mogu pisati na nekim ARM64 verzijama, ostavljajuÄ‡i mali **RELRO razmak** koji se mogao pisati nakon `mprotect`. Upstream sada usklaÄ‘uje `PT_GNU_RELRO` sa granicama stranica, eliminiÅ¡uÄ‡i taj iviÄni sluÄaj.

---

## Reference

* Dokumentacija za Binutils â€“ *`-z relro`, `-z now` i `PT_GNU_RELRO`*
* *â€œRELRO â€“ Potpuni, DelimiÄni i Tehnike zaobilaÅ¾enjaâ€* â€“ blog post @ wolfslittlered 2023

{{#include ../../banners/hacktricks-training.md}}
