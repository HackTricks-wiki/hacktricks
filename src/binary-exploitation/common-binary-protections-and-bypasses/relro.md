# Relro

{{#include ../../banners/hacktricks-training.md}}

## Relro

**RELRO** stands for **Relocation Read-Only** and it is a mitigation implemented by the linker (`ld`) that turns a subset of the ELF‚Äôs data segments **read-only after all relocations have been applied**.  The goal is to stop an attacker from overwriting entries in the **GOT (Global Offset Table)** or other relocation-related tables that are dereferenced during program execution (e.g. `__fini_array`).

Moderne Linker implementieren RELRO durch **Umordnung** der **GOT** (und einiger anderer Sections), sodass sie **vor** der **.bss** liegen und ‚Äì am wichtigsten ‚Äì durch das Anlegen eines dedizierten `PT_GNU_RELRO`-Segments, das unmittelbar nachdem der dynamic loader die Relocations angewendet hat als `R‚ÄìX` neu gemappt wird. Folglich k√∂nnen typische Buffer Overflows in der **.bss** die GOT nicht mehr erreichen und arbitrary-write primitives k√∂nnen nicht mehr verwendet werden, um Funktionszeiger zu √ºberschreiben, die innerhalb einer RELRO-gesch√ºtzten Seite liegen.

Es gibt **zwei Schutzstufen**, die der Linker ausgeben kann:

### Partial RELRO

* Erzeugt mit dem Flag `-Wl,-z,relro` (oder einfach `-z relro`, wenn `ld` direkt aufgerufen wird).
* Nur der **non-PLT**-Teil der **GOT** (der Teil, der f√ºr Datenrelocations verwendet wird) wird in das schreibgesch√ºtzte Segment verschoben. Sections, die zur Laufzeit ver√§ndert werden m√ºssen ‚Äì am wichtigsten **.got.plt**, das **lazy binding** unterst√ºtzt ‚Äì bleiben schreibbar.
* Aufgrund dessen kann eine **arbitrary write**-Primitive die Ausf√ºhrung immer noch umleiten, z. B. durch √úberschreiben eines PLT-Eintrags (oder durch Ausf√ºhren von **ret2dlresolve**).
* Die Performance-Auswirkung ist vernachl√§ssigbar und deshalb **liefert fast jede Distribution seit Jahren Pakete mit mindestens Partial RELRO aus (es ist seit 2016 das GCC/Binutils-Default)**.

### Full RELRO

* Erzeugt mit **beiden** Flags `-Wl,-z,relro,-z,now` (a.k.a. `-z relro -z now`). `-z now` zwingt den dynamic loader, **alle** Symbole im Voraus aufzul√∂sen (eager binding), sodass **.got.plt** nie wieder geschrieben werden muss und sicher schreibgesch√ºtzt gemappt werden kann.
* Die komplette **GOT**, **.got.plt**, **.fini_array**, **.init_array**, **.preinit_array** und einige zus√§tzliche interne glibc-Tabellen landen innerhalb eines schreibgesch√ºtzten `PT_GNU_RELRO`-Segments.
* F√ºgt messbaren Start-Overhead hinzu (alle dynamischen Relocations werden beim Start verarbeitet), verursacht jedoch **keinen Laufzeit-Overhead**.

Seit 2023 haben mehrere Mainstream-Distributionen begonnen, die system tool-chain (und die meisten Pakete) standardm√§√üig mit Full RELRO zu kompilieren ‚Äì e.g. **Debian 12 ‚Äúbookworm‚Äù (dpkg-buildflags 13.0.0)** und **Fedora 35+**. Als pentester solltest du daher damit rechnen, auf Bin√§rdateien zu sto√üen, bei denen **jeder GOT-Eintrag schreibgesch√ºtzt** ist.

---

## How to Check the RELRO status of a binary
```bash
$ checksec --file ./vuln
[*] '/tmp/vuln'
Arch:     amd64-64-little
RELRO:    Full
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```
`checksec` (Teil von [pwntools](https://github.com/pwncollege/pwntools) und vielen Distributionen) parst `ELF`-Header und gibt das Schutzniveau aus. Wenn du `checksec` nicht verwenden kannst, greife auf `readelf` zur√ºck:
```bash
# Partial RELRO ‚Üí PT_GNU_RELRO is present but BIND_NOW is *absent*
$ readelf -l ./vuln | grep -E "GNU_RELRO|BIND_NOW"
GNU_RELRO      0x0000000000600e20 0x0000000000600e20
```

```bash
# Full RELRO ‚Üí PT_GNU_RELRO *and* the DF_BIND_NOW flag
$ readelf -d ./vuln | grep BIND_NOW
0x0000000000000010 (FLAGS)              FLAGS: BIND_NOW
```
Wenn das Binary l√§uft (z. B. ein set-uid root helper), kannst du die ausf√ºhrbare Datei trotzdem √ºber **`/proc/$PID/exe`** inspizieren:
```bash
readelf -l /proc/$(pgrep helper)/exe | grep GNU_RELRO
```
---

## RELRO aktivieren beim Kompilieren des eigenen Codes
```bash
# GCC example ‚Äì create a PIE with Full RELRO and other common hardenings
$ gcc -fPIE -pie -z relro -z now -Wl,--as-needed -D_FORTIFY_SOURCE=2 main.c -o secure
```
`-z relro -z now` funktioniert sowohl mit **GCC/clang** (√ºbergeben nach `-Wl,`) als auch direkt mit **ld**. Wenn Sie **CMake 3.18+** verwenden, k√∂nnen Sie Full RELRO mit dem eingebauten Preset anfordern:
```cmake
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON) # LTO
set(CMAKE_ENABLE_EXPORTS OFF)
set(CMAKE_BUILD_RPATH_USE_ORIGIN ON)
set(CMAKE_EXE_LINKER_FLAGS "-Wl,-z,relro,-z,now")
```
---

## Umgehungstechniken

| RELRO level | Typical primitive | Possible exploitation techniques |
|-------------|-------------------|----------------------------------|
| None / Partial | Arbitrary write | 1. Overwrite **.got.plt** entry and pivot execution.<br>2. **ret2dlresolve** ‚Äì craft fake `Elf64_Rela` & `Elf64_Sym` in a writable segment and call `_dl_runtime_resolve`.<br>3. Overwrite function pointers in **.fini_array** / **atexit()** list. |
| Full | GOT is read-only | 1. Look for **other writable code pointers** (C++ vtables, `__malloc_hook` < glibc 2.34, `__free_hook`, callbacks in custom `.data` sections, JIT pages).<br>2. Abuse *relative read* primitives to leak libc and perform **SROP/ROP into libc**.<br>3. Inject a rogue shared object via **DT_RPATH**/`LD_PRELOAD` (if environment is attacker-controlled) or **`ld_audit`**.<br>4. Exploit **format-string** or partial pointer overwrite to divert control-flow without touching the GOT. |

> üí° Selbst bei Full RELRO ist die **GOT of loaded shared libraries (e.g. libc itself)** nur **only Partial RELRO** weil diese Objekte bereits gemappt sind, wenn der Loader Relocations anwendet. Wenn du eine **arbitrary write**-Primitive erh√§ltst, die Seiten eines anderen shared object anvisieren kann, kannst du trotzdem die Ausf√ºhrung pivotieren, indem du libc‚Äôs GOT-Eintr√§ge oder den `__rtld_global` stack √ºberschreibst ‚Äî eine Technik, die regelm√§√üig in modernen CTF-Challenges ausgenutzt wird.

### Praxisbeispiel (2024 CTF ‚Äì *pwn.college ‚Äúenlightened‚Äù*)

Die Challenge wurde mit Full RELRO ausgeliefert. Der Exploit nutzte einen **off-by-one**, um die Gr√∂√üe eines Heap-Chunks zu korrumpieren, leaked libc mit `tcache poisoning`, und √ºberschrieb schlie√ülich `__free_hook` (au√üerhalb des RELRO-Segments) mit einem one-gadget, um Codeausf√ºhrung zu erlangen. Kein GOT write war erforderlich.

---

## Aktuelle Forschung & Verwundbarkeiten (2022-2025)

* **glibc hook removal (2.34 ‚Üí present)** ‚Äì malloc/free hooks wurden aus der main libc in die optionale `libc_malloc_debug.so` ausgelagert, wodurch ein h√§ufiger Full‚ÄëRELRO bypass primitive entfiel; moderne Exploits m√ºssen andere beschreibbare Pointer anvisieren.
* **GNU ld RELRO page‚Äëalignment fix (binutils 2.39+/2.41)** ‚Äì linker bug 30612 verursachte, dass die letzten Bytes von `PT_GNU_RELRO` auf 64‚ÄØKiB-Page-Systemen eine beschreibbare Seite teilten; aktuelle binutils richtet RELRO an `max-page-size` aus und schlie√üt diese ‚ÄúRELRO gap‚Äù.

---

## References

* [Why malloc hooks were removed from glibc](https://developers.redhat.com/articles/2021/08/25/securing-malloc-glibc-why-malloc-hooks-had-go)
* [Binutils bug 30612 ‚Äì RELRO end alignment](https://lists.gnu.org/archive/html/bug-binutils/2023-08/msg00305.html)

{{#include ../../banners/hacktricks-training.md}}
