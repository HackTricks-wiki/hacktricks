# Relro

{{#include ../../banners/hacktricks-training.md}}

## Relro

**RELRO**, **Relocation Read-Only** anlamÄ±na gelir ve bir baÄŸlayÄ±cÄ± (`ld`) tarafÄ±ndan uygulanan bir Ã¶nlemdir; bu, ELF'nin veri segmentlerinin bir alt kÃ¼mesini **tÃ¼m yeniden konumlandÄ±rmalar uygulandÄ±ktan sonra yalnÄ±zca okunur hale getirir**. AmaÃ§, bir saldÄ±rganÄ±n program yÃ¼rÃ¼tÃ¼lmesi sÄ±rasÄ±nda dereferans edilen **GOT (Global Offset Table)** veya diÄŸer yeniden konumlandÄ±rma ile ilgili tablolarÄ±n giriÅŸlerini yazmasÄ±nÄ± engellemektir (Ã¶rneÄŸin, `__fini_array`).

Modern baÄŸlayÄ±cÄ±lar, RELRO'yu **GOT'u** (ve birkaÃ§ diÄŸer bÃ¶lÃ¼mÃ¼) **.bss**'den **Ã¶nce** yerleÅŸtirerek ve â€“ en Ã¶nemlisi â€“ dinamik yÃ¼kleyici yeniden konumlandÄ±rmalarÄ± uyguladÄ±ktan hemen sonra `Râ€“X` olarak yeniden haritalanan Ã¶zel bir `PT_GNU_RELRO` segmenti oluÅŸturarak uygular. SonuÃ§ olarak, **.bss**'deki tipik tampon taÅŸmalarÄ± artÄ±k GOT'a ulaÅŸamaz ve keyfi yazma ilkelere, RELRO korumalÄ± bir sayfanÄ±n iÃ§inde bulunan iÅŸlev iÅŸaretÃ§ilerini yazmak iÃ§in kullanÄ±lamaz.

BaÄŸlayÄ±cÄ± tarafÄ±ndan yayÄ±mlanabilecek **iki seviye** koruma vardÄ±r:

### KÄ±smi RELRO

* `-Wl,-z,relro` (veya `ld`'yi doÄŸrudan Ã§aÄŸÄ±rÄ±rken sadece `-z relro`) bayraÄŸÄ± ile Ã¼retilir.
* Sadece **GOT**'un **non-PLT** kÄ±smÄ± (veri yeniden konumlandÄ±rmalarÄ± iÃ§in kullanÄ±lan kÄ±sÄ±m) yalnÄ±zca okunur segmente konur. Ã‡alÄ±ÅŸma zamanÄ±nda deÄŸiÅŸtirilmesi gereken bÃ¶lÃ¼mler â€“ en Ã¶nemlisi **lazy binding**'i destekleyen **.got.plt** â€“ yazÄ±labilir kalÄ±r.
* Bu nedenle, bir **keyfi yazma** ilkesinin hala bir PLT giriÅŸini yazmasÄ± (veya **ret2dlresolve** gerÃ§ekleÅŸtirmesi) mÃ¼mkÃ¼ndÃ¼r.
* Performans etkisi Ã¶nemsizdir ve bu nedenle **neredeyse her daÄŸÄ±tÄ±m yÄ±llardÄ±r en az KÄ±smi RELRO ile paketler gÃ¶nderiyor (2016 itibarÄ±yla GCC/Binutils varsayÄ±lanÄ±dÄ±r)**.

### Tam RELRO

* **Her iki** bayrak ile Ã¼retilir: `-Wl,-z,relro,-z,now` (diÄŸer adÄ±yla `-z relro -z now`). `-z now`, dinamik yÃ¼kleyicinin **tÃ¼m** sembolleri Ã¶nceden Ã§Ã¶zmesini (istekli baÄŸlama) zorlar, bÃ¶ylece **.got.plt** bir daha yazÄ±lmak zorunda kalmaz ve gÃ¼venli bir ÅŸekilde yalnÄ±zca okunur olarak haritalanabilir.
* TÃ¼m **GOT**, **.got.plt**, **.fini_array**, **.init_array**, **.preinit_array** ve birkaÃ§ ek iÃ§ glibc tablosu yalnÄ±zca okunur bir `PT_GNU_RELRO` segmentinin iÃ§ine yerleÅŸtirilir.
* Ã–lÃ§Ã¼lebilir bir baÅŸlangÄ±Ã§ yÃ¼kÃ¼ ekler (tÃ¼m dinamik yeniden konumlandÄ±rmalar baÅŸlatÄ±ldÄ±ÄŸÄ±nda iÅŸlenir) ancak **Ã§alÄ±ÅŸma zamanÄ± yÃ¼kÃ¼ yoktur**.

2023'ten itibaren birkaÃ§ ana akÄ±m daÄŸÄ±tÄ±m, **sistem araÃ§ zincirini** (ve Ã§oÄŸu paketi) varsayÄ±lan olarak **Tam RELRO ile derlemeye** geÃ§ti â€“ Ã¶rneÄŸin, **Debian 12 â€œbookwormâ€ (dpkg-buildflags 13.0.0)** ve **Fedora 35+**. Bu nedenle, bir pentester olarak **her GOT giriÅŸinin yalnÄ±zca okunur** olduÄŸu ikili dosyalarla karÅŸÄ±laÅŸmayÄ± beklemelisiniz.

---

## Bir ikilinin RELRO durumunu nasÄ±l kontrol edersiniz
```bash
$ checksec --file ./vuln
[*] '/tmp/vuln'
Arch:     amd64-64-little
RELRO:    Full
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```
`checksec` (bir parÃ§asÄ± [pwntools](https://github.com/pwncollege/pwntools) ve birÃ§ok daÄŸÄ±tÄ±m) `ELF` baÅŸlÄ±klarÄ±nÄ± ayrÄ±ÅŸtÄ±rÄ±r ve koruma seviyesini yazdÄ±rÄ±r. EÄŸer `checksec` kullanamÄ±yorsanÄ±z, `readelf`'e gÃ¼venin:
```bash
# Partial RELRO â†’ PT_GNU_RELRO is present but BIND_NOW is *absent*
$ readelf -l ./vuln | grep -E "GNU_RELRO|BIND_NOW"
GNU_RELRO      0x0000000000600e20 0x0000000000600e20
```

```bash
# Full RELRO â†’ PT_GNU_RELRO *and* the DF_BIND_NOW flag
$ readelf -d ./vuln | grep BIND_NOW
0x0000000000000010 (FLAGS)              FLAGS: BIND_NOW
```
EÄŸer ikili Ã§alÄ±ÅŸÄ±yorsa (Ã¶rneÄŸin, bir set-uid root yardÄ±mcÄ± programÄ±), yÃ¼rÃ¼tÃ¼lebilir dosyayÄ± **`/proc/$PID/exe`** Ã¼zerinden inceleyebilirsiniz:
```bash
readelf -l /proc/$(pgrep helper)/exe | grep GNU_RELRO
```
---

## Kendi kodunuzu derlerken RELRO'yu etkinleÅŸtirme
```bash
# GCC example â€“ create a PIE with Full RELRO and other common hardenings
$ gcc -fPIE -pie -z relro -z now -Wl,--as-needed -D_FORTIFY_SOURCE=2 main.c -o secure
```
`-z relro -z now` hem **GCC/clang** ( `-Wl,` sonrasÄ±nda geÃ§ildiÄŸinde) hem de doÄŸrudan **ld** iÃ§in Ã§alÄ±ÅŸÄ±r. **CMake 3.18+** kullanÄ±rken, yerleÅŸik Ã¶n ayar ile Tam RELRO talep edebilirsiniz:
```cmake
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON) # LTO
set(CMAKE_ENABLE_EXPORTS OFF)
set(CMAKE_BUILD_RPATH_USE_ORIGIN ON)
set(CMAKE_EXE_LINKER_FLAGS "-Wl,-z,relro,-z,now")
```
---

## Bypass Teknikleri

| RELRO seviyesi | Tipik ilkel | OlasÄ± istismar teknikleri |
|----------------|-------------|---------------------------|
| Yok / KÄ±smi | Keyfi yazma | 1. **.got.plt** giriÅŸini Ã¼zerine yaz ve yÃ¼rÃ¼tmeyi yÃ¶nlendir.<br>2. **ret2dlresolve** â€“ yazÄ±labilir bir segmentte sahte `Elf64_Rela` & `Elf64_Sym` oluÅŸtur ve `_dl_runtime_resolve` Ã§aÄŸrÄ±sÄ± yap.<br>3. **.fini_array** / **atexit()** listesinde fonksiyon iÅŸaretÃ§ilerini Ã¼zerine yaz. |
| Tam | GOT salt okunur | 1. **diÄŸer yazÄ±labilir kod iÅŸaretÃ§ilerini** (C++ vtables, `__malloc_hook` < glibc 2.34, `__free_hook`, Ã¶zel `.data` bÃ¶lÃ¼mlerindeki geri Ã§aÄŸÄ±rmalar, JIT sayfalarÄ±) ara.<br>2. libc'yi sÄ±zdÄ±rmak ve **SROP/ROP into libc** gerÃ§ekleÅŸtirmek iÃ§in *gÃ¶receli okuma* ilkelerini kÃ¶tÃ¼ye kullan.<br>3. **DT_RPATH**/`LD_PRELOAD` aracÄ±lÄ±ÄŸÄ±yla bir sahte paylaÅŸÄ±lan nesne enjekte et (eÄŸer ortam saldÄ±rganÄ±n kontrolÃ¼ndeyse) veya **`ld_audit`**.<br>4. GOT'a dokunmadan kontrol akÄ±ÅŸÄ±nÄ± saptÄ±rmak iÃ§in **format-string** veya kÄ±smi iÅŸaretÃ§i Ã¼zerine yazma istismar et. |

> ğŸ’¡ Tam RELRO ile bile, **yÃ¼klenen paylaÅŸÄ±lan kÃ¼tÃ¼phanelerin GOT'u (Ã¶rneÄŸin libc'nin kendisi)** **yalnÄ±zca KÄ±smi RELRO**'dur Ã§Ã¼nkÃ¼ bu nesneler yÃ¼kleyici yerleÅŸtirmeleri uyguladÄ±ÄŸÄ±nda zaten haritalanmÄ±ÅŸtÄ±r. EÄŸer baÅŸka bir paylaÅŸÄ±lan nesnenin sayfalarÄ±nÄ± hedef alabilen bir **keyfi yazma** ilkesine sahip olursanÄ±z, libc'nin GOT giriÅŸlerini veya `__rtld_global` yÄ±ÄŸÄ±nÄ±nÄ± Ã¼zerine yazarak yÃ¼rÃ¼tmeyi yÃ¶nlendirebilirsiniz; bu, modern CTF zorluklarÄ±nda dÃ¼zenli olarak istismar edilen bir tekniktir.

### GerÃ§ek dÃ¼nya bypass Ã¶rneÄŸi (2024 CTF â€“ *pwn.college â€œaydÄ±nlanmÄ±ÅŸâ€*)

Zorluk Tam RELRO ile gÃ¶nderildi. Ä°stismar, bir yÄ±ÄŸÄ±n parÃ§asÄ±nÄ±n boyutunu bozmak iÃ§in bir **off-by-one** kullandÄ±, `tcache poisoning` ile libc'yi sÄ±zdÄ±rdÄ± ve sonunda `__free_hook`'u (RELRO segmentinin dÄ±ÅŸÄ±nda) bir gadget ile kod yÃ¼rÃ¼tmek iÃ§in Ã¼zerine yazdÄ±. HiÃ§bir GOT yazma gerekmiyordu.

---

## Son araÅŸtÄ±rmalar & gÃ¼venlik aÃ§Ä±klarÄ± (2022-2025)

* **glibc 2.40 `__malloc_hook` / `__free_hook`'u kullanÄ±mdan kaldÄ±rÄ±yor (2025)** â€“ Bu sembolleri kÃ¶tÃ¼ye kullanan modern yÄ±ÄŸÄ±n istismarlarÄ±nÄ±n Ã§oÄŸu artÄ±k **`rtld_global._dl_load_jump`** veya C++ istisna tablolarÄ± gibi alternatif vektÃ¶rlere geÃ§mek zorundadÄ±r. Kancalar **RELRO'nun dÄ±ÅŸÄ±ndadÄ±r**, bu nedenle kaldÄ±rÄ±lmalarÄ± Tam RELRO bypass'larÄ±nÄ± zorlaÅŸtÄ±rÄ±r.
* **Binutils 2.41 â€œmax-page-sizeâ€ dÃ¼zeltmesi (2024)** â€“ Bir hata, RELRO segmentinin son birkaÃ§ baytÄ±nÄ±n bazÄ± ARM64 derlemelerinde yazÄ±labilir verilerle aynÄ± sayfayÄ± paylaÅŸmasÄ±na izin verdi ve `mprotect`'ten sonra yazÄ±labilecek kÃ¼Ã§Ã¼k bir **RELRO boÅŸluÄŸu** bÄ±raktÄ±. Ãœst akÄ±m artÄ±k `PT_GNU_RELRO`'yu sayfa sÄ±nÄ±rlarÄ±na hizalÄ±yor ve bu kenar durumunu ortadan kaldÄ±rÄ±yor.

---

## Referanslar

* Binutils belgeleri â€“ *`-z relro`, `-z now` ve `PT_GNU_RELRO`*
* *â€œRELRO â€“ Tam, KÄ±smi ve Bypass Teknikleriâ€* â€“ blog yazÄ±sÄ± @ wolfslittlered 2023

{{#include ../../banners/hacktricks-training.md}}
