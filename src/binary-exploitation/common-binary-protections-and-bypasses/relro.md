# Relro

{{#include ../../banners/hacktricks-training.md}}

## Relro

**RELRO** signifie **Relocation Read-Only** et c'est une att√©nuation impl√©ment√©e par l'√©diteur de liens (`ld`) qui rend un sous-ensemble des segments de donn√©es ELF **en lecture seule apr√®s que toutes les relocations ont √©t√© appliqu√©es**. L'objectif est d'emp√™cher un attaquant d'√©craser des entr√©es dans la **GOT (Global Offset Table)** ou d'autres tables li√©es aux relocations qui sont d√©r√©f√©renc√©es pendant l'ex√©cution du programme (par ex. `__fini_array`).

Les linkers modernes impl√©mentent RELRO en **r√©ordonnant** la **GOT** (et quelques autres sections) de sorte qu'elles se trouvent **avant** la **.bss** et ‚Äî surtout ‚Äî en cr√©ant un segment d√©di√© `PT_GNU_RELRO` qui est remapp√© en `R‚ÄìX` imm√©diatement apr√®s que le chargeur dynamique a fini d'appliquer les relocations. Par cons√©quent, les d√©bordements de tampon typiques dans la **.bss** ne peuvent plus atteindre la GOT et des primitives d'√©criture arbitraire ne peuvent pas √™tre utilis√©es pour √©craser des pointeurs de fonction situ√©s dans une page prot√©g√©e par RELRO.

Il existe **deux niveaux** de protection que l'√©diteur de liens peut √©mettre :

### Partial RELRO

* Produit avec le drapeau `-Wl,-z,relro` (ou simplement `-z relro` lorsque l'on invoque `ld` directement).
* Seule la partie **non-PLT** de la **GOT** (la partie utilis√©e pour les relocations de donn√©es) est plac√©e dans le segment en lecture seule. Les sections qui doivent √™tre modifi√©es √† l'ex√©cution ‚Äì surtout **.got.plt** qui prend en charge le **lazy binding** ‚Äì restent modifiables.
* De ce fait, une primitive d'**arbitrary write** peut encore rediriger le flux d'ex√©cution en √©crasant une entr√©e PLT (ou en effectuant un **ret2dlresolve**).
* L'impact sur les performances est n√©gligeable et par cons√©quent **presque toutes les distributions livrent des paquets avec au moins Partial RELRO depuis des ann√©es (c'est le comportement par d√©faut de GCC/Binutils depuis 2016)**.

### Full RELRO

* Produit avec **les deux** flags `-Wl,-z,relro,-z,now` (a.k.a. `-z relro -z now`). `-z now` force le chargeur dynamique √† r√©soudre **tous** les symboles au d√©marrage (eager binding) de sorte que **.got.plt** n'ait plus jamais besoin d'√™tre √©crit et puisse √™tre mapp√© en lecture seule.
* L'ensemble de la **GOT**, **.got.plt**, **.fini_array**, **.init_array**, **.preinit_array** et quelques tables internes suppl√©mentaires de glibc se retrouvent dans un segment `PT_GNU_RELRO` en lecture seule.
* Ajoute une surcharge de d√©marrage mesurable (toutes les relocations dynamiques sont trait√©es au lancement) mais **aucune surcharge √† l'ex√©cution**.

Depuis 2023, plusieurs distributions grand public ont bascul√© vers la compilation de la **system tool-chain** (et de la plupart des paquets) avec **Full RELRO par d√©faut** ‚Äî par exemple **Debian 12 ‚Äúbookworm‚Äù (dpkg-buildflags 13.0.0)** et **Fedora 35+**. En tant que pentester, vous devez donc vous attendre √† rencontrer des binaires o√π **chaque entr√©e GOT est en lecture seule**.

---

## Comment v√©rifier le statut RELRO d'un binaire
```bash
$ checksec --file ./vuln
[*] '/tmp/vuln'
Arch:     amd64-64-little
RELRO:    Full
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```
`checksec` (part of [pwntools](https://github.com/pwncollege/pwntools) et de nombreuses distributions) analyse les en-t√™tes `ELF` et affiche le niveau de protection.  Si vous ne pouvez pas utiliser `checksec`, utilisez `readelf` :
```bash
# Partial RELRO ‚Üí PT_GNU_RELRO is present but BIND_NOW is *absent*
$ readelf -l ./vuln | grep -E "GNU_RELRO|BIND_NOW"
GNU_RELRO      0x0000000000600e20 0x0000000000600e20
```

```bash
# Full RELRO ‚Üí PT_GNU_RELRO *and* the DF_BIND_NOW flag
$ readelf -d ./vuln | grep BIND_NOW
0x0000000000000010 (FLAGS)              FLAGS: BIND_NOW
```
Si le binaire est en cours d'ex√©cution (par ex. un set-uid root helper), vous pouvez toujours inspecter l'ex√©cutable **via `/proc/$PID/exe`** :
```bash
readelf -l /proc/$(pgrep helper)/exe | grep GNU_RELRO
```
## Activer RELRO lors de la compilation de votre propre code
```bash
# GCC example ‚Äì create a PIE with Full RELRO and other common hardenings
$ gcc -fPIE -pie -z relro -z now -Wl,--as-needed -D_FORTIFY_SOURCE=2 main.c -o secure
```
`-z relro -z now` fonctionne √† la fois pour **GCC/clang** (pass√© apr√®s `-Wl,`) et pour **ld** directement. Lorsque vous utilisez **CMake 3.18+** vous pouvez demander Full RELRO avec le preset int√©gr√© :
```cmake
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON) # LTO
set(CMAKE_ENABLE_EXPORTS OFF)
set(CMAKE_BUILD_RPATH_USE_ORIGIN ON)
set(CMAKE_EXE_LINKER_FLAGS "-Wl,-z,relro,-z,now")
```
---

## Techniques de contournement

| RELRO level | Typical primitive | Possible exploitation techniques |
|-------------|-------------------|----------------------------------|
| Aucun / Partiel | Arbitrary write | 1. √âcraser l'entr√©e **.got.plt** et pivoter l'ex√©cution.<br>2. **ret2dlresolve** ‚Äì construire de faux `Elf64_Rela` & `Elf64_Sym` dans un segment √©crivable et appeler `_dl_runtime_resolve`.<br>3. √âcraser les pointeurs de fonction dans **.fini_array** / la liste **atexit()**. |
| Full | GOT is read-only | 1. Chercher **d'autres writable code pointers** (C++ vtables, `__malloc_hook` < glibc 2.34, `__free_hook`, callbacks in custom `.data` sections, JIT pages).<br>2. Abuser des primitives *relative read* pour leak libc et effectuer **SROP/ROP into libc**.<br>3. Injecter une biblioth√®que partag√©e malveillante via **DT_RPATH**/`LD_PRELOAD` (si l'environnement est contr√¥l√© par l'attaquant) ou **`ld_audit`**.<br>4. Exploiter **format-string** ou un √©crasement partiel de pointeur pour d√©tourner le flux de contr√¥le sans toucher le GOT. |

> üí° M√™me avec Full RELRO le **GOT des biblioth√®ques partag√©es charg√©es (p.ex. libc lui-m√™me)** est **seulement Partial RELRO** parce que ces objets sont d√©j√† mapp√©s lorsque le chargeur applique les relocations. Si vous gagnez une primitive **arbitrary write** pouvant cibler les pages d'une autre biblioth√®que partag√©e vous pouvez toujours pivoter l'ex√©cution en √©crasant les entr√©es GOT de libc ou la pile `__rtld_global`, une technique r√©guli√®rement exploit√©e dans les CTF modernes.

### Real-world bypass example (2024 CTF ‚Äì *pwn.college ‚Äúenlightened‚Äù*)

Le challenge √©tait livr√© avec Full RELRO. L'exploit a utilis√© un **off-by-one** pour corrompre la taille d'un heap chunk, a leak libc avec `tcache poisoning`, et a finalement √©cras√© `__free_hook` (en dehors du segment RELRO) avec un one-gadget pour obtenir l'ex√©cution de code. Aucune √©criture sur le GOT n'√©tait requise.

---

## Recherches r√©centes & vuln√©rabilit√©s (2022-2025)

* **glibc hook removal (2.34 ‚Üí present)** ‚Äì les malloc/free hooks ont √©t√© extraits du libc principal vers la `libc_malloc_debug.so` optionnelle, √©liminant un primitive courant de contournement Full‚ÄëRELRO ; les exploits modernes doivent cibler d'autres pointeurs modifiables.
* **GNU ld RELRO page‚Äëalignment fix (binutils 2.39+/2.41)** ‚Äì le linker bug 30612 faisait que les derniers octets de `PT_GNU_RELRO` partageaient une page modifiable sur les syst√®mes √† pages de 64‚ÄØKiB ; les binutils actuels alignent RELRO sur `max-page-size`, comblant cette ‚ÄúRELRO gap‚Äù.

---

## References

* [Why malloc hooks were removed from glibc](https://developers.redhat.com/articles/2021/08/25/securing-malloc-glibc-why-malloc-hooks-had-go)
* [Binutils bug 30612 ‚Äì RELRO end alignment](https://lists.gnu.org/archive/html/bug-binutils/2023-08/msg00305.html)

{{#include ../../banners/hacktricks-training.md}}
