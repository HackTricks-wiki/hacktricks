# Relro

{{#include ../../banners/hacktricks-training.md}}

## Relro

**RELRO** significa **Relocation Read-Only** e √© uma mitiga√ß√£o implementada pelo linker (`ld`) que torna um subconjunto dos segmentos de dados do ELF **somente leitura ap√≥s todas as realoca√ß√µes terem sido aplicadas**. O objetivo √© impedir que um atacante sobrescreva entradas na **GOT (Tabela de Deslocamento Global)** ou outras tabelas relacionadas a realoca√ß√µes que s√£o desreferenciadas durante a execu√ß√£o do programa (por exemplo, `__fini_array`).

Linkers modernos implementam RELRO **reordenando** a **GOT** (e algumas outras se√ß√µes) para que elas fiquem **antes** da **.bss** e ‚Äì mais importante ‚Äì criando um segmento dedicado `PT_GNU_RELRO` que √© remapeado `R‚ÄìX` logo ap√≥s o carregador din√¢mico terminar de aplicar as realoca√ß√µes. Consequentemente, estouros de buffer t√≠picos na **.bss** n√£o podem mais alcan√ßar a GOT e primitivas de escrita arbitr√°ria n√£o podem ser usadas para sobrescrever ponteiros de fun√ß√£o que est√£o dentro de uma p√°gina protegida por RELRO.

Existem **dois n√≠veis** de prote√ß√£o que o linker pode emitir:

### Partial RELRO

* Produzido com a flag `-Wl,-z,relro` (ou apenas `-z relro` ao invocar `ld` diretamente).
* Apenas a parte **n√£o-PLT** da **GOT** (a parte usada para realoca√ß√µes de dados) √© colocada no segmento somente leitura. Se√ß√µes que precisam ser modificadas em tempo de execu√ß√£o ‚Äì mais importante **.got.plt** que suporta **lazy binding** ‚Äì permanecem grav√°veis.
* Por causa disso, uma primitiva de **escrita arbitr√°ria** ainda pode redirecionar o fluxo de execu√ß√£o sobrescrevendo uma entrada PLT (ou realizando **ret2dlresolve**).
* O impacto no desempenho √© negligenci√°vel e, portanto, **quase todas as distribui√ß√µes t√™m enviado pacotes com pelo menos Partial RELRO h√° anos (√© o padr√£o do GCC/Binutils desde 2016)**.

### Full RELRO

* Produzido com **ambas** as flags `-Wl,-z,relro,-z,now` (tamb√©m conhecido como `-z relro -z now`). `-z now` for√ßa o carregador din√¢mico a resolver **todos** os s√≠mbolos antecipadamente (binding ansioso) para que **.got.plt** nunca precise ser escrita novamente e possa ser mapeada com seguran√ßa como somente leitura.
* A **GOT** inteira, **.got.plt**, **.fini_array**, **.init_array**, **.preinit_array** e algumas tabelas internas adicionais da glibc acabam dentro de um segmento `PT_GNU_RELRO` somente leitura.
* Adiciona uma sobrecarga de inicializa√ß√£o mensur√°vel (todas as realoca√ß√µes din√¢micas s√£o processadas na inicializa√ß√£o), mas **sem sobrecarga em tempo de execu√ß√£o**.

Desde 2023, v√°rias distribui√ß√µes populares mudaram para compilar a **ferramenta de sistema** (e a maioria dos pacotes) com **Full RELRO por padr√£o** ‚Äì por exemplo, **Debian 12 ‚Äúbookworm‚Äù (dpkg-buildflags 13.0.0)** e **Fedora 35+**. Como um pentester, voc√™ deve, portanto, esperar encontrar bin√°rios onde **cada entrada da GOT √© somente leitura**.

---

## Como verificar o status RELRO de um bin√°rio
```bash
$ checksec --file ./vuln
[*] '/tmp/vuln'
Arch:     amd64-64-little
RELRO:    Full
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```
`checksec` (parte do [pwntools](https://github.com/pwncollege/pwntools) e muitas distribui√ß√µes) analisa os cabe√ßalhos `ELF` e imprime o n√≠vel de prote√ß√£o. Se voc√™ n√£o puder usar `checksec`, confie em `readelf`:
```bash
# Partial RELRO ‚Üí PT_GNU_RELRO is present but BIND_NOW is *absent*
$ readelf -l ./vuln | grep -E "GNU_RELRO|BIND_NOW"
GNU_RELRO      0x0000000000600e20 0x0000000000600e20
```

```bash
# Full RELRO ‚Üí PT_GNU_RELRO *and* the DF_BIND_NOW flag
$ readelf -d ./vuln | grep BIND_NOW
0x0000000000000010 (FLAGS)              FLAGS: BIND_NOW
```
Se o bin√°rio estiver em execu√ß√£o (por exemplo, um helper set-uid root), voc√™ ainda pode inspecionar o execut√°vel **via `/proc/$PID/exe`**:
```bash
readelf -l /proc/$(pgrep helper)/exe | grep GNU_RELRO
```
---

## Habilitando RELRO ao compilar seu pr√≥prio c√≥digo
```bash
# GCC example ‚Äì create a PIE with Full RELRO and other common hardenings
$ gcc -fPIE -pie -z relro -z now -Wl,--as-needed -D_FORTIFY_SOURCE=2 main.c -o secure
```
`-z relro -z now` funciona para ambos **GCC/clang** (passado ap√≥s `-Wl,`) e **ld** diretamente. Ao usar **CMake 3.18+** voc√™ pode solicitar Full RELRO com o preset embutido:
```cmake
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON) # LTO
set(CMAKE_ENABLE_EXPORTS OFF)
set(CMAKE_BUILD_RPATH_USE_ORIGIN ON)
set(CMAKE_EXE_LINKER_FLAGS "-Wl,-z,relro,-z,now")
```
---

## T√©cnicas de Bypass

| N√≠vel RELRO | Primitiva t√≠pica | T√©cnicas de explora√ß√£o poss√≠veis |
|-------------|-------------------|----------------------------------|
| Nenhum / Parcial | Escrita arbitr√°ria | 1. Sobrescrever a entrada **.got.plt** e mudar a execu√ß√£o.<br>2. **ret2dlresolve** ‚Äì criar `Elf64_Rela` & `Elf64_Sym` falsos em um segmento grav√°vel e chamar `_dl_runtime_resolve`.<br>3. Sobrescrever ponteiros de fun√ß√£o na lista **.fini_array** / **atexit()**. |
| Completo | GOT √© somente leitura | 1. Procurar **outros ponteiros de c√≥digo grav√°veis** (vtables C++, `__malloc_hook` < glibc 2.34, `__free_hook`, callbacks em se√ß√µes `.data` personalizadas, p√°ginas JIT).<br>2. Abusar de primitivas de *leitura relativa* para vazar libc e realizar **SROP/ROP em libc**.<br>3. Injetar um objeto compartilhado malicioso via **DT_RPATH**/`LD_PRELOAD` (se o ambiente for controlado pelo atacante) ou **`ld_audit`**.<br>4. Explorar **format-string** ou sobrescrita parcial de ponteiro para desviar o fluxo de controle sem tocar na GOT. |

> üí° Mesmo com Full RELRO, a **GOT de bibliotecas compartilhadas carregadas (por exemplo, a pr√≥pria libc)** √© **apenas RELRO Parcial** porque esses objetos j√° est√£o mapeados quando o carregador aplica relocations. Se voc√™ ganhar uma primitiva de **escrita arbitr√°ria** que pode direcionar as p√°ginas de outro objeto compartilhado, ainda pode mudar a execu√ß√£o sobrescrevendo as entradas da GOT da libc ou a pilha `__rtld_global`, uma t√©cnica frequentemente explorada em desafios modernos de CTF.

### Exemplo de bypass no mundo real (2024 CTF ‚Äì *pwn.college ‚Äúenlightened‚Äù*)

O desafio foi enviado com Full RELRO. O exploit usou um **off-by-one** para corromper o tamanho de um chunk de heap, vazou libc com `tcache poisoning` e finalmente sobrescreveu `__free_hook` (fora do segmento RELRO) com um one-gadget para obter execu√ß√£o de c√≥digo. Nenhuma escrita na GOT foi necess√°ria.

---

## Pesquisas recentes & vulnerabilidades (2022-2025)

* **glibc 2.40 descontinuou `__malloc_hook` / `__free_hook` (2025)** ‚Äì A maioria dos exploits modernos de heap que abusaram desses s√≠mbolos agora deve mudar para vetores alternativos, como **`rtld_global._dl_load_jump`** ou tabelas de exce√ß√£o C++. Como os hooks vivem **fora** do RELRO, sua remo√ß√£o aumenta a dificuldade de bypasses de Full-RELRO.
* **Corre√ß√£o ‚Äúmax-page-size‚Äù do Binutils 2.41 (2024)** ‚Äì Um bug permitiu que os √∫ltimos bytes do segmento RELRO compartilhassem uma p√°gina com dados grav√°veis em algumas compila√ß√µes ARM64, deixando um pequeno **gap RELRO** que poderia ser escrito ap√≥s `mprotect`. O upstream agora alinha `PT_GNU_RELRO` aos limites de p√°gina, eliminando esse caso extremo.

---

## Refer√™ncias

* Documenta√ß√£o do Binutils ‚Äì *`-z relro`, `-z now` e `PT_GNU_RELRO`*
* *‚ÄúRELRO ‚Äì Full, Partial and Bypass Techniques‚Äù* ‚Äì post no blog @ wolfslittlered 2023

{{#include ../../banners/hacktricks-training.md}}
