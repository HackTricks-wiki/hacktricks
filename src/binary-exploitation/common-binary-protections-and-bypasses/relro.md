# Relro

{{#include ../../banners/hacktricks-training.md}}

## Relro

**RELRO** stands for **Relocation Read-Only** i jest to mitigacja zaimplementowana przez linker (`ld`), kt√≥ra ustawia podzbi√≥r segment√≥w danych ELF jako **tylko do odczytu po zastosowaniu wszystkich relokacji**. Celem jest uniemo≈ºliwienie atakujƒÖcemu nadpisania wpis√≥w w **GOT (Global Offset Table)** lub innych tabel zwiƒÖzanych z relokacjami, kt√≥re sƒÖ dereferencjonowane podczas wykonywania programu (np. `__fini_array`).

Nowoczesne linkery implementujƒÖ RELRO poprzez **ponowne uporzƒÖdkowanie** **GOT** (i kilku innych sekcji), tak aby znajdowa≈Çy siƒô **przed** **.bss** i ‚Äî co najwa≈ºniejsze ‚Äî poprzez utworzenie dedykowanego segmentu `PT_GNU_RELRO`, kt√≥ry jest remapowany jako `R‚ÄìX` zaraz po tym, jak dynamic loader zako≈Ñczy stosowanie relokacji. W konsekwencji typowe buffer overflows w **.bss** nie mogƒÖ ju≈º dotrzeƒá do GOT, a arbitrary‚Äêwrite primitives nie mogƒÖ byƒá u≈ºyte do nadpisania wska≈∫nik√≥w funkcji znajdujƒÖcych siƒô na stronie chronionej przez RELRO.

IstniejƒÖ **dwa poziomy** ochrony, kt√≥re linker mo≈ºe wygenerowaƒá:

### Partial RELRO

* Produced with the flag `-Wl,-z,relro` (or just `-z relro` when invoking `ld` directly).
* Only the **non-PLT** part of the **GOT** (the part used for data relocations) is put into the read-only segment. Sections that need to be modified at run-time ‚Äì most importantly **.got.plt** which supports **lazy binding** ‚Äì remain writable.
* Because of that, an **arbitrary write** primitive can still redirect execution flow by overwriting a PLT entry (or by performing **ret2dlresolve**).
* The performance impact is negligible and therefore **almost every distribution has been shipping packages with at least Partial RELRO for years (it is the GCC/Binutils default as of 2016)**.

### Full RELRO

* Produced with **both** flags `-Wl,-z,relro,-z,now` (a.k.a. `-z relro -z now`).  `-z now` forces the dynamic loader to resolve **all** symbols up-front (eager binding) so that **.got.plt** never needs to be written again and can safely be mapped read-only.
* The entire **GOT**, **.got.plt**, **.fini_array**, **.init_array**, **.preinit_array** and a few additional internal glibc tables end up inside a read-only `PT_GNU_RELRO` segment.
* Adds measurable start-up overhead (all dynamic relocations are processed at launch) but **no run-time overhead**.

Since 2023 several mainstream distributions have switched to compiling the **system tool-chain** (and most packages) with **Full RELRO by default** ‚Äì e.g. **Debian 12 ‚Äúbookworm‚Äù (dpkg-buildflags 13.0.0)** and **Fedora 35+**. As a pentester you should therefore expect to encounter binaries where **every GOT entry is read-only**.

---

## How to Check the RELRO status of a binary
```bash
$ checksec --file ./vuln
[*] '/tmp/vuln'
Arch:     amd64-64-little
RELRO:    Full
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```
`checksec` (czƒô≈õƒá [pwntools](https://github.com/pwncollege/pwntools) i wielu dystrybucji) analizuje nag≈Ç√≥wki `ELF` i wypisuje poziom ochrony. Je≈õli nie mo≈ºesz u≈ºyƒá `checksec`, polegaj na `readelf`:
```bash
# Partial RELRO ‚Üí PT_GNU_RELRO is present but BIND_NOW is *absent*
$ readelf -l ./vuln | grep -E "GNU_RELRO|BIND_NOW"
GNU_RELRO      0x0000000000600e20 0x0000000000600e20
```

```bash
# Full RELRO ‚Üí PT_GNU_RELRO *and* the DF_BIND_NOW flag
$ readelf -d ./vuln | grep BIND_NOW
0x0000000000000010 (FLAGS)              FLAGS: BIND_NOW
```
Je≈õli binary jest uruchomiony (np. set-uid root helper), nadal mo≈ºesz zbadaƒá plik wykonywalny **przez `/proc/$PID/exe`**:
```bash
readelf -l /proc/$(pgrep helper)/exe | grep GNU_RELRO
```
---

## W≈ÇƒÖczanie RELRO podczas kompilacji w≈Çasnego kodu
```bash
# GCC example ‚Äì create a PIE with Full RELRO and other common hardenings
$ gcc -fPIE -pie -z relro -z now -Wl,--as-needed -D_FORTIFY_SOURCE=2 main.c -o secure
```
`-z relro -z now` dzia≈Ça zar√≥wno dla **GCC/clang** (przekazywane po `-Wl,`) jak i bezpo≈õrednio dla **ld**.  Przy u≈ºyciu **CMake 3.18+** mo≈ºesz wymusiƒá Full RELRO za pomocƒÖ wbudowanego presetu:
```cmake
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON) # LTO
set(CMAKE_ENABLE_EXPORTS OFF)
set(CMAKE_BUILD_RPATH_USE_ORIGIN ON)
set(CMAKE_EXE_LINKER_FLAGS "-Wl,-z,relro,-z,now")
```
---

## Techniki obej≈õcia

| RELRO level | Typical primitive | Possible exploitation techniques |
|-------------|-------------------|----------------------------------|
| None / Partial | Arbitrary write | 1. Nadpisz **.got.plt** entry i przekieruj wykonanie.<br>2. **ret2dlresolve** ‚Äì stw√≥rz fa≈Çszywe `Elf64_Rela` & `Elf64_Sym` w zapisywalnym segmencie i wywo≈Çaj `_dl_runtime_resolve`.<br>3. Nadpisz wska≈∫niki funkcji w **.fini_array** / li≈õcie **atexit()**. |
| Full | GOT is read-only | 1. Szukaj **other writable code pointers** (C++ vtables, `__malloc_hook` < glibc 2.34, `__free_hook`, callbacki w niestandardowych sekcjach `.data`, strony JIT).<br>2. Wykorzystaj prymitywy *relative read* do leak libc i przeprowad≈∫ **SROP/ROP into libc**.<br>3. Wstrzyknij z≈Ço≈õliwy shared object przez **DT_RPATH**/`LD_PRELOAD` (je≈õli ≈õrodowisko jest kontrolowane przez atakujƒÖcego) lub **`ld_audit`**.<br>4. Wykorzystaj **format-string** lub czƒô≈õciowe nadpisanie wska≈∫nika, aby przekierowaƒá przep≈Çyw sterowania bez dotykania GOT. |

> üí° Nawet przy Full RELRO **GOT za≈Çadowanych bibliotek wsp√≥≈Çdzielonych (np. libc)** jest **tylko Partial RELRO**, poniewa≈º te obiekty sƒÖ ju≈º zmapowane, gdy loader stosuje relokacje. Je≈õli zdobƒôdziesz prymityw **arbitrary write**, kt√≥ry mo≈ºe celowaƒá w strony innego obiektu wsp√≥≈Çdzielonego, nadal mo≈ºesz przekierowaƒá wykonanie przez nadpisanie wpis√≥w GOT libc lub stosu `__rtld_global` ‚Äî technika regularnie wykorzystywana w nowoczesnych zadaniach CTF.

### Real-world bypass example (2024 CTF ‚Äì *pwn.college ‚Äúenlightened‚Äù*)

The challenge shipped with Full RELRO.  The exploit used an **off-by-one** to corrupt the size of a heap chunk, leaked libc with `tcache poisoning`, and finally overwrote `__free_hook` (outside of the RELRO segment) with a one-gadget to get code execution.  No GOT write was required.

---

## Najnowsze badania i luki (2022-2025)

* **glibc hook removal (2.34 ‚Üí present)** ‚Äì malloc/free hooks zosta≈Çy przeniesione z g≈Ç√≥wnego libc do opcjonalnego `libc_malloc_debug.so`, eliminujƒÖc powszechny prymityw obej≈õcia Full‚ÄëRELRO; wsp√≥≈Çczesne exploity muszƒÖ celowaƒá w inne zapisywalne wska≈∫niki.
* **GNU ld RELRO page‚Äëalignment fix (binutils 2.39+/2.41)** ‚Äì linker bug 30612 powodowa≈Ç, ≈ºe ostatnie bajty `PT_GNU_RELRO` dzieli≈Çy zapisywalnƒÖ stronƒô w systemach ze stronƒÖ 64‚ÄØKiB; obecne binutils wyr√≥wnujƒÖ RELRO do `max-page-size`, zamykajƒÖc tƒô ‚ÄûRELRO gap‚Äù.

---

## References

* [Why malloc hooks were removed from glibc](https://developers.redhat.com/articles/2021/08/25/securing-malloc-glibc-why-malloc-hooks-had-go)
* [Binutils bug 30612 ‚Äì RELRO end alignment](https://lists.gnu.org/archive/html/bug-binutils/2023-08/msg00305.html)

{{#include ../../banners/hacktricks-training.md}}
