# Relro

{{#include ../../banners/hacktricks-training.md}}

## Relro

**RELRO** signifie **Relocation Read-Only**, et c'est une fonctionnalité de sécurité utilisée dans les binaires pour atténuer les risques associés aux écrasements de **GOT (Global Offset Table)**. Il existe deux types de protections **RELRO** : (1) **Partial RELRO** et (2) **Full RELRO**. Tous deux réorganisent la **GOT** et la **BSS** des fichiers ELF, mais avec des résultats et des implications différents. Plus précisément, ils placent la section **GOT** _avant_ la **BSS**. C'est-à-dire que **GOT** se trouve à des adresses inférieures à celles de **BSS**, rendant ainsi impossible l'écrasement des entrées **GOT** en débordant des variables dans la **BSS** (rappelez-vous que l'écriture en mémoire se fait des adresses inférieures vers les adresses supérieures).

Décomposons le concept en ses deux types distincts pour plus de clarté.

### **Partial RELRO**

**Partial RELRO** adopte une approche plus simple pour améliorer la sécurité sans impacter significativement les performances du binaire. Partial RELRO rend **la .got en lecture seule (la partie non-PLT de la section GOT)**. Gardez à l'esprit que le reste de la section (comme la .got.plt) est toujours modifiable et, par conséquent, sujet à des attaques. Cela **ne prévient pas l'abus de la GOT** à partir de vulnérabilités d'**écriture arbitraire**.

Note : Par défaut, GCC compile les binaires avec Partial RELRO.

### **Full RELRO**

**Full RELRO** renforce la protection en **rendant l'ensemble de la GOT (à la fois .got et .got.plt) et la section .fini_array** complètement **en lecture seule.** Une fois que le binaire démarre, toutes les adresses de fonction sont résolues et chargées dans la GOT, puis, la GOT est marquée comme en lecture seule, empêchant effectivement toute modification pendant l'exécution.

Cependant, le compromis avec Full RELRO se situe en termes de performances et de temps de démarrage. Parce qu'il doit résoudre tous les symboles dynamiques au démarrage avant de marquer la GOT comme en lecture seule, **les binaires avec Full RELRO activé peuvent connaître des temps de chargement plus longs**. Ce surcoût supplémentaire au démarrage est la raison pour laquelle Full RELRO n'est pas activé par défaut dans tous les binaires.

Il est possible de voir si Full RELRO est **activé** dans un binaire avec :
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
## Bypass

Si Full RELRO est activé, la seule façon de le contourner est de trouver un autre moyen qui ne nécessite pas d'écrire dans la table GOT pour obtenir une exécution arbitraire.

Notez que **la GOT de LIBC est généralement en Partial RELRO**, donc elle peut être modifiée avec une écriture arbitraire. Plus d'informations dans [Targetting libc GOT entries](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#1---targetting-libc-got-entries)**.**

{{#include ../../banners/hacktricks-training.md}}
