# Relro

{{#include ../../banners/hacktricks-training.md}}

## Relro

**RELRO** का मतलब है **Relocation Read-Only**, और यह बाइनरी में एक सुरक्षा विशेषता है जो **GOT (Global Offset Table)** ओवरराइट्स से संबंधित जोखिमों को कम करने के लिए उपयोग की जाती है। **RELRO** सुरक्षा के दो प्रकार हैं: (1) **Partial RELRO** और (2) **Full RELRO**। दोनों **GOT** और **BSS** को ELF फ़ाइलों से पुनर्व्यवस्थित करते हैं, लेकिन विभिन्न परिणामों और निहितार्थों के साथ। विशेष रूप से, वे **GOT** अनुभाग को **BSS** से _पहले_ रखते हैं। अर्थात, **GOT** के पते **BSS** से कम हैं, जिससे **BSS** में वेरिएबल्स को ओवरफ्लो करके **GOT** प्रविष्टियों को ओवरराइट करना असंभव हो जाता है (याद रखें कि मेमोरी में लिखना निम्न से उच्च पते की ओर होता है)।

स्पष्टता के लिए, हम इस अवधारणा को इसके दो अलग-अलग प्रकारों में विभाजित करते हैं।

### **Partial RELRO**

**Partial RELRO** सुरक्षा को बढ़ाने के लिए एक सरल दृष्टिकोण अपनाता है बिना बाइनरी के प्रदर्शन पर महत्वपूर्ण प्रभाव डाले। Partial RELRO **.got को केवल पढ़ने योग्य बनाता है (GOT अनुभाग का गैर-PLT भाग)**। ध्यान रखें कि अनुभाग का बाकी हिस्सा (जैसे .got.plt) अभी भी लिखने योग्य है और, इसलिए, हमलों के अधीन है। यह **GOT** को **मनमाने लिखने** की कमजोरियों से दुरुपयोग करने से नहीं रोकता है।

नोट: डिफ़ॉल्ट रूप से, GCC बाइनरी को Partial RELRO के साथ संकलित करता है।

### **Full RELRO**

**Full RELRO** सुरक्षा को बढ़ाता है **पूरे GOT (दोनों .got और .got.plt) और .fini_array** अनुभाग को पूरी तरह से **पढ़ने योग्य** बनाकर। एक बार जब बाइनरी शुरू होती है, तो सभी फ़ंक्शन पते GOT में हल और लोड होते हैं, फिर, GOT को पढ़ने योग्य के रूप में चिह्नित किया जाता है, प्रभावी रूप से रनटाइम के दौरान इसमें किसी भी संशोधन को रोकता है।

हालांकि, Full RELRO के साथ व्यापार-निष्कर्ष प्रदर्शन और स्टार्टअप समय के संदर्भ में है। क्योंकि इसे GOT को पढ़ने योग्य के रूप में चिह्नित करने से पहले स्टार्टअप पर सभी गतिशील प्रतीकों को हल करने की आवश्यकता होती है, **Full RELRO सक्षम बाइनरी में लंबे लोड समय का अनुभव हो सकता है**। यह अतिरिक्त स्टार्टअप ओवरहेड ही कारण है कि Full RELRO सभी बाइनरी में डिफ़ॉल्ट रूप से सक्षम नहीं है।

यह देखना संभव है कि क्या Full RELRO एक बाइनरी में **सक्षम** है:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
## Bypass

यदि Full RELRO सक्षम है, तो इसे बायपास करने का एकमात्र तरीका यह है कि कोई और तरीका खोजा जाए जिसे मनमाने निष्पादन के लिए GOT तालिका में लिखने की आवश्यकता न हो।

ध्यान दें कि **LIBC का GOT आमतौर पर Partial RELRO है**, इसलिए इसे मनमाने लिखने के साथ संशोधित किया जा सकता है। अधिक जानकारी के लिए [Targetting libc GOT entries](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#1---targetting-libc-got-entries)**.**

{{#include ../../banners/hacktricks-training.md}}
