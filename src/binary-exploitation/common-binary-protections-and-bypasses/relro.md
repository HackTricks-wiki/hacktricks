# Relro

{{#include ../../banners/hacktricks-training.md}}

## Relro

**RELRO** signifie **Relocation Read-Only** et c'est une att√©nuation mise en ≈ìuvre par le linker (`ld`) qui rend un sous-ensemble des segments de donn√©es ELF **lecture seule apr√®s que toutes les relocations ont √©t√© appliqu√©es**. L'objectif est d'emp√™cher un attaquant de remplacer des entr√©es dans la **GOT (Global Offset Table)** ou d'autres tables li√©es aux relocations qui sont d√©r√©f√©renc√©es pendant l'ex√©cution du programme (par exemple, `__fini_array`).

Les linkers modernes mettent en ≈ìuvre RELRO en **r√©organisant** la **GOT** (et quelques autres sections) afin qu'elles se trouvent **avant** le **.bss** et ‚Äì surtout ‚Äì en cr√©ant un segment `PT_GNU_RELRO` d√©di√© qui est remapp√© `R‚ÄìX` juste apr√®s que le chargeur dynamique ait termin√© d'appliquer les relocations. Par cons√©quent, les d√©bordements de tampon typiques dans le **.bss** ne peuvent plus atteindre la GOT et les primitives d'√©criture arbitraire ne peuvent pas √™tre utilis√©es pour √©craser des pointeurs de fonction qui se trouvent √† l'int√©rieur d'une page prot√©g√©e par RELRO.

Il existe **deux niveaux** de protection que le linker peut √©mettre :

### Partial RELRO

* Produit avec le drapeau `-Wl,-z,relro` (ou juste `-z relro` lors de l'invocation directe de `ld`).
* Seule la partie **non-PLT** de la **GOT** (la partie utilis√©e pour les relocations de donn√©es) est plac√©e dans le segment en lecture seule. Les sections qui doivent √™tre modifi√©es √† l'ex√©cution ‚Äì surtout **.got.plt** qui prend en charge **lazy binding** ‚Äì restent modifiables.
* √Ä cause de cela, une primitive **d'√©criture arbitraire** peut toujours rediriger le flux d'ex√©cution en √©crasant une entr√©e PLT (ou en effectuant **ret2dlresolve**).
* L'impact sur les performances est n√©gligeable et donc **presque toutes les distributions exp√©dient des paquets avec au moins Partial RELRO depuis des ann√©es (c'est le d√©faut de GCC/Binutils depuis 2016)**.

### Full RELRO

* Produit avec **les deux** drapeaux `-Wl,-z,relro,-z,now` (a.k.a. `-z relro -z now`). `-z now` force le chargeur dynamique √† r√©soudre **tous** les symboles √† l'avance (liaison impatiente) afin que **.got.plt** n'ait jamais besoin d'√™tre √©crit √† nouveau et puisse √™tre mapp√© en toute s√©curit√© en lecture seule.
* L'ensemble de la **GOT**, **.got.plt**, **.fini_array**, **.init_array**, **.preinit_array** et quelques tables internes suppl√©mentaires de glibc se retrouvent √† l'int√©rieur d'un segment `PT_GNU_RELRO` en lecture seule.
* Ajoute un surco√ªt de d√©marrage mesurable (toutes les relocations dynamiques sont trait√©es au lancement) mais **aucun surco√ªt √† l'ex√©cution**.

Depuis 2023, plusieurs distributions grand public ont commenc√© √† compiler la **tool-chain syst√®me** (et la plupart des paquets) avec **Full RELRO par d√©faut** ‚Äì par exemple **Debian 12 ‚Äúbookworm‚Äù (dpkg-buildflags 13.0.0)** et **Fedora 35+**. En tant que pentester, vous devez donc vous attendre √† rencontrer des binaires o√π **chaque entr√©e GOT est en lecture seule**.

---

## Comment v√©rifier le statut RELRO d'un binaire
```bash
$ checksec --file ./vuln
[*] '/tmp/vuln'
Arch:     amd64-64-little
RELRO:    Full
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```
`checksec` (fait partie de [pwntools](https://github.com/pwncollege/pwntools) et de nombreuses distributions) analyse les en-t√™tes `ELF` et affiche le niveau de protection. Si vous ne pouvez pas utiliser `checksec`, comptez sur `readelf`:
```bash
# Partial RELRO ‚Üí PT_GNU_RELRO is present but BIND_NOW is *absent*
$ readelf -l ./vuln | grep -E "GNU_RELRO|BIND_NOW"
GNU_RELRO      0x0000000000600e20 0x0000000000600e20
```

```bash
# Full RELRO ‚Üí PT_GNU_RELRO *and* the DF_BIND_NOW flag
$ readelf -d ./vuln | grep BIND_NOW
0x0000000000000010 (FLAGS)              FLAGS: BIND_NOW
```
Si le binaire est en cours d'ex√©cution (par exemple, un helper set-uid root), vous pouvez toujours inspecter l'ex√©cutable **via `/proc/$PID/exe`** :
```bash
readelf -l /proc/$(pgrep helper)/exe | grep GNU_RELRO
```
---

## Activer RELRO lors de la compilation de votre propre code
```bash
# GCC example ‚Äì create a PIE with Full RELRO and other common hardenings
$ gcc -fPIE -pie -z relro -z now -Wl,--as-needed -D_FORTIFY_SOURCE=2 main.c -o secure
```
`-z relro -z now` fonctionne pour **GCC/clang** (pass√© apr√®s `-Wl,`) et **ld** directement. Lorsque vous utilisez **CMake 3.18+**, vous pouvez demander Full RELRO avec le pr√©r√©glage int√©gr√© :
```cmake
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON) # LTO
set(CMAKE_ENABLE_EXPORTS OFF)
set(CMAKE_BUILD_RPATH_USE_ORIGIN ON)
set(CMAKE_EXE_LINKER_FLAGS "-Wl,-z,relro,-z,now")
```
---

## Techniques de contournement

| Niveau RELRO | Primitive typique | Techniques d'exploitation possibles |
|--------------|-------------------|------------------------------------|
| Aucun / Partiel | √âcriture arbitraire | 1. √âcraser l'entr√©e **.got.plt** et pivoter l'ex√©cution.<br>2. **ret2dlresolve** ‚Äì cr√©er un faux `Elf64_Rela` & `Elf64_Sym` dans un segment √©crivable et appeler `_dl_runtime_resolve`.<br>3. √âcraser les pointeurs de fonction dans **.fini_array** / liste **atexit()**. |
| Complet | GOT en lecture seule | 1. Rechercher **d'autres pointeurs de code √©crivable** (vtables C++, `__malloc_hook` < glibc 2.34, `__free_hook`, rappels dans des sections `.data` personnalis√©es, pages JIT).<br>2. Abuser des primitives de *lecture relative* pour divulguer libc et effectuer **SROP/ROP dans libc**.<br>3. Injecter un objet partag√© malveillant via **DT_RPATH**/`LD_PRELOAD` (si l'environnement est contr√¥l√© par l'attaquant) ou **`ld_audit`**.<br>4. Exploiter **format-string** ou √©criture partielle de pointeur pour d√©tourner le flux de contr√¥le sans toucher le GOT. |

> üí° M√™me avec un RELRO Complet, le **GOT des biblioth√®ques partag√©es charg√©es (par exemple, libc elle-m√™me)** est **seulement Partiel RELRO** car ces objets sont d√©j√† mapp√©s lorsque le chargeur applique les relocations. Si vous obtenez une primitive **d'√©criture arbitraire** qui peut cibler les pages d'un autre objet partag√©, vous pouvez toujours pivoter l'ex√©cution en √©crasant les entr√©es GOT de libc ou la pile `__rtld_global`, une technique r√©guli√®rement exploit√©e dans les d√©fis CTF modernes.

### Exemple de contournement dans le monde r√©el (CTF 2024 ‚Äì *pwn.college ‚Äúenlightened‚Äù*)

Le d√©fi √©tait livr√© avec un RELRO Complet. L'exploitation a utilis√© un **off-by-one** pour corrompre la taille d'un morceau de tas, a divulgu√© libc avec `tcache poisoning`, et enfin a √©cras√© `__free_hook` (en dehors du segment RELRO) avec un one-gadget pour obtenir l'ex√©cution de code. Aucune √©criture dans le GOT n'√©tait requise.

---

## Recherches r√©centes & vuln√©rabilit√©s (2022-2025)

* **glibc 2.40 d√©pr√©cie `__malloc_hook` / `__free_hook` (2025)** ‚Äì La plupart des exploits de tas modernes qui abusaient de ces symboles doivent maintenant pivoter vers des vecteurs alternatifs tels que **`rtld_global._dl_load_jump`** ou les tables d'exceptions C++. √âtant donn√© que les hooks vivent **en dehors** du RELRO, leur suppression augmente la difficult√© des contournements de RELRO Complet.
* **Correction ‚Äúmax-page-size‚Äù de Binutils 2.41 (2024)** ‚Äì Un bug permettait aux derniers octets du segment RELRO de partager une page avec des donn√©es √©crivables sur certaines constructions ARM64, laissant un petit **√©cart RELRO** qui pouvait √™tre √©crit apr√®s `mprotect`. En amont, `PT_GNU_RELRO` est maintenant align√© sur les limites de page, √©liminant ce cas particulier.

---

## R√©f√©rences

* Documentation de Binutils ‚Äì *`-z relro`, `-z now` et `PT_GNU_RELRO`*
* *‚ÄúRELRO ‚Äì Complet, Partiel et Techniques de Contournement‚Äù* ‚Äì article de blog @ wolfslittlered 2023

{{#include ../../banners/hacktricks-training.md}}
