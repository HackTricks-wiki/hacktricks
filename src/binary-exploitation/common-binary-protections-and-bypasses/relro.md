# Relro

{{#include ../../banners/hacktricks-training.md}}

## Relro

**RELRO** stands for **Relocation Read-Only** and it is a mitigation implemented by the linker (`ld`) that turns a subset of the ELFâ€™s data segments **read-only after all relocations have been applied**.  The goal is to stop an attacker from overwriting entries in the **GOT (Global Offset Table)** or other relocation-related tables that are dereferenced during program execution (e.g. `__fini_array`).

Modern linkers implement RELRO by **reâ€“ordering** the **GOT** (and a few other sections) so they live **before** the **.bss** and â€“ most importantly â€“ by creating a dedicated `PT_GNU_RELRO` segment that is remapped `Râ€“X` right after the dynamic loader finishes applying relocations.  Consequently, typical buffer overflows in the **.bss** can no longer reach the GOT and arbitraryâ€write primitives cannot be used to overwrite function pointers that sit inside a RELRO-protected page.

There are **two levels** of protection that the linker can emit:

### Partial RELRO

* Produced with the flag `-Wl,-z,relro` (or just `-z relro` when invoking `ld` directly).
* Only the **non-PLT** part of the **GOT** (the part used for data relocations) is put into the read-only segment.  Sections that need to be modified at run-time â€“ most importantly **.got.plt** which supports **lazy binding** â€“ remain writable.
* Because of that, an **arbitrary write** primitive can still redirect execution flow by overwriting a PLT entry (or by performing **ret2dlresolve**).
* The performance impact is negligible and therefore **almost every distribution has been shipping packages with at least Partial RELRO for years (it is the GCC/Binutils default as of 2016)**.

### Full RELRO

* Produced with **both** flags `-Wl,-z,relro,-z,now` (a.k.a. `-z relro -z now`).  `-z now` forces the dynamic loader to resolve **all** symbols up-front (eager binding) so that **.got.plt** never needs to be written again and can safely be mapped read-only.
* The entire **GOT**, **.got.plt**, **.fini_array**, **.init_array**, **.preinit_array** and a few additional internal glibc tables end up inside a read-only `PT_GNU_RELRO` segment.
* Adds measurable start-up overhead (all dynamic relocations are processed at launch) but **no run-time overhead**.

Since 2023 several mainstream distributions have switched to compiling the **system tool-chain** (and most packages) with **Full RELRO by default** â€“ e.g. **Debian 12 â€œbookwormâ€ (dpkg-buildflags 13.0.0)** and **Fedora 35+**.  As a pentester you should therefore expect to encounter binaries where **every GOT entry is read-only**.

---

## Bir ikili dosyanÄ±n RELRO durumunu nasÄ±l kontrol edersiniz
```bash
$ checksec --file ./vuln
[*] '/tmp/vuln'
Arch:     amd64-64-little
RELRO:    Full
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```
`checksec` ([pwntools] paketinin bir parÃ§asÄ± ve birÃ§ok daÄŸÄ±tÄ±mda mevcuttur) `ELF` baÅŸlÄ±klarÄ±nÄ± Ã§Ã¶zer ve koruma seviyesini yazdÄ±rÄ±r. `checksec` kullanamÄ±yorsanÄ±z, `readelf`'e gÃ¼venin:
```bash
# Partial RELRO â†’ PT_GNU_RELRO is present but BIND_NOW is *absent*
$ readelf -l ./vuln | grep -E "GNU_RELRO|BIND_NOW"
GNU_RELRO      0x0000000000600e20 0x0000000000600e20
```

```bash
# Full RELRO â†’ PT_GNU_RELRO *and* the DF_BIND_NOW flag
$ readelf -d ./vuln | grep BIND_NOW
0x0000000000000010 (FLAGS)              FLAGS: BIND_NOW
```
EÄŸer binary Ã§alÄ±ÅŸÄ±yorsa (Ã¶r. set-uid root helper), yine yÃ¼rÃ¼tÃ¼lebilir dosyayÄ± **Ã¼zerinden `/proc/$PID/exe`** inceleyebilirsiniz:
```bash
readelf -l /proc/$(pgrep helper)/exe | grep GNU_RELRO
```
---

## Kendi kodunuzu derlerken RELRO'yu etkinleÅŸtirme
```bash
# GCC example â€“ create a PIE with Full RELRO and other common hardenings
$ gcc -fPIE -pie -z relro -z now -Wl,--as-needed -D_FORTIFY_SOURCE=2 main.c -o secure
```
`-z relro -z now` hem **GCC/clang** (`-Wl,` sonrasÄ±nda geÃ§irilir) hem de doÄŸrudan **ld** iÃ§in Ã§alÄ±ÅŸÄ±r. **CMake 3.18+** kullanÄ±yorsanÄ±z yerleÅŸik preset ile Full RELRO talep edebilirsiniz:
```cmake
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON) # LTO
set(CMAKE_ENABLE_EXPORTS OFF)
set(CMAKE_BUILD_RPATH_USE_ORIGIN ON)
set(CMAKE_EXE_LINKER_FLAGS "-Wl,-z,relro,-z,now")
```
---

## Atlatma Teknikleri

| RELRO level | Typical primitive | Possible exploitation techniques |
|-------------|-------------------|----------------------------------|
| None / Partial | Arbitrary write | 1. Overwrite **.got.plt** entry and pivot execution.<br>2. **ret2dlresolve** â€“ craft fake `Elf64_Rela` & `Elf64_Sym` in a writable segment and call `_dl_runtime_resolve`.<br>3. Overwrite function pointers in **.fini_array** / **atexit()** list. |
| Full | GOT is read-only | 1. Look for **other writable code pointers** (C++ vtables, `__malloc_hook` < glibc 2.34, `__free_hook`, callbacks in custom `.data` sections, JIT pages).<br>2. Abuse *relative read* primitives to leak libc and perform **SROP/ROP into libc**.<br>3. Inject a rogue shared object via **DT_RPATH**/`LD_PRELOAD` (if environment is attacker-controlled) or **`ld_audit`**.<br>4. Exploit **format-string** or partial pointer overwrite to divert control-flow without touching the GOT. |

> ğŸ’¡ Full RELRO olsa bile, **GOT of loaded shared libraries (e.g. libc itself)** **sadece Partial RELRO** olur Ã§Ã¼nkÃ¼ loader relocations uygulandÄ±ÄŸÄ±nda bu nesneler zaten maplenmiÅŸ olur. EÄŸer baÅŸka bir shared objectâ€™in sayfalarÄ±nÄ± hedefleyebilen bir **arbitrary write** primitive elde ederseniz, libcâ€™nin GOT entryâ€™lerini veya `__rtld_global` yÄ±ÄŸÄ±nÄ±nÄ± overwrite ederek hÃ¢lÃ¢ execution pivot edebilirsiniz; bu, modern CTF challengeâ€™larÄ±nda dÃ¼zenli olarak kullanÄ±lan bir tekniktir.

### GerÃ§ek dÃ¼nya atlatma Ã¶rneÄŸi (2024 CTF â€“ *pwn.college â€œenlightenedâ€*)

Challenge Full RELRO ile geldi. Exploit, heap chunk boyutunu bozmak iÃ§in bir **off-by-one** kullandÄ±, `tcache poisoning` ile libcâ€™yi leaked etti ve sonunda RELRO segmenti dÄ±ÅŸÄ±nda kalan `__free_hook`â€™u bir one-gadget ile overwrite ederek kod yÃ¼rÃ¼tme elde etti. GOT yazmasÄ± gerekmedi.

---

## Son araÅŸtÄ±rmalar & zafiyetler (2022-2025)

* **glibc hook removal (2.34 â†’ present)** â€“ malloc/free hookâ€™larÄ± ana libcâ€™den opsiyonel `libc_malloc_debug.so`â€™ya taÅŸÄ±ndÄ±; bu, yaygÄ±n bir Fullâ€‘RELRO atlatma primitiveâ€™ini ortadan kaldÄ±rdÄ±; modern exploitâ€™lerin diÄŸer writable pointerâ€™larÄ± hedeflemesi gerekiyor.
* **GNU ld RELRO pageâ€‘alignment fix (binutils 2.39+/2.41)** â€“ linker bug 30612, `PT_GNU_RELRO`â€™nun son byteâ€™larÄ±nÄ±n 64â€¯KiB sayfa sistemlerinde writable bir sayfayÄ± paylaÅŸmasÄ±na neden oluyordu; mevcut binutils RELROâ€™yu `max-page-size`â€™a hizalayarak bu â€œRELRO gapâ€i kapattÄ±.

---

## References

* [Why malloc hooks were removed from glibc](https://developers.redhat.com/articles/2021/08/25/securing-malloc-glibc-why-malloc-hooks-had-go)
* [Binutils bug 30612 â€“ RELRO end alignment](https://lists.gnu.org/archive/html/bug-binutils/2023-08/msg00305.html)

{{#include ../../banners/hacktricks-training.md}}
