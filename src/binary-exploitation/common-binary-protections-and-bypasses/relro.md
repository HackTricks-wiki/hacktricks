# Relro

{{#include ../../banners/hacktricks-training.md}}

## Relro

**RELRO** stands for **Relocation Read-Only** and it is a mitigation implemented by the linker (`ld`) that turns a subset of the ELFâ€™s data segments **read-only after all relocations have been applied**.  The goal is to stop an attacker from overwriting entries in the **GOT (Global Offset Table)** or other relocation-related tables that are dereferenced during program execution (e.g. `__fini_array`).

í˜„ëŒ€ì˜ ë§ì»¤ë“¤ì€ **GOT**(ë° ëª‡ëª‡ ë‹¤ë¥¸ ì„¹ì…˜)ë¥¼ **ì¬ì •ë ¬(reâ€“ordering)**í•˜ì—¬ ì´ë“¤ì´ **.bss**ë³´ë‹¤ **ì•ì—** ìœ„ì¹˜í•˜ë„ë¡ ë§Œë“¤ê³ , ê°€ì¥ ì¤‘ìš”í•œ ê²ƒì€ ë™ì  ë¡œë”ê°€ ì¬ë°°ì¹˜ ì ìš©ì„ ì™„ë£Œí•œ ì§í›„ `PT_GNU_RELRO` ì „ìš© ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ìƒì„±í•˜ì—¬ `Râ€“X`ë¡œ ì¬ë§¤í•‘í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ RELROë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤. ê²°ê³¼ì ìœ¼ë¡œ **.bss**ì—ì„œ ë°œìƒí•˜ëŠ” ì „í˜•ì ì¸ ë²„í¼ ì˜¤ë²„í”Œë¡œìš°ëŠ” ë” ì´ìƒ GOTì— ë„ë‹¬í•  ìˆ˜ ì—†ìœ¼ë©°, arbitraryâ€write í”„ë¦¬ë¯¸í‹°ë¸Œë¡œ RELROë¡œ ë³´í˜¸ëœ í˜ì´ì§€ ë‚´ë¶€ì˜ í•¨ìˆ˜ í¬ì¸í„°ë¥¼ ë®ì–´ì“¸ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

There are **two levels** of protection that the linker can emit:

### Partial RELRO

* Produced with the flag `-Wl,-z,relro` (or just `-z relro` when invoking `ld` directly).
* Only the **non-PLT** part of the **GOT** (the part used for data relocations) is put into the read-only segment.  Sections that need to be modified at run-time â€“ most importantly **.got.plt** which supports **lazy binding** â€“ remain writable.
* Because of that, an **arbitrary write** primitive can still redirect execution flow by overwriting a PLT entry (or by performing **ret2dlresolve**).
* The performance impact is negligible and therefore **almost every distribution has been shipping packages with at least Partial RELRO for years (it is the GCC/Binutils default as of 2016)**.

### Full RELRO

* Produced with **both** flags `-Wl,-z,relro,-z,now` (a.k.a. `-z relro -z now`).  `-z now` forces the dynamic loader to resolve **all** symbols up-front (eager binding) so that **.got.plt** never needs to be written again and can safely be mapped read-only.
* The entire **GOT**, **.got.plt**, **.fini_array**, **.init_array**, **.preinit_array** and a few additional internal glibc tables end up inside a read-only `PT_GNU_RELRO` segment.
* Adds measurable start-up overhead (all dynamic relocations are processed at launch) but **no run-time overhead**.

Since 2023 several mainstream distributions have switched to compiling the **system tool-chain** (and most packages) with **Full RELRO by default** â€“ e.g. **Debian 12 â€œbookwormâ€ (dpkg-buildflags 13.0.0)** and **Fedora 35+**.  As a pentester you should therefore expect to encounter binaries where **every GOT entry is read-only**.

---

## ë°”ì´ë„ˆë¦¬ì˜ RELRO ìƒíƒœë¥¼ í™•ì¸í•˜ëŠ” ë°©ë²•
```bash
$ checksec --file ./vuln
[*] '/tmp/vuln'
Arch:     amd64-64-little
RELRO:    Full
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```
`checksec` (ëŠ” [pwntools](https://github.com/pwncollege/pwntools)ì˜ ì¼ë¶€ì´ì ë§ì€ ë°°í¬íŒì— í¬í•¨ë˜ì–´ ìˆìŒ)ëŠ” `ELF` í—¤ë”ë¥¼ íŒŒì‹±í•˜ê³  ë³´í˜¸ ìˆ˜ì¤€ì„ ì¶œë ¥í•©ë‹ˆë‹¤. `checksec`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤ë©´ `readelf`ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”:
```bash
# Partial RELRO â†’ PT_GNU_RELRO is present but BIND_NOW is *absent*
$ readelf -l ./vuln | grep -E "GNU_RELRO|BIND_NOW"
GNU_RELRO      0x0000000000600e20 0x0000000000600e20
```

```bash
# Full RELRO â†’ PT_GNU_RELRO *and* the DF_BIND_NOW flag
$ readelf -d ./vuln | grep BIND_NOW
0x0000000000000010 (FLAGS)              FLAGS: BIND_NOW
```
ë°”ì´ë„ˆë¦¬ê°€ ì‹¤í–‰ ì¤‘ì¸ ê²½ìš°(ì˜ˆ: a set-uid root helper), ì‹¤í–‰ íŒŒì¼ì„ ì—¬ì „íˆ ê²€ì‚¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤ **via `/proc/$PID/exe`**:
```bash
readelf -l /proc/$(pgrep helper)/exe | grep GNU_RELRO
```
---

## ìì‹ ì˜ ì½”ë“œë¥¼ ì»´íŒŒì¼í•  ë•Œ RELRO í™œì„±í™”
```bash
# GCC example â€“ create a PIE with Full RELRO and other common hardenings
$ gcc -fPIE -pie -z relro -z now -Wl,--as-needed -D_FORTIFY_SOURCE=2 main.c -o secure
```
`-z relro -z now`ëŠ” **GCC/clang** (`-Wl,` ë’¤ì— ì „ë‹¬)ê³¼ **ld**ì—ì„œ ëª¨ë‘ ë™ì‘í•©ë‹ˆë‹¤. **CMake 3.18+**ë¥¼ ì‚¬ìš©í•  ê²½ìš° ë‚´ì¥ í”„ë¦¬ì…‹ìœ¼ë¡œ Full RELROë¥¼ ìš”ì²­í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:
```cmake
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON) # LTO
set(CMAKE_ENABLE_EXPORTS OFF)
set(CMAKE_BUILD_RPATH_USE_ORIGIN ON)
set(CMAKE_EXE_LINKER_FLAGS "-Wl,-z,relro,-z,now")
```
---

## Bypass Techniques

| RELRO level | Typical primitive | Possible exploitation techniques |
|-------------|-------------------|----------------------------------|
| None / Partial | Arbitrary write | 1. Overwrite **.got.plt** entry and pivot execution.<br>2. **ret2dlresolve** â€“ writable ì„¸ê·¸ë¨¼íŠ¸ì— ê°€ì§œ `Elf64_Rela` & `Elf64_Sym`ë¥¼ ìƒì„±í•˜ê³  `_dl_runtime_resolve`ë¥¼ í˜¸ì¶œ.<br>3. **.fini_array** / **atexit()** ëª©ë¡ì˜ í•¨ìˆ˜ í¬ì¸í„°ë¥¼ ë®ì–´ì“°ê¸°. |
| Full | GOT is read-only | 1. ë‹¤ë¥¸ **writable code pointers**(C++ vtables, `__malloc_hook` < glibc 2.34, `__free_hook`, custom `.data` ì„¹ì…˜ì˜ ì½œë°±, JIT í˜ì´ì§€)ë¥¼ ì°¾ê¸°.<br>2. ìƒëŒ€ì  ì½ê¸°(*relative read*) í”„ë¦¬ë¯¸í‹°ë¸Œë¥¼ ì•…ìš©í•´ libcë¥¼ leakí•˜ê³  **SROP/ROP into libc** ìˆ˜í–‰.<br>3. ê³µê²©ìê°€ ì œì–´í•˜ëŠ” í™˜ê²½ì´ë¼ë©´ **DT_RPATH**/`LD_PRELOAD`ë¥¼ í†µí•´ ì•…ì„± shared objectë¥¼ ì£¼ì…í•˜ê±°ë‚˜ **`ld_audit`** ì‚¬ìš©.<br>4. **format-string** ë˜ëŠ” ë¶€ë¶„ í¬ì¸í„° ë®ì–´ì“°ê¸°ë¥¼ ì´ìš©í•´ GOTë¥¼ ê±´ë“œë¦¬ì§€ ì•Šê³  ì œì–´ íë¦„ì„ ì „í™˜. |

> ğŸ’¡ Full RELRO í™˜ê²½ì—ì„œë„ **GOT of loaded shared libraries (e.g. libc itself)**ëŠ” ë¡œë”ê°€ ì´ë¯¸ ì¬ë°°ì¹˜ë¥¼ ì ìš©í•  ë•Œ ë§µí•‘ë˜ì–´ ìˆê¸° ë•Œë¬¸ì— **only Partial RELRO**ì…ë‹ˆë‹¤. ë‹¤ë¥¸ shared objectì˜ í˜ì´ì§€ë¥¼ ëŒ€ìƒìœ¼ë¡œ ì‚¼ì„ ìˆ˜ ìˆëŠ” **arbitrary write** í”„ë¦¬ë¯¸í‹°ë¸Œë¥¼ ì–»ìœ¼ë©´ libcì˜ GOT ì—”íŠ¸ë¦¬ë‚˜ `__rtld_global` ìŠ¤íƒì„ ë®ì–´ì¨ì„œ ì—¬ì „íˆ ì‹¤í–‰ì„ í”¼ë²—í•  ìˆ˜ ìˆìœ¼ë©°, ì´ëŠ” í˜„ëŒ€ CTF ë¬¸ì œì—ì„œ ìì£¼ ì•…ìš©ë˜ëŠ” ê¸°ë²•ì…ë‹ˆë‹¤.

### Real-world bypass example (2024 CTF â€“ *pwn.college â€œenlightenedâ€*)

í•´ë‹¹ ì±Œë¦°ì§€ëŠ” Full RELROë¡œ ë°°í¬ë˜ì—ˆìŠµë‹ˆë‹¤. ìµìŠ¤í”Œë¡œì‡ì€ **off-by-one**ìœ¼ë¡œ í™ ì²­í¬ì˜ í¬ê¸°ë¥¼ ì†ìƒì‹œì¼°ê³ , `tcache poisoning`ìœ¼ë¡œ libcë¥¼ leakí•œ ë’¤ RELRO ì„¸ê·¸ë¨¼íŠ¸ ì™¸ë¶€ì˜ `__free_hook`ì„ one-gadgetìœ¼ë¡œ ë®ì–´ì¨ ì½”ë“œ ì‹¤í–‰ì„ ì–»ì—ˆìŠµë‹ˆë‹¤. GOT writeëŠ” í•„ìš”í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.

---

## Recent research & vulnerabilities (2022-2025)

* **glibc hook removal (2.34 â†’ present)** â€“ malloc/free í›…ë“¤ì´ ë©”ì¸ libcì—ì„œ ì„ íƒì  `libc_malloc_debug.so`ë¡œ ë¶„ë¦¬ë˜ì–´ Fullâ€‘RELRO ìš°íšŒì— ìì£¼ ì“°ì´ë˜ í”„ë¦¬ë¯¸í‹°ë¸Œê°€ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤; í˜„ëŒ€ ìµìŠ¤í”Œë¡œì‡ì€ ë‹¤ë¥¸ writable í¬ì¸í„°ë¥¼ ëª©í‘œë¡œ í•´ì•¼ í•©ë‹ˆë‹¤.
* **GNU ld RELRO pageâ€‘alignment fix (binutils 2.39+/2.41)** â€“ linker bug 30612ëŠ” 64â€¯KiB í˜ì´ì§€ ì‹œìŠ¤í…œì—ì„œ `PT_GNU_RELRO`ì˜ ë§ˆì§€ë§‰ ë°”ì´íŠ¸ê°€ ì“°ê¸° ê°€ëŠ¥í•œ í˜ì´ì§€ë¥¼ ê³µìœ í•˜ê²Œ ë§Œë“¤ì—ˆê³ ; í˜„ì¬ binutilsëŠ” RELROë¥¼ `max-page-size`ì— ë§ì¶° ì •ë ¬í•˜ì—¬ ê·¸ â€œRELRO gapâ€ì„ ë‹«ì•˜ìŠµë‹ˆë‹¤.

---

## References

* [Why malloc hooks were removed from glibc](https://developers.redhat.com/articles/2021/08/25/securing-malloc-glibc-why-malloc-hooks-had-go)
* [Binutils bug 30612 â€“ RELRO end alignment](https://lists.gnu.org/archive/html/bug-binutils/2023-08/msg00305.html)

{{#include ../../banners/hacktricks-training.md}}
