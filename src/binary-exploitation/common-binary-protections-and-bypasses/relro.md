# Relro

{{#include ../../banners/hacktricks-training.md}}

## Relro

**RELRO** steht f√ºr **Relocation Read-Only** und ist eine Minderung, die vom Linker (`ld`) implementiert wird, der einen Teil der ELF-Datensegmente **nach Anwendung aller Relokationen schreibgesch√ºtzt macht**. Das Ziel ist es, einen Angreifer daran zu hindern, Eintr√§ge in der **GOT (Global Offset Table)** oder anderen relokationsbezogenen Tabellen zu √ºberschreiben, die w√§hrend der Programmausf√ºhrung dereferenziert werden (z. B. `__fini_array`).

Moderne Linker implementieren RELRO, indem sie die **GOT** (und einige andere Abschnitte) **neu anordnen**, sodass sie **vor** der **.bss** leben und ‚Äì am wichtigsten ‚Äì indem sie ein dediziertes `PT_GNU_RELRO`-Segment erstellen, das direkt nach Abschluss der Relokationen durch den dynamischen Loader `R‚ÄìX` umgemappt wird. Folglich k√∂nnen typische Puffer√ºberl√§ufe in der **.bss** die GOT nicht mehr erreichen, und willk√ºrliche Schreibprimitive k√∂nnen nicht verwendet werden, um Funktionszeiger zu √ºberschreiben, die sich innerhalb einer RELRO-gesch√ºtzten Seite befinden.

Es gibt **zwei Ebenen** des Schutzes, die der Linker ausgeben kann:

### Partial RELRO

* Produziert mit dem Flag `-Wl,-z,relro` (oder einfach `-z relro`, wenn `ld` direkt aufgerufen wird).
* Nur der **nicht-PLT** Teil der **GOT** (der Teil, der f√ºr Datenrelokationen verwendet wird) wird in das schreibgesch√ºtzte Segment gelegt. Abschnitte, die zur Laufzeit ge√§ndert werden m√ºssen ‚Äì am wichtigsten **.got.plt**, das **lazy binding** unterst√ºtzt ‚Äì bleiben beschreibbar.
* Aufgrund dessen kann ein **willk√ºrliches Schreiben** immer noch den Ausf√ºhrungsfluss umleiten, indem ein PLT-Eintrag √ºberschrieben wird (oder durch Ausf√ºhren von **ret2dlresolve**).
* Der Leistungsimpact ist vernachl√§ssigbar und daher **versenden fast alle Distributionen seit Jahren Pakete mit mindestens Partial RELRO (es ist der GCC/Binutils-Standard seit 2016)**.

### Full RELRO

* Produziert mit **beiden** Flags `-Wl,-z,relro,-z,now` (auch bekannt als `-z relro -z now`). `-z now` zwingt den dynamischen Loader, **alle** Symbole im Voraus aufzul√∂sen (eager binding), sodass **.got.plt** nie wieder geschrieben werden muss und sicher schreibgesch√ºtzt gemappt werden kann.
* Die gesamte **GOT**, **.got.plt**, **.fini_array**, **.init_array**, **.preinit_array** und einige zus√§tzliche interne glibc-Tabellen landen in einem schreibgesch√ºtzten `PT_GNU_RELRO`-Segment.
* F√ºgt messbare Startkosten hinzu (alle dynamischen Relokationen werden beim Start verarbeitet), aber **keine Laufzeitkosten**.

Seit 2023 haben mehrere g√§ngige Distributionen damit begonnen, die **System-Toolchain** (und die meisten Pakete) standardm√§√üig mit **Full RELRO** zu kompilieren ‚Äì z. B. **Debian 12 ‚Äúbookworm‚Äù (dpkg-buildflags 13.0.0)** und **Fedora 35+**. Als Pentester sollten Sie daher erwarten, auf Bin√§rdateien zu sto√üen, bei denen **jeder GOT-Eintrag schreibgesch√ºtzt ist**.

---

## So √ºberpr√ºfen Sie den RELRO-Status einer Bin√§rdatei
```bash
$ checksec --file ./vuln
[*] '/tmp/vuln'
Arch:     amd64-64-little
RELRO:    Full
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```
`checksec` (Teil von [pwntools](https://github.com/pwncollege/pwntools) und vielen Distributionen) analysiert `ELF`-Header und gibt das Schutzniveau aus. Wenn Sie `checksec` nicht verwenden k√∂nnen, verlassen Sie sich auf `readelf`:
```bash
# Partial RELRO ‚Üí PT_GNU_RELRO is present but BIND_NOW is *absent*
$ readelf -l ./vuln | grep -E "GNU_RELRO|BIND_NOW"
GNU_RELRO      0x0000000000600e20 0x0000000000600e20
```

```bash
# Full RELRO ‚Üí PT_GNU_RELRO *and* the DF_BIND_NOW flag
$ readelf -d ./vuln | grep BIND_NOW
0x0000000000000010 (FLAGS)              FLAGS: BIND_NOW
```
Wenn die Bin√§rdatei l√§uft (z. B. ein set-uid root Helper), k√∂nnen Sie die ausf√ºhrbare Datei weiterhin **√ºber `/proc/$PID/exe`** inspizieren:
```bash
readelf -l /proc/$(pgrep helper)/exe | grep GNU_RELRO
```
---

## Aktivieren von RELRO beim Kompilieren Ihres eigenen Codes
```bash
# GCC example ‚Äì create a PIE with Full RELRO and other common hardenings
$ gcc -fPIE -pie -z relro -z now -Wl,--as-needed -D_FORTIFY_SOURCE=2 main.c -o secure
```
`-z relro -z now` funktioniert sowohl f√ºr **GCC/clang** (nach `-Wl,` √ºbergeben) als auch direkt f√ºr **ld**. Wenn Sie **CMake 3.18+** verwenden, k√∂nnen Sie Full RELRO mit dem integrierten Preset anfordern:
```cmake
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON) # LTO
set(CMAKE_ENABLE_EXPORTS OFF)
set(CMAKE_BUILD_RPATH_USE_ORIGIN ON)
set(CMAKE_EXE_LINKER_FLAGS "-Wl,-z,relro,-z,now")
```
---

## Bypass-Techniken

| RELRO-Stufe | Typische Primitive | M√∂gliche Ausnutzungstechniken |
|-------------|-------------------|----------------------------------|
| Keine / Teilweise | Arbitr√§res Schreiben | 1. √úberschreiben des **.got.plt**-Eintrags und Ausf√ºhrung umschalten.<br>2. **ret2dlresolve** ‚Äì gef√§lschte `Elf64_Rela` & `Elf64_Sym` in einem beschreibbaren Segment erstellen und `_dl_runtime_resolve` aufrufen.<br>3. Funktionszeiger in **.fini_array** / **atexit()**-Liste √ºberschreiben. |
| Voll | GOT ist schreibgesch√ºtzt | 1. Nach **anderen beschreibbaren Codezeigern** suchen (C++ vtables, `__malloc_hook` < glibc 2.34, `__free_hook`, R√ºckrufe in benutzerdefinierten `.data`-Sektionen, JIT-Seiten).<br>2. Missbrauch von *relativen Lese*-Primitiven, um libc auszulesen und **SROP/ROP in libc** durchzuf√ºhren.<br>3. Ein b√∂sartiges Shared Object √ºber **DT_RPATH**/`LD_PRELOAD` injizieren (wenn die Umgebung vom Angreifer kontrolliert wird) oder **`ld_audit`**.<br>4. **Format-String** oder teilweise Zeiger√ºberschreibung ausnutzen, um den Kontrollfluss umzuleiten, ohne die GOT zu ber√ºhren. |

> üí° Selbst mit Voll-RELRO ist die **GOT von geladenen Shared Libraries (z.B. libc selbst)** **nur Teilweise RELRO**, da diese Objekte bereits gemappt sind, wenn der Loader die Relokationen anwendet. Wenn Sie ein **arbitr√§res Schreiben**-Primitive erhalten, das auf die Seiten eines anderen Shared Objects abzielt, k√∂nnen Sie die Ausf√ºhrung weiterhin umschalten, indem Sie die GOT-Eintr√§ge von libc oder den `__rtld_global`-Stack √ºberschreiben, eine Technik, die regelm√§√üig in modernen CTF-Herausforderungen ausgenutzt wird.

### Beispiel f√ºr einen echten Bypass (2024 CTF ‚Äì *pwn.college ‚Äúenlightened‚Äù*)

Die Herausforderung wurde mit Voll-RELRO ausgeliefert. Der Exploit nutzte ein **Off-by-One**, um die Gr√∂√üe eines Heap-Chunks zu korrumpieren, leakte libc mit `tcache poisoning` und √ºberschreibt schlie√ülich `__free_hook` (au√üerhalb des RELRO-Segments) mit einem One-Gadget, um Codeausf√ºhrung zu erhalten. Es war kein GOT-Schreiben erforderlich.

---

## Aktuelle Forschung & Schwachstellen (2022-2025)

* **glibc 2.40 deprecates `__malloc_hook` / `__free_hook` (2025)** ‚Äì Die meisten modernen Heap-Exploits, die diese Symbole ausnutzten, m√ºssen nun auf alternative Vektoren wie **`rtld_global._dl_load_jump`** oder C++-Ausnahmetabellen umschalten. Da Hooks **au√üerhalb** von RELRO leben, erh√∂ht ihre Entfernung die Schwierigkeit von Voll-RELRO-Byp√§ssen.
* **Binutils 2.41 ‚Äúmax-page-size‚Äù Fix (2024)** ‚Äì Ein Fehler erlaubte es, dass die letzten paar Bytes des RELRO-Segments eine Seite mit beschreibbaren Daten auf einigen ARM64-Bauten teilten, was eine kleine **RELRO-L√ºcke** hinterlie√ü, die nach `mprotect` geschrieben werden konnte. Der Upstream richtet jetzt `PT_GNU_RELRO` an Seitengrenzen aus, wodurch diesen Randfall beseitigt wird.

---

## Referenzen

* Binutils-Dokumentation ‚Äì *`-z relro`, `-z now` und `PT_GNU_RELRO`*
* *‚ÄúRELRO ‚Äì Voll, Teilweise und Bypass-Techniken‚Äù* ‚Äì Blogbeitrag @ wolfslittlered 2023

{{#include ../../banners/hacktricks-training.md}}
