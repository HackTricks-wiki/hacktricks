# Ret2ret & Reo2pop

{{#include ../../../banners/hacktricks-training.md}}

## Ret2ret

这个技术的主要**目标**是尝试**通过滥用栈中现有指针来绕过 ASLR**。

基本上，栈溢出通常是由字符串引起的，而**字符串在内存中以一个空字节结尾**。这允许尝试减少由栈中现有指针指向的位置。因此，如果栈包含 `0xbfffffdd`，这个溢出可以将其转换为 `0xbfffff00`（注意最后一个零字节）。

如果该地址指向我们在栈中的 shellcode，可以通过**向 `ret` 指令添加地址**使流程到达该地址，直到到达该地址。

因此，攻击将是这样的：

- NOP sled
- Shellcode
- 从 EIP 覆盖栈，使用**指向 `ret` 的地址**（RET sled）
- 由字符串添加的 0x00 修改栈中的一个地址，使其指向 NOP sled

通过[**这个链接**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/ASLR%20Smack%20and%20Laugh%20reference%20-%20Tilo%20Mueller/ret2ret.c)你可以看到一个易受攻击的二进制文件，和[**这个链接**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/ASLR%20Smack%20and%20Laugh%20reference%20-%20Tilo%20Mueller/ret2retexploit.c)中的利用。

## Ret2pop

如果你能找到一个**完美的指针在栈中而不想修改**（在 `ret2ret` 中我们将最后一个最低字节更改为 `0x00`），你可以执行相同的 `ret2ret` 攻击，但**RET sled 的长度必须缩短 1**（因此最后的 `0x00` 覆盖完美指针之前的数据），并且**RET sled 的最后**地址必须指向**`pop <reg>; ret`**。\
这样，**完美指针之前的数据将从栈中移除**（这是受 `0x00` 影响的数据），并且**最终的 `ret` 将指向栈中的完美地址**而没有任何更改。

通过[**这个链接**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/ASLR%20Smack%20and%20Laugh%20reference%20-%20Tilo%20Mueller/ret2pop.c)你可以看到一个易受攻击的二进制文件，和[**这个链接**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/ASLR%20Smack%20and%20Laugh%20reference%20-%20Tilo%20Mueller/ret2popexploit.c)中的利用。

## References

- [https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md)

{{#include ../../../banners/hacktricks-training.md}}
