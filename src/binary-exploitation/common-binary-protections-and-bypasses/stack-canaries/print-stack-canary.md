# 打印栈金丝雀

{{#include ../../../banners/hacktricks-training.md}}

## 扩大打印的栈

想象一个情况，一个**易受攻击的程序**可以执行一个**puts**函数，**指向****栈溢出**的**一部分**。攻击者知道**金丝雀的第一个字节是一个空字节**（`\x00`），其余的金丝雀是**随机**字节。然后，攻击者可以创建一个溢出，**覆盖栈直到金丝雀的第一个字节**。

然后，攻击者在有效负载的中间**调用puts功能**，这将**打印所有金丝雀**（除了第一个空字节）。

有了这些信息，攻击者可以**制作并发送一个新攻击**，知道金丝雀（在同一程序会话中）。

显然，这种策略是非常**受限**的，因为攻击者需要能够**打印**其**有效负载**的**内容**以**提取**金丝雀，然后能够创建一个新有效负载（在**同一程序会话**中）并**发送****真实的缓冲区溢出**。

**CTF示例：**&#x20;

- [**https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html**](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64位，启用ASLR但没有PIE，第一步是填充溢出直到金丝雀的字节0x00，然后调用puts并泄露它。利用金丝雀创建一个ROP小工具来调用puts以泄露GOT中puts的地址，然后是一个ROP小工具来调用`system('/bin/sh')`
- [**https://guyinatuxedo.github.io/14-ret_2_system/hxp18_poorCanary/index.html**](https://guyinatuxedo.github.io/14-ret_2_system/hxp18_poorCanary/index.html)
- 32位，ARM，无relro，金丝雀，nx，无pie。通过调用puts来溢出以泄露金丝雀 + ret2lib调用`system`，使用ROP链弹出r0（参数`/bin/sh`）和pc（system的地址）

## 任意读取

通过**任意读取**，如格式**字符串**提供的，可能泄露金丝雀。查看这个例子：[**https://ir0nstone.gitbook.io/notes/types/stack/canaries**](https://ir0nstone.gitbook.io/notes/types/stack/canaries)，你可以阅读关于滥用格式字符串以读取任意内存地址的内容：

{{#ref}}
../../format-strings/
{{#endref}}

- [https://guyinatuxedo.github.io/14-ret_2_system/asis17_marymorton/index.html](https://guyinatuxedo.github.io/14-ret_2_system/asis17_marymorton/index.html)
- 这个挑战以非常简单的方式滥用格式字符串从栈中读取金丝雀

{{#include ../../../banners/hacktricks-training.md}}
