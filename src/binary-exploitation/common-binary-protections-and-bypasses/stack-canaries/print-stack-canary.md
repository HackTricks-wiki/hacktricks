# Print Stack Canary

{{#include ../../../banners/hacktricks-training.md}}

## Enlarge printed stack

스택 오버플로우에 취약한 **프로그램**이 **스택 오버플로우**의 **일부**를 가리키는 **puts** 함수를 실행할 수 있는 상황을 상상해 보십시오. 공격자는 **canary의 첫 번째 바이트가 null 바이트**(`\x00`)이고 나머지 canary는 **무작위** 바이트라는 것을 알고 있습니다. 그러면 공격자는 **canary의 첫 번째 바이트**까지 스택을 **덮어쓰는** 오버플로우를 생성할 수 있습니다.

그런 다음 공격자는 페이로드의 중간에서 **puts 기능**을 호출하여 **canary를 모두 출력**합니다(첫 번째 null 바이트 제외).

이 정보를 통해 공격자는 **canary를 알고** 새로운 공격을 **구성하고 전송**할 수 있습니다(같은 프로그램 세션에서).

명백히, 이 전술은 공격자가 자신의 **페이로드**의 **내용**을 **출력**하여 **canary**를 **유출**할 수 있어야 하므로 매우 **제한적**입니다. 그런 다음 **새로운 페이로드**를 생성하고 **실제 버퍼 오버플로우**를 **전송**할 수 있어야 합니다.

**CTF 예시:**

- [**https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html**](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64비트, ASLR 활성화, PIE 없음, 첫 번째 단계는 canary의 바이트 0x00까지 오버플로우를 채운 다음 puts를 호출하여 유출하는 것입니다. canary로 ROP 가젯을 생성하여 puts를 호출하여 GOT에서 puts의 주소를 유출하고 `system('/bin/sh')`를 호출하는 ROP 가젯을 생성합니다.
- [**https://guyinatuxedo.github.io/14-ret_2_system/hxp18_poorCanary/index.html**](https://guyinatuxedo.github.io/14-ret_2_system/hxp18_poorCanary/index.html)
- 32비트, ARM, relro 없음, canary, nx, pie 없음. canary를 유출하기 위해 puts를 호출하는 오버플로우 + ROP 체인을 사용하여 r0(인수 `/bin/sh`)와 pc(시스템 주소)를 팝하는 `system`을 호출합니다.

## Arbitrary Read

**형식 문자열**이 제공하는 **임의 읽기**를 사용하면 canary를 유출할 수 있을 수 있습니다. 이 예제를 확인하십시오: [**https://ir0nstone.gitbook.io/notes/types/stack/canaries**](https://ir0nstone.gitbook.io/notes/types/stack/canaries) 및 다음에서 임의의 메모리 주소를 읽기 위해 형식 문자열을 악용하는 방법에 대해 읽을 수 있습니다:

{{#ref}}
../../format-strings/
{{#endref}}

- [https://guyinatuxedo.github.io/14-ret_2_system/asis17_marymorton/index.html](https://guyinatuxedo.github.io/14-ret_2_system/asis17_marymorton/index.html)
- 이 도전 과제는 형식 문자열을 매우 간단하게 악용하여 스택에서 canary를 읽습니다.

{{#include ../../../banners/hacktricks-training.md}}
