# iMessage Media Parser Zero-Click → CoreAudio RCE → PAC/RPAC → Kernel → CryptoTokenKit Abuse

{{#include ../../banners/hacktricks-training.md}}

Esta página resume una superficie de ataque zero-click moderna en iOS y una cadena de explotación de extremo a extremo observada que abusa del parsing automático de medios de iMessage para comprometer CoreAudio, eludir BlastDoor, derrotar Pointer Authentication (PAC) vía una ruta RPAC, escalar a kernel y, finalmente, abusar de CryptoTokenKit para usos no autorizados de claves.

> Advertencia: Este es un resumen educativo para ayudar a defensores, investigadores y equipos rojos a comprender las técnicas. No usar con fines ofensivos.

## Cadena a alto nivel

- Delivery vector: un adjunto de audio malicioso (p. ej., .amr / MP4 AAC) enviado vía iMessage/SMS.
- Auto-ingestion: iOS parsea automáticamente medios para vistas previas y conversiones sin interacción del usuario.
- Parser bug: estructuras malformadas impactan AudioConverterService de CoreAudio y corrompen memoria heap.
- Code exec in media context: RCE dentro del proceso de parsing de medios; se informó que puede eludir el aislamiento de BlastDoor en rutas específicas (p. ej., el framing de “known sender”).
- PAC/RPAC bypass: una vez logrado acceso R/W arbitrario, un bypass de PAC en la ruta RPAC permite control de flujo estable bajo arm64e PAC.
- Kernel escalation: la cadena convierte la ejecución en userland a ejecución en kernel (p. ej., vía rutas de código wireless/AppleBCMWLAN y manejo de AMPDU como se ve en los logs abajo).
- Post-exploitation: con kernel, se abusa de CryptoTokenKit para firmar con claves respaldadas por Secure Enclave, leer rutas de datos sensibles (contextos de Keychain), interceptar mensajes/2FA, autorizar acciones de forma silenciosa y habilitar vigilancia sigilosa (mic/camera/GPS) sin prompts.

## Notas sobre la superficie de ataque iMessage/BlastDoor

BlastDoor es un servicio endurecido diseñado para parsear contenido de mensajes no confiable. Sin embargo, logs observados indican rutas donde las protecciones pueden ser eludidas cuando los mensajes están enmarcados desde un “known sender” y cuando filtros adicionales (p. ej., Blackhole) se relajan:
```text
IDSDaemon    BlastDoor: Disabled for framing messages
SpamFilter   Blackhole disabled; user has disabled filtering unknown senders.
```
Puntos clave:
- El auto-parsing sigue representando una superficie de ataque remota, zero-click.
- Las decisiones de política/contexto (remitente conocido, estado de filtrado) pueden cambiar de forma significativa el aislamiento efectivo.

## CoreAudio: AudioConverterService heap corruption (userland RCE)

Componente afectado:
- CoreAudio → AudioConverterService → AAC/AMR/MP4 parsing and conversion flows

Punto de contacto observado del parser (registros):
```text
AudioConverterService    ACMP4AACBaseDecoder.cpp: inMagicCookie=0x0, inMagicCookieByteSize=39
```
Resumen de la técnica:
- Metadatos de container/codec malformados (p. ej., invalid/short/NULL magic cookie) causan una corrupción de memoria durante el decode setup.
- Se dispara en la ruta de conversión de medios de iMessage sin que el usuario realice taps.
- Produce ejecución de código en el proceso de media parsing. El informe afirma que esto escapa de BlastDoor en la ruta de entrega observada, habilitando la siguiente etapa.

Consejos prácticos:
- Fuzzear AAC/AMR magic cookie y los MP4 codec atoms cuando se apunte a las conversiones de AudioConverterService.
- Enfóquese en heap overflows/underflows, OOB reads/writes y size/length confusion alrededor de la decoder initialization.

## PAC bypass via RPAC path (CVE-2025-31201)

arm64e Pointer Authentication (PAC) impide el secuestro de return addresses y function pointers. La cadena reporta derrotar PAC usando un RPAC path una vez que arbitrary read/write está disponible.

Idea clave:
- Con arbitrary R/W, los atacantes pueden crear pointers válidos re-signed o pivotar la ejecución hacia paths tolerantes a PAC. El llamado “RPAC path” permite control-flow bajo las restricciones de PAC, convirtiendo un userland RCE en una configuración fiable para un kernel exploit.

Notas para investigadores:
- Recolecte info leaks para derrotar KASLR y estabilizar ROP/JOP chains incluso bajo PAC.
- Apunte a callsites que generen o autentiquen PAC de maneras controlables (p. ej., signatures generadas sobre valores controlados por el atacante, predictable context keys, o secuencias de gadgets que re-sign pointers).
- Espere variación en el hardening de Apple según SoC/OS; la fiabilidad depende de leaks, entropy y primitives robustas.

## Kernel escalation: wireless/AMPDU path example

En la cadena observada, una vez en userland con corrupción de memoria y un primitive de PAC bypass, se consiguió control del kernel vía rutas de código en la Wi‑Fi stack (AppleBCMWLAN) bajo malformed AMPDU handling. Registros de ejemplo:
```text
IO80211ControllerMonitor::setAMPDUstat unhandled kAMPDUStat_ type 14
IO80211ControllerMonitor::setAMPDUstat unhandled kAMPDUStat_ type 13
```
Técnica general:
- Usar userland primitives para construir kernel R/W o controlled call paths.
- Abusar de reachable kernel surfaces (IOKit, networking/AMPDU, media shared memory, Mach interfaces) para lograr kernel PC control o arbitrary memory.
- Estabilizar construyendo read/write primitives y derrotando las restricciones PPL/SPTM cuando corresponda.

## Post-explotación: CryptoTokenKit y abuso de identity/signing

Una vez comprometido el kernel, procesos como identityservicesd pueden ser suplantados y operaciones criptográficas privilegiadas invocadas vía CryptoTokenKit sin avisos al usuario. Ejemplo de logs:
```text
CryptoTokenKit    operation:2 algo:algid:sign:ECDSA:digest-X962:SHA256
CryptoTokenKit    <sepk:p256(d) kid=9a86778f7163e305> parsed for identityservicesd
```
Impacto:
- Usar claves respaldadas por Secure Enclave para firmas no autorizadas (tokens, mensajes, pagos), rompiendo modelos de confianza incluso si las claves no se exportan.
- Interceptar códigos/mensajes 2FA silenciosamente; autorizar pagos/transferencias; activar micrófono/cámara/GPS de forma sigilosa.

Enfoque defensivo:
- Tratar las rupturas de integridad post-kernel como catastróficas: aplicar runtime attestation para consumidores de CTK; minimizar la autoridad ambiental; verificar los entitlements en el punto de uso.

## Reproducción y pistas de telemetría (solo laboratorio)

- Delivery: enviar un audio AMR/MP4-AAC manipulado al dispositivo objetivo vía iMessage/SMS.
- Observar la telemetría por las líneas de log mencionadas alrededor del parsing y las reacciones de la pila inalámbrica.
- Asegurarse de que los dispositivos estén completamente parchados; probar solo en entornos de laboratorio aislados.

## Mitigaciones e ideas de hardening

- Patch level: iOS 18.4.1 reportedly fixes this chain; mantener los dispositivos actualizados.
- Parser hardening: validación estricta para codec cookies/atoms y longitudes; rutas de decodificación defensiva con bounds checks.
- iMessage isolation: evitar relajar BlastDoor/Blackhole en “known sender” contexts para el parsing de medios.
- PAC hardening: reducir la disponibilidad de PAC-gadgets; asegurar que las firmas estén ligadas a contextos impredecibles; eliminar patrones PAC-tolerant bypassable.
- CryptoTokenKit: requerir post-kernel attestation y entitlements fuertes en tiempo de llamada para operaciones ligadas a claves.
- Kernel surfaces: harden el manejo de wireless AMPDU/status; minimizar entradas controladas por el atacante desde userland tras la compromisión.

## Versiones afectadas (según reportes)

- iOS 18.x anteriores a iOS 18.4.1 (16 de abril de 2025).
- Primary: CoreAudio → AudioConverterService (media auto-parsing path via iMessage/SMS).
- Chained: PAC/RPAC path and kernel escalation via AppleBCMWLAN AMPDU handling.

## Referencias

- [Repositorio iOS Crypto Heist (README)](https://github.com/JGoyd/iOS-Attack-Chain-CVE-2025-31200-CVE-2025-31201)
- [Detalles de Remote Crypto Attack Chain](https://github.com/JGoyd/iOS-Attack-Chain-CVE-2025-31200-CVE-2025-31201/blob/main/Remote%20Crypto%20Attack%20Chain%20.md)

{{#include ../../banners/hacktricks-training.md}}
