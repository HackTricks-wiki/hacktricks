# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

- **Code Signing** in iOS works by requiring every piece of executable code (apps, libraries, extensions, etc.) to be cryptographically signed with a certificate issued by Apple. When code is loaded, iOS verifies the digital signature against Apple’s trusted root. If the signature is invalid, missing, or modified, the OS refuses to run it. This prevents attackers from injecting malicious code into legitimate apps or running unsigned binaries, effectively stopping most exploit chains that rely on executing arbitrary or tampered code.
- **CoreTrust** is the iOS subsystem responsible for enforcing code signing at runtime. It directly verifies signatures using Apple’s root certificate without relying on cached trust stores, meaning only binaries signed by Apple (or with valid entitlements) can execute. CoreTrust ensures that even if an attacker tampers with an app after installation, modifies system libraries, or tries to load unsigned code, the system will block execution unless the code is still properly signed. This strict enforcement closes many post-exploitation vectors that older iOS versions allowed through weaker or bypassable signature checks.
- **Data Execution Prevention (DEP)** marks memory regions as non-executable unless they explicitly contain code. This stops attackers from injecting shellcode into data regions (like the stack or heap) and running it, forcing them to rely on more complex techniques like ROP (Return-Oriented Programming).
- **ASLR (Address Space Layout Randomization)** randomizes the memory addresses of code, libraries, stack, and heap every time the system runs. This makes it much harder for attackers to predict where useful instructions or gadgets are, breaking many exploit chains that depend on fixed memory layouts.
- **KASLR (Kernel ASLR)** applies the same randomization concept to the iOS kernel. By shuffling the kernel’s base address at each boot, it prevents attackers from reliably locating kernel functions or structures, raising the difficulty of kernel-level exploits that would otherwise gain full system control.
- **Kernel Patch Protection (KPP)** also known as **AMCC (Apple Mobile File Integrity)** in iOS, continuously monitors the kernel’s code pages to ensure they haven’t been modified. If any tampering is detected—such as an exploit trying to patch kernel functions or insert malicious code—the device will immediately panic and reboot. This protection makes persistent kernel exploits far harder, as attackers can’t simply hook or patch kernel instructions without triggering a system crash.
- **Kernel Text Readonly Region (KTRR)** is a hardware-based security feature introduced on iOS devices. It uses the CPU’s memory controller to mark the kernel’s code (text) section as permanently read-only after boot. Once locked, even the kernel itself cannot modify this memory region. This prevents attackers—and even privileged code—from patching kernel instructions at runtime, closing off a major class of exploits that relied on modifying kernel code directly.
- **Pointer Authentication Codes (PAC)** use cryptographic signatures embedded into unused bits of pointers to verify their integrity before use. When a pointer (like a return address or function pointer) is created, the CPU signs it with a secret key; before dereferencing, the CPU checks the signature. If the pointer was tampered with, the check fails and execution stops. This prevents attackers from forging or reusing corrupted pointers in memory corruption exploits, making techniques like ROP or JOP much harder to pull off reliably.
- **Privilege Access never (PAN)** is a hardware feature that prevents the kernel (privileged mode) from directly accessing user-space memory unless it explicitly enables access. This stops attackers who gained kernel code execution from easily reading or writing user memory to escalate exploits or steal sensitive data. By enforcing strict separation, PAN reduces the impact of kernel exploits and blocks many common privilege-escalation techniques.
- **Page Protection Layer (PPL)** is an iOS security mechanism that protects critical kernel-managed memory regions, especially those related to code signing and entitlements. It enforces strict write protections using the MMU (Memory Management Unit) and additional checks, ensuring that even privileged kernel code cannot arbitrarily modify sensitive pages. This prevents attackers who gain kernel-level execution from tampering with security-critical structures, making persistence and code-signing bypasses significantly harder.

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

The kernel used a **zone allocator** (`kalloc`) divided into fixed-size "zones."
Each zone only stores allocations of a single size class.

From the screenshot:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Very small kernel structs, pointers.                                        |
| `default.kalloc.32`  | 32 bytes     | Small structs, object headers.                                              |
| `default.kalloc.64`  | 64 bytes     | IPC messages, tiny kernel buffers.                                          |
| `default.kalloc.128` | 128 bytes    | Medium objects like parts of `OSObject`.                                    |
| `default.kalloc.256` | 256 bytes    | Larger IPC messages, arrays, device structures.                             |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Large structures, IOSurface/graphics metadata.                              |

**How it worked:**
- Each allocation request gets **rounded up** to the nearest zone size.
(E.g., a 50-byte request lands in the `kalloc.64` zone).
- Memory in each zone was kept in a **free list** — chunks freed by the kernel went back into that zone.
- If you overflowed a 64-byte buffer, you’d overwrite the **next object in the same zone**.

This is why **heap spraying / feng shui** was so effective: you could predict object neighbors by spraying allocations of the same size class.

### The freelist

Inside each kalloc zone, freed objects weren’t returned directly to the system — they went into a freelist, a linked list of available chunks.

- When a chunk was freed, the kernel wrote a pointer at the start of that chunk → the address of the next free chunk in the same zone.

- The zone kept a HEAD pointer to the first free chunk.

- Allocation always used the current HEAD:

1. Pop HEAD (return that memory to the caller).

2. Update HEAD = HEAD->next (stored in the freed chunk’s header).

- Freeing pushed chunks back:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

So the freelist was just a linked list built inside the freed memory itself.

Normal state:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Exploiting the freelist

Çünkü bir free chunk'ın ilk 8 baytı = freelist pointer olduğundan, bir saldırgan bunu bozabilir:

1. **Heap overflow** ile bitişik freed chunk'a taşma → onun “next” pointer'ını üzerine yazma.

2. **Use-after-free** ile freed object içine yazma → onun “next” pointer'ını üzerine yazma.

Then, on the next allocation of that size:

- Allocator bozuk chunk'ı poplar.

- Saldırgan tarafından sağlanan “next” pointer'ı takip eder.

- Rastgele belleğe bir pointer döndürür, fake object primitives veya hedefli overwrite'e izin verir.

Visual example of freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
This freelist tasarımı, hardening öncesinde exploitleri çok etkili hale getiriyordu: heap sprays'ten gelen tahmin edilebilir komşular, raw pointer freelist bağlantıları ve tür ayrımının olmaması, saldırganların UAF/overflow hatalarını rastgele kernel belleği kontrolüne yükseltmesine izin veriyordu.

### Heap Grooming / Feng Shui
The goal of heap grooming is to **heap yerleşimini şekillendirmek** so that when an attacker triggers an overflow or use-after-free, the target (victim) object sits right next to an attacker-controlled object.\
Böylece bellek bozulması gerçekleştiğinde, saldırgan kurban objeyi kontrollü verilerle güvenilir şekilde ezebilir.

**Adımlar:**

1. Spray allocations (fill the holes)
- Zamanla kernel heap fragmentasyona uğrar: bazı zonlarda eski nesnelerin free edildiği boşluklar oluşur.
- Saldırgan ilk olarak bu boşlukları doldurmak için çok sayıda dummy allocation yapar, böylece heap “packed” ve daha öngörülebilir hale gelir.

2. Force new pages
- Boşluklar doldurulduktan sonra, bir sonraki allocation zone'a eklenen yeni sayfalardan gelmek zorunda kalır.
- Yeni sayfalar, nesnelerin eski parçalanmış bellek boyunca dağılmayıp bir arada kümeleşmesini sağlar.
- Bu, saldırganın komşular üzerinde çok daha iyi kontrol elde etmesini sağlar.

3. Place attacker objects
- Saldırgan şimdi tekrar spray yapar ve bu yeni sayfalarda çok sayıda attacker-controlled obje oluşturur.
- Bu objeler boyut ve yerleşim açısından öngörülebilirdir (çünkü hepsi aynı zone'a aittir).

4. Free a controlled object (make a gap)
- Saldırgan kasten kendi objelerinden birini free eder.
- Bu, allocator'ın daha sonra aynı boyuttaki bir sonraki allocation için yeniden kullanacağı heap'te bir “delik” oluşturur.

5. Victim object lands in the hole
- Saldırgan, kernel'in hedef (victim) objeyi allocate etmesini tetikler.
- Delik freelist'teki ilk uygun slot olduğundan, victim tam olarak saldırganın free ettiği yerde konumlanır.

6. Overflow / UAF into victim
- Artık saldırganın kontrollü objeleri victim çevresindedir.
- Kendi objelerinden birinden overflow yaparak (veya freed objeyi tekrar kullanarak) victim’in bellek alanlarını seçilen değerlerle güvenilir şekilde overwrite edebilir.

**Neden çalışır**:

- Zone allocator predictability: aynı boyuttaki allocationlar her zaman aynı zon'dan gelir.
- Freelist behavior: yeni allocationlar en son free edilmiş chunk'ı önce yeniden kullanır.
- Heap sprays: saldırgan bellek içeriklerini öngörülebilir şekilde doldurur ve yerleşimi kontrol eder.
- Sonuç: saldırgan victim objenin nereye yerleşeceğini ve yanında hangi verilerin olacağını kontrol eder.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple allocator'ı sertleştirdi ve **heap grooming'i çok daha zorlaştırdı**:

### 1. From Classic kalloc to kalloc_type
- **Before**: her boyut sınıfı için (16, 32, 64, … 1280, vb.) tek bir `kalloc.<size>` zone vardı. O boyuttaki herhangi bir obje oraya yerleştirilirdi → saldırgan objeleri ayrıcalıklı kernel objelerinin yanına yerleşebilirdi.
- **Now**:
- Kernel objeleri **typed zones** (`kalloc_type`) üzerinden allocate ediliyor.
- Her obje tipi (ör. `ipc_port_t`, `task_t`, `OSString`, `OSData`) kendi adanmış zone'una sahip; aynı boyutta olsalar bile ayrılıyorlar.
- Obje tipi ↔ zone eşlemesi derleme zamanında **kalloc_type system** tarafından üretilir.

Artık saldırgan kontrollü verinin (`OSData`) aynı boyuttaki hassas kernel objelerinin (`task_t`) yanında olacağını garanti edemez.

### 2. Slabs and Per-CPU Caches
- Heap, her zone için sabit boyutlu chunk'lara ayrılmış bellek sayfaları olan **slab**'lara bölünmüştür.
- Her zone'un contenstion'u azaltmak için bir **per-CPU cache**'i vardır.
- Allocation yolu:
1. Per-CPU cache denenir.
2. Boşsa, global freelist'ten çekilir.
3. Freelist boşsa, yeni bir slab (bir veya daha fazla sayfa) allocate edilir.
- **Fayda**: Bu desantralizasyon, allocationların farklı CPU cache'lerinden karşılanabilmesi nedeniyle heap sprays'i daha az deterministik yapar.

### 3. Randomization inside zones
- Bir zone içinde, free edilmiş elemanlar basit FIFO/LIFO sırasıyla geri verilmez.
- Modern XNU **encoded freelist pointers** (Linux tarzı safe-linking gibi, ~iOS 14'te tanıtıldı) kullanır.
- Her freelist pointer, bir zone-a özgü gizli cookie ile **XOR-encoded** edilir.
- Bu, bir write primitive elde edilse bile saldırganların sahte bir freelist pointer üretmesini engeller.
- Bazı allocationlar slab içinde **yerleştirme açısından randomize edilir**, bu yüzden spraying komşuluk garanti etmez.

### 4. Guarded Allocations
- Bazı kritik kernel objeleri (ör. credentials, task yapıları) **guarded zones** içinde allocate edilir.
- Bu zonlar slab'lar arasında **guard pages** (unmapped memory) ekler veya objelerin etrafında **redzones** kullanır.
- Guard page'e yapılan herhangi bir overflow fault tetikler → sessiz corruption yerine anında panic oluşur.

### 5. Page Protection Layer (PPL) and SPTM
- Freed bir objeyi kontrol ediyor olsanız bile tüm kernel belleğini değiştiremezsiniz:
- **PPL (Page Protection Layer)**, belirli bölgelerin (ör. code signing verileri, entitlements) kernel'in kendisi için bile **sadece okunur** olmasını zorunlu kılar.
- **A15/M2+** cihazlarda bu rol **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)** ile yerini alır veya güçlendirilir.
- Bu donanım tarafından zorlanan katmanlar, saldırganların tek bir heap bozulmasından kritik güvenlik yapılarında keyfi patch yapmasına engel olur.

### 6. Large Allocations
- Her allocation `kalloc_type` üzerinden gitmez.
- Çok büyük istekler (~16KB üzeri) typed zone'lardan atlanır ve doğrudan **kernel VM (kmem)** üzerinden page allocation ile servis edilir.
- Bunlar daha az öngörülebilir, ancak slab paylaşmadıkları için aynı zamanda daha az exploitable olurlar.

### 7. Allocation Patterns Attackers Target
Bunlara rağmen saldırganlar hâlâ şunları hedefler:
- **Reference count objects**: retain/release sayacıyla oynayabilirseniz use-after-free oluşmasına sebep olabilirsiniz.
- **Objects with function pointers (vtables)**: bunları bozmak yine kontrol akışı sağlar.
- **Shared memory objects (IOSurface, Mach ports)**: user ↔ kernel köprüsü oluşturdukları için hâlâ hedeflenirler.

Ama — eskisi gibi — sadece `OSData` spray yapıp bir `task_t` ile komşu olmasını bekleyemezsiniz. Başarılı olmak için **type-specific bugs** veya **info leaks** gerekir.

### Example: Allocation Flow in Modern Heap

Varsayalım userspace IOKit üzerinden bir `OSData` objesi allocate ediyor:

1. **Type lookup** → `OSData` `kalloc_type_osdata` zone'una (boyut 64 byte) eşlenir.
2. Per-CPU cache'de boş eleman kontrol edilir.
- Bulunursa → bir tane return edilir.
- Boşsa → global freelist'e bakılır.
- Freelist boşsa → yeni bir slab allocate edilir (4KB page → 64 adet 64 byte chunk).
3. Chunk caller'a return edilir.

**Freelist pointer protection**:
- Her free edilmiş chunk, bir sonraki free chunk'ın adresini saklar, fakat bu adres gizli bir anahtarla encoded edilmiştir.
- Bu alanı saldırgan verisiyle overwrite etmek, anahtarı bilmeden işe yaramaz.

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages   |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

BinDiff DMG'yi [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) adresinden indirip kurun.

Ghidra'yı `ghidraRun` ile açın ve `File` --> `Install Extensions`'a gidin, add düğmesine basın ve yolu `/Applications/BinDiff/Extra/Ghidra/BinExport` olarak seçin, ardından OK tuşuna basın ve versiyon uyuşmazlığı olsa bile install edin.

### Using BinDiff with Kernel versions

1. [https://ipsw.me/](https://ipsw.me/) sayfasına gidip diff'lemek istediğiniz iOS sürümlerini indirin. Bunlar `.ipsw` dosyaları olacaktır.
2. Her iki `.ipsw` dosyasının kernelcache'inin bin formatını elde edene kadar dekompresyon yapın. Bunu nasıl yapacağınıza dair bilgi için:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. `ghidraRun` ile Ghidra'yı açın, yeni bir proje oluşturun ve kernelcache'leri yükleyin.
4. Her kernelcache'i açın ki Ghidra otomatik analiz yapsın.
5. Ardından Project Window'da her kernelcache üzerine sağ tıklayın, `Export` seçin, format olarak `Binary BinExport (v2) for BinDiff` seçin ve export edin.
6. BinDiff'i açın, yeni bir workspace oluşturun ve primary file olarak vulnerability içeren kernelcache'i, secondary file olarak patched kernelcache'i göstererek yeni bir diff ekleyin.

---

## Finding the right XNU version

Belirli bir iOS sürümündeki zafiyetleri kontrol etmek istiyorsanız, o iOS sürümünün hangi XNU release versiyonunu kullandığını şu adresten kontrol edebilirsiniz: [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

Örneğin, `15.1 RC`, `15.1` ve `15.1.1` sürümleri `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006` versiyonunu kullanır.

{{#include ../../banners/hacktricks-training.md}}
