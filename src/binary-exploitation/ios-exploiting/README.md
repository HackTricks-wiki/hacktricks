# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

### 1. **Code Signing** / Runtime Signature Verification
**Introduced early (iPhone OS → iOS)**
Bu, temel korumalardan biridir: **tüm yürütülebilir kod** (apps, dynamic libraries, JIT-ed code, extensions, frameworks, caches) Apple’ın güven köküne dayanan bir sertifika zinciriyle kriptografik olarak imzalanmalıdır. Çalışma zamanında, bir ikiliyi belleğe yüklemeden (veya bazı sınırlar arasında atlama yapmadan) önce sistem imzayı kontrol eder. Kod değiştirilmişse (bit-flip, patch) veya imzasızsa, yükleme başarısız olur.

- **Engeller**: exploit zincirlerindeki “klasik payload drop + execute” aşamasını; keyfi kod enjeksiyonunu; mevcut bir ikiliyi kötü amaçlı mantık eklemek için değiştirmeyi.
- **Mekanizma ayrıntısı**:
* Mach-O loader (ve dynamic linker) kod sayfalarını, segmentleri, entitlements, team ID’lerini ve imzanın dosya içeriğini kapsayıp kapsamadığını kontrol eder.
* JIT cache’leri veya dinamik üretilen kod gibi bellek bölgeleri için, Apple sayfaların imzalanmasını veya özel API'lar (ör. `mprotect` ile code-sign kontrolleri) aracılığıyla doğrulanmasını zorunlu kılar.
* İmza, entitlements ve tanımlayıcıları içerir; OS belirli API’lerin veya ayrıcalıklı yeteneklerin belirli entitlements gerektirdiğini ve bunların taklit edilemeyeceğini uygular.

<details>
<summary>Örnek</summary>
Bir exploit bir process içinde kod yürütmesi elde edip shellcode’u heap’e yazıp oraya atlamayı denediğini varsayalım. iOS’ta o sayfanın executable olarak işaretlenmesi ve code-signature kısıtlamalarını karşılaması gerekir. Shellcode Apple’ın sertifikasıyla imzalanmadığı için atlama başarısız olur veya sistem o bellek bölgesini executable hale getirmeyi reddeder.
</details>


### 2. **CoreTrust**
**Introduced around iOS 14+ era (or gradually in newer devices / later iOS)**
CoreTrust, ikilileri çalışma zamanında **Apple’ın root certificate**’ına karşı doğrulayan (userland trust cache’e güvenmeyen) bir alt sistemdir.

- **Engeller**: ikililerin kurulum sonrası tahrifatı, sistem kütüphanelerini veya user apps’i swap/patch ederek kalıcılık kazanmaya çalışan jailbreaking teknikleri; güvenilen ikililerin kötü amaçlı muadilleriyle değiştirilerek sistemi kandırma.
- **Mekanizma ayrıntısı**:
* Yerel bir trust veritabanına veya sertifika önbelleğine güvenmek yerine, CoreTrust doğrudan Apple’ın root'una başvurur veya güvenli bir zincirde ara sertifikaları doğrular.
* Mevcut ikililerde yapılan değişikliklerin (ör. filesystem üzerindeki) tespit edilmesini ve reddedilmesini sağlar.
* İmza sırasında entitlements, team ID’leri, code signing bayrakları ve diğer meta verileri ikiliye bağlar.

<details>
<summary>Örnek</summary>
Bir jailbreak, `SpringBoard` veya `libsystem`’i yamalanmış bir sürümle değiştirmeye çalışabilir. Ancak OS loader veya CoreTrust kontrol ettiğinde imza uyuşmazlığını (veya değiştirilmiş entitlements’ı) fark eder ve yürütmeyi reddeder.
</details>


### 3. **Data Execution Prevention (DEP / NX / W^X)**
**Introduced in many OSes earlier; iOS had NX-bit / w^x for a long time**
DEP, yazılabilir (data) olarak işaretlenmiş sayfaların **executable olmamasını**, executable olarak işaretlenmiş sayfaların ise **yazılabilir olmamasını** zorunlu kılar. Yani heap veya stack bölgesine shellcode yazıp onu doğrudan çalıştıramazsınız.

- **Engeller**: doğrudan shellcode yürütme; klasik buffer-overflow → injected shellcode’a atlama.
- **Mekanizma ayrıntısı**:
* MMU / bellek koruma bitleri (sayfa tabloları aracılığıyla) ayrımı uygular.
* Bir writable sayfayı executable olarak işaretleme girişimi sistem kontrolünü tetikler (ve ya yasaklanır ya da code-sign onayı gerektirir).
* Birçok durumda sayfaları executable yapmak OS API’ları üzerinden yapılmalı ve ek kısıtlamalar/denetimler uygulanır.

<details>
<summary>Örnek</summary>
Bir overflow shellcode’u heap’e yazar. Saldırgan `mprotect(heap_addr, size, PROT_EXEC)` ile onu executable yapmayı dener. Ancak sistem reddeder veya yeni sayfanın code-sign kısıtlarını geçmesini doğrular (ki shellcode geçemez).
</details>

### 4. **Address Space Layout Randomization (ASLR)**
**Introduced in iOS ~4–5 era (roughly iOS 4–5 timeframe)**
ASLR, kütüphaneler, heap, stack gibi ana bellek bölgelerinin taban adreslerini her process başlatıldığında rastgeleleştirir. Gadget adresleri çalıştırmalar arasında değişir.

- **Engeller**: ROP/JOP için sabit gadget adresleri; statik exploit zincirleri; bilinen offset’lere kör atlamalar.
- **Mekanizma ayrıntısı**:
* Her yüklenen kütüphane / dynamic module rastgele bir offset’te rebase edilir.
* Stack ve heap taban pointer’ları (belirli entropi limitleri içinde) rastgeleleştirilir.
* Bazen diğer bölgeler (ör. mmap alımları) de rastgeleleştirilir.
* Bilgi-leak mitigasyonları ile birleştiğinde, saldırganın önce bir adres veya pointer leak etmesi zorunlu hale gelir.

<details>
<summary>Örnek</summary>
Bir ROP zinciri `0x….lib + offset`’teki gadget’a ihtiyaç duyar. Ancak `lib` her çalıştırmada farklı yere taşındığı için hardcoded zincir başarısız olur. Bir exploit önce modülün base adresini leak etmelidir ki gadget adresleri hesaplanabilsin.
</details>


### 5. **Kernel Address Space Layout Randomization (KASLR)**
**Introduced in iOS ~ (iOS 5 / iOS 6 timeframe)**
Kullanıcı ASLR’sine benzer şekilde, KASLR her boot’ta **kernel text** ve diğer kernel yapıların tabanını rastgeleleştirir.

- **Engeller**: kernel seviye exploitler ki sabit kernel kodu veya veri lokasyonlarına güveniyor; statik kernel exploitleri.
- **Mekanizma ayrıntısı**:
* Her boot’ta kernel’in base adresi bir aralık içinde rastgeleleştirilir.
* `task_structs`, `vm_map` gibi kernel veri yapıları da taşınmış veya offset’lenmiş olabilir.
* Saldırganlar, kernel pointer’larını leak etmek veya bilgi disclosure zafiyetleri kullanmak zorundadırlar ki offset’leri hesaplayabilsinler.

<details>
<summary>Örnek</summary>
Bir yerel zafiyet, bir kernel fonksiyon pointer’ını (ör. `vtable` içindeki) `KERN_BASE + offset`’te bozmaya çalışır. Ancak `KERN_BASE` bilinmediği için saldırgan önce bir leak (ör. read primitive) ile onu açığa çıkarmalıdır.
</details>


### 6. **Kernel Patch Protection (KPP / AMCC)**
**Introduced in newer iOS / A-series hardware (post around iOS 15–16 era or newer chips)**
KPP (aka AMCC) kernel text sayfalarının bütünlüğünü (hash veya checksum ile) sürekli izler. Eğer izinsiz bir patch, inline hook veya kod değişikliği tespit edilirse kernel panic veya reboot tetikler.

- **Engeller**: kalıcı kernel patch’leri (kernel instrüksiyonlarını değiştirme), inline hook’lar, statik fonksiyon overwrite’ları.
- **Mekanizma ayrıntısı**:
* Donanım veya firmware modülü kernel text bölgesini izler.
* Periyodik veya istem üzerine sayfaların hash’ini yeniden alır ve beklenenlerle karşılaştırır.
* Eşleşmezlik zararsız güncelleme pencereleri dışında ise cihazı panic’e sokar (kalıcı kötü amaçlı yama riskini önlemek için).
* Saldırganlar ya tespit pencerelerini atlatmalı ya da meşru patch yollarını kullanmalıdır.

<details>
<summary>Örnek</summary>
Bir exploit, `memcmp` gibi bir kernel fonksiyonunun prologunu patch ederek çağrıları yakalamaya çalışır. Ancak KPP kod sayfasının hash’inin beklenenle uyuşmadığını fark eder ve kernel panic tetikler; böylece patch stabil hale gelmeden cihaz çökertilir.
</details>


### 7. **Kernel Text Read‐Only Region (KTRR)**
**Introduced in modern SoCs (post ~A12 / newer hardware)**
KTRR, donanım tarafından uygulanan bir mekanizmadır: kernel text önyükleme sırasında kilitlendikten sonra EL1 (kernel) tarafından yazılabilirliği engellenir.

- **Engeller**: boot sonrası kernel kodunda yapılacak herhangi bir değişiklik (ör. patching, in-place code injection) EL1 ayrıcalık seviyesinde.
- **Mekanizma ayrıntısı**:
* Boot sırasında (secure/bootloader aşamasında) memory controller veya bir güvenli donanım birimi kernel text içeren fiziksel sayfaları read-only olarak işaretler.
* Bir exploit tam kernel ayrıcalığı elde etse bile, bu sayfalara yazamaz.
* Onları değiştirmek için saldırgan önce boot zincirini ele geçirmeli veya KTRR’yi atlatmalıdır.

<details>
<summary>Örnek</summary>
Bir ayrıcalık yükseltme exploit’i EL1’e atlayıp kernel fonksiyonuna trampoline yazmaya çalışır (ör. syscall handler). Ancak sayfalar KTRR tarafından read-only olarak kilitlendiği için yazma başarısız olur veya fault tetiklenir; böylece patch uygulanamaz.
</details>


### 8. **Pointer Authentication Codes (PAC)**
**Introduced with ARMv8.3 (hardware), Apple beginning with A12 / iOS ~12+**
- PAC, ARMv8.3-A ile gelen bir donanım özelliğidir; pointer değerlerinin (return adresleri, function pointer’lar, belirli data pointer’lar) manipülasyonunu tespit etmek için pointer’ın kullanılmayan üst bitlerine küçük bir kriptografik imza (“MAC”) gömer.
- İmza (“PAC”), pointer değeri ile bir **modifier** (bağlam değeri, ör. stack pointer veya ayırt edici veri) üzerinden hesaplanır. Böylece aynı pointer değeri farklı bağlamlarda farklı PAC üretir.
- Kullanım zamanında, pointer dereference edilmeden veya ona branch yapılmadan önce bir **authenticate** talimatı PAC’i denetler. Geçerliyse PAC çıkarılır ve saf pointer elde edilir; geçersizse pointer “poisoned” olur (veya fault yükselir).
- PAC üretimi/doğrulaması için kullanılan anahtarlar ayrıcalıklı register’larda (EL1, kernel) yaşar ve user mode’dan doğrudan okunamaz.
- Birçok sistemde 64 bit pointer’ların tüm bitleri kullanılmadığı için (ör. 48-bit adres uzayı), üst bitler PAC tutmak için “boş” olarak kullanılır.

#### Architectural Basis & Key Types

- ARMv8.3 beş adet 128-bit anahtar (her biri iki 64-bit sistem register’ı ile uygulanmış) tanıtır.
- **APIAKey** — instruction pointer’lar için (domain “I”, key A)
- **APIBKey** — ikinci instruction pointer anahtarı (domain “I”, key B)
- **APDAKey** — data pointer’lar için (domain “D”, key A)
- **APDBKey** — data pointer’lar için (domain “D”, key B)
- **APGAKey** — “generic” anahtar, pointer olmayan veri veya diğer genel kullanımlar için

- Bu anahtarlar ayrıcalıklı sistem register’larında saklanır (sadece EL1/EL2 vb. erişebilir), user mode erişimine kapalıdır.
- PAC, ARM’ın önerdiği QARMA benzeri bir kriptografik fonksiyon kullanılarak hesaplanır ve girdileri:
1. Pointer değeri (canonical portion)
2. Bir **modifier** (bağlam değeri, ör. bir salt)
3. Gizli anahtar
4. İçsel tweak mantığı
Elde edilen PAC pointer’ın üst bitlerine yazılıysa doğrulama başarılı olur.

#### Instruction Families

İsimlendirme: **PAC** / **AUT** / **XPAC**, sonra domain harfleri.
- `PACxx` talimatları bir pointer’ı **imzalar** ve PAC ekler
- `AUTxx` talimatları **doğrular + çıkarır** (PAC’i doğrula ve kaldır)
- `XPACxx` talimatları **doğrulamadan çıkarır**

Domain / suffixler:

| Mnemonic     | Meaning / Domain                      | Key / Domain     | Example Usage in Assembly |
|--------------|-----------------------------------------|--------------------|-----------------------------|
| **PACIA**    | Sign instruction pointer with APIAKey   | “I, A”             | `PACIA X0, X1` — sign pointer in X0 using APIAKey with modifier X1|
| **PACIB**    | Sign instruction pointer with APIBKey   | “I, B”             | `PACIB X2, X3`              |
| **PACDA**    | Sign data pointer with APDAKey           | “D, A”             | `PACDA X4, X5`              |
| **PACDB**    | Sign data pointer with APDBKey           | “D, B”             | `PACDB X6, X7`              |
| **PACG / PACGA** | Generic (non-pointer) signing with APGAKey | “G”         | `PACGA X8, X9, X10` (sign X9 with modifier X10 into X8) |
| **AUTIA**    | Authenticate APIA-signed instruction pointer & strip PAC | “I, A” | `AUTIA X0, X1` — check PAC on X0 using modifier X1, then strip |
| **AUTIB**    | Authenticate APIB domain                 | “I, B”             | `AUTIB X2, X3`               |
| **AUTDA**    | Authenticate APDA-signed data pointer    | “D, A”             | `AUTDA X4, X5`               |
| **AUTDB**    | Authenticate APDB-signed data pointer    | “D, B”             | `AUTDB X6, X7`               |
| **AUTGA**    | Authenticate generic / blob (APGA)        | “G”               | `AUTGA X8, X9, X10` (validate generic) |
| **XPACI**     | Strip PAC (instruction pointer, no validation) | “I”         | `XPACI X0` — remove PAC from X0 (instruction domain) |
| **XPACD**     | Strip PAC (data pointer, no validation)    | “D”             | `XPACD X4` — remove PAC from data pointer in X4 |


Bazı özel/alias formları:

- `PACIASP` `PACIA X30, SP` kısaltmasıdır (link register’ı SP ile modifier kullanarak imzala)
- `AUTIASP` `AUTIA X30, SP`’dir (link register’ı SP ile doğrula)
- `RETAA`, `RETAB` (authenticate-and-return) veya `BLRAA` (authenticate & branch) gibi birleşik formlar ARM uzantılarında / derleyici desteğinde bulunur.
- Ayrıca modifier sıfır olan formlar: `PACIZA` / `PACIZB` gibi, modifier implicit olarak zero’dır.

#### Modifiers

Modifier’ın temel amacı PAC’i belirli bir bağlama bağlamaktır; böylece aynı adres farklı bağlamlarda imzalandığında farklı PAC’ler üretir. Bu, pointer’ın basitçe yeniden kullanılmasını engeller — bir hash’e salt eklemek gibidir.

Buna göre:
- **modifier** bir bağlam değeri (başka bir register) olup PAC hesaplamasına karıştırılır. Tipik seçimler: stack pointer (`SP`), frame pointer veya bir object ID.
- SP’nin modifier olarak kullanılması, return address signing için yaygındır: PAC belirli bir stack frame’e bağlanır. Aynı LR’ı farklı bir frame’de yeniden kullanmayı denerseniz modifier değişir ve PAC doğrulaması başarısız olur.
- Aynı pointer değeri farklı modifier’larla imzalandığında farklı PAC’ler ortaya çıkar.
- Modifier gizli olmak zorunda değildir, ama ideal olarak saldırgan tarafından kontrol edilmeyen bir değer olmalıdır.
- Hiç anlamlı modifier olmayan durumlarda bazı formlar zero veya implicit sabit kullanır.

#### Apple / iOS / XNU Customizations & Observations

- Apple’ın PAC uygulaması her boot için diversifier’lar içerir, böylece anahtarlar veya tweakler her boot’ta değişir ve boot’lar arası tekrar kullanım engellenir.
- Ayrıca cross-domain mitigations vardır; user mode’da imzalanan PAC’lerin kernel modunda kolayca yeniden kullanılmasını zorlaştırırlar.
- Apple Silicon (M1) üzerinde tersine mühendislik, dokuz modifier tipi ve Apple’a özgü anahtar kontrolü register’ları olduğunu gösterdi.
- Apple, PAC’i birçok kernel alt sisteminde kullanır: return address signing, kernel veri pointer’larında bütünlük, signed thread context’ler vb.
- Google Project Zero, güçlü bir read/write primitive ile kernel PAC’leri (A anahtarları için) A12 çağındaki aygıtlarda taklit edilebileceğini gösterdi; Apple bu yolların bir kısmını yamaladı.
- Apple’ın sisteminde bazı anahtarlar kernel genelindedir, user process’ler ise process başına anahtar rastgeleliği alabilir.

#### PAC Bypasses

1. **Kernel-mode PAC: theoretical vs real bypasses**

-   Kernel PAC anahtarları ve mantığı sıkı kontrol edildiği (ayrıcalıklı register’lar, diversifier’lar, domain izolasyonu) için, rastgele imzalanmış kernel pointer’ları taklit etmek çok zordur.
-   Azad’ın 2020 "iOS Kernel PAC, One Year Later" raporu, iOS 12-13’te birkaç kısmi bypass (signing gadget’lar, signed state yeniden kullanımı, korumasız dolaylı branch’ler) bulduğunu, fakat genel amaçlı tam bir bypass olmadığını bildirir. [bazad.github.io](https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf)
-   Apple’ın “Dark Magic” özelleştirmeleri exploitable yüzeyi daha da daralttı (domain switching, per-key enabling bit’leri). [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Apple silicon (M1/M2) için bildirilen bilinen bir kernel PAC bypass CVE-2023-32424 vardır (Zecao Cai ve diğ.). [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Ancak bu bypass’lar genellikle çok spesifik gadget’lara veya uygulama hatalarına dayanmaktadır; genel amaçlı değillerdir.

Dolayısıyla kernel PAC yüksek derecede sağlam kabul edilir, ancak kusursuz değildir.

2. **User-mode / runtime PAC bypass techniques**

Bunlar daha yaygındır ve PAC’in runtime/dinamik linking uygulamalarındaki eksikliklerini hedef alır. Aşağıda sınıflar ve örnekler verilmiştir.

2.1 **Shared Cache / A key issues**

-   **dyld shared cache** büyük, önceden linklenmiş sistem framework’leri ve kütüphanelerinin bir blob’udur. Çünkü çok yaygın paylaşılır, shared cache içindeki function pointer’lar zaten “pre-signed” olur ve birçok process tarafından kullanılır. Saldırganlar bu halihazırda imzalı pointer’ları “PAC oracle” olarak hedef alır.
-   Bazı bypass teknikleri shared cache’teki A-key ile imzalanmış pointer’ları çıkartıp yeniden kullanmaya çalışır.
-   "No Clicks Required" konuşması shared cache üzerinde bir oracle kurarak relative adresleri çıkarmayı ve imzalı pointer’larla birleşerek PAC’i atlatmayı tanımlar. [saelo.github.io](https://saelo.github.io/presentations/offensivecon_20_no_clicks.pdf)
-   Ayrıca userspace’deki shared library import’ları PAC ile yetersiz korunmuş bulunmuş; bir saldırgan function pointer’ları signature değiştirmeden elde edebiliyordu. (Project Zero bug entry) [bugs.chromium.org](https://bugs.chromium.org/p/project-zero/issues/detail?id=2044&utm_source=chatgpt.com)

2.2 **dlsym(3) / dynamic symbol resolution**

-   Bilinen bypass’lardan biri `dlsym()` çağırıp *zaten imzalanmış* bir function pointer almak ve onu kullanmaktır (A-key ile, diversifier zero ile imzalanmış olabilir). `dlsym` meşru olarak imzalanmış bir pointer döndürdüğünden PAC taklit etme ihtiyacını ortadan kaldırır.
-   Epsilon’un blogu bazı bypass’ların bunu nasıl kullandığını detaylandırır: `dlsym("someSym")` imzalı bir pointer döndürür ve dolaylı çağrılarda kullanılabilir. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)
-   Synacktiv’in "iOS 18.4 --- dlsym considered harmful" yazısı, iOS 18.4’te bazı `dlsym` çağrılarının yanlış imzalı veya hatalı diversifier’larla pointer döndürdüğünü ve bu sayede istenmeyen PAC bypass’larının ortaya çıktığını anlatır. [Synacktiv](https://www.synacktiv.com/en/publications/ios-184-dlsym-considered-harmful)
-   dyld içindeki mantık, `result->isCode` olduğunda döndürülen pointer’ı `__builtin_ptrauth_sign_unauthenticated(..., key_asia, 0)` ile context zero kullanarak imzaladığını içerir. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

Böylece `dlsym` user-mode PAC bypass’larında sıkça kullanılan bir vektördür.

2.3 **Other DYLD / runtime relocations**

-   DYLD loader ve dinamik relocation mantığı karmaşıktır ve bazen relocasyon yapmak için sayfaları geçici olarak read/write olarak eşler, sonra tekrar read-only’a çevirir. Saldırganlar bu zaman pencerelerini istismar eder. Synacktiv’in konuşması "Operation Triangulation" olarak adlandırılan, dinamik relocasyonlar yoluyla zamanlama tabanlı bir PAC bypass’ını anlatır. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)
-   DYLD sayfaları artık SPRR / VM_FLAGS_TPRO ile korunuyor (dyld için bazı koruma bayrakları). Ancak daha eski sürümlerde daha zayıf korumalar vardı. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)
-   WebKit exploit zincirlerinde DYLD loader sıklıkla PAC bypass hedefi olmuştur. Sunumlarda birçok PAC bypass’ının DYLD loader’ı (relocation, interposer hook’lar yoluyla) hedef aldığı belirtilir. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

2.4 **NSPredicate / NSExpression / ObjC / SLOP**

-   Userland exploit zincirlerinde Objective-C runtime method’ları (`NSPredicate`, `NSExpression`, `NSInvocation`) kontrol çağrılarını gizlice taşımak için kullanılır.
-   PAC öncesi eski iOS’ta bir exploit, sahte `NSInvocation` objeleri kullanarak kontrollü bellekteki selector’ları çağırabiliyordu. PAC ile teknik güncelleme gerektirdi, ancak SLOP (SeLector Oriented Programming) PAC altında da genişletildi. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)
-   Orijinal SLOP tekniği, sahte invocation’lar oluşturarak ObjC çağrılarının zincirlenmesine izin veriyordu; bypass, ISA veya selector pointer’larının bazen tam olarak PAC ile korunmamasına dayanıyordu. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)
-   PAC’in kısmi uygulandığı ortamlarda, method’lar / selector’lar / target pointer’lar her zaman PAC ile korunmayabilir; bu da bypass için fırsat verir.

#### Example Flow

<details>
<summary>Example Signing & Authenticating</summary>
```
; Example: function prologue / return address protection
my_func:
stp x29, x30, [sp, #-0x20]!        ; push frame pointer + LR
mov x29, sp
PACIASP                            ; sign LR (x30) using SP as modifier
; … body …
mov sp, x29
ldp x29, x30, [sp], #0x20         ; restore
AUTIASP                            ; authenticate & strip PAC
ret

; Example: indirect function pointer stored in a struct
; suppose X1 contains a function pointer
PACDA X1, X2     ; sign data pointer X1 with context X2
STR X1, [X0]      ; store signed pointer

; later retrieval:
LDR X1, [X0]
AUTDA X1, X2       ; authenticate & strip
BLR X1             ; branch to valid target

; Example: stripping for comparison (unsafe)
LDR X1, [X0]
XPACI X1           ; strip PAC (instruction domain)
CMP X1, #some_label_address
BEQ matched_label
```
### 9. **Branch Target Identification (BTI)**
**Introduced with ARMv8.5 (later hardware)**
BTI, **dolaylı branch hedeflerini** kontrol eden bir donanım özelliğidir: `blr` veya dolaylı çağrılar/atlamalar yürütülürken, hedefin bir **BTI landing pad** ile başlaması gerekir (`BTI j` veya `BTI c`). Landing pad içermeyen gadget adreslerine atlama bir istisna tetikler.

LLVM’in uygulama notları BTI talimatlarının üç varyantını ve bunların branch türlerine nasıl eşlendiğini belirtir.

| BTI Variant | What it permits (which branch types) | Typical placement / use case |
|-------------|----------------------------------------|-------------------------------|
| **BTI C** | Targets of *call*-style indirect branches (e.g. `BLR`, or `BR` using X16/X17) | Put at entry of functions that may be called indirectly |
| **BTI J** | Targets of *jump*-style branches (e.g. `BR` used for tail calls) | Placed at the beginning of blocks reachable by jump tables or tail-calls |
| **BTI JC** | Acts as both C and J | Can be targeted by either call or jump branches |

- Branch target enforcement ile derlenen kodda, derleyiciler her geçerli dolaylı-branch hedefinin (fonksiyon başlangıçları veya atlamalarla erişilebilen bloklar) başına bir BTI talimatı (C, J veya JC) yerleştirir, böylece dolaylı branch’ler yalnızca bu yerlere başarılı olur.
- **Doğrudan branch / çağrılar** (yani sabit adresli `B`, `BL`) BTI ile **kısıtlanmaz**. Varsayım, kod sayfalarının güvenilir olduğu ve saldırganın bunları değiştiremeyeceğidir (bu yüzden doğrudan branch’ler güvenlidir).
- Ayrıca, **RET / return** talimatları genellikle BTI ile kısıtlanmaz çünkü dönüş adresleri PAC veya return signing mekanizmalarıyla korunur.

#### Mechanism and enforcement

- CPU, “guarded / BTI-enabled” olarak işaretlenmiş bir sayfada **dolaylı branch (BLR / BR)** çözdüğünde, hedef adresin ilk talimatının izin verilen bir BTI (izin verilen C, J veya JC) olup olmadığını kontrol eder. Değilse, bir **Branch Target Exception** oluşur.
- BTI talimatı kodlaması, daha önce NOP olarak ayrılmış opcode’ları yeniden kullanacak şekilde tasarlandığından, BTI-etkin ikili dosyalar geriye dönük uyumludur: BTI desteği olmayan donanımda bu talimatlar NOP gibi davranır.
- BTI ekleyen derleyici pass’ları yalnızca gerektiği yere BTI koyar: dolaylı çağrılabilecek fonksiyonlar veya atlamalarla hedeflenen basic block’lar.
- Bazı yamalar ve LLVM kodu, BTI’nin *tüm* basic block’lara değil — yalnızca olası branch hedeflerine (ör. switch / jump tablolarından gelenler) eklendiğini gösterir.

#### BTI + PAC synergy

PAC, gösterge değerini (kaynağı) korur — dolaylı çağrıların / dönüşlerin zincirinin değiştirilmediğini sağlar.

BTI ise geçerli bir pointer olsa bile hedefin doğru işaretlenmiş giriş noktalarına yapılması gerektiğini garanti eder.

Birleşince, bir saldırganın hem doğru PAC ile imzalanmış geçerli bir pointer’a hem de hedefte BTI bulunmasına ihtiyacı olur. Bu, exploit gadget’ları oluşturmayı zorlaştırır.

#### Example


<details>
<summary>Example</summary>
Bir exploit, `0xABCDEF` adresindeki ve `BTI c` ile başlamayan bir gadget’a pivot etmeye çalışır. CPU `blr x0` yürüttüğünde hedefi kontrol eder ve talimat hizalaması geçerli bir landing pad içermediği için hata verir. Böylece BTI ön eki olmayan birçok gadget kullanılamaz hale gelir.
</details>


### 10. **Privileged Access Never (PAN) & Privileged Execute Never (PXN)**
**Introduced in more recent ARMv8 extensions / iOS support (for hardened kernel)**

#### PAN (Privileged Access Never)

- **PAN**, **ARMv8.1-A** ile gelen bir özellikle, **ayrıcalıklı kodun** (EL1 veya EL2) **kullanıcıya açık (EL0)** olarak işaretlenmiş belleği **okumasını veya yazmasını** engeller; PAN açık değilse bu erişim mümkün değildir.
- Fikir: kernel kandırılsa veya ele geçirilse bile, user-space pointer’larını keyfi olarak dereference edememesi için önce PAN’ı *devre dışı bırakması* gerekir; böylece `ret2usr` tarzı exploit veya kullanıcı kontrollü bufferların kötüye kullanımı azaltılır.
- PAN etkinken (PSTATE.PAN = 1), herhangi bir ayrıcalıklı load/store, “EL0 tarafından erişilebilir” olarak işaretlenmiş sanal adrese erişmeye çalışırsa bir **izin hatası** tetiklenir.
- Kernel, meşru olarak user-space belleğine erişmesi gerektiğinde (ör. kullanıcı buffer’larına veri kopyalama), PAN’ı **geçici olarak devre dışı bırakmak** veya bu erişime izin veren “unprivileged load/store” talimatlarını kullanmak zorundadır.
- Linux’ta ARM64 için PAN desteği ~2015 civarında eklendi: kernel yamaları özelliği algılayıp `get_user` / `put_user` vb. işlevleri PAN’ı temizleyen varyantlarla değiştirdi.

**Key nuance / limitation / bug**
- Siguza ve diğerlerinin belirttiği gibi, ARM spesifikasyonundaki bir tasarım belirsizliği (veya hata), **sadece execute olan kullanıcı haritalamalarının** (`--x`) **PAN’ı tetiklemeyebileceği** anlamına gelir. Yani bir kullanıcı sayfası yürütülebilir ancak okunamaz olarak işaretlenmişse, kernel’in okuma denemesi PAN’ı atlatabilir çünkü mimari “EL0 tarafından erişilebilir” tanımında okunabilir iznin aranması, yalnızca yürütme izninin aranmasından farklı değerlendirilebilir. Bu, belirli konfigürasyonlarda PAN baypasına yol açar.
- Bu nedenle, eğer iOS / XNU execute-only kullanıcı sayfalarına izin veriyorsa (ör. bazı JIT veya code-cache düzenleri), kernel PAN etkin olsa bile bu sayfalardan yanlışlıkla veri okuyabilir. Bu, ARMv8+ sistemlerde bilinen ince bir istismar edilebilir alandır.

#### PXN (Privileged eXecute Never)

- **PXN**, sayfa tablosu girdilerinde (leaf veya block girdileri) bulunan bir bit olup, sayfanın **ayrıcalıklı modda yürütülemeyeceğini** gösterir (yani EL1’in o sayfayı yürütmesi engellenir).
- PXN, kernel’in (veya herhangi ayrıcalıklı kodun) kullanıcı-space sayfalarından talimatları yürütmesini engeller; kontrol akışı yönlendirilse bile kernel’in user belleğine atlamasını durdurur.
- PAN ile birleştiğinde:
1. Kernel varsayılan olarak kullanıcı verisini okuyamaz/yazamaz (PAN)
2. Kernel kullanıcı kodunu yürütemez (PXN)
- ARMv8 sayfa tablosu formatında leaf girdilerin attribute bitleri arasında `PXN` (ve ayrıca unprivileged için `UXN`) bittleri bulunur.

Dolayısıyla kernel’in bozulmuş bir fonksiyon göstergesinin kullanıcı belleğine işaret etmesi ve oraya branch yapması durumunda PXN biti bir hata oluşturur.

#### Memory-permission model & how PAN and PXN map to page table bits

PAN / PXN’in nasıl çalıştığını anlamak için ARM’ın çeviri ve izin modeline bakmak gerekir (basitleştirilmiş):

- Her sayfa veya block girdisinin, erişim izinleri için **AP[2:1]** ve yürütmeyi engellemek için **UXN / PXN** bitleri dahil öznitelik alanları vardır.
- PSTATE.PAN 1 (etkin) olduğunda, donanım değiştirilmiş semantiği uygular: ayrıcalıklı erişimler, “EL0 tarafından erişilebilir” olarak işaretlenmiş sayfalara karşı engellenir (hata).
- Bahsedilen hata nedeniyle, yalnızca yürütülebilir (okunamaz) olarak işaretlenmiş sayfalar bazı uygulamalarda “EL0 tarafından erişilebilir” sayılmayabilir ve böylece PAN’ı atlayabilir.
- Bir sayfanın PXN biti setliyse, talimat fetch’i daha yüksek ayrıcalıktan gelse bile yürütme yasaklanır.

#### Kernel usage of PAN / PXN in a hardened OS (e.g. iOS / XNU)

Sertleştirilmiş bir kernel tasarımında (Apple’ın kullanabileceği gibi):

- Kernel varsayılan olarak PAN’ı etkinleştirir (böylece ayrıcalıklı kod sınırlanır).
- Meşru olarak kullanıcı buffer’larını okumak/yazmak gerektiğinde (syscall buffer copy, I/O, read/write user pointer vb.), kernel PAN’ı geçici olarak **devre dışı bırakır** veya erişimi aşan özel talimatlar kullanır.
- Kullanıcı veri erişimi bitince PAN tekrar **yeniden etkinleştirilmelidir**.
- PXN sayfa tabloları aracılığıyla uygulanır: kullanıcı sayfalarının PXN = 1 olarak ayarlanması (kernel’in onları yürütmesini engellemek) sağlanır; kernel sayfaları PXN içermez.
- Kernel, hiçbir kod yolunun kullanıcı bellek bölgelerine yürütme akışı getirmemesini sağlamalıdır — aksi durumda PXN’i atlayan exploit zincirleri mümkün olur.

Belirtilen execute-only sayfa PAN baypası yüzünden, pratikte Apple bu tür execute-only user sayfalarını devre dışı bırakabilir veya spesifikasyon zayıflığına karşı yamalar uygulayabilir.

#### Attack surfaces, bypasses, and mitigations

- **PAN bypass via execute-only pages**: Yukarıda tartışıldığı gibi, spesifikasyon bir boşluk sunar: execute-only (okunmaz) olarak işaretlenmiş kullanıcı sayfaları bazı uygulamalarda “EL0 tarafından erişilebilir” sayılmayabilir, dolayısıyla PAN kernel okumasını engellemez. Bu, saldırgana execute-only bölümler aracılığıyla veri verme yolu açar.
- **Temporal window exploit**: Kernel PAN’ı gerekli olandan daha uzun süre devre dışı bırakırsa, bir yarış veya kötü niyetli yol bu pencereyi kullanarak istenmeyen kullanıcı bellek erişimi yapabilir.
- **Forgotten re-enable**: Kod yolları PAN’ı yeniden etkinleştirmeyi unutursa, sonraki kernel işlemleri yanlışlıkla kullanıcı belleğine erişebilir.
- **Misconfiguration of PXN**: Sayfa tabloları kullanıcı sayfalarında PXN’i ayarlamazsa veya kullanıcı kod sayfalarını yanlış eşlerse, kernel kullanıcı-space kodunu çalıştırmaya zorlanabilir.
- **Speculation / side-channels**: Spekülatif baypaslara benzer olarak, mikromimari yan etkiler PAN / PXN kontrollerinin geçici olarak atlanmasına neden olabilir (ancak bu tür saldırılar CPU tasarımına oldukça bağımlıdır).
- **Complex interactions**: JIT, shared memory, just-in-time code region’ları gibi gelişmiş özelliklerde kernelin belirli bellek erişimlerine veya kullanıcı-mapped bölgelerde yürütmeye ince kontrollü izin vermesi gerekebilir; PAN/PXN kısıtları altında bunları güvenli şekilde tasarlamak zordur.

#### Example

<details>
<summary>Code Example</summary>
Aşağıda, kullanıcı belleğine erişim etrafında PAN’ın etkinleştirilip/devre dışı bırakılmasını ve bir hatanın nasıl oluşabileceğini gösteren örnek pseudo-assembly dizileri verilmiştir.
</details>
```  
// Suppose kernel entry point, PAN is enabled (privileged code cannot access user memory by default)

; Kernel receives a syscall with user pointer in X0
; wants to read an integer from user space
mov   X1, X0        ; X1 = user pointer

; disable PAN to allow privileged access to user memory
MSR   PSTATE.PAN, #0   ; clear PAN bit, disabling the restriction

ldr   W2, [X1]       ; now allowed load from user address

; re-enable PAN before doing other kernel logic
MSR   PSTATE.PAN, #1   ; set PAN

; ... further kernel work ...

; Later, suppose an exploit corrupts a pointer to a user-space code page and jumps there
BR    X3             ; branch to X3 (which points into user memory)

; Because the target page is marked PXN = 1 for privileged execution,
; the CPU throws an exception (fault) and rejects execution
```
Eğer kernel o kullanıcı sayfasında PXN'yi **etkinleştirmemiş** olsaydı, o dallanma başarılı olabilir — ki bu güvensiz olurdu.

Kernel, kullanıcı belleğine erişim sonrası PAN'ı yeniden etkinleştirmeyi unutursa, bu durum ilerideki kernel mantığının kazara rasgele kullanıcı belleğini okumasına/yazmasına olanak verecek bir pencere açar.

Eğer kullanıcı işaretçisi execute-only bir sayfaya (sadece execute izni, okuma/yazma yok) işaret ediyorsa, PAN spesifikasyon hatası altında `ldr W2, [X1]` PAN etkin olsa bile hata vermeyebilir; uygulamaya bağlı olarak bu bir bypass exploit'ine olanak sağlayabilir.

</details>

<details>
<summary>Örnek</summary>
Bir kernel açığı, kullanıcı tarafından sağlanan bir fonksiyon işaretçisini alıp kernel bağlamında çağırmaya çalışır (örn. `call user_buffer`). PAN/PXN altında bu işlem yasaktır veya hata üretir.
</details>

---

### 11. **Top Byte Ignore (TBI) / Pointer Tagging**
**Introduced in ARMv8.5 / newer (or optional extension)**
TBI, 64-bit bir işaretçinin en üst baytının adres çevriminde yok sayılmasını sağlar. Bu, OS veya donanımın işaretçinin üst baytında **tag bitleri** gömmesine olanak tanır; bu, gerçek adresi etkilemez.

- TBI, **Top Byte Ignore** anlamına gelir (bazı yerlerde *Address Tagging* olarak anılır). Bu, bir donanım özelliğidir (birçok ARMv8+ implementasyonunda bulunur) ve 64-bit bir işaretçinin en üst 8 bitini (bit 63:56) adres çevirimi / load/store / instruction fetch sırasında **göz ardı eder**.
- Pratikte, CPU adres çevirimi açısından `0xTTxxxx_xxxx_xxxx` (burada `TT` = üst bayt) işaretçisini `0x00xxxx_xxxx_xxxx` olarak ele alır; üst bayt maskelenir. Üst bayt, yazılım tarafından **metadata / tag bitleri** depolamak için kullanılabilir.
- Bu, yazılıma her işaretçiye hangi bellek lokasyonuna işaret ettiğini değiştirmeden bir bayt tag gömme için “ücretsiz” bant içi alan sağlar.
- Mimari, yükleme, yazma ve komut getirme işlemlerinin gerçek bellek erişimi gerçekleştirilmeden önce işaretçinin üst baytı maskelenmiş (yani tag çıkarılmış) halini kullanmasını garanti eder.

Böylece TBI, **mantıksal işaretçi**yi (işaretçi + tag) bellek işlemleri için kullanılan **fiziksel adresten** ayırır.

#### Neden TBI: Kullanım durumları ve motivasyon

- **Pointer tagging / metadata**: Üst baytta ekstra meta veri (ör. nesne türü, sürüm, sınırlar, bütünlük tag'leri) depolayabilirsiniz. İşaretçi daha sonra kullanıldığında tag donanım düzeyinde göz ardı edilir; bu nedenle bellek erişimi için manuel olarak tag temizlemeye gerek kalmaz.
- **Memory tagging / MTE (Memory Tagging Extension)**: TBI, MTE'nin üzerine kurulduğu temel donanım mekanizmasıdır. ARMv8.5'te, **Memory Tagging Extension**, işaretçinin bit 59:56'sını bir **mantıksal tag** olarak kullanır ve bunu bellekte saklanan bir **allocation tag** ile karşılaştırır.
- **Gelişmiş güvenlik ve bütünlük**: TBI'yi pointer authentication (PAC) veya runtime kontrollerle birleştirerek yalnızca işaretçi değerinin değil tag'in de doğru olmasını zorlayabilirsiniz. Doğru tag olmadan bir işaretçiyi üzerine yazan saldırgan, tag uyuşmazlığı ile karşılaşır.
- **Uyumluluk**: TBI opsiyoneldir ve tag bitleri donanım tarafından göz ardı edildiği için mevcut tag'lenmemiş kod normal şekilde çalışmaya devam eder. Tag bitleri eski kod için etkili olarak “umursanmaz” bitler haline gelir.

#### Örnek
<details>
<summary>Örnek</summary>
Bir fonksiyon işaretçisinin üst baytında bir tag vardı (ör. `0xAA`). Bir exploit işaretçinin düşük bitlerini üzerine yazar fakat tag'i ihmal eder; bu yüzden kernel doğrulama veya temizleme yaptığında işaretçi başarısız olur veya reddedilir.
</details>

---

### 12. **Page Protection Layer (PPL)**
**Introduced in late iOS / modern hardware (iOS ~17 / Apple silicon / high-end models)** (bazı raporlar PPL'i macOS / Apple silicon civarında gösteriyor, ancak Apple iOS için benzer korumaları getiriyor)

- PPL, bir **intra-kernel koruma sınırı** olarak tasarlanmıştır: kernel (EL1) ele geçirilmiş ve okuma/yazma yetkisine sahip olsa bile, belirli **hassas sayfaları** (özellikle sayfa tabloları, code-signing metadata, kernel kod sayfaları, entitlements, trust cache'ler vb.) **serbestçe değiştirememelidir**.
- Bu temelde bir “kernel içinde kernel” yaratır — sadece PPL alanına ait daha küçük bir güvenilir bileşen, korunan sayfaları değiştirebilecek **yükseltilmiş ayrıcalıklara** sahiptir. Diğer kernel kodu değişiklik yapmak için PPL rutinlerini çağırmak zorundadır.
- Bu, kernel exploit'lerinin saldırı yüzeyini azaltır: kernel modunda tam rasgele R/W/execute kontrolü olsa bile, exploit kodunun kritik yapıları değiştirebilmesi için PPL alanına girmesi (veya PPL'i atlatması) gerekir.
- Yeni Apple silicon'larda (A15+ / M2+), Apple birçok durumda sayfa tablosu koruması için PPL yerine **SPTM (Secure Page Table Monitor)**'a geçiş yapmaktadır.

Aşağıda PPL'in kamuya açık analizlere dayanarak nasıl çalıştığına dair inanılanlar verilmiştir:

#### APRR / permission routing kullanımı (APRR = Access Permission ReRouting)

- Apple donanımı, sayfa tablo girdilerinin (PTE) tam izin bitleri yerine küçük indeksler içermesine izin veren bir mekanizma olan **APRR (Access Permission ReRouting)** kullanır. Bu indeksler APRR kayıtları aracılığıyla gerçek izinlere eşlenir. Bu, domain başına dinamik izin yeniden eşlemesine izin verir.
- PPL, kernel bağlamı içinde ayrıcalıkları ayırmak için APRR'den yararlanır: yalnızca PPL domain'i PTE'ler ile indeksler arasındaki eşlemeyi güncelleme yetkisine sahiptir. Yani, non-PPL kernel kodu bir PTE yazdığında veya izin bitlerini değiştirmeye çalıştığında, APRR mantığı bunu engeller (veya salt-okunur eşlemeyi uygular).
- PPL kodu kendisi sınırlı bir bölge (`__PPLTEXT` gibi) içinde çalışır; bu bölge normalde giriş kapıları geçici olarak izin verene kadar executable veya writable değildir. Kernel, hassas işlemleri gerçekleştirmek için PPL giriş noktalarını (“PPL rutinleri”) çağırır.

#### Giriş / Çıkış Kapısı

- Kernel, korunan bir sayfayı değiştirmesi gerektiğinde (ör. bir kernel kod sayfasının izinlerini değiştirmek veya sayfa tablolarını değiştirmek) bir **PPL wrapper** rutinini çağırır; bu rutin doğrulama yapar ve ardından PPL domain'ine geçiş yapar. Bu domain dışındayken, korunan sayfalar ana kernel tarafından etkili olarak salt-okunur veya değiştirilemez durumdadır.
- PPL girişinde, APRR eşlemeleri PPL bölgesindeki bellek sayfalarının PPL içinde **executable & writable** olacak şekilde ayarlanır. Çıkışta, bunlar tekrar salt-okunur / yazılamaz hale getirilir. Bu, sadece iyi denetlenmiş PPL rutinlerinin korunan sayfaları yazmasını sağlar.
- PPL dışındaki kernel kodunun bu korunan sayfalara yazma girişimleri, o kod domain'i için APRR eşlemesi yazmaya izin vermediği için fault (izin reddi) ile sonuçlanır.

#### Korunan sayfa kategorileri

PPL genellikle aşağıdaki sayfaları korur:

- Sayfa tablo yapıları (translation table girdileri, eşleme metadata'sı)
- Kernel kod sayfaları, özellikle kritik mantığı içerenler
- Code-sign metadata (trust cache'ler, imza blob'ları)
- Entitlement tabloları, imza uygulama tabloları
- İmza kontrollerini veya kimlik bilgisi manipülasyonunu atlatmaya izin verecek diğer yüksek değerli kernel yapıları

Amaç, kernel belleği tamamen kontrol altında olsa bile saldırganın bu sayfaları basitçe yamalayıp yeniden yazamamasıdır; saldırganın ya PPL rutinlerini ele geçirmesi ya da PPL'i atlatması gerekir.


#### Bilinen Bypass'lar & Zayıflıklar

1. **Project Zero’nun PPL bypass'ı (stale TLB hilesi)**

- Project Zero tarafından yayımlanan bir yazıda **stale TLB entry** içerikli bir bypass anlatılmaktadır.
- Fikir:

1. İki fiziksel sayfa A ve B ayırın, bunları PPL sayfaları olarak işaretleyin (yani korunan).
2. L3 çeviri tablosu sayfaları A ve B olan iki sanal adres P ve Q eşleyin.
3. Q'ya sürekli erişerek bir thread çalıştırın, böylece onun TLB girdisi canlı kalsın.
4. `pmap_remove_options()` çağırarak P'den başlayan eşlemeleri kaldırın; bir hatadan ötürü kod yanlışlıkla P ve Q için TTE'leri kaldırır, ancak sadece P için TLB girdisini geçersiz kılar, Q'nun stale girdisi canlı kalır.
5. B'yi (Q'nun tablosu) yeniden kullanarak rasgele bellek (ör. PPL-korunan sayfalar) eşlemesi yapın. Çünkü stale TLB girişi hala Q'nun eski eşlemesini haritalıyor, o bağlam için bu eşleme geçerli kalır.
6. Böylece saldırgan, PPL arayüzünü kullanmadan PPL-korunan sayfaların yazılabilir eşlemesini yerleştirebilir.

- Bu exploit fiziksel eşleme ve TLB davranışı üzerinde hassas kontrol gerektiriyordu. Bu, TLB invalidasyonu ve eşleme tutarlılığına dayanan bir güvenlik sınırının çok dikkatli olması gerektiğini gösterir.

- Project Zero, bu tür bypass'ların ince ve nadir olduğunu, ancak karmaşık sistemlerde mümkün olduğunu belirtti. Yine de PPL'i sağlam bir hafifletme olarak görüyorlar.

2. **Diğer potansiyel tehlikeler & kısıtlar**

- Eğer bir kernel exploit'i doğrudan PPL rutinlerine girebiliyorsa (PPL wrapper'larını çağırarak), kısıtlamaları atlayabilir. Bu nedenle argüman doğrulaması kritik önemdedir.
- PPL kodundaki hatalar (örn. aritmetik taşma, sınır kontrolleri) PPL içinde out-of-bounds değişikliklere izin verebilir. Project Zero, `pmap_remove_options_internal()` içindeki böyle bir hatanın bypass'ta kullanıldığını gözlemledi.
- PPL sınırı donanım uygulamasına (APRR, bellek denetleyicisi) sıkı sıkıya bağlıdır; bu yüzden yalnızca donanım uygulaması kadar güçlüdür.



#### Örnek
<details>
<summary>Kod Örneği</summary>
Burada, bir kernel'in korunan sayfaları değiştirmek için PPL'yi nasıl çağırabileceğini gösteren basitleştirilmiş pseudo-kod / mantık:
```c
// In kernel (outside PPL domain)
function kernel_modify_pptable(pt_addr, new_entry) {
// validate arguments, etc.
return ppl_call_modify(pt_addr, new_entry)  // call PPL wrapper
}

// In PPL (trusted domain)
function ppl_call_modify(pt_addr, new_entry) {
// temporarily enable write access to protected pages (via APRR adjustments)
aprr_set_index_for_write(PPL_INDEX)
// perform the modification
*pt_addr = new_entry
// restore permissions (make pages read-only again)
aprr_restore_default()
return success
}

// If kernel code outside PPL does:
*pt_addr = new_entry  // a direct write
// It will fault because APRR mapping for non-PPL domain disallows write to that page
```
Kernel birçok normal işlemi gerçekleştirebilir, ancak korumalı eşlemeleri değiştirebilmesi veya kodu yamayabilmesi yalnızca `ppl_call_*` rutinleri aracılığıyla mümkündür.
</details>

<details>
<summary>Örnek</summary>
Bir kernel exploit'i entitlement tablosunu üzerine yazmaya çalışır veya bir kernel signature blob'unu değiştirerek code-sign zorlamasını devre dışı bırakmaya çalışır. O sayfa PPL ile korunmuş olduğundan, yazma PPL arayüzü üzerinden yapılmadıkça engellenir. Yani kernel kod yürütme yetkiniz olsa bile code-sign kısıtlamalarını atlayamaz veya kimlik bilgisi verilerini keyfi olarak değiştiremezsiniz.
iOS 17+'de bazı cihazlar PPL tarafından yönetilen sayfaları daha da izole etmek için SPTM kullanır.
</details>

#### PPL → SPTM / Replacements / Future

- On Apple’s modern SoCs (A15 or later, M2 or later), Apple supports **SPTM** (Secure Page Table Monitor), which **replaces PPL** for page table protections.
- Apple calls out in documentation: “Page Protection Layer (PPL) and Secure Page Table Monitor (SPTM) enforce execution of signed and trusted code … PPL manages the page table permission overrides … Secure Page Table Monitor replaces PPL on supported platforms.”
- The SPTM architecture likely shifts more policy enforcement into a higher-privileged monitor outside kernel control, further reducing the trust boundary.

### MTE | EMTE | MIE

Aşağıda Apple'ın MIE düzeninde EMTE'nin nasıl çalıştığına dair üst düzey bir açıklama yer alıyor:

1. **Etiket atanması**
- Bellek ayrıldığında (ör. kernel veya user space'te secure allocator'lar aracılığıyla), o bloğa bir **gizli etiket** atanır.
- Kullanıcıya veya kernela döndürülen pointer, yüksek bitlerinde o etiketi içerir (TBI / top byte ignore mekanizmalarını kullanarak).

2. **Erişimde etiket denetimi**
- Bir pointer kullanılarak her load veya store gerçekleştirildiğinde, donanım pointer'ın etiketinin bellek bloğunun etiketiyle (allocation tag) eşleşip eşleşmediğini kontrol eder. Uyuşmazlık varsa hemen fault verir (çünkü eşzamanlıdır).
- Eşzamanlı olduğundan “delayed detection” penceresi yoktur.

3. **Free / reuse sırasında yeniden etiketleme**
- Bellek free edildiğinde, allocator bloğun etiketini değiştirir (dolayısıyla eski etiketli pointer'lar artık eşleşmez).
- Bu yüzden bir use-after-free pointer eski bir etiket taşır ve erişildiğinde uyuşmazlık olur.

4. **Taşmaları yakalamak için komşu-etiket farklılaştırması**
- Bitışik ayrımlara farklı etiketler verilir. Eğer bir buffer overflow komşu belleğe taşarsa, etiket uyuşmazlığı fault'a neden olur.
- Bu, sınırı geçen küçük overflow'ları yakalamada özellikle etkilidir.

5. **Etiket gizliliğinin sağlanması**
- Apple tag değerlerinin leaked olmasını engellemelidir (çünkü saldırgan etiketi öğrenirse doğru etiketlere sahip pointer'lar oluşturabilir).
- Bunun için side-channel leakage of tag bits'i önlemeye yönelik microarchitectural / speculative controls gibi korumalar içerir.

6. **Kernel ve user-space entegrasyonu**
- Apple EMTE'yi sadece user-space'te değil, aynı zamanda kernel/OS kritik bileşenlerinde de kullanır (kernel'i bellek bozulmalarına karşı korumak için).
- Donanım/OS, kernel user space adına çalışıyor olsa bile etiket kurallarının uygulanmasını garanti eder.

<details>
<summary>Örnek</summary>
```
Allocate A = 0x1000, assign tag T1
Allocate B = 0x2000, assign tag T2

// pointer P points into A with tag T1
P = (T1 << 56) | 0x1000

// Valid store
*(P + offset) = value // tag T1 matches allocation → allowed

// Overflow attempt: P’ = P + size_of_A (into B region)
*(P' + delta) = value
→ pointer includes tag T1 but memory block has tag T2 → mismatch → fault

// Free A, allocator retags it to T3
free(A)

// Use-after-free:
*(P) = value
→ pointer still has old tag T1, memory region is now T3 → mismatch → fault
```
</details>

#### Limitations & challenges

- **Intrablock overflows**: Taşma aynı allocation içinde kalırsa (sınırı geçmez) ve tag aynıysa, tag mismatch bunu yakalamaz.
- **Tag width limitation**: Tag için sadece birkaç bit (ör. 4 bit veya küçük bir domain) kullanılabilir—sınırlı isim alanı.
- **Side-channel leaks**: Eğer tag bitleri (cache / speculative execution aracılığıyla) leak olabiliyorsa, saldırgan geçerli tagleri öğrenip atlatabilir. Apple’ın tag confidentiality enforcement buna karşı koruma sağlamayı amaçlar.
- **Performance overhead**: Her load/store için yapılan tag kontrolleri maliyet ekler; Apple donanımı optimize ederek bu ek yükü düşük tutmak zorunda.
- **Compatibility & fallback**: Eski donanımda veya EMTE desteklemeyen kısımlarda fallback olması gerekir. Apple, MIE’nin sadece destekleyen cihazlarda etkinleştirildiğini iddia ediyor.
- **Complex allocator logic**: Allocator tag’leri yönetmeli, retagging, hizalama sınırlarını ele almalı ve yanlış-tag çakışmalarını önlemeli. Allocator mantığındaki hatalar yeni zafiyetler yaratabilir.
- **Mixed memory / hybrid areas**: Bazı bellek alanları untagged (legacy) kalabilir; bu da birlikte çalışmayı zorlaştırır.
- **Speculative / transient attacks**: Birçok mikro-mimari korumada olduğu gibi speculative execution veya micro-op fusion’lar kontrolleri geçici olarak atlatabilir ya da tag bitlerini leak edebilir.
- **Limited to supported regions**: Apple EMTE’yi yalnızca seçili, yüksek riskli alanlarda (çekirdek, güvenlik-kritik alt sistemler) zorunlu kılabilir, tümünde değil.

---

## Key enhancements / differences compared to standard MTE

Here are the improvements and changes Apple emphasizes:

| Feature | Original MTE | EMTE (Apple’s enhanced) / MIE |
|---|---|---|
| **Check mode** | Supports synchronous and asynchronous modes. In async, tag mismatches are reported later (delayed)| Apple insists on **synchronous mode** by default—tag mismatches are caught immediately, no delay/race windows allowed.|
| **Coverage of non-tagged memory** | Accesses to non-tagged memory (e.g. globals) may bypass checks in some implementations | EMTE requires that accesses from a tagged region to non-tagged memory also validate tag knowledge, making it harder to bypass by mixing allocations.|
| **Tag confidentiality / secrecy** | Tags might be observable or leaked via side channels | Apple adds **Tag Confidentiality Enforcement**, which attempts to prevent leakage of tag values (via speculative side-channels etc.).|
| **Allocator integration & retagging** | MTE leaves much of allocator logic to software | Apple’s secure typed allocators (kalloc_type, xzone malloc, etc.) integrate with EMTE: when memory is allocated or freed, tags are managed at fine granularity.|
| **Always-on by default** | In many platforms, MTE is optional or off by default | Apple enables EMTE / MIE by default on supported hardware (e.g. iPhone 17 / A19) for kernel and many user processes.|

Because Apple controls both the hardware and software stack, it can enforce EMTE tightly, avoid performance pitfalls, and close side-channel holes.

---

## How EMTE works in practice (Apple / MIE)

Here’s a higher-level description of how EMTE operates under Apple’s MIE setup:

1. **Tag assignment**
- When memory is allocated (e.g. in kernel or user space via secure allocators), a **secret tag** is assigned to that block.
- The pointer returned to the user or kernel includes that tag in its high bits (using TBI / top byte ignore mechanisms).

2. **Tag checking on access**
- Whenever a load or store is executed using a pointer, the hardware checks that the pointer’s tag matches the memory block’s tag (allocation tag). If mismatch, it faults immediately (since synchronous).
- Because it's synchronous, there is no “delayed detection” window.

3. **Retagging on free / reuse**
- When memory is freed, the allocator changes the block’s tag (so older pointers with old tags no longer match).
- A use-after-free pointer would therefore have a stale tag and mismatch when accessed.

4. **Neighbor-tag differentiation to catch overflows**
- Adjacent allocations are given distinct tags. If a buffer overflow spills into neighbor’s memory, tag mismatch causes a fault.
- This is especially powerful in catching small overflows that cross boundary.

5. **Tag confidentiality enforcement**
- Apple must prevent tag values being leaked (because if attacker learns the tag, they could craft pointers with correct tags).
- They include protections (microarchitectural / speculative controls) to avoid side-channel leakage of tag bits.

6. **Kernel and user-space integration**
- Apple uses EMTE not just in user-space but also in kernel / OS-critical components (to guard kernel against memory corruption).
- The hardware/OS ensures tag rules apply even when kernel is executing on behalf of user space.

Because EMTE is built into MIE, Apple uses EMTE in synchronous mode across key attack surfaces, not as opt-in or debugging mode.

---

## Exception handling in XNU

When an **exception** occurs (e.g., `EXC_BAD_ACCESS`, `EXC_BAD_INSTRUCTION`, `EXC_CRASH`, `EXC_ARM_PAC`, etc.), the **Mach layer** of the XNU kernel is responsible for intercepting it before it becomes a UNIX-style **signal** (like `SIGSEGV`, `SIGBUS`, `SIGILL`, ...).

This process involves multiple layers of exception propagation and handling before reaching user space or being converted to a BSD signal.

### Exception Flow (High-Level)

1.  **CPU triggers a synchronous exception** (e.g., invalid pointer dereference, PAC failure, illegal instruction, etc.).

2.  **Low-level trap handler** runs (`trap.c`, `exception.c` in XNU source).

3.  The trap handler calls **`exception_triage()`**, the core of the Mach exception handling.

4.  `exception_triage()` decides how to route the exception:

-   First to the **thread's exception port**.

-   Then to the **task's exception port**.

-   Then to the **host's exception port** (often `launchd` or `ReportCrash`).

If none of these ports handle the exception, the kernel may:

-   **Convert it into a BSD signal** (for user-space processes).

-   **Panic** (for kernel-space exceptions).

### Core Function: `exception_triage()`

The function `exception_triage()` routes Mach exceptions up the chain of possible handlers until one handles it or until it's finally fatal. It's defined in `osfmk/kern/exception.c`.
```c
void exception_triage(exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt);
```
**Tipik Çağrı Akışı:**

`exception_triage()
└── exception_deliver()
├── exception_deliver_thread()
├── exception_deliver_task()
└── exception_deliver_host()`

Eğer hepsi başarısız olursa → `bsd_exception()` tarafından işlenir → `SIGSEGV` gibi bir sinyale çevrilir.


### Exception Ports

Her Mach nesnesi (thread, task, host) **exception ports** kaydedebilir; exception mesajlarının gönderildiği yerlerdir.

Bunlar API tarafından tanımlanır:
```
task_set_exception_ports()
thread_set_exception_ports()
host_set_exception_ports()
```
Each exception port has:

-   A **mask** (which exceptions it wants to receive)
-   A **port name** (Mach port to receive messages)
-   A **behavior** (how the kernel sends the message)
-   A **flavor** (which thread state to include)


### Debuggers and Exception Handling

A **debugger** (e.g., LLDB) sets an **exception port** on the target task or thread, usually using `task_set_exception_ports()`.

**When an exception occurs:**

-   The Mach message is sent to the debugger process.
-   The debugger can decide to **handle** (resume, modify registers, skip instruction) or **not handle** the exception.
-   If the debugger doesn't handle it, the exception propagates to the next level (task → host).


### Flow of `EXC_BAD_ACCESS`

1.  Thread dereferences invalid pointer → CPU raises Data Abort.

2.  Kernel trap handler calls `exception_triage(EXC_BAD_ACCESS, ...)`.

3.  Message sent to:

-   Thread port → (debugger can intercept breakpoint).

-   If debugger ignores → Task port → (process-level handler).

-   If ignored → Host port (usually ReportCrash).

4.  If no one handles → `bsd_exception()` translates to `SIGSEGV`.


### PAC Exceptions

When **Pointer Authentication** (PAC) fails (signature mismatch), a **special Mach exception** is raised:

-   **`EXC_ARM_PAC`** (type)
-   Codes may include details (e.g., key type, pointer type).

If the binary has the flag **`TFRO_PAC_EXC_FATAL`**, the kernel treats PAC failures as **fatal**, bypassing debugger interception. This is to prevent attackers from using debuggers to bypass PAC checks and it's enabled for **platform binaries**.

### Software Breakpoints

A software breakpoint (`int3` on x86, `brk` on ARM64) is implemented by **causing a deliberate fault**.\
The debugger catches this via the exception port:

-   Modifies instruction pointer or memory.
-   Restores original instruction.
-   Resumes execution.

This same mechanism is what allows you to "catch" a PAC exception --- **unless `TFRO_PAC_EXC_FATAL`** is set, in which case it never reaches the debugger.


### Conversion to BSD Signals

If no handler accepts the exception:

-   Kernel calls `task_exception_notify() → bsd_exception()`.

-   This maps Mach exceptions to signals:

| Mach Exception | Signal |
| --- | --- |
| EXC_BAD_ACCESS | SIGSEGV or SIGBUS |
| EXC_BAD_INSTRUCTION | SIGILL |
| EXC_ARITHMETIC | SIGFPE |
| EXC_SOFTWARE | SIGTRAP |
| EXC_BREAKPOINT | SIGTRAP |
| EXC_CRASH | SIGKILL |
| EXC_ARM_PAC | SIGILL (on non-fatal) |


### Key Files in XNU Source

-   `osfmk/kern/exception.c` → Core of `exception_triage()`, `exception_deliver_*()`.

-   `bsd/kern/kern_sig.c` → Signal delivery logic.

-   `osfmk/arm64/trap.c` → Low-level trap handlers.

-   `osfmk/mach/exc.h` → Exception codes and structures.

-   `osfmk/kern/task.c` → Task exception port setup.

---

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

The kernel used a **zone allocator** (`kalloc`) divided into fixed-size "zones."
Each zone only stores allocations of a single size class.

From the screenshot:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Çok küçük kernel struct'ları, pointer'lar.                                  |
| `default.kalloc.32`  | 32 bytes     | Küçük struct'lar, obje header'ları.                                        |
| `default.kalloc.64`  | 64 bytes     | IPC mesajları, küçük kernel buffer'ları.                                   |
| `default.kalloc.128` | 128 bytes    | `OSObject` gibi orta boyutlu objelerin parçaları.                          |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Büyük yapılar, `IOSurface`/grafik metadata'sı.                              |

**How it worked:**
- Each allocation request gets **rounded up** to the nearest zone size.
(E.g., a 50-byte request lands in the `kalloc.64` zone).
- Memory in each zone was kept in a **free list** — chunks freed by the kernel went back into that zone.
- If you overflowed a 64-byte buffer, you’d overwrite the **next object in the same zone**.

This is why **heap spraying / feng shui** was so effective: you could predict object neighbors by spraying allocations of the same size class.

### The freelist

Inside each kalloc zone, freed objects weren’t returned directly to the system — they went into a freelist, a linked list of available chunks.

- When a chunk was freed, the kernel wrote a pointer at the start of that chunk → the address of the next free chunk in the same zone.

- The zone kept a HEAD pointer to the first free chunk.

- Allocation always used the current HEAD:

1. Pop HEAD (return that memory to the caller).

2. Update HEAD = HEAD->next (stored in the freed chunk’s header).

- Freeing pushed chunks back:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

So the freelist was just a linked list built inside the freed memory itself.

Normal state:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### freelist'in istismarı

Çünkü bir free chunk'ın ilk 8 baytı = freelist pointer olduğundan, bir saldırgan bunu bozabilir:

1. **Heap overflow** ile bitişik freed chunk'a taşma → onun “next” işaretçisini üzerine yazma.

2. **Use-after-free** ile freed bir nesneye yazma → onun “next” işaretçisini üzerine yazma.

Ardından, o boyuttaki bir sonraki allocation sırasında:

- Allocator bozulmuş chunk'ı pop eder.
- Saldırgan tarafından sağlanan “next” işaretçisini takip eder.
- Rastgele belleğe bir işaretçi döndürür; bu, fake object primitives veya targeted overwrite'a olanak verir.

Visual example of freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
This freelist tasarımı, sertleştirme öncesinde exploitleri son derece etkili hale getiriyordu: heap sprays'ten öngörülebilir komşular, raw pointer freelist linkleri ve tip ayrımının olmaması, saldırganların UAF/overflow hatalarını rastgele kernel bellek kontrolüne yükseltmesine izin veriyordu.

### Heap Grooming / Feng Shui
heap grooming'in amacı, bir saldırgan taşma veya use-after-free tetiklediğinde hedef (kurban) nesnenin saldırgan-kontrollü bir nesnenin hemen yanında yer almasını sağlayarak heap düzenini şekillendirmektir.\
Böylece bellek bozulması gerçekleştiğinde, saldırgan kurban nesneyi kontrollü verilerle güvenilir şekilde overwrite edebilir.

**Adımlar:**

1. Spray allocations (fill the holes)
- Zamanla kernel heap parçalanır: bazı zonlarda eski nesnelerin free edildiği delikler (holes) oluşur.
- Saldırgan ilk olarak bu boşlukları doldurmak için birçok sahte allocation yapar, böylece heap “sıkışır” ve öngörülebilir hale gelir.

2. Force new pages
- Delikler dolduktan sonra, sonraki allocations zone'a eklenen yeni sayfalardan gelmek zorunda kalır.
- Yeni sayfalar, nesnelerin eski parçalanmış bellek üzerinde dağılmak yerine küme halinde yerleşeceği anlamına gelir.
- Bu, saldırganın komşular üzerinde çok daha iyi kontrol sahibi olmasını sağlar.

3. Place attacker objects
- Saldırgan şimdi tekrar spray yapar ve bu yeni sayfalarda birçok saldırgan-kontrollü nesne oluşturur.
- Bu nesneler boyut ve yerleşim açısından öngörülebilir olur (çünkü hepsi aynı zone'a aittir).

4. Free a controlled object (make a gap)
- Saldırgan kasıtlı olarak kendi nesnelerinden birini free eder.
- Bu, allocator tarafından daha sonra aynı boyuttaki bir allocation için yeniden kullanılacak bir “delik” oluşturur.

5. Victim object lands in the hole
- Saldırgan, kernel'in hedef (korrupt etmek istediği) nesneyi allocate etmesini tetikler.
- Delik, freelist'teki ilk kullanılabilir slot olduğundan, kurban tam olarak saldırganın free ettiği nesnenin yerine yerleşir.

6. Overflow / UAF into victim
- Artık saldırganın kontrolündeki nesneler kurbanın etrafında bulunur.
- Kendi nesnesinden taşma yaparak (veya freed edilmiş birini yeniden kullanarak) kurbanın bellek alanındaki alanları seçilen değerlerle güvenilir şekilde overwrite edebilir.

**Neden işe yarar**:

- Zone allocator öngörülebilirliği: aynı boyuttaki allocation'lar her zaman aynı zon'dan gelir.
- Freelist davranışı: yeni allocation'lar önce en son free edilmiş chunk'ı yeniden kullanır.
- Heap sprays: saldırgan belleği öngörülebilir içerikle doldurur ve düzeni kontrol eder.
- Sonuç: saldırganın kurban nesnenin nereye yerleşeceğini ve yanına hangi verinin geleceğini kontrol etmesi sağlanır.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple allocator'ı sertleştirdi ve heap grooming'i çok daha zor hale getirdi:

### 1. From Classic kalloc to kalloc_type
- **Before**: her boyut sınıfı için (16, 32, 64, … 1280 vb.) tek bir `kalloc.<size>` zone'u vardı. O boyuttaki herhangi bir nesne oraya konulurdu → saldırgan nesneleri ayrıcalıklı kernel nesnelerinin yanına yerleşebilirdi.
- **Now**:
- Kernel nesneleri **typed zones** (`kalloc_type`)'tan allocate edilir.
- Her nesne tipi (ör. `ipc_port_t`, `task_t`, `OSString`, `OSData`) kendi adanmış zone'una sahiptir, hatta aynı boyutta olsalar bile.
- Nesne tipi ↔ zone eşlemesi derleme zamanında **kalloc_type system** tarafından üretilir.

Artık bir saldırgan, kontrollü verinin (`OSData`) aynı boyuttaki hassas kernel nesnelerinin (`task_t`) yanına geleceğini garanti edemez.

### 2. Slabs and Per-CPU Caches
- Heap, her zone için sabit boyutlu chunk'lara bölünmüş **slabs** (sayfa grupları) haline ayrılmıştır.
- Her zone'un contention'ı azaltmak için bir **per-CPU cache**'i vardır.
- Allocation yolu:
1. Önce per-CPU cache denenir.
2. Eğer boşsa, global freelist'ten çekilir.
3. Freelist boşsa, yeni bir slab (bir veya birden fazla sayfa) allocate edilir.
- **Fayda**: Bu decentralizasyon, allocation'ların farklı CPU cache'lerinden karşılanabilmesi nedeniyle heap spray'leri daha az deterministik yapar.

### 3. Randomization inside zones
- Bir zone içinde, free edilmiş elemanlar basit FIFO/LIFO sırasıyla geri verilmez.
- Modern XNU, **encoded freelist pointers** (Linux tarzı safe-linking benzeri, ~iOS 14 civarında) kullanır.
- Her freelist pointer, bir zone başına gizli bir cookie ile **XOR-encoded** edilir.
- Bu, eğer bir write primitive elde edilse bile saldırganın sahte bir freelist pointer oluşturmasını engeller.
- Bazı allocation'ların slab içinde yerleşimleri **rastgeleleştirilir**, bu nedenle spraying adjacency garanti etmez.

### 4. Guarded Allocations
- Bazı kritik kernel nesneleri (örn. credentials, task yapıları) **guarded zones** içinde allocate edilir.
- Bu zonlar slab'lar arasında **guard pages** (maplenmemiş bellek) veya nesneler etrafında **redzones** kullanır.
- Guard page'e yapılacak herhangi bir overflow bir fault tetikler → sessiz bozulma yerine hemen panic.

### 5. Page Protection Layer (PPL) and SPTM
- Bir freed objeyi kontrol etseniz bile, tüm kernel belleğini değiştiremezsiniz:
- **PPL (Page Protection Layer)**, belirli bölgelerin (örn. code signing verileri, entitlements) kernel’in kendisine bile **read-only** olmasını zorunlu kılar.
- **A15/M2+** cihazlarda bu rol **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)** ile değiştirilmiş/geliştirilmiştir.
- Bu donanım-uygulaması katmanlar, saldırganların tek bir heap bozulmasından kritik güvenlik yapılarını rastgele patch'lemeye yükselmesini engeller.
- **(Added / Enhanced)**: ayrıca kernel'de pointer'ları (özellikle function pointer'lar, vtable'lar) korumak için **PAC (Pointer Authentication Codes)** kullanılır; böylece onların sahteleştirilmesi veya bozulması zorlaşır.
- **(Added / Enhanced)**: zonlar **zone_require / zone enforcement** uygulayabilir; yani bir nesnenin free edildikten sonra yalnızca doğru typed zone üzerinden geri döndürülebileceği zorlanır; yanlış cross-zone free'lar panic'e neden olabilir veya reddedilebilir. (Apple bu konudan bellek güvenliği yazılarında ima eder)

### 6. Large Allocations
- Tüm allocation'lar `kalloc_type` üzerinden geçmez.
- Çok büyük talepler (yaklaşık ~16 KB üzeri) typed zone'ları atlar ve doğrudan **kernel VM (kmem)** üzerinden sayfa allocate edilerek servis edilir.
- Bunlar daha az öngörülebilir, ama aynı zamanda daha az exploitable'dır çünkü diğer nesnelerle slab paylaşmazlar.

### 7. Allocation Patterns Attackers Target
Bu korumalara rağmen saldırganlar hâlâ şunları hedefler:
- **Reference count objects**: retain/release sayaçlarına müdahale edebilirseniz use-after-free yaratabilirsiniz.
- **Objects with function pointers (vtables)**: bunları bozmak hâlâ kontrol akışı sağlayabilir.
- **Shared memory objects (IOSurface, Mach ports)**: bu nesneler user ↔ kernel köprüsü olduğu için hâlâ hedeflenir.

Ancak — öncekilerden farklı olarak — sadece `OSData` spray yapıp `task_t` ile komşu olmasını bekleyemezsiniz. Başarılı olmak için **type-specific bugs** veya **info leaks** gerekir.

### Example: Allocation Flow in Modern Heap

Kullanıcı alanı IOKit'e `OSData` nesnesi allocate etmesi için çağrı yapsın:

1. **Type lookup** → `OSData` `kalloc_type_osdata` zone'una (boyut 64 bytes) eşlenir.
2. Per-CPU cache için boş eleman kontrol edilir.
- Eğer bulunursa → bir eleman döndürülür.
- Eğer boşsa → global freelist'e gidilir.
- Eğer freelist boşsa → yeni bir slab allocate edilir (4KB sayfa → 64 adet 64 byte chunk).
3. Chunk çağırana döndürülür.

**Freelist pointer protection**:
- Her free edilmiş chunk, bir sonraki free chunk'ın adresini saklar, ama bu adres bir gizli anahtarla encode edilmiştir.
- Bu alanı saldırgan verisiyle overwrite etmek, anahtarı bilmiyorsanız işe yaramaz.

---

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages, and **PAC** protects pointers |
| Allocation reuse validation     | None (freelist pointers raw)                               | **zone_require / zone enforcement**             |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |
| Large allocations handling      | All small allocations managed equally                       | Large ones bypass zones → handled via VM         |

---

## Modern Userland Heap (iOS, macOS — type-aware / xzone malloc)

Son Apple OS sürümlerinde (özellikle iOS 17+), Apple daha güvenli bir userland allocator olan **xzone malloc** (XZM) tanıttı. Bu, kernel'deki `kalloc_type`'ın user-space eşdeğeri olup type awareness, metadata izolasyonu ve memory tagging korumaları uygular.

### Goals & Design Principles

- **Type segregation / type awareness**: tür veya kullanım (pointer vs data) bazında allocation'ları gruplayarak type confusion ve cross-type reuse'u önlemek.
- **Metadata isolation**: heap metadata'sını (örn. free list'ler, size/state bitleri) nesne payload'undan ayırmak; böylece out-of-bounds yazmaların metadata'yı bozma ihtimali azaltılır.
- **Guard pages / redzones**: allocation'lar etrafına unmapped sayfalar veya padding koyarak overflow'ları yakalamak.
- **Memory tagging (EMTE / MIE)**: donanım tagging ile birlikte çalışarak use-after-free, OOB ve geçersiz erişimleri tespit etmek.
- **Scalable performance**: düşük overhead korumak, aşırı parçalanmadan kaçınmak ve yüksek sayıda allocation için düşük gecikme sağlamak.

### Architecture & Components

Aşağıda xzone allocator'ın ana bileşenleri bulunmaktadır:

#### Segment Groups & Zones

- **Segment groups** adres uzayını kullanım kategorilerine göre böler: örn. `data`, `pointer_xzones`, `data_large`, `pointer_large`.
- Her segment group, o kategori için allocation'ları barındıran **segments** (VM aralıkları) içerir.
- Her segment ile ilişkili bir **metadata slab** (ayrı bir VM alanı) vardır; metadata (örn. free/used bitleri, size class bilgisi) burada saklanır. Bu **out-of-line (OOL) metadata**, metadata'nın nesne payload ile karışmamasını sağlar ve overflow'lardan kaynaklı bozulmaları azaltır.
- Segmentler **chunks** (dilimler) halinde bölünür; bu chunk'lar daha sonra **blocks** (allocation birimleri) olarak alt bölümlere ayrılır. Bir chunk, belirli bir size class ve segment group'a bağlıdır (yani chunk içindeki tüm block'lar aynı boyut & kategoriye sahiptir).
- Küçük/orta boy allocation'lar için sabit boyutlu chunk'lar kullanılır; büyük/çok büyük allocation'lar ayrı olarak map edilebilir.

#### Chunks & Blocks

- Bir **chunk**, genellikle birkaç sayfa olan ve bir boyut sınıfına adanmış bir bölgedir.
- Bir chunk içinde **blocks**, allocation için kullanılabilir slot'lardır. Free edilmiş block'lar metadata slab aracılığıyla izlenir — ör. bitmap'ler veya out-of-line saklanan free list'ler ile.
- Chunk'lar arasında (veya içinde) **guard slices / guard pages** (ör. unmapped dilimler) yerleştirilebilir, böylece out-of-bounds yazmalar yakalanır.

#### Type / Type ID

- Her allocation yeri (veya malloc, calloc vb. çağrısı) bir **type identifier** (`malloc_type_id_t`) ile ilişkilendirilir; bu ID, hangi tür nesnenin allocate edildiğini kodlar. Bu type ID allocator'a iletilir ve hangi zone/segment'in allocation'ı sağlayacağı seçilir.
- Bu yüzden, iki allocation aynı boyutta olsa bile türleri farklıysa tamamen farklı zone'lara gidebilir.
- iOS 17'nin erken sürümlerinde, bazı API'ler (örn. CFAllocator) tam anlamıyla type-aware değildi; Apple bu zayıflıkları iOS 18'de ele aldı.

---

### Allocation & Freeing Workflow

xzone içinde allocation ve deallocation işlemlerinin yüksek seviyeli akışı:

1. **malloc / calloc / realloc / typed alloc** bir boyut ve type ID ile çağrılır.
2. Allocator **type ID**'yi kullanarak doğru segment group / zone'u seçer.
3. O zone/segment içinde, istenen boyutta boş block'ı olan bir chunk aranır.
- Local cache'ler / per-thread pool'lar veya metadata'daki free block list'leri kontrol edilebilir.
- Eğer boş block yoksa, o zone'da yeni bir chunk allocate edilebilir.
4. Metadata slab güncellenir (free biti temizlenir, bookkeeping yapılır).
5. Eğer memory tagging (EMTE) varsa, döndürülen block'a bir **tag** atanır ve metadata onun “canlı” olduğu şeklinde güncellenir.
6. `free()` çağrıldığında:
- Block metadata'da freed olarak işaretlenir (OOL slab üzerinden).
- Block bir free list'e konulabilir veya yeniden kullanım için pool'a alınabilir.
- Opsiyonel olarak, blok içeriği veri sızıntılarını veya use-after-free exploitation'u azaltmak için temizlenebilir veya zehirlenebilir.
- Bloka atanan donanım tag'i geçersiz kılınabilir veya yeniden tag'lenebilir.
- Eğer bir chunk tamamen boşalırsa (tüm block'lar free ise), allocator bellek baskısı altında o chunk'ı **reclaim** ederek unmap edebilir veya OS'e geri verebilir.

---

### Security Features & Hardening

Modern userland xzone içinde bulunan savunmalar:

| Feature | Purpose | Notes |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | Prevent overflow from corrupting metadata | Metadata ayrı bir VM bölgesinde (metadata slab) saklanır |
| **Guard pages / unmapped slices** | Catch out-of-bounds writes | Buffer overflow'ları sessizce bitişik blokları bozmak yerine tespit etmeye yardımcı olur |
| **Type-based segregation** | Prevent cross-type reuse & type confusion | Aynı boyuttaki allocation'lar bile türleri farklıysa farklı zone'lara gider |
| **Memory Tagging (EMTE / MIE)** | Detect invalid access, stale references, OOB, UAF | xzone, donanım EMTE ile senkron modda (“Memory Integrity Enforcement”) çalışır |
| **Delayed reuse / poisoning / zap** | Reduce chance of use-after-free exploitation | Freed block'lar zehirlenebilir, sıfırlanabilir veya yeniden kullanımdan önce karantinaya alınabilir |
| **Chunk reclamation / dynamic unmapping** | Reduce memory waste and fragmentation | Tüm chunk'lar kullanılmadığında unmap edilebilir |
| **Randomization / placement variation** | Prevent deterministic adjacency | Chunk içindeki block'lar ve chunk seçimi rastgeleleştirilebilir |
| **Segregation of “data-only” allocations** | Separate allocations that don’t store pointers | Pointer içermeyen allocation'lar ayrılarak metadata veya kontrol alanları üzerinde saldırgan kontrolü azaltılır |

---

### Interaction with Memory Integrity Enforcement (MIE / EMTE)

- Apple’ın MIE (Memory Integrity Enforcement), **Enhanced Memory Tagging Extension (EMTE)**'yi ana saldırı yüzeylerinde her zaman açık, senkron modda getiren donanım + OS çerçevesidir.
- xzone allocator, user space'te MIE'nin temelini oluşturur: xzone ile yapılan allocation'lar tag alır ve erişimler donanım tarafından kontrol edilir.
- MIE içinde allocator, tag atama, metadata yönetimi ve tag gizliliği denetimi entegre edilmiştir; böylece bellek hataları (örn. stale reads, OOB, UAF) hemen yakalanır, daha sonra istismar edilmesine izin verilmez.

---

If you like, I can also generate a cheat-sheet or diagram of xzone internals for your book. Do you want me to do that next?
::contentReference[oai:20]{index=20}


---

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

BinDiff DMG'yi [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) adresinden indirip kurun.

Ghidra'yı `ghidraRun` ile açın ve `File` --> `Install Extensions`e gidin, add butonuna basın ve yolu `/Applications/BinDiff/Extra/Ghidra/BinExport` olarak seçin, OK'ye tıklayın ve versiyon uyuşmazlığı olsa bile yükleyin.

### Using BinDiff with Kernel versions

1. [https://ipsw.me/](https://ipsw.me/) sayfasına gidin ve difflemek istediğiniz iOS sürümlerini indirin. Bunlar `.ipsw` dosyaları olacaktır.
2. Her iki `.ipsw` dosyasının kernelcache'inin bin formatını elde edene kadar dekompresyon yapın. Bunu nasıl yapacağınıza dair bilgiye şu kaynaktan ulaşabilirsiniz:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. `ghidraRun` ile Ghidra'yı açın, yeni bir proje oluşturun ve kernelcache'leri yükleyin.
4. Her kernelcache'i açın, böylece Ghidra otomatik olarak analizlesin.
5. Ardından Ghidra proje penceresinde her kernelcache'e sağ tıklayın, `Export` seçin, format olarak `Binary BinExport (v2) for BinDiff` seçin ve export edin.
6. BinDiff'i açın, yeni bir workspace oluşturun ve primary file olarak vulnerability içeren kernelcache'i, secondary file olarak patched kernelcache'i belirterek yeni bir diff ekleyin.

---

## Finding the right XNU version

Belirli bir iOS sürümünde zafiyet kontrolü yapmak istiyorsanız, o iOS sürümünün hangi XNU release versiyonunu kullandığını şu adresten kontrol edebilirsiniz: [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

Örneğin, `15.1 RC`, `15.1` ve `15.1.1` sürümleri `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006` sürümünü kullanır.

### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
