# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

### 1. **Code Signing** / Runtime Signature Verification
**Introduced early (iPhone OS → iOS)**
Bu, temel korumalardan biridir: **tüm yürütülebilir kod** (apps, dynamic libraries, JIT-ed code, extensions, frameworks, caches) Apple’ın güvenine dayanan bir sertifika zinciriyle kriptografik olarak imzalanmış olmalıdır. Runtime’da, bir ikiliyi belleğe yüklemeden önce (veya belirli sınırlar arasında atlamalar yapmadan önce) sistem imzayı kontrol eder. Kod değiştirilmiş (bit-flip, patch) veya imzasız ise yükleme başarısız olur.

- **Engeller**: exploit zincirlerinde “klasik payload drop + execute” aşamasını; arbitrary code injection; mevcut bir ikiliyi kötü amaçlı mantık eklemek için değiştirmeyi.
- **Mekanizma detayı**:
* Mach-O loader (ve dynamic linker) kod sayfalarını, segmentleri, entitlements, team ID’leri ve imzanın dosya içeriğini kapsadığını kontrol eder.
* JIT cache’leri veya dinamik üretilen kod gibi bellek bölgeleri için Apple, sayfaların imzalanmasını ya da özel API’ler üzerinden doğrulanmasını zorunlu kılar (ör. `mprotect` ile code-sign kontrolleri).
* İmza entitlements ve identifier’ları içerir; OS belirli API’lerin veya ayrıcalıklı yeteneklerin özel entitlements gerektirdiğini ve bunların taklit edilemeyeceğini uygular.

<details>
<summary>Example</summary>
Bir exploit bir süreçte code execution elde edip shellcode’u heap’e yazıp oraya atlamayı denerse: iOS’ta o sayfanın executable olarak işaretlenmesi ve code-signature kısıtlarını karşılaması gerekir. Shellcode Apple’ın sertifikasıyla imzalanmadığı için atlama başarısız olur veya sistem o bellek bölgesini executable yapmayı reddeder.
</details>


### 2. **CoreTrust**
**Introduced around iOS 14+ era (or gradually in newer devices / later iOS)**
CoreTrust, ikililerin runtime signature validation’ını yapan alt sistemdir (system ve user binaries dahil) ve cached userland trust store yerine **Apple’ın root certificate**’ına karşı doğrulama yapar.

- **Engeller**: kurulum sonrası ikililerin tahrifini, SpringBoard veya system kütüphanelerini swap/patch etmeye çalışan jailbreaking tekniklerini; trusted ikililerin kötü amaçlı muadilleriyle değiştirilmesini.
- **Mekanizma detayı**:
* Yerel bir trust database veya sertifika önbelleğine güvenmek yerine CoreTrust doğrudan Apple’ın root’una referans verir veya güvenli bir zincirde intermediate sertifikaları doğrular.
* Dosya sistemindeki mevcut ikililerdeki değişikliklerin (ör. filesystem değişiklikleri) tespit edilmesini ve reddedilmesini sağlar.
* Entitlements, team ID’ler, code signing flag’leri ve diğer metadata’yı yükleme zamanında binary’ye bağlar.

<details>
<summary>Example</summary>
Bir jailbreak `SpringBoard` veya `libsystem` gibi ikilileri patched bir sürümle değiştirip persistence sağlamaya çalışabilir. Ancak OS loader veya CoreTrust kontrol ettiğinde imza uyuşmazlığını (veya değiştirilmiş entitlements’ı) fark eder ve yürütmeyi reddeder.
</details>


### 3. **Data Execution Prevention (DEP / NX / W^X)**
**Introduced in many OSes earlier; iOS had NX-bit / w^x for a long time**
DEP, writable (data) olarak işaretlenmiş sayfaların **non-executable**, executable olarak işaretlenmiş sayfaların ise **non-writable** olmasını zorunlu kılar. Basitçe heap veya stack bölgesine shellcode yazıp çalıştıramazsınız.

- **Engeller**: doğrudan shellcode execution; klasik buffer-overflow → injected shellcode’a atlama.
- **Mekanizma detayı**:
* MMU / memory protection flag’leri (page table’lar aracılığıyla) ayrımı zorunlu kılar.
* Writable bir sayfayı executable yapma girişimi sistem kontrolünü tetikler (veya yasaklanır ya da code-sign onayı gerektirir).
* Birçok durumda sayfaları executable yapmak OS API’leri üzerinden ve ek kısıtlamalar ya da kontrollerle yapılmalıdır.

<details>
<summary>Example</summary>
Bir overflow shellcode’u heap’e yazar. Saldırgan `mprotect(heap_addr, size, PROT_EXEC)` yapmaya çalışır. Ancak sistem reddeder veya yeni sayfanın code-sign kısıtlarını geçtiğini doğrulamayı ister (ki shellcode bunu sağlayamaz).
</details>

### 4. **Address Space Layout Randomization (ASLR)**
**Introduced in iOS ~4–5 era (roughly iOS 4–5 timeframe)**
ASLR, kütüphaneler, heap, stack vb. ana bellek bölgelerinin base adreslerini her process başlatılışında rastgeleleştirir. Gadget adresleri çalıştırmalar arasında değişir.

- **Engeller**: ROP/JOP için gadget adreslerini hardcode etmeyi; statik exploit zincirlerini; bilinen offset’lere kör atlamayı.
- **Mekanizma detayı**:
* Her yüklenen library / dynamic module rastgele bir offset’te rebase edilir.
* Stack ve heap base pointer’ları (belirli entropi sınırları içinde) rastgeleleştirilir.
* Bazen diğer bölgeler (ör. mmap allocations) de rastgeleleştirilir.
* Bilgi-disclosure mitigasyonlarıyla birleştiğinde, saldırganın önce runtime’da base adresleri keşfetmek için bir address veya pointer leak etmesini zorunlu kılar.

<details>
<summary>Example</summary>
Bir ROP zinciri `0x….lib + offset` üzerindeki gadget’ı bekler. Ancak `lib` her çalıştırmada farklı şekilde relocate edildiği için hardcoded zincir başarısız olur. Bir exploit, gadget adreslerini hesaplamak için önce modülün base adresini leak etmelidir.
</details>


### 5. **Kernel Address Space Layout Randomization (KASLR)**
**Introduced in iOS ~ (iOS 5 / iOS 6 timeframe)**
User ASLR’ye analojik olarak, KASLR kernel text’in ve diğer kernel yapıların base’ini boot sırasında rastgeleleştirir.

- **Engeller**: kernel düzeyinde sabit kernel kodu veya veri lokasyonlarına dayanan exploitleri; statik kernel exploitlerini.
- **Mekanizma detayı**:
* Her boot’ta kernel base adresi (belirli bir aralık içinde) rastgeleleştirilir.
* Kernel data yapıları (ör. `task_structs`, `vm_map` vb.) da taşınabilir veya offset’lenmiş olabilir.
* Saldırganlar kernel pointer’ları leak etmek veya bilgi disclosure zaafiyeti kullanmak zorundadırlar, ardından kernel yapıları veya kod üzerinde hijack yapmadan önce offset’leri hesaplarlar.

<details>
<summary>Example</summary>
Bir local vulnerability kernel function pointer’ını (`vtable` içindeki gibi) `KERN_BASE + offset` adresinde bozmayı hedefler. Ancak `KERN_BASE` bilinmediği için saldırgan önce bir read primitive ile leak etmek zorundadır ki doğru adresi hesaplayıp bozulmayı gerçekleştirebilsin.
</details>


### 6. **Kernel Patch Protection (KPP / AMCC)**
**Introduced in newer iOS / A-series hardware (post around iOS 15–16 era or newer chips)**
KPP (aka AMCC) kernel text sayfalarının bütünlüğünü (hash veya checksum ile) sürekli izler. Eğer beklenmeyen bir tahrifat (patch, inline hook, code modification) tespit ederse kernel panic veya reboot tetikler.

- **Engeller**: kalıcı kernel patching (kernel instructions’ı değiştirme), inline hook’lar, statik function overwrite’lar.
- **Mekanizma detayı**:
* Bir donanım veya firmware modülü kernel text bölgesini izler.
* Periyodik veya talebe bağlı olarak sayfaları tekrar hash’ler ve beklenen değerlerle karşılaştırır.
* Eğer uyumsuzluklar benign update pencereleri dışında meydana gelirse cihaz panic yapar (kalıcı kötü niyetli patch’i önlemek için).
* Saldırganlar ya tespit pencerelerini kaçınmalı ya da meşru patch yollarını kullanmalıdır.

<details>
<summary>Example</summary>
Bir exploit kernel fonksiyon prologunu (ör. `memcmp`) patchlemeye çalışır. Ancak KPP, kod sayfasının hash’i artık beklenenle uyuşmadığını fark eder ve kernel panic tetikleyerek cihazı patch stabil hale gelmeden crash eder.
</details>


### 7. **Kernel Text Read‐Only Region (KTRR)**
**Introduced in modern SoCs (post ~A12 / newer hardware)**
KTRR, donanım tarafından zorlanan bir mekanizmadır: boot sırasında kernel text kilitlendiğinde, EL1 (kernel) seviyesinden bu sayfalar yazılmaz hale gelir ve kod sayfalarına sonradan yazma engellenir.

- **Engeller**: boot sonrası kernel koduna yapılacak her türlü değişiklik (ör. patching, in-place code injection) EL1 ayrıcalık seviyesiyle yapılamaz.
- **Mekanizma detayı**:
* Boot sırasında (secure/bootloader aşamasında) memory controller veya güvenli bir donanım birimi kernel text içeren fiziksel sayfaları read-only olarak işaretler.
* Bir exploit tam kernel ayrıcalığı elde etse bile bu sayfalara yazarak instruksyonları değiştiremez.
* Bu sayfaları değiştirmek için saldırgan önce boot zincirini ihlal etmeli veya KTRR’i alt etmeli.

<details>
<summary>Example</summary>
Bir privilege-escalation exploit EL1’e atlayıp kernel fonksiyonuna (ör. syscall handler) bir trampoline yazmaya çalışır. Ancak KTRR sayfaları read-only olarak kilitlediği için yazma başarısız olur (veya fault tetikler) ve patch uygulanmaz.
</details>


### 8. **Pointer Authentication Codes (PAC)**
**Introduced with ARMv8.3 (hardware), Apple beginning with A12 / iOS ~12+**
- PAC, pointer değerlerinin (return address’ler, function pointer’lar, bazı data pointer’lar) tahrifini tespit etmek için pointer’ların kullanılmayan üst bitlerine küçük bir kriptografik imza (bir “MAC”) yerleştirerek çalışan bir donanım özelliğidir.
- İmza (“PAC”), pointer değeri ile birlikte bir **modifier** (bağlam değeri, ör. stack pointer ya da ayırt edici bazı veri) üzerinde hesaplanır. Böylece aynı pointer değeri farklı bağlamlarda farklı PAC üretir.
- Kullanım zamanında, pointer ile referanslama veya dallanma yapılmadan önce bir **authenticate** instruction PAC’ı doğrular. Eğer geçerliyse PAC kaldırılır ve masum pointer elde edilir; geçersizse pointer “poisoned” olur (veya fault oluşur).
- PAC üretimi/doğrulaması için kullanılan anahtarlar ayrıcalıklı register’larda (EL1, kernel) saklanır ve user moddan doğrudan okunamaz.
- Birçok sistemde 64-bit pointer’ların tüm bitleri kullanılmadığı için (ör. 48-bit adres uzayı), üst bitler PAC için “boş” olarak kullanılabilir.

#### Architectural Basis & Key Types

- ARMv8.3, pointer authentication için **beş 128-bit anahtar** tanıtır (her biri iki 64-bit sistem register’ı ile uygulanmış).
- **APIAKey** — instruction pointer’lar için (domain “I”, key A)
- **APIBKey** — ikinci instruction pointer anahtarı (domain “I”, key B)
- **APDAKey** — data pointer’lar için (domain “D”, key A)
- **APDBKey** — data pointer’lar için (domain “D”, key B)
- **APGAKey** — “generic” anahtar, non-pointer veri veya diğer genel kullanımlar için

- Bu anahtarlar ayrıcalıklı sistem register’larında saklanır (yalnızca EL1/EL2 vb. erişilebilir), user moddan erişilemez.
- PAC, ARM tarafından önerilen QARMA gibi bir algoritma üzerinden hesaplanır ve şu girdileri kullanır:
1. Pointer değeri (canonical portion)
2. Bir **modifier** (bağlam değeri, ör. salt)
3. Gizli anahtar
4. Bazı iç tweak mantığı
Elde edilen PAC, pointer’ın üst bitlerine yazılmışsa authentication başarılı olur.

#### Instruction Families

Adlandırma kuralı: **PAC** / **AUT** / **XPAC**, ardından domain harfleri.
- `PACxx` instruction’ları bir pointer’ı **sign** eder ve PAC ekler
- `AUTxx` instruction’ları **authenticate + strip** yapar (doğrulayıp PAC’ı kaldırır)
- `XPACxx` instruction’ları doğrulamadan sadece **strip** eder

Domains / suffix’ler:

| Mnemonic     | Meaning / Domain                      | Key / Domain     | Example Usage in Assembly |
|--------------|-----------------------------------------|--------------------|-----------------------------|
| **PACIA**    | Sign instruction pointer with APIAKey   | “I, A”             | `PACIA X0, X1` — sign pointer in X0 using APIAKey with modifier X1|
| **PACIB**    | Sign instruction pointer with APIBKey   | “I, B”             | `PACIB X2, X3`              |
| **PACDA**    | Sign data pointer with APDAKey           | “D, A”             | `PACDA X4, X5`              |
| **PACDB**    | Sign data pointer with APDBKey           | “D, B”             | `PACDB X6, X7`              |
| **PACG / PACGA** | Generic (non-pointer) signing with APGAKey | “G”         | `PACGA X8, X9, X10` (sign X9 with modifier X10 into X8) |
| **AUTIA**    | Authenticate APIA-signed instruction pointer & strip PAC | “I, A” | `AUTIA X0, X1` — check PAC on X0 using modifier X1, then strip |
| **AUTIB**    | Authenticate APIB domain                 | “I, B”             | `AUTIB X2, X3`               |
| **AUTDA**    | Authenticate APDA-signed data pointer    | “D, A”             | `AUTDA X4, X5`               |
| **AUTDB**    | Authenticate APDB-signed data pointer    | “D, B”             | `AUTDB X6, X7`               |
| **AUTGA**    | Authenticate generic / blob (APGA)        | “G”               | `AUTGA X8, X9, X10` (validate generic) |
| **XPACI**     | Strip PAC (instruction pointer, no validation) | “I”         | `XPACI X0` — remove PAC from X0 (instruction domain) |
| **XPACD**     | Strip PAC (data pointer, no validation)    | “D”             | `XPACD X4` — remove PAC from data pointer in X4 |

Bazı özel / alias formları da vardır:

- `PACIASP` `PACIA X30, SP` için kısaltmadır (link register’ı SP ile modifier olarak imzala)
- `AUTIASP` `AUTIA X30, SP`’dir (link register’ı SP ile authenticate et)
- `RETAA`, `RETAB` (authenticate-and-return) veya `BLRAA` (authenticate & branch) gibi birleşik formlar ARM uzantılarında / compiler desteğinde mevcuttur.
- Ayrıca modifier’ın sıfır olduğu varyantlar: `PACIZA` / `PACIZB` gibi (modifier implicitly zero) gibi formlar vardır.

#### Modifiers

Modifier’ın asıl amacı PAC’ı belirli bir bağlama bağlamaktır; böylece aynı adres farklı bağlamlarda yeniden kullanılamaz. Bir hash’e salt eklemek gibidir.

Buna göre:
- **Modifier** bir bağlam değeri (başka bir register) olup PAC hesaplamasına karıştırılır. Tipik seçimler: stack pointer (`SP`), frame pointer veya bir object ID.
- SP’i modifier olarak kullanmak return address signing için yaygındır: PAC belirli stack frame’e bağlanır. LR’ı farklı bir frame’de yeniden kullanmaya çalışırsanız modifier değişir ve PAC doğrulaması başarısız olur.
- Aynı pointer değeri farklı modifier’lar altında imzalandığında farklı PAC’lar üretir.
- Modifier gizli olmak zorunda değildir, fakat idealde saldırgan tarafından kontrol edilmemelidir.
- Anlamlı bir modifier’in olmadığı durumlarda bazı formlar zero veya implicit constant kullanır.

#### Apple / iOS / XNU Customizations & Observations

- Apple’ın PAC uygulaması **per-boot diversifier** içerir; böylece anahtarlar veya tweak’ler her boot’ta değişir ve boot’lar arası yeniden kullanımı engeller.
- Ayrıca **cross-domain mitigations** içerir; user modda imzalanmış PAC’ların kernel modda kolayca yeniden kullanılmasını zorlaştırır.
- Apple M1 / Apple Silicon’da tersine mühendislik, **dokuz modifier tipi** ve anahtar kontrolü için Apple-özgü sistem register’larının olduğunu gösterdi.
- Apple PAC’ı birçok kernel alt sisteminde kullanır: return address signing, kernel data içindeki pointer bütünlüğü, signed thread context’ler vb.
- Google Project Zero, güçlü bir kernel read/write primitive altında kernel PAC’ları (A anahtarları için) sahtelemenin mümkün olduğunu gösterdi (A12-era cihazlarda), ancak Apple birçok yolu kapattı.
- Apple’ın sisteminde bazı anahtarlar **kernel genelinde** iken user process’ler per-process key randomness alabilir.

#### PAC Bypasses

1. **Kernel-mode PAC: theoretical vs real bypasses**

-   Kernel PAC anahtarları ve mantığı sıkı kontrol edildiği için (ayrıcalıklı register’lar, diversifier’lar, domain izolasyonu), arbitrary signed kernel pointer üretmek çok zordur.
-   Azad’ın 2020 “iOS Kernel PAC, One Year Later” raporu iOS 12-13’te birkaç kısmi bypass (signing gadgets, reuse of signed states, unprotected indirect branches) bulduğunu, ancak tam genel bir bypass bulamadığını rapor eder. [bazad.github.io](https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf)
-   Apple’ın “Dark Magic” özelleştirmeleri exploitable yüzeyleri daralttı (domain switching, per-key enabling bits). [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Apple silicon (M1/M2) için bilinen bir **kernel PAC bypass CVE-2023-32424** Zecao Cai ve ekip tarafından raporlandı. [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Ancak bu bypass’lar genellikle çok spesifik gadget’lara veya implementasyon hatalarına dayanır; genel amaçlı değildir.

Bu yüzden kernel PAC **yüksek derecede sağlam** kabul edilir, ancak mükemmel değildir.

2. **User-mode / runtime PAC bypass techniques**

Bunlar daha yaygın olup PAC’ın runtime/dynamic linking uygulamasındaki eksiklikleri hedef alır. Aşağıda sınıflar ve örnekleri var.

2.1 **Shared Cache / A key issues**

-   **dyld shared cache** büyük, önceden linklenmiş bir sistem frameworkleri ve kütüphanelerinin blob’udur. Çok yaygın paylaşıldığı için shared cache içindeki function pointer’lar zaten “pre-signed” olabilir ve birçok process tarafından kullanılır. Saldırganlar bu zaten-signed pointer’ları “PAC oracle” olarak hedefler.
-   Bazı bypass teknikleri, shared cache’te bulunan A-key ile imzalanmış pointer’ları çıkarmaya veya yeniden kullanmaya çalışır.
-   "No Clicks Required" sunumu shared cache üzerinde bir oracle kurup relative adresleri çıkarmak ve imzalanmış pointer’larla birleştirmekten bahseder. [saelo.github.io](https://saelo.github.io/presentations/offensivecon_20_no_clicks.pdf)
-   Ayrıca userspace’de shared library’lerden import edilen function pointer’ların PAC ile yetersiz korunmuş olduğu ve saldırganın imzayı değiştirmeden pointer’ı almasına izin verdiği vakalar bulundu. (Project Zero bug entry) [bugs.chromium.org](https://bugs.chromium.org/p/project-zero/issues/detail?id=2044&utm_source=chatgpt.com)

2.2 **dlsym(3) / dynamic symbol resolution**

-   Bilinen bypass’lardan biri `dlsym()` çağırarak zaten imzalanmış bir function pointer almak ve bunu kullanmaktır (A-key ile, diversifier zero ile imzalanmış olabilir). Çünkü `dlsym` meşru şekilde imzalanmış bir pointer döndürdüğünden, bunu kullanmak PAC sahtelemeye ihtiyaç duymaz.
-   Epsilon’ın blog’u bazı bypass’ların bunu nasıl kullandığını detaylandırır: `dlsym("someSym")` imzalanmış bir pointer döndürebilir ve indirect call’larda kullanılabilir. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)
-   Synacktiv’in "iOS 18.4 --- dlsym considered harmful" yazısı bir bug tanımlar: iOS 18.4’te `dlsym` tarafından çözümlenen bazı semboller yanlış imzalanmış pointer’lar döndürüyor (veya buggy diversifier’larla), bu da beklenmeyen PAC bypass’a yol açıyor. [Synacktiv](https://www.synacktiv.com/en/publications/ios-184-dlsym-considered-harmful)
-   dyld içindeki logic: `result->isCode` olduğunda döndürülen pointer’ı `__builtin_ptrauth_sign_unauthenticated(..., key_asia, 0)` ile sign eder (yani context zero). [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

Dolayısıyla, `dlsym` user-mode PAC bypass’larında sık kullanılan bir vektördür.

2.3 **Other DYLD / runtime relocations**

-   DYLD loader ve dynamic relocation logic’i karmaşıktır ve bazen relocasyon yapmak için sayfaları geçici olarak read/write olarak map eder, sonra tekrar read-only yapar. Saldırganlar bu pencereyi kullanır. Synacktiv’in sunumu "Operation Triangulation" adlı bir zamanlama tabanlı PAC bypass’ından bahseder (dynamic relocations yoluyla). [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)
-   DYLD sayfaları artık SPRR / VM_FLAGS_TPRO gibi korumalarla korunuyor. Ancak önceki sürümlerde daha zayıf korumalar vardı. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)
-   WebKit exploit zincirlerinde DYLD loader sıklıkla PAC bypass hedefi olmuştur. Sunumlar birçok PAC bypass’ın DYLD loader’ı (relocation, interposer hooks yoluyla) hedeflediğini belirtiyor. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

2.4 **NSPredicate / NSExpression / ObjC / SLOP**

-   Userland exploit zincirlerinde Objective-C runtime metotları (ör. `NSPredicate`, `NSExpression`, `NSInvocation`) control call’ları gizlice taşımak için kullanılır.
-   PAC öncesi eski iOS’larda bir exploit fake `NSInvocation` objeleriyle arbitrary selector’ları çağırabiliyordu. PAC ile birlikte teknikler uyarlanmak zorunda kaldı. SLOP (SeLector Oriented Programming) tekniği PAC altında da genişletildi. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)
-   Orijinal SLOP tekniği sahte invokation’lar oluşturarak ObjC çağrı zincirleri yapabiliyordu; bypass, ISA veya selector pointer’larının bazen tam olarak PAC ile korunmamasına dayanıyordu. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)
-   Pointer authentication kısmen uygulandığı ortamlarda, method/selector/target pointer’lar her zaman PAC ile korunmayabilir; bu da bypass için alan bırakır.

#### Example Flow

<details>
<summary>Example Signing & Authenticating</summary>
```
; Example: function prologue / return address protection
my_func:
stp x29, x30, [sp, #-0x20]!        ; push frame pointer + LR
mov x29, sp
PACIASP                            ; sign LR (x30) using SP as modifier
; … body …
mov sp, x29
ldp x29, x30, [sp], #0x20         ; restore
AUTIASP                            ; authenticate & strip PAC
ret

; Example: indirect function pointer stored in a struct
; suppose X1 contains a function pointer
PACDA X1, X2     ; sign data pointer X1 with context X2
STR X1, [X0]      ; store signed pointer

; later retrieval:
LDR X1, [X0]
AUTDA X1, X2       ; authenticate & strip
BLR X1             ; branch to valid target

; Example: stripping for comparison (unsafe)
LDR X1, [X0]
XPACI X1           ; strip PAC (instruction domain)
CMP X1, #some_label_address
BEQ matched_label
```
</details>

<details>
<summary>Example</summary>
A buffer overflow yığıttaki (stack) return address'i üzerine yazar. Saldırgan hedef gadget adresini yazar ama doğru PAC'i hesaplayamaz. Fonksiyon döndüğünde CPU’nun `AUTIA` talimatı PAC uyuşmazlığı nedeniyle hata verir. Zincir başarısız olur.
Project Zero’nun A12 (iPhone XS) üzerine analizi, Apple’ın PAC’ını nasıl kullandığını ve bir saldırganın bellek okuma/yazma primitive’ine sahip olması durumunda PAC’leri nasıl sahteleyeceğine dair yöntemleri gösterdi.
</details>


### 9. **Branch Target Identification (BTI)**
**ARMv8.5 (daha yeni donanım) ile tanıtıldı**
BTI, **indirect branch targets**'ı kontrol eden bir donanım özelliğidir: `blr` veya dolaylı call/jump’ler çalıştırıldığında hedef, bir **BTI landing pad** (`BTI j` veya `BTI c`) ile başlamalıdır. Landing pad içermeyen gadget adreslerine atlama bir istisna (exception) tetikler.

LLVM’nin uygulaması, BTI talimatlarının üç varyantını ve bunların branch türlerine nasıl eşlendiğini not eder.

| BTI Variant | What it permits (which branch types) | Typical placement / use case |
|-------------|----------------------------------------|-------------------------------|
| **BTI C** | Targets of *call*-style indirect branches (e.g. `BLR`, or `BR` using X16/X17) | Dolaylı olarak çağrılabilecek fonksiyonların girişine konur |
| **BTI J** | Targets of *jump*-style branches (e.g. `BR` used for tail calls) | jump tabloları veya tail-call’larla ulaşılabilen blokların başına konur |
| **BTI JC** | Acts as both C and J | Hem call hem de jump branch’leri tarafından hedeflenebilir |

- branch target enforcement ile derlenen kodda, derleyiciler geçerli her dolaylı-branch hedefine (fonksiyon başlangıçları veya jump ile ulaşılabilen bloklar) bir BTI talimatı (C, J veya JC) ekler, böylece dolaylı branch’ler yalnızca bu yerlere başarılı olur.
- **Direct branches / calls** (yani sabit-adres `B`, `BL`) BTI tarafından **kısıtlanmaz**. Varsayım, kod sayfalarının güvenilir olduğu ve saldırganın onları değiştiremeyeceği yönündedir (dolayısıyla doğrudan branch’ler güvenlidir).
- Ayrıca, **RET / return** talimatları genellikle BTI ile kısıtlanmaz çünkü return adresleri PAC veya return signing mekanizmalarıyla korunur.

#### Mekanizma ve uygulama

- CPU, “guarded / BTI-enabled” olarak işaretlenmiş bir sayfadaki bir **indirect branch (BLR / BR)** decode ettiğinde, hedef adresin ilk talimatının geçerli bir BTI (izin verilen C, J veya JC) olup olmadığını kontrol eder. Değilse, bir **Branch Target Exception** oluşur.
- BTI talimat kodlaması, daha önce NOP’lar için ayrılmış opcode’ları yeniden kullanacak şekilde tasarlanmıştır (önceki ARM sürümlerinde). Bu yüzden BTI-etkin ikili dosyalar geriye dönük uyumludur: BTI desteği olmayan donanımda bu talimatlar NOP olarak davranır.
- BTI ekleyen derleyici aşamaları, onları sadece gerektiği yerlere ekler: dolaylı çağrılabilecek fonksiyonlar veya jump’larla hedeflenen basic block’lar.
- Bazı yamalar ve LLVM kodu BTI’nin *tüm* basic block’lara eklenmediğini — sadece potansiyel branch hedeflerine (örn. switch / jump tablolarından gelenler) eklendiğini gösterir.

#### BTI + PAC sinerjisi

PAC işaretçi değerini (kaynağı) korur — dolaylı çağrı/return zincirinin değiştirilmediğini garanti eder.

BTI ise, geçerli bir işaretçinin bile yalnızca uygun şekilde işaretlenmiş giriş noktalarını hedefleyebileceğini sağlar.

Birlikte düşünüldüğünde, bir saldırganın hem doğru PAC’e sahip geçerli bir işaretçiye hem de hedefin oraya BTI yerleştirilmiş olmasına ihtiyacı vardır. Bu, exploit gadget’ları oluşturmayı zorlaştırır.

#### Example


<details>
<summary>Example</summary>
Bir exploit, `0xABCDEF` adresindeki ve `BTI c` ile başlamayan bir gadget’a pivot yapmayı dener. CPU `blr x0` çalıştırıldığında hedefi kontrol eder ve geçerli bir landing pad içermediği için hata verir. Bu nedenle birçok gadget, BTI öneki içermedikçe kullanılamaz hale gelir.
</details>


### 10. **Privileged Access Never (PAN) & Privileged Execute Never (PXN)**
**Daha yeni ARMv8 uzantılarında / iOS desteğinde (sertleştirilmiş kernel için) tanıtıldı**

#### PAN (Privileged Access Never)

- **PAN**, **ARMv8.1-A**’da tanıtılan bir özellik olup, **privileged code** (EL1 veya EL2) tarafından **user-accessible (EL0)** olarak işaretlenmiş belleğin **okunmasını veya yazılmasını** engeller; PAN açıkça devre dışı bırakılmadıkça.
- Fikir: kernel kandırılsa veya ele geçirilmiş olsa bile, önce PAN’i *clear* etmeden user-space pointer’larını keyfi olarak dereference edemez; böylece **`ret2usr`** tarzı exploit’ler veya kullanıcı kontrollü buffer’ların kötüye kullanımı riski azalır.
- PAN etkin olduğunda (PSTATE.PAN = 1), “EL0’de erişilebilir” olarak kabul edilen bir virtual adrese erişen herhangi bir privileged load/store talimatı **permission fault** tetikler.
- Kernel, meşru olarak user-space belleğe erişmesi gerektiğinde (örn. user buffer’lara veri kopyalama), bu erişime izin vermek için **geçici olarak PAN’i devre dışı bırakmalı** (ya da “unprivileged load/store” talimatlarına geçmelidir).
- ARM64 üzerinde Linux’ta PAN desteği yaklaşık 2015 civarında eklendi: kernel yamaları özelliğin tespiti ekledi ve `get_user` / `put_user` gibi fonksiyonları user bellek erişimleri etrafında PAN’i temizleyen varyantlarla değiştirdi.

**Önemli nüans / sınırlama / hata**
- Siguza ve diğerlerinin belirttiği gibi, ARM tasarımındaki bir spesifikasyon hatası (veya belirsiz davranış), execute-only user mapping’lerinin (`--x`) PAN’i tetiklemeyebileceği anlamına gelir. Başka bir deyişle, eğer bir user sayfa executable olarak işaretlenmiş ama okuma izni yoksa, kernel’in okuma denemesi PAN’i atlayabilir çünkü mimari “EL0’de erişilebilir”i yalnızca okunabilir izinle ilişkilendirebilir, sadece executable ile değil. Bu, bazı konfigürasyonlarda PAN atlatmasına yol açar.
- Bu yüzden, eğer iOS / XNU execute-only user sayfalarına izin veriyorsa (bazı JIT veya code-cache yapılandırmalarında olduğu gibi), kernel PAN etkin olsa bile bu sayfalardan kazara okuyabilir. Bu, bazı ARMv8+ sistemlerinde bilinen ve ince bir şekilde exploitable bir alandır.

#### PXN (Privileged eXecute Never)

- **PXN**, sayfa tablosu girdilerinde (leaf veya block girdilerde) bulunan bir bit olup, sayfanın **privileged modda yürütüldüğünde yürütülemez** olduğunu gösterir (yani EL1 onu yürütürken).
- PXN, kernel’in (veya herhangi bir privileged code’un) kontrol akışı yöneldiğinde bile user-space sayfalarına atlamasını veya buralardaki talimatları yürütmesini engeller. Etkisi olarak, kernel seviyesindeki kontrol akışı yönlendirmelerini kullanıcı belleğine doğru durdurur.
- PAN ile birleştirildiğinde şu garantiler sağlanır:
1. Kernel varsayılan olarak user-space verisini okuyamaz veya yazamaz (PAN)
2. Kernel user-space kodunu yürütemez (PXN)
- ARMv8 sayfa tablosu formatında, leaf girdilerinin attribute bitlerinde bir `PXN` biti (ve unprivileged execute-never için `UXN`) bulunur.

Dolayısıyla kernel’in user belleğe işaret eden bozulmuş bir function pointer’ı olsa ve oraya branch etmeye çalışsa bile, PXN biti bir fault oluşturur.

#### Bellek-izin modeli & PAN ile PXN’in sayfa tablosu bitlerine eşlenmesi

PAN / PXN’in nasıl çalıştığını anlamak için ARM’ın çeviri ve izin modelinin nasıl çalıştığını görmeniz gerekir (basitleştirilmiş):

- Her sayfa veya block girdisi, erişim izinleri (okuma/yazma, privileged vs unprivileged) için **AP[2:1]** ve execute-never kısıtlamaları için **UXN / PXN** bitleri gibi attribute alanlarına sahiptir.
- PSTATE.PAN 1 (etkin) olduğunda, donanım değiştirilmiş semantikleri uygular: 'EL0 tarafından erişilebilir' olarak işaretlenmiş sayfalara yapılan privileged erişimler reddedilir (fault).
- Bahsedilen hata nedeniyle, sadece executable (okuma izni olmayan) olarak işaretlenmiş sayfalar bazı uygulamalarda 'EL0 tarafından erişilebilir' sayılmayabilir ve böylece PAN atlatılabilir.
- Bir sayfanın PXN biti set edilmişse, talimat getirme (instruction fetch) daha yüksek bir yetki seviyesinden gelse bile yürütme yasaklanır.

#### Sertleştirilmiş bir OS’te (örn. iOS / XNU) kernel tarafından PAN / PXN kullanımı

- Kernel varsayılan olarak PAN’i etkinleştirir (böylece privileged code kısıtlanır).
- Gerçekten user buffer’larını okumaya/yazmaya ihtiyaç duyan yollarda (örn. syscall buffer kopyası, I/O, read/write user pointer), kernel geçici olarak **PAN’i devre dışı bırakır** veya geçersiz kılmak için özel talimatlar kullanır.
- User veri erişimini bitirdikten sonra PAN’i yeniden etkinleştirmelidir.
- PXN sayfa tabloları yoluyla uygulanır: user sayfaların PXN = 1 olur (böylece kernel bunları yürütemez), kernel sayfalarının PXN’i yoktur (böylece kernel kodu yürütülebilir).
- Kernel, hiçbir kod yolunun yürütme akışını user bellek bölgelerine yönlendirmesine (PXN’i atlatabilecek) izin vermemelidir — bu yüzden “jump into user-controlled shellcode”a dayanan exploit zincirleri engellenir.

Execute-only sayfalar üzerinden belirtilen PAN atlatması nedeniyle, gerçek bir sistemde Apple execute-only user sayfalarını devre dışı bırakabilir veya spesifikasyon zayıflığı etrafında yamalar uygulayabilir.

#### Saldırı yüzeyleri, atlatmalar ve hafifletmeler

- Execute-only sayfalar üzerinden PAN atlatması: tartışıldığı gibi, spesifikasyon bir boşluk bırakıyor: execute-only (okuma izni olmayan) user sayfalar bazı uygulamalarda 'EL0’de erişilebilir' sayılmayabilir, dolayısıyla PAN bu sayfalardan kernel okumalarını engellemez. Bu, saldırgana 'execute-only' bölümler aracılığıyla veri beslemek için alışılmadık bir yol sağlar.
- Zamanlama penceresi exploit’i: kernel PAN’i gerekli olandan daha uzun süre devre dışı bırakırsa, bir yarış durumu veya kötü niyetli yol o pencereyi kullanarak istenmeyen user bellek erişimi yapabilir.
- Yeniden etkinleştirmeyi unutma: eğer kod yolları PAN’i yeniden etkinleştiremezse, sonraki kernel işlemleri user belleğe yanlışlıkla erişebilir.
- PXN’nin yanlış yapılandırılması: eğer sayfa tabloları user sayfalarda PXN’i ayarlamaz veya user kod sayfalarını yanlış maplerse, kernel user-space kodunu yürütmeye kandırılabilir.
- Spekülasyon / yan-kanallar: spekülatif atlatmalara benzer şekilde, PAN / PXN kontrollerinin geçici olarak ihlaline neden olan mikro-mimari yan etkiler olabilir (ancak bu tür saldırılar CPU tasarımına yüksek derecede bağlıdır).
- Karmaşık etkileşimler: daha gelişmiş özelliklerde (örn. JIT, shared memory, just-in-time kod bölgeleri), kernel belirli bellek erişimlerine veya user-mapped bölgelerde yürütmeye izin vermek için ince kontrollere ihtiyaç duyabilir; bunları PAN/PXN kısıtları altında güvenli şekilde tasarlamak basit değildir.

#### Example

<details>
<summary>Code Example</summary>
Burada user bellek erişimi etrafında PAN’in etkinleştirilmesi/devre dışı bırakılmasını gösteren ve bir fault’un nasıl oluşabileceğini gösteren örnek pseudo-assembly dizileri bulunmaktadır.
</details>
```  
// Suppose kernel entry point, PAN is enabled (privileged code cannot access user memory by default)

; Kernel receives a syscall with user pointer in X0
; wants to read an integer from user space
mov   X1, X0        ; X1 = user pointer

; disable PAN to allow privileged access to user memory
MSR   PSTATE.PAN, #0   ; clear PAN bit, disabling the restriction

ldr   W2, [X1]       ; now allowed load from user address

; re-enable PAN before doing other kernel logic
MSR   PSTATE.PAN, #1   ; set PAN

; ... further kernel work ...

; Later, suppose an exploit corrupts a pointer to a user-space code page and jumps there
BR    X3             ; branch to X3 (which points into user memory)

; Because the target page is marked PXN = 1 for privileged execution,
; the CPU throws an exception (fault) and rejects execution
```
If the kernel had **değil** set PXN on that user page, then the branch might succeed — which would be insecure.

If the kernel forgets to re-enable PAN after user memory access, it opens a window where further kernel logic might accidentally read/write arbitrary user memory.

If the user pointer is into an execute-only page (user page with only execute permission, no read/write), under the PAN spec bug, `ldr W2, [X1]` might **değil** fault even with PAN enabled, enabling a bypass exploit, depending on implementation.

</details>

<details>
<summary>Example</summary>
A kernel vulnerability tries to take a user-provided function pointer and call it in kernel context (i.e. `call user_buffer`). Under PAN/PXN, that operation is disallowed or faults.
</details>

---

### 11. **Top Byte Ignore (TBI) / Pointer Tagging**
**Introduced in ARMv8.5 / newer (or optional extension)**
TBI means the top byte (most-significant byte) of a 64-bit pointer is ignored by address translation. This lets OS or hardware embed **tag bits** in the pointer’s top byte without affecting the actual address.

- TBI stands for **Top Byte Ignore** (sometimes called *Address Tagging*). It is a hardware feature (available in many ARMv8+ implementations) that **ignores the top 8 bits** (bits 63:56) of a 64-bit pointer when performing **address translation / load/store / instruction fetch**.
- In effect, the CPU treats a pointer `0xTTxxxx_xxxx_xxxx` (where `TT` = top byte) as `0x00xxxx_xxxx_xxxx` for the purposes of address translation, ignoring (masking off) the top byte. The top byte can be used by software to store **metadata / tag bits**.
- This gives software “free” in-band space to embed a byte of tag in each pointer without altering which memory location it refers to.
- The architecture ensures that loads, stores, and instruction fetch treat the pointer with its top byte masked (i.e. tag stripped off) before performing the actual memory access.

Thus TBI decouples the **logical pointer** (pointer + tag) from the **physical address** used for memory operations.

#### Why TBI: Use cases and motivation

- **Pointer tagging / metadata**: You can store extra metadata (e.g. object type, version, bounds, integrity tags) in that top byte. When you later use the pointer, the tag is ignored at hardware level, so you don’t need to strip manually for the memory access.
- **Memory tagging / MTE (Memory Tagging Extension)**: TBI is the base hardware mechanism that MTE builds on. In ARMv8.5, the **Memory Tagging Extension** uses bits 59:56 of the pointer as a **logical tag** and checks it against an **allocation tag** stored in memory.
- **Enhanced security & integrity**: By combining TBI with pointer authentication (PAC) or runtime checks, you can force not just the pointer value but also the tag to be correct. An attacker overwriting a pointer without the correct tag will produce a mismatched tag.
- **Compatibility**: Because TBI is optional and tag bits are ignored by hardware, existing untagged code continues to operate normally. The tag bits effectively become “don’t care” bits for legacy code.

#### Example
<details>
<summary>Example</summary>
A function pointer included a tag in its top byte (say `0xAA`). An exploit overwrites the pointer low bits but neglects the tag, so when the kernel verifies or sanitizes, the pointer fails or is rejected.
</details>

---

### 12. **Page Protection Layer (PPL)**
**Introduced in late iOS / modern hardware (iOS ~17 / Apple silicon / high-end models)** (some reports show PPL circa macOS / Apple silicon, but Apple is bringing analogous protections to iOS)

- PPL is designed as an **intra-kernel protection boundary**: even if the kernel (EL1) is compromised and has read/write capabilities, **it should not be able to freely modify** certain **sensitive pages** (especially page tables, code-signing metadata, kernel code pages, entitlements, trust caches, etc.).
- It effectively creates a **“kernel within the kernel”** — a smaller trusted component (PPL) with **elevated privileges** that alone can modify protected pages. Other kernel code must call into PPL routines to effect changes.
- This reduces the attack surface for kernel exploits: even with full arbitrary R/W/execute in kernel mode, exploit code must also somehow get into the PPL domain (or bypass PPL) to modify critical structures.
- On newer Apple silicon (A15+ / M2+), Apple is transitioning to **SPTM (Secure Page Table Monitor)**, which in many cases replaces PPL for page-table protection on those platforms.

Here’s how PPL is believed to operate, based on public analysis:

#### Use of APRR / permission routing (APRR = Access Permission ReRouting)

- Apple hardware uses a mechanism called **APRR (Access Permission ReRouting)**, which allows page table entries (PTEs) to contain small indices, rather than full permission bits. Those indices are mapped via APRR registers to actual permissions. This allows dynamic remapping of permissions per domain.
- PPL leverages APRR to segregate privilege within kernel context: only the PPL domain is permitted to update the mapping between indices and effective permissions. That is, when non-PPL kernel code writes a PTE or tries to flip permission bits, the APRR logic disallows it (or enforces read-only mapping).
- PPL code itself runs in a restricted region (e.g. `__PPLTEXT`) which is normally non-executable or non-writable until entry gates temporarily allow it. The kernel calls PPL entry points (“PPL routines”) to perform sensitive operations.

#### Gate / Entry & Exit

- When the kernel needs to modify a protected page (e.g. change permissions of a kernel code page, or modify page tables), it calls into a **PPL wrapper** routine, which does validation and then transitions into the PPL domain. Outside that domain, the protected pages are effectively read-only or non-modifiable by the main kernel.
- During PPL entry, the APRR mappings are adjusted so that memory pages in the PPL region are set to **executable & writable** within PPL. Upon exit, they are returned to read-only / non-writable. This ensures that only well-audited PPL routines can write to protected pages.
- Outside PPL, attempts by kernel code to write to those protected pages will fault (permission denied) because the APRR mapping for that code domain doesn’t permit writing.

#### Protected page categories

The pages that PPL typically protects include:

- Page table structures (translation table entries, mapping metadata)
- Kernel code pages, especially those containing critical logic
- Code-sign metadata (trust caches, signature blobs)
- Entitlement tables, signature enforcement tables
- Other high-value kernel structures where a patch would allow bypassing signature checks or credentials manipulation

The idea is that even if the kernel memory is fully controlled, the attacker cannot simply patch or rewrite these pages, unless they also compromise PPL routines or bypass PPL.


#### Known Bypasses & Vulnerabilities

1. **Project Zero’s PPL bypass (stale TLB trick)**

- A public writeup by Project Zero describes a bypass involving **stale TLB entries**.
- The idea:

1. Allocate two physical pages A and B, mark them as PPL pages (so they are protected).
2. Map two virtual addresses P and Q whose L3 translation table pages come from A and B.
3. Spin a thread to continuously access Q, keeping its TLB entry alive.
4. Call `pmap_remove_options()` to remove mappings starting at P; due to a bug, the code mistakenly removes the TTEs for both P and Q, but only invalidates the TLB entry for P, leaving Q’s stale entry live.
5. Reuse B (page Q’s table) to map arbitrary memory (e.g. PPL-protected pages). Because the stale TLB entry still maps Q’s old mapping, that mapping remains valid for that context.
6. Through this, the attacker can put writable mapping of PPL-protected pages in place without going through PPL interface.

- This exploit required fine control of physical mapping and TLB behavior. It demonstrates that a security boundary relying on TLB / mapping correctness must be extremely careful about TLB invalidations and mapping consistency.

- Project Zero commented that bypasses like this are subtle and rare, but possible in complex systems. Still, they regard PPL as a solid mitigation.

2. **Other potential hazards & constraints**

- If a kernel exploit can directly enter PPL routines (via calling the PPL wrappers), it might bypass restrictions. Thus argument validation is critical.
- Bugs in the PPL code itself (e.g. arithmetic overflow, boundary checks) can allow out-of-bounds modifications inside PPL. Project Zero observed that such a bug in `pmap_remove_options_internal()` was exploited in their bypass.
- The PPL boundary is irrevocably tied to hardware enforcement (APRR, memory controller), so it's only as strong as the hardware implementation.



#### Example
<details>
<summary>Code Example</summary>
Here’s a simplified pseudocode / logic showing how a kernel might call into PPL to modify protected pages:
```c
// In kernel (outside PPL domain)
function kernel_modify_pptable(pt_addr, new_entry) {
// validate arguments, etc.
return ppl_call_modify(pt_addr, new_entry)  // call PPL wrapper
}

// In PPL (trusted domain)
function ppl_call_modify(pt_addr, new_entry) {
// temporarily enable write access to protected pages (via APRR adjustments)
aprr_set_index_for_write(PPL_INDEX)
// perform the modification
*pt_addr = new_entry
// restore permissions (make pages read-only again)
aprr_restore_default()
return success
}

// If kernel code outside PPL does:
*pt_addr = new_entry  // a direct write
// It will fault because APRR mapping for non-PPL domain disallows write to that page
```
The kernel can do many normal operations, but only through `ppl_call_*` routines can it change protected mappings or patch code.
</details>

<details>
<summary>Örnek</summary>
Bir kernel exploit, entitlement tablosunu üzerine yazmaya veya kernel signature blob'unu değiştirerek code-sign enforcement'ı devre dışı bırakmaya çalışır. Çünkü o sayfa PPL-korumalıdır, yazma PPL arayüzü üzerinden yapılmadıkça engellenir. Bu nedenle kernel kod yürütmesi olsa bile code-sign kısıtlamalarını atlatamaz veya kimlik bilgisi verilerini keyfi olarak değiştiremezsiniz. iOS 17+ üzerinde bazı cihazlar PPL tarafından yönetilen sayfaları daha da izole etmek için SPTM kullanır.
</details>

#### PPL → SPTM / Yerine Geçiş / Gelecek

- On Apple’s modern SoCs (A15 or later, M2 or later), Apple supports **SPTM** (Secure Page Table Monitor), which **replaces PPL** for page table protections.
- Apple calls out in documentation: “Page Protection Layer (PPL) and Secure Page Table Monitor (SPTM) enforce execution of signed and trusted code … PPL manages the page table permission overrides … Secure Page Table Monitor replaces PPL on supported platforms.”
- The SPTM architecture likely shifts more policy enforcement into a higher-privileged monitor outside kernel control, further reducing the trust boundary.

### MTE | EMTE | MIE

Here’s a higher-level description of how EMTE operates under Apple’s MIE setup:

1. **Etiket ataması**
- When memory is allocated (e.g. in kernel or user space via secure allocators), a **gizli etiket** is assigned to that block.
- The pointer returned to the user or kernel includes that tag in its high bits (using TBI / top byte ignore mechanisms).

2. **Erişimde etiket kontrolü**
- Whenever a load or store is executed using a pointer, the hardware checks that the pointer’s tag matches the memory block’s tag (allocation tag). If mismatch, it faults immediately (since synchronous).
- Because it's synchronous, there is no “delayed detection” window.

3. **Boşaltma / yeniden kullanımda yeniden-etiketleme**
- When memory is freed, the allocator changes the block’s tag (so older pointers with old tags no longer match).
- A use-after-free pointer would therefore have a stale tag and mismatch when accessed.

4. **Taşmaları yakalamak için komşu etiket farklılaştırması**
- Adjacent allocations are given distinct tags. If a buffer overflow spills into neighbor’s memory, tag mismatch causes a fault.
- This is especially powerful in catching small overflows that cross boundary.

5. **Etiket gizliliğinin sağlanması**
- Apple must prevent tag values being leak (because if attacker learns the tag, they could craft pointers with correct tags).
- They include protections (microarchitectural / speculative controls) to avoid side-channel leakage of tag bits.

6. **Kernel ve kullanıcı alanı entegrasyonu**
- Apple uses EMTE not just in user-space but also in kernel / OS-critical components (to guard kernel against memory corruption).
- The hardware/OS ensures tag rules apply even when kernel is executing on behalf of user space.

<details>
<summary>Örnek</summary>
```
Allocate A = 0x1000, assign tag T1
Allocate B = 0x2000, assign tag T2

// pointer P points into A with tag T1
P = (T1 << 56) | 0x1000

// Valid store
*(P + offset) = value // tag T1 matches allocation → allowed

// Overflow attempt: P’ = P + size_of_A (into B region)
*(P' + delta) = value
→ pointer includes tag T1 but memory block has tag T2 → mismatch → fault

// Free A, allocator retags it to T3
free(A)

// Use-after-free:
*(P) = value
→ pointer still has old tag T1, memory region is now T3 → mismatch → fault
```
</details>

#### Sınırlamalar & zorluklar

- **Intrablock overflows**: Eğer overflow aynı allocation içinde kalır (sınırı aşmaz) ve tag aynı kalırsa, tag mismatch bunu yakalayamaz.
- **Tag width limitation**: Etiket için yalnızca birkaç bit (ör. 4 bit veya küçük bir alan) kullanılabiliyor—sınırlı isim alanı.
- **Side-channel leaks**: Eğer tag bitleri (cache / speculative execution yoluyla) leak olabiliyorsa, saldırgan geçerli tagleri öğrenip atlatabilir. Apple’ın tag confidentiality enforcement bunu hafifletmeyi amaçlar.
- **Performance overhead**: Her load/store için yapılan tag kontrolleri maliyet ekler; Apple donanımı optimize ederek overhead’i düşük tutmalı.
- **Compatibility & fallback**: Eski donanımda veya EMTE’yi desteklemeyen parçalar için fallback olmalı. Apple, MIE’in yalnızca destekleyen cihazlarda etkinleştirildiğini iddia ediyor.
- **Complex allocator logic**: Allocator tagleri yönetmeli, retagging yapmalı, boundary’leri hizalamalı ve tag çakışmalarından kaçınmalı. Allocator mantığındaki hatalar yeni zafiyetler yaratabilir.
- **Mixed memory / hybrid areas**: Bazı bellek bölgeleri (legacy) untagged kalabilir; bu, birlikte çalışmayı (interoperability) daha karmaşık hale getirir.
- **Speculative / transient attacks**: Birçok mikro-mimari koruma gibi, speculative execution veya micro-op fusions geçici olarak kontrolleri atlatabilir veya tag bitlerini leak edebilir.
- **Limited to supported regions**: Apple EMTE’yi yalnızca seçilmiş, yüksek riskli alanlarda (kernel, security-critical subsystems) zorunlu kılabilir, evrensel olarak değil.

---

## Standart MTE ile karşılaştırıldığında ana geliştirmeler / farklar

| Feature | Original MTE | EMTE (Apple’s enhanced) / MIE |
|---|---|---|
| **Check mode** | Supports synchronous and asynchronous modes. In async, tag mismatches are reported later (delayed)| Apple insists on **synchronous mode** by default—tag mismatches are caught immediately, no delay/race windows allowed.|
| **Coverage of non-tagged memory** | Accesses to non-tagged memory (e.g. globals) may bypass checks in some implementations | EMTE requires that accesses from a tagged region to non-tagged memory also validate tag knowledge, making it harder to bypass by mixing allocations.|
| **Tag confidentiality / secrecy** | Tags might be observable or leaked via side channels | Apple adds **Tag Confidentiality Enforcement**, which attempts to prevent leakage of tag values (via speculative side-channels etc.).|
| **Allocator integration & retagging** | MTE leaves much of allocator logic to software | Apple’s secure typed allocators (kalloc_type, xzone malloc, etc.) integrate with EMTE: when memory is allocated or freed, tags are managed at fine granularity.|
| **Always-on by default** | In many platforms, MTE is optional or off by default | Apple enables EMTE / MIE by default on supported hardware (e.g. iPhone 17 / A19) for kernel and many user processes.|

Because Apple controls both the hardware and software stack, it can enforce EMTE tightly, avoid performance pitfalls, and close side-channel holes.

---

## How EMTE works in practice (Apple / MIE)

Here’s a higher-level description of how EMTE operates under Apple’s MIE setup:

1. **Tag assignment**
- When memory is allocated (e.g. in kernel or user space via secure allocators), a **secret tag** is assigned to that block.
- The pointer returned to the user or kernel includes that tag in its high bits (using TBI / top byte ignore mechanisms).

2. **Tag checking on access**
- Whenever a load or store is executed using a pointer, the hardware checks that the pointer’s tag matches the memory block’s tag (allocation tag). If mismatch, it faults immediately (since synchronous).
- Because it's synchronous, there is no “delayed detection” window.

3. **Retagging on free / reuse**
- When memory is freed, the allocator changes the block’s tag (so older pointers with old tags no longer match).
- A use-after-free pointer would therefore have a stale tag and mismatch when accessed.

4. **Neighbor-tag differentiation to catch overflows**
- Adjacent allocations are given distinct tags. If a buffer overflow spills into neighbor’s memory, tag mismatch causes a fault.
- This is especially powerful in catching small overflows that cross boundary.

5. **Tag confidentiality enforcement**
- Apple must prevent tag values being leaked (because if attacker learns the tag, they could craft pointers with correct tags).
- They include protections (microarchitectural / speculative controls) to avoid side-channel leakage of tag bits.

6. **Kernel and user-space integration**
- Apple uses EMTE not just in user-space but also in kernel / OS-critical components (to guard kernel against memory corruption).
- The hardware/OS ensures tag rules apply even when kernel is executing on behalf of user space.

Because EMTE is built into MIE, Apple uses EMTE in synchronous mode across key attack surfaces, not as opt-in or debugging mode.

---

## Exception handling in XNU

When an **exception** occurs (e.g., `EXC_BAD_ACCESS`, `EXC_BAD_INSTRUCTION`, `EXC_CRASH`, `EXC_ARM_PAC`, etc.), the **Mach layer** of the XNU kernel is responsible for intercepting it before it becomes a UNIX-style **signal** (like `SIGSEGV`, `SIGBUS`, `SIGILL`, ...).

This process involves multiple layers of exception propagation and handling before reaching user space or being converted to a BSD signal.

### Exception Flow (High-Level)

1.  **CPU triggers a synchronous exception** (e.g., invalid pointer dereference, PAC failure, illegal instruction, etc.).

2.  **Low-level trap handler** runs (`trap.c`, `exception.c` in XNU source).

3.  The trap handler calls **`exception_triage()`**, the core of the Mach exception handling.

4.  `exception_triage()` decides how to route the exception:

-   First to the **thread's exception port**.

-   Then to the **task's exception port**.

-   Then to the **host's exception port** (often `launchd` or `ReportCrash`).

If none of these ports handle the exception, the kernel may:

-   **Convert it into a BSD signal** (for user-space processes).

-   **Panic** (for kernel-space exceptions).

### Core Function: `exception_triage()`

The function `exception_triage()` routes Mach exceptions up the chain of possible handlers until one handles it or until it's finally fatal. It's defined in `osfmk/kern/exception.c`.
```c
void exception_triage(exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt);
```
**Tipik Çağrı Akışı:**

`exception_triage()
└── exception_deliver()
├── exception_deliver_thread()
├── exception_deliver_task()
└── exception_deliver_host()`

Eğer tümü başarısız olursa → `bsd_exception()` tarafından işlenir → `SIGSEGV` gibi bir sinyale dönüştürülür.


### Exception Ports

Her Mach nesnesi (thread, task, host) **exception ports** kaydedebilir; exception messages buraya gönderilir.

Bunlar API tarafından tanımlanır:
```
task_set_exception_ports()
thread_set_exception_ports()
host_set_exception_ports()
```
Her exception port'un şunları vardır:

-   A **mask** (hangi exceptionları almak istediği)
-   A **port name** (Mach port mesajları almak için)
-   A **behavior** (kernel mesajı nasıl gönderir)
-   A **flavor** (hangi thread state dahil edilecek)


### Debuggers and Exception Handling

Bir **debugger** (örn. LLDB), hedef task veya thread üzerinde genellikle `task_set_exception_ports()` kullanarak bir **exception port** ayarlar.

**Bir istisna oluştuğunda:**

-   Mach mesajı debugger sürecine gönderilir.
-   Debugger istisnayı **işlemek** (devam ettir, kayıtları değiştir, komutu atla) veya **işlememek** arasında karar verebilir.
-   Debugger işleme almazsa, istisna bir sonraki seviyeye yayılır (task → host).


### Flow of `EXC_BAD_ACCESS`

1.  Thread geçersiz bir pointer'ı dereference eder → CPU Data Abort oluşturur.

2.  Kernel trap handler `exception_triage(EXC_BAD_ACCESS, ...)` çağrısını yapar.

3.  Mesaj şuraya gönderilir:

-   Thread port → (debugger breakpoint'i yakalayabilir).

-   Eğer debugger önemsemez → Task port → (process-seviyesi işleyici).

-   Eğer yine önemsenmez → Host port (genellikle ReportCrash).

4.  Eğer kimse işleme almazsa → `bsd_exception()` bunu `SIGSEGV`'ye çevirir.


### PAC Exceptions

Pointer Authentication (PAC) başarısız olduğunda (imza uyuşmazlığı), özel bir Mach exception yükseltilir:

-   **`EXC_ARM_PAC`** (type)
-   Kodlar ayrıntılar içerebilir (ör. anahtar tipi, pointer tipi).

Binary'de **`TFRO_PAC_EXC_FATAL`** flag'i varsa, kernel PAC hatalarını **fatal** olarak işler ve debugger yakalamasını atlar. Bu, saldırganların debugger kullanarak PAC kontrollerini atlatmasını önlemek için yapılmıştır ve platform binary'leri için etkindir.


### Software Breakpoints

Bir yazılım breakpoint'i (`int3` on x86, `brk` on ARM64) kasıtlı bir hata oluşturarak uygulanır.\
Debugger bunu exception port üzerinden yakalar:

-   Instruction pointer veya belleği değiştirir.
-   Orijinal komutu geri yükler.
-   Çalıştırmayı sürdürür.

Aynı mekanizma bir PAC istisnasını "yakalamanıza" da izin verir — **TFRO_PAC_EXC_FATAL** set edilmemişse. Eğer set edilmişse, istisna hiçbir zaman debugger'a ulaşmaz.


### Conversion to BSD Signals

Hiçbir işleyici istisnayı kabul etmezse:

-   Kernel `task_exception_notify() → bsd_exception()` çağrısını yapar.

-   Bu, Mach exception'ları sinyallere eşler:

| Mach Exception | Signal |
| --- | --- |
| EXC_BAD_ACCESS | SIGSEGV or SIGBUS |
| EXC_BAD_INSTRUCTION | SIGILL |
| EXC_ARITHMETIC | SIGFPE |
| EXC_SOFTWARE | SIGTRAP |
| EXC_BREAKPOINT | SIGTRAP |
| EXC_CRASH | SIGKILL |
| EXC_ARM_PAC | SIGILL (on non-fatal) |


### Key Files in XNU Source

-   `osfmk/kern/exception.c` → `exception_triage()`, `exception_deliver_*()` çekirdeği.

-   `bsd/kern/kern_sig.c` → Sinyal iletme mantığı.

-   `osfmk/arm64/trap.c` → Düşük seviye trap handler'ları.

-   `osfmk/mach/exc.h` → Exception kodları ve yapıları.

-   `osfmk/kern/task.c` → Task exception port kurulumları.

---

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

Kernel, sabit boyutlu "zones" olarak bölünmüş bir **zone allocator** (`kalloc`) kullanıyordu. Her zone yalnızca tek bir boyut sınıfındaki allocation'ları tutuyordu.

Ekran görüntüsünden:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Very small kernel structs, pointers.                                        |
| `default.kalloc.32`  | 32 bytes     | Small structs, object headers.                                              |
| `default.kalloc.64`  | 64 bytes     | IPC messages, tiny kernel buffers.                                          |
| `default.kalloc.128` | 128 bytes    | Medium objects like parts of `OSObject`.                                    |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Large structures, IOSurface/graphics metadata.                              |

**Nasıl çalışıyordu:**
- Her allocation isteği en yakın zone boyutuna **yukarı yuvarlanır**. (Örn. 50 byte'lık istek `kalloc.64` zoneda yer alır).
- Her zone'daki bellek bir **freelist** içinde tutulurdu — kernel tarafından freed edilen chunk'lar o zone'a geri giderdi.
- Eğer 64 byte'lık bir buffer'ı taşırırsanız, aynı zonedaki **bir sonraki objeyi** ezerdiniz.

Bu yüzden **heap spraying / feng shui** çok etkiliydi: aynı boyut sınıfında allocation'lar yaparak obje komşularını tahmin edebiliyordunuz.

### The freelist

Her kalloc zonunda, freed edilmiş objeler doğrudan sisteme verilmez — onlar bir freelist'e, aynı zone içindeki kullanılabilir chunk'ların bağlı listesinin içine giderdi.

- Bir chunk free edildiğinde, kernel o chunk'ın başına bir pointer yazar → aynı zonedaki bir sonraki free chunk'ın adresi.

- Zone bir HEAD pointer tutardı; ilk free chunk'ı gösterirdi.

- Allocation her zaman mevcut HEAD'i kullanırdı:

1. HEAD'i popla (o belleği çağırana ver).

2. HEAD = HEAD->next (freed chunk'ın header'ında saklanan).

- Free işlemi chunk'ları geri iterdi:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

Yani freelist, freed belleğin kendi içinde inşa edilmiş bir bağlı listeydi.

Normal durum:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### freelist'in istismarı

Çünkü bir free chunk'ın ilk 8 byte'ı = freelist pointer, bir saldırgan bunu bozabilir:

1. **Heap overflow** ile bitişikteki freed chunk'a taşma → onun “next” pointer'ının üzerine yazma.
2. **Use-after-free** ile freed object içine yazma → onun “next” pointer'ının üzerine yazma.

Sonra, o boyutta yapılacak bir sonraki allocation sırasında:

- Allocator bozuk chunk'ı pop eder.
- Saldırgan tarafından sağlanan “next” pointer'ını takip eder.
- Rastgele belleğe bir pointer döndürür; bu, fake object primitives veya hedefe yönelik üzerine yazma imkânı sağlar.

freelist poisoning'in görsel örneği:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
Bu freelist tasarımı, sertleştirmeden önce exploitleri son derece etkili hale getiriyordu: heap sprays'lerden gelen tahmin edilebilir komşular, raw pointer freelist links ve type separation olmaması, saldırganların UAF/overflow hatalarını rastgele kernel bellek kontrolüne yükseltmesine izin veriyordu.

### Heap Grooming / Feng Shui
Heap grooming'in amacı, bir saldırganın overflow veya use-after-free tetiklediğinde hedef (kurban) nesnenin saldırgan kontrollü bir nesnenin hemen yanında olacak şekilde **heap düzenini şekillendirmek**dir.\
Böylece bellek bozulması gerçekleştiğinde saldırgan kurban nesneyi kontrollü verilerle güvenilir şekilde overwrite edebilir.

**Adımlar:**

1. Spray allocations (fill the holes)
- Zamanla kernel heap parçalanır: bazı zone'larda eski nesnelerin free edildiği delikler oluşur.
- Saldırgan önce bu boşlukları doldurmak için çok sayıda dummy allocation yapar, böylece heap “paketlenir” ve öngörülebilir olur.

2. Force new pages
- Delikler dolduktan sonra, sonraki tahsisatlar o zone'a eklenen yeni sayfalardan gelmek zorunda kalır.
- Yeni sayfalar, nesnelerin eski parçalanmış belleğe dağılmak yerine kümelenmesini sağlar.
- Bu, saldırganın komşular üzerinde daha iyi kontrol sahibi olmasını sağlar.

3. Place attacker objects
- Saldırgan şimdi yeniden spray yapar ve o yeni sayfalarda birçok saldırgan-kontrollü nesne oluşturur.
- Bu nesneler boyut ve yerleşim açısından öngörülebilirdir (çünkü hepsi aynı zone'a aittir).

4. Free a controlled object (make a gap)
- Saldırgan kasıtlı olarak kendi nesnelerinden birini free eder.
- Bu, allocator'ın daha sonra aynı boyuttaki bir sonraki tahsis için yeniden kullanacağı heap'te bir “delik” yaratır.

5. Victim object lands in the hole
- Saldırgan, kernel'i hedef (bozmak istediği) nesneyi allocate etmeye zorlar.
- Delik, freelist'teki ilk uygun slot olduğu için kurban, saldırganın freed ettiği nesnenin tam yerine yerleşir.

6. Overflow / UAF into victim
- Artık saldırganın kontrolündeki nesneler kurbanın etrafındadır.
- Kendi nesnelerinden birinden overflow yaparak (veya freed birini yeniden kullanarak) kurbanın bellek alanlarını seçilen değerlerle güvenilir şekilde overwrite edebilirler.

**Neden işe yarar**:

- Zone allocator tahmin edilebilirliği: aynı boyuttaki tahsisatlar hep aynı zone'dan gelir.
- Freelist davranışı: yeni tahsisatlar en son freed edilmiş chunk'ı ilk yeniden kullanır.
- Heap sprays: saldırgan belleği öngörülebilir içerikle doldurur ve yerleşimi kontrol eder.
- Sonuç: saldırgan kurban nesnenin nereye düştüğünü ve yanındaki veriyi kontrol eder.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple allocator'ı sertleştirdi ve **heap grooming'i çok daha zor** hale getirdi:

### 1. From Classic kalloc to kalloc_type
- **Before**: her boyut sınıfı için tek bir `kalloc.<size>` zone'u vardı (16, 32, 64, … 1280, vb.). O boyuttaki herhangi bir nesne oraya yerleşirdi → saldırgan nesneleri ayrıcalıklı kernel nesnelerinin yanına oturabilirdi.
- **Now**:
- Kernel nesneleri **typed zones** (`kalloc_type`) üzerinden allocate ediliyor.
- Her nesne türünün (ör. `ipc_port_t`, `task_t`, `OSString`, `OSData`) kendine ayrılmış bir zone'u var, aynı boyutta olsalar bile.
- Nesne türü ↔ zone eşlemesi derleme zamanında **kalloc_type system** tarafından üretilir.

Bir saldırgan artık kontrollü verinin (`OSData`) aynı boyuttaki hassas kernel nesneleri (`task_t`) ile komşu olacağını garanti edemez.

### 2. Slabs and Per-CPU Caches
- Heap, o zone için sabit boyutlu parçacıklara bölünmüş **slab**'lara (sayfalar) ayrıldı.
- Her zone'un contention'ı azaltmak için bir **per-CPU cache**'i var.
- Tahsisat yolu:
1. Önce per-CPU cache denenir.
2. Boşsa, global freelist'ten çekilir.
3. Freelist boşsa yeni bir slab (bir veya daha fazla sayfa) allocate edilir.
- **Fayda**: Bu desantralizasyon, tahsisatların farklı CPU'ların cache'lerinden karşılanabilmesi nedeniyle heap spray'leri daha az deterministik yapar.

### 3. Randomization inside zones
- Bir zone içinde, freed elemanlar basit FIFO/LIFO sırasıyla geri verilmez.
- Modern XNU **encoded freelist pointers** kullanır (Linux'taki safe-linking tarzı, ~iOS 14 civarında tanıtıldı).
- Her freelist pointer, per-zone bir gizli cookie ile **XOR-encode** edilir.
- Bu, yazma primitive'ine sahip olsanız bile saldırganların sahte bir freelist pointer oluşturmasını engeller.
- Bazı tahsisatlar slab içinde yerleştirme açısından **randomize** edilir, bu yüzden spraying adjacency garantilemez.

### 4. Guarded Allocations
- Belirli kritik kernel nesneleri (ör. credentials, task yapıları) **guarded zones** içinde allocate edilir.
- Bu zonelar slab'lar arasında **guard pages** (maplenmemiş bellek) ekler veya nesnelerin etrafında **redzones** kullanır.
- Guard page'e olan herhangi bir overflow hata tetikler → sessiz bozulma yerine anında panic.

### 5. Page Protection Layer (PPL) and SPTM
- Freed bir nesneyi kontrol edebilseniz bile tüm kernel belleğini değiştiremezsiniz:
- **PPL (Page Protection Layer)**, belirli bölgelerin (ör. code signing verileri, entitlements) kernel'in kendisine bile **read-only** olmasını zorunlu kılar.
- **A15/M2+** cihazlarda bu rol **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)** ile değiştirildi/geliştirildi.
- Bu donanım tarafından zorlanan katmanlar, saldırganların tek bir heap bozulmasından kritik güvenlik yapılarını rastgele patch'lemeye yükseltememesi demektir.
- **(Added / Enhanced)**: ayrıca kernel'de pointerları (öz. function pointers, vtables) korumak için **PAC (Pointer Authentication Codes)** kullanılır; bu, onları taklit etmeyi veya bozmayı zorlaştırır.
- **(Added / Enhanced)**: zonelar **zone_require / zone enforcement** uygulayabilir; yani freed bir nesnenin yalnızca doğru typed zone üzerinden geri dönebileceği zorlanabilir; geçersiz cross-zone free'lar panic'e veya reddedilmeye neden olabilir. (Apple bu konudan bellek güvenliği yazılarında bahsediyor)

### 6. Large Allocations
- Tüm tahsisatlar `kalloc_type` üzerinden geçmez.
- Çok büyük istekler (~16 KB üzeri) typed zoneların dışına çıkar ve doğrudan **kernel VM (kmem)** üzerinden page allocation ile servis edilir.
- Bunlar daha az öngörülebilir, fakat aynı zamanda daha az exploitable olur çünkü diğer nesnelerle slab paylaşmazlar.

### 7. Allocation Patterns Attackers Target
Bu korumalara rağmen saldırganlar hâlâ şunları hedef alır:
- **Reference count objects**: retain/release counter'larına müdahale edilebilirse use-after-free oluşabilir.
- **Objects with function pointers (vtables)**: birini bozmak hâlâ kontrol akışı sağlayabilir.
- **Shared memory objects (IOSurface, Mach ports)**: bunlar user ↔ kernel köprüsü olduğu için hâlâ hedeflerdir.

Ancak — eskisi gibi — sadece `OSData` spray yapıp bunun bir `task_t` ile komşu olmasını bekleyemezsiniz. Başarmak için **type-specific bugs** veya **info leaks** gerekir.

### Example: Allocation Flow in Modern Heap

Diyelim userspace, IOKit aracılığıyla bir `OSData` nesnesi allocate ediyor:

1. **Type lookup** → `OSData` `kalloc_type_osdata` zone'una eşlenir (boyut 64 byte).
2. Free element için per-CPU cache kontrol edilir.
- Bulunursa → geri döndürülür.
- Boşsa → global freelist'e gidilir.
- Freelist boşsa → yeni bir slab allocate edilir (4KB sayfa → 64 adet 64 byte chunk).
3. Chunk caller'a döndürülür.

**Freelist pointer protection**:
- Her freed chunk, sonraki free chunk'ın adresini saklar, ama bir gizli anahtarla encode edilmiştir.
- O alanı saldırgan verisi ile overwrite etmek, anahtarı bilmeden işe yaramaz.

---

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages, and **PAC** protects pointers |
| Allocation reuse validation     | None (freelist pointers raw)                               | **zone_require / zone enforcement**             |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |
| Large allocations handling      | All small allocations managed equally                       | Large ones bypass zones → handled via VM         |

---

## Modern Userland Heap (iOS, macOS — type-aware / xzone malloc)

Son Apple OS sürümlerinde (özellikle iOS 17+), Apple daha güvenli bir userland allocator olan **xzone malloc** (XZM) getirdi. Bu, kernel'deki `kalloc_type`'ın user-space karşılığı olup type awareness, metadata isolation ve memory tagging korumaları uyguluyor.

### Goals & Design Principles

- **Type segregation / type awareness**: tahsisatları *type veya kullanım (pointer vs data)* bazında gruplayarak type confusion ve cross-type reuse'u engellemek.
- **Metadata isolation**: heap metadata'sını (ör. free listler, size/state bitleri) obje payload'larından ayırmak, out-of-bounds yazmaların metadata'yı bozma olasılığını azaltır.
- **Guard pages / redzones**: tahsislerin etrafına unmapped sayfalar veya padding eklemek, overflow'ları yakalamak için.
- **Memory tagging (EMTE / MIE)**: donanım tagging ile birlikte UAF, OOB ve geçersiz erişimleri tespit etmek.
- **Scalable performance**: düşük ek yük koruyarak, aşırı parçalanmadan kaçınmak ve yüksek tahsis hızıyla düşük gecikme sağlamak.

### Architecture & Components

Aşağıda xzone allocator'ın ana elemanları var:

#### Segment Groups & Zones

- **Segment groups** adres alanını kullanım kategorilerine göre böler: ör. `data`, `pointer_xzones`, `data_large`, `pointer_large`.
- Her segment group, o kategori için tahsisat barındıran **segments** (VM aralıkları) içerir.
- Her segment ile ilişkili bir **metadata slab** (ayrı bir VM alanı) vardır; bu slab metadata'yı (ör. free/used bitleri, size class bilgisi) depolar. Bu **out-of-line (OOL) metadata**, metadata'nın obje payload'larıyla karışmasını engeller ve overflow riskini azaltır.
- Segmentler **chunks** (dilimler) halinde ayrılır; chunk daha sonra **blocks** (tahsis ünitesi) olarak bölünür. Bir chunk belirli bir size class ve segment group'a bağlıdır (yani bir chunk içindeki tüm bloklar aynı boyut ve kategoriyi paylaşır).
- Küçük/orta boy tahsisatlar sabit boy chunk'lar kullanır; büyük/çok büyükler ayrı olarak maplenebilir.

#### Chunks & Blocks

- Bir **chunk**, genellikle birkaç sayfa, bir group içindeki tek bir size class için ayrılan bölgedir.
- İçinde, **blocks** tahsis için kullanılabilen slotlardır. Freed block'lar metadata slab aracılığıyla izlenir — örneğin bitmaps veya out-of-line free listler ile.
- Chunk'lar arasında (veya içinde) **guard slices / guard pages** konulabilir (ör. unmapped dilimler) ki out-of-bounds yazmalar yakalansın.

#### Type / Type ID

- Her allocation site (veya malloc, calloc vb. çağrıları) bir **type identifier** (`malloc_type_id_t`) ile ilişkilendirilir; bu, ne tür bir nesne allocate edildiğini kodlar. Bu type ID allocator'a iletilir ve hangi zone/segment'in seçileceğini belirler.
- Bu yüzden iki tahsis aynı boyutta olsa bile türleri farklıysa tamamen farklı zonelara gidebilir.
- iOS 17'nin erken sürümlerinde tüm API'ler (ör. CFAllocator) tam olarak type-aware değildi; Apple bu zayıflıkları iOS 18'de ele aldı.

---

### Allocation & Freeing Workflow

xzone'da allocation ve deallocation nasıl çalışır (yüksek seviyede):

1. **malloc / calloc / realloc / typed alloc** boyut ve type ID ile çağrılır.
2. Allocator **type ID** kullanarak doğru segment group / zone'u seçer.
3. O zone/segment içinde istenen boyutta free blok olan bir chunk aranır.
- Yerel cache'ler / per-thread pool'lar veya metadata'daki free block listleri kontrol edilebilir.
- Uygun blok yoksa zone içinde yeni bir chunk allocate edilebilir.
4. Metadata slab güncellenir (free biti cleared, bookkeeping).
5. Eğer memory tagging (EMTE) aktifse, döndürülen blok bir **tag** alır ve metadata "live" durumunu yansıtacak şekilde güncellenir.
6. `free()` çağrıldığında:
- Blok metadata'da freed olarak işaretlenir (OOL slab üzerinden).
- Blok bir free list'e konulabilir veya yeniden kullanım için pool'a alınabilir.
- İsteğe bağlı olarak, blok içerikleri veri sızıntılarını veya UAF exploitlerini azaltmak için temizlenebilir veya zehirlenebilir.
- Bloka ait donanım tag'i geçersizleştirilebilir veya yeniden tag'lenebilir.
- Bir chunk tamamen boşalırsa (tüm bloklar freed ise), allocator bellek baskısı altında o chunk'ı **reclaim** edip unmap edebilir veya OS'e geri verebilir.

---

### Security Features & Hardening

Modern userland xzone'a entegre edilen savunmalar:

| Feature | Purpose | Notes |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | Prevent overflow from corrupting metadata | Metadata ayrı bir VM bölgesinde (metadata slab) tutulur|
| **Guard pages / unmapped slices** | Catch out-of-bounds writes | Buffer overflow'ları sessizce bitişik blokları bozmak yerine tespit etmeye yardımcı olur|
| **Type-based segregation** | Prevent cross-type reuse & type confusion | Aynı boyuttaki farklı type'lar farklı zonelara gider|
| **Memory Tagging (EMTE / MIE)** | Detect invalid access, stale references, OOB, UAF | xzone, donanım EMTE ile synchronous modda (“Memory Integrity Enforcement”) çalışır|
| **Delayed reuse / poisoning / zap** | Reduce chance of use-after-free exploitation | Freed block'lar zehirlenebilir, sıfırlanabilir veya karantinaya alınabilir|
| **Chunk reclamation / dynamic unmapping** | Reduce memory waste and fragmentation | Kullanılmayan chunk'lar unmap edilebilir |
| **Randomization / placement variation** | Prevent deterministic adjacency | Chunk içindeki bloklar ve chunk seçimi rastgeleleştirilebilir |
| **Segregation of “data-only” allocations** | Separate allocations that don’t store pointers | Pointer içermeyen tahsisatlar ayrılarak metadata veya kontrol alanları üzerindeki saldırgan kontrolü azaltılır|

---

### Interaction with Memory Integrity Enforcement (MIE / EMTE)

- Apple’ın MIE (Memory Integrity Enforcement), Enhanced Memory Tagging Extension (EMTE) ile birlikte önemli yüzeylerde her zaman açık, synchronous mod sağlayan donanım + OS çerçevesidir.
- xzone allocator, user space'te MIE'nin temelidir: xzone üzerinden yapılan tahsisatlar tag alır ve erişimler donanım tarafından denetlenir.
- MIE'de allocator, tag atama, metadata yönetimi ve tag gizliliği uygulaması entegre edilerek bellek hatalarının (stale reads, OOB, UAF vb.) derhal yakalanmasını sağlar, sonradan suistimal edilmesini engeller.

---

Eğer isterseniz, kitabınız için xzone iç yapısının kısa bir cheat-sheet'ini veya diyagramını da üretebilirim. Bunu ister misiniz?
::contentReference[oaicite:20]{index=20}


---

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

BinDiff DMG'yi [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) adresinden indirip kurun.

Ghidra'yı `ghidraRun` ile açın ve `File` --> `Install Extensions` gitin, add butonuna basın ve yolu `/Applications/BinDiff/Extra/Ghidra/BinExport` olarak seçin ve OK deyin; sürüm uyuşmazlığı olsa bile yükleyin.

### Using BinDiff with Kernel versions

1. İstediğiniz iOS sürümlerini diff etmek için [https://ipsw.me/](https://ipsw.me/) sayfasına gidin ve indirin. Bunlar `.ipsw` dosyaları olacaktır.
2. Her iki `.ipsw` dosyasının kernelcache'inin bin formatına ulaşana kadar dekomprese edin. Bunu nasıl yapacağınızla ilgili bilgiye şurada ulaşabilirsiniz:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. `ghidraRun` ile Ghidra'yı açın, yeni bir proje oluşturun ve kernelcache'leri yükleyin.
4. Her kernelcache'i açın, böylece Ghidra tarafından otomatik olarak analiz edilsin.
5. Ardından, Ghidra proje penceresinde her kernelcache üzerine sağ tıklayın, `Export` seçin, format olarak `Binary BinExport (v2) for BinDiff` seçin ve dışa aktarın.
6. BinDiff'i açın, yeni bir workspace oluşturun ve primary dosya olarak zafiyet içeren kernelcache'i, secondary olarak patch'lenmiş kernelcache'i belirterek yeni bir diff ekleyin.

---

## Finding the right XNU version

Belirli bir iOS sürümündeki zafiyetleri kontrol etmek istiyorsanız, o iOS sürümünün hangi XNU release versiyonunu kullandığını şu adreste kontrol edebilirsiniz: [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

Örneğin, `15.1 RC`, `15.1` ve `15.1.1` sürümleri `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006` versiyonunu kullanır.

### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
