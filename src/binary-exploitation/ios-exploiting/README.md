# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

- **Code Signing** in iOS werk deur te vereis dat elke stukkie uitvoerbare kode (apps, libraries, extensions, ens.) kriptografies geteken is met 'n sertifikaat wat deur Apple uitgereik is. Wanneer kode gelaai word, verifieer iOS die digitale handtekening teen Apple’s trusted root. As die handtekening ongeldig, afwesig of gemodifiseer is, weier die OS om dit te bestuur. Dit verhoed dat aanvalleerders kwaadwillige kode in legitieme apps insit of unsigned binaries uitvoer, en stop dus die meeste exploit-chains wat staatmaak op die uitvoer van arbitrêre of gemanipuleerde kode.
- **CoreTrust** is die iOS-substelsel wat code signing by runtime afdwing. Dit verifieer handtekeninge direk met Apple’s root certificate sonder om op gecachte trust-stores staat te maak, wat beteken dat slegs binaries gesigneer deur Apple (of met geldige entitlements) kan uitvoer. CoreTrust verseker dat selfs as 'n aanvaller 'n app ná installasie manipuleer, sistembiblioteke wysig of probeer unsigned code laai, die stelsel uitvoering blokkeer tensy die kode steeds behoorlik geteken is. Hierdie streng afdwinging sluit baie post-exploitation vektore wat ouer iOS-weergawes deur swak of omseilbare signature checks toegelaat het.
- **Data Execution Prevention (DEP)** merk geheuegebiede as nie-uitvoerbaar tensy hulle eksplisiet kode bevat. Dit keer dat aanvalleerders shellcode in data-områdes (soos die stack of heap) insit en uitvoer, en dwing hulle om op meer komplekse tegnieke soos ROP (Return-Oriented Programming) staat te maak.
- **ASLR (Address Space Layout Randomization)** randomiseer die geheueadresse van kode, libraries, stack en heap elke keer wanneer die stelsel loop. Dit maak dit baie moeiliker vir aanvalleerders om te voorspel waar nuttige instruksies of gadgets is, en breek baie exploit-chains wat op vaste geheue-lay-outs staatmaak.
- **KASLR (Kernel ASLR)** pas dieselfde randomiseringskonsep op die iOS-kernel toe. Deur die kernel se basisadres by elke opstart te skud, voorkom dit dat aanvalleerders betroubaar kernel-funksies of -strukture lokaliseer, wat die moeilikheidsgraad van kernel-vlak exploits wat volle stelselbeheer sou gee, verhoog.
- **Kernel Patch Protection (KPP)**, ook bekend as **AMCC (Apple Mobile File Integrity)** in iOS, monitor kontinu die kernel se code pages om te verseker dat dit nie gewysig is nie. As enige manipulasie opgespoor word—soos 'n exploit wat kernel-funksies probeer patch of kwaadwillige kode insit—sal die toestel onmiddellik panic en herbegin. Hierdie beskerming maak volhoubare kernel-exploits aansienlik moeiliker, aangesien aanvalleerders nie net kernel-instruksies kan hook of patch sonder om 'n stelsel-crash te veroorsaak nie.
- **Kernel Text Readonly Region (KTRR)** is 'n hardeware-gebaseerde sekuriteitsfunksie wat op iOS-toestelle bekendgestel is. Dit gebruik die CPU se geheuebeheerder om die kernel se code (text) afdeling na opstart permanent as read-only te merk. Sodra dit vergrendel is, kan selfs die kernel self hierdie geheuegebied nie wysig nie. Dit keer aanvalleerders — en selfs bevoorregte kode — om kernel-instruksies tydens runtime te patch, en sluit 'n groot klas exploits wat op direkte modifikasie van kernel-kode staatgemaak het, af.
- **Pointer Authentication Codes (PAC)** gebruik kriptografiese handtekeninge ingebed in ongebruikte bits van pointers om hul integriteit te verifieer voordat hulle gebruik word. Wanneer 'n pointer (soos 'n return address of function pointer) geskep word, teken die CPU dit met 'n geheime sleutel; voor dereferencing, kontroleer die CPU die handtekening. As die pointer gemanipuleer is, misluk die check en stop uitvoering. Dit verhoed dat aanvalleerders vervalste of gekorrupte pointers in memory forgeer of hergebruik in memory corruption exploits, wat tegnieke soos ROP of JOP baie moeiliker maak om betroubaar uit te voer.
- **Privilege Access never (PAN)** is 'n hardeware-funksie wat die kernel (bevoorregte modus) verhinder om direk user-space memory te benader tensy dit eksplisiet toegang aktief maak. Dit hou aanvalleerders wat kernel code execution verkry het daarvan weerhou om maklik user memory te lees of te skryf om exploits op te skerp of sensitiewe data te steel. Deur streng skeiding af te dwing, verminder PAN die impak van kernel-exploits en blokkeer baie algemene privilege-escalation tegnieke.
- **Page Protection Layer (PPL)** is 'n iOS-sekuriteitsmeganisme wat kritieke kernel-beheerde geheuegebiede beskerm, veral dié wat verband hou met code signing en entitlements. Dit handhaaf streng write-beskerming met behulp van die MMU (Memory Management Unit) en addisionele kontroles, wat verseker dat selfs bevoorregte kernel-kode nie lukraak sensitiewe pages kan wysig nie. Dit verhoed dat aanvalleerders wat kernel-vlak uitvoering kry sekuriteitskritieke strukture manipuleer, en maak persistentie en code-signing omseilings aansienlik moeiliker.

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

Die kernel het 'n **zone allocator** (`kalloc`) gebruik wat in vaste-grootte "zones" verdeel is.
Elke zone stoor slegs allocations van 'n enkele size class.

From the screenshot:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Very small kernel structs, pointers.                                        |
| `default.kalloc.32`  | 32 bytes     | Small structs, object headers.                                              |
| `default.kalloc.64`  | 64 bytes     | IPC messages, tiny kernel buffers.                                          |
| `default.kalloc.128` | 128 bytes    | Medium objects like parts of `OSObject`.                                    |
| `default.kalloc.256` | 256 bytes    | Larger IPC messages, arrays, device structures.                             |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Large structures, IOSurface/graphics metadata.                              |

**How it worked:**
- Each allocation request gets **rounded up** to the nearest zone size.
(E.g., a 50-byte request lands in the `kalloc.64` zone).
- Memory in each zone was kept in a **free list** — chunks freed by the kernel went back into that zone.
- If you overflowed a 64-byte buffer, you’d overwrite the **next object in the same zone**.

This is why **heap spraying / feng shui** was so effective: you could predict object neighbors by spraying allocations of the same size class.

### The freelist

Inside each kalloc zone, freed objects weren’t returned directly to the system — they went into a freelist, a linked list of available chunks.

- When a chunk was freed, the kernel wrote a pointer at the start of that chunk → the address of the next free chunk in the same zone.

- The zone kept a HEAD pointer to the first free chunk.

- Allocation always used the current HEAD:

1. Pop HEAD (return that memory to the caller).

2. Update HEAD = HEAD->next (stored in the freed chunk’s header).

- Freeing pushed chunks back:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

So the freelist was just a linked list built inside the freed memory itself.

Normal state:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Exploiting the freelist

Omdat die eerste 8 bytes van 'n free chunk = freelist pointer, kan 'n aanvaller dit korrupteer:

1. **Heap overflow** in 'n aangrensende freed chunk → oorskryf sy “next” pointer.

2. **Use-after-free** skryf in 'n freed object → oorskryf sy “next” pointer.

Dan, by die volgende toewysing van daardie grootte:

- Die allocator haal die gekorrupte chunk uit.
- Volg die deur die aanvaller verskafde “next” pointer.
- Gee 'n pointer terug na arbitrêre geheue, wat fake object primitives of geteikende oorskrywing moontlik maak.

Visuele voorbeeld van freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
This freelist-ontwerp het uitbuiting baie effektief gemaak voor die verharding: voorspelbare bure van heap sprays, ruwe pointer freelist links, en geen tipe-separasie het aanvallers toegelaat om UAF/overflow-bugs te eskaleer na arbitraire beheer van kernel-geheue.

### Heap Grooming / Feng Shui
Die doel van heap grooming is om die heap-lay-out te **vorm** sodat wanneer 'n aanvaller 'n overflow of use-after-free aktiveer, die teiken (slagoffer) objek presies langs 'n deur-aanvaller-beheerde objek sit.\
Op dié manier kan die aanvaller, wanneer geheue-korrupsie plaasvind, die slagoffer-objek betroubaar met beheerdata oorskryf.

**Stappe:**

1. Spray allocations (fill the holes)
- Mettertyd raak die kernel heap gefragmenteerd: sommige zones het gapings waar ou
objekte vrygestel is.
- Die aanvaller maak eers baie dummy-allocations om hierdie gapings te vul, sodat
die heap “gepak” en voorspelbaar raak.

2. Force new pages
- Sodra die gapings gevul is, moet die volgende allocations van nuwe bladsye
by die zone kom.
- Nuwe bladsye beteken objekke sal saamgekluster wees, nie oor ou gefragmenteerde
geheue versprei nie.
- Dit gee die aanvaller baie beter beheer oor bure.

3. Place attacker objects
- Die aanvaller spray weer, en skep baie deur-aanvaller-beheerde objekke
in daardie nuwe bladsye.
- Hierdie objekke is voorspelbaar in grootte en posisie (aangesien hulle almal
aan dieselfde zone behoort).

4. Free a controlled object (make a gap)
- Die aanvaller vrylaat doelbewus een van hul eie objekke.
- Dit skep 'n “gat” in die heap, wat die allocator later sal hergebruik vir
die volgende allocation van daardie grootte.

5. Victim object lands in the hole
- Die aanvaller laat die kernel die slagoffer-objek (die een wat hulle wil korrupteer) allokeer.
- Aangesien die gat die eerste beskikbare slot in die freelist is, word die slagoffer
presies geplaas waar die aanvaller hul objek vrygelaat het.

6. Overflow / UAF into victim
- Nou het die aanvaller deur-aanvaller-beheerde objekke rondom die slagoffer.
- Deur te overflow van een van hul eie objekke (of deur 'n vrygestelde een te hergebruik), kan hulle betroubaar die slagoffer se geheuevelde met gekose waardes oorskryf.

**Waarom dit werk**:

- Zone allocator voorspelbaarheid: allocations van dieselfde grootte kom altyd uit
dieselfde zone.
- Freelist gedrag: nuwe allocations hergebruik die mees onlangs vrygestelde chunk eerstens.
- Heap sprays: die aanvaller vul geheue met voorspelbare inhoud en beheer die lay-out.
- Eindresultaat: die aanvaller beheer waar die slagoffer-objek lands en watter data langs dit sit.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple het die allocator gehard en gemaak dat **heap grooming baie moeiliker** is:

### 1. From Classic kalloc to kalloc_type
- **Before**: 'n enkele `kalloc.<size>` zone het bestaan vir elke grootteklas (16, 32, 64, … 1280, ens.). Enige objek van daardie grootte is daar geplaas → aanvaller-objekte kon langs bevoorregte kernel-objekte sit.
- **Now**:
- Kernel-objekte word gealloceer uit **typed zones** (`kalloc_type`).
- Elke tipe objek (bv. `ipc_port_t`, `task_t`, `OSString`, `OSData`) het sy eie toegewyde zone, selfs al is hulle dieselfde grootte.
- Die mapping tussen objektipe ↔ zone word gegenereer uit die **kalloc_type system** by saamstelling.

'n Aanvaller kan nie meer waarborg dat beheerde data (`OSData`) langs sensitiewe kernel-objekte (`task_t`) van dieselfde grootte eindig nie.

### 2. Slabs and Per-CPU Caches
- Die heap is verdeel in **slabs** (bladsye geheue in vaste-grootte stukke gesny vir daardie zone).
- Elke zone het 'n **per-CPU cache** om konflik te verminder.
- Allocatiepad:
1. Probeer per-CPU cache.
2. As dit leeg is, haal van die globale freelist.
3. As die freelist leeg is, allokeer 'n nuwe slab (een of meer bladsye).
- **Voordeel**: Hierdie desentralisasie maak heap sprays minder deterministies, aangesien allocations moontlik deur verskillende CPU's se caches bevredig word.

### 3. Randomization inside zones
- Binne 'n zone word vrygestelde elemente nie in eenvoudige FIFO/LIFO volgorde teruggegee nie.
- Moderne XNU gebruik **encoded freelist pointers** (safe-linking soos Linux, bekendgestel ~iOS 14).
- Elke freelist-pointer is **XOR-gekodeer** met 'n per-zone geheime cookie.
- Dit verhoed dat aanvallers 'n vals freelist-pointer kan voorsê indien hulle 'n write-primitive kry.
- Sommige allocations word **gerandomiseer in hul plasing binne 'n slab**, so spraying waarborg nie nabyheid nie.

### 4. Guarded Allocations
- Sekere kritieke kernel-objekte (bv. credentials, task-strukture) word gealloceer in **guarded zones**.
- Hierdie zones sit **guard pages** (nie-gemapde geheue) tussen slabs in of gebruik **redzones** rondom objekke.
- Enige overflow in die guard page veroorsaak 'n fout → onmiddellike panic in plaas van stille korrupsie.

### 5. Page Protection Layer (PPL) and SPTM
- Selfs as jy 'n vrygestelde objek beheer, kan jy nie al die kernel-geheue wysig nie:
- **PPL (Page Protection Layer)** dwing af dat sekere streke (bv. code signing data, entitlements) **slegs-lees** is selfs vir die kernel self.
- Op **A15/M2+ devices**, word hierdie rol vervang/versterk deur **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- Hierdie hardware-afgedwonge lae beteken aanvallers kan nie van 'n enkele heap-korrupsie eskaleer na arbitraire patching van kritieke sekuriteitsstrukture nie.

### 6. Large Allocations
- Nie alle allocations gaan deur `kalloc_type` nie.
- Baie groot versoeke (bo ~16KB) omseil typed zones en word direk vanaf **kernel VM (kmem)** deur bladsy-allocations bedien.
- Hierdie is minder voorspelbaar, maar ook minder uitbuitbaar, aangesien hulle nie slabs met ander objekke deel nie.

### 7. Allocation Patterns Attackers Target
Alhoewel hierdie beskermings bestaan, soek aanvallers steeds na:
- **Reference count objects**: as jy die retain/release tellers kan manipuleer, kan jy use-after-free veroorsaak.
- **Objects with function pointers (vtables)**: korruptering van een gee steeds control flow.
- **Shared memory objects (IOSurface, Mach ports)**: hierdie bly teiken omdat hulle user ↔ kernel bridge.

Maar — anders as voorheen — kan jy nie net `OSData` spray en verwag dat dit langs 'n `task_t` sit nie. Jy het behoefte aan **type-specific bugs** of **info leaks** om te slaag.

### Example: Allocation Flow in Modern Heap

Stel userspace roep in op IOKit om 'n `OSData`-objek te allokeer:

1. **Type lookup** → `OSData` map na `kalloc_type_osdata` zone (grootte 64 bytes).
2. Check per-CPU cache vir vry elemente.
- As gevind → gee een terug.
- As leeg → gaan na globale freelist.
- As freelist leeg → allokeer 'n nuwe slab (bladsy van 4KB → 64 stukke van 64 bytes).
3. Gee chunk terug aan caller.

**Freelist pointer protection**:
- Elke vrygestelde chunk stoor die adres van die volgende vrye chunk, maar gekodeer met 'n geheime sleutel.
- Oorskryf van daardie veld met aanvaller-data sal nie werk tensy jy die sleutel ken.

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages   |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


{{#include ../../banners/hacktricks-training.md}}
