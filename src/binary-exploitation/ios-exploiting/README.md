# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

### 1. **Code Signing** / Runtime Signature Verification
**Introduced early (iPhone OS → iOS)**
C’est l’une des protections fondamentales : **tout code exécutable** (apps, dynamic libraries, code JIT, extensions, frameworks, caches) doit être signé cryptographiquement par une chaîne de certificats ancrée dans la confiance d’Apple. À l’exécution, avant de charger un binaire en mémoire (ou avant d’effectuer des sauts à travers certaines frontières), le système vérifie sa signature. Si le code est modifié (bit-flipped, patché) ou non signé, le chargement échoue.

- **Empêche** : l’étape « classic payload drop + execute » dans les chaînes d’exploit ; l’injection de code arbitraire ; la modification d’un binaire existant pour y insérer une logique malveillante.
- **Détails du mécanisme** :
* Le chargeur Mach-O (et le dynamic linker) vérifie les pages de code, les segments, les entitlements, les team IDs, et que la signature couvre le contenu du fichier.
* Pour les régions mémoire comme les caches JIT ou le code généré dynamiquement, Apple impose que les pages soient signées ou validées via des APIs spéciales (ex. `mprotect` avec contrôles de code-sign).
* La signature inclut les entitlements et identifiants ; l’OS impose que certaines APIs ou capacités privilégiées requièrent des entitlements spécifiques qui ne peuvent pas être falsifiés.

<details>
<summary>Example</summary>
Supposons qu’un exploit obtienne l’exécution de code dans un process et tente d’écrire du shellcode dans un heap puis d’y sauter. Sur iOS, cette page devrait être marquée exécutable **et** satisfaire aux contraintes de code-signature. Comme le shellcode n’est pas signé avec le certificat d’Apple, le saut échoue ou le système refuse de rendre cette région mémoire exécutable.
</details>


### 2. **CoreTrust**
**Introduced around iOS 14+ era (or gradually in newer devices / later iOS)**
CoreTrust est le sous-système qui effectue la **validation de signature à l’exécution** des binaires (incluant les binaires système et utilisateurs) contre **le certificat racine d’Apple** plutôt que de se fier à des stores de confiance en userland mis en cache.

- **Empêche** : le tampering post-install des binaires, les techniques de jailbreaking qui tentent de remplacer ou patcher des librairies système ou des apps utilisateur ; tromper le système en remplaçant des binaires de confiance par des équivalents malveillants.
- **Détails du mécanisme** :
* Au lieu de faire confiance à une base de confiance locale ou à un cache de certificats, CoreTrust consulte ou se réfère directement à la racine d’Apple ou vérifie des certificats intermédiaires dans une chaîne sécurisée.
* Il garantit que les modifications (ex. dans le filesystem) des binaires existants sont détectées et rejetées.
* Il lie les entitlements, team IDs, flags de code signing et autres métadonnées au binaire au moment du chargement.

<details>
<summary>Example</summary>
Un jailbreak pourrait tenter de remplacer `SpringBoard` ou `libsystem` par une version patchée pour obtenir de la persistance. Mais lorsque le chargeur de l’OS ou CoreTrust vérifie, il remarque la discordance de signature (ou des entitlements modifiés) et refuse d’exécuter.
</details>


### 3. **Data Execution Prevention (DEP / NX / W^X)**
**Introduced in many OSes earlier; iOS had NX-bit / w^x for a long time**
DEP impose que les pages marquées comme writables (pour les données) soient **non-exécutables**, et que les pages marquées exécutables soient **non-writables**. On ne peut pas simplement écrire du shellcode dans un heap ou la stack et l’exécuter.

- **Empêche** : l’exécution directe de shellcode ; le classique buffer-overflow → saut vers du shellcode injecté.
- **Détails du mécanisme** :
* Le MMU / les flags de protection mémoire (via les tables de pages) appliquent la séparation.
* Toute tentative de marquer une page writable comme exécutable déclenche une vérification système (et est soit interdite, soit nécessite l’approbation du code-sign).
* Dans beaucoup de cas, rendre des pages exécutables nécessite de passer par des APIs OS qui imposent des contraintes ou vérifications additionnelles.

<details>
<summary>Example</summary>
Un overflow écrit du shellcode dans le heap. L’attaquant tente `mprotect(heap_addr, size, PROT_EXEC)` pour le rendre exécutable. Mais le système refuse ou valide que la nouvelle page doit satisfaire aux contraintes de code-sign (ce que le shellcode ne peut pas).
</details>

### 4. **Address Space Layout Randomization (ASLR)**
**Introduced in iOS ~4–5 era (roughly iOS 4–5 timeframe)**
ASLR randomise les adresses de base des régions mémoire clés : libraries, heap, stack, etc., à chaque lancement de process. Les adresses des gadgets bougent entre les exécutions.

- **Empêche** : le hardcoding d’adresses de gadgets pour ROP/JOP ; les chaînes d’exploit statiques ; le saut aveugle vers des offsets connus.
- **Détails du mécanisme** :
* Chaque librairie / module dynamique chargé est rebasé à un offset aléatoire.
* Les pointeurs de base de la stack et du heap sont randomisés (avec certaines limites d’entropie).
* Parfois d’autres régions (ex. mmap allocations) sont aussi randomisées.
* Combiné avec des mitigations d’information-disclosure, cela force l’attaquant à d’abord leak une adresse ou un pointeur pour découvrir les adresses de base à l’exécution.

<details>
<summary>Example</summary>
Une chaîne ROP s’attend à un gadget à `0x….lib + offset`. Mais puisque `lib` est relocée différemment à chaque exécution, la chaîne codée en dur échoue. Un exploit doit d’abord leak la base du module avant de calculer les adresses des gadgets.
</details>


### 5. **Kernel Address Space Layout Randomization (KASLR)**
**Introduced in iOS ~ (iOS 5 / iOS 6 timeframe)**
Analogue de l’ASLR utilisateur, KASLR randomise la base du **kernel text** et d’autres structures du kernel au démarrage.

- **Empêche** : les exploits kernel qui reposent sur des emplacements fixes du code ou des données du kernel ; les exploits kernel statiques.
- **Détails du mécanisme** :
* À chaque boot, l’adresse de base du kernel est randomisée (dans une plage).
* Les structures de données kernel (comme `task_structs`, `vm_map`, etc.) peuvent aussi être relocatées ou décalées.
* Les attaquants doivent d’abord leak des pointeurs kernel ou utiliser des vulnérabilités d’information disclosure pour calculer les offsets avant de détourner des structures ou du code kernel.

<details>
<summary>Example</summary>
Une vuln locale vise à corrompre un pointeur de fonction kernel (ex. dans un `vtable`) à `KERN_BASE + offset`. Mais comme `KERN_BASE` est inconnu, l’attaquant doit d’abord leak sa valeur (ex. via un primitive de lecture) avant de calculer l’adresse correcte pour la corruption.
</details>


### 6. **Kernel Patch Protection (KPP / AMCC)**
**Introduced in newer iOS / A-series hardware (post around iOS 15–16 era or newer chips)**
KPP (aka AMCC) surveille en continu l’intégrité des pages de texte du kernel (via hash ou checksum). Si elle détecte du tampering (patchs, hooks inline, modifications de code) en dehors des fenêtres autorisées, elle déclenche un kernel panic ou un reboot.

- **Empêche** : le patching persistant du kernel (modification des instructions), les hooks inline, les overwrites statiques de fonctions.
- **Détails du mécanisme** :
* Un module hardware ou firmware surveille la région de texte du kernel.
* Il recalculte périodiquement ou à la demande des hash sur les pages et compare aux valeurs attendues.
* Si des discordances apparaissent en dehors de fenêtres de mise à jour bénignes, il panique l’appareil (pour éviter une persistance malveillante).
* Les attaquants doivent soit éviter les fenêtres de détection, soit utiliser des chemins de patching légitimes.

<details>
<summary>Example</summary>
Un exploit tente de patcher le prologue d’une fonction kernel (ex. `memcmp`) pour intercepter des appels. Mais KPP remarque que le hash de la page de code ne correspond plus à la valeur attendue et déclenche un kernel panic, plantant le device avant que le patch ne soit stabilisé.
</details>


### 7. **Kernel Text Read‐Only Region (KTRR)**
**Introduced in modern SoCs (post ~A12 / newer hardware)**
KTRR est un mécanisme appliqué par le hardware : une fois le kernel text verrouillé tôt au boot, il devient en lecture seule depuis EL1 (le kernel), empêchant tout écrit ultérieur sur les pages de code.

- **Empêche** : toute modification du code kernel après le boot (ex. patching, injection de code in-place) au niveau de privilège EL1.
- **Détails du mécanisme** :
* Durant le boot (dans le secure/bootloader stage), le contrôleur mémoire (ou une unité hardware sécurisée) marque les pages physiques contenant le kernel text comme read-only.
* Même si un exploit obtient des privilèges kernel complets, il ne peut pas écrire sur ces pages pour patcher les instructions.
* Pour les modifier, l’attaquant doit d’abord compromettre la chaîne de boot, ou subvertir KTRR lui-même.

<details>
<summary>Example</summary>
Un exploit d’escalade de privilèges saute en EL1 et écrit une trampoline dans une fonction kernel (ex. dans le handler `syscall`). Mais puisque les pages sont verrouillées en lecture seule par KTRR, l’écriture échoue (ou déclenche une faute), donc les patches ne sont pas appliqués.
</details>


### 8. **Pointer Authentication Codes (PAC)**
**Introduced with ARMv8.3 (hardware), Apple beginning with A12 / iOS ~12+**
- PAC est une fonctionnalité hardware introduite dans **ARMv8.3-A** pour détecter la modification des valeurs de pointeurs (adresses de retour, function pointers, certains pointeurs de données) en encodant une petite signature cryptographique (un “MAC”) dans les bits hauts inutilisés du pointeur.
- La signature (“PAC”) est calculée sur la valeur du pointeur plus un **modifier** (une valeur de contexte, ex. stack pointer ou une donnée distinctrice). De cette manière, la même valeur de pointeur dans des contextes différents obtient un PAC différent.
- Au moment de l’utilisation, avant de déréférencer ou de brancher via ce pointeur, une instruction d’**authenticate** vérifie le PAC. Si valide, le PAC est retiré et on obtient le pointeur pur ; si invalide, le pointeur devient « poisoned » (ou une faute est levée).
- Les clés utilisées pour produire/valider les PACs résident dans des registres privilégiés (EL1, kernel) et ne sont pas directement lisibles depuis le user mode.
- Parce que toutes les 64 bits d’un pointeur ne sont pas utilisées dans de nombreux systèmes (ex. espace d’adressage 48-bit), les bits supérieurs sont “libres” et peuvent contenir le PAC sans altérer l’adresse effective.

#### Architectural Basis & Key Types

- ARMv8.3 introduit **cinq clés 128-bit** (chacune implémentée via deux registres système 64-bit) pour pointer authentication.
- **APIAKey** — pour les instruction pointers (domaine “I”, clé A)
- **APIBKey** — seconde clé pour instruction pointer (domaine “I”, clé B)
- **APDAKey** — pour les data pointers (domaine “D”, clé A)
- **APDBKey** — pour les data pointers (domaine “D”, clé B)
- **APGAKey** — clé “generic”, pour signer des données non-pointer ou usages génériques

- Ces clés sont stockées dans des registres système privilégiés (accessibles seulement à EL1/EL2 etc.), non accessibles depuis le user mode.
- Le PAC est calculé via une fonction cryptographique (ARM suggère QARMA comme algorithme) en utilisant :
1. La valeur du pointeur (portion canonique)
2. Un **modifier** (une valeur de contexte, comme un sel)
3. La clé secrète
4. Une logique interne de tweak
Si le PAC obtenu correspond à ce qui est stocké dans les bits supérieurs du pointeur, l’authentification réussit.


#### Instruction Families

La convention de nommage est : **PAC** / **AUT** / **XPAC**, puis des lettres de domaine.
- `PACxx` instructions **signent** un pointeur et insèrent un PAC
- `AUTxx` instructions **authentifient + enlèvent** (valident et retirent le PAC)
- `XPACxx` instructions **retirent** sans valider

Domains / suffixes:

| Mnemonic     | Meaning / Domain                      | Key / Domain     | Example Usage in Assembly |
|--------------|-----------------------------------------|--------------------|-----------------------------|
| **PACIA**    | Signer un instruction pointer avec APIAKey   | “I, A”             | `PACIA X0, X1` — sign pointer in X0 using APIAKey with modifier X1|
| **PACIB**    | Signer un instruction pointer avec APIBKey   | “I, B”             | `PACIB X2, X3`              |
| **PACDA**    | Signer un data pointer avec APDAKey           | “D, A”             | `PACDA X4, X5`              |
| **PACDB**    | Signer un data pointer avec APDBKey            | “D, B”             | `PACDB X6, X7`              |
| **PACG / PACGA** | Signing générique (non-pointer) avec APGAKey | “G”         | `PACGA X8, X9, X10` (sign X9 with modifier X10 into X8) |
| **AUTIA**    | Authenticate un instruction pointer signé par APIA et retirer le PAC | “I, A” | `AUTIA X0, X1` — check PAC on X0 using modifier X1, then strip |
| **AUTIB**    | Authenticate domaine APIB                 | “I, B”             | `AUTIB X2, X3`               |
| **AUTDA**    | Authenticate un data pointer signé APDA    | “D, A”             | `AUTDA X4, X5`               |
| **AUTDB**    | Authenticate un data pointer signé APDB    | “D, B”             | `AUTDB X6, X7`               |
| **AUTGA**    | Authenticate générique / blob (APGA)        | “G”               | `AUTGA X8, X9, X10` (validate generic) |
| **XPACI**     | Retirer le PAC (instruction pointer, sans validation) | “I”         | `XPACI X0` — remove PAC from X0 (instruction domain) |
| **XPACD**     | Retirer le PAC (data pointer, sans validation)    | “D”             | `XPACD X4` — remove PAC from data pointer in X4 |


Il existe des formes spécialisées / alias :

- `PACIASP` est un raccourci pour `PACIA X30, SP` (signer le link register en utilisant SP comme modifier)
- `AUTIASP` est `AUTIA X30, SP` (authentifier le link register avec SP)
- Des formes combinées comme `RETAA`, `RETAB` (authenticate-and-return) ou `BLRAA` (authenticate & branch) existent dans les extensions ARM / support compilateur.
- Aussi des variantes à modifier implicite zéro : `PACIZA` / `PACIZB` où le modifier est implicitement zéro, etc.

#### Modifiers

L’objectif principal du modifier est de **lier le PAC à un contexte spécifique** pour que la même adresse signée dans des contextes différents produise des PACs différents. C’est comme ajouter un **sel à un hash.**

Donc :
- Le **modifier** est une valeur de contexte (un autre registre) qui est mélangée dans le calcul du PAC. Choix typiques : le stack pointer (`SP`), un frame pointer, ou un ID d’objet.
- Utiliser SP comme modifier est courant pour le signing des adresses de retour : le PAC devient lié à la frame de stack spécifique. Si on tente de réutiliser le LR dans une autre frame, le modifier change, donc la validation PAC échoue.
- La même valeur de pointeur signée avec des modifiers différents produit des PACs différents.
- Le modifier **n’a pas besoin d’être secret**, mais idéalement il n’est pas contrôlé par l’attaquant.
- Pour les instructions qui signent ou vérifient des pointeurs où aucun modifier significatif n’existe, certaines formes utilisent zéro ou une constante implicite.

#### Apple / iOS / XNU Customizations & Observations

- L’implémentation PAC d’Apple inclut des **diversifiers par boot** de sorte que les clés ou tweaks changent à chaque boot, empêchant la réutilisation entre boots.
- Ils incluent aussi des **mitigations cross-domain** pour que les PACs signés en user mode ne puissent pas être réutilisés facilement en kernel mode, etc.
- Sur Apple M1 / Apple Silicon, le reverse engineering a montré qu’il y a **neuf types de modifier** et des registres système Apple-spécifiques pour le contrôle des clés.
- Apple utilise PAC dans de nombreux sous-systèmes kernel : signing des adresses de retour, intégrité des pointeurs dans les données kernel, signed thread contexts, etc.
- Google Project Zero a montré que sous un puissant primitive de lecture/écriture mémoire en kernel, on pouvait forger des PACs kernel (pour les clés A) sur des appareils A12, mais Apple a patché beaucoup de ces chemins.
- Dans le système Apple, certaines clés sont **globales au kernel**, tandis que les processus utilisateur peuvent obtenir un aléa de clé par-processus.

#### PAC Bypasses

1. **Kernel-mode PAC: theoretical vs real bypasses**

-   Parce que les clés PAC kernel et la logique sont strictement contrôlées (registres privilégiés, diversifiers, isolation de domaine), forger arbitrairement des pointeurs kernel signés est très difficile.
-   Azad’s 2020 "iOS Kernel PAC, One Year Later" rapporte que dans iOS 12-13, il a trouvé quelques contournements partiels (signing gadgets, reuse d’états signés, branches indirectes non protégées) mais pas de contournement générique complet. [bazad.github.io](https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf)
-   Les customizations "Dark Magic" d’Apple réduisent encore les surfaces exploitables (changement de domaine, bits d’activation par clé). [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Il existe un contournement kernel PAC connu CVE-2023-32424 sur Apple silicon (M1/M2) rapporté par Zecao Cai et al. [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Mais ces contournements reposent souvent sur des gadgets très spécifiques ou des bugs d’implémentation ; ce ne sont pas des bypass génériques.

Ainsi le PAC kernel est considéré comme **fortement robuste**, bien que pas parfait.

2. **User-mode / runtime PAC bypass techniques**

Ceux-ci sont plus courants, et exploitent des imperfections dans la manière dont PAC est appliqué ou utilisé dans le dynamic linking / les frameworks runtime. Ci‑dessous des classes, avec exemples.

2.1 **Shared Cache / A key issues**

-   Le **dyld shared cache** est un gros blob pré-lié de frameworks système et de librairies. Parce qu’il est largement partagé, les function pointers à l’intérieur du shared cache sont « pré-signed » puis utilisés par de nombreux process. Les attaquants ciblent ces pointeurs déjà signés comme des "PAC oracles".
-   Certaines techniques de bypass cherchent à extraire ou réutiliser des pointeurs signés A-key présents dans le shared cache et les réemployer dans des gadgets.
-   Le talk "No Clicks Required" décrit la construction d’un oracle sur le shared cache pour déduire des adresses relatives et combiner cela avec des pointeurs signés pour bypasser PAC. [saelo.github.io](https://saelo.github.io/presentations/offensivecon_20_no_clicks.pdf)
-   Aussi, l’import de function pointers depuis des librairies partagées en userspace a été jugé insuffisamment protégé par PAC, permettant à un attaquant d’obtenir des function pointers sans changer leur signature. (Project Zero bug entry) [bugs.chromium.org](https://bugs.chromium.org/p/project-zero/issues/detail?id=2044&utm_source=chatgpt.com)

2.2 **dlsym(3) / dynamic symbol resolution**

-   Un contournement connu est d’appeler `dlsym()` pour obtenir un function pointer *déjà signé* (signé avec A-key, diversifier zéro) puis de l’utiliser. Parce que `dlsym` retourne un pointeur légitime signé, l’utiliser évite le besoin de forger un PAC.
-   Le blog d’Epsilon détaille comment certains bypass exploitent cela : appeler `dlsym("someSym")` renvoie un pointeur signé et peut être utilisé pour des appels indirects. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)
-   Synacktiv dans "iOS 18.4 --- dlsym considered harmful" décrit un bug : certains symboles résolus via `dlsym` sur iOS 18.4 retournent des pointeurs incorrectement signés (ou avec des diversifiers buggés), permettant un bypass PAC involontaire. [Synacktiv](https://www.synacktiv.com/en/publications/ios-184-dlsym-considered-harmful)
-   La logique dans dyld pour dlsym inclut : quand `result->isCode`, ils signent le pointeur retourné avec `__builtin_ptrauth_sign_unauthenticated(..., key_asia, 0)`, c’est-à-dire contexte zéro. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

Ainsi, `dlsym` est un vecteur fréquent dans les bypass PAC en user-mode.

2.3 **Other DYLD / runtime relocations**

-   Le chargeur DYLD et la logique de relocation dynamique sont complexes et mappent parfois temporairement des pages en read/write pour effectuer des relocations, puis les remettent en read-only. Les attaquants exploitent ces fenêtres. Le talk de Synacktiv décrit "Operation Triangulation", un bypass temporel de PAC via des relocations dynamiques. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)
-   Les pages DYLD sont maintenant protégées avec SPRR / VM_FLAGS_TPRO (certains flags de protection pour dyld). Mais les versions antérieures avaient des gardes plus faibles. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)
-   Dans les chaînes d’exploit WebKit, le chargeur DYLD est souvent une cible pour bypass PAC. Les slides mentionnent que beaucoup de bypass PAC ont ciblé le chargeur DYLD (via relocation, interposer hooks). [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

2.4 **NSPredicate / NSExpression / ObjC / SLOP**

-   Dans les chaînes d’exploit userland, des méthodes du runtime Objective-C comme `NSPredicate`, `NSExpression` ou `NSInvocation` sont utilisées pour transporter des appels de contrôle sans pointer apparent.
-   Sur les anciens iOS (avant PAC), un exploit utilisait des **fake NSInvocation** objects pour appeler des selectors arbitraires sur une mémoire contrôlée. Avec PAC, des modifications sont nécessaires. Mais la technique SLOP (SeLector Oriented Programming) est étendue sous PAC aussi. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)
-   La technique originale SLOP permettait d’enchaîner des appels ObjC en créant de fausses invocations ; le bypass repose sur le fait que ISA ou les selectors sont parfois pas entièrement protégés par PAC. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)
-   Dans des environnements où pointer authentication est appliqué partiellement, les méthodes / selectors / target pointers peuvent ne pas toujours avoir de protection PAC, laissant de la place pour des contournements.

#### Example Flow

<details>
<summary>Example Signing & Authenticating</summary>
```
; Example: function prologue / return address protection
my_func:
stp x29, x30, [sp, #-0x20]!        ; push frame pointer + LR
mov x29, sp
PACIASP                            ; sign LR (x30) using SP as modifier
; … body …
mov sp, x29
ldp x29, x30, [sp], #0x20         ; restore
AUTIASP                            ; authenticate & strip PAC
ret

; Example: indirect function pointer stored in a struct
; suppose X1 contains a function pointer
PACDA X1, X2     ; sign data pointer X1 with context X2
STR X1, [X0]      ; store signed pointer

; later retrieval:
LDR X1, [X0]
AUTDA X1, X2       ; authenticate & strip
BLR X1             ; branch to valid target

; Example: stripping for comparison (unsafe)
LDR X1, [X0]
XPACI X1           ; strip PAC (instruction domain)
CMP X1, #some_label_address
BEQ matched_label
```
</details>

<details>
<summary>Exemple</summary>
Un débordement de tampon écrase une adresse de retour sur la pile. L'attaquant écrit l'adresse du gadget ciblé mais ne peut pas calculer le PAC correct. Quand la fonction retourne, l'instruction CPU `AUTIA` provoque une faute à cause du désaccord du PAC. La chaîne échoue.
L'analyse de Project Zero sur A12 (iPhone XS) a montré comment le PAC d'Apple est utilisé et des méthodes pour forger des PAC si un attaquant dispose d'un primitif de lecture/écriture mémoire.
</details>


### 9. **Branch Target Identification (BTI)**
**Introduit avec ARMv8.5 (matériel plus récent)**
BTI est une fonctionnalité matérielle qui vérifie les **cibles de branches indirectes** : lors de l'exécution de `blr` ou d'appels/sauts indirects, la cible doit commencer par un **BTI landing pad** (`BTI j` ou `BTI c`). Sauter vers des adresses de gadget qui n'ont pas ce landing pad déclenche une exception.

LLVM’s implementation notes three variants of BTI instructions and how they map to branch types.

| Variante BTI | Ce qu'elle permet (types de branchements) | Placement / cas d'utilisation typiques |
|-------------|----------------------------------------|-------------------------------|
| **BTI C** | Cibles des branches indirectes de style *call* (p.ex. `BLR`, ou `BR` utilisant X16/X17) | Placé à l'entrée des fonctions susceptibles d'être appelées indirectement |
| **BTI J** | Cibles des branches de style *jump* (p.ex. `BR` utilisé pour des tail-calls) | Placé au début des blocs accessibles par des jump tables ou des tail-calls |
| **BTI JC** | Agit à la fois comme C et J | Peut être ciblé par des branches de type call ou jump |

- Dans du code compilé avec enforcement des branch targets, les compilateurs insèrent une instruction BTI (C, J, ou JC) à chaque cible valide de branche indirecte (entrées de fonctions ou blocs accessibles par saut) afin que les branches indirectes ne réussissent que vers ces endroits.
- Les **branches / appels directs** (c.-à-d. les `B`, `BL` à adresse fixe) ne sont **pas restreints** par BTI. L'hypothèse est que les pages de code sont de confiance et que l'attaquant ne peut pas les modifier (donc les branches directes sont sûres).
- De plus, les instructions **RET / return** ne sont généralement pas restreintes par BTI parce que les adresses de retour sont protégées via PAC ou des mécanismes de signature de retour.

#### Mécanisme et application

- Quand le CPU décode une **branch indirecte (BLR / BR)** dans une page marquée « guarded / BTI-enabled », il vérifie si la première instruction de l'adresse cible est un BTI valide (C, J, ou JC selon autorisation). Si ce n'est pas le cas, une **Branch Target Exception** survient.
- L'encodage de l'instruction BTI est conçu pour réutiliser des opcodes précédemment réservés pour des NOPs (dans les versions ARM antérieures). Ainsi les binaires BTI-enabled restent rétro-compatibles : sur du matériel sans support BTI, ces instructions agissent comme des NOPs.
- Les passes du compilateur qui ajoutent des BTI les insèrent uniquement là où c'est nécessaire : fonctions susceptibles d'être appelées indirectement, ou blocs de base ciblés par des sauts.
- Certains patchs et du code LLVM montrent que BTI n'est pas inséré pour *tous* les blocs de base — seulement ceux qui sont des cibles potentielles de branchement (p.ex. depuis des switch / jump tables).

#### Synergie BTI + PAC

PAC protège la valeur du pointeur (la source) — assure que la chaîne d'appels/retours indirects n'a pas été modifiée.

BTI garantit que même un pointeur valide ne peut cibler que des points d'entrée correctement marqués.

Combinés, l'attaquant a besoin à la fois d'un pointeur valide avec le PAC correct et que la cible dispose d'un BTI placé à cet endroit. Cela augmente la difficulté de construction de gadgets exploitables.

#### Exemple


<details>
<summary>Exemple</summary>
Un exploit tente de pivoter vers un gadget à `0xABCDEF` qui ne commence pas par `BTI c`. Le CPU, lors de l'exécution de `blr x0`, vérifie la cible et provoque une faute parce que l'alignement de l'instruction n'inclut pas de landing pad valide. Ainsi beaucoup de gadgets deviennent inutilisables à moins d'inclure le préfixe BTI.
</details>


### 10. **Privileged Access Never (PAN) & Privileged Execute Never (PXN)**
**Introduit dans des extensions ARMv8 plus récentes / support iOS (pour noyau durci)**

#### PAN (Privileged Access Never)

- **PAN** est une fonctionnalité introduite dans **ARMv8.1-A** qui empêche le code **privilégié** (EL1 ou EL2) de **lire ou écrire** des zones mémoires marquées comme **accessibles par l'utilisateur (EL0)**, sauf si PAN est explicitement désactivé.
- L'idée : même si le noyau est trompé ou compromis, il ne peut pas déréférencer arbitrairement des pointeurs user-space sans d'abord *clear* PAN, réduisant ainsi les risques d'exploits de type **ret2usr** ou d'abus de buffers contrôlés par l'utilisateur.
- Quand PAN est activé (PSTATE.PAN = 1), toute instruction privilégiée de load/store accédant à une adresse virtuelle « accessible à EL0 » déclenche une **permission fault**.
- Le noyau, quand il doit légitimement accéder à la mémoire utilisateur (p.ex. copier des données depuis/vers des buffers utilisateur), doit **désactiver temporairement PAN** (ou utiliser des instructions de load/store non privilégiées) pour permettre cet accès.
- Sur Linux ARM64, le support de PAN a été introduit vers 2015 : des patches noyau ont ajouté la détection de la fonctionnalité, et remplacé `get_user` / `put_user` etc. par des variantes qui clear PAN autour des accès mémoire utilisateur.

**Nuance / limitation / bug important**
- Comme noté par Siguza et d'autres, un bug de spécification (ou un comportement ambigu) dans la conception ARM signifie que les mappings utilisateur execute-only (`--x`) peuvent **ne pas déclencher PAN**. Autrement dit, si une page user est marquée exécutable mais sans permission de lecture, la tentative de lecture du noyau pourrait contourner PAN parce que l'architecture considère que « accessible à EL0 » nécessite la permission de lecture, pas seulement d'exécution. Cela conduit à un contournement de PAN dans certaines configurations.
- À cause de cela, si iOS / XNU permet des pages utilisateur execute-only (comme certains setups JIT ou code-caches), le noyau pourrait lire accidentellement depuis elles même avec PAN activé. C'est une zone connue et subtilement exploitable dans certains systèmes ARMv8+.

#### PXN (Privileged eXecute Never)

- **PXN** est un drapeau de page table (dans les entrées de table des pages, leaf ou block entries) qui indique que la page est **non exécutable en mode privilégié** (c.-à-d. quand EL1 exécute).
- PXN empêche le noyau (ou tout code privilégié) de sauter vers ou d'exécuter des instructions provenant de pages user même si le contrôle est détourné. En pratique, cela bloque une redirection de contrôle au niveau noyau vers la mémoire user.
- Combiné avec PAN, cela assure que :
1. Le noyau ne peut pas (par défaut) lire ou écrire des données user (PAN)
2. Le noyau ne peut pas exécuter de code user (PXN)
- Dans le format de page table ARMv8, les entrées leaf ont un bit `PXN` (et aussi `UXN` pour unprivileged execute-never) dans leurs bits d'attribut.

Donc même si le noyau a un pointeur de fonction corrompu pointant vers la mémoire user, et qu'il tente de brancher là-bas, le bit PXN provoquerait une faute.

#### Modèle de permissions mémoire & comment PAN et PXN se mappent aux bits de page table

Pour comprendre comment PAN / PXN fonctionnent, il faut voir comment la traduction et le modèle de permissions ARM fonctionnent (simplifié) :

- Chaque entrée de page ou block a des champs d'attribut incluant **AP[2:1]** pour les permissions d'accès (lecture/écriture, privilégié vs non-privé) et les bits **UXN / PXN** pour les restrictions d'exécution.
- Quand PSTATE.PAN est 1 (activé), le hardware applique une sémantique modifiée : les accès privilégiés aux pages marquées « accessibles par EL0 » (c.-à-d. user-accessible) sont interdits (fault).
- À cause du bug mentionné, les pages marquées uniquement exécutables (sans permission de lecture) peuvent ne pas être considérées comme « accessibles par EL0 » sous certaines implémentations, contournant ainsi PAN.
- Quand une page a le bit PXN défini, même si la fetch d'instruction vient d'un niveau de privilège supérieur, l'exécution est interdite.

#### Usage noyau de PAN / PXN dans un OS hardeni (p.ex. iOS / XNU)

Dans une conception de noyau hardeni (comme ce que Apple pourrait utiliser) :

- Le noyau active PAN par défaut (donc le code privilégié est contraint).
- Dans les chemins qui ont légitimement besoin de lire ou écrire des buffers utilisateur (p.ex. copie de buffers de syscall, I/O, read/write d'un pointeur utilisateur), le noyau **désactive temporairement PAN** ou utilise des instructions spéciales pour contourner.
- Après avoir fini l'accès aux données utilisateur, il doit réactiver PAN.
- PXN est appliqué via les page tables : les pages user ont PXN = 1 (donc le noyau ne peut pas exécuter depuis elles), les pages kernel n'ont pas PXN (donc le code noyau peut s'exécuter).
- Le noyau doit s'assurer qu'aucun chemin d'exécution ne conduit à exécuter du code dans des régions user (ce qui contournerait PXN) — donc les chaînes d'exploit qui reposent sur « sauter dans du shellcode contrôlé par l'utilisateur » sont bloquées.

À cause du contournement PAN via les pages execute-only, dans un système réel Apple pourrait désactiver ou interdire les pages user execute-only, ou corriger autour de la faiblesse de spécification.

#### Surfaces d'attaque, contournements et mitigations

- **Contournement PAN via pages execute-only** : comme discuté, la spec laisse un espace : les pages user en execute-only (sans permission de lecture) peuvent ne pas être considérées comme « accessibles à EL0 », donc PAN ne bloquera pas les lectures du noyau sous certaines implémentations. Cela donne à l'attaquant un chemin inhabituel pour fournir des données via des sections « execute-only ».
- **Exploitation de fenêtre temporelle** : si le noyau désactive PAN pour une fenêtre plus longue que nécessaire, une course ou un chemin malveillant pourrait exploiter cette fenêtre pour effectuer des accès mémoire user non intentionnés.
- **Oubli de réactivation** : si des chemins de code ne réactivent pas PAN, des opérations noyau ultérieures pourraient accéder incorrectement à la mémoire user.
- **Mauvaise configuration de PXN** : si les page tables ne définissent pas PXN sur les pages user ou mappent incorrectement des pages de code user, le noyau pourrait être trompé pour exécuter du code user.
- **Spéculation / canaux auxiliaires** : analogue aux contournements par spéculation, il peut exister des effets microarchitecturaux transitoires qui violent PAN / PXN (bien que de tels attaques dépendent fortement du design du CPU).
- **Interactions complexes** : dans des fonctionnalités avancées (p.ex. JIT, mémoire partagée, zones de code générées à la volée), le noyau peut nécessiter un contrôle fin pour autoriser certains accès mémoire ou exécutions dans des régions mappées user ; concevoir cela en sécurité sous contraintes PAN/PXN n'est pas trivial.

#### Exemple

<details>
<summary>Exemple de code</summary>
Voici des séquences pseudo-assembly illustratives montrant l'activation/désactivation de PAN autour d'un accès mémoire user, et comment une faute pourrait se produire.
</details>
```  
// Suppose kernel entry point, PAN is enabled (privileged code cannot access user memory by default)

; Kernel receives a syscall with user pointer in X0
; wants to read an integer from user space
mov   X1, X0        ; X1 = user pointer

; disable PAN to allow privileged access to user memory
MSR   PSTATE.PAN, #0   ; clear PAN bit, disabling the restriction

ldr   W2, [X1]       ; now allowed load from user address

; re-enable PAN before doing other kernel logic
MSR   PSTATE.PAN, #1   ; set PAN

; ... further kernel work ...

; Later, suppose an exploit corrupts a pointer to a user-space code page and jumps there
BR    X3             ; branch to X3 (which points into user memory)

; Because the target page is marked PXN = 1 for privileged execution,
; the CPU throws an exception (fault) and rejects execution
```
Si le noyau n'avait **pas** défini PXN sur cette page utilisateur, alors le branchement pourrait réussir — ce qui serait non sécurisé.

Si le noyau oublie de réactiver PAN après un accès mémoire utilisateur, cela ouvre une fenêtre où la logique du noyau ultérieure pourrait accidentellement lire/écrire de la mémoire utilisateur arbitraire.

Si le pointeur utilisateur pointe vers une page à exécution seule (page utilisateur avec seulement la permission d'exécution, pas de lecture/écriture), sous le bug de spécification PAN, `ldr W2, [X1]` pourrait **ne pas** provoquer d'exception même avec PAN activé, permettant un contournement/exploit selon l'implémentation.

</details>

<details>
<summary>Exemple</summary>
Une vulnérabilité du noyau tente de prendre un pointeur de fonction fourni par l'utilisateur et de l'appeler dans le contexte du noyau (c.-à-d. `call user_buffer`). Sous PAN/PXN, cette opération est interdite ou provoque une exception.
</details>

---

### 11. **Top Byte Ignore (TBI) / Pointer Tagging**
**Introduit dans ARMv8.5 / versions ultérieures (ou extension optionnelle)**
TBI signifie que l'octet supérieur (octet de poids fort) d'un pointeur 64 bits est ignoré par la traduction d'adresses. Cela permet à l'OS ou au matériel d'embarquer des **tag bits** dans l'octet supérieur du pointeur sans affecter l'adresse réelle.

- TBI signifie **Top Byte Ignore** (parfois appelé *Address Tagging*). C'est une fonctionnalité matérielle (disponible dans de nombreuses implémentations ARMv8+) qui **ignore les 8 bits supérieurs** (bits 63:56) d'un pointeur 64 bits lors de la **traduction d'adresse / load/store / récupération d'instruction**.
- En pratique, le CPU traite un pointeur `0xTTxxxx_xxxx_xxxx` (où `TT` = octet supérieur) comme `0x00xxxx_xxxx_xxxx` pour la traduction d'adresse, en ignorant (masquant) l'octet supérieur. L'octet supérieur peut être utilisé par le logiciel pour stocker des **métadonnées / tag bits**.
- Cela donne au logiciel un espace « gratuit » en bande pour intégrer un octet de tag dans chaque pointeur sans modifier la localisation mémoire référencée.
- L'architecture garantit que les loads, stores et la récupération d'instruction traitent le pointeur avec son octet supérieur masqué (c.-à-d. tag retiré) avant d'effectuer l'accès mémoire réel.

Ainsi, TBI découple le **pointeur logique** (pointeur + tag) de l'**adresse physique** utilisée pour les opérations mémoire.

#### Why TBI: Use cases and motivation

- **Pointer tagging / metadata** : Vous pouvez stocker des métadonnées supplémentaires (par ex. type d'objet, version, limites, tags d'intégrité) dans cet octet supérieur. Quand vous utilisez ensuite le pointeur, le tag est ignoré au niveau matériel, donc vous n'avez pas besoin de le retirer manuellement pour l'accès mémoire.
- **Memory tagging / MTE (Memory Tagging Extension)** : TBI est le mécanisme matériel de base sur lequel MTE s'appuie. Dans ARMv8.5, la **Memory Tagging Extension** utilise les bits 59:56 du pointeur comme **tag logique** et les compare à un **allocation tag** stocké en mémoire.
- **Sécurité et intégrité renforcées** : En combinant TBI avec pointer authentication (PAC) ou des vérifications à l'exécution, vous pouvez exiger non seulement la valeur du pointeur mais aussi que le tag soit correct. Un attaquant qui écrase un pointeur sans le tag correct produira un tag non concordant.
- **Compatibilité** : Comme TBI est optionnel et que les bits de tag sont ignorés par le matériel, le code existant non taggé continue de fonctionner normalement. Les bits de tag deviennent en pratique des bits « indifférents » pour le code legacy.

#### Example
<details>
<summary>Exemple</summary>
Un pointeur de fonction comportait un tag dans son octet supérieur (par ex. `0xAA`). Un exploit écrase les bits faibles du pointeur mais néglige le tag, si bien que lorsque le noyau vérifie ou assainit, le pointeur échoue ou est rejeté.
</details>

---

### 12. **Page Protection Layer (PPL)**
**Introduit dans les dernières versions d'iOS / matériel moderne (iOS ~17 / Apple silicon / modèles haut de gamme)** (certains rapports montrent PPL autour de macOS / Apple silicon, mais Apple apporte des protections analogues à iOS)

- PPL est conçu comme une **barrière de protection intra-noyau** : même si le noyau (EL1) est compromis et dispose de capacités de lecture/écriture, **il ne devrait pas être en mesure de modifier librement** certaines **pages sensibles** (notamment les tables de pages, les métadonnées de signature de code, les pages de code du noyau, les entitlements, les trust caches, etc.).
- Il crée en pratique un **« noyau dans le noyau »** — un composant plus petit de confiance (PPL) avec des **privilèges élevés** qui seul peut modifier les pages protégées. Le reste du code du noyau doit appeler des routines PPL pour effectuer des modifications.
- Cela réduit la surface d'attaque pour les exploits du noyau : même avec un accès R/W/exécution arbitraire en mode noyau, le code d'exploit doit aussi d'une manière ou d'une autre pénétrer dans le domaine PPL (ou contourner PPL) pour modifier les structures critiques.
- Sur les nouveaux Apple silicon (A15+ / M2+), Apple migre vers **SPTM (Secure Page Table Monitor)**, qui dans de nombreux cas remplace PPL pour la protection des tables de pages sur ces plateformes.

Voici comment on pense que PPL fonctionne, d'après l'analyse publique :

#### Use of APRR / permission routing (APRR = Access Permission ReRouting)

- Le matériel Apple utilise un mécanisme appelé **APRR (Access Permission ReRouting)**, qui permet aux entrées de table de pages (PTEs) de contenir de petits indices, plutôt que des bits de permission complets. Ces indices sont mappés via des registres APRR vers des permissions effectives. Cela permet le remappage dynamique des permissions par domaine.
- PPL exploite APRR pour ségréger les privilèges dans le contexte du noyau : seul le domaine PPL est autorisé à mettre à jour la correspondance entre indices et permissions effectives. Autrement dit, quand du code noyau non-PPL écrit une PTE ou tente de changer des bits de permission, la logique APRR le refuse (ou impose un mapping en lecture seule).
- Le code PPL lui-même s'exécute dans une région restreinte (p.ex. `__PPLTEXT`) qui est normalement non exécutable ou non modifiable jusqu'à ce que des portes d'entrée l'autorisent temporairement. Le noyau appelle des points d'entrée PPL (« routines PPL ») pour effectuer des opérations sensibles.

#### Gate / Entry & Exit

- Quand le noyau a besoin de modifier une page protégée (p.ex. changer les permissions d'une page de code du noyau, ou modifier les tables de pages), il appelle une routine **PPL wrapper**, qui effectue des validations puis effectue la transition vers le domaine PPL. En dehors de ce domaine, les pages protégées sont effectivement en lecture seule ou non modifiables par le noyau principal.
- Pendant l'entrée en PPL, les mappings APRR sont ajustés afin que les pages mémoire dans la région PPL soient définies comme **exécutables & modifiables** au sein de PPL. À la sortie, elles sont remises en lecture seule / non modifiables. Cela garantit que seules des routines PPL bien auditées peuvent écrire dans les pages protégées.
- Hors PPL, les tentatives du code noyau pour écrire sur ces pages protégées provoqueront une erreur (permission denied) parce que le mapping APRR pour ce domaine de code n'autorise pas l'écriture.

#### Protected page categories

Les pages que PPL protège typiquement incluent :

- Structures des tables de pages (entrées de table de traduction, métadonnées de mapping)
- Pages de code du noyau, en particulier celles contenant la logique critique
- Métadonnées de signature de code (trust caches, blobs de signature)
- Tables d'entitlements, tables d'application des signatures
- Autres structures noyau de haute valeur où un patch permettrait de contourner les vérifications de signature ou de manipuler des credentials

L'idée est que même si la mémoire du noyau est entièrement contrôlée, l'attaquant ne peut pas simplement patcher ou réécrire ces pages, sauf s'il compromet aussi les routines PPL ou contourne PPL.

#### Known Bypasses & Vulnerabilities

1. **Project Zero’s PPL bypass (stale TLB trick)**

- Un writeup public de Project Zero décrit un contournement impliquant des **entrées TLB périmées**.
- L'idée :

1. Allouer deux pages physiques A et B, les marquer comme pages PPL (donc protégées).
2. Mapper deux adresses virtuelles P et Q dont les pages de table de traduction L3 proviennent de A et B.
3. Lancer un thread qui accède en continu à Q, gardant son entrée TLB vivante.
4. Appeler `pmap_remove_options()` pour supprimer les mappings à partir de P ; à cause d'un bug, le code supprime par erreur les TTEs pour P et Q, mais n'invalide que l'entrée TLB pour P, laissant l'entrée périmée de Q active.
5. Réutiliser B (la table de Q) pour mapper de la mémoire arbitraire (p.ex. des pages protégées par PPL). Comme l'entrée TLB périmée mappe toujours l'ancien mapping de Q, ce mapping reste valide pour ce contexte.
6. Grâce à cela, l'attaquant peut mettre en place un mapping modifiable de pages protégées par PPL sans passer par l'interface PPL.

- Cet exploit nécessitait un contrôle fin du mapping physique et du comportement du TLB. Il démontre qu'une frontière de sécurité reposant sur la justesse des TLB/mapping doit être extrêmement prudente quant aux invalidations de TLB et à la cohérence des mappings.

- Project Zero a noté que des contournements de ce type sont subtils et rares, mais possibles dans des systèmes complexes. Néanmoins, ils considèrent PPL comme une mitigation solide.

2. **Other potential hazards & constraints**

- Si un exploit du noyau peut entrer directement dans les routines PPL (via l'appel des wrappers PPL), il pourrait contourner les restrictions. La validation des arguments est donc cruciale.
- Des bugs dans le code PPL lui-même (p.ex. overflow arithmétique, contrôles de bornes) peuvent permettre des modifications hors-borne à l'intérieur de PPL. Project Zero a observé qu'un tel bug dans `pmap_remove_options_internal()` a été exploité dans leur contournement.
- La frontière PPL est irrévocablement liée à l'application matérielle (APRR, contrôleur mémoire), donc elle n'est aussi solide que l'implémentation matérielle.

#### Example
<details>
<summary>Exemple de code</summary>
Voici un pseudocode / logique simplifiée montrant comment un noyau pourrait appeler PPL pour modifier des pages protégées :
</details>
```c
// In kernel (outside PPL domain)
function kernel_modify_pptable(pt_addr, new_entry) {
// validate arguments, etc.
return ppl_call_modify(pt_addr, new_entry)  // call PPL wrapper
}

// In PPL (trusted domain)
function ppl_call_modify(pt_addr, new_entry) {
// temporarily enable write access to protected pages (via APRR adjustments)
aprr_set_index_for_write(PPL_INDEX)
// perform the modification
*pt_addr = new_entry
// restore permissions (make pages read-only again)
aprr_restore_default()
return success
}

// If kernel code outside PPL does:
*pt_addr = new_entry  // a direct write
// It will fault because APRR mapping for non-PPL domain disallows write to that page
```
The kernel can do many normal operations, but only through `ppl_call_*` routines can it change protected mappings or patch code.
</details>

<details>
<summary>Example</summary>
A kernel exploit tries to overwrite the entitlement table, or disable code-sign enforcement by modifying a kernel signature blob. Because that page is PPL-protected, the write is blocked unless going through the PPL interface. So even with kernel code execution, you cannot bypass code-sign constraints or modify credential data arbitrarily.
On iOS 17+ certain devices use SPTM to further isolate PPL-managed pages.
</details>

#### PPL → SPTM / Replacements / Future

- On Apple’s modern SoCs (A15 or later, M2 or later), Apple supports **SPTM** (Secure Page Table Monitor), which **replaces PPL** for page table protections.
- Apple calls out in documentation: “Page Protection Layer (PPL) and Secure Page Table Monitor (SPTM) enforce execution of signed and trusted code … PPL manages the page table permission overrides … Secure Page Table Monitor replaces PPL on supported platforms.”
- The SPTM architecture likely shifts more policy enforcement into a higher-privileged monitor outside kernel control, further reducing the trust boundary.

### MTE | EMTE | MIE

Here’s a higher-level description of how EMTE operates under Apple’s MIE setup:

1. **Tag assignment**
- When memory is allocated (e.g. in kernel or user space via secure allocators), a **secret tag** is assigned to that block.
- The pointer returned to the user or kernel includes that tag in its high bits (using TBI / top byte ignore mechanisms).

2. **Tag checking on access**
- Whenever a load or store is executed using a pointer, the hardware checks that the pointer’s tag matches the memory block’s tag (allocation tag). If mismatch, it faults immediately (since synchronous).
- Because it's synchronous, there is no “delayed detection” window.

3. **Retagging on free / reuse**
- When memory is freed, the allocator changes the block’s tag (so older pointers with old tags no longer match).
- A use-after-free pointer would therefore have a stale tag and mismatch when accessed.

4. **Neighbor-tag differentiation to catch overflows**
- Adjacent allocations are given distinct tags. If a buffer overflow spills into neighbor’s memory, tag mismatch causes a fault.
- This is especially powerful in catching small overflows that cross boundary.

5. **Tag confidentiality enforcement**
- Apple must prevent tag values being leaked (because if attacker learns the tag, they could craft pointers with correct tags).
- They include protections (microarchitectural / speculative controls) to avoid side-channel leakage of tag bits.

6. **Kernel and user-space integration**
- Apple uses EMTE not just in user-space but also in kernel / OS-critical components (to guard kernel against memory corruption).
- The hardware/OS ensures tag rules apply even when kernel is executing on behalf of user space.

<details>
<summary>Example</summary>
```
Allocate A = 0x1000, assign tag T1
Allocate B = 0x2000, assign tag T2

// pointer P points into A with tag T1
P = (T1 << 56) | 0x1000

// Valid store
*(P + offset) = value // tag T1 matches allocation → allowed

// Overflow attempt: P’ = P + size_of_A (into B region)
*(P' + delta) = value
→ pointer includes tag T1 but memory block has tag T2 → mismatch → fault

// Free A, allocator retags it to T3
free(A)

// Use-after-free:
*(P) = value
→ pointer still has old tag T1, memory region is now T3 → mismatch → fault
```
</details>

#### Limitations & challenges

- **Intrablock overflows** : Si l’overflow reste dans la même allocation (ne franchit pas la frontière) et que le tag reste identique, le tag mismatch ne le détecte pas.
- **Tag width limitation** : Seuls quelques bits (p. ex. 4 bits, ou un petit domaine) sont disponibles pour le tag — namespace limité.
- **Side-channel leaks** : Si les bits de tag peuvent être leaked (via cache / speculative execution), un attaquant peut apprendre des tags valides et contourner la protection. L’enforcement de la confidentialité des tags par Apple vise à atténuer cela.
- **Performance overhead** : Les checks de tag à chaque load/store ajoutent un coût ; Apple doit optimiser le hardware pour réduire l’overhead.
- **Compatibility & fallback** : Sur du hardware plus ancien ou des composants qui ne supportent pas EMTE, il doit exister un fallback. Apple affirme que MIE n’est activé que sur les devices qui le supportent.
- **Complex allocator logic** : L’allocator doit gérer les tags, le retagging, l’alignement des frontières, et éviter les collisions de mis-tag. Des bugs dans la logique de l’allocator pourraient introduire des vulnérabilités.
- **Mixed memory / hybrid areas** : Certaines zones mémoire peuvent rester untagged (legacy), rendant l’interopérabilité plus délicate.
- **Speculative / transient attacks** : Comme pour beaucoup de protections microarchitecturales, la speculative execution ou des micro-op fusions pourraient bypasser les checks de façon transitoire ou leak des bits de tag.
- **Limited to supported regions** : Apple peut n’appliquer EMTE que dans des zones sélectives et à haut risque (kernel, subsystèmes critiques), pas universellement.



---

## Key enhancements / differences compared to standard MTE

Here are the improvements and changes Apple emphasizes:

| Feature | Original MTE | EMTE (Apple’s enhanced) / MIE |
|---|---|---|
| **Check mode** | Supports synchronous and asynchronous modes. In async, tag mismatches are reported later (delayed)| Apple insists on **synchronous mode** by default—tag mismatches are caught immediately, no delay/race windows allowed.|
| **Coverage of non-tagged memory** | Accesses to non-tagged memory (e.g. globals) may bypass checks in some implementations | EMTE requires that accesses from a tagged region to non-tagged memory also validate tag knowledge, making it harder to bypass by mixing allocations.|
| **Tag confidentiality / secrecy** | Tags might be observable or leaked via side channels | Apple adds **Tag Confidentiality Enforcement**, which attempts to prevent leakage of tag values (via speculative side-channels etc.).|
| **Allocator integration & retagging** | MTE leaves much of allocator logic to software | Apple’s secure typed allocators (kalloc_type, xzone malloc, etc.) integrate with EMTE: when memory is allocated or freed, tags are managed at fine granularity.|
| **Always-on by default** | In many platforms, MTE is optional or off by default | Apple enables EMTE / MIE by default on supported hardware (e.g. iPhone 17 / A19) for kernel and many user processes.|

Parce qu’Apple contrôle à la fois le hardware et la stack software, elle peut appliquer EMTE strictement, éviter les pièges de performance et colmater les trous de side-channel.

---

## How EMTE works in practice (Apple / MIE)

Here’s a higher-level description of how EMTE operates under Apple’s MIE setup:

1. **Tag assignment**
- When memory is allocated (e.g. in kernel or user space via secure allocators), a **secret tag** is assigned to that block.
- The pointer returned to the user or kernel includes that tag in its high bits (using TBI / top byte ignore mechanisms).

2. **Tag checking on access**
- Whenever a load or store is executed using a pointer, the hardware checks that the pointer’s tag matches the memory block’s tag (allocation tag). If mismatch, it faults immediately (since synchronous).
- Because it's synchronous, there is no “delayed detection” window.

3. **Retagging on free / reuse**
- When memory is freed, the allocator changes the block’s tag (so older pointers with old tags no longer match).
- A use-after-free pointer would therefore have a stale tag and mismatch when accessed.

4. **Neighbor-tag differentiation to catch overflows**
- Adjacent allocations are given distinct tags. If a buffer overflow spills into neighbor’s memory, tag mismatch causes a fault.
- This is especially powerful in catching small overflows that cross boundary.

5. **Tag confidentiality enforcement**
- Apple must prevent tag values being leaked (because if attacker learns the tag, they could craft pointers with correct tags).
- They include protections (microarchitectural / speculative controls) to avoid side-channel leakage of tag bits.

6. **Kernel and user-space integration**
- Apple uses EMTE not just in user-space but also in kernel / OS-critical components (to guard kernel against memory corruption).
- The hardware/OS ensures tag rules apply even when kernel is executing on behalf of user space.

Because EMTE is built into MIE, Apple uses EMTE in synchronous mode across key attack surfaces, not as opt-in or debugging mode.



---

## Exception handling in XNU

When an **exception** occurs (e.g., `EXC_BAD_ACCESS`, `EXC_BAD_INSTRUCTION`, `EXC_CRASH`, `EXC_ARM_PAC`, etc.), the **Mach layer** of the XNU kernel is responsible for intercepting it before it becomes a UNIX-style **signal** (like `SIGSEGV`, `SIGBUS`, `SIGILL`, ...).

This process involves multiple layers of exception propagation and handling before reaching user space or being converted to a BSD signal.


### Exception Flow (High-Level)

1.  **CPU triggers a synchronous exception** (e.g., invalid pointer dereference, PAC failure, illegal instruction, etc.).

2.  **Low-level trap handler** runs (`trap.c`, `exception.c` in XNU source).

3.  The trap handler calls **`exception_triage()`**, the core of the Mach exception handling.

4.  `exception_triage()` decides how to route the exception:

-   First to the **thread's exception port**.

-   Then to the **task's exception port**.

-   Then to the **host's exception port** (often `launchd` or `ReportCrash`).

If none of these ports handle the exception, the kernel may:

-   **Convert it into a BSD signal** (for user-space processes).

-   **Panic** (for kernel-space exceptions).


### Core Function: `exception_triage()`

The function `exception_triage()` routes Mach exceptions up the chain of possible handlers until one handles it or until it's finally fatal. It's defined in `osfmk/kern/exception.c`.
```c
void exception_triage(exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt);
```
**Flux d'appels typique :**

`exception_triage()
└── exception_deliver()
├── exception_deliver_thread()
├── exception_deliver_task()
└── exception_deliver_host()`

Si tout échoue → pris en charge par `bsd_exception()` → traduit en un signal comme `SIGSEGV`.


### Ports d'exception

Chaque objet Mach (thread, task, host) peut enregistrer des **ports d'exception**, où sont envoyés les messages d'exception.

Ils sont définis par l'API :
```
task_set_exception_ports()
thread_set_exception_ports()
host_set_exception_ports()
```
Chaque exception port a :

-   A **mask** (quelles exceptions il souhaite recevoir)
-   A **port name** (Mach port pour recevoir les messages)
-   A **behavior** (comment le kernel envoie le message)
-   A **flavor** (quel état du thread inclure)


### Débogueurs et gestion des exceptions

Un **débogueur** (par ex., LLDB) définit un **exception port** sur la task ou le thread cible, généralement en utilisant `task_set_exception_ports()`.

Lorsque une exception se produit :

-   Le message Mach est envoyé au processus du débogueur.
-   Le débogueur peut décider de **gérer** (reprendre, modifier les registres, sauter l'instruction) ou de **ne pas gérer** l'exception.
-   Si le débogueur ne la gère pas, l'exception se propage au niveau suivant (task → host).


### Flux de `EXC_BAD_ACCESS`

1.  Le thread déréférence un pointeur invalide → le CPU déclenche un Data Abort.

2.  Le gestionnaire de trap du kernel appelle `exception_triage(EXC_BAD_ACCESS, ...)`.

3.  Message envoyé à :

-   Thread port → (le débogueur peut intercepter un breakpoint).

-   Si le débogueur ignore → Task port → (handler au niveau du process).

-   Si ignoré → Host port (généralement ReportCrash).

4.  Si personne ne gère → `bsd_exception()` traduit en `SIGSEGV`.


### Exceptions PAC

Lorsque la **Pointer Authentication** (PAC) échoue (non-correspondance de la signature), une **exception Mach spéciale** est levée :

-   **`EXC_ARM_PAC`** (type)
-   Les codes peuvent inclure des détails (p.ex., type de clé, type de pointeur).

Si le binaire a le flag **`TFRO_PAC_EXC_FATAL`**, le kernel traite les échecs PAC comme **fatals**, contournant l'interception par le débogueur. Ceci évite que des attaquants utilisent des débogueurs pour contourner les vérifications PAC et c'est activé pour les **platform binaries**.


### Breakpoints logiciels

Un breakpoint logiciel (`int3` on x86, `brk` on ARM64) est implémenté en **provoquant une faute délibérée**.\
Le débogueur la capture via l'exception port :

-   Modifie le pointeur d'instruction ou la mémoire.
-   Restaure l'instruction originale.
-   Reprend l'exécution.

Ce même mécanisme permet de "capturer" une exception PAC --- **sauf si `TFRO_PAC_EXC_FATAL`** est défini, auquel cas elle n'atteint jamais le débogueur.


### Conversion vers les signaux BSD

Si aucun handler n'accepte l'exception :

-   Le kernel appelle `task_exception_notify() → bsd_exception()`.

-   Cela mappe les exceptions Mach vers des signaux :

| Exception Mach | Signal |
| --- | --- |
| EXC_BAD_ACCESS | SIGSEGV or SIGBUS |
| EXC_BAD_INSTRUCTION | SIGILL |
| EXC_ARITHMETIC | SIGFPE |
| EXC_SOFTWARE | SIGTRAP |
| EXC_BREAKPOINT | SIGTRAP |
| EXC_CRASH | SIGKILL |
| EXC_ARM_PAC | SIGILL (si non-fatal) |


### Fichiers clés dans le code source XNU

-   `osfmk/kern/exception.c` → Cœur de `exception_triage()`, `exception_deliver_*()`.
-   `bsd/kern/kern_sig.c` → Logique de livraison des signaux.
-   `osfmk/arm64/trap.c` → Gestionnaires bas niveau de traps.
-   `osfmk/mach/exc.h` → Codes et structures d'exception.
-   `osfmk/kern/task.c` → Configuration des exception ports de task.

---

## Ancien heap du kernel (ère pré-iOS 15 / pré-A12)

Le kernel utilisait un **zone allocator** (`kalloc`) divisé en "zones" de taille fixe.  
Chaque zone stockait uniquement des allocations d'une seule classe de taille.

D'après la capture d'écran :

| Nom de la zone            | Taille de l'élément | Exemple d'utilisation                                                       |
|--------------------------|---------------------|------------------------------------------------------------------------------|
| `default.kalloc.16`      | 16 octets           | Très petites structures kernel, pointeurs.                                   |
| `default.kalloc.32`      | 32 octets           | Petites structures, en-têtes d'objets.                                      |
| `default.kalloc.64`      | 64 octets           | Messages IPC, petits buffers kernel.                                        |
| `default.kalloc.128`     | 128 octets          | Objets de taille moyenne comme des parties de `OSObject`.                   |
| …                        | …                   | …                                                                            |
| `default.kalloc.1280`    | 1280 octets         | Grandes structures, metadata IOSurface/graphics.                            |

Comment ça fonctionnait :
- Chaque requête d'allocation est **arrondie à la hausse** vers la taille de zone la plus proche. (p.ex., une requête de 50 octets se retrouve dans la zone `kalloc.64`).
- La mémoire dans chaque zone était conservée dans une **freelist** — les chunks libérés par le kernel retournaient dans cette zone.
- Si vous débordiez un buffer de 64 octets, vous écraseriez l'**objet suivant dans la même zone**.

C'est pourquoi le **heap spraying / feng shui** était si efficace : on pouvait prédire les voisins d'un objet en effectuant des allocations de la même classe de taille.

### La freelist

Dans chaque zone kalloc, les objets libérés n'étaient pas renvoyés directement au système — ils allaient dans une freelist, une liste chaînée de chunks disponibles.

- Quand un chunk était libéré, le kernel écrivait un pointeur au début de ce chunk → l'adresse du prochain chunk libre dans la même zone.

- La zone conservait un pointeur HEAD vers le premier chunk libre.

- L'allocation utilisait toujours le HEAD courant :

1. Extraire HEAD (retourner cette mémoire à l'appelant).

2. Mettre à jour HEAD = HEAD->next (stocké dans l'en-tête du chunk libéré).

- La libération repoussait les chunks :

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

Ainsi, la freelist n'était qu'une liste chaînée construite à l'intérieur de la mémoire libérée elle-même.

État normal :
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Exploitation du freelist

Parce que les 8 premiers octets d'un chunk libre correspondent au freelist pointer, un attaquant peut le corrompre :

1. **Heap overflow** dans un chunk libéré adjacent → écraser son pointeur “next”.

2. **Use-after-free** : écrire dans un objet libéré → écraser son pointeur “next”.

Ensuite, lors de la prochaine allocation de cette taille :

- L'allocateur dépile le chunk corrompu.
- Suit le pointeur “next” fourni par l'attaquant.
- Retourne un pointeur vers de la mémoire arbitraire, permettant des primitives d'objet factices ou un écrasement ciblé.

Exemple visuel de freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
This freelist design made exploitation highly effective pre-hardening: predictable neighbors from heap sprays, raw pointer freelist links, and no type separation allowed attackers to escalate UAF/overflow bugs into arbitrary kernel memory control.

### Heap Grooming / Feng Shui
The goal of heap grooming is to **shape the heap layout** so that when an attacker triggers an overflow or use-after-free, the target (victim) object sits right next to an attacker-controlled object.\
That way, when memory corruption happens, the attacker can reliably overwrite the victim object with controlled data.

**Steps:**

1. Spray allocations (fill the holes)
- Over time, the kernel heap gets fragmented: some zones have holes where old
objects were freed.
- The attacker first makes lots of dummy allocations to fill these gaps, so
the heap becomes “packed” and predictable.

2. Force new pages
- Once the holes are filled, the next allocations must come from new pages
added to the zone.
- Fresh pages mean objects will be clustered together, not scattered across
old fragmented memory.
- This gives the attacker much better control of neighbors.

3. Place attacker objects
- The attacker now sprays again, creating lots of attacker-controlled objects
in those new pages.
- These objects are predictable in size and placement (since they all belong
to the same zone).

4. Free a controlled object (make a gap)
- The attacker deliberately frees one of their own objects.
- This creates a “hole” in the heap, which the allocator will later reuse for
the next allocation of that size.

5. Victim object lands in the hole
- The attacker triggers the kernel to allocate the victim object (the one
they want to corrupt).
- Since the hole is the first available slot in the freelist, the victim is
placed exactly where the attacker freed their object.

6. Overflow / UAF into victim
- Now the attacker has attacker-controlled objects around the victim.
- By overflowing from one of their own objects (or reusing a freed one), they
can reliably overwrite the victim’s memory fields with chosen values.

**Why it works**:

- Zone allocator predictability: allocations of the same size always come from
the same zone.
- Freelist behavior: new allocations reuse the most recently freed chunk first.
- Heap sprays: attacker fills memory with predictable content and controls layout.
- End result: attacker controls where the victim object lands and what data sits
next to it.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple hardened the allocator and made **heap grooming much harder**:

### 1. From Classic kalloc to kalloc_type
- **Before**: a single `kalloc.<size>` zone existed for each size class (16, 32, 64, … 1280, etc.). Any object of that size was placed there → attacker objects could sit next to privileged kernel objects.
- **Now**:
- Kernel objects are allocated from **typed zones** (`kalloc_type`).
- Each type of object (e.g., `ipc_port_t`, `task_t`, `OSString`, `OSData`) has its own dedicated zone, even if they’re the same size.
- The mapping between object type ↔ zone is generated from the **kalloc_type system** at compile time.

An attacker can no longer guarantee that controlled data (`OSData`) ends up adjacent to sensitive kernel objects (`task_t`) of the same size.

### 2. Slabs and Per-CPU Caches
- The heap is divided into **slabs** (pages of memory carved into fixed-size chunks for that zone).
- Each zone has a **per-CPU cache** to reduce contention.
- Allocation path:
1. Try per-CPU cache.
2. If empty, pull from the global freelist.
3. If freelist is empty, allocate a new slab (one or more pages).
- **Benefit**: This decentralization makes heap sprays less deterministic, since allocations may be satisfied from different CPUs’ caches.

### 3. Randomization inside zones
- Within a zone, freed elements are not handed back in simple FIFO/LIFO order.
- Modern XNU uses **encoded freelist pointers** (safe-linking like Linux, introduced ~iOS 14).
- Each freelist pointer is **XOR-encoded** with a per-zone secret cookie.
- This prevents attackers from forging a fake freelist pointer if they gain a write primitive.
- Some allocations are **randomized in their placement within a slab**, so spraying doesn’t guarantee adjacency.

### 4. Guarded Allocations
- Certain critical kernel objects (e.g., credentials, task structures) are allocated in **guarded zones**.
- These zones insert **guard pages** (unmapped memory) between slabs or use **redzones** around objects.
- Any overflow into the guard page triggers a fault → immediate panic instead of silent corruption.

### 5. Page Protection Layer (PPL) and SPTM
- Even if you control a freed object, you can’t modify all of kernel memory:
- **PPL (Page Protection Layer)** enforces that certain regions (e.g., code signing data, entitlements) are **read-only** even to the kernel itself.
- On **A15/M2+ devices**, this role is replaced/enhanced by **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- These hardware-enforced layers mean attackers can’t escalate from a single heap corruption to arbitrary patching of critical security structures.
- **(Added / Enhanced)**: also, **PAC (Pointer Authentication Codes)** is used in the kernel to protect pointers (especially function pointers, vtables) so that forging or corrupting them becomes harder.
- **(Added / Enhanced)**: zones may enforce **zone_require / zone enforcement**, i.e. that an object freed can only be returned through its correct typed zone; invalid cross-zone frees may panic or be rejected. (Apple alludes to this in their memory safety posts)

### 6. Large Allocations
- Not all allocations go through `kalloc_type`.
- Very large requests (above ~16 KB) bypass typed zones and are served directly from **kernel VM (kmem)** via page allocations.
- These are less predictable, but also less exploitable, since they don’t share slabs with other objects.

### 7. Allocation Patterns Attackers Target
Even with these protections, attackers still look for:
- **Reference count objects**: if you can tamper with retain/release counters, you may cause use-after-free.
- **Objects with function pointers (vtables)**: corrupting one still yields control flow.
- **Shared memory objects (IOSurface, Mach ports)**: these are still attack targets because they bridge user ↔ kernel.

But — unlike before — you can’t just spray `OSData` and expect it to neighbor a `task_t`. You need **type-specific bugs** or **info leaks** to succeed.

### Example: Allocation Flow in Modern Heap

Suppose userspace calls into IOKit to allocate an `OSData` object:

1. **Type lookup** → `OSData` maps to `kalloc_type_osdata` zone (size 64 bytes).
2. Check per-CPU cache for free elements.
- If found → return one.
- If empty → go to global freelist.
- If freelist empty → allocate a new slab (page of 4KB → 64 chunks of 64 bytes).
3. Return chunk to caller.

**Freelist pointer protection**:
- Each freed chunk stores the address of the next free chunk, but encoded with a secret key.
- Overwriting that field with attacker data won’t work unless you know the key.

---

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages, and **PAC** protects pointers |
| Allocation reuse validation     | None (freelist pointers raw)                               | **zone_require / zone enforcement**             |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |
| Large allocations handling      | All small allocations managed equally                       | Large ones bypass zones → handled via VM         |

---

## Modern Userland Heap (iOS, macOS — type-aware / xzone malloc)

In recent Apple OS versions (especially iOS 17+), Apple introduced a more secure userland allocator, **xzone malloc** (XZM). This is the user-space analog to the kernel’s `kalloc_type`, applying type awareness, metadata isolation, and memory tagging safeguards.

### Goals & Design Principles

- **Type segregation / type awareness**: group allocations by *type or usage (pointer vs data)* to prevent type confusion and cross-type reuse.
- **Metadata isolation**: separate heap metadata (e.g. free lists, size/state bits) from object payloads so that out-of-bounds writes are less likely to corrupt metadata.
- **Guard pages / redzones**: insert unmapped pages or padding around allocations to catch overflows.
- **Memory tagging (EMTE / MIE)**: work in conjunction with hardware tagging to detect use-after-free, out-of-bounds, and invalid accesses.
- **Scalable performance**: maintain low overhead, avoid excessive fragmentation, and support many allocations per second with low latency.

### Architecture & Components

Below are the main elements in the xzone allocator:

#### Segment Groups & Zones

- **Segment groups** partition the address space by usage categories: e.g. `data`, `pointer_xzones`, `data_large`, `pointer_large`.
- Each segment group contains **segments** (VM ranges) that host allocations for that category.
- Associated with each segment is a **metadata slab** (separate VM area) that stores metadata (e.g. free/used bits, size classes) for that segment. This **out-of-line (OOL) metadata** ensures that metadata is not intermingled with object payloads, mitigating corruption from overflows.
- Segments are carved into **chunks** (slices) which in turn are subdivided into **blocks** (allocation units). A chunk is tied to a specific size class and segment group (i.e. all blocks in a chunk share the same size & category).
- For small / medium allocations, it will use fixed-size chunks; for large/huges, it may map separately.

#### Chunks & Blocks

- A **chunk** is a region (often several pages) dedicated to allocations of one size class within a group.
- Inside a chunk, **blocks** are slots available for allocations. Freed blocks are tracked via the metadata slab — e.g. via bitmaps or free lists stored out-of-line.
- Between chunks (or within), **guard slices / guard pages** may be inserted (e.g. unmapped slices) to catch out-of-bounds writes.

#### Type / Type ID

- Every allocation site (or call to malloc, calloc, etc.) is associated with a **type identifier** (a `malloc_type_id_t`) which encodes what kind of object is being allocated. That type ID is passed to the allocator, which uses it to select which zone / segment to serve the allocation.
- Because of this, even if two allocations have the same size, they may go into entirely different zones if their types differ.
- In early iOS 17 versions, not all APIs (e.g. CFAllocator) were fully type-aware; Apple addressed some of those weaknesses in iOS 18.

---

### Allocation & Freeing Workflow

Here is a high-level flow of how allocation and deallocation operate in xzone:

1. **malloc / calloc / realloc / typed alloc** is invoked with a size and type ID.
2. The allocator uses the **type ID** to pick the correct segment group / zone.
3. Within that zone/segment, it seeks a chunk that has free blocks of the requested size.
- It may consult **local caches / per-thread pools** or **free block lists** from metadata.
- If no free block is available, it may allocate a new chunk in that zone.
4. The metadata slab is updated (free bit cleared, bookkeeping).
5. If memory tagging (EMTE) is in play, the returned block gets a **tag** assigned, and metadata is updated to reflect its “live” state.
6. When `free()` is called:
- The block is marked as freed in metadata (via OOL slab).
- The block may be placed into a free list or pooled for reuse.
- Optionally, block contents may be cleared or poisoned to reduce data leaks or use-after-free exploitation.
- The hardware tag associated with the block may be invalidated or re-tagged.
- If an entire chunk becomes free (all blocks freed), the allocator may **reclaim** that chunk (unmap it or return to OS) under memory pressure.

---

### Security Features & Hardening

These are the defenses built into modern userland xzone:

| Feature | Purpose | Notes |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | Prevent overflow from corrupting metadata | Metadata lives in separate VM region (metadata slab)|
| **Guard pages / unmapped slices** | Catch out-of-bounds writes | Helps detect buffer overflows rather than silently corrupting adjacent blocks|
| **Type-based segregation** | Prevent cross-type reuse & type confusion | Even same-size allocations from different types go to different zones|
| **Memory Tagging (EMTE / MIE)** | Detect invalid access, stale references, OOB, UAF | xzone works in concert with hardware EMTE in synchronous mode (“Memory Integrity Enforcement”)|
| **Delayed reuse / poisoning / zap** | Reduce chance of use-after-free exploitation | Freed blocks may be poisoned, zeroed, or quarantined before reuse |
| **Chunk reclamation / dynamic unmapping** | Reduce memory waste and fragmentation | Entire chunks may be unmapped when unused |
| **Randomization / placement variation** | Prevent deterministic adjacency | Blocks in a chunk and chunk selection may have randomized aspects |
| **Segregation of “data-only” allocations** | Separate allocations that don’t store pointers | Reduces attacker control over metadata or control fields|

---

### Interaction with Memory Integrity Enforcement (MIE / EMTE)

- Apple’s MIE (Memory Integrity Enforcement) is the hardware + OS framework that brings **Enhanced Memory Tagging Extension (EMTE)** into always-on, synchronous mode across major attack surfaces.
- xzone allocator is a fundamental foundation of MIE in user space: allocations done via xzone get tags, and accesses are checked by hardware.
- In MIE, the allocator, tag assignment, metadata management, and tag confidentiality enforcement are integrated to ensure that memory errors (e.g. stale reads, OOB, UAF) are caught immediately, not exploited later.

---

If you like, I can also generate a cheat-sheet or diagram of xzone internals for your book. Do you want me to do that next?
::contentReference[oaicite:20]{index=20}


---

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
