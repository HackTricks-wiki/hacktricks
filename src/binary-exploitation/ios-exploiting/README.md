# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

### 1. **Code Signing** / Runtime Signature Verification
**Introduced early (iPhone OS → iOS)**
Αυτή είναι μία από τις θεμελιώδεις προστασίες: **όλος ο εκτελέσιμος κώδικας** (apps, dynamic libraries, JIT-ed code, extensions, frameworks, caches) πρέπει να είναι κρυπτογραφικά υπογεγραμμένος με μια αλυσίδα πιστοποιητικών ριζωμένη στην εμπιστοσύνη της Apple. Σε runtime, πριν φορτωθεί ένα binary στη μνήμη (ή πριν γίνουν άλματα πέρα από ορισμένα όρια), το σύστημα ελέγχει την υπογραφή. Αν ο κώδικας τροποποιηθεί (bit-flipped, patched) ή είναι unsigned, το load αποτυγχάνει.

- **Thwarts**: το “classic payload drop + execute” στάδιο σε exploit chains; arbitrary code injection; τροποποίηση υπάρχοντος binary για εισαγωγή κακόβουλης λογικής.
- **Mechanism detail**:
* Ο Mach-O loader (και ο dynamic linker) ελέγχουν code pages, segments, entitlements, team IDs, και ότι η υπογραφή καλύπτει το περιεχόμενο του αρχείου.
* Για περιοχές μνήμης όπως JIT caches ή dynamically generated code, η Apple επιβάλλει ότι οι σελίδες να είναι signed ή να επικυρώνονται μέσω ειδικών APIs (π.χ. `mprotect` με code-sign checks).
* Η υπογραφή περιλαμβάνει entitlements και identifiers· το OS επιβάλλει ότι ορισμένα APIs ή privileged capabilities απαιτούν συγκεκριμένα entitlements που δεν μπορούν να πλαστογραφηθούν.

<details>
<summary>Example</summary>
Αν ένα exploit αποκτήσει code execution σε μια διεργασία και προσπαθήσει να γράψει shellcode σε heap και να κάνει jump σε αυτό, σε iOS η σελίδα πρέπει να είναι flagged executable **και** να ικανοποιεί τα code-signature constraints. Εφόσον το shellcode δεν είναι υπογεγραμμένο με το πιστοποιητικό της Apple, το άλμα αποτυγχάνει ή το σύστημα απορρίπτει το να γίνει η περιοχή μνήμης executable.
</details>


### 2. **CoreTrust**
**Introduced around iOS 14+ era (or gradually in newer devices / later iOS)**
CoreTrust είναι το subsystem που εκτελεί **runtime signature validation** των binaries (συμπεριλαμβανομένων system και user binaries) σε σχέση με την **root certificate της Apple** αντί να βασίζεται σε cached userland trust stores.

- **Thwarts**: post-install tampering των binaries, jailbreaking τεχνικές που προσπαθούν να αντικαταστήσουν ή να patch-άρουν system libraries ή user apps; να ξεγελάσουν το σύστημα αντικαθιστώντας trusted binaries με κακόβουλα αντίγραφα.
- **Mechanism detail**:
* Αντί να εμπιστεύεται μια τοπική trust database ή certificate cache, το CoreTrust αναφέρεται απευθείας στην root της Apple ή επαληθεύει intermediate certificates σε μια ασφαλή αλυσίδα.
* Εξασφαλίζει ότι οι τροποποιήσεις (π.χ. στο filesystem) σε υπάρχοντα binaries ανιχνεύονται και απορρίπτονται.
* Συνδέει entitlements, team IDs, code signing flags και άλλα metadata με το binary κατά το load time.

<details>
<summary>Example</summary>
Ένα jailbreak μπορεί να προσπαθήσει να αντικαταστήσει το `SpringBoard` ή `libsystem` με patched έκδοση για persistence. Αλλά όταν ο loader του OS ή το CoreTrust ελέγξει, παρατηρεί τη mismatch στην υπογραφή (ή τροποποιημένα entitlements) και αρνείται να εκτελέσει.
</details>


### 3. **Data Execution Prevention (DEP / NX / W^X)**
**Introduced in many OSes earlier; iOS had NX-bit / w^x for a long time**
Το DEP επιβάλλει ότι σελίδες που είναι marked writable (για data) είναι **non-executable**, και σελίδες marked executable είναι **non-writable**. Δεν μπορεί κανείς απλώς να γράψει shellcode σε heap ή stack και να το εκτελέσει.

- **Thwarts**: direct shellcode execution; classic buffer-overflow → jump to injected shellcode.
- **Mechanism detail**:
* Το MMU / flags προστασίας μνήμης (μέσω page tables) επιβάλλουν τον διαχωρισμό.
* Οποιαδήποτε προσπάθεια να σημειωθεί writable σελίδα ως executable ενεργοποιεί έναν system check (και είτε απαγορεύεται είτε απαιτεί code-sign approval).
* Σε πολλές περιπτώσεις, το να γίνουν σελίδες executable απαιτεί χρήση OS APIs που επιβάλλουν επιπλέον περιορισμούς ή ελέγχους.

<details>
<summary>Example</summary>
Ένα overflow γράφει shellcode στο heap. Ο attacker προσπαθεί `mprotect(heap_addr, size, PROT_EXEC)` για να το κάνει executable. Αλλά το σύστημα αρνείται ή επικυρώνει ότι η νέα σελίδα πρέπει να περάσει code-sign constraints (τα οποία το shellcode δεν μπορεί).
</details>

### 4. **Address Space Layout Randomization (ASLR)**
**Introduced in iOS ~4–5 era (roughly iOS 4–5 timeframe)**
Το ASLR τυχαίοποιεί τις βασικές διευθύνσεις κρίσιμων περιοχών μνήμης: libraries, heap, stack κ.λπ. σε κάθε εκκίνηση διεργασίας. Οι διευθύνσεις των gadgets κινούνται μεταξύ runs.

- **Thwarts**: hardcoding gadget addresses για ROP/JOP; static exploit chains; blind jumping σε γνωστά offsets.
- **Mechanism detail**:
* Κάθε loaded library / dynamic module rebased σε τυχαίο offset.
* Stack και heap base pointers randomized (μέσα σε ορισμένα όρια entropy).
* Μερικές φορές κι άλλες περιοχές (π.χ. mmap allocations) είναι επίσης randomized.
* Σε συνδυασμό με information-leak mitigations, αναγκάζει τον attacker να κάνει πρώτα leak μιας διεύθυνσης ή pointer για να ανακαλύψει τα base addresses σε runtime.

<details>
<summary>Example</summary>
Μια ROP αλυσίδα περιμένει gadget σε `0x….lib + offset`. Αλλά αφού το `lib` relocated διαφορετικά κάθε run, η hardcoded αλυσίδα αποτυγχάνει. Ένα exploit πρέπει πρώτα να κάνει leak το base address του module πριν υπολογίσει τα gadget addresses.
</details>


### 5. **Kernel Address Space Layout Randomization (KASLR)**
**Introduced in iOS ~ (iOS 5 / iOS 6 timeframe)**
Αντίστοιχο του user ASLR, το KASLR randomizes το base της **kernel text** και άλλων kernel δομών κατά το boot.

- **Thwarts**: kernel-level exploits που βασίζονται σε σταθερές τοποθεσίες kernel κώδικα ή δεδομένων; static kernel exploits.
- **Mechanism detail**:
* Σε κάθε boot, η base address του kernel randomized (μέσα σε εύρος).
* Kernel data structures (όπως `task_structs`, `vm_map`, κ.λπ.) μπορεί επίσης να μετατοπίζονται ή να έχουν offsets.
* Οι attackers πρέπει πρώτα να κάνουν leak kernel pointers ή να χρησιμοποιήσουν information disclosure vulnerabilities για να υπολογίσουν offsets πριν υπεραρχίσουν kernel structures ή κώδικα.

<details>
<summary>Example</summary>
Μια local ευπάθεια στοχεύει να corrupt-άρει ένα kernel function pointer (π.χ. σε `vtable`) στο `KERN_BASE + offset`. Αλλά αφού το `KERN_BASE` είναι άγνωστο, ο attacker πρέπει πρώτα να το leak (π.χ. μέσω ενός read primitive) πριν υπολογίσει τη σωστή διεύθυνση για corruption.
</details>


### 6. **Kernel Patch Protection (KPP / AMCC)**
**Introduced in newer iOS / A-series hardware (post around iOS 15–16 era or newer chips)**
Το KPP (aka AMCC) παρακολουθεί συνεχώς την ακεραιότητα των kernel text pages (μέσω hash ή checksum). Αν ανιχνεύσει tampering (patches, inline hooks, τροποποιήσεις κώδικα) εκτός επιτρεπτών παραθύρων, προκαλεί kernel panic ή reboot.

- **Thwarts**: persistent kernel patching (τροποποίηση kernel instructions), inline hooks, static function overwrites.
- **Mechanism detail**:
* Ένα hardware ή firmware module παρακολουθεί την περιοχή του kernel text.
* Περιοδικά ή κατόπιν αιτήματος επανα-υπολογίζει hashes των pages και τα συγκρίνει με αναμενόμενες τιμές.
* Αν υπάρχουν mismatches εκτός benign update windows, προκαλεί panic στη συσκευή (για να αποφύγει persistent κακόβουλες αλλαγές).
* Οι attackers πρέπει είτε να αποφύγουν τα detection windows είτε να χρησιμοποιήσουν legitimate patch paths.

<details>
<summary>Example</summary>
Ένα exploit προσπαθεί να patch-άρει το prologue μιας kernel συνάρτησης (π.χ. `memcmp`) για να παρεμβάλει κλήσεις. Αλλά το KPP παρατηρεί ότι το code page hash δεν ταιριάζει με την αναμενόμενη τιμή και προκαλεί kernel panic, καταρρέοντας τη συσκευή πριν το patch σταθεροποιηθεί.
</details>


### 7. **Kernel Text Read‐Only Region (KTRR)**
**Introduced in modern SoCs (post ~A12 / newer hardware)**
Το KTRR είναι μηχανισμός επιβεβλημένος από hardware: μόλις το kernel text κλειδωθεί νωρίς κατά το boot, γίνεται read-only από EL1 (τον kernel), αποτρέποντας περαιτέρω writes σε code pages.

- **Thwarts**: οποιεσδήποτε τροποποιήσεις στον kernel code μετά το boot (π.χ. patching, in-place code injection) σε επίπεδο προνομίων EL1.
- **Mechanism detail**:
* Κατά το boot (σε secure/bootloader στάδιο), ο memory controller (ή μια secure hardware μονάδα) σημαδεύει τις φυσικές σελίδες που περιέχουν kernel text ως read-only.
* Ακόμα κι αν ένα exploit αποκτήσει πλήρη kernel privileges, δεν μπορεί να γράψει σε αυτές τις σελίδες για να τροποποιήσει instructions.
* Για να τις τροποποιήσει, ο attacker πρέπει πρώτα να compromize-άρει την boot chain ή να υπονομεύσει το ίδιο το KTRR.

<details>
<summary>Example</summary>
Ένα privilege-escalation exploit πηδάει σε EL1 και γράφει ένα trampoline μέσα σε kernel function (π.χ. στον `syscall` handler). Αλλά επειδή οι σελίδες κλειδώθηκαν ως read-only από το KTRR, το write αποτυγχάνει (ή προκαλεί fault), οπότε το patch δεν εφαρμόζεται.
</details>


### 8. **Pointer Authentication Codes (PAC)**
**Introduced with ARMv8.3 (hardware), Apple beginning with A12 / iOS ~12+**
- Το PAC είναι ένα hardware feature εισαχθέν στο **ARMv8.3-A** για να ανιχνεύει τη χειραγώγηση των pointer τιμών (return addresses, function pointers, ορισμένοι data pointers) ενσωματώνοντας μια μικρή κρυπτογραφική υπογραφή (“MAC”) στα αχρησιμοποίητα υψηλά bits του pointer.
- Η υπογραφή (“PAC”) υπολογίζεται πάνω στην τιμή του pointer μαζί με ένα **modifier** (μια context τιμή, π.χ. stack pointer ή κάποιο διακριτικό δεδομένο). Έτσι η ίδια pointer τιμή σε διαφορετικά contexts έχει διαφορετικό PAC.
- Στο χρόνο χρήσης, πριν από dereference ή branch μέσω αυτού του pointer, μια **authenticate** εντολή ελέγχει το PAC. Αν είναι valid, το PAC αφαιρείται και λαμβάνεται ο καθαρός pointer· αν είναι invalid, ο pointer γίνεται “poisoned” (ή προκαλείται fault).
- Τα κλειδιά που χρησιμοποιούνται για παραγωγή/επικύρωση των PAC ζουν σε privileged registers (EL1, kernel) και δεν είναι άμεσα αναγνώσιμα από user mode.
- Επειδή δεν χρησιμοποιούνται όλα τα 64-bit μιας pointer σε πολλές αρχιτεκτονικές (π.χ. 48-bit address space), τα ανώτερα bits είναι “spare” και μπορούν να φιλοξενήσουν το PAC χωρίς να αλλάζουν την effective address.

#### Architectural Basis & Key Types

- Το ARMv8.3 εισάγει **πέντε 128-bit keys** (το καθένα υλοποιημένο μέσω δύο 64-bit system registers) για pointer authentication.
- **APIAKey** — για instruction pointers (domain “I”, key A)
- **APIBKey** — δεύτερο key για instruction pointers (domain “I”, key B)
- **APDAKey** — για data pointers (domain “D”, key A)
- **APDBKey** — για data pointers (domain “D”, key B)
- **APGAKey** — “generic” key, για signing μη-pointer δεδομένων ή άλλες γενικές χρήσεις

- Αυτά τα κλειδιά αποθηκεύονται σε privileged system registers (πρόσβαση μόνο σε EL1/EL2 κ.λπ.), μη προσβάσιμα από user mode.
- Το PAC υπολογίζεται μέσω μιας κρυπτογραφικής συνάρτησης (το ARM προτείνει QARMA ως αλγόριθμο) χρησιμοποιώντας:
1. Την τιμή του pointer (canonical portion)
2. Έναν **modifier** (μια τιμή context, όπως salt)
3. Το secret key
4. Κάποια εσωτερική tweak λογική
Αν το προκύπτον PAC ταιριάζει με αυτό που είναι αποθηκευμένο στα υψηλά bits του pointer, η authentication πετυχαίνει.


#### Instruction Families

Η ονοματολογία είναι: **PAC** / **AUT** / **XPAC**, μετά τα domain letters.
- `PACxx` εντολές **sign** έναν pointer και εισάγουν PAC
- `AUTxx` εντολές **authenticate + strip** (validate και remove το PAC)
- `XPACxx` εντολές **strip** χωρίς validation

Domains / suffixes:

| Mnemonic     | Meaning / Domain                      | Key / Domain     | Example Usage in Assembly |
|--------------|-----------------------------------------|--------------------|-----------------------------|
| **PACIA**    | Sign instruction pointer with APIAKey   | “I, A”             | `PACIA X0, X1` — sign pointer in X0 using APIAKey with modifier X1|
| **PACIB**    | Sign instruction pointer with APIBKey   | “I, B”             | `PACIB X2, X3`              |
| **PACDA**    | Sign data pointer with APDAKey           | “D, A”             | `PACDA X4, X5`              |
| **PACDB**    | Sign data pointer with APDBKey           | “D, B”             | `PACDB X6, X7`              |
| **PACG / PACGA** | Generic (non-pointer) signing with APGAKey | “G”         | `PACGA X8, X9, X10` (sign X9 with modifier X10 into X8) |
| **AUTIA**    | Authenticate APIA-signed instruction pointer & strip PAC | “I, A” | `AUTIA X0, X1` — check PAC on X0 using modifier X1, then strip |
| **AUTIB**    | Authenticate APIB domain                 | “I, B”             | `AUTIB X2, X3`               |
| **AUTDA**    | Authenticate APDA-signed data pointer    | “D, A”             | `AUTDA X4, X5`               |
| **AUTDB**    | Authenticate APDB-signed data pointer    | “D, B”             | `AUTDB X6, X7`               |
| **AUTGA**    | Authenticate generic / blob (APGA)        | “G”               | `AUTGA X8, X9, X10` (validate generic) |
| **XPACI**     | Strip PAC (instruction pointer, no validation) | “I”         | `XPACI X0` — remove PAC from X0 (instruction domain) |
| **XPACD**     | Strip PAC (data pointer, no validation)    | “D”             | `XPACD X4` — remove PAC from data pointer in X4 |

Υπάρχουν εξειδικευμένες / alias μορφές:

- `PACIASP` είναι συντομογραφία για `PACIA X30, SP` (sign the link register using SP as modifier)
- `AUTIASP` είναι `AUTIA X30, SP` (authenticate link register with SP)
- Συνδυασμένες μορφές όπως `RETAA`, `RETAB` (authenticate-and-return) ή `BLRAA` (authenticate & branch) υπάρχουν σε ARM extensions / compiler support.
- Επίσης υπάρχουν zero-modifier variants: `PACIZA` / `PACIZB` όπου ο modifier είναι implicitly zero, κ.λπ.

#### Modifiers

Ο κύριος στόχος του modifier είναι να **συνδέσει το PAC με ένα συγκεκριμένο context** ώστε η ίδια διεύθυνση που υπογράφεται σε διαφορετικά contexts να παράγει διαφορετικά PACs. Είναι σαν να προσθέτεις **salt σε ένα hash.**

Επομένως:
- Ο **modifier** είναι μια context τιμή (άλλο register) που αναμειγνύεται στον υπολογισμό του PAC. Τυπικές επιλογές: ο stack pointer (`SP`), frame pointer, ή κάποιο object ID.
- Η χρήση του SP ως modifier είναι συχνή για signing των return addresses: το PAC δένεται στο συγκεκριμένο stack frame. Αν προσπαθήσεις να επαναχρησιμοποιήσεις το LR σε διαφορετικό frame, ο modifier αλλάζει, οπότε η PAC validation αποτυγχάνει.
- Η ίδια pointer τιμή υπογεγραμμένη με διαφορετικούς modifiers παράγει διαφορετικά PACs.
- Ο modifier **δεν χρειάζεται να είναι μυστικός**, αλλά ιδανικά να μην μπορεί να ελεγχθεί από τον attacker.
- Για εντολές που υπογράφουν ή επαληθεύουν pointers όπου δεν υπάρχει ουσιαστικός modifier, κάποιες μορφές χρησιμοποιούν zero ή έναν implicit constant.

#### Apple / iOS / XNU Customizations & Observations

- Η υλοποίηση PAC της Apple περιλαμβάνει **per-boot diversifiers** έτσι ώστε τα keys ή τα tweaks να αλλάζουν σε κάθε boot, αποτρέποντας επαναχρησιμοποίηση across boots.
- Επίσης περιλαμβάνουν **cross-domain mitigations** έτσι ώστε PACs που υπογράφονται σε user mode να μην μπορούν εύκολα να επαναχρησιμοποιηθούν σε kernel mode, κ.λπ.
- Στο Apple M1 / Apple Silicon, το reverse engineering έδειξε ότι υπάρχουν **εννέα τύποι modifiers** και Apple-specific system registers για τον έλεγχο των keys.
- Η Apple χρησιμοποιεί PAC σε πολλά kernel υποσυστήματα: return address signing, pointer integrity σε kernel data, signed thread contexts, κ.λπ.
- Το Google Project Zero έδειξε πως με ένα ισχυρό memory read/write primitive στον kernel, κάποιος μπορούσε να forge-άρει kernel PACs (για A keys) σε A12-era συσκευές, αλλά η Apple έσπευσε να κλείσει πολλές από αυτές τις διαδρομές.
- Στο σύστημα της Apple, κάποια keys είναι **global across kernel**, ενώ οι user processes μπορεί να παίρνουν per-process key randomness.

#### PAC Bypasses

1. **Kernel-mode PAC: theoretical vs real bypasses**

-   Επειδή τα kernel PAC keys και η λογική ελέγχονται αυστηρά (privileged registers, diversifiers, domain isolation), το να forge-άρει κανείς αυθαίρετα signed kernel pointers είναι πολύ δύσκολο.
-   Ο Azad στο 2020 "iOS Kernel PAC, One Year Later" αναφέρει ότι σε iOS 12-13 βρήκε μερικά partial bypasses (signing gadgets, reuse of signed states, unprotected indirect branches) αλλά όχι ένα πλήρες generic bypass. [bazad.github.io](https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf)
-   Τα Apple “Dark Magic” customizations περιορίζουν ακόμα περισσότερο τις επιφάνειες που μπορούν να εκμεταλλευτούν (domain switching, per-key enabling bits). [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Υπάρχει γνωστό **kernel PAC bypass CVE-2023-32424** σε Apple silicon (M1/M2) αναφερθέν από Zecao Cai et al. [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Αλλά αυτά τα bypasses συχνά βασίζονται σε πολύ συγκεκριμένα gadgets ή implementation bugs· δεν είναι γενικής χρήσης bypass.

Έτσι, το kernel PAC θεωρείται **ιδιαίτερα ισχυρό**, αν και όχι τέλειο.

2. **User-mode / runtime PAC bypass techniques**

Αυτά είναι πιο κοινά, και εκμεταλλεύονται ατέλειες στον τρόπο που εφαρμόζεται το PAC ή χρησιμοποιείται στο dynamic linking / runtime frameworks. Παρακάτω είναι κατηγορίες με παραδείγματα.

2.1 **Shared Cache / A key issues**

-   Η **dyld shared cache** είναι ένα μεγάλο pre-linked blob συστημικών frameworks και βιβλιοθηκών. Επειδή μοιράζεται ευρέως, function pointers μέσα στη shared cache είναι "pre-signed" και χρησιμοποιούνται από πολλές διεργασίες. Οι attackers στοχεύουν αυτούς τους ήδη-signed pointers ως "PAC oracles".
-   Κάποιοι bypass τεχνικές προσπαθούν να εξάγουν ή να επαναχρησιμοποιήσουν A-key signed pointers που υπάρχουν στη shared cache και να τα επαναχρησιμοποιήσουν σε gadgets.
-   Η ομιλία "No Clicks Required" περιγράφει το χτίσιμο ενός oracle πάνω στη shared cache για να συμπεράνει relative addresses και να το συνδυάσει με signed pointers για να παρακάμψει PAC. [saelo.github.io](https://saelo.github.io/presentations/offensivecon_20_no_clicks.pdf)
-   Επίσης, imports function pointers από shared libraries σε userspace βρέθηκαν ότι δεν είναι πάντα επαρκώς προστατευμένα από PAC, επιτρέποντας σε attacker να πάρει function pointers χωρίς να αλλάξει την υπογραφή τους. (Project Zero bug entry) [bugs.chromium.org](https://bugs.chromium.org/p/project-zero/issues/detail?id=2044&utm_source=chatgpt.com)

2.2 **dlsym(3) / dynamic symbol resolution**

-   Ένα γνωστό bypass είναι να καλέσεις `dlsym()` για να πάρεις ένα *already signed* function pointer (υπογεγραμμένο με A-key, diversifier zero) και να το χρησιμοποιήσεις. Επειδή το `dlsym` επιστρέφει νόμιμα signed pointer, η χρήση του παρακάμπτει την ανάγκη να forge-άρεις PAC.
-   Το blog του Epsilon περιγράφει πώς κάποια bypasses εκμεταλλεύονται αυτό: κλήση `dlsym("someSym")` δίνει signed pointer και μπορεί να χρησιμοποιηθεί για indirect calls. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)
-   Η Synacktiv στο "iOS 18.4 --- dlsym considered harmful" περιγράφει ένα bug: κάποια symbols που επιλύονται μέσω `dlsym` στο iOS 18.4 επιστρέφουν pointers που είναι λανθασμένα signed (ή με buggy diversifiers), επιτρέποντας ανεπιθύμητο PAC bypass. [Synacktiv](https://www.synacktiv.com/en/publications/ios-184-dlsym-considered-harmful)
-   Η λογική στο dyld για dlsym περιλαμβάνει: όταν `result->isCode`, υπογράφουν τον επιστρεφόμενο pointer με `__builtin_ptrauth_sign_unauthenticated(..., key_asia, 0)`, δηλαδή context zero. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

Έτσι, το `dlsym` είναι συχνός vector σε user-mode PAC bypasses.

2.3 **Other DYLD / runtime relocations**

-   Ο DYLD loader και η dynamic relocation λογική είναι πολύπλοκα και μερικές φορές προσωρινά κάνουν map σελίδες ως read/write για να εκτελέσουν relocations, και μετά τις επαναφέρουν σε read-only. Οι attackers εκμεταλλεύονται αυτά τα παράθυρα. Η ομιλία της Synacktiv περιγράφει την "Operation Triangulation", ένα timing-based bypass του PAC μέσω dynamic relocations. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)
-   Οι DYLD σελίδες τώρα προστατεύονται με SPRR / VM_FLAGS_TPRO (κάποια protection flags για dyld). Αλλά παλαιότερες εκδόσεις είχαν ασθενέστερα guards. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)
-   Σε WebKit exploit chains, ο DYLD loader είναι συχνά στόχος για PAC bypass. Οι slides αναφέρουν ότι πολλά PAC bypasses έχουν στοχεύσει τον DYLD loader (μέσω relocation, interposer hooks). [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

2.4 **NSPredicate / NSExpression / ObjC / SLOP**

-   Σε userland exploit chains, Objective-C runtime methods όπως `NSPredicate`, `NSExpression` ή `NSInvocation` χρησιμοποιούνται για να smuggle control calls χωρίς προφανή pointer forging.
-   Σε παλαιότερο iOS (πριν PAC), ένα exploit χρησιμοποίησε **fake NSInvocation** objects για να καλέσει arbitrary selectors σε ελεγχόμενη μνήμη. Με PAC χρειάστηκαν τροποποιήσεις. Αλλά η τεχνική SLOP (SeLector Oriented Programming) επεκτάθηκε και υπό PAC. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)
-   Η αρχική τεχνική SLOP επέτρεπε αλυσίδωση ObjC calls δημιουργώντας fake invocations· το bypass βασίζεται στο ότι ISA ή selector pointers μερικές φορές δεν προστατεύονται πλήρως από PAC. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)
-   Σε περιβάλλοντα όπου το pointer authentication εφαρμόζεται μερικώς, methods / selectors / target pointers μπορεί να μην έχουν πάντα PAC protection, δίνοντας πεδίο για bypass.

#### Example Flow

<details>
<summary>Example Signing & Authenticating</summary>
```
; Example: function prologue / return address protection
my_func:
stp x29, x30, [sp, #-0x20]!        ; push frame pointer + LR
mov x29, sp
PACIASP                            ; sign LR (x30) using SP as modifier
; … body …
mov sp, x29
ldp x29, x30, [sp], #0x20         ; restore
AUTIASP                            ; authenticate & strip PAC
ret

; Example: indirect function pointer stored in a struct
; suppose X1 contains a function pointer
PACDA X1, X2     ; sign data pointer X1 with context X2
STR X1, [X0]      ; store signed pointer

; later retrieval:
LDR X1, [X0]
AUTDA X1, X2       ; authenticate & strip
BLR X1             ; branch to valid target

; Example: stripping for comparison (unsafe)
LDR X1, [X0]
XPACI X1           ; strip PAC (instruction domain)
CMP X1, #some_label_address
BEQ matched_label
```
</details>

<details>
<summary>Example</summary>
Μια υπερχείλιση buffer αντικαθιστά μια διεύθυνση επιστροφής στην στοίβα. Ο επιτιθέμενος γράφει τη διεύθυνση του στοχευόμενου gadget αλλά δεν μπορεί να υπολογίσει το σωστό PAC. Όταν η συνάρτηση επιστρέφει, η CPU’s `AUTIA` instruction προκαλεί σφάλμα επειδή το PAC δεν ταιριάζει. Η αλυσίδα αποτυγχάνει.
Η ανάλυση του Project Zero στο A12 (iPhone XS) έδειξε πώς χρησιμοποιείται το PAC της Apple και μεθόδους πλαστογράφησης PACs εάν ένας επιτιθέμενος έχει primitive ανάγνωσης/εγγραφής μνήμης.
</details>


### 9. **Branch Target Identification (BTI)**
**Introduced with ARMv8.5 (later hardware)**
Το BTI είναι ένα hardware χαρακτηριστικό που ελέγχει **έμμεσους στόχους διακλάδωσης**: κατά την εκτέλεση `blr` ή έμμεσων κλήσεων/αλλάγων, ο στόχος πρέπει να ξεκινάει με ένα **BTI landing pad** (`BTI j` ή `BTI c`). Το άλμα σε διευθύνσεις gadget που δεν έχουν το landing pad ενεργοποιεί εξαίρεση.

Η υλοποίηση του LLVM αναφέρει τρεις παραλλαγές των εντολών BTI και πώς αντιστοιχίζονται σε τύπους διακλαδώσεων.

| BTI Variant | What it permits (which branch types) | Typical placement / use case |
|-------------|----------------------------------------|-------------------------------|
| **BTI C** | Targets of *call*-style indirect branches (e.g. `BLR`, or `BR` using X16/X17) | Τοποθετείται στην είσοδο συναρτήσεων που μπορεί να κληθούν έμμεσα |
| **BTI J** | Targets of *jump*-style branches (e.g. `BR` used for tail calls) | Τοποθετείται στην αρχή blocks που είναι προσβάσιμα μέσω jump tables ή tail-calls |
| **BTI JC** | Acts as both C and J | Λειτουργεί ως C και J — μπορεί να στοχευτεί είτε από call είτε από jump διακλαδώσεις |

- Σε κώδικα που μεταγλωττίζεται με επιβολή branch target, οι μεταγλωττιστές εισάγουν μια εντολή BTI (C, J, ή JC) σε κάθε έγκυρο στόχο έμμεσης διακλάδωσης (αρχές συναρτήσεων ή blocks προσβάσιμα με jumps) έτσι ώστε οι έμμεσες διακλαδώσεις να πετυχαίνουν μόνο σε αυτά τα σημεία.
- Οι **άμεσες διακλαδώσεις / κλήσεις** (δηλ. σταθερής διεύθυνσης `B`, `BL`) **δεν περιορίζονται** από το BTI. Η υπόθεση είναι ότι οι σελίδες κώδικα είναι έμπιστες και ο επιτιθέμενος δεν μπορεί να τις αλλάξει (οπότε οι άμεσες διακλαδώσεις είναι ασφαλείς).
- Επίσης, οι εντολές **RET / return** γενικά δεν περιορίζονται από το BTI γιατί οι διευθύνσεις επιστροφής προστατεύονται μέσω PAC ή μηχανισμών υπογραφής επιστροφής.

#### Mechanism and enforcement

- Όταν η CPU αποκωδικοποιεί μια **έμμεση διακλάδωση (BLR / BR)** σε μια σελίδα που σημειώνεται ως “guarded / BTI-enabled,” ελέγχει αν η πρώτη εντολή στη διεύθυνση στόχου είναι ένα έγκυρο BTI (C, J, ή JC όπως επιτρέπεται). Αν όχι, συμβαίνει μια **Branch Target Exception**.
- Η κωδικοποίηση της εντολής BTI έχει σχεδιαστεί ώστε να επαναχρησιμοποιεί opcodes που προηγουμένως ήταν δεσμευμένοι για NOPs (σε παλαιότερες ARM εκδόσεις). Έτσι τα BTI-enabled binaries παραμένουν backward-compatible: σε hardware χωρίς υποστήριξη BTI, αυτές οι εντολές λειτουργούν ως NOPs.
- Τα compiler passes που προσθέτουν BTIs τα εισάγουν μόνο εκεί που χρειάζεται: σε συναρτήσεις που μπορεί να κληθούν έμμεσα ή σε basic blocks που στοχεύονται από jumps.
- Ορισμένα patches και κώδικας LLVM δείχνουν ότι το BTI δεν εισάγεται για *όλα* τα basic blocks — μόνο για εκείνα που είναι πιθανοί στόχοι διακλάδωσης (π.χ. από switch / jump tables).

#### BTI + PAC synergy

Το PAC προστατεύει την τιμή του pointer (την πηγή) — εξασφαλίζει ότι η αλυσίδα έμμεσων κλήσεων / επιστροφών δεν έχει παραποιηθεί.

Το BTI διασφαλίζει ότι ακόμη και ένας έγκυρος pointer πρέπει να στοχεύει αποκλειστικά σε σωστά σημασμένα entry points.

Συνδυαστικά, ένας επιτιθέμενος χρειάζεται τόσο έναν έγκυρο pointer με σωστό PAC όσο και ο στόχος να έχει τοποθετημένο BTI εκεί. Αυτό αυξάνει τη δυσκολία στην κατασκευή exploit gadgets.

#### Example


<details>
<summary>Example</summary>
Ένα exploit προσπαθεί να κάνει pivot σε gadget στη `0xABCDEF` που δεν ξεκινάει με `BTI c`. Η CPU, κατά την εκτέλεση `blr x0`, ελέγχει τον στόχο και προκαλεί σφάλμα επειδή η στοίχιση των εντολών δεν περιλαμβάνει ένα έγκυρο landing pad. Έτσι πολλά gadgets γίνονται μη χρηστικά εκτός αν περιλαμβάνουν το πρόθεμα BTI.
</details>


### 10. **Privileged Access Never (PAN) & Privileged Execute Never (PXN)**
**Introduced in more recent ARMv8 extensions / iOS support (for hardened kernel)**

#### PAN (Privileged Access Never)

- Το **PAN** είναι ένα χαρακτηριστικό που εισήχθη στο **ARMv8.1-A** και αποτρέπει τον **privileged code** (EL1 ή EL2) από το να **διαβάζει ή να γράφει** μνήμη που έχει χαρακτηριστεί ως **user-accessible (EL0)**, εκτός αν το PAN απενεργοποιηθεί ρητά.
- Η ιδέα: ακόμα κι αν ο kernel παραπλανηθεί ή παραβιαστεί, δεν μπορεί αυθαίρετα να ακολουθήσει δείκτες user-space χωρίς πρώτα να *καθαρίσει* το PAN, μειώνοντας έτσι τους κινδύνους εκμεταλλεύσεων τύπου `ret2usr` ή κατάχρησης buffers που ελέγχονται από τον χρήστη.
- Όταν το PAN είναι ενεργό (PSTATE.PAN = 1), οποιαδήποτε privileged εντολή load/store που προσπελαύνει μια εικονική διεύθυνση που είναι “accessible at EL0” προκαλεί permission fault.
- Ο kernel, όταν πρέπει νόμιμα να προσπελάσει μνήμη χρήστη (π.χ. αντιγραφή δεδομένων προς/από user buffers), πρέπει προσωρινά να απενεργοποιήσει το PAN (ή να χρησιμοποιήσει “unprivileged load/store” εντολές) για να επιτρέψει την πρόσβαση.
- Στο Linux σε ARM64, η υποστήριξη PAN εισήχθη περίπου το 2015: patches του kernel πρόσθεσαν ανίχνευση της δυνατότητας και αντικατέστησαν `get_user` / `put_user` κ.λπ. με παραλλαγές που καθαρίζουν το PAN γύρω από τις προσπελάσεις μνήμης χρήστη.

**Key nuance / limitation / bug**
- Όπως σημειώθηκε από τον Siguza και άλλους, ένα σφάλμα προδιαγραφής (ή ασαφής συμπεριφορά) στο σχέδιο του ARM σημαίνει ότι οι **execute-only user mappings** (`--x`) μπορεί να **μην ενεργοποιούν το PAN**. Με άλλα λόγια, αν μια user σελίδα είναι επισημασμένη ως executable αλλά χωρίς δικαίωμα ανάγνωσης, η προσπάθεια ανάγνωσης από τον kernel μπορεί να παρακάμψει το PAN επειδή η αρχιτεκτονική θεωρεί ότι “accessible at EL0” απαιτεί αναγνώσιμη άδεια, όχι μόνο executable. Αυτό οδηγεί σε PAN bypass σε ορισμένες υλοποιήσεις.
- Λόγω αυτού, αν το iOS / XNU επιτρέπει execute-only user σελίδες (όπως σε μερικές JIT ή code-cache ρυθμίσεις), ο kernel μπορεί κατά λάθος να διαβάσει από αυτές ακόμη και με ενεργό PAN. Αυτό είναι γνωστό και λεπτό εκμεταλλεύσιμο σημείο σε μερικά συστήματα ARMv8+.

#### PXN (Privileged eXecute Never)

- Το **PXN** είναι ένα bit στους page table entries (σε leaf ή block entries) που υποδεικνύει ότι η σελίδα **δεν είναι εκτελέσιμη όταν τρέχει σε privileged mode** (π.χ. όταν εκτελείται EL1).
- Το PXN αποτρέπει τον kernel (ή οποιονδήποτε privileged κώδικα) από το να κάνει jump ή να εκτελέσει εντολές από σελίδες user-space ακόμα κι αν ο έλεγχος εκτρέπεται εκεί. Στην πράξη, εμποδίζει την εκτροπή ροής εκτέλεσης στο επίπεδο kernel προς μνήμη χρήστη.
- Σε συνδυασμό με το PAN, αυτό εξασφαλίζει ότι:
1. Ο kernel δεν μπορεί (κατά προεπιλογή) να διαβάσει ή να γράψει δεδομένα χρήστη (PAN)
2. Ο kernel δεν μπορεί να εκτελέσει κώδικα χρήστη (PXN)
- Στο format των page tables του ARMv8, οι leaf entries έχουν ένα bit `PXN` (και επίσης `UXN` για unprivileged execute-never) στα attribute bits τους.

Έτσι ακόμα κι αν ο kernel έχει κατεστραμμένο function pointer που δείχνει σε μνήμη χρήστη και επιχειρήσει branch εκεί, το bit PXN θα προκαλέσει σφάλμα.

#### Memory-permission model & how PAN and PXN map to page table bits

Για να κατανοήσετε πώς δουλεύουν PAN / PXN, χρειάζεται να δείτε πώς λειτουργεί το μοντέλο μετάφρασης και δικαιωμάτων του ARM (απλοποιημένο):

- Κάθε page ή block entry έχει πεδία attributes συμπεριλαμβανομένων των **AP[2:1]** για δικαιώματα πρόσβασης (read/write, privileged vs unprivileged) και των bits **UXN / PXN** για περιορισμούς execute-never.
- Όταν το PSTATE.PAN είναι 1 (enabled), το hardware επιβάλλει τροποποιημένη σημασιολογία: privileged προσβάσεις σε σελίδες που σημειώνονται ως “accessible by EL0” (δηλ. προσβάσιμες από user) απαγορεύονται (fault).
- Λόγω του προαναφερθέντος bug, οι σελίδες που μαρκάρονται μόνο ως executable (χωρίς δικαίωμα ανάγνωσης) μπορεί να μην μετρώνται ως “accessible by EL0” σε ορισμένες υλοποιήσεις, και έτσι να παρακάμπτουν το PAN.
- Όταν το PXN bit μιας σελίδας είναι ρυθμισμένο, ακόμη κι αν το fetch της εντολής προέρχεται από υψηλότερο επίπεδο προνομίων, η εκτέλεση απαγορεύεται.

#### Kernel usage of PAN / PXN in a hardened OS (e.g. iOS / XNU)

Σε ένα hardened kernel design (όπως αυτό που μπορεί να χρησιμοποιεί η Apple):

- Ο kernel ενεργοποιεί το PAN από προεπιλογή (ώστε ο privileged κώδικας να περιορίζεται).
- Σε μονοπάτια που νόμιμα πρέπει να διαβάσουν ή να γράψουν buffers χρήστη (π.χ. syscall buffer copy, I/O, read/write user pointer), ο kernel προσωρινά **απενεργοποιεί το PAN** ή χρησιμοποιεί ειδικές εντολές για override.
- Μετά την ολοκλήρωση της πρόσβασης σε δεδομένα χρήστη, πρέπει να επανενεργοποιήσει το PAN.
- Το PXN επιβάλλεται μέσω των page tables: οι user σελίδες έχουν PXN = 1 (ώστε ο kernel να μην μπορεί να τις εκτελέσει), οι kernel σελίδες δεν έχουν PXN (ώστε ο kernel κώδικας να εκτελείται).
- Ο kernel πρέπει να διασφαλίσει ότι δεν υπάρχουν μονοπάτια κώδικα που προκαλούν εκτέλεση σε user περιοχές (που θα παρακάμπτανε το PXN) — έτσι οι αλυσίδες εκμετάλλευσης που βασίζονται στο “jump into user-controlled shellcode” μπλοκάρονται.

Λόγω της αναφερθείσας PAN bypass μέσω execute-only σελίδων, σε ένα πραγματικό σύστημα, η Apple μπορεί να απενεργοποιεί ή να απαγορεύει execute-only user σελίδες, ή να επιδιορθώνει το γύρω από την ατέλεια της προδιαγραφής.

#### Attack surfaces, bypasses, and mitigations

- **PAN bypass via execute-only pages**: όπως συζητήθηκε, η προδιαγραφή αφήνει ένα κενό: user σελίδες με execute-only (χωρίς read perm) μπορεί να μην μετρηθούν ως “accessible at EL0,” οπότε το PAN δεν θα εμποδίσει τον kernel από το να διαβάσει αυτές τις σελίδες σε κάποιες υλοποιήσεις. Αυτό δίνει στον επιτιθέμενο μια ασυνήθιστη οδό για να τροφοδοτήσει δεδομένα μέσω “execute-only” τμημάτων.
- **Temporal window exploit**: αν ο kernel απενεργοποιεί το PAN για παράθυρο μεγαλύτερο από το απαραίτητο, ένας race ή μονοπάτι με κακόβουλη συμπεριφορά μπορεί να εκμεταλλευτεί αυτό το παράθυρο για να πραγματοποιήσει απρόβλεπτη πρόσβαση μνήμης χρήστη.
- **Forgotten re-enable**: αν μονοπάτια κώδικα ξεχάσουν να επανενεργοποιήσουν το PAN, επακόλουθες kernel λειτουργίες μπορεί να προσπελάσουν λάθος μνήμη χρήστη.
- **Misconfiguration of PXN**: αν τα page tables δεν ρυθμίσουν PXN στις user σελίδες ή χαρτογραφήσουν λανθασμένα τις σελίδες κώδικα χρήστη, ο kernel μπορεί να παραπλανηθεί και να εκτελέσει κώδικα χρήστη.
- **Speculation / side-channels**: ανάλογα με τις speculative παρακάμψεις, μπορεί να υπάρχουν μικροαρχιτεκτονικές παρενέργειες που προκαλούν παροδική παράβαση των ελέγχων PAN / PXN (αν και τέτοιες επιθέσεις εξαρτώνται πολύ από το σχέδιο της CPU).
- **Complex interactions**: σε πιο προχωρημένες λειτουργίες (π.χ. JIT, shared memory, περιοχές code-cache), ο kernel μπορεί να χρειάζεται λεπτομερή έλεγχο για να επιτρέψει ορισμένες προσβάσεις ή εκτέλεση σε user-mapped περιοχές· το σωστό σχεδιασμό αυτών υπό τους περιορισμούς PAN/PXN δεν είναι απλό.

#### Example

<details>
<summary>Code Example</summary>
Εδώ είναι ενδεικτικές pseudo-assembly ακολουθίες που δείχνουν την ενεργοποίηση/απενεργοποίηση του PAN γύρω από πρόσβαση σε μνήμη χρήστη, και πώς μπορεί να προκύψει ένα σφάλμα.
</details>
```  
// Suppose kernel entry point, PAN is enabled (privileged code cannot access user memory by default)

; Kernel receives a syscall with user pointer in X0
; wants to read an integer from user space
mov   X1, X0        ; X1 = user pointer

; disable PAN to allow privileged access to user memory
MSR   PSTATE.PAN, #0   ; clear PAN bit, disabling the restriction

ldr   W2, [X1]       ; now allowed load from user address

; re-enable PAN before doing other kernel logic
MSR   PSTATE.PAN, #1   ; set PAN

; ... further kernel work ...

; Later, suppose an exploit corrupts a pointer to a user-space code page and jumps there
BR    X3             ; branch to X3 (which points into user memory)

; Because the target page is marked PXN = 1 for privileged execution,
; the CPU throws an exception (fault) and rejects execution
```
Αν ο kernel είχε **όχι** ορίσει το PXN σε εκείνη τη σελίδα χρήστη, τότε το branch μπορεί να πετύχει — κάτι που θα ήταν ανασφαλές.

Εάν ο kernel ξεχάσει να ενεργοποιήσει ξανά το PAN μετά από πρόσβαση σε μνήμη χρήστη, ανοίγει ένα παράθυρο όπου περαιτέρω λογική του kernel μπορεί κατά λάθος να διαβάσει/γράψει αυθαίρετη μνήμη χρήστη.

Εάν ο user pointer δείχνει σε execute-only σελίδα (σελίδα χρήστη με μόνο execute δικαίωμα, χωρίς read/write), υπό το σφάλμα στη προδιαγραφή PAN, `ldr W2, [X1]` μπορεί **να μη** προκαλέσει fault ακόμα και με PAN ενεργό, επιτρέποντας ένα bypass exploit, ανάλογα με την υλοποίηση.

</details>

<details>
<summary>Example</summary>
Μια ευπάθεια στον kernel προσπαθεί να πάρει έναν από χρήστη παρεχόμενο function pointer και να τον καλέσει στο πλαίσιο του kernel (π.χ. `call user_buffer`). Υπό PAN/PXN, αυτή η ενέργεια απαγορεύεται ή προκαλεί fault.
</details>

---

### 11. **Top Byte Ignore (TBI) / Pointer Tagging**
**Introduced in ARMv8.5 / newer (or optional extension)**
TBI σημαίνει ότι το top byte (το πιο σημαντικό byte) ενός 64-bit pointer αγνοείται από τη μετάφραση διευθύνσεων. Αυτό επιτρέπει στο OS ή στο hardware να ενσωματώσει **tag bits** στο top byte του pointer χωρίς να επηρεάζει τη πραγματική διεύθυνση.

- TBI stands for **Top Byte Ignore** (sometimes called *Address Tagging*). Είναι μια hardware δυνατότητα (διαθέσιμη σε πολλές υλοποιήσεις ARMv8+) που **αγνοεί τα πάνω 8 bits** (bits 63:56) ενός 64-bit pointer κατά την εκτέλεση της **address translation / load/store / instruction fetch**.
- Στην πράξη, η CPU αντιμετωπίζει έναν pointer `0xTTxxxx_xxxx_xxxx` (όπου `TT` = top byte) ως `0x00xxxx_xxxx_xxxx` για σκοπούς address translation, αγνοώντας (μηδενίζοντας) το top byte. Το top byte μπορεί να χρησιμοποιηθεί από το software για να αποθηκεύσει **metadata / tag bits**.
- Αυτό δίνει στο software «δωρεάν» in-band χώρο για να ενσωματώσει ένα byte tag σε κάθε pointer χωρίς να αλλάζει τη μνήμη στην οποία αναφέρεται.
- Η αρχιτεκτονική διασφαλίζει ότι τα loads, stores και instruction fetch αντιμετωπίζουν το pointer με το top byte μασκαρισμένο (δηλ. χωρίς το tag) πριν πραγματοποιήσουν την πραγματική πρόσβαση στη μνήμη.

Έτσι το TBI αποσυνδέει τον **logical pointer** (pointer + tag) από τη **physical address** που χρησιμοποιείται για λειτουργίες μνήμης.

#### Why TBI: Use cases and motivation

- **Pointer tagging / metadata**: Μπορείτε να αποθηκεύσετε επιπλέον metadata (π.χ. object type, version, bounds, integrity tags) σε αυτό το top byte. Όταν αργότερα χρησιμοποιήσετε το pointer, το tag αγνοείται σε hardware επίπεδο, οπότε δεν χρειάζεται να το αφαιρέσετε χειροκίνητα για την πρόσβαση στη μνήμη.
- **Memory tagging / MTE (Memory Tagging Extension)**: Το TBI είναι ο βασικός μηχανισμός hardware πάνω στον οποίο βασίζεται το MTE. Σε ARMv8.5, το **Memory Tagging Extension** χρησιμοποιεί τα bits 59:56 του pointer ως **logical tag** και τα ελέγχει έναντι ενός **allocation tag** που αποθηκεύεται στη μνήμη.
- **Enhanced security & integrity**: Συνδυάζοντας το TBI με pointer authentication (PAC) ή runtime ελέγχους, μπορείτε να απαιτήσετε όχι μόνο την ορθότητα της τιμής του pointer αλλά και του tag. Ένας επιτιθέμενος που αντικαθιστά έναν pointer χωρίς το σωστό tag θα προκαλέσει μη συμβατό tag.
- **Compatibility**: Επειδή το TBI είναι προαιρετικό και τα tag bits αγνοούνται από το hardware, ο υπάρχων μη-ετικετοποιημένος κώδικας συνεχίζει να λειτουργεί κανονικά. Τα tag bits ουσιαστικά γίνονται «bits που δεν έχουν σημασία» για legacy κώδικα.

#### Example
<details>
<summary>Example</summary>
Ένας function pointer περιείχε ένα tag στο top byte του (π.χ. `0xAA`). Ένα exploit αντικαθιστά τα χαμηλά bits του pointer αλλά παραλείπει το tag, έτσι όταν ο kernel επαληθεύει ή κάνει sanitization, ο pointer αποτυγχάνει ή απορρίπτεται.
</details>

---

### 12. **Page Protection Layer (PPL)**
**Introduced in late iOS / modern hardware (iOS ~17 / Apple silicon / high-end models)** (μερικές αναφορές δείχνουν PPL περίπου στο macOS / Apple silicon, αλλά η Apple φέρνει αναλογικές προστασίες στο iOS)

- Το PPL έχει σχεδιαστεί ως ένα **intra-kernel protection boundary**: ακόμα κι αν ο kernel (EL1) έχει παραβιαστεί και έχει δικαιώματα read/write, **δεν θα πρέπει να μπορεί να τροποποιεί ελεύθερα** ορισμένες **ευαίσθητες σελίδες** (ειδικά page tables, metadata υπογραφής κώδικα, kernel code pages, entitlements, trust caches, κ.λπ.).
- Στην ουσία δημιουργεί έναν **“kernel within the kernel”** — ένα μικρότερο αξιόπιστο συστατικό (PPL) με **elevated privileges** που μόνο αυτό μπορεί να τροποποιεί προστατευμένες σελίδες. Άλλος kernel κώδικας πρέπει να καλεί PPL routines για να κάνει αλλαγές.
- Αυτό μειώνει την attack surface για kernel exploits: ακόμα κι αν υπάρχει πλήρης αυθαίρετο R/W/execute σε kernel mode, ο exploit κώδικας πρέπει με κάποιο τρόπο να εισέλθει στο PPL domain (ή να παρακάμψει το PPL) για να τροποποιήσει κρίσιμες δομές.
- Σε νεότερο Apple silicon (A15+ / M2+), η Apple μεταβαίνει σε **SPTM (Secure Page Table Monitor)**, που σε πολλές περιπτώσεις αντικαθιστά το PPL για προστασία των page-tables σε αυτές τις πλατφόρμες.

Ακολουθεί πώς πιστεύεται ότι λειτουργεί το PPL, βάσει δημόσιας ανάλυσης:

#### Use of APRR / permission routing (APRR = Access Permission ReRouting)

- Το Apple hardware χρησιμοποιεί έναν μηχανισμό που ονομάζεται **APRR (Access Permission ReRouting)**, ο οποίος επιτρέπει στα page table entries (PTEs) να περιέχουν μικρούς δείκτες (indices), αντί για πλήρη permission bits. Αυτοί οι δείκτες χαρτογραφούνται μέσω των APRR registers σε πραγματικά δικαιώματα. Αυτό επιτρέπει δυναμική επαναχαρτογράφηση των δικαιωμάτων ανά domain.
- Το PPL αξιοποιεί το APRR για να διαχωρίσει τα προνόμια μέσα στο kernel context: μόνο το PPL domain επιτρέπεται να ενημερώνει τη χαρτογράφηση μεταξύ indices και των πραγματικών δικαιωμάτων. Δηλαδή, όταν μη-PPL kernel κώδικας γράφει ένα PTE ή προσπαθεί να αλλάξει permission bits, η λογική APRR το απορρίπτει (ή επιβάλλει read-only χαρτογράφηση).
- Ο ίδιος ο κώδικας PPL τρέχει σε μια περιορισμένη περιοχή (π.χ. `__PPLTEXT`) η οποία κανονικά δεν είναι executable ή writable μέχρι οι entry gates να το επιτρέψουν προσωρινά. Ο kernel καλεί PPL entry points (“PPL routines”) για να εκτελέσει ευαίσθητες λειτουργίες.

#### Gate / Entry & Exit

- Όταν ο kernel χρειάζεται να τροποποιήσει μια προστατευμένη σελίδα (π.χ. να αλλάξει τα permissions μιας σελίδας kernel code, ή να τροποποιήσει page tables), καλεί μια **PPL wrapper** ρουτίνα, η οποία κάνει validation και κατόπιν μεταβαίνει στο PPL domain. Εκτός αυτού του domain, οι προστατευμένες σελίδες είναι ουσιαστικά read-only ή μη τροποποιήσιμες από τον κύριο kernel.
- Κατά την είσοδο στο PPL, οι APRR mappings προσαρμόζονται έτσι ώστε οι σελίδες μνήμης στην περιοχή PPL να ορίζονται ως **executable & writable** εντός PPL. Μετά την έξοδο, επιστρέφουν σε read-only / non-writable. Αυτό διασφαλίζει ότι μόνο καλά ελεγχόμενες PPL routines μπορούν να γράψουν στις προστατευμένες σελίδες.
- Εκτός PPL, οι προσπάθειες από kernel κώδικα να γράψουν σε αυτές τις προστατευμένες σελίδες θα προκαλέσουν fault (permission denied) επειδή η APRR mapping για αυτό το code domain δεν επιτρέπει εγγραφή.

#### Protected page categories

Οι σελίδες που το PPL τυπικά προστατεύει περιλαμβάνουν:

- Δομές page table (translation table entries, mapping metadata)
- Σελίδες κώδικα kernel, ειδικά αυτές που περιέχουν κρίσιμη λογική
- Metadata υπογραφής κώδικα (trust caches, signature blobs)
- Πίνακες entitlements, πίνακες επιβολής υπογραφής
- Άλλες υψηλής αξίας δομές kernel όπου ένα patch θα επέτρεπε την παράκαμψη ελέγχων υπογραφής ή την αλλοίωση credentials

Η ιδέα είναι ότι ακόμη κι αν η μνήμη του kernel είναι πλήρως υπό έλεγχο, ο επιτιθέμενος δεν μπορεί απλώς να κάνει patch ή να ξαναγράψει αυτές τις σελίδες, εκτός αν επίσης παραβιάσει τις PPL routines ή παρακάμψει το PPL.

#### Known Bypasses & Vulnerabilities

1. **Project Zero’s PPL bypass (stale TLB trick)**

- Μια δημόσια ανάλυση από το Project Zero περιγράφει μια παράκαμψη που περιλαμβάνει **stale TLB entries**.
- Η ιδέα:

1. Δεσμεύστε δύο φυσικές σελίδες A και B, μαρκάρετέ τες ως PPL σελίδες (ώστε να προστατεύονται).
2. Χαρτογραφήστε δύο virtual διευθύνσεις P και Q των οποίων οι L3 translation table σελίδες προέρχονται από τις A και B.
3. Τρέξτε ένα thread που συνεχώς θα προσπελαύνει το Q, διατηρώντας το TLB entry ζωντανό.
4. Καλέστε `pmap_remove_options()` για να αφαιρέσετε τις χαρτογραφήσεις που ξεκινούν από το P· εξαιτίας ενός bug, ο κώδικας λανθασμένα αφαιρεί τα TTEs και για τα P και Q, αλλά μόνο αναιρεί το TLB entry για το P, αφήνοντας το stale entry του Q ενεργό.
5. Επαναχρησιμοποιήστε το B (τον πίνακα της σελίδας Q) για να χαρτογραφήσετε αυθαίρετη μνήμη (π.χ. PPL-protected σελίδες). Επειδή το stale TLB entry εξακολουθεί να δείχνει στην παλιά χαρτογράφηση του Q, αυτή η χαρτογράφηση παραμένει έγκυρη για εκείνο το context.
6. Μέσω αυτού, ο επιτιθέμενος μπορεί να τοποθετήσει ένα writable mapping των PPL-protected σελίδων χωρίς να περάσει από το PPL interface.

- Αυτό το exploit απαιτούσε λεπτό έλεγχο της φυσικής χαρτογράφησης και της συμπεριφοράς του TLB. Δείχνει ότι ένα security boundary που βασίζεται στην ορθότητα του TLB / της χαρτογράφησης πρέπει να είναι εξαιρετικά προσεκτικό όσον αφορά τις invalidations του TLB και τη συνέπεια της χαρτογράφησης.

- Το Project Zero σχολίασε ότι παρακάμψεις όπως αυτή είναι λεπτές και σπάνιες, αλλά δυνατές σε πολύπλοκα συστήματα. Παρ' όλα αυτά, θεωρούν το PPL ως ισχυρή mitigation.

2. **Other potential hazards & constraints**

- Εάν ένας kernel exploit μπορεί να εισέλθει απευθείας στις PPL routines (καλώντας τα PPL wrappers), μπορεί να παρακάμψει τους περιορισμούς. Επομένως η επαλήθευση των ορισμάτων είναι κρίσιμη.
- Σφάλματα στον ίδιο τον κώδικα PPL (π.χ. arithmetic overflow, έλεγχοι ορίων) μπορούν να επιτρέψουν τροποποιήσεις εκτός ορίων εντός του PPL. Το Project Zero παρατήρησε ότι τέτοιο σφάλμα στο `pmap_remove_options_internal()` αξιοποιήθηκε στην παράκαμψή τους.
- Το όριο PPL είναι αναπόφευκτα συνδεδεμένο με την επιβολή σε επίπεδο hardware (APRR, memory controller), οπότε είναι τόσο ισχυρό όσο η υλοποίηση του hardware.

#### Example
<details>
<summary>Code Example</summary>
Ακολουθεί ένας απλοποιημένος pseudocode / λογική που δείχνει πώς ένας kernel μπορεί να καλέσει το PPL για να τροποποιήσει προστατευμένες σελίδες:
</details>
```c
// In kernel (outside PPL domain)
function kernel_modify_pptable(pt_addr, new_entry) {
// validate arguments, etc.
return ppl_call_modify(pt_addr, new_entry)  // call PPL wrapper
}

// In PPL (trusted domain)
function ppl_call_modify(pt_addr, new_entry) {
// temporarily enable write access to protected pages (via APRR adjustments)
aprr_set_index_for_write(PPL_INDEX)
// perform the modification
*pt_addr = new_entry
// restore permissions (make pages read-only again)
aprr_restore_default()
return success
}

// If kernel code outside PPL does:
*pt_addr = new_entry  // a direct write
// It will fault because APRR mapping for non-PPL domain disallows write to that page
```
Το kernel μπορεί να εκτελεί πολλές κανονικές λειτουργίες, αλλά μόνο μέσω των ρουτινών `ppl_call_*` μπορεί να αλλάξει προστατευμένες mappings ή να τροποποιήσει code.
</details>

<details>
<summary>Παράδειγμα</summary>
A kernel exploit tries to overwrite the entitlement table, or disable code-sign enforcement by modifying a kernel signature blob. Because that page is PPL-protected, the write is blocked unless going through the PPL interface. So even with kernel code execution, you cannot bypass code-sign constraints or modify credential data arbitrarily.
On iOS 17+ certain devices use SPTM to further isolate PPL-managed pages.
</details>

#### PPL → SPTM / Replacements / Future

- Σε σύγχρονα SoCs της Apple (A15 or later, M2 or later), η Apple υποστηρίζει **SPTM** (Secure Page Table Monitor), το οποίο **replaces PPL** για τις προστασίες των page tables.
- Apple calls out in documentation: “Page Protection Layer (PPL) and Secure Page Table Monitor (SPTM) enforce execution of signed and trusted code … PPL manages the page table permission overrides … Secure Page Table Monitor replaces PPL on supported platforms.”
- Η αρχιτεκτονική SPTM πιθανότατα μεταφέρει περισσότερη επιβολή πολιτικών σε έναν higher-privileged monitor έξω από τον έλεγχο του kernel, μειώνοντας περαιτέρω το trust boundary.

### MTE | EMTE | MIE

Ακολουθεί μια περιγραφή υψηλού επιπέδου του πώς λειτουργεί το EMTE στο πλαίσιο του MIE της Apple:

1. **Ανάθεση tag**
- Όταν δεσμεύεται μνήμη (π.χ. στο kernel or user space via secure allocators), σε εκείνο το μπλοκ ανατίθεται ένα **secret tag**.
- Ο pointer που επιστρέφεται στον χρήστη ή το kernel περιλαμβάνει αυτό το tag στα υψηλά του bits (χρησιμοποιώντας μηχανισμούς TBI / top byte ignore).

2. **Έλεγχος tag κατά την πρόσβαση**
- Όταν εκτελείται ένα load ή store χρησιμοποιώντας pointer, το hardware ελέγχει ότι το tag του pointer ταιριάζει με το tag του μπλοκ μνήμης (allocation tag). Αν υπάρχει mismatch, προκαλείται fault άμεσα (επειδή είναι synchronous).
- Επειδή είναι synchronous, δεν υπάρχει παράθυρο “delayed detection”.

3. **Retagging κατά το free / reuse**
- Όταν η μνήμη απελευθερώνεται, ο allocator αλλάζει το tag του μπλοκ (ώστε οι παλαιότεροι pointers με παλιά tags να μην ταιριάζουν πια).
- Ένας use-after-free pointer θα έχει επομένως ένα stale tag και mismatch κατά την πρόσβαση.

4. **Διαφοροποίηση tag γειτόνων για ανίχνευση overflows**
- Γειτονικές allocations λαμβάνουν διαφορετικά tags. Αν ένα buffer overflow διαχυθεί στη μνήμη του γείτονα, το tag mismatch προκαλεί fault.
- Αυτό είναι ιδιαίτερα ισχυρό στην ανίχνευση μικρών overflows που διασχίζουν όρια.

5. **Επιβολή εμπιστευτικότητας tag**
- Η Apple πρέπει να αποτρέψει τα tag values από being leaked (επειδή αν ο attacker μάθει το tag, θα μπορούσε να κατασκευάσει pointers με σωστά tags).
- Περιλαμβάνουν προστασίες (microarchitectural / speculative controls) για να αποφευχθεί side-channel leakage των bit του tag.

6. **Ενσωμάτωση kernel και user-space**
- Η Apple χρησιμοποιεί το EMTE όχι μόνο στο user-space αλλά και σε kernel / OS-critical components (για να προστατεύσει το kernel από memory corruption).
- Το hardware/OS διασφαλίζει ότι οι κανόνες tag εφαρμόζονται ακόμα και όταν το kernel εκτελείται εκ μέρους του user space.

<details>
<summary>Παράδειγμα</summary>
```
Allocate A = 0x1000, assign tag T1
Allocate B = 0x2000, assign tag T2

// pointer P points into A with tag T1
P = (T1 << 56) | 0x1000

// Valid store
*(P + offset) = value // tag T1 matches allocation → allowed

// Overflow attempt: P’ = P + size_of_A (into B region)
*(P' + delta) = value
→ pointer includes tag T1 but memory block has tag T2 → mismatch → fault

// Free A, allocator retags it to T3
free(A)

// Use-after-free:
*(P) = value
→ pointer still has old tag T1, memory region is now T3 → mismatch → fault
```
</details>

#### Περιορισμοί & προκλήσεις

- **Intrablock overflows**: Αν το overflow παραμένει μέσα στην ίδια allocation (δεν διασχίζει όριο) και το tag παραμένει το ίδιο, το tag mismatch δεν το εντοπίζει.
- **Tag width limitation**: Μόνο λίγα bits (π.χ. 4 bits, ή μικρό domain) είναι διαθέσιμα για το tag — περιορισμένος namespace.
- **Side-channel leaks**: Αν tag bits μπορούν να leaked (via cache / speculative execution), ο επιτιθέμενος μπορεί να μάθει έγκυρα tags και να παρακάμψει. Apple’s tag confidentiality enforcement is meant to mitigate this.
- **Performance overhead**: Οι έλεγχοι tag σε κάθε load/store προσθέτουν κόστος; η Apple πρέπει να βελτιστοποιήσει το hardware για να μειώσει το overhead.
- **Compatibility & fallback**: Σε παλαιότερο hardware ή σε μέρη που δεν υποστηρίζουν EMTE, πρέπει να υπάρχει fallback. Η Apple ισχυρίζεται ότι το MIE ενεργοποιείται μόνο σε συσκευές με υποστήριξη.
- **Complex allocator logic**: Ο allocator πρέπει να διαχειρίζεται tags, retagging, ευθυγράμμιση ορίων και να αποφεύγει mis-tag collisions. Σφάλματα στη λογική του allocator μπορούν να εισάγουν ευπάθειες.
- **Mixed memory / hybrid areas**: Μερική μνήμη μπορεί να παραμένει untagged (legacy), κάνοντας την διαλειτουργικότητα πιο περίπλοκη.
- **Speculative / transient attacks**: Όπως με πολλές microarchitectural protections, speculative execution ή micro-op fusions μπορεί να παρακάμψουν προσωρινά τους ελέγχους ή να leak tag bits.
- **Limited to supported regions**: Η Apple μπορεί να εφαρμόζει EMTE μόνο σε επιλεγμένες, υψηλού κινδύνου περιοχές (kernel, security-critical subsystems), όχι καθολικά.

---

## Key enhancements / differences compared to standard MTE

Here are the improvements and changes Apple emphasizes:

| Feature | Original MTE | EMTE (Apple’s enhanced) / MIE |
|---|---|---|
| **Check mode** | Supports synchronous and asynchronous modes. In async, tag mismatches are reported later (delayed)| Apple insists on **synchronous mode** by default—tag mismatches are caught immediately, no delay/race windows allowed.|
| **Coverage of non-tagged memory** | Accesses to non-tagged memory (e.g. globals) may bypass checks in some implementations | EMTE requires that accesses from a tagged region to non-tagged memory also validate tag knowledge, making it harder to bypass by mixing allocations.|
| **Tag confidentiality / secrecy** | Tags might be observable or leaked via side channels | Apple adds **Tag Confidentiality Enforcement**, which attempts to prevent leakage of tag values (via speculative side-channels etc.).|
| **Allocator integration & retagging** | MTE leaves much of allocator logic to software | Apple’s secure typed allocators (kalloc_type, xzone malloc, etc.) integrate with EMTE: when memory is allocated or freed, tags are managed at fine granularity.|
| **Always-on by default** | In many platforms, MTE is optional or off by default | Apple enables EMTE / MIE by default on supported hardware (e.g. iPhone 17 / A19) for kernel and many user processes.|

Because Apple controls both the hardware and software stack, it can enforce EMTE tightly, avoid performance pitfalls, and close side-channel holes.

---

## How EMTE works in practice (Apple / MIE)

Here’s a higher-level description of how EMTE operates under Apple’s MIE setup:

1. **Tag assignment**
- When memory is allocated (e.g. in kernel or user space via secure allocators), a **secret tag** is assigned to that block.
- The pointer returned to the user or kernel includes that tag in its high bits (using TBI / top byte ignore mechanisms).

2. **Tag checking on access**
- Whenever a load or store is executed using a pointer, the hardware checks that the pointer’s tag matches the memory block’s tag (allocation tag). If mismatch, it faults immediately (since synchronous).
- Because it's synchronous, there is no “delayed detection” window.

3. **Retagging on free / reuse**
- When memory is freed, the allocator changes the block’s tag (so older pointers with old tags no longer match).
- A use-after-free pointer would therefore have a stale tag and mismatch when accessed.

4. **Neighbor-tag differentiation to catch overflows**
- Adjacent allocations are given distinct tags. If a buffer overflow spills into neighbor’s memory, tag mismatch causes a fault.
- This is especially powerful in catching small overflows that cross boundary.

5. **Tag confidentiality enforcement**
- Apple must prevent tag values being leaked (because if attacker learns the tag, they could craft pointers with correct tags).
- They include protections (microarchitectural / speculative controls) to avoid side-channel leakage of tag bits.

6. **Kernel and user-space integration**
- Apple uses EMTE not just in user-space but also in kernel / OS-critical components (to guard kernel against memory corruption).
- The hardware/OS ensures tag rules apply even when kernel is executing on behalf of user space.

Because EMTE is built into MIE, Apple uses EMTE in synchronous mode across key attack surfaces, not as opt-in or debugging mode.

---

## Exception handling in XNU

When an **exception** occurs (e.g., `EXC_BAD_ACCESS`, `EXC_BAD_INSTRUCTION`, `EXC_CRASH`, `EXC_ARM_PAC`, etc.), the **Mach layer** of the XNU kernel is responsible for intercepting it before it becomes a UNIX-style **signal** (like `SIGSEGV`, `SIGBUS`, `SIGILL`, ...).

This process involves multiple layers of exception propagation and handling before reaching user space or being converted to a BSD signal.


### Exception Flow (High-Level)

1.  **CPU triggers a synchronous exception** (e.g., invalid pointer dereference, PAC failure, illegal instruction, etc.).

2.  **Low-level trap handler** runs (`trap.c`, `exception.c` in XNU source).

3.  The trap handler calls **`exception_triage()`**, the core of the Mach exception handling.

4.  `exception_triage()` decides how to route the exception:

-   First to the **thread's exception port**.

-   Then to the **task's exception port**.

-   Then to the **host's exception port** (often `launchd` or `ReportCrash`).

If none of these ports handle the exception, the kernel may:

-   **Convert it into a BSD signal** (for user-space processes).

-   **Panic** (for kernel-space exceptions).


### Core Function: `exception_triage()`

The function `exception_triage()` routes Mach exceptions up the chain of possible handlers until one handles it or until it's finally fatal. It's defined in `osfmk/kern/exception.c`.
```c
void exception_triage(exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt);
```
**Τυπική ροή κλήσεων:**

`exception_triage()
└── exception_deliver()
├── exception_deliver_thread()
├── exception_deliver_task()
└── exception_deliver_host()`

Αν όλα αποτύχουν → χειρίζεται από `bsd_exception()` → μεταφράζεται σε σήμα όπως `SIGSEGV`.


### Θύρες εξαίρεσης

Κάθε αντικείμενο Mach (thread, task, host) μπορεί να καταχωρήσει **θύρες εξαίρεσης**, όπου αποστέλλονται μηνύματα εξαίρεσης.

Ορίζονται από το API:
```
task_set_exception_ports()
thread_set_exception_ports()
host_set_exception_ports()
```
Κάθε exception port έχει:

-   Ένα **mask** (ποιες εξαιρέσεις θέλει να λαμβάνει)
-   Ένα **port name** (Mach port που θα λαμβάνει μηνύματα)
-   Ένα **behavior** (πώς ο kernel στέλνει το μήνυμα)
-   Ένα **flavor** (ποια κατάσταση thread να συμπεριληφθεί)


### Debuggers and Exception Handling

Ένας **debugger** (π.χ. LLDB) ορίζει ένα **exception port** στο target task ή thread, συνήθως χρησιμοποιώντας `task_set_exception_ports()`.

**Όταν προκύπτει μια εξαίρεση:**

-   Το Mach μήνυμα αποστέλλεται στη διεργασία debugger.
-   Ο debugger μπορεί να αποφασίσει να **χειριστεί** (συνέχιση, τροποποίηση καταχωρητών, παράλειψη εντολής) ή **να μην χειριστεί** την εξαίρεση.
-   Αν ο debugger δεν τη χειριστεί, η εξαίρεση προωθείται στο επόμενο επίπεδο (task → host).


### Flow of `EXC_BAD_ACCESS`

1.  Το thread κάνει dereference σε άκυρο pointer → ο CPU προκαλεί Data Abort.

2.  Ο kernel trap handler καλεί `exception_triage(EXC_BAD_ACCESS, ...)`.

3.  Το μήνυμα αποστέλλεται σε:

-   Thread port → (ο debugger μπορεί να αναχαιτίσει breakpoint).

-   Αν ο debugger αγνοήσει → Task port → (handler σε επίπεδο διεργασίας).

-   Αν αγνοηθεί → Host port (συνήθως ReportCrash).

4.  Αν κανείς δεν το χειριστεί → `bsd_exception()` μεταφράζεται σε `SIGSEGV`.


### PAC Exceptions

Όταν Pointer Authentication (PAC) αποτυγχάνει (ασυμφωνία υπογραφής), εγείρεται μια ειδική Mach εξαίρεση:

-   **`EXC_ARM_PAC`** (type)
-   Οι κωδικοί μπορεί να περιλαμβάνουν λεπτομέρειες (π.χ., τύπος κλειδιού, τύπος pointer).

Αν το binary έχει τη σημαία **`TFRO_PAC_EXC_FATAL`**, ο kernel θεωρεί τις αποτυχίες PAC ως **θανατηφόρες**, παρακάμπτοντας την αναχαίτιση από τον debugger. Αυτό γίνεται για να αποτραπεί η δυνατότητα επιτιθέμενων να χρησιμοποιήσουν debuggers για να παρακάμψουν τους ελέγχους PAC και είναι ενεργοποιημένο για **platform binaries**.


### Software Breakpoints

Ένα software breakpoint (`int3` on x86, `brk` on ARM64) υλοποιείται προκαλώντας ένα σκόπιμο σφάλμα.\
Ο debugger το αναχαιτίζει μέσω του exception port:

-   Τροποποιεί το instruction pointer ή τη μνήμη.
-   Επαναφέρει την αρχική εντολή.
-   Συνεχίζει την εκτέλεση.

Ο ίδιος μηχανισμός επιτρέπει να "πιάσετε" μια PAC exception --- **εκτός αν έχει οριστεί `TFRO_PAC_EXC_FATAL`**, οπότε ποτέ δεν φτάνει στον debugger.


### Conversion to BSD Signals

Αν κανένας handler δεν αποδεχθεί την εξαίρεση:

-   Ο kernel καλεί `task_exception_notify() → bsd_exception()`.

-   Αυτό αντιστοιχίζει Mach exceptions σε σήματα:

| Mach Exception | Signal |
| --- | --- |
| EXC_BAD_ACCESS | SIGSEGV or SIGBUS |
| EXC_BAD_INSTRUCTION | SIGILL |
| EXC_ARITHMETIC | SIGFPE |
| EXC_SOFTWARE | SIGTRAP |
| EXC_BREAKPOINT | SIGTRAP |
| EXC_CRASH | SIGKILL |
| EXC_ARM_PAC | SIGILL (on non-fatal) |


### Key Files in XNU Source

-   `osfmk/kern/exception.c` → Πυρήνας του `exception_triage()`, `exception_deliver_*()`.
-   `bsd/kern/kern_sig.c` → Λογική παράδοσης σημάτων.
-   `osfmk/arm64/trap.c` → Χειριστές παγίδων χαμηλού επιπέδου.
-   `osfmk/mach/exc.h` → Κωδικοί και δομές εξαιρέσεων.
-   `osfmk/kern/task.c` → Ρύθμιση exception port για task.

---

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

Ο kernel χρησιμοποιούσε έναν **zone allocator** (`kalloc`) χωρισμένο σε ζώνες (zones) σταθερού μεγέθους. Κάθε zone αποθηκεύει μόνο allocations μιας μοναδικής κλάσης μεγέθους.

Από την εικόνα:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Πολύ μικρές δομές kernel, δείκτες.                                          |
| `default.kalloc.32`  | 32 bytes     | Μικρές δομές, επικεφαλίδες αντικειμένων.                                    |
| `default.kalloc.64`  | 64 bytes     | Μηνύματα IPC, μικροί kernel buffers.                                        |
| `default.kalloc.128` | 128 bytes    | Μεσαία αντικείμενα όπως μέρη του `OSObject`.                                |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Μεγάλες δομές, μεταδεδομένα IOSurface/γραφικών.                             |

**Πώς λειτουργούσε:**
- Κάθε αίτημα κατανομής στρογγυλοποιούνταν **προς τα πάνω** στο πλησιέστερο μέγεθος zone. (π.χ., ένα αίτημα 50 bytes προσγειώνεται στο `kalloc.64` zone).
- Η μνήμη σε κάθε zone διατηρούνταν σε μια **λίστα ελεύθερων** — τα κομμάτια που απελευθερώνονταν από τον kernel επέστρεφαν σε αυτή τη zone.
- Αν υπερχείλιζες ένα buffer 64 bytes, θα έγραφες πάνω στο **επόμενο αντικείμενο στην ίδια zone**.

Αυτός είναι ο λόγος που το **heap spraying / feng shui** ήταν τόσο αποτελεσματικό: μπορούσες να προβλέψεις τους γείτονες αντικειμένων ψεκάζοντας allocations της ίδιας κλάσης μεγέθους.

### Η λίστα ελεύθερων

Μέσα σε κάθε kalloc zone, τα απελευθερωμένα αντικείμενα δεν επιστρέφονταν απευθείας στο σύστημα — πήγαιναν σε μια λίστα ελεύθερων (freelist), μια συνδεδεμένη λίστα διαθέσιμων κομματιών.

- Όταν ένα κομμάτι απελευθερωνόταν, ο kernel έγραφε έναν pointer στην αρχή αυτού του κομματιού → τη διεύθυνση του επόμενου ελεύθερου κομματιού στην ίδια zone.

- Η zone κρατούσε έναν δείκτη HEAD προς το πρώτο ελεύθερο κομμάτι.

- Η κατανομή πάντα χρησιμοποιούσε το τρέχον HEAD:

1. Αφαίρεση (pop) του HEAD (επιστρέφει τη μνήμη στον καλούντα).

2. Ενημέρωση HEAD = HEAD->next (αποθηκευμένο στην κεφαλίδα του απελευθερωμένου κομματιού).

- Η απελευθέρωση τοποθετούσε τα κομμάτια πίσω:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

Άρα η λίστα ελεύθερων ήταν απλώς μια συνδεδεμένη λίστα χτισμένη μέσα στην ίδια την απελευθερωμένη μνήμη.

Κανονική κατάσταση:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Εκμετάλλευση του freelist

Επειδή τα πρώτα 8 bytes ενός free chunk = freelist pointer, ένας επιτιθέμενος μπορεί να το αλλοιώσει:

1. **Heap overflow** σε διπλανό ελεύθερο chunk → επαναγράψει τον “next” pointer του.

2. **Use-after-free**: εγγραφή μέσα σε ελευθερωμένο αντικείμενο → επαναγράφει τον “next” pointer του.

Τότε, στην επόμενη κατανομή αυτού του μεγέθους:

- Ο allocator αφαιρεί (pop) το διεφθαρμένο chunk.

- Ακολουθεί τον “next” pointer που παρείχε ο επιτιθέμενος.

- Επιστρέφει pointer σε αυθαίρετη μνήμη, επιτρέποντας fake object primitives ή στοχευμένη υπεργραφή.

Visual example of freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
Αυτός ο σχεδιασμός freelist έκανε την εκμετάλλευση εξαιρετικά αποτελεσματική πριν το hardening: predictable neighbors από heap sprays, raw pointer freelist links, και η απουσία type separation επέτρεπαν σε επιτιθέμενους να κλιμακώσουν UAF/overflow bugs σε arbitrary kernel memory control.

### Heap Grooming / Feng Shui
Ο στόχος του heap grooming είναι να **διαμορφώσει το layout της heap** έτσι ώστε όταν ένας επιτιθέμενος ενεργοποιήσει ένα overflow ή use-after-free, το αντικείμενο-θύμα να βρίσκεται ακριβώς δίπλα σε ένα αντικείμενο που ελέγχεται από τον επιτιθέμενο.\
Με αυτόν τον τρόπο, όταν συμβεί memory corruption, ο επιτιθέμενος μπορεί αξιόπιστα να επικαλύψει (overwrite) το αντικείμενο-θύμα με ελεγχόμενα δεδομένα.

**Βήματα:**

1. Spray allocations (fill the holes)
- Με τον καιρό, η kernel heap κατακερματίζεται: κάποιες ζώνες έχουν κενά όπου παλιά objects απελευθερώθηκαν.
- Ο επιτιθέμενος αρχικά κάνει πολλές dummy allocations για να γεμίσει αυτά τα κενά, έτσι ώστε η heap να γίνει “packed” και προβλέψιμη.

2. Force new pages
- Μόλις γεμίσουν τα κενά, οι επόμενες allocations πρέπει να έρθουν από νέες σελίδες που προστίθενται στη ζώνη.
- Νέες σελίδες σημαίνουν ότι τα objects θα ομαδοποιηθούν μαζί, όχι σκορπισμένα σε παλιή fragmented μνήμη.
- Αυτό δίνει στον επιτιθέμενο πολύ καλύτερο έλεγχο των γειτόνων.

3. Place attacker objects
- Ο επιτιθέμενος ξανα-sprays, δημιουργώντας πολλά attacker-controlled objects σε αυτές τις νέες σελίδες.
- Αυτά τα objects είναι προβλέψιμα σε μέγεθος και τοποθέτηση (εφόσον ανήκουν στην ίδια zone).

4. Free a controlled object (make a gap)
- Ο επιτιθέμενος σκόπιμα απελευθερώνει ένα από τα δικά του objects.
- Αυτό δημιουργεί μια “τρύπα” στην heap, την οποία ο allocator θα ξαναχρησιμοποιήσει για την επόμενη allocation του ίδιου μεγέθους.

5. Victim object lands in the hole
- Ο επιτιθέμενος προκαλεί τον kernel να κάνει allocation του αντικειμένου-θύματος (αυτό που θέλει να αλλοιώσει).
- Εφόσον η τρύπα είναι η πρώτη διαθέσιμη θέση στο freelist, το θύμα τοποθετείται ακριβώς εκεί που ο επιτιθέμενος απελευθέρωσε το αντικείμενό του.

6. Overflow / UAF into victim
- Τώρα ο επιτιθέμενος έχει attacker-controlled objects γύρω από το θύμα.
- Με overflow από ένα από τα δικά του objects (ή επαναχρησιμοποίηση ενός freed), μπορεί αξιόπιστα να επικαλύψει τα memory fields του θύματος με επιλεγμένες τιμές.

**Γιατί λειτουργεί**:

- Zone allocator predictability: allocations του ίδιου μεγέθους προέρχονται πάντα από την ίδια zone.
- Freelist behavior: νέες allocations επαναχρησιμοποιούν πρώτα το πιο πρόσφατα freed chunk.
- Heap sprays: ο επιτιθέμενος γεμίζει τη μνήμη με προβλέψιμα περιεχόμενα και ελέγχει το layout.
- End result: ο επιτιθέμενος ελέγχει πού θα τοποθετηθεί το αντικείμενο-θύμα και ποια δεδομένα θα βρίσκονται δίπλα του.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Η Apple σκληροποίησε τον allocator και έκανε το **heap grooming πολύ πιο δύσκολο**:

### 1. From Classic kalloc to kalloc_type
- **Before**: υπήρχε μια ενιαία `kalloc.<size>` zone για κάθε size class (16, 32, 64, … 1280, κ.λπ.). Οποιοδήποτε object αυτού του μεγέθους τοποθετούνταν εκεί → attacker objects μπορούσαν να βρεθούν δίπλα σε privileged kernel objects.
- **Now**:
- Kernel objects κατανέμονται από **typed zones** (`kalloc_type`).
- Κάθε τύπος αντικειμένου (π.χ., `ipc_port_t`, `task_t`, `OSString`, `OSData`) έχει τη δική του αφιερωμένη zone, ακόμα κι αν έχουν το ίδιο μέγεθος.
- Ο χάρτης μεταξύ object type ↔ zone παράγεται από το **kalloc_type system** κατά το compile time.

Ένας επιτιθέμενος δεν μπορεί πλέον να εγγυηθεί ότι ελεγχόμενα δεδομένα (`OSData`) θα βρεθούν δίπλα σε ευαίσθητα kernel objects (`task_t`) ίδιου μεγέθους.

### 2. Slabs and Per-CPU Caches
- Η heap χωρίζεται σε **slabs** (σελίδες μνήμης κομμένες σε fixed-size chunks για εκείνη τη zone).
- Κάθε zone έχει μια **per-CPU cache** για να μειώσει το contention.
- Allocation path:
1. Προσπάθεια από per-CPU cache.
2. Αν είναι άδεια, τράβηγμα από το global freelist.
3. Αν το freelist είναι άδειο, allocation ενός νέου slab (μία ή περισσότερες σελίδες).
- **Όφελος**: Αυτή η αποκέντρωση κάνει τα heap sprays λιγότερο deterministic, καθώς οι allocations μπορεί να εξυπηρετηθούν από caches διαφορετικών CPUs.

### 3. Randomization inside zones
- Μέσα σε μια zone, τα freed elements δεν επιστρέφονται σε απλή FIFO/LIFO σειρά.
- Το σύγχρονο XNU χρησιμοποιεί **encoded freelist pointers** (safe-linking όπως στο Linux, εισήχθη ~iOS 14).
- Κάθε freelist pointer είναι **XOR-encoded** με ένα per-zone secret cookie.
- Αυτό αποτρέπει τους επιτιθέμενους από το να δημιουργήσουν ένα fake freelist pointer αν αποκτήσουν write primitive.
- Κάποιες allocations είναι **randomized στην τοποθέτησή τους μέσα σε ένα slab**, οπότε το spraying δεν εγγυάται adjacency.

### 4. Guarded Allocations
- Ορισμένα κρίσιμα kernel objects (π.χ., credentials, task structures) allocated σε **guarded zones**.
- Αυτές οι zones εισάγουν **guard pages** (unmapped memory) μεταξύ slabs ή χρησιμοποιούν **redzones** γύρω από αντικείμενα.
- Οποιοδήποτε overflow στο guard page προκαλεί fault → άμεσο panic αντί για silent corruption.

### 5. Page Protection Layer (PPL) and SPTM
- Ακόμα κι αν ελέγχεις ένα freed object, δεν μπορείς να τροποποιήσεις όλη την kernel memory:
- **PPL (Page Protection Layer)** επιβάλλει ότι ορισμένες περιοχές (π.χ., code signing data, entitlements) είναι **read-only** ακόμα και για τον ίδιο τον kernel.
- Σε **A15/M2+ devices**, αυτός ο ρόλος αντικαθίσταται/ενισχύεται από **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- Αυτά τα hardware-enforced layers σημαίνουν ότι οι επιτιθέμενοι δεν μπορούν να κλιμακώσουν από ένα single heap corruption σε arbitrary patching κρίσιμων security structures.
- **(Προστέθηκε / Ενισχύθηκε)**: επίσης, **PAC (Pointer Authentication Codes)** χρησιμοποιείται στον kernel για να προστατεύσει pointers (ειδικά function pointers, vtables) ώστε το forging ή η αλλοίωσή τους να γίνεται πιο δύσκολη.
- **(Προστέθηκε / Ενισχύθηκε)**: οι zones μπορεί να επιβάλλουν **zone_require / zone enforcement**, δηλ. ότι ένα αντικείμενο που απελευθερώθηκε μπορεί να επιστραφεί μόνο στην σωστή typed zone· μη έγκυρα cross-zone frees μπορεί να προκαλέσουν panic ή να απορριφθούν. (Η Apple αναφέρεται σε αυτό στα memory safety posts της)

### 6. Large Allocations
- Όχι όλες οι allocations περνούν από `kalloc_type`.
- Πολύ μεγάλες αιτήσεις (πάνω από ~16 KB) παρακάμπτουν τις typed zones και εξυπηρετούνται απευθείας από **kernel VM (kmem)** μέσω page allocations.
- Αυτές είναι λιγότερο προβλέψιμες, αλλά επίσης λιγότερο exploitable, επειδή δεν μοιράζονται slabs με άλλα objects.

### 7. Allocation Patterns Attackers Target
Ακόμα και με αυτές τις προστασίες, οι επιτιθέμενοι ψάχνουν ακόμα για:
- **Reference count objects**: αν μπορείς να χειριστείς retain/release counters, μπορείς να προκαλέσεις use-after-free.
- **Objects with function pointers (vtables)**: η αλλοίωση ενός τέτοιου αντικειμένου μπορεί ακόμα να δώσει control flow.
- **Shared memory objects (IOSurface, Mach ports)**: αυτοί παραμένουν στόχοι γιατί γεφυρώνουν user ↔ kernel.

Αλλά — σε αντίθεση με πριν — δεν μπορείς απλά να sprayάρεις `OSData` και να περιμένεις να γειτονεύσει ένα `task_t`. Χρειάζεσαι **type-specific bugs** ή **info leaks** για να πετύχεις.

### Example: Allocation Flow in Modern Heap

Υποθέτουμε ότι το userspace καλεί IOKit για να κάνει allocation ενός `OSData` αντικειμένου:

1. **Type lookup** → `OSData` mapάρει στη zone `kalloc_type_osdata` (size 64 bytes).
2. Έλεγχος per-CPU cache για free elements.
- Αν βρεθεί → επιστρέφεται ένα.
- Αν είναι άδεια → πάει στο global freelist.
- Αν το freelist είναι άδειο → allocate νέο slab (σελίδα 4KB → 64 chunks των 64 bytes).
3. Επιστροφή chunk στον caller.

**Freelist pointer protection**:
- Κάθε freed chunk αποθηκεύει τη διεύθυνση του επόμενου free chunk, αλλά encoded με ένα secret key.
- Η υπεργραφή αυτού του πεδίου με attacker data δεν θα λειτουργήσει εκτός κι αν γνωρίζεις το κλειδί.

---

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages, and **PAC** protects pointers |
| Allocation reuse validation     | None (freelist pointers raw)                               | **zone_require / zone enforcement**             |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |
| Large allocations handling      | All small allocations managed equally                       | Large ones bypass zones → handled via VM         |

---

## Modern Userland Heap (iOS, macOS — type-aware / xzone malloc)

Σε πρόσφατες εκδόσεις των Apple OS (ειδικά iOS 17+), η Apple εισήγαγε έναν πιο ασφαλή userland allocator, το **xzone malloc** (XZM). Αυτό είναι το user-space ανάλογο του kernel’s `kalloc_type`, εφαρμόζοντας type awareness, metadata isolation και memory tagging safeguards.

### Goals & Design Principles

- **Type segregation / type awareness**: ομαδοποίηση allocations ανά *type ή χρήση (pointer vs data)* για να αποφεύγεται type confusion και cross-type reuse.
- **Metadata isolation**: διαχωρισμός του heap metadata (π.χ. free lists, size/state bits) από τα object payloads ώστε out-of-bounds writes να έχουν μικρότερη πιθανότητα να καταστρέψουν metadata.
- **Guard pages / redzones**: εισαγωγή unmapped pages ή padding γύρω από allocations για να εντοπίζονται overflows.
- **Memory tagging (EMTE / MIE)**: λειτουργεί σε συνδυασμό με hardware tagging για να ανιχνεύει use-after-free, out-of-bounds και invalid accesses.
- **Scalable performance**: διατήρηση χαμηλού overhead, αποφυγή υπερβολικού fragmentation και υποστήριξη πολλαπλών allocations ανά δευτερόλεπτο με χαμηλή λανθάνουσα.

### Architecture & Components

Παρακάτω είναι τα κύρια στοιχεία του xzone allocator:

#### Segment Groups & Zones

- **Segment groups** χωρίζουν το address space ανά κατηγορίες χρήσης: π.χ. `data`, `pointer_xzones`, `data_large`, `pointer_large`.
- Κάθε segment group περιέχει **segments** (VM ranges) που φιλοξενούν allocations για αυτή την κατηγορία.
- Σε κάθε segment συνδέεται μια **metadata slab** (ξεχωριστή VM περιοχή) που αποθηκεύει metadata (π.χ. free/used bits, size classes) για εκείνο το segment. Αυτή η **out-of-line (OOL) metadata** εξασφαλίζει ότι το metadata δεν αναμιγνύεται με τα object payloads, μειώνοντας την πιθανότητα corruption από overflow.
- Τα segments χωρίζονται σε **chunks** (slices) τα οποία με τη σειρά τους υποδιαιρούνται σε **blocks** (units allocation). Ένα chunk δεσμεύεται σε μια συγκεκριμένη size class και segment group (δηλ. όλα τα blocks σε ένα chunk έχουν το ίδιο μέγεθος & category).
- Για μικρές/μεσαίες allocations, χρησιμοποιούνται fixed-size chunks· για μεγάλες/τεράστιες, μπορεί να γίνει ξεχωριστό mapping.

#### Chunks & Blocks

- Ένα **chunk** είναι μια περιοχή (συχνά αρκετών σελίδων) αφιερωμένη σε allocations μιας size class μέσα σε μια group.
- Μέσα σε ένα chunk, **blocks** είναι οι θέσεις διαθέσιμες για allocations. Τα freed blocks παρακολουθούνται μέσω της metadata slab — π.χ. μέσω bitmaps ή free lists που αποθηκεύονται out-of-line.
- Ανάμεσα σε chunks (ή εντός αυτών), μπορεί να εισαχθούν **guard slices / guard pages** (π.χ. unmapped slices) για να πιαστούν out-of-bounds writes.

#### Type / Type ID

- Κάθε allocation site (ή κλήση σε malloc, calloc, κ.λπ.) συνδέεται με ένα **type identifier** (ένα `malloc_type_id_t`) που κωδικοποιεί τι είδους αντικείμενο γίνεται allocation. Αυτό το type ID περνάει στον allocator, που το χρησιμοποιεί για να επιλέξει ποιο zone / segment θα εξυπηρετήσει την allocation.
- Εξαιτίας αυτού, ακόμα κι αν δύο allocations έχουν το ίδιο μέγεθος, μπορεί να πάνε σε εντελώς διαφορετικές zones αν οι τύποι διαφέρουν.
- Στις πρώιμες εκδόσεις του iOS 17, όχι όλα τα APIs (π.χ. CFAllocator) ήταν πλήρως type-aware· η Apple διόρθωσε κάποιες από αυτές τις αδυναμίες στο iOS 18.

---

### Allocation & Freeing Workflow

Εδώ είναι μια υψηλού επιπέδου ροή για το πώς λειτουργούν allocation και deallocation στο xzone:

1. Κλήση malloc / calloc / realloc / typed alloc με μέγεθος και type ID.
2. Ο allocator χρησιμοποιεί το **type ID** για να επιλέξει το σωστό segment group / zone.
3. Μέσα σε εκείνη τη zone/segment, αναζητά ένα chunk που έχει free blocks του ζητούμενου μεγέθους.
- Μπορεί να συμβουλευτεί **local caches / per-thread pools** ή **free block lists** από το metadata.
- Αν δεν υπάρχει διαθέσιμο block, μπορεί να allocate ένα νέο chunk σε εκείνη τη zone.
4. Το metadata slab ενημερώνεται (το free bit καθαρίζεται, bookkeeping).
5. Αν memory tagging (EMTE) είναι ενεργό, το επιστρεφόμενο block παίρνει ένα **tag**, και το metadata ενημερώνεται για την “live” κατάσταση του.
6. Όταν γίνεται `free()`:
- Το block σημειώνεται ως freed στο metadata (μέσω OOL slab).
- Το block μπορεί να μπει σε free list ή pooled για επαναχρησιμοποίηση.
- Προαιρετικά, τα περιεχόμενα του block μπορεί να καθαριστούν ή να poisoned για να μειωθεί το data leak ή η χρήση μετά από free.
- Το hardware tag που συνδέεται με το block μπορεί να απενεργοποιηθεί ή να re-tag.
- Αν ένα ολόκληρο chunk γίνει free (όλα τα blocks freed), ο allocator μπορεί να **reclaim** εκείνο το chunk (unmap ή return to OS) υπό πίεση μνήμης.

---

### Security Features & Hardening

Αυτές είναι οι άμυνες ενσωματωμένες στο σύγχρονο userland xzone:

| Feature | Purpose | Notes |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | Prevent overflow from corrupting metadata | Metadata lives in separate VM region (metadata slab)|
| **Guard pages / unmapped slices** | Catch out-of-bounds writes | Helps detect buffer overflows rather than silently corrupting adjacent blocks|
| **Type-based segregation** | Prevent cross-type reuse & type confusion | Even same-size allocations from different types go to different zones|
| **Memory Tagging (EMTE / MIE)** | Detect invalid access, stale references, OOB, UAF | xzone works in concert with hardware EMTE in synchronous mode (“Memory Integrity Enforcement”)|
| **Delayed reuse / poisoning / zap** | Reduce chance of use-after-free exploitation | Freed blocks may be poisoned, zeroed, or quarantined before reuse |
| **Chunk reclamation / dynamic unmapping** | Reduce memory waste and fragmentation | Entire chunks may be unmapped when unused |
| **Randomization / placement variation** | Prevent deterministic adjacency | Blocks in a chunk and chunk selection may have randomized aspects |
| **Segregation of “data-only” allocations** | Separate allocations that don’t store pointers | Reduces attacker control over metadata or control fields|

---

### Interaction with Memory Integrity Enforcement (MIE / EMTE)

- Το MIE (Memory Integrity Enforcement) της Apple είναι το hardware + OS framework που φέρνει την **Enhanced Memory Tagging Extension (EMTE)** σε always-on, synchronous mode σε σημαντικές επιφάνειες επίθεσης.
- Ο allocator xzone είναι θεμελιώδης βάση του MIE στο user space: allocations που γίνονται μέσω xzone παίρνουν tags, και οι προσβάσεις ελέγχονται από το hardware.
- Στο MIE, ο allocator, η ανάθεση tags, η διαχείριση metadata και η εφαρμογή εμπιστευτικότητας των tags είναι ενσωματωμένα ώστε τα memory errors (π.χ. stale reads, OOB, UAF) να ανιχνεύονται άμεσα και να μην εκμεταλλεύονται αργότερα.

---

Αν θέλεις, μπορώ επίσης να δημιουργήσω ένα cheat-sheet ή ένα διάγραμμα των xzone internals για το βιβλίο σου. Θες να το κάνω μετά;
::contentReference[oaicite:20]{index=20}


---

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
