# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

- **Code Signing** in iOS λειτουργεί απαιτώντας κάθε piece of executable code (apps, libraries, extensions, etc.) να είναι cryptographically signed με ένα certificate που εκδίδει η Apple. Όταν code φορτώνεται, iOS επαληθεύει την digital signature σε σχέση με το Apple’s trusted root. Αν η υπογραφή είναι άκυρη, λείπει ή έχει τροποποιηθεί, το OS αρνείται να το τρέξει. Αυτό αποτρέπει attackers από το να εγχύσουν malicious code σε legitimate apps ή να τρέξουν unsigned binaries, σταματώντας αποτελεσματικά τις περισσότερες exploit chains που βασίζονται στην εκτέλεση arbitrary ή tampered code.
- **CoreTrust** είναι το iOS subsystem υπεύθυνο για την επιβολή του code signing κατά το runtime. Επαληθεύει απευθείας τις υπογραφές χρησιμοποιώντας το Apple’s root certificate χωρίς να βασίζεται σε cached trust stores, πράγμα που σημαίνει ότι μόνο binaries signed by Apple (ή με valid entitlements) μπορούν να εκτελεστούν. Το CoreTrust διασφαλίζει ότι ακόμα και αν κάποιος attacker τροποποιήσει ένα app μετά την εγκατάσταση, αλλάξει system libraries ή προσπαθήσει να φορτώσει unsigned code, το σύστημα θα μπλοκάρει την εκτέλεση εκτός αν το code παραμένει σωστά signed. Αυτή η αυστηρή επιβολή κλείνει πολλούς post-exploitation vectors που παλαιότερες iOS εκδόσεις επέτρεπαν μέσω ασθενέστερων ή bypassable signature checks.
- **DEP (Data Execution Prevention)** σηματοδοτεί περιοχές μνήμης ως non-executable εκτός αν περιέχουν ρητά code. Αυτό σταματάει attackers από το να εγχύσουν shellcode σε data regions (π.χ. stack ή heap) και να το τρέξουν, αναγκάζοντάς τους να βασιστούν σε πιο πολύπλοκες τεχνικές όπως ROP (Return-Oriented Programming).
- **ASLR (Address Space Layout Randomization)** randomizes τις διευθύνσεις μνήμης του code, των libraries, του stack και του heap κάθε φορά που το σύστημα τρέχει. Αυτό καθιστά πολύ πιο δύσκολο για attackers να προβλέψουν που βρίσκονται χρήσιμες οδηγίες ή gadgets, καταστρέφοντας πολλές exploit chains που εξαρτώνται από fixed memory layouts.
- **KASLR (Kernel ASLR)** εφαρμόζει την ίδια ιδέα randomization στον iOS kernel. Με την ανακατάταξη της kernel’s base address σε κάθε boot, αποτρέπει τους attackers από το να εντοπίζουν αξιόπιστα kernel functions ή structures, αυξάνοντας τη δυσκολία των kernel-level exploits που διαφορετικά θα αποκτούσαν full system control.
- **KPP (Kernel Patch Protection)**, επίσης γνωστό ως **AMCC (Apple Mobile File Integrity)** στο iOS, παρακολουθεί συνεχώς τις kernel’s code pages για να βεβαιωθεί ότι δεν έχουν τροποποιηθεί. Αν εντοπιστεί οποιαδήποτε αλλοίωση—όπως ένα exploit που προσπαθεί να patchάρει kernel functions ή να εισάγει malicious code—η συσκευή θα panicάρει και θα κάνει reboot. Αυτή η προστασία καθιστά τα persistent kernel exploits πολύ πιο δύσκολα, καθώς οι attackers δεν μπορούν απλά να κάνουν hook ή patch kernel instructions χωρίς να προκαλέσουν system crash.
- **KTRR** είναι ένα hardware-based security feature που εισήχθη σε iOS συσκευές. Χρησιμοποιεί τον CPU’s memory controller για να σηματοδοτήσει το kernel’s code (text) section ως permanently read-only μετά το boot. Μόλις κλειδωθεί, ακόμη και ο kernel δεν μπορεί να τροποποιήσει αυτήν την περιοχή μνήμης. Αυτό αποτρέπει attackers—και ακόμα privileged code—από το να patchάρουν kernel instructions στο runtime, κλείνοντας μια μεγάλη κατηγορία exploits που βασίζονταν στο direct modification του kernel code.
- **PAC (Pointer Authentication Codes)** χρησιμοποιεί cryptographic signatures ενσωματωμένες σε unused bits των pointers για να επαληθεύσει την ακεραιότητά τους πριν τη χρήση. Όταν ένα pointer (π.χ. return address ή function pointer) δημιουργείται, ο CPU το signs με ένα secret key; πριν το dereference, ο CPU ελέγχει την υπογραφή. Αν το pointer έχει τροποποιηθεί, ο έλεγχος αποτυγχάνει και η εκτέλεση σταματά. Αυτό αποτρέπει attackers από το να forgάρουν ή να επαναχρησιμοποιήσουν corrupted pointers σε memory corruption exploits, κάνοντας τεχνικές όπως ROP ή JOP πολύ πιο δύσκολες για αξιόπιστη εκτέλεση.
- **PAN (Privilege Access never)** είναι ένα hardware feature που αποτρέπει τον kernel (privileged mode) από το να έχει άμεση πρόσβαση σε user-space memory εκτός αν ενεργοποιήσει ρητά την πρόσβαση. Αυτό εμποδίζει attackers που απέκτησαν kernel code execution από το να διαβάσουν ή να γράψουν εύκολα user memory για να escalate exploits ή να κλέψουν sensitive data. Με την επιβολή αυστηρού separation, το PAN μειώνει τον αντίκτυπο των kernel exploits και μπλοκάρει πολλές κοινές privilege-escalation τεχνικές.
- **PPL (Page Protection Layer)** είναι ένας iOS μηχανισμός ασφάλειας που προστατεύει κρίσιμες kernel-managed memory regions, ιδιαίτερα αυτές που αφορούν το code signing και τα entitlements. Εφαρμόζει αυστηρές write protections χρησιμοποιώντας την MMU και πρόσθετους ελέγχους, διασφαλίζοντας ότι ακόμη και privileged kernel code δεν μπορεί αυθαίρετα να τροποποιήσει sensitive pages. Αυτό αποτρέπει attackers που αποκτούν kernel-level execution από το να παραποιήσουν security-critical structures, καθιστώντας persistence και code-signing bypasses σημαντικά πιο δύσκολα.

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

The kernel χρησιμοποιούσε έναν **zone allocator** (`kalloc`) χωρισμένο σε fixed-size "zones."
Κάθε zone αποθηκεύει allocations μιας μόνο size class.

From the screenshot:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Πολύ μικρά kernel structs, pointers.                                        |
| `default.kalloc.32`  | 32 bytes     | Μικρές structs, object headers.                                             |
| `default.kalloc.64`  | 64 bytes     | IPC messages, tiny kernel buffers.                                          |
| `default.kalloc.128` | 128 bytes    | Μέσα αντικείμενα όπως μέρη του `OSObject`.                                  |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Μεγάλες δομές, IOSurface/graphics metadata.                                 |

**How it worked:**
- Κάθε allocation request округλωνόταν προς τα πάνω στο κοντινότερο zone size.
(Π.χ., ένα 50-byte request πάει στο `kalloc.64` zone).
- Η μνήμη σε κάθε zone κρατιόταν σε έναν **freelist** — chunks που απελευθερώνονταν από τον kernel επέστρεφαν σε εκείνο το zone.
- Αν υπέρβαινες ένα 64-byte buffer, θα έγραφες πάνω στο **επόμενο object στο ίδιο zone**.

Αυτός είναι ο λόγος που το heap spraying / feng shui ήταν τόσο αποτελεσματικό: μπορούσες να προβλέψεις τους γείτονες αντικειμένων ψεκάζοντας allocations της ίδιας size class.

### The freelist

Μέσα σε κάθε kalloc zone, τα freed objects δεν επιστρέφονταν απευθείας στο system — πήγαιναν σε έναν freelist, μια linked list από διαθέσιμα chunks.

- Όταν ένα chunk απελευθερωνόταν, ο kernel έγραφε έναν pointer στην αρχή αυτού του chunk → τη διεύθυνση του επόμενου free chunk στο ίδιο zone.

- Το zone κρατούσε ένα HEAD pointer προς το πρώτο free chunk.

- Η allocation πάντα χρησιμοποιούσε το τρέχον HEAD:

1. Pop HEAD (επιστρέφει αυτή τη μνήμη στον caller).

2. Ενημέρωση HEAD = HEAD->next (αποθηκευμένο στο header του freed chunk).

- Το freeing έσπρωχνε chunks πίσω:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

Άρα ο freelist ήταν απλά μια linked list χτισμένη μέσα στην ίδια τη freed μνήμη.

Normal state:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Εκμετάλλευση της freelist

Επειδή τα πρώτα 8 bytes ενός free chunk = freelist pointer, ένας επιτιθέμενος θα μπορούσε να το αλλοιώσει:

1. **Heap overflow** σε έναν γειτονικό freed chunk → υπεργραφή του “next” pointer.

2. **Use-after-free** εγγραφή σε ένα freed object → υπεργραφή του “next” pointer.

Έπειτα, στην επόμενη κατανομή αυτού του μεγέθους:

- Ο allocator απομακρύνει (pop) το corrupted chunk.
- Ακολουθεί τον “next” pointer που παρείχε ο επιτιθέμενος.
- Επιστρέφει δείκτη σε αυθαίρετη μνήμη, επιτρέποντας fake object primitives ή στοχευμένη υπεργραφή.

Οπτικό παράδειγμα του freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
Αυτός ο σχεδιασμός του freelist έκανε την εκμετάλλευση ιδιαίτερα αποτελεσματική πριν το hardening: predictable neighbors από heap sprays, raw pointer freelist links, και η απουσία διαχωρισμού τύπων επέτρεπε σε επιτιθέμενους να κλιμακώσουν σφάλματα UAF/overflow σε αυθαίρετο έλεγχο μνήμης του kernel.

### Heap Grooming / Feng Shui
Ο στόχος του Heap Grooming είναι να **διαμορφώσει τη διάταξη του heap** έτσι ώστε όταν ένας επιτιθέμενος ενεργοποιήσει ένα overflow ή use-after-free, το στοχευόμενο (victim) αντικείμενο να βρίσκεται ακριβώς δίπλα σε ένα αντικείμενο ελεγχόμενο από τον επιτιθέμενο.\
Με αυτόν τον τρόπο, όταν συμβεί διαφθορά μνήμης, ο επιτιθέμενος μπορεί αξιόπιστα να overwrite το victim αντικείμενο με ελεγχόμενα δεδομένα.

**Βήματα:**

1. Spray allocations (fill the holes)
- Με τον καιρό, το kernel heap θρυμματίζεται: κάποες ζώνες έχουν κενά όπου παλιά αντικείμενα απελευθερώθηκαν.
- Ο επιτιθέμενος αρχικά κάνει πολλές dummy allocations για να γεμίσει αυτά τα κενά, ώστε το heap να γίνει «συμπιεσμένο» και προβλέψιμο.

2. Force new pages
- Μόλις γεμίσουν τα κενά, οι επόμενες allocations πρέπει να προέλθουν από νέες σελίδες που προστίθενται στη ζώνη.
- Νέες σελίδες σημαίνουν ότι τα αντικείμενα θα ομαδοποιηθούν μαζί, και όχι διασκορπισμένα σε παλιά θραυσματοποιημένη μνήμη.
- Αυτό δίνει στον επιτιθέμενο πολύ καλύτερο έλεγχο των γειτόνων.

3. Place attacker objects
- Ο επιτιθέμενος κάνει ξανά spray, δημιουργώντας πολλά attacker-controlled αντικείμενα σε αυτές τις νέες σελίδες.
- Αυτά τα αντικείμενα έχουν προβλέψιμο μέγεθος και θέση (εφόσον ανήκουν στην ίδια ζώνη).

4. Free a controlled object (make a gap)
- Ο επιτιθέμενος εσκεμμένα απελευθερώνει ένα από τα αντικείμενά του.
- Αυτό δημιουργεί μια «τρύπα» στο heap, την οποία ο allocator θα επαναχρησιμοποιήσει για την επόμενη allocation αυτού του μεγέθους.

5. Victim object lands in the hole
- Ο επιτιθέμενος προκαλεί τον kernel να κάνει allocation του victim αντικειμένου (αυτού που θέλει να καταστρέψει).
- Εφόσον η τρύπα είναι η πρώτη διαθέσιμη θέση στο freelist, το victim τοποθετείται ακριβώς εκεί που ο επιτιθέμενος απελευθέρωσε το αντικείμενό του.

6. Overflow / UAF into victim
- Τώρα ο επιτιθέμενος έχει attacker-controlled αντικείμενα γύρω από το victim.
- Με overflow από ένα από τα δικά του αντικείμενα (ή με επαναχρησιμοποίηση ενός freed), μπορεί αξιόπιστα να overwrite τα πεδία μνήμης του victim με επιλεγμένες τιμές.

**Γιατί δουλεύει**:

- Predictability του zone allocator: allocations του ίδιου μεγέθους προέρχονται πάντα από την ίδια ζώνη.
- Συμπεριφορά freelist: οι νέες allocations επαναχρησιμοποιούν πρώτα το πιο πρόσφατα freed chunk.
- Heap sprays: ο επιτιθέμενος γεμίζει τη μνήμη με προβλέψιμο περιεχόμενο και ελέγχει τη διάταξη.
- Τελικό αποτέλεσμα: ο επιτιθέμενος ελέγχει πού land-άρει το victim αντικείμενο και ποια δεδομένα βρίσκονται δίπλα του.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Η Apple σκλήρυνε τον allocator και έκανε το **heap grooming πολύ δυσκολότερο**:

### 1. From Classic kalloc to kalloc_type
- **Πριν**: υπήρχε μία ζώνη `kalloc.<size>` για κάθε size class (16, 32, 64, … 1280, κ.λπ.). Οποιοδήποτε αντικείμενο αυτού του μεγέθους τοποθετούνταν εκεί → attacker objects μπορούσαν να βρεθούν δίπλα σε privileged kernel objects.
- **Τώρα**:
- Τα kernel objects κατανέμονται από **typed zones** (`kalloc_type`).
- Κάθε τύπος αντικειμένου (π.χ. `ipc_port_t`, `task_t`, `OSString`, `OSData`) έχει τη δική του αφιερωμένη ζώνη, ακόμα κι αν έχουν το ίδιο μέγεθος.
- Ο χάρτης τύπου ↔ ζώνης παράγεται από το **kalloc_type system** κατά τη διάρκεια της μεταγλώττισης.

Ένας επιτιθέμενος δεν μπορεί πλέον να εγγυηθεί ότι ελεγχόμενα δεδομένα (`OSData`) θα βρεθούν δίπλα σε ευαίσθητα kernel objects (`task_t`) του ίδιου μεγέθους.

### 2. Slabs and Per-CPU Caches
- Το heap διαιρείται σε **slabs** (σελίδες μνήμης χωρισμένες σε fixed-size chunks για εκείνη τη ζώνη).
- Κάθε ζώνη έχει ένα **per-CPU cache** για να μειωθεί η contention.
- Διαδρομή allocation:
1. Δοκιμή στο per-CPU cache.
2. Αν είναι άδειο, τράβηγμα από το global freelist.
3. Αν το freelist είναι άδειο, allocation νέου slab (μια ή περισσότερες σελίδες).
- **Όφελος**: αυτή η αποκέντρωση κάνει τα heap sprays λιγότερο ντετερμινιστικά, καθώς οι allocations μπορεί να καλυφθούν από caches διαφορετικών CPUs.

### 3. Randomization inside zones
- Μέσα σε μια ζώνη, τα freed στοιχεία δεν επιστρέφονται σε απλή FIFO/LIFO σειρά.
- Το σύγχρονο XNU χρησιμοποιεί **encoded freelist pointers** (safe-linking στυλ όπως το Linux, εισήχθη ~iOS 14).
- Κάθε freelist pointer **κωδικοποιείται με XOR** με ένα per-zone secret cookie.
- Αυτό αποτρέπει έναν επιτιθέμενο από το να κατασκευάσει ψεύτικο freelist pointer αν αποκτήσει write primitive.
- Κάποιες allocations **τυχαροποιούνται στην τοποθέτηση μέσα σε ένα slab**, έτσι το spraying δεν εγγυάται adjacency.

### 4. Guarded Allocations
- Ορισμένα κρίσιμα kernel objects (π.χ. credentials, task structures) κατανέμονται σε **guarded zones**.
- Αυτές οι ζώνες εισάγουν **guard pages** (απροσπέλαστη μνήμη) μεταξύ slabs ή χρησιμοποιούν **redzones** γύρω από αντικείμενα.
- Οποιοδήποτε overflow στο guard page προκαλεί fault → άμεσο panic αντί για σιωπηλή διαφθορά.

### 5. Page Protection Layer (PPL) and SPTM
- Ακόμα κι αν ελέγχεις ένα freed αντικείμενο, δεν μπορείς να τροποποιήσεις όλη τη kernel μνήμη:
- **PPL (Page Protection Layer)** επιβάλλει ότι ορισμένες περιοχές (π.χ. code signing data, entitlements) είναι **read-only** ακόμα και για τον ίδιο τον kernel.
- Σε **A15/M2+ devices**, αυτός ο ρόλος αντικαθίσταται/ενισχύεται από **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- Αυτά τα hardware-enforced επίπεδα σημαίνουν ότι οι επιτιθέμενοι δεν μπορούν να κλιμακώσουν από μια μεμονωμένη heap corruption σε αυθαίρετο patching κρίσιμων security structures.

### 6. Large Allocations
- Όλες οι allocations δεν περνάνε από `kalloc_type`.
- Πολύ μεγάλες αιτήσεις (πάνω από ~16KB) παρακάμπτουν τις typed zones και εξυπηρετούνται απευθείας από το **kernel VM (kmem)** μέσω page allocations.
- Αυτές είναι λιγότερο προβλέψιμες, αλλά και λιγότερο εκμεταλλεύσιμες, επειδή δεν μοιράζονται slabs με άλλα αντικείμενα.

### 7. Allocation Patterns Attackers Target
Ακόμα και με αυτές τις προστασίες, οι επιτιθέμενοι ψάχνουν για:
- **Reference count objects**: αν μπορείτε να τροποποιήσετε retain/release counters, μπορεί να προκαλέσετε use-after-free.
- **Objects with function pointers (vtables)**: η διαφθορά ενός τέτοιου αντικειμένου εξακολουθεί να δίνει control flow.
- **Shared memory objects (IOSurface, Mach ports)**: αυτοί παραμένουν στόχοι επειδή γεφυρώνουν user ↔ kernel.

Αλλά — σε αντίθεση με πριν — δεν μπορείτε απλώς να κάνετε spray `OSData` και να περιμένετε να βρίσκεται δίπλα σε `task_t`. Χρειάζεστε **bugs ειδικά για τύπους** ή **info leaks** για να επιτύχετε.

### Example: Allocation Flow in Modern Heap

Υποθέστε ότι userspace καλεί IOKit για να κάνει allocation ενός `OSData` αντικειμένου:

1. **Type lookup** → `OSData` αντιστοιχίζεται στη ζώνη `kalloc_type_osdata` (μέγεθος 64 bytes).
2. Έλεγχος per-CPU cache για διαθέσιμα στοιχεία.
- Αν βρεθεί → επιστρέφεται ένα.
- Αν είναι άδειο → πάει στο global freelist.
- Αν το freelist είναι άδειο → allocation νέου slab (σελίδα 4KB → 64 chunks των 64 bytes).
3. Επιστρέφεται chunk στον καλούντα.

**Freelist pointer protection**:
- Κάθε freed chunk αποθηκεύει τη διεύθυνση του επόμενου free chunk, αλλά κωδικοποιημένη με ένα secret key.
- Η υπεργραφή αυτού του πεδίου με attacker δεδομένα δεν θα λειτουργήσει εκτός αν γνωρίζετε το κλειδί.

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages   |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Κατεβάστε το BinDiff DMG από [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) και εγκαταστήστε το.

Ανοίξτε το Ghidra με `ghidraRun` και πηγαίνετε στο `File` --> `Install Extensions`, πατήστε το κουμπί add και επιλέξτε το path `/Applications/BinDiff/Extra/Ghidra/BinExport` και κάντε κλικ OK και isntall ακόμα και αν υπάρχει version mismatch.

### Using BinDiff with Kernel versions

1. Πηγαίνετε στη σελίδα [https://ipsw.me/](https://ipsw.me/) και κατεβάστε τις iOS versions που θέλετε να diff-άρετε. Αυτά θα είναι αρχεία `.ipsw`.
2. Αποσυμπιέστε μέχρι να πάρετε τη bin μορφή του kernelcache και για τα δύο `.ipsw` αρχεία. Υπάρχουν οδηγίες για το πώς να το κάνετε στο:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Ανοίξτε το Ghidra με `ghidraRun`, δημιουργήστε ένα νέο project και φορτώστε τα kernelcaches.
4. Ανοίξτε κάθε kernelcache ώστε να αναλυθούν αυτόματα από το Ghidra.
5. Στη συνέχεια, στο project Window του Ghidra, δεξί κλικ σε κάθε kernelcache, επιλέξτε `Export`, επιλέξτε format `Binary BinExport (v2) for BinDiff` και εξάγετε τα.
6. Ανοίξτε το BinDiff, δημιουργήστε ένα νέο workspace και προσθέστε ένα νέο diff δείχνοντας ως primary file το kernelcache που περιέχει την ευπάθεια και ως secondary file το patched kernelcache.

---

## Finding the right XNU version

Αν θέλετε να ελέγξετε για ευπάθειες σε μία συγκεκριμένη έκδοση iOS, μπορείτε να δείτε ποια XNU release version χρησιμοποιεί η έκδοση iOS στο [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

Για παράδειγμα, οι εκδόσεις `15.1 RC`, `15.1` και `15.1.1` χρησιμοποιούν την έκδοση `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.

### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
