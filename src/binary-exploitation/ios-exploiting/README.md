# iOS 漏洞利用

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

- **Code Signing** 在 iOS 中通过要求所有可执行代码（apps、libraries、extensions 等）必须使用 Apple 签发的证书进行加密签名来工作。当代码被加载时，iOS 会将数字签名与 Apple 的受信任根证书验证比对。如果签名无效、缺失或被修改，系统会拒绝运行。这样可以阻止攻击者向合法应用注入恶意代码或运行未签名的二进制，从而有效阻断依赖执行任意或被篡改代码的大多数利用链。
- **CoreTrust** 是负责在运行时强制执行 code signing 的 iOS 子系统。它直接使用 Apple 的根证书验证签名，而不依赖于缓存的信任存储，这意味着只有由 Apple 签名（或具有有效 entitlements）的二进制才能执行。CoreTrust 确保即便攻击者在安装后篡改了应用、修改系统库或尝试加载未签名代码，系统也会阻止执行，除非代码仍然正确签名。此严格的强制措施关闭了旧 iOS 版本中通过较弱或可绕过的签名检查允许的许多事后利用向量。
- **Data Execution Prevention (DEP)** 将内存区域标记为不可执行，除非它们明确包含代码。这阻止了攻击者在数据区域（比如栈或堆）注入 shellcode 并执行，迫使攻击者依赖更复杂的技术如 ROP（Return-Oriented Programming）。
- **ASLR (Address Space Layout Randomization)** 随机化代码、库、栈和堆的内存地址，每次系统运行时都不同。这让攻击者更难预测有用指令或 gadget 的位置，破坏了许多依赖固定内存布局的利用链。
- **KASLR (Kernel ASLR)** 将相同的随机化概念应用到 iOS 内核。通过在每次启动时打乱内核基地址，它阻止攻击者可靠地定位内核函数或结构，从而提高了内核级漏洞利用（可能获取完整系统控制）的难度。
- **Kernel Patch Protection (KPP)**，也称为 **AMCC (Apple Mobile File Integrity)**，持续监控内核的代码页以确保它们未被修改。如果检测到任何篡改——例如利用尝试修补内核函数或插入恶意代码——设备会立即 panic 并重启。该保护使得持久化内核利用变得更加困难，因为攻击者无法在不触发系统崩溃的情况下简单地 hook 或修补内核指令。
- **Kernel Text Readonly Region (KTRR)** 是在 iOS 设备上引入的基于硬件的安全特性。它使用 CPU 的内存控制器在启动后将内核的代码（text）段标记为永久只读。一旦锁定，即使是内核本身也无法修改该内存区域。这阻止了攻击者——甚至是有特权的代码——在运行时修补内核指令，关闭了依赖直接修改内核代码的主要利用类别。
- **Pointer Authentication Codes (PAC)** 使用嵌入在指针未使用位内的加密签名来在使用前验证其完整性。当创建指针（比如返回地址或函数指针）时，CPU 使用一个秘密密钥对其签名；在解引用之前，CPU 会检查签名。如果指针被篡改，检查就会失败并停止执行。这阻止攻击者在内存损坏漏洞中伪造或重用被破坏的指针，使得像 ROP 或 JOP 这样的技术更难可靠实施。
- **Privilege Access never (PAN)** 是一项硬件特性，防止内核（特权模式）在未显式启用访问的情况下直接访问 user-space 内存。这阻止了在已获得内核代码执行的情况下，攻击者轻易读取或写入用户内存以升级利用或窃取敏感数据。通过强制严格隔离，PAN 降低了内核利用的影响并阻断了许多常见的权限提升技术。
- **Page Protection Layer (PPL)** 是一种 iOS 安全机制，用于保护关键的内核管理内存区域，特别是与 code signing 和 entitlements 相关的那些。它使用 MMU（Memory Management Unit）和额外的检查来强制严格的写保护，确保即使是有特权的内核代码也无法任意修改敏感页。这阻止了在获得内核级执行权限的情况下篡改安全关键结构，使持久化和绕过 code-signing 变得明显更难。

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

内核使用了一个 **zone allocator** (`kalloc`)，被划分为固定大小的 "zones"。每个 zone 仅存储单一大小类别的分配。

From the screenshot:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | 非常小的内核结构体、指针。                                                   |
| `default.kalloc.32`  | 32 bytes     | 小型结构体、对象头。                                                         |
| `default.kalloc.64`  | 64 bytes     | IPC messages、微小的内核缓冲区。                                             |
| `default.kalloc.128` | 128 bytes    | 中等对象，例如 `OSObject` 的部分。                                           |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | 大型结构体，IOSurface/图形元数据。                                           |

**工作原理：**
- 每个分配请求会被**向上取整**到最近的 zone 大小。（例如，一个 50 字节的请求会落入 `kalloc.64` zone。）
- 每个 zone 的内存通过一个 **free list** 保存——被内核释放的块会回到同一 zone。
- 如果你溢出一个 64 字节的缓冲区，你会覆盖同一 zone 中的**下一个对象**。

这就是为什么 **heap spraying / feng shui** 如此有效：你可以通过喷射相同大小类别的分配来预测对象邻居。

### The freelist

在每个 kalloc zone 内，已释放的对象不会直接返回给系统——它们进入了 freelist，一个可用块的链表。

- 当一个块被释放时，内核会在该块的起始处写入一个指针 → 指向同一 zone 中下一个空闲块的地址。

- zone 保持一个 HEAD 指针，指向第一个空闲块。

- 分配总是使用当前的 HEAD：

1. Pop HEAD（将该内存返回给调用者）。

2. 更新 HEAD = HEAD->next（存储在被释放块的头部）。

- 释放时把块推回去：

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

所以 freelist 只是一个构建在已释放内存内部的链表。

正常状态：
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### 利用 freelist

因为 free chunk 的前 8 字节 = freelist pointer，攻击者可以破坏它：

1. **Heap overflow**：写入到相邻的 freed chunk → 覆盖其 “next” pointer。
2. **Use-after-free**：写入到 freed object → 覆盖其 “next” pointer。

随后，在下一次分配相同大小时：

- 分配器弹出被篡改的 chunk。
- 跟随攻击者提供的 “next” pointer。
- 返回指向任意内存的指针，从而实现 fake object primitives 或定向覆盖。

freelist poisoning 的可视化示例：
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
在加固之前，这种 freelist 设计使得利用变得高度有效：来自 heap sprays 的可预测邻居、原始指针 freelist 链接以及缺乏类型隔离使攻击者能够将 UAF/overflow 漏洞升级为对任意内核内存的控制。

### Heap Grooming / Feng Shui
The goal of heap grooming is to **shape the heap layout** so that when an attacker triggers an overflow or use-after-free, the target (victim) object sits right next to an attacker-controlled object.\
That way, when memory corruption happens, the attacker can reliably overwrite the victim object with controlled data.

**Steps:**

1. Spray allocations (fill the holes)
- 随着时间推移，kernel heap 会碎片化：有些 zone 会出现旧对象被释放后留下的空洞。
- 攻击者首先进行大量的伪分配以填充这些间隙，使堆变得“紧凑”且可预测。

2. Force new pages
- 一旦这些空洞被填满，后续分配必须从该 zone 新增加的页面中获得。
- 新页面意味着对象会被聚集在一起，而不会散布在旧的碎片化内存中。
- 这让攻击者对邻居对象的控制力大大增强。

3. Place attacker objects
- 攻击者再次进行 spray，在那些新页面中创建大量 attacker-controlled objects。
- 这些对象在大小和位置上是可预测的（因为它们属于同一 zone）。

4. Free a controlled object (make a gap)
- 攻击者故意 free 掉自己其中一个对象。
- 这在堆中创建了一个“洞”，分配器随后会重用该尺寸的下一个分配槽。

5. Victim object lands in the hole
- 攻击者触发内核分配他们想要破坏的 victim object。
- 由于该洞是 freelist 中可用的第一个槽，victim 就会被放置在攻击者之前释放的位置。

6. Overflow / UAF into victim
- 现在攻击者在 victim 周围有 attacker-controlled objects。
- 通过从自己的对象溢出（或重用已释放的对象），他们可以可靠地用选定值覆盖 victim 的内存字段。

**Why it works**：

- Zone allocator predictability：相同大小的分配总是来自相同的 zone。
- Freelist behavior：新的分配会优先重用最近释放的 chunk。
- Heap sprays：攻击者用可预测内容填充内存并控制布局。
- 结果：攻击者能控制 victim 对象的落点以及其相邻的数据。

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple 对分配器进行了加固，使得 **heap grooming 更难**：

### 1. From Classic kalloc to kalloc_type
- **Before**: a single `kalloc.<size>` zone existed for each size class (16, 32, 64, … 1280, etc.). Any object of that size was placed there → attacker objects could sit next to privileged kernel objects.
- **Now**：
- Kernel objects are allocated from **typed zones** (`kalloc_type`)。
- 每种对象类型（例如 `ipc_port_t`、`task_t`、`OSString`、`OSData`）都有自己的专用 zone，即使它们大小相同。
- 对象类型 ↔ zone 的映射由编译时的 **kalloc_type system** 生成。

攻击者不再能够保证受控数据（例如 `OSData`）会与敏感内核对象（例如 `task_t`）在同一邻近位置。

### 2. Slabs and Per-CPU Caches
- heap 被划分为 **slabs**（将页面切分为该 zone 的固定大小块）。
- 每个 zone 都有一个 **per-CPU cache** 来减少争用。
- 分配路径：
1. 先尝试 per-CPU cache。
2. 若为空，从 global freelist 获取。
3. 若 freelist 为空，分配一个新 slab（一个或多个页面）。
- **好处**：这种去中心化使得 heap sprays 变得不那么确定，因为分配可能来自不同 CPU 的缓存。

### 3. Randomization inside zones
- 在同一 zone 内，已释放元素不会以简单的 FIFO/LIFO 顺序返还。
- 现代 XNU 使用 **encoded freelist pointers**（类似 safe-linking 的方式，大约在 iOS 14 引入）。
- 每个 freelist 指针都用每个 zone 的 secret cookie 进行 **XOR 编码**。
- 这阻止了攻击者在获得写原语后伪造假的 freelist 指针。
- 某些分配在 slab 内的放置位置也会被 **随机化**，因此 spray 并不能保证邻近性。

### 4. Guarded Allocations
- 某些关键内核对象（例如凭证、task 结构）会分配到 **guarded zones**。
- 这些 zone 在 slabs 之间插入 **guard pages**（未映射内存）或在对象周围使用 **redzones**。
- 任何溢出进入 guard page 都会触发 fault → 直接 panic 而不是静默破坏。

### 5. Page Protection Layer (PPL) and SPTM
- 即使你控制了一个已释放对象，也不能修改内核内的所有内存：
- **PPL (Page Protection Layer)** 强制某些区域（例如 code signing 数据、entitlements）对内核自身也为 **只读**。
- 在 **A15/M2+ 设备** 上，这一角色由 **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)** 替代/增强。
- 这些硬件强制的层级意味着攻击者无法仅通过一次 heap 损坏就任意修改关键安全结构。

### 6. Large Allocations
- 并非所有分配都经过 `kalloc_type`。
- 非常大的请求（大约超过 ~16KB）会绕过 typed zones，直接通过页面分配从 **kernel VM (kmem)** 提供。
- 这些分配的可预测性较低，但也较难被利用，因为它们不与其他对象共享 slabs。

### 7. Allocation Patterns Attackers Target
即便有这些保护，攻击者仍然会寻找：
- **Reference count objects**：如果你能篡改 retain/release 计数，可能导致 use-after-free。
- **Objects with function pointers (vtables)**：破坏这些仍能得到控制流。
- **Shared memory objects (IOSurface, Mach ports)**：这些仍是攻击目标，因为它们桥接 user ↔ kernel。

但是 — 与以前不同 — 你不能只 spray 一个 `OSData` 并指望它会邻接到 `task_t`。你需要 **类型特定的漏洞** 或 **info leaks** 来成功。

### Example: Allocation Flow in Modern Heap

Suppose userspace calls into IOKit to allocate an `OSData` object:

1. **Type lookup** → `OSData` maps to `kalloc_type_osdata` zone (size 64 bytes).
2. Check per-CPU cache for free elements.
- If found → return one.
- If empty → go to global freelist.
- If freelist empty → allocate a new slab (page of 4KB → 64 chunks of 64 bytes).
3. Return chunk to caller.

**Freelist pointer protection**：
- 每个已释放的 chunk 存储下一个空闲 chunk 的地址，但该地址已用一个 secret key 编码。
- 在不知道 key 的情况下用攻击者数据覆盖该字段不会奏效。

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages   |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`。


### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
