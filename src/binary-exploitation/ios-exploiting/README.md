# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

### 1. **Code Signing** / Runtime Signature Verification
**Introduced early (iPhone OS → iOS)**
Ovo je jedna od osnovnih zaštita: **sav izvršni kod** (apps, dynamic libraries, JIT-ed code, extensions, frameworks, caches) mora biti kriptografski potpisan sertifikatnim lancem koji se završava u Apple-ovom root-u poverenja. Pri izvršavanju, pre nego što se binarni fajl učita u memoriju (ili pre nego što se izvrše skokovi preko određenih granica), sistem proverava njegov potpis. Ako je kod izmenjen (bit-flip, patch) ili nije potpisan, učitavanje ne uspeva.

- **Onemogućava**: fazu „classic payload drop + execute“ u exploit lancima; arbitrary code injection; izmenu postojećeg binarnog fajla radi ubacivanja maliciozne logike.
- **Detalji mehanizma**:
* Mach-O loader (i dynamic linker) proveravaju code pages, сегменте, entitlements, team IDs i da li potpis pokriva sadržaj fajla.
* Za memorijske regione kao što su JIT caches ili dinamički generisan kod, Apple zahteva da stranice budu potpisane ili validirane preko specijalnih API-ja (npr. `mprotect` sa code-sign proverama).
* Potpis uključuje entitlements i identifikatore; OS zahteva da određeni API-ji ili privilegovane sposobnosti zahtevaju specifična entitlements koja se ne mogu falsifikovati.

<details>
<summary>Example</summary>
Pretpostavimo da exploit dobije code execution u procesu i pokuša da upiše shellcode u heap i skoči na njega. Na iOS-u ta stranica bi morala biti označena kao executable **i** ispuniti code-signature uslove. Pošto shellcode nije potpisan Apple-ovim sertifikatom, skok ne uspeva ili sistem odbija da tu memorijsku oblast učini izvršnom.
</details>


### 2. **CoreTrust**
**Introduced around iOS 14+ era (or gradually in newer devices / later iOS)**
CoreTrust je subsistem koji obavlja **runtime signature validation** binarnih fajlova (uključujući sistemske i korisničke binare) protiv **Apple’s root certificate** umesto oslanjanja na keširane userland trust store-ove.

- **Onemogućava**: post-install tampering binarima, jailbreaking tehnike koje pokušavaju da zamene ili zakrpe sistemske biblioteke ili user apps; prevaru sistema zamenom trusted binarima malicioznim ekvivalentima.
- **Detalji mehanizma**:
* Umesto da veruje lokalnoj trust bazi ili kešu sertifikata, CoreTrust referiše ili verifikuje Apple-ov root direktno ili proverava intermediate sertifikate u sigurnom lancu.
* Osigurava da se izmene (npr. u fajl sistemu) postojećih binarnih fajlova otkriju i odbiju.
* Veže entitlements, team IDs, code signing flag-ove i drugu metadata za binarni fajl pri učitavanju.

<details>
<summary>Example</summary>
Jailbreak bi mogao pokušati da zameni `SpringBoard` ili `libsystem` patch-ovanom verzijom da dobije persistenciju. Ali kada loader OS-a ili CoreTrust izvrši proveru, primeti mismatch potpisa (ili izmenjene entitlements) i odbije izvršavanje.
</details>


### 3. **Data Execution Prevention (DEP / NX / W^X)**
**Introduced in many OSes earlier; iOS had NX-bit / w^x for a long time**
DEP nameće da stranice označene kao writable (za data) budu **non-executable**, a stranice označene kao executable budu **non-writable**. Ne možete jednostavno upisati shellcode u heap ili stack region i izvršiti ga.

- **Onemogućava**: direktno izvršavanje shellcode-a; classic buffer-overflow → skok na injektovani shellcode.
- **Detalji mehanizma**:
* MMU / memory protection flags (preko page tables) nameću razdvajanje.
* Svaki pokušaj da se writable stranici dodeli executable svojstvo pokreće sistemsku proveru (i ili je zabranjen ili zahteva code-sign odobrenje).
* U mnogim slučajevima, pravljenje stranica executable zahteva korišćenje OS API-ja koji nameću dodatne restrikcije ili provere.

<details>
<summary>Example</summary>
Overflow upisuje shellcode u heap. Napadač pokušava `mprotect(heap_addr, size, PROT_EXEC)` da bi je učinio izvršnom. Ali sistem odbija ili validira da nova stranica mora proći code-sign ograničenja (koja shellcode ne može).
</details>

### 4. **Address Space Layout Randomization (ASLR)**
**Introduced in iOS ~4–5 era (roughly iOS 4–5 timeframe)**
ASLR randomizuje osnovne adrese ključnih memorijskih regiona: libraries, heap, stack, itd., pri svakom pokretanju procesa. Adrese gadgets-a se menjaju između pokretanja.

- **Onemogućava**: hardkodiranje gadget adresa za ROP/JOP; statične exploit lance; slepo skakanje na poznate offset-e.
- **Detalji mehanizma**:
* Svaka učitana biblioteka / dynamic module se rebāsuје na randomizovani offset.
* Stack i heap base pointer-i su randomizovani (u okviru određenih entropijskih ograničenja).
* Ponekad i drugi regioni (npr. mmap alokacije) su takođe randomizovani.
* U kombinaciji sa information-leak mitigacijama, tera napadača da prvo leak-uje adresu ili pointer kako bi otkrio base adrese u runtime-u.

<details>
<summary>Example</summary>
ROP chain očekuje gadget na `0x….lib + offset`. Pošto se `lib` relocate-uje drugačije pri svakom pokretanju, hardkodovani chain ne funkcioniše. Exploit mora prvo leak-ovati baznu adresu modula pre nego što izračuna gadget adrese.
</details>


### 5. **Kernel Address Space Layout Randomization (KASLR)**
**Introduced in iOS ~ (iOS 5 / iOS 6 timeframe)**
Analogno korisničkom ASLR-u, KASLR randomizuje bazu **kernel text** i drugih kernel struktura pri boot-u.

- **Onemogućava**: kernel-level exploite koji se oslanjaju na fiksne lokacije kernel koda ili podataka; statične kernel exploite.
- **Detalji mehanizma**:
* Pri svakom boot-u, baza kernela se randomizuje (u okviru nekog opsega).
* Kernel data strukture (kao `task_structs`, `vm_map`, itd.) takođe mogu biti relocirane ili imati offset.
* Napadači moraju prvo leak-ovati kernel pointer-e ili koristiti information disclosure ranjivosti da izračunaju offset-e pre nego što hijack-uju kernel strukture ili kod.

<details>
<summary>Example</summary>
Lokalna ranjivost cilja da korumpira kernel function pointer (npr. u `vtable`) na `KERN_BASE + offset`. Ali pošto je `KERN_BASE` nepoznat, napadač mora prvo leak-ovati istog (npr. preko read primitive) pre nego što izračuna pravu adresu za korupciju.
</details>


### 6. **Kernel Patch Protection (KPP / AMCC)**
**Introduced in newer iOS / A-series hardware (post around iOS 15–16 era or newer chips)**
KPP (aka AMCC) kontinuirano nadzire integritet kernel text stranica (preko hash-a ili checksuma). Ako detektuje tampering (patch-e, inline hook-ove, izmene koda) van dozvoljenih prozora, pokreće kernel panic ili reboot.

- **Onemogućava**: persistent kernel patching (izmenu kernel instrukcija), inline hook-ove, statičke overwrite-e funkcija.
- **Detalji mehanizma**:
* Hardverski ili firmware modul nadgleda kernel text region.
* Periodično ili na zahtev re-hash-uje stranice i upoređuje sa očekivanim vrednostima.
* Ako se jave mismatch-evi van benignih update prozora, izaziva panic uređaja (da bi se izbegla persistent maliciozna patch).
* Napadači moraju ili izbeći detekcione prozore ili koristiti legitimne putanje za patch.

<details>
<summary>Example</summary>
Exploit pokušava da patch-uje kernel function prologue (npr. `memcmp`) da presretne pozive. Ali KPP primeti da se hash code stranice više ne slaže sa očekivanom vrednošću i izazove kernel panic, rušeći uređaj pre nego što patch postane stabilan.
</details>


### 7. **Kernel Text Read‐Only Region (KTRR)**
**Introduced in modern SoCs (post ~A12 / newer hardware)**
KTRR je hardverski sprovodljiva mera: jednom kada je kernel text zaključan rano tokom boot-a, postaje read-only sa EL1 (kernel) nivoa, onemogućavajući dalja pisanja u code pages.

- **Onemogućava**: bilo kakve izmene kernel koda nakon boot-a (npr. patching, in-place code injection) na EL1 privilegovanom nivou.
- **Detalji mehanizma**:
* Tokom boot-a (u secure/bootloader fazi), memory controller (ili neki secure hardware unit) označava fizičke stranice koje sadrže kernel text kao read-only.
* Čak i ako exploit dobije pune kernel privilegije, ne može pisati na te stranice da bi patchovao instrukcije.
* Da bi ih modifikovao, napadač mora prvo kompromitovati boot chain ili subvert-ovati sam KTRR.

<details>
<summary>Example</summary>
Privilege-escalation exploit skoči u EL1 i pokuša da upiše trampoline u kernel funkciju (npr. u `syscall` handler). Ali zato što su stranice zaključane kao read-only od strane KTRR, upis ne uspeva (ili izazove fault), pa se patch ne primeni.
</details>


### 8. **Pointer Authentication Codes (PAC)**
**Introduced with ARMv8.3 (hardware), Apple beginning with A12 / iOS ~12+**
- PAC je hardverska funkcija uvedena u **ARMv8.3-A** da detektuje tampering pointer vrednosti (return addresses, function pointers, određene data pointer-e) ubacujući mali kriptografski potpis (MAC) u neiskorišćene visoke bitove pointera.
- Potpis (“PAC”) se računa preko pointer vrednosti plus **modifier** (kontekstualna vrednost, npr. stack pointer ili neki distinguishing podatak). Na taj način ista pointer vrednost u različitim kontekstima dobija različit PAC.
- Pri upotrebi, pre dereferenciranja ili grananja preko tog pointera, instrukcija za **authenticate** proverava PAC. Ako je validan, PAC se odstrani i dobija se čisti pointer; ako nije, pointer postaje „poisoned“ (ili se podigne fault).
- Ključevi koji se koriste za proizvodnju/validaciju PAC-a žive u privilegovanim registrima (EL1, kernel) i nisu direktno čitljivi iz user mode.
- Pošto se ne koriste svi 64 bita pointera u mnogim sistemima (npr. 48-bit address space), gornji bitovi su „slobodni“ i mogu držati PAC bez menjanja efektivne adrese.

#### Architectural Basis & Key Types

- ARMv8.3 uvodi **pet 128-bitnih ključeva** (svaki implementiran preko dva 64-bit sistema registra) za pointer authentication.
- **APIAKey** — za instruction pointers (domen “I”, ključ A)
- **APIBKey** — drugi ključ za instruction pointers (domen “I”, ključ B)
- **APDAKey** — za data pointer-e (domen “D”, ključ A)
- **APDBKey** — za data pointer-e (domen “D”, ključ B)
- **APGAKey** — “generic” ključ, za potpisivanje non-pointer podataka ili druge generičke upotrebe

- Ovi ključevi su skladišteni u privilegovanim sistemskim registrima (pristup samo na EL1/EL2 itd.), nisu dostupni iz user mode.
- PAC se računa kroz kriptografski algoritam (ARM predlaže QARMA kao algoritam) koristeći:
1. Vrednost pointera (kanonnični deo)
2. **modifier** (kontekstualna vrednost, kao salt)
3. Tajni ključ
4. Neki interni tweak logiku
Ako rezultujući PAC odgovara onome što je smešteno u gornjim bitovima pointera, autentikacija uspe.

#### Instruction Families

Konvencija imenovanja je: **PAC** / **AUT** / **XPAC**, pa domeni.
- `PACxx` instrukcije **sign**-uju pointer i ubacuju PAC
- `AUTxx` instrukcije **authenticate + strip** (validiraju i uklanjaju PAC)
- `XPACxx` instrukcije **strip** bez validacije

Domains / sufiksi:

| Mnemonic     | Meaning / Domain                      | Key / Domain     | Example Usage in Assembly |
|--------------|-----------------------------------------|--------------------|-----------------------------|
| **PACIA**    | Sign instruction pointer with APIAKey   | “I, A”             | `PACIA X0, X1` — sign pointer in X0 using APIAKey with modifier X1|
| **PACIB**    | Sign instruction pointer with APIBKey   | “I, B”             | `PACIB X2, X3`              |
| **PACDA**    | Sign data pointer with APDAKey           | “D, A”             | `PACDA X4, X5`              |
| **PACDB**    | Sign data pointer with APDBKey           | “D, B”             | `PACDB X6, X7`              |
| **PACG / PACGA** | Generic (non-pointer) signing with APGAKey | “G”         | `PACGA X8, X9, X10` (sign X9 with modifier X10 into X8) |
| **AUTIA**    | Authenticate APIA-signed instruction pointer & strip PAC | “I, A” | `AUTIA X0, X1` — check PAC on X0 using modifier X1, then strip |
| **AUTIB**    | Authenticate APIB domain                 | “I, B”             | `AUTIB X2, X3`               |
| **AUTDA**    | Authenticate APDA-signed data pointer    | “D, A”             | `AUTDA X4, X5`               |
| **AUTDB**    | Authenticate APDB-signed data pointer    | “D, B”             | `AUTDB X6, X7`               |
| **AUTGA**    | Authenticate generic / blob (APGA)        | “G”               | `AUTGA X8, X9, X10` (validate generic) |
| **XPACI**     | Strip PAC (instruction pointer, no validation) | “I”         | `XPACI X0` — remove PAC from X0 (instruction domain) |
| **XPACD**     | Strip PAC (data pointer, no validation)    | “D”             | `XPACD X4` — remove PAC from data pointer in X4 |

Postoje specijalizovani / alias oblici:

- `PACIASP` je skraćeno za `PACIA X30, SP` (sign the link register using SP as modifier)
- `AUTIASP` je `AUTIA X30, SP` (authenticate link register with SP)
- Kombinovani oblici poput `RETAA`, `RETAB` (authenticate-and-return) ili `BLRAA` (authenticate & branch) postoje u ARM ekstenzijama / podršci kompajlera.
- Takođe varijante sa nul-modifierom: `PACIZA` / `PACIZB` gde je modifier implicitno zero, itd.

#### Modifiers

Glavni cilj modifier-a je da **veže PAC za specifičan kontekst** tako da ista adresa potpisana u različitim kontekstima daje različite PAC-ove. To sprečava jednostavnu ponovnu upotrebu pointera između frejmova ili objekata. To je kao dodavanje **salta hash-u.**

Dakle:
- **modifier** je kontekstualna vrednost (drugi registar) koja se meša u PAC računanje. Tipični izbori: stack pointer (`SP`), frame pointer, ili neki object ID.
- Korišćenje SP kao modifier-a je uobičajeno za signing return address-a: PAC postaje vezan za konkretan stack frame. Ako pokušate da ponovo iskoristite LR u drugom frejmu, modifier se menja i PAC validacija pada.
- Ista pointer vrednost potpisana pod različitim modifier-ima daje različite PAC-ove.
- modifier ne mora biti tajan, ali idealno nije kontrolisan od strane napadača.
- Za instrukcije koje potpisuju ili verifikuju pointer-e gde nema smislenog modifier-a, neke forme koriste zero ili implicitnu konstantu.

#### Apple / iOS / XNU Customizations & Observations

- Apple-ova PAC implementacija uključuje **per-boot diversifiers** tako da ključevi ili tweak-ovi menjaju pri svakom boot-u, sprečavajući reuse između boot-ova.
- Takođe uključuju **cross-domain mitigacije** tako da PAC-ovi potpisi iz user mode-a ne mogu lako da se re-use-uju u kernel mode, itd.
- Na Apple M1 / Apple Silicon, reverzni inženjering je pokazao da postoji **devet tipova modifier-a** i Apple-specifični sistemski registri za kontrolu ključeva.
- Apple koristi PAC u mnogim kernel podsistemima: signing povratnih adresa, integritet pointera u kernel podacima, potpisani thread context-i, itd.
- Google Project Zero je pokazao kako pod moćnim memory read/write primitive-om u kernelu, moguće je falsifikovati kernel PAC-ove (za A ključeve) na A12-era uređajima, ali Apple je zakrpio mnoge od tih puteva.
- U Apple-ovom sistemu, neki ključevi su **globalni preko kernela**, dok korisnički procesi mogu dobiti per-process randomness ključeva.

#### PAC Bypasses

1. **Kernel-mode PAC: theoretical vs real bypasses**

-   Pošto su kernel PAC ključevi i logika strogo kontrolisani (privilegovani registri, diversifier-i, domain izolacija), falsifikovanje arbitrarnih potpisanih kernel pointera je veoma teško.
-   Azad-ov 2020 "iOS Kernel PAC, One Year Later" izvestio je da je u iOS 12–13 pronašao nekoliko delimičnih bypass-ova (signing gadgets, reuse signed states, unprotected indirect branches) ali ne i potpuni generički bypass. [bazad.github.io](https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf)
-   Apple-ove "Dark Magic" customizacije dodatno su suzile površine za eksploataciju (domain switching, per-key enabling bits). [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Poznat je **kernel PAC bypass CVE-2023-32424** na Apple silicon (M1/M2) prijavljen od strane Zecao Cai et al. [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Ali ovi bypass-ovi često se oslanjaju na vrlo specifične gadget-e ili implementacione bagove; nisu general-purpose.

Dakle kernel PAC se smatra **veoma robusnim**, iako ne i savršenim.

2. **User-mode / runtime PAC bypass techniques**

Ovi su češći, i iskorišćavaju nedostatke u tome kako se PAC primenjuje ili koristi u dynamic linking / runtime framework-ovima. Ispod su klase, sa primerima.

2.1 **Shared Cache / A key issues**

-   **dyld shared cache** je velika pre-linked blob sistema frameworks i biblioteka. Pošto se široko deli, function pointer-i unutar shared cache-a su „pre-signed“ i onda koriste od strane mnogih procesa. Napadači ciljaju te već potpisane pointer-e kao „PAC oracles“.

-   Neki bypass pristupi pokušavaju da ekstrahuju ili re-use-uju A-key signed pointer-e prisutne u shared cache i iskoriste ih u gadget lancima.

-   Predavanje "No Clicks Required" opisuje izgradnju oracle-a nad shared cache-om da bi se inferisale relativne adrese i kombinovalo to sa signed pointer-ima da bi se zaobišao PAC. [saelo.github.io](https://saelo.github.io/presentations/offensivecon_20_no_clicks.pdf)

-   Takođe, import-ovi function pointer-a iz shared libraries u userspace su bili nalazeni kao nedovoljno zaštićeni od PAC-a, dozvoljavajući napadaču da dobije function pointer-e bez menjanja njihovog potpisa. (Project Zero bug entry) [bugs.chromium.org](https://bugs.chromium.org/p/project-zero/issues/detail?id=2044&utm_source=chatgpt.com)

2.2 **dlsym(3) / dynamic symbol resolution**

-   Jedan poznati bypass je pozvati `dlsym()` da se dobije *already signed* function pointer (potpisan sa A-key, diversifier zero) i onda ga koristiti. Pošto `dlsym` vraća legitimno signed pointer, korišćenje istog zaobilazi potrebu za falsifikovanjem PAC-a.

-   Epsilon-ov blog detaljno opisuje kako neki bypass-i iskorišćavaju ovo: poziv `dlsym("someSym")` vraća signed pointer koji se može iskoristiti za indirect calls. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

-   Synacktiv-ov tekst "iOS 18.4 --- dlsym considered harmful" opisuje bag: neki symbol-i resolvani preko `dlsym` na iOS 18.4 vraćaju pointer-e koji su pogrešno potpisani (ili sa buggy diversifier-ima), omogućavajući nenameran PAC bypass. [Synacktiv](https://www.synacktiv.com/en/publications/ios-184-dlsym-considered-harmful)

-   Logika u dyld za dlsym uključuje: kada `result->isCode`, oni sign-uju vraćeni pointer sa `__builtin_ptrauth_sign_unauthenticated(..., key_asia, 0)`, tj. kontekst zero. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

Dakle, `dlsym` je čest vektor u user-mode PAC bypass-ima.

2.3 **Other DYLD / runtime relocations**

-   DYLD loader i dynamic relocation logika su kompleksni i ponekad privremeno mapiraju stranice kao read/write da izvrše relocations, pa ih onda vraćaju nazad na read-only. Napadači iskorišćavaju ove vremenske prozore. Synacktiv-ova prezentacija opisuje "Operation Triangulation", timing-bazirani bypass PAC-a preko dynamic relocations. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   DYLD stranice su sada zaštićene sa SPRR / VM_FLAGS_TPRO (neke protection flag-ove za dyld). Ali ranije verzije su imale slabije guard-e. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   U WebKit exploit lancima, DYLD loader je često meta za PAC bypass. Slajdovi navode da su mnogi PAC bypass-i ciljali DYLD loader (preko relocacija, interposer hook-ova). [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

2.4 **NSPredicate / NSExpression / ObjC / SLOP**

-   U userland exploit lancima, Objective-C runtime metode kao `NSPredicate`, `NSExpression` ili `NSInvocation` se koriste da krijumčare kontrolne pozive bez očiglednog falsifikovanja pointer-a.

-   Na starijem iOS-u (pre PAC), exploit je koristio **fake NSInvocation** objekte da pozove arbitrarne selektore na kontrolisanoj memoriji. Sa PAC, tehnika zahteva modifikacije. Ali tehnika SLOP (SeLector Oriented Programming) je proširena i pod PAC-om. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   Originalna SLOP tehnika je dozvoljavala chain-ovanje ObjC poziva kreiranjem lažnih invocation objekata; bypass se oslanja na to da ISA ili selector pointer-i ponekad nisu u potpunosti PAC-zastićeni. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   U okruženjima gde je pointer authentication primenjen parcijalno, metode / selector-i / target pointer-i možda nisu uvek PAC-zastićeni, ostavljajući prostor za bypass.

#### Example Flow

<details>
<summary>Example Signing & Authenticating</summary>
```
; Example: function prologue / return address protection
my_func:
stp x29, x30, [sp, #-0x20]!        ; push frame pointer + LR
mov x29, sp
PACIASP                            ; sign LR (x30) using SP as modifier
; … body …
mov sp, x29
ldp x29, x30, [sp], #0x20         ; restore
AUTIASP                            ; authenticate & strip PAC
ret

; Example: indirect function pointer stored in a struct
; suppose X1 contains a function pointer
PACDA X1, X2     ; sign data pointer X1 with context X2
STR X1, [X0]      ; store signed pointer

; later retrieval:
LDR X1, [X0]
AUTDA X1, X2       ; authenticate & strip
BLR X1             ; branch to valid target

; Example: stripping for comparison (unsafe)
LDR X1, [X0]
XPACI X1           ; strip PAC (instruction domain)
CMP X1, #some_label_address
BEQ matched_label
```
</details>

<details>
<summary>Primer</summary>
A buffer overflow prepisuje return address na stack-u. Napadač upisuje adresu ciljnog gadgeta ali ne može da izračuna ispravan PAC. Kada se funkcija vrati, CPU-ova instrukcija `AUTIA` baci grešku zbog neusaglašenosti PAC-a. Lanac ne uspeva.
Project Zero-ova analiza A12 (iPhone XS) pokazala je kako Apple koristi PAC i metode falsifikovanja PAC-ova ako napadač ima memory read/write primitive.
</details>


### 9. **Branch Target Identification (BTI)**
**Uvedeno u ARMv8.5 (noviji hardver)**
BTI je hardverska funkcija koja proverava **indirect branch targets**: pri izvršavanju `blr` ili indirektnih poziva/skokova, cilj mora početi sa **BTI landing pad** (`BTI j` ili `BTI c`). Skakanje u gadget adrese koje nemaju landing pad izaziva izuzetak.

LLVM-ova implementacija beleži tri varijante BTI instrukcija i kako se one mapiraju na tipove grana.

| BTI Variant | What it permits (which branch types) | Typical placement / use case |
|-------------|----------------------------------------|-------------------------------|
| **BTI C** | Targets of *call*-style indirect branches (e.g. `BLR`, or `BR` using X16/X17) | Put at entry of functions that may be called indirectly |
| **BTI J** | Targets of *jump*-style branches (e.g. `BR` used for tail calls) | Placed at the beginning of blocks reachable by jump tables or tail-calls |
| **BTI JC** | Acts as both C and J | Can be targeted by either call or jump branches |

- U kodu kompajliranom sa branch target enforcement, kompajleri ubacuju BTI instrukciju (C, J, ili JC) na svaki validni indirect-branch target (početci funkcija ili blokovi dostupni putem skokova) tako da indirektne grane uspevaju samo prema tim mestima.
- **Direct branches / calls** (tj. fiksne adrese `B`, `BL`) **nisu ograničene** BTI-jem. Pretpostavka je da su code stranice pouzdane i da napadač ne može da ih menja (tako da su direct branch-ovi bezbedni).
- Takođe, **RET / return** instrukcije generalno nisu ograničene BTI-jem jer su return adrese zaštićene putem PAC ili mehanizama za return signing.

#### Mehanizam i sprovođenje

- Kada CPU dekodira **indirect branch (BLR / BR)** na strani označenoj kao “guarded / BTI-enabled”, proveri da li prva instrukcija na ciljnoj adresi predstavlja validan BTI (C, J, ili JC kao što je dozvoljeno). Ako nije, nastaje **Branch Target Exception**.
- Kodiranje BTI instrukcije je dizajnirano da ponovo koristi opkodove ranije rezervisane za NOP-ove (u ranijim ARM verzijama). Tako BTI-om omogućeni binarni fajlovi ostaju backward-compatible: na hardveru bez BTI podrške te instrukcije ponašaju se kao NOP.
- Compiler pass-ovi koji dodaju BTI ubacuju ih samo gde je potrebno: funkcije koje mogu biti pozvane indirektno, ili basic blokovi na koje ciljaju skokovi.
- Neki patch-evi i LLVM kod pokazuju da BTI nije ubačen za *sve* basic blokove — samo za one koji su potencijalni branch targets (npr. iz switch / jump table).

#### BTI + PAC sinergija

PAC štiti vrednost pokazivača (izvor) — obezbeđuje da lanac indirektnih poziva / return-a nije izmenjen.

BTI osigurava da čak i validan pokazivač može ciljati samo pravilno označene entry point-e.

U kombinaciji, napadaču su potrebni i validan pokazivač sa ispravnim PAC-om i da cilj na koji pokazivač upućuje ima BTI prefiks. To otežava kreiranje usable gadget-a za eksploite.

#### Primer


<details>
<summary>Primer</summary>
Exploit pokušava da pivot-uje u gadget na `0xABCDEF` koji ne počinje sa `BTI c`. CPU, prilikom izvršavanja `blr x0`, proveri cilj i baci grešku jer instrukcija ne sadrži validan landing pad. Dakle, mnogi gadget-i postaju neupotrebljivi osim ako nemaju BTI prefiks.
</details>


### 10. **Privileged Access Never (PAN) & Privileged Execute Never (PXN)**
**Predstavljeno u novijim ARMv8 ekstenzijama / iOS podršci (za hardened kernel)**

#### PAN (Privileged Access Never)

- **PAN** je feature uveden u **ARMv8.1-A** koji sprečava **privileged code** (EL1 ili EL2) da **čita ili piše** memoriju koja je označena kao **user-accessible (EL0)**, osim ako PAN nije eksplicitno isključen.
- Ideja: čak i ako je kernel prevaren ili kompromitovan, ne može proizvoljno dereferencirati user-space pokazivače bez prethodnog *čišćenja* PAN-a, čime se smanjuje rizik od `ret2usr` tip eksploita ili zloupotrebe user-kontrolisanih bafera.
- Kada je PAN omogućen (PSTATE.PAN = 1), bilo koja privileged load/store instrukcija koja pristupa virtuelnoj adresi koja je “accessible at EL0” izaziva **permission fault**.
- Kernel, kada legitimno mora da pristupi user-space memoriji (npr. kopiranje podataka do/iz user bafera), mora **privremeno da onemogući PAN** (ili da koristi “unprivileged load/store” instrukcije) da bi dozvolio pristup.
- U Linuxu na ARM64, podrška za PAN je uvedena oko 2015: kernel patch-evi su dodali detekciju feature-a i zamenili `get_user` / `put_user` itd. sa varijantama koje čiste PAN oko pristupa user memoriji.

**Ključna nijansa / ograničenje / bug**
- Kao što su Siguza i drugi primetili, spec bug (ili dvosmislena ponašanja) u ARM dizajnu znači da **execute-only user mappings** (`--x`) možda **neće trigger-ovati PAN**. Drugim rečima, ako je user stranica označena kao executable ali bez read permisije, kernelov pokušaj čitanja može zaobići PAN jer arhitektura smatra “accessible at EL0” da zahteva readable permission, a ne samo executable. Ovo vodi do PAN bypass-a u određenim konfiguracijama.
- Zbog toga, ako iOS / XNU dozvoljava execute-only user strane (kao što bi neki JIT ili code-cache mogli), kernel možda slučajno pročita sa njih čak i kada je PAN omogućen. Ovo je poznato i suptilno eksploatisano mesto u nekim ARMv8+ sistemima.

#### PXN (Privileged eXecute Never)

- **PXN** je page table flag (u page table entries, leaf ili block entries) koji označava da stranica nije izvršna kada se izvršava u privileged modu (tj. kada EL1 izvršava).
- PXN sprečava kernel (ili bilo koji privileged kod) da skrene izvršavanje ili izvršava instrukcije iz user-space stranica čak i ako se kontrola presmeri tamo. U suštini, to blokira kernel-level control-flow redirection u user memoriju.
- U kombinaciji sa PAN, ovo osigurava:
1. Kernel ne može (po default-u) da čita ili piše user-space podatke (PAN)
2. Kernel ne može da izvršava user-space kod (PXN)
- U ARMv8 page table formatu, leaf unosi imaju `PXN` bit (i takođe `UXN` za unprivileged execute-never) u atributnim bitovima.

Dakle, čak i ako kernel ima korumpiran function pointer koji pokazuje na user memoriju i pokuša da skoči tamo, PXN bit bi izazvao fault.

#### Model permisija memorije & kako se PAN i PXN mapiraju na page table bitove

Da biste razumeli kako PAN / PXN rade, potrebno je videti kako ARM-ova translacija i model permisija funkcionišu (pojednostavljeno):

- Svaka page ili block entry ima atributna polja uključujući **AP[2:1]** za access permissions (read/write, privileged vs unprivileged) i **UXN / PXN** bitove za execute-never restrikcije.
- Kada je PSTATE.PAN = 1 (omogućen), hardver sprovodi izmenjena semantiku: privileged pristupi stranama označenim kao “accessible by EL0” (tj. user-accessible) su zabranjeni (fault).
- Zbog pomenutog buga, stranice koje su označene samo kao executable (bez read permisije) možda se ne računaju kao “accessible by EL0” pod nekim implementacijama, čime se PAN može zaobići.
- Kada je PXN bit podešen za stranicu, čak i ako dolazi instrukcijski fetch sa višeg privilege nivoa, izvršavanje je zabranjeno.

#### Korišćenje PAN / PXN u kernelu ojačanog OS-a (npr. iOS / XNU)

U dizajnu ojačanog kernela (kao što Apple može koristiti):

- Kernel omogućava PAN po default-u (tako da je privileged kod ograničen).
- U putevima koji legitimno trebaju da čitaju ili pišu user bafer-e (npr. syscall buffer copy, I/O, read/write user pointer), kernel privremeno **onemogućava PAN** ili koristi specijalne instrukcije da zaobiđe zaštitu.
- Nakon završetka pristupa user podacima, mora ponovo da omogući PAN.
- PXN se sprovodi putem page tabela: user stranice imaju PXN = 1 (tako kernel ne može da ih izvršava), kernel stranice nemaju PXN (tako kernel kod može da se izvršava).
- Kernel mora osigurati da nijedan kod-put ne dovede do izvršavanja u user memorijskim regionima (što bi zaobišlo PXN) — tako su chain-ovi koji zavise od “jump into user-controlled shellcode” blokirani.

Zbog pomenutog PAN bypass-a kroz execute-only stranice, u realnom sistemu Apple može onemogućiti ili zabraniti execute-only user stranice, ili zakrpiti specifikacionu slabost.

#### Površine napada, bypass-ovi i mitigacije

- **PAN bypass kroz execute-only stranice**: kao što je diskutovano, spec dozvoljava prazninu: user stranice sa execute-only (bez read perm) možda se ne računaju kao “accessible at EL0”, tako da PAN neće blokirati kernel čitanja sa tih stranica u nekim implementacijama. Ovo daje napadaču neuobičajen put da ubaci podatke preko “execute-only” sekcija.
- **Temporal window exploit**: ako kernel onemogući PAN za vremenski period duži nego što je potrebno, trka ili maliciozan put može iskoristiti taj prozor da izvrši neželjeni pristup user memoriji.
- **Zaboravljeno ponovo omogućavanje**: ako kodne grane zakažu da ponovo omoguće PAN, naredne kernel operacije bi mogle pogrešno pristupati user memoriji.
- **Pogrešna konfiguracija PXN**: ako page tabele ne postave PXN na user strane ili pogrešno mapiraju user code stranice, kernel bi mogao biti prevaren da izvrši user-space kod.
- **Spekulativno / side-channel**: analogno spekulativnim bypass-ovima, mogu postojati mikroarhitektonski side-effekti koji uzrokuju transientno kršenje PAN / PXN provera (iako su takvi napadi snažno zavisni od dizajna CPU-a).
- **Kompleksne interakcije**: kod naprednijih feature-a (npr. JIT, shared memory, just-in-time code regions), kernel može zahtevati fino upravljanje da dozvoli određene memorijske pristupe ili izvršavanje u user-mapiranim regionima; dizajniranje toga bezbedno pod PAN/PXN ograničenjima je netrivijalno.

#### Primer

<details>
<summary>Primer koda</summary>
Here are illustrative pseudo-assembly sequences showing enabling/disabling PAN around user memory access, and how a fault might occur.
```  
// Suppose kernel entry point, PAN is enabled (privileged code cannot access user memory by default)

; Kernel receives a syscall with user pointer in X0
; wants to read an integer from user space
mov   X1, X0        ; X1 = user pointer

; disable PAN to allow privileged access to user memory
MSR   PSTATE.PAN, #0   ; clear PAN bit, disabling the restriction

ldr   W2, [X1]       ; now allowed load from user address

; re-enable PAN before doing other kernel logic
MSR   PSTATE.PAN, #1   ; set PAN

; ... further kernel work ...

; Later, suppose an exploit corrupts a pointer to a user-space code page and jumps there
BR    X3             ; branch to X3 (which points into user memory)

; Because the target page is marked PXN = 1 for privileged execution,
; the CPU throws an exception (fault) and rejects execution
```
<details>
If the kernel had **not** set PXN on that user page, then the branch might succeed — which would be insecure.

If the kernel forgets to re-enable PAN after user memory access, it opens a window where further kernel logic might accidentally read/write arbitrary user memory.

If the user pointer is into an execute-only page (user page with only execute permission, no read/write), under the PAN spec bug, `ldr W2, [X1]` might **not** fault even with PAN enabled, enabling a bypass exploit, depending on implementation.
</details>

<details>
<summary>Example</summary>
A kernel vulnerability tries to take a user-provided function pointer and call it in kernel context (i.e. `call user_buffer`). Under PAN/PXN, that operation is disallowed or faults.
</details>

---

### 11. **Top Byte Ignore (TBI) / Pointer Tagging**
**Introduced in ARMv8.5 / newer (or optional extension)**
TBI means the top byte (most-significant byte) of a 64-bit pointer is ignored by address translation. This lets OS or hardware embed **tag bits** in the pointer’s top byte without affecting the actual address.

- TBI stands for **Top Byte Ignore** (sometimes called *Address Tagging*). It is a hardware feature (available in many ARMv8+ implementations) that **ignores the top 8 bits** (bits 63:56) of a 64-bit pointer when performing **address translation / load/store / instruction fetch**.
- In effect, the CPU treats a pointer `0xTTxxxx_xxxx_xxxx` (where `TT` = top byte) as `0x00xxxx_xxxx_xxxx` for the purposes of address translation, ignoring (masking off) the top byte. The top byte can be used by software to store **metadata / tag bits**.
- This gives software “free” in-band space to embed a byte of tag in each pointer without altering which memory location it refers to.
- The architecture ensures that loads, stores, and instruction fetch treat the pointer with its top byte masked (i.e. tag stripped off) before performing the actual memory access.

Thus TBI decouples the **logical pointer** (pointer + tag) from the **physical address** used for memory operations.

#### Why TBI: Use cases and motivation

- **Pointer tagging / metadata**: You can store extra metadata (e.g. object type, version, bounds, integrity tags) in that top byte. When you later use the pointer, the tag is ignored at hardware level, so you don’t need to strip manually for the memory access.
- **Memory tagging / MTE (Memory Tagging Extension)**: TBI is the base hardware mechanism that MTE builds on. In ARMv8.5, the **Memory Tagging Extension** uses bits 59:56 of the pointer as a **logical tag** and checks it against an **allocation tag** stored in memory.
- **Enhanced security & integrity**: By combining TBI with pointer authentication (PAC) or runtime checks, you can force not just the pointer value but also the tag to be correct. An attacker overwriting a pointer without the correct tag will produce a mismatched tag.
- **Compatibility**: Because TBI is optional and tag bits are ignored by hardware, existing untagged code continues to operate normally. The tag bits effectively become “don’t care” bits for legacy code.

#### Example
<details>
<summary>Example</summary>
A function pointer included a tag in its top byte (say `0xAA`). An exploit overwrites the pointer low bits but neglects the tag, so when the kernel verifies or sanitizes, the pointer fails or is rejected.
</details>

---

### 12. **Page Protection Layer (PPL)**
**Introduced in late iOS / modern hardware (iOS ~17 / Apple silicon / high-end models)** (some reports show PPL circa macOS / Apple silicon, but Apple is bringing analogous protections to iOS)

- PPL is designed as an **intra-kernel protection boundary**: even if the kernel (EL1) is compromised and has read/write capabilities, **it should not be able to freely modify** certain **sensitive pages** (especially page tables, code-signing metadata, kernel code pages, entitlements, trust caches, etc.).
- It effectively creates a **“kernel within the kernel”** — a smaller trusted component (PPL) with **elevated privileges** that alone can modify protected pages. Other kernel code must call into PPL routines to effect changes.
- This reduces the attack surface for kernel exploits: even with full arbitrary R/W/execute in kernel mode, exploit code must also somehow get into the PPL domain (or bypass PPL) to modify critical structures.
- On newer Apple silicon (A15+ / M2+), Apple is transitioning to **SPTM (Secure Page Table Monitor)**, which in many cases replaces PPL for page-table protection on those platforms.

Here’s how PPL is believed to operate, based on public analysis:

#### Use of APRR / permission routing (APRR = Access Permission ReRouting)

- Apple hardware uses a mechanism called **APRR (Access Permission ReRouting)**, which allows page table entries (PTEs) to contain small indices, rather than full permission bits. Those indices are mapped via APRR registers to actual permissions. This allows dynamic remapping of permissions per domain.
- PPL leverages APRR to segregate privilege within kernel context: only the PPL domain is permitted to update the mapping between indices and effective permissions. That is, when non-PPL kernel code writes a PTE or tries to flip permission bits, the APRR logic disallows it (or enforces read-only mapping).
- PPL code itself runs in a restricted region (e.g. `__PPLTEXT`) which is normally non-executable or non-writable until entry gates temporarily allow it. The kernel calls PPL entry points (“PPL routines”) to perform sensitive operations.

#### Gate / Entry & Exit

- When the kernel needs to modify a protected page (e.g. change permissions of a kernel code page, or modify page tables), it calls into a **PPL wrapper** routine, which does validation and then transitions into the PPL domain. Outside that domain, the protected pages are effectively read-only or non-modifiable by the main kernel.
- During PPL entry, the APRR mappings are adjusted so that memory pages in the PPL region are set to **executable & writable** within PPL. Upon exit, they are returned to read-only / non-writable. This ensures that only well-audited PPL routines can write to protected pages.
- Outside PPL, attempts by kernel code to write to those protected pages will fault (permission denied) because the APRR mapping for that code domain doesn’t permit writing.

#### Protected page categories

The pages that PPL typically protects include:

- Page table structures (translation table entries, mapping metadata)
- Kernel code pages, especially those containing critical logic
- Code-sign metadata (trust caches, signature blobs)
- Entitlement tables, signature enforcement tables
- Other high-value kernel structures where a patch would allow bypassing signature checks or credentials manipulation

The idea is that even if the kernel memory is fully controlled, the attacker cannot simply patch or rewrite these pages, unless they also compromise PPL routines or bypass PPL.

#### Known Bypasses & Vulnerabilities

1. **Project Zero’s PPL bypass (stale TLB trick)**

- A public writeup by Project Zero describes a bypass involving **stale TLB entries**.
- The idea:

1. Allocate two physical pages A and B, mark them as PPL pages (so they are protected).
2. Map two virtual addresses P and Q whose L3 translation table pages come from A and B.
3. Spin a thread to continuously access Q, keeping its TLB entry alive.
4. Call `pmap_remove_options()` to remove mappings starting at P; due to a bug, the code mistakenly removes the TTEs for both P and Q, but only invalidates the TLB entry for P, leaving Q’s stale entry live.
5. Reuse B (page Q’s table) to map arbitrary memory (e.g. PPL-protected pages). Because the stale TLB entry still maps Q’s old mapping, that mapping remains valid for that context.
6. Through this, the attacker can put writable mapping of PPL-protected pages in place without going through PPL interface.

- This exploit required fine control of physical mapping and TLB behavior. It demonstrates that a security boundary relying on TLB / mapping correctness must be extremely careful about TLB invalidations and mapping consistency.

- Project Zero commented that bypasses like this are subtle and rare, but possible in complex systems. Still, they regard PPL as a solid mitigation.

2. **Other potential hazards & constraints**

- If a kernel exploit can directly enter PPL routines (via calling the PPL wrappers), it might bypass restrictions. Thus argument validation is critical.
- Bugs in the PPL code itself (e.g. arithmetic overflow, boundary checks) can allow out-of-bounds modifications inside PPL. Project Zero observed that such a bug in `pmap_remove_options_internal()` was exploited in their bypass.
- The PPL boundary is irrevocably tied to hardware enforcement (APRR, memory controller), so it's only as strong as the hardware implementation.

#### Example
<details>
<summary>Code Example</summary>
Here’s a simplified pseudocode / logic showing how a kernel might call into PPL to modify protected pages:
</details>
```c
// In kernel (outside PPL domain)
function kernel_modify_pptable(pt_addr, new_entry) {
// validate arguments, etc.
return ppl_call_modify(pt_addr, new_entry)  // call PPL wrapper
}

// In PPL (trusted domain)
function ppl_call_modify(pt_addr, new_entry) {
// temporarily enable write access to protected pages (via APRR adjustments)
aprr_set_index_for_write(PPL_INDEX)
// perform the modification
*pt_addr = new_entry
// restore permissions (make pages read-only again)
aprr_restore_default()
return success
}

// If kernel code outside PPL does:
*pt_addr = new_entry  // a direct write
// It will fault because APRR mapping for non-PPL domain disallows write to that page
```
The kernel can do many normal operations, but only through `ppl_call_*` routines can it change protected mappings or patch code.
</details>

<details>
<summary>Example</summary>
A kernel exploit tries to overwrite the entitlement table, or disable code-sign enforcement by modifying a kernel signature blob. Because that page is PPL-protected, the write is blocked unless going through the PPL interface. So even with kernel code execution, you cannot bypass code-sign constraints or modify credential data arbitrarily.
On iOS 17+ certain devices use SPTM to further isolate PPL-managed pages.
</details>

#### PPL → SPTM / Replacements / Future

- On Apple’s modern SoCs (A15 or later, M2 or later), Apple supports **SPTM** (Secure Page Table Monitor), which **replaces PPL** for page table protections.
- Apple calls out in documentation: “Page Protection Layer (PPL) and Secure Page Table Monitor (SPTM) enforce execution of signed and trusted code … PPL manages the page table permission overrides … Secure Page Table Monitor replaces PPL on supported platforms.”
- The SPTM architecture likely shifts more policy enforcement into a higher-privileged monitor outside kernel control, further reducing the trust boundary.

### MTE | EMTE | MIE

Evo opisa na višem nivou kako EMTE funkcioniše u Apple-ovom MIE okruženju:

1. **Tag assignment**
- Kada se memorija alocira (npr. u kernelu ili user space-u preko secure allocators), tom bloku se dodeljuje **secret tag**.
- Pokazivač koji se vraća korisniku ili kernelu uključuje taj tag u svojim visokim bitovima (koristeći TBI / top byte ignore mehanizme).

2. **Tag checking on access**
- Kad god se izvrši load ili store koristeći pokazivač, hardware proverava da li tag pokazivača odgovara tagu memorijskog bloka (allocation tag). Ako se ne poklapa, odmah se javlja fault (pošto je synchronous).
- Pošto je synchronous, ne postoji prozor za „odloženo otkrivanje“.

3. **Retagging on free / reuse**
- Kada se memorija oslobodi, allocator menja tag bloka (tako da stariji pokazivači sa starim tagovima više ne odgovaraju).
- Use-after-free pokazivač bi zbog toga imao zastareli tag i pri pristupu bi se javilo neusklađivanje.

4. **Neighbor-tag differentiation to catch overflows**
- Susedne alokacije dobijaju različite tagove. Ako buffer overflow prelije u memoriju suseda, neusklađenost tagova izaziva fault.
- Ovo je posebno efikasno u otkrivanju malih overflow-a koji prelaze granicu.

5. **Tag confidentiality enforcement**
- Apple mora sprečiti da vrednosti tagova budu leaked (jer ako napadač sazna tag, mogao bi napraviti pokazivače sa ispravnim tagovima).
- Uključuju zaštite (microarchitectural / speculative controls) da bi izbegli side-channel leakage tag bitova.

6. **Kernel and user-space integration**
- Apple koristi EMTE ne samo u user-space-u već i u kernel/OS-critical komponentama (da bi zaštitio kernel od memory corruption).
- Hardware/OS obezbeđuju da pravila tagova važe čak i kada se kernel izvršava u ime user space-a.

<details>
<summary>Example</summary>
```
Allocate A = 0x1000, assign tag T1
Allocate B = 0x2000, assign tag T2

// pointer P points into A with tag T1
P = (T1 << 56) | 0x1000

// Valid store
*(P + offset) = value // tag T1 matches allocation → allowed

// Overflow attempt: P’ = P + size_of_A (into B region)
*(P' + delta) = value
→ pointer includes tag T1 but memory block has tag T2 → mismatch → fault

// Free A, allocator retags it to T3
free(A)

// Use-after-free:
*(P) = value
→ pointer still has old tag T1, memory region is now T3 → mismatch → fault
```
</details>

#### Ograničenja i izazovi

- **Intrablock overflows**: Ako overflow ostane unutar iste alokacije (ne prelazi granicu) i tag ostane isti, tag mismatch ga ne detektuje.
- **Tag width limitation**: Samo nekoliko bitova (npr. 4 bita, ili mali domen) je dostupno za tag—ograničen namespace.
- **Side-channel leaks**: Ako tag bitovi mogu biti leaked (putem cache / speculative execution), napadač može saznati validne tage i zaobići zaštitu. Apple-ovo sprovođenje tag confidentiality ima za cilj da ovo ublaži.
- **Performance overhead**: Provere taga pri svakom load/store dodaju trošak; Apple mora optimizovati hardver da bi držao overhead nizak.
- **Compatibility & fallback**: Na starijem hardveru ili delovima koji ne podržavaju EMTE mora postojati fallback. Apple tvrdi da je MIE omogućeno samo na uređajima sa podrškom.
- **Complex allocator logic**: Allocator mora da upravlja tagovima, retagiranjem, poravnavanjem granica i da izbegne kolizije tagova. Bagovi u logici allocatora mogu uvesti ranjivosti.
- **Mixed memory / hybrid areas**: Neki regioni mogu ostati untagged (legacy), što otežava interoperabilnost.
- **Speculative / transient attacks**: Kao i kod mnogih mikroarhitekturnih zaštita, speculative execution ili micro-op fuzije mogu privremeno zaobići provere ili leak-ovati tag bitove.
- **Limited to supported regions**: Apple možda primenjuje EMTE samo u selektivnim, visokorizičnim oblastima (kernel, security-critical subsistemi), a ne univerzalno.

---

## Ključna poboljšanja / razlike u odnosu na standardni MTE

Evo poboljšanja i izmena koje Apple ističe:

| Feature | Original MTE | EMTE (Apple’s enhanced) / MIE |
|---|---|---|
| **Check mode** | Supports synchronous and asynchronous modes. In async, tag mismatches are reported later (delayed)| Apple insists on **synchronous mode** by default—tag mismatches are caught immediately, no delay/race windows allowed.|
| **Coverage of non-tagged memory** | Accesses to non-tagged memory (e.g. globals) may bypass checks in some implementations | EMTE requires that accesses from a tagged region to non-tagged memory also validate tag knowledge, making it harder to bypass by mixing allocations.|
| **Tag confidentiality / secrecy** | Tags might be observable or leaked via side channels | Apple adds **Tag Confidentiality Enforcement**, which attempts to prevent leakage of tag values (via speculative side-channels etc.).|
| **Allocator integration & retagging** | MTE leaves much of allocator logic to software | Apple’s secure typed allocators (kalloc_type, xzone malloc, etc.) integrate with EMTE: when memory is allocated or freed, tags are managed at fine granularity.|
| **Always-on by default** | In many platforms, MTE is optional or off by default | Apple enables EMTE / MIE by default on supported hardware (e.g. iPhone 17 / A19) for kernel and many user processes.|

Pošto Apple kontroliše i hardver i softverski stack, može strogo primeniti EMTE, izbeći performansne probleme i zatvoriti side-channel rupe.

---

## Kako EMTE radi u praksi (Apple / MIE)

Evo višeg nivoa opisa kako EMTE funkcioniše pod Apple-ovim MIE podešavanjem:

1. **Dodela taga**
- Kada se memorija alocira (npr. u kernelu ili user space preko secure allocators), toj bloku se dodeljuje **secret tag**.
- Pokazivač vraćen korisniku ili kernelu uključuje taj tag u svojim višim bitovima (koristeći TBI / top byte ignore mehanizme).

2. **Provera taga pri pristupu**
- Kad se izvrši load ili store koristeći pokazivač, hardver proverava da li tag pokazivača odgovara tagu memorijskog bloka (allocation tag). Ako se ne slaže, odmah se javlja fault (pošto je synchronous).
- Pošto je synchronous, ne postoji prozor za “delayed detection”.

3. **Promena taga pri oslobađanju / ponovnom korišćenju**
- Kada se memorija oslobodi, allocator menja tag bloka (tako da stariji pokazivači sa starim tagovima više ne odgovaraju).
- A use-after-free pointer će zato imati zastareli tag i napraviće mismatch pri pristupu.

4. **Razlikovanje tagova suseda da bi se uhvatili overflows**
- Susedne alokacije dobijaju različite tage. Ako buffer overflow prelije u memoriju suseda, tag mismatch izaziva fault.
- Ovo je naročito efikasno za hvatanje malih overflows koji prelaze granicu.

5. **Sprovodjenje tag confidentiality**
- Apple mora sprečiti da se vrednosti tagova leak-uju (jer ako napadač sazna tag, mogao bi konstruisati pokazivače sa ispravnim tagovima).
- Uključene su zaštite (mikroarhitekturne / speculative kontrole) da bi se izbeglo side-channel leak-ovanje bitova taga.

6. **Integracija u kernel i user-space**
- Apple koristi EMTE ne samo u user-space već i u kernelu / OS-critical komponentama (da bi zaštitio kernel od korupcije memorije).
- Hardver/OS osigurava da pravila tagova važe čak i kada kernel izvršava radnje u ime user space procesa.

Pošto je EMTE ugrađen u MIE, Apple koristi EMTE u synchronous modu preko ključnih attack surface-a, a ne kao opcioni ili debug mod.

---

## Exception handling u XNU

Kada se dogodi **exception** (npr. `EXC_BAD_ACCESS`, `EXC_BAD_INSTRUCTION`, `EXC_CRASH`, `EXC_ARM_PAC`, itd.), **Mach layer** XNU kernela je odgovoran da ga presretne pre nego što postane UNIX-styl signal (kao `SIGSEGV`, `SIGBUS`, `SIGILL`, ...).

Ovaj proces uključuje više nivoa propagacije i obrade exception-a pre nego što dostigne user space ili bude konvertovan u BSD signal.

### Exception Flow (High-Level)

1.  **CPU pokreće synchronous exception** (npr. dereferenciranje nevažećeg pokazivača, PAC failure, illegal instruction, itd.).

2.  **Low-level trap handler** se izvršava (`trap.c`, `exception.c` u XNU source).

3.  Trap handler poziva **`exception_triage()`**, jezgro Mach exception handling-a.

4.  `exception_triage()` odlučuje kako da rutira exception:

-   Prvo ka **thread's exception port**.

-   Zatim ka **task's exception port**.

-   Zatim ka **host's exception port** (često `launchd` ili `ReportCrash`).

Ako nijedan od ovih portova ne obradi exception, kernel može:

-   **Konvertovati ga u BSD signal** (za user-space procese).

-   **Panic-ovati** (za kernel-space exception-e).

### Core Function: `exception_triage()`

Funkcija `exception_triage()` routuje Mach exception-e niz lanac mogućih handler-a dok je neko ne obradi ili dok ne postane fatalna. Definisana je u `osfmk/kern/exception.c`.
```c
void exception_triage(exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt);
```
**Tipičan tok poziva:**

`exception_triage()
└── exception_deliver()
├── exception_deliver_thread()
├── exception_deliver_task()
└── exception_deliver_host()`

Ako svi zakažu → obrađuje ih `bsd_exception()` → prevodi u signal kao što je `SIGSEGV`.


### Portovi izuzetaka

Svaki Mach objekat (thread, task, host) može registrovati **exception portove**, na koje se šalju poruke o izuzecima.

Definisani su API-jem:
```
task_set_exception_ports()
thread_set_exception_ports()
host_set_exception_ports()
```
Each exception port has:

-   A **mask** (koje exceptions želi da primi)
-   A **port name** (Mach port koji prima poruke)
-   A **behavior** (kako kernel šalje poruku)
-   A **flavor** (koji thread state da uključi)


### Debuggers and Exception Handling

A **debugger** (npr. LLDB) postavlja **exception port** na target task ili thread, obično koristeći `task_set_exception_ports()`.

**When an exception occurs:**

-   Mach message se šalje debugger procesu.
-   Debugger može odlučiti da **handle**-uje (resume, modifikuje registre, preskoči instrukciju) ili **ne handle**-uje exception.
-   Ako debugger ne handle-uje, exception propagira na sledeći nivo (task → host).


### Flow of `EXC_BAD_ACCESS`

1.  Thread dereferencira invalid pointer → CPU podiže Data Abort.

2.  Kernel trap handler poziva `exception_triage(EXC_BAD_ACCESS, ...)`.

3.  Poruka se šalje na:

-   Thread port → (debugger može da presretne breakpoint).

-   Ako debugger ignoriše → Task port → (proces-nivo handler).

-   Ako se ignoriše → Host port (obično ReportCrash).

4.  Ako niko ne handluje → `bsd_exception()` prevodi u `SIGSEGV`.


### PAC Exceptions

Kada **Pointer Authentication (PAC)** zakaže (mismatch signature), podiže se **poseban Mach exception**:

-   **`EXC_ARM_PAC`** (type)
-   Codes mogu sadržati detalje (npr. key type, pointer type).

Ako binar ima flag **`TFRO_PAC_EXC_FATAL`**, kernel tretira PAC greške kao **fatalne**, zaobilaže debugger interception. Ovo je da se spreči da napadači koriste debuggere za zaobilaženje PAC provera i omogućeno je za **platform binaries**.

### Software Breakpoints

Software breakpoint (`int3` na x86, `brk` na ARM64) se implementira izazivanjem namernog falla.\
Debugger to hvata preko exception porta:

-   Modifikuje instruction pointer ili memoriju.
-   Vraća originalnu instrukciju.
-   Nastavlja izvršenje.

Isti mehanizam omogućava da "uhvatite" PAC exception — **osim ako je `TFRO_PAC_EXC_FATAL`** postavljen, u kom slučaju nikada ne dopire do debugger-a.


### Conversion to BSD Signals

Ako nijedan handler ne prihvati exception:

-   Kernel poziva `task_exception_notify() → bsd_exception()`.

-   Ovo mapira Mach exceptions na signals:

| Mach Exception | Signal |
| --- | --- |
| EXC_BAD_ACCESS | SIGSEGV or SIGBUS |
| EXC_BAD_INSTRUCTION | SIGILL |
| EXC_ARITHMETIC | SIGFPE |
| EXC_SOFTWARE | SIGTRAP |
| EXC_BREAKPOINT | SIGTRAP |
| EXC_CRASH | SIGKILL |
| EXC_ARM_PAC | SIGILL (on non-fatal) |


### Key Files in XNU Source

-   `osfmk/kern/exception.c` → Core of `exception_triage()`, `exception_deliver_*()`.

-   `bsd/kern/kern_sig.c` → Signal delivery logic.

-   `osfmk/arm64/trap.c` → Low-level trap handlers.

-   `osfmk/mach/exc.h` → Exception codes and structures.

-   `osfmk/kern/task.c` → Task exception port setup.

---

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

Kernel je koristio **zone allocator** (`kalloc`) podeljen na fiksne "zone."
Svaka zona čuva alokacije samo jedne size class.

Iz screenshot-a:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Very small kernel structs, pointers.                                        |
| `default.kalloc.32`  | 32 bytes     | Small structs, object headers.                                              |
| `default.kalloc.64`  | 64 bytes     | IPC messages, tiny kernel buffers.                                          |
| `default.kalloc.128` | 128 bytes    | Medium objects like parts of `OSObject`.                                    |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Large structures, IOSurface/graphics metadata.                              |

**How it worked:**
- Svaki allocation request se **zaokruži nagore** na najbližu zone size.
(Npr., 50-byte request završi u `kalloc.64` zoni).
- Memorija u svakoj zoni se čuvala u **freelist-u** — chunk-ovi koje kernel free-uje vraćaju se u tu zonu.
- Ako prelijete 64-byte buffer, prepišete **sledeći objekat u istoj zoni**.

Zato su **heap spraying / feng shui** bili tako efikasni: mogli ste predvideti susedne objekte tako što biste sprejali alokacije iste size klase.

### The freelist

Unutar svake kalloc zone, oslobođeni objekti nisu vraćani direktno sistemu — stavljani su u freelist, linked list dostupnih chunk-ova.

- Kada se chunk free-uje, kernel upisuje pointer na početak tog chunka → adresu sledećeg slobodnog chunka u istoj zoni.

- Zona drži HEAD pointer na prvi slobodni chunk.

- Alokacija uvek koristi trenutni HEAD:

1. Pop HEAD (vrati tu memoriju caller-u).

2. Update HEAD = HEAD->next (smešteno u header-u freed chunka).

- Freeing gura chuck-ove nazad:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

Dakle, freelist je jednostavna linked lista izgrađena unutar same oslobođene memorije.

Normalan stanje:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Eksploatacija freelist-a

Pošto prvih 8 bajtova slobodnog chunk-a = freelist pointer, napadač može da ga korumpira:

1. **Heap overflow** u susedni oslobođeni chunk → prepiše njegov „next“ pokazivač.

2. **Use-after-free** upis u oslobođeni objekat → prepiše njegov „next“ pokazivač.

Zatim, pri sledećoj alokaciji te veličine:

- Alokator izvadi korumpirani chunk.
- Sledi napadačem obezbeđeni „next“ pokazivač.
- Vraća pokazivač na proizvoljnu memoriju, omogućavajući fake object primitives ili targeted overwrite.

Vizuelan primer freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
This freelist design je činilo exploitatabilnost veoma efikasnom pre hardening-a: predictable neighbors from heap sprays, raw pointer freelist links, i no type separation dozvoljavali su napadačima da eskaliraju UAF/overflow bagove u arbitrary kernel memory control.

### Heap Grooming / Feng Shui
The goal of heap grooming is to **shape the heap layout** so that when an attacker triggers an overflow or use-after-free, the target (victim) object sits right next to an attacker-controlled object.\
That way, when memory corruption happens, the attacker can reliably overwrite the victim object with controlled data.

**Steps:**

1. Spray allocations (fill the holes)
- Over time, the kernel heap gets fragmented: some zones have holes where old
objects were freed.
- The attacker first makes lots of dummy allocations to fill these gaps, so
the heap becomes “packed” and predictable.

2. Force new pages
- Once the holes are filled, the next allocations must come from new pages
added to the zone.
- Fresh pages mean objects will be clustered together, not scattered across
old fragmented memory.
- This gives the attacker much better control of neighbors.

3. Place attacker objects
- The attacker now sprays again, creating lots of attacker-controlled objects
in those new pages.
- These objects are predictable in size and placement (since they all belong
to the same zone).

4. Free a controlled object (make a gap)
- The attacker deliberately frees one of their own objects.
- This creates a “hole” in the heap, which the allocator will later reuse for
the next allocation of that size.

5. Victim object lands in the hole
- The attacker triggers the kernel to allocate the victim object (the one
they want to corrupt).
- Since the hole is the first available slot in the freelist, the victim is
placed exactly where the attacker freed their object.

6. Overflow / UAF into victim
- Now the attacker has attacker-controlled objects around the victim.
- By overflowing from one of their own objects (or reusing a freed one), they
can reliably overwrite the victim’s memory fields with chosen values.

**Why it works**:

- Zone allocator predictability: allocations of the same size always come from
the same zone.
- Freelist behavior: new allocations reuse the most recently freed chunk first.
- Heap sprays: attacker fills memory with predictable content and controls layout.
- End result: attacker controls where the victim object lands and what data sits
next to it.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple je ojačao allocator i učinio **heap grooming mnogo težim**:

### 1. From Classic kalloc to kalloc_type
- **Pre**: postojao je jedan `kalloc.<size>` zone za svaku size class (16, 32, 64, … 1280, itd.). Bilo koji objekat tog size-a bio je smešten tamo → attacker objekti su mogli da sede pored privileged kernel objekata.
- **Sada**:
- Kernel objekti se alociraju iz **typed zones** (`kalloc_type`).
- Svaka vrsta objekta (npr. `ipc_port_t`, `task_t`, `OSString`, `OSData`) ima sopstvenu dedikovan zonu, čak i ako su iste veličine.
- Mapping između object type ↔ zone se generiše iz **kalloc_type system** u compile vremenu.

Napadač više ne može garantovati da controlled data (`OSData`) završi pored sensitive kernel objekata (`task_t`) iste veličine.

### 2. Slabs and Per-CPU Caches
- Heap je podeljen na **slabs** (paginе memorije podeljene na fixed-size chunkove za tu zonu).
- Svaka zona ima **per-CPU cache** da smanji contention.
- Allocation path:
1. Try per-CPU cache.
2. If empty, pull from the global freelist.
3. If freelist is empty, allocate a new slab (one or more pages).
- **Benefit**: Ova decentralizacija čini heap sprays manje determinističkim, jer alokacije mogu biti zadovoljene iz cache-ova različitih CPU-ova.

### 3. Randomization inside zones
- Unutar zone, freed elementi se ne vraćaju u prostom FIFO/LIFO redosledu.
- Modern XNU koristi **encoded freelist pointers** (safe-linking like Linux, uvedeno ~iOS 14).
- Svaki freelist pointer je **XOR-encoded** sa per-zone secret cookie.
- Ovo sprečava napadače da falsifikuju lažni freelist pointer ako dobiju write primitive.
- Neke alokacije su **randomized in their placement within a slab**, tako da spraying ne garantuje adjacency.

### 4. Guarded Allocations
- Određeni kritični kernel objekti (npr. credentials, task strukture) se alociraju u **guarded zones**.
- Ove zone umeću **guard pages** (unmapped memory) između slabs ili koriste **redzones** oko objekata.
- Bilo koji overflow u guard page trigeruje fault → instant panic umesto silent corruption.

### 5. Page Protection Layer (PPL) and SPTM
- Čak i ako kontrolišete freed objekat, ne možete modifikovati sve delove kernel memorije:
- **PPL (Page Protection Layer)** nameće da određeni regioni (npr. code signing data, entitlements) budu **read-only** čak i za kernel.
- Na **A15/M2+ devices**, ovu ulogu zamenjuju/enhance-uju **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- Ovi hardware-enforced layeri znače da napadači ne mogu eskalirati iz single heap corruption u arbitrary patching of critical security structures.
- **(Added / Enhanced)**: takođe se koristi **PAC (Pointer Authentication Codes)** u kernelu da zaštiti pointere (posebno function pointers, vtables) tako da njihovo falsifikovanje ili korupcija postane težja.
- **(Added / Enhanced)**: zone mogu enforcing-ovati **zone_require / zone enforcement**, tj. da objekat koji je freed može biti vraćen samo kroz svoju ispravnu typed zonu; invalid cross-zone frees mogu izazvati panic ili biti odbijeni. (Apple aludira na ovo u svojim memory safety postovima)

### 6. Large Allocations
- Ne sve alokacije prolaze kroz `kalloc_type`.
- Veće zahteve (iznad ~16 KB) zaobilaze typed zones i služe se direktno iz **kernel VM (kmem)** preko page alokacija.
- Ove su manje predvidljive, ali i manje exploitable, jer ne dele slabs sa drugim objektima.

### 7. Allocation Patterns Attackers Target
Čak i sa ovim zaštitama, napadači i dalje traže:
- **Reference count objects**: ako možete manipulisati retain/release brojačima, možete izazvati use-after-free.
- **Objects with function pointers (vtables)**: korumpiranje jednog i dalje daje control flow.
- **Shared memory objects (IOSurface, Mach ports)**: ovo su i dalje ciljevi zato što povezuju user ↔ kernel.

Ali — za razliku od pre — ne možete samo spray-ovati `OSData` i očekivati da će biti pored `task_t`. Potrebni su **type-specific bugs** ili **info leaks** da bi se uspelo.

### Example: Allocation Flow in Modern Heap

Pretpostavimo da userspace pozove IOKit da alocira `OSData` objekat:

1. **Type lookup** → `OSData` mapira na `kalloc_type_osdata` zonu (size 64 bytes).
2. Check per-CPU cache for free elements.
- If found → return one.
- If empty → go to global freelist.
- If freelist empty → allocate a new slab (page of 4KB → 64 chunks of 64 bytes).
3. Return chunk to caller.

**Freelist pointer protection**:
- Svaki freed chunk čuva adresu sledećeg free chunka, ali enkodiranu sa tajnim ključem.
- Overwriting tog polja attacker podacima neće raditi osim ako ne znate ključ.

---

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages, and **PAC** protects pointers |
| Allocation reuse validation     | None (freelist pointers raw)                               | **zone_require / zone enforcement**             |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |
| Large allocations handling      | All small allocations managed equally                       | Large ones bypass zones → handled via VM         |

---

## Modern Userland Heap (iOS, macOS — type-aware / xzone malloc)

U recent Apple OS verzijama (posebno iOS 17+), Apple je uveo sigurniji userland allocator, **xzone malloc** (XZM). Ovo je user-space analog kernel-ovog `kalloc_type`, koji primenjuje type awareness, metadata isolation i memory tagging safeguard-ove.

### Goals & Design Principles

- **Type segregation / type awareness**: grupisati alokacije po *type-u ili usage-u (pointer vs data)* da bi se sprečila type confusion i cross-type reuse.
- **Metadata isolation**: razdvojiti heap metadata (npr. free lists, size/state bits) od object payload-a kako bi out-of-bounds write-ovi manje verovatno korumpirali metadata.
- **Guard pages / redzones**: umetati unmapped pages ili padding oko alokacija da bi se uhvatili overflows.
- **Memory tagging (EMTE / MIE)**: raditi u saradnji sa hardware tagging-om da detektuje use-after-free, out-of-bounds, i invalid accesses.
- **Scalable performance**: održati nizak overhead, izbeći preveliku fragmentaciju i podržati veliki broj alokacija po sekundi sa niskom latencijom.

### Architecture & Components

Ispod su glavni elementi xzone allocatora:

#### Segment Groups & Zones

- **Segment groups** particionišu address space po usage kategorijama: npr. `data`, `pointer_xzones`, `data_large`, `pointer_large`.
- Svaki segment group sadrži **segments** (VM range-ove) koji hostuju alokacije za tu kategoriju.
- Povezan sa svakim segmentom je **metadata slab** (separate VM area) koji čuva metadata (npr. free/used bits, size classes) za taj segment. Ova **out-of-line (OOL) metadata** osigurava da metadata nije pomešana sa object payload-ima, smanjujući mogućnost korupcije od overflow-a.
- Segments se seku na **chunks** (slices) koji dalje dele na **blocks** (allocation units). Chunk je vezan za određenu size class i segment group (tj. svi block-ovi u chunk-u dele isti size & category).
- Za small/medium alokacije koristi se fixed-size chunks; za large/huge, može se mapirati zasebno.

#### Chunks & Blocks

- **Chunk** je region (često više stranica) posvećen alokacijama jedne size klase unutar grupe.
- Unutar chunk-a, **blocks** su slotovi dostupni za alokacije. Freed blocks se prate kroz metadata slab — npr. pomoću bitmape ili free list-ova koji se čuvaju out-of-line.
- Između chunk-ova (ili unutar njih) mogu biti umetnuti **guard slices / guard pages** (npr. unmapped slices) da bi se uhvatili out-of-bounds writes.

#### Type / Type ID

- Svako allocation site (ili poziv malloc, calloc, itd.) je povezan sa **type identifier-om** (jedan `malloc_type_id_t`) koji enkodira koji tip objekta se alocira. Taj type ID se prosleđuje allocator-u, koji ga koristi za izbor zone / segment-a za servisiranje alokacije.
- Zbog toga, čak i ako dve alokacije imaju istu veličinu, mogu ići u potpuno različite zone ako im tipovi razlikuju.
- U ranoj iOS 17 verziji, nisu svi API-ji (npr. CFAllocator) bili potpuno type-aware; Apple je adresirao neke od tih slabosti u iOS 18.

---

### Allocation & Freeing Workflow

Evo high-level toka kako allocation i deallocation rade u xzone:

1. **malloc / calloc / realloc / typed alloc** se poziva sa size-om i type ID.
2. Allocator koristi **type ID** da izabere odgovarajući segment group / zonu.
3. Unutar te zone/segment-a traži chunk koji ima free block-ove tražene veličine.
- Može konzultovati **local caches / per-thread pools** ili **free block lists** iz metadata.
- Ako nema free block-a, može alocirati novi chunk u toj zoni.
4. Metadata slab se ažurira (free bit se briše, bookkeeping).
5. Ako je memory tagging (EMTE) uključen, vraćeni block dobija **tag** i metadata se ažurira da odrazi njegov “live” state.
6. Kada se pozove `free()`:
- Block se označava kao freed u metadata (putem OOL slab-a).
- Block može biti stavljen u free list ili pooled za reuse.
- Opcionalno, sadržaj block-a može biti očišćen ili poisoned da smanji data leaks ili UAF exploitability.
- Hardware tag povezan sa block-om može biti invalidiran ili re-tag-ovan.
- Ako ceo chunk postane free (svi block-ovi freed), allocator može **reclaim** taj chunk (unmap-ovati ga ili vratiti OS-u) pod memory pressure-om.

---

### Security Features & Hardening

Ovo su odbrane ugrađene u moderni userland xzone:

| Feature | Purpose | Notes |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | Prevent overflow from corrupting metadata | Metadata živi u separatnom VM regionu (metadata slab)|
| **Guard pages / unmapped slices** | Catch out-of-bounds writes | Pomaže da se detektuju buffer overflows umesto da se tiho korumpiraju susedni block-ovi|
| **Type-based segregation** | Prevent cross-type reuse & type confusion | Čak i same-size alokacije iz različitih tipova idu u različite zone|
| **Memory Tagging (EMTE / MIE)** | Detect invalid access, stale references, OOB, UAF | xzone radi u paru sa hardware EMTE u synchronous modu (“Memory Integrity Enforcement”)|
| **Delayed reuse / poisoning / zap** | Reduce chance of use-after-free exploitation | Freed blocks mogu biti poisoned, zeroed, ili quarantine-ovani pre reuse-a |
| **Chunk reclamation / dynamic unmapping** | Reduce memory waste and fragmentation | Celi chunks mogu biti unmapped kada se ne koriste |
| **Randomization / placement variation** | Prevent deterministic adjacency | Blocks u chunk-u i izbor chunk-a mogu imati randomizovane aspekte |
| **Segregation of “data-only” allocations** | Separate allocations that don’t store pointers | Smanjuje attacker kontrolu nad metadata ili control poljima|

---

### Interaction with Memory Integrity Enforcement (MIE / EMTE)

- Apple-jev MIE (Memory Integrity Enforcement) je hardware + OS framework koji dovodi **Enhanced Memory Tagging Extension (EMTE)** u always-on, synchronous mod preko glavnih attack surface-a.
- xzone allocator je fundamentalna osnova MIE u user space-u: alokacije urađene preko xzone dobijaju tagove, i pristupi se proveravaju od strane hardware-a.
- U MIE, allocator, tag assignment, metadata management, i tag confidentiality enforcement su integrisani da osiguraju da memory greške (npr. stale reads, OOB, UAF) budu uhvaćene odmah, a ne iskorišćene kasnije.

---

If you like, I can also generate a cheat-sheet or diagram of xzone internals for your book. Do you want me to do that next?
::contentReference[oaicite:20]{index=20}


---

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
