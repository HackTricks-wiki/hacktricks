# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

### 1. **Code Signing** / Runtime Signature Verification
**Introduced early (iPhone OS → iOS)**
これは基本的な保護の一つです: **すべての実行可能コード**（apps, dynamic libraries, JIT-ed code, extensions, frameworks, caches）は Apple の信頼に根ざした証明書チェーンで暗号的に署名されていなければなりません。ランタイムでは、バイナリをメモリにロードする前（あるいは特定の境界を越えるジャンプを行う前）にシステムがその署名を検証します。コードが改変（bit-flip、patch）されたり未署名であれば、ロードは失敗します。

- **Thwarts**: “classic payload drop + execute” ステージの阻止；任意コード注入；既存バイナリを改変して悪意あるロジックを挿入することの阻止。
- **Mechanism detail**:
* Mach-O loader（および dynamic linker）はコードページ、セグメント、entitlements、team IDs、署名がファイル内容をカバーしていることをチェックします。
* JIT キャッシュや動的生成コードのようなメモリ領域については、Apple はページが署名されているか特殊な API（例: `mprotect` with code-sign checks）で検証されることを要求します。
* 署名には entitlements や識別子が含まれ、OS は特定の API や特権機能が偽造できない特定の entitlements を必要とすることを強制します。

<details>
<summary>Example</summary>
例えば、エクスプロイトでプロセス内のコード実行を得てヒープに shellcode を書き込みそこにジャンプしようとしたとします。iOS ではそのページは実行可能にフラグされるだけでは不十分で、code-signature の制約を満たす必要があります。shellcode が Apple の証明書で署名されていないため、ジャンプは失敗するか、そのメモリ領域を実行可能にすることが拒否されます。
</details>


### 2. **CoreTrust**
**Introduced around iOS 14+ era (or gradually in newer devices / later iOS)**
CoreTrust はバイナリ（システムとユーザバイナリを含む）の **ランタイム署名検証** を Apple のルート証明書に対して行うサブシステムで、ユーザランドのキャッシュされた信頼ストアに依存しません。

- **Thwarts**: インストール後のバイナリ改竄、system libraries や user apps を差し替え・patch しようとする jailbreaking 手法の阻止；信頼されたバイナリを悪意あるものとすり替える手法の防止。
- **Mechanism detail**:
* ローカルの信頼データベースや証明書キャッシュを信用する代わりに、CoreTrust は Apple のルートを直接参照したり、セキュアなチェーンで中間証明書を検証します。
* 既存バイナリへの変更（例: filesystem 上での改変）を検出して拒否することを保証します。
* entitlements、team IDs、code signing フラグ、その他のメタデータをロード時にバイナリに紐づけます。

<details>
<summary>Example</summary>
jailbreak が `SpringBoard` や `libsystem` をパッチしたバージョンに差し替えて永続化を狙うかもしれません。しかし OS の loader や CoreTrust がチェックすると、署名の不一致（または entitlements の改変）を検出して実行を拒否します。
</details>


### 3. **Data Execution Prevention (DEP / NX / W^X)**
**Introduced in many OSes earlier; iOS had NX-bit / w^x for a long time**
DEP は書き込み可能（data）としてマークされたページが **実行不可** であり、実行可能としてマークされたページが **書き込み不可** であることを強制します。単純にヒープやスタックに shellcode を書いて実行することはできません。

- **Thwarts**: 直接的な shellcode 実行；古典的なバッファオーバーフロー → 注入した shellcode にジャンプする手法の阻止。
- **Mechanism detail**:
* MMU / memory protection フラグ（ページテーブル経由）が分離を強制します。
* 書き込み可能なページを実行可能にしようとする試みはシステムチェックを引き起こし（禁止されるか、code-sign 承認が必要になります）。
* 多くの場合、ページを実行可能にするには追加の制約やチェックを課す OS API を経由する必要があります。

<details>
<summary>Example</summary>
オーバーフローで shellcode をヒープに書き込んだ攻撃者が `mprotect(heap_addr, size, PROT_EXEC)` を実行してそれを実行可能にしようとします。しかしシステムは拒否するか、その新しいページが code-sign の制約を満たすことを検証します（shellcode は満たせません）。
</details>

### 4. **Address Space Layout Randomization (ASLR)**
**Introduced in iOS ~4–5 era (roughly iOS 4–5 timeframe)**
ASLR は主要なメモリ領域（libraries, heap, stack 等）のベースアドレスを各プロセス起動時にランダム化します。gadgets のアドレスは実行ごとに変わります。

- **Thwarts**: ROP/JOP のために gadget アドレスをハードコードする手法；静的な exploit チェーン；既知のオフセットへ盲目的にジャンプする手法の阻止。
- **Mechanism detail**:
* 各ロード済みライブラリ / dynamic module はランダム化されたオフセットで再ベース化されます。
* スタックやヒープのベースポインタは（一定のエントロピー制限内で）ランダム化されます。
* 時に他の領域（例: mmap アロケーション）もランダム化されます。
* 情報-leak mitigations と組み合わさって、攻撃者はまずアドレスやポインタを leak して実行時にベースアドレスを特定する必要があります。

<details>
<summary>Example</summary>
ROP チェーンが `0x….lib + offset` にある gadget を期待している場合、`lib` は実行ごとに再配置されるためハードコードされたチェーンは失敗します。エクスプロイトはモジュールのベースアドレスをまず leak して gadget アドレスを計算する必要があります。
</details>


### 5. **Kernel Address Space Layout Randomization (KASLR)**
**Introduced in iOS ~ (iOS 5 / iOS 6 timeframe)**
ユーザ ASLR に類似して、KASLR は起動時に **kernel text** やその他のカーネル構造のベースをランダム化します。

- **Thwarts**: カーネルレベルの exploit が固定された kernel コードやデータ位置に依存することの阻止；静的なカーネル exploit の防止。
- **Mechanism detail**:
* 各ブートでカーネルのベースアドレスが（範囲内で）ランダム化されます。
* `task_structs`、`vm_map` のようなカーネルデータ構造も移動またはオフセットされる場合があります。
* 攻撃者はカーネルポインタをまず leak するか、情報開示の脆弱性を利用してオフセットを計算しなければ、カーネル構造やコードを乗っ取れません。

<details>
<summary>Example</summary>
ローカル脆弱性がカーネル関数ポインタ（例: `vtable`）を `KERN_BASE + offset` で破壊しようとします。しかし `KERN_BASE` が不明なので、攻撃者はまずそれを leak して正しいアドレスを計算する必要があります（例: read primitive を介して）。
</details>


### 6. **Kernel Patch Protection (KPP / AMCC)**
**Introduced in newer iOS / A-series hardware (post around iOS 15–16 era or newer chips)**
KPP（別名 AMCC）はカーネルの text ページの整合性を（ハッシュやチェックサムで）継続的に監視します。許可されていない窓口外で改竄（patch、inline hook、コード変更）を検出すると、kernel panic や再起動を引き起こします。

- **Thwarts**: 永続的なカーネルパッチ（カーネル命令の改変）、inline hook、静的関数上書きの阻止。
- **Mechanism detail**:
* ハードウェアまたはファームウェアモジュールがカーネル text 領域を監視します。
* ページを周期的またはオンデマンドで再ハッシュし、期待値と比較します。
* 悪意ある不一致が benign なアップデート窓口外で発生するとデバイスを panic させます（永続的な悪意あるパッチを避けるため）。
* 攻撃者は検出ウィンドウを回避するか、正当な patch 経路を使う必要があります。

<details>
<summary>Example</summary>
あるエクスプロイトがカーネル関数プロローグ（例: `memcmp`）をパッチして呼び出しを傍受しようとします。しかし KPP はコードページのハッシュが期待値と一致しないことを検出し、カーネル panic を引き起こしてデバイスをクラッシュさせ、パッチが安定する前に阻止します。
</details>


### 7. **Kernel Text Read‐Only Region (KTRR)**
**Introduced in modern SoCs (post ~A12 / newer hardware)**
KTRR はハードウェアで強制される仕組みです: ブート中の早い段階で kernel text がロックされると、それ以降 EL1（カーネル）からは読み取り専用になり、コードページへの書き込みが防止されます。

- **Thwarts**: ブート後のカーネルコード改変（例: パッチ、in-place code injection）を EL1 権限で行うことの阻止。
- **Mechanism detail**:
* ブート（secure/bootloader ステージ）時にメモリコントローラ（またはセキュアハードウェアユニット）がカーネルテキストを含む物理ページを読み取り専用に設定します。
* たとえ exploit が完全なカーネル権限を得ても、そのページを書き換えて命令をパッチすることはできません。
* それらを変更するには、攻撃者はまずブートチェーンを破り、または KTRR 自体を乗っ取らなければなりません。

<details>
<summary>Example</summary>
権限昇格エクスプロイトが EL1 にジャンプしてカーネル関数にトランポリンを書き込もうとします（例: `syscall` ハンドラ）。しかしページは KTRR によって読み取り専用にロックされているため、書き込みは失敗するかフォルトを引き起こし、パッチは適用されません。
</details>


### 8. **Pointer Authentication Codes (PAC)**
**Introduced with ARMv8.3 (hardware), Apple beginning with A12 / iOS ~12+**
- PAC は **ARMv8.3-A** で導入されたハードウェア機能で、ポインタ値（戻りアドレス、関数ポインタ、一部のデータポインタ）の改竄を検出するために、ポインタの未使用上位ビットに小さな暗号署名（“MAC”）を埋め込みます。
- 署名（“PAC”）はポインタ値と **modifier**（文脈値、例: stack pointer や区別用データ）を元に計算されます。これにより同一のポインタ値でも異なる文脈では別の PAC になります。
- 使用時に、そのポインタで dereference や branch を行う前に **authenticate** 命令が PAC をチェックします。正しければ PAC を剥ぎ取り純粋なポインタを得ます。誤っていればポインタは “poisoned” になるかフォルトが発生します。
- PAC を生成/検証する鍵は特権レジスタ（EL1, kernel）に保管され、user mode から直接読み出せません。
- 多くのシステムではポインタの全 64 ビットが使われていないため（例: 48-bit address space）、上位ビットの余裕に PAC を格納できます。

#### Architectural Basis & Key Types

- ARMv8.3 は **五つの 128-bit 鍵**（それぞれ二つの 64-bit システムレジスタで実装される）を導入します。
- **APIAKey** — instruction pointers 用（domain “I”, key A）
- **APIBKey** — 二番目の instruction pointer 鍵（domain “I”, key B）
- **APDAKey** — data pointers 用（domain “D”, key A）
- **APDBKey** — data pointers 用（domain “D”, key B）
- **APGAKey** — generic 鍵、ポインタ以外のデータや汎用用途に使用

- これらの鍵は特権システムレジスタに格納され（EL1/EL2 等でのみアクセス可能）、user mode からはアクセスできません。
- PAC は暗号関数（ARM は QARMA を推奨）を用いて計算され、以下を入力とします:
1. ポインタ値（カノニカル部分）
2. **modifier**（文脈値、例: salt）
3. 秘密鍵
4. 内部の tweak ロジック
結果の PAC がポインタの上位ビットに格納されているものと一致すれば認証成功です。


#### Instruction Families

命名規則は: **PAC** / **AUT** / **XPAC** 、続いて domain 文字です。
- `PACxx` 命令はポインタに署名して PAC を挿入します
- `AUTxx` 命令は認証して PAC を剥ぎ取ります（validate + strip）
- `XPACxx` 命令は検証せずに剥ぎ取ります（strip without validating）

Domains / suffixes:

| Mnemonic     | Meaning / Domain                      | Key / Domain     | Example Usage in Assembly |
|--------------|-----------------------------------------|--------------------|-----------------------------|
| **PACIA**    | Sign instruction pointer with APIAKey   | “I, A”             | `PACIA X0, X1` — sign pointer in X0 using APIAKey with modifier X1|
| **PACIB**    | Sign instruction pointer with APIBKey   | “I, B”             | `PACIB X2, X3`              |
| **PACDA**    | Sign data pointer with APDAKey           | “D, A”             | `PACDA X4, X5`              |
| **PACDB**    | Sign data pointer with APDBKey           | “D, B”             | `PACDB X6, X7`              |
| **PACG / PACGA** | Generic (non-pointer) signing with APGAKey | “G”         | `PACGA X8, X9, X10` (sign X9 with modifier X10 into X8) |
| **AUTIA**    | Authenticate APIA-signed instruction pointer & strip PAC | “I, A” | `AUTIA X0, X1` — check PAC on X0 using modifier X1, then strip |
| **AUTIB**    | Authenticate APIB domain                 | “I, B”             | `AUTIB X2, X3`               |
| **AUTDA**    | Authenticate APDA-signed data pointer    | “D, A”             | `AUTDA X4, X5`               |
| **AUTDB**    | Authenticate APDB-signed data pointer    | “D, B”             | `AUTDB X6, X7`               |
| **AUTGA**    | Authenticate generic / blob (APGA)        | “G”               | `AUTGA X8, X9, X10` (validate generic) |
| **XPACI**     | Strip PAC (instruction pointer, no validation) | “I”         | `XPACI X0` — remove PAC from X0 (instruction domain) |
| **XPACD**     | Strip PAC (data pointer, no validation)    | “D”             | `XPACD X4` — remove PAC from data pointer in X4 |

いくつかの特殊/エイリアス形式があります:

- `PACIASP` は `PACIA X30, SP` の省略形（リンクレジスタを SP を modifier として署名）
- `AUTIASP` は `AUTIA X30, SP`（リンクレジスタを SP で認証）
- `RETAA`, `RETAB`（authenticate-and-return）や `BLRAA`（authenticate & branch）といった結合形式は ARM 拡張 / コンパイラサポートに存在します。
- modifier がゼロのバリアントもあります: `PACIZA` / `PACIZB`（modifier が暗黙的にゼロ）など。

#### Modifiers

modifier の主目的は PAC を特定の文脈に結びつけることで、同じアドレスが異なる文脈で使われた場合に異なる PAC が生成されるようにすることです。ハッシュに salt を加えるようなものです。

したがって:
- **modifier** は文脈値（別のレジスタ）で、PAC の計算に混ぜられます。典型的には stack pointer (`SP`)、frame pointer、あるいはオブジェクト ID などが使われます。
- SP を modifier に使うのは戻りアドレス署名で一般的です: PAC は特定のスタックフレームに結びつくため、別のフレームで LR を再利用すると modifier が変わり認証は失敗します。
- 同じポインタ値を異なる modifier で署名すると、異なる PAC になります。
- modifier は秘密である必要はありませんが、理想的には攻撃者に制御されない値であるべきです。
- 有意な modifier が存在しない場合、いくつかの形式はゼロや暗黙の定数を使います。

#### Apple / iOS / XNU Customizations & Observations

- Apple の PAC 実装には **per-boot diversifiers** が含まれており、キーや tweak がブートごとに変わるためブート跨りでの再利用を防ぎます。
- クロスドメイン緩和策もあり、user mode で署名された PAC が簡単に kernel mode で再利用されないようにしています。
- Apple Silicon（M1）ではリバースで **nine modifier types** やキー制御用の Apple 固有システムレジスタが見つかっています。
- Apple は多くのカーネルサブシステムで PAC を使用しています: 戻りアドレス署名、カーネルデータ内のポインタ整合性、signed thread contexts など。
- Google Project Zero は、強力なメモリ read/write primitive をカーネルで持つとカーネル PAC（A keys）を偽造できる可能性があることを示しました（A12 以前のデバイス）が、Apple は多くの経路を修正しています。
- Apple の体系では一部の鍵が **kernel 全体でグローバル** な一方、ユーザプロセスはプロセスごとのランダム性を得ることがあります。

#### PAC Bypasses

1. **Kernel-mode PAC: theoretical vs real bypasses**

-   カーネル PAC 鍵とロジックは厳格に管理されている（特権レジスタ、diversifiers、ドメイン分離）のため、任意の署名付きカーネルポインタを偽造するのは非常に困難です。
-   Azad の 2020 年 “iOS Kernel PAC, One Year Later” は iOS 12-13 でいくつかの部分的な bypass（signing gadgets、signed states の再利用、保護されていない間接分岐）を見つけたが、汎用的な完全 bypass は見つからなかったと報告しています。 [bazad.github.io](https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf)
-   Apple の “Dark Magic” カスタマイズはさらに攻撃可能面を狭めています（ドメイン切替、per-key enabling bits など）。 [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Apple silicon (M1/M2) 上の **kernel PAC bypass CVE-2023-32424** のような既知の脆弱性が報告されています（Zecao Cai 他）。 [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   しかしこれらの bypass は多くの場合非常に特定の gadgets や実装バグに依存しており、汎用的なバイパスではありません。

従ってカーネル PAC は **非常に堅牢と見なされている** が完全ではありません。

2. **User-mode / runtime PAC bypass techniques**

これらはより一般的で、PAC が動的リンキングやランタイムフレームワークで適用される際の不完全さを利用します。以下にクラスと例を挙げます。

2.1 **Shared Cache / A key issues**

-   **dyld shared cache** は多数のシステムフレームワークとライブラリを事前リンクした大きなブロブです。広く共有されるため、shared cache 内の関数ポインタは既に署名されており、多くのプロセスで使われます。攻撃者はこれら既に署名されたポインタを “PAC oracles” として狙います。

-   一部の bypass 技法は shared cache にある A-key 署名済ポインタを抽出・再利用して PAC を回避しようとします。

-   "No Clicks Required" の発表は shared cache 上にオラクルを構築して相対アドレスを推測し、署名付きポインタと組み合わせて PAC を回避する手法を説明しています。 [saelo.github.io](https://saelo.github.io/presentations/offensivecon_20_no_clicks.pdf)

-   また、ユーザ空間の shared libraries からの関数ポインタの import が十分に PAC で保護されておらず、攻撃者がシグネチャを変えずに関数ポインタを取得できるケースが見つかっています（Project Zero のバグエントリ）。 [bugs.chromium.org](https://bugs.chromium.org/p/project-zero/issues/detail?id=2044&utm_source=chatgpt.com)

2.2 **dlsym(3) / dynamic symbol resolution**

-   既知の bypass の一つは `dlsym()` を呼び出して *既に署名された* 関数ポインタ（A-key で署名、diversifier がゼロ）を取得し、それを利用する方法です。`dlsym` が正当に署名されたポインタを返すため、それを使うことで PAC を偽造する必要がなくなります。

-   Epsilon のブログはこのような bypass を詳述しており: `dlsym("someSym")` が署名済みポインタを返し、間接呼び出しに使える場合があると述べています。 [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

-   Synacktiv の "iOS 18.4 --- dlsym considered harmful" は iOS 18.4 で一部のシンボルが誤って署名された（または diversifier がバグっている）ポインタを返し、意図しない PAC bypass を可能にした事例を説明しています。 [Synacktiv](https://www.synacktiv.com/en/publications/ios-184-dlsym-considered-harmful)

-   dyld のロジックでは: `result->isCode` のときに返されるポインタを `__builtin_ptrauth_sign_unauthenticated(..., key_asia, 0)` で署名する、つまり文脈としてゼロを使うことがあると報告されています。 [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

したがって、`dlsym` は user-mode PAC bypass の頻繁なベクトルです。

2.3 **Other DYLD / runtime relocations**

-   DYLD loader と dynamic relocation ロジックは複雑で、一時的にページを read/write としてマップして relocations を行い、その後 read-only に戻すことがあります。攻撃者はこれらのウィンドウを悪用します。Synacktiv の発表は relocation を利用した timing ベースの PAC bypass（"Operation Triangulation"）を説明しています。 [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   DYLD ページは現在 SPRR / VM_FLAGS_TPRO のような保護で守られていますが、以前のバージョンでは弱いガードしかなかったことがあります。 [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   WebKit のエクスプロイトチェーンでは DYLD loader は PAC bypass の標的になることが多いです。スライドでは多くの PAC bypass が DYLD loader（relocation、interposer hooks 経由）を標的にしてきたと述べられています。 [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

2.4 **NSPredicate / NSExpression / ObjC / SLOP**

-   ユーザランドのエクスプロイトチェーンでは、Objective-C ランタイムのメソッド（`NSPredicate`, `NSExpression`, `NSInvocation` など）が制御呼び出しを密輸するために使われます。

-   PAC 導入前の古い iOS では、**fake NSInvocation** オブジェクトを使って制御されたメモリ上のセレクタを呼び出すエクスプロイトがありました。PAC の導入により手法は修正が必要になりましたが、SLOP（SeLector Oriented Programming）は PAC 下でも拡張されています。 [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   元々の SLOP 技法は偽の invocations を作ることで ObjC 呼び出しを連結することを可能にしていました; bypass は時に ISA や selector ポインタが完全に PAC 保護されていない点を利用します。 [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   ポインタ認証が部分的にしか適用されない環境では、method / selector / target pointers が常に PAC 保護されているわけではなく、回避の余地を与えます。

#### Example Flow

<details>
<summary>Example Signing & Authenticating</summary>
```
; Example: function prologue / return address protection
my_func:
stp x29, x30, [sp, #-0x20]!        ; push frame pointer + LR
mov x29, sp
PACIASP                            ; sign LR (x30) using SP as modifier
; … body …
mov sp, x29
ldp x29, x30, [sp], #0x20         ; restore
AUTIASP                            ; authenticate & strip PAC
ret

; Example: indirect function pointer stored in a struct
; suppose X1 contains a function pointer
PACDA X1, X2     ; sign data pointer X1 with context X2
STR X1, [X0]      ; store signed pointer

; later retrieval:
LDR X1, [X0]
AUTDA X1, X2       ; authenticate & strip
BLR X1             ; branch to valid target

; Example: stripping for comparison (unsafe)
LDR X1, [X0]
XPACI X1           ; strip PAC (instruction domain)
CMP X1, #some_label_address
BEQ matched_label
```
</details>

<details>
<summary>例</summary>
バッファオーバーフローはスタック上のリターンアドレスを上書きします。攻撃者はターゲットのgadgetアドレスを書き込みますが、正しいPACを算出できない場合があります。関数がリターンすると、CPUの`AUTIA`命令はPACが不一致のためフォルトします。チェインは失敗します。
Project ZeroによるA12 (iPhone XS)の解析は、AppleのPACの使われ方と、攻撃者がメモリの読み書きプリミティブを持つ場合にPACを偽造する方法を示しました。
</details>


### 9. **Branch Target Identification (BTI)**
**Introduced with ARMv8.5 (later hardware)**
BTIは、間接分岐ターゲットをチェックするハードウェア機能です: `blr` や間接的なcall/jumpを実行する際、ターゲットは**BTIランディングパッド**（`BTI j` または `BTI c`）で始まっている必要があります。ランディングパッドがないgadgetアドレスにジャンプすると例外が発生します。

LLVMの実装ノートはBTI命令の三つのバリアントと、それらが分岐タイプにどう対応するかを示しています。

| BTI Variant | 何を許可するか（どの分岐タイプか） | 一般的な配置 / 使用例 |
|-------------|----------------------------------------|-------------------------------|
| **BTI C** | *call* スタイルの間接分岐のターゲット（例: `BLR`、または X16/X17 を使う `BR`） | 間接呼び出しされる可能性のある関数の先頭に置く |
| **BTI J** | *jump* スタイルの分岐のターゲット（例: tail call に使われる `BR`） | ジャンプテーブルやtail-callで到達可能なブロックの先頭に配置 |
| **BTI JC** | C と J の両方として機能する | call または jump のどちらにもターゲットにされ得る |

- branch target enforcement 有効でコンパイルされたコードでは、コンパイラは各有効な間接分岐ターゲット（関数の先頭やジャンプで到達可能なブロック）にBTI命令（C, J, または JC）を挿入し、間接分岐がそれらの場所へしか成功しないようにします。
- **直接分岐 / call**（固定アドレスの `B`, `BL`）はBTIによって制限されません。仮定としてコードページは信頼されており攻撃者がそれを変更できないため（直接分岐は安全とみなされる）です。
- また、**RET / return** 命令は一般にBTIで制限されないことが多いです。なぜなら戻りアドレスはPACやリターン署名機構で保護されているからです。

#### メカニズムと強制

- CPUが「guarded / BTI-enabled」とマークされたページで間接分岐（BLR / BR）をデコードするとき、ターゲットアドレスの最初の命令が許可されたBTI（C, J, または JC）であるかをチェックします。そうでない場合、**Branch Target Exception** が発生します。
- BTI命令のエンコーディングは、以前のARMバージョンでNOP用に予約されていたオペコードを再利用するよう設計されています。したがって、BTI対応のバイナリは後方互換性を保ち、BTI非対応ハードウェアではそれらの命令はNOPとして動作します。
- BTIを追加するコンパイラパスは、必要な箇所にのみ挿入します: 間接的に呼ばれる可能性がある関数、またはジャンプでターゲットされ得る基本ブロック。
- いくつかのパッチやLLVMのコードは、BTIがすべての基本ブロックに挿入されるわけではなく、switch / jump table などで潜在的な分岐ターゲットとなるブロックのみに挿入されることを示しています。

#### BTI と PAC の相乗効果

PACはポインタ値（ソース）を保護し、間接呼び出し／リターンのチェインが改ざんされていないことを保証します。

BTIは有効なポインタであっても、正しくマーキングされたエントリポイントのみをターゲットにできるようにします。

組み合わせると、攻撃者は正しいPACを持つ有効なポインタに加えて、そのターゲットがBTIを持っている必要があります。これによりエクスプロイトgadgetの構築がさらに困難になります。

#### 例


<details>
<summary>例</summary>
エクスプロイトが `0xABCDEF` にある gadget にピボットしようとしますが、その場所は `BTI c` で始まっていません。CPUは `blr x0` を実行するとターゲットをチェックし、ランディングパッドが有効でないためフォルトします。したがって多くのgadgetはBTIプレフィックスがない限り使えなくなります。
</details>


### 10. **Privileged Access Never (PAN) & Privileged Execute Never (PXN)**
**Introduced in more recent ARMv8 extensions / iOS support (for hardened kernel)**

#### PAN (Privileged Access Never)

- **PAN** は **ARMv8.1-A** で導入された機能で、**特権コード**（EL1 または EL2）が **user-accessible (EL0)** とマークされたメモリを **読み書き** することを防ぎます。PANは明示的に無効にされない限り有効です。
- 概念としては: カーネルが騙されたり妥協された場合でも、まずPANをクリアしないとカーネルが任意にユーザ空間ポインタを参照できないようにし、`ret2usr` スタイルのエクスプロイトやユーザ制御バッファの悪用リスクを減らします。
- PANが有効なとき（PSTATE.PAN = 1）、EL0で「アクセス可能」とマークされた仮想アドレスに対する特権の load/store 命令はパーミッションフォルトを引き起こします。
- カーネルが正当にユーザ空間メモリにアクセスする必要がある場合（例: ユーザバッファへのデータコピー）、カーネルは一時的にPANを無効にするか（または「非特権の load/store」命令に切り替えて）そのアクセスを許可する必要があります。
- ARM64上のLinuxでは、PANサポートは2015年頃に導入されました: カーネルパッチは機能の検出を追加し、`get_user` / `put_user` 等をPANをクリアするバリアントに置き換えました。

**重要なニュアンス / 制限 / バグ**
- Siguzaらが指摘したように、ARM設計の仕様バグ（あるいは曖昧な挙動）により、**execute-only user mappings**（`--x`）は**PANをトリガーしない**場合があります。つまり、ユーザページが実行可能で読み取り権がない場合、カーネルの読み取り試行がPANをバイパスすることがあり得ます。アーキテクチャが「EL0でアクセス可能」と判断するには読み取り可能であることを要求し、実行のみを許すページは該当しないとみなされるためです。これは特定の構成でPANバイパスにつながります。
- そのため、iOS / XNU が execute-only のユーザページを許可している（JITやcode-cacheの設定でそうなることがある）場合、カーネルはPANが有効でもそれらから読み出せてしまう可能性があります。これはARMv8+システムのいくつかで既知の微妙な悪用可能領域です。

#### PXN (Privileged eXecute Never)

- **PXN** はページテーブルのフラグ（ページテーブルエントリのリーフまたはブロックエントリ）で、そのページが**特権モードで実行できない**（つまりEL1での実行が禁止される）ことを示します。
- PXNは、特権コード（カーネルなど）がユーザ空間ページから命令を実行することを防ぎます。結果として、カーネルレベルで制御フローがユーザメモリに向かっても実行を止めます。
- PANと組み合わせると以下が保証されます:
1. カーネルはデフォルトでユーザデータを読み書きできない（PAN）
2. カーネルはユーザコードを実行できない（PXN）
- ARMv8のページテーブルフォーマットでは、リーフエントリに `PXN` ビット（および非特権実行禁止の `UXN`）があります。

したがって、カーネルが壊れた関数ポインタを持ちユーザメモリを指していて分岐しようとしても、PXNビットによりフォルトが発生します。

#### メモリ許可モデルとPAN / PXN がページテーブルビットにどう対応するか

PAN / PXN の動作を理解するには、ARMの翻訳とパーミッションモデル（簡略化）を理解する必要があります:

- 各ページまたはブロックエントリは、アクセス許可のための **AP[2:1]**（読み/書き、特権 vs 非特権）や実行禁止制限のための **UXN / PXN** ビットなどの属性フィールドを持ちます。
- PSTATE.PAN が 1（有効）であるとき、ハードウェアは修正された意味論を強制します: EL0により「アクセス可能」とマークされたページへの特権アクセスは許可されずフォルトになります。
- 前述のバグのため、読み取り権のない実行専用ページは実装によっては「EL0でアクセス可能」とカウントされない場合があり、これがPANのバイパスにつながります。
- ページのPXNビットがセットされている場合、上位特権レベルからの命令フェッチでも実行が禁止されます。

#### ハード化されたOS（例: iOS / XNU）におけるPAN / PXNのカーネルでの使用

ハード化カーネル設計（Appleが採用している可能性のある設計）では:

- カーネルはデフォルトでPANを有効にします（特権コードの制約）。
- 正当にユーザバッファを読み書きする経路（システムコールのデータコピー、I/O、ユーザポインタのread/writeなど）では、カーネルは一時的にPANを**無効化**するか、特別な命令を使って上書きします。
- ユーザーデータアクセスを終えたら、PANを再度有効に戻す必要があります。
- PXNはページテーブルで強制されます: ユーザページはPXN = 1（カーネルがそれらを実行できない）、カーネルページはPXNが設定されていません（カーネルコードは実行可能）。
- カーネルはユーザメモリ領域への実行フローを誘発しないようにコードパスを保証する必要があります（これが守られないと、ユーザ制御シェルコードへのジャンプに基づくエクスプロイトが成立してしまう）。

実際のシステムでは、execute-only ページによるPANバイパスを避けるために Apple が execute-only のユーザページを無効にするか、仕様の弱点を回避するパッチを当てている可能性があります。


#### 攻撃対象面、バイパス、緩和策

- **execute-only ページによる PAN バイパス**: 前述の通り、仕様の隙間により読み取り権のない実行専用ユーザページがPANを回避する場合があります。これにより攻撃者は「execute-only」セクションを介してデータを渡す異例の経路を得ることがあります。
- **一時的ウィンドウ攻撃**: カーネルがPANを必要以上に長く無効化する場合、レースや悪意ある経路がそのウィンドウを利用して不正なユーザメモリアクセスを行う可能性があります。
- **再有効化忘れ**: コードパスがPANを再有効化し忘れると、その後のカーネル操作が誤ってユーザメモリにアクセスしてしまう可能性があります。
- **PXNの誤設定**: ページテーブルがユーザページにPXNを設定していない、またはユーザコードページを誤ってマップしていると、カーネルがユーザ空間コードを実行してしまう可能性があります。
- **投機的 / サイドチャネル**: 投機的実行を利用したバイパスのように、PAN / PXN チェックの一時的回避を引き起こすマイクロアーキテクチャの副作用があるかもしれません（ただしこれらの攻撃はCPU設計に強く依存します）。
- **複雑な相互作用**: JIT、共有メモリ、just-in-time code regions のような高度な機能では、カーネルはユーザマップ領域での特定のメモリアクセスや実行を許可する細かな制御が必要になります。PAN/PXN 制約の下で安全に設計するのは非自明です。


#### 例

<details>
<summary>コード例</summary>
以下は、ユーザメモリアクセスの前後でPANを有効/無効にすることを示す擬似アセンブリ系列と、どのようにフォルトが発生するかを示す説明です。
</details>
```  
// Suppose kernel entry point, PAN is enabled (privileged code cannot access user memory by default)

; Kernel receives a syscall with user pointer in X0
; wants to read an integer from user space
mov   X1, X0        ; X1 = user pointer

; disable PAN to allow privileged access to user memory
MSR   PSTATE.PAN, #0   ; clear PAN bit, disabling the restriction

ldr   W2, [X1]       ; now allowed load from user address

; re-enable PAN before doing other kernel logic
MSR   PSTATE.PAN, #1   ; set PAN

; ... further kernel work ...

; Later, suppose an exploit corrupts a pointer to a user-space code page and jumps there
BR    X3             ; branch to X3 (which points into user memory)

; Because the target page is marked PXN = 1 for privileged execution,
; the CPU throws an exception (fault) and rejects execution
```
もしカーネルがそのユーザページにPXNを**設定していなかった**場合、その分岐は成功してしまう可能性があり、これは安全ではありません。

カーネルがユーザメモリへのアクセス後にPANを再有効化するのを忘れると、さらにカーネルの処理が誤って任意のユーザメモリを読み書きしてしまう隙が生じます。

ユーザポインタが実行のみのページ（実行権限のみで読み/書き不可）を指している場合、PAN仕様のバグにより、`ldr W2, [X1]` はPANが有効でも**フォルトしない**ことがあり、実装によってはバイパス攻撃を可能にします。

</details>

<details>
<summary>例</summary>
カーネルの脆弱性がユーザ提供の関数ポインタを取得してカーネルコンテキストで呼び出そうとする（例: `call user_buffer`）。PAN/PXN下では、その操作は許可されないかフォルトします。
</details>

---

### 11. **Top Byte Ignore (TBI) / Pointer Tagging**
**導入: ARMv8.5以降（またはオプション拡張）**
TBIは64ビットポインタの最上位バイト（最上位8ビット）をアドレス変換時に無視することを意味します。これにより、OSやハードウェアはポインタの最上位バイトに**タグビット**を埋め込んでも実際のアドレスに影響を与えません。

- TBIは**Top Byte Ignore**（時に *Address Tagging* と呼ばれる）を意味します。これはハードウェア機能で（多くのARMv8+実装で利用可能）、64ビットポインタの**最上位8ビットを無視**（bits 63:56）して、**address translation / load/store / instruction fetch** を行います。
- 実際には、CPUはポインタ `0xTTxxxx_xxxx_xxxx`（`TT` = トップバイト）をアドレス翻訳の目的では `0x00xxxx_xxxx_xxxx` と扱い、トップバイトをマスク（除去）します。トップバイトはソフトウェアが**メタデータ / タグビット**を格納するために使えます。
- これにより、各ポインタに1バイト分のタグを埋め込んでも参照先メモリ位置が変わらない「オーバーヘッド無しのインバンド領域」をソフトウェアに提供します。
- アーキテクチャはロード・ストア・命令フェッチの際にポインタのトップバイトをマスク（タグを剥がす）してから実際のメモリアクセスを行うことを保証します。

したがって、TBIは**論理ポインタ**（pointer + tag）とメモリ操作に使われる**実際のアドレス**とを切り離します。

#### Why TBI: Use cases and motivation

- **Pointer tagging / metadata**: トップバイトに追加のメタデータ（例：オブジェクト型、バージョン、境界、整合性タグ）を格納できます。後でポインタを使用する際、ハードウェアレベルでタグが無視されるため、メモリアクセス時に手動で剥がす必要がありません。
- **Memory tagging / MTE (Memory Tagging Extension)**: TBIはMTEが構築するための基本的なハードウェア機構です。ARMv8.5では、**Memory Tagging Extension** がポインタのビット59:56を**論理タグ**として使い、メモリに格納された**allocation tag**と照合します。
- **Enhanced security & integrity**: TBIをpointer authentication (PAC) や実行時チェックと組み合わせることで、ポインタ値だけでなくタグも正しいことを強制できます。不正なタグでポインタを書き換えた攻撃者はタグ不一致を引き起こします。
- **Compatibility**: TBIはオプションでありタグビットはハードウェアにより無視されるため、既存のタグ無しコードはそのまま動作します。タグビットはレガシーコードに対して事実上「関係ない」ビットになります。

#### Example
<details>
<summary>例</summary>
関数ポインタのトップバイトにタグ（例えば `0xAA`）が含まれていたとします。エクスプロイトがポインタの下位ビットを上書きしてタグを無視すると、カーネルが検証やサニタイズを行った際にタグ不一致でポインタが拒否される、という例です。
</details>

---

### 12. **Page Protection Layer (PPL)**
**導入: 最新のiOS / モダンハードウェア（iOS ≒17 / Apple silicon / ハイエンド機種）**（一部の報告ではmacOS / Apple siliconでのPPLについて言及されていますが、Appleは同様の保護をiOSにも導入しています）

- PPLは**カーネル内部の保護境界**として設計されています：たとえカーネル（EL1）が侵害されて読み書き可能になっても、**特定の機密ページ**（特にページテーブル、コード署名メタデータ、カーネルコードページ、エンタイトルメント、trust cache等）を自由に修正できてはならない、という考えです。
- これは事実上「カーネル内の小さな信頼コンポーネント（PPL）」を作り、そのコンポーネントのみが保護ページを変更できるようにするものです。その他のカーネルコードは変更を行う際にPPLルーチンを呼び出す必要があります。
- これによりカーネルエクスプロイトの攻撃面が減少します：たとえカーネルモードで任意のR/W/executeが得られても、攻撃コードはPPLドメインに侵入するかPPLをバイパスしない限り重要な構造を変更できません。
- 新しいApple silicon（A15+ / M2+）では、Appleはページテーブル保護のために多くの場合PPLの代わりに**SPTM (Secure Page Table Monitor)** へ移行しています。

ここでは公開解析に基づいてPPLがどのように動作すると考えられているかを示します。

#### Use of APRR / permission routing (APRR = Access Permission ReRouting)

- Appleのハードウェアは**APRR (Access Permission ReRouting)** と呼ばれる機構を使用します。これによりページテーブルエントリ（PTE）はフルの権限ビットを持つ代わりに小さなインデックスを含めることができ、そのインデックスはAPRRレジスタ経由で実際の権限にマッピングされます。これによりドメインごとに権限を動的に再マッピングできます。
- PPLはAPRRを利用してカーネルコンテキスト内の特権を分離します：PPLドメインのみがインデックスと実際の権限とのマッピングを更新することを許可されます。つまり、非PPLのカーネルコードがPTEを書き込んだり権限ビットを変更しようとすると、APRRロジックがそれを拒否（または読み取り専用マッピングを強制）します。
- PPLコード自体は制限された領域（例: `__PPLTEXT`）で実行され、通常はエントリゲートが一時的に許可するまで実行不可または書き込み不可です。カーネルは敏感な操作を実行するためにPPLエントリポイント（“PPL routines”）を呼び出します。

#### Gate / Entry & Exit

- カーネルが保護ページ（例：カーネルコードページの権限変更やページテーブルの修正）を変更する必要があるとき、PPLラッパーを呼び出し、検証を行った上でPPLドメインに遷移します。そのドメイン外では保護ページは事実上読み取り専用または変更不可です。
- PPLエントリ時に、APRRマッピングが調整されPPL領域のメモリページがPPL内では**実行 & 書き込み可能**に設定されます。終了時にはそれらは読み取り専用/非書き込み状態に戻されます。これにより、監査されたPPLルーチンだけが保護ページを書き換えられることが保証されます。
- PPL外では、カーネルコードがそれら保護ページに書き込みを試みるとフォルト（権限拒否）します。これは、そのコードドメインのAPRRマッピングが書き込みを許可していないためです。

#### Protected page categories

PPLが通常保護するページには次が含まれます:

- ページテーブル構造（翻訳テーブルエントリ、マッピングメタデータ）
- 重要なロジックを含むカーネルコードページ
- コード署名メタデータ（trust caches、署名ブロブ）
- エンタイトルメントテーブル、署名強制テーブル
- 署名チェック回避や資格情報操作を可能にするような高価値のカーネル構造

考え方は、たとえカーネルメモリが完全に制御されたとしても、攻撃者が単純にこれらページをパッチ／書き換えできないようにする、という点です。PPLルーチンを侵害するかPPLをバイパスしない限り変更は不可能です。

#### Known Bypasses & Vulnerabilities

1. **Project Zero’s PPL bypass (stale TLB trick)**

- Project Zeroによる公開された解析は、**stale TLB entries** を利用する回避法を示しています。
- 考え方:

1. 物理ページAとBを割り当て、それらをPPLページとしてマークする。
2. 仮想アドレスPとQをマップするが、これらのL3翻訳テーブルページがAとBから取られるようにする。
3. スレッドを回してQに継続的にアクセスさせ、QのTLBエントリを生存させ続ける。
4. `pmap_remove_options()` を呼んでPからのマッピングを削除する。バグにより、コードはPとQの両方のTTEを誤って削除するが、TLBの無効化はPだけに対して行われ、Qの古い（stale）エントリが残る。
5. B（Qのテーブル）を再利用して任意のメモリ（例：PPL保護ページ）をマップする。古いTLBエントリが依然としてQの旧マッピングをマッピングしているため、そのコンテキストではそのマッピングが有効なままになる。
6. これにより攻撃者はPPLインターフェースを経ずにPPL保護ページの書き込み可能なマッピングを配置できる。

- このエクスプロイトは物理マッピングとTLB挙動を細かく制御する必要がありました。これにより、TLB無効化とマッピングの整合性に依存するセキュリティ境界は非常に注意深く扱う必要があることが示されます。
- Project Zeroは、このようなバイパスは微妙で稀であるが複雑なシステムでは可能であるとコメントしています。それでも彼らはPPLを堅固な緩和策と見なしています。

2. **Other potential hazards & constraints**

- カーネルのエクスプロイトがPPLラッパーを直接呼び出してPPLルーチンに入れる場合、制限をバイパスする可能性があります。したがって引数の検証が重要です。
- PPLコード自体のバグ（例：算術オーバーフロー、境界チェックの欠如）はPPL内部での範囲外変更を許すことがあります。Project Zeroは `pmap_remove_options_internal()` のバグが彼らのバイパスで悪用されたと観察しました。
- PPL境界はハードウェア実装（APRR、メモリコントローラ）に不可逆的に結びついているため、ハードウェア実装の強度に依存します。

#### Example
<details>
<summary>例</summary>
以下は、カーネルが保護ページを変更するためにPPLを呼び出す際の簡略化した擬似コード／ロジックの例です：
</details>
```c
// In kernel (outside PPL domain)
function kernel_modify_pptable(pt_addr, new_entry) {
// validate arguments, etc.
return ppl_call_modify(pt_addr, new_entry)  // call PPL wrapper
}

// In PPL (trusted domain)
function ppl_call_modify(pt_addr, new_entry) {
// temporarily enable write access to protected pages (via APRR adjustments)
aprr_set_index_for_write(PPL_INDEX)
// perform the modification
*pt_addr = new_entry
// restore permissions (make pages read-only again)
aprr_restore_default()
return success
}

// If kernel code outside PPL does:
*pt_addr = new_entry  // a direct write
// It will fault because APRR mapping for non-PPL domain disallows write to that page
```
<details>
<summary>例</summary>
カーネルは多くの通常の操作を行えますが、保護されたマッピングを変更したりコードをパッチしたりできるのは、`ppl_call_*` ルーチンを通じてのみです。
</details>

<details>
<summary>例</summary>
カーネルエクスプロイトは entitlement テーブルを上書きしようとしたり、カーネル署名 blob を改変して code-sign の検証を無効化しようとします。そのページが PPL によって保護されているため、PPL インターフェイスを通らない書き込みはブロックされます。したがって、カーネルコード実行が得られても、code-sign の制約を回避したり、認証情報データを任意に変更したりすることはできません。
iOS 17+ では、特定のデバイスが SPTM を使用して PPL 管理ページをさらに分離する場合があります。
</details>

#### PPL → SPTM / 置換 / 今後

- On Apple’s modern SoCs (A15 or later, M2 or later), Apple supports **SPTM** (Secure Page Table Monitor), which **replaces PPL** for page table protections.
- Apple calls out in documentation: “Page Protection Layer (PPL) and Secure Page Table Monitor (SPTM) enforce execution of signed and trusted code … PPL manages the page table permission overrides … Secure Page Table Monitor replaces PPL on supported platforms.”
- The SPTM architecture likely shifts more policy enforcement into a higher-privileged monitor outside kernel control, further reducing the trust boundary.

### MTE | EMTE | MIE

以下は、Apple の MIE 環境下で EMTE がどのように動作するかの上位レベルの説明です:

1. **タグ割り当て**
- メモリが割り当てられると（例: カーネルやユーザ空間でセキュアなアロケータを介して）、そのブロックに **秘密タグ** が割り当てられます。
- ユーザまたはカーネルに返されるポインタは、そのタグを上位ビットに含みます（TBI / top byte ignore mechanisms を使用）。

2. **アクセス時のタグチェック**
- ポインタを使ってロードやストアが実行されるたびに、ハードウェアはポインタのタグがメモリブロックのタグ（割り当てタグ）と一致するかを確認します。不一致の場合は即座にフォルトします（同期的であるため）。
- 同期的であるため、「遅延検出」の猶予はありません。

3. **解放 / 再利用時のリタグ付け**
- メモリが解放されると、アロケータはブロックのタグを変更します（古いタグを持つ以前のポインタは一致しなくなります）。
- したがって、use-after-free のポインタは古いタグを持ち、アクセス時に不一致になります。

4. **オーバーフロー検出のための隣接タグ差別化**
- 隣接する割り当てには異なるタグが付与されます。バッファオーバーフローが隣接領域にまで及ぶと、タグ不一致によりフォルトが発生します。
- これは境界を越える小さなオーバーフローの検出に特に効果的です。

5. **タグ機密性の強制**
- Apple はタグ値が leaked されるのを防ぐ必要があります（攻撃者がタグを知ると正しいタグを持つポインタを作成できるため）。
- タグビットのサイドチャネル leakage を回避するために、マイクロアーキテクチャ的・投機的制御などの保護が含まれます。

6. **カーネルとユーザ空間の統合**
- Apple は EMTE をユーザ空間だけでなく、カーネル / OS の重要コンポーネントにも使用しており（カーネルをメモリ破損から保護するため）、ハードウェア/OS はユーザ空間のためにカーネルが実行されている場合でもタグルールが適用されることを保証します。

<details>
<summary>例</summary>
</details>
```
Allocate A = 0x1000, assign tag T1
Allocate B = 0x2000, assign tag T2

// pointer P points into A with tag T1
P = (T1 << 56) | 0x1000

// Valid store
*(P + offset) = value // tag T1 matches allocation → allowed

// Overflow attempt: P’ = P + size_of_A (into B region)
*(P' + delta) = value
→ pointer includes tag T1 but memory block has tag T2 → mismatch → fault

// Free A, allocator retags it to T3
free(A)

// Use-after-free:
*(P) = value
→ pointer still has old tag T1, memory region is now T3 → mismatch → fault
```
</details>

#### Limitations & challenges

- **Intrablock overflows**: オーバーフローが同じ割り当て内に留まり（境界を越えない）、tag が同じままの場合、tag mismatch は検出しない。
- **Tag width limitation**: タグに使えるビット数は限られている（例: 4 bits や小さなドメイン）—名前空間が限定される。
- **Side-channel leaks**: タグビットが cache / speculative execution 経由で leak され得る場合、攻撃者は有効なタグを学習して回避する可能性がある。Apple の tag confidentiality enforcement はこれを緩和することを目的としている。
- **Performance overhead**: 各 load/store ごとに tag チェックが入るためコストが増える；Apple はハードウェア最適化でオーバーヘッドを低く抑える必要がある。
- **Compatibility & fallback**: 旧ハードウェアや EMTE をサポートしない部分ではフォールバックが必要。Apple は MIE をサポートのあるデバイスでのみ有効にしていると主張している。
- **Complex allocator logic**: アロケータはタグ管理、retagging、境界整列、mis-tag collision の回避を扱う必要がある。アロケータロジックのバグは脆弱性を生む可能性がある。
- **Mixed memory / hybrid areas**: 一部のメモリは未タグ（レガシー）のまま残る可能性があり、相互運用性が複雑になる。
- **Speculative / transient attacks**: 多くのマイクロアーキテクチャ防御と同様に、speculative execution や micro-op fusion によって一時的にチェックを回避したりタグビットを leak する可能性がある。
- **Limited to supported regions**: Apple は EMTE をカーネルやセキュリティ重要領域など選択的な高リスク領域でのみ強制する可能性があり、全域での適用は保証されない。



---

## Key enhancements / differences compared to standard MTE

Here are the improvements and changes Apple emphasizes:

| Feature | Original MTE | EMTE (Apple’s enhanced) / MIE |
|---|---|---|
| **Check mode** | Supports synchronous and asynchronous modes. In async, tag mismatches are reported later (delayed)| Apple insists on **synchronous mode** by default—tag mismatches are caught immediately, no delay/race windows allowed.|
| **Coverage of non-tagged memory** | Accesses to non-tagged memory (e.g. globals) may bypass checks in some implementations | EMTE requires that accesses from a tagged region to non-tagged memory also validate tag knowledge, making it harder to bypass by mixing allocations.|
| **Tag confidentiality / secrecy** | Tags might be observable or leaked via side channels | Apple adds **Tag Confidentiality Enforcement**, which attempts to prevent leakage of tag values (via speculative side-channels etc.).|
| **Allocator integration & retagging** | MTE leaves much of allocator logic to software | Apple’s secure typed allocators (kalloc_type, xzone malloc, etc.) integrate with EMTE: when memory is allocated or freed, tags are managed at fine granularity.|
| **Always-on by default** | In many platforms, MTE is optional or off by default | Apple enables EMTE / MIE by default on supported hardware (e.g. iPhone 17 / A19) for kernel and many user processes.|

Apple がハードウェアとソフトウェアスタックの両方を制御しているため、EMTE を厳密に適用し、パフォーマンス問題を回避し、side-channel の穴を塞ぐことができる。

---

## How EMTE works in practice (Apple / MIE)

Here’s a higher-level description of how EMTE operates under Apple’s MIE setup:

1. **Tag assignment**
- メモリが割り当てられたとき（カーネルや secure allocators を通じてのユーザ空間等）、そのブロックに対して **secret tag** が割り当てられる。
- 返されるポインタは高位ビットにそのタグを含む（TBI / top byte ignore 機構を使用）。

2. **Tag checking on access**
- ポインタを使って load/store が実行されるとき、ハードウェアはポインタのタグがメモリブロックのタグ（allocation tag）と一致するかをチェックする。一致しなければ即座にフォルトする（synchronous のため）。
- synchronous なので「検出遅延」のウィンドウは存在しない。

3. **Retagging on free / reuse**
- メモリが free されると、アロケータはそのブロックのタグを変更する（古いタグを持つポインタはもう一致しない）。
- したがって use-after-free ポインタは古いタグを保持しており、アクセス時に mismatch になる。

4. **Neighbor-tag differentiation to catch overflows**
- 隣接する割り当てには異なるタグが付与される。バッファオーバーフローが隣のメモリに溢れるとタグ mismatch によりフォルトする。
- これは境界を越える小さなオーバーフローを検出するのに特に有効。

5. **Tag confidentiality enforcement**
- 攻撃者がタグ値を学習すると正しいタグでポインタを作成できるため、Apple はタグ値の leak を防ぐ必要がある。
- そのためタグビットを side-channel 経由で漏らさないようにする保護（microarchitectural / speculative controls 等）を含めている。

6. **Kernel and user-space integration**
- Apple は EMTE をユーザ空間だけでなくカーネル / OS の重要コンポーネントにも適用している（カーネルのメモリ破壊保護のため）。
- ハード/OS は kernel 実行時にもタグルールを適用することを保証する。

EMTE は MIE に組み込まれているため、Apple は主要な攻撃面で同期モードの EMTE をデフォルトで利用しており、デバッグモードやオプトイン扱いにしていない。

---

## Exception handling in XNU

When an **exception** occurs (e.g., `EXC_BAD_ACCESS`, `EXC_BAD_INSTRUCTION`, `EXC_CRASH`, `EXC_ARM_PAC`, etc.), the **Mach layer** of the XNU kernel is responsible for intercepting it before it becomes a UNIX-style **signal** (like `SIGSEGV`, `SIGBUS`, `SIGILL`, ...).

This process involves multiple layers of exception propagation and handling before reaching user space or being converted to a BSD signal.


### Exception Flow (High-Level)

1.  **CPU triggers a synchronous exception** (e.g., invalid pointer dereference, PAC failure, illegal instruction, etc.).

2.  **Low-level trap handler** runs (`trap.c`, `exception.c` in XNU source).

3.  The trap handler calls **`exception_triage()`**, the core of the Mach exception handling.

4.  `exception_triage()` decides how to route the exception:

-   First to the **thread's exception port**.

-   Then to the **task's exception port**.

-   Then to the **host's exception port** (often `launchd` or `ReportCrash`).

If none of these ports handle the exception, the kernel may:

-   **Convert it into a BSD signal** (for user-space processes).

-   **Panic** (for kernel-space exceptions).


### Core Function: `exception_triage()`

The function `exception_triage()` routes Mach exceptions up the chain of possible handlers until one handles it or until it's finally fatal. It's defined in `osfmk/kern/exception.c`.
```c
void exception_triage(exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt);
```
**典型的な呼び出しフロー:**

`exception_triage()
└── exception_deliver()
├── exception_deliver_thread()
├── exception_deliver_task()
└── exception_deliver_host()`

すべて失敗した場合 → `bsd_exception()` によって処理され → `SIGSEGV` のようなシグナルに変換される。


### Exception Ports

各 Mach オブジェクト（thread、task、host）は、例外メッセージが送信される **exception ports** を登録できる。

それらは API によって定義される:
```
task_set_exception_ports()
thread_set_exception_ports()
host_set_exception_ports()
```
各例外ポートは次を持つ：

-   A **mask**（どの例外を受け取りたいか）
-   A **port name**（Mach ポート：メッセージを受け取る先）
-   A **behavior**（カーネルがメッセージをどう送るか）
-   A **flavor**（どの thread state を含めるか）


### デバッガと例外処理

A **debugger**（例: LLDB）はターゲットの task や thread に **exception port** を設定し、通常は `task_set_exception_ports()` を使う。

**例外が発生したとき：**

-   Mach メッセージがデバッガプロセスに送られる。
-   デバッガは例外を **handle**（再開、レジスタ修正、命令のスキップなど）するか、**not handle** するかを決められる。
-   デバッガが処理しない場合、例外は次のレベルに伝播する（task → host）。


### Flow of `EXC_BAD_ACCESS`

1.  スレッドが無効なポインタをデリファレンス → CPU が Data Abort を発生。

2.  カーネルの trap handler が `exception_triage(EXC_BAD_ACCESS, ...)` を呼ぶ。

3.  メッセージは次の順で送られる：

-   Thread port → （デバッガがブレークポイントを傍受できる）。

-   デバッガが無視すると → Task port → （プロセスレベルのハンドラ）。

-   さらに無視されると → Host port（通常は ReportCrash）。

4.  誰も処理しなければ → `bsd_exception()` が `SIGSEGV` に変換する。


### PAC Exceptions

**Pointer Authentication**（PAC）が失敗（署名不一致）した場合、**特別な Mach 例外**が発生する：

-   **`EXC_ARM_PAC`**（タイプ）
-   コードには詳細が含まれることがある（例: キー種別、ポインタ種別）。

バイナリにフラグ **`TFRO_PAC_EXC_FATAL`** が付いている場合、カーネルは PAC の失敗を **fatal** として扱い、デバッガによる傍受をバイパスする。これは攻撃者がデバッガを使って PAC チェックを回避するのを防ぐためで、**platform binaries** に対して有効になる。


### Software Breakpoints

ソフトウェアブレークポイント（x86 の `int3`、ARM64 の `brk`）は **意図的なフォルトを発生させる** ことで実装される。\
デバッガは例外 port 経由でこれを捕捉する：

-   命令ポインタやメモリを修正する。
-   元の命令を復元する。
-   実行を再開する。

この同じ仕組みで PAC 例外を「キャッチ」することができる --- **ただし `TFRO_PAC_EXC_FATAL` が設定されている場合は例外はデバッガに届かない**。


### Conversion to BSD Signals

誰も例外を受け取らない場合：

-   カーネルは `task_exception_notify() → bsd_exception()` を呼ぶ。

-   これが Mach 例外をシグナルにマップする：

| Mach Exception | Signal |
| --- | --- |
| EXC_BAD_ACCESS | SIGSEGV or SIGBUS |
| EXC_BAD_INSTRUCTION | SIGILL |
| EXC_ARITHMETIC | SIGFPE |
| EXC_SOFTWARE | SIGTRAP |
| EXC_BREAKPOINT | SIGTRAP |
| EXC_CRASH | SIGKILL |
| EXC_ARM_PAC | SIGILL (on non-fatal) |


### Key Files in XNU Source

-   `osfmk/kern/exception.c` → `exception_triage()`、`exception_deliver_*()` のコア部分。

-   `bsd/kern/kern_sig.c` → シグナル配送ロジック。

-   `osfmk/arm64/trap.c` → 低レベルの trap ハンドラ。

-   `osfmk/mach/exc.h` → 例外コードと構造体。

-   `osfmk/kern/task.c` → タスク例外ポートのセットアップ。

---

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

カーネルは固定サイズの「zone」に分かれた **zone allocator**（`kalloc`）を使用していた。各 zone は単一のサイズクラスの割り当てのみを保持する。

スクリーンショットから：

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | 非常に小さいカーネル構造体、ポインタ。                                        |
| `default.kalloc.32`  | 32 bytes     | 小さな構造体、オブジェクトヘッダ。                                              |
| `default.kalloc.64`  | 64 bytes     | IPC メッセージ、極小のカーネルバッファ。                                          |
| `default.kalloc.128` | 128 bytes    | `OSObject` の一部など中程度のオブジェクト。                                    |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | 大きな構造体、IOSurface / グラフィックスのメタデータ。                              |

どう動いていたか：
- 各割り当て要求は最寄りの zone サイズに **切り上げられる**。
（例：50 バイトの要求は `kalloc.64` zone に入る）。
- 各 zone のメモリは **freelist** に保持されていた — カーネルで解放されたチャンクはその zone に戻った。
- もし 64 バイトバッファをオーバーフローさせると、同じ zone 内の **次のオブジェクトを上書き**してしまう。

これが **heap spraying / feng shui** が非常に効果的だった理由：同じサイズクラスの割り当てをスプレーすることでオブジェクトの隣接関係を予測できた。


### The freelist

各 kalloc zone 内では、解放されたオブジェクトは直接システムに返されず — freelist、つまり利用可能チャンクの連結リストに入った。

- チャンクが解放されると、カーネルはそのチャンクの先頭にポインタを書き込む → 同じ zone 内の次の free チャンクのアドレス。

- zone は最初の free チャンクを指す HEAD ポインタを保持する。

- 割り当ては常に現在の HEAD を使用：

1. HEAD を pop（そのメモリを呼び出し元に返す）。

2. HEAD = HEAD->next に更新（解放チャンクのヘッダに格納されている）。

- 解放はチャンクを戻す：

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

つまり freelist は解放されたメモリ自身の中に構築された単なる連結リストだった。

Normal state:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### freelist の悪用

free chunk の最初の8バイトが freelist pointer に等しいため、攻撃者はそれを改ざんできます:

1. **Heap overflow** により隣接する freed chunk に侵入し、”next” pointer を上書きする。
2. **Use-after-free** により freed object に書き込みを行い、”next” pointer を上書きする。

次に、そのサイズの次の割り当て時に:

- allocator が改ざんされたチャンクを取り出す。
- 攻撃者が指定した “next” pointer に従う。
- 任意のメモリへのポインタを返し、fake object primitives や targeted overwrite を可能にする。

Visual example of freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
This freelist design made exploitation highly effective pre-hardening: predictable neighbors from heap sprays, raw pointer freelist links, and no type separation allowed attackers to escalate UAF/overflow bugs into arbitrary kernel memory control.
この freelist の設計はハードニング前は非常に効果的なエクスプロイトを可能にしていました：heap sprays による隣接の予測可能性、生のポインタ freelist リンク、タイプ分離がないことにより、攻撃者は UAF/overflow バグを任意のカーネルメモリ制御へとエスカレートできました。

### Heap Grooming / Feng Shui
The goal of heap grooming is to **shape the heap layout** so that when an attacker triggers an overflow or use-after-free, the target (victim) object sits right next to an attacker-controlled object.\
That way, when memory corruption happens, the attacker can reliably overwrite the victim object with controlled data.
Heap Grooming / Feng Shui
heap grooming の目的はヒープのレイアウトを「整形」して、攻撃者が overflow や use-after-free を引き起こしたときに標的（victim）オブジェクトが攻撃者制御のオブジェクトのすぐ隣に来るようにすることです。これによりメモリ破壊が起きた場合、攻撃者は決定的に victim オブジェクトを書き換えることができます。

**Steps:**
手順:

1. Spray allocations (fill the holes)
- Over time, the kernel heap gets fragmented: some zones have holes where old
objects were freed.
- The attacker first makes lots of dummy allocations to fill these gaps, so
the heap becomes “packed” and predictable.
1. Spray allocations (fill the holes)
- 時間とともにカーネルヒープは断片化します：古いオブジェクトが free された場所に穴（holes）ができます。
- 攻撃者はまず大量のダミー割当を行いこれらのギャップを埋め、ヒープを「詰める（packed）」ことで予測可能にします。

2. Force new pages
- Once the holes are filled, the next allocations must come from new pages
added to the zone.
- Fresh pages mean objects will be clustered together, not scattered across
old fragmented memory.
- This gives the attacker much better control of neighbors.
2. Force new pages
- 穴が埋まると、次の割当はそのゾーンに追加された新しいページから行われます。
- 新しいページではオブジェクトがクラスタ化され、古い断片化メモリに散らばることがなくなります。
- これにより攻撃者は隣接の配置をより正確に制御できます。

3. Place attacker objects
- The attacker now sprays again, creating lots of attacker-controlled objects
in those new pages.
- These objects are predictable in size and placement (since they all belong
to the same zone).
3. Place attacker objects
- 攻撃者は再度 spray を行い、その新しいページ上に多数の攻撃者制御オブジェクトを作成します。
- これらのオブジェクトは同じゾーンに属するため、サイズや配置が予測可能です。

4. Free a controlled object (make a gap)
- The attacker deliberately frees one of their own objects.
- This creates a “hole” in the heap, which the allocator will later reuse for
the next allocation of that size.
4. Free a controlled object (make a gap)
- 攻撃者は意図的に自分のオブジェクトの1つを free します。
- これによりヒープに「穴」ができ、そのサイズの次の割当時にアロケータが再利用します。

5. Victim object lands in the hole
- The attacker triggers the kernel to allocate the victim object (the one
they want to corrupt).
- Since the hole is the first available slot in the freelist, the victim is
placed exactly where the attacker freed their object.
5. Victim object lands in the hole
- 攻撃者はカーネルに対して victim オブジェクトを割り当てさせます（破壊したいもの）。
- その穴が freelist 上で最初に使えるスロットであるため、victim は攻撃者が free した場所に正確に配置されます。

6. Overflow / UAF into victim
- Now the attacker has attacker-controlled objects around the victim.
- By overflowing from one of their own objects (or reusing a freed one), they
can reliably overwrite the victim’s memory fields with chosen values.
6. Overflow / UAF into victim
- こうして攻撃者制御オブジェクトが victim の周辺に存在する状態になります。
- 自分のオブジェクトからの overflow（または再利用した freed オブジェクト）によって、攻撃者は victim のメモリフィールドを確実に任意の値で上書きできます。

**Why it works**:
なぜこれが有効か:

- Zone allocator predictability: allocations of the same size always come from
the same zone.
- Freelist behavior: new allocations reuse the most recently freed chunk first.
- Heap sprays: attacker fills memory with predictable content and controls layout.
- End result: attacker controls where the victim object lands and what data sits
next to it.
- ゾーンアロケータの予測可能性：同じサイズの割当は常に同じゾーンから行われる。
- Freelist の振る舞い：新しい割当は直近に free されたチャンクを優先的に再利用する。
- Heap sprays：攻撃者は予測可能な内容でメモリを埋め、レイアウトを制御する。
- 結果として攻撃者は victim の配置位置と隣接するデータを制御できる。

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)
Apple hardened the allocator and made **heap grooming much harder**:
現代のカーネルヒープ（iOS 15+/A12+ SoCs）
Apple はアロケータを強化し、**heap grooming を非常に困難にしました**。

### 1. From Classic kalloc to kalloc_type
- **Before**: a single `kalloc.<size>` zone existed for each size class (16, 32, 64, … 1280, etc.). Any object of that size was placed there → attacker objects could sit next to privileged kernel objects.
- **Now**:
- Kernel objects are allocated from **typed zones** (`kalloc_type`).
- Each type of object (e.g., `ipc_port_t`, `task_t`, `OSString`, `OSData`) has its own dedicated zone, even if they’re the same size.
- The mapping between object type ↔ zone is generated from the **kalloc_type system** at compile time.
1. From Classic kalloc to kalloc_type
- 以前：各サイズクラス（16, 32, 64, … 1280 等）に対して単一の `kalloc.<size>` ゾーンが存在しました。同じサイズの任意のオブジェクトがそこに配置され、攻撃者オブジェクトが特権カーネルオブジェクトの隣に並ぶ可能性がありました。
- 現在：
- カーネルオブジェクトは **typed zones**（`kalloc_type`）から割り当てられます。
- 各オブジェクトタイプ（例：`ipc_port_t`, `task_t`, `OSString`, `OSData`）はたとえ同じサイズでも専用のゾーンを持ちます。
- オブジェクトタイプ ↔ ゾーンの対応はコンパイル時に **kalloc_type system** から生成されます。

An attacker can no longer guarantee that controlled data (`OSData`) ends up adjacent to sensitive kernel objects (`task_t`) of the same size.
攻撃者はもはや制御されたデータ（`OSData`）が同サイズの機密カーネルオブジェクト（`task_t`）の隣に来ることを保証できません。

### 2. Slabs and Per-CPU Caches
- The heap is divided into **slabs** (pages of memory carved into fixed-size chunks for that zone).
- Each zone has a **per-CPU cache** to reduce contention.
- Allocation path:
1. Try per-CPU cache.
2. If empty, pull from the global freelist.
3. If freelist is empty, allocate a new slab (one or more pages).
- **Benefit**: This decentralization makes heap sprays less deterministic, since allocations may be satisfied from different CPUs’ caches.
2. Slabs and Per-CPU Caches
- ヒープは **slabs** に分割されます（そのゾーン用に固定サイズのチャンクに分けられたページ）。
- 各ゾーンは競合を減らすために **per-CPU cache** を持ちます。
- 割当パス:
1. per-CPU cache を試す。
2. 空なら global freelist から取得。
3. freelist が空なら新しい slab（1ページ以上）を割当。
- 利点：この分散化により割当は異なる CPU のキャッシュから満たされる可能性があり、heap sprays の決定性が低下します。

### 3. Randomization inside zones
- Within a zone, freed elements are not handed back in simple FIFO/LIFO order.
- Modern XNU uses **encoded freelist pointers** (safe-linking like Linux, introduced ~iOS 14).
- Each freelist pointer is **XOR-encoded** with a per-zone secret cookie.
- This prevents attackers from forging a fake freelist pointer if they gain a write primitive.
- Some allocations are **randomized in their placement within a slab**, so spraying doesn’t guarantee adjacency.
3. Randomization inside zones
- ゾーン内では、free された要素は単純な FIFO/LIFO の順序で返されません。
- 最新の XNU は **encoded freelist pointers**（Linux の safe-linking に似た手法、~iOS 14 で導入）を使用しています。
- 各 freelist ポインタはゾーンごとの秘密 cookie で **XOR エンコード**されています。
- これにより write プリミティブを手に入れても攻撃者が偽の freelist ポインタを作ることを防ぎます。
- 一部の割当は **slab 内での配置がランダム化**されるため、spray しても隣接が保証されません。

### 4. Guarded Allocations
- Certain critical kernel objects (e.g., credentials, task structures) are allocated in **guarded zones**.
- These zones insert **guard pages** (unmapped memory) between slabs or use **redzones** around objects.
- Any overflow into the guard page triggers a fault → immediate panic instead of silent corruption.
4. Guarded Allocations
- 一部の重要なカーネルオブジェクト（例：credentials、task 構造体）は **guarded zones** で割り当てられます。
- これらのゾーンは slab 間に **guard pages**（未マップのメモリ）を挿入したり、オブジェクトの周囲に **redzones** を用いたりします。
- guard page への overflow はフォルトを引き起こし、静かな破壊ではなく即時パニックを招きます。

### 5. Page Protection Layer (PPL) and SPTM
- Even if you control a freed object, you can’t modify all of kernel memory:
- **PPL (Page Protection Layer)** enforces that certain regions (e.g., code signing data, entitlements) are **read-only** even to the kernel itself.
- On **A15/M2+ devices**, this role is replaced/enhanced by **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- These hardware-enforced layers mean attackers can’t escalate from a single heap corruption to arbitrary patching of critical security structures.
- **(Added / Enhanced)**: also, **PAC (Pointer Authentication Codes)** is used in the kernel to protect pointers (especially function pointers, vtables) so that forging or corrupting them becomes harder.
- **(Added / Enhanced)**: zones may enforce **zone_require / zone enforcement**, i.e. that an object freed can only be returned through its correct typed zone; invalid cross-zone frees may panic or be rejected. (Apple alludes to this in their memory safety posts)
5. Page Protection Layer (PPL) and SPTM
- freed オブジェクトを制御できても、カーネルメモリ全体を改変できるわけではありません。
- **PPL (Page Protection Layer)** は特定領域（例：コード署名データ、entitlements）をカーネル自身であっても **read-only** に強制します。
- **A15/M2+ デバイス**では、この役割が **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)** によって置き換え/強化されています。
- これらのハードウェア強制レイヤにより、単一のヒープ破壊から重要なセキュリティ構造の任意パッチ適用へエスカレートすることが困難になります。
- （追加/強化）: カーネルでは **PAC (Pointer Authentication Codes)** がポインタ（特に関数ポインタや vtables）保護に使われ、偽造や破壊が困難になります。
- （追加/強化）: ゾーンは **zone_require / zone enforcement** を強制する可能性があり、つまり free されたオブジェクトは正しい typed zone を通じてしか戻せない等、無効なクロスゾーン free はパニックや拒否を招くかもしれません。（Apple のメモリ安全性に関する投稿がこれに言及しています）

### 6. Large Allocations
- Not all allocations go through `kalloc_type`.
- Very large requests (above ~16 KB) bypass typed zones and are served directly from **kernel VM (kmem)** via page allocations.
- These are less predictable, but also less exploitable, since they don’t share slabs with other objects.
6. Large Allocations
- すべての割当が `kalloc_type` を通るわけではありません。
- 非常に大きな要求（およそ 16 KB 以上）は typed zones をバイパスし、ページ割当経由で **kernel VM (kmem)** から直接供給されます。
- これらは予測しにくいですが、他のオブジェクトと slab を共有しないため利用可能性は低くなります（exploitable 性は低い）。

### 7. Allocation Patterns Attackers Target
Even with these protections, attackers still look for:
- **Reference count objects**: if you can tamper with retain/release counters, you may cause use-after-free.
- **Objects with function pointers (vtables)**: corrupting one still yields control flow.
- **Shared memory objects (IOSurface, Mach ports)**: these are still attack targets because they bridge user ↔ kernel.

But — unlike before — you can’t just spray `OSData` and expect it to neighbor a `task_t`. You need **type-specific bugs** or **info leaks** to succeed.
7. 攻撃者が狙う割当パターン
これらの防御があっても、攻撃者は依然として以下を探します：
- **Reference count objects**：retain/release カウンタを改竄できれば use-after-free を引き起こせる可能性がある。
- **Objects with function pointers (vtables)**：これらを破壊すれば制御フローの取得につながる。
- **Shared memory objects (IOSurface, Mach ports)**：user ↔ kernel を橋渡しするため依然として狙われる。
しかし以前と違い、単に `OSData` を spray して `task_t` の隣に配置されるのを期待することはできません。成功には **type-specific bugs** や **info leaks** が必要です。

### Example: Allocation Flow in Modern Heap
Suppose userspace calls into IOKit to allocate an `OSData` object:

1. **Type lookup** → `OSData` maps to `kalloc_type_osdata` zone (size 64 bytes).
2. Check per-CPU cache for free elements.
- If found → return one.
- If empty → go to global freelist.
- If freelist empty → allocate a new slab (page of 4KB → 64 chunks of 64 bytes).
3. Return chunk to caller.

**Freelist pointer protection**:
- Each freed chunk stores the address of the next free chunk, but encoded with a secret key.
- Overwriting that field with attacker data won’t work unless you know the key.
例：現代ヒープでの割当フロー
ユーザスペースが IOKit を通じて `OSData` オブジェクトを割り当てると仮定します：

1. **Type lookup** → `OSData` は `kalloc_type_osdata` ゾーン（サイズ 64 バイト）にマップされる。
2. per-CPU cache に空き要素があるか確認。
- 見つかれば → 返却。
- 空なら → global freelist へ。
- freelist が空なら → 新しい slab を割当（4KB ページ → 64 個の 64 バイトチャンク）。
3. チャンクを呼び出し元に返す。

**Freelist ポインタ保護**：
- 各 freed チャンクは次の free チャンクのアドレスを格納しますが、秘密鍵でエンコードされています。
- 攻撃者がそのフィールドを上書きしても、キーを知らなければ有効になりません。

---

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages, and **PAC** protects pointers |
| Allocation reuse validation     | None (freelist pointers raw)                               | **zone_require / zone enforcement**             |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |
| Large allocations handling      | All small allocations managed equally                       | Large ones bypass zones → handled via VM         |
比較表

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | 固定サイズバケット (`kalloc.16`, `kalloc.32` 等)           | サイズ + **タイプベースのバケット** (`kalloc_type`) |
| Placement predictability        | 高（同サイズのオブジェクトが隣接）                         | 低（同タイプでのグルーピング＋ランダム性）         |
| Freelist management             | freed チャンク内の生ポインタ（改竄が容易）                 | **エンコードされたポインタ**（safe-linking スタイル） |
| Adjacent object control         | sprays/frees による制御が容易（Feng Shui が有効）          | 難しい — typed zones が攻撃者オブジェクトを分離     |
| Kernel data/code protections    | ハードウェア保護は少ない                                   | **PPL / SPTM** がページテーブル & コードページを保護、**PAC** がポインタを保護 |
| Allocation reuse validation     | なし（freelist ポインタは生）                              | **zone_require / zone enforcement**              |
| Exploit reliability             | heap sprays で高い                                          | かなり低く、ロジックバグや info leaks が必要       |
| Large allocations handling      | 全ての小さい割当が同じように管理                            | 大きい割当はゾーンをバイパス → VM により処理       |

---

## Modern Userland Heap (iOS, macOS — type-aware / xzone malloc)
In recent Apple OS versions (especially iOS 17+), Apple introduced a more secure userland allocator, **xzone malloc** (XZM). This is the user-space analog to the kernel’s `kalloc_type`, applying type awareness, metadata isolation, and memory tagging safeguards.
現代のユーザーランドヒープ（iOS, macOS — type-aware / xzone malloc）
最近の Apple OS（特に iOS 17+）では、より安全なユーザーランドアロケータ **xzone malloc**（XZM）が導入されました。これはカーネルの `kalloc_type` のユーザ空間版に相当し、タイプ認識、メタデータの分離、メモリタグ付けによる保護を適用します。

### Goals & Design Principles
- **Type segregation / type awareness**: group allocations by *type or usage (pointer vs data)* to prevent type confusion and cross-type reuse.
- **Metadata isolation**: separate heap metadata (e.g. free lists, size/state bits) from object payloads so that out-of-bounds writes are less likely to corrupt metadata.
- **Guard pages / redzones**: insert unmapped pages or padding around allocations to catch overflows.
- **Memory tagging (EMTE / MIE)**: work in conjunction with hardware tagging to detect use-after-free, out-of-bounds, and invalid accesses.
- **Scalable performance**: maintain low overhead, avoid excessive fragmentation, and support many allocations per second with low latency.
目標と設計原則

- **Type segregation / type awareness**：タイプや用途（ポインタかデータか）ごとに割当をグループ化し、タイプ混同やクロスタイプ再利用を防ぐ。
- **Metadata isolation**：ヒープのメタデータ（例：free list、サイズ/状態ビット）をオブジェクトペイロードから分離し、OOB 書き込みでメタデータが壊れる可能性を低減する。
- **Guard pages / redzones**：割当の周囲に未マップページやパディングを挿入してオーバーフローを検出する。
- **Memory tagging (EMTE / MIE)**：ハードウェアのタグ付けと連携して use-after-free、OOB、不正アクセスを検出する。
- **Scalable performance**：低オーバーヘッドを維持し、過度の断片化を避け、低レイテンシで多数の割当をサポートする。

### Architecture & Components
Below are the main elements in the xzone allocator:
#### Segment Groups & Zones
- **Segment groups** partition the address space by usage categories: e.g. `data`, `pointer_xzones`, `data_large`, `pointer_large`.
- Each segment group contains **segments** (VM ranges) that host allocations for that category.
- Associated with each segment is a **metadata slab** (separate VM area) that stores metadata (e.g. free/used bits, size/classes) for that segment. This **out-of-line (OOL) metadata** ensures that metadata is not intermingled with object payloads, mitigating corruption from overflows.
- Segments are carved into **chunks** (slices) which in turn are subdivided into **blocks** (allocation units). A chunk is tied to a specific size class and segment group (i.e. all blocks in a chunk share the same size & category).
- For small / medium allocations, it will use fixed-size chunks; for large/huges, it may map separately.
アーキテクチャと構成要素
以下は xzone アロケータの主要要素です：

#### Segment Groups & Zones
- **Segment groups** はアドレス空間を用途カテゴリ（例：`data`, `pointer_xzones`, `data_large`, `pointer_large`）ごとに分割します。
- 各 segment group はそのカテゴリの割当をホストする **segments**（VM 範囲）を含みます。
- 各 segment にはその segment 用のメタデータ（free/used ビット、サイズクラス等）を格納する **metadata slab**（別個の VM 領域）が関連付けられています。この **out-of-line (OOL) metadata** によりメタデータがオブジェクトペイロードと混在せず、オーバーフローによる破壊を緩和します。
- Segments は **chunks**（スライス）に分割され、さらに **blocks**（割当単位）に細分されます。チャンクは特定のサイズクラスと segment group に紐づきます（チャンク内の全 block は同じサイズとカテゴリを共有）。
- 小中サイズの割当では固定サイズチャンクを用い、大きな割当は別途マップすることがあります。

#### Chunks & Blocks
- A **chunk** is a region (often several pages) dedicated to allocations of one size class within a group.
- Inside a chunk, **blocks** are slots available for allocations. Freed blocks are tracked via the metadata slab — e.g. via bitmaps or free lists stored out-of-line.
- Between chunks (or within), **guard slices / guard pages** may be inserted (e.g. unmapped slices) to catch out-of-bounds writes.
#### Chunks & Blocks
- **chunk** はグループ内のあるサイズクラスの割当に専用される領域（しばしば数ページ）です。
- チャンク内では **blocks** が割当用のスロットです。free されたブロックは metadata slab によりトラッキングされます（例：ビットマップや out-of-line に保存された free list）。
- チャンク間や内部に **guard slices / guard pages**（未マップスライス等）を挿入して OOB 書き込みを検出することがあります。

#### Type / Type ID
- Every allocation site (or call to malloc, calloc, etc.) is associated with a **type identifier** (a `malloc_type_id_t`) which encodes what kind of object is being allocated. That type ID is passed to the allocator, which uses it to select which zone / segment to serve the allocation.
- Because of this, even if two allocations have the same size, they may go into entirely different zones if their types differ.
- In early iOS 17 versions, not all APIs (e.g. CFAllocator) were fully type-aware; Apple addressed some of those weaknesses in iOS 18.
#### Type / Type ID
- 各割当サイト（malloc, calloc 等の呼び出し）は、どの種類のオブジェクトが割り当てられるかをエンコードする **type identifier**（`malloc_type_id_t`）に紐づけられます。その type ID がアロケータに渡され、どの zone / segment が割当を提供するかを選択します。
- これにより、同じサイズの割当でもタイプが異なれば全く異なるゾーンに入ることがあります。
- iOS 17 初期では全ての API（例：CFAllocator）が完全にタイプ対応していなかった部分があり、Apple は iOS 18 でいくつかの弱点に対処しました。

---

### Allocation & Freeing Workflow
Here is a high-level flow of how allocation and deallocation operate in xzone:

1. **malloc / calloc / realloc / typed alloc** is invoked with a size and type ID.
2. The allocator uses the **type ID** to pick the correct segment group / zone.
3. Within that zone/segment, it seeks a chunk that has free blocks of the requested size.
- It may consult **local caches / per-thread pools** or **free block lists** from metadata.
- If no free block is available, it may allocate a new chunk in that zone.
4. The metadata slab is updated (free bit cleared, bookkeeping).
5. If memory tagging (EMTE) is in play, the returned block gets a **tag** assigned, and metadata is updated to reflect its “live” state.
6. When `free()` is called:
- The block is marked as freed in metadata (via OOL slab).
- The block may be placed into a free list or pooled for reuse.
- Optionally, block contents may be cleared or poisoned to reduce data leaks or use-after-free exploitation.
- The hardware tag associated with the block may be invalidated or re-tagged.
- If an entire chunk becomes free (all blocks freed), the allocator may **reclaim** that chunk (unmap it or return to OS) under memory pressure.
割当と解放のワークフロー
xzone における割当と解放の高レベルな流れは以下の通りです：

1. サイズと type ID を指定して **malloc / calloc / realloc / typed alloc** が呼ばれる。
2. アロケータは **type ID** を使って適切な segment group / zone を選択する。
3. その zone/segment 内で要求サイズの空きブロックを持つチャンクを探す。
- **ローカルキャッシュ / per-thread pool** やメタデータの **free block lists** を参照することがある。
- 空きブロックがなければ、そのゾーンで新しいチャンクを割当する場合がある。
4. metadata slab が更新される（free ビットクリア、帳簿付け）。
5. メモリタグ付け（EMTE）が有効なら、返却されるブロックに **タグ** が割り当てられ、メタデータは “live” 状態を反映するよう更新される。
6. `free()` が呼ばれると:
- ブロックはメタデータ上で freed とマークされる（OOL slab 経由）。
- ブロックは free list に置かれるか再利用のためプールされる。
- 任意で、データ漏洩や use-after-free 利用を減らすためにブロック内容がクリアまたは poison されることがある。
- ブロックに対応するハードウェアタグが無効化または再タグ付けされる。
- チャンク全体が空になれば（全ブロックが freed）、アロケータはメモリプレッシャー下でそのチャンクを **reclaim**（unmap または OS に返す）することがある。

---

### Security Features & Hardening
These are the defenses built into modern userland xzone:

| Feature | Purpose | Notes |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | Prevent overflow from corrupting metadata | Metadata lives in separate VM region (metadata slab)|
| **Guard pages / unmapped slices** | Catch out-of-bounds writes | Helps detect buffer overflows rather than silently corrupting adjacent blocks|
| **Type-based segregation** | Prevent cross-type reuse & type confusion | Even same-size allocations from different types go to different zones|
| **Memory Tagging (EMTE / MIE)** | Detect invalid access, stale references, OOB, UAF | xzone works in concert with hardware EMTE in synchronous mode (“Memory Integrity Enforcement”)|
| **Delayed reuse / poisoning / zap** | Reduce chance of use-after-free exploitation | Freed blocks may be poisoned, zeroed, or quarantined before reuse |
| **Chunk reclamation / dynamic unmapping** | Reduce memory waste and fragmentation | Entire chunks may be unmapped when unused |
| **Randomization / placement variation** | Prevent deterministic adjacency | Blocks in a chunk and chunk selection may have randomized aspects |
| **Segregation of “data-only” allocations** | Separate allocations that don’t store pointers | Reduces attacker control over metadata or control fields|
セキュリティ機能とハードニング
以下は現代のユーザーランド xzone に組み込まれた防御策です：

| Feature | 目的 | 備考 |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | オーバーフローによるメタデータ破壊を防ぐ | メタデータは別 VM 領域（metadata slab）に存在 |
| **Guard pages / unmapped slices** | OOB 書き込みを検出する | 隣接ブロックを静かに破壊するのではなくバッファオーバーフローを検出するのに有用 |
| **Type-based segregation** | クロスタイプ再利用やタイプ混同を防ぐ | 同サイズでもタイプが異なれば別ゾーンに入る |
| **Memory Tagging (EMTE / MIE)** | 不正アクセス、古い参照、OOB、UAF を検出する | xzone はハードウェア EMTE の同期モード（“Memory Integrity Enforcement”）と連携 |
| **Delayed reuse / poisoning / zap** | use-after-free 利用の可能性を低減 | freed ブロックは再利用前に poison、zero、隔離されることがある |
| **Chunk reclamation / dynamic unmapping** | メモリ無駄や断片化を減らす | 未使用のチャンクはアンマップされる可能性がある |
| **Randomization / placement variation** | 決定的な隣接を防ぐ | チャンク内のブロックやチャンク選択にランダム性がある場合がある |
| **Segregation of “data-only” allocations** | ポインタを保持しない割当を分離する | メタデータや制御フィールドに対する攻撃者の制御を減らす |

---

### Interaction with Memory Integrity Enforcement (MIE / EMTE)
- Apple’s MIE (Memory Integrity Enforcement) is the hardware + OS framework that brings **Enhanced Memory Tagging Extension (EMTE)** into always-on, synchronous mode across major attack surfaces.
- xzone allocator is a fundamental foundation of MIE in user space: allocations done via xzone get tags, and accesses are checked by hardware.
- In MIE, the allocator, tag assignment, metadata management, and tag confidentiality enforcement are integrated to ensure that memory errors (e.g. stale reads, OOB, UAF) are caught immediately, not exploited later.
MIE / EMTE との相互作用
- Apple の MIE（Memory Integrity Enforcement）はハードウェア＋OS のフレームワークで、**Enhanced Memory Tagging Extension (EMTE)** を主要な攻撃面で常時オンかつ同期モードにします。
- xzone アロケータはユーザ空間における MIE の基盤であり、xzone 経由で行われた割当にはタグが付与され、アクセスはハードウェアによって検査されます。
- MIE では、アロケータ、タグ割当、メタデータ管理、タグの機密保持 enforcement が統合され、メモリエラー（古い読み出し、OOB、UAF 等）が即座に検出され、後で悪用されることを防ぎます。

---

If you like, I can also generate a cheat-sheet or diagram of xzone internals for your book. Do you want me to do that next?
必要であれば、xzone の内部に関するチートシートや図も作成できます。次にそれを作成しましょうか？
::contentReference[oai:20]{index=20}


---

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
