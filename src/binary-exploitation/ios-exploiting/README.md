# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

- **Code Signing** in iOS funziona richiedendo che ogni pezzo di codice eseguibile (apps, libraries, extensions, ecc.) sia firmato crittograficamente con un certificato rilasciato da Apple. Quando il codice viene caricato, iOS verifica la firma digitale rispetto alla root di fiducia di Apple. Se la firma è invalida, mancante o modificata, il sistema rifiuta di eseguirlo. Questo impedisce agli attacker di injectare codice malevolo in app legittime o eseguire binari non firmati, bloccando la maggior parte delle catene di exploit che si basano sull'esecuzione di codice arbitrario o manomesso.
- **CoreTrust** è il sottosistema iOS responsabile dell’enforcement della code signing a runtime. Verifica direttamente le firme usando il certificato root di Apple senza appoggiarsi a store di trust in cache, il che significa che possono eseguire solo binari firmati da Apple (o con entitlements validi). CoreTrust assicura che anche se un attacker manomette un'app dopo l'installazione, modifica librerie di sistema o tenta di caricare codice non firmato, il sistema bloccherà l'esecuzione a meno che il codice non sia ancora correttamente firmato. Questa applicazione rigorosa chiude molte vie post-exploitation che le versioni più vecchie di iOS permettevano tramite controlli di firma più deboli o bypassabili.
- **Data Execution Prevention (DEP)** marca regioni di memoria come non eseguibili a meno che non contengano esplicitamente codice. Questo impedisce agli attacker di injectare shellcode in regioni dati (come stack o heap) ed eseguirlo, costringendoli a usare tecniche più complesse come ROP.
- **ASLR (Address Space Layout Randomization)** randomizza gli indirizzi di memoria di codice, libraries, stack e heap a ogni esecuzione del sistema. Questo rende molto più difficile per gli attacker prevedere dove si trovino istruzioni o gadget utili, interrompendo molte catene di exploit che dipendono da layout di memoria fissi.
- **KASLR (Kernel ASLR)** applica lo stesso concetto di randomizzazione al kernel di iOS. Mescolando l'indirizzo base del kernel ad ogni boot, impedisce agli attacker di localizzare in modo affidabile funzioni o strutture del kernel, aumentando la difficoltà di exploit a livello kernel che altrimenti guadagnerebbero il controllo completo del sistema.
- **Kernel Patch Protection (KPP)**, noto anche come **AMCC (Apple Mobile File Integrity)** in iOS, monitora continuamente le pagine di codice del kernel per assicurarsi che non siano state modificate. Se viene rilevata una manomissione—come un exploit che tenta di patchare funzioni del kernel o inserire codice malevolo—il dispositivo andrà immediatamente in panic e si riavvierà. Questa protezione rende molto più difficili gli exploit kernel persistenti, poiché gli attacker non possono semplicemente hookare o patchare istruzioni del kernel senza provocare un crash di sistema.
- **Kernel Text Readonly Region (KTRR)** è una feature di sicurezza basata su hardware introdotta sui dispositivi iOS. Usa il memory controller della CPU per marcare la sezione di codice (text) del kernel come permanentemente read-only dopo il boot. Una volta bloccata, anche il kernel stesso non può modificare quella regione di memoria. Questo impedisce agli attacker—e persino al codice privilegiato—from patchare istruzioni del kernel a runtime, chiudendo una grande classe di exploit che si basavano sulla modifica diretta del codice del kernel.
- **Pointer Authentication Codes (PAC)** usa firme crittografiche incorporate nei bit inutilizzati dei pointer per verificarne l'integrità prima dell'uso. Quando un pointer (come un return address o function pointer) viene creato, la CPU lo firma con una chiave segreta; prima di dereferenziare, la CPU verifica la firma. Se il pointer è stato manomesso, il controllo fallisce e l'esecuzione si ferma. Questo impedisce agli attacker di forgiare o riusare pointer corrotti in exploit di memory corruption, rendendo tecniche come ROP o JOP molto più difficili da eseguire in modo affidabile.
- **Privilege Access never (PAN)** è una feature hardware che impedisce al kernel (modalità privilegiata) di accedere direttamente alla memoria user-space a meno che non abiliti esplicitamente l'accesso. Questo blocca gli attacker che hanno ottenuto esecuzione di codice nel kernel dal leggere o scrivere facilmente la memoria user per escalation di privilegi o furto di dati sensibili. Imponendo una netta separazione, PAN riduce l'impatto degli exploit kernel e blocca molte tecniche comuni di escalation di privilegi.
- **Page Protection Layer (PPL)** è un meccanismo di sicurezza di iOS che protegge regioni critiche di memoria gestite dal kernel, specialmente quelle relative a code signing e entitlements. Applica protezioni di scrittura stringenti usando la MMU (Memory Management Unit) e controlli aggiuntivi, assicurando che anche il codice kernel privilegiato non possa modificare arbitrariamente pagine sensibili. Questo impedisce agli attacker che ottengono esecuzione a livello kernel di manomettere strutture critiche per la sicurezza, rendendo persistence e bypass della code-signing significativamente più difficili.

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

Il kernel usava un **zone allocator** (`kalloc`) diviso in "zone" di dimensione fissa.
Ogni zona memorizzava solo allocazioni di una singola size class.

From the screenshot:

| Nome Zona            | Dimensione Elemento | Esempio d'uso                                                               |
|----------------------|---------------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes            | Strutture kernel molto piccole, pointer.                                    |
| `default.kalloc.32`  | 32 bytes            | Piccole strutture, object headers.                                          |
| `default.kalloc.64`  | 64 bytes            | IPC messages, tiny kernel buffers.                                          |
| `default.kalloc.128` | 128 bytes           | Oggetti medi come parti di `OSObject`.                                      |
| `default.kalloc.256` | 256 bytes           | IPC messages più grandi, array, strutture device.                           |
| …                    | …                   | …                                                                           |
| `default.kalloc.1280`| 1280 bytes          | Strutture grandi, IOSurface/graphics metadata.                              |

Come funzionava:
- Ogni richiesta di allocazione veniva **arrotondata per eccesso** alla dimensione della zona più vicina.
(E.g., una richiesta di 50 byte finiva nella zona `kalloc.64`).
- La memoria in ogni zona veniva mantenuta in una **free list** — i chunk liberati dal kernel tornavano in quella zona.
- Se sovrascrivevi un buffer da 64 byte, avresti sovrascritto il **prossimo oggetto nella stessa zona**.

Per questo **heap spraying / feng shui** era così efficace: potevi prevedere i vicini degli oggetti spruzzando allocazioni della stessa size class.

### La freelist

Dentro ogni zona kalloc, gli oggetti liberati non venivano restituiti direttamente al sistema — andavano in una freelist, una linked list di chunk disponibili.

- Quando un chunk veniva freed, il kernel scriveva un pointer all'inizio di quel chunk → l'indirizzo del prossimo chunk libero nella stessa zona.

- La zona manteneva un puntatore HEAD al primo chunk libero.

- L'allocazione usava sempre l'HEAD corrente:

1. Pop HEAD (restituisce quella memoria al chiamante).

2. Aggiorna HEAD = HEAD->next (memorizzato nell'header del chunk liberato).

- Il free rimetteva i chunk indietro:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

Quindi la freelist era semplicemente una linked list costruita dentro la memoria liberata stessa.

Stato normale:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Sfruttare la freelist

Poiché i primi 8 byte di un free chunk = freelist pointer, un attaccante potrebbe corromperlo:

1. **Heap overflow** in un freed chunk adiacente → sovrascrivere il suo “next” pointer.

2. **Use-after-free**: scrivere in un freed object → sovrascrivere il suo “next” pointer.

Poi, alla successiva allocazione di quella dimensione:

- L'allocator estrae il corrupted chunk.

- Segue il “next” pointer fornito dall'attaccante.

- Restituisce un pointer a memoria arbitraria, consentendo fake object primitives o targeted overwrite.

Esempio visivo di freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
Questo design del freelist rese l'exploitation altamente efficace prima dell'hardening: vicini prevedibili derivanti da heap sprays, raw pointer freelist links e l'assenza di separazione per tipo permettevano agli attaccanti di escalare bug UAF/overflow fino al controllo arbitrario della memoria kernel.

### Heap Grooming / Feng Shui
The goal of heap grooming is to **modellare il layout dell'heap** so that when an attacker triggers an overflow or use-after-free, the target (victim) object sits right next to an attacker-controlled object.\
In questo modo, quando avviene la corruzione di memoria, l'attaccante può sovrascrivere in modo affidabile l'oggetto vittima con dati controllati.

**Passaggi:**

1. Spray allocations (fill the holes)
- Col tempo, il kernel heap si frammenta: alcune zone hanno buchi dove vecchi oggetti sono stati freed.
- L'attaccante prima esegue molte dummy allocations per riempire questi spazi, così l'heap diventa "compattato" e prevedibile.

2. Force new pages
- Una volta che i buchi sono riempiti, le allocate successive devono provenire da nuove pagine aggiunte alla zona.
- Pagine fresche significano oggetti raggruppati insieme, non sparsi nella memoria frammentata.
- Questo dà all'attaccante un controllo molto migliore sui neighbors.

3. Place attacker objects
- L'attaccante ora effettua un nuovo spray, creando molti attacker-controlled objects in quelle nuove pagine.
- Questi oggetti sono prevedibili per dimensione e posizionamento (dato che appartengono alla stessa zone).

4. Free a controlled object (make a gap)
- L'attaccante deliberateamente free-a uno dei propri oggetti.
- Ciò crea un "buco" nell'heap, che l'allocator riutilizzerà per la successiva allocazione di quella dimensione.

5. Victim object lands in the hole
- L'attaccante forza il kernel ad allocare l'oggetto vittima (quello che vuole corrompere).
- Poiché il buco è la prima slot disponibile nella freelist, la vittima viene posizionata esattamente dove l'attaccante aveva freed il proprio oggetto.

6. Overflow / UAF into victim
- Ora l'attaccante ha attacker-controlled objects attorno alla vittima.
- Sovrascrivendo per overflow da uno dei propri oggetti (o riutilizzando uno freed), può sovrascrivere in modo affidabile i campi di memoria della vittima con valori scelti.

**Perché funziona**:

- Predictability dell'allocator di zona: le allocate della stessa dimensione provengono sempre dalla stessa zone.
- Comportamento della freelist: le nuove allocate riutilizzano per prime il chunk più recentemente freed.
- Heap sprays: l'attaccante riempie la memoria con contenuti prevedibili e controlla il layout.
- Risultato finale: l'attaccante controlla dove l'oggetto vittima atterra e quali dati si trovano accanto ad esso.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple ha rinforzato l'allocator e ha reso il **heap grooming molto più difficile**:

### 1. From Classic kalloc to kalloc_type
- **Before**: esisteva una singola zona `kalloc.<size>` per ogni classe di dimensione (16, 32, 64, … 1280, ecc.). Qualsiasi oggetto di quella dimensione veniva allocato lì → gli attacker objects potevano stare accanto a privileged kernel objects.
- **Now**:
- Kernel objects sono allocati da **typed zones** (`kalloc_type`).
- Ogni tipo di oggetto (es., `ipc_port_t`, `task_t`, `OSString`, `OSData`) ha la propria zona dedicata, anche se hanno la stessa dimensione.
- La mappatura tra object type ↔ zone è generata dal **kalloc_type system** a compile time.

Un attaccante non può più garantire che dati controllati (`OSData`) finiscano adiacenti a oggetti kernel sensibili (`task_t`) della stessa dimensione.

### 2. Slabs and Per-CPU Caches
- L'heap è diviso in **slabs** (pagine di memoria suddivise in chunk di dimensione fissa per quella zona).
- Ogni zona ha una **per-CPU cache** per ridurre la contention.
- Allocation path:
1. Prova la per-CPU cache.
2. Se vuota, prendi dalla global freelist.
3. Se la freelist è vuota, allocare un nuovo slab (una o più pagine).
- **Vantaggio**: questa decentralizzazione rende gli heap sprays meno deterministici, dato che le allocate possono essere soddisfatte dalle cache di CPU diverse.

### 3. Randomization inside zones
- All'interno di una zona, gli elementi freed non vengono restituiti in semplice ordine FIFO/LIFO.
- L'XNU moderno usa **encoded freelist pointers** (stile safe-linking come Linux, introdotto ~iOS 14).
- Ogni freelist pointer è **XOR-encoded** con un cookie segreto per zona.
- Questo impedisce agli attaccanti di forgiare un fake freelist pointer se ottengono un write primitive.
- Alcune allocate sono **randomizzate nella loro collocazione all'interno di uno slab**, quindi lo spraying non garantisce adiacenza.

### 4. Guarded Allocations
- Alcuni kernel objects critici (es., credentials, strutture di task) sono allocati in **guarded zones**.
- Queste zone inseriscono **guard pages** (memoria non mappata) tra slab o usano **redzones** attorno agli oggetti.
- Qualsiasi overflow nella guard page causa un fault → panic immediato anziché corruzione silenziosa.

### 5. Page Protection Layer (PPL) and SPTM
- Anche se controlli un oggetto freed, non puoi modificare tutta la memoria kernel:
- **PPL (Page Protection Layer)** impone che certe regioni (es., code signing data, entitlements) siano **read-only** anche per il kernel stesso.
- Su dispositivi **A15/M2+**, questo ruolo è sostituito/migliorato da **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- Questi layer imposti via hardware significano che gli attaccanti non possono eseguire l'escalation da una singola corruzione dell'heap a patch arbitrarie di strutture di sicurezza critiche.

### 6. Large Allocations
- Non tutte le allocate passano per `kalloc_type`.
- Richieste molto grandi (sopra ~16KB) bypassano le typed zones e sono servite direttamente dalla **kernel VM (kmem)** tramite page allocations.
- Queste sono meno prevedibili, ma anche meno sfruttabili, dato che non condividono slab con altri oggetti.

### 7. Allocation Patterns Attackers Target
Anche con queste protezioni, gli attaccanti cercano ancora:
- **Reference count objects**: se puoi manomettere i contatori retain/release, puoi causare use-after-free.
- **Objects with function pointers (vtables)**: corromperne uno può ancora portare a control flow.
- **Shared memory objects (IOSurface, Mach ports)**: questi sono ancora obiettivi perché fanno da ponte tra user ↔ kernel.

Ma — a differenza di prima — non puoi semplicemente sprayare `OSData` e aspettarti che sia vicino a un `task_t`. Serve **bug specifici per tipo** o **info leaks** per avere successo.

### Example: Allocation Flow in Modern Heap

Supponiamo che userspace invochi IOKit per allocare un oggetto `OSData`:

1. **Type lookup** → `OSData` mappa alla zona `kalloc_type_osdata` (size 64 bytes).
2. Controlla la per-CPU cache per elementi liberi.
- Se trovati → ritorna uno.
- Se vuota → vai alla global freelist.
- Se la freelist è vuota → allocare un nuovo slab (pagina di 4KB → 64 chunk da 64 bytes).
3. Ritorna il chunk al chiamante.

**Freelist pointer protection**:
- Ogni chunk freed memorizza l'indirizzo del prossimo chunk libero, ma codificato con una chiave segreta.
- Sovrascrivere quel campo con dati controllati dall'attaccante non funzionerà a meno di conoscere la chiave.


## Tabella di confronto

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages   |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Scarica il DMG di BinDiff da [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) e installalo.

Apri Ghidra con `ghidraRun` e vai su `File` --> `Install Extensions`, premi il pulsante add e seleziona il percorso `/Applications/BinDiff/Extra/Ghidra/BinExport` e clicca OK e installalo anche se c'è una mismatch di versione.

### Using BinDiff with Kernel versions

1. Vai alla pagina [https://ipsw.me/](https://ipsw.me/) e scarica le versioni iOS che vuoi diffare. Questi saranno file `.ipsw`.
2. Decomprimi finché non ottieni il formato bin del kernelcache di entrambi i file `.ipsw`. Hai informazioni su come farlo in:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Apri Ghidra con `ghidraRun`, crea un nuovo progetto e carica i kernelcaches.
4. Apri ciascun kernelcache così che vengano analizzati automaticamente da Ghidra.
5. Poi, nella project Window di Ghidra, clic destro su ogni kernelcache, seleziona `Export`, scegli il formato `Binary BinExport (v2) for BinDiff` ed esportali.
6. Apri BinDiff, crea un nuovo workspace e aggiungi un nuovo diff indicando come primary file il kernelcache che contiene la vulnerabilità e come secondary file il kernelcache patched.

---

## Finding the right XNU version

Se vuoi controllare per vulnerabilità in una versione specifica di iOS, puoi verificare quale versione di XNU quella release di iOS usa su [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

Per esempio, le versioni `15.1 RC`, `15.1` e `15.1.1` usano la versione `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


{{#include ../../banners/hacktricks-training.md}}
