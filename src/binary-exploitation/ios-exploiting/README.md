# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

- **Code Signing** in iOS works by requiring every piece of executable code (apps, libraries, extensions, etc.) to be cryptographically signed with a certificate issued by Apple. When code is loaded, iOS verifies the digital signature against Apple’s trusted root. If the signature is invalid, missing, or modified, the OS refuses to run it. This prevents attackers from injecting malicious code into legitimate apps or running unsigned binaries, effectively stopping most exploit chains that rely on executing arbitrary or tampered code.
- **CoreTrust** is the iOS subsystem responsible for enforcing code signing at runtime. It directly verifies signatures using Apple’s root certificate without relying on cached trust stores, meaning only binaries signed by Apple (or with valid entitlements) can execute. CoreTrust ensures that even if an attacker tampers with an app after installation, modifies system libraries, or tries to load unsigned code, the system will block execution unless the code is still properly signed. This strict enforcement closes many post-exploitation vectors that older iOS versions allowed through weaker or bypassable signature checks.
- **Data Execution Prevention (DEP)** marks memory regions as non-executable unless they explicitly contain code. This stops attackers from injecting shellcode into data regions (like the stack or heap) and running it, forcing them to rely on more complex techniques like ROP (Return-Oriented Programming).
- **ASLR (Address Space Layout Randomization)** randomizes the memory addresses of code, libraries, stack, and heap every time the system runs. This makes it much harder for attackers to predict where useful instructions or gadgets are, breaking many exploit chains that depend on fixed memory layouts.
- **KASLR (Kernel ASLR)** applies the same randomization concept to the iOS kernel. By shuffling the kernel’s base address at each boot, it prevents attackers from reliably locating kernel functions or structures, raising the difficulty of kernel-level exploits that would otherwise gain full system control.
- **Kernel Patch Protection (KPP)** also known as **AMCC (Apple Mobile File Integrity)** in iOS, continuously monitors the kernel’s code pages to ensure they haven’t been modified. If any tampering is detected—such as an exploit trying to patch kernel functions or insert malicious code—the device will immediately panic and reboot. This protection makes persistent kernel exploits far harder, as attackers can’t simply hook or patch kernel instructions without triggering a system crash.
- **Kernel Text Readonly Region (KTRR)** is a hardware-based security feature introduced on iOS devices. It uses the CPU’s memory controller to mark the kernel’s code (text) section as permanently read-only after boot. Once locked, even the kernel itself cannot modify this memory region. This prevents attackers—and even privileged code—from patching kernel instructions at runtime, closing off a major class of exploits that relied on modifying kernel code directly.
- **Pointer Authentication Codes (PAC)** use cryptographic signatures embedded into unused bits of pointers to verify their integrity before use. When a pointer (like a return address or function pointer) is created, the CPU signs it with a secret key; before dereferencing, the CPU checks the signature. If the pointer was tampered with, the check fails and execution stops. This prevents attackers from forging or reusing corrupted pointers in memory corruption exploits, making techniques like ROP or JOP much harder to pull off reliably.
- **Privilege Access never (PAN)** is a hardware feature that prevents the kernel (privileged mode) from directly accessing user-space memory unless it explicitly enables access. This stops attackers who gained kernel code execution from easily reading or writing user memory to escalate exploits or steal sensitive data. By enforcing strict separation, PAN reduces the impact of kernel exploits and blocks many common privilege-escalation techniques.
- **Page Protection Layer (PPL)** is an iOS security mechanism that protects critical kernel-managed memory regions, especially those related to code signing and entitlements. It enforces strict write protections using the MMU (Memory Management Unit) and additional checks, ensuring that even privileged kernel code cannot arbitrarily modify sensitive pages. This prevents attackers who gain kernel-level execution from tampering with security-critical structures, making persistence and code-signing bypasses significantly harder.

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

The kernel used a **zone allocator** (`kalloc`) divided into fixed-size "zones."
Each zone only stores allocations of a single size class.

From the screenshot:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Very small kernel structs, pointers.                                        |
| `default.kalloc.32`  | 32 bytes     | Small structs, object headers.                                              |
| `default.kalloc.64`  | 64 bytes     | IPC messages, tiny kernel buffers.                                          |
| `default.kalloc.128` | 128 bytes    | Medium objects like parts of `OSObject`.                                    |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Large structures, IOSurface/graphics metadata.                              |

**How it worked:**
- Each allocation request gets **rounded up** to the nearest zone size.
(E.g., a 50-byte request lands in the `kalloc.64` zone).
- Memory in each zone was kept in a **free list** — chunks freed by the kernel went back into that zone.
- If you overflowed a 64-byte buffer, you’d overwrite the **next object in the same zone**.

This is why **heap spraying / feng shui** was so effective: you could predict object neighbors by spraying allocations of the same size class.

### The freelist

Inside each kalloc zone, freed objects weren’t returned directly to the system — they went into a freelist, a linked list of available chunks.

- When a chunk was freed, the kernel wrote a pointer at the start of that chunk → the address of the next free chunk in the same zone.

- The zone kept a HEAD pointer to the first free chunk.

- Allocation always used the current HEAD:

1. Pop HEAD (return that memory to the caller).

2. Update HEAD = HEAD->next (stored in the freed chunk’s header).

- Freeing pushed chunks back:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

So the freelist was just a linked list built inside the freed memory itself.

Normal state:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Kutumia freelist

Kwa sababu the first 8 bytes za free chunk ni freelist pointer, mshambuliaji anaweza kuiharibu:

1. **Heap overflow** ndani ya free chunk jirani → kuandika upya “next” pointer yake.

2. **Use-after-free** kuandika ndani ya freed object → kuandika upya “next” pointer yake.

Kisha, kwenye allocation inayofuata ya ukubwa huo:

- Allocator inatoa chunk iliyoharibika.

- Inafuata “next” pointer iliyotolewa na mshambuliaji.

- Inarudisha pointer kwa arbitrary memory, ikiruhusu fake object primitives au targeted overwrite.

Mfano wa kielelezo wa freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
Muundo huu wa freelist ulifanya exploitation kuwa yenye ufanisi mkubwa kabla ya hardening: majirani yanayotabirika kutokana na heap sprays, raw pointer freelist links, na ukosefu wa type separation uliruhusu washambuliaji kuinua mdudu wa UAF/overflow hadi kupata udhibiti wa arbitrary kernel memory.

### Heap Grooming / Feng Shui
Lengo la heap grooming ni kuunda **shape the heap layout** ili wakati mshambuliaji atakapochochea overflow au use-after-free, object linalolengwa (victim) likaa karibu kabisa na object inayoendeshwa na mshambuliaji.\
Kwa hivyo, wakati uharibifu wa memory unatokea, mshambuliaji anaweza kwa kuaminika kuandika juu object ya victim na data anayoitawala.

**Hatua:**

1. Spray allocations (fill the holes)
- Kwa muda, kernel heap hupotoka: baadhi ya zones zina mashimo ambapo vitu vya zamani vilifutwa.
- Mshambuliaji kwanza anaweka allocations nyingi za dummy ili kujaza nafasi hizi, hivyo heap inakuwa “packed” na inatarajiwa.

2. Force new pages
- Mara mashimo yamejazwa, allocations zinazofuata lazima zitoke kutoka kwenye new pages zilizoongezwa kwenye zone.
- Kurasa mpya zinamaanisha vitu vitakusanywa karibu pamoja, si kusambazwa kwenye memory iliyoyumba.
- Hii inampa mshambuliaji udhibiti bora wa majirani.

3. Place attacker objects
- Mshambuliaji sasa anafanya spray tena, akitengeneza vitu vingi vinavyoendeshwa na mshambuliaji kwenye hizo new pages.
- Vitu hivi vina ukubwa na nafasi inayotarajiwa (kwa sababu vyote vinatoka kwenye zone ile ile).

4. Free a controlled object (make a gap)
- Mshambuliaji kwa makusudi anafungua moja ya vitu vyake (free).
- Hii inaunda “hole” kwenye heap, ambayo allocator baadaye itatumia kwa allocation inayofuata ya ukubwa huo.

5. Victim object lands in the hole
- Mshambuliaji anachochea kernel ili allocate victim object (ile wanayotaka kuharibu).
- Kwa kuwa hole ndiyo slot ya kwanza inayopatikana kwenye freelist, victim inawekwa hasa mahali mshambuliaji alifungua object yake.

6. Overflow / UAF into victim
- Sasa mshambuliaji ana vitu vinavyoendeshwa na yeye karibu na victim.
- Kwa kufanya overflow kutoka kwa moja ya vitu vyake (au kutumia iliyofutwa tena), anaweza kwa kuaminika kuandika juu ya fields za memory za victim na thamani anazozichagua.

**Kwa nini inafanya kazi**:

- Zone allocator predictability: allocations za ukubwa ule ule kila mara zinatoka kwenye zone ile ile.
- Freelist behavior: allocations mpya hutumia chunk iliyoachwa hivi karibuni kwanza.
- Heap sprays: mshambuliaji anajaza memory na maudhui yanayotarajiwa na kudhibiti layout.
- Matokeo ya mwisho: mshambuliaji anadhibiti mahali victim atawekwa na ni data gani itakayokaa karibu nayo.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple ilitengeneza allocator na kufanya **heap grooming iwe ngumu zaidi**:

### 1. From Classic kalloc to kalloc_type
- **Before**: zone moja `kalloc.<size>` ilikuwepo kwa kila size class (16, 32, 64, … 1280, nk). Kila object ya ukubwa huo iliwekwa pale → vitu vya mshambuliaji vilikuwa vinaweza kukaa karibu na vitu vya kernel vilivyo na nguvu.
- **Now**:
- Kernel objects zina allocated kutoka kwenye **typed zones** (`kalloc_type`).
- Kila aina ya object (mfano, `ipc_port_t`, `task_t`, `OSString`, `OSData`) ina zone yake maalum, hata kama zina ukubwa ule ule.
- Ramani kati ya object type ↔ zone inatengenezwa kutoka kwenye **kalloc_type system** wakati wa compile.

Mshambuliaji hawezi tena kuhakikisha kwamba controlled data (`OSData`) itamalizika karibu na vitu nyeti za kernel (`task_t`) za ukubwa ule ule.

### 2. Slabs and Per-CPU Caches
- Heap imegawanywa kwenye **slabs** (pages za memory zilizogawanywa katika vipande vya ukubwa fasta kwa zone hiyo).
- Kila zone ina **per-CPU cache** kupunguza contention.
- Allocation path:
1. Jaribu per-CPU cache.
2. Ikiwa tupu, chukua kutoka global freelist.
3. Ikiwa freelist iko tupu, allocate slab mpya (ukurasa mmoja au zaidi).
- **Faida**: ugawaji huu unafanya heap sprays kuwa sio deterministic, kwani allocations zinaweza kutimizwa kutoka caches za CPU tofauti.

### 3. Randomization inside zones
- Ndani ya zone, elementi zilizofutwa hazirudishiwi kwa FIFO/LIFO rahisi.
- XNU ya kisasa inatumia **encoded freelist pointers** (safe-linking kama Linux, iliyoanzishwa ~iOS 14).
- Kila freelist pointer ime **XOR-encoded** na cookie ya siri ya zone.
- Hii inazuia mshambuliaji kutengeneza pointer bandia ya freelist ikiwa wanapata write primitive.
- Baadhi ya allocations zinapangiliwa kwa nasibu ndani ya slab, hivyo spraying haihakikishi adjacency.

### 4. Guarded Allocations
- Vitu fulani nyeti za kernel (mfano, credentials, task structures) zimepewa allocation katika **guarded zones**.
- Zones hizi zinaweka **guard pages** (memory isiyopangwa) kati ya slabs au kutumia **redzones** kuzunguka vitu.
- Overflow kwenye guard page husababisha fault → panic mara moja badala ya uharibifu usioonekana.

### 5. Page Protection Layer (PPL) and SPTM
- Hata ukidhibiti object iliyofutwa, huwezi kuhariri sehemu zote za kernel memory:
- **PPL (Page Protection Layer)** inatekeleza kwamba maeneo fulani (mfano, code signing data, entitlements) ni **read-only** hata kwa kernel yenyewe.
- Kwa **A15/M2+ devices**, jukumu hili limebadilishwa/kuimarishwa na **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- Tabaka hizi zilizo kwenye hardware zinamaanisha mshambuliaji hawawezi kuinuka kutoka kwa single heap corruption hadi kuchapa arbitrary critical security structures.

### 6. Large Allocations
- Sio allocations zote zinapita kupitia `kalloc_type`.
- Maombi makubwa sana (juu ya ~16KB) yanapita typed zones na hutumika moja kwa moja kutoka **kernel VM (kmem)** kupitia page allocations.
- Hizi hazitarajiwi vizuri, lakini pia ni ngumu zaidi kuzitumia kwa exploits, kwa kuwa hazishiriki slabs na vitu vingine.

### 7. Allocation Patterns Attackers Target
Hata kwa ulinzi huu, washambuliaji bado wanatafuta:
- **Reference count objects**: ikiwa unaweza kuathiri retain/release counters, unaweza kusababisha use-after-free.
- **Objects with function pointers (vtables)**: kuharibu moja bado kunatoa control flow.
- **Shared memory objects (IOSurface, Mach ports)**: hizi bado ni malengo kwa sababu zinapambana user ↔ kernel.

Lakini — tofauti na zamani — huwezi tu kufanya spray ya `OSData` ukitarajia ije karibu na `task_t`. Unahitaji **type-specific bugs** au **info leaks** ili kufanikiwa.

### Example: Allocation Flow in Modern Heap

Suppose userspace calls into IOKit to allocate an `OSData` object:

1. **Type lookup** → `OSData` maps to `kalloc_type_osdata` zone (size 64 bytes).
2. Check per-CPU cache for free elements.
- If found → return one.
- If empty → go to global freelist.
- If freelist empty → allocate a new slab (page of 4KB → 64 chunks of 64 bytes).
3. Return chunk to caller.

**Freelist pointer protection**:
- Each freed chunk stores the address of the next free chunk, but encoded with a secret key.
- Overwriting that field with attacker data won’t work unless you know the key.


## Comparison Table

| Kipengele                        | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Vipande vya ukubwa fasta (`kalloc.16`, `kalloc.32`, etc.)  | Ukubwa + **type-based buckets** (`kalloc_type`)  |
| Placement predictability        | Juu (same-size objects side by side)                       | Chini (same-type grouping + randomness)          |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Rahisi kupitia sprays/frees (feng shui predictable)        | Ngumu — typed zones zinatenganisha attacker objects |
| Kernel data/code protections    | Ulinzi mdogo wa hardware                                   | **PPL / SPTM** zinazuia page tables & code pages |
| Exploit reliability             | Juu na heap sprays                                          | Imezidi kushuka, inahitaji logic bugs au info leaks |

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
