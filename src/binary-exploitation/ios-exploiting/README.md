# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

### 1. **Code Signing** / Runtime Signature Verification
**Introduced early (iPhone OS → iOS)**
Ovo je jedna od fundamentalnih zaštita: **sav izvršni kod** (apps, dynamic libraries, JIT-ed code, extensions, frameworks, caches) mora biti kriptografski potpisan sertifikacionim lancem koji vodi do Apple-ovog root trust-a. U runtime-u, pre nego što se binarni fajl učita u memoriju (ili pre nego što se izvrše skokovi preko određenih granica), sistem proverava njegov potpis. Ako je kod izmenjen (bit-flipped, patched) ili nije potpisan, učitavanje ne uspeva.

- **Onemogućava**: fazu “classic payload drop + execute” u exploit lancima; arbitrary code injection; izmenu postojećeg binarnog fajla za ubacivanje maliciozne logike.
- **Detalji mehanizma**:
* Mach-O loader (and dynamic linker) proverava code pages, segments, entitlements, team IDs, i da li potpis pokriva sadržaj fajla.
* Za memorijske regione kao što su JIT caches ili dinamički generisan kod, Apple zahteva da stranice budu potpisane ili validirane putem specijalnih API-ja (npr. `mprotect` sa code-sign proverama).
* Potpis uključuje entitlements i identifikatore; OS zahteva da određeni API-ji ili privilegovane mogućnosti zahtevaju specifične entitlements koje nije moguće falsifikovati.

<details>
<summary>Example</summary>
Pretpostavimo da exploit dobije code execution u procesu i pokuša da upiše shellcode u heap i skoči na njega. Na iOS-u, ta stranica bi morala biti označena kao executable **i** zadovoljavati code-signature uslove. Pošto shellcode nije potpisan Apple-ovim sertifikatom, skok ne uspeva ili sistem odbija da tu memorijsku oblast učini izvršnom.
</details>


### 2. **CoreTrust**
**Introduced around iOS 14+ era (or gradually in newer devices / later iOS)**
CoreTrust je subsistem koji vrši **runtime signature validation** binarnih fajlova (uključujući system i user binare) naspram **Apple-ovog root sertifikata** umesto oslanjanja na keširane userland trust store-ove.

- **Onemogućava**: post-install tampering binarnih fajlova, jailbreaking tehnike koje pokušavaju da zamene ili zakrpe system libraries ili user apps; zavaravanje sistema zamenskim, malicioznim binarnim fajlovima.
- **Detalji mehanizma**:
* Umesto da se veruje lokalnoj trust bazi ili kešu sertifikata, CoreTrust referiše ili verifikuje Apple-ov root direktno ili proverava intermediate sertifikate u sigurnom lancu.
* Osigurava da su izmene (npr. u filesystem-u) postojećih binarnih fajlova detektovane i odbijene.
* Povezuje entitlements, team IDs, code signing flags i drugu metadata sa binarnim fajlom u vreme učitavanja.

<details>
<summary>Example</summary>
Jailbreak bi mogao pokušati da zameni `SpringBoard` ili `libsystem` sa zakrpljenom verzijom da bi dobio persistenciju. Ali kada loader sistema ili CoreTrust proveri, primeti mismatch potpisa (ili izmenjene entitlements) i odbije da izvrši.
</details>


### 3. **Data Execution Prevention (DEP / NX / W^X)**
**Introduced in many OSes earlier; iOS had NX-bit / w^x for a long time**
DEP nameće da stranice koje su označene kao writable (za podatke) budu **non-executable**, i stranice označene kao executable budu **non-writable**. Ne možete jednostavno upisati shellcode u heap ili stack region i izvršiti ga.

- **Onemogućava**: direktno izvršavanje shellcode-a; klasičan buffer-overflow → jump to injected shellcode.
- **Detalji mehanizma**:
* MMU / memory protection flags (preko page table-a) nameću ovu separaciju.
* Svaki pokušaj da se writable stranica označi kao executable okida sistemsku proveru (i ili je zabranjen ili zahteva code-sign odobrenje).
* U mnogim slučajevima, pravljenje stranica executable zahteva korišćenje OS API-ja koji nameću dodatna ograničenja ili provere.

<details>
<summary>Example</summary>
Overflow upisuje shellcode u heap. Napadač pokušava `mprotect(heap_addr, size, PROT_EXEC)` da je učini izvršnom. Ali sistem odbija ili validira da nova stranica mora proći code-sign constraints (što shellcode ne može).
</details>

### 4. **Address Space Layout Randomization (ASLR)**
**Introduced in iOS ~4–5 era (roughly iOS 4–5 timeframe)**
ASLR randomizuje bazne adrese ključnih memorijskih regiona: libraries, heap, stack, itd., pri svakom pokretanju procesa. Adrese gadget-a se pomeraju između pokretanja.

- **Onemogućava**: hardkodiranje adresa gadget-a za ROP/JOP; statične exploit lance; slepo skakanje na poznate offset-e.
- **Detalji mehanizma**:
* Svaka učitana biblioteka / dynamic module je rebased na nasumični offset.
* Stack i heap base pointer-i su randomizovani (u okviru određenih entropijskih ograničenja).
* Ponekad su i drugi regioni (npr. mmap alokacije) takođe randomizovani.
* U kombinaciji sa mitigacijama protiv information-leak-a, primorana je napadaču da prvo izvrši leak adrese ili pokazivača da bi otkrio base adrese u runtime-u.

<details>
<summary>Example</summary>
ROP lanac očekuje gadget na `0x….lib + offset`. Ali pošto je `lib` relociran drugačije pri svakom pokretanju, hardkodirani lanac ne uspeva. Exploit mora prvo da leak-uje baznu adresu modula pre nego što izračuna adrese gadget-a.
</details>


### 5. **Kernel Address Space Layout Randomization (KASLR)**
**Introduced in iOS ~ (iOS 5 / iOS 6 timeframe)**
Analogno korisničkom ASLR-u, KASLR randomizuje bazu **kernel text-a** i drugih kernel struktura pri boot-u.

- **Onemogućava**: kernel-level exploite koji se oslanjaju na fiksne lokacije kernel koda ili podataka; statične kernel exploite.
- **Detalji mehanizma**:
* Pri svakom boot-u, baza kernela je randomizovana (u okviru opsega).
* Kernel data strukture (kao `task_structs`, `vm_map`, itd.) takođe mogu biti relocirane ili offset-ovane.
* Napadači moraju prvo da leak-uju kernel pointer-e ili koriste information disclosure ranjivosti da bi izračunali offset-e pre nego što hijack-uju kernel strukture ili kod.

<details>
<summary>Example</summary>
Lokalna ranjivost želi da korumpira kernel function pointer (npr. u `vtable`) na `KERN_BASE + offset`. Ali pošto `KERN_BASE` nije poznat, napadač mora prvo da ga leak-uje (npr. putem read primitive) pre nego što izračuna tačnu adresu za korupciju.
</details>


### 6. **Kernel Patch Protection (KPP / AMCC)**
**Introduced in newer iOS / A-series hardware (post around iOS 15–16 era or newer chips)**
KPP (aka AMCC) kontinuirano prati integritet kernel text stranica (preko hash-a ili checksum-a). Ako detektuje tampering (patch-ove, inline hooks, izmene koda) izvan dozvoljenih prozora, okida kernel panic ili reboot.

- **Onemogućava**: persistent kernel patching (izmenu kernel instrukcija), inline hooks, statičke funkcionalne overwrite-ove.
- **Detalji mehanizma**:
* Hardverski ili firmware modul prati kernel text region.
* Periodično ili po zahtevu re-hash-uje stranice i poredi sa očekivanim vrednostima.
* Ako se pojave mismatch-evi izvan benignih update prozora, izaziva panic uređaja (da bi se izbegla persistencija maliciozne zakrpe).
* Napadači moraju ili izbeći detekcione prozore ili koristiti legitimne puteve za patchovanje.

<details>
<summary>Example</summary>
Exploit pokušava da patch-uje kernel funkciju prolog (npr. `memcmp`) da bi presretao pozive. Ali KPP primeti da se hash code stranice više ne poklapa sa očekivanom vrednošću i okida kernel panic, čime se uređaj sruši pre nego što zakrpa postane stabilna.
</details>


### 7. **Kernel Text Read‐Only Region (KTRR)**
**Introduced in modern SoCs (post ~A12 / newer hardware)**
KTRR je hardverski sproveden mehanizam: jednom kada je kernel text zaključan rano tokom boot-a, postaje read-only iz EL1 (kernel), sprečavajući dalja pisanja u code stranice.

- **Onemogućava**: bilo kakve izmene kernel koda posle boot-a (npr. patching, in-place code injection) na EL1 privilegiji.
- **Detalji mehanizma**:
* Tokom boot-a (u secure/bootloader fazi), memory controller (ili neki secure hardware unit) označava fizičke stranice koje sadrže kernel text kao read-only.
* Čak i ako exploit dobije pune kernel privilegije, ne može da piše u te stranice da bi patch-ovao instrukcije.
* Da bi ih menjao, napadač mora prvo kompromitovati boot chain ili subvert-ovati sam KTRR.

<details>
<summary>Example</summary>
Privilege-escalation exploit skoči u EL1 i upiše trampoline u kernel funkciju (npr. u `syscall` handler). Ali pošto su stranice zaključane kao read-only od strane KTRR, upis ne uspeva (ili izaziva fault), pa patch-ovi nisu primenjeni.
</details>


### 8. **Pointer Authentication Codes (PAC)**
**Introduced with ARMv8.3 (hardware), Apple beginning with A12 / iOS ~12+**
- PAC je hardverska funkcija uvedena u **ARMv8.3-A** da detektuje tampering vrednosti pointer-a (return addresses, function pointers, certain data pointers) ubacivanjem malog kriptografskog potpisa (“MAC”) u neiskorišćene visoke bitove pointer-a.
- Potpis (“PAC”) se računa preko vrednosti pointer-a plus **modifier** (vrednost konteksta, npr. stack pointer ili neki identifikator). Na taj način ista vrednost pointer-a u različitim kontekstima dobija drugačiji PAC.
- Pri korišćenju, instrukcija za autentifikaciju proverava PAC. Ako je validan, PAC se uklanja i dobija se čisti pointer; ako nije, pointer postaje “poisoned” (ili se podiže fault).
- Ključevi koji se koriste za generisanje/validaciju PAC-ova nalaze se u privilegovanim registrima (EL1, kernel) i nisu direktno čitljivi iz user mode-a.
- Pošto se ne koriste sve 64 bita pointer-a u mnogim sistemima (npr. 48-bit address space), gornji bitovi su “slobodni” i mogu držati PAC bez menjanja efektivne adrese.

#### Architectural Basis & Key Types

- ARMv8.3 uvodi **pet 128-bitnih ključeva** (svaki implementiran kao dva 64-bitna sistemska registra) za pointer authentication.
- **APIAKey** — za instruction pointers (domen “I”, ključ A)
- **APIBKey** — drugi ključ za instruction pointers (domen “I”, ključ B)
- **APDAKey** — za data pointers (domen “D”, ključ A)
- **APDBKey** — za data pointers (domen “D”, ključ B)
- **APGAKey** — “generic” ključ, za potpisivanje ne-pointer podataka ili druge opšte upotrebe

- Ovi ključevi su uskladišteni u privilegovanim sistemskim registrima (pristup samo na EL1/EL2 itd.), nedostupni iz user mode-a.
- PAC se računa preko kriptografijske funkcije (ARM predlaže QARMA kao algoritam) koristeći:
1. Vrednost pointer-a (kanonični deo)
2. **Modifier** (vrednost konteksta, kao salt)
3. Tajni ključ
4. Neki interni tweak logike
Ako dobijeni PAC odgovara onome što je pohranjeno u gornjim bitovima pointer-a, autentifikacija uspeva.

#### Instruction Families

Konvencija imenovanja je: **PAC** / **AUT** / **XPAC**, pa zatim sufiksi domena.
- `PACxx` instrukcije **potpisuju** pointer i ubacuju PAC
- `AUTxx` instrukcije **autentifikuju + skidaju** (validiraju i uklanjaju PAC)
- `XPACxx` instrukcije **skidaju** bez validacije

Domains / sufiksi:

| Mnemonic     | Meaning / Domain                      | Key / Domain     | Example Usage in Assembly |
|--------------|-----------------------------------------|--------------------|-----------------------------|
| **PACIA**    | Sign instruction pointer with APIAKey   | “I, A”             | `PACIA X0, X1` — sign pointer in X0 using APIAKey with modifier X1|
| **PACIB**    | Sign instruction pointer with APIBKey   | “I, B”             | `PACIB X2, X3`              |
| **PACDA**    | Sign data pointer with APDAKey           | “D, A”             | `PACDA X4, X5`              |
| **PACDB**    | Sign data pointer with APDBKey           | “D, B”             | `PACDB X6, X7`              |
| **PACG / PACGA** | Generic (non-pointer) signing with APGAKey | “G”         | `PACGA X8, X9, X10` (sign X9 with modifier X10 into X8) |
| **AUTIA**    | Authenticate APIA-signed instruction pointer & strip PAC | “I, A” | `AUTIA X0, X1` — check PAC on X0 using modifier X1, then strip |
| **AUTIB**    | Authenticate APIB domain                 | “I, B”             | `AUTIB X2, X3`               |
| **AUTDA**    | Authenticate APDA-signed data pointer    | “D, A”             | `AUTDA X4, X5`               |
| **AUTDB**    | Authenticate APDB-signed data pointer    | “D, B”             | `AUTDB X6, X7`               |
| **AUTGA**    | Authenticate generic / blob (APGA)        | “G”               | `AUTGA X8, X9, X10` (validate generic) |
| **XPACI**     | Strip PAC (instruction pointer, no validation) | “I”         | `XPACI X0` — remove PAC from X0 (instruction domain) |
| **XPACD**     | Strip PAC (data pointer, no validation)    | “D”             | `XPACD X4` — remove PAC from data pointer in X4 |


Postoje specijalizovani / alias oblici:

- `PACIASP` je skraćeno za `PACIA X30, SP` (potpiši link register koristeći SP kao modifier)
- `AUTIASP` je `AUTIA X30, SP` (autentifikuj link register sa SP)
- Kombinovani oblici kao `RETAA`, `RETAB` (authenticate-and-return) ili `BLRAA` (authenticate & branch) postoje u ARM ekstenzijama / podršci kompajlera.
- Takođe varijante sa nul-modifier-om: `PACIZA` / `PACIZB` gde je modifier implicitno nula, itd.

#### Modifiers

Glavni cilj modifier-a je da **veže PAC za specifičan kontekst** tako da ista adresa potpisana u različitim kontekstima daje različite PAC-ove. Ovo sprečava jednostavnu ponovnu upotrebu pointer-a između frame-ova ili objekata. To je kao dodavanje **soli hash-u.**

Dakle:
- **Modifier** je kontekstualna vrednost (drugi registar) koja se uklapa u PAC računanje. Tipični izbori: stack pointer (`SP`), frame pointer, ili neki object ID.
- Korišćenje SP kao modifier-a je uobičajeno za signing return adresa: PAC je vezan za konkretan stack frame. Ako pokušate da ponovo upotrebite LR u drugom frame-u, modifier se menja i PAC validacija ne uspe.
- Ista vrednost pointer-a potpisana uz različite modifier-e daje različite PAC-ove.
- Modifier ne mora biti tajan, ali idealno nije pod kontrolom napadača.
- Za instrukcije koje potpisuju ili verifikuju pointer-e gde ne postoji smislen modifier, neke forme koriste nulu ili implicitnu konstantu.

#### Apple / iOS / XNU Customizations & Observations

- Apple-ova PAC implementacija uključuje **per-boot diversifiers** tako da ključevi ili tweak-ovi menjaju svaki boot, sprečavajući ponovnu upotrebu između boot-ova.
- Takođe uključuju **cross-domain mitigacije** tako da PAC potpisan u user modu teško može biti ponovo upotrebljen u kernel modu, itd.
- Na Apple M1 / Apple Silicon, reverzno inženjerstvo je pokazalo da postoji **devet tipova modifier-a** i Apple-specifični sistemski registri za kontrolu ključeva.
- Apple koristi PAC u mnogim kernel pod-sistemima: signing return adresa, pointer integritet u kernel podacima, signed thread contexts, itd.
- Google Project Zero je pokazao kako pod moćnim memory read/write primitivom u kernelu, može se forgovati kernel PAC-ove (za A ključeve) na A12-era uređajima, ali Apple je zakrpao mnoge od tih puteva.
- U Apple sistemu, neki ključevi su **globalni za kernel**, dok user procesi mogu dobiti per-process randomizaciju ključeva.

#### PAC Bypasses

1. **Kernel-mode PAC: theoretical vs real bypasses**

-   Pošto su kernel PAC ključevi i logika strogo kontrolisani (privileged registri, diversifiers, domain izolacija), falsifikovanje proizvoljno potpisanih kernel pointer-a je veoma teško.
-   Azad-ov 2020 "iOS Kernel PAC, One Year Later" izvestio je da je u iOS 12-13 pronašao nekoliko parcijalnih bypass-a (signing gadgets, reuse of signed states, unprotected indirect branches) ali ne i potpuni generički bypass. [bazad.github.io](https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf)
-   Apple-ove “Dark Magic” customizacije dodatno su suzile exploitable površine (domain switching, per-key enabling bits). [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Postoji poznati **kernel PAC bypass CVE-2023-32424** na Apple silicon (M1/M2) prijavljen od strane Zecao Cai et al. [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Ali ovi bypass-i često se oslanjaju na vrlo specifične gadget-e ili implementacione bube; nisu generalno primenjivi.

Dakle kernel PAC se smatra **vrlo robustnim**, iako nije savršen.

2. **User-mode / runtime PAC bypass techniques**

Ovi su češći i iskorišćavaju nesavršenosti u načinu na koji se PAC primenjuje ili koristi u dynamic linking / runtime framework-ovima. Ispod su klase sa primerima.

2.1 **Shared Cache / A key issues**

-   **dyld shared cache** je veliki pre-linked blob system frameworks i libraries. Pošto se široko deli, function pointer-i unutar shared cache-a su “pre-signed” i koriste ih mnogi procesi. Napadači ciljaju ove već potpisane pointer-e kao “PAC oracale”.

-   Neki bypass-ovi pokušavaju da ekstrahuju ili ponovo iskoriste A-key potpisane pointer-e prisutne u shared cache-u i da ih ponovo iskoriste u gadget-ima.

-   Predavanje "No Clicks Required" opisuje izgradnju oracle-a preko shared cache-a za inferenciju relativnih adresa i kombinovanje toga sa signed pointer-ima da bi se zaobišao PAC. [saelo.github.io](https://saelo.github.io/presentations/offensivecon_20_no_clicks.pdf)

-   Takođe, import-ovi function pointer-a iz shared biblioteka u userspace su bili nedovoljno zaštićeni od PAC-a, dopuštajući napadaču da dobije pointer-e bez menjanja njihovog potpisa. (Project Zero bug entry) [bugs.chromium.org](https://bugs.chromium.org/p/project-zero/issues/detail?id=2044&utm_source=chatgpt.com)

2.2 **dlsym(3) / dynamic symbol resolution**

-   Jedan poznati bypass je da se pozove `dlsym()` da bi se dobio *već potpisani* function pointer (potpisan A-key-om, diversifier zero) i zatim koristiti. Pošto `dlsym` vraća legitimno potpisan pointer, njegovo korišćenje zaobilazi potrebu da se falsifikuje PAC.

-   Epsilon-ov blog opisuje kako neki bypass-ovi iskorišćavaju ovo: pozivanje `dlsym("someSym")` vraća potpisani pointer i može se koristiti za indirektne pozive. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

-   Synacktiv-ov tekst "iOS 18.4 --- dlsym considered harmful" opisuje bugu: neki simboli rešeni preko `dlsym` na iOS 18.4 vraćaju pointer-e koji su pogrešno potpisani (ili sa bugovitim diversifier-ima), omogućavajući neželjen PAC bypass. [Synacktiv](https://www.synacktiv.com/en/publications/ios-184-dlsym-considered-harmful)

-   Logika u dyld za dlsym uključuje: kada `result->isCode`, oni potpisuju vraćeni pointer sa `__builtin_ptrauth_sign_unauthenticated(..., key_asia, 0)`, tj. kontekst nula. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

Dakle, `dlsym` je čest vektor u user-mode PAC bypass-ovima.

2.3 **Other DYLD / runtime relocations**

-   DYLD loader i dinamička relocaciona logika su kompleksni i ponekad privremeno mapiraju stranice kao read/write da bi izvršili relocacije, pa ih zatim ponovo prebace na read-only. Napadači iskorišćavaju ove vremenske prozore. Synacktiv-ova prezentacija opisuje "Operation Triangulation", timing-based PAC bypass preko dinamičkih relocacija. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   DYLD stranice su sada zaštićene sa SPRR / VM_FLAGS_TPRO (neki zaštitni flag-ovi za dyld). Ali ranije verzije su imale slabije odbrane. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   U WebKit exploit lancima, DYLD loader je često cilj za PAC bypass. Slajdovi pominju da su mnogi PAC bypass-ovi ciljali DYLD loader (preko relocation, interposer hooks). [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

2.4 **NSPredicate / NSExpression / ObjC / SLOP**

-   U userland exploit lancima, Objective-C runtime metode kao što su `NSPredicate`, `NSExpression` ili `NSInvocation` koriste se za provlačenje kontrolnih poziva bez očiglednog forge-ovanja pointer-a.

-   Na starijem iOS-u (pre PAC), exploit je koristio **fake NSInvocation** objekte da bi pozivao arbitrarne selektore nad kontrolisanom memorijom. Sa PAC, tehnika zahteva modifikacije. Ali tehnika SLOP (SeLector Oriented Programming) proširena je i pod PAC-om. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   Originalna SLOP tehnika je dozvoljavala lančanje ObjC poziva kreiranjem lažnih invokation objekata; bypass se oslanja na činjenicu da ISA ili selector pointer-i ponekad nisu u potpunosti PAC-zaštićeni. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   U okruženjima gde je pointer authentication primenjena parcijalno, metode / selector-i / target pointer-i možda nisu uvek PAC-zaštićeni, što ostavlja prostor za bypass.

#### Example Flow

<details>
<summary>Example Signing & Authenticating</summary>
```
; Example: function prologue / return address protection
my_func:
stp x29, x30, [sp, #-0x20]!        ; push frame pointer + LR
mov x29, sp
PACIASP                            ; sign LR (x30) using SP as modifier
; … body …
mov sp, x29
ldp x29, x30, [sp], #0x20         ; restore
AUTIASP                            ; authenticate & strip PAC
ret

; Example: indirect function pointer stored in a struct
; suppose X1 contains a function pointer
PACDA X1, X2     ; sign data pointer X1 with context X2
STR X1, [X0]      ; store signed pointer

; later retrieval:
LDR X1, [X0]
AUTDA X1, X2       ; authenticate & strip
BLR X1             ; branch to valid target

; Example: stripping for comparison (unsafe)
LDR X1, [X0]
XPACI X1           ; strip PAC (instruction domain)
CMP X1, #some_label_address
BEQ matched_label
```
</details>

<details>
<summary>Primer</summary>
A buffer overflow prepisuje return adresu na stacku. Napadač upisuje ciljnu adresu gadgeta ali ne može izračunati ispravan PAC. Kada funkcija vraća, CPU-ova `AUTIA` instrukcija baci grešku zbog neusklađenog PAC-a. Lanac ne uspeva.
Project Zero’s analysis on A12 (iPhone XS) showed how Apple’s PAC is used and methods of forging PACs if an attacker has a memory read/write primitive.
</details>


### 9. **Branch Target Identification (BTI)**
**Introduced with ARMv8.5 (later hardware)**
BTI je hardverska funkcija koja proverava **indirektne branch target-e**: pri izvršavanju `blr` ili indirektnih poziva/skokova, cilj mora početi sa **BTI landing pad-om** (`BTI j` or `BTI c`). Skakanje u adrese gadgeta koje nemaju landing pad izaziva izuzetak.

LLVM-ova implementacija beleži tri varijante BTI instrukcija i kako se one mapiraju na tipove grana.

| BTI Variant | What it permits (which branch types) | Typical placement / use case |
|-------------|----------------------------------------|-------------------------------|
| **BTI C** | Targets of *call*-style indirect branches (e.g. `BLR`, or `BR` using X16/X17) | Put at entry of functions that may be called indirectly |
| **BTI J** | Targets of *jump*-style branches (e.g. `BR` used for tail calls) | Placed at the beginning of blocks reachable by jump tables or tail-calls |
| **BTI JC** | Acts as both C and J | Can be targeted by either call or jump branches |

- U kodu kompajliranom sa branch target enforcement, kompajleri umeću BTI instrukciju (C, J, ili JC) na svaki validan indirektni-branch target (početci funkcija ili blokovi dostupni preko skokova) tako da indirektni branch-evi uspevaju samo ka tim mestima.
- **Direktni branch-evi / pozivi** (tj. fiksno-adresni `B`, `BL`) **nisu ograničeni** od strane BTI. Pretpostavka je da su code stranice verodostojne i da napadač ne može da ih menja (tako da su direktni branch-evi bezbedni).
- Takođe, **RET / return** instrukcije generalno nisu ograničene od BTI zato što su return adrese zaštićene preko PAC ili mehanizama potpisivanja povratka.

#### Mechanism and enforcement

- Kada CPU dekodira **indirektan branch (BLR / BR)** u strani označenoj kao “guarded / BTI-enabled,” proverava da li prva instrukcija ciljne adrese predstavlja validan BTI (C, J, ili JC kako je dozvoljeno). Ako nije, dolazi do **Branch Target Exception**.
- Kodiranje BTI instrukcije je dizajnirano da ponovo koristi opcode-e koji su ranije bili rezervisani za NOP-ove (u starijim ARM verzijama). Dakle, BTI-enabled binarni fajlovi ostaju kompatibilni unazad: na hardveru bez BTI podrške te instrukcije ponašaju se kao NOP.
- Compiler pass-ovi koji dodaju BTI umeću ih samo tamo gde je potrebno: funkcije koje mogu biti pozvane indirektno, ili osnovni blokovi targetirani skokovima.
- Neki patch-evi i LLVM kod pokazuju da BTI nije ubačen za *sve* osnovne blokove — samo za one koji su potencijalni branch target-i (npr. iz switch / jump tabela).

#### BTI + PAC synergy

PAC štiti vrednost pokazivača (izvor) — garantuje da lanac indirektnih poziva / povrataka nije izmenjen.

BTI osigurava da čak i validan pokazivač može ciljati samo pravilno označene ulazne tačke.

Kombinacijom, napadač treba i validan pokazivač sa ispravnim PAC-om i da ciljna lokacija ima postavljen BTI. To povećava težinu konstruisanja exploit gadget-a.

#### Primer


<details>
<summary>Primer</summary>
Exploit pokušava da pivotuje u gadget na `0xABCDEF` koji ne počinje sa `BTI c`. CPU, pri izvršavanju `blr x0`, proverava cilj i baci grešku zato što instrukcijska poravnanja ne sadrže validan landing pad. Dakle, mnogi gadget-i postaju neupotrebljivi osim ako ne uključuju BTI prefiks.
</details>


### 10. **Privileged Access Never (PAN) & Privileged Execute Never (PXN)**
**Introduced in more recent ARMv8 extensions / iOS support (for hardened kernel)**

#### PAN (Privileged Access Never)

- **PAN** je feature uveden u **ARMv8.1-A** koji sprečava **privileged code** (EL1 ili EL2) da **čitaju ili pišu** memoriju koja je označena kao **user-accessible (EL0)**, osim ako PAN nije eksplicitno onemogućen.
- Ideja: čak i ako je kernel prevaren ili kompromitovan, ne može proizvoljno dereferencirati user-space pokazivače bez pre toga *isključivanja* PAN-a, što smanjuje rizik od eksploata tipa **`ret2usr`** ili zloupotrebe user-kontrolisanih buffera.
- Kada je PAN omogućen (PSTATE.PAN = 1), svaka privileged load/store instrukcija koja pristupa virtuelnoj adresi koja je “accessible at EL0” izaziva **permission fault**.
- Kernel, kada mora legitimno da pristupi user-space memoriji (npr. kopiranje podataka u/iz user buffera), mora **privremeno da onemogući PAN** (ili koristiti “unprivileged load/store” instrukcije) da dozvoli taj pristup.
- U Linux-u na ARM64, podrška za PAN je uvedena oko 2015: kernel patch-evi su dodali detekciju feature-a i zamenili `get_user` / `put_user` itd. varijantama koje brišu PAN oko pristupa user memoriji.

**Ključna nijansa / ograničenje / bug**
- Kao što su primetili Siguza i drugi, specifikaciona greška (ili nejasno ponašanje) u ARM dizajnu znači da **execute-only user mappings** (`--x`) možda **neću pokrenuti PAN**. Drugim rečima, ako je user stranica označena kao izvršna ali bez read dozvole, pokušaj kernela da je čita može zaobići PAN jer arhitektura smatra da “accessible at EL0” zahteva readable permisiju, a ne samo izvršnu. Ovo dovodi do PAN bypass-a u određenim konfiguracijama.
- Zbog toga, ako iOS / XNU dozvoljava execute-only user stranice (kao što neke JIT ili code-cache postavke mogu), kernel bi mogao slučajno da čita iz njih čak i sa uključenim PAN-om. Ovo je poznato suptilno eksploatabilno područje u nekim ARMv8+ sistemima.

#### PXN (Privileged eXecute Never)

- **PXN** je bit u page table-u (u PTE-ovima, leaf ili block entry-ima) koji označava da je stranica **neizvršna kada se pokreće u privileged modu** (tj. kada EL1 izvršava).
- PXN sprečava kernel (ili bilo koji privileged kod) da skoči na ili izvršava instrukcije iz user-space stranica čak i ako je kontrola preusmerena. U suštini, to zaustavlja kernel-level preusmeravanje kontrolnog toka u user memoriju.
- U kombinaciji sa PAN, ovo osigurava da:
1. Kernel ne može (po defaultu) da čita ili piše user-space podatke (PAN)
2. Kernel ne može da izvršava user-space kod (PXN)
- U ARMv8 page table formatu, leaf entry-ji imaju `PXN` bit (i takođe `UXN` za unprivileged execute-never) u svojim atribut bitovima.

Dakle čak i ako kernel ima korumpiran pointer funkcije koji pokazuje na user memoriju i pokuša da skoči tamo, PXN bit bi izazvao fault.

#### Memory-permission model & how PAN and PXN map to page table bits

Da biste razumeli kako PAN / PXN rade, potrebno je videti kako ARM-ov prevod i permission model funkcionišu (pojednostavljeno):

- Svaka page ili block entry ima atribut polja uključujući **AP[2:1]** za access permisije (read/write, privileged vs unprivileged) i **UXN / PXN** bitove za execute-never restrikcije.
- Kada je PSTATE.PAN = 1 (omogućen), hardver primenjuje modifikovanu semantiku: privileged pristupi stranicama označenim kao “accessible by EL0” (tj. user-accessible) su zabranjeni (fault).
- Zbog pomenutog buga, stranice koje su označene samo kao izvršne (bez read permisije) možda se ne računaju kao “accessible by EL0” kod određenih implementacija, što može dovesti do zaobilaženja PAN-a.
- Kada je PXN bit za stranicu postavljen, čak i ako fetch instrukcije dolazi sa višeg privilege nivoa, izvršavanje je zabranjeno.

#### Kernel usage of PAN / PXN in a hardened OS (e.g. iOS / XNU)

U dizajnu hardenovanog kernela (kao što Apple može koristiti):

- Kernel omogućava PAN po defaultu (tako da je privileged kod ograničen).
- U putanjama koje legitimno trebaju da čitaju ili pišu user buffere (npr. syscall buffer copy, I/O, read/write user pointer), kernel privremeno **onemogućava PAN** ili koristi specijalne instrukcije da nadjača zaštitu.
- Nakon završetka pristupa user podacima, mora ponovo da omogući PAN.
- PXN se primenjuje preko page table-a: user stranice imaju PXN = 1 (tako da kernel ne može da ih izvršava), kernel stranice nemaju PXN (tako da kernel kod može da se izvršava).
- Kernel mora da osigura da nijedan kod-put ne izazove izvršavanje u user memorijskim regionima (to bi zaobišlo PXN) — pa su exploit chain-ovi koji se oslanjaju na “jump into user-controlled shellcode” blokirani.

Zbog pomenutog PAN bypass-a kroz execute-only stranice, u realnom sistemu Apple bi mogao da onemogući ili zabrani execute-only user stranice, ili da započne patch oko specifikacione slabosti.

#### Attack surfaces, bypasses, and mitigations

- **PAN bypass via execute-only pages**: kao što je diskutovano, spec omogućava prazninu: user stranice sa execute-only (bez read permissije) možda neće biti blokirane od strane PAN-a kod nekih implementacija. Ovo daje napadaču neočekivan put da ubaci podatke kroz “execute-only” sekcije.
- **Temporal window exploit**: ako kernel isključi PAN na period duži nego što je potrebno, race ili maliciozni put mogu iskoristiti taj interval za izvođenje nepredviđenog pristupa user memoriji.
- **Forgotten re-enable**: ako kodne putanje zaborave da ponovo uključe PAN, naredne kernel operacije bi mogle pogrešno da pristupaju user memoriji.
- **Misconfiguration of PXN**: ako page table-i ne postave PXN na user stranicama ili pogrešno mapiraju user code stranice, kernel bi mogao biti prevaren da izvrši user-space kod.
- **Speculation / side-channels**: analogno spekulativnim zaobilaženjima, mogu postojati mikroarhitektonski sporedni efekti koji uzrokuju tranzijentno kršenje PAN / PXN provera (iako su takvi napadi visoko zavisni od dizajna CPU-a).
- **Complex interactions**: U naprednijim feature-ima (npr. JIT, shared memory, just-in-time code regioni), kernel može zahtevati finu kontrolu da dopusti određene memorijske pristupe ili izvršavanje u user-mapped regionima; dizajniranje tih mehanizama bezbedno pod PAN/PXN ograničenjima nije trivijalno.

#### Primer

<details>
<summary>Code Example</summary>
Evo ilustrativnih pseudo-assembly sekvenci koje pokazuju uključivanje/isključivanje PAN oko pristupa user memoriji, i kako bi mogao nastati fault.
</details>
```  
// Suppose kernel entry point, PAN is enabled (privileged code cannot access user memory by default)

; Kernel receives a syscall with user pointer in X0
; wants to read an integer from user space
mov   X1, X0        ; X1 = user pointer

; disable PAN to allow privileged access to user memory
MSR   PSTATE.PAN, #0   ; clear PAN bit, disabling the restriction

ldr   W2, [X1]       ; now allowed load from user address

; re-enable PAN before doing other kernel logic
MSR   PSTATE.PAN, #1   ; set PAN

; ... further kernel work ...

; Later, suppose an exploit corrupts a pointer to a user-space code page and jumps there
BR    X3             ; branch to X3 (which points into user memory)

; Because the target page is marked PXN = 1 for privileged execution,
; the CPU throws an exception (fault) and rejects execution
```
If the kernel had **not** set PXN on that user page, then the branch might succeed — which would be insecure.

If the kernel forgets to re-enable PAN after user memory access, it opens a window where further kernel logic might accidentally read/write arbitrary user memory.

If the user pointer is into an execute-only page (user page with only execute permission, no read/write), under the PAN spec bug, `ldr W2, [X1]` might **not** fault even with PAN enabled, enabling a bypass exploit, depending on implementation.

</details>

<details>
<summary>Example</summary>
Kernel ranjivost pokušava da uzme funkcijski pokazivač dostavljen od korisnika i pozove ga u kernel kontekstu (npr. `call user_buffer`). Pod PAN/PXN, ta operacija je zabranjena ili izaziva fault.
</details>

---

### 11. **Top Byte Ignore (TBI) / Pointer Tagging**
**Introduced in ARMv8.5 / newer (or optional extension)**
TBI means the top byte (most-significant byte) of a 64-bit pointer is ignored by address translation. This lets OS or hardware embed **tag bits** in the pointer’s top byte without affecting the actual address.

- TBI stands for **Top Byte Ignore** (sometimes called *Address Tagging*). It is a hardware feature (available in many ARMv8+ implementations) that **ignores the top 8 bits** (bits 63:56) of a 64-bit pointer when performing **address translation / load/store / instruction fetch**.
- In effect, the CPU treats a pointer `0xTTxxxx_xxxx_xxxx` (where `TT` = top byte) as `0x00xxxx_xxxx_xxxx` for the purposes of address translation, ignoring (masking off) the top byte. The top byte can be used by software to store **metadata / tag bits**.
- This gives software “free” in-band space to embed a byte of tag in each pointer without altering which memory location it refers to.
- The architecture ensures that loads, stores, and instruction fetch treat the pointer with its top byte masked (i.e. tag stripped off) before performing the actual memory access.

Dakle, TBI odvaja **logički pokazivač** (pointer + tag) od **fizičke adrese** koje se koriste za memorijske operacije.

#### Zašto TBI: Use cases and motivation

- **Pointer tagging / metadata**: Možete čuvati dodatne metadata (npr. tip objekta, verziju, granice, integrity tags) u tom top bajtu. Kada kasnije upotrebite pokazivač, tag se ignoriše na nivou hardvera, tako da nije potrebno ručno uklanjati tag pre pristupa memoriji.
- **Memory tagging / MTE (Memory Tagging Extension)**: TBI is the base hardware mechanism that MTE builds on. In ARMv8.5, the **Memory Tagging Extension** uses bits 59:56 of the pointer as a **logical tag** and checks it against an **allocation tag** stored in memory.
- **Enhanced security & integrity**: By combining TBI with pointer authentication (PAC) or runtime checks, you can force not just the pointer value but also the tag to be correct. An attacker overwriting a pointer without the correct tag will produce a mismatched tag.
- **Compatibility**: Because TBI is optional and tag bits are ignored by hardware, existing untagged code continues to operate normally. The tag bits effectively become “don’t care” bits for legacy code.

#### Example
<details>
<summary>Example</summary>
Funkcijski pokazivač je imao tag u top bajtu (npr. `0xAA`). Exploit prepisuje niske bitove pokazivača ali zanemaruje tag, pa kada kernel verifikuje ili sanitizuje, pokazivač ne prođe ili bude odbijen.
</details>

---

### 12. **Page Protection Layer (PPL)**
**Introduced in late iOS / modern hardware (iOS ~17 / Apple silicon / high-end models)** (some reports show PPL circa macOS / Apple silicon, but Apple is bringing analogous protections to iOS)

- PPL je dizajniran kao **intra-kernel granica zaštite**: čak i ako je kernel (EL1) kompromitovan i ima read/write mogućnosti, **ne bi trebalo da može slobodno menjati** određene **osetljive stranice** (posebno page table-ove, code-sign metadata, kernel code stranice, entitlements, trust caches, itd.).
- Efektivno stvara **“kernel unutar kernela”** — manju poverljivu komponentu (PPL) sa **povišenim privilegijama** koja jedina može menjati zaštićene stranice. Drugi kernel kod mora da pozove PPL rutine da bi izvršio izmene.
- Ovo smanjuje površinu napada za kernel exploit-e: čak i sa punim proizvoljnim R/W/execute u kernel modu, exploit kod mora na neki način ući u PPL domen (ili zaobići PPL) da bi menjao kritične strukture.
- Na novijem Apple silicon-u (A15+ / M2+), Apple prelazi na **SPTM (Secure Page Table Monitor)**, koji u mnogim slučajevima zamenjuje PPL za zaštitu page-table-a na tim platformama.

Evo kako se veruje da PPL radi, na osnovu javnih analiza:

#### Use of APRR / permission routing (APRR = Access Permission ReRouting)

- Apple hardware koristi mehanizam nazvan **APRR (Access Permission ReRouting)**, koji dozvoljava da page table entries (PTEs) sadrže male indekse, umesto punih permission bita. Ti indeksi se mapiraju preko APRR registara na stvarne dozvole. Ovo omogućava dinamičko premapiranje dozvola po domenu.
- PPL koristi APRR da separiše privilegije unutar kernel konteksta: samo PPL domen ima dozvolu da ažurira mapiranje između indeksa i efektivnih dozvola. To znači da, kada non-PPL kernel kod piše PTE ili pokušava da preokrene permission bita, APRR logika to onemogućava (ili nameće read-only mapiranje).
- PPL kod sam radi u ograničenom regionu (npr. `__PPLTEXT`) koji je obično non-executable ili non-writable dok entry gate privremeno ne dozvoli pristup. Kernel poziva PPL entry tačke (“PPL routines”) da izvrši osetljive operacije.

#### Gate / Entry & Exit

- Kada kernel treba da izmeni zaštićenu stranicu (npr. promeni dozvole kernel code stranice, ili izmeni page table-ove), pozove **PPL wrapper** rutinu, koja radi validaciju i zatim prelazi u PPL domen. Van tog domena, zaštićene stranice su efektivno read-only ili nemodifikabilne od glavnog kernela.
- Tokom PPL ulaska, APRR mapiranja se prilagode tako da memorijske stranice u PPL regionu budu postavljene kao **executable & writable** unutar PPL. Po izlazu, one se vraćaju u read-only / non-writable stanje. Ovo osigurava da samo dobro pregledane PPL rutine mogu pisati u zaštićene stranice.
- Van PPL, pokušaji kernel koda da upiše te zaštićene stranice će fault-ovati (permission denied) jer APRR mapiranje za taj code domain ne dozvoljava pisanje.

#### Protected page categories

Stranice koje PPL tipično štiti uključuju:

- Strukture page table-a (translation table entries, mapping metadata)
- Kernel code stranice, naročito one koje sadrže kritičnu logiku
- Code-sign metadata (trust caches, signature blobs)
- Entitlement tabele, tabele za primenu potpisa
- Druge visokovredne kernel strukture gde bi patch omogućio zaobilaženje provere potpisa ili manipulaciju credential-ima

Ideja je da čak i ako je kernel memorija potpuno pod kontrolom, napadač ne može jednostavno da patch-uje ili prepiše ove stranice, osim ako takođe ne kompromituje PPL rutine ili ne zaobiđe PPL.

#### Known Bypasses & Vulnerabilities

1. **Project Zero’s PPL bypass (stale TLB trick)**

- Javni writeup Project Zero-a opisuje bypass koji uključuje **stale TLB entries**.
- Ideja:

1. Alocirajte dve fizičke stranice A i B, označite ih kao PPL stranice (tako da su zaštićene).
2. Mapirajte dve virtuelne adrese P i Q čije L3 translation table stranice potiču iz A i B.
3. Pokrenite thread koji kontinuirano pristupa Q, održavajući njegov TLB unos živim.
4. Pozovite `pmap_remove_options()` da uklonite mapiranja počevši od P; zbog buga, kod greškom uklanja TTE-e za oba P i Q, ali invalidira samo TLB unos za P, ostavljajući Q-ev stale unos živim.
5. Ponovo iskoristite B (stranicu Q-ove tabele) da mapirate proizvoljnu memoriju (npr. PPL-zaštićene stranice). Pošto zastareli TLB unos i dalje mapira staro mapiranje Q, to mapiranje ostaje važeće za taj kontekst.
6. Kroz ovo, napadač može postaviti zapisivi mapping PPL-zaštićenih stranica bez prolaska kroz PPL interfejs.

- Ovaj exploit je zahtevao finu kontrolu fizičkog mapiranja i TLB ponašanja. Pokazuje da bezbednosna granica koja se oslanja na ispravnost TLB / mapiranja mora biti izuzetno pažljiva oko invalidacija TLB-a i konzistentnosti mapiranja.
- Project Zero je komentarisao da su ovakvi bypass-i suptilni i retki, ali mogući u kompleksnim sistemima. Ipak, smatraju PPL solidnom mitigacijom.

2. **Other potential hazards & constraints**

- Ako kernel exploit može direktno da uđe u PPL rutine (pozivajući PPL wrapper-e), može zaobići restrikcije. Zato je validacija argumenata kritična.
- Bagovi u samom PPL kodu (npr. aritmetički overflow, provere granica) mogu dozvoliti out-of-bounds izmene unutar PPL. Project Zero je u svom bypass-u primetio da je takav bug u `pmap_remove_options_internal()` iskorišćen.
- PPL granica je nepovratno vezana za hardversko sprovođenje (APRR, memory controller), tako da je snažna koliko i implementacija hardvera.

#### Example
<details>
<summary>Code Example</summary>
Evo pojednostavljenog pseudokoda / logike koja pokazuje kako bi kernel mogao da pozove PPL da izmeni zaštićene stranice:
</details>
```c
// In kernel (outside PPL domain)
function kernel_modify_pptable(pt_addr, new_entry) {
// validate arguments, etc.
return ppl_call_modify(pt_addr, new_entry)  // call PPL wrapper
}

// In PPL (trusted domain)
function ppl_call_modify(pt_addr, new_entry) {
// temporarily enable write access to protected pages (via APRR adjustments)
aprr_set_index_for_write(PPL_INDEX)
// perform the modification
*pt_addr = new_entry
// restore permissions (make pages read-only again)
aprr_restore_default()
return success
}

// If kernel code outside PPL does:
*pt_addr = new_entry  // a direct write
// It will fault because APRR mapping for non-PPL domain disallows write to that page
```
The kernel can do many normal operations, but only through `ppl_call_*` routines can it change protected mappings or patch code.
</details>

<details>
<summary>Example</summary>
Kernel može obavljati mnoge uobičajene operacije, ali samo kroz rutine `ppl_call_*` može menjati zaštićene mape ili patch-ovati kod.
</details>

#### PPL → SPTM / Replacements / Future

- On Apple’s modern SoCs (A15 or later, M2 or later), Apple supports **SPTM** (Secure Page Table Monitor), which **replaces PPL** for page table protections.
- Apple calls out in documentation: “Page Protection Layer (PPL) and Secure Page Table Monitor (SPTM) enforce execution of signed and trusted code … PPL manages the page table permission overrides … Secure Page Table Monitor replaces PPL on supported platforms.”
- The SPTM architecture likely shifts more policy enforcement into a higher-privileged monitor outside kernel control, further reducing the trust boundary.

### MTE | EMTE | MIE

Here’s a higher-level description of how EMTE operates under Apple’s MIE setup:

1. **Tag assignment**
- When memory is allocated (e.g. in kernel or user space via secure allocators), a **secret tag** is assigned to that block.
- The pointer returned to the user or kernel includes that tag in its high bits (using TBI / top byte ignore mechanisms).

2. **Tag checking on access**
- Whenever a load or store is executed using a pointer, the hardware checks that the pointer’s tag matches the memory block’s tag (allocation tag). If mismatch, it faults immediately (since synchronous).
- Because it's synchronous, there is no “delayed detection” window.

3. **Retagging on free / reuse**
- When memory is freed, the allocator changes the block’s tag (so older pointers with old tags no longer match).
- A use-after-free pointer would therefore have a stale tag and mismatch when accessed.

4. **Neighbor-tag differentiation to catch overflows**
- Adjacent allocations are given distinct tags. If a buffer overflow spills into neighbor’s memory, tag mismatch causes a fault.
- This is especially powerful in catching small overflows that cross boundary.

5. **Tag confidentiality enforcement**
- Apple must prevent tag values being leaked (because if attacker learns the tag, they could craft pointers with correct tags).
- They include protections (microarchitectural / speculative controls) to avoid side-channel leakage of tag bits.

6. **Kernel and user-space integration**
- Apple uses EMTE not just in user-space but also in kernel / OS-critical components (to guard kernel against memory corruption).
- The hardware/OS ensures tag rules apply even when kernel is executing on behalf of user space.

<details>
<summary>Example</summary>
```
Allocate A = 0x1000, assign tag T1
Allocate B = 0x2000, assign tag T2

// pointer P points into A with tag T1
P = (T1 << 56) | 0x1000

// Valid store
*(P + offset) = value // tag T1 matches allocation → allowed

// Overflow attempt: P’ = P + size_of_A (into B region)
*(P' + delta) = value
→ pointer includes tag T1 but memory block has tag T2 → mismatch → fault

// Free A, allocator retags it to T3
free(A)

// Use-after-free:
*(P) = value
→ pointer still has old tag T1, memory region is now T3 → mismatch → fault
```
</details>

#### Ograničenja & izazovi

- **Intrablock overflows**: Ako overflow ostane unutar iste alokacije (ne pređe granicu) i tag ostane isti, tag mismatch ga neće detektovati.
- **Tag width limitation**: Samo nekoliko bitova (npr. 4 bita, ili mali domen) je dostupno za tag—ograničen namespace.
- **Side-channel leaks**: Ako se tag bits mogu be leaked (putem cache / speculative execution), napadač može saznati validne tagove i zaobići zaštitu. Apple-ova primena tag confidentiality enforcement ima za cilj da ovo ublaži.
- **Performance overhead**: Provere taga pri svakom load/store dodaju trošak; Apple mora optimizovati hardver da bi taj overhead bio mali.
- **Compatibility & fallback**: Na starijem hardveru ili delovima koji ne podržavaju EMTE, mora postojati fallback. Apple tvrdi da je MIE omogućen samo na uređajima sa podrškom.
- **Complex allocator logic**: Allocator mora da upravlja tagovima, retagovanjem, poravnavanjem granica i izbegavanjem kolizija tagova. Bagovi u logici allocatora mogu uvesti ranjivosti.
- **Mixed memory / hybrid areas**: Neki delovi memorije mogu ostati untagged (legacy), što otežava interoperabilnost.
- **Speculative / transient attacks**: Kao i kod mnogih mikroarhitekturnih zaštita, speculative execution ili micro-op fuzije mogu privremeno zaobići provere ili leak-ovati tag bits.
- **Limited to supported regions**: Apple možda primenjuje EMTE selektivno, u visokorizičnim oblastima (kernel, security-critical subsystems), a ne univerzalno.



---

## Ključna poboljšanja / razlike u odnosu na standardni MTE

Evo poboljšanja i izmena na koje Apple stavlja naglasak:

| Feature | Original MTE | EMTE (Apple’s enhanced) / MIE |
|---|---|---|
| **Check mode** | Supports synchronous and asynchronous modes. In async, tag mismatches are reported later (delayed)| Apple insists on **synchronous mode** by default—tag mismatches are caught immediately, no delay/race windows allowed.|
| **Coverage of non-tagged memory** | Accesses to non-tagged memory (e.g. globals) may bypass checks in some implementations | EMTE zahteva da i pristupi iz tagged regiona ka non-tagged memoriji provere validnost taga, otežavajući zaobilaženje mešanim alokacijama.|
| **Tag confidentiality / secrecy** | Tags might be observable or leaked via side channels | Apple dodaje **Tag Confidentiality Enforcement**, koja pokušava da spreči leak-ovanje vrednosti tagova (putem speculative side-channels itd.).|
| **Allocator integration & retagging** | MTE leaves much of allocator logic to software | Apple-ovi secure typed allocators (kalloc_type, xzone malloc, etc.) integrišu se sa EMTE: kada se memorija alocira ili oslobodi, tagovi se upravljaju na finom nivou.|
| **Always-on by default** | In many platforms, MTE is optional or off by default | Apple enables EMTE / MIE by default on supported hardware (e.g. iPhone 17 / A19) for kernel and many user processes.|

Pošto Apple kontroliše i hardver i softver stack, može strogo primeniti EMTE, izbeći performansne zamke i zatvoriti side-channel rupe.

---

## Kako EMTE funkcioniše u praksi (Apple / MIE)

Evo visokog nivoa opisa kako EMTE radi u Apple-ovom MIE setupu:

1. **Tag assignment**
- Kada se memorija alocira (npr. u kernelu ili user space preko secure allocators), toj blok memorije se dodeljuje **secret tag**.
- Pokazivač koji se vraća korisniku ili kernelu uključuje taj tag u svojim visokim bitovima (koristeći TBI / top byte ignore mechanisms).

2. **Tag checking on access**
- Kad god se izvršava load ili store koristeći pokazivač, hardver proverava da li tag u pokazivaču odgovara tagu memorijskog bloka (allocation tag). Ako je mismatch, javlja se fault odmah (pošto je sinhrono).
- Pošto je sinhrono, nema prozora za „odloženu detekciju“.

3. **Retagging on free / reuse**
- Kada se memorija oslobodi, allocator menja tag bloka (tako da stari pokazivači sa starim tagom više ne odgovaraju).
- Use-after-free pokazivač će imati zastareli tag i biće mismatch pri pristupu.

4. **Neighbor-tag differentiation to catch overflows**
- Susedne alokacije dobijaju različite tagove. Ako buffer overflow pređe u memoriju suseda, tag mismatch izaziva fault.
- Ovo je posebno efektivno za detekciju malih overflow-a koji prelaze granicu.

5. **Tag confidentiality enforcement**
- Apple mora da spreči leak tag vrednosti (jer ako napadač sazna tag, može da konstruše pokazivače sa korektnim tagom).
- Uključuju zaštite (mikroarhitekturne / speculative kontrole) da bi se izbeglo leak-ovanje tag bitova.

6. **Kernel and user-space integration**
- Apple koristi EMTE ne samo u user-space već i u kernelu / OS-critical komponentama (da bi zaštitio kernel od memory corruption).
- Hardver/OS garantuje da pravila taga važe čak i kada kernel izvršava na zahtev user space-a.

Pošto je EMTE ugrađen u MIE, Apple koristi EMTE u sinhronom režimu preko ključnih attack surface-a, a ne kao opcioni ili debug mod.

---

## Exception handling in XNU

Kada se desi **exception** (npr. `EXC_BAD_ACCESS`, `EXC_BAD_INSTRUCTION`, `EXC_CRASH`, `EXC_ARM_PAC`, itd.), **Mach layer** u XNU kernelu je odgovoran da je presretne pre nego što postane UNIX-style **signal** (kao `SIGSEGV`, `SIGBUS`, `SIGILL`, ...).

Ovaj proces uključuje više slojeva propagacije i obrade exception-a pre nego što stigne do user space-a ili bude konvertovan u BSD signal.


### Exception Flow (High-Level)

1.  **CPU triggers a synchronous exception** (npr. nevažeće dereferenciranje pointer-a, PAC failure, ilegalna instrukcija, itd.).

2.  **Low-level trap handler** runs (`trap.c`, `exception.c` in XNU source).

3.  The trap handler calls **`exception_triage()`**, core Mach exception handling funkcije.

4.  `exception_triage()` odlučuje kako da usmeri exception:

-   Prvo na **thread's exception port**.

-   Zatim na **task's exception port**.

-   Zatim na **host's exception port** (često `launchd` ili `ReportCrash`).

Ako nijedan od ovih portova ne obradi exception, kernel može:

-   **Convert it into a BSD signal** (za user-space procese).

-   **Panic** (za kernel-space exception-e).


### Core Function: `exception_triage()`

Funkcija `exception_triage()` usmerava Mach exception-e duž lanca mogućih handler-a sve dok jedan ne obradi exception ili dok on konačno ne postane fatalan. Definisana je u `osfmk/kern/exception.c`.
```c
void exception_triage(exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt);
```
**Tipičan tok poziva:**

`exception_triage()
└── exception_deliver()
├── exception_deliver_thread()
├── exception_deliver_task()
└── exception_deliver_host()`

Ako sve zakaže → obrađuje se pomoću `bsd_exception()` → prevodi se u signal kao što je `SIGSEGV`.


### Portovi izuzetaka

Svaki Mach objekat (thread, task, host) može da registruje **portove izuzetaka**, na koje se šalju poruke o izuzetku.

Definisani su API-jem:
```
task_set_exception_ports()
thread_set_exception_ports()
host_set_exception_ports()
```
Each exception port has:

-   A **mask** (which exceptions it wants to receive)
-   A **port name** (Mach port to receive messages)
-   A **behavior** (how the kernel sends the message)
-   A **flavor** (which thread state to include)


### Debuggers and Exception Handling

A **debugger** (e.g., LLDB) sets an **exception port** on the target task or thread, usually using `task_set_exception_ports()`.

**When an exception occurs:**

-   The Mach message is sent to the debugger process.
-   The debugger can decide to **handle** (resume, modify registers, skip instruction) or **not handle** the exception.
-   If the debugger doesn't handle it, the exception propagates to the next level (task → host).


### Flow of `EXC_BAD_ACCESS`

1.  Thread dereferences invalid pointer → CPU raises Data Abort.

2.  Kernel trap handler calls `exception_triage(EXC_BAD_ACCESS, ...)`.

3.  Message sent to:

-   Thread port → (debugger can intercept breakpoint).

-   If debugger ignores → Task port → (process-level handler).

-   If ignored → Host port (usually ReportCrash).

4.  If no one handles → `bsd_exception()` translates to `SIGSEGV`.


### PAC Exceptions

When **Pointer Authentication** (PAC) fails (signature mismatch), a **special Mach exception** is raised:

-   **`EXC_ARM_PAC`** (type)
-   Codes may include details (e.g., key type, pointer type).

If the binary has the flag **`TFRO_PAC_EXC_FATAL`**, the kernel treats PAC failures as **fatal**, bypassing debugger interception. This is to prevent attackers from using debuggers to bypass PAC checks and it's enabled for **platform binaries**.

### Software Breakpoints

A software breakpoint (`int3` on x86, `brk` on ARM64) is implemented by **causing a deliberate fault**.\
The debugger catches this via the exception port:

-   Modifies instruction pointer or memory.
-   Restores original instruction.
-   Resumes execution.

This same mechanism is what allows you to "catch" a PAC exception --- **unless `TFRO_PAC_EXC_FATAL`** is set, in which case it never reaches the debugger.


### Conversion to BSD Signals

If no handler accepts the exception:

-   Kernel calls `task_exception_notify() → bsd_exception()`.

-   This maps Mach exceptions to signals:

| Mach Exception | Signal |
| --- | --- |
| EXC_BAD_ACCESS | SIGSEGV or SIGBUS |
| EXC_BAD_INSTRUCTION | SIGILL |
| EXC_ARITHMETIC | SIGFPE |
| EXC_SOFTWARE | SIGTRAP |
| EXC_BREAKPOINT | SIGTRAP |
| EXC_CRASH | SIGKILL |
| EXC_ARM_PAC | SIGILL (on non-fatal) |


### Key Files in XNU Source

-   `osfmk/kern/exception.c` → Core of `exception_triage()`, `exception_deliver_*()`.

-   `bsd/kern/kern_sig.c` → Signal delivery logic.

-   `osfmk/arm64/trap.c` → Low-level trap handlers.

-   `osfmk/mach/exc.h` → Exception codes and structures.

-   `osfmk/kern/task.c` → Task exception port setup.

---

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

Kernel je koristio **zone allocator** (`kalloc`) podeljen na fiksne "zone".
Svaka zona je čuvala alokacije jedne veličine.

From the screenshot:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Very small kernel structs, pointers.                                        |
| `default.kalloc.32`  | 32 bytes     | Small structs, object headers.                                              |
| `default.kalloc.64`  | 64 bytes     | IPC messages, tiny kernel buffers.                                          |
| `default.kalloc.128` | 128 bytes    | Medium objects like parts of `OSObject`.                                    |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Large structures, IOSurface/graphics metadata.                              |

**How it worked:**
- Each allocation request gets **rounded up** to the nearest zone size.
(E.g., a 50-byte request lands in the `kalloc.64` zone).
- Memory in each zone was kept in a **free list** — chunks freed by the kernel went back into that zone.
- If you overflowed a 64-byte buffer, you’d overwrite the **next object in the same zone**.

This is why **heap spraying / feng shui** was so effective: you could predict object neighbors by spraying allocations of the same size class.

### The freelist

Inside each kalloc zone, freed objects weren’t returned directly to the system — they went into a freelist, a linked list of available chunks.

- When a chunk was freed, the kernel wrote a pointer at the start of that chunk → the address of the next free chunk in the same zone.

- The zone kept a HEAD pointer to the first free chunk.

- Allocation always used the current HEAD:

1. Pop HEAD (return that memory to the caller).

2. Update HEAD = HEAD->next (stored in the freed chunk’s header).

- Freeing pushed chunks back:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

So the freelist was just a linked list built inside the freed memory itself.

Normal state:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Exploiting the freelist

Pošto the first 8 bytes of a free chunk = freelist pointer, napadač može da ga korumpira:

1. **Heap overflow** u susedni freed chunk → prepiše njegov “next” pointer.

2. **Use-after-free** pisanje u freed object → prepiše njegov “next” pointer.

Zatim, pri sledećoj alokaciji te veličine:

- The allocator izvlači korumpirani chunk.
- Sleduje napadačem naveden “next” pointer.
- Vraća pokazivač na proizvoljnu memoriju, omogućavajući fake object primitives ili targeted overwrite.

Vizuelni primer freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
This freelist design made exploitation highly effective pre-hardening: predictable neighbors from heap sprays, raw pointer freelist links, and no type separation allowed attackers to escalate UAF/overflow bugs into arbitrary kernel memory control.

### Heap Grooming / Feng Shui
Cilj heap grooming je da **formeira raspored heapa** tako da kada napadač izazove overflow ili use-after-free, cilj (žrtva) objekat sedi odmah pored objekta koji napadač kontroliše.\
Na taj način, kad dođe do korupcije memorije, napadač može pouzdano da prepiše memoriju žrtve sa kontrolisanim podacima.

**Koraci:**

1. Spray allocations (fill the holes)
- Vremenom, kernel heap postaje fragmentisan: neke zone imaju praznine gde su stari objekti bili oslobođeni.
- Napadač prvo pravi puno dummy alokacija da popuni te praznine, tako da heap postane „gustom“ i predvidiv.

2. Force new pages
- Kada su rupe popunjene, sledeće alokacije moraju da dođu iz novih stranica dodanih u zonu.
- Sveže stranice znače da će objekti biti grupisani zajedno, a ne razbacani po staroj fragmentiranoj memoriji.
- To daje napadaču mnogo bolju kontrolu nad susedima.

3. Place attacker objects
- Napadač ponovo radi spray, kreirajući puno objekata koje kontroliše u tim novim stranicama.
- Ti objekti su predvidivi po veličini i poziciji (pošto svi pripadaju istoj zoni).

4. Free a controlled object (make a gap)
- Napadač namerno oslobodi jedan od svojih objekata.
- To stvara „rupu“ u heapu, koju će allocator kasnije ponovo iskoristiti za sledeću alokaciju te veličine.

5. Victim object lands in the hole
- Napadač provocira kernel da alocira objekat žrtve (onaj koji želi da korumpira).
- Pošto je rupa prvi dostupni slot u freelist, žrtva se postavlja upravo na mesto koje je napadač oslobodio.

6. Overflow / UAF into victim
- Sada napadač ima kontrolisane objekte oko žrtve.
- Preko overflow-a iz jednog od svojih objekata (ili ponovnim korišćenjem oslobođenog) može pouzdano da prepiše memorijska polja žrtve izabranim vrednostima.

**Zašto ovo radi**:

- Predvidivost zone allocator-a: alokacije iste veličine uvek dolaze iz iste zone.
- Freelist behavior: nove alokacije ponovo koriste najskorije oslobođeni chunk prvi.
- Heap sprays: napadač popunjava memoriju predvidljivim sadržajem i kontroliše raspored.
- Krajni rezultat: napadač kontroliše gde žrtva objekat pada i koji podaci se nalaze pored njega.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple je ojačao allocator i učinio da je **heap grooming mnogo teži**:

### 1. From Classic kalloc to kalloc_type
- **Before**: postojao je jedan `kalloc.<size>` zone za svaku veličinsku klasu (16, 32, 64, … 1280, itd.). Bilo koji objekat te veličine bi bio postavljen tamo → napadački objekti su mogli da sede pored privilegovanih kernel objekata.
- **Now**:
- Kernel objekti se alociraju iz **typed zones** (`kalloc_type`).
- Svaka vrsta objekta (npr. `ipc_port_t`, `task_t`, `OSString`, `OSData`) ima svoju namensku zonu, čak i ako su iste veličine.
- Mapiranje između tip objekta ↔ zona se generiše iz **kalloc_type sistema** pri kompilaciji.

Napadač više ne može da garantuje da će kontrolisani podaci (`OSData`) završiti pored osetljivih kernel objekata (`task_t`) iste veličine.

### 2. Slabs and Per-CPU Caches
- Heap je podeljen na **slabs** (stranice memorije isečene na fiksne chunk-ove za tu zonu).
- Svaka zona ima **per-CPU cache** da smanji contentions.
- Putanja alokacije:
1. Pokušaj per-CPU cache.
2. Ako je prazno, izvadi iz global freelist.
3. Ako je freelist prazan, alociraj novi slab (jedna ili više stranica).
- **Prednost**: ova decentralizacija čini heap sprays manje determinističkim, pošto alokacije mogu biti zadovoljene iz cache-a različitih CPU-a.

### 3. Randomization inside zones
- Unutar zone, oslobođeni elementi se ne vraćaju u jednostavnom FIFO/LIFO redosledu.
- Modern XNU koristi **encoded freelist pointers** (safe-linking like Linux, uvedeno oko iOS 14).
- Svaki freelist pointer je **XOR-enkodiran** sa per-zone secret cookie.
- Ovo sprečava napadače da falsifikuju lažni freelist pointer ako dobiju write primitive.
- Neke alokacije se **randomizuju u svom postavljanju unutar slaba**, pa spray ne garantuje susedstvo.

### 4. Guarded Allocations
- Određeni kritični kernel objekti (npr. credentials, task strukture) se alociraju u **guarded zones**.
- Te zone ubacuju **guard pages** (ne-mapiranu memoriju) između slab-ova ili koriste **redzones** oko objekata.
- Bilo koji overflow u guard page izaziva fault → trenutni panic umesto tihu korupciju.

### 5. Page Protection Layer (PPL) and SPTM
- Čak i ako kontrolišete oslobođeni objekat, ne možete izmeniti svu kernel memoriju:
- **PPL (Page Protection Layer)** nameće da određeni regioni (npr. code signing data, entitlements) budu **read-only** čak i za sam kernel.
- Na **A15/M2+ devices**, ovu ulogu zamenjuju/pojačavaju **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- Ovi hardverski sprovođeni slojevi znače da napadači ne mogu eskalirati iz jedne heap korupcije u proizvoljno patchovanje kritičnih sigurnosnih struktura.
- **(Added / Enhanced)**: takođe se koristi **PAC (Pointer Authentication Codes)** u kernelu za zaštitu pokazivača (posebno funkcijskih pokazivača, vtable-ova) tako da njihovo falsifikovanje ili korupcija postaje teža.
- **(Added / Enhanced)**: zone mogu da sprovedu **zone_require / zone enforcement**, tj. da objekat koji je oslobođen može biti vraćen samo kroz svoju ispravnu typed zonu; nevalidni cross-zone frees mogu izazvati panic ili biti odbijeni. (Apple nagoveštava ovo u svojim postovima o memory safety)

### 6. Large Allocations
- Ne sve alokacije prolaze kroz `kalloc_type`.
- Veći zahtevi (iznad ~16 KB) zaobilaze typed zones i služe se direktno iz **kernel VM (kmem)** putem page alokacija.
- Oni su manje predvidivi, ali takođe manje eksploatabilni, pošto ne dele slab-ove sa drugim objektima.

### 7. Allocation Patterns Attackers Target
Čak i sa ovim zaštitama, napadači i dalje traže:
- **Reference count objects**: ako možete da manipulišete retain/release brojačima, možete izazvati use-after-free.
- **Objects with function pointers (vtables)**: korupcija jednog i dalje donosi control flow.
- **Shared memory objects (IOSurface, Mach ports)**: i dalje su mete jer povezuju user ↔ kernel.

Ali — za razliku od ranije — ne možete samo da spray-ujete `OSData` i očekujete da bude pored `task_t`. Treba vam **type-specific bugs** ili **info leaks** da uspete.

### Example: Allocation Flow in Modern Heap

Suppose userspace calls into IOKit to allocate an `OSData` object:

1. **Type lookup** → `OSData` maps to `kalloc_type_osdata` zone (size 64 bytes).
2. Check per-CPU cache for free elements.
- If found → return one.
- If empty → go to global freelist.
- If freelist empty → allocate a new slab (page of 4KB → 64 chunks of 64 bytes).
3. Return chunk to caller.

**Freelist pointer protection**:
- Each freed chunk stores the address of the next free chunk, but encoded with a secret key.
- Overwriting that field with attacker data won’t work unless you know the key.

---

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages, and **PAC** protects pointers |
| Allocation reuse validation     | None (freelist pointers raw)                               | **zone_require / zone enforcement**             |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |
| Large allocations handling      | All small allocations managed equally                       | Large ones bypass zones → handled via VM         |

---

## Modern Userland Heap (iOS, macOS — type-aware / xzone malloc)

U novijim Apple OS verzijama (posebno iOS 17+), Apple je uveo sigurniji userland allocator, **xzone malloc** (XZM). Ovo je user-space analog kernel-ovog `kalloc_type`, primenjujući type awareness, metadata izolaciju i memory tagging zaštite.

### Goals & Design Principles

- **Type segregation / type awareness**: grupisati alokacije po tipu ili upotrebi (pointer vs data) kako bi se sprečila type confusion i cross-type reuse.
- **Metadata isolation**: odvojiti heap metadata (npr. free lists, size/state bitove) od payload-a objekata tako da out-of-bounds write-ovi manje verovatno korumpiraju metadata.
- **Guard pages / redzones**: ubaciti ne-mapirane stranice ili padding oko alokacija da se uhvate overflow-i.
- **Memory tagging (EMTE / MIE)**: raditi zajedno sa hardware tagging-om da detektuje use-after-free, out-of-bounds i nevalidne pristupe.
- **Scalable performance**: održati nizak overhead, izbegavati preteranu fragmentaciju i podržavati mnogo alokacija u sekundi sa niskom latencijom.

### Architecture & Components

Ispod su glavni elementi xzone allocator-a:

#### Segment Groups & Zones

- **Segment groups** dele address space po kategorijama upotrebe: npr. `data`, `pointer_xzones`, `data_large`, `pointer_large`.
- Svaka segment grupa sadrži **segments** (VM opsege) koji hostuju alokacije za tu kategoriju.
- Povezan sa svakim segmentom je **metadata slab** (odvojena VM oblast) koja čuva metadata (npr. free/used bitove, size classes) za taj segment. Ova **out-of-line (OOL) metadata** osigurava da metadata nije pomiješana sa payload-om objekata, smanjujući rizik od korupcije iz overflow-a.
- Segmenti se seku na **chunks** (slice-ove) koji se dalje dele na **blocks** (alokacione jedinice). Chunk je vezan za određenu size klasu i segment grupu (tj. svi block-ovi u chunk-u dele istu veličinu & kategoriju).
- Za male / srednje alokacije koristi se fiksno-veličinski chunks; za velike/ogromne, može mapirati odvojeno.

#### Chunks & Blocks

- **Chunk** je region (često više stranica) posvećen alokacijama jedne size klase unutar grupe.
- Unutar chunka, **blocks** su slotovi dostupni za alokacije. Oslobođeni block-ovi se prate putem metadata slab-a — npr. preko bitmap-a ili free list-i koje se čuvaju out-of-line.
- Između chunk-ova (ili unutar njih) mogu biti ubačene **guard slices / guard pages** (npr. ne-mapirane slice-ove) da se uhvate out-of-bounds write-ovi.

#### Type / Type ID

- Svako mesto alokacije (ili poziv malloc, calloc, itd.) ima pridružen **type identifier** (jedan `malloc_type_id_t`) koji kodira koji tip objekta se alocira. Taj type ID se prosleđuje allocator-u, koji ga koristi da izabere koju zonu / segment će služiti alokaciju.
- Zbog toga, čak i ako dve alokacije imaju istu veličinu, one mogu ići u potpuno različite zone ako im tipovi odstupaju.
- U ranijim iOS 17 verzijama, nisu svi API-ji (npr. CFAllocator) bili potpuno type-aware; Apple je rešio neke od tih slabosti u iOS 18.

---

### Allocation & Freeing Workflow

Evo visokog nivoa toka kako alokacija i dealokacija rade u xzone:

1. **malloc / calloc / realloc / typed alloc** se poziva sa veličinom i type ID.
2. Allocator koristi **type ID** da izabere odgovarajući segment group / zonu.
3. Unutar zone/segmenta traži chunk koji ima slobodne blokove tražene veličine.
- Može konsultovati **local caches / per-thread pools** ili **free block lists** iz metadata.
- Ako nema slobodnog bloka, može alocirati novi chunk u toj zoni.
4. Metadata slab se ažurira (free bit se briše, bookkeeping).
5. Ako je memory tagging (EMTE) uključen, vraćenom bloku se dodeljuje **tag**, i metadata se ažurira da odražava njegov „live“ status.
6. Kada se pozove `free()`:
- Block se označi kao oslobođen u metadata (putem OOL slab-a).
- Block može biti stavljen u free list ili pool za ponovnu upotrebu.
- Opcionalno, sadržaj bloka može biti očišćen ili poisan da se smanji curenje podataka ili exploatacija use-after-free.
- Hardverski tag povezan sa blokom može biti invalidiran ili ponovo tagovan.
- Ako ceo chunk postane slobodan (svi block-ovi oslobođeni), allocator može **reclaim** taj chunk (unmap-ovati ga ili vratiti OS-u) pod memorijskim pritiskom.

---

### Security Features & Hardening

Ovo su odbrane ugrađene u moderni userland xzone:

| Feature | Purpose | Notes |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | Prevent overflow from corrupting metadata | Metadata živi u odvojenoj VM oblasti (metadata slab)|
| **Guard pages / unmapped slices** | Catch out-of-bounds writes | Pomaže da se otkriju buffer overflow-i umesto tihog korumpiranja susednih blokova|
| **Type-based segregation** | Prevent cross-type reuse & type confusion | Čak i iste-size alokacije iz različitih tipova idu u različite zone|
| **Memory Tagging (EMTE / MIE)** | Detect invalid access, stale references, OOB, UAF | xzone radi u saradnji sa hardware EMTE u synchronous modu (“Memory Integrity Enforcement”)|
| **Delayed reuse / poisoning / zap** | Reduce chance of use-after-free exploitation | Oslobođeni blokovi mogu biti poison-ovani, zero-ovani ili stavljeni u karantin pre ponovne upotrebe |
| **Chunk reclamation / dynamic unmapping** | Reduce memory waste and fragmentation | Celi chunk-ovi mogu biti unmap-ovani kada nisu u upotrebi |
| **Randomization / placement variation** | Prevent deterministic adjacency | Blokovi u chunk-u i izbor chunk-a mogu imati randomizovane aspekte |
| **Segregation of “data-only” allocations** | Separate allocations that don’t store pointers | Smanjuje napadačevu kontrolu nad metadata ili kontrolnim poljima|

---

### Interaction with Memory Integrity Enforcement (MIE / EMTE)

- Apple-ov MIE (Memory Integrity Enforcement) je hardware + OS okvir koji donosi **Enhanced Memory Tagging Extension (EMTE)** u uvek-uključen, sinhroni režim preko glavnih attack surface-a.
- xzone allocator je temelj MIE u user space: alokacije preko xzone dobijaju tagove, i pristupi su proveravani hardverom.
- U MIE, allocator, dodela taga, upravljanje metadata-om i sprovođenje tajnosti taga su integrisani da osiguraju da greške u memoriji (npr. stale reads, OOB, UAF) budu odmah uhvaćene, a ne iskorišćene kasnije.

---

Ako želite, mogu takođe da generišem cheat-sheet ili dijagram internals xzone za vašu knjigu. Želite li da to napravim sledeće?
::contentReference[oai:20]{index=20}


---

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
