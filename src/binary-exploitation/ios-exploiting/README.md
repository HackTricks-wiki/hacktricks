# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

### 1. **Code Signing** / Runtime Signature Verification
**Introduced early (iPhone OS → iOS)**
これは基本的な防護の一つです: **すべての実行可能コード**（apps, dynamic libraries, JIT-ed code, extensions, frameworks, caches）は Apple の信頼ルートに紐づく証明書チェーンで暗号的に署名されている必要があります。ランタイムでは、バイナリをメモリにロードする前（あるいは特定の境界を跨ぐジャンプを実行する前）にシステムがその署名をチェックします。コードが改変されている（ビット反転、パッチ適用）か署名が無ければ、ロードは失敗します。

- **Thwarts**: exploit チェーンにおける「古典的なペイロード書き込み + 実行」段階；任意コード注入；既存バイナリの改変による悪意あるロジックの挿入。
- **Mechanism detail**:
* Mach-O ローダ（および dynamic linker）はコードページ、セグメント、entitlements、team IDs、そして署名がファイル内容をカバーしているかをチェックします。
* JIT キャッシュや動的生成コードのようなメモリ領域については、Apple はページが署名されているか、特別な API（例: `mprotect` with code-sign checks）経由で検証されることを要求します。
* 署名には entitlements や識別子が含まれ、OS は特定の API や特権機能が特定の entitlements を必要とすることを強制し、それらは偽造できません。

<details>
<summary>Example</summary>
あるプロセスでコード実行を得て、ヒープにシェルコードを書き込みそこにジャンプしようとするとします。iOS では、そのページは実行可能にフラグされるだけでなく code-signature 制約を満たす必要があります。シェルコードは Apple の証明書で署名されていないため、ジャンプは失敗するか、そのメモリ領域を実行可能にする操作が拒否されます。
</details>


### 2. **CoreTrust**
**Introduced around iOS 14+ era (or gradually in newer devices / later iOS)**
CoreTrust はバイナリ（システムとユーザバイナリを含む）の **ランタイム署名検証** を Apple のルート証明書に対して行うサブシステムで、ユーザーランドのキャッシュされた信頼ストアに依存しません。

- **Thwarts**: バイナリのインストール後改ざん、system ライブラリやユーザアプリを入れ替え／パッチして不正化する jailbreak 技術；信頼されたバイナリを悪意ある別物に置き換えてシステムを騙す手口。
- **Mechanism detail**:
* ローカルの信頼データベースや証明書キャッシュを信用する代わりに、CoreTrust は Apple のルートを直接参照するか、安全なチェーンで中間証明書を検証します。
* 既存バイナリのファイルシステム上での改変（例: パッチ）は検出され拒否されます。
* entitlements、team IDs、code signing フラグや他のメタデータをロード時にバイナリに紐づけます。

<details>
<summary>Example</summary>
jailbreak が `SpringBoard` や `libsystem` をパッチしたバージョンに置き換えて永続化を試みても、OS のローダや CoreTrust がチェックすると署名不一致（あるいは entitlements の改変）を検出して実行を拒否します。
</details>


### 3. **Data Execution Prevention (DEP / NX / W^X)**
**Introduced in many OSes earlier; iOS had NX-bit / w^x for a long time**
DEP は writable（データ用）にマークされたページを **非実行** とし、実行可能にマークされたページを **非書き込み** にすることを強制します。単にヒープやスタックにシェルコードを書き込んで実行することはできません。

- **Thwarts**: 直接的なシェルコード実行；古典的なバッファオーバーフロー → 注入シェルコードへジャンプ。
- **Mechanism detail**:
* MMU / ページテーブルによるメモリ保護フラグが分離を強制します。
* writable なページを実行可能にしようとする試みはシステムチェックを誘発し（禁止されるか code-sign 承認が必要になる）ます。
* 多くの場合、ページを実行可能にするには追加の制約やチェックを課す OS の API を経由する必要があります。

<details>
<summary>Example</summary>
オーバーフローでヒープにシェルコードを書き込み、攻撃者が `mprotect(heap_addr, size, PROT_EXEC)` を試みます。しかしシステムは拒否するか、新しいページが code-sign 制約を満たすことを検証します（シェルコードは満たしません）。
</details>

### 4. **Address Space Layout Randomization (ASLR)**
**Introduced in iOS ~4–5 era (roughly iOS 4–5 timeframe)**
ASLR は各プロセス起動毎にライブラリ、heap、stack 等の主要メモリ領域のベースアドレスをランダム化します。gadgets のアドレスは実行毎に変わります。

- **Thwarts**: ROP/JOP の gadget アドレスのハードコーディング；静的な exploit チェーン；既知オフセットへの盲目的なジャンプ。
- **Mechanism detail**:
* 各ロードされたライブラリ / 動的モジュールはランダムなオフセットで rebased されます。
* スタックやヒープのベースポインタは（一定のエントロピー制限内で）ランダム化されます。
* 時には mmap での割当てなど他の領域もランダム化されます。
* information-leak mitigations と組み合わせることで、攻撃者はまずアドレスやポインタを leak してベースアドレスを実行時に判明させる必要があります。

<details>
<summary>Example</summary>
ROP チェーンが `0x….lib + offset` の gadget を期待していても、`lib` は実行毎に別の位置にリロケートされるためハードコードされたチェーンは失敗します。エクスプロイトはまずモジュールのベースアドレスを leak してから gadget アドレスを計算する必要があります。
</details>


### 5. **Kernel Address Space Layout Randomization (KASLR)**
**Introduced in iOS ~ (iOS 5 / iOS 6 timeframe)**
ユーザ ASLR に類似して、KASLR はブート時に **カーネルテキスト** や他のカーネル構造のベースをランダム化します。

- **Thwarts**: カーネルコードやデータの固定位置に依存するカーネルレベルのエクスプロイト；静的なカーネル exploit。
- **Mechanism detail**:
* 各ブートでカーネルのベースアドレスが（ある範囲内で）ランダム化されます。
* `task_structs` や `vm_map` のようなカーネルデータ構造もリロケートまたはオフセットされることがあります。
* 攻撃者はカーネルポインタを leak するか、情報開示脆弱性を使ってオフセットを割り出す必要があります。

<details>
<summary>Example</summary>
ローカル脆弱性がカーネル関数ポインタ（例: `vtable` 内）を `KERN_BASE + offset` に上書きしようとしても、`KERN_BASE` が不明なため正しいアドレスを求める前に leak（例: read プリミティブ）して割り出す必要があります。
</details>


### 6. **Kernel Patch Protection (KPP / AMCC)**
**Introduced in newer iOS / A-series hardware (post around iOS 15–16 era or newer chips)**
KPP（別名 AMCC）はカーネルテキストページの整合性を（ハッシュやチェックサムで）継続的に監視します。許可されたウィンドウ外で改変（パッチ、インラインフック、コード変更）を検出するとカーネルパニックや再起動を引き起こします。

- **Thwarts**: 永続的なカーネルパッチ（カーネル命令の改変）、インラインフック、静的関数の上書き。
- **Mechanism detail**:
* ハードウェアまたはファームウェアモジュールがカーネルテキスト領域を監視します。
* 定期的またはオンデマンドでページを再ハッシュして期待値と比較します。
* 正当なアップデートウィンドウ外で不一致が発生するとデバイスをパニックさせ（悪意あるパッチの持続を避けるため）クラッシュさせます。
* 攻撃者は検出ウィンドウを回避するか、正当なパッチ経路を使う必要があります。

<details>
<summary>Example</summary>
エクスプロイトがカーネル関数のプロローグ（例: `memcmp`）をパッチして呼び出しを傍受しようとしても、KPP はコードページのハッシュが期待値と一致しないことを検出してカーネルパニックを発生させ、パッチが安定する前にデバイスをクラッシュさせます。
</details>


### 7. **Kernel Text Read‐Only Region (KTRR)**
**Introduced in modern SoCs (post ~A12 / newer hardware)**
KTRR はハードウェアで強制される仕組みです: ブート初期に kernel text がロックされると、EL1（カーネル）からその後は読み取り専用になり、コードページへの書き込みを防ぎます。

- **Thwarts**: ブート後に行われるカーネルコードの改変（例: パッチ、インプレースでのコード注入）を EL1 特権で行う試み。
- **Mechanism detail**:
* ブート時（secure/bootloader ステージ）にメモリコントローラやセキュアハードウェアユニットがカーネルテキストを含む物理ページを読み取り専用としてマークします。
* エクスプロイトが完全なカーネル権限を得ても、これらのページを書き換えて命令をパッチすることはできません。
* それらを変更するには、攻撃者はブートチェーン自体を侵害するか、KTRR を破壊しなければなりません。

<details>
<summary>Example</summary>
特権昇格エクスプロイトが EL1 にジャンプしてカーネル関数にトランポリンを書き込もうとしても、KTRR によってページが読み取り専用にロックされているため書き込みは失敗するかフォルトを引き起こし、パッチは適用されません。
</details>


### 8. **Pointer Authentication Codes (PAC)**
**Introduced with ARMv8.3 (hardware), Apple beginning with A12 / iOS ~12+**
- PAC は **ARMv8.3-A** で導入されたハードウェア機能で、ポインタ値（リターンアドレス、関数ポインタ、特定のデータポインタ）の改ざんを検出するために、ポインタの未使用上位ビットに小さな暗号署名（“MAC”）を埋め込みます。
- 署名（“PAC”）はポインタ値に **modifier**（コンテキスト値、例: stack pointer や識別データ）を加えた上で計算されます。これにより同じポインタ値でも異なるコンテキストでは異なる PAC になります。
- 使用時には、そのポインタを参照または分岐する前に **authenticate** 命令が PAC を検査します。有効なら PAC は剥がされ純粋なポインタが得られ、無効ならポインタは “poisoned” になるかフォルトが発生します。
- PAC を生成／検証する鍵は特権レジスタ（EL1, kernel）にありユーザモードから直接読み出せません。
- 多くのシステムでは 64 ビットポインタの全ビットが使われていない（例: 48-bit address space）ため、上位ビットの余剰が PAC を保持しても実効アドレスには影響しません。

#### Architectural Basis & Key Types

- ARMv8.3 は **五つの 128-bit 鍵**（それぞれが 64-bit レジスタ二つで実装）を導入します。
- **APIAKey** — instruction pointers 用（ドメイン “I”, key A）
- **APIBKey** — 二番目の instruction pointer key（ドメイン “I”, key B）
- **APDAKey** — data pointers 用（ドメイン “D”, key A）
- **APDBKey** — data pointers 用（ドメイン “D”, key B）
- **APGAKey** — 汎用（非ポインタデータや他の用途）用

- これらの鍵は特権システムレジスタに格納され（EL1/EL2 等でのみアクセス可能）、ユーザモードからはアクセスできません。
- PAC は暗号関数（ARM は QARMA を示唆）を用いて計算され、入力は以下:
1. ポインタ値（正規化された部分）
2. **modifier**（コンテキスト値、例: salt）
3. 秘密鍵
4. 内部のチューニングロジック
計算結果がポインタ上位ビットに格納された PAC と一致すれば認証成功です。


#### Instruction Families

命名規則は: **PAC** / **AUT** / **XPAC**、その後にドメイン文字です。
- `PACxx` 命令はポインタに署名して PAC を挿入します
- `AUTxx` 命令は認証して PAC を剥がします（検証 + 剥離）
- `XPACxx` 命令は検証せずに剥がします

ドメイン / サフィックス:

| Mnemonic     | Meaning / Domain                      | Key / Domain     | Example Usage in Assembly |
|--------------|-----------------------------------------|--------------------|-----------------------------|
| **PACIA**    | Sign instruction pointer with APIAKey   | “I, A”             | `PACIA X0, X1` — sign pointer in X0 using APIAKey with modifier X1|
| **PACIB**    | Sign instruction pointer with APIBKey   | “I, B”             | `PACIB X2, X3`              |
| **PACDA**    | Sign data pointer with APDAKey           | “D, A”             | `PACDA X4, X5`              |
| **PACDB**    | Sign data pointer with APDBKey           | “D, B”             | `PACDB X6, X7`              |
| **PACG / PACGA** | Generic (non-pointer) signing with APGAKey | “G”         | `PACGA X8, X9, X10` (sign X9 with modifier X10 into X8) |
| **AUTIA**    | Authenticate APIA-signed instruction pointer & strip PAC | “I, A” | `AUTIA X0, X1` — check PAC on X0 using modifier X1, then strip |
| **AUTIB**    | Authenticate APIB domain                 | “I, B”             | `AUTIB X2, X3`               |
| **AUTDA**    | Authenticate APDA-signed data pointer    | “D, A”             | `AUTDA X4, X5`               |
| **AUTDB**    | Authenticate APDB-signed data pointer    | “D, B”             | `AUTDB X6, X7`               |
| **AUTGA**    | Authenticate generic / blob (APGA)        | “G”               | `AUTGA X8, X9, X10` (validate generic) |
| **XPACI**     | Strip PAC (instruction pointer, no validation) | “I”         | `XPACI X0` — remove PAC from X0 (instruction domain) |
| **XPACD**     | Strip PAC (data pointer, no validation)    | “D”             | `XPACD X4` — remove PAC from data pointer in X4 |


There are specialized / alias forms:

- `PACIASP` is shorthand for `PACIA X30, SP` (sign the link register using SP as modifier)
- `AUTIASP` is `AUTIA X30, SP` (authenticate link register with SP)
- Combined forms like `RETAA`, `RETAB` (authenticate-and-return) or `BLRAA` (authenticate & branch) exist in ARM extensions / compiler support.
- Also zero-modifier variants: `PACIZA` / `PACIZB` where the modifier is implicitly zero, etc.

#### Modifiers

modifier の主目的は PAC を **特定のコンテキストに結び付ける** ことで、同じアドレスを別のコンテキストで再利用できないようにすることです。ハッシュに塩を加えるようなものです。

従って:
- **modifier** はコンテキスト値（別のレジスタ）で PAC 計算に混ぜられます。典型的な選択肢は stack pointer (`SP`)、フレームポインタ、あるいはオブジェクト ID です。
- SP を modifier に使うのはリターンアドレス署名で一般的です: PAC は特定のスタックフレームに紐づくため、別のフレームで LR を再利用すると modifier が変わり認証に失敗します。
- 同じポインタ値でも異なる modifier で署名すると異なる PAC になります。
- modifier は必ずしも秘密である必要はありませんが、理想的には攻撃者が制御できない値であるべきです。
- modifier が意味を持たない場合の命令では、ゼロや暗黙の定数を使う形式もあります。

#### Apple / iOS / XNU Customizations & Observations

- Apple の PAC 実装には **per-boot diversifiers** が含まれ、起動ごとに鍵やチューニングが変わりブート間での再利用を防ぎます。
- 彼らはまた **cross-domain mitigations** を含め、ユーザモードで署名された PAC が簡単にカーネルモードで再利用されないようにしています。
- Apple Silicon（M1）ではリバースエンジニアリングにより **nine modifier types** やキー制御用の Apple 固有のシステムレジスタがあることが示されました。
- Apple は多くのカーネルサブシステムで PAC を利用しています: リターンアドレス署名、カーネルデータ内のポインタ整合性、署名されたスレッドコンテキスト等。
- Google Project Zero は強力なメモリ read/write プリミティブがあると一部のカーネル PAC（A keys）を偽造できる可能性を示しました（A12 世代での研究）。Apple は多くの経路を修正しました。
- Apple のシステムでは一部の鍵は **カーネル全体でグローバル** であり、ユーザプロセスはプロセス毎の鍵ランダム性を得ることがあります。

#### PAC Bypasses

1. **Kernel-mode PAC: theoretical vs real bypasses**

-   カーネル PAC 鍵とロジックは厳密に制御されている（特権レジスタ、diversifiers、ドメイン分離）ため、任意の署名済みカーネルポインタを偽造するのは非常に困難です。
-   Azad の 2020 年の "iOS Kernel PAC, One Year Later" は iOS 12-13 で一部の部分的なバイパス（署名ガジェット、署名済み状態の再利用、保護されていない間接分岐など）を報告しましたが、汎用的な完全バイパスは見つかっていません。 [bazad.github.io](https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf)
-   Apple のカスタマイズ（“Dark Magic”）はさらに攻撃対象面を狭めています（ドメイン切替、キーごとの有効化ビット等）。 [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Apple silicon (M1/M2) 上での **kernel PAC bypass CVE-2023-32424** の報告があり、Zecao Cai 等による研究が存在します。 [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   しかしこれらのバイパスは多くの場合非常に特定のガジェットや実装バグに依存しており、一般的な回避策ではありません。

したがってカーネル PAC は **非常に堅牢** と見なされていますが、完璧ではありません。

2. **User-mode / runtime PAC bypass techniques**

これらはより一般的で、PAC の適用やランタイムフレームワークでの使用法の不完全さを突きます。以下はクラス別の説明と例です。

2.1 **Shared Cache / A key issues**

-   **dyld shared cache** は多くのシステムフレームワークとライブラリをプリリンクした大きなブロブです。共有度が高いため、shared cache 内の関数ポインタは既に署名されており多くのプロセスで使われます。攻撃者はこれらの既署名ポインタを「PAC オラクル」として狙います。
-   いくつかのバイパス技術は shared cache に存在する A-key で署名されたポインタを抽出・再利用して PAC を回避しようとします。
-   "No Clicks Required" の講演は shared cache 上のオラクルを構築して相対アドレスを推測し、署名済みポインタと組み合わせて PAC を回避する手法を説明しています。 [saelo.github.io](https://saelo.github.io/presentations/offensivecon_20_no_clicks.pdf)
-   また、ユーザ空間の shared libraries からの関数ポインタの import が PAC によって十分に保護されていないことが見つかり、攻撃者が関数ポインタを署名を変更せずに取得できる事例がありました（Project Zero のバグエントリ）。 [bugs.chromium.org](https://bugs.chromium.org/p/project-zero/issues/detail?id=2044&utm_source=chatgpt.com)

2.2 **dlsym(3) / dynamic symbol resolution**

-   既知のバイパスのひとつに、`dlsym()` を呼んで *既に署名された* 関数ポインタ（A-key で署名、diversifier がゼロ）を取得し、そのまま使用する手法があります。`dlsym` が正当な署名付きポインタを返すため、これを使えば PAC を偽造する必要が回避されます。
-   Epsilon のブログはこの種のバイパスを詳述しており、`dlsym("someSym")` が署名済みポインタを返し間接呼び出しに使える例を示しています。 [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)
-   Synacktiv の "iOS 18.4 --- dlsym considered harmful" は iOS 18.4 のバグを説明しており、`dlsym` が誤った署名（あるいはバグのある diversifier）を返すケースを指摘しています。 [Synacktiv](https://www.synacktiv.com/en/publications/ios-184-dlsym-considered-harmful)
-   dyld 内の論理では: `result->isCode` の場合、返されるポインタを `__builtin_ptrauth_sign_unauthenticated(..., key_asia, 0)` を使ってコンテキストゼロで署名する、という処理が行われています。 [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

従って `dlsym` は user-mode PAC バイパスで頻繁に使われるベクターです。

2.3 **Other DYLD / runtime relocations**

-   DYLD ローダと動的リロケーションのロジックは複雑で、一時的にページを read/write としてマップしてリロケーションを行い、その後 read-only に戻すことがあります。攻撃者はこれらのウィンドウを突きます。Synacktiv の講演は dynamic relocation を使ったタイミングベースの PAC バイパス（"Operation Triangulation"）を解説しています。 [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)
-   DYLD ページは現在 SPRR / VM_FLAGS_TPRO などで保護されていますが、以前のバージョンでは保護が弱いことがありました。 [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)
-   WebKit の exploit チェーンでは DYLD ローダが PAC バイパスのターゲットになることが多く、リロケーションや interposer hook を介した攻撃が多く報告されています。 [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

2.4 **NSPredicate / NSExpression / ObjC / SLOP**

-   ユーザランドのエクスプロイトでは、Objective-C runtime のメソッド（`NSPredicate`, `NSExpression`, `NSInvocation` など）を使って制御呼び出しを隠匿することがあります。
-   PAC 導入前の古い iOS では、**fake NSInvocation** オブジェクトを使って制御されたメモリ上で任意の selector を呼ぶエクスプロイトがありました。PAC 下では修正が必要ですが、SLOP（SeLector Oriented Programming）技術は PAC 環境でも拡張されています。 [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)
-   元の SLOP 技法は偽の invocations を作って ObjC 呼び出しをチェインするもので、ISA や selector ポインタが常に PAC で保護されているわけではない点を突いていました。 [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)
-   ポインタ認証が部分的に適用されている環境では、メソッド／セレクタ／ターゲットポインタが常に PAC で保護されているわけではなく、バイパスの余地が残ることがあります。

#### Example Flow

<details>
<summary>Example Signing & Authenticating</summary>
```
; Example: function prologue / return address protection
my_func:
stp x29, x30, [sp, #-0x20]!        ; push frame pointer + LR
mov x29, sp
PACIASP                            ; sign LR (x30) using SP as modifier
; … body …
mov sp, x29
ldp x29, x30, [sp], #0x20         ; restore
AUTIASP                            ; authenticate & strip PAC
ret

; Example: indirect function pointer stored in a struct
; suppose X1 contains a function pointer
PACDA X1, X2     ; sign data pointer X1 with context X2
STR X1, [X0]      ; store signed pointer

; later retrieval:
LDR X1, [X0]
AUTDA X1, X2       ; authenticate & strip
BLR X1             ; branch to valid target

; Example: stripping for comparison (unsafe)
LDR X1, [X0]
XPACI X1           ; strip PAC (instruction domain)
CMP X1, #some_label_address
BEQ matched_label
```
</details>

<details>
<summary>例</summary>
バッファオーバーフローはスタック上のリターンアドレスを上書きします。攻撃者はターゲットの gadget アドレスを書き込みますが、正しい PAC を計算できないことがあります。関数が戻ると、CPU の `AUTIA` 命令が PAC の不一致でフォルトします。チェーンは失敗します。
Project Zero’s の A12 (iPhone XS) に関する解析は、Apple の PAC がどのように使われているか、攻撃者がメモリの読み書きプリミティブを持っている場合に PAC を偽造する方法を示しました。
</details>


### 9. **Branch Target Identification (BTI)**
**Introduced with ARMv8.5 (later hardware)**
BTI は間接ブランチターゲットをチェックするハードウェア機能です：`blr` や間接的な call/jump を実行する際、ターゲットは **BTI landing pad**（`BTI j` または `BTI c`）で始まる必要があります。landing pad を欠く gadget アドレスにジャンプすると例外が発生します。

LLVM の実装は BTI 命令の三つの変種と、それらがブランチ種にどのように対応するかを記述しています。

| BTI Variant | What it permits (which branch types) | Typical placement / use case |
|-------------|----------------------------------------|-------------------------------|
| **BTI C** | Targets of *call*-style indirect branches (e.g. `BLR`, or `BR` using X16/X17) | Put at entry of functions that may be called indirectly |
| **BTI J** | Targets of *jump*-style branches (e.g. `BR` used for tail calls) | Placed at the beginning of blocks reachable by jump tables or tail-calls |
| **BTI JC** | Acts as both C and J | Can be targeted by either call or jump branches |

- branch target enforcement でコンパイルされたコードでは、コンパイラは各有効な間接ブランチターゲット（関数の先頭やジャンプで到達可能なブロック）に BTI 命令（C, J, または JC）を挿入し、間接ブランチがそれらの場所にしか成功しないようにします。
- **Direct branches / calls**（固定アドレスの `B`, `BL`）は BTI によって制限されません。仮定としてコードページは信頼でき、攻撃者はそれらを変更できない（したがって direct branch は安全）とされています。
- また、**RET / return** 命令は一般に BTI によって制限されないことが多いです。リターンアドレスは PAC や return signing メカニズムで保護されているためです。

#### Mechanism and enforcement

- CPU が “guarded / BTI-enabled” とマークされたページ内で **indirect branch (BLR / BR)** をデコードすると、ターゲットのアドレス先頭命令が許可された BTI（C, J, または JC）であるかをチェックします。そうでなければ **Branch Target Exception** が発生します。
- BTI 命令のエンコーディングは、以前の ARM バージョンで NOPs に予約されていたオペコードを再利用するよう設計されているため、BTI-enabled バイナリは後方互換性を保ちます：BTI をサポートしないハードウェア上ではこれらの命令は NOP として動作します。
- BTI を追加するコンパイラパスは、必要な場所にのみ挿入します：間接的に呼ばれる可能性のある関数、またはジャンプで到達される基本ブロックなどです。
- いくつかのパッチや LLVM のコードは、BTI が *すべて* の基本ブロックに挿入されるわけではなく、switch / jump table などから到達可能な潜在的なブランチターゲットに対してのみ挿入されることを示しています。

#### BTI + PAC synergy

PAC はポインタ値（ソース）を保護し、間接呼び出し／リターンのチェーンが改竄されていないことを保証します。

BTI は有効なポインタであっても正しくマーキングされたエントリポイントのみをターゲットにできるようにします。

組み合わせることで、攻撃者は正しい PAC を持つ有効なポインタに加え、ターゲット側にも BTI が配置されている必要があり、exploit gadget を構築する難易度が上がります。

#### Example


<details>
<summary>例</summary>
あるエクスプロイトが `0xABCDEF` の gadget にピボットしようとしますが、その先頭が `BTI c` で始まっていません。CPU は `blr x0` を実行した際にターゲットをチェックし、有効な landing pad が含まれていないためフォルトします。したがって多くの gadget は BTI プレフィックスがない限り使えなくなります。
</details>


### 10. **Privileged Access Never (PAN) & Privileged Execute Never (PXN)**
**Introduced in more recent ARMv8 extensions / iOS support (for hardened kernel)**

#### PAN (Privileged Access Never)

- **PAN** は **ARMv8.1-A** で導入された機能で、**特権コード**（EL1 または EL2）が **ユーザがアクセス可能な（EL0）メモリ** を **読み書き** することを防ぎます。PAN は明示的に無効化されない限り有効です。
- 目的：カーネルが騙されたり侵害された場合でも、まず PAN をクリアしない限りカーネルが任意にユーザポインタを逆参照できないようにし、`ret2usr` 型のエクスプロイトやユーザ制御バッファの誤用のリスクを低減します。
- PAN が有効なとき（PSTATE.PAN = 1）、特権の load/store 命令が「EL0 でアクセス可能」とマークされた仮想アドレスへアクセスすると権限フォルトが発生します。
- カーネルが正当にユーザ空間メモリにアクセスする必要がある場合（例：ユーザバッファへのデータコピー）、カーネルは一時的に **PAN を無効化** するか、「非特権 load/store」命令に切り替えてそのアクセスを許可する必要があります。
- Linux on ARM64 では、PAN サポートは 2015 年頃に導入されました：カーネルパッチが機能検出を追加し、`get_user` / `put_user` 等を PAN をクリアするバリアントに置き換えました。

**重要なニュアンス / 制限 / バグ**
- Siguza らが指摘しているように、ARM の設計には仕様上の不備（あるいは曖昧さ）があり、**execute-only user mappings**（`--x`）は **PAN をトリガーしない** 可能性があります。言い換えれば、ユーザページが実行可能だが読み取り権限を持たない場合、カーネルの読み取り試行が PAN をバイパスすることがあり得ます。これはアーキテクチャが「EL0 でアクセス可能」と見なす条件を可読性ではなく実行可能性で扱うために起こることがあります。これにより一部の ARMv8+ 実装では PAN バイパスが発生します。
- そのため、iOS / XNU が execute-only なユーザページを許可している（例えば一部の JIT や code-cache の構成）場合、カーネルは PAN が有効でもそれらから読み出してしまう可能性があります。これは一部のシステムで既知の微妙な悪用可能領域です。

#### PXN (Privileged eXecute Never)

- **PXN** はページテーブルフラグ（ページテーブルエントリのリーフまたはブロックエントリ）で、そのページが **特権モードで実行不可**（つまり EL1 が実行するときに不可）であることを示します。
- PXN はカーネル（またはその他の特権コード）がユーザ空間ページの命令を実行したりジャンプしたりするのを防ぎます。実質的に、特権レベルでの制御フローがユーザメモリに逸脱するのを止めます。
- PAN と組み合わせると以下が保証されます：
  1. カーネルはデフォルトでユーザデータを読み書きできない（PAN）
  2. カーネルはユーザ空間コードを実行できない（PXN）
- ARMv8 のページテーブル形式では、リーフエントリに `PXN` ビット（および非特権実行不可の `UXN`）が属性ビットとして存在します。

したがって、カーネルがユーザメモリを指す壊れた関数ポインタを持っていても、そこへ分岐しようとすれば PXN ビットがフォルトを引き起こします。

#### Memory-permission model & how PAN and PXN map to page table bits

PAN / PXN の動作を理解するには、ARM の翻訳と権限モデル（簡略化）を確認する必要があります：

- 各ページまたはブロックエントリは、読み書きや特権・非特権のための **AP[2:1]** や、実行不可制限のための **UXN / PXN** ビットなどの属性フィールドを持ちます。
- PSTATE.PAN が 1（有効）である場合、ハードウェアは修正されたセマンティクスを強制します：EL0 によってアクセス可能とマークされたページへの特権アクセスは拒否（フォルト）されます。
- 前述のバグのため、読み取り権限を持たない実行専用ページは特定の実装では「EL0 でアクセス可能」と見なされない可能性があり、これにより PAN をバイパスされることがあります。
- ページの PXN ビットが設定されていれば、たとえ高い特権レベルからの命令フェッチであっても実行は禁止されます。

#### Kernel usage of PAN / PXN in a hardened OS (e.g. iOS / XNU)

ハードニングされたカーネル設計（Apple が使うような設計）では：

- カーネルはデフォルトで PAN を有効にします（特権コードのアクセスを制約）。
- ユーザバッファを正当に読んだり書いたりする経路（syscall のデータコピー、I/O、read/write user pointer 等）では、カーネルは一時的に **PAN を無効化**するか、ユーザメモリアクセスを上書きする特別な命令を使います。
- ユーザデータへのアクセスを終えたら、PAN を再び有効にする必要があります。
- PXN はページテーブルで強制されます：ユーザページは PXN = 1（カーネルはそれらを実行できない）、カーネルページは PXN = 0（カーネルコードは実行可能）となります。
- カーネルは実行フローがユーザメモリ領域に流れるようなコードパスがないことを確実にする必要があります（これができないと PXN を回避する可能性が出ます）— したがって「ユーザ制御の shellcode にジャンプする」ことに頼るエクスプロイトチェーンはブロックされます。

前述の execute-only ページによる PAN バイパスのため、実運用システムでは Apple は execute-only なユーザページを無効にするか、仕様の弱点を回避するためのパッチを当てる可能性があります。

#### Attack surfaces, bypasses, and mitigations

- **PAN bypass via execute-only pages**: 前述のように仕様のギャップにより、読み取り権限を持たない実行専用ユーザページが PAN をトリガーしない場合があります。これにより攻撃者は「execute-only」セクション経由でデータを提供する異例のパスを得られることがあります。
- **Temporal window exploit**: カーネルが必要以上に長く PAN を無効化すると、レースや悪意ある経路がそのウィンドウを利用して意図しないユーザメモリアクセスを行う可能性があります。
- **Forgotten re-enable**: コードパスが PAN を再有効化するのを忘れると、その後のカーネル操作が誤ってユーザメモリへアクセスしてしまう可能性があります。
- **Misconfiguration of PXN**: ページテーブルがユーザページに PXN を設定していない、あるいはユーザコードページを誤ってマップしていると、カーネルはユーザ空間コードを実行するよう騙され得ます。
- **Speculation / side-channels**: 投機的実行を類推したバイパスのように、PAN / PXN チェックの一時的な回避を引き起こすマイクロアーキテクチャ副作用が存在するかもしれません（ただしそのような攻撃は CPU 設計に強く依存します）。
- **Complex interactions**: JIT、shared memory、just-in-time code region などの高度な機能では、カーネルがユーザマップ領域で特定のメモリアクセスや実行を許可する必要があり、PAN/PXN 制約下でそれらを安全に設計するのは難しい問題です。

#### Example

<details>
<summary>コード例</summary>
以下はユーザメモリアクセスの周りで PAN を有効化／無効化する擬似アセンブリ列と、どのようにフォルトが発生するかを示す図示的な例です。
```  
// Suppose kernel entry point, PAN is enabled (privileged code cannot access user memory by default)

; Kernel receives a syscall with user pointer in X0
; wants to read an integer from user space
mov   X1, X0        ; X1 = user pointer

; disable PAN to allow privileged access to user memory
MSR   PSTATE.PAN, #0   ; clear PAN bit, disabling the restriction

ldr   W2, [X1]       ; now allowed load from user address

; re-enable PAN before doing other kernel logic
MSR   PSTATE.PAN, #1   ; set PAN

; ... further kernel work ...

; Later, suppose an exploit corrupts a pointer to a user-space code page and jumps there
BR    X3             ; branch to X3 (which points into user memory)

; Because the target page is marked PXN = 1 for privileged execution,
; the CPU throws an exception (fault) and rejects execution
```
If the kernel had **not** set PXN on that user page, then the branch might succeed — which would be insecure.

カーネルがそのユーザページに対してPXNを**設定していなかった**場合、そのブランチは成功する可能性があり — それは安全ではありません。

If the kernel forgets to re-enable PAN after user memory access, it opens a window where further kernel logic might accidentally read/write arbitrary user memory.

カーネルがユーザメモリへのアクセス後にPANを再有効化するのを忘れると、以降のカーネルロジックが誤って任意のユーザメモリを読み書きしてしまう余地を生じます。

If the user pointer is into an execute-only page (user page with only execute permission, no read/write), under the PAN spec bug, `ldr W2, [X1]` might **not** fault even with PAN enabled, enabling a bypass exploit, depending on implementation.

ユーザポインタが実行専用ページ（実行のみ許可、読み/書き不可）を指している場合、PAN仕様のバグの下では、`ldr W2, [X1]` がPAN有効時でもフォルトを起こさず（**起こさない**ことがあり）、実装次第でバイパスを可能にすることがあります。

</details>

<details>
<summary>Example</summary>
A kernel vulnerability tries to take a user-provided function pointer and call it in kernel context (i.e. `call user_buffer`). Under PAN/PXN, that operation is disallowed or faults.

カーネルの脆弱性がユーザ提供の関数ポインタを取り、それをカーネルコンテキストで呼び出そうとする（例: `call user_buffer`）。PAN/PXNのもとでは、その操作は許可されないかフォルトします。
</details>

---

### 11. **Top Byte Ignore (TBI) / Pointer Tagging**
**Introduced in ARMv8.5 / newer (or optional extension)**
TBI means the top byte (most-significant byte) of a 64-bit pointer is ignored by address translation. This lets OS or hardware embed **tag bits** in the pointer’s top byte without affecting the actual address.

- TBI stands for **Top Byte Ignore** (sometimes called *Address Tagging*). It is a hardware feature (available in many ARMv8+ implementations) that **ignores the top 8 bits** (bits 63:56) of a 64-bit pointer when performing **address translation / load/store / instruction fetch**.
- In effect, the CPU treats a pointer `0xTTxxxx_xxxx_xxxx` (where `TT` = top byte) as `0x00xxxx_xxxx_xxxx` for the purposes of address translation, ignoring (masking off) the top byte. The top byte can be used by software to store **metadata / tag bits**.
- This gives software “free” in-band space to embed a byte of tag in each pointer without altering which memory location it refers to.
- The architecture ensures that loads, stores, and instruction fetch treat the pointer with its top byte masked (i.e. tag stripped off) before performing the actual memory access.

Thus TBI decouples the **logical pointer** (pointer + tag) from the **physical address** used for memory operations.

TBI（Top Byte Ignore）は、64ビットポインタの最上位バイト（最上位8ビット）をアドレス変換時に無視することを意味します。これにより、OSやハードウェアはポインタの最上位バイトに**タグビット**を埋め込んでも、実際のアドレスに影響を与えずに扱えます。

- TBIは**Top Byte Ignore**（時に *Address Tagging* とも呼ばれる）を表します。多くのARMv8+実装で利用可能なハードウェア機能で、アドレス変換 / load/store / instruction fetch を行う際に64ビットポインタの**最上位8ビット**（ビット63:56）を無視します。
- 実際には、CPUはポインタ `0xTTxxxx_xxxx_xxxx`（`TT` がトップバイト）をアドレス変換の目的上 `0x00xxxx_xxxx_xxxx` と見なします。トップバイトはソフトウェアが**メタデータ / タグビット**を格納するために使えます。
- これにより、ソフトウェアはポインタが参照するメモリ位置を変えずに、各ポインタに1バイトのタグをインバンドで埋め込む「無料の」領域を得られます。
- アーキテクチャは、実際のメモリアクセスを行う前に、ロード／ストア／命令フェッチがポインタの最上位バイトをマスク（すなわちタグを剥がした状態）して扱うことを保証します。

したがって、TBIはメモリ操作で使われる**論理ポインタ**（ポインタ＋タグ）と**実際のアドレス**を切り離します。

#### Why TBI: Use cases and motivation

- **Pointer tagging / metadata**: You can store extra metadata (e.g. object type, version, bounds, integrity tags) in that top byte. When you later use the pointer, the tag is ignored at hardware level, so you don’t need to strip manually for the memory access.
- **Memory tagging / MTE (Memory Tagging Extension)**: TBI is the base hardware mechanism that MTE builds on. In ARMv8.5, the **Memory Tagging Extension** uses bits 59:56 of the pointer as a **logical tag** and checks it against an **allocation tag** stored in memory.
- **Enhanced security & integrity**: By combining TBI with pointer authentication (PAC) or runtime checks, you can force not just the pointer value but also the tag to be correct. An attacker overwriting a pointer without the correct tag will produce a mismatched tag.
- **Compatibility**: Because TBI is optional and tag bits are ignored by hardware, existing untagged code continues to operate normally. The tag bits effectively become “don’t care” bits for legacy code.

#### Example
<details>
<summary>Example</summary>
A function pointer included a tag in its top byte (say `0xAA`). An exploit overwrites the pointer low bits but neglects the tag, so when the kernel verifies or sanitizes, the pointer fails or is rejected.

関数ポインタの最上位バイトにタグ（例: `0xAA`）が含まれていた場合。エクスプロイトがポインタの下位ビットだけを上書きしてタグを無視すると、カーネルが検証やサニタイズを行った際にタグが一致せず、ポインタは失敗したり拒否されたりします。
</details>

---

### 12. **Page Protection Layer (PPL)**
**Introduced in late iOS / modern hardware (iOS ~17 / Apple silicon / high-end models)** (some reports show PPL circa macOS / Apple silicon, but Apple is bringing analogous protections to iOS)

- PPL is designed as an **intra-kernel protection boundary**: even if the kernel (EL1) is compromised and has read/write capabilities, **it should not be able to freely modify** certain **sensitive pages** (especially page tables, code-signing metadata, kernel code pages, entitlements, trust caches, etc.).
- It effectively creates a **“kernel within the kernel”** — a smaller trusted component (PPL) with **elevated privileges** that alone can modify protected pages. Other kernel code must call into PPL routines to effect changes.
- This reduces the attack surface for kernel exploits: even with full arbitrary R/W/execute in kernel mode, exploit code must also somehow get into the PPL domain (or bypass PPL) to modify critical structures.
- On newer Apple silicon (A15+ / M2+), Apple is transitioning to **SPTM (Secure Page Table Monitor)**, which in many cases replaces PPL for page-table protection on those platforms.

PPLは**カーネル内部の保護境界**として設計されています：カーネル（EL1）が侵害され読み書き権限を持っていたとしても、特定の**機密性の高いページ**（ページテーブル、code-sign メタデータ、カーネルコードページ、entitlements、trust caches 等）を自由に改変できるべきではない、という考えです。

- 事実上、PPLは「カーネルの中のカーネル」を作り出します — より小さく信頼されたコンポーネント（PPL）で、保護されたページを単独で変更できる**昇格した特権**を持ちます。他のカーネルコードは変更を行うためにPPLルーチンを呼び出す必要があります。
- これによりカーネルエクスプロイトの攻撃対象が狭まり、カーネルモードで任意のR/W/Executeが得られても、重要構造を変更するにはPPLドメインに入るかPPLをバイパスする必要があります。
- 新しいApple silicon（A15+ / M2+）では、Appleは多くの場合ページテーブル保護のためにPPLの代わりに**SPTM (Secure Page Table Monitor)** に移行しています。

Here’s how PPL is believed to operate, based on public analysis:

公開解析に基づく、PPLがどのように動作すると考えられているかの概要は次の通りです。

#### Use of APRR / permission routing (APRR = Access Permission ReRouting)

- Apple hardware uses a mechanism called **APRR (Access Permission ReRouting)**, which allows page table entries (PTEs) to contain small indices, rather than full permission bits. Those indices are mapped via APRR registers to actual permissions. This allows dynamic remapping of permissions per domain.
- PPL leverages APRR to segregate privilege within kernel context: only the PPL domain is permitted to update the mapping between indices and effective permissions. That is, when non-PPL kernel code writes a PTE or tries to flip permission bits, the APRR logic disallows it (or enforces read-only mapping).
- PPL code itself runs in a restricted region (e.g. `__PPLTEXT`) which is normally non-executable or non-writable until entry gates temporarily allow it. The kernel calls PPL entry points (“PPL routines”) to perform sensitive operations.

#### Gate / Entry & Exit

- When the kernel needs to modify a protected page (e.g. change permissions of a kernel code page, or modify page tables), it calls into a **PPL wrapper** routine, which does validation and then transitions into the PPL domain. Outside that domain, the protected pages are effectively read-only or non-modifiable by the main kernel.
- During PPL entry, the APRR mappings are adjusted so that memory pages in the PPL region are set to **executable & writable** within PPL. Upon exit, they are returned to read-only / non-writable. This ensures that only well-audited PPL routines can write to protected pages.
- Outside PPL, attempts by kernel code to write to those protected pages will fault (permission denied) because the APRR mapping for that code domain doesn’t permit writing.

#### Protected page categories

The pages that PPL typically protects include:

- Page table structures (translation table entries, mapping metadata)
- Kernel code pages, especially those containing critical logic
- Code-sign metadata (trust caches, signature blobs)
- Entitlement tables, signature enforcement tables
- Other high-value kernel structures where a patch would allow bypassing signature checks or credentials manipulation

The idea is that even if the kernel memory is fully controlled, the attacker cannot simply patch or rewrite these pages, unless they also compromise PPL routines or bypass PPL.

#### Use of APRR / permission routing の説明

- Appleのハードウェアは**APRR (Access Permission ReRouting)** と呼ばれる仕組みを使用します。これにより、PTE（ページテーブルエントリ）は完全な許可ビットの代わりに小さなインデックスを含めることができます。これらのインデックスはAPRRレジスタを介して実際の権限にマッピングされます。ドメインごとに動的に権限を再マッピングできる点が利点です。
- PPLはこのAPRRを活用してカーネルコンテキスト内の特権を分離します：インデックスと実際の権限のマッピングを更新できるのはPPLドメインだけです。つまり、非PPLのカーネルコードがPTEを書き換えたり権限ビットを反転しようとすると、APRRロジックがそれを拒否（または読み取り専用のマッピングを強制）します。
- PPLコード自体は制限された領域（例: `__PPLTEXT`）で動作し、通常はエントリゲートが一時的に許可するまで実行不可または書き込み不可です。カーネルは敏感な操作を行うためにPPLエントリポイント（“PPL routines”）を呼び出します。

#### Gate / Entry & Exit の説明

- カーネルが保護されたページを変更する必要があるとき（例：カーネルコードページの権限を変える、またはページテーブルを変更する等）、カーネルは検証を行う**PPLラッパ**ルーチンを呼び出し、それからPPLドメインへ遷移します。そのドメインの外では、保護ページは実質的にメインカーネルからは読み取り専用または変更不可能です。
- PPLへのエントリ中に、APRRマッピングが調整され、PPL領域内のメモリページがPPL内で**実行可能かつ書き込み可能**に設定されます。エグジット時にはそれらは読み取り専用／書き込み不可に戻されます。これにより監査されたPPLルーチンだけが保護ページへ書き込めることが保証されます。
- PPL外では、カーネルコードがそれら保護ページへ書き込みを試みるとフォルト（権限拒否）します。これはそのコードドメインのAPRRマッピングが書き込みを許可していないためです。

#### 保護対象ページのカテゴリ

PPLが通常保護するページには以下が含まれます：

- ページテーブル構造（変換テーブルエントリ、マッピングメタデータ）
- カーネルコードページ（特に重要なロジックを含むページ）
- code-sign メタデータ（trust caches、署名ブロブ）
- Entitlementテーブル、署名適用テーブル
- 署名チェックのバイパスや資格情報操作が可能になるようなその他の重要なカーネル構造

考え方としては、カーネルメモリが完全に制御されていても、攻撃者が単にこれらのページをパッチしたり上書きしたりすることはできず、PPLルーチンを侵害するかPPLをバイパスしない限り不可能、ということです。

#### Known Bypasses & Vulnerabilities

1. **Project Zero’s PPL bypass (stale TLB trick)**

- A public writeup by Project Zero describes a bypass involving **stale TLB entries**.
- The idea:

1. Allocate two physical pages A and B, mark them as PPL pages (so they are protected).
2. Map two virtual addresses P and Q whose L3 translation table pages come from A and B.
3. Spin a thread to continuously access Q, keeping its TLB entry alive.
4. Call `pmap_remove_options()` to remove mappings starting at P; due to a bug, the code mistakenly removes the TTEs for both P and Q, but only invalidates the TLB entry for P, leaving Q’s stale entry live.
5. Reuse B (page Q’s table) to map arbitrary memory (e.g. PPL-protected pages). Because the stale TLB entry still maps Q’s old mapping, that mapping remains valid for that context.
6. Through this, the attacker can put writable mapping of PPL-protected pages in place without going through PPL interface.

- This exploit required fine control of physical mapping and TLB behavior. It demonstrates that a security boundary relying on TLB / mapping correctness must be extremely careful about TLB invalidations and mapping consistency.

- Project Zero commented that bypasses like this are subtle and rare, but possible in complex systems. Still, they regard PPL as a solid mitigation.

2. **Other potential hazards & constraints**

- If a kernel exploit can directly enter PPL routines (via calling the PPL wrappers), it might bypass restrictions. Thus argument validation is critical.
- Bugs in the PPL code itself (e.g. arithmetic overflow, boundary checks) can allow out-of-bounds modifications inside PPL. Project Zero observed that such a bug in `pmap_remove_options_internal()` was exploited in their bypass.
- The PPL boundary is irrevocably tied to hardware enforcement (APRR, memory controller), so it's only as strong as the hardware implementation.

#### 既知のバイパスと脆弱性

1. **Project Zero の PPL バイパス（stale TLB trick）**

- Project Zeroによる公開レポートは、**スタールした（古い）TLBエントリ**を含むバイパスについて記述しています。
- 概要:

1. 物理ページAとBを2つ確保し、それらをPPLページとしてマーク（保護）。
2. L3変換テーブルページがAとBから来る2つの仮想アドレスPとQをマップする。
3. スレッドを回してQへ継続的にアクセスし、QのTLBエントリを生かし続ける。
4. `pmap_remove_options()` を呼んでPから始まるマッピングを削除する；バグによりコードはPとQの両方のTTEを誤って削除するが、TLB無効化はPのみ行われ、Qの古いエントリが残る。
5. B（Qのテーブルページ）を再利用して任意のメモリ（例：PPLで保護されたページ）をマップする。古いTLBエントリがQの古いマッピングをまだ指しているため、そのマッピングはそのコンテキストで有効のままになる。
6. これにより、攻撃者はPPLインターフェースを経ずにPPL保護ページの書き込み可能なマッピングを配置できる。

- このエクスプロイトは物理マッピングとTLBの挙動を細かく制御することを必要としました。これは、TLBやマッピングの正確さに依存するセキュリティ境界がTLB無効化とマッピングの整合性について非常に慎重である必要があることを示しています。

- Project Zeroは、この種のバイパスは微妙で稀だが複雑なシステムでは可能であるとコメントしています。それでも彼らはPPLを有効な緩和策と見なしています。

2. **その他の潜在的危険と制約**

- カーネルのエクスプロイトがPPLラッパを呼び出して直接PPLルーチンに入れる場合、制限をバイパスできる可能性があります。したがって引数の検証が重要です。
- PPLコード自体に存在するバグ（例：算術オーバーフロー、境界チェックの欠如）は、PPL内部での境界外修正を許してしまう可能性があります。Project Zeroは`pmap_remove_options_internal()`のそのようなバグがバイパスに利用されたことを観察しました。
- PPL境界はハードウェア強制（APRR、メモリコントローラ）に不可逆的に結び付けられているため、実装されるハードウェアの堅牢さに依存します。

#### Example
<details>
<summary>Code Example</summary>
Here’s a simplified pseudocode / logic showing how a kernel might call into PPL to modify protected pages:

以下は、カーネルが保護ページを変更するためにPPLを呼び出す際の簡略化した擬似コード／ロジックの例です：
</details>
```c
// In kernel (outside PPL domain)
function kernel_modify_pptable(pt_addr, new_entry) {
// validate arguments, etc.
return ppl_call_modify(pt_addr, new_entry)  // call PPL wrapper
}

// In PPL (trusted domain)
function ppl_call_modify(pt_addr, new_entry) {
// temporarily enable write access to protected pages (via APRR adjustments)
aprr_set_index_for_write(PPL_INDEX)
// perform the modification
*pt_addr = new_entry
// restore permissions (make pages read-only again)
aprr_restore_default()
return success
}

// If kernel code outside PPL does:
*pt_addr = new_entry  // a direct write
// It will fault because APRR mapping for non-PPL domain disallows write to that page
```
kernelは多くの通常操作を実行できるが、protected mappingsを変更したりコードをpatchできるのは`ppl_call_*`ルーチン経由の場合のみである。
</details>

<details>
<summary>例</summary>
kernel exploitはentitlementテーブルを上書きしようとしたり、kernel signature blobを改変してcode-signの強制を無効化しようとする。  
そのページはPPLで保護されているため、PPLインターフェースを経由しない書き込みはブロックされる。したがってkernelでコード実行できても、code-signの制約を回避したりcredential dataを任意に変更したりすることはできない。  
iOS 17+の一部デバイスでは、PPL管理ページをさらに分離するためにSPTMが使用される。
</details>

#### PPL → SPTM / Replacements / Future

- On Apple’s modern SoCs (A15 or later, M2 or later), Apple supports **SPTM** (Secure Page Table Monitor), which **replaces PPL** for page table protections.
- Apple calls out in documentation: “Page Protection Layer (PPL) and Secure Page Table Monitor (SPTM) enforce execution of signed and trusted code … PPL manages the page table permission overrides … Secure Page Table Monitor replaces PPL on supported platforms.”
- SPTMのアーキテクチャは、おそらくより多くのポリシー強制をkernelの制御外にあるより高い特権のモニタに移し、信頼境界をさらに縮小する。

### MTE | EMTE | MIE

Here’s a higher-level description of how EMTE operates under Apple’s MIE setup:

1. **Tag assignment**
- When memory is allocated (e.g. in kernel or user space via secure allocators), a **secret tag** is assigned to that block.
- The pointer returned to the user or kernel includes that tag in its high bits (using TBI / top byte ignore mechanisms).

2. **Tag checking on access**
- Whenever a load or store is executed using a pointer, the hardware checks that the pointer’s tag matches the memory block’s tag (allocation tag). If mismatch, it faults immediately (since synchronous).
- Because it's synchronous, there is no “delayed detection” window.

3. **Retagging on free / reuse**
- When memory is freed, the allocator changes the block’s tag (so older pointers with old tags no longer match).
- A use-after-free pointer would therefore have a stale tag and mismatch when accessed.

4. **Neighbor-tag differentiation to catch overflows**
- Adjacent allocations are given distinct tags. If a buffer overflow spills into neighbor’s memory, tag mismatch causes a fault.
- This is especially powerful in catching small overflows that cross boundary.

5. **Tag confidentiality enforcement**
- Apple must prevent tag values being leaked (because if attacker learns the tag, they could craft pointers with correct tags).
- They include protections (microarchitectural / speculative controls) to avoid side-channel leakage of tag bits.

6. **Kernel and user-space integration**
- Apple uses EMTE not just in user-space but also in kernel / OS-critical components (to guard kernel against memory corruption).
- The hardware/OS ensures tag rules apply even when kernel is executing on behalf of user space.

<details>
<summary>例</summary>
```
Allocate A = 0x1000, assign tag T1
Allocate B = 0x2000, assign tag T2

// pointer P points into A with tag T1
P = (T1 << 56) | 0x1000

// Valid store
*(P + offset) = value // tag T1 matches allocation → allowed

// Overflow attempt: P’ = P + size_of_A (into B region)
*(P' + delta) = value
→ pointer includes tag T1 but memory block has tag T2 → mismatch → fault

// Free A, allocator retags it to T3
free(A)

// Use-after-free:
*(P) = value
→ pointer still has old tag T1, memory region is now T3 → mismatch → fault
```
</details>

#### 制約と課題

- **Intrablock overflows**: オーバーフローが同じ割り当て内にとどまり（境界を越えない）タグが同一のままなら、tag mismatch は検出しない可能性がある。
- **Tag width limitation**: タグに使えるビット数は限られている（例: 4ビットなど、小さい名前空間）。
- **Side-channel leaks**: タグビットが cache / speculative execution 経由で leaked できると、攻撃者は有効なタグを学習して回避する可能性がある。Apple の tag confidentiality enforcement はこれを緩和することを目的としている。
- **Performance overhead**: 各 load/store ごとのタグチェックはコストがかかるため、Apple はハードウェア側で最適化してオーバーヘッドを低く抑える必要がある。
- **Compatibility & fallback**: 古いハードウェアや EMTE をサポートしない部分ではフォールバックが必要になる。Apple は MIE をサポートがあるデバイスでのみ有効にしていると主張している。
- **Complex allocator logic**: アロケータはタグの管理、retagging、境界のアライン、誤タグ衝突の回避などを扱う必要がある。アロケータロジックのバグは脆弱性を導入する可能性がある。
- **Mixed memory / hybrid areas**: 一部のメモリは untagged（レガシー）で残ることがあり、相互運用性が複雑になる。
- **Speculative / transient attacks**: 多くのマイクロアーキテクチャ保護と同様に、speculative execution や micro-op の融合が一時的にチェックを回避したりタグビットを漏らしたりする可能性がある。
- **Limited to supported regions**: Apple は EMTE をカーネルやセキュリティ重要サブシステムなど選択された高リスク領域にのみ適用する可能性があり、全域に適用されるとは限らない。

---

## Key enhancements / differences compared to standard MTE

Here are the improvements and changes Apple emphasizes:

| Feature | Original MTE | EMTE (Apple’s enhanced) / MIE |
|---|---|---|
| **Check mode** | Supports synchronous and asynchronous modes. In async, tag mismatches are reported later (delayed)| Apple insists on **synchronous mode** by default—tag mismatches are caught immediately, no delay/race windows allowed.|
| **Coverage of non-tagged memory** | Accesses to non-tagged memory (e.g. globals) may bypass checks in some implementations | EMTE requires that accesses from a tagged region to non-tagged memory also validate tag knowledge, making it harder to bypass by mixing allocations.|
| **Tag confidentiality / secrecy** | Tags might be observable or leaked via side channels | Apple adds **Tag Confidentiality Enforcement**, which attempts to prevent leakage of tag values (via speculative side-channels etc.).|
| **Allocator integration & retagging** | MTE leaves much of allocator logic to software | Apple’s secure typed allocators (kalloc_type, xzone malloc, etc.) integrate with EMTE: when memory is allocated or freed, tags are managed at fine granularity.|
| **Always-on by default** | In many platforms, MTE is optional or off by default | Apple enables EMTE / MIE by default on supported hardware (e.g. iPhone 17 / A19) for kernel and many user processes.|

Apple はハードウェアとソフトウェアの両方をコントロールしているため、EMTE を厳密に適用し、パフォーマンス上の問題やサイドチャネルの穴を閉じやすい。

---

## How EMTE works in practice (Apple / MIE)

Here’s a higher-level description of how EMTE operates under Apple’s MIE setup:

1. **Tag assignment**
- メモリが割り当てられると（カーネルや secure allocators 経由）、そのブロックに対して **secret tag** が割り当てられる。
- ユーザやカーネルに返されるポインタは、そのタグを上位ビットに含む（TBI / top byte ignore 機構を使用）。

2. **Tag checking on access**
- ポインタを用いて load/store が実行されると、ハードウェアはポインタのタグがメモリブロックのタグ（allocation tag）と一致するかをチェックする。ミスマッチがあれば即座にフォルトする（同期モードのため）。
- 同期モードなので「検出の遅延」ウィンドウは存在しない。

3. **Retagging on free / reuse**
- メモリが free されると、アロケータはそのブロックのタグを変更する（古いタグを持つポインタはもう一致しない）。
- そのため use-after-free ポインタは古いタグを持ち、アクセス時にミスマッチとなる。

4. **Neighbor-tag differentiation to catch overflows**
- 隣接する割り当てには異なるタグが与えられる。バッファオーバーフローが隣接領域に侵入すると、タグミスマッチでフォルトが発生する。
- 境界を越える小さなオーバーフローを検出するのに特に有効。

5. **Tag confidentiality enforcement**
- 攻撃者がタグ値を知ると正しいタグを持つポインタを作成できるため、タグ値の漏洩を防ぐ必要がある。
- Apple はタグビットのサイドチャネル漏洩を防ぐための対策（マイクロアーキテクチャ／speculative 制御など）を含めている。

6. **Kernel and user-space integration**
- Apple は EMTE をユーザ空間だけでなくカーネル／OS 重要コンポーネントにも適用している（カーネルのメモリ破壊防御）。
- ハードウェアと OS は、ユーザ処理を代行する場合でもタグルールが適用されるよう保証する。

EMTE は MIE に組み込まれているため、Apple は主要な攻撃面に対して同期モードで EMTE を利用しており、単なるオプトインやデバッグモードではない。

---

## Exception handling in XNU

When an **exception** occurs (e.g., `EXC_BAD_ACCESS`, `EXC_BAD_INSTRUCTION`, `EXC_CRASH`, `EXC_ARM_PAC`, etc.), the **Mach layer** of the XNU kernel is responsible for intercepting it before it becomes a UNIX-style **signal** (like `SIGSEGV`, `SIGBUS`, `SIGILL`, ...).

This process involves multiple layers of exception propagation and handling before reaching user space or being converted to a BSD signal.


### Exception Flow (High-Level)

1.  **CPU triggers a synchronous exception** (e.g., invalid pointer dereference, PAC failure, illegal instruction, etc.).

2.  **Low-level trap handler** runs (`trap.c`, `exception.c` in XNU source).

3.  The trap handler calls **`exception_triage()`**, the core of the Mach exception handling.

4.  `exception_triage()` decides how to route the exception:

-   First to the **thread's exception port**.

-   Then to the **task's exception port**.

-   Then to the **host's exception port** (often `launchd` or `ReportCrash`).

If none of these ports handle the exception, the kernel may:

-   **Convert it into a BSD signal** (for user-space processes).

-   **Panic** (for kernel-space exceptions).


### Core Function: `exception_triage()`

The function `exception_triage()` routes Mach exceptions up the chain of possible handlers until one handles it or until it's finally fatal. It's defined in `osfmk/kern/exception.c`.
```c
void exception_triage(exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt);
```
**典型的な呼び出しフロー:**

`exception_triage()
└── exception_deliver()
├── exception_deliver_thread()
├── exception_deliver_task()
└── exception_deliver_host()`

すべて失敗すると → `bsd_exception()` によって処理され → `SIGSEGV` のようなシグナルに変換される。


### 例外ポート

各 Mach オブジェクト（thread、task、host）は、例外メッセージが送られる **例外ポート** を登録できる。

これらは API によって定義されている:
```
task_set_exception_ports()
thread_set_exception_ports()
host_set_exception_ports()
```
Each exception port has:

-   A **mask**（どの例外を受け取りたいか）
-   A **port name**（メッセージを受け取る Mach ポート）
-   A **behavior**（カーネルがメッセージを送る方法）
-   A **flavor**（どのスレッド状態を含めるか）


### Debuggers and Exception Handling

**デバッガ**（例: LLDB）は、対象の task や thread に **例外ポート** を設定します。通常は `task_set_exception_ports()` を使います。

**例外が発生したとき：**

-   Mach メッセージがデバッガプロセスに送られる。
-   デバッガは例外を **処理する**（再開、レジスタを変更、命令をスキップ）か **処理しない** かを決められる。
-   デバッガが処理しなければ、例外は次のレベルに伝播する（task → host）。


### Flow of `EXC_BAD_ACCESS`

1.  スレッドが無効なポインタを逆参照 → CPU が Data Abort を発生させる。

2.  カーネルの trap ハンドラが `exception_triage(EXC_BAD_ACCESS, ...)` を呼ぶ。

3.  メッセージは次へ送られる：

-   Thread port →（デバッガがブレークポイントを傍受できる）。

-   デバッガが無視 → Task port →（プロセスレベルのハンドラ）。

-   無視されると → Host port（通常は ReportCrash）。

4.  誰も処理しなければ → `bsd_exception()` が `SIGSEGV` に変換する。


### PAC Exceptions

Pointer Authentication（PAC）の検証が失敗した（署名不一致）場合、特別な Mach 例外が発生する：

-   **`EXC_ARM_PAC`**（タイプ）
-   コードには詳細が含まれることがある（例：キーの種類、ポインタの種類）。

バイナリにフラグ **`TFRO_PAC_EXC_FATAL`** が付いていると、カーネルは PAC の失敗を **致命的** と見なし、デバッガの傍受をバイパスする。これは攻撃者がデバッガを使って PAC チェックを回避するのを防ぐためで、**platform binaries** に対して有効になる。


### Software Breakpoints

ソフトウェアブレークポイント（x86 の `int3`、ARM64 の `brk`）は **意図的なフォルトを発生させる** ことで実装される。\
デバッガはこれを例外ポート経由で捕捉する：

-   命令ポインタやメモリを変更する。
-   元の命令を復元する。
-   実行を再開する。

この同じ仕組みで PAC 例外を「キャッチ」することが可能だが、**`TFRO_PAC_EXC_FATAL`** が設定されている場合は常にデバッガに到達しない。


### Conversion to BSD Signals

誰も例外を受け入れなければ：

-   カーネルは `task_exception_notify() → bsd_exception()` を呼ぶ。

-   これが Mach 例外をシグナルにマップする：

| Mach Exception | Signal |
| --- | --- |
| EXC_BAD_ACCESS | SIGSEGV or SIGBUS |
| EXC_BAD_INSTRUCTION | SIGILL |
| EXC_ARITHMETIC | SIGFPE |
| EXC_SOFTWARE | SIGTRAP |
| EXC_BREAKPOINT | SIGTRAP |
| EXC_CRASH | SIGKILL |
| EXC_ARM_PAC | SIGILL (on non-fatal) |


### Key Files in XNU Source

-   `osfmk/kern/exception.c` → `exception_triage()`、`exception_deliver_*()` のコア。

-   `bsd/kern/kern_sig.c` → シグナル配信ロジック。

-   `osfmk/arm64/trap.c` → 低レベルの trap ハンドラ。

-   `osfmk/mach/exc.h` → 例外コードと構造体。

-   `osfmk/kern/task.c` → Task の例外ポート設定。

---

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

カーネルは固定サイズの「zone」に分かれたゾーンアロケータ（`kalloc`）を使用していた。各 zone は単一のサイズクラスの割り当てのみを保持する。

スクリーンショットから：

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Very small kernel structs, pointers.                                        |
| `default.kalloc.32`  | 32 bytes     | Small structs, object headers.                                              |
| `default.kalloc.64`  | 64 bytes     | IPC messages, tiny kernel buffers.                                          |
| `default.kalloc.128` | 128 bytes    | Medium objects like parts of `OSObject`.                                    |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Large structures, IOSurface/graphics metadata.                              |

仕組み：

- 各割り当て要求は最も近い zone サイズに **切り上げ** られる。（例：50 バイトの要求は `kalloc.64` zone に入る）
- 各 zone のメモリは **freelist**（空きリスト）で管理され、カーネルが解放したチャンクはその zone に戻されていた。
- もし 64 バイトバッファをオーバーフローすると、**同じ zone にある次のオブジェクト** を上書きしてしまう。

これがなぜ **heap spraying / feng shui** が有効だったかの理由：同じサイズクラスの割り当てをスプレーすることで、オブジェクトの隣接関係を予測できた。


### The freelist

各 kalloc zone の内部では、解放されたオブジェクトは直接システムに返されず、freelist（利用可能チャンクの連結リスト）に入れられていた。

- チャンクが解放されると、カーネルはそのチャンクの先頭にポインタを書き込む → 同じ zone の次の空きチャンクのアドレス。

- zone は最初の空きチャンクへの HEAD ポインタを保持する。

- 割り当ては常に現在の HEAD を使う：

1. HEAD をポップ（そのメモリを呼び出し元に返す）。

2. HEAD = HEAD->next に更新（解放チャンクのヘッダに保存されている）。

- 解放はチャンクをプッシュする：

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

つまり freelist は解放されたメモリ自身の中に構築された単なる連結リストだった。

通常時：
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### freelist を悪用する

Because the first 8 bytes of a free chunk = freelist pointer, an attacker could corrupt it:

1. **Heap overflow** により隣接する freed chunk に書き込みを行い、その “next” pointer を上書きする。

2. **Use-after-free** により freed object に書き込みを行い、その “next” pointer を上書きする。

Then, on the next allocation of that size:

- allocator は破損したチャンクをポップする。

- 攻撃者が供給した “next” pointer に従う。

- 任意のメモリへのポインタを返し、fake object primitives や targeted overwrite を可能にする。

Visual example of freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
この freelist 設計はハードニング前に悪用を非常に効果的にしていました：heap sprays による予測可能な隣接、raw pointer freelist links、型分離が無かったため攻撃者は UAF/overflow バグを任意のカーネルメモリ制御へとエスカレートできました。

### Heap Grooming / Feng Shui
heap grooming の目的はヒープレイアウトを整形して、攻撃者が overflow や use-after-free を誘発したときにターゲット（victim）オブジェクトが攻撃者制御下のオブジェクトのすぐ隣に配置されるようにすることです。\
そうすることで、メモリ破損が発生した際に攻撃者は確実に victim オブジェクトを制御データで上書きできます。

**手順:**

1. Spray allocations (fill the holes)
- 時間が経つとカーネルヒープは断片化します：古いオブジェクトが free された箇所に穴ができます。
- 攻撃者はまずダミーの大量割当を行いこれらの隙間を埋め、ヒープを「詰めた」予測可能な状態にします。

2. Force new pages
- 穴が埋まると、次の割当はゾーンに追加された新しいページから供給されます。
- 新しいページはオブジェクトがバラバラに散らばるのではなくクラスタ化されることを意味します。
- これにより攻撃者は近傍の配置をより良く制御できます。

3. Place attacker objects
- 攻撃者は再度スプレーを行い、それらの新しいページに攻撃者制御下のオブジェクトを大量に作ります。
- これらのオブジェクトは同じゾーンに属するためサイズや配置が予測可能です。

4. Free a controlled object (make a gap)
- 攻撃者は意図的に自分のオブジェクトの一つを free します。
- これによりヒープに「穴」が生まれ、アロケータはそのサイズの次の割当にその穴を再利用します。

5. Victim object lands in the hole
- 攻撃者はカーネルに対して victim オブジェクト（破壊したいもの）を割り当てさせます。
- その穴が freelist 上で最初に使えるスロットであるため、victim は攻撃者が free した正確な位置に置かれます。

6. Overflow / UAF into victim
- これで攻撃者は victim の周囲に攻撃者制御下のオブジェクトを配置できます。
- 自分のオブジェクトからの overflow（あるいは freed オブジェクトの再利用）で、victim のメモリフィールドを確実に選択した値で上書きできます。

**なぜこれが効くのか**：

- ゾーンアロケータの予測可能性：同じサイズの割当は常に同じゾーンから来ます。
- Freelist の挙動：新しい割当は最も最近に free されたチャンクをまず再利用します。
- Heap sprays：攻撃者は予測可能な内容でメモリを埋め、レイアウトを制御します。
- 結果：攻撃者は victim がどこに落ちるか、どのデータが隣接するかをコントロールできます。

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple はアロケータをハードニングし、heap grooming を大幅に困難にしました：

### 1. From Classic kalloc to kalloc_type
- **Before**: 各サイズクラス（16, 32, 64, … 1280, など）に対して単一の `kalloc.<size>` ゾーンが存在していました。任意のそのサイズのオブジェクトはそこに置かれ、→ 攻撃者オブジェクトが特権カーネルオブジェクトの隣に座ることが可能でした。
- **Now**:
- カーネルオブジェクトは **typed zones**（`kalloc_type`）から割り当てられます。
- 各オブジェクト型（例：`ipc_port_t`, `task_t`, `OSString`, `OSData`）は同じサイズでも専用のゾーンを持ちます。
- オブジェクト型 ↔ ゾーンのマッピングはコンパイル時に **kalloc_type system** から生成されます。

攻撃者はもはや制御されたデータ（`OSData`）が同じサイズの機密カーネルオブジェクト（`task_t`）の隣に確実に配置されることを保証できません。

### 2. Slabs and Per-CPU Caches
- ヒープは **slabs**（そのゾーン向けに固定サイズのチャンクに切り出されたページ）に分割されています。
- 各ゾーンは競合を減らすための **per-CPU cache** を持ちます。
- 割当パス:
1. per-CPU cache を試す。
2. 空なら global freelist から取る。
3. freelist が空なら新しい slab（1ページ以上）を割り当てる。
- **利点**：この分散化により alloc の応答が異なる CPU のキャッシュから満たされることがあり、heap sprays の決定性が低くなります。

### 3. Randomization inside zones
- ゾーン内では、free された要素が単純な FIFO/LIFO 順で戻されるわけではありません。
- 現代の XNU は **encoded freelist pointers**（Linux の safe-linking に類似、~iOS 14 で導入）を使用します。
- 各 freelist ポインタはゾーン毎の秘密の cookie で **XOR エンコード**されています。
- これにより、もし書き込みプリミティブを得ても攻撃者が偽の freelist ポインタを作ることを防ぎます。
- 一部の割当は **slab 内での配置がランダム化**されており、スプレーでは隣接が保証されません。

### 4. Guarded Allocations
- ある種の重要なカーネルオブジェクト（例：credentials、task 構造体）は **guarded zones** に割り当てられます。
- これらのゾーンは slab 間に **guard pages**（マップされていないメモリ）を挿入したり、オブジェクト周辺に **redzones** を使ったりします。
- ガードページへの overflow はフォルトを引き起こし → サイレントな破損の代わりに即時パニックを発生させます。

### 5. Page Protection Layer (PPL) and SPTM
- freed オブジェクトを制御できたとしても、カーネルメモリ全体を改変できるわけではありません:
- **PPL (Page Protection Layer)** は特定領域（例：コード署名データ、entitlements）をカーネル自身に対しても **read-only** に強制します。
- **A15/M2+ デバイス** では、この役割は **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)** によって置き換え/拡張されています。
- これらのハードウェア強制レイヤにより、単一のヒープ破損から重要なセキュリティ構造の任意パッチへエスカレートすることが困難になります。
- **(追加/強化)**：カーネルはポインタ（特に関数ポインタ、vtable）保護のために **PAC (Pointer Authentication Codes)** を使用し、偽造や破壊を難しくしています。
- **(追加/強化)**：ゾーンは **zone_require / zone enforcement** を強制する場合があり、つまり free されたオブジェクトは正しい typed zone を通じてのみ返されるべきで、異なるゾーンへの不正な cross-zone free はパニックを引き起こすか拒否されます。（Apple はこの点をメモリ安全に関する投稿で示唆しています）

### 6. Large Allocations
- すべての割当が `kalloc_type` を通るわけではありません。
- 非常に大きな要求（約16 KB 以上）は typed zones をバイパスし、ページ割当経由で **kernel VM (kmem)** から直接提供されます。
- これらは予測しづらいですが、他のオブジェクトとスラブを共有しないため exploitable の可能性は低くなります。

### 7. Allocation Patterns Attackers Target
これらの保護があっても、攻撃者は依然として以下を狙います：
- **Reference count objects**：retain/release カウンタを改ざんできれば use-after-free を引き起こせる可能性があります。
- **Objects with function pointers (vtables)**：これを破壊すれば依然として制御フローが得られます。
- **Shared memory objects (IOSurface, Mach ports)**：これらは user ↔ kernel を橋渡しするため依然として攻撃対象です。

しかし — 以前のように `OSData` をスプレーして `task_t` の隣に来ることを期待することはできません。成功するには **type-specific bugs** や **info leaks** が必要です。

### Example: Allocation Flow in Modern Heap

Suppose userspace calls into IOKit to allocate an `OSData` object:

1. **Type lookup** → `OSData` maps to `kalloc_type_osdata` zone (size 64 bytes).
2. Check per-CPU cache for free elements.
- If found → return one.
- If empty → go to global freelist.
- If freelist empty → allocate a new slab (page of 4KB → 64 chunks of 64 bytes).
3. Return chunk to caller.

**Freelist pointer protection**:
- 各 freed チャンクは次の free チャンクのアドレスを格納しますが、それは秘密鍵でエンコードされています。
- そのフィールドを攻撃者データで上書きしても鍵を知らなければ無効です。

---

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages, and **PAC** protects pointers |
| Allocation reuse validation     | None (freelist pointers raw)                               | **zone_require / zone enforcement**             |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |
| Large allocations handling      | All small allocations managed equally                       | Large ones bypass zones → handled via VM         |

---

## Modern Userland Heap (iOS, macOS — type-aware / xzone malloc)

近年の Apple OS（特に iOS 17+）では、より安全なユーザランドアロケータ **xzone malloc**（XZM）が導入されました。これはカーネルの `kalloc_type` に相当するユーザ空間版で、タイプ認識、メタデータ分離、メモリタグ付け保護を適用します。

### Goals & Design Principles

- **Type segregation / type awareness**: 割当を型や用途（ポインタ対データ）でグループ化し、type confusion やクロスタイプ再利用を防ぐ。
- **Metadata isolation**: ヒープメタデータ（例：free lists、size/state ビット）をオブジェクトペイロードから分離し、アウトオブバウンズ書き込みによるメタデータ破損の可能性を低減。
- **Guard pages / redzones**: 割当の周囲にマップされていないページやパディングを挿入しオーバーフローを検出。
- **Memory tagging (EMTE / MIE)**: ハードウェアタグ付けと連携して UAF、OOB、無効アクセスを検出。
- **Scalable performance**: 低オーバーヘッドを維持し、過度の断片化を避け、低レイテンシで多数の割当をサポート。

### Architecture & Components

以下は xzone アロケータの主な要素です：

#### Segment Groups & Zones

- **Segment groups** は使用カテゴリ（例：`data`, `pointer_xzones`, `data_large`, `pointer_large`）ごとにアドレス空間を分割します。
- 各 segment group はそのカテゴリ用の割当をホストする **segments**（VM 範囲）を含みます。
- 各 segment には **metadata slab**（別の VM 領域）が関連付けられ、そこに free/used ビットやサイズクラスなどのメタデータが格納されます。この **out-of-line (OOL) metadata** によりメタデータがオブジェクトペイロードと混在しないため、オーバーフローによる影響が軽減されます。
- Segments は **chunks**（スライス）に分割され、さらに **blocks**（割当ユニット）に細分されます。チャンクは特定のサイズクラスと segment group に紐づきます（つまりチャンク内の全ブロックは同じサイズとカテゴリを共有）。
- 小〜中サイズの割当では固定サイズチャンクを使用し、大きな割当は別途マップする場合があります。

#### Chunks & Blocks

- **chunk** はあるサイズクラス内の割当に専用された領域（多くは複数ページ）です。
- チャンク内では **blocks** が割当スロットで、free されたブロックは metadata slab（例：ビットマップや out-of-line の free list）で管理されます。
- チャンク間（または内部）には **guard slices / guard pages**（例：マップされていないスライス）が挿入され、OOB 書き込みを検出します。

#### Type / Type ID

- 各割当サイト（または malloc, calloc の呼び出し）は **type identifier**（`malloc_type_id_t`）に紐づき、どのタイプのオブジェクトが割り当てられているかをエンコードします。その type ID はアロケータに渡され、適切な zone / segment を選択するために使用されます。
- このため、同じサイズでもタイプが異なればまったく異なるゾーンに入ることがあります。
- iOS 17 の初期バージョンではすべての API（例：CFAllocator）が完全に type-aware ではなかったため弱点があり、Apple は iOS 18 でこれらの問題を一部修正しました。

---

### Allocation & Freeing Workflow

以下は xzone における割当と解放の高レベルフローです：

1. **malloc / calloc / realloc / typed alloc** がサイズと type ID を指定して呼ばれる。
2. アロケータは **type ID** を使って適切な segment group / zone を選択する。
3. その zone/segment 内で要求サイズの空きブロックがあるチャンクを探す。
- ローカルキャッシュ / per-thread プールや metadata の free block lists を参照することがあります。
- 空きが無ければその zone に新しいチャンクを割り当てることがあります。
4. metadata slab が更新され（free ビットがクリアされ、帳簿が更新される）。
5. メモリタグ付け（EMTE）が有効な場合、返されるブロックにタグが割り当てられ、メタデータはその「ライブ」状態を反映するよう更新されます。
6. `free()` が呼ばれると：
- ブロックは metadata 上で freed とマークされます（OOL slab 経由）。
- ブロックは free list に入れられるか再利用のためプールされます。
- 任意でブロック内容はクリアまたは poisoning されてデータ漏えいや UAF 悪用を減らします。
- ブロックに紐づくハードウェアタグは無効化または再タグ付けされます。
- チャンク内の全ブロックが解放されると、アロケータはメモリプレッシャ下でそのチャンクを **reclaim**（アンマップまたは OS に返す）することがあります。

---

### Security Features & Hardening

以下はモダンなユーザランド xzone に組み込まれた防御です：

| Feature | Purpose | Notes |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | Overflow がメタデータを破壊するのを防ぐ | メタデータは別 VM 領域（metadata slab）に存在 |
| **Guard pages / unmapped slices** | OOB 書き込みを検出する | 近接ブロックを静かに破壊する代わりにオーバーフローを検出 |
| **Type-based segregation** | クロスタイプ再利用・type confusion を防ぐ | 同サイズでもタイプが異なれば別ゾーンへ |
| **Memory Tagging (EMTE / MIE)** | 無効アクセス、古い参照、OOB、UAF を検出 | xzone はハードウェア EMTE と同期モードで連携（“Memory Integrity Enforcement”） |
| **Delayed reuse / poisoning / zap** | UAF 悪用の可能性を低減 | Freed ブロックは poison / zero / quarantine されることがある |
| **Chunk reclamation / dynamic unmapping** | メモリ浪費と断片化を低減 | 未使用チャンクはアンマップされる可能性あり |
| **Randomization / placement variation** | 決定的な隣接を防ぐ | チャンク内のブロックやチャンク選択にランダム要素あり |
| **Segregation of “data-only” allocations** | ポインタを持たない割当を分離 | メタデータや制御フィールドに対する攻撃者の影響を減らす |

---

### Interaction with Memory Integrity Enforcement (MIE / EMTE)

- Apple の MIE（Memory Integrity Enforcement）はハードウェア＋OS フレームワークで、**Enhanced Memory Tagging Extension (EMTE)** を主要な攻撃面で常時オンの同期モードとして提供します。
- xzone アロケータはユーザ空間における MIE の基盤であり：xzone で行われる割当はタグを受け取り、アクセスはハードウェアによりチェックされます。
- MIE ではアロケータ、タグ割当、メタデータ管理、タグの秘匿性強制が統合されており、メモリエラー（古い参照、OOB、UAF 等）が即座に検出され、後で悪用されるのを防ぎます。

---

もしよければ、xzone 内部のチートシートや図をあなたの本用に生成することもできます。次にそれを生成しましょうか？
::contentReference[oaicite:20]{index=20}


---

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
