# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

### 1. **Code Signing** / Runtime Signature Verification
**Introduced early (iPhone OS → iOS)**
To jedna z podstawowych ochron: **wszystki wykonywalny kod** (apps, dynamic libraries, JIT-ed code, extensions, frameworks, caches) musi być kryptograficznie podpisany przez łańcuch certyfikatów z zaufaniem Apple. W czasie działania, przed załadowaniem binarki do pamięci (lub przed wykonaniem skoku przez pewne granice), system sprawdza jej podpis. Jeżeli kod został zmodyfikowany (zmiana bitów, łatki) lub nie jest podpisany, załadowanie się nie powiedzie.

- **Powstrzymuje**: etap „classic payload drop + execute” w łańcuchach exploitów; arbitrary code injection; modyfikowanie istniejącej binarki w celu wstawienia złośliwej logiki.
- **Szczegóły mechanizmu**:
* Mach-O loader (i dynamic linker) sprawdzają strony kodu, segmenty, entitlements, team IDs oraz to, że podpis obejmuje zawartość pliku.
* Dla regionów pamięci takich jak JIT caches lub dynamicznie generowany kod, Apple wymusza, żeby strony były podpisane lub walidowane przez specjalne API (np. `mprotect` z code-sign checks).
* Podpis zawiera entitlements i identyfikatory; OS wymusza, że niektóre API lub uprzywilejowane możliwości wymagają konkretnych entitlements, których nie da się sfałszować.

<details>
<summary>Example</summary>
Załóżmy, że exploit uzyska wykonanie kodu w procesie i próbuje zapisać shellcode na heapie i skoczyć do niego. Na iOS taka strona musiałaby być oznaczona jako executable **i** spełniać ograniczenia code-signature. Ponieważ shellcode nie jest podpisany certyfikatem Apple, skok się nie powiedzie lub system odrzuci ustawienie tego regionu pamięci jako wykonywalnego.
</details>


### 2. **CoreTrust**
**Introduced around iOS 14+ era (or gradually in newer devices / later iOS)**
CoreTrust to podsystem wykonujący **runtime signature validation** binarek (w tym systemowych i użytkownika) względem **root certyfikatu Apple**, zamiast polegać na lokalnych store’ach zaufania w userlandzie.

- **Powstrzymuje**: post-install tampering binarek, techniki jailbreakingowe próbujące podmiany lub łatania bibliotek systemowych czy aplikacji; oszukanie systemu przez zastąpienie zaufanych binarek złośliwymi odpowiednikami.
- **Szczegóły mechanizmu**:
* Zamiast ufać lokalnej bazie zaufania lub cache’owi certyfikatów, CoreTrust odwołuje się do rootu Apple lub weryfikuje certyfikaty pośrednie w bezpiecznym łańcuchu.
* Zapewnia wykrywanie i odrzucanie modyfikacji (np. w filesystemie) istniejących binarek.
* Wiąże entitlements, team IDs, flagi code signing i inne metadane z binarką w czasie ładowania.

<details>
<summary>Example</summary>
Jailbreak mógłby spróbować zastąpić `SpringBoard` lub `libsystem` podrasowaną wersją, by uzyskać persistencję. Ale gdy loader OS lub CoreTrust sprawdza, wykryje niezgodność podpisu (lub zmodyfikowane entitlements) i odmówi wykonania.
</details>


### 3. **Data Execution Prevention (DEP / NX / W^X)**
**Introduced in many OSes earlier; iOS had NX-bit / w^x for a long time**
DEP wymusza, że strony oznaczone jako writable (dla danych) są **non-executable**, a strony oznaczone jako executable są **non-writable**. Nie można po prostu zapisać shellcode’a na heapie lub stosie i go wykonać.

- **Powstrzymuje**: bezpośrednie wykonanie shellcode’u; klasyczny buffer-overflow → skok do wstrzykniętego shellcode’u.
- **Szczegóły mechanizmu**:
* MMU / flagi ochrony pamięci (przez page tables) wymuszają separację.
* Każda próba oznaczenia writable strony jako executable wywołuje kontrolę systemową (i jest albo zabroniona, albo wymaga code-sign approval).
* W wielu przypadkach ustawienie stron jako executable wymaga użycia API OS, które narzuca dodatkowe ograniczenia lub sprawdzenia.

<details>
<summary>Example</summary>
Overflow zapisuje shellcode na heapie. Atakujący próbuje `mprotect(heap_addr, size, PROT_EXEC)` by uczynić go wykonywalnym. Ale system odmawia lub waliduje, że nowa strona musi przejść code-sign constraints (czego shellcode nie potrafi).
</details>

### 4. **Address Space Layout Randomization (ASLR)**
**Introduced in iOS ~4–5 era (roughly iOS 4–5 timeframe)**
ASLR losuje base addresses kluczowych regionów pamięci: libraries, heap, stack itd. przy każdym uruchomieniu procesu. Adresy gadgetów zmieniają się między uruchomieniami.

- **Powstrzymuje**: hardcodowanie adresów gadgetów dla ROP/JOP; statyczne łańcuchy exploitów; ślepe skoki do znanych offsetów.
- **Szczegóły mechanizmu**:
* Każda załadowana biblioteka / moduł dynamiczny jest rebazowany na losowym offsecie.
* Bazowe wskaźniki stosu i heapu są losowane (w pewnych ograniczeniach entropii).
* Czasami inne regiony (np. mmap allocations) też są losowane.
* W połączeniu z information-leak mitigations, zmusza atakującego do najpierw wycieku adresu lub wskaźnika, by odkryć base addresses w czasie działania.

<details>
<summary>Example</summary>
Łańcuch ROP spodziewa się gadgetu w `0x….lib + offset`. Ale ponieważ `lib` jest relokowany inaczej przy każdym uruchomieniu, hardcodowany łańcuch zawiedzie. Exploit musi najpierw leak’ować base address modułu, zanim obliczy adresy gadgetów.
</details>


### 5. **Kernel Address Space Layout Randomization (KASLR)**
**Introduced in iOS ~ (iOS 5 / iOS 6 timeframe)**
Analogicznie do user ASLR, KASLR losuje base kernel text i inne struktury jądra przy starcie systemu.

- **Powstrzymuje**: kernel-level exploit’y polegające na stałych lokalizacjach kodu lub danych jądra; statyczne exploity kernelowe.
- **Szczegóły mechanizmu**:
* Przy każdym bootowaniu base jądra jest losowane (w pewnym zakresie).
* Struktury danych jądra (np. `task_structs`, `vm_map` itd.) również mogą być relokowane lub mieć przesunięcia.
* Atakujący muszą najpierw leak’ować wskaźniki jądra lub użyć podatności ujawniającej informacje, by obliczyć offsety przed przejęciem struktur czy kodu jądra.

<details>
<summary>Example</summary>
Lokalna podatność ma na celu uszkodzenie wskaźnika funkcji jądra (np. w `vtable`) na `KERN_BASE + offset`. Ale ponieważ `KERN_BASE` jest nieznane, atakujący musi najpierw leak’ować go (np. przez read primitive) zanim obliczy poprawny adres do nadpisania.
</details>


### 6. **Kernel Patch Protection (KPP / AMCC)**
**Introduced in newer iOS / A-series hardware (post around iOS 15–16 era or newer chips)**
KPP (aka AMCC) ciągle monitoruje integralność stron z kodem jądra (przez hash lub checksum). Jeśli wykryje manipulacje (patche, inline hooks, modyfikacje kodu) poza dozwolonymi oknami, wywołuje kernel panic lub reboot.

- **Powstrzymuje**: trwałe łatanie jądra (modyfikacje instrukcji jądra), inline hooks, statyczne nadpisywanie funkcji.
- **Szczegóły mechanizmu**:
* Moduł sprzętowy lub firmware monitoruje regiony tekstu jądra.
* Periodycznie lub na żądanie re-hashuje strony i porównuje z oczekiwanymi wartościami.
* Jeśli wystąpią niezgodności poza benign update windows, powoduje panic urządzenia (by zapobiec trwałemu złośliwemu patchowi).
* Atakujący muszą albo unikać okien wykrywania, albo użyć legitnych ścieżek patchowania.

<details>
<summary>Example</summary>
Exploit próbuje załatać prolog funkcji jądra (np. `memcmp`) by przechwycić wywołania. KPP zauważa, że hash strony kodu już nie pasuje i wywołuje kernel panic, crashując urządzenie zanim patch utrwali się.
</details>


### 7. **Kernel Text Read‐Only Region (KTRR)**
**Introduced in modern SoCs (post ~A12 / newer hardware)**
KTRR to mechanizm egzekwowany przez sprzęt: raz zablokowany wczesnym etapem bootu kernel text staje się read-only z poziomu EL1 (kernel), uniemożliwiając dalsze zapisy na stronach kodu.

- **Powstrzymuje**: wszelkie modyfikacje kodu jądra po bootie (np. patching, in-place code injection) na poziomie uprawnień EL1.
- **Szczegóły mechanizmu**:
* Podczas bootu (w secure/bootloader stage) kontroler pamięci (lub bezpieczny moduł sprzętowy) oznacza fizyczne strony zawierające kernel text jako read-only.
* Nawet jeśli exploit zdobędzie pełne uprawnienia jądra, nie może zapisać do tych stron, by zmienić instrukcje.
* Aby je zmodyfikować, atakujący musiałby najpierw skompromitować łańcuch bootowania lub podważyć sam KTRR.

<details>
<summary>Example</summary>
Exploit eskalujący uprawnienia skacze do EL1 i próbuje napisać trampoline w funkcji jądra (np. w handlerze syscall). Ale ponieważ strony są zablokowane jako read-only przez KTRR, zapis się nie udaje (lub wywołuje fault), więc łatka nie jest stosowana.
</details>


### 8. **Pointer Authentication Codes (PAC)**
**Introduced with ARMv8.3 (hardware), Apple beginning with A12 / iOS ~12+**
- PAC to funkcja sprzętowa wprowadzona w **ARMv8.3-A** do wykrywania manipulacji wartościami wskaźników (adresy powrotu, function pointers, niektóre data pointers) przez osadzanie małego kryptograficznego podpisu („MAC”) w nieużywanych wysokich bitach wskaźnika.
- Podpis („PAC”) jest obliczany na podstawie wartości wskaźnika plus **modifier** (wartość kontekstowa, np. stack pointer lub inne odróżniające dane). Dzięki temu ta sama wartość wskaźnika w różnych kontekstach ma inny PAC.
- Przy użyciu, przed dereferencją lub branchingiem przez taki wskaźnik, instrukcja **authenticate** sprawdza PAC. Jeśli poprawny, PAC jest usuwany i uzyskuje się „czysty” wskaźnik; jeśli niepoprawny, wskaźnik zostaje „poisoned” (lub jest podnoszony fault).
- Klucze używane do generowania/walidacji PAC są przechowywane w uprzywilejowanych rejestrach (EL1, kernel) i nie są dostępne z user mode.
- Ponieważ nie wszystkie 64 bity wskaźnika są używane w wielu systemach (np. 48-bitowa przestrzeń adresowa), górne bity są „wolne” i mogą pomieścić PAC bez zmiany efektywnego adresu.

#### Architectural Basis & Key Types

- ARMv8.3 wprowadza **pięć 128-bitowych kluczy** (każdy implementowany przez dwa 64-bitowe rejestry systemowe) dla pointer authentication.
- **APIAKey** — dla instruction pointers (domena „I”, klucz A)
- **APIBKey** — drugi klucz dla instruction pointers (domena „I”, klucz B)
- **APDAKey** — dla data pointers (domena „D”, klucz A)
- **APDBKey** — dla data pointers (domena „D”, klucz B)
- **APGAKey** — „generic” key, do podpisywania non-pointer danych lub zastosowań ogólnych

- Te klucze są przechowywane w uprzywilejowanych rejestrach systemowych (dostępnych tylko w EL1/EL2 itd.), niedostępnych z user mode.
- PAC jest obliczane przez funkcję kryptograficzną (ARM sugeruje QARMA jako algorytm) używając:
1. Wartości wskaźnika (część kanoniczna)
2. **modifier** (wartość kontekstowa, jak sól)
3. Tajny klucz
4. Pewna wewnętrzna logika tweak
Jeśli wynikowy PAC pasuje do tego, co jest zapisane w górnych bitach wskaźnika, uwierzytelnienie się powiedzie.

#### Instruction Families

Konwencja nazewnictwa: **PAC** / **AUT** / **XPAC**, potem litery domen.
- `PACxx` instrukcje **sign**ują wskaźnik i wstawiają PAC
- `AUTxx` instrukcje **authenticate + strip** (walidują i usuwają PAC)
- `XPACxx` instrukcje **strip** bez walidacji

Domeny / sufiksy:

| Mnemonic     | Meaning / Domain                      | Key / Domain     | Example Usage in Assembly |
|--------------|-----------------------------------------|--------------------|-----------------------------|
| **PACIA**    | Sign instruction pointer with APIAKey   | “I, A”             | `PACIA X0, X1` — sign pointer in X0 using APIAKey with modifier X1|
| **PACIB**    | Sign instruction pointer with APIBKey   | “I, B”             | `PACIB X2, X3`              |
| **PACDA**    | Sign data pointer with APDAKey           | “D, A”             | `PACDA X4, X5`              |
| **PACDB**    | Sign data pointer with APDBKey           | “D, B”             | `PACDB X6, X7`              |
| **PACG / PACGA** | Generic (non-pointer) signing with APGAKey | “G”         | `PACGA X8, X9, X10` (sign X9 with modifier X10 into X8) |
| **AUTIA**    | Authenticate APIA-signed instruction pointer & strip PAC | “I, A” | `AUTIA X0, X1` — check PAC on X0 using modifier X1, then strip |
| **AUTIB**    | Authenticate APIB domain                 | “I, B”             | `AUTIB X2, X3`               |
| **AUTDA**    | Authenticate APDA-signed data pointer    | “D, A”             | `AUTDA X4, X5`               |
| **AUTDB**    | Authenticate APDB-signed data pointer    | “D, B”             | `AUTDB X6, X7`               |
| **AUTGA**    | Authenticate generic / blob (APGA)        | “G”               | `AUTGA X8, X9, X10` (validate generic) |
| **XPACI**     | Strip PAC (instruction pointer, no validation) | “I”         | `XPACI X0` — remove PAC from X0 (instruction domain) |
| **XPACD**     | Strip PAC (data pointer, no validation)    | “D”             | `XPACD X4` — remove PAC from data pointer in X4 |

Są też wyspecjalizowane / aliasowe formy:

- `PACIASP` to skrót dla `PACIA X30, SP` (sign the link register using SP as modifier)
- `AUTIASP` to `AUTIA X30, SP` (authenticate link register with SP)
- Formy łączone jak `RETAA`, `RETAB` (authenticate-and-return) lub `BLRAA` (authenticate & branch) występują w rozszerzeniach ARM / wsparciu kompilatora.
- Również warianty z zerowym modifierem: `PACIZA` / `PACIZB` gdzie modifier jest implicite zerem, itd.

#### Modifiers

Głównym celem modifiera jest **przypiąć PAC do konkretnego kontekstu**, tak by ta sama adresacja podpisana w różnych kontekstach dawała różne PACy. To zapobiega prostemu ponownemu użyciu wskaźnika między frame’ami lub obiektami. Jest to jak dodanie **soli do hasha.**

Dlatego:
- **modifier** to wartość kontekstowa (inny rejestr) mieszana do obliczenia PAC. Typowe wybory: stack pointer (`SP`), frame pointer lub jakiś ID obiektu.
- Użycie SP jako modifiera jest powszechne dla podpisywania adresów powrotu: PAC jest związany z konkretną ramką stosu. Jeśli spróbujesz ponownie użyć LR w innej ramce, modifier się zmienia i walidacja PAC nie przejdzie.
- Ta sama wartość wskaźnika podpisana z różnymi modifierami daje różne PACy.
- Modifier nie musi być tajny, ale najlepiej, aby nie był kontrolowany przez atakującego.
- Dla instrukcji, które podpisują lub weryfikują wskaźniki bez sensownego modifiera, niektóre formy używają zera lub implicite stałej.

#### Apple / iOS / XNU Customizations & Observations

- Implementacja PAC w Apple zawiera **per-boot diversifiers**, dzięki czemu klucze lub tweak zmieniają się przy każdym boocie, uniemożliwiając reuse między bootami.
- Zawiera też **cross-domain mitigations**, by PACy podpisane w user mode nie były łatwo wykorzystywalne w kernel mode itd.
- Na Apple M1 / Apple Silicon inżynieria wsteczna pokazała, że istnieje **dziewięć typów modifierów** i Apple-specyficzne rejestry systemowe dla kontroli kluczy.
- Apple używa PAC w wielu subsystemach jądra: signing adresów powrotu, integralność wskaźników w danych jądra, podpisane konteksty wątków itd.
- Google Project Zero pokazał, że przy potężnym primitywie read/write w kernel można było sfałszować kernel PACy (dla A keys) na urządzeniach A12, ale Apple załatało wiele z tych ścieżek.
- W systemie Apple niektóre klucze są **globalne dla jądra**, podczas gdy procesy użytkownika mogą dostawać per-process losowość kluczy.

#### PAC Bypasses

1. **Kernel-mode PAC: theoretical vs real bypasses**

-   Ponieważ klucze PAC i logika są ściśle kontrolowane (uprzywilejowane rejestry, diversifiers, izolacja domen), sfałszowanie dowolnych podpisanych wskaźników jądra jest bardzo trudne.
-   Azad w 2020 „iOS Kernel PAC, One Year Later” raportował, że w iOS 12–13 znalazł kilka częściowych bypassów (signing gadgets, reuse signed states, niechronione indirect branches) ale nie pełnego, uniwersalnego obejścia. [bazad.github.io](https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf)
-   Apple’owskie „Dark Magic” customizacje dodatkowo zawęziły powierzchnie ataku (domain switching, per-key enabling bits). [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Istnieje znany **kernel PAC bypass CVE-2023-32424** na Apple silicon (M1/M2) zgłoszony przez Zecao Cai i in. [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Jednak te bypasses często opierają się na bardzo specyficznych gadgetach lub bugach implementacyjnych; nie są to ogólne obejścia.

W efekcie kernel PAC jest uważany za **wysoce solidny**, choć nie idealny.

2. **User-mode / runtime PAC bypass techniques**

Te są częstsze i wykorzystują niedoskonałości w tym, jak PAC jest stosowany lub używany w dynamicznym linkowaniu / runtime frameworks. Poniżej klasy technik z przykładami.

2.1 **Shared Cache / A key issues**

-   **dyld shared cache** to duży pre-linked blob systemowych frameworków i bibliotek. Ponieważ jest szeroko współdzielony, wskaźniki funkcji wewnątrz shared cache są „pre-signed” i używane przez wiele procesów. Atakujący celują w te już-podpisane wskaźniki jako „PAC oracles”.
-   Niektóre techniki bypass próbują wyodrębnić lub ponownie użyć A-key podpisanych wskaźników obecnych w shared cache i ponownie wykorzystać je w gadgetach.
-   Prezentacja „No Clicks Required” opisuje budowę orakla nad shared cache, by wnioskować względne adresy i łączyć to z podpisanymi wskaźnikami do ominięcia PAC. [saelo.github.io](https://saelo.github.io/presentations/offensivecon_20_no_clicks.pdf)
-   Również importy wskaźników funkcji z bibliotek w userspace okazały się czasami niewystarczająco chronione przez PAC, pozwalając atakującemu uzyskać function pointers bez zmiany ich podpisu. (Project Zero bug entry) [bugs.chromium.org](https://bugs.chromium.org/p/project-zero/issues/detail?id=2044&utm_source=chatgpt.com)

2.2 **dlsym(3) / dynamic symbol resolution**

-   Jeden z znanych bypassów polega na wywołaniu `dlsym()` w celu uzyskania *już podpisanego* wskaźnika funkcji (signed with A-key, diversifier zero) i jego użycia. Ponieważ `dlsym` zwraca legalnie podpisany wskaźnik, użycie go omija potrzebę fałszowania PAC.
-   Blog Epsilon opisuje, jak niektóre bypasses wykorzystują to: wywołanie `dlsym("someSym")` zwraca signed pointer i może być użyte do wywołań pośrednich. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)
-   Synacktiv w „iOS 18.4 --- dlsym considered harmful” opisuje błąd: niektóre symbole rozwiązywane przez `dlsym` w iOS 18.4 zwracają pointery niepoprawnie podpisane (lub z błędnymi diversifierami), umożliwiając niezamierzony PAC bypass. [Synacktiv](https://www.synacktiv.com/en/publications/ios-184-dlsym-considered-harmful)
-   Logika dyld dla dlsym zawiera: kiedy `result->isCode`, podpisują zwracany pointer z `__builtin_ptrauth_sign_unauthenticated(..., key_asia, 0)`, czyli kontekst zero. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

Dlatego `dlsym` jest częstym wektorem w bypassach PAC w user-mode.

2.3 **Other DYLD / runtime relocations**

-   Loader DYLD i logika relokacji dynamicznych są złożone i czasami tymczasowo mapują strony jako read/write, by wykonać relokacje, a potem przełączają je z powrotem na read-only. Atakujący wykorzystują takie okna czasowe. Talk Synacktiv opisuje „Operation Triangulation”, timingowy bypass PAC przez dynamiczne relokacje. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)
-   Strony DYLD są teraz chronione przy pomocy SPRR / VM_FLAGS_TPRO (pewne flagi ochrony dla dyld). Ale wcześniejsze wersje miały słabsze zabezpieczenia. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)
-   W łańcuchach exploitów WebKit loader DYLD jest często celem bypassów PAC. Slajdy wspominają, że wiele bypassów PAC atakowało loader DYLD (przez relokacje, interposer hooks). [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

2.4 **NSPredicate / NSExpression / ObjC / SLOP**

-   W userland exploit chains, runtime Objective-C takie jak `NSPredicate`, `NSExpression` czy `NSInvocation` są używane do przemycania wywołań kontrolnych bez oczywistego fałszowania wskaźników.
-   Na starszych iOS (przed PAC), exploit używał **fake NSInvocation** obiektów do wywoływania arbitralnych selectorów na kontrolowanej pamięci. Z PAC technika wymaga modyfikacji. Ale technika SLOP (SeLector Oriented Programming) została rozszerzona pod PAC. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)
-   Oryginalna technika SLOP pozwalała łańcuchować wywołania ObjC tworząc fałszywe invocation; bypass polegał na tym, że ISA lub selector pointers czasami nie były w pełni chronione przez PAC. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)
-   W środowiskach, gdzie pointer authentication jest stosowane częściowo, metody / selektory / target pointers mogą nie zawsze mieć ochronę PAC, co daje pole do obejścia.

#### Example Flow

<details>
<summary>Example Signing & Authenticating</summary>
```
; Example: function prologue / return address protection
my_func:
stp x29, x30, [sp, #-0x20]!        ; push frame pointer + LR
mov x29, sp
PACIASP                            ; sign LR (x30) using SP as modifier
; … body …
mov sp, x29
ldp x29, x30, [sp], #0x20         ; restore
AUTIASP                            ; authenticate & strip PAC
ret

; Example: indirect function pointer stored in a struct
; suppose X1 contains a function pointer
PACDA X1, X2     ; sign data pointer X1 with context X2
STR X1, [X0]      ; store signed pointer

; later retrieval:
LDR X1, [X0]
AUTDA X1, X2       ; authenticate & strip
BLR X1             ; branch to valid target

; Example: stripping for comparison (unsafe)
LDR X1, [X0]
XPACI X1           ; strip PAC (instruction domain)
CMP X1, #some_label_address
BEQ matched_label
```
</details>

<details>
<summary>Przykład</summary>
Przepełnienie bufora nadpisuje adres powrotu na stosie. Atakujący wpisuje adres docelowego gadgetu, ale nie potrafi obliczyć poprawnego PAC. Gdy funkcja zwraca, instrukcja CPU `AUTIA` wywołuje fault z powodu niezgodności PAC. Łańcuch się nie udaje.
Analiza Project Zero dotycząca A12 (iPhone XS) pokazała, jak Apple wykorzystuje PAC i metody fałszowania PAC jeśli atakujący ma prymityw do odczytu/zapisu pamięci.
</details>


### 9. **Branch Target Identification (BTI)**
**Wprowadzone w ARMv8.5 (późniejszy sprzęt)**
BTI to funkcja sprzętowa, która sprawdza **indirect branch targets**: przy wykonywaniu `blr` lub pośrednich wywołań/skoków, cel musi zaczynać się od **BTI landing pad** (`BTI j` lub `BTI c`). Skakanie do adresów gadgetów, które nie mają takiego landing padu, powoduje wyjątek.

Implementacja LLVM opisuje trzy warianty instrukcji BTI i jak mapują się na typy rozgałęzień.

| Wariant BTI | Co pozwala (jakie typy rozgałęzień) | Typowe umiejscowienie / przypadek użycia |
|-------------|----------------------------------------|-------------------------------|
| **BTI C** | Cele pośrednich rozgałęzień w stylu *call* (np. `BLR`, lub `BR` używające X16/X17) | Umieszczany na wejściu funkcji, które mogą być wywoływane pośrednio |
| **BTI J** | Cele rozgałęzień w stylu *jump* (np. `BR` używany dla tail call) | Umieszczany na początku bloków osiągalnych przez jump tables lub tail-calle |
| **BTI JC** | Działa zarówno jako C jak i J | Może być celem zarówno call jak i jump |

- W kodzie skompilowanym z wymuszaniem branch target, kompilatory wstawiają instrukcję BTI (C, J lub JC) przy każdym poprawnym celu pośredniego rozgałęzienia (początki funkcji lub bloki osiągalne przez skoki), tak że pośrednie skoki powiodą się tylko do tych miejsc.
- **Bezpośrednie branchy / calls** (tj. stałoadresowe `B`, `BL`) **nie są ograniczane** przez BTI. Założenie jest takie, że strony kodu są zaufane i atakujący nie może ich zmienić (więc bezpośrednie skoki są bezpieczne).
- Również instrukcje RET / return zazwyczaj nie są ograniczane przez BTI, ponieważ adresy powrotu są chronione przez PAC lub mechanizmy podpisywania zwrotu.

#### Mechanizm i egzekwowanie

- Gdy CPU dekoduje **pośrednie rozgałęzienie (BLR / BR)** w stronie oznaczonej jako „guarded / BTI-enabled”, sprawdza, czy pierwsza instrukcja pod adresem celu jest poprawnym BTI (C, J, lub JC, w zależności od dozwolonego typu). Jeśli nie, występuje **wyjątek celu rozgałęzienia**.
- Kodowanie instrukcji BTI zostało zaprojektowane tak, aby ponownie użyć opcode’ów wcześniej zarezerwowanych dla NOPów (w wcześniejszych wersjach ARM). Dzięki temu binaria z BTI są kompatybilne wstecz: na sprzęcie bez wsparcia BTI te instrukcje działają jak NOP.
- Przejścia kompilatora, które dodają BTI, wstawiają je tylko tam, gdzie są potrzebne: funkcje, które mogą być wywoływane pośrednio, lub bloki podstawowe będące celami skoków.
- Niektóre poprawki i fragmenty kodu LLVM pokazują, że BTI nie jest wstawiane dla *wszystkich* bloków podstawowych — tylko dla tych, które są potencjalnymi celami rozgałęzień (np. z switch / jump tables).

#### Synergia BTI + PAC

PAC chroni wartość wskaźnika (źródło) — zapewnia, że łańcuch pośrednich wywołań / zwrotów nie został zmanipulowany.

BTI zapewnia, że nawet poprawny wskaźnik może celować tylko w odpowiednio oznaczone entry pointy.

W połączeniu, atakujący potrzebuje zarówno poprawnego wskaźnika z właściwym PAC, jak i celu z wstawionym w nim BTI. To zwiększa trudność budowy exploitów bazujących na gadgetach.

#### Przykład


<details>
<summary>Przykład</summary>
Exploit próbuje pivotować do gadgetu pod `0xABCDEF`, który nie zaczyna się od `BTI c`. CPU przy wykonywaniu `blr x0` sprawdza cel i zgłasza fault, ponieważ wyrównanie instrukcji nie zawiera poprawnego landing padu. Wiele gadgetów staje się więc nieużytecznych, chyba że mają prefiks BTI.
</details>


### 10. **Privileged Access Never (PAN) & Privileged Execute Never (PXN)**
**Wprowadzone w nowszych rozszerzeniach ARMv8 / wsparcie iOS (dla utwardzanego kernela)**

#### PAN (Privileged Access Never)

- **PAN** to funkcja wprowadzona w **ARMv8.1-A**, która uniemożliwia **kodowi uprzywilejowanemu** (EL1 lub EL2) **odczyt lub zapis** pamięci oznaczonej jako **dostępna dla user (EL0)**, chyba że PAN jest jawnie wyłączone.
- Ideą jest: nawet jeśli kernel zostanie oszukany lub skompromitowany, nie może dowolnie dereferencjonować wskaźników użytkownika bez najpierw *wyłączenia* PAN, zmniejszając ryzyko exploitów w stylu **`ret2usr`** lub niewłaściwego użycia buforów kontrolowanych przez użytkownika.
- Gdy PAN jest włączone (PSTATE.PAN = 1), każda uprzywilejowana instrukcja load/store odwołująca się do wirtualnego adresu, który jest „dostępny na EL0”, powoduje **fault uprawnień**.
- Kernel, gdy musi legalnie uzyskać dostęp do pamięci użytkownika (np. kopiowanie danych do/z buforów użytkownika), musi **tymczasowo wyłączyć PAN** (lub użyć instrukcji „unprivileged load/store”), aby umożliwić ten dostęp.
- W Linuxie na ARM64 wsparcie PAN zostało wprowadzone około 2015: poprawki kernela dodały wykrywanie funkcji i zastąpiły `get_user` / `put_user` itd. wariantami, które wyłączają PAN wokół dostępu do pamięci użytkownika.

**Kluczowy niuans / ograniczenie / błąd**
- Jak zauważyli Siguza i inni, błąd w specyfikacji (lub niejednoznaczne zachowanie) w projektowaniu ARM oznacza, że **execute-only user mappings** (`--x`) mogą **nie wywoływać PAN**. Innymi słowy, jeśli strona użytkownika jest oznaczona jako wykonalna, ale bez prawa do odczytu, próba odczytu kernela może ominąć PAN, ponieważ architektura uznaje „accessible at EL0” za wymagające uprawnienia do odczytu, a nie tylko wykonania. To prowadzi do możliwości obejścia PAN w pewnych konfiguracjach.
- Z tego powodu, jeśli iOS / XNU pozwala na execute-only user pages (jak w niektórych JIT lub code-cache), kernel może przypadkowo czytać z nich nawet przy włączonym PAN. To znany, subtelny obszar podatny w niektórych systemach ARMv8+.

#### PXN (Privileged eXecute Never)

- **PXN** to flaga wpisu tablicy stron (w entry liścia lub block entry), która wskazuje, że strona jest **niewykonalna przy uruchomieniu w trybie uprzywilejowanym** (tj. gdy EL1 wykonuje instrukcje).
- PXN zapobiega temu, by kernel (lub dowolny kod uprzywilejowany) wskoczył do i wykonał instrukcje ze stron użytkownika nawet jeśli kontrola zostanie przekierowana. W efekcie blokuje przekierowanie kontroli kernela do pamięci użytkownika.
- W połączeniu z PAN zapewnia to, że:
1. Kernel nie może (domyślnie) czytać ani zapisywać danych użytkownika (PAN)
2. Kernel nie może wykonywać kodu użytkownika (PXN)
- W formacie tablicy stron ARMv8 wpisy liścia mają bit `PXN` (i także `UXN` dla unprivileged execute-never) w swoich bitach atrybutów.

Nawet jeśli kernel ma uszkodzony wskaźnik funkcji wskazujący na pamięć użytkownika i spróbuje się tam rozgałęzić, bit PXN spowoduje fault.

#### Model uprawnień pamięci & jak PAN i PXN mapują się na bity tablicy stron

Aby zrozumieć jak PAN / PXN działają, trzeba zobaczyć model translacji i uprawnień ARM (uproszczone):

- Każdy wpis strony lub bloku ma pola atrybutów, w tym **AP[2:1]** dla uprawnień dostępu (read/write, privileged vs unprivileged) oraz bity **UXN / PXN** dla ograniczeń execute-never.
- Gdy PSTATE.PAN = 1 (włączone), sprzęt egzekwuje zmodyfikowaną semantykę: uprzywilejowane dostępy do stron oznaczonych jako „dostępne przez EL0” (tj. dostępne dla user) są zabronione (fault).
- Z powodu wspomnianego buga, strony oznaczone tylko jako execute-only (bez uprawnień do odczytu) mogą nie być traktowane jako „accessible by EL0” w pewnych implementacjach, co pozwala obejść PAN.
- Gdy bit PXN strony jest ustawiony, nawet jeśli fetch instrukcji pochodzi z wyższego poziomu uprzywilejowania, wykonanie jest zabronione.

#### Użycie PAN / PXN przez kernel w utwardzonym OS (np. iOS / XNU)

W projecie utwardzanego kernela (jakim może stosować Apple):

- Kernel włącza PAN domyślnie (by ograniczyć kod uprzywilejowany).
- W ścieżkach, które legalnie muszą czytać lub zapisywać bufory użytkownika (np. kopiowanie syscall, I/O, read/write user pointer), kernel tymczasowo **wyłącza PAN** lub używa specjalnych instrukcji, by obejść ograniczenie.
- Po zakończeniu dostępu do danych użytkownika musi ponownie włączyć PAN.
- PXN jest egzekwowane przez tablice stron: strony użytkownika mają PXN = 1 (więc kernel nie może ich wykonywać), strony kernela nie mają PXN (więc kod kernela może być wykonywany).
- Kernel musi upewnić się, że żadne ścieżki wykonawcze nie prowadzą do regionów pamięci użytkownika (co omijałoby PXN) — więc łańcuchy exploitów polegające na „skoku do shellcode’u użytkownika” są zablokowane.

Z powodu wspomnianego obejścia PAN przez strony execute-only, w rzeczywistym systemie Apple może wyłączyć lub zabronić execute-only user pages albo załatać tę słabość specyfikacji.

#### Powierzchnie ataku, obejścia i środki zaradcze

- **PAN bypass via execute-only pages**: jak opisano, spec pozwala na lukę: strony użytkownika z execute-only (bez prawa do odczytu) mogą nie być traktowane jako „accessible at EL0”, więc PAN nie zablokuje odczytów kernela na niektórych implementacjach. To daje atakującemu nietypową ścieżkę przesyłania danych przez sekcje execute-only.
- **Temporal window exploit**: jeśli kernel wyłącza PAN na okres dłuższy niż potrzebny, wyścig lub złośliwa ścieżka może wykorzystać ten okno do wykonania niezamierzonego dostępu do pamięci użytkownika.
- **Zapomniane ponowne włączenie**: jeśli ścieżki kodu nie włączą ponownie PAN, kolejne operacje kernela mogą niepoprawnie uzyskać dostęp do pamięci użytkownika.
- **Błędna konfiguracja PXN**: jeśli tablice stron nie ustawiają PXN na stronach użytkownika lub błędnie mapują strony kodu użytkownika, kernel może zostać oszukany do wykonania kodu użytkownika.
- **Spekulacja / side-channels**: analogicznie do spekulacyjnych obejść, mogą występować mikroarchitektoniczne efekty uboczne powodujące przejściowe naruszenie kontroli PAN / PXN (choć takie ataki są silnie zależne od projektu CPU).
- **Złożone interakcje**: w bardziej zaawansowanych funkcjach (np. JIT, shared memory, obszary generujące kod w locie), kernel może potrzebować drobiazgowej kontroli by zezwolić na pewne dostępy pamięci lub wykonanie w regionach mapowanych dla użytkownika; zaprojektowanie tego bezpiecznie pod ograniczeniami PAN/PXN jest nietrywialne.


#### Przykład

<details>
<summary>Przykład kodu</summary>
Poniżej ilustracyjne pseudo-assemble’y pokazujące włączanie/wyłączanie PAN wokół dostępu do pamięci użytkownika i jak może wystąpić fault.
```  
// Suppose kernel entry point, PAN is enabled (privileged code cannot access user memory by default)

; Kernel receives a syscall with user pointer in X0
; wants to read an integer from user space
mov   X1, X0        ; X1 = user pointer

; disable PAN to allow privileged access to user memory
MSR   PSTATE.PAN, #0   ; clear PAN bit, disabling the restriction

ldr   W2, [X1]       ; now allowed load from user address

; re-enable PAN before doing other kernel logic
MSR   PSTATE.PAN, #1   ; set PAN

; ... further kernel work ...

; Later, suppose an exploit corrupts a pointer to a user-space code page and jumps there
BR    X3             ; branch to X3 (which points into user memory)

; Because the target page is marked PXN = 1 for privileged execution,
; the CPU throws an exception (fault) and rejects execution
```
If the kernel had **not** set PXN on that user page, then the branch might succeed — which would be insecure.

If the kernel forgets to re-enable PAN after user memory access, it opens a window where further kernel logic might accidentally read/write arbitrary user memory.

If the user pointer is into an execute-only page (user page with only execute permission, no read/write), under the PAN spec bug, `ldr W2, [X1]` might **not** fault even with PAN enabled, enabling a bypass exploit, depending on implementation.

</details>

<details>
<summary>Example</summary>
A kernel vulnerability tries to take a user-provided function pointer and call it in kernel context (i.e. `call user_buffer`). Under PAN/PXN, that operation is disallowed or faults.
</details>

---

### 11. **Top Byte Ignore (TBI) / Pointer Tagging**
**Introduced in ARMv8.5 / newer (or optional extension)**
TBI means the top byte (most-significant byte) of a 64-bit pointer is ignored by address translation. This lets OS or hardware embed **tag bits** in the pointer’s top byte without affecting the actual address.

- TBI stands for **Top Byte Ignore** (sometimes called *Address Tagging*). It is a hardware feature (available in many ARMv8+ implementations) that **ignores the top 8 bits** (bits 63:56) of a 64-bit pointer when performing **address translation / load/store / instruction fetch**.
- In effect, the CPU treats a pointer `0xTTxxxx_xxxx_xxxx` (where `TT` = top byte) as `0x00xxxx_xxxx_xxxx` for the purposes of address translation, ignoring (masking off) the top byte. The top byte can be used by software to store **metadata / tag bits**.
- This gives software “free” in-band space to embed a byte of tag in each pointer without altering which memory location it refers to.
- The architecture ensures that loads, stores, and instruction fetch treat the pointer with its top byte masked (i.e. tag stripped off) before performing the actual memory access.

Thus TBI decouples the **logical pointer** (pointer + tag) from the **physical address** used for memory operations.

#### Why TBI: Use cases and motivation

- **Pointer tagging / metadata**: You can store extra metadata (e.g. object type, version, bounds, integrity tags) in that top byte. When you later use the pointer, the tag is ignored at hardware level, so you don’t need to strip manually for the memory access.
- **Memory tagging / MTE (Memory Tagging Extension)**: TBI is the base hardware mechanism that MTE builds on. In ARMv8.5, the **Memory Tagging Extension** uses bits 59:56 of the pointer as a **logical tag** and checks it against an **allocation tag** stored in memory.
- **Enhanced security & integrity**: By combining TBI with pointer authentication (PAC) or runtime checks, you can force not just the pointer value but also the tag to be correct. An attacker overwriting a pointer without the correct tag will produce a mismatched tag.
- **Compatibility**: Because TBI is optional and tag bits are ignored by hardware, existing untagged code continues to operate normally. The tag bits effectively become “don’t care” bits for legacy code.

#### Example
<details>
<summary>Example</summary>
A function pointer included a tag in its top byte (say `0xAA`). An exploit overwrites the pointer low bits but neglects the tag, so when the kernel verifies or sanitizes, the pointer fails or is rejected.
</details>

---

### 12. **Page Protection Layer (PPL)**
**Introduced in late iOS / modern hardware (iOS ~17 / Apple silicon / high-end models)** (some reports show PPL circa macOS / Apple silicon, but Apple is bringing analogous protections to iOS)

- PPL is designed as an **intra-kernel protection boundary**: even if the kernel (EL1) is compromised and has read/write capabilities, **it should not be able to freely modify** certain **sensitive pages** (especially page tables, code-signing metadata, kernel code pages, entitlements, trust caches, etc.).
- It effectively creates a **“kernel within the kernel”** — a smaller trusted component (PPL) with **elevated privileges** that alone can modify protected pages. Other kernel code must call into PPL routines to effect changes.
- This reduces the attack surface for kernel exploits: even with full arbitrary R/W/execute in kernel mode, exploit code must also somehow get into the PPL domain (or bypass PPL) to modify critical structures.
- On newer Apple silicon (A15+ / M2+), Apple is transitioning to **SPTM (Secure Page Table Monitor)**, which in many cases replaces PPL for page-table protection on those platforms.

Here’s how PPL is believed to operate, based on public analysis:

#### Use of APRR / permission routing (APRR = Access Permission ReRouting)

- Apple hardware uses a mechanism called **APRR (Access Permission ReRouting)**, which allows page table entries (PTEs) to contain small indices, rather than full permission bits. Those indices are mapped via APRR registers to actual permissions. This allows dynamic remapping of permissions per domain.
- PPL leverages APRR to segregate privilege within kernel context: only the PPL domain is permitted to update the mapping between indices and effective permissions. That is, when non-PPL kernel code writes a PTE or tries to flip permission bits, the APRR logic disallows it (or enforces read-only mapping).
- PPL code itself runs in a restricted region (e.g. `__PPLTEXT`) which is normally non-executable or non-writable until entry gates temporarily allow it. The kernel calls PPL entry points (“PPL routines”) to perform sensitive operations.

#### Gate / Entry & Exit

- When the kernel needs to modify a protected page (e.g. change permissions of a kernel code page, or modify page tables), it calls into a **PPL wrapper** routine, which does validation and then transitions into the PPL domain. Outside that domain, the protected pages are effectively read-only or non-modifiable by the main kernel.
- During PPL entry, the APRR mappings are adjusted so that memory pages in the PPL region are set to **executable & writable** within PPL. Upon exit, they are returned to read-only / non-writable. This ensures that only well-audited PPL routines can write to protected pages.
- Outside PPL, attempts by kernel code to write to those protected pages will fault (permission denied) because the APRR mapping for that code domain doesn’t permit writing.

#### Protected page categories

The pages that PPL typically protects include:

- Page table structures (translation table entries, mapping metadata)
- Kernel code pages, especially those containing critical logic
- Code-sign metadata (trust caches, signature blobs)
- Entitlement tables, signature enforcement tables
- Other high-value kernel structures where a patch would allow bypassing signature checks or credentials manipulation

The idea is that even if the kernel memory is fully controlled, the attacker cannot simply patch or rewrite these pages, unless they also compromise PPL routines or bypass PPL.


#### Known Bypasses & Vulnerabilities

1. **Project Zero’s PPL bypass (stale TLB trick)**

- A public writeup by Project Zero describes a bypass involving **stale TLB entries**.
- The idea:

1. Allocate two physical pages A and B, mark them as PPL pages (so they are protected).
2. Map two virtual addresses P and Q whose L3 translation table pages come from A and B.
3. Spin a thread to continuously access Q, keeping its TLB entry alive.
4. Call `pmap_remove_options()` to remove mappings starting at P; due to a bug, the code mistakenly removes the TTEs for both P and Q, but only invalidates the TLB entry for P, leaving Q’s stale entry live.
5. Reuse B (page Q’s table) to map arbitrary memory (e.g. PPL-protected pages). Because the stale TLB entry still maps Q’s old mapping, that mapping remains valid for that context.
6. Through this, the attacker can put writable mapping of PPL-protected pages in place without going through PPL interface.

- This exploit required fine control of physical mapping and TLB behavior. It demonstrates that a security boundary relying on TLB / mapping correctness must be extremely careful about TLB invalidations and mapping consistency.

- Project Zero commented that bypasses like this are subtle and rare, but possible in complex systems. Still, they regard PPL as a solid mitigation.

2. **Other potential hazards & constraints**

- If a kernel exploit can directly enter PPL routines (via calling the PPL wrappers), it might bypass restrictions. Thus argument validation is critical.
- Bugs in the PPL code itself (e.g. arithmetic overflow, boundary checks) can allow out-of-bounds modifications inside PPL. Project Zero observed that such a bug in `pmap_remove_options_internal()` was exploited in their bypass.
- The PPL boundary is irrevocably tied to hardware enforcement (APRR, memory controller), so it's only as strong as the hardware implementation.



#### Example
<details>
<summary>Code Example</summary>
Here’s a simplified pseudocode / logic showing how a kernel might call into PPL to modify protected pages:
```c
// In kernel (outside PPL domain)
function kernel_modify_pptable(pt_addr, new_entry) {
// validate arguments, etc.
return ppl_call_modify(pt_addr, new_entry)  // call PPL wrapper
}

// In PPL (trusted domain)
function ppl_call_modify(pt_addr, new_entry) {
// temporarily enable write access to protected pages (via APRR adjustments)
aprr_set_index_for_write(PPL_INDEX)
// perform the modification
*pt_addr = new_entry
// restore permissions (make pages read-only again)
aprr_restore_default()
return success
}

// If kernel code outside PPL does:
*pt_addr = new_entry  // a direct write
// It will fault because APRR mapping for non-PPL domain disallows write to that page
```
Kernel może wykonywać wiele normalnych operacji, ale tylko przez rutyny `ppl_call_*` może zmieniać chronione mapowania lub patchować kod.
</details>

<details>
<summary>Przykład</summary>
Exploit kernel próbuje nadpisać entitlement table, lub wyłączyć egzekwowanie code-sign przez modyfikację kernel signature blob. Ponieważ ta strona jest chroniona przez PPL, zapis jest zablokowany, chyba że odbywa się przez interfejs PPL. Zatem nawet przy wykonaniu kodu w kernel nie można obejść ograniczeń code-sign ani dowolnie modyfikować danych credential.
Na iOS 17+ niektóre urządzenia używają SPTM do dalszej izolacji stron zarządzanych przez PPL.
</details>

#### PPL → SPTM / Zastąpienia / Przyszłość

- W nowoczesnych SoC Apple (A15 lub nowsze, M2 lub nowsze) Apple wspiera **SPTM** (Secure Page Table Monitor), który **zastępuje PPL** dla ochrony page table.
- Apple wskazuje w dokumentacji: „Page Protection Layer (PPL) and Secure Page Table Monitor (SPTM) enforce execution of signed and trusted code … PPL manages the page table permission overrides … Secure Page Table Monitor replaces PPL on supported platforms.”
- Architektura SPTM prawdopodobnie przesuwa więcej egzekwowania polityk do monitora o wyższych uprawnieniach poza kontrolą kernel, dalej zmniejszając boundary zaufania.

### MTE | EMTE | MIE

Oto opis na wyższym poziomie, jak EMTE działa w konfiguracji MIE Apple:

1. **Przypisanie tagu**
- Gdy pamięć jest alokowana (np. w kernel lub w user-space przez secure allocators), do bloku przypisywany jest **secret tag**.
- Wskaźnik zwracany do użytkownika lub kernel zawiera ten tag w swoich wysokich bitach (używając mechanizmów TBI / top byte ignore).

2. **Sprawdzanie tagu przy dostępie**
- Za każdym razem, gdy wykonywany jest load lub store używając wskaźnika, hardware sprawdza, czy tag wskaźnika zgadza się z tagiem bloku pamięci (allocation tag). Jeśli nie pasuje, następuje fault natychmiast (ponieważ jest synchronous).
- Ponieważ jest to synchronous, nie ma okna „delayed detection”.

3. **Retagowanie przy free / reuse**
- Gdy pamięć jest zwalniana, allocator zmienia tag bloku (tak że starsze wskaźniki ze starymi tagami już nie pasują).
- Use-after-free pointer będzie więc miał stale tag i spowoduje mismatch przy dostępie.

4. **Różnicowanie tagów sąsiednich alokacji, by złapać overflows**
- Przylegające alokacje otrzymują różne tagi. Jeśli buffer overflow wypłynie do pamięci sąsiada, mismatch tagu spowoduje fault.
- To jest szczególnie skuteczne w wykrywaniu małych overflowów, które przekraczają boundary.

5. **Wymuszanie poufności tagów**
- Apple musi zapobiegać tag values being leaked (ponieważ jeśli attacker pozna tag, może spreparować wskaźniki z poprawnymi tagami).
- Obejmuje to zabezpieczenia (microarchitectural / speculative controls) zapobiegające side-channel leakage bitów tagu.

6. **Integracja kernel i user-space**
- Apple używa EMTE nie tylko w user-space, ale także w komponentach krytycznych dla OS / kernel (by chronić kernel przed memory corruption).
- Hardware/OS zapewnia, że reguły tagów obowiązują nawet gdy kernel wykonuje się w imieniu user-space.

<details>
<summary>Przykład</summary>
```
Allocate A = 0x1000, assign tag T1
Allocate B = 0x2000, assign tag T2

// pointer P points into A with tag T1
P = (T1 << 56) | 0x1000

// Valid store
*(P + offset) = value // tag T1 matches allocation → allowed

// Overflow attempt: P’ = P + size_of_A (into B region)
*(P' + delta) = value
→ pointer includes tag T1 but memory block has tag T2 → mismatch → fault

// Free A, allocator retags it to T3
free(A)

// Use-after-free:
*(P) = value
→ pointer still has old tag T1, memory region is now T3 → mismatch → fault
```
</details>

#### Ograniczenia i wyzwania

- **Intrablock overflows**: Jeśli overflow pozostaje w tej samej alokacji (nie przekracza granicy) i tag pozostaje ten sam, tag mismatch tego nie wykryje.
- **Tag width limitation**: Do dyspozycji jest tylko kilka bitów (np. 4 bity, lub mała domena) dla taga — ograniczona przestrzeń nazw.
- **Side-channel leaks**: Jeśli bity taga mogą zostać wycieknięte (via cache / speculative execution), atakujący może poznać prawidłowe tagi i obejść mechanizm. Apple’owe wymuszenie poufności tagów ma na celu to złagodzić.
- **Performance overhead**: Sprawdzenia tagu przy każdym load/store dodają koszt; Apple musi zoptymalizować hardware, by zredukować narzut.
- **Compatibility & fallback**: Na starszym sprzęcie lub tam, gdzie EMTE nie jest wspierane, musi istnieć fallback. Apple twierdzi, że MIE jest włączone tylko na urządzeniach z obsługą.
- **Complex allocator logic**: Allocator musi zarządzać tagami, retaggingiem, wyrównywaniem granic i unikać kolizji tagów. Błędy w logice allocatora mogą wprowadzić podatności.
- **Mixed memory / hybrid areas**: Część pamięci może pozostać nieotagowana (legacy), co utrudnia interoperacyjność.
- **Speculative / transient attacks**: Podobnie jak przy wielu mikrotechnicznych zabezpieczeniach, speculative execution lub mikro-op fusion mogą transientnie obejść sprawdzenia lub wyciec tag bits.
- **Limited to supported regions**: Apple może egzekwować EMTE tylko w wybranych, wysokiego ryzyka obszarach (kernel, krytyczne subsystemy), a nie globalnie.



---

## Kluczowe ulepszenia / różnice w porównaniu do standardowego MTE

Oto usprawnienia i zmiany, które Apple podkreśla:

| Feature | Original MTE | EMTE (Apple’s enhanced) / MIE |
|---|---:|---|
| **Check mode** | Supports synchronous and asynchronous modes. In async, tag mismatches are reported later (delayed)| Apple insists on **synchronous mode** by default—tag mismatches are caught immediately, no delay/race windows allowed.|
| **Coverage of non-tagged memory** | Accesses to non-tagged memory (e.g. globals) may bypass checks in some implementations | EMTE requires that accesses from a tagged region to non-tagged memory also validate tag knowledge, making it harder to bypass by mixing allocations.|
| **Tag confidentiality / secrecy** | Tags might be observable or leaked via side channels | Apple adds **Tag Confidentiality Enforcement**, which attempts to prevent leakage of tag values (via speculative side-channels etc.).|
| **Allocator integration & retagging** | MTE leaves much of allocator logic to software | Apple’s secure typed allocators (kalloc_type, xzone malloc, etc.) integrate with EMTE: when memory is allocated or freed, tags are managed at fine granularity.|
| **Always-on by default** | In many platforms, MTE is optional or off by default | Apple enables EMTE / MIE by default on supported hardware (e.g. iPhone 17 / A19) for kernel and many user processes.|

Dzięki kontrolowaniu zarówno hardware’u, jak i stacku software’owego, Apple może rygorystycznie egzekwować EMTE, unikać problemów z wydajnością i zamykać luki typu side-channel.

---

## Jak EMTE działa w praktyce (Apple / MIE)

Poniżej opis działania EMTE w kontekście MIE Apple’a:

1. **Tag assignment**
- Gdy pamięć jest alokowana (np. w kernelu lub w user space przez secure allocators), alokowanemu blokowi przypisywany jest **secret tag**.
- Wskaźnik zwracany do użytkownika lub kernela zawiera ten tag w wysokich bitach (używając mechanizmów TBI / top byte ignore).

2. **Tag checking on access**
- Za każdym razem, gdy wykonywany jest load lub store z użyciem wskaźnika, hardware sprawdza czy tag wskaźnika zgadza się z tagiem bloku pamięci (allocation tag). Jeśli mismatch, następuje fault natychmiast (ponieważ synchronous).
- Ponieważ jest to tryb synchroniczny, nie ma okna „opóźnionego wykrycia”.

3. **Retagging on free / reuse**
- Gdy pamięć jest zwalniana, allocator zmienia tag bloku (stare wskaźniki ze starym tagiem już nie pasują).
- Use-after-free wskaźnik będzie miał więc przestarzały tag i spowoduje mismatch przy dostępie.

4. **Neighbor-tag differentiation to catch overflows**
- Sąsiednim alokacjom przypisuje się różne tagi. Jeśli buffer overflow przeleje się do pamięci sąsiada, tag mismatch spowoduje fault.
- To jest szczególnie skuteczne w wykrywaniu małych overflowów przekraczających granicę.

5. **Tag confidentiality enforcement**
- Apple musi zapobiegać temu, by wartości tagów były wyciekane (ponieważ jeśli atakujący pozna tag, może sfałszować wskaźniki z prawidłowymi tagami).
- Wprowadzono ochrony (mikroarchitektoniczne / dotyczące spekulacji), żeby unikać side-channel wycieków tag bits.

6. **Kernel and user-space integration**
- Apple używa EMTE nie tylko w user-space, ale też w kernelu / krytycznych komponentach OS (by chronić kernel przed korupcją pamięci).
- Hardware/OS zapewniają, że zasady tagów obowiązują nawet gdy kernel wykonuje kod w imieniu user space.

Ponieważ EMTE jest zintegrowane z MIE, Apple stosuje EMTE w trybie synchronicznym across kluczowe powierzchnie ataku, nie tylko jako opcję czy tryb debugowania.



---

## Obsługa wyjątków w XNU

Gdy wystąpi **exception** (np. `EXC_BAD_ACCESS`, `EXC_BAD_INSTRUCTION`, `EXC_CRASH`, `EXC_ARM_PAC`, etc.), warstwa **Mach** jądra XNU przechwytuje ją zanim zostanie zamieniona na UNIX-style **signal** (jak `SIGSEGV`, `SIGBUS`, `SIGILL`, ...).

Proces ten obejmuje wiele warstw propagacji i obsługi wyjątków zanim dotrą one do przestrzeni użytkownika lub zostaną przekształcone w BSD signal.


### Exception Flow (High-Level)

1.  **CPU triggers a synchronous exception** (e.g., invalid pointer dereference, PAC failure, illegal instruction, etc.).

2.  **Low-level trap handler** runs (`trap.c`, `exception.c` in XNU source).

3.  The trap handler calls **`exception_triage()`**, the core of the Mach exception handling.

4.  `exception_triage()` decides how to route the exception:

-   First to the **thread's exception port**.

-   Then to the **task's exception port**.

-   Then to the **host's exception port** (often `launchd` or `ReportCrash`).

If none of these ports handle the exception, the kernel may:

-   **Convert it into a BSD signal** (for user-space processes).

-   **Panic** (for kernel-space exceptions).


### Core Function: `exception_triage()`

Funkcja `exception_triage()` kieruje Mach exceptions w górę łańcucha potencjalnych handlerów, aż któryś je obsłuży lub aż stanie się ostatecznie fatalny. Jest zdefiniowana w `osfmk/kern/exception.c`.
```c
void exception_triage(exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt);
```
**Typowy przebieg wywołań:**

`exception_triage()
└── exception_deliver()
├── exception_deliver_thread()
├── exception_deliver_task()
└── exception_deliver_host()`

Jeśli wszystkie zawiodą → obsługiwane przez `bsd_exception()` → przetłumaczone na sygnał, np. `SIGSEGV`.


### Porty wyjątków

Każdy obiekt Mach (wątek, zadanie, host) może zarejestrować **porty wyjątków**, na które wysyłane są komunikaty o wyjątkach.

Są one zdefiniowane przez API:
```
task_set_exception_ports()
thread_set_exception_ports()
host_set_exception_ports()
```
Each exception port has:

-   A **mask** (which exceptions it wants to receive)
-   A **port name** (Mach port to receive messages)
-   A **behavior** (how the kernel sends the message)
-   A **flavor** (which thread state to include)


### Debuggers and Exception Handling

A **debugger** (e.g., LLDB) sets an **exception port** on the target task or thread, usually using `task_set_exception_ports()`.

**When an exception occurs:**

-   The Mach message is sent to the debugger process.
-   The debugger can decide to **handle** (resume, modify registers, skip instruction) or **not handle** the exception.
-   If the debugger doesn't handle it, the exception propagates to the next level (task → host).


### Flow of `EXC_BAD_ACCESS`

1.  Thread dereferences invalid pointer → CPU raises Data Abort.

2.  Kernel trap handler calls `exception_triage(EXC_BAD_ACCESS, ...)`.

3.  Message sent to:

-   Thread port → (debugger can intercept breakpoint).

-   If debugger ignores → Task port → (process-level handler).

-   If ignored → Host port (usually ReportCrash).

4.  If no one handles → `bsd_exception()` translates to `SIGSEGV`.


### PAC Exceptions

When **Pointer Authentication** (PAC) fails (signature mismatch), a **special Mach exception** is raised:

-   **`EXC_ARM_PAC`** (type)
-   Codes may include details (e.g., key type, pointer type).

If the binary has the flag **`TFRO_PAC_EXC_FATAL`**, the kernel treats PAC failures as **fatal**, bypassing debugger interception. This is to prevent attackers from using debuggers to bypass PAC checks and it's enabled for **platform binaries**.

### Software Breakpoints

A software breakpoint (`int3` on x86, `brk` on ARM64) is implemented by **causing a deliberate fault**.\
The debugger catches this via the exception port:

-   Modifies instruction pointer or memory.
-   Restores original instruction.
-   Resumes execution.

This same mechanism is what allows you to "catch" a PAC exception --- **unless `TFRO_PAC_EXC_FATAL`** is set, in which case it never reaches the debugger.


### Conversion to BSD Signals

If no handler accepts the exception:

-   Kernel calls `task_exception_notify() → bsd_exception()`.

-   This maps Mach exceptions to signals:

| Mach Exception | Signal |
| --- | --- |
| EXC_BAD_ACCESS | SIGSEGV or SIGBUS |
| EXC_BAD_INSTRUCTION | SIGILL |
| EXC_ARITHMETIC | SIGFPE |
| EXC_SOFTWARE | SIGTRAP |
| EXC_BREAKPOINT | SIGTRAP |
| EXC_CRASH | SIGKILL |
| EXC_ARM_PAC | SIGILL (on non-fatal) |


### Key Files in XNU Source

-   `osfmk/kern/exception.c` → Core of `exception_triage()`, `exception_deliver_*()`.

-   `bsd/kern/kern_sig.c` → Signal delivery logic.

-   `osfmk/arm64/trap.c` → Low-level trap handlers.

-   `osfmk/mach/exc.h` → Exception codes and structures.

-   `osfmk/kern/task.c` → Task exception port setup.

---

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

The kernel used a **zone allocator** (`kalloc`) divided into fixed-size "zones."
Each zone only stores allocations of a single size class.

From the screenshot:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Very small kernel structs, pointers.                                        |
| `default.kalloc.32`  | 32 bytes     | Small structs, object headers.                                              |
| `default.kalloc.64`  | 64 bytes     | IPC messages, tiny kernel buffers.                                          |
| `default.kalloc.128` | 128 bytes    | Medium objects like parts of `OSObject`.                                    |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Large structures, IOSurface/graphics metadata.                              |

**How it worked:**
- Each allocation request gets **rounded up** to the nearest zone size.
(E.g., a 50-byte request lands in the `kalloc.64` zone).
- Memory in each zone was kept in a **free list** — chunks freed by the kernel went back into that zone.
- If you overflowed a 64-byte buffer, you’d overwrite the **next object in the same zone**.

This is why **heap spraying / feng shui** was so effective: you could predict object neighbors by spraying allocations of the same size class.

### The freelist

Inside each kalloc zone, freed objects weren’t returned directly to the system — they went into a freelist, a linked list of available chunks.

- When a chunk was freed, the kernel wrote a pointer at the start of that chunk → the address of the next free chunk in the same zone.

- The zone kept a HEAD pointer to the first free chunk.

- Allocation always used the current HEAD:

1. Pop HEAD (return that memory to the caller).

2. Update HEAD = HEAD->next (stored in the freed chunk’s header).

- Freeing pushed chunks back:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

So the freelist was just a linked list built inside the freed memory itself.

Normal state:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Eksploatacja freelist

Ponieważ pierwsze 8 bajtów wolnego chunku = freelist pointer, attacker mógłby go uszkodzić:

1. **Heap overflow** do sąsiedniego zwolnionego chunku → nadpisanie jego “next” pointer.

2. **Use-after-free** zapis w zwolnionym obiekcie → nadpisanie jego “next” pointer.

Następnie, przy następnej alokacji tego rozmiaru:

- Alokator wyciąga sfałszowany chunk.

- Podąża za dostarczonym przez attackera “next” pointer.

- Zwraca wskaźnik do dowolnej pamięci, umożliwiając fake object primitives lub targeted overwrite.

Wizualny przykład freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
This freelist design made exploitation highly effective pre-hardening: predictable neighbors from heap sprays, raw pointer freelist links, and no type separation allowed attackers to escalate UAF/overflow bugs into arbitrary kernel memory control.

### Heap Grooming / Feng Shui
The goal of heap grooming is to **shape the heap layout** so that when an attacker triggers an overflow or use-after-free, the target (victim) object sits right next to an attacker-controlled object.\
That way, when memory corruption happens, the attacker can reliably overwrite the victim object with controlled data.

**Steps:**

1. Spray allocations (fill the holes)
- Over time, the kernel heap gets fragmented: some zones have holes where old
objects were freed.
- The attacker first makes lots of dummy allocations to fill these gaps, so
the heap becomes “packed” and predictable.

2. Force new pages
- Once the holes are filled, the next allocations must come from new pages
added to the zone.
- Fresh pages mean objects will be clustered together, not scattered across
old fragmented memory.
- This gives the attacker much better control of neighbors.

3. Place attacker objects
- The attacker now sprays again, creating lots of attacker-controlled objects
in those new pages.
- These objects are predictable in size and placement (since they all belong
to the same zone).

4. Free a controlled object (make a gap)
- The attacker deliberately frees one of their own objects.
- This creates a “hole” in the heap, which the allocator will later reuse for
the next allocation of that size.

5. Victim object lands in the hole
- The attacker triggers the kernel to allocate the victim object (the one
they want to corrupt).
- Since the hole is the first available slot in the freelist, the victim is
placed exactly where the attacker freed their object.

6. Overflow / UAF into victim
- Now the attacker has attacker-controlled objects around the victim.
- By overflowing from one of their own objects (or reusing a freed one), they
can reliably overwrite the victim’s memory fields with chosen values.

**Why it works**:

- Zone allocator predictability: allocations of the same size always come from
the same zone.
- Freelist behavior: new allocations reuse the most recently freed chunk first.
- Heap sprays: attacker fills memory with predictable content and controls layout.
- End result: attacker controls where the victim object lands and what data sits
next to it.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple hardened the allocator and made **heap grooming much harder**:

### 1. From Classic kalloc to kalloc_type
- **Before**: a single `kalloc.<size>` zone existed for each size class (16, 32, 64, … 1280, etc.). Any object of that size was placed there → attacker objects could sit next to privileged kernel objects.
- **Now**:
- Kernel objects are allocated from **typed zones** (`kalloc_type`).
- Each type of object (e.g., `ipc_port_t`, `task_t`, `OSString`, `OSData`) has its own dedicated zone, even if they’re the same size.
- The mapping between object type ↔ zone is generated from the **kalloc_type system** at compile time.

An attacker can no longer guarantee that controlled data (`OSData`) ends up adjacent to sensitive kernel objects (`task_t`) of the same size.

### 2. Slabs and Per-CPU Caches
- The heap is divided into **slabs** (pages of memory carved into fixed-size chunks for that zone).
- Each zone has a **per-CPU cache** to reduce contention.
- Allocation path:
1. Try per-CPU cache.
2. If empty, pull from the global freelist.
3. If freelist is empty, allocate a new slab (one or more pages).
- **Benefit**: This decentralization makes heap sprays less deterministic, since allocations may be satisfied from different CPUs’ caches.

### 3. Randomization inside zones
- Within a zone, freed elements are not handed back in simple FIFO/LIFO order.
- Modern XNU uses **encoded freelist pointers** (safe-linking like Linux, introduced ~iOS 14).
- Each freelist pointer is **XOR-encoded** with a per-zone secret cookie.
- This prevents attackers from forging a fake freelist pointer if they gain a write primitive.
- Some allocations are **randomized in their placement within a slab**, so spraying doesn’t guarantee adjacency.

### 4. Guarded Allocations
- Certain critical kernel objects (e.g., credentials, task structures) are allocated in **guarded zones**.
- These zones insert **guard pages** (unmapped memory) between slabs or use **redzones** around objects.
- Any overflow into the guard page triggers a fault → immediate panic instead of silent corruption.

### 5. Page Protection Layer (PPL) and SPTM
- Even if you control a freed object, you can’t modify all of kernel memory:
- **PPL (Page Protection Layer)** enforces that certain regions (e.g., code signing data, entitlements) are **read-only** even to the kernel itself.
- On **A15/M2+ devices**, this role is replaced/enhanced by **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- These hardware-enforced layers mean attackers can’t escalate from a single heap corruption to arbitrary patching of critical security structures.
- **(Added / Enhanced)**: also, **PAC (Pointer Authentication Codes)** is used in the kernel to protect pointers (especially function pointers, vtables) so that forging or corrupting them becomes harder.
- **(Added / Enhanced)**: zones may enforce **zone_require / zone enforcement**, i.e. that an object freed can only be returned through its correct typed zone; invalid cross-zone frees may panic or be rejected. (Apple alludes to this in their memory safety posts)

### 6. Large Allocations
- Not all allocations go through `kalloc_type`.
- Very large requests (above ~16 KB) bypass typed zones and are served directly from **kernel VM (kmem)** via page allocations.
- These are less predictable, but also less exploitable, since they don’t share slabs with other objects.

### 7. Allocation Patterns Attackers Target
Even with these protections, attackers still look for:
- **Reference count objects**: if you can tamper with retain/release counters, you may cause use-after-free.
- **Objects with function pointers (vtables)**: corrupting one still yields control flow.
- **Shared memory objects (IOSurface, Mach ports)**: these are still attack targets because they bridge user ↔ kernel.

But — unlike before — you can’t just spray `OSData` and expect it to neighbor a `task_t`. You need **type-specific bugs** or **info leaks** to succeed.

### Example: Allocation Flow in Modern Heap

Suppose userspace calls into IOKit to allocate an `OSData` object:

1. **Type lookup** → `OSData` maps to `kalloc_type_osdata` zone (size 64 bytes).
2. Check per-CPU cache for free elements.
- If found → return one.
- If empty → go to global freelist.
- If freelist empty → allocate a new slab (page of 4KB → 64 chunks of 64 bytes).
3. Return chunk to caller.

**Freelist pointer protection**:
- Each freed chunk stores the address of the next free chunk, but encoded with a secret key.
- Overwriting that field with attacker data won’t work unless you know the key.

---

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages, and **PAC** protects pointers |
| Allocation reuse validation     | None (freelist pointers raw)                               | **zone_require / zone enforcement**             |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |
| Large allocations handling      | All small allocations managed equally                       | Large ones bypass zones → handled via VM         |

---

## Modern Userland Heap (iOS, macOS — type-aware / xzone malloc)

In recent Apple OS versions (especially iOS 17+), Apple introduced a more secure userland allocator, **xzone malloc** (XZM). This is the user-space analog to the kernel’s `kalloc_type`, applying type awareness, metadata isolation, and memory tagging safeguards.

### Goals & Design Principles

- **Type segregation / type awareness**: group allocations by *type or usage (pointer vs data)* to prevent type confusion and cross-type reuse.
- **Metadata isolation**: separate heap metadata (e.g. free lists, size/state bits) from object payloads so that out-of-bounds writes are less likely to corrupt metadata.
- **Guard pages / redzones**: insert unmapped pages or padding around allocations to catch overflows.
- **Memory tagging (EMTE / MIE)**: work in conjunction with hardware tagging to detect use-after-free, out-of-bounds, and invalid accesses.
- **Scalable performance**: maintain low overhead, avoid excessive fragmentation, and support many allocations per second with low latency.

### Architecture & Components

Below are the main elements in the xzone allocator:

#### Segment Groups & Zones

- **Segment groups** partition the address space by usage categories: e.g. `data`, `pointer_xzones`, `data_large`, `pointer_large`.
- Each segment group contains **segments** (VM ranges) that host allocations for that category.
- Associated with each segment is a **metadata slab** (separate VM area) that stores metadata (e.g. free/used bits, size classes) for that segment. This **out-of-line (OOL) metadata** ensures that metadata is not intermingled with object payloads, mitigating corruption from overflows.
- Segments are carved into **chunks** (slices) which in turn are subdivided into **blocks** (allocation units). A chunk is tied to a specific size class and segment group (i.e. all blocks in a chunk share the same size & category).
- For small / medium allocations, it will use fixed-size chunks; for large/huges, it may map separately.

#### Chunks & Blocks

- A **chunk** is a region (often several pages) dedicated to allocations of one size class within a group.
- Inside a chunk, **blocks** are slots available for allocations. Freed blocks are tracked via the metadata slab — e.g. via bitmaps or free lists stored out-of-line.
- Between chunks (or within), **guard slices / guard pages** may be inserted (e.g. unmapped slices) to catch out-of-bounds writes.

#### Type / Type ID

- Every allocation site (or call to malloc, calloc, etc.) is associated with a **type identifier** (a `malloc_type_id_t`) which encodes what kind of object is being allocated. That type ID is passed to the allocator, which uses it to select which zone / segment to serve the allocation.
- Because of this, even if two allocations have the same size, they may go into entirely different zones if their types differ.
- In early iOS 17 versions, not all APIs (e.g. CFAllocator) were fully type-aware; Apple addressed some of those weaknesses in iOS 18.

---

### Allocation & Freeing Workflow

Here is a high-level flow of how allocation and deallocation operate in xzone:

1. **malloc / calloc / realloc / typed alloc** is invoked with a size and type ID.
2. The allocator uses the **type ID** to pick the correct segment group / zone.
3. Within that zone/segment, it seeks a chunk that has free blocks of the requested size.
- It may consult **local caches / per-thread pools** or **free block lists** from metadata.
- If no free block is available, it may allocate a new chunk in that zone.
4. The metadata slab is updated (free bit cleared, bookkeeping).
5. If memory tagging (EMTE) is in play, the returned block gets a **tag** assigned, and metadata is updated to reflect its “live” state.
6. When `free()` is called:
- The block is marked as freed in metadata (via OOL slab).
- The block may be placed into a free list or pooled for reuse.
- Optionally, block contents may be cleared or poisoned to reduce data leaks or use-after-free exploitation.
- The hardware tag associated with the block may be invalidated or re-tagged.
- If an entire chunk becomes free (all blocks freed), the allocator may **reclaim** that chunk (unmap it or return to OS) under memory pressure.

---

### Security Features & Hardening

These are the defenses built into modern userland xzone:

| Feature | Purpose | Notes |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | Prevent overflow from corrupting metadata | Metadata lives in separate VM region (metadata slab)|
| **Guard pages / unmapped slices** | Catch out-of-bounds writes | Helps detect buffer overflows rather than silently corrupting adjacent blocks|
| **Type-based segregation** | Prevent cross-type reuse & type confusion | Even same-size allocations from different types go to different zones|
| **Memory Tagging (EMTE / MIE)** | Detect invalid access, stale references, OOB, UAF | xzone works in concert with hardware EMTE in synchronous mode (“Memory Integrity Enforcement”)|
| **Delayed reuse / poisoning / zap** | Reduce chance of use-after-free exploitation | Freed blocks may be poisoned, zeroed, or quarantined before reuse |
| **Chunk reclamation / dynamic unmapping** | Reduce memory waste and fragmentation | Entire chunks may be unmapped when unused |
| **Randomization / placement variation** | Prevent deterministic adjacency | Blocks in a chunk and chunk selection may have randomized aspects |
| **Segregation of “data-only” allocations** | Separate allocations that don’t store pointers | Reduces attacker control over metadata or control fields|

---

### Interaction with Memory Integrity Enforcement (MIE / EMTE)

- Apple’s MIE (Memory Integrity Enforcement) is the hardware + OS framework that brings **Enhanced Memory Tagging Extension (EMTE)** into always-on, synchronous mode across major attack surfaces.
- xzone allocator is a fundamental foundation of MIE in user space: allocations done via xzone get tags, and accesses are checked by hardware.
- In MIE, the allocator, tag assignment, metadata management, and tag confidentiality enforcement are integrated to ensure that memory errors (e.g. stale reads, OOB, UAF) are caught immediately, not exploited later.

---

If you like, I can also generate a cheat-sheet or diagram of xzone internals for your book. Do you want me to do that next?
::contentReference[oai:20]{index=20}


---

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


## JSKit-Based Safari Chains and PREYHUNTER Stagers

### Renderer RCE abstraction with JSKit
- **Reusable entry**: Recent in-the-wild chains abused a WebKit JIT bug (patched as CVE-2023-41993) purely to gain JavaScript-level arbitrary read/write. The exploit immediately pivots into a purchased framework called **JSKit**, so any future Safari bug only needs to deliver the same primitive.
- **Version abstraction & PAC bypasses**: JSKit bundles support for a wide range of iOS releases together with multiple, selectable Pointer Authentication Code bypass modules. The framework fingerprints the target build, selects the appropriate PAC bypass logic, and verifies every step (primitive validation, shellcode launch) before progressing.
- **Manual Mach-O mapping**: JSKit parses Mach-O headers directly from memory, resolves the symbols it needs inside dyld-cached images, and can manually map additional Mach-O payloads without writing them to disk. This keeps the renderer process in-memory only and evades code-signature checks tied to filesystem artifacts.
- **Portfolio model**: Debug strings such as *"exploit number 7"* show that the suppliers maintain multiple interchangeable WebKit exploits. Once the JS primitive matches JSKit’s interface, the rest of the chain is unchanged across campaigns.

### Kernel bridge: IPC UAF -> code-sign bypass pattern
- **Kernel IPC UAF (CVE-2023-41992)**: The second stage, still running inside the Safari context, triggers a kernel use-after-free in IPC code, re-allocates the freed object from userland, and abuses the dangling pointers to pivot into arbitrary kernel read/write. The stage also reuses PAC bypass material previously computed by JSKit instead of re-deriving it.
- **Code-signing bypass (CVE-2023-41991)**: With kernel R/W available, the exploit patches the trust cache / code-signing structures so unsigned payloads execute as `system`. The stage then exposes a lightweight kernel R/W service to later payloads.
- **Composed pattern**: This chain demonstrates a reusable recipe that defenders should expect going forward:
```
WebKit renderer RCE -> kernel IPC UAF -> kernel arbitrary R/W -> code-sign bypass -> unsigned system stager
```
### PREYHUNTER — moduły helper i watcher
- **Watcher anti-analysis**: Dedykowany binarny watcher ciągle profiluje urządzenie i przerywa kill-chain, gdy wykryte zostanie środowisko badawcze. Inspekcje obejmują `security.mac.amfi.developer_mode_status`, obecność konsoli `diagnosticd`, locales `US` lub `IL`, ślady jailbreaku takie jak **Cydia**, procesy takie jak `bash`, `tcpdump`, `frida`, `sshd` lub `checkrain`, mobilne AV (McAfee, AvastMobileSecurity, NortonMobileSecurity), niestandardowe ustawienia HTTP proxy oraz niestandardowe root CAs. Niepowodzenie któregokolwiek testu blokuje dalszą dostawę payloadu.
- **Helper surveillance hooks**: Komponent helper komunikuje się z innymi etapami przez `/tmp/helper.sock`, a następnie ładuje zestawy hooków o nazwach **DMHooker** i **UMHooker**. Te hooki przechwytują ścieżki audio VOIP (nagrania zapisywane są pod `/private/var/tmp/l/voip_%lu_%u_PART.m4a`), implementują system-wide keylogger, wykonują zdjęcia bez UI oraz hookują SpringBoard, aby stłumić powiadomienia, które te akcje normalnie wywołałyby. Helper pełni więc rolę ukrytej warstwy walidacji i lekkiego nadzoru przed wdrożeniem cięższych implantów, takich jak Predator.

### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

## Odniesienia

- [Google Threat Intelligence – Intellexa zero-day exploits continue](https://cloud.google.com/blog/topics/threat-intelligence/intellexa-zero-day-exploits-continue)

{{#include ../../banners/hacktricks-training.md}}
