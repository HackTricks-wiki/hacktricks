# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

- **Code Signing** in iOS works by requiring every piece of executable code (apps, libraries, extensions, etc.) to be cryptographically signed with a certificate issued by Apple. When code is loaded, iOS verifies the digital signature against Apple’s trusted root. If the signature is invalid, missing, or modified, the OS refuses to run it. This prevents attackers from injecting malicious code into legitimate apps or running unsigned binaries, effectively stopping most exploit chains that rely on executing arbitrary or tampered code.
- **CoreTrust** is the iOS subsystem responsible for enforcing code signing at runtime. It directly verifies signatures using Apple’s root certificate without relying on cached trust stores, meaning only binaries signed by Apple (or with valid entitlements) can execute. CoreTrust ensures that even if an attacker tampers with an app after installation, modifies system libraries, or tries to load unsigned code, the system will block execution unless the code is still properly signed. This strict enforcement closes many post-exploitation vectors that older iOS versions allowed through weaker or bypassable signature checks.
- **Data Execution Prevention (DEP)** marks memory regions as non-executable unless they explicitly contain code. This stops attackers from injecting shellcode into data regions (like the stack or heap) and running it, forcing them to rely on more complex techniques like ROP (Return-Oriented Programming).
- **ASLR (Address Space Layout Randomization)** randomizes the memory addresses of code, libraries, stack, and heap every time the system runs. This makes it much harder for attackers to predict where useful instructions or gadgets are, breaking many exploit chains that depend on fixed memory layouts.
- **KASLR (Kernel ASLR)** applies the same randomization concept to the iOS kernel. By shuffling the kernel’s base address at each boot, it prevents attackers from reliably locating kernel functions or structures, raising the difficulty of kernel-level exploits that would otherwise gain full system control.
- **Kernel Patch Protection (KPP)** also known as **AMCC (Apple Mobile File Integrity)** in iOS, continuously monitors the kernel’s code pages to ensure they haven’t been modified. If any tampering is detected—such as an exploit trying to patch kernel functions or insert malicious code—the device will immediately panic and reboot. This protection makes persistent kernel exploits far harder, as attackers can’t simply hook or patch kernel instructions without triggering a system crash.
- **Kernel Text Readonly Region (KTRR)** is a hardware-based security feature introduced on iOS devices. It uses the CPU’s memory controller to mark the kernel’s code (text) section as permanently read-only after boot. Once locked, even the kernel itself cannot modify this memory region. This prevents attackers—and even privileged code—from patching kernel instructions at runtime, closing off a major class of exploits that relied on modifying kernel code directly.
- **Pointer Authentication Codes (PAC)** use cryptographic signatures embedded into unused bits of pointers to verify their integrity before use. When a pointer (like a return address or function pointer) is created, the CPU signs it with a secret key; before dereferencing, the CPU checks the signature. If the pointer was tampered with, the check fails and execution stops. This prevents attackers from forging or reusing corrupted pointers in memory corruption exploits, making techniques like ROP or JOP much harder to pull off reliably.
- **Privilege Access never (PAN)** is a hardware feature that prevents the kernel (privileged mode) from directly accessing user-space memory unless it explicitly enables access. This stops attackers who gained kernel code execution from easily reading or writing user memory to escalate exploits or steal sensitive data. By enforcing strict separation, PAN reduces the impact of kernel exploits and blocks many common privilege-escalation techniques.
- **Page Protection Layer (PPL)** is an iOS security mechanism that protects critical kernel-managed memory regions, especially those related to code signing and entitlements. It enforces strict write protections using the MMU (Memory Management Unit) and additional checks, ensuring that even privileged kernel code cannot arbitrarily modify sensitive pages. This prevents attackers who gain kernel-level execution from tampering with security-critical structures, making persistence and code-signing bypasses significantly harder.

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

The kernel used a **zone allocator** (`kalloc`) divided into fixed-size "zones."
Each zone only stores allocations of a single size class.

From the screenshot:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | 매우 작은 커널 구조체, 포인터.                                               |
| `default.kalloc.32`  | 32 bytes     | 작은 구조체, 객체 헤더.                                                      |
| `default.kalloc.64`  | 64 bytes     | IPC 메시지, 작은 커널 버퍼.                                                  |
| `default.kalloc.128` | 128 bytes    | `OSObject`의 일부처럼 중간 크기 객체.                                        |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | 큰 구조체, `IOSurface`/그래픽 메타데이터.                                   |

**How it worked:**
- Each allocation request gets **rounded up** to the nearest zone size.
(E.g., a 50-byte request lands in the `kalloc.64` zone).
- Memory in each zone was kept in a **free list** — chunks freed by the kernel went back into that zone.
- If you overflowed a 64-byte buffer, you’d overwrite the **next object in the same zone**.

This is why **heap spraying / feng shui** was so effective: you could predict object neighbors by spraying allocations of the same size class.

### The freelist

Inside each kalloc zone, freed objects weren’t returned directly to the system — they went into a freelist, a linked list of available chunks.

- When a chunk was freed, the kernel wrote a pointer at the start of that chunk → the address of the next free chunk in the same zone.

- The zone kept a HEAD pointer to the first free chunk.

- Allocation always used the current HEAD:

1. Pop HEAD (return that memory to the caller).

2. Update HEAD = HEAD->next (stored in the freed chunk’s header).

- Freeing pushed chunks back:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

So the freelist was just a linked list built inside the freed memory itself.

Normal state:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### freelist 악용

free chunk의 첫 8바이트 = freelist pointer이기 때문에, 공격자는 이를 손상시킬 수 있다:

1. **Heap overflow**로 인접한 freed chunk에 침범하여 → 그 “next” pointer를 덮어쓴다.

2. **Use-after-free**로 freed object에 쓰기를 수행하여 → 그 “next” pointer를 덮어쓴다.

Then, on the next allocation of that size:

- allocator가 손상된 chunk를 꺼낸다.

- 공격자가 제공한 “next” pointer를 따라간다.

- 임의 메모리에 대한 포인터를 반환하여 fake object primitives 또는 targeted overwrite를 가능하게 한다.

Visual example of freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
This freelist 설계는 하드닝 이전에 exploitation을 매우 효과적으로 만들었다: predictable neighbors from heap sprays, raw pointer freelist links, 그리고 타입 분리가 없어 공격자가 UAF/overflow 버그를 임의의 커널 메모리 제어로 확대할 수 있었다.

### Heap Grooming / Feng Shui
The goal of heap grooming is to **힙 레이아웃을 형성**하여 공격자가 overflow 또는 use-after-free를 트리거할 때 대상(victim) 객체가 attacker-controlled 객체 바로 옆에 놓이게 하는 것이다.\
이렇게 하면 메모리 훼손이 발생했을 때 공격자는 victim 객체를 제어된 데이터로 신뢰성 있게 덮어쓸 수 있다.

**Steps:**

1. Spray allocations (fill the holes)
- 시간이 지남에 따라 커널 힙은 단편화된다: 일부 존에는 이전에 해제된 객체들로 인한 구멍이 생긴다.
- 공격자는 먼저 이러한 구멍을 채우기 위해 많은 더미 할당을 수행하여 힙을 “채워진” 상태로 만들어 예측 가능하게 만든다.

2. Force new pages
- 구멍이 채워지면 다음 할당은 존에 새로 추가된 페이지에서 할당되어야 한다.
- 새 페이지는 객체들이 오래 단편화된 메모리에 흩어지지 않고 클러스터링되도록 한다.
- 이는 공격자가 이웃 객체 배치를 훨씬 더 잘 제어할 수 있게 한다.

3. Place attacker objects
- 공격자는 이제 다시 스프레이를 수행하여 그 새 페이지들에 많은 attacker-controlled 객체를 만든다.
- 이 객체들은 모두 같은 존에 속하므로 크기와 위치가 예측 가능하다.

4. Free a controlled object (make a gap)
- 공격자는 의도적으로 자신이 만든 객체 중 하나를 해제한다.
- 이는 다음에 동일 크기의 할당이 재사용할 힙의 “구멍”을 만든다.

5. Victim object lands in the hole
- 공격자는 커널이 대상(victim) 객체(훼손하려는 객체)를 할당하도록 트리거한다.
- 그 구멍이 freelist에서 첫 번째 사용 가능한 슬롯이므로 victim은 공격자가 해제한 객체가 있던 정확한 위치에 배치된다.

6. Overflow / UAF into victim
- 이제 공격자는 victim 주변에 attacker-controlled 객체들을 갖고 있다.
- 자신의 객체에서 오버플로우하거나 해제된 것을 재사용함으로써 victim의 메모리 필드를 원하는 값으로 신뢰성 있게 덮어쓸 수 있다.

**Why it works**:

- 존 할당자 예측성: 동일 크기의 할당은 항상 같은 존에서 온다.
- Freelist 동작: 새 할당은 가장 최근에 해제된 청크를 먼저 재사용한다.
- Heap sprays: 공격자는 예측 가능한 내용으로 메모리를 채우고 레이아웃을 제어한다.
- 최종 결과: 공격자는 victim 객체가 어디에 배치되고 어떤 데이터가 그 옆에 오는지를 제어할 수 있다.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple은 할당자를 강화하여 **heap grooming을 훨씬 더 어렵게** 만들었다:

### 1. From Classic kalloc to kalloc_type
- **Before**: 각 사이즈 클래스(16, 32, 64, … 1280 등)에 대해 단일 `kalloc.<size>` 존이 존재했다. 해당 크기의 모든 객체는 거기에 배치되었기 때문에 → 공격자 객체가 특권있는 커널 객체 옆에 놓일 수 있었다.
- **Now**:
- 커널 객체는 **typed zones** (`kalloc_type`)에서 할당된다.
- 각 객체 타입(e.g., `ipc_port_t`, `task_t`, `OSString`, `OSData`)은 같은 크기여도 전용 존을 가진다.
- 객체 타입 ↔ 존 간의 매핑은 컴파일 타임에 **kalloc_type 시스템**에서 생성된다.

공격자는 더 이상 제어된 데이터(`OSData`)가 동일 크기의 민감한 커널 객체(`task_t`) 옆에 반드시 배치될 것이라고 보장할 수 없다.

### 2. Slabs and Per-CPU Caches
- 힙은 **slabs**(해당 존을 위해 고정 크기 청크로 잘라낸 메모리 페이지)로 나뉜다.
- 각 존은 경쟁을 줄이기 위해 **per-CPU cache**를 가진다.
- 할당 경로:
1. per-CPU cache 시도.
2. 비어있으면 global freelist에서 가져옴.
3. freelist도 비어있으면 새 slab(하나 이상 페이지)를 할당.
- **이점**: 이 분산화는 할당들이 서로 다른 CPU의 캐시에서 충족될 수 있어 heap sprays의 결정론성을 낮춘다.

### 3. Randomization inside zones
- 존 내에서 해제된 요소들은 단순한 FIFO/LIFO 순서로 반환되지 않는다.
- 최신 XNU는 **encoded freelist pointers**(Linux의 safe-linking 유사, ~iOS 14 도입)를 사용한다.
- 각 freelist 포인터는 **per-zone secret cookie**로 **XOR-encoded** 된다.
- 이는 공격자가 쓰기 프리미티브를 얻었을 때 가짜 freelist 포인터를 위조하는 것을 방지한다.
- 일부 할당은 slab 내에서 배치가 **무작위화**되어 스프레이만으로는 인접성을 보장하지 못한다.

### 4. Guarded Allocations
- 특정 중요한 커널 객체(e.g., credentials, task 구조체)는 **guarded zones**에서 할당된다.
- 이러한 존은 slab 사이에 **guard pages**(맵되지 않은 메모리)를 삽입하거나 객체 주변에 **redzones**를 사용한다.
- Guard page로의 오버플로우는 fault를 유발 → 조용한 손상 대신 즉시 패닉을 발생시킨다.

### 5. Page Protection Layer (PPL) and SPTM
- 해제된 객체를 제어하더라도 모든 커널 메모리를 수정할 수 있는 것은 아니다:
- **PPL (Page Protection Layer)**은 특정 영역(e.g., 코드 서명 데이터, entitlements)을 커널 자체에도 **읽기 전용**으로 강제한다.
- **A15/M2+ 장치**에서는 이 역할이 **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**로 대체/강화된다.
- 이러한 하드웨어 강제 계층은 공격자가 단일 힙 훼손에서 중요한 보안 구조를 임의로 패치하는 것을 방지한다.

### 6. Large Allocations
- 모든 할당이 `kalloc_type`을 통하지는 않는다.
- 매우 큰 요청(약 16KB 이상)은 typed zones를 우회하고 페이지 할당을 통해 직접 **kernel VM (kmem)**에서 제공된다.
- 이러한 것들은 덜 예측 가능하지만, 다른 객체와 slab를 공유하지 않기 때문에 또한 덜 exploitable 하다.

### 7. Allocation Patterns Attackers Target
심지어 이러한 보호가 있어도 공격자는 여전히 다음을 찾는다:
- **Reference count objects**: retain/release 카운터를 변조할 수 있으면 use-after-free를 발생시킬 수 있다.
- **Objects with function pointers (vtables)**: 하나를 손상시키면 여전히 제어 흐름을 얻을 수 있다.
- **Shared memory objects (IOSurface, Mach ports)**: 이들은 user ↔ kernel을 연결하기 때문에 여전히 공격 대상이다.

하지만 — 이전과 달리 — 단순히 `OSData`를 스프레이해서 `task_t` 옆에 놓이길 기대할 수 없다. 성공하려면 **type-specific bugs** 또는 **info leaks**가 필요하다.

### Example: Allocation Flow in Modern Heap

Suppose userspace calls into IOKit to allocate an `OSData` object:

1. **Type lookup** → `OSData` maps to `kalloc_type_osdata` zone (size 64 bytes).
2. Check per-CPU cache for free elements.
- If found → return one.
- If empty → go to global freelist.
- If freelist empty → allocate a new slab (page of 4KB → 64 chunks of 64 bytes).
3. Return chunk to caller.

**Freelist pointer protection**:
- Each freed chunk stores the address of the next free chunk, but encoded with a secret key.
- Overwriting that field with attacker data won’t work unless you know the key.


## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages   |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
