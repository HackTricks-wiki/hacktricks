# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

### 1. **Code Signing** / Runtime Signature Verification
**Introduced early (iPhone OS → iOS)**
이것은 기본적인 보호 중 하나입니다: **모든 실행 가능한 코드**(apps, dynamic libraries, JIT-ed code, extensions, frameworks, caches)는 Apple의 신뢰 루트로 이어지는 인증서 체인으로 암호화되어 서명되어야 합니다. 런타임에서는 바이너리를 메모리에 로드하기 전에(또는 특정 경계를 넘는 점프를 수행하기 전에) 서명을 검사합니다. 코드가 수정되었거나(비트 플립, 패치) 서명이 없으면 로드가 실패합니다.

- **Thwarts**: exploit 체인에서의 “classic payload drop + execute” 단계; arbitrary code injection; 기존 바이너리를 수정하여 악의적 로직을 삽입하는 것.
- **Mechanism detail**:
* Mach-O loader(및 dynamic linker)는 코드 페이지, 세그먼트, entitlements, team IDs, 그리고 서명이 파일 내용 전체를 커버하는지 등을 검사합니다.
* JIT 캐시나 동적으로 생성된 코드 같은 메모리 영역에 대해서는, Apple은 페이지가 서명되었거나 특수 API(예: `mprotect` with code-sign checks)를 통해 검증되도록 요구합니다.
* 서명에는 entitlements와 식별자가 포함되며; OS는 특정 API나 권한이 특정 entitlements를 필요로 한다는 것을 강제합니다(위조 불가).

<details>
<summary>Example</summary>
예를 들어 exploit가 프로세스에서 코드 실행을 얻고 heap에 shellcode를 쓰고 그로 점프하려고 한다고 가정합시다. iOS에서는 그 페이지가 실행 가능하다고 표시되는 동시에 code-signature 제약을 만족해야 합니다. 해당 shellcode는 Apple의 인증서로 서명되지 않았으므로 점프가 실패하거나 시스템이 그 메모리 영역을 실행 가능으로 만드는 것을 거부합니다.
</details>


### 2. **CoreTrust**
**Introduced around iOS 14+ era (or gradually in newer devices / later iOS)**
CoreTrust는 **런타임 바이너리 서명 검증**을 수행하는 서브시스템으로, 로컬 유저랜드 신뢰 저장소에 의존하지 않고 **Apple의 루트 인증서**에 대해 검증합니다.

- **Thwarts**: 설치 후 바이너리 변조, 시스템 라이브러리나 유저 앱을 교체/패치하려는 jailbreaking 기법; 신뢰된 바이너리를 악의적 복제본으로 바꿔 시스템을 속이는 시도.
- **Mechanism detail**:
* 로컬 신뢰 데이터베이스나 인증서 캐시를 신뢰하는 대신, CoreTrust는 Apple의 루트에 직접 참조하거나 안전한 체인으로 중간 인증서를 검증합니다.
* 기존 바이너리에 대한 수정(예: 파일시스템 상 변경)이 탐지되어 거부되도록 보장합니다.
* entitlements, team IDs, code signing 플래그 등과 같은 메타데이터를 로드 시 바이너리에 묶습니다.

<details>
<summary>Example</summary>
jailbreak이 `SpringBoard`나 `libsystem`을 패치된 버전으로 교체하여 지속성을 얻으려 시도할 수 있습니다. 그러나 OS의 loader나 CoreTrust가 검사할 때, 서명 불일치(또는 변경된 entitlements)를 발견하고 실행을 거부합니다.
</details>


### 3. **Data Execution Prevention (DEP / NX / W^X)**
**Introduced in many OSes earlier; iOS had NX-bit / w^x for a long time**
DEP는 쓰기 가능한 페이지(데이터)는 **비실행**으로, 실행 가능한 페이지는 **비쓰기**로 강제합니다. 단순히 heap이나 stack 영역에 shellcode를 쓰고 실행할 수 없습니다.

- **Thwarts**: direct shellcode execution; 고전적 buffer-overflow → 주입된 shellcode로 점프.
- **Mechanism detail**:
* MMU / 메모리 보호 플래그(페이지 테이블을 통해)가 분리를 강제합니다.
* 쓰기 가능한 페이지를 실행 가능으로 표시하려는 모든 시도는 시스템 검사를 트리거합니다(금지되거나 code-sign 승인이 필요).
* 많은 경우, 페이지를 실행 가능으로 만드는 것은 추가 제약이나 검사를 수행하는 OS API를 통해서만 가능합니다.

<details>
<summary>Example</summary>
오버플로우로 heap에 shellcode를 썼다고 합시다. 공격자는 `mprotect(heap_addr, size, PROT_EXEC)`을 시도하여 실행 가능으로 만들려 합니다. 그러나 시스템은 이를 거부하거나 새 페이지가 code-sign 제약을 통과해야 한다고 검증합니다(통과 불가).
</details>

### 4. **Address Space Layout Randomization (ASLR)**
**Introduced in iOS ~4–5 era (roughly iOS 4–5 timeframe)**
ASLR은 주요 메모리 영역(라이브러리, heap, stack 등)의 베이스 주소를 각 프로세스 실행마다 무작위화합니다. gadgets의 주소는 실행마다 달라집니다.

- **Thwarts**: ROP/JOP를 위한 고정된 gadget 주소 하드코딩; 정적 exploit 체인; 알려진 오프셋으로의 블라인드 점프.
- **Mechanism detail**:
* 로드된 각 라이브러리/동적 모듈은 무작위 오프셋으로 rebased 됩니다.
* 스택과 heap의 기본 포인터도 무작위화됩니다(특정 엔트로피 한도 내).
* 때때로 다른 영역(예: mmap 할당)도 무작위화됩니다.
* 정보-누출(leak) 완화와 결합되어, 공격자는 먼저 런타임에서 베이스 주소를 찾기 위해 address나 pointer를 leak해야 합니다.

<details>
<summary>Example</summary>
ROP 체인이 `0x….lib + offset`에 있는 gadget을 기대합니다. 하지만 `lib`는 실행마다 다르게 relocate되므로 하드코딩된 체인은 실패합니다. 익스플로잇은 gadget 주소를 계산하기 전에 모듈의 베이스 주소를 먼저 leak해야 합니다.
</details>


### 5. **Kernel Address Space Layout Randomization (KASLR)**
**Introduced in iOS ~ (iOS 5 / iOS 6 timeframe)**
유저 ASLR과 유사하게, KASLR은 부팅 시 **kernel text** 및 다른 커널 구조의 베이스를 무작위화합니다.

- **Thwarts**: 커널 코드나 데이터의 고정 위치에 의존하는 kernel-level exploits; 정적 커널 익스플로잇.
- **Mechanism detail**:
* 각 부팅마다 커널의 베이스 주소가 범위 내에서 무작위화됩니다.
* `task_structs`, `vm_map` 같은 커널 데이터 구조들도 재배치되거나 오프셋될 수 있습니다.
* 공격자는 커널 포인터를 먼저 leak하거나 정보 노출 취약점을 이용해 오프셋을 계산해야 커널 구조나 코드를 hijack할 수 있습니다.

<details>
<summary>Example</summary>
로컬 취약점이 `KERN_BASE + offset`의 커널 함수 포인터(예: vtable)를 손상하려 합니다. 그러나 `KERN_BASE`가 알려지지 않았기 때문에 공격자는 먼저 그것을 leak(예: read primitive로)한 뒤 올바른 주소를 계산해야 합니다.
</details>


### 6. **Kernel Patch Protection (KPP / AMCC)**
**Introduced in newer iOS / A-series hardware (post around iOS 15–16 era or newer chips)**
KPP(aka AMCC)는 커널 텍스트 페이지의 무결성을 지속적으로 모니터링합니다(해시나 체크섬을 통해). 허용된 윈도우 밖에서 패치(인라인 훅, 코드 수정)를 감지하면 kernel panic이나 재부팅을 트리거합니다.

- **Thwarts**: 지속적인 커널 패칭(커널 명령어 수정), 인라인 훅, 정적 함수 덮어쓰기.
- **Mechanism detail**:
* 하드웨어나 펌웨어 모듈이 커널 텍스트 영역을 모니터링합니다.
* 주기적 또는 필요시 페이지를 다시 해시하고 예상 값과 비교합니다.
* 일치하지 않으면(정상 업데이트 윈도우 밖) 장치를 패닉시켜(악의적 패치를 방지) 재부팅합니다.
* 공격자는 탐지 윈도우를 피하거나 합법적인 패치 경로를 사용해야 합니다.

<details>
<summary>Example</summary>
익스플로잇이 커널 함수 프롤로그(예: `memcmp`)를 패치하여 호출을 가로채려 합니다. 그러나 KPP는 코드 페이지의 해시가 예상과 다르다는 것을 감지하고 kernel panic을 일으켜 패치가 안정화되기 전에 장치를 크래시시킵니다.
</details>


### 7. **Kernel Text Read‐Only Region (KTRR)**
**Introduced in modern SoCs (post ~A12 / newer hardware)**
KTRR은 하드웨어로 강제되는 메커니즘입니다: 부팅 초기에 커널 텍스트가 잠기면 EL1(커널)에서 해당 코드를 더 이상 쓸 수 없게 됩니다.

- **Thwarts**: 부팅 후 커널 코드 수정(예: 패치, 인플레이스 코드 인젝션) 등 EL1 권한으로 수행하는 모든 변경.
- **Mechanism detail**:
* 부팅 중(secure/bootloader 단계) 메모리 컨트롤러(또는 보안 하드웨어 유닛)가 커널 텍스트를 포함한 물리 페이지를 읽기 전용으로 표시합니다.
* exploit가 완전한 커널 권한을 얻어도 해당 페이지들에 쓰지 못합니다.
* 이를 수정하려면 부트 체인을 먼저 손상시키거나 KTRR 자체를 무력화해야 합니다.

<details>
<summary>Example</summary>
권한 상승 익스플로잇이 EL1로 점프하여 커널 함수에 트램폴린을 쓰려 합니다(예: syscall 핸들러). 그러나 페이지가 KTRR로 읽기 전용으로 잠겨 있어서 쓰기가 실패하거나 오류를 발생시켜 패치가 적용되지 않습니다.
</details>


### 8. **Pointer Authentication Codes (PAC)**
**Introduced with ARMv8.3 (hardware), Apple beginning with A12 / iOS ~12+**
- PAC는 ARMv8.3-A에서 도입된 하드웨어 기능으로, 포인터 값(리턴 주소, 함수 포인터, 특정 데이터 포인터)의 변조를 감지하기 위해 포인터의 사용되지 않는 상위 비트에 작은 암호 서명(“MAC”)을 삽입합니다.
- 서명(“PAC”)은 포인터 값과 함께 **modifier**(컨텍스트 값, 예: stack pointer 또는 구분값)를 사용해 계산됩니다. 그래서 동일한 포인터 값도 다른 컨텍스트에서는 다른 PAC를 가집니다.
- 사용 시점에, 해당 포인터를 역참조하거나 분기하기 전에 **authenticate** 명령이 PAC를 검사합니다. 유효하면 PAC는 제거되고 순수한 포인터가 얻어집니다; 유효하지 않으면 포인터가 “poisoned”되거나 fault가 발생합니다.
- PAC를 생성/검증하는 키는 특권 레지스터(EL1, kernel)에 저장되며 유저 모드에서 직접 읽을 수 없습니다.
- 많은 시스템에서 포인터의 모든 64비트를 사용하지 않기 때문에(예: 48비트 주소 공간), 상위 비트가 “여유”로 남아 PAC를 보관할 수 있습니다.

#### Architectural Basis & Key Types

- ARMv8.3는 **다섯 개의 128-bit 키**(각각 두 개의 64-bit 시스템 레지스터로 구현)를 도입합니다.
- **APIAKey** — instruction pointers 용(도메인 “I”, key A)
- **APIBKey** — 두 번째 instruction pointer 키(도메인 “I”, key B)
- **APDAKey** — data pointers 용(도메인 “D”, key A)
- **APDBKey** — data pointers 용(도메인 “D”, key B)
- **APGAKey** — “generic” 키, 포인터가 아닌 데이터나 기타 일반적 용도 서명

- 이 키들은 특권 시스템 레지스터에 저장되며(EL1/EL2 등에서만 접근 가능), 유저 모드에서 접근 불가합니다.
- PAC는 암호 함수(ARM은 QARMA를 제안)를 통해 계산됩니다. 입력은:
1. 포인터 값(정규화된 부분)
2. **modifier**(컨텍스트 값, 예: salt)
3. 비밀 키
4. 내부 튜윅 로직
만약 산출된 PAC가 포인터의 상위 비트에 저장된 값과 일치하면 인증이 성공합니다.

#### Instruction Families

명명 규칙은: **PAC** / **AUT** / **XPAC**, 그 다음에 도메인 글자들입니다.
- `PACxx` 명령은 포인터에 서명하고 PAC를 삽입합니다
- `AUTxx` 명령은 인증 후 PAC를 제거합니다(검증 + strip)
- `XPACxx` 명령은 검증 없이 PAC를 제거합니다

Domains / suffixes:

| Mnemonic     | Meaning / Domain                      | Key / Domain     | Example Usage in Assembly |
|--------------|-----------------------------------------|--------------------|-----------------------------|
| **PACIA**    | Sign instruction pointer with APIAKey   | “I, A”             | `PACIA X0, X1` — sign pointer in X0 using APIAKey with modifier X1|
| **PACIB**    | Sign instruction pointer with APIBKey   | “I, B”             | `PACIB X2, X3`              |
| **PACDA**    | Sign data pointer with APDAKey           | “D, A”             | `PACDA X4, X5`              |
| **PACDB**    | Sign data pointer with APDBKey           | “D, B”             | `PACDB X6, X7`              |
| **PACG / PACGA** | Generic (non-pointer) signing with APGAKey | “G”         | `PACGA X8, X9, X10` (sign X9 with modifier X10 into X8) |
| **AUTIA**    | Authenticate APIA-signed instruction pointer & strip PAC | “I, A” | `AUTIA X0, X1` — check PAC on X0 using modifier X1, then strip |
| **AUTIB**    | Authenticate APIB domain                 | “I, B”             | `AUTIB X2, X3`               |
| **AUTDA**    | Authenticate APDA-signed data pointer    | “D, A”             | `AUTDA X4, X5`               |
| **AUTDB**    | Authenticate APDB-signed data pointer    | “D, B”             | `AUTDB X6, X7`               |
| **AUTGA**    | Authenticate generic / blob (APGA)        | “G”               | `AUTGA X8, X9, X10` (validate generic) |
| **XPACI**     | Strip PAC (instruction pointer, no validation) | “I”         | `XPACI X0` — remove PAC from X0 (instruction domain) |
| **XPACD**     | Strip PAC (data pointer, no validation)    | “D”             | `XPACD X4` — remove PAC from data pointer in X4 |

특수화된 / alias 형태도 있습니다:

- `PACIASP`는 `PACIA X30, SP`의 축약형입니다(링크 레지스터를 SP를 modifier로 서명)
- `AUTIASP`는 `AUTIA X30, SP`입니다(링크 레지스터를 SP로 인증)
- `RETAA`, `RETAB`(authenticate-and-return)나 `BLRAA`(authenticate & branch) 같은 결합 형태가 ARM 확장/컴파일러 지원에 존재합니다.
- modifier가 0인 변형도 있습니다: `PACIZA` / `PACIZB`처럼 modifier가 암묵적으로 0인 경우 등.

#### Modifiers

modifier의 주된 목적은 PAC를 특정 컨텍스트에 바인딩하는 것입니다. 그래서 동일한 주소를 다른 컨텍스트에서 재사용하면 다른 PAC가 되어 재사용을 방지합니다. 해시에 salt를 더하는 것과 유사합니다.

따라서:
- **modifier**는 컨텍스트 값(다른 레지스터)으로 PAC 계산에 혼합됩니다. 일반적인 선택지는 stack pointer(`SP`), frame pointer, 또는 object ID입니다.
- SP를 modifier로 사용하는 것은 리턴 주소 서명에 흔히 쓰입니다: PAC는 특정 스택 프레임에 묶입니다. 다른 프레임에서 LR을 재사용하면 modifier가 달라져 PAC 검증이 실패합니다.
- 동일한 포인터 값이라도 다른 modifier로 서명하면 다른 PAC가 생성됩니다.
- modifier는 반드시 비밀일 필요는 없지만, 이상적으로는 공격자가 제어하지 못하는 값이어야 합니다.
- 의미 있는 modifier가 없는 경우, 일부 명령은 0이나 암묵적 상수를 사용합니다.

#### Apple / iOS / XNU Customizations & Observations

- Apple의 PAC 구현에는 **per-boot diversifiers**가 포함되어 있어 키나 튜윅이 부팅마다 바뀌어 부팅 간 재사용을 방지합니다.
- 또한 cross-domain 완화책이 있어 user 모드에서 서명된 PAC가 kernel 모드에서 쉽게 재사용되지 않도록 합니다.
- Apple M1 / Apple Silicon 리버스 엔지니어링에서는 **nine modifier types**과 키 제어를 위한 Apple-특유 시스템 레지스터가 있음이 드러났습니다.
- Apple은 리턴 주소 서명, 커널 데이터의 포인터 무결성, 서명된 스레드 컨텍스트 등 많은 커널 서브시스템 전반에 PAC를 사용합니다.
- Google Project Zero는 강력한 메모리 read/write 프리미티브가 있는 경우 커널 PAC(A 키)를 위조할 수 있음을 보였고(A12-era devices), Apple은 많은 경로를 패치했습니다.
- Apple 시스템에서는 일부 키가 **커널 전체에 대해 글로벌**인 반면 유저 프로세스는 프로세스별 키 무작위성을 가질 수 있습니다.

#### PAC Bypasses

1. **Kernel-mode PAC: theoretical vs real bypasses**

-   커널 PAC 키와 로직은(특권 레지스터, diversifier, 도메인 분리 등) 강하게 통제되므로 임의의 서명된 커널 포인터를 위조하는 것은 매우 어렵습니다.
-   Azad의 2020 "iOS Kernel PAC, One Year Later"는 iOS 12–13에서 몇몇 부분적 우회(signing gadgets, reuse of signed states, unprotected indirect branches)를 찾았지만 전체 일반화된 우회는 없었다고 보고했습니다. [bazad.github.io](https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf)
-   Apple's "Dark Magic" 커스터마이징은 더 많은 공격 표면을 좁혔습니다(domain switching, per-key enabling bits). [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Apple silicon(M1/M2)에서의 알려진 **kernel PAC bypass CVE-2023-32424**가 Zecao Cai 등에게 보고되었습니다. [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   그러나 이러한 우회는 대개 매우 특정한 gadgets나 구현 버그에 의존하며, 일반적인 우회가 아닙니다.

따라서 kernel PAC는 **매우 강력한** 것으로 간주되지만 완벽하진 않습니다.

2. **User-mode / runtime PAC bypass techniques**

이들은 더 흔하며 PAC가 적용되는 방식이나 dynamic linking / runtime 프레임워크의 불완전함을 악용합니다. 아래는 분류와 예시입니다.

2.1 **Shared Cache / A key issues**

-   **dyld shared cache**는 시스템 프레임워크와 라이브러리의 대형 사전 연결된 블롭입니다. 널리 공유되기 때문에 shared cache 내부의 함수 포인터는 이미 서명되어 있는 경우가 많아 공격자가 이 A-key 서명된 포인터들을 "PAC oracle"로 표적화합니다.
-   일부 우회 기술은 shared cache에 존재하는 A-key 서명 포인터를 추출하거나 재사용하여 gadgets와 결합하려 합니다.
-   "No Clicks Required" 발표는 shared cache 위에 오라클을 구축해 상대 주소를 유추하고 서명된 포인터와 결합해 PAC를 우회하는 방법을 설명합니다. [saelo.github.io](https://saelo.github.io/presentations/offensivecon_20_no_clicks.pdf)
-   또한 userspace의 shared library로부터 import된 함수 포인터들이 PAC로 충분히 보호되지 않아 공격자가 서명을 변경하지 않고도 함수 포인터를 얻는 사례가 보고되었습니다(Project Zero bug entry). [bugs.chromium.org](https://bugs.chromium.org/p/project-zero/issues/detail?id=2044&utm_source=chatgpt.com)

2.2 **dlsym(3) / dynamic symbol resolution**

-   알려진 우회 중 하나는 `dlsym()`을 호출해 *이미 서명된* 함수 포인터(A-key로 서명, diversifier zero)를 얻는 것입니다. `dlsym`이 합법적으로 서명된 포인터를 반환하면 이를 사용함으로써 PAC를 위조할 필요를 회피할 수 있습니다.
-   Epsilon의 블로그는 일부 우회가 이를 어떻게 악용하는지 상세히 설명합니다: `dlsym("someSym")`은 서명된 포인터를 반환하며 간접 호출에 사용될 수 있습니다. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)
-   Synacktiv의 "iOS 18.4 --- dlsym considered harmful"는 iOS 18.4에서 `dlsym`으로 해석된 일부 심볼이 잘못 서명되거나(diversifier 버그) 의도치 않은 PAC 우회를 가능하게 했던 버그를 설명합니다. [Synacktiv](https://www.synacktiv.com/en/publications/ios-184-dlsym-considered-harmful)
-   dyld의 logic에는: `result->isCode`일 때 반환된 포인터를 `__builtin_ptrauth_sign_unauthenticated(..., key_asia, 0)`로 서명한다는 부분이 포함됩니다(컨텍스트 0). [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

따라서 `dlsym`은 user-mode PAC 우회를 위한 빈번한 벡터입니다.

2.3 **Other DYLD / runtime relocations**

-   DYLD 로더와 동적 재배치 로직은 복잡하며 때때로 재배치를 수행하기 위해 페이지를 일시적으로 read/write로 맵핑하고 다시 read-only로 전환합니다. 공격자는 이러한 창을 악용합니다. Synacktiv의 발표는 동적 재배치를 통한 타이밍 기반 PAC 우회("Operation Triangulation")를 설명합니다. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)
-   DYLD 페이지들은 이제 SPRR / VM_FLAGS_TPRO 같은 보호로 보호됩니다(몇몇 보호 플래그). 그러나 이전 버전은 더 약한 보호를 가지고 있었습니다. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)
-   WebKit exploit 체인에서는 DYLD loader가 PAC 우회의 표적이 되는 경우가 많습니다. 슬라이드들은 많은 PAC 우회가 DYLD loader(재배치, interposer hooks)를 겨냥했다고 언급합니다. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

2.4 **NSPredicate / NSExpression / ObjC / SLOP**

-   userland exploit 체인에서는 Objective-C 런타임 메서드(`NSPredicate`, `NSExpression`, `NSInvocation`)가 통제된 메모리로 제어 호출을 밀반입(smuggle)하기 위해 사용됩니다.
-   PAC 도입 이전의 오래된 iOS에서는 **fake NSInvocation** 객체를 사용해 제어된 메모리에서 임의 selector를 호출하는 익스플로잇이 있었습니다. PAC가 도입되면서 수정이 필요했지만, SLOP(SeLector Oriented Programming) 기법은 PAC 하에서도 확장되어 사용됩니다. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)
-   원래 SLOP 기법은 가짜 invocations를 만들어 ObjC 호출을 체인할 수 있게 했습니다; 우회는 ISA나 selector 포인터가 항상 PAC로 완전히 보호되지 않는다는 사실을 이용했습니다. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)
-   PAC가 부분적으로만 적용되는 환경에서는 메서드/selector/target 포인터가 항상 PAC 보호를 받지 않아 우회 여지가 생깁니다.

#### Example Flow

<details>
<summary>Example Signing & Authenticating</summary>
```
; Example: function prologue / return address protection
my_func:
stp x29, x30, [sp, #-0x20]!        ; push frame pointer + LR
mov x29, sp
PACIASP                            ; sign LR (x30) using SP as modifier
; … body …
mov sp, x29
ldp x29, x30, [sp], #0x20         ; restore
AUTIASP                            ; authenticate & strip PAC
ret

; Example: indirect function pointer stored in a struct
; suppose X1 contains a function pointer
PACDA X1, X2     ; sign data pointer X1 with context X2
STR X1, [X0]      ; store signed pointer

; later retrieval:
LDR X1, [X0]
AUTDA X1, X2       ; authenticate & strip
BLR X1             ; branch to valid target

; Example: stripping for comparison (unsafe)
LDR X1, [X0]
XPACI X1           ; strip PAC (instruction domain)
CMP X1, #some_label_address
BEQ matched_label
```
</details>

<details>
<summary>예시</summary>
버퍼 오버플로우는 스택의 리턴 주소를 덮어쓴다. 공격자는 타깃 가젯 주소를 쓰지만 올바른 PAC을 계산하지 못한다. 함수가 반환될 때 CPU의 `AUTIA` 명령이 PAC 불일치로 인해 오류를 발생시킨다. 체인은 실패한다.
Project Zero의 A12 (iPhone XS) 분석은 Apple의 PAC 사용 방식과 공격자가 메모리 읽기/쓰기 primitive를 가진 경우 PAC을 위조하는 방법을 보여주었다.
</details>


### 9. **분기 대상 식별 (Branch Target Identification, BTI)**
**ARMv8.5(이후 하드웨어)에서 도입**
BTI는 **간접 분기 대상**을 검사하는 하드웨어 기능이다: `blr` 또는 간접 call/jump를 실행할 때, 타깃은 **BTI 착지 패드**(`BTI j` 또는 `BTI c`)로 시작해야 한다. 착지 패드가 없는 가젯 주소로 점프하면 예외가 발생한다.

LLVM의 구현 문서는 BTI 명령의 세 가지 변형과 이들이 분기 유형에 어떻게 매핑되는지 기술한다.

| BTI 변형 | 허용하는 것(어떤 분기 유형) | 전형적인 배치 / 사용 사례 |
|-------------|----------------------------------------|-------------------------------|
| **BTI C** | *call*-스타일 간접 분기의 대상 (예: `BLR`, 또는 X16/X17을 사용하는 `BR`) | 간접 호출될 수 있는 함수의 시작에 배치 |
| **BTI J** | *jump*-스타일 분기의 대상 (예: tail call에 사용되는 `BR`) | 점프 테이블이나 tail-call로 도달 가능한 블록의 시작에 배치 |
| **BTI JC** | C와 J 둘 다의 역할 | call 또는 jump 분기 모두에 의해 타겟이 될 수 있음 |

- 분기 대상 강제가 활성화된 코드에서는, 컴파일러가 각 유효한 간접 분기 대상(함수 시작이나 점프로 도달 가능한 블록)에 BTI 명령(C, J, 또는 JC)을 삽입하여 간접 분기가 오직 그러한 장소로만 성공하도록 한다.
- **직접 분기/호출**(즉 고정 주소의 `B`, `BL`)은 BTI의 제한을 받지 않는다. 이는 코드 페이지가 신뢰되며 공격자가 이를 변경할 수 없다는 가정(따라서 직접 분기는 안전함)에 기반한다.
- 또한, **RET / return** 명령은 일반적으로 BTI의 제한을 받지 않는데, 리턴 주소는 PAC 또는 리턴 서명 메커니즘으로 보호되기 때문이다.

#### 메커니즘과 강제

- CPU가 “guarded / BTI-enabled”로 표시된 페이지에서 **간접 분기(BLR / BR)**를 디코드할 때, 타깃 주소의 첫 번째 명령어가 유효한 BTI(C, J, 또는 허용된 경우 JC)인지 확인한다. 그렇지 않으면 **Branch Target Exception**이 발생한다.
- BTI 명령 인코딩은 이전 ARM 버전에서 NOP로 예약되었던 opcode를 재사용하도록 설계되었다. 따라서 BTI-enabled 바이너리는 하드웨어에 BTI 지원이 없어도 역호환성을 유지한다: 해당 명령어들은 NOP로 동작한다.
- BTI를 추가하는 컴파일러 패스는 필요한 곳에만 BTI를 삽입한다: 간접 호출될 수 있는 함수들이나 점프로 타겟이 되는 기본 블록들에만.
- 일부 패치와 LLVM 코드에서는 BTI가 *모든* 기본 블록에 삽입되지 않음을 보여준다 — 오직 잠재적 분기 대상인 블록들(예: switch / jump table에서 오는 블록)에만 삽입된다.

#### BTI + PAC의 시너지

PAC은 포인터 값(소스)을 보호한다 — 간접 호출/리턴 체인이 변조되지 않았음을 보장한다.

BTI는 유효한 포인터라 하더라도 오직 적절히 표기된 진입 지점만을 타깃으로 삼게 한다.

결합하면, 공격자는 올바른 PAC을 가진 유효한 포인터뿐만 아니라 타깃 위치에도 BTI가 배치되어 있어야 한다. 이는 익스플로잇 가젯을 구성하는 난이도를 증가시킨다.

#### 예시


<details>
<summary>예시</summary>
익스플로잇이 `0xABCDEF`에 있는 가젯으로 피벗하려고 하는데 그 주소는 `BTI c`로 시작하지 않는다. CPU는 `blr x0`를 실행할 때 타깃을 확인하고 유효한 착지 패드가 없으므로 오류를 발생시킨다. 따라서 많은 가젯은 BTI 접두사가 포함되어 있지 않으면 사용할 수 없게 된다.
</details>


### 10. **Privileged Access Never (PAN) & Privileged Execute Never (PXN)**
**더 최근의 ARMv8 확장 / iOS 하드닝된 커널 지원에서 도입**

#### PAN (Privileged Access Never)

- **PAN**은 **ARMv8.1-A**에서 도입된 기능으로, **특권 코드**(EL1 또는 EL2)가 **사용자 접근 가능(EL0)**로 표시된 메모리를 **읽거나 쓰지 못하도록** 한다. 단, PAN을 명시적으로 비활성화한 경우는 예외이다.
- 아이디어는: 커널이 속임을 당하거나 손상되더라도, 먼저 PAN을 *해제*하지 않는 한 임의로 사용자 공간 포인터를 역참조할 수 없게 하여 **ret2usr** 스타일 익스플로잇이나 사용자 제어 버퍼의 오용 위험을 줄이는 것이다.
- PAN이 활성화되어 있을 때(PSTATE.PAN = 1), 특권 로드/스토어 명령이 “EL0에서 접근 가능한” 가상 주소에 접근하면 **권한 오류(permission fault)**를 일으킨다.
- 커널은 정당하게 사용자 공간 메모리에 접근해야 할 때(예: 사용자 버퍼로/로부터 데이터 복사), **일시적으로 PAN을 비활성화**하거나 “비특권 로드/스토어” 명령을 사용해야 한다.
- ARM64의 Linux에서는 PAN 지원이 대략 2015년경에 도입되었다: 커널 패치들이 기능 감지를 추가하고 `get_user` / `put_user` 등을 PAN을 해제하는 버전으로 대체했다.

**주요 뉘앙스 / 제한 / 버그**
- Siguza 등에서 지적한 바와 같이, ARM 설계의 명세 버그(또는 모호한 동작)로 인해 **execute-only user mappings**(`--x`)은 **PAN을 유발하지 않을 수 있다**. 즉, 사용자 페이지가 실행 가능하지만 읽기 권한이 없으면, 커널의 읽기 시도가 PAN을 우회할 수 있다 — 아키텍처가 “EL0에서 접근 가능”을 판단할 때 읽기 권한을 요구하고 실행 가능 여부만으로는 판단하지 않기 때문이다. 이는 특정 구성에서 PAN 우회로 이어질 수 있다.
- 따라서, iOS / XNU가 execute-only 사용자 페이지를 허용한다면(예: 일부 JIT 또는 코드 캐시 설정), PAN이 활성화된 상태에서도 커널이 실수로 그들로부터 읽을 수 있는 경우가 있다. 이는 일부 ARMv8+ 시스템에서 알려진 미묘한 취약 영역이다.

#### PXN (Privileged eXecute Never)

- **PXN**은 페이지 테이블 플래그(페이지 테이블 항목의 리프 또는 블록 항목)에 있는 비트로, 해당 페이지가 **특권 모드에서 실행 불가**(즉 EL1이 실행할 때)임을 표시한다.
- PXN은 커널(또는 어떤 특권 코드도)이 사용자 공간 페이지에서 명령을 점프하거나 실행하는 것을 방지한다. 결과적으로 특권 레벨에서의 제어 흐름이 사용자 메모리로 리디렉션되는 것을 차단한다.
- PAN과 결합하면 다음을 보장한다:
1. 커널은 기본적으로 사용자 공간 데이터를 읽거나 쓰지 못한다 (PAN)
2. 커널은 사용자 공간 코드를 실행할 수 없다 (PXN)
- ARMv8 페이지 테이블 형식에서, 리프 항목들은 속성 비트에 `PXN` 비트(그리고 비특권 실행 금지인 `UXN`)를 포함한다.

따라서 만약 커널이 사용자 메모리를 가리키는 손상된 함수 포인터를 가지고 있고 거기로 분기하려고 해도, PXN 비트가 있으면 오류가 발생한다.

#### 메모리 권한 모델 & PAN과 PXN이 페이지 테이블 비트에 매핑되는 방식

PAN / PXN의 동작을 이해하려면 ARM의 변환 및 권한 모델을 봐야 한다(단순화):

- 각 페이지 또는 블록 항목은 읽기/쓰기, 특권 대 비특권을 나타내는 **AP[2:1]**과 실행 불가 제한을 위한 **UXN / PXN** 비트를 포함한 속성 필드를 가진다.
- PSTATE.PAN이 1(활성)일 때 하드웨어는 수정된 의미론을 강제한다: “EL0에 의해 접근 가능”으로 표시된 페이지에 대한 특권 접근은 금지된다(오류 발생).
- 앞서 언급한 버그 때문에, 읽기 권한 없이 실행만 가능한 페이지들은 특정 구현에서 “EL0에 의해 접근 가능”으로 간주되지 않을 수 있어 PAN을 우회할 수 있다.
- 페이지의 PXN 비트가 설정되어 있으면, 더 높은 특권 수준에서의 명령 페치라 하더라도 실행이 금지된다.

#### 하드닝된 OS(예: iOS / XNU)에서 PAN / PXN의 커널 사용

하드닝된 커널 설계에서는:

- 커널이 기본적으로 PAN을 활성화한다(따라서 특권 코드는 제약을 받음).
- 사용자 버퍼를 정당하게 읽거나 써야 하는 경로(예: 시스템 콜 버퍼 복사, I/O, read/write 사용자 포인터)에서는 커널이 일시적으로 **PAN을 비활성화**하거나 사용자 메모리 접근을 재개하기 위한 특수 명령을 사용한다.
- 사용자 데이터 접근을 마친 후에는 PAN을 다시 활성화해야 한다.
- PXN은 페이지 테이블을 통해 강제된다: 사용자 페이지는 PXN = 1로 설정되어(따라서 커널이 이를 실행할 수 없음), 커널 페이지는 PXN이 설정되지 않는다(커널 코드는 실행 가능).
- 커널은 제어 흐름이 사용자 메모리 영역으로 이동하지 않도록 코드 경로를 보장해야 한다(그렇지 않으면 PXN을 우회할 수 있음) — 사용자 제어 쉘코드로 점프하는 익스플로잇 체인은 차단된다.

앞서 언급한 execute-only 페이지를 통한 PAN 우회 때문에, 실제 시스템에서 Apple은 execute-only 사용자 페이지를 비활성화하거나 명세의 약점을 회피하는 패치를 적용할 수 있다.


#### 공격 표면, 우회 방법, 및 완화책

- **execute-only 페이지를 통한 PAN 우회**: 앞서 논의했듯, 명세는 격차를 허용한다: 읽기 권한 없이 실행만 가능한 사용자 페이지는 어떤 구현에서 “EL0에서 접근 가능”으로 간주되지 않을 수 있어 PAN이 차단하지 못한다. 이는 공격자에게 execute-only 섹션을 통해 데이터를 공급하는 비정상적 경로를 제공할 수 있다.
- **시간적 창 공격(Temporal window exploit)**: 커널이 필요 이상으로 PAN을 비활성화하는 창이 있다면, 레이스나 악의적 경로가 그 창을 이용해 의도하지 않은 사용자 메모리 접근을 수행할 수 있다.
- **재활성화 누락(Forgotten re-enable)**: 코드 경로가 PAN을 다시 활성화하지 못하면 이후의 커널 동작이 사용자 메모리에 잘못 접근할 수 있다.
- **PXN의 잘못된 구성**: 페이지 테이블이 사용자 페이지에 PXN을 설정하지 않거나 사용자 코드 페이지를 잘못 매핑하면 커널을 사용자 공간 코드 실행으로 속일 수 있다.
- **스펙츨레이션 / 사이드채널**: 스펙츨레이션 우회와 유사하게, 마이크로아키텍처적 부작용이 PAN / PXN 검사에 대한 일시적 위반을 초래할 수 있다(그러나 이러한 공격은 CPU 설계에 크게 의존한다).
- **복잡한 상호작용**: JIT, 공유 메모리, JIT 코드 영역과 같은 고급 기능에서는 커널이 특정 메모리 접근이나 사용자 매핑 영역에서의 실행을 허용해야 할 필요가 있다; PAN/PXN 제약 하에서 이를 안전하게 설계하는 것은 쉽지 않다.


#### 예시

<details>
<summary>코드 예시</summary>
여기에는 사용자 메모리 접근 주변에서 PAN을 활성화/비활성화하는 것과 오류가 발생할 수 있는 방식을 보여주는 설명용 의사 어셈블리 시퀀스가 있다.
```  
// Suppose kernel entry point, PAN is enabled (privileged code cannot access user memory by default)

; Kernel receives a syscall with user pointer in X0
; wants to read an integer from user space
mov   X1, X0        ; X1 = user pointer

; disable PAN to allow privileged access to user memory
MSR   PSTATE.PAN, #0   ; clear PAN bit, disabling the restriction

ldr   W2, [X1]       ; now allowed load from user address

; re-enable PAN before doing other kernel logic
MSR   PSTATE.PAN, #1   ; set PAN

; ... further kernel work ...

; Later, suppose an exploit corrupts a pointer to a user-space code page and jumps there
BR    X3             ; branch to X3 (which points into user memory)

; Because the target page is marked PXN = 1 for privileged execution,
; the CPU throws an exception (fault) and rejects execution
```
If the kernel had **not** set PXN on that user page, then the branch might succeed — which would be insecure.

If the kernel forgets to re-enable PAN after user memory access, it opens a window where further kernel logic might accidentally read/write arbitrary user memory.

If the user pointer is into an execute-only page (user page with only execute permission, no read/write), under the PAN spec bug, `ldr W2, [X1]` might **not** fault even with PAN enabled, enabling a bypass exploit, depending on implementation.

</details>

<details>
<summary>예시</summary>
A kernel vulnerability tries to take a user-provided function pointer and call it in kernel context (i.e. `call user_buffer`). Under PAN/PXN, that operation is disallowed or faults.
</details>

---

### 11. **Top Byte Ignore (TBI) / Pointer Tagging**
**Introduced in ARMv8.5 / newer (or optional extension)**
TBI means the top byte (most-significant byte) of a 64-bit pointer is ignored by address translation. This lets OS or hardware embed **tag bits** in the pointer’s top byte without affecting the actual address.

- TBI stands for **Top Byte Ignore** (sometimes called *Address Tagging*). It is a hardware feature (available in many ARMv8+ implementations) that **ignores the top 8 bits** (bits 63:56) of a 64-bit pointer when performing **address translation / load/store / instruction fetch**.
- In effect, the CPU treats a pointer `0xTTxxxx_xxxx_xxxx` (where `TT` = top byte) as `0x00xxxx_xxxx_xxxx` for the purposes of address translation, ignoring (masking off) the top byte. The top byte can be used by software to store **metadata / tag bits**.
- This gives software “free” in-band space to embed a byte of tag in each pointer without altering which memory location it refers to.
- The architecture ensures that loads, stores, and instruction fetch treat the pointer with its top byte masked (i.e. tag stripped off) before performing the actual memory access.

Thus TBI decouples the **logical pointer** (pointer + tag) from the **physical address** used for memory operations.

#### Why TBI: Use cases and motivation

- **Pointer tagging / metadata**: You can store extra metadata (e.g. object type, version, bounds, integrity tags) in that top byte. When you later use the pointer, the tag is ignored at hardware level, so you don’t need to strip manually for the memory access.
- **Memory tagging / MTE (Memory Tagging Extension)**: TBI is the base hardware mechanism that MTE builds on. In ARMv8.5, the **Memory Tagging Extension** uses bits 59:56 of the pointer as a **logical tag** and checks it against an **allocation tag** stored in memory.
- **Enhanced security & integrity**: By combining TBI with pointer authentication (PAC) or runtime checks, you can force not just the pointer value but also the tag to be correct. An attacker overwriting a pointer without the correct tag will produce a mismatched tag.
- **Compatibility**: Because TBI is optional and tag bits are ignored by hardware, existing untagged code continues to operate normally. The tag bits effectively become “don’t care” bits for legacy code.

#### Example
<details>
<summary>예시</summary>
A function pointer included a tag in its top byte (say `0xAA`). An exploit overwrites the pointer low bits but neglects the tag, so when the kernel verifies or sanitizes, the pointer fails or is rejected.
</details>

---

### 12. **Page Protection Layer (PPL)**
**Introduced in late iOS / modern hardware (iOS ~17 / Apple silicon / high-end models)** (some reports show PPL circa macOS / Apple silicon, but Apple is bringing analogous protections to iOS)

- PPL is designed as an **intra-kernel protection boundary**: even if the kernel (EL1) is compromised and has read/write capabilities, **it should not be able to freely modify** certain **sensitive pages** (especially page tables, code-signing metadata, kernel code pages, entitlements, trust caches, etc.).
- It effectively creates a **“kernel within the kernel”** — a smaller trusted component (PPL) with **elevated privileges** that alone can modify protected pages. Other kernel code must call into PPL routines to effect changes.
- This reduces the attack surface for kernel exploits: even with full arbitrary R/W/execute in kernel mode, exploit code must also somehow get into the PPL domain (or bypass PPL) to modify critical structures.
- On newer Apple silicon (A15+ / M2+), Apple is transitioning to **SPTM (Secure Page Table Monitor)**, which in many cases replaces PPL for page-table protection on those platforms.

Here’s how PPL is believed to operate, based on public analysis:

#### Use of APRR / permission routing (APRR = Access Permission ReRouting)

- Apple hardware uses a mechanism called **APRR (Access Permission ReRouting)**, which allows page table entries (PTEs) to contain small indices, rather than full permission bits. Those indices are mapped via APRR registers to actual permissions. This allows dynamic remapping of permissions per domain.
- PPL leverages APRR to segregate privilege within kernel context: only the PPL domain is permitted to update the mapping between indices and effective permissions. That is, when non-PPL kernel code writes a PTE or tries to flip permission bits, the APRR logic disallows it (or enforces read-only mapping).
- PPL code itself runs in a restricted region (e.g. `__PPLTEXT`) which is normally non-executable or non-writable until entry gates temporarily allow it. The kernel calls PPL entry points (“PPL routines”) to perform sensitive operations.

#### Gate / Entry & Exit

- When the kernel needs to modify a protected page (e.g. change permissions of a kernel code page, or modify page tables), it calls into a **PPL wrapper** routine, which does validation and then transitions into the PPL domain. Outside that domain, the protected pages are effectively read-only or non-modifiable by the main kernel.
- During PPL entry, the APRR mappings are adjusted so that memory pages in the PPL region are set to **executable & writable** within PPL. Upon exit, they are returned to read-only / non-writable. This ensures that only well-audited PPL routines can write to protected pages.
- Outside PPL, attempts by kernel code to write to those protected pages will fault (permission denied) because the APRR mapping for that code domain doesn’t permit writing.

#### Protected page categories

The pages that PPL typically protects include:

- Page table structures (translation table entries, mapping metadata)
- Kernel code pages, especially those containing critical logic
- Code-sign metadata (trust caches, signature blobs)
- Entitlement tables, signature enforcement tables
- Other high-value kernel structures where a patch would allow bypassing signature checks or credentials manipulation

The idea is that even if the kernel memory is fully controlled, the attacker cannot simply patch or rewrite these pages, unless they also compromise PPL routines or bypass PPL.


#### Known Bypasses & Vulnerabilities

1. **Project Zero’s PPL bypass (stale TLB trick)**

- A public writeup by Project Zero describes a bypass involving **stale TLB entries**.
- The idea:

1. Allocate two physical pages A and B, mark them as PPL pages (so they are protected).
2. Map two virtual addresses P and Q whose L3 translation table pages come from A and B.
3. Spin a thread to continuously access Q, keeping its TLB entry alive.
4. Call `pmap_remove_options()` to remove mappings starting at P; due to a bug, the code mistakenly removes the TTEs for both P and Q, but only invalidates the TLB entry for P, leaving Q’s stale entry live.
5. Reuse B (page Q’s table) to map arbitrary memory (e.g. PPL-protected pages). Because the stale TLB entry still maps Q’s old mapping, that mapping remains valid for that context.
6. Through this, the attacker can put writable mapping of PPL-protected pages in place without going through PPL interface.

- This exploit required fine control of physical mapping and TLB behavior. It demonstrates that a security boundary relying on TLB / mapping correctness must be extremely careful about TLB invalidations and mapping consistency.

- Project Zero commented that bypasses like this are subtle and rare, but possible in complex systems. Still, they regard PPL as a solid mitigation.

2. **Other potential hazards & constraints**

- If a kernel exploit can directly enter PPL routines (via calling the PPL wrappers), it might bypass restrictions. Thus argument validation is critical.
- Bugs in the PPL code itself (e.g. arithmetic overflow, boundary checks) can allow out-of-bounds modifications inside PPL. Project Zero observed that such a bug in `pmap_remove_options_internal()` was exploited in their bypass.
- The PPL boundary is irrevocably tied to hardware enforcement (APRR, memory controller), so it's only as strong as the hardware implementation.



#### Example
<details>
<summary>코드 예시</summary>
Here’s a simplified pseudocode / logic showing how a kernel might call into PPL to modify protected pages:
```c
// In kernel (outside PPL domain)
function kernel_modify_pptable(pt_addr, new_entry) {
// validate arguments, etc.
return ppl_call_modify(pt_addr, new_entry)  // call PPL wrapper
}

// In PPL (trusted domain)
function ppl_call_modify(pt_addr, new_entry) {
// temporarily enable write access to protected pages (via APRR adjustments)
aprr_set_index_for_write(PPL_INDEX)
// perform the modification
*pt_addr = new_entry
// restore permissions (make pages read-only again)
aprr_restore_default()
return success
}

// If kernel code outside PPL does:
*pt_addr = new_entry  // a direct write
// It will fault because APRR mapping for non-PPL domain disallows write to that page
```
The kernel can do many normal operations, but only through `ppl_call_*` routines can it change protected mappings or patch code.
</details>

<details>
<summary>예시</summary>
커널 익스플로잇이 entitlement 테이블을 덮어쓰거나 커널 서명 블롭을 수정해 code-sign 강제를 비활성화하려고 시도할 수 있습니다. 해당 페이지가 PPL로 보호되어 있기 때문에 PPL 인터페이스를 거치지 않으면 쓰기가 차단됩니다. 따라서 커널 코드 실행이 가능하더라도 code-sign 제약을 우회하거나 자격 증명 데이터를 임의로 수정할 수 없습니다.
iOS 17+에서는 특정 기기가 PPL로 관리되는 페이지를 추가로 격리하기 위해 SPTM을 사용합니다.
</details>

#### PPL → SPTM / 대체 / 향후

- Apple의 최신 SoC(A15 이상, M2 이상)에서는 **SPTM**(Secure Page Table Monitor)을 지원하며, 이는 페이지 테이블 보호를 위해 **PPL을 대체**합니다.
- Apple 문서에서는 다음과 같이 명시합니다: “Page Protection Layer (PPL) and Secure Page Table Monitor (SPTM) enforce execution of signed and trusted code … PPL manages the page table permission overrides … Secure Page Table Monitor replaces PPL on supported platforms.”
- SPTM 아키텍처는 정책 집행의 더 많은 부분을 커널 통제 밖의 더 높은 권한의 모니터로 이동시키는 경향이 있어, 신뢰 경계를 더욱 축소합니다.

### MTE | EMTE | MIE

다음은 Apple의 MIE 환경에서 EMTE가 어떻게 동작하는지에 대한 상위 수준 설명입니다:

1. **태그 할당**
- 메모리가 할당될 때(예: 커널 또는 secure allocator를 통해 user 공간에서), 해당 블록에 **비밀 태그(secret tag)** 가 할당됩니다.
- 사용자나 커널에 반환되는 포인터는 그 태그를 상위 비트에 포함합니다(사용되는 메커니즘: TBI / top byte ignore mechanisms).

2. **접근 시 태그 검사**
- 포인터를 사용해 load나 store가 실행될 때마다 하드웨어는 포인터의 태그가 메모리 블록의 태그(할당 태그)와 일치하는지 검사합니다. 불일치하면 즉시 fault가 납니다(동기적이므로).
- 동기적이기 때문에 “지연된 탐지” 창이 없습니다.

3. **free / 재사용 시 리태깅**
- 메모리가 해제되면 allocator는 블록의 태그를 변경합니다(따라서 오래된 태그를 가진 포인터는 더 이상 일치하지 않습니다).
- 따라서 use-after-free 포인터는 오래된 태그를 가지게 되어 접근 시 불일치가 발생합니다.

4. **오버플로우를 잡기 위한 인접-태그 분리**
- 인접한 할당은 서로 다른 태그를 부여받습니다. 버퍼 오버플로우가 이웃 메모리로 흘러들어갈 경우 태그 불일치로 인해 fault가 발생합니다.
- 경계를 넘는 작은 오버플로우를 잡는 데 특히 강력합니다.

5. **태그 기밀성 강제**
- 공격자가 태그를 알게 되면 올바른 태그를 가진 포인터를 조작할 수 있기 때문에 Apple은 태그 값이 being leaked(공격에 이용되지 않도록) 되는 것을 방지해야 합니다.
- 이를 위해 태그 비트를 side-channel로부터 보호하기 위한 보호장치(microarchitectural / speculative controls)를 포함합니다.

6. **커널 및 사용자 공간 통합**
- Apple은 EMTE를 사용자 공간뿐만 아니라 커널/OS 핵심 구성요소에서도 사용하여 커널을 메모리 손상으로부터 보호합니다.
- 하드웨어/OS는 사용자 공간을 대리하여 커널이 실행될 때에도 태그 규칙이 적용되도록 보장합니다.

<details>
<summary>예시</summary>
```
Allocate A = 0x1000, assign tag T1
Allocate B = 0x2000, assign tag T2

// pointer P points into A with tag T1
P = (T1 << 56) | 0x1000

// Valid store
*(P + offset) = value // tag T1 matches allocation → allowed

// Overflow attempt: P’ = P + size_of_A (into B region)
*(P' + delta) = value
→ pointer includes tag T1 but memory block has tag T2 → mismatch → fault

// Free A, allocator retags it to T3
free(A)

// Use-after-free:
*(P) = value
→ pointer still has old tag T1, memory region is now T3 → mismatch → fault
```
</details>

#### 제한사항 및 과제

- **Intrablock overflows**: 오버플로가 동일한 할당 내부에만 머물고(경계를 넘지 않으며) 할당의 태그가 동일하게 유지되면 태그 불일치가 이를 잡아내지 못한다.
- **Tag width limitation**: 태그에 사용할 수 있는 비트 수가 적다(예: 4비트 또는 작은 도메인) — 태그 네임스페이스가 제한된다.
- **Side-channel leaks**: 태그 비트가 캐시 / speculative execution 등을 통해 leak될 수 있으면 공격자가 유효한 태그를 알아내어 우회할 수 있다. Apple의 tag confidentiality enforcement는 이를 완화하려는 목적이다.
- **Performance overhead**: 각 load/store마다 태그 검사가 추가 비용을 발생시킨다; Apple은 오버헤드를 낮추기 위해 하드웨어를 최적화해야 한다.
- **Compatibility & fallback**: 구형 하드웨어나 EMTE를 지원하지 않는 부품에서는 대체 경로가 필요하다. Apple은 MIE가 지원되는 기기에서만 활성화된다고 주장한다.
- **Complex allocator logic**: 할당자는 태그 관리, retagging, 경계 정렬, 잘못된 태그 충돌 회피 등을 처리해야 한다. allocator 로직의 버그는 취약점을 유발할 수 있다.
- **Mixed memory / hybrid areas**: 일부 메모리는 여전히 untagged(레거시)로 남아 있어 상호운용성이 더 복잡해진다.
- **Speculative / transient attacks**: 많은 마이크로아키텍처 보호와 마찬가지로, speculative execution이나 micro-op fusions가 일시적으로 검사를 우회하거나 태그 비트를 leak할 수 있다.
- **Limited to supported regions**: Apple은 EMTE를 전체에 적용하지 않고 선택적, 고위험 영역(예: kernel, security-critical subsystems)에만 강제할 수 있다.

---

## 표준 MTE와 비교한 주요 향상점/차이점

Here are the improvements and changes Apple emphasizes:

| Feature | Original MTE | EMTE (Apple’s enhanced) / MIE |
|---|---|---|
| **Check mode** | 동기(synchronous) 및 비동기(asynchronous) 모드를 지원한다. 비동기에서는 태그 불일치가 나중에(지연되어) 보고된다 | Apple은 기본적으로 **synchronous mode**를 고수한다—태그 불일치는 즉시 잡히며 지연/레이스 창이 허용되지 않는다.|
| **Coverage of non-tagged memory** | non-tagged memory(예: globals)에 대한 접근은 일부 구현에서 검사를 우회할 수 있다 | EMTE는 태그된 영역에서 non-tagged memory로의 접근도 태그 정보를 검증하도록 요구하여, 할당을 섞어서 우회하기 어렵게 만든다.|
| **Tag confidentiality / secrecy** | 태그는 관찰되거나 side channels를 통해 leak될 수 있다 | Apple은 **Tag Confidentiality Enforcement**를 추가하여 태그 값의 유출(예: speculative side-channels 등)을 방지하려 한다.|
| **Allocator integration & retagging** | MTE는 할당자 로직의 많은 부분을 소프트웨어에 맡긴다 | Apple의 secure typed allocators (kalloc_type, xzone malloc, 등)는 EMTE와 통합되어: 메모리 할당/해제 시 태그를 세밀하게 관리한다.|
| **Always-on by default** | 많은 플랫폼에서 MTE는 선택적이거나 기본적으로 비활성화되어 있다 | Apple은 지원되는 하드웨어(예: iPhone 17 / A19)에서 kernel 및 많은 사용자 프로세스에 대해 EMTE / MIE를 기본으로 활성화한다.|

Apple이 하드웨어와 소프트웨어 스택을 모두 제어하므로 EMTE를 엄격하게 적용하고 성능 문제를 완화하며 side-channel 취약점을 닫을 수 있다.

---

## EMTE의 실제 동작 방식 (Apple / MIE)

여기 Apple의 MIE 설정에서 EMTE가 작동하는 상위 수준 설명이 있다:

1. **Tag assignment**
- 메모리가 할당될 때(예: kernel이나 사용자 공간에서 secure allocators를 통해), 해당 블록에 **secret tag**가 할당된다.
- 사용자나 커널에 반환되는 포인터는 상위 비트에 그 태그를 포함한다 (TBI / top byte ignore 메커니즘 사용).

2. **Tag checking on access**
- 포인터로 load나 store가 실행될 때 하드웨어는 포인터의 태그가 메모리 블록의 태그(할당 태그)와 일치하는지 검사한다. 불일치하면 즉시 fault가 발생한다(동기 방식).
- 동기이기 때문에 “지연된 탐지” 창이 없다.

3. **Retagging on free / reuse**
- 메모리가 해제되면 할당자가 블록의 태그를 변경한다(그래서 오래된 포인터의 stale 태그는 더 이상 일치하지 않는다).
- 따라서 use-after-free 포인터는 오래된 태그를 가지고 접근 시 불일치를 일으킨다.

4. **Neighbor-tag differentiation to catch overflows**
- 인접 할당들에는 서로 다른 태그를 부여한다. 버퍼 오버플로가 이웃 메모리로 흘러들어가면 태그 불일치로 fault가 발생한다.
- 이는 경계를 넘는 작은 오버플로를 잡아내는 데 특히 강력하다.

5. **Tag confidentiality enforcement**
- Apple은 태그 값이 leak되는 것을 방지해야 한다(공격자가 태그를 알게 되면 올바른 태그를 가진 포인터를 구성할 수 있기 때문).
- 이를 위해 microarchitectural / speculative 제어 등으로 태그 비트의 side-channel leakage를 막는 보호 장치를 포함한다.

6. **Kernel and user-space integration**
- Apple은 EMTE를 사용자 공간뿐 아니라 kernel / OS-핵심 구성요소에도 적용한다(커널을 메모리 손상으로부터 보호).
- 하드웨어/OS는 태그 규칙이 사용자 공간을 대신하여 커널이 실행될 때에도 적용되도록 보장한다.

EMTE가 MIE에 통합되어 있기 때문에 Apple은 EMTE를 주요 공격 표면 전반에 걸쳐 동기 모드로 사용하며, 이는 옵트인이나 디버깅 모드가 아니다.

---

## XNU에서의 예외 처리

예외가 발생할 때(예: `EXC_BAD_ACCESS`, `EXC_BAD_INSTRUCTION`, `EXC_CRASH`, `EXC_ARM_PAC`, 등), XNU 커널의 **Mach layer**는 이를 UNIX 스타일의 **signal**(예: `SIGSEGV`, `SIGBUS`, `SIGILL`, ...)로 변환하기 전에 인터셉트하는 역할을 한다.

이 과정은 사용자 공간에 도달하거나 BSD 시그널로 변환되기 전까지 여러 계층의 예외 전파 및 처리를 포함한다.


### 예외 흐름 (High-Level)

1.  CPU가 동기 예외를 트리거한다(예: 잘못된 포인터 역참조, PAC 실패, 불법 명령 등).
2.  저수준 trap handler가 실행된다 (`trap.c`, `exception.c` in XNU source).
3.  trap handler는 Mach 예외 처리의 핵심인 **`exception_triage()`**를 호출한다.
4.  `exception_triage()`는 예외를 라우팅할 방법을 결정한다:

-   먼저 **thread의 exception port**로 보낸다.
-   그 다음 **task의 exception port**로 보낸다.
-   그 다음 **host의 exception port**로 보낸다(종종 `launchd` 또는 `ReportCrash`).

만약 이 포트들 중 어느 것도 예외를 처리하지 않으면, 커널은:

-   사용자 공간 프로세스의 경우 이를 **BSD signal**로 변환하거나,
-   커널 공간 예외의 경우 **panic**을 일으킬 수 있다.


### Core Function: `exception_triage()`

함수 `exception_triage()`는 Mach 예외를 가능한 처리기 체인 상위로 라우팅하여 어느 하나가 처리하거나 최종적으로 치명적이 될 때까지 전달한다. 이 함수는 `osfmk/kern/exception.c`에 정의되어 있다.
```c
void exception_triage(exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt);
```
**전형적인 호출 흐름:**

`exception_triage()
└── exception_deliver()
├── exception_deliver_thread()
├── exception_deliver_task()
└── exception_deliver_host()`

모두 실패하면 → `bsd_exception()`에서 처리됨 → `SIGSEGV` 같은 시그널로 변환됩니다.


### 예외 포트

각 Mach 객체 (thread, task, host)는 예외 메시지가 전송되는 **예외 포트**를 등록할 수 있습니다.

이들은 API에 의해 정의됩니다:
```
task_set_exception_ports()
thread_set_exception_ports()
host_set_exception_ports()
```
각 exception port는 다음을 가집니다:

-   A **mask** (어떤 예외를 받기를 원하는지)
-   A **port name** (메시지를 받을 Mach 포트)
-   A **behavior** (커널이 메시지를 보내는 방식)
-   A **flavor** (어떤 thread state를 포함할지)


### Debuggers and Exception Handling

A **debugger** (예: LLDB)은 보통 `task_set_exception_ports()`를 사용해 대상 task나 thread에 **exception port**를 설정합니다.

**예외가 발생하면:**

-   Mach 메시지가 debugger 프로세스로 전송됩니다.
-   debugger는 예외를 **처리할지**(resume, 레지스터 수정, 명령 건너뛰기) 아니면 **처리하지 않을지** 결정할 수 있습니다.
-   debugger가 처리하지 않으면 예외는 다음 레벨로 전파됩니다 (task → host).


### Flow of `EXC_BAD_ACCESS`

1.  Thread가 잘못된 포인터를 역참조 → CPU가 Data Abort를 발생시킵니다.

2.  커널의 trap handler가 `exception_triage(EXC_BAD_ACCESS, ...)`를 호출합니다.

3.  메시지가 전송됩니다:

-   Thread port → (debugger가 breakpoint에서 가로챌 수 있음).

-   debugger가 무시하면 → Task port → (프로세스-레벨 핸들러).

-   무시되면 → Host port (보통 ReportCrash).

4.  아무도 처리하지 않으면 → `bsd_exception()`이 `SIGSEGV`로 변환합니다.


### PAC Exceptions

When **Pointer Authentication (PAC)** fails (signature mismatch), a **special Mach exception** is raised:

-   **`EXC_ARM_PAC`** (type)
-   Codes may include details (e.g., key type, pointer type).

If the binary has the flag **`TFRO_PAC_EXC_FATAL`**, the kernel treats PAC failures as **fatal**, bypassing debugger interception. This is to prevent attackers from using debuggers to bypass PAC checks and it's enabled for **platform binaries**.

### Software Breakpoints

A software breakpoint (`int3` on x86, `brk` on ARM64) is implemented by **causing a deliberate fault**.\
The debugger catches this via the exception port:

-   명령 포인터 또는 메모리를 수정합니다.
-   원래 명령을 복원합니다.
-   실행을 재개합니다.

이 동일한 메커니즘으로 PAC 예외를 "catch"할 수 있습니다 --- **단, `TFRO_PAC_EXC_FATAL`이 설정된 경우**에는 debugger에 절대 도달하지 않습니다.


### Conversion to BSD Signals

핸들러가 예외를 수락하지 않으면:

-   커널은 `task_exception_notify() → bsd_exception()`을 호출합니다.

-   이 과정은 Mach 예외를 시그널로 매핑합니다:

| Mach Exception | Signal |
| --- | --- |
| EXC_BAD_ACCESS | SIGSEGV or SIGBUS |
| EXC_BAD_INSTRUCTION | SIGILL |
| EXC_ARITHMETIC | SIGFPE |
| EXC_SOFTWARE | SIGTRAP |
| EXC_BREAKPOINT | SIGTRAP |
| EXC_CRASH | SIGKILL |
| EXC_ARM_PAC | SIGILL (on non-fatal) |


### Key Files in XNU Source

-   `osfmk/kern/exception.c` → `exception_triage()`, `exception_deliver_*()`의 핵심.

-   `bsd/kern/kern_sig.c` → 시그널 전달 로직.

-   `osfmk/arm64/trap.c` → 저수준 trap 핸들러들.

-   `osfmk/mach/exc.h` → 예외 코드와 구조체들.

-   `osfmk/kern/task.c` → Task exception port 설정.


---

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

커널은 고정 크기 "zones"로 나뉜 **zone allocator**(`kalloc`)를 사용했습니다.  
각 zone은 단일 크기 클래스의 할당만 저장합니다.

From the screenshot:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | 매우 작은 kernel 구조체들, 포인터.                                           |
| `default.kalloc.32`  | 32 bytes     | 작은 구조체들, 객체 헤더.                                                   |
| `default.kalloc.64`  | 64 bytes     | IPC 메시지, 아주 작은 커널 버퍼.                                            |
| `default.kalloc.128` | 128 bytes    | `OSObject`의 일부 같은 중간 크기 객체들.                                    |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | 큰 구조체들, IOSurface/그래픽스 메타데이터.                                  |

**동작 방식:**
- 각 할당 요청은 가장 가까운 zone 크기로 **올림**됩니다.
(예: 50바이트 요청은 `kalloc.64` zone에 들어갑니다).
- 각 zone의 메모리는 **freelist**에 보관되었습니다 — 커널이 해제한 청크들은 해당 zone으로 돌아갔습니다.
- 64바이트 버퍼를 오버플로우하면 동일 zone의 **다음 객체를 덮어쓰게** 됩니다.

이 때문에 **heap spraying / feng shui**가 매우 효과적이었습니다: 동일 크기 클래스의 할당을 뿌려 이웃 객체를 예측할 수 있었기 때문입니다.

### The freelist

각 kalloc zone 내부에서, 해제된 객체들은 시스템으로 즉시 반환되지 않고 freelist에 들어갔습니다. freelist는 사용 가능한 청크들의 연결 리스트입니다.

- 청크가 해제되면, 커널은 그 청크의 시작 부분에 포인터를 씁니다 → 같은 zone의 다음 free 청크의 주소.

- zone은 첫 번째 free 청크를 가리키는 HEAD 포인터를 유지합니다.

- 할당은 항상 현재 HEAD를 사용했습니다:

1. HEAD를 팝(pop) (그 메모리를 호출자에게 반환).

2. HEAD = HEAD->next로 업데이트 (해제된 청크의 헤더에 저장된 값).

- 해제는 청크를 다시 푸시(push)했습니다:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

따라서 freelist는 해제된 메모리 자체 안에 구축된 단순 연결 리스트였습니다.

Normal state:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### freelist 악용

Because the first 8 bytes of a free chunk = freelist pointer, 공격자는 이를 손상시킬 수 있다:

1. **Heap overflow** into an adjacent freed chunk → overwrite its “next” pointer.

2. **Use-after-free** write into a freed object → overwrite its “next” pointer.

그다음, 동일한 크기의 다음 할당에서:

- The allocator pops the corrupted chunk.

- Follows the attacker-supplied “next” pointer.

- Returns a pointer to arbitrary memory, enabling fake object primitives or targeted overwrite.

Visual example of freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
This freelist 설계는 하드닝 이전에 익스플로잇을 매우 효과적으로 만들었다: heap sprays로 인한 예측 가능한 이웃, 원시 포인터 freelist 링크, 그리고 타입 분리가 없어 공격자가 UAF/overflow 버그를 임의의 커널 메모리 제어로 확장할 수 있었다.

### Heap Grooming / Feng Shui
Heap grooming의 목표는 힙 레이아웃을 조작해, 공격자가 overflow나 use-after-free를 트리거할 때 대상(victim) 객체가 공격자가 제어하는 객체 바로 옆에 오도록 만드는 것이다.\
이렇게 하면 메모리 손상이 발생했을 때 공격자는 제어된 데이터로 victim 객체를 신뢰성 있게 덮어쓸 수 있다.

**단계:**

1. Spray allocations (fill the holes)
- 시간이 지나면서 kernel heap은 조각화된다: 일부 zone에는 이전에 해제된 객체들로 인해 구멍(hole)이 생긴다.
- 공격자는 먼저 많은 더미 할당을 만들어 이러한 빈칸을 채워 heap을 “꽉 채운(packed)” 상태로 만들어 예측 가능하게 만든다.

2. Force new pages
- 구멍들이 채워지면, 다음 할당들은 zone에 새로 추가된 페이지에서 이루어진다.
- 새 페이지들은 객체들이 흩어지지 않고 클러스터(집중)되도록 한다.
- 이는 공격자가 이웃을 제어하는 데 훨씬 유리하다.

3. Place attacker objects
- 공격자는 다시 스프레이를 하여 그 새 페이지들에 많은 공격자 제어 객체를 만든다.
- 이 객체들은 동일한 zone에 속하므로 크기와 배치가 예측 가능하다.

4. Free a controlled object (make a gap)
- 공격자는 의도적으로 자신의 객체 중 하나를 해제한다.
- 이는 allocator가 같은 크기의 다음 할당을 위해 재사용할 “구멍”을 만든다.

5. Victim object lands in the hole
- 공격자는 kernel이 피해 객체(victim)를 할당하도록 트리거한다.
- 구멍이 freelist에서 첫 사용 가능한 슬롯이기 때문에 victim은 공격자가 해제한 객체가 있던 정확한 위치에 배치된다.

6. Overflow / UAF into victim
- 이제 공격자는 victim 주변에 공격자 제어 객체들을 가지고 있다.
- 자신의 객체에서 overflow를 발생시키거나 해제된 객체를 재사용함으로써 공격자는 victim의 메모리 필드를 선택한 값으로 신뢰성 있게 덮어쓸 수 있다.

**동작 원리:**

- Zone allocator의 예측 가능성: 동일한 크기의 할당은 항상 동일한 zone에서 나온다.
- Freelist 동작: 새 할당은 가장 최근에 해제된 청크를 먼저 재사용한다.
- Heap sprays: 공격자는 예측 가능한 콘텐츠로 메모리를 채우고 레이아웃을 제어한다.
- 최종 결과: 공격자는 victim 객체가 어디에 배치되고 어떤 데이터가 그 옆에 놓일지 제어할 수 있다.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple은 allocator를 강화하여 **heap grooming을 훨씬 어렵게** 만들었다:

### 1. From Classic kalloc to kalloc_type
- **Before**: 각 크기 클래스(16, 32, 64, … 1280 등)에 대해 단일 `kalloc.<size>` zone이 존재했다. 해당 크기의 어떤 객체든 그곳에 배치되었기 때문에 → 공격자 객체가 privileged kernel 객체 옆에 놓일 수 있었다.
- **Now**:
- Kernel 객체들은 **typed zones** (`kalloc_type`)에서 할당된다.
- 각 객체 타입(e.g., `ipc_port_t`, `task_t`, `OSString`, `OSData`)은 동일한 크기라도 전용 zone을 갖는다.
- 객체 타입 ↔ zone 매핑은 컴파일 시 **kalloc_type 시스템**에서 생성된다.

이제 공격자는 제어된 데이터(`OSData`)가 민감한 커널 객체(`task_t`)와 같은 크기임에도 불구하고 인접하게 배치되도록 보장할 수 없다.

### 2. Slabs and Per-CPU Caches
- 힙은 해당 zone을 위한 고정 크기 청크로 나뉜 **slabs**(메모리 페이지)로 분할된다.
- 각 zone은 경쟁을 줄이기 위해 **per-CPU cache**를 가진다.
- 할당 경로:
1. per-CPU cache를 시도.
2. 비어있으면 global freelist에서 가져옴.
3. freelist가 비어있으면 새 slab(하나 이상의 페이지)를 할당.
- **이점**: 이 분산화는 할당이 서로 다른 CPU의 캐시에서 충족될 수 있기 때문에 heap sprays를 덜 결정론적으로 만든다.

### 3. Randomization inside zones
- zone 내에서 해제된 요소들은 단순한 FIFO/LIFO 순서로 다시 제공되지 않는다.
- 현대 XNU는 **encoded freelist pointers**(Linux의 safe-linking과 유사, ~iOS 14 도입)를 사용한다.
- 각 freelist 포인터는 **per-zone 비밀 cookie로 XOR 인코딩**된다.
- 이는 공격자가 쓰기 프리미티브를 얻더라도 가짜 freelist 포인터를 위조하지 못하게 한다.
- 일부 할당은 slab 내에서 **배치가 무작위화**되어 스프레이가 인접성을 보장하지 못한다.

### 4. Guarded Allocations
- 특정 중요한 커널 객체(e.g., 자격(credentials), task 구조체)는 **guarded zones**에 할당된다.
- 이 zone들은 slab 사이에 **guard pages**(언매핑된 메모리)를 삽입하거나 객체 주변에 **redzones**를 사용한다.
- guard page로의 어떤 overflow도 fault를 트리거 → 조용한 손상 대신 즉시 panic을 발생시킨다.

### 5. Page Protection Layer (PPL) and SPTM
- 해제된 객체를 제어하더라도 모든 커널 메모리를 수정할 수 있는 것은 아니다:
- **PPL (Page Protection Layer)**은 특정 영역(e.g., 코드 서명 데이터, entitlements)을 커널 자체에게도 **읽기 전용**으로 강제한다.
- **A15/M2+ 장치**에서는 이 역할이 **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**로 대체/강화된다.
- 이러한 하드웨어 강화 계층은 공격자가 단일 heap 손상에서 중요한 보안 구조를 임의로 패치하는 것으로 권한 상승하는 것을 막는다.
- **(추가/강화됨)**: 커널에서는 포인터(특히 함수 포인터, vtables)를 보호하기 위해 **PAC (Pointer Authentication Codes)**를 사용하여 위조나 손상을 어렵게 만든다.
- **(추가/강화됨)**: zones는 **zone_require / zone enforcement**를 시행할 수 있다. 즉, 해제된 객체는 올바른 typed zone을 통해서만 반환될 수 있으며, 잘못된 cross-zone frees는 panic을 유발하거나 거부될 수 있다. (Apple은 이 점을 메모리 안전성 관련 글에서 언급한다)

### 6. Large Allocations
- 모든 할당이 `kalloc_type`을 거치는 것은 아니다.
- 매우 큰 요청(약 ~16 KB 이상)은 typed zones를 우회하고 **kernel VM (kmem)**에서 페이지 할당으로 직접 제공된다.
- 이는 덜 예측 가능하지만, 다른 객체와 slab를 공유하지 않기 때문에 exploitable 가능성도 낮다.

### 7. Allocation Patterns Attackers Target
이러한 보호에도 불구하고 공격자들이 여전히 노리는 것은:
- **Reference count objects**: retain/release 카운터를 조작할 수 있다면 use-after-free를 유발할 수 있다.
- **Objects with function pointers (vtables)**: 이를 손상시키면 여전히 제어 흐름을 얻을 수 있다.
- **Shared memory objects (IOSurface, Mach ports)**: 이들은 사용자 ↔ 커널을 잇는 다리이기 때문에 여전히 공격 대상이다.

하지만 — 이전과 달리 — 단순히 `OSData`를 스프레이해서 `task_t` 옆에 놓일 것으로 기대할 수는 없다. 성공하려면 **타입 특정 버그**나 **정보 누출(info leak)**이 필요하다.

### Example: Allocation Flow in Modern Heap

Suppose userspace calls into IOKit to allocate an `OSData` object:

1. **Type lookup** → `OSData` maps to `kalloc_type_osdata` zone (size 64 bytes).
2. Check per-CPU cache for free elements.
- If found → return one.
- If empty → go to global freelist.
- If freelist empty → allocate a new slab (page of 4KB → 64 chunks of 64 bytes).
3. Return chunk to caller.

**Freelist pointer protection**:
- Each freed chunk stores the address of the next free chunk, but encoded with a secret key.
- Overwriting that field with attacker data won’t work unless you know the key.

---

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages, and **PAC** protects pointers |
| Allocation reuse validation     | None (freelist pointers raw)                               | **zone_require / zone enforcement**             |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |
| Large allocations handling      | All small allocations managed equally                       | Large ones bypass zones → handled via VM         |

---

## Modern Userland Heap (iOS, macOS — type-aware / xzone malloc)

최근 Apple OS 버전(특히 iOS 17+)에서 Apple은 더 안전한 사용자 공간 allocator인 **xzone malloc**(XZM)을 도입했다. 이는 커널의 `kalloc_type`에 해당하는 사용자 공간 대응물로, 타입 인식, 메타데이터 분리, 메모리 태깅 보호를 적용한다.

### Goals & Design Principles

- **Type segregation / type awareness**: *타입 또는 용도(포인터 대 데이터)*별로 할당을 그룹화하여 타입 혼동 및 교차 타입 재사용을 방지.
- **Metadata isolation**: 힙 메타데이터(e.g. free lists, size/state 비트)를 객체 페이로드와 분리하여 OOB 쓰기가 메타데이터를 손상시킬 가능성을 줄임.
- **Guard pages / redzones**: 할당 주위에 언매핑된 페이지나 패딩을 삽입하여 오버플로를 포착.
- **Memory tagging (EMTE / MIE)**: 하드웨어 태깅과 함께 작동하여 use-after-free, OOB, 잘못된 접근을 감지.
- **Scalable performance**: 낮은 오버헤드 유지, 과도한 조각화 회피, 초당 많은 할당을 낮은 지연으로 지원.

### Architecture & Components

아래는 xzone allocator의 주요 요소들이다:

#### Segment Groups & Zones

- **Segment groups**는 주소 공간을 용도 범주(e.g. `data`, `pointer_xzones`, `data_large`, `pointer_large`)별로 분할한다.
- 각 segment group는 해당 카테고리의 할당을 호스팅하는 **segments**(VM 범위)를 포함한다.
- 각 segment와 연관된 **metadata slab**(별도의 VM 영역)가 있어 세그먼트의 메타데이터(e.g. free/used 비트, 크기 클래스)를 저장한다. 이 **out-of-line (OOL) metadata**는 메타데이터가 객체 페이로드와 섞이지 않도록 하여 오버플로로 인한 손상을 완화한다.
- Segments는 **chunks**(슬라이스)로 나뉘고, 각 chunk는 다시 **blocks**(할당 단위)로 세분된다. 하나의 chunk는 특정 크기 클래스와 segment group에 묶여 있다(즉 chunk 내 모든 block은 동일한 크기 및 카테고리를 공유).
- 작은/중간 크기 할당에는 고정 크기 chunks를 사용하고, 큰/거대한 할당은 별도로 매핑할 수 있다.

#### Chunks & Blocks

- **chunk**는 한 size class 내에서 할당 전용으로 사용되는 영역(종종 여러 페이지)이다.
- chunk 내부에서 **blocks**는 할당 가능한 슬롯이다. 해제된 blocks는 metadata slab(예: 비트맵 또는 out-of-line으로 저장된 free lists)를 통해 추적된다.
- chunk 사이(또는 내부)에 **guard slices / guard pages**(예: 언매핑된 슬라이스)가 삽입되어 OOB 쓰기를 포착할 수 있다.

#### Type / Type ID

- 모든 할당 지점(또는 malloc, calloc 호출)은 어떤 종류의 객체가 할당되는지 인코딩하는 **type identifier**(`malloc_type_id_t`)와 연관된다. 이 type ID는 allocator에 전달되어 어떤 zone/segment가 할당을 제공할지 선택한다.
- 이로 인해 동일한 크기라도 타입이 다르면 완전히 다른 zone으로 갈 수 있다.
- 초기 iOS 17 버전에서는 모든 API(e.g. CFAllocator)가 완전한 타입 인식을 하지 않았고, Apple은 iOS 18에서 일부 약점을 해결했다.

---

### Allocation & Freeing Workflow

다음은 xzone에서 할당 및 해제가 동작하는 높은 수준의 흐름이다:

1. **malloc / calloc / realloc / typed alloc**이 크기와 type ID와 함께 호출된다.
2. allocator는 **type ID**를 사용해 올바른 segment group / zone을 선택한다.
3. 해당 zone/segment 내에서 요청한 크기의 free blocks가 있는 chunk를 찾는다.
- **local caches / per-thread pools** 또는 metadata의 **free block lists**를 참조할 수 있다.
- 사용 가능한 free block이 없으면 zone에 새 chunk를 할당할 수 있다.
4. metadata slab가 업데이트된다(free 비트 클리어, 예약 관리).
5. 메모리 태깅(EMTE)이 적용되는 경우, 반환된 block에 **tag**가 할당되고 메타데이터가 “live” 상태를 반영하도록 업데이트된다.
6. `free()`가 호출되면:
- block은 메타데이터에서 freed로 표시된다(OOL slab를 통해).
- block은 free list에 들어가거나 재사용을 위해 풀링될 수 있다.
- 선택적으로, 데이터 누출이나 use-after-free 악용을 줄이기 위해 block 내용을 지우거나 poisoning할 수 있다.
- 블록과 연관된 하드웨어 태그는 무효화되거나 재태깅될 수 있다.
- 전체 chunk가 비어있게 되면(모든 block이 해제됨) allocator는 메모리 압박 시 해당 chunk를 **reclaim**(언맵하거나 OS에 반환)할 수 있다.

---

### Security Features & Hardening

현대 사용자 공간 xzone에 내장된 방어책들은 다음과 같다:

| Feature | Purpose | Notes |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | Prevent overflow from corrupting metadata | Metadata lives in separate VM region (metadata slab)|
| **Guard pages / unmapped slices** | Catch out-of-bounds writes | Helps detect buffer overflows rather than silently corrupting adjacent blocks|
| **Type-based segregation** | Prevent cross-type reuse & type confusion | Even same-size allocations from different types go to different zones|
| **Memory Tagging (EMTE / MIE)** | Detect invalid access, stale references, OOB, UAF | xzone works in concert with hardware EMTE in synchronous mode (“Memory Integrity Enforcement”)|
| **Delayed reuse / poisoning / zap** | Reduce chance of use-after-free exploitation | Freed blocks may be poisoned, zeroed, or quarantined before reuse |
| **Chunk reclamation / dynamic unmapping** | Reduce memory waste and fragmentation | Entire chunks may be unmapped when unused |
| **Randomization / placement variation** | Prevent deterministic adjacency | Blocks in a chunk and chunk selection may have randomized aspects |
| **Segregation of “data-only” allocations** | Separate allocations that don’t store pointers | Reduces attacker control over metadata or control fields|

---

### Interaction with Memory Integrity Enforcement (MIE / EMTE)

- Apple의 MIE(Memory Integrity Enforcement)는 하드웨어 + OS 프레임워크로, **Enhanced Memory Tagging Extension (EMTE)**를 주요 공격 표면에서 항상 켜진 동기 모드로 동작하게 만든다.
- xzone allocator는 사용자 영역에서 MIE의 근간이다: xzone으로 수행된 할당은 태그를 받고 접근은 하드웨어에 의해 검사된다.
- MIE에서는 allocator, 태그 할당, 메타데이터 관리, 태그 기밀성 강제가 통합되어 메모리 오류(e.g. stale reads, OOB, UAF)가 즉시 포착되어 나중에 악용되지 않도록 한다.

---

If you like, I can also generate a cheat-sheet or diagram of xzone internals for your book. Do you want me to do that next?
::contentReference[oaicite:20]{index=20}


---

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
