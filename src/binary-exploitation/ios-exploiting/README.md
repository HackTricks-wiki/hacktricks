# iOS 利用

{{#include ../../banners/hacktricks-training.md}}

## iOS 漏洞利用缓解措施

### 1. **Code Signing** / Runtime Signature Verification
**Introduced early (iPhone OS → iOS)**
这是基本的保护之一：**所有可执行代码**（apps、dynamic libraries、JIT-ed code、extensions、frameworks、caches）必须由以 Apple 信任为根的证书链进行加密签名。在运行时，在将二进制加载到内存之前（或在跨某些边界进行跳转之前），系统会检查其签名。如果代码被修改（位翻转、打补丁）或未签名，加载会失败。

- **阻止**：利用链中“经典的 payload drop + execute”阶段；任意代码注入；修改已有二进制以插入恶意逻辑。
- **机制细节**：
* Mach-O loader（以及 dynamic linker）检查代码页、segments、entitlements、team IDs，并确保证书签名覆盖文件内容。
* 对于像 JIT caches 或动态生成的代码这类内存区域，Apple 强制要求页面被签名或通过特殊 API 验证（例如带有 code-sign 检查的 `mprotect`）。
* 签名包含 entitlements 和标识符；OS 强制要求某些 API 或特权能力需要特定的 entitlements，而这些不能被伪造。

<details>
<summary>示例</summary>
假设一个 exploit 在进程中获得代码执行并尝试把 shellcode 写到 heap 然后跳过去。在 iOS 上，该页面需要被标记为 executable **并且** 满足 code-signature 约束。由于 shellcode 没有用 Apple 的证书签名，跳转会失败或系统会拒绝将该内存区域设为 executable。
</details>


### 2. **CoreTrust**
**Introduced around iOS 14+ era (or gradually in newer devices / later iOS)**
CoreTrust 是一个子系统，用于对二进制在运行时进行 **签名验证**，它针对的是 **Apple 的根证书**，而不是依赖本地的 userland trust 存储。

- **阻止**：安装后对二进制的篡改、尝试替换或打补丁 system libraries 或 user apps 的越狱技术；用恶意替代品欺骗系统。
- **机制细节**：
* CoreTrust 不信任本地的 trust 数据库或证书缓存，而是直接引用或验证指向 Apple 根证书的安全链。
* 它确保检测并拒绝对现有二进制的修改（例如在 filesystem 中的修改）。
* 在加载时，它将 entitlements、team IDs、code signing 标志和其它元数据与二进制绑定。

<details>
<summary>示例</summary>
越狱可能试图替换 `SpringBoard` 或 `libsystem` 为打过补丁的版本以获得持久性。但当 OS 的 loader 或 CoreTrust 检查时，会发现签名不匹配（或 entitlements 被修改），并拒绝执行。
</details>


### 3. **Data Execution Prevention (DEP / NX / W^X)**
**Introduced in many OSes earlier; iOS had NX-bit / w^x for a long time**
DEP 强制要求被标记为可写（用于数据）的页面为 **不可执行**，而被标记为可执行的页面为 **不可写**。不能简单地把 shellcode 写入 heap 或 stack 并执行。

- **阻止**：直接的 shellcode 执行；经典的 buffer-overflow → 跳转到注入的 shellcode。
- **机制细节**：
* MMU / memory protection flags（通过页表）强制执行这种分离。
* 任何试图将可写页面标记为可执行的操作都会触发系统检查（要么被禁止，要么需要 code-sign 批准）。
* 在很多情况下，使页面可执行需要通过强制执行附加约束或检查的 OS API。

<details>
<summary>示例</summary>
一次 overflow 把 shellcode 写到 heap。攻击者尝试 `mprotect(heap_addr, size, PROT_EXEC)` 使其可执行。但系统会拒绝或验证新页面必须通过 code-sign 约束（shellcode 无法通过）。
</details>

### 4. **Address Space Layout Randomization (ASLR)**
**Introduced in iOS ~4–5 era (roughly iOS 4–5 timeframe)**
ASLR 在每次进程启动时随机化关键内存区域的基地址：libraries、heap、stack 等。gadgets 的地址在运行间会变化。

- **阻止**：为 ROP/JOP 硬编码 gadget 地址；静态利用链；盲目跳转到已知偏移。
- **机制细节**：
* 每个加载的 library / dynamic module 都会被重基址到一个随机偏移。
* stack 和 heap 基指针被随机化（在某些熵限制内）。
* 有时其他区域（例如 mmap 分配）也会被随机化。
* 与 information-leak 缓解措施结合使用，强制攻击者先泄露一个地址或指针以在运行时发现基地址。

<details>
<summary>示例</summary>
一个 ROP 链期望 gadget 在 `0x….lib + offset`。但由于 `lib` 在每次运行时被重新定位，硬编码的链会失败。一个 exploit 必须先 leak 模块的基地址，然后再计算 gadget 地址。
</details>


### 5. **Kernel Address Space Layout Randomization (KASLR)**
**Introduced in iOS ~ (iOS 5 / iOS 6 timeframe)**
类似于用户 ASLR，KASLR 在启动时随机化 **kernel text** 和其它内核结构的基址。

- **阻止**：依赖固定内核代码或数据位置的内核级利用；静态内核利用。
- **机制细节**：
* 每次引导时，kernel 的基地址在某个范围内被随机化。
* 内核数据结构（如 `task_structs`、`vm_map` 等）也可能被重新定位或偏移。
* 攻击者必须先 leak 内核指针或利用信息披露漏洞来计算偏移，才能劫持内核结构或代码。

<details>
<summary>示例</summary>
某本地漏洞试图破坏一个 kernel 函数指针（例如在 `vtable`）位于 `KERN_BASE + offset`。但由于 `KERN_BASE` 未知，攻击者必须先 leak 它（例如通过 read primitive）然后再计算正确的地址进行破坏。
</details>


### 6. **Kernel Patch Protection (KPP / AMCC)**
**Introduced in newer iOS / A-series hardware (post around iOS 15–16 era or newer chips)**
KPP（又名 AMCC）持续监控 kernel text 页的完整性（通过 hash 或 checksum）。如果检测到篡改（补丁、inline hooks、代码修改）在非允许窗口内发生，会触发 kernel panic 或重启。

- **阻止**：内核的持久补丁（修改内核指令）、inline hooks、静态函数覆写。
- **机制细节**：
* 一个硬件或固件模块监控 kernel text 区域。
* 它周期性或按需对页面重新哈希并与预期值比较。
* 如果在非正常更新窗口检测到不匹配，它会 panic 设备（以避免持久恶意补丁）。
* 攻击者必须避开检测窗口或使用合法的补丁路径。

<details>
<summary>示例</summary>
一个 exploit 试图打补丁 kernel 函数前导（例如 `memcmp`）以拦截调用。但 KPP 注意到代码页的 hash 与预期不符并触发 kernel panic，从而在补丁稳定前就崩溃了设备。
</details>


### 7. **Kernel Text Read‐Only Region (KTRR)**
**Introduced in modern SoCs (post ~A12 / newer hardware)**
KTRR 是一个硬件强制的机制：一旦 kernel text 在引导早期被锁定，它从 EL1（kernel）层级变为只读，防止后续对代码页的写入。

- **阻止**：引导后对内核代码的任何修改（例如补丁、就地代码注入）在 EL1 权限层面。
- **机制细节**：
* 在引导阶段（secure/bootloader 阶段），memory controller（或某个 secure hardware 单元）标记包含 kernel text 的物理页面为只读。
* 即使 exploit 获得了完整的 kernel 权限，也无法写入这些页面来打补丁指令。
* 要修改它们，攻击者必须先破坏引导链，或颠覆 KTRR 本身。

<details>
<summary>示例</summary>
一个权限提升 exploit 跳入 EL1 并尝试在 kernel 函数中写入 trampoline（例如在 `syscall` handler）。但因为这些页面已被 KTRR 锁定为只读，写入会失败（或触发 fault），因此补丁无法应用。
</details>


### 8. **Pointer Authentication Codes (PAC)**
**Introduced with ARMv8.3 (hardware), Apple beginning with A12 / iOS ~12+**
- PAC 是 ARMv8.3-A 中引入的硬件特性，用于检测指针值（返回地址、函数指针、某些数据指针）是否被篡改，通过将一个小的加密签名（“MAC”）嵌入到指针未使用的高位中。
- 该签名（“PAC”）是基于指针值加上一个 **modifier**（上下文值，例如 stack pointer 或某些区分数据）计算的。这样相同的指针值在不同上下文中会有不同的 PAC。
- 在使用时，在解引用或通过该指针分支之前，authenticate 指令会检查 PAC。如果有效，PAC 会被剥离并得到纯指针；如果无效，指针会被“poisoned”（或触发 fault）。
- 用于产生/验证 PAC 的密钥存放在特权寄存器（EL1、kernel）中，用户态无法直接读取。
- 因为许多系统并未使用全部 64 位地址（例如 48-bit 地址空间），高位是“空闲”的，可以用来存放 PAC 而不改变有效地址。

#### Architectural Basis & Key Types

- ARMv8.3 引入了 **五个 128-bit 密钥**（每个通过两个 64-bit 系统寄存器实现）用于 pointer authentication。
- **APIAKey** — 用于 instruction pointers（域 “I”，key A）
- **APIBKey** — 第二个 instruction pointer key（域 “I”，key B）
- **APDAKey** — 用于 data pointers（域 “D”，key A）
- **APDBKey** — 用于 data pointers（域 “D”，key B）
- **APGAKey** — “generic” key，用于为非指针数据或其它通用用途签名

- 这些密钥存储在特权系统寄存器中（仅在 EL1/EL2 等可访问），用户态不可访问。
- PAC 通过一个加密函数计算（ARM 建议使用 QARMA 作为算法），使用的输入包括：
1. 指针值（规范化部分）
2. 一个 **modifier**（上下文值，如 salt）
3. 秘密密钥
4. 一些内部 tweak 逻辑
如果生成的 PAC 与存储在指针高位中的值匹配，认证成功。


#### Instruction Families

命名约定为：**PAC** / **AUT** / **XPAC**，然后是域字母。
- `PACxx` 指令用于 **签名** 指针并插入 PAC
- `AUTxx` 指令用于 **认证 + 剥离**（验证并移除 PAC）
- `XPACxx` 指令用于 **剥离**，但不验证

Domains / suffixes:

| Mnemonic     | Meaning / Domain                      | Key / Domain     | Example Usage in Assembly |
|--------------|-----------------------------------------|--------------------|-----------------------------|
| **PACIA**    | Sign instruction pointer with APIAKey   | “I, A”             | `PACIA X0, X1` — sign pointer in X0 using APIAKey with modifier X1|
| **PACIB**    | Sign instruction pointer with APIBKey   | “I, B”             | `PACIB X2, X3`              |
| **PACDA**    | Sign data pointer with APDAKey           | “D, A”             | `PACDA X4, X5`              |
| **PACDB**    | Sign data pointer with APDBKey           | “D, B”             | `PACDB X6, X7`              |
| **PACG / PACGA** | Generic (non-pointer) signing with APGAKey | “G”         | `PACGA X8, X9, X10` (sign X9 with modifier X10 into X8) |
| **AUTIA**    | Authenticate APIA-signed instruction pointer & strip PAC | “I, A” | `AUTIA X0, X1` — check PAC on X0 using modifier X1, then strip |
| **AUTIB**    | Authenticate APIB domain                 | “I, B”             | `AUTIB X2, X3`               |
| **AUTDA**    | Authenticate APDA-signed data pointer    | “D, A”             | `AUTDA X4, X5`               |
| **AUTDB**    | Authenticate APDB-signed data pointer    | “D, B”             | `AUTDB X6, X7`               |
| **AUTGA**    | Authenticate generic / blob (APGA)        | “G”               | `AUTGA X8, X9, X10` (validate generic) |
| **XPACI**     | Strip PAC (instruction pointer, no validation) | “I”         | `XPACI X0` — remove PAC from X0 (instruction domain) |
| **XPACD**     | Strip PAC (data pointer, no validation)    | “D”             | `XPACD X4` — remove PAC from data pointer in X4 |


有些专门化 / 别名形式：

- `PACIASP` 是 `PACIA X30, SP` 的简写（用 SP 作为 modifier 签名 link register）
- `AUTIASP` 是 `AUTIA X30, SP`（用 SP 验证 link register）
- 还有像 `RETAA`, `RETAB`（authenticate-and-return）或 `BLRAA`（authenticate & branch）这类的组合形式在 ARM 扩展 / compiler 支持中存在。
- 也有零 modifier 的变体：`PACIZA` / `PACIZB`，modifier 隐含为零，等等。

#### Modifiers

modifier 的主要目标是将 PAC **绑定到特定上下文**，使得同一地址在不同上下文签名后产生不同的 PAC。这阻止了简单的指针跨帧或跨对象重用。相当于给哈希加了一个 salt。

因此：
- **modifier** 是一个上下文值（另一个寄存器），被混入 PAC 计算。典型选择：stack pointer（SP）、frame pointer 或某个对象 ID。
- 使用 SP 作为 modifier 对返回地址签名很常见：PAC 与特定栈帧绑定。如果你尝试在不同帧重用 LR，modifier 会改变，PAC 验证失败。
- 同一指针值在不同 modifier 下签名会得到不同的 PAC。
- modifier 不需要保密，但理想情况下它不应被攻击者控制。
- 对于那些没有有意义 modifier 的签名/验证场景，有些形式使用零或隐含常量。

#### Apple / iOS / XNU Customizations & Observations

- Apple 的 PAC 实现包含 **每次引导的 diversifiers**，因此密钥或 tweak 每次引导都会变化，防止跨引导的重用。
- 它们还包含 **跨域缓解**，使得在 user mode 签名的 PAC 不容易在 kernel mode 中重用，等等。
- 在 Apple M1 / Apple Silicon 上，逆向显示有 **九种 modifier 类型** 以及 Apple 特定的控制密钥的系统寄存器。
- Apple 在很多内核子系统中使用 PAC：返回地址签名、内核数据中的指针完整性、签名的线程上下文等。
- Google Project Zero 展示了在拥有强大内核读/写原语时，如何在 A12 时代 forge 内核 PAC（针对 A keys），但 Apple 修补了许多这些路径。
- 在 Apple 的系统中，某些密钥是 **全局内核** 级别的，而用户进程可能获得每进程的密钥随机性。

#### PAC Bypasses

1. **Kernel-mode PAC: theoretical vs real bypasses**

-   由于 kernel PAC 密钥和逻辑受到严格控制（特权寄存器、多样化器、域隔离），伪造任意签名的 kernel 指针非常困难。
-   Azad 的 2020 年 “iOS Kernel PAC, One Year Later” 报告指出在 iOS 12-13 中，他发现了一些部分绕过（signing gadgets、重用已签名状态、未受保护的间接分支），但没有发现通用的完全绕过。 [bazad.github.io](https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf)
-   Apple 的 “Dark Magic” 定制进一步缩小了可被利用的面（域切换、每-key 启用位）。 [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   已知存在一处 **kernel PAC 绕过 CVE-2023-32424**，影响 Apple silicon（M1/M2），由 Zecao Cai 等人报告。 [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   但这些绕过通常依赖非常特定的 gadgets 或实现缺陷；并非通用绕过方法。

因此 kernel PAC 被认为是 **高度可靠** 的，尽管不是完美的。

2. **User-mode / runtime PAC bypass techniques**

这些更为常见，利用 PAC 在 dynamic linking / runtime frameworks 中应用或使用上的不完美之处。下面列出几类并附示例。

2.1 **Shared Cache / A key issues**

-   **dyld shared cache** 是一个包含系统 frameworks 和 libraries 的大型预链接 blob。因为它被大量共享，shared cache 内的函数指针是“预签名”的并被许多进程使用。攻击者把这些已签名的指针作为 “PAC oracles” 进行利用。
-   一些绕过技术试图提取或重用 shared cache 中 A-key 签名的指针并在 gadgets 中重用它们。
-   “No Clicks Required” 的演讲描述了如何在 shared cache 上构建一个 oracle 来推断相对地址，并结合已签名指针来绕过 PAC。 [saelo.github.io](https://saelo.github.io/presentations/offensivecon_20_no_clicks.pdf)
-   此外，从 shared libraries 导入的函数指针在 userspace 中被发现对 PAC 保护不足，允许攻击者获取函数指针而不更改其签名。（Project Zero 的 bug 条目） [bugs.chromium.org](https://bugs.chromium.org/p/project-zero/issues/detail?id=2044&utm_source=chatgpt.com)

2.2 **dlsym(3) / dynamic symbol resolution**

-   一个已知的绕过方式是调用 `dlsym()` 来获取一个 *已签名的* 函数指针（用 A-key 签名，diversifier 为零），然后使用它。因为 `dlsym` 返回的是合法签名的指针，使用它绕过了伪造 PAC 的需求。
-   Epsilon 的博客详细说明了一些绕过如何利用这一点：调用 `dlsym("someSym")` 会产生一个已签名的指针并可以用于间接调用。 [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)
-   Synacktiv 的 “iOS 18.4 --- dlsym considered harmful” 描述了一个 bug：iOS 18.4 上通过 `dlsym` 解析的一些符号返回的指针被错误签名（或具有有问题的 diversifier），使得意外的 PAC 绕过成为可能。 [Synacktiv](https://www.synacktiv.com/en/publications/ios-184-dlsym-considered-harmful)
-   dyld 中处理 dlsym 的逻辑包含：当 `result->isCode` 时，它用 `__builtin_ptrauth_sign_unauthenticated(..., key_asia, 0)` 对返回指针进行签名，即上下文为零。 [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

因此，`dlsym` 常常是 user-mode PAC 绕过的向量。

2.3 **Other DYLD / runtime relocations**

-   DYLD loader 和动态重定位逻辑非常复杂，有时会临时把页面映射为读/写以执行重定位，然后再切回只读。攻击者会利用这些窗口。Synacktiv 的报告描述了通过动态重定位进行基于时序的 PAC 绕过（“Operation Triangulation”）。 [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)
-   DYLD 页面现在受 SPRR / VM_FLAGS_TPRO 等保护标志保护。但早期版本的保护较弱。 [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)
-   在 WebKit exploit 链中，DYLD loader 经常成为 PAC 绕过的目标。幻灯片提到许多 PAC 绕过针对 DYLD loader（通过重定位、interposer hooks）。 [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

2.4 **NSPredicate / NSExpression / ObjC / SLOP**

-   在 userland exploit 链中，Objective-C runtime 的方法如 `NSPredicate`、`NSExpression` 或 `NSInvocation` 被用来走私控制调用而不明显地伪造指针。
-   在早期 iOS（在 PAC 之前），有一个 exploit 使用 **fake NSInvocation** 对象来对受控内存上的任意 selector 进行调用。引入 PAC 后需要对该技术做修改。但 SLOP（SeLector Oriented Programming）技术也在 PAC 下得到扩展。 [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)
-   原始的 SLOP 技术通过创建伪造的 invocations 链接 ObjC 调用；绕过依赖于 ISA 或 selector 指针有时没有完全被 PAC 保护。 [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)
-   在部分应用了 pointer authentication 的环境中，methods / selectors / target pointers 并不总是受到 PAC 保护，从而留下绕过空间。

#### Example Flow

<details>
<summary>Example Signing & Authenticating</summary>
```
; Example: function prologue / return address protection
my_func:
stp x29, x30, [sp, #-0x20]!        ; push frame pointer + LR
mov x29, sp
PACIASP                            ; sign LR (x30) using SP as modifier
; … body …
mov sp, x29
ldp x29, x30, [sp], #0x20         ; restore
AUTIASP                            ; authenticate & strip PAC
ret

; Example: indirect function pointer stored in a struct
; suppose X1 contains a function pointer
PACDA X1, X2     ; sign data pointer X1 with context X2
STR X1, [X0]      ; store signed pointer

; later retrieval:
LDR X1, [X0]
AUTDA X1, X2       ; authenticate & strip
BLR X1             ; branch to valid target

; Example: stripping for comparison (unsafe)
LDR X1, [X0]
XPACI X1           ; strip PAC (instruction domain)
CMP X1, #some_label_address
BEQ matched_label
```
</details>

<details>
<summary>Example</summary>
缓冲区溢出会覆盖栈上的返回地址。攻击者写入目标 gadget 地址但无法计算正确的 PAC。当函数返回时，CPU 的 `AUTIA` 指令会因 PAC 不匹配而发生错误。链条失败。
Project Zero 对 A12（iPhone XS）的分析展示了 Apple 如何使用 PAC 以及当攻击者拥有内存读/写原语时伪造 PAC 的方法。
</details>


### 9. **Branch Target Identification (BTI)**
**Introduced with ARMv8.5 (later hardware)**
BTI 是一项硬件特性，用于检查**间接分支目标**：在执行 `blr` 或间接调用/跳转时，目标必须以一个 **BTI landing pad**（`BTI j` 或 `BTI c`）开头。跳转到没有 landing pad 的 gadget 地址会触发异常。

LLVM 的实现说明了三种 BTI 指令变体以及它们如何映射到分支类型。

| BTI 变体 | 允许的目标（分支类型） | 典型位置 / 用例 |
|-------------|----------------------------------------|-------------------------------|
| **BTI C** | 用于 *call*-风格的间接分支目标（例如 `BLR`，或使用 X16/X17 的 `BR`） | 放在可能被间接调用的函数入口处 |
| **BTI J** | 用于 *jump*-风格的分支目标（例如用于尾调用的 `BR`） | 放在通过跳表或尾调用可到达的基本块开始处 |
| **BTI JC** | 同时作为 C 与 J | 可被 call 或 jump 分支中的任意一种指向 |

- 在使用分支目标强制的代码中，编译器会在每个有效的间接分支目标（函数开头或可被跳转到的基本块）插入 BTI 指令（C、J 或 JC），以便间接分支只能成功跳转到这些位置。
- **直接分支 / 调用**（即固定地址的 `B`、`BL`）**不受** BTI 的限制。其前提是假定代码页是受信任且攻击者无法更改（因此直接分支是安全的）。
- 此外，**RET / return** 指令通常不受 BTI 限制，因为返回地址通过 PAC 或返回签名机制得到保护。

#### 机制与强制执行

- 当 CPU 在被标记为“guarded / BTI-enabled”的页面中解码一个**间接分支（BLR / BR）**时，会检查目标地址的第一条指令是否为允许的有效 BTI（C、J 或 JC）。如果不是，则会发生 **Branch Target Exception**。
- BTI 指令的编码设计为重用之前在早期 ARM 版本中保留给 NOP 的操作码。因此在不支持 BTI 的硬件上，这些指令仍作为 NOP，保证了向后兼容。
- 插入 BTI 的编译器阶段仅在必要位置加入：可能被间接调用的函数，或可能被跳转指向的基本块。
- 一些补丁和 LLVM 代码显示，BTI 并不会插入到*所有*基本块——仅插入到那些可能成为分支目标的基本块（例如来自 switch / jump table 的目标）。

#### BTI + PAC 协同

PAC 保护指针值（源）——确保间接调用/返回链未被篡改。

BTI 确保即使指针有效，也只能指向带有合适标记的入口点。

结合起来，攻击者需要同时满足有效指针具有正确的 PAC，并且目标处必须有 BTI。这增加了构造利用 gadget 的难度。

#### Example


<details>
<summary>Example</summary>
一个 exploit 试图 pivot 到不以 `BTI c` 开头的 `0xABCDEF` gadget。当 CPU 执行 `blr x0` 时，会检查目标并因指令前缀不包含有效 landing pad 而发生故障。因此许多 gadgets 在没有 BTI 前缀的情况下变得不可用。
</details>


### 10. **Privileged Access Never (PAN) & Privileged Execute Never (PXN)**
**Introduced in more recent ARMv8 extensions / iOS support (for hardened kernel)**

#### PAN (Privileged Access Never)

- **PAN** 是在 **ARMv8.1-A** 中引入的一个特性，防止**特权代码**（EL1 或 EL2）在 PAN 未被显式禁用的情况下**读取或写入**被标记为**用户可访问（EL0）**的内存。
- 其思想是：即便内核被欺骗或被破坏，也不能在不先*清除* PAN 的前提下任意解引用用户空间指针，从而减少 `ret2usr` 风格利用或滥用用户可控缓冲区的风险。
- 当 PAN 启用（PSTATE.PAN = 1）时，任何特权的 load/store 指令访问被标记为“在 EL0 可访问”的虚拟地址会触发**权限错误**。
- 内核在必须合法访问用户空间内存（例如复制数据到/从用户缓冲区）时，必须**临时禁用 PAN**（或使用“非特权的 load/store”指令）以允许该访问。
- 在 ARM64 的 Linux 中，大约在 2015 年引入了 PAN 支持：内核补丁添加了对该特性的检测，并用在访问用户内存时会清除 PAN 的变体替换了 `get_user` / `put_user` 等。

**关键细节 / 限制 / 漏洞**
- 如 Siguza 等人指出的，ARM 规范中的一个模糊/错误行为意味着**仅可执行的用户映射**（`--x`）可能**不会触发 PAN**。换言之，如果某个用户页仅标记为可执行而无读取权限，内核的读取尝试可能绕过 PAN，因为架构在判断“在 EL0 可访问”时要求可读权限，而不仅仅是可执行。这在某些实现下会导致 PAN 绕过。
- 因此，如果 iOS / XNU 允许可执行但只读受限的用户页面（例如某些 JIT 或代码缓存设置），内核在 PAN 启用时仍可能无意中读取它们。这在某些 ARMv8+ 系统中是已知的微妙可利用点。

#### PXN (Privileged eXecute Never)

- **PXN** 是页表标志（在页表项的叶或块条目中），表示该页面在特权模式下（即 EL1 执行时）**不可执行**。
- PXN 阻止内核（或任何特权代码）跳转到或从用户空间页面执行指令，即使控制流被劫持，也无法在用户页上执行代码。实质上，它阻止了内核级别的控制流重定向到用户内存。
- 配合 PAN，一般可确保：
1. 内核默认不能读取或写入用户空间数据（PAN）
2. 内核不能执行用户空间代码（PXN）
- 在 ARMv8 页表格式中，叶条目有一个 `PXN` 位（以及对于非特权执行的 `UXN`）位于属性位中。

因此，即便内核有一个被破坏的函数指针指向用户内存，尝试分支到那里也会被 PXN 位引起故障阻止。

#### 内存权限模型 & PAN / PXN 如何映射到页表位

要理解 PAN / PXN 的工作机制，需要看看 ARM 的转换与权限模型（简化）：

- 每个页或块条目具有属性字段，包括用于访问权限的 **AP[2:1]**（读/写，特权 vs 非特权）以及用于执行禁止的 **UXN / PXN** 位。
- 当 PSTATE.PAN 为 1（启用）时，硬件执行修改后的语义：对标记为“EL0 可访问”的页面的特权访问会被禁止（触发错误）。
- 由于前述的规范问题，仅被标记为可执行（无读权限）的页面在某些实现中可能不被视为“EL0 可访问”，从而导致 PAN 绕过。
- 当某页的 PXN 位被设置时，即便指令获取在更高特权级别发生，执行也被禁止。

#### 内核在加固 OS（例如 iOS / XNU）中对 PAN / PXN 的使用

在加固的内核设计中（如 Apple 可能采用的做法）：

- 内核默认启用 PAN（因此特权代码受到限制）。
- 在必须合法读取或写入用户缓冲区的路径中（例如 syscall 缓冲区复制、I/O、读/写用户指针），内核会临时**禁用 PAN**或使用覆盖 PAN 的特殊指令以完成访问。
- 完成用户数据访问后，必须重新启用 PAN。
- PXN 由页表强制：用户页设置 PXN = 1（因此内核不能在其上执行），内核页不设置 PXN（因此内核代码可执行）。
- 内核必须确保没有代码路径导致执行流进入用户内存区域（那会绕过 PXN）——因此依赖“跳到用户 shellcode” 的利用链被阻断。

鉴于通过仅可执行页面的 PAN 绕过，实际系统中 Apple 可能会禁用或不允许仅可执行的用户页面，或在规范弱点上做补丁。

#### 攻击面、绕过和缓解措施

- **通过仅可执行页面的 PAN 绕过**：如前所述，规范允许一个缺口：仅可执行（无读权限）的用户页在某些实现下可能不计为“EL0 可访问”，因此 PAN 不会阻止内核从这些页面读取。这为攻击者提供了一种通过“仅可执行”段传递数据的非常规路径。
- **时间窗口利用**：如果内核在禁用 PAN 的窗口比必要时间更长，竞态或恶意路径可能利用该窗口执行未预期的用户内存访问。
- **遗忘重新启用**：如果某些代码路径忘记重新启用 PAN，后续内核操作可能会错误地访问用户内存。
- **PXN 配置错误**：如果页表未在用户页上设置 PXN 或错误地映射用户代码页，内核可能被诱导去执行用户空间代码。
- **投机 / 侧信道**：类似于投机执行绕过，可能存在导致 PAN / PXN 检查短暂失效的微架构副作用（尽管此类攻击高度依赖于具体 CPU 设计）。
- **复杂交互**：在更复杂的特性（例如 JIT、共享内存、即时编译的代码区域）中，内核需要精细控制以允许某些内存访问或在用户映射区域内执行代码；在 PAN/PXN 限制下安全地设计这些机制并非易事。

#### Example

<details>
<summary>Code Example</summary>
下面是说明在访问用户内存时围绕 PAN 启用/禁用的伪汇编序列，以及可能如何导致故障的示例。
</details>
```  
// Suppose kernel entry point, PAN is enabled (privileged code cannot access user memory by default)

; Kernel receives a syscall with user pointer in X0
; wants to read an integer from user space
mov   X1, X0        ; X1 = user pointer

; disable PAN to allow privileged access to user memory
MSR   PSTATE.PAN, #0   ; clear PAN bit, disabling the restriction

ldr   W2, [X1]       ; now allowed load from user address

; re-enable PAN before doing other kernel logic
MSR   PSTATE.PAN, #1   ; set PAN

; ... further kernel work ...

; Later, suppose an exploit corrupts a pointer to a user-space code page and jumps there
BR    X3             ; branch to X3 (which points into user memory)

; Because the target page is marked PXN = 1 for privileged execution,
; the CPU throws an exception (fault) and rejects execution
```
如果内核**没有**在该用户页面上设置 PXN，那么分支可能会成功——这将是不安全的。

如果内核在访问用户内存后忘记重新启用 PAN，就会打开一个窗口，期间进一步的内核逻辑可能会意外地读/写任意用户内存。

如果用户指针指向一个 execute-only 页面（只有 execute 权限的用户页面，没有读/写），在 PAN 规范的实现缺陷下，`ldr W2, [X1]` 即使在启用 PAN 时也可能**不会**发生 fault，依据实现可能导致绕过利用。

</details>

<details>
<summary>Example</summary>
内核漏洞试图采用用户提供的函数指针并在内核上下文中调用它（即 `call user_buffer`）。在 PAN/PXN 下，该操作被禁止或会发生 fault。
</details>

---

### 11. **Top Byte Ignore (TBI) / Pointer Tagging**
**Introduced in ARMv8.5 / newer (or optional extension)**
TBI 表示 64 位指针的最高字节（most-significant byte）在地址转换时被忽略。这允许 OS 或硬件在指针的最高字节中嵌入**tag bits**，而不影响实际地址。

- TBI 代表 **Top Byte Ignore**（有时称为 *Address Tagging*）。这是一个硬件特性（在许多 ARMv8+ 实现中可用），在执行**address translation / load/store / instruction fetch** 时**忽略最高 8 位**（位 63:56）。
- 实际上，CPU 在进行地址转换时把指针 `0xTTxxxx_xxxx_xxxx`（其中 `TT` = top byte）当作 `0x00xxxx_xxxx_xxxx` 来处理，忽略（掩去）最高字节。最高字节可被软件用来存储**元数据 / tag bits**。
- 这为软件提供了“免费”的带内空间，可以在每个指针中嵌入一个字节的 tag，而不改变其所指向的内存位置。
- 架构保证在执行 load、store 和 instruction fetch 时，会在进行实际内存访问前将指针的最高字节掩去（即去除 tag）。

因此 TBI 将**逻辑指针**（pointer + tag）与用于内存操作的**物理地址**解耦。

#### Why TBI: Use cases and motivation

- **Pointer tagging / metadata**：你可以在最高字节中存储额外的元数据（例如对象类型、版本、边界、完整性 tag）。当稍后使用该指针时，硬件会忽略 tag，所以在进行内存访问时不需要手动去除。
- **Memory tagging / MTE (Memory Tagging Extension)**：TBI 是 MTE 构建的基础硬件机制。在 ARMv8.5 中，**Memory Tagging Extension** 使用指针的位 59:56 作为**逻辑 tag**，并将其与存储在内存中的**allocation tag** 进行比对。
- **增强的安全性与完整性**：通过将 TBI 与 pointer authentication (PAC) 或运行时校验结合，可以确保不仅指针值而且 tag 也必须正确。攻击者在不带正确 tag 的情况下覆盖指针会导致 tag 不匹配。
- **兼容性**：因为 TBI 是可选的且硬件会忽略 tag 位，现有未带 tag 的代码仍然可以正常运行。对于旧代码，这些 tag 位实际上成为“无所谓”的位。

#### Example
<details>
<summary>Example</summary>
一个函数指针在其最高字节中包含了一个 tag（例如 `0xAA`）。利用者覆盖了指针的低位但忽略了 tag，因此当内核验证或消毒该指针时，指针不会通过检查或被拒绝。
</details>

---

### 12. **Page Protection Layer (PPL)**
**Introduced in late iOS / modern hardware (iOS ~17 / Apple silicon / high-end models)**（有些报告显示 PPL 在 macOS / Apple silicon 就已出现，但 Apple 正在将类似保护引入 iOS）

- PPL 设计为一种**内核内的保护边界**：即使内核 (EL1) 被攻破并具有读/写权限，**它也不应能自由地修改**某些**敏感页面**（尤其是页表、code-signing 元数据、内核代码页、entitlements、trust caches 等）。
- 它实际上创建了一个“内核内的内核”——一个较小的受信任组件（PPL），具有**更高的权限**，只有它才能修改受保护的页面。其他内核代码必须调用 PPL 例程以进行更改。
- 这减少了内核利用的攻击面：即便在内核模式下获得了任意 R/W/execute，利用代码仍必须以某种方式进入 PPL 域（或绕过 PPL）才能修改关键结构。
- 在更新的 Apple silicon（A15+ / M2+）上，Apple 正在过渡到 **SPTM (Secure Page Table Monitor)**，在很多情况下用它来替代 PPL 以保护页表。

下面是基于公开分析对 PPL 如何运作的推测：

#### Use of APRR / permission routing (APRR = Access Permission ReRouting)

- Apple 硬件使用一种称为 **APRR (Access Permission ReRouting)** 的机制，它允许页表项（PTEs）包含小的索引，而不是完整的权限位。这些索引通过 APRR 寄存器映射到实际权限。这允许按域动态重映射权限。
- PPL 利用 APRR 在内核上下文内实现特权隔离：只有 PPL 域被允许更新索引与实际有效权限之间的映射。也就是说，当非 PPL 内核代码写入 PTE 或尝试切换权限位时，APRR 逻辑会拒绝（或强制只读）该操作。
- PPL 代码自身运行在受限区域（例如 `__PPLTEXT`），在入口闸门临时允许之前，该区域通常不可执行或不可写。内核必须调用 PPL 的入口点（“PPL 例程”）来执行敏感操作。

#### Gate / Entry & Exit

- 当内核需要修改受保护页面（例如更改内核代码页的权限，或修改页表）时，它会调用一个 **PPL wrapper** 例程，该例程进行校验然后切换到 PPL 域。在该域外，受保护页面对主内核来说实际上是只读或不可修改的。
- 在 PPL 入口期间，APRR 映射会被调整，使 PPL 区域内的内存页面在 PPL 内被设置为**可执行 & 可写**。退出时，它们会被恢复为只读/不可写。这样可以确保只有经过严格审计的 PPL 例程才能写入受保护页面。
- 在 PPL 之外，内核代码尝试写入这些受保护页面将会发生 fault（权限被拒绝），因为该代码域的 APRR 映射不允许写入。

#### Protected page categories

PPL 通常保护的页面包括：

- 页表结构（translation table entries、映射元数据）
- 内核代码页，尤其是包含关键逻辑的那些页
- code-sign 元数据（trust caches、签名 blob）
- entitlements 表、签名强制表
- 以及其他高价值的内核结构，修改这些页面可导致绕过签名检查或操纵凭据

其思想是：即使内核内存被完全控制，攻击者也不能简单地修补或重写这些页面，除非他们也入侵了 PPL 例程或绕过了 PPL。

#### Known Bypasses & Vulnerabilities

1. **Project Zero’s PPL bypass (stale TLB trick)**

- Project Zero 的一篇公开写作描述了一个涉及**stale TLB entries** 的绕过方法。
- 思路为：

1. 分配两个物理页面 A 和 B，并将它们标记为 PPL 页面（因此它们受保护）。
2. 映射两个虚拟地址 P 和 Q，其 L3 translation table 页面来自 A 和 B。
3. 启动一个线程持续访问 Q，保持其 TLB 条目处于活动状态。
4. 调用 `pmap_remove_options()` 来移除从 P 开始的映射；由于一个 bug，代码错误地同时移除了 P 和 Q 的 TTEs，但只失效了 P 的 TLB 条目，留下 Q 的 stale 条目仍然存在。
5. 重新使用 B（Q 的表）来映射任意内存（例如 PPL 受保护的页面）。因为 stale TLB 条目仍然映射 Q 的旧映射，所以在该上下文中该映射仍然有效。
6. 通过这种方式，攻击者可以在不通过 PPL 接口的情况下放置对 PPL 受保护页面的可写映射。

- 该利用需要对物理映射和 TLB 行为有精细的控制。它表明依赖 TLB / 映射正确性的安全边界必须在 TLB 无效化和映射一致性方面非常小心。

- Project Zero 评论道，这类绕过是微妙且罕见的，但在复杂系统中是可能的。尽管如此，他们仍认为 PPL 是一个有效的缓解措施。

2. **Other potential hazards & constraints**

- 如果内核利用能够直接进入 PPL 例程（通过调用 PPL wrapper），它可能会绕过限制。因此对参数的验证至关重要。
- PPL 代码本身的 bug（例如算术溢出、边界检查错误）可能允许在 PPL 内部进行越界修改。Project Zero 观察到 `pmap_remove_options_internal()` 中的此类 bug 被用于他们的绕过。
- PPL 边界不可撤销地依赖硬件强制（APRR、memory controller），因此它的强度取决于硬件实现的可靠性。

#### Example
<details>
<summary>Code Example</summary>
下面是一个简化的伪代码 / 逻辑，展示内核如何可能调用 PPL 来修改受保护页面：
</details>
```c
// In kernel (outside PPL domain)
function kernel_modify_pptable(pt_addr, new_entry) {
// validate arguments, etc.
return ppl_call_modify(pt_addr, new_entry)  // call PPL wrapper
}

// In PPL (trusted domain)
function ppl_call_modify(pt_addr, new_entry) {
// temporarily enable write access to protected pages (via APRR adjustments)
aprr_set_index_for_write(PPL_INDEX)
// perform the modification
*pt_addr = new_entry
// restore permissions (make pages read-only again)
aprr_restore_default()
return success
}

// If kernel code outside PPL does:
*pt_addr = new_entry  // a direct write
// It will fault because APRR mapping for non-PPL domain disallows write to that page
```
The kernel can do many normal operations, but only through `ppl_call_*` routines can it change protected mappings or patch code.
</details>

<details>
<summary>Example</summary>
A kernel exploit tries to overwrite the entitlement table, or disable code-sign enforcement by modifying a kernel signature blob. Because that page is PPL-protected, the write is blocked unless going through the PPL interface. So even with kernel code execution, you cannot bypass code-sign constraints or modify credential data arbitrarily.
On iOS 17+ certain devices use SPTM to further isolate PPL-managed pages.
</details>

#### PPL → SPTM / Replacements / Future

- On Apple’s modern SoCs (A15 or later, M2 or later), Apple supports **SPTM** (Secure Page Table Monitor), which **replaces PPL** for page table protections.
- Apple calls out in documentation: “Page Protection Layer (PPL) and Secure Page Table Monitor (SPTM) enforce execution of signed and trusted code … PPL manages the page table permission overrides … Secure Page Table Monitor replaces PPL on supported platforms.”
- The SPTM architecture likely shifts more policy enforcement into a higher-privileged monitor outside kernel control, further reducing the trust boundary.

### MTE | EMTE | MIE

Here’s a higher-level description of how EMTE operates under Apple’s MIE setup:

1. **Tag assignment**
- When memory is allocated (e.g. in kernel or user space via secure allocators), a **secret tag** is assigned to that block.
- The pointer returned to the user or kernel includes that tag in its high bits (using TBI / top byte ignore mechanisms).

2. **Tag checking on access**
- Whenever a load or store is executed using a pointer, the hardware checks that the pointer’s tag matches the memory block’s tag (allocation tag). If mismatch, it faults immediately (since synchronous).
- Because it's synchronous, there is no “delayed detection” window.

3. **Retagging on free / reuse**
- When memory is freed, the allocator changes the block’s tag (so older pointers with old tags no longer match).
- A use-after-free pointer would therefore have a stale tag and mismatch when accessed.

4. **Neighbor-tag differentiation to catch overflows**
- Adjacent allocations are given distinct tags. If a buffer overflow spills into neighbor’s memory, tag mismatch causes a fault.
- This is especially powerful in catching small overflows that cross boundary.

5. **Tag confidentiality enforcement**
- Apple must prevent tag values being leaked (because if attacker learns the tag, they could craft pointers with correct tags).
- They include protections (microarchitectural / speculative controls) to avoid side-channel leakage of tag bits.

6. **Kernel and user-space integration**
- Apple uses EMTE not just in user-space but also in kernel / OS-critical components (to guard kernel against memory corruption).
- The hardware/OS ensures tag rules apply even when kernel is executing on behalf of user space.

<details>
<summary>Example</summary>
```
Allocate A = 0x1000, assign tag T1
Allocate B = 0x2000, assign tag T2

// pointer P points into A with tag T1
P = (T1 << 56) | 0x1000

// Valid store
*(P + offset) = value // tag T1 matches allocation → allowed

// Overflow attempt: P’ = P + size_of_A (into B region)
*(P' + delta) = value
→ pointer includes tag T1 but memory block has tag T2 → mismatch → fault

// Free A, allocator retags it to T3
free(A)

// Use-after-free:
*(P) = value
→ pointer still has old tag T1, memory region is now T3 → mismatch → fault
```
</details>

#### Limitations & challenges

- **Intrablock overflows**: 如果 overflow 保持在相同的分配内（没有越过边界）并且 tag 保持相同，tag mismatch 无法检测到它。
- **Tag width limitation**: 可用于 tag 的位数很少（例如 4 位，或小域）— 命名空间受限。
- **Side-channel leaks**: 如果 tag 位可以被 leaked（通过 cache / speculative execution），攻击者可能会知道有效的 tags 并 bypass。Apple 的 tag confidentiality enforcement 旨在缓解这一点。
- **Performance overhead**: 每次 load/store 都要做 tag 检查会增加开销；Apple 必须在硬件层面进行优化以把开销降到很低。
- **Compatibility & fallback**: 在不支持 EMTE 的旧硬件或某些部件上必须有回退机制。Apple 声称只有在支持的设备上才启用 MIE。
- **Complex allocator logic**: allocator 必须管理 tags、retagging、对齐边界，并避免错标碰撞。allocator 逻辑中的 bug 可能会引入漏洞。
- **Mixed memory / hybrid areas**: 有些内存可能仍然未被标记（legacy），这会使互操作性更加棘手。
- **Speculative / transient attacks**: 像许多微架构保护一样，speculative execution 或 micro-op 融合可能会短暂绕过检查或泄露 tag 位。
- **Limited to supported regions**: Apple 可能只在选择的高风险区域（kernel、security-critical 子系统）强制执行 EMTE，而不是普遍适用。



---

## Key enhancements / differences compared to standard MTE

Here are the improvements and changes Apple emphasizes:

| Feature | Original MTE | EMTE (Apple’s enhanced) / MIE |
|---|---|---|
| **Check mode** | Supports synchronous and asynchronous modes. In async, tag mismatches are reported later (delayed)| Apple insists on **synchronous mode** by default—tag mismatches are caught immediately, no delay/race windows allowed.|
| **Coverage of non-tagged memory** | Accesses to non-tagged memory (e.g. globals) may bypass checks in some implementations | EMTE requires that accesses from a tagged region to non-tagged memory also validate tag knowledge, making it harder to bypass by mixing allocations.|
| **Tag confidentiality / secrecy** | Tags might be observable or leaked via side channels | Apple adds **Tag Confidentiality Enforcement**, which attempts to prevent leakage of tag values (via speculative side-channels etc.).|
| **Allocator integration & retagging** | MTE leaves much of allocator logic to software | Apple’s secure typed allocators (kalloc_type, xzone malloc, etc.) integrate with EMTE: when memory is allocated or freed, tags are managed at fine granularity.|
| **Always-on by default** | In many platforms, MTE is optional or off by default | Apple enables EMTE / MIE by default on supported hardware (e.g. iPhone 17 / A19) for kernel and many user processes.|

因为 Apple 同时控制硬件和软件栈，它可以严格地强制执行 EMTE，避免性能陷阱，并修补侧信道缺陷。

---

## How EMTE works in practice (Apple / MIE)

Here’s a higher-level description of how EMTE operates under Apple’s MIE setup:

1. **Tag assignment**
- 当内存被分配（例如在 kernel 或通过 secure allocators 在 user space 中）时，会给该块分配一个 **secret tag**。
- 返回给用户或 kernel 的 pointer 在高位中包含该 tag（使用 TBI / top byte ignore mechanisms）。

2. **Tag checking on access**
- 每当使用 pointer 执行 load 或 store 时，硬件会检查 pointer 的 tag 是否与内存块的 tag（allocation tag）匹配。如果不匹配，会立即 fault（因为是同步的）。
- 因为是同步的，所以不存在“延迟检测”的窗口。

3. **Retagging on free / reuse**
- 当内存被 free 时，allocator 会改变该块的 tag（因此带有旧 tag 的指针将不再匹配）。
- 因此 use-after-free 指针在访问时会因为 tag 过时而发生 mismatch。

4. **Neighbor-tag differentiation to catch overflows**
- 相邻的分配会被赋予不同的 tags。如果 buffer overflow 溢出到邻居的内存，tag mismatch 会导致 fault。
- 这在检测跨界的小型 overflow 时尤其有效。

5. **Tag confidentiality enforcement**
- Apple 必须防止 tag 值被泄露（因为如果攻击者知道了 tag，就可以构造带有正确 tag 的 pointer）。
- 他们包括了保护（microarchitectural / speculative 控制）以避免 tag 位的 side-channel 泄露。

6. **Kernel and user-space integration**
- Apple 不仅在 user-space 中使用 EMTE，也在 kernel / OS 关键组件中使用（以保护 kernel 免受内存破坏）。
- 硬件/OS 确保即使在 kernel 为 user space 执行时也应用 tag 规则。

因为 EMTE 内置于 MIE，Apple 在关键攻击面上以同步模式使用 EMTE，而不是作为可选或调试模式。



---

## Exception handling in XNU

当发生 **exception**（例如 `EXC_BAD_ACCESS`、`EXC_BAD_INSTRUCTION`、`EXC_CRASH`、`EXC_ARM_PAC` 等）时，XNU kernel 的 **Mach layer** 负责在其成为 UNIX 风格的 **signal**（如 `SIGSEGV`、`SIGBUS`、`SIGILL` 等）之前拦截它。

这个过程涉及多个层次的 exception 传播和处理，才会到达 user space 或被转换为 BSD signal。


### Exception Flow (High-Level)

1.  **CPU triggers a synchronous exception**（例如无效的 pointer 解引用、PAC failure、illegal instruction 等）。

2.  **Low-level trap handler** 运行（在 XNU 源码中为 `trap.c`、`exception.c`）。

3.  trap handler 调用 **`exception_triage()`**，这是 Mach exception 处理的核心。

4.  `exception_triage()` 决定如何路由该 exception：

-   首先到 **thread 的 exception port**。

-   然后到 **task 的 exception port**。

-   然后到 **host 的 exception port**（通常是 `launchd` 或 `ReportCrash`）。

如果这些 port 都没有处理该 exception，kernel 可能会：

-   **将其转换为 BSD signal**（对于 user-space 进程）。

-   **panic**（对于 kernel-space 的 exception）。


### Core Function: `exception_triage()`

函数 `exception_triage()` 将 Mach exceptions 按可能的处理者链路进行路由，直到某个处理者处理它，或者最终致命。它在 `osfmk/kern/exception.c` 中定义。
```c
void exception_triage(exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt);
```
**典型调用流程：**

`exception_triage()
└── exception_deliver()
├── exception_deliver_thread()
├── exception_deliver_task()
└── exception_deliver_host()`

如果全部失败 → 由 `bsd_exception()` 处理 → 转换为像 `SIGSEGV` 这样的信号。


### Exception Ports

每个 Mach 对象（thread、task、host）可以注册 **exception ports**，异常消息会被发送到这些端口。

它们由 API 定义：
```
task_set_exception_ports()
thread_set_exception_ports()
host_set_exception_ports()
```
Each exception port has:

-   A **mask** (which exceptions it wants to receive)
-   A **port name** (Mach port to receive messages)
-   A **behavior** (how the kernel sends the message)
-   A **flavor** (which thread state to include)


### Debuggers and Exception Handling

A **debugger** (e.g., LLDB) sets an **exception port** on the target task or thread, usually using `task_set_exception_ports()`.

**当发生异常时：**

-   Mach message 会被发送到调试器进程。
-   调试器可以决定是否**处理**（resume、修改寄存器、跳过指令）该异常。
-   如果调试器不处理，异常会传播到下一层（task → host）。


### Flow of `EXC_BAD_ACCESS`

1.  线程解除引用无效指针 → CPU 触发 Data Abort。

2.  内核陷阱处理程序调用 `exception_triage(EXC_BAD_ACCESS, ...)`。

3.  消息被发送到：

-   Thread port →（调试器可以拦截断点）。

-   如果调试器忽略 → Task port →（进程级处理器）。

-   如果仍被忽略 → Host port（通常是 ReportCrash）。

4.  如果没人处理 → `bsd_exception()` 将其转换为 `SIGSEGV`。


### PAC Exceptions

当 **Pointer Authentication (PAC)** 失败（签名不匹配）时，会抛出一个**特殊的 Mach 异常**：

-   **`EXC_ARM_PAC`**（类型）
-   Codes 可能包含细节（例如 key type、pointer type）。

如果二进制带有标志 **`TFRO_PAC_EXC_FATAL`**，内核会将 PAC 失败视为**致命**，绕过调试器拦截。这样做是为了防止攻击者使用调试器绕过 PAC 检查，并且该标志在 **platform binaries** 中启用。


### Software Breakpoints

软件断点（x86 上的 `int3`，ARM64 上的 `brk`）是通过**故意引发故障**来实现的。\
调试器通过 exception port 捕获该故障：

-   修改指令指针或内存。
-   恢复原始指令。
-   恢复执行。

相同的机制也允许你“捕获”PAC 异常——**除非设置了 `TFRO_PAC_EXC_FATAL`**，在这种情况下异常永远不会到达调试器。


### Conversion to BSD Signals

如果没有处理程序接受该异常：

-   内核调用 `task_exception_notify() → bsd_exception()`。

-   这将 Mach 异常映射为信号：

| Mach Exception | Signal |
| --- | --- |
| EXC_BAD_ACCESS | SIGSEGV or SIGBUS |
| EXC_BAD_INSTRUCTION | SIGILL |
| EXC_ARITHMETIC | SIGFPE |
| EXC_SOFTWARE | SIGTRAP |
| EXC_BREAKPOINT | SIGTRAP |
| EXC_CRASH | SIGKILL |
| EXC_ARM_PAC | SIGILL (on non-fatal) |


### Key Files in XNU Source

-   `osfmk/kern/exception.c` → `exception_triage()`、`exception_deliver_*()` 的核心实现。

-   `bsd/kern/kern_sig.c` → 信号投递逻辑。

-   `osfmk/arm64/trap.c` → 低级 trap 处理程序。

-   `osfmk/mach/exc.h` → 异常代码和结构。

-   `osfmk/kern/task.c` → 任务异常端口的设置。


---

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

内核使用一个按大小划分的 **zone allocator**（`kalloc`），分成固定大小的 “zones”。每个 zone 只存储单一 size class 的分配。

从截图看：

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | 非常小的内核结构体、指针。                                                   |
| `default.kalloc.32`  | 32 bytes     | 小型结构体、对象头。                                                         |
| `default.kalloc.64`  | 64 bytes     | IPC messages、微小的内核缓冲区。                                              |
| `default.kalloc.128` | 128 bytes    | 中等对象，例如 `OSObject` 的部分。                                           |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | 大型结构体，IOSurface/graphics 元数据。                                      |

工作原理：

- 每个分配请求会被**向上取整**到最近的 zone 大小。（例如，50 字节的请求会进入 `kalloc.64` zone）。
- 每个 zone 的内存由一个 **freelist** 管理 —— 被内核释放的块会回到该 zone。
- 如果你溢出一个 64 字节的缓冲区，你会覆盖**同一 zone 中的下一个对象**。

这就是为什么 **heap spraying / feng shui** 如此有效：通过喷同一 size class 的分配可以预测对象邻居。


### The freelist

在每个 kalloc zone 内，被释放的对象不会直接返回给系统 —— 它们进入一个 freelist，一个可用块的链表。

- 当一个块被释放时，内核会在该块的起始处写入一个指针 → 指向同一 zone 中下一个空闲块的地址。

- zone 保持一个 HEAD 指针指向第一个空闲块。

- 分配总是使用当前的 HEAD：

1. Pop HEAD（把该内存返回给调用者）。

2. 更新 HEAD = HEAD->next（存储在被释放块的头部）。

- 释放时把块推回去：

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

所以 freelist 只是利用被释放内存本身构建的一个链表。

正常状态：
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Exploiting the freelist

因为 free chunk 的前 8 字节 = freelist pointer，攻击者可以破坏它：

1. **Heap overflow** 写入相邻的 freed chunk → 覆盖其 “next” pointer。

2. **Use-after-free** 写入 freed object → 覆盖其 “next” pointer。

然后，在下一次分配该大小时：

- allocator 弹出被破坏的 chunk。
- 跟随攻击者提供的 “next” pointer。
- 返回指向任意内存的 pointer，从而实现 fake object primitives 或定向覆盖。

Visual example of freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
这种 freelist 设计在加固之前使得利用变得非常高效：来自 heap sprays 的可预测邻居、原始指针 freelist 链接，以及没有类型隔离，允许攻击者将 UAF/overflow 漏洞升级为对任意 kernel memory 的控制。

### Heap Grooming / Feng Shui
The goal of heap grooming is to **shape the heap layout** so that when an attacker triggers an overflow or use-after-free, the target (victim) object sits right next to an attacker-controlled object.\
That way, when memory corruption happens, the attacker can reliably overwrite the victim object with controlled data.

**Steps:**

1. Spray allocations (fill the holes)
- Over time, the kernel heap gets fragmented: some zones have holes where old
objects were freed.
- The attacker first makes lots of dummy allocations to fill these gaps, so
the heap becomes “packed” and predictable.

2. Force new pages
- Once the holes are filled, the next allocations must come from new pages
added to the zone.
- Fresh pages mean objects will be clustered together, not scattered across
old fragmented memory.
- This gives the attacker much better control of neighbors.

3. Place attacker objects
- The attacker now sprays again, creating lots of attacker-controlled objects
in those new pages.
- These objects are predictable in size and placement (since they all belong
to the same zone).

4. Free a controlled object (make a gap)
- The attacker deliberately frees one of their own objects.
- This creates a “hole” in the heap, which the allocator will later reuse for
the next allocation of that size.

5. Victim object lands in the hole
- The attacker triggers the kernel to allocate the victim object (the one
they want to corrupt).
- Since the hole is the first available slot in the freelist, the victim is
placed exactly where the attacker freed their object.

6. Overflow / UAF into victim
- Now the attacker has attacker-controlled objects around the victim.
- By overflowing from one of their own objects (or reusing a freed one), they
can reliably overwrite the victim’s memory fields with chosen values.

**Why it works**:

- Zone allocator predictability: allocations of the same size always come from
the same zone.
- Freelist behavior: new allocations reuse the most recently freed chunk first.
- Heap sprays: attacker fills memory with predictable content and controls layout.
- End result: attacker controls where the victim object lands and what data sits
next to it.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple 对 allocator 进行了加固，使得 **heap grooming 变得更加困难**：

### 1. From Classic kalloc to kalloc_type
- **Before**: a single `kalloc.<size>` zone existed for each size class (16, 32, 64, … 1280, etc.). Any object of that size was placed there → attacker objects could sit next to privileged kernel objects.
- **Now**:
- Kernel objects are allocated from **typed zones** (`kalloc_type`).
- Each type of object (e.g., `ipc_port_t`, `task_t`, `OSString`, `OSData`) has its own dedicated zone, even if they’re the same size.
- The mapping between object type ↔ zone is generated from the **kalloc_type system** at compile time.

An attacker can no longer guarantee that controlled data (`OSData`) ends up adjacent to sensitive kernel objects (`task_t`) of the same size.

### 2. Slabs and Per-CPU Caches
- The heap is divided into **slabs** (pages of memory carved into fixed-size chunks for that zone).
- Each zone has a **per-CPU cache** to reduce contention.
- Allocation path:
1. Try per-CPU cache.
2. If empty, pull from the global freelist.
3. If freelist is empty, allocate a new slab (one or more pages).
- **Benefit**: This decentralization makes heap sprays less deterministic, since allocations may be satisfied from different CPUs’ caches.

### 3. Randomization inside zones
- Within a zone, freed elements are not handed back in simple FIFO/LIFO order.
- Modern XNU uses **encoded freelist pointers** (safe-linking like Linux, introduced ~iOS 14).
- Each freelist pointer is **XOR-encoded** with a per-zone secret cookie.
- This prevents attackers from forging a fake freelist pointer if they gain a write primitive.
- Some allocations are **randomized in their placement within a slab**, so spraying doesn’t guarantee adjacency.

### 4. Guarded Allocations
- Certain critical kernel objects (e.g., credentials, task structures) are allocated in **guarded zones**.
- These zones insert **guard pages** (unmapped memory) between slabs or use **redzones** around objects.
- Any overflow into the guard page triggers a fault → immediate panic instead of silent corruption.

### 5. Page Protection Layer (PPL) and SPTM
- Even if you control a freed object, you can’t modify all of kernel memory:
- **PPL (Page Protection Layer)** enforces that certain regions (e.g., code signing data, entitlements) are **read-only** even to the kernel itself.
- On **A15/M2+ devices**, this role is replaced/enhanced by **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- These hardware-enforced layers mean attackers can’t escalate from a single heap corruption to arbitrary patching of critical security structures.
- **(Added / Enhanced)**: also, **PAC (Pointer Authentication Codes)** is used in the kernel to protect pointers (especially function pointers, vtables) so that forging or corrupting them becomes harder.
- **(Added / Enhanced)**: zones may enforce **zone_require / zone enforcement**, i.e. that an object freed can only be returned through its correct typed zone; invalid cross-zone frees may panic or be rejected. (Apple alludes to this in their memory safety posts)

### 6. Large Allocations
- Not all allocations go through `kalloc_type`.
- Very large requests (above ~16 KB) bypass typed zones and are served directly from **kernel VM (kmem)** via page allocations.
- These are less predictable, but also less exploitable, since they don’t share slabs with other objects.

### 7. Allocation Patterns Attackers Target
Even with these protections, attackers still look for:
- **Reference count objects**: if you can tamper with retain/release counters, you may cause use-after-free.
- **Objects with function pointers (vtables)**: corrupting one still yields control flow.
- **Shared memory objects (IOSurface, Mach ports)**: these are still attack targets because they bridge user ↔ kernel.

But — unlike before — you can’t just spray `OSData` and expect it to neighbor a `task_t`. You need **type-specific bugs** or **info leaks** to succeed.

### Example: Allocation Flow in Modern Heap

Suppose userspace calls into IOKit to allocate an `OSData` object:

1. **Type lookup** → `OSData` maps to `kalloc_type_osdata` zone (size 64 bytes).
2. Check per-CPU cache for free elements.
- If found → return one.
- If empty → go to global freelist.
- If freelist empty → allocate a new slab (page of 4KB → 64 chunks of 64 bytes).
3. Return chunk to caller.

**Freelist pointer protection**:
- Each freed chunk stores the address of the next free chunk, but encoded with a secret key.
- Overwriting that field with attacker data won’t work unless you know the key.

---

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages, and **PAC** protects pointers |
| Allocation reuse validation     | None (freelist pointers raw)                               | **zone_require / zone enforcement**             |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |
| Large allocations handling      | All small allocations managed equally                       | Large ones bypass zones → handled via VM         |

---

## Modern Userland Heap (iOS, macOS — type-aware / xzone malloc)

In recent Apple OS versions (especially iOS 17+), Apple introduced a more secure userland allocator, **xzone malloc** (XZM). This is the user-space analog to the kernel’s `kalloc_type`, applying type awareness, metadata isolation, and memory tagging safeguards.

### Goals & Design Principles

- **Type segregation / type awareness**: group allocations by *type or usage (pointer vs data)* to prevent type confusion and cross-type reuse.
- **Metadata isolation**: separate heap metadata (e.g. free lists, size/state bits) from object payloads so that out-of-bounds writes are less likely to corrupt metadata.
- **Guard pages / redzones**: insert unmapped pages or padding around allocations to catch overflows.
- **Memory tagging (EMTE / MIE)**: work in conjunction with hardware tagging to detect use-after-free, out-of-bounds, and invalid accesses.
- **Scalable performance**: maintain low overhead, avoid excessive fragmentation, and support many allocations per second with low latency.

### Architecture & Components

Below are the main elements in the xzone allocator:

#### Segment Groups & Zones

- **Segment groups** partition the address space by usage categories: e.g. `data`, `pointer_xzones`, `data_large`, `pointer_large`.
- Each segment group contains **segments** (VM ranges) that host allocations for that category.
- Associated with each segment is a **metadata slab** (separate VM area) that stores metadata (e.g. free/used bits, size classes) for that segment. This **out-of-line (OOL) metadata** ensures that metadata is not intermingled with object payloads, mitigating corruption from overflows.
- Segments are carved into **chunks** (slices) which in turn are subdivided into **blocks** (allocation units). A chunk is tied to a specific size class and segment group (i.e. all blocks in a chunk share the same size & category).
- For small / medium allocations, it will use fixed-size chunks; for large/huges, it may map separately.

#### Chunks & Blocks

- A **chunk** is a region (often several pages) dedicated to allocations of one size class within a group.
- Inside a chunk, **blocks** are slots available for allocations. Freed blocks are tracked via the metadata slab — e.g. via bitmaps or free lists stored out-of-line.
- Between chunks (or within), **guard slices / guard pages** may be inserted (e.g. unmapped slices) to catch out-of-bounds writes.

#### Type / Type ID

- Every allocation site (or call to malloc, calloc, etc.) is associated with a **type identifier** (a `malloc_type_id_t`) which encodes what kind of object is being allocated. That type ID is passed to the allocator, which uses it to select which zone / segment to serve the allocation.
- Because of this, even if two allocations have the same size, they may go into entirely different zones if their types differ.
- In early iOS 17 versions, not all APIs (e.g. CFAllocator) were fully type-aware; Apple addressed some of those weaknesses in iOS 18.

---

### Allocation & Freeing Workflow

Here is a high-level flow of how allocation and deallocation operate in xzone:

1. **malloc / calloc / realloc / typed alloc** is invoked with a size and type ID.
2. The allocator uses the **type ID** to pick the correct segment group / zone.
3. Within that zone/segment, it seeks a chunk that has free blocks of the requested size.
- It may consult **local caches / per-thread pools** or **free block lists** from metadata.
- If no free block is available, it may allocate a new chunk in that zone.
4. The metadata slab is updated (free bit cleared, bookkeeping).
5. If memory tagging (EMTE) is in play, the returned block gets a **tag** assigned, and metadata is updated to reflect its “live” state.
6. When `free()` is called:
- The block is marked as freed in metadata (via OOL slab).
- The block may be placed into a free list or pooled for reuse.
- Optionally, block contents may be cleared or poisoned to reduce data leaks or use-after-free exploitation.
- The hardware tag associated with the block may be invalidated or re-tagged.
- If an entire chunk becomes free (all blocks freed), the allocator may **reclaim** that chunk (unmap it or return to OS) under memory pressure.

---

### Security Features & Hardening

These are the defenses built into modern userland xzone:

| Feature | Purpose | Notes |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | Prevent overflow from corrupting metadata | Metadata lives in separate VM region (metadata slab)|
| **Guard pages / unmapped slices** | Catch out-of-bounds writes | Helps detect buffer overflows rather than silently corrupting adjacent blocks|
| **Type-based segregation** | Prevent cross-type reuse & type confusion | Even same-size allocations from different types go to different zones|
| **Memory Tagging (EMTE / MIE)** | Detect invalid access, stale references, OOB, UAF | xzone works in concert with hardware EMTE in synchronous mode (“Memory Integrity Enforcement”)|
| **Delayed reuse / poisoning / zap** | Reduce chance of use-after-free exploitation | Freed blocks may be poisoned, zeroed, or quarantined before reuse |
| **Chunk reclamation / dynamic unmapping** | Reduce memory waste and fragmentation | Entire chunks may be unmapped when unused |
| **Randomization / placement variation** | Prevent deterministic adjacency | Blocks in a chunk and chunk selection may have randomized aspects |
| **Segregation of “data-only” allocations** | Separate allocations that don’t store pointers | Reduces attacker control over metadata or control fields|

---

### Interaction with Memory Integrity Enforcement (MIE / EMTE)

- Apple’s MIE (Memory Integrity Enforcement) is the hardware + OS framework that brings **Enhanced Memory Tagging Extension (EMTE)** into always-on, synchronous mode across major attack surfaces.
- xzone allocator is a fundamental foundation of MIE in user space: allocations done via xzone get tags, and accesses are checked by hardware.
- In MIE, the allocator, tag assignment, metadata management, and tag confidentiality enforcement are integrated to ensure that memory errors (e.g. stale reads, OOB, UAF) are caught immediately, not exploited later.

---

If you like, I can also generate a cheat-sheet or diagram of xzone internals for your book. Do you want me to do that next?
::contentReference[oai:20]{index=20}


---

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
