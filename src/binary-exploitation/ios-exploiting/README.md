# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

- **Code Signing** in iOS funktioniert so, dass jedes ausführbare Stück Code (Apps, Libraries, Extensions, etc.) kryptografisch mit einem von Apple ausgestellten Zertifikat signiert sein muss. Beim Laden von Code verifiziert iOS die digitale Signatur gegen Apples vertrauenswürdiges Root-Zertifikat. Ist die Signatur ungültig, fehlt oder wurde verändert, verweigert das OS die Ausführung. Das verhindert, dass Angreifer bösartigen Code in legitime Apps injizieren oder unsigned Binaries ausführen, und stoppt damit die meisten Exploit-Chains, die auf das Ausführen beliebigen oder manipulierten Codes angewiesen sind.
- **CoreTrust** ist das iOS-Subsystem, das Code-Signing zur Laufzeit durchsetzt. Es verifiziert Signaturen direkt mit Apples Root-Zertifikat, ohne sich auf zwischengespeicherte Trust-Stores zu verlassen, was bedeutet, dass nur Binaries, die von Apple signiert sind (oder gültige Entitlements haben), ausgeführt werden können. CoreTrust stellt sicher, dass selbst wenn ein Angreifer eine App nach der Installation manipuliert, Systembibliotheken verändert oder versucht, unsigned Code zu laden, die Ausführung blockiert wird, sofern der Code nicht korrekt signiert ist. Diese strikte Durchsetzung schließt viele Post-Exploitation-Vektoren, die ältere iOS-Versionen über schwächere oder umgehbare Signaturprüfungen zuließen.
- **Data Execution Prevention (DEP)** markiert Speicherregionen als nicht ausführbar, es sei denn, sie enthalten explizit Code. Das verhindert, dass Angreifer Shellcode in Datenregionen (wie Stack oder Heap) injizieren und ausführen; stattdessen müssen sie auf komplexere Techniken wie ROP (Return-Oriented Programming) zurückgreifen.
- **ASLR (Address Space Layout Randomization)** randomisiert die Speicheradressen von Code, Libraries, Stack und Heap bei jedem Systemstart. Das erschwert es Angreifern, vorherzusagen, wo nützliche Instruktionen oder Gadgets liegen, und bricht viele Exploit-Chains, die von festen Speicherlayouts abhängen.
- **KASLR (Kernel ASLR)** wendet das gleiche Randomisierungsprinzip auf den iOS-Kernel an. Durch Verschieben der Kernel-Base-Adresse bei jedem Boot verhindert es, dass Angreifer zuverlässig Kernel-Funktionen oder -Strukturen finden, und erhöht die Schwierigkeit von Kernel-Level-Exploits, die sonst volle Systemkontrolle erlangen würden.
- **Kernel Patch Protection (KPP)**, auch bekannt als **AMCC (Apple Mobile File Integrity)** in iOS, überwacht kontinuierlich die Kernel-Code-Seiten, um sicherzustellen, dass sie nicht verändert wurden. Wird Manipulation festgestellt — z. B. wenn ein Exploit versucht, Kernel-Funktionen zu patchen oder bösartigen Code einzufügen — wird das Gerät sofort panicen und neu starten. Dieser Schutz macht persistente Kernel-Exploits deutlich schwerer, da Angreifer Kernel-Instruktionen nicht einfach hooken oder patchen können, ohne einen Systemabsturz auszulösen.
- **Kernel Text Readonly Region (KTRR)** ist eine hardwarebasierte Sicherheitsfunktion auf iOS-Geräten. Sie nutzt den Speichercontroller der CPU, um den Kernel-Code (Text-Segment) nach dem Boot dauerhaft als read-only zu markieren. Einmal gesperrt, kann nicht einmal der Kernel selbst diese Speicherregion ändern. Das verhindert, dass Angreifer — und sogar privilegierter Code — Kernel-Instruktionen zur Laufzeit patchen, und schließt eine große Klasse von Exploits, die auf das direkte Modifizieren von Kernel-Code angewiesen waren.
- **Pointer Authentication Codes (PAC)** verwenden kryptografische Signaturen, die in ungenutzten Bits von Pointern eingebettet sind, um deren Integrität vor der Verwendung zu prüfen. Wenn ein Pointer (z. B. eine Rücksprungadresse oder ein Funktionspointer) erstellt wird, signiert die CPU ihn mit einem geheimen Schlüssel; vor dem Dereferenzieren prüft die CPU die Signatur. Wurde der Pointer manipuliert, schlägt die Prüfung fehl und die Ausführung stoppt. Das verhindert, dass Angreifer gefälschte oder korrupte Pointer in Memory-Corruption-Exploits verwenden, und macht Techniken wie ROP oder JOP deutlich schwerer zuverlässig durchführbar.
- **Privilege Access never (PAN)** ist eine Hardware-Funktion, die verhindert, dass der Kernel (privilegierter Modus) direkt auf User-Space-Speicher zugreift, es sei denn, er aktiviert den Zugriff explizit. Das stoppt Angreifer, die Code-Execution im Kernel erlangen, daran, ohne Weiteres User-Memory zu lesen oder zu schreiben, um Exploits zu eskalieren oder sensible Daten zu stehlen. Durch die strikte Trennung reduziert PAN die Auswirkungen von Kernel-Exploits und blockiert viele gängige Privilege-Escalation-Techniken.
- **Page Protection Layer (PPL)** ist ein iOS-Sicherheitsmechanismus, der kritische kernelverwaltete Speicherbereiche schützt, insbesondere solche, die mit Code-Signing und Entitlements zusammenhängen. Er erzwingt strikte Schreibschutzmechanismen mittels MMU (Memory Management Unit) und zusätzlicher Prüfungen und stellt sicher, dass selbst privilegierter Kernel-Code nicht beliebig sensitive Pages verändern kann. Das verhindert, dass Angreifer mit Kernel-Level-Execution sicherheitskritische Strukturen manipulieren, und erschwert Persistenz und Code-Signing-Bypässe erheblich.

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

Der Kernel verwendete einen **zone allocator** (`kalloc`), aufgeteilt in festgroße "zones".
Jede Zone speicherte nur Allokationen einer einzelnen Größenklasse.

From the screenshot:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 Bytes     | Sehr kleine Kernel-Structs, Pointer.                                        |
| `default.kalloc.32`  | 32 Bytes     | Kleine Structs, Objekt-Header.                                              |
| `default.kalloc.64`  | 64 Bytes     | IPC-Messages, winzige Kernel-Buffer.                                        |
| `default.kalloc.128` | 128 Bytes    | Mittlere Objekte wie Teile von `OSObject`.                                  |
| `default.kalloc.256` | 256 Bytes    | Größere IPC-Messages, Arrays, Geräte-Strukturen.                            |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 Bytes   | Große Strukturen, IOSurface-/Graphics-Metadaten.                            |

**How it worked:**
- Jede Allokationsanfrage wurde auf die nächste Zone-Größe **aufgerundet**.
(z. B. landet eine 50-Byte-Anfrage in der `kalloc.64`-Zone).
- Speicher in jeder Zone wurde in einer **freelist** gehalten — vom Kernel freigegebene Chunks gingen zurück in diese Zone.
- Wenn du einen 64-Byte-Buffer overflowtest, überschreibst du das **nächste Objekt in derselben Zone**.

Deshalb war **heap spraying / feng shui** so effektiv: du konntest Objekt-Nachbarn vorhersagen, indem du Allokationen derselben Größenklasse gesprayd hast.

### The freelist

Innerhalb jeder kalloc-Zone wurden freigegebene Objekte nicht direkt an das System zurückgegeben — sie landeten in einer freelist, einer verketteten Liste verfügbarer Chunks.

- Wenn ein Chunk freigegeben wurde, schrieb der Kernel einen Pointer an den Anfang dieses Chunks → die Adresse des nächsten freien Chunks in derselben Zone.

- Die Zone hielt einen HEAD-Pointer auf den ersten freien Chunk.

- Eine Allokation nutzte immer das aktuelle HEAD:

1. Pop HEAD (gibt diesen Speicher an den Caller zurück).

2. Update HEAD = HEAD->next (gespeichert im Header des freigegebenen Chunks).

- Freigeben schob Chunks wieder zurück:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

Also war die freelist einfach eine verkettete Liste, die in dem freigegebenen Speicher selbst aufgebaut wurde.

Normalzustand:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Freelist ausnutzen

Da die ersten 8 Bytes eines free chunk = freelist pointer, könnte ein Angreifer diesen korrumpieren:

1. **Heap overflow** in einen angrenzenden freed chunk → überschreibt dessen “next” pointer.

2. **Use-after-free** Schreibzugriff auf ein freed object → überschreibt dessen “next” pointer.

Dann, bei der nächsten Allocation dieser Größe:

- Der Allocator poppt den korrumpierten Chunk.
- Folgt dem vom Angreifer gelieferten “next” pointer.
- Gibt einen Pointer auf beliebigen Speicher zurück, wodurch fake object primitives oder targeted overwrite möglich werden.

Visuelles Beispiel für freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
This freelist-Design machte Exploitation vor den Hardening-Maßnahmen sehr effektiv: predictable neighbors durch heap sprays, raw pointer freelist links und keine Typtrennung erlaubten Angreifern, UAF/overflow-Bugs in beliebige Kontrolle über Kernel-Speicher zu eskalieren.

### Heap Grooming / Feng Shui
Das Ziel von heap grooming ist, das Heap-Layout so zu gestalten, dass wenn ein Angreifer einen overflow oder use-after-free auslöst, das Zielobjekt (Victim) direkt neben einem vom Angreifer kontrollierten Objekt liegt.\
Auf diese Weise kann bei Speicherkorruption der Angreifer zuverlässig das Victim-Objekt mit kontrollierten Daten überschreiben.

**Schritte:**

1. Spray allocations (fill the holes)
- Im Laufe der Zeit fragmentiert der kernel heap: Einige Zonen haben Lücken, in denen alte Objekte freed wurden.
- Der Angreifer macht zuerst viele Dummy-Allocations, um diese Lücken zu füllen, sodass der Heap „gepackt“ und vorhersehbar wird.

2. Force new pages
- Sobald die Lücken gefüllt sind, müssen die nächsten Allocations aus neuen Pages kommen, die der Zone hinzugefügt werden.
- Frische Pages bedeuten, dass Objekte zusammengeclustert werden, statt über alten fragmentierten Speicher verstreut zu sein.
- Das gibt dem Angreifer deutlich bessere Kontrolle über Nachbarn.

3. Place attacker objects
- Der Angreifer sprayed erneut und erzeugt viele attacker-controlled Objekte in diesen neuen Pages.
- Diese Objekte sind in Größe und Platzierung vorhersehbar (da sie alle zur gleichen Zone gehören).

4. Free a controlled object (make a gap)
- Der Angreifer freed absichtlich eines seiner eigenen Objekte.
- Dadurch entsteht ein „Hole“ im Heap, das der Allocator später für die nächste Allocation dieser Größe wiederverwenden wird.

5. Victim object lands in the hole
- Der Angreifer löst aus, dass der Kernel das Victim-Objekt (das er korruptieren möchte) alloziert.
- Da die Lücke der zuerst verfügbare Slot in der freelist ist, wird das Victim genau dort platziert, wo der Angreifer sein Objekt freed hat.

6. Overflow / UAF into victim
- Nun hat der Angreifer attacker-controlled Objekte um das Victim herum.
- Durch Overflow aus einem eigenen Objekt (oder Wiederverwendung eines freed Objekts) kann er zuverlässig die Speicherfelder des Victims mit gewählten Werten überschreiben.

**Warum das funktioniert**:

- Zone allocator predictability: Allocations gleicher Größe kommen immer aus der gleichen Zone.
- Freelist behavior: Neue Allocations reuse den zuletzt freed Chunk zuerst.
- Heap sprays: Der Angreifer füllt Speicher mit vorhersehbarem Inhalt und kontrolliert das Layout.
- Endergebnis: Der Angreifer kontrolliert, wo das Victim landet und welche Daten daneben liegen.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple hat den Allocator gehärtet und machte **heap grooming much harder**:

### 1. From Classic kalloc to kalloc_type
- **Before**: Für jede Größenklasse (16, 32, 64, … 1280, etc.) existierte eine einzelne `kalloc.<size>` Zone. Jedes Objekt dieser Größe wurde dort platziert → Angreifer-Objekte konnten neben privilegierten Kernel-Objekten liegen.
- **Now**:
- Kernel-Objekte werden aus **typed zones** (`kalloc_type`) alloziert.
- Jeder Objekttyp (z. B. `ipc_port_t`, `task_t`, `OSString`, `OSData`) hat seine eigene dedizierte Zone, selbst wenn sie die gleiche Größe haben.
- Die Zuordnung zwischen Objekttyp ↔ Zone wird zur Compile-Zeit vom **kalloc_type system** generiert.

Ein Angreifer kann nicht mehr garantieren, dass kontrollierte Daten (`OSData`) neben sensiblen Kernel-Objekten (`task_t`) gleicher Größe landen.

### 2. Slabs and Per-CPU Caches
- Der Heap ist in **slabs** unterteilt (Pages, die in fixed-size Chunks für diese Zone aufgeteilt sind).
- Jede Zone hat einen **per-CPU cache**, um Contention zu reduzieren.
- Allocation-Pfad:
1. Versuche per-CPU cache.
2. Falls leer, ziehe aus der global freelist.
3. Falls freelist leer, alloziere einen neuen slab (eine oder mehrere Pages).
- **Vorteil**: Diese Dezentralisierung macht heap sprays weniger deterministisch, da Allocations aus den Caches verschiedener CPUs bedient werden können.

### 3. Randomization inside zones
- Innerhalb einer Zone werden freed Elemente nicht in einfacher FIFO/LIFO-Reihenfolge zurückgegeben.
- Modernes XNU verwendet **encoded freelist pointers** (safe-linking-ähnlich wie Linux, eingeführt ~iOS 14).
- Jeder freelist-Pointer ist mit einem zonespezifischen Secret Cookie **XOR-encodiert**.
- Das verhindert, dass Angreifer gefälschte freelist-Pointer erzeugen können, wenn sie einen write-primitive erlangen.
- Manche Allocations werden **in ihrer Platzierung innerhalb eines Slabs randomisiert**, sodass Spraying keine Adjazenz garantiert.

### 4. Guarded Allocations
- Bestimmte kritische Kernel-Objekte (z. B. credentials, task-Strukturen) werden in **guarded zones** alloziert.
- Diese Zonen fügen **guard pages** (nicht gemappter Speicher) zwischen Slabs ein oder nutzen **redzones** um Objekte.
- Jeder Overflow in die Guard Page löst einen Fault aus → sofortiger Panic anstelle stiller Korruption.

### 5. Page Protection Layer (PPL) and SPTM
- Selbst wenn du ein freed Objekt kontrollierst, kannst du nicht ganzes Kernel-Memory modifizieren:
- **PPL (Page Protection Layer)** erzwingt, dass bestimmte Regionen (z. B. code signing data, entitlements) **read-only** sind, selbst für den Kernel.
- Auf **A15/M2+ devices** wird diese Rolle durch **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)** ersetzt/erweitert.
- Diese hardware-gestützten Layer bedeuten, dass Angreifer nicht von einer einzelnen Heap-Korruption auf beliebiges Patchen kritischer Sicherheitsstrukturen eskalieren können.

### 6. Large Allocations
- Nicht alle Allocations laufen über `kalloc_type`.
- Sehr große Requests (oberhalb ~16KB) umgehen typed zones und werden direkt aus dem **kernel VM (kmem)** via Page-Allocations bedient.
- Diese sind weniger vorhersehbar, aber auch weniger exploitbar, da sie Slabs nicht mit anderen Objekten teilen.

### 7. Allocation Patterns Attackers Target
Auch mit diesen Protektionen suchen Angreifer weiterhin nach:
- **Reference count objects**: Wenn man retain/release-Zähler manipulieren kann, lässt sich eventuell use-after-free erzwingen.
- **Objects with function pointers (vtables)**: Das Korruptieren solcher Objekte liefert weiterhin Kontrolle über Control Flow.
- **Shared memory objects (IOSurface, Mach ports)**: Diese bleiben Angriffsziele, da sie user ↔ kernel vermitteln.

Aber — anders als früher — kann man nicht einfach `OSData` sprayen und erwarten, dass es neben einem `task_t` landet. Man benötigt **type-specific bugs** oder **info leaks**, um erfolgreich zu sein.

### Example: Allocation Flow in Modern Heap

Angenommen, Userspace ruft IOKit auf, um ein `OSData`-Objekt zu alloziieren:

1. **Type lookup** → `OSData` mapped zur `kalloc_type_osdata` Zone (Größe 64 bytes).
2. Prüfe per-CPU cache nach freien Elementen.
- Falls gefunden → gib eines zurück.
- Falls leer → gehe zur global freelist.
- Falls freelist leer → alloziere einen neuen slab (Page von 4KB → 64 Chunks à 64 bytes).
3. Gib den Chunk an den Caller zurück.

**Freelist pointer protection**:
- Jeder freed Chunk speichert die Adresse des nächsten freien Chunks, aber encodiert mit einem Secret Key.
- Das Überschreiben dieses Feldes mit Angreifer-Daten funktioniert nicht, sofern man den Key nicht kennt.

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages   |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and install it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


{{#include ../../banners/hacktricks-training.md}}
