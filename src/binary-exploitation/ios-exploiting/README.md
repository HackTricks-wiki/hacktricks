# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

- **Code Signing** u iOS funkcioniše tako što zahteva da svaki deo izvršnog koda (apps, libraries, extensions, itd.) bude kriptografski potpisan sertifikatom koji izdaje Apple. Kada se kod učitava, iOS verifikuje digitalni potpis u odnosu na Apple-ov trusted root. Ako je potpis nevažeći, nedostaje ili je izmenjen, OS odbija da ga izvrši. Ovo sprečava napadače da ubacuju maliciozni kod u legitimne aplikacije ili pokreću unsigned binarije, efikasno zaustavljajući većinu exploit lanaca koji zavise od izvršavanja proizvoljnog ili izmenjenog koda.
- **CoreTrust** je iOS subsistem odgovoran za sprovođenje code signing-a u runtime-u. On direktno verifikuje potpise koristeći Apple-ov root sertifikat bez oslanjanja na keširane trust store-ove, što znači da samo binariji potpisani od strane Apple-a (ili sa validnim entitlements) mogu da se izvršavaju. CoreTrust osigurava da čak i ako napadač izmeni aplikaciju posle instalacije, modifikuje system libraries ili pokuša da učita unsigned code, sistem će blokirati izvršenje osim ako kod nije ispravno potpisan. Ovo strogo sprovođenje zatvara mnoge post-exploitation vektore koje su starije iOS verzije dozvoljavale kroz slabije ili zaobilažive provere potpisa.
- **Data Execution Prevention (DEP)** označava regionе memorije kao neizvršne osim ako eksplicitno ne sadrže kod. Ovo sprečava napadače da ubace shellcode u data regionе (kao stack ili heap) i izvrše ga, prisiljavajući ih da se oslone na složenije tehnike poput ROP (Return-Oriented Programming).
- **ASLR (Address Space Layout Randomization)** nasumično raspoređuje adrese memorije koda, libraries, stack-a i heap-a pri svakom pokretanju sistema. To otežava napadačima da predvide gde se nalaze korisne instrukcije ili gadgets, kvareći mnoge exploit lance koji zavise od fiksnih memorijskih rasporeda.
- **KASLR (Kernel ASLR)** primenjuje isti koncept randomizacije na iOS kernel. Mešanjem kernel base adrese pri svakom boot-u, on sprečava napadače da pouzdano lociraju kernel funkcije ili strukture, povećavajući težinu kernel-level exploit-a koji bi inače omogućili potpunu kontrolu nad sistemom.
- **Kernel Patch Protection (KPP)**, takođe poznat kao **AMCC (Apple Mobile File Integrity)** u iOS-u, kontinuirano nadgleda kernel code pages kako bi osigurao da nisu modifikovani. Ako se detektuje bilo kakvo manipulisanje—kao pokušaj exploit-a da patch-uje kernel funkcije ili ubaci maliciozni kod—uređaj će odmah panic-ovati i restartovati se. Ova zaštita čini uporne kernel exploit-e znatno težim, jer napadači ne mogu jednostavno da hook-uju ili patch-uju kernel instrukcije bez izazivanja sistemskog pada.
- **Kernel Text Readonly Region (KTRR)** je hardverska sigurnosna osobina uvedena na iOS uređajima. Koristi memory controller CPU-a da označi kernel-ov code (text) segment kao trajno read-only nakon boot-a. Jednom zaključan, čak ni kernel sam ne može da modifikuje taj region memorije. Ovo sprečava napadače—i čak privilegovani kod—da patch-uju kernel instrukcije u runtime-u, zatvarajući veliku klasu exploit-a koji su se oslanjali na direktnu modifikaciju kernel koda.
- **Pointer Authentication Codes (PAC)** koriste kriptografske potpise ugrađene u neiskorišćene bitove pointera da verifikuju njihov integritet pre upotrebe. Kada se pointer (kao return address ili function pointer) kreira, CPU ga potpisuje sa tajnim ključem; pre dereferenciranja, CPU proverava potpis. Ako je pointer bio izmenjen, provera zakazuje i izvršenje se zaustavlja. Ovo sprečava napadače da falsifikuju ili ponovo koriste korumpirane pointere u memory corruption exploit-ima, čineći tehnike poput ROP ili JOP mnogo težim za pouzdano izvođenje.
- **Privilege Access Never (PAN)** je hardverska osobina koja sprečava kernel (privileged mode) da direktno pristupa user-space memoriji osim ako eksplicitno ne omogući pristup. Ovo zaustavlja napadače koji su dobili kernel code execution da lako čitaju ili pišu user memory radi eskalacije exploit-a ili krađe osetljivih podataka. Sprovodeći strogo razdvajanje, PAN smanjuje uticaj kernel exploit-a i blokira mnoge uobičajene tehnike za eskalaciju privilegija.
- **Page Protection Layer (PPL)** je iOS mehanizam zaštite koji štiti kritične kernel-managed memory regione, posebno one povezane sa code signing-om i entitlements. On nameće stroga write-protection pravila koristeći MMU (Memory Management Unit) i dodatne provere, osiguravajući da čak ni privilegovani kernel kod ne može proizvoljno da modifikuje osetljive stranice. Ovo sprečava napadače koji dobiju kernel-level execution da manipulišu security-critical strukturama, čineći persistence i code-signing bypass-ove značajno težim.

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

Kernel je koristio **zone allocator** (`kalloc`) podeljen na zone fiksne veličine.
Svaka zona je čuvala alokacije samo jedne size klase.

Iz snimka ekrana:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Veoma male kernel strukture, pointeri.                                      |
| `default.kalloc.32`  | 32 bytes     | Male strukture, object headers.                                             |
| `default.kalloc.64`  | 64 bytes     | IPC messages, sitni kernel bufferi.                                         |
| `default.kalloc.128` | 128 bytes    | Srednji objekti poput delova `OSObject`.                                    |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Velike strukture, IOSurface/graphics metadata.                              |

Kako je radilo:
- Svaki zahtev za alokacijom se **zaokruživao nagore** na najbližu zone veličinu.
(Npr. zahtev od 50 bajtova završi u zoni `kalloc.64`).
- Memorija u svakoj zoni se držala u **freelist**-u — chunk-ovi koje je kernel oslobodio vraćali su se u tu zonu.
- Ako bi prelio 64-bajtni buffer, prepisali biste **sledeći objekat u istoj zoni**.

Zato je **heap spraying / feng shui** bio toliko efikasan: mogao si da predvidiš susede objekata prskanjem alokacija iste size klase.

### The freelist

Unutar svake kalloc zone, oslobođeni objekti nisu vraćani direktno sistemu — išli su u freelist, povezanu listu dostupnih chunk-ova.

- Kada bi se chunk oslobodio, kernel je zapisivao pointer na početku tog chunka → adresu sledećeg slobodnog chunka u istoj zoni.

- Zona je držala HEAD pointer na prvi slobodni chunk.

- Alokacija je uvek koristila trenutni HEAD:

1. Pop HEAD (vrati tu memoriju pozivaocu).

2. Ažuriraj HEAD = HEAD->next (smešteno u header-u oslobođenog chunka).

- Freeing je gurala chunk-ove nazad:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

Dakle, freelist je bila jednostavno povezana lista izgrađena unutar same oslobođene memorije.

Uobičajeno stanje:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Eksploatacija freelist-a

Pošto prvih 8 bajtova slobodnog chunk-a = freelist pointer, napadač može da ga korumpira:

1. **Heap overflow** u susedni freed chunk → prepiše njegov “next” pointer.

2. **Use-after-free** upis u oslobođeni objekat → prepiše njegov “next” pointer.

Zatim, pri sledećoj alokaciji te veličine:

- Alokator izvlači korumpirani chunk.

- Prati attacker-supplied “next” pointer.

- Vraća pointer na proizvoljnu memoriju, omogućavajući fake object primitives ili targeted overwrite.

Vizuelni primer freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
Ovaj dizajn freelist-a je pre hardeninga činio eksploataciju veoma efikasnom: predvidljivi susedi iz heap sprays, raw pointer freelist links i odsustvo razdvajanja tipova omogućavali su napadačima da eskaliraju UAF/overflow bugove u arbitrarno upravljanje kernel memorijom.

### Heap Grooming / Feng Shui
The goal of heap grooming is to **oblikovati heap layout** tako da kada napadač izazove overflow ili use-after-free, ciljani (victim) objekat sedi tačno pored objekta pod kontrolom napadača.\
Na taj način, kada se dogodi korupcija memorije, napadač može pouzdano prepisati victim objekat sa kontrolisanim podacima.

**Koraci:**

1. Spray allocations (fill the holes)
- Vremenom se kernel heap fragmentira: neke zone imaju rupe gde su stari objekti bili oslobođeni.
- Napadač prvo pravi mnogo dummy allocations da popuni ove praznine, tako da heap postane “packed” i predvidljiv.

2. Force new pages
- Kada se rupe popune, naredne allocations moraju da dolaze iz novih pages dodatih u zone.
- Sveže pages znače da će objekti biti grupisani zajedno, a ne razbacani po staroj fragmentiranoj memoriji.
- To daje napadaču mnogo bolju kontrolu nad susedima.

3. Place attacker objects
- Napadač sada ponovo radi spray, kreirajući mnogo attacker-controlled objekata na tim novim pages.
- Ti objekti su predvidljivi po veličini i poziciji (pošto svi pripadaju istoj zone).

4. Free a controlled object (make a gap)
- Napadač namerno free-uje jedan od svojih objekata.
- To stvara „rupu“ u heap-u koju će allocator kasnije iskoristiti za sledeću alokaciju te veličine.

5. Victim object lands in the hole
- Napadač izaziva kernel da alocira victim objekat (onaj koji želi da korumpira).
- Pošto je rupa prvi dostupan slot u freelist-u, victim se postavlja tačno tamo gde je napadač free-ovao svoj objekat.

6. Overflow / UAF into victim
- Sada napadač ima attacker-controlled objekte oko victima.
- Prelivanjem iz jednog od svojih objekata (ili ponovnim korišćenjem oslobođenog) može pouzdano prepisati polja victim-ovog objekta sa izabranim vrednostima.

**Zašto ovo funkcioniše**:

- Zone allocator predictability: allocations iste veličine uvek dolaze iz iste zone.
- Freelist behavior: nove allocations ponovo koriste najskorije oslobođeni chunk prvi.
- Heap sprays: napadač puni memoriju predvidljivim sadržajem i kontroliše layout.
- Krajnji rezultat: napadač kontroliše gde će victim objekat da se nađe i koji podaci su pored njega.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple je ojačao allocator i učinio **heap grooming mnogo težim**:

### 1. From Classic kalloc to kalloc_type
- **Pre**: postojala je jedinstvena `kalloc.<size>` zone za svaku size klasu (16, 32, 64, … 1280, itd.). Bilo koji objekat te veličine bio je smesten tamo → attacker objekti su mogli sedeti pored privilegovanih kernel objekata.
- **Sada**:
- Kernel objekti se alociraju iz **typed zones** (`kalloc_type`).
- Svaki tip objekta (npr. `ipc_port_t`, `task_t`, `OSString`, `OSData`) ima svoju dedikovanu zone, čak i ako su iste veličine.
- Mapiranje između tipa objekta ↔ zone se generiše iz **kalloc_type sistema** u vreme kompajliranja.

Napadač više ne može da garantuje da će kontrolisani podaci (`OSData`) završiti pored osetljivih kernel objekata (`task_t`) iste veličine.

### 2. Slabs and Per-CPU Caches
- Heap je podeljen na **slabs** (pages memorije isečene u fiksne-chunkove za tu zone).
- Svaka zone ima **per-CPU cache** da smanji contentions.
- Allocation put:
1. Pokušaj per-CPU cache.
2. Ako je prazno, uzmi iz global freelist-a.
3. Ako je freelist prazan, alociraj novi slab (jedna ili više pages).
- **Prednost**: ova decentralizacija čini heap sprays manje determinističkim, pošto allocations mogu biti zadovoljene iz cache-a različitih CPU.

### 3. Randomization inside zones
- Unutar zone, oslobođeni elementi se ne vraćaju u jednostavnom FIFO/LIFO redu.
- Modern XNU koristi **encoded freelist pointers** (safe-linking stil kao Linux, uvedeno oko iOS 14).
- Svaki freelist pokazivač je **XOR-enkodiran** sa per-zone secret cookie.
- Ovo sprečava napadače da falsifikuju lažni freelist pointer ako dobiju write primitive.
- Neke allocatione su **randomizovane u njihovom postavljanju unutar slaba**, tako da spray ne garantuje adjacency.

### 4. Guarded Allocations
- Određeni kritični kernel objekti (npr. credentials, task strukture) se alociraju u **guarded zones**.
- Ove zone ubacuju **guard pages** (ne-mapiranu memoriju) između slabs ili koriste **redzones** oko objekata.
- Bilo koji overflow u guard page izaziva fault → momentalni panic umesto tihi korupcije.

### 5. Page Protection Layer (PPL) and SPTM
- Čak i ako kontrolišete oslobođeni objekat, ne možete modifikovati celu kernel memoriju:
- **PPL (Page Protection Layer)** nameće da određene regije (npr. code signing podaci, entitlements) budu **read-only** čak i za sam kernel.
- Na **A15/M2+ uređajima**, ovu ulogu zamenjuju/pojačavaju **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- Ovi hardware-enforced slojevi znače da napadači ne mogu eskalirati iz jednog heap korupcije do arbitrarne patch-ovanja kritičnih security struktura.

### 6. Large Allocations
- Nisu sve allocations prolaze kroz `kalloc_type`.
- Veće zahteve (iznad ~16KB) zaobilaze typed zones i služe se direktno iz **kernel VM (kmem)** preko page allocations.
- One su manje predvidljive, ali i manje eksploatabilne, pošto ne dele slabove sa drugim objektima.

### 7. Allocation Patterns Attackers Target
Čak i uz ove zaštite, napadači i dalje traže:
- **Reference count objects**: ako možete dirati retain/release counters, možete izazvati use-after-free.
- **Objects with function pointers (vtables)**: korupcija jednog takvog i dalje može dati control flow.
- **Shared memory objects (IOSurface, Mach ports)**: ovi su i dalje meta jer povezuju user ↔ kernel.

Ali — za razliku od pre — ne možete samo spray-ovati `OSData` i očekivati da bude pored `task_t`. Potrebni su **type-specific bugovi** ili **info leaks** da bi se uspelo.

### Example: Allocation Flow in Modern Heap

Pretpostavimo da userspace pozove u IOKit da alocira `OSData` objekat:

1. **Type lookup** → `OSData` mapira na `kalloc_type_osdata` zone (size 64 bytes).
2. Provera per-CPU cache-a za slobodne elemente.
- Ako se nađe → vrati jedan.
- Ako je prazno → idi na global freelist.
- Ako je freelist prazan → alociraj novi slab (page od 4KB → 64 chunk-a od 64 bytes).
3. Vrati chunk pozivaocu.

**Freelist pointer protection**:
- Svaki oslobođeni chunk čuva adresu sledećeg slobodnog chunka, ali enkodiranu sa secret ključem.
- Overwriting tog polja sa attacker podacima neće raditi osim ako ne znate ključ.

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages   |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.

### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
