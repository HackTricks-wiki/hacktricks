# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

### 1. **Code Signing** / Runtime Signature Verification
**Bekendgestel vroeg (iPhone OS → iOS)**
Dit is een van die fondamentale beskermings: **all executable code** (apps, dynamic libraries, JIT-ed code, extensions, frameworks, caches) moet kriptografies onderteken wees deur ’n sertifikaatketting wat op Apple se trust wortel. Tydens uitvoering, voordat ’n binary in geheue gelaai word (of voordat spronge oor sekere grense gemaak word), kontroleer die stelsel sy handtekening. As die kode gewysig is (bit-flipped, patched) of unsigned, misluk die laai.

- **Thwarts**: die “classic payload drop + execute” fase in exploit-kettings; arbitrary code injection; die wysiging van ’n bestaande binary om kwaadwillige logika in te voeg.
- **Mechanism detail**:
* Die Mach-O loader (en dynamic linker) kontroleer code pages, segments, entitlements, team IDs, en dat die signature die lêer se inhoud dek.
* Vir geheueregions soos JIT caches of dinamies gegenereerde kode, dwing Apple dat bladsye onderteken of gevalideer moet word via spesiale APIs (bv. `mprotect` met code-sign checks).
* Die signature sluit entitlements en identifiers in; die OS dwing af dat sekere APIs of bevoorregte vermoëns spesifieke entitlements benodig wat nie vervals kan word nie.

<details>
<summary>Example</summary>
Stel ’n exploit verkry code execution in ’n proses en probeer shellcode na die heap skryf en daarna daarheen jump. Op iOS moet daardie bladsy as executable gemerk wees **en** code-signature-voorwaardes bevredig. Aangesien die shellcode nie met Apple se sertifikaat onderteken is nie, misluk die jump of weier die stelsel om daardie geheuegebied executable te maak.
</details>


### 2. **CoreTrust**
**Bekendgestel rondom iOS 14+ era (of geleidelik op nuwer toestelle / later iOS)**
CoreTrust is die subsisteem wat **runtime signature validation** van binaries uitvoer (insluitend stelsel- en gebruikersbinaries) teen **Apple’s root certificate** eerder as om op gekaslede userland trust stores te vertrou.

- **Thwarts**: post-install tampering van binaries, jailbreaking-tegnieke wat probeer om stelselbiblioteke of gebruikersapps te vervang of te patch; die stelsel mislei deur vertroude binaries met kwaadwillige weergawes te vervang.
- **Mechanism detail**:
* In plaas daarvan om ’n plaaslike trust-databasis of sertifikaat-cache te vertrou, verwys CoreTrust direk na Apple se root of verifieer intermediêre sertifikate in ’n veilige ketting.
* Dit verseker dat wysigings (bv. in die filesystem) aan bestaande binaries opgespoor en verwerp word.
* Dit bind entitlements, team IDs, code signing flags, en ander metadata aan die binary by laai-tyd.

<details>
<summary>Example</summary>
’n Jailbreak kan probeer om `SpringBoard` of `libsystem` met ’n gepatchte weergawe te vervang om persistentie te kry. Maar wanneer die OS se loader of CoreTrust nagaan, sien dit die signature mismatch (of gemodifiseerde entitlements) en weier dit die uitvoering.
</details>


### 3. **Data Execution Prevention (DEP / NX / W^X)**
**Ingevoer in baie OS’e vroeër; iOS het NX-bit / w^x al lank gehad**
DEP dwing af dat bladsye wat as writable gemerk is (vir data) **nie-executable** is, en bladsye wat executable is **nie-writable** is. Jy kan nie net shellcode in ’n heap of stack skryf en dit uitvoer nie.

- **Thwarts**: direkte shellcode-execution; klassieke buffer-overflow → jump na ingesate shellcode.
- **Mechanism detail**:
* Die MMU / memory protection flags (via page tables) dwing die skeiding af.
* Enige poging om ’n writable bladsy executable te maak, aktiveer ’n stelselkontrole (en is óf verbode óf vereis code-sign approvaal).
* In baie gevalle vereis dit om bladsye executable te maak deur OS-APIs wat addisionele beperkings of kontroles afdwing.

<details>
<summary>Example</summary>
’n Overflow skryf shellcode op die heap. Die aanvaller probeer `mprotect(heap_addr, size, PROT_EXEC)` om dit executable te maak. Maar die stelsel weier of verifieer dat die nuwe bladsy code-sign-voorwaardes moet slaag (wat die shellcode nie kan).
</details>

### 4. **Address Space Layout Randomization (ASLR)**
**Bekendgestel in iOS ~4–5 era (ongeveer iOS 4–5 tydperk)**
ASLR randomiseer die basisadresse van sleutel geheue-area’s: libraries, heap, stack, ens., by elke prosesstart. Gadgets se adresse skuif tussen runs.

- **Thwarts**: hardcoding van gadget-adresse vir ROP/JOP; statiese exploit-kettings; blindly jumping na bekende offsets.
- **Mechanism detail**:
* Elke gelaaide library / dynamic module word herbasis op ’n gerandomiseerde offset.
* Stack- en heap-basispunte is gerandomiseer (binne sekere entropy-limiete).
* Soms word ander regions (bv. mmap allocations) ook gerandomiseer.
* Gecombineer met information-leak mitigations, dwing dit die aanvaller om eers ’n address of pointer te leak om basisadresse tydens uitvoering te ontdek.

<details>
<summary>Example</summary>
’n ROP-ketting verwag gadget by `0x….lib + offset`. Maar aangesien `lib` by elke run anders herlokas, misluk die hardgekode ketting. ’n Exploit moet eers die base-adres van die module leak voordat dit gadget-adresse kan bereken.
</details>


### 5. **Kernel Address Space Layout Randomization (KASLR)**
**Bekendgestel in iOS ~ (iOS 5 / iOS 6 tydperk)**
Analogies aan user ASLR, KASLR randomiseer die basis van die **kernel text** en ander kernel strukture tydens boot.

- **Thwarts**: kernel-vlak exploits wat op vaste plekke in kernel code of data staatmaak; statiese kernel exploits.
- **Mechanism detail**:
* By elke boot word die kernel se base-adres gerandomiseer (binne ’n reeks).
* Kernel data strukture (soos `task_structs`, `vm_map`, ens.) kan ook verskuif of ge-offset wees.
* Aanvallers moet eers kernel pointers leak of gebruik maak van information disclosure vulnerabilities om offsets te bereken voordat hulle kernel strukture of code kan kap.

<details>
<summary>Example</summary>
’n Lokaal vulnerability probeer ’n kernel function pointer korrupteer (bv. in ’n `vtable`) by `KERN_BASE + offset`. Maar omdat `KERN_BASE` onbekend is, moet die aanvaller dit eers leak (bv. via ’n read primitive) voordat die korrekte adres bereken kan word.
</details>


### 6. **Kernel Patch Protection (KPP / AMCC)**
**Bekendgestel in nuwer iOS / A-series hardware (nakomend rond iOS 15–16 era of nuwer chips)**
KPP (aka AMCC) monitor voortdurend die integriteit van kernel text pages (via hash of checksum). As dit tampering (patches, inline hooks, code-wysigings) buite toegelate vensters ontdek, trigger dit ’n kernel panic of herbegin.

- **Thwarts**: persistente kernel patching (wysiging van kernel-instruksies), inline hooks, statiese funksie-overskrywings.
- **Mechanism detail**:
* ’n Hardware- of firmware-module monitor die kernel text region.
* Dit her-hash periodiek of op aanvraag die bladsye en vergelyk teen verwagte waardes.
* As mismatch buiten benign update-wensters voorkom, panikeer die toestel (om persistent kwaadwillige patch te voorkom).
* Aanvallers moet óf deteksie-vensters vermy óf legitieme patch-paaie gebruik.

<details>
<summary>Example</summary>
’n Exploit probeer ’n kernel funksieproloog (bv. `memcmp`) patch om oproepe te onderskep. Maar KPP sien dat die code-bladsy se hash nie meer ooreenstem nie en trigger ’n kernel panic, wat die toestel laat crash voordat die patch stabiliseer.
</details>


### 7. **Kernel Text Read‐Only Region (KTRR)**
**Bekendgestel in moderne SoCs (na ~A12 / nuwer hardware)**
KTRR is ’n hardware-afgedwingde meganisme: sodra die kernel text vroeër tydens boot ge-locked word, word dit read-only vanaf EL1 (die kernel), wat verdere skryf op code pages verhoed.

- **Thwarts**: enige wysigings aan kernel code ná boot (bv. patching, in-place code injection) op EL1 privilege-vlak.
- **Mechanism detail**:
* Tydens boot (in secure/bootloader-stadium) merk die memory controller (of ’n veilige hardware-eenheid) die fisiese bladsye wat kernel text bevat as read-only.
* Selfs as ’n exploit volle kernel voorregte kry, kan dit nie daardie bladsye skryf om instrukssies te patch nie.
* Om dit te wysig, moet die aanvaller eers die boot chain kompromitteer, of KTRR self subvervreem.

<details>
<summary>Example</summary>
’n Privilege-escalation exploit spring in EL1 en probeer ’n trampoline in ’n kernel funksie skryf (bv. in `syscall` handler). Maar omdat die bladsye deur KTRR read-only gemerk is, misluk die skryf (of trigger dit ’n fout), so word patches nie toegepas nie.
</details>


### 8. **Pointer Authentication Codes (PAC)**
**Bekendgestel met ARMv8.3 (hardware), Apple begin met A12 / iOS ~12+**
- PAC is ’n hardware-funksie bekendgestel in **ARMv8.3-A** om wysiging van pointer-waardes (return addresses, function pointers, sekere data pointers) op te spoor deur ’n klein kriptografiese handtekening (’n “MAC”) in ongebruikte hoë-bits van die pointer in te bed.
- Die handtekening (“PAC”) word oor die pointer-waarde plus ’n **modifier** (’n kontekstwaarde, bv. stack pointer of ander onderskeidende data) bereken. Sodoende kry dieselfde pointer-waarde in verskillende kontekste ’n ander PAC.
- By gebruikstyd word ’n **authenticate** instruksie die PAC nagaan. As dit geldig is, word die PAC verwyder en die suiwer pointer verkry; as dit ongeldig is, word die pointer “poisoned” (of ’n fout gegenereer).
- Die sleutels wat gebruik word om PACs te produseer/valideer, woon in bevoorregte registers (EL1, kernel) en is nie direk leesbaar vanaf user mode nie.
- Omdat nie al 64 bits van ’n pointer in baie stelsels gebruik word nie (bv. 48-bit address space), is die boonste bits “spaar” en kan die PAC sonder verandering aan die effektiewe adres gehou word.

#### Architectural Basis & Key Types

- ARMv8.3 maak voorsiening vir **vyf 128-bit sleutels** (elkeen geïmplementeer via twee 64-bit stelselregisters) vir pointer authentication.
- **APIAKey** — vir instruction pointers (domein “I”, sleutel A)
- **APIBKey** — tweede instruction pointer sleutel (domein “I”, sleutel B)
- **APDAKey** — vir data pointers (domein “D”, sleutel A)
- **APDBKey** — vir data pointers (domein “D”, sleutel B)
- **APGAKey** — “generic” sleutel, vir signing van nie-pointer data of ander generiese gebruike

- Hierdie sleutels word in bevoorregte stelselregisters gestoor (slegs toeganklik op EL1/EL2 ens.), nie toeganklik vanaf user mode nie.
- Die PAC word bereken deur ’n kriptografiese funksie (ARM stel QARMA voor as die algoritme) gebruikmakend van:
1. Die pointer-waarde (die kanoniese gedeelte)
2. ’n **modifier** (’n kontekstwaarde, soos ’n salt)
3. Die geheimsleutel
4. Sekere interne tweak-logika
As die resulterende PAC ooreenstem met wat in die boonste bits van die pointer gebêre is, slaag authenticatie.

#### Instruction Families

Die naamkonvensie is: **PAC** / **AUT** / **XPAC**, gevolg deur domeinletters.
- `PACxx` instruksies **sign** ’n pointer en voeg ’n PAC in
- `AUTxx` instruksies **authenticate + strip** (valideer en verwyder die PAC)
- `XPACxx` instruksies **strip** sonder validering

Domains / suffixes:

| Mnemonic     | Betekenis / Domein                      | Key / Domein     | Voorbeeldgebruik in Assembly |
|--------------|-----------------------------------------|------------------|-----------------------------|
| **PACIA**    | Sign instruction pointer with APIAKey   | “I, A”           | `PACIA X0, X1` — sign pointer in X0 using APIAKey with modifier X1|
| **PACIB**    | Sign instruction pointer with APIBKey   | “I, B”           | `PACIB X2, X3`              |
| **PACDA**    | Sign data pointer with APDAKey          | “D, A”           | `PACDA X4, X5`              |
| **PACDB**    | Sign data pointer with APDBKey          | “D, B”           | `PACDB X6, X7`              |
| **PACG / PACGA** | Generic (non-pointer) signing with APGAKey | “G”       | `PACGA X8, X9, X10` (sign X9 with modifier X10 into X8) |
| **AUTIA**    | Authenticate APIA-signed instruction pointer & strip PAC | “I, A” | `AUTIA X0, X1` — check PAC on X0 using modifier X1, then strip |
| **AUTIB**    | Authenticate APIB domain                | “I, B”           | `AUTIB X2, X3`              |
| **AUTDA**    | Authenticate APDA-signed data pointer   | “D, A”           | `AUTDA X4, X5`              |
| **AUTDB**    | Authenticate APDB-signed data pointer   | “D, B”           | `AUTDB X6, X7`              |
| **AUTGA**    | Authenticate generic / blob (APGA)      | “G”              | `AUTGA X8, X9, X10` (validate generic) |
| **XPACI**    | Strip PAC (instruction pointer, no validation) | “I”       | `XPACI X0` — remove PAC from X0 (instruction domain) |
| **XPACD**    | Strip PAC (data pointer, no validation) | “D”              | `XPACD X4` — remove PAC from data pointer in X4 |

Daar is gespesialiseerde / alias-vorme:

- `PACIASP` is ’n afkorting vir `PACIA X30, SP` (sign the link register using SP as modifier)
- `AUTIASP` is `AUTIA X30, SP` (authenticate link register with SP)
- Gecombineerde vorms soos `RETAA`, `RETAB` (authenticate-and-return) of `BLRAA` (authenticate & branch) bestaan in ARM uitbreidings / compiler-ondersteuning.
- Ook nul-modifier variante: `PACIZA` / `PACIZB` waar die modifier implisiet nul is, ens.

#### Modifiers

Die hoofdoel van die modifier is om die PAC aan ’n spesifieke konteks te bind sodat dieselfde adres wat in verskillende kontekste onderteken is, verskillende PACs kry. Dit verhoed eenvoudige pointer-hergebruik oor rame of objekke heen. Dis soos om ’n **salt by ’n hash** te voeg.

Dus:
- Die **modifier** is ’n kontekstwaarde (’n ander register) wat in die PAC-berekening meng. Tipiese keuses: die stack pointer (`SP`), ’n frame pointer, of ’n objek-ID.
- Die gebruik van SP as modifier is algemeen vir return address signing: die PAC word aan die spesifieke stack frame gebind. As jy probeer om die LR in ’n ander frame te hergebruik, verander die modifier en valideer die PAC misluk.
- Dieselfde pointer-waarde, onderteken met verskillende modifiers, gee verskillende PACs.
- Die modifier hoef nie geheim te wees nie, maar idealiter is dit nie deur die aanvaller beheerbaar nie.
- Vir instruksies wat pointers teken of verifieer waar geen sinvolle modifier bestaan nie, gebruik sommige vorms nul of ’n implisiete konstante.

#### Apple / iOS / XNU Customizations & Observations

- Apple se PAC-implementasie sluit **per-boot diversifiers** in sodat sleutels of tweaks by elke boot verander, wat hergebruik oor boots voorkom.
- Hulle sluit ook **cross-domain mitigations** in sodat PACs wat in user mode gesign is nie maklik in kernel mode hergebruik kan word nie, ens.
- Op Apple M1 / Apple Silicon het reverse engineering getoon dat daar **nege modifier-tipes** en Apple-spesifieke stelselregisters vir sleutelbeheer is.
- Apple gebruik PAC oor baie kernel-subsisteme: return address signing, pointer integriteit in kernel data, signed thread contexts, ens.
- Google Project Zero het getoon hoe, onder ’n kragtige memory read/write primitive in die kernel, een kernel PAC’s (vir A sleutels) op A12-era toestelle geforseer kon word, maar Apple het baie van daardie paaie gepatch.
- In Apple se stelsel is sommige sleutels **globaal oor die kernel**, terwyl user prosesse per-proses sleutel-willekeurigheid kan kry.

#### PAC Bypasses

1. **Kernel-mode PAC: teoreties vs werklike bypasses**

-   Omdat kernel PAC-sleutels en logika styf beheer word (bevoorregte registers, diversifiers, domein isolasie), is die vervalsing van arbitrêre gesigneerde kernel-pointers baie moeilik.
-   Azad se 2020 "iOS Kernel PAC, One Year Later" rapporteer dat in iOS 12-13 hy ’n paar gedeeltelike bypasses gevind het (signing gadgets, reuse van signed states, ongebeskermde indirekte takke) maar geen volledige generiese bypass nie. [bazad.github.io](https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf)
-   Apple se "Dark Magic" aanpassings beperk verder die aanvalsoppervlakke (domain switching, per-key enabling bits). [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Daar is ’n bekende **kernel PAC bypass CVE-2023-32424** op Apple silicon (M1/M2) gerapporteer deur Zecao Cai et al. [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Maar hierdie bypasses berus dikwels op baie spesifieke gadgets of implementeringsfoute; dit is nie generiese bypasses nie.

Dus word kernel PAC beskou as **uiters robuust**, alhoewel dit nie perfek is nie.

2. **User-mode / runtime PAC bypass techniques**

Hierdie is meer algemeen, en misbruik onvolmaakthede in hoe PAC toegepas of gebruik word in dynamic linking / runtime frameworks. Hieronder is klasse met voorbeelde.

2.1 **Shared Cache / A key issues**

-   Die **dyld shared cache** is ’n groot pre-linked blob van stelselframeworks en biblioteke. Omdat dit so wyd gedeel word, is funksiepointers binne die shared cache “pre-signed” en word deur baie prosesse gebruik. Aanvallers mik na hierdie reeds-gesigneerde pointers as “PAC oracles”.

-   Sommige bypass-tegnieke probeer om A-key gesigneerde pointers in die shared cache uit te trek of te hergebruik en dit in gadgets te kombineer.

-   Die "No Clicks Required" praatjie beskryf die bou van ’n oracle oor die shared cache om relatiewe adresse af te lei en dit met gesigneerde pointers te kombineer om PAC te omseil. [saelo.github.io](https://saelo.github.io/presentations/offensivecon_20_no_clicks.pdf)

-   Ook is invoere van funksiepointers uit shared libraries in userspace gevind as onvoldoende beskerm deur PAC, wat ’n aanvaller toelaat om funksiepointers te kry sonder om hul signature te verander. (Project Zero bug entry) [bugs.chromium.org](https://bugs.chromium.org/p/project-zero/issues/detail?id=2044&utm_source=chatgpt.com)

2.2 **dlsym(3) / dynamic symbol resolution**

-   ’n Bekende bypass is om `dlsym()` te roep om ’n reeds gesigneerde function pointer (signed with A-key, diversifier zero) te kry en dit dan te gebruik. Omdat `dlsym` ’n wettige gesigneerde pointer teruggee, omseil dit die behoefte om PAC te forge.

-   Epsilon se blog beskryf hoe sommige bypasses dit uitbuit: `dlsym("someSym")` lewer ’n signed pointer en kan vir indirekte calls gebruik word. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

-   Synacktiv se "iOS 18.4 --- dlsym considered harmful" beskryf ’n bug: sommige simbole wat via `dlsym` op iOS 18.4 opgelos word, return pointers wat verkeerdelik gesign is (of met buggy diversifiers), wat onbedoelde PAC bypass moontlik maak. [Synacktiv](https://www.synacktiv.com/en/publications/ios-184-dlsym-considered-harmful)

-   Die logika in dyld vir dlsym sluit in: wanneer `result->isCode`, teken hulle die teruggegewe pointer met `__builtin_ptrauth_sign_unauthenticated(..., key_asia, 0)`, d.w.s. konteks nul. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

Dus is `dlsym` ’n gereelde vektor in user-mode PAC bypasses.

2.3 **Other DYLD / runtime relocations**

-   Die DYLD loader en dinamiese relocation-logika is kompleks en kaart soms bladsye tydelik as read/write om relocations uit te voer, en skakel dan terug na read-only. Aanvallers misbruik hierdie vensters. Synacktiv se praatjie beskryf "Operation Triangulation", ’n timing-gebaseerde PAC bypass via dynamic relocations. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   DYLD pages word nou beskerm met SPRR / VM_FLAGS_TPRO (sekere beskermingsvlae vir dyld). Maar vroeër weergawes het swakere beskerming gehad. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   In WebKit exploit-kettings is die DYLD loader dikwels ’n teiken vir PAC bypass. Die skyfies noem dat baie PAC bypasses die DYLD loader geteiken het (via relocation, interposer hooks). [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

2.4 **NSPredicate / NSExpression / ObjC / SLOP**

-   In userland exploit-kettings word Objective-C runtime-metodes soos `NSPredicate`, `NSExpression` of `NSInvocation` gebruik om control calls te smokkel sonder duidelike pointer-forging.

-   Op ouer iOS (voor PAC) het ’n exploit gebruik gemaak van **fake NSInvocation** objects om arbitrary selectors op beheerde geheue te call. Met PAC is modifikasies nodig. Maar die tegniek SLOP (SeLector Oriented Programming) is steeds aanpasbaar onder PAC. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   Die oorspronklike SLOP-tegniek het toegelaat om ObjC calls te ketting deur fake invocations te skep; die bypass berus op die feit dat ISA of selector pointers soms nie volledig PAC-beskerm is nie. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   In omgewings waar pointer authentication gedeeltelik toegepas word, mag metode / selectors / target pointers nie altyd PAC-beskerming hê nie, wat ruimte vir bypass gee.

#### Example Flow

<details>
<summary>Example Signing & Authenticating</summary>
```
; Example: function prologue / return address protection
my_func:
stp x29, x30, [sp, #-0x20]!        ; push frame pointer + LR
mov x29, sp
PACIASP                            ; sign LR (x30) using SP as modifier
; … body …
mov sp, x29
ldp x29, x30, [sp], #0x20         ; restore
AUTIASP                            ; authenticate & strip PAC
ret

; Example: indirect function pointer stored in a struct
; suppose X1 contains a function pointer
PACDA X1, X2     ; sign data pointer X1 with context X2
STR X1, [X0]      ; store signed pointer

; later retrieval:
LDR X1, [X0]
AUTDA X1, X2       ; authenticate & strip
BLR X1             ; branch to valid target

; Example: stripping for comparison (unsafe)
LDR X1, [X0]
XPACI X1           ; strip PAC (instruction domain)
CMP X1, #some_label_address
BEQ matched_label
```
</details>

<details>
<summary>Example</summary>
'n Buffer overflow oorskryf 'n return address op die stack. Die aanvaller skryf die teiken gadget address maar kan nie die korrekte PAC bereken nie. Wanneer die funksie terugkeer, faal die CPU se `AUTIA` instruksie omdat die PAC nie ooreenstem nie. Die ketting misluk.
Project Zero se ontleding van A12 (iPhone XS) het getoon hoe Apple se PAC gebruik word en metodes om PACs te vervals as 'n aanvaller 'n memory read/write primitive het.
</details>


### 9. **Branch Target Identification (BTI)**
**Introduced with ARMv8.5 (later hardware)**
BTI is 'n hardware-funksie wat **indirect branch targets** kontroleer: wanneer `blr` of indirekte calls/jumps uitgevoer word, moet die teiken begin met 'n **BTI landing pad** (`BTI j` of `BTI c`). Om na gadget-adresse te spring wat nie die landing pad het nie, veroorsaak 'n uitsondering.

LLVM se implementasie noem drie variante van BTI-instruksies en hoe hulle na branch-tipes karteer.

| BTI Variant | What it permits (which branch types) | Typical placement / use case |
|-------------|----------------------------------------|-------------------------------|
| **BTI C** | Targets of *call*-style indirect branches (e.g. `BLR`, or `BR` using X16/X17) | Put at entry of functions that may be called indirectly |
| **BTI J** | Targets of *jump*-style branches (e.g. `BR` used for tail calls) | Placed at the beginning of blocks reachable by jump tables or tail-calls |
| **BTI JC** | Acts as both C and J | Can be targeted by either call or jump branches |

- In code saamgestel met branch target enforcement, voeg compilers 'n BTI-instruksie (C, J, of JC) by by elke geldige indirekte-branch teiken (funksie-beginpunte of blokke bereikbaar deur jumps) sodat indirekte branches slegs na daardie plekke kan suksesvol spring.
- **Direct branches / calls** (d.w.s. vaste-adres `B`, `BL`) word **nie deur BTI beperk nie**. Die veronderstelling is dat kode-bladsye vertrou word en 'n aanvaller nie dit kan verander nie (dus is direkte branches veilig).
- Ook, **RET / return** instruksies is gewoonlik nie deur BTI beperk nie omdat return-adresse beskerm word via PAC of return signing meganismes.

#### Mechanism and enforcement

- Wanneer die CPU 'n **indirect branch (BLR / BR)** decodeer in 'n bladsy wat gemerk is as “guarded / BTI-enabled,” kontroleer dit of die teikenadres se eerste instruksie 'n geldige BTI is (C, J, of JC soos toegelaat). Indien nie, gebeur 'n **Branch Target Exception**.
- Die BTI-instruksie-enkoding is ontwerp om opcode-ruimte wat voorheen gereserveer was vir NOPs (in vroeëre ARM-weergawes) te hergebruik. Dus bly BTI-enabled binaries backwards-compatible: op hardware sonder BTI-ondersteuning tree daardie instruksies as NOPs op.
- Die compiler-passe wat BTIs byvoeg, sit hulle slegs waar nodig in: funksies wat indirek aangeroep mag word, of basic blocks geteiken deur jumps.
- Sommige patches en LLVM-kode toon dat BTI nie ingevoeg word vir *alle* basic blocks nie — slegs daardie wat potensiële branch-teikens is (bv. van switch / jump tables).

#### BTI + PAC synergy

PAC beskerm die pointer-waarde (die bron) — verseker dat die ketting van indirekte calls / returns nie gemanipuleer is nie.

BTI verseker dat selfs 'n geldige pointer slegs na behoorlik gemerkte entry-punte mag wys.

Gekombineerd benodig 'n aanvaller beide 'n geldige pointer met korrekte PAC en dat die teiken 'n BTI daar het. Dit maak dit moeiliker om exploit gadgets te konstrueer.

#### Example


<details>
<summary>Example</summary>
'n Exploit probeer pivot in 'n gadget by `0xABCDEF` wat nie met `BTI c` begin nie. Die CPU, toe `blr x0` uitgevoer word, kontroleer die teiken en faal omdat die instruksie-uitlijning nie 'n geldige landing pad bevat nie. Dus raak baie gadgets onbruikbaar tensy hulle 'n BTI-prefiks het.
</details>


### 10. **Privileged Access Never (PAN) & Privileged Execute Never (PXN)**
**Introduced in more recent ARMv8 extensions / iOS support (for hardened kernel)**

#### PAN (Privileged Access Never)

- **PAN** is 'n funksie ingevoer in **ARMv8.1-A** wat voorkom dat **privileged code** (EL1 of EL2) **lees of skryf** na geheue wat as **user-accessible (EL0)** gemerk is, tensy PAN uitdruklik gedeaktiveer word.
- Die idee: selfs as die kernel mislei of gekompromitteer word, kan dit nie ewekansig user-space pointers dereference sonder eers om PAN te *skakel uit* nie, wat die risiko van **`ret2usr`**-styl exploits of misbruik van user-controlled buffers verminder.
- Wanneer PAN geaktiveer is (PSTATE.PAN = 1), veroorsaak enige privileged load/store instruksie wat 'n virtuele adres benader wat “accessible at EL0” is 'n **permission fault**.
- Die kernel, wanneer dit regsmatig user-space geheue moet benader (bv. kopieer data na/van user buffers), moet **PAN tydelik deaktiveer** (of oorskakel na “unprivileged load/store” instruksies) om daardie toegang toe te laat.
- In Linux on ARM64 is PAN-ondersteuning ingestel omstreeks 2015: kernel patches het opsporing van die funksie bygevoeg en `get_user` / `put_user` ens. vervang met variante wat PAN rondom user memory accesses skoonmaak.

**Key nuance / limitation / bug**
- Soos deur Siguza en ander aangetoon, beteken 'n spesifikasie-bug (of dubbelinterpretasie) in ARM se ontwerp dat **execute-only user mappings** (`--x`) moontlik **nie PAN trigger** nie. Met ander woorde, as 'n user bladsy uitvoerbaar maar nie leesbaar is nie, kan die kernel se leespoging PAN omseil omdat die argitektuur “accessible at EL0” as vereis leespermissie beskou, nie net uitvoerbaarheid nie. Dit lei tot 'n PAN-bypass in sekere konfigurasies.
- As gevolg hiervan, as iOS / XNU execute-only user pages toelaat (soos sommige JIT of code-cache opstellings mag doen), kan die kernel per ongeluk van hulle lees selfs met PAN aangeskakel. Dit is 'n bekende subtiele uitbuitbare area in sekere ARMv8+ stelsels.

#### PXN (Privileged eXecute Never)

- **PXN** is 'n page table vlag (in page table entries, leaf of block entries) wat aandui dat die bladsy **nie uitvoerbaar is wanneer in privileged mode** nie (d.w.s. wanneer EL1 dit uitvoer).
- PXN voorkom dat die kernel (of enige privileged code) in user-space bladsye inspring of instruksies vanaf user-ruimte uitvoer al het beheer gediversieer. In effek stop dit kernel-level control-flow om na user memory te spring.
- Gekombineer met PAN verseker dit dat:
1. Kernel nie (standaard) user-space data kan lees of skryf nie (PAN)
2. Kernel nie user-space code kan uitvoer nie (PXN)
- In die ARMv8 page table formaat het die leaf entries 'n `PXN` bit (en ook `UXN` vir unprivileged execute-never) in hul attribuut-bits.

Selfs as die kernel 'n beskadigde function pointer het wat na user memory wys, en dit probeer daarheen tak, sal die PXN-bit 'n fout veroorsaak.

#### Memory-permission model & how PAN and PXN map to page table bits

Om te verstaan hoe PAN / PXN werk, moet jy sien hoe ARM se vertaling en permissiemodel werk (vereenvoudig):

- Elke bladsy of blok entry het attribuut-velde insluitend **AP[2:1]** vir toegangsposisies (lees/skryf, privileged vs unprivileged) en **UXN / PXN** bits vir execute-never beperkings.
- Wanneer PSTATE.PAN 1 is (geaktiveer), dwing die hardeware gewysigde semantiek af: privileged toegang tot bladsye gemerk as “accessible by EL0” (d.w.s. user-accessible) word verbied (fault).
- As gevolg van die genoem bug, mag bladsye wat slegs uitvoerbaar is (geen lees-perm nie) nie as “accessible by EL0” beskou word onder sekere implementasies nie, wat PAN kan omseil.
- Wanneer 'n bladsy se PXN-bit gestel is, word uitvoering verbied selfs al kom die instruksie-fetch vanaf 'n hoër privilege-vlak.

#### Kernel usage of PAN / PXN in a hardened OS (e.g. iOS / XNU)

In 'n geharde kernel-ontwerp (soos wat Apple mag gebruik):

- Die kernel skakel PAN standaard aan (sodat privileged code beperk word).
- In paadjies wat regmatig user-buffers moet lees of skryf (bv. syscall buffer copy, I/O, read/write user pointer), deaktiveer die kernel tydelik **PAN** of gebruik spesiale instruksies om dit te oorbrug.
- Nadat die user data toegang klaar is, moet dit PAN weer heraktiveer.
- PXN word afgedwing via page tables: user pages het PXN = 1 (sodat kernel dit nie kan uitvoer nie), kernel pages het nie PXN nie (sodat kernel code dit kan uitvoer).
- Die kernel moet seker maak dat geen kodepaaie uitvoering na user memory bring nie (wat PXN omseil) — dus is exploit-kettinge wat op “jump into user-controlled shellcode” staatmaak geblokkeer.

Weens die genoemde PAN-omseiling via execute-only pages, kan Apple in 'n werklike stelsel execute-only user pages deaktiveer of die spesifikasie-kwessie omseil.

#### Attack surfaces, bypasses, and mitigations

- **PAN bypass via execute-only pages**: soos bespreek, die spesifikasie laat 'n gaping toe: user pages met execute-only (geen lees-perm) mag nie as “accessible at EL0” tel nie, so PAN sal kernel reads van sulke bladsye in sekere implementasies nie blokkeer nie. Dit gee die aanvaller 'n ongewone pad om data via “execute-only” sekies te voorsien.
- **Temporal window exploit**: as die kernel PAN vir 'n venster langer as nodig deaktiveer, kan 'n race of kwaadwillige paadjie daardie venster misbruik om onbedoelde user memory toegang te kry.
- **Forgotten re-enable**: as kodepaaie misluk om PAN weer aan te skakel, kan daaropvolgende kernel operasies verkeerdelik user memory benader.
- **Misconfiguration of PXN**: as page tables PXN op user pages nie stel nie of user code pages verkeerdelik map, kan die kernel mislei word om user-space code uit te voer.
- **Speculation / side-channels**: soortgelyk aan speculative bypasses, daar kan mikro-argitektuurale newe-effekte wees wat transiënt PAN / PXN kontroles oortree (alhoewel sulke aanvalle sterk afhanklik van CPU-ontwerp is).
- **Complex interactions**: In meer gevorderde funksies (bv. JIT, shared memory, just-in-time code regions), benodig die kernel fynbeheerde toestemming om sekere memory accesses of uitvoering in user-gemapte streke toe te laat; om dit veilig te ontwerp onder PAN/PXN-beperkings is nie triviaal nie.

#### Example

<details>
<summary>Code Example</summary>
Here are illustrative pseudo-assembly sequences showing enabling/disabling PAN around user memory access, and how a fault might occur.
```  
// Suppose kernel entry point, PAN is enabled (privileged code cannot access user memory by default)

; Kernel receives a syscall with user pointer in X0
; wants to read an integer from user space
mov   X1, X0        ; X1 = user pointer

; disable PAN to allow privileged access to user memory
MSR   PSTATE.PAN, #0   ; clear PAN bit, disabling the restriction

ldr   W2, [X1]       ; now allowed load from user address

; re-enable PAN before doing other kernel logic
MSR   PSTATE.PAN, #1   ; set PAN

; ... further kernel work ...

; Later, suppose an exploit corrupts a pointer to a user-space code page and jumps there
BR    X3             ; branch to X3 (which points into user memory)

; Because the target page is marked PXN = 1 for privileged execution,
; the CPU throws an exception (fault) and rejects execution
```
As die kernel nie PXN op daardie user page gestel het nie, kan die branch slaag — dit sou onveilig wees.

As die kernel vergeet om PAN weer te aktiveer na user memory access, skep dit 'n tydelike venster waar verdere kernel logic per ongeluk arbitrêre user memory kan lees/skryf.

As die user pointer na 'n execute-only page wys (user page met slegs execute-permissie, geen read/write), kan dit onder die PAN spec bug gebeur dat `ldr W2, [X1]` **nie** fout gee selfs met PAN geaktiveer nie, wat 'n bypass-exploit moontlik maak, afhangend van implementasie.

</details>

<details>
<summary>Example</summary>
'n kernel vulnerability probeer 'n user-provided function pointer neem en dit in kernel context aanroep (d.w.s. `call user_buffer`). Onder PAN/PXN is daardie operasie verbode of sal dit 'n fout veroorsaak.
</details>

---

### 11. **Top Byte Ignore (TBI) / Pointer Tagging**
**Introduced in ARMv8.5 / newer (or optional extension)**
TBI beteken dat die top byte (mees-betekenisvolle byte) van 'n 64-bit pointer deur address translation geïgnoreer word. Dit laat OS of hardware toe om **tag bits** in die pointer se top byte in te sluit sonder om die werklike adres te beïnvloed.

- TBI stands for **Top Byte Ignore** (soms genoem *Address Tagging*). Dit is 'n hardware feature (beskikbaar in baie ARMv8+ implementasies) wat **die hoogste 8 bits ignoreer** (bits 63:56) van 'n 64-bit pointer wanneer dit **address translation / load/store / instruction fetch** uitvoer.
- In praktyk behandel die CPU 'n pointer `0xTTxxxx_xxxx_xxxx` (waar `TT` = top byte) as `0x00xxxx_xxxx_xxxx` vir doeleindes van address translation, en masker die top byte af. Die top byte kan deur software gebruik word om **metadata / tag bits** te stoor.
- Dit gee software "gratis" in-band ruimte om 'n byte tag in elke pointer in te sluit sonder om te verander watter memory location dit verwys na.
- Die argitektuur verseker dat loads, stores, en instruction fetch die pointer met sy top byte gemaskeer (d.w.s. tag verwyder) behandel voordat die werklike memory access uitgevoer word.

Dus onkoppel TBI die **logiese pointer** (pointer + tag) van die **fisiese address** wat vir memory operations gebruik word.

#### Waarom TBI: Gebruiksgevalle en motivering

- **Pointer tagging / metadata**: Jy kan ekstra metadata stoor (bv. object type, version, bounds, integrity tags) in daardie top byte. Wanneer jy later die pointer gebruik, word die tag op hardware-vlak geïgnoreer, so jy hoef dit nie handmatig te verwyder vir die memory access nie.
- **Memory tagging / MTE (Memory Tagging Extension)**: TBI is die basiese hardware-meganisme waarop MTE bou. In ARMv8.5 gebruik die **Memory Tagging Extension** bits 59:56 van die pointer as 'n **logiese tag** en vergelyk dit met 'n **allocation tag** wat in memory gestoor is.
- **Enhanced security & integrity**: Deur TBI te kombineer met pointer authentication (PAC) of runtime checks, kan jy vereis dat nie net die pointer-waarde nie, maar ook die tag korrek is. 'n Aanvaller wat 'n pointer oor-skryf sonder die korrekte tag sal 'n ongelykende tag produseer.
- **Compatibility**: Omdat TBI opsioneel is en tag bits deur hardware geïgnoreer word, werk bestaande ongetagde kode normaal. Die tag bits word effektief "moenie-sorg" bits vir legacy-kode.

#### Example
<details>
<summary>Example</summary>
'n function pointer het 'n tag in sy top byte gehad (bv. `0xAA`). 'n Exploit oor-skryf die laer bits van die pointer maar vergeet die tag, so wanneer die kernel verifieer of sanitiseer, misluk die pointer of word dit verwerp.
</details>

---

### 12. **Page Protection Layer (PPL)**
**Introduced in late iOS / modern hardware (iOS ~17 / Apple silicon / high-end models)** (sommige verslae wys PPL circa macOS / Apple silicon, maar Apple bring analoog-beskermings na iOS)

- PPL is ontwerp as 'n **intra-kernel protection boundary**: selfs as die kernel (EL1) gekompromitteer is en lees/skryf-capabilities het, behoort dit nie vrylik sekere sensitiewe pages te kan wysig nie (veral page tables, code-signing metadata, kernel code pages, entitlements, trust caches, ens.).
- Dit kan gesien word as 'n **“kernel binne die kernel”** — 'n kleiner vertroude komponent (PPL) met **verhoogde bevoegdhede** wat alleen protected pages mag wysig. Ander kernel-kode moet in PPL routines aanroep om veranderinge te doen.
- Dit verminder die attack surface vir kernel exploits: selfs met volle arbitrary R/W/execute in kernel mode, moet exploit-kode ook op een of ander manier die PPL-domein betree (of PPL omseil) om kritieke strukture te wysig.
- Op nuwer Apple silicon (A15+ / M2+) skuif Apple na **SPTM (Secure Page Table Monitor)**, wat in baie gevalle PPL vervang vir page-table beskerming op daardie platforms.

Hier is hoe PPL vermoedelik werk, gebaseer op openbare analise:

#### Use of APRR / permission routing (APRR = Access Permission ReRouting)

- Apple hardware gebruik 'n meganisme genaamd **APRR (Access Permission ReRouting)**, wat toelaat dat page table entries (PTEs) klein indekse bevat, eerder as volwaardige permission bits. Daardie indekse word via APRR registers na werklike permissies gemap. Dit laat dinamiese her-mapping van permissies per domein toe.
- PPL benut APRR om privilegie binne kernel context te segregeer: slegs die PPL-domein mag die mapping tussen indekse en effektiewe permissies opdateer. Met ander woorde, wanneer nie-PPL kernel-kode 'n PTE skryf of probeer om permission bits te verander, sal die APRR-logika dit verhoed (of 'n read-only mapping afdwing).
- PPL-kode self loop in 'n beperkte streek (bv. `__PPLTEXT`) wat normaalweg nie-uitvoerbaar of nie-skrifbaar is totdat entry gates tydelik toegang gee. Die kernel roep PPL entry points ("PPL routines") aan om sensitiewe operasies uit te voer.

#### Gate / Entry & Exit

- Wanneer die kernel 'n beskermde page moet wysig (bv. om die permissies van 'n kernel code page te verander, of page tables aan te raak), roep dit 'n **PPL wrapper** routine aan wat validasie doen en dan in die PPL-domein oorskakel. Buiten daardie domein is die beskermde pages effektief read-only of nie-wysigbaar vir die hoof-kernel.
- Tydens PPL entry word die APRR-mappings aangepas sodat memory pages in die PPL-streek binne PPL as **executable & writable** gesetel is. By exit word hulle teruggesit na read-only / nie-wysigbaar. Dit verseker dat slegs goed-gekontroleerde PPL-routines beskermde pages kan skryf.
- Buiten PPL sal pogings deur kernel-kode om daardie beskermde pages te skryf fout (permission denied) omdat die APRR-mapping vir daardie kode-domein nie skryf-permissie toelaat nie.

#### Protected page categories

Die pages wat PPL tipies beskerm sluit in:

- Page table structures (translation table entries, mapping metadata)
- Kernel code pages, veral dié wat kritieke logika bevat
- Code-sign metadata (trust caches, signature blobs)
- Entitlement tables, signature enforcement tables
- Ander hoë-waarde kernel strukture waar 'n patch dit moontlik sou maak om signature checks of credentials te omseil

Die idee is dat selfs as kernel memory volledig gekontroleer word, die aanvaller nie eenvoudig daardie pages kan patch of herskryf nie, tensy hulle ook PPL routines kompromitteer of PPL omseil.

#### Known Bypasses & Vulnerabilities

1. **Project Zero’s PPL bypass (stale TLB trick)**

- 'n Openbare writeup deur Project Zero beskryf 'n bypass wat betrokke is by **stale TLB entries**.
- Die idee:

1. Allocate twee physical pages A en B, merk hulle as PPL pages (sodat hulle beskerm is).
2. Map twee virtual addresses P en Q waarvan die L3 translation table pages van A en B kom.
3. Spin 'n thread om voortdurend Q te access, wat sy TLB entry lewendig hou.
4. Roep `pmap_remove_options()` aan om mappings te verwyder wat by P begin; weens 'n bug verwyder die kode per ongeluk die TTEs vir beide P en Q, maar invalideer slegs die TLB entry vir P, wat Q se stale entry lewendig laat.
5. Hergebruik B (page Q se table) om willekeurige memory te map (bv. PPL-beskermde pages). Omdat die stale TLB entry steeds Q se ou mapping map, bly daardie mapping geldig vir daardie context.
6. Deur dit kan die aanvaller 'n writable mapping van PPL-beskermde pages in plek sit sonder om deur die PPL-interface te gaan.

- Hierdie exploit het fyn beheer van physical mapping en TLB-gedrag vereis. Dit demonstreer dat 'n security boundary wat op TLB / mapping korrektheid staatmaak uiters sorgvuldig moet wees oor TLB invalidations en mapping konsistensie.

- Project Zero het opgemerk dat bypasses soos hierdie subtiel en skaars is, maar moontlik in komplekse stelsels. Hulle beskou nogtans PPL as 'n stewige mitigasie.

2. **Other potential hazards & constraints**

- As 'n kernel exploit direk PPL routines kan betree (deur die PPL wrappers aan te roep), kan dit die beperkings omseil. Daarom is argument-validasie kritiek.
- Bugs in die PPL-kode self (bv. arithmetic overflow, boundary checks) kan binnenshuis in PPL out-of-bounds wysigings toelaat. Project Zero het opgemerk dat so 'n fout in `pmap_remove_options_internal()` in hul bypass uitgebuit is.
- Die PPL-grens is onherroeplik aan hardware-enforcement (APRR, memory controller), so dit is slegs so sterk soos die hardware-implementasie.

#### Example
<details>
<summary>Code Example</summary>
Hier is 'n vereenvoudigde pseudocode/logika wat wys hoe 'n kernel dalk in PPL kan aanroep om beskermde pages te wysig:
</details>
```c
// In kernel (outside PPL domain)
function kernel_modify_pptable(pt_addr, new_entry) {
// validate arguments, etc.
return ppl_call_modify(pt_addr, new_entry)  // call PPL wrapper
}

// In PPL (trusted domain)
function ppl_call_modify(pt_addr, new_entry) {
// temporarily enable write access to protected pages (via APRR adjustments)
aprr_set_index_for_write(PPL_INDEX)
// perform the modification
*pt_addr = new_entry
// restore permissions (make pages read-only again)
aprr_restore_default()
return success
}

// If kernel code outside PPL does:
*pt_addr = new_entry  // a direct write
// It will fault because APRR mapping for non-PPL domain disallows write to that page
```
Die kernel kan baie normale operasies uitvoer, maar slegs deur die `ppl_call_*` routines kan dit beskermde mappings verander of kode patch.
</details>

<details>
<summary>Example</summary>
'n kernel exploit probeer die entitlement table oorskryf, of code-sign afdwinging deaktiveer deur 'n kernel signature blob te wysig. Omdat daardie bladsy PPL-beskerm is, word die skryf geblokkeer tensy dit via die PPL-koppelvlak gaan. Selfs met kernel kode-uitvoering kan jy dus nie code-sign-beperkings omseil of credential data arbitrêr wysig nie.
Op iOS 17+ gebruik sekere toestelle SPTM om PPL-managed bladsye verder te isoleer.
</details>

#### PPL → SPTM / Replacements / Future

- On Apple’s modern SoCs (A15 or later, M2 or later), Apple supports **SPTM** (Secure Page Table Monitor), which **replaces PPL** for page table protections.
- Apple calls out in documentation: “Page Protection Layer (PPL) and Secure Page Table Monitor (SPTM) enforce execution of signed and trusted code … PPL manages the page table permission overrides … Secure Page Table Monitor replaces PPL on supported platforms.”
- Die SPTM-argitektuur skuif waarskynlik meer beleidstoepassing na 'n hoër-geprivilegieerde monitor buite kernelbeheer, wat die vertrouensgrens verder verminder.

### MTE | EMTE | MIE

Hier is 'n hoërvlak beskrywing van hoe EMTE onder Apple se MIE-opstelling werk:

1. **Tag assignment**
- Wanneer geheue toegeken word (bv. in kernel of user space via secure allocators), word 'n **geheime tag** aan daardie blok toegeken.
- Die pointer wat aan die gebruiker of kernel teruggegee word, sluit daardie tag in sy hoë bits in (met gebruik van TBI / top byte ignore mechanisms).

2. **Tag checking on access**
- Wanneer 'n load of store uitgevoer word met 'n pointer, kontroleer die hardware dat die pointer se tag ooreenstem met die geheueblok se tag (allocation tag). By wanpassing faal dit onmiddellik (aangesien dit synchronous is).
- Omdat dit synchronous is, is daar geen “delayed detection”-venster nie.

3. **Retagging on free / reuse**
- Wanneer geheue vrygestel word, verander die allocator die blok se tag (sodat ou pointers met ou tags nie meer ooreenstem nie).
- 'n use-after-free pointer sou dus 'n verouderde tag hê en by toegang nie ooreenstem nie.

4. **Neighbor-tag differentiation to catch overflows**
- Aangrensende toewysings kry verskillende tags. As 'n buffer overflow in die buurman se geheue oorloop, veroorsaak tag-wanpassing 'n fout.
- Dit is veral kragtig om klein overflows te vang wat 'n grens oorskry.

5. **Tag confidentiality enforcement**
- Apple moet verhoed dat tag-waardes being leaked (want as 'n aanvaller die tag leer, kan hulle pointers met korrekte tags skep).
- Hulle sluit beskermings in (microarchitectural / speculative controls) om side-channel leakage van tag-bits te vermy.

6. **Kernel and user-space integration**
- Apple gebruik EMTE nie net in user-space nie, maar ook in kernel / OS-kritiese komponente (om die kernel teen geheuekorruptie te beskerm).
- Die hardware/OS verseker dat tag-reëls geld selfs wanneer die kernel namens user space uitgevoer word.

<details>
<summary>Example</summary>
```
Allocate A = 0x1000, assign tag T1
Allocate B = 0x2000, assign tag T2

// pointer P points into A with tag T1
P = (T1 << 56) | 0x1000

// Valid store
*(P + offset) = value // tag T1 matches allocation → allowed

// Overflow attempt: P’ = P + size_of_A (into B region)
*(P' + delta) = value
→ pointer includes tag T1 but memory block has tag T2 → mismatch → fault

// Free A, allocator retags it to T3
free(A)

// Use-after-free:
*(P) = value
→ pointer still has old tag T1, memory region is now T3 → mismatch → fault
```
</details>

#### Beperkings & uitdagings

- **Intrablock overflows**: As overflow binne dieselfde allokasie bly (oorkruis nie die grens nie) en die tag bly dieselfde, vang tag mismatch dit nie.
- **Tag width limitation**: Slegs ŉ paar bits (bv. 4 bits, of ŉ klein domein) is beskikbaar vir die tag — beperkte naamruimte.
- **Side-channel leaks**: Indien tag bits via cache / speculative execution geleak kan word, kan ŉ aanvaller geldige tags leer en omseil. Apple se tag confidentiality enforcement is bedoel om dit te mitigate.
- **Performance overhead**: Tag checks by elke load/store voeg koste by; Apple moet die hardware optimaliseer om die overhead laag te hou.
- **Compatibility & fallback**: Op ouer hardware of dele wat EMTE nie ondersteun nie, moet daar ŉ fallback bestaan. Apple voer aan dat MIE slegs op toestelle met ondersteuning geaktiveer is.
- **Complex allocator logic**: Die allocator moet tags bestuur, retagging hanteer, grense belyn en mis-tag botsings vermy. Foute in allocator-logika kan kwesbaarhede ingevoer.
- **Mixed memory / hybrid areas**: Sekere geheue mag ongetag bly (legacy), wat interoperabiliteit moeiliker maak.
- **Speculative / transient attacks**: Soos met baie mikroargitektoniese beskermings, kan speculative execution of micro-op fusions kontroles tydelik omseil of tag bits leak.
- **Limited to supported regions**: Apple mag EMTE slegs in selektiewe, hoë-risiko areas (kernel, security-critical subsystems) afdwing, nie universeel nie.

---

## Key enhancements / differences compared to standard MTE

Hier is die verbeterings en veranderinge wat Apple beklemtoon:

| Kenmerk | Original MTE | EMTE (Apple’s enhanced) / MIE |
|---|---|---|
| **Check mode** | Ondersteun sinksroon en asinksroon modi. In async word tag mismatches later gerapporteer (vertraag) | Apple dring aan op **synchronous mode** standaard — tag mismatches word onmiddellik gevang, geen vertraging / race-windows toegestaan nie. |
| **Coverage of non-tagged memory** | Toegange tot nie-getagde geheue (bv. globals) mag in sommige implementasies kontroles omseil | EMTE vereis dat toegang vanaf ŉ getagde area na nie-getagde geheue ook tag-kennis valideer, wat dit moeiliker maak om te omseil deur toewysings te meng. |
| **Tag confidentiality / secrecy** | Tags mag waarneembaar wees of via side channels leaked wees | Apple voeg **Tag Confidentiality Enforcement** by, wat probeer om leakage van tag-waardes te voorkom (via spekulatiewe side-channels ens.). |
| **Allocator integration & retagging** | MTE laat baie van die allocator-logika aan sagteware oor | Apple se secure typed allocators (kalloc_type, xzone malloc, ens.) integreer met EMTE: wanneer geheue toegeken of vrygemaak word, word tags op fyn granulariteit bestuur. |
| **Always-on by default** | Op baie platforms is MTE opsioneel of standaard uit | Apple aktiveer EMTE / MIE standaard op ondersteunende hardware (bv. iPhone 17 / A19) vir kernel en baie user-processes. |

Omdat Apple beide die hardware en die sagteware-stapel beheer, kan dit EMTE styf afdwing, prestasie-valkuils vermy en side-channel gapings toemaak.

---

## How EMTE works in practice (Apple / MIE)

Hier is ŉ hoëvlak beskrywing van hoe EMTE onder Apple se MIE-opset werk:

1. **Tag assignment**
- Wanneer geheue toegeken word (bv. in kernel of user space via secure allocators), word ŉ **secret tag** aan daardie blok toegeken.
- Die pointer wat aan die gebruiker of kernel teruggegee word bevat daardie tag in sy hoë bits (met TBI / top byte ignore-meganismes).

2. **Tag checking on access**
- Wanneer ŉ load of store uitgevoer word met ŉ pointer, kontroleer die hardware dat die pointer se tag ooreenstem met die geheueblok se tag (allocation tag). Indien daar ŉ mismatch is, faal dit onmiddellik (aangesien sinksroon).
- Omdat dit sinksroon is, bestaan daar geen “vertraagde opsporing” venster nie.

3. **Retagging on free / reuse**
- Wanneer geheue vrygestel word, verander die allocator die blok se tag (sodat ou pointers met ou tags nie meer ooreenstem nie).
- ŉ use-after-free pointer sal dus ŉ stale tag hê en mismatch as dit gebruik word.

4. **Neighbor-tag differentiation to catch overflows**
- Nabygeleë toewysings word verskillende tags gegee. Indien ŉ buffer overflow in die buur se geheue mors, veroorsaak ŉ tag mismatch ŉ fout.
- Dit is veral kragtig om klein overflows wat grense kruis op te spoor.

5. **Tag confidentiality enforcement**
- Apple moet verhoed dat tag-waardes geleak word (want indien ŉ aanvaller die tag ken, kan hulle pointers saamstel met korrekte tags).
- Hulle sluit beskerming in (mikroargitektonies / spekulatiewe kontroles) om side-channel lekke van tag-bits te probeer voorkom.

6. **Kernel and user-space integration**
- Apple gebruik EMTE nie net in user-space nie, maar ook in kernel / OS-kritieke komponente (om die kernel teen geheue-korrupsie te beskerm).
- Die hardware/OS verseker dat tag-reëls toegepas word selfs wanneer die kernel namens user-space uitvoer.

Omdat EMTE in MIE ingebou is, gebruik Apple EMTE in sinksroontoestand oor sleutel-aanvalsvlakke, nie as opsionele of foutopsporingsmodus nie.

---

## Exception handling in XNU

Wanneer ŉ **exception** voorkom (bv. `EXC_BAD_ACCESS`, `EXC_BAD_INSTRUCTION`, `EXC_CRASH`, `EXC_ARM_PAC`, ens.), is die **Mach layer** van die XNU-kernel verantwoordelik om dit te onderskep voordat dit ŉ UNIX-styl **signal** (soos `SIGSEGV`, `SIGBUS`, `SIGILL`, ...) word.

Hierdie proses behels verskeie lae van exception-propagasie en hantering voordat dit by user space kom of na ŉ BSD-siniaal omskep word.

### Exception Flow (High-Level)

1.  **CPU triggers a synchronous exception** (bv. ongeldig pointer-dereference, PAC-failure, onwettige instruksie, ens.).

2.  **Low-level trap handler** hardloop (`trap.c`, `exception.c` in XNU source).

3.  Die trap handler roep **`exception_triage()`** aan, die kern van die Mach exception handling.

4.  `exception_triage()` besluit hoe om die exception te roeteer:

-   Eerstens na die **thread's exception port**.

-   Daarna na die **task's exception port**.

-   Daarna na die **host's exception port** (dikwels `launchd` of `ReportCrash`).

Indien geen van hierdie porte die exception hanteer nie, mag die kernel:

-   **Dit omskakel na ŉ BSD-siniaal** (vir user-space prosesse).

-   **Panic** (vir kernel-space exceptions).

### Core Function: `exception_triage()`

Die funksie `exception_triage()` stuur Mach-exceptions op die ketting van moontlike hanteerders totdat een dit hanteer of totdat dit uiteindelik fataal is. Dit is gedefinieer in `osfmk/kern/exception.c`.
```c
void exception_triage(exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt);
```
**Tipiese oproepvloei:**

`exception_triage()
└── exception_deliver()
├── exception_deliver_thread()
├── exception_deliver_task()
└── exception_deliver_host()`

As alles misluk → hanteer deur `bsd_exception()` → vertaal na 'n sein soos `SIGSEGV`.


### Uitsonderingsporte

Elke Mach-objek (thread, task, host) kan **uitsonderingsporte** registreer, waarheen uitsonderingsboodskappe gestuur word.

Hulle word deur die API gedefinieer:
```
task_set_exception_ports()
thread_set_exception_ports()
host_set_exception_ports()
```
Each exception port has:

-   A **mask** (watter exceptions dit wil ontvang)
-   A **port name** (Mach port om boodskappe te ontvang)
-   A **behavior** (hoe die kernel die boodskap stuur)
-   A **flavor** (watter thread state ingesluit word)


### Debuggers and Exception Handling

A **debugger** (bv. LLDB) stel 'n **exception port** op die teiken task of thread, gewoonlik deur `task_set_exception_ports()` te gebruik.

**Wanneer 'n exception plaasvind:**

-   Die Mach-boodskap word na die debugger-proses gestuur.
-   Die debugger kan besluit om die exception te **handle** (hervat, registers wysig, instruksie oorslaan) of dit nie te **handle** nie.
-   As die debugger dit nie handel nie, propagseer die exception na die volgende vlak (task → host).


### Flow of `EXC_BAD_ACCESS`

1.  Thread dereferences 'n ongeldig pointer → CPU gooi Data Abort.

2.  Kernel trap handler roep `exception_triage(EXC_BAD_ACCESS, ...)`.

3.  Boodskap gestuur na:

-   Thread port → (debugger kan breakpoint onderskep).

-   As debugger ignoreer → Task port → (process-level handler).

-   As dit geïgnoreer word → Host port (gewoonlik ReportCrash).

4.  As niemand dit hanteer nie → `bsd_exception()` vertaal dit na `SIGSEGV`.


### PAC Exceptions

Wanneer **Pointer Authentication** (PAC) misluk (handtekening kom nie ooreen nie), word 'n **spesiale Mach exception** geëmiteer:

-   **`EXC_ARM_PAC`** (type)
-   Codes kan besonderhede insluit (bv. sleuteltipe, pointertipe).

As die binary die vlag **`TFRO_PAC_EXC_FATAL`** het, hanteer die kernel PAC-foute as **fatal**, en omseil debugger-onderskeping. Dit is om te voorkom dat attackers debuggers gebruik om PAC-checks te omseil en dit is geaktiveer vir **platform binaries**.


### Software Breakpoints

'n Software breakpoint (`int3` op x86, `brk` op ARM64) word geïmplementeer deur **'n doelbewuste fout te veroorsaak**.\
Die debugger vang dit via die exception port:

-   Wysig die instruction pointer of geheue.
-   Herstel die oorspronklike instruksie.
-   Hervat uitvoering.

Dieselfde meganisme laat jou toe om 'n PAC exception te "catch" --- **tensy `TFRO_PAC_EXC_FATAL`** gestel is, in welke geval dit nooit by die debugger uitkom nie.


### Conversion to BSD Signals

As geen handler die exception aanvaar nie:

-   Kernel roep `task_exception_notify() → bsd_exception()`.

-   Dit map Mach-exceptions na seine:

| Mach Exception | Signal |
| --- | --- |
| EXC_BAD_ACCESS | SIGSEGV or SIGBUS |
| EXC_BAD_INSTRUCTION | SIGILL |
| EXC_ARITHMETIC | SIGFPE |
| EXC_SOFTWARE | SIGTRAP |
| EXC_BREAKPOINT | SIGTRAP |
| EXC_CRASH | SIGKILL |
| EXC_ARM_PAC | SIGILL (on non-fatal) |


### Key Files in XNU Source

-   `osfmk/kern/exception.c` → Kern van `exception_triage()`, `exception_deliver_*()`.

-   `bsd/kern/kern_sig.c` → Signal delivery logika.

-   `osfmk/arm64/trap.c` → Lae-vlak trap handlers.

-   `osfmk/mach/exc.h` → Exception codes en strukture.

-   `osfmk/kern/task.c` → Task exception port opstelling.

---

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

Die kernel het 'n **zone allocator** (`kalloc`) gebruik, verdeel in vaste-grootte "zones."
Elke sone berg slegs allocations van 'n enkele size class.

Uit die skermskoot:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Baie klein kernel structs, pointers.                                        |
| `default.kalloc.32`  | 32 bytes     | Klein structs, object headers.                                              |
| `default.kalloc.64`  | 64 bytes     | IPC messages, klein kernel buffers.                                         |
| `default.kalloc.128` | 128 bytes    | Medium objects soos dele van `OSObject`.                                    |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Groot strukture, IOSurface/graphics metadata.                               |

Hoe dit gewerk het:
- Elke allocation versoek is **opgerond** na die naaste zone-grootte.
(Byv., 'n 50-byte versoek beland in die `kalloc.64` sone).
- Geheue in elke sone is onderhou op 'n **freelist** — stukke wat deur die kernel vrygestel is, het teruggegaan na daardie sone.
- As jy 'n 64-byte buffer oorloop, sou jy die **volgende object in dieselfde sone** oorskryf.

Dit is waarom heap spraying / feng shui so effektief was: jy kon objek-naasteburen voorspel deur allocations van dieselfde size class te spuit.


### The freelist

Binne elke kalloc-sone is vrygestelde objects nie direk aan die stelsel teruggegee nie — hulle het in 'n freelist gegaan, 'n gekoppelde lys van beskikbare stukke.

- Wanneer 'n stuk vrygestel is, het die kernel 'n pointer by die begin van daardie stuk geskryf → die adres van die volgende gratis stuk in dieselfde sone.

- Die sone het 'n HEAD pointer na die eerste gratis stuk gehou.

- Allocation het altyd die huidige HEAD gebruik:

1. Pop HEAD (gee daardie geheue terug aan die caller).

2. Werk HEAD by = HEAD->next (gestoor in die vrygestelde stuk se header).

- Freeing het stukke teruggedruk:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

Dus was die freelist net 'n gekoppelde lys gebou binne die vrygestelde geheue self.

Normale toestand:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Uitbuiting van die freelist

Omdat die eerste 8 bytes van 'n free chunk die freelist pointer is, kan 'n aanvaller dit korrupteer:

1. **Heap overflow** in 'n aangrensende freed chunk → oorskryf sy “next” pointer.

2. **Use-after-free** skryf in 'n freed object → oorskryf sy “next” pointer.

Dan, by die volgende toewysing van daardie grootte:

- Die allocator haal die gekorrupte chunk uit die freelist.
- Volg die deur die aanvaller verskafde “next” pointer.
- Gee 'n pointer na arbitrêre geheue terug, waardeur fake object primitives of geteikende overwrite moontlik word.

Visuele voorbeeld van freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
This freelist-ontwerp het uitbuiting voor hardening baie effektief gemaak: voorspelbare bure van heap sprays, raw pointer freelist links, en geen tipe-segregasie wat aanvalers toegelaat het om UAF/overflow-bugs in arbitrêre kernel-geheuebeheer te eskaleer.

### Heap Grooming / Feng Shui
Die doel van heap grooming is om die heap-layout te **vorm** sodat wanneer ’n aanvaller ’n overflow of use-after-free trigger, die teiken (slagoffer) objek direk langs ’n aanvaller-beheerde objek sit.\
Op daardie manier kan die aanvaller betroubaar die slagoffer-objek met beheerdata oorskryf wanneer geheuekorruptie plaasvind.

**Stappe:**

1. Spray allocations (fill the holes)
- Mettertyd raak die kernel heap gefragmenteer: sommige zones het gapings waar ou
objects vrygestel is.
- Die aanvaller maak eers baie dummy-allocations om hierdie gaps te vul, sodat
die heap “gepak” en voorspelbaar word.

2. Force new pages
- Sodra die gapings gevul is, moet die volgende allocations vanaf nuwe bladsye
by die zone gevoeg word.
- Vars bladsye beteken dat objekke saamgegroepeer sal wees, nie oor ou
gefragmenteerde geheue versprei nie.
- Dit gee die aanvaller baie beter beheer oor bure.

3. Place attacker objects
- Die aanvaller spray nou weer en skep baie aanvaller-beheerde objekke
in daardie nuwe bladsye.
- Hierdie objekke is voorspelbaar in grootte en plasing (aangesien hulle almal
aan dieselfde zone behoort).

4. Free a controlled object (make a gap)
- Die aanvaller maak doelbewus een van hul eie objekke vry.
- Dit skep ’n “gat” in die heap, wat die allocator later sal hergebruik vir
die volgende allokasie van daardie grootte.

5. Victim object lands in the hole
- Die aanvaller trigger die kernel om die slagoffer-objek (die een wat hulle
wil korrupteer) te allokeer.
- Aangesien die gat die eerste beskikbare slot in die freelist is, word die slagoffer
presies geplaas waar die aanvaller hul objek vrygestel het.

6. Overflow / UAF into victim
- Nou het die aanvaller aanvaler-beheerde objekke rondom die slagoffer.
- Deur te overflow van een van hul eie objekke (of deur ’n vrygestelde een te hergebruik), kan hulle betroubaar die slagoffer se geheuevelde met gekose waardes oorskryf.

**Waarom dit werk**:

- Zone allocator predictability: allocations van dieselfde grootte kom altyd van
dieselfde zone.
- Freelist behavior: nuwe allocations hergebruik die mees onlangs vrygestelde chunk eerste.
- Heap sprays: die aanvaller vul geheue met voorspelbare inhoud en beheer die layout.
- Eindresultaat: die aanvaller beheer waar die slagoffer-objek land en watter data langs dit sit.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple het die allocator gehard en maak **heap grooming baie moeiliker**:

### 1. From Classic kalloc to kalloc_type
- **Before**: ’n enkele `kalloc.<size>` zone het bestaan vir elke grootteklas (16, 32, 64, … 1280, ens.). Enige objek van daardie grootte is daar geplaas → aanvaller-objekte kon langs bevoorregte kernel-objekte sit.
- **Now**:
- Kernel objekke word gealloceer uit **typed zones** (`kalloc_type`).
- Elke tipe objek (bv. `ipc_port_t`, `task_t`, `OSString`, `OSData`) het sy eie toegewyde zone, selfs al is hulle dieselfde grootte.
- Die mapping tussen objektipe ↔ zone word tydens compilering gegenereer deur die **kalloc_type system**.

’n Aanvaller kan nie meer waarborg dat beheerdata (`OSData`) langs sensitiewe kernel-objekte (`task_t`) van dieselfde grootte eindig nie.

### 2. Slabs and Per-CPU Caches
- Die heap is in **slabs** verdeel (bladsye geheue in vaste-grootte stukke vir daardie zone).
- Elke zone het ’n **per-CPU cache** om kontensie te verminder.
- Allocatiepad:
1. Probeer per-CPU cache.
2. As leeg, haal uit die global freelist.
3. As freelist leeg is, allokeer ’n nuwe slab (een of meer bladsye).
- **Voordeel**: Hierdie desentralisering maak heap sprays minder deterministies, aangesien allocations moontlik deur verskillende CPU’s se caches bevredig word.

### 3. Randomization inside zones
- Binne ’n zone word vrygemaakte elemente nie in eenvoudige FIFO/LIFO volgorde teruggegee nie.
- Moderne XNU gebruik **encoded freelist pointers** (safe-linking soos Linux, ingestel rondom iOS 14).
- Elke freelist pointer is **XOR-encoded** met ’n per-zone geheime cookie.
- Dit verhoed dat ’n aanvaller ’n vals freelist-pointer forgeer as hulle ’n write-primitive kry.
- Sommige allocations word **gerandomiseer in hul plasing binne ’n slab**, sodat spraying nie adjacency waarborg nie.

### 4. Guarded Allocations
- Sekere kritieke kernel-objekte (bv. credentials, task structures) word in **guarded zones** gealloceer.
- Hierdie zones voeg **guard pages** (onmapped geheue) tussen slabs in of gebruik **redzones** rondom objekke.
- Enige overflow in die guard page trigger ’n fout → onmiddellike panic in plaas van stil corruptie.

### 5. Page Protection Layer (PPL) and SPTM
- Selfs as jy ’n vrygestelde objek beheer, kan jy nie alle kernel-geheue wysig nie:
- **PPL (Page Protection Layer)** dwing af dat sekere streke (bv. code signing data, entitlements) **read-only** is selfs vir die kernel self.
- Op **A15/M2+ devices**, hierdie rol word vervang/versterk deur **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- Hierdie hardware-afgedwonge lae beteken dat aanvallers nie van ’n enkele heap-korruptie na arbitrêre patching van kritieke sekuriteitsstrukture kan eskaleer nie.
- **(Added / Enhanced)**: ook, **PAC (Pointer Authentication Codes)** word in die kernel gebruik om pointers (veral function pointers, vtables) te beskerm sodat hul forging of korrupsie moeiliker is.
- **(Added / Enhanced)**: zones kan **zone_require / zone enforcement** afdwing, d.w.s. dat ’n objek wat vrygestel is slegs via sy korrekte typed zone teruggegee kan word; ongeldige cross-zone frees kan panic of verwerp word. (Apple verwys hierna in hul memory safety poste)

### 6. Large Allocations
- Nie alle allocations gaan deur `kalloc_type` nie.
- Baie groot versoeke (bo ~16 KB) omseil typed zones en word direk uit **kernel VM (kmem)** via bladsy-allocations bedien.
- Hierdie is minder voorspelbaar, maar ook minder uitbuitbaar, aangesien hulle nie slabs met ander objekke deel nie.

### 7. Allocation Patterns Attackers Target
Selfs met hierdie beskermings soek aanvallers steeds na:
- **Reference count objects**: as jy retain/release tellers kan manipuleer, kan jy use-after-free veroorsaak.
- **Objects with function pointers (vtables)**: korruptering van een gee steeds control flow.
- **Shared memory objects (IOSurface, Mach ports)**: dit bly teikens omdat hulle user ↔ kernel oorbrug.

Maar — anders as voorheen — jy kan nie net `OSData` spray nie en verwag dat dit ’n `task_t` sal naastaan. Jy het nodig aan **type-specific bugs** of **info leaks** om te slaag.

### Example: Allocation Flow in Modern Heap

Stel userspace roep IOKit aan om ’n `OSData` object te allokeer:

1. **Type lookup** → `OSData` map na `kalloc_type_osdata` zone (grootte 64 bytes).
2. Check per-CPU cache vir vry elemente.
- As gevind → gee een terug.
- As leeg → gaan na global freelist.
- As freelist leeg → allokeer ’n nuwe slab (bladsy van 4KB → 64 chunks van 64 bytes).
3. Gee chunk terug aan caller.

**Freelist pointer protection**:
- Elke vrygemaakte chunk stoor die adres van die volgende vrye chunk, maar gekodeer met ’n geheime sleutel.
- Oorskrywing van daardie veld met aanvaller-data sal nie werk tensy jy die sleutel ken nie.

---

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages, and **PAC** protects pointers |
| Allocation reuse validation     | None (freelist pointers raw)                               | **zone_require / zone enforcement**             |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |
| Large allocations handling      | All small allocations managed equally                       | Large ones bypass zones → handled via VM         |

---

## Modern Userland Heap (iOS, macOS — type-aware / xzone malloc)

In onlangse Apple OS weergawes (veral iOS 17+), het Apple ’n meer veilige userland allocator bekendgestel, **xzone malloc** (XZM). Dit is die user-space analoog van die kernel se `kalloc_type`, wat tipe-bewustheid, metadata-isolasie, en memory tagging beskrywings toepas.

### Goals & Design Principles

- **Type segregation / type awareness**: groepeer allocations volgens *type of gebruik (pointer vs data)* om type confusion en cross-type reuse te voorkom.
- **Metadata isolation**: skei heap metadata (bv. free lists, size/state bits) van objekpayloads sodat out-of-bounds skrywes minder waarskynlik metadata korrupteer.
- **Guard pages / redzones**: voeg unmapped bladsye of padding rondom allocations in om overflows te vang.
- **Memory tagging (EMTE / MIE)**: werk saam met hardware tagging om use-after-free, out-of-bounds, en ongeldige toegang te ontdek.
- **Scalable performance**: handhaaf lae overhead, vermy oormatige fragmentasie, en ondersteun baie allocations per sekonde met lae latency.

### Architecture & Components

Hier is die hoofelemente in die xzone allocator:

#### Segment Groups & Zones

- **Segment groups** verdeel die adresruimte volgens gebruikskategorieë: bv. `data`, `pointer_xzones`, `data_large`, `pointer_large`.
- Elke segment group bevat **segments** (VM reekse) wat allocations vir daardie kategorie huisves.
- Geassosieer met elke segment is ’n **metadata slab** (afgesonderde VM area) wat metadata stoor (bv. free/used bits, size classes) vir daardie segment. Hierdie **out-of-line (OOL) metadata** verseker dat metadata nie deurmekaar met objekpayloads leef nie, wat korrupsie deur overflows verminder.
- Segmente word uitgekap in **chunks** (skywe) wat weer in **blocks** (allocasie-eenhede) verdeel is. ’n Chunk is gebind aan ’n spesifieke size class en segment group (d.w.s. al die blocks in ’n chunk deel dieselfde grootte & kategorie).
- Vir klein/midgrootte allocations gebruik dit vaste-grootte chunks; vir groot/húe kan dit afsonderlik map.

#### Chunks & Blocks

- ’n **chunk** is ’n streek (gewoonlik verskeie bladsye) toegewy aan allocations van een grootteklas binne ’n group.
- Binne ’n chunk is **blocks** slots beskikbaar vir allocations. Vrygemaakte blocks word via die metadata slab opgespoor — bv. via bitmaps of free lists gestoor out-of-line.
- Tussen chunks (of binne), mag daar **guard slices / guard pages** ingevoeg word (bv. unmapped slices) om out-of-bounds skrywes te vang.

#### Type / Type ID

- Elke allocasieterrein (of oproep na malloc, calloc, ens.) is geassosieer met ’n **type identifier** (’n `malloc_type_id_t`) wat kodeer watter soort objek gealloceer word. Daardie type ID word aan die allocator gegee, wat dit gebruik om te kies watter zone/segment die allocasie moet bedien.
- As gevolg hiervan kan twee allocations dieselfde grootte hê, maar heeltemal verskillende zones betree as hul tipes verskil.
- In vroeë iOS 17 weergawes was nie alle APIs (bv. CFAllocator) ten volle type-aware nie; Apple het sommige van daardie swakhede in iOS 18 aangespreek.

---

### Allocation & Freeing Workflow

Hier is ’n hoëvlak vloei van hoe allocasie en deallokasie in xzone werk:

1. **malloc / calloc / realloc / typed alloc** word aangeroep met ’n grootte en type ID.
2. Die allocator gebruik die **type ID** om die korrekte segment group / zone te kies.
3. Binne daardie zone/segment soek dit ’n chunk met vrye blocks van die versoekte grootte.
- Dit mag **local caches / per-thread pools** of **free block lists** uit die metadata raadpleeg.
- As geen vrye block beskikbaar is nie, kan dit ’n nuwe chunk in daardie zone allokeer.
4. Die metadata slab word opgedateer (free bit skoongemaak, bookkeeping).
5. As memory tagging (EMTE) in werking is, kry die teruggegewe block ’n **tag** toegewys en metadata word opgedateer om sy “live” status te wys.
6. Wanneer `free()` geroep word:
- Die block word in metadata as vry gemerk (via OOL slab).
- Die block kan in ’n free list geplaas of gepoel word vir hergebruik.
- Opsioneel kan block-inhoud uitgevee of vergif (poisoned) word om data leaks of use-after-free uitbuiting te verminder.
- Die hardware-tag geassosieer met die block kan ongeldig gemaak of her-getag word.
- As ’n hele chunk vry raak (alle blocks vry), kan die allocator daardie chunk **reclaim** (unmap of teruggee aan OS) onder geheue-pressuur.

---

### Security Features & Hardening

Hierdie is die verdediging wat in moderne userland xzone ingebou is:

| Feature | Purpose | Notes |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | Prevent overflow from corrupting metadata | Metadata lives in separate VM region (metadata slab)|
| **Guard pages / unmapped slices** | Catch out-of-bounds writes | Helps detect buffer overflows rather than silently corrupting adjacent blocks|
| **Type-based segregation** | Prevent cross-type reuse & type confusion | Even same-size allocations from different types go to different zones|
| **Memory Tagging (EMTE / MIE)** | Detect invalid access, stale references, OOB, UAF | xzone works in concert with hardware EMTE in synchronous mode (“Memory Integrity Enforcement”)|
| **Delayed reuse / poisoning / zap** | Reduce chance of use-after-free exploitation | Freed blocks may be poisoned, zeroed, or quarantined before reuse |
| **Chunk reclamation / dynamic unmapping** | Reduce memory waste and fragmentation | Entire chunks may be unmapped when unused |
| **Randomization / placement variation** | Prevent deterministic adjacency | Blocks in a chunk and chunk selection may have randomized aspects |
| **Segregation of “data-only” allocations** | Separate allocations that don’t store pointers | Reduces attacker control over metadata or control fields|

---

### Interaction with Memory Integrity Enforcement (MIE / EMTE)

- Apple se MIE (Memory Integrity Enforcement) is die hardware + OS raamwerk wat **Enhanced Memory Tagging Extension (EMTE)** in altyd-aan, sinchrone modus oor hoof-aanvalsoppervlakke bring.
- Die xzone allocator is ’n fundamentele basis van MIE in user space: allocations wat via xzone gedoen word kry tags, en toegang word deur hardware nagegaan.
- In MIE word die allocator, tag-toekenning, metadata-bestuur, en tag-geheimhouding saamgevoeg om te verseker dat geheuefoute (bv. stale reads, OOB, UAF) onmiddellik gevang word en nie later uitgebuit word nie.

---

As jy wil, kan ek ook ’n cheat-sheet of diagram van xzone-internals vir jou boek genereer. Wil jy dat ek dit volgende doen?
::contentReference[oai:20]{index=20}


---

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and installeer dit.

Open Ghidra with `ghidraRun` and gaan na `File` --> `Install Extensions`, druk die add-knoppie en selekteer die pad `/Applications/BinDiff/Extra/Ghidra/BinExport` en klik OK en installeer dit selfs al is daar ’n weergawe-ontroulikheid.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
