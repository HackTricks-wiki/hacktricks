# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

- **Code Signing** in iOS works by requiring every piece of executable code (apps, libraries, extensions, etc.) to be cryptographically signed with a certificate issued by Apple. When code is loaded, iOS verifies the digital signature against Apple’s trusted root. If the signature is invalid, missing, or modified, the OS refuses to run it. This prevents attackers from injecting malicious code into legitimate apps or running unsigned binaries, effectively stopping most exploit chains that rely on executing arbitrary or tampered code.
- **CoreTrust** is the iOS subsystem responsible for enforcing code signing at runtime. It directly verifies signatures using Apple’s root certificate without relying on cached trust stores, meaning only binaries signed by Apple (or with valid entitlements) can execute. CoreTrust ensures that even if an attacker tampers with an app after installation, modifies system libraries, or tries to load unsigned code, the system will block execution unless the code is still properly signed. This strict enforcement closes many post-exploitation vectors that older iOS versions allowed through weaker or bypassable signature checks.
- **Data Execution Prevention (DEP)** 将内存区域标记为不可执行，除非该区域显式包含代码。这样可以阻止攻击者在数据区（例如 stack 或 heap）注入 shellcode 并运行，迫使他们依赖更复杂的技术，比如 ROP（Return-Oriented Programming）。
- **ASLR (Address Space Layout Randomization)** 每次系统运行时随机化代码、库、stack 和 heap 的内存地址布局。这样攻击者就很难预测有用指令或 gadgets 的位置，破坏了许多依赖固定内存布局的利用链。
- **KASLR (Kernel ASLR)** 将相同的随机化概念应用到 iOS kernel。通过在每次启动时打乱 kernel 的基址，阻止攻击者可靠地定位 kernel 函数或结构，从而增加了内核级 exploit 的难度。
- **Kernel Patch Protection (KPP)**（在 iOS 中也称为 **AMCC (Apple Mobile File Integrity)**）持续监控 kernel 的代码页以确保它们未被修改。如果检测到篡改——例如尝试 patch kernel 函数或插入恶意代码——设备会立即 panic 并重启。此保护使得持久性的内核利用更加困难，因为攻击者不能简单地 hook 或 patch kernel 指令而不触发系统崩溃。
- **Kernel Text Readonly Region (KTRR)** 是在 iOS 设备上引入的基于硬件的安全功能。它使用 CPU 的内存控制器在启动后将 kernel 的代码（text）段标记为永久只读。锁定后，即使是 kernel 自身也无法修改该内存区域。这阻止了攻击者（甚至有特权的代码）在运行时 patch kernel 指令，封堵了依赖直接修改 kernel 代码的主要利用方式。
- **Pointer Authentication Codes (PAC)** 在指针的未使用位中嵌入加密签名以在使用前验证其完整性。当创建指针（如返回地址或函数指针）时，CPU 使用秘密密钥对其签名；在取消引用之前，CPU 会检查该签名。如果指针被篡改，检查失败并停止执行。这阻止了攻击者在内存损坏利用中伪造或重用损坏的指针，使得像 ROP 或 JOP 的技术更难可靠完成。
- **Privilege Access never (PAN)** 是一项硬件特性，防止 kernel（特权模式）在未显式启用访问的情况下直接访问 user-space 内存。这阻止了即使获得 kernel 代码执行的攻击者也能轻易读取或写入用户内存以升级利用或窃取敏感数据。通过强制严格的隔离，PAN 降低了 kernel exploit 的影响并阻止了许多常见的权限提升技术。
- **Page Protection Layer (PPL)** 是 iOS 的一项安全机制，用于保护关键的由 kernel 管理的内存区域，尤其是与 code signing 和 entitlements 相关的区域。它使用 MMU 和额外检查强制严格的写保护，确保即使是有特权的 kernel 代码也不能任意修改敏感页。这阻止了获得内核级执行权限的攻击者篡改安全关键结构，使得持久化和绕过 code-signing 更加困难。

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

The kernel used a **zone allocator** (`kalloc`) divided into fixed-size "zones."
Each zone only stores allocations of a single size class.

From the screenshot:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | 非常小的 kernel structs、pointers。                                           |
| `default.kalloc.32`  | 32 bytes     | 小型 structs、object headers。                                               |
| `default.kalloc.64`  | 64 bytes     | IPC messages、微小的 kernel buffers。                                         |
| `default.kalloc.128` | 128 bytes    | 中等对象，例如 `OSObject` 的部分。                                           |
| `default.kalloc.256` | 256 bytes    | 更大的 IPC messages、数组、device structures。                                |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | 大型结构体、IOSurface/graphics metadata。                                    |

**How it worked:**
- Each allocation request gets **rounded up** to the nearest zone size.
(E.g., a 50-byte request lands in the `kalloc.64` zone).
- Memory in each zone was kept in a **free list** — chunks freed by the kernel went back into that zone.
- If you overflowed a 64-byte buffer, you’d overwrite the **next object in the same zone**.

This is why **heap spraying / feng shui** was so effective: you could predict object neighbors by spraying allocations of the same size class.

### The freelist

Inside each kalloc zone, freed objects weren’t returned directly to the system — they went into a freelist, a linked list of available chunks.

- When a chunk was freed, the kernel wrote a pointer at the start of that chunk → the address of the next free chunk in the same zone.

- The zone kept a HEAD pointer to the first free chunk.

- Allocation always used the current HEAD:

1. Pop HEAD (return that memory to the caller).

2. Update HEAD = HEAD->next (stored in the freed chunk’s header).

- Freeing pushed chunks back:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

So the freelist was just a linked list built inside the freed memory itself.

Normal state:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### 利用 freelist

因为 free chunk 的前 8 字节 = freelist pointer，攻击者可以破坏它：

1. **Heap overflow** 写入到相邻的 freed chunk → 覆盖其 “next” pointer。
2. **Use-after-free** 往 freed object 写入 → 覆盖其 “next” pointer。

然后，在下一次分配相同大小时：

- allocator 会 pop 被破坏的 chunk。
- 遵循攻击者提供的 “next” pointer。
- 返回指向任意内存的指针，从而实现 fake object primitives 或定向 overwrite。

freelist poisoning 的可视化示例：
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
This freelist 设计在强化之前使利用非常有效：来自 heap sprays 的可预测邻居、原始指针 freelist 链接，以及缺乏类型分离，允许攻击者将 UAF/overflow 漏洞升级为对任意 kernel memory 的控制。

### Heap Grooming / Feng Shui
The goal of heap grooming is to **shape the heap layout** so that when an attacker triggers an overflow or use-after-free, the target (victim) object sits right next to an attacker-controlled object.\
这样，当发生内存损坏时，攻击者可以可靠地用受控数据覆盖受害对象。

**Steps:**

1. Spray allocations (fill the holes)
- 随着时间推移，kernel heap 会碎片化：某些 zone 出现旧对象被释放后留下的空洞。
- 攻击者首先进行大量占位分配以填满这些空隙，使堆变得“紧凑”且可预测。

2. Force new pages
- 一旦空洞被填满，下一波分配必须来自添加到该 zone 的新页面。
- 新页面意味着对象会被聚集在一起，而不是分散在老的碎片化内存中。
- 这使攻击者对邻居对象的控制大大提高。

3. Place attacker objects
- 攻击者再次进行喷洒，在那些新页面中创建大量受控对象。
- 这些对象在大小和位置上是可预测的（因为它们都属于同一个 zone）。

4. Free a controlled object (make a gap)
- 攻击者有意释放他们自己的某个对象。
- 这会在堆中创建一个“洞”，分配器会在以后重用该大小的下一个分配时使用该洞。

5. Victim object lands in the hole
- 攻击者触发内核分配受害对象（他们想要破坏的对象）。
- 由于该洞是 freelist 中第一个可用插槽，受害对象就会被放在攻击者之前释放对象的位置。

6. Overflow / UAF into victim
- 现在攻击者在受害对象周围拥有受控对象。
- 通过从自己的对象溢出（或重用已释放对象），他们可以可靠地用选定值覆盖受害者的内存字段。

**Why it works**:

- Zone allocator predictability：相同大小的分配总是来自同一个 zone。
- Freelist behavior：新的分配优先重用最近释放的 chunk。
- Heap sprays：攻击者用可预测的内容填充内存并控制布局。
- 最终结果：攻击者控制受害对象落在哪里以及它旁边放着什么数据。

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple 加固了分配器，使得 **heap grooming much harder**：

### 1. From Classic kalloc to kalloc_type
- **Before**: 每个大小类（16、32、64、… 1280 等）只有一个 `kalloc.<size>` zone。任何该大小的对象都会被放在那里 → 攻击者的对象可以与特权内核对象并排放置。
- **Now**:
- Kernel objects 从 **typed zones**（`kalloc_type`）中分配。
- 每种类型的对象（例如 `ipc_port_t`、`task_t`、`OSString`、`OSData`）都有自己的专用 zone，即使它们大小相同。
- 对象类型 ↔ zone 之间的映射在编译时由 **kalloc_type system** 生成。

攻击者不能再保证受控数据（`OSData`）会紧邻敏感内核对象（`task_t`）出现。

### 2. Slabs and Per-CPU Caches
- 堆被划分为 **slabs**（为该 zone 切分成固定大小块的内存页）。
- 每个 zone 有一个 **per-CPU cache** 以减少争用。
- 分配路径：
1. 尝试从 per-CPU cache。
2. 如果为空，从全局 freelist 拉取。
3. 如果 freelist 为空，分配新的 slab（一个或多个页面）。
- **好处**：这种去中心化使得 heap sprays 不那么确定性，因为分配可能由不同 CPU 的缓存来满足。

### 3. Randomization inside zones
- 在 zone 内，释放的元素不会按简单的 FIFO/LIFO 顺序返回。
- 现代 XNU 使用 **encoded freelist pointers**（类似 Linux 的 safe-linking，大约在 iOS 14 引入）。
- 每个 freelist 指针都用每个 zone 的 secret cookie 进行 **XOR 编码**。
- 这阻止攻击者在获得写原语后伪造假的 freelist 指针。
- 有些分配在 slab 内的位置也会被 **随机化**，因此喷洒不能保证相邻性。

### 4. Guarded Allocations
- 某些关键内核对象（例如 credentials、task 结构）在 **guarded zones** 中分配。
- 这些 zones 在 slab 之间插入 **guard pages**（未映射内存）或在对象周围使用 **redzones**。
- 任何溢出到 guard page 都会触发 fault → 立即 panic 而不是静默破坏。

### 5. Page Protection Layer (PPL) and SPTM
- 即使你控制了一个已释放对象，也不能修改内核内所有内存：
- **PPL (Page Protection Layer)** 强制某些区域（例如 code signing 数据、entitlements）即使对内核本身也是 **只读**。
- 在 **A15/M2+ devices** 上，这一角色被 **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)** 所替代/增强。
- 这些硬件强制的层意味着攻击者无法从单一的 heap 损坏升级到对关键安全结构的任意修补。

### 6. Large Allocations
- 并非所有分配都通过 `kalloc_type`。
- 非常大的请求（超过约 ~16KB）会绕过 typed zones，直接通过页面分配从 **kernel VM (kmem)** 提供。
- 这些分配可预测性较差，但也较难利用，因为它们不会与其他对象共享 slab。

### 7. Allocation Patterns Attackers Target
即便有这些保护，攻击者仍然寻找：
- **Reference count objects**：如果你能篡改 retain/release 计数，可能会导致 use-after-free。
- **Objects with function pointers (vtables)**：破坏其中一个仍然可以获得控制流。
- **Shared memory objects (IOSurface, Mach ports)**：这些仍然是攻击目标，因为它们桥接 user ↔ kernel。

但——与以前不同——你不能只喷洒 `OSData` 并指望它与 `task_t` 相邻。你需要 **type-specific bugs** 或 **info leaks** 才能成功。

### Example: Allocation Flow in Modern Heap

Suppose userspace calls into IOKit to allocate an `OSData` object:

1. **Type lookup** → `OSData` maps to `kalloc_type_osdata` zone (size 64 bytes).
2. Check per-CPU cache for free elements.
- If found → return one.
- If empty → go to global freelist.
- If freelist empty → allocate a new slab (page of 4KB → 64 chunks of 64 bytes).
3. Return chunk to caller.

**Freelist pointer protection**:
- 每个被释放的 chunk 存储下一个空闲 chunk 的地址，但该地址已用一个秘密 key 进行了编码。
- 用攻击者数据覆盖该字段不会生效，除非你知道该 key。

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages   |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and 安装 it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


{{#include ../../banners/hacktricks-training.md}}
