# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

- **Code Signing** in iOS radi tako što zahteva da svaki deo izvršnog koda (apps, libraries, extensions, etc.) bude kriptografski potpisan sertifikatom izdatim od strane Apple-a. Kada se kod učitava, iOS verifikuje digitalni potpis u odnosu na Apple-ov trusted root. Ako je potpis nevažeći, nedostaje ili je izmenjen, OS odbija njegovo pokretanje. Ovo sprečava napadače da injektuju maliciozni kod u legitimne aplikacije ili pokreću unsigned binarije, efektivno zaustavljajući većinu exploit lanaca koji se oslanjaju na izvršavanje proizvoljnog ili izmenjenog koda.
- **CoreTrust** je iOS subsistem odgovoran za sprovođenje code signing-a u runtime-u. On direktno verifikuje potpise koristeći Apple-ov root sertifikat bez oslanjanja na keširane trust store-ove, što znači da samo binariji potpisani od strane Apple-a (ili sa validnim entitlements) mogu da se izvrše. CoreTrust osigurava da čak i ako napadač manipuliše aplikacijom nakon instalacije, modifikuje sistemske biblioteke ili pokuša da učita unsigned kod, sistem će blokirati izvršenje osim ako kod nije pravilno potpisan. Ovo strogo sprovođenje zatvara mnoge post-exploitation vektore koje su starije iOS verzije omogućavale kroz slabije ili zaobilažive provere potpisa.
- **Data Execution Prevention (DEP)** označava regiona memorije kao non-executable osim ako jasno ne sadrže kod. Ovo sprečava napadače da injektuju shellcode u data regions (like the stack or heap) i pokrenu ga, prisiljavajući ih da koriste kompleksnije tehnike kao što su ROP (Return-Oriented Programming).
- **ASLR (Address Space Layout Randomization)** nasumično postavlja memorijske adrese koda, biblioteka, stack-a i heap-a pri svakom pokretanju sistema. Ovo otežava napadačima da predvide gde se nalaze korisne instrukcije ili gadgets, čime se razbijaju mnogi exploit lanci koji zavise od fiksne memorijske raspodele.
- **KASLR (Kernel ASLR)** primenjuje isti koncept randomizacije na iOS kernel. Mešanjem kernel base adrese pri svakom boot-u, on onemogućava napadačima da pouzdano lociraju kernel funkcije ili strukture, što povećava težinu kernel-level exploit-a koji bi inače stekli potpuni sistemski kontrol.
- **Kernel Patch Protection (KPP)**, takođe poznat kao **AMCC (Apple Mobile File Integrity)** u iOS-u, kontinuirano nadgleda kernel code pages kako bi osigurao da nisu modifikovane. Ako se detektuje bilo kakva manipulacija—kao što je exploit koji pokušava da patch-uje kernel funkcije ili ubaci maliciozni kod—uređaj će odmah panic-ovati i reboot-ovati. Ova zaštita čini persistent kernel exploit-e znatno težim, jer napadači ne mogu jednostavno hook-ovati ili patch-ovati kernel instrukcije bez izazivanja sistemskog pada.
- **Kernel Text Readonly Region (KTRR)** je hardverska sigurnosna funkcija uvedena na iOS uređajima. Koristi CPU-ov memory controller da označi kernel-ov code (text) segment kao trajno read-only nakon boot-a. Jednom zaključan, čak ni kernel sam ne može modifikovati tu memorijsku oblast. Ovo sprečava napadače—i čak privilegovan kod—from patch-ovanja kernel instrukcija u runtime-u, zatvarajući veliki klasu exploit-a koji su zavisili od direktne izmene kernel koda.
- **Pointer Authentication Codes (PAC)** koriste kriptografske potpise ugrađene u neiskorišćene bitove pointera kako bi verifikovali njihovu integritet pre upotrebe. Kada se pointer (npr. return address ili function pointer) kreira, CPU ga potpisuje sa tajnim ključem; pre dereferenciranja, CPU proverava potpis. Ako je pointer bio manipulisан, provera ne uspeva i izvršenje se zaustavlja. Ovo sprečava napadače da falsifikuju ili ponovo upotrebe korumpirane pointere u memory corruption exploit-ima, otežavajući tehnike poput ROP ili JOP.
- **Privilege Access never (PAN)** je hardverska funkcija koja sprečava kernel (privileged mode) da direktno pristupi user-space memoriji osim ako eksplicitno ne omogući pristup. Ovo onemogućava napadačima koji su dobili kernel code execution da lako čitaju ili pišu user memory radi eskalacije ili krađe osetljivih podataka. Strogo sprovođenje separacije smanjuje uticaj kernel exploit-a i blokira mnoge uobičajene privilege-escalation tehnike.
- **Page Protection Layer (PPL)** je iOS sigurnosni mehanizam koji štiti kritične kernel-managed memorijske regione, naročito one vezane za code signing i entitlements. On sprovodi stroga write protections koristeći MMU (Memory Management Unit) i dodatne provere, osiguravajući da čak ni privilegovan kernel kod ne može proizvoljno modifikovati osetljive stranice. Ovo sprečava napadače koji steknu kernel-level execution da manipulišu security-critical strukturama, čineći persistence i code-signing bypass-e znatno težim.

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

Kernel je koristio **zone allocator** (`kalloc`) podeljen u fiksne "zone".
Svaka zona skladišti alokacije samo jedne veličinske klase.

From the screenshot:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Very small kernel structs, pointers.                                        |
| `default.kalloc.32`  | 32 bytes     | Small structs, object headers.                                              |
| `default.kalloc.64`  | 64 bytes     | IPC messages, tiny kernel buffers.                                          |
| `default.kalloc.128` | 128 bytes    | Medium objects like parts of `OSObject`.                                    |
| `default.kalloc.256` | 256 bytes    | Larger IPC messages, arrays, device structures.                             |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Large structures, IOSurface/graphics metadata.                              |

Kako je radilo:
- Svaki zahtev za alokacijom se **zaokruži nagore** do najbliže zone veličine.
(Na primer, zahtev od 50 bajtova će završiti u `kalloc.64` zoni).
- Memorija u svakoj zoni se održavala u **freelist-u** — chunk-ovi koje je kernel oslobodio vraćali su se u tu zonu.
- Ako bi prelioš (overflow) buffer od 64 bajta, prebrisali biste **sledeći objekat u istoj zoni**.

Zbog toga su bile tako efikasne tehnike kao što su **heap spraying / feng shui**: moglo se predvideti susedstvo objekata tako što se raspršivale alokacije iste veličinske klase.

### The freelist

Unutar svake kalloc zone, oslobođeni objekti se nisu vraćali direktno sistemu — oni su išli u freelist, povezan list dostupnih chunk-ova.

- Kada bi chunk bio oslobođen, kernel bi upisao pointer na početak tog chunka → adresu sledećeg slobodnog chunka u istoj zoni.

- Zona je držala HEAD pointer na prvi slobodan chunk.

- Alokacija je uvek koristila trenutni HEAD:

1. Pop HEAD (vrati tu memoriju pozivaocu).

2. Update HEAD = HEAD->next (čuvano u header-u oslobođenog chunka).

- Freeing je gurala chunke nazad:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

Dakle, freelist je bio samo povezan list izgrađen unutar same oslobođene memorije.

Normalno stanje:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Eksploatisanje freelist-a

Pošto prvih 8 bajtova slobodnog chunk-a predstavljaju freelist pokazivač, napadač ga može korumpirati:

1. **Heap overflow** u susedni oslobođeni chunk → prepiše njegov “next” pointer.

2. **Use-after-free** upis u oslobođeni objekat → prepiše njegov “next” pointer.

Zatim, pri sledećoj alokaciji te veličine:

- Alokator izbaci korumpirani chunk.

- Prati “next” pointer koji je napadač postavio.

- Vraća pokazivač na proizvoljnu memoriju, omogućavajući fake object primitives ili targeted overwrite.

Vizuelni primer freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
Ovaj dizajn freelist je pre hardening-a činio eksploataciju izuzetno efikasnom: predvidivi susedi iz heap sprays, raw pointer freelist links i odsustvo razdvajanja tipova dozvoljavali su napadačima da eskaliraju UAF/overflow greške u arbitrarno upravljanje kernel memorijom.

### Heap Grooming / Feng Shui
Cilj Heap Grooming je da **oblikuje raspored heapa** tako da kada napadač izazove overflow ili use-after-free, ciljni (victim) objekat bude tačno pored objekta kojim napadač kontroliše. Na taj način, kada dođe do korupcije memorije, napadač može pouzdano prepisati victim objekat kontrolisanim podacima.

**Koraci:**

1. Spray allocations (fill the holes)
- Vremenom se kernel heap fragmentiše: neke zone imaju “rupe” gde su stari objekti oslobođeni.
- Napadač prvo pravi mnogo dummy allocations da popuni te praznine, tako da heap postane “packed” i predvidiv.

2. Force new pages
- Kada su rupe popunjene, sledeće alokacije moraju doći iz novih stranica dodatih u zonu.
- Sveže stranice znače da će objekti biti grupisani zajedno, a ne rasuti po staroj fragmentiranoj memoriji.
- To daje napadaču znatno bolju kontrolu nad susedima.

3. Place attacker objects
- Napadač ponovo radi spray, kreirajući mnogo attacker-controlled objekata u tim novim stranicama.
- Ti objekti su predvidivi po veličini i položaju (pošto svi pripadaju istoj zoni).

4. Free a controlled object (make a gap)
- Napadač namerno oslobodi jedan od svojih objekata.
- To stvara “rupu” u heapu koju će allocator kasnije ponovo upotrebiti za sledeću alokaciju te veličine.

5. Victim object lands in the hole
- Napadač izazove kernel da alocira victim objekat (onaj koji želi da korumpira).
- Pošto je rupa prvi dostupan slot u freelist, victim će biti smešten tačno tamo gde je napadač oslobodio svoj objekat.

6. Overflow / UAF into victim
- Sada napadač ima attacker-controlled objekte oko victima.
- Overflow-ovanjem iz jednog od svojih objekata (ili ponovnim korišćenjem oslobođenog) može pouzdano prepisati polja victim-ovog objekta sa izabranim vrednostima.

**Zašto ovo radi**:

- Predvidivost Zone allocator-a: alokacije iste veličine uvek dolaze iz iste zone.
- Freelist ponašanje: nove alokacije ponovo koriste najskorije oslobođen chunk prvi.
- Heap sprays: napadač puni memoriju predvidljivim sadržajem i kontroliše raspored.
- Krajnji rezultat: napadač kontroliše gde victim objekat bude i koji podaci su pored njega.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple je ojačao allocator i učinio **heap grooming mnogo težim**:

### 1. From Classic kalloc to kalloc_type
- **Pre**: postojala je jedna `kalloc.<size>` zona za svaku veličinsku klasu (16, 32, 64, … 1280, itd.). Bilo koji objekat te veličine je bio smešten tamo → attacker objekti su mogli sedeti pored privilegovanih kernel objekata.
- **Sada**:
- Kernel objekti se alociraju iz **typed zones** (`kalloc_type`).
- Svaka vrsta objekta (npr. `ipc_port_t`, `task_t`, `OSString`, `OSData`) ima svoju posvećenu zonu, čak i ako su iste veličine.
- Mapiranje između tip objekta ↔ zone se generiše iz **kalloc_type sistema** pri kompajliranju.

Napadač više ne može garantovati da će kontrolisani podaci (`OSData`) završiti pored osetljivih kernel objekata (`task_t`) iste veličine.

### 2. Slabs and Per-CPU Caches
- Heap je podeljen na **slabs** (stranice memorije isečene na chunk-ove fiksne veličine za tu zonu).
- Svaka zona ima **per-CPU cache** da bi se smanjila contentiona.
- Putanja alokacije:
1. Pokušaj per-CPU cache.
2. Ako je prazna, uzmi iz global freelist-a.
3. Ako je freelist prazan, alociraj novi slab (jednu ili više stranica).
- **Prednost**: ova decentralizacija čini heap sprays manje determinističkim, pošto alokacije mogu biti zadovoljene iz keševa različitih CPU-a.

### 3. Randomization inside zones
- Unutar zone, oslobođeni elementi se ne vraćaju jednostavnim FIFO/LIFO redosledom.
- Moderni XNU koristi **encoded freelist pointers** (safe-linking like Linux, uvedeno oko iOS 14).
- Svaki freelist pointer je **XOR-ovan** sa per-zone tajnim cookie-jem.
- Ovo sprečava napadače da falsifikuju lažni freelist pointer ako dobiju write primitive.
- Neke alokacije su **randomizovane u svom položaju unutar slaba**, tako da spray ne garantuje susedstvo.

### 4. Guarded Allocations
- Određeni kritični kernel objekti (npr. credentials, task strukture) se alociraju u **guarded zones**.
- Ove zone ubacuju **guard pages** (nemapiranu memoriju) između slabs ili koriste **redzones** oko objekata.
- Bilo koji overflow u guard page izaziva fault → neposredan panic umesto tihi korupcije.

### 5. Page Protection Layer (PPL) and SPTM
- Čak i ako kontrolišete oslobođeni objekat, ne možete modifikovati svu kernel memoriju:
- **PPL (Page Protection Layer)** nameće da određeni regioni (npr. code signing data, entitlements) budu **read-only** čak i za sam kernel.
- Na **A15/M2+ uređajima**, ovu ulogu zamenjuju/pojačavaju **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- Ovi hardware-enforced slojevi znače da napadači ne mogu eskalirati iz jedne heap korupcije u arbitrarno patch-ovanje kritičnih sigurnosnih struktura.

### 6. Large Allocations
- Nisu sve alokacije kroz `kalloc_type`.
- Vrlo velike zahteve (iznad ~16KB) zaobilaze typed zones i služe se direktno iz **kernel VM (kmem)** putem page alokacija.
- One su manje predvidive, ali i manje iskoristive, jer ne dele slabe sa drugim objektima.

### 7. Allocation Patterns Attackers Target
Čak i sa ovim zaštitama, napadači i dalje traže:
- **Reference count objects**: ako možete manipulisati retain/release brojačima, možete izazvati use-after-free.
- **Objects with function pointers (vtables)**: korumpiranje jednog i dalje daje kontrolu toka izvršavanja.
- **Shared memory objects (IOSurface, Mach ports)**: i dalje su cilj jer povezuju user ↔ kernel.

Ali — za razliku od pre — ne možete samo spray-ovati `OSData` i očekivati da bude pored `task_t`. Potreban vam je **type-specific bug** ili **info leak** da biste uspeli.

### Example: Allocation Flow in Modern Heap

Pretpostavimo da userspace poziva IOKit da alocira `OSData` objekat:

1. **Type lookup** → `OSData` mapira na `kalloc_type_osdata` zonu (size 64 bytes).
2. Provera per-CPU cache za slobodne elemente.
- Ako nađen → vrati jedan.
- Ako je prazan → idi na global freelist.
- Ako je freelist prazan → alociraj novi slab (stranica od 4KB → 64 chunk-a od 64 bajta).
3. Vrati chunk pozivaocu.

**Freelist pointer protection**:
- Svaki oslobođeni chunk čuva adresu sledećeg slobodnog chunka, ali enkodiranu sa tajnim ključem.
- Prepisivanje tog polja napadačkim podacima neće raditi osim ako ne znate ključ.

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages   |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Preuzmite BinDiff DMG sa [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) i instalirajte ga.

Otvorte Ghidra pomoću `ghidraRun` i idite na `File` --> `Install Extensions`, pritisnite dugme za dodavanje i izaberite putanju `/Applications/BinDiff/Extra/Ghidra/BinExport` i kliknite OK i install-ujte ga čak i ako postoji neusklađenost verzija.

### Using BinDiff with Kernel versions

1. Idite na stranicu [https://ipsw.me/](https://ipsw.me/) i preuzmite iOS verzije koje želite da diff-ujete. To će biti `.ipsw` fajlovi.
2. Decompress-ujte dok ne dobijete bin format kernelcache-a obe `.ipsw` datoteke. Informacije o tome kako to uraditi imate na:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Otvorite Ghidra sa `ghidraRun`, kreirajte novi projekat i učitajte kernelcaches.
4. Otvorite svaki kernelcache da budu automatski analizirani od strane Ghidra-e.
5. Zatim, u Project Window-u Ghidra-e, desni klik na svaki kernelcache, izaberite `Export`, izaberite format `Binary BinExport (v2) for BinDiff` i eksportujte ih.
6. Otvorite BinDiff, kreirajte novi workspace i dodajte novi diff označivši kao primary file kernelcache koji sadrži ranjivost, a kao secondary file patched kernelcache.

---

## Finding the right XNU version

Ako želite da proverite ranjivosti u određenoj verziji iOS-a, možete proveriti koju XNU release verziju ta iOS verzija koristi na [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

Na primer, verzije `15.1 RC`, `15.1` i `15.1.1` koriste verziju `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.

{{#include ../../banners/hacktricks-training.md}}
