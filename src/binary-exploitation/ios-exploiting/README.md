# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

### 1. **Code Signing** / Runtime Signature Verification
**Introduced early (iPhone OS → iOS)**
Hii ni moja ya kinga za msingi: **all executable code** (apps, dynamic libraries, JIT-ed code, extensions, frameworks, caches) lazima isainiwe kwa kificho na mnyororo wa cheti unaoanzia kwenye root ya Apple. Wakati wa runtime, kabla ya kupakia binary ndani ya memory (au kabla ya kufanya jumps kwenye mipaka fulani), mfumo unachunguza signature yake. Ikiwa code imerekebishwa (bit-flipped, patched) au haijasainiwa, load inashindwa.

- **Thwarts**: the “classic payload drop + execute” stage in exploit chains; arbitrary code injection; modifying an existing binary to insert malicious logic.
- **Mechanism detail**:
* The Mach-O loader (and dynamic linker) inakagua code pages, segments, entitlements, team IDs, na kwamba signature inafunika maudhui ya file.
* Kwa maeneo ya memory kama JIT caches au dynamically generated code, Apple inalazimisha kwamba pages zisainishwe au zichunguzwe kupitia APIs maalumu (mfano `mprotect` with code-sign checks).
* Signature inajumuisha entitlements na identifiers; OS inatekeleza kwamba APIs fulani au uwezo ulio na ruhusa unahitaji entitlements maalumu ambazo hazinaweza kuigizwa.

<details>
<summary>Example</summary>
Tuseme exploit inapata code execution katika process na inajaribu kuandika shellcode kwenye heap na kuruka kwenda kwake. Kwenye iOS, page hiyo ingehitajika kuwa imeflagged executable **and** kukidhi vigezo vya code-signature. Kwa kuwa shellcode haijasainiwa na cheti cha Apple, jump inashindwa au mfumo unakataa kufanya eneo hilo la memory liwe executable.
</details>


### 2. **CoreTrust**
**Introduced around iOS 14+ era (or gradually in newer devices / later iOS)**
CoreTrust ni subsystem inayofanya **runtime signature validation** ya binaries (pamoja na system na user binaries) dhidi ya **Apple’s root certificate** badala ya kutegemea cached userland trust stores.

- **Thwarts**: post-install tampering of binaries, jailbreaking techniques that try to swap or patch system libraries or user apps; tricking the system by replacing trusted binaries with malicious counterparts.
- **Mechanism detail**:
* Badala ya kuamini local trust database au certificate cache, CoreTrust inapata au kurejea kwenye root ya Apple moja kwa moja au inathibitisha intermediate certificates katika chain salama.
* Inahakikisha kwamba marekebisho (mfano kwenye filesystem) kwa binaries zilizopo yanagunduliwa na kukataliwa.
* Inafunga entitlements, team IDs, code signing flags, na metadata nyingine kwenye binary wakati wa load.

<details>
<summary>Example</summary>
Jailbreak inaweza kujaribu kubadilisha `SpringBoard` au `libsystem` kwa version iliyopachikwa ili kupata persistence. Lakini wakati loader ya OS au CoreTrust inachunguza, inagundua mismatch ya signature (au entitlements zilizorekebishwa) na inakataa kuendesha.
</details>


### 3. **Data Execution Prevention (DEP / NX / W^X)**
**Introduced in many OSes earlier; iOS had NX-bit / w^x for a long time**
DEP inalazimisha kwamba pages zilizoflagged writable (kwa data) ziwe **non-executable**, na pages zilizoflagged executable ziwe **non-writable**. Huwezi kwa urahisi kuandika shellcode kwenye heap au stack kisha kuitekeleza.

- **Thwarts**: direct shellcode execution; classic buffer-overflow → jump to injected shellcode.
- **Mechanism detail**:
* MMU / memory protection flags (kupitia page tables) zinalazimisha utofauti huo.
* Jaribio lolote la kuweka writable page iwe executable linasababisha ukaguzi wa mfumo (na huonyeshwa kama imezuiwa au inahitaji code-sign approval).
* Katika matukio mengi, kufanya pages executable kunahitaji kupitia OS APIs ambazo zinalazimisha vigezo au ukaguzi wa ziada.

<details>
<summary>Example</summary>
Overflow inaandika shellcode kwenye heap. Mwizi anajaribu `mprotect(heap_addr, size, PROT_EXEC)` ili kuiweka executable. Lakini mfumo unakataa au unathibitisha kwamba page mpya lazima ipitie vigezo vya code-sign (ambavyo shellcode haiwezi).
</details>

### 4. **Address Space Layout Randomization (ASLR)**
**Introduced in iOS ~4–5 era (roughly iOS 4–5 timeframe)**
ASLR inarandamiza base addresses za memory regions muhimu: libraries, heap, stack, n.k., kila kuanzishwa kwa process. Mikusanyiko ya gadgets inahamishwa kati ya runs.

- **Thwarts**: hardcoding gadget addresses for ROP/JOP; static exploit chains; blind jumping to known offsets.
- **Mechanism detail**:
* Kila library / dynamic module iliyopakiwa inarebase kwa offset iliyoratibiwa nasibu.
* Stack na heap base pointers zinarandamizwa (ndani ya mipaka ya entropy).
* Wakati mwingine maeneo mengine (mfano mmap allocations) pia yamerandamizwa.
* Imeunganishwa na mitigations za information-leak, inamfanya mwizi kwanza afanye leak ya address au pointer ili kugundua base addresses wakati wa runtime.

<details>
<summary>Example</summary>
ROP chain inatarajia gadget kwenye `0x….lib + offset`. Lakini kwa kuwa `lib` inarelokeshwa tofauti kila run, chain iliyowekwa kwa mtego inashindwa. Exploit lazima kwanza ifichue base address ya module kabla ya kuhesabu gadget addresses.
</details>


### 5. **Kernel Address Space Layout Randomization (KASLR)**
**Introduced in iOS ~ (iOS 5 / iOS 6 timeframe)**
Kama ASLR ya user, KASLR inarandamiza base ya **kernel text** na miundo mingine ya kernel wakati wa boot.

- **Thwarts**: kernel-level exploits that rely on fixed location of kernel code or data; static kernel exploits.
- **Mechanism detail**:
* Kila boot, base address ya kernel inabadilishwa nasibu (ndani ya range).
* Miundo ya kernel (kama `task_structs`, `vm_map`, n.k.) pia inaweza kurelokeshwa au kuwekewa offset.
* Washambuliaji lazima kwanza wafichue kernel pointers au kutumia information disclosure vulnerabilities kupata offsets kabla ya kuingilia kernel structures au code.

<details>
<summary>Example</summary>
Vulnerability ya local inalenga kuharibu kernel function pointer (mfano katika `vtable`) kwa `KERN_BASE + offset`. Lakini kwa kuwa `KERN_BASE` haijulikani, mwizi lazima afichue kwanza (mfano kupitia read primitive) kabla ya kuhesabu address sahihi ya kuharibu.
</details>


### 6. **Kernel Patch Protection (KPP / AMCC)**
**Introduced in newer iOS / A-series hardware (post around iOS 15–16 era or newer chips)**
KPP (aka AMCC) inafuatilia kwa kuendelea integrity ya kernel text pages (kutumia hash au checksum). Ikiwa inagundua tampering (patches, inline hooks, code modifications) nje ya windows zilizoruhusiwa, inasababisha kernel panic au reboot.

- **Thwarts**: persistent kernel patching (modifying kernel instructions), inline hooks, static function overwrites.
- **Mechanism detail**:
* Module ya hardware au firmware inalinda kernel text region.
* Mara kwa mara au kwa ombi inaharibu/huhesabu tena pages na kulinganisha na thamani inayotarajiwa.
* Ikiwa kuna mismatch nje ya windows za updates, inapaniki kifaa (ili kuepuka patchi za kudumu).
* Washambuliaji lazima wachague kuepuka windows za kugundua au watumie njia za patch halali.

<details>
<summary>Example</summary>
Exploit inajaribu kuipatch prologue ya kernel function (mfano `memcmp`) ili kuingilia simu. Lakini KPP inagundua kwamba page ya code hakilingani na thamani inayotarajiwa na inasababisha kernel panic, ikirusha kifaa kabla patch iweze kustawi.
</details>


### 7. **Kernel Text Read‐Only Region (KTRR)**
**Introduced in modern SoCs (post ~A12 / newer hardware)**
KTRR ni mekanisimu inayotekelezwa kwa hardware: mara kernel text inafungwa mapema wakati wa boot, inakuwa read-only kutoka EL1 (the kernel), ikizuia maandishi zaidi kwenye code pages.

- **Thwarts**: any modifications to kernel code after boot (e.g. patching, in-place code injection) at EL1 privilege level.
- **Mechanism detail**:
* Wakati wa boot (katika hatua ya secure/bootloader), memory controller (au unit ya hardware salama) inaweka physical pages zenye kernel text kuwa read-only.
* Hata kama exploit inapata privileges kamili za kernel, haiwezi kuandika kwenye pages hizo ili kupachika maelekezo.
* Ili kuzibadilisha, mwizi lazima kwanza aharibishe boot chain, au ashinde KTRR yenyewe.

<details>
<summary>Example</summary>
Exploit ya privilege-escalation inajaribu kuruka hadi EL1 na kuandika trampoline ndani ya kernel function (mfano katika handler ya `syscall`). Lakini kwa sababu pages zimefungwa read-only na KTRR, uandishi unashindwa (au unasababisha fault), hivyo patch haifanyiki.
</details>


### 8. **Pointer Authentication Codes (PAC)**
**Introduced with ARMv8.3 (hardware), Apple beginning with A12 / iOS ~12+**
- PAC ni kipengele cha hardware kilichotolewa katika **ARMv8.3-A** kugundua uharibifu wa pointer values (return addresses, function pointers, certain data pointers) kwa kuweka saini ndogo ya cryptographic (“MAC”) ndani ya bits za juu zisizotumika za pointer.
- Saini (“PAC”) huhesabiwa juu ya pointer value pamoja na **modifier** (thamani ya muktadha, mfano stack pointer au data ya kutofautisha). Kwa hivyo pointer ile ile chini ya muktadha tofauti inapata PAC tofauti.
- Wakati wa matumizi, kabla ya kureference au branching kupitia pointer hiyo, instruction ya **authenticate** inakagua PAC. Ikiwa sahihi, PAC inafutwa na pointer safi inapatikana; ikiwa sio sahihi, pointer inakuwa “poisoned” (au fault inatolewa).
- Keys zinazotumika kwa kuzalisha/kuhakiki PAC ziko katika privileged registers (EL1, kernel) na hazipatikani moja kwa moja kutoka user mode.
- Kwa sababu si bit zote 64 za pointer zinatumika katika mifumo mingi (mfano 48-bit address space), bits za juu ni “spare” na zinaweza kushikilia PAC bila kubadilisha address halisi.

#### Architectural Basis & Key Types

- ARMv8.3 inaleta **five 128-bit keys** (kila moja ikitekelezwa kupitia two 64-bit system registers) kwa pointer authentication.
- **APIAKey** — kwa instruction pointers (domain “I”, key A)
- **APIBKey** — second instruction pointer key (domain “I”, key B)
- **APDAKey** — kwa data pointers (domain “D”, key A)
- **APDBKey** — kwa data pointers (domain “D”, key B)
- **APGAKey** — “generic” key, kwa kusaini non-pointer data au matumizi mengine ya generic

- Keys hizi ziko katika privileged system registers (zinazopatikana tu katika EL1/EL2 n.k.), hazipatikani kutoka user mode.
- PAC huhesabiwa kwa kutumia cryptographic function (ARM inapendekeza QARMA kama algorithm) kwa:
1. The pointer value (canonical portion)
2. A **modifier** (thamani ya muktadha, kama salt)
3. The secret key
4. Logic ya tweak ndani
Ikiwa PAC inayotoka inalingana na ile iliyowekwa katika bits za juu za pointer, authentication inafanikiwa.

#### Instruction Families

Convention ya majina ni: **PAC** / **AUT** / **XPAC**, kisha herufi za domain.
- `PACxx` instructions **sign** pointer na kuweka PAC
- `AUTxx` instructions **authenticate + strip** (validate na kuondoa PAC)
- `XPACxx` instructions **strip** bila kuvalidate

Domains / suffixes:

| Mnemonic     | Meaning / Domain                      | Key / Domain     | Example Usage in Assembly |
|--------------|-----------------------------------------|--------------------|-----------------------------|
| **PACIA**    | Sign instruction pointer with APIAKey   | “I, A”             | `PACIA X0, X1` — sign pointer in X0 using APIAKey with modifier X1|
| **PACIB**    | Sign instruction pointer with APIBKey   | “I, B”             | `PACIB X2, X3`              |
| **PACDA**    | Sign data pointer with APDAKey           | “D, A”             | `PACDA X4, X5`              |
| **PACDB**    | Sign data pointer with APDBKey           | “D, B”             | `PACDB X6, X7`              |
| **PACG / PACGA** | Generic (non-pointer) signing with APGAKey | “G”         | `PACGA X8, X9, X10` (sign X9 with modifier X10 into X8) |
| **AUTIA**    | Authenticate APIA-signed instruction pointer & strip PAC | “I, A” | `AUTIA X0, X1` — check PAC on X0 using modifier X1, then strip |
| **AUTIB**    | Authenticate APIB domain                 | “I, B”             | `AUTIB X2, X3`               |
| **AUTDA**    | Authenticate APDA-signed data pointer    | “D, A”             | `AUTDA X4, X5`               |
| **AUTDB**    | Authenticate APDB-signed data pointer    | “D, B”             | `AUTDB X6, X7`               |
| **AUTGA**    | Authenticate generic / blob (APGA)        | “G”               | `AUTGA X8, X9, X10` (validate generic) |
| **XPACI**     | Strip PAC (instruction pointer, no validation) | “I”         | `XPACI X0` — remove PAC from X0 (instruction domain) |
| **XPACD**     | Strip PAC (data pointer, no validation)    | “D”             | `XPACD X4` — remove PAC from data pointer in X4 |


There are specialized / alias forms:

- `PACIASP` ni kifupi cha `PACIA X30, SP` (sign the link register using SP as modifier)
- `AUTIASP` ni `AUTIA X30, SP` (authenticate link register with SP)
- Fomu zilizojumuishwa kama `RETAA`, `RETAB` (authenticate-and-return) au `BLRAA` (authenticate & branch) zipo katika extensions za ARM / compiler support.
- Pia variants za zero-modifier: `PACIZA` / `PACIZB` ambapo modifier ni implicitly zero, n.k.

#### Modifiers

Lengo kuu la modifier ni **kuziunganisha PAC na muktadha maalumu** kwa hivyo address ile ile iliyosainiwa katika muktadha tofauti hutoa PAC tofauti. Hii inazuia matumizi rahisi ya pointer across frames au objects. Ni kama kuongeza **salt kwenye hash.**

Kwa hivyo:
- **modifier** ni thamani ya muktadha (register nyingine) inayochanganywa katika hesabu ya PAC. Chaguo za kawaida: stack pointer (`SP`), frame pointer, au object ID.
- Kutumia SP kama modifier ni kawaida kwa signing ya return address: PAC inafungwa kwa frame fulani. Ikiwa utajaribu kutumia tena LR katika frame tofauti, modifier itabadilika, hivyo PAC validation itashindwa.
- Pointer ile ile iliyosainiwa chini ya modifiers tofauti inatoa PAC tofauti.
- Modifier haitaji kuwa siri, lakini vinginevyo haifai iwe under attacker control.
- Kwa instructions zinazofanya sign/verify pointer ambapo hakuna modifier yenye maana, baadhi ya fomu zinatumia zero au constant implicit.

#### Apple / iOS / XNU Customizations & Observations

- Implementations ya Apple ya PAC zinajumuisha **per-boot diversifiers** hivyo keys au tweaks hubadilika kila boot, kuzuia reuse across boots.
- Pia zipo **cross-domain mitigations** ili PAC zilizotumiwa katika user mode zisitumiwe kwa urahisi katika kernel mode, n.k.
- Kwenye Apple M1 / Apple Silicon, reverse engineering ilionyesha kwamba kuna **nine modifier types** na system registers za Apple kwa control ya keys.
- Apple inatumia PAC katika subsystems nyingi za kernel: return address signing, pointer integrity katika kernel data, signed thread contexts, n.k.
- Google Project Zero ilionyesha jinsi chini ya memory read/write primitive katika kernel, mtu anaweza kuforge kernel PACs (kwa A keys) kwenye vifaa vya A12, lakini Apple ilirekebisha njia nyingi hizo.
- Katika mfumo wa Apple, baadhi ya keys ni **global across kernel**, wakati user processes zinaweza kupata randomness ya key per-process.

#### PAC Bypasses

1. **Kernel-mode PAC: theoretical vs real bypasses**

-   Kwa sababu kernel PAC keys na logic zinadhibitiwa kwa karibu (privileged registers, diversifiers, domain isolation), kuforge arbitrary signed kernel pointers ni ngumu sana.
-   Azad's 2020 "iOS Kernel PAC, One Year Later" inaripoti kwamba katika iOS 12-13, aligundua baadhi ya bypasses za sehemu (signing gadgets, reuse ya signed states, indirect branches zisizo na ulinzi) lakini hakuna bypass kamili ya generic. [bazad.github.io](https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf)
-   Apple's "Dark Magic" customizations zinafunga zaidi surfaces zinazoweza kutumiwa (domain switching, per-key enabling bits). [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Kuna CVE-2023-32424 inayohusiana na kernel PAC bypass kwenye Apple silicon (M1/M2) iliyoripotiwa na Zecao Cai et al. [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Lakini bypasses hizi mara nyingi zinategemea gadgets maalumu au bugs za implementation; siyo njia za jumla za kukwepa.

Kwa hivyo kernel PAC inachukuliwa kuwa **sana imara**, ingawa si kamili.

2. **User-mode / runtime PAC bypass techniques**

Hizi ni za kawaida zaidi, na zinafaidika na makosa katika matumizi ya PAC au jinsi inavyotekelezwa kwenye dynamic linking / runtime frameworks. Hapa chini ni darasa, na mifano.

2.1 **Shared Cache / A key issues**

-   The **dyld shared cache** ni blob kubwa pre-linked ya system frameworks na libraries. Kwa kuwa inashirikiwa sana, function pointers ndani ya shared cache tayari "zimesainishwa" na kutumiwa na processes nyingi. Washambuliaji wanawalenga pointers hizi tayari-zimesainishwa kama "PAC oracles".

-   Baadhi ya mbinu za bypass zinajaribu kutoa au kutumia A-key signed pointers zilizopo kwenye shared cache na kuzitumia katika gadgets.

-   The "No Clicks Required" talk inaelezea kujenga oracle juu ya shared cache ili kubaini relative addresses na kuziunganisha na signed pointers ili kukwepa PAC. [saelo.github.io](https://saelo.github.io/presentations/offensivecon_20_no_clicks.pdf)

-   Pia, imports za function pointers kutoka shared libraries katika userspace zilikutwa kuwa hazilindwa vya kutosha na PAC, kuruhusu mwizi kupata function pointers bila kubadilisha signature. (Project Zero bug entry) [bugs.chromium.org](https://bugs.chromium.org/p/project-zero/issues/detail?id=2044&utm_source=chatgpt.com)

2.2 **dlsym(3) / dynamic symbol resolution**

-   Moja ya bypass inayojulikana ni kuita `dlsym()` kupata pointer ya function *ambayo tayari imesainishwa* (imesainishwa kwa A-key, diversifier zero) kisha kuitumia. Kwa kuwa `dlsym` inarudisha legitimately signed pointer, kuitumia kunazuia hitaji la kuforge PAC.

-   Blog ya Epsilon inaelezea jinsi baadhi ya bypasses zinavyotumia hii: kuita `dlsym("someSym")` hurudisha signed pointer na inaweza kutumika kwa indirect calls. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

-   Synacktiv's "iOS 18.4 --- dlsym considered harmful" inaelezea bug: baadhi ya symbols zilizoambatishwa kupitia `dlsym` kwenye iOS 18.4 zilirudisha pointers ambazo zimesainishwa vibaya (au zikiwa na diversifiers zenye mdanganyiko), kuruhusu PAC bypass isiyotakiwa. [Synacktiv](https://www.synacktiv.com/en/publications/ios-184-dlsym-considered-harmful)

-   Logic katika dyld kwa dlsym ni: wakati `result->isCode`, wana-sign pointer iliyorejeshwa na `__builtin_ptrauth_sign_unauthenticated(..., key_asia, 0)`, yaani context zero. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

Hivyo, `dlsym` ni vector ya mara kwa mara katika user-mode PAC bypasses.

2.3 **Other DYLD / runtime relocations**

-   DYLD loader na logic ya dynamic relocation ni ngumu na wakati mwingine inamepuka kuruhusu pages ziwe read/write kwa ajili ya kufanya relocations, kisha kurudisha read-only. Washambuliaji wanatumia windows hizi. Wasilisho za Synacktiv zinaelezea "Operation Triangulation", bypass kwa msingi wa timing ya PAC kupitia dynamic relocations. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   DYLD pages sasa zinalindwa na SPRR / VM_FLAGS_TPRO (bendera za ulinzi kwa dyld). Lakini matoleo ya awali yalikuwa na ulinzi dhaifu. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   Katika WebKit exploit chains, DYLD loader mara nyingi ni lengo la PAC bypass. Slides zinataja kuwa PAC bypass nyingi zililenga DYLD loader (kupitia relocation, interposer hooks). [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

2.4 **NSPredicate / NSExpression / ObjC / SLOP**

-   Katika chains za userland exploit, Objective-C runtime methods kama `NSPredicate`, `NSExpression` au `NSInvocation` hutumika kusafirisha simu za control bila kuonekana wazi kuwa pointer zimeforge-ungwa.

-   Kwenye iOS za zamani (kabla ya PAC), exploit ilitumia **fake NSInvocation** objects kuita selectors yoyote kwenye memory iliyodhibitiwa. Kwa PAC, mbinu zilibadilishwa. Lakini SLOP (SeLector Oriented Programming) imetumika pia chini ya PAC. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   Mbinu ya awali ya SLOP iliruhusu kuunda mnyororo wa ObjC calls kwa kutengeneza invocations bandia; bypass hii inategemea kwamba ISA au selector pointers wakati mwingine hazilindwa kikamilifu na PAC. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   Katika mazingira ambapo pointer authentication inatumika kwa sehemu, methods / selectors / target pointers hazina daima ulinzi wa PAC, ikitoa nafasi ya bypass.

#### Example Flow

<details>
<summary>Example Signing & Authenticating</summary>
```
; Example: function prologue / return address protection
my_func:
stp x29, x30, [sp, #-0x20]!        ; push frame pointer + LR
mov x29, sp
PACIASP                            ; sign LR (x30) using SP as modifier
; … body …
mov sp, x29
ldp x29, x30, [sp], #0x20         ; restore
AUTIASP                            ; authenticate & strip PAC
ret

; Example: indirect function pointer stored in a struct
; suppose X1 contains a function pointer
PACDA X1, X2     ; sign data pointer X1 with context X2
STR X1, [X0]      ; store signed pointer

; later retrieval:
LDR X1, [X0]
AUTDA X1, X2       ; authenticate & strip
BLR X1             ; branch to valid target

; Example: stripping for comparison (unsafe)
LDR X1, [X0]
XPACI X1           ; strip PAC (instruction domain)
CMP X1, #some_label_address
BEQ matched_label
```
</details>

<details>
<summary>Example</summary>
Overflow ya buffer inabandika anwani ya return kwenye stack. Mshambuliaji anaandika anwani ya gadget inayolengwa lakini hawawezi hesabu PAC sahihi. Wakati function inarudi, CPU’s `AUTIA` instruction inatenda kosa kwa sababu ya mismatch ya PAC. Mnyororo unabomoka.
Project Zero’s analysis on A12 (iPhone XS) ilionyesha jinsi Apple’s PAC inavyotumika na mbinu za kutengeneza PACs ikiwa mshambuliaji ana primitive ya kusoma/kuandika kumbukumbu.
</details>


### 9. **Branch Target Identification (BTI)**
**Ilianzishwa na ARMv8.5 (hardware za baadaye)**
BTI ni sifa ya hardware inayochunguza **malengo ya branch zisizo za moja kwa moja**: wakati ikitekeleza `blr` au indirect calls/jumps, lengo lazima lianze na **BTI landing pad** (`BTI j` au `BTI c`). Kuruka ndani ya anwani za gadget ambazo hazina landing pad husababisha exception.

LLVM’s implementation inabainisha aina tatu za maelekezo ya BTI na jinsi zinavyolingana na aina za branch.

| BTI Variant | What it permits (which branch types) | Typical placement / use case |
|-------------|----------------------------------------|-------------------------------|
| **BTI C** | Targets of *call*-style indirect branches (e.g. `BLR`, or `BR` using X16/X17) | Weka kwenye kuingia kwa functions ambazo zinaweza kuitwa kwa njia isiyo ya moja kwa moja |
| **BTI J** | Targets of *jump*-style branches (e.g. `BR` used for tail calls) | Iwekwa mwanzoni mwa blocks zinazoweza kufikiwa na jump tables au tail-calls |
| **BTI JC** | Acts as both C and J | Inaweza kulengwa kwa branch ya call au jump |

- Katika code iliyosanywa na branch target enforcement, compilers huingiza instruction ya BTI (C, J, au JC) kwenye kila lengo halali la indirect-branch (mwanzo wa functions au blocks zinazoweza kulengwa na jumps) ili indirect branches zaweze kufaulu tu kwenda sehemu hizo.
- **Direct branches / calls** (yaani anwani za fasta `B`, `BL`) hazina vizuizi vya BTI. Dhana ni kwamba ukurasa wa code unatajwa kuwa wa kuaminika na mshambuliaji hawezi kuubadilisha (hivyo direct branches ni salama).
- Vilevile, **RET / return** instructions kwa kawaida hazizuiziwi na BTI kwa sababu anwani za return zinaprotektwa kupitia PAC au mekanisimu za return signing.

#### Mechanism and enforcement

- Wakati CPU inakatafsiri **indirect branch (BLR / BR)** kwenye page iliyotajwa kama “guarded / BTI-enabled,” inachunguza kama instruction ya kwanza kwenye anwani ya lengo ni BTI halali (C, J, au JC kama inaruhusiwa). Ikiwa siyo, hutokea **Branch Target Exception**.
- Encoding ya instruction ya BTI imetengenezwa ili kutumia tena opcodes ambazo awali zilikuwa zimehifadhiwa kwa NOPs (katika matoleo ya ARM ya awali). Hivyo binaries zilizo BTI-enabled zinabaki backward-compatible: kwenye hardware isiyo na msaada wa BTI, maelekezo hayo hufanya kazi kama NOPs.
- Compiler passes zinazoongeza BTIs zinaingiza tu pale zinapohitajika: functions ambazo zinaweza kuitwa kwa njia isiyo ya moja kwa moja, au basic blocks zinazolengwa na jumps.
- Baadhi ya patches na code za LLVM zinaonyesha kwamba BTI haingiziwi kwa *blocks zote* — ni kwa zile tu ambazo zinaweza kuwa branch targets (kwa mfano kutoka switch / jump tables).

#### BTI + PAC synergy

PAC inalinda thamani ya pointer (chanzo) — inahakikisha mnyororo wa indirect calls / returns haujabadilishwa.

BTI inahakikisha kwamba hata pointer halali lazima inalenga tu entry points zilizo alama ipasavyo.

Pamoja, mshambuliaji anahitaji pointer halali yenye PAC sahihi na lengo ambalo limewekwa BTI hapo. Hii inaongeza ugumu wa kutengeneza gadgets za exploit.

#### Example


<details>
<summary>Example</summary>
Exploit inajaribu ku-pivot ndani ya gadget kwenye `0xABCDEF` ambayo haianzi na `BTI c`. CPU, wakati ikitekeleza `blr x0`, inakagua lengo na inashindwa kwa sababu usanifu wa maelekezo haujajumuisha landing pad halali. Hivyo gadgets nyingi zinakuwa hazitumiiki isipokuwa zinajumuisha prefix ya BTI.
</details>


### 10. **Privileged Access Never (PAN) & Privileged Execute Never (PXN)**
**Ilianzishwa katika nyongeza za hivi karibuni za ARMv8 / msaada wa iOS (kwa kernel yenye ulinzi)**

#### PAN (Privileged Access Never)

- **PAN** ni sifa iliyowekezwa katika **ARMv8.1-A** inayozuia **code yenye privilage** (EL1 au EL2) kutoka **kusoma au kuandika** kumbukumbu ambayo imewekwa kama **user-accessible (EL0)**, isipokuwa PAN iwe imezimwa wazi.
- Wazo ni: hata kama kernel imechukuliwa au kuingiliwa, haiwezi kusoma pointers za user-space kwa hiari bila kwanza *kuzima* PAN, hivyo kupunguza hatari za exploits za mtindo wa **`ret2usr`** au matumizi mabaya ya buffers zinazosimamiwa na user.
- Wakati PAN imewezeshwa (PSTATE.PAN = 1), maagizo yoyote ya privileged load/store yanayofikia anwani pepe inayokuwa “accessible at EL0” husababisha **permission fault**.
- Kernel, inapohitaji kwa mhimili kufikia kumbukumbu ya user-space kwa njia halali (mfano ku-copy data kwenda/ kutoka user buffers), lazima **wazime PAN kwa muda** (au kutumia maagizo ya “unprivileged load/store”) ili kuruhusu ufikiaji huo.
- Katika Linux kwenye ARM64, msaada wa PAN ulianza takriban 2015: patches za kernel ziliongeza utambuzi wa sifa hiyo, na kubadilisha `get_user` / `put_user` nk na variantes zinazozima PAN wakati wa ufikiaji wa kumbukumbu za user.

**Tofauti muhimu / kikomo / mdudu**
- Kama ilivyobainishwa na Siguza na wengine, mdudu wa specification (au tabia isiyo wazi) katika muundo wa ARM una maana kwamba **mappings za user zinazotekelezwa tu (execute-only) (`--x`) huenda **zisizowafanya PAN kazi**. Kwa maneno mengine, ikiwa ukurasa wa user umewekwa executable bila ruhusa ya kusoma, jaribio la kernel la kusoma linaweza kupita PAN kwa sababu architecture inachukulia “accessible at EL0” kuhitaji ruhusa ya kusoma, sio tu executable. Hii inasababisha bypass ya PAN katika usanidi fulani.
- Kwa sababu hiyo, ikiwa iOS / XNU inaruhusu pages za user kuwa execute-only (kama baadhi ya JIT au code-cache setups zinaweza kufanya), kernel huenda ikasoma kutoka kwao hata PAN ikiwa imewezeshwa. Hii ni eneo nyeti lililojulikana kwamba linaweza kutumiwa katika baadhi ya mifumo ya ARMv8+.

#### PXN (Privileged eXecute Never)

- **PXN** ni bit ya page table (katika page table entries, leaf au block entries) inayoonyesha kwamba ukurasa hauwezi kutekelezwa unapokuwa unaendesha kwa mode ya privileged (yaani wakati EL1 inatekeleza).
- PXN inazuia kernel (au code yoyote ya privileged) kutekeleza maagizo kutoka kwa pages za user hata kama control imepindukia. Kwa ufanisi, inazuia redirect ya control-flow kwenye code ya user kutoka kwa kernel.
- Pamoja na PAN, hili linahakikisha:
1. Kernel haiwezi (kwa default) kusoma au kuandika data ya user-space (PAN)
2. Kernel haiwezi kutekeleza code ya user-space (PXN)
- Katika format ya page table ya ARMv8, entries za leaf zina biti ya `PXN` (na pia `UXN` kwa unprivileged execute-never) katika bits zao za sifa.

Hivyo hata kama kernel ina function pointer iliyoharibika inayolenga memory ya user, na ikajaribu kubranch huko, bit ya PXN ingesababisha fault.

#### Memory-permission model & how PAN and PXN map to page table bits

Ili kuelewa jinsi PAN / PXN zinavyofanya kazi, unahitaji kuona jinsi utafutaji na modeli ya ruhusa za ARM inavyofanya kazi (imekuzwa):

- Kila page au block entry ina fields za sifa zikiwemo **AP[2:1]** kwa ruhusa za upatikanaji (kusoma/kuandika, privileged vs unprivileged) na bit za **UXN / PXN** kwa vizuizi vya execute-never.
- Wakati PSTATE.PAN ni 1 (imewezeshwa), hardware inatekeleza semantics zilizobadilishwa: ufikiaji wa privileged kwa pages zilizoainishwa kama “accessible by EL0” (yaani user-accessible) unazuizwa (fault).
- Kwa sababu ya mdudu uliotajwa, pages ambazo zimewekwa executable tu (bila ruhusa ya kusoma) huenda zisihesabiwe kama “accessible by EL0” kwenye utekelezaji fulani, hivyo kupita PAN.
- Wakati bit ya PXN kwenye ukurasa imewekwa, hata kama instruction fetch inatoka kwa level ya juu ya privilage, utekelezaji unazuuzwa.

#### Kernel usage of PAN / PXN in a hardened OS (e.g. iOS / XNU)

Katika muundo wa kernel yenye ulinzi (kama vile Apple inaweza kutumia):

- Kernel inawawezesha PAN kwa default (hivyo code ya privileged inalazimika).
- Katika njia ambazo zinahitaji kwa haki kusoma au kuandika buffers za user (mfano syscall buffer copy, I/O, read/write user pointer), kernel huwasha **kuzima PAN kwa muda** au kutumia maagizo maalum ili kuvuka.
- Baada ya kumaliza ufikiaji wa data ya user, lazima iahire PAN tena.
- PXN inateketezwa kupitia page tables: pages za user zina PXN = 1 (hivyo kernel haiwezi kuzitekeleza), pages za kernel hazina PXN (hivyo code ya kernel inaweza kutekelezwa).
- Kernel lazima ihakikishe kwamba hakuna njia za code zinazosababisha mtiririko wa utekelezaji kwenda maeneo ya memory ya user (ambayo ingepita PXN) — hivyo mnyororo wa exploit unaotegemea “kuruka ndani ya shellcode ya user” unafungwa.

Kwa sababu ya bypass ya PAN kupitia execute-only pages, katika mfumo halisi, Apple inaweza kuzima au kukataa execute-only user pages, au kurekebisha kuzunguka udhaifu wa specification.

#### Attack surfaces, bypasses, and mitigations

- **PAN bypass via execute-only pages**: kama ilivyojadiliwa, spec inaruhusu pengo: pages za user zenye execute-only (bila perm ya kusoma) huenda zisizihesabiwe kama “accessible at EL0,” hivyo PAN haitazuia kusomwa kwa kernel kutoka kwa pages hizo kwenye utekelezaji fulani. Hii inampa mshambuliaji njia isiyo ya kawaida ya kuingiza data kupitia sehemu za “execute-only.”
- **Temporal window exploit**: ikiwa kernel inazima PAN kwa dirisha lenye urefu mkubwa kuliko inavyohitajika, race condition au njia mbaya inaweza kutumia dirisha hilo kufanya ufikiaji usiolengwa wa kumbukumbu ya user.
- **Forgotten re-enable**: ikiwa njia za code hazirudishi PAN, operesheni za baadaye za kernel zinaweza kufanya ufikiaji usiofaa wa memory ya user.
- **Misconfiguration of PXN**: ikiwa page tables hazoweka PXN kwenye pages za user au zinaweka vibaya mapping za pages za code za user, kernel inaweza kujaribiwa kutekeleza code ya user.
- **Speculation / side-channels**: kama ilivyo kwa bypasses za speculative, kunaweza kuwa na athari za microarchitectural ambazo husababisha ukiukaji wa muda mfupi wa ukaguzi wa PAN / PXN (ingawa mashambulizi ya aina hii yanategemea sana muundo wa CPU).
- **Complex interactions**: Katika vipengele vya juu zaidi (mfano JIT, shared memory, maeneo ya code ya just-in-time), kernel inaweza kuhitaji udhibiti wa kina ili kuruhusu ufikiaji fulani wa memory au utekelezaji katika maeneo yaliyopangwa kwa user; kubuni hayo salama chini ya vizuizi vya PAN/PXN si jambo rahisi.

#### Example

<details>
<summary>Code Example</summary>
Hapa kuna mlolongo wa pseudo-assembly unaoonyesha kuwasha/kuzima PAN wakati wa ufikiaji wa memory ya user, na jinsi fault inaweza kutokea.
```  
// Suppose kernel entry point, PAN is enabled (privileged code cannot access user memory by default)

; Kernel receives a syscall with user pointer in X0
; wants to read an integer from user space
mov   X1, X0        ; X1 = user pointer

; disable PAN to allow privileged access to user memory
MSR   PSTATE.PAN, #0   ; clear PAN bit, disabling the restriction

ldr   W2, [X1]       ; now allowed load from user address

; re-enable PAN before doing other kernel logic
MSR   PSTATE.PAN, #1   ; set PAN

; ... further kernel work ...

; Later, suppose an exploit corrupts a pointer to a user-space code page and jumps there
BR    X3             ; branch to X3 (which points into user memory)

; Because the target page is marked PXN = 1 for privileged execution,
; the CPU throws an exception (fault) and rejects execution
```
If the kernel had **not** set PXN on that user page, then the branch might succeed — which would be insecure.

If the kernel forgets to re-enable PAN after user memory access, it opens a window where further kernel logic might accidentally read/write arbitrary user memory.

If the user pointer is into an execute-only page (user page with only execute permission, no read/write), under the PAN spec bug, `ldr W2, [X1]` might **not** fault even with PAN enabled, enabling a bypass exploit, depending on implementation.

</details>

<details>
<summary>Example</summary>
A kernel vulnerability tries to take a user-provided function pointer and call it in kernel context (i.e. `call user_buffer`). Under PAN/PXN, that operation is disallowed or faults.
</details>

---

### 11. **Top Byte Ignore (TBI) / Pointer Tagging**
**Introduced in ARMv8.5 / newer (or optional extension)**
TBI means the top byte (most-significant byte) of a 64-bit pointer is ignored by address translation. This lets OS or hardware embed **tag bits** in the pointer’s top byte without affecting the actual address.

- TBI stands for **Top Byte Ignore** (sometimes called *Address Tagging*). It is a hardware feature (available in many ARMv8+ implementations) that **ignores the top 8 bits** (bits 63:56) of a 64-bit pointer when performing **address translation / load/store / instruction fetch**.
- In effect, the CPU treats a pointer `0xTTxxxx_xxxx_xxxx` (where `TT` = top byte) as `0x00xxxx_xxxx_xxxx` for the purposes of address translation, ignoring (masking off) the top byte. The top byte can be used by software to store **metadata / tag bits**.
- This gives software “free” in-band space to embed a byte of tag in each pointer without altering which memory location it refers to.
- The architecture ensures that loads, stores, and instruction fetch treat the pointer with its top byte masked (i.e. tag stripped off) before performing the actual memory access.

Thus TBI decouples the **logical pointer** (pointer + tag) from the **physical address** used for memory operations.

#### Why TBI: Use cases and motivation

- **Pointer tagging / metadata**: You can store extra metadata (e.g. object type, version, bounds, integrity tags) in that top byte. When you later use the pointer, the tag is ignored at hardware level, so you don’t need to strip manually for the memory access.
- **Memory tagging / MTE (Memory Tagging Extension)**: TBI is the base hardware mechanism that MTE builds on. In ARMv8.5, the **Memory Tagging Extension** uses bits 59:56 of the pointer as a **logical tag** and checks it against an **allocation tag** stored in memory.
- **Enhanced security & integrity**: By combining TBI with pointer authentication (PAC) or runtime checks, you can force not just the pointer value but also the tag to be correct. An attacker overwriting a pointer without the correct tag will produce a mismatched tag.
- **Compatibility**: Because TBI is optional and tag bits are ignored by hardware, existing untagged code continues to operate normally. The tag bits effectively become “don’t care” bits for legacy code.

#### Example
<details>
<summary>Example</summary>
A function pointer included a tag in its top byte (say `0xAA`). An exploit overwrites the pointer low bits but neglects the tag, so when the kernel verifies or sanitizes, the pointer fails or is rejected.
</details>

---

### 12. **Page Protection Layer (PPL)**
**Introduced in late iOS / modern hardware (iOS ~17 / Apple silicon / high-end models)** (some reports show PPL circa macOS / Apple silicon, but Apple is bringing analogous protections to iOS)

- PPL is designed as an **intra-kernel protection boundary**: even if the kernel (EL1) is compromised and has read/write capabilities, **it should not be able to freely modify** certain **sensitive pages** (especially page tables, code-signing metadata, kernel code pages, entitlements, trust caches, etc.).
- It effectively creates a **“kernel within the kernel”** — a smaller trusted component (PPL) with **elevated privileges** that alone can modify protected pages. Other kernel code must call into PPL routines to effect changes.
- This reduces the attack surface for kernel exploits: even with full arbitrary R/W/execute in kernel mode, exploit code must also somehow get into the PPL domain (or bypass PPL) to modify critical structures.
- On newer Apple silicon (A15+ / M2+), Apple is transitioning to **SPTM (Secure Page Table Monitor)**, which in many cases replaces PPL for page-table protection on those platforms.

Here’s how PPL is believed to operate, based on public analysis:

#### Use of APRR / permission routing (APRR = Access Permission ReRouting)

- Apple hardware uses a mechanism called **APRR (Access Permission ReRouting)**, which allows page table entries (PTEs) to contain small indices, rather than full permission bits. Those indices are mapped via APRR registers to actual permissions. This allows dynamic remapping of permissions per domain.
- PPL leverages APRR to segregate privilege within kernel context: only the PPL domain is permitted to update the mapping between indices and effective permissions. That is, when non-PPL kernel code writes a PTE or tries to flip permission bits, the APRR logic disallows it (or enforces read-only mapping).
- PPL code itself runs in a restricted region (e.g. `__PPLTEXT`) which is normally non-executable or non-writable until entry gates temporarily allow it. The kernel calls PPL entry points (“PPL routines”) to perform sensitive operations.

#### Gate / Entry & Exit

- When the kernel needs to modify a protected page (e.g. change permissions of a kernel code page, or modify page tables), it calls into a **PPL wrapper** routine, which does validation and then transitions into the PPL domain. Outside that domain, the protected pages are effectively read-only or non-modifiable by the main kernel.
- During PPL entry, the APRR mappings are adjusted so that memory pages in the PPL region are set to **executable & writable** within PPL. Upon exit, they are returned to read-only / non-writable. This ensures that only well-audited PPL routines can write to protected pages.
- Outside PPL, attempts by kernel code to write to those protected pages will fault (permission denied) because the APRR mapping for that code domain doesn’t permit writing.

#### Protected page categories

The pages that PPL typically protects include:

- Page table structures (translation table entries, mapping metadata)
- Kernel code pages, especially those containing critical logic
- Code-sign metadata (trust caches, signature blobs)
- Entitlement tables, signature enforcement tables
- Other high-value kernel structures where a patch would allow bypassing signature checks or credentials manipulation

The idea is that even if the kernel memory is fully controlled, the attacker cannot simply patch or rewrite these pages, unless they also compromise PPL routines or bypass PPL.


#### Known Bypasses & Vulnerabilities

1. **Project Zero’s PPL bypass (stale TLB trick)**

- A public writeup by Project Zero describes a bypass involving **stale TLB entries**.
- The idea:

1. Allocate two physical pages A and B, mark them as PPL pages (so they are protected).
2. Map two virtual addresses P and Q whose L3 translation table pages come from A and B.
3. Spin a thread to continuously access Q, keeping its TLB entry alive.
4. Call `pmap_remove_options()` to remove mappings starting at P; due to a bug, the code mistakenly removes the TTEs for both P and Q, but only invalidates the TLB entry for P, leaving Q’s stale entry live.
5. Reuse B (page Q’s table) to map arbitrary memory (e.g. PPL-protected pages). Because the stale TLB entry still maps Q’s old mapping, that mapping remains valid for that context.
6. Through this, the attacker can put writable mapping of PPL-protected pages in place without going through PPL interface.

- This exploit required fine control of physical mapping and TLB behavior. It demonstrates that a security boundary relying on TLB / mapping correctness must be extremely careful about TLB invalidations and mapping consistency.

- Project Zero commented that bypasses like this are subtle and rare, but possible in complex systems. Still, they regard PPL as a solid mitigation.

2. **Other potential hazards & constraints**

- If a kernel exploit can directly enter PPL routines (via calling the PPL wrappers), it might bypass restrictions. Thus argument validation is critical.
- Bugs in the PPL code itself (e.g. arithmetic overflow, boundary checks) can allow out-of-bounds modifications inside PPL. Project Zero observed that such a bug in `pmap_remove_options_internal()` was exploited in their bypass.
- The PPL boundary is irrevocably tied to hardware enforcement (APRR, memory controller), so it's only as strong as the hardware implementation.



#### Example
<details>
<summary>Code Example</summary>
Here’s a simplified pseudocode / logic showing how a kernel might call into PPL to modify protected pages:
```c
// In kernel (outside PPL domain)
function kernel_modify_pptable(pt_addr, new_entry) {
// validate arguments, etc.
return ppl_call_modify(pt_addr, new_entry)  // call PPL wrapper
}

// In PPL (trusted domain)
function ppl_call_modify(pt_addr, new_entry) {
// temporarily enable write access to protected pages (via APRR adjustments)
aprr_set_index_for_write(PPL_INDEX)
// perform the modification
*pt_addr = new_entry
// restore permissions (make pages read-only again)
aprr_restore_default()
return success
}

// If kernel code outside PPL does:
*pt_addr = new_entry  // a direct write
// It will fault because APRR mapping for non-PPL domain disallows write to that page
```
Kernel inaweza kufanya operesheni nyingi za kawaida, lakini ni kupitia taratibu za `ppl_call_*` pekee ndiyo inaweza kubadilisha mappings zilizolindwa au kupachika code.
</details>

<details>
<summary>Mfano</summary>
Exploit ya kernel inajaribu kuandika juu ya entitlement table, au kuzima utekelezaji wa code-sign kwa kubadilisha kernel signature blob. Kwa sababu ukurasa huo ni PPL-protected, uandishi unazuiauwa isipokuwa ukipitishwa kupitia interface ya PPL. Hivyo hata ukiwa na execution ya kernel code, huwezi kuondoa vikwazo vya code-sign au kubadilisha data za credential kiholela.
On iOS 17+ vifaa vingine vinatumia SPTM kwa kuwatenga zaidi kurasa zinazosimamiwa na PPL.
</details>

#### PPL → SPTM / Replacements / Future

- On Apple’s modern SoCs (A15 or later, M2 or later), Apple supports **SPTM** (Secure Page Table Monitor), which **replaces PPL** for page table protections.
- Apple inaelezea katika nyaraka: “Page Protection Layer (PPL) and Secure Page Table Monitor (SPTM) enforce execution of signed and trusted code … PPL manages the page table permission overrides … Secure Page Table Monitor replaces PPL on supported platforms.”
- The SPTM architecture likely shifts more policy enforcement into a higher-privileged monitor outside kernel control, further reducing the trust boundary.

### MTE | EMTE | MIE

Hapa kuna maelezo ya juu ya jinsi EMTE inavyofanya kazi chini ya mpangilio wa Apple’s MIE:

1. **Ugawaji wa tag**
- Wakati memory inagawanywa (km. katika kernel au user space kupitia secure allocators), kwa block hiyo hutolewa **secret tag**.
- Pointer inayorudishwa kwa user au kernel ina tag hiyo katika high bits (ikitumia TBI / top byte ignore mechanisms).

2. **Uhakiki wa tag wakati wa upatikanaji**
- Kila mara inapotekelezwa load au store kwa kutumia pointer, hardware inahakiki kwamba tag ya pointer inaendana na tag ya block ya memory (allocation tag). Ikiwa haifanani, inaonyesha fault mara moja (kwa sababu ni synchronous).
- Kwa sababu ni synchronous, hakuna dirisha la “delayed detection”.

3. **Kure-tagi wakati wa free / reuse**
- Wakati memory inatolewa (freed), allocator hubadilisha tag ya block (hivyo pointers za zamani zilizo na tags za zamani hazitawiana tena).
- Use-after-free pointer kwa hivyo itakuwa na tag iliyokuwa zamani na itaonyesha mismatch inapofikiwa.

4. **Tofauti za tag za majirani ili kugundua overflows**
- Mgao jirani hupatiwa tags tofauti. Ikiwa buffer overflow itaporomoka ndani ya memory ya jirani, mismatch ya tag itasababisha fault.
- Hii ni nguvu hasa katika kugundua overflows ndogo zinazovuka boundary.

5. **Utekelezaji wa usiri wa tag**
- Apple lazima izuie tag values being leaked (kwa sababu ikiwa mshambuliaji atajua tag, wanaweza kutengeneza pointers zenye tags sahihi).
- Wanajumuisha kinga (microarchitectural / speculative controls) ili kuepuka side-channel leakage ya bit za tag.

6. **Uunganishaji wa Kernel na user-space**
- Apple inatumia EMTE si tu katika user-space bali pia katika kernel / OS-critical components (kwa ajili ya kumlinda kernel dhidi ya memory corruption).
- Hardware/OS inahakikisha sheria za tag zinafanya kazi hata wakati kernel inatekeleza kwa niaba ya user space.

<details>
<summary>Mfano</summary>
```
Allocate A = 0x1000, assign tag T1
Allocate B = 0x2000, assign tag T2

// pointer P points into A with tag T1
P = (T1 << 56) | 0x1000

// Valid store
*(P + offset) = value // tag T1 matches allocation → allowed

// Overflow attempt: P’ = P + size_of_A (into B region)
*(P' + delta) = value
→ pointer includes tag T1 but memory block has tag T2 → mismatch → fault

// Free A, allocator retags it to T3
free(A)

// Use-after-free:
*(P) = value
→ pointer still has old tag T1, memory region is now T3 → mismatch → fault
```
</details>

#### Mipaka na changamoto

- **Intrablock overflows**: Ikiwa overflow inabaki ndani ya uteuzi uleule (haitavuka mpaka) na tag inabaki ileile, utofauti wa tag hauuoni.
- **Tag width limitation**: Bit chache tu (km. 4 bits, au domain ndogo) zinapatikana kwa tag—nafasi ya jina ni ndogo.
- **Side-channel leaks**: Ikiwa bits za tag zinaweza ku-leak (kupitia cache / speculative execution), mshambuliaji anaweza kujua tags halali na kuiruka. Apple inatekeleza udhibiti wa usiri wa tag ili kupunguza hili.
- **Performance overhead**: Ukaguzi wa tag kila load/store unaongeza gharama; Apple lazima ioptimize hardware ili kupunguza overhead.
- **Compatibility & fallback**: Kwenye hardware ya zamani au sehemu ambazo hazina support ya EMTE, lazima kuwe na fallback. Apple inadai MIE imewezeshwa tu kwenye vifaa vinavyoiunga mkono.
- **Complex allocator logic**: Allocator lazima idhibiti tags, retagging, kuoanisha mipaka, na kuepuka migongano ya mis-tag. Mende katika mantiki ya allocator yanaweza kuleta uharibifu wa usalama.
- **Mixed memory / hybrid areas**: Kumbukumbu baadhi inaweza kubaki bila tag (legacy), ikifanya utangamano uwe mgumu zaidi.
- **Speculative / transient attacks**: Kama kwa ulinzi wa microarchitectural nyingi, speculative execution au micro-op fusions zinaweza kupitisha ukaguzi transient au ku-leak bits za tag.
- **Limited to supported regions**: Apple inaweza kufuata EMTE tu katika maeneo maalumu, yanayohisiwa kuwa ya hatari (kernel, subsystems za usalama), si kwa ujumla.

---

## Maboresho muhimu / tofauti ikilinganishwa na MTE ya kawaida

Hapa ni maboresho na mabadiliko ambayo Apple inasisitiza:

| Feature | Original MTE | EMTE (Apple’s enhanced) / MIE |
|---|---|---|
| **Check mode** | Inaunga mkono modos synchronous na asynchronous. Katika async, tag mismatches hutoroshwa baadaye (kicheleweshwa) | Apple inasisitiza **synchronous mode** kwa default—tag mismatches zinagunduliwa mara moja, hakuna dirisha la kuchelewa/mbio. |
| **Coverage of non-tagged memory** | Upatikanaji wa non-tagged memory (km. globals) yanaweza kupitisha ukaguzi katika utekelezwaji fulani | EMTE inahitaji kwamba upatikanaji kutoka eneo lililo tagged kwenda memory isiyo tagged pia uthibitishe ufahamu wa tag, ikifanya iwe ngumu kugeuza kwa kuchanganya allocations. |
| **Tag confidentiality / secrecy** | Tags zinaweza kuonekana au ku-leak kupitia side channels | Apple inaongeza **Tag Confidentiality Enforcement**, inayojaribu kuzuia ku-leak kwa thamani za tag (kupitia speculative side-channels n.k.). |
| **Allocator integration & retagging** | MTE inaacha sehemu kubwa ya mantiki ya allocator kwa software | Secure typed allocators za Apple (kalloc_type, xzone malloc, n.k.) zinaunganishwa na EMTE: wakati memory inatolewa au kuachwa, tags zinadhibitiwa kwa azimio ndogo. |
| **Always-on by default** | Katika majukwaa mengi, MTE ni hiari au imezimwa kwa default | Apple inoxidable EMTE / MIE kwa default kwenye hardware zinazounga mkono (km. iPhone 17 / A19) kwa kernel na mchakato mwingi wa user-space. |

Kwa sababu Apple inadhibiti hardware na software stack, inaweza kutekeleza EMTE kwa ukali, kuepuka matatizo ya performance, na kufunga nafsi za side-channel.

---

## Jinsi EMTE inavyofanya kazi kwa vitendo (Apple / MIE)

Hapa kuna maelezo ya kiwango cha juu ya jinsi EMTE inavyofanya kazi chini ya usanidi wa Apple MIE:

1. **Tag assignment**
- Wakati memory inatolewa (km. ndani ya kernel au user space kupitia secure allocators), `secret tag` imeteuliwa kwa block hiyo.
- Pointer inarudishwa kwa user au kernel ina tag hiyo katika bits za juu (ikitumia TBI / top byte ignore mechanisms).

2. **Tag checking on access**
- Kila mara load au store inapotekelezwa kwa kutumia pointer, hardware inakagua kwamba tag ya pointer inalingana na tag ya block ya memory (allocation tag). Ikiwa haifanani, inatoa fault mara moja (kwa sababu synchronous).
- Kwa kuwa ni synchronous, hakuna dirisha la “delayed detection”.

3. **Retagging on free / reuse**
- Wakati memory inafunguliwa (freed), allocator hubadilisha tag ya block (hivyo pointers za zamani zenye tags za zamani hazitalingana tena).
- Use-after-free pointer kwa hivyo itakuwa na tag iliyopoteza muda na itashindwa wakati wa upatikanaji.

4. **Neighbor-tag differentiation to catch overflows**
- Allocations zilizo karibu zinaruhusiwa kuwa na tags tofauti. Ikiwa buffer overflow itatoka na kuingia kwenye memory ya jirani, tag mismatch itasababisha fault.
- Hii ni nguvu hasa katika kugundua overflows ndogo zinazovuka mipaka.

5. **Tag confidentiality enforcement**
- Apple lazima iepushe thamani za tag ku-leak (kwa sababu ikiwa mshambuliaji atajua tag, wanaweza kutengeneza pointers zenye tags sahihi).
- Wanajumuisha ulinzi (microarchitectural / speculative controls) ili kuepuka ku-leak kwa bits za tag.

6. **Kernel and user-space integration**
- Apple inatumia EMTE si tu katika user-space bali pia ndani ya kernel / vipengele muhimu vya OS (kukuza kernel dhidi ya memory corruption).
- Hardware/OS inahakikisha sheria za tag zinatumika hata wakati kernel inafanya kazi kwa niaba ya user space.

Kwa kuwa EMTE imejengwa ndani ya MIE, Apple inatumia EMTE katika synchronous mode katika maeneo muhimu ya mashambulio, sio kama chaguo la kujiandikisha au kama mode ya debugging.

---

## Exception handling in XNU

Wakati kutokea **exception** (mfano, `EXC_BAD_ACCESS`, `EXC_BAD_INSTRUCTION`, `EXC_CRASH`, `EXC_ARM_PAC`, n.k.), safu ya **Mach layer** ya kernel ya XNU ndiyo inawajibika kukamata kabla haijabadilika kuwa signal ya mtindo wa UNIX (kama `SIGSEGV`, `SIGBUS`, `SIGILL`, ...).

Mchakato huu unajumuisha tabaka kadhaa za kusambaza na kushughulikia exception kabla ya kufika user space au kubadilishwa kuwa BSD signal.

### Exception Flow (High-Level)

1.  **CPU inasababisha exception synchronous** (km. dereference ya pointer isiyo halali, PAC failure, instruction haramu, n.k.).

2.  **Low-level trap handler** inaendesha (`trap.c`, `exception.c` katika chanzo cha XNU).

3.  Trap handler inaitisha **`exception_triage()`**, miongoni mwa nyenzo za msingi za kushughulikia Mach exception.

4.  `exception_triage()` inaamua jinsi ya kusafirisha exception:

-   Kwanza kwa **thread's exception port**.

-   Kisha kwa **task's exception port**.

-   Kisha kwa **host's exception port** (mara nyingi `launchd` au `ReportCrash`).

Ikiwa hakuna moja ya hizi port inashughulikia exception, kernel inaweza:

-   **Kuibadilisha kuwa BSD signal** (kwa michakato ya user-space).

-   **Kusababisha panic** (kwa exceptions za kernel-space).


### Core Function: `exception_triage()`

Function `exception_triage()` inasafirisha Mach exceptions juu ya mkataba wa handlers hadi mmoja atakayeshughulikia au mpaka itakapotajwa kuwa ya hatari. Imefafanuliwa katika `osfmk/kern/exception.c`.
```c
void exception_triage(exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt);
```
**Mtiririko wa Kawaida wa Wito:**

`exception_triage()
└── exception_deliver()
├── exception_deliver_thread()
├── exception_deliver_task()
└── exception_deliver_host()`

Ikiwa zote zitashindwa → zinashughulikiwa na `bsd_exception()` → zimetafsiriwa kuwa ishara kama `SIGSEGV`.


### Bandari za Exception

Kila Mach object (thread, task, host) inaweza kusajili **exception ports**, ambazo ujumbe za exception hutumwa.

Zimefafanuliwa na API:
```
task_set_exception_ports()
thread_set_exception_ports()
host_set_exception_ports()
```
Kila exception port ina:

-   A **mask** (ni exceptions gani inataka kupokea)
-   A **port name** (Mach port ya kupokea messages)
-   A **behavior** (jinsi kernel inavyotuma message)
-   A **flavor** (ni thread state gani kujumuisha)


### Debuggers and Exception Handling

A **debugger** (e.g., LLDB) inaweka **exception port** kwenye target task au thread, kwa kawaida kwa kutumia `task_set_exception_ports()`.

**Wakati exception inapotokea:**

-   The Mach message inatumwa kwa mchakato wa debugger.
-   The debugger inaweza kuamua **handle** (resume, modify registers, skip instruction) au **not handle** exception.
-   Ikiwa debugger haifanyi handle, exception husambaa kwa ngazi inayofuata (task → host).


### Flow of `EXC_BAD_ACCESS`

1.  Thread inafanya dereference ya pointer isiyo halali → CPU inaleta Data Abort.

2.  Kernel trap handler inaita `exception_triage(EXC_BAD_ACCESS, ...)`.

3.  Ujumbe umetumwa kwa:

-   Thread port → (debugger inaweza kukamata breakpoint).

-   Ikiwa debugger inapuuza → Task port → (process-level handler).

-   Ikiwa inapuuzwa pia → Host port (kawaida ReportCrash).

4.  Kama hakuna anayehandle → `bsd_exception()` hubadilisha kuwa `SIGSEGV`.


### PAC Exceptions

Wakati **Pointer Authentication** (PAC) inashindwa (signature mismatch), **special Mach exception** inafufuliwa:

-   **`EXC_ARM_PAC`** (type)
-   Codes zinaweza kujumuisha taarifa (e.g., key type, pointer type).

Ikiwa binary ina flag **`TFRO_PAC_EXC_FATAL`**, kernel itachukulia PAC failures kama **fatal**, ikiruka interception ya debugger. Hii ni kuzuia attackers kutumia debuggers kupitisha PAC checks na imewezeshwa kwa **platform binaries**.


### Software Breakpoints

A software breakpoint (`int3` on x86, `brk` on ARM64) hufanywa kwa **kusababisha hitilafu ya kusudi**.\
The debugger inakamata hili kupitia exception port:

-   Hubadilisha instruction pointer au memory.
-   Inarejesha instruction ya awali.
-   Inaendelea execution.

Mekanismo huo huo ndiyo unayokuwezesha "kukamata" PAC exception --- **isipokuwa `TFRO_PAC_EXC_FATAL`** imewekwa, ambapo haitawahi kufika kwa debugger.


### Conversion to BSD Signals

Ikiwa hakuna handler anayekubali exception:

-   Kernel inaita `task_exception_notify() → bsd_exception()`.

-   Hii inaweka Mach exceptions kwa signals:

| Mach Exception | Signal |
| --- | --- |
| EXC_BAD_ACCESS | SIGSEGV or SIGBUS |
| EXC_BAD_INSTRUCTION | SIGILL |
| EXC_ARITHMETIC | SIGFPE |
| EXC_SOFTWARE | SIGTRAP |
| EXC_BREAKPOINT | SIGTRAP |
| EXC_CRASH | SIGKILL |
| EXC_ARM_PAC | SIGILL (on non-fatal) |


### Key Files in XNU Source

-   `osfmk/kern/exception.c` → Msingi wa `exception_triage()`, `exception_deliver_*()`.

-   `bsd/kern/kern_sig.c` → Mantiki ya signal delivery.

-   `osfmk/arm64/trap.c` → Low-level trap handlers.

-   `osfmk/mach/exc.h` → Exception codes and structures.

-   `osfmk/kern/task.c` → Mpangilio wa task exception port.

---

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

Kernel ilitumia **zone allocator** (`kalloc`) iliyogawanywa katika fixed-size "zones." Kila zone ilihifadhi tu allocations za daraja moja ya ukubwa.

From the screenshot:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Very small kernel structs, pointers.                                        |
| `default.kalloc.32`  | 32 bytes     | Small structs, object headers.                                              |
| `default.kalloc.64`  | 64 bytes     | IPC messages, tiny kernel buffers.                                          |
| `default.kalloc.128` | 128 bytes    | Medium objects like parts of `OSObject`.                                    |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Large structures, IOSurface/graphics metadata.                              |

Jinsi ilivyofanya kazi:
- Kila ombi la allocation linazungushwa hadi ukubwa wa zone inayokaribia.
(Mf., ombi la 50-byte linaingia katika `kalloc.64` zone).
- Memory katika kila zone ilihifadhiwa katika **free list** — chunks zilizo freed na kernel zilirudi kwenye zone hiyo.
- Ikiwa ungefanya overflow ya buffer ya 64-byte, ungeandika juu ya **next object in the same zone**.

Hivyo ndivyo **heap spraying / feng shui** ilivyokuwa yenye ufanisi: unaweza kutabiri majirani wa object kwa kupiga allocations za daraja moja ya ukubwa.

### The freelist

Ndani ya kila kalloc zone, vitu vilivyofreed havirudishwi moja kwa moja kwa system — viliingia kwenye freelist, linked list ya vipande vinavyopatikana.

- Wakati chunk ilipopigwa free, kernel iliandika pointer mwanzoni mwa chunk hiyo → anwani ya next free chunk katika zone hiyo.

- Zone iliweka HEAD pointer kwa chunk ya kwanza free.

- Allocation daima ilitumia HEAD ya sasa:

1. Pop HEAD (kurudisha memory hiyo kwa caller).

2. Sasisha HEAD = HEAD->next (iliyo stored katika header ya freed chunk).

- Freeing ilisukuma vipande kurudi:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

Hivyo freelist ilikuwa linked list iliyojengwa ndani ya memory iliyofreed yenyewe.

Normal state:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Exploiting the freelist

Kwa sababu 8 bytes za kwanza za free chunk ni freelist pointer, mshambuliaji anaweza kuharibu hiyo:

1. **Heap overflow** katika adjacent freed chunk → overwrite its “next” pointer.

2. **Use-after-free** write into a freed object → overwrite its “next” pointer.

Kisha, kwenye allocation inayofuata ya ukubwa huo:

- The allocator pops the corrupted chunk.

- Inafuata attacker-supplied “next” pointer.

- Inarudisha pointer kwa arbitrary memory, ikiruhusu fake object primitives au targeted overwrite.

Mfano wa kuona wa freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
This freelist design made exploitation highly effective pre-hardening: predictable neighbors from heap sprays, raw pointer freelist links, and no type separation allowed attackers to escalate UAF/overflow bugs into arbitrary kernel memory control.

### Heap Grooming / Feng Shui
Lengo la heap grooming ni **kuunda mpangilio wa heap** ili wakati mwizi atakapoanzisha overflow au use-after-free, kitu lengwa (mjeruhi) kiwe karibu kabisa na kitu kinachodhibitiwa na mwizi.\
Kwa njia hiyo, wakati uharibifu wa kumbukumbu unapotokea, mwizi anaweza kubadilisha kwa uhakika kitu lengwa kwa data anayotaka.

**Hatua:**

1. Spray allocations (fill the holes)
- Kwa muda, kernel heap hupata fragmentation: maeneo fulani yana mashimo ambapo vitu vya zamani vilifunguliwa (freed).
- Mwizi awali hufanya allocations nyingi za dummy ili kujaza mabeghi haya, hivyo heap inakuwa “imejaa” na inayotarajiwa.

2. Force new pages
- Mara mashimo yanapojazwa, allocations zinazofuata lazima zitoke kwenye pages mpya zinazoongezwa kwenye zone.
- Pages safi zinamaanisha vitu vitakusanyika pamoja, si kugawanywa kwenye memory iliyotangazwa.
- Hii inampa mwizi udhibiti bora wa majirani.

3. Place attacker objects
- Mwizi sasa anafanya spray tena, akitengeneza vitu vingi vinavyodhibitiwa na mwizi katika hizo pages mpya.
- Vitu hivi vina ukubwa na nafasi zinazotarajiwa (kwa kuwa vyote vinatoka kwenye zone moja).

4. Free a controlled object (make a gap)
- Mwizi kwa makusudi anafungua moja ya vitu vyake.
- Hii inaunda “tundu” ndani ya heap, ambalo allocator itautumia kwa allocation inayofuata ya ukubwa huo.

5. Victim object lands in the hole
- Mwizi anasababisha kernel kuallocate kitu lengwa (kile wanachotaka kuharibu).
- Kwa kuwa tundu ndio slot ya kwanza inapatikana kwenye freelist, kitu lengwa kimewekwa mahali precisely pale alipofungua mwizi kitu chake.

6. Overflow / UAF into victim
- Sasa mwizi ana vitu vinavyodhibitiwa karibu na victim.
- Kwa kuoverflow kutoka kwa mojawapo ya vitu vyake (au kutumia tena kitu kilichofunguliwa), anaweza kwa uhakika kuandika juu ya fields za memory za victim kwa thamani walizochagua.

**Kwanini inafanya kazi**:

- Zone allocator predictability: allocations za ukubwa sawa daima zinatoka kwenye zone ile ile.
- Freelist behavior: allocations mpya zinatumia chunk iliyoachiliwa hivi karibuni kwanza.
- Heap sprays: mwizi anajaza memory na content inayotarajiwa na kudhibiti layout.
- Matokeo: mwizi anadhibiti wapi kitu lengwa kitakapowekwa na ni data gani itakaa karibu nacho.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple iliyafanya allocator kuwa ngumu zaidi na kufanya **heap grooming iwe ngumu sana**:

### 1. From Classic kalloc to kalloc_type
- **Before**: zone moja `kalloc.<size>` ilikuwepo kwa kila size class (16, 32, 64, … 1280, n.k.). Kila kitu cha ukubwa huo kiliwekwa pale → vitu vya mwizi vinaweza kukaa kando ya vitu vya kernel yenye privilage.
- **Now**:
- Kernel objects zinallocate kutoka kwa **typed zones** (`kalloc_type`).
- Kila aina ya object (mf. `ipc_port_t`, `task_t`, `OSString`, `OSData`) ina zone yake maalum, hata kama zina ukubwa ule ule.
- Mapping kati ya object type ↔ zone inatengenezwa kutoka kwa **kalloc_type system** wakati wa compile.

Mwizi hawezi tena kuhakikisha kuwa data iliyodhibitiwa (`OSData`) itafikia karibu na vitu nyeti za kernel (`task_t`) ambazo zina ukubwa ule ule.

### 2. Slabs and Per-CPU Caches
- Heap imegawanywa kuwa **slabs** (pages za memory zilizogawanywa katika chunks za ukubwa thabiti kwa zone hiyo).
- Kila zone ina **per-CPU cache** ili kupunguza contention.
- Mchakato wa allocation:
1. Jaribu per-CPU cache.
2. Ikiwa tupu, chukua kutoka global freelist.
3. Ikiwa freelist ni tupu, allocate slab mpya (ukurasa mmoja au zaidi).
- **Faida**: usambazaji huu wa kazi unafanya heap sprays zisitabirike kwa urahisi, kwa kuwa allocations zinaweza kutolewa kutoka caches za CPU tofauti.

### 3. Randomization inside zones
- Ndani ya zone, elements zilizoachiliwa hazirudishiwi kwa FIFO/LIFO rahisi.
- XNU ya kisasa inatumia **encoded freelist pointers** (safe-linking kama Linux, iliyoanzishwa ~iOS 14).
- Kila freelist pointer ime **XOR-encoded** na cookie ya siri per-zone.
- Hii inazuia mwizi kuunda freelist pointer bandia kama itapata write primitive.
- Baadhi ya allocations zime **randomized katika placement ndani ya slab**, hivyo spraying haihakikishi adjacency.

### 4. Guarded Allocations
- Vitu fulani muhimu za kernel (mf., credentials, task structures) zinallocate katika **guarded zones**.
- Zones hizi zinaweka **guard pages** (memory isiyopangwa) kati ya slabs au kutumia **redzones** karibu na vitu.
- Overflow yoyote kwa guard page husababisha fault → panic mara moja badala ya corruption kimya.

### 5. Page Protection Layer (PPL) and SPTM
- Hata ukidhibiti object iliyoachiliwa, huwezi kuhariri sehemu zote za kernel memory:
- **PPL (Page Protection Layer)** inahakikisha kuwa maeneo fulani (mf., code signing data, entitlements) ni **read-only** hata kwa kernel yenyewe.
- Kwenye **A15/M2+ devices**, jukumu hili limebadilishwa/kuongezewa na **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- Layer hizi zinazotekelezwa kwa hardware zinamaanisha mwizi hawawezi kukuza kutoka heap corruption moja hadi kufanya patch arbitrary kwenye miundo muhimu ya usalama.
- **(Added / Enhanced)**: pia, **PAC (Pointer Authentication Codes)** inatumiwa kwenye kernel kulinda pointers (hasa function pointers, vtables) hivyo kutengeneza au kuharibu hizo inakuwa ngumu zaidi.
- **(Added / Enhanced)**: zones zinaweza kutekeleza **zone_require / zone enforcement**, yaani kwamba object iliyotolewa inaweza tu kurudishwa kupitia zone yake ya aina sahihi; frees za cross-zone zisizo halali zinaweza kusababisha panic au kukataliwa. (Apple inataja hili katika post zao za memory safety)

### 6. Large Allocations
- Si allocations zote hupitia `kalloc_type`.
- Maombi makubwa sana (juu ya ~16 KB) hupita typed zones na hutolewa moja kwa moja kutoka **kernel VM (kmem)** kupitia page allocations.
- Hizi si za utabiri sana, lakini pia hazina exploitable sana, kwa kuwa hazishiriki slabs na vitu vingine.

### 7. Allocation Patterns Attackers Target
Hata na kinga hizi, mwizi bado wanatafuta:
- **Reference count objects**: ikiwa unaweza kuingilia counters za retain/release, unaweza kusababisha use-after-free.
- **Objects with function pointers (vtables)**: kuharibu moja bado huleta control flow.
- **Shared memory objects (IOSurface, Mach ports)**: bado ni malengo kwa kuwa ni daraja kati ya user ↔ kernel.

Lakini — tofauti na zamani — huwezi tu ku-spray `OSData` na kutarajia ije karibu na `task_t`. Unahitaji **bugs za type-specific** au **info leaks** ili kufanikiwa.

### Example: Allocation Flow in Modern Heap

Suppose userspace calls into IOKit to allocate an `OSData` object:

1. **Type lookup** → `OSData` maps to `kalloc_type_osdata` zone (size 64 bytes).
2. Check per-CPU cache for free elements.
- If found → return one.
- If empty → go to global freelist.
- If freelist empty → allocate a new slab (page of 4KB → 64 chunks of 64 bytes).
3. Return chunk to caller.

**Freelist pointer protection**:
- Kila chunk iliyofunguliwa inaweka address ya chunk inayofuata ya bure, lakini imekodishwa na key ya siri.
- Kuandika juu ya field hiyo na data ya mwizi haitafanyi kazi isipokuwa unajua key.

---

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages, and **PAC** protects pointers |
| Allocation reuse validation     | None (freelist pointers raw)                               | **zone_require / zone enforcement**             |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |
| Large allocations handling      | All small allocations managed equally                       | Large ones bypass zones → handled via VM         |

---

## Modern Userland Heap (iOS, macOS — type-aware / xzone malloc)

Katika matoleo ya hivi karibuni ya Apple OS (hasa iOS 17+), Apple ilianzisha allocator ya userland yenye usalama zaidi, **xzone malloc** (XZM). Hii ni analog ya user-space kwa kernel’s `kalloc_type`, ikitumia type awareness, metadata isolation, na memory tagging safeguards.

### Goals & Design Principles

- **Type segregation / type awareness**: kugawa allocations kwa aina au matumizi (pointer vs data) ili kuzuia type confusion na cross-type reuse.
- **Metadata isolation**: kutenganisha metadata ya heap (mf. free lists, size/state bits) kutoka kwenye payloads za vitu ili out-of-bounds writes zisiharibu metadata.
- **Guard pages / redzones**: kuweka pages zisizopangwa au padding karibu na allocations ili kugundua overflows.
- **Memory tagging (EMTE / MIE)**: kufanya kazi pamoja na hardware tagging kugundua use-after-free, out-of-bounds, na upatikanaji batili.
- **Scalable performance**: kudumisha overhead ndogo, kuepuka fragmentation kubwa, na kuunga mkono allocations nyingi kwa sekunde kwa latency ndogo.

### Architecture & Components

Hapa kuna vipengele vikuu vya xzone allocator:

#### Segment Groups & Zones

- **Segment groups** hugitangaza address space kwa vikundi vya matumizi: mf. `data`, `pointer_xzones`, `data_large`, `pointer_large`.
- Kila segment group ina **segments** (ranges za VM) zinazoweka allocations za kundi hilo.
- Kila segment ina **metadata slab** (edanoni VM tofauti) inayohifadhi metadata (mf. free/used bits, size classes) kwa segment hiyo. Hii **out-of-line (OOL) metadata** inahakikisha metadata haipungwi pamoja na payloads za vitu, ikipunguza corruption kutokana na overflows.
- Segments hugawanywa katika **chunks** (slices) ambazo kwa upande zinagawanywa kuwa **blocks** (units za allocation). Chunk imefungamana na size class maalum na segment group (yaani blocks zote ndani ya chunk zinashiriki size & category moja).
- Kwa allocations ndogo / za kati, itatumia chunks za ukubwa thabiti; kwa kubwa/huge, inaweza kujibu kwa map.

#### Chunks & Blocks

- **Chunk** ni eneo (mara nyingi kurasa kadhaa) iliyotengwa kwa allocations za class moja ndani ya group.
- Ndani ya chunk, **blocks** ni slots zinapatikana kwa allocations. Blocks zilizofunguliwa zinazosimamiwa kupitia metadata slab — mf. kwa bitmaps au free lists zilizo kwenye out-of-line.
- Kati ya chunks (au ndani), **guard slices / guard pages** zinaweza kuingizwa (mf. slices zisizopangwa) ili kugundua out-of-bounds writes.

#### Type / Type ID

- Kila allocation site (au wito wa malloc, calloc, n.k.) inaambatana na **type identifier** (`malloc_type_id_t`) ambayo inaelezea aina ya kitu kinachotolewa. Type ID hiyo inapitishwa kwa allocator, ambayo inaitumia kuchagua zone / segment ambayo itaweza allocation.
- Kwa sababu ya hili, hata kama allocations mbili zina ukubwa ule ule, zinaweza kwenda kwenye zones tofauti kabisa ikiwa types zao zinatofautiana.
- Katika toleo za awali za iOS 17, APIs zote (mf. CFAllocator) hazikuwa fully type-aware; Apple ilitatua baadhi ya udhaifu huo katika iOS 18.

---

### Allocation & Freeing Workflow

Hapa ni mtiririko wa juu wa jinsi allocation na deallocation zinavyofanya kazi katika xzone:

1. **malloc / calloc / realloc / typed alloc** inaitwa na size na type ID.
2. Allocator inatumia **type ID** kuchagua segment group / zone sahihi.
3. Ndani ya zone/segment, inatafuta chunk yenye free blocks za size iliyotakiwa.
- Inaweza kushauriana na **local caches / per-thread pools** au **free block lists** kutoka metadata.
- Ikiwa hakuna free block inapatikana, inaweza allocate chunk mpya katika zone hiyo.
4. Metadata slab inasasishwa (free bit inafutwa, bookkeeping).
5. Ikiwa memory tagging (EMTE) iko, block iliyorejeshwa inapata **tag**, na metadata inasasishwa kuonyesha hali yake “live”.
6. Wakati `free()` inaitwa:
- Block inatambulishwa kama freed katika metadata (kupitia OOL slab).
- Block inaweza kuwekwa kwenye free list au kuhifadhiwa kwa reuse.
- Hiari, content za block zinaweza kufutwa au ku-poison ili kupunguza data leaks au exploitation ya use-after-free.
- Hardware tag inayohusishwa na block inaweza kushindwa au ku-re-tag.
- Ikiwa chunk yote inakuwa free (blocks zote zimetolewa), allocator anaweza **reclaim** chunk hiyo (ku-is-map au kurudisha kwa OS) wakati kuna pressure ya memory.

---

### Security Features & Hardening

Hizi ni defenses zilizojengwa ndani ya xzone ya userland:

| Feature | Purpose | Notes |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | Prevent overflow from corrupting metadata | Metadata lives in separate VM region (metadata slab)|
| **Guard pages / unmapped slices** | Catch out-of-bounds writes | Helps detect buffer overflows rather than silently corrupting adjacent blocks|
| **Type-based segregation** | Prevent cross-type reuse & type confusion | Even same-size allocations from different types go to different zones|
| **Memory Tagging (EMTE / MIE)** | Detect invalid access, stale references, OOB, UAF | xzone works in concert with hardware EMTE in synchronous mode (“Memory Integrity Enforcement”)|
| **Delayed reuse / poisoning / zap** | Reduce chance of use-after-free exploitation | Freed blocks may be poisoned, zeroed, or quarantined before reuse |
| **Chunk reclamation / dynamic unmapping** | Reduce memory waste and fragmentation | Entire chunks may be unmapped when unused |
| **Randomization / placement variation** | Prevent deterministic adjacency | Blocks in a chunk and chunk selection may have randomized aspects |
| **Segregation of “data-only” allocations** | Separate allocations that don’t store pointers | Reduces attacker control over metadata or control fields|

---

### Interaction with Memory Integrity Enforcement (MIE / EMTE)

- MIE ya Apple (Memory Integrity Enforcement) ni mfumo wa hardware + OS unaoleta **Enhanced Memory Tagging Extension (EMTE)** katika mode ya kuwa daima tuli, synchronous, katika maeneo makuu ya shambulio.
- xzone allocator ni msingi wa MIE katika user space: allocations zinazofanywa kupitia xzone zinapata tags, na upatikanaji unakaguliwa na hardware.
- Katika MIE, allocator, utendaji wa ugawaji tags, usimamizi wa metadata, na enforcement ya usiri wa tags vimeunganishwa kuhakikisha kuwa makosa ya memory (mf. stale reads, OOB, UAF) yanagunduliwa mara moja, sio kutumika baadaye.

---

If you like, I can also generate a cheat-sheet or diagram of xzone internals for your book. Do you want me to do that next?
::contentReference[oai:20]{index=20}


---

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual] and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


## JSKit-Based Safari Chains and PREYHUNTER Stagers

### Renderer RCE abstraction with JSKit
- **Reusable entry**: Recent in-the-wild chains abused a WebKit JIT bug (patched as CVE-2023-41993) purely to gain JavaScript-level arbitrary read/write. The exploit immediately pivots into a purchased framework called **JSKit**, so any future Safari bug only needs to deliver the same primitive.
- **Version abstraction & PAC bypasses**: JSKit bundles support for a wide range of iOS releases together with multiple, selectable Pointer Authentication Code bypass modules. The framework fingerprints the target build, selects the appropriate PAC bypass logic, and verifies every step (primitive validation, shellcode launch) before progressing.
- **Manual Mach-O mapping**: JSKit parses Mach-O headers directly from memory, resolves the symbols it needs inside dyld-cached images, and can manually map additional Mach-O payloads without writing them to disk. This keeps the renderer process in-memory only and evades code-signature checks tied to filesystem artifacts.
- **Portfolio model**: Debug strings such as *"exploit number 7"* show that the suppliers maintain multiple interchangeable WebKit exploits. Once the JS primitive matches JSKit’s interface, the rest of the chain is unchanged across campaigns.

### Kernel bridge: IPC UAF -> code-sign bypass pattern
- **Kernel IPC UAF (CVE-2023-41992)**: The second stage, still running inside the Safari context, triggers a kernel use-after-free in IPC code, re-allocates the freed object from userland, and abuses the dangling pointers to pivot into arbitrary kernel read/write. The stage also reuses PAC bypass material previously computed by JSKit instead of re-deriving it.
- **Code-signing bypass (CVE-2023-41991)**: With kernel R/W available, the exploit patches the trust cache / code-signing structures so unsigned payloads execute as `system`. The stage then exposes a lightweight kernel R/W service to later payloads.
- **Composed pattern**: This chain demonstrates a reusable recipe that defenders should expect going forward:
```
WebKit renderer RCE -> kernel IPC UAF -> kernel arbitrary R/W -> code-sign bypass -> unsigned system stager
```
### PREYHUNTER helper & watcher modules
- **Watcher anti-analysis**: Binary maalum ya watcher huendelea kufanya profiling ya kifaa na kusitisha kill-chain wakati mazingira ya utafiti yanapotambuliwa. Inachunguza `security.mac.amfi.developer_mode_status`, uwepo wa console ya `diagnosticd`, locales `US` au `IL`, alama za jailbreak kama **Cydia**, michakato kama `bash`, `tcpdump`, `frida`, `sshd`, au `checkrain`, mobile AV apps (McAfee, AvastMobileSecurity, NortonMobileSecurity), mipangilio maalum ya proxy ya HTTP, na root CA maalum. Kushindwa kwa ukaguzi wowote kunazuia utoaji wa payload zaidi.
- **Helper surveillance hooks**: Komponenti ya helper huwasiliana na hatua nyingine kupitia `/tmp/helper.sock`, kisha inapakia seti za hook zinazoitwa **DMHooker** na **UMHooker**. Hook hizi zinatangaza path za sauti za VOIP (rekodi zinawekwa chini ya `/private/var/tmp/l/voip_%lu_%u_PART.m4a`), hutekeleza keylogger ya mfumo mzima, zinachukua picha bila UI, na ku-hook SpringBoard ili kuzizuia notifications ambazo vitendo hivyo kawaida vingeingiza. Kwa hivyo helper inafanya kazi kama safu ya uthibitisho ya kificho + ufuatiliaji mwepesi kabla implants nzito kama Predator hazijawekwa.

### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

## Marejeleo

- [Google Threat Intelligence – Intellexa zero-day exploits continue](https://cloud.google.com/blog/topics/threat-intelligence/intellexa-zero-day-exploits-continue)

{{#include ../../banners/hacktricks-training.md}}
