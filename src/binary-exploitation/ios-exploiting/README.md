# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

- **Code Signing** στο iOS λειτουργεί απαιτώντας κάθε κομμάτι εκτελέσιμου κώδικα (apps, libraries, extensions, κ.λπ.) να είναι κρυπτογραφικά υπογεγραμμένο με πιστοποιητικό που εκδίδεται από Apple. Όταν φορτώνεται κώδικας, το iOS επαληθεύει την ψηφιακή υπογραφή έναντι της αξιόπιστης root της Apple. Αν η υπογραφή είναι άκυρη, λείπει ή έχει τροποποιηθεί, το OS αρνείται να την εκτελέσει. Αυτό εμποδίζει τους επιτιθέμενους να εισάγουν κακόβουλο κώδικα σε νόμιμες εφαρμογές ή να τρέχουν ανυπόγραφους δυαδικούς, σταματώντας στην πράξη τις περισσότερες αλυσίδες exploit που βασίζονται στην εκτέλεση αυθαίρετου ή τροποποιημένου κώδικα.
- **CoreTrust** είναι το υποσύστημα του iOS που είναι υπεύθυνο για την επιβολή του code signing σε runtime. Επαληθεύει απευθείας υπογραφές χρησιμοποιώντας το root πιστοποιητικό της Apple χωρίς να βασίζεται σε cached trust stores, που σημαίνει ότι μόνο binaries υπογεγραμμένα από την Apple (ή με έγκυρα entitlements) μπορούν να εκτελεστούν. Το CoreTrust εξασφαλίζει ότι ακόμα κι αν κάποιος αλλοιώσει μια app μετά την εγκατάσταση, τροποποιήσει system libraries ή προσπαθήσει να φορτώσει unsigned code, το σύστημα θα μπλοκάρει την εκτέλεση εκτός αν ο κώδικας παραμένει σωστά υπογεγραμμένος. Αυτή η αυστηρή επιβολή κλείνει πολλούς post-exploitation διαδρόμους που παλαιότερες εκδόσεις του iOS επέτρεπαν μέσω αδύνατων ή παρακαμπτόμενων ελέγχων υπογραφών.
- **Data Execution Prevention (DEP)** σηματοδοτεί περιοχές μνήμης ως non-executable εκτός αν περιέχουν ρητά κώδικα. Αυτό εμποδίζει τους επιτιθέμενους να εγχύσουν shellcode σε data regions (όπως stack ή heap) και να τον εκτελέσουν, αναγκάζοντάς τους να βασιστούν σε πιο σύνθετες τεχνικές όπως ROP (Return-Oriented Programming).
- **ASLR (Address Space Layout Randomization)** τυχαΐζει τις διευθύνσεις μνήμης για κώδικα, libraries, stack και heap κάθε φορά που τρέχει το σύστημα. Αυτό καθιστά πολύ δυσκολότερο για τους επιτιθέμενους να προβλέψουν πού βρίσκονται χρήσιμες εντολές ή gadgets, σπάζοντας πολλές αλυσίδες exploit που εξαρτώνται από στατικές διατάξεις μνήμης.
- **KASLR (Kernel ASLR)** εφαρμόζει την ίδια έννοια τυχαιοποίησης στον kernel του iOS. Με την ανακατέψη της base address του kernel σε κάθε εκκίνηση, εμποδίζει τους επιτιθέμενους να εντοπίσουν με αξιοπιστία kernel functions ή δομές, αυξάνοντας τη δυσκολία σε kernel-level exploits που διαφορετικά θα απέκτηναν πλήρη έλεγχο του συστήματος.
- **Kernel Patch Protection (KPP)** γνωστή και ως **AMCC (Apple Mobile File Integrity)** στο iOS, παρακολουθεί συνεχώς τις σελίδες κώδικα του kernel για να βεβαιωθεί ότι δεν έχουν τροποποιηθεί. Αν ανιχνευθεί οποιαδήποτε παραβίαση—όπως ένα exploit που προσπαθεί να αλλάξει kernel functions ή να εισάγει κακόβουλο κώδικα—η συσκευή θα πάθει panic και θα κάνει επανεκκίνηση. Αυτή η προστασία καθιστά πολύ πιο δύσκολα τα επίμονα kernel exploits, καθώς οι επιτιθέμενοι δεν μπορούν απλά να κάνουν hook ή patch σε kernel instructions χωρίς να προκαλέσουν κρασάρισμα του συστήματος.
- **Kernel Text Readonly Region (KTRR)** είναι μια hardware-based λειτουργία ασφάλειας που εισήχθη σε συσκευές iOS. Χρησιμοποιεί τον memory controller του CPU για να σημάνει το text section του kernel ως μόνιμα read-only μετά το boot. Μόλις κλειδωθεί, ούτε ο ίδιος ο kernel μπορεί να τροποποιήσει αυτή την περιοχή μνήμης. Αυτό αποτρέπει τους επιτιθέμενους—και ακόμα και privileged code—από το να κάνουν patch σε kernel instructions σε runtime, κλείνοντας μια σημαντική κατηγορία exploits που βασιζόταν στην άμεση τροποποίηση του kernel κώδικα.
- **Pointer Authentication Codes (PAC)** χρησιμοποιούν κρυπτογραφικές υπογραφές ενσωματωμένες σε αχρησιμοποίητα bits των pointers για να επαληθεύουν την ακεραιότητά τους πριν τη χρήση. Όταν δημιουργείται ένας pointer (όπως μια return address ή function pointer), η CPU τον υπογράφει με ένα secret key· πριν γίνει dereference, η CPU ελέγχει την υπογραφή. Αν ο pointer έχει παραποιηθεί, ο έλεγχος αποτυγχάνει και η εκτέλεση σταματά. Αυτό εμποδίζει τους επιτιθέμενους από το να πλαστογραφήσουν ή να επαναχρησιμοποιήσουν κατεστραμμένους pointers σε memory corruption exploits, κάνοντας τεχνικές όπως ROP ή JOP πολύ πιο δύσκολες να υλοποιηθούν αξιόπιστα.
- **Privilege Access never (PAN)** είναι μια hardware λειτουργία που αποτρέπει τον kernel (privileged mode) από το να έχει άμεση πρόσβαση σε user-space μνήμη εκτός αν ενεργοποιήσει ρητά αυτή την πρόσβαση. Αυτό σταματάει επιτιθέμενους που απέκτησαν kernel code execution από το να διαβάσουν ή να γράψουν εύκολα user memory για να κλιμακώσουν exploits ή να κλέψουν ευαίσθητα δεδομένα. Με την επιβολή αυστηρού διαχωρισμού, το PAN μειώνει τον αντίκτυπο kernel exploits και μπλοκάρει πολλές κοινές τεχνικές privilege-escalation.
- **Page Protection Layer (PPL)** είναι ένας μηχανισμός ασφάλειας στο iOS που προστατεύει κρίσιμες περιοχές μνήμης που διαχειρίζεται ο kernel, ειδικά αυτές που σχετίζονται με code signing και entitlements. Εφαρμόζει αυστηρές write protections χρησιμοποιώντας την MMU (Memory Management Unit) και πρόσθετους ελέγχους, εξασφαλίζοντας ότι ακόμα και privileged kernel code δεν μπορεί αυθαίρετα να τροποποιήσει ευαίσθητες σελίδες. Αυτό αποτρέπει επιτιθέμενους που αποκτούν kernel-level execution από το να παραποιήσουν security-critical δομές, κάνοντας την επιμονή και τις παρακαμπτήριες υπογραφών πολύ πιο δύσκολες.

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

Ο kernel χρησιμοποιούσε έναν **zone allocator** (`kalloc`) χωρισμένο σε ζώνες ("zones") με σταθερό μέγεθος.
Κάθε ζώνη αποθηκεύει μόνο allocations μιας συγκεκριμένης size class.

From the screenshot:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Πολύ μικρές kernel structs, pointers.                                        |
| `default.kalloc.32`  | 32 bytes     | Μικρές δομές, object headers.                                              |
| `default.kalloc.64`  | 64 bytes     | IPC messages, πολύ μικροί kernel buffers.                                   |
| `default.kalloc.128` | 128 bytes    | Μεσαία αντικείμενα όπως μέρη του `OSObject`.                                |
| `default.kalloc.256` | 256 bytes    | Μεγαλύτερα IPC messages, πίνακες, device structures.                        |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Μεγάλες δομές, IOSurface/γραφικά metadata.                                  |

**Πώς λειτουργούσε:**
- Κάθε αίτημα allocation γίνεται **στρογγυλοποιημένο προς τα πάνω** στο πλησιέστερο μέγεθος ζώνης.
(π.χ., ένα αίτημα 50-byte καταλήγει στη ζώνη `kalloc.64`).
- Η μνήμη σε κάθε ζώνη κρατιόταν σε μια **free list** — κομμάτια που απελευθερώνονταν από τον kernel επέστρεφαν σε εκείνη τη ζώνη.
- Αν υπερχείλιζες ένα buffer των 64 bytes, θα έγραφες πάνω στο **επόμενο αντικείμενο στην ίδια ζώνη**.

Γι’ αυτό το λόγο το **heap spraying / feng shui** ήταν τόσο αποτελεσματικό: μπορούσες να προβλέψεις τους γείτονες των αντικειμένων ψεκάζοντας allocations της ίδιας size class.

### The freelist

Μέσα σε κάθε kalloc ζώνη, τα ελεύθερα αντικείμενα δεν επιστρέφονταν άμεσα στο σύστημα — πήγαιναν σε ένα freelist, μια συνδεδεμένη λίστα διαθέσιμων chunks.

- Όταν ένα chunk απελευθερώνονταν, ο kernel έγραφε έναν pointer στην αρχή αυτού του chunk → τη διεύθυνση του επόμενου free chunk στην ίδια ζώνη.

- Η ζώνη κρατούσε έναν δείκτη HEAD στο πρώτο free chunk.

- Η allocation πάντα χρησιμοποιούσε το τρέχον HEAD:

1. Pop HEAD (επιστροφή εκείνης της μνήμης στον καλούντα).

2. Update HEAD = HEAD->next (αποθηκευμένο στην κεφαλίδα του freed chunk).

- Η απελευθέρωση έσπρωχνε τα chunks πίσω:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

Άρα το freelist ήταν απλώς μια συνδεδεμένη λίστα που χτιζόταν μέσα στην ίδια την ελεύθερη μνήμη.

Normal state:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Εκμετάλλευση του freelist

Δεδομένου ότι τα πρώτα 8 bytes ενός free chunk αντιστοιχούν στον freelist pointer, ένας επιτιθέμενος μπορεί να τον αλλοιώσει:

1. **Heap overflow** σε ένα διπλανό freed chunk → overwrite του “next” pointer.

2. **Use-after-free** write σε ένα freed object → overwrite του “next” pointer.

Έπειτα, στην επόμενη allocation αυτού του μεγέθους:

- Ο allocator κάνει pop στο corrupted chunk.

- Ακολουθεί το attacker-supplied “next” pointer.

- Επιστρέφει pointer προς arbitrary memory, επιτρέποντας fake object primitives ή targeted overwrite.

Οπτικό παράδειγμα freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
Αυτό το freelist design έκανε την εκμετάλλευση ιδιαίτερα αποτελεσματική πριν το hardening: predictable neighbors από heap sprays, raw pointer freelist links, και η έλλειψη type separation επέτρεπαν στους attackers να ανεβάσουν UAF/overflow bugs σε έλεγχο αυθαίρετης kernel μνήμης.

### Heap Grooming / Feng Shui
Ο στόχος του heap grooming είναι να **διαμορφώσει το layout της heap** έτσι ώστε όταν ένας attacker ενεργοποιήσει ένα overflow ή use-after-free, το στόχο (victim) αντικείμενο να βρίσκεται ακριβώς δίπλα σε ένα αντικείμενο που ελέγχεται από τον attacker.\
Με αυτόν τον τρόπο, όταν συμβεί καταστροφή μνήμης, ο attacker μπορεί αξιόπιστα να αντιγράψει πάνω στο victim αντικείμενο ελεγχόμενα δεδομένα.

**Βήματα:**

1. Spray allocations (fill the holes)
- Με την πάροδο του χρόνου, η kernel heap κατακερματίζεται: κάποιες ζώνες έχουν κενά όπου παλιά αντικείμενα απελευθερώθηκαν.
- Ο attacker πρώτα κάνει πολλές dummy allocations για να γεμίσει αυτά τα κενά, έτσι ώστε η heap να γίνει «συμπαγής» και προβλέψιμη.

2. Force new pages
- Μόλις τα κενά γεμίσουν, οι επόμενες allocations πρέπει να προέλθουν από νέες σελίδες που προστίθενται στη ζώνη.
- Νέες σελίδες σημαίνουν ότι τα αντικείμενα θα ομαδοποιηθούν μαζί, όχι σκορπισμένα πάνω σε παλαιά κατακερματισμένα τμήματα μνήμης.
- Αυτό δίνει στον attacker πολύ καλύτερο έλεγχο των γειτόνων.

3. Place attacker objects
- Ο attacker ψεκάζει ξανά, δημιουργώντας πολλά attacker-controlled objects σε αυτές τις νέες σελίδες.
- Αυτά τα αντικείμενα έχουν προβλέψιμο μέγεθος και θέση (εφόσον ανήκουν στην ίδια ζώνη).

4. Free a controlled object (make a gap)
- Ο attacker σκόπιμα απελευθερώνει κάποιο από τα δικά του αντικείμενα.
- Αυτό δημιουργεί μια «τρύπα» στην heap, την οποία ο allocator θα ξαναχρησιμοποιήσει για την επόμενη allocation ίδιου μεγέθους.

5. Victim object lands in the hole
- Ο attacker προκαλεί το kernel να κάνει allocation για το victim αντικείμενο (αυτό που θέλει να καταστρέψει).
- Εφόσον η τρύπα είναι το πρώτο διαθέσιμο slot στο freelist, το victim τοποθετείται ακριβώς εκεί που ο attacker απελευθέρωσε το αντικείμενό του.

6. Overflow / UAF into victim
- Τώρα ο attacker έχει attacker-controlled objects γύρω από το victim.
- Με overflow από κάποιο από τα δικά του αντικείμενα (ή επαναχρησιμοποίηση ενός freed), μπορεί αξιόπιστα να αντικαταστήσει τα πεδία μνήμης του victim με επιλεγμένες τιμές.

**Γιατί δουλεύει**:

- Zone allocator predictability: allocations ίδιου μεγέθους πάντα προέρχονται από την ίδια ζώνη.
- Freelist behavior: νέες allocations ξαναχρησιμοποιούν πρώτα το πιο πρόσφατα freed chunk.
- Heap sprays: ο attacker γεμίζει τη μνήμη με προβλέψιμο περιεχόμενο και ελέγχει το layout.
- Τελικό αποτέλεσμα: ο attacker ελέγχει πού προσγειώνεται το victim αντικείμενο και ποια δεδομένα βρίσκονται δίπλα του.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Η Apple ενίσχυσε τον allocator και έκανε το **heap grooming πολύ πιο δύσκολο**:

### 1. From Classic kalloc to kalloc_type
- **Before**: υπήρχε μια μοναδική `kalloc.<size>` ζώνη για κάθε size class (16, 32, 64, … 1280, κ.λπ.). Οποιοδήποτε αντικείμενο αυτού του μεγέθους τοποθετούνταν εκεί → attacker objects μπορούσαν να βρεθούν δίπλα σε privileged kernel objects.
- **Now**:
- Kernel objects allocated από **typed zones** (`kalloc_type`).
- Κάθε type αντικειμένου (π.χ. `ipc_port_t`, `task_t`, `OSString`, `OSData`) έχει τη δική του αφιερωμένη ζώνη, ακόμα κι αν έχουν το ίδιο μέγεθος.
- Το mapping μεταξύ object type ↔ zone δημιουργείται από το **kalloc_type system** κατά το compile time.

Ένας attacker πλέον δεν μπορεί να εγγυηθεί ότι ελεγχόμενα δεδομένα (`OSData`) θα βρεθούν δίπλα σε ευαίσθητα kernel objects (`task_t`) ίδιου μεγέθους.

### 2. Slabs and Per-CPU Caches
- Η heap χωρίζεται σε **slabs** (σελίδες μνήμης χωρισμένες σε fixed-size chunks για εκείνη τη ζώνη).
- Κάθε ζώνη έχει ένα **per-CPU cache** για μείωση contention.
- Allocation path:
1. Προσπάθεια από per-CPU cache.
2. Αν είναι άδειο, τράβηγμα από το global freelist.
3. Αν το freelist είναι άδειο, allocate νέου slab (μία ή περισσότερες σελίδες).
- **Όφελος**: αυτή η αποκέντρωση κάνει τα heap sprays λιγότερο ντετερμινιστικά, καθώς allocations μπορεί να εξυπηρετηθούν από caches διαφορετικών CPUs.

### 3. Randomization inside zones
- Εντός μιας ζώνης, τα freed elements δεν επιστρέφονται σε απλή FIFO/LIFO σειρά.
- Το σύγχρονο XNU χρησιμοποιεί **encoded freelist pointers** (safe-linking σαν το Linux, εισήχθη ~iOS 14).
- Κάθε freelist pointer είναι **XOR-κωδικοποιημένος** με ένα per-zone secret cookie.
- Αυτό αποτρέπει τους attackers από το να πλαστογραφήσουν fake freelist pointer αν αποκτήσουν write primitive.
- Κάποιες allocations **τυχαίνουν στη θέση μέσα σε ένα slab**, οπότε το spraying δεν εγγυάται γειτονία.

### 4. Guarded Allocations
- Ορισμένα κρίσιμα kernel αντικείμενα (π.χ. credentials, task structures) allocated σε **guarded zones**.
- Αυτές οι ζώνες εισάγουν **guard pages** (unmapped μνήμη) μεταξύ slabs ή χρησιμοποιούν **redzones** γύρω από αντικείμενα.
- Οποιοδήποτε overflow στο guard page προκαλεί fault → άμεσο panic αντί για σιωπηρή καταστροφή.

### 5. Page Protection Layer (PPL) και SPTM
- Ακόμα και αν ελέγχεις ένα freed αντικείμενο, δεν μπορείς να τροποποιήσεις όλη την kernel μνήμη:
- **PPL (Page Protection Layer)** επιβάλλει ότι ορισμένες περιοχές (π.χ. code signing data, entitlements) είναι **read-only** ακόμη και για το kernel.
- Σε **A15/M2+ συσκευές**, αυτός ο ρόλος αντικαθίσταται/ενισχύεται από **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- Αυτά τα hardware-enforced layers σημαίνουν ότι οι attackers δεν μπορούν να ανεβάσουν ένα single heap corruption σε αυθαίρετο patching κρίσιμων security structures.

### 6. Large Allocations
- Όχι όλες οι allocations περνούν από `kalloc_type`.
- Πολύ μεγάλες αιτήσεις (πάνω από ~16KB) παρακάμπτουν typed zones και εξυπηρετούνται απευθείας από **kernel VM (kmem)** μέσω page allocations.
- Αυτές είναι λιγότερο προβλέψιμες, αλλά και λιγότερο εκμεταλλεύσιμες, καθώς δεν μοιράζονται slabs με άλλα αντικείμενα.

### 7. Allocation Patterns Attackers Target
Ακόμα και με αυτές τις προστασίες, attackers ψάχνουν για:
- **Reference count objects**: αν μπορέσεις να παραποιήσεις retain/release counters, μπορείς να προκαλέσεις use-after-free.
- **Objects with function pointers (vtables)**: η καταστροφή ενός τέτοιου αντικειμένου ακόμα δίνει control flow.
- **Shared memory objects (IOSurface, Mach ports)**: αυτά παραμένουν στόχοι επειδή γεφυρώνουν user ↔ kernel.

Αλλά — σε αντίθεση με παλιά — δεν μπορείς απλώς να ψεκάσεις `OSData` και να περιμένεις να βρεθεί δίπλα σε `task_t`. Χρειάζεσαι **type-specific bugs** ή **info leaks** για να πετύχεις.

### Example: Allocation Flow in Modern Heap

Υποθέτουμε ότι το userspace καλεί το IOKit για να κάνει allocation ενός `OSData` αντικειμένου:

1. **Type lookup** → `OSData` αντιστοιχίζεται στη ζώνη `kalloc_type_osdata` (μέγεθος 64 bytes).
2. Έλεγχος per-CPU cache για free elements.
- Αν βρεθεί → επιστροφή ενός.
- Αν είναι άδειο → πάμε στο global freelist.
- Αν το freelist είναι άδειο → allocate νέο slab (σελίδα 4KB → 64 chunks των 64 bytes).
3. Επιστροφή chunk στον caller.

**Freelist pointer protection**:
- Κάθε freed chunk αποθηκεύει τη διεύθυνση του επόμενου free chunk, αλλά κωδικοποιημένη με ένα secret key.
- Η αντικατάσταση αυτού του πεδίου με attacker δεδομένα δεν θα δουλέψει αν δεν ξέρεις το key.

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages   |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


{{#include ../../banners/hacktricks-training.md}}
