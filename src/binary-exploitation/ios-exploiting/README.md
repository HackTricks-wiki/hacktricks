# Εκμετάλλευση iOS

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

### 1. **Code Signing** / Έλεγχος Υπογραφής σε Runtime
**Εισήχθη νωρίς (iPhone OS → iOS)**
Αυτή είναι μια από τις θεμελιώδεις προστασίες: **όλος ο εκτελέσιμος κώδικας** (apps, dynamic libraries, JIT-ed code, extensions, frameworks, caches) πρέπει να είναι κρυπτογραφικά υπογεγραμμένος από μια αλυσίδα πιστοποιητικών που καταλήγει στην εμπιστοσύνη της Apple. Σε runtime, πριν φορτωθεί ένα binary στη μνήμη (ή πριν γίνει άλμα μέσω ορισμένων ορίων), το σύστημα ελέγχει την υπογραφή του. Αν ο κώδικας τροποποιηθεί (bit-flipped, patched) ή δεν είναι υπογεγραμμένος, το load αποτυγχάνει.

- **Αποτρέπει**: το στάδιο “classic payload drop + execute” σε αλυσίδες exploits; arbitrary code injection; την τροποποίηση υπάρχοντος binary για εισαγωγή κακόβουλης λογικής.
- **Λεπτομέρεια μηχανισμού**:
* Ο Mach-O loader (και ο dynamic linker) ελέγχει code pages, segments, entitlements, team IDs, και ότι η υπογραφή καλύπτει το περιεχόμενο του αρχείου.
* Για περιοχές μνήμης όπως JIT caches ή δυναμικά παραγόμενο κώδικα, η Apple επιβάλλει ότι οι σελίδες να είναι υπογεγραμμένες ή να επικυρώνονται μέσω ειδικών APIs (π.χ. `mprotect` με ελέγχους code-sign).
* Η υπογραφή περιλαμβάνει entitlements και identifiers· το OS επιβάλλει ότι ορισμένα APIs ή προνομιακές δυνατότητες απαιτούν συγκεκριμένα entitlements που δεν μπορούν να πλαστογραφηθούν.

<details>
<summary>Παράδειγμα</summary>
Ας υποθέσουμε ότι ένα exploit αποκτά code execution σε μια διεργασία και προσπαθεί να γράψει shellcode στο heap και να κάνει άλμα σε αυτό. Σε iOS, αυτή η σελίδα θα πρέπει να επισημανθεί ως executable **και** να ικανοποιεί τους περιορισμούς code-signature. Εφόσον το shellcode δεν είναι υπογεγραμμένο με το πιστοποιητικό της Apple, το άλμα αποτυγχάνει ή το σύστημα απορρίπτει το να γίνει η εν λόγω περιοχή μνήμης executable.
</details>


### 2. **CoreTrust**
**Εισήχθη περίπου στην εποχή iOS 14+ (ή σταδιακά σε νεότερες συσκευές / μεταγενέστερο iOS)**
Το CoreTrust είναι το υποσύστημα που πραγματοποιεί **runtime validation υπογραφών** των binaries (συμπεριλαμβανομένων system και user binaries) απέναντι στην **root πιστοποιητικό της Apple** αντί να βασίζεται σε cached userland trust stores.

- **Αποτρέπει**: μεταγενέστερη παραβίαση (post-install) των binaries, jailbreak τεχνικές που προσπαθούν να αντικαταστήσουν ή να patch-άρουν system libraries ή user apps; εξαπάτηση του συστήματος με αντικατάσταση αξιόπιστων binaries με κακόβουλα.
- **Λεπτομέρεια μηχανισμού**:
* Αντί να εμπιστεύεται μια τοπική βάση εμπιστοσύνης ή cache πιστοποιητικών, το CoreTrust αναφέρεται άμεσα στη root της Apple ή επαληθεύει ενδιάμεσα πιστοποιητικά σε μια ασφαλή αλυσίδα.
* Εξασφαλίζει ότι τροποποιήσεις (π.χ. στο filesystem) σε υπάρχοντα binaries εντοπίζονται και απορρίπτονται.
* Συνδέει entitlements, team IDs, code signing flags και άλλα metadata με το binary κατά το φορτάρισμα.

<details>
<summary>Παράδειγμα</summary>
Ένα jailbreak μπορεί να προσπαθήσει να αντικαταστήσει το `SpringBoard` ή το `libsystem` με μια patched έκδοση για επίτευξη persistence. Όταν όμως ο loader του OS ή το CoreTrust ελέγξει, θα παρατηρήσει τη διαφωνία στην υπογραφή (ή τα τροποποιημένα entitlements) και θα αρνηθεί την εκτέλεση.
</details>


### 3. **Data Execution Prevention (DEP / NX / W^X)**
**Εισήχθη νωρίτερα σε πολλά OS· το iOS είχε NX-bit / w^x για μεγάλο διάστημα**
Η DEP επιβάλλει ότι σελίδες που σημαίνονται ως writable (για data) είναι **μη εκτελέσιμες**, και σελίδες που σημαίνονται ως executable είναι **μη γραπτές**. Δεν μπορείς απλά να γράψεις shellcode σε heap ή stack και να το εκτελέσεις.

- **Αποτρέπει**: άμεση εκτέλεση shellcode; κλασικό buffer-overflow → άλμα σε injected shellcode.
- **Λεπτομέρεια μηχανισμού**:
* Η MMU / flags προστασίας μνήμης (μέσω page tables) επιβάλλουν τον διαχωρισμό.
* Οποιαδήποτε προσπάθεια να επισημανθεί μια writable σελίδα ως executable ενεργοποιεί έναν έλεγχο από το σύστημα (και είτε απαγορεύεται είτε απαιτεί έγκριση code-sign).
* Σε πολλές περιπτώσεις, το να καταστήσεις σελίδες executable απαιτεί χρήση OS APIs που επιβάλλουν επιπρόσθετους περιορισμούς ή ελέγχους.

<details>
<summary>Παράδειγμα</summary>
Ένα overflow γράφει shellcode στο heap. Ο επιτιθέμενος επιχειρεί `mprotect(heap_addr, size, PROT_EXEC)` για να το κάνει executable. Αλλά το σύστημα αρνείται ή επικυρώνει ότι η νέα σελίδα πρέπει να περάσει τους περιορισμούς code-sign (που το shellcode δεν περνά).
</details>

### 4. **Address Space Layout Randomization (ASLR)**
**Εισήχθη περίπου στην εποχή iOS ~4–5**
Η ASLR τυχαδοποιεί τις βάσεις διευθύνσεων βασικών περιοχών μνήμης: libraries, heap, stack, κ.λπ., σε κάθε εκκίνηση διεργασίας. Τα addresses των gadgets αλλάζουν μεταξύ εκτελέσεων.

- **Αποτρέπει**: hardcoding gadget addresses για ROP/JOP; στατικές αλυσίδες exploits; τυφλά άλματα σε γνωστά offsets.
- **Λεπτομέρεια μηχανισμού**:
* Κάθε φορτωμένη βιβλιοθήκη / δυναμικό module γίνεται rebase σε ένα τυχαίο offset.
* Οι βάσεις του stack και heap είναι τυχαδοποιημένες (μέσα σε συγκεκριμένα όρια entropy).
* Μερικές φορές και άλλες περιοχές (π.χ. mmap allocations) επίσης τυχαδοποιούνται.
* Σε συνδυασμό με μηχανισμούς αντιμετώπισης information-leak, αναγκάζει τον επιτιθέμενο πρώτα να κάνει leak μιας διεύθυνσης ή pointer για να ανακαλύψει τις βάσεις σε runtime.

<details>
<summary>Παράδειγμα</summary>
Μια ROP αλυσίδα περιμένει gadget στο `0x….lib + offset`. Αλλά επειδή η `lib` μετατοπίζεται διαφορετικά κάθε εκτέλεση, η hardcoded αλυσίδα αποτυγχάνει. Ένα exploit πρέπει πρώτα να κάνει leak τη βάση του module πριν υπολογίσει τα addresses των gadgets.
</details>


### 5. **Kernel Address Space Layout Randomization (KASLR)**
**Εισήχθη περίπου στην εποχή iOS 5–6**
Αναλογικά με την user ASLR, η KASLR τυχαδοποιεί τη βάση του **kernel text** και άλλων kernel δομών κατά την εκκίνηση.

- **Αποτρέπει**: kernel-level exploits που βασίζονται σε σταθερές τοποθεσίες kernel κώδικα ή δεδομένων; στατικά kernel exploits.
- **Λεπτομέρεια μηχανισμού**:
* Σε κάθε boot, η βάση του kernel randomized (εντός κάποιου εύρους).
* Δομές kernel δεδομένων (όπως `task_structs`, `vm_map`, κ.λπ.) μπορεί επίσης να μετατοπίζονται ή να έχουν offsets.
* Ο επιτιθέμενος πρέπει πρώτα να κάνει leak kernel pointers ή να χρησιμοποιήσει vulnerability information disclosure για να υπολογίσει offsets πριν παραβιάσει kernel δομές ή κώδικα.

<details>
<summary>Παράδειγμα</summary>
Ένα τοπικό vulnerability στοχεύει να αλλοιώσει ένα kernel function pointer (π.χ. σε `vtable`) στο `KERN_BASE + offset`. Αλλά επειδή το `KERN_BASE` είναι άγνωστο, ο επιτιθέμενος πρέπει πρώτα να το κάνει leak (π.χ. μέσω read primitive) πριν υπολογίσει τη σωστή διεύθυνση για την αλλοίωση.
</details>


### 6. **Kernel Patch Protection (KPP / AMCC)**
**Εισήχθη σε νεότερα iOS / A-series hardware (μετά περίπου iOS 15–16 ή σε νεότερα chips)**
Το KPP (aka AMCC) παρακολουθεί συνεχώς την ακεραιότητα των kernel text pages (μέσω hash ή checksum). Αν εντοπίσει tampering (patches, inline hooks, τροποποιήσεις κώδικα) εκτός επιτρεπτών παραθύρων, προκαλεί kernel panic ή reboot.

- **Αποτρέπει**: μόνιμη τροποποίηση kernel (patching kernel instructions), inline hooks, στατικές αντικαταστάσεις λειτουργιών.
- **Λεπτομέρεια μηχανισμού**:
* Ένα hardware ή firmware module παρακολουθεί την περιοχή kernel text.
* Περιοδικά ή κατά απαίτηση επανυπολογίζει hashes των pages και τα συγκρίνει με τις αναμενόμενες τιμές.
* Αν υπάρχουν αποκλίσεις εκτός των benign update windows, προκαλεί panic στη συσκευή (για να αποφευχθεί μόνιμη κακόβουλη τροποποίηση).
* Ο επιτιθέμενος πρέπει είτε να αποφύγει τα παράθυρα ανίχνευσης είτε να χρησιμοποιήσει νόμιμες διαδρομές patch.

<details>
<summary>Παράδειγμα</summary>
Ένα exploit προσπαθεί να patch-άρει το prologue μιας kernel function (π.χ. `memcmp`) για να παρεμβάλει κλήσεις. Αλλά το KPP παρατηρεί ότι η code page πλέον δεν ταιριάζει στο αναμενόμενο hash και προκαλεί kernel panic, κρασάροντας τη συσκευή πριν σταθεροποιηθεί το patch.
</details>


### 7. **Kernel Text Read‐Only Region (KTRR)**
**Εισήχθη σε σύγχρονα SoCs (μετά ~A12 / νεότερο hardware)**
Το KTRR είναι ένας hardware-enforced μηχανισμός: μόλις το kernel text κλειδωθεί νωρίς κατά το boot, γίνεται read-only από EL1 (τον kernel), αποτρέποντας περαιτέρω εγγραφές σε code pages.

- **Αποτρέπει**: οποιεσδήποτε τροποποιήσεις στον kernel κώδικα μετά το boot (π.χ. patching, in-place code injection) στο επίπεδο προνομίων EL1.
- **Λεπτομέρεια μηχανισμού**:
* Κατά το boot (στο secure/bootloader στάδιο), ο memory controller (ή μια secure hardware μονάδα) σηματοδοτεί τις φυσικές σελίδες που περιέχουν kernel text ως read-only.
* Ακόμη κι αν ένα exploit αποκτήσει πλήρη kernel προνόμια, δεν μπορεί να γράψει σε αυτές τις σελίδες για να αλλάξει οδηγίες.
* Για να τις τροποποιήσει, ο επιτιθέμενος πρέπει πρώτα να συμβιβάσει το boot chain ή να υπονομεύσει το ίδιο το KTRR.

<details>
<summary>Παράδειγμα</summary>
Ένα privilege-escalation exploit κάνει άλμα σε EL1 και γράφει ένα trampoline μέσα σε μια kernel function (π.χ. στον `syscall` handler). Αλλά επειδή οι σελίδες έχουν κλειδωθεί ως read-only από το KTRR, η εγγραφή αποτυγχάνει (ή προκαλεί fault), οπότε τα patches δεν εφαρμόζονται.
</details>


### 8. **Pointer Authentication Codes (PAC)**
**Εισήχθη με ARMv8.3 (hardware), η Apple άρχισε με A12 / iOS ~12+**
- Το PAC είναι ένα hardware χαρακτηριστικό που εισήχθη στο **ARMv8.3-A** για τον εντοπισμό αλλαγών σε τιμές pointer (return addresses, function pointers, ορισμένα data pointers) με την ενσωμάτωση μιας μικρής κρυπτογραφικής υπογραφής (ένα “MAC”) σε αχρησιμοποίητα ψηφία υψηλότερης τάξης του pointer.
- Η υπογραφή (“PAC”) υπολογίζεται πάνω στην τιμή του pointer συν έναν **modifier** (μια τιμή context, π.χ. stack pointer ή κάποιο διακριτικό δεδομένο). Έτσι η ίδια pointer τιμή σε διαφορετικά contexts έχει διαφορετικό PAC.
- Κατά τη χρήση, πριν γίνει dereference ή branch μέσω αυτού του pointer, μια εντολή **authenticate** ελέγχει το PAC. Αν είναι έγκυρο, το PAC αφαιρείται και προκύπτει ο καθαρός pointer· αν είναι άκυρο, ο pointer γίνεται “poisoned” (ή προκαλείται fault).
- Τα κλειδιά που χρησιμοποιούνται για παραγωγή/επικύρωση PAC ζουν σε privileged registers (EL1, kernel) και δεν είναι απευθείας αναγνώσιμα από user mode.
- Επειδή δεν χρησιμοποιούνται όλα τα 64 bits ενός pointer σε πολλές αρχιτεκτονικές (π.χ. 48-bit address space), τα υψηλά bits είναι “ελεύθερα” και μπορούν να φιλοξενήσουν το PAC χωρίς να αλλάξουν τη λειτουργική διεύθυνση.

#### Αρχιτεκτονική βάση & τύποι κλειδιών

- Το ARMv8.3 εισάγει **πέντε 128-bit keys** (το καθένα υλοποιημένο μέσω δύο 64-bit system registers) για pointer authentication.
- **APIAKey** — για instruction pointers (domain “I”, key A)
- **APIBKey** — δεύτερο key για instruction pointers (domain “I”, key B)
- **APDAKey** — για data pointers (domain “D”, key A)
- **APDBKey** — για data pointers (domain “D”, key B)
- **APGAKey** — “generic” key, για υπογραφή μη-pointer δεδομένων ή άλλες γενικές χρήσεις

- Αυτά τα κλειδιά αποθηκεύονται σε privileged system registers (προσβάσιμα μόνο σε EL1/EL2 κ.λπ.), μη προσβάσιμα από user mode.
- Το PAC υπολογίζεται μέσω μιας κρυπτογραφικής συνάρτησης (η ARM προτείνει το QARMA ως αλγόριθμο) χρησιμοποιώντας:
1. Την τιμή του pointer (canonical portion)
2. Έναν **modifier** (τιμή context, όπως salt)
3. Το μυστικό κλειδί
4. Κάποιο εσωτερικό tweak logic
Αν το παραγόμενο PAC ταιριάζει με αυτό που είναι αποθηκευμένο στα υψηλά bits του pointer, η authentication πετυχαίνει.


#### Οικογένειες εντολών

Η σύμβαση ονοματοδοσίας είναι: **PAC** / **AUT** / **XPAC**, έπειτα τα γράμματα domain.
- `PACxx` εντολές **υπογράφουν** έναν pointer και εισάγουν PAC
- `AUTxx` εντολές **επαληθεύουν + αφαιρούν** (validate και remove το PAC)
- `XPACxx` εντολές **αφαιρούν** χωρίς επαλήθευση

Domains / επίθημα:

| Mnemonic     | Σημασία / Domain                      | Key / Domain     | Παράδειγμα Χρήσης στην Assembly |
|--------------|-----------------------------------------|--------------------|-----------------------------|
| **PACIA**    | Υπογράφει instruction pointer με APIAKey   | “I, A”             | `PACIA X0, X1` — sign pointer in X0 using APIAKey with modifier X1|
| **PACIB**    | Υπογράφει instruction pointer με APIBKey   | “I, B”             | `PACIB X2, X3`              |
| **PACDA**    | Υπογράφει data pointer με APDAKey           | “D, A”             | `PACDA X4, X5`              |
| **PACDB**    | Υπογράφει data pointer με APDBKey           | “D, B”             | `PACDB X6, X7`              |
| **PACG / PACGA** | Generic (μη-pointer) υπογραφή με APGAKey | “G”         | `PACGA X8, X9, X10` (sign X9 with modifier X10 into X8) |
| **AUTIA**    | Επαληθεύει APIA-υπογεγραμμένο instruction pointer & αφαιρεί PAC | “I, A” | `AUTIA X0, X1` — check PAC on X0 using modifier X1, then strip |
| **AUTIB**    | Επαληθεύει APIB domain                 | “I, B”             | `AUTIB X2, X3`               |
| **AUTDA**    | Επαληθεύει APDA-υπογεγραμμένο data pointer    | “D, A”             | `AUTDA X4, X5`               |
| **AUTDB**    | Επαληθεύει APDB-υπογεγραμμένο data pointer    | “D, B”             | `AUTDB X6, X7`               |
| **AUTGA**    | Επαληθεύει generic / blob (APGA)        | “G”               | `AUTGA X8, X9, X10` (validate generic) |
| **XPACI**     | Αφαιρεί PAC (instruction pointer, χωρίς validation) | “I”         | `XPACI X0` — remove PAC from X0 (instruction domain) |
| **XPACD**     | Αφαιρεί PAC (data pointer, χωρίς validation)    | “D”             | `XPACD X4` — remove PAC from data pointer in X4 |


Υπάρχουν εξειδικευμένες / alias μορφές:

- `PACIASP` είναι συντομογραφία για `PACIA X30, SP` (υπογράφει το link register χρησιμοποιώντας το SP ως modifier)
- `AUTIASP` είναι `AUTIA X30, SP` (επαληθεύει το link register με SP)
- Υπάρχουν και συνδυασμένες μορφές όπως `RETAA`, `RETAB` (authenticate-and-return) ή `BLRAA` (authenticate & branch) σε επεκτάσεις ARM / υποστήριξη compiler.
- Επίσης υπάρχουν zero-modifier παραλλαγές: `PACIZA` / `PACIZB` όπου ο modifier είναι παθητικά μηδενικός, κ.λπ.

#### Modifiers

Ο βασικός σκοπός του modifier είναι να **δέσει το PAC με ένα συγκεκριμένο context** ώστε η ίδια διεύθυνση που υπογράφεται σε διαφορετικά contexts να παράγει διαφορετικά PACs. Λειτουργεί σαν salt για ένα hash.

Επομένως:
- Ο **modifier** είναι μια τιμή context (άλλο register) που αναμιγνύεται στον υπολογισμό του PAC. Τυπικές επιλογές: το stack pointer (`SP`), ένας frame pointer, ή κάποιο object ID.
- Η χρήση του SP ως modifier είναι κοινή για signing των return addresses: το PAC συνδέεται με το συγκεκριμένο stack frame. Αν προσπαθήσεις να επαναχρησιμοποιήσεις το LR σε διαφορετικό frame, ο modifier αλλάζει και η επικύρωση PAC αποτυγχάνει.
- Η ίδια pointer τιμή υπογεγραμμένη με διαφορετικούς modifiers δίνει διαφορετικά PACs.
- Ο modifier **δεν χρειάζεται να είναι μυστικός**, αλλά ιδανικά δεν είναι υπό πλήρη έλεγχο του επιτιθέμενου.
- Για εντολές που υπογράφουν ή επικυρώνουν pointers όπου δεν υπάρχει ουσιαστικός modifier, κάποιες μορφές χρησιμοποιούν το μηδέν ή μια προεπιλεγμένη σταθερά.

#### Προσαρμογές & Παρατηρήσεις της Apple / iOS / XNU

- Η υλοποίηση PAC της Apple περιλαμβάνει **diversifiers ανά boot** ώστε τα κλειδιά ή τα tweaks να αλλάζουν κάθε boot, αποτρέποντας την επαναχρησιμοποίηση across boots.
- Επίσης περιλαμβάνουν **cross-domain mitigations** έτσι ώστε PACs που υπογράφονται σε user mode να μην είναι εύκολα επαναχρησιμοποιήσιμα σε kernel mode, κ.λπ.
- Στο Apple M1 / Apple Silicon, η αντιστροφή έδειξε ότι υπάρχουν **εννέα τύποι modifiers** και Apple-ειδικά system registers για τον έλεγχο των κλειδιών.
- Η Apple χρησιμοποιεί PAC σε πολλά kernel υποσυστήματα: signing return addresses, pointer integrity σε kernel δεδομένα, signed thread contexts, κ.λπ.
- Το Google Project Zero έδειξε πώς υπό ισχυρό memory read/write primitive στο kernel, κάποιος μπορούσε να κατασκευάσει (forge) kernel PACs (για A keys) σε συσκευές A12-era, αλλά η Apple έκλεισε πολλές από αυτές τις διαδρομές.
- Στο σύστημα της Apple, κάποια κλειδιά είναι **global για το kernel**, ενώ οι user processes μπορεί να λαμβάνουν per-process key randomness.

#### PAC Bypasses

1. **Kernel-mode PAC: θεωρητικά vs πραγματικά bypasses**

-   Επειδή τα kernel PAC keys και η λογική ελέγχονται αυστηρά (privileged registers, diversifiers, domain isolation), το να πλαστογραφήσεις αυθαίρετα υπογεγραμμένους kernel pointers είναι πολύ δύσκολο.
-   Το άρθρο του Azad 2020 "iOS Kernel PAC, One Year Later" αναφέρει ότι σε iOS 12-13 βρέθηκαν λίγες μερικές παρακάμψεις (signing gadgets, reuse of signed states, unprotected indirect branches) αλλά όχι πλήρης γενική παράκαμψη. [bazad.github.io](https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf)
-   Οι Apple "Dark Magic" προσαρμογές μειώνουν επιπλέον τις επιφάνειες εκμετάλλευσης (domain switching, per-key enabling bits). [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Υπάρχει γνωστή **kernel PAC bypass CVE-2023-32424** σε Apple silicon (M1/M2) αναφερθείσα από Zecao Cai et al. [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Όμως αυτές οι παρακάμψεις συνήθως βασίζονται σε πολύ συγκεκριμένα gadgets ή bugs υλοποίησης· δεν είναι γενικής χρήσης bypass.

Συνεπώς το kernel PAC θεωρείται **πολύ ανθεκτικό**, αν και όχι τέλειο.

2. **User-mode / runtime PAC bypass τεχνικές**

Αυτές είναι πιο κοινές, και εκμεταλλεύονται ατέλειες στον τρόπο που εφαρμόζεται το PAC ή χρησιμοποιείται στο dynamic linking / runtime frameworks. Παρακάτω κατηγορίες με παραδείγματα.

2.1 **Shared Cache / A key issues**

-   Το **dyld shared cache** είναι ένα μεγάλο pre-linked blob συστημικών frameworks και βιβλιοθηκών. Επειδή χρησιμοποιείται ευρέως, function pointers μέσα στο shared cache είναι "pre-signed" και χρησιμοποιούνται από πολλές διεργασίες. Επιτιθέμενοι στοχεύουν αυτούς τους ήδη-υπογεγραμμένους pointers ως "PAC oracles".

-   Κάποιες bypass τεχνικές προσπαθούν να εξάγουν ή να επαναχρησιμοποιήσουν A-key υπογεγραμμένους pointers που υπάρχουν στο shared cache και να τους χρησιμοποιήσουν σε gadgets.

-   Η παρουσίαση "No Clicks Required" περιγράφει την κατασκευή ενός oracle πάνω στο shared cache για να συναγάγει relative addresses και να το συνδυάσει με signed pointers για παράκαμψη PAC. [saelo.github.io](https://saelo.github.io/presentations/offensivecon_20_no_clicks.pdf)

-   Επίσης, imports function pointers από shared libraries σε userspace βρέθηκαν ότι δεν προστατεύονται επαρκώς από PAC, επιτρέποντας σε επιτιθέμενους να πάρουν function pointers χωρίς να αλλάξουν την υπογραφή τους. (Project Zero bug entry) [bugs.chromium.org](https://bugs.chromium.org/p/project-zero/issues/detail?id=2044&utm_source=chatgpt.com)

2.2 **dlsym(3) / dynamic symbol resolution**

-   Μια γνωστή παράκαμψη είναι να καλέσεις `dlsym()` για να πάρεις έναν *ήδη υπογεγραμμένο* function pointer (υπογεγραμμένο με A-key, diversifier zero) και να τον χρησιμοποιήσεις. Εφόσον το `dlsym` επιστρέφει ένα νόμιμα υπογεγραμμένο pointer, η χρήση του παρακάμπτει την ανάγκη να πλαστογραφήσεις PAC.

-   Το blog του Epsilon εξηγεί πώς κάποιες παρακάμψεις εκμεταλλεύονται αυτό: κλήση `dlsym("someSym")` επιστρέφει signed pointer και μπορεί να χρησιμοποιηθεί για indirect calls. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

-   Το Synacktiv's "iOS 18.4 --- dlsym considered harmful" περιγράφει ένα bug: κάποια symbols που λύνονται μέσω `dlsym` στο iOS 18.4 επιστρέφουν pointers που είναι λανθασμένα signed (ή με buggy diversifiers), επιτρέποντας ανεπιθύμητη PAC παράκαμψη. [Synacktiv](https://www.synacktiv.com/en/publications/ios-184-dlsym-considered-harmful)

-   Η λογική στο dyld για dlsym περιλαμβάνει: όταν `result->isCode`, υπογράφουν τον επιστρεφόμενο pointer με `__builtin_ptrauth_sign_unauthenticated(..., key_asia, 0)`, δηλ. context zero. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

Έτσι, το `dlsym` είναι συχνός φορέας σε user-mode PAC bypasses.

2.3 **Άλλες DYLD / runtime relocations**

-   Ο DYLD loader και η λογική δυναμικής relocation είναι πολύπλοκη και μερικές φορές προσωρινά κάνει map σελίδες ως read/write για να εκτελέσει relocations, έπειτα τις επαναφέρει σε read-only. Επιτιθέμενοι εκμεταλλεύονται αυτά τα παράθυρα. Η παρουσίαση του Synacktiv περιγράφει την "Operation Triangulation", μια timing-based παράκαμψη PAC μέσω dynamic relocations. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   Οι σελίδες του DYLD πλέον προστατεύονται με SPRR / VM_FLAGS_TPRO (κάποια protection flags για dyld). Αλλά σε παλαιότερες εκδόσεις οι φρουρές ήταν πιο αδύναμες. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   Σε WebKit exploit chains, ο DYLD loader είναι συχνά στόχος για PAC bypass. Οι slides αναφέρουν ότι πολλές PAC παρακάμψεις στόχευσαν τον DYLD loader (μέσω relocation, interposer hooks). [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

2.4 **NSPredicate / NSExpression / ObjC / SLOP**

-   Σε userland exploit chains, μέθοδοι του Objective-C runtime όπως `NSPredicate`, `NSExpression` ή `NSInvocation` χρησιμοποιούνται για να μεταφέρουν κλήσεις ελέγχου χωρίς προφανή forging pointers.

-   Σε παλαιότερο iOS (πριν PAC), ένα exploit χρησιμοποίησε **fake NSInvocation** objects για να καλέσει arbitrary selectors σε ελεγχόμενη μνήμη. Με PAC χρειάστηκαν τροποποιήσεις. Αλλά η τεχνική SLOP (SeLector Oriented Programming) επεκτάθηκε και υπό PAC. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   Η αρχική τεχνική SLOP επέτρεπε την αλυσιδωτή εκτέλεση ObjC calls δημιουργώντας fake invocations· η παράκαμψη στηρίζεται στο ότι ISA ή selector pointers μερικές φορές δεν προστατεύονται πλήρως από PAC. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   Σε περιβάλλοντα όπου η pointer authentication εφαρμόζεται μερικώς, methods / selectors / target pointers μπορεί να μην έχουν πάντα PAC protection, προσφέροντας χώρο για παράκαμψη.

#### Παράδειγμα Ροής

<details>
<summary>Παράδειγμα Signing & Authenticating</summary>
```
; Example: function prologue / return address protection
my_func:
stp x29, x30, [sp, #-0x20]!        ; push frame pointer + LR
mov x29, sp
PACIASP                            ; sign LR (x30) using SP as modifier
; … body …
mov sp, x29
ldp x29, x30, [sp], #0x20         ; restore
AUTIASP                            ; authenticate & strip PAC
ret

; Example: indirect function pointer stored in a struct
; suppose X1 contains a function pointer
PACDA X1, X2     ; sign data pointer X1 with context X2
STR X1, [X0]      ; store signed pointer

; later retrieval:
LDR X1, [X0]
AUTDA X1, X2       ; authenticate & strip
BLR X1             ; branch to valid target

; Example: stripping for comparison (unsafe)
LDR X1, [X0]
XPACI X1           ; strip PAC (instruction domain)
CMP X1, #some_label_address
BEQ matched_label
```
</details>

<details>
<summary>Παράδειγμα</summary>
A buffer overflow overwrites a return address on the stack. The attacker writes the target gadget address but cannot compute the correct PAC. When the function returns, the CPU’s `AUTIA` instruction faults because the PAC mismatch. The chain fails.
Project Zero’s analysis on A12 (iPhone XS) showed how Apple’s PAC is used and methods of forging PACs if an attacker has a memory read/write primitive.
</details>


### 9. **Branch Target Identification (BTI)**
**Introduced with ARMv8.5 (later hardware)**
BTI είναι μια hardware λειτουργία που ελέγχει τους **indirect branch targets**: όταν εκτελείται `blr` ή indirect calls/jumps, ο στόχος πρέπει να ξεκινά με μια **BTI landing pad** (`BTI j` ή `BTI c`). Το άλμα σε gadget addresses που στερούνται του landing pad προκαλεί exception.

Η υλοποίηση του LLVM σημειώνει τρεις παραλλαγές των BTI οδηγιών και πώς αντιστοιχούν σε τύπους branches.

| BTI Variant | Τι επιτρέπει (ποιους τύπους branch) | Τυπική τοποθέτηση / χρήση |
|-------------|----------------------------------------|-------------------------------|
| **BTI C** | Targets of *call*-style indirect branches (π.χ. `BLR`, ή `BR` χρησιμοποιώντας X16/X17) | Τοποθετείται στην είσοδο συναρτήσεων που μπορεί να κληθούν έμμεσα |
| **BTI J** | Targets of *jump*-style branches (π.χ. `BR` που χρησιμοποιείται για tail calls) | Τοποθετείται στην αρχή blocks που είναι προσβάσιμα μέσω jump tables ή tail-calls |
| **BTI JC** | Acts as both C and J | Μπορεί να στοχοποιηθεί είτε από call είτε από jump branches |

- Σε code που έχει compiler-enforced branch target enforcement, οι compilers εισάγουν μια BTI οδηγία (C, J, ή JC) σε κάθε έγκυρο indirect-branch target (αρχές συναρτήσεων ή blocks προσβάσιμα με jumps) ώστε τα indirect branches να επιτρέπονται μόνο προς αυτά τα σημεία.
- **Direct branches / calls** (δηλαδή fixed-address `B`, `BL`) **δεν περιορίζονται** από BTI. Η υπόθεση είναι ότι οι code pages είναι trusted και ο attacker δεν μπορεί να τις αλλάξει (οπότε τα direct branches θεωρούνται ασφαλή).
- Επίσης, οι **RET / return** οδηγίες γενικά δεν περιορίζονται από BTI επειδή οι return διευθύνσεις προστατεύονται μέσω PAC ή μηχανισμών return signing.

#### Μηχανισμός και επιβολή

- Όταν η CPU αποκωδικοποιεί ένα **indirect branch (BLR / BR)** σε σελίδα που σημαίνεται ως “guarded / BTI-enabled,” ελέγχει αν η πρώτη οδηγία στον στόχο είναι έγκυρο BTI (C, J, ή JC όπως επιτρέπεται). Αν όχι, συμβαίνει **Branch Target Exception**.
- Το encoding της BTI οδηγίας έχει σχεδιαστεί ώστε να επαναχρησιμοποιεί opcode που προηγουμένως ήταν δεσμευμένα για NOPs (σε παλαιότερες ARM εκδόσεις). Έτσι τα BTI-enabled binaries παραμένουν backward-compatible: σε hardware χωρίς υποστήριξη BTI, αυτές οι οδηγίες λειτουργούν σαν NOPs.
- Τα compiler passes που προσθέτουν BTIs τα εισάγουν μόνο όπου χρειάζεται: σε συναρτήσεις που μπορεί να κληθούν έμμεσα, ή σε basic blocks που στοχοποιούνται από jumps.
- Κάποια patches και κώδικας LLVM δείχνουν ότι το BTI δεν εισάγεται για *όλα* τα basic blocks — μόνο για εκείνα που είναι πιθανοί branch targets (π.χ. από switch / jump tables).

#### BTI + PAC συνδυασμός

Το PAC προστατεύει την pointer τιμή (την πηγή) — εξασφαλίζει ότι η αλυσίδα των indirect calls / returns δεν έχει τροποποιηθεί.

Το BTI εξασφαλίζει ότι ακόμη κι ένας έγκυρος pointer πρέπει να στοχεύει μόνο σε κατάλληλα επισημασμένα entry points.

Συνδυαστικά, ένας attacker χρειάζεται τόσο έναν έγκυρο pointer με σωστό PAC όσο και το target να έχει BTI τοποθετημένο εκεί. Αυτό αυξάνει τη δυσκολία στον σχηματισμό exploit gadgets.

#### Παράδειγμα


<details>
<summary>Παράδειγμα</summary>
An exploit tries to pivot into gadget at `0xABCDEF` that doesn’t start with `BTI c`. The CPU, upon executing `blr x0`, checks the target and faults because the instruction alignment doesn’t include a valid landing pad. Thus many gadgets become unusable unless they include BTI prefix.
</details>


### 10. **Privileged Access Never (PAN) & Privileged Execute Never (PXN)**
**Introduced in more recent ARMv8 extensions / iOS support (for hardened kernel)**

#### PAN (Privileged Access Never)

- **PAN** είναι μια λειτουργία που εισήχθη στο **ARMv8.1-A** και αποτρέπει το **privileged code** (EL1 ή EL2) από το να **διαβάζει ή να γράφει** σε μνήμη που είναι σημειωμένη ως **user-accessible (EL0)**, εκτός εάν το PAN απενεργοποιηθεί ρητά.
- Η ιδέα: ακόμα κι αν ο kernel παραβιαστεί ή χειραγωγηθεί, δεν μπορεί αυθαίρετα να dereference pointers του user-space χωρίς πρώτα να *απενεργοποιήσει* το PAN, μειώνοντας τον κίνδυνο exploit τύπου **`ret2usr`** ή κακής χρήσης user-controlled buffers.
- Όταν το PAN είναι ενεργό (PSTATE.PAN = 1), οποιαδήποτε privileged load/store που προσπελαύνει μια virtual address που είναι “accessible at EL0” προκαλεί **permission fault**.
- Ο kernel, όταν πρέπει νόμιμα να προσπελάσει user-space μνήμη (π.χ. copy δεδομένων προς/από user buffers), πρέπει **προσωρινά να απενεργοποιήσει το PAN** (ή να χρησιμοποιήσει “unprivileged load/store” οδηγίες) για να επιτρέψει την πρόσβαση.
- Σε Linux σε ARM64, η υποστήριξη PAN εισήχθη περίπου το 2015: patches στον kernel πρόσθεσαν ανίχνευση του feature, και αντικατέστησαν `get_user` / `put_user` κ.λπ. με παραλλαγές που καθαρίζουν το PAN γύρω από τις προσπελάσεις user μνήμης.

**Κύρια ιδιαιτερότητα / περιορισμός / bug**
- Όπως σχολιάστηκε από τον Siguza και άλλους, ένα specification bug (ή ασαφής συμπεριφορά) στο σχέδιο του ARM σημαίνει ότι οι **execute-only user mappings** (`--x`) ενδέχεται να **μην ενεργοποιούν το PAN**. Με άλλα λόγια, αν μια user σελίδα είναι σημειωμένη ως executable αλλά χωρίς read permission, η προσπάθεια του kernel να τη διαβάσει μπορεί να παρακάμψει το PAN επειδή η αρχιτεκτονική θεωρεί “accessible at EL0” ότι απαιτείται δικαίωμα ανάγνωσης, όχι μόνο εκτέλεσης. Αυτό οδηγεί σε PAN bypass σε ορισμένες υλοποιήσεις.
- Εξαιτίας αυτού, αν iOS / XNU επιτρέπουν execute-only user pages (όπως σε μερικά JIT ή code-cache setups), ο kernel μπορεί κατά λάθος να διαβάσει από αυτές ακόμη και με ενεργό PAN. Αυτό είναι γνωστή λεπτή επιτιθέμενη επιφάνεια σε μερικά ARMv8+ συστήματα.

#### PXN (Privileged eXecute Never)

- **PXN** είναι ένα flag στον page table (στα page table entries, leaf ή block entries) που δείχνει ότι η σελίδα **δεν μπορεί να εκτελεστεί όταν τρέχει σε privileged mode** (δηλαδή όταν εκτελείται σε EL1).
- Το PXN εμποδίζει τον kernel (ή οποιοδήποτε privileged code) από το να κάνει jump ή να εκτελέσει οδηγίες από user-space pages ακόμα κι αν ο έλεγχος εκτρέπεται. Ουσιαστικά σταματάει τη μετατόπιση του control-flow του kernel σε user memory.
- Σε συνδυασμό με το PAN, αυτό εξασφαλίζει ότι:
1. Ο kernel δεν μπορεί (εκ προεπιλογής) να διαβάσει ή να γράψει user-space δεδομένα (PAN)
2. Ο kernel δεν μπορεί να εκτελέσει user-space κώδικα (PXN)
- Στο ARMv8 page table format, τα leaf entries έχουν bit `PXN` (και επίσης `UXN` για unprivileged execute-never) στα attribute bits τους.

Έτσι, ακόμα κι αν ο kernel έχει corrupted function pointer που δείχνει σε user memory, και επιχειρήσει branch εκεί, το PXN bit θα προκαλέσει fault.

#### Μοντέλο δικαιωμάτων μνήμης & πώς το PAN και το PXN αντιστοιχούν σε bits του page table

Για να κατανοήσετε πώς δουλεύουν PAN / PXN, χρειάζεται να δείτε πώς λειτουργεί ο translation και το permission model του ARM (απλοποιημένο):

- Κάθε page ή block entry έχει πεδία attributes περιλαμβάνοντας **AP[2:1]** για access permissions (read/write, privileged vs unprivileged) και bits **UXN / PXN** για execute-never περιορισμούς.
- Όταν το PSTATE.PAN είναι 1 (enabled), το hardware επιβάλλει τροποποιημένη σημασιολογία: privileged προσπελάσεις σε σελίδες σημειωμένες ως “accessible by EL0” (δηλ. user-accessible) απαγορεύονται (fault).
- Εξαιτίας του αναφερθέντος bug, σελίδες που είναι σημειωμένες μόνο ως executable (χωρίς δικαίωμα ανάγνωσης) μπορεί να μην θεωρούνται “accessible by EL0” σε κάποιες υλοποιήσεις, άρα να παρακάμπτουν το PAN.
- Όταν το PXN bit μιας σελίδας είναι ενεργό, ακόμα κι αν ο fetch προέρχεται από υψηλότερο privilege level, η εκτέλεση απαγορεύεται.

#### Χρήση του PAN / PXN στον kernel ενός hardened OS (π.χ. iOS / XNU)

Σε ένα hardened kernel design (όπως αυτό που μπορεί να χρησιμοποιεί η Apple):

- Ο kernel ενεργοποιεί το PAN από προεπιλογή (ώστε το privileged code να περιορίζεται).
- Σε μονοπάτια που νόμιμα χρειάζεται να διαβάσει/γράψει user buffers (π.χ. syscall buffer copy, I/O, read/write user pointer), ο kernel προσωρινά **απενεργοποιεί το PAN** ή χρησιμοποιεί ειδικές οδηγίες για να υπερβεί το περιορισμό.
- Μετά την πρόσβαση στα user δεδομένα, πρέπει να επανενεργοποιήσει το PAN.
- Το PXN επιβάλλεται μέσω των page tables: οι user pages έχουν PXN = 1 (ώστε ο kernel να μην μπορεί να τις εκτελέσει), οι kernel pages δεν έχουν PXN (οπότε ο kernel κώδικας μπορεί να εκτελεστεί).
- Ο kernel πρέπει να διασφαλίζει ότι δεν υπάρχουν code paths που προκαλούν εκτέλεση σε user memory regions (που θα παρακάμπτα το PXN) — επομένως οι exploit αλυσίδες που βασίζονται στο “jump into user-controlled shellcode” αποκλείονται.

Εξαιτίας του αναφερθέντος PAN bypass μέσω execute-only pages, σε ένα πραγματικό σύστημα, η Apple μπορεί να απαγορεύει execute-only user pages ή να διορθώνει την αδυναμία της προδιαγραφής.

#### Επιφάνειες επίθεσης, παρακάμψεις και μετριασμοί

- **PAN bypass μέσω execute-only pages**: όπως συζητήθηκε, η προδιαγραφή αφήνει κενό: user pages με execute-only (χωρίς read perm) μπορεί να μην μετρήσουν ως “accessible at EL0,” έτσι το PAN δεν θα μπλοκάρει kernel reads από τέτοιες σελίδες σε κάποιες υλοποιήσεις. Αυτό δίνει στον attacker έναν ασυνήθιστο δρόμο να τροφοδοτήσει δεδομένα μέσω “execute-only” τμημάτων.
- **Temporal window exploit**: αν ο kernel απενεργοποιεί το PAN για μεγαλύτερο window από το αναγκαίο, μια race ή κακόβουλη ενέργεια μπορεί να εκμεταλλευτεί αυτό το παράθυρο για να πραγματοποιήσει μη προβλεπόμενη πρόσβαση σε user μνήμη.
- **Ξεχασμένη επανενεργοποίηση**: αν κάποιο μονοπάτι κώδικα αποτύχει να επανενεργοποιήσει το PAN, επόμενες λειτουργίες του kernel μπορεί εσφαλμένα να προσπελάσουν user μνήμη.
- **Λανθασμένη ρύθμιση του PXN**: αν τα page tables δεν θέτουν το PXN στις user pages ή χαρτογραφούν λανθασμένα user code pages, ο kernel μπορεί να εξαναγκαστεί σε εκτέλεση user-space κώδικα.
- **Σκέψεις περί speculation / side-channels**: παρόμοια με speculative bypasses, μπορεί να υπάρξουν microarchitectural side-effects που προκαλούν παροδικές παραβιάσεις των ελέγχων PAN / PXN (αν και τέτοιες επιθέσεις εξαρτώνται πολύ από το σχεδιασμό του CPU).
- **Σύνθετες αλληλεπιδράσεις**: Σε πιο προηγμένα features (π.χ. JIT, shared memory, code-cache περιοχές), ο kernel μπορεί να χρειάζεται λεπτομερή έλεγχο για να επιτρέψει ορισμένες προσβάσεις ή εκτέλεση σε user-mapped περιοχές· το σχεδιασμό αυτών με ασφάλεια υπό τους περιορισμούς PAN/PXN δεν είναι απλό.

#### Παράδειγμα

<details>
<summary>Παράδειγμα Κώδικα</summary>
Here are illustrative pseudo-assembly sequences showing enabling/disabling PAN around user memory access, and how a fault might occur.
</details>
```  
// Suppose kernel entry point, PAN is enabled (privileged code cannot access user memory by default)

; Kernel receives a syscall with user pointer in X0
; wants to read an integer from user space
mov   X1, X0        ; X1 = user pointer

; disable PAN to allow privileged access to user memory
MSR   PSTATE.PAN, #0   ; clear PAN bit, disabling the restriction

ldr   W2, [X1]       ; now allowed load from user address

; re-enable PAN before doing other kernel logic
MSR   PSTATE.PAN, #1   ; set PAN

; ... further kernel work ...

; Later, suppose an exploit corrupts a pointer to a user-space code page and jumps there
BR    X3             ; branch to X3 (which points into user memory)

; Because the target page is marked PXN = 1 for privileged execution,
; the CPU throws an exception (fault) and rejects execution
```
If ο πυρήνας είχε **μην** ορίσει PXN σε εκείνη τη σελίδα χρήστη, τότε η διακλάδωση μπορεί να επιτύχει — κάτι που θα ήταν ανασφαλές.

Εάν ο πυρήνας ξεχάσει να επανενεργοποιήσει το PAN μετά από πρόσβαση σε μνήμη χρήστη, ανοίγει ένα παράθυρο όπου περαιτέρω λογική του πυρήνα μπορεί κατά λάθος να διαβάσει/γράψει αυθαίρετη μνήμη χρήστη.

Αν ο δείκτης χρήστη δείχνει σε σελίδα execute-only (σελίδα χρήστη με μόνο δικαίωμα execute, χωρίς read/write), υπό το bug του PAN spec, `ldr W2, [X1]` μπορεί **να μην** προκαλέσει σφάλμα ακόμη και με ενεργό PAN, επιτρέποντας bypass exploit, ανάλογα με την υλοποίηση.

</details>

<details>
<summary>Example</summary>
Μια ευπάθεια του πυρήνα προσπαθεί να πάρει έναν user-provided function pointer και να τον καλέσει στο context του πυρήνα (π.χ. `call user_buffer`). Υπό PAN/PXN, αυτή η ενέργεια απαγορεύεται ή προκαλεί σφάλμα.
</details>

---

### 11. **Top Byte Ignore (TBI) / Pointer Tagging**
**Introduced in ARMv8.5 / newer (or optional extension)**
TBI σημαίνει ότι το ανώτατο byte (το πιο σημαντικό byte) ενός 64-bit pointer αγνοείται από τη μετάφραση διευθύνσεων. Αυτό επιτρέπει στο OS ή στο hardware να ενσωματώσει **tag bits** στο ανώτατο byte του pointer χωρίς να επηρεάζει τη πραγματική διεύθυνση.

- TBI σημαίνει **Top Byte Ignore** (μερικές φορές ονομάζεται *Address Tagging*). Είναι ένα χαρακτηριστικό υλικού (διαθέσιμο σε πολλές υλοποιήσεις ARMv8+) που **αγνοεί τα ανώτατα 8 bits** (bits 63:56) ενός 64-bit pointer όταν πραγματοποιείται **address translation / load/store / instruction fetch**.
- Στην πράξη, η CPU αντιμετωπίζει έναν pointer `0xTTxxxx_xxxx_xxxx` (όπου `TT` = top byte) ως `0x00xxxx_xxxx_xxxx` για σκοπούς μετάφρασης διευθύνσεων, αγνοώντας (masking off) το top byte. Το top byte μπορεί να χρησιμοποιηθεί από το λογισμικό για να αποθηκεύσει **metadata / tag bits**.
- Αυτό δίνει στο λογισμικό «δωρεάν» ενσωματωμένο χώρο για να αποθηκεύσει ένα byte tag σε κάθε pointer χωρίς να αλλάζει ποια θέση μνήμης δείχνει.
- Η αρχιτεκτονική εξασφαλίζει ότι οι φορτώσεις, οι αποθηκεύσεις και η ανάκληση εντολών αντιμετωπίζουν τον pointer με το top byte masked (δηλ. χωρίς το tag) πριν την πραγματική πρόσβαση στη μνήμη.

Έτσι, το TBI αποσυνδέει τον **logical pointer** (pointer + tag) από τη **physical address** που χρησιμοποιείται για λειτουργίες μνήμης.

#### Why TBI: Use cases and motivation

- **Pointer tagging / metadata**: Μπορείτε να αποθηκεύσετε επιπλέον metadata (π.χ. object type, version, bounds, integrity tags) σε αυτό το top byte. Όταν αργότερα χρησιμοποιείτε τον pointer, το tag αγνοείται σε επίπεδο hardware, έτσι δεν χρειάζεται να το αφαιρείτε χειροκίνητα πριν από την πρόσβαση στη μνήμη.
- **Memory tagging / MTE (Memory Tagging Extension)**: Το TBI είναι ο βασικός μηχανισμός υλικού πάνω στον οποίο χτίζει το MTE. Στην ARMv8.5, η **Memory Tagging Extension** χρησιμοποιεί τα bits 59:56 του pointer ως **logical tag** και τα συγκρίνει με ένα **allocation tag** αποθηκευμένο στη μνήμη.
- **Enhanced security & integrity**: Συνδυάζοντας το TBI με pointer authentication (PAC) ή runtime checks, μπορείτε να απαιτήσετε όχι μόνο τη σωστή τιμή του pointer αλλά και το σωστό tag. Ένας attacker που τροποποιεί έναν pointer χωρίς το σωστό tag θα παράγει mismatched tag.
- **Compatibility**: Επειδή το TBI είναι προαιρετικό και τα tag bits αγνοούνται από το hardware, ο υπάρχων μη-βελτιωμένος κώδικας συνεχίζει να λειτουργεί κανονικά. Τα tag bits ουσιαστικά γίνονται «μηδενικής σημασίας» bits για legacy κώδικα.

#### Example
<details>
<summary>Example</summary>
Ένας function pointer περιείχε ένα tag στο top byte του (π.χ. `0xAA`). Ένα exploit αντικαθιστά τα χαμηλά bits του pointer αλλά παραλείπει το tag, οπότε όταν ο πυρήνας επαληθεύει ή καθαρίζει τον pointer, το pointer απορρίπτεται λόγω λάθους tag.
</details>

---

### 12. **Page Protection Layer (PPL)**
**Introduced in late iOS / modern hardware (iOS ~17 / Apple silicon / high-end models)** (κάποιες αναφορές δείχνουν PPL γύρω στο macOS / Apple silicon, αλλά η Apple φέρνει ανάλογες προστασίες και στο iOS)

- Το PPL έχει σχεδιαστεί ως ένα **intra-kernel protection boundary**: ακόμα κι αν ο πυρήνας (EL1) παραβιαστεί και έχει δικαιώματα read/write, **δεν θα πρέπει να μπορεί ελεύθερα να τροποποιεί** ορισμένες **ευαίσθητες σελίδες** (ειδικά page tables, code-signing metadata, kernel code pages, entitlements, trust caches, κ.λπ.).
- Δημιουργεί ουσιαστικά έναν **“πυρήνα μέσα στον πυρήνα”** — ένα μικρότερο αξιόπιστο συστατικό (PPL) με **ανυψωμένα προνόμια** που μόνο αυτό μπορεί να τροποποιεί προστατευόμενες σελίδες. Άλλος κώδικας του πυρήνα πρέπει να καλεί ρουτίνες του PPL για να πραγματοποιήσει αλλαγές.
- Αυτό μειώνει την επιφάνεια επίθεσης για exploits του πυρήνα: ακόμα κι αν υπάρχει πλήρης arbitrary R/W/execute σε kernel mode, ο exploit πρέπει επίσης να περάσει στην PPL domain (ή να παρακάμψει το PPL) για να τροποποιήσει κρίσιμες δομές.
- Σε νεότερα Apple silicon (A15+ / M2+), η Apple μεταβαίνει σε **SPTM (Secure Page Table Monitor)**, που σε πολλές περιπτώσεις αντικαθιστά το PPL για προστασία των page-tables σε αυτές τις πλατφόρμες.

Εδώ είναι πώς πιστεύεται ότι λειτουργεί το PPL, βάσει δημόσιας ανάλυσης:

#### Use of APRR / permission routing (APRR = Access Permission ReRouting)

- Το hardware της Apple χρησιμοποιεί έναν μηχανισμό που ονομάζεται **APRR (Access Permission ReRouting)**, που επιτρέπει στα page table entries (PTEs) να περιέχουν μικρούς δείκτες (indices), αντί για πλήρη permission bits. Αυτοί οι δείκτες αντιστοιχίζονται μέσω APRR registers σε πραγματικά permissions. Αυτό επιτρέπει δυναμική αναχαρτογράφηση δικαιωμάτων ανά domain.
- Το PPL αξιοποιεί το APRR για να διαχωρίσει τα προνόμια εντός του context του πυρήνα: μόνο το PPL domain έχει δικαίωμα να ενημερώνει τη χαρτογράφηση μεταξύ indices και των αποτελεσματικών permissions. Δηλαδή, όταν μη-PPL kernel κώδικας γράφει ένα PTE ή προσπαθεί να αλλάξει permission bits, η λογική APRR το απορρίπτει (ή επιβάλει read-only mapping).
- Ο κώδικας PPL ο ίδιος τρέχει σε μια περιορισμένη περιοχή (π.χ. `__PPLTEXT`) που κανονικά δεν είναι εκτελέσιμη ή εγγράψιμη μέχρι να επιτραπεί προσωρινά μέσω entry gates. Ο πυρήνας καλεί PPL entry points (“PPL routines”) για να πραγματοποιήσει ευαίσθητες λειτουργίες.

#### Gate / Entry & Exit

- Όταν ο πυρήνας χρειάζεται να τροποποιήσει μια προστατευόμενη σελίδα (π.χ. να αλλάξει permissions μιας σελίδας κώδικα του πυρήνα, ή να τροποποιήσει page tables), καλεί μια **PPL wrapper** ρουτίνα, που κάνει validaton και μετά μεταβαίνει στο PPL domain. Έξω από αυτό το domain, οι προστατευμένες σελίδες είναι ουσιαστικά read-only ή μη τροποποιήσιμες από τον κεντρικό πυρήνα.
- Κατά την είσοδο στο PPL, οι APRR mappings προσαρμόζονται έτσι ώστε οι σελίδες μνήμης στην περιοχή PPL να τίθενται **εκτελέσιμες & εγγράψιμες** εντός του PPL. Μετά την έξοδο, επιστρέφουν σε read-only / non-writable. Αυτό εξασφαλίζει ότι μόνο οι ελεγμένες ρουτίνες PPL μπορούν να γράψουν σε προστατευόμενες σελίδες.
- Έξω από το PPL, οι προσπάθειες του kernel κώδικα να γράψουν σε αυτές τις προστατευμένες σελίδες θα προκαλέσουν fault (permission denied) επειδή η APRR χαρτογράφηση για εκείνο το code domain δεν επιτρέπει εγγραφή.

#### Protected page categories

Οι σελίδες που συνήθως προστατεύει το PPL περιλαμβάνουν:

- Δομές page table (translation table entries, mapping metadata)
- Σελίδες κώδικα του πυρήνα, ειδικά αυτές που περιέχουν κρίσιμη λογική
- Code-sign metadata (trust caches, signature blobs)
- Πίνακες entitlements, πίνακες επιβολής signatures
- Άλλες υψηλής αξίας δομές πυρήνα όπου ένα patch θα επέτρεπε παράκαμψη ελέγχων υπογραφής ή χειρισμό credentials

Η ιδέα είναι ότι ακόμη κι αν η μνήμη του πυρήνα ελέγχεται πλήρως, ο attacker δεν μπορεί απλά να κάνει patch ή να ξαναγράψει αυτές τις σελίδες, εκτός αν επίσης συμβιβάσει ρουτίνες του PPL ή παρακάμψει το PPL.

#### Known Bypasses & Vulnerabilities

1. **Project Zero’s PPL bypass (stale TLB trick)**

- Ένα δημόσιο writeup από το Project Zero περιγράφει μια παράκαμψη που εμπλέκει **stale TLB entries**.
- Η ιδέα:

1. Allocate δύο φυσικές σελίδες A και B, σημαδέψτε τις ως PPL σελίδες (ώστε να προστατεύονται).
2. Χαρτογραφήστε δύο virtual διευθύνσεις P και Q των οποίων οι L3 translation table σελίδες προέρχονται από A και B.
3. Περάστε ένα thread να προσπελάζει συνεχώς το Q, διατηρώντας την TLB εγγραφή του ζωντανή.
4. Καλέστε `pmap_remove_options()` για να αφαιρέσετε mappings που ξεκινούν από P· λόγω ενός bug, ο κώδικας καταλάθος αφαιρεί τα TTEs για τόσο το P όσο και το Q, αλλά μόνο η TLB εγγραφή για το P αδειάζει, αφήνοντας την stale εγγραφή του Q ενεργή.
5. Επαναχρησιμοποιήστε το B (η σελίδα του table του Q) για να χαρτογραφήσετε αυθαίρετη μνήμη (π.χ. PPL-protected pages). Επειδή η stale TLB εγγραφή εξακολουθεί να χαρτογραφεί το παλιό mapping του Q, αυτό το mapping παραμένει έγκυρο για εκείνο το context.
6. Μέσω αυτού, ο attacker μπορεί να τοποθετήσει writable mapping για PPL-protected pages χωρίς να περάσει από το PPL interface.

- Αυτό το exploit απαιτούσε λεπτό έλεγχο φυσικών mappings και συμπεριφοράς TLB. Δείχνει ότι ένα security boundary που βασίζεται στην ορθότητα TLB / mapping πρέπει να είναι εξαιρετικά προσεκτικό όσον αφορά τις TLB invalidations και τη συνοχή των mappings.

- Το Project Zero σχολίασε ότι παρακάμψεις σαν αυτή είναι λεπτές και σπάνιες, αλλά δυνατές σε σύνθετα συστήματα. Παρόλα αυτά, θεωρούν το PPL μια σοβαρή/ισχυρή μείωση κινδύνου.

2. **Other potential hazards & constraints**

- Αν ένας kernel exploit μπορεί άμεσα να εισέλθει σε PPL routines (μέσω κλήσης των PPL wrappers), μπορεί να παρακάμψει τους περιορισμούς. Επομένως η επικύρωση των ορισμάτων είναι κρίσιμη.
- Σφάλματα στον ίδιο τον κώδικα PPL (π.χ. overflow σε αριθμητικούς χειρισμούς, έλεγχοι ορίων) μπορούν να επιτρέψουν out-of-bounds τροποποιήσεις εντός PPL. Το Project Zero παρατήρησε ότι τέτοιο bug στο `pmap_remove_options_internal()` εκμεταλλεύτηκε στην παράκαμψή τους.
- Το PPL boundary είναι αδιαίρετα συνδεδεμένο με την επιβολή από το hardware (APRR, memory controller), οπότε είναι τόσο ισχυρό όσο και η υλοποίηση του hardware.

#### Example
<details>
<summary>Code Example</summary>
Here’s a simplified pseudocode / logic showing how a kernel might call into PPL to modify protected pages:
```c
// In kernel (outside PPL domain)
function kernel_modify_pptable(pt_addr, new_entry) {
// validate arguments, etc.
return ppl_call_modify(pt_addr, new_entry)  // call PPL wrapper
}

// In PPL (trusted domain)
function ppl_call_modify(pt_addr, new_entry) {
// temporarily enable write access to protected pages (via APRR adjustments)
aprr_set_index_for_write(PPL_INDEX)
// perform the modification
*pt_addr = new_entry
// restore permissions (make pages read-only again)
aprr_restore_default()
return success
}

// If kernel code outside PPL does:
*pt_addr = new_entry  // a direct write
// It will fault because APRR mapping for non-PPL domain disallows write to that page
```
<details>
<summary>Παράδειγμα</summary>
Ο kernel μπορεί να κάνει πολλές κανονικές λειτουργίες, αλλά μόνο μέσω των ρουτινών `ppl_call_*` μπορεί να αλλάξει προστατευμένα mappings ή να επιδιορθώσει κώδικα.
</details>

<details>
<summary>Παράδειγμα</summary>
A kernel exploit προσπαθεί να υπεργράψει τον entitlement table, ή να απενεργοποιήσει το code-sign enforcement τροποποιώντας ένα kernel signature blob. Επειδή αυτή η σελίδα είναι PPL-protected, η εγγραφή αποκλείεται εκτός κι αν γίνει μέσω του PPL interface. Έτσι, ακόμα και με kernel code execution, δεν μπορείτε να παρακάμψετε τους περιορισμούς του code-sign ή να τροποποιήσετε αυθαίρετα credential data.
Σε iOS 17+ ορισμένες συσκευές χρησιμοποιούν SPTM για περαιτέρω απομόνωση των PPL-managed pages.
</details>

#### PPL → SPTM / Αντικαταστάσεις / Μέλλον

- Σε Apple’s modern SoCs (A15 or later, M2 or later), η Apple υποστηρίζει **SPTM** (Secure Page Table Monitor), το οποίο **replaces PPL** για page table protections.
- Η Apple αναφέρει στην τεκμηρίωση: “Page Protection Layer (PPL) and Secure Page Table Monitor (SPTM) enforce execution of signed and trusted code … PPL manages the page table permission overrides … Secure Page Table Monitor replaces PPL on supported platforms.”
- Η αρχιτεκτονική SPTM πιθανόν μεταφέρει περισσότερη επιβολή πολιτικής σε έναν υψηλότερου προνομίου monitor έξω από τον έλεγχο του kernel, μειώνοντας περαιτέρω το trust boundary.

### MTE | EMTE | MIE

Εδώ είναι μια πιο υψηλού επιπέδου περιγραφή του πώς λειτουργεί το EMTE στο πλαίσιο του Apple’s MIE setup:

1. **Ανάθεση tag**
- Όταν γίνεται allocation μνήμης (π.χ. στον kernel ή στο user space μέσω secure allocators), ένα **secret tag** αντιστοιχίζεται σε αυτό το μπλοκ.
- Ο pointer που επιστρέφεται στον user ή kernel περιλαμβάνει αυτό το tag στα high bits (χρησιμοποιώντας TBI / top byte ignore mechanisms).

2. **Έλεγχος tag κατά την πρόσβαση**
- Όποτε εκτελείται load ή store χρησιμοποιώντας pointer, το hardware ελέγχει ότι το tag του pointer ταιριάζει με το tag του μπλοκ μνήμης (allocation tag). Αν υπάρχει mismatch, προκαλείται fault άμεσα (εφόσον είναι synchronous).
- Επειδή είναι synchronous, δεν υπάρχει παράθυρο “delayed detection”.

3. **Retagging κατά το free / reuse**
- Όταν η μνήμη απελευθερώνεται, ο allocator αλλάζει το tag του μπλοκ (ώστε παλαιότεροι pointers με παλιά tags να μην ταιριάζουν πλέον).
- Ένας use-after-free pointer επομένως θα έχει stale tag και θα υπάρχει mismatch όταν προσεγγιστεί.

4. **Διάκριση neighbor-tag για τον εντοπισμό overflows**
- Γειτονικές allocations λαμβάνουν διαφορετικά tags. Αν ένα buffer overflow ξεχειλίσει στη μνήμη του neighbor, το tag mismatch προκαλεί fault.
- Αυτό είναι ιδιαίτερα ισχυρό στον εντοπισμό μικρών overflows που διασχίζουν όρια.

5. **Επιβολή εμπιστευτικότητας tag**
- Η Apple πρέπει να αποτρέψει το tag values από το να γίνουν leaked (επειδή αν ο attacker μάθει το tag, θα μπορούσε να κατασκευάσει pointers με σωστά tags).
- Περιλαμβάνουν προστασίες (microarchitectural / speculative controls) για να αποφευχθεί side-channel leakage των bit του tag.

6. **Ενσωμάτωση kernel και user-space**
- Η Apple χρησιμοποιεί EMTE όχι μόνο στο user-space αλλά και σε kernel / OS-critical components (για να προστατεύσει τον kernel από memory corruption).
- Το hardware/OS διασφαλίζει ότι οι κανόνες tag εφαρμόζονται ακόμη και όταν ο kernel εκτελείται εκ μέρους του user space.

<details>
<summary>Παράδειγμα</summary>
```
Allocate A = 0x1000, assign tag T1
Allocate B = 0x2000, assign tag T2

// pointer P points into A with tag T1
P = (T1 << 56) | 0x1000

// Valid store
*(P + offset) = value // tag T1 matches allocation → allowed

// Overflow attempt: P’ = P + size_of_A (into B region)
*(P' + delta) = value
→ pointer includes tag T1 but memory block has tag T2 → mismatch → fault

// Free A, allocator retags it to T3
free(A)

// Use-after-free:
*(P) = value
→ pointer still has old tag T1, memory region is now T3 → mismatch → fault
```
</details>

#### Περιορισμοί & προκλήσεις

- **Intrablock overflows**: Αν το overflow μένει μέσα στην ίδια allocation (δεν διασχίζει boundary) και το tag παραμένει το ίδιο, το tag mismatch δεν το ανιχνεύει.
- **Tag width limitation**: Διατίθενται μόνο λίγα bits (π.χ. 4 bits, ή μικρό domain) για tag—περιορισμένο namespace.
- **Side-channel leaks**: Αν tag bits μπορούν να be leaked (μέσω cache / speculative execution), ο attacker μπορεί να μάθει έγκυρα tags και να παρακάμψει. Η Tag Confidentiality Enforcement της Apple στοχεύει να μετριάσει αυτό.
- **Performance overhead**: Οι έλεγχοι tag σε κάθε load/store προσθέτουν κόστος· η Apple πρέπει να βελτιστοποιήσει το hardware για να μειώσει το overhead.
- **Compatibility & fallback**: Σε παλαιότερο hardware ή τμήματα που δεν υποστηρίζουν EMTE, πρέπει να υπάρχει fallback. Η Apple λέει ότι MIE ενεργοποιείται μόνο σε συσκευές με υποστήριξη.
- **Complex allocator logic**: Ο allocator πρέπει να διαχειρίζεται tags, retagging, alignment των boundaries και να αποφεύγει mis-tag collisions. Σφάλματα στην allocator logic μπορούν να εισαγάγουν ευπάθειες.
- **Mixed memory / hybrid areas**: Μερική μνήμη μπορεί να παραμείνει untagged (legacy), κάνοντας την interoperability πιο περίπλοκη.
- **Speculative / transient attacks**: Όπως με πολλές μικροαρχιτεκτονικές προστασίες, speculative execution ή micro-op fusions μπορεί προσωρινά να παρακάμψουν checks ή να leak tag bits.
- **Limited to supported regions**: Η Apple μπορεί να εφαρμόζει EMTE μόνο σε επιλεγμένες, high-risk περιοχές (kernel, security-critical subsystems), όχι παγκοσμίως.

---

## Κύριες βελτιώσεις / διαφορές σε σχέση με το standard MTE

Εδώ είναι οι βελτιώσεις και οι αλλαγές που τονίζει η Apple:

| Feature | Original MTE | EMTE (Apple’s enhanced) / MIE |
|---|---|---|
| **Check mode** | Supports synchronous and asynchronous modes. In async, tag mismatches are reported later (delayed)| Apple insists on **synchronous mode** by default—tag mismatches are caught immediately, no delay/race windows allowed.|
| **Coverage of non-tagged memory** | Accesses to non-tagged memory (e.g. globals) may bypass checks in some implementations | EMTE requires that accesses from a tagged region to non-tagged memory also validate tag knowledge, making it harder to bypass by mixing allocations.|
| **Tag confidentiality / secrecy** | Tags might be observable or leaked via side channels | Apple adds **Tag Confidentiality Enforcement**, which attempts to prevent leakage of tag values (via speculative side-channels etc.).|
| **Allocator integration & retagging** | MTE leaves much of allocator logic to software | Apple’s secure typed allocators (kalloc_type, xzone malloc, etc.) integrate with EMTE: when memory is allocated or freed, tags are managed at fine granularity.|
| **Always-on by default** | In many platforms, MTE is optional or off by default | Apple enables EMTE / MIE by default on supported hardware (e.g. iPhone 17 / A19) for kernel and many user processes.|

Επειδή η Apple ελέγχει τόσο το hardware όσο και το software stack, μπορεί να επιβάλει EMTE αυστηρά, να αποφύγει performance προβλήματα και να κλείσει side-channel τρύπες.

---

## Πώς λειτουργεί το EMTE στην πράξη (Apple / MIE)

Εδώ είναι μια υψηλού επιπέδου περιγραφή του πώς λειτουργεί το EMTE στο setup της Apple / MIE:

1. **Tag assignment**
- Όταν δεσμεύεται μνήμη (π.χ. στον kernel ή user space μέσω secure allocators), αποδίδεται ένα **secret tag** σε αυτό το block.
- Ο pointer που επιστρέφεται στον user ή kernel περιλαμβάνει αυτό το tag στα high bits (χρησιμοποιώντας TBI / top byte ignore μηχανισμούς).

2. **Tag checking on access**
- Όποτε εκτελείται ένα load ή store χρησιμοποιώντας έναν pointer, το hardware ελέγχει ότι το pointer’s tag ταιριάζει με το memory block’s tag (allocation tag). Αν υπάρχει mismatch, γίνεται fault αμέσως (επειδή synchronous).
- Επειδή είναι synchronous, δεν υπάρχει "delayed detection" παράθυρο.

3. **Retagging on free / reuse**
- Όταν η μνήμη απελευθερώνεται, ο allocator αλλάζει το block’s tag (ώστε παλαιότεροι pointers με παλιά tags να μην ταιριάζουν πλέον).
- Ένας use-after-free pointer θα έχει stale tag και θα προκαλέσει mismatch όταν προσπελαστεί.

4. **Neighbor-tag differentiation to catch overflows**
- Γειτονικές allocations παίρνουν διαφορετικά tags. Αν ένα buffer overflow χυθεί στη γειτονική μνήμη, το tag mismatch προκαλεί fault.
- Αυτό είναι ιδιαίτερα ισχυρό στο να ανιχνεύει μικρά overflows που διασχίζουν boundary.

5. **Tag confidentiality enforcement**
- Η Apple πρέπει να αποτρέψει να leak tag values (επειδή αν ο attacker μάθει το tag, μπορεί να δημιουργήσει pointers με σωστά tags).
- Περιλαμβάνουν προστασίες (microarchitectural / speculative controls) για να αποφευχθεί η side-channel διαρροή των tag bits.

6. **Kernel and user-space integration**
- Η Apple χρησιμοποιεί EMTE όχι μόνο στο user-space αλλά και στον kernel / OS-critical components (για να προστατεύσει τον kernel από memory corruption).
- Το hardware/OS διασφαλίζει ότι οι κανόνες των tags εφαρμόζονται ακόμη και όταν ο kernel εκτελεί εργασίες για λογαριασμό του user space.

Επειδή το EMTE είναι ενσωματωμένο στο MIE, η Apple το χρησιμοποιεί σε synchronous mode στις κύριες επιφάνειες επίθεσης, όχι ως opt-in ή debugging mode.

---

## Exception handling in XNU

Όταν προκύπτει μια **exception** (π.χ., `EXC_BAD_ACCESS`, `EXC_BAD_INSTRUCTION`, `EXC_CRASH`, `EXC_ARM_PAC`, κ.λπ.), το **Mach layer** του XNU kernel είναι υπεύθυνο να το αναχαιτίσει πριν μετατραπεί σε UNIX-style **signal** (όπως `SIGSEGV`, `SIGBUS`, `SIGILL`, ...).

Αυτή η διαδικασία περιλαμβάνει πολλαπλά στρώματα propagation και handling πριν φτάσει στο user space ή μετατραπεί σε BSD signal.


### Exception Flow (Υψηλού Επιπέδου)

1.  **CPU triggers a synchronous exception** (π.χ. invalid pointer dereference, PAC failure, illegal instruction, κ.λπ.).

2.  **Low-level trap handler** τρέχει (`trap.c`, `exception.c` στο XNU source).

3.  Ο trap handler καλεί **`exception_triage()`**, τον πυρήνα του Mach exception handling.

4.  Το `exception_triage()` αποφασίζει πώς να δρομολογήσει την exception:

-   Πρώτα προς το **thread's exception port**.

-   Έπειτα προς το **task's exception port**.

-   Έπειτα προς το **host's exception port** (συχνά `launchd` ή `ReportCrash`).

Αν κανένα από αυτά τα ports δεν χειριστεί την exception, ο kernel μπορεί:

-   **Να την μετατρέψει σε BSD signal** (για user-space processes).

-   **Να κάνει panic** (για kernel-space exceptions).


### Core Function: `exception_triage()`

Η συνάρτηση `exception_triage()` δρομολογεί Mach exceptions στην αλυσίδα των πιθανών handlers μέχρι κάποιος να την χειριστεί ή μέχρι να καταστεί τελικά fatal. Ορίζεται σε `osfmk/kern/exception.c`.
```c
void exception_triage(exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt);
```
**Τυπική Ροή Κλήσεων:**

`exception_triage()
└── exception_deliver()
├── exception_deliver_thread()
├── exception_deliver_task()
└── exception_deliver_host()`

Αν όλα αποτύχουν → χειρίζεται από `bsd_exception()` → μεταφράζεται σε σήμα όπως `SIGSEGV`.


### Θύρες Εξαιρέσεων

Κάθε αντικείμενο Mach (thread, task, host) μπορεί να εγγράψει **exception ports**, όπου αποστέλλονται τα exception messages.

Ορίζονται από το API:
```
task_set_exception_ports()
thread_set_exception_ports()
host_set_exception_ports()
```
Κάθε exception port έχει:

-   Ένα **mask** (ποιες εξαιρέσεις θέλει να λάβει)
-   Ένα **port name** (Mach port για να λαμβάνει μηνύματα)
-   Μια **behavior** (πώς ο kernel στέλνει το μήνυμα)
-   Ένα **flavor** (ποιο thread state να συμπεριλάβει)


### Debuggers and Exception Handling

Ένας **debugger** (π.χ. LLDB) ρυθμίζει ένα **exception port** στην target task ή thread, συνήθως χρησιμοποιώντας `task_set_exception_ports()`.

**Όταν συμβαίνει μια εξαίρεση:**

-   Το Mach μήνυμα στέλνεται στη διαδικασία του debugger.
-   Ο debugger μπορεί να αποφασίσει να **handle** (επαναφορά εκτέλεσης, τροποποίηση registers, παράλειψη εντολής) ή να **not handle** την εξαίρεση.
-   Αν ο debugger δεν την αναλάβει, η εξαίρεση διαδίδεται στο επόμενο επίπεδο (task → host).


### Flow of `EXC_BAD_ACCESS`

1.  Το thread αποαναφέρεται σε μη έγκυρο pointer → η CPU σηκώνει Data Abort.

2.  Ο kernel trap handler καλεί `exception_triage(EXC_BAD_ACCESS, ...)`.

3.  Το μήνυμα αποστέλλεται σε:

-   Thread port → (ο debugger μπορεί να αναχαιτίσει breakpoint).

-   Αν ο debugger αγνοήσει → Task port → (process-level handler).

-   Αν αγνοηθεί → Host port (συνήθως ReportCrash).

4.  Αν κανείς δεν το αναλάβει → `bsd_exception()` μεταφράζει σε `SIGSEGV`.


### PAC Exceptions

Όταν Pointer Authentication (PAC) αποτυγχάνει (mismatch υπογραφής), εγείρεται μια ειδική Mach εξαίρεση:

-   **`EXC_ARM_PAC`** (type)
-   Οι codes μπορεί να περιέχουν λεπτομέρειες (π.χ., τύπο key, τύπο pointer).

Αν το binary έχει το flag **`TFRO_PAC_EXC_FATAL`**, ο kernel αντιμετωπίζει τις αποτυχίες PAC ως **fatal**, παρακάμπτοντας την αναχαίτιση από τον debugger. Αυτό γίνεται για να αποτρέψει επιτιθέμενους από το να χρησιμοποιήσουν debuggers για να παρακάμψουν τους ελέγχους PAC και είναι ενεργό για platform binaries.


### Software Breakpoints

Ένα software breakpoint (`int3` σε x86, `brk` σε ARM64) υλοποιείται προκαλώντας εσκεμμένο fault.\
Ο debugger το πιάσει μέσω του exception port:

-   Τροποποιεί το instruction pointer ή τη μνήμη.
-   Επαναφέρει την αρχική εντολή.
-   Επαναφέρει την εκτέλεση.

Αυτός ο ίδιος μηχανισμός είναι που επιτρέπει να "πιάσεις" μια PAC εξαίρεση --- **εκτός αν `TFRO_PAC_EXC_FATAL`** είναι ενεργό, οπότε ποτέ δεν φτάνει στον debugger.


### Conversion to BSD Signals

Αν κανένας handler δεν αποδεχτεί την εξαίρεση:

-   Ο kernel καλεί `task_exception_notify() → bsd_exception()`.

-   Αυτό αντιστοιχίζει Mach exceptions σε signals:

| Mach Exception | Signal |
| --- | --- |
| EXC_BAD_ACCESS | SIGSEGV or SIGBUS |
| EXC_BAD_INSTRUCTION | SIGILL |
| EXC_ARITHMETIC | SIGFPE |
| EXC_SOFTWARE | SIGTRAP |
| EXC_BREAKPOINT | SIGTRAP |
| EXC_CRASH | SIGKILL |
| EXC_ARM_PAC | SIGILL (on non-fatal) |


### Key Files in XNU Source

-   `osfmk/kern/exception.c` → Core of `exception_triage()`, `exception_deliver_*()`.

-   `bsd/kern/kern_sig.c` → Signal delivery logic.

-   `osfmk/arm64/trap.c` → Low-level trap handlers.

-   `osfmk/mach/exc.h` → Exception codes and structures.

-   `osfmk/kern/task.c` → Task exception port setup.

---

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

Ο kernel χρησιμοποιούσε έναν **zone allocator** (`kalloc`) διαιρεμένο σε σταθερού μεγέθους "ζώνες". Κάθε zone αποθηκεύει μόνο allocations μιας συγκεκριμένης size class.

Από το screenshot:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Πολύ μικρές kernel δομές, pointers.                                         |
| `default.kalloc.32`  | 32 bytes     | Μικρές δομές, object headers.                                               |
| `default.kalloc.64`  | 64 bytes     | IPC messages, πολύ μικροί kernel buffers.                                   |
| `default.kalloc.128` | 128 bytes    | Μεσαία αντικείμενα όπως μέρη του `OSObject`.                                |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Μεγάλες δομές, IOSurface/γραφικά metadata.                                  |

Πώς λειτουργούσε:
- Κάθε αίτημα allocation στρογγυλοποιούνταν προς τα πάνω στην πλησιέστερη zone size.
(π.χ., ένα αίτημα 50-byte καταλήγει στη zone `kalloc.64`).
- Η μνήμη σε κάθε zone κρατιόταν σε μια **freelist** — τα chunks που απελευθερώνονταν από τον kernel επέστρεφαν σε εκείνη τη zone.
- Αν υπερβαίνατε ένα 64-byte buffer, θα υπέγραφαν το **επόμενο αντικείμενο στην ίδια zone**.

Γι' αυτό το heap spraying / feng shui ήταν τόσο αποτελεσματικό: μπορούσατε να προβλέψετε γείτονες αντικειμένων ψεκάζοντας allocations της ίδιας size class.

### The freelist

Μέσα σε κάθε kalloc zone, τα freed αντικείμενα δεν επιστρέφονταν άμεσα στο σύστημα — μπαίνανε σε μια freelist, μια συνδεδεμένη λίστα διαθέσιμων chunks.

- Όταν ένα chunk απελευθερωνόταν, ο kernel έγραφε έναν pointer στην αρχή του chunk → τη διεύθυνση του επόμενου free chunk στην ίδια zone.

- Η zone κρατούσε έναν HEAD pointer προς το πρώτο free chunk.

- Η allocation πάντα χρησιμοποιούσε το τρέχον HEAD:

1. Pop HEAD (επιστρέφει αυτή τη μνήμη στον caller).

2. Ενημερώνει HEAD = HEAD->next (αποθηκευμένο στην κεφαλίδα του freed chunk).

- Το freeing έσπρωχνε τα chunks πίσω:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

Άρα η freelist ήταν απλά μια συνδεδεμένη λίστα χτισμένη μέσα στη μνήμη των freed αντικειμένων.

Κανονική κατάσταση:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Εκμετάλλευση του freelist

Επειδή τα πρώτα 8 bytes ενός free chunk αντιστοιχούν στο freelist pointer, ένας επιτιθέμενος μπορεί να το αλλοιώσει:

1. **Heap overflow** σε διπλανό freed chunk → να αντικαταστήσει τον δείκτη “next” του.

2. **Use-after-free** εγγραφή σε freed αντικείμενο → να αντικαταστήσει τον δείκτη “next” του.

Μετά, στην επόμενη allocation αυτού του μεγέθους:

- Ο allocator αφαιρεί (pops) το αλλοιωμένο chunk.

- Ακολουθεί τον δείκτη “next” που παρείχε ο επιτιθέμενος.

- Επιστρέφει pointer σε αυθαίρετη μνήμη, επιτρέποντας fake object primitives ή targeted overwrite.

Οπτικό παράδειγμα του freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
This freelist design made exploitation highly effective pre-hardening: predictable neighbors from heap sprays, raw pointer freelist links, and no type separation allowed attackers to escalate UAF/overflow bugs into arbitrary kernel memory control.

### Heap Grooming / Feng Shui
The goal of heap grooming is to **shape the heap layout** so that when an attacker triggers an overflow or use-after-free, the target (victim) object sits right next to an attacker-controlled object.\
That way, when memory corruption happens, the attacker can reliably overwrite the victim object with controlled data.

**Steps:**

1. Spray allocations (fill the holes)
- Over time, the kernel heap gets fragmented: some zones have holes where old
objects were freed.
- The attacker first makes lots of dummy allocations to fill these gaps, so
the heap becomes “packed” and predictable.

2. Force new pages
- Once the holes are filled, the next allocations must come from new pages
added to the zone.
- Fresh pages mean objects will be clustered together, not scattered across
old fragmented memory.
- This gives the attacker much better control of neighbors.

3. Place attacker objects
- The attacker now sprays again, creating lots of attacker-controlled objects
in those new pages.
- These objects are predictable in size and placement (since they all belong
to the same zone).

4. Free a controlled object (make a gap)
- The attacker deliberately frees one of their own objects.
- This creates a “hole” in the heap, which the allocator will later reuse for
the next allocation of that size.

5. Victim object lands in the hole
- The attacker triggers the kernel to allocate the victim object (the one
they want to corrupt).
- Since the hole is the first available slot in the freelist, the victim is
placed exactly where the attacker freed their object.

6. Overflow / UAF into victim
- Now the attacker has attacker-controlled objects around the victim.
- By overflowing from one of their own objects (or reusing a freed one), they
can reliably overwrite the victim’s memory fields with chosen values.

**Why it works**:

- Zone allocator predictability: allocations of the same size always come from
the same zone.
- Freelist behavior: new allocations reuse the most recently freed chunk first.
- Heap sprays: attacker fills memory with predictable content and controls layout.
- End result: attacker controls where the victim object lands and what data sits
next to it.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Η Apple ενίσχυσε τον allocator και έκανε το **heap grooming πολύ πιο δύσκολο**:

### 1. From Classic kalloc to kalloc_type
- **Before**: a single `kalloc.<size>` zone existed for each size class (16, 32, 64, … 1280, etc.). Any object of that size was placed there → attacker objects could sit next to privileged kernel objects.
- **Now**:
- Kernel objects are allocated from **typed zones** (`kalloc_type`).
- Each type of object (e.g., `ipc_port_t`, `task_t`, `OSString`, `OSData`) has its own dedicated zone, even if they’re the same size.
- The mapping between object type ↔ zone is generated from the **kalloc_type system** at compile time.

An attacker can no longer guarantee that controlled data (`OSData`) ends up adjacent to sensitive kernel objects (`task_t`) of the same size.

### 2. Slabs and Per-CPU Caches
- The heap is divided into **slabs** (pages of memory carved into fixed-size chunks for that zone).
- Each zone has a **per-CPU cache** to reduce contention.
- Allocation path:
1. Try per-CPU cache.
2. If empty, pull from the global freelist.
3. If freelist is empty, allocate a new slab (one or more pages).
- **Benefit**: This decentralization makes heap sprays less deterministic, since allocations may be satisfied from different CPUs’ caches.

### 3. Randomization inside zones
- Within a zone, freed elements are not handed back in simple FIFO/LIFO order.
- Modern XNU uses **encoded freelist pointers** (safe-linking like Linux, introduced ~iOS 14).
- Each freelist pointer is **XOR-encoded** with a per-zone secret cookie.
- This prevents attackers from forging a fake freelist pointer if they gain a write primitive.
- Some allocations are **randomized in their placement within a slab**, so spraying doesn’t guarantee adjacency.

### 4. Guarded Allocations
- Certain critical kernel objects (e.g., credentials, task structures) are allocated in **guarded zones**.
- These zones insert **guard pages** (unmapped memory) between slabs or use **redzones** around objects.
- Any overflow into the guard page triggers a fault → immediate panic instead of silent corruption.

### 5. Page Protection Layer (PPL) and SPTM
- Even if you control a freed object, you can’t modify all of kernel memory:
- **PPL (Page Protection Layer)** enforces that certain regions (e.g., code signing data, entitlements) are **read-only** even to the kernel itself.
- On **A15/M2+ devices**, this role is replaced/enhanced by **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- These hardware-enforced layers mean attackers can’t escalate from a single heap corruption to arbitrary patching of critical security structures.
- **(Added / Enhanced)**: also, **PAC (Pointer Authentication Codes)** is used in the kernel to protect pointers (especially function pointers, vtables) so that forging or corrupting them becomes harder.
- **(Added / Enhanced)**: zones may enforce **zone_require / zone enforcement**, i.e. that an object freed can only be returned through its correct typed zone; invalid cross-zone frees may panic or be rejected. (Apple alludes to this in their memory safety posts)

### 6. Large Allocations
- Not all allocations go through `kalloc_type`.
- Very large requests (above ~16 KB) bypass typed zones and are served directly from **kernel VM (kmem)** via page allocations.
- These are less predictable, but also less exploitable, since they don’t share slabs with other objects.

### 7. Allocation Patterns Attackers Target
Even with these protections, attackers still look for:
- **Reference count objects**: if you can tamper with retain/release counters, you may cause use-after-free.
- **Objects with function pointers (vtables)**: corrupting one still yields control flow.
- **Shared memory objects (IOSurface, Mach ports)**: these are still attack targets because they bridge user ↔ kernel.

But — unlike before — you can’t just spray `OSData` and expect it to neighbor a `task_t`. You need **type-specific bugs** or **info leaks** to succeed.

### Example: Allocation Flow in Modern Heap

Suppose userspace calls into IOKit to allocate an `OSData` object:

1. **Type lookup** → `OSData` maps to `kalloc_type_osdata` zone (size 64 bytes).
2. Check per-CPU cache for free elements.
- If found → return one.
- If empty → go to global freelist.
- If freelist empty → allocate a new slab (page of 4KB → 64 chunks of 64 bytes).
3. Return chunk to caller.

**Freelist pointer protection**:
- Each freed chunk stores the address of the next free chunk, but encoded with a secret key.
- Overwriting that field with attacker data won’t work unless you know the key.

---

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages, and **PAC** protects pointers |
| Allocation reuse validation     | None (freelist pointers raw)                               | **zone_require / zone enforcement**             |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |
| Large allocations handling      | All small allocations managed equally                       | Large ones bypass zones → handled via VM         |

---

## Modern Userland Heap (iOS, macOS — type-aware / xzone malloc)

Σε πρόσφατες εκδόσεις των Apple OS (ειδικά iOS 17+), η Apple εισήγαγε έναν πιο ασφαλή userland allocator, **xzone malloc** (XZM). Αυτός είναι ο user-space ανάλογος του kernel’s `kalloc_type`, εφαρμόζοντας type awareness, metadata isolation και memory tagging safeguards.

### Goals & Design Principles

- **Type segregation / type awareness**: group allocations by *type or usage (pointer vs data)* to prevent type confusion and cross-type reuse.
- **Metadata isolation**: separate heap metadata (e.g. free lists, size/state bits) from object payloads so that out-of-bounds writes are less likely to corrupt metadata.
- **Guard pages / redzones**: insert unmapped pages or padding around allocations to catch overflows.
- **Memory tagging (EMTE / MIE)**: work in conjunction with hardware tagging to detect use-after-free, out-of-bounds, and invalid accesses.
- **Scalable performance**: maintain low overhead, avoid excessive fragmentation, and support many allocations per second with low latency.

### Architecture & Components

Below are the main elements in the xzone allocator:

#### Segment Groups & Zones

- **Segment groups** partition the address space by usage categories: e.g. `data`, `pointer_xzones`, `data_large`, `pointer_large`.
- Each segment group contains **segments** (VM ranges) that host allocations for that category.
- Associated with each segment is a **metadata slab** (separate VM area) that stores metadata (e.g. free/used bits, size classes) for that segment. This **out-of-line (OOL) metadata** ensures that metadata is not intermingled with object payloads, mitigating corruption from overflows.
- Segments are carved into **chunks** (slices) which in turn are subdivided into **blocks** (allocation units). A chunk is tied to a specific size class and segment group (i.e. all blocks in a chunk share the same size & category).
- For small / medium allocations, it will use fixed-size chunks; for large/huges, it may map separately.

#### Chunks & Blocks

- A **chunk** is a region (often several pages) dedicated to allocations of one size class within a group.
- Inside a chunk, **blocks** are slots available for allocations. Freed blocks are tracked via the metadata slab — e.g. via bitmaps or free lists stored out-of-line.
- Between chunks (or within), **guard slices / guard pages** may be inserted (e.g. unmapped slices) to catch out-of-bounds writes.

#### Type / Type ID

- Every allocation site (or call to malloc, calloc, etc.) is associated with a **type identifier** (a `malloc_type_id_t`) which encodes what kind of object is being allocated. That type ID is passed to the allocator, which uses it to select which zone / segment to serve the allocation.
- Because of this, even if two allocations have the same size, they may go into entirely different zones if their types differ.
- In early iOS 17 versions, not all APIs (e.g. CFAllocator) were fully type-aware; Apple addressed some of those weaknesses in iOS 18.

---

### Allocation & Freeing Workflow

Here is a high-level flow of how allocation and deallocation operate in xzone:

1. **malloc / calloc / realloc / typed alloc** is invoked with a size and type ID.
2. The allocator uses the **type ID** to pick the correct segment group / zone.
3. Within that zone/segment, it seeks a chunk that has free blocks of the requested size.
- It may consult **local caches / per-thread pools** or **free block lists** from metadata.
- If no free block is available, it may allocate a new chunk in that zone.
4. The metadata slab is updated (free bit cleared, bookkeeping).
5. If memory tagging (EMTE) is in play, the returned block gets a **tag** assigned, and metadata is updated to reflect its “live” state.
6. When `free()` is called:
- The block is marked as freed in metadata (via OOL slab).
- The block may be placed into a free list or pooled for reuse.
- Optionally, block contents may be cleared or poisoned to reduce data leaks or use-after-free exploitation.
- The hardware tag associated with the block may be invalidated or re-tagged.
- If an entire chunk becomes free (all blocks freed), the allocator may **reclaim** that chunk (unmap it or return to OS) under memory pressure.

---

### Security Features & Hardening

These are the defenses built into modern userland xzone:

| Feature | Purpose | Notes |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | Prevent overflow from corrupting metadata | Metadata lives in separate VM region (metadata slab)|
| **Guard pages / unmapped slices** | Catch out-of-bounds writes | Helps detect buffer overflows rather than silently corrupting adjacent blocks|
| **Type-based segregation** | Prevent cross-type reuse & type confusion | Even same-size allocations from different types go to different zones|
| **Memory Tagging (EMTE / MIE)** | Detect invalid access, stale references, OOB, UAF | xzone works in concert with hardware EMTE in synchronous mode (“Memory Integrity Enforcement”)|
| **Delayed reuse / poisoning / zap** | Reduce chance of use-after-free exploitation | Freed blocks may be poisoned, zeroed, or quarantined before reuse |
| **Chunk reclamation / dynamic unmapping** | Reduce memory waste and fragmentation | Entire chunks may be unmapped when unused |
| **Randomization / placement variation** | Prevent deterministic adjacency | Blocks in a chunk and chunk selection may have randomized aspects |
| **Segregation of “data-only” allocations** | Separate allocations that don’t store pointers | Reduces attacker control over metadata or control fields|

---

### Interaction with Memory Integrity Enforcement (MIE / EMTE)

- Apple’s MIE (Memory Integrity Enforcement) is the hardware + OS framework that brings **Enhanced Memory Tagging Extension (EMTE)** into always-on, synchronous mode across major attack surfaces.
- xzone allocator is a fundamental foundation of MIE in user space: allocations done via xzone get tags, and accesses are checked by hardware.
- In MIE, the allocator, tag assignment, metadata management, and tag confidentiality enforcement are integrated to ensure that memory errors (e.g. stale reads, OOB, UAF) are caught immediately, not exploited later.

---

If you like, I can also generate a cheat-sheet or diagram of xzone internals for your book. Do you want me to do that next?
::contentReference[oai:20]{index=20}


---

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


## JSKit-Based Safari Chains and PREYHUNTER Stagers

### Renderer RCE abstraction with JSKit
- **Reusable entry**: Recent in-the-wild chains abused a WebKit JIT bug (patched as CVE-2023-41993) purely to gain JavaScript-level arbitrary read/write. The exploit immediately pivots into a purchased framework called **JSKit**, so any future Safari bug only needs to deliver the same primitive.
- **Version abstraction & PAC bypasses**: JSKit bundles support for a wide range of iOS releases together with multiple, selectable Pointer Authentication Code bypass modules. The framework fingerprints the target build, selects the appropriate PAC bypass logic, and verifies every step (primitive validation, shellcode launch) before progressing.
- **Manual Mach-O mapping**: JSKit parses Mach-O headers directly from memory, resolves the symbols it needs inside dyld-cached images, and can manually map additional Mach-O payloads without writing them to disk. This keeps the renderer process in-memory only and evades code-signature checks tied to filesystem artifacts.
- **Portfolio model**: Debug strings such as *"exploit number 7"* show that the suppliers maintain multiple interchangeable WebKit exploits. Once the JS primitive matches JSKit’s interface, the rest of the chain is unchanged across campaigns.

### Kernel bridge: IPC UAF -> code-sign bypass pattern
- **Kernel IPC UAF (CVE-2023-41992)**: The second stage, still running inside the Safari context, triggers a kernel use-after-free in IPC code, re-allocates the freed object from userland, and abuses the dangling pointers to pivot into arbitrary kernel read/write. The stage also reuses PAC bypass material previously computed by JSKit instead of re-deriving it.
- **Code-signing bypass (CVE-2023-41991)**: With kernel R/W available, the exploit patches the trust cache / code-signing structures so unsigned payloads execute as `system`. The stage then exposes a lightweight kernel R/W service to later payloads.
- **Composed pattern**: This chain demonstrates a reusable recipe that defenders should expect going forward:
```
WebKit renderer RCE -> kernel IPC UAF -> kernel arbitrary R/W -> code-sign bypass -> unsigned system stager
```
### PREYHUNTER helper & watcher modules
- **Watcher anti-analysis**: Ένα αφιερωμένο watcher binary προφίλάρει συνεχώς τη συσκευή και ακυρώνει την kill-chain όταν εντοπίζεται περιβάλλον έρευνας. Ελέγχει `security.mac.amfi.developer_mode_status`, την παρουσία ενός `diagnosticd` console, τα locales `US` ή `IL`, ίχνη jailbreak όπως **Cydia**, διεργασίες όπως `bash`, `tcpdump`, `frida`, `sshd`, ή `checkrain`, mobile AV apps (McAfee, AvastMobileSecurity, NortonMobileSecurity), προσαρμοσμένες ρυθμίσεις HTTP proxy και προσαρμοσμένα root CAs. Η αποτυχία οποιουδήποτε ελέγχου μπλοκάρει περαιτέρω παράδοση payload.
- **Helper surveillance hooks**: Το helper component επικοινωνεί με άλλα στάδια μέσω του `/tmp/helper.sock`, και στη συνέχεια φορτώνει σετ hook με ονόματα **DMHooker** και **UMHooker**. Αυτά τα hooks παρεμβαίνουν στις VOIP audio διαδρομές (οι εγγραφές αποθηκεύονται στο `/private/var/tmp/l/voip_%lu_%u_PART.m4a`), υλοποιούν system-wide keylogger, τραβούν φωτογραφίες χωρίς UI και κάνουν hook στο SpringBoard για να κατασιγάσουν τις ειδοποιήσεις που θα προέκυπταν από αυτές τις ενέργειες. Το helper λειτουργεί έτσι ως stealthy validation + light-surveillance layer πριν εγκατασταθούν βαρύτερα implants όπως το Predator.

### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

## Αναφορές

- [Google Threat Intelligence – Intellexa zero-day exploits continue](https://cloud.google.com/blog/topics/threat-intelligence/intellexa-zero-day-exploits-continue)

{{#include ../../banners/hacktricks-training.md}}
