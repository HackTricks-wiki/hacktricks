# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

### 1. **Code Signing** / Runtime Signature Verification
**Introduced early (iPhone OS → iOS)**
これは基本的な保護の一つです: **すべての実行可能コード**（apps、dynamic libraries、JIT-ed code、extensions、frameworks、caches）は Apple の信頼に根ざした証明書チェーンで暗号的に署名されている必要があります。ランタイムでは、バイナリをメモリにロードする前（または特定の境界を越えてジャンプする前）にシステムが署名を検証します。コードが改変（ビット反転、パッチ）されたり署名が無い場合、ロードは失敗します。

- **Thwarts**: the “classic payload drop + execute” stage in exploit chains; arbitrary code injection; modifying an existing binary to insert malicious logic.
- **Mechanism detail**:
* The Mach-O loader (and dynamic linker) checks code pages, segments, entitlements, team IDs, and that the signature covers the file’s contents.
* For memory regions like JIT caches or dynamically generated code, Apple enforces that pages be signed or validated via special APIs (e.g. `mprotect` with code-sign checks).
* The signature includes entitlements and identifiers; the OS enforces that certain APIs or privileged capabilities require specific entitlements that cannot be forged.

<details>
<summary>Example</summary>
Suppose an exploit obtains code execution in a process and tries to write shellcode into a heap and jump to it. On iOS, that page would need to be flagged executable **and** satisfy code-signature constraints. Since the shellcode isn’t signed with Apple’s certificate, the jump fails or the system rejects making that memory region executable.
</details>


### 2. **CoreTrust**
**Introduced around iOS 14+ era (or gradually in newer devices / later iOS)**
CoreTrust は、バイナリ（システムおよびユーザーバイナリを含む）の**ランタイム署名検証**を行うサブシステムで、ローカルのユーザランドの信頼ストアに頼るのではなく **Apple のルート証明書** に対して検証を行います。

- **Thwarts**: post-install tampering of binaries, jailbreaking techniques that try to swap or patch system libraries or user apps; tricking the system by replacing trusted binaries with malicious counterparts.
- **Mechanism detail**:
* Instead of trusting a local trust database or certificate cache, CoreTrust fetches or refers to Apple’s root directly or verifies intermediate certificates in a secure chain.
* It ensures that modifications (e.g. in the filesystem) to existing binaries are detected and rejected.
* It ties entitlements, team IDs, code signing flags, and other metadata to the binary at load time.

<details>
<summary>Example</summary>
A jailbreak might try to replace `SpringBoard` or `libsystem` with a patched version to gain persistence. But when the OS’s loader or CoreTrust checks, it notices the signature mismatch (or modified entitlements) and refuses to execute.
</details>


### 3. **Data Execution Prevention (DEP / NX / W^X)**
**Introduced in many OSes earlier; iOS had NX-bit / w^x for a long time**
DEP は、書き込み可能（データ用）にマークされたページは **実行不可**、実行可能にマークされたページは **書き込み不可** であることを強制します。ヒープやスタック領域にシェルコードを書き込んで実行することはできません。

- **Thwarts**: direct shellcode execution; classic buffer-overflow → jump to injected shellcode.
- **Mechanism detail**:
* The MMU / memory protection flags (via page tables) enforce the separation.
* Any attempt to mark a writable page executable triggers a system check (and is either forbidden or requires code-sign approval).
* In many cases, making pages executable requires going through OS APIs that enforce additional constraints or checks.

<details>
<summary>Example</summary>
An overflow writes shellcode onto the heap. The attacker attempts `mprotect(heap_addr, size, PROT_EXEC)` to make it executable. But the system refuses or validates that the new page must pass code-sign constraints (which the shellcode cannot).
</details>

### 4. **Address Space Layout Randomization (ASLR)**
**Introduced in iOS ~4–5 era (roughly iOS 4–5 timeframe)**
ASLR は、ライブラリ、heap、stack など主要なメモリ領域のベースアドレスを各プロセス起動ごとにランダム化します。gadget のアドレスは実行ごとに移動します。

- **Thwarts**: hardcoding gadget addresses for ROP/JOP; static exploit chains; blind jumping to known offsets.
- **Mechanism detail**:
* Each loaded library / dynamic module is rebased at a randomized offset.
* Stack and heap base pointers are randomized (within certain entropy limits).
* Sometimes other regions (e.g. mmap allocations) are also randomized.
* Combined with information-leak mitigations, it forces the attacker to first leak an address or pointer to discover base addresses at runtime.

<details>
<summary>Example</summary>
A ROP chain expects gadget at `0x….lib + offset`. But since `lib` is relocated differently each run, the hardcoded chain fails. An exploit must first leak the base address of the module before computing gadget addresses.
</details>


### 5. **Kernel Address Space Layout Randomization (KASLR)**
**Introduced in iOS ~ (iOS 5 / iOS 6 timeframe)**
ユーザ ASLR に類似して、KASLR はブート時に**kernel text** やその他カーネル構造のベースをランダム化します。

- **Thwarts**: kernel-level exploits that rely on fixed location of kernel code or data; static kernel exploits.
- **Mechanism detail**:
* On each boot, the kernel’s base address is randomized (within a range).
* Kernel data structures (like `task_structs`, `vm_map`, etc.) may also be relocated or offset.
* Attackers must first leak kernel pointers or use information disclosure vulnerabilities to compute offsets before hijacking kernel structures or code.

<details>
<summary>Example</summary>
A local vulnerability aims to corrupt a kernel function pointer (e.g. in `vtable`) at `KERN_BASE + offset`. But since `KERN_BASE` is unknown, the attacker must leak it first (e.g. via a read primitive) before computing the correct address for corruption.
</details>


### 6. **Kernel Patch Protection (KPP / AMCC)**
**Introduced in newer iOS / A-series hardware (post around iOS 15–16 era or newer chips)**
KPP (aka AMCC) は、カーネルのテキストページの整合性を（ハッシュやチェックサムで）継続的に監視します。改ざん（パッチ、inline hooks、コード変更）を検出するとカーネルパニックや再起動を引き起こします。

- **Thwarts**: persistent kernel patching (modifying kernel instructions), inline hooks, static function overwrites.
- **Mechanism detail**:
* A hardware or firmware module monitors the kernel text region.
* It periodically or on-demand re-hashes the pages and compares against expected values.
* If mismatches occur outside benign update windows, it panics the device (to avoid persistent malicious patch).
* Attackers must either avoid detection windows or use legitimate patch paths.

<details>
<summary>Example</summary>
An exploit tries to patch a kernel function prologue (e.g. `memcmp`) to intercept calls. But KPP notices that the code page’s hash no longer matches the expected value and triggers a kernel panic, crashing the device before the patch can stabilize.
</details>


### 7. **Kernel Text Read‐Only Region (KTRR)**
**Introduced in modern SoCs (post ~A12 / newer hardware)**
KTRR はハードウェアで強制されるメカニズムで、カーネルテキストがブート時にロックされると EL1（カーネル）からの書き込みが禁止され、コードページをそれ以降書き換えられなくします。

- **Thwarts**: any modifications to kernel code after boot (e.g. patching, in-place code injection) at EL1 privilege level.
- **Mechanism detail**:
* During boot (in secure/bootloader stage), the memory controller (or a secure hardware unit) marks the physical pages containing kernel text as read-only.
* Even if an exploit gains full kernel privileges, it cannot write to those pages to patch instructions.
* To modify them, the attacker must first compromise the boot chain, or subvert KTRR itself.

<details>
<summary>Example</summary>
A privilege-escalation exploit jumps into EL1 and writes a trampoline into a kernel function (e.g. in `syscall` handler). But because the pages are locked read-only by KTRR, the write fails (or triggers fault), so patches aren’t applied.
</details>


### 8. **Pointer Authentication Codes (PAC)**
**Introduced with ARMv8.3 (hardware), Apple beginning with A12 / iOS ~12+**
- PAC は **ARMv8.3-A** で導入されたハードウェア機能で、ポインタ値（戻りアドレス、関数ポインタ、特定のデータポインタ）の改ざん検出のために、ポインタの未使用の上位ビットに小さな暗号的署名（“MAC”）を埋め込みます。
- 署名（“PAC”）はポインタ値と **modifier**（コンテキスト値、例: stack pointer や識別用データ）を用いて計算されます。同じポインタ値でもコンテキストが異なれば異なる PAC が生成されます。
- 利用時には、ポインタをデリファレンスしたりブランチする前に **authenticate** 命令が PAC を検証します。検証が成功すれば PAC は剥がされ純粋なポインタが得られ、無効であればポインタは “poisoned” になるかフォルトが発生します。
- PAC を生成/検証する鍵は特権レジスタ（EL1、カーネル）に存在し、ユーザーモードからは直接読み出せません。
- 多くのシステムでポインタの全 64 ビットが使われているわけではない（例: 48-bit アドレス空間）ため、上位ビットの余剰領域に PAC を保持しても実効アドレスは変わりません。

#### Architectural Basis & Key Types

- ARMv8.3 は **五つの 128-bit 鍵**（それぞれが 2 つの 64-bit システムレジスタで実装）を導入します。
- **APIAKey** — instruction pointers 用（ドメイン “I”, key A）
- **APIBKey** — 第二の instruction pointer key（ドメイン “I”, key B）
- **APDAKey** — data pointers 用（ドメイン “D”, key A）
- **APDBKey** — data pointers 用（ドメイン “D”, key B）
- **APGAKey** — “generic” key（ポインタ以外のデータや汎用用途）

- これらの鍵は特権システムレジスタに格納され（EL1/EL2 等でのみアクセス可能）、ユーザモードからはアクセスできません。
- PAC は暗号的関数（ARM は QARMA を推奨）で計算され、以下を入力にします:
1. ポインタ値（正規化された部分）
2. **modifier**（スタックポインタ等のコンテキスト値）
3. 秘密鍵
4. 内部のチュークリジック
結果の PAC がポインタの上位ビットに入っている値と一致すれば認証は成功します。


#### Instruction Families

命名規則は: **PAC** / **AUT** / **XPAC**、その後にドメイン文字が続きます。
- `PACxx` 命令はポインタに署名して PAC を挿入します
- `AUTxx` 命令は認証して PAC を剥がします（検証 + 剥離）
- `XPACxx` 命令は検証せずに PAC を剥がします

Domains / suffixes:

| Mnemonic     | Meaning / Domain                      | Key / Domain     | Example Usage in Assembly |
|--------------|-----------------------------------------|--------------------|-----------------------------|
| **PACIA**    | Sign instruction pointer with APIAKey   | “I, A”             | `PACIA X0, X1` — sign pointer in X0 using APIAKey with modifier X1|
| **PACIB**    | Sign instruction pointer with APIBKey   | “I, B”             | `PACIB X2, X3`              |
| **PACDA**    | Sign data pointer with APDAKey           | “D, A”             | `PACDA X4, X5`              |
| **PACDB**    | Sign data pointer with APDBKey           | “D, B”             | `PACDB X6, X7`              |
| **PACG / PACGA** | Generic (non-pointer) signing with APGAKey | “G”         | `PACGA X8, X9, X10` (sign X9 with modifier X10 into X8) |
| **AUTIA**    | Authenticate APIA-signed instruction pointer & strip PAC | “I, A” | `AUTIA X0, X1` — check PAC on X0 using modifier X1, then strip |
| **AUTIB**    | Authenticate APIB domain                 | “I, B”             | `AUTIB X2, X3`               |
| **AUTDA**    | Authenticate APDA-signed data pointer    | “D, A”             | `AUTDA X4, X5`               |
| **AUTDB**    | Authenticate APDB-signed data pointer    | “D, B”             | `AUTDB X6, X7`               |
| **AUTGA**    | Authenticate generic / blob (APGA)        | “G”               | `AUTGA X8, X9, X10` (validate generic) |
| **XPACI**     | Strip PAC (instruction pointer, no validation) | “I”         | `XPACI X0` — remove PAC from X0 (instruction domain) |
| **XPACD**     | Strip PAC (data pointer, no validation)    | “D”             | `XPACD X4` — remove PAC from data pointer in X4 |


There are specialized / alias forms:

- `PACIASP` is shorthand for `PACIA X30, SP` (sign the link register using SP as modifier)
- `AUTIASP` is `AUTIA X30, SP` (authenticate link register with SP)
- Combined forms like `RETAA`, `RETAB` (authenticate-and-return) or `BLRAA` (authenticate & branch) exist in ARM extensions / compiler support.
- Also zero-modifier variants: `PACIZA` / `PACIZB` where the modifier is implicitly zero, etc.

#### Modifiers

modifier の主目的は PAC を特定のコンテキストに結びつけることで、同じアドレスが異なるコンテキストで再利用されるのを防ぐことです。ハッシュに salt を加えるようなものです。

したがって:
- **modifier** はコンテキスト値（別のレジスタ）で、PAC 計算に混ぜられます。典型的な選択肢: stack pointer (`SP`), frame pointer, オブジェクト ID など。
- SP を modifier に使うのは戻りアドレス署名で一般的です: PAC は特定のスタックフレームに結びつきます。異なるフレームで LR を再利用しようとすると modifier が変わるため PAC 検証は失敗します。
- 同じポインタ値でも異なる modifier で署名すると異なる PAC になります。
- modifier 自体は必ずしも秘密である必要はありませんが、理想的には攻撃者が制御できない値です。
- 意味のある modifier が存在しない箇所では、ゼロや暗黙の定数を使うバリアントがあります。

#### Apple / iOS / XNU Customizations & Observations

- Apple の PAC 実装は **per-boot diversifiers** を含み、ブートごとに鍵やチューンが変わりブート間での再利用を防ぎます。
- また **cross-domain mitigations** を含み、ユーザモードで署名された PAC がカーネルモードで簡単に再利用されないようにします。
- Apple Silicon（M1） のリバースで、**九種類の modifier タイプ** やキー制御用の Apple 固有のシステムレジスタがあることが示されました。
- Apple は多くのカーネルサブシステムで PAC を利用しています: 戻りアドレス署名、カーネルデータのポインタ整合性、署名されたスレッドコンテキスト等。
- Google Project Zero は、強力なメモリ読み書きプリミティブがある場合にカーネル PAC を偽造できる経路（A12 世代での例）を示しましたが、Apple は多くの経路を修正しました。
- Apple のシステムでは一部の鍵は **カーネル全体でグローバル** なものがあり、ユーザプロセスはプロセスごとの鍵ランダム性を得る場合があります。

#### PAC Bypasses

1. **Kernel-mode PAC: theoretical vs real bypasses**

-   カーネル PAC の鍵とロジックは厳格に管理されているため（特権レジスタ、diversifier、ドメイン分離）、任意の署名付きカーネルポインタを偽造するのは非常に困難です。
-   Azad の 2020 年の "iOS Kernel PAC, One Year Later" は、iOS 12–13 で署名 gadget の再利用や未保護の間接ブランチなどの部分的バイパスをいくつか報告しましたが、汎用的な完全バイパスは無かったとしています。 [bazad.github.io](https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf)
-   Apple の "Dark Magic" カスタマイズはさらに攻撃面を狭めています（ドメイン切替、per-key enabling bits）。 [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Apple silicon (M1/M2) での既知の **kernel PAC bypass CVE-2023-32424** が Zecao Cai らによって報告されています。 [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   しかしこれらのバイパスは多くの場合非常に特定の gadget や実装バグに依存しており、汎用的ではありません。

したがってカーネル PAC は **非常に強固** と見なされていますが、完全ではありません。

2. **User-mode / runtime PAC bypass techniques**

これらはより一般的で、PAC が動的リンクやランタイムフレームワークで部分的に適用されている不完全さを突きます。以下にクラス別と事例を示します。

2.1 **Shared Cache / A key issues**

-   **dyld shared cache** はシステムフレームワークとライブラリを大きなプリリンク済みバイナリとしてまとめたものです。広く共有されるため、shared cache 内の関数ポインタは既に署名されており、多くのプロセスで使われます。攻撃者はこれら既署名ポインタを "PAC oracles" として狙います。

-   いくつかのバイパス手法は shared cache 内にある A-key 署名済みポインタを抽出または再利用して gadget と組み合わせて PAC を迂回しようとします。

-   "No Clicks Required" の発表では、shared cache 上のオラクルを作って相対アドレスを推測し、署名済みポインタと組み合わせて PAC を回避する手法が説明されています。 [saelo.github.io](https://saelo.github.io/presentations/offensivecon_20_no_clicks.pdf)

-   また、ユーザ空間の共有ライブラリからの関数ポインタのインポートが PAC によって十分に保護されていないケースがあり、攻撃者が署名を変更せずに関数ポインタを入手できることが見つかっています。（Project Zero の報告） [bugs.chromium.org](https://bugs.chromium.org/p/project-zero/issues/detail?id=2044&utm_source=chatgpt.com)

2.2 **dlsym(3) / dynamic symbol resolution**

-   既知のバイパスの一つは `dlsym()` を呼び出して *既に署名された* 関数ポインタ（A-key で署名済み、diversifier がゼロ）を得ることです。`dlsym` が正当に署名されたポインタを返すため、それを使うことで PAC の偽造を回避できます。

-   Epsilon のブログは、`dlsym("someSym")` が署名済みポインタを返してそれを間接呼び出しに使えるという回避を詳述しています。 [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

-   Synacktiv の "iOS 18.4 --- dlsym considered harmful" は、iOS 18.4 の `dlsym` が不正に署名された（あるいは diversifier が壊れている）ポインタを返すバグを記述しており、意図しない PAC バイパスを可能にしていると報告しています。 [Synacktiv](https://www.synacktiv.com/en/publications/ios-184-dlsym-considered-harmful)

-   dyld の dlsym に関するロジックでは: `result->isCode` の場合、返されるポインタに対して `__builtin_ptrauth_sign_unauthenticated(..., key_asia, 0)` で署名している、つまりコンテキストとしてゼロを使っている、という実装が見られます。 [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

したがって、`dlsym` はユーザモード PAC バイパスで頻繁に利用されるベクターです。

2.3 **Other DYLD / runtime relocations**

-   DYLD ローダーと動的再配置ロジックは複雑で、再配置を行うため一時的にページを read/write にマップしてから再び read-only に戻すことがあります。攻撃者はこの一時的ウィンドウを悪用します。Synacktiv の発表は動的再配置を使ったタイミングベースの PAC バイパス ("Operation Triangulation") を説明しています。 [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   DYLD ページは現在 SPRR / VM_FLAGS_TPRO などで保護されていますが、以前のバージョンでは防御が弱いことがありました。 [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   WebKit のエクスプロイトチェーンでは、DYLD ローダーはしばしば PAC バイパスの標的になります。スライドでは多くの PAC バイパスが DYLD ローダー（再配置、interposer フック経由）を狙ったとしています。 [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

2.4 **NSPredicate / NSExpression / ObjC / SLOP**

-   ユーザランドのエクスプロイトチェーンでは、Objective-C ランタイムの `NSPredicate`、`NSExpression`、`NSInvocation` のようなメソッドが、コントロールフローを目立たず運ぶために利用されます。

-   PAC 導入以前の古い iOS では、**fake NSInvocation** オブジェクトを用いて任意の selector を制御メモリ上で呼び出すエクスプロイトがありました。PAC があるとこの手法には修正が必要になります。しかし SLOP (SeLector Oriented Programming) の技術は PAC 下でも拡張されて使われています。 [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   元の SLOP 技法は、偽の invocation を作って ObjC 呼び出しを連鎖させるものでした；バイパスは ISA や selector ポインタが必ずしも完全に PAC 保護されていない点を突きます。 [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   ポインタ認証が部分的にしか適用されていない環境では、メソッド/セレクタ/ターゲットポインタが常に PAC 保護されているわけではなく、そこにバイパスの余地があります。

#### Example Flow

<details>
<summary>Example Signing & Authenticating</summary>
```
; Example: function prologue / return address protection
my_func:
stp x29, x30, [sp, #-0x20]!        ; push frame pointer + LR
mov x29, sp
PACIASP                            ; sign LR (x30) using SP as modifier
; … body …
mov sp, x29
ldp x29, x30, [sp], #0x20         ; restore
AUTIASP                            ; authenticate & strip PAC
ret

; Example: indirect function pointer stored in a struct
; suppose X1 contains a function pointer
PACDA X1, X2     ; sign data pointer X1 with context X2
STR X1, [X0]      ; store signed pointer

; later retrieval:
LDR X1, [X0]
AUTDA X1, X2       ; authenticate & strip
BLR X1             ; branch to valid target

; Example: stripping for comparison (unsafe)
LDR X1, [X0]
XPACI X1           ; strip PAC (instruction domain)
CMP X1, #some_label_address
BEQ matched_label
```
</details>

<details>
<summary>例</summary>
バッファオーバーフローがスタック上のリターンアドレスを上書きする。攻撃者はターゲットの gadget アドレスを書き込むが、正しい PAC を計算できない。関数が戻ると、CPU の `AUTIA` 命令は PAC の不一致によりフォルトを起こすため、チェインは失敗する。
Project Zero による A12 (iPhone XS) の解析は、Apple の PAC がどのように使われているか、そして攻撃者が memory read/write primitive を持っている場合に PAC を偽造する方法を示した。
</details>


### 9. **Branch Target Identification (BTI)**
**Introduced with ARMv8.5 (later hardware)**
BTI は間接分岐ターゲットをチェックするハードウェア機能で、`blr` や間接的な call/jump を実行する際、ターゲットは **BTI landing pad**（`BTI j` または `BTI c`）で始まる必要がある。landing pad のない gadget アドレスに飛ぼうとすると例外が発生する。

LLVM の実装は BTI 命令の三つのバリアントと、それらがどの分岐タイプに対応するかを示している。

| BTI Variant | What it permits (which branch types) | Typical placement / use case |
|-------------|----------------------------------------|-------------------------------|
| **BTI C** | Targets of *call*-style indirect branches (e.g. `BLR`, or `BR` using X16/X17) | 間接的に呼ばれる可能性のある関数のエントリに置かれる |
| **BTI J** | Targets of *jump*-style branches (e.g. `BR` used for tail calls) | jump table や tail-call で到達可能なブロックの先頭に置かれる |
| **BTI JC** | Acts as both C and J | call と jump の両方からターゲットにできる |

- branch target enforcement でコンパイルされたコードでは、コンパイラは各有効な間接分岐ターゲット（関数の先頭やジャンプで到達可能なブロック）に BTI 命令（C, J, または JC）を挿入し、間接分岐がそれらの場所へしか成功しないようにする。
- **Direct branches / calls**（固定アドレスの `B`, `BL` 等）は BTI による制約を受けない。前提としてコードページは信頼されており攻撃者がそれを変更できない（よって direct branch は安全）と見なされている。
- また、**RET / return** 命令は一般的に BTI の制約を受けない。リターンアドレスは PAC や return signing といった仕組みで保護されているためである。

#### Mechanism and enforcement

- CPU が「guarded / BTI-enabled」とマークされたページ内で **間接分岐（BLR / BR）** をデコードする際、ターゲットアドレスの最初の命令が有効な BTI（許可された C, J, または JC）であるかをチェックする。そうでない場合は **Branch Target Exception** が発生する。
- BTI 命令のエンコーディングは、以前の ARM バージョンで NOPs に予約されていたオペコードを再利用するよう設計されている。したがって BTI 対応のバイナリは、BTI 非対応ハードウェア上ではこれらの命令が NOP として動作し、後方互換性を保つ。
- BTI を追加するコンパイラパスは必要な箇所にのみ挿入する：間接的に呼ばれる可能性のある関数や、ジャンプで到達可能な基本ブロックなど。
- いくつかのパッチや LLVM のコードは、BTI が全ての基本ブロックに挿入されるわけではなく、潜在的な分岐ターゲット（例えば switch / jump tables からのターゲット）のみが対象であることを示している。

#### BTI + PAC synergy

PAC はポインタ値（ソース）を保護し、間接呼び出しやリターンのチェインが改竄されていないことを保証する。

BTI は有効なポインタであっても、そのポインタが適切にマークされたエントリポイントのみを指すべきことを強制する。

これらを組み合わせると、攻撃者は正しい PAC を持つ有効なポインタと、かつターゲットに BTI が置かれていることの両方を満たす必要があり、exploit gadget の構築がさらに難しくなる。

#### Example


<details>
<summary>例</summary>
あるエクスプロイトが `0xABCDEF` の gadget にピボットしようとするが、そのアドレスは `BTI c` で始まっていない。CPU は `blr x0` を実行した際にターゲットをチェックし、有効な landing pad がないためフォルトする。このため多くの gadget は BTI プレフィックスがない限り使用不能になる。
</details>


### 10. **Privileged Access Never (PAN) & Privileged Execute Never (PXN)**
**Introduced in more recent ARMv8 extensions / iOS support (for hardened kernel)**

#### PAN (Privileged Access Never)

- **PAN** は **ARMv8.1-A** で導入された機能で、**privileged code**（EL1 や EL2）が **user-accessible (EL0)** とマークされたメモリを **読み書きできない** ようにする（PAN を明示的に無効にしない限り）。
- 目的は：カーネルがトリックされたり侵害された場合でも、カーネルがユーザ空間ポインタを恣意的にデリファレンスできないようにし、`ret2usr` スタイルのエクスプロイトやユーザ制御バッファの悪用のリスクを減らすこと。
- PAN が有効なとき（PSTATE.PAN = 1）、EL0 でアクセス可能とマークされた仮想アドレスに対して特権レベルの load/store を行うと **permission fault** が発生する。
- カーネルが正当にユーザ空間メモリにアクセスする必要がある場合（例：ユーザバッファへのデータコピーなど）、カーネルは一時的に PAN を無効にする（または「非特権の load/store」命令を使う）必要がある。
- Linux on ARM64 では、PAN サポートは 2015 年頃に導入された：カーネルのパッチは機能検出を追加し、`get_user` / `put_user` 等を PAN をクリアするバリアントに置き換えた。

**重要なニュアンス / 制限 / バグ**
- Siguza 等が指摘したように、ARM の設計における仕様上のバグ（または曖昧な挙動）により、**execute-only user mappings**（`--x`）は PAN をトリガしない場合がある。つまり、ユーザページが実行可能だが読み取り権限を持たない場合、カーネルの読み取り試行が PAN を迂回する可能性がある。アーキテクチャは「accessible at EL0」を読み取り可能な権限を要求するものと解釈しており、単に実行可能であるだけでは該当しないことがある。これは特定の構成で PAN のバイパスにつながる。
- そのため、もし iOS / XNU が execute-only user pages を許可している（JIT や code-cache のような設定で見られる）場合、カーネルが PAN 有効時でも誤ってそれらから読み出せてしまう可能性がある。これは一部の ARMv8+ システムで知られた微妙な脆弱ポイントである。

#### PXN (Privileged eXecute Never)

- **PXN** はページテーブルフラグ（ページテーブルエントリ、leaf または block エントリ）で、当該ページが **privileged mode（EL1 など）で実行不可** であることを示す。
- PXN は、カーネル（あるいは他の特権コード）がユーザ空間ページからジャンプして命令を実行することを防ぐ。実質的に、特権レベルでのコントロールフローのリダイレクトによるユーザメモリ実行を阻止する。
- PAN と組み合わせると以下が成り立つ：
1. カーネルはデフォルトでユーザデータを読み書きできない（PAN）
2. カーネルはユーザ空間コードを実行できない（PXN）
- ARMv8 のページテーブルフォーマットでは、leaf エントリに `PXN` ビット（および unprivileged 用の `UXN`）が属性ビットとして存在する。

したがって、カーネルの関数ポインタがユーザメモリを指すように破壊され、そこへ分岐しようとしても、PXN ビットによりフォルトが発生する。

#### Memory-permission model & how PAN and PXN map to page table bits

PAN / PXN の動作を理解するには、ARM の翻訳とパーミッションモデル（簡略化）を押さえておく必要がある：

- 各ページやブロックエントリには、アクセス権を示す **AP[2:1]**（読み書き、特権対非特権）や実行不可制限を示す **UXN / PXN** ビットといった属性フィールドがある。
- PSTATE.PAN が 1（有効）のとき、ハードウェアは修正された意味論を強制する：EL0 がアクセス可能とマークされたページへの特権アクセスは拒否され（フォルトになる）。
- 先に述べたバグのため、読み取り権限を持たない「実行のみ」のページは、ある実装では「accessible by EL0」とみなされず、PAN をバイパスする可能性がある。
- ページに PXN ビットがセットされている場合、たとえ高い特権レベルからの命令フェッチであっても実行は禁止される。

#### Kernel usage of PAN / PXN in a hardened OS (e.g. iOS / XNU)

ハード化されたカーネル設計（例: Apple が採るような設計）では：

- カーネルはデフォルトで PAN を有効にする（よって特権コードは制約を受ける）。
- ユーザバッファを正当に読み書きする必要がある経路（syscall のデータコピー、I/O、ユーザポインタの read/write 等）では、カーネルは一時的に **PAN を無効化** するか、ユーザメモリアクセスを許す特別な命令を使う。
- ユーザデータアクセスが終わったら、カーネルは PAN を再度有効にしなければならない。
- PXN はページテーブルを通じて強制される：ユーザページには PXN = 1 が設定され（カーネルがそれらを実行できないように）、カーネルページには PXN が設定されない（カーネルコードは実行可能）。
- カーネルは、実行フローがユーザメモリ領域に流れるようなコードパスを生じさせないように確認する必要がある（そうでなければ PXN を迂回される）。これにより「ユーザ制御のシェルコードへジャンプして実行する」系のエクスプロイトチェインは阻止される。

先述の execute-only ページによる PAN バイパスのため、実システムでは Apple は execute-only user pages を無効にするか、仕様の弱点を回避するためのパッチを当てている可能性がある。

#### Attack surfaces, bypasses, and mitigations

- **PAN bypass via execute-only pages**: 前述のとおり仕様のギャップにより、読み取り権限を持たない実行専用のユーザページは PAN をトリガしないことがあり、これにより攻撃者は「execute-only」セクションを通じてデータを供給する異常な経路を得られる可能性がある。
- **Temporal window exploit**: カーネルが必要以上に長い間 PAN を無効にすると、その時間窓を利用してレースや悪意ある経路が意図しないユーザメモリアクセスを行う可能性がある。
- **Forgotten re-enable**: PAN の再有効化を忘れるコード経路があると、その後のカーネル操作が誤ってユーザメモリにアクセスしてしまう。
- **Misconfiguration of PXN**: ユーザページに PXN が設定されていない、あるいはユーザコードページが誤ってマップされていると、カーネルがユーザ空間コードを実行してしまう恐れがある。
- **Speculation / side-channels**: 推測実行に伴うバイパスに類似して、PAN / PXN チェックの一時的な違反を引き起こすマイクロアーキテクチャ的な副作用が存在する可能性がある（ただしそのような攻撃は CPU 設計に強く依存する）。
- **Complex interactions**: JIT、共有メモリ、just-in-time code regions のような高度な機能では、カーネルが特定のユーザマップ領域でのアクセスや実行を細かく許可する必要があり、PAN/PXN の制約下でそれを安全に設計するのは容易ではない。

#### Example

<details>
<summary>コード例</summary>
ここでは、ユーザメモリアクセスの前後で PAN を有効／無効化する擬似アセンブリのシーケンスと、どのようにフォルトが発生しうるかを示す説明的な例を示す。
</details>
```  
// Suppose kernel entry point, PAN is enabled (privileged code cannot access user memory by default)

; Kernel receives a syscall with user pointer in X0
; wants to read an integer from user space
mov   X1, X0        ; X1 = user pointer

; disable PAN to allow privileged access to user memory
MSR   PSTATE.PAN, #0   ; clear PAN bit, disabling the restriction

ldr   W2, [X1]       ; now allowed load from user address

; re-enable PAN before doing other kernel logic
MSR   PSTATE.PAN, #1   ; set PAN

; ... further kernel work ...

; Later, suppose an exploit corrupts a pointer to a user-space code page and jumps there
BR    X3             ; branch to X3 (which points into user memory)

; Because the target page is marked PXN = 1 for privileged execution,
; the CPU throws an exception (fault) and rejects execution
```
If the kernel had **not** set PXN on that user page, then the branch might succeed — which would be insecure.

If the kernel forgets to re-enable PAN after user memory access, it opens a window where further kernel logic might accidentally read/write arbitrary user memory.

If the user pointer is into an execute-only page (user page with only execute permission, no read/write), under the PAN spec bug, `ldr W2, [X1]` might **not** fault even with PAN enabled, enabling a bypass exploit, depending on implementation.

</details>

<details>
<summary>Example</summary>
カーネルの脆弱性がユーザー提供の関数ポインタを取り、それをカーネルコンテキストで呼び出そうとする（つまり `call user_buffer`）。PAN/PXN の下では、その操作は許可されないか、フォルトする。
</details>

---

### 11. **Top Byte Ignore (TBI) / Pointer Tagging**
**Introduced in ARMv8.5 / newer (or optional extension)**
TBI means the top byte (most-significant byte) of a 64-bit pointer is ignored by address translation. This lets OS or hardware embed **tag bits** in the pointer’s top byte without affecting the actual address.

- TBI stands for **Top Byte Ignore** (sometimes called *Address Tagging*). It is a hardware feature (available in many ARMv8+ implementations) that **ignores the top 8 bits** (bits 63:56) of a 64-bit pointer when performing **address translation / load/store / instruction fetch**.
- In effect, the CPU treats a pointer `0xTTxxxx_xxxx_xxxx` (where `TT` = top byte) as `0x00xxxx_xxxx_xxxx` for the purposes of address translation, ignoring (masking off) the top byte. The top byte can be used by software to store **metadata / tag bits**.
- This gives software “free” in-band space to embed a byte of tag in each pointer without altering which memory location it refers to.
- The architecture ensures that loads, stores, and instruction fetch treat the pointer with its top byte masked (i.e. tag stripped off) before performing the actual memory access.

Thus TBI decouples the **logical pointer** (pointer + tag) from the **physical address** used for memory operations.

#### Why TBI: Use cases and motivation

- **Pointer tagging / metadata**: ポインタの上位バイトに追加のメタデータ（例：オブジェクトの種類、バージョン、境界、整合性タグなど）を格納できる。後でポインタを使うとき、タグはハードウェアレベルで無視されるため、メモリアクセスのために手動で剥がす必要がない。
- **Memory tagging / MTE (Memory Tagging Extension)**: TBI は MTE が基盤とするハードウェア機構である。ARMv8.5 では、Memory Tagging Extension がポインタのビット 59:56 を論理タグとして使用し、それをメモリに格納された allocation tag と照合する。
- **Enhanced security & integrity**: TBI を pointer authentication (PAC) やランタイムチェックと組み合わせることで、ポインタ値だけでなくタグも正しいことを要求できる。攻撃者がタグを伴わずにポインタを書き換えると、タグ不一致が生じる。
- **Compatibility**: TBI はオプションであり、タグビットはハードウェアにより無視されるため、既存の非タグ付きコードは通常通り動作する。タグビットはレガシーコードにとって「気にしなくて良い」ビットになる。

#### Example
<details>
<summary>Example</summary>
関数ポインタの上位バイトにタグ（例えば `0xAA`）が含まれていた。Exploit がポインタの下位ビットを上書きしたがタグを無視したため、カーネルが検証やサニタイズを行うとポインタが失敗または拒否される。
</details>

---

### 12. **Page Protection Layer (PPL)**
**Introduced in late iOS / modern hardware (iOS ~17 / Apple silicon / high-end models)** (some reports show PPL circa macOS / Apple silicon, but Apple is bringing analogous protections to iOS)

- PPL は **カーネル内部の保護境界**として設計されている：たとえカーネル（EL1）が侵害され読み書き権限を持っていても、特定の **機密ページ**（特にページテーブル、コード署名メタデータ、カーネルコードページ、entitlements、trust caches など）を自由に改変できてはいけない。
- 実質的に「カーネルの中の小さな信頼領域」を作り、PPL は **昇格した特権**を持つ小さなコンポーネントとして、保護されたページの変更を行えるのは PPL のみとする。他のカーネルコードは変更を行うために PPL ルーチンを呼び出す必要がある。
- これによりカーネル exploit の攻撃面が縮小される：カーネルモードで任意の R/W/execute を得たとしても、攻撃コードは PPL ドメインに入り込むか PPL をバイパスしない限り重要構造を書き換えられない。
- 新しい Apple silicon（A15+ / M2+）では、Apple はページテーブル保護のために多くの場合 PPL の代わりに **SPTM (Secure Page Table Monitor)** に移行している。

以下は公開解析に基づく PPL の動作推定である：

#### Use of APRR / permission routing (APRR = Access Permission ReRouting)

- Apple ハードウェアは **APRR (Access Permission ReRouting)** という機構を使用し、これによりページテーブルエントリ（PTE）が完全な権限ビットの代わりに小さなインデックスを含めることができる。これらのインデックスは APRR レジスタを介して実際の権限にマッピングされる。これによりドメインごとに権限を動的に再マッピングできる。
- PPL はカーネルコンテキスト内で特権を隔離するために APRR を活用する：PPL ドメインだけがインデックスと実際の権限とのマッピングを更新できる。つまり、非 PPL のカーネルコードが PTE を書き換えたり権限ビットを切り替えようとすると、APRR ロジックがそれを拒否（あるいは読み取り専用マッピングを強制）する。
- PPL コード自体は制限された領域（例：`__PPLTEXT`）で実行され、通常は入力ゲートが一時的に許可するまで実行不可または書き込み不可になっている。カーネルは保護操作を行うために PPL エントリポイント（「PPL ルーチン」）を呼び出す。

#### Gate / Entry & Exit

- カーネルが保護ページ（例：カーネルコードページの権限変更やページテーブルの変更）を変更する必要がある場合、検証を行い PPL ドメインへ遷移する **PPL ラッパー** ルーチンを呼び出す。PPL の外側では、保護ページは実質的に読み取り専用または変更不可になっている。
- PPL へのエントリ時に、APRR マッピングが調整され PPL 領域内のメモリページが PPL 内で **実行 & 書き込み可能** に設定される。退出時にはそれらは読み取り専用 / 非書き込み可能に戻される。これにより、監査済みの PPL ルーチンのみが保護ページを書き換えられるようになる。
- PPL の外側でカーネルコードがこれら保護ページを書き込もうとすると、APRR マッピングがそのコードドメインに対して書き込みを許可しないためフォルト（permission denied）する。

#### Protected page categories

PPL が通常保護するページには次が含まれる：

- ページテーブル構造（翻訳テーブルエントリ、マッピングメタデータ）
- カーネルコードページ、特に重要ロジックを含むページ
- コード署名メタデータ（trust caches、署名ブロブ）
- entitlements テーブル、署名強制テーブル
- 署名チェックや資格情報の回避を可能にするようなパッチを許す高価値カーネル構造

考え方は、たとえカーネルメモリが完全に制御されても、攻撃者は PPL ルーチンを侵害するか PPL をバイパスしない限りこれらページを単純にパッチ/上書きできないということ。

#### Known Bypasses & Vulnerabilities

1. **Project Zero’s PPL bypass (stale TLB trick)**

- Project Zero の公開レポートは、**stale TLB entries** を利用したバイパスを説明している。
- アイデアは次のとおり：

1. 物理ページ A と B を 2 つ割り当て、それらを PPL ページとしてマークする。
2. 2 つの仮想アドレス P と Q をマップし、その L3 翻訳テーブルページが A と B から来るようにする。
3. 別スレッドを回して Q に継続的にアクセスさせ、その TLB エントリを生かし続ける。
4. `pmap_remove_options()` を呼んで P から始まるマッピングを削除する；バグによりコードは P と Q 両方の TTE を誤って削除するが、TLB の無効化は P のみ行われ、Q の stale エントリが残る。
5. B（Q のテーブル）を再利用して任意のメモリ（例：PPL 保護ページ）をマップする。stale TLB エントリが依然として Q の古いマッピングをそのコンテキストで有効にしているため、そのマッピングは有効のままになる。
6. これにより、攻撃者は PPL インターフェースを通さずに PPL 保護ページの書き込み可能マッピングを置くことができる。

- このエクスプロイトは物理マップと TLB 挙動を細かく制御することを必要とした。これは TLB / マッピングの一貫性と無効化が正しくないとセキュリティ境界が破られることを示している。
- Project Zero は、この種のバイパスは微妙で稀だが複雑なシステムでは可能であるとコメントしている。とはいえ、彼らは PPL を有効な緩和策と見なしている。

2. **Other potential hazards & constraints**

- カーネルエクスプロイトが直接 PPL ルーチンに入れる場合（PPL ラッパーを呼べる場合）、制限を回避する可能性がある。したがって引数の検証が重要である。
- PPL コード自体のバグ（例：算術オーバーフロー、境界チェックの不備）は PPL 内での範囲外書き換えを許す可能性がある。Project Zero は `pmap_remove_options_internal()` のような関数内のバグが彼らのバイパスで利用されたと観察している。
- PPL 境界はハードウェアの実装（APRR、メモリコントローラ）に密接に結び付いているため、その強度はハードウェア実装の堅牢性に依存する。

#### Example
<details>
<summary>Code Example</summary>
Here’s a simplified pseudocode / logic showing how a kernel might call into PPL to modify protected pages:
```c
// In kernel (outside PPL domain)
function kernel_modify_pptable(pt_addr, new_entry) {
// validate arguments, etc.
return ppl_call_modify(pt_addr, new_entry)  // call PPL wrapper
}

// In PPL (trusted domain)
function ppl_call_modify(pt_addr, new_entry) {
// temporarily enable write access to protected pages (via APRR adjustments)
aprr_set_index_for_write(PPL_INDEX)
// perform the modification
*pt_addr = new_entry
// restore permissions (make pages read-only again)
aprr_restore_default()
return success
}

// If kernel code outside PPL does:
*pt_addr = new_entry  // a direct write
// It will fault because APRR mapping for non-PPL domain disallows write to that page
```
<details>
<summary>Example</summary>
kernel は多くの通常の操作を行えますが、保護されたマッピングを変更したりコードをパッチしたりできるのは `ppl_call_*` ルーチン経由だけです。
</details>

<details>
<summary>Example</summary>
A kernel exploit は entitlement table を上書きしようとしたり、kernel signature blob を改変して code-sign enforcement を無効化しようとします。 そのページは PPL-protected であるため、PPL インターフェース経由でない限り書き込みはブロックされます。 したがって、kernel code execution を得ても、code-sign 制約をバイパスしたり credential data を恣意的に変更することはできません。iOS 17+ では、特定のデバイスが SPTM を用いて PPL-managed ページをさらに分離します。
</details>

#### PPL → SPTM / Replacements / Future

- On Apple’s modern SoCs (A15 or later, M2 or later), Apple supports **SPTM** (Secure Page Table Monitor), which **replaces PPL** for page table protections.
- Apple calls out in documentation: “Page Protection Layer (PPL) and Secure Page Table Monitor (SPTM) enforce execution of signed and trusted code … PPL manages the page table permission overrides … Secure Page Table Monitor replaces PPL on supported platforms.”
- The SPTM architecture likely shifts more policy enforcement into a higher-privileged monitor outside kernel control, further reducing the trust boundary.

### MTE | EMTE | MIE

以下は、Apple の MIE 設定下で EMTE がどのように動作するかの高レベルな説明です:

1. **Tag assignment**
- メモリが割り当てられるとき（例: kernel や user space で secure allocators を介して）、そのブロックに **secret tag** が割り当てられます。
- ユーザまたは kernel に返されるポインタは、高位ビットにそのタグを含みます（TBI / top byte ignore mechanisms を使用）。

2. **Tag checking on access**
- ポインタを使って load や store が実行されるたびに、ハードウェアはポインタのタグがそのメモリブロックのタグ（allocation tag）と一致するかをチェックします。不一致なら即座に fault します（同期的であるため）。
- 同期的であるため、「検出の遅延」ウインドウは存在しません。

3. **Retagging on free / reuse**
- メモリが free されると、allocator はそのブロックのタグを変更します（古いタグを持つ以前のポインタはもう一致しません）。
- したがって、use-after-free ポインタは古いタグを持っており、アクセス時に不一致になります。

4. **Neighbor-tag differentiation to catch overflows**
- Adjacent allocations are given distinct tags. If a buffer overflow spills into neighbor’s memory, tag mismatch causes a fault.
- This is especially powerful in catching small overflows that cross boundary.

5. **Tag confidentiality enforcement**
- Apple はタグ値が leaked するのを防がなければなりません（攻撃者がタグを知ると、正しいタグを持つポインタを作成できるため）。
- 彼らはタグビットのサイドチャネル漏洩を避けるために、microarchitectural / speculative controls といった保護を組み込みます。

6. **Kernel and user-space integration**
- Apple は EMTE を user-space だけでなく kernel / OS-critical コンポーネントにも使用しており（kernel をメモリ破損から守るため）、
- ハードウェア/OS は、kernel が user space を代理して実行している場合でもタグルールが適用されることを保証します。

<details>
<summary>Example</summary>
```
Allocate A = 0x1000, assign tag T1
Allocate B = 0x2000, assign tag T2

// pointer P points into A with tag T1
P = (T1 << 56) | 0x1000

// Valid store
*(P + offset) = value // tag T1 matches allocation → allowed

// Overflow attempt: P’ = P + size_of_A (into B region)
*(P' + delta) = value
→ pointer includes tag T1 but memory block has tag T2 → mismatch → fault

// Free A, allocator retags it to T3
free(A)

// Use-after-free:
*(P) = value
→ pointer still has old tag T1, memory region is now T3 → mismatch → fault
```
</details>

#### 制限 & 課題

- **Intrablock overflows**: オーバーフローが同じ割り当て内に留まり（境界を越えない）、タグが同一のままなら、tag mismatch は検出されないことがある。
- **Tag width limitation**: タグに利用できるビット数は限られる（例：4ビットや小さなドメイン）ため、名前空間が制限される。
- **Side-channel leaks**: タグビットが（cache / speculative execution 経由で）leaked され得る場合、攻撃者は有効なタグを知り回避できる。Apple の Tag Confidentiality Enforcement はこれを緩和することを目的としている。
- **Performance overhead**: 各ロード/ストアでのタグチェックはコストを追加するため、Apple はハードウェア最適化でオーバーヘッドを低く抑える必要がある。
- **Compatibility & fallback**: 古いハードウェアや EMTE をサポートしない部分ではフォールバックが必要になる。Apple は MIE がサポートされたデバイスでのみ有効にすると主張している。
- **Complex allocator logic**: アロケータはタグ管理、retagging、境界のアライン、誤タグ衝突回避を扱う必要がある。アロケータロジックのバグは新たな脆弱性を生む可能性がある。
- **Mixed memory / hybrid areas**: 一部のメモリは未タグ化（レガシー）のまま残ることがあり、相互運用性が複雑になる。
- **Speculative / transient attacks**: 多くのマイクロアーキテクチャ保護と同様に、speculative execution や micro-op fusion により一時的にチェックを回避したりタグビットを漏らしたりする可能性がある。
- **Limited to supported regions**: Apple は EMTE をカーネルやセキュリティクリティカルなサブシステムなど、選択的な高リスク領域でのみ強制する可能性がある（全域適用ではない）。



---

## 標準 MTE と比べた主な強化点 / 相違点

| 機能 | Original MTE | EMTE (Apple’s enhanced) / MIE |
|---|---|---|
| **Check mode** | 同期モードと非同期モードをサポート。非同期ではタグ不一致が後で報告される（遅延） | Apple はデフォルトで**同期モード**を主張 — タグ不一致は即時に検出され、遅延／レースウィンドウを許さない。|
| **Coverage of non-tagged memory** | 非タグ化メモリ（例：globals）へのアクセスは一部実装でチェックを回避することがある | EMTE は、タグ付領域から非タグ化メモリへのアクセスでもタグ情報の妥当性を検証することを要求し、割り当てを混在させて回避することを難しくする。|
| **Tag confidentiality / secrecy** | タグは観測可能だったり side-channel 経由で leak され得る | Apple は **Tag Confidentiality Enforcement** を追加し、タグ値の漏洩（speculative side-channels など）を防ごうとする。|
| **Allocator integration & retagging** | MTE は多くのアロケータロジックをソフトウェア側に委ねる | Apple の secure typed allocators（kalloc_type、xzone malloc など）は EMTE と統合されている：メモリの割当て/解放時にタグが細粒度で管理される。|
| **Always-on by default** | 多くのプラットフォームでは MTE はオプション、またはデフォルトで無効 | Apple はサポートされたハードウェア（例：iPhone 17 / A19）上で、カーネルおよび多くのユーザープロセスに対して EMTE / MIE をデフォルトで有効にする。|

Apple はハードウェアとソフトウェアスタックの両方を制御できるため、EMTE を厳密に適用し、性能上の問題を回避し、サイドチャネルの穴を閉じられる利点がある。

---

## How EMTE works in practice (Apple / MIE)

以下は Apple の MIE 構成下で EMTE がどのように動作するかの高レベルな説明です：

1. **Tag assignment**
- メモリが割り当てられるとき（カーネルや secure allocators 経由でのユーザ/カーネル空間）、そのブロックに**秘密タグ**が割り当てられる。
- 返されるポインタはそのタグを高位ビットに含む（TBI / top byte ignore 機構を使用）。

2. **Tag checking on access**
- ポインタを使ってロード/ストアが実行されるとき、ハードウェアはポインタのタグがメモリブロックのタグ（割当タグ）と一致するかを検査する。一致しなければ即座にフォルトする（同期モードのため）。
- 同期であるため、「遅延検出」のウィンドウは存在しない。

3. **Retagging on free / reuse**
- メモリが解放されると、アロケータはそのブロックのタグを変更する（古いタグを持つポインタはもはや一致しない）。
- したがって use-after-free ポインタは古いタグを持ち、アクセス時に不一致となる。

4. **Neighbor-tag differentiation to catch overflows**
- 隣接する割り当てには異なるタグが与えられる。もしバッファオーバーフローが隣接領域に溢れれば、タグ不一致でフォルトが発生する。
- これは境界を跨ぐ小さなオーバーフローを検出する上で非常に有効である。

5. **Tag confidentiality enforcement**
- 攻撃者がタグ値を学べば正しいタグを持つポインタを作成できるため、Apple はタグ値の漏洩を防ぐ必要がある。
- そのため、タグビットのサイドチャネル的な漏洩を避けるための保護（マイクロアーキテクチャ／speculative 制御など）を導入している。

6. **Kernel and user-space integration**
- Apple は EMTE をユーザー空間だけでなくカーネル／OS クリティカルなコンポーネントにも適用している（カーネルのメモリ破壊を防ぐため）。
- ハードウェア／OS はタグ規則がユーザ処理の代理で実行されるときでも適用されるよう保証する。

EMTE は MIE に組み込まれているため、Apple は主要な攻撃面に対して同期モードで EMTE を適用し、オプトインやデバッグモードとしてではなく常時有効にしている。

---

## Exception handling in XNU

例外（例えば `EXC_BAD_ACCESS`, `EXC_BAD_INSTRUCTION`, `EXC_CRASH`, `EXC_ARM_PAC` など）が発生すると、XNU カーネルの **Mach layer** がそれを UNIX スタイルの **signal**（`SIGSEGV`, `SIGBUS`, `SIGILL`, ... のような）に変換する前にインターセプトする責任を負う。

このプロセスはユーザー空間に到達するか BSD シグナルに変換されるまでに、複数の例外伝播と処理のレイヤーを含む。


### 例外フロー（高レベル）

1.  CPU が同期例外を引き起こす（例：無効なポインタ参照、PAC 失敗、不正命令など）。

2.  低レベルの trap ハンドラが実行される（`trap.c`, `exception.c` in XNU source）。

3.  トラップハンドラは **`exception_triage()`** を呼び出す — Mach 例外処理の中核。

4.  `exception_triage()` は例外をルーティングする方法を決定する：

-   まず **thread の exception port** へ送る。

-   次に **task の exception port** へ送る。

-   それでも処理されなければ **host の exception port**（多くの場合 `launchd` や `ReportCrash`）へ送る。

これらのポートのどれも例外を処理しない場合、カーネルは：

-   **ユーザープロセスに対して BSD シグナルへ変換** するか、

-   **panic** する（カーネル空間の例外の場合）。


### Core Function: `exception_triage()`

関数 `exception_triage()` は Mach 例外を可能なハンドラのチェーンに沿ってルーティングし、どれかが処理するか最終的に致命的になるまで進める。これは `osfmk/kern/exception.c` に定義されている。
```c
void exception_triage(exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt);
```
**典型的なコールフロー:**

`exception_triage()
└── exception_deliver()
├── exception_deliver_thread()
├── exception_deliver_task()
└── exception_deliver_host()`

もしすべて失敗すると → `bsd_exception()` によって処理され → `SIGSEGV` のようなシグナルに変換されます。


### Exception Ports

Each Mach object (thread, task, host) can register **exception ports**, where exception messages are sent.

They are defined by the API:
```
task_set_exception_ports()
thread_set_exception_ports()
host_set_exception_ports()
```
Each exception port has:

-   A **mask** (受け取りたい例外の種類)
-   A **port name** (メッセージを受け取る Mach ポート)
-   A **behavior** (カーネルがメッセージを送る方法)
-   A **flavor** (含めるスレッド状態の種類)


### Debuggers and Exception Handling

A **debugger** (例: LLDB) はターゲットの task または thread 上に **exception port** を設定し、通常 `task_set_exception_ports()` を使います。

**例外が発生したとき:**

-   Mach message が debugger プロセスに送られる。
-   デバッガは例外を **handle**（再開、レジスタ修正、命令スキップ）するか **しない** かを決められる。
-   デバッガが処理しなければ、例外は次のレベルに伝播する（task → host）。


### Flow of `EXC_BAD_ACCESS`

1.  スレッドが無効なポインタをデリファレンス → CPU が Data Abort を発生させる。

2.  カーネルトラップハンドラが `exception_triage(EXC_BAD_ACCESS, ...)` を呼ぶ。

3.  メッセージは以下に送られる:

-   Thread port →（デバッガがブレークポイントを傍受できる）

-   デバッガが無視 → Task port →（プロセスレベルのハンドラ）

-   無視されると → Host port（通常 ReportCrash）

4.  誰も処理しなければ → `bsd_exception()` が `SIGSEGV` に変換する。


### PAC Exceptions

When **Pointer Authentication (PAC)** fails（署名不一致）すると、特別な Mach 例外が上がる:

-   **`EXC_ARM_PAC`**（タイプ）
-   コードには詳細が含まれる場合がある（例: key type, pointer type）。

バイナリにフラグ **`TFRO_PAC_EXC_FATAL`** があると、カーネルは PAC 失敗を致命的として扱い、デバッガの傍受をバイパスする。これは攻撃者がデバッガを使って PAC チェックを回避するのを防ぐためで、**platform binaries** に対して有効になる。


### Software Breakpoints

A software breakpoint（x86 の `int3`、ARM64 の `brk`）は、意図的にフォルトを発生させることで実装される。\
デバッガは exception port を通じてこれをキャッチする:

-   命令ポインタやメモリを修正する。
-   元の命令を復元する。
-   実行を再開する。

同じ仕組みで PAC 例外を「キャッチ」できるが、**`TFRO_PAC_EXC_FATAL`** が設定されている場合はデバッガに到達しない。


### Conversion to BSD Signals

ハンドラが例外を受け入れない場合:

-   カーネルは `task_exception_notify()` → `bsd_exception()` を呼ぶ。

-   これが Mach 例外をシグナルにマップする:

| Mach 例外 | シグナル |
| --- | --- |
| EXC_BAD_ACCESS | SIGSEGV or SIGBUS |
| EXC_BAD_INSTRUCTION | SIGILL |
| EXC_ARITHMETIC | SIGFPE |
| EXC_SOFTWARE | SIGTRAP |
| EXC_BREAKPOINT | SIGTRAP |
| EXC_CRASH | SIGKILL |
| EXC_ARM_PAC | SIGILL（非致命時） |


### Key Files in XNU Source

-   `osfmk/kern/exception.c` → `exception_triage()`、`exception_deliver_*()` のコア。
-   `bsd/kern/kern_sig.c` → シグナル配信ロジック。
-   `osfmk/arm64/trap.c` → 低レベルのトラップハンドラ。
-   `osfmk/mach/exc.h` → 例外コードと構造体。
-   `osfmk/kern/task.c` → Task の exception port 設定。

---

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

カーネルは固定サイズの「ゾーン」に分かれた zone allocator（`kalloc`）を使っていた。各ゾーンは単一のサイズクラスの割当のみを保持する。

From the screenshot:

| ゾーン名 | 要素サイズ | 使用例 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | 非常に小さなカーネル構造体、ポインタ。                                        |
| `default.kalloc.32`  | 32 bytes     | 小さな構造体、オブジェクトヘッダ。                                              |
| `default.kalloc.64`  | 64 bytes     | IPC messages、小さなカーネルバッファ。                                          |
| `default.kalloc.128` | 128 bytes    | `OSObject` の一部など中くらいのオブジェクト。                                    |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | 大きな構造体、IOSurface/graphics metadata。                              |

**動作原理:**
- 各割当要求は最も近いゾーンサイズに **切り上げ** られる。
（例: 50 バイトの要求は `kalloc.64` ゾーンに入る）。
- 各ゾーンのメモリは **フリーリスト** に保持され、カーネルが解放したチャンクはそのゾーンに戻る。
- 64 バイトバッファをオーバーフローすると、同じゾーン内の **次のオブジェクト** を上書きしてしまう。

これが heap spraying / feng shui が非常に有効だった理由で、同じサイズクラスの割当をスプレーすることでオブジェクトの隣接関係を予測できた。


### フリーリスト

各 kalloc ゾーン内で、解放されたオブジェクトは直接システムに返されず — フリーリスト（利用可能チャンクの連結リスト）に入った。

- チャンクが解放されると、カーネルはそのチャンクの先頭にポインタを書き込む → 同じゾーン内の次のフリーチャンクのアドレス。
- ゾーンは最初のフリーチャンクを指す HEAD ポインタを持っている。
- 割当は常に現在の HEAD を使う:

1. HEAD をポップ（そのメモリを呼び出し元に返す）。
2. HEAD = HEAD->next に更新（解放されたチャンクのヘッダに保存されている）。

- 解放はチャンクをプッシュする:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

つまりフリーリストは解放されたメモリ内に構築された単なる連結リストだった。

通常の状態:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### freelistを悪用する

free chunk の最初の8バイトは freelist pointer に等しいため、攻撃者はこれを破損させることができる：

1. **Heap overflow** により隣接する freed chunk に侵入 → “next” pointer を上書きする。
2. **Use-after-free** により freed object に書き込む → “next” pointer を上書きする。

次に同サイズの割り当てが行われると：

- allocator は破損したチャンクをポップする。
- 攻撃者が供給した “next” pointer を辿る。
- 任意のメモリへのポインタを返し、fake object primitives や targeted overwrite を可能にする。

Visual example of freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
This freelist design made exploitation highly effective pre-hardening: predictable neighbors from heap sprays, raw pointer freelist links, and no type separation allowed attackers to escalate UAF/overflow bugs into arbitrary kernel memory control.

### Heap Grooming / Feng Shui
The goal of heap grooming is to **shape the heap layout** so that when an attacker triggers an overflow or use-after-free, the target (victim) object sits right next to an attacker-controlled object.\
That way, when memory corruption happens, the attacker can reliably overwrite the victim object with controlled data.

**Steps:**

1. Spray allocations (fill the holes)
- Over time, the kernel heap gets fragmented: some zones have holes where old
objects were freed.
- The attacker first makes lots of dummy allocations to fill these gaps, so
the heap becomes “packed” and predictable.

2. Force new pages
- Once the holes are filled, the next allocations must come from new pages
added to the zone.
- Fresh pages mean objects will be clustered together, not scattered across
old fragmented memory.
- This gives the attacker much better control of neighbors.

3. Place attacker objects
- The attacker now sprays again, creating lots of attacker-controlled objects
in those new pages.
- These objects are predictable in size and placement (since they all belong
to the same zone).

4. Free a controlled object (make a gap)
- The attacker deliberately frees one of their own objects.
- This creates a “hole” in the heap, which the allocator will later reuse for
the next allocation of that size.

5. Victim object lands in the hole
- The attacker triggers the kernel to allocate the victim object (the one
they want to corrupt).
- Since the hole is the first available slot in the freelist, the victim is
placed exactly where the attacker freed their object.

6. Overflow / UAF into victim
- Now the attacker has attacker-controlled objects around the victim.
- By overflowing from one of their own objects (or reusing a freed one), they
can reliably overwrite the victim’s memory fields with chosen values.

**Why it works**:

- Zone allocator predictability: allocations of the same size always come from
the same zone.
- Freelist behavior: new allocations reuse the most recently freed chunk first.
- Heap sprays: attacker fills memory with predictable content and controls layout.
- End result: attacker controls where the victim object lands and what data sits
next to it.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple hardened the allocator and made **heap grooming much harder**:

### 1. From Classic kalloc to kalloc_type
- **Before**: a single `kalloc.<size>` zone existed for each size class (16, 32, 64, … 1280, etc.). Any object of that size was placed there → attacker objects could sit next to privileged kernel objects.
- **Now**:
- Kernel objects are allocated from **typed zones** (`kalloc_type`).
- Each type of object (e.g., `ipc_port_t`, `task_t`, `OSString`, `OSData`) has its own dedicated zone, even if they’re the same size.
- The mapping between object type ↔ zone is generated from the **kalloc_type system** at compile time.

An attacker can no longer guarantee that controlled data (`OSData`) ends up adjacent to sensitive kernel objects (`task_t`) of the same size.

### 2. Slabs and Per-CPU Caches
- The heap is divided into **slabs** (pages of memory carved into fixed-size chunks for that zone).
- Each zone has a **per-CPU cache** to reduce contention.
- Allocation path:
1. Try per-CPU cache.
2. If empty, pull from the global freelist.
3. If freelist is empty, allocate a new slab (one or more pages).
- **Benefit**: This decentralization makes heap sprays less deterministic, since allocations may be satisfied from different CPUs’ caches.

### 3. Randomization inside zones
- Within a zone, freed elements are not handed back in simple FIFO/LIFO order.
- Modern XNU uses **encoded freelist pointers** (safe-linking like Linux, introduced ~iOS 14).
- Each freelist pointer is **XOR-encoded** with a per-zone secret cookie.
- This prevents attackers from forging a fake freelist pointer if they gain a write primitive.
- Some allocations are **randomized in their placement within a slab**, so spraying doesn’t guarantee adjacency.

### 4. Guarded Allocations
- Certain critical kernel objects (e.g., credentials, task structures) are allocated in **guarded zones**.
- These zones insert **guard pages** (unmapped memory) between slabs or use **redzones** around objects.
- Any overflow into the guard page triggers a fault → immediate panic instead of silent corruption.

### 5. Page Protection Layer (PPL) and SPTM
- Even if you control a freed object, you can’t modify all of kernel memory:
- **PPL (Page Protection Layer)** enforces that certain regions (e.g., code signing data, entitlements) are **read-only** even to the kernel itself.
- On **A15/M2+ devices**, this role is replaced/enhanced by **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- These hardware-enforced layers mean attackers can’t escalate from a single heap corruption to arbitrary patching of critical security structures.
- **(Added / Enhanced)**: also, **PAC (Pointer Authentication Codes)** is used in the kernel to protect pointers (especially function pointers, vtables) so that forging or corrupting them becomes harder.
- **(Added / Enhanced)**: zones may enforce **zone_require / zone enforcement**, i.e. that an object freed can only be returned through its correct typed zone; invalid cross-zone frees may panic or be rejected. (Apple alludes to this in their memory safety posts)

### 6. Large Allocations
- Not all allocations go through `kalloc_type`.
- Very large requests (above ~16 KB) bypass typed zones and are served directly from **kernel VM (kmem)** via page allocations.
- These are less predictable, but also less exploitable, since they don’t share slabs with other objects.

### 7. Allocation Patterns Attackers Target
Even with these protections, attackers still look for:
- **Reference count objects**: if you can tamper with retain/release counters, you may cause use-after-free.
- **Objects with function pointers (vtables)**: corrupting one still yields control flow.
- **Shared memory objects (IOSurface, Mach ports)**: these are still attack targets because they bridge user ↔ kernel.

But — unlike before — you can’t just spray `OSData` and expect it to neighbor a `task_t`. You need **type-specific bugs** or **info leaks** to succeed.

### Example: Allocation Flow in Modern Heap

Suppose userspace calls into IOKit to allocate an `OSData` object:

1. **Type lookup** → `OSData` maps to `kalloc_type_osdata` zone (size 64 bytes).
2. Check per-CPU cache for free elements.
- If found → return one.
- If empty → go to global freelist.
- If freelist empty → allocate a new slab (page of 4KB → 64 chunks of 64 bytes).
3. Return chunk to caller.

**Freelist pointer protection**:
- Each freed chunk stores the address of the next free chunk, but encoded with a secret key.
- Overwriting that field with attacker data won’t work unless you know the key.

---

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages, and **PAC** protects pointers |
| Allocation reuse validation     | None (freelist pointers raw)                               | **zone_require / zone enforcement**             |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |
| Large allocations handling      | All small allocations managed equally                       | Large ones bypass zones → handled via VM         |

---

## Modern Userland Heap (iOS, macOS — type-aware / xzone malloc)

In recent Apple OS versions (especially iOS 17+), Apple introduced a more secure userland allocator, **xzone malloc** (XZM). This is the user-space analog to the kernel’s `kalloc_type`, applying type awareness, metadata isolation, and memory tagging safeguards.

### Goals & Design Principles

- **Type segregation / type awareness**: group allocations by *type or usage (pointer vs data)* to prevent type confusion and cross-type reuse.
- **Metadata isolation**: separate heap metadata (e.g. free lists, size/state bits) from object payloads so that out-of-bounds writes are less likely to corrupt metadata.
- **Guard pages / redzones**: insert unmapped pages or padding around allocations to catch overflows.
- **Memory tagging (EMTE / MIE)**: work in conjunction with hardware tagging to detect use-after-free, out-of-bounds, and invalid accesses.
- **Scalable performance**: maintain low overhead, avoid excessive fragmentation, and support many allocations per second with low latency.

### Architecture & Components

Below are the main elements in the xzone allocator:

#### Segment Groups & Zones

- **Segment groups** partition the address space by usage categories: e.g. `data`, `pointer_xzones`, `data_large`, `pointer_large`.
- Each segment group contains **segments** (VM ranges) that host allocations for that category.
- Associated with each segment is a **metadata slab** (separate VM area) that stores metadata (e.g. free/used bits, size classes) for that segment. This **out-of-line (OOL) metadata** ensures that metadata is not intermingled with object payloads, mitigating corruption from overflows.
- Segments are carved into **chunks** (slices) which in turn are subdivided into **blocks** (allocation units). A chunk is tied to a specific size class and segment group (i.e. all blocks in a chunk share the same size & category).
- For small / medium allocations, it will use fixed-size chunks; for large/huges, it may map separately.

#### Chunks & Blocks

- A **chunk** is a region (often several pages) dedicated to allocations of one size class within a group.
- Inside a chunk, **blocks** are slots available for allocations. Freed blocks are tracked via the metadata slab — e.g. via bitmaps or free lists stored out-of-line.
- Between chunks (or within), **guard slices / guard pages** may be inserted (e.g. unmapped slices) to catch out-of-bounds writes.

#### Type / Type ID

- Every allocation site (or call to malloc, calloc, etc.) is associated with a **type identifier** (a `malloc_type_id_t`) which encodes what kind of object is being allocated. That type ID is passed to the allocator, which uses it to select which zone / segment to serve the allocation.
- Because of this, even if two allocations have the same size, they may go into entirely different zones if their types differ.
- In early iOS 17 versions, not all APIs (e.g. CFAllocator) were fully type-aware; Apple addressed some of those weaknesses in iOS 18.

---

### Allocation & Freeing Workflow

Here is a high-level flow of how allocation and deallocation operate in xzone:

1. **malloc / calloc / realloc / typed alloc** is invoked with a size and type ID.
2. The allocator uses the **type ID** to pick the correct segment group / zone.
3. Within that zone/segment, it seeks a chunk that has free blocks of the requested size.
- It may consult **local caches / per-thread pools** or **free block lists** from metadata.
- If no free block is available, it may allocate a new chunk in that zone.
4. The metadata slab is updated (free bit cleared, bookkeeping).
5. If memory tagging (EMTE) is in play, the returned block gets a **tag** assigned, and metadata is updated to reflect its “live” state.
6. When `free()` is called:
- The block is marked as freed in metadata (via OOL slab).
- The block may be placed into a free list or pooled for reuse.
- Optionally, block contents may be cleared or poisoned to reduce data leaks or use-after-free exploitation.
- The hardware tag associated with the block may be invalidated or re-tagged.
- If an entire chunk becomes free (all blocks freed), the allocator may **reclaim** that chunk (unmap it or return to OS) under memory pressure.

---

### Security Features & Hardening

These are the defenses built into modern userland xzone:

| Feature | Purpose | Notes |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | Prevent overflow from corrupting metadata | Metadata lives in separate VM region (metadata slab)|
| **Guard pages / unmapped slices** | Catch out-of-bounds writes | Helps detect buffer overflows rather than silently corrupting adjacent blocks|
| **Type-based segregation** | Prevent cross-type reuse & type confusion | Even same-size allocations from different types go to different zones|
| **Memory Tagging (EMTE / MIE)** | Detect invalid access, stale references, OOB, UAF | xzone works in concert with hardware EMTE in synchronous mode (“Memory Integrity Enforcement”)|
| **Delayed reuse / poisoning / zap** | Reduce chance of use-after-free exploitation | Freed blocks may be poisoned, zeroed, or quarantined before reuse |
| **Chunk reclamation / dynamic unmapping** | Reduce memory waste and fragmentation | Entire chunks may be unmapped when unused |
| **Randomization / placement variation** | Prevent deterministic adjacency | Blocks in a chunk and chunk selection may have randomized aspects |
| **Segregation of “data-only” allocations** | Separate allocations that don’t store pointers | Reduces attacker control over metadata or control fields|

---

### Interaction with Memory Integrity Enforcement (MIE / EMTE)

- Apple’s MIE (Memory Integrity Enforcement) is the hardware + OS framework that brings **Enhanced Memory Tagging Extension (EMTE)** into always-on, synchronous mode across major attack surfaces.
- xzone allocator is a fundamental foundation of MIE in user space: allocations done via xzone get tags, and accesses are checked by hardware.
- In MIE, the allocator, tag assignment, metadata management, and tag confidentiality enforcement are integrated to ensure that memory errors (e.g. stale reads, OOB, UAF) are caught immediately, not exploited later.

---

If you like, I can also generate a cheat-sheet or diagram of xzone internals for your book. Do you want me to do that next?
::contentReference[oai:20]{index=20}


---

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


## JSKit-Based Safari Chains and PREYHUNTER Stagers

### Renderer RCE abstraction with JSKit
- **Reusable entry**: Recent in-the-wild chains abused a WebKit JIT bug (patched as CVE-2023-41993) purely to gain JavaScript-level arbitrary read/write. The exploit immediately pivots into a purchased framework called **JSKit**, so any future Safari bug only needs to deliver the same primitive.
- **Version abstraction & PAC bypasses**: JSKit bundles support for a wide range of iOS releases together with multiple, selectable Pointer Authentication Code bypass modules. The framework fingerprints the target build, selects the appropriate PAC bypass logic, and verifies every step (primitive validation, shellcode launch) before progressing.
- **Manual Mach-O mapping**: JSKit parses Mach-O headers directly from memory, resolves the symbols it needs inside dyld-cached images, and can manually map additional Mach-O payloads without writing them to disk. This keeps the renderer process in-memory only and evades code-signature checks tied to filesystem artifacts.
- **Portfolio model**: Debug strings such as *"exploit number 7"* show that the suppliers maintain multiple interchangeable WebKit exploits. Once the JS primitive matches JSKit’s interface, the rest of the chain is unchanged across campaigns.

### Kernel bridge: IPC UAF -> code-sign bypass pattern
- **Kernel IPC UAF (CVE-2023-41992)**: The second stage, still running inside the Safari context, triggers a kernel use-after-free in IPC code, re-allocates the freed object from userland, and abuses the dangling pointers to pivot into arbitrary kernel read/write. The stage also reuses PAC bypass material previously computed by JSKit instead of re-deriving it.
- **Code-signing bypass (CVE-2023-41991)**: With kernel R/W available, the exploit patches the trust cache / code-signing structures so unsigned payloads execute as `system`. The stage then exposes a lightweight kernel R/W service to later payloads.
- **Composed pattern**: This chain demonstrates a reusable recipe that defenders should expect going forward:
```
WebKit renderer RCE -> kernel IPC UAF -> kernel arbitrary R/W -> code-sign bypass -> unsigned system stager
```
### PREYHUNTER helper & watcher modules
- **Watcher anti-analysis**: 専用の watcher バイナリがデバイスを継続的にプロファイリングし、研究環境が検出されるとキルチェーンを中断します。`security.mac.amfi.developer_mode_status`、`diagnosticd` コンソールの存在、ロケール `US` または `IL`、**Cydia** のような脱獄の痕跡、`bash`、`tcpdump`、`frida`、`sshd`、`checkrain` といったプロセス、McAfee、AvastMobileSecurity、NortonMobileSecurity のようなモバイルAVアプリ、カスタムHTTPプロキシ設定、カスタムルートCAを検査します。いずれかの検査に失敗すると、追加のペイロード配信はブロックされます。
- **Helper surveillance hooks**: Helper コンポーネントは `/tmp/helper.sock` を介して他のステージと通信し、**DMHooker** と **UMHooker** という名前のフックセットをロードします。これらのフックは VOIP オーディオ経路にアクセスし（録音は `/private/var/tmp/l/voip_%lu_%u_PART.m4a` に保存されます）、システム全体のキー入力ロガーを実装し、UI を表示せずに写真を撮影し、そのような動作によって通常発生する通知を抑制するために SpringBoard にフックを入れます。したがって helper は、Predator のようなより大きなインプラントを投入する前のステルスな検証および軽度の監視レイヤとして機能します。

### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

## References

- [Google Threat Intelligence – Intellexa zero-day exploits continue](https://cloud.google.com/blog/topics/threat-intelligence/intellexa-zero-day-exploits-continue)

{{#include ../../banners/hacktricks-training.md}}
