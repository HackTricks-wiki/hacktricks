# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

### 1. **Code Signing** / Runtime Signature Verification
**Introduced early (iPhone OS → iOS)**
Ovo je jedna od osnovnih zaštita: **svi izvršni binarni fajlovi** (apps, dynamic libraries, JIT-ed code, extensions, frameworks, caches) moraju biti kriptografski potpisani sertifikatnim lancem koji vodi do Apple-ovog root trust-a. U runtime-u, pre učitavanja binarnog fajla u memoriju (ili pre izvođenja skokova preko određenih granica), sistem proverava njegov potpis. Ako je kod modifikovan (bit-flip, patch) ili nepotpisan, učitavanje ne uspeva.

- **Onemogućava**: fazu “classic payload drop + execute” u exploit lancima; arbitrary code injection; modifikovanje postojećeg binárnog fajla da se ubaci maliciozna logika.
- **Mehanizam (detalji)**:
* Mach-O loader (i dynamic linker) proverava code pages, segmente, entitlements, team IDs, i da li potpis pokriva sadržaj fajla.
* Za regione u memoriji kao što su JIT cache-ovi ili dinamički generisan kod, Apple zahteva da stranice budu potpisane ili validirane putem specijalnih API-ja (npr. `mprotect` sa code-sign proverama).
* Potpis uključuje entitlements i identifikatore; OS zahteva da određeni API-ji ili privilegovane mogućnosti zahtevaju specifične entitlements koje nije moguće falsifikovati.

<details>
<summary>Example</summary>
Pretpostavimo da exploit obezbedi code execution u procesu i pokuša da upiše shellcode u heap i skoči na njega. Na iOS-u, ta stranica bi morala biti označena kao executable **i** zadovoljiti code-signature zahteve. Pošto shellcode nije potpisan Apple-ovim sertifikatom, skok ne uspeva ili sistem odbija da tu memorijsku regiju učini executable.
</details>


### 2. **CoreTrust**
**Introduced around iOS 14+ era (or gradually in newer devices / later iOS)**
CoreTrust je subsistem koji vrši **runtime signature validation** binarnih fajlova (uključujući sistemske i korisničke) protiv **Apple-ovog root sertifikata** umesto oslanjanja na keširane userland trust store-ove.

- **Onemogućava**: post-install tampering binarnih fajlova, jailbreaking tehnike koje pokušavaju da zamene ili patch-uju sistemske biblioteke ili user apps; obmanjivanje sistema zamenom trusted binarnih fajlova malicioznim verzijama.
- **Mehanizam (detalji)**:
* Umesto da veruje lokalnoj trust bazi ili kešu sertifikata, CoreTrust referiše Apple-ov root direktno ili verifikuje intermediate sertifikate u sigurnom lancu.
* Osigurava da se modifikacije (npr. u filesystem-u) postojećih binarnih fajlova detektuju i odbiju.
* Vezuje entitlements, team IDs, code signing flag-ove i drugu metapodatke za binarni fajl u vreme učitavanja.

<details>
<summary>Example</summary>
Jailbreak bi mogao pokušati da zameni `SpringBoard` ili `libsystem` sa patch-ovanom verzijom radi perzistencije. Ali kada loader OS-a ili CoreTrust izvrši proveru, primeti mismatch u potpisu (ili izmenjene entitlements) i odbije izvršenje.
</details>


### 3. **Data Execution Prevention (DEP / NX / W^X)**
**Introduced in many OSes earlier; iOS had NX-bit / w^x for a long time**
DEP nameće da stranice označene kao writable (za podatke) budu **non-executable**, i stranice označene kao executable budu **non-writable**. Ne možete jednostavno upisati shellcode u heap ili stack region i izvršiti ga.

- **Onemogućava**: direktno izvršenje shellcode-a; klasik buffer-overflow → jump to injected shellcode.
- **Mehanizam (detalji)**:
* MMU / memory protection flag-ovi (putem page table-a) nameću ovu separaciju.
* Bilo kakav pokušaj da se writable stranica označi kao executable pokreće sistemsku proveru (i ili je zabranjen ili zahteva code-sign odobrenje).
* U mnogim slučajevima, pravljenje stranica executable zahteva korišćenje OS API-ja koji nameću dodatna ograničenja ili provere.

<details>
<summary>Example</summary>
Overflow upisuje shellcode na heap. Napadač poziva `mprotect(heap_addr, size, PROT_EXEC)` da je učini executable. Ali sistem to odbija ili validira da nova stranica mora proći code-sign constraint-e (što shellcode ne može).
</details>

### 4. **Address Space Layout Randomization (ASLR)**
**Introduced in iOS ~4–5 era (roughly iOS 4–5 timeframe)**
ASLR randomizuje baze ključnih memorijskih regiona: libraries, heap, stack, itd., pri svakom pokretanju procesa. Adrese gadget-a se pomeraju između pokretanja.

- **Onemogućava**: hardkodiranje adresa gadget-a za ROP/JOP; statične exploit lance; blind jumping na poznate offset-e.
- **Mehanizam (detalji)**:
* Svaka učitana library / dynamic module se rebasa na randomizovani offset.
* Stack i heap base pointer-i se randomizuju (u okviru određenog entropijskog opsega).
* Ponekad su i drugi regioni (npr. mmap alokacije) takođe randomizovani.
* U kombinaciji sa information-leak mitigacijama, prisiljava napadača prvo da leak-uje adresu ili pointer da otkrije baze adresa u runtime-u.

<details>
<summary>Example</summary>
ROP lanč očekuje gadget na `0x….lib + offset`. Pošto se `lib` relocira drugačije pri svakom pokretanju, hardkodovani lanč ne uspeva. Exploit mora prvo da leak-uje baznu adresu modula pre nego što izračuna adrese gadget-a.
</details>


### 5. **Kernel Address Space Layout Randomization (KASLR)**
**Introduced in iOS ~ (iOS 5 / iOS 6 timeframe)**
Analogno user ASLR-u, KASLR randomizuje bazu **kernel text** i drugih kernel struktura pri boot-u.

- **Onemogućava**: kernel-level exploit-e koji se oslanjaju na fiksnu lokaciju kernel koda ili podataka; statične kernel exploit-e.
- **Mehanizam (detalji)**:
* Pri svakom boot-u, kernel base adresa se randomizuje (u okviru određenog opsega).
* Kernel data strukture (kao što su `task_structs`, `vm_map`, itd.) takođe mogu biti preseljene ili imati offset.
* Napadači moraju prvo da leak-uju kernel pointer-e ili koriste information disclosure ranjivosti da izračunaju offset-e pre nego što hijack-uju kernel strukture ili kod.

<details>
<summary>Example</summary>
Lokalna ranjivost ima cilj da korumpira kernel function pointer (npr. u `vtable`) na `KERN_BASE + offset`. Ali pošto je `KERN_BASE` nepoznat, napadač prvo mora da ga leak-uje (npr. preko read primitive) pre nego što izračuna ispravnu adresu za korupciju.
</details>


### 6. **Kernel Patch Protection (KPP / AMCC)**
**Introduced in newer iOS / A-series hardware (post around iOS 15–16 era or newer chips)**
KPP (aka AMCC) kontinuirano nadgleda integritet kernel text stranica (putem hash-a ili checksum-a). Ako detektuje tampering (patch-eve, inline hook-ove, izmene koda) van dozvoljenih prozora, pokreće kernel panic ili reboot.

- **Onemogućava**: persistent kernel patching (modifikovanje kernel instrukcija), inline hooks, statičke zamene funkcija.
- **Mehanizam (detalji)**:
* Hardverski ili firmware modul nadgleda kernel text region.
* Periodično ili na zahtev re-hash-uje stranice i upoređuje sa očekivanim vrednostima.
* Ako se pojave mismatch-evi van benignih update prozora, pokreće panic uređaja (da bi se izbegla perzistentna maliciozna izmena).
* Napadači moraju ili izbeći detekcijske prozore ili koristiti legitimne update puteve.

<details>
<summary>Example</summary>
Exploit pokuša da patch-uje prolog kernel funkcije (npr. `memcmp`) da presretne pozive. Ali KPP primeti da hash code stranice više ne odgovara očekivanoj vrednosti i izazove kernel panic, rušeći uređaj pre nego što se patch stabilizuje.
</details>


### 7. **Kernel Text Read‐Only Region (KTRR)**
**Introduced in modern SoCs (post ~A12 / newer hardware)**
KTRR je hardverski-enforced mehanizam: nakon što se kernel text zaključa rano tokom boot-a, postaje read-only iz EL1 (kernela), sprečavajući dalje upise u code stranice.

- **Onemogućava**: bilo kakve modifikacije kernel koda nakon boot-a (npr. patching, in-place code injection) na EL1 privilegovanom nivou.
- **Mehanizam (detalji)**:
* Tokom boot-a (u secure/bootloader fazi), memory controller (ili sigurni hardverski modul) označava fizičke stranice koje sadrže kernel text kao read-only.
* Čak i ako exploit dobije pune kernel privilegije, ne može da piše u te stranice da bi patch-ovao instrukcije.
* Da bi ih menjao, napadač mora prvo kompromitovati boot chain ili subvert-ovati sam KTRR.

<details>
<summary>Example</summary>
Privilege-escalation exploit skoči u EL1 i pokuša da upiše trampoline u kernel funkciju (npr. u `syscall` handler). Ali pošto su stranice zaključane kao read-only od strane KTRR-a, upis ne uspeva (ili izazove fault), pa se patch ne primeni.
</details>


### 8. **Pointer Authentication Codes (PAC)**
**Introduced with ARMv8.3 (hardware), Apple beginning with A12 / iOS ~12+**
- PAC je hardverska funkcija uvedena u **ARMv8.3-A** za detekciju tampering-a pointer vrednosti (return addresses, function pointers, određeni data pointer-i) ubacivanjem malog kriptografskog potpisa (“MAC”) u neiskorišćene visoke bitove pointer-a.
- Potpis (“PAC”) se računa preko pointer vrednosti plus **modifier** (kontekstna vrednost, npr. stack pointer ili neki ID). Na taj način ista pointer vrednost u različitim kontekstima dobija različit PAC.
- Kada se pointer koristi, instrukcija za **authenticate** proverava PAC. Ako je validan, PAC se uklanja i dobija se čista pointer vrednost; ako nije validan, pointer postaje “poisoned” (ili se podigne fault).
- Ključevi koji se koriste za pravljenje/validaciju PAC-a žive u privilegovanim registrima (EL1, kernel) i nisu direktno čitljivi iz user mode-a.
- Pošto nisu svi 64 bita pointer-a iskorišćeni u mnogim sistemima (npr. 48-bit address space), gornji bitovi su “slobodni” i mogu držati PAC bez menjanja efektivne adrese.

#### Architectural Basis & Key Types

- ARMv8.3 uvodi **pet 128-bit ključeva** (svaki implementiran preko dva 64-bit system registra) za pointer authentication.
- **APIAKey** — za instruction pointers (domen “I”, ključ A)
- **APIBKey** — drugi instruction pointer ključ (domen “I”, ključ B)
- **APDAKey** — za data pointer-e (domen “D”, ključ A)
- **APDBKey** — za data pointer-e (domen “D”, ključ B)
- **APGAKey** — “generic” ključ, za potpisivanje non-pointer podataka ili druge generičke upotrebe

- Ovi ključevi su smešteni u privilegovane system registre (pristup je moguć samo na EL1/EL2 itd.), nedostupni iz user mode-a.
- PAC se računa kriptografskom funkcijom (ARM predlaže QARMA kao algoritam) koristeći:
1. Pointer vrednost (kanonični deo)
2. **modifier** (kontekstna vrednost, kao salt)
3. Tajni ključ
4. Neki interni tweak logic
Ako dobijeni PAC odgovara onome što je smešteno u gornjim bitovima pointer-a, autentikacija uspe.

#### Instruction Families

Konvencija imenovanja je: **PAC** / **AUT** / **XPAC**, zatim sufiksi domena.
- `PACxx` instrukcije **potpisuju** pointer i ubacuju PAC
- `AUTxx` instrukcije **autentifikuju + skidaju** (validiraju i uklanjaju PAC)
- `XPACxx` instrukcije **skidaju** bez validacije

Domeni / sufiksi:

| Mnemonic     | Značenje / Domen                      | Ključ / Domen     | Primer upotrebe u Assembly |
|--------------|-----------------------------------------|--------------------|-----------------------------|
| **PACIA**    | Potpiši instruction pointer koristeći APIAKey   | “I, A”             | `PACIA X0, X1` — potpiši pointer u X0 koristeći APIAKey sa modifier-om X1|
| **PACIB**    | Potpiši instruction pointer koristeći APIBKey   | “I, B”             | `PACIB X2, X3`              |
| **PACDA**    | Potpiši data pointer koristeći APDAKey           | “D, A”             | `PACDA X4, X5`              |
| **PACDB**    | Potpiši data pointer koristeći APDBKey           | “D, B”             | `PACDB X6, X7`              |
| **PACG / PACGA** | Generic (non-pointer) potpisivanje koristeći APGAKey | “G”         | `PACGA X8, X9, X10` (potpiši X9 sa modifier-om X10 u X8) |
| **AUTIA**    | Autentifikuj APIA-potpisani instruction pointer i skini PAC | “I, A” | `AUTIA X0, X1` — proveri PAC na X0 koristeći modifier X1, zatim ukloni |
| **AUTIB**    | Autentifikuj APIB domen                 | “I, B”             | `AUTIB X2, X3`               |
| **AUTDA**    | Autentifikuj APDA-potpisani data pointer    | “D, A”             | `AUTDA X4, X5`               |
| **AUTDB**    | Autentifikuj APDB-potpisani data pointer    | “D, B”             | `AUTDB X6, X7`               |
| **AUTGA**    | Autentifikuj generički / blob (APGA)        | “G”               | `AUTGA X8, X9, X10` (validiraj generički) |
| **XPACI**     | Skini PAC (instruction pointer, bez validacije) | “I”         | `XPACI X0` — ukloni PAC iz X0 (instruction domain) |
| **XPACD**     | Skini PAC (data pointer, bez validacije)    | “D”             | `XPACD X4` — ukloni PAC iz data pointer-a u X4 |


Postoje specijalizovane / alias forme:

- `PACIASP` je skraćeno za `PACIA X30, SP` (potpiši link register koristeći SP kao modifier)
- `AUTIASP` je `AUTIA X30, SP` (autentifikuj link register sa SP)
- Kombinovane forme kao `RETAA`, `RETAB` (autentifikuj-i-vrati) ili `BLRAA` (autentifikuj i branch) postoje u ARM ekstenzijama / podršci kompajlera.
- Takođe nult-modifier varijante: `PACIZA` / `PACIZB` gde je modifier implicitno nula, itd.

#### Modifiers

Glavni cilj modifier-a je da **veže PAC za specifičan kontekst** tako da ista adresa potpisana u različitim kontekstima daje različit PAC. Ovo sprečava jednostavnu ponovnu upotrebu pointer-a između frejmova ili objekata. To je kao dodavanje **salta** hashu.

Dakle:
- **modifier** je kontekstna vrednost (neki registar) koja se meša u PAC računanje. Tipični izbori: stack pointer (`SP`), frame pointer, ili neki object ID.
- Korišćenje SP kao modifier-a je uobičajeno za potpisivanje return adresa: PAC se veže za specifičan stack frame. Ako pokušaš da ponovo upotrebiš LR u drugom frejmu, modifier se menja pa AUT ne uspe.
- Ista pointer vrednost potpisana pod različitim modifier-ima vodi do različitih PAC-ova.
- Modifier **ne mora biti tajan**, ali idealno nije kontrolisan od strane napadača.
- Za instrukcije koje potpisuju ili verifikuju pointer-e gde ne postoji smislen modifier, neke forme koriste nulu ili implicitnu konstantu.

#### Apple / iOS / XNU Customizations & Observations

- Apple-ova PAC implementacija uključuje **per-boot diversifiers** tako da se ključevi ili tweak-ovi menjaju pri svakom boot-u, sprečavajući reuse između boot-ova.
- Takođe uključuju **cross-domain mitigacije** tako da PAC potpisan u user mode-u ne može lako da se ponovo iskoristi u kernel mode-u, itd.
- Na Apple M1 / Apple Silicon, reverse engineering je pokazao da postoje **devet tipova modifier-a** i Apple-specifični system registri za kontrolu ključeva.
- Apple koristi PAC u mnogim kernel pod-sistemima: potpisivanje return adresa, integritet pointer-a u kernel podacima, potpisani thread context-i, itd.
- Google Project Zero je pokazao kako pod moćnim memory read/write primitive-om u kernel-u, neko može falsifikovati kernel PAC-ove (za A ključeve) na A12-era uređajima, ali Apple je patch-ovao mnoge od tih puteva.
- U Apple-ovom sistemu, neki ključevi su **globalni za kernel**, dok procesi dobijaju per-process key randomness.

#### PAC Bypasses

1. **Kernel-mode PAC: theoretical vs real bypasses**

-   Pošto su kernel PAC ključevi i logika strogo kontrolisani (privilegovani registri, diversifiers, domain izolacija), forg-ovanje proizvoljnih potpisanih kernel pointer-a je veoma teško.
-   Azad-ov 2020 "iOS Kernel PAC, One Year Later" izveštaj navodi da je u iOS 12-13 pronašao nekoliko partial bypass-ova (signing gadgets, reuse potpisanih stanja, nezaštićeni indirektni skokovi) ali ne i full generic bypass. [bazad.github.io](https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf)
-   Apple-ove "Dark Magic" customizacije dodatno su srezale exploitable površine (domain switching, per-key enabling bits). [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Postoji poznati **kernel PAC bypass CVE-2023-32424** na Apple silicon-u (M1/M2) izveštan od strane Zecao Cai i saradnika. [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Ali ovi bypass-i često zavise od vrlo specifičnih gadget-a ili implementacijskih bagova; nisu general-purpose bypass.

Dakle kernel PAC se smatra **izuzetno robusnim**, iako ne i savršenim.

2. **User-mode / runtime PAC bypass techniques**

Ovi su češći i iskorišćavaju nesavršenosti u primeni PAC-a ili u runtime/framework interakcijama. Ispod su klase tehnika sa primerima.

2.1 **Shared Cache / A key issues**

-   **dyld shared cache** je veliki pre-linked blob sistemskih framework-a i biblioteka. Pošto se široko deli, function pointer-i unutar shared cache-a su “pre-signed” i zatim korišćeni od strane mnogih procesa. Napadači ciljaju ove već potpisane pointer-e kao “PAC oracles”.

-   Neki bypassi pokušavaju da izvuku ili ponovo iskoriste A-key potpisane pointer-e prisutne u shared cache i ponovo ih upotrebe u gadget-ima.

-   Predavanje "No Clicks Required" opisuje izgradnju oracle-a preko shared cache-a da se infer-uju relativne adrese i kombinuju sa potpisanim pointer-ima za bypass PAC-a. [saelo.github.io](https://saelo.github.io/presentations/offensivecon_20_no_clicks.pdf)

-   Takođe, import-ovi function pointer-a iz shared libraries u userspace su ponekad bili nedovoljno zaštićeni PAC-om, omogućavajući napadaču da dobije function pointer-e bez menjanja njihovog potpisa. (Project Zero bug entry) [bugs.chromium.org](https://bugs.chromium.org/p/project-zero/issues/detail?id=2044&utm_source=chatgpt.com)

2.2 **dlsym(3) / dynamic symbol resolution**

-   Jedan poznat bypass je pozvati `dlsym()` da se dobije *već potpisan* function pointer (potpisan A-key-om, diversifier nula) i zatim ga koristiti. Pošto `dlsym` vraća legitimno potpisan pointer, njegovo korišćenje zaobilazi potrebu za falsifikovanjem PAC-a.

-   Epsilon-ov blog opisuje kako neki bypass-i iskorišćavaju ovo: pozivanjem `dlsym("someSym")` dobija se potpisani pointer koji se može koristiti za indirektne pozive. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

-   Synacktiv-ov tekst "iOS 18.4 --- dlsym considered harmful" opisuje bug: neki simboli razrešeni preko `dlsym` na iOS 18.4 vraćaju pointer-e koji su pogrešno potpisani (ili sa buggy diversifier-ima), omogućavajući nenameran PAC bypass. [Synacktiv](https://www.synacktiv.com/en/publications/ios-184-dlsym-considered-harmful)

-   Logika u dyld-u za dlsym uključuje: kada `result->isCode`, oni potpisuju vraćeni pointer sa `__builtin_ptrauth_sign_unauthenticated(..., key_asia, 0)`, tj. kontekst nula. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

Dakle, `dlsym` je čest vektor u user-mode PAC bypass-ovima.

2.3 **Other DYLD / runtime relocations**

-   DYLD loader i dynamic relocation logika su kompleksni i ponekad privremeno mapiraju stranice kao read/write da bi izvršili relocations, pa ih onda vrate na read-only. Napadači iskorišćavaju te vremenske prozore. Synacktiv-ovo predavanje opisuje "Operation Triangulation", timing-bazirani bypass PAC-a putem dynamic relocations. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   DYLD stranice su sada zaštićene sa SPRR / VM_FLAGS_TPRO (neki protection flag-ovi za dyld). Ali ranije verzije imale su slabije zaštite. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   U WebKit exploit lancima, DYLD loader je često meta za PAC bypass. Slides navode da su mnogi PAC bypass-i ciljali DYLD loader (preko relocations, interposer hook-ova). [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

2.4 **NSPredicate / NSExpression / ObjC / SLOP**

-   U userland exploit lancima, Objective-C runtime metode kao `NSPredicate`, `NSExpression` ili `NSInvocation` se koriste da “smuggle” control calls bez očiglednog falsifikovanja pointer-a.

-   Na starijim iOS verzijama (pre PAC), exploit je koristio **fake NSInvocation** objekte da pozove proizvoljne selektore na kontrolisanoj memoriji. Sa PAC-om, tehnika zahteva izmenu. Ali tehnika SLOP (SeLector Oriented Programming) je proširena i pod PAC-om. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   Originalna SLOP tehnika je dozvoljavala chaining ObjC poziva stvaranjem lažnih invokacija; bypass se oslanjao na činjenicu da ISA ili selector pointer-i ponekad nisu bili u potpunosti zaštićeni PAC-om. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   U okruženjima gde je pointer authentication primenjen delimično, metode / selektori / target pointer-i možda nisu uvek PAC-zaštićeni, ostavljajući prostor za bypass.

#### Example Flow

<details>
<summary>Primer potpisivanja i autentifikacije</summary>
```
; Example: function prologue / return address protection
my_func:
stp x29, x30, [sp, #-0x20]!        ; push frame pointer + LR
mov x29, sp
PACIASP                            ; sign LR (x30) using SP as modifier
; … body …
mov sp, x29
ldp x29, x30, [sp], #0x20         ; restore
AUTIASP                            ; authenticate & strip PAC
ret

; Example: indirect function pointer stored in a struct
; suppose X1 contains a function pointer
PACDA X1, X2     ; sign data pointer X1 with context X2
STR X1, [X0]      ; store signed pointer

; later retrieval:
LDR X1, [X0]
AUTDA X1, X2       ; authenticate & strip
BLR X1             ; branch to valid target

; Example: stripping for comparison (unsafe)
LDR X1, [X0]
XPACI X1           ; strip PAC (instruction domain)
CMP X1, #some_label_address
BEQ matched_label
```
</details>

<details>
<summary>Primer</summary>
A buffer overflow prepisuje return adresu na steku. Napadač upisuje ciljnu adresu gadgeta ali ne može da izračuna ispravan PAC. Kada funkcija vrati, CPU-ova instrukcija `AUTIA` izazove grešku zbog neusaglašenosti PAC-a. Lanac se prekida.
Project Zero-ova analiza na A12 (iPhone XS) je pokazala kako Apple koristi PAC i metode falsifikovanja PAC-ova ako napadač ima memory read/write primitiv.
</details>


### 9. **Branch Target Identification (BTI)**
**Introduced with ARMv8.5 (later hardware)**
BTI je hardverska funkcija koja proverava **indirect branch targete**: kada se izvršava `blr` ili indirektni pozivi/skokovi, cilj mora početi sa **BTI landing pad-om** (`BTI j` ili `BTI c`). Skakanje u adrese gadgeta koje nemaju landing pad izaziva izuzetak.

LLVM-ove beleške implementacije navode tri varijante BTI instrukcija i kako se one mapiraju na vrste grana.

| BTI Varijanta | Šta dozvoljava (koje vrste grananja) | Tipično mesto / slučaj upotrebe |
|---------------|----------------------------------------|-------------------------------|
| **BTI C** | Ciljevi indirektnih grananja u stilu *call* (npr. `BLR`, ili `BR` koristeći X16/X17) | Postaviti na ulazu funkcija koje mogu biti pozvane indirektno |
| **BTI J** | Ciljevi indirektnih grananja u stilu *jump* (npr. `BR` korišćen za tail-calls) | Postavljen na početku blokova kojima se pristupa preko jump tabela ili tail-calls |
| **BTI JC** | Ponaša se i kao C i kao J | Može biti meta i call i jump grananja |

- U kodu kompajliranom sa branch target enforcement, kompajleri umeću BTI instrukciju (C, J, ili JC) na svaki validan indirect-branch target (početci funkcija ili blokovi dostižni skokovima) tako da indirektna grananja uspevaju samo do tih mesta.
- **Direct branches / calls** (tj. fiksno-adresni `B`, `BL`) **nisu ograničeni** od strane BTI. Pretpostavka je da su code stranice poverljive i da napadač ne može da ih promeni (dakle direct grane su bezbedne).
- Takođe, **RET / return** instrukcije generalno nisu ograničene BTI jer su return adrese zaštićene preko PAC ili mehanizama potpisivanja povratka.

#### Mehanizam i sprovođenje

- Kada CPU dekodira **indirect branch (BLR / BR)** u stranici označenoj kao „guarded / BTI-enabled,“ proverava da li prva instrukcija ciljne adrese predstavlja validan BTI (C, J, ili JC, ako je dozvoljeno). Ako nije, dolazi do **Branch Target Exception**.
- Kodiranje BTI instrukcije je dizajnirano da ponovo iskoristi opcode-ove prethodno rezervisane za NOP-ove (u ranijim ARM verzijama). Tako BTI-enabled binari ostaju backward-compatible: na hardveru bez BTI podrške te instrukcije deluju kao NOP.
- Kompajlerske faze koje dodaju BTI umeću ih samo tamo gde je potrebno: funkcije koje mogu biti pozvane indirektno, ili osnovni blokovi koji su ciljevi skokova.
- Neki patch-evi i LLVM kod pokazuju da se BTI ne umeće za *sve* osnovne blokove — samo za one koji su potencijalni branch targeti (npr. iz switch / jump tabela).

#### BTI + PAC sinergija

PAC štiti vrednost pokazivača (izvor) — osigurava da lanac indirektnih poziva/povrataka nije izmenjen.

BTI osigurava da čak i validan pokazivač može ciljati samo propisno označene ulazne tačke.

Zajedno, napadač treba i validan pokazivač sa ispravnim PAC-om i da ciljna lokacija ima postavljen BTI. Ovo povećava težinu konstruisanja exploit gadgeta.

#### Primer


<details>
<summary>Primer</summary>
Exploit pokuša da pivota u gadget na `0xABCDEF` koji ne počinje sa `BTI c`. CPU, pri izvršavanju `blr x0`, proveri cilj i napravi grešku jer instrukcija nije validan landing pad. Dakle mnogi gadgeti postaju neupotrebljivi osim ako nemaju BTI prefiks.
</details>


### 10. **Privileged Access Never (PAN) & Privileged Execute Never (PXN)**
**Introduced in more recent ARMv8 extensions / iOS support (for hardened kernel)**

#### PAN (Privileged Access Never)

- **PAN** je funkcija uvedena u **ARMv8.1-A** koja sprečava **privileged kod** (EL1 ili EL2) da **čita ili piše** memoriju koja je označena kao **user-accessible (EL0)**, osim ako PAN nije eksplicitno onemogućen.
- Ideja: čak i ako je kernel prevaren ili kompromitovan, on ne može proizvoljno dereferencirati user-space pokazivače bez prethodnog *isključivanja* PAN-a, čime se smanjuje rizik od `ret2usr` tip exploits-a ili zloupotrebe user-kontrolisanih buffera.
- Kada je PAN omogućен (PSTATE.PAN = 1), svaka privileged load/store instrukcija koja pristupa virtuelnoj adresi koja je „accessible at EL0“ izaziva **permission fault**.
- Kernel, kada legitimno mora da pristupi user-space memoriji (npr. kopiranje podataka iz/za user buffere), mora **privremeno da onemogući PAN** (ili da koristi „unprivileged load/store“ instrukcije) da bi omogućio taj pristup.
- U Linux-u na ARM64, podrška za PAN je uvedena oko 2015: kernel patch-evi su dodali detekciju te funkcije i zamenili `get_user` / `put_user` itd. varijantama koje brišu PAN oko pristupa korisničkoj memoriji.

**Ključna nijansa / ograničenje / bug**
- Kao što su Siguza i drugi napomenuli, specifikaciona greška (ili nejasno ponašanje) u ARM dizajnu znači da **execute-only user mappings** (`--x`) možda **neće trigger-ovati PAN**. Drugim rečima, ako je user stranica označena kao izvršna ali bez prava čitanja, pokušaj kernela da je pročita može zaobići PAN jer arhitektura smatra da „accessible at EL0“ zahteva čitljivu dozvolu, a ne samo izvršnu. Ovo vodi do PAN bypass-a u određenim konfiguracijama.
- Zbog toga, ako iOS / XNU dozvoljava execute-only user stranice (kako to rade neki JIT ili code-cache setup-i), kernel bi mogao nenamerno da pročita iz njih čak i sa omogućenim PAN-om. Ovo je poznata suptilna eksploatabilna oblast u nekim ARMv8+ sistemima.

#### PXN (Privileged eXecute Never)

- **PXN** je bit u page table-u (u page table entry-ima, leaf ili block entry-ima) koji označava da stranica **nije izvršna kada se izvršava u privileged modu** (tj. kada EL1 izvršava).
- PXN sprečava kernel (ili bilo koji privileged kod) da skoči u ili izvrši instrukcije iz user-space stranica čak i ako je kontrola preusmerena. U suštini, zaustavlja preusmeravanje izvršavanja kernel-a u user memoriju.
- Kombinovano sa PAN, ovo osigurava da:
1. Kernel podrazumevano ne može da čita ili piše user-space podatke (PAN)
2. Kernel ne može da izvršava user-space kod (PXN)
- U ARMv8 formatu page tabela, leaf entry-ji imaju `PXN` bit (i takođe `UXN` za unprivileged execute-never) u svojim atributnim bitovima.

Dakle čak i ako kernel ima korumpiran pokazivač funkcije koji pokazuje na user memoriju i pokuša da skoči tamo, PXN bit će izazvati grešku.

#### Model permisija memorije i kako se PAN i PXN mapiraju na page table bitove

Da biste razumeli kako PAN / PXN rade, treba videti kako ARM-ov prevod i model permisija funkcionišu (pojednostavljeno):

- Svaka page ili block entry ima atributna polja uključujući **AP[2:1]** za pristupna prava (read/write, privileged vs unprivileged) i **UXN / PXN** bitove za execute-never restrikcije.
- Kada je PSTATE.PAN = 1 (omogućен), hardver sprovodi izmenjena semantika: privileged pristupi stranicama označenim kao „accessible by EL0“ (tj. user-accessible) su zabranjeni (fault).
- Zbog pomenutog buga, stranice koje su označene samo kao izvršne (bez prava čitanja) možda se ne računaju kao „accessible by EL0“ u određenim implementacijama, čime se PAN može zaobići.
- Kada je PXN bita postavljena na stranici, čak i ako dolazi zahtev za instrukciju sa višeg privilegovanog nivoa, izvršavanje je zabranjeno.

#### Kernel upotreba PAN / PXN u hardened OS-u (npr. iOS / XNU)

U dizajnu ojačanog kernela (kako to Apple može koristiti):

- Kernel podrazumevano omogućava PAN (tako da je privileged kod ograničen).
- U putanjama koje legitimno moraju da čitaju ili pišu user buffere (npr. copy iz/za syscall buffer, I/O, read/write user pointer), kernel privremeno **isključi PAN** ili koristi specijalne instrukcije da ga nadjača.
- Nakon završetka pristupa korisničkim podacima, mora ponovo da omogući PAN.
- PXN se sprovodi putem page tabela: user stranice imaju PXN = 1 (tako kernel ne može da ih izvrši), kernel stranice nemaju PXN (tako kernel kod može da se izvrši).
- Kernel mora da osigura da nijedan kod-put ne dovodi do izvršavanja u user memorijskim regionima (što bi zaobišlo PXN) — tako exploit lanci koji zavise od „skoka u user-controlled shellcode“ su blokirani.

Zbog pomenutog PAN bypass-a preko execute-only stranica, u realnom sistemu Apple može onemogućiti ili zabrinuti execute-only user stranice, ili zakrpeti specifikacionu slabost.

#### Površine napada, bypass-i i mitigacije

- **PAN bypass preko execute-only stranica**: kao što je diskutovano, specifikacija dozvoljava prazninu: user stranice sa execute-only (bez read perm) možda neće računati kao „accessible at EL0,“ tako da PAN neće blokirati kernel read iz takvih stranica u nekim implementacijama. Ovo daje napadaču neobičan put da ubaci podatke kroz execute-only sekcije.
- **Temporal window exploit**: ako kernel onemogući PAN na prozor duži nego što je potrebno, race ili zlonamerni put može iskoristiti taj prozor za izvođenje neželjenog user memory access-a.
- **Zaboravljeno ponovo omogućavanje**: ako kodne putanje ne ponovo uključe PAN, naredne kernel operacije mogu pogrešno pristupati korisničkoj memoriji.
- **Pogrešna konfiguracija PXN**: ako page tabele ne postave PXN na user stranicama ili pogrešno mapiraju user kod stranice, kernel može biti prevaren da izvrši user-space kod.
- **Spekulacija / side-channels**: analožno spekulativnim bypass-ovima, mogu postojati mikroarhitekturni sporedni efekti koji dovode do transientnog kršenja PAN / PXN provera (iako su takvi napadi veoma zavisni od dizajna CPU-a).
- **Kompleksne interakcije**: U naprednijim funkcijama (npr. JIT, shared memory, just-in-time code regioni), kernel može zahtevati finu kontrolu da dozvoli određene memorijske pristupe ili izvršavanje u user-mapiranim regionima; dizajniranje toga bezbedno pod PAN/PXN ograničenjima nije trivijalno.

#### Primer

<details>
<summary>Primer koda</summary>
Evo ilustrativnih pseudo-assembly sekvenci koje prikazuju uključivanje/isključivanje PAN oko pristupa korisničkoj memoriji, i kako greška može nastati.
</details>
```  
// Suppose kernel entry point, PAN is enabled (privileged code cannot access user memory by default)

; Kernel receives a syscall with user pointer in X0
; wants to read an integer from user space
mov   X1, X0        ; X1 = user pointer

; disable PAN to allow privileged access to user memory
MSR   PSTATE.PAN, #0   ; clear PAN bit, disabling the restriction

ldr   W2, [X1]       ; now allowed load from user address

; re-enable PAN before doing other kernel logic
MSR   PSTATE.PAN, #1   ; set PAN

; ... further kernel work ...

; Later, suppose an exploit corrupts a pointer to a user-space code page and jumps there
BR    X3             ; branch to X3 (which points into user memory)

; Because the target page is marked PXN = 1 for privileged execution,
; the CPU throws an exception (fault) and rejects execution
```
Ako kernel nije postavio PXN na tu user page, tada grana može uspeti — što bi bilo nesigurno.

Ako kernel zaboravi da ponovo omogući PAN nakon pristupa user memory, otvara se prozor u kome dalja kernel logika može slučajno da čita/pisuje proizvoljnu user memoriju.

Ako user pointer pokazuje na execute-only page (user page sa samo execute dozvolom, bez read/write), pod PAN spec bug-om, `ldr W2, [X1]` možda **neće** prijaviti grešku čak i sa PAN omogućenim, omogućavajući bypass exploit, zavisno od implementacije.

</details>

<details>
<summary>Example</summary>
A kernel vulnerability pokušava da uzme user-provided function pointer i pozove ga u kernel kontekstu (tj. `call user_buffer`). Pod PAN/PXN, ta operacija je zabranjena ili će se raspasti sa fault-om.
</details>

---

### 11. **Top Byte Ignore (TBI) / Pointer Tagging**
**Introduced in ARMv8.5 / newer (or optional extension)**
TBI znači da je top byte (najznačajniji bajt) 64-bit pointera ignorisan pri address translation. Ovo omogućava OS-u ili hardveru da ugradi **tag bits** u top byte pointera bez uticaja na stvarnu adresu.

- TBI stands for **Top Byte Ignore** (ponekad nazivan *Address Tagging*). To je hardware feature (dostupna u mnogim ARMv8+ implementacijama) koja **ignoriše top 8 bitova** (bitove 63:56) 64-bit pointera pri izvođenju **address translation / load/store / instruction fetch**.
- U praksi, CPU tretira pointer `0xTTxxxx_xxxx_xxxx` (gde je `TT` = top byte) kao `0x00xxxx_xxxx_xxxx` za potrebe address translation, ignorišući (maskirajući) top byte. Top byte može softveru služiti za čuvanje **metadata / tag bits**.
- Ovo daje softveru “besplatan” in-band prostor da ugradi jedan bajt taga u svaki pointer bez promene koje memorijske lokacije pointer referencira.
- Arhitektura obezbeđuje da load, store i instruction fetch tretiraju pointer sa top bytom maskiranim (tj. tag uklonjenim) pre nego što izvrše stvarni memory access.

Tako TBI odvaja **logical pointer** (pointer + tag) od **physical address** koja se koristi za memorijske operacije.

#### Why TBI: Use cases and motivation

- **Pointer tagging / metadata**: Možete čuvati dodatne metadata (npr. object type, version, bounds, integrity tags) u tom top byte-u. Kada kasnije koristite pointer, tag se na nivou hardvera ignoriše, pa nije neophodno ručno skidanje pre pristupa memoriji.
- **Memory tagging / MTE (Memory Tagging Extension)**: TBI je osnovni hardware mehanizam na kome se gradi MTE. U ARMv8.5, **Memory Tagging Extension** koristi bitove 59:56 pointera kao **logical tag** i proverava ih protiv **allocation tag** koji je smešten u memoriji.
- **Enhanced security & integrity**: Kombinovanjem TBI sa pointer authentication (PAC) ili runtime proverama, možete zahtevati da ne bude tačan samo pointer vrednost nego i tag. Napadač koji prepiše pointer bez ispravnog taga će proizvesti mismatch tag.
- **Compatibility**: Pošto je TBI opciona i hardver ignoriše tag bitove, postojeći netagovani kod nastavlja da radi normalno. Tag bitovi efektivno postaju “don't care” bitovi za legacy kod.

#### Example
<details>
<summary>Example</summary>
Function pointer je sadržao tag u svom top byte-u (recimo `0xAA`). Exploit prepisuje niže bitove pointera ali zaboravlja tag, pa kada kernel verifikuje ili sanitizuje, pointer ne prođe ili bude odbijen.
</details>

---

### 12. **Page Protection Layer (PPL)**
**Introduced in late iOS / modern hardware (iOS ~17 / Apple silicon / high-end models)** (some reports show PPL circa macOS / Apple silicon, but Apple is bringing analogous protections to iOS)

- PPL je dizajniran kao intra-kernel protection boundary: čak i ako je kernel (EL1) kompromitovan i ima read/write mogućnosti, **ne bi trebalo da može slobodno da menja** određene **osetljive stranice** (posebno page tables, code-signing metadata, kernel code pages, entitlements, trust caches, itd.).
- Efektivno stvara **“kernel unutar kernela”** — manju trusted komponentu (PPL) sa **elevated privileges** koja sama može da menja protected pages. Ostali kernel kod mora da pozove PPL routine da bi izvršio promene.
- Ovo smanjuje attack surface za kernel exploite: čak i sa punim arbitrary R/W/execute u kernel modu, exploit kod mora nekako da uđe u PPL domen (ili da zaobiđe PPL) da bi menjao kritične strukture.
- Na novijem Apple silicon-u (A15+ / M2+), Apple prelazi na **SPTM (Secure Page Table Monitor)**, koji u mnogim slučajevima zamenjuje PPL za page-table zaštitu na tim platformama.

Evo kako se veruje da PPL radi, zasnovano na javnoj analizi:

#### Use of APRR / permission routing (APRR = Access Permission ReRouting)

- Apple hardware koristi mehanizam nazvan **APRR (Access Permission ReRouting)**, koji omogućava da page table entries (PTEs) sadrže male indekse, umesto punih permission bitova. Ti indeksi se mapiraju preko APRR registara na stvarne dozvole. Ovo omogućava dinamičko remapping dozvola po domain-u.
- PPL koristi APRR da separiše privilegije unutar kernel konteksta: samo PPL domen ima pravo da ažurira mapiranje između indeksa i efektivnih dozvola. To jest, kada non-PPL kernel kod piše PTE ili pokušava da promeni permission bitove, APRR logika to onemogućava (ili nameće read-only mapiranje).
- PPL kod sam radi u ograničenom regionu (npr. `__PPLTEXT`) koji je normalno non-executable ili non-writable dok entry gates privremeno ne dozvole pristup. Kernel poziva PPL entry points (“PPL routines”) da izvrši osetljive operacije.

#### Gate / Entry & Exit

- Kada kernel treba da menja zaštićenu stranicu (npr. promeni dozvole kernel code page-a, ili modifikuje page tables), poziva PPL wrapper routine koja radi validaciju i zatim prelazi u PPL domen. Izvan tog domena, protected pages su efektivno read-only ili non-modifiable od strane glavnog kernela.
- Tokom PPL entry, APRR mapiranja se podešavaju tako da su memory pages u PPL regionu postavljene na **executable & writable** unutar PPL. Nakon izlaska, vraćaju se na read-only / non-writable. Ovo osigurava da samo dobro revidirane PPL rutine mogu da pišu u protected pages.
- Izvan PPL, pokušaji kernel koda da piše u te zaštićene stranice će fault-ovati (permission denied) jer APRR mapping za taj code domain ne dozvoljava pisanje.

#### Protected page categories

Stranice koje PPL tipično štiti uključuju:

- Page table strukture (translation table entries, mapping metadata)
- Kernel code pages, posebno one koje sadrže kritičnu logiku
- Code-sign metadata (trust caches, signature blobs)
- Entitlement tables, signature enforcement tables
- Druge high-value kernel strukture gde bi patch omogućio zaobilaženje signature checks ili manipulaciju credential-ima

Ideja je da čak i ako je kernel memory potpuno kontrolisana, napadač ne može jednostavno da patch-uje ili prepiše ove stranice, osim ako ne kompromituje PPL routines ili ne zaobiđe PPL.


#### Known Bypasses & Vulnerabilities

1. **Project Zero’s PPL bypass (stale TLB trick)**

- Javna analiza od Project Zero opisuje bypass koji uključuje **stale TLB entries**.
- Ideja:

1. Alocirajte dve physical stranice A i B, označite ih kao PPL pages (tako da su protected).
2. Mapirajte dve virtualne adrese P i Q čije L3 translation table stranice potiču iz A i B.
3. Pokrenite thread koji kontinuirano pristupa Q, držeći njegov TLB entry živim.
4. Pozovite `pmap_remove_options()` da uklonite mapping-e počevši od P; zbog buga, kod greškom uklanja TTEs za oba, P i Q, ali invaliadira TLB entry samo za P, ostavljajući Q-ov stale entry živim.
5. Ponovo iskoristite B (stranicu tablice Q) da mapirate proizvoljnu memoriju (npr. PPL-protected pages). Pošto stale TLB entry i dalje mapira Q-ovo staro mapiranje, to mapiranje ostaje validno za taj kontekst.
6. Kroz ovo, napadač može postaviti writable mapping PPL-protected pages bez korišćenja PPL interfejsa.

- Ovaj exploit zahteva finu kontrolu physical mapping-a i TLB ponašanja. Demonstrira da security boundary koji zavisi od TLB / mapping korektnosti mora biti izuzetno pažljiv oko TLB invalidacija i konzistentnosti mapiranja.

- Project Zero je napomenuo da su takvi bypass-ovi suptilni i retki, ali mogući u kompleksnim sistemima. Ipak, smatraju PPL solidnom mitigacijom.

2. **Other potential hazards & constraints**

- Ako kernel exploit može direktno da uđe u PPL routines (pozivanjem PPL wrapper-a), može zaobići restrikcije. Zbog toga je validacija argumenata kritična.
- Bugovi u samom PPL kodu (npr. arithmetic overflow, provere granica) mogu omogućiti out-of-bounds modifikacije unutar PPL. Project Zero je uočio da je takav bug u `pmap_remove_options_internal()` iskorišćen u njihovom bypass-u.
- PPL granica je nerevokabilno vezana za hardware enforcement (APRR, memory controller), tako da je jaka koliko i implementacija hardvera.

#### Example
<details>
<summary>Code Example</summary>
Here’s a simplified pseudocode / logic showing how a kernel might call into PPL to modify protected pages:
```c
// In kernel (outside PPL domain)
function kernel_modify_pptable(pt_addr, new_entry) {
// validate arguments, etc.
return ppl_call_modify(pt_addr, new_entry)  // call PPL wrapper
}

// In PPL (trusted domain)
function ppl_call_modify(pt_addr, new_entry) {
// temporarily enable write access to protected pages (via APRR adjustments)
aprr_set_index_for_write(PPL_INDEX)
// perform the modification
*pt_addr = new_entry
// restore permissions (make pages read-only again)
aprr_restore_default()
return success
}

// If kernel code outside PPL does:
*pt_addr = new_entry  // a direct write
// It will fault because APRR mapping for non-PPL domain disallows write to that page
```
Kernel može da izvrši mnogo normalnih operacija, ali samo kroz `ppl_call_*` rutine može da menja zaštićene mape ili zakrpi kod.
</details>

<details>
<summary>Primer</summary>
Kernel exploit pokušava da prepiše tabelu entitlements, ili da onemogući primenu code-sign provere tako što menja kernel signature blob. Pošto je ta stranica zaštićena PPL-om, zapisivanje je blokirano osim ako se ne ide preko PPL interfejsa. Dakle, čak i sa izvršenjem koda u kernelu, ne možete zaobići code-sign ograničenja ili proizvoljno menjati podatke o akreditivima.
Na iOS 17+ određeni uređaji koriste SPTM da dodatno izoluju PPL-om upravljane stranice.
</details>

#### PPL → SPTM / Zamene / Budućnost

- Na Apple-ovim modernim SoC-ovima (A15 ili noviji, M2 ili noviji), Apple podržava **SPTM** (Secure Page Table Monitor), koji **zamenjuje PPL** za zaštitu page table-a.
- Apple u dokumentaciji navodi: “Page Protection Layer (PPL) and Secure Page Table Monitor (SPTM) enforce execution of signed and trusted code … PPL manages the page table permission overrides … Secure Page Table Monitor replaces PPL on supported platforms.”
- Arhitektura SPTM verovatno premešta veću primenu politika u monitor sa višim privilegijama izvan kontrole kernela, dodatno smanjujući granicu poverenja.

### MTE | EMTE | MIE

Evo opisa na višem nivou kako EMTE funkcioniše u Apple-ovom MIE okruženju:

1. **Dodela taga**
- Kada se memorija alocira (npr. u kernelu ili user space-u preko secure allocators), dodeljuje se **tajni tag** tom bloku.
- Pokazivač koji se vraća korisniku ili kernelu uključuje taj tag u svojim visokim bitovima (koristeći TBI / top byte ignore mehanizme).

2. **Provera taga pri pristupu**
- Kad god se izvrši load ili store koristeći pokazivač, hardver proverava da li tag pokazivača odgovara tagu memorijskog bloka (allocation tag). Ako se ne poklapaju, javlja se fault odmah (pošto je sinhrono).
- Pošto je sinhrono, ne postoji prozor za “delayed detection”.

3. **Ponovno označavanje pri free / reuse**
- Kada se memorija oslobodi, allocator menja tag bloka (tako da stariji pokazivači sa starim tagovima više ne odgovaraju).
- Use-after-free pokazivač će zato imati zastareo tag i biće mismatch pri pristupu.

4. **Razlikovanje tagova suseda da bi se uhvatili overflows**
- Susedne alokacije dobijaju različite tagove. Ako buffer overflow prelije u memoriju suseda, tag mismatch izaziva fault.
- Ovo je posebno efikasno za detekciju malih overflow-a koji prelaze granicu.

5. **Sprovodjenje poverljivosti tagova**
- Apple mora sprečiti da vrednosti tagova budu leaked (jer ako attacker sazna tag, mogao bi da kreira pokazivače sa odgovarajućim tagovima).
- Uključuju zaštite (microarchitectural / speculative controls) da bi izbegli side-channel leakage bitova taga.

6. **Integracija kernela i user-space-a**
- Apple koristi EMTE ne samo u user-space-u već i u kernelu / OS-critical komponentama (da zaštiti kernel od memory corruption).
- Hardver/OS osigurava da se pravila taga primenjuju čak i kada kernel izvršava u ime user space-a.

<details>
<summary>Primer</summary>
```
Allocate A = 0x1000, assign tag T1
Allocate B = 0x2000, assign tag T2

// pointer P points into A with tag T1
P = (T1 << 56) | 0x1000

// Valid store
*(P + offset) = value // tag T1 matches allocation → allowed

// Overflow attempt: P’ = P + size_of_A (into B region)
*(P' + delta) = value
→ pointer includes tag T1 but memory block has tag T2 → mismatch → fault

// Free A, allocator retags it to T3
free(A)

// Use-after-free:
*(P) = value
→ pointer still has old tag T1, memory region is now T3 → mismatch → fault
```
</details>

#### Limitations & challenges

- **Intrablock overflows**: Ako overflow ostane unutar iste alokacije (ne pređe granicu) i tag ostane isti, tag mismatch ga neće detektovati.
- **Tag width limitation**: Dostupno je samo nekoliko bitova za tag (npr. 4 bita, ili mali domen) — ograničen namespace.
- **Side-channel leaks**: Ako se tag bits mogu leak-ovati (putem cache / speculative execution), napadač može saznati validne tage i zaobići zaštitu. Apple-ova primena tag confidentiality enforcement-a ima za cilj da ovo ublaži.
- **Performance overhead**: Provere taga pri svakom load/store dodaju trošak; Apple mora optimizovati hardware da bi smanjio overhead.
- **Compatibility & fallback**: Na starijem hardveru ili delovima koji ne podržavaju EMTE mora postojati fallback. Apple tvrdi da je MIE omogućeno samo na uređajima koji podržavaju tu funkciju.
- **Complex allocator logic**: Allocator mora da upravlja tag-ovima, retagging-om, poravnavanjem granica i da izbegne kolizije pogrešnih tag-ova. Bagovi u logici allocatora mogu uvesti ranjivosti.
- **Mixed memory / hybrid areas**: Deo memorije može ostati untagged (legacy), što otežava interoperabilnost.
- **Speculative / transient attacks**: Kao i kod mnogih mikroarhitekturnih zaštita, speculative execution ili micro-op fuzije mogu privremeno zaobići provere ili leak-ovati tag bits.
- **Limited to supported regions**: Apple može primenjivati EMTE samo u selektivnim, visokorizičnim oblastima (kernel, security-critical subsystems), a ne univerzalno.

---

## Key enhancements / differences compared to standard MTE

Here are the improvements and changes Apple emphasizes:

| Feature | Original MTE | EMTE (Apple’s enhanced) / MIE |
|---|---|---|
| **Check mode** | Supports synchronous and asynchronous modes. In async, tag mismatches are reported later (delayed)| Apple insists on **synchronous mode** by default—tag mismatches are caught immediately, no delay/race windows allowed.|
| **Coverage of non-tagged memory** | Accesses to non-tagged memory (e.g. globals) may bypass checks in some implementations | EMTE requires that accesses from a tagged region to non-tagged memory also validate tag knowledge, making it harder to bypass by mixing allocations.|
| **Tag confidentiality / secrecy** | Tags might be observable or leaked via side channels | Apple adds **Tag Confidentiality Enforcement**, which attempts to prevent leakage of tag values (via speculative side-channels etc.).|
| **Allocator integration & retagging** | MTE leaves much of allocator logic to software | Apple’s secure typed allocators (kalloc_type, xzone malloc, etc.) integrate with EMTE: when memory is allocated or freed, tags are managed at fine granularity.|
| **Always-on by default** | In many platforms, MTE is optional or off by default | Apple enables EMTE / MIE by default on supported hardware (e.g. iPhone 17 / A19) for kernel and many user processes.|

Because Apple controls both the hardware and software stack, it can enforce EMTE tightly, avoid performance pitfalls, and close side-channel holes.

---

## How EMTE works in practice (Apple / MIE)

Here’s a higher-level description of how EMTE operates under Apple’s MIE setup:

1. **Tag assignment**
- When memory is allocated (e.g. in kernel or user space via secure allocators), a **secret tag** is assigned to that block.
- The pointer returned to the user or kernel includes that tag in its high bits (using TBI / top byte ignore mechanisms).

2. **Tag checking on access**
- Whenever a load or store is executed using a pointer, the hardware checks that the pointer’s tag matches the memory block’s tag (allocation tag). If mismatch, it faults immediately (since synchronous).
- Because it's synchronous, there is no “delayed detection” window.

3. **Retagging on free / reuse**
- When memory is freed, the allocator changes the block’s tag (so older pointers with old tags no longer match).
- A use-after-free pointer would therefore have a stale tag and mismatch when accessed.

4. **Neighbor-tag differentiation to catch overflows**
- Adjacent allocations are given distinct tags. If a buffer overflow spills into neighbor’s memory, tag mismatch causes a fault.
- This is especially powerful in catching small overflows that cross boundary.

5. **Tag confidentiality enforcement**
- Apple must prevent tag values being leaked (because if attacker learns the tag, they could craft pointers with correct tags).
- They include protections (microarchitectural / speculative controls) to avoid side-channel leakage of tag bits.

6. **Kernel and user-space integration**
- Apple uses EMTE not just in user-space but also in kernel / OS-critical components (to guard kernel against memory corruption).
- The hardware/OS ensures tag rules apply even when kernel is executing on behalf of user space.

Because EMTE is built into MIE, Apple uses EMTE in synchronous mode across key attack surfaces, not as opt-in or debugging mode.

---

## Exception handling in XNU

When an **exception** occurs (e.g., `EXC_BAD_ACCESS`, `EXC_BAD_INSTRUCTION`, `EXC_CRASH`, `EXC_ARM_PAC`, etc.), the **Mach layer** of the XNU kernel is responsible for intercepting it before it becomes a UNIX-style **signal** (like `SIGSEGV`, `SIGBUS`, `SIGILL`, ...).

This process involves multiple layers of exception propagation and handling before reaching user space or being converted to a BSD signal.

### Exception Flow (High-Level)

1.  **CPU triggers a synchronous exception** (e.g., invalid pointer dereference, PAC failure, illegal instruction, etc.).

2.  **Low-level trap handler** runs (`trap.c`, `exception.c` in XNU source).

3.  The trap handler calls **`exception_triage()`**, the core of the Mach exception handling.

4.  `exception_triage()` decides how to route the exception:

-   First to the **thread's exception port**.

-   Then to the **task's exception port**.

-   Then to the **host's exception port** (often `launchd` or `ReportCrash`).

If none of these ports handle the exception, the kernel may:

-   **Convert it into a BSD signal** (for user-space processes).

-   **Panic** (for kernel-space exceptions).

### Core Function: `exception_triage()`

The function `exception_triage()` routes Mach exceptions up the chain of possible handlers until one handles it or until it's finally fatal. It's defined in `osfmk/kern/exception.c`.
```c
void exception_triage(exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt);
```
**Tipični tok poziva:**

`exception_triage()
└── exception_deliver()
├── exception_deliver_thread()
├── exception_deliver_task()
└── exception_deliver_host()`

Ako sve zakaže → obrađuje ih `bsd_exception()` → prevodi ih u signal poput `SIGSEGV`.


### Portovi izuzetaka

Svaki Mach objekat (thread, task, host) može registrovati **portove izuzetaka**, na koje se šalju poruke o izuzecima.

Definisani su API-jem:
```
task_set_exception_ports()
thread_set_exception_ports()
host_set_exception_ports()
```
Svaki exception port ima:

-   A **mask** (koje exception-e želi da prima)
-   A **port name** (Mach port koji prima poruke)
-   A **behavior** (kako kernel šalje poruku)
-   A **flavor** (koji thread state da uključi)


### Debuggers and Exception Handling

A **debugger** (npr. LLDB) postavlja **exception port** na target task ili thread, obično koristeći `task_set_exception_ports()`.

**Kada se dogodi exception:**

-   Mach poruka se šalje debugger procesu.
-   Debugger može odlučiti da **obradi** (resume, modifikuje registre, preskoči instrukciju) ili **ne obradi** exception.
-   Ako debugger ne obradi, exception se propagira na sledeći nivo (task → host).


### Flow of `EXC_BAD_ACCESS`

1.  Thread dereferencira invalid pointer → CPU podiže Data Abort.

2.  Kernel trap handler poziva `exception_triage(EXC_BAD_ACCESS, ...)`.

3.  Poruka se šalje na:

-   Thread port → (debugger može da presretne breakpoint).

-   Ako debugger ignoriše → Task port → (process-level handler).

-   Ako se ignoriše → Host port (obično ReportCrash).

4.  Ako niko ne obradi → `bsd_exception()` prevodi u `SIGSEGV`.


### PAC Exceptions

Kada **Pointer Authentication** (PAC) zakaže (signature mismatch), podiže se **specijalan Mach exception**:

-   **`EXC_ARM_PAC`** (tip)
-   Codes mogu uključivati detalje (npr. tip ključa, tip pointer-a).

Ako binar ima flag **`TFRO_PAC_EXC_FATAL`**, kernel tretira PAC greške kao **fatalne**, zaobilaže debugger intercept. Ovo je da bi se sprečilo da napadači koriste debuggere za zaobilaženje PAC provera i omogućeno je za **platform binaries**.

### Software Breakpoints

Software breakpoint (`int3` na x86, `brk` na ARM64) se implementira tako što se **namerno izazove fault**.\
Debugger to presreće preko exception porta:

-   Modifikuje instruction pointer ili memory.
-   Vraća originalnu instrukciju.
-   Nastavlja izvršavanje.

Isti mehanizam omogućava da "uhvatite" PAC exception — **osim ako nije postavljen `TFRO_PAC_EXC_FATAL`**, u kom slučaju nikada ne stiže do debugger-a.


### Conversion to BSD Signals

Ako nijedan handler ne prihvati exception:

-   Kernel poziva `task_exception_notify() → bsd_exception()`.

-   Ovo mapira Mach exceptions na signal-e:

| Mach Exception | Signal |
| --- | --- |
| EXC_BAD_ACCESS | SIGSEGV or SIGBUS |
| EXC_BAD_INSTRUCTION | SIGILL |
| EXC_ARITHMETIC | SIGFPE |
| EXC_SOFTWARE | SIGTRAP |
| EXC_BREAKPOINT | SIGTRAP |
| EXC_CRASH | SIGKILL |
| EXC_ARM_PAC | SIGILL (on non-fatal) |


### Key Files in XNU Source

-   `osfmk/kern/exception.c` → Core of `exception_triage()`, `exception_deliver_*()`.

-   `bsd/kern/kern_sig.c` → Signal delivery logic.

-   `osfmk/arm64/trap.c` → Low-level trap handlers.

-   `osfmk/mach/exc.h` → Exception codes and structures.

-   `osfmk/kern/task.c` → Task exception port setup.

---

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

Kernel je koristio **zone allocator** (`kalloc`) podeljen na zone fiksnih veličina.  
Svaka zona čuva alokacije samo jedne size class.

Iz screenshot-a:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Very small kernel structs, pointers.                                        |
| `default.kalloc.32`  | 32 bytes     | Small structs, object headers.                                              |
| `default.kalloc.64`  | 64 bytes     | IPC messages, tiny kernel buffers.                                          |
| `default.kalloc.128` | 128 bytes    | Medium objects like parts of `OSObject`.                                    |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Large structures, IOSurface/graphics metadata.                              |

**Kako je radilo:**
- Svaki zahtev za alokaciju se **zaokruži nagore** na najbližu zone veličinu.
(Npr. zahtev od 50 bajtova ide u `kalloc.64` zonu).
- Memorija u svakoj zoni se držala u **freelist-u** — chunk-ovi koje kernel oslobodi vraćali su se nazad u tu zonu.
- Ako bi prelio 64-bajtni buffer, prepisao bi **sledeći objekat u istoj zoni**.

Zbog toga su bile veoma efikasne tehnike kao što su **heap spraying / feng shui**: mogao si da predvidiš susedne objekte tako što bi sprejao alokacije iste size class.

### The freelist

U svakoj kalloc zoni, oslobođeni objekti se nisu vraćali direktno sistemu — otišli su u freelist, linked list dostupnih chunk-ova.

- Kada bi chunk bio oslobođen, kernel bi upisao pointer na početak tog chunka → adresu sledećeg slobodnog chunka u istoj zoni.

- Zona je držala HEAD pointer na prvi slobodan chunk.

- Alokacija je uvek koristila trenutni HEAD:

1. Pop HEAD (vrati tu memoriju pozivaocu).

2. Update HEAD = HEAD->next (smešteno u header-u oslobođenog chunka).

- Oslobađanje je guralo chunke nazad:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

Dakle freelist je jednostavno linked lista izgrađena unutar same oslobođene memorije.

Normalno stanje:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Eksploatacija freelist-a

Pošto prvih 8 bajtova free chunk-a predstavlja freelist pointer, napadač može da ga korumpira:

1. **Heap overflow** u susedni freed chunk → prepiše njegov “next” pointer.

2. **Use-after-free** write u freed object → prepiše njegov “next” pointer.

Zatim, pri sledećoj alokaciji te veličine:

- Allocator izbacuje korumpirani chunk.
- Sledi attacker-supplied “next” pointer.
- Vraća pointer na proizvoljnu memoriju, omogućavajući fake object primitives ili targeted overwrite.

Vizuelni primer freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
This freelist design made exploitation highly effective pre-hardening: predictable neighbors from heap sprays, raw pointer freelist links, and no type separation allowed attackers to escalate UAF/overflow bugs into arbitrary kernel memory control.

### Heap Grooming / Feng Shui
Cilj heap grooming-a je da se oblikuje layout heap-a tako da kada napadač okine overflow ili use-after-free, target (victim) objekat bude odmah pored objekta kontrolisanog od strane napadača.\
Na taj način, kada se desi korupcija memorije, napadač može pouzdano prepisati victim objekat sa kontrolisanim podacima.

**Koraci:**

1. Spray allocations (fill the holes)
- Vremenom, kernel heap se fragmentira: neke zone imaju rupe gde su stari objekti bili oslobođeni.
- Napadač prvo pravi veliki broj dummy alokacija da popuni te praznine, tako da heap postane „packed“ i predvidiv.

2. Force new pages
- Kada su rupe popunjene, sledeće alokacije moraju doći iz novih stranica dodatih u zonu.
- Sveže stranice znače da će objekti biti grupisani zajedno, a ne rasuti po staroj fragmentiranoj memoriji.
- To daje napadaču mnogo bolju kontrolu nad susedima.

3. Place attacker objects
- Napadač ponovo sprejuje, kreirajući veliki broj objekata koje kontroliše u tim novim stranicama.
- Ti objekti su predvidive veličine i pozicije (pošto svi pripadaju istoj zoni).

4. Free a controlled object (make a gap)
- Napadač namerno oslobodi jedan od svojih objekata.
- Time se stvara „rupe“ u heap-u koju će allocator kasnije ponovo upotrebiti za sledeću alokaciju te veličine.

5. Victim object lands in the hole
- Napadač izazove kernel da alocira victim objekat (onaj koji želi da korumpira).
- Pošto je rupa prvi dostupan slot u freelist-u, victim se postavlja tačno tamo gde je napadač prethodno oslobodio svoj objekat.

6. Overflow / UAF into victim
- Sada napadač ima kontrolisane objekte oko victima.
- Prelivanjem iz jednog od svojih objekata (ili ponovnim korišćenjem freed objekta), može pouzdano prepisati memorijska polja victima sa željenim vrednostima.

**Zašto ovo radi**:

- Zone allocator predictability: alokacije iste veličine uvek dolaze iz iste zone.
- Freelist behavior: nove alokacije ponovo koriste najskorije oslobođeni chunk prvi.
- Heap sprays: napadač popunjava memoriju sa predvidivim sadržajem i kontroliše layout.
- Krajnji rezultat: napadač kontroliše gde će victim objekat pasti i koji će podaci stajati pored njega.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple je ojačao allocator i učinio da je **heap grooming mnogo teži**:

### 1. From Classic kalloc to kalloc_type
- **Pre**: postojala je po jedna `kalloc.<size>` zona za svaku veličinsku klasu (16, 32, 64, … 1280, itd.). Bilo koji objekat te veličine bio je tamo → napadački objekti su mogli sedeti pored privilegovanih kernel objekata.
- **Sada**:
- Kernel objekti se alociraju iz **typed zones** (`kalloc_type`).
- Svaka vrsta objekta (npr. `ipc_port_t`, `task_t`, `OSString`, `OSData`) ima svoju sopstvenu zonu, čak i ako su iste veličine.
- Mapiranje između type ↔ zone se generiše iz **kalloc_type system** u vreme kompajliranja.

Napadač više ne može garantovati da kontrolisani podaci (`OSData`) završe pored osetljivih kernel objekata (`task_t`) iste veličine.

### 2. Slabs and Per-CPU Caches
- Heap je podeljen na **slabs** (stranice memorije izrezane u fiksno-veličinske chanke za tu zonu).
- Svaka zona ima **per-CPU cache** da smanji contention.
- Allocation path:
1. Pokušaj per-CPU cache.
2. Ako je prazan, uzmi sa global freelist-a.
3. Ako je freelist prazan, alociraj novi slab (jedna ili više stranica).
- **Prednost**: ova decentralizacija čini heap sprays manje determinističkim, pošto alokacije mogu biti zadovoljene iz cache-a raznih CPU-a.

### 3. Randomization inside zones
- Unutar zone, oslobođeni elementi se ne vraćaju nazad jednostavnim FIFO/LIFO redosledom.
- Moderni XNU koristi **encoded freelist pointers** (safe-linking poput Linux-a, uvedeno ~iOS 14).
- Svaki freelist pointer je **XOR-ovan** sa per-zone tajnom cookie-jem.
- Ovo sprečava napadače da falsifikuju lažni freelist pointer ako dobiju write primitive.
- Neke alokacije su **randomizovane u svom položaju unutar slaba**, tako da spray ne garantuje susedstvo.

### 4. Guarded Allocations
- Određeni kritični kernel objekti (npr. credentials, task strukture) se alociraju u **guarded zones**.
- Te zone ubacuju **guard pages** (nemapirane stranice) između slab-ova ili koriste **redzones** oko objekata.
- Bilo koji overflow u guard page izaziva fault → momentalni panic umesto tihog korumpiranja.

### 5. Page Protection Layer (PPL) and SPTM
- Čak i ako kontrolišete freed objekat, ne možete menjati svu kernel memoriju:
- **PPL (Page Protection Layer)** primenjuje da su određene oblasti (npr. code signing data, entitlements) **read-only** čak i za sam kernel.
- Na **A15/M2+ uređajima**, tu ulogu zamenjuju/pojačavaju **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- Ove hardware-enforced slojeve znače da napadači ne mogu eskalirati iz jedne heap korupcije u proizvoljno patch-ovanje kritičnih security struktura.
- **(Dodato / Pojačano)**: takođe, **PAC (Pointer Authentication Codes)** se koristi u kernelu da zaštiti pokazivače (posebno function pointers, vtables) tako da njihovo falsifikovanje ili korumpiranje postane teže.
- **(Dodato / Pojačano)**: zone mogu sprovesti **zone_require / zone enforcement**, tj. da objekat koji je oslobođen može biti vraćen samo kroz svoju ispravnu typed zonu; nevažeći cross-zone free može izazvati panic ili biti odbijen. (Apple aludira na ovo u svojim postovima o memory safety)

### 6. Large Allocations
- Ne idu sve alokacije kroz `kalloc_type`.
- Veći zahtevi (iznad ~16 KB) zaobilaze typed zone i služe se direktno iz **kernel VM (kmem)** preko page alokacija.
- Ove su manje predvidive, ali takođe manje eksploatisane, jer ne dele slab-ove sa drugim objektima.

### 7. Allocation Patterns Attackers Target
Čak i sa ovim zaštitama, napadači i dalje traže:
- **Reference count objects**: ako možete manipulisati retain/release brojačima, možete izazvati use-after-free.
- **Objects with function pointers (vtables)**: korumpovanje jednog i dalje može dovesti do kontrolisanja flow-a.
- **Shared memory objects (IOSurface, Mach ports)**: i dalje su mete jer predstavljaju bridge između user ↔ kernel.

Ali — za razliku od ranije — više ne možete jednostavno sprejovati `OSData` i očekivati da bude pored `task_t`. Potrebni su **type-specific bugs** ili **info leaks** da bi uspeh bio moguć.

### Example: Allocation Flow in Modern Heap

Pretpostavimo da userspace pozove IOKit da alocira `OSData` objekat:

1. **Type lookup** → `OSData` mapira na `kalloc_type_osdata` zonu (size 64 bytes).
2. Provera per-CPU cache-a za slobodne elemente.
- Ako nađeno → vrati jedan.
- Ako je prazan → idi na global freelist.
- Ako je freelist prazan → alociraj novi slab (page od 4KB → 64 chanka od po 64 bytes).
3. Vrati chunk caller-u.

**Freelist pointer protection**:
- Svaki freed chunk čuva adresu sledećeg free chanka, ali enkodovanu sa secret key-jem.
- Overwriting tog polja sa napadačkim podacima neće raditi osim ako ne znate key.

---

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages, and **PAC** protects pointers |
| Allocation reuse validation     | None (freelist pointers raw)                               | **zone_require / zone enforcement**             |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |
| Large allocations handling      | All small allocations managed equally                       | Large ones bypass zones → handled via VM         |

---

## Modern Userland Heap (iOS, macOS — type-aware / xzone malloc)

U novijim Apple OS verzijama (posebno iOS 17+), Apple je uveo sigurniji userland allocator, **xzone malloc** (XZM). Ovo je user-space analog kernel-ovog `kalloc_type`, primenjujući type awareness, metadata isolation i memory tagging zaštite.

### Goals & Design Principles

- **Type segregation / type awareness**: grupisati alokacije po tipu ili upotrebi (pointer vs data) da se spreči type confusion i cross-type reuse.
- **Metadata isolation**: odvojiti heap metadata (npr. free lists, size/state bitovi) od payload-a objekata tako da out-of-bounds write manje verovatno korumpira metadata.
- **Guard pages / redzones**: ubaciti nemapirane stranice ili padding oko alokacija da se uhvate overflows.
- **Memory tagging (EMTE / MIE)**: raditi u kombinaciji sa hardware tagging-om da detektuje use-after-free, out-of-bounds i nevalidne pristupe.
- **Scalable performance**: održavati nizak overhead, izbeći preteranu fragmentaciju i podržati veliki broj alokacija po sekundi sa niskom latencijom.

### Architecture & Components

Ispod su glavni elementi xzone allocatora:

#### Segment Groups & Zones

- **Segment groups** particionišu address space po kategorijama upotrebe: npr. `data`, `pointer_xzones`, `data_large`, `pointer_large`.
- Svaka segment group sadrži **segments** (VM opsege) koji hostuju alokacije za tu kategoriju.
- Povezan sa svakim segmentom je **metadata slab** (odvojena VM oblast) koja čuva metadata (npr. free/used bitove, size klase) za taj segment. Ova **out-of-line (OOL) metadata** osigurava da metadata nije pomešana sa payload-om objekata, smanjujući rizik od korupcije usled overflows.
- Segmenti se seku na **chunks** (slice-ove) koji zauzvrat se dele na **blocks** (alokacione jedinice). Chunk je vezan za specifičnu size klasu i segment group (tj. svi block-ovi u chunk-u dele istu veličinu & kategoriju).
- Za male/srednje alokacije koristi fiksno-veličinske chunks; za velike/ogromne može mapirati zasebno.

#### Chunks & Blocks

- **Chunk** je region (često nekoliko stranica) posvećen alokacijama jedne size klase unutar grupe.
- Unutar chunka, **blocks** su slotovi dostupni za alokacije. Freed block-ovi se prate putem metadata slab-a — npr. preko bitmapa ili free list-ova smeštenih out-of-line.
- Između chunk-ova (ili unutar) mogu biti ubačeni **guard slices / guard pages** (npr. nemapirane sekcije) da uhvate out-of-bounds write-ove.

#### Type / Type ID

- Svaki allocation site (ili poziv malloc, calloc, itd.) je povezan sa **type identifier-om** (`malloc_type_id_t`) koji kodira kakav tip objekta se alocira. Taj type ID se prosleđuje allocator-u, koji ga koristi da izabere koju zonu / segment da posluži.
- Zbog toga, čak i ako dve alokacije imaju istu veličinu, mogu ići u potpuno različite zone ako im tipovi nisu isti.
- U ranim iOS 17 verzijama, nisu svi API-ji (npr. CFAllocator) bili potpuno type-aware; Apple je adresirao neke od tih slabosti u iOS 18.

---

### Allocation & Freeing Workflow

Evo high-level toka kako alokacija i dealokacija funkcionišu u xzone:

1. **malloc / calloc / realloc / typed alloc** se poziva sa veličinom i type ID-jem.
2. Allocator koristi **type ID** da izabere odgovarajući segment group / zonu.
3. Unutar te zone/segmenta, traži chunk koji ima slobodne block-ove tražene veličine.
- Može konzultovati **local caches / per-thread pools** ili **free block lists** iz metadata.
- Ako nema slobodnog block-a, može alocirati novi chunk u toj zoni.
4. Metadata slab se ažurira (free bit se briše, bookkeeping).
5. Ako je memory tagging (EMTE) u igri, vraćenom block-u se dodeljuje **tag**, i metadata se ažurira da odrazi njegovo „live“ stanje.
6. Kada se pozove `free()`:
- Block se označi kao freed u metadata (putem OOL slab-a).
- Block može biti smešten u free list ili pooled za ponovnu upotrebu.
- Opcionalno, sadržaj block-a može biti očišćen ili poisoned da se smanji podatak-leak ili iskorišćenost UAF.
- Hardverski tag povezan sa block-om može biti invalidiran ili re-tagovan.
- Ako ceo chunk postane slobodan (svi block-ovi oslobođeni), allocator može **reclaim** taj chunk (unmap-ovati ga ili vratiti OS-u) pod memorijskim pritiskom.

---

### Security Features & Hardening

Ovo su odbrane ugrađene u moderni userland xzone:

| Feature | Purpose | Notes |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | Prevent overflow from corrupting metadata | Metadata živi u odvojenoj VM regiji (metadata slab)|
| **Guard pages / unmapped slices** | Catch out-of-bounds writes | Pomaže da se detektuju buffer overflows umesto da tiho korumpiraju susedne blokove|
| **Type-based segregation** | Prevent cross-type reuse & type confusion | Čak i iste-size alokacije iz različitih tipova idu u različite zone|
| **Memory Tagging (EMTE / MIE)** | Detect invalid access, stale references, OOB, UAF | xzone radi u saradnji sa hardware EMTE u synchronous modu (“Memory Integrity Enforcement”)|
| **Delayed reuse / poisoning / zap** | Reduce chance of use-after-free exploitation | Freed block-ovi mogu biti poisoned, zeroed, ili karantinisani pre ponovnog korišćenja |
| **Chunk reclamation / dynamic unmapping** | Reduce memory waste and fragmentation | Celi chunk-ovi mogu biti unmap-ovani kada su neiskorišćeni |
| **Randomization / placement variation** | Prevent deterministic adjacency | Block-ovi u chunk-u i izbor chunk-a mogu imati randomizovane aspekte |
| **Segregation of “data-only” allocations** | Separate allocations that don’t store pointers | Smanjuje napadačevu kontrolu nad metadata ili kontrolnim poljima|

---

### Interaction with Memory Integrity Enforcement (MIE / EMTE)

- Apple-ov MIE (Memory Integrity Enforcement) je hardware + OS framework koji uvodi **Enhanced Memory Tagging Extension (EMTE)** u always-on, synchronous mod preko glavnih attack surface-a.
- xzone allocator je fundamentalna osnova MIE u user space-u: alokacije preko xzone dobijaju tagove, a pristupi se proveravaju hardware-om.
- U MIE, allocator, dodela tagova, upravljanje metadata-om i sprovođenje tajnosti tagova su integrisani da osiguraju da greške u memoriji (npr. stale reads, OOB, UAF) budu uhvaćene momentalno, a ne iskorišćene kasnije.

---

If you like, I can also generate a cheat-sheet or diagram of xzone internals for your book. Do you want me to do that next?
::contentReference[oai:20]{index=20}


---

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and install it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


## JSKit-Based Safari Chains and PREYHUNTER Stagers

### Renderer RCE abstraction with JSKit
- **Reusable entry**: Recent in-the-wild chains abused a WebKit JIT bug (patched as CVE-2023-41993) purely to gain JavaScript-level arbitrary read/write. The exploit immediately pivots into a purchased framework called **JSKit**, so any future Safari bug only needs to deliver the same primitive.
- **Version abstraction & PAC bypasses**: JSKit bundles support for a wide range of iOS releases together with multiple, selectable Pointer Authentication Code bypass modules. The framework fingerprints the target build, selects the appropriate PAC bypass logic, and verifies every step (primitive validation, shellcode launch) before progressing.
- **Manual Mach-O mapping**: JSKit parses Mach-O headers directly from memory, resolves the symbols it needs inside dyld-cached images, and can manually map additional Mach-O payloads without writing them to disk. This keeps the renderer process in-memory only and evades code-signature checks tied to filesystem artifacts.
- **Portfolio model**: Debug strings such as *"exploit number 7"* show that the suppliers maintain multiple interchangeable WebKit exploits. Once the JS primitive matches JSKit’s interface, the rest of the chain is unchanged across campaigns.

### Kernel bridge: IPC UAF -> code-sign bypass pattern
- **Kernel IPC UAF (CVE-2023-41992)**: The second stage, still running inside the Safari context, triggers a kernel use-after-free in IPC code, re-allocates the freed object from userland, and abuses the dangling pointers to pivot into arbitrary kernel read/write. The stage also reuses PAC bypass material previously computed by JSKit instead of re-deriving it.
- **Code-signing bypass (CVE-2023-41991)**: With kernel R/W available, the exploit patches the trust cache / code-signing structures so unsigned payloads execute as `system`. The stage then exposes a lightweight kernel R/W service to later payloads.
- **Composed pattern**: This chain demonstrates a reusable recipe that defenders should expect going forward:
```
WebKit renderer RCE -> kernel IPC UAF -> kernel arbitrary R/W -> code-sign bypass -> unsigned system stager
```
### PREYHUNTER helper & watcher modules
- **Watcher anti-analysis**: Posvećen watcher binarni fajl kontinuirano profilira uređaj i prekida kill-chain kada se detektuje istraživačko okruženje. Pregledava `security.mac.amfi.developer_mode_status`, prisustvo `diagnosticd` konzole, lokalizacije `US` ili `IL`, tragove jailbreak-a kao što je **Cydia**, procese kao `bash`, `tcpdump`, `frida`, `sshd`, ili `checkrain`, mobilne AV aplikacije (McAfee, AvastMobileSecurity, NortonMobileSecurity), prilagođena HTTP proxy podešavanja i prilagođene root CAs. Ako bilo koja provera ne uspe, blokira dalju isporuku payload-a.
- **Helper surveillance hooks**: Helper komponenta komunicira sa ostalim fazama preko `/tmp/helper.sock`, zatim učitava setove hook-ova nazvane **DMHooker** i **UMHooker**. Ovi hook-ovi presreću VOIP audio puteve (snimci se čuvaju pod `/private/var/tmp/l/voip_%lu_%u_PART.m4a`), implementiraju sistemski keylogger, prave fotografije bez UI, i hook-uju SpringBoard kako bi potisnuli notifikacije koje bi te akcije inače izazvale. Helper tako deluje kao prikriveni sloj za validaciju i lagani nadzor pre nego što se ubace teži implantati poput Predator.

### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

## References

- [Google Threat Intelligence – Intellexa zero-day exploits continue](https://cloud.google.com/blog/topics/threat-intelligence/intellexa-zero-day-exploits-continue)

{{#include ../../banners/hacktricks-training.md}}
