# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

### 1. **Code Signing** / Runtime Signature Verification
**Introduced early (iPhone OS → iOS)**
这是基本的防护之一：**所有可执行代码**（应用、dynamic libraries、JIT-ed code、extensions、frameworks、caches）必须由以 Apple 信任为根的证书链进行加密签名。在运行时，在将二进制加载到内存之前（或在跨某些边界执行跳转之前），系统会检查其签名。如果代码被修改（bit-flipped、patched）或未签名，加载将失败。

- **Thwarts**: the “classic payload drop + execute” stage in exploit chains; arbitrary code injection; modifying an existing binary to insert malicious logic.
- **Mechanism detail**:
* Mach-O loader（以及 dynamic linker）会检查代码页、segments、entitlements、team IDs，并验证签名覆盖文件内容。
* 对于像 JIT caches 或动态生成的代码这样的内存区域，Apple 强制要求页面被签名或通过特殊 API 验证（例如使用带有 code-sign 检查的 `mprotect`）。
* 签名包括 entitlements 和标识符；OS 会强制要求某些 API 或特权能力需要特定的 entitlements，这些无法伪造。

<details>
<summary>Example</summary>
假设一次 exploit 在一个进程内获得了 code execution 并尝试把 shellcode 写入 heap 并跳转到它。在 iOS 上，该页面需要被标记为 executable **且** 满足 code-signature 约束。因为 shellcode 没有用 Apple 的证书签名，跳转会失败或系统会拒绝将该内存区域设为可执行。
</details>


### 2. **CoreTrust**
**Introduced around iOS 14+ era (or gradually in newer devices / later iOS)**
CoreTrust 是在运行时对二进制进行签名验证的子系统（包括系统和用户二进制），它针对的是 Apple 的 root certificate，而不是依赖本地缓存的 userland trust stores。

- **Thwarts**: post-install tampering of binaries, jailbreaking techniques that try to swap or patch system libraries or user apps; tricking the system by replacing trusted binaries with malicious counterparts.
- **Mechanism detail**:
* CoreTrust 不依赖于本地 trust database 或证书缓存，它直接引用或验证指向 Apple root 的证书链或中间证书。
* 它确保检测并拒绝对已有二进制的修改（例如文件系统中的篡改）。
* 它在加载时将 entitlements、team IDs、code signing flags 和其他元数据与二进制绑定起来。

<details>
<summary>Example</summary>
一个 jailbreak 可能尝试替换 `SpringBoard` 或 `libsystem` 为补丁版本以获得持久化。但当 OS 的 loader 或 CoreTrust 检查时，会注意到签名不匹配（或 entitlements 被修改），并拒绝执行。
</details>


### 3. **Data Execution Prevention (DEP / NX / W^X)**
**Introduced in many OSes earlier; iOS had NX-bit / w^x for a long time**
DEP 强制要求标为 writable（数据）的页面为非可执行，标为 executable 的页面为不可写。你不能简单地把 shellcode 写入 heap 或 stack 然后执行它。

- **Thwarts**: direct shellcode execution; classic buffer-overflow → jump to injected shellcode.
- **Mechanism detail**:
* MMU / memory protection flags（通过 page tables）强制执行这种分离。
* 任何试图将可写页面标记为可执行的行为会触发系统检查（要么被禁止，要么需要 code-sign 批准）。
* 在许多情况下，使页面可执行需要通过 OS 的 API，并强制执行额外的约束或检查。

<details>
<summary>Example</summary>
一次 overflow 将 shellcode 写到 heap。攻击者尝试 `mprotect(heap_addr, size, PROT_EXEC)` 使其可执行。但系统会拒绝或验证新页面必须通过 code-sign 约束（shellcode 无法通过）。
</details>

### 4. **Address Space Layout Randomization (ASLR)**
**Introduced in iOS ~4–5 era (roughly iOS 4–5 timeframe)**
ASLR 在每次进程启动时随机化关键内存区域的基址：libraries、heap、stack 等。gadgets 的地址在不同运行间会移动。

- **Thwarts**: hardcoding gadget addresses for ROP/JOP; static exploit chains; blind jumping to known offsets.
- **Mechanism detail**:
* 每个加载的库 / dynamic module 都会被 rebased 到随机偏移。
* stack 和 heap 的基址被随机化（在一定熵限制内）。
* 有时其他区域（例如 mmap 分配）也被随机化。
* 与信息泄露缓解结合，它迫使攻击者先 leak 一个地址或指针以在运行时发现基址。

<details>
<summary>Example</summary>
一个 ROP 链期待 gadget 在 `0x….lib + offset`。但因为 `lib` 在每次运行时会被重新定位，硬编码的链会失败。exploit 必须先泄露模块的基地址，然后再计算 gadget 地址。
</details>


### 5. **Kernel Address Space Layout Randomization (KASLR)**
**Introduced in iOS ~ (iOS 5 / iOS 6 timeframe)**
类比用户态 ASLR，KASLR 在每次引导时对 kernel text 和其他内核结构的基址进行随机化。

- **Thwarts**: kernel-level exploits that rely on fixed location of kernel code or data; static kernel exploits.
- **Mechanism detail**:
* 每次启动时，kernel 的基地址会被随机化（在一个范围内）。
* 内核数据结构（如 `task_structs`、`vm_map` 等）也可能被重新定位或偏移。
* 攻击者必须先泄露内核指针或利用信息泄露漏洞来计算偏移，才能在内核中劫持结构或代码。

<details>
<summary>Example</summary>
一个本地漏洞企图破坏一个内核函数指针（例如在 `vtable` 中）位于 `KERN_BASE + offset`。但因为 `KERN_BASE` 未知，攻击者必须先泄露它（例如通过 read primitive）才能计算正确的破坏地址。
</details>


### 6. **Kernel Patch Protection (KPP / AMCC)**
**Introduced in newer iOS / A-series hardware (post around iOS 15–16 era or newer chips)**
KPP（又名 AMCC）持续监控内核 text 页的完整性（通过 hash 或 checksum）。如果检测到 tampering（补丁、inline hooks、代码修改）且不在允许的时间窗口内，它会触发 kernel panic 或重启。

- **Thwarts**: persistent kernel patching (modifying kernel instructions), inline hooks, static function overwrites.
- **Mechanism detail**:
* 一个硬件或固件模块监控 kernel text 区域。
* 它周期性或按需对页面进行 re-hash 并与预期值比较。
* 如果发生不在良性更新窗口内的不匹配，它会 panic 设备（以避免持久化的恶意补丁）。
* 攻击者必须要么避开检测窗口，要么走合法的 patch 路径。

<details>
<summary>Example</summary>
一个 exploit 试图 patch 一个内核函数的 prologue（例如 `memcmp`）以拦截调用。但 KPP 注意到代码页的 hash 不再匹配预期值并触发 kernel panic，使设备在补丁稳定之前崩溃。
</details>


### 7. **Kernel Text Read‐Only Region (KTRR)**
**Introduced in modern SoCs (post ~A12 / newer hardware)**
KTRR 是硬件强制的机制：在引导早期一旦 kernel text 被锁定，它从 EL1（内核）变为只读，防止对代码页的后续写入。

- **Thwarts**: any modifications to kernel code after boot (e.g. patching, in-place code injection) at EL1 privilege level.
- **Mechanism detail**:
* 在引导期间（secure/bootloader 阶段），memory controller（或安全硬件单元）将包含 kernel text 的物理页面标记为只读。
* 即便 exploit 获得了完整的内核权限，也无法写入这些页面来 patch 指令。
* 要修改它们，攻击者必须先破坏引导链或攻破 KTRR 本身。

<details>
<summary>Example</summary>
一个提权 exploit 跳入 EL1 并尝试在内核函数（例如 syscall handler）中写入 trampoline。但由于页面被 KTRR 锁定为只读，写入会失败或触发 fault，因此无法应用补丁。
</details>


### 8. **Pointer Authentication Codes (PAC)**
**Introduced with ARMv8.3 (hardware), Apple beginning with A12 / iOS ~12+**
- PAC 是在 **ARMv8.3-A** 中引入的硬件特性，用于检测指针值（返回地址、函数指针、某些数据指针）被篡改的情况，通过将一个小的加密签名（“MAC”）嵌入到指针的未使用高位中。
- 该签名（“PAC”）是基于指针值加上一个 **modifier**（上下文值，例如 stack pointer 或某些区分性数据）计算的。这样相同的指针值在不同上下文下会得到不同的 PAC。
- 在使用时，在对该指针进行解引用或通过该指针分支之前，**authenticate** 指令会检查 PAC。如果有效，PAC 会被剥离，得到纯指针；如果无效，指针会被“poisoned”（或引发 fault）。
- 用于生成/验证 PAC 的密钥存放在特权寄存器（EL1、kernel）中，用户态无法直接读取。
- 因为在许多系统中并非全部 64 位指针都被使用（例如 48-bit 地址空间），上位位是“空闲”的，可以在不影响有效地址的情况下存放 PAC。

#### Architectural Basis & Key Types

- ARMv8.3 引入了 **五个 128-bit 密钥**（每个通过两个 64-bit 系统寄存器实现）用于 pointer authentication。
- **APIAKey** — 针对 instruction pointers（域 “I”，key A）
- **APIBKey** — 第二个 instruction pointer key（域 “I”，key B）
- **APDAKey** — 针对 data pointers（域 “D”，key A）
- **APDBKey** — 针对 data pointers（域 “D”，key B）
- **APGAKey** — “generic” key，用于对非指针数据或其他通用用途进行签名

- 这些密钥存储在特权系统寄存器中（仅在 EL1/EL2 等可访问），用户态无法访问。
- PAC 是通过一个加密函数（ARM 推荐使用 QARMA 作为算法）计算的，输入包括：
1. 指针值（规范化部分）
2. 一个 **modifier**（上下文值，如 salt）
3. 秘钥
4. 一些内部的 tweak 逻辑
如果生成的 PAC 与存储在指针高位的值匹配，则认证成功。


#### Instruction Families

命名约定是：**PAC** / **AUT** / **XPAC**，然后跟域字母。
- `PACxx` 指令用于 **签名** 一个指针并插入 PAC
- `AUTxx` 指令用于 **认证 + 剥离**（验证并移除 PAC）
- `XPACxx` 指令用于 **剥离** 而不验证

Domains / suffixes:

| Mnemonic     | Meaning / Domain                      | Key / Domain     | Example Usage in Assembly |
|--------------|-----------------------------------------|--------------------|-----------------------------|
| **PACIA**    | Sign instruction pointer with APIAKey   | “I, A”             | `PACIA X0, X1` — sign pointer in X0 using APIAKey with modifier X1|
| **PACIB**    | Sign instruction pointer with APIBKey   | “I, B”             | `PACIB X2, X3`              |
| **PACDA**    | Sign data pointer with APDAKey           | “D, A”             | `PACDA X4, X5`              |
| **PACDB**    | Sign data pointer with APDBKey           | “D, B”             | `PACDB X6, X7`              |
| **PACG / PACGA** | Generic (non-pointer) signing with APGAKey | “G”         | `PACGA X8, X9, X10` (sign X9 with modifier X10 into X8) |
| **AUTIA**    | Authenticate APIA-signed instruction pointer & strip PAC | “I, A” | `AUTIA X0, X1` — check PAC on X0 using modifier X1, then strip |
| **AUTIB**    | Authenticate APIB domain                 | “I, B”             | `AUTIB X2, X3`               |
| **AUTDA**    | Authenticate APDA-signed data pointer    | “D, A”             | `AUTDA X4, X5`               |
| **AUTDB**    | Authenticate APDB-signed data pointer    | “D, B”             | `AUTDB X6, X7`               |
| **AUTGA**    | Authenticate generic / blob (APGA)        | “G”               | `AUTGA X8, X9, X10` (validate generic) |
| **XPACI**     | Strip PAC (instruction pointer, no validation) | “I”         | `XPACI X0` — remove PAC from X0 (instruction domain) |
| **XPACD**     | Strip PAC (data pointer, no validation)    | “D”             | `XPACD X4` — remove PAC from data pointer in X4 |


有一些专门化 / 别名形式：

- `PACIASP` 是 `PACIA X30, SP` 的速写（使用 SP 作为 modifier 对 link register 进行签名）
- `AUTIASP` 是 `AUTIA X30, SP`（用 SP 对 link register 进行认证）
- 在 ARM 扩展 / 编译器支持中也存在组合形式如 `RETAA`、`RETAB`（authenticate-and-return）或 `BLRAA`（authenticate & branch）。
- 还有零 modifier 的变体：`PACIZA` / `PACIZB`，其中 modifier 隐式为零，等等。

#### Modifiers

modifier 的主要目标是将 PAC **绑定到特定上下文**，因此相同地址在不同上下文签名会得到不同的 PAC。这防止了简单的指针跨帧或对象复用。它类似于对哈希添加 salt。

因此：
- **modifier** 是一个上下文值（另一个寄存器），会混入 PAC 的计算。常见选择：stack pointer（SP）、frame pointer，或某个对象 ID。
- 使用 SP 作为 modifier 对返回地址签名是常见的：PAC 会与特定栈帧绑定。如果尝试在不同帧中重用 LR，modifier 会变化导致 PAC 校验失败。
- 相同的指针值在不同 modifier 下会产生不同的 PAC。
- modifier 不需要是机密的，但理想情况下它不应由攻击者控制。
- 对于那些没有有意义 modifier 的签名/验证情形，有些形式会使用零或隐式常量。

#### Apple / iOS / XNU Customizations & Observations

- Apple 的 PAC 实现包含 **每次启动的 diversifiers**，使得密钥或 tweak 在每次启动时变化，防止跨启动的重用。
- 他们还包含 **跨域缓解**，使得在 user mode 签名的 PAC 不容易在 kernel mode 中重用等。
- 在 Apple M1 / Apple Silicon 的逆向中发现 Apple 有 **九种 modifier 类型** 和 Apple 特有的控制密钥的系统寄存器。
- Apple 在很多内核子系统中使用 PAC：返回地址签名、内核数据的指针完整性、签名的线程上下文等。
- Google Project Zero 展示了在有强大内存读/写 primitive 的内核环境下，如何在 A12 时代设备上伪造 kernel PAC（针对 A keys），但 Apple 修补了许多这些路径。
- 在 Apple 的系统中，某些密钥是 **跨内核全局的**，而用户进程可能会获得每个进程的 key 随机性。

#### PAC Bypasses

1. **Kernel-mode PAC: theoretical vs real bypasses**

-   因为 kernel PAC 的密钥和逻辑受严格控制（特权寄存器、diversifiers、域隔离），伪造任意签名的 kernel 指针非常困难。
-   Azad 在 2020 年的 "iOS Kernel PAC, One Year Later" 报告中提到，在 iOS 12-13 中，他发现了一些部分绕过（signing gadgets、重用已签名状态、未受保护的间接分支），但没有发现完全通用的 bypass。 [bazad.github.io](https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf)
-   Apple 的“Dark Magic”定制进一步收窄了可被利用的面（域切换、每-key 的启用位）。 [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   已知存在一个 **kernel PAC bypass CVE-2023-32424** 在 Apple silicon（M1/M2）上，由 Zecao Cai 等人报告。 [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   但这些 bypass 往往依赖非常具体的 gadgets 或实现 bug；它们并非通用绕过方法。

因此 kernel PAC 被认为是 **高度健壮** 的，尽管并非完美无缺。

2. **User-mode / runtime PAC bypass techniques**

这些更常见，并且利用 PAC 在 dynamic linking / runtime frameworks 中应用不完善的地方。下面列出几类及示例。

2.1 **Shared Cache / A key issues**

-   dyld shared cache 是一个预链接的大块系统 frameworks 和 libraries。因为它被广泛共享，shared cache 内的函数指针是“预先签名”的，并被许多进程使用。攻击者会把这些已签名指针当作 “PAC oracles” 来利用。
-   有些 bypass 技术尝试提取或重用 shared cache 中已用 A-key 签名的指针并重用于 gadgets。
-   “No Clicks Required” 的演讲描述了如何在 shared cache 上构建一个 oracle 来推断相对地址，并结合已签名指针来绕过 PAC。 [saelo.github.io](https://saelo.github.io/presentations/offensivecon_20_no_clicks.pdf)
-   另外，用户态中来自 shared libraries 的函数指针导入曾被发现未被 PAC 充分保护，允许攻击者在不改变签名的情况下获取函数指针。（Project Zero 的 bug 条目） [bugs.chromium.org](https://bugs.chromium.org/p/project-zero/issues/detail?id=2044&utm_source=chatgpt.com)

2.2 **dlsym(3) / dynamic symbol resolution**

-   一个已知的 bypass 是调用 `dlsym()` 来获取一个 *已经签名的* 函数指针（用 A-key 签名，diversifier 为零），然后直接使用它。因为 `dlsym` 返回的是合法签名的指针，使用它可以规避伪造 PAC 的需要。
-   Epsilon 的博客详细说明了一些 bypass 如何利用这一点：调用 `dlsym("someSym")` 会产生一个签名指针并可用于间接调用。 [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)
-   Synacktiv 的 “iOS 18.4 --- dlsym considered harmful” 描述了一个 bug：iOS 18.4 上某些通过 `dlsym` 解析的符号返回了错误签名（或有缺陷的 diversifier），导致非预期的 PAC bypass。 [Synacktiv](https://www.synacktiv.com/en/publications/ios-184-dlsym-considered-harmful)
-   dyld 中 `dlsym` 的逻辑包括：当 `result->isCode` 时，它用 `__builtin_ptrauth_sign_unauthenticated(..., key_asia, 0)` 对返回指针进行签名，也就是上下文为零。 [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

因此，`dlsym` 是用户态 PAC bypass 的常见向量。

2.3 **Other DYLD / runtime relocations**

-   DYLD loader 和动态重定位逻辑很复杂，有时会将页面临时映射为 read/write 以执行重定位，然后再切回 read-only。攻击者利用这些时间窗口。Synacktiv 的演讲描述了“Operation Triangulation”，一种基于时序的通过动态重定位绕过 PAC 的方法。 [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)
-   DYLD 的页面现在受到 SPRR / VM_FLAGS_TPRO（一些针对 dyld 的保护标志）的保护。但早期版本的防护较弱。 [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)
-   在 WebKit exploit 链中，DYLD loader 常常是 PAC bypass 的目标。幻灯片提到许多 PAC bypass 针对 DYLD loader（通过重定位、interposer hooks）。 [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

2.4 **NSPredicate / NSExpression / ObjC / SLOP**

-   在用户态 exploit 链中，Objective-C runtime 的方法如 `NSPredicate`、`NSExpression` 或 `NSInvocation` 被用来在不明显伪造指针的情况下走控调用路径。
-   在旧的 iOS（PAC 出现之前），有 exploit 使用 **fake NSInvocation** 对象来对受控内存执行任意 selector。引入 PAC 后该方法需要调整。但 SLOP（SeLector Oriented Programming）技术在 PAC 下仍有扩展可能。 [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)
-   原始的 SLOP 技术通过创建伪造的 invocations 链接 ObjC 调用；绕过依赖于 ISA 或 selector 指针有时并未完全受 PAC 保护的事实。 [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)
-   在 pointer authentication 仅被部分应用的环境中，methods / selectors / target pointers 有时并未获得完整的 PAC 保护，从而提供了 bypass 的空间。

#### Example Flow

<details>
<summary>Example Signing & Authenticating</summary>
```
; Example: function prologue / return address protection
my_func:
stp x29, x30, [sp, #-0x20]!        ; push frame pointer + LR
mov x29, sp
PACIASP                            ; sign LR (x30) using SP as modifier
; … body …
mov sp, x29
ldp x29, x30, [sp], #0x20         ; restore
AUTIASP                            ; authenticate & strip PAC
ret

; Example: indirect function pointer stored in a struct
; suppose X1 contains a function pointer
PACDA X1, X2     ; sign data pointer X1 with context X2
STR X1, [X0]      ; store signed pointer

; later retrieval:
LDR X1, [X0]
AUTDA X1, X2       ; authenticate & strip
BLR X1             ; branch to valid target

; Example: stripping for comparison (unsafe)
LDR X1, [X0]
XPACI X1           ; strip PAC (instruction domain)
CMP X1, #some_label_address
BEQ matched_label
```
</details>

<details>
<summary>Example</summary>
A buffer overflow overwrites a return address on the stack. The attacker writes the target gadget address but cannot compute the correct PAC. When the function returns, the CPU’s `AUTIA` instruction faults because the PAC mismatch. The chain fails.
Project Zero’s analysis on A12 (iPhone XS) showed how Apple’s PAC is used and methods of forging PACs if an attacker has a memory read/write primitive.
</details>


### 9. **分支目标识别 (BTI)**
**Introduced with ARMv8.5 (later hardware)**
BTI 是一项硬件特性，用于检查 **间接分支目标**：当执行 `blr` 或间接调用/跳转时，目标必须以 **BTI landing pad**（`BTI j` 或 `BTI c`）开头。跳转到缺少 landing pad 的 gadget 地址会触发异常。

LLVM 的实现说明了三种 BTI 指令变体及其如何映射到不同的分支类型。

| BTI Variant | What it permits (which branch types) | Typical placement / use case |
|-------------|----------------------------------------|-------------------------------|
| **BTI C** | Targets of *call*-style indirect branches (e.g. `BLR`, or `BR` using X16/X17) | Put at entry of functions that may be called indirectly |
| **BTI J** | Targets of *jump*-style branches (e.g. `BR` used for tail calls) | Placed at the beginning of blocks reachable by jump tables or tail-calls |
| **BTI JC** | Acts as both C and J | Can be targeted by either call or jump branches |

- 在使用 branch target enforcement 编译的代码中，编译器会在每个有效的间接分支目标（函数开头或可被跳转到的基本块）插入 BTI 指令（C、J 或 JC），以确保间接分支只能成功到这些位置。
- **直接分支 / 调用**（即固定地址的 `B`, `BL`）**不受 BTI 限制**。假设代码页是可信的且攻击者无法修改它们（因此直接分支被认为是安全的）。
- 此外，**RET / return** 指令通常也不受 BTI 限制，因为返回地址通常通过 PAC 或返回签名机制得到保护。

#### 机制与强制执行

- 当 CPU 在被标记为“guarded / BTI-enabled”的页中解码到一个 **间接分支 (BLR / BR)** 时，它会检查目标地址的第一条指令是否为有效的 BTI（C、J 或 JC，视允许的类型而定）。如果不是，就会发生 **Branch Target Exception**。
- BTI 指令编码设计为重用先前为 NOPs 保留的 opcode（在早期 ARM 版本中）。因此在不支持 BTI 的硬件上，这些指令仍表现为 NOPs，使得 BTI-enabled 的二进制文件向后兼容。
- 添加 BTI 的编译器 pass 只在需要的位置插入：可能被间接调用的函数，或被跳转目标所达成的基本块。
- 一些补丁和 LLVM 代码表明 BTI 并不是插入到*所有*基本块 —— 仅插入到那些可能成为分支目标的块（例如来自 switch / jump table 的目标）。

#### BTI 与 PAC 的协同

PAC 保护指针值（源）——确保间接调用/返回链路没有被篡改。

BTI 确保即使指针有效，也只能指向被正确标记的入口点。

组合起来，攻击者需要同时满足：拥有带正确 PAC 的有效指针，并且目标位置必须放置 BTI。这样大幅增加了构造可用 exploit gadget 的难度。

#### Example


<details>
<summary>Example</summary>
An exploit tries to pivot into gadget at `0xABCDEF` that doesn’t start with `BTI c`. The CPU, upon executing `blr x0`, checks the target and faults because the instruction alignment doesn’t include a valid landing pad. Thus many gadgets become unusable unless they include BTI prefix.
</details>


### 10. **Privileged Access Never (PAN) & Privileged Execute Never (PXN)**
**Introduced in more recent ARMv8 extensions / iOS support (for hardened kernel)**

#### PAN (Privileged Access Never)

- **PAN** 是在 **ARMv8.1-A** 中引入的特性，防止 **特权代码**（EL1 或 EL2）在 PAN 未显式禁用的情况下**读取或写入**标记为 **user-accessible (EL0)** 的内存。
- 其目的是：即使内核被欺骗或被破坏，也不能在不先*清除* PAN 的情况下任意解引用用户空间指针，从而降低 `ret2usr` 风格漏洞或滥用用户控制缓冲区的风险。
- 当 PAN 启用（PSTATE.PAN = 1）时，任何特权的 load/store 指令访问一个“在 EL0 可访问”的虚拟地址都会触发 **权限错误**。
- 当内核确实需要合法访问用户空间内存（例如将数据复制到/从用户缓冲区），必须**临时禁用 PAN**（或使用“非特权 load/store”指令）以允许该访问。
- 在 ARM64 的 Linux 中，PAN 支持大约在 2015 年引入：内核补丁添加了该特性的检测，并用在访问用户内存前后清除 PAN 的变体来替换 `get_user` / `put_user` 等。

**关键细微差别 / 限制 / 错误**
- 如 Siguza 等人指出，ARM 规范中存在一个错误（或含糊行为），导致 **execute-only user mappings**（`--x`）可能**不会触发 PAN**。换言之，如果用户页被标记为可执行但没有读权限，内核的读取尝试可能会绕过 PAN，因为架构认为“在 EL0 可访问”需要可读权限，而不仅仅是可执行。这在某些实现中导致了 PAN 的绕过。
- 因此，如果 iOS / XNU 允许 execute-only 的用户页面（例如某些 JIT 或 code-cache 设置可能会如此），内核在 PAN 启用时可能仍会意外地从这些页面读取。这在某些 ARMv8+ 系统中是已知的可利用的细微问题。

#### PXN (Privileged eXecute Never)

- **PXN** 是页表标志（leaf 或 block 条目中的位），表示该页在特权模式下（即 EL1 执行时）**不可执行**。
- PXN 防止内核（或任何特权代码）跳入或执行来自用户空间页面的指令，即使控制流被劫持。实际上，它阻止了内核级别的控制流重定向到用户内存。
- 与 PAN 结合，可确保：
1. 内核默认不能读取或写入用户空间数据（PAN）
2. 内核不能执行用户空间代码（PXN）
- 在 ARMv8 的页表格式中，leaf 条目有 `PXN` 位（以及用于非特权的 `UXN`）在属性位中。

因此，哪怕内核有被破坏的函数指针指向用户内存，试图分支到那里的时候，PXN 位也会导致故障。

#### 内存权限模型 & PAN / PXN 如何映射到页表位

要理解 PAN / PXN 的工作，需要看 ARM 的映射与权限模型（简化）：

- 每个页或 block 条目都有属性字段，包括用于访问权限的 **AP[2:1]**（读/写、特权与非特权）以及用于执行限制的 **UXN / PXN** 位。
- 当 PSTATE.PAN = 1（启用）时，硬件强制执行修改后的语义：对标记为“EL0 可访问”的页面进行的特权访问会被拒绝（触发 fault）。
- 由于前述的规范问题，被仅标记为可执行（无读权限）的页面在某些实现中可能不被计为“EL0 可访问”，从而绕过 PAN。
- 当页面的 PXN 位被设置时，即使指令取自更高特权级，也会禁止执行。

#### 内核在 hardened OS（例如 iOS / XNU）中对 PAN / PXN 的使用

在一个加固的内核设计中（如 Apple 可能采用的设计）：

- 内核默认启用 PAN（因此特权代码受到约束）。
- 在那些合法需要读取或写入用户缓冲区的路径中（如 syscall 缓冲复制、I/O、读/写用户指针），内核会临时**禁用 PAN**或使用特殊指令来覆盖。
- 完成用户数据访问后，必须重新启用 PAN。
- PXN 通过页表强制：用户页面的 PXN = 1（因此内核无法在这些页上执行），内核页面没有 PXN（内核代码可执行）。
- 内核必须确保没有代码路径会导致执行流进入用户内存区域（那会绕过 PXN）——因此依赖于“跳转到用户控制的 shellcode”的 exploit 链被阻断。

鉴于通过 execute-only 页面可以绕过 PAN 的情况，实际系统中 Apple 可能会禁用或不允许 execute-only 的用户页面，或对该规范弱点进行修补。

#### 攻击面、绕过方式与缓解措施

- **PAN bypass via execute-only pages**: 如上所述，规范存在空档：如果用户页仅为 execute-only（无读权限），在某些实现中可能不会被视为“EL0 可访问”，因此 PAN 不会阻止内核从这些页读取。这为攻击者提供了一条通过 execute-only 段传输数据的非同寻常路径。
- **时间窗口攻击**：如果内核在比必要更长的时间内禁用 PAN，竞态或恶意路径可能利用该窗口进行未预期的用户内存访问。
- **忘记重新启用**：如果代码路径未能在后续重新启用 PAN，随后的内核操作可能会错误地访问用户内存。
- **PXN 配置错误**：如果页表未在用户页上设置 PXN，或错误地映射用户代码页，内核可能被诱导去执行用户空间代码。
- **投机/侧信道**：类似于投机执行绕过，可能存在微架构副作用导致 PAN / PXN 检查的短暂违规（尽管此类攻击高度依赖于具体 CPU 设计）。
- **复杂交互**：在更高级的功能（例如 JIT、共享内存、即时生成代码的区域）中，内核可能需要细粒度的控制以允许某些用户映射的内存访问或执行；在 PAN/PXN 约束下安全地设计这些路径并非易事。

#### Example

<details>
<summary>代码示例</summary>
Here are illustrative pseudo-assembly sequences showing enabling/disabling PAN around user memory access, and how a fault might occur.
```  
// Suppose kernel entry point, PAN is enabled (privileged code cannot access user memory by default)

; Kernel receives a syscall with user pointer in X0
; wants to read an integer from user space
mov   X1, X0        ; X1 = user pointer

; disable PAN to allow privileged access to user memory
MSR   PSTATE.PAN, #0   ; clear PAN bit, disabling the restriction

ldr   W2, [X1]       ; now allowed load from user address

; re-enable PAN before doing other kernel logic
MSR   PSTATE.PAN, #1   ; set PAN

; ... further kernel work ...

; Later, suppose an exploit corrupts a pointer to a user-space code page and jumps there
BR    X3             ; branch to X3 (which points into user memory)

; Because the target page is marked PXN = 1 for privileged execution,
; the CPU throws an exception (fault) and rejects execution
```
如果内核在该用户页面上**没有**设置 PXN，那么该分支可能会成功 —— 这将是不安全的。

如果内核在访问用户内存后忘记重新启用 PAN，就会打开一个窗口，后续的内核逻辑可能会意外地读取/写入任意用户内存。

如果用户指针指向一个 execute-only 页面（只有执行权限，没有读/写），在 PAN 规范的 bug 下，`ldr W2, [X1]` 可能即使在启用 PAN 的情况下也**不会**产生 fault，具体取决于实现，这会允许绕过利用。

</details>

<details>
<summary>Example</summary>
内核漏洞尝试获取一个由用户提供的函数指针并在内核上下文中调用它（即 `call user_buffer`）。在 PAN/PXN 下，该操作被禁止或会导致 fault。
</details>

---

### 11. **Top Byte Ignore (TBI) / Pointer Tagging**
**Introduced in ARMv8.5 / newer (or optional extension)**
TBI 意味着 64 位指针的最高字节在地址转换时被忽略。这允许 OS 或硬件在指针的最高字节中嵌入**标签位**，而不影响实际地址。

- TBI 表示 **Top Byte Ignore**（有时称为 *Address Tagging*）。它是一个硬件特性（在许多 ARMv8+ 实现中可用），在执行地址转换 / load/store / instruction fetch 时**忽略最高 8 位**（位 63:56）。
- 实际上，CPU 在进行地址转换时会把指针 `0xTTxxxx_xxxx_xxxx`（其中 `TT` = 最高字节）当作 `0x00xxxx_xxxx_xxxx` 来处理，忽略（屏蔽）最高字节。最高字节可以被软件用来存储**元数据 / tag bits**。
- 这为软件提供了“免费”的带内空间，可以在每个指针中嵌入一个字节的 tag，而不会改变它所指向的内存位置。
- 架构确保 load、store 和 instruction fetch 在执行实际内存访问前，会对指针的最高字节进行屏蔽（即去除 tag）。

因此 TBI 将**逻辑指针**（指针 + tag）与用于内存操作的**物理地址**解耦。

#### Why TBI: Use cases and motivation

- **Pointer tagging / metadata**：可以在最高字节中存储额外的元数据（例如对象类型、版本、边界、完整性标签）。当稍后使用指针时，硬件会忽略 tag，因此无需为内存访问手动去除它。
- **Memory tagging / MTE (Memory Tagging Extension)**：TBI 是 MTE 构建的基础硬件机制。在 ARMv8.5 中，**Memory Tagging Extension** 使用指针的位 59:56 作为**逻辑标签**，并将其与存储在内存中的**allocation tag** 进行检查。
- **增强的安全性与完整性**：将 TBI 与 pointer authentication (PAC) 或运行时检查结合，可以强制不仅指针值本身，而且 tag 也必须正确。攻击者在覆盖指针时如果没有正确的 tag 会导致标签不匹配。
- **兼容性**：由于 TBI 是可选的且标签位被硬件忽略，现有未标记的代码可以继续正常运行。对于遗留代码而言，标签位实际上成为“无关紧要”的位。

#### Example
<details>
<summary>Example</summary>
一个函数指针在其最高字节中包含了一个 tag（例如 `0xAA`）。一次利用覆盖了指针的低位但忽略了 tag，因此当内核校验或清理时，该指针因 tag 不匹配而失败或被拒绝。
</details>

---

### 12. **Page Protection Layer (PPL)**
**Introduced in late iOS / modern hardware (iOS ~17 / Apple silicon / high-end models)** (some reports show PPL circa macOS / Apple silicon, but Apple is bringing analogous protections to iOS)

- PPL 被设计为一个**内核内的保护边界**：即使内核 (EL1) 被攻破并具有读/写能力，**它也不应当能够自由地修改**某些**敏感页面**（尤其是页表、代码签名元数据、内核代码页、entitlements、trust caches 等）。
- 它实际上创建了一个“内核内的内核”——一个更小的受信任组件（PPL），只有它具有修改受保护页面的**提升权限**。其他内核代码必须调用 PPL 例程来进行修改。
- 这减少了内核利用的攻击面：即便拥有内核模式下的任意 R/W/execute，利用代码也必须以某种方式进入 PPL 域（或绕过 PPL）才能修改关键结构。
- 在较新的 Apple silicon（A15+ / M2+）上，Apple 正在转向 **SPTM (Secure Page Table Monitor)**，在许多情况下用以替代 PPL 对页表的保护。

下面是基于公开分析对 PPL 如何工作的信念说明：

#### Use of APRR / permission routing (APRR = Access Permission ReRouting)

- Apple 硬件使用一种叫做 **APRR (Access Permission ReRouting)** 的机制，允许页表项 (PTEs) 包含小的索引，而不是完整的权限位。这些索引通过 APRR 寄存器映射到实际权限。这允许按域动态重映射权限。
- PPL 利用 APRR 在内核上下文中隔离特权：只有 PPL 域被允许更新索引与实际生效权限之间的映射。也就是说，当非 PPL 的内核代码写入 PTE 或尝试翻转权限位时，APRR 逻辑会阻止它（或强制只读映射）。
- PPL 代码自身运行在一个受限区域（例如 `__PPLTEXT`），该区域在进入前通常是不可执行或不可写的，直到入口门暂时允许。内核必须调用 PPL 入口点（“PPL 例程”）来执行敏感操作。

#### Gate / Entry & Exit

- 当内核需要修改受保护页面（例如更改内核代码页的权限，或修改页表）时，它会调用一个 **PPL wrapper** 例程，该例程进行验证然后切换到 PPL 域。在该域之外，受保护的页面对主内核实际上是只读或不可修改的。
- 在 PPL 入口期间，APRR 映射会被调整，使 PPL 区域内的内存页面在 PPL 内被设置为**可执行且可写**。退出时，它们会被恢复为只读/不可写。这确保只有经过严格审核的 PPL 例程能够写入受保护页面。
- 在 PPL 之外，内核代码尝试写入那些受保护页面会导致 fault（权限被拒绝），因为对应代码域的 APRR 映射不允许写入。

#### Protected page categories

PPL 通常保护的页面包括：

- 页表结构（translation table entries、映射元数据）
- 内核代码页，特别是包含关键逻辑的那些页
- 代码签名元数据（trust caches、签名 blob）
- entitlement 表、签名强制表
- 其他高价值的内核结构，修改这些页面可以允许绕过签名检查或操纵凭证

其思路是：即便内核内存被完全控制，攻击者也不能简单地打补丁或重写这些页面，除非他们同时破坏 PPL 例程或绕过 PPL。

#### Known Bypasses & Vulnerabilities

1. **Project Zero’s PPL bypass (stale TLB trick)**

- Project Zero 的一篇公开报告描述了一个涉及**stale TLB entries** 的绕过方法。
- 其思路：

1. 分配两个物理页面 A 和 B，并将它们标记为 PPL 页面（因此受保护）。
2. 映射两个虚拟地址 P 和 Q，它们的 L3 translation table 页分别来自 A 和 B。
3. 启动一个线程持续访问 Q，以保持其 TLB 条目活跃。
4. 调用 `pmap_remove_options()` 来移除从 P 开始的映射；由于一个 bug，代码错误地移除了 P 和 Q 的 TTEs，但只对 P 失效了 TLB 条目，留下了 Q 的 stale 条目仍然存在。
5. 重新利用 B（Q 的表页）去映射任意内存（例如 PPL 受保护的页面）。因为 stale 的 TLB 条目仍然映射着 Q 的旧映射，该映射在该上下文中仍然有效。
6. 通过这种方式，攻击者可以在不通过 PPL 接口的情况下放置对 PPL 受保护页面的可写映射。

- 该利用需要对物理映射和 TLB 行为有精细控制。它表明依赖 TLB / 映射正确性的安全边界必须非常小心地处理 TLB 失效和映射一致性。
- Project Zero 评论认为此类绕过较为微妙且罕见，但在复杂系统中是可能的。尽管如此，他们仍认为 PPL 是一个可靠的缓解手段。

2. **Other potential hazards & constraints**

- 如果内核利用能够直接进入 PPL 例程（通过调用 PPL wrappers），则可能绕过限制。因此参数验证至关重要。
- PPL 代码本身的 bug（例如算术溢出、边界检查错误）可能允许在 PPL 内部进行越界修改。Project Zero 观察到 `pmap_remove_options_internal()` 中的此类 bug 被用于绕过。
- PPL 边界不可撤销地依赖于硬件强制（APRR、memory controller），因此其强度取决于硬件实现本身。

#### Example
<details>
<summary>Code Example</summary>
这里是一个简化的伪代码 / 逻辑，展示内核如何调用 PPL 来修改受保护页面：
</details>
```c
// In kernel (outside PPL domain)
function kernel_modify_pptable(pt_addr, new_entry) {
// validate arguments, etc.
return ppl_call_modify(pt_addr, new_entry)  // call PPL wrapper
}

// In PPL (trusted domain)
function ppl_call_modify(pt_addr, new_entry) {
// temporarily enable write access to protected pages (via APRR adjustments)
aprr_set_index_for_write(PPL_INDEX)
// perform the modification
*pt_addr = new_entry
// restore permissions (make pages read-only again)
aprr_restore_default()
return success
}

// If kernel code outside PPL does:
*pt_addr = new_entry  // a direct write
// It will fault because APRR mapping for non-PPL domain disallows write to that page
```
内核可以执行许多常规操作，但只有通过 `ppl_call_*` 例程才能更改受保护的映射或修补代码。
</details>

<details>
<summary>Example</summary>
内核漏洞利用会尝试覆盖 entitlement table，或通过修改 kernel signature blob 来禁用 code-sign enforcement。因为该页受到 PPL 保护，除非通过 PPL 接口，否则写入会被阻止。因此即使获得内核代码执行，也无法绕过 code-sign 限制或任意修改 credential 数据。在 iOS 17+，某些设备使用 SPTM 进一步隔离由 PPL 管理的页面。
</details>

#### PPL → SPTM / Replacements / Future

- 在 Apple 的现代 SoC（A15 或更高，M2 或更高）上，Apple 支持 **SPTM** (Secure Page Table Monitor)，它 **取代 PPL** 用于页面表保护。
- Apple 在文档中指出：“Page Protection Layer (PPL) and Secure Page Table Monitor (SPTM) enforce execution of signed and trusted code … PPL manages the page table permission overrides … Secure Page Table Monitor replaces PPL on supported platforms.”
- SPTM 架构很可能将更多策略强制移入一个位于内核控制之外的更高权限的监控器，从而进一步缩小信任边界。

### MTE | EMTE | MIE

下面是 EMTE 在 Apple 的 MIE 架构下运行的高级描述：

1. **标签分配**
- 当内存被分配（例如在内核或 user space 通过 secure allocators），该块会被分配一个 **secret tag**。
- 返回给用户或内核的指针在其高位包含该 tag（使用 TBI / top byte ignore 机制）。

2. **访问时的标签检查**
- 每当使用指针执行 load 或 store 时，硬件会检查指针的 tag 是否与内存块的 tag（allocation tag）匹配。若不匹配，会立即发生 fault（因为是同步的）。
- 由于这是同步的，不存在“延迟检测”窗口。

3. **释放/重用时的重新标记**
- 当内存被释放时，分配器会更改该块的 tag（因此带有旧 tag 的旧指针将不再匹配）。
- 因此，use-after-free 指针将具有过期的 tag，在访问时产生不匹配。

4. **邻近标签区分以捕获溢出**
- 相邻的分配会被赋予不同的 tags。如果 buffer overflow 溢出到邻近内存，tag 不匹配会导致 fault。
- 这对于捕获跨边界的小型溢出尤其有效。

5. **标签保密性强制**
- Apple 必须防止 tag 值被 leaked（因为如果攻击者得知 tag，他们可以构造带有正确 tags 的指针）。
- 他们包含保护（microarchitectural / speculative controls）以避免对 tag 位的 side-channel leakage。

6. **内核与用户空间的集成**
- Apple 不仅在 user-space 中使用 EMTE，也在内核/OS 关键组件中使用（用于保护内核免受内存损坏）。
- 硬件/OS 确保即便在内核代表 user space 执行时，tag 规则仍然生效。

<details>
<summary>Example</summary>
```
Allocate A = 0x1000, assign tag T1
Allocate B = 0x2000, assign tag T2

// pointer P points into A with tag T1
P = (T1 << 56) | 0x1000

// Valid store
*(P + offset) = value // tag T1 matches allocation → allowed

// Overflow attempt: P’ = P + size_of_A (into B region)
*(P' + delta) = value
→ pointer includes tag T1 but memory block has tag T2 → mismatch → fault

// Free A, allocator retags it to T3
free(A)

// Use-after-free:
*(P) = value
→ pointer still has old tag T1, memory region is now T3 → mismatch → fault
```
</details>

#### 限制与挑战

- **Intrablock overflows**: 如果 overflow 保留在同一分配内（未越界到相邻分配）且 tag 保持不变，tag mismatch 无法检测到它。
- **Tag width limitation**: 可用于 tag 的位数很少（例如 4 位或更小的域）——命名空间受限。
- **Side-channel leaks**: 如果 tag 位可以被 leak（通过 cache / speculative execution），攻击者可能会获取有效的 tags 并绕过检测。Apple 的 tag confidentiality enforcement 旨在缓解此问题。
- **Performance overhead**: 每次 load/store 的 tag 检查都会增加开销；Apple 必须优化硬件以将开销降到最低。
- **Compatibility & fallback**: 在旧硬件或不支持 EMTE 的部件上，必须有回退机制。Apple 声称 MIE 只在支持的设备上启用。
- **Complex allocator logic**: allocator 必须管理 tags、retagging、对齐边界，并避免 tag 冲突。allocator 逻辑中的 bugs 可能会引入漏洞。
- **Mixed memory / hybrid areas**: 部分内存可能仍然无 tag（legacy），这使得互操作性更复杂。
- **Speculative / transient attacks**: 与许多微架构防护一样，speculative execution 或 micro-op 融合可能会短暂绕过检查或 leak tag bits。
- **Limited to supported regions**: Apple 可能只在选择的高风险区域（kernel、security-critical 子系统）强制实施 EMTE，而非全域强制。

---

## 与标准 MTE 相比的关键增强/差异

以下是 Apple 强调的改进和变化：

| Feature | Original MTE | EMTE (Apple’s enhanced) / MIE |
|---|---|---|
| **Check mode** | Supports synchronous and asynchronous modes. In async, tag mismatches are reported later (delayed)| Apple insists on **synchronous mode** by default—tag mismatches are caught immediately, no delay/race windows allowed.|
| **Coverage of non-tagged memory** | Accesses to non-tagged memory (e.g. globals) may bypass checks in some implementations | EMTE requires that accesses from a tagged region to non-tagged memory also validate tag knowledge, making it harder to bypass by mixing allocations.|
| **Tag confidentiality / secrecy** | Tags might be observable or leaked via side channels | Apple adds **Tag Confidentiality Enforcement**, which attempts to prevent leakage of tag values (via speculative side-channels etc.).|
| **Allocator integration & retagging** | MTE leaves much of allocator logic to software | Apple’s secure typed allocators (kalloc_type, xzone malloc, etc.) integrate with EMTE: when memory is allocated or freed, tags are managed at fine granularity.|
| **Always-on by default** | In many platforms, MTE is optional or off by default | Apple enables EMTE / MIE by default on supported hardware (e.g. iPhone 17 / A19) for kernel and many user processes.|

因为 Apple 同时控制硬件和软件栈，它可以紧密地强制执行 EMTE，避免性能陷阱并修补 side-channel 孔洞。

---

## How EMTE works in practice (Apple / MIE)

下面是 Apple 在 MIE 设置下 EMTE 如何运作的高层描述：

1. **Tag assignment**
- 当内存被分配（例如在 kernel 或通过 secure allocators 在用户空间），会给该块分配一个 **secret tag**。
- 返回给用户或 kernel 的 pointer 在高位包含该 tag（使用 TBI / top byte ignore 机制）。

2. **Tag checking on access**
- 每当使用某个 pointer 执行 load 或 store 时，硬件会检查该 pointer 的 tag 是否与内存块的 tag（allocation tag）匹配。如果不匹配，会立即产生 fault（因为是 synchronous）。
- 由于是 synchronous，不存在“延迟检测”的窗口。

3. **Retagging on free / reuse**
- 当内存被 free 时，allocator 会更改该块的 tag（因此携带旧 tag 的指针将不再匹配）。
- 因此对 use-after-free 指针的访问会因 tag 过时而导致 mismatch。

4. **Neighbor-tag differentiation to catch overflows**
- 相邻分配会被赋予不同的 tags。如果 buffer overflow 溢出到相邻内存，tag mismatch 会导致 fault。
- 这在捕捉越过边界的小型 overflow 时尤其有效。

5. **Tag confidentiality enforcement**
- Apple 必须防止 tag 值被泄露（因为如果攻击者知道了 tag，就可以构造带有正确 tag 的指针）。
- 他们加入了保护（微架构 / speculative 控制）以避免通过 side-channel 泄露 tag bits。

6. **Kernel and user-space integration**
- Apple 不仅在用户空间使用 EMTE，也在 kernel / OS 关键组件中使用（以防护 kernel 免受内存破坏）。
- 硬件/OS 确保即便在 kernel 代表用户空间执行时，tag 规则也会被应用。

由于 EMTE 被内建到 MIE 中，Apple 在关键攻击面采用了同步模式的 EMTE，并非作为可选或调试模式。

---

## Exception handling in XNU

当发生 **exception**（例如 `EXC_BAD_ACCESS`, `EXC_BAD_INSTRUCTION`, `EXC_CRASH`, `EXC_ARM_PAC`, 等），XNU 的 **Mach layer** 负责在将其转为 UNIX 风格的 **signal**（如 `SIGSEGV`, `SIGBUS`, `SIGILL`, ...）之前拦截它。

这个过程涉及多个层次的异常传播与处理，最终才会到达用户空间或被转换为 BSD signal。

### Exception Flow (High-Level)

1.  **CPU triggers a synchronous exception**（例如无效指针解引用、PAC 失败、非法指令等）。

2.  **Low-level trap handler** 运行（在 XNU 源码的 `trap.c`, `exception.c` 中）。

3.  trap handler 调用 **`exception_triage()`**，这是 Mach 异常处理的核心。

4.  `exception_triage()` 决定如何路由该异常：

-   首先发送到 **thread 的 exception port**。

-   然后发送到 **task 的 exception port**。

-   然后发送到 **host 的 exception port**（通常是 `launchd` 或 `ReportCrash`）。

如果这些 port 都未能处理异常，kernel 可能会：

-   **将其转换为 BSD signal**（针对用户空间进程）。

-   **panic**（针对 kernel 空间的异常）。

### Core Function: `exception_triage()`

函数 `exception_triage()` 会将 Mach 异常沿可能的处理链路转发，直到某个处理者处理它或最终判定为致命。该函数定义在 `osfmk/kern/exception.c`。
```c
void exception_triage(exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt);
```
**典型调用流程：**

`exception_triage()
└── exception_deliver()
├── exception_deliver_thread()
├── exception_deliver_task()
└── exception_deliver_host()`

如果全部失败 → 由 `bsd_exception()` 处理 → 转换为像 `SIGSEGV` 这样的信号。


### 异常端口

每个 Mach 对象（线程、任务、主机）可以注册 **异常端口**，异常消息会发送到这些端口。

它们由以下 API 定义：
```
task_set_exception_ports()
thread_set_exception_ports()
host_set_exception_ports()
```
Each exception port has:

-   A **mask**（它想接收哪些异常）
-   A **port name**（接收消息的 Mach port）
-   A **behavior**（内核如何发送消息）
-   A **flavor**（包含哪个 thread state）


### Debuggers and Exception Handling

A **debugger** (e.g., LLDB) sets an **exception port** on the target task or thread, usually using `task_set_exception_ports()`.

**When an exception occurs:**

-   The Mach message is sent to the debugger process.
-   The debugger can decide to **handle**（恢复、修改寄存器、跳过指令）或**not handle**该异常。
-   If the debugger doesn't handle it, the exception propagates to the next level（task → host）。


### Flow of `EXC_BAD_ACCESS`

1.  Thread dereferences invalid pointer → CPU raises Data Abort。

2.  Kernel trap handler calls `exception_triage(EXC_BAD_ACCESS, ...)`。

3.  Message sent to：

-   Thread port →（调试器可以拦截断点）。

-   If debugger ignores → Task port →（进程级处理器）。

-   If ignored → Host port（通常是 ReportCrash）。

4.  If no one handles → `bsd_exception()` translates to `SIGSEGV`。


### PAC Exceptions

When Pointer Authentication (PAC) fails（签名不匹配），a **special Mach exception** is raised：

-   **`EXC_ARM_PAC`**（类型）
-   Codes may include details（例如，key type、pointer type）。

If the binary has the flag **`TFRO_PAC_EXC_FATAL`**, the kernel treats PAC failures as **fatal**，bypassing debugger interception。This is to prevent attackers from using debuggers to bypass PAC checks and it's enabled for **platform binaries**。


### Software Breakpoints

A software breakpoint（`int3` on x86, `brk` on ARM64）is implemented by **causing a deliberate fault**。\
The debugger catches this via the exception port：

-   Modifies instruction pointer or memory。
-   Restores original instruction。
-   Resumes execution。

This same mechanism is what allows you to "catch" a PAC exception --- **unless `TFRO_PAC_EXC_FATAL`** is set, in which case it never reaches the debugger。


### Conversion to BSD Signals

If no handler accepts the exception：

-   Kernel calls `task_exception_notify() → bsd_exception()`。

-   This maps Mach exceptions to signals：

| Mach Exception | Signal |
| --- | --- |
| EXC_BAD_ACCESS | SIGSEGV or SIGBUS |
| EXC_BAD_INSTRUCTION | SIGILL |
| EXC_ARITHMETIC | SIGFPE |
| EXC_SOFTWARE | SIGTRAP |
| EXC_BREAKPOINT | SIGTRAP |
| EXC_CRASH | SIGKILL |
| EXC_ARM_PAC | SIGILL (on non-fatal) |


### Key Files in XNU Source

-   `osfmk/kern/exception.c` → `exception_triage()`、`exception_deliver_*()` 的核心实现。

-   `bsd/kern/kern_sig.c` → 信号投递逻辑。

-   `osfmk/arm64/trap.c` → 低级 trap 处理器。

-   `osfmk/mach/exc.h` → 异常代码和结构体。

-   `osfmk/kern/task.c` → 任务异常端口的设置。


---

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

The kernel used a **zone allocator**（`kalloc`）divided into fixed-size "zones."  
Each zone only stores allocations of a single size class。

From the screenshot：

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Very small kernel structs, pointers.                                        |
| `default.kalloc.32`  | 32 bytes     | Small structs, object headers.                                              |
| `default.kalloc.64`  | 64 bytes     | IPC messages, tiny kernel buffers.                                          |
| `default.kalloc.128` | 128 bytes    | Medium objects like parts of `OSObject`.                                    |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Large structures, IOSurface/graphics metadata.                              |

**How it worked:**
- Each allocation request gets **rounded up** to the nearest zone size。
（例如，一个 50-byte 的请求会落到 `kalloc.64` zone）。
- Memory in each zone was kept in a **freelist** — chunks freed by the kernel went back into that zone。
- If you overflowed a 64-byte buffer, you’d overwrite the **next object in the same zone**。

This is why **heap spraying / feng shui** was so effective：you could predict object neighbors by spraying allocations of the same size class。


### The freelist

Inside each kalloc zone, freed objects weren’t returned directly to the system — they went into a freelist, a linked list of available chunks。

- When a chunk was freed, the kernel wrote a pointer at the start of that chunk → the address of the next free chunk in the same zone。

- The zone kept a HEAD pointer to the first free chunk。

- Allocation always used the current HEAD：

1. Pop HEAD（将该内存返回给调用者）。

2. Update HEAD = HEAD->next（存储在已释放 chunk 的头部）。

- Freeing pushed chunks back：

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

So the freelist was just a linked list built inside the freed memory itself。

Normal state：
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### 利用 freelist

Because the first 8 bytes of a free chunk = freelist pointer，攻击者可以破坏它：

1. **Heap overflow** 写入相邻的 freed chunk → 覆盖其 “next” pointer。

2. **Use-after-free** 向已 freed 的对象写入数据 → 覆盖其 “next” pointer。

Then, on the next allocation of that size：

- The allocator pops the corrupted chunk.

- Follows the attacker-supplied “next” pointer。

- Returns a pointer to arbitrary memory，能够实现 fake object primitives 或有针对性的 overwrite。

Visual example of freelist poisoning：
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
This freelist design made exploitation highly effective pre-hardening: predictable neighbors from heap sprays, raw pointer freelist links, and no type separation allowed attackers to escalate UAF/overflow bugs into arbitrary kernel memory control.

### Heap Grooming / Feng Shui
The goal of heap grooming is to **shape the heap layout** so that when an attacker triggers an overflow or use-after-free, the target (victim) object sits right next to an attacker-controlled object.\
That way, when memory corruption happens, the attacker can reliably overwrite the victim object with controlled data.

**Steps:**

1. Spray allocations (fill the holes)
- Over time, the kernel heap gets fragmented: some zones have holes where old
objects were freed.
- The attacker first makes lots of dummy allocations to fill these gaps, so
the heap becomes “packed” and predictable.

2. Force new pages
- Once the holes are filled, the next allocations must come from new pages
added to the zone.
- Fresh pages mean objects will be clustered together, not scattered across
old fragmented memory.
- This gives the attacker much better control of neighbors.

3. Place attacker objects
- The attacker now sprays again, creating lots of attacker-controlled objects
in those new pages.
- These objects are predictable in size and placement (since they all belong
to the same zone).

4. Free a controlled object (make a gap)
- The attacker deliberately frees one of their own objects.
- This creates a “hole” in the heap, which the allocator will later reuse for
the next allocation of that size.

5. Victim object lands in the hole
- The attacker triggers the kernel to allocate the victim object (the one
they want to corrupt).
- Since the hole is the first available slot in the freelist, the victim is
placed exactly where the attacker freed their object.

6. Overflow / UAF into victim
- Now the attacker has attacker-controlled objects around the victim.
- By overflowing from one of their own objects (or reusing a freed one), they
can reliably overwrite the victim’s memory fields with chosen values.

**Why it works**:

- Zone allocator predictability: allocations of the same size always come from
the same zone.
- Freelist behavior: new allocations reuse the most recently freed chunk first.
- Heap sprays: attacker fills memory with predictable content and controls layout.
- End result: attacker controls where the victim object lands and what data sits
next to it.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple hardened the allocator and made **heap grooming much harder**:

### 1. From Classic kalloc to kalloc_type
- **Before**: a single `kalloc.<size>` zone existed for each size class (16, 32, 64, … 1280, etc.). Any object of that size was placed there → attacker objects could sit next to privileged kernel objects.
- **Now**:
- Kernel objects are allocated from **typed zones** (`kalloc_type`).
- Each type of object (e.g., `ipc_port_t`, `task_t`, `OSString`, `OSData`) has its own dedicated zone, even if they’re the same size.
- The mapping between object type ↔ zone is generated from the **kalloc_type system** at compile time.

An attacker can no longer guarantee that controlled data (`OSData`) ends up adjacent to sensitive kernel objects (`task_t`) of the same size.

### 2. Slabs and Per-CPU Caches
- The heap is divided into **slabs** (pages of memory carved into fixed-size chunks for that zone).
- Each zone has a **per-CPU cache** to reduce contention.
- Allocation path:
1. Try per-CPU cache.
2. If empty, pull from the global freelist.
3. If freelist is empty, allocate a new slab (one or more pages).
- **Benefit**: This decentralization makes heap sprays less deterministic, since allocations may be satisfied from different CPUs’ caches.

### 3. Randomization inside zones
- Within a zone, freed elements are not handed back in simple FIFO/LIFO order.
- Modern XNU uses **encoded freelist pointers** (safe-linking like Linux, introduced ~iOS 14).
- Each freelist pointer is **XOR-encoded** with a per-zone secret cookie.
- This prevents attackers from forging a fake freelist pointer if they gain a write primitive.
- Some allocations are **randomized in their placement within a slab**, so spraying doesn’t guarantee adjacency.

### 4. Guarded Allocations
- Certain critical kernel objects (e.g., credentials, task structures) are allocated in **guarded zones**.
- These zones insert **guard pages** (unmapped memory) between slabs or use **redzones** around objects.
- Any overflow into the guard page triggers a fault → immediate panic instead of silent corruption.

### 5. Page Protection Layer (PPL) and SPTM
- Even if you control a freed object, you can’t modify all of kernel memory:
- **PPL (Page Protection Layer)** enforces that certain regions (e.g., code signing data, entitlements) are **read-only** even to the kernel itself.
- On **A15/M2+ devices**, this role is replaced/enhanced by **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- These hardware-enforced layers mean attackers can’t escalate from a single heap corruption to arbitrary patching of critical security structures.
- **(Added / Enhanced)**: also, **PAC (Pointer Authentication Codes)** is used in the kernel to protect pointers (especially function pointers, vtables) so that forging or corrupting them becomes harder.
- **(Added / Enhanced)**: zones may enforce **zone_require / zone enforcement**, i.e. that an object freed can only be returned through its correct typed zone; invalid cross-zone frees may panic or be rejected. (Apple alludes to this in their memory safety posts)

### 6. Large Allocations
- Not all allocations go through `kalloc_type`.
- Very large requests (above ~16 KB) bypass typed zones and are served directly from **kernel VM (kmem)** via page allocations.
- These are less predictable, but also less exploitable, since they don’t share slabs with other objects.

### 7. Allocation Patterns Attackers Target
Even with these protections, attackers still look for:
- **Reference count objects**: if you can tamper with retain/release counters, you may cause use-after-free.
- **Objects with function pointers (vtables)**: corrupting one still yields control flow.
- **Shared memory objects (IOSurface, Mach ports)**: these are still attack targets because they bridge user ↔ kernel.

But — unlike before — you can’t just spray `OSData` and expect it to neighbor a `task_t`. You need **type-specific bugs** or **info leaks** to succeed.

### Example: Allocation Flow in Modern Heap

Suppose userspace calls into IOKit to allocate an `OSData` object:

1. **Type lookup** → `OSData` maps to `kalloc_type_osdata` zone (size 64 bytes).
2. Check per-CPU cache for free elements.
- If found → return one.
- If empty → go to global freelist.
- If freelist empty → allocate a new slab (page of 4KB → 64 chunks of 64 bytes).
3. Return chunk to caller.

**Freelist pointer protection**:
- Each freed chunk stores the address of the next free chunk, but encoded with a secret key.
- Overwriting that field with attacker data won’t work unless you know the key.

---

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages, and **PAC** protects pointers |
| Allocation reuse validation     | None (freelist pointers raw)                               | **zone_require / zone enforcement**             |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |
| Large allocations handling      | All small allocations managed equally                       | Large ones bypass zones → handled via VM         |

---

## Modern Userland Heap (iOS, macOS — type-aware / xzone malloc)

In recent Apple OS versions (especially iOS 17+), Apple introduced a more secure userland allocator, **xzone malloc** (XZM). This is the user-space analog to the kernel’s `kalloc_type`, applying type awareness, metadata isolation, and memory tagging safeguards.

### Goals & Design Principles

- **Type segregation / type awareness**: group allocations by *type or usage (pointer vs data)* to prevent type confusion and cross-type reuse.
- **Metadata isolation**: separate heap metadata (e.g. free lists, size/state bits) from object payloads so that out-of-bounds writes are less likely to corrupt metadata.
- **Guard pages / redzones**: insert unmapped pages or padding around allocations to catch overflows.
- **Memory tagging (EMTE / MIE)**: work in conjunction with hardware tagging to detect use-after-free, out-of-bounds, and invalid accesses.
- **Scalable performance**: maintain low overhead, avoid excessive fragmentation, and support many allocations per second with low latency.

### Architecture & Components

Below are the main elements in the xzone allocator:

#### Segment Groups & Zones

- **Segment groups** partition the address space by usage categories: e.g. `data`, `pointer_xzones`, `data_large`, `pointer_large`.
- Each segment group contains **segments** (VM ranges) that host allocations for that category.
- Associated with each segment is a **metadata slab** (separate VM area) that stores metadata (e.g. free/used bits, size classes) for that segment. This **out-of-line (OOL) metadata** ensures that metadata is not intermingled with object payloads, mitigating corruption from overflows.
- Segments are carved into **chunks** (slices) which in turn are subdivided into **blocks** (allocation units). A chunk is tied to a specific size class and segment group (i.e. all blocks in a chunk share the same size & category).
- For small / medium allocations, it will use fixed-size chunks; for large/huges, it may map separately.

#### Chunks & Blocks

- A **chunk** is a region (often several pages) dedicated to allocations of one size class within a group.
- Inside a chunk, **blocks** are slots available for allocations. Freed blocks are tracked via the metadata slab — e.g. via bitmaps or free lists stored out-of-line.
- Between chunks (or within), **guard slices / guard pages** may be inserted (e.g. unmapped slices) to catch out-of-bounds writes.

#### Type / Type ID

- Every allocation site (or call to malloc, calloc, etc.) is associated with a **type identifier** (a `malloc_type_id_t`) which encodes what kind of object is being allocated. That type ID is passed to the allocator, which uses it to select which zone / segment to serve the allocation.
- Because of this, even if two allocations have the same size, they may go into entirely different zones if their types differ.
- In early iOS 17 versions, not all APIs (e.g. CFAllocator) were fully type-aware; Apple addressed some of those weaknesses in iOS 18.

---

### Allocation & Freeing Workflow

Here is a high-level flow of how allocation and deallocation operate in xzone:

1. **malloc / calloc / realloc / typed alloc** is invoked with a size and type ID.
2. The allocator uses the **type ID** to pick the correct segment group / zone.
3. Within that zone/segment, it seeks a chunk that has free blocks of the requested size.
- It may consult **local caches / per-thread pools** or **free block lists** from metadata.
- If no free block is available, it may allocate a new chunk in that zone.
4. The metadata slab is updated (free bit cleared, bookkeeping).
5. If memory tagging (EMTE) is in play, the returned block gets a **tag** assigned, and metadata is updated to reflect its “live” state.
6. When `free()` is called:
- The block is marked as freed in metadata (via OOL slab).
- The block may be placed into a free list or pooled for reuse.
- Optionally, block contents may be cleared or poisoned to reduce data leaks or use-after-free exploitation.
- The hardware tag associated with the block may be invalidated or re-tagged.
- If an entire chunk becomes free (all blocks freed), the allocator may **reclaim** that chunk (unmap it or return to OS) under memory pressure.

---

### Security Features & Hardening

These are the defenses built into modern userland xzone:

| Feature | Purpose | Notes |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | Prevent overflow from corrupting metadata | Metadata lives in separate VM region (metadata slab)|
| **Guard pages / unmapped slices** | Catch out-of-bounds writes | Helps detect buffer overflows rather than silently corrupting adjacent blocks|
| **Type-based segregation** | Prevent cross-type reuse & type confusion | Even same-size allocations from different types go to different zones|
| **Memory Tagging (EMTE / MIE)** | Detect invalid access, stale references, OOB, UAF | xzone works in concert with hardware EMTE in synchronous mode (“Memory Integrity Enforcement”)|
| **Delayed reuse / poisoning / zap** | Reduce chance of use-after-free exploitation | Freed blocks may be poisoned, zeroed, or quarantined before reuse |
| **Chunk reclamation / dynamic unmapping** | Reduce memory waste and fragmentation | Entire chunks may be unmapped when unused |
| **Randomization / placement variation** | Prevent deterministic adjacency | Blocks in a chunk and chunk selection may have randomized aspects |
| **Segregation of “data-only” allocations** | Separate allocations that don’t store pointers | Reduces attacker control over metadata or control fields|

---

### Interaction with Memory Integrity Enforcement (MIE / EMTE)

- Apple’s MIE (Memory Integrity Enforcement) is the hardware + OS framework that brings **Enhanced Memory Tagging Extension (EMTE)** into always-on, synchronous mode across major attack surfaces.
- xzone allocator is a fundamental foundation of MIE in user space: allocations done via xzone get tags, and accesses are checked by hardware.
- In MIE, the allocator, tag assignment, metadata management, and tag confidentiality enforcement are integrated to ensure that memory errors (e.g. stale reads, OOB, UAF) are caught immediately, not exploited later.

---

If you like, I can also generate a cheat-sheet or diagram of xzone internals for your book. Do you want me to do that next?
::contentReference[oai:20]{index=20}


---

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and install it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


## JSKit-Based Safari Chains and PREYHUNTER Stagers

### Renderer RCE abstraction with JSKit
- **Reusable entry**: Recent in-the-wild chains abused a WebKit JIT bug (patched as CVE-2023-41993) purely to gain JavaScript-level arbitrary read/write. The exploit immediately pivots into a purchased framework called **JSKit**, so any future Safari bug only needs to deliver the same primitive.
- **Version abstraction & PAC bypasses**: JSKit bundles support for a wide range of iOS releases together with multiple, selectable Pointer Authentication Code bypass modules. The framework fingerprints the target build, selects the appropriate PAC bypass logic, and verifies every step (primitive validation, shellcode launch) before progressing.
- **Manual Mach-O mapping**: JSKit parses Mach-O headers directly from memory, resolves the symbols it needs inside dyld-cached images, and can manually map additional Mach-O payloads without writing them to disk. This keeps the renderer process in-memory only and evades code-signature checks tied to filesystem artifacts.
- **Portfolio model**: Debug strings such as *"exploit number 7"* show that the suppliers maintain multiple interchangeable WebKit exploits. Once the JS primitive matches JSKit’s interface, the rest of the chain is unchanged across campaigns.

### Kernel bridge: IPC UAF -> code-sign bypass pattern
- **Kernel IPC UAF (CVE-2023-41992)**: The second stage, still running inside the Safari context, triggers a kernel use-after-free in IPC code, re-allocates the freed object from userland, and abuses the dangling pointers to pivot into arbitrary kernel read/write. The stage also reuses PAC bypass material previously computed by JSKit instead of re-deriving it.
- **Code-signing bypass (CVE-2023-41991)**: With kernel R/W available, the exploit patches the trust cache / code-signing structures so unsigned payloads execute as `system`. The stage then exposes a lightweight kernel R/W service to later payloads.
- **Composed pattern**: This chain demonstrates a reusable recipe that defenders should expect going forward:
```
WebKit renderer RCE -> kernel IPC UAF -> kernel arbitrary R/W -> code-sign bypass -> unsigned system stager
```
### PREYHUNTER helper & watcher modules
- **Watcher anti-analysis**: 一个专用的 watcher 二进制会持续分析设备，并在检测到研究/分析环境时中止 kill-chain。它检查 `security.mac.amfi.developer_mode_status`、是否存在 `diagnosticd` 控制台、系统地区设置为 `US` 或 `IL`、是否有像 **Cydia** 的越狱痕迹、是否运行 `bash`、`tcpdump`、`frida`、`sshd` 或 `checkrain` 等进程、移动 AV 应用（McAfee、AvastMobileSecurity、NortonMobileSecurity）、自定义 HTTP 代理设置以及自签根 CA。任一检测不通过都会阻止后续 payload 的投放。
- **Helper surveillance hooks**: helper 组件通过 `/tmp/helper.sock` 与其他阶段通信，然后加载名为 **DMHooker** 和 **UMHooker** 的 hook 集。这些 hooks 挂接 VOIP 音频路径（录音保存在 `/private/var/tmp/l/voip_%lu_%u_PART.m4a` 下）、实现全系统 keylogger、在无 UI 的情况下拍照，并 hook SpringBoard 以压制这些操作通常会引发的通知。因此 helper 在投放像 Predator 这样的更重型 implants 之前，充当隐蔽的验证 + 轻量监视层。

### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

## References

- [Google Threat Intelligence – Intellexa zero-day exploits continue](https://cloud.google.com/blog/topics/threat-intelligence/intellexa-zero-day-exploits-continue)

{{#include ../../banners/hacktricks-training.md}}
