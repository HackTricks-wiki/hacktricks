# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

### 1. **Code Signing** / Runtime Signature Verification
**Introduced early (iPhone OS → iOS)**
Hii ni moja ya kinga msingi: **kodi zote za utekelezaji** (apps, dynamic libraries, JIT-ed code, extensions, frameworks, caches) zinapaswa kusainiwa kwa kificho cha cryptographic na mnyororo wa vyeti ulioanzia kwenye mtandao wa Apple. Wakati wa runtime, kabla ya kupakia binary kwenye memory (au kabla ya kufanya jumps kuvuka mipaka fulani), mfumo huthibitisha saini yake. Ikiwa code imebadilishwa (bit-flipped, patched) au haijasainiwa, load inashindwa.

- **Huzuia**: hatua ya “classic payload drop + execute” katika exploit chains; injection ya arbitrary code; kubadilisha binary iliyopo ili kuingiza mantiki ya uovu.
- **Maelezo ya utendakazi**:
* The Mach-O loader (and dynamic linker) checks code pages, segments, entitlements, team IDs, and that the signature covers the file’s contents.
* Kwa maeneo ya memory kama JIT caches au code zinazozalishwa kwa runtime, Apple inalazimisha kwamba pages zisainishwe au zichunguzwe kupitia API maalum (mfano `mprotect` with code-sign checks).
* Saini inajumuisha entitlements na identifiers; OS inalazimisha kwamba API fulani au uwezo wa privileged yanahitaji entitlements maalum ambayo hayawezi kutengenezwa bandia.

<details>
<summary>Example</summary>
Fikiria exploit inapata code execution kwenye process na inajaribu kuandika shellcode kwenye heap na kuruka kwayo. Kwenye iOS, page hiyo ingepaswa kuwa imewekwa kama executable **na** kukidhi vigezo vya code-signature. Kwa kuwa shellcode haijasainiwa na cheti cha Apple, jump inashindwa au mfumo unakataa kuifanya region hiyo ya memory iwe executable.
</details>


### 2. **CoreTrust**
**Introduced around iOS 14+ era (or gradually in newer devices / later iOS)**
CoreTrust ni subsystem inayofanya **runtime signature validation** ya binaries (ikiwa ni pamoja na system na user binaries) dhidi ya **Apple’s root certificate** badala ya kutegemea cached userland trust stores.

- **Huzuia**: tampering baada ya install ya binaries, jailbreaking techniques zinazojaribu kubadilisha au kupatch system libraries au user apps; kumnyenga mfumo kwa kubadilisha binaries zilizothibitishwa na zilizoibiwa.
- **Maelezo ya utendakazi**:
* Instead of trusting a local trust database or certificate cache, CoreTrust fetches or refers to Apple’s root directly or verifies intermediate certificates in a secure chain.
* Inahakikisha kwamba mabadiliko (mfano kwenye filesystem) kwa binaries zilizopo yanagunduliwa na yakakataliwa.
* Inahusisha entitlements, team IDs, code signing flags, na metadata nyingine na binary wakati wa load.

<details>
<summary>Example</summary>
Jailbreak inaweza kujaribu kubadilisha `SpringBoard` au `libsystem` na toleo lililopatchiwa ili kupata persistence. Lakini wakati loader ya OS au CoreTrust inachunguza, inagundua mismatch ya signature (au entitlements zilizobadilishwa) na inakataa kuendesha.
</details>


### 3. **Data Execution Prevention (DEP / NX / W^X)**
**Introduced in many OSes earlier; iOS had NX-bit / w^x for a long time**
DEP inalazimisha kwamba pages zilizoelezwa kuwa writable (kwa data) ziwe **zisizoweza kutekelezwa**, na pages zilizoelezwa kuwa executable ziwe **zisizoweza kuandikwa**. Huwezi tu kuandika shellcode kwenye heap au stack na kuitekeleza.

- **Huzuia**: execution ya shellcode moja kwa moja; classic buffer-overflow → jump kwa injected shellcode.
- **Maelezo ya utendakazi**:
* The MMU / memory protection flags (via page tables) enforce the separation.
* Kila jaribio la kufanya writable page iwe executable linaanza ukaguzi wa mfumo (na linakahitajika au kukataliwa au linahitaji idhini ya code-sign).
* Katika matukio mengi, kufanya pages ziwe executable kunahitaji kutumia OS APIs ambazo zinatetea vizuizi zaidi au ukaguzi.

<details>
<summary>Example</summary>
Overflow inaandika shellcode kwenye heap. Mshambuliaji anajaribu `mprotect(heap_addr, size, PROT_EXEC)` ili kuifanya executable. Lakini mfumo unakataza au unathibitisha kwamba page mpya lazima ipite vigezo vya code-sign (ambayo shellcode haiwezi kukidhi).
</details>

### 4. **Address Space Layout Randomization (ASLR)**
**Introduced in iOS ~4–5 era (roughly iOS 4–5 timeframe)**
ASLR inabadilisha kwa nasibu addresses za maeneo muhimu ya memory: libraries, heap, stack, n.k., kila mara process inapoanzishwa. Addresses za gadgets hubadilika kati ya runs.

- **Huzuia**: hardcoding addresses za gadgets kwa ROP/JOP; exploit chains za static; kuruka bila kujua offsets za kawaida.
- **Maelezo ya utendakazi**:
* Each loaded library / dynamic module is rebased at a randomized offset.
* Stack and heap base pointers are randomized (within certain entropy limits).
* Wakati mwingine maeneo mengine (mfano mmap allocations) nayo yanarandomize.
* Pamoja na information-leak mitigations, inalazimisha mshambuliaji kwanza kukuja na address au pointer ili kugundua base addresses wakati wa runtime.

<details>
<summary>Example</summary>
ROP chain inatarajia gadget kwa `0x….lib + offset`. Lakini kwa kuwa `lib` inarebased tofauti kila run, chain iliyowekwa kwa hardcode inashindwa. Exploit lazima kwanza i-`leak` base address ya module kabla ya kuhesabu addresses za gadgets.
</details>


### 5. **Kernel Address Space Layout Randomization (KASLR)**
**Introduced in iOS ~ (iOS 5 / iOS 6 timeframe)**
Kama ASLR ya user, KASLR inararandisha base ya **kernel text** na miundo mingine ya kernel wakati wa boot.

- **Huzuia**: kernel-level exploits zinazotegemea eneo la kudumu la kernel code au data; exploits za kernel za static.
- **Maelezo ya utendakazi**:
* Kila boot, base address ya kernel inararandishwa (ndani ya range).
* Miundo ya data ya kernel (kama `task_structs`, `vm_map`, n.k.) pia zinaweza kuhamishwa au kuwekwa offsets.
* Washambuliaji lazima kwanza wa-`leak` kernel pointers au kutumia information disclosure vulnerabilities ili kuhesabu offsets kabla ya kuiba au kudhibiti kernel structures au code.

<details>
<summary>Example</summary>
Uvunjaji wa ndani unalenga kuharibu kernel function pointer (mfano katika `vtable`) kwa `KERN_BASE + offset`. Lakini kwa kuwa `KERN_BASE` haijulikani, mshambuliaji lazima a-`leak` kwanza (mfano kupitia read primitive) kabla ya kuhesabu address sahihi ya kuharibu.
</details>


### 6. **Kernel Patch Protection (KPP / AMCC)**
**Introduced in newer iOS / A-series hardware (post around iOS 15–16 era or newer chips)**
KPP (aka AMCC) inaendelea kufuatilia integrity ya kernel text pages (kwa hash au checksum). Ikiwa inagundua tampering (patches, inline hooks, modifications) nje ya muda ulioruhusiwa, inasababisha kernel panic au reboot.

- **Huzuia**: patching ya kudumu ya kernel (kubadilisha maagizo ya kernel), inline hooks, kuandika juu ya function kwa static.
- **Maelezo ya utendakazi**:
* Hardware au firmware module inafuatilia region ya kernel text.
* Mara kwa mara au kwa ombi inafanya re-hash ya pages na kulinganisha na thamani inayotarajiwa.
* Ikiwa kuna mismatch nje ya madirisha ya updates halali, inafanya panic ya device (ili kuepuka patch ya kudumu ya uovu).
* Washambuliaji lazima wajaribu kuepuka madirisha ya kugundua au kutumia njia za patch halali.

<details>
<summary>Example</summary>
Exploit inajaribu kupatcha prologue ya kernel function (mfano `memcmp`) ili kuingilia simu. Lakini KPP inagundua kwamba hash ya page ya code haifai na inasababisha kernel panic, ikichoma device kabla ya patch kustawi.
</details>


### 7. **Kernel Text Read‐Only Region (KTRR)**
**Introduced in modern SoCs (post ~A12 / newer hardware)**
KTRR ni mécanism iliyotekelezwa kwa hardware: mara kernel text inafungwa mapema wakati wa boot, inakuwa read-only kutoka EL1 (kernel), ikizuia uandishi zaidi kwa code pages.

- **Huzuia**: mabadiliko yoyote ya kernel code baada ya boot (mfano patching, code injection kwa in-place) kwa viwango vya uwezo EL1.
- **Maelezo ya utendakazi**:
* Wakati wa boot (katika hatua ya secure/bootloader), memory controller (au unit ya hardware salama) inaweka physical pages zenye kernel text kuwa read-only.
* Hata kama exploit inapata privileges zote za kernel, haiwezi kuandika kwenye pages hizo ili kupatcha maagizo.
* Ili kuzibadilisha, mshambuliaji lazima kwanza aibulishe chain ya boot, au kutengeneza KTRR yenyewe.

<details>
<summary>Example</summary>
Exploit ya privilege-escalation inajaribu kuruka hadi EL1 na kuandika trampoline ndani ya kernel function (mfano katika `syscall` handler). Lakini kwa sababu pages zimefungwa kama read-only na KTRR, uandishi unashindwa (au unaleta fault), hivyo patch haifanyiki.
</details>


### 8. **Pointer Authentication Codes (PAC)**
**Introduced with ARMv8.3 (hardware), Apple beginning with A12 / iOS ~12+**
- PAC ni kipengele cha hardware kilichowasilishwa katika **ARMv8.3-A** kutambua uharibifu wa thamani za pointer (return addresses, function pointers, certain data pointers) kwa kuingiza sahihi ndogo ya cryptographic (“MAC”) katika bits za juu zisizotumika za pointer.
- Saini (“PAC”) inahesabiwa juu ya thamani ya pointer pamoja na **modifier** (thamani ya context, mfano stack pointer au data ya kutofautisha). Kwa hiyo pointer ile ile iliyosainiwa katika contexts tofauti hupata PAC tofauti.
- Wakati wa kutumia, instruction ya **authenticate** inakagua PAC. Ikiwa ni halali, PAC inatolewa na pointer safi inapatikana; ikiwa si sahihi, pointer inakuwa “poisoned” (au fault inatolewa).
- Keys zinazotumika kutengeneza/kuhalalisha PAC zinaishi katika rejista za privileged (EL1, kernel) na hawezi kusomwa moja kwa moja kutoka user mode.
- Kwa sababu sio bits zote 64 za pointer zinatumiwa katika mifumo mingi (mfano 48-bit address space), bits za juu ni “spare” na zinaweza kushikilia PAC bila kuathiri address inayofanya kazi.

#### Architectural Basis & Key Types

- ARMv8.3 inatambua **vitufe vitano vya 128-bit** (kila kimefumwa kupitia rejista mbili za 64-bit) kwa pointer authentication.
- **APIAKey** — kwa instruction pointers (domain “I”, key A)
- **APIBKey** — key ya pili ya instruction pointer (domain “I”, key B)
- **APDAKey** — kwa data pointers (domain “D”, key A)
- **APDBKey** — kwa data pointers (domain “D”, key B)
- **APGAKey** — key “generic”, kwa kusaini data isiyo-pointer au matumizi ya jumla

- Vitufe hivi vinahifadhiwa katika rejista za system privileged (zinazopatikana tu katika EL1/EL2 n.k.), hazipatikani kutoka user mode.
- PAC inahesabiwa kupitia function ya cryptographic (ARM inapendekeza QARMA kama algorithm) ikitumia:
1. The pointer value (canonical portion)
2. A **modifier** (thamani ya context, kama salt)
3. The secret key
4. Some internal tweak logic
Ikiwa PAC inayotokana inalingana na ile iliyohifadhiwa katika bits za juu za pointer, authentication inafanikiwa.

#### Instruction Families

The naming convention is: **PAC** / **AUT** / **XPAC**, then domain letters.
- `PACxx` instructions **sign** a pointer and insert a PAC
- `AUTxx` instructions **authenticate + strip** (validate and remove the PAC)
- `XPACxx` instructions **strip** without validating

Domains / suffixes:

| Mnemonic     | Meaning / Domain                      | Key / Domain     | Example Usage in Assembly |
|--------------|-----------------------------------------|--------------------|-----------------------------|
| **PACIA**    | Sign instruction pointer with APIAKey   | “I, A”             | `PACIA X0, X1` — sign pointer in X0 using APIAKey with modifier X1|
| **PACIB**    | Sign instruction pointer with APIBKey   | “I, B”             | `PACIB X2, X3`              |
| **PACDA**    | Sign data pointer with APDAKey           | “D, A”             | `PACDA X4, X5`              |
| **PACDB**    | Sign data pointer with APDBKey           | “D, B”             | `PACDB X6, X7`              |
| **PACG / PACGA** | Generic (non-pointer) signing with APGAKey | “G”         | `PACGA X8, X9, X10` (sign X9 with modifier X10 into X8) |
| **AUTIA**    | Authenticate APIA-signed instruction pointer & strip PAC | “I, A” | `AUTIA X0, X1` — check PAC on X0 using modifier X1, then strip |
| **AUTIB**    | Authenticate APIB domain                 | “I, B”             | `AUTIB X2, X3`               |
| **AUTDA**    | Authenticate APDA-signed data pointer    | “D, A”             | `AUTDA X4, X5`               |
| **AUTDB**    | Authenticate APDB-signed data pointer    | “D, B”             | `AUTDB X6, X7`               |
| **AUTGA**    | Authenticate generic / blob (APGA)        | “G”               | `AUTGA X8, X9, X10` (validate generic) |
| **XPACI**     | Strip PAC (instruction pointer, no validation) | “I”         | `XPACI X0` — remove PAC from X0 (instruction domain) |
| **XPACD**     | Strip PAC (data pointer, no validation)    | “D”             | `XPACD X4` — remove PAC from data pointer in X4 |


There are specialized / alias forms:

- `PACIASP` is shorthand for `PACIA X30, SP` (sign the link register using SP as modifier)
- `AUTIASP` is `AUTIA X30, SP` (authenticate link register with SP)
- Combined forms like `RETAA`, `RETAB` (authenticate-and-return) or `BLRAA` (authenticate & branch) exist in ARM extensions / compiler support.
- Also zero-modifier variants: `PACIZA` / `PACIZB` where the modifier is implicitly zero, etc.

#### Modifiers

Lengo kuu la modifier ni **kufuata PAC kwa context maalum** ili address ile ile iliyosainiwa katika contexts tofauti iwe na PAC tofauti. Hii inazuia matumizi ya pointer moja kwa frame nyingine au object nyingine. Ni kama kuongeza **salt kwenye hash.**

Kwa hiyo:
- **modifier** ni thamani ya context (rejista nyingine) inayochanganywa kwenye hesabu ya PAC. Chaguo za kawaida: stack pointer (`SP`), frame pointer, au object ID.
- Kutumia SP kama modifier ni kawaida kwa signing ya return addresses: PAC inafungwa kwa frame maalum ya stack. Ukijaribu kutumia LR katika frame tofauti, modifier hubadilika, hivyo authentication ya PAC inashindwa.
- Pointer ile ile iliyosainiwa kwa modifiers tofauti huzaa PAC tofauti.
- modifier haiondoki kuwa siri, lakini bora iwe haidhibitiwi na mshambuliaji.
- Kwa instructions zinazofanya sign au verify pointers ambako hakuna modifier ya maana, baadhi ya fomu zinatumia zero au constant iliyofichwa.

#### Apple / iOS / XNU Customizations & Observations

- Utekelezaji wa PAC wa Apple unajumuisha **diversifiers za kila boot** ili vitufe au tweaks zibadilike kila boot, kuzuia matumizi tena kati ya boots.
- Pia wanajumuisha **cross-domain mitigations** ili PAC zilizosainiwa katika user mode zisitumiwe kirahisi katika kernel mode, n.k.
- Kwenye Apple M1 / Apple Silicon, reverse engineering ilionyesha kuwa kuna **aina tisa za modifier** na rejista za mfumo maalum za Apple kwa udhibiti wa vitufe.
- Apple inatumia PAC katika subsystems nyingi za kernel: signing ya return address, integrity ya pointer katika data ya kernel, signed thread contexts, n.k.
- Google Project Zero ilionyesha jinsi chini ya powerful memory read/write primitive katika kernel, mtu angeweza kuforge kernel PACs (kwa A keys) kwenye devices za A12-era, lakini Apple ilifunga njia nyingi hizo.
- Kwenye mfumo wa Apple, baadhi ya keys ni **global kwa kernel**, wakati processes za user zinaweza kupata randomness ya key kwa kila process.

#### PAC Bypasses

1. **Kernel-mode PAC: theoretical vs real bypasses**

-   Kwa kuwa vitufe na mantiki ya kernel PAC vinadhibitiwa kwa ukali (rejista za privileged, diversifiers, isolation ya domain), kutengeneza pointers zilizothibitishwa za kernel ni ngumu sana.
-   Azad's 2020 "iOS Kernel PAC, One Year Later" inaripoti kwamba katika iOS 12-13, alipata baadhi ya bypasses za sehemu (signing gadgets, reuse ya signed states, indirect branches zisizo ziliwal protected) lakini hakuna bypass kamili ya generic. [bazad.github.io](https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf)
-   Apple’s "Dark Magic" customizations zimepunguza zaidi surfaces zinazoweza kutumiwa (domain switching, per-key enabling bits). [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Kuna CVE inayoonekana kama **kernel PAC bypass CVE-2023-32424** kwenye Apple silicon (M1/M2) iliyoripotiwa na Zecao Cai et al. [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Lakini bypasses hizi mara nyingi zinategemea gadgets maalum au bugs za utekelezaji; si bypass za matumizi ya jumla.

Hivyo kernel PAC inachukuliwa kuwa **thabiti sana**, ingawa si kamili.

2. **User-mode / runtime PAC bypass techniques**

Hizi ni za kawaida zaidi, na zinachukua nafasi ya mapungufu jinsi PAC inavyotekelezwa au kutumiwa katika dynamic linking / runtime frameworks. Hapa chini ni daraja, na mifano.

2.1 **Shared Cache / A key issues**

-   The **dyld shared cache** ni blob kubwa ya pre-linked system frameworks na libraries. Kwa kuwa inashirikiwa sana, function pointers ndani ya shared cache zinakuwa "pre-signed" na kisha zikitumika na processes nyingi. Washambuliaji walilenga pointers hizi tayari-sainiwa kama "PAC oracles".

-   Baadhi ya mbinu za bypass zinajaribu kutokeza au kutumia A-key signed pointers zilizopo katika shared cache na kuzitumia kwenye gadgets.

-   Hotuba ya "No Clicks Required" inaelezea kujenga oracle juu ya shared cache ili kubaini addresses za relative na kuiunganisha na pointers zilizosainiwa kuvunja PAC. [saelo.github.io](https://saelo.github.io/presentations/offensivecon_20_no_clicks.pdf)

-   Pia, imports ya function pointers kutoka shared libraries katika userspace zilikuonekana kuwa hazilindwa vya kutosha na PAC, kuruhusu mshambuliaji kupata function pointers bila kubadilisha saini yake. (Project Zero bug entry) [bugs.chromium.org](https://bugs.chromium.org/p/project-zero/issues/detail?id=2044&utm_source=chatgpt.com)

2.2 **dlsym(3) / dynamic symbol resolution**

-   Moja ya bypass inayojulikana ni kuita `dlsym()` kupata pointer ya function *iliyosasishwa tayari* (ilayosainiwa na A-key, diversifier zero) kisha kuitumia. Kwa sababu `dlsym` inarudisha pointer iliyosainiwa kwa njia halali, kuitumia inazuia hitaji la kutengeneza PAC.

-   Blog ya Epsilon inaelezea jinsi baadhi ya bypasses zilivyotumia hili: kuitwa `dlsym("someSym")` hutoa pointer iliyosainiwa na inaweza kutumika kwa indirect calls. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

-   Synacktiv's "iOS 18.4 --- dlsym considered harmful" inaelezea bug: baadhi ya symbols zilizotatuliwa kupitia `dlsym` kwenye iOS 18.4 zinarudisha pointers zilizosainiwa kinyume (au na diversifiers zenye bug), kurahisisha unintended PAC bypass. [Synacktiv](https://www.synacktiv.com/en/publications/ios-184-dlsym-considered-harmful)

-   Mantiki katika dyld kwa dlsym ni pamoja na: wakati `result->isCode`, wanahakikisha pointer iliyorudishwa kwa `__builtin_ptrauth_sign_unauthenticated(..., key_asia, 0)`, i.e. context zero. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

Hivyo, `dlsym` mara nyingi ni vector katika user-mode PAC bypasses.

2.3 **Other DYLD / runtime relocations**

-   DYLD loader na logic ya dynamic relocation ni ngumu na wakati mwingine inamepanga pages kama read/write kwa kufanya relocations, kisha kurudisha kuwa read-only. Washambuliaji wanatumia madirisha haya. Hotuba za Synacktiv zinaelezea "Operation Triangulation", bypass inayotegemea timing ya PAC kupitia dynamic relocations. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   DYLD pages sasa zinalindwa kwa SPRR / VM_FLAGS_TPRO (bendera za ulinzi kwa dyld). Lakini toleo za awali zilikuwa na ulinzi dhaifu. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   Katika exploit chains za WebKit, DYLD loader mara nyingi ni lengo la PAC bypass. Slides zinataja kwamba PAC bypasses nyingi zimetegemea DYLD loader (kupitia relocation, interposer hooks). [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

2.4 **NSPredicate / NSExpression / ObjC / SLOP**

-   Katika chains za userland exploit, Objective-C runtime methods kama `NSPredicate`, `NSExpression` au `NSInvocation` zinatumika kusafirisha control calls bila kuonekana wazi ya forging pointers.

-   Kwenye iOS za zamani (kabla ya PAC), exploit ilitumia **fake NSInvocation** objects kuita selectors yoyote kwenye memory iliyodhibitiwa. Kwa PAC, mbinu zilihitaji mabadiliko. Lakini mbinu ya SLOP (SeLector Oriented Programming) imeenea chini ya PAC pia. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   Mbinu ya asili ya SLOP iliruhusu kuunganisha ObjC calls kwa kuunda invocations bandia; bypass inategemea ukweli kwamba ISA au selector pointers wakati mwingine hazilindwa kikamilifu na PAC. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   Katika mazingira ambapo pointer authentication inatumiwa kwa sehemu, methods / selectors / target pointers huenda hazilinganiwi kila mara na PAC, zikitoa nafasi ya bypass.

#### Example Flow

<details>
<summary>Example Signing & Authenticating</summary>
```
; Example: function prologue / return address protection
my_func:
stp x29, x30, [sp, #-0x20]!        ; push frame pointer + LR
mov x29, sp
PACIASP                            ; sign LR (x30) using SP as modifier
; … body …
mov sp, x29
ldp x29, x30, [sp], #0x20         ; restore
AUTIASP                            ; authenticate & strip PAC
ret

; Example: indirect function pointer stored in a struct
; suppose X1 contains a function pointer
PACDA X1, X2     ; sign data pointer X1 with context X2
STR X1, [X0]      ; store signed pointer

; later retrieval:
LDR X1, [X0]
AUTDA X1, X2       ; authenticate & strip
BLR X1             ; branch to valid target

; Example: stripping for comparison (unsafe)
LDR X1, [X0]
XPACI X1           ; strip PAC (instruction domain)
CMP X1, #some_label_address
BEQ matched_label
```
</details>

<details>
<summary>Mfano</summary>
Buffer overflow inaandika juu anwani ya kurudisha kwenye stack. Mshambuliaji anaandika anwani ya gadget ya lengo lakini hawezi kuhesabu PAC sahihi. Wakati function inarudi, instruction ya CPU `AUTIA` inatoa hitilafu kwa sababu PAC haikufanana. Mlolongo unashindwa.
Uchambuzi wa Project Zero juu ya A12 (iPhone XS) ulionyesha jinsi PAC ya Apple inavyotumika na mbinu za kutengeneza PAC ikiwa mshambuliaji ana primitive ya kusoma/kuandika kumbukumbu.
</details>


### 9. **Utambuzi wa Malengo ya Matawi (Branch Target Identification, BTI)**
**Ilianzishwa katika ARMv8.5 (vifaa vya baadaye)**
BTI ni kipengele cha hardware kinachokagua **malengo ya matawi yasiyo ya moja kwa moja**: wakati `blr` au simu/zama zisizo za moja kwa moja zinaendeshwa, lengo lazima liwe na **BTI landing pad** (`BTI j` au `BTI c`). Kuruka ndani ya anwani za gadget ambazo hazina landing pad husababisha exception.

LLVM inataja aina tatu za maelekezo ya BTI na jinsi zinavyofanana na aina za matawi.

| BTI Variant | Inaruhusu nini (ni aina gani za matawi) | Mipangilio ya kawaida / matumizi |
|-------------|----------------------------------------|-------------------------------|
| **BTI C** | Targets of *call*-style indirect branches (e.g. `BLR`, or `BR` using X16/X17) | Weka kwenye kuingia kwa functions ambazo zinaweza kuitwa kwa njia zisizo za moja kwa moja |
| **BTI J** | Targets of *jump*-style branches (e.g. `BR` used for tail calls) | Imewekwa mwanzoni mwa blocks zinazofikika kwa jump tables au tail-calls |
| **BTI JC** | Acts as both C and J | Inaweza kulengwa na simu au matawi kwa njia yoyote |

- Katika code iliyotengenezwa na enforcement ya branch target, compilers huchangia maelekezo ya BTI (C, J, au JC) katika kila lengo halali la indirect-branch (mwanzo wa functions au blocks zinazofikika kwa jumps) ili matawi yasiyo ya moja kwa moja yaweze kufanikiwa tu kwa maeneo hayo.
- **Direct branches / calls** (yaani anwani thabiti `B`, `BL`) **hayana kikomo** na BTI. Dhana ni kwamba pages za code zinatumiwa kwa uaminifu na mshambuliaji hawezi kuzibadilisha (hivyo direct branches ni salama).
- Pia, maagizo ya **RET / return** kwa kawaida hayafungwa na BTI kwa sababu anwani za kurudi zinalindwa kupitia PAC au mekanisimu za return signing.

#### Mechanism and enforcement

- Wakati CPU inachambua **indirect branch (BLR / BR)** kwenye page iliyotajwa kama “guarded / BTI-enabled,” inakagua kama instruction ya kwanza ya anwani ya lengo ni BTI halali (C, J, au JC kama inaruhusiwa). Ikiwa siyo, hutokea **Branch Target Exception**.
- Ujenzi wa maelekezo ya BTI ulikusudiwa kutumia opcodes ambazo hapo awali zilikuwa zimehifadhiwa kwa NOPs (kwa matoleo ya ARM ya awali). Hivyo binaries zinazounga mkono BTI zinabaki backward-compatible: kwenye hardware isiyo na BTI, maelekezo hayo hufanya kazi kama NOPs.
- Compiler passes zinazoweka BTIs zinaweka tu pale zinapohitajika: functions zinazoweza kuitwa kwa njia zisizo za moja kwa moja, au basic blocks zinazolengwa na jumps.
- Baadhi ya patches na code za LLVM zinaonyesha kuwa BTI haijiwekwi kwa *blocks zote* — ni kwa blocks ambazo zina uwezekano wa kuwa malengo ya matawi (mfano: kutoka switch / jump tables).

#### BTI + PAC ushirikiano

PAC inalinda thamani ya pointer (chanzo) — inahakikisha mlolongo wa simu zisizo za moja kwa moja / returns haujabadilishwa.

BTI inahakikisha kwamba hata pointer halali inapaswa kulenga tu entry points zilizowekwa alama ipasavyo.

Kwa pamoja, mshambuliaji anahitaji pointer halali yenye PAC sahihi na lengo ambalo limewekwa na BTI. Hii inaongeza ugumu wa kujenga gadgets za exploit.

#### Mfano


<details>
<summary>Mfano</summary>
Exploit inajaribu kuhamia kwenye gadget kwenye `0xABCDEF` ambayo haianzi na `BTI c`. CPU, inapotekeleza `blr x0`, inakagua lengo na inatoa fault kwa sababu mpangilio wa maelekezo haujumuishi landing pad halali. Hivyo gadgets nyingi zinakuwa hazitumiki hadi ziwe na prefiksi ya BTI.
</details>


### 10. **Privileged Access Never (PAN) & Privileged Execute Never (PXN)**
**Imeanzishwa katika nyongeza za hivi karibuni za ARMv8 / msaada wa iOS (kwa kernel iliyoimarishwa)**

#### PAN (Privileged Access Never)

- **PAN** ni kipengele kilichoanzishwa katika **ARMv8.1-A** kinachozuiwa **code iliyo kwenye ngazi za juu za privilégée** (EL1 au EL2) kutoka **kusoma au kuandika** kumbukumbu inayotajwa kama **inayopatikana kwa user (EL0)**, isipokuwa PAN iondolewe kwa wazi.
- Wazo ni: hata kama kernel imepotoshwa au kuibiwa, haiwezi kufanya dereference ya pointers za user-space bila kwanza *kufuta* PAN, hivyo kupunguza hatari za exploits za mtindo wa **`ret2usr`** au matumizi mabaya ya buffers zinazodhibitiwa na user.
- Wakati PAN imewezeshwa (PSTATE.PAN = 1), instruction yoyote ya privileged load/store inayofikia anwani ya virtual iliyotajwa kama “inayopatikana kwa EL0” husababisha **permission fault**.
- Kernel, inapohitaji kwa uhalali kufikia kumbukumbu ya user-space (mfano ku-copy data kwenda/kutoka user buffers), lazima **waondoe PAN kwa muda** (au watumie maagizo “unprivileged load/store”) ili kuruhusu upatikanaji huo.
- Katika Linux kwenye ARM64, msaada wa PAN ulianzishwa takriban 2015: patches za kernel ziliongeza ugunduzi wa kipengele, na kubadilisha `get_user` / `put_user` n.k. na utofauti ambao unafuta PAN wakati wa upatikanaji wa kumbukumbu za user.

**Nuance muhimu / kikomo / bug**
- Kama ilivyoelezwa na Siguza na wengine, kasoro ya specification (au tabia isiyoeleweka) katika muundo wa ARM inamaanisha kuwa **mappings za user ambazo ni execute-only** (`--x`) huenda **zisizokusanya PAN**. Kwa maneno mengine, ikiwa page ya user imewekwa executable lakini bila ruhusa ya kusoma, jaribio la kernel la kusoma linaweza kupitisha PAN kwa sababu architecture inachukulia “inapatikana kwa EL0” kuhitaji ruhusa ya kusoma, sio tu executable. Hii inapelekea bypass ya PAN katika usanidi fulani.
- Kwa sababu hiyo, kama iOS / XNU inaruhusu pages za user kuwa execute-only (kama baadhi ya JIT au code-cache zinaweza kufanya), kernel inaweza kwa bahati kusoma kutoka kwao hata PAN iko. Hii ni eneo tambulika linaloweza kutumika kwa udukuzi katika baadhi ya mifumo ya ARMv8+.

#### PXN (Privileged eXecute Never)

- **PXN** ni bit katika page table (katika entries za leaf au block) inayoonyesha kuwa page haiepukiki kutekelezwa wakati inafanya kazi kwa mode ya juu ya privilège (yaani EL1 haiwezi kutekeleza).
- PXN inazuia kernel (au code yoyote ya privilegi) kutoka kuruka au kutekeleza maelekezo kutoka kwenye pages za user hata kama control imeelekezwa huko. Kwa vitendo, inazuia mabadiliko ya control-flow ya kiwango cha kernel kwenda kwenye memory ya user.
- Ikichanganywa na PAN, hii inahakikisha:
1. Kernel hawezi (kwa default) kusoma au kuandika data za user-space (PAN)
2. Kernel haiwezi kutekeleza code za user-space (PXN)
- Katika muundo wa page table wa ARMv8, entries za leaf zina bit ya `PXN` (na pia `UXN` kwa unprivileged execute-never) katika bits zao za sifa.

Hivyo hata kama kernel ina function pointer iliyoharibika ikielekeza kwenye memory ya user, na ikijaribu kuruka huko, bit ya PXN itasababisha fault.

#### Mfano wa modeli ya ruhusa za kumbukumbu & jinsi PAN na PXN zinavyolingana na bits za page table

Ili kuelewa jinsi PAN / PXN zinavyofanya kazi, unahitaji kuona jinsi tafsiri ya ARM na modeli ya ruhusa inavyofanya kazi (imefupishwa):

- Kila page au block entry ina sehemu za sifa zikiwemo **AP[2:1]** kwa ruhusa za upatikanaji (kusoma/kuandika, privilégi dhidi ya unprivileged) na bits za **UXN / PXN** kwa vizuizi vya execute-never.
- Wakati PSTATE.PAN ni 1 (imewezeshwa), hardware inatekeleza semantics zilizobadilishwa: upatikanaji wa privileged kwa pages zilizochaguliwa kama “zinazopatikana na EL0” unazuiliwa (fault).
- Kwa sababu ya kasoro iliyotajwa, pages ambazo zimewekwa tu executable (bila ruhusa ya kusoma) huenda zisichukuliwe kama “zinazopatikana na EL0” chini ya implementations fulani, hivyo kupitisha PAN.
- Wakati page ina bit ya PXN, hata kama instruction fetch inatoka kwa level ya juu ya privilège, utekelezaji unaruhusiwa.

#### Matumizi ya kernel ya PAN / PXN katika OS iliyoimarishwa (mfano iOS / XNU)

Katika muundo wa kernel ulioboreshwa (kama alivyo efektishaji Apple):

- Kernel inawasha PAN kwa default (hivyo code ya privilegi inazuiwa).
- Katika njia ambazo kwa uhalali zinahitaji kusoma au kuandika buffers za user (mfano copy ya syscall buffer, I/O, read/write user pointer), kernel huwasha **kufuta PAN kwa muda** au hutumia instructions maalum kuzipita.
- Baada ya kumaliza upatikanaji wa data ya user, lazima irauli PAN.
- PXN inatekelezwa kupitia page tables: pages za user zina PXN = 1 (hivyo kernel hawezi kuzitekeleza), pages za kernel hazina PXN (hivyo code ya kernel inaweza kutekelezwa).
- Kernel lazima ihakikishe hakuna njia za code zinazosababisha utekelezaji wa flow kwenda kwenye maeneo ya memory ya user (ambayo ingepitisha PXN) — hivyo mlolongo wa exploit unaotegemea “kuruka kwenye shellcode ya user” unazuia.

Kwa sababu ya bypass ya PAN kupitia execute-only pages, katika mfumo halisi, Apple inaweza kuzima au kutoa ruhusa za execute-only kwa user pages, au kurekebisha kasoro ya specification.

#### Surfaces za mashambulizi, bypasses, na njia za kuzuia

- **PAN bypass via execute-only pages**: kama ilivyojadiliwa, spec inaruhusu pengo: pages za user zikiwa execute-only (bila read perm) huenda zisichukulwe kama “zinazopatikana kwa EL0,” hivyo PAN haitazuia kernel kusoma kutoka kwa pages hizo chini ya implementations fulani. Hii inampa mshambuliaji njia isiyo ya kawaida ya kusambaza data kupitia sehemu za “execute-only.”
- **Temporal window exploit**: ikiwa kernel inaondoa PAN kwa muda mrefu kuliko inavyohitajika, race au njia mbaya inaweza kutumia dirisha hilo kufanya access zisizo zinazotakiwa kwa memory ya user.
- **Forgotten re-enable**: ikiwa njia za code zinashindwa kurudisha PAN, utendaji wa kernel utakosa kuzuia upatikanaji wa user memory baadaye.
- **Misconfiguration of PXN**: ikiwa page tables hazowekwa PXN kwa user pages au kuandika upya mapping za user code pages, kernel inaweza kudanganywa kutekeleza code ya user-space.
- **Speculation / side-channels**: sambamba na speculative bypasses, kuna uwezekano wa athari za microarchitectural ambazo husababisha ukiukwaji wa muda mfupi wa ukaguzi wa PAN / PXN (ingawa mashambulizi kama haya yanategemea sana muundo wa CPU).
- **Complex interactions**: katika vipengele vya juu zaidi (mfano JIT, shared memory, maeneo ya code ya just-in-time), kernel inaweza kuhitaji udhibiti wa kina kuruhusu upatikanaji fulani wa memory au utekelezaji katika maeneo yaliyo-mapped kwa user; kubuni hilo kwa usalama chini ya vikwazo vya PAN/PXN siyo rahisi.

#### Mfano

<details>
<summary>Mfano wa Code</summary>
Hapa kuna mfululizo wa pseudo-assembly unaoonyesha kuwezesha/kufuta PAN kuzunguka upatikanaji wa memory ya user, na jinsi fault inaweza kutokea.
</details>
```  
// Suppose kernel entry point, PAN is enabled (privileged code cannot access user memory by default)

; Kernel receives a syscall with user pointer in X0
; wants to read an integer from user space
mov   X1, X0        ; X1 = user pointer

; disable PAN to allow privileged access to user memory
MSR   PSTATE.PAN, #0   ; clear PAN bit, disabling the restriction

ldr   W2, [X1]       ; now allowed load from user address

; re-enable PAN before doing other kernel logic
MSR   PSTATE.PAN, #1   ; set PAN

; ... further kernel work ...

; Later, suppose an exploit corrupts a pointer to a user-space code page and jumps there
BR    X3             ; branch to X3 (which points into user memory)

; Because the target page is marked PXN = 1 for privileged execution,
; the CPU throws an exception (fault) and rejects execution
```
Ikiwa kernel haikuwa imeweka PXN kwenye ukurasa huo wa mtumiaji, basi tawi linaweza kufanikiwa — jambo ambalo linge kuwa hatari.

Ikiwa kernel itasahau kuweka tena PAN baada ya ufikiaji wa kumbukumbu ya mtumiaji, inafungua dirisha ambapo mantiki zaidi ya kernel inaweza kwa bahati kusoma/kuandika kumbukumbu ya mtumiaji kwa bahati.

Ikiwa pointer ya mtumiaji iko kwenye ukurasa wa execute-only (ukurasa wa mtumiaji unaoruhusu tu execute, bila read/write), chini ya bug ya PAN spec, `ldr W2, [X1]` inaweza **isifanye** fault hata PAN ikiwa imewezeshwa, kuruhusu exploit ya bypass, kulingana na utekelezaji.

</details>

<details>
<summary>Mfano</summary>
Udhaifu wa kernel unajaribu kuchukua function pointer iliyotolewa na mtumiaji na kuiita katika muktadha wa kernel (yaani `call user_buffer`). Chini ya PAN/PXN, operesheni hiyo hairuhusiwi au inasababisha fault.
</details>

---

### 11. **Top Byte Ignore (TBI) / Pointer Tagging**
**Iliyoletwa katika ARMv8.5 / toleo jipya (au extension ya hiari)**
TBI inamaanisha top byte (baiti iliyo mbele kabisa) ya pointer ya 64-bit inatenguliwa na address translation. Hii inaruhusu OS au hardware kuweka bits za **tag** kwenye top byte ya pointer bila kuathiri anwani halisi.

- TBI inasimama kwa **Top Byte Ignore** (kwa wakati mwingine huitwa *Address Tagging*). Ni kipengele cha hardware (kinachopatikana katika utekelezaji mwingi wa ARMv8+) kinachotekeleza **kusahau baiti 8 za juu** (bits 63:56) za pointer ya 64-bit wakati wa kufanya **address translation / load/store / instruction fetch**.
- Kwa vitendo, CPU inachukulia pointer `0xTTxxxx_xxxx_xxxx` (ambapo `TT` = top byte) kama `0x00xxxx_xxxx_xxxx` kwa madhumuni ya address translation, ikitenga (kuweka mask) top byte. Top byte inaweza kutumiwa na software kuhifadhi **metadata / tag bits**.
- Hii inawapa software nafasi ya " ndani ya pointer" (in-band) kuhifadhi baiti ya tag kwenye kila pointer bila kubadilisha ni sehemu gani ya kumbukumbu inarejelewa.
- Architecture inahakikisha kuwa loads, stores, na instruction fetch huchukua pointer baada ya kuondoa top byte (yaani tag iliyoondolewa) kabla ya kufanya ufikiaji wa kumbukumbu.

Hivyo TBI inatenganisha **pointer la kimantiki** (pointer + tag) kutoka kwa **anwani ya kimwili** inayotumiwa kwa operesheni za kumbukumbu.

#### Kwa Nini TBI: Matumizi na msukumo

- **Pointer tagging / metadata**: Unaweza kuhifadhi metadata ya ziada (mf. aina ya object, toleo, bounds, integrity tags) kwenye top byte. Unapoitumia pointer baadaye, tag inatelekezwa na hardware, hivyo huhitaji kuifuta kwa mkono kabla ya ufikiaji wa kumbukumbu.
- **Memory tagging / MTE (Memory Tagging Extension)**: TBI ni msingi wa hardware ambao MTE inajengwa juu yake. Katika ARMv8.5, Memory Tagging Extension inatumia bits 59:56 za pointer kama **logical tag** na kuikagua dhidi ya **allocation tag** iliyohifadhiwa katika kumbukumbu.
- **Enhanced security & integrity**: Kwa kuunganisha TBI na pointer authentication (PAC) au ukaguzi wa wakati wa utekelezaji, unaweza kutaka si tu thamani ya pointer bali pia tag iwe sahihi. Mshambuliaji anayebadilisha pointer bila tag sahihi atasababisha tag isiyolingana.
- **Compatibility**: Kwa kuwa TBI ni hiari na tag bits zinasahauwa na hardware, nambari zilizokuwepo bila tag zinaendelea kufanya kazi kama kawaida. Tag bits kwa vitendo zinakuwa "dont care" kwa nambari za zamani.

#### Mfano
<details>
<summary>Mfano</summary>
Function pointer iliyo na tag kwenye top byte yake (tuseme `0xAA`). Exploit inafunika sehemu ya chini ya pointer lakini ikasahau tag, hivyo wakati kernel inathibitisha au kusanisha, pointer inashindwa au inakataliwa.
</details>

---

### 12. **Page Protection Layer (PPL)**
**Iliyoletwa katika iOS ya hivi karibuni / hardware za kisasa (iOS ~17 / Apple silicon / models za daraja la juu)** (ripoti kadhaa zinaonyesha PPL karibu macOS / Apple silicon, lakini Apple inaletza ulinzi kama huo kwa iOS)

- PPL imeundwa kama mipaka ya ulinzi ndani ya kernel: hata kama kernel (EL1) imevamiwa na ina uwezo wa read/write, **haipaswi kuwa na uwezo wa kubadilisha kwa uhuru** kurasa fulani za nyeti (hasa page tables, metadata ya code-signing, kurasa za code za kernel, entitlements, trust caches, n.k.).
- Kwa vitendo inaunda **"kernel ndani ya kernel"** — kipengele kidogo cha kuaminika (PPL) chenye **idhini iliyoongezwa** pekee ndicho kinaweza kubadilisha kurasa zilizolindwa. Msimamo mwingine wa kernel lazima uitumie PPL routines kufanya mabadiliko.
- Hii inapunguza eneo la mashambulizi kwa exploits za kernel: hata kwa R/W/execute kamili katika kernel mode, msaliti lazima pia apate kwa namna fulani kuingia katika eneo la PPL (au kuzunguka PPL) ili kubadilisha miundo muhimu.
- Katika Apple silicon za kisasa (A15+ / M2+), Apple inahamia kwa **SPTM (Secure Page Table Monitor)**, ambayo katika baadhi ya kesi inachukua nafasi ya PPL kwa ulinzi wa page-table katika platform hizo.

Hapa ni jinsi inavyodhaniwa PPL inavyofanya kazi, kulingana na uchambuzi wa umma:

#### Use of APRR / permission routing (APRR = Access Permission ReRouting)

- Hardware ya Apple inatumia mbinu inayoitwa **APRR (Access Permission ReRouting)**, ambayo inaruhusu page table entries (PTEs) kuwa na viashiria vidogo, badala ya biti za ruhusa kamili. Viashiria hivyo vina mapping kupitia rejista za APRR hadi ruhusa halisi. Hii inaruhusu upatanisho wa nguvu wa ruhusa kwa kila domain.
- PPL inatumia APRR kutenganisha mamlaka ndani ya muktadha wa kernel: ni tu domain ya PPL inayoruhusiwa kuboresha mapping kati ya viashiria na ruhusa za maana. Yaani, wakati code isiyo ya PPL ya kernel inafungua PTE au kujaribu kubadili biti za ruhusa, mantiki ya APRR hairuhusu (au inatekeleza kama read-only mapping).
- Code ya PPL yenyewe inaendesha katika eneo lililofungwa (mf. `__PPLTEXT`) ambalo kwa kawaida haliruhusiwi ku-execute au kuandikwa hadi milango ya kuingia ya muda iyaruhusu. Kernel inaita PPL entry points ("PPL routines") kutekeleza operesheni nyeti.

#### Gate / Entry & Exit

- Wakati kernel inahitaji kubadilisha ukurasa ulioletwa ulinzi (mf. kubadilisha ruhusa za kurasa za code ya kernel, au kubadilisha page tables), inaita kwenye **PPL wrapper** routine, ambayo hufanya uhalalisho kisha inabadilisha muktadha hadi eneo la PPL. Nje ya eneo hilo, kurasa zilizolindwa kwa vitendo ni kama read-only au hazinaweza kubadilishwa na kernel kuu.
- Wakati wa kuingia PPL, mappings za APRR zinabadilishwa ili kurasa za kumbukumbu katika eneo la PPL ziwe **executable & writable** ndani ya PPL. Baada ya kutoka, zinarudishwa kuwa read-only / non-writable. Hii inahakikisha kuwa ni PPL routines zilizokaguliwa vyema tu zinaweza kuandika kurasa zilizolindwa.
- Nje ya PPL, jaribio la code ya kernel kuandika kwenye kurasa zilizolindwa litafanyika fault (permission denied) kwa sababu mapping ya APRR kwa domain hiyo haijaruhusu uandishi.

#### Protected page categories

Kurasa ambazo PPL kawaida inalinda ni pamoja na:

- Muundo wa page table (translation table entries, metadata ya mapping)
- Kurasa za code za kernel, hasa zile zenye mantiki nyeti
- Metadata ya code-sign (trust caches, signature blobs)
- Jedwali la entitlements, jedwali la enforcement ya saini
- Miundo mingine ya kernel yenye thamani kubwa ambapo patch itaruhusu kuzunguka checks za saini au udanganyifu wa credentials

Wazo ni kwamba hata kama kumbukumbu ya kernel imekamatwa kabisa, mshambuliaji hawezi kusahili kubadilisha ama patch kurasa hizi, isipokuwa pia adhibiti PPL routines au azunguke PPL.

#### Known Bypasses & Vulnerabilities

1. **Project Zero’s PPL bypass (stale TLB trick)**

- Uandishi wa umma na Project Zero unaelezea bypass inayohusisha **stale TLB entries**.
- Wazo ni kama ifuatavyo:

1. Tengeneza kurasa mbili za fizikali A na B, zifanye kuwa kurasa za PPL (ili zilindwe).
2. Panga anwani mbili za virtual P na Q ambazo kurasa zao za L3 translation table zinatokana na A na B.
3. Sukuma thread iendelee kufikia Q, kudumisha entry yake kwenye TLB hai.
4. Iita `pmap_remove_options()` kuondoa mappings kuanzia P; kutokana na bug, code kwa bahati mbaya inaondoa TTEs za P na Q, lakini inabadilisha tu TLB entry kwa P, ikiacha entry ya Q kuwa stale na hai.
5. Tumia tena B (ukurasa wa table wa Q) kuwekeza maping ya kumbukumbu yoyote (mf. kurasa za PPL zilizolindwa) kwa anwani za virtual. Kwa sababu stale TLB entry bado inamap Q kama zamani, mapping hiyo inabaki halali kwa muktadha huo.
6. Kupitia hili, mshambuliaji anaweza kuweka mapping ya writable ya kurasa zilizolindwa za PPL bila kupitia interface ya PPL.

- Exploit hii ilihitaji udhibiti mzuri wa mapping za fizikali na tabia ya TLB. Inaonyesha kuwa mipaka ya usalama inayotegemea TLB / usahihi wa mapping lazima iwe makini sana kuhusu uhalali wa TLB invalidations na uthabiti wa mapping.

- Project Zero walielezea kwamba bypass kama hizi ni za nyeti na nadra, lakini zinawezekana katika mifumo ngumu. Hata hivyo, wanachukulia PPL kama ukarabati thabiti.

2. **Other potential hazards & constraints**

- Ikiwa exploit ya kernel inaweza moja kwa moja kuingia PPL routines (kwa kuiita PPL wrappers), inaweza kuzuru vizuizi. Kwa hivyo uthibitisho wa hoja (argument validation) ni muhimu.
- Bugs ndani ya code ya PPL yenyewe (mf. overflow za arithmetic, ukosefu wa ukaguzi wa mipaka) zinaweza kuruhusu urekebishaji nje ya mipaka ndani ya PPL. Project Zero waligundua kuwa bug katika `pmap_remove_options_internal()` ilitumika katika bypass yao.
- Mipaka ya PPL inategemea enforcement ya hardware (APRR, memory controller), kwa hivyo ni ile ile nguvu na utendaji wa utekelezaji wa hardware.

#### Mfano
<details>
<summary>Code Example</summary>
Here’s a simplified pseudocode / logic showing how a kernel might call into PPL to modify protected pages:
```c
// In kernel (outside PPL domain)
function kernel_modify_pptable(pt_addr, new_entry) {
// validate arguments, etc.
return ppl_call_modify(pt_addr, new_entry)  // call PPL wrapper
}

// In PPL (trusted domain)
function ppl_call_modify(pt_addr, new_entry) {
// temporarily enable write access to protected pages (via APRR adjustments)
aprr_set_index_for_write(PPL_INDEX)
// perform the modification
*pt_addr = new_entry
// restore permissions (make pages read-only again)
aprr_restore_default()
return success
}

// If kernel code outside PPL does:
*pt_addr = new_entry  // a direct write
// It will fault because APRR mapping for non-PPL domain disallows write to that page
```
The kernel can do many normal operations, but only through `ppl_call_*` routines can it change protected mappings or patch code.
</details>

<details>
<summary>Example</summary>
A kernel exploit tries to overwrite the entitlement table, or disable code-sign enforcement by modifying a kernel signature blob. Because that page is PPL-protected, the write is blocked unless going through the PPL interface. So even with kernel code execution, you cannot bypass code-sign constraints or modify credential data arbitrarily.
On iOS 17+ certain devices use SPTM to further isolate PPL-managed pages.
</details>

#### PPL → SPTM / Ubadilishaji / Mustakabali

- On Apple’s modern SoCs (A15 or later, M2 or later), Apple supports **SPTM** (Secure Page Table Monitor), which **replaces PPL** for page table protections.
- Apple calls out in documentation: “Page Protection Layer (PPL) and Secure Page Table Monitor (SPTM) enforce execution of signed and trusted code … PPL manages the page table permission overrides … Secure Page Table Monitor replaces PPL on supported platforms.”
- The SPTM architecture likely shifts more policy enforcement into a higher-privileged monitor outside kernel control, further reducing the trust boundary.

### MTE | EMTE | MIE

Here’s a higher-level description of how EMTE operates under Apple’s MIE setup:

1. **Ugawaji wa tag**
- When memory is allocated (e.g. in kernel or user space via secure allocators), a **secret tag** is assigned to that block.
- The pointer returned to the user or kernel includes that tag in its high bits (using TBI / top byte ignore mechanisms).

2. **Ukaguzi wa tag wakati wa ufikiaji**
- Whenever a load or store is executed using a pointer, the hardware checks that the pointer’s tag matches the memory block’s tag (allocation tag). If mismatch, it faults immediately (since synchronous).
- Because it's synchronous, there is no “delayed detection” window.

3. **Kuweka tag mpya wakati wa kuachilia / matumizi upya**
- When memory is freed, the allocator changes the block’s tag (so older pointers with old tags no longer match).
- A use-after-free pointer would therefore have a stale tag and mismatch when accessed.

4. **Utofauti wa tag za majirani ili kushika overflows**
- Adjacent allocations are given distinct tags. If a buffer overflow spills into neighbor’s memory, tag mismatch causes a fault.
- This is especially powerful in catching small overflows that cross boundary.

5. **Tag confidentiality enforcement**
- Apple must prevent tag values being leaked (because if attacker learns the tag, they could craft pointers with correct tags).
- They include protections (microarchitectural / speculative controls) to avoid side-channel leakage of tag bits.

6. **Integration ya kernel na user-space**
- Apple uses EMTE not just in user-space but also in kernel / OS-critical components (to guard kernel against memory corruption).
- The hardware/OS ensures tag rules apply even when kernel is executing on behalf of user space.

<details>
<summary>Example</summary>
```
Allocate A = 0x1000, assign tag T1
Allocate B = 0x2000, assign tag T2

// pointer P points into A with tag T1
P = (T1 << 56) | 0x1000

// Valid store
*(P + offset) = value // tag T1 matches allocation → allowed

// Overflow attempt: P’ = P + size_of_A (into B region)
*(P' + delta) = value
→ pointer includes tag T1 but memory block has tag T2 → mismatch → fault

// Free A, allocator retags it to T3
free(A)

// Use-after-free:
*(P) = value
→ pointer still has old tag T1, memory region is now T3 → mismatch → fault
```
</details>

#### Vikwazo na changamoto

- **Intrablock overflows**: Ikiwa overflow inabaki ndani ya allocation ile ile (haivuki boundary) na tag inabaki sawa, tag mismatch haitagundua.
- **Tag width limitation**: Kuna bits chache tu (mfano 4 bits, au domain ndogo) zinazopatikana kwa tag—nafasi ya majina ndogo.
- **Side-channel leaks**: Iki tag bits zinaweza be leaked (kupitia cache / speculative execution), mshambuliaji anaweza kujifunza valid tags na kuzuia kinga. Apple’s tag confidentiality enforcement inalenga kupunguza hili.
- **Performance overhead**: Angalizo za tag kwa kila load/store huongeza gharama; Apple lazima iboreshe hardware ili kupunguza overhead.
- **Compatibility & fallback**: Kwenye hardware ya zamani au sehemu zisizounga mkono EMTE, lazima kuwe na fallback. Apple inadai MIE imewezeshwa tu kwenye vifaa vinavyounga mkono.
- **Complex allocator logic**: Allocator lazima idhibiti tags, retagging, kuoanisha mipaka, na kuepuka mis-tag collisions. Mende katika mantiki ya allocator yanaweza kuleta vulnerabilities.
- **Mixed memory / hybrid areas**: Kumbukumbu fulani inaweza kubaki untagged (legacy), kufanya interoperability kuwa ngumu zaidi.
- **Speculative / transient attacks**: Kama ilivyo kwa kinga nyingi za microarchitectural, speculative execution au micro-op fusions zinaweza transiently bypass checks au leak tag bits.
- **Limited to supported regions**: Apple huenda itekeleze EMTE tu katika maeneo maalum yenye hatari kubwa (kernel, security-critical subsystems), si kote.

---

## Maboresho muhimu / tofauti ikilinganishwa na standard MTE

Here are the improvements and changes Apple emphasizes:

| Sifa | Original MTE | EMTE (Apple’s enhanced) / MIE |
|---|---:|---|
| **Check mode** | Supports synchronous and asynchronous modes. In async, tag mismatches are reported later (delayed)| Apple insists on **synchronous mode** by default—tag mismatches are caught immediately, no delay/race windows allowed.|
| **Coverage of non-tagged memory** | Accesses to non-tagged memory (e.g. globals) may bypass checks in some implementations | EMTE requires that accesses from a tagged region to non-tagged memory also validate tag knowledge, making it harder to bypass by mixing allocations.|
| **Tag confidentiality / secrecy** | Tags might be observable or leaked via side channels | Apple adds **Tag Confidentiality Enforcement**, which attempts to prevent leakage of tag values (via speculative side-channels etc.).|
| **Allocator integration & retagging** | MTE leaves much of allocator logic to software | Apple’s secure typed allocators (kalloc_type, xzone malloc, etc.) integrate with EMTE: when memory is allocated or freed, tags are managed at fine granularity.|
| **Always-on by default** | In many platforms, MTE is optional or off by default | Apple enables EMTE / MIE by default on supported hardware (e.g. iPhone 17 / A19) for kernel and many user processes.|

Kwa sababu Apple inadhibiti both hardware na software stack, inaweza kutekeleza EMTE kwa ukamilifu, kuepuka matatizo ya performance, na kufunga njia za side-channel.

---

## Jinsi EMTE inavyofanya kazi kwa vitendo (Apple / MIE)

Here’s a higher-level description of how EMTE operates under Apple’s MIE setup:

1. **Tag assignment**
- When memory is allocated (e.g. in kernel or user space via secure allocators), a **secret tag** is assigned to that block.
- The pointer returned to the user or kernel includes that tag in its high bits (using TBI / top byte ignore mechanisms).

2. **Tag checking on access**
- Whenever a load or store is executed using a pointer, the hardware checks that the pointer’s tag matches the memory block’s tag (allocation tag). If mismatch, it faults immediately (since synchronous).
- Because it's synchronous, there is no “delayed detection” window.

3. **Retagging on free / reuse**
- When memory is freed, the allocator changes the block’s tag (so older pointers with old tags no longer match).
- A use-after-free pointer would therefore have a stale tag and mismatch when accessed.

4. **Neighbor-tag differentiation to catch overflows**
- Adjacent allocations are given distinct tags. If a buffer overflow spills into neighbor’s memory, tag mismatch causes a fault.
- This is especially powerful in catching small overflows that cross boundary.

5. **Tag confidentiality enforcement**
- Apple must prevent tag values being leaked (because if attacker learns the tag, they could craft pointers with correct tags).
- They include protections (microarchitectural / speculative controls) to avoid side-channel leakage of tag bits.

6. **Kernel and user-space integration**
- Apple uses EMTE not just in user-space but also in kernel / OS-critical components (to guard kernel against memory corruption).
- The hardware/OS ensures tag rules apply even when kernel is executing on behalf of user space.

Kwa kuwa EMTE imejengwa ndani ya MIE, Apple inatumia EMTE katika synchronous mode katika maeneo muhimu ya mashambulizi, si kama opt-in au debugging mode.

---

## Exception handling in XNU

When an **exception** occurs (e.g., `EXC_BAD_ACCESS`, `EXC_BAD_INSTRUCTION`, `EXC_CRASH`, `EXC_ARM_PAC`, etc.), the **Mach layer** of the XNU kernel is responsible for intercepting it before it becomes a UNIX-style **signal** (like `SIGSEGV`, `SIGBUS`, `SIGILL`, ...).

Mchakato huu unahusisha tabaka kadhaa za exception propagation na handling kabla ya kufikia user space au kubadilishwa kuwa BSD signal.

### Mtiririko wa Exception (Ngazi ya Juu)

1.  **CPU triggers a synchronous exception** (e.g., invalid pointer dereference, PAC failure, illegal instruction, etc.).

2.  **Low-level trap handler** runs (`trap.c`, `exception.c` in XNU source).

3.  The trap handler calls **`exception_triage()`**, the core of the Mach exception handling.

4.  `exception_triage()` decides how to route the exception:

-   First to the **thread's exception port**.

-   Then to the **task's exception port**.

-   Then to the **host's exception port** (often `launchd` or `ReportCrash`).

If none of these ports handle the exception, the kernel may:

-   **Convert it into a BSD signal** (for user-space processes).

-   **Panic** (for kernel-space exceptions).


### Kazi Kuu: `exception_triage()`

The function `exception_triage()` routes Mach exceptions up the chain of possible handlers until one handles it or until it's finally fatal. It's defined in `osfmk/kern/exception.c`.
```c
void exception_triage(exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt);
```
**Mtiririko wa Kawaida:**

`exception_triage()
└── exception_deliver()
├── exception_deliver_thread()
├── exception_deliver_task()
└── exception_deliver_host()`

Ikiwa vyote vinashindwa → inashughulikiwa na `bsd_exception()` → hubadilishwa kuwa signal kama `SIGSEGV`.


### Exception Ports

Kila Mach object (thread, task, host) inaweza kujisajili **exception ports**, ambapo exception messages hutumwa.

Zimeainishwa na API:
```
task_set_exception_ports()
thread_set_exception_ports()
host_set_exception_ports()
```
Kila exception port ina:

-   A **mask** (ni exceptions gani inayotaka kupokea)
-   A **port name** (Mach port ya kupokea ujumbe)
-   A **behavior** (jinsi kernel inavyotuma ujumbe)
-   A **flavor** (ni thread state gani kujumuishwa)


### Debuggers and Exception Handling

A **debugger** (mfano, LLDB) huweka **exception port** kwenye task au thread lengwa, kawaida kwa kutumia `task_set_exception_ports()`.

**Wakati exception inapotokea:**

-   Ujumbe wa Mach hutumwa kwa process ya debugger.
-   Debugger inaweza kuamua **kushughulikia** (resume, badilisha registers, ruka instruction) au **kutoishughulikia** exception.
-   Ikiwa debugger haitashughulikia, exception inaendelea kwa ngazi inayofuata (task → host).


### Flow of `EXC_BAD_ACCESS`

1.  Thread inafanya dereference ya pointer batili → CPU inatoa Data Abort.

2.  Kernel trap handler inaita `exception_triage(EXC_BAD_ACCESS, ...)`.

3.  Ujumbe unatumwa kwa:

-   Thread port → (debugger inaweza kukamata breakpoint).

-   Ikiwa debugger inaepuka → Task port → (process-level handler).

-   Ikiwa pia haishughuliki → Host port (kawaida ReportCrash).

4.  Ikiwa hakuna anayeshughulikia → `bsd_exception()` inatafsiri kuwa `SIGSEGV`.


### PAC Exceptions

Wakati Pointer Authentication (PAC) inashindwa (signature mismatch), exception maalum ya Mach inazikwa:

-   **`EXC_ARM_PAC`** (aina)
-   Codes zinaweza kujumuisha maelezo (mfano, aina ya key, aina ya pointer).

Ikiwa binary ina flag **`TFRO_PAC_EXC_FATAL`**, kernel inachukulia PAC failures kama **fatal**, ikiepuka interception ya debugger. Hii ni kuzuia attackers kutumia debuggers kupita PAC checks na imewezeshwa kwa **platform binaries**.


### Software Breakpoints

A software breakpoint (`int3` on x86, `brk` on ARM64) hutekelezwa kwa **kusababisha fault kwa makusudi**.\
Debugger inakamata hili kupitia exception port:

-   Inabadilisha instruction pointer au memory.
-   Inarejesha instruction asili.
-   Inarudisha execution.

Mekanismo hiyo hiyo ndiyo inayo kuwezesha "kukamata" PAC exception --- **wanapo kuwekwa `TFRO_PAC_EXC_FATAL`**, basi haifiki kamwe kwa debugger.


### Conversion to BSD Signals

Ikiwa hakuna handler anayekubali exception:

-   Kernel inaita `task_exception_notify() → bsd_exception()`.

-   Hii inaweka mapping ya Mach exceptions kwa signals:

| Mach Exception | Signal |
| --- | --- |
| EXC_BAD_ACCESS | SIGSEGV or SIGBUS |
| EXC_BAD_INSTRUCTION | SIGILL |
| EXC_ARITHMETIC | SIGFPE |
| EXC_SOFTWARE | SIGTRAP |
| EXC_BREAKPOINT | SIGTRAP |
| EXC_CRASH | SIGKILL |
| EXC_ARM_PAC | SIGILL (on non-fatal) |


### Key Files in XNU Source

-   `osfmk/kern/exception.c` → Core of `exception_triage()`, `exception_deliver_*()`.

-   `bsd/kern/kern_sig.c` → Signal delivery logic.

-   `osfmk/arm64/trap.c` → Low-level trap handlers.

-   `osfmk/mach/exc.h` → Exception codes and structures.

-   `osfmk/kern/task.c` → Task exception port setup.

---

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

Kernel ilitumia **zone allocator** (`kalloc`) iliyogawanywa katika "zones" za ukubwa uliowekwa. Kila zone ilihifadhi tu allocations za class moja ya ukubwa.

From the screenshot:

| Jina la Zone | Ukubwa wa Kipengee | Matumizi Mfano                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Very small kernel structs, pointers.                                        |
| `default.kalloc.32`  | 32 bytes     | Small structs, object headers.                                              |
| `default.kalloc.64`  | 64 bytes     | IPC messages, tiny kernel buffers.                                          |
| `default.kalloc.128` | 128 bytes    | Medium objects like parts of `OSObject`.                                    |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Large structures, IOSurface/graphics metadata.                              |

Jinsi ilivyofanya kazi:
- Kila ombi la allocation liliwekewa **rounded up** hadi ukubwa wa zone uliokaribu.
(Mfano, ombi la 50-byte lilienda kwenye zone ya `kalloc.64`).
- Memory katika kila zone ilikuwa imehifadhiwa kwenye **freelist** — chunks zilizotolewa na kernel ziliarudi kwenye zone hiyo.
- Ikiwa ungelifanya overflow kwenye buffer ya 64-byte, ungeandika juu ya **kitu kinachofuata kwenye zone hiyo hiyo**.

Hii ndicho kilichofanya heap spraying / feng shui kuwa yenye ufanisi: ungeweza kutabiri majirani za object kwa ku-spray allocations za class moja ya ukubwa.

### The freelist

Ndani ya kila kalloc zone, vitu vilivyotolewa havirudi moja kwa moja kwenye system — viliingia kwenye freelist, linked list ya chunks zinazopatikana.

- Wakati chunk ilipotolewa, kernel iliandika pointer mwanzoni mwa chunk hiyo → anwani ya chunk inayofuata ya bure katika zone hiyo.

- Zone ilihifadhi pointer ya HEAD kwa chunk ya kwanza ya bure.

- Allocation ilitumia kila wakati HEAD ya sasa:

1. Pop HEAD (rudisha memory hiyo kwa mtumiaji).

2. Update HEAD = HEAD->next (inakaa kwenye header ya chunk iliyotolewa).

- Freeing ilirudisha chunks nyuma:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

Hivyo freelist ilikuwa tu linked list iliyojengwa ndani ya memory iliyotolewa yenyewe.

Normal state:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### Exploiting the freelist

Kwa sababu 8 bytes za kwanza za free chunk = freelist pointer, mshambuliaji anaweza kuharibu:

1. **Heap overflow** ndani ya adjacent freed chunk → kuandika tena “next” pointer yake.

2. **Use-after-free** andika ndani ya freed object → kuandika tena “next” pointer yake.

Kisha, kwenye allocation inayofuata ya ukubwa huo:

- Allocator inatoa corrupted chunk.

- Inafuata attacker-supplied “next” pointer.

- Inarudisha pointer kwa arbitrary memory, ikiruhusu fake object primitives au targeted overwrite.

Mfano wa kuona wa freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
Cette freelist design made exploitation highly effective pre-hardening: predictable neighbors from heap sprays, raw pointer freelist links, and no type separation allowed attackers to escalate UAF/overflow bugs into arbitrary kernel memory control.

### Heap Grooming / Feng Shui
The goal of heap grooming is to **shape the heap layout** so that when an attacker triggers an overflow or use-after-free, the target (victim) object sits right next to an attacker-controlled object.\
That way, when memory corruption happens, the attacker can reliably overwrite the victim object with controlled data.

**Steps:**

1. Spray allocations (fill the holes)
- Over time, the kernel heap gets fragmented: some zones have holes where old
objects were freed.
- The attacker first makes lots of dummy allocations to fill these gaps, so
the heap becomes “packed” and predictable.

2. Force new pages
- Once the holes are filled, the next allocations must come from new pages
added to the zone.
- Fresh pages mean objects will be clustered together, not scattered across
old fragmented memory.
- This gives the attacker much better control of neighbors.

3. Place attacker objects
- The attacker now sprays again, creating lots of attacker-controlled objects
in those new pages.
- These objects are predictable in size and placement (since they all belong
to the same zone).

4. Free a controlled object (make a gap)
- The attacker deliberately frees one of their own objects.
- This creates a “hole” in the heap, which the allocator will later reuse for
the next allocation of that size.

5. Victim object lands in the hole
- The attacker triggers the kernel to allocate the victim object (the one
they want to corrupt).
- Since the hole is the first available slot in the freelist, the victim is
placed exactly where the attacker freed their object.

6. Overflow / UAF into victim
- Now the attacker has attacker-controlled objects around the victim.
- By overflowing from one of their own objects (or reusing a freed one), they
can reliably overwrite the victim’s memory fields with chosen values.

**Why it works**:

- Zone allocator predictability: allocations of the same size always come from
the same zone.
- Freelist behavior: new allocations reuse the most recently freed chunk first.
- Heap sprays: attacker fills memory with predictable content and controls layout.
- End result: attacker controls where the victim object lands and what data sits
next to it.

---

## Ganda la Kernel la Kisasa (iOS 15+/A12+ SoCs)

Apple hardened the allocator and made **heap grooming much harder**:

### 1. From Classic kalloc to kalloc_type
- **Before**: a single `kalloc.<size>` zone existed for each size class (16, 32, 64, … 1280, etc.). Any object of that size was placed there → attacker objects could sit next to privileged kernel objects.
- **Now**:
- Kernel objects are allocated from **typed zones** (`kalloc_type`).
- Each type of object (e.g., `ipc_port_t`, `task_t`, `OSString`, `OSData`) has its own dedicated zone, even if they’re the same size.
- The mapping between object type ↔ zone is generated from the **kalloc_type system** at compile time.

An attacker can no longer guarantee that controlled data (`OSData`) ends up adjacent to sensitive kernel objects (`task_t`) of the same size.

### 2. Slabs and Per-CPU Caches
- The heap is divided into **slabs** (pages of memory carved into fixed-size chunks for that zone).
- Each zone has a **per-CPU cache** to reduce contention.
- Allocation path:
1. Try per-CPU cache.
2. If empty, pull from the global freelist.
3. If freelist is empty, allocate a new slab (one or more pages).
- **Benefit**: This decentralization makes heap sprays less deterministic, since allocations may be satisfied from different CPUs’ caches.

### 3. Randomization inside zones
- Within a zone, freed elements are not handed back in simple FIFO/LIFO order.
- Modern XNU uses **encoded freelist pointers** (safe-linking like Linux, introduced ~iOS 14).
- Each freelist pointer is **XOR-encoded** with a per-zone secret cookie.
- This prevents attackers from forging a fake freelist pointer if they gain a write primitive.
- Some allocations are **randomized in their placement within a slab**, so spraying doesn’t guarantee adjacency.

### 4. Guarded Allocations
- Certain critical kernel objects (e.g., credentials, task structures) are allocated in **guarded zones**.
- These zones insert **guard pages** (unmapped memory) between slabs or use **redzones** around objects.
- Any overflow into the guard page triggers a fault → immediate panic instead of silent corruption.

### 5. Page Protection Layer (PPL) and SPTM
- Even if you control a freed object, you can’t modify all of kernel memory:
- **PPL (Page Protection Layer)** enforces that certain regions (e.g., code signing data, entitlements) are **read-only** even to the kernel itself.
- On **A15/M2+ devices**, this role is replaced/enhanced by **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**.
- These hardware-enforced layers mean attackers can’t escalate from a single heap corruption to arbitrary patching of critical security structures.
- **(Added / Enhanced)**: also, **PAC (Pointer Authentication Codes)** is used in the kernel to protect pointers (especially function pointers, vtables) so that forging or corrupting them becomes harder.
- **(Added / Enhanced)**: zones may enforce **zone_require / zone enforcement**, i.e. that an object freed can only be returned through its correct typed zone; invalid cross-zone frees may panic or be rejected. (Apple alludes to this in their memory safety posts)

### 6. Large Allocations
- Not all allocations go through `kalloc_type`.
- Very large requests (above ~16 KB) bypass typed zones and are served directly from **kernel VM (kmem)** via page allocations.
- These are less predictable, but also less exploitable, since they don’t share slabs with other objects.

### 7. Allocation Patterns Attackers Target
Even with these protections, attackers still look for:
- **Reference count objects**: if you can tamper with retain/release counters, you may cause use-after-free.
- **Objects with function pointers (vtables)**: corrupting one still yields control flow.
- **Shared memory objects (IOSurface, Mach ports)**: these are still attack targets because they bridge user ↔ kernel.

But — unlike before — you can’t just spray `OSData` and expect it to neighbor a `task_t`. You need **type-specific bugs** or **info leaks** to succeed.

### Example: Allocation Flow in Modern Heap

Suppose userspace calls into IOKit to allocate an `OSData` object:

1. **Type lookup** → `OSData` maps to `kalloc_type_osdata` zone (size 64 bytes).
2. Check per-CPU cache for free elements.
- If found → return one.
- If empty → go to global freelist.
- If freelist empty → allocate a new slab (page of 4KB → 64 chunks of 64 bytes).
3. Return chunk to caller.

**Freelist pointer protection**:
- Each freed chunk stores the address of the next free chunk, but encoded with a secret key.
- Overwriting that field with attacker data won’t work unless you know the key.

---

## Jedwali la Mlinganisho

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages, and **PAC** protects pointers |
| Allocation reuse validation     | None (freelist pointers raw)                               | **zone_require / zone enforcement**             |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |
| Large allocations handling      | All small allocations managed equally                       | Large ones bypass zones → handled via VM         |

---

## Ganda la Userland la Kisasa (iOS, macOS — type-aware / xzone malloc)

In recent Apple OS versions (especially iOS 17+), Apple introduced a more secure userland allocator, **xzone malloc** (XZM). This is the user-space analog to the kernel’s `kalloc_type`, applying type awareness, metadata isolation, and memory tagging safeguards.

### Goals & Design Principles

- **Type segregation / type awareness**: group allocations by *type or usage (pointer vs data)* to prevent type confusion and cross-type reuse.
- **Metadata isolation**: separate heap metadata (e.g. free lists, size/state bits) from object payloads so that out-of-bounds writes are less likely to corrupt metadata.
- **Guard pages / redzones**: insert unmapped pages or padding around allocations to catch overflows.
- **Memory tagging (EMTE / MIE)**: work in conjunction with hardware tagging to detect use-after-free, out-of-bounds, and invalid accesses.
- **Scalable performance**: maintain low overhead, avoid excessive fragmentation, and support many allocations per second with low latency.

### Architecture & Components

Below are the main elements in the xzone allocator:

#### Segment Groups & Zones

- **Segment groups** partition the address space by usage categories: e.g. `data`, `pointer_xzones`, `data_large`, `pointer_large`.
- Each segment group contains **segments** (VM ranges) that host allocations for that category.
- Associated with each segment is a **metadata slab** (separate VM area) that stores metadata (e.g. free/used bits, size classes) for that segment. This **out-of-line (OOL) metadata** ensures that metadata is not intermingled with object payloads, mitigating corruption from overflows.
- Segments are carved into **chunks** (slices) which in turn are subdivided into **blocks** (allocation units). A chunk is tied to a specific size class and segment group (i.e. all blocks in a chunk share the same size & category).
- For small / medium allocations, it will use fixed-size chunks; for large/huges, it may map separately.

#### Chunks & Blocks

- A **chunk** is a region (often several pages) dedicated to allocations of one size class within a group.
- Inside a chunk, **blocks** are slots available for allocations. Freed blocks are tracked via the metadata slab — e.g. via bitmaps or free lists stored out-of-line.
- Between chunks (or within), **guard slices / guard pages** may be inserted (e.g. unmapped slices) to catch out-of-bounds writes.

#### Type / Type ID

- Every allocation site (or call to malloc, calloc, etc.) is associated with a **type identifier** (a `malloc_type_id_t`) which encodes what kind of object is being allocated. That type ID is passed to the allocator, which uses it to select which zone / segment to serve the allocation.
- Because of this, even if two allocations have the same size, they may go into entirely different zones if their types differ.
- In early iOS 17 versions, not all APIs (e.g. CFAllocator) were fully type-aware; Apple addressed some of those weaknesses in iOS 18.

---

### Allocation & Freeing Workflow

Here is a high-level flow of how allocation and deallocation operate in xzone:

1. **malloc / calloc / realloc / typed alloc** is invoked with a size and type ID.
2. The allocator uses the **type ID** to pick the correct segment group / zone.
3. Within that zone/segment, it seeks a chunk that has free blocks of the requested size.
- It may consult **local caches / per-thread pools** or **free block lists** from metadata.
- If no free block is available, it may allocate a new chunk in that zone.
4. The metadata slab is updated (free bit cleared, bookkeeping).
5. If memory tagging (EMTE) is in play, the returned block gets a **tag** assigned, and metadata is updated to reflect its “live” state.
6. When `free()` is called:
- The block is marked as freed in metadata (via OOL slab).
- The block may be placed into a free list or pooled for reuse.
- Optionally, block contents may be cleared or poisoned to reduce data leaks or use-after-free exploitation.
- The hardware tag associated with the block may be invalidated or re-tagged.
- If an entire chunk becomes free (all blocks freed), the allocator may **reclaim** that chunk (unmap it or return to OS) under memory pressure.

---

### Security Features & Hardening

These are the defenses built into modern userland xzone:

| Feature | Purpose | Notes |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | Prevent overflow from corrupting metadata | Metadata lives in separate VM region (metadata slab)|
| **Guard pages / unmapped slices** | Catch out-of-bounds writes | Helps detect buffer overflows rather than silently corrupting adjacent blocks|
| **Type-based segregation** | Prevent cross-type reuse & type confusion | Even same-size allocations from different types go to different zones|
| **Memory Tagging (EMTE / MIE)** | Detect invalid access, stale references, OOB, UAF | xzone works in concert with hardware EMTE in synchronous mode (“Memory Integrity Enforcement”)|
| **Delayed reuse / poisoning / zap** | Reduce chance of use-after-free exploitation | Freed blocks may be poisoned, zeroed, or quarantined before reuse |
| **Chunk reclamation / dynamic unmapping** | Reduce memory waste and fragmentation | Entire chunks may be unmapped when unused |
| **Randomization / placement variation** | Prevent deterministic adjacency | Blocks in a chunk and chunk selection may have randomized aspects |
| **Segregation of “data-only” allocations** | Separate allocations that don’t store pointers | Reduces attacker control over metadata or control fields|

---

### Interaction with Memory Integrity Enforcement (MIE / EMTE)

- Apple’s MIE (Memory Integrity Enforcement) is the hardware + OS framework that brings **Enhanced Memory Tagging Extension (EMTE)** into always-on, synchronous mode across major attack surfaces.
- xzone allocator is a fundamental foundation of MIE in user space: allocations done via xzone get tags, and accesses are checked by hardware.
- In MIE, the allocator, tag assignment, metadata management, and tag confidentiality enforcement are integrated to ensure that memory errors (e.g. stale reads, OOB, UAF) are caught immediately, not exploited later.

---

If you like, I can also generate a cheat-sheet or diagram of xzone internals for your book. Do you want me to do that next?
::contentReference[oaicite:20]{index=20}


---

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
