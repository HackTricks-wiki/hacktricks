# iOS Exploiting

{{#include ../../banners/hacktricks-training.md}}

## iOS Exploit Mitigations

### 1. **Code Signing** / Runtime Signature Verification
**Introduced early (iPhone OS → iOS)**
이것은 기본적인 보호 중 하나입니다: **all executable code**(apps, dynamic libraries, JIT-ed code, extensions, frameworks, caches)는 Apple의 신뢰로 루팅된 인증서 체인으로 암호학적으로 서명되어야 합니다. 런타임에서는 바이너리를 메모리에 로드하기 전에(또는 특정 경계를 넘는 점프를 수행하기 전에) 시스템이 서명을 검사합니다. 코드가 수정되었거나(bit-flipped, patched) 서명되지 않은 경우 로드가 실패합니다.

- **Thwarts**: “classic payload drop + execute” 단계 in exploit chains; arbitrary code injection; 기존 바이너리를 수정해 악성 로직을 삽입하는 것.
- **Mechanism detail**:
* Mach-O loader(및 dynamic linker)는 코드 페이지, 세그먼트, entitlements, team IDs, 그리고 서명이 파일 내용 전체를 덮고 있는지를 확인합니다.
* JIT caches나 동적으로 생성된 코드 같은 메모리 영역의 경우, Apple은 페이지가 서명되었거나 특수 API(예: `mprotect` with code-sign checks)를 통해 검증되도록 강제합니다.
* 서명에는 entitlements와 식별자가 포함되며, OS는 특정 API나 권한 있는 기능이 특정 entitlements를 요구한다는 것을 강제합니다(위조 불가).

<details>
<summary>Example</summary>
예를 들어 익스플릿이 프로세스에서 코드 실행을 얻어 힙에 shellcode를 쓰고 그곳으로 점프하려고 한다고 합시다. iOS에서는 해당 페이지가 실행 가능으로 표시될 뿐만 아니라 code-signature 제약을 만족해야 합니다. 그 shellcode는 Apple의 인증으로 서명되어 있지 않기 때문에 점프가 실패하거나 시스템이 해당 메모리 영역을 실행 가능으로 만드는 것을 거부합니다.
</details>


### 2. **CoreTrust**
**Introduced around iOS 14+ era (or gradually in newer devices / later iOS)**
CoreTrust는 바이너리(시스템 및 사용자 바이너리 포함)의 런타임 서명 검증을 수행하는 서브시스템으로, 로컬 유저랜드 신뢰 저장소에 의존하지 않고 **Apple의 루트 인증서**에 대해 검증합니다.

- **Thwarts**: 설치 후 바이너리 변조, jailbreaking 기법으로 시스템 라이브러리나 사용자 앱을 교체하거나 패치하려는 시도; 신뢰된 바이너리를 악성 바이너리로 바꿔 시스템을 속이는 시도.
- **Mechanism detail**:
* 로컬 트러스트 데이터베이스나 인증서 캐시를 신뢰하는 대신, CoreTrust는 Apple의 루트를 직접 참조하거나 보안 체인에서 중간 인증서를 검증합니다.
* 기존 바이너리에 대한 변경(e.g. filesystem상의 수정)을 감지하고 거부합니다.
* entitlements, team IDs, code signing 플래그 및 기타 메타데이터를 로드 시점에 바이너리에 연계합니다.

<details>
<summary>Example</summary>
jailbreak이 `SpringBoard`나 `libsystem`을 패치된 버전으로 교체해 persistence를 얻으려 할 수 있습니다. 하지만 OS의 loader나 CoreTrust가 검사를 수행하면 서명 불일치(또는 변경된 entitlements)를 감지하고 실행을 거부합니다.
</details>


### 3. **Data Execution Prevention (DEP / NX / W^X)**
**Introduced in many OSes earlier; iOS had NX-bit / w^x for a long time**
DEP는 쓰기 가능한 페이지(데이터용)는 **실행 불가**, 실행 가능한 페이지는 **쓰기 불가**로 강제합니다. 단순히 힙이나 스택에 shellcode를 쓰고 이를 실행할 수 없습니다.

- **Thwarts**: 직접적인 shellcode 실행; 고전적인 buffer-overflow → injected shellcode로 점프하는 기법.
- **Mechanism detail**:
* MMU / 메모리 보호 플래그(페이지 테이블을 통해)가 분리를 강제합니다.
* 쓰기 가능한 페이지를 실행 가능으로 표시하려는 시도는 시스템 검사를 유발하며(금지되거나 code-sign 승인이 필요).
* 많은 경우 페이지를 실행 가능으로 만들려면 추가 제약이나 검사를 강제하는 OS API를 통해야 합니다.

<details>
<summary>Example</summary>
오버플로우로 shellcode가 힙에 기록됩니다. 공격자는 `mprotect(heap_addr, size, PROT_EXEC)`을 시도해 실행 가능으로 만들려고 합니다. 그러나 시스템은 이를 거부하거나 새로운 페이지가 code-sign 제약을 통과해야 한다고 검증합니다(그 shellcode는 통과하지 못합니다).
</details>

### 4. **Address Space Layout Randomization (ASLR)**
**Introduced in iOS ~4–5 era (roughly iOS 4–5 timeframe)**
ASLR은 라이브러리, heap, stack 등 주요 메모리 영역의 베이스 주소를 각 프로세스 실행 시 무작위화합니다. gadget 주소가 실행마다 이동합니다.

- **Thwarts**: ROP/JOP에 대해 gadget 주소를 하드코딩하는 것; 정적 exploit 체인; 알려진 오프셋으로의 블라인드 점프.
- **Mechanism detail**:
* 로드된 각 라이브러리 / 동적 모듈은 무작위화된 오프셋으로 rebased됩니다.
* 스택과 힙의 베이스 포인터는(일정한 엔트로피 한도 내에서) 무작위화됩니다.
* 때때로 다른 영역(e.g. mmap 할당)도 무작위화됩니다.
* information-leak mitigations과 결합되어, 공격자는 런타임에 베이스 주소를 알아내기 위해 먼저 주소를 leak해야 합니다.

<details>
<summary>Example</summary>
ROP 체인이 `0x….lib + offset`에 있는 gadget을 기대합니다. 하지만 `lib`가 실행마다 다르게 재배치되므로 하드코딩된 체인은 실패합니다. 익스플릿은 모듈의 베이스 주소를 알아내기 위해 먼저 주소를 leak해야 합니다.
</details>


### 5. **Kernel Address Space Layout Randomization (KASLR)**
**Introduced in iOS ~ (iOS 5 / iOS 6 timeframe)**
사용자 ASLR과 유사하게, KASLR은 부팅 시 **kernel text** 및 기타 커널 구조의 베이스를 무작위화합니다.

- **Thwarts**: 고정된 커널 코드나 데이터 위치에 의존하는 kernel-level exploit; 정적 커널 익스플릿.
- **Mechanism detail**:
* 부팅마다 커널의 베이스 주소가 범위 내에서 무작위화됩니다.
* `task_structs`, `vm_map` 등과 같은 커널 데이터 구조도 재배치되거나 오프셋이 적용될 수 있습니다.
* 공격자는 커널 포인터를 먼저 leak하거나 information disclosure 취약점을 이용해 오프셋을 계산해야 커널 구조나 코드를 탈취할 수 있습니다.

<details>
<summary>Example</summary>
로컬 취약점이 `KERN_BASE + offset`의 커널 함수 포인터(vtable 등)를 훼손하려 합니다. 그러나 `KERN_BASE`가 알려지지 않았기 때문에 공격자는 먼저 주소를 leak(예: 읽기 원시능력)해 올바른 오프셋을 계산해야 합니다.
</details>


### 6. **Kernel Patch Protection (KPP / AMCC)**
**Introduced in newer iOS / A-series hardware (post around iOS 15–16 era or newer chips)**
KPP(aka AMCC)는 커널 텍스트 페이지의 무결성을 지속적으로 모니터링합니다(해시나 체크섬을 통해). 허용된 창 밖에서 패치(인라인 후킹, 코드 수정)가 감지되면 커널 패닉이나 리부트가 발생합니다.

- **Thwarts**: 지속적인 커널 패칭(커널 명령어 수정), 인라인 후킹, 정적 함수 오버라이트.
- **Mechanism detail**:
* 하드웨어나 펌웨어 모듈이 커널 텍스트 영역을 모니터링합니다.
* 주기적이거나 온디맨드로 페이지를 재해싱하고 예상 값과 비교합니다.
* 악성 변경이 허용된 업데이트 창 밖에서 발생하면 기기를 패닉시켜(영구적인 악성 패치를 방지) 재부팅합니다.
* 공격자는 감지 창을 피하거나 합법적인 패치 경로를 사용해야 합니다.

<details>
<summary>Example</summary>
익스플릿이 커널 함수 프로로그(e.g. `memcmp`)를 패치해 호출을 가로채려 합니다. 그러나 KPP는 코드 페이지의 해시가 예상 값과 일치하지 않음을 감지하고 커널 패닉을 유발해 패치가 안정화되기 전에 장치를 크래시시킵니다.
</details>


### 7. **Kernel Text Read‐Only Region (KTRR)**
**Introduced in modern SoCs (post ~A12 / newer hardware)**
KTRR은 하드웨어로 강제되는 메커니즘입니다: 부팅 초기에 커널 텍스트가 잠기면 EL1(커널)에서 해당 코드 페이지에 대한 쓰기가 불가능해집니다.

- **Thwarts**: 부팅 이후의 커널 코드 수정(예: 패칭, 인플레이스 코드 주입) — EL1 권한 레벨에서의 시도.
- **Mechanism detail**:
* 부트(secure/bootloader 단계) 동안 메모리 컨트롤러(또는 보안 하드웨어 유닛)가 커널 텍스트를 포함한 물리 페이지를 읽기 전용으로 표시합니다.
* 익스플릿이 커널 권한을 얻더라도 해당 페이지를 쓰기 위해 패치할 수 없습니다.
* 이를 수정하려면 공격자는 부트 체인을 먼저 손상시키거나 KTRR 자체를 무력화해야 합니다.

<details>
<summary>Example</summary>
권한 상승 익스플릿이 EL1로 점프해 kernel 함수에 트램폴린을 쓰려고 합니다(e.g. `syscall` 핸들러). 하지만 페이지가 KTRR로 읽기 전용으로 잠겨 있기 때문에 쓰기가 실패하거나 fault를 유발해 패치가 적용되지 않습니다.
</details>


### 8. **Pointer Authentication Codes (PAC)**
**Introduced with ARMv8.3 (hardware), Apple beginning with A12 / iOS ~12+**
- PAC는 **ARMv8.3-A**에서 도입된 하드웨어 기능으로, 포인터 값(리턴 주소, 함수 포인터, 특정 데이터 포인터)의 변조를 감지하기 위해 포인터의 사용되지 않는 상위 비트에 작은 암호화 서명(“MAC”)을 삽입합니다.
- 서명(“PAC”)은 포인터 값과 **modifier**(컨텍스트 값, 예: 스택 포인터나 구분 데이터)를 입력으로 계산됩니다. 그래서 동일한 포인터 값이라도 컨텍스트가 다르면 다른 PAC가 생성됩니다.
- 사용 시점에서는 해당 포인터를 역참조하거나 분기하기 전에 **authenticate** 명령어가 PAC를 검사합니다. 유효하면 PAC를 제거하고 순수한 포인터를 얻고, 유효하지 않으면 포인터가 “poisoned”되거나 fault가 발생합니다.
- PAC를 생성/검증하는 키는 권한 레지스터(EL1, 커널)에 존재하며 유저 모드에서 직접 읽을 수 없습니다.
- 많은 시스템에서 포인터의 모든 64비트를 사용하지 않기 때문에(e.g. 48-bit 주소 공간), 상위 비트는 PAC를 담는 데 여유가 있습니다.

#### Architectural Basis & Key Types

- ARMv8.3는 **다섯 개의 128-bit 키**를 도입합니다(각각 두 개의 64-bit 시스템 레지스터로 구현).
- **APIAKey** — instruction pointers 용(domain “I”, key A)
- **APIBKey** — 두 번째 instruction pointer 키(domain “I”, key B)
- **APDAKey** — data pointers 용(domain “D”, key A)
- **APDBKey** — data pointers 용(domain “D”, key B)
- **APGAKey** — generic 키, 포인터가 아닌 데이터나 기타 일반적 용도로 서명

- 이 키들은 권한 있는 시스템 레지스터에 저장되어(EL1/EL2 등에서만 접근 가능) 유저 모드에서는 접근 불가합니다.
- PAC는 암호화 함수(ARM이 QARMA를 권장)를 통해 계산됩니다. 입력은:
1. 포인터 값(정규화된 부분)
2. **modifier**(스택 포인터 같은 컨텍스트 값)
3. 비밀 키
4. 내부 튜닝 로직
결과 PAC가 포인터의 상위 비트에 저장된 값과 일치하면 인증이 성공합니다.


#### Instruction Families

명명 규칙은: **PAC** / **AUT** / **XPAC**, 그 다음 도메인 문자입니다.
- `PACxx` 명령어는 포인터에 서명하고 PAC를 삽입합니다.
- `AUTxx` 명령어는 PAC를 **authenticate + strip**(검증 후 제거)합니다.
- `XPACxx` 명령어는 검증 없이 PAC를 제거합니다.

Domains / suffixes:

| Mnemonic     | Meaning / Domain                      | Key / Domain     | Example Usage in Assembly |
|--------------|-----------------------------------------|--------------------|-----------------------------|
| **PACIA**    | Sign instruction pointer with APIAKey   | “I, A”             | `PACIA X0, X1` — sign pointer in X0 using APIAKey with modifier X1|
| **PACIB**    | Sign instruction pointer with APIBKey   | “I, B”             | `PACIB X2, X3`              |
| **PACDA**    | Sign data pointer with APDAKey           | “D, A”             | `PACDA X4, X5`              |
| **PACDB**    | Sign data pointer with APDBKey           | “D, B”             | `PACDB X6, X7`              |
| **PACG / PACGA** | Generic (non-pointer) signing with APGAKey | “G”         | `PACGA X8, X9, X10` (sign X9 with modifier X10 into X8) |
| **AUTIA**    | Authenticate APIA-signed instruction pointer & strip PAC | “I, A” | `AUTIA X0, X1` — check PAC on X0 using modifier X1, then strip |
| **AUTIB**    | Authenticate APIB domain                 | “I, B”             | `AUTIB X2, X3`               |
| **AUTDA**    | Authenticate APDA-signed data pointer    | “D, A”             | `AUTDA X4, X5`               |
| **AUTDB**    | Authenticate APDB-signed data pointer    | “D, B”             | `AUTDB X6, X7`               |
| **AUTGA**    | Authenticate generic / blob (APGA)        | “G”               | `AUTGA X8, X9, X10` (validate generic) |
| **XPACI**     | Strip PAC (instruction pointer, no validation) | “I”         | `XPACI X0` — remove PAC from X0 (instruction domain) |
| **XPACD**     | Strip PAC (data pointer, no validation)    | “D”             | `XPACD X4` — remove PAC from data pointer in X4 |


There are specialized / alias forms:

- `PACIASP` is shorthand for `PACIA X30, SP` (sign the link register using SP as modifier)
- `AUTIASP` is `AUTIA X30, SP` (authenticate link register with SP)
- Combined forms like `RETAA`, `RETAB` (authenticate-and-return) or `BLRAA` (authenticate & branch) exist in ARM extensions / compiler support.
- Also zero-modifier variants: `PACIZA` / `PACIZB` where the modifier is implicitly zero, etc.

#### Modifiers

modifier의 주요 목적은 PAC를 특정 컨텍스트에 묶는 것입니다. 동일한 주소에 서명하더라도 다른 컨텍스트에서는 다른 PAC가 생성됩니다. 이는 포인터 재사용을 방지하는 일종의 salt 역할을 합니다.

따라서:
- **modifier**는 PAC 계산에 혼합되는 컨텍스트 값(다른 레지스터)입니다. 일반적인 선택: stack pointer(`SP`), frame pointer, 또는 객체 ID 등.
- SP를 modifier로 사용하는 것은 리턴 주소 서명에 흔히 사용됩니다: PAC가 특정 스택 프레임에 묶이게 됩니다. 다른 프레임에서 LR을 재사용하려 하면 modifier가 달라져 PAC 검증이 실패합니다.
- 동일한 포인터 값이라도 다른 modifier로 서명하면 다른 PAC를 생성합니다.
- modifier는 반드시 비밀일 필요는 없지만 이상적으로는 공격자가 제어할 수 없어야 합니다.
- 의미 있는 modifier가 없는 경우 일부 명령은 0이나 암묵적 상수를 사용합니다.

#### Apple / iOS / XNU Customizations & Observations

- Apple의 PAC 구현에는 **per-boot diversifiers**가 포함되어 부팅마다 키나 튜닝값이 변경되어 부팅 간 재사용을 방지합니다.
- 또한 도메인 간 완화책(cross-domain mitigations)이 있어 user mode에서 서명된 PAC가 kernel 모드에서 쉽게 재사용되지 않도록 합니다.
- Apple M1 / Apple Silicon에서 리버스 엔지니어링 결과 **아홉 가지 modifier 타입**과 키 제어용 Apple 전용 시스템 레지스터가 있음이 드러났습니다.
- Apple은 많은 커널 서브시스템에 PAC를 사용합니다: 리턴 주소 서명, 커널 데이터의 포인터 무결성, 서명된 스레드 컨텍스트 등.
- Google Project Zero는 강력한 커널 메모리 읽기/쓰기 원시 기능이 있을 때 일부 커널 PAC(A 키)를 위조할 수 있음을 보였고(A12-era), Apple은 그 경로들을 패치했습니다.
- Apple 시스템에서는 일부 키가 **커널 전역**으로 사용되는 반면, 사용자 프로세스는 프로세스별 키 랜덤화를 받을 수 있습니다.

#### PAC Bypasses

1. **Kernel-mode PAC: theoretical vs real bypasses**

-   커널 PAC 키와 로직은 엄격히 통제(권한 레지스터, diversifiers, 도메인 분리)되므로 임의의 서명된 커널 포인터를 위조하는 것은 매우 어렵습니다.
-   Azad의 2020 "iOS Kernel PAC, One Year Later"는 iOS 12-13에서 몇 가지 부분적 우회(signing gadgets, reuse of signed states, unprotected indirect branches)를 발견했지만 범용 우회는 없었다고 보고합니다. [bazad.github.io](https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf)
-   Apple의 "Dark Magic" 커스터마이제이션은 공격 표면을 더 좁혔습니다(domain switching, per-key enabling bits). [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   Apple silicon(M1/M2)에서 알려진 **kernel PAC bypass CVE-2023-32424**가 Zecao Cai 등에게 보고되었습니다. [i.blackhat.com](https://i.blackhat.com/BH-US-23/Presentations/US-23-Zec-Apple-PAC-Four-Years-Later.pdf)
-   그러나 이러한 우회는 종종 매우 특정한 gadget 또는 구현 버그에 의존하며, 일반적인 우회는 아닙니다.

따라서 kernel PAC는 **매우 강력**하다고 여겨지지만 완벽하지는 않습니다.

2. **User-mode / runtime PAC bypass techniques**

이들은 더 흔하며, PAC가 적용되는 방식이나 dynamic linking / runtime 프레임워크의 불완전함을 악용합니다. 아래는 분류와 예시입니다.

2.1 **Shared Cache / A key issues**

-   **dyld shared cache**는 많은 시스템 프레임워크와 라이브러리를 사전 연결한 큰 블롭입니다. 널리 공유되기 때문에 shared cache 내의 함수 포인터는 이미 “pre-signed”되어 여러 프로세스에서 사용됩니다. 공격자는 이 이미 서명된 포인터들을 “PAC oracles”로 타깃팅합니다.

-   몇몇 우회 기법은 shared cache에 존재하는 A-key 서명된 포인터를 추출하거나 재사용해 gadget과 결합하려 합니다.

-   "No Clicks Required" 발표는 shared cache를 이용해 상대 주소를 유추하는 오라클을 구축하고, 이를 서명된 포인터와 결합해 PAC를 우회하는 방법을 설명합니다. [saelo.github.io](https://saelo.github.io/presentations/offensivecon_20_no_clicks.pdf)

-   또한 사용자 공간에서의 shared 라이브러리로부터의 함수 포인터 import가 PAC로 충분히 보호되지 않아, 공격자가 서명을 변경하지 않고도 함수 포인터를 얻을 수 있다는 사례가 보고되었습니다. (Project Zero bug entry) [bugs.chromium.org](https://bugs.chromium.org/p/project-zero/issues/detail?id=2044&utm_source=chatgpt.com)

2.2 **dlsym(3) / dynamic symbol resolution**

-   알려진 우회 중 하나는 `dlsym()`을 호출해 이미 서명되어 있는 함수 포인터(A-key로 서명되고 diversifier가 0인)를 얻는 것입니다. `dlsym`이 합법적으로 서명된 포인터를 반환하므로 이를 사용하면 PAC를 위조할 필요가 없습니다.

-   Epsilon 블로그는 몇몇 우회가 이를 어떻게 악용하는지 자세히 설명합니다: `dlsym("someSym")`은 서명된 포인터를 반환해 간접 호출에 사용할 수 있습니다. [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

-   Synacktiv의 "iOS 18.4 --- dlsym considered harmful"는 iOS 18.4에서 `dlsym`으로 해석된 일부 심볼이 잘못 서명되거나 buggy diversifier를 가진 포인터를 반환해 의도치 않은 PAC 우회를 가능하게 하는 버그를 기술합니다. [Synacktiv](https://www.synacktiv.com/en/publications/ios-184-dlsym-considered-harmful)

-   dyld의 `dlsym` 로직에는: `when result->isCode`, 반환된 포인터를 `__builtin_ptrauth_sign_unauthenticated(..., key_asia, 0)`로 서명하는 코드가 포함됩니다(컨텍스트 0). [blog.epsilon-sec.com](https://blog.epsilon-sec.com/tag/pac.html)

따라서 `dlsym`은 user-mode PAC 우회에서 빈번한 벡터입니다.

2.3 **Other DYLD / runtime relocations**

-   DYLD 로더와 동적 재배치 로직은 복잡하며 때때로 재배치를 수행하기 위해 페이지를 일시적으로 read/write로 맵핑하고 다시 read-only로 전환합니다. 공격자는 이러한 창을 악용합니다. Synacktiv의 발표는 dynamic relocations를 통한 타이밍 기반 PAC 우회인 "Operation Triangulation"을 설명합니다. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   DYLD 페이지는 이제 SPRR / VM_FLAGS_TPRO 같은 보호로 보호됩니다(일부 보호 플래그). 그러나 이전 버전들은 더 약한 보호를 가졌습니다. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

-   WebKit exploit 체인에서는 DYLD loader가 종종 PAC 우회의 타깃이 됩니다. 슬라이드는 많은 PAC 우회가 DYLD loader(재배치, interposer hooks 등)를 겨냥했다고 언급합니다. [Synacktiv](https://www.synacktiv.com/sites/default/files/2024-05/escaping_the_safari_sandbox_slides.pdf)

2.4 **NSPredicate / NSExpression / ObjC / SLOP**

-   사용자랜드 익스플릿 체인에서는 Objective-C 런타임 메서드들(예: `NSPredicate`, `NSExpression`, `NSInvocation`)이 제어 호출을 은닉하는 데 사용됩니다.

-   PAC 도입 이전의 iOS에서는 **fake NSInvocation** 객체를 사용해 제어를 전달하는 익스플릿이 있었습니다. PAC가 적용되면서 수정이 필요했지만 SLOP(SeLector Oriented Programming) 기술은 PAC 하에서도 확장되었습니다. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   원래 SLOP 기법은 가짜 invocation을 만들어 ObjC 호출을 체인하는 방식이었고, ISA나 selector 포인터가 때때로 PAC로 완전히 보호되지 않는다는 사실을 이용했습니다. [Project Zero](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)

-   PAC가 부분적으로만 적용되는 환경에서는 method / selector / target 포인터가 항상 PAC 보호를 받지 않아 우회 여지가 생깁니다.

#### Example Flow

<details>
<summary>Example Signing & Authenticating</summary>
```
; Example: function prologue / return address protection
my_func:
stp x29, x30, [sp, #-0x20]!        ; push frame pointer + LR
mov x29, sp
PACIASP                            ; sign LR (x30) using SP as modifier
; … body …
mov sp, x29
ldp x29, x30, [sp], #0x20         ; restore
AUTIASP                            ; authenticate & strip PAC
ret

; Example: indirect function pointer stored in a struct
; suppose X1 contains a function pointer
PACDA X1, X2     ; sign data pointer X1 with context X2
STR X1, [X0]      ; store signed pointer

; later retrieval:
LDR X1, [X0]
AUTDA X1, X2       ; authenticate & strip
BLR X1             ; branch to valid target

; Example: stripping for comparison (unsafe)
LDR X1, [X0]
XPACI X1           ; strip PAC (instruction domain)
CMP X1, #some_label_address
BEQ matched_label
```
</details>

<details>
<summary>예시</summary>
버퍼 오버플로우가 스택의 리턴 주소를 덮어쓴다. 공격자는 대상 gadget 주소를 쓰지만 올바른 PAC를 계산하지 못한다. 함수가 리턴할 때 CPU의 `AUTIA` 명령이 PAC 불일치로 예외를 발생시킨다. 체인은 실패한다.
Project Zero의 A12 (iPhone XS) 분석은 Apple의 PAC 사용 방식과 공격자가 메모리 읽기/쓰기 primitive를 갖고 있을 때 PAC를 위조하는 방법을 보여주었다.
</details>


### 9. **분기 대상 식별 (BTI)**
**ARMv8.5(이후 하드웨어)에서 도입**
BTI는 **간접 분기 대상**을 검사하는 하드웨어 기능이다: `blr` 또는 간접 호출/점프를 실행할 때, 대상은 **BTI landing pad**(`BTI j` 또는 `BTI c`)로 시작해야 한다. landing pad가 없는 gadget 주소로 점프하면 예외가 발생한다.

LLVM의 구현 메모는 BTI 명령의 세 가지 변형과 이들이 분기 유형에 어떻게 매핑되는지 설명한다.

| BTI Variant | 허용하는 것 (어떤 분기 유형) | 전형적인 배치 / 사용 사례 |
|-------------|----------------------------------------|-------------------------------|
| **BTI C** | *call*-스타일 간접 분기(예: `BLR`, 또는 X16/X17를 사용하는 `BR`)의 대상 | 간접 호출될 수 있는 함수의 진입부에 둠 |
| **BTI J** | *jump*-스타일 분기(예: tail call에 사용되는 `BR`)의 대상 | jump table이나 tail-call로 도달 가능한 블록의 시작에 둠 |
| **BTI JC** | C와 J 둘 다의 역할을 함 | call 또는 jump 분기 어느 쪽에서도 대상이 될 수 있음 |

- branch target enforcement로 컴파일된 코드에서는 컴파일러가 각 유효한 간접 분기 대상(함수 시작이나 점프로 도달 가능한 블록)의 앞에 BTI 명령(C, J, 또는 JC)을 삽입하여 간접 분기가 그 장소들로만 성공하도록 한다.
- **직접 분기 / 호출**(즉, 고정 주소 `B`, `BL`)은 BTI의 제한을 받지 않는다. 가정은 코드 페이지가 신뢰되며 공격자가 이를 변경할 수 없다는 것이므로(따라서 직접 분기는 안전하다).
- 또한 **RET / return** 명령은 보통 BTI의 제한을 받지 않는데, 이는 리턴 주소가 PAC나 리턴 서명 메커니즘으로 보호되기 때문이다.

#### 메커니즘 및 강제

- CPU가 “guarded / BTI-enabled”로 표시된 페이지에서 **간접 분기 (BLR / BR)** 를 디코드할 때, 대상 주소의 첫 명령이 유효한 BTI(C, J, 또는 허용된 경우 JC)인지 검사한다. 그렇지 않으면 **Branch Target Exception**이 발생한다.
- BTI 명령 인코딩은 이전 ARM 버전에서 NOP로 예약되어 있던 opcode를 재사용하도록 설계되었다. 따라서 BTI-enabled 바이너리는 하드웨어에 BTI 지원이 없어도 이전과 호환된다: 해당 명령들은 NOP로 동작한다.
- BTI를 추가하는 컴파일러 패스는 필요한 곳에만 삽입한다: 간접 호출될 수 있는 함수나 점프로 타겟이 되는 기본 블록에만 넣는다.
- 일부 패치와 LLVM 코드는 BTI가 *모든* 기본 블록에 삽입되는 것이 아니라 — switch / jump table 등에서 잠재적 분기 대상인 블록들에만 삽입된다는 것을 보여준다.

#### BTI + PAC 시너지

PAC는 포인터 값(출처)을 보호한다 — 간접 호출/리턴 체인이 변조되지 않았음을 보장한다.

BTI는 유효한 포인터라도 적절히 표시된 진입점만 목표로 할 수 있음을 보장한다.

결합하면, 공격자는 올바른 PAC를 가진 유효한 포인터뿐 아니라 대상 위치에 BTI가 있어야 한다. 이는 exploit gadget을 구성하는 난이도를 높인다.

#### 예시


<details>
<summary>예시</summary>
익스플로잇이 `0xABCDEF`에 있는 gadget으로 피벗하려고 하는데 그 시작이 `BTI c`로 시작하지 않는다. CPU가 `blr x0`를 실행할 때 대상 검사를 하고 명령 정렬에 유효한 landing pad가 포함되어 있지 않으므로 fault가 발생한다. 따라서 많은 gadgets는 BTI 접두어가 포함되지 않는 한 사용 불가능해진다.
</details>


### 10. **Privileged Access Never (PAN) & Privileged Execute Never (PXN)**
**더 최신 ARMv8 확장 / iOS 지원(하드닝된 커널을 위해)에서 도입**

#### PAN (Privileged Access Never)

- **PAN**은 **ARMv8.1-A**에서 도입된 기능으로, **privileged 코드**(EL1 또는 EL2)가 **user-접근 가능(EL0)** 으로 표시된 메모리를 **읽거나 쓰지 못하도록** 한다, 단 PAN이 명시적으로 비활성화되지 않는 한.
- 아이디어: 커널이 속임수에 걸리거나 손상되더라도, 커널은 먼저 PAN을 *해제*하지 않는 한 사용자 포인터를 임의로 역참조할 수 없게 하여 `ret2usr` 스타일의 익스플로잇이나 사용자 제어 버퍼의 오용 위험을 줄인다.
- PAN이 활성화되어 있을 때(PSTATE.PAN = 1), “EL0에서 접근 가능한” 가상 주소에 접근하는 privileged load/store 명령은 권한 오류를 유발한다.
- 커널은 합법적으로 사용자 메모리에 접근해야 할 때(예: 사용자 버퍼로/에서 데이터 복사) PAN을 **일시적으로 비활성화**하거나 “비특권 load/store” 명령으로 전환하여 접근을 허용해야 한다.
- Linux의 ARM64에서 PAN 지원은 2015년경에 도입되었다: 커널 패치들은 기능 감지를 추가하고 `get_user` / `put_user` 등을 PAN을 해제하는 변형으로 교체했다.

**핵심 뉘앙스 / 제한 / 버그**
- Siguza 등에서 언급한 바와 같이, ARM 설계의 사양 버그(또는 모호한 동작)는 **execute-only user mappings**(`--x`)이 PAN을 트리거하지 않을 수 있음을 의미한다. 즉, 사용자 페이지가 읽기 권한 없이 실행 가능으로 표시된 경우, 커널의 읽기 시도가 PAN을 우회할 수 있다. 이는 아키텍처가 “EL0에서 접근 가능”을 판정할 때 읽기 권한을 요구하고 단순 실행 권한만으로는 판단하지 않기 때문이다. 이는 특정 구성에서 PAN 우회로 이어진다.
- 따라서 iOS / XNU가 execute-only user 페이지를 허용하는 경우(일부 JIT 또는 코드 캐시 설정처럼), 커널은 PAN이 활성화된 상태에서도 해당 페이지에서 우연히 읽어올 수 있다. 이는 일부 ARMv8+ 시스템에서 알려진 미묘한 취약 지점이다.

#### PXN (Privileged eXecute Never)

- **PXN**은 페이지 테이블 플래그(리프 또는 블록 엔트리 안에)로, 해당 페이지가 **privileged 모드로 실행 불가**함(즉 EL1에서 실행할 수 없음)을 나타낸다.
- PXN은 커널(또는 어떤 privileged 코드) 이 사용자 공간 페이지에서 명령을 점프하거나 실행하는 것을 방지한다. 실질적으로 커널 수준의 제어 흐름을 사용자 메모리로 리디렉트하는 것을 차단한다.
- PAN과 결합하면 다음을 보장한다:
1. 커널은 기본적으로 사용자 공간 데이터를 읽거나 쓰지 못한다 (PAN)
2. 커널은 사용자 공간 코드를 실행할 수 없다 (PXN)
- ARMv8 페이지 테이블 포맷에서 리프 엔트리들은 속성 비트에 `PXN` 비트(및 비특권 실행 불가를 위한 `UXN`)를 가진다.

따라서 커널에 사용자 메모리를 가리키는 손상된 함수 포인터가 있어 브랜치하려 해도, PXN 비트가 fault를 일으킨다.

#### 메모리 권한 모델 및 PAN/PXN이 페이지 테이블 비트에 매핑되는 방식

PAN / PXN이 어떻게 동작하는지 이해하려면 ARM의 변환 및 권한 모델을 봐야 한다(단순화):

- 각 페이지나 블록 엔트리는 읽기/쓰기, 권한(특권 vs 비특권)을 위한 **AP[2:1]** 및 실행 금지를 위한 **UXN / PXN** 비트 등 속성 필드를 가진다.
- PSTATE.PAN이 1(활성)일 때 하드웨어는 수정된 의미를 강제한다: “EL0에서 접근 가능한” 페이지(즉 user-접근 가능)로 표시된 페이지에 대한 privileged 접근은 거부(FAULT)된다.
- 앞서 언급한 버그 때문에 읽기 권한 없이 실행만 가능한 페이지는 구현에 따라 “EL0에서 접근 가능한” 것으로 간주되지 않을 수 있어 PAN을 우회하는 결과를 낳을 수 있다.
- 페이지의 PXN 비트가 설정되면, 더 높은 권한 레벨에서의 명령 페치라도 실행이 금지된다.

#### 하드닝된 OS(예: iOS / XNU)에서의 PAN / PXN 사용

하드닝된 커널 설계에서는(Apple이 사용할 법한 방식):

- 커널은 기본적으로 PAN을 활성화한다(따라서 privileged 코드가 제약을 받는다).
- 합법적으로 사용자 버퍼를 읽거나 써야 하는 경로(예: syscall 버퍼 복사, I/O, 사용자 포인터 읽기/쓰기)에서는 커널이 일시적으로 **PAN을 비활성화**하거나 사용자 메모리 접근을 허용하는 특수 명령을 사용한다.
- 사용자 데이터 접근을 마친 후에는 PAN을 다시 활성화해야 한다.
- PXN은 페이지 테이블을 통해 강제된다: 사용자 페이지는 PXN = 1로 설정되어(커널이 실행 불가), 커널 페이지는 PXN이 설정되지 않는다(커널 코드는 실행 가능).
- 커널은 실행 흐름이 사용자 메모리 영역으로 유입되지 않도록 보장해야 한다(그렇지 않으면 PXN을 우회하게 됨) — 따라서 “사용자 제어 shellcode로 점프”에 의존한 익스플로잇 체인은 차단된다.

앞서 언급한 execute-only 페이지를 통한 PAN 우회 때문에, 실제 시스템에서는 Apple이 execute-only 사용자 페이지를 비활성화하거나 사양 약점을 패치로 우회할 수 있다.


#### 공격 표면, 우회, 완화

- **execute-only 페이지를 통한 PAN 우회**: 앞서 논의한 바와 같이, 사양은 공백을 허용한다: 읽기 권한이 없는 execute-only 사용자 페이지는 일부 구현에서 “EL0에서 접근 가능”으로 간주되지 않을 수 있어 PAN이 커널 읽기를 차단하지 않는다. 이는 공격자에게 execute-only 섹션을 통해 데이터를 주입할 수 있는 특이한 경로를 제공한다.
- **일시적 창(Temporal window) 익스플로잇**: 커널이 필요 이상으로 오래 PAN을 비활성화하면, 레이스나 악의적 경로가 그 창을 악용하여 의도하지 않은 사용자 메모리 접근을 수행할 수 있다.
- **재활성화 누락**: 코드 경로가 PAN을 다시 활성화하는 것을 잊으면 이후 커널 동작이 잘못해서 사용자 메모리에 접근할 수 있다.
- **PXN의 잘못된 구성**: 페이지 테이블이 사용자 페이지에 PXN을 설정하지 않거나 사용자 코드 페이지를 잘못 매핑하면 커널이 사용자 공간 코드를 실행하도록 속을 수 있다.
- **추측 실행 / 사이드 채널**: 추측 실행 우회와 유사하게, PAN / PXN 검사에 대한 일시적 위반을 일으키는 마이크로아키텍처 측면의 부작용이 있을 수 있다(그러나 이러한 공격은 CPU 설계에 매우 의존적이다).
- **복잡한 상호작용**: JIT, shared memory, just-in-time code regions 같은 고급 기능에서는 커널이 사용자 매핑된 영역에서 특정 메모리 접근이나 실행을 허용해야 할 필요가 있는데; PAN/PXN 제약 하에서 이를 안전하게 설계하는 것은 까다롭다.


#### 예시

<details>
<summary>코드 예시</summary>
다음은 사용자 메모리 접근 주변에서 PAN을 활성화/비활성화하는 것을 보여주는 설명적 의사-어셈블리 시퀀스와 fault가 발생할 수 있는 방식이다.
</details>
```  
// Suppose kernel entry point, PAN is enabled (privileged code cannot access user memory by default)

; Kernel receives a syscall with user pointer in X0
; wants to read an integer from user space
mov   X1, X0        ; X1 = user pointer

; disable PAN to allow privileged access to user memory
MSR   PSTATE.PAN, #0   ; clear PAN bit, disabling the restriction

ldr   W2, [X1]       ; now allowed load from user address

; re-enable PAN before doing other kernel logic
MSR   PSTATE.PAN, #1   ; set PAN

; ... further kernel work ...

; Later, suppose an exploit corrupts a pointer to a user-space code page and jumps there
BR    X3             ; branch to X3 (which points into user memory)

; Because the target page is marked PXN = 1 for privileged execution,
; the CPU throws an exception (fault) and rejects execution
```
If the kernel had **not** set PXN on that user page, then the branch might succeed — which would be insecure.

If the kernel forgets to re-enable PAN after user memory access, it opens a window where further kernel logic might accidentally read/write arbitrary user memory.

If the user pointer is into an execute-only page (user page with only execute permission, no read/write), under the PAN spec bug, `ldr W2, [X1]` might **not** fault even with PAN enabled, enabling a bypass exploit, depending on implementation.

</details>

<details>
<summary>Example</summary>
A kernel vulnerability tries to take a user-provided function pointer and call it in kernel context (i.e. `call user_buffer`). Under PAN/PXN, that operation is disallowed or faults.
</details>

---

### 11. **Top Byte Ignore (TBI) / Pointer Tagging**
**Introduced in ARMv8.5 / newer (or optional extension)**
TBI means the top byte (most-significant byte) of a 64-bit pointer is ignored by address translation. This lets OS or hardware embed **tag bits** in the pointer’s top byte without affecting the actual address.

- TBI stands for **Top Byte Ignore** (sometimes called *Address Tagging*). It is a hardware feature (available in many ARMv8+ implementations) that **ignores the top 8 bits** (bits 63:56) of a 64-bit pointer when performing **address translation / load/store / instruction fetch**.
- In effect, the CPU treats a pointer `0xTTxxxx_xxxx_xxxx` (where `TT` = top byte) as `0x00xxxx_xxxx_xxxx` for the purposes of address translation, ignoring (masking off) the top byte. The top byte can be used by software to store **metadata / tag bits**.
- This gives software “free” in-band space to embed a byte of tag in each pointer without altering which memory location it refers to.
- The architecture ensures that loads, stores, and instruction fetch treat the pointer with its top byte masked (i.e. tag stripped off) before performing the actual memory access.

Thus TBI decouples the **logical pointer** (pointer + tag) from the **physical address** used for memory operations.

#### Why TBI: Use cases and motivation

- **Pointer tagging / metadata**: You can store extra metadata (e.g. object type, version, bounds, integrity tags) in that top byte. When you later use the pointer, the tag is ignored at hardware level, so you don’t need to strip manually for the memory access.
- **Memory tagging / MTE (Memory Tagging Extension)**: TBI is the base hardware mechanism that MTE builds on. In ARMv8.5, the **Memory Tagging Extension** uses bits 59:56 of the pointer as a **logical tag** and checks it against an **allocation tag** stored in memory.
- **Enhanced security & integrity**: By combining TBI with pointer authentication (PAC) or runtime checks, you can force not just the pointer value but also the tag to be correct. An attacker overwriting a pointer without the correct tag will produce a mismatched tag.
- **Compatibility**: Because TBI is optional and tag bits are ignored by hardware, existing untagged code continues to operate normally. The tag bits effectively become “don’t care” bits for legacy code.

#### Example
<details>
<summary>Example</summary>
A function pointer included a tag in its top byte (say `0xAA`). An exploit overwrites the pointer low bits but neglects the tag, so when the kernel verifies or sanitizes, the pointer fails or is rejected.
</details>

---

### 12. **Page Protection Layer (PPL)**
**Introduced in late iOS / modern hardware (iOS ~17 / Apple silicon / high-end models)** (some reports show PPL circa macOS / Apple silicon, but Apple is bringing analogous protections to iOS)

- PPL is designed as an **intra-kernel protection boundary**: even if the kernel (EL1) is compromised and has read/write capabilities, **it should not be able to freely modify** certain **sensitive pages** (especially page tables, code-signing metadata, kernel code pages, entitlements, trust caches, etc.).
- It effectively creates a **“kernel within the kernel”** — a smaller trusted component (PPL) with **elevated privileges** that alone can modify protected pages. Other kernel code must call into PPL routines to effect changes.
- This reduces the attack surface for kernel exploits: even with full arbitrary R/W/execute in kernel mode, exploit code must also somehow get into the PPL domain (or bypass PPL) to modify critical structures.
- On newer Apple silicon (A15+ / M2+), Apple is transitioning to **SPTM (Secure Page Table Monitor)**, which in many cases replaces PPL for page-table protection on those platforms.

Here’s how PPL is believed to operate, based on public analysis:

#### Use of APRR / permission routing (APRR = Access Permission ReRouting)

- Apple hardware uses a mechanism called **APRR (Access Permission ReRouting)**, which allows page table entries (PTEs) to contain small indices, rather than full permission bits. Those indices are mapped via APRR registers to actual permissions. This allows dynamic remapping of permissions per domain.
- PPL leverages APRR to segregate privilege within kernel context: only the PPL domain is permitted to update the mapping between indices and effective permissions. That is, when non-PPL kernel code writes a PTE or tries to flip permission bits, the APRR logic disallows it (or enforces read-only mapping).
- PPL code itself runs in a restricted region (e.g. `__PPLTEXT`) which is normally non-executable or non-writable until entry gates temporarily allow it. The kernel calls PPL entry points (“PPL routines”) to perform sensitive operations.

#### Gate / Entry & Exit

- When the kernel needs to modify a protected page (e.g. change permissions of a kernel code page, or modify page tables), it calls into a **PPL wrapper** routine, which does validation and then transitions into the PPL domain. Outside that domain, the protected pages are effectively read-only or non-modifiable by the main kernel.
- During PPL entry, the APRR mappings are adjusted so that memory pages in the PPL region are set to **executable & writable** within PPL. Upon exit, they are returned to read-only / non-writable. This ensures that only well-audited PPL routines can write to protected pages.
- Outside PPL, attempts by kernel code to write to those protected pages will fault (permission denied) because the APRR mapping for that code domain doesn’t permit writing.

#### Protected page categories

The pages that PPL typically protects include:

- Page table structures (translation table entries, mapping metadata)
- Kernel code pages, especially those containing critical logic
- Code-sign metadata (trust caches, signature blobs)
- Entitlement tables, signature enforcement tables
- Other high-value kernel structures where a patch would allow bypassing signature checks or credentials manipulation

The idea is that even if the kernel memory is fully controlled, the attacker cannot simply patch or rewrite these pages, unless they also compromise PPL routines or bypass PPL.


#### Known Bypasses & Vulnerabilities

1. **Project Zero’s PPL bypass (stale TLB trick)**

- A public writeup by Project Zero describes a bypass involving **stale TLB entries**.
- The idea:

1. Allocate two physical pages A and B, mark them as PPL pages (so they are protected).
2. Map two virtual addresses P and Q whose L3 translation table pages come from A and B.
3. Spin a thread to continuously access Q, keeping its TLB entry alive.
4. Call `pmap_remove_options()` to remove mappings starting at P; due to a bug, the code mistakenly removes the TTEs for both P and Q, but only invalidates the TLB entry for P, leaving Q’s stale entry live.
5. Reuse B (page Q’s table) to map arbitrary memory (e.g. PPL-protected pages). Because the stale TLB entry still maps Q’s old mapping, that mapping remains valid for that context.
6. Through this, the attacker can put writable mapping of PPL-protected pages in place without going through PPL interface.

- This exploit required fine control of physical mapping and TLB behavior. It demonstrates that a security boundary relying on TLB / mapping correctness must be extremely careful about TLB invalidations and mapping consistency.

- Project Zero commented that bypasses like this are subtle and rare, but possible in complex systems. Still, they regard PPL as a solid mitigation.

2. **Other potential hazards & constraints**

- If a kernel exploit can directly enter PPL routines (via calling the PPL wrappers), it might bypass restrictions. Thus argument validation is critical.
- Bugs in the PPL code itself (e.g. arithmetic overflow, boundary checks) can allow out-of-bounds modifications inside PPL. Project Zero observed that such a bug in `pmap_remove_options_internal()` was exploited in their bypass.
- The PPL boundary is irrevocably tied to hardware enforcement (APRR, memory controller), so it's only as strong as the hardware implementation.



#### Example
<details>
<summary>Code Example</summary>
Here’s a simplified pseudocode / logic showing how a kernel might call into PPL to modify protected pages:
```c
// In kernel (outside PPL domain)
function kernel_modify_pptable(pt_addr, new_entry) {
// validate arguments, etc.
return ppl_call_modify(pt_addr, new_entry)  // call PPL wrapper
}

// In PPL (trusted domain)
function ppl_call_modify(pt_addr, new_entry) {
// temporarily enable write access to protected pages (via APRR adjustments)
aprr_set_index_for_write(PPL_INDEX)
// perform the modification
*pt_addr = new_entry
// restore permissions (make pages read-only again)
aprr_restore_default()
return success
}

// If kernel code outside PPL does:
*pt_addr = new_entry  // a direct write
// It will fault because APRR mapping for non-PPL domain disallows write to that page
```
The kernel can do many normal operations, but only through `ppl_call_*` routines can it change protected mappings or patch code.
</details>

<details>
<summary>예제</summary>
커널 익스플로잇이 entitlement 테이블을 덮어쓰거나, 커널 서명 블롭(kernel signature blob)을 수정해 code-sign 강제를 비활성화하려고 시도합니다. 해당 페이지는 PPL로 보호되어 있기 때문에 PPL 인터페이스를 통하지 않으면 쓰기가 차단됩니다. 따라서 커널 코드 실행을 얻었다 하더라도 code-sign 제약을 우회하거나 자격 증명 데이터를 임의로 수정할 수 없습니다.
iOS 17+의 일부 디바이스는 PPL로 관리되는 페이지를 추가로 분리하기 위해 SPTM을 사용합니다.
</details>

#### PPL → SPTM / 교체 / 향후

- On Apple’s modern SoCs (A15 or later, M2 or later), Apple supports **SPTM** (Secure Page Table Monitor), which **replaces PPL** for page table protections.
- Apple calls out in documentation: “Page Protection Layer (PPL) and Secure Page Table Monitor (SPTM) enforce execution of signed and trusted code … PPL manages the page table permission overrides … Secure Page Table Monitor replaces PPL on supported platforms.”
- The SPTM architecture likely shifts more policy enforcement into a higher-privileged monitor outside kernel control, further reducing the trust boundary.

### MTE | EMTE | MIE

Here’s a higher-level description of how EMTE operates under Apple’s MIE setup:

1. **Tag assignment**
- 메모리가 할당될 때(예: kernel 또는 user space에서 secure allocators를 통해), 해당 블록에 **secret tag**가 할당됩니다.
- 사용자나 커널에 반환된 포인터는 상위 비트에 그 태그를 포함합니다( TBI / top byte ignore 메커니즘 사용).

2. **Tag checking on access**
- 포인터를 사용해 load나 store가 실행될 때마다 하드웨어는 포인터의 태그가 메모리 블록의 태그(할당 태그)와 일치하는지 확인합니다. 불일치하면 즉시 fault가 발생합니다(동기적이기 때문).
- 동기적이기 때문에 “delayed detection” 창이 존재하지 않습니다.

3. **Retagging on free / reuse**
- 메모리가 해제되면 allocator는 블록의 태그를 변경합니다(그래서 오래된 태그를 가진 이전 포인터들은 더 이상 일치하지 않습니다).
- 따라서 use-after-free 포인터는 오래된 태그를 가지므로 접근 시 불일치가 발생합니다.

4. **Neighbor-tag differentiation to catch overflows**
- 인접한 할당에는 서로 다른 태그가 부여됩니다. 버퍼 오버플로가 이웃 메모리로 침범하면 태그 불일치로 인해 fault가 발생합니다.
- 경계를 넘는 작은 오버플로를 잡아내는 데 특히 강력합니다.

5. **Tag confidentiality enforcement**
- Apple은 태그 값이 leaked되는 것을 방지해야 합니다(공격자가 태그를 알게 되면 올바른 태그를 가진 포인터를 제작할 수 있기 때문).
- microarchitectural / speculative 제어 등 보호장치를 포함하여 태그 비트의 side-channel leak를 방지합니다.

6. **Kernel and user-space integration**
- Apple은 EMTE를 user-space뿐 아니라 커널/OS 핵심 구성요소에서도 사용하여 커널을 메모리 손상으로부터 보호합니다.
- 하드웨어/OS는 커널이 user space를 대신해 실행 중일 때에도 태그 규칙이 적용되도록 보장합니다.

<details>
<summary>예제</summary>
```
Allocate A = 0x1000, assign tag T1
Allocate B = 0x2000, assign tag T2

// pointer P points into A with tag T1
P = (T1 << 56) | 0x1000

// Valid store
*(P + offset) = value // tag T1 matches allocation → allowed

// Overflow attempt: P’ = P + size_of_A (into B region)
*(P' + delta) = value
→ pointer includes tag T1 but memory block has tag T2 → mismatch → fault

// Free A, allocator retags it to T3
free(A)

// Use-after-free:
*(P) = value
→ pointer still has old tag T1, memory region is now T3 → mismatch → fault
```
</details>

#### 제한 사항 및 과제

- **Intrablock overflows**: 오버플로우가 동일한 할당 내에 머물러(경계를 넘지 않고) 태그가 동일하게 유지되면, tag mismatch가 이를 감지하지 못합니다.
- **Tag width limitation**: 태그에 사용할 수 있는 비트 수(예: 4비트 또는 작은 도메인)가 제한되어 네임스페이스가 좁습니다.
- **Side-channel leaks**: 태그 비트가 캐시나 speculative execution 같은 경로로 유출될 수 있으면, 공격자가 유효한 태그를 알아내어 우회할 수 있습니다. Apple의 tag confidentiality enforcement는 이를 완화하려는 목적입니다.
- **Performance overhead**: 각 로드/스토어마다 태그 검사를 수행하면 비용이 추가됩니다; Apple은 하드웨어를 최적화해 오버헤드를 낮춰야 합니다.
- **Compatibility & fallback**: 구형 하드웨어나 EMTE를 지원하지 않는 부품에서는 대체 동작(fallback)이 필요합니다. Apple은 MIE가 지원되는 기기에서만 활성화된다고 주장합니다.
- **Complex allocator logic**: Allocator는 태그 관리, retagging, 경계 정렬, 그리고 태그 충돌 방지 등을 처리해야 합니다. Allocator 로직의 버그는 취약점을 유발할 수 있습니다.
- **Mixed memory / hybrid areas**: 일부 메모리는 untagged(레거시) 상태로 남아 있을 수 있어 상호운용성이 더 까다로워집니다.
- **Speculative / transient attacks**: 많은 마이크로아키텍처 보호와 마찬가지로, speculative execution이나 micro-op fusions가 검사를 일시적으로 우회하거나 태그 비트를 유출할 수 있습니다.
- **Limited to supported regions**: Apple은 EMTE를 커널이나 보안에 민감한 서브시스템 같은 선택된 고위험 영역에서만 적용할 수 있으며, 전면 적용하지 않을 수 있습니다.

---

## Key enhancements / differences compared to standard MTE

다음은 Apple이 강조하는 개선점 및 변경 사항입니다:

| Feature | Original MTE | EMTE (Apple’s enhanced) / MIE |
|---|---|---|
| **Check mode** | Supports synchronous and asynchronous modes. In async, tag mismatches are reported later (delayed)| Apple insists on **synchronous mode** by default—tag mismatches are caught immediately, no delay/race windows allowed.|
| **Coverage of non-tagged memory** | Accesses to non-tagged memory (e.g. globals) may bypass checks in some implementations | EMTE requires that accesses from a tagged region to non-tagged memory also validate tag knowledge, making it harder to bypass by mixing allocations.|
| **Tag confidentiality / secrecy** | Tags might be observable or leaked via side channels | Apple adds **Tag Confidentiality Enforcement**, which attempts to prevent leakage of tag values (via speculative side-channels etc.).|
| **Allocator integration & retagging** | MTE leaves much of allocator logic to software | Apple’s secure typed allocators (kalloc_type, xzone malloc, etc.) integrate with EMTE: when memory is allocated or freed, tags are managed at fine granularity.|
| **Always-on by default** | In many platforms, MTE is optional or off by default | Apple enables EMTE / MIE by default on supported hardware (e.g. iPhone 17 / A19) for kernel and many user processes.|

Apple은 하드웨어와 소프트웨어 스택을 모두 제어하기 때문에 EMTE를 엄격하게 적용하고, 성능 문제를 회피하며, 사이드채널 취약점을 줄일 수 있습니다.

---

## How EMTE works in practice (Apple / MIE)

다음은 Apple의 MIE 설정 하에서 EMTE가 어떻게 동작하는지에 대한 높은 수준의 설명입니다:

1. **Tag assignment**
- 메모리가 할당될 때(예: 커널이나 secure allocators를 통한 user space 할당) 해당 블록에 **secret tag**가 할당됩니다.
- 반환되는 포인터는 해당 태그를 상위 비트에 포함합니다(예: TBI / top byte ignore 메커니즘 사용).

2. **Tag checking on access**
- 포인터를 사용해 load 또는 store를 실행할 때마다 하드웨어는 포인터의 태그가 메모리 블록의 태그(할당 태그)와 일치하는지 검사합니다. 불일치하면 즉시 fault가 발생합니다(동기 모드이므로).
- 동기 방식이므로 “지연된 탐지” 창이 존재하지 않습니다.

3. **Retagging on free / reuse**
- 메모리가 해제될 때, allocator는 블록의 태그를 변경합니다(그래서 이전 태그를 가진 포인터는 더 이상 일치하지 않습니다).
- 이로 인해 use-after-free 포인터는 오래된 태그를 갖고 있어 접근 시 불일치가 발생합니다.

4. **Neighbor-tag differentiation to catch overflows**
- 인접한 할당물에는 서로 다른 태그가 부여됩니다. 버퍼 overflow가 이웃 메모리로 넘치면 tag mismatch로 인해 fault가 발생합니다.
- 이는 경계를 넘는 작은 overflows를 탐지하는 데 특히 효과적입니다.

5. **Tag confidentiality enforcement**
- 공격자가 태그 값을 알게 되면 올바른 태그로 포인터를 조작할 수 있으므로, Apple은 태그 값 유출을 방지해야 합니다.
- 이를 위해 태그 비트의 유출을 방지하려는 보호책(마이크로아키텍처/투기적 제어 등)을 포함합니다.

6. **Kernel and user-space integration**
- Apple은 EMTE를 user-space뿐 아니라 kernel/OS-중요 구성요소에도 적용하여 커널을 메모리 손상으로부터 보호합니다.
- 하드웨어/OS는 커널이 user space를 대신해 실행할 때도 태그 규칙이 적용되도록 보장합니다.

EMTE가 MIE에 통합되어 있기 때문에, Apple은 주요 공격 표면 전반에 걸쳐 EMTE를 동기 모드로 사용하며 선택적 또는 디버깅용 모드로 두지 않습니다.

---

## Exception handling in XNU

예외가 발생할 때(예: `EXC_BAD_ACCESS`, `EXC_BAD_INSTRUCTION`, `EXC_CRASH`, `EXC_ARM_PAC` 등), XNU 커널의 **Mach layer**는 이것이 UNIX 스타일의 **signal**(예: `SIGSEGV`, `SIGBUS`, `SIGILL`, ...)로 변환되기 전에 이를 가로채는 역할을 합니다.

이 과정은 사용자 공간에 도달하거나 BSD 신호로 변환되기 전에 여러 계층의 예외 전파 및 처리를 포함합니다.

### Exception Flow (High-Level)

1.  **CPU triggers a synchronous exception** (e.g., invalid pointer dereference, PAC failure, illegal instruction, etc.).

2.  **Low-level trap handler** runs (`trap.c`, `exception.c` in XNU source).

3.  The trap handler calls **`exception_triage()`**, the core of the Mach exception handling.

4.  `exception_triage()` decides how to route the exception:

-   First to the **thread's exception port**.

-   Then to the **task's exception port**.

-   Then to the **host's exception port** (often `launchd` or `ReportCrash`).

If none of these ports handle the exception, the kernel may:

-   **Convert it into a BSD signal** (for user-space processes).

-   **Panic** (for kernel-space exceptions).

### Core Function: `exception_triage()`

함수 `exception_triage()`는 Mach 예외를 가능한 핸들러 체인으로 라우팅하여 어느 한 쪽이 처리하거나 최종적으로 치명적인 상태가 될 때까지 전달합니다. 이 함수는 `osfmk/kern/exception.c`에 정의되어 있습니다.
```c
void exception_triage(exception_type_t exception, mach_exception_data_t code, mach_msg_type_number_t codeCnt);
```
**일반적인 호출 흐름:**

`exception_triage()
└── exception_deliver()
├── exception_deliver_thread()
├── exception_deliver_task()
└── exception_deliver_host()`

모두 실패하면 → `bsd_exception()`에서 처리되어 → `SIGSEGV` 같은 시그널로 변환된다.


### 예외 포트

각 Mach 객체 (thread, task, host)는 예외 메시지가 전송되는 **예외 포트**를 등록할 수 있다.

이들은 API에 의해 정의된다:
```
task_set_exception_ports()
thread_set_exception_ports()
host_set_exception_ports()
```
Each exception port has:

-   A **mask** (which exceptions it wants to receive)
-   A **port name** (Mach port to receive messages)
-   A **behavior** (how the kernel sends the message)
-   A **flavor** (which thread state to include)


### Debuggers and Exception Handling

A **debugger** (e.g., LLDB) sets an **exception port** on the target task or thread, usually using `task_set_exception_ports()`.

**When an exception occurs:**

-   The Mach message is sent to the debugger process.
-   The debugger can decide to **handle** (resume, modify registers, skip instruction) or **not handle** the exception.
-   If the debugger doesn't handle it, the exception propagates to the next level (task → host).


### Flow of `EXC_BAD_ACCESS`

1.  Thread dereferences invalid pointer → CPU raises Data Abort.

2.  Kernel trap handler calls `exception_triage(EXC_BAD_ACCESS, ...)`.

3.  Message sent to:

-   Thread port → (debugger can intercept breakpoint).

-   If debugger ignores → Task port → (process-level handler).

-   If ignored → Host port (usually ReportCrash).

4.  If no one handles → `bsd_exception()` translates to `SIGSEGV`.


### PAC Exceptions

When **Pointer Authentication** (PAC) fails (signature mismatch), a **special Mach exception** is raised:

-   **`EXC_ARM_PAC`** (type)
-   Codes may include details (e.g., key type, pointer type).

If the binary has the flag **`TFRO_PAC_EXC_FATAL`**, the kernel treats PAC failures as **fatal**, bypassing debugger interception. This is to prevent attackers from using debuggers to bypass PAC checks and it's enabled for **platform binaries**.

### Software Breakpoints

A software breakpoint (`int3` on x86, `brk` on ARM64) is implemented by **causing a deliberate fault**.\
The debugger catches this via the exception port:

-   Modifies instruction pointer or memory.
-   Restores original instruction.
-   Resumes execution.

This same mechanism is what allows you to "catch" a PAC exception --- **unless `TFRO_PAC_EXC_FATAL`** is set, in which case it never reaches the debugger.


### Conversion to BSD Signals

If no handler accepts the exception:

-   Kernel calls `task_exception_notify() → bsd_exception()`.

-   This maps Mach exceptions to signals:

| Mach Exception | Signal |
| --- | --- |
| EXC_BAD_ACCESS | SIGSEGV or SIGBUS |
| EXC_BAD_INSTRUCTION | SIGILL |
| EXC_ARITHMETIC | SIGFPE |
| EXC_SOFTWARE | SIGTRAP |
| EXC_BREAKPOINT | SIGTRAP |
| EXC_CRASH | SIGKILL |
| EXC_ARM_PAC | SIGILL (on non-fatal) |


### Key Files in XNU Source

-   `osfmk/kern/exception.c` → Core of `exception_triage()`, `exception_deliver_*()`.

-   `bsd/kern/kern_sig.c` → Signal delivery logic.

-   `osfmk/arm64/trap.c` → Low-level trap handlers.

-   `osfmk/mach/exc.h` → Exception codes and structures.

-   `osfmk/kern/task.c` → Task exception port setup.

---

## Old Kernel Heap (Pre-iOS 15 / Pre-A12 era)

The kernel used a **zone allocator** (`kalloc`) divided into fixed-size "zones."
Each zone only stores allocations of a single size class.

From the screenshot:

| Zone Name            | Element Size | Example Use                                                                 |
|----------------------|--------------|-----------------------------------------------------------------------------|
| `default.kalloc.16`  | 16 bytes     | Very small kernel structs, pointers.                                        |
| `default.kalloc.32`  | 32 bytes     | Small structs, object headers.                                              |
| `default.kalloc.64`  | 64 bytes     | IPC messages, tiny kernel buffers.                                          |
| `default.kalloc.128` | 128 bytes    | Medium objects like parts of `OSObject`.                                    |
| …                    | …            | …                                                                           |
| `default.kalloc.1280`| 1280 bytes   | Large structures, IOSurface/graphics metadata.                              |

**How it worked:**
- Each allocation request gets **rounded up** to the nearest zone size.
(E.g., a 50-byte request lands in the `kalloc.64` zone).
- Memory in each zone was kept in a **free list** — chunks freed by the kernel went back into that zone.
- If you overflowed a 64-byte buffer, you’d overwrite the **next object in the same zone**.

This is why **heap spraying / feng shui** was so effective: you could predict object neighbors by spraying allocations of the same size class.

### The freelist

Inside each kalloc zone, freed objects weren’t returned directly to the system — they went into a freelist, a linked list of available chunks.

- When a chunk was freed, the kernel wrote a pointer at the start of that chunk → the address of the next free chunk in the same zone.

- The zone kept a HEAD pointer to the first free chunk.

- Allocation always used the current HEAD:

1. Pop HEAD (return that memory to the caller).

2. Update HEAD = HEAD->next (stored in the freed chunk’s header).

- Freeing pushed chunks back:

- `freed_chunk->next = HEAD`

- `HEAD = freed_chunk`

So the freelist was just a linked list built inside the freed memory itself.

Normal state:
```
Zone page (64-byte chunks for example):
[ A ] [ F ] [ F ] [ A ] [ F ] [ A ] [ F ]

Freelist view:
HEAD ──► [ F ] ──► [ F ] ──► [ F ] ──► [ F ] ──► NULL
(next ptrs stored at start of freed chunks)
```
### freelist 악용

free chunk의 처음 8바이트가 freelist pointer와 같기 때문에, 공격자는 이를 손상시킬 수 있다:

1. **Heap overflow** — 인접한 freed chunk으로 덮어써서 그 “next” pointer를 덮어씀.

2. **Use-after-free** — freed object에 쓰기를 해서 그 “next” pointer를 덮어씀.

그런 다음, 해당 크기의 다음 할당 시:

- allocator가 손상된 chunk를 pop한다.

- 공격자가 제공한 “next” pointer를 따라간다.

- 임의의 메모리를 가리키는 포인터를 반환하여 fake object primitives 또는 targeted overwrite를 가능하게 한다.

Visual example of freelist poisoning:
```
Before corruption:
HEAD ──► [ F1 ] ──► [ F2 ] ──► [ F3 ] ──► NULL

After attacker overwrite of F1->next:
HEAD ──► [ F1 ]
(next) ──► 0xDEAD_BEEF_CAFE_BABE  (attacker-chosen)

Next alloc of this zone → kernel hands out memory at attacker-controlled address.
```
This freelist 설계는 하드닝 이전에 익스플로잇을 매우 효과적으로 만들었습니다: heap sprays로 인한 예측 가능한 이웃, raw pointer freelist links, 그리고 타입 분리가 없어 공격자가 UAF/overflow 버그를 임의의 kernel memory 제어로 확장할 수 있었습니다.

### Heap Grooming / Feng Shui
The goal of heap grooming is to **shape the heap layout** so that when an attacker triggers an overflow or use-after-free, the target (victim) object sits right next to an attacker-controlled object.\
That way, when memory corruption happens, the attacker can reliably overwrite the victim object with controlled data.

**단계:**

1. Spray allocations (fill the holes)
- 시간이 지나면서 kernel heap은 단편화됩니다: 일부 zone에는 이전에 free된 객체들로 인한 구멍(hole)이 생깁니다.
- 공격자는 먼저 이러한 빈칸을 메우기 위해 더미 할당을 많이 만들어 heap을 “빽빽하게” 하고 예측 가능하게 만듭니다.

2. Force new pages
- 구멍이 채워지면 다음 할당은 해당 zone에 추가된 새 페이지에서 발생해야 합니다.
- 새 페이지는 객체들이 오래된 단편화된 메모리에 흩어져 있는 대신 한 곳에 모이게 합니다.
- 이는 공격자가 이웃 객체의 배치를 더 잘 제어할 수 있게 합니다.

3. Place attacker objects
- 공격자는 이제 다시 스프레이하여 새 페이지들에 공격자가 제어하는 객체들을 많이 생성합니다.
- 이 객체들은 모두 동일한 zone에 속하므로 크기와 배치가 예측 가능합니다.

4. Free a controlled object (make a gap)
- 공격자는 의도적으로 자신이 만든 객체 중 하나를 free합니다.
- 이것은 allocator가 동일 크기의 다음 할당에서 재사용할 “구멍(hole)”을 생성합니다.

5. Victim object lands in the hole
- 공격자는 커널이 피해자(victim) 객체를 할당하도록 트리거합니다.
- 구멍이 freelist에서 첫 번째로 사용 가능한 슬롯이므로 피해자는 공격자가 free한 바로 그 위치에 배치됩니다.

6. Overflow / UAF into victim
- 이제 공격자는 피해자 주변에 공격자 제어 객체를 갖고 있습니다.
- 자신이 만든 객체에서 overflow를 발생시키거나 freed 객체를 재사용하여 피해자의 메모리 필드를 원하는 값으로 신뢰성 있게 덮어쓸 수 있습니다.

**왜 동작하는가**:

- Zone allocator의 예측 가능성: 동일 크기 할당은 항상 같은 zone에서 가져옵니다.
- Freelist 동작: 새 할당은 가장 최근에 free된 청크를 먼저 재사용합니다.
- Heap sprays: 공격자는 예측 가능한 콘텐츠로 메모리를 채우고 레이아웃을 제어합니다.
- 최종 결과: 공격자는 피해자 객체가 어디에 배치되는지와 그 옆에 어떤 데이터가 놓이는지를 제어합니다.

---

## Modern Kernel Heap (iOS 15+/A12+ SoCs)

Apple은 allocator를 강화하여 **heap grooming을 훨씬 어렵게** 만들었습니다:

### 1. From Classic kalloc to kalloc_type
- **Before**: 각 size class(16, 32, 64, … 1280 등)에 대해 단일 `kalloc.<size>` zone이 존재했습니다. 그 크기의 어떤 객체든 그곳에 배치되었기 때문에 → 공격자 객체가 privileged kernel 객체 옆에 앉을 수 있었습니다.
- **Now**:
- Kernel 객체들은 **typed zones**(`kalloc_type`)에서 할당됩니다.
- 각 객체 타입(예: `ipc_port_t`, `task_t`, `OSString`, `OSData`)은 동일한 크기라도 각각 전용 zone을 갖습니다.
- 객체 타입 ↔ zone 매핑은 컴파일 시 **kalloc_type 시스템**에서 생성됩니다.

공격자는 더 이상 제어한 데이터(`OSData`)가 동일 크기의 민감한 kernel 객체(`task_t`) 옆에 올 것이라고 보장할 수 없습니다.

### 2. Slabs and Per-CPU Caches
- heap은 특정 zone을 위한 고정 크기 청크로 잘라진 **slabs**로 나뉩니다(메모리 페이지들).
- 각 zone은 경쟁을 줄이기 위해 **per-CPU cache**를 가집니다.
- 할당 경로:
1. per-CPU cache 시도.
2. 비어 있으면 global freelist에서 가져옴.
3. freelist가 비어 있으면 새 slab(하나 이상의 페이지) 할당.
- **이점**: 이 분산화는 할당이 서로 다른 CPU의 캐시에서 만족될 수 있기 때문에 heap sprays를 덜 결정론적으로 만듭니다.

### 3. Randomization inside zones
- zone 내부에서 freed 요소들이 단순 FIFO/LIFO 순서로 반환되지 않습니다.
- 최신 XNU는 **encoded freelist pointers**(Linux의 safe-linking 유사, ~iOS 14 도입)를 사용합니다.
- 각 freelist 포인터는 **per-zone secret cookie**와 XOR로 인코딩됩니다.
- 이는 쓰기 프리미티브를 얻더라도 공격자가 가짜 freelist 포인터를 위조하는 것을 방지합니다.
- 일부 할당은 **slab 내 배치가 무작위화**되어 스프레이가 인접을 보장하지 않습니다.

### 4. Guarded Allocations
- 특정 핵심 kernel 객체들(예: credentials, task 구조체)은 **guarded zones**에서 할당됩니다.
- 이러한 zone들은 slab 사이에 **guard pages**(매핑되지 않은 메모리)를 삽입하거나 객체 주변에 **redzones**를 사용합니다.
- guard page로의 어떤 overflow라도 fault를 유발 → 즉시 panic (무음 손상 대신).

### 5. Page Protection Layer (PPL) and SPTM
- freed 객체를 제어하더라도 모든 kernel 메모리를 수정할 수는 없습니다:
- **PPL (Page Protection Layer)**는 특정 영역(예: code signing 데이터, entitlements)을 커널 자체에도 **read-only**로 강제합니다.
- **A15/M2+ 디바이스**에서는 이 역할이 **SPTM (Secure Page Table Monitor)** + **TXM (Trusted Execution Monitor)**로 대체/강화됩니다.
- 이러한 하드웨어 강제 계층은 공격자가 단일 heap 손상에서 중요한 보안 구조를 임의로 패치하는 것을 불가능하게 만듭니다.
- **(추가/강화됨)**: 또한 커널에서 포인터(특히 함수 포인터, vtables)를 보호하기 위해 **PAC (Pointer Authentication Codes)**가 사용되어 이를 위조하거나 손상시키기 어렵게 합니다.
- **(추가/강화됨)**: zones는 **zone_require / zone enforcement**를 시행할 수 있으며, 즉 free된 객체는 올바른 typed zone을 통해서만 반환될 수 있습니다; 잘못된 cross-zone free는 panic을 유발하거나 거부될 수 있습니다. (Apple은 메모리 안전성 관련 포스트에서 이를 암시합니다)

### 6. Large Allocations
- 모든 할당이 `kalloc_type`을 통하지는 않습니다.
- 매우 큰 요청(대략 ~16 KB 이상)은 typed zone을 우회하고 페이지 할당을 통해 직접 **kernel VM (kmem)**에서 서비스됩니다.
- 이들은 덜 예측 가능하지만, 다른 객체와 slab를 공유하지 않기 때문에 exploitable 가능성도 낮습니다.

### 7. Allocation Patterns Attackers Target
이러한 보호가 있어도 공격자들은 여전히 다음을 노립니다:
- **Reference count objects**: retain/release 카운터를 변조할 수 있다면 use-after-free를 야기할 수 있습니다.
- **Objects with function pointers (vtables)**: 이를 손상시키면 여전히 control flow를 얻을 수 있습니다.
- **Shared memory objects (IOSurface, Mach ports)**: 이들은 user ↔ kernel을 잇는 브리지이므로 여전히 공격 대상입니다.

하지만 — 이전과 달리 — 단순히 `OSData`를 스프레이해서 `task_t` 옆에 오게 할 수는 없습니다. 성공하려면 **타입별 버그** 또는 **정보 유출(info leaks)** 이 필요합니다.

### Example: Allocation Flow in Modern Heap

Suppose userspace calls into IOKit to allocate an `OSData` object:

1. **Type lookup** → `OSData` maps to `kalloc_type_osdata` zone (size 64 bytes).
2. Check per-CPU cache for free elements.
- If found → return one.
- If empty → go to global freelist.
- If freelist empty → allocate a new slab (page of 4KB → 64 chunks of 64 bytes).
3. Return chunk to caller.

**Freelist pointer protection**:
- Each freed chunk stores the address of the next free chunk, but encoded with a secret key.
- Overwriting that field with attacker data won’t work unless you know the key.

---

## Comparison Table

| Feature                         | **Old Heap (Pre-iOS 15)**                                  | **Modern Heap (iOS 15+ / A12+)**                  |
|---------------------------------|------------------------------------------------------------|--------------------------------------------------|
| Allocation granularity          | Fixed size buckets (`kalloc.16`, `kalloc.32`, etc.)        | Size + **type-based buckets** (`kalloc_type`)    |
| Placement predictability         | High (same-size objects side by side)                     | Low (same-type grouping + randomness)            |
| Freelist management             | Raw pointers in freed chunks (easy to corrupt)             | **Encoded pointers** (safe-linking style)        |
| Adjacent object control         | Easy via sprays/frees (feng shui predictable)              | Hard — typed zones separate attacker objects      |
| Kernel data/code protections    | Few hardware protections                                   | **PPL / SPTM** protect page tables & code pages, and **PAC** protects pointers |
| Allocation reuse validation     | None (freelist pointers raw)                               | **zone_require / zone enforcement**             |
| Exploit reliability             | High with heap sprays                                      | Much lower, requires logic bugs or info leaks     |
| Large allocations handling      | All small allocations managed equally                       | Large ones bypass zones → handled via VM         |

---

## Modern Userland Heap (iOS, macOS — type-aware / xzone malloc)

최근 Apple OS 버전(특히 iOS 17+)에서 Apple은 더 안전한 사용자 공간 allocator인 **xzone malloc**(XZM)을 도입했습니다. 이는 커널의 `kalloc_type`에 해당하는 사용자 공간 아날로그로, 타입 인식, 메타데이터 분리, 메모리 태깅 보호를 적용합니다.

### Goals & Design Principles

- **Type segregation / type awareness**: 타입 또는 사용(포인터 vs 데이터)별로 할당을 그룹화하여 type confusion 및 cross-type 재사용을 방지합니다.
- **Metadata isolation**: 힙 메타데이터(예: free lists, size/state 비트)를 객체 페이로드와 분리하여 OOB 쓰기가 메타데이터를 손상시킬 가능성을 줄입니다.
- **Guard pages / redzones**: 할당 주변에 매핑되지 않은 페이지나 패딩을 삽입하여 overflow를 포착합니다.
- **Memory tagging (EMTE / MIE)**: 하드웨어 태깅과 함께 동작하여 use-after-free, out-of-bounds, 잘못된 접근을 검출합니다.
- **Scalable performance**: 낮은 오버헤드를 유지하고 과도한 단편화를 피하며 초당 많은 할당을 저지연으로 지원합니다.

### Architecture & Components

아래는 xzone allocator의 주요 요소들입니다:

#### Segment Groups & Zones

- **Segment groups**은 사용 카테고리별로 주소 공간을 분할합니다: 예: `data`, `pointer_xzones`, `data_large`, `pointer_large`.
- 각 segment group은 해당 카테고리의 할당을 호스팅하는 **segments**(VM 범위)를 포함합니다.
- 각 segment와 연관된 **metadata slab**(별도 VM 영역)는 해당 segment의 메타데이터(예: free/used 비트, size class)를 저장합니다. 이 **out-of-line (OOL) metadata**는 메타데이터가 객체 페이로드와 섞이지 않도록 하여 overflow로 인한 손상을 완화합니다.
- Segments는 **chunks**(슬라이스)로 잘려지고, 각 chunk는 다시 **blocks**(할당 단위)로 세분화됩니다. 하나의 chunk는 특정 size class와 segment group에 묶여 있습니다(즉 해당 chunk의 모든 block은 동일한 크기 및 카테고리 공유).
- 작은/중간 할당에 대해서는 고정 크기 chunks를 사용하고, 큰/거대한 할당은 별도로 매핑할 수 있습니다.

#### Chunks & Blocks

- **chunk**는 하나의 size class를 위한 영역(종종 여러 페이지)입니다.
- chunk 내부에서 **blocks**는 할당 가능한 슬롯입니다. freed된 blocks는 metadata slab(예: 비트맵 또는 out-of-line에 저장된 free lists)를 통해 추적됩니다.
- chunk 사이(또는 내부)에 **guard slices / guard pages**(예: 매핑되지 않은 슬라이스)가 삽입되어 OOB 쓰기를 포착할 수 있습니다.

#### Type / Type ID

- 모든 할당 지점(또는 malloc, calloc 등 호출)은 어떤 종류의 객체가 할당되는지를 인코딩한 **type identifier**(`malloc_type_id_t`)와 연관됩니다. 이 type ID는 allocator에 전달되어 어떤 zone/segment가 그 할당을 제공할지 선택합니다.
- 이로 인해, 같은 크기의 두 할당이라도 타입이 다르면 완전히 다른 zone에 들어갈 수 있습니다.
- 초기 iOS 17 버전에서는 일부 API(예: CFAllocator)가 완전한 타입 인식을 지원하지 않았고; Apple은 iOS 18에서 이러한 약점을 보완했습니다.

---

### Allocation & Freeing Workflow

다음은 xzone에서 할당과 해제가 작동하는 높은 수준의 흐름입니다:

1. **malloc / calloc / realloc / typed alloc**이 크기와 type ID와 함께 호출됩니다.
2. allocator는 **type ID**를 사용해 올바른 segment group / zone을 선택합니다.
3. 해당 zone/segment 내에서 요청 크기의 free blocks가 있는 chunk를 찾습니다.
- 로컬 캐시/스레드별 풀 또는 metadata의 free block 목록을 참조할 수 있습니다.
- 사용 가능한 free block이 없으면 해당 zone에 새 chunk를 할당할 수 있습니다.
4. metadata slab이 업데이트됩니다(free 비트 클리어, 북키핑).
5. 메모리 태깅(EMTE)이 적용되는 경우, 반환되는 block에는 **tag**가 할당되고 메타데이터는 해당 블록의 “live” 상태를 반영하도록 업데이트됩니다.
6. `free()`가 호출되면:
- block은 메타데이터에서 freed로 표시됩니다(OOL slab 통해).
- block은 free list에 놓이거나 재사용을 위해 풀링될 수 있습니다.
- 선택적으로 블록 내용은 데이터 유출이나 UAF 악용을 줄이기 위해 지워지거나 포이즈닝될 수 있습니다.
- 블록과 연관된 하드웨어 태그는 무효화되거나 재태깅될 수 있습니다.
- 전체 chunk가 비게 되면(모든 block이 freed) allocator는 메모리 압박 시 해당 chunk를 **회수(reclaim)** 하여 언맵하거나 OS로 반환할 수 있습니다.

---

### Security Features & Hardening

다음은 현대 사용자 공간 xzone에 내장된 방어 기능들입니다:

| Feature | Purpose | Notes |
|---|-------------------------------|-----------------------------------------|
| **Metadata decoupling** | Prevent overflow from corrupting metadata | Metadata lives in separate VM region (metadata slab)|
| **Guard pages / unmapped slices** | Catch out-of-bounds writes | Helps detect buffer overflows rather than silently corrupting adjacent blocks|
| **Type-based segregation** | Prevent cross-type reuse & type confusion | Even same-size allocations from different types go to different zones|
| **Memory Tagging (EMTE / MIE)** | Detect invalid access, stale references, OOB, UAF | xzone works in concert with hardware EMTE in synchronous mode (“Memory Integrity Enforcement”)|
| **Delayed reuse / poisoning / zap** | Reduce chance of use-after-free exploitation | Freed blocks may be poisoned, zeroed, or quarantined before reuse |
| **Chunk reclamation / dynamic unmapping** | Reduce memory waste and fragmentation | Entire chunks may be unmapped when unused |
| **Randomization / placement variation** | Prevent deterministic adjacency | Blocks in a chunk and chunk selection may have randomized aspects |
| **Segregation of “data-only” allocations** | Separate allocations that don’t store pointers | Reduces attacker control over metadata or control fields|

---

### Interaction with Memory Integrity Enforcement (MIE / EMTE)

- Apple의 MIE (Memory Integrity Enforcement)는 **Enhanced Memory Tagging Extension (EMTE)**를 주요 공격 표면에 대해 항상 켜진 동기 모드로 제공하는 하드웨어 + OS 프레임워크입니다.
- xzone allocator는 사용자 공간에서 MIE의 핵심 기반입니다: xzone을 통해 수행된 할당들은 태그를 받고 접근은 하드웨어에 의해 검사됩니다.
- MIE에서 allocator, 태그 할당, 메타데이터 관리 및 태그 기밀성 강제는 통합되어 메모리 오류(예: 오래된 참조, OOB, UAF)가 즉시 감지되어 나중에 악용되는 것을 방지합니다.

---

If you like, I can also generate a cheat-sheet or diagram of xzone internals for your book. Do you want me to do that next?
::contentReference[oai:20]{index=20}


---

## (Old) Physical Use-After-Free via IOSurface

{{#ref}}
ios-physical-uaf-iosurface.md
{{#endref}}

---

## Ghidra Install BinDiff

Download BinDiff DMG from [https://www.zynamics.com/bindiff/manual](https://www.zynamics.com/bindiff/manual) and install it.

Open Ghidra with `ghidraRun` and go to `File` --> `Install Extensions`, press the add button and select the path `/Applications/BinDiff/Extra/Ghidra/BinExport` and click OK and isntall it even if there is a version mismatch.

### Using BinDiff with Kernel versions

1. Go to the page [https://ipsw.me/](https://ipsw.me/) and download the iOS versions you want to diff. These will be `.ipsw` files.
2. Decompress until you get the bin format of the kernelcache of both `.ipsw` files. You have information on how to do this on:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/mac-os-architecture/macos-kernel-extensions.md
{{#endref}}

3. Open Ghidra with `ghidraRun`, create a new project and load the kernelcaches.
4. Open each kernelcache so they are automatically analyzed by Ghidra.
5. Then, on the project Window of Ghidra, right click each kernelcache, select `Export`, select format `Binary BinExport (v2) for BinDiff` and export them.
6. Open BinDiff, create a new workspace and add a new diff indicating as primary file the kernelcache that contains the vulnerability and as secondary file the patched kernelcache.

---

## Finding the right XNU version

If you want to check for vulnerabilities in a specific version of iOS, you can check which XNU release version the iOS version uses at [https://www.theiphonewiki.com/wiki/kernel]https://www.theiphonewiki.com/wiki/kernel).

For example, the versions `15.1 RC`, `15.1` and `15.1.1` use the version `Darwin Kernel Version 21.1.0: Wed Oct 13 19:14:48 PDT 2021; root:xnu-8019.43.1~1/RELEASE_ARM64_T8006`.


### iMessage/Media Parser Zero-Click Chains

{{#ref}}
imessage-media-parser-zero-click-coreaudio-pac-bypass.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
