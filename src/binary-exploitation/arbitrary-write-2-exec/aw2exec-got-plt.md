# WWW2Exec - GOT/PLT

{{#include ../../banners/hacktricks-training.md}}

## **Informações Básicas**

### **GOT: Tabela de Deslocamento Global**

A **Tabela de Deslocamento Global (GOT)** é um mecanismo usado em binários vinculados dinamicamente para gerenciar os **endereços de funções externas**. Como esses **endereços não são conhecidos até o tempo de execução** (devido ao vínculo dinâmico), a GOT fornece uma maneira de **atualizar dinamicamente os endereços desses símbolos externos** uma vez que são resolvidos.

Cada entrada na GOT corresponde a um símbolo nas bibliotecas externas que o binário pode chamar. Quando uma **função é chamada pela primeira vez, seu endereço real é resolvido pelo vinculador dinâmico e armazenado na GOT**. Chamadas subsequentes para a mesma função usam o endereço armazenado na GOT, evitando assim a sobrecarga de resolver o endereço novamente.

### **PLT: Tabela de Ligação de Procedimentos**

A **Tabela de Ligação de Procedimentos (PLT)** trabalha em estreita colaboração com a GOT e serve como um trampolim para lidar com chamadas a funções externas. Quando um binário **chama uma função externa pela primeira vez, o controle é passado para uma entrada na PLT associada a essa função**. Esta entrada da PLT é responsável por invocar o vinculador dinâmico para resolver o endereço da função, caso ainda não tenha sido resolvido. Após o endereço ser resolvido, ele é armazenado na **GOT**.

**Portanto,** as entradas da GOT são usadas diretamente uma vez que o endereço de uma função ou variável externa é resolvido. **As entradas da PLT são usadas para facilitar a resolução inicial** desses endereços via o vinculador dinâmico.

## Obter Execução

### Verifique a GOT

Obtenha o endereço da tabela GOT com: **`objdump -s -j .got ./exec`**

![](<../../images/image (121).png>)

Observe como após **carregar** o **executável** no GEF você pode **ver** as **funções** que estão na **GOT**: `gef➤ x/20x 0xADDR_GOT`

![](<../../images/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (2) (2).png>)

Usando o GEF, você pode **iniciar** uma sessão de **depuração** e executar **`got`** para ver a tabela got:

![](<../../images/image (496).png>)

### GOT2Exec

Em um binário, a GOT tem os **endereços para as funções ou** para a **seção PLT** que irá carregar o endereço da função. O objetivo desta escrita arbitrária é **substituir uma entrada da GOT** de uma função que será executada mais tarde **com** o **endereço** da PLT da **função** **`system`**, por exemplo.

Idealmente, você irá **substituir** a **GOT** de uma **função** que está **prestes a ser chamada com parâmetros controlados por você** (assim você poderá controlar os parâmetros enviados para a função system).

Se **`system`** **não for usado** pelo binário, a função system **não terá** uma entrada na PLT. Nesse cenário, você **precisará vazar primeiro o endereço** da função `system` e então sobrescrever a GOT para apontar para esse endereço.

Você pode ver os endereços da PLT com **`objdump -j .plt -d ./vuln_binary`**

## Entradas da GOT libc

A **GOT da libc** geralmente é compilada com **RELRO parcial**, tornando-a um bom alvo para isso, supondo que seja possível descobrir seu endereço ([**ASLR**](../common-binary-protections-and-bypasses/aslr/)).

Funções comuns da libc vão chamar **outras funções internas** cujas GOT poderiam ser sobrescritas para obter execução de código.

Encontre [**mais informações sobre esta técnica aqui**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#1---targetting-libc-got-entries).

### **Free2system**

Em explorações de heap em CTFs, é comum conseguir controlar o conteúdo de chunks e em algum momento até sobrescrever a tabela GOT. Um truque simples para obter RCE se gadgets não estiverem disponíveis é sobrescrever o endereço GOT de `free` para apontar para `system` e escrever dentro de um chunk `"/bin/sh"`. Dessa forma, quando esse chunk for liberado, ele executará `system("/bin/sh")`.

### **Strlen2system**

Outra técnica comum é sobrescrever o endereço GOT de **`strlen`** para apontar para **`system`**, então se essa função for chamada com entrada do usuário, é possível passar a string `"/bin/sh"` e obter um shell.

Além disso, se `puts` for usado com entrada do usuário, é possível sobrescrever o endereço GOT de `strlen` para apontar para `system` e passar a string `"/bin/sh"` para obter um shell porque **`puts` chamará `strlen` com a entrada do usuário**.

## **One Gadget**

{{#ref}}
../rop-return-oriented-programing/ret2lib/one-gadget.md
{{#endref}}

## **Abusando da GOT do Heap**

Uma maneira comum de obter RCE a partir de uma vulnerabilidade de heap é abusar de um fastbin para que seja possível adicionar a parte da tabela GOT no fast bin, de modo que sempre que esse chunk for alocado, será possível **sobrescrever o ponteiro de uma função, geralmente `free`**.\
Então, apontando `free` para `system` e liberando um chunk onde foi escrito `/bin/sh\x00` executará um shell.

É possível encontrar um [**exemplo aqui**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/chunk_extend_overlapping/#hitcon-trainging-lab13)**.**

## **Proteções**

A proteção **Full RELRO** é destinada a proteger contra esse tipo de técnica resolvendo todos os endereços das funções quando o binário é iniciado e tornando a **tabela GOT somente leitura** após isso:

{{#ref}}
../common-binary-protections-and-bypasses/relro.md
{{#endref}}

## Referências

- [https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite](https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite)
- [https://ir0nstone.gitbook.io/notes/types/stack/one-gadgets-and-malloc-hook](https://ir0nstone.gitbook.io/notes/types/stack/one-gadgets-and-malloc-hook)

{{#include ../../banners/hacktricks-training.md}}
