# WWW2Exec - GOT/PLT

{{#include ../../banners/hacktricks-training.md}}

## **बुनियादी जानकारी**

### **GOT: ग्लोबल ऑफसेट टेबल**

**ग्लोबल ऑफसेट टेबल (GOT)** एक तंत्र है जो गतिशील रूप से लिंक किए गए बाइनरी में **बाहरी कार्यों के पते** को प्रबंधित करने के लिए उपयोग किया जाता है। चूंकि ये **पते रनटाइम तक ज्ञात नहीं होते** (गतिशील लिंकिंग के कारण), GOT एक तरीका प्रदान करता है जिससे **इन बाहरी प्रतीकों के पते को गतिशील रूप से अपडेट किया जा सके** जब वे हल हो जाते हैं।

GOT में प्रत्येक प्रविष्टि उस प्रतीक से संबंधित होती है जो बाहरी पुस्तकालयों में हो सकती है जिसे बाइनरी कॉल कर सकता है। जब एक **कार्य को पहली बार कॉल किया जाता है, तो इसका वास्तविक पता गतिशील लिंकर्स द्वारा हल किया जाता है और GOT में संग्रहीत किया जाता है**। उसी कार्य को बाद में कॉल करने पर GOT में संग्रहीत पते का उपयोग किया जाता है, इस प्रकार फिर से पते को हल करने का ओवरहेड बचता है।

### **PLT: प्रक्रिया लिंक टेबल**

**प्रक्रिया लिंक टेबल (PLT)** GOT के साथ निकटता से काम करता है और बाहरी कार्यों को कॉल करने के लिए एक ट्रम्पोलिन के रूप में कार्य करता है। जब एक बाइनरी **पहली बार एक बाहरी कार्य को कॉल करता है, तो नियंत्रण उस कार्य से संबंधित PLT में एक प्रविष्टि को सौंपा जाता है**। यह PLT प्रविष्टि उस कार्य के पते को हल करने के लिए गतिशील लिंकर्स को सक्रिय करने के लिए जिम्मेदार होती है यदि इसे पहले से हल नहीं किया गया है। पते के हल होने के बाद, इसे **GOT** में संग्रहीत किया जाता है।

**इसलिए,** GOT प्रविष्टियाँ सीधे उपयोग की जाती हैं जब एक बाहरी कार्य या चर का पता हल हो जाता है। **PLT प्रविष्टियाँ इन पते को गतिशील लिंकर्स के माध्यम से प्रारंभिक समाधान को सुविधाजनक बनाने के लिए उपयोग की जाती हैं।**

## निष्पादन प्राप्त करें

### GOT की जाँच करें

GOT तालिका का पता प्राप्त करने के लिए: **`objdump -s -j .got ./exec`**

![](<../../images/image (121).png>)

देखें कि **GEF** में **कार्यकारी** को **लोड** करने के बाद आप **GOT** में **कार्य** कैसे **देख सकते हैं**: `gef➤ x/20x 0xADDR_GOT`

![](<../../images/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (2) (2).png>)

GEF का उपयोग करके आप **डिबगिंग** सत्र शुरू कर सकते हैं और GOT तालिका देखने के लिए **`got`** निष्पादित कर सकते हैं:

![](<../../images/image (496).png>)

### GOT2Exec

एक बाइनरी में GOT के पास **कार्य या** PLT अनुभाग के **पते** होते हैं जो कार्य के पते को लोड करेगा। इस मनमाने लेखन का लक्ष्य एक कार्य के GOT प्रविष्टि को **ओवरराइड करना** है जिसे बाद में **`system`** **कार्य** के PLT के **पते** के साथ निष्पादित किया जाएगा।

आदर्श रूप से, आप एक **कार्य** के **GOT** को **ओवरराइड** करेंगे जिसे **आपके द्वारा नियंत्रित पैरामीटर के साथ कॉल किया जाएगा** (ताकि आप सिस्टम कार्य को भेजे गए पैरामीटर को नियंत्रित कर सकें)।

यदि **`system`** **बाइनरी द्वारा उपयोग नहीं किया गया है**, तो सिस्टम कार्य का **PLT में कोई प्रविष्टि नहीं होगी**। इस परिदृश्य में, आपको पहले `system` कार्य का पता लीक करना होगा और फिर GOT को इस पते की ओर इंगित करने के लिए ओवरराइड करना होगा।

आप PLT पते देख सकते हैं **`objdump -j .plt -d ./vuln_binary`** के साथ।

## libc GOT प्रविष्टियाँ

**libc का GOT** आमतौर पर **आंशिक RELRO** के साथ संकलित होता है, जिससे यह इस तकनीक के लिए एक अच्छा लक्ष्य बनता है यदि इसका पता लगाना संभव हो ([**ASLR**](../common-binary-protections-and-bypasses/aslr/))।

libc के सामान्य कार्य **अन्य आंतरिक कार्यों** को कॉल करने जा रहे हैं जिनका GOT ओवरराइड किया जा सकता है ताकि कोड निष्पादन प्राप्त किया जा सके।

[**इस तकनीक के बारे में अधिक जानकारी यहाँ प्राप्त करें**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#1---targetting-libc-got-entries)।

### **Free2system**

हीप शोषण CTFs में यह सामान्य है कि आप चंक्स की सामग्री को नियंत्रित कर सकें और किसी बिंदु पर GOT तालिका को भी ओवरराइड कर सकें। यदि एक गैजेट उपलब्ध नहीं है तो RCE प्राप्त करने के लिए एक सरल चाल `free` GOT पते को `system` की ओर इंगित करना और एक चंक में `"/bin/sh"` लिखना है। इस तरह जब इस चंक को मुक्त किया जाएगा, यह `system("/bin/sh")` को निष्पादित करेगा।

### **Strlen2system**

एक और सामान्य तकनीक **`strlen`** GOT पते को **`system`** की ओर इंगित करना है, ताकि यदि इस कार्य को उपयोगकर्ता इनपुट के साथ कॉल किया जाए तो यह संभव हो कि स्ट्रिंग `"/bin/sh"` पास की जाए और एक शेल प्राप्त किया जा सके।

इसके अलावा, यदि `puts` का उपयोग उपयोगकर्ता इनपुट के साथ किया जाता है, तो `strlen` GOT पते को `system` की ओर इंगित करने के लिए ओवरराइड करना संभव है और स्ट्रिंग `"/bin/sh"` पास करना संभव है ताकि एक शेल प्राप्त किया जा सके क्योंकि **`puts` उपयोगकर्ता इनपुट के साथ `strlen` को कॉल करेगा**।

## **One Gadget**

{{#ref}}
../rop-return-oriented-programing/ret2lib/one-gadget.md
{{#endref}}

## **हीप से GOT का दुरुपयोग करना**

हीप भेद्यता से RCE प्राप्त करने का एक सामान्य तरीका एक फास्टबिन का दुरुपयोग करना है ताकि GOT तालिका के भाग को फास्ट बिन में जोड़ा जा सके, ताकि जब भी उस चंक को आवंटित किया जाएगा, यह संभव होगा कि **एक कार्य के पते को ओवरराइड किया जा सके, आमतौर पर `free`**।\
फिर, `free` को `system` की ओर इंगित करना और एक चंक को मुक्त करना जहाँ `/bin/sh\x00` लिखा गया था, एक शेल को निष्पादित करेगा।

यहाँ एक [**उदाहरण पाया जा सकता है**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/chunk_extend_overlapping/#hitcon-trainging-lab13)**।**

## **सुरक्षाएँ**

**पूर्ण RELRO** सुरक्षा इस प्रकार की तकनीक के खिलाफ सुरक्षा के लिए बनाई गई है, सभी कार्यों के पते को बाइनरी शुरू होने पर हल करके और इसके बाद **GOT तालिका को केवल पढ़ने योग्य** बनाकर:

{{#ref}}
../common-binary-protections-and-bypasses/relro.md
{{#endref}}

## संदर्भ

- [https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite](https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite)
- [https://ir0nstone.gitbook.io/notes/types/stack/one-gadgets-and-malloc-hook](https://ir0nstone.gitbook.io/notes/types/stack/one-gadgets-and-malloc-hook)

{{#include ../../banners/hacktricks-training.md}}
