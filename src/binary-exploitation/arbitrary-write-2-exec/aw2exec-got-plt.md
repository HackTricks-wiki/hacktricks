# WWW2Exec - GOT/PLT

{{#include ../../banners/hacktricks-training.md}}

## **Podstawowe informacje**

### **GOT: Global Offset Table**

**Global Offset Table (GOT)** to mechanizm używany w dynamicznie linkowanych binariach do zarządzania **adresami funkcji zewnętrznych**. Ponieważ te **adresy nie są znane aż do czasu wykonania** (z powodu dynamicznego linkowania), GOT zapewnia sposób na **dynamiczne aktualizowanie adresów tych zewnętrznych symboli** po ich rozwiązaniu.

Każdy wpis w GOT odpowiada symbolowi w zewnętrznych bibliotekach, które może wywołać binarne. Gdy **funkcja jest wywoływana po raz pierwszy, jej rzeczywisty adres jest rozwiązywany przez dynamiczny linker i przechowywany w GOT**. Kolejne wywołania tej samej funkcji korzystają z adresu przechowywanego w GOT, unikając w ten sposób narzutu związanego z ponownym rozwiązywaniem adresu.

### **PLT: Procedure Linkage Table**

**Procedure Linkage Table (PLT)** działa blisko z GOT i służy jako trampolina do obsługi wywołań funkcji zewnętrznych. Gdy binarne **wywołuje funkcję zewnętrzną po raz pierwszy, kontrola jest przekazywana do wpisu w PLT powiązanego z tą funkcją**. Ten wpis PLT jest odpowiedzialny za wywołanie dynamicznego linkera w celu rozwiązania adresu funkcji, jeśli nie został on jeszcze rozwiązany. Po rozwiązaniu adresu jest on przechowywany w **GOT**.

**Dlatego** wpisy GOT są używane bezpośrednio, gdy adres funkcji lub zmiennej zewnętrznej jest rozwiązany. **Wpisy PLT są używane do ułatwienia początkowego rozwiązania** tych adresów za pośrednictwem dynamicznego linkera.

## Uzyskaj wykonanie

### Sprawdź GOT

Uzyskaj adres do tabeli GOT za pomocą: **`objdump -s -j .got ./exec`**

![](<../../images/image (121).png>)

Zauważ, jak po **załadowaniu** **wykonywalnego** w GEF możesz **zobaczyć** **funkcje**, które są w **GOT**: `gef➤ x/20x 0xADDR_GOT`

![](<../../images/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (2) (2).png>)

Korzystając z GEF, możesz **rozpocząć** sesję **debugowania** i wykonać **`got`**, aby zobaczyć tabelę got:

![](<../../images/image (496).png>)

### GOT2Exec

W binarnym GOT ma **adresy do funkcji lub** do sekcji **PLT**, która załadowuje adres funkcji. Celem tego arbitralnego zapisu jest **nadpisanie wpisu GOT** funkcji, która ma być wykonana później **z** **adresem** PLT funkcji **`system`** na przykład.

Idealnie, chcesz **nadpisać** **GOT** funkcji, która **ma być wywołana z parametrami kontrolowanymi przez Ciebie** (abyś mógł kontrolować parametry wysyłane do funkcji systemowej).

Jeśli **`system`** **nie jest używany** przez binarne, funkcja systemowa **nie będzie** miała wpisu w PLT. W tym scenariuszu będziesz **musiał najpierw wycieknąć adres** funkcji `system`, a następnie nadpisać GOT, aby wskazywał na ten adres.

Możesz zobaczyć adresy PLT za pomocą **`objdump -j .plt -d ./vuln_binary`**

## wpisy GOT libc

**GOT libc** jest zazwyczaj kompilowane z **częściowym RELRO**, co czyni go dobrym celem dla tej techniki, zakładając, że możliwe jest ustalenie jego adresu ([**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html)).

Typowe funkcje libc będą wywoływać **inne funkcje wewnętrzne**, których GOT mogłoby być nadpisane w celu uzyskania wykonania kodu.

Znajdź [**więcej informacji na temat tej techniki tutaj**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#1---targetting-libc-got-entries).

### **Free2system**

W eksploitacji heap w CTF często można kontrolować zawartość kawałków i w pewnym momencie nawet nadpisać tabelę GOT. Prosty trik, aby uzyskać RCE, jeśli gadżety nie są dostępne, to nadpisać adres GOT `free`, aby wskazywał na `system` i zapisać w kawałku `"/bin/sh"`. W ten sposób, gdy ten kawałek zostanie zwolniony, wykona `system("/bin/sh")`.

### **Strlen2system**

Inną powszechną techniką jest nadpisanie adresu GOT **`strlen`**, aby wskazywał na **`system`**, więc jeśli ta funkcja jest wywoływana z danymi wejściowymi użytkownika, możliwe jest przekazanie ciągu `"/bin/sh"` i uzyskanie powłoki.

Ponadto, jeśli `puts` jest używane z danymi wejściowymi użytkownika, możliwe jest nadpisanie adresu GOT `strlen`, aby wskazywał na `system` i przekazanie ciągu `"/bin/sh"`, aby uzyskać powłokę, ponieważ **`puts` wywoła `strlen` z danymi wejściowymi użytkownika**.

## **One Gadget**

{{#ref}}
../rop-return-oriented-programing/ret2lib/one-gadget.md
{{#endref}}

## **Wykorzystywanie GOT z Heap**

Powszechnym sposobem uzyskania RCE z podatności na heap jest nadużycie fastbina, aby można było dodać część tabeli GOT do fastbina, więc za każdym razem, gdy ten kawałek jest przydzielany, będzie można **nadpisać wskaźnik funkcji, zazwyczaj `free`**.\
Następnie, wskazując `free` na `system` i zwalniając kawałek, w którym zapisano `/bin/sh\x00`, wykona powłokę.

Możliwe jest znalezienie [**przykładu tutaj**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/chunk_extend_overlapping/#hitcon-trainging-lab13)**.**

## **Ochrony**

Ochrona **Full RELRO** ma na celu ochronę przed tego rodzaju techniką, rozwiązując wszystkie adresy funkcji, gdy binarne jest uruchamiane i czyniąc tabelę **GOT tylko do odczytu** po tym:

{{#ref}}
../common-binary-protections-and-bypasses/relro.md
{{#endref}}

## Referencje

- [https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite](https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite)
- [https://ir0nstone.gitbook.io/notes/types/stack/one-gadgets-and-malloc-hook](https://ir0nstone.gitbook.io/notes/types/stack/one-gadgets-and-malloc-hook)

{{#include ../../banners/hacktricks-training.md}}
