# WWW2Exec - GOT/PLT

{{#include ../../banners/hacktricks-training.md}}

## **기본 정보**

### **GOT: 전역 오프셋 테이블**

**전역 오프셋 테이블(GOT)**은 동적으로 연결된 바이너리에서 **외부 함수의 주소**를 관리하는 메커니즘입니다. 이러한 **주소는 런타임까지 알 수 없기 때문에**(동적 연결로 인해), GOT는 **이 외부 기호의 주소를 동적으로 업데이트하는 방법**을 제공합니다.

GOT의 각 항목은 바이너리가 호출할 수 있는 외부 라이브러리의 기호에 해당합니다. **함수가 처음 호출될 때, 동적 링커에 의해 실제 주소가 해결되어 GOT에 저장됩니다**. 이후 동일한 함수에 대한 호출은 GOT에 저장된 주소를 사용하여 주소를 다시 해결하는 오버헤드를 피합니다.

### **PLT: 프로시저 링크 테이블**

**프로시저 링크 테이블(PLT)**은 GOT와 밀접하게 작동하며 외부 함수 호출을 처리하는 트램폴린 역할을 합니다. 바이너리가 **외부 함수를 처음 호출할 때, 제어는 해당 함수와 연결된 PLT의 항목으로 전달됩니다**. 이 PLT 항목은 함수의 주소가 아직 해결되지 않은 경우 동적 링커를 호출하여 주소를 해결하는 역할을 합니다. 주소가 해결된 후, 그것은 **GOT**에 저장됩니다.

**따라서,** GOT 항목은 외부 함수나 변수의 주소가 해결된 후 직접 사용됩니다. **PLT 항목은 이러한 주소를 동적 링커를 통해 초기 해결하는 데 사용됩니다.**

## 실행 가져오기

### GOT 확인

GOT 테이블의 주소를 가져오려면: **`objdump -s -j .got ./exec`**

![](<../../images/image (121).png>)

GEF에서 **실행 파일을 로드한 후** **GOT에 있는 함수**를 **볼 수 있는 방법**을 관찰하세요: `gef➤ x/20x 0xADDR_GOT`

![](<../../images/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (2) (2).png>)

GEF를 사용하여 **디버깅** 세션을 시작하고 **`got`**를 실행하여 GOT 테이블을 확인할 수 있습니다:

![](<../../images/image (496).png>)

### GOT2Exec

바이너리에서 GOT는 **함수의 주소** 또는 **PLT** 섹션의 주소를 가지고 있어 함수 주소를 로드합니다. 이 임의 쓰기의 목표는 **나중에 실행될 함수의 GOT 항목을** **`system`** **함수의 PLT 주소로 덮어쓰는 것입니다**.

이상적으로는, **당신이 제어할 수 있는 매개변수로 호출될 함수의 GOT를 덮어써야 합니다**(그래야 시스템 함수에 전달되는 매개변수를 제어할 수 있습니다).

만약 **`system`** **이 바이너리에서 사용되지 않는다면**, 시스템 함수는 **PLT에 항목이 없을 것입니다**. 이 경우, 먼저 `system` 함수의 주소를 **유출**한 다음 GOT를 이 주소를 가리키도록 덮어써야 합니다.

PLT 주소는 **`objdump -j .plt -d ./vuln_binary`**로 확인할 수 있습니다.

## libc GOT 항목

**libc의 GOT**는 일반적으로 **부분 RELRO**로 컴파일되어 있어, 그 주소를 파악할 수 있다면 좋은 목표가 됩니다 ([**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html)).

libc의 일반적인 함수는 **다른 내부 함수**를 호출할 것이며, 이 함수의 GOT는 코드 실행을 얻기 위해 덮어쓸 수 있습니다.

[**이 기술에 대한 더 많은 정보는 여기에서 확인하세요**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#1---targetting-libc-got-entries).

### **Free2system**

힙 익스플로잇 CTF에서는 청크의 내용을 제어할 수 있고, 때때로 GOT 테이블을 덮어쓸 수 있는 것이 일반적입니다. 가젯이 사용 불가능할 경우 RCE를 얻기 위한 간단한 트릭은 `free` GOT 주소를 `system`을 가리키도록 덮어쓰고, 청크에 `"/bin/sh"`를 작성하는 것입니다. 이렇게 하면 이 청크가 해제될 때 `system("/bin/sh")`가 실행됩니다.

### **Strlen2system**

또 다른 일반적인 기술은 **`strlen`** GOT 주소를 **`system`**을 가리키도록 덮어쓰는 것입니다. 따라서 이 함수가 사용자 입력으로 호출되면 문자열 `"/bin/sh"`를 전달하여 셸을 얻을 수 있습니다.

게다가, `puts`가 사용자 입력과 함께 사용되면, `strlen` GOT 주소를 `system`을 가리키도록 덮어쓰고 문자열 `"/bin/sh"`를 전달하여 셸을 얻을 수 있습니다. 왜냐하면 **`puts`가 사용자 입력으로 `strlen`을 호출하기 때문입니다**.

## **One Gadget**

{{#ref}}
../rop-return-oriented-programing/ret2lib/one-gadget.md
{{#endref}}

## **힙에서 GOT 악용하기**

힙 취약점에서 RCE를 얻는 일반적인 방법은 빠른 빈을 악용하여 GOT 테이블의 일부를 빠른 빈에 추가하는 것입니다. 이렇게 하면 해당 청크가 할당될 때 **일반적으로 `free`의 포인터를 덮어쓸 수 있습니다**.\
그런 다음 `free`를 `system`을 가리키도록 하고 `/bin/sh\x00`가 작성된 청크를 해제하면 셸이 실행됩니다.

[**여기에서 예제를 찾을 수 있습니다**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/chunk_extend_overlapping/#hitcon-trainging-lab13)**.**

## **보호**

**전체 RELRO** 보호는 이와 같은 기술을 방지하기 위해 바이너리가 시작될 때 모든 함수의 주소를 해결하고, 그 후 **GOT 테이블을 읽기 전용**으로 만드는 것을 목표로 합니다:

{{#ref}}
../common-binary-protections-and-bypasses/relro.md
{{#endref}}

## 참고 문헌

- [https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite](https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite)
- [https://ir0nstone.gitbook.io/notes/types/stack/one-gadgets-and-malloc-hook](https://ir0nstone.gitbook.io/notes/types/stack/one-gadgets-and-malloc-hook)

{{#include ../../banners/hacktricks-training.md}}
