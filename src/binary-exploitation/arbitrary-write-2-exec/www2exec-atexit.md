# WWW2Exec - atexit(), TLS Storage & Other mangled Pointers

{{#include ../../banners/hacktricks-training.md}}

## **\_\_atexit Structures**

> [!CAUTION]
> आजकल इसे **शोषण करना बहुत अजीब है!**

**`atexit()`** एक फ़ंक्शन है जिसमें **अन्य फ़ंक्शनों** को पैरामीटर के रूप में पास किया जाता है। ये **फ़ंक्शन** तब **निष्पादित** होंगे जब **`exit()`** या **main** का **रिटर्न** किया जाएगा।\
यदि आप इन **फ़ंक्शनों** में से किसी के **पते** को एक शेलकोड की ओर **संशोधित** कर सकते हैं, तो आप **प्रक्रिया** पर **नियंत्रण** प्राप्त कर लेंगे, लेकिन यह वर्तमान में अधिक जटिल है।\
वर्तमान में निष्पादित होने वाले **फ़ंक्शनों के पते** कई संरचनाओं के पीछे **छिपे** हुए हैं और अंततः जिस पते की ओर यह इशारा करते हैं, वे फ़ंक्शनों के पते नहीं हैं, बल्कि **XOR** और एक **यादृच्छिक कुंजी** के साथ विस्थापनों के साथ **एन्क्रिप्टेड** हैं। इसलिए वर्तमान में यह हमले का वेक्टर **कम से कम x86** और **x64_86** पर **बहुत उपयोगी नहीं है**।\
**एन्क्रिप्शन फ़ंक्शन** **`PTR_MANGLE`** है। **अन्य आर्किटेक्चर** जैसे m68k, mips32, mips64, aarch64, arm, hppa... **एन्क्रिप्शन** फ़ंक्शन को **क्रियान्वित नहीं करते** क्योंकि यह **वही** लौटाता है जो इसे इनपुट के रूप में प्राप्त होता है। इसलिए ये आर्किटेक्चर इस वेक्टर द्वारा हमले के लिए **संवेदनशील होंगे**।

आप इस पर गहन व्याख्या [https://m101.github.io/binholic/2017/05/20/notes-on-abusing-exit-handlers.html](https://m101.github.io/binholic/2017/05/20/notes-on-abusing-exit-handlers.html) पर पा सकते हैं।

## link_map

जैसा कि [**इस पोस्ट में**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#2---targetting-ldso-link_map-structure) समझाया गया है, यदि प्रोग्राम `return` या `exit()` का उपयोग करके समाप्त होता है, तो यह `__run_exit_handlers()` को चलाएगा जो पंजीकृत डेस्ट्रक्टर्स को कॉल करेगा।

> [!CAUTION]
> यदि प्रोग्राम **`_exit()`** फ़ंक्शन के माध्यम से समाप्त होता है, तो यह **`exit` syscall** को कॉल करेगा और निकासी हैंडलर निष्पादित नहीं होंगे। इसलिए, यह पुष्टि करने के लिए कि `__run_exit_handlers()` निष्पादित होता है, आप इस पर एक ब्रेकपॉइंट सेट कर सकते हैं।

महत्वपूर्ण कोड है ([source](https://elixir.bootlin.com/glibc/glibc-2.32/source/elf/dl-fini.c#L131)):
```c
ElfW(Dyn) *fini_array = map->l_info[DT_FINI_ARRAY];
if (fini_array != NULL)
{
ElfW(Addr) *array = (ElfW(Addr) *) (map->l_addr + fini_array->d_un.d_ptr);
size_t sz = (map->l_info[DT_FINI_ARRAYSZ]->d_un.d_val / sizeof (ElfW(Addr)));

while (sz-- > 0)
((fini_t) array[sz]) ();
}
[...]




// This is the d_un structure
ptype l->l_info[DT_FINI_ARRAY]->d_un
type = union {
Elf64_Xword d_val;	// address of function that will be called, we put our onegadget here
Elf64_Addr d_ptr;	// offset from l->l_addr of our structure
}
```
ध्यान दें कि `map -> l_addr + fini_array -> d_un.d_ptr` का उपयोग **स्थान** की गणना करने के लिए किया जाता है **कार्यक्रमों की सूची को कॉल करने के लिए**।

कुछ **विकल्प** हैं:

- `map->l_addr` के मान को ओवरराइट करें ताकि यह एक **नकली `fini_array`** की ओर इंगित करे जिसमें मनमाने कोड को निष्पादित करने के लिए निर्देश हों।
- `l_info[DT_FINI_ARRAY]` और `l_info[DT_FINI_ARRAYSZ]` प्रविष्टियों को ओवरराइट करें (जो मेमोरी में अधिक या कम लगातार होते हैं), ताकि वे **एक जाली `Elf64_Dyn`** संरचना की ओर इंगित करें जो फिर से **`array` को एक मेमोरी** क्षेत्र की ओर इंगित करेगा जिसे हमलावर ने नियंत्रित किया।
- [**यह लेख**](https://github.com/nobodyisnobody/write-ups/tree/main/DanteCTF.2023/pwn/Sentence.To.Hell) `l_info[DT_FINI_ARRAY]` को `.bss` में नियंत्रित मेमोरी के पते से ओवरराइट करता है जिसमें एक नकली `fini_array` है। यह नकली सूची **पहले एक** [**one gadget**](../rop-return-oriented-programing/ret2lib/one-gadget.md) **पता** शामिल करती है जिसे निष्पादित किया जाएगा और फिर **इस** **नकली सूची** के पते और `map->l_addr` के **मान** के बीच का **अंतर** ताकि `*array` नकली सूची की ओर इंगित करे।
- इस तकनीक के मुख्य पोस्ट के अनुसार और [**यह लेख**](https://activities.tjhsst.edu/csc/writeups/angstromctf-2021-wallstreet) ld.so एक पॉइंटर को स्टैक पर छोड़ता है जो ld.so में बाइनरी `link_map` की ओर इंगित करता है। एक मनमाने लेखन के साथ इसे ओवरराइट करना संभव है और इसे एक नकली `fini_array` की ओर इंगित करना संभव है जिसे हमलावर द्वारा नियंत्रित किया गया है जिसमें एक [**one gadget**](../rop-return-oriented-programing/ret2lib/one-gadget.md) का पता है, उदाहरण के लिए।

पिछले कोड के बाद आप कोड के साथ एक और दिलचस्प अनुभाग पा सकते हैं:
```c
/* Next try the old-style destructor.  */
ElfW(Dyn) *fini = map->l_info[DT_FINI];
if (fini != NULL)
DL_CALL_DT_FINI (map, ((void *) map->l_addr + fini->d_un.d_ptr));
}
```
इस मामले में `map->l_info[DT_FINI]` के मान को एक forged `ElfW(Dyn)` संरचना की ओर इंगित करके ओवरराइट करना संभव होगा। [**यहां अधिक जानकारी प्राप्त करें**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#2---targetting-ldso-link_map-structure)।

## TLS-Storage dtor_list ओवरराइट करना **`__run_exit_handlers`** में

जैसा कि [**यहां समझाया गया है**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#5---code-execution-via-tls-storage-dtor_list-overwrite), यदि कोई प्रोग्राम `return` या `exit()` के माध्यम से बाहर निकलता है, तो यह **`__run_exit_handlers()`** को निष्पादित करेगा जो किसी भी पंजीकृत डेस्ट्रक्टर फ़ंक्शन को कॉल करेगा।

`_run_exit_handlers()` से कोड:
```c
/* Call all functions registered with `atexit' and `on_exit',
in the reverse of the order in which they were registered
perform stdio cleanup, and terminate program execution with STATUS.  */
void
attribute_hidden
__run_exit_handlers (int status, struct exit_function_list **listp,
bool run_list_atexit, bool run_dtors)
{
/* First, call the TLS destructors.  */
#ifndef SHARED
if (&__call_tls_dtors != NULL)
#endif
if (run_dtors)
__call_tls_dtors ();
```
**`__call_tls_dtors()`** का कोड:
```c
typedef void (*dtor_func) (void *);
struct dtor_list //struct added
{
dtor_func func;
void *obj;
struct link_map *map;
struct dtor_list *next;
};

[...]
/* Call the destructors.  This is called either when a thread returns from the
initial function or when the process exits via the exit function.  */
void
__call_tls_dtors (void)
{
while (tls_dtor_list)		// parse the dtor_list chained structures
{
struct dtor_list *cur = tls_dtor_list;		// cur point to tls-storage dtor_list
dtor_func func = cur->func;
PTR_DEMANGLE (func);						// demangle the function ptr

tls_dtor_list = tls_dtor_list->next;		// next dtor_list structure
func (cur->obj);
[...]
}
}
```
प्रत्येक पंजीकृत फ़ंक्शन के लिए **`tls_dtor_list`**, यह **`cur->func`** से पॉइंटर को डिमैंगल करेगा और इसे **`cur->obj`** के साथ कॉल करेगा।

इस [**GEF के फोर्क**](https://github.com/bata24/gef) से **`tls`** फ़ंक्शन का उपयोग करते हुए, यह देखना संभव है कि वास्तव में **`dtor_list`** **stack canary** और **PTR_MANGLE cookie** के बहुत **करीब** है। इसलिए, इसके ओवरफ्लो के साथ **cookie** और **stack canary** को **overwrite** करना संभव होगा।\
PTR_MANGLE cookie को ओवरराइट करने पर, **`PTR_DEMANLE` फ़ंक्शन** को 0x00 पर सेट करके **bypass** करना संभव होगा, जिसका अर्थ है कि वास्तविक पते को प्राप्त करने के लिए उपयोग किया गया **`xor`** केवल कॉन्फ़िगर किया गया पता है। फिर, **`dtor_list`** पर लिखकर, यह संभव है कि **कई फ़ंक्शंस** को फ़ंक्शन **पते** और इसके **आर्गुमेंट** के साथ **चेन** किया जा सके।

अंत में ध्यान दें कि संग्रहीत पॉइंटर केवल cookie के साथ xored नहीं होगा बल्कि 17 बिट्स भी घुमाया जाएगा:
```armasm
0x00007fc390444dd4 <+36>:	mov    rax,QWORD PTR [rbx]      --> mangled ptr
0x00007fc390444dd7 <+39>:	ror    rax,0x11		        --> rotate of 17 bits
0x00007fc390444ddb <+43>:	xor    rax,QWORD PTR fs:0x30	--> xor with PTR_MANGLE
```
इससे पहले कि आप एक नया पता जोड़ें, आपको इसे ध्यान में रखना होगा।

[**मूल पोस्ट**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#5---code-execution-via-tls-storage-dtor_list-overwrite) में एक उदाहरण खोजें।

## अन्य मंगले हुए पॉइंटर्स **`__run_exit_handlers`** में

यह तकनीक [**यहां समझाई गई है**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#5---code-execution-via-tls-storage-dtor_list-overwrite) और फिर से इस पर निर्भर करती है कि प्रोग्राम **`return` या `exit()`** कॉल करके **बंद हो रहा है** ताकि **`__run_exit_handlers()`** को कॉल किया जा सके।

आइए इस फ़ंक्शन का अधिक कोड देखें:
```c
while (true)
{
struct exit_function_list *cur;

restart:
cur = *listp;

if (cur == NULL)
{
/* Exit processing complete.  We will not allow any more
atexit/on_exit registrations.  */
__exit_funcs_done = true;
break;
}

while (cur->idx > 0)
{
struct exit_function *const f = &cur->fns[--cur->idx];
const uint64_t new_exitfn_called = __new_exitfn_called;

switch (f->flavor)
{
void (*atfct) (void);
void (*onfct) (int status, void *arg);
void (*cxafct) (void *arg, int status);
void *arg;

case ef_free:
case ef_us:
break;
case ef_on:
onfct = f->func.on.fn;
arg = f->func.on.arg;
PTR_DEMANGLE (onfct);

/* Unlock the list while we call a foreign function.  */
__libc_lock_unlock (__exit_funcs_lock);
onfct (status, arg);
__libc_lock_lock (__exit_funcs_lock);
break;
case ef_at:
atfct = f->func.at;
PTR_DEMANGLE (atfct);

/* Unlock the list while we call a foreign function.  */
__libc_lock_unlock (__exit_funcs_lock);
atfct ();
__libc_lock_lock (__exit_funcs_lock);
break;
case ef_cxa:
/* To avoid dlclose/exit race calling cxafct twice (BZ 22180),
we must mark this function as ef_free.  */
f->flavor = ef_free;
cxafct = f->func.cxa.fn;
arg = f->func.cxa.arg;
PTR_DEMANGLE (cxafct);

/* Unlock the list while we call a foreign function.  */
__libc_lock_unlock (__exit_funcs_lock);
cxafct (arg, status);
__libc_lock_lock (__exit_funcs_lock);
break;
}

if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))
/* The last exit function, or another thread, has registered
more exit functions.  Start the loop over.  */
goto restart;
}

*listp = cur->next;
if (*listp != NULL)
/* Don't free the last element in the chain, this is the statically
allocate element.  */
free (cur);
}

__libc_lock_unlock (__exit_funcs_lock);
```
चर `f` **`initial`** संरचना की ओर इशारा करता है और `f->flavor` के मान के आधार पर विभिन्न कार्यों को कॉल किया जाएगा।\
मान के आधार पर, कॉल करने के लिए कार्य का पता एक अलग स्थान पर होगा, लेकिन यह हमेशा **demangled** होगा।

इसके अलावा, विकल्प **`ef_on`** और **`ef_cxa`** में एक **argument** को नियंत्रित करना भी संभव है।

आप **`initial` संरचना** को GEF के साथ डिबगिंग सत्र में **`gef> p initial`** चलाकर जांच सकते हैं।

इसका दुरुपयोग करने के लिए, आपको या तो **leak या `PTR_MANGLE`cookie** को मिटाना होगा और फिर `system('/bin/sh')` के साथ `initial` में एक `cxa` प्रविष्टि को ओवरराइट करना होगा।\
आप इस तकनीक के बारे में [**मूल ब्लॉग पोस्ट**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#6---code-execution-via-other-mangled-pointers-in-initial-structure) में इसका एक उदाहरण पा सकते हैं।

{{#include ../../banners/hacktricks-training.md}}
