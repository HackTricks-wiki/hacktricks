# WWW2Exec - .dtors & .fini_array

{{#include ../../banners/hacktricks-training.md}}

## .dtors

> [!CAUTION]
> Hoje em dia é muito **estranho encontrar um binário com uma seção .dtors!**

Os destrutores são funções que são **executadas antes do programa terminar** (após a função `main` retornar).\
Os endereços dessas funções são armazenados dentro da seção **`.dtors`** do binário e, portanto, se você conseguir **escrever** o **endereço** em um **shellcode** em **`__DTOR_END__`**, isso será **executado** antes que o programa termine.

Obtenha o endereço desta seção com:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
Geralmente, você encontrará os marcadores **DTOR** **entre** os valores `ffffffff` e `00000000`. Então, se você apenas ver esses valores, isso significa que **não há nenhuma função registrada**. Portanto, **sobrescreva** o **`00000000`** com o **endereço** do **shellcode** para executá-lo.

> [!WARNING]
> Claro, você primeiro precisa encontrar um **lugar para armazenar o shellcode** para depois chamá-lo.

## **.fini_array**

Essencialmente, esta é uma estrutura com **funções que serão chamadas** antes do programa terminar, como **`.dtors`**. Isso é interessante se você puder chamar seu **shellcode apenas pulando para um endereço**, ou em casos onde você precisa voltar para **`main`** novamente para **explorar a vulnerabilidade uma segunda vez**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Note que quando uma função do **`.fini_array`** é executada, ela passa para a próxima, então não será executada várias vezes (prevenindo loops eternos), mas também só dará 1 **execução da função** colocada aqui.

Note que as entradas em **`.fini_array`** são chamadas em **ordem reversa**, então você provavelmente quer começar a escrever a partir da última.

#### Loop eterno

Para abusar de **`.fini_array`** e obter um loop eterno, você pode [**ver o que foi feito aqui**](https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html)**:** Se você tiver pelo menos 2 entradas em **`.fini_array`**, você pode:

- Usar sua primeira escrita para **chamar a função vulnerável de escrita arbitrária** novamente
- Em seguida, calcular o endereço de retorno na pilha armazenado por **`__libc_csu_fini`** (a função que está chamando todas as funções de **`.fini_array`**) e colocar lá o **endereço de `__libc_csu_fini`**
- Isso fará com que **`__libc_csu_fini`** chame a si mesmo novamente, executando as funções de **`.fini_array`** novamente, o que chamará a função vulnerável WWW 2 vezes: uma para **escrita arbitrária** e outra para sobrescrever novamente o **endereço de retorno de `__libc_csu_fini`** na pilha para chamá-la novamente.

> [!CAUTION]
> Note que com [**Full RELRO**](../common-binary-protections-and-bypasses/relro.md)**,** a seção **`.fini_array`** é tornada **somente leitura**.
> Em versões mais novas, mesmo com [**Partial RELRO**], a seção **`.fini_array`** também é tornada **somente leitura**.

{{#include ../../banners/hacktricks-training.md}}
