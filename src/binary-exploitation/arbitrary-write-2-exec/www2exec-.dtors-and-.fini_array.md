# WWW2Exec - .dtors & .fini_array

{{#include ../../banners/hacktricks-training.md}}

## .dtors

> [!CAUTION]
> आजकल एक बाइनरी में .dtors सेक्शन मिलना बहुत **अजीब है!**

डिस्ट्रक्टर्स वे फ़ंक्शन हैं जो **कार्यक्रम समाप्त होने से पहले** (जब `main` फ़ंक्शन लौटता है) **निष्पादित** होते हैं।\
इन फ़ंक्शनों के पते बाइनरी के **`.dtors`** सेक्शन के अंदर संग्रहीत होते हैं और इसलिए, यदि आप **`__DTOR_END__`** में **शेलकोड** के लिए **पता लिखने** में सफल होते हैं, तो वह **कार्यक्रम समाप्त होने से पहले** **निष्पादित** होगा।

इस सेक्शन का पता प्राप्त करें:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
आमतौर पर आप **DTOR** मार्कर **मानों** `ffffffff` और `00000000` के बीच पाएंगे। इसलिए यदि आप केवल उन मानों को देखते हैं, तो इसका मतलब है कि कोई **फंक्शन पंजीकृत नहीं है**। इसलिए **`00000000`** को **shellcode** के **पते** से **ओवरराइट** करें ताकि इसे निष्पादित किया जा सके।

> [!WARNING]
> बेशक, आपको पहले **shellcode को स्टोर करने के लिए एक स्थान** ढूंढना होगा ताकि बाद में इसे कॉल किया जा सके।

## **.fini_array**

आधारभूत रूप से यह एक संरचना है जिसमें **फंक्शन होते हैं जो प्रोग्राम समाप्त होने से पहले कॉल किए जाएंगे**, जैसे **`.dtors`**। यह दिलचस्प है यदि आप अपने **shellcode को केवल एक पते पर कूदकर** कॉल कर सकते हैं, या उन मामलों में जहां आपको **फिर से `main`** पर वापस जाना है ताकि **दूसरी बार भेद्यता का शोषण** किया जा सके।
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
ध्यान दें कि जब **`.fini_array`** से कोई फ़ंक्शन निष्पादित होता है, तो यह अगले फ़ंक्शन पर चला जाता है, इसलिए इसे कई बार निष्पादित नहीं किया जाएगा (अनंत लूप को रोकना), लेकिन यह केवल यहाँ रखे गए फ़ंक्शन का 1 **निष्पादन** देगा।

ध्यान दें कि `.fini_array` में प्रविष्टियाँ **विपरीत** क्रम में कॉल की जाती हैं, इसलिए आप शायद अंतिम प्रविष्टि से लिखना शुरू करना चाहेंगे।

#### अनंत लूप

**`.fini_array`** का दुरुपयोग करने के लिए अनंत लूप प्राप्त करने के लिए आप [**यहाँ क्या किया गया था**](https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html)**:** यदि आपके पास **`.fini_array`** में कम से कम 2 प्रविष्टियाँ हैं, तो आप:

- अपने पहले लिखने का उपयोग करें **कमजोर अनियंत्रित लिखने वाले फ़ंक्शन** को फिर से कॉल करने के लिए
- फिर, **`__libc_csu_fini`** द्वारा स्टैक में संग्रहीत लौटने के पते की गणना करें (वह फ़ंक्शन जो सभी `.fini_array` फ़ंक्शंस को कॉल कर रहा है) और वहाँ **`__libc_csu_fini`** का **पता** डालें
- इससे **`__libc_csu_fini`** फिर से खुद को कॉल करेगा, **`.fini_array`** फ़ंक्शंस को फिर से निष्पादित करेगा, जो कमजोर WWW फ़ंक्शन को 2 बार कॉल करेगा: एक बार **अनियंत्रित लिखने** के लिए और एक बार फिर से स्टैक पर **`__libc_csu_fini`** के लौटने के पते को ओवरराइट करने के लिए ताकि यह फिर से खुद को कॉल कर सके।

> [!CAUTION]
> ध्यान दें कि [**पूर्ण RELRO**](../common-binary-protections-and-bypasses/relro.md)**,** अनुभाग **`.fini_array`** को **पढ़ने के लिए केवल** बनाया गया है।
> नए संस्करणों में, [**आंशिक RELRO**] के साथ भी अनुभाग **`.fini_array`** को **पढ़ने के लिए केवल** बनाया गया है।

{{#include ../../banners/hacktricks-training.md}}
