# WWW2Exec - .dtors & .fini_array

{{#include ../../banners/hacktricks-training.md}}

## .dtors

> [!CAUTION]
> 现在找到一个带有 .dtors 部分的二进制文件是非常**奇怪的**！

析构函数是在程序结束之前（在 `main` 函数返回后）**执行**的函数。\
这些函数的地址存储在二进制文件的 **`.dtors`** 部分，因此，如果你设法将 **地址** 写入 **`__DTOR_END__`** 的 **shellcode**，那么它将在程序结束之前被 **执行**。

获取此部分的地址：
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep “__DTOR”
```
通常，您会在值 `ffffffff` 和 `00000000` 之间找到 **DTOR** 标记。因此，如果您只看到这些值，这意味着 **没有注册任何函数**。所以 **用** **shellcode** 的 **地址** **覆盖** **`00000000`** 以执行它。

> [!WARNING]
> 当然，您首先需要找到一个 **存储 shellcode 的地方** 以便稍后调用它。

## **.fini_array**

本质上，这是一个在程序结束之前会被调用的 **函数** 结构，类似于 **`.dtors`**。如果您可以通过 **跳转到一个地址** 来调用您的 **shellcode**，或者在需要 **再次返回 `main`** 以 **第二次利用漏洞** 的情况下，这一点很有趣。
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
注意，当执行 **`.fini_array`** 中的一个函数时，它会移动到下一个函数，因此不会被多次执行（防止永恒循环），但它只会给你在这里放置的 1 次 **函数执行**。

注意，`.fini_array` 中的条目是按 **反向** 顺序调用的，因此你可能想从最后一个开始写。

#### 永恒循环

为了利用 **`.fini_array`** 造成一个永恒循环，你可以 [**查看这里做了什么**](https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html)**:** 如果你在 **`.fini_array`** 中至少有 2 个条目，你可以：

- 使用你的第一次写入来 **再次调用易受攻击的任意写入函数**
- 然后，计算由 **`__libc_csu_fini`** 存储在栈中的返回地址（调用所有 `.fini_array` 函数的函数），并将 **`__libc_csu_fini`** 的 **地址** 放在那里
- 这将使 **`__libc_csu_fini`** 再次调用自己，执行 **`.fini_array`** 函数，这将使易受攻击的 WWW 函数被调用 2 次：一次用于 **任意写入**，另一次用于再次覆盖栈上 **`__libc_csu_fini`** 的返回地址以再次调用自己。

> [!CAUTION]
> 注意，在 [**完全 RELRO**](../common-binary-protections-and-bypasses/relro.md)**,** 部分 **`.fini_array`** 被设置为 **只读**。
> 在较新的版本中，即使是 [**部分 RELRO**]，部分 **`.fini_array`** 也被设置为 **只读**。

{{#include ../../banners/hacktricks-training.md}}
