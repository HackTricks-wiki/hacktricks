# Vectored Overloading PE Injection

{{#include ../banners/hacktricks-training.md}}

> [!TIP]
> Suchen Sie nach Windows 11 LFH heap shaping und VMware Workstation PVSCSI (vmware-vmx) Escape-Techniken?
>
> {{#ref}}
> vmware-workstation-pvscsi-lfh-escape.md
> {{#endref}}

## Technikübersicht

Vectored Overloading ist ein Windows PE injection Primitive, das das klassische [Module Overloading](https://github.com/hasherezade/module_overloading) mit Vectored Exception Handlers (VEHs) und hardware breakpoints verbindet. Anstatt `LoadLibrary` zu patchen oder einen eigenen Loader zu schreiben, geht der Angreifer wie folgt vor:

1. Erstellt einen `SEC_IMAGE` section-Objekt, das auf eine legitime DLL verweist (z. B. `wmp.dll`).
2. Überschreibt die gemappte View mit einem vollständig relocatierten bösartigen PE, behält aber das section-Objekt, das auf das harmlose Image auf der Festplatte zeigt.
3. Registriert einen VEH und programmiert die debug-Register, sodass jeder Aufruf von `NtOpenSection`, `NtMapViewOfSection` und optional `NtClose` einen user-mode Breakpoint auslöst.
4. Ruft `LoadLibrary("amsi.dll")` (oder eine andere harmlose Ziel-DLL) auf. Wenn der Windows-Loader diese Syscalls aufruft, überspringt der VEH die Kernel-Transition und gibt die Handles und Basisadressen des vorbereiteten bösartigen Images zurück.

Weil der Loader weiterhin glaubt, die angeforderte DLL gemappt zu haben, sieht Werkzeuging, das nur auf die section backing files schaut, `wmp.dll`, obwohl der Speicher nun die Payload des Angreifers enthält. Gleichzeitig werden Imports/TLS-Callbacks weiterhin vom echten Loader aufgelöst, wodurch der Adversary deutlich weniger eigene PE-Parsing-Logik pflegen muss.

## Stage 1 – Build the disguised section

1. **Create and map a section for the decoy DLL**
```c
NtCreateSection(&DecoySection, SECTION_ALL_ACCESS, NULL,
0, PAGE_READWRITE, SEC_IMAGE, L"\??\C:\\Windows\\System32\\wmp.dll");
NtMapViewOfSection(DecoySection, GetCurrentProcess(), &DecoyView, 0, 0,
NULL, &DecoySize, ViewShare, 0, PAGE_READWRITE);
```
2. **Copy the malicious PE into that view** section by section, honouring `SizeOfRawData`/`VirtualSize` and updating protections afterwards (`PAGE_EXECUTE_READ`, `PAGE_READWRITE`, etc.).
3. **Apply relocations and resolve imports** exactly as a reflective loader would. Because the view is already mapped as `SEC_IMAGE`, section alignments and guard pages match what the Windows loader expects later.
4. **Normalize the PE header**:
- If the payload is an EXE, set `IMAGE_FILE_HEADER.Characteristics |= IMAGE_FILE_DLL` and zero the entry point to keep `LdrpCallTlsInitializers` from jumping into EXE-specific stubs.
- DLL payloads can keep their headers unchanged.

An diesem Punkt besitzt der Prozess eine RWX-fähige View, deren backing object weiterhin `wmp.dll` ist, während die Bytes im Speicher vom Angreifer kontrolliert werden.

## Stage 2 – Hijack the loader with VEHs

1. **Register a VEH and arm hardware breakpoints**: programmiere `Dr0` (oder ein anderes debug-Register) mit der Adresse von `ntdll!NtOpenSection` und setze `DR7`, sodass jede Ausführung `STATUS_SINGLE_STEP` auslöst. Später dasselbe für `NtMapViewOfSection` und optional `NtClose`.
2. **Trigger DLL loading** mit `LoadLibrary("amsi.dll")`. `LdrLoadDll` wird schließlich `NtOpenSection` aufrufen, um das echte Section-Handle zu erhalten.
3. **VEH hook für `NtOpenSection`**:
- Finde den Stack-Slot für das `[out] PHANDLE SectionHandle` Argument.
- Schreibe das zuvor erstellte `DecoySection`-Handle in diesen Slot.
- Setze `RIP`/`EIP` so, dass zur `ret`-Anweisung gesprungen wird, damit der Kernel nie aufgerufen wird.
- Rüste den hardware breakpoint erneut aus, um als Nächstes `NtMapViewOfSection` zu überwachen.
4. **VEH hook für `NtMapViewOfSection`**:
- Überschreibe das `[out] PVOID *BaseAddress` (und die Size/Protection-Outputs) mit der Adresse der bereits gemappten bösartigen View.
- Überspringe den Syscall-Body wie zuvor.
5. **(Optional) VEH hook für `NtClose`** verifiziert, dass das gefälschte Section-Handle bereinigt wird, vermeidet Ressourcenlecks und liefert eine abschließende Validierung.

Weil die Syscalls nie tatsächlich ausgeführt werden, beobachten Kernel-Callbacks (ETWti, minifilter, etc.) die verdächtigen `NtOpenSection`/`NtMapViewOfSection`-Events nicht, was die Telemetrie drastisch reduziert. Aus Sicht des Loaders ist alles erfolgreich verlaufen und `amsi.dll` befindet sich im Speicher, woraufhin er mit der Import-/TLS-Auflösung gegen die Bytes des Angreifers fortfährt.

## Stage 3 – Execute the payload

- **EXE payload**: Der Injector springt einfach zum ursprünglichen Entry Point, sobald Relocations angewendet wurden. Wenn der Loader glaubt, `DllMain` aufzurufen, führt der benutzerdefinierte Code stattdessen die EXE-typische Entry aus.
- **DLL payload / Node.js addon**: Auflösung und Aufruf des vorgesehenen Exports (Kidkadi stellt eine benannte Funktion für JavaScript bereit). Da das Modul bereits in `LdrpModuleBaseAddressIndex` registriert ist, sehen nachfolgende Lookups es als die harmlose DLL.

In Kombination mit einem Node.js native addon (`.node` Datei) bleibt die auf Windows-Interna basierende Logik außerhalb der JavaScript-Schicht, was dem Threat Actor ermöglicht, denselben Loader mit vielen verschiedenen obfuscierten Node-Wrappern zu verwenden.

## References

- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [VectoredOverloading – PoC implementation](https://github.com/CheckPointSW/VectoredOverloading)

{{#include ../banners/hacktricks-training.md}}
