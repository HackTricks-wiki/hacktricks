# Vectored Overloading PE Injection

{{#include ../banners/hacktricks-training.md}}

> [!TIP]
> Szukasz Windows 11 LFH heap shaping i VMware Workstation PVSCSI (vmware-vmx) escape techniques?
>
> {{#ref}}
> vmware-workstation-pvscsi-lfh-escape.md
> {{#endref}}

## Przegląd techniki

Vectored Overloading to **Windows PE injection primitive**, która scala klasyczny [Module Overloading](https://github.com/hasherezade/module_overloading) z **Vectored Exception Handlers (VEHs)** i **hardware breakpoints**. Zamiast patchować `LoadLibrary` lub pisać własny loader, atakujący:

1. Tworzy sekcję `SEC_IMAGE` powiązaną z legalnym DLL (np. `wmp.dll`).
2. Nadpisuje zmapowany widok w pełni zrelokowanym złośliwym PE, ale obiekt sekcji nadal wskazuje na prawidłowy obraz na dysku.
3. Rejestruje VEH i programuje rejestry debugowania tak, aby każde wywołanie `NtOpenSection`, `NtMapViewOfSection`, oraz opcjonalnie `NtClose` wywoływało punkt przerwania w trybie użytkownika.
4. Wywołuje `LoadLibrary("amsi.dll")` (lub dowolny inny cel). Gdy loader Windows wywołuje te syscalle, VEH **pomija przejście do jądra** i zwraca uchwyty oraz adresy bazowe przygotowanego złośliwego obrazu.

Ponieważ loader nadal wierzy, że zmapował żądany DLL, narzędzia które patrzą jedynie na pliki powiązane z sekcją widzą `wmp.dll`, mimo że w pamięci znajdują się teraz bajty atakującego. Tymczasem importy/callbacki TLS są nadal rozwiązywane przez autentyczny loader, co znacząco zmniejsza ilość niestandardowej logiki parsowania PE, którą atakujący musi utrzymywać.

## Etap 1 – Zbuduj zamaskowaną sekcję

1. **Utwórz i zmapuj sekcję dla zastępczego DLL**
```c
NtCreateSection(&DecoySection, SECTION_ALL_ACCESS, NULL,
0, PAGE_READWRITE, SEC_IMAGE, L"\??\C:\\Windows\\System32\\wmp.dll");
NtMapViewOfSection(DecoySection, GetCurrentProcess(), &DecoyView, 0, 0,
NULL, &DecoySize, ViewShare, 0, PAGE_READWRITE);
```
2. **Skopiuj złośliwy PE do tego widoku** sekcja po sekcji, respektując `SizeOfRawData`/`VirtualSize` i aktualizując ochrony potem (`PAGE_EXECUTE_READ`, `PAGE_READWRITE`, itd.).
3. **Zastosuj relokacje i rozwiąż importy** dokładnie tak, jak zrobiłby to reflective loader. Ponieważ widok jest już zmapowany jako `SEC_IMAGE`, wyrównania sekcji i guard pages odpowiadają temu, czego później oczekuje Windows loader.
4. **Znormalizuj nagłówek PE**:
- Jeśli payload to EXE, ustaw `IMAGE_FILE_HEADER.Characteristics |= IMAGE_FILE_DLL` i wyzeruj entry point, aby `LdrpCallTlsInitializers` nie skakał do stubów specyficznych dla EXE.
- Payloady DLL mogą pozostawić nagłówki bez zmian.

W tym momencie proces posiada widok z możliwością RWX, którego obiekt zaplecza to nadal `wmp.dll`, lecz bajty w pamięci są kontrolowane przez atakującego.

## Etap 2 – Przejmij loader z użyciem VEHs

1. **Zarejestruj VEH i uzbrój hardware breakpoints**: zaprogramuj `Dr0` (lub inny rejestr debugowania) adresem `ntdll!NtOpenSection` i ustaw `DR7`, tak aby każde wykonanie powodowało `STATUS_SINGLE_STEP`. Powtórz później dla `NtMapViewOfSection` i opcjonalnie `NtClose`.
2. **Wywołaj ładowanie DLL** przez `LoadLibrary("amsi.dll")`. `LdrLoadDll` w końcu wywoła `NtOpenSection`, aby uzyskać prawdziwy uchwyt sekcji.
3. **VEH hook dla `NtOpenSection`**:
- Znajdź slot na stosie dla argumentu `[out] PHANDLE SectionHandle`.
- Zapisz wcześniej utworzony uchwyt `DecoySection` w tym slocie.
- Przesuń `RIP`/`EIP` do instrukcji `ret`, tak aby kernel nigdy nie został wywołany.
- Ponownie uzbrój hardware breakpoint, aby obserwować `NtMapViewOfSection`.
4. **VEH hook dla `NtMapViewOfSection`**:
- Nadpisz `[out] PVOID *BaseAddress` (oraz wyjścia dotyczące rozmiaru/ochrony) adresem już zmapowanego złośliwego widoku.
- Pomiń ciało syscalla tak jak wcześniej.
5. **(Opcjonalnie) VEH hook dla `NtClose`** weryfikuje, że fałszywy uchwyt sekcji jest oczyszczony, zapobiegając resource leaks i zapewniając końcową weryfikację poprawności.

Ponieważ syscalli nigdy nie wykonano, callbacki jądra (ETWti, minifilter, itd.) nie obserwują podejrzanych zdarzeń `NtOpenSection`/`NtMapViewOfSection`, co drastycznie obniża telemetry. Z punktu widzenia loadera wszystko zakończyło się powodzeniem i `amsi.dll` znajduje się w pamięci, więc loader kontynuuje rozwiązywanie importów/TLS przeciwko bajtom atakującego.

## Etap 3 – Wykonanie payloadu

- **EXE payload**: Injector po prostu skacze do oryginalnego entry point po ukończeniu relokacji. Gdy loader "myśli", że wywoła `DllMain`, niestandardowy kod zamiast tego wykonuje entry w stylu EXE.
- **DLL payload / Node.js addon**: Rozwiąż i wywołaj zamierzony export (Kidkadi udostępnia nazwaną funkcję do JavaScript). Ponieważ moduł jest już zarejestrowany w `LdrpModuleBaseAddressIndex`, kolejne wyszukiwania widzą go jako benign DLL.

W połączeniu z Node.js native addon (`.node` file), całe ciężkie operacje związane z Windows-internals pozostają poza warstwą JavaScript, co pozwala aktorowi zagrożenia dostarczać ten sam loader z wieloma różnymi obfuskowanymi wrapperami Node.

## References

- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [VectoredOverloading – PoC implementation](https://github.com/CheckPointSW/VectoredOverloading)

{{#include ../banners/hacktricks-training.md}}
