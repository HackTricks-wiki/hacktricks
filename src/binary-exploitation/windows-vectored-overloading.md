# Vectored Overloading PE Injection

{{#include ../banners/hacktricks-training.md}}

> [!TIP]
> Cerchi tecniche per Windows 11 LFH heap shaping e VMware Workstation PVSCSI (vmware-vmx) escape?
>
> {{#ref}}
> vmware-workstation-pvscsi-lfh-escape.md
> {{#endref}}

## Technique overview

Vectored Overloading è una **Windows PE injection primitive** che fonde il classico [Module Overloading](https://github.com/hasherezade/module_overloading) con **Vectored Exception Handlers (VEHs)** e breakpoint hardware. Invece di patchare `LoadLibrary` o scrivere un proprio loader, l'avversario:

1. Crea una sezione `SEC_IMAGE` backed da una DLL legittima (es., `wmp.dll`).
2. Sovrascrive la view mappata con un PE malevolo completamente relocato ma mantiene l'oggetto section puntato all'immagine benign su disco.
3. Registra un VEH e programma i debug registers in modo che ogni chiamata a `NtOpenSection`, `NtMapViewOfSection`, e opzionalmente `NtClose` sollevi un breakpoint in user-mode.
4. Chiama `LoadLibrary("amsi.dll")` (o qualsiasi altro target benign). Quando il loader di Windows invoca quelle syscall, il VEH **salta la transizione al kernel** e restituisce gli handle e gli indirizzi base dell'immagine malevola preparata.

Poiché il loader continua a credere di aver mappato la DLL richiesta, gli strumenti che guardano solo al file di backing della section vedono `wmp.dll` anche se la memoria ora contiene il payload dell'attaccante. Nel frattempo, imports/callback TLS sono ancora risolti dal loader genuino, riducendo significativamente la quantità di logica di parsing PE custom che l'avversario deve mantenere.

## Stage 1 – Build the disguised section

1. **Create and map a section for the decoy DLL**
```c
NtCreateSection(&DecoySection, SECTION_ALL_ACCESS, NULL,
0, PAGE_READWRITE, SEC_IMAGE, L"\??\C:\\Windows\\System32\\wmp.dll");
NtMapViewOfSection(DecoySection, GetCurrentProcess(), &DecoyView, 0, 0,
NULL, &DecoySize, ViewShare, 0, PAGE_READWRITE);
```
2. **Copia il PE malevolo in quella view** sezione per sezione, rispettando `SizeOfRawData`/`VirtualSize` e aggiornando le protezioni successivamente (`PAGE_EXECUTE_READ`, `PAGE_READWRITE`, ecc.).
3. **Applica le relocations e risolvi gli imports** esattamente come farebbe un reflective loader. Poiché la view è già mappata come `SEC_IMAGE`, gli allineamenti di section e le guard pages corrispondono a ciò che il loader di Windows si aspetterà in seguito.
4. **Normalizza l'header PE**:
- Se il payload è un EXE, imposta `IMAGE_FILE_HEADER.Characteristics |= IMAGE_FILE_DLL` e azzera l'entry point per impedire che `LdrpCallTlsInitializers` salti in stub specifici per EXE.
- I payload DLL possono mantenere gli header invariati.

A questo punto il processo possiede una view con permessi RWX il cui oggetto di backing è ancora `wmp.dll`, ma i byte in memoria sono controllati dall'attaccante.

## Stage 2 – Hijack the loader with VEHs

1. **Registra un VEH e arma i breakpoint hardware**: programma `Dr0` (o un altro debug register) con l'indirizzo di `ntdll!NtOpenSection` e imposta `DR7` in modo che ogni esecuzione sollevi `STATUS_SINGLE_STEP`. Ripeti più tardi per `NtMapViewOfSection` e opzionalmente `NtClose`.
2. **Triggera il caricamento della DLL** con `LoadLibrary("amsi.dll")`. `LdrLoadDll` alla fine chiamerà `NtOpenSection` per ottenere il section handle reale.
3. **VEH hook per `NtOpenSection`**:
- Individua lo slot nello stack per l'argomento `[out] PHANDLE SectionHandle`.
- Scrivi in quello slot l'handle `DecoySection` precedentemente creato.
- Avanza `RIP`/`EIP` fino all'istruzione `ret` così il kernel non viene mai chiamato.
- Ri-arma il breakpoint hardware per osservare successivamente `NtMapViewOfSection`.
4. **VEH hook per `NtMapViewOfSection`**:
- Sovrascrivi `[out] PVOID *BaseAddress` (e gli output di size/protection) con l'indirizzo della view malevola già mappata.
- Salta la body della syscall come fatto in precedenza.
5. **(Opzionale) VEH hook per `NtClose`** verifica che il fake section handle sia pulito, prevenendo resource leaks e fornendo un controllo di sanità finale.

Poiché le syscall non vengono mai eseguite, callback a livello kernel (ETWti, minifilter, ecc.) non osservano gli eventi sospetti `NtOpenSection`/`NtMapViewOfSection`, riducendo drasticamente la telemetry. Dal punto di vista del loader tutto è riuscito e `amsi.dll` è in memoria, quindi procede con la risoluzione di import/TLS contro i byte dell'attaccante.

## Stage 3 – Execute the payload

- **EXE payload**: L'injector salta semplicemente al entry point originale una volta completate le relocations. Quando il loader pensa di chiamare `DllMain`, il codice custom esegue invece l'entry in stile EXE.
- **DLL payload / Node.js addon**: Risolvi e chiama l'export voluto (Kidkadi espone una funzione nominata per JavaScript). Poiché il modulo è già registrato in `LdrpModuleBaseAddressIndex`, le ricerche successive lo vedono come la DLL benign.

Quando combinato con un Node.js native addon (`.node` file), tutta la complessa logica di internals Windows resta fuori dallo strato JavaScript, permettendo all'attore di minaccia di distribuire lo stesso loader con molti wrapper Node offuscati diversi.

## Riferimenti

- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [VectoredOverloading – PoC implementation](https://github.com/CheckPointSW/VectoredOverloading)

{{#include ../banners/hacktricks-training.md}}
