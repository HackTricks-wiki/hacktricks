# Vectored Overloading PE Injection

{{#include ../banners/hacktricks-training.md}}

> [!TIP]
> Tražite tehnike za Windows 11 LFH heap shaping i VMware Workstation PVSCSI (vmware-vmx) escape?
>
> {{#ref}}
> vmware-workstation-pvscsi-lfh-escape.md
> {{#endref}}

## Pregled tehnike

Vectored Overloading je **Windows PE injection primitive** koji spaja klasični [Module Overloading](https://github.com/hasherezade/module_overloading) sa **Vectored Exception Handlers (VEHs)** i **hardware breakpoints**. Umesto da patchuje `LoadLibrary` ili piše sopstveni loader, napadač:

1. Kreira `SEC_IMAGE` sekciju zasnovanu na legitimnom DLL-u (npr. `wmp.dll`).
2. Prepisuje mapped view potpuno relociranim malicioznim PE-om, ali ostavlja section object da pokazuje na benigni image na disku.
3. Registruje VEH i programira debug registre tako da svaki poziv `NtOpenSection`, `NtMapViewOfSection`, i eventualno `NtClose` podiže user-mode breakpoint.
4. Poziva `LoadLibrary("amsi.dll")` (ili bilo koji drugi benigni target). Kada Windows loader pozove te syscalle, VEH **preskače kernel transition** i vraća handle-ove i base adrese pripremljenog malicioznog image-a.

Pošto loader i dalje veruje da je mapirao traženi DLL, alati koji gledaju samo section backing fajlove vide `wmp.dll` iako memorija sada sadrži napadačev payload. U međuvremenu, imports/TLS callbacks i dalje rešava genuini loader, što značajno smanjuje količinu custom PE-parsing logike koju napadač mora da održava.

## Stage 1 – Build the disguised section

1. **Create and map a section for the decoy DLL**
```c
NtCreateSection(&DecoySection, SECTION_ALL_ACCESS, NULL,
0, PAGE_READWRITE, SEC_IMAGE, L"\??\C:\\Windows\\System32\\wmp.dll");
NtMapViewOfSection(DecoySection, GetCurrentProcess(), &DecoyView, 0, 0,
NULL, &DecoySize, ViewShare, 0, PAGE_READWRITE);
```
2. **Copy the malicious PE into that view** section by section, honouring `SizeOfRawData`/`VirtualSize` and updating protections afterwards (`PAGE_EXECUTE_READ`, `PAGE_READWRITE`, etc.).
3. **Apply relocations and resolve imports** exactly as a reflective loader would. Because the view is already mapped as `SEC_IMAGE`, section alignments and guard pages match what the Windows loader expects later.
4. **Normalize the PE header**:
- If the payload is an EXE, set `IMAGE_FILE_HEADER.Characteristics |= IMAGE_FILE_DLL` and zero the entry point to keep `LdrpCallTlsInitializers` from jumping into EXE-specific stubs.
- DLL payloads can keep their headers unchanged.

U ovom trenutku proces poseduje RWX-capable view čiji backing object je i dalje `wmp.dll`, dok su bajtovi u memoriji pod kontrolom napadača.

## Stage 2 – Hijack the loader with VEHs

1. **Register a VEH and arm hardware breakpoints**: programirajte `Dr0` (ili drugi debug register) sa adresom `ntdll!NtOpenSection` i podesite `DR7` tako da svaka eksekucija podiže `STATUS_SINGLE_STEP`. Ponovite kasnije za `NtMapViewOfSection` i eventualno `NtClose`.
2. **Trigger DLL loading** sa `LoadLibrary("amsi.dll")`. `LdrLoadDll` će na kraju pozvati `NtOpenSection` da dobije realan section handle.
3. **VEH hook for `NtOpenSection`**:
- Locirajte stack slot za `[out] PHANDLE SectionHandle` argument.
- Upisujte prethodno kreirani `DecoySection` handle u taj slot.
- Pomaknite `RIP`/`EIP` do `ret` instrukcije tako da kernel nikada nije pozvan.
- Ponovo naoružajte hardware breakpoint da posmatra `NtMapViewOfSection` sledeće.
4. **VEH hook for `NtMapViewOfSection`**:
- Prepišite `[out] PVOID *BaseAddress` (i izlaze za size/protection) adresom već mapiranog malicioznog view-a.
- Preskočite syscall body isto kao i ranije.
5. **(Optional) VEH hook for `NtClose`** verifikuje da je lažni section handle očišćen, sprečavajući resource leaks i pružajući konačnu proveru ispravnosti.

Pošto se syscall-ovi nikada ne izvrše, kernel callbacks (ETWti, minifilter, itd.) ne beleže sumnjive `NtOpenSection`/`NtMapViewOfSection` događaje, što drastično smanjuje telemetriju. Iz ugla loader-a sve je uspešno i `amsi.dll` je u memoriji, pa nastavlja sa import/TLS resolution nad napadačevim bajtovima.

## Stage 3 – Execute the payload

- **EXE payload**: Injector jednostavno skače na originalni entry point nakon što su relocations završene. Kada loader misli da bi pozvao `DllMain`, custom kod umesto toga izvršava EXE-style entry.
- **DLL payload / Node.js addon**: Resolvujte i pozovite intendovani export (Kidkadi exposes a named function to JavaScript). Pošto je modul već registrovan u `LdrpModuleBaseAddressIndex`, naknadne pretrage ga vide kao benigni DLL.

Kada se kombinuje sa Node.js native addon-om (`.node` fajl), sav težak posao Windows-internalsa ostaje izvan JavaScript sloja, pomažući napadaču da distribuira isti loader sa mnogim različitim obfuscated Node wrapper-ima.

## References

- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [VectoredOverloading – PoC implementation](https://github.com/CheckPointSW/VectoredOverloading)

{{#include ../banners/hacktricks-training.md}}
