# Vectored Overloading PE Injection

{{#include ../banners/hacktricks-training.md}}

> [!TIP]
> Windows 11 LFH heap shaping and VMware Workstation PVSCSI (vmware-vmx) escape techniques를 찾고 계신가요?
>
> {{#ref}}
> vmware-workstation-pvscsi-lfh-escape.md
> {{#endref}}

## 기술 개요

Vectored Overloading는 고전적인 [Module Overloading](https://github.com/hasherezade/module_overloading)과 **Vectored Exception Handlers (VEHs)** 및 **hardware breakpoints**를 결합한 **Windows PE injection primitive**입니다. `LoadLibrary`를 패치하거나 자체 로더를 구현하는 대신 공격자는 다음을 수행합니다:

1. 정상적인 DLL(예: `wmp.dll`)을 backing file로 사용하는 `SEC_IMAGE` 섹션을 생성합니다.
2. 매핑된 뷰를 완전히 재배치된 악성 PE로 섹션 단위로 덮어쓰되, 섹션 객체는 디스크상의 정상 이미지를 가리키도록 유지합니다.
3. VEH를 등록하고 디버그 레지스터를 설정해 `NtOpenSection`, `NtMapViewOfSection` 및 선택적으로 `NtClose` 호출마다 사용자 모드 브레이크포인트가 발생하도록 만듭니다.
4. `LoadLibrary("amsi.dll")`(또는 다른 정상 타깃)을 호출합니다. Windows 로더가 해당 시스템콜들을 호출하면, VEH가 **커널 전환을 건너뛰고** 준비된 악성 이미지의 핸들과 베이스 주소를 반환합니다.

로더는 요청된 DLL을 매핑했다고 믿기 때문에, 섹션의 backing file만 보는 도구들은 메모리가 공격자의 페이로드로 바뀌었음에도 불구하고 `wmp.dll`을 표시합니다. 한편, imports/TLS 콜백은 여전히 정식 로더가 해결하므로 공격자가 유지해야 하는 커스텀 PE 파싱 로직의 양이 크게 줄어듭니다.

## Stage 1 – 위장된 섹션 구성

1. **Create and map a section for the decoy DLL**
```c
NtCreateSection(&DecoySection, SECTION_ALL_ACCESS, NULL,
0, PAGE_READWRITE, SEC_IMAGE, L"\??\C:\\Windows\\System32\\wmp.dll");
NtMapViewOfSection(DecoySection, GetCurrentProcess(), &DecoyView, 0, 0,
NULL, &DecoySize, ViewShare, 0, PAGE_READWRITE);
```
2. **해당 뷰에 악성 PE를 섹션 단위로 복사**: `SizeOfRawData`/`VirtualSize`를 준수하고, 이후 프로텍션을 적절히 설정합니다(`PAGE_EXECUTE_READ`, `PAGE_READWRITE` 등).
3. **재배치 적용 및 imports 해결**: reflective loader와 동일하게 재배치 작업을 수행하고 imports를 해결합니다. 뷰가 이미 `SEC_IMAGE`로 매핑되어 있기 때문에 섹션 정렬과 가드 페이지가 나중에 Windows 로더가 예상하는 것과 일치합니다.
4. **PE 헤더 정규화**:
- 페이로드가 EXE인 경우 `IMAGE_FILE_HEADER.Characteristics |= IMAGE_FILE_DLL`를 설정하고 엔트리 포인트를 0으로 만들어 `LdrpCallTlsInitializers`가 EXE 전용 스텁으로 점프하지 않도록 합니다.
- DLL 페이로드는 헤더를 변경하지 않아도 됩니다.

이 시점에서 프로세스는 백킹 오브젝트가 여전히 `wmp.dll`인 RWX 가능한 뷰를 소유하고 있으나, 메모리의 바이트는 공격자가 제어합니다.

## Stage 2 – VEH로 로더 하이재킹

1. **VEH 등록 및 하드웨어 브레이크포인트 장전**: `Dr0`(또는 다른 디버그 레지스터)에 `ntdll!NtOpenSection`의 주소를 설정하고 `DR7`을 구성해 실행 시마다 `STATUS_SINGLE_STEP`가 발생하도록 합니다. 이후 동일 방법으로 `NtMapViewOfSection`과 선택적으로 `NtClose`에 대해 반복합니다.
2. **DLL 로딩 트리거**: `LoadLibrary("amsi.dll")`을 호출합니다. `LdrLoadDll`은 결국 실제 섹션 핸들을 얻기 위해 `NtOpenSection`을 호출합니다.
3. **NtOpenSection에 대한 VEH 훅**:
- `[out] PHANDLE SectionHandle` 인수의 스택 슬롯을 찾습니다.
- 해당 슬롯에 이전에 생성한 `DecoySection` 핸들을 씁니다.
- `ret` 명령으로 RIP/EIP를 이동시켜 커널 호출이 발생하지 않게 합니다.
- 다음으로 `NtMapViewOfSection`을 감시하도록 하드웨어 브레이크포인트를 재설정합니다.
4. **NtMapViewOfSection에 대한 VEH 훅**:
- `[out] PVOID *BaseAddress`(및 크기/프로텍션 출력)를 이미 매핑된 악성 뷰의 주소로 덮어씁니다.
- 앞서와 동일하게 시스템콜 본문을 건너뜁니다.
5. **(선택사항) NtClose에 대한 VEH 훅**은 가짜 섹션 핸들이 정리되는지 확인해 리소스 누수를 방지하고 최종 무결성 검사를 제공합니다.

시스템콜이 실제로 실행되지 않기 때문에 커널 콜백(ETWti, minifilter 등)은 의심스러운 `NtOpenSection`/`NtMapViewOfSection` 이벤트를 관측하지 못해 텔레메트리가 크게 낮아집니다. 로더 관점에서는 모든 것이 성공했으며 `amsi.dll`이 메모리에 있는 것으로 보이므로 이후 import/TLS 해결을 공격자의 바이트에 대해 진행합니다.

## Stage 3 – 페이로드 실행

- **EXE 페이로드**: 재배치 완료 후 인젝터는 원래 엔트리 포인트로 점프합니다. 로더가 `DllMain`을 호출하려고 생각할 때, 커스텀 코드는 EXE 스타일 엔트리를 대신 실행합니다.
- **DLL 페이로드 / Node.js addon**: 의도한 export를 해결하고 호출합니다(Kidkadi는 JavaScript에 노출되는 명명된 함수를 제공합니다). 모듈이 이미 `LdrpModuleBaseAddressIndex`에 등록되어 있기 때문에 이후 조회에서는 해당 모듈을 정상 DLL로 인식합니다.

Node.js 네이티브 애드온(`.node` 파일)과 결합하면 Windows 내부 구현의 복잡한 부분이 JavaScript 레이어 밖에 머물러 동일한 로더를 다양한 난독화된 Node 래퍼와 함께 배포하기 쉬워집니다.

## 참고자료

- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [VectoredOverloading – PoC implementation](https://github.com/CheckPointSW/VectoredOverloading)

{{#include ../banners/hacktricks-training.md}}
