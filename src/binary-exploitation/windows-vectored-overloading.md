# Vectored Overloading PE Injection

{{#include ../banners/hacktricks-training.md}}

## Teknik genel bakışı

Vectored Overloading, klasik [Module Overloading](https://github.com/hasherezade/module_overloading) ile **Vectored Exception Handlers (VEHs)** ve **hardware breakpoints**i birleştiren bir Windows PE injection primitive'ıdır. `LoadLibrary`'yi patchlemek veya kendi loader'ını yazmak yerine, saldırgan:

1. Meşru bir DLL (ör. `wmp.dll`) tarafından desteklenen bir `SEC_IMAGE` section oluşturur.
2. Maplenmiş view'u tamamen relocate edilmiş kötü amaçlı PE ile üzerine yazar, fakat section objesini diskteki iyi niyetli görüntüye işaret etmeye devam ettirir.
3. Bir VEH kaydeder ve debug register'ları programlayarak her `NtOpenSection`, `NtMapViewOfSection` ve isteğe bağlı olarak `NtClose` çağrısında bir user-mode breakpoint tetiklenmesini sağlar.
4. `LoadLibrary("amsi.dll")` (veya başka herhangi bir hedef) çağrısı yapılır. Windows loader ilgili syscall'ları çağırdığında, VEH **kernel transition'ını atlar** ve hazırlanan kötü amaçlı imajın handle'larını ve base adreslerini döndürür.

Loader hâlâ istenen DLL'i maplediğini düşündüğü için, sadece section backing dosyasına bakan araçlar `wmp.dll` görürken bellek artık saldırganın payload'unu barındırır. Bu arada imports/TLS callback'leri gerçek loader tarafından hâlâ çözülür; böylece saldırganın sürdürmesi gereken özel PE-parsing mantığı önemli ölçüde azalır.

## Aşama 1 – Kılık değiştirilmiş section oluşturma

1. **Decoy DLL için bir section oluşturun ve map edin**
```c
NtCreateSection(&DecoySection, SECTION_ALL_ACCESS, NULL,
0, PAGE_READWRITE, SEC_IMAGE, L"\??\C:\\Windows\\System32\\wmp.dll");
NtMapViewOfSection(DecoySection, GetCurrentProcess(), &DecoyView, 0, 0,
NULL, &DecoySize, ViewShare, 0, PAGE_READWRITE);
```
2. **Kötü amaçlı PE'yi o view'a kopyalayın** section by section, `SizeOfRawData`/`VirtualSize`'a uyarak ve sonrasında korumaları (`PAGE_EXECUTE_READ`, `PAGE_READWRITE`, vb.) güncelleyerek.
3. **Relokasyonları uygulayın ve import'ları çözün** tam olarak bir reflective loader'ın yapacağı gibi. View zaten `SEC_IMAGE` olarak maplendiği için section hizalamaları ve guard page'ler Windows loader'ın daha sonra beklediği ile eşleşir.
4. **PE header'ını normalize edin**:
- Eğer payload bir EXE ise, `IMAGE_FILE_HEADER.Characteristics |= IMAGE_FILE_DLL` yapın ve `EntryPoint`i sıfırlayın ki `LdrpCallTlsInitializers` EXE-özgü stub'lara atlamasın.
- DLL payload'ları header'larını olduğu gibi bırakabilir.

Bu noktada process, backing objesi hâlâ `wmp.dll` olan ancak bellekteki byte'ları saldırganın kontrolünde olan RWX-capable bir view'a sahiptir.

## Aşama 2 – Loader'ı VEH ile ele geçirme

1. **Bir VEH kaydedin ve hardware breakpoint'leri kurun**: `Dr0` (veya başka bir debug register) içine `ntdll!NtOpenSection` adresini yazın ve her yürütmede `STATUS_SINGLE_STEP` tetiklenecek şekilde `DR7`'yi ayarlayın. Daha sonra `NtMapViewOfSection` ve isteğe bağlı olarak `NtClose` için de tekrarlayın.
2. `LoadLibrary("amsi.dll")` ile **DLL yüklemeyi tetikleyin**. `LdrLoadDll` eninde sonunda gerçek section handle'ını almak için `NtOpenSection`'ı çağıracaktır.
3. **NtOpenSection için VEH hook'u**:
- `[out] PHANDLE SectionHandle` argümanı için stack slot'unu bulun.
- O slota önceden oluşturulmuş `DecoySection` handle'ını yazın.
- Kernel'in asla çağrılmaması için `RIP`/`EIP`'yi `ret` instruction'ına ilerletin.
- Donanım breakpoint'ini bir sonraki hedef olan `NtMapViewOfSection`'u izleyecek şekilde yeniden ayarlayın.
4. **NtMapViewOfSection için VEH hook'u**:
- `[out] PVOID *BaseAddress` (ve size/protection çıktıları) üzerine zaten maplenmiş kötü amaçlı view'ın adresini yazın.
- Syscall body'ini öncekinde olduğu gibi atlayın.
5. **(İsteğe bağlı) NtClose için VEH hook'u** fake section handle'ının temizlendiğini doğrular, resource leak'leri önler ve son bir sanity check sağlar.

Syscall'lar hiç çalıştırılmadığı için kernel callback'leri (ETWti, minifilter, vb.) şüpheli `NtOpenSection`/`NtMapViewOfSection` olaylarını gözlemlemez, böylece telemetry ciddi şekilde düşer. Loader açısından her şey başarılı olmuş gibi görünür ve `amsi.dll` bellektedir; bu yüzden loader, import/TLS çözümlemeyi saldırganın byte'ları üzerinde sürdürür.

## Aşama 3 – Payload'u çalıştırma

- **EXE payload**: Injector, relocasyonlar tamamlandığında basitçe orijinal entry point'e atlar. Loader `DllMain` çağıracağını sandığında, özel kod EXE tarzı entry'yi yürütür.
- **DLL payload / Node.js addon**: İstenilen export'ı çözümleyip çağırın (Kidkadi JavaScript'e isimlendirilmiş bir fonksiyon sunar). Modül zaten `LdrpModuleBaseAddressIndex` ile kayıtlı olduğundan, sonraki aramalar onu iyi niyetli DLL olarak görür.

Bir Node.js native addon (`.node` dosyası) ile birleştirildiğinde, Windows-internal'larının ağır işleri JavaScript katmanının dışında kalır; bu da tehdit aktörünün aynı loader'ı pek çok farklı obfusk edilmiş Node wrapper ile göndermesine yardımcı olur.

## Kaynaklar

- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [VectoredOverloading – PoC implementation](https://github.com/CheckPointSW/VectoredOverloading)

{{#include ../banners/hacktricks-training.md}}
