# Vectored Overloading PE Injection

{{#include ../banners/hacktricks-training.md}}

> [!TIP]
> Procurando técnicas de shaping de heap LFH no Windows 11 e escape do VMware Workstation PVSCSI (vmware-vmx)?
>
> {{#ref}}
> vmware-workstation-pvscsi-lfh-escape.md
> {{#endref}}

## Technique overview

Vectored Overloading é uma primitiva de injeção de PE do Windows que funde o clássico [Module Overloading](https://github.com/hasherezade/module_overloading) com **Vectored Exception Handlers (VEHs)** e **hardware breakpoints**. Em vez de patchar `LoadLibrary` ou escrever um loader próprio, o adversário:

1. Cria uma seção `SEC_IMAGE` respaldada por um DLL legítimo (por exemplo, `wmp.dll`).
2. Sobrescreve a view mapeada com um PE malicioso totalmente relocável, mas mantém o objeto de seção apontando para a imagem benign no disco.
3. Registra um VEH e programa os registradores de debug para que toda chamada a `NtOpenSection`, `NtMapViewOfSection` e opcionalmente `NtClose` gere um breakpoint em user-mode.
4. Chama `LoadLibrary("amsi.dll")` (ou qualquer outro alvo benigno). Quando o loader do Windows invoca esses syscalls, o VEH **pula a transição para o kernel** e retorna os handles e endereços base da imagem maliciosa preparada.

Porque o loader ainda acredita que mapeou o DLL solicitado, ferramentas que apenas verificam o arquivo de backing da seção veem `wmp.dll` mesmo que a memória contenha o payload do atacante. Enquanto isso, imports/callbacks TLS ainda são resolvidos pelo loader genuíno, reduzindo significativamente a quantidade de lógica de parsing de PE personalizada que o adversário precisa manter.

## Stage 1 – Build the disguised section

1. **Create and map a section for the decoy DLL**
```c
NtCreateSection(&DecoySection, SECTION_ALL_ACCESS, NULL,
0, PAGE_READWRITE, SEC_IMAGE, L"\??\C:\\Windows\\System32\\wmp.dll");
NtMapViewOfSection(DecoySection, GetCurrentProcess(), &DecoyView, 0, 0,
NULL, &DecoySize, ViewShare, 0, PAGE_READWRITE);
```
2. **Copy the malicious PE into that view** seção por seção, respeitando `SizeOfRawData`/`VirtualSize` e atualizando proteções depois (`PAGE_EXECUTE_READ`, `PAGE_READWRITE`, etc.).
3. **Apply relocations and resolve imports** exatamente como um reflective loader faria. Como a view já está mapeada como `SEC_IMAGE`, alinhamentos de seção e guard pages batem com o que o loader do Windows espera depois.
4. **Normalize the PE header**:
- Se o payload for um EXE, defina `IMAGE_FILE_HEADER.Characteristics |= IMAGE_FILE_DLL` e zere o entry point para evitar que `LdrpCallTlsInitializers` salte para stubs específicos de EXE.
- Payloads DLL podem manter seus headers inalterados.

Neste ponto o processo possui uma view com capacidades RWX cujo objeto de backing ainda é `wmp.dll`, porém os bytes em memória estão sob controle do atacante.

## Stage 2 – Hijack the loader with VEHs

1. **Register a VEH and arm hardware breakpoints**: programe `Dr0` (ou outro registrador de debug) com o endereço de `ntdll!NtOpenSection` e ajuste `DR7` para que cada execução gere `STATUS_SINGLE_STEP`. Repita depois para `NtMapViewOfSection` e opcionalmente `NtClose`.
2. **Trigger DLL loading** com `LoadLibrary("amsi.dll")`. `LdrLoadDll` acabará chamando `NtOpenSection` para obter o handle da section real.
3. **VEH hook for `NtOpenSection`**:
- Localize o slot na stack correspondente ao argumento `[out] PHANDLE SectionHandle`.
- Escreva o handle previamente criado `DecoySection` naquele slot.
- Avance `RIP`/`EIP` até a instrução `ret` para que o kernel nunca seja chamado.
- Rearme o hardware breakpoint para observar `NtMapViewOfSection` em seguida.
4. **VEH hook for `NtMapViewOfSection`**:
- Sobrescreva o `[out] PVOID *BaseAddress` (e as saídas de size/protection) com o endereço da view maliciosa já mapeada.
- Pule o corpo do syscall como antes.
5. **(Optional) VEH hook for `NtClose`** verifica que o handle de seção falso é limpo, evitando resource leaks e fornecendo uma checagem final de sanidade.

Como os syscalls nunca são executados, callbacks do kernel (ETWti, minifilter, etc.) não observam os eventos suspeitos de `NtOpenSection`/`NtMapViewOfSection`, reduzindo drasticamente a telemetria. Do ponto de vista do loader, tudo teve sucesso e `amsi.dll` está em memória, então ele prossegue com a resolução de imports/TLS contra os bytes do atacante.

## Stage 3 – Execute the payload

- **EXE payload**: O injector simplesmente salta para o entry point original assim que as relocations são aplicadas. Quando o loader acredita que chamaria `DllMain`, o código personalizado executa o entry no estilo EXE.
- **DLL payload / Node.js addon**: Resolva e chame o export pretendido (Kidkadi expõe uma função nomeada para JavaScript). Como o módulo já está registrado em `LdrpModuleBaseAddressIndex`, buscas subsequentes o veem como o DLL benigno.

Quando combinado com um Node.js native addon (`.node` file), todo o trabalho pesado de Windows-internals permanece fora da camada JavaScript, ajudando o ator de ameaça a distribuir o mesmo loader com diferentes wrappers Node ofuscados.

## References

- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [VectoredOverloading – PoC implementation](https://github.com/CheckPointSW/VectoredOverloading)

{{#include ../banners/hacktricks-training.md}}
