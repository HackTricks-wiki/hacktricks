# Vectored Overloading PE Injection

{{#include ../banners/hacktricks-training.md}}

> [!TIP]
> Unatafuta Windows 11 LFH heap shaping na VMware Workstation PVSCSI (vmware-vmx) escape techniques?
>
> {{#ref}}
> vmware-workstation-pvscsi-lfh-escape.md
> {{#endref}}

## Muhtasari wa mbinu

Vectored Overloading ni **Windows PE injection primitive** inayochanganya classic Module Overloading na Vectored Exception Handlers (VEHs) pamoja na hardware breakpoints. Badala ya kupachika `LoadLibrary` au kuandika loader yake mwenyewe, adhabu:

1. Inaunda sehemu ya `SEC_IMAGE` inayotokana na DLL halali (mfano, `wmp.dll`).
2. Inafunika mapped view na PE mwenye madhara uliosogezwa kikamilifu lakini inaleta section object ikielekea kwenye image isiyo ya madhara kwenye diski.
3. Inasajili VEH na kuprogram debug registers ili kila simu kwa `NtOpenSection`, `NtMapViewOfSection`, na hiari `NtClose` inapelekea user-mode breakpoint.
4. Inaita `LoadLibrary("amsi.dll")` (au DLL nyingine yoyote ya kukinga). Wakati Windows loader inapoita syscalls hizo, VEH **inaruka transition ya kernel** na inarudisha handles na anwani za base za image ya uandaaji ya madhara.

Kwa kuwa loader bado inaamini ilimekama DLL iliyohitajika, zana zinazotazama tu faili za backing za section zinaona `wmp.dll` ingawa memory sasa ina payload ya adhabu. Wakati huo huo, imports/TLS callbacks bado zinawekwa na loader halisi, ikipunguza kwa kiasi kikubwa logic ya kawaida ya PE-parsing ambayo adhabu inapaswa kudumisha.

## Hatua 1 – Jenga sehemu iliyofichwa

1. **Create and map a section for the decoy DLL**
```c
NtCreateSection(&DecoySection, SECTION_ALL_ACCESS, NULL,
0, PAGE_READWRITE, SEC_IMAGE, L"\??\C:\\Windows\\System32\\wmp.dll");
NtMapViewOfSection(DecoySection, GetCurrentProcess(), &DecoyView, 0, 0,
NULL, &DecoySize, ViewShare, 0, PAGE_READWRITE);
```
2. **Copy the malicious PE into that view** section by section, honouring `SizeOfRawData`/`VirtualSize` and updating protections afterwards (`PAGE_EXECUTE_READ`, `PAGE_READWRITE`, etc.).
3. **Apply relocations and resolve imports** exactly as a reflective loader would. Because the view is already mapped as `SEC_IMAGE`, section alignments and guard pages match what the Windows loader expects later.
4. **Normalize the PE header**:
- If the payload is an EXE, set `IMAGE_FILE_HEADER.Characteristics |= IMAGE_FILE_DLL` and zero the entry point to keep `LdrpCallTlsInitializers` from jumping into EXE-specific stubs.
- DLL payloads can keep their headers unchanged.

Wakati huu mchakato unamiliki view yenye uwezo wa RWX ambayo backing object bado ni `wmp.dll`, lakini byte katika memory zina udhibiti wa mshambuliaji.

## Hatua 2 – Chukua udhibiti wa loader kwa VEHs

1. **Register a VEH and arm hardware breakpoints**: program `Dr0` (au debug register nyingine) kwa anwani ya `ntdll!NtOpenSection` na weka `DR7` ili kila utekelezaji upelekee `STATUS_SINGLE_STEP`. Rudia baadaye kwa `NtMapViewOfSection` na hiari `NtClose`.
2. **Trigger DLL loading** kwa `LoadLibrary("amsi.dll")`. `LdrLoadDll` hatimaye itaweka simu kwa `NtOpenSection` kupata handle ya section halisi.
3. **VEH hook for `NtOpenSection`**:
- Tafuta slot kwenye stack kwa argument ya `[out] PHANDLE SectionHandle`.
- Andika handle ya `DecoySection` iliyotengenezwa awali kwenye slot hiyo.
- Sogeza `RIP`/`EIP` hadi kwa instruction ya `ret` ili kernel isiwaliwe.
- Re-arm hardware breakpoint kutazama `NtMapViewOfSection` baadae.
4. **VEH hook for `NtMapViewOfSection`**:
- Rekebisha `[out] PVOID *BaseAddress` (na outputs za size/protection) na anwani ya view ya madhara iliyokamuliwa tayari.
- Ruka body ya syscall kama hapo awali.
5. **(Optional) VEH hook for `NtClose`** inathibitisha kuwa fake section handle imesomwa, kuzuia resource leaks na kutoa ukaguzi wa mwisho wa sanity.

Kwa kuwa syscalls hazifanyiki kabisa, kernel callbacks (ETWti, minifilter, nk.) haziona matukio ya kuibuka ya `NtOpenSection`/`NtMapViewOfSection`, hivyo kupunguza telemetry kwa kiasi kikubwa. Kwa mtazamo wa loader kila kitu kilifanikiwa na `amsi.dll` iko katika memory, hivyo inaendelea na resolution ya import/TLS dhidi ya byte za mshambuliaji.

## Hatua 3 – Tekeleza payload

- **EXE payload**: Injector inaruka tu kwenye original entry point mara relocations zinapomalizika. Wakati loader ikifikiria itaita `DllMain`, code maalumu badala yake inatekeleza entry ya mtindo wa EXE.
- **DLL payload / Node.js addon**: Tatua na ita call export iliyokusudiwa (Kidkadi inafichua function iliyopewa jina kwa JavaScript). Kwa kuwa module tayari imesajiliwa na `LdrpModuleBaseAddressIndex`, utafutaji wa baadaye unaiona kama DLL ya kigeni.

Wakati inachanganywa na Node.js native addon (`.node` file), kazi nzito za Windows-internals zinabaki nje ya tabaka la JavaScript, zikimsaidia mshambuliaji kusafirisha loader moja na wrappers nyingi za Node zilizo obfuscated.

## Marejeleo

- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [VectoredOverloading – PoC implementation](https://github.com/CheckPointSW/VectoredOverloading)

{{#include ../banners/hacktricks-training.md}}
