# Vectored Overloading PE Injection

{{#include ../banners/hacktricks-training.md}}

> [!TIP]
> Vous recherchez des techniques de LFH heap shaping sous Windows 11 et d'évasion VMware Workstation PVSCSI (vmware-vmx) ?
>
> {{#ref}}
> vmware-workstation-pvscsi-lfh-escape.md
> {{#endref}}

## Vue d'ensemble de la technique

Vectored Overloading is a **Windows PE injection primitive** qui fusionne le classique [Module Overloading](https://github.com/hasherezade/module_overloading) avec les **Vectored Exception Handlers (VEHs)** et les **hardware breakpoints**. Au lieu de patcher `LoadLibrary` ou d'écrire son propre loader, l'adversaire :

1. Crée une section `SEC_IMAGE` associée à une DLL légitime (p.ex., `wmp.dll`).
2. Écrase la vue mappée avec un PE malveillant entièrement relocalisé tout en laissant l'objet de section pointer vers l'image bénigne sur disque.
3. Enregistre un VEH et programme les registres de débogage pour que chaque appel à `NtOpenSection`, `NtMapViewOfSection`, et optionnellement `NtClose` déclenche un point d'arrêt en espace utilisateur.
4. Appelle `LoadLibrary("amsi.dll")` (ou toute autre cible bénigne). Quand le loader Windows invoque ces syscalls, le VEH **évite la transition vers le noyau** et retourne les handles et adresses de base de l'image malveillante préparée.

Parce que le loader croit toujours avoir mappé la DLL demandée, les outils qui regardent uniquement les fichiers de backing de la section voient `wmp.dll` alors que la mémoire contient maintenant la charge utile de l'attaquant. Pendant ce temps, les imports/TLS callbacks sont toujours résolus par le loader authentique, réduisant significativement la quantité de logique de parsing PE custom que l'adversaire doit maintenir.

## Étape 1 – Construire la section déguisée

1. **Créer et mapper une section pour la DLL leurre**
```c
NtCreateSection(&DecoySection, SECTION_ALL_ACCESS, NULL,
0, PAGE_READWRITE, SEC_IMAGE, L"\??\C:\\Windows\\System32\\wmp.dll");
NtMapViewOfSection(DecoySection, GetCurrentProcess(), &DecoyView, 0, 0,
NULL, &DecoySize, ViewShare, 0, PAGE_READWRITE);
```
2. **Copier le PE malveillant dans cette vue** section par section, en respectant `SizeOfRawData`/`VirtualSize` et en mettant à jour les protections ensuite (`PAGE_EXECUTE_READ`, `PAGE_READWRITE`, etc.).
3. **Appliquer les relocations et résoudre les imports** exactement comme le ferait un reflective loader. Parce que la vue est déjà mappée en tant que `SEC_IMAGE`, les alignements de section et les guard pages correspondent à ce que le loader Windows attendra ensuite.
4. **Normaliser l'en-tête PE** :
- Si la charge utile est un EXE, définir `IMAGE_FILE_HEADER.Characteristics |= IMAGE_FILE_DLL` et mettre à zéro le entry point pour empêcher `LdrpCallTlsInitializers` de sauter dans des stubs spécifiques aux EXE.
- Les payloads DLL peuvent garder leurs en-têtes inchangés.

À ce stade, le processus possède une vue RWX dont l'objet de backing est toujours `wmp.dll`, alors que les octets en mémoire sont contrôlés par l'attaquant.

## Étape 2 – Détourner le loader avec des VEH

1. **Enregistrer un VEH et armer des hardware breakpoints** : programmer `Dr0` (ou un autre registre de débogage) avec l'adresse de `ntdll!NtOpenSection` et régler `DR7` pour que chaque exécution déclenche `STATUS_SINGLE_STEP`. Répéter ensuite pour `NtMapViewOfSection` et, optionnellement, `NtClose`.
2. **Déclencher le chargement de la DLL** avec `LoadLibrary("amsi.dll")`. `LdrLoadDll` appellera finalement `NtOpenSection` pour obtenir le handle réel de la section.
3. **VEH hook pour `NtOpenSection`** :
- Localiser la case de la pile correspondant à l'argument `[out] PHANDLE SectionHandle`.
- Écrire le handle `DecoySection` précédemment créé dans cette case.
- Avancer `RIP`/`EIP` jusqu'à l'instruction `ret` pour que le kernel ne soit jamais appelé.
- Réarmer le breakpoint matériel pour surveiller ensuite `NtMapViewOfSection`.
4. **VEH hook pour `NtMapViewOfSection`** :
- Écraser le `[out] PVOID *BaseAddress` (et les sorties taille/protection) avec l'adresse de la vue malveillante déjà mappée.
- Sauter le corps du syscall comme précédemment.
5. **(Optionnel) VEH hook pour `NtClose`** vérifie que le faux handle de section est nettoyé, empêchant les resource leaks et fournissant une vérification finale.

Parce que les syscalls ne sont jamais exécutés, les callbacks noyau (ETWti, minifilter, etc.) n'observent pas les événements suspects `NtOpenSection`/`NtMapViewOfSection`, réduisant drastiquement la télémétrie. Du point de vue du loader, tout a réussi et `amsi.dll` est en mémoire, il poursuit donc la résolution des imports/TLS contre les octets de l'attaquant.

## Étape 3 – Exécuter la charge utile

- **EXE payload** : L'injecteur saute simplement vers le entry point original une fois les relocations effectuées. Quand le loader pense appeler `DllMain`, le code personnalisé exécute à la place l'entrée de type EXE.
- **DLL payload / Node.js addon** : Résoudre et appeler l'export voulu (Kidkadi expose une fonction nommée à JavaScript). Parce que le module est déjà enregistré dans `LdrpModuleBaseAddressIndex`, les recherches ultérieures le voient comme la DLL bénigne.

Lorsqu'il est combiné avec un addon natif Node.js (`.node`), toute la logique lourde liée aux internals Windows reste en dehors de la couche JavaScript, aidant l'acteur menaçant à déployer le même loader avec plusieurs wrappers Node obfusqués.

## Références

- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [VectoredOverloading – PoC implementation](https://github.com/CheckPointSW/VectoredOverloading)

{{#include ../banners/hacktricks-training.md}}
