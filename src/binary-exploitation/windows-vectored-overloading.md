# Vectored Overloading PE Injection

{{#include ../banners/hacktricks-training.md}}

## 기술 개요

Vectored Overloading는 전통적인 Module Overloading과 Vectored Exception Handlers (VEHs), hardware breakpoints를 결합한 Windows PE 인젝션 기법입니다. LoadLibrary를 패치하거나 자체 로더를 작성하는 대신, 공격자는:

1. 정상 DLL(예: wmp.dll)에 기반한 SEC_IMAGE 섹션을 생성한다.
2. 매핑된 뷰를 완전히 재배치된 악성 PE로 덮어쓰되 섹션 오브젝트는 디스크의 정상 이미지(wmp.dll)를 가리키도록 유지한다.
3. VEH를 등록하고 디버그 레지스터를 프로그래밍하여 NtOpenSection, NtMapViewOfSection, 필요시 NtClose에 대한 모든 호출마다 사용자 모드 브레이크포인트가 발생하도록 한다.
4. LoadLibrary("amsi.dll")(또는 다른 정상 대상)를 호출한다. Windows 로더가 해당 syscall들을 호출할 때 VEH가 커널 전환을 건너뛰고 준비된 악성 이미지의 핸들과 베이스 주소를 반환한다.

로더는 여전히 요청한 DLL을 매핑했다고 믿기 때문에, 섹션의 backing 파일만 확인하는 툴은 메모리에 공격자의 페이로드가 들어 있음에도 wmp.dll을 보게 됩니다. 한편 imports/TLS callbacks는 진짜 로더에 의해 여전히 해결되므로 공격자가 유지해야 하는 커스텀 PE 파싱 로직의 양이 크게 줄어듭니다.

## Stage 1 – Build the disguised section

1. **Create and map a section for the decoy DLL**
```c
NtCreateSection(&DecoySection, SECTION_ALL_ACCESS, NULL,
0, PAGE_READWRITE, SEC_IMAGE, L"\??\C:\\Windows\\System32\\wmp.dll");
NtMapViewOfSection(DecoySection, GetCurrentProcess(), &DecoyView, 0, 0,
NULL, &DecoySize, ViewShare, 0, PAGE_READWRITE);
```
2. **해당 뷰에 섹션 단위로 악성 PE를 복사**하되 SizeOfRawData/VirtualSize를 준수하고 이후 보호 속성(PAGE_EXECUTE_READ, PAGE_READWRITE 등)을 업데이트한다.
3. **반사 로더(reflective loader)가 하는 것처럼 정확히 재배치(relocations)와 임포트 해결(imports)을 적용**한다. 뷰가 이미 SEC_IMAGE로 매핑되어 있으므로 섹션 정렬과 가드 페이지는 이후 Windows 로더가 예상하는 것과 일치한다.
4. **PE 헤더 정규화**:
- 페이로드가 EXE인 경우, IMAGE_FILE_HEADER.Characteristics |= IMAGE_FILE_DLL을 설정하고 엔트리 포인트를 0으로 만들어 LdrpCallTlsInitializers가 EXE 전용 스텁으로 점프하는 것을 막는다.
- DLL 페이로드는 헤더를 변경하지 않고 그대로 둘 수 있다.

이 시점에서 프로세스는 backing object가 여전히 wmp.dll인 RWX 권한의 뷰를 소유하지만, 메모리의 바이트는 공격자가 제어합니다.

## Stage 2 – Hijack the loader with VEHs

1. **VEH를 등록하고 hardware breakpoints를 설정**: ntldl!NtOpenSection의 주소로 Dr0(또는 다른 디버그 레지스터)를 프로그래밍하고 DR7을 설정하여 실행 시마다 STATUS_SINGLE_STEP가 발생하게 한다. 이후 NtMapViewOfSection과 필요시 NtClose에 대해서도 동일하게 반복한다.
2. **LoadLibrary("amsi.dll")로 DLL 로딩을 트리거**한다. LdrLoadDll은 결국 NtOpenSection을 호출하여 실제 섹션 핸들을 얻는다.
3. **NtOpenSection에 대한 VEH 훅**:
- [out] PHANDLE SectionHandle 인수의 스택 슬롯을 찾는다.
- 이전에 생성한 DecoySection 핸들을 해당 슬롯에 쓴다.
- RIP/EIP를 ret 명령으로 이동시켜 커널 호출이 발생하지 않게 한다.
- 다음으로 NtMapViewOfSection을 감시하도록 하드웨어 브레이크포인트를 재설정한다.
4. **NtMapViewOfSection에 대한 VEH 훅**:
- [out] PVOID *BaseAddress(및 크기/보호 출력값)를 이미 매핑된 악성 뷰의 주소로 덮어쓴다.
- 앞서와 같이 syscall 본문을 건너뛴다.
5. **(선택적) NtClose에 대한 VEH 훅**은 가짜 섹션 핸들이 정리되었는지 확인하여 resource leaks를 방지하고 최종적인 정상성 검사를 제공한다.

syscall이 전혀 실행되지 않기 때문에 커널 콜백(ETWti, minifilter 등)은 의심스러운 NtOpenSection/NtMapViewOfSection 이벤트를 관찰하지 못해 telemetry가 크게 낮아집니다. 로더 관점에서는 모든 것이 성공했고 amsi.dll이 메모리에 있으므로, 로더는 공격자의 바이트에 대해 import/TLS 해결을 계속 진행합니다.

## Stage 3 – Execute the payload

- **EXE 페이로드**: 재배치가 완료되면 인젝터는 원래 엔트리 포인트로 단순히 점프한다. 로더가 DllMain을 호출한다고 생각할 때, 커스텀 코드는 대신 EXE 스타일 엔트리를 실행한다.
- **DLL 페이로드 / Node.js addon**: 의도된 익스포트를 해결하고 호출한다(Kidkadi는 JavaScript에 이름이 지정된 함수를 노출함). 모듈이 이미 LdrpModuleBaseAddressIndex에 등록되어 있으므로 이후의 조회는 그것을 정상 DLL로 인식한다.

Node.js 네이티브 애드온(.node 파일)과 결합하면 Windows 내부 동작에 대한 무거운 작업은 JavaScript 레이어 밖에 남게 되어, 위협 행위자는 다양한 난독화된 Node 래퍼와 함께 동일한 로더를 배포할 수 있습니다.

## References

- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [VectoredOverloading – PoC implementation](https://github.com/CheckPointSW/VectoredOverloading)

{{#include ../banners/hacktricks-training.md}}
