# Vectored Overloading PE Injection

{{#include ../banners/hacktricks-training.md}}

> [!TIP]
> Windows 11 LFH heap shaping ve VMware Workstation PVSCSI (vmware-vmx) escape tekniklerini mi arıyorsunuz?
>
> {{#ref}}
> vmware-workstation-pvscsi-lfh-escape.md
> {{#endref}}

## Technique overview

Vectored Overloading, klasik [Module Overloading](https://github.com/hasherezade/module_overloading) ile **Vectored Exception Handlers (VEHs)** ve **hardware breakpoints**'ı birleştiren bir **Windows PE injection primitive**'dir. Kendi loader'ını yazmak veya `LoadLibrary`'yi patch'lemek yerine, saldırgan:

1. Meşru bir DLL (örn. `wmp.dll`) tarafından desteklenen bir `SEC_IMAGE` section oluşturur.
2. Eşlenen görünümü tamamen relocate edilmiş kötü amaçlı bir PE ile üzerine yazar, ancak section objesinin diskteki zararsız imaja işaret etmesini sağlar.
3. Bir VEH kaydeder ve debug register'ları programlayarak her `NtOpenSection`, `NtMapViewOfSection` ve isteğe bağlı olarak `NtClose` çağrısında kullanıcı modu breakpoint'i oluşmasını sağlar.
4. `LoadLibrary("amsi.dll")` (veya başka bir zararsız hedef) çağırır. Windows loader bu syscall'leri çağırdığında, VEH **kernel geçişini atlar** ve hazırlanmış kötü amaçlı imajın handle ve base adreslerini döndürür.

Loader hâlâ istenen DLL'i eşlediğini düşündüğü için, yalnızca section backing dosyasına bakan araçlar `wmp.dll` görürler, oysa bellek şimdi saldırganın payload'unu içerir. Bu arada imports/TLS callback'leri gerçek loader tarafından hâlâ çözümlenir; bu da saldırganın sürdürmesi gereken özel PE-parse mantığının miktarını önemli ölçüde azaltır.

## Stage 1 – Build the disguised section

1. **Create and map a section for the decoy DLL**
```c
NtCreateSection(&DecoySection, SECTION_ALL_ACCESS, NULL,
0, PAGE_READWRITE, SEC_IMAGE, L"\??\C:\\Windows\\System32\\wmp.dll");
NtMapViewOfSection(DecoySection, GetCurrentProcess(), &DecoyView, 0, 0,
NULL, &DecoySize, ViewShare, 0, PAGE_READWRITE);
```
2. **Copy the malicious PE into that view** section by section, honouring `SizeOfRawData`/`VirtualSize` and updating protections afterwards (`PAGE_EXECUTE_READ`, `PAGE_READWRITE`, etc.).
3. **Apply relocations and resolve imports** exactly as a reflective loader would. Because the view is already mapped as `SEC_IMAGE`, section alignments and guard pages match what the Windows loader expects later.
4. **Normalize the PE header**:
- If the payload is an EXE, set `IMAGE_FILE_HEADER.Characteristics |= IMAGE_FILE_DLL` and zero the entry point to keep `LdrpCallTlsInitializers` from jumping into EXE-specific stubs.
- DLL payloads can keep their headers unchanged.

Bu noktada process, backing object'i hâlâ `wmp.dll` olan ancak bellekteki byte'ları saldırganın kontrol ettiği RWX yetenekli bir view'a sahiptir.

## Stage 2 – Hijack the loader with VEHs

1. **Register a VEH and arm hardware breakpoints**: `Dr0` (veya başka bir debug register) adresine `ntdll!NtOpenSection` koyun ve her yürütmede `STATUS_SINGLE_STEP` tetiklenecek şekilde `DR7`'yi ayarlayın. Daha sonra `NtMapViewOfSection` ve isteğe bağlı olarak `NtClose` için aynı işlemi tekrarlayın.
2. **Trigger DLL loading** with `LoadLibrary("amsi.dll")`. `LdrLoadDll` sonunda gerçek section handle'ını almak için `NtOpenSection`'ı çağıracaktır.
3. **VEH hook for `NtOpenSection`**:
- `[out] PHANDLE SectionHandle` argümanının stack slot'unu bulun.
- Daha önce oluşturulmuş `DecoySection` handle'ını o slota yazın.
- Kernel asla çağrılmasın diye `ret` talimatına `RIP`/`EIP`'yi ilerletin.
- Donanım breakpoint'ini bir sonraki izlenecek hedef olarak `NtMapViewOfSection`'ı izlemek üzere yeniden etkinleştirin.
4. **VEH hook for `NtMapViewOfSection`**:
- `[out] PVOID *BaseAddress` (ve boyut/proteksiyon çıktılarını) zaten eşlenmiş kötü amaçlı view'ın adresiyle ezip değiştirin.
- Önceki gibi syscall body'sini atlayın.
5. **(Optional) VEH hook for `NtClose`** sahte section handle'ının temizlendiğini doğrular, kaynak sızıntılarını önler ve nihai bir akıl sağlığı kontrolü sağlar.

Syscall'ler asla yürütülmediği için kernel callback'leri (ETWti, minifilter, vb.) şüpheli `NtOpenSection`/`NtMapViewOfSection` olaylarını gözlemlemez; bu da telemetry'yi büyük ölçüde düşürür. Loader açısından her şey başarılı olmuş gibi görünür ve `amsi.dll` bellektedir; bu yüzden import/TLS çözümlemelerine saldırganın byte'ları üzerinden devam eder.

## Stage 3 – Execute the payload

- **EXE payload**: Injector, relocasyonlar tamamlandığında basitçe orijinal entry point'e atlar. Loader `DllMain` çağıracağını düşündüğünde, özel kod EXE tarzı entry'i çalıştırır.
- **DLL payload / Node.js addon**: Hedef export'ı çözümleyip çağırın (Kidkadi, JavaScript'e isimlendirilmiş bir fonksiyon sunar). Modül zaten `LdrpModuleBaseAddressIndex` ile kayıtlı olduğu için sonraki aramalar onu zararsız DLL olarak görür.

Bir Node.js native addon (`.node` dosyası) ile birleştirildiğinde, Windows-internal işlemlerin tümü JavaScript katmanının dışında kalır ve tehdit aktörünün aynı loader'ı birçok farklı obfuscated Node wrapper ile dağıtmasına yardımcı olur.

## References

- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [VectoredOverloading – PoC implementation](https://github.com/CheckPointSW/VectoredOverloading)

{{#include ../banners/hacktricks-training.md}}
