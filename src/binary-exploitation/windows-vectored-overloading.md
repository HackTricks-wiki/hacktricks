# Vectored Overloading PE Injection

{{#include ../banners/hacktricks-training.md}}

> [!TIP]
> ¿Buscas técnicas de shaping del heap LFH en Windows 11 y escape desde VMware Workstation PVSCSI (vmware-vmx)?
>
> {{#ref}}
> vmware-workstation-pvscsi-lfh-escape.md
> {{#endref}}

## Technique overview

Vectored Overloading es una **Windows PE injection primitive** que fusiona el clásico [Module Overloading](https://github.com/hasherezade/module_overloading) con Vectored Exception Handlers (VEHs) y hardware breakpoints. En lugar de parchear `LoadLibrary` o escribir su propio loader, el adversario:

1. Crea una sección `SEC_IMAGE` respaldada por un DLL legítimo (por ejemplo, `wmp.dll`).
2. Sobrescribe la vista mapeada con un PE malicioso completamente relocado pero mantiene el objeto sección apuntando a la imagen benigna en disco.
3. Registra un VEH y programa los debug registers para que cada llamada a `NtOpenSection`, `NtMapViewOfSection`, y opcionalmente `NtClose` desencadene un breakpoint en user-mode.
4. Llama a `LoadLibrary("amsi.dll")` (o cualquier otro objetivo benigno). Cuando el loader de Windows invoca esos syscalls, el VEH **evita la transición al kernel** y devuelve los handles y direcciones base de la imagen maliciosa preparada.

Porque el loader aún cree que mapeó el DLL solicitado, las herramientas que solo miran los archivos backing de la sección ven `wmp.dll` aunque la memoria ahora contenga la carga del atacante. Mientras tanto, imports/TLS callbacks siguen siendo resueltos por el loader genuino, reduciendo significativamente la cantidad de lógica custom de parseo de PE que el adversario debe mantener.

## Stage 1 – Build the disguised section

1. **Create and map a section for the decoy DLL**
```c
NtCreateSection(&DecoySection, SECTION_ALL_ACCESS, NULL,
0, PAGE_READWRITE, SEC_IMAGE, L"\??\C:\\Windows\\System32\\wmp.dll");
NtMapViewOfSection(DecoySection, GetCurrentProcess(), &DecoyView, 0, 0,
NULL, &DecoySize, ViewShare, 0, PAGE_READWRITE);
```
2. **Copy the malicious PE into that view** sección por sección, respetando `SizeOfRawData`/`VirtualSize` y actualizando las protecciones después (`PAGE_EXECUTE_READ`, `PAGE_READWRITE`, etc.).
3. **Apply relocations and resolve imports** exactamente como lo haría un reflective loader. Dado que la vista ya está mapeada como `SEC_IMAGE`, los alineamientos de sección y las guard pages coinciden con lo que el loader de Windows espera después.
4. **Normalize the PE header**:
- Si el payload es un EXE, establece `IMAGE_FILE_HEADER.Characteristics |= IMAGE_FILE_DLL` y pon a cero el entry point para evitar que `LdrpCallTlsInitializers` salte a stubs específicos de EXE.
- Los payloads DLL pueden mantener sus headers sin cambios.

En este punto el proceso posee una vista con permisos RWX cuyo objeto backing sigue siendo `wmp.dll`, pero los bytes en memoria están controlados por el atacante.

## Stage 2 – Hijack the loader with VEHs

1. **Register a VEH and arm hardware breakpoints**: programa `Dr0` (o otro registro de depuración) con la dirección de `ntdll!NtOpenSection` y ajusta `DR7` para que cada ejecución provoque `STATUS_SINGLE_STEP`. Repite después para `NtMapViewOfSection` y opcionalmente `NtClose`.
2. **Trigger DLL loading** con `LoadLibrary("amsi.dll")`. `LdrLoadDll` eventualmente llamará a `NtOpenSection` para obtener el handle de la sección real.
3. **VEH hook for `NtOpenSection`**:
- Localiza la ranura en la pila para el argumento `[out] PHANDLE SectionHandle`.
- Escribe el handle previamente creado `DecoySection` en esa ranura.
- Avanza `RIP`/`EIP` hasta la instrucción `ret` para que el kernel nunca sea llamado.
- Rearma el hardware breakpoint para vigilar `NtMapViewOfSection` a continuación.
4. **VEH hook for `NtMapViewOfSection`**:
- Sobrescribe el `[out] PVOID *BaseAddress` (y las salidas de tamaño/protección) con la dirección de la vista maliciosa ya mapeada.
- Omite el cuerpo del syscall igual que antes.
5. **(Optional) VEH hook for `NtClose`** verifica que el fake section handle se limpie, previniendo resource leaks y proporcionando una comprobación final de sanidad.

Dado que los syscalls nunca se ejecutan, los callbacks del kernel (ETWti, minifilter, etc.) no observan los eventos sospechosos de `NtOpenSection`/`NtMapViewOfSection`, reduciendo drásticamente la telemetría. Desde el punto de vista del loader todo tuvo éxito y `amsi.dll` está en memoria, por lo que procede con la resolución de imports/TLS contra los bytes del atacante.

## Stage 3 – Execute the payload

- **EXE payload**: El injector simplemente salta al entry point original una vez realizadas las relocations. Cuando el loader crea que llamaría a `DllMain`, el código custom en su lugar ejecuta el entry estilo EXE.
- **DLL payload / Node.js addon**: Resuelve y llama al export previsto (Kidkadi expone una función con nombre para JavaScript). Como el módulo ya está registrado en `LdrpModuleBaseAddressIndex`, búsquedas posteriores lo ven como el DLL benigno.

Cuando se combina con un Node.js native addon (`.node` file), todo el trabajo pesado de Windows-internals se mantiene fuera de la capa de JavaScript, ayudando al actor de amenazas a distribuir el mismo loader con muchos wrappers de Node ofuscados diferentes.

## References

- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [VectoredOverloading – PoC implementation](https://github.com/CheckPointSW/VectoredOverloading)

{{#include ../banners/hacktricks-training.md}}
