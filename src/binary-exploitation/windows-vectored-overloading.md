# Vectored Overloading PE Injection

{{#include ../banners/hacktricks-training.md}}

> [!TIP]
> क्या आप Windows 11 LFH heap shaping और VMware Workstation PVSCSI (vmware-vmx) escape techniques खोज रहे हैं?
>
> {{#ref}}
> vmware-workstation-pvscsi-lfh-escape.md
> {{#endref}}

## Technique overview

Vectored Overloading एक **Windows PE injection primitive** है जो क्लासिक [Module Overloading](https://github.com/hasherezade/module_overloading) को **Vectored Exception Handlers (VEHs)** और **hardware breakpoints** के साथ जोड़ता है। `LoadLibrary` को patch करने या अपना loader लिखने के बजाय, adversary:

1. एक `SEC_IMAGE` section बनाता है जो एक legitimate DLL (उदा., `wmp.dll`) से backed होता है।
2. mapped view को पूरी तरह relocated malicious PE से overwrite करता है लेकिन section object को disk पर मौजूद benign image की ओर ही पॉइंटिंग रखता है।
3. एक VEH register करता है और debug registers program करता है ताकि हर call पर `NtOpenSection`, `NtMapViewOfSection`, और विकल्प के तौर पर `NtClose` एक user-mode breakpoint उठाएँ।
4. `LoadLibrary("amsi.dll")` कॉल करता है (या कोई अन्य benign target)। जब Windows loader उन syscalls को invoke करता है, तो VEH kernel transition **skip** करके prepared malicious image के handles और base addresses लौटाता है।

क्योंकि loader अभी भी मानता है कि उसने requested DLL map किया है, tooling जो केवल section backing files देखती है वह `wmp.dll` देखती है भले ही memory में attacker का payload मौजूद हो। इस बीच, imports/TLS callbacks अभी भी genuine loader द्वारा resolve होते हैं, जिससे adversary को कम custom PE-parsing logic बनाए रखने की जरूरत पड़ती है।

## Stage 1 – Build the disguised section

1. **Create and map a section for the decoy DLL**
```c
NtCreateSection(&DecoySection, SECTION_ALL_ACCESS, NULL,
0, PAGE_READWRITE, SEC_IMAGE, L"\??\C:\\Windows\\System32\\wmp.dll");
NtMapViewOfSection(DecoySection, GetCurrentProcess(), &DecoyView, 0, 0,
NULL, &DecoySize, ViewShare, 0, PAGE_READWRITE);
```
2. **Copy the malicious PE into that view** section by section, honouring `SizeOfRawData`/`VirtualSize` and updating protections afterwards (`PAGE_EXECUTE_READ`, `PAGE_READWRITE`, etc.)।
3. **Apply relocations and resolve imports** बिल्कुल वैसे ही जैसा एक reflective loader करेगा। क्योंकि view पहले से `SEC_IMAGE` के रूप में mapped है, section alignments और guard pages बाद में Windows loader की उम्मीद के अनुसार मेल खाते हैं।
4. **Normalize the PE header**:
- यदि payload एक EXE है, तो `IMAGE_FILE_HEADER.Characteristics |= IMAGE_FILE_DLL` सेट करें और entry point को zero करें ताकि `LdrpCallTlsInitializers` EXE-विशिष्ट stubs में jump न करे।
- DLL payloads अपने headers को अपरिवर्तित रख सकते हैं।

इस बिंदु पर process के पास एक RWX-capable view है जिसका backing object अब भी `wmp.dll` है, फिर भी memory में bytes attacker-controlled हैं।

## Stage 2 – Hijack the loader with VEHs

1. **Register a VEH and arm hardware breakpoints**: `Dr0` (या कोई अन्य debug register) को `ntdll!NtOpenSection` के address से program करें और `DR7` सेट करें ताकि हर execution पर `STATUS_SINGLE_STEP` उठे। बाद में `NtMapViewOfSection` और विकल्प के रूप में `NtClose` के लिए यही दोहराएँ।
2. **Trigger DLL loading** `LoadLibrary("amsi.dll")` के साथ। `LdrLoadDll` अंततः वास्तविक section handle प्राप्त करने के लिए `NtOpenSection` कॉल करेगा।
3. **VEH hook for `NtOpenSection`**:
- `[out] PHANDLE SectionHandle` argument के लिए stack slot ढूँढें।
- उस slot में पहले बनाए गए `DecoySection` handle को लिख दें।
- `RIP`/`EIP` को `ret` instruction तक आगे बढ़ाएँ ताकि kernel कभी कॉल न हो।
- अगली बार `NtMapViewOfSection` को देखने के लिए hardware breakpoint को फिर से arm करें।
4. **VEH hook for `NtMapViewOfSection`**:
- `[out] PVOID *BaseAddress` (और size/protection outputs) को पहले से mapped malicious view के address से overwrite करें।
- syscall body को पहले की तरह skip करें।
5. **(Optional) VEH hook for `NtClose`** यह सत्यापित करता है कि fake section handle clean up हो गया है, resource leaks को रोकता है और एक अंतिम sanity check प्रदान करता है।

क्योंकि syscalls कभी execute नहीं होते, kernel callbacks (ETWti, minifilter, आदि) suspicious `NtOpenSection`/`NtMapViewOfSection` events को observe नहीं करते, जिससे telemetry बहुत घट जाती है। Loader की नज़र में सब कुछ सफल हुआ और `amsi.dll` memory में है, इसलिए यह imports/TLS resolution attacker के bytes के खिलाफ आगे बढ़ता है।

## Stage 3 – Execute the payload

- **EXE payload**: injector बस relocations के बाद original entry point पर jump कर देता है। जब loader सोचता है कि वह `DllMain` को कॉल करेगा, तब custom code EXE-style entry execute कर देता है।
- **DLL payload / Node.js addon**: intended export को resolve और call करें (Kidkadi JavaScript के लिए एक named function expose करता है)। क्योंकि module पहले से `LdrpModuleBaseAddressIndex` के साथ register है, subsequent lookups इसे benign DLL के रूप में देखते हैं।

जब इसे Node.js native addon (`.node` file) के साथ जोड़ा जाता है, तो सभी Windows-internals का भारी काम JavaScript लेयर के बाहर रहता है, जिससे threat actor कई अलग obfuscated Node wrappers के साथ वही loader भेज सकता है।

## References

- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [VectoredOverloading – PoC implementation](https://github.com/CheckPointSW/VectoredOverloading)

{{#include ../banners/hacktricks-training.md}}
