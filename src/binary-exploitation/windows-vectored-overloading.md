# Vectored Overloading PE Injection

{{#include ../banners/hacktricks-training.md}}

> [!TIP]
> 在寻找 Windows 11 LFH heap shaping 和 VMware Workstation PVSCSI (vmware-vmx) escape 技术吗？
>
> {{#ref}}
> vmware-workstation-pvscsi-lfh-escape.md
> {{#endref}}

## 技术概述

Vectored Overloading 是一种 **Windows PE 注入 原语**，将经典的 [Module Overloading](https://github.com/hasherezade/module_overloading) 与 Vectored Exception Handlers (VEHs) 和硬件断点结合。攻击者不是补丁 LoadLibrary 或编写自己的 loader，而是：

1. 创建一个由合法 DLL（例如 `wmp.dll`）作为 backing 的 `SEC_IMAGE` section。
2. 将映射视图覆盖为完全重定位的恶意 PE，但保持 section object 指向磁盘上的良性映像。
3. 注册 VEH 并编程调试寄存器，使每次调用 `NtOpenSection`、`NtMapViewOfSection`，以及可选的 `NtClose` 时触发用户态断点。
4. 调用 `LoadLibrary("amsi.dll")`（或任意其他良性目标）。当 Windows loader 调用这些 syscall 时，VEH **跳过内核转换** 并返回已准备好的恶意映像的句柄和基址。

因为 loader 仍然认为它映射了请求的 DLL，且只看 section backing file 的工具会看到 `wmp.dll`，尽管内存现在包含攻击者的载荷。与此同时，imports/TLS 回调仍由真实 loader 解析，这大大减少了攻击者需要维护的自定义 PE 解析逻辑量。

## Stage 1 – Build the disguised section

1. **Create and map a section for the decoy DLL**
```c
NtCreateSection(&DecoySection, SECTION_ALL_ACCESS, NULL,
0, PAGE_READWRITE, SEC_IMAGE, L"\??\C:\\Windows\\System32\\wmp.dll");
NtMapViewOfSection(DecoySection, GetCurrentProcess(), &DecoyView, 0, 0,
NULL, &DecoySize, ViewShare, 0, PAGE_READWRITE);
```
2. **将恶意 PE 按 section 复制进该 view**，遵循 `SizeOfRawData`/`VirtualSize` 并在之后更新保护（`PAGE_EXECUTE_READ`、`PAGE_READWRITE` 等）。
3. **应用重定位并解析 imports**，与 reflective loader 完全相同。因为 view 已以 `SEC_IMAGE` 映射，section 对齐和 guard page 与 Windows loader 后续的期待一致。
4. **规范化 PE 头**：
- 如果载荷是 EXE，将 `IMAGE_FILE_HEADER.Characteristics |= IMAGE_FILE_DLL` 并将入口点置零，以防 `LdrpCallTlsInitializers` 跳入 EXE 专用的 stub。
- DLL 载荷可以保持头部不变。

此时，进程拥有一个其 backing object 仍为 `wmp.dll` 的 RWX-capable view，但内存中的字节由攻击者控制。

## Stage 2 – Hijack the loader with VEHs

1. **注册 VEH 并设置硬件断点**：将 `Dr0`（或其他调试寄存器）编程为 `ntdll!NtOpenSection` 的地址，并设置 `DR7`，以便每次执行均触发 `STATUS_SINGLE_STEP`。稍后对 `NtMapViewOfSection`（以及可选的 `NtClose`）重复相同操作。
2. **通过 `LoadLibrary("amsi.dll")` 触发 DLL 加载**。`LdrLoadDll` 最终会调用 `NtOpenSection` 来获取真实的 section handle。
3. **针对 `NtOpenSection` 的 VEH 钩子**：
- 定位栈上 `[out] PHANDLE SectionHandle` 参数的位置。
- 将之前创建的 `DecoySection` handle 写入该位置。
- 将 `RIP`/`EIP` 推进到 `ret` 指令，从而永不调用内核。
- 重新设置硬件断点以监视接下来的 `NtMapViewOfSection`。
4. **针对 `NtMapViewOfSection` 的 VEH 钩子**：
- 覆写 `[out] PVOID *BaseAddress`（以及大小/保护输出）为已映射的恶意 view 的地址。
- 像之前一样跳过 syscall 本体。
5. **（可选）针对 `NtClose` 的 VEH 钩子** 验证伪造的 section handle 已被清理，防止资源泄漏并提供最终的合理性检查。

由于这些 syscall 从未执行，内核回调（ETWti、minifilter 等）不会观察到可疑的 `NtOpenSection`/`NtMapViewOfSection` 事件，显著降低了遥测。对 loader 来说一切成功，`amsi.dll` 已在内存中，因此它继续对攻击者的字节执行 import/TLS 解析。

## Stage 3 – Execute the payload

- **EXE 载荷**：一旦完成重定位，注入者直接跳转到原始入口点。当 loader 认为它将调用 `DllMain` 时，自定义代码反而执行 EXE 风格的入口。
- **DLL 载荷 / Node.js addon**：解析并调用目标导出（Kidkadi 向 JavaScript 暴露了一个命名函数）。因为模块已在 `LdrpModuleBaseAddressIndex` 中注册，后续查找将其视为良性 DLL。

当与 Node.js 本地 addon（`.node` 文件）结合时，所有 Windows 内部的复杂工作都保持在 JavaScript 层之外，帮助威胁行为者用许多不同的混淆 Node 包装器复用相同的 loader。

## 参考资料

- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [VectoredOverloading – PoC implementation](https://github.com/CheckPointSW/VectoredOverloading)

{{#include ../banners/hacktricks-training.md}}
