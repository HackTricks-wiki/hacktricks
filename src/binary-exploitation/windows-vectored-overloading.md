# Vectored Overloading PE Injection

{{#include ../banners/hacktricks-training.md}}

> [!TIP]
> Шукаєте Windows 11 LFH heap shaping та VMware Workstation PVSCSI (vmware-vmx) escape techniques?
>
> {{#ref}}
> vmware-workstation-pvscsi-lfh-escape.md
> {{#endref}}

## Technique overview

Vectored Overloading — це примітива Windows PE injection, що об’єднує класичний [Module Overloading](https://github.com/hasherezade/module_overloading) з **Vectored Exception Handlers (VEHs)** та **hardware breakpoints**. Замість того, щоб патчити `LoadLibrary` або писати власний лоадер, противник:

1. Створює `SEC_IMAGE` секцію, пов’язану з легітимною DLL (наприклад, `wmp.dll`).
2. Перезаписує змонтований вигляд (mapped view) повністю релокованим шкідливим PE, при цьому об’єкт секції все ще вказує на бенінну копію на диску.
3. Регіструє VEH і програмує debug-регістри так, щоби кожен виклик `NtOpenSection`, `NtMapViewOfSection` і опціонально `NtClose` викликав user-mode breakpoint.
4. Викликає `LoadLibrary("amsi.dll")` (або будь-яку іншу бенінну ціль). Коли Windows loader виконує ці syscall’и, VEH **пропускає перехід у ядро** й повертає дескриптори та базові адреси підготовленого шкідливого образу.

Оскільки loader думає, що змонтував потрібну DLL, інструменти, які дивляться тільки на backing file секції, бачать `wmp.dll`, хоча в пам’яті знаходиться payload атакуючого. Тим часом імпорти/TLS callbacks все ще резолвляться справжнім лоадером, що значно зменшує обсяг власної логіки парсингу PE, яку має підтримувати противник.

## Stage 1 – Build the disguised section

1. **Create and map a section for the decoy DLL**
```c
NtCreateSection(&DecoySection, SECTION_ALL_ACCESS, NULL,
0, PAGE_READWRITE, SEC_IMAGE, L"\??\C:\\Windows\\System32\\wmp.dll");
NtMapViewOfSection(DecoySection, GetCurrentProcess(), &DecoyView, 0, 0,
NULL, &DecoySize, ViewShare, 0, PAGE_READWRITE);
```
2. **Copy the malicious PE into that view** section by section, honouring `SizeOfRawData`/`VirtualSize` and updating protections afterwards (`PAGE_EXECUTE_READ`, `PAGE_READWRITE`, etc.).
3. **Apply relocations and resolve imports** exactly as a reflective loader would. Because the view is already mapped as `SEC_IMAGE`, section alignments and guard pages match what the Windows loader expects later.
4. **Normalize the PE header**:
- If the payload is an EXE, set `IMAGE_FILE_HEADER.Characteristics |= IMAGE_FILE_DLL` and zero the entry point to keep `LdrpCallTlsInitializers` from jumping into EXE-specific stubs.
- DLL payloads can keep their headers unchanged.

На цьому етапі процес володіє RWX-спроможним view, чий backing object все ще вказує на `wmp.dll`, але байти в пам’яті контролюються нападником.

## Stage 2 – Hijack the loader with VEHs

1. **Register a VEH and arm hardware breakpoints**: запрограмуйте `Dr0` (або інший debug-регістр) з адресою `ntdll!NtOpenSection` і встановіть `DR7`, щоб кожне виконання викликало `STATUS_SINGLE_STEP`. Потім повторіть для `NtMapViewOfSection` та опціонально `NtClose`.
2. **Trigger DLL loading** with `LoadLibrary("amsi.dll")`. `LdrLoadDll` в підсумку викличе `NtOpenSection`, щоб отримати реальний handle секції.
3. **VEH hook for `NtOpenSection`**:
- Знайдіть слот на стеку для аргументу `[out] PHANDLE SectionHandle`.
- Запишіть туди раніше створений `DecoySection` handle.
- Просуньте `RIP`/`EIP` на інструкцію `ret`, щоб ядро ніколи не було викликано.
- Переналаштуйте hardware breakpoint, щоб наступним спостерігати `NtMapViewOfSection`.
4. **VEH hook for `NtMapViewOfSection`**:
- Перезапишіть `[out] PVOID *BaseAddress` (та вихідні значення size/protection) адресою вже змонтованого шкідливого view.
- Пропустіть тіло syscall так само, як і раніше.
5. **(Optional) VEH hook for `NtClose`** перевіряє, що фейковий handle секції очищено, запобігаючи resource leaks та виконуючи фінальну перевірку цілісності.

Оскільки syscall’и ніколи не виконуються, kernel callbacks (ETWti, minifilter тощо) не бачать підозрілих подій `NtOpenSection`/`NtMapViewOfSection`, що різко знижує телеметрію. З точки зору loader’а все пройшло успішно і `amsi.dll` знаходиться в пам’яті, тож він продовжує резолв імпортів/TLS проти байтів нападника.

## Stage 3 – Execute the payload

- **EXE payload**: Інжектор просто переходить до оригінальної точки входу після завершення релокацій. Коли loader вважає, що мав би викликати `DllMain`, натомість виконується код у EXE-стилі.
- **DLL payload / Node.js addon**: Резолвте і викличте потрібний експорт (Kidkadi експортує іменовану функцію для JavaScript). Оскільки модуль вже зареєстрований у `LdrpModuleBaseAddressIndex`, подальші пошуки бачать його як бенінну DLL.

У поєднанні з Node.js native addon (`.node` файл) вся важка робота з Windows-інтерналами залишається за межами JavaScript шару, дозволяючи загружати той самий лоадер з багатьма різними обфускованими Node-обгортками.

## References

- [Check Point Research – GachiLoader: Defeating Node.js Malware with API Tracing](https://research.checkpoint.com/2025/gachiloader-node-js-malware-with-api-tracing/)
- [VectoredOverloading – PoC implementation](https://github.com/CheckPointSW/VectoredOverloading)

{{#include ../banners/hacktricks-training.md}}
