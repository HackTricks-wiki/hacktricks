# Indeksowanie Tablic

{{#include ../banners/hacktricks-training.md}}

## Podstawowe Informacje

Ta kategoria obejmuje wszystkie luki, które występują, ponieważ możliwe jest nadpisanie pewnych danych przez błędy w obsłudze indeksów w tablicach. To bardzo szeroka kategoria bez konkretnej metodologii, ponieważ mechanizm eksploatacji w pełni zależy od warunków luki.

Jednakże można znaleźć kilka ładnych **przykładów**:

- [https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html](https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html)
- Istnieją **2 kolidujące tablice**, jedna dla **adresów**, gdzie przechowywane są dane, a druga z **rozmiarami** tych danych. Możliwe jest nadpisanie jednego z drugiego, co umożliwia zapisanie dowolnego adresu, wskazując go jako rozmiar. To pozwala na zapisanie adresu funkcji `free` w tabeli GOT, a następnie nadpisanie go adresem do `system`, i wywołanie free z pamięci z `/bin/sh`.
- [https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html](https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html)
- 64 bity, brak nx. Nadpisanie rozmiaru, aby uzyskać rodzaj przepełnienia bufora, gdzie wszystko będzie używane jako podwójna liczba i sortowane od najmniejszego do największego, więc konieczne jest stworzenie shellcode, który spełnia ten wymóg, biorąc pod uwagę, że kanarek nie powinien być przesuwany z jego pozycji, a na koniec nadpisanie RIP adresem do ret, który spełnia wcześniejsze wymagania i umieszczenie największego adresu jako nowego adresu wskazującego na początek stosu (ujawnionego przez program), aby można było użyć ret do skoku tam.
- [https://faraz.faith/2019-10-20-secconctf-2019-sum/](https://faraz.faith/2019-10-20-secconctf-2019-sum/)
- 64 bity, brak relro, kanarek, nx, brak pie. Istnieje off-by-one w tablicy na stosie, który pozwala na kontrolowanie wskaźnika, przyznając WWW (zapisuje sumę wszystkich liczb w tablicy w nadpisanym adresie przez off-by-one w tablicy). Stos jest kontrolowany, więc adres GOT `exit` jest nadpisywany `pop rdi; ret`, a na stosie dodawany jest adres do `main` (powracając do `main`). Używana jest łańcuch ROP do ujawnienia adresu put w GOT przy użyciu puts (`exit` zostanie wywołany, więc wywoła `pop rdi; ret`, wykonując ten łańcuch na stosie). Na koniec używany jest nowy łańcuch ROP wykonujący ret2lib.
- [https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html](https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html)
- 32 bity, brak relro, brak kanarka, nx, pie. Wykorzystanie złego indeksowania do ujawnienia adresów libc i heap z stosu. Wykorzystanie przepełnienia bufora do wykonania ret2lib wywołując `system('/bin/sh')` (adres heap jest potrzebny do ominięcia sprawdzenia).
