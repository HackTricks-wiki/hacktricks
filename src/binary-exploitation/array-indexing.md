# Indexation de tableau

{{#include ../banners/hacktricks-training.md}}

## Informations de base

Cette catégorie inclut toutes les vulnérabilités qui se produisent parce qu'il est possible d'écraser certaines données à travers des erreurs dans la gestion des index dans les tableaux. C'est une catégorie très large sans méthodologie spécifique, car le mécanisme d'exploitation dépend complètement des conditions de la vulnérabilité.

Cependant, vous pouvez trouver quelques **exemples** intéressants :

- [https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html](https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html)
- Il y a **2 tableaux en collision**, un pour les **adresses** où les données sont stockées et un avec les **tailles** de ces données. Il est possible d'écraser l'un par l'autre, permettant d'écrire une adresse arbitraire en l'indiquant comme taille. Cela permet d'écrire l'adresse de la fonction `free` dans la table GOT et ensuite de l'écraser avec l'adresse de `system`, et d'appeler free depuis une mémoire avec `/bin/sh`.
- [https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html](https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html)
- 64 bits, pas de nx. Écraser une taille pour obtenir une sorte de débordement de tampon où tout va être utilisé comme un double nombre et trié du plus petit au plus grand, donc il est nécessaire de créer un shellcode qui répond à cette exigence, en tenant compte que le canary ne doit pas être déplacé de sa position et enfin écraser le RIP avec une adresse de retour, qui répond aux exigences précédentes et en mettant la plus grande adresse à une nouvelle adresse pointant vers le début de la pile (fuit par le programme) afin qu'il soit possible d'utiliser le retour pour sauter là-bas.
- [https://faraz.faith/2019-10-20-secconctf-2019-sum/](https://faraz.faith/2019-10-20-secconctf-2019-sum/)
- 64 bits, pas de relro, canary, nx, pas de pie. Il y a un off-by-one dans un tableau dans la pile qui permet de contrôler un pointeur accordant WWW (il écrit la somme de tous les nombres du tableau dans l'adresse écrasée par l'off-by-one dans le tableau). La pile est contrôlée donc l'adresse GOT `exit` est écrasée avec `pop rdi; ret`, et dans la pile est ajoutée l'adresse de `main` (retournant à `main`). Une chaîne ROP pour fuir l'adresse de mise dans la GOT en utilisant puts est utilisée (`exit` sera appelé donc il appellera `pop rdi; ret` exécutant ainsi cette chaîne dans la pile). Enfin, une nouvelle chaîne ROP exécutant ret2lib est utilisée.
- [https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html](https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html)
- 32 bits, pas de relro, pas de canary, nx, pie. Abuser d'une mauvaise indexation pour fuir les adresses de libc et de heap depuis la pile. Abuser du débordement de tampon pour faire un ret2lib appelant `system('/bin/sh')` (l'adresse de la heap est nécessaire pour contourner une vérification).
