# 数组索引

{{#include ../banners/hacktricks-training.md}}

## 基本信息

此类别包括所有由于在处理数组索引时出现错误而可能覆盖某些数据的漏洞。这是一个非常广泛的类别，没有特定的方法论，因为利用机制完全依赖于漏洞的条件。

然而，您可以找到一些不错的 **示例**：

- [https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html](https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html)
- 有 **2 个冲突的数组**，一个用于 **地址**，存储数据，另一个用于该数据的 **大小**。可以从一个数组覆盖另一个数组，从而写入一个任意地址，将其视为大小。这允许在 GOT 表中写入 `free` 函数的地址，然后用 `system` 的地址覆盖它，并从内存中调用 `/bin/sh` 的 free。
- [https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html](https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html)
- 64 位，无 nx。覆盖一个大小以获得一种缓冲区溢出，其中每个东西都将被用作双倍数字，并按从小到大的顺序排序，因此需要创建一个满足该要求的 shellcode，考虑到 canary 不应从其位置移动，最后用一个返回地址覆盖 RIP，该地址满足先前的要求，并将最大的地址放置为指向栈开始的新地址（由程序泄漏），以便可以使用 ret 跳转到那里。
- [https://faraz.faith/2019-10-20-secconctf-2019-sum/](https://faraz.faith/2019-10-20-secconctf-2019-sum/)
- 64 位，无 relro，canary，nx，无 pie。栈中的数组存在一个 off-by-one 漏洞，允许控制一个指针，从而授予 WWW（它将数组中所有数字的总和写入被数组中的 off-by-one 覆盖的地址）。栈被控制，因此 GOT 的 `exit` 地址被覆盖为 `pop rdi; ret`，并在栈中添加 `main` 的地址（循环回到 `main`）。使用 ROP 链泄漏 GOT 中 put 的地址，使用 puts（`exit` 将被调用，因此将调用 `pop rdi; ret`，因此在栈中执行此链）。最后，使用新的 ROP 链执行 ret2lib。
- [https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html](https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html)
- 32 位，无 relro，无 canary，nx，pie。利用错误的索引泄漏 libc 和堆的地址。利用缓冲区溢出进行 ret2lib 调用 `system('/bin/sh')`（需要堆地址以绕过检查）。
