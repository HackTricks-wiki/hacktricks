# Індексація масивів

{{#include ../banners/hacktricks-training.md}}

## Основна інформація

Ця категорія включає всі вразливості, які виникають через можливість перезапису певних даних через помилки в обробці індексів у масивах. Це дуже широка категорія без конкретної методології, оскільки механізм експлуатації повністю залежить від умов вразливості.

Однак ви можете знайти кілька гарних **прикладів**:

- [https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html](https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html)
- Є **2 колізійні масиви**, один для **адрес**, де зберігаються дані, і один з **розмірами** цих даних. Можливо перезаписати один з іншого, що дозволяє записати довільну адресу, вказуючи її як розмір. Це дозволяє записати адресу функції `free` в таблиці GOT, а потім перезаписати її адресою до `system` і викликати free з пам'яті з `/bin/sh`.
- [https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html](https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html)
- 64 біти, без nx. Перезаписати розмір, щоб отримати свого роду переповнення буфера, де все буде використовуватися як подвоєне число і сортуватися від найменшого до найбільшого, тому потрібно створити shellcode, який відповідає цій вимозі, враховуючи, що канарейка не повинна бути переміщена з її позиції, і нарешті перезаписати RIP адресою до ret, яка відповідає попереднім вимогам, і помістити найбільшу адресу на нову адресу, що вказує на початок стеку (викрита програмою), щоб можна було використовувати ret для стрибка туди.
- [https://faraz.faith/2019-10-20-secconctf-2019-sum/](https://faraz.faith/2019-10-20-secconctf-2019-sum/)
- 64 біти, без relro, канарейка, nx, без pie. Є off-by-one в масиві в стеку, що дозволяє контролювати вказівник, надаючи WWW (він записує суму всіх чисел масиву в перезаписаній адресі через off-by-one в масиві). Стек контролюється, тому адреса GOT `exit` перезаписується на `pop rdi; ret`, а в стеку додається адреса до `main` (зациклюючись назад на `main`). Використовується ланцюг ROP для викриття адреси put в GOT за допомогою puts (`exit` буде викликано, тому він викликатиме `pop rdi; ret`, отже, виконуючи цей ланцюг у стеку). Нарешті, використовується новий ланцюг ROP, що виконує ret2lib.
- [https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html](https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html)
- 32 біти, без relro, без канарейки, nx, pie. Зловживання поганою індексацією для викриття адрес libc і heap зі стеку. Зловживання переповненням буфера для виконання ret2lib, викликаючи `system('/bin/sh')` (адреса heap потрібна для обходу перевірки).
