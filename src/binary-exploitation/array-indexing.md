# Indexación de Arreglos

{{#include ../banners/hacktricks-training.md}}

## Información Básica

Esta categoría incluye todas las vulnerabilidades que ocurren porque es posible sobrescribir ciertos datos a través de errores en el manejo de índices en arreglos. Es una categoría muy amplia sin una metodología específica, ya que el mecanismo de explotación depende completamente de las condiciones de la vulnerabilidad.

Sin embargo, aquí puedes encontrar algunos **ejemplos**:

- [https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html](https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html)
- Hay **2 arreglos en colisión**, uno para **direcciones** donde se almacenan los datos y otro con los **tamaños** de esos datos. Es posible sobrescribir uno desde el otro, lo que permite escribir una dirección arbitraria indicándola como un tamaño. Esto permite escribir la dirección de la función `free` en la tabla GOT y luego sobrescribirla con la dirección de `system`, y llamar a free desde una memoria con `/bin/sh`.
- [https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html](https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html)
- 64 bits, sin nx. Sobrescribir un tamaño para obtener una especie de desbordamiento de búfer donde todo se va a usar como un número doble y ordenado de menor a mayor, por lo que es necesario crear un shellcode que cumpla con ese requisito, teniendo en cuenta que el canario no debe moverse de su posición y finalmente sobrescribir el RIP con una dirección de ret, que cumpla con los requisitos anteriores y poniendo la dirección más grande como una nueva dirección apuntando al inicio de la pila (filtrada por el programa) para que sea posible usar el ret para saltar allí.
- [https://faraz.faith/2019-10-20-secconctf-2019-sum/](https://faraz.faith/2019-10-20-secconctf-2019-sum/)
- 64 bits, sin relro, canario, nx, sin pie. Hay un off-by-one en un arreglo en la pila que permite controlar un puntero otorgando WWW (escribe la suma de todos los números del arreglo en la dirección sobrescrita por el off-by-one en el arreglo). La pila está controlada, por lo que la dirección GOT de `exit` se sobrescribe con `pop rdi; ret`, y en la pila se agrega la dirección a `main` (volviendo a `main`). Se utiliza una cadena ROP para filtrar la dirección de `put` en la GOT usando puts (`exit` será llamado, por lo que llamará a `pop rdi; ret`, ejecutando así esta cadena en la pila). Finalmente, se utiliza una nueva cadena ROP que ejecuta ret2lib.
- [https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html](https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html)
- 32 bits, sin relro, sin canario, nx, pie. Abusar de una mala indexación para filtrar direcciones de libc y heap desde la pila. Abusar del desbordamiento de búfer para hacer un ret2lib llamando a `system('/bin/sh')` (la dirección del heap es necesaria para eludir una verificación).
