# Array Indexing

{{#include ../banners/hacktricks-training.md}}

## Basic Information

यह श्रेणी उन सभी कमजोरियों को शामिल करती है जो तब होती हैं जब कुछ डेटा को एरे में इंडेक्स के प्रबंधन में त्रुटियों के माध्यम से ओवरराइट करना संभव होता है। यह एक बहुत व्यापक श्रेणी है जिसमें कोई विशिष्ट कार्यप्रणाली नहीं है क्योंकि शोषण तंत्र पूरी तरह से कमजोरी की स्थितियों पर निर्भर करता है।

हालांकि, आप कुछ अच्छे **उदाहरण** पा सकते हैं:

- [https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html](https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html)
- **2 टकराते एरे** हैं, एक **पते** के लिए जहां डेटा संग्रहीत है और एक उस डेटा के **आकार** के साथ। एक को दूसरे से ओवरराइट करना संभव है, जिससे एक मनमाना पता लिखना संभव हो जाता है जो इसे आकार के रूप में इंगित करता है। यह GOT तालिका में `free` फ़ंक्शन के पते को लिखने और फिर इसे `system` के पते से ओवरराइट करने की अनुमति देता है, और `/bin/sh` के साथ मेमोरी से free को कॉल करता है।
- [https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html](https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html)
- 64 बिट, कोई nx नहीं। एक आकार को ओवरराइट करें ताकि एक प्रकार का बफर ओवरफ्लो प्राप्त हो जहां हर चीज को एक डबल संख्या के रूप में उपयोग किया जाएगा और सबसे छोटे से सबसे बड़े तक क्रमबद्ध किया जाएगा, इसलिए एक शेलकोड बनाना आवश्यक है जो उस आवश्यकता को पूरा करे, यह ध्यान में रखते हुए कि कैनरी को अपनी स्थिति से नहीं हिलाया जाना चाहिए और अंततः RIP को एक पता के साथ ओवरराइट करना चाहिए जो पिछले आवश्यकताओं को पूरा करता है और सबसे बड़े पते को एक नए पते की ओर इंगित करना चाहिए जो स्टैक की शुरुआत की ओर है (जो प्रोग्राम द्वारा लीक किया गया है) ताकि इसे वहां कूदने के लिए ret का उपयोग करना संभव हो।
- [https://faraz.faith/2019-10-20-secconctf-2019-sum/](https://faraz.faith/2019-10-20-secconctf-2019-sum/)
- 64 बिट, कोई relro नहीं, कैनरी, nx, कोई pie नहीं। स्टैक में एक एरे में एक ऑफ-बाय-वन है जो एक पॉइंटर को नियंत्रित करने की अनुमति देता है जो WWW (यह ओवरराइट किए गए पते में एरे के सभी नंबरों का योग लिखता है) प्रदान करता है। स्टैक को नियंत्रित किया जाता है ताकि GOT `exit` पता `pop rdi; ret` के साथ ओवरराइट किया जाए, और स्टैक में `main` का पता जोड़ा जाता है (जो `main` पर वापस लूप करता है)। एक ROP श्रृंखला का उपयोग किया जाता है जो puts का उपयोग करके GOT में रखे गए पते को लीक करता है (`exit` को कॉल किया जाएगा इसलिए यह `pop rdi; ret` को कॉल करेगा और इस श्रृंखला को स्टैक में निष्पादित करेगा)। अंततः एक नई ROP श्रृंखला का उपयोग किया जाता है जो ret2lib को निष्पादित करती है।
- [https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html](https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html)
- 32 बिट, कोई relro नहीं, कोई कैनरी नहीं, nx, pie। स्टैक से libc और heap के पते को लीक करने के लिए एक खराब इंडेक्सिंग का दुरुपयोग करें। एक बफर ओवरफ्लो का दुरुपयोग करें ताकि `system('/bin/sh')` को कॉल करते हुए ret2lib किया जा सके (चेक को बायपास करने के लिए heap का पता आवश्यक है)।

{{#include /banners/hacktricks-training.md}}
