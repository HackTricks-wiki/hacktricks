# Array Indexing

{{#include ../banners/hacktricks-training.md}}

## Basic Information

Αυτή η κατηγορία περιλαμβάνει όλες τις ευπάθειες που προκύπτουν επειδή είναι δυνατό να επαναγραφούν ορισμένα δεδομένα μέσω σφαλμάτων στη διαχείριση των δεικτών σε πίνακες. Είναι μια πολύ ευρεία κατηγορία χωρίς συγκεκριμένη μεθοδολογία, καθώς ο μηχανισμός εκμετάλλευσης εξαρτάται εντελώς από τις συνθήκες της ευπάθειας.

Ωστόσο, μπορείτε να βρείτε μερικά ωραία **παραδείγματα**:

- [https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html](https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html)
- Υπάρχουν **2 συγκρουόμενοι πίνακες**, ένας για **διευθύνσεις** όπου αποθηκεύονται τα δεδομένα και ένας με τα **μεγέθη** αυτών των δεδομένων. Είναι δυνατό να επαναγραφεί ο ένας από τον άλλο, επιτρέποντας την εγγραφή μιας αυθαίρετης διεύθυνσης υποδεικνύοντας την ως μέγεθος. Αυτό επιτρέπει την εγγραφή της διεύθυνσης της συνάρτησης `free` στον πίνακα GOT και στη συνέχεια την επαναγραφή της με τη διεύθυνση προς `system`, και την κλήση του free από μια μνήμη με `/bin/sh`.
- [https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html](https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html)
- 64 bits, no nx. Επαναγράψτε ένα μέγεθος για να αποκτήσετε μια μορφή buffer overflow όπου όλα θα χρησιμοποιηθούν ως διπλός αριθμός και θα ταξινομηθούν από το μικρότερο στο μεγαλύτερο, οπότε είναι απαραίτητο να δημιουργηθεί ένα shellcode που να πληροί αυτή την απαίτηση, λαμβάνοντας υπόψη ότι το canary δεν πρέπει να μετακινηθεί από τη θέση του και τελικά να επαναγράψει το RIP με μια διεύθυνση προς ret, που να πληροί τις προηγούμενες απαιτήσεις και να τοποθετήσει τη μεγαλύτερη διεύθυνση σε μια νέα διεύθυνση που δείχνει στην αρχή της στοίβας (που διαρρέει από το πρόγραμμα) ώστε να είναι δυνατή η χρήση του ret για να πηδήξει εκεί.
- [https://faraz.faith/2019-10-20-secconctf-2019-sum/](https://faraz.faith/2019-10-20-secconctf-2019-sum/)
- 64bits, no relro, canary, nx, no pie. Υπάρχει ένα off-by-one σε έναν πίνακα στη στοίβα που επιτρέπει τον έλεγχο ενός δείκτη παρέχοντας WWW (γράφει το άθροισμα όλων των αριθμών του πίνακα στη διεύθυνση που έχει επαναγραφεί από το off-by-one στον πίνακα). Η στοίβα ελέγχεται ώστε η διεύθυνση GOT `exit` να επαναγραφεί με `pop rdi; ret`, και στη στοίβα προστίθεται η διεύθυνση προς `main` (επιστρέφοντας στο `main`). Χρησιμοποιείται μια αλυσίδα ROP για να διαρρεύσει τη διεύθυνση του put στον GOT χρησιμοποιώντας puts (`exit` θα κληθεί, οπότε θα καλέσει `pop rdi; ret`, εκτελώντας έτσι αυτή την αλυσίδα στη στοίβα). Τέλος, χρησιμοποιείται μια νέα αλυσίδα ROP που εκτελεί το ret2lib.
- [https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html](https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html)
- 32 bit, no relro, no canary, nx, pie. Καταχρήστε μια κακή ευρετηρίαση για να διαρρεύσετε διευθύνσεις της libc και της heap από τη στοίβα. Καταχρήστε το buffer overflow για να κάνετε ένα ret2lib καλώντας `system('/bin/sh')` (η διεύθυνση της heap είναι απαραίτητη για να παρακαμφθεί ένας έλεγχος).
