# Array Indexing

{{#include ../banners/hacktricks-training.md}}

## Basic Information

यह श्रेणी सभी कमजोरियों को शामिल करती है जो इस कारण होती हैं कि यह संभव है कि कुछ डेटा को एरे में अनुक्रमांक के प्रबंधन में त्रुटियों के माध्यम से ओवरराइट किया जा सके। यह एक बहुत व्यापक श्रेणी है जिसमें कोई विशिष्ट कार्यप्रणाली नहीं है क्योंकि शोषण तंत्र पूरी तरह से कमजोरी की स्थितियों पर निर्भर करता है।

हालांकि, आप कुछ अच्छे **उदाहरण** पा सकते हैं:

- [https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html](https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html)
- वहाँ **2 टकराते हुए एरे** हैं, एक **पते** के लिए जहाँ डेटा संग्रहीत है और एक उस डेटा के **आकारों** के साथ। एक को दूसरे से ओवरराइट करना संभव है, जिससे एक मनमाना पता लिखना संभव हो जाता है जो इसे आकार के रूप में इंगित करता है। यह GOT तालिका में `free` फ़ंक्शन का पता लिखने की अनुमति देता है और फिर इसे `system` के पते से ओवरराइट करता है, और `/bin/sh` के साथ मेमोरी से free को कॉल करता है।
- [https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html](https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html)
- 64 बिट, कोई nx नहीं। एक आकार को ओवरराइट करें ताकि एक प्रकार का बफर ओवरफ्लो प्राप्त हो जहाँ हर चीज़ को एक डबल संख्या के रूप में उपयोग किया जाएगा और सबसे छोटे से सबसे बड़े तक क्रमबद्ध किया जाएगा, इसलिए एक शेलकोड बनाना आवश्यक है जो उस आवश्यकता को पूरा करे, यह ध्यान में रखते हुए कि कैनरी को अपनी स्थिति से नहीं हिलाया जाना चाहिए और अंततः RIP को एक पता के साथ ओवरराइट करना चाहिए जो ret के लिए है, जो पिछले आवश्यकताओं को पूरा करता है और सबसे बड़े पते को एक नए पते की ओर इंगित करता है जो स्टैक की शुरुआत की ओर है (जो प्रोग्राम द्वारा लीक किया गया है) ताकि ret का उपयोग वहाँ कूदने के लिए किया जा सके।
- [https://faraz.faith/2019-10-20-secconctf-2019-sum/](https://faraz.faith/2019-10-20-secconctf-2019-sum/)
- 64 बिट, कोई relro नहीं, कैनरी, nx, कोई pie नहीं। स्टैक में एक एरे में एक ऑफ-बाय-वन है जो एक पॉइंटर को नियंत्रित करने की अनुमति देता है जो WWW (यह ओवरराइट किए गए पते में एरे के सभी नंबरों का योग लिखता है) को प्रदान करता है। स्टैक को नियंत्रित किया जाता है ताकि GOT `exit` पता `pop rdi; ret` के साथ ओवरराइट किया जाए, और स्टैक में `main` का पता जोड़ा जाता है (जो `main` पर वापस लूप करता है)। एक ROP श्रृंखला का उपयोग किया जाता है जो GOT में put के पते को लीक करने के लिए है (`exit` को कॉल किया जाएगा इसलिए यह `pop rdi; ret` को कॉल करेगा और इस प्रकार स्टैक में इस श्रृंखला को निष्पादित करेगा)। अंततः एक नई ROP श्रृंखला का उपयोग किया जाता है जो ret2lib को निष्पादित करती है।
- [https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html](https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html)
- 32 बिट, कोई relro नहीं, कोई कैनरी नहीं, nx, pie। स्टैक से libc और heap के पते को लीक करने के लिए एक खराब अनुक्रमण का दुरुपयोग करें। `system('/bin/sh')` को कॉल करते हुए ret2lib करने के लिए बफर ओवरफ्लो का दुरुपयोग करें (चेक को बायपास करने के लिए heap का पता आवश्यक है)।
