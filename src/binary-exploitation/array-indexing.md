# 배열 인덱싱

{{#include ../banners/hacktricks-training.md}}

## 기본 정보

이 카테고리는 배열의 인덱스 처리 오류로 인해 특정 데이터를 덮어쓸 수 있는 모든 취약점을 포함합니다. 이는 취약점의 조건에 완전히 의존하는 폭넓은 카테고리로, 특정한 방법론이 없습니다.

하지만 여기 몇 가지 멋진 **예제**를 찾을 수 있습니다:

- [https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html](https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html)
- **주소**가 저장된 배열과 그 데이터의 **크기**를 가진 **2개의 충돌 배열**이 있습니다. 하나에서 다른 것으로 덮어쓸 수 있어, 크기로 표시된 임의의 주소를 쓸 수 있습니다. 이를 통해 GOT 테이블에서 `free` 함수의 주소를 쓰고, 이를 `system`의 주소로 덮어쓴 후 `/bin/sh` 메모리에서 free를 호출할 수 있습니다.
- [https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html](https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html)
- 64비트, nx 없음. 크기를 덮어써서 모든 것이 두 배의 숫자로 사용되고 가장 작은 것부터 가장 큰 것까지 정렬되는 일종의 버퍼 오버플로우를 발생시킵니다. 따라서 그 요구 사항을 충족하는 쉘코드를 생성해야 하며, 카나리가 그 위치에서 이동하지 않도록 하고, 마지막으로 RIP를 ret 주소로 덮어씌워야 합니다. 이 주소는 이전 요구 사항을 충족하고, 가장 큰 주소는 스택의 시작을 가리키는 새로운 주소로 설정됩니다(프로그램에 의해 유출됨). 따라서 ret를 사용하여 그곳으로 점프할 수 있습니다.
- [https://faraz.faith/2019-10-20-secconctf-2019-sum/](https://faraz.faith/2019-10-20-secconctf-2019-sum/)
- 64비트, relro 없음, 카나리, nx, pie 없음. 스택의 배열에서 오프 바이 원이 있어 포인터를 제어할 수 있습니다. WWW를 부여합니다(배열의 모든 숫자의 합을 덮어쓴 주소에 씁니다). 스택이 제어되므로 GOT의 `exit` 주소가 `pop rdi; ret`로 덮어쓰여지고, 스택에 `main`의 주소가 추가됩니다(다시 `main`으로 루프). 그런 다음 puts를 사용하여 GOT에 있는 주소를 유출하는 ROP 체인이 사용됩니다(`exit`가 호출되므로 `pop rdi; ret`가 호출되어 이 체인이 스택에서 실행됩니다). 마지막으로 ret2lib를 실행하는 새로운 ROP 체인이 사용됩니다.
- [https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html](https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html)
- 32비트, relro 없음, 카나리 없음, nx, pie 없음. 잘못된 인덱싱을 악용하여 스택에서 libc와 힙의 주소를 유출합니다. 버퍼 오버플로우를 악용하여 `system('/bin/sh')`를 호출하는 ret2lib를 수행합니다(체크를 우회하기 위해 힙 주소가 필요합니다).
