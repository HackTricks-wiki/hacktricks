# Indexação de Array

{{#include ../banners/hacktricks-training.md}}

## Informações Básicas

Esta categoria inclui todas as vulnerabilidades que ocorrem porque é possível sobrescrever certos dados através de erros no manuseio de índices em arrays. É uma categoria muito ampla, sem uma metodologia específica, pois o mecanismo de exploração depende completamente das condições da vulnerabilidade.

No entanto, você pode encontrar alguns **exemplos** interessantes:

- [https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html](https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html)
- Existem **2 arrays colidindo**, um para **endereços** onde os dados são armazenados e um com os **tamanhos** desses dados. É possível sobrescrever um a partir do outro, permitindo escrever um endereço arbitrário indicando-o como um tamanho. Isso permite escrever o endereço da função `free` na tabela GOT e, em seguida, sobrescrevê-lo com o endereço de `system`, e chamar free de uma memória com `/bin/sh`.
- [https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html](https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html)
- 64 bits, sem nx. Sobrescrever um tamanho para obter uma espécie de buffer overflow onde tudo vai ser usado como um número duplo e ordenado do menor para o maior, então é necessário criar um shellcode que atenda a esse requisito, levando em conta que o canário não deve ser movido de sua posição e, finalmente, sobrescrever o RIP com um endereço para ret, que atenda aos requisitos anteriores e colocando o maior endereço como um novo endereço apontando para o início da pilha (vazado pelo programa) para que seja possível usar o ret para pular lá.
- [https://faraz.faith/2019-10-20-secconctf-2019-sum/](https://faraz.faith/2019-10-20-secconctf-2019-sum/)
- 64 bits, sem relro, canário, nx, sem pie. Há um off-by-one em um array na pilha que permite controlar um ponteiro concedendo WWW (ele escreve a soma de todos os números do array no endereço sobrescrito pelo off-by-one no array). A pilha é controlada, então o endereço GOT `exit` é sobrescrito com `pop rdi; ret`, e na pilha é adicionado o endereço para `main` (retornando para `main`). Uma cadeia ROP para vazar o endereço de put na GOT usando puts é utilizada (`exit` será chamado, então chamará `pop rdi; ret`, executando assim essa cadeia na pilha). Finalmente, uma nova cadeia ROP executando ret2lib é utilizada.
- [https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html](https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html)
- 32 bits, sem relro, sem canário, nx, pie. Abuse uma má indexação para vazar endereços de libc e heap da pilha. Abuse o buffer overflow para fazer um ret2lib chamando `system('/bin/sh')` (o endereço da heap é necessário para contornar uma verificação).
