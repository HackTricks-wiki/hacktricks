# Array Indexing

{{#include ../banners/hacktricks-training.md}}

## Grundinformationen

Diese Kategorie umfasst alle Schwachstellen, die auftreten, weil es möglich ist, bestimmte Daten durch Fehler im Umgang mit Indizes in Arrays zu überschreiben. Es ist eine sehr breite Kategorie ohne spezifische Methodik, da der Exploit-Mechanismus vollständig von den Bedingungen der Schwachstelle abhängt.

Hier finden Sie jedoch einige schöne **Beispiele**:

- [https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html](https://guyinatuxedo.github.io/11-index/swampctf19_dreamheaps/index.html)
- Es gibt **2 kollidierende Arrays**, eines für **Adressen**, wo Daten gespeichert sind, und eines mit den **Größen** dieser Daten. Es ist möglich, eines vom anderen zu überschreiben, was es ermöglicht, eine beliebige Adresse anzugeben, die als Größe betrachtet wird. Dies erlaubt es, die Adresse der `free`-Funktion in der GOT-Tabelle zu schreiben und sie dann mit der Adresse von `system` zu überschreiben und `free` aus einem Speicher mit `/bin/sh` aufzurufen.
- [https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html](https://guyinatuxedo.github.io/11-index/csaw18_doubletrouble/index.html)
- 64 Bit, kein nx. Überschreiben Sie eine Größe, um eine Art Pufferüberlauf zu erhalten, bei dem alles als doppelte Zahl verwendet wird und von klein nach groß sortiert wird, sodass es erforderlich ist, einen Shellcode zu erstellen, der diese Anforderung erfüllt, wobei zu beachten ist, dass der Canary nicht von seiner Position verschoben werden sollte, und schließlich die RIP mit einer Adresse zu ret überschreiben, die die vorherigen Anforderungen erfüllt und die größte Adresse auf eine neue Adresse zeigt, die auf den Anfang des Stacks zeigt (vom Programm geleakt), sodass es möglich ist, das ret zu verwenden, um dorthin zu springen.
- [https://faraz.faith/2019-10-20-secconctf-2019-sum/](https://faraz.faith/2019-10-20-secconctf-2019-sum/)
- 64 Bit, kein relro, Canary, nx, kein pie. Es gibt einen Off-by-One-Fehler in einem Array im Stack, der es ermöglicht, einen Zeiger zu kontrollieren, der WWW gewährt (es schreibt die Summe aller Zahlen des Arrays in die überschriebenen Adressen durch den Off-by-One-Fehler im Array). Der Stack wird kontrolliert, sodass die GOT-Adresse `exit` mit `pop rdi; ret` überschrieben wird, und im Stack wird die Adresse zu `main` hinzugefügt (zurück zu `main` schleifen). Eine ROP-Kette wird verwendet, um die Adresse von put in der GOT mit puts zu leaken (`exit` wird aufgerufen, sodass es `pop rdi; ret` aufruft und daher diese Kette im Stack ausführt). Schließlich wird eine neue ROP-Kette verwendet, die ret2lib ausführt.
- [https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html](https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html)
- 32 Bit, kein relro, kein Canary, nx, pie. Missbrauch einer schlechten Indizierung, um Adressen von libc und Heap aus dem Stack zu leaken. Missbrauch des Pufferüberlaufs, um ein ret2lib aufzurufen, das `system('/bin/sh')` aufruft (die Heap-Adresse wird benötigt, um eine Überprüfung zu umgehen).
