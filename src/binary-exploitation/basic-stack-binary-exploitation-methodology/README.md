# Metodologia di Base per l'Exploitation Binaria

{{#include ../../banners/hacktricks-training.md}}

## Informazioni di Base su ELF

Prima di iniziare a sfruttare qualsiasi cosa, è interessante comprendere parte della struttura di un **binario ELF**:

{{#ref}}
elf-tricks.md
{{#endref}}

## Strumenti di Sfruttamento

{{#ref}}
tools/
{{#endref}}

## Metodologia dello Stack Overflow

Con così tante tecniche, è utile avere uno schema su quando ciascuna tecnica sarà utile. Nota che le stesse protezioni influenzeranno tecniche diverse. Puoi trovare modi per bypassare le protezioni in ciascuna sezione di protezione, ma non in questa metodologia.

## Controllare il Flusso

Ci sono diversi modi in cui potresti finire per controllare il flusso di un programma:

- [**Stack Overflows**](../stack-overflow/index.html) sovrascrivendo il puntatore di ritorno dallo stack o l'EBP -> ESP -> EIP.
- Potrebbe essere necessario abusare di un [**Integer Overflows**](../integer-overflow.md) per causare l'overflow.
- Oppure tramite **Arbitrary Writes + Write What Where to Execution**.
- [**Format strings**](../format-strings/index.html)**:** Abusare di `printf` per scrivere contenuti arbitrari in indirizzi arbitrari.
- [**Array Indexing**](../array-indexing.md): Abusare di un indicizzazione mal progettata per poter controllare alcuni array e ottenere una scrittura arbitraria.
- Potrebbe essere necessario abusare di un [**Integer Overflows**](../integer-overflow.md) per causare l'overflow.
- **bof to WWW via ROP**: Abusare di un buffer overflow per costruire un ROP e poter ottenere un WWW.

Puoi trovare le tecniche di **Write What Where to Execution** in:

{{#ref}}
../arbitrary-write-2-exec/
{{#endref}}

## Loop Eterni

Qualcosa da tenere in considerazione è che di solito **solo un sfruttamento di una vulnerabilità potrebbe non essere sufficiente** per eseguire un exploit con successo, specialmente alcune protezioni devono essere bypassate. Pertanto, è interessante discutere alcune opzioni per **rendere una singola vulnerabilità sfruttabile più volte** nella stessa esecuzione del binario:

- Scrivere in una **catena ROP** l'indirizzo della **funzione `main`** o l'indirizzo in cui si verifica la **vulnerabilità**.
- Controllando una corretta catena ROP potresti essere in grado di eseguire tutte le azioni in quella catena.
- Scrivere nell'**indirizzo `exit` in GOT** (o qualsiasi altra funzione utilizzata dal binario prima di terminare) l'indirizzo per **tornare alla vulnerabilità**.
- Come spiegato in [**.fini_array**](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini_array.md#eternal-loop)**,** memorizzare qui 2 funzioni, una per chiamare di nuovo la vulnerabilità e un'altra per chiamare **`__libc_csu_fini`** che richiamerà di nuovo la funzione da `.fini_array`.

## Obiettivi di Sfruttamento

### Obiettivo: Chiamare una Funzione Esistente

- [**ret2win**](#ret2win): C'è una funzione nel codice che devi chiamare (forse con alcuni parametri specifici) per ottenere il flag.
- In un **bof regolare senza** [**PIE**](../common-binary-protections-and-bypasses/pie/index.html) **e** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/index.html) devi solo scrivere l'indirizzo nel puntatore di ritorno memorizzato nello stack.
- In un bof con [**PIE**](../common-binary-protections-and-bypasses/pie/index.html), dovrai bypassarlo.
- In un bof con [**canary**](../common-binary-protections-and-bypasses/stack-canaries/index.html), dovrai bypassarlo.
- Se hai bisogno di impostare diversi parametri per chiamare correttamente la funzione **ret2win**, puoi usare:
- Una **catena ROP** (se ci sono abbastanza gadget) per preparare tutti i parametri.
- [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/index.html) (nel caso tu possa chiamare questa syscall) per controllare molti registri.
- Gadget da [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) e [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) per controllare diversi registri.
- Tramite un [**Write What Where**](../arbitrary-write-2-exec/index.html) potresti abusare di altre vulnerabilità (non bof) per chiamare la funzione **`win`**.
- [**Pointers Redirecting**](../stack-overflow/pointer-redirecting.md): Nel caso in cui lo stack contenga puntatori a una funzione che verrà chiamata o a una stringa che verrà utilizzata da una funzione interessante (system o printf), è possibile sovrascrivere quell'indirizzo.
- [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) o [**PIE**](../common-binary-protections-and-bypasses/pie/index.html) potrebbero influenzare gli indirizzi.
- [**Variabili non inizializzate**](../stack-overflow/uninitialized-variables.md): Non si sa mai.

### Obiettivo: RCE

#### Via shellcode, se nx disabilitato o mescolando shellcode con ROP:

- [**(Stack) Shellcode**](#stack-shellcode): Questo è utile per memorizzare uno shellcode nello stack prima o dopo aver sovrascritto il puntatore di ritorno e poi **saltare a esso** per eseguirlo:
- **In ogni caso, se c'è un** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/index.html)**,** in un bof regolare dovrai bypassarlo (leak).
- **Senza** [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) **e** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md) è possibile saltare all'indirizzo dello stack poiché non cambierà mai.
- **Con** [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) dovrai utilizzare tecniche come [**ret2esp/ret2reg**](../rop-return-oriented-programing/ret2esp-ret2reg.md) per saltare a esso.
- **Con** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md), dovrai usare alcuni [**ROP**](../rop-return-oriented-programing/index.html) **per chiamare `memprotect`** e rendere alcune pagine `rwx`, per poi **memorizzare lo shellcode lì** (chiamando read ad esempio) e poi saltare lì.
- Questo mescolerà shellcode con una catena ROP.

#### Via syscalls

- [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv/index.html): Utile per chiamare `execve` per eseguire comandi arbitrari. Devi essere in grado di trovare i **gadget per chiamare la specifica syscall con i parametri**.
- Se [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) o [**PIE**](../common-binary-protections-and-bypasses/pie/index.html) sono abilitati, dovrai sconfiggerli **per utilizzare i gadget ROP** dal binario o dalle librerie.
- [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/index.html) può essere utile per preparare il **ret2execve**.
- Gadget da [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) e [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) per controllare diversi registri.

#### Via libc

- [**Ret2lib**](../rop-return-oriented-programing/ret2lib/index.html): Utile per chiamare una funzione da una libreria (di solito da **`libc`**) come **`system`** con alcuni argomenti preparati (ad es. `'/bin/sh'`). Devi che il binario **carichi la libreria** con la funzione che desideri chiamare (libc di solito).
- Se **compilato staticamente e senza** [**PIE**](../common-binary-protections-and-bypasses/pie/index.html), l'**indirizzo** di `system` e `/bin/sh` non cambierà, quindi è possibile usarli staticamente.
- **Senza** [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) **e conoscendo la versione di libc** caricata, l'**indirizzo** di `system` e `/bin/sh` non cambierà, quindi è possibile usarli staticamente.
- Con [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) **ma senza** [**PIE**](../common-binary-protections-and-bypasses/pie/index.html)**, conoscendo la libc e con il binario che utilizza la funzione `system`** è possibile **`ret` all'indirizzo di system in GOT** con l'indirizzo di `'/bin/sh'` nel parametro (dovrai scoprirlo).
- Con [ASLR](../common-binary-protections-and-bypasses/aslr/index.html) ma senza [PIE](../common-binary-protections-and-bypasses/pie/index.html), conoscendo la libc e **senza che il binario utilizzi la `system`**:
- Usa [**`ret2dlresolve`**](../rop-return-oriented-programing/ret2dlresolve.md) per risolvere l'indirizzo di `system` e chiamarlo.
- **Bypassa** [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) e calcola l'indirizzo di `system` e `'/bin/sh'` in memoria.
- **Con** [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) **e** [**PIE**](../common-binary-protections-and-bypasses/pie/index.html) **e non conoscendo la libc**: Devi:
- Bypassare [**PIE**](../common-binary-protections-and-bypasses/pie/index.html).
- Trovare la **versione di `libc`** utilizzata (leak un paio di indirizzi di funzione).
- Controllare gli **scenari precedenti con ASLR** per continuare.

#### Via EBP/RBP

- [**Stack Pivoting / EBP2Ret / EBP Chaining**](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md): Controllare l'ESP per controllare RET attraverso l'EBP memorizzato nello stack.
- Utile per **off-by-one** stack overflows.
- Utile come modo alternativo per controllare EIP mentre si abusa di EIP per costruire il payload in memoria e poi saltare a esso tramite EBP.

#### Varie

- [**Pointers Redirecting**](../stack-overflow/pointer-redirecting.md): Nel caso in cui lo stack contenga puntatori a una funzione che verrà chiamata o a una stringa che verrà utilizzata da una funzione interessante (system o printf), è possibile sovrascrivere quell'indirizzo.
- [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) o [**PIE**](../common-binary-protections-and-bypasses/pie/index.html) potrebbero influenzare gli indirizzi.
- [**Variabili non inizializzate**](../stack-overflow/uninitialized-variables.md): Non si sa mai.

{{#include ../../banners/hacktricks-training.md}}
