# Metodologia Básica de Exploração Binária

{{#include ../../banners/hacktricks-training.md}}

## Informações Básicas sobre ELF

Antes de começar a explorar qualquer coisa, é interessante entender parte da estrutura de um **binário ELF**:

{{#ref}}
elf-tricks.md
{{#endref}}

## Ferramentas de Exploração

{{#ref}}
tools/
{{#endref}}

## Metodologia de Stack Overflow

Com tantas técnicas, é bom ter um esquema de quando cada técnica será útil. Note que as mesmas proteções afetarão diferentes técnicas. Você pode encontrar maneiras de contornar as proteções em cada seção de proteção, mas não nesta metodologia.

## Controlando o Fluxo

Existem diferentes maneiras de você acabar controlando o fluxo de um programa:

- [**Stack Overflows**](../stack-overflow/index.html) sobrescrevendo o ponteiro de retorno da pilha ou o EBP -> ESP -> EIP.
- Pode ser necessário abusar de um [**Integer Overflows**](../integer-overflow.md) para causar o overflow.
- Ou via **Arbitrary Writes + Write What Where to Execution**.
- [**Format strings**](../format-strings/index.html)**:** Abuse `printf` para escrever conteúdo arbitrário em endereços arbitrários.
- [**Array Indexing**](../array-indexing.md): Abuse de um indexação mal projetada para conseguir controlar alguns arrays e obter uma escrita arbitrária.
- Pode ser necessário abusar de um [**Integer Overflows**](../integer-overflow.md) para causar o overflow.
- **bof to WWW via ROP**: Abuse um buffer overflow para construir um ROP e conseguir um WWW.

Você pode encontrar as técnicas de **Write What Where to Execution** em:

{{#ref}}
../arbitrary-write-2-exec/
{{#endref}}

## Laços Eternos

Algo a ser levado em conta é que geralmente **apenas uma exploração de uma vulnerabilidade pode não ser suficiente** para executar um exploit bem-sucedido, especialmente algumas proteções precisam ser contornadas. Portanto, é interessante discutir algumas opções para **tornar uma única vulnerabilidade explorável várias vezes** na mesma execução do binário:

- Escrever em uma cadeia **ROP** o endereço da **função `main`** ou para o endereço onde a **vulnerabilidade** está ocorrendo.
- Controlando uma cadeia ROP adequada, você pode ser capaz de realizar todas as ações nessa cadeia.
- Escrever no **endereço `exit` no GOT** (ou qualquer outra função usada pelo binário antes de terminar) o endereço para **voltar à vulnerabilidade**.
- Como explicado em [**.fini_array**](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini_array.md#eternal-loop)**,** armazene 2 funções aqui, uma para chamar a vulnerabilidade novamente e outra para chamar **`__libc_csu_fini`** que chamará novamente a função de `.fini_array`.

## Objetivos de Exploração

### Objetivo: Chamar uma Função Existente

- [**ret2win**](#ret2win): Há uma função no código que você precisa chamar (talvez com alguns parâmetros específicos) para obter a flag.
- Em um **bof regular sem** [**PIE**](../common-binary-protections-and-bypasses/pie/index.html) **e** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/index.html), você só precisa escrever o endereço no endereço de retorno armazenado na pilha.
- Em um bof com [**PIE**](../common-binary-protections-and-bypasses/pie/index.html), você precisará contorná-lo.
- Em um bof com [**canary**](../common-binary-protections-and-bypasses/stack-canaries/index.html), você precisará contorná-lo.
- Se você precisar definir vários parâmetros para chamar corretamente a função **ret2win**, você pode usar:
- Uma cadeia [**ROP**](#rop-and-ret2...-techniques) **se houver gadgets suficientes** para preparar todos os parâmetros.
- [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/index.html) (caso você possa chamar essa syscall) para controlar muitos registradores.
- Gadgets de [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) e [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) para controlar vários registradores.
- Via um [**Write What Where**](../arbitrary-write-2-exec/index.html), você poderia abusar de outras vulnerabilidades (não bof) para chamar a função **`win`**.
- [**Pointers Redirecting**](../stack-overflow/pointer-redirecting.md): Caso a pilha contenha ponteiros para uma função que será chamada ou para uma string que será usada por uma função interessante (system ou printf), é possível sobrescrever esse endereço.
- [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) ou [**PIE**](../common-binary-protections-and-bypasses/pie/index.html) podem afetar os endereços.
- [**Uninitialized variables**](../stack-overflow/uninitialized-variables.md): Você nunca sabe.

### Objetivo: RCE

#### Via shellcode, se nx desativado ou misturando shellcode com ROP:

- [**(Stack) Shellcode**](#stack-shellcode): Isso é útil para armazenar um shellcode na pilha antes ou depois de sobrescrever o ponteiro de retorno e então **pular para ele** para executá-lo:
- **Em qualquer caso, se houver um** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/index.html)**,** em um bof regular você precisará contorná-lo (vazar).
- **Sem** [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) **e** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md), é possível pular para o endereço da pilha, pois ele nunca mudará.
- **Com** [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html), você precisará de técnicas como [**ret2esp/ret2reg**](../rop-return-oriented-programing/ret2esp-ret2reg.md) para pular para ele.
- **Com** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md), você precisará usar algum [**ROP**](../rop-return-oriented-programing/index.html) **para chamar `memprotect`** e tornar alguma página `rwx`, para então **armazenar o shellcode lá** (chamando read, por exemplo) e então pular para lá.
- Isso misturará shellcode com uma cadeia ROP.

#### Via syscalls

- [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv/index.html): Útil para chamar `execve` para executar comandos arbitrários. Você precisa ser capaz de encontrar os **gadgets para chamar a syscall específica com os parâmetros**.
- Se [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) ou [**PIE**](../common-binary-protections-and-bypasses/pie/index.html) estiverem habilitados, você precisará derrotá-los **para usar gadgets ROP** do binário ou bibliotecas.
- [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/index.html) pode ser útil para preparar o **ret2execve**.
- Gadgets de [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) e [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) para controlar vários registradores.

#### Via libc

- [**Ret2lib**](../rop-return-oriented-programing/ret2lib/index.html): Útil para chamar uma função de uma biblioteca (geralmente de **`libc`**) como **`system`** com alguns argumentos preparados (por exemplo, `'/bin/sh'`). Você precisa que o binário **carregue a biblioteca** com a função que você gostaria de chamar (libc geralmente).
- Se **compilado estaticamente e sem** [**PIE**](../common-binary-protections-and-bypasses/pie/index.html), o **endereço** de `system` e `/bin/sh` não vão mudar, então é possível usá-los estaticamente.
- **Sem** [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) **e sabendo a versão da libc** carregada, o **endereço** de `system` e `/bin/sh` não vão mudar, então é possível usá-los estaticamente.
- Com [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) **mas sem** [**PIE**](../common-binary-protections-and-bypasses/pie/index.html)**, sabendo a libc e com o binário usando a função `system`**, é possível **`ret` para o endereço de system no GOT** com o endereço de `'/bin/sh'` no parâmetro (você precisará descobrir isso).
- Com [ASLR](../common-binary-protections-and-bypasses/aslr/index.html) mas sem [PIE](../common-binary-protections-and-bypasses/pie/index.html), sabendo a libc e **sem o binário usar a função `system`**:
- Use [**`ret2dlresolve`**](../rop-return-oriented-programing/ret2dlresolve.md) para resolver o endereço de `system` e chamá-lo.
- **Contorne** [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) e calcule o endereço de `system` e `'/bin/sh'` na memória.
- **Com** [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) **e** [**PIE**](../common-binary-protections-and-bypasses/pie/index.html) **e não sabendo a libc**: Você precisa:
- Contornar [**PIE**](../common-binary-protections-and-bypasses/pie/index.html).
- Encontrar a **versão da `libc`** usada (vazar alguns endereços de função).
- Verificar os **cenários anteriores com ASLR** para continuar.

#### Via EBP/RBP

- [**Stack Pivoting / EBP2Ret / EBP Chaining**](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md): Controle o ESP para controlar RET através do EBP armazenado na pilha.
- Útil para **off-by-one** stack overflows.
- Útil como uma maneira alternativa de acabar controlando o EIP enquanto abusa do EIP para construir o payload na memória e então pulando para ele via EBP.

#### Diversos

- [**Pointers Redirecting**](../stack-overflow/pointer-redirecting.md): Caso a pilha contenha ponteiros para uma função que será chamada ou para uma string que será usada por uma função interessante (system ou printf), é possível sobrescrever esse endereço.
- [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) ou [**PIE**](../common-binary-protections-and-bypasses/pie/index.html) podem afetar os endereços.
- [**Uninitialized variables**](../stack-overflow/uninitialized-variables.md): Você nunca sabe.

{{#include ../../banners/hacktricks-training.md}}
