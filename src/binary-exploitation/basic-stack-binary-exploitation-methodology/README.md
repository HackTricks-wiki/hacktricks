# Basic Binary Exploitation Methodology

{{#include ../../banners/hacktricks-training.md}}

## ELF Basic Info

Prima di iniziare a sfruttare qualsiasi cosa, è interessante comprendere parte della struttura di un **ELF binary**:

{{#ref}}
elf-tricks.md
{{#endref}}

## Exploiting Tools

{{#ref}}
tools/
{{#endref}}

## Stack Overflow Methodology

Con così tante tecniche, è utile avere uno schema su quando ciascuna tecnica sarà utile. Nota che le stesse protezioni influenzeranno tecniche diverse. Puoi trovare modi per bypassare le protezioni in ciascuna sezione di protezione, ma non in questa metodologia.

## Controlling the Flow

Ci sono diversi modi in cui potresti finire per controllare il flusso di un programma:

- [**Stack Overflows**](../stack-overflow/index.html) sovrascrivendo il puntatore di ritorno dallo stack o l'EBP -> ESP -> EIP.
- Potrebbe essere necessario abusare di un [**Integer Overflows**](../integer-overflow.md) per causare il overflow.
- Oppure tramite **Arbitrary Writes + Write What Where to Execution**.
- [**Format strings**](../format-strings/index.html)**:** Abusare di `printf` per scrivere contenuti arbitrari in indirizzi arbitrari.
- [**Array Indexing**](../array-indexing.md): Abusare di un indicizzazione mal progettata per poter controllare alcuni array e ottenere una scrittura arbitraria.
- Potrebbe essere necessario abusare di un [**Integer Overflows**](../integer-overflow.md) per causare il overflow.
- **bof to WWW via ROP**: Abusare di un buffer overflow per costruire un ROP e poter ottenere un WWW.

Puoi trovare le tecniche di **Write What Where to Execution** in:

{{#ref}}
../arbitrary-write-2-exec/
{{#endref}}

## Eternal Loops

Qualcosa da tenere in considerazione è che di solito **solo un sfruttamento di una vulnerabilità potrebbe non essere sufficiente** per eseguire un exploit con successo, specialmente alcune protezioni devono essere bypassate. Pertanto, è interessante discutere alcune opzioni per **rendere una singola vulnerabilità sfruttabile più volte** nella stessa esecuzione del binary:

- Scrivere in una **ROP** chain l'indirizzo della **funzione `main`** o l'indirizzo in cui si verifica la **vulnerabilità**.
- Controllando una corretta ROP chain potresti essere in grado di eseguire tutte le azioni in quella catena.
- Scrivere nell'indirizzo **`exit` in GOT** (o qualsiasi altra funzione utilizzata dal binary prima di terminare) l'indirizzo per **tornare alla vulnerabilità**.
- Come spiegato in [**.fini_array**](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini_array.md#eternal-loop)**,** memorizzare qui 2 funzioni, una per chiamare di nuovo la vuln e un'altra per chiamare **`__libc_csu_fini`** che richiamerà di nuovo la funzione da `.fini_array`.

## Exploitation Goals

### Goal: Call an Existing function

- [**ret2win**](#ret2win): C'è una funzione nel codice che devi chiamare (forse con alcuni parametri specifici) per ottenere il flag.
- In un **regular bof without** [**PIE**](../common-binary-protections-and-bypasses/pie/index.html) **and** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/index.html) devi solo scrivere l'indirizzo nel puntatore di ritorno memorizzato nello stack.
- In un bof con [**PIE**](../common-binary-protections-and-bypasses/pie/index.html), dovrai bypassarlo.
- In un bof con [**canary**](../common-binary-protections-and-bypasses/stack-canaries/index.html), dovrai bypassarlo.
- Se hai bisogno di impostare diversi parametri per chiamare correttamente la funzione **ret2win** puoi usare:
- Una [**ROP**](#rop-and-ret2...-techniques) **chain se ci sono abbastanza gadget** per preparare tutti i parametri.
- [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/index.html) (nel caso tu possa chiamare questa syscall) per controllare molti registri.
- Gadget da [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) e [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) per controllare diversi registri.
- Tramite un [**Write What Where**](../arbitrary-write-2-exec/index.html) potresti abusare di altre vulnerabilità (non bof) per chiamare la funzione **`win`**.
- [**Pointers Redirecting**](../stack-overflow/pointer-redirecting.md): Nel caso in cui lo stack contenga puntatori a una funzione che verrà chiamata o a una stringa che verrà utilizzata da una funzione interessante (system o printf), è possibile sovrascrivere quell'indirizzo.
- [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) o [**PIE**](../common-binary-protections-and-bypasses/pie/index.html) potrebbero influenzare gli indirizzi.
- [**Uninitialized variables**](../stack-overflow/uninitialized-variables.md): Non si sa mai.

### Goal: RCE

#### Via shellcode, se nx disabilitato o mescolando shellcode con ROP:

- [**(Stack) Shellcode**](#stack-shellcode): Questo è utile per memorizzare uno shellcode nello stack prima o dopo aver sovrascritto il puntatore di ritorno e poi **saltare a esso** per eseguirlo:
- **In ogni caso, se c'è un** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/index.html)**,** in un regular bof dovrai bypassarlo (leak).
- **Senza** [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) **e** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md) è possibile saltare all'indirizzo dello stack poiché non cambierà mai.
- **Con** [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) dovrai utilizzare tecniche come [**ret2esp/ret2reg**](../rop-return-oriented-programing/ret2esp-ret2reg.md) per saltare a esso.
- **Con** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md), dovrai usare alcuni [**ROP**](../rop-return-oriented-programing/index.html) **per chiamare `memprotect`** e rendere alcune pagine `rwx`, per poi **memorizzare lo shellcode lì** (chiamando read ad esempio) e poi saltare lì.
- Questo mescolerà shellcode con una catena ROP.

#### Via syscalls

- [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv/index.html): Utile per chiamare `execve` per eseguire comandi arbitrari. Devi essere in grado di trovare i **gadget per chiamare la specifica syscall con i parametri**.
- Se [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) o [**PIE**](../common-binary-protections-and-bypasses/pie/index.html) sono abilitati, dovrai sconfiggerli **per utilizzare i gadget ROP** dal binary o dalle librerie.
- [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/index.html) può essere utile per preparare il **ret2execve**.
- Gadget da [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) e [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) per controllare diversi registri.

#### Via libc

- [**Ret2lib**](../rop-return-oriented-programing/ret2lib/index.html): Utile per chiamare una funzione da una libreria (di solito da **`libc`**) come **`system`** con alcuni argomenti preparati (ad es. `'/bin/sh'`). Devi che il binary **carichi la libreria** con la funzione che desideri chiamare (libc di solito).
- Se **compilato staticamente e senza** [**PIE**](../common-binary-protections-and-bypasses/pie/index.html), l'**indirizzo** di `system` e `/bin/sh` non cambierà, quindi è possibile usarli staticamente.
- **Senza** [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) **e conoscendo la versione di libc** caricata, l'**indirizzo** di `system` e `/bin/sh` non cambierà, quindi è possibile usarli staticamente.
- Con [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) **ma senza** [**PIE**](../common-binary-protections-and-bypasses/pie/index.html)**, conoscendo la libc e con il binary che utilizza la funzione `system`** è possibile **`ret` all'indirizzo di system nel GOT** con l'indirizzo di `'/bin/sh'` nel parametro (dovrai scoprirlo).
- Con [ASLR](../common-binary-protections-and-bypasses/aslr/index.html) ma senza [PIE](../common-binary-protections-and-bypasses/pie/index.html), conoscendo la libc e **senza che il binary utilizzi la `system`** :
- Usa [**`ret2dlresolve`**](../rop-return-oriented-programing/ret2dlresolve.md) per risolvere l'indirizzo di `system` e chiamarlo.
- **Bypassa** [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) e calcola l'indirizzo di `system` e `'/bin/sh'` in memoria.
- **Con** [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) **e** [**PIE**](../common-binary-protections-and-bypasses/pie/index.html) **e non conoscendo la libc**: Devi:
- Bypassare [**PIE**](../common-binary-protections-and-bypasses/pie/index.html).
- Trovare la **versione di `libc`** utilizzata (leakare un paio di indirizzi di funzione).
- Controllare gli **scenari precedenti con ASLR** per continuare.

#### Via EBP/RBP

- [**Stack Pivoting / EBP2Ret / EBP Chaining**](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md): Controllare l'ESP per controllare RET tramite l'EBP memorizzato nello stack.
- Utile per **off-by-one** stack overflows.
- Utile come modo alternativo per controllare EIP mentre si abusa di EIP per costruire il payload in memoria e poi saltare a esso tramite EBP.

#### Misc

- [**Pointers Redirecting**](../stack-overflow/pointer-redirecting.md): Nel caso in cui lo stack contenga puntatori a una funzione che verrà chiamata o a una stringa che verrà utilizzata da una funzione interessante (system o printf), è possibile sovrascrivere quell'indirizzo.
- [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) o [**PIE**](../common-binary-protections-and-bypasses/pie/index.html) potrebbero influenzare gli indirizzi.
- [**Uninitialized variables**](../stack-overflow/uninitialized-variables.md): Non si sa mai.

{{#include ../../banners/hacktricks-training.md}}
