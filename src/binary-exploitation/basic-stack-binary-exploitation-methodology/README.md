# Méthodologie de Base pour l'Exploitation Binaire

{{#include ../../banners/hacktricks-training.md}}

## Informations de Base sur ELF

Avant de commencer à exploiter quoi que ce soit, il est intéressant de comprendre une partie de la structure d'un **binaire ELF** :

{{#ref}}
elf-tricks.md
{{#endref}}

## Outils d'Exploitation

{{#ref}}
tools/
{{#endref}}

## Méthodologie de Débordement de Pile

Avec tant de techniques, il est bon d'avoir un schéma pour savoir quand chaque technique sera utile. Notez que les mêmes protections affecteront différentes techniques. Vous pouvez trouver des moyens de contourner les protections dans chaque section de protection, mais pas dans cette méthodologie.

## Contrôle du Flux

Il existe différentes manières de contrôler le flux d'un programme :

- [**Débordements de Pile**](../stack-overflow/) en écrasant le pointeur de retour de la pile ou le EBP -> ESP -> EIP.
- Peut nécessiter d'abuser d'un [**Débordement d'Entier**](../integer-overflow.md) pour provoquer le débordement.
- Ou via **Écritures Arbitraires + Écrire Quoi Où pour l'Exécution**.
- [**Chaînes de Format**](../format-strings/)**:** Abuser de `printf` pour écrire du contenu arbitraire à des adresses arbitraires.
- [**Indexation de Tableaux**](../array-indexing.md) : Abuser d'une indexation mal conçue pour pouvoir contrôler certains tableaux et obtenir une écriture arbitraire.
- Peut nécessiter d'abuser d'un [**Débordement d'Entier**](../integer-overflow.md) pour provoquer le débordement.
- **bof à WWW via ROP** : Abuser d'un débordement de tampon pour construire un ROP et pouvoir obtenir un WWW.

Vous pouvez trouver les techniques **Écrire Quoi Où pour l'Exécution** dans :

{{#ref}}
../arbitrary-write-2-exec/
{{#endref}}

## Boucles Éternelles

Un point à prendre en compte est que généralement **une seule exploitation d'une vulnérabilité peut ne pas suffire** à exécuter un exploit réussi, surtout certaines protections doivent être contournées. Par conséquent, il est intéressant de discuter de certaines options pour **rendre une seule vulnérabilité exploitable plusieurs fois** dans la même exécution du binaire :

- Écrire dans une chaîne **ROP** l'adresse de la **fonction `main`** ou l'adresse où la **vulnérabilité** se produit.
- En contrôlant une chaîne ROP appropriée, vous pourriez être en mesure d'effectuer toutes les actions dans cette chaîne.
- Écrire à l'adresse **`exit` dans GOT** (ou toute autre fonction utilisée par le binaire avant de se terminer) l'adresse pour **revenir à la vulnérabilité**.
- Comme expliqué dans [**.fini_array**](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini_array.md#eternal-loop)**,** stocker 2 fonctions ici, une pour rappeler la vulnérabilité et une autre pour appeler **`__libc_csu_fini`** qui rappellera à nouveau la fonction de `.fini_array`.

## Objectifs d'Exploitation

### Objectif : Appeler une Fonction Existante

- [**ret2win**](./#ret2win) : Il y a une fonction dans le code que vous devez appeler (peut-être avec des paramètres spécifiques) afin d'obtenir le drapeau.
- Dans un **bof régulier sans** [**PIE**](../common-binary-protections-and-bypasses/pie/) **et** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/), vous devez simplement écrire l'adresse dans l'adresse de retour stockée dans la pile.
- Dans un bof avec [**PIE**](../common-binary-protections-and-bypasses/pie/), vous devrez le contourner.
- Dans un bof avec [**canary**](../common-binary-protections-and-bypasses/stack-canaries/), vous devrez le contourner.
- Si vous devez définir plusieurs paramètres pour appeler correctement la fonction **ret2win**, vous pouvez utiliser :
- Une chaîne [**ROP**](./#rop-and-ret2...-techniques) **s'il y a suffisamment de gadgets** pour préparer tous les paramètres.
- [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/) (au cas où vous pourriez appeler cet appel système) pour contrôler beaucoup de registres.
- Gadgets de [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) et [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) pour contrôler plusieurs registres.
- Via un [**Écrire Quoi Où**](../arbitrary-write-2-exec/), vous pourriez abuser d'autres vulnérabilités (pas de bof) pour appeler la fonction **`win`**.
- [**Redirection de Pointeurs**](../stack-overflow/pointer-redirecting.md) : Dans le cas où la pile contient des pointeurs vers une fonction qui va être appelée ou vers une chaîne qui va être utilisée par une fonction intéressante (system ou printf), il est possible d'écraser cette adresse.
- [**ASLR**](../common-binary-protections-and-bypasses/aslr/) ou [**PIE**](../common-binary-protections-and-bypasses/pie/) peuvent affecter les adresses.
- [**Variables Non Initialisées**](../stack-overflow/uninitialized-variables.md) : Vous ne savez jamais.

### Objectif : RCE

#### Via shellcode, si nx désactivé ou mélangeant shellcode avec ROP :

- [**(Stack) Shellcode**](./#stack-shellcode) : Cela est utile pour stocker un shellcode dans la pile avant ou après avoir écrasé le pointeur de retour et ensuite **sauter vers lui** pour l'exécuter :
- **Dans tous les cas, s'il y a un** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/)**,** dans un bof régulier, vous devrez le contourner (leak).
- **Sans** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **et** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md), il est possible de sauter à l'adresse de la pile car elle ne changera jamais.
- **Avec** [**ASLR**](../common-binary-protections-and-bypasses/aslr/), vous aurez besoin de techniques telles que [**ret2esp/ret2reg**](../rop-return-oriented-programing/ret2esp-ret2reg.md) pour sauter vers elle.
- **Avec** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md), vous devrez utiliser un [**ROP**](../rop-return-oriented-programing/) **pour appeler `memprotect`** et rendre une page `rwx`, afin de pouvoir ensuite **stocker le shellcode là-dedans** (en appelant read par exemple) et ensuite sauter là-bas.
- Cela mélangera le shellcode avec une chaîne ROP.

#### Via syscalls

- [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv/) : Utile pour appeler `execve` pour exécuter des commandes arbitraires. Vous devez être en mesure de trouver les **gadgets pour appeler l'appel système spécifique avec les paramètres**.
- Si [**ASLR**](../common-binary-protections-and-bypasses/aslr/) ou [**PIE**](../common-binary-protections-and-bypasses/pie/) sont activés, vous devrez les contourner **afin d'utiliser les gadgets ROP** du binaire ou des bibliothèques.
- [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/) peut être utile pour préparer le **ret2execve**.
- Gadgets de [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) et [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) pour contrôler plusieurs registres.

#### Via libc

- [**Ret2lib**](../rop-return-oriented-programing/ret2lib/) : Utile pour appeler une fonction d'une bibliothèque (généralement de **`libc`**) comme **`system`** avec des arguments préparés (par exemple, `'/bin/sh'`). Vous avez besoin que le binaire **charge la bibliothèque** avec la fonction que vous souhaitez appeler (libc généralement).
- Si **compilé statiquement et sans** [**PIE**](../common-binary-protections-and-bypasses/pie/), l'**adresse** de `system` et `/bin/sh` ne changera pas, donc il est possible de les utiliser statiquement.
- **Sans** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **et en connaissant la version de libc** chargée, l'**adresse** de `system` et `/bin/sh` ne changera pas, donc il est possible de les utiliser statiquement.
- Avec [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **mais sans** [**PIE**](../common-binary-protections-and-bypasses/pie/)**, en connaissant la libc et avec le binaire utilisant la fonction `system`**, il est possible de **`ret` à l'adresse de system dans le GOT** avec l'adresse de `'/bin/sh'` dans le paramètre (vous devrez le découvrir).
- Avec [ASLR](../common-binary-protections-and-bypasses/aslr/) mais sans [PIE](../common-binary-protections-and-bypasses/pie/), en connaissant la libc et **sans que le binaire utilise la `system`** :
- Utilisez [**`ret2dlresolve`**](../rop-return-oriented-programing/ret2dlresolve.md) pour résoudre l'adresse de `system` et l'appeler.
- **Contourner** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) et calculer l'adresse de `system` et `'/bin/sh'` en mémoire.
- **Avec** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **et** [**PIE**](../common-binary-protections-and-bypasses/pie/) **et sans connaître la libc** : Vous devez :
- Contourner [**PIE**](../common-binary-protections-and-bypasses/pie/).
- Trouver la **version de `libc`** utilisée (leak quelques adresses de fonction).
- Vérifier les **scénarios précédents avec ASLR** pour continuer.

#### Via EBP/RBP

- [**Pivotement de Pile / EBP2Ret / Chaînage EBP**](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md) : Contrôler l'ESP pour contrôler RET via le EBP stocké dans la pile.
- Utile pour les débordements de pile **off-by-one**.
- Utile comme une manière alternative de finir par contrôler l'EIP tout en abusant de l'EIP pour construire la charge utile en mémoire et ensuite sauter vers elle via EBP.

#### Divers

- [**Redirection de Pointeurs**](../stack-overflow/pointer-redirecting.md) : Dans le cas où la pile contient des pointeurs vers une fonction qui va être appelée ou vers une chaîne qui va être utilisée par une fonction intéressante (system ou printf), il est possible d'écraser cette adresse.
- [**ASLR**](../common-binary-protections-and-bypasses/aslr/) ou [**PIE**](../common-binary-protections-and-bypasses/pie/) peuvent affecter les adresses.
- [**Variables Non Initialisées**](../stack-overflow/uninitialized-variables.md) : Vous ne savez jamais.

{{#include ../../banners/hacktricks-training.md}}
