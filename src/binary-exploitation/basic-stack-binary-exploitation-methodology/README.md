# 基本的なバイナリエクスプロイテーションの方法論

{{#include ../../banners/hacktricks-training.md}}

## ELFの基本情報

何かをエクスプロイトする前に、**ELFバイナリ**の構造の一部を理解することは興味深いです：

{{#ref}}
elf-tricks.md
{{#endref}}

## エクスプロイトツール

{{#ref}}
tools/
{{#endref}}

## スタックオーバーフローの方法論

多くの技術があるため、各技術がどのように役立つかのスキームを持つことは良いことです。同じ保護が異なる技術に影響を与えることに注意してください。各保護セクションで保護を回避する方法を見つけることができますが、この方法論ではありません。

## フローの制御

プログラムのフローを制御する方法はいくつかあります：

- [**スタックオーバーフロー**](../stack-overflow/index.html)によってスタックからリターンポインタやEBP -> ESP -> EIPを上書きする。
- オーバーフローを引き起こすために[**整数オーバーフロー**](../integer-overflow.md)を悪用する必要があるかもしれません。
- または**任意の書き込み + 実行への書き込み**を介して。
- [**フォーマット文字列**](../format-strings/index.html)**:** `printf`を悪用して任意の内容を任意のアドレスに書き込む。
- [**配列インデクシング**](../array-indexing.md): 不適切に設計されたインデクシングを悪用して、いくつかの配列を制御し、任意の書き込みを得る。
- オーバーフローを引き起こすために[**整数オーバーフロー**](../integer-overflow.md)を悪用する必要があるかもしれません。
- **bofからWWWへのROP**: バッファオーバーフローを悪用してROPを構築し、WWWを取得できるようにします。

**実行への書き込み**技術は以下で見つけることができます：

{{#ref}}
../arbitrary-write-2-exec/
{{#endref}}

## 永続ループ

考慮すべきことは、通常**脆弱性の1回のエクスプロイトでは不十分な場合がある**ということです。特にいくつかの保護を回避する必要があります。したがって、**単一の脆弱性を同じバイナリの実行中に何度もエクスプロイト可能にする**いくつかのオプションを議論することは興味深いです：

- **`main`関数**のアドレスや**脆弱性**が発生しているアドレスを**ROP**チェーンに書き込む。
- 適切なROPチェーンを制御することで、そのチェーン内のすべてのアクションを実行できるかもしれません。
- **`exit`のGOT内のアドレス**（またはバイナリが終了する前に使用する他の関数）に**脆弱性に戻る**アドレスを書き込む。
- [**.fini_array**](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini_array.md#eternal-loop)**で説明されているように、ここに2つの関数を格納し、1つは再度脆弱性を呼び出し、もう1つは**`__libc_csu_fini`**を呼び出して`.fini_array`から関数を再度呼び出します。

## エクスプロイトの目標

### 目標: 既存の関数を呼び出す

- [**ret2win**](#ret2win): フラグを取得するために呼び出す必要があるコード内の関数（特定のパラメータが必要な場合もあります）。
- **PIE**がない**通常のbofでは**、スタックに保存されたリターンアドレスにアドレスを書き込むだけで済みます。
- [**PIE**](../common-binary-protections-and-bypasses/pie/index.html)があるbofでは、それを回避する必要があります。
- [**canary**](../common-binary-protections-and-bypasses/stack-canaries/index.html)があるbofでは、それを回避する必要があります。
- **ret2win**関数を正しく呼び出すために複数のパラメータを設定する必要がある場合は、以下を使用できます：
- すべてのパラメータを準備するのに十分なガジェットがある場合は、[**ROP**](#rop-and-ret2...-techniques) **チェーン**。
- [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/index.html)（このシステムコールを呼び出せる場合）を使用して多くのレジスタを制御します。
- [**ret2csu**](../rop-return-oriented-programing/ret2csu.md)および[**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md)からのガジェットを使用して複数のレジスタを制御します。
- [**Write What Where**](../arbitrary-write-2-exec/index.html)を介して、他の脆弱性（bofではない）を悪用して**`win`**関数を呼び出すことができます。
- [**ポインタのリダイレクト**](../stack-overflow/pointer-redirecting.md): スタックに呼び出される関数へのポインタや、興味のある関数（systemやprintf）で使用される文字列へのポインタが含まれている場合、そのアドレスを上書きすることが可能です。
- [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html)や[**PIE**](../common-binary-protections-and-bypasses/pie/index.html)がアドレスに影響を与える可能性があります。
- [**未初期化の変数**](../stack-overflow/uninitialized-variables.md): あなたは決してわかりません。

### 目標: RCE

#### シェルコードを介して、nxが無効な場合またはシェルコードとROPを混合する場合：

- [**(スタック)シェルコード**](#stack-shellcode): これは、リターンポインタを上書きする前または後にスタックにシェルコードを格納し、**それにジャンプして**実行するのに役立ちます：
- いかなる場合でも、**canary**がある場合、通常のbofではそれを回避（リーク）する必要があります。
- **ASLR**がない場合、**nx**がない場合、スタックのアドレスにジャンプすることが可能です。
- **ASLR**がある場合、[**ret2esp/ret2reg**](../rop-return-oriented-programing/ret2esp-ret2reg.md)のような技術を使用してそこにジャンプする必要があります。
- **nx**がある場合、いくつかの[**ROP**](../rop-return-oriented-programing/index.html)を使用して`memprotect`を呼び出し、ページを`rwx`にしてから、シェルコードをそこに格納（例えばreadを呼び出す）し、そこにジャンプする必要があります。
- これはシェルコードとROPチェーンを混合します。

#### システムコールを介して

- [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv/index.html): 任意のコマンドを実行するために`execve`を呼び出すのに役立ちます。**特定のシステムコールをパラメータで呼び出すためのガジェットを見つける必要があります**。
- [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html)や[**PIE**](../common-binary-protections-and-bypasses/pie/index.html)が有効な場合、バイナリやライブラリからROPガジェットを使用するためにそれらを打破する必要があります。
- [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/index.html)は**ret2execve**を準備するのに役立ちます。
- [**ret2csu**](../rop-return-oriented-programing/ret2csu.md)や[**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md)からのガジェットを使用して複数のレジスタを制御します。

#### libcを介して

- [**Ret2lib**](../rop-return-oriented-programing/ret2lib/index.html): **`libc`**からの関数（通常は**`system`**）を呼び出すのに役立ちます。準備された引数（例：`'/bin/sh'`）を使用します。呼び出したい関数を持つライブラリを**バイナリがロードする必要があります**（通常はlibc）。
- **静的にコンパイルされていて、PIEがない場合**、`system`と`/bin/sh`の**アドレス**は変わらないため、静的に使用することが可能です。
- **ASLRがなく、ロードされたlibcのバージョンを知っている場合**、`system`と`/bin/sh`の**アドレス**は変わらないため、静的に使用することが可能です。
- [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html)があるが[**PIE**](../common-binary-protections-and-bypasses/pie/index.html)がない場合、libcを知っていて、バイナリが`system`関数を使用している場合、**GOT内のsystemのアドレスに`ret`し、`'/bin/sh'`のアドレスをパラメータにすることが可能です**（これを解決する必要があります）。
- [ASLR](../common-binary-protections-and-bypasses/aslr/index.html)があり、[PIE](../common-binary-protections-and-bypasses/pie/index.html)がないが、バイナリが`system`を使用していない場合：
- [**`ret2dlresolve`**](../rop-return-oriented-programing/ret2dlresolve.md)を使用して`system`のアドレスを解決し、呼び出します。
- [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html)を回避し、メモリ内の`system`と`'/bin/sh'`のアドレスを計算します。
- [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html)と[**PIE**](../common-binary-protections-and-bypasses/pie/index.html)があり、libcを知らない場合：以下を行う必要があります：
- [**PIE**](../common-binary-protections-and-bypasses/pie/index.html)を回避します。
- 使用されている**`libc`のバージョン**を見つけます（いくつかの関数アドレスをリークします）。
- **ASLR**の以前のシナリオを確認して続行します。

#### EBP/RBPを介して

- [**スタックピボッティング / EBP2Ret / EBPチェイニング**](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md): スタック内の保存されたEBPを介してESPを制御してRETを制御します。
- **オフバイワン**スタックオーバーフローに役立ちます。
- EIPを制御するための代替手段として、EIPを悪用してメモリ内にペイロードを構築し、EBPを介してそれにジャンプするのに役立ちます。

#### その他

- [**ポインタのリダイレクト**](../stack-overflow/pointer-redirecting.md): スタックに呼び出される関数へのポインタや、興味のある関数（systemやprintf）で使用される文字列へのポインタが含まれている場合、そのアドレスを上書きすることが可能です。
- [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html)や[**PIE**](../common-binary-protections-and-bypasses/pie/index.html)がアドレスに影響を与える可能性があります。
- [**未初期化の変数**](../stack-overflow/uninitialized-variables.md): あなたは決してわかりません。

{{#include ../../banners/hacktricks-training.md}}
