# Correções de Relocação Inseguras em Carregadores de Assets

{{#include ../banners/hacktricks-training.md}}

## Por que as relocações de assets são importantes

Muitos motores de jogos legados (Granny 3D, Gamebryo, etc.) carregam assets complexos por:

1. Analisar um header e a tabela de seções.
2. Alocar um buffer de heap por seção.
3. Construir um `SectionArray` que armazena o ponteiro base de cada seção.
4. Aplicar tabelas de relocação para que os ponteiros embutidos nos dados da seção sejam ajustados para a seção alvo + deslocamento corretos.

Quando o handler de relocação confia cegamente em metadados controlados pelo atacante, cada relocação passa a ser um potencial primitivo de leitura/escrita arbitrária. Em *Anno 1404: Venice*, `granny2.dll` inclui o seguinte helper:

<details>
<summary>`GrannyGRNFixUp_0` (reduzido)</summary>
```c
int *__cdecl GrannyGRNFixUp_0(DWORD RelocationCount,
Relocation *PointerFixupArray,
int *SectionArray,
char *destination)
{
while (RelocationCount--) {
int target_base = SectionArray[PointerFixupArray->SectionNumber]; // unchecked index
int *patch_site = (int *)(destination + PointerFixupArray->SectionOffset); // unchecked offset
*patch_site = target_base ;
if (target_base)
*patch_site = target_base + PointerFixupArray->Offset;
++PointerFixupArray;
}
return SectionArray;
}
```
</details>

`SectionNumber` nunca é verificado quanto ao intervalo e `SectionOffset` nunca é validado em relação ao tamanho da seção atual. Construir relocation entries com offsets negativos ou índices excessivos permite que você saia da seção que controla e sobrescreva metadados do allocator, como o próprio section pointer array.

## Fase 1 – Escrita para trás nos metadados do loader

O objetivo é fazer com que o relocation table de **section 0** sobrescreva entradas de `SectionContentArray` (que espelha `SectionArray` e é armazenado imediatamente antes do primeiro section buffer). Como o custom allocator do Granny antepõe **0x1F** bytes e o NT heap adiciona seu próprio cabeçalho de **0x10** bytes além do alinhamento, um atacante pode precalcular a distância entre o início da primeira seção (`destination`) e o section-pointer array.

No build testado, forçar o loader a alocar uma estrutura `GrannyFile` que tenha exatamente **0x4000 bytes** faz com que os section-pointer arrays fiquem imediatamente antes do primeiro section buffer. Resolvendo
```
0x20 (header) + 0x20 (section descriptors)
+ n * 1 (section types) + n * 1 (flags)
+ n * 4 (pointer table) = 0x4000
```
resulta em **n = 2720** seções. Uma entrada de relocação com `SectionOffset = -0x3FF0` (`0x4000 - 0x20 - 0x20 + 0x30`) agora resolve para `SectionContentArray[1]` mesmo que a seção de destino acredite estar patching internal pointers.

## Stage 2 – Deterministic heap layout on Windows 10

Windows 10 NT Heap routes allocations **≤ RtlpLargestLfhBlock (0x4000)** para o LFH randomizado e allocations maiores para o deterministic backend allocator. Mantendo os metadados de `GrannyFile` ligeiramente acima desse limiar (usando o truque das 2720 seções) e pré-carregando vários assets `.gr2` maliciosos, você pode fazer:

- Allocation #1 (metadata + section pointer arrays) land in a >0x4000 backend chunk.
- Allocation #2 (section 0 contents) land immediately after allocation #1.
- Allocation #3 (section 1 contents) land right after allocation #2, dando um alvo previsível para relocations subsequentes.

Process Monitor confirmou que assets são streamados sob demanda, então requisitar repetidamente unidades/edifícios crafted é suficiente para “prime” o layout do heap sem tocar na imagem executável.

## Stage 3 – Converting the primitive into RCE

1. **Corrupt `SectionContentArray[1]`.** A relocation table da Section 0 a sobrescreve usando o `-0x3FF0` offset. Aponte-a para qualquer região gravável que você controle (por exemplo, dados de uma seção posterior).
2. **Recycle the corrupted pointer.** A relocation table da Section 1 agora trata `SectionNumber = 1` como o ponteiro que você injetou. O handler escreve `SectionArray[1] + Offset` para `destination + SectionOffset`, dando a você uma escrita arbitrária de 4 bytes para cada entrada de relocação.
3. **Hit reliable dispatchers.** Em Anno 1404 o alvo escolhido foi os allocator callbacks de `granny2.dll` (no ASLR, DEP disabled). Sobrescrever o ponteiro de função que `granny2.dll` usa para a próxima chamada `Malloc`/`Free` desvia imediatamente a execução para código controlado pelo atacante carregado a partir do asset trojanizado.

Porque tanto `granny2.dll` quanto os buffers `.gr2` injetados residem em endereços estáveis quando ASLR/DEP estão desabilitados, o ataque se reduz a construir uma pequena ROP chain ou shellcode bruto e apontar o callback para ele.

## Practical checklist

- Procure por asset loaders que mantenham `SectionArray` / relocation tables.
- Diff relocation handlers em busca de falta de checagem de limites em índices/offsets.
- Meça os allocator headers adicionados tanto pelo allocator wrapper do jogo quanto pelo heap do SO subjacente para computar offsets para trás precisamente.
- Forçar posicionamento determinístico por:
  - inflar os metadados (muitas seções vazias) até que o tamanho da allocation > `RtlpLargestLfhBlock`;
  - carregar repetidamente o asset malicioso para preencher buracos no backend.
- Use uma relocation table em duas etapas (primeira para retarget `SectionArray`, segunda para spray writes) e sobrescreva ponteiros de função que irão disparar durante a renderização normal (allocator callbacks, virtual tables, animation dispatchers, etc.).

Uma vez que você consiga uma escrita arbitrária em arquivo (por exemplo, via path traversal na transferência de save multiplayer), reempacotar RDA archives com o `.gr2` craftado fornece um vetor de entrega limpo que é automaticamente descomprimido por clientes remotos.

## Referências

- [Synacktiv – Exploiting Anno 1404](https://www.synacktiv.com/publications/exploiting-anno-1404.html)
- [W. Yason – Windows 10 Segment Heap Internals (BlackHat USA 2016)](https://blackhat.com/docs/us-16/materials/us-16-Yason-Windows-10-Segment-Heap-Internals-wp.pdf)

{{#include ../banners/hacktricks-training.md}}
