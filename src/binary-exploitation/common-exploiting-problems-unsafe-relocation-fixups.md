# Varlık Yükleyicilerinde Güvensiz Relocation Düzeltmeleri

{{#include ../banners/hacktricks-training.md}}

## Neden varlık relokasyonları önemli

Birçok eski oyun motoru (Granny 3D, Gamebryo, vb.) karmaşık varlıkları şu adımlarla yükler:

1. Bir başlık ve bölüm tablosunu ayrıştırma.
2. Her bölüm için bir heap tamponu tahsis etme.
3. Her bölümün taban işaretçisini depolayan bir `SectionArray` oluşturma.
4. Bölüm verilerinin içine gömülü işaretçilerin doğru hedef bölüm + ofset ile düzeltilmesi için relokasyon tablolarını uygulama.

Relokasyon işleyicisi saldırgan kontrollü metadata'ya körü körüne güvenirse, her relokasyon potansiyel bir keyfi okuma/yazma primitifine dönüşür. *Anno 1404: Venice*'de, `granny2.dll` aşağıdaki yardımcıyı içerir:

<details>
<summary>`GrannyGRNFixUp_0` (trimmed)</summary>
```c
int *__cdecl GrannyGRNFixUp_0(DWORD RelocationCount,
Relocation *PointerFixupArray,
int *SectionArray,
char *destination)
{
while (RelocationCount--) {
int target_base = SectionArray[PointerFixupArray->SectionNumber]; // unchecked index
int *patch_site = (int *)(destination + PointerFixupArray->SectionOffset); // unchecked offset
*patch_site = target_base ;
if (target_base)
*patch_site = target_base + PointerFixupArray->Offset;
++PointerFixupArray;
}
return SectionArray;
}
```
</details>

`SectionNumber` hiçbir zaman aralık denetimine tabi tutulmaz ve `SectionOffset` mevcut bölümün boyutuna karşı doğrulanmaz. Negatif offset'ler veya aşırı büyük indekslerle relocation girdileri oluşturarak, kontrol ettiğiniz bölümün dışına çıkabilir ve section pointer array gibi allocator metadata'sını ezebilirsiniz.

## Aşama 1 – loader metadata'sına geriye doğru yazma

Amaç, **section 0**'ın relocation table'ının `SectionContentArray` girişlerini (bu, `SectionArray`'ın aynasıdır ve ilk section buffer'ından hemen önce depolanır) üzerine yazmasını sağlamaktır. Granny’nin custom allocator'ı **0x1F** byte öneklediği ve NT heap kendi **0x10**-byte başlığını artı hizalamasını eklediği için, bir saldırgan ilk bölümün başlangıcı (`destination`) ile section-pointer array arasındaki mesafeyi önceden hesaplayabilir.

Test edilen build'de, loader'ı tam olarak **0x4000 bytes** olan bir `GrannyFile` yapısı allocate etmeye zorlamak, section-pointer array'lerinin ilk section buffer'ından hemen önce yerleşmesini sağlar. Bunu çözmek
```
0x20 (header) + 0x20 (section descriptors)
+ n * 1 (section types) + n * 1 (flags)
+ n * 4 (pointer table) = 0x4000
```
verir **n = 2720** bölüm. `SectionOffset = -0x3FF0` ( `0x4000 - 0x20 - 0x20 + 0x30` ) olan bir relocation girişi artık hedef bölüm içsel pointer'ları yama yaptığını düşünse bile `SectionContentArray[1]`'e çözülüyor.

## Stage 2 – Deterministic heap layout on Windows 10

Windows 10 NT Heap, tahsisleri **≤ RtlpLargestLfhBlock (0x4000)** için randomized LFH'ye, daha büyükleri ise deterministik backend allocator'a yönlendirir. `GrannyFile` metadata'sını bu eşikten biraz yukarıda tutarak (2720 bölüm hilesiyle) ve birkaç zararlı `.gr2` asset'i önyükleyerek şunu sağlayabilirsiniz:

- Allocation #1 (metadata + section pointer array'leri) >0x4000 olan bir backend chunk'ında yer alır.
- Allocation #2 (section 0 içeriği) Allocation #1'in hemen sonuna gelir.
- Allocation #3 (section 1 içeriği) Allocation #2'nin hemen sonuna gelir; bu da sonraki relocasyonlar için öngörülebilir bir hedef verir.

Process Monitor, asset'lerin talep üzerine streamlendiğini doğruladı; bu yüzden crafted birimleri/binaları tekrar tekrar istemek, executable imajına dokunmadan heap düzenini “prime” etmek için yeterlidir.

## Stage 3 – Converting the primitive into RCE

1. **Corrupt `SectionContentArray[1]`.** Section 0’ın relocation tablosu `-0x3FF0` offset'ini kullanarak bunu overwrite eder. Bunu kontrol ettiğiniz herhangi bir yazılabilir bölgeye yönlendirin (ör. sonraki section verisi).
2. **Recycle the corrupted pointer.** Section 1’in relocation tablosu artık `SectionNumber = 1`i enjekte ettiğiniz pointer olarak ele alır. Handler, `SectionArray[1] + Offset`'u `destination + SectionOffset`'a yazar; bu da her relocation girdisi için size keyfi bir 4-bayt yazma imkanı verir.
3. **Hit reliable dispatchers.** Anno 1404'te tercih edilen hedef `granny2.dll` allocator callback'leriydi (ASLR yok, DEP devre dışı). `granny2.dll`'in bir sonraki `Malloc`/`Free` çağrısı için kullandığı function pointer'ı overwrite etmek, trojanlanmış asset'ten yüklenen saldırgan kontrollü koda yürütmeyi anında yönlendirir.

ASLR/DEP devre dışı olduğunda hem `granny2.dll` hem de enjekte edilen `.gr2` buffer'ları kararlı adreslerde kaldığından, saldırı küçük bir ROP zinciri veya ham shellcode inşa edip callback'i ona yönlendirmeye indirgenir.

## Practical checklist

- `SectionArray` / relocation tablolarını koruyan asset loader'ları arayın.
- Indeks/offsetler üzerinde eksik sınır kontrolleri olan relocation handler'larını diffleyin.
- Geriye doğru offsetleri kesin hesaplamak için hem oyunun allocator wrapper'ının hem de alttaki OS heap'in eklediği allocator header'larını ölçün.
- Deterministik yerleşimi zorlamak için:
  - metadata'yı (birçok boş section) şişirerek allocation boyutunu `RtlpLargestLfhBlock`'un üzerine çıkarın;
  - backend boşluklarını doldurmak için zararlı asset'i tekrar tekrar yükleyin.
- İki aşamalı bir relocation tablosu kullanın (ilk aşama `SectionArray`'i yeniden hedef, ikinci aşama yazmaları spray yapmak) ve normal render sırasında tetiklenecek function pointer'ları overwrite edin (allocator callback'leri, virtual table'lar, animation dispatcher'lar vb.).

Örneğin path traversal ile rastgele dosya yazma elde ettiğinizde (multiplayer save transfer gibi), crafted `.gr2` içeren RDA arşivlerini yeniden paketlemek uzak istemciler tarafından otomatik olarak açıldığından temiz bir teslimat vektörü sağlar.

## References

- [Synacktiv – Exploiting Anno 1404](https://www.synacktiv.com/publications/exploiting-anno-1404.html)
- [W. Yason – Windows 10 Segment Heap Internals (BlackHat USA 2016)](https://blackhat.com/docs/us-16/materials/us-16-Yason-Windows-10-Segment-Heap-Internals-wp.pdf)

{{#include ../banners/hacktricks-training.md}}
