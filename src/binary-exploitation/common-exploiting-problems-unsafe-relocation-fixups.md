# Correzioni di rilocazione non sicure negli asset loader

{{#include ../banners/hacktricks-training.md}}

## Perché le rilocazioni degli asset sono importanti

Molti motori di gioco legacy (Granny 3D, Gamebryo, ecc.) caricano asset complessi tramite:

1. Analizzare un header e la tabella delle sezioni.
2. Allocare un buffer heap per ogni sezione.
3. Creare un `SectionArray` che memorizza il puntatore base di ogni sezione.
4. Applicare tabelle di rilocazione in modo che i puntatori incorporati nei dati della sezione vengano patchati alla corretta sezione di destinazione + offset.

Quando l'handler delle rilocazioni si fida ciecamente di metadata controllati dall'attaccante, ogni rilocazione diventa un potenziale primitivo di lettura/scrittura arbitraria. In *Anno 1404: Venice*, `granny2.dll` include il seguente helper:

<details>
<summary>`GrannyGRNFixUp_0` (troncato)</summary>
```c
int *__cdecl GrannyGRNFixUp_0(DWORD RelocationCount,
Relocation *PointerFixupArray,
int *SectionArray,
char *destination)
{
while (RelocationCount--) {
int target_base = SectionArray[PointerFixupArray->SectionNumber]; // unchecked index
int *patch_site = (int *)(destination + PointerFixupArray->SectionOffset); // unchecked offset
*patch_site = target_base ;
if (target_base)
*patch_site = target_base + PointerFixupArray->Offset;
++PointerFixupArray;
}
return SectionArray;
}
```
</details>

`SectionNumber` non viene mai controllato nel range e `SectionOffset` non viene mai validato rispetto alla dimensione della sezione corrente. Crafting relocation entries con offset negativi o indici sovradimensionati permette di uscire dalla sezione che controlli e di sovrascrivere allocator metadata come lo section pointer array stesso.

## Fase 1 – Scrivere all'indietro nei metadata del loader

L'obiettivo è fare in modo che the relocation table of **section 0** sovrascriva le voci di `SectionContentArray` (che rispecchia `SectionArray` ed è memorizzato subito prima del primo section buffer). Poiché l'allocator custom di Granny antepone **0x1F** bytes e l'NT heap aggiunge il proprio header di **0x10**-byte più l'allineamento, un attaccante può precalcolare la distanza tra l'inizio della prima sezione (`destination`) e lo section-pointer array.

Nella build testata, forzare il loader ad allocare una struttura `GrannyFile` che sia esattamente **0x4000 bytes** fa sì che gli section-pointer arrays finiscano immediatamente prima del primo section buffer. Solving
```
0x20 (header) + 0x20 (section descriptors)
+ n * 1 (section types) + n * 1 (flags)
+ n * 4 (pointer table) = 0x4000
```
gives **n = 2720** sections. A relocation entry with `SectionOffset = -0x3FF0` ( `0x4000 - 0x20 - 0x20 + 0x30` ) now resolves to `SectionContentArray[1]` even though the destination section thinks it is patching internal pointers.

## Stage 2 – Deterministic heap layout on Windows 10

Windows 10 NT Heap instrada le allocazioni **≤ RtlpLargestLfhBlock (0x4000)** al LFH randomizzato e quelle più grandi al backend allocator deterministico. Mantenendo i metadata del `GrannyFile` leggermente sopra quella soglia (usando il trucco delle 2720 sezioni) e precaricando diversi asset `.gr2` malevoli, puoi ottenere:

- Allocation #1 (metadata + section pointer arrays) si posiziona in un chunk del backend >0x4000.
- Allocation #2 (section 0 contents) si posiziona immediatamente dopo allocation #1.
- Allocation #3 (section 1 contents) si posiziona subito dopo allocation #2, fornendoti un target prevedibile per le relocations successive.

Process Monitor ha confermato che gli asset vengono streamati on demand, quindi richiedere ripetutamente unità/building appositamente create è sufficiente per "primare" il layout dell'heap senza toccare l'immagine eseguibile.

## Stage 3 – Converting the primitive into RCE

1. **Corrupt `SectionContentArray[1]`.** La tabella di relocation della sezione 0 la sovrascrive usando l'offset `-0x3FF0`. Puntala verso qualsiasi regione scrivibile che controlli (es., dati di sezioni successive).
2. **Recycle the corrupted pointer.** La tabella di relocation della sezione 1 ora tratta `SectionNumber = 1` come qualsiasi puntatore tu abbia iniettato. L'handler scrive `SectionArray[1] + Offset` su `destination + SectionOffset`, fornendoti una write arbitrarie di 4 byte per ogni voce di relocation.
3. **Hit reliable dispatchers.** In Anno 1404 il target preferito erano le allocator callbacks in `granny2.dll` (no ASLR, DEP disabled). Sovrascrivere il puntatore a funzione che `granny2.dll` usa per la successiva chiamata `Malloc`/`Free` devia immediatamente l'esecuzione su codice controllato dall'attaccante caricato dall'asset trojanizzato.

Poiché sia `granny2.dll` che i buffer `.gr2` iniettati risiedono a indirizzi stabili quando ASLR/DEP sono disabilitati, l'attacco si riduce a costruire una piccola catena ROP o shellcode grezzo e puntare il callback su di essa.

## Practical checklist

- Look for asset loaders that maintain `SectionArray` / relocation tables.
- Diff relocation handlers for missing bounds on indices/offsets.
- Measure the allocator headers added by both the game’s allocator wrapper and the underlying OS heap to compute backwards offsets precisely.
- Force deterministic placement by:
  - inflating metadata (many empty sections) until allocation size > `RtlpLargestLfhBlock`;
  - repeatedly loading the malicious asset to fill backend holes.
- Use a two-stage relocation table (first to retarget `SectionArray`, second to spray writes) and overwrite function pointers that will fire during normal rendering (allocator callbacks, virtual tables, animation dispatchers, etc.).

Once you gain an arbitrary file write (e.g., via the path traversal in the multiplayer save transfer), repackaging RDA archives with the crafted `.gr2` gives you a clean delivery vector that is automatically decompressed by remote clients.

## References

- [Synacktiv – Exploiting Anno 1404](https://www.synacktiv.com/publications/exploiting-anno-1404.html)
- [W. Yason – Windows 10 Segment Heap Internals (BlackHat USA 2016)](https://blackhat.com/docs/us-16/materials/us-16-Yason-Windows-10-Segment-Heap-Internals-wp.pdf)

{{#include ../banners/hacktricks-training.md}}
