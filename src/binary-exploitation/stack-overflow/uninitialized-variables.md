# Ongeïnitialiseerde Veranderlikes

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

Die kernidee hier is om te verstaan wat gebeur met **ongeïnitialiseerde veranderlikes aangesien hulle die waarde sal hê wat reeds in die toegewyde geheue aan hulle was.** Voorbeeld:

- **Funksie 1: `initializeVariable`**: Ons verklaar 'n veranderlike `x` en ken dit 'n waarde toe, kom ons sê `0x1234`. Hierdie aksie is soortgelyk aan die reservasie van 'n plek in geheue en die plasing van 'n spesifieke waarde daarin.
- **Funksie 2: `useUninitializedVariable`**: Hier verklaar ons 'n ander veranderlike `y` maar ken nie enige waarde aan dit toe nie. In C, ongeïnitialiseerde veranderlikes word nie outomaties op nul gestel nie. In plaas daarvan behou hulle die waarde wat laas op hul geheue ligging gestoor was.

Wanneer ons hierdie twee funksies **opvolgend** uitvoer:

1. In `initializeVariable`, word `x` 'n waarde toegeken (`0x1234`), wat 'n spesifieke geheue adres beset.
2. In `useUninitializedVariable`, word `y` verklaar maar nie 'n waarde toegeken nie, so dit neem die geheue plek reg na `x`. As gevolg van die nie-initialisering van `y`, eindig dit op om die waarde van dieselfde geheue ligging wat deur `x` gebruik is, "te erf", omdat dit die laaste waarde was wat daar was.

Hierdie gedrag illustreer 'n sleutelkonsep in lae-vlak programmering: **Geheue bestuur is van kardinale belang**, en ongeïnitialiseerde veranderlikes kan lei tot onvoorspelbare gedrag of sekuriteitskwesbaarhede, aangesien hulle onbedoeld sensitiewe data wat in geheue gelaat is, kan hou.

Ongeïnitialiseerde stapel veranderlikes kan verskeie sekuriteitsrisiko's inhou soos:

- **Data Lek**: Sensitiewe inligting soos wagwoorde, versleuteling sleutels, of persoonlike besonderhede kan blootgestel word as dit in ongeïnitialiseerde veranderlikes gestoor word, wat dit moontlik maak vir aanvallers om hierdie data te lees.
- **Inligting Onthulling**: Die inhoud van ongeïnitialiseerde veranderlikes kan besonderhede oor die program se geheue uitleg of interne operasies onthul, wat aanvallers help om geteikende ontploffings te ontwikkel.
- **Kras en Onstabiliteit**: Operasies wat ongeïnitialiseerde veranderlikes betrek, kan lei tot ongedefinieerde gedrag, wat lei tot program kras of onvoorspelbare uitkomste.
- **Arbitraire Kode Uitvoering**: In sekere scenario's kan aanvallers hierdie kwesbaarhede benut om die program se uitvoeringsvloei te verander, wat hulle in staat stel om arbitraire kode uit te voer, wat dalk afstandkode-uitvoeringsbedreigings kan insluit.

### Voorbeeld
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Hoe Dit Werk:

- **`initializeAndPrint` Funksie**: Hierdie funksie verklaar 'n heelgetal veranderlike `initializedVar`, ken dit die waarde `100` toe, en druk dan beide die geheueadres en die waarde van die veranderlike. Hierdie stap is eenvoudig en toon hoe 'n geïnitialiseerde veranderlike optree.
- **`demonstrateUninitializedVar` Funksie**: In hierdie funksie verklaar ons 'n heelgetal veranderlike `uninitializedVar` sonder om dit te initialiseer. Wanneer ons probeer om sy waarde te druk, kan die uitvoer 'n ewekansige getal toon. Hierdie getal verteenwoordig enige data wat voorheen op daardie geheue ligging was. Afhangende van die omgewing en kompilateur, kan die werklike uitvoer verskil, en soms, vir veiligheid, mag sommige kompilateurs veranderlikes outomaties na nul initialiseer, alhoewel daar nie op staatgemaak moet word nie.
- **`main` Funksie**: Die `main` funksie roep beide van die bogenoemde funksies in volgorde aan, wat die teenstelling tussen 'n geïnitialiseerde veranderlike en 'n nie-geïnitialiseerde een demonstreer.

## ARM64 Voorbeeld

Dit verander glad nie in ARM64 nie, aangesien plaaslike veranderlikes ook in die stapel bestuur word, jy kan [**hierdie voorbeeld nagaan**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) waar dit getoon word.

{{#include ../../banners/hacktricks-training.md}}
