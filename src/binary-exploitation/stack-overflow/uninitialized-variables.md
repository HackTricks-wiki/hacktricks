# Uninitialisierte Variablen

{{#include ../../banners/hacktricks-training.md}}

## Grundlegende Informationen

Die Kernidee hier ist zu verstehen, was mit **uninitialisierten Variablen passiert, da sie den Wert behalten, der bereits im ihnen zugewiesenen Speicher stand.** Beispiel:

- **Function 1: `initializeVariable`**: Wir deklarieren eine Variable `x` und weisen ihr einen Wert zu, sagen wir `0x1234`. Diese Aktion ist vergleichbar damit, einen Platz im Speicher zu reservieren und einen bestimmten Wert hineinzulegen.
- **Function 2: `useUninitializedVariable`**: Hier deklarieren wir eine andere Variable `y`, weisen ihr aber keinen Wert zu. In C werden uninitialisierte Variablen nicht automatisch auf null gesetzt. Stattdessen behalten sie den Wert, der zuletzt an ihrer Speicherstelle gespeichert war.

Wenn wir diese beiden Funktionen **nacheinander** ausführen:

1. In `initializeVariable` wird `x` ein Wert (`0x1234`) zugewiesen, der eine bestimmte Speicheradresse belegt.
2. In `useUninitializedVariable` wird `y` deklariert, aber nicht initialisiert, sodass es den direkt nach `x` liegenden Speicherplatz einnimmt. Da `y` nicht initialisiert wird, "erbt" es letztlich den Wert aus derselben Speicherstelle, die von `x` verwendet wurde, weil dort zuletzt dieser Wert stand.

Dieses Verhalten veranschaulicht ein zentrales Konzept in der Low-Level-Programmierung: **Speicherverwaltung ist entscheidend**, und uninitialisierte Variablen können zu unvorhersehbarem Verhalten oder Sicherheitslücken führen, da sie unbeabsichtigt sensible Daten enthalten können, die im Speicher verblieben sind.

Uninitialisierte Stack-Variablen können mehrere Sicherheitsrisiken bergen, wie zum Beispiel:

- **Data Leakage**: Sensible Informationen wie Passwörter, Verschlüsselungskeys oder persönliche Daten können offengelegt werden, wenn sie in uninitialisierten Variablen gespeichert sind, wodurch Angreifer möglicherweise auf diese Daten zugreifen können.
- **Information Disclosure**: Der Inhalt uninitialisierter Variablen kann Details über das Speicherlayout des Programms oder interne Abläufe offenbaren und Angreifern helfen, gezielte Exploits zu entwickeln.
- **Crashes and Instability**: Operationen mit uninitialisierten Variablen können undefiniertes Verhalten verursachen, was zu Programmabstürzen oder unvorhersehbaren Ergebnissen führt.
- **Arbitrary Code Execution**: In bestimmten Szenarien könnten Angreifer diese Schwachstellen ausnutzen, um den Programmfluss zu verändern und beliebigen Code auszuführen, einschließlich möglicher remote code execution-Bedrohungen.

### Beispiel
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Wie das funktioniert:

- **`initializeAndPrint` Funktion**: Diese Funktion deklariert eine Ganzzahlvariable `initializedVar`, weist ihr den Wert `100` zu und gibt dann sowohl die Speicheradresse als auch den Wert der Variable aus. Dieser Schritt ist unkompliziert und zeigt, wie sich eine initialisierte Variable verhält.
- **`demonstrateUninitializedVar` Funktion**: In dieser Funktion deklarieren wir eine Ganzzahlvariable `uninitializedVar`, ohne sie zu initialisieren. Wenn wir versuchen, ihren Wert auszugeben, kann die Ausgabe eine zufällige Zahl zeigen. Diese Zahl repräsentiert die Daten, die zuvor an dieser Speicherstelle enthalten waren. Abhängig von Umgebung und Compiler kann die tatsächliche Ausgabe variieren; manche Compiler initialisieren Variablen aus Sicherheitsgründen möglicherweise automatisch mit null, aber darauf sollte man sich nicht verlassen.
- **`main` Funktion**: Die `main`-Funktion ruft beide oben genannten Funktionen nacheinander auf und demonstriert so den Kontrast zwischen einer initialisierten und einer uninitialisierten Variable.

## Praktische Exploit-Muster (2024–2025)

Der klassische "read-before-write"-Bug bleibt relevant, weil moderne Mitigations (ASLR, canaries) häufig auf Geheimhaltung beruhen. Typische Angriffsflächen:

- **Partially initialized structs copied to userland**: Kernel oder Treiber führen häufig ein `memset` nur auf ein Längenfeld aus und dann `copy_to_user(&u, &local_struct, sizeof(local_struct))`. Padding und unbenutzte Felder leak Hälften des stack canary, gespeicherte frame pointers oder kernel pointers. Wenn das Struct einen function pointer enthält, kann das Nicht-Initialisieren auch ein **controlled overwrite** ermöglichen, wenn es später wiederverwendet wird.
- **Uninitialized stack buffers reused as indexes/lengths**: Ein uninitialisiertes `size_t len;`, das zur Begrenzung von `read(fd, buf, len)` verwendet wird, kann Angreifern out-of-bounds reads/writes ermöglichen oder erlauben, Größenprüfungen zu umgehen, wenn die Stack-Variable noch einen großen Wert aus einem vorherigen Aufruf enthält.
- **Compiler-added padding**: Selbst wenn einzelne Members initialisiert sind, werden implizite Padding-Bytes zwischen ihnen nicht initialisiert. Das Kopieren des gesamten Structs in userland leaks Padding, das oft vorherige Stack-Inhalte (canaries, pointers) enthält.
- **ROP/Canary disclosure**: Wenn eine Funktion ein lokales Struct zur Ausgabe auf stdout kopiert (z. B. zum Debugging), kann uninitialisiertes Padding den stack canary offenbaren und so eine anschließende Stack-Overflow-Exploitation ohne Brute-Force ermöglichen.

Minimal PoC pattern to detect such issues during review:
```c
struct msg {
char data[0x20];
uint32_t len;
};

ssize_t handler(int fd) {
struct msg m;              // never fully initialized
m.len = read(fd, m.data, sizeof(m.data));
// later debug helper
write(1, &m, sizeof(m));   // leaks padding + stale stack
return m.len;
}
```
## Gegenmaßnahmen & Compiler-Optionen (bei Umgehung beachten)

- **Clang/GCC auto-init**: Recent toolchains expose `-ftrivial-auto-var-init=zero` or `-ftrivial-auto-var-init=pattern`, filling *every* automatic (stack) variable at function entry with zeros or a poison pattern (0xAA / 0xFE). Damit werden die meisten Informations-leaks aus uninitialisiertem Stack-Speicher verhindert und die Ausnutzung erschwert, da Geheimnisse in bekannte Werte umgewandelt werden.
- **Linux kernel hardening**: Kernels built with `CONFIG_INIT_STACK_ALL` or the newer `CONFIG_INIT_STACK_ALL_PATTERN` zero/pattern-initialize every stack slot at function entry, wiping canaries/pointers that would otherwise leak. Achte auf Distros, die Clang-gebouwde Kernel mit diesen Optionen ausliefern (häufig in Hardenings-Konfigurationen ab 6.8+).
- **Opt-out attributes**: Clang now allows `__attribute__((uninitialized))` on specific locals/structs to keep performance-critical areas uninitialized even when global auto-init is enabled. Überprüfe solche Annotationen sorgfältig — sie markieren oft absichtliche Angriffsflächen für side channels.

Aus Angreiferperspektive entscheidet das Wissen, ob das Binary mit diesen Flags gebaut wurde, ob stack-leak primitives praktikabel sind oder ob du auf heap/data-section disclosures pivotieren musst.

## Schnell uninitialisierte Stack-Bugs finden

- **Compiler diagnostics**: Build with `-Wall -Wextra -Wuninitialized` (GCC/Clang). For C++ code, `clang-tidy -checks=cppcoreguidelines-init-variables` will auto-fix many cases to zero-init and is handy to spot missed locals during audit.
- **Dynamic tools**: `-fsanitize=memory` (MSan) in Clang or Valgrind's `--track-origins=yes` reliably flag reads of uninitialized stack bytes during fuzzing. Instrumentiere Test-Harnesses damit, um subtile padding leaks aufzudecken.
- **Grepping patterns**: In reviews, search for `copy_to_user` / `write` calls of whole structs, or `memcpy`/`send` of stack data where only part of the struct is set. Achte besonders auf Fehlerpfade, in denen die Initialisierung übersprungen wird.

## ARM64 Example

This doesn't change at all in ARM64 as local variables are also managed in the stack, you can [**check this example**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) were this is shown.



## References

- [CONFIG_INIT_STACK_ALL_PATTERN documentation](https://www.kernelconfig.io/config_init_stack_all_pattern)
- [GHSL-2024-197: GStreamer uninitialized stack variable leading to function pointer overwrite](https://securitylab.github.com/advisories/GHSL-2024-197_GStreamer/)
{{#include ../../banners/hacktricks-training.md}}
