# Μη Αρχικοποιημένες Μεταβλητές

{{#include ../../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

Η βασική ιδέα εδώ είναι να κατανοήσουμε τι συμβαίνει με **uninitialized variables καθώς θα έχουν την τιμή που βρισκόταν ήδη στη μνήμη που τους έχει ανατεθεί.** Παράδειγμα:

- **Συνάρτηση 1: `initializeVariable`**: Δηλώνουμε μια μεταβλητή `x` και της αναθέτουμε μια τιμή, ας πούμε `0x1234`. Αυτή η ενέργεια είναι ανάλογη με την κράτηση μιας θέσης στη μνήμη και την τοποθέτηση μιας συγκεκριμένης τιμής σε αυτήν.
- **Συνάρτηση 2: `useUninitializedVariable`**: Εδώ, δηλώνουμε άλλη μια μεταβλητή `y` αλλά δεν της αναθέτουμε καμία τιμή. Στην C, οι uninitialized variables δεν μηδενίζονται αυτόματα. Αντίθετα, διατηρούν όποια τιμή είχε αποθηκευτεί τελευταία στη θέση μνήμης τους.

Όταν εκτελέσουμε αυτές τις δύο συναρτήσεις **διαδοχικά**:

1. Στη `initializeVariable`, στη μεταβλητή `x` ανατίθεται μια τιμή (`0x1234`), η οποία καταλαμβάνει μια συγκεκριμένη διεύθυνση μνήμης.
2. Στη `useUninitializedVariable`, η `y` δηλώνεται αλλά δεν της ανατίθεται τιμή, οπότε καταλαμβάνει τη θέση μνήμης αμέσως μετά την `x`. Επειδή η `y` δεν αρχικοποιείται, τελικά "κληρονομεί" την τιμή από την ίδια θέση μνήμης που χρησιμοποίησε η `x`, επειδή αυτή ήταν η τελευταία τιμή που υπήρχε εκεί.

Αυτή η συμπεριφορά απεικονίζει μια βασική έννοια στον προγραμματισμό χαμηλού επιπέδου: **Η διαχείριση μνήμης είναι κρίσιμη**, και οι uninitialized variables μπορούν να οδηγήσουν σε απρόβλεπτη συμπεριφορά ή σε τρωτότητες ασφαλείας, καθώς μπορεί να κρατήσουν άθελά τους ευαίσθητα δεδομένα που έχουν μείνει στη μνήμη.

Οι uninitialized stack variables μπορούν να προκαλέσουν διάφορους κινδύνους ασφαλείας, όπως:

- **Data Leakage**: Ευαίσθητες πληροφορίες όπως passwords, encryption keys ή προσωπικά στοιχεία μπορούν να εκτεθούν αν αποθηκευτούν σε uninitialized variables, επιτρέποντας σε επιτιθέμενους να διαβάσουν πιθανώς αυτά τα δεδομένα.
- **Information Disclosure**: Τα περιεχόμενα των uninitialized variables μπορεί να αποκαλύψουν λεπτομέρειες για τη διάταξη της μνήμης του προγράμματος ή τις εσωτερικές λειτουργίες, βοηθώντας τους επιτιθέμενους να αναπτύξουν στοχευμένα exploits.
- **Crashes and Instability**: Λειτουργίες που εμπλέκουν uninitialized variables μπορούν να οδηγήσουν σε undefined behavior, προκαλώντας κρασαρίσματα του προγράμματος ή απρόβλεπτα αποτελέσματα.
- **Arbitrary Code Execution**: Σε ορισμένα σενάρια, οι επιτιθέμενοι θα μπορούσαν να εκμεταλλευτούν αυτές τις ευπάθειες για να αλλάξουν τη ροή εκτέλεσης του προγράμματος, επιτρέποντάς τους να εκτελέσουν arbitrary code, που μπορεί να περιλαμβάνει απειλές remote code execution.

### Παράδειγμα
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Πώς λειτουργεί αυτό:

- **`initializeAndPrint` Function**: Αυτή η συνάρτηση δηλώνει μια ακέραια μεταβλητή `initializedVar`, της αναθέτει την τιμή `100`, και στη συνέχεια εκτυπώνει τόσο τη διεύθυνση μνήμης όσο και την τιμή της μεταβλητής. Αυτό το βήμα είναι απλό και δείχνει πώς συμπεριφέρεται μια αρχικοποιημένη μεταβλητή.
- **`demonstrateUninitializedVar` Function**: Σε αυτή τη συνάρτηση δηλώνουμε μια ακέραια μεταβλητή `uninitializedVar` χωρίς αρχικοποίηση. Όταν προσπαθήσουμε να εκτυπώσουμε την τιμή της, η έξοδος μπορεί να εμφανίσει έναν τυχαίο αριθμό. Αυτός ο αριθμός αντιπροσωπεύει οποιαδήποτε δεδομένα υπήρχαν προηγουμένως σε εκείνη τη θέση μνήμης. Ανάλογα με το περιβάλλον και τον μεταγλωττιστή, η πραγματική έξοδος μπορεί να διαφέρει, και μερικές φορές, για λόγους ασφάλειας, κάποιοι μεταγλωττιστές μπορεί να αρχικοποιούν αυτόματα μεταβλητές σε μηδέν — όμως σε αυτό δεν πρέπει να βασιζόμαστε.
- **`main` Function**: Η συνάρτηση `main` καλεί και τις δύο παραπάνω συναρτήσεις στη σειρά, δείχνοντας την αντίθεση μεταξύ μιας αρχικοποιημένης μεταβλητής και μιας μη αρχικοποιημένης.

## Πρακτικά exploitation patterns (2024–2025)

Το κλασικό "read-before-write" bug παραμένει σχετικό επειδή οι σύγχρονες mitigations (ASLR, canaries) συχνά βασίζονται στην μυστικότητα. Τυπικές επιφάνειες επίθεσης:

- **Partially initialized structs copied to userland**: Kernel ή drivers συχνά `memset` μόνο ένα πεδίο μήκους και μετά κάνουν `copy_to_user(&u, &local_struct, sizeof(local_struct))`. Padding και unused fields leak stack canary halves, saved frame pointers ή kernel pointers. Αν το struct περιέχει function pointer, αφήνοντάς το uninitialized μπορεί επίσης να επιτρέψει **controlled overwrite** όταν επαναχρησιμοποιηθεί αργότερα.
- **Uninitialized stack buffers reused as indexes/lengths**: Ένα uninitialized `size_t len;` που χρησιμοποιείται για να περιορίσει το `read(fd, buf, len)` μπορεί να δώσει σε επιτιθέμενους out-of-bounds reads/writes ή να επιτρέψει την παράκαμψη των ελέγχων μεγέθους όταν η θέση στο stack εξακολουθεί να περιέχει μια μεγάλη τιμή από προηγούμενη κλήση.
- **Padding που προστίθεται από τον μεταγλωττιστή**: Ακόμα κι όταν τα μεμονωμένα μέλη είναι αρχικοποιημένα, τα implicit padding bytes μεταξύ τους δεν είναι. Η αντιγραφή ολόκληρου του struct στο userland leaks padding που συχνά περιέχει προηγούμενο περιεχόμενο stack (canaries, pointers).
- **ROP/Canary disclosure**: Αν μια συνάρτηση αντιγράψει ένα local struct στο stdout για debugging, το uninitialized padding μπορεί να αποκαλύψει το stack canary, επιτρέποντας επακόλουθη stack overflow exploitation χωρίς brute-force.

Ελάχιστο PoC pattern για την ανίχνευση τέτοιων ζητημάτων κατά την ανασκόπηση:
```c
struct msg {
char data[0x20];
uint32_t len;
};

ssize_t handler(int fd) {
struct msg m;              // never fully initialized
m.len = read(fd, m.data, sizeof(m.data));
// later debug helper
write(1, &m, sizeof(m));   // leaks padding + stale stack
return m.len;
}
```
## Μέτρα μετριασμού & compiler options (keep in mind when bypassing)

- **Clang/GCC auto-init**: Οι πρόσφατες toolchains εκθέτουν `-ftrivial-auto-var-init=zero` ή `-ftrivial-auto-var-init=pattern`, γεμίζοντας *κάθε* automatic (stack) μεταβλητή στην είσοδο της συνάρτησης με μηδενικά ή με poison pattern (0xAA / 0xFE). Αυτό κλείνει τα περισσότερα uninitialized-stack info leaks και κάνει την εκμετάλλευση πιο δύσκολη μετατρέποντας μυστικά σε γνωστές τιμές.
- **Linux kernel hardening**: Πυρήνες που χτίζονται με `CONFIG_INIT_STACK_ALL` ή το νεότερο `CONFIG_INIT_STACK_ALL_PATTERN` μηδενίζουν/pattern-initialize κάθε stack slot στην είσοδο της συνάρτησης, σβήνοντας canaries/pointers που αλλιώς θα leak. Ψάξτε για distros που ship Clang-built kernels με αυτές τις επιλογές ενεργοποιημένες (συνηθισμένο σε 6.8+ hardening configs).
- **Opt-out attributes**: Το Clang πλέον επιτρέπει `__attribute__((uninitialized))` σε συγκεκριμένους locals/structs για να κρατά performance-critical περιοχές uninitialized ακόμα και όταν global auto-init είναι ενεργοποιημένο. Εξετάστε προσεκτικά τέτοιες annotations—συχνά σηματοδοτούν σκόπιμη attack surface για side channels.

Από την πλευρά του attacker, το αν το binary χτίστηκε με αυτές τις flags καθορίζει αν τα stack-leak primitives είναι βιώσιμα ή αν πρέπει να pivot σε heap/data-section disclosures.

## Finding uninitialized-stack bugs quickly

- **Compiler diagnostics**: Κάντε build με `-Wall -Wextra -Wuninitialized` (GCC/Clang). Για C++ κώδικα, `clang-tidy -checks=cppcoreguidelines-init-variables` θα auto-fix πολλές περιπτώσεις σε zero-init και είναι χρήσιμο για να εντοπίσετε missed locals κατά την audit.
- **Dynamic tools**: `-fsanitize=memory` (MSan) στο Clang ή το Valgrind `--track-origins=yes` σηματοδοτούν αξιόπιστα reads από uninitialized stack bytes κατά το fuzzing. Instrument test harnesses με αυτά για να φέρουν στην επιφάνεια subtle padding leaks.
- **Grepping patterns**: Σε reviews, ψάξτε για `copy_to_user` / `write` κλήσεις ολόκληρων structs, ή `memcpy`/`send` του stack data όπου μόνο μέρος του struct έχει ρυθμιστεί. Δώστε ιδιαίτερη προσοχή σε error paths όπου η initialization παραλείπεται.

## ARM64 Example

Αυτό δεν αλλάζει καθόλου σε ARM64 καθώς και οι local variables διαχειρίζονται επίσης στο stack, μπορείτε [**check this example**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) were this is shown.



## References

- [CONFIG_INIT_STACK_ALL_PATTERN documentation](https://www.kernelconfig.io/config_init_stack_all_pattern)
- [GHSL-2024-197: GStreamer uninitialized stack variable leading to function pointer overwrite](https://securitylab.github.com/advisories/GHSL-2024-197_GStreamer/)
{{#include ../../banners/hacktricks-training.md}}
