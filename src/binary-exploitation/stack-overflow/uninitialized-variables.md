# Uninitialized Variables

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

यहाँ का मुख्य विचार यह है कि **अनियोजित चर के साथ क्या होता है क्योंकि उनके पास पहले से आवंटित मेमोरी में जो मान था, वही होगा।** उदाहरण:

- **Function 1: `initializeVariable`**: हम एक चर `x` घोषित करते हैं और इसे एक मान सौंपते हैं, मान लीजिए `0x1234`। यह क्रिया मेमोरी में एक स्थान आरक्षित करने और उसमें एक विशिष्ट मान रखने के समान है।
- **Function 2: `useUninitializedVariable`**: यहाँ, हम एक और चर `y` घोषित करते हैं लेकिन इसे कोई मान नहीं सौंपते। C में, अनियोजित चर स्वचालित रूप से शून्य पर सेट नहीं होते। इसके बजाय, वे अपनी मेमोरी स्थान पर अंतिम बार संग्रहीत मान को बनाए रखते हैं।

जब हम इन दोनों कार्यों को **क्रमिक रूप से** चलाते हैं:

1. `initializeVariable` में, `x` को एक मान (`0x1234`) सौंपा जाता है, जो एक विशिष्ट मेमोरी पते पर कब्जा करता है।
2. `useUninitializedVariable` में, `y` घोषित किया जाता है लेकिन इसे कोई मान नहीं सौंपा जाता, इसलिए यह `x` के ठीक बाद का मेमोरी स्थान ले लेता है। `y` को अनियोजित छोड़ने के कारण, यह `x` द्वारा उपयोग किए गए उसी मेमोरी स्थान से मान "विरासत में" ले लेता है, क्योंकि वही अंतिम मान था जो वहाँ था।

यह व्यवहार निम्न-स्तरीय प्रोग्रामिंग में एक प्रमुख अवधारणा को दर्शाता है: **मेमोरी प्रबंधन महत्वपूर्ण है**, और अनियोजित चर अप्रत्याशित व्यवहार या सुरक्षा कमजोरियों का कारण बन सकते हैं, क्योंकि वे अनजाने में मेमोरी में छोड़े गए संवेदनशील डेटा को रख सकते हैं।

अनियोजित स्टैक चर कई सुरक्षा जोखिम पैदा कर सकते हैं जैसे:

- **Data Leakage**: संवेदनशील जानकारी जैसे पासवर्ड, एन्क्रिप्शन कुंजी, या व्यक्तिगत विवरण अनियोजित चर में संग्रहीत होने पर उजागर हो सकते हैं, जिससे हमलावरों को संभावित रूप से इस डेटा को पढ़ने की अनुमति मिलती है।
- **Information Disclosure**: अनियोजित चर की सामग्री कार्यक्रम की मेमोरी लेआउट या आंतरिक संचालन के बारे में विवरण प्रकट कर सकती है, जिससे हमलावरों को लक्षित शोषण विकसित करने में मदद मिलती है।
- **Crashes and Instability**: अनियोजित चर से संबंधित संचालन अपरिभाषित व्यवहार का परिणाम हो सकते हैं, जिससे कार्यक्रम क्रैश या अप्रत्याशित परिणाम हो सकते हैं।
- **Arbitrary Code Execution**: कुछ परिदृश्यों में, हमलावर इन कमजोरियों का लाभ उठाकर कार्यक्रम के निष्पादन प्रवाह को बदल सकते हैं, जिससे उन्हें मनमाने कोड को निष्पादित करने की अनुमति मिलती है, जिसमें दूरस्थ कोड निष्पादन खतरों को शामिल किया जा सकता है।

### Example
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### यह कैसे काम करता है:

- **`initializeAndPrint` फ़ंक्शन**: यह फ़ंक्शन एक पूर्णांक चर `initializedVar` घोषित करता है, इसे `100` का मान सौंपता है, और फिर चर के मेमोरी पते और मान को प्रिंट करता है। यह कदम सीधा है और दिखाता है कि एक प्रारंभिक चर कैसे व्यवहार करता है।
- **`demonstrateUninitializedVar` फ़ंक्शन**: इस फ़ंक्शन में, हम एक पूर्णांक चर `uninitializedVar` घोषित करते हैं बिना इसे प्रारंभ किए। जब हम इसके मान को प्रिंट करने का प्रयास करते हैं, तो आउटपुट एक यादृच्छिक संख्या दिखा सकता है। यह संख्या उस मेमोरी स्थान पर पहले से मौजूद डेटा का प्रतिनिधित्व करती है। वातावरण और संकलक के आधार पर, वास्तविक आउटपुट भिन्न हो सकता है, और कभी-कभी, सुरक्षा के लिए, कुछ संकलक स्वचालित रूप से चर को शून्य पर प्रारंभ कर सकते हैं, हालांकि इस पर भरोसा नहीं किया जाना चाहिए।
- **`main` फ़ंक्शन**: `main` फ़ंक्शन उपरोक्त दोनों फ़ंक्शनों को अनुक्रम में कॉल करता है, एक प्रारंभिक चर और एक अप्रारंभिक चर के बीच का अंतर प्रदर्शित करता है।

## ARM64 उदाहरण

यह ARM64 में बिल्कुल नहीं बदलता है क्योंकि स्थानीय चर भी स्टैक में प्रबंधित होते हैं, आप [**इस उदाहरण की जांच कर सकते हैं**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) जहाँ यह दिखाया गया है।

{{#include ../../banners/hacktricks-training.md}}
