# Variables non initialisées

{{#include ../../banners/hacktricks-training.md}}

## Informations de base

L'idée principale ici est de comprendre ce qui se passe avec **les variables non initialisées : elles auront la valeur qui se trouvait déjà dans la zone mémoire qui leur est assignée.** Exemple :

- **Function 1: `initializeVariable`**: Nous déclarons une variable `x` et lui attribuons une valeur, par exemple `0x1234`. Cette action revient à réserver un emplacement en mémoire et y stocker une valeur précise.
- **Function 2: `useUninitializedVariable`**: Ici, nous déclarons une autre variable `y` sans lui attribuer de valeur. En C, les variables non initialisées ne sont pas automatiquement mises à zéro. Elles conservent plutôt la dernière valeur qui était stockée à leur emplacement mémoire.

Lorsque nous exécutons ces deux fonctions **séquentiellement** :

1. Dans `initializeVariable`, `x` se voit assigner une valeur (`0x1234`), qui occupe une adresse mémoire précise.
2. Dans `useUninitializedVariable`, `y` est déclarée mais non initialisée ; elle prend donc l'emplacement mémoire juste après `x`. Du fait de ne pas initialiser `y`, elle finit par « hériter » de la valeur qui se trouvait à cet emplacement mémoire utilisé par `x`, car c'était la dernière valeur écrite.

Ce comportement illustre un concept clé en programmation bas niveau : **la gestion de la mémoire est cruciale**, et les variables non initialisées peuvent conduire à un comportement imprévisible ou à des vulnérabilités de sécurité, car elles peuvent contenir involontairement des données sensibles restées en mémoire.

Les variables non initialisées sur le stack peuvent présenter plusieurs risques de sécurité, tels que :

- **Data Leakage**: Les informations sensibles comme les mots de passe, clés de chiffrement ou données personnelles peuvent être exposées si elles résident dans des variables non initialisées, permettant à des attaquants de potentiellement lire ces données.
- **Information Disclosure**: Le contenu des variables non initialisées peut révéler des informations sur la disposition mémoire du programme ou son fonctionnement interne, aidant les attaquants à développer des exploits ciblés.
- **Crashes and Instability**: Les opérations impliquant des variables non initialisées peuvent provoquer un comportement indéfini, entraînant des plantages ou des résultats imprévisibles.
- **Arbitrary Code Execution**: Dans certains scénarios, des attaquants pourraient exploiter ces vulnérabilités pour altérer le flux d'exécution du programme, leur permettant d'exécuter du code arbitraire, ce qui peut inclure des menaces d'exécution de code à distance.

### Exemple
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Comment cela fonctionne :

- **`initializeAndPrint` Function** : Cette fonction déclare une variable entière `initializedVar`, lui assigne la valeur `100`, puis affiche à la fois l'adresse mémoire et la valeur de la variable. Cette étape est simple et montre comment se comporte une variable initialisée.
- **`demonstrateUninitializedVar` Function** : Dans cette fonction, on déclare une variable entière `uninitializedVar` sans l'initialiser. Lorsqu'on tente d'afficher sa valeur, la sortie peut afficher un nombre aléatoire. Ce nombre représente les données qui se trouvaient précédemment à cet emplacement mémoire. Selon l'environnement et le compilateur, la sortie réelle peut varier, et parfois, par sécurité, certains compilateurs peuvent initialiser automatiquement les variables à zéro, bien qu'on ne doive pas s'y fier.
- **`main` Function** : La fonction `main` appelle les deux fonctions ci‑dessus en séquence, démontrant le contraste entre une variable initialisée et une variable non initialisée.

## Schémas d'exploitation pratiques (2024–2025)

Le bogue classique de "read-before-write" reste pertinent car les mitigations modernes (ASLR, canaries) reposent souvent sur le secret. Surfaces d'attaque typiques :

- **Partially initialized structs copied to userland** : Kernel ou drivers font fréquemment un `memset` uniquement sur un champ de longueur puis `copy_to_user(&u, &local_struct, sizeof(local_struct))`. Le padding et les champs inutilisés leak des moitiés de stack canary, des saved frame pointers ou des kernel pointers. Si le struct contient un function pointer, le laisser non initialisé peut aussi permettre une **controlled overwrite** lorsqu'il est réutilisé.
- **Uninitialized stack buffers reused as indexes/lengths** : Un `size_t len;` non initialisé utilisé pour borner `read(fd, buf, len)` peut donner aux attaquants des lectures/écritures out-of-bounds ou permettre de contourner les vérifications de taille quand la case de la pile contient encore une grande valeur d'un appel précédent.
- **Compiler-added padding** : Même lorsque les membres individuels sont initialisés, les octets de padding implicites entre eux ne le sont pas. Copier l'intégralité du struct vers userland leak le padding qui contient souvent du contenu de pile antérieur (canaries, pointers).
- **ROP/Canary disclosure** : Si une fonction copie un struct local vers stdout pour le debugging, le padding non initialisé peut révéler le stack canary, permettant une exploitation de stack overflow ultérieure sans brute-force.

Minimal PoC pattern to detect such issues during review:
```c
struct msg {
char data[0x20];
uint32_t len;
};

ssize_t handler(int fd) {
struct msg m;              // never fully initialized
m.len = read(fd, m.data, sizeof(m.data));
// later debug helper
write(1, &m, sizeof(m));   // leaks padding + stale stack
return m.len;
}
```
## Mitigations & compiler options (à garder à l'esprit lors du contournement)

- **Clang/GCC auto-init**: Recent toolchains expose `-ftrivial-auto-var-init=zero` or `-ftrivial-auto-var-init=pattern`, filling *every* automatic (stack) variable at function entry with zeros or a poison pattern (0xAA / 0xFE). Cela ferme la plupart des info leaks d'uninitialized-stack et rend l'exploitation plus difficile en convertissant les secrets en valeurs connues.
- **Linux kernel hardening**: Kernels built with `CONFIG_INIT_STACK_ALL` or the newer `CONFIG_INIT_STACK_ALL_PATTERN` zero/pattern-initialize every stack slot at function entry, wiping canaries/pointers that would otherwise leak. Recherchez des distros livrant des kernels Clang-built avec ces options activées (courant dans les hardening configs 6.8+).
- **Opt-out attributes**: Clang now allows `__attribute__((uninitialized))` on specific locals/structs to keep performance-critical areas uninitialized even when global auto-init is enabled. Examinez ces annotations attentivement — elles marquent souvent une surface d'attaque délibérée pour les side channels.

Du point de vue d'un attaquant, savoir si le binaire a été compilé avec ces flags détermine si les primitives de stack-leak sont viables ou si vous devez pivoter vers des heap/data-section disclosures.

## Trouver rapidement des uninitialized-stack bugs

- **Compiler diagnostics**: Build with `-Wall -Wextra -Wuninitialized` (GCC/Clang). For C++ code, `clang-tidy -checks=cppcoreguidelines-init-variables` will auto-fix many cases to zero-init and is handy to spot missed locals during audit.
- **Dynamic tools**: `-fsanitize=memory` (MSan) in Clang or Valgrind's `--track-origins=yes` reliably flag reads of uninitialized stack bytes during fuzzing. Instrument test harnesses with these to surface subtle padding leaks.
- **Grepping patterns**: In reviews, search for `copy_to_user` / `write` calls of whole structs, or `memcpy`/`send` of stack data where only part of the struct is set. Pay special attention to error paths where initialization is skipped.

## Exemple ARM64

Rien ne change sur ARM64 : les variables locales sont également gérées sur le stack ; vous pouvez [**check this example**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) où ceci est montré.



## Références

- [CONFIG_INIT_STACK_ALL_PATTERN documentation](https://www.kernelconfig.io/config_init_stack_all_pattern)
- [GHSL-2024-197: GStreamer uninitialized stack variable leading to function pointer overwrite](https://securitylab.github.com/advisories/GHSL-2024-197_GStreamer/)
{{#include ../../banners/hacktricks-training.md}}
