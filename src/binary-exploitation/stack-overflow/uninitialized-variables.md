# Variáveis não inicializadas

{{#include ../../banners/hacktricks-training.md}}

## Informações Básicas

A ideia principal aqui é entender o que acontece com **variáveis não inicializadas, pois elas terão o valor que já estava na memória atribuída a elas.** Exemplo:

- **Function 1: `initializeVariable`**: Declaramos uma variável `x` e atribuímos a ela um valor, digamos `0x1234`. Esta ação é semelhante a reservar um espaço na memória e colocar um valor específico nele.
- **Function 2: `useUninitializedVariable`**: Aqui, declaramos outra variável `y` mas não atribuímos nenhum valor a ela. Em C, variáveis não inicializadas não são automaticamente definidas como zero. Em vez disso, elas retêm o último valor armazenado na localização de memória.

Quando executamos essas duas funções **sequencialmente**:

1. Em `initializeVariable`, `x` recebe um valor (`0x1234`), que ocupa um endereço de memória específico.
2. Em `useUninitializedVariable`, `y` é declarada mas não recebe um valor, então ocupa o espaço de memória imediatamente após `x`. Por não inicializar `y`, ela acaba “herdando” o valor da mesma localização de memória usada por `x`, porque esse foi o último valor que esteve ali.

Esse comportamento ilustra um conceito-chave em programação de baixo nível: **o gerenciamento de memória é crucial**, e variáveis não inicializadas podem levar a comportamentos imprevisíveis ou vulnerabilidades de segurança, pois podem, involuntariamente, conter dados sensíveis deixados na memória.

Variáveis não inicializadas na pilha podem representar vários riscos de segurança, como:

- **Data Leakage**: Informações sensíveis, como senhas, chaves de criptografia ou dados pessoais, podem ser expostas se armazenadas em variáveis não inicializadas, permitindo que atacantes potencialmente leiam esses dados.
- **Information Disclosure**: O conteúdo de variáveis não inicializadas pode revelar detalhes sobre o layout da memória do programa ou operações internas, ajudando atacantes a desenvolver exploits direcionados.
- **Falhas e Instabilidade**: Operações envolvendo variáveis não inicializadas podem resultar em comportamento indefinido, levando a travamentos do programa ou resultados imprevisíveis.
- **Arbitrary Code Execution**: Em certos cenários, atacantes poderiam explorar essas vulnerabilidades para alterar o fluxo de execução do programa, permitindo-lhes executar código arbitrário, o que pode incluir ameaças de execução remota de código.

### Exemplo
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Como isso funciona:

- **`initializeAndPrint` Função**: Esta função declara uma variável inteira `initializedVar`, atribui a ela o valor `100`, e então imprime tanto o endereço de memória quanto o valor da variável. Esta etapa é direta e mostra como uma variável inicializada se comporta.
- **`demonstrateUninitializedVar` Função**: Nesta função, declaramos uma variável inteira `uninitializedVar` sem inicializá-la. Ao tentar imprimir seu valor, a saída pode mostrar um número aleatório. Esse número representa quaisquer dados que estavam previamente naquela localização de memória. Dependendo do ambiente e do compilador, a saída real pode variar, e às vezes, por segurança, alguns compiladores podem inicializar automaticamente variáveis para zero, embora isso não deva ser confiável.
- **`main` Função**: A função `main` chama ambas as funções acima em sequência, demonstrando o contraste entre uma variável inicializada e uma não inicializada.

## Padrões práticos de exploração (2024–2025)

The classic "read-before-write" bug remains relevant because modern mitigations (ASLR, canaries) often rely on secrecy. Typical attack surfaces:

- **Partially initialized structs copied to userland**: Kernel or drivers frequently `memset` only a length field and then `copy_to_user(&u, &local_struct, sizeof(local_struct))`. Padding and unused fields leak stack canary halves, saved frame pointers or kernel pointers. If the struct contains a function pointer, leaving it uninitialized may also allow **controlled overwrite** when later reused.
- **Uninitialized stack buffers reused as indexes/lengths**: An uninitialized `size_t len;` used to bound `read(fd, buf, len)` may give attackers out-of-bounds reads/writes or allow bypassing size checks when the stack slot still contains a large value from a prior call.
- **Compiler-added padding**: Even when individual members are initialized, implicit padding bytes between them are not. Copying the whole struct to userland leaks padding that often contains prior stack content (canaries, pointers).
- **ROP/Canary disclosure**: If a function copies a local struct to stdout for debugging, uninitialized padding can reveal the stack canary enabling subsequent stack overflow exploitation without brute-force.

Minimal PoC pattern to detect such issues during review:
```c
struct msg {
char data[0x20];
uint32_t len;
};

ssize_t handler(int fd) {
struct msg m;              // never fully initialized
m.len = read(fd, m.data, sizeof(m.data));
// later debug helper
write(1, &m, sizeof(m));   // leaks padding + stale stack
return m.len;
}
```
## Mitigações & opções do compilador (tenha em mente ao contornar)

- **Clang/GCC auto-init**: Toolchains recentes expõem `-ftrivial-auto-var-init=zero` ou `-ftrivial-auto-var-init=pattern`, preenchendo *toda* variável automática (stack) na entrada da função com zeros ou um padrão de poison (0xAA / 0xFE). Isso fecha a maioria dos uninitialized-stack info leaks e torna a exploração mais difícil ao converter segredos em valores conhecidos.
- **Linux kernel hardening**: Kernels compilados com `CONFIG_INIT_STACK_ALL` ou o mais novo `CONFIG_INIT_STACK_ALL_PATTERN` inicializam com zero/padrão cada slot da stack na entrada da função, apagando canaries/pointers que, de outra forma, iriam leak. Procure distros que entreguem kernels buildados com Clang com essas opções ativadas (comum em configs de hardening 6.8+).
- **Opt-out attributes**: Clang agora permite `__attribute__((uninitialized))` em locals/structs específicos para manter áreas críticas de desempenho não inicializadas mesmo quando o auto-init global está habilitado. Revise essas anotações cuidadosamente—elas frequentemente marcam surface de ataque deliberada para side channels.

Do ponto de vista de um atacante, saber se o binário foi construído com essas flags determina se stack-leak primitives são viáveis ou se é necessário pivotar para heap/data-section disclosures.

## Encontrando bugs uninitialized-stack rapidamente

- **Compiler diagnostics**: Compile com `-Wall -Wextra -Wuninitialized` (GCC/Clang). Para código C++, `clang-tidy -checks=cppcoreguidelines-init-variables` auto-corrige muitos casos para zero-init e é útil para identificar locals esquecidos durante uma auditoria.
- **Dynamic tools**: `-fsanitize=memory` (MSan) no Clang ou o Valgrind com `--track-origins=yes` sinalizam de forma confiável leituras de bytes de stack não inicializados durante fuzzing. Instrumente harnesses de teste com essas ferramentas para expor leaks sutis em padding.
- **Grepping patterns**: Em reviews, procure por chamadas `copy_to_user` / `write` de estruturas inteiras, ou `memcpy`/`send` de dados da stack onde apenas parte da struct foi preenchida. Preste atenção especial a caminhos de erro onde a inicialização é pulada.

## Exemplo ARM64

Isso não muda nada no ARM64, pois variáveis locais também são gerenciadas na stack; você pode [**check this example**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) onde isso é mostrado.

## Referências

- [CONFIG_INIT_STACK_ALL_PATTERN documentation](https://www.kernelconfig.io/config_init_stack_all_pattern)
- [GHSL-2024-197: GStreamer uninitialized stack variable leading to function pointer overwrite](https://securitylab.github.com/advisories/GHSL-2024-197_GStreamer/)
{{#include ../../banners/hacktricks-training.md}}
