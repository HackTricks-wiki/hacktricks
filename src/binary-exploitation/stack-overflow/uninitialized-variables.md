# Neinicijalizovane promenljive

{{#include ../../banners/hacktricks-training.md}}

## Osnovne informacije

Suština ovde je da se razume šta se dešava sa **neinicijalizovanim promenljivama jer će one imati vrednost koja je već bila u dodeljenoj memoriji.** Primer:

- **Function 1: `initializeVariable`**: Deklarišemo promenljivu `x` i dodelimo joj vrednost, recimo `0x1234`. Ova akcija je slična rezervisanju mesta u memoriji i postavljanju određene vrednosti u njega.
- **Function 2: `useUninitializedVariable`**: Ovde deklarišemo drugu promenljivu `y`, ali joj ne dodeljujemo vrednost. U C-u, neinicijalizovane promenljive se automatski ne postavljaju na nulu. Umesto toga, zadržavaju vrednost koja je poslednja bila upisana na njihovoj memorijskoj lokaciji.

Kada pokrenemo ove dve funkcije **uzastopno**:

1. U `initializeVariable`, `x` dobija vrednost (`0x1234`), koja zauzima određenu memorijsku adresu.
2. U `useUninitializedVariable`, `y` je deklarisan ali mu nije dodeljena vrednost, pa zauzima memorijsko mesto neposredno posle `x`. Zbog toga što `y` nije inicijalizovan, on "nasleđuje" vrednost sa iste memorijske lokacije koju je prethodno koristio `x`, jer je to poslednja vrednost koja je tamo bila.

Ovo ponašanje ilustruje ključni koncept u programiranju niskog nivoa: **upravljanje memorijom je od suštinskog značaja**, i neinicijalizovane promenljive mogu dovesti do nepredvidivog ponašanja ili bezbednosnih ranjivosti, jer nenamerno mogu čuvati osetljive podatke koji su ostali u memoriji.

Neinicijalizovane promenljive na steku mogu predstavljati nekoliko bezbednosnih rizika, kao što su:

- Data Leakage: Osetljive informacije kao što su lozinke, enkripcioni ključevi ili lični podaci mogu biti izloženi ako su smešteni u neinicijalizovanim promenljivama, dopuštajući napadačima potencijalno da pročitaju te podatke.
- Otkrivanje informacija: Sadržaj neinicijalizovanih promenljivih može otkriti detalje o rasporedu memorije programa ili unutrašnjim operacijama, pomažući napadačima da razviju ciljane exploit-e.
- Padovi i nestabilnost: Operacije koje uključuju neinicijalizovane promenljive mogu rezultirati nedefinisanим ponašanjem, dovodeći do padova programa ili nepredvidivih ishoda.
- Arbitrary Code Execution: U određenim scenarijima, napadači bi mogli iskoristiti ove ranjivosti da izmene tok izvršavanja programa, omogućavajući im da izvrše arbitrary code, što može uključivati i remote code execution pretnje.

### Primer
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Kako ovo radi:

- **`initializeAndPrint` Function**: Ova funkcija deklariše integer promenljivu `initializedVar`, dodeljuje joj vrednost `100`, i potom ispisuje i adresu memorije i vrednost promenljive. Ovaj korak je jednostavan i pokazuje kako se ponaša inicijalizovana promenljiva.
- **`demonstrateUninitializedVar` Function**: U ovoj funkciji deklarišemo integer promenljivu `uninitializedVar` bez inicijalizacije. Kada pokušamo da ispišemo njenu vrednost, izlaz može prikazati nasumičan broj. Taj broj predstavlja podatke koji su prethodno bili na toj lokaciji memorije. U zavisnosti od okruženja i kompajlera, stvarni izlaz može varirati, i ponekad, iz bezbednosnih razloga, neki kompajleri automatski inicijalizuju promenljive na nulu, mada se na to ne treba oslanjati.
- **`main` Function**: Funkcija `main` poziva obe prethodne funkcije uzastopno, demonstrirajući kontrast između inicijalizovane i neinicijalizovane promenljive.

## Praktični obrasci eksploatacije (2024–2025)

Klasican "read-before-write" bug ostaje relevantan jer moderni mitigations (ASLR, canaries) često zavise od tajnosti. Tipične površine napada:

- **Partially initialized structs copied to userland**: Kernel or drivers frequently `memset` only a length field and then `copy_to_user(&u, &local_struct, sizeof(local_struct))`. Padding i neiskorišćena polja leak polovinu stack canary-a, sačuvane frame pointer-e ili kernel pointer-e. Ako struktura sadrži function pointer, ostavljanje neinicijalizovanog polja može takođe dozvoliti **controlled overwrite** kada se kasnije ponovo iskoristi.
- **Uninitialized stack buffers reused as indexes/lengths**: An uninitialized `size_t len;` used to bound `read(fd, buf, len)` may give attackers out-of-bounds reads/writes or allow bypassing size checks when the stack slot still contains a large value from a prior call.
- **Compiler-added padding**: Čak i kada su pojedinačni članovi inicijalizovani, implicitni padding bajtovi između njih nisu. Kopiranje cele strukture u userland leak padding koji često sadrži prethodni sadržaj stack-a (canaries, pointers).
- **ROP/Canary disclosure**: Ako funkcija kopira lokalnu strukturu na stdout za debugging, neinicijalizovani padding može otkriti stack canary i omogućiti naknadnu eksploataciju stack overflow-a bez brute-force.

Minimalni PoC obrazac za otkrivanje ovakvih problema tokom pregleda:
```c
struct msg {
char data[0x20];
uint32_t len;
};

ssize_t handler(int fd) {
struct msg m;              // never fully initialized
m.len = read(fd, m.data, sizeof(m.data));
// later debug helper
write(1, &m, sizeof(m));   // leaks padding + stale stack
return m.len;
}
```
## Ublažavanja & opcije kompajlera (imajte na umu prilikom zaobilaženja)

- **Clang/GCC auto-init**: Noviji toolchains izlažu `-ftrivial-auto-var-init=zero` ili `-ftrivial-auto-var-init=pattern`, popunjavajući *svaku* automatsku (stack) promenljivu na ulazu funkcije nulama ili poison pattern-om (0xAA / 0xFE). Ovo zatvara većinu uninitialized-stack info leaks i otežava exploitovanje pretvaranjem tajni u poznate vrednosti.
- **Linux kernel hardening**: Kerneli izgrađeni sa `CONFIG_INIT_STACK_ALL` ili novijim `CONFIG_INIT_STACK_ALL_PATTERN` nula/obrascem inicijalizuju svaki stack slot pri ulazu u funkciju, brišući canaries/pointers koji bi inače leak-ovali. Potražite distre koje isporučuju Clang-built kernels sa ovim opcijama omogućenim (češće u 6.8+ hardening konfiguracijama).
- **Opt-out attributes**: Clang sada dopušta `__attribute__((uninitialized))` na specifičnim locals/structs da bi zadržao performance-critical oblasti neinicijalizovanim čak i kada je global auto-init omogućen. Pažljivo pregledajte takve anotacije — često označavaju namerni attack surface za side channels.

Iz perspektive napadača, znanje da li je binary izgrađen sa ovim flagovima određuje da li su stack-leak primitives izvodljive ili morate pivotirati na heap/data-section disclosures.

## Brzo pronalaženje uninitialized-stack bugova

- **Compiler diagnostics**: Kompajlirajte sa `-Wall -Wextra -Wuninitialized` (GCC/Clang). Za C++ kod, `clang-tidy -checks=cppcoreguidelines-init-variables` će automatski popraviti mnoge slučajeve na zero-init i korisno je za uočavanje propuštenih lokala tokom audita.
- **Dynamic tools**: `-fsanitize=memory` (MSan) u Clang-u ili Valgrind-ov `--track-origins=yes` pouzdano označavaju čitanja neinicijalizovanih bajtova steka tokom fuzzinga. Instrumentujte test harness-e ovim alatima da otkrijete suptilne padding leaks.
- **Grepping patterns**: U pregledima tražite `copy_to_user` / `write` pozive celih struct-ova, ili `memcpy`/`send` stack podataka gde je samo deo struct-a postavljen. Obratite posebnu pažnju na error paths gde se inicijalizacija preskače.

## ARM64 Example

Ovo se uopšte ne menja na ARM64 pošto su lokalne promenljive takođe upravljane na steku, možete [**check this example**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) were this is shown.



## References

- [CONFIG_INIT_STACK_ALL_PATTERN documentation](https://www.kernelconfig.io/config_init_stack_all_pattern)
- [GHSL-2024-197: GStreamer uninitialized stack variable leading to function pointer overwrite](https://securitylab.github.com/advisories/GHSL-2024-197_GStreamer/)
{{#include ../../banners/hacktricks-training.md}}
