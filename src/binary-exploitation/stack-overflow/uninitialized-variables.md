# Variables sin inicializar

{{#include ../../banners/hacktricks-training.md}}

## Información básica

La idea principal aquí es entender qué ocurre con las **variables sin inicializar, ya que tendrán el valor que ya estaba en la memoria asignada para ellas.** Ejemplo:

- **Función 1: `initializeVariable`**: Declaramos una variable `x` y le asignamos un valor, digamos `0x1234`. Esta acción es similar a reservar un espacio en memoria y colocar un valor específico en él.
- **Función 2: `useUninitializedVariable`**: Aquí declaramos otra variable `y` pero no le asignamos ningún valor. En `C`, las variables sin inicializar no se ponen a cero automáticamente. En su lugar, conservan el valor que se almacenó por última vez en su ubicación de memoria.

Cuando ejecutamos estas dos funciones de forma **secuencial**:

1. En `initializeVariable`, `x` se le asigna un valor (`0x1234`), que ocupa una dirección de memoria específica.
2. En `useUninitializedVariable`, `y` se declara pero no se le asigna un valor, por lo que ocupa el espacio de memoria inmediatamente posterior a `x`. Al no inicializar `y`, termina "heredando" el valor de la misma ubicación de memoria que usó `x`, porque ese es el último valor que allí quedó.

Este comportamiento ilustra un concepto clave en la programación a bajo nivel: **La gestión de memoria es crucial**, y las variables sin inicializar pueden causar comportamientos impredecibles o vulnerabilidades de seguridad, ya que pueden contener involuntariamente datos sensibles residuales en memoria.

Las variables de stack sin inicializar pueden plantear varios riesgos de seguridad, como:

- **Data Leakage**: Información sensible como contraseñas, claves de cifrado o datos personales puede quedar expuesta si se almacenan en variables sin inicializar, permitiendo que atacantes posiblemente lean esos datos.
- **Information Disclosure**: El contenido de variables sin inicializar podría revelar detalles sobre la disposición de memoria del programa u operaciones internas, ayudando a atacantes a desarrollar exploits dirigidos.
- **Crashes and Instability**: Operaciones que impliquen variables sin inicializar pueden provocar comportamiento indefinido, causando caídas del programa o resultados impredecibles.
- **Arbitrary Code Execution**: En ciertos escenarios, atacantes podrían explotar estas vulnerabilidades para alterar el flujo de ejecución del programa, permitiéndoles ejecutar código arbitrario, lo que podría incluir amenazas de ejecución remota de código.

### Ejemplo
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Cómo funciona:

- **`initializeAndPrint` Function**: Esta función declara una variable entera `initializedVar`, le asigna el valor `100` y luego imprime tanto la dirección de memoria como el valor de la variable. Este paso es directo y muestra cómo se comporta una variable inicializada.
- **`demonstrateUninitializedVar` Function**: En esta función declaramos una variable entera `uninitializedVar` sin inicializarla. Cuando intentamos imprimir su valor, la salida puede mostrar un número aleatorio. Ese número representa los datos que previamente estaban en esa ubicación de memoria. Dependiendo del entorno y del compilador, la salida real puede variar, y a veces, por seguridad, algunos compiladores pueden inicializar automáticamente las variables a cero; sin embargo, no se debe confiar en ello.
- **`main` Function**: La función `main` llama a ambas funciones anteriores en secuencia, demostrando el contraste entre una variable inicializada y una no inicializada.

## Patrones de explotación prácticos (2024–2025)

El clásico bug "read-before-write" sigue siendo relevante porque las mitigaciones modernas (ASLR, canaries) a menudo dependen del secreto. Superficies de ataque típicas:

- **Partially initialized structs copied to userland**: El kernel o los drivers frecuentemente `memset` solo un campo de longitud y luego `copy_to_user(&u, &local_struct, sizeof(local_struct))`. El padding y los campos sin usar leak mitades del stack canary, saved frame pointers o kernel pointers. Si el struct contiene un function pointer, dejarlo sin inicializar también puede permitir un **controlled overwrite** cuando se reutilice más tarde.
- **Uninitialized stack buffers reused as indexes/lengths**: Un `size_t len;` sin inicializar usado para acotar `read(fd, buf, len)` puede dar a los atacantes lecturas/escrituras out-of-bounds o permitir eludir las comprobaciones de tamaño cuando la ranura de la pila todavía contiene un valor grande de una llamada anterior.
- **Compiler-added padding**: Incluso cuando los miembros individuales están inicializados, los bytes de padding implícitos entre ellos no lo están. Copiar todo el struct a userland leaks padding que a menudo contiene contenido previo de la stack (canaries, pointers).
- **ROP/Canary disclosure**: Si una función copia un struct local a stdout para depuración, el padding sin inicializar puede revelar el stack canary, permitiendo la explotación posterior de un stack overflow sin fuerza bruta.

Minimal PoC pattern to detect such issues during review:
```c
struct msg {
char data[0x20];
uint32_t len;
};

ssize_t handler(int fd) {
struct msg m;              // never fully initialized
m.len = read(fd, m.data, sizeof(m.data));
// later debug helper
write(1, &m, sizeof(m));   // leaks padding + stale stack
return m.len;
}
```
## Mitigaciones & compiler options (keep in mind when bypassing)

- **Clang/GCC auto-init**: Recent toolchains expose `-ftrivial-auto-var-init=zero` or `-ftrivial-auto-var-init=pattern`, filling *every* automatic (stack) variable at function entry with zeros or a poison pattern (0xAA / 0xFE). Esto cierra la mayoría de los uninitialized-stack info leaks y hace la explotación más difícil al convertir secretos en valores conocidos.
- **Linux kernel hardening**: Kernels built with `CONFIG_INIT_STACK_ALL` or the newer `CONFIG_INIT_STACK_ALL_PATTERN` zero/pattern-initialize every stack slot at function entry, wiping canaries/pointers that would otherwise leak. Busca distros que distribuyan Clang-built kernels con estas opciones habilitadas (común en 6.8+ hardening configs).
- **Opt-out attributes**: Clang now allows `__attribute__((uninitialized))` on specific locals/structs to keep performance-critical areas uninitialized even when global auto-init is enabled. Revisa esas anotaciones cuidadosamente—a menudo marcan superficie de ataque deliberada para side channels.

From an attacker perspective, knowing whether the binary was built with these flags determines if stack-leak primitives are viable or if you must pivot to heap/data-section disclosures.

## Finding uninitialized-stack bugs quickly

- **Compiler diagnostics**: Build with `-Wall -Wextra -Wuninitialized` (GCC/Clang). For C++ code, `clang-tidy -checks=cppcoreguidelines-init-variables` will auto-fix many cases to zero-init and is handy to spot missed locals during audit.
- **Dynamic tools**: `-fsanitize=memory` (MSan) in Clang or Valgrind's `--track-origins=yes` reliably flag reads of uninitialized stack bytes during fuzzing. Instrument test harnesses with these to surface subtle padding leaks.
- **Grepping patterns**: In reviews, search for `copy_to_user` / `write` calls of whole structs, or `memcpy`/`send` of stack data where only part of the struct is set. Pay special attention to error paths where initialization is skipped.

## ARM64 Example

Esto no cambia en absoluto en ARM64, ya que las variables locales también se gestionan en el stack; puedes [**revisar este ejemplo**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) donde se muestra esto.



## References

- [CONFIG_INIT_STACK_ALL_PATTERN documentation](https://www.kernelconfig.io/config_init_stack_all_pattern)
- [GHSL-2024-197: GStreamer uninitialized stack variable leading to function pointer overwrite](https://securitylab.github.com/advisories/GHSL-2024-197_GStreamer/)
{{#include ../../banners/hacktricks-training.md}}
