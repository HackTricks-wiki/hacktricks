# Variables Zisizoanzishwa

{{#include ../../banners/hacktricks-training.md}}

## Taarifa za Msingi

Wazo kuu hapa ni kuelewa kinachotokea na **variables zisizoanzishwa kwani zitakuwa na thamani iliyokuwepo tayari kwenye kumbukumbu iliyotengwa kwao.** Mfano:

- **Function 1: `initializeVariable`**: Tunatangaza variable `x` na kuipa thamani, kwa mfano `0x1234`. Kitendo hiki ni sawa na kutenga sehemu katika kumbukumbu na kuweka thamani maalumu ndani yake.
- **Function 2: `useUninitializedVariable`**: Hapa, tunatangaza variable nyingine `y` lakini hatuipe thamani. Katika C, variables zisizoanzishwa hazipangiwi kuwa zero kwa ajili yao; badala yake, zinabaki na thamani iliyohifadhiwa mara ya mwisho katika eneo lao la kumbukumbu.

Tukiendesha hizi kazi mbili **mfululizo**:

1. Katika `initializeVariable`, `x` anapewa thamani (`0x1234`), ambayo inachukua anwani maalumu ya kumbukumbu.
2. Katika `useUninitializedVariable`, `y` yaletangazwa lakini hakuwa na thamani, hivyo inachukua nafasi ya kumbukumbu mara baada ya `x`. Kwa kutokuwa imeanzishwa `y`, inabaki "kurithi" thamani kutoka eneo lile lile la kumbukumbu lililotumika na `x`, kwa sababu ndilo lilikuwa na thamani ya mwisho.

Tabia hii inaonyesha wazo muhimu katika programu za kiwango cha chini: **uendeshaji wa kumbukumbu ni muhimu**, na variables zisizoanzishwa zinaweza kusababisha tabia zisizotarajiwa au udhaifu wa usalama, kwani zinaweza kwa bahati mbaya kuhifadhi data nyeti iliyobaki katika kumbukumbu.

Variables za stack zisizoanzishwa zinaweza kuleta hatari kadhaa za usalama kama:

- **Data Leakage**: Taarifa nyeti kama nywila, funguo za encryption, au taarifa binafsi zinaweza kufichuka ikiwa zimo kwenye variables zisizoanzishwa, kuruhusu watapeli kusoma data hiyo.
- **Information Disclosure**: Yaliyomo katika variables zisizoanzishwa yanaweza kufichua maelezo ya mpangilio wa kumbukumbu ya programu au jinsi inavyoendeshwa kwa ndani, zikimsaidia mtapeli kuendeleza exploits zilizolengwa.
- **Crashes and Instability**: Operesheni zinazohusisha variables zisizoanzishwa zinaweza kusababisha tabia isiyoeleweka, ikielekea kwenye kuanguka kwa programu au matokeo yasiyotabirika.
- **Arbitrary Code Execution**: Katika baadhi ya matukio, watapeli wanaweza kutumia udhaifu huu kubadilisha mtiririko wa utekelezaji wa programu, kuwaruhusu kutekeleza code yoyote, ambayo inaweza kujumuisha tishio la remote code execution.

### Mfano
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Jinsi Hii Inavyofanya Kazi:

- **`initializeAndPrint` Function**: Kazi hii inatangaza variable ya integer `initializedVar`, inampa thamani `100`, kisha inachapisha anwani ya kumbukumbu pamoja na thamani ya variable. Hatua hii ni rahisi na inaonyesha jinsi variable iliyoinitialize inavyofanya kazi.
- **`demonstrateUninitializedVar` Function**: Katika function hii, tunatangaza variable ya integer `uninitializedVar` bila kui-initialize. Tunapojaribu kuchapisha thamani yake, matokeo yanaweza kuonyesha nambari ya bahati nasibu. Nambari hiyo inawakilisha data yoyote iliyokuwepo hapo kabla katika eneo hilo la kumbukumbu. Kutegemea mazingira na compiler, matokeo halisi yanaweza kutofautiana, na wakati mwingine, kwa usalama, baadhi ya compilers zinaweza moja kwa moja ku-initialize variables kwa zeru—hata hivyo haifai kuitegemea.
- **`main` Function**: `main` inaita functions hizo mbili kwa mfululizo, ikionyesha utofauti kati ya variable iliyoinitialize na isiyo-initialize.

## Mifumo ya exploitation ya vitendo (2024–2025)

Ududu wa kawaida wa "read-before-write" bado una umuhimu kwa sababu mitigations za kisasa (ASLR, canaries) mara nyingi zinategemea usiri. Nyuso za kawaida za mashambulizi:

- **Structs zilizoinitialize kwa sehemu zinazokopwa kwenda userland**: Kernel au drivers mara nyingi `memset` tu shamba la urefu kisha `copy_to_user(&u, &local_struct, sizeof(local_struct))`. Padding na fields zisizotumika leak halves za stack canary, saved frame pointers au kernel pointers. Ikiwa struct ina function pointer, kuiacha bila initialize pia kunaweza kuruhusu **controlled overwrite** wakati itakapotumiwa tena.
- **Uninitialized stack buffers reused as indexes/lengths**: `size_t len;` isiyokuwa initialized inayotumika kuwa kikomo cha `read(fd, buf, len)` inaweza kuwapa attackers read/write nje ya mipaka au kuruhusu kupitisha checks za ukubwa wakati stack slot bado ina thamani kubwa kutoka kwa wito uliopita.
- **Compiler-added padding**: Hata wakati wanachama binafsi wame-initialize, implicit padding bytes kati yao hazijatiliwa. Kunakili struct nzima kwenda userland kunalea leak ya padding ambayo mara nyingi ina yaliyokuwepo kwenye stack kabla (canaries, pointers).
- **ROP/Canary disclosure**: Ikiwa function inakopia local struct kwenda stdout kwa debugging, padding isiyokuwa initialized inaweza kufichua stack canary na kuruhusu subsequent stack overflow exploitation bila brute-force.

Minimal PoC pattern ya kugundua matatizo kama haya wakati wa ukaguzi:
```c
struct msg {
char data[0x20];
uint32_t len;
};

ssize_t handler(int fd) {
struct msg m;              // never fully initialized
m.len = read(fd, m.data, sizeof(m.data));
// later debug helper
write(1, &m, sizeof(m));   // leaks padding + stale stack
return m.len;
}
```
## Mitigations & compiler options (zingatia wakati wa kuzipitisha)

- **Clang/GCC auto-init**: Toolchains za karibuni zinaonyesha `-ftrivial-auto-var-init=zero` au `-ftrivial-auto-var-init=pattern`, zikijaza *kila* automatic (stack) variable mwanzoni mwa function na zeros au pattern ya sumu (0xAA / 0xFE). Hii inazuia nyingi za uninitialized-stack info leak na kufanya exploitation kuwa ngumu kwa kugeuza siri kuwa thamani zinazojulikana.
- **Linux kernel hardening**: Kernels zilizojengwa na `CONFIG_INIT_STACK_ALL` au mpya `CONFIG_INIT_STACK_ALL_PATTERN` zinafanya zero/pattern-initialize kila slot ya stack mwanzoni mwa function, zikifuta canaries/pointers ambazo vingeleak vinginevyo. Tafuta distros zinazotuma kernels zilizojengwa na Clang zilizo na chaguo hizi zikiwa zimeshawashwa (zipo mara nyingi katika hardening configs 6.8+).
- **Opt-out attributes**: Clang sasa inaruhusu `__attribute__((uninitialized))` kwenye locals/structs maalum ili kuweka maeneo muhimu kwa performance wasiopangwa hata wakati global auto-init imewezeshwa. Kagua maelezo hayo kwa makini—mara nyingi huashiria uso wa shambulio uliokusudiwa kwa side channels.

Kutoka kwa mtazamo wa mshambulizi, kujua ikiwa binary ilijengwa na flags hizi kunamua kama stack-leak primitives zinafaa au kama lazima uhamie kwa ufichuzi wa heap/data-section.

## Finding uninitialized-stack bugs quickly

- **Compiler diagnostics**: Build na `-Wall -Wextra -Wuninitialized` (GCC/Clang). Kwa C++ code, `clang-tidy -checks=cppcoreguidelines-init-variables` ita-auto-fix kesi nyingi kwa zero-init na ni zana nzuri za kubaini locals zilizokosewa wakati wa audit.
- **Dynamic tools**: `-fsanitize=memory` (MSan) in Clang au Valgrind's `--track-origins=yes` hutoa alama kwa usomaji wa bytes za uninitialized stack kwa wakati wa fuzzing. Instrument test harnesses na hizi ili kuibua subtle padding leaks.
- **Grepping patterns**: Katika reviews, tafuta wito za `copy_to_user` / `write` za structs nzima, au `memcpy`/`send` za data ya stack ambapo sehemu tu ya struct imewekwa. Toa umakini maalum kwa error paths ambapo initialization imepitishwa.

## ARM64 Example

Hili halibadiliki kabisa kwenye ARM64 kwani local variables pia zinadhibitiwa kwenye stack; unaweza [**check this example**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) ambapo hili linaonyeshwa.



## References

- [CONFIG_INIT_STACK_ALL_PATTERN documentation](https://www.kernelconfig.io/config_init_stack_all_pattern)
- [GHSL-2024-197: GStreamer uninitialized stack variable leading to function pointer overwrite](https://securitylab.github.com/advisories/GHSL-2024-197_GStreamer/)
{{#include ../../banners/hacktricks-training.md}}
