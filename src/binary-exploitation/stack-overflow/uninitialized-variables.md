# Niezainicjowane Zmienne

{{#include ../../banners/hacktricks-training.md}}

## Podstawowe Informacje

Główna idea polega na zrozumieniu, co się dzieje z **niezainicjowanymi zmiennymi, ponieważ będą miały wartość, która już znajdowała się w przydzielonej pamięci.** Przykład:

- **Funkcja 1: `initializeVariable`**: Deklarujemy zmienną `x` i przypisujemy jej wartość, powiedzmy `0x1234`. Ta akcja jest podobna do zarezerwowania miejsca w pamięci i umieszczenia w nim konkretnej wartości.
- **Funkcja 2: `useUninitializedVariable`**: Tutaj deklarujemy inną zmienną `y`, ale nie przypisujemy jej żadnej wartości. W C, niezainicjowane zmienne nie są automatycznie ustawiane na zero. Zamiast tego, zachowują ostatnią wartość, która była przechowywana w ich lokalizacji pamięci.

Kiedy uruchamiamy te dwie funkcje **sekwencyjnie**:

1. W `initializeVariable`, `x` otrzymuje wartość (`0x1234`), która zajmuje określony adres pamięci.
2. W `useUninitializedVariable`, `y` jest zadeklarowane, ale nie przypisano mu wartości, więc zajmuje miejsce w pamięci tuż po `x`. Z powodu braku inicjalizacji `y`, kończy się na "odziedziczeniu" wartości z tej samej lokalizacji pamięci, która była używana przez `x`, ponieważ to była ostatnia wartość, która tam była.

To zachowanie ilustruje kluczową koncepcję w programowaniu niskopoziomowym: **Zarządzanie pamięcią jest kluczowe**, a niezainicjowane zmienne mogą prowadzić do nieprzewidywalnego zachowania lub luk w zabezpieczeniach, ponieważ mogą niezamierzenie przechowywać wrażliwe dane pozostawione w pamięci.

Niezainicjowane zmienne stosu mogą stwarzać kilka zagrożeń bezpieczeństwa, takich jak:

- **Wycieki Danych**: Wrażliwe informacje, takie jak hasła, klucze szyfrowania lub dane osobowe, mogą być ujawnione, jeśli są przechowywane w niezainicjowanych zmiennych, co pozwala atakującym na potencjalne odczytanie tych danych.
- **Ujawnienie Informacji**: Zawartość niezainicjowanych zmiennych może ujawniać szczegóły dotyczące układu pamięci programu lub wewnętrznych operacji, co pomaga atakującym w opracowywaniu ukierunkowanych exploitów.
- **Awaria i Niestabilność**: Operacje związane z niezainicjowanymi zmiennymi mogą prowadzić do nieokreślonego zachowania, co skutkuje awariami programu lub nieprzewidywalnymi wynikami.
- **Wykonanie Arbitralnego Kodu**: W niektórych scenariuszach, atakujący mogą wykorzystać te luki, aby zmienić przepływ wykonania programu, co umożliwia im wykonanie arbitralnego kodu, co może obejmować zagrożenia związane z zdalnym wykonaniem kodu.

### Przykład
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Jak to działa:

- **`initializeAndPrint` Function**: Ta funkcja deklaruje zmienną całkowitą `initializedVar`, przypisuje jej wartość `100`, a następnie drukuje zarówno adres pamięci, jak i wartość zmiennej. Ten krok jest prosty i pokazuje, jak zachowuje się zainicjowana zmienna.
- **`demonstrateUninitializedVar` Function**: W tej funkcji deklarujemy zmienną całkowitą `uninitializedVar` bez jej inicjalizacji. Gdy próbujemy wydrukować jej wartość, wynik może pokazać losową liczbę. Ta liczba reprezentuje dane, które wcześniej znajdowały się w tej lokalizacji pamięci. W zależności od środowiska i kompilatora, rzeczywisty wynik może się różnić, a czasami, dla bezpieczeństwa, niektóre kompilatory mogą automatycznie inicjalizować zmienne do zera, chociaż na tym nie należy polegać.
- **`main` Function**: Funkcja `main` wywołuje obie powyższe funkcje w kolejności, demonstrując kontrast między zainicjowaną zmienną a niezainicjowaną.

## Przykład ARM64

To w ogóle się nie zmienia w ARM64, ponieważ zmienne lokalne są również zarządzane na stosie, możesz [**sprawdzić ten przykład**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/), gdzie to jest pokazane.

{{#include ../../banners/hacktricks-training.md}}
