# Niezainicjalizowane zmienne

{{#include ../../banners/hacktricks-training.md}}

## Podstawowe informacje

Główną ideą jest zrozumienie, co dzieje się z **niezainicjalizowanymi zmiennymi — będą one zawierać wartość, która już znajdowała się w przydzielonym im obszarze pamięci.** Przykład:

- **Function 1: `initializeVariable`**: Deklarujemy zmienną `x` i przypisujemy jej wartość, powiedzmy `0x1234`. To działanie jest podobne do zarezerwowania miejsca w pamięci i umieszczenia w nim konkretnej wartości.
- **Function 2: `useUninitializedVariable`**: Tutaj deklarujemy inną zmienną `y`, ale nie przypisujemy jej żadnej wartości. W C niezainicjalizowane zmienne nie są automatycznie ustawiane na zero. Zamiast tego zachowują wartość, która ostatnio była zapisana w ich lokalizacji pamięci.

Kiedy uruchomimy te dwie funkcje **sekwencyjnie**:

1. W `initializeVariable` `x` otrzymuje wartość (`0x1234`), która zajmuje konkretny adres pamięci.
2. W `useUninitializedVariable` `y` jest deklarowana, ale nie przypisywana, więc zajmuje miejsce w pamięci tuż po `x`. Ponieważ `y` nie została zainicjalizowana, kończy „dziedziczyć” wartość z tej samej lokalizacji pamięci używanej przez `x`, ponieważ to była ostatnia wartość tam zapisana.

To zachowanie ilustruje kluczową koncepcję programowania niskopoziomowego: **zarządzanie pamięcią jest kluczowe**, a niezainicjalizowane zmienne mogą prowadzić do nieprzewidywalnego zachowania lub luk bezpieczeństwa, ponieważ mogą niezamierzenie przechowywać wrażliwe dane pozostawione w pamięci.

Niezainicjalizowane zmienne na stosie mogą stwarzać następujące zagrożenia bezpieczeństwa:

- **Wycieki danych**: Poufne informacje, takie jak hasła, klucze szyfrowania czy dane osobowe, mogą zostać ujawnione, jeśli znajdują się w niezainicjalizowanych zmiennych, pozwalając atakującym na ich odczyt.
- **Ujawnienie informacji**: Zawartość niezainicjalizowanych zmiennych może ujawnić szczegóły dotyczące układu pamięci programu lub jego wewnętrznych operacji, ułatwiając atakującym opracowanie sprecyzowanych exploitów.
- **Awarie i niestabilność**: Operacje z użyciem niezainicjalizowanych zmiennych mogą skutkować niezdefiniowanym zachowaniem, prowadząc do awarii programu lub nieprzewidywalnych wyników.
- **Wykonanie dowolnego kodu**: W niektórych scenariuszach atakujący mogą wykorzystać te luki do zmiany przepływu wykonania programu, umożliwiając wykonanie dowolnego kodu, co może obejmować zagrożenia związane ze zdalnym wykonaniem kodu.

### Przykład
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Jak to działa:

- **`initializeAndPrint` Function**: Ta funkcja deklaruje zmienną całkowitą `initializedVar`, przypisuje jej wartość `100`, a następnie wypisuje zarówno adres pamięci, jak i wartość zmiennej. Ten krok jest prosty i pokazuje, jak zachowuje się zainicjalizowana zmienna.
- **`demonstrateUninitializedVar` Function**: W tej funkcji deklarujemy zmienną całkowitą `uninitializedVar` bez jej inicjalizacji. Gdy spróbujemy wypisać jej wartość, wyjście może pokazać losową liczbę. Ta liczba reprezentuje dane, które wcześniej znajdowały się w tej lokalizacji pamięci. W zależności od środowiska i kompilatora rzeczywisty wynik może się różnić, a czasem, ze względów bezpieczeństwa, niektóre kompilatory mogą automatycznie inicjalizować zmienne zerem — na to jednak nie należy polegać.
- **`main` Function**: Funkcja `main` wywołuje obie powyższe funkcje kolejno, demonstrując kontrast między zmienną zainicjalizowaną a niezainicjalizowaną.

## Practical exploitation patterns (2024–2025)

Klasyczny "read-before-write" bug pozostaje istotny, ponieważ nowoczesne mechanizmy łagodzące (ASLR, canaries) często opierają się na poufności. Typowe powierzchnie ataku:

- **Partially initialized structs copied to userland**: Kernel lub sterowniki często wywołują `memset` tylko na polu długości, a następnie `copy_to_user(&u, &local_struct, sizeof(local_struct))`. Bajty paddingu i nieużywane pola mogą leak połowy stack canary, zapisane frame pointers lub kernel pointers. Jeśli struct zawiera function pointer, pozostawienie go niezainicjalizowanego może również umożliwić **controlled overwrite** przy późniejszym ponownym użyciu.
- **Uninitialized stack buffers reused as indexes/lengths**: Niezainicjalizowany `size_t len;` użyty do ograniczenia `read(fd, buf, len)` może dać atakującym odczyty/zapisy poza zakresem lub pozwolić na obejście kontroli rozmiaru, gdy slot na stosie wciąż zawiera dużą wartość z poprzedniego wywołania.
- **Compiler-added padding**: Nawet gdy poszczególne pola są zainicjalizowane, bajty paddingu między nimi nie są. Skopiowanie całego struct do userland powoduje leak paddingu, który często zawiera zawartość stosu z wcześniejszych wywołań (canaries, wskaźniki).
- **ROP/Canary disclosure**: Jeśli funkcja kopiuje lokalny struct do stdout w celach debugowania, niezainicjalizowany padding może ujawnić stack canary, umożliwiając późniejszą stack overflow exploitation bez brute-force.

Minimalny wzorzec PoC do wykrywania takich problemów podczas przeglądu:
```c
struct msg {
char data[0x20];
uint32_t len;
};

ssize_t handler(int fd) {
struct msg m;              // never fully initialized
m.len = read(fd, m.data, sizeof(m.data));
// later debug helper
write(1, &m, sizeof(m));   // leaks padding + stale stack
return m.len;
}
```
## Łagodzenia i opcje kompilatora (pamiętaj przy omijaniu)

- **Clang/GCC auto-init**: Nowsze toolchainy udostępniają `-ftrivial-auto-var-init=zero` lub `-ftrivial-auto-var-init=pattern`, wypełniając *wszystkie* automatyczne (stack) zmienne przy wejściu do funkcji zerami lub patternem-poison (0xAA / 0xFE). To zamyka większość uninitialized-stack info leaks i utrudnia eksploatację, zamieniając sekrety na znane wartości.
- **Linux kernel hardening**: Kernels zbudowane z `CONFIG_INIT_STACK_ALL` lub nowszym `CONFIG_INIT_STACK_ALL_PATTERN` zerują/wypełniają patternem każdy slot na stacku przy wejściu do funkcji, nadpisując canaries/pointers, które w przeciwnym razie mogłyby wyciekać. Szukaj dystrybucji wysyłających kernele zbudowane Clangiem z tymi opcjami włączonymi (powszechne w konfiguracjach hardening 6.8+).
- **Opt-out attributes**: Clang pozwala teraz na `__attribute__((uninitialized))` dla konkretnych lokalnych zmiennych/struktur, aby utrzymać obszary krytyczne dla wydajności niezainicjalizowane nawet gdy globalne auto-init jest włączone. Dokładnie przejrzyj takie adnotacje — często oznaczają celowo wystawioną powierzchnię ataku dla side channels.

Z perspektywy atakującego, znajomość tego, czy binarka była zbudowana z tymi flagami, determinuje, czy stack-leak primitives są możliwe, czy też musisz przełączyć się na ujawnienia heap/data-section.

## Znajdowanie uninitialized-stack bugów szybko

- **Compiler diagnostics**: Kompiluj z `-Wall -Wextra -Wuninitialized` (GCC/Clang). Dla kodu C++, `clang-tidy -checks=cppcoreguidelines-init-variables` automatycznie naprawi wiele przypadków do zero-init i jest użyteczny do wyłapania pominiętych lokalnych zmiennych podczas audytu.
- **Dynamic tools**: `-fsanitize=memory` (MSan) w Clang lub Valgrind z `--track-origins=yes` wiarygodnie sygnalizują odczyty niezainicjalizowanych bajtów ze stacku podczas fuzzingu. Instrumentuj harnessy testowe tymi narzędziami, aby wydobyć subtelne padding leaks.
- **Grepping patterns**: W przeglądach szukaj wywołań `copy_to_user` / `write` kopiujących całe struktury, albo `memcpy`/`send` danych ze stacku, gdzie tylko część struktury jest ustawiona. Zwróć szczególną uwagę na ścieżki błędów, gdzie inicjalizacja jest pomijana.

## Przykład ARM64

To w ogóle się nie zmienia na ARM64, ponieważ zmienne lokalne też są trzymane na stacku — możesz [**check this example**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) gdzie to jest pokazane.



## References

- [CONFIG_INIT_STACK_ALL_PATTERN documentation](https://www.kernelconfig.io/config_init_stack_all_pattern)
- [GHSL-2024-197: GStreamer uninitialized stack variable leading to function pointer overwrite](https://securitylab.github.com/advisories/GHSL-2024-197_GStreamer/)
{{#include ../../banners/hacktricks-training.md}}
