# 未初期化変数

{{#include ../../banners/hacktricks-training.md}}

## 基本情報

ここでの核心的な考え方は、**未初期化変数は割り当てられたメモリに既に存在していた値を持つことになる、という挙動を理解すること**です。例：

- **Function 1: `initializeVariable`**: 変数 `x` を宣言して値（例：`0x1234`）を代入します。これはメモリ上の領域を確保して特定の値をそこに置く行為に相当します。
- **Function 2: `useUninitializedVariable`**: ここでは別の変数 `y` を宣言しますが、値を代入しません。C では未初期化変数が自動的にゼロになることはなく、そのメモリ位置に最後に格納されていた値を保持します。

これらの二つの関数を**順番に**実行すると：

1. `initializeVariable` で `x` に値（`0x1234`）が代入され、特定のメモリアドレスを占有します。
2. `useUninitializedVariable` で `y` を宣言しますが値を代入しないため、`x` の直後のメモリ位置を使うことになります。`y` を初期化していないため、その位置に最後に存在していた `x` の値を「受け継ぐ」ことになります。

この挙動は低レベルプログラミングの重要な概念を示しています：**メモリ管理は極めて重要であり、未初期化変数は予測不能な挙動やセキュリティ上の脆弱性を引き起こす可能性がある**ということです。未初期化のままのスタック変数は以下のようなセキュリティリスクをもたらすことがあります：

- **Data Leakage**: パスワード、暗号キー、個人情報などの機密情報が未初期化変数に残っていると露出し、攻撃者がこれらのデータを読み取れる可能性があります。
- **Information Disclosure**: 未初期化変数の内容がプログラムのメモリレイアウトや内部動作の詳細を明らかにし、攻撃者が標的型のエクスプロイトを作成する助けになることがあります。
- **Crashes and Instability**: 未初期化変数を使った操作は未定義動作を引き起こし、プログラムのクラッシュや予測不能な結果を招くことがあります。
- **Arbitrary Code Execution**: 特定の状況では、攻撃者がこれらの脆弱性を悪用してプログラムの実行フローを変更し、任意のコード実行（リモートコード実行を含む）を可能にすることがあります。

### 例
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### 仕組み:

- **`initializeAndPrint` Function**: この関数は整数変数`initializedVar`を宣言し、値を`100`に設定してから、変数のメモリアドレスと値の両方を出力します。このステップは単純で、初期化された変数がどのように振る舞うかを示します。
- **`demonstrateUninitializedVar` Function**: この関数では整数変数`uninitializedVar`を初期化せずに宣言します。その値を出力しようとすると、出力はランダムな数値を示すことがあります。これはそのメモリ位置に以前あったデータを表します。環境やコンパイラによって実際の出力は変わる可能性があり、安全のために一部のコンパイラが変数を自動的にゼロで初期化する場合もありますが、これは当てにすべきではありません。
- **`main` Function**: `main`関数は上記2つの関数を順に呼び出し、初期化済みの変数と未初期化の変数の対比を示します。

## 実践的な悪用パターン (2024–2025)

古典的な "read-before-write" バグは依然として重要です。なぜなら現代の緩和策 (ASLR, canaries) はしばしば秘匿性に依存しているからです。典型的な攻撃面:

- **Partially initialized structs copied to userland**: カーネルやドライバはしばしば長さフィールドだけを `memset` し、次に `copy_to_user(&u, &local_struct, sizeof(local_struct))` を行います。パディングや未使用フィールドは stack canary halves、saved frame pointers、または kernel pointers を leak します。もし struct が関数ポインタを含む場合、未初期化のままにしておくと再利用時に **controlled overwrite** を許してしまう可能性もあります。
- **Uninitialized stack buffers reused as indexes/lengths**: 未初期化の `size_t len;` が `read(fd, buf, len)` の境界値として使われると、攻撃者に範囲外の読み/書きや、以前の呼び出しでスタックスロットに大きな値が残っているときにサイズチェックのバイパスを可能にすることがあります。
- **Compiler-added padding**: 個々のメンバーが初期化されていても、それらの間の暗黙的なパディングバイトは初期化されません。構造体全体を userland にコピーすると、しばしば以前のスタック内容（canaries、pointers）を含むパディングが leak します。
- **ROP/Canary disclosure**: もし関数がデバッグのためにローカルの struct を stdout にコピーすると、未初期化のパディングが stack canary を露出させ、それにより総当たりなしでその後のスタックオーバーフローの悪用を可能にします。

Minimal PoC pattern to detect such issues during review:
```c
struct msg {
char data[0x20];
uint32_t len;
};

ssize_t handler(int fd) {
struct msg m;              // never fully initialized
m.len = read(fd, m.data, sizeof(m.data));
// later debug helper
write(1, &m, sizeof(m));   // leaks padding + stale stack
return m.len;
}
```
## 緩和策とコンパイラオプション（バイパスを試みる際の注意点）

- **Clang/GCC auto-init**: Recent toolchains expose `-ftrivial-auto-var-init=zero` or `-ftrivial-auto-var-init=pattern`、関数開始時にすべての自動（スタック）変数をゼロまたは毒パターン（0xAA / 0xFE）で埋めます。これによりほとんどの未初期化スタックのinfo leaksが防がれ、秘密が既知の値に変換されることでエクスプロイトが困難になります。
- **Linux kernel hardening**: `CONFIG_INIT_STACK_ALL` または新しい `CONFIG_INIT_STACK_ALL_PATTERN` でビルドされたカーネルは、関数開始時にスタックのすべてのスロットをゼロ／パターン初期化し、そうでなければ leak するであろう canaries/pointers を消去します。これらのオプションを有効にしてClangでビルドされたカーネルを配布しているディストリを探してください（6.8+ の hardening 設定で一般的）。
- **Opt-out attributes**: Clangは現在、特定のローカル/構造体に対して `__attribute__((uninitialized))` を許可し、global auto-init が有効でもパフォーマンスクリティカルな領域を未初期化のままにできます。そのような注釈は慎重に確認してください — 多くの場合、side channels に対する意図的な攻撃面を示します。

攻撃者の観点では、バイナリがこれらのフラグでビルドされているかを知ることが、stack-leak primitives が使えるか、または heap/data-section disclosures に軸足を移す必要があるかを決定します。

## 未初期化スタックバグを素早く見つける方法

- **Compiler diagnostics**: `-Wall -Wextra -Wuninitialized` (GCC/Clang) でビルドしてください。C++ コードでは `clang-tidy -checks=cppcoreguidelines-init-variables` が多くの場合を自動で zero-init に修正し、監査中に見落とされたローカルを見つけるのに便利です。
- **Dynamic tools**: Clang の `-fsanitize=memory` (MSan) や Valgrind の `--track-origins=yes` は、ファジング中に未初期化のスタックバイトの読み取りを確実に検出します。テストハーネスにこれらを組み込んで、微妙なパディングのleaksを顕在化させてください。
- **Grepping patterns**: レビューでは、全構造体を対象とした `copy_to_user` / `write` 呼び出し、あるいは構造体の一部しか設定されていないのに `memcpy`/`send` でスタックデータを送っている箇所を検索してください。初期化がスキップされるエラーパスに特に注意を払ってください。

## ARM64 Example

ARM64でもローカル変数はスタック上で管理されるため、状況はまったく変わりません。これは[**check this example**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/)で示されています。



## References

- [CONFIG_INIT_STACK_ALL_PATTERN documentation](https://www.kernelconfig.io/config_init_stack_all_pattern)
- [GHSL-2024-197: GStreamer uninitialized stack variable leading to function pointer overwrite](https://securitylab.github.com/advisories/GHSL-2024-197_GStreamer/)
{{#include ../../banners/hacktricks-training.md}}
