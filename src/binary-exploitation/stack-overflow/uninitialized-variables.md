# Ongeïnitialiseerde Veranderlikes

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

Die kernidee hier is om te verstaan wat gebeur met **ongeïnitialiseerde veranderlikes, want hulle sal die waarde hê wat reeds in die aan hulle toegewysde geheue was.** Voorbeeld:

- **Function 1: `initializeVariable`**: Ons verklaar 'n veranderlike `x` en ken dit 'n waarde toe, sê `0x1234`. Hierdie aksie is soortgelyk aan om 'n plekkie in geheue te reserveer en 'n spesifieke waarde daarin te plaas.
- **Function 2: `useUninitializedVariable`**: Hier verklaar ons nog 'n veranderlike `y` maar ken geen waarde daaraan toe nie. In C word ongeïnitialiseerde veranderlikes nie outomaties na nul gestel nie. In plaas daarvan behou hulle watter waarde ook al laas by hul geheueplek gestoor is.

Wanneer ons hierdie twee funksies **opvolgend** uitvoer:

1. In `initializeVariable` word `x` 'n waarde toegewys (`0x1234`), wat 'n spesifieke geheueadres beset.
2. In `useUninitializedVariable` word `y` verklaar maar geen waarde daaraan toegewys nie, so neem dit die geheueplek direk ná `x` in. Omdat `y` nie geïnitialiseer is nie, eindig dit daarmee dat dit die waarde "erf" vanaf dieselfde geheueplek wat deur `x` gebruik is, omdat dit die laaste waarde daar was.

Hierdie gedrag illustreer 'n sleutelkonsep in laagvlak programmering: **geheuebestuur is kritiek**, en ongeïnitialiseerde veranderlikes kan lei tot onvoorspelbare gedrag of sekuriteitskwesbaarhede, aangesien hulle per ongeluk sensitiewe data wat in geheue agtergelaat is, kan bevat.

Ongeïnitialiseerde stack veranderlikes kan verskeie sekuriteitsrisiko's inhou soos:

- **Data Leakage**: Sensitiewe inligting soos wagwoorde, enkripsiesleutels of persoonlike besonderhede kan blootgestel word as dit in ongeïnitialiseerde veranderlikes gestoor is, wat aanvallers moontlik in staat stel om hierdie data te lees.
- **Information Disclosure**: Die inhoud van ongeïnitialiseerde veranderlikes kan besonderhede oor die program se geheue-indeling of interne werking openbaar, wat aanvallers help om gerigte exploits te ontwikkel.
- **Crashes and Instability**: Operasies wat ongeïnitialiseerde veranderlikes betrek kan tot ongedefinieerde gedrag lei, wat programkrasse of onvoorspelbare uitkomste tot gevolg kan hê.
- **Arbitrary Code Execution**: In sekere scenario's kan aanvallers hierdie kwesbaarhede misbruik om die program se uitvoervloei te verander, waardeur hulle arbitraire kode kan uitvoer, wat moontlik remote code execution threats kan insluit.

### Voorbeeld
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Hoe Dit Werk:

- **`initializeAndPrint` Function**: Hierdie funksie verklaar 'n heelgetal-variabele `initializedVar`, ken dit die waarde `100` toe, en druk dan beide die geheueadres en die waarde van die veranderlike uit. Hierdie stap is reguit en toon hoe 'n initialized veranderlike optree.
- **`demonstrateUninitializedVar` Function**: In hierdie funksie verklaar ons 'n heelgetal-variabele `uninitializedVar` sonder om dit te initialiseer. Wanneer ons probeer om sy waarde te druk, kan die uitset 'n ewekansige getal toon. Hierdie getal verteenwoordig watter data ook al voorheen by daardie geheueplek was. Afhangend van die omgewing en die compiler, kan die werklike uitset wissel, en soms kan sommige compilers uit veiligheid veranderlikes outomaties op nul initialiseer, al moet daar nie op staatgemaak word nie.
- **`main` Function**: Die `main` funksie roep beide bogenoemde funksies in volgorde aan, en demonstreer die kontras tussen 'n geïnisialiseerde veranderlike en 'n nie-geïnisialiseerde een.

## Praktiese exploitation patterns (2024–2025)

Die klassieke "read-before-write" fout bly relevant omdat moderne mitigations (ASLR, canaries) dikwels op geheimhouding staatmaak. Tipiese aanvalsvlakke:

- **Partially initialized structs copied to userland**: Kernel of drivers doen dikwels `memset` slegs op 'n lengte-veld en dan `copy_to_user(&u, &local_struct, sizeof(local_struct))`. Padding en ongebruikte velde leak stack canary halves, saved frame pointers of kernel pointers. As die struct 'n function pointer bevat, kan dit ongeïnisialiseerd agterlaat ook **controlled overwrite** toelaat wanneer dit later hergebruik word.
- **Uninitialized stack buffers reused as indexes/lengths**: 'n Uninitialized `size_t len;` wat gebruik word om `read(fd, buf, len)` te begrens, kan aanvallers out-of-bounds reads/writes gee of toelaat om groottekontroles te omseil wanneer die stack slot nog 'n groot waarde van 'n vorige oproep bevat.
- **Compiler-added padding**: Selfs wanneer individuele lede geïnitialiseer is, word die implisiete padding-bytes tussen hulle nie geïnitialiseer nie. Om die hele struct na userland te kopieer lek padding wat dikwels vorige stack-inhoud bevat (canaries, pointers).
- **ROP/Canary disclosure**: As 'n funksie 'n plaaslike struct na stdout kopieer vir debugging, kan uninitialized padding die stack canary openbaar maak en gevolglike stack overflow exploitation moontlik maak sonder brute-force.

Minimale PoC-patroon om sulke kwessies tydens hersiening op te spoor:
```c
struct msg {
char data[0x20];
uint32_t len;
};

ssize_t handler(int fd) {
struct msg m;              // never fully initialized
m.len = read(fd, m.data, sizeof(m.data));
// later debug helper
write(1, &m, sizeof(m));   // leaks padding + stale stack
return m.len;
}
```
## Mitigeringe & compiler-opsies (hou in gedagte wanneer jy dit omseil)

- **Clang/GCC auto-init**: Recent toolchains expose `-ftrivial-auto-var-init=zero` or `-ftrivial-auto-var-init=pattern`, filling *every* automatic (stack) variable at function entry with zeros or a poison pattern (0xAA / 0xFE). Dit sluit die meeste uninitialized-stack info leaks en maak exploitation moeiliker deur geheime in bekende waardes om te sit.
- **Linux kernel hardening**: Kernels built with `CONFIG_INIT_STACK_ALL` or the newer `CONFIG_INIT_STACK_ALL_PATTERN` zero/pattern-initialize every stack slot at function entry, wiping canaries/pointers that would otherwise leak. Soek na distros wat Clang-built kernels met hierdie opsies geaktiveer lewer (algemeen in 6.8+ hardening configs).
- **Opt-out attributes**: Clang now allows `__attribute__((uninitialized))` on specific locals/structs to keep performance-critical areas uninitialized even when global auto-init is enabled. Hersien sulke annotasies noukeurig — hulle merk dikwels 'n doelbewuste aanvalsvlak vir side channels.

Van 'n attacker-perspektief bepaal die kennis of die binary met hierdie flags gebou is of stack-leak primitives lewensvatbaar is of dat jy na heap/data-section disclosures moet pivot.

## Vind uninitialized-stack bugs vinnig

- **Compiler diagnostics**: Bou met `-Wall -Wextra -Wuninitialized` (GCC/Clang). Vir C++ kode, `clang-tidy -checks=cppcoreguidelines-init-variables` sal baie gevalle outomaties na zero-init herstel en is handig om gemiste locals tydens 'n audit op te spoor.
- **Dynamic tools**: `-fsanitize=memory` (MSan) in Clang or Valgrind's `--track-origins=yes` merk betroubaar lees van uninitialized stack bytes tydens fuzzing. Instrumenteer test harnesses met hierdie om subtiele padding leaks te openbaar.
- **Grepping patterns**: In resensies, soek na `copy_to_user` / `write` calls of whole structs, or `memcpy`/`send` of stack data where only part of the struct is set. Gee besondere aandag aan foutpade waar initialisering oorgeslaan word.

## ARM64 Voorbeeld

Dit verander glad nie op ARM64 nie aangesien local variables ook in die stack bestuur word; jy kan [**kyk na hierdie voorbeeld**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) waar dit getoon word.



## Verwysings

- [CONFIG_INIT_STACK_ALL_PATTERN documentation](https://www.kernelconfig.io/config_init_stack_all_pattern)
- [GHSL-2024-197: GStreamer uninitialized stack variable leading to function pointer overwrite](https://securitylab.github.com/advisories/GHSL-2024-197_GStreamer/)
{{#include ../../banners/hacktricks-training.md}}
