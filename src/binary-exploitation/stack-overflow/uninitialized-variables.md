# Неініціалізовані змінні

{{#include ../../banners/hacktricks-training.md}}

## Основна інформація

Суть полягає в тому, щоб зрозуміти, що відбувається з **неініціалізованими змінними, оскільки вони матимуть значення, яке вже було в призначеній їм пам'яті.** Приклад:

- **Function 1: `initializeVariable`**: Ми оголошуємо змінну `x` і присвоюємо їй значення, наприклад `0x1234`. Ця дія подібна до резервування місця в пам'яті та запису в нього конкретного значення.
- **Function 2: `useUninitializedVariable`**: Тут ми оголошуємо іншу змінну `y`, але не присвоюємо їй жодного значення. У C неініціалізовані змінні автоматично не встановлюються в нуль. Натомість вони зберігають те значення, яке останнім було записане за цією адресою пам'яті.

Коли ми виконуємо ці дві функції **послідовно**:

1. У `initializeVariable` змінній `x` присвоюється значення (`0x1234`), яке займає певну адресу пам'яті.
2. У `useUninitializedVariable` оголошується `y`, але їй не присвоюється значення, тому вона займає місце в пам'яті одразу після `x`. Через відсутність ініціалізації `y` вона врешті «успадковує» значення з тієї самої локації пам'яті, яке залишилося там від `x`.

Ця поведінка ілюструє ключову концепцію у низькорівневому програмуванні: **керування пам'яттю є критично важливим**, і неініціалізовані змінні можуть призводити до непередбачуваної поведінки чи вразливостей безпеки, оскільки вони можуть ненавмисно містити чутливі дані, що залишилися в пам'яті.

Неініціалізовані змінні в стеку можуть становити кілька ризиків для безпеки, таких як:

- **Data Leakage**: Чутлива інформація, така як паролі, ключі шифрування або персональні дані, може бути виявлена, якщо зберігається в неініціалізованих змінних, що дозволяє атакуючим потенційно прочитати ці дані.
- **Information Disclosure**: Вміст неініціалізованих змінних може розкрити деталі про розміщення пам'яті програми або її внутрішні операції, допомагаючи атакуючим розробляти спрямовані експлойти.
- **Crashes and Instability**: Операції з неініціалізованими змінними можуть спричинити невизначену поведінку, що призводить до падінь програми або непередбачуваних результатів.
- **Arbitrary Code Execution**: У певних сценаріях атакуючі можуть використати ці вразливості, щоб змінити хід виконання програми, що дозволяє виконувати довільний код, включно з загрозами віддаленого виконання коду.

### Приклад
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Як це працює:

- **`initializeAndPrint` Функція**: Ця функція оголошує цілу змінну `initializedVar`, присвоює їй значення `100`, а потім виводить як адресу пам'яті, так і значення змінної. Цей крок простий і показує, як поводиться ініціалізована змінна.
- **`demonstrateUninitializedVar` Функція**: У цій функції ми оголошуємо цілу змінну `uninitializedVar` без ініціалізації. Коли ми намагаємося вивести її значення, вихід може показати випадкове число. Це число представляє будь-які дані, які раніше знаходилися в цій ділянці пам'яті. Залежно від середовища та компілятора, фактичний вивід може змінюватися, і іноді, для безпеки, деякі компілятори можуть автоматично ініціалізувати змінні нулем, хоча на це не слід покладатися.
- **`main` Функція**: Функція `main` викликає обидві вищезгадані функції послідовно, демонструючи контраст між ініціалізованою змінною та неініціалізованою.

## Практичні патерни експлуатації (2024–2025)

Класична вразливість "read-before-write" залишається актуальною, оскільки сучасні міри захисту (ASLR, canaries) часто залежать від секретності. Типові поверхні атаки:

- **Partially initialized structs copied to userland**: Kernel or drivers часто `memset` лише поле довжини, а потім `copy_to_user(&u, &local_struct, sizeof(local_struct))`. Padding та невикористані поля leak stack canary halves, saved frame pointers or kernel pointers. Якщо struct містить function pointer, залишення його неініціалізованим також може дозволити **controlled overwrite** при подальшому повторному використанні.
- **Uninitialized stack buffers reused as indexes/lengths**: Неініціалізована `size_t len;`, що використовується для обмеження `read(fd, buf, len)`, може надати attackers можливість виконувати out-of-bounds reads/writes або дозволити обходити перевірки розміру, коли стекова комірка все ще містить велике значення з попереднього виклику.
- **Compiler-added padding**: Навіть коли окремі члени ініціалізовані, неявні padding байти між ними — ні. Копіювання всього struct в userland leak padding, який часто містить попередній вміст стеку (canaries, pointers).
- **ROP/Canary disclosure**: Якщо функція копіює локальний struct на stdout для дебагу, uninitialized padding може reveal the stack canary, що дозволяє подальшу експлуатацію stack overflow без brute-force.

Minimal PoC pattern to detect such issues during review:
```c
struct msg {
char data[0x20];
uint32_t len;
};

ssize_t handler(int fd) {
struct msg m;              // never fully initialized
m.len = read(fd, m.data, sizeof(m.data));
// later debug helper
write(1, &m, sizeof(m));   // leaks padding + stale stack
return m.len;
}
```
## Mitigations & compiler options (keep in mind when bypassing)

- **Clang/GCC auto-init**: Recent toolchains expose `-ftrivial-auto-var-init=zero` or `-ftrivial-auto-var-init=pattern`, filling *every* automatic (stack) variable at function entry with zeros or a poison pattern (0xAA / 0xFE). Це закриває більшість uninitialized-stack info leaks і ускладнює exploitation, перетворюючи секрети на відомі значення.
- **Linux kernel hardening**: Kernels built with `CONFIG_INIT_STACK_ALL` or the newer `CONFIG_INIT_STACK_ALL_PATTERN` zero/pattern-initialize every stack slot at function entry, wiping canaries/pointers that would otherwise leak. Шукайте дистрибутиви, що поставляють Clang-built kernels з цими опціями (поширено в 6.8+ hardening конфігураціях).
- **Opt-out attributes**: Clang now allows `__attribute__((uninitialized))` on specific locals/structs to keep performance-critical areas uninitialized even when global auto-init is enabled. Ретельно переглядайте такі анотації — вони часто позначають навмисну attack surface для side channels.

З точки зору нападника, знання того, чи був бінарник зібраний з цими прапорами, визначає, чи життєздатні stack-leak primitives або чи потрібно переходити до heap/data-section disclosures.

## Finding uninitialized-stack bugs quickly

- **Compiler diagnostics**: Build with `-Wall -Wextra -Wuninitialized` (GCC/Clang). For C++ code, `clang-tidy -checks=cppcoreguidelines-init-variables` will auto-fix many cases to zero-init and is handy to spot missed locals during audit.
- **Dynamic tools**: `-fsanitize=memory` (MSan) in Clang or Valgrind's `--track-origins=yes` reliably flag reads of uninitialized stack bytes during fuzzing. Інструментуйте тестові рантайми цими засобами, щоб виявити тонкі padding leaks.
- **Grepping patterns**: In reviews, search for `copy_to_user` / `write` calls of whole structs, or `memcpy`/`send` of stack data where only part of the struct is set. Особливу увагу приділяйте error paths, де ініціалізація пропускається.

## ARM64 Example

This doesn't change at all in ARM64 as local variables are also managed in the stack, you can [**check this example**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) were this is shown.



## References

- [CONFIG_INIT_STACK_ALL_PATTERN documentation](https://www.kernelconfig.io/config_init_stack_all_pattern)
- [GHSL-2024-197: GStreamer uninitialized stack variable leading to function pointer overwrite](https://securitylab.github.com/advisories/GHSL-2024-197_GStreamer/)
{{#include ../../banners/hacktricks-training.md}}
