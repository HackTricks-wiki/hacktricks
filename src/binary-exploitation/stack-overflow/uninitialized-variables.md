# Başlatılmamış Değişkenler

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

Buradaki temel fikir, **başlatılmamış değişkenlerin, kendilerine atanan bellek alanında zaten bulunan değeri alacağıdır.** Örnek:

- **Fonksiyon 1: `initializeVariable`**: Bir `x` değişkeni tanımlıyoruz ve ona bir değer atıyoruz, diyelim ki `0x1234`. Bu işlem, bellekte bir yer ayırmaya ve oraya belirli bir değer koymaya benzer.
- **Fonksiyon 2: `useUninitializedVariable`**: Burada başka bir `y` değişkeni tanımlıyoruz ama ona herhangi bir değer atamıyoruz. C dilinde, başlatılmamış değişkenler otomatik olarak sıfıra ayarlanmıyor. Bunun yerine, en son depolanan değeri koruyorlar.

Bu iki fonksiyonu **sırasıyla** çalıştırdığımızda:

1. `initializeVariable` içinde, `x` bir değer (`0x1234`) alır ve bu belirli bir bellek adresini kaplar.
2. `useUninitializedVariable` içinde, `y` tanımlanır ama bir değer atanmamıştır, bu nedenle `x`'in hemen arkasındaki bellek alanını alır. `y`'yi başlatmadığımız için, `x` tarafından kullanılan aynı bellek konumundan "miras" alır, çünkü orada en son bulunan değer odur.

Bu davranış, düşük seviyeli programlamada önemli bir kavramı gösterir: **Bellek yönetimi kritik öneme sahiptir** ve başlatılmamış değişkenler, istemeden bellek içinde kalan hassas verileri tutabilecekleri için öngörülemeyen davranışlara veya güvenlik açıklarına yol açabilir.

Başlatılmamış yığın değişkenleri birkaç güvenlik riski oluşturabilir:

- **Veri Sızıntısı**: Başlatılmamış değişkenlerde depolanan hassas bilgiler, şifreler, şifreleme anahtarları veya kişisel detaylar gibi bilgiler ifşa edilebilir ve bu da saldırganların bu verileri okumasına olanak tanır.
- **Bilgi Açığa Çıkması**: Başlatılmamış değişkenlerin içeriği, programın bellek düzeni veya iç işlemleri hakkında detaylar ortaya çıkarabilir ve bu da saldırganların hedeflenmiş istismarlar geliştirmesine yardımcı olabilir.
- **Çökme ve Dengesizlik**: Başlatılmamış değişkenlerle ilgili işlemler, tanımsız davranışa yol açabilir ve bu da program çökmesine veya öngörülemeyen sonuçlara neden olabilir.
- **Rastgele Kod Çalıştırma**: Belirli senaryolarda, saldırganlar bu güvenlik açıklarını kullanarak programın yürütme akışını değiştirebilir ve rastgele kod çalıştırmalarına olanak tanıyabilir; bu da uzaktan kod çalıştırma tehditlerini içerebilir.

### Örnek
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Bu Nasıl Çalışır:

- **`initializeAndPrint` Fonksiyonu**: Bu fonksiyon bir tamsayı değişkeni `initializedVar` tanımlar, ona `100` değerini atar ve ardından değişkenin hem bellek adresini hem de değerini yazdırır. Bu adım basittir ve bir başlatılmış değişkenin nasıl davrandığını gösterir.
- **`demonstrateUninitializedVar` Fonksiyonu**: Bu fonksiyonda, bir tamsayı değişkeni `uninitializedVar` tanımlıyoruz ancak onu başlatmıyoruz. Değerini yazdırmaya çalıştığımızda, çıktı rastgele bir sayı gösterebilir. Bu sayı, o bellek konumunda daha önce bulunan veriyi temsil eder. Ortama ve derleyiciye bağlı olarak, gerçek çıktı değişebilir ve bazen güvenlik nedeniyle bazı derleyiciler değişkenleri otomatik olarak sıfıra başlatabilir, ancak buna güvenilmemelidir.
- **`main` Fonksiyonu**: `main` fonksiyonu yukarıdaki her iki fonksiyonu sırasıyla çağırarak başlatılmış bir değişken ile başlatılmamış bir değişken arasındaki farkı gösterir.

## ARM64 Örneği

Bu, ARM64'te hiç değişmez çünkü yerel değişkenler de yığında yönetilir, bunu gösteren [**bu örneği kontrol edebilirsiniz**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/).

{{#include ../../banners/hacktricks-training.md}}
