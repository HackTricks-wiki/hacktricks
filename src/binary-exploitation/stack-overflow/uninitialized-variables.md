# अनइनिशियलाइज़्ड वेरिएबल्स

{{#include ../../banners/hacktricks-training.md}}

## मूल जानकारी

मुख्य विचार यह समझना है कि अनइनिशियलाइज़्ड वेरिएबल्स के साथ क्या होता है — वे उस मेमोरी में पहले से मौजूद मान को धारण कर लेंगे जो उन्हें असाइन की गई होती है। उदाहरण:

- **Function 1: `initializeVariable`**: हम एक वेरिएबल `x` घोषित करते हैं और उसे कोई मान असाइन करते हैं, मान लीजिए `0x1234`। यह कार्रवाई मेमोरी में एक स्थान रिज़र्व करने और उसमें एक निश्चित मान रखने जैसी है।
- **Function 2: `useUninitializedVariable`**: यहाँ हम एक और वेरिएबल `y` घोषित करते हैं लेकिन उसे कोई मान नहीं देते। C में, अनइनिशियलाइज़्ड वेरिएबल्स अपने आप ज़ीरो पर सेट नहीं होते। इसके बजाय, वे उस मेमोरी लोकेशन में अंतिम बार जो रखा गया था वह मान रख लेते हैं।

जब हम इन दोनों फ़ंक्शन्स को क्रमिक रूप से चलाते हैं:

1. `initializeVariable` में, `x` को एक मान (`0x1234`) असाइन किया जाता है, जो एक विशिष्ट मेमोरी एड्रेस घेर लेता है।
2. `useUninitializedVariable` में, `y` घोषित होता है लेकिन उसे मान नहीं दिया जाता, इसलिए यह `x` के ठीक बाद वाली मेमोरी जगह ले लेता है। `y` को इनिशियलाइज़ न करने के कारण, यह उसी मेमोरी लोकेशन से "वंशानुगत" मान प्राप्त कर लेता है जो वहां आख़िरी बार था।

यह व्यवहार लो-लेवल प्रोग्रामिंग के एक प्रमुख सिद्धांत को दर्शाता है: मेमोरी मैनेजमेंट महत्वपूर्ण है, और अनइनिशियलाइज़्ड वेरिएबल्स अनपेक्षित व्यवहार या सुरक्षा कमजोरियों का कारण बन सकते हैं, क्योंकि वे अनजाने में मेमोरी में छोड़े गए संवेदनशील डेटा को धारण कर सकते हैं।

अनइनिशियलाइज़्ड स्टैक वेरिएबल्स कई सुरक्षा जोखिम पैदा कर सकते हैं जैसे:

- **Data Leakage**: पासवर्ड, एन्क्रिप्शन कीज़, या व्यक्तिगत विवरण जैसी संवेदनशील जानकारी अनइनिशियलाइज़्ड वेरिएबल्स में स्टोर होने पर एक्सपोज़ हो सकती है, जिससे attackers को ये डेटा पढ़ने का मौका मिल सकता है।
- **Information Disclosure**: अनइनिशियलाइज़्ड वेरिएबल्स की सामग्री प्रोग्राम की मेमोरी लेआउट या आंतरिक ऑपरेशनों के बारे में विवरण प्रकट कर सकती है, जिससे attackers को लक्षित exploit विकसित करने में मदद मिल सकती है।
- **Crashes and Instability**: अनइनिशियलाइज़्ड वेरिएबल्स के साथ की जाने वाली ऑपरेशन्स अनिर्धारित व्यवहार का कारण बन सकती हैं, जिससे प्रोग्राम क्रैश या अप्रत्याशित परिणाम हो सकते हैं।
- **Arbitrary Code Execution**: कुछ परिस्थितियों में, attackers इन कमजोरियों का उपयोग प्रोग्राम के एक्ज़ीक्यूशन फ्लो को बदलने के लिए कर सकते हैं, जिससे वे arbitrary code execute कर सकें — जिसमें remote code execution खतरे भी शामिल हो सकते हैं।

### उदाहरण
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### यह कैसे काम करता है:

- **`initializeAndPrint` फ़ंक्शन**: यह फ़ंक्शन एक integer वेरिएबल `initializedVar` घोषित करता है, उसे मान `100` असाइन करता है, और फिर वेरिएबल का मेमोरी पता और मान दोनों प्रिंट करता है। यह चरण सीधा है और दिखाता है कि initialized वेरिएबल कैसे व्यवहार करता है।
- **`demonstrateUninitializedVar` फ़ंक्शन**: इस फ़ंक्शन में, हम एक integer वेरिएबल `uninitializedVar` घोषित करते हैं बिना उसे initialize किए। जब हम उसका मान प्रिंट करने की कोशिश करते हैं, आउटपुट में एक यादृच्छिक संख्या दिख सकती है। यह संख्या उस मेमोरी लोकेशन पर पहले मौजूद डेटा को दर्शाती है। परिनियोजन और compiler के अनुसार वास्तविक आउटपुट बदल सकता है, और कभी-कभी सुरक्षा कारणों से कुछ compilers वेरिएबल्स को ऑटोमेटिकली 0 से initialize कर सकते हैं, हालांकि इस पर भरोसा नहीं किया जाना चाहिए।
- **`main` फ़ंक्शन**: `main` फ़ंक्शन ऊपर दोनों फ़ंक्शन्स को क्रम में कॉल करता है, यह दर्शाते हुए initialized वेरिएबल और uninitialized वेरिएबल के बीच का अंतर।

## Practical exploitation patterns (2024–2025)

क्लासिक "read-before-write" बग अभी भी प्रासंगिक है क्योंकि आधुनिक mitigations (ASLR, canaries) अक्सर secrecy पर निर्भर करते हैं। Typical attack surfaces:

- **Partially initialized structs copied to userland**: Kernel या drivers अक्सर केवल लंबाई फ़ील्ड को `memset` करते हैं और फिर `copy_to_user(&u, &local_struct, sizeof(local_struct))` करते हैं। Padding और unused फ़ील्ड stack canary halves, saved frame pointers या kernel pointers को leak कर देते हैं। अगर struct में function pointer है, तो उसे uninitialized छोड़ने से बाद में reuse होने पर **controlled overwrite** की संभावना भी हो सकती है।
- **Uninitialized stack buffers reused as indexes/lengths**: एक uninitialized `size_t len;` जिसका उपयोग `read(fd, buf, len)` को bound करने के लिए किया जाता है, वह attackers को out-of-bounds reads/writes दे सकता है या size checks को bypass करने की अनुमति दे सकता है जब stack slot में पहले के कॉल से बड़ा मान बना हुआ हो।
- **Compiler-added padding**: भले ही अलग-अलग सदस्य initialize किए गए हों, उनके बीच implicit padding bytes नहीं होते। पूरी struct को userland में कॉपी करने से padding leak हो जाता है जिसमें अक्सर पहले का stack content (canaries, pointers) होता है।
- **ROP/Canary disclosure**: यदि कोई फ़ंक्शन debugging के लिए एक local struct को stdout पर copy करता है, तो uninitialized padding stack canary को reveal कर सकता है जिससे बाद में stack overflow exploitation बिना brute-force के संभव हो जाता है।

Minimal PoC pattern to detect such issues during review:
```c
struct msg {
char data[0x20];
uint32_t len;
};

ssize_t handler(int fd) {
struct msg m;              // never fully initialized
m.len = read(fd, m.data, sizeof(m.data));
// later debug helper
write(1, &m, sizeof(m));   // leaks padding + stale stack
return m.len;
}
```
## रोकथाम और कम्पाइलर विकल्प (बायपास करते समय ध्यान में रखें)

- **Clang/GCC auto-init**: Recent toolchains expose `-ftrivial-auto-var-init=zero` or `-ftrivial-auto-var-init=pattern`, filling *every* automatic (stack) variable at function entry with zeros or a poison pattern (0xAA / 0xFE). यह अधिकांश uninitialized-stack info leaks को बंद कर देता है और secrets को ज्ञात मानों में बदलकर exploitation को कठिन बना देता है।
- **Linux kernel hardening**: Kernels built with `CONFIG_INIT_STACK_ALL` or the newer `CONFIG_INIT_STACK_ALL_PATTERN` zero/pattern-initialize every stack slot at function entry, wiping canaries/pointers that would otherwise leak. उन distros की तलाश करें जो Clang-built kernels इन विकल्पों के साथ ship करते हैं (आम तौर पर 6.8+ hardening configs में)।
- **Opt-out attributes**: Clang now allows `__attribute__((uninitialized))` on specific locals/structs to keep performance-critical areas uninitialized even when global auto-init is enabled. ऐसे annotations को सावधानी से देखें—ये अक्सर side channels के लिए जानबूझकर attack surface को चिन्हित करते हैं।

एक हमलावर के दृष्टिकोण से, यह जानना कि बाइनरी इन फ्लैग्स के साथ बनाई गई थी या नहीं, यह निर्धारित करता है कि stack-leak primitives उपयोगी हैं या आपको heap/data-section disclosures पर pivot करना होगा।

## Finding uninitialized-stack bugs quickly

- **Compiler diagnostics**: Build with `-Wall -Wextra -Wuninitialized` (GCC/Clang). For C++ code, `clang-tidy -checks=cppcoreguidelines-init-variables` will auto-fix many cases to zero-init and is handy to spot missed locals during audit.
- **Dynamic tools**: `-fsanitize=memory` (MSan) in Clang or Valgrind's `--track-origins=yes` reliably flag reads of uninitialized stack bytes during fuzzing. Instrument test harnesses with these to surface subtle padding leaks.
- **Grepping patterns**: In reviews, search for `copy_to_user` / `write` calls of whole structs, or `memcpy`/`send` of stack data where only part of the struct is set. Pay special attention to error paths where initialization is skipped.

## ARM64 Example

This doesn't change at all in ARM64 as local variables are also managed in the stack, you can [**check this example**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) were this is shown.



## References

- [CONFIG_INIT_STACK_ALL_PATTERN documentation](https://www.kernelconfig.io/config_init_stack_all_pattern)
- [GHSL-2024-197: GStreamer uninitialized stack variable leading to function pointer overwrite](https://securitylab.github.com/advisories/GHSL-2024-197_GStreamer/)
{{#include ../../banners/hacktricks-training.md}}
