# 초기화되지 않은 변수

{{#include ../../banners/hacktricks-training.md}}

## 기본 정보

핵심은 **초기화되지 않은 변수는 그 변수에 할당된 메모리에 이미 있던 값을 가지게 된다**는 점을 이해하는 것이다. 예:

- **Function 1: `initializeVariable`**: 우리는 변수 `x`를 선언하고 값을 할당한다, 예를 들어 `0x1234`. 이 동작은 메모리에서 공간을 예약하고 특정 값을 넣는 것과 같다.
- **Function 2: `useUninitializedVariable`**: 여기서 우리는 다른 변수 `y`를 선언하지만 어떤 값도 할당하지 않는다. C에서는 초기화되지 않은 변수는 자동으로 0으로 설정되지 않는다. 대신 그 메모리 위치에 마지막으로 저장되어 있던 값을 유지한다.

이 두 함수를 **순차적으로** 실행하면:

1. `initializeVariable`에서는 `x`에 값(`0x1234`)이 할당되어 특정 메모리 주소를 차지한다.
2. `useUninitializedVariable`에서는 `y`가 선언되지만 값이 할당되지 않아 `x` 바로 다음 메모리 자리를 차지한다. `y`를 초기화하지 않았기 때문에 그 자리에 마지막으로 남아 있던 값, 즉 `x`가 사용하던 메모리의 값을 '상속'하게 된다.

이 동작은 저수준 프로그래밍의 핵심 개념을 보여준다: **메모리 관리는 매우 중요하다**, 초기화되지 않은 변수는 예기치 않은 동작이나 보안 취약점으로 이어질 수 있다. 메모리에 남아 있던 민감한 데이터를 의도치 않게 보유할 수 있기 때문이다.

초기화되지 않은 스택 변수는 다음과 같은 여러 보안 위험을 초래할 수 있다:

- **데이터 유출**: 비밀번호, 암호화 키 또는 개인 정보와 같은 민감한 정보가 초기화되지 않은 변수에 저장되어 노출될 수 있으며, 공격자가 이 데이터를 읽을 수 있다.
- **정보 노출**: 초기화되지 않은 변수의 내용은 프로그램의 메모리 레이아웃이나 내부 동작에 대한 정보를 드러낼 수 있어, 공격자가 타겟화된 익스플로잇을 개발하는 데 도움이 된다.
- **충돌 및 불안정성**: 초기화되지 않은 변수를 사용하는 연산은 정의되지 않은 동작을 초래하여 프로그램 충돌이나 예측 불가능한 결과를 발생시킬 수 있다.
- **임의 코드 실행**: 특정 시나리오에서는 공격자가 이러한 취약점을 이용해 프로그램의 실행 흐름을 변경하여 임의 코드를 실행하게 할 수 있으며, 이는 원격 코드 실행(remote code execution) 위협을 포함할 수 있다.

### 예제
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### 작동 방식:

- **`initializeAndPrint` Function**: 이 함수는 정수 변수 `initializedVar`를 선언하고 값 `100`을 할당한 다음 변수의 메모리 주소와 값을 출력합니다. 이 단계는 간단하며 초기화된 변수가 어떻게 동작하는지 보여줍니다.
- **`demonstrateUninitializedVar` Function**: 이 함수에서는 정수 변수 `uninitializedVar`를 선언하지만 초기화하지 않습니다. 그 값을 출력하려 하면 출력에 임의의 숫자가 표시될 수 있습니다. 이 숫자는 해당 메모리 위치에 이전에 존재하던 데이터를 나타냅니다. 환경과 컴파일러에 따라 실제 출력은 달라질 수 있으며, 일부 컴파일러는 안전을 위해 변수를 자동으로 0으로 초기화할 수도 있지만, 이는 의존해서는 안 됩니다.
- **`main` Function**: `main` 함수는 위의 두 함수를 순서대로 호출하여 초기화된 변수와 초기화되지 않은 변수의 차이를 보여줍니다.

## 실전 exploitation 패턴 (2024–2025)

고전적인 "read-before-write" 버그는 여전히 관련성이 높습니다. 이는 현대적 완화 기법(ASLR, canaries)이 종종 기밀성에 의존하기 때문입니다. 전형적인 공격 표면:

- **Partially initialized structs copied to userland**: Kernel 또는 drivers는 종종 길이 필드만 `memset`한 다음 `copy_to_user(&u, &local_struct, sizeof(local_struct))`를 호출합니다. 패딩과 사용되지 않는 필드는 leak stack canary halves, saved frame pointers 또는 kernel pointers를 노출할 수 있습니다. struct에 function pointer가 포함되어 있고 이를 초기화하지 않으면 나중에 재사용될 때 **controlled overwrite**가 가능해질 수 있습니다.
- **Uninitialized stack buffers reused as indexes/lengths**: 초기화되지 않은 `size_t len;`이 `read(fd, buf, len)`의 경계로 사용되면, 이전 호출에서 스택 슬롯에 남아 있던 큰 값 때문에 공격자가 out-of-bounds reads/writes를 수행하거나 size checks를 우회할 수 있습니다.
- **Compiler-added padding**: 개별 멤버가 초기화되어 있더라도 그 사이의 implicit padding 바이트는 초기화되지 않을 수 있습니다. 전체 struct를 userland로 복사하면 종종 이전의 스택 내용(canaries, pointers)이 leak 됩니다.
- **ROP/Canary disclosure**: 함수가 디버깅을 위해 로컬 struct를 stdout으로 복사하면, 초기화되지 않은 패딩이 stack canary를 노출하여 brute-force 없이 이후의 stack overflow exploitation을 가능하게 할 수 있습니다.

최소 PoC 패턴(검토 중 해당 문제를 탐지하기 위한):
```c
struct msg {
char data[0x20];
uint32_t len;
};

ssize_t handler(int fd) {
struct msg m;              // never fully initialized
m.len = read(fd, m.data, sizeof(m.data));
// later debug helper
write(1, &m, sizeof(m));   // leaks padding + stale stack
return m.len;
}
```
## 완화책 및 컴파일러 옵션 (우회 시 유의사항)

- **Clang/GCC auto-init**: 최근 툴체인들은 `-ftrivial-auto-var-init=zero` 또는 `-ftrivial-auto-var-init=pattern`을 제공해 함수 진입 시 *모든* 자동(스택) 변수를 0이나 포이즌 패턴(0xAA / 0xFE)으로 채웁니다. 이는 대부분의 uninitialized-stack info leaks를 차단하고, 비밀값을 알려진 값으로 바꿔 exploitation을 더 어렵게 만듭니다.
- **Linux kernel hardening**: `CONFIG_INIT_STACK_ALL` 또는 최신의 `CONFIG_INIT_STACK_ALL_PATTERN`으로 빌드된 커널은 함수 진입 시 스택의 모든 슬롯을 0/패턴으로 초기화하여, 그렇지 않으면 leak될 수 있는 canaries/포인터들을 삭제합니다. 이러한 옵션이 활성화된 Clang으로 빌드된 커널을 배포하는 배포판(6.8+ hardening 구성에서 흔함)을 찾아보세요.
- **Opt-out attributes**: Clang은 이제 특정 로컬/구조체에 대해 `__attribute__((uninitialized))`를 허용하여, 전역 auto-init이 활성화된 경우에도 성능에 민감한 영역을 초기화하지 않도록 할 수 있습니다. 이러한 주석은 주의 깊게 검토하세요—종종 side channels를 위한 의도된 공격 표면을 표시합니다.

공격자 관점에서는 바이너리가 이러한 플래그로 빌드되었는지 아는 것이 stack-leak primitives가 유효한지, 아니면 heap/data-section disclosures로 전환해야 하는지를 판단합니다.

## Finding uninitialized-stack bugs quickly

- **Compiler diagnostics**: `-Wall -Wextra -Wuninitialized`(GCC/Clang)로 빌드하세요. C++ 코드의 경우 `clang-tidy -checks=cppcoreguidelines-init-variables`가 많은 케이스를 자동으로 zero-init으로 수정해주며, 감사 중 놓친 로컬 변수를 찾는 데 유용합니다.
- **Dynamic tools**: Clang의 `-fsanitize=memory`(MSan) 또는 Valgrind의 `--track-origins=yes`는 fuzzing 중에 초기화되지 않은 스택 바이트의 읽기를 신뢰성 있게 표시합니다. 이러한 도구로 테스트 하니스에 계측을 추가하면 미세한 패딩 leaks를 드러내는 데 도움이 됩니다.
- **Grepping patterns**: 코드 리뷰에서는 전체 구조체를 대상으로 한 `copy_to_user` / `write` 호출이나, 구조체의 일부만 설정되는 상황에서의 `memcpy`/`send` 같은 스택 데이터 전송을 검색하세요. 초기화가 건너뛰어지는 에러 경로에 특히 주의하세요.

## ARM64 Example

ARM64에서도 지역 변수는 스택에서 관리되므로 상황은 전혀 달라지지 않습니다. [**check this example**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/)에서 이 점을 확인할 수 있습니다.



## References

- [CONFIG_INIT_STACK_ALL_PATTERN documentation](https://www.kernelconfig.io/config_init_stack_all_pattern)
- [GHSL-2024-197: GStreamer uninitialized stack variable leading to function pointer overwrite](https://securitylab.github.com/advisories/GHSL-2024-197_GStreamer/)
{{#include ../../banners/hacktricks-training.md}}
