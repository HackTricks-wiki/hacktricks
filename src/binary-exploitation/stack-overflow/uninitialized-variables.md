# Variabili non inizializzate

{{#include ../../banners/hacktricks-training.md}}

## Informazioni di base

L'idea principale è capire cosa succede con le **variabili non inizializzate, poiché avranno il valore che era già presente nella memoria a loro assegnata.** Esempio:

- **Funzione 1: `initializeVariable`**: Dichiariamo una variabile `x` e le assegniamo un valore, diciamo `0x1234`. Questa azione è analoga a riservare un'area di memoria e inserire al suo interno un valore specifico.
- **Funzione 2: `useUninitializedVariable`**: Qui dichiariamo un'altra variabile `y` ma non le assegnamo alcun valore. In C, le variabili non inizializzate non vengono automaticamente azzerate. Invece, mantengono qualunque valore fosse stato memorizzato precedentemente nella loro locazione di memoria.

Quando eseguiamo queste due funzioni **in sequenza**:

1. In `initializeVariable`, alla variabile `x` viene assegnato un valore (`0x1234`), che occupa un indirizzo di memoria specifico.
2. In `useUninitializedVariable`, la variabile `y` viene dichiarata ma non le viene assegnato un valore, quindi prende lo spazio di memoria immediatamente successivo a quello di `x`. Non inizializzando `y`, finisce per "ereditare" il valore dalla stessa locazione di memoria usata da `x`, perché è l'ultimo valore presente.

Questo comportamento illustra un concetto chiave nella programmazione a basso livello: **la gestione della memoria è cruciale**, e le variabili non inizializzate possono portare a comportamenti imprevedibili o a vulnerabilità di sicurezza, poiché potrebbero involontariamente contenere dati sensibili rimasti in memoria.

Le variabili di stack non inizializzate possono comportare diversi rischi per la sicurezza, come:

- **Data Leakage**: Informazioni sensibili come password, chiavi di crittografia o dati personali possono essere esposte se presenti in variabili non inizializzate, permettendo ad attaccanti di potenzialmente leggere tali dati.
- **Information Disclosure**: Il contenuto delle variabili non inizializzate potrebbe rivelare dettagli sulla disposizione della memoria del programma o sulle sue operazioni interne, aiutando gli attaccanti a sviluppare exploit mirati.
- **Crashes and Instability**: Le operazioni che coinvolgono variabili non inizializzate possono causare comportamento indefinito, portando a crash del programma o risultati imprevedibili.
- **Arbitrary Code Execution**: In certi scenari, gli attaccanti potrebbero sfruttare queste vulnerabilità per alterare il flusso di esecuzione del programma, permettendo loro di eseguire codice arbitrario, il che potrebbe includere minacce di remote code execution.

### Esempio
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Come funziona:

- **`initializeAndPrint` Funzione**: Questa funzione dichiara una variabile intera `initializedVar`, le assegna il valore `100`, e poi stampa sia l'indirizzo di memoria sia il valore della variabile. Questo passaggio è semplice e mostra come si comporta una variabile inizializzata.
- **`demonstrateUninitializedVar` Funzione**: In questa funzione dichiariamo una variabile intera `uninitializedVar` senza inizializzarla. Quando proviamo a stampare il suo valore, l'output potrebbe mostrare un numero casuale. Questo numero rappresenta qualsiasi dato fosse precedentemente in quella locazione di memoria. A seconda dell'ambiente e del compiler, l'output reale può variare, e talvolta, per sicurezza, alcuni compiler potrebbero inizializzare automaticamente le variabili a zero, sebbene ciò non debba essere dato per scontato.
- **`main` Funzione**: La funzione `main` chiama entrambe le funzioni precedenti in sequenza, dimostrando il contrasto tra una variabile inizializzata e una non inizializzata.

## Pattern pratici di exploitation (2024–2025)

Il classico bug "read-before-write" resta rilevante perché le mitigazioni moderne (ASLR, canaries) spesso si basano sulla segretezza. Superfici d'attacco tipiche:

- **Partially initialized structs copied to userland**: Kernel o driver spesso eseguono `memset` solo su un campo di lunghezza e poi `copy_to_user(&u, &local_struct, sizeof(local_struct))`. I padding e i campi non usati leak stack canary halves, saved frame pointers o kernel pointers. Se la struct contiene un function pointer, lasciarlo non inizializzato può anche permettere un **controlled overwrite** quando viene riutilizzato.
- **Uninitialized stack buffers reused as indexes/lengths**: Un `size_t len;` non inizializzato usato per limitare `read(fd, buf, len)` può consentire agli attaccanti out-of-bounds reads/writes o permettere di bypassare i controlli di dimensione quando lo slot di stack contiene ancora un valore grande da una chiamata precedente.
- **Compiler-added padding**: Anche quando i singoli membri sono inizializzati, i byte di padding impliciti tra di essi non lo sono. Copiare l'intera struct in userland leak il padding che spesso contiene contenuti di stack precedenti (canaries, pointers).
- **ROP/Canary disclosure**: Se una funzione copia una struct locale su stdout per il debugging, il padding non inizializzato può rivelare lo stack canary permettendo successivi sfruttamenti di stack overflow senza brute-force.

Minimal PoC pattern to detect such issues during review:
```c
struct msg {
char data[0x20];
uint32_t len;
};

ssize_t handler(int fd) {
struct msg m;              // never fully initialized
m.len = read(fd, m.data, sizeof(m.data));
// later debug helper
write(1, &m, sizeof(m));   // leaks padding + stale stack
return m.len;
}
```
## Mitigations & compiler options (keep in mind when bypassing)

- **Clang/GCC auto-init**: Le toolchain recenti espongono `-ftrivial-auto-var-init=zero` o `-ftrivial-auto-var-init=pattern`, riempiendo *ogni* variabile automatica (stack) all'ingresso della funzione con zeri o con un pattern poison (0xAA / 0xFE). Questo chiude la maggior parte dei leak di informazioni da stack non inizializzato e rende l'exploitation più difficile convertendo segreti in valori noti.
- **Linux kernel hardening**: Kernels compilati con `CONFIG_INIT_STACK_ALL` o il più recente `CONFIG_INIT_STACK_ALL_PATTERN` inizializzano a zero/o a pattern ogni slot di stack all'ingresso della funzione, cancellando canaries/pointers che altrimenti potrebbero essere leakati. Cerca distro che distribuiscono kernel compilati con Clang con queste opzioni abilitate (comune nelle config di hardening 6.8+).
- **Opt-out attributes**: Clang ora permette `__attribute__((uninitialized))` su locali/struct specifici per mantenere non inizializzate aree critiche per le prestazioni anche quando l'auto-init globale è abilitato. Revisiona attentamente tali annotazioni—spesso indicano una surface di attacco deliberata per side channels.

Dal punto di vista di un attacker, sapere se il binario è stato compilato con queste flag determina se gli stack-leak primitives sono praticabili o se devi pivotare verso heap/data-section disclosures.

## Finding uninitialized-stack bugs quickly

- **Compiler diagnostics**: Compila con `-Wall -Wextra -Wuninitialized` (GCC/Clang). Per codice C++, `clang-tidy -checks=cppcoreguidelines-init-variables` corregge automaticamente molti casi azzerandoli ed è utile per individuare locali mancanti durante l'audit.
- **Dynamic tools**: `-fsanitize=memory` (MSan) in Clang o Valgrind's `--track-origins=yes` segnalano in modo affidabile letture di byte di stack non inizializzati durante il fuzzing. Strumenta gli harness di test con questi per far emergere leak di padding sottili.
- **Grepping patterns**: Nelle review, cerca chiamate `copy_to_user` / `write` di intere struct, o `memcpy`/`send` di dati di stack dove solo una parte della struct è impostata. Presta particolare attenzione ai percorsi di errore dove l'inizializzazione viene saltata.

## ARM64 Example

Questo non cambia per ARM64 dato che le variabili locali sono comunque gestite nello stack; puoi [**controllare questo esempio**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) dove questo è mostrato.



## References

- [CONFIG_INIT_STACK_ALL_PATTERN documentation](https://www.kernelconfig.io/config_init_stack_all_pattern)
- [GHSL-2024-197: GStreamer uninitialized stack variable leading to function pointer overwrite](https://securitylab.github.com/advisories/GHSL-2024-197_GStreamer/)
{{#include ../../banners/hacktricks-training.md}}
