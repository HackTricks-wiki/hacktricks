# 未初始化变量

{{#include ../../banners/hacktricks-training.md}}

## 基本信息

核心思想是理解未初始化变量会发生什么：**未初始化变量会具有分配给它们的内存中已有的值。** 示例：

- **Function 1: `initializeVariable`**：我们声明一个变量 `x` 并赋值，例如 `0x1234`。这个操作类似于在内存中保留一个位置并放入一个特定的值。
- **Function 2: `useUninitializedVariable`**：在这里我们声明另一个变量 `y` 但不赋值。在 C 中，未初始化变量不会自动置零。相反，它们保留最后存储在其内存位置的值。

当我们**顺序**运行这两个函数时：

1. 在 `initializeVariable` 中，`x` 被赋值（`0x1234`），占据一个特定的内存地址。
2. 在 `useUninitializedVariable` 中，声明了 `y` 但没有赋值，因此它占据紧随 `x` 之后的内存位置。由于没有初始化 `y`，它最终“继承”了 `x` 所使用的同一内存位置的值，因为那是该位置最后的值。

这种行为说明了底层编程的一个关键概念：**内存管理至关重要**，未初始化的变量可能导致不可预测的行为或安全漏洞，因为它们可能无意中保存内存中遗留的敏感数据。

未初始化的栈变量可能带来若干安全风险，例如：

- **Data Leakage**：敏感信息（如密码、加密密钥或个人信息）如果存储在未初始化变量中可能被暴露，攻击者可能读取这些数据。
- **Information Disclosure**：未初始化变量的内容可能泄露程序的内存布局或内部操作细节，帮助攻击者开发有针对性的利用手段。
- **Crashes and Instability**：涉及未初始化变量的操作可能导致未定义行为，引起程序崩溃或不可预测的结果。
- **Arbitrary Code Execution**：在某些情形下，攻击者可以利用这些漏洞改变程序执行流程，使其执行任意代码，可能包括远程代码执行威胁。

### 示例
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### 工作原理：

- **`initializeAndPrint` 函数**：该函数声明一个整型变量 `initializedVar`，将其赋值为 `100`，然后打印该变量的内存地址和数值。这个步骤很直接，展示了已初始化变量的行为。
- **`demonstrateUninitializedVar` 函数**：在此函数中，我们声明一个整型变量 `uninitializedVar`，但未对其进行初始化。当尝试打印其值时，输出可能显示一个随机数。该数值表示该内存位置之前遗留的数据。根据运行环境和编译器不同，实际输出会有差异；有时出于安全考虑，某些编译器可能会自动将变量初始化为 0，但不应依赖这一行为。
- **`main` 函数**：`main` 函数按顺序调用上述两个函数，演示已初始化变量与未初始化变量之间的对比。

## 实际利用模式 (2024–2025)

经典的 "read-before-write" bug 仍然相关，因为现代缓解措施（ASLR、canaries）常依赖于秘密性。典型攻击面包括：

- **Partially initialized structs copied to userland**：kernel 或 drivers 经常只对长度字段调用 `memset`，然后执行 `copy_to_user(&u, &local_struct, sizeof(local_struct))`。填充字节和未使用字段会 leak stack canary halves、saved frame pointers 或 kernel pointers。如果结构体包含 function pointer，保留其未初始化可能在后续重用时允许 **controlled overwrite**。
- **Uninitialized stack buffers reused as indexes/lengths**：未初始化的 `size_t len;` 用于限制 `read(fd, buf, len)` 时，可能使攻击者获得 out-of-bounds reads/writes，或当栈槽仍包含先前调用留下的大值时绕过大小检查。
- **Compiler-added padding**：即便单个成员已初始化，成员间的隐含填充字节通常不会被初始化。将整个 struct 复制到 userland 会 leak 这些填充，填充通常包含先前的栈内容（canaries、pointers）。
- **ROP/Canary disclosure**：如果某个函数将本地 struct 复制到 stdout 进行调试，未初始化的填充可能泄露 stack canary，从而使后续的 stack overflow exploitation 在无需 brute-force 的情况下成为可能。

在代码审查期间检测此类问题的最小 PoC 模式：
```c
struct msg {
char data[0x20];
uint32_t len;
};

ssize_t handler(int fd) {
struct msg m;              // never fully initialized
m.len = read(fd, m.data, sizeof(m.data));
// later debug helper
write(1, &m, sizeof(m));   // leaks padding + stale stack
return m.len;
}
```
## 缓解措施 & 编译器选项（在绕过时注意）

- **Clang/GCC auto-init**: 最近的工具链提供 `-ftrivial-auto-var-init=zero` 或 `-ftrivial-auto-var-init=pattern`，在函数入口将*每个*自动（stack）变量填充为零或毒性模式（0xAA / 0xFE）。这堵住了大多数 uninitialized-stack info leaks，并通过将 secrets 转换为已知值使 exploitation 更困难。
- **Linux kernel hardening**: 使用 `CONFIG_INIT_STACK_ALL` 或较新的 `CONFIG_INIT_STACK_ALL_PATTERN` 构建的内核，会在函数入口对每个 stack 槽进行 zero/pattern 初始化，抹去本会 otherwise leak 的 canaries/pointers。注意查找那些以 Clang 构建且启用了这些选项的发行版内核（在 6.8+ 的 hardening 配置中常见）。
- **Opt-out attributes**: Clang 现在允许在特定 locals/structs 上使用 `__attribute__((uninitialized))`，即使全局 auto-init 启用也能让性能关键区域保持 uninitialized。仔细审查这类注解 —— 它们通常标记出可被用于 side channels 的刻意攻击面。

从攻击者角度，知道二进制是否使用这些 flags 构建，决定了 stack-leak primitives 是否可行，或者是否必须 pivot 到 heap/data-section disclosures。

## 快速查找 uninitialized-stack bugs

- **Compiler diagnostics**: 使用 `-Wall -Wextra -Wuninitialized` (GCC/Clang) 构建。对于 C++ 代码，`clang-tidy -checks=cppcoreguidelines-init-variables` 会自动修复许多为 zero-init 的情况，便于在审计中发现被遗漏的 locals。
- **Dynamic tools**: Clang 的 `-fsanitize=memory` (MSan) 或 Valgrind 的 `--track-origins=yes` 能在 fuzzing 时可靠地标记对未初始化 stack 字节的读取。用这些工具对测试 harness 进行插桩，以揭示细微的 padding leaks。
- **Grepping patterns**: 在代码审查时，搜索对整个 struct 的 `copy_to_user` / `write` 调用，或对 stack 数据的 `memcpy`/`send`，但结构体只有部分被赋值的情形。特别注意那些在错误路径中会跳过初始化的路径。

## ARM64 Example

在 ARM64 上情况并无改变，因为局部变量也在 stack 上管理，你可以 [**check this example**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) 查看示例说明。

## References

- [CONFIG_INIT_STACK_ALL_PATTERN documentation](https://www.kernelconfig.io/config_init_stack_all_pattern)
- [GHSL-2024-197: GStreamer uninitialized stack variable leading to function pointer overwrite](https://securitylab.github.com/advisories/GHSL-2024-197_GStreamer/)
{{#include ../../banners/hacktricks-training.md}}
