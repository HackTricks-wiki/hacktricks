# Başlatılmamış Değişkenler

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

Temel fikir, **başlatılmamış değişkenlerin, atandıkları bellekten zaten bulunan değeri alacağını** anlamaktır. Örnek:

- **Function 1: `initializeVariable`**: Bir değişken `x` ilan ederiz ve ona örneğin `0x1234` değerini atarız. Bu eylem, bellekte bir yer ayırıp ona belirli bir değer koymaya benzer.
- **Function 2: `useUninitializedVariable`**: Burada başka bir değişken `y` ilan edilir ama ona herhangi bir değer atamayız. C'de başlatılmamış değişkenler otomatik olarak sıfırlanmaz. Bunun yerine, bulundukları bellek konumunda en son hangi değer saklandıysa onu korurlar.

Bu iki fonksiyonu ardışık olarak çalıştırdığımızda:

1. `initializeVariable` içinde `x`'e (`0x1234`) bir değer atanır; bu belirli bir bellek adresini işgal eder.
2. `useUninitializedVariable` içinde `y` ilan edilir ama değer atanmamıştır, bu yüzden `x`'ten hemen sonraki bellek konumunu alır. `y` başlatılmadığı için, aynı bellek konumunda kalan son değeri "miras" olarak alır; bu durumda `x`'in bıraktığı değeri.

Bu davranış, düşük seviyeli programlamada önemli bir kavramı gösterir: **Bellek yönetimi kritiktir**, ve başlatılmamış değişkenler öngörülemeyen davranışlara veya güvenlik açıklarına yol açabilir; çünkü istemeden bellekte kalan hassas verileri tutabilirler.

Başlatılmamış stack değişkenleri birkaç güvenlik riski oluşturabilir, örneğin:

- **Veri Sızıntısı**: Parolalar, şifreleme anahtarları veya kişisel bilgiler gibi hassas veriler başlatılmamış değişkenlerde saklanırsa açığa çıkabilir; bu da saldırganların bu verileri okumasına imkan verir.
- **Bilgi Açığa Çıkması**: Başlatılmamış değişkenlerin içeriği, programın bellek düzeni veya dahili işlemleri hakkında ayrıntılar ortaya koyabilir ve bu da saldırganların hedefe yönelik exploit geliştirmesine yardımcı olabilir.
- **Çökme ve Kararsızlık**: Başlatılmamış değişkenlerle yapılan işlemler tanımsız davranışa yol açabilir ve program çökmesine ya da öngörülemez sonuçlara neden olabilir.
- **Keyfi Kod Çalıştırma**: Bazı senaryolarda saldırganlar bu zafiyetleri programın yürütme akışını değiştirmek için kullanabilir; bu da onların keyfi kod çalıştırmasına olanak sağlayabilir ve uzaktan kod çalıştırma tehdidini içerebilir.

### Örnek
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Bu Nasıl Çalışır:

- **`initializeAndPrint` Fonksiyonu**: Bu fonksiyon bir integer değişken `initializedVar` bildirir, ona `100` değerini atar ve ardından değişkenin hem bellek adresini hem de değerini yazdırır. Bu adım basittir ve initialize edilmiş bir değişkenin nasıl davrandığını gösterir.
- **`demonstrateUninitializedVar` Fonksiyonu**: Bu fonksiyonda bir integer değişken `uninitializedVar` bildiririz fakat initialize etmeyiz. Değerini yazdırmaya çalıştığımızda çıktı rastgele bir sayı gösterebilir. Bu sayı, o bellek konumunda daha önce bulunan veriyi temsil eder. Ortama ve derleyiciye bağlı olarak gerçek çıktı değişebilir; bazı derleyiciler güvenlik nedeniyle değişkenleri otomatik olarak sıfıra initialize edebilir, ancak buna güvenilmemelidir.
- **`main` Fonksiyonu**: `main` fonksiyonu yukarıdaki iki fonksiyonu sırayla çağırır ve initialize edilmiş bir değişken ile initialize edilmemiş bir değişken arasındaki farkı gösterir.

## Practical exploitation patterns (2024–2025)

Klasik "read-before-write" hatası halen önemlidir çünkü modern koruma önlemleri (ASLR, canaries) genellikle gizliliğe dayanır. Typical attack surfaces:

- **Partially initialized structs copied to userland**: Kernel veya sürücüler sık sık sadece bir uzunluk alanını `memset` eder ve sonra `copy_to_user(&u, &local_struct, sizeof(local_struct))` çağrısı yapar. Padding ve kullanılmayan alanlar stack canary yarılarını, saved frame pointers veya kernel pointers'ı leak edebilir. Eğer struct bir function pointer içeriyorsa, onu initialize etmemek daha sonra yeniden kullanıldığında **controlled overwrite**'a da izin verebilir.
- **Uninitialized stack buffers reused as indexes/lengths**: Bir uninitialized `size_t len;` değeri `read(fd, buf, len)` gibi bir kullanımda sınır olarak kullanıldığında, saldırganlara out-of-bounds read/write imkanı verebilir veya önceki çağrıdan kalan büyük bir değer yüzünden boyut kontrollerinin atlatılmasına neden olabilir.
- **Compiler-added padding**: Bireysel üyeler initialize edilse bile, aralarındaki implicit padding byte'ları edilmez. Tüm struct'ı userland'e kopyalamak, genellikle önceki stack içeriğini (canaries, pointers) içeren padding'i leak eder.
- **ROP/Canary disclosure**: Eğer bir fonksiyon debug amacıyla yerel bir struct'ı stdout'a kopyalarsa, uninitialized padding stack canary'yi ortaya çıkarabilir ve sonrasında brute-force yapmadan stack overflow exploit'ine imkan verebilir.

Minimal PoC pattern to detect such issues during review:
```c
struct msg {
char data[0x20];
uint32_t len;
};

ssize_t handler(int fd) {
struct msg m;              // never fully initialized
m.len = read(fd, m.data, sizeof(m.data));
// later debug helper
write(1, &m, sizeof(m));   // leaks padding + stale stack
return m.len;
}
```
## Mitigasyonlar ve derleyici seçenekleri (atlatırken aklınızda tutun)

- **Clang/GCC auto-init**: Yeni toolchain'ler `-ftrivial-auto-var-init=zero` veya `-ftrivial-auto-var-init=pattern` seçeneklerini sunar; bunlar fonksiyon girişinde *her* otomatik (stack) değişkeni sıfırlarla veya bir zehir deseni (0xAA / 0xFE) ile doldurur. Bu, çoğu uninitialized-stack bilgi leak'ini kapatır ve gizli verileri bilinen değerlere dönüştürerek exploitation'ı zorlaştırır.
- **Linux kernel hardening**: `CONFIG_INIT_STACK_ALL` veya daha yeni `CONFIG_INIT_STACK_ALL_PATTERN` ile derlenen kernel'ler fonksiyon girişinde her stack slot'unu sıfır/desen ile başlatır, aksi halde leak olabilecek canaries/pointer'ları temizler. Bu seçeneklerin etkin olduğu Clang ile derlenmiş kernel'leri dağıtan distro'lara bakın (6.8+ hardening konfigürasyonlarında yaygın).
- **Opt-out attributes**: Clang artık belirli local/struct'lar için `__attribute__((uninitialized))` kullanımına izin veriyor; böylece global auto-init etkin olsa bile performans-kritik alanlar uninitialized kalabilir. Bu anotasyonları dikkatle inceleyin—genelde side channel'lar için kasıtlı saldırı yüzeyi işaretlerler.

From an attacker perspective, knowing whether the binary was built with these flags determines if stack-leak primitives are viable or if you must pivot to heap/data-section disclosures.

## Uninitialized-stack hatalarını hızlıca bulma

- **Compiler diagnostics**: `-Wall -Wextra -Wuninitialized` ile derleyin (GCC/Clang). C++ kodu için `clang-tidy -checks=cppcoreguidelines-init-variables` birçok durumu otomatik olarak zero-init'e çevirir ve denetimde atlanmış local'leri tespit etmek için kullanışlıdır.
- **Dynamic tools**: Clang'da `-fsanitize=memory` (MSan) veya Valgrind'in `--track-origins=yes` seçeneği, fuzzing sırasında uninitialized stack byte'larının okunmasını güvenilir şekilde işaretler. Test harness'larını bunlarla enstrümante edin ki ince padding leak'leri ortaya çıksın.
- **Grepping patterns**: İncelemelerde, tüm struct'ları kopyalayan `copy_to_user` / `write` çağrılarını veya struct'ın sadece bir kısmı set edilmişken stack verisinin `memcpy`/`send` ile gönderildiği yerleri arayın. Başlatmanın atlandığı hata yollarına özellikle dikkat edin.

## ARM64 Örneği

ARM64'te bu hiç değişmez çünkü local değişkenler yine stack'te yönetilir; bunun gösterildiği yere [**check this example**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) bakabilirsiniz.



## References

- [CONFIG_INIT_STACK_ALL_PATTERN documentation](https://www.kernelconfig.io/config_init_stack_all_pattern)
- [GHSL-2024-197: GStreamer uninitialized stack variable leading to function pointer overwrite](https://securitylab.github.com/advisories/GHSL-2024-197_GStreamer/)
{{#include ../../banners/hacktricks-training.md}}
