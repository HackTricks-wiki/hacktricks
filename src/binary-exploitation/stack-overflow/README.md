# Stack Overflow

{{#include ../../banners/hacktricks-training.md}}

## What is a Stack Overflow

A **stack overflow** एक सुरक्षा कमी है जो तब होती है जब एक प्रोग्राम स्टैक में उस डेटा से अधिक डेटा लिखता है जितना कि उसे रखने के लिए आवंटित किया गया है। यह अतिरिक्त डेटा **सन्निकट मेमोरी स्थान को ओवरराइट** करेगा, जिससे वैध डेटा का भ्रष्टाचार, नियंत्रण प्रवाह में विघटन, और संभावित रूप से दुर्भावनापूर्ण कोड का निष्पादन हो सकता है। यह समस्या अक्सर असुरक्षित कार्यों के उपयोग के कारण उत्पन्न होती है जो इनपुट पर सीमा जांच नहीं करते हैं।

इस ओवरराइट का मुख्य समस्या यह है कि **सहेजा गया निर्देश सूचक (EIP/RIP)** और **सहेजा गया बेस सूचक (EBP/RBP)** जो पिछले कार्य में लौटने के लिए होते हैं, **स्टैक पर संग्रहीत** होते हैं। इसलिए, एक हमलावर उन्हें ओवरराइट करने में सक्षम होगा और **प्रोग्राम के निष्पादन प्रवाह को नियंत्रित** कर सकेगा।

यह सुरक्षा कमी आमतौर पर इसलिए उत्पन्न होती है क्योंकि एक कार्य **स्टैक के अंदर उन बाइट्स की अधिक संख्या की नकल करता है जितनी कि इसके लिए आवंटित की गई है**, इसलिए अन्य स्टैक के हिस्सों को ओवरराइट करने में सक्षम होता है।

इससे प्रभावित कुछ सामान्य कार्य हैं: **`strcpy`, `strcat`, `sprintf`, `gets`**... इसके अलावा, ऐसे कार्य जैसे **`fgets`**, **`read` & `memcpy`** जो **लंबाई तर्क** लेते हैं, यदि निर्दिष्ट लंबाई आवंटित लंबाई से अधिक है तो उन्हें असुरक्षित तरीके से उपयोग किया जा सकता है।

उदाहरण के लिए, निम्नलिखित कार्य असुरक्षित हो सकते हैं:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Stack Overflows ऑफसेट्स खोजना

Stack overflows खोजने का सबसे सामान्य तरीका `A`s का बहुत बड़ा इनपुट देना है (जैसे `python3 -c 'print("A"*1000)'`) और एक `Segmentation Fault` की उम्मीद करना जो यह संकेत करता है कि **पता `0x41414141` को एक्सेस करने की कोशिश की गई थी**।

इसके अलावा, एक बार जब आप यह पता लगा लेते हैं कि Stack Overflow की कमजोरी है, तो आपको यह पता लगाने की आवश्यकता होगी कि **रिटर्न एड्रेस को ओवरराइट करने के लिए कितना ऑफसेट चाहिए**, इसके लिए आमतौर पर एक **De Bruijn अनुक्रम** का उपयोग किया जाता है। जो एक दिए गए वर्णमाला के आकार _k_ और लंबाई _n_ के उप अनुक्रमों के लिए एक **चक्रीय अनुक्रम है जिसमें लंबाई _n_ का हर संभव उप अनुक्रम ठीक एक बार एक सन्निहित उप अनुक्रम के रूप में प्रकट होता है**।

इस तरह, EIP को नियंत्रित करने के लिए आवश्यक ऑफसेट को हाथ से पता लगाने के बजाय, इन अनुक्रमों में से एक को पैडिंग के रूप में उपयोग करना संभव है और फिर उन बाइट्स का ऑफसेट ढूंढना संभव है जो इसे ओवरराइट करने के अंत में हैं।

इसके लिए **pwntools** का उपयोग करना संभव है:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
या **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## स्टैक ओवरफ्लोज़ का शोषण

एक ओवरफ्लो के दौरान (मान लेते हैं कि ओवरफ्लो का आकार पर्याप्त बड़ा है) आप स्टैक के अंदर स्थानीय वेरिएबल्स के मानों को **ओवरराइट** करने में सक्षम होंगे जब तक कि आप सुरक्षित **EBP/RBP और EIP/RIP (या इससे भी अधिक)** तक नहीं पहुँच जाते।\
इस प्रकार की भेद्यता का दुरुपयोग करने का सबसे सामान्य तरीका **रिटर्न एड्रेस को संशोधित करना** है ताकि जब फ़ंक्शन समाप्त हो, तो **नियंत्रण प्रवाह उस प्वाइंटर में उपयोगकर्ता द्वारा निर्दिष्ट स्थान पर पुनर्निर्देशित किया जाएगा**।

हालांकि, अन्य परिदृश्यों में केवल **स्टैक में कुछ वेरिएबल्स के मानों को ओवरराइट करना** शोषण के लिए पर्याप्त हो सकता है (जैसे आसान CTF चुनौतियों में)।

### Ret2win

इस प्रकार की CTF चुनौतियों में, बाइनरी के अंदर एक **फंक्शन** है जो **कभी नहीं बुलाया जाता** और जिसे **आपको जीतने के लिए बुलाना होगा**। इन चुनौतियों के लिए आपको केवल **रिटर्न एड्रेस को ओवरराइट करने के लिए ऑफसेट** ढूंढना है और **बुलाने के लिए फंक्शन का पता** लगाना है (आमतौर पर [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) अक्षम होगा) ताकि जब कमजोर फ़ंक्शन लौटे, तो छिपा हुआ फ़ंक्शन बुलाया जाएगा:

{{#ref}}
ret2win/
{{#endref}}

### स्टैक शेलकोड

इस परिदृश्य में हमलावर स्टैक में एक शेलकोड रख सकता है और नियंत्रित EIP/RIP का दुरुपयोग करके शेलकोड पर कूद सकता है और मनमाने कोड को निष्पादित कर सकता है:

{{#ref}}
stack-shellcode/
{{#endref}}

### ROP और Ret2... तकनीकें

यह तकनीक मुख्य सुरक्षा को बायपास करने के लिए मौलिक ढांचा है: **कोई निष्पादन योग्य स्टैक (NX)**। और यह कई अन्य तकनीकों (ret2lib, ret2syscall...) को निष्पादित करने की अनुमति देती है जो बाइनरी में मौजूदा निर्देशों का दुरुपयोग करके मनमाने आदेशों को निष्पादित करेंगी:

{{#ref}}
../rop-return-oriented-programing/
{{#endref}}

## हीप ओवरफ्लोज़

एक ओवरफ्लो हमेशा स्टैक में नहीं होगा, यह **हीप** में भी हो सकता है, उदाहरण के लिए:

{{#ref}}
../libc-heap/heap-overflow.md
{{#endref}}

## सुरक्षा के प्रकार

भेद्यताओं के शोषण को रोकने के लिए कई सुरक्षा उपाय हैं, उन्हें देखें:

{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

### वास्तविक-विश्व उदाहरण: CVE-2025-40596 (SonicWall SMA100)

क्यों **`sscanf` को अविश्वसनीय इनपुट को पार्स करने के लिए कभी भी भरोसा नहीं किया जाना चाहिए** इसका एक अच्छा प्रदर्शन 2025 में SonicWall के SMA100 SSL-VPN उपकरण में सामने आया।\
`/usr/src/EasyAccess/bin/httpd` के अंदर कमजोर रूटीन किसी भी URI से संस्करण और एंडपॉइंट निकालने का प्रयास करता है जो `/__api__/` से शुरू होता है:
```c
char version[3];
char endpoint[0x800] = {0};
/* simplified proto-type */
sscanf(uri, "%*[^/]/%2s/%s", version, endpoint);
```
1. पहला रूपांतरण (`%2s`) सुरक्षित रूप से **दो** बाइट्स को `version` में स्टोर करता है (जैसे कि `"v1"`).
2. दूसरा रूपांतरण (`%s`) **कोई लंबाई निर्दिष्ट नहीं करता**, इसलिए `sscanf` **पहले NUL बाइट** तक कॉपी करना जारी रखेगा.
3. क्योंकि `endpoint` **स्टैक** पर स्थित है और इसकी लंबाई **0x800 बाइट्स** है, 0x800 बाइट्स से लंबा पथ प्रदान करने से बफर के बाद जो कुछ भी है, वह सब भ्रष्ट हो जाता है ‑ जिसमें **स्टैक कैनरी** और **सहेजा गया रिटर्न पता** शामिल है.

एकल-पंक्ति प्रमाण-ऑफ-कॉन्सेप्ट क्रैश को **प्रमाणन से पहले** ट्रिगर करने के लिए पर्याप्त है:
```python
import requests, warnings
warnings.filterwarnings('ignore')
url = "https://TARGET/__api__/v1/" + "A"*3000
requests.get(url, verify=False)
```
हालाँकि स्टैक कैनरी प्रक्रिया को समाप्त कर देते हैं, एक हमलावर अभी भी एक **Denial-of-Service** प्राइमिटिव प्राप्त करता है (और, अतिरिक्त जानकारी लीक के साथ, संभवतः कोड-एक्ज़ीक्यूशन)। सबक सरल है:

* हमेशा एक **अधिकतम फ़ील्ड चौड़ाई** प्रदान करें (जैसे `%511s`)।
* `snprintf`/`strncpy_s` जैसे सुरक्षित विकल्पों को प्राथमिकता दें।

## References
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)

{{#include ../../banners/hacktricks-training.md}}
