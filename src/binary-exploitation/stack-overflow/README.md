# Stack Overflow

{{#include ../../banners/hacktricks-training.md}}

## What is a Stack Overflow

一个**栈溢出**是指当程序向栈中写入的数据超过其分配的容量时发生的漏洞。这些多余的数据将**覆盖相邻的内存空间**，导致有效数据的损坏、控制流的中断，以及潜在的恶意代码执行。这个问题通常是由于使用不安全的函数而引起的，这些函数对输入没有进行边界检查。

这个覆盖的主要问题在于**保存的指令指针（EIP/RIP）**和**保存的基指针（EBP/RBP）**用于返回到上一个函数，它们是**存储在栈上的**。因此，攻击者将能够覆盖这些内容并**控制程序的执行流**。

该漏洞通常是因为一个函数**在栈中复制的字节数超过了为其分配的数量**，因此能够覆盖栈的其他部分。

一些常见的易受攻击的函数包括：**`strcpy`, `strcat`, `sprintf`, `gets`**... 此外，像**`fgets`**、**`read`**和**`memcpy`**这样的函数，如果指定的长度大于分配的长度，可能会以脆弱的方式使用。

例如，以下函数可能是脆弱的：
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### 寻找栈溢出偏移量

寻找栈溢出的最常见方法是输入大量的 `A`（例如 `python3 -c 'print("A"*1000)'）并期待出现 `Segmentation Fault`，这表明 **地址 `0x41414141` 被尝试访问**。

此外，一旦发现存在栈溢出漏洞，您需要找到偏移量，直到可以 **覆盖返回地址**，通常使用 **De Bruijn 序列**。对于给定大小为 _k_ 的字母表和长度为 _n_ 的子序列，这是一个 **循环序列，其中每个可能的长度为 _n_ 的子序列恰好出现一次** 作为连续子序列。

这样，您就不需要手动找出控制 EIP 所需的偏移量，可以使用这些序列作为填充，然后找到覆盖它的字节的偏移量。

可以使用 **pwntools** 来实现这一点：
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
或 **GEF**：
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## 利用栈溢出

在溢出期间（假设溢出大小足够大），您将能够**覆盖**栈内局部变量的值，直到达到保存的**EBP/RBP 和 EIP/RIP（甚至更多）**。\
滥用这种类型漏洞的最常见方法是**修改返回地址**，这样当函数结束时，**控制流将被重定向到用户在此指针中指定的地方**。

然而，在其他场景中，仅仅**覆盖栈中某些变量的值**可能就足以进行利用（例如在简单的 CTF 挑战中）。

### Ret2win

在这种类型的 CTF 挑战中，二进制文件中有一个**从未被调用的函数**，而且**您需要调用它才能获胜**。对于这些挑战，您只需找到**覆盖返回地址的偏移量**并**找到要调用的函数的地址**（通常[**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html)会被禁用），这样当易受攻击的函数返回时，隐藏的函数将被调用：

{{#ref}}
ret2win/
{{#endref}}

### 栈 Shellcode

在这种情况下，攻击者可以在栈中放置一个 shellcode，并利用受控的 EIP/RIP 跳转到 shellcode 并执行任意代码：

{{#ref}}
stack-shellcode/
{{#endref}}

### ROP & Ret2... 技术

该技术是绕过前一种技术的主要保护措施的基本框架：**不可执行栈 (NX)**。它允许执行其他几种技术（ret2lib、ret2syscall...），通过滥用二进制中的现有指令来执行任意命令：

{{#ref}}
../rop-return-oriented-programing/
{{#endref}}

## 堆溢出

溢出不总是在栈中，它也可能发生在**堆**中，例如：

{{#ref}}
../libc-heap/heap-overflow.md
{{#endref}}

## 保护类型

有几种保护措施试图防止漏洞的利用，请查看它们：

{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
