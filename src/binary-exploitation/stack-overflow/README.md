# Stack Overflow

{{#include ../../banners/hacktricks-training.md}}

## What is a Stack Overflow

A **stack overflow** ni udhaifu unaotokea wakati programu inapoandika data zaidi kwenye stack kuliko ilivyopewa kushikilia. Data hii ya ziada it **andika nafasi ya kumbukumbu iliyo karibu**, ikisababisha uharibifu wa data halali, kuingiliwa kwa mtiririko wa udhibiti, na kwa uwezekano wa utekelezaji wa msimbo mbaya. Tatizo hili mara nyingi linatokea kutokana na matumizi ya kazi zisizo salama ambazo hazifanyi ukaguzi wa mipaka kwenye ingizo.

Tatizo kuu la kuandika tena ni kwamba **pointer ya maagizo iliyohifadhiwa (EIP/RIP)** na **pointer ya msingi iliyohifadhiwa (EBP/RBP)** za kurudi kwenye kazi ya awali zime **hifadhiwa kwenye stack**. Hivyo, mshambuliaji ataweza kuandika tena hizo na **kudhibiti mtiririko wa utekelezaji wa programu**.

Udhaifu huu kawaida hutokea kwa sababu kazi **inakopi ndani ya stack bytes zaidi kuliko kiasi kilichotengwa kwa ajili yake**, hivyo kuwa na uwezo wa kuandika tena sehemu nyingine za stack.

Baadhi ya kazi za kawaida zinazoweza kuwa na udhaifu huu ni: **`strcpy`, `strcat`, `sprintf`, `gets`**... Pia, kazi kama **`fgets`**, **`read` & `memcpy`** ambazo zinachukua **kiwango cha urefu**, zinaweza kutumika kwa njia yenye udhaifu ikiwa urefu ulioainishwa ni mkubwa kuliko ule uliotengwa.

Kwa mfano, kazi zifuatazo zinaweza kuwa na udhaifu:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Kutafuta ofseti za Stack Overflows

Njia ya kawaida zaidi ya kutafuta stack overflows ni kutoa ingizo kubwa sana la `A`s (kwa mfano, `python3 -c 'print("A"*1000)'`) na kutarajia `Segmentation Fault` ikionyesha kwamba **anwani `0x41414141` ilijaribu kufikiwa**.

Zaidi ya hayo, mara tu unapogundua kwamba kuna udhaifu wa Stack Overflow utahitaji kutafuta ofseti hadi iwezekane **kufuta anwani ya kurudi**, kwa hili mara nyingi hutumiwa **De Bruijn sequence.** Ambayo kwa alfabeti iliyotolewa ya ukubwa _k_ na subsequences za urefu _n_ ni **mfuatano wa mzunguko ambapo kila subsequence inayowezekana ya urefu _n_ inaonekana mara moja tu** kama subsequence iliyo karibu.

Kwa njia hii, badala ya kuhitaji kubaini ni ofseti ipi inahitajika kudhibiti EIP kwa mkono, inawezekana kutumia kama padding moja ya hizi sequences na kisha kutafuta ofseti ya bytes ambazo zilimaliza kufuta hiyo.

Inawezekana kutumia **pwntools** kwa hili:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
au **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Kutumia Stack Overflows

Wakati wa overflow (ikiwa saizi ya overflow ni kubwa vya kutosha) utaweza **kuandika upya** thamani za mabadiliko ya ndani ya stack hadi kufikia **EBP/RBP na EIP/RIP (au hata zaidi)**.\
Njia ya kawaida zaidi ya kutumia aina hii ya udhaifu ni kwa **kubadilisha anwani ya kurudi** ili wakati kazi inamalizika **mchakato wa udhibiti utaelekezwa popote mtumiaji alivyobainisha** katika kiashiria hiki.

Hata hivyo, katika hali nyingine labda tu **kuandika upya baadhi ya thamani za mabadiliko katika stack** inaweza kuwa ya kutosha kwa matumizi (kama katika changamoto rahisi za CTF).

### Ret2win

Katika aina hii ya changamoto za CTF, kuna **kazi** **ndani** ya binary ambayo **haitaitwa kamwe** na ambayo **unahitaji kuitwa ili kushinda**. Kwa ajili ya changamoto hizi unahitaji tu kupata **offset ya kuandika upya anwani ya kurudi** na **kupata anwani ya kazi** ya kuita (kawaida [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) itakuwa imezimwa) ili wakati kazi iliyo hatarini inarudi, kazi iliyofichwa itaitwa:

{{#ref}}
ret2win/
{{#endref}}

### Stack Shellcode

Katika hali hii mshambuliaji anaweza kuweka shellcode katika stack na kutumia EIP/RIP iliyo na udhibiti kuruka kwenye shellcode na kutekeleza msimbo wa kiholela:

{{#ref}}
stack-shellcode/
{{#endref}}

### ROP & Ret2... mbinu

Mbinu hii ni muundo wa msingi wa kupita ulinzi mkuu wa mbinu ya awali: **No executable stack (NX)**. Na inaruhusu kutekeleza mbinu kadhaa nyingine (ret2lib, ret2syscall...) ambazo zitamaliza kwa kutekeleza amri za kiholela kwa kutumia maagizo yaliyopo katika binary:

{{#ref}}
../rop-return-oriented-programing/
{{#endref}}

## Heap Overflows

Overflow si kila wakati utaenda kuwa katika stack, inaweza pia kuwa katika **heap** kwa mfano:

{{#ref}}
../libc-heap/heap-overflow.md
{{#endref}}

## Aina za ulinzi

Kuna ulinzi kadhaa zinazojaribu kuzuia matumizi ya udhaifu, angalia katika:

{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

### Mfano wa Uhalisia: CVE-2025-40596 (SonicWall SMA100)

Onyesho zuri la kwa nini **`sscanf` haipaswi kuaminika kamwe kwa kuchambua pembejeo zisizoaminika** lilionekana mwaka wa 2025 katika kifaa cha SonicWall SMA100 SSL-VPN. 
Ruti iliyo hatarini ndani ya `/usr/src/EasyAccess/bin/httpd` inajaribu kutoa toleo na kiungo kutoka kwa URI yoyote inayaanza na `/__api__/`:
```c
char version[3];
char endpoint[0x800] = {0};
/* simplified proto-type */
sscanf(uri, "%*[^/]/%2s/%s", version, endpoint);
```
1. Mabadiliko ya kwanza (`%2s`) hifadhi salama **bytes mbili** ndani ya `version` (kwa mfano, `"v1"`).
2. Mabadiliko ya pili (`%s`) **hayana mwelekeo wa urefu**, kwa hivyo `sscanf` itaendelea nakala **hadi byte ya kwanza ya NUL**.
3. Kwa sababu `endpoint` iko kwenye **stack** na ina **urefu wa 0x800 bytes**, kutoa njia ndefu zaidi ya 0x800 bytes inaharibu kila kitu kilichopo baada ya buffer ‑ ikiwa ni pamoja na **stack canary** na **anwani ya kurudi iliyohifadhiwa**.

Uthibitisho wa dhana wa mstari mmoja unatosha kuanzisha ajali **kabla ya uthibitisho**:
```python
import requests, warnings
warnings.filterwarnings('ignore')
url = "https://TARGET/__api__/v1/" + "A"*3000
requests.get(url, verify=False)
```
Hata ingawa stack canaries zinafunga mchakato, mshambuliaji bado anapata **Denial-of-Service** primitive (na, kwa uvujaji wa habari za ziada, labda utekelezaji wa msimbo). Somo ni rahisi:

* Daima toa **upana wa uwanja wa juu** (kwa mfano, `%511s`).
* Prefer njia salama kama `snprintf`/`strncpy_s`.

## References
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)

{{#include ../../banners/hacktricks-training.md}}
