# Stack Overflow

{{#include ../../banners/hacktricks-training.md}}

## Qu'est-ce qu'un débordement de pile

Un **débordement de pile** est une vulnérabilité qui se produit lorsqu'un programme écrit plus de données dans la pile qu'il n'est alloué pour en contenir. Ces données excédentaires vont **écraser l'espace mémoire adjacent**, entraînant la corruption de données valides, une perturbation du flux de contrôle, et potentiellement l'exécution de code malveillant. Ce problème survient souvent en raison de l'utilisation de fonctions non sécurisées qui ne vérifient pas les limites des entrées.

Le principal problème de cette écriture est que le **pointeur d'instruction sauvegardé (EIP/RIP)** et le **pointeur de base sauvegardé (EBP/RBP)** pour revenir à la fonction précédente sont **stockés sur la pile**. Par conséquent, un attaquant pourra écraser ceux-ci et **contrôler le flux d'exécution du programme**.

La vulnérabilité survient généralement parce qu'une fonction **copie dans la pile plus d'octets que la quantité qui lui est allouée**, permettant ainsi d'écraser d'autres parties de la pile.

Certaines fonctions courantes vulnérables à cela sont : **`strcpy`, `strcat`, `sprintf`, `gets`**... De plus, des fonctions comme **`fgets`**, **`read` & `memcpy`** qui prennent un **argument de longueur**, peuvent être utilisées de manière vulnérable si la longueur spécifiée est supérieure à celle allouée.

Par exemple, les fonctions suivantes pourraient être vulnérables :
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Trouver les offsets des débordements de pile

La façon la plus courante de trouver des débordements de pile est de donner une très grande entrée de `A`s (par exemple, `python3 -c 'print("A"*1000)'`) et de s'attendre à un `Segmentation Fault` indiquant que l'**adresse `0x41414141` a été tentée d'être accédée**.

De plus, une fois que vous avez trouvé qu'il y a une vulnérabilité de débordement de pile, vous devrez trouver l'offset jusqu'à ce qu'il soit possible de **surcharger l'adresse de retour**, pour cela, on utilise généralement une **séquence de De Bruijn.** Qui pour un alphabet donné de taille _k_ et des sous-séquences de longueur _n_ est une **séquence cyclique dans laquelle chaque sous-séquence possible de longueur \_n**\_\*\* apparaît exactement une fois\*\* en tant que sous-séquence contiguë.

De cette façon, au lieu de devoir déterminer manuellement quel offset est nécessaire pour contrôler l'EIP, il est possible d'utiliser comme remplissage l'une de ces séquences et ensuite de trouver l'offset des octets qui ont fini par le surcharger.

Il est possible d'utiliser **pwntools** pour cela :
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
ou **GEF** :
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Exploiter les débordements de pile

Lors d'un débordement (en supposant que la taille du débordement soit suffisamment grande), vous pourrez **écraser** les valeurs des variables locales dans la pile jusqu'à atteindre les **EBP/RBP et EIP/RIP sauvegardés (ou même plus)**.\
La manière la plus courante d'abuser de ce type de vulnérabilité est de **modifier l'adresse de retour** afin que lorsque la fonction se termine, le **flux de contrôle soit redirigé vers l'endroit spécifié par l'utilisateur** dans ce pointeur.

Cependant, dans d'autres scénarios, il se peut que **l'écrasement de certaines valeurs de variables dans la pile** soit suffisant pour l'exploitation (comme dans des défis CTF faciles).

### Ret2win

Dans ce type de défis CTF, il y a une **fonction** **dans** le binaire qui **n'est jamais appelée** et que **vous devez appeler pour gagner**. Pour ces défis, vous devez simplement trouver l'**offset pour écraser l'adresse de retour** et **trouver l'adresse de la fonction** à appeler (généralement [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) serait désactivé) afin que lorsque la fonction vulnérable retourne, la fonction cachée soit appelée :

{{#ref}}
ret2win/
{{#endref}}

### Shellcode de pile

Dans ce scénario, l'attaquant pourrait placer un shellcode dans la pile et abuser de l'EIP/RIP contrôlé pour sauter au shellcode et exécuter du code arbitraire :

{{#ref}}
stack-shellcode/
{{#endref}}

### Techniques ROP & Ret2...

Cette technique est le cadre fondamental pour contourner la principale protection de la technique précédente : **Pas de pile exécutable (NX)**. Et elle permet d'exécuter plusieurs autres techniques (ret2lib, ret2syscall...) qui finiront par exécuter des commandes arbitraires en abusant des instructions existantes dans le binaire :

{{#ref}}
../rop-return-oriented-programing/
{{#endref}}

## Débordements de tas

Un débordement ne se produira pas toujours dans la pile, il pourrait également se produire dans le **tas**, par exemple :

{{#ref}}
../libc-heap/heap-overflow.md
{{#endref}}

## Types de protections

Il existe plusieurs protections essayant de prévenir l'exploitation des vulnérabilités, consultez-les dans :

{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
