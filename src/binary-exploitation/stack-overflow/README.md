# Stack Overflow

{{#include ../../banners/hacktricks-training.md}}

## What is a Stack Overflow

**スタックオーバーフロー**は、プログラムがスタックに割り当てられたよりも多くのデータを書き込むときに発生する脆弱性です。この余分なデータは**隣接するメモリ空間を上書き**し、有効なデータの破損、制御フローの混乱、そして潜在的には悪意のあるコードの実行を引き起こします。この問題は、入力に対して境界チェックを行わない安全でない関数の使用によってしばしば発生します。

この上書きの主な問題は、**保存された命令ポインタ (EIP/RIP)** と**保存されたベースポインタ (EBP/RBP)** が前の関数に戻るために**スタックに保存されている**ことです。したがって、攻撃者はそれらを上書きし、**プログラムの実行フローを制御**できるようになります。

この脆弱性は通常、関数が**スタックに割り当てられたバイト数よりも多くのバイトをコピーする**ために発生し、したがってスタックの他の部分を上書きすることができます。

この脆弱性に対して一般的な関数には、**`strcpy`, `strcat`, `sprintf`, `gets`**などがあります。また、**`fgets`**、**`read` & `memcpy`**のように**長さ引数**を取る関数も、指定された長さが割り当てられたものより大きい場合に脆弱な方法で使用される可能性があります。

例えば、以下の関数は脆弱である可能性があります:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### スタックオーバーフローのオフセットを見つける

スタックオーバーフローを見つける最も一般的な方法は、非常に大きな入力の `A`s を与えることです（例: `python3 -c 'print("A"*1000)'`）そして、**アドレス `0x41414141` にアクセスしようとしたことを示す `Segmentation Fault` を期待します**。

さらに、スタックオーバーフローの脆弱性があることがわかったら、**リターンアドレスを上書きするために必要なオフセットを見つける必要があります**。これには通常、**De Bruijn シーケンス**が使用されます。これは、サイズ _k_ のアルファベットと長さ _n_ の部分列に対して、**長さ _n_ のすべての可能な部分列がちょうど一度だけ連続した部分列として現れる循環シーケンス**です。

この方法により、手動で EIP を制御するために必要なオフセットを特定する代わりに、これらのシーケンスの1つをパディングとして使用し、上書きされたバイトのオフセットを見つけることが可能です。

これには **pwntools** を使用することができます:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
または **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## スタックオーバーフローの悪用

オーバーフロー中（オーバーフローサイズが十分大きいと仮定すると）、スタック内のローカル変数の値を**上書き**することができ、保存された**EBP/RBPおよびEIP/RIP（またはそれ以上）**に達することができます。\
この種の脆弱性を悪用する最も一般的な方法は、**戻りアドレスを変更する**ことで、関数が終了すると**制御フローがユーザーが指定したポインタの場所にリダイレクトされる**ことです。

しかし、他のシナリオでは、スタック内の**いくつかの変数の値を上書きする**だけで悪用が可能な場合もあります（簡単なCTFチャレンジのように）。

### Ret2win

この種のCTFチャレンジでは、バイナリ内に**決して呼び出されない****関数**があり、**勝つために呼び出す必要があります**。これらのチャレンジでは、**戻りアドレスを上書きするオフセットを見つけ**、呼び出す**関数のアドレスを見つける**だけで済みます（通常、[**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html)は無効になります）ので、脆弱な関数が戻ると、隠れた関数が呼び出されます：

{{#ref}}
ret2win/
{{#endref}}

### スタックシェルコード

このシナリオでは、攻撃者はスタックにシェルコードを配置し、制御されたEIP/RIPを悪用してシェルコードにジャンプし、任意のコードを実行することができます：

{{#ref}}
stack-shellcode/
{{#endref}}

### ROP & Ret2... テクニック

このテクニックは、前述のテクニックの主要な保護を回避するための基本的なフレームワークです：**実行可能なスタックなし（NX）**。これにより、バイナリ内の既存の命令を悪用して任意のコマンドを実行する他のいくつかのテクニック（ret2lib、ret2syscallなど）を実行することが可能になります：

{{#ref}}
../rop-return-oriented-programing/
{{#endref}}

## ヒープオーバーフロー

オーバーフローは常にスタック内で発生するわけではなく、例えば**ヒープ**内で発生することもあります：

{{#ref}}
../libc-heap/heap-overflow.md
{{#endref}}

## 保護の種類

脆弱性の悪用を防ぐためのいくつかの保護があります。詳細は以下を確認してください：

{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

### 実世界の例: CVE-2025-40596 (SonicWall SMA100)

**`sscanf`は信頼できない入力の解析に決して信頼されるべきではない**理由の良いデモが、2025年にSonicWallのSMA100 SSL-VPNアプライアンスで現れました。\
`/usr/src/EasyAccess/bin/httpd`内の脆弱なルーチンは、`/__api__/`で始まる任意のURIからバージョンとエンドポイントを抽出しようとします。
```c
char version[3];
char endpoint[0x800] = {0};
/* simplified proto-type */
sscanf(uri, "%*[^/]/%2s/%s", version, endpoint);
```
1. 最初の変換（`%2s`）は、`version`に**2**バイトを安全に格納します（例：`"v1"`）。
2. 2番目の変換（`%s`）は**長さ指定子がありません**。したがって、`sscanf`は**最初のNULバイト**までコピーを続けます。
3. `endpoint`は**スタック**上にあり、**0x800バイトの長さ**があるため、0x800バイトより長いパスを提供すると、バッファの後にあるすべてのものが破損します ‑ **スタックカナリア**や**保存された戻りアドレス**を含む。

認証**前に**クラッシュを引き起こすには、1行の概念実証で十分です：
```python
import requests, warnings
warnings.filterwarnings('ignore')
url = "https://TARGET/__api__/v1/" + "A"*3000
requests.get(url, verify=False)
```
スタックカナリアがプロセスを中止させるにもかかわらず、攻撃者は依然として**サービス拒否**のプリミティブを得る（さらに情報漏洩があれば、コード実行も可能）。教訓はシンプルです：

* 常に**最大フィールド幅**を指定する（例：`%511s`）。
* `snprintf`/`strncpy_s`のような安全な代替手段を好む。

## 参考文献
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)

{{#include ../../banners/hacktricks-training.md}}
