# Stack Overflow

{{#include ../../banners/hacktricks-training.md}}

## What is a Stack Overflow

A **stack overflow** एक सुरक्षा कमी है जो तब होती है जब एक प्रोग्राम स्टैक में उस डेटा से अधिक डेटा लिखता है जितना कि उसे रखने के लिए आवंटित किया गया है। यह अतिरिक्त डेटा **सन्निकट मेमोरी स्थान को ओवरराइट** करेगा, जिससे वैध डेटा का भ्रष्टाचार, नियंत्रण प्रवाह में विघटन, और संभावित रूप से दुर्भावनापूर्ण कोड का निष्पादन हो सकता है। यह समस्या अक्सर असुरक्षित कार्यों के उपयोग के कारण उत्पन्न होती है जो इनपुट पर सीमा जांच नहीं करते हैं।

इस ओवरराइट की मुख्य समस्या यह है कि **सहेजा गया निर्देश सूचकांक (EIP/RIP)** और **सहेजा गया बेस सूचकांक (EBP/RBP)** जो पिछले कार्य में लौटने के लिए हैं, **स्टैक पर संग्रहीत** होते हैं। इसलिए, एक हमलावर उन्हें ओवरराइट करने में सक्षम होगा और **प्रोग्राम के निष्पादन प्रवाह को नियंत्रित** कर सकेगा।

यह सुरक्षा कमी आमतौर पर इसलिए उत्पन्न होती है क्योंकि एक कार्य **स्टैक के अंदर उन बाइट्स की अधिक संख्या की कॉपी करता है जितनी कि इसके लिए आवंटित की गई है**, जिससे अन्य स्टैक के हिस्सों को ओवरराइट करने में सक्षम होता है।

इससे प्रभावित कुछ सामान्य कार्य हैं: **`strcpy`, `strcat`, `sprintf`, `gets`**... इसके अलावा, ऐसे कार्य जैसे **`fgets`**, **`read` & `memcpy`** जो **लंबाई तर्क** लेते हैं, यदि निर्दिष्ट लंबाई आवंटित लंबाई से अधिक है तो उन्हें असुरक्षित तरीके से उपयोग किया जा सकता है।

उदाहरण के लिए, निम्नलिखित कार्य असुरक्षित हो सकते हैं:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Stack Overflows ऑफसेट्स खोजना

Stack overflows खोजने का सबसे सामान्य तरीका `A`s का बहुत बड़ा इनपुट देना है (जैसे `python3 -c 'print("A"*1000)'`) और एक `Segmentation Fault` की उम्मीद करना जो यह संकेत करता है कि **पता `0x41414141` को एक्सेस करने की कोशिश की गई थी**।

इसके अलावा, एक बार जब आप यह पता लगा लेते हैं कि Stack Overflow की कमजोरी है, तो आपको **रिटर्न एड्रेस को ओवरराइट करने** के लिए ऑफसेट खोजना होगा, इसके लिए आमतौर पर **De Bruijn अनुक्रम** का उपयोग किया जाता है। जो एक दिए गए वर्णमाला के आकार _k_ और लंबाई _n_ के उप अनुक्रमों के लिए एक **चक्रीय अनुक्रम है जिसमें लंबाई \_n**\_\*\* के हर संभव उप अनुक्रम** ठीक एक बार** एक सन्निहित उप अनुक्रम के रूप में प्रकट होता है।

इस तरह, EIP को नियंत्रित करने के लिए आवश्यक ऑफसेट को हाथ से खोजने के बजाय, इन अनुक्रमों में से एक को पैडिंग के रूप में उपयोग करना संभव है और फिर उन बाइट्स के ऑफसेट को खोजना संभव है जिन्होंने इसे ओवरराइट किया।

इसके लिए **pwntools** का उपयोग करना संभव है:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
या **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## स्टैक ओवरफ्लोज़ का शोषण

एक ओवरफ्लो के दौरान (मान लेते हैं कि ओवरफ्लो का आकार पर्याप्त बड़ा है) आप स्टैक के अंदर स्थानीय चर के मानों को **ओवरराइट** करने में सक्षम होंगे जब तक कि सहेजे गए **EBP/RBP और EIP/RIP (या इससे भी अधिक)** तक नहीं पहुँच जाते।\
इस प्रकार की भेद्यता का दुरुपयोग करने का सबसे सामान्य तरीका **रिटर्न पते को संशोधित करना** है ताकि जब फ़ंक्शन समाप्त हो, तो **नियंत्रण प्रवाह उस पते पर पुनर्निर्देशित हो जाए जो उपयोगकर्ता ने निर्दिष्ट किया है**।

हालांकि, अन्य परिदृश्यों में, केवल **स्टैक में कुछ चर के मानों को ओवरराइट करना** शोषण के लिए पर्याप्त हो सकता है (जैसे आसान CTF चुनौतियों में)।

### Ret2win

इस प्रकार की CTF चुनौतियों में, बाइनरी के अंदर एक **फंक्शन** है जो **कभी कॉल नहीं किया जाता** और जिसे **जीतने के लिए आपको कॉल करना है**। इन चुनौतियों के लिए आपको केवल **रिटर्न पते को ओवरराइट करने के लिए ऑफसेट** खोजने की आवश्यकता है और **कॉल करने के लिए फंक्शन का पता** खोजने की आवश्यकता है (आमतौर पर [**ASLR**](../common-binary-protections-and-bypasses/aslr/) अक्षम होगा) ताकि जब कमजोर फ़ंक्शन लौटे, तो छिपा हुआ फ़ंक्शन कॉल किया जाएगा:

{{#ref}}
ret2win/
{{#endref}}

### स्टैक शेलकोड

इस परिदृश्य में हमलावर स्टैक में एक शेलकोड रख सकता है और नियंत्रित EIP/RIP का दुरुपयोग करके शेलकोड पर कूद सकता है और मनमाने कोड को निष्पादित कर सकता है:

{{#ref}}
stack-shellcode/
{{#endref}}

### ROP & Ret2... तकनीकें

यह तकनीक पिछले तकनीक की मुख्य सुरक्षा को बायपास करने के लिए मौलिक ढांचा है: **कोई निष्पादन योग्य स्टैक (NX)**। और यह कई अन्य तकनीकों (ret2lib, ret2syscall...) को निष्पादित करने की अनुमति देती है जो बाइनरी में मौजूदा निर्देशों का दुरुपयोग करके मनमाने आदेशों को निष्पादित करेंगी:

{{#ref}}
../rop-return-oriented-programing/
{{#endref}}

## हीप ओवरफ्लोज़

एक ओवरफ्लो हमेशा स्टैक में नहीं होगा, यह **हीप** में भी हो सकता है, उदाहरण के लिए:

{{#ref}}
../libc-heap/heap-overflow.md
{{#endref}}

## सुरक्षा के प्रकार

भेद्यताओं के शोषण को रोकने के लिए कई सुरक्षा उपाय हैं, उन्हें देखें:

{{#ref}}
../common-binary-protections-and-bypasses/
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
