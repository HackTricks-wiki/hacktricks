# Desbordamiento de Enteros

{{#include ../banners/hacktricks-training.md}}

## Información Básica

En el corazón de un **desbordamiento de enteros** está la limitación impuesta por el **tamaño** de los tipos de datos en la programación de computadoras y la **interpretación** de los datos.

Por ejemplo, un **entero sin signo de 8 bits** puede representar valores de **0 a 255**. Si intentas almacenar el valor 256 en un entero sin signo de 8 bits, se envuelve a 0 debido a la limitación de su capacidad de almacenamiento. De manera similar, para un **entero sin signo de 16 bits**, que puede contener valores de **0 a 65,535**, agregar 1 a 65,535 hará que el valor vuelva a 0.

Además, un **entero con signo de 8 bits** puede representar valores de **-128 a 127**. Esto se debe a que un bit se utiliza para representar el signo (positivo o negativo), dejando 7 bits para representar la magnitud. El número más negativo se representa como **-128** (binario `10000000`), y el número más positivo es **127** (binario `01111111`).

### Valores máximos

Para las posibles **vulnerabilidades web**, es muy interesante conocer los valores máximos soportados:

{{#tabs}}
{{#tab name="Rust"}}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{{#endtab}}

{{#tab name="C"}}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
{{#endtab}}
{{#endtabs}}

## Ejemplos

### Desbordamiento puro

El resultado impreso será 0 ya que desbordamos el char:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Conversión de Firmado a No Firmado

Considere una situación en la que un entero firmado se lee de la entrada del usuario y luego se utiliza en un contexto que lo trata como un entero no firmado, sin la validación adecuada:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
En este ejemplo, si un usuario introduce un número negativo, se interpretará como un gran entero sin signo debido a la forma en que se interpretan los valores binarios, lo que puede llevar a un comportamiento inesperado.

### Otros Ejemplos

- [https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html)
- Solo se utiliza 1B para almacenar el tamaño de la contraseña, por lo que es posible desbordarlo y hacer que piense que su longitud es de 4, mientras que en realidad es 260 para eludir la protección de verificación de longitud.
- [https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html)

- Dado un par de números, encuentra usando z3 un nuevo número que multiplicado por el primero dará el segundo:&#x20;

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```

- [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
- Solo se utiliza 1B para almacenar el tamaño de la contraseña, por lo que es posible desbordarlo y hacer que piense que su longitud es de 4, mientras que en realidad es 260 para eludir la protección de verificación de longitud y sobrescribir en la pila la siguiente variable local y eludir ambas protecciones.

## ARM64

Esto **no cambia en ARM64** como puedes ver en [**esta publicación del blog**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/).

{{#include ../banners/hacktricks-training.md}}
