# Overflow de Inteiro

{{#include ../banners/hacktricks-training.md}}

## Informações Básicas

No coração de um **overflow de inteiro** está a limitação imposta pelo **tamanho** dos tipos de dados na programação de computadores e a **interpretação** dos dados.

Por exemplo, um **inteiro sem sinal de 8 bits** pode representar valores de **0 a 255**. Se você tentar armazenar o valor 256 em um inteiro sem sinal de 8 bits, ele retorna a 0 devido à limitação de sua capacidade de armazenamento. Da mesma forma, para um **inteiro sem sinal de 16 bits**, que pode conter valores de **0 a 65.535**, adicionar 1 a 65.535 fará com que o valor retorne a 0.

Além disso, um **inteiro com sinal de 8 bits** pode representar valores de **-128 a 127**. Isso ocorre porque um bit é usado para representar o sinal (positivo ou negativo), deixando 7 bits para representar a magnitude. O número mais negativo é representado como **-128** (binário `10000000`), e o número mais positivo é **127** (binário `01111111`).

### Valores Máximos

Para potenciais **vulnerabilidades na web**, é muito interessante conhecer os valores máximos suportados:

{{#tabs}}
{{#tab name="Rust"}}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{{#endtab}}

{{#tab name="C"}}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
{{#endtab}}
{{#endtabs}}

## Exemplos

### Overflow puro

O resultado impresso será 0, pois ultrapassamos o char:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Conversão de Assinado para Não Assinado

Considere uma situação em que um inteiro assinado é lido da entrada do usuário e, em seguida, usado em um contexto que o trata como um inteiro não assinado, sem a validação adequada:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
Neste exemplo, se um usuário inserir um número negativo, ele será interpretado como um grande inteiro sem sinal devido à forma como os valores binários são interpretados, potencialmente levando a um comportamento inesperado.

### Outros Exemplos

- [https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html)
- Apenas 1B é usado para armazenar o tamanho da senha, então é possível transbordá-lo e fazê-lo pensar que seu comprimento é 4, enquanto na verdade é 260, para contornar a proteção de verificação de comprimento.
- [https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html)

- Dado um par de números, descubra usando z3 um novo número que multiplicado pelo primeiro dará o segundo:

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```

- [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
- Apenas 1B é usado para armazenar o tamanho da senha, então é possível transbordá-lo e fazê-lo pensar que seu comprimento é 4, enquanto na verdade é 260, para contornar a proteção de verificação de comprimento e sobrescrever na pilha a próxima variável local e contornar ambas as proteções.

## ARM64

Isso **não muda no ARM64** como você pode ver em [**este post do blog**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/).

{{#include ../banners/hacktricks-training.md}}
