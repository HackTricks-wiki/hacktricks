# Integer Overflow

{{#include ../banners/hacktricks-training.md}}

## Basic Information

Στην καρδιά ενός **integer overflow** βρίσκεται ο περιορισμός που επιβάλλεται από το **μέγεθος** των τύπων δεδομένων στον προγραμματισμό υπολογιστών και την **ερμηνεία** των δεδομένων.

Για παράδειγμα, ένας **8-bit unsigned integer** μπορεί να αναπαραστήσει τιμές από **0 έως 255**. Αν προσπαθήσετε να αποθηκεύσετε την τιμή 256 σε έναν 8-bit unsigned integer, θα επανέλθει στο 0 λόγω του περιορισμού της χωρητικότητάς του. Ομοίως, για έναν **16-bit unsigned integer**, ο οποίος μπορεί να κρατήσει τιμές από **0 έως 65,535**, η προσθήκη 1 στο 65,535 θα επαναφέρει την τιμή στο 0.

Επιπλέον, ένας **8-bit signed integer** μπορεί να αναπαραστήσει τιμές από **-128 έως 127**. Αυτό συμβαίνει επειδή ένα bit χρησιμοποιείται για να αναπαραστήσει το πρόσημο (θετικό ή αρνητικό), αφήνοντας 7 bits για να αναπαραστήσουν το μέγεθος. Ο πιο αρνητικός αριθμός αναπαρίσταται ως **-128** (δυαδικό `10000000`), και ο πιο θετικός αριθμός είναι **127** (δυαδικό `01111111`).

### Max values

Για τις πιθανές **web vulnerabilities** είναι πολύ ενδιαφέρον να γνωρίζουμε τις μέγιστες υποστηριζόμενες τιμές:

{{#tabs}}
{{#tab name="Rust"}}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{{#endtab}}

{{#tab name="C"}}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
{{#endtab}}
{{#endtabs}}

## Παραδείγματα

### Καθαρή υπερχείλιση

Το εκτυπωμένο αποτέλεσμα θα είναι 0 καθώς υπερχείλαμε το char:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Signed to Unsigned Conversion

Σκεφτείτε μια κατάσταση όπου ένας υπογεγραμμένος ακέραιος διαβάζεται από την είσοδο του χρήστη και στη συνέχεια χρησιμοποιείται σε ένα πλαίσιο που τον αντιμετωπίζει ως άυλο ακέραιο, χωρίς κατάλληλη επικύρωση:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
Σε αυτό το παράδειγμα, αν ένας χρήστης εισάγει έναν αρνητικό αριθμό, θα ερμηνευτεί ως ένας μεγάλος μη υπογεγραμμένος ακέραιος λόγω του τρόπου που ερμηνεύονται οι δυαδικές τιμές, ενδεχομένως οδηγώντας σε απροσδόκητη συμπεριφορά.

### Άλλα Παραδείγματα

- [https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html)
- Μόνο 1B χρησιμοποιείται για να αποθηκεύσει το μέγεθος του κωδικού πρόσβασης, οπότε είναι δυνατό να υπερχειλίσει και να νομίζει ότι έχει μήκος 4 ενώ στην πραγματικότητα είναι 260 για να παρακάμψει την προστασία ελέγχου μήκους
- [https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html)

- Δεδομένων μερικών αριθμών, βρείτε χρησιμοποιώντας το z3 έναν νέο αριθμό που πολλαπλασιαζόμενος με τον πρώτο θα δώσει τον δεύτερο:

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```

- [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
- Μόνο 1B χρησιμοποιείται για να αποθηκεύσει το μέγεθος του κωδικού πρόσβασης, οπότε είναι δυνατό να υπερχειλίσει και να νομίζει ότι έχει μήκος 4 ενώ στην πραγματικότητα είναι 260 για να παρακάμψει την προστασία ελέγχου μήκους και να επαναγράψει στη στοίβα την επόμενη τοπική μεταβλητή και να παρακάμψει και τις δύο προστασίες

## ARM64

Αυτό **δεν αλλάζει σε ARM64** όπως μπορείτε να δείτε σε [**αυτή την ανάρτηση blog**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/).

{{#include ../banners/hacktricks-training.md}}
