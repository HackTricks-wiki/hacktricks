# Integer Overflow

{{#include ../banners/hacktricks-training.md}}

## Grundinformationen

Im Kern eines **Integer Overflow** steht die Einschränkung, die durch die **Größe** der Datentypen in der Computerprogrammierung und die **Interpretation** der Daten auferlegt wird.

Zum Beispiel kann ein **8-Bit unsigned integer** Werte von **0 bis 255** darstellen. Wenn Sie versuchen, den Wert 256 in einem 8-Bit unsigned integer zu speichern, wird er aufgrund der Begrenzung seiner Speicherkapazität auf 0 zurückgesetzt. Ähnlich verhält es sich bei einem **16-Bit unsigned integer**, der Werte von **0 bis 65.535** halten kann; das Hinzufügen von 1 zu 65.535 wird den Wert wieder auf 0 zurücksetzen.

Darüber hinaus kann ein **8-Bit signed integer** Werte von **-128 bis 127** darstellen. Dies liegt daran, dass ein Bit verwendet wird, um das Vorzeichen (positiv oder negativ) darzustellen, wodurch 7 Bits zur Darstellung der Größe verbleiben. Die negativste Zahl wird als **-128** (binär `10000000`) dargestellt, und die positivste Zahl ist **127** (binär `01111111`).

### Maximalwerte

Für potenzielle **Web-Sicherheitsanfälligkeiten** ist es sehr interessant, die maximal unterstützten Werte zu kennen:

{{#tabs}}
{{#tab name="Rust"}}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{{#endtab}}

{{#tab name="C"}}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
{{#endtab}}
{{#endtabs}}

## Beispiele

### Reiner Überlauf

Das gedruckte Ergebnis wird 0 sein, da wir das Zeichen überlaufen haben:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Signed to Unsigned Conversion

Betrachten Sie eine Situation, in der eine signierte Ganzzahl aus der Benutzereingabe gelesen und dann in einem Kontext verwendet wird, der sie als unsignierte Ganzzahl behandelt, ohne ordnungsgemäße Validierung:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
In diesem Beispiel wird eine negative Zahl als große unsigned Integer interpretiert, was auf die Art und Weise zurückzuführen ist, wie binäre Werte interpretiert werden, was potenziell zu unerwartetem Verhalten führen kann.

### Weitere Beispiele

- [https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html)
- Es wird nur 1B verwendet, um die Größe des Passworts zu speichern, sodass es möglich ist, es zu überlaufen und es glauben zu lassen, dass es eine Länge von 4 hat, während es tatsächlich 260 ist, um den Schutz der Längenüberprüfung zu umgehen.
- [https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html)

- Gegeben ein paar Zahlen, finde mit z3 eine neue Zahl, die multipliziert mit der ersten die zweite ergibt:&#x20;

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```

- [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
- Es wird nur 1B verwendet, um die Größe des Passworts zu speichern, sodass es möglich ist, es zu überlaufen und es glauben zu lassen, dass es eine Länge von 4 hat, während es tatsächlich 260 ist, um den Schutz der Längenüberprüfung zu umgehen und die nächste lokale Variable im Stack zu überschreiben und beide Schutzmaßnahmen zu umgehen.

## ARM64

Dies **ändert sich nicht in ARM64**, wie Sie in [**diesem Blogbeitrag**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/) sehen können.

{{#include ../banners/hacktricks-training.md}}
