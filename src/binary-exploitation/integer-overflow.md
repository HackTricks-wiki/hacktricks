# Integer Overflow

{{#include ../banners/hacktricks-training.md}}

## Basic Information

**정수 오버플로우**의 핵심은 컴퓨터 프로그래밍에서 데이터 유형의 **크기**에 의해 부과된 제한과 데이터의 **해석**입니다.

예를 들어, **8비트 부호 없는 정수**는 **0에서 255**까지의 값을 나타낼 수 있습니다. 8비트 부호 없는 정수에 256의 값을 저장하려고 하면, 저장 용량의 제한으로 인해 0으로 돌아갑니다. 마찬가지로, **0에서 65,535**까지의 값을 저장할 수 있는 **16비트 부호 없는 정수**에 65,535에 1을 더하면 값이 다시 0으로 돌아갑니다.

또한, **8비트 부호 있는 정수**는 **-128에서 127**까지의 값을 나타낼 수 있습니다. 이는 한 비트가 부호(양수 또는 음수)를 나타내는 데 사용되므로 7비트가 크기를 나타내는 데 남습니다. 가장 작은 음수는 **-128**(이진 `10000000`)로 표현되고, 가장 큰 양수는 **127**(이진 `01111111`)로 표현됩니다.

### Max values

잠재적인 **웹 취약점**에 대해 최대 지원 값을 아는 것은 매우 흥미롭습니다:

{{#tabs}}
{{#tab name="Rust"}}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{{#endtab}}

{{#tab name="C"}}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
{{#endtab}}
{{#endtabs}}

## 예시

### 순수 오버플로우

출력된 결과는 0이 될 것입니다. 왜냐하면 우리는 char를 오버플로우했기 때문입니다:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Signed to Unsigned Conversion

사용자 입력에서 읽은 signed 정수가 적절한 검증 없이 unsigned 정수로 처리되는 상황을 고려해 보십시오:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
이 예제에서 사용자가 음수를 입력하면 이진 값이 해석되는 방식 때문에 큰 부호 없는 정수로 해석되어 예기치 않은 동작을 초래할 수 있습니다.

### 다른 예제들

- [https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/int_overflow_post/index.html)
- 비밀번호의 크기를 저장하는 데 1B만 사용되므로 이를 오버플로우하여 실제 길이가 260인 반면 길이가 4라고 생각하게 할 수 있습니다. 길이 검사 보호를 우회하기 위해서입니다.
- [https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer_exploitation/puzzle/index.html)

- 몇 개의 숫자가 주어졌을 때 z3를 사용하여 첫 번째 숫자와 곱해져 두 번째 숫자를 생성하는 새로운 숫자를 찾습니다:&#x20;

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```

- [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
- 비밀번호의 크기를 저장하는 데 1B만 사용되므로 이를 오버플로우하여 실제 길이가 260인 반면 길이가 4라고 생각하게 할 수 있습니다. 길이 검사 보호를 우회하고 스택에서 다음 지역 변수를 덮어쓰고 두 가지 보호를 모두 우회합니다.

## ARM64

이 **ARM64에서는 변경되지 않습니다**. [**이 블로그 게시물**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)에서 볼 수 있습니다.

{{#include ../banners/hacktricks-training.md}}
