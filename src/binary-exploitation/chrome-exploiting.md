# Експлуатація Chrome

{{#include ../banners/hacktricks-training.md}}

> Ця сторінка надає високорівневий, але **практичний** огляд сучасного "full-chain" робочого процесу експлуатації Google Chrome 130, базованого на серії досліджень **“101 Chrome Exploitation”** (Part-0 — Preface).
> Мета — надати pentesters та exploit-developers мінімальний набір знань, необхідних для відтворення або адаптації технік для власних досліджень.

## 1. Огляд архітектури Chrome
Розуміння attack surface вимагає знати, де виконується код і які sandboxes застосовуються.

<details>
<summary>Розташування процесів Chrome та структура sandbox</summary>
```text
+-------------------------------------------------------------------------+
|                             Chrome Browser                              |
|                                                                         |
|  +----------------------------+      +-----------------------------+    |
|  |      Renderer Process      |      |    Browser/main Process     |    |
|  |  [No direct OS access]     |      |  [OS access]                |    |
|  |  +----------------------+   |      |                             |    |
|  |  |    V8 Sandbox        |   |      |                             |    |
|  |  |  [JavaScript / Wasm] |   |      |                             |    |
|  |  +----------------------+   |      |                             |    |
|  +----------------------------+      +-----------------------------+    |
|               |           IPC/Mojo              |                       |
|               V                                    |                     |
|  +----------------------------+                   |                     |
|  |        GPU Process         |                   |                     |
|  |  [Restricted OS access]    |                   |                     |
|  +----------------------------+                   |                     |
+-------------------------------------------------------------------------+
```
</details>

Багаторівневий захист у глибину:

* **V8 sandbox** (Isolate): дозволи пам'яті обмежені, щоб запобігти довільному читанню/запису з JITed JS / Wasm.
* **Renderer ↔ Browser split** забезпечується через передавання повідомлень **Mojo/IPC**; рендерер *не має* нативного доступу до FS/network.
* **OS sandboxes** додатково ізолюють кожен процес (Windows Integrity Levels / `seccomp-bpf` / macOS sandbox profiles).

Отже *remote* атакуючому потрібні **три** послідовні примітиви:

1. Pошкодження пам'яті в V8, щоб отримати **arbitrary RW inside the V8 heap**.
2. Друга уразливість, що дозволяє атакуючому **escape the V8 sandbox to full renderer memory**.
3. Остаточний sandbox-escape (часто логіка, а не пошкодження пам'яті) для виконання коду **outside of the Chrome OS sandbox**.

---

## 2. Етап 1 – WebAssembly Type-Confusion (CVE-2025-0291)

Проблема в оптимізації TurboFan’s **Turboshaft** неправильно класифікує **WasmGC reference types**, коли значення продукується і споживається всередині *single basic block loop*.

Наслідок:
* Компілятор **пропускає перевірку типу**, трактуючи *reference* (`externref/anyref`) як *int64*.
* Сфабрикований Wasm дозволяє накладати заголовок JS-об'єкта на дані, контрольовані атакуючим → <code>addrOf()</code> & <code>fakeObj()</code> **AAW / AAR primitives**.

Мінімальний PoC (фрагмент):
```WebAssembly
(module
(type $t0 (func (param externref) (result externref)))
(func $f (param $p externref) (result externref)
(local $l externref)
block $exit
loop $loop
local.get $p      ;; value with real ref-type
;; compiler incorrectly re-uses it as int64 in the same block
br_if $exit       ;; exit condition keeps us single-block
br   $loop
end
end)
(export "f" (func $f)))
```
Спровокувати оптимізацію & spray objects from JS:
```js
const wasmMod = new WebAssembly.Module(bytes);
const wasmInst = new WebAssembly.Instance(wasmMod);
const f = wasmInst.exports.f;

for (let i = 0; i < 1e5; ++i) f({});   // warm-up for JIT

// primitives
let victim   = {m: 13.37};
let fake     = arbitrary_data_backed_typedarray;
let addrVict = addrOf(victim);
```
Outcome: **arbitrary read/write within V8**.

---

## 3. Етап 2 – Втеча з V8 Sandbox (issue 379140430)

Коли Wasm function проходить Tier-Up-компіляцію, генерується **JS ↔ Wasm wrapper**. Баг невідповідності сигнатур змушує wrapper записувати за кінцем надійного **`Tuple2`** об'єкта, коли Wasm function ре-оптимізується *поки ще на стеці*.

Перезапис двох 64-бітних полів об'єкта `Tuple2` надає **read/write на будь-яку адресу всередині Renderer process**, фактично обходячи V8 sandbox.

Ключові кроки експлойту:
1. Помістити function у стан **Tier-Up** шляхом чергування turbofan/baseline коду.
2. Триггернути Tier-Up, зберігаючи посилання на стеці (`Function.prototype.apply`).
3. Використати Stage-1 AAR/AAW щоб знайти й пошкодити суміжний `Tuple2`.

Ідентифікація wrapper:
```js
function wrapperGen(arg) {
return f(arg);
}
%WasmTierUpFunction(f);          // force tier-up (internals-only flag)
wrapperGen(0x1337n);
```
Після пошкодження пам'яті ми отримуємо повнофункціональний **renderer R/W primitive**.

---

## 4. Stage 3 – Renderer → OS Sandbox Escape (CVE-2024-11114)

The **Mojo** IPC interface `blink.mojom.DragService.startDragging()` can be called from the Renderer with *частково довіреними* parameters.  By crafting a `DragData` structure pointing to an **довільний шлях до файлу** the renderer convinces the browser to perform a *нативну* drag-and-drop **поза renderer sandbox**.

Зловживаючи цим, ми можемо програмно «перетягнути» шкідливий EXE (попередньо поміщений у доступне для запису всім розташування) на Desktop, де Windows автоматично виконує певні типи файлів після їх скидання.

Приклад (спрощено):
```js
const payloadPath = "C:\\Users\\Public\\explorer.exe";

chrome.webview.postMessage({
type: "DragStart",
data: {
title: "MyFile",
file_path: payloadPath,
mime_type: "application/x-msdownload"
}
});
```
No additional memory corruption is necessary – the **logic flaw** gives us arbitrary file execution with the user’s privileges.

---

## 5. Повний ланцюг експлуатації

1. **Користувач відвідує** шкідливу веб-сторінку.
2. **Етап 1**: Wasm module зловживає CVE-2025-0291 → V8 heap AAR/AAW.
3. **Етап 2**: Невідповідність wrapper'а пошкоджує `Tuple2` → втеча з V8 sandbox.
4. **Етап 3**: `startDragging()` IPC → втеча з OS sandbox та виконання payload.

Результат: **Remote Code Execution (RCE)** на хості (Chrome 130, Windows/Linux/macOS).

---

## 6. Налаштування лабораторії та налагодження
```bash
# Spin-up local HTTP server w/ PoCs
npm i -g http-server
git clone https://github.com/Petitoto/chromium-exploit-dev
cd chromium-exploit-dev
http-server -p 8000 -c -1

# Windows kernel debugging
"C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\windbgx.exe" -symbolpath srv*C:\symbols*https://msdl.microsoft.com/download/symbols
```
Корисні прапорці при запуску *розробницької* збірки Chrome:
```bash
chrome.exe --no-sandbox --disable-gpu --single-process --js-flags="--allow-natives-syntax"
```
## 7. Renderer → kernel ресурс для втечі

Коли renderer exploit потребує kernel pivot, який залишається в межах seccomp profile, зловживання AF_UNIX `MSG_OOB` sockets, що все ще доступні в межах sandbox, дає детермінований шлях. Перегляньте case-study Linux kernel exploitation нижче щодо SKB UAF → kernel RCE chain:

{{#ref}}
linux-kernel-exploitation/af-unix-msg-oob-uaf-skb-primitives.md
{{#endref}}

---

## Висновки

* **WebAssembly JIT bugs** залишаються надійною точкою входу – система типів ще молода.
* Отримання другої memory-corruption bug всередині V8 (наприклад, wrapper mismatch) суттєво спрощує **V8-sandbox escape**.
* Логічні слабкості в привілейованих Mojo IPC інтерфейсах часто достатні для **final sandbox escape** – стежте за *non-memory* багами.



## Посилання
- [101 Chrome Exploitation — Part 0 (Preface)](https://opzero.ru/en/press/101-chrome-exploitation-part-0-preface/)
- [Chromium security architecture](https://chromium.org/developers/design-documents/security)
{{#include ../banners/hacktricks-training.md}}
