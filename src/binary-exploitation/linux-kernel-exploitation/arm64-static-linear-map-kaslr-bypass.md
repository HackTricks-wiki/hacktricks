# Linux arm64 Static Linear Map KASLR Bypass

{{#include ../../banners/hacktricks-training.md}}

## Muhtasari

Kernel za Android zinazotengenezwa kwa arm64 karibu kila mara zinawezeshwa **`CONFIG_ARM64_VA_BITS=39`** (3-level paging) na **`CONFIG_MEMORY_HOTPLUG=y`**. Kwa nafasi ya virtual ya kernel ya 512 GiB tu inayopatikana, waendelezaji wa Linux waliamua kuwekea msingi **linear map** kwenye kernel VA ya chini kabisa ili RAM mpya inayoongezwa kwa hot-plug iweze kupanua ramani kuelekea juu. Tangu commit `1db780bafa4c`, arm64 haijaribu hata kutawanya kwa nasibu nafasi hiyo tena, ambayo inamaanisha:

- `PAGE_OFFSET = 0xffffff8000000000` imejengwa ndani.
- `PHYS_OFFSET` inapatikana kutoka kwa `memstart_addr` iliyotolewa, ambayo kwenye vifaa vya Android vya hisa ni takriban thabiti (0x80000000 kwa sasa).

Kama matokeo, **kila ukurasa wa kimwili una anwani ya virtual ya deterministic ya linear-map ambayo haina uhusiano na KASLR slide**:
```c
#define phys_to_virt(p) (((unsigned long)(p) - 0x80000000UL) | 0xffffff8000000000UL)
```
Ikiwa mshambuliaji anaweza kujifunza au kuathiri anwani ya kimwili (kernel object, PFN kutoka `/proc/pagemap`, au hata user-controlled page), wanajua mara moja anwani ya virtual ya kernel inayolingana bila leaking randomized primary kernel mapping.

## Kusoma `memstart_addr` na kuthibitisha uongofu

`memstart_addr` is exported in `/proc/kallsyms` and can be read on rooted devices or via any arbitrary kernel-read primitive. Project Zero used Jann Horn's tracing-BPF helper (`bpf_arb_read`) to dump it directly:
```bash
grep memstart /proc/kallsyms
# ... obtains memstart_addr virtual address
./bpf_arb_read <addr_of_memstart_addr> 8
```
The bytes `00 00 00 80 00 00 00 00` zinaonyesha `memstart_addr = 0x80000000`. Mara `PAGE_OFFSET` na `PHYS_OFFSET` zinapowekwa, arm64 linear map ni mageuzi ya affine ya hali ya kimya ya anwani yoyote ya kimwili.

## Kupata anwani za `.data` ambazo hazibadiliki kwenye vifaa vinavyo kuwa na kernel physbase iliyowekwa

Many Pixels bado huwa zinakatafuta kernel kwenye **`phys_kernel_base = 0x80010000`** kila wakati wa boot (inaonekana katika `/proc/iomem`). Kuunganisha hilo na transform ya kimya kunatoa anwani zinazodumu baada ya reboot kwa alama yoyote ya data:

1. Rekodi anwani ya kernel iliyorajishwa ya `_stext` na alama unayolenga kutoka `/proc/kallsyms` (au kutoka kwa `vmlinux` sahihi).
2. Hesabu offset: `offset = sym_virt - _stext_virt`.
3. Ongeza physbase ya boot ya kimya: `phys_sym = 0x80010000 + offset`.
4. Badilisha kuwa linear-map VA: `virt_sym = phys_to_virt(phys_sym)`.

Mfano (`modprobe_path` on a Pixel 9): `offset = 0x1fe2398`, `phys = 0x81ff2398`, `virt = 0xffffff8001ff2398`. Baada ya reboots nyingi, `bpf_arb_read 0xffffff8001ff2398` hurudisha bytes zile zile, hivyo payloads za exploit zinaweza kutibu `0xffffff8000010000` kama base ya synthetic, isiyotengenezwa-kubwa kwa offsets zote za `.data`.

Mapping hii ni **RW**, kwa hivyo primitive yoyote inayoweza kuweka data ya attacker katika kernel virtual space (double free, UAF, non-paged heap write, n.k.) inaweza kubadilisha credentials, LSM hooks, au dispatch tables bila kamwe kutoa true KASLR slide. Kizuizi pekee ni kwamba `.text` imepangwa kama non-executable katika linear map, hivyo gadget hunting bado inahitaji leak ya jadi.

## PFN spraying wakati physbase ya kernel imewezeshwa kwa random

Vendors kama Samsung hufanya randomize load PFN ya kernel, lakini linear map ya kimya bado inatumika kwa sababu allocation ya PFN haijarandom kabisa:

1. **Spray user pages**: `mmap()` ~5 GiB, gusa kila ukurasa ili ufute ndani.
2. **Harvest PFNs**: soma `/proc/pagemap` kwa kila ukurasa (au tumia PFN leak nyingine) kukusanya orodha ya PFN zinazotumika.
3. **Repeat and profile**: reboot, rerun 100×, jenga histogram inayoonyesha ni mara ngapi kila PFN ilikuwa chini ya udhibiti wa attacker. PFNs nyingine zinaonekana kuwa white-hot (allocated 100/100 times shortly after boot).
4. **Convert PFN → kernel VA**:
- `phys = (pfn << PAGE_SHIFT) + offset_in_page`
- `virt = phys_to_virt(phys)`
5. **Forge kernel objects in those pages** na elekeza victim pointers (UAF, overflow, n.k.) kwenda anwani za linear-map zinazojulikana.

Kwa kuwa linear map ni identity-mapped RW memory, tekniki hii inakuwezesha kuweka data inayodhibitiwa kabisa na attacker kwenye deterministic kernel VAs hata wakati basi halisi la kernel linaposogea. Exploits zinaweza kujenga kabla fake `file_operations`, `cred`, au refcount structures ndani ya sprayed pages kisha kutengeneza pivot kwa kernel pointers zilizopo ndani yao.

## Kazi ya vitendo kwa exploits za arm64 Android

1. **Info gathering**
- Root au tumia kernel read primitive ili dump `memstart_addr`, `_stext`, na alama unayolenga kutoka `/proc/kallsyms`.
- Kwa Pixels, amini physbase ya kimya kutoka `/proc/iomem`; kwa vifaa vingine, andaa PFN profiler.
2. **Address calculation**
- Tumia hisabati ya offset iliyo juu na cache VA za linear-map zilizopatikana katika exploit yako.
- Kwa PFN spraying, hifadhi orodha ya PFNs "reliable" ambazo mara kwa mara zinaenda kwenye memory ya attacker.
3. **Exploit integration**
- Wakati arbitrary write inapatikana, patch moja kwa moja malengo kama `modprobe_path`, `init_cred`, au security ops arrays kwenye anwani zilizopangiliwa.
- Wakati tu heap corruption ipo, tengeneza fake objects katika kurasa zilizojulikana na ujaribu kupindua victim pointers kwenda hizo linear-map VAs.
4. **Verification**
- Tumia `bpf_arb_read` au primitive yoyote ya usome salama kukagua kwamba anwani iliyohesabiwa ina bytes zinazotarajiwa kabla ya kuandika kinyume.

Kazi hii inaondoa hatua ya KASLR-leak kwa exploits za kernel zinazolenga data kwenye Android, ambayo inashusha kwa kiasi kikubwa ugumu wa exploit na kuboresha uaminifu.

## References

- [Project Zero - Defeating arm64 Linux KASLR by Exploiting the Static Linear Map and Kernel Physical Placement on Android](https://projectzero.google/2025/11/defeating-kaslr-by-doing-nothing-at-all.html)

{{#include ../../banners/hacktricks-training.md}}
