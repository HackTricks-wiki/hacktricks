# Linux arm64 Static Linear Map KASLR Bypass

{{#include ../../banners/hacktricks-training.md}}

## Επισκόπηση

Τα Android kernels που χτίζονται για arm64 σχεδόν καθολικά ενεργοποιούν **`CONFIG_ARM64_VA_BITS=39`** (σελιδοποίηση 3 επιπέδων) και **`CONFIG_MEMORY_HOTPLUG=y`**. Με διαθέσιμο μόνο 512 GiB χώρο εικονικής μνήμης του kernel, οι προγραμματιστές του Linux επέλεξαν να αγκυρώσουν το **linear map** στην χαμηλότερη δυνατή kernel VA ώστε η μελλοντική hot-plug μνήμη RAM να μπορεί απλώς να επεκτείνει τον χάρτη προς τα πάνω. Από το commit `1db780bafa4c`, το arm64 δεν επιχειρεί καν πλέον να τυχαιοποιήσει αυτή την τοποθέτηση, που σημαίνει:

- `PAGE_OFFSET = 0xffffff8000000000` είναι ενσωματωμένο.
- `PHYS_OFFSET` προέρχεται από το εξαγόμενο `memstart_addr`, το οποίο σε stock Android συσκευές είναι ουσιαστικά σταθερό (σήμερα 0x80000000).

Ως συνέπεια, **κάθε φυσική σελίδα έχει μία ντετερμινιστική linear-map virtual address που είναι ανεξάρτητη από το KASLR slide**:
```c
#define phys_to_virt(p) (((unsigned long)(p) - 0x80000000UL) | 0xffffff8000000000UL)
```
If an attacker can learn or influence a physical address (kernel object, PFN from `/proc/pagemap`, or even a user-controlled page), they instantly know the corresponding kernel virtual address without leaking the randomized primary kernel mapping.

## Ανάγνωση του `memstart_addr` και επιβεβαίωση της μετατροπής

`memstart_addr` εξάγεται στο `/proc/kallsyms` και μπορεί να διαβαστεί σε rooted devices ή μέσω οποιουδήποτε arbitrary kernel-read primitive. Project Zero χρησιμοποίησε το tracing-BPF helper του Jann Horn (`bpf_arb_read`) για να το dump απευθείας:
```bash
grep memstart /proc/kallsyms
# ... obtains memstart_addr virtual address
./bpf_arb_read <addr_of_memstart_addr> 8
```
Τα bytes `00 00 00 80 00 00 00 00` επιβεβαιώνουν `memstart_addr = 0x80000000`. Μόλις `PAGE_OFFSET` και `PHYS_OFFSET` καθοριστούν, ο arm64 linear map είναι μια στατική αφινική μετατροπή οποιασδήποτε φυσικής διεύθυνσης.

## Παράγωγη σταθερών `.data` διευθύνσεων σε συσκευές με σταθερό kernel physbase

Πολλά Pixels εξακολουθούν να αποσυμπιέζουν τον kernel στο **`phys_kernel_base = 0x80010000`** σε κάθε εκκίνηση (ορατό στο `/proc/iomem`). Συνδυάζοντας αυτό με τη στατική μετατροπή προκύπτουν διευθύνσεις που παραμένουν σταθερές μεταξύ επανεκκινήσεων για οποιοδήποτε data symbol:

1. Καταγράψτε τη randomized kernel virtual address του `_stext` και του συμβόλου-στόχου από `/proc/kallsyms` (ή από το ακριβές `vmlinux`).
2. Υπολογίστε το offset: `offset = sym_virt - _stext_virt`.
3. Προσθέστε το στατικό boot-time physbase: `phys_sym = 0x80010000 + offset`.
4. Μετατρέψτε σε linear-map VA: `virt_sym = phys_to_virt(phys_sym)`.

Παράδειγμα (`modprobe_path` σε ένα Pixel 9): `offset = 0x1fe2398`, `phys = 0x81ff2398`, `virt = 0xffffff8001ff2398`. Μετά από πολλαπλές επανεκκινήσεις, `bpf_arb_read 0xffffff8001ff2398` επιστρέφει τα ίδια bytes, έτσι τα exploit payloads μπορούν να θεωρούν `0xffffff8000010000` ως συνθετική, μη-randomized βάση για όλα τα `.data` offsets.

Αυτή η αντιστοίχιση είναι **RW**, οπότε οποιοδήποτε primitive μπορεί να τοποθετήσει attacker data στον kernel virtual χώρο (double free, UAF, non-paged heap write, κ.λπ.) μπορεί να τροποποιήσει credentials, LSM hooks ή dispatch tables χωρίς ποτέ να leakάρει το πραγματικό KASLR slide. Η μόνη περιοριστική παράμετρος είναι ότι η `.text` είναι mapped ως non-executable στον linear map, οπότε το gadget hunting εξακολουθεί να απαιτεί έναν παραδοσιακό leak.

## PFN spraying when the kernel physbase is randomized

Vendor-ες όπως η Samsung randomize το kernel load PFN, αλλά ο static linear map εξακολουθεί να είναι εκμεταλλεύσιμος επειδή η κατανομή PFN δεν είναι πλήρως τυχαία:

1. **Spray user pages**: `mmap()` ~5 GiB, αγγίξτε κάθε σελίδα για να την faultάρετε.
2. **Harvest PFNs**: διαβάστε `/proc/pagemap` για κάθε σελίδα (ή χρησιμοποιήστε κάποιο άλλο PFN leak) για να συλλέξετε τη λίστα backing PFN.
3. **Repeat and profile**: επανεκκινήστε, τρέξτε ξανά 100×, φτιάξτε ένα ιστόγραμμα που δείχνει πόσο συχνά κάθε PFN ήταν υπό τον έλεγχο του attacker. Μερικά PFNs είναι white-hot (allocated 100/100 φορές λίγο μετά την εκκίνηση).
4. **Convert PFN → kernel VA**:
- `phys = (pfn << PAGE_SHIFT) + offset_in_page`
- `virt = phys_to_virt(phys)`
5. **Forge kernel objects in those pages** και κατευθύνετε τους victim pointers (UAF, overflow, κ.λπ.) προς τις γνωστές linear-map διευθύνσεις.

Επειδή ο linear map είναι identity-mapped RW memory, αυτή η τεχνική σας επιτρέπει να τοποθετήσετε πλήρως attacker-controlled data σε ντετερμινιστικά kernel VAs ακόμα κι όταν η πραγματική βάση του kernel μετακινείται. Τα exploits μπορούν να προκατασκευάσουν ψεύτικα `file_operations`, `cred` ή refcount structures μέσα στις sprayed σελίδες και στη συνέχεια να pivot-άρουν υπάρχοντες kernel pointers σε αυτές.

## Πρακτική ροή εργασίας για arm64 Android exploits

1. **Συλλογή πληροφοριών**
- Κάντε root ή χρησιμοποιήστε ένα kernel read primitive για να εξάγετε `memstart_addr`, `_stext`, και το σύμβολο-στόχο από `/proc/kallsyms`.
- Σε Pixels, εμπιστευτείτε το στατικό physbase από το `/proc/iomem`; σε άλλες συσκευές, προετοιμάστε τον PFN profiler.
2. **Υπολογισμός διευθύνσεων**
- Εφαρμόστε τα παραπάνω μαθηματικά offset και αποθηκεύστε στις cache τα προκύπτοντα linear-map VAs στο exploit σας.
- Για PFN spraying, κρατήστε μια λίστα με "reliable" PFNs που επανειλημμένα καταλήγουν σε attacker memory.
3. **Ενσωμάτωση exploit**
- Όταν υπάρχει arbitrary write, κάντε άμεσο patch σε στόχους όπως `modprobe_path`, `init_cred` ή πίνακες security ops στις προϋπολογισμένες διευθύνσεις.
- Όταν υπάρχει μόνο heap corruption, δημιουργήστε ψεύτικα αντικείμενα στις γνωστές επιτηρούμενες σελίδες και επαναδείξτε τους victim pointers σε αυτές τις linear-map VAs.
4. **Επαλήθευση**
- Χρησιμοποιήστε `bpf_arb_read` ή οποιοδήποτε ασφαλές read primitive για να ελέγξετε ότι η υπολογισμένη διεύθυνση περιέχει τα αναμενόμενα bytes πριν από καταστροφικές εγγραφές.

Αυτή η ροή εργασίας αφαιρεί το στάδιο του KASLR-leak για data-centric kernel exploits σε Android, κάτι που μειώνει δραστικά την πολυπλοκότητα των exploits και βελτιώνει την αξιοπιστία.

## Αναφορές

- [Project Zero - Defeating arm64 Linux KASLR by Exploiting the Static Linear Map and Kernel Physical Placement on Android](https://projectzero.google/2025/11/defeating-kaslr-by-doing-nothing-at-all.html)

{{#include ../../banners/hacktricks-training.md}}
