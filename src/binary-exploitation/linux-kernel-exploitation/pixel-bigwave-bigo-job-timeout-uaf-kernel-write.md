# Pixel BigWave BIGO timeout race UAF → 2KB kernel write from mediacodec

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- Vanaf die SELinux-beperkte **mediacodec**-konteks is `/dev/bigwave` (Pixel AV1 hardwareversneller) bereikbaar. 'n Agterstand van jobs laat `BIGO_IOCX_PROCESS` sy **16s wait_for_completion_timeout()** tref en terugkeer, terwyl die worker-thread terselfdertyd dieselfde inline `job`-struktuur uit die tou uithaal.
- Deur die FD onmiddellik te sluit, word `struct bigo_inst` vrygestel (wat `struct bigo_job` insluit). Die worker rekonstrueer `inst = container_of(job, ...)` en gebruik later vrygestelde velde soos **`job->regs`** binne `bigo_run_job()`, wat 'n **Use-After-Free op die inline job/inst** veroorsaak.
- `bigo_pull_regs(core, job->regs)` voer `memcpy_fromio(regs, core->base, core->regs_size)` uit. Deur die vrygestelde slab te herwin en `job->regs` oor te skryf, kry 'n aanvaller 'n **~2144-byte arbitrary kernel write** na 'n gekose adres, met gedeeltelike beheer oor die bytes deur registerwaardes voor die timeout voor te programmeer.

## Attack surface mapping (SELinux → /dev reachability)

- Gebruik gereedskap soos **DriverCartographer** om apparaatnodes te enumereer wat vanaf 'n gegewe SELinux-domein toeganklik is. Ten spyte van mediacodec se beperkte beleid (software-dekoders moet in 'n geïsoleerde konteks bly), het `/dev/bigwave` steeds bereikbaar gebly, wat 'n groot aanvalsoppervlakte aan post-media-RCE-kode blootgestel het.

## Vulnerability: BIGO_IOCX_PROCESS timeout vs worker

- Vloei: ioctl kopieer die gebruikersregister-buffer na `job->regs`, plaas die inline `job` in die tou, en roep dan `wait_for_completion_timeout(..., 16s)` aan. By timeout probeer dit die job uit die tou uit te haal/te kanselleer en keer terug na userspace.
- Intussen kan `bigo_worker_thread` net die selfde `job` uit die tou onttrek het:
```c
inst = container_of(job, struct bigo_inst, job);
bigo_push_regs(core, job->regs);
...
bigo_pull_regs(core, job->regs);   // memcpy_fromio(regs, core->base, core->regs_size)
*(u32 *)(job->regs + BIGO_REG_STAT) = status;
```
- As userspace die FD ná die timeout toemaak, word `inst`/`job` vrygestel terwyl die worker voortgaan om dit te gebruik → UAF. Geen sinkronisering koppel FD-leeftyd aan die worker-thread se job pointer nie.

## Oorsig van uitbuiting

1. **Backlog + timeout:** Queue genoeg jobs sodat die worker vertraag word, dan stuur `BIGO_IOCX_PROCESS` en laat dit die 16s timeout-pad tref.
2. **Free while in use:** Sodra ioctl terugkeer, voer `close(fd)` uit om `inst`/`job` te vry te stel terwyl die worker nog steeds die de-queued job loop.
3. **Reclaim + pointer control:** Spray reclaimers (bv. **Unix domain socket message** allocations) om die vrygestelde slab-slot te beset en die inline `job` oor te skryf, veral `job->regs`.
4. **Arbitrary write:** Wanneer `bigo_pull_regs()` loop, skryf `memcpy_fromio()` **core->regs_size (~2144 bytes)** vanaf MMIO na die deur-aanvaller-verskafte adres in `job->regs`, wat 'n groot write-what-where produseer sonder 'n KASLR leak.
5. **Data shaping:** Omdat registers eers vanuit user data geprogrammeer word (`bigo_push_regs`), stel hulle so dat die hardware nie uitvoer nie, en hou die teruggekopieerde register-beeld naby aanvaller-gekontroleerde bytes.

## Belangrike punte vir bestuurderhersieners

- Inline per-FD job structs wat aan async workers ingeryg word, moet verwysings hou wat timeout/cancel-paadjies oorleef; **closing an FD must synchronize with worker consumption**.
- Enige MMIO copy helpers (`memcpy_fromio`/`memcpy_toio`) wat buffer pointers uit jobs gebruik, moet geverifieer of gedupliseer word voordat hulle ingeryg word om UAF→write primitives te voorkom.

## Verwysings

- [Pixel 0-click (Part 2): Escaping the mediacodec sandbox via the BigWave driver](https://projectzero.google/2026/01/pixel-0-click-part-2.html)
- [Project Zero issue 426567975 – BigWave BIGO timeout UAF](https://project-zero.issues.chromium.org/issues/426567975)

{{#include ../../banners/hacktricks-training.md}}
