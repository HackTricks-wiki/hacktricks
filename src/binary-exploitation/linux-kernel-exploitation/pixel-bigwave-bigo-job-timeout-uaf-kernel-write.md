# Pixel BigWave BIGO timeout race UAF → 2KB kernel write from mediacodec

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- Vanaf die SELinux-beperkte **mediacodec** konteks is `/dev/bigwave` (Pixel AV1 hardware accelerator) bereikbaar. 'n Agterstand van jobs laat `BIGO_IOCX_PROCESS` sy **16s wait_for_completion_timeout()** tref en terugkeer terwyl die worker-thread gelyktydig dieselfde inline `job` struktuur uit die rye haal.
- Deur die FD onmiddellik te sluit vrymaak dit `struct bigo_inst` (wat `struct bigo_job` inkorporeer). Die worker herstel `inst = container_of(job, ...)` en gebruik later vrygelaat velde soos **`job->regs`** binne `bigo_run_job()`, wat 'n **Use-After-Free on the inline job/inst** tot gevolg het.
- `bigo_pull_regs(core, job->regs)` voer `memcpy_fromio(regs, core->base, core->regs_size)` uit. Deur die vrygemaakte slab te herwin en `job->regs` oor te skryf, kry 'n aanvaller 'n **~2144-byte arbitrary kernel write** na 'n gekose adres, met gedeeltelike beheer oor die bytes deur registerwaardes vooraf te programmeer voor die timeout.
- Geklassifiseer as **CVE-2025-36934**; gefikseer in die **2026-01-05 Pixel/2025-12-01 ASB** builds.

## Attack surface mapping (SELinux → /dev reachability)

- Gebruik gereedskap soos **DriverCartographer** om device nodes te enumereer wat van 'n gegewe SELinux-domein toeganklik is. Ondanks mediacodec se beperkte beleid (software decoders moet in 'n geïsoleerde konteks bly), het `/dev/bigwave` steeds bereikbaar gebly, waardeur 'n groot aanvalsvlak aan post-media-RCE kode blootgestel is.

## Vulnerability: BIGO_IOCX_PROCESS timeout vs worker

- Vloei: ioctl kopieer die user register buffer na `job->regs`, sit die inline `job` in die ry, dan word `wait_for_completion_timeout(..., 16s)` aangeroep. By timeout probeer dit ontkoppel/annuleer en keer terug na userspace.
- Intussen kan `bigo_worker_thread` net die selfde `job` uit die ry gehaal het:
```c
inst = container_of(job, struct bigo_inst, job);
bigo_push_regs(core, job->regs);
...
bigo_pull_regs(core, job->regs);   // memcpy_fromio(regs, core->base, core->regs_size)
*(u32 *)(job->regs + BIGO_REG_STAT) = status;
```
- As userspace die FD sluit na die timeout, word `inst`/`job` vrygemaak terwyl die worker hulle steeds gebruik → UAF. Geen sinkronisasie bind die FD-leeftyd aan die worker thread se job pointer nie.

## Oorsig van uitbuiting

1. **Backlog + timeout:** Plaas genoeg jobs in die wagry sodat die worker vertraag word, voer dan `BIGO_IOCX_PROCESS` uit en laat dit die 16s timeout-pad tref.
2. **Free while in use:** Sodra ioctl terugkeer, voer `close(fd)` uit om `inst`/`job` vry te gee terwyl die worker nog steeds die uit die wagry verwyderde job uitvoer.
3. **Reclaim + pointer control:** Spray reclaimers (e.g., **Unix domain socket message** allocations) om die vrygemaakte slab-slot te beset en die inline `job` oor te skryf, veral `job->regs`.
4. **Arbitrary write:** Wanneer `bigo_pull_regs()` loop, skryf `memcpy_fromio()` **core->regs_size (~2144 bytes)** vanaf MMIO na die deur die aanvaller verskafde adres in `job->regs`, wat 'n groot write-what-where skep sonder 'n KASLR leak.
5. **Data shaping:** Omdat registers eers van gebruikersdata geprogrammeer word (`bigo_push_regs`), stel hulle so die hardware nie uitvoer nie, sodat die teruggekopieerde registerbeeld naby aanvaller-beheerde bytes bly.

### Minimal PoC skeleton (blocking backlog + reclaim)
```c
int fd = open("/dev/bigwave", O_RDWR);
for (int i = 0; i < 64; i++) submit_job(fd, regs_buf);   // fill worker queue
submit_job(fd, regs_buf);                                // victim job
auto t0 = now();
while (now() - t0 < 17000ms) sched_yield();              // hit 16s timeout
close(fd);                                               // free inst/job
spray_uds_msgs(payload_pointing_to_target, spray_count); // reclaim slab
sleep(1);                                                // let worker memcpy_fromio
```
- `regs_buf` moet BigWave vooraf instel om idle te wees (e.g., stel control bits om uitvoering oor te slaan) sodat die terug-geskopieerde registerbeeld deterministies bly.

## Belangrike punte vir stuurprogram-hersieners

- Inline per-FD job structs wat by async workers in die tou geplaas word, moet verwysings hê wat timeout-/kanselleer-paaie oorleef; **Die sluit van 'n FD moet met die worker se verbruik gesinchroniseer word**.
- Enige MMIO copy helpers (`memcpy_fromio`/`memcpy_toio`) wat buffer-aanwysers van jobs gebruik, moet gevalideer of gedupliseer word voordat hulle in die tou geplaas word om UAF→write primitives te voorkom.

## References

- [Pixel 0-click (Part 2): Escaping the mediacodec sandbox via the BigWave driver](https://projectzero.google/2026/01/pixel-0-click-part-2.html)
- [Project Zero issue 426567975 – BigWave BIGO timeout UAF](https://project-zero.issues.chromium.org/issues/426567975)
- [CVE-2025-36934 entry (BigWave driver)](https://www.cybersecurity-help.cz/vulnerabilities/119071/)

{{#include ../../banners/hacktricks-training.md}}
