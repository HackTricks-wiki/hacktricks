# Pixel BigWave BIGO timeout race UAF → 2KB kernel write from mediacodec

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- Iz SELinux-ograničenog **mediacodec** konteksta, `/dev/bigwave` (Pixel AV1 hardware accelerator) je dostupan. Nagomilavanje poslova uzrokuje da `BIGO_IOCX_PROCESS` dostigne svoj **16s wait_for_completion_timeout()** i vrati se dok worker thread istovremeno dekuje istu inline `job` strukturu.
- Zatvaranjem FD-a odmah se oslobađa `struct bigo_inst` (koji sadrži `struct bigo_job`). Worker rekonstruše `inst = container_of(job, ...)` i kasnije koristi oslobođena polja kao što je **`job->regs`** unutar `bigo_run_job()`, što dovodi do **Use-After-Free na inline job/inst**.
- `bigo_pull_regs(core, job->regs)` izvršava `memcpy_fromio(regs, core->base, core->regs_size)`. Preuzimanjem oslobođenog slaba i prepisivanjem `job->regs`, napadač dobija **~2144-byte arbitrary kernel write** na odabranu adresu, sa delimičnom kontrolom bajtova podešavanjem vrednosti registara pre timeout-a.
- Praćeno kao **CVE-2025-36934**; ispravljeno u **2026-01-05 Pixel/2025-12-01 ASB** buildovima.

## Attack surface mapping (SELinux → /dev reachability)

- Koristite alate kao što su **DriverCartographer** za enumeraciju device node-ova dostupnih iz datog SELinux domena. Uprkos ograničenoj politici mediacodec-a (software decoders treba da ostanu u izolovanom kontekstu), `/dev/bigwave` je ostao dostupan, otkrivajući veliku površinu napada za post-media-RCE kod.

## Vulnerability: BIGO_IOCX_PROCESS timeout vs worker

- Tok: ioctl kopira korisnički register buffer u `job->regs`, stavi inline `job` u red, zatim se poziva `wait_for_completion_timeout(..., 16s)`. Na timeout pokušava da dekuje/otkaže i vraća se u userspace.
- U međuvremenu, `bigo_worker_thread` je mogao upravo da dekuje isti `job`:
```c
inst = container_of(job, struct bigo_inst, job);
bigo_push_regs(core, job->regs);
...
bigo_pull_regs(core, job->regs);   // memcpy_fromio(regs, core->base, core->regs_size)
*(u32 *)(job->regs + BIGO_REG_STAT) = status;
```
- Ako userspace zatvori FD posle timeout-a, `inst`/`job` se oslobode dok worker i dalje koristi te strukture → UAF. Nema sinhronizacije koja vezuje životni vek FD za job pointer worker threada.

## Plan eksploatacije

1. **Backlog + timeout:** Umetni dovoljno job-ova u red da se worker zakašnjava, zatim pozovi `BIGO_IOCX_PROCESS` i pusti da udari u 16s timeout path.
2. **Free while in use:** Čim ioctl vrati kontrolu, pozovi `close(fd)` da oslobodiš `inst`/`job` dok worker i dalje izvršava izbačeni job iz reda.
3. **Reclaim + pointer control:** Rasprši reclaimere (npr. **Unix domain socket message** alokacije) da zauzmu oslobođeni slab slot i prepišu inline `job`, posebno `job->regs`.
4. **Arbitrary write:** Kada `bigo_pull_regs()` radi, `memcpy_fromio()` upisuje **core->regs_size (~2144 bytes)** iz MMIO u adresu zadatu od strane napadača u `job->regs`, proizvodeći veliki write-what-where bez KASLR leak.
5. **Data shaping:** Pošto se registri prvo programiraju iz user podataka (`bigo_push_regs`), postavi ih tako da hardver ne izvrši kod, držeći vraćenu sliku registara blizu bajtova pod kontrolom napadača.

### Minimalni PoC skelet (blocking backlog + reclaim)
```c
int fd = open("/dev/bigwave", O_RDWR);
for (int i = 0; i < 64; i++) submit_job(fd, regs_buf);   // fill worker queue
submit_job(fd, regs_buf);                                // victim job
auto t0 = now();
while (now() - t0 < 17000ms) sched_yield();              // hit 16s timeout
close(fd);                                               // free inst/job
spray_uds_msgs(payload_pointing_to_target, spray_count); // reclaim slab
sleep(1);                                                // let worker memcpy_fromio
```
- `regs_buf` treba unapred da konfiguriše BigWave da bude u idle stanju (npr. postaviti kontrolne bitove da preskoči izvršenje) tako da povratno kopirana slika registara ostane deterministička.

## Zaključci za pregledaoce drajvera

- Inline per-FD job structs enqueued to async workers moraju držati reference koje prežive timeout/cancel putanje; **zatvaranje FD mora biti sinhronizovano sa potrošnjom od strane workera**.
- Bilo koji MMIO copy helperi (`memcpy_fromio`/`memcpy_toio`) koji koriste pokazivače na bafer iz jobs treba da budu validirani ili duplicirani pre enqueovanja kako bi se izbegle UAF→write primitive.

## Reference

- [Pixel 0-click (Part 2): Escaping the mediacodec sandbox via the BigWave driver](https://projectzero.google/2026/01/pixel-0-click-part-2.html)
- [Project Zero issue 426567975 – BigWave BIGO timeout UAF](https://project-zero.issues.chromium.org/issues/426567975)
- [CVE-2025-36934 entry (BigWave driver)](https://www.cybersecurity-help.cz/vulnerabilities/119071/)

{{#include ../../banners/hacktricks-training.md}}
