# Pixel BigWave BIGO timeout race UAF → 2KB kernel write from mediacodec

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- Iz SELinux-ograničenog **mediacodec** konteksta, `/dev/bigwave` (Pixel AV1 hardware accelerator) je dostupan. Nagomilavanje poslova navodi `BIGO_IOCX_PROCESS` da udari u svoj **16s wait_for_completion_timeout()** i vrati se dok worker thread istovremeno dequeuje istu inline `job` strukturu.
- Zatvaranje FD odmah oslobodi `struct bigo_inst` (koji ugrađuje `struct bigo_job`). Worker rekonstruše `inst = container_of(job, ...)` i kasnije koristi oslobođena polja kao što su **`job->regs`** unutar `bigo_run_job()`, što dovodi do **Use-After-Free on the inline job/inst**.
- `bigo_pull_regs(core, job->regs)` radi `memcpy_fromio(regs, core->base, core->regs_size)`. Reklaimovanjem oslobođenog slaba i prepisivanjem `job->regs`, napadač dobija **~2144-byte arbitrary kernel write** na izabranu adresu, sa delimičnom kontrolom bajtova pre-programiranjem vrednosti registara pre timeout-a.

## Attack surface mapping (SELinux → /dev reachability)

- Koristite alate kao što su **DriverCartographer** za enumerisanje device node-ova koji su dostupni iz datog SELinux domena. Uprkos ograničenoj politici mediacodec‑a (software decodere treba držati u izolovanom kontekstu), `/dev/bigwave` je ostao dostupan, izlažući veliki attack surface post-media-RCE kodu.

## Vulnerability: BIGO_IOCX_PROCESS timeout vs worker

- Tok: ioctl kopira korisnički buffer registara u `job->regs`, queuje inline `job`, zatim poziva `wait_for_completion_timeout(..., 16s)`. Na timeout pokuša da dequeue/cancel i vraća se u userspace.
- U međuvremenu `bigo_worker_thread` je možda upravo dequeovao isti `job`:
```c
inst = container_of(job, struct bigo_inst, job);
bigo_push_regs(core, job->regs);
...
bigo_pull_regs(core, job->regs);   // memcpy_fromio(regs, core->base, core->regs_size)
*(u32 *)(job->regs + BIGO_REG_STAT) = status;
```
- Ako userspace zatvori FD nakon timeout-a, `inst`/`job` se oslobode dok worker i dalje koristi te strukture → UAF. Ne postoji sinhronizacija koja vezuje životni vek FD-a za pokazivač job-a u worker niti.

## Pregled eksploatacije

1. **Backlog + timeout:** Stavite dovoljno job-ova u red da worker bude usporen, zatim pozovite `BIGO_IOCX_PROCESS` i dozvolite da uđe na putanju sa timeout-om od 16s.
2. **Free while in use:** Čim ioctl vrati, pozovite `close(fd)` da oslobodite `inst`/`job` dok worker još uvek izvršava dequeued job.
3. **Reclaim + pointer control:** Spray-ujte reclaimere (npr. **Unix domain socket message** alokacije) da zauzmete oslobođeni slab slot i prepišete inline `job`, posebno `job->regs`.
4. **Arbitrary write:** Kada se izvrši `bigo_pull_regs()`, `memcpy_fromio()` upisuje **core->regs_size (~2144 bytes)** iz MMIO u adresu koju je napadač postavio u `job->regs`, proizvodeći veliki write-what-where bez KASLR leak-a.
5. **Data shaping:** Pošto se registri najpre programiraju iz korisničkih podataka (`bigo_push_regs`), podesite ih tako da hardware ne izvršava, čuvajući kopiranu sliku registara blizu bajtova koje kontroliše napadač.

## Zaključci za pregledaoce drajvera

- Inline per-FD job strukture koje se stavljaju u red za async workere moraju držati reference koje prežive timeout/cancel puteve; **zatvaranje FD-a mora biti sinhronizovano sa potrošnjom od strane workera**.
- Bilo koji MMIO copy helper-i (`memcpy_fromio`/`memcpy_toio`) koji koriste pokazivače na bafer iz job-ova treba validirati ili duplicirati pre stavljanja u red kako bi se izbegle UAF→write primitive.

## Reference

- [Pixel 0-click (Part 2): Escaping the mediacodec sandbox via the BigWave driver](https://projectzero.google/2026/01/pixel-0-click-part-2.html)
- [Project Zero issue 426567975 – BigWave BIGO timeout UAF](https://project-zero.issues.chromium.org/issues/426567975)

{{#include ../../banners/hacktricks-training.md}}
