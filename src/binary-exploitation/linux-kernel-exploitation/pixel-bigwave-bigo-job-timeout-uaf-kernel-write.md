# Pixel BigWave BIGO timeout race UAF → 2KB kernel write από mediacodec

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- Από το SELinux-περιορισμένο **mediacodec** context, `/dev/bigwave` (Pixel AV1 hardware accelerator) είναι προσβάσιμο. Μια συσσώρευση εργασιών (backlog) αναγκάζει το `BIGO_IOCX_PROCESS` να φτάσει στο **16s wait_for_completion_timeout()** και να επιστρέψει ενώ το worker thread ταυτόχρονα αφαιρεί από την ουρά (dequeues) την ίδια inline δομή `job`.
- Το κλείσιμο του FD απελευθερώνει αμέσως το `struct bigo_inst` (που ενσωματώνει `struct bigo_job`). Ο worker ανασυνθέτει `inst = container_of(job, ...)` και αργότερα χρησιμοποιεί πεδία που έχουν απελευθερωθεί όπως **`job->regs`** μέσα σε `bigo_run_job()`, οδηγώντας σε **Use-After-Free στο inline job/inst**.
- `bigo_pull_regs(core, job->regs)` εκτελεί `memcpy_fromio(regs, core->base, core->regs_size)`. Ανακτώντας το απελευθερωμένο slab και υπερχείροντας το `job->regs`, ένας επιτιθέμενος αποκτά ένα **~2144-byte arbitrary kernel write** σε μια επιλεγμένη διεύθυνση, με μερικό έλεγχο των bytes μέσω προ-προγραμματισμού των τιμών των registers πριν το timeout.

## Χαρτογράφηση επιφανείας επίθεσης (SELinux → /dev προσβασιμότητα)

- Χρησιμοποιήστε εργαλεία όπως **DriverCartographer** για να απαριθμήσετε τους device nodes που είναι προσβάσιμοι από ένα δεδομένο SELinux domain. Παρά την περιορισμένη πολιτική του mediacodec (οι λογισμικοί αποκωδικοποιητές πρέπει να παραμένουν σε απομονωμένο πλαίσιο), το `/dev/bigwave` παρέμεινε προσβάσιμο, εκθέτοντας μεγάλη επιφάνεια επίθεσης σε post-media-RCE κώδικα.

## Ευπάθεια: BIGO_IOCX_PROCESS timeout vs worker

- Ροή: το ioctl αντιγράφει το user register buffer στο `job->regs`, βάζει στην ουρά το inline `job`, και στη συνέχεια καλεί `wait_for_completion_timeout(..., 16s)`. Σε timeout προσπαθεί να dequeue/cancel και επιστρέφει στο userspace.
- Εν τω μεταξύ, το `bigo_worker_thread` μπορεί να έχει μόλις αφαιρέσει από την ουρά το ίδιο `job`:
```c
inst = container_of(job, struct bigo_inst, job);
bigo_push_regs(core, job->regs);
...
bigo_pull_regs(core, job->regs);   // memcpy_fromio(regs, core->base, core->regs_size)
*(u32 *)(job->regs + BIGO_REG_STAT) = status;
```
- If userspace closes the FD after the timeout, `inst`/`job` are freed while the worker keeps using them → UAF. No synchronization ties FD lifetime to the worker thread’s job pointer.

## Σχεδιάγραμμα εκμετάλλευσης

1. **Backlog + timeout:** Τοποθετήστε αρκετά jobs στην ουρά ώστε ο worker να καθυστερήσει, μετά εκτελέστε `BIGO_IOCX_PROCESS` και αφήστε το να φτάσει στη διαδρομή timeout των 16s.
2. **Free while in use:** Μόλις επιστρέψει το ioctl, καλέστε `close(fd)` για να απελευθερώσετε `inst`/`job` ενώ ο worker εξακολουθεί να εκτελεί το job που αφαιρέθηκε από την ουρά.
3. **Reclaim + pointer control:** Ψεκάστε reclaimers (π.χ. **Unix domain socket message** allocations) για να καταλάβουν το απελευθερωμένο slab slot και να υπεργράψουν το inline `job`, ειδικά το `job->regs`.
4. **Arbitrary write:** Όταν τρέξει το `bigo_pull_regs()`, η `memcpy_fromio()` γράφει **core->regs_size (~2144 bytes)** από MMIO στην attacker-supplied διεύθυνση στο `job->regs`, παράγοντας ένα μεγάλο write-what-where χωρίς KASLR leak.
5. **Data shaping:** Επειδή τα registers πρώτα προγραμματίζονται από δεδομένα χρήστη (`bigo_push_regs`), ορίστε τα ώστε το hardware να μην εκτελέσει κώδικα, διατηρώντας την αντιγραμμένη εικόνα των registers κοντά σε bytes ελεγχόμενα από τον attacker.

## Σημεία προς προσοχή για αξιολογητές driver

- Inline per-FD job structs enqueued to async workers πρέπει να κρατούν αναφορές που επιβιώνουν στις διαδρομές timeout/cancel; **το κλείσιμο ενός FD πρέπει να συγχρονίζεται με την κατανάλωση από τον worker**.
- Οποιοιδήποτε MMIO copy helpers (`memcpy_fromio`/`memcpy_toio`) που χρησιμοποιούν buffer pointers από jobs θα πρέπει να επικυρώνονται ή να αντιγράφονται πριν την enqueue για να αποφευχθούν UAF→write primitives.

## Αναφορές

- [Pixel 0-click (Part 2): Escaping the mediacodec sandbox via the BigWave driver](https://projectzero.google/2026/01/pixel-0-click-part-2.html)
- [Project Zero issue 426567975 – BigWave BIGO timeout UAF](https://project-zero.issues.chromium.org/issues/426567975)

{{#include ../../banners/hacktricks-training.md}}
