# Pixel BigWave BIGO timeout race UAF → scrittura kernel di 2KB da mediacodec

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- Dal contesto SELinux-confined **mediacodec**, `/dev/bigwave` (Pixel AV1 hardware accelerator) è raggiungibile. Un arretrato di job fa sì che `BIGO_IOCX_PROCESS` incappi nel suo **16s wait_for_completion_timeout()** e ritorni mentre il thread worker contemporaneamente estrae dalla coda lo stesso `job` inline.
- La chiusura del FD libera immediatamente `struct bigo_inst` (che incorpora `struct bigo_job`). Il worker ricostruisce `inst = container_of(job, ...)` e poi usa campi già liberati come **`job->regs`** dentro `bigo_run_job()`, causando un **Use-After-Free on the inline job/inst**.
- `bigo_pull_regs(core, job->regs)` esegue `memcpy_fromio(regs, core->base, core->regs_size)`. Recuperando lo slab liberato e sovrascrivendo `job->regs`, un attaccante ottiene una **scrittura kernel arbitraria di ~2144 byte** verso un indirizzo scelto, con controllo parziale dei byte pre-programmando i valori dei registri prima del timeout.

## Attack surface mapping (SELinux → /dev reachability)

- Usare strumenti come **DriverCartographer** per enumerare i device node accessibili da un dato dominio SELinux. Nonostante la policy ristretta di mediacodec (i decoder software dovrebbero restare in un contesto isolato), `/dev/bigwave` è rimasto raggiungibile, esponendo una larga superficie di attacco al codice post-media-RCE.

## Vulnerability: BIGO_IOCX_PROCESS timeout vs worker

- Flusso: ioctl copia il buffer registri utente in `job->regs`, mette in coda l'`job` inline, poi chiama `wait_for_completion_timeout(..., 16s)`. Al timeout prova a dequeue/cancel e ritorna in userspace.
- Nel frattempo `bigo_worker_thread` potrebbe aver appena estratto dalla coda lo stesso `job`:
```c
inst = container_of(job, struct bigo_inst, job);
bigo_push_regs(core, job->regs);
...
bigo_pull_regs(core, job->regs);   // memcpy_fromio(regs, core->base, core->regs_size)
*(u32 *)(job->regs + BIGO_REG_STAT) = status;
```
- Se lo userspace chiude il FD dopo il timeout, `inst`/`job` vengono liberati mentre il worker continua a usarli → UAF. Non c'è sincronizzazione che leghi la durata del FD al puntatore job del thread worker.

## Schema di sfruttamento

1. **Backlog + timeout:** Accoda un numero sufficiente di job in modo da ritardare il worker, poi esegui `BIGO_IOCX_PROCESS` e lascia che entri nel percorso di timeout a 16s.
2. **Free while in use:** Non appena l'ioctl ritorna, esegui `close(fd)` per liberare `inst`/`job` mentre il worker sta ancora eseguendo il job estratto dalla coda.
3. **Reclaim + pointer control:** Spray reclaimers (e.g., **Unix domain socket message** allocations) per occupare lo slot di slab liberato e sovrascrivere l'`job` inline, in particolare `job->regs`.
4. **Arbitrary write:** Quando `bigo_pull_regs()` viene eseguita, `memcpy_fromio()` scrive **core->regs_size (~2144 bytes)** da MMIO nell'indirizzo fornito dall'attaccante in `job->regs`, generando un ampio write-what-where senza un KASLR leak.
5. **Data shaping:** Poiché i registri sono inizialmente programmati da dati utente (`bigo_push_regs`), impostali in modo che l'hardware non esegua codice, mantenendo l'immagine dei registri copiata vicina a byte controllati dall'attaccante.

## Indicazioni per i revisori del driver

- Le struct job inline per-FD messe in coda a worker asincroni devono mantenere riferimenti che sopravvivano ai percorsi di timeout/cancel; **la chiusura di un FD deve sincronizzarsi con il consumo da parte del worker**.
- Qualsiasi helper di copia MMIO (`memcpy_fromio`/`memcpy_toio`) che usa puntatori a buffer presi dai job dovrebbe essere validato o duplicato prima dell'enqueue per evitare primitive UAF→write.

## Riferimenti

- [Pixel 0-click (Part 2): Escaping the mediacodec sandbox via the BigWave driver](https://projectzero.google/2026/01/pixel-0-click-part-2.html)
- [Project Zero issue 426567975 – BigWave BIGO timeout UAF](https://project-zero.issues.chromium.org/issues/426567975)

{{#include ../../banners/hacktricks-training.md}}
