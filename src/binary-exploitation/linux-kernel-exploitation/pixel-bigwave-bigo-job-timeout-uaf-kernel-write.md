# Pixel BigWave BIGO timeout race UAF → 2KB kernel write from mediacodec

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- 在受 SELinux 限制的 **mediacodec** 上下文中，可访问 `/dev/bigwave`（Pixel AV1 硬件加速器）。任务积压会使 `BIGO_IOCX_PROCESS` 命中其 **16s wait_for_completion_timeout()** 并返回，同时工作线程并发地从队列中取出相同的内联 `job` 结构。
- 关闭 FD 会立即释放 `struct bigo_inst`（其中嵌入 `struct bigo_job`）。工作线程重建 `inst = container_of(job, ...)`，并在 `bigo_run_job()` 中使用已释放的字段，例如 **`job->regs`**，导致在内联 job/inst 上出现 **Use-After-Free**。
- `bigo_pull_regs(core, job->regs)` 执行 `memcpy_fromio(regs, core->base, core->regs_size)`。通过回收已释放的 slab 并覆盖 `job->regs`，攻击者可以对选定地址进行大约 **~2144-byte arbitrary kernel write**，并且通过在超时前预设寄存器值可以部分控制写入的字节。

## Attack surface mapping (SELinux → /dev reachability)

- 使用像 **DriverCartographer** 这样的工具枚举从给定 SELinux 域可访问的设备节点。尽管 mediacodec 的策略受限（软件解码器应保持在隔离的上下文中），`/dev/bigwave` 仍然可访问，向 post-media-RCE 代码暴露了大量攻击面。

## Vulnerability: BIGO_IOCX_PROCESS timeout vs worker

- 流程：ioctl 将用户寄存器缓冲区复制到 `job->regs`，把内联 `job` 入队，然后调用 `wait_for_completion_timeout(..., 16s)`。超时后它尝试出队/取消并返回用户态。
- 与此同时，`bigo_worker_thread` 可能刚刚从队列中取出了相同的 `job`：
```c
inst = container_of(job, struct bigo_inst, job);
bigo_push_regs(core, job->regs);
...
bigo_pull_regs(core, job->regs);   // memcpy_fromio(regs, core->base, core->regs_size)
*(u32 *)(job->regs + BIGO_REG_STAT) = status;
```
- 如果 userspace 在超时后关闭 FD，`inst`/`job` 会在 worker 仍然使用它们时被释放 → UAF。没有同步机制将 FD 的生命周期与工作线程的 job 指针绑定。

## Exploitation outline

1. **Backlog + timeout:** 排足够多的作业使工作线程被延迟，然后发起 `BIGO_IOCX_PROCESS` 并让其触发 16s 的超时路径。
2. **Free while in use:** ioctl 一返回，立即 `close(fd)` 以释放 `inst`/`job`，而 worker 仍在运行已出队的作业。
3. **Reclaim + pointer control:** 喷洒回收对象（例如 **Unix domain socket message** allocations）以占据被释放的 slab 槽并覆盖内联的 `job`，特别是 `job->regs`。
4. **Arbitrary write:** 当 `bigo_pull_regs()` 运行时，`memcpy_fromio()` 会把来自 MMIO 的 **core->regs_size (~2144 bytes)** 写入 `job->regs` 中攻击者提供的地址，产生一个大的 write-what-where，而无需 KASLR leak。
5. **Data shaping:** 由于寄存器首先由用户数据（`bigo_push_regs`）编程，将其设置为不触发硬件执行，从而使复制回来的寄存器映像尽量接近攻击者可控的字节。

## Takeaways for driver reviewers

- Inline per-FD job structs 入队到异步 worker 时必须持有能在超时/取消路径中存活的引用；**关闭 FD 必须与 worker 的消费进行同步**。
- 任何使用来自 job 的缓冲指针的 MMIO 拷贝辅助函数（`memcpy_fromio`/`memcpy_toio`）应在入队前进行校验或复制，以避免 UAF→write 原语。

## References

- [Pixel 0-click (Part 2): Escaping the mediacodec sandbox via the BigWave driver](https://projectzero.google/2026/01/pixel-0-click-part-2.html)
- [Project Zero issue 426567975 – BigWave BIGO timeout UAF](https://project-zero.issues.chromium.org/issues/426567975)

{{#include ../../banners/hacktricks-training.md}}
