# Pixel BigWave BIGO timeout race UAF → escrita de 2KB no kernel a partir de mediacodec

{{#include ../../banners/hacktricks-training.md}}

## Resumo

- A partir do contexto confinado pelo SELinux **mediacodec**, `/dev/bigwave` (Pixel AV1 hardware accelerator) é alcançável. Um backlog de jobs faz com que `BIGO_IOCX_PROCESS` atinja seu **wait_for_completion_timeout() de 16s** e retorne enquanto a worker thread simultaneamente dequeues a mesma estrutura inline `job`.
- Fechar o FD imediatamente libera `struct bigo_inst` (que incorpora `struct bigo_job`). O worker reconstrói `inst = container_of(job, ...)` e depois usa campos já liberados como **`job->regs`** dentro de `bigo_run_job()`, resultando em um **Use-After-Free no job/inst inline**.
- `bigo_pull_regs(core, job->regs)` executa `memcpy_fromio(regs, core->base, core->regs_size)`. Ao reocupar o slab liberado e sobrescrever `job->regs`, um atacante obtém uma **escrita arbitrária no kernel de ~2144 bytes** para um endereço escolhido, com controle parcial dos bytes ao pré-programar valores de registradores antes do timeout.

## Mapeamento da superfície de ataque (SELinux → alcance de /dev)

- Use ferramentas como **DriverCartographer** para enumerar device nodes acessíveis a partir de um domínio SELinux dado. Apesar da política restrita do mediacodec (decodificadores por software deveriam permanecer em um contexto isolado), `/dev/bigwave` permaneceu acessível, expondo uma grande superfície de ataque para código pós-RCE em mídia.

## Vulnerabilidade: BIGO_IOCX_PROCESS timeout vs worker

- Fluxo: o ioctl copia o buffer de registradores do usuário para `job->regs`, enfileira o `job` inline, então chama `wait_for_completion_timeout(..., 16s)`. No timeout ele tenta fazer dequeue/cancel e retorna para o userspace.
- Enquanto isso, `bigo_worker_thread` pode ter acabado de dequeuar o mesmo `job`:
```c
inst = container_of(job, struct bigo_inst, job);
bigo_push_regs(core, job->regs);
...
bigo_pull_regs(core, job->regs);   // memcpy_fromio(regs, core->base, core->regs_size)
*(u32 *)(job->regs + BIGO_REG_STAT) = status;
```
- If userspace closes the FD after the timeout, `inst`/`job` are freed while the worker keeps using them → UAF. No synchronization ties FD lifetime to the worker thread’s job pointer.

## Esquema de exploração

1. **Backlog + timeout:** Enfileire jobs suficientes para atrasar o worker, então emita `BIGO_IOCX_PROCESS` e deixe que ele atinja o caminho de timeout de 16s.
2. **Free while in use:** Assim que o ioctl retornar, chame `close(fd)` para liberar `inst`/`job` enquanto o worker ainda está executando o job removido da fila.
3. **Reclaim + pointer control:** Spray reclaimers (e.g., **Unix domain socket message** allocations) para ocupar o slot de slab liberado e sobrescrever o `job` inline, especialmente `job->regs`.
4. **Arbitrary write:** Quando `bigo_pull_regs()` é executado, `memcpy_fromio()` escreve **core->regs_size (~2144 bytes)** do MMIO no endereço fornecido pelo atacante em `job->regs`, produzindo um grande write-what-where sem um KASLR leak.
5. **Data shaping:** Como os registradores são primeiro programados a partir de dados do usuário (`bigo_push_regs`), configure-os para que o hardware não execute, mantendo a imagem dos registradores copiada de volta próxima aos bytes controlados pelo atacante.

## Principais conclusões para revisores de drivers

- Inline per-FD job structs enqueued to async workers must hold references that survive timeout/cancel paths; **closing an FD must synchronize with worker consumption**.
- Any MMIO copy helpers (`memcpy_fromio`/`memcpy_toio`) that use buffer pointers from jobs should be validated or duplicated before enqueuing to avoid UAF→write primitives.

## References

- [Pixel 0-click (Part 2): Escaping the mediacodec sandbox via the BigWave driver](https://projectzero.google/2026/01/pixel-0-click-part-2.html)
- [Project Zero issue 426567975 – BigWave BIGO timeout UAF](https://project-zero.issues.chromium.org/issues/426567975)

{{#include ../../banners/hacktricks-training.md}}
