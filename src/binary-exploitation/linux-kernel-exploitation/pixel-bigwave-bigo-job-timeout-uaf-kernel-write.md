# Pixel BigWave BIGO timeout race UAF → 2KB kernel write from mediacodec

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- SELinux로 제한된 **mediacodec** 컨텍스트에서 `/dev/bigwave`(Pixel AV1 하드웨어 가속기)에 접근할 수 있습니다. 작업이 밀려 쌓이면 `BIGO_IOCX_PROCESS`가 **16s wait_for_completion_timeout()**에 걸려 반환되고, 그 사이 worker 스레드는 동일한 인라인 `job` 구조체를 동시에 dequeue할 수 있습니다.
- FD를 닫으면 즉시 `struct bigo_inst`(내부에 `struct bigo_job`를 포함)를 해제합니다. worker는 `inst = container_of(job, ...)`를 재구성하고 나중에 `bigo_run_job()` 내부에서 **`job->regs`**와 같은 해제된 필드를 사용하여 인라인 job/inst에 대한 **Use-After-Free**를 발생시킵니다.
- `bigo_pull_regs(core, job->regs)`는 `memcpy_fromio(regs, core->base, core->regs_size)`를 수행합니다. 해제된 slab를 재할당하고 `job->regs`를 덮어쓰면 공격자는 **~2144-byte 임의의 커널 쓰기**를 선택한 주소로 얻을 수 있으며, 타임아웃 전에 레지스터 값을 미리 설정함으로써 바이트의 일부를 제어할 수 있습니다.

## Attack surface mapping (SELinux → /dev reachability)

- **DriverCartographer** 같은 도구를 사용해 주어진 SELinux 도메인에서 접근 가능한 디바이스 노드를 열거하세요. mediacodec의 제한된 정책에도 불구하고(소프트웨어 디코더는 격리된 컨텍스트에 있어야 함), `/dev/bigwave`는 여전히 접근 가능했으며 post-media-RCE 코드에 큰 공격 표면을 노출했습니다.

## Vulnerability: BIGO_IOCX_PROCESS timeout vs worker

- Flow: ioctl은 사용자 레지스터 버퍼를 `job->regs`로 복사하고 인라인 `job`을 큐에 넣은 뒤 `wait_for_completion_timeout(..., 16s)`를 호출합니다. 타임아웃 시에는 dequeue/취소를 시도하고 유저스페이스로 반환합니다.
- 한편 `bigo_worker_thread`는 방금 동일한 `job`을 dequeue했을 수도 있습니다:
```c
inst = container_of(job, struct bigo_inst, job);
bigo_push_regs(core, job->regs);
...
bigo_pull_regs(core, job->regs);   // memcpy_fromio(regs, core->base, core->regs_size)
*(u32 *)(job->regs + BIGO_REG_STAT) = status;
```
- timeout 이후 userspace가 FD를 close하면, `inst`/`job`가 해제된 상태에서 worker가 계속 사용 → UAF. FD의 수명과 worker 스레드의 job 포인터를 연결하는 동기화가 없음.

## Exploitation outline

1. **Backlog + timeout:** worker가 지연되도록 충분한 jobs를 큐에 넣고, `BIGO_IOCX_PROCESS`를 실행해 16s timeout 경로에 걸리게 한다.
2. **Free while in use:** ioctl이 반환되자마자 `close(fd)`로 worker가 아직 실행 중인 dequeued job의 `inst`/`job`를 해제한다.
3. **Reclaim + pointer control:** Spray reclaimers(예: **Unix domain socket message** 할당)를 사용해 해제된 slab 슬롯을 차지하고 inline `job`, 특히 `job->regs`를 덮어쓴다.
4. **Arbitrary write:** `bigo_pull_regs()`가 실행될 때, `memcpy_fromio()`가 MMIO에서 **core->regs_size (~2144 bytes)**를 `job->regs`에 있는 공격자가 제공한 주소로 써서 KASLR leak 없이 대규모 write-what-where를 만든다.
5. **Data shaping:** 레지스터가 먼저 user 데이터(`bigo_push_regs`)로 프로그램되므로, 하드웨어가 실행하지 않도록 설정해 복사된 레지스터 이미지가 공격자가 제어한 바이트에 가깝게 유지되도록 한다.

## Takeaways for driver reviewers

- Inline per-FD job structs enqueued to async workers는 timeout/cancel 경로를 견딜 수 있는 레퍼런스를 유지해야 한다; **FD를 close하는 동작은 worker의 소비와 동기화되어야 한다**.
- job에서 온 버퍼 포인터를 사용하는 모든 MMIO 복사 헬퍼(`memcpy_fromio`/`memcpy_toio`)는 UAF→write primitives를 방지하기 위해 enqueue하기 전에 검증되거나 복제되어야 한다.

## References

- [Pixel 0-click (Part 2): Escaping the mediacodec sandbox via the BigWave driver](https://projectzero.google/2026/01/pixel-0-click-part-2.html)
- [Project Zero issue 426567975 – BigWave BIGO timeout UAF](https://project-zero.issues.chromium.org/issues/426567975)

{{#include ../../banners/hacktricks-training.md}}
