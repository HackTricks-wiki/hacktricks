# Pixel BigWave BIGO timeout race UAF → écriture noyau 2KB depuis mediacodec

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- Depuis le contexte SELinux-confiné **mediacodec**, `/dev/bigwave` (accélérateur matériel Pixel AV1) est accessible. Un arriéré de jobs fait que `BIGO_IOCX_PROCESS` atteint son **16s wait_for_completion_timeout()** et retourne tandis que le thread worker désenfile simultanément la même structure inline `job`.
- La fermeture du FD libère immédiatement `struct bigo_inst` (qui inclut `struct bigo_job`). Le worker reconstruit `inst = container_of(job, ...)` et utilise ensuite des champs libérés tels que **`job->regs`** dans `bigo_run_job()`, entraînant un **Use-After-Free sur le job/inst inline**.
- `bigo_pull_regs(core, job->regs)` exécute `memcpy_fromio(regs, core->base, core->regs_size)`. En récupérant le slab libéré et en écrasant `job->regs`, un attaquant obtient une **écriture arbitraire vers le noyau d'environ 2144 octets** à une adresse choisie, avec contrôle partiel des octets en préprogrammant les valeurs des registres avant le timeout.

## Attack surface mapping (SELinux → /dev reachability)

- Utilisez des outils comme **DriverCartographer** pour énumérer les nœuds de périphériques accessibles depuis un domaine SELinux donné. Malgré la politique restreinte de mediacodec (les décodeurs logiciels doivent rester dans un contexte isolé), `/dev/bigwave` restait accessible, exposant une large surface d'attaque au code post-media-RCE.

## Vulnerability: BIGO_IOCX_PROCESS timeout vs worker

- Flux : ioctl copie le buffer de registres utilisateur dans `job->regs`, met en file le `job` inline, puis `wait_for_completion_timeout(..., 16s)`. En cas de timeout il tente de désenfiler/annuler et retourne en espace utilisateur.
- Pendant ce temps `bigo_worker_thread` peut avoir juste désenfilé le même `job`:
```c
inst = container_of(job, struct bigo_inst, job);
bigo_push_regs(core, job->regs);
...
bigo_pull_regs(core, job->regs);   // memcpy_fromio(regs, core->base, core->regs_size)
*(u32 *)(job->regs + BIGO_REG_STAT) = status;
```
- Si l'espace utilisateur ferme le FD après le timeout, `inst`/`job` sont libérés alors que le worker continue à les utiliser → UAF. Il n'y a aucune synchronisation liant la durée de vie du FD au pointeur job du thread worker.

## Plan d'exploitation

1. **Backlog + timeout :** Mettre en file suffisamment de jobs pour retarder le worker, puis appeler `BIGO_IOCX_PROCESS` et laisser atteindre le chemin de timeout de 16s.
2. **Free while in use :** Dès que l'ioctl retourne, appeler `close(fd)` pour libérer `inst`/`job` alors que le worker exécute encore le job retiré de la file.
3. **Reclaim + pointer control :** Effectuer un spray de reclaimers (p.ex., allocations **Unix domain socket message**) pour occuper la case de slab libérée et écraser le `job` inline, en particulier `job->regs`.
4. **Arbitrary write :** Quand `bigo_pull_regs()` s'exécute, `memcpy_fromio()` écrit **core->regs_size (~2144 bytes)** depuis le MMIO vers l'adresse fournie par l'attaquant dans `job->regs`, produisant un large write-what-where sans KASLR leak.
5. **Data shaping :** Comme les registres sont d'abord programmés depuis des données utilisateur (`bigo_push_regs`), configurez-les pour que le matériel n'exécute pas, en gardant l'image des registres copiée proche des octets contrôlés par l'attaquant.

## Points à retenir pour les réviseurs de pilotes

- Les structs de job inline par-FD mis en file pour des workers asynchrones doivent conserver des références qui survivent aux chemins de timeout/annulation ; **fermer un FD doit se synchroniser avec la consommation par le worker**.
- Tout helper de copie MMIO (`memcpy_fromio`/`memcpy_toio`) qui utilise des pointeurs de buffer provenant de jobs doit être validé ou dupliqué avant l'enqueue pour éviter des primitives UAF→write.

## References

- [Pixel 0-click (Part 2): Escaping the mediacodec sandbox via the BigWave driver](https://projectzero.google/2026/01/pixel-0-click-part-2.html)
- [Project Zero issue 426567975 – BigWave BIGO timeout UAF](https://project-zero.issues.chromium.org/issues/426567975)

{{#include ../../banners/hacktricks-training.md}}
