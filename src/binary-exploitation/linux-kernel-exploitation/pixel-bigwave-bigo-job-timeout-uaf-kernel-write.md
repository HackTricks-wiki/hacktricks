# Pixel BigWave BIGO timeout race UAF → 2KB kernel write from mediacodec

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- З SELinux-confined контексту mediacodec `/dev/bigwave` (Pixel AV1 hardware accelerator) доступний. Накопичення черги завдань змушує `BIGO_IOCX_PROCESS` досягти свого **16s wait_for_completion_timeout()** і повернутися, поки робочий потік одночасно знімає з черги той самий inline `job` structure.
- Закриття FD негайно звільняє `struct bigo_inst` (який містить `struct bigo_job`). Робітник реконструює `inst = container_of(job, ...)` і пізніше використовує звільнені поля, такі як **`job->regs`** всередині `bigo_run_job()`, спричиняючи **Use-After-Free on the inline job/inst**.
- `bigo_pull_regs(core, job->regs)` виконує `memcpy_fromio(regs, core->base, core->regs_size)`. Повернувши у користування звільнений slab і перезаписавши `job->regs`, зловмисник отримує **~2144-byte arbitrary kernel write** на обрану адресу, з частковим контролем байтів шляхом попереднього програмування значень регістрів перед тайм-аутом.

## Attack surface mapping (SELinux → /dev reachability)

- Використовуйте інструменти на кшталт **DriverCartographer** для перерахунку device nodes, доступних з певного SELinux домену. Незважаючи на обмежену політику mediacodec (software decoders повинні залишатися в ізольованому контексті), `/dev/bigwave` залишався доступним, відкриваючи велику поверхню атаки для post-media-RCE коду.

## Vulnerability: BIGO_IOCX_PROCESS timeout vs worker

- Потік: ioctl копіює буфер регістрів з користувача в `job->regs`, ставить inline `job` у чергу, потім викликає `wait_for_completion_timeout(..., 16s)`. При тайм-ауті він намагається dequeue/cancel і повертається в userspace.
- Тим часом `bigo_worker_thread` міг щойно зняти з черги той самий `job`:
```c
inst = container_of(job, struct bigo_inst, job);
bigo_push_regs(core, job->regs);
...
bigo_pull_regs(core, job->regs);   // memcpy_fromio(regs, core->base, core->regs_size)
*(u32 *)(job->regs + BIGO_REG_STAT) = status;
```
- Якщо користувацький простір закриває FD після таймауту, `inst`/`job` звільняються, поки робочий потік продовжує їх використовувати → UAF. Немає синхронізації, що пов'язує життя FD з вказівником `job` робочого потоку.

## Схема експлуатації

1. **Накопичення черги + таймаут:** Помістіть у чергу достатньо задач, щоб воркер затримався, потім викличте `BIGO_IOCX_PROCESS` і дозвольте потрапити на шлях таймауту 16s.
2. **Звільнення під час використання:** Як тільки ioctl повертається, викличте `close(fd)`, щоб звільнити `inst`/`job`, поки робочий потік все ще виконує витягнуту задачу.
3. **Перехоплення + контроль вказівника:** Розпиліть reclaimers (наприклад, **Unix domain socket message** allocations), щоб зайняти звільнений слот slab і перезаписати inline `job`, особливо `job->regs`.
4. **Довільний запис:** Коли виконується `bigo_pull_regs()`, `memcpy_fromio()` записує **core->regs_size (~2144 bytes)** з MMIO у адресу, вказану в `job->regs`, створюючи великий write-what-where без KASLR leak.
5. **Формування даних:** Оскільки регістри спочатку програмуються з даних користувача (`bigo_push_regs`), встановіть їх так, щоб апаратура не виконувала інструкцій, зберігаючи скопійоване назад зображення регістрів максимально близьким до байтів, контрольованих атакуючим.

## Висновки для рев'юверів драйверів

- Inline структури job на FD, які ставляться в чергу асинхронним воркерам, повинні зберігати посилання, що переживуть шляхи таймауту/скасування; **закриття FD має синхронізуватися зі споживанням воркером**.
- Будь-які помічники копіювання MMIO (`memcpy_fromio`/`memcpy_toio`), які використовують вказівники на буфери з job, повинні бути перевірені або продубльовані перед постановкою в чергу, щоб уникнути UAF→write примітивів.

## Посилання

- [Pixel 0-click (Part 2): Escaping the mediacodec sandbox via the BigWave driver](https://projectzero.google/2026/01/pixel-0-click-part-2.html)
- [Project Zero issue 426567975 – BigWave BIGO timeout UAF](https://project-zero.issues.chromium.org/issues/426567975)

{{#include ../../banners/hacktricks-training.md}}
