# Off by one overflow

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Om net toegang te hê tot 'n 1B overflow laat 'n aanvaller toe om die `size` veld van die volgende chunk te verander. Dit maak dit moontlik om te manipuleer watter chunks werklik vrygestel word, wat potensieel 'n chunk kan genereer wat 'n ander wettige chunk bevat. Die uitbuiting is soortgelyk aan [double free](double-free.md) of oorvleuelende chunks.

Daar is 2 tipes off by one kwesbaarhede:

- Arbitrêre byte: Hierdie tipe laat toe om daardie byte met enige waarde te oorskryf
- Null byte (off-by-null): Hierdie tipe laat toe om daardie byte slegs met 0x00 te oorskryf
- 'n Algemene voorbeeld van hierdie kwesbaarheid kan gesien word in die volgende kode waar die gedrag van `strlen` en `strcpy` onbestendig is, wat dit moontlik maak om 'n 0x00 byte aan die begin van die volgende chunk in te stel.
- Dit kan uitgebruik word met die [House of Einherjar](house-of-einherjar.md).
- As Tcache gebruik word, kan dit benut word vir 'n [double free](double-free.md) situasie.

<details>

<summary>Off-by-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Onder andere kontroles, nou wanneer 'n stuk vry is, word die vorige grootte vergelyk met die grootte wat in die metadata se stuk gekonfigureer is, wat hierdie aanval redelik kompleks maak vanaf weergawe 2.28.

### Kode voorbeeld:

- [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking_free_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking_free_chunks.c)
- Hierdie aanval werk nie meer nie weens die gebruik van Tcaches.
- Boonop, as jy probeer om dit te misbruik met groter stukke (sodat tcaches nie betrokke is nie), sal jy die fout kry: `malloc(): invalid next size (unsorted)`

### Doel

- Maak 'n stuk ingesluit binne 'n ander stuk sodat skrywe toegang oor daardie tweede stuk toelaat om die ingeslote een te oorskry

### Vereistes

- Off by one overflow om die grootte metadata inligting te wysig

### Algemene off-by-one aanval

- Allokeer drie stukke `A`, `B` en `C` (sê groottes 0x20), en nog een om konsolidasie met die top-stuk te voorkom.
- Vry `C` (ingevoeg in 0x20 Tcache vrylys).
- Gebruik stuk `A` om oor te vloei op `B`. Misbruik off-by-one om die `size` veld van `B` van 0x21 na 0x41 te wysig.
- Nou het ons `B` wat die vrye stuk `C` bevat
- Vry `B` en allokeer 'n 0x40 stuk (dit sal hier weer geplaas word)
- Ons kan die `fd` pointer van `C` wysig, wat steeds vry is (Tcache vergiftiging)

### Off-by-null aanval

- 3 stukke geheue (a, b, c) word een na die ander gereserveer. Dan word die middelste een vrygestel. Die eerste een bevat 'n off by one overflow kwesbaarheid en die aanvaller misbruik dit met 'n 0x00 (as die vorige byte 0x10 was, sou dit die middelste stuk aandui dat dit 0x10 kleiner is as wat dit werklik is).
- Dan, 2 meer kleiner stukke word in die middel vrygestelde stuk (b) allokeer, egter, aangesien `b + b->size` nooit die c stuk opdateer nie omdat die aangeduide adres kleiner is as wat dit moet wees.
- Dan, b1 en c word vrygestel. Aangesien `c - c->prev_size` steeds na b (b1 nou) wys, word albei in een stuk gekonsolideer. egter, b2 is steeds binne tussen b1 en c.
- Laastens, 'n nuwe malloc word uitgevoer wat hierdie geheuegebied herwin wat eintlik b2 gaan bevat, wat die eienaar van die nuwe malloc toelaat om die inhoud van b2 te beheer.

Hierdie beeld verduidelik perfek die aanval:

<figure><img src="../../images/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Ander Voorbeelde & Verwysings

- [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks)
- [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
- Off-by-one weens `strlen` wat die volgende stuk se `size` veld oorweeg.
- Tcache word gebruik, so 'n algemene off-by-one aanval werk om 'n arbitrêre skrywe primitief met Tcache vergiftiging te verkry.
- [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/#1-asis-ctf-2016-b00ks)
- Dit is moontlik om 'n off by one te misbruik om 'n adres van die heap te lek omdat die byte 0x00 aan die einde van 'n string oorgeskryf word deur die volgende veld.
- Arbitrêre skrywe word verkry deur die off by one skrywe te misbruik om die pointer na 'n ander plek te laat wys waar 'n valse struktuur met valse pointers gebou sal word. Dan is dit moontlik om die pointer van hierdie struktuur te volg om arbitrêre skrywe te verkry.
- Die libc adres word gelek omdat as die heap met mmap uitgebrei word, die geheue wat deur mmap allokeer 'n vaste offset van libc het.
- Laastens word die arbitrêre skrywe misbruik om in die adres van \_\_free_hook te skryf met 'n een gadget.
- [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/#instance-2-plaidctf-2015-plaiddb)
- Daar is 'n NULL off by one kwesbaarheid in die `getline` funksie wat gebruikersinvoer lyne lees. Hierdie funksie word gebruik om die "sleutel" van die inhoud te lees en nie die inhoud nie.
- In die skrywe word 5 aanvanklike stukke geskep:
- stuk1 (0x200)
- stuk2 (0x50)
- stuk5 (0x68)
- stuk3 (0x1f8)
- stuk4 (0xf0)
- stuk verdediging (0x400) om te verhoed dat dit met die top stuk konsolideer
- Dan word stuk 1, 5 en 3 vrygestel, so:
- ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
- Dan, deur stuk3 (0x1f8) te misbruik, word die null off-by-one misbruik deur die prev_size na `0x4e0` te skryf.
- Let op hoe die groottes van die aanvanklike toegekende stukke 1, 2, 5 en 3 plus die koppe van 4 van daardie stukke gelyk is aan `0x4e0`: `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
- Dan, stuk 4 word vrygestel, wat 'n stuk genereer wat al die stukke tot by die begin verbruik:
- ```python
[ 0x4e0 Chunk 1-2-5-3 (free) ] [ 0xf0 Chunk 4 (corrupted) ] [ 0x400 Chunk defense ]
```
- ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
- Dan, word `0x200` bytes toegeken wat die oorspronklike stuk 1 vul
- En nog 'n 0x200 bytes word toegeken en stuk 2 word vernietig en daarom is daar geen lek nie en dit werk nie? Miskien moet dit nie gedoen word nie
- Dan, word 'n ander stuk met 0x58 "a"s toegeken (wat stuk 2 oorgeskryf en stuk 5 bereik) en die `fd` van die vinnige bin stuk van stuk 5 word gewysig om na `__malloc_hook` te wys
- Dan, word 'n stuk van 0x68 toegeken sodat die valse vinnige bin stuk in `__malloc_hook` die volgende vinnige bin stuk is
- Laastens, word 'n nuwe vinnige bin stuk van 0x68 toegeken en `__malloc_hook` word oorgeskryf met 'n `one_gadget` adres

{{#include ../../banners/hacktricks-training.md}}
