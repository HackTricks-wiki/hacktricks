# Off by one overflow

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

केवल 1B ओवरफ्लो तक पहुंच होने से एक हमलावर को अगले चंक के `size` फ़ील्ड को संशोधित करने की अनुमति मिलती है। यह यह तय करने की अनुमति देता है कि वास्तव में कौन से चंक मुक्त हैं, संभावित रूप से एक चंक उत्पन्न करना जो एक अन्य वैध चंक को शामिल करता है। शोषण [double free](double-free.md) या ओवरलैपिंग चंक्स के समान है।

ऑफ बाय वन कमजोरियों के 2 प्रकार हैं:

- मनमाना बाइट: यह प्रकार किसी भी मान के साथ उस बाइट को ओवरराइट करने की अनुमति देता है
- नल बाइट (ऑफ-बाय-नल): यह प्रकार उस बाइट को केवल 0x00 के साथ ओवरराइट करने की अनुमति देता है
- इस कमजोरी का एक सामान्य उदाहरण निम्नलिखित कोड में देखा जा सकता है जहां `strlen` और `strcpy` का व्यवहार असंगत है, जो अगले चंक की शुरुआत में 0x00 बाइट सेट करने की अनुमति देता है।
- इसे [House of Einherjar](house-of-einherjar.md) के साथ शोषित किया जा सकता है।
- यदि Tcache का उपयोग किया जा रहा है, तो इसे [double free](double-free.md) स्थिति में लाभ उठाया जा सकता है।

<details>

<summary>Off-by-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

अन्य जांचों के बीच, अब जब भी एक चंक मुक्त होता है, तो पिछले आकार की तुलना मेटाडेटा के चंक में कॉन्फ़िगर किए गए आकार से की जाती है, जिससे यह हमला संस्करण 2.28 से काफी जटिल हो जाता है।

### कोड उदाहरण:

- [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking_free_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking_free_chunks.c)
- यह हमला Tcaches के उपयोग के कारण अब काम नहीं कर रहा है।
- इसके अलावा, यदि आप इसे बड़े चंक्स का उपयोग करके दुरुपयोग करने की कोशिश करते हैं (ताकि tcaches शामिल न हों), तो आपको त्रुटि मिलेगी: `malloc(): invalid next size (unsorted)`

### लक्ष्य

- एक चंक को दूसरे चंक के अंदर रखना ताकि उस दूसरे चंक पर लेखन पहुंच उसे ओवरराइट करने की अनुमति दे।

### आवश्यकताएँ

- आकार मेटाडेटा जानकारी को संशोधित करने के लिए ऑफ बाय वन ओवरफ्लो।

### सामान्य ऑफ-बाय-वन हमला

- तीन चंक्स `A`, `B` और `C` (मान लें आकार 0x20) आवंटित करें, और एक और एक को शीर्ष-चंक के साथ समेकन से रोकने के लिए।
- `C` को मुक्त करें (0x20 Tcache मुक्त-सूची में डाला गया)।
- चंक `A` का उपयोग करके `B` पर ओवरफ्लो करें। `B` के `size` फ़ील्ड को 0x21 से 0x41 में संशोधित करने के लिए ऑफ-बाय-वन का दुरुपयोग करें।
- अब हमारे पास `B` में मुक्त चंक `C` है।
- `B` को मुक्त करें और एक 0x40 चंक आवंटित करें (यह फिर से यहाँ रखा जाएगा)।
- हम `C` से `fd` पॉइंटर को संशोधित कर सकते हैं, जो अभी भी मुक्त है (Tcache विषाक्तता)।

### ऑफ-बाय-नल हमला

- 3 मेमोरी चंक्स (a, b, c) एक के बाद एक आरक्षित किए जाते हैं। फिर मध्य वाला मुक्त किया जाता है। पहला एक ऑफ बाय वन ओवरफ्लो भेद्यता रखता है और हमलावर इसका दुरुपयोग 0x00 के साथ करता है (यदि पिछले बाइट 0x10 था तो यह मध्य चंक को यह संकेत देगा कि यह वास्तव में 0x10 छोटा है)।
- फिर, मध्य मुक्त चंक (b) में 2 और छोटे चंक्स आवंटित किए जाते हैं, हालाँकि, चूंकि `b + b->size` कभी भी c चंक को अपडेट नहीं करता है क्योंकि पॉइंटेड पता जितना होना चाहिए उससे छोटा है।
- फिर, b1 और c को मुक्त किया जाता है। चूंकि `c - c->prev_size` अभी भी b (अब b1) की ओर इशारा करता है, दोनों एक चंक में समेकित होते हैं। हालाँकि, b2 अभी भी b1 और c के बीच में है।
- अंततः, एक नया malloc किया जाता है जो इस मेमोरी क्षेत्र को पुनः प्राप्त करता है जो वास्तव में b2 को समाहित करने जा रहा है, जिससे नए malloc के मालिक को b2 की सामग्री को नियंत्रित करने की अनुमति मिलती है।

यह चित्र हमले को पूरी तरह से समझाता है:

<figure><img src="../../images/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## अन्य उदाहरण और संदर्भ

- [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks)
- [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
- `strlen` के कारण ऑफ-बाय-वन।
- Tcache का उपयोग किया जा रहा है, इसलिए एक सामान्य ऑफ-बाय-वन हमले का उपयोग Tcache विषाक्तता के साथ एक मनमाना लिखने की प्राइमिटिव प्राप्त करने के लिए किया जाता है।
- [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/#1-asis-ctf-2016-b00ks)
- एक ऑफ बाय वन का दुरुपयोग करके हीप से एक पता लीक करना संभव है क्योंकि एक स्ट्रिंग के अंत का बाइट 0x00 अगले फ़ील्ड द्वारा ओवरराइट किया जा रहा है।
- मनमाना लिखने को प्राप्त करने के लिए ऑफ बाय वन लिखने का दुरुपयोग किया जाता है ताकि पॉइंटर को एक और स्थान पर इंगित किया जा सके जहाँ एक नकली संरचना के साथ नकली पॉइंटर्स बनाए जाएंगे। फिर, इस संरचना के पॉइंटर का पालन करके मनमाना लिखना संभव है।
- libc पता लीक होता है क्योंकि यदि हीप को mmap का उपयोग करके बढ़ाया जाता है, तो mmap द्वारा आवंटित मेमोरी libc से एक निश्चित ऑफसेट रखती है।
- अंततः मनमाना लिखने का दुरुपयोग किया जाता है ताकि \_\_free_hook के पते पर एक गेजेट लिखा जा सके।
- [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/#instance-2-plaidctf-2015-plaiddb)
- `getline` फ़ंक्शन में एक NULL ऑफ बाय वन भेद्यता है जो उपयोगकर्ता इनपुट पंक्तियों को पढ़ता है। यह फ़ंक्शन सामग्री की "कुंजी" पढ़ने के लिए उपयोग किया जाता है और सामग्री नहीं।
- लेखन में 5 प्रारंभिक चंक्स बनाए जाते हैं:
- chunk1 (0x200)
- chunk2 (0x50)
- chunk5 (0x68)
- chunk3 (0x1f8)
- chunk4 (0xf0)
- शीर्ष चंक के साथ समेकन से बचने के लिए चंक रक्षा (0x400)
- फिर चंक 1, 5 और 3 को मुक्त किया जाता है, इसलिए:
- ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
- फिर चंक3 (0x1f8) का दुरुपयोग करते हुए नल ऑफ-बाय-वन का दुरुपयोग करते हुए prev_size को `0x4e0` पर लिखा जाता है।
- ध्यान दें कि प्रारंभ में आवंटित चंक्स 1, 2, 5 और 3 के आकार और उन चंक्स के 4 हेडर का योग `0x4e0` के बराबर है: `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
- फिर, चंक 4 को मुक्त किया जाता है, एक चंक उत्पन्न करते हुए जो सभी चंक्स को शुरुआत तक खा जाता है:
- ```python
[ 0x4e0 Chunk 1-2-5-3 (free) ] [ 0xf0 Chunk 4 (corrupted) ] [ 0x400 Chunk defense ]
```
- ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
- फिर, `0x200` बाइट्स आवंटित किए जाते हैं जो मूल चंक 1 को भरते हैं।
- और फिर 0x200 बाइट्स आवंटित किए जाते हैं और चंक2 नष्ट हो जाता है और इसलिए कोई लीक नहीं होती है और यह काम नहीं करता? शायद ऐसा नहीं करना चाहिए।
- फिर, यह 0x58 "a"s के साथ एक और चंक आवंटित करता है (चंक2 को ओवरराइट करते हुए और चंक5 तक पहुँचते हुए) और चंक5 के तेज़ बिन चंक के `fd` को `__malloc_hook` की ओर इशारा करते हुए संशोधित करता है।
- फिर, 0x68 का एक चंक आवंटित किया जाता है ताकि `__malloc_hook` में नकली तेज़ बिन चंक अगला तेज़ बिन चंक हो।
- अंततः, 0x68 का एक नया तेज़ बिन चंक आवंटित किया जाता है और `__malloc_hook` को एक `one_gadget` पते के साथ ओवरराइट किया जाता है।

{{#include ../../banners/hacktricks-training.md}}
