# Libc Heap

{{#include ../../banners/hacktricks-training.md}}

## Heap Basics

Die heap is basies die plek waar 'n program data kan stoor wanneer dit data versoek deur funksies te roep soos **`malloc`**, `calloc`... Verder, wanneer hierdie geheue nie meer nodig is nie, word dit beskikbaar gestel deur die funksie **`free`** te roep.

Soos getoon, is dit net ná waar die binary in geheue gelaai word (kyk die `[heap]` afdeling):

<figure><img src="../../images/image (1241).png" alt=""><figcaption></figcaption></figure>

### Basic Chunk Allocation

Wanneer data versoek word om in die heap gestoor te word, word 'n deel van die heap aan dit toegeken. Hierdie ruimte sal aan 'n bin behoort en slegs die versoekte data + die ruimte van die bin headers + die minimum bin-grootte-offset sal vir die chunk gereserveer word. Die doel is om soveel moontlike min geheue te reserveer sonder om dit ingewikkeld te maak om te vind waar elke chunk is. Hiervoor word die chunk-metagegewens gebruik om te weet waar elke gebruikte/vrye chunk is.

Daar is verskillende maniere om die ruimte te reserveer, hoofsaaklik afhangend van die gebruikte bin, maar 'n algemene metodologie is die volgende:

- Die program begin deur 'n sekere hoeveelheid geheue te versoek.
- As daar in die lys van chunks 'n chunk beskikbaar is wat groot genoeg is om die versoek te vervul, sal dit gebruik word.
- Dit kan selfs beteken dat 'n deel van die beskikbare chunk vir hierdie versoek gebruik word en die res by die chunks-lys gevoeg word.
- As daar geen beskikbare chunk in die lys is nie, maar daar steeds spasie in die toegekende heap-geheue is, skep die heap-bestuurder 'n nuwe chunk.
- As daar nie genoeg heap-spasie is om die nuwe chunk toe te ken nie, vra die heap-bestuurder die kernel om die geheue wat aan die heap toegeken is uit te brei en gebruik dan hierdie geheue om die nuwe chunk te genereer.
- As alles misluk, gee `malloc` null terug.

Let daarop dat as die versoekte **geheue 'n drempel oorskry**, sal **`mmap`** gebruik word om die versoekte geheue te map.

## Arenas

In **multithreaded** toepassings moet die heap-bestuurder **race conditions** voorkom wat tot crashes kan lei. Aanvanklik is dit gedoen deur 'n **global mutex** te gebruik om te verseker dat net een thread op 'n slag toegang tot die heap het, maar dit het **prestasieprobleme** veroorsaak weens die bottleneck wat deur die mutex geskep is.

Om dit aan te spreek het die ptmalloc2 heap allocator 'arenas' ingevoer, waar elke arena optree as 'n separate heap met sy own data structures en mutex, wat dit moontlik maak vir meerdere threads om heap-operasies uit te voer sonder om mekaar te steur, solank hulle verskillende arenas gebruik.

Die standaard "main" arena hanteer heap-operasies vir single-threaded toepassings. Wanneer **new threads** bygevoeg word, ken die heap-bestuurder vir hulle **secondary arenas** toe om kontensie te verminder. Dit probeer eers om elke nuwe thread aan 'n onbenutte arena te koppel, en skep nuwe arenas indien nodig, tot 'n limiet van 2 keer die aantal CPU-kerne vir 32-bit stelsels en 8 keer vir 64-bit stelsels. Sodra die limiet bereik is, **moet threads arenas deel**, wat tot potensiële kontensie kan lei.

Anders as die main arena, wat uitbrei deur die `brk` system call, skep secondary arenas "subheaps" deur gebruik te maak van `mmap` en `mprotect` om die heap-gedrag na te boots, wat buigbaarheid bied in die bestuur van geheue vir multithreaded operasies.

### Subheaps

Subheaps dien as geheue-reserwes vir secondary arenas in multithreaded toepassings, wat hulle toelaat om te groei en hul eie heap-streke apart van die main heap te bestuur. Hier is hoe subheaps verskil van die aanvanklike heap en hoe hulle werk:

1. Initial Heap vs. Subheaps:
- Die aanvanklike heap is direk na die program se binary in geheue geleë, en dit brei uit deur die `sbrk` system call te gebruik.

2. Memory Reservation with `mmap`:
- Wanneer die heap-bestuurder 'n subheap skep, reserveer dit 'n groot blok geheue deur `mmap`. Hierdie reservasie ken nie onmiddellik fisiese geheue toe nie; dit dui eenvoudig 'n streek aan wat ander stelselprosesse of toekenninge nie moet gebruik nie.
- Standaard is die gereserveerde grootte vir 'n subheap 1 MB vir 32-bit prosesse en 64 MB vir 64-bit prosesse.

3. Gradual Expansion with `mprotect`:
- Die gereserveerde geheuegebied word aanvanklik gemerk as `PROT_NONE`, wat aandui dat die kernel nog nie fisiese geheue na hierdie area hoef toe te ken nie.
- Om die subheap te "grow", gebruik die heap-bestuurder `mprotect` om bladsytoestemmings van `PROT_NONE` na `PROT_READ | PROT_WRITE` te verander, wat die kernel aanmoedig om fisiese geheue aan die voorheen gereserveerde adresse toe te ken. Hierdie stapsgewyse benadering stel die subheap in staat om na behoefte uit te brei.
- Sodra die hele subheap uitgeput is, skep die heap-bestuurder 'n nuwe subheap om toekenning voort te sit.

### heap_info <a href="#heap_info" id="heap_info"></a>

Hierdie struct stoor relevante inligting oor die heap. Verder mag heap-geheue na meer toewysings nie aaneenlopend wees nie; hierdie struct sal daardie inligting ook stoor.
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/arena.c#L837

typedef struct _heap_info
{
mstate ar_ptr; /* Arena for this heap. */
struct _heap_info *prev; /* Previous heap. */
size_t size;   /* Current size in bytes. */
size_t mprotect_size; /* Size in bytes that has been mprotected
PROT_READ|PROT_WRITE.  */
size_t pagesize; /* Page size used when allocating the arena.  */
/* Make sure the following data is properly aligned, particularly
that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of
MALLOC_ALIGNMENT. */
char pad[-3 * SIZE_SZ & MALLOC_ALIGN_MASK];
} heap_info;
```
### malloc_state

**Elke heap** (main arena of ander thread-arenas) het 'n **`malloc_state` struktuur.**\
Dit is belangrik om op te let dat die **main arena `malloc_state`** struktuur 'n **globale veranderlike in die libc** is (dus geleë in die libc geheue-ruimte).\
In die geval van **`malloc_state`** strukture van die heaps van threads, is dit geleë **binne die eie thread "heap"**.

Daar is 'n paar interessante dinge om op te let by hierdie struktuur (sien C-kode hieronder):

- `__libc_lock_define (, mutex);` is daar om te verseker dat hierdie struktuur vanaf die heap deur een thread op 'n slag toeganklik is
- Vlagte:

- ```c
#define NONCONTIGUOUS_BIT     (2U)

#define contiguous(M)          (((M)->flags & NONCONTIGUOUS_BIT) == 0)
#define noncontiguous(M)       (((M)->flags & NONCONTIGUOUS_BIT) != 0)
#define set_noncontiguous(M)   ((M)->flags |= NONCONTIGUOUS_BIT)
#define set_contiguous(M)      ((M)->flags &= ~NONCONTIGUOUS_BIT)
```

- Die `mchunkptr bins[NBINS * 2 - 2];` bevat **pointers** na die **eerste en laaste chunks** van die klein, groot en ongesorteerde **bins** (die -2 is omdat indeks 0 nie gebruik word nie)
- Daarom sal die **eerste chunk** van hierdie bins 'n **agterwaartse pointer na hierdie struktuur** hê en die **laaste chunk** van hierdie bins 'n **vorentoe pointer** na hierdie struktuur hê. Dit beteken basies dat as jy hierdie adresse in die main arena kan leak, sal jy 'n pointer na die struktuur in die **libc** hê.
- Die structs `struct malloc_state *next;` en `struct malloc_state *next_free;` is gekoppelde lyste van arenas
- Die `top` chunk is die laaste "chunk", wat basies **al die oorblywende heap-ruimte** is. Sodra die top chunk "leeg" is, is die heap ten volle gebruik en moet dit meer ruimte versoek.
- Die `last reminder` chunk ontstaan in gevalle waar 'n presiese grootte chunk nie beskikbaar is nie en daarom 'n groter chunk gesplit word; 'n oorblywende deel (pointer) word hier geplaas.
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1812

struct malloc_state
{
/* Serialize access.  */
__libc_lock_define (, mutex);

/* Flags (formerly in max_fast).  */
int flags;

/* Set if the fastbin chunks contain recently inserted free blocks.  */
/* Note this is a bool but not all targets support atomics on booleans.  */
int have_fastchunks;

/* Fastbins */
mfastbinptr fastbinsY[NFASTBINS];

/* Base of the topmost chunk -- not otherwise kept in a bin */
mchunkptr top;

/* The remainder from the most recent split of a small request */
mchunkptr last_remainder;

/* Normal bins packed as described above */
mchunkptr bins[NBINS * 2 - 2];

/* Bitmap of bins */
unsigned int binmap[BINMAPSIZE];

/* Linked list */
struct malloc_state *next;

/* Linked list for free arenas.  Access to this field is serialized
by free_list_lock in arena.c.  */
struct malloc_state *next_free;

/* Number of threads attached to this arena.  0 if the arena is on
the free list.  Access to this field is serialized by
free_list_lock in arena.c.  */
INTERNAL_SIZE_T attached_threads;

/* Memory allocated from the system in this arena.  */
INTERNAL_SIZE_T system_mem;
INTERNAL_SIZE_T max_system_mem;
};
```
### malloc_chunk

Hierdie struktuur verteenwoordig 'n spesifieke chunk van geheue. Die verskillende velde het verskillende betekenisse vir allocated en unallocated chunks.
```c
// https://github.com/bminor/glibc/blob/master/malloc/malloc.c
struct malloc_chunk {
INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk, if it is free. */
INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
struct malloc_chunk* fd;                /* double links -- used only if this chunk is free. */
struct malloc_chunk* bk;
/* Only used for large blocks: pointer to next larger size.  */
struct malloc_chunk* fd_nextsize; /* double links -- used only if this chunk is free. */
struct malloc_chunk* bk_nextsize;
};

typedef struct malloc_chunk* mchunkptr;
```
Soos vroeër opgemerk, het hierdie chunks ook metadata, baie goed voorgestel in hierdie beeld:

<figure><img src="../../images/image (1242).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

Die metadata is gewoonlik 0x08B wat die huidige chunk-grootte aandui deur die laaste 3 bis te gebruik om aan te dui:

- `A`: As dit 1 is kom dit van 'n subheap, as dit 0 is is dit in die main arena
- `M`: As dit 1 is, is hierdie chunk deel van 'n ruimte wat met mmap gealloceer is en nie deel van 'n heap nie
- `P`: As dit 1 is, is die vorige chunk in gebruik

Dan die ruimte vir die gebruikersdata, en uiteindelik 0x08B om die vorige chunk-grootte aan te dui wanneer die chunk beskikbaar is (of om gebruikersdata te stoor wanneer dit gealloceer is).

Verder, wanneer beskikbaar, word die gebruikersdata ook gebruik om sommige data te bevat:

- **`fd`**: Aanwyser na die volgende chunk
- **`bk`**: Aanwyser na die vorige chunk
- **`fd_nextsize`**: Aanwyser na die eerste chunk in die lys wat kleiner as dit is
- **`bk_nextsize`**: Aanwyser na die eerste chunk in die lys wat groter as dit is

<figure><img src="../../images/image (1243).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

> [!TIP]
> Let op hoe die koppeling van die lys op hierdie wyse die behoefte verhoed om 'n array te hê waarin elke chunk geregistreer word.

### Chunk-aanwysers

Wanneer malloc gebruik word, word 'n aanwyser na die inhoud wat geskryf kan word teruggegee (net na die headers), maar wanneer chunks bestuur word, is 'n aanwyser na die begin van die headers (metadata) nodig.\
Vir hierdie omskakelings word hierdie funksies gebruik:
```c
// https://github.com/bminor/glibc/blob/master/malloc/malloc.c

/* Convert a chunk address to a user mem pointer without correcting the tag.  */
#define chunk2mem(p) ((void*)((char*)(p) + CHUNK_HDR_SZ))

/* Convert a user mem pointer to a chunk address and extract the right tag.  */
#define mem2chunk(mem) ((mchunkptr)tag_at (((char*)(mem) - CHUNK_HDR_SZ)))

/* The smallest possible chunk */
#define MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))

/* The smallest size we can malloc is an aligned minimal chunk */

#define MINSIZE  \
(unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK))
```
### Uitlijning & min grootte

Die pointer na die chunk en `0x0f` moet 0 wees.
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/sysdeps/generic/malloc-size.h#L61
#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)

// https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/sysdeps/i386/malloc-alignment.h
#define MALLOC_ALIGNMENT 16


// https://github.com/bminor/glibc/blob/master/malloc/malloc.c
/* Check if m has acceptable alignment */
#define aligned_OK(m)  (((unsigned long)(m) & MALLOC_ALIGN_MASK) == 0)

#define misaligned_chunk(p) \
((uintptr_t)(MALLOC_ALIGNMENT == CHUNK_HDR_SZ ? (p) : chunk2mem (p)) \
& MALLOC_ALIGN_MASK)


/* pad request bytes into a usable size -- internal version */
/* Note: This must be a macro that evaluates to a compile time constant
if passed a literal constant.  */
#define request2size(req)                                         \
(((req) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE)  ?             \
MINSIZE :                                                      \
((req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK)

/* Check if REQ overflows when padded and aligned and if the resulting
value is less than PTRDIFF_T.  Returns the requested size or
MINSIZE in case the value is less than MINSIZE, or 0 if any of the
previous checks fail.  */
static inline size_t
checked_request2size (size_t req) __nonnull (1)
{
if (__glibc_unlikely (req > PTRDIFF_MAX))
return 0;

/* When using tagged memory, we cannot share the end of the user
block with the header for the next chunk, so ensure that we
allocate blocks that are rounded up to the granule size.  Take
care not to overflow from close to MAX_SIZE_T to a small
number.  Ideally, this would be part of request2size(), but that
must be a macro that produces a compile time constant if passed
a constant literal.  */
if (__glibc_unlikely (mtag_enabled))
{
/* Ensure this is not evaluated if !mtag_enabled, see gcc PR 99551.  */
asm ("");

req = (req + (__MTAG_GRANULE_SIZE - 1)) &
~(size_t)(__MTAG_GRANULE_SIZE - 1);
}

return request2size (req);
}
```
Let wel dat by die berekening van die totale spasie wat benodig word, slegs `SIZE_SZ` een keer bygevoeg word, omdat die `prev_size` veld gebruik kan word om data te stoor; daarom is slegs die aanvanklike header nodig.

### Verkry Chunk data en verander metadata

Hierdie funksies werk deur 'n pointer na 'n chunk te ontvang en is nuttig om metadata te kontroleer/te stel:

- Check chunk flags
```c
// From https://github.com/bminor/glibc/blob/master/malloc/malloc.c


/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */
#define PREV_INUSE 0x1

/* extract inuse bit of previous chunk */
#define prev_inuse(p)       ((p)->mchunk_size & PREV_INUSE)


/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */
#define IS_MMAPPED 0x2

/* check for mmap()'ed chunk */
#define chunk_is_mmapped(p) ((p)->mchunk_size & IS_MMAPPED)


/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained
from a non-main arena.  This is only set immediately before handing
the chunk to the user, if necessary.  */
#define NON_MAIN_ARENA 0x4

/* Check for chunk from main arena.  */
#define chunk_main_arena(p) (((p)->mchunk_size & NON_MAIN_ARENA) == 0)

/* Mark a chunk as not being on the main arena.  */
#define set_non_main_arena(p) ((p)->mchunk_size |= NON_MAIN_ARENA)
```
- Groottes en pointers na ander chunks
```c
/*
Bits to mask off when extracting size

Note: IS_MMAPPED is intentionally not masked off from size field in
macros for which mmapped chunks should never be seen. This should
cause helpful core dumps to occur if it is tried by accident by
people extending or adapting this malloc.
*/
#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)

/* Get size, ignoring use bits */
#define chunksize(p) (chunksize_nomask (p) & ~(SIZE_BITS))

/* Like chunksize, but do not mask SIZE_BITS.  */
#define chunksize_nomask(p)         ((p)->mchunk_size)

/* Ptr to next physical malloc_chunk. */
#define next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))

/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */
#define prev_size(p) ((p)->mchunk_prev_size)

/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */
#define set_prev_size(p, sz) ((p)->mchunk_prev_size = (sz))

/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */
#define prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))

/* Treat space at ptr + offset as a chunk */
#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))
```
- Insue bit
```c
/* extract p's inuse bit */
#define inuse(p)							      \
((((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size) & PREV_INUSE)

/* set/clear chunk as being inuse without otherwise disturbing */
#define set_inuse(p)							      \
((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size |= PREV_INUSE

#define clear_inuse(p)							      \
((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size &= ~(PREV_INUSE)


/* check/set/clear inuse bits in known places */
#define inuse_bit_at_offset(p, s)					      \
(((mchunkptr) (((char *) (p)) + (s)))->mchunk_size & PREV_INUSE)

#define set_inuse_bit_at_offset(p, s)					      \
(((mchunkptr) (((char *) (p)) + (s)))->mchunk_size |= PREV_INUSE)

#define clear_inuse_bit_at_offset(p, s)					      \
(((mchunkptr) (((char *) (p)) + (s)))->mchunk_size &= ~(PREV_INUSE))
```
- Stel head en footer (wanneer chunk nos in gebruik
```c
/* Set size at head, without disturbing its use bit */
#define set_head_size(p, s)  ((p)->mchunk_size = (((p)->mchunk_size & SIZE_BITS) | (s)))

/* Set size/use field */
#define set_head(p, s)       ((p)->mchunk_size = (s))

/* Set size at footer (only when chunk is not in use) */
#define set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))->mchunk_prev_size = (s))
```
- Kry die grootte van die werklike bruikbare data binne die chunk
```c
#pragma GCC poison mchunk_size
#pragma GCC poison mchunk_prev_size

/* This is the size of the real usable data in the chunk.  Not valid for
dumped heap chunks.  */
#define memsize(p)                                                    \
(__MTAG_GRANULE_SIZE > SIZE_SZ && __glibc_unlikely (mtag_enabled) ? \
chunksize (p) - CHUNK_HDR_SZ :                                    \
chunksize (p) - CHUNK_HDR_SZ + (chunk_is_mmapped (p) ? 0 : SIZE_SZ))

/* If memory tagging is enabled the layout changes to accommodate the granule
size, this is wasteful for small allocations so not done by default.
Both the chunk header and user data has to be granule aligned.  */
_Static_assert (__MTAG_GRANULE_SIZE <= CHUNK_HDR_SZ,
"memory tagging is not supported with large granule.");

static __always_inline void *
tag_new_usable (void *ptr)
{
if (__glibc_unlikely (mtag_enabled) && ptr)
{
mchunkptr cp = mem2chunk(ptr);
ptr = __libc_mtag_tag_region (__libc_mtag_new_tag (ptr), memsize (cp));
}
return ptr;
}
```
## Voorbeelde

### Vinnige Heap-voorbeeld

Vinnige heap-voorbeeld van [https://guyinatuxedo.github.io/25-heap/index.html](https://guyinatuxedo.github.io/25-heap/index.html) maar in arm64:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void main(void)
{
char *ptr;
ptr = malloc(0x10);
strcpy(ptr, "panda");
}
```
Stel 'n breakpoint aan die einde van die main-funksie en kom ons vind uit waar die inligting gestoor is:

<figure><img src="../../images/image (1239).png" alt=""><figcaption></figcaption></figure>

Dit is moontlik om te sien dat die string panda gestoor is by `0xaaaaaaac12a0` (wat die adres was wat as respons deur malloc in `x0` gegee is). As jy 0x10 bytes vroeër kyk, kan jy sien dat die `0x0` aandui dat die **vorige chunk nie gebruik is** (lengte 0) en dat die lengte van hierdie chunk `0x21` is.

Die ekstra ruimte wat gereserveer is (0x21-0x10=0x11) kom van die **bygevoegde headers** (0x10) en 0x1 beteken nie dat dit 0x21B gereserveer is nie, maar die laaste 3 bisse van die lengte van die huidige header het 'n paar spesiale betekenisse. Aangesien die lengte altyd 16-byte uitgelijnd is (op 64-bit masjiene), gaan hierdie bits eintlik nooit deur die lengtegetal gebruik word nie.
```
0x1:     Previous in Use     - Specifies that the chunk before it in memory is in use
0x2:     Is MMAPPED          - Specifies that the chunk was obtained with mmap()
0x4:     Non Main Arena      - Specifies that the chunk was obtained from outside of the main arena
```
### Meerdraad-voorbeeld

<details>

<summary>Meerdraad</summary>
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/types.h>


void* threadFuncMalloc(void* arg) {
printf("Hello from thread 1\n");
char* addr = (char*) malloc(1000);
printf("After malloc and before free in thread 1\n");
free(addr);
printf("After free in thread 1\n");
}

void* threadFuncNoMalloc(void* arg) {
printf("Hello from thread 2\n");
}


int main() {
pthread_t t1;
void* s;
int ret;
char* addr;

printf("Before creating thread 1\n");
getchar();
ret = pthread_create(&t1, NULL, threadFuncMalloc, NULL);
getchar();

printf("Before creating thread 2\n");
ret = pthread_create(&t1, NULL, threadFuncNoMalloc, NULL);

printf("Before exit\n");
getchar();

return 0;
}
```
</details>

Deur die vorige voorbeeld te debug, kan jy sien dat daar aan die begin net 1 arena is:

<figure><img src="../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Daarna, nadat die eerste thread geroep is — die een wat malloc oproep — word 'n nuwe arena geskep:

<figure><img src="../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

en binne-in daarvan kan 'n paar chunks gevind word:

<figure><img src="../../images/image (2) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Bins & Geheue-toewysings/Vrystellings

Kyk wat die bins is, hoe hulle georganiseer is en hoe geheue toegeken en vrygestel word in:


{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

## Heap Funksies Sekuriteitskontroles

Funksies wat by die heap betrokke is, sal sekere kontroles uitvoer voordat hulle aksies neem om te probeer verseker dat die heap nie gekorrupteer is nie:


{{#ref}}
heap-memory-functions/heap-functions-security-checks.md
{{#endref}}

## Gevallestudies

Bestudeer allocator-spesifieke primitives wat van regte wêreld bugs afgelei is:

{{#ref}}
virtualbox-slirp-nat-packet-heap-exploitation.md
{{#endref}}

{{#ref}}
gnu-obstack-function-pointer-hijack.md
{{#endref}}

## Verwysings

- [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
- [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)


{{#include ../../banners/hacktricks-training.md}}
