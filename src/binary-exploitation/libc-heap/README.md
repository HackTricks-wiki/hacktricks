# Libc Heap

## Heap Grundlagen

Der Heap ist im Grunde der Ort, an dem ein Programm Daten speichern kann, wenn es Daten anfordert, indem es Funktionen wie **`malloc`**, `calloc`... aufruft. Darüber hinaus wird dieser Speicher, wenn er nicht mehr benötigt wird, durch den Aufruf der Funktion **`free`** wieder verfügbar gemacht.

Wie gezeigt, befindet er sich direkt nach dem Laden des Binaries im Speicher (siehe den Abschnitt `[heap]`):

<figure><img src="../../images/image (1241).png" alt=""><figcaption></figcaption></figure>

### Grundlegende Chunk-Zuweisung

Wenn Daten angefordert werden, um im Heap gespeichert zu werden, wird ein Teil des Heaps dafür reserviert. Dieser Speicher gehört zu einem Bin und nur die angeforderten Daten + der Speicher der Bin-Header + der Offset der minimalen Bin-Größe werden für den Chunk reserviert. Das Ziel ist es, so wenig Speicher wie möglich zu reservieren, ohne es kompliziert zu machen, wo sich jeder Chunk befindet. Zu diesem Zweck werden die Metadaten-Chunk-Informationen verwendet, um zu wissen, wo sich jeder verwendete/freie Chunk befindet.

Es gibt verschiedene Möglichkeiten, den Speicher zu reservieren, die hauptsächlich von dem verwendeten Bin abhängen, aber eine allgemeine Methodik ist die folgende:

- Das Programm beginnt mit der Anforderung einer bestimmten Menge an Speicher.
- Wenn in der Liste der Chunks ein verfügbarer, ausreichend großer Chunk vorhanden ist, wird dieser verwendet.
- Dies kann sogar bedeuten, dass ein Teil des verfügbaren Chunks für diese Anfrage verwendet wird und der Rest zur Chunk-Liste hinzugefügt wird.
- Wenn in der Liste kein verfügbarer Chunk vorhanden ist, aber noch Speicher im zugewiesenen Heap vorhanden ist, erstellt der Heap-Manager einen neuen Chunk.
- Wenn nicht genügend Heap-Speicher vorhanden ist, um den neuen Chunk zuzuweisen, fragt der Heap-Manager den Kernel, den dem Heap zugewiesenen Speicher zu erweitern, und verwendet dann diesen Speicher, um den neuen Chunk zu generieren.
- Wenn alles fehlschlägt, gibt `malloc` null zurück.

Beachten Sie, dass, wenn der angeforderte **Speicher einen Schwellenwert überschreitet**, **`mmap`** verwendet wird, um den angeforderten Speicher zuzuordnen.

## Arenen

In **multithreaded** Anwendungen muss der Heap-Manager **Race Conditions** verhindern, die zu Abstürzen führen könnten. Ursprünglich wurde dies durch die Verwendung eines **globalen Mutex** erreicht, um sicherzustellen, dass nur ein Thread gleichzeitig auf den Heap zugreifen kann, was jedoch **Leistungsprobleme** aufgrund des durch den Mutex verursachten Engpasses verursachte.

Um dies zu beheben, führte der ptmalloc2 Heap-Allocator "Arenen" ein, wobei **jede Arena** als **separater Heap** mit ihren **eigenen** Daten **strukturen** und **Mutex** fungiert, sodass mehrere Threads Heap-Operationen durchführen können, ohne sich gegenseitig zu stören, solange sie unterschiedliche Arenen verwenden.

Die Standard-"Haupt"-Arena verwaltet Heap-Operationen für Single-Thread-Anwendungen. Wenn **neue Threads** hinzugefügt werden, weist der Heap-Manager ihnen **sekundäre Arenen** zu, um die Konkurrenz zu verringern. Er versucht zunächst, jeden neuen Thread an eine ungenutzte Arena anzuhängen und erstellt bei Bedarf neue, bis zu einem Limit von 2 mal der Anzahl der CPU-Kerne für 32-Bit-Systeme und 8 mal für 64-Bit-Systeme. Sobald das Limit erreicht ist, **müssen Threads Arenen teilen**, was zu potenzieller Konkurrenz führt.

Im Gegensatz zur Hauptarena, die sich mit dem `brk` Systemaufruf erweitert, erstellen sekundäre Arenen "Subheaps" mit `mmap` und `mprotect`, um das Verhalten des Heaps zu simulieren, was Flexibilität bei der Verwaltung des Speichers für multithreaded Operationen ermöglicht.

### Subheaps

Subheaps dienen als Speicherreserven für sekundäre Arenen in multithreaded Anwendungen, sodass sie wachsen und ihre eigenen Heap-Bereiche getrennt vom Haupt-Heap verwalten können. So unterscheiden sich Subheaps vom ursprünglichen Heap und so funktionieren sie:

1. **Ursprünglicher Heap vs. Subheaps**:
- Der ursprüngliche Heap befindet sich direkt nach dem Binary des Programms im Speicher und erweitert sich mit dem `sbrk` Systemaufruf.
- Subheaps, die von sekundären Arenen verwendet werden, werden durch `mmap` erstellt, einen Systemaufruf, der einen bestimmten Speicherbereich zuordnet.
2. **Speicherreservierung mit `mmap`**:
- Wenn der Heap-Manager einen Subheap erstellt, reserviert er einen großen Speicherblock über `mmap`. Diese Reservierung allokiert nicht sofort Speicher; sie weist einfach einen Bereich zu, den andere Systemprozesse oder Zuweisungen nicht verwenden sollten.
- Standardmäßig beträgt die reservierte Größe für einen Subheap 1 MB für 32-Bit-Prozesse und 64 MB für 64-Bit-Prozesse.
3. **Allmähliche Erweiterung mit `mprotect`**:
- Der reservierte Speicherbereich ist zunächst als `PROT_NONE` markiert, was bedeutet, dass der Kernel noch keinen physischen Speicher für diesen Bereich zuweisen muss.
- Um den Subheap "zu vergrößern", verwendet der Heap-Manager `mprotect`, um die Seitenberechtigungen von `PROT_NONE` auf `PROT_READ | PROT_WRITE` zu ändern, was den Kernel auffordert, physischen Speicher für die zuvor reservierten Adressen zuzuweisen. Dieser schrittweise Ansatz ermöglicht es dem Subheap, nach Bedarf zu wachsen.
- Sobald der gesamte Subheap erschöpft ist, erstellt der Heap-Manager einen neuen Subheap, um die Zuweisung fortzusetzen.

### heap_info <a href="#heap_info" id="heap_info"></a>

Diese Struktur weist relevante Informationen des Heaps zu. Darüber hinaus ist der Heap-Speicher nach weiteren Zuweisungen möglicherweise nicht kontinuierlich, diese Struktur speichert auch diese Informationen.
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/arena.c#L837

typedef struct _heap_info
{
mstate ar_ptr; /* Arena for this heap. */
struct _heap_info *prev; /* Previous heap. */
size_t size;   /* Current size in bytes. */
size_t mprotect_size; /* Size in bytes that has been mprotected
PROT_READ|PROT_WRITE.  */
size_t pagesize; /* Page size used when allocating the arena.  */
/* Make sure the following data is properly aligned, particularly
that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of
MALLOC_ALIGNMENT. */
char pad[-3 * SIZE_SZ & MALLOC_ALIGN_MASK];
} heap_info;
```
### malloc_state

**Jeder Heap** (Hauptarena oder andere Thread-Arenen) hat eine **`malloc_state` Struktur.**\
Es ist wichtig zu beachten, dass die **`malloc_state` Struktur der Hauptarena** eine **globale Variable in der libc** ist (daher im libc-Speicherbereich lokalisiert).\
Im Fall von **`malloc_state`** Strukturen der Heaps von Threads befinden sie sich **innerhalb des eigenen Thread-"Heaps"**.

Es gibt einige interessante Dinge, die man aus dieser Struktur beachten sollte (siehe C-Code unten):

- `__libc_lock_define (, mutex);` ist da, um sicherzustellen, dass diese Struktur vom Heap von 1 Thread zur Zeit zugegriffen wird.
- Flags:

- ```c
#define NONCONTIGUOUS_BIT     (2U)

#define contiguous(M)          (((M)->flags & NONCONTIGUOUS_BIT) == 0)
#define noncontiguous(M)       (((M)->flags & NONCONTIGUOUS_BIT) != 0)
#define set_noncontiguous(M)   ((M)->flags |= NONCONTIGUOUS_BIT)
#define set_contiguous(M)      ((M)->flags &= ~NONCONTIGUOUS_BIT)
```

- Der `mchunkptr bins[NBINS * 2 - 2];` enthält **Zeiger** auf die **ersten und letzten Chunks** der kleinen, großen und unsortierten **Bins** (die -2 ist, weil der Index 0 nicht verwendet wird).
- Daher wird der **erste Chunk** dieser Bins einen **rückwärts gerichteten Zeiger auf diese Struktur** haben und der **letzte Chunk** dieser Bins wird einen **vorwärts gerichteten Zeiger** auf diese Struktur haben. Das bedeutet im Grunde, dass wenn du diese Adressen in der Hauptarena **leaken** kannst, du einen Zeiger auf die Struktur in der **libc** haben wirst.
- Die Strukturen `struct malloc_state *next;` und `struct malloc_state *next_free;` sind verkettete Listen von Arenen.
- Der `top` Chunk ist der letzte "Chunk", der im Grunde **den gesamten verbleibenden Speicher des Heaps** darstellt. Sobald der Top-Chuck "leer" ist, ist der Heap vollständig genutzt und es muss mehr Speicher angefordert werden.
- Der `last reminder` Chunk stammt aus Fällen, in denen ein Chunk mit genau der Größe nicht verfügbar ist und daher ein größerer Chunk geteilt wird, ein Zeiger auf den verbleibenden Teil wird hier platziert.
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1812

struct malloc_state
{
/* Serialize access.  */
__libc_lock_define (, mutex);

/* Flags (formerly in max_fast).  */
int flags;

/* Set if the fastbin chunks contain recently inserted free blocks.  */
/* Note this is a bool but not all targets support atomics on booleans.  */
int have_fastchunks;

/* Fastbins */
mfastbinptr fastbinsY[NFASTBINS];

/* Base of the topmost chunk -- not otherwise kept in a bin */
mchunkptr top;

/* The remainder from the most recent split of a small request */
mchunkptr last_remainder;

/* Normal bins packed as described above */
mchunkptr bins[NBINS * 2 - 2];

/* Bitmap of bins */
unsigned int binmap[BINMAPSIZE];

/* Linked list */
struct malloc_state *next;

/* Linked list for free arenas.  Access to this field is serialized
by free_list_lock in arena.c.  */
struct malloc_state *next_free;

/* Number of threads attached to this arena.  0 if the arena is on
the free list.  Access to this field is serialized by
free_list_lock in arena.c.  */
INTERNAL_SIZE_T attached_threads;

/* Memory allocated from the system in this arena.  */
INTERNAL_SIZE_T system_mem;
INTERNAL_SIZE_T max_system_mem;
};
```
### malloc_chunk

Diese Struktur repräsentiert ein bestimmtes Speicherstück. Die verschiedenen Felder haben unterschiedliche Bedeutungen für zugewiesene und nicht zugewiesene Stücke.
```c
// https://github.com/bminor/glibc/blob/master/malloc/malloc.c
struct malloc_chunk {
INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk, if it is free. */
INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
struct malloc_chunk* fd;                /* double links -- used only if this chunk is free. */
struct malloc_chunk* bk;
/* Only used for large blocks: pointer to next larger size.  */
struct malloc_chunk* fd_nextsize; /* double links -- used only if this chunk is free. */
struct malloc_chunk* bk_nextsize;
};

typedef struct malloc_chunk* mchunkptr;
```
Wie zuvor kommentiert, haben diese Chunks auch einige Metadaten, die in diesem Bild sehr gut dargestellt sind:

<figure><img src="../../images/image (1242).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

Die Metadaten sind normalerweise 0x08B, was die aktuelle Chunk-Größe angibt, wobei die letzten 3 Bits Folgendes anzeigen:

- `A`: Wenn 1, stammt es aus einem Subheap, wenn 0, befindet es sich in der Hauptarena
- `M`: Wenn 1, ist dieser Chunk Teil eines mit mmap zugewiesenen Bereichs und nicht Teil eines Heaps
- `P`: Wenn 1, ist der vorherige Chunk in Benutzung

Dann der Platz für die Benutzerdaten und schließlich 0x08B, um die Größe des vorherigen Chunks anzugeben, wenn der Chunk verfügbar ist (oder um Benutzerdaten zu speichern, wenn er zugewiesen ist).

Darüber hinaus wird, wenn verfügbar, der Benutzerdatenbereich auch verwendet, um einige Daten zu enthalten:

- **`fd`**: Zeiger auf den nächsten Chunk
- **`bk`**: Zeiger auf den vorherigen Chunk
- **`fd_nextsize`**: Zeiger auf den ersten Chunk in der Liste, der kleiner ist als er selbst
- **`bk_nextsize`:** Zeiger auf den ersten Chunk in der Liste, der größer ist als er selbst

<figure><img src="../../images/image (1243).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

> [!NOTE]
> Beachten Sie, wie das Verknüpfen der Liste auf diese Weise die Notwendigkeit eines Arrays verhindert, in dem jeder einzelne Chunk registriert wird.

### Chunk-Zeiger

Wenn malloc verwendet wird, wird ein Zeiger auf den Inhalt, der geschrieben werden kann, zurückgegeben (direkt nach den Headern), jedoch ist beim Verwalten von Chunks ein Zeiger auf den Anfang der Header (Metadaten) erforderlich.\
Für diese Umwandlungen werden diese Funktionen verwendet:
```c
// https://github.com/bminor/glibc/blob/master/malloc/malloc.c

/* Convert a chunk address to a user mem pointer without correcting the tag.  */
#define chunk2mem(p) ((void*)((char*)(p) + CHUNK_HDR_SZ))

/* Convert a user mem pointer to a chunk address and extract the right tag.  */
#define mem2chunk(mem) ((mchunkptr)tag_at (((char*)(mem) - CHUNK_HDR_SZ)))

/* The smallest possible chunk */
#define MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))

/* The smallest size we can malloc is an aligned minimal chunk */

#define MINSIZE  \
(unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK))
```
### Ausrichtung & minimale Größe

Der Zeiger auf den Chunk und `0x0f` müssen 0 sein.
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/sysdeps/generic/malloc-size.h#L61
#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)

// https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/sysdeps/i386/malloc-alignment.h
#define MALLOC_ALIGNMENT 16


// https://github.com/bminor/glibc/blob/master/malloc/malloc.c
/* Check if m has acceptable alignment */
#define aligned_OK(m)  (((unsigned long)(m) & MALLOC_ALIGN_MASK) == 0)

#define misaligned_chunk(p) \
((uintptr_t)(MALLOC_ALIGNMENT == CHUNK_HDR_SZ ? (p) : chunk2mem (p)) \
& MALLOC_ALIGN_MASK)


/* pad request bytes into a usable size -- internal version */
/* Note: This must be a macro that evaluates to a compile time constant
if passed a literal constant.  */
#define request2size(req)                                         \
(((req) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE)  ?             \
MINSIZE :                                                      \
((req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK)

/* Check if REQ overflows when padded and aligned and if the resulting
value is less than PTRDIFF_T.  Returns the requested size or
MINSIZE in case the value is less than MINSIZE, or 0 if any of the
previous checks fail.  */
static inline size_t
checked_request2size (size_t req) __nonnull (1)
{
if (__glibc_unlikely (req > PTRDIFF_MAX))
return 0;

/* When using tagged memory, we cannot share the end of the user
block with the header for the next chunk, so ensure that we
allocate blocks that are rounded up to the granule size.  Take
care not to overflow from close to MAX_SIZE_T to a small
number.  Ideally, this would be part of request2size(), but that
must be a macro that produces a compile time constant if passed
a constant literal.  */
if (__glibc_unlikely (mtag_enabled))
{
/* Ensure this is not evaluated if !mtag_enabled, see gcc PR 99551.  */
asm ("");

req = (req + (__MTAG_GRANULE_SIZE - 1)) &
~(size_t)(__MTAG_GRANULE_SIZE - 1);
}

return request2size (req);
}
```
Beachten Sie, dass für die Berechnung des insgesamt benötigten Speicherplatzes `SIZE_SZ` nur einmal hinzugefügt wird, da das Feld `prev_size` verwendet werden kann, um Daten zu speichern. Daher ist nur der ursprüngliche Header erforderlich.

### Chunk-Daten abrufen und Metadaten ändern

Diese Funktionen arbeiten, indem sie einen Zeiger auf einen Chunk erhalten und sind nützlich, um Metadaten zu überprüfen/zu setzen:

- Überprüfen Sie die Chunk-Flags
```c
// From https://github.com/bminor/glibc/blob/master/malloc/malloc.c


/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */
#define PREV_INUSE 0x1

/* extract inuse bit of previous chunk */
#define prev_inuse(p)       ((p)->mchunk_size & PREV_INUSE)


/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */
#define IS_MMAPPED 0x2

/* check for mmap()'ed chunk */
#define chunk_is_mmapped(p) ((p)->mchunk_size & IS_MMAPPED)


/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained
from a non-main arena.  This is only set immediately before handing
the chunk to the user, if necessary.  */
#define NON_MAIN_ARENA 0x4

/* Check for chunk from main arena.  */
#define chunk_main_arena(p) (((p)->mchunk_size & NON_MAIN_ARENA) == 0)

/* Mark a chunk as not being on the main arena.  */
#define set_non_main_arena(p) ((p)->mchunk_size |= NON_MAIN_ARENA)
```
- Größen und Zeiger auf andere Chunks
```c
/*
Bits to mask off when extracting size

Note: IS_MMAPPED is intentionally not masked off from size field in
macros for which mmapped chunks should never be seen. This should
cause helpful core dumps to occur if it is tried by accident by
people extending or adapting this malloc.
*/
#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)

/* Get size, ignoring use bits */
#define chunksize(p) (chunksize_nomask (p) & ~(SIZE_BITS))

/* Like chunksize, but do not mask SIZE_BITS.  */
#define chunksize_nomask(p)         ((p)->mchunk_size)

/* Ptr to next physical malloc_chunk. */
#define next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))

/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */
#define prev_size(p) ((p)->mchunk_prev_size)

/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */
#define set_prev_size(p, sz) ((p)->mchunk_prev_size = (sz))

/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */
#define prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))

/* Treat space at ptr + offset as a chunk */
#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))
```
- Insue-Bit
```c
/* extract p's inuse bit */
#define inuse(p)							      \
((((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size) & PREV_INUSE)

/* set/clear chunk as being inuse without otherwise disturbing */
#define set_inuse(p)							      \
((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size |= PREV_INUSE

#define clear_inuse(p)							      \
((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size &= ~(PREV_INUSE)


/* check/set/clear inuse bits in known places */
#define inuse_bit_at_offset(p, s)					      \
(((mchunkptr) (((char *) (p)) + (s)))->mchunk_size & PREV_INUSE)

#define set_inuse_bit_at_offset(p, s)					      \
(((mchunkptr) (((char *) (p)) + (s)))->mchunk_size |= PREV_INUSE)

#define clear_inuse_bit_at_offset(p, s)					      \
(((mchunkptr) (((char *) (p)) + (s)))->mchunk_size &= ~(PREV_INUSE))
```
- Kopf- und Fußzeile festlegen (wenn Chunk-Nummern verwendet werden)
```c
/* Set size at head, without disturbing its use bit */
#define set_head_size(p, s)  ((p)->mchunk_size = (((p)->mchunk_size & SIZE_BITS) | (s)))

/* Set size/use field */
#define set_head(p, s)       ((p)->mchunk_size = (s))

/* Set size at footer (only when chunk is not in use) */
#define set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))->mchunk_prev_size = (s))
```
- Bestimmen Sie die Größe der tatsächlich verwendbaren Daten im Chunk
```c
#pragma GCC poison mchunk_size
#pragma GCC poison mchunk_prev_size

/* This is the size of the real usable data in the chunk.  Not valid for
dumped heap chunks.  */
#define memsize(p)                                                    \
(__MTAG_GRANULE_SIZE > SIZE_SZ && __glibc_unlikely (mtag_enabled) ? \
chunksize (p) - CHUNK_HDR_SZ :                                    \
chunksize (p) - CHUNK_HDR_SZ + (chunk_is_mmapped (p) ? 0 : SIZE_SZ))

/* If memory tagging is enabled the layout changes to accommodate the granule
size, this is wasteful for small allocations so not done by default.
Both the chunk header and user data has to be granule aligned.  */
_Static_assert (__MTAG_GRANULE_SIZE <= CHUNK_HDR_SZ,
"memory tagging is not supported with large granule.");

static __always_inline void *
tag_new_usable (void *ptr)
{
if (__glibc_unlikely (mtag_enabled) && ptr)
{
mchunkptr cp = mem2chunk(ptr);
ptr = __libc_mtag_tag_region (__libc_mtag_new_tag (ptr), memsize (cp));
}
return ptr;
}
```
## Beispiele

### Schnelles Heap-Beispiel

Schnelles Heap-Beispiel von [https://guyinatuxedo.github.io/25-heap/index.html](https://guyinatuxedo.github.io/25-heap/index.html), aber in arm64:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void main(void)
{
char *ptr;
ptr = malloc(0x10);
strcpy(ptr, "panda");
}
```
Setze einen Breakpoint am Ende der Hauptfunktion und lass uns herausfinden, wo die Informationen gespeichert wurden:

<figure><img src="../../images/image (1239).png" alt=""><figcaption></figcaption></figure>

Es ist möglich zu sehen, dass der String panda bei `0xaaaaaaac12a0` gespeichert wurde (was die Adresse war, die als Antwort von malloc innerhalb von `x0` gegeben wurde). Wenn man 0x10 Bytes davor überprüft, kann man sehen, dass das `0x0` darstellt, dass der **vorherige Chunk nicht verwendet wird** (Länge 0) und dass die Länge dieses Chunks `0x21` beträgt.

Die reservierten zusätzlichen Bytes (0x21-0x10=0x11) stammen von den **hinzugefügten Headern** (0x10) und 0x1 bedeutet nicht, dass es 0x21B reserviert wurde, sondern die letzten 3 Bits der Länge des aktuellen Headers haben einige spezielle Bedeutungen. Da die Länge immer 16-Byte ausgerichtet ist (in 64-Bit-Maschinen), werden diese Bits tatsächlich niemals von der Längenangabe verwendet.
```
0x1:     Previous in Use     - Specifies that the chunk before it in memory is in use
0x2:     Is MMAPPED          - Specifies that the chunk was obtained with mmap()
0x4:     Non Main Arena      - Specifies that the chunk was obtained from outside of the main arena
```
### Multithreading Beispiel

<details>

<summary>Multithread</summary>
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/types.h>


void* threadFuncMalloc(void* arg) {
printf("Hello from thread 1\n");
char* addr = (char*) malloc(1000);
printf("After malloc and before free in thread 1\n");
free(addr);
printf("After free in thread 1\n");
}

void* threadFuncNoMalloc(void* arg) {
printf("Hello from thread 2\n");
}


int main() {
pthread_t t1;
void* s;
int ret;
char* addr;

printf("Before creating thread 1\n");
getchar();
ret = pthread_create(&t1, NULL, threadFuncMalloc, NULL);
getchar();

printf("Before creating thread 2\n");
ret = pthread_create(&t1, NULL, threadFuncNoMalloc, NULL);

printf("Before exit\n");
getchar();

return 0;
}
```
</details>

Beim Debuggen des vorherigen Beispiels ist es möglich zu sehen, dass zu Beginn nur 1 Arena vorhanden ist:

<figure><img src="../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Dann, nach dem Aufruf des ersten Threads, der malloc aufruft, wird eine neue Arena erstellt:

<figure><img src="../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

und darin können einige Chunks gefunden werden:

<figure><img src="../../images/image (2) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Bins & Speicherzuweisungen/Freigaben

Überprüfen Sie, was die Bins sind und wie sie organisiert sind und wie Speicher zugewiesen und freigegeben wird in:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

## Sicherheitsprüfungen von Heap-Funktionen

Funktionen, die im Heap beteiligt sind, führen bestimmte Prüfungen durch, bevor sie ihre Aktionen ausführen, um sicherzustellen, dass der Heap nicht beschädigt wurde:

{{#ref}}
heap-memory-functions/heap-functions-security-checks.md
{{#endref}}

## Referenzen

- [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
- [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
