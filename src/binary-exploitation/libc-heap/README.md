# Libc Heap

{{#include ../../banners/hacktricks-training.md}}

## Heap Basiese beginsels

Die heap is basies die plek waar 'n program data kan stoor wanneer dit data versoek deur funksies soos **`malloc`**, `calloc`... aan te roep. Verder, wanneer hierdie geheue nie meer benodig word nie, word dit vrygemaak deur die funksie **`free`** aan te roep.

Soos getoon, dit is reg ná waar die binary in geheue gelaai word (kyk die `[heap]` afdeling):

<figure><img src="../../images/image (1241).png" alt=""><figcaption></figcaption></figure>

### Basiese Chunk-toekenning

Wanneer data versoek word om in die heap gestoor te word, word 'n gedeelte van die heap daaraan toegeken. Hierdie ruimte sal aan 'n bin behoort en slegs die versoekte data + die ruimte vir die bin-headers + die minimum bin-grootte offset sal vir die chunk gereserveer word. Die doel is om soveel moontlike minimum geheue te bespreek sonder om dit moeilik te maak om te vind waar elke chunk is. Hiervoor word die metadata van die chunk gebruik om te weet waar elke gebruikte/vrye chunk is.

Daar is verskillende maniere om die ruimte te reserveer, afhangend van die gebruikte bin, maar 'n algemene metodologie is die volgende:

- Die program begin deur 'n sekere hoeveelheid geheue aan te vra.
- As daar in die lys van chunks 'n beskikbare een is wat groot genoeg is om die versoek te vervul, sal dit gebruik word.
- Dit kan selfs beteken dat 'n deel van die beskikbare chunk vir hierdie versoek gebruik sal word en die res by die chunk-lys gevoeg word.
- As daar geen beskikbare chunk in die lys is nie maar daar nog spasie in die toegekenne heap-geheue is, skep die heap-bestuurder 'n nuwe chunk.
- As daar nie genoeg heap-spasie is om die nuwe chunk toe te ken nie, vra die heap-bestuurder die kernel om die heap-geheue uit te brei en gebruik dan daardie geheue om die nuwe chunk te genereer.
- As alles misluk, keer `malloc` null terug.

Let daarop dat as die versoekte **memory** 'n drempel oorskry, **`mmap`** gebruik sal word om die versoekte memory te map.

## Arenas

In **multithreaded** toepassings moet die heap-bestuurder **race conditions** verhoed wat tot crashe kan lei. Aanvanklik is dit gedoen deur 'n **global mutex** te gebruik om te verseker dat slegs een thread op 'n slag toegang tot die heap het, maar dit het prestasieprobleme veroorsaak as gevolg van die mutex-verwante knelpunt.

Om dit aan te spreek het die ptmalloc2 heap allocator "arenas" ingevoer, waar elke arena optree as 'n aparte heap met sy eie data strukture en mutex, wat toelaat dat meerdere threads heap-operasies uitvoer sonder om mekaar te steur, solank hulle verskillende arenas gebruik.

Die standaard "main" arena hanteer heap-operasies vir single-threaded toepassings. Wanneer **new threads** bygevoeg word, ken die heap-bestuurder vir hulle **secondary arenas** toe om kompetisie te verminder. Dit probeer eers om elke nuwe thread aan 'n ongebruikte arena te koppel, en skep nuwe arenas indien nodig, tot 'n limiet van 2 keer die aantal CPU-kerne vir 32-bit stelsels en 8 keer vir 64-bit stelsels. Sodra die limiet bereik is, moet **threads arenas deel**, wat tot potensiële kompetisie kan lei.

Anders as die main arena, wat uitbrei deur die `brk` system call te gebruik, skep secondary arenas "subheaps" deur `mmap` en `mprotect` te gebruik om die heap-gedrag te simuleer, wat buigbaarheid in die bestuur van geheue vir multithreaded operasies toelaat.

### Subheaps

Subheaps dien as geheue-reserwes vir secondary arenas in multithreaded toepassings, wat hulle toelaat om te groei en hul eie heap-streke afsonderlik van die hoofheap te bestuur. Hier is hoe subheaps verskil van die initële heap en hoe hulle werk:

1. Initial Heap vs. Subheaps:
- Die initële heap is direk na die program se binary in geheue geleë, en dit brei uit deur die `sbrk` system call.
- Subheaps, gebruik deur secondary arenas, word geskep deur middel van `mmap`, 'n system call wat 'n gespesifiseerde geheue-reeks map.

2. Memory Reservation with `mmap`:
- Wanneer die heap-bestuurder 'n subheap skep, reserveer dit 'n groot blokkie geheue deur `mmap`. Hierdie reservasie ken nie onmiddellik fisiese geheue toe nie; dit dui net 'n streek aan wat ander stelselprosesse of toewysings nie moet gebruik nie.
- By verstek is die gereserveerde grootte vir 'n subheap 1 MB vir 32-bit prosesse en 64 MB vir 64-bit prosesse.

3. Gradual Expansion with `mprotect`:
- Die gereserveerde geheue-streek is aanvanklik gemerk as `PROT_NONE`, wat aandui dat die kernel nog nie fisiese geheue aan hierdie ruimte hoef toe te ken nie.
- Om die subheap te "groei", gebruik die heap-bestuurder `mprotect` om bladsytoestemmings van `PROT_NONE` na `PROT_READ | PROT_WRITE` te verander, wat die kernel daartoe aanmoedig om fisiese geheue aan die voorheen gereserveerde adresse toe te ken. Hierdie stapsgewyse benadering laat die subheap toe om na gelang van behoefte uit te brei.
- Sodra die hele subheap opgebruik is, skep die heap-bestuurder 'n nuwe subheap om voort te gaan met toewysing.

### heap_info <a href="#heap_info" id="heap_info"></a>

Hierdie struct bewaar relevante inligting oor die heap. Verder kan heap-geheue na meer toewysings nie voortdurend wees nie; hierdie struct sal daardie inligting ook stoor.
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/arena.c#L837

typedef struct _heap_info
{
mstate ar_ptr; /* Arena for this heap. */
struct _heap_info *prev; /* Previous heap. */
size_t size;   /* Current size in bytes. */
size_t mprotect_size; /* Size in bytes that has been mprotected
PROT_READ|PROT_WRITE.  */
size_t pagesize; /* Page size used when allocating the arena.  */
/* Make sure the following data is properly aligned, particularly
that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of
MALLOC_ALIGNMENT. */
char pad[-3 * SIZE_SZ & MALLOC_ALIGN_MASK];
} heap_info;
```
### malloc_state

**Elke heap** (main arena or other threads arenas) het 'n **`malloc_state` struktuur.**\
Dit is belangrik om op te let dat die **main arena `malloc_state`** struktuur 'n **globale veranderlike in die libc** is (dus geleë in die libc geheue-ruimte).\
In die geval van **`malloc_state`** strukture van die heaps van threads, is hulle geleë **binne die eie thread "heap"**.

Daar is 'n paar interessante dinge om op te let in hierdie struktuur (sien C-kode hieronder):

- `__libc_lock_define (, mutex);` Is daar om te verseker dat hierdie struktuur van die heap deur net 1 thread op 'n slag benader word
- Vlae:

- ```c
#define NONCONTIGUOUS_BIT     (2U)

#define contiguous(M)          (((M)->flags & NONCONTIGUOUS_BIT) == 0)
#define noncontiguous(M)       (((M)->flags & NONCONTIGUOUS_BIT) != 0)
#define set_noncontiguous(M)   ((M)->flags |= NONCONTIGUOUS_BIT)
#define set_contiguous(M)      ((M)->flags &= ~NONCONTIGUOUS_BIT)
```

- The `mchunkptr bins[NBINS * 2 - 2];` contains **pointers** to the **first and last chunks** of the small, large and unsorted **bins** (the -2 is because the index 0 is not used)
- Daarom sal die **first chunk** van hierdie bins 'n **backwards pointer to this structure** hê en die **last chunk** van hierdie bins sal 'n **forward pointer** to this structure hê. Dit beteken basies dat as jy hierdie adresse in die main arena kan leak, sal jy 'n pointer na die struktuur in die **libc** hê.
- Die structs `struct malloc_state *next;` en `struct malloc_state *next_free;` is gekoppelde lyste van arenas
- Die `top` chunk is die laaste "chunk", wat basies **al die oorblywende heap-ruimte** beslaan. Sodra die `top` chunk "empty" is, is die heap volledig gebruik en moet dit meer ruimte versoek.
- Die `last reminder` chunk kom voor in gevalle waar 'n presiese grootte chunk nie beskikbaar is nie en dus 'n groter chunk gesplit word, 'n oorblywende deel (pointer) hier geplaas word.
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1812

struct malloc_state
{
/* Serialize access.  */
__libc_lock_define (, mutex);

/* Flags (formerly in max_fast).  */
int flags;

/* Set if the fastbin chunks contain recently inserted free blocks.  */
/* Note this is a bool but not all targets support atomics on booleans.  */
int have_fastchunks;

/* Fastbins */
mfastbinptr fastbinsY[NFASTBINS];

/* Base of the topmost chunk -- not otherwise kept in a bin */
mchunkptr top;

/* The remainder from the most recent split of a small request */
mchunkptr last_remainder;

/* Normal bins packed as described above */
mchunkptr bins[NBINS * 2 - 2];

/* Bitmap of bins */
unsigned int binmap[BINMAPSIZE];

/* Linked list */
struct malloc_state *next;

/* Linked list for free arenas.  Access to this field is serialized
by free_list_lock in arena.c.  */
struct malloc_state *next_free;

/* Number of threads attached to this arena.  0 if the arena is on
the free list.  Access to this field is serialized by
free_list_lock in arena.c.  */
INTERNAL_SIZE_T attached_threads;

/* Memory allocated from the system in this arena.  */
INTERNAL_SIZE_T system_mem;
INTERNAL_SIZE_T max_system_mem;
};
```
### malloc_chunk

Hierdie struktuur verteenwoordig 'n bepaalde chunk van memory. Die verskeie velde het verskillende betekenisse vir allocated en unallocated chunks.
```c
// https://github.com/bminor/glibc/blob/master/malloc/malloc.c
struct malloc_chunk {
INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk, if it is free. */
INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
struct malloc_chunk* fd;                /* double links -- used only if this chunk is free. */
struct malloc_chunk* bk;
/* Only used for large blocks: pointer to next larger size.  */
struct malloc_chunk* fd_nextsize; /* double links -- used only if this chunk is free. */
struct malloc_chunk* bk_nextsize;
};

typedef struct malloc_chunk* mchunkptr;
```
Soos voorheen opgemerk, het hierdie chunks ook sekere metadata, baie goed voorgestel in hierdie beeld:

<figure><img src="../../images/image (1242).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

Die metadata is gewoonlik 0x08B en dui die huidige chunk-grootte aan deur die laaste 3 bisse te gebruik om aan te dui:

- `A`: As 1, dit kom van 'n subheap; as 0 is dit in die main arena
- `M`: As 1, hierdie chunk is deel van 'n ruimte wat met mmap toegeken is en nie deel van 'n heap nie
- `P`: As 1, die vorige chunk is in gebruik

Dan die ruimte vir die user data, en uiteindelik 0x08B om die vorige chunk-grootte aan te dui wanneer die chunk beskikbaar is (of om user data te stoor wanneer dit toegeken is).

Verder, wanneer beskikbaar, word die user data ook gebruik om sekere velde te bevat:

- **`fd`**: Aanwyser na die volgende chunk
- **`bk`**: Aanwyser na die vorige chunk
- **`fd_nextsize`**: Aanwyser na die eerste chunk in die lys wat kleiner as die huidige chunk is
- **`bk_nextsize`:** Aanwyser na die eerste chunk in die lys wat groter as die huidige chunk is

<figure><img src="../../images/image (1243).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

> [!TIP]
> Let daarop hoe die skakeling van die lys op hierdie manier die behoefte aan 'n array waarin elke enkele chunk geregistreer word, voorkom.

### Chunk-aanwysers

Wanneer malloc gebruik word, word 'n pointer na die inhoud wat geskryf kan word teruggegee (net na die headers); wanneer mens egter chunks bestuur, is 'n pointer na die begin van die headers (metadata) nodig.\
Vir hierdie omskakelings word die volgende funksies gebruik:
```c
// https://github.com/bminor/glibc/blob/master/malloc/malloc.c

/* Convert a chunk address to a user mem pointer without correcting the tag.  */
#define chunk2mem(p) ((void*)((char*)(p) + CHUNK_HDR_SZ))

/* Convert a user mem pointer to a chunk address and extract the right tag.  */
#define mem2chunk(mem) ((mchunkptr)tag_at (((char*)(mem) - CHUNK_HDR_SZ)))

/* The smallest possible chunk */
#define MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))

/* The smallest size we can malloc is an aligned minimal chunk */

#define MINSIZE  \
(unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK))
```
### Uitlijning & minimum grootte

Die pointer na die chunk en `0x0f` moet 0 wees.
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/sysdeps/generic/malloc-size.h#L61
#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)

// https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/sysdeps/i386/malloc-alignment.h
#define MALLOC_ALIGNMENT 16


// https://github.com/bminor/glibc/blob/master/malloc/malloc.c
/* Check if m has acceptable alignment */
#define aligned_OK(m)  (((unsigned long)(m) & MALLOC_ALIGN_MASK) == 0)

#define misaligned_chunk(p) \
((uintptr_t)(MALLOC_ALIGNMENT == CHUNK_HDR_SZ ? (p) : chunk2mem (p)) \
& MALLOC_ALIGN_MASK)


/* pad request bytes into a usable size -- internal version */
/* Note: This must be a macro that evaluates to a compile time constant
if passed a literal constant.  */
#define request2size(req)                                         \
(((req) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE)  ?             \
MINSIZE :                                                      \
((req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK)

/* Check if REQ overflows when padded and aligned and if the resulting
value is less than PTRDIFF_T.  Returns the requested size or
MINSIZE in case the value is less than MINSIZE, or 0 if any of the
previous checks fail.  */
static inline size_t
checked_request2size (size_t req) __nonnull (1)
{
if (__glibc_unlikely (req > PTRDIFF_MAX))
return 0;

/* When using tagged memory, we cannot share the end of the user
block with the header for the next chunk, so ensure that we
allocate blocks that are rounded up to the granule size.  Take
care not to overflow from close to MAX_SIZE_T to a small
number.  Ideally, this would be part of request2size(), but that
must be a macro that produces a compile time constant if passed
a constant literal.  */
if (__glibc_unlikely (mtag_enabled))
{
/* Ensure this is not evaluated if !mtag_enabled, see gcc PR 99551.  */
asm ("");

req = (req + (__MTAG_GRANULE_SIZE - 1)) &
~(size_t)(__MTAG_GRANULE_SIZE - 1);
}

return request2size (req);
}
```
Let daarop dat by die berekening van die totale ruimte slegs `SIZE_SZ` 1 keer bygevoeg word omdat die `prev_size` veld gebruik kan word om data te stoor, daarom is slegs die aanvanklike header nodig.

### Haal Chunk-data en verander metadata

Hierdie funksies werk deur 'n pointer na 'n chunk te ontvang en is nuttig om metadata te kontroleer/instel:

- Kontroleer chunk-vlagte
```c
// From https://github.com/bminor/glibc/blob/master/malloc/malloc.c


/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */
#define PREV_INUSE 0x1

/* extract inuse bit of previous chunk */
#define prev_inuse(p)       ((p)->mchunk_size & PREV_INUSE)


/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */
#define IS_MMAPPED 0x2

/* check for mmap()'ed chunk */
#define chunk_is_mmapped(p) ((p)->mchunk_size & IS_MMAPPED)


/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained
from a non-main arena.  This is only set immediately before handing
the chunk to the user, if necessary.  */
#define NON_MAIN_ARENA 0x4

/* Check for chunk from main arena.  */
#define chunk_main_arena(p) (((p)->mchunk_size & NON_MAIN_ARENA) == 0)

/* Mark a chunk as not being on the main arena.  */
#define set_non_main_arena(p) ((p)->mchunk_size |= NON_MAIN_ARENA)
```
- Groottes en aanwysers na ander blokke
```c
/*
Bits to mask off when extracting size

Note: IS_MMAPPED is intentionally not masked off from size field in
macros for which mmapped chunks should never be seen. This should
cause helpful core dumps to occur if it is tried by accident by
people extending or adapting this malloc.
*/
#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)

/* Get size, ignoring use bits */
#define chunksize(p) (chunksize_nomask (p) & ~(SIZE_BITS))

/* Like chunksize, but do not mask SIZE_BITS.  */
#define chunksize_nomask(p)         ((p)->mchunk_size)

/* Ptr to next physical malloc_chunk. */
#define next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))

/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */
#define prev_size(p) ((p)->mchunk_prev_size)

/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */
#define set_prev_size(p, sz) ((p)->mchunk_prev_size = (sz))

/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */
#define prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))

/* Treat space at ptr + offset as a chunk */
#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))
```
- Probleem-bit
```c
/* extract p's inuse bit */
#define inuse(p)							      \
((((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size) & PREV_INUSE)

/* set/clear chunk as being inuse without otherwise disturbing */
#define set_inuse(p)							      \
((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size |= PREV_INUSE

#define clear_inuse(p)							      \
((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size &= ~(PREV_INUSE)


/* check/set/clear inuse bits in known places */
#define inuse_bit_at_offset(p, s)					      \
(((mchunkptr) (((char *) (p)) + (s)))->mchunk_size & PREV_INUSE)

#define set_inuse_bit_at_offset(p, s)					      \
(((mchunkptr) (((char *) (p)) + (s)))->mchunk_size |= PREV_INUSE)

#define clear_inuse_bit_at_offset(p, s)					      \
(((mchunkptr) (((char *) (p)) + (s)))->mchunk_size &= ~(PREV_INUSE))
```
- Stel head en footer (wanneer chunk nos in gebruik is
```c
/* Set size at head, without disturbing its use bit */
#define set_head_size(p, s)  ((p)->mchunk_size = (((p)->mchunk_size & SIZE_BITS) | (s)))

/* Set size/use field */
#define set_head(p, s)       ((p)->mchunk_size = (s))

/* Set size at footer (only when chunk is not in use) */
#define set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))->mchunk_prev_size = (s))
```
- Kry die grootte van die werklike bruikbare data binne die chunk
```c
#pragma GCC poison mchunk_size
#pragma GCC poison mchunk_prev_size

/* This is the size of the real usable data in the chunk.  Not valid for
dumped heap chunks.  */
#define memsize(p)                                                    \
(__MTAG_GRANULE_SIZE > SIZE_SZ && __glibc_unlikely (mtag_enabled) ? \
chunksize (p) - CHUNK_HDR_SZ :                                    \
chunksize (p) - CHUNK_HDR_SZ + (chunk_is_mmapped (p) ? 0 : SIZE_SZ))

/* If memory tagging is enabled the layout changes to accommodate the granule
size, this is wasteful for small allocations so not done by default.
Both the chunk header and user data has to be granule aligned.  */
_Static_assert (__MTAG_GRANULE_SIZE <= CHUNK_HDR_SZ,
"memory tagging is not supported with large granule.");

static __always_inline void *
tag_new_usable (void *ptr)
{
if (__glibc_unlikely (mtag_enabled) && ptr)
{
mchunkptr cp = mem2chunk(ptr);
ptr = __libc_mtag_tag_region (__libc_mtag_new_tag (ptr), memsize (cp));
}
return ptr;
}
```
## Voorbeelde

### Vinnige Heap Voorbeeld

Vinnige heap voorbeeld van [https://guyinatuxedo.github.io/25-heap/index.html](https://guyinatuxedo.github.io/25-heap/index.html) maar in arm64:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void main(void)
{
char *ptr;
ptr = malloc(0x10);
strcpy(ptr, "panda");
}
```
Stel 'n breakpoint aan die einde van die main-funksie en kom ons vind uit waar die inligting gestoor is:

<figure><img src="../../images/image (1239).png" alt=""><figcaption></figcaption></figure>

Dit is moontlik om te sien dat die string panda gestoor is by `0xaaaaaaac12a0` (wat die adres was wat deur malloc in `x0` as antwoord gegee is). As jy 0x10 bytes verder terug kyk, is dit duidelik dat `0x0` aandui dat die **vorige chunk nie gebruik is nie** (lengte 0) en dat die lengte van hierdie chunk `0x21` is.

Die ekstra ruimte wat gereserveer is (0x21-0x10=0x11) kom van die **bygevoegde headers** (0x10) en 0x1 beteken nie dat 0x21B gereserveer is nie, maar dat die laaste 3 bisse van die lengte van die huidige header sommige spesiale betekenisse het. Aangesien die lengte altyd op 16-byte uitgelyn is (op 64-bit masjiene), gaan hierdie bisse in werklikheid nooit deur die lengte-getal gebruik word nie.
```
0x1:     Previous in Use     - Specifies that the chunk before it in memory is in use
0x2:     Is MMAPPED          - Specifies that the chunk was obtained with mmap()
0x4:     Non Main Arena      - Specifies that the chunk was obtained from outside of the main arena
```
### Voorbeeld van multithreading

<details>

<summary>Meerdraadig</summary>
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/types.h>


void* threadFuncMalloc(void* arg) {
printf("Hello from thread 1\n");
char* addr = (char*) malloc(1000);
printf("After malloc and before free in thread 1\n");
free(addr);
printf("After free in thread 1\n");
}

void* threadFuncNoMalloc(void* arg) {
printf("Hello from thread 2\n");
}


int main() {
pthread_t t1;
void* s;
int ret;
char* addr;

printf("Before creating thread 1\n");
getchar();
ret = pthread_create(&t1, NULL, threadFuncMalloc, NULL);
getchar();

printf("Before creating thread 2\n");
ret = pthread_create(&t1, NULL, threadFuncNoMalloc, NULL);

printf("Before exit\n");
getchar();

return 0;
}
```
</details>

Deur die vorige voorbeeld te debug, is dit moontlik om te sien hoe daar aan die begin net 1 arena is:

<figure><img src="../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Dan, nadat die eerste thread aangeroep is, die een wat malloc aanroep, word 'n nuwe arena geskep:

<figure><img src="../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

en daarin kan 'n paar chunks gevind word:

<figure><img src="../../images/image (2) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Bins & Geheue-toewysings/-vrymaak

Kyk watter bins daar is en hoe hulle georganiseer is en hoe geheue toegeken en vrygemaak word in:


{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

## Heap-funksies: veiligheidskontroles

Funksies wat by die heap betrokke is, sal sekere kontroles uitvoer voordat hulle aksies uitvoer om te probeer verseker dat die heap nie gekorrupteer is nie:


{{#ref}}
heap-memory-functions/heap-functions-security-checks.md
{{#endref}}

## Gevalstudies

Bestudeer allocator-spesifieke primitives wat afkomstig is van regstreekse bugs:

{{#ref}}
virtualbox-slirp-nat-packet-heap-exploitation.md
{{#endref}}

## Verwysings

- [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
- [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)


{{#include ../../banners/hacktricks-training.md}}
