# Libc 堆

{{#include ../../banners/hacktricks-training.md}}

## 堆 基础

堆基本上是程序在调用诸如 **`malloc`**、`calloc` 等函数请求存储数据时用来保存这些数据的区域。此外，当这段内存不再需要时，会通过调用 **`free`** 将其释放。

如图所示，它位于二进制加载到内存之后（查看 `[heap]` 段）：

<figure><img src="../../images/image (1241).png" alt=""><figcaption></figcaption></figure>

### 基本 chunk 分配

当请求在堆上存储数据时，会为其分配堆中的一段空间。该空间属于某个 bin，并且为该 chunk 只保留请求的数据、bin 头的空间以及最小 bin 大小的偏移。目标是尽量少地保留内存，同时不会使查找每个 chunk 的位置变得复杂。为此，使用 chunk 的元数据来记录每个已用/空闲 chunk 的位置。

根据使用的 bin，保留空间的方式不同，但一般流程如下：

- 程序首先请求一定大小的内存。
- 如果在 chunk 列表中存在足够大的空闲块以满足请求，则使用该空闲块。
- 这可能意味着可用 chunk 的一部分会被用于本次请求，剩余部分会重新加入 chunk 列表。
- 如果列表中没有可用的 chunk 但已分配的堆内存仍有空间，堆管理器会创建一个新的 chunk。
- 如果堆空间不足以分配新的 chunk，堆管理器会请求内核扩展分配给堆的内存，然后使用这些内存来生成新的 chunk。
- 如果所有操作都失败，`malloc` 返回 null。

注意，如果请求的 **memory passes a threshold**，会使用 **`mmap`** 来映射请求的内存。

## Arenas

在 **multithreaded** 应用中，堆管理器必须防止可能导致崩溃的 **race conditions**。最初这是通过一个 **global mutex** 来实现，确保一次只有一个线程可以访问堆，但这会因为 mutex 引起的瓶颈而导致 **performance issues**。

为了解决这个问题，ptmalloc2 引入了 "arenas"，其中 **每个 arena** 作为一个 **独立的 heap**，拥有自己的数据结构和 mutex，允许多个线程在使用不同 arenas 时并行执行堆操作而互不干扰。

默认的 "main" arena 负责单线程应用的堆操作。当 **新线程** 增加时，堆管理器会为它们分配 **secondary arenas** 以减少竞争。它会先尝试将每个新线程附加到未使用的 arena，必要时创建新的 arena，最多达到 32 位系统为 CPU 核心数的 2 倍、64 位系统为 CPU 核心数的 8 倍的限制。达到限制后，**线程必须共享 arenas**，可能导致竞争。

不同于使用 `brk` 系统调用扩展的 main arena，secondary arenas 使用 `mmap` 和 `mprotect` 创建 "subheaps" 来模拟堆行为，从而在多线程操作中更灵活地管理内存。

### Subheaps

Subheaps 作为 multithreaded 应用中 secondary arenas 的内存储备，允许它们单独增长并管理自己的堆区域，以下是 subheaps 与初始堆的区别及其工作方式：

1. Initial Heap vs. Subheaps:
- 初始堆位于程序二进制在内存之后，并使用 `sbrk` 系统调用扩展。
- 用于 secondary arenas 的 subheaps 通过 `mmap` 创建，该系统调用用于映射指定的内存区域。
2. Memory Reservation with `mmap`:
- 当堆管理器创建 subheap 时，会通过 `mmap` 预留一大块内存。此预留并不会立即分配物理内存；它只是标记一个区域，表示其它系统进程或分配不应使用该区域。
- 默认情况下，subheap 的预留大小为 32 位进程的 1 MB 和 64 位进程的 64 MB。
3. Gradual Expansion with `mprotect`:
- 预留的内存区域最初被标记为 `PROT_NONE`，表明内核暂时不需要为该区域分配物理内存。
- 为了“增长” subheap，堆管理器使用 `mprotect` 将页面权限从 `PROT_NONE` 更改为 `PROT_READ | PROT_WRITE`，促使内核为先前预留的地址分配物理内存。这种逐步方式允许 subheap 按需扩展。
- 一旦整个 subheap 被耗尽，堆管理器会创建新的 subheap 以继续分配。

### heap_info <a href="#heap_info" id="heap_info"></a>

该 struct 存储堆的相关信息。此外，在更多分配操作之后，堆内存可能不再连续，该 struct 也会记录这类信息。
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/arena.c#L837

typedef struct _heap_info
{
mstate ar_ptr; /* Arena for this heap. */
struct _heap_info *prev; /* Previous heap. */
size_t size;   /* Current size in bytes. */
size_t mprotect_size; /* Size in bytes that has been mprotected
PROT_READ|PROT_WRITE.  */
size_t pagesize; /* Page size used when allocating the arena.  */
/* Make sure the following data is properly aligned, particularly
that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of
MALLOC_ALIGNMENT. */
char pad[-3 * SIZE_SZ & MALLOC_ALIGN_MASK];
} heap_info;
```
### malloc_state

**每个 heap**（main arena 或其他线程的 arenas）都有一个 **`malloc_state` structure.**\
重要的是要注意 **main arena `malloc_state`** 结构在 **libc** 中是一个 **全局变量**（因此位于 libc 的内存空间）。\
对于线程 heap 的 **`malloc_state`** 结构，它们位于各自线程的 "heap" 内部。

从该结构中有一些有趣的点需要注意（见下方 C 代码）：

- `__libc_lock_define (, mutex);` 用来确保该 heap 中的这个结构一次只被一个线程访问
- 标志：

- ```c
#define NONCONTIGUOUS_BIT     (2U)

#define contiguous(M)          (((M)->flags & NONCONTIGUOUS_BIT) == 0)
#define noncontiguous(M)       (((M)->flags & NONCONTIGUOUS_BIT) != 0)
#define set_noncontiguous(M)   ((M)->flags |= NONCONTIGUOUS_BIT)
#define set_contiguous(M)      ((M)->flags &= ~NONCONTIGUOUS_BIT)
```

- The `mchunkptr bins[NBINS * 2 - 2];` contains **pointers** to the **first and last chunks** of the small, large and unsorted **bins** (the -2 is because the index 0 is not used)
- Therefore, the **first chunk** of these bins will have a **backwards pointer to this structure** and the **last chunk** of these bins will have a **forward pointer** to this structure. Which basically means that if you can l**eak these addresses in the main arena** you will have a pointer to the structure in the **libc**.
- The structs `struct malloc_state *next;` and `struct malloc_state *next_free;` 是 arenas 的链表
- The `top` chunk is the last "chunk", which is basically **all the heap reminding space**. Once the top chunk is "empty", the heap is completely used and it needs to request more space.
- The `last reminder` chunk comes from cases where an exact size chunk is not available and therefore a bigger chunk is splitter, a pointer remaining part is placed here.
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1812

struct malloc_state
{
/* Serialize access.  */
__libc_lock_define (, mutex);

/* Flags (formerly in max_fast).  */
int flags;

/* Set if the fastbin chunks contain recently inserted free blocks.  */
/* Note this is a bool but not all targets support atomics on booleans.  */
int have_fastchunks;

/* Fastbins */
mfastbinptr fastbinsY[NFASTBINS];

/* Base of the topmost chunk -- not otherwise kept in a bin */
mchunkptr top;

/* The remainder from the most recent split of a small request */
mchunkptr last_remainder;

/* Normal bins packed as described above */
mchunkptr bins[NBINS * 2 - 2];

/* Bitmap of bins */
unsigned int binmap[BINMAPSIZE];

/* Linked list */
struct malloc_state *next;

/* Linked list for free arenas.  Access to this field is serialized
by free_list_lock in arena.c.  */
struct malloc_state *next_free;

/* Number of threads attached to this arena.  0 if the arena is on
the free list.  Access to this field is serialized by
free_list_lock in arena.c.  */
INTERNAL_SIZE_T attached_threads;

/* Memory allocated from the system in this arena.  */
INTERNAL_SIZE_T system_mem;
INTERNAL_SIZE_T max_system_mem;
};
```
### malloc_chunk

该结构表示内存中的一个特定 chunk。各个字段在已分配和未分配的 chunk 中具有不同的含义。
```c
// https://github.com/bminor/glibc/blob/master/malloc/malloc.c
struct malloc_chunk {
INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk, if it is free. */
INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
struct malloc_chunk* fd;                /* double links -- used only if this chunk is free. */
struct malloc_chunk* bk;
/* Only used for large blocks: pointer to next larger size.  */
struct malloc_chunk* fd_nextsize; /* double links -- used only if this chunk is free. */
struct malloc_chunk* bk_nextsize;
};

typedef struct malloc_chunk* mchunkptr;
```
如前所述，这些 chunks 也有一些元数据，图中表现得很清楚：

<figure><img src="../../images/image (1242).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

这些元数据通常是 0x08B，用来表示当前 chunk 大小，使用最低 3 位表示：

- `A`: 如果为 1，则来自 subheap；如果为 0，则位于 main arena
- `M`: 如果为 1，表明该 chunk 位于通过 mmap 分配的区域，不属于 heap
- `P`: 如果为 1，表示前一个 chunk 正在被使用

随后是用户数据的空间，最后是 0x08B，用于在 chunk 可用时表示前一个 chunk 的大小（或在已分配时用于存放用户数据）。

此外，当 chunk 可用时，用户数据区域还会包含一些指针：

- **`fd`**: 指向下一个 chunk 的指针
- **`bk`**: 指向上一个 chunk 的指针
- **`fd_nextsize`**: 指向链表中第一个比自身小的 chunk 的指针
- **`bk_nextsize`:** 指向链表中第一个比自身大的 chunk 的指针

<figure><img src="../../images/image (1243).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

> [!TIP]
> 注意这种链表连接方式如何避免需要一个数组来记录每一个 chunk。

### Chunk 指针

当使用 malloc 时，会返回一个指向可写内容的指针（就在 headers 之后）；但是在管理 chunks 时，需要一个指向 headers（metadata）开头的指针。\
用于这些转换的函数如下：
```c
// https://github.com/bminor/glibc/blob/master/malloc/malloc.c

/* Convert a chunk address to a user mem pointer without correcting the tag.  */
#define chunk2mem(p) ((void*)((char*)(p) + CHUNK_HDR_SZ))

/* Convert a user mem pointer to a chunk address and extract the right tag.  */
#define mem2chunk(mem) ((mchunkptr)tag_at (((char*)(mem) - CHUNK_HDR_SZ)))

/* The smallest possible chunk */
#define MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))

/* The smallest size we can malloc is an aligned minimal chunk */

#define MINSIZE  \
(unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK))
```
### 对齐与最小大小

指向 chunk 的 pointer 和 `0x0f` 必须为 0。
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/sysdeps/generic/malloc-size.h#L61
#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)

// https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/sysdeps/i386/malloc-alignment.h
#define MALLOC_ALIGNMENT 16


// https://github.com/bminor/glibc/blob/master/malloc/malloc.c
/* Check if m has acceptable alignment */
#define aligned_OK(m)  (((unsigned long)(m) & MALLOC_ALIGN_MASK) == 0)

#define misaligned_chunk(p) \
((uintptr_t)(MALLOC_ALIGNMENT == CHUNK_HDR_SZ ? (p) : chunk2mem (p)) \
& MALLOC_ALIGN_MASK)


/* pad request bytes into a usable size -- internal version */
/* Note: This must be a macro that evaluates to a compile time constant
if passed a literal constant.  */
#define request2size(req)                                         \
(((req) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE)  ?             \
MINSIZE :                                                      \
((req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK)

/* Check if REQ overflows when padded and aligned and if the resulting
value is less than PTRDIFF_T.  Returns the requested size or
MINSIZE in case the value is less than MINSIZE, or 0 if any of the
previous checks fail.  */
static inline size_t
checked_request2size (size_t req) __nonnull (1)
{
if (__glibc_unlikely (req > PTRDIFF_MAX))
return 0;

/* When using tagged memory, we cannot share the end of the user
block with the header for the next chunk, so ensure that we
allocate blocks that are rounded up to the granule size.  Take
care not to overflow from close to MAX_SIZE_T to a small
number.  Ideally, this would be part of request2size(), but that
must be a macro that produces a compile time constant if passed
a constant literal.  */
if (__glibc_unlikely (mtag_enabled))
{
/* Ensure this is not evaluated if !mtag_enabled, see gcc PR 99551.  */
asm ("");

req = (req + (__MTAG_GRANULE_SIZE - 1)) &
~(size_t)(__MTAG_GRANULE_SIZE - 1);
}

return request2size (req);
}
```
注意，在计算所需的总空间时只需添加 `SIZE_SZ` 一次，因为 `prev_size` 字段可以用来存储数据，因此只需要初始 header。

### 获取 Chunk 数据并更改 metadata

这些函数通过接收指向 chunk 的 pointer 来工作，并且对于检查/设置 metadata 很有用：

- 检查 chunk 的 flags
```c
// From https://github.com/bminor/glibc/blob/master/malloc/malloc.c


/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */
#define PREV_INUSE 0x1

/* extract inuse bit of previous chunk */
#define prev_inuse(p)       ((p)->mchunk_size & PREV_INUSE)


/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */
#define IS_MMAPPED 0x2

/* check for mmap()'ed chunk */
#define chunk_is_mmapped(p) ((p)->mchunk_size & IS_MMAPPED)


/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained
from a non-main arena.  This is only set immediately before handing
the chunk to the user, if necessary.  */
#define NON_MAIN_ARENA 0x4

/* Check for chunk from main arena.  */
#define chunk_main_arena(p) (((p)->mchunk_size & NON_MAIN_ARENA) == 0)

/* Mark a chunk as not being on the main arena.  */
#define set_non_main_arena(p) ((p)->mchunk_size |= NON_MAIN_ARENA)
```
- 大小和指向其他 chunk 的指针
```c
/*
Bits to mask off when extracting size

Note: IS_MMAPPED is intentionally not masked off from size field in
macros for which mmapped chunks should never be seen. This should
cause helpful core dumps to occur if it is tried by accident by
people extending or adapting this malloc.
*/
#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)

/* Get size, ignoring use bits */
#define chunksize(p) (chunksize_nomask (p) & ~(SIZE_BITS))

/* Like chunksize, but do not mask SIZE_BITS.  */
#define chunksize_nomask(p)         ((p)->mchunk_size)

/* Ptr to next physical malloc_chunk. */
#define next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))

/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */
#define prev_size(p) ((p)->mchunk_prev_size)

/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */
#define set_prev_size(p, sz) ((p)->mchunk_prev_size = (sz))

/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */
#define prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))

/* Treat space at ptr + offset as a chunk */
#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))
```
- Insue 位
```c
/* extract p's inuse bit */
#define inuse(p)							      \
((((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size) & PREV_INUSE)

/* set/clear chunk as being inuse without otherwise disturbing */
#define set_inuse(p)							      \
((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size |= PREV_INUSE

#define clear_inuse(p)							      \
((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size &= ~(PREV_INUSE)


/* check/set/clear inuse bits in known places */
#define inuse_bit_at_offset(p, s)					      \
(((mchunkptr) (((char *) (p)) + (s)))->mchunk_size & PREV_INUSE)

#define set_inuse_bit_at_offset(p, s)					      \
(((mchunkptr) (((char *) (p)) + (s)))->mchunk_size |= PREV_INUSE)

#define clear_inuse_bit_at_offset(p, s)					      \
(((mchunkptr) (((char *) (p)) + (s)))->mchunk_size &= ~(PREV_INUSE))
```
- 设置头部和页脚（当使用 chunk 编号
```c
/* Set size at head, without disturbing its use bit */
#define set_head_size(p, s)  ((p)->mchunk_size = (((p)->mchunk_size & SIZE_BITS) | (s)))

/* Set size/use field */
#define set_head(p, s)       ((p)->mchunk_size = (s))

/* Set size at footer (only when chunk is not in use) */
#define set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))->mchunk_prev_size = (s))
```
- 获取 chunk 中真实可用数据的大小
```c
#pragma GCC poison mchunk_size
#pragma GCC poison mchunk_prev_size

/* This is the size of the real usable data in the chunk.  Not valid for
dumped heap chunks.  */
#define memsize(p)                                                    \
(__MTAG_GRANULE_SIZE > SIZE_SZ && __glibc_unlikely (mtag_enabled) ? \
chunksize (p) - CHUNK_HDR_SZ :                                    \
chunksize (p) - CHUNK_HDR_SZ + (chunk_is_mmapped (p) ? 0 : SIZE_SZ))

/* If memory tagging is enabled the layout changes to accommodate the granule
size, this is wasteful for small allocations so not done by default.
Both the chunk header and user data has to be granule aligned.  */
_Static_assert (__MTAG_GRANULE_SIZE <= CHUNK_HDR_SZ,
"memory tagging is not supported with large granule.");

static __always_inline void *
tag_new_usable (void *ptr)
{
if (__glibc_unlikely (mtag_enabled) && ptr)
{
mchunkptr cp = mem2chunk(ptr);
ptr = __libc_mtag_tag_region (__libc_mtag_new_tag (ptr), memsize (cp));
}
return ptr;
}
```
## 示例

### 快速 heap 示例

来自 [https://guyinatuxedo.github.io/25-heap/index.html](https://guyinatuxedo.github.io/25-heap/index.html) 的快速 heap 示例，但在 arm64 上:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void main(void)
{
char *ptr;
ptr = malloc(0x10);
strcpy(ptr, "panda");
}
```
在 main 函数结束处设置一个断点，看看信息存放在哪里：

<figure><img src="../../images/image (1239).png" alt=""><figcaption></figcaption></figure>

可以看到字符串 panda 存储在 `0xaaaaaaac12a0`（这是 malloc 在 `x0` 中返回的地址）。在它之前 0x10 字节处检查，可以看到 `0x0` 表示 **previous chunk is not used**（长度为 0），并且该 chunk 的长度是 `0x21`。

额外保留的空间 (0x21-0x10=0x11) 来自 **added headers** (0x10)，而 0x1 并不表示它保留了 0x21B，而是当前 header 长度的低 3 位具有一些特殊含义。由于长度在 64bits 机器上总是按 16 字节对齐，这些位实际上不会被用于长度数值。
```
0x1:     Previous in Use     - Specifies that the chunk before it in memory is in use
0x2:     Is MMAPPED          - Specifies that the chunk was obtained with mmap()
0x4:     Non Main Arena      - Specifies that the chunk was obtained from outside of the main arena
```
### 多线程示例

<details>

<summary>多线程</summary>
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/types.h>


void* threadFuncMalloc(void* arg) {
printf("Hello from thread 1\n");
char* addr = (char*) malloc(1000);
printf("After malloc and before free in thread 1\n");
free(addr);
printf("After free in thread 1\n");
}

void* threadFuncNoMalloc(void* arg) {
printf("Hello from thread 2\n");
}


int main() {
pthread_t t1;
void* s;
int ret;
char* addr;

printf("Before creating thread 1\n");
getchar();
ret = pthread_create(&t1, NULL, threadFuncMalloc, NULL);
getchar();

printf("Before creating thread 2\n");
ret = pthread_create(&t1, NULL, threadFuncNoMalloc, NULL);

printf("Before exit\n");
getchar();

return 0;
}
```
</details>

调试前面的示例时，可以看到一开始只有 1 个 arena：

<figure><img src="../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

然后，在调用第一个线程（即调用 malloc 的线程）之后，会创建一个新的 arena：

<figure><img src="../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

并且在其中可以找到一些 chunks：

<figure><img src="../../images/image (2) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Bins & Memory Allocations/Frees

查看 bins 是什么、它们如何组织，以及内存如何被分配和释放，详见：


{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

## Heap Functions Security Checks

与 heap 相关的函数在执行其操作之前会执行某些检查，以尽量确保 heap 未被破坏：


{{#ref}}
heap-memory-functions/heap-functions-security-checks.md
{{#endref}}

## Case Studies

研究从真实世界漏洞中衍生出的 allocator-specific primitives：


{{#ref}}
virtualbox-slirp-nat-packet-heap-exploitation.md
{{#endref}}

{{#ref}}
gnu-obstack-function-pointer-hijack.md
{{#endref}}

## 参考

- [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
- [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)


{{#include ../../banners/hacktricks-training.md}}
