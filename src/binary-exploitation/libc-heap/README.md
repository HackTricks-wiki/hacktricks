# Libc Heap

{{#include ../../banners/hacktricks-training.md}}

## Heap-Grundlagen

Der Heap ist im Grunde der Bereich, in dem ein Programm Daten speichern kann, wenn es Speicher über Funktionen wie **`malloc`**, `calloc` anfordert. Wenn dieser Speicher nicht mehr benötigt wird, wird er durch Aufruf der Funktion **`free`** wieder freigegeben.

Wie gezeigt liegt er direkt hinter dem Bereich, in dem das Binary in den Speicher geladen wird (siehe den Abschnitt `[heap]`):

<figure><img src="../../images/image (1241).png" alt=""><figcaption></figcaption></figure>

### Grundlegende Chunk-Allokation

Wenn Speicher für Daten im Heap angefordert wird, wird ein Bereich des Heaps dafür reserviert. Dieser Bereich gehört zu einem bin, und nur die angeforderten Daten + der Platz für die bin-Header + der minimale bin-Größenversatz werden für den Chunk reserviert. Ziel ist es, so wenig Speicher wie möglich zu reservieren, ohne es kompliziert zu machen, die Lage der einzelnen Chunks zu bestimmen. Dazu werden Metadaten des Chunks verwendet, um zu wissen, wo sich belegte/freie Chunks befinden.

Es gibt verschiedene Methoden, den Speicher zu reservieren, hauptsächlich abhängig vom verwendeten bin, aber die allgemeine Vorgehensweise ist folgende:

- Das Programm fordert zunächst eine bestimmte Menge Speicher an.
- Wenn in der Liste der Chunks ein verfügbarer Chunk groß genug ist, um die Anfrage zu erfüllen, wird er verwendet
- Das kann bedeuten, dass ein Teil des verfügbaren Chunks für diese Anfrage benutzt wird und der Rest wieder in die Chunks-Liste aufgenommen wird
- Wenn in der Liste kein verfügbarer Chunk vorhanden ist, aber noch freier Platz im bereits allozierten Heap-Speicher vorhanden ist, erzeugt der Heap-Manager einen neuen Chunk
- Wenn nicht genügend Heap-Speicher vorhanden ist, fordert der Heap-Manager das Kernel auf, den für den Heap zugewiesenen Speicher zu erweitern, und verwendet diesen Speicher dann zur Erzeugung des neuen Chunks
- Wenn alles fehlschlägt, gibt `malloc` null zurück.

Beachte, dass wenn der angeforderte **Speicher einen Schwellenwert überschreitet**, **`mmap`** verwendet wird, um den angeforderten Speicher zu mappen.

## Arenas

In mehrthreadigen Anwendungen muss der Heap-Manager Race Conditions verhindern, die zu Abstürzen führen können. Anfangs wurde dies durch einen globalen Mutex gelöst, der sicherstellt, dass jeweils nur ein Thread auf den Heap zugreifen kann, was jedoch zu Performance-Problemen aufgrund dieses Mutex-bedingten Flaschenhalses führte.

Um dem zu begegnen führte der ptmalloc2 heap allocator „arenas“ ein, wobei jede arena als separater Heap mit eigenen Datenstrukturen und eigenem Mutex fungiert. Dadurch können mehrere Threads Heap-Operationen ausführen, ohne sich gegenseitig zu stören, solange sie unterschiedliche arenas verwenden.

Die Standard-"main" arena übernimmt die Heap-Operationen für Single-Thread-Anwendungen. Wenn neue Threads hinzugefügt werden, weist der Heap-Manager ihnen secondary arenas zu, um Contention zu reduzieren. Er versucht zunächst, jeden neuen Thread an eine ungenutzte arena anzuhängen, und erstellt bei Bedarf neue, bis zu einer Grenze von 2× der Anzahl der CPU-Kerne für 32-Bit-Systeme und 8× für 64-Bit-Systeme. Sobald das Limit erreicht ist, müssen Threads arenas teilen, was zu möglicher Contention führt.

Im Gegensatz zur main arena, die mit dem Systemaufruf `brk` wächst, erstellen secondary arenas "subheaps" mithilfe von `mmap` und `mprotect`, um das Heap-Verhalten zu simulieren und so Flexibilität bei der Speicherverwaltung für multithreaded Operationen zu bieten.

### Subheaps

Subheaps dienen als Speicherreserve für secondary arenas in multithreaded Anwendungen und ermöglichen es ihnen, eigenständig zu wachsen und eigene Heap-Bereiche getrennt vom Haupt-Heap zu verwalten. So unterscheiden sich subheaps vom initialen Heap und so funktionieren sie:

1. Initialer Heap vs. Subheaps:
- Der initiale Heap befindet sich unmittelbar hinter dem Programmbinary im Speicher und wächst mittels des Systemaufrufs `sbrk`.
- Subheaps, die von secondary arenas verwendet werden, werden mittels `mmap` erstellt, einem Systemaufruf, der einen bestimmten Speicherbereich abbildet.
2. Speicherreservierung mit `mmap`:
- Wenn der Heap-Manager einen subheap anlegt, reserviert er mit `mmap` einen großen Speicherblock. Diese Reservierung weist dem Bereich nicht sofort physischen Speicher zu; sie markiert lediglich eine Region, die andere Systemprozesse oder Allokationen nicht verwenden sollten.
- Standardmäßig beträgt die reservierte Größe eines subheaps 1 MB für 32-Bit-Prozesse und 64 MB für 64-Bit-Prozesse.
3. Stufenweises Wachstum mit `mprotect`:
- Der reservierte Speicherbereich wird zunächst mit `PROT_NONE` markiert, was anzeigt, dass der Kernel diesem Bereich noch keinen physischen Speicher zuweisen muss.
- Um den subheap zu 'vergrößern', verwendet der Heap-Manager `mprotect`, um die Seitenschutzrechte von `PROT_NONE` auf `PROT_READ | PROT_WRITE` zu ändern, wodurch der Kernel physischen Speicher für die zuvor reservierten Adressen zuweist. Dieser schrittweise Ansatz ermöglicht es dem subheap, bei Bedarf zu wachsen.
- Ist der gesamte subheap erschöpft, erstellt der Heap-Manager einen neuen subheap, um die Allokationen fortzusetzen.

### heap_info <a href="#heap_info" id="heap_info"></a>

Diese struct enthält relevante Informationen zum Heap. Außerdem kann der Heap-Speicher nach weiteren Allokationen nicht mehr zusammenhängend sein; diese struct speichert ebenfalls diese Information.
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/arena.c#L837

typedef struct _heap_info
{
mstate ar_ptr; /* Arena for this heap. */
struct _heap_info *prev; /* Previous heap. */
size_t size;   /* Current size in bytes. */
size_t mprotect_size; /* Size in bytes that has been mprotected
PROT_READ|PROT_WRITE.  */
size_t pagesize; /* Page size used when allocating the arena.  */
/* Make sure the following data is properly aligned, particularly
that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of
MALLOC_ALIGNMENT. */
char pad[-3 * SIZE_SZ & MALLOC_ALIGN_MASK];
} heap_info;
```
### malloc_state

**Jeder heap** (main arena or other threads arenas) hat eine **`malloc_state` Struktur.**\
Es ist wichtig zu beachten, dass die **main arena `malloc_state`** Struktur eine **globale Variable in der libc** ist (daher im libc memory space gelegen).\
Im Falle der **`malloc_state`** Strukturen der Heaps von Threads befinden sie sich **im eigenen Thread "heap"**.

There some interesting things to note from this structure (see C code below):

- `__libc_lock_define (, mutex);` dient dazu sicherzustellen, dass auf diese Struktur im heap jeweils nur ein Thread zugreift
- Flags:

- ```c
#define NONCONTIGUOUS_BIT     (2U)

#define contiguous(M)          (((M)->flags & NONCONTIGUOUS_BIT) == 0)
#define noncontiguous(M)       (((M)->flags & NONCONTIGUOUS_BIT) != 0)
#define set_noncontiguous(M)   ((M)->flags |= NONCONTIGUOUS_BIT)
#define set_contiguous(M)      ((M)->flags &= ~NONCONTIGUOUS_BIT)
```

- The `mchunkptr bins[NBINS * 2 - 2];` enthält **pointers** zu den **first and last chunks** der small, large und unsorted **bins** (das -2 ist, weil der Index 0 nicht verwendet wird)
- Daher wird der **first chunk** dieser bins einen **backwards pointer to this structure** haben und der **last chunk** dieser bins wird einen **forward pointer** zu dieser Struktur haben. Das bedeutet im Grunde, dass, wenn du diese Adressen in der main arena leak kannst, du einen Pointer auf die Struktur in der **libc** haben wirst.
- Die structs `struct malloc_state *next;` und `struct malloc_state *next_free;` sind linked lists of arenas
- Der `top` chunk ist der letzte "chunk", welcher im Grunde **der gesamte verbleibende heap space** ist. Sobald der top chunk "empty" ist, ist der heap vollständig benutzt und muss mehr Platz anfordern.
- Der `last reminder` chunk entsteht in Fällen, in denen kein Chunk in exakt passender Größe verfügbar ist und daher ein größerer Chunk aufgeteilt wird; ein Pointer auf den verbleibenden Teil wird hier platziert.
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1812

struct malloc_state
{
/* Serialize access.  */
__libc_lock_define (, mutex);

/* Flags (formerly in max_fast).  */
int flags;

/* Set if the fastbin chunks contain recently inserted free blocks.  */
/* Note this is a bool but not all targets support atomics on booleans.  */
int have_fastchunks;

/* Fastbins */
mfastbinptr fastbinsY[NFASTBINS];

/* Base of the topmost chunk -- not otherwise kept in a bin */
mchunkptr top;

/* The remainder from the most recent split of a small request */
mchunkptr last_remainder;

/* Normal bins packed as described above */
mchunkptr bins[NBINS * 2 - 2];

/* Bitmap of bins */
unsigned int binmap[BINMAPSIZE];

/* Linked list */
struct malloc_state *next;

/* Linked list for free arenas.  Access to this field is serialized
by free_list_lock in arena.c.  */
struct malloc_state *next_free;

/* Number of threads attached to this arena.  0 if the arena is on
the free list.  Access to this field is serialized by
free_list_lock in arena.c.  */
INTERNAL_SIZE_T attached_threads;

/* Memory allocated from the system in this arena.  */
INTERNAL_SIZE_T system_mem;
INTERNAL_SIZE_T max_system_mem;
};
```
### malloc_chunk

Diese Struktur repräsentiert einen bestimmten Chunk im Speicher. Die verschiedenen Felder haben unterschiedliche Bedeutungen für alloziierte und nicht-alloziierte Chunks.
```c
// https://github.com/bminor/glibc/blob/master/malloc/malloc.c
struct malloc_chunk {
INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk, if it is free. */
INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
struct malloc_chunk* fd;                /* double links -- used only if this chunk is free. */
struct malloc_chunk* bk;
/* Only used for large blocks: pointer to next larger size.  */
struct malloc_chunk* fd_nextsize; /* double links -- used only if this chunk is free. */
struct malloc_chunk* bk_nextsize;
};

typedef struct malloc_chunk* mchunkptr;
```
Wie bereits erwähnt, haben diese chunks auch einige Metadaten, sehr gut dargestellt in diesem Bild:

<figure><img src="../../images/image (1242).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

Die Metadaten sind üblicherweise 0x08B und geben die aktuelle Chunk-Größe an, wobei die letzten 3 Bits folgendes kodieren:

- `A`: If 1 it comes from a subheap, if 0 it's in the main arena
- `M`: If 1, this chunk is part of a space allocated with mmap and not part of a heap
- `P`: If 1, the previous chunk is in use

Dann folgt der Platz für die user data, und schließlich 0x08B, um die previous chunk size anzuzeigen, wenn der Chunk verfügbar ist (oder um user data zu speichern, wenn er alloziert wurde).

Außerdem werden, wenn sie verfügbar ist, die user data genutzt, um zusätzlich folgende Felder zu enthalten:

- **`fd`**: Pointer zum nächsten chunk
- **`bk`**: Pointer zum vorherigen chunk
- **`fd_nextsize`**: Pointer auf das erste chunk in der Liste, das kleiner als dieses ist
- **`bk_nextsize`:** Pointer auf das erste chunk in der Liste, das größer als dieses ist

<figure><img src="../../images/image (1243).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

> [!TIP]
> Beachte, wie das Verknüpfen der Liste auf diese Weise die Notwendigkeit eines Arrays verhindert, in dem jeder einzelne chunk registriert werden müsste.

### Chunk-Pointer

Wenn malloc verwendet wird, wird ein Pointer auf den Inhalt zurückgegeben, der beschrieben werden kann (direkt nach den headers); beim Verwalten von chunks wird jedoch ein Pointer auf den Beginn der headers (metadata) benötigt.\
Für diese Konversionen werden folgende Funktionen verwendet:
```c
// https://github.com/bminor/glibc/blob/master/malloc/malloc.c

/* Convert a chunk address to a user mem pointer without correcting the tag.  */
#define chunk2mem(p) ((void*)((char*)(p) + CHUNK_HDR_SZ))

/* Convert a user mem pointer to a chunk address and extract the right tag.  */
#define mem2chunk(mem) ((mchunkptr)tag_at (((char*)(mem) - CHUNK_HDR_SZ)))

/* The smallest possible chunk */
#define MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))

/* The smallest size we can malloc is an aligned minimal chunk */

#define MINSIZE  \
(unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK))
```
### Ausrichtung & Mindestgröße

Der pointer auf den chunk und `0x0f` müssen 0 sein.
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/sysdeps/generic/malloc-size.h#L61
#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)

// https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/sysdeps/i386/malloc-alignment.h
#define MALLOC_ALIGNMENT 16


// https://github.com/bminor/glibc/blob/master/malloc/malloc.c
/* Check if m has acceptable alignment */
#define aligned_OK(m)  (((unsigned long)(m) & MALLOC_ALIGN_MASK) == 0)

#define misaligned_chunk(p) \
((uintptr_t)(MALLOC_ALIGNMENT == CHUNK_HDR_SZ ? (p) : chunk2mem (p)) \
& MALLOC_ALIGN_MASK)


/* pad request bytes into a usable size -- internal version */
/* Note: This must be a macro that evaluates to a compile time constant
if passed a literal constant.  */
#define request2size(req)                                         \
(((req) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE)  ?             \
MINSIZE :                                                      \
((req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK)

/* Check if REQ overflows when padded and aligned and if the resulting
value is less than PTRDIFF_T.  Returns the requested size or
MINSIZE in case the value is less than MINSIZE, or 0 if any of the
previous checks fail.  */
static inline size_t
checked_request2size (size_t req) __nonnull (1)
{
if (__glibc_unlikely (req > PTRDIFF_MAX))
return 0;

/* When using tagged memory, we cannot share the end of the user
block with the header for the next chunk, so ensure that we
allocate blocks that are rounded up to the granule size.  Take
care not to overflow from close to MAX_SIZE_T to a small
number.  Ideally, this would be part of request2size(), but that
must be a macro that produces a compile time constant if passed
a constant literal.  */
if (__glibc_unlikely (mtag_enabled))
{
/* Ensure this is not evaluated if !mtag_enabled, see gcc PR 99551.  */
asm ("");

req = (req + (__MTAG_GRANULE_SIZE - 1)) &
~(size_t)(__MTAG_GRANULE_SIZE - 1);
}

return request2size (req);
}
```
Beachte, dass bei der Berechnung des benötigten Gesamtspeichers `SIZE_SZ` nur einmal hinzugefügt wird, da das Feld `prev_size` zum Speichern von Daten verwendet werden kann; daher ist nur der initiale Header nötig.

### Chunk-Daten abrufen und Metadaten ändern

Diese Funktionen erhalten einen Pointer auf einen Chunk und sind nützlich, um Metadaten zu prüfen/setzen:

- Prüfe Chunk-Flags
```c
// From https://github.com/bminor/glibc/blob/master/malloc/malloc.c


/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */
#define PREV_INUSE 0x1

/* extract inuse bit of previous chunk */
#define prev_inuse(p)       ((p)->mchunk_size & PREV_INUSE)


/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */
#define IS_MMAPPED 0x2

/* check for mmap()'ed chunk */
#define chunk_is_mmapped(p) ((p)->mchunk_size & IS_MMAPPED)


/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained
from a non-main arena.  This is only set immediately before handing
the chunk to the user, if necessary.  */
#define NON_MAIN_ARENA 0x4

/* Check for chunk from main arena.  */
#define chunk_main_arena(p) (((p)->mchunk_size & NON_MAIN_ARENA) == 0)

/* Mark a chunk as not being on the main arena.  */
#define set_non_main_arena(p) ((p)->mchunk_size |= NON_MAIN_ARENA)
```
- Größen und pointers zu anderen chunks
```c
/*
Bits to mask off when extracting size

Note: IS_MMAPPED is intentionally not masked off from size field in
macros for which mmapped chunks should never be seen. This should
cause helpful core dumps to occur if it is tried by accident by
people extending or adapting this malloc.
*/
#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)

/* Get size, ignoring use bits */
#define chunksize(p) (chunksize_nomask (p) & ~(SIZE_BITS))

/* Like chunksize, but do not mask SIZE_BITS.  */
#define chunksize_nomask(p)         ((p)->mchunk_size)

/* Ptr to next physical malloc_chunk. */
#define next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))

/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */
#define prev_size(p) ((p)->mchunk_prev_size)

/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */
#define set_prev_size(p, sz) ((p)->mchunk_prev_size = (sz))

/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */
#define prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))

/* Treat space at ptr + offset as a chunk */
#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))
```
- In-use-Bit
```c
/* extract p's inuse bit */
#define inuse(p)							      \
((((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size) & PREV_INUSE)

/* set/clear chunk as being inuse without otherwise disturbing */
#define set_inuse(p)							      \
((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size |= PREV_INUSE

#define clear_inuse(p)							      \
((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size &= ~(PREV_INUSE)


/* check/set/clear inuse bits in known places */
#define inuse_bit_at_offset(p, s)					      \
(((mchunkptr) (((char *) (p)) + (s)))->mchunk_size & PREV_INUSE)

#define set_inuse_bit_at_offset(p, s)					      \
(((mchunkptr) (((char *) (p)) + (s)))->mchunk_size |= PREV_INUSE)

#define clear_inuse_bit_at_offset(p, s)					      \
(((mchunkptr) (((char *) (p)) + (s)))->mchunk_size &= ~(PREV_INUSE))
```
- Kopf- und Fußzeile setzen (wenn Chunk-Nummern verwendet werden)
```c
/* Set size at head, without disturbing its use bit */
#define set_head_size(p, s)  ((p)->mchunk_size = (((p)->mchunk_size & SIZE_BITS) | (s)))

/* Set size/use field */
#define set_head(p, s)       ((p)->mchunk_size = (s))

/* Set size at footer (only when chunk is not in use) */
#define set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))->mchunk_prev_size = (s))
```
- Bestimme die Größe der tatsächlich nutzbaren Daten im chunk
```c
#pragma GCC poison mchunk_size
#pragma GCC poison mchunk_prev_size

/* This is the size of the real usable data in the chunk.  Not valid for
dumped heap chunks.  */
#define memsize(p)                                                    \
(__MTAG_GRANULE_SIZE > SIZE_SZ && __glibc_unlikely (mtag_enabled) ? \
chunksize (p) - CHUNK_HDR_SZ :                                    \
chunksize (p) - CHUNK_HDR_SZ + (chunk_is_mmapped (p) ? 0 : SIZE_SZ))

/* If memory tagging is enabled the layout changes to accommodate the granule
size, this is wasteful for small allocations so not done by default.
Both the chunk header and user data has to be granule aligned.  */
_Static_assert (__MTAG_GRANULE_SIZE <= CHUNK_HDR_SZ,
"memory tagging is not supported with large granule.");

static __always_inline void *
tag_new_usable (void *ptr)
{
if (__glibc_unlikely (mtag_enabled) && ptr)
{
mchunkptr cp = mem2chunk(ptr);
ptr = __libc_mtag_tag_region (__libc_mtag_new_tag (ptr), memsize (cp));
}
return ptr;
}
```
## Beispiele

### Schnelles Heap-Beispiel

Schnelles Heap-Beispiel aus [https://guyinatuxedo.github.io/25-heap/index.html](https://guyinatuxedo.github.io/25-heap/index.html), aber für arm64:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void main(void)
{
char *ptr;
ptr = malloc(0x10);
strcpy(ptr, "panda");
}
```
Setze einen Breakpoint am Ende der main-Funktion und lass uns herausfinden, wo die Information gespeichert wurde:

<figure><img src="../../images/image (1239).png" alt=""><figcaption></figcaption></figure>

Es ist möglich zu sehen, dass der String panda bei `0xaaaaaaac12a0` gespeichert wurde (was die von malloc in `x0` zurückgegebene Adresse war). Wenn man 0x10 Bytes davor prüft, kann man sehen, dass `0x0` bedeutet, dass der **vorherige Chunk nicht verwendet wird** (Länge 0) und dass die Länge dieses Chunks `0x21` ist.

Die zusätzlich reservierten Bytes (0x21-0x10=0x11) stammen von den **hinzugefügten Headern** (0x10) und 0x1 bedeutet nicht, dass 0x21B reserviert wurde, sondern die letzten 3 Bits der Länge des aktuellen Headers haben einige spezielle Bedeutungen. Da die Länge immer 16-Byte-ausgerichtet ist (auf 64-Bit-Maschinen), werden diese Bits vom Längenwert tatsächlich nie verwendet.
```
0x1:     Previous in Use     - Specifies that the chunk before it in memory is in use
0x2:     Is MMAPPED          - Specifies that the chunk was obtained with mmap()
0x4:     Non Main Arena      - Specifies that the chunk was obtained from outside of the main arena
```
### Multithreading-Beispiel

<details>

<summary>Multithreading</summary>
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/types.h>


void* threadFuncMalloc(void* arg) {
printf("Hello from thread 1\n");
char* addr = (char*) malloc(1000);
printf("After malloc and before free in thread 1\n");
free(addr);
printf("After free in thread 1\n");
}

void* threadFuncNoMalloc(void* arg) {
printf("Hello from thread 2\n");
}


int main() {
pthread_t t1;
void* s;
int ret;
char* addr;

printf("Before creating thread 1\n");
getchar();
ret = pthread_create(&t1, NULL, threadFuncMalloc, NULL);
getchar();

printf("Before creating thread 2\n");
ret = pthread_create(&t1, NULL, threadFuncNoMalloc, NULL);

printf("Before exit\n");
getchar();

return 0;
}
```
</details>

Beim Debuggen des vorherigen Beispiels ist zu sehen, dass sich zu Beginn nur 1 arena befindet:

<figure><img src="../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Dann, nachdem der erste thread aufgerufen wurde — derjenige, der malloc aufruft — wird eine neue arena erstellt:

<figure><img src="../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

und darin können einige chunks gefunden werden:

<figure><img src="../../images/image (2) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Bins & Memory Allocations/Frees

Untersuche, welche bins existieren, wie sie organisiert sind und wie Speicher alloziert und freigegeben wird in:


{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

## Heap Functions Security Checks

Funktionen, die am heap beteiligt sind, führen bestimmte Prüfungen durch, bevor sie ihre Aktionen ausführen, um zu versuchen sicherzustellen, dass der heap nicht korruptiert wurde:


{{#ref}}
heap-memory-functions/heap-functions-security-checks.md
{{#endref}}

## Case Studies

Untersuche allocator-spezifische primitives, die aus realen bugs abgeleitet sind:

{{#ref}}
virtualbox-slirp-nat-packet-heap-exploitation.md
{{#endref}}

## Referenzen

- [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
- [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)


{{#include ../../banners/hacktricks-training.md}}
