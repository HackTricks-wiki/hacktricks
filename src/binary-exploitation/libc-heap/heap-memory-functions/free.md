# free

{{#include ../../../banners/hacktricks-training.md}}

## Riepilogo dell'ordine di Free <a href="#libc_free" id="libc_free"></a>

(In questo sommario non sono spiegati i controlli e alcuni casi sono stati omessi per brevità)

1. If the address is null don't do anything
2. If the chunk was mmaped, munmap it and finish
3. Call `_int_free`:
   1. If possible, add the chunk to the tcache
   2. If possible, add the chunk to the fast bin
   3. Call `_int_free_merge_chunk` to consolidate the chunk is needed and add it to the unsorted list

> Nota: A partire da glibc 2.42, il passo della tcache può anche accettare chunk fino a una soglia di dimensione molto maggiore (see “Recent glibc changes” below). Questo cambia quando una free finisce in tcache vs. unsorted/small/large bins.

## __libc_free <a href="#libc_free" id="libc_free"></a>

`Free` calls `__libc_free`.

- Se l'indirizzo passato è Null (0) non fare nulla.
- Controlla il pointer tag
- Se il chunk è `mmaped`, `munmap` it e basta
- Altrimenti, aggiungi il color e chiama `_int_free` su di esso

<details>

<summary>__lib_free code</summary>
```c
void
__libc_free (void *mem)
{
mstate ar_ptr;
mchunkptr p;                          /* chunk corresponding to mem */

if (mem == 0)                              /* free(0) has no effect */
return;

/* Quickly check that the freed pointer matches the tag for the memory.
This gives a useful double-free detection.  */
if (__glibc_unlikely (mtag_enabled))
*(volatile char *)mem;

int err = errno;

p = mem2chunk (mem);

if (chunk_is_mmapped (p))                       /* release mmapped memory. */
{
/* See if the dynamic brk/mmap threshold needs adjusting.
Dumped fake mmapped chunks do not affect the threshold.  */
if (!mp_.no_dyn_threshold
&& chunksize_nomask (p) > mp_.mmap_threshold
&& chunksize_nomask (p) <= DEFAULT_MMAP_THRESHOLD_MAX)
{
mp_.mmap_threshold = chunksize (p);
mp_.trim_threshold = 2 * mp_.mmap_threshold;
LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,
mp_.mmap_threshold, mp_.trim_threshold);
}
munmap_chunk (p);
}
else
{
MAYBE_INIT_TCACHE ();

/* Mark the chunk as belonging to the library again.  */
(void)tag_region (chunk2mem (p), memsize (p));

ar_ptr = arena_for_chunk (p);
_int_free (ar_ptr, p, 0);
}

__set_errno (err);
}
libc_hidden_def (__libc_free)
```
</details>

## _int_free <a href="#int_free" id="int_free"></a>

### _int_free start <a href="#int_free" id="int_free"></a>

Inizia con alcuni controlli che verificano:

- il **pointer** sia **aligned,** altrimenti viene generato l'errore `free(): invalid pointer`
- la **size** non sia inferiore al minimo e che la **size** sia anche **aligned**, altrimenti viene generato l'errore: `free(): invalid size`

<details>

<summary>_int_free start</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4493C1-L4513C28

#define aligned_OK(m) (((unsigned long) (m) &MALLOC_ALIGN_MASK) == 0)

static void
_int_free (mstate av, mchunkptr p, int have_lock)
{
INTERNAL_SIZE_T size;        /* its size */
mfastbinptr *fb;             /* associated fastbin */

size = chunksize (p);

/* Little security check which won't hurt performance: the
allocator never wraps around at the end of the address space.
Therefore we can exclude some size values which might appear
here by accident or by "design" from some intruder.  */
if (__builtin_expect ((uintptr_t) p > (uintptr_t) -size, 0)
|| __builtin_expect (misaligned_chunk (p), 0))
malloc_printerr ("free(): invalid pointer");
/* We know that each chunk is at least MINSIZE bytes in size or a
multiple of MALLOC_ALIGNMENT.  */
if (__glibc_unlikely (size < MINSIZE || !aligned_OK (size)))
malloc_printerr ("free(): invalid size");

check_inuse_chunk(av, p);
```
</details>

### _int_free tcache <a href="#int_free" id="int_free"></a>

Prima tenterà di allocare questo chunk nel tcache correlato. Tuttavia, vengono eseguiti alcuni controlli prima. Scorrerà tutti i chunk del tcache nello stesso indice del freed chunk e:

- If there are more entries than `mp_.tcache_count`: `free(): too many chunks detected in tcache`
- If the entry is not aligned: `free(): unaligned chunk detected in tcache 2`
- se il freed chunk era già stato liberato ed è presente come chunk nel tcache: `free(): double free detected in tcache 2`

Se tutto va bene, il chunk viene aggiunto al tcache e la funzione ritorna.

<details>

<summary>_int_free tcache</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4515C1-L4554C7
#if USE_TCACHE
{
size_t tc_idx = csize2tidx (size);
if (tcache != NULL && tc_idx < mp_.tcache_bins)
{
/* Check to see if it's already in the tcache.  */
tcache_entry *e = (tcache_entry *) chunk2mem (p);

/* This test succeeds on double free.  However, we don't 100%
trust it (it also matches random payload data at a 1 in
2^<size_t> chance), so verify it's not an unlikely
coincidence before aborting.  */
if (__glibc_unlikely (e->key == tcache_key))
{
tcache_entry *tmp;
size_t cnt = 0;
LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
for (tmp = tcache->entries[tc_idx];
tmp;
tmp = REVEAL_PTR (tmp->next), ++cnt)
{
if (cnt >= mp_.tcache_count)
malloc_printerr ("free(): too many chunks detected in tcache");
if (__glibc_unlikely (!aligned_OK (tmp)))
malloc_printerr ("free(): unaligned chunk detected in tcache 2");
if (tmp == e)
malloc_printerr ("free(): double free detected in tcache 2");
/* If we get here, it was a coincidence.  We've wasted a
few cycles, but don't abort.  */
}
}

if (tcache->counts[tc_idx] < mp_.tcache_count)
{
tcache_put (p, tc_idx);
return;
}
}
}
#endif
```
</details>

### _int_free fast bin <a href="#int_free" id="int_free"></a>

Inizia verificando che la dimensione sia adatta ai fast bin e controlla se è possibile posizionarla vicino al top chunk.

Poi, aggiungi il chunk liberato in cima al fast bin eseguendo alcuni controlli:

- Se la dimensione del chunk non è valida (troppo grande o troppo piccola) viene generato: `free(): invalid next size (fast)`
- Se il chunk aggiunto era già il top del fast bin: `double free or corruption (fasttop)`
- Se la dimensione del chunk in cima ha una dimensione diversa da quella del chunk che stiamo aggiungendo: `invalid fastbin entry (free)`

<details>

<summary>_int_free Fast Bin</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4556C2-L4631C4

/*
If eligible, place chunk on a fastbin so it can be found
and used quickly in malloc.
*/

if ((unsigned long)(size) <= (unsigned long)(get_max_fast ())

#if TRIM_FASTBINS
/*
If TRIM_FASTBINS set, don't place chunks
bordering top into fastbins
*/
&& (chunk_at_offset(p, size) != av->top)
#endif
) {

if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))
<= CHUNK_HDR_SZ, 0)
|| __builtin_expect (chunksize (chunk_at_offset (p, size))
>= av->system_mem, 0))
{
bool fail = true;
/* We might not have a lock at this point and concurrent modifications
of system_mem might result in a false positive.  Redo the test after
getting the lock.  */
if (!have_lock)
{
__libc_lock_lock (av->mutex);
fail = (chunksize_nomask (chunk_at_offset (p, size)) <= CHUNK_HDR_SZ
|| chunksize (chunk_at_offset (p, size)) >= av->system_mem);
__libc_lock_unlock (av->mutex);
}

if (fail)
malloc_printerr ("free(): invalid next size (fast)");
}

free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);

atomic_store_relaxed (&av->have_fastchunks, true);
unsigned int idx = fastbin_index(size);
fb = &fastbin (av, idx);

/* Atomically link P to its fastbin: P->FD = *FB; *FB = P;  */
mchunkptr old = *fb, old2;

if (SINGLE_THREAD_P)
{
/* Check that the top of the bin is not the record we are going to
add (i.e., double free).  */
if (__builtin_expect (old == p, 0))
malloc_printerr ("double free or corruption (fasttop)");
p->fd = PROTECT_PTR (&p->fd, old);
*fb = p;
}
else
do
{
/* Check that the top of the bin is not the record we are going to
add (i.e., double free).  */
if (__builtin_expect (old == p, 0))
malloc_printerr ("double free or corruption (fasttop)");
old2 = old;
p->fd = PROTECT_PTR (&p->fd, old);
}
while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))
!= old2);

/* Check that size of fastbin chunk at the top is the same as
size of the chunk that we are adding.  We can dereference OLD
only if we have the lock, otherwise it might have already been
allocated again.  */
if (have_lock && old != NULL
&& __builtin_expect (fastbin_index (chunksize (old)) != idx, 0))
malloc_printerr ("invalid fastbin entry (free)");
}
```
</details>

### _int_free finale <a href="#int_free" id="int_free"></a>

Se il chunk non è ancora stato allocato in nessun bin, chiama `_int_free_merge_chunk`

<details>

<summary>_int_free finale</summary>
```c
/*
Consolidate other non-mmapped chunks as they arrive.
*/

else if (!chunk_is_mmapped(p)) {

/* If we're single-threaded, don't lock the arena.  */
if (SINGLE_THREAD_P)
have_lock = true;

if (!have_lock)
__libc_lock_lock (av->mutex);

_int_free_merge_chunk (av, p, size);

if (!have_lock)
__libc_lock_unlock (av->mutex);
}
/*
If the chunk was allocated via mmap, release via munmap().
*/

else {
munmap_chunk (p);
}
}
```
</details>

## _int_free_merge_chunk

Questa funzione tenta di unire il chunk P di SIZE byte con i suoi vicini. Pone il chunk risultante nella unsorted bin list.

Vengono effettuati alcuni controlli:

- Se il chunk è il top chunk: `double free or corruption (top)`
- Se il chunk successivo è fuori dai limiti dell'arena: `double free or corruption (out)`
- Se il chunk non è marcato come usato (nel `prev_inuse` del chunk successivo): `double free or corruption (!prev)`
- Se il chunk successivo ha una dimensione troppo piccola o troppo grande: `free(): invalid next size (normal)`
- Se il chunk precedente non è in uso, verrà tentata la consolidazione. Tuttavia, se il prev_size differisce dalla dimensione indicata nel chunk precedente: `corrupted size vs. prev_size while consolidating`

<details>

<summary>_int_free_merge_chunk codice</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4660C1-L4702C2

/* Try to merge chunk P of SIZE bytes with its neighbors.  Put the
resulting chunk on the appropriate bin list.  P must not be on a
bin list yet, and it can be in use.  */
static void
_int_free_merge_chunk (mstate av, mchunkptr p, INTERNAL_SIZE_T size)
{
mchunkptr nextchunk = chunk_at_offset(p, size);

/* Lightweight tests: check whether the block is already the
top block.  */
if (__glibc_unlikely (p == av->top))
malloc_printerr ("double free or corruption (top)");
/* Or whether the next chunk is beyond the boundaries of the arena.  */
if (__builtin_expect (contiguous (av)
&& (char *) nextchunk
>= ((char *) av->top + chunksize(av->top)), 0))
malloc_printerr ("double free or corruption (out)");
/* Or whether the block is actually not marked used.  */
if (__glibc_unlikely (!prev_inuse(nextchunk)))
malloc_printerr ("double free or corruption (!prev)");

INTERNAL_SIZE_T nextsize = chunksize(nextchunk);
if (__builtin_expect (chunksize_nomask (nextchunk) <= CHUNK_HDR_SZ, 0)
|| __builtin_expect (nextsize >= av->system_mem, 0))
malloc_printerr ("free(): invalid next size (normal)");

free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);

/* Consolidate backward.  */
if (!prev_inuse(p))
{
INTERNAL_SIZE_T prevsize = prev_size (p);
size += prevsize;
p = chunk_at_offset(p, -((long) prevsize));
if (__glibc_unlikely (chunksize(p) != prevsize))
malloc_printerr ("corrupted size vs. prev_size while consolidating");
unlink_chunk (av, p);
}

/* Write the chunk header, maybe after merging with the following chunk.  */
size = _int_free_create_chunk (av, p, size, nextchunk, nextsize);
_int_free_maybe_consolidate (av, size);
}
```
</details>

---

## Note dell'attaccante e modifiche recenti (2023–2025)

- Safe-Linking in tcache/fastbins: `free()` memorizza il puntatore `fd` delle liste collegare singolarmente usando la macro `PROTECT_PTR(pos, ptr) = ((size_t)pos >> 12) ^ (size_t)ptr`. Questo significa che creare un fake next pointer per il tcache poisoning richiede che l'attaccante conosca un indirizzo heap (es., leak `chunk_addr`, poi usare `chunk_addr >> 12` come chiave XOR). Vedi più dettagli e PoCs nella pagina tcache qui sotto.
- Tcache double-free detection: Prima di inserire un chunk nel tcache, `free()` controlla il per-entry `e->key` rispetto al per-thread `tcache_key` e scorre il bin fino a `mp_.tcache_count` cercando duplicati, abortendo con `free(): double free detected in tcache 2` quando ne trova.
- Recent glibc change (2.42): il tcache è stato esteso per accettare chunk molto più grandi, controllato dal nuovo tunable `glibc.malloc.tcache_max_bytes`. `free()` ora tenterà di mettere in cache i chunk liberati fino a quel limite in byte (i chunk mmapped non vengono messi in cache). Questo riduce la frequenza con cui le free ricadono negli unsorted/small/large bins sui sistemi moderni.

### Creazione rapida di un safe-linked fd (per tcache poisoning)
```py
# Given a leaked heap pointer to an entry located at &entry->next == POS
# compute the protected fd that points to TARGET
protected_fd = TARGET ^ (POS >> 12)
```
- Per una guida completa al tcache poisoning (e i suoi limiti sotto safe-linking), vedi:

{{#ref}}
../tcache-bin-attack.md
{{#endref}}

### Forzare i frees a colpire unsorted/small bins durante la ricerca

Talvolta vuoi evitare completamente tcache in un laboratorio locale per osservare il comportamento classico di `_int_free` (unsorted bin consolidation, ecc.). Puoi farlo con GLIBC_TUNABLES:
```bash
# Disable tcache completely
GLIBC_TUNABLES=glibc.malloc.tcache_count=0 ./vuln

# Pre-2.42: shrink the maximum cached request size to 0
GLIBC_TUNABLES=glibc.malloc.tcache_max=0 ./vuln

# 2.42+: cap the new large-cache threshold (bytes)
GLIBC_TUNABLES=glibc.malloc.tcache_max_bytes=0 ./vuln
```
Letture correlate in HackTricks:

- First-fit/unsorted behaviour e trucchi di overlap:

{{#ref}}
../use-after-free/first-fit.md
{{#endref}}

- Double-free primitives e controlli moderni:

{{#ref}}
../double-free.md
{{#endref}}

> Attenzione sui hooks: Le classiche tecniche di sovrascrittura `__malloc_hook`/`__free_hook` non sono praticabili su glibc moderne (≥ 2.34). Se le trovi ancora in write-up più vecchi, adattale a target alternativi (IO_FILE, exit handlers, vtables, ecc.). Per background, consulta la pagina sui hooks in HackTricks.

{{#ref}}
../../arbitrary-write-2-exec/aw2exec-__malloc_hook.md
{{#endref}}

## Riferimenti

- GNU C Library – NEWS per 2.42 (allocator: tcache più grande via tcache_max_bytes, i chunk mmapped non vengono memorizzati nella cache) <https://www.gnu.org/software/libc/NEWS.html#2.42>
- Spiegazione e internals di Safe-Linking (Red Hat Developer, 2020) <https://developers.redhat.com/articles/2020/05/13/new-security-hardening-gnu-c-library>

{{#include ../../../banners/hacktricks-training.md}}
