# free

{{#include ../../../banners/hacktricks-training.md}}

## Free Order Summary <a href="#libc_free" id="libc_free"></a>

(Δεν εξηγούνται οι έλεγχοι σε αυτή τη σύνοψη και κάποιες περιπτώσεις έχουν παραλειφθεί για συντομία)

1. If the address is null don't do anything
2. If the chunk was mmaped, munmap it and finish
3. Call `_int_free`:
1. If possible, add the chunk to the tcache
2. If possible, add the chunk to the fast bin
3. Call `_int_free_merge_chunk` to consolidate the chunk is needed and add it to the unsorted list

> Note: Starting with glibc 2.42, the tcache step can also take chunks up to a much larger size threshold (see “Recent glibc changes” below). This changes when a free lands in tcache vs. unsorted/small/large bins.

## __libc_free <a href="#libc_free" id="libc_free"></a>

`Free` καλεί `__libc_free`.

- Εάν η διεύθυνση που περάστηκε είναι Null (0), μην κάνετε τίποτα.
- Ελέγξτε το pointer tag
- Εάν το chunk είναι `mmaped`, `munmap` it και αυτό είναι όλο
- Αν όχι, προσθέστε το color και καλέστε `_int_free` πάνω του

<details>

<summary>__lib_free code</summary>
```c
void
__libc_free (void *mem)
{
mstate ar_ptr;
mchunkptr p;                          /* chunk corresponding to mem */

if (mem == 0)                              /* free(0) has no effect */
return;

/* Quickly check that the freed pointer matches the tag for the memory.
This gives a useful double-free detection.  */
if (__glibc_unlikely (mtag_enabled))
*(volatile char *)mem;

int err = errno;

p = mem2chunk (mem);

if (chunk_is_mmapped (p))                       /* release mmapped memory. */
{
/* See if the dynamic brk/mmap threshold needs adjusting.
Dumped fake mmapped chunks do not affect the threshold.  */
if (!mp_.no_dyn_threshold
&& chunksize_nomask (p) > mp_.mmap_threshold
&& chunksize_nomask (p) <= DEFAULT_MMAP_THRESHOLD_MAX)
{
mp_.mmap_threshold = chunksize (p);
mp_.trim_threshold = 2 * mp_.mmap_threshold;
LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,
mp_.mmap_threshold, mp_.trim_threshold);
}
munmap_chunk (p);
}
else
{
MAYBE_INIT_TCACHE ();

/* Mark the chunk as belonging to the library again.  */
(void)tag_region (chunk2mem (p), memsize (p));

ar_ptr = arena_for_chunk (p);
_int_free (ar_ptr, p, 0);
}

__set_errno (err);
}
libc_hidden_def (__libc_free)
```
</details>

## _int_free <a href="#int_free" id="int_free"></a>

### _int_free start <a href="#int_free" id="int_free"></a>

Ξεκινά με κάποιους ελέγχους που εξασφαλίζουν:

- ο **pointer** είναι **aligned,** αλλιώς προκαλεί σφάλμα `free(): invalid pointer`
- το **size** να μην είναι μικρότερο από το ελάχιστο και το **size** να είναι επίσης **aligned**, αλλιώς προκαλεί σφάλμα: `free(): invalid size`

<details>

<summary>_int_free start</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4493C1-L4513C28

#define aligned_OK(m) (((unsigned long) (m) &MALLOC_ALIGN_MASK) == 0)

static void
_int_free (mstate av, mchunkptr p, int have_lock)
{
INTERNAL_SIZE_T size;        /* its size */
mfastbinptr *fb;             /* associated fastbin */

size = chunksize (p);

/* Little security check which won't hurt performance: the
allocator never wraps around at the end of the address space.
Therefore we can exclude some size values which might appear
here by accident or by "design" from some intruder.  */
if (__builtin_expect ((uintptr_t) p > (uintptr_t) -size, 0)
|| __builtin_expect (misaligned_chunk (p), 0))
malloc_printerr ("free(): invalid pointer");
/* We know that each chunk is at least MINSIZE bytes in size or a
multiple of MALLOC_ALIGNMENT.  */
if (__glibc_unlikely (size < MINSIZE || !aligned_OK (size)))
malloc_printerr ("free(): invalid size");

check_inuse_chunk(av, p);
```
</details>

### _int_free tcache <a href="#int_free" id="int_free"></a>

Θα προσπαθήσει πρώτα να τοποθετήσει αυτό το chunk στο σχετικό tcache. Ωστόσο, προηγουμένως εκτελούνται κάποιοι έλεγχοι. Θα διατρέξει όλα τα chunks του tcache στο ίδιο index με το freed chunk και:

- Αν υπάρχουν περισσότερες εγγραφές από το `mp_.tcache_count`: `free(): too many chunks detected in tcache`
- Αν η εγγραφή δεν είναι ευθυγραμμισμένη: free(): `unaligned chunk detected in tcache 2`
- Αν το freed chunk είχε ήδη απελευθερωθεί και υπάρχει ως chunk στο tcache: `free(): double free detected in tcache 2`

Εάν όλα πάνε καλά, το chunk προστίθεται στο tcache και η συνάρτηση επιστρέφει.

<details>

<summary>_int_free tcache</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4515C1-L4554C7
#if USE_TCACHE
{
size_t tc_idx = csize2tidx (size);
if (tcache != NULL && tc_idx < mp_.tcache_bins)
{
/* Check to see if it's already in the tcache.  */
tcache_entry *e = (tcache_entry *) chunk2mem (p);

/* This test succeeds on double free.  However, we don't 100%
trust it (it also matches random payload data at a 1 in
2^<size_t> chance), so verify it's not an unlikely
coincidence before aborting.  */
if (__glibc_unlikely (e->key == tcache_key))
{
tcache_entry *tmp;
size_t cnt = 0;
LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
for (tmp = tcache->entries[tc_idx];
tmp;
tmp = REVEAL_PTR (tmp->next), ++cnt)
{
if (cnt >= mp_.tcache_count)
malloc_printerr ("free(): too many chunks detected in tcache");
if (__glibc_unlikely (!aligned_OK (tmp)))
malloc_printerr ("free(): unaligned chunk detected in tcache 2");
if (tmp == e)
malloc_printerr ("free(): double free detected in tcache 2");
/* If we get here, it was a coincidence.  We've wasted a
few cycles, but don't abort.  */
}
}

if (tcache->counts[tc_idx] < mp_.tcache_count)
{
tcache_put (p, tc_idx);
return;
}
}
}
#endif
```
</details>

### _int_free fast bin <a href="#int_free" id="int_free"></a>

Ξεκινήστε ελέγχοντας ότι το μέγεθος είναι κατάλληλο για fast bin και ελέγξτε αν είναι δυνατό να το τοποθετήσετε κοντά στο top chunk.

Στη συνέχεια, προσθέστε το freed chunk στην κορυφή του fast bin ενώ εκτελείτε μερικούς ελέγχους:

- Εάν το μέγεθος του chunk είναι άκυρο (πολύ μεγάλο ή πολύ μικρό) προκαλείται: `free(): invalid next size (fast)`
- Εάν το προστιθέμενο chunk ήταν ήδη το top του fast bin: `double free or corruption (fasttop)`
- Εάν το μέγεθος του chunk στην κορυφή έχει διαφορετικό μέγεθος από το chunk που προσθέτουμε: `invalid fastbin entry (free)`

<details>

<summary>_int_free Fast Bin</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4556C2-L4631C4

/*
If eligible, place chunk on a fastbin so it can be found
and used quickly in malloc.
*/

if ((unsigned long)(size) <= (unsigned long)(get_max_fast ())

#if TRIM_FASTBINS
/*
If TRIM_FASTBINS set, don't place chunks
bordering top into fastbins
*/
&& (chunk_at_offset(p, size) != av->top)
#endif
) {

if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))
<= CHUNK_HDR_SZ, 0)
|| __builtin_expect (chunksize (chunk_at_offset (p, size))
>= av->system_mem, 0))
{
bool fail = true;
/* We might not have a lock at this point and concurrent modifications
of system_mem might result in a false positive.  Redo the test after
getting the lock.  */
if (!have_lock)
{
__libc_lock_lock (av->mutex);
fail = (chunksize_nomask (chunk_at_offset (p, size)) <= CHUNK_HDR_SZ
|| chunksize (chunk_at_offset (p, size)) >= av->system_mem);
__libc_lock_unlock (av->mutex);
}

if (fail)
malloc_printerr ("free(): invalid next size (fast)");
}

free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);

atomic_store_relaxed (&av->have_fastchunks, true);
unsigned int idx = fastbin_index(size);
fb = &fastbin (av, idx);

/* Atomically link P to its fastbin: P->FD = *FB; *FB = P;  */
mchunkptr old = *fb, old2;

if (SINGLE_THREAD_P)
{
/* Check that the top of the bin is not the record we are going to
add (i.e., double free).  */
if (__builtin_expect (old == p, 0))
malloc_printerr ("double free or corruption (fasttop)");
p->fd = PROTECT_PTR (&p->fd, old);
*fb = p;
}
else
do
{
/* Check that the top of the bin is not the record we are going to
add (i.e., double free).  */
if (__builtin_expect (old == p, 0))
malloc_printerr ("double free or corruption (fasttop)");
old2 = old;
p->fd = PROTECT_PTR (&p->fd, old);
}
while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))
!= old2);

/* Check that size of fastbin chunk at the top is the same as
size of the chunk that we are adding.  We can dereference OLD
only if we have the lock, otherwise it might have already been
allocated again.  */
if (have_lock && old != NULL
&& __builtin_expect (fastbin_index (chunksize (old)) != idx, 0))
malloc_printerr ("invalid fastbin entry (free)");
}
```
</details>

### _int_free τελική φάση <a href="#int_free" id="int_free"></a>

Εάν το chunk δεν είχε ακόμη εκχωρηθεί σε κανένα bin, καλέστε `_int_free_merge_chunk`

<details>

<summary>_int_free τελική φάση</summary>
```c
/*
Consolidate other non-mmapped chunks as they arrive.
*/

else if (!chunk_is_mmapped(p)) {

/* If we're single-threaded, don't lock the arena.  */
if (SINGLE_THREAD_P)
have_lock = true;

if (!have_lock)
__libc_lock_lock (av->mutex);

_int_free_merge_chunk (av, p, size);

if (!have_lock)
__libc_lock_unlock (av->mutex);
}
/*
If the chunk was allocated via mmap, release via munmap().
*/

else {
munmap_chunk (p);
}
}
```
</details>

## _int_free_merge_chunk

Αυτή η συνάρτηση θα προσπαθήσει να συγχωνεύσει το chunk P των SIZE bytes με τους γείτονές του. Το προκύπτον chunk τοποθετείται στη λίστα unsorted bin.

Γίνονται ορισμένοι έλεγχοι:

- Αν το chunk είναι το top chunk: `double free or corruption (top)`
- Αν το επόμενο chunk βρίσκεται εκτός των ορίων του arena: `double free or corruption (out)`
- Αν το chunk δεν είναι σημειωμένο ως χρησιμοποιημένο (στο `prev_inuse` από το επόμενο chunk): `double free or corruption (!prev)`
- Αν το επόμενο chunk έχει πολύ μικρό ή πολύ μεγάλο μέγεθος: `free(): invalid next size (normal)`
- Αν το προηγούμενο chunk δεν είναι σε χρήση, θα προσπαθήσει να ενοποιήσει. Όμως, αν το `prev_size` διαφέρει από το μέγεθος που δηλώνεται στο προηγούμενο chunk: `corrupted size vs. prev_size while consolidating`

<details>

<summary>_int_free_merge_chunk code</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4660C1-L4702C2

/* Try to merge chunk P of SIZE bytes with its neighbors.  Put the
resulting chunk on the appropriate bin list.  P must not be on a
bin list yet, and it can be in use.  */
static void
_int_free_merge_chunk (mstate av, mchunkptr p, INTERNAL_SIZE_T size)
{
mchunkptr nextchunk = chunk_at_offset(p, size);

/* Lightweight tests: check whether the block is already the
top block.  */
if (__glibc_unlikely (p == av->top))
malloc_printerr ("double free or corruption (top)");
/* Or whether the next chunk is beyond the boundaries of the arena.  */
if (__builtin_expect (contiguous (av)
&& (char *) nextchunk
>= ((char *) av->top + chunksize(av->top)), 0))
malloc_printerr ("double free or corruption (out)");
/* Or whether the block is actually not marked used.  */
if (__glibc_unlikely (!prev_inuse(nextchunk)))
malloc_printerr ("double free or corruption (!prev)");

INTERNAL_SIZE_T nextsize = chunksize(nextchunk);
if (__builtin_expect (chunksize_nomask (nextchunk) <= CHUNK_HDR_SZ, 0)
|| __builtin_expect (nextsize >= av->system_mem, 0))
malloc_printerr ("free(): invalid next size (normal)");

free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);

/* Consolidate backward.  */
if (!prev_inuse(p))
{
INTERNAL_SIZE_T prevsize = prev_size (p);
size += prevsize;
p = chunk_at_offset(p, -((long) prevsize));
if (__glibc_unlikely (chunksize(p) != prevsize))
malloc_printerr ("corrupted size vs. prev_size while consolidating");
unlink_chunk (av, p);
}

/* Write the chunk header, maybe after merging with the following chunk.  */
size = _int_free_create_chunk (av, p, size, nextchunk, nextsize);
_int_free_maybe_consolidate (av, size);
}
```
</details>

---

## Σημειώσεις επιτιθέμενου και πρόσφατες αλλαγές (2023–2025)

- Safe-Linking in tcache/fastbins: `free()` αποθηκεύει τον δείκτη `fd` των μονοσυνδεδεμένων λιστών χρησιμοποιώντας το macro `PROTECT_PTR(pos, ptr) = ((size_t)pos >> 12) ^ (size_t)ptr`. Αυτό σημαίνει ότι το στήσιμο ενός ψεύτικου δείκτη next για tcache poisoning απαιτεί από τον attacker να γνωρίζει μια διεύθυνση heap (π.χ., leak `chunk_addr`, και στη συνέχεια να χρησιμοποιήσει το `chunk_addr >> 12` ως κλειδί XOR). Δείτε περισσότερες λεπτομέρειες και PoCs στη σελίδα tcache παρακάτω.
- Tcache double-free detection: Πριν ωθήσει ένα chunk στο tcache, το `free()` ελέγχει το per-entry `e->key` σε σχέση με το per-thread `tcache_key` και διασχίζει το bin έως το `mp_.tcache_count` αναζητώντας διπλότυπα, τερματίζοντας με `free(): double free detected in tcache 2` όταν βρεθούν.
- Recent glibc change (2.42): Το tcache επεκτάθηκε ώστε να δέχεται πολύ μεγαλύτερα chunks, ελεγχόμενα από το νέο `glibc.malloc.tcache_max_bytes` tunable. Το `free()` τώρα θα προσπαθεί να cache-άρει freed chunks μέχρι αυτό το byte όριο (mmapped chunks δεν αποθηκεύονται). Αυτό μειώνει τη συχνότητα με την οποία τα free καταλήγουν σε unsorted/small/large bins σε σύγχρονα συστήματα.

### Quick crafting of a safe-linked fd (for tcache poisoning)
```py
# Given a leaked heap pointer to an entry located at &entry->next == POS
# compute the protected fd that points to TARGET
protected_fd = TARGET ^ (POS >> 12)
```
- Για έναν πλήρη οδηγό βήμα-βήμα για tcache poisoning (και τους περιορισμούς του υπό safe-linking), δείτε:

{{#ref}}
../tcache-bin-attack.md
{{#endref}}

### Αναγκάζοντας τα frees να χτυπήσουν unsorted/small bins κατά την έρευνα

Μερικές φορές θέλετε να αποφύγετε εντελώς το tcache σε ένα τοπικό εργαστήριο για να παρατηρήσετε την κλασική συμπεριφορά του `_int_free` (unsorted bin consolidation, κ.λπ.). Μπορείτε να το κάνετε αυτό με GLIBC_TUNABLES:
```bash
# Disable tcache completely
GLIBC_TUNABLES=glibc.malloc.tcache_count=0 ./vuln

# Pre-2.42: shrink the maximum cached request size to 0
GLIBC_TUNABLES=glibc.malloc.tcache_max=0 ./vuln

# 2.42+: cap the new large-cache threshold (bytes)
GLIBC_TUNABLES=glibc.malloc.tcache_max_bytes=0 ./vuln
```
Σχετική ανάγνωση στο HackTricks:

- First-fit/unsorted συμπεριφορά και overlap tricks:

{{#ref}}
../use-after-free/first-fit.md
{{#endref}}

- Double-free primitives και σύγχρονοι έλεγχοι:

{{#ref}}
../double-free.md
{{#endref}}

> Προειδοποίηση για hooks: Οι κλασικές τεχνικές επανεγγραφής `__malloc_hook`/`__free_hook` δεν είναι εφαρμόσιμες στη σύγχρονη glibc (≥ 2.34). Αν τις βλέπετε ακόμα σε παλαιότερα write-ups, προσαρμόστε σε εναλλακτικούς στόχους (IO_FILE, exit handlers, vtables, κ.λπ.). Για υπόβαθρο, δείτε τη σελίδα για hooks στο HackTricks.

{{#ref}}
../../arbitrary-write-2-exec/aw2exec-__malloc_hook.md
{{#endref}}

## Αναφορές

- GNU C Library – NEWS for 2.42 (allocator: μεγαλύτερο tcache μέσω tcache_max_bytes, mmapped chunks δεν αποθηκεύονται στην cache) <https://www.gnu.org/software/libc/NEWS.html#2.42>
- Εξήγηση και εσωτερικά του Safe-Linking (Red Hat Developer, 2020) <https://developers.redhat.com/articles/2020/05/13/new-security-hardening-gnu-c-library>

{{#include ../../../banners/hacktricks-training.md}}
