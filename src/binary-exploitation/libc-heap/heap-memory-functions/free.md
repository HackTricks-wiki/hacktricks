# free

{{#include ../../../banners/hacktricks-training.md}}

## Free - Podsumowanie kolejności <a href="#libc_free" id="libc_free"></a>

(W tym podsumowaniu nie wyjaśniono żadnych kontroli i niektóre przypadki zostały pominięte dla zwięzłości)

1. Jeśli adres jest Null (0) nic nie rób
2. Jeśli chunk był mmaped, wywołaj munmap i zakończ
3. Wywołaj `_int_free`:
   1. Jeśli to możliwe, dodaj chunk do tcache
   2. Jeśli to możliwe, dodaj chunk do fast bin
   3. Wywołaj `_int_free_merge_chunk`, aby scalić chunk jeśli to konieczne i dodać go do unsorted list

> Uwaga: Począwszy od glibc 2.42, krok tcache może również przyjmować chunky o znacznie większym progu rozmiaru (zobacz “Recent glibc changes” poniżej). To zmienia, kiedy free trafia do tcache vs. unsorted/small/large bins.

## __libc_free <a href="#libc_free" id="libc_free"></a>

`Free` wywołuje `__libc_free`.

- Jeśli przekazany adres jest Null (0), nic nie rób.
- Sprawdź znacznik wskaźnika
- Jeśli chunk jest `mmaped`, wywołaj `munmap` i to wszystko
- Jeśli nie, dodaj kolor i wywołaj `_int_free` na nim

<details>

<summary>__lib_free kod</summary>
```c
void
__libc_free (void *mem)
{
mstate ar_ptr;
mchunkptr p;                          /* chunk corresponding to mem */

if (mem == 0)                              /* free(0) has no effect */
return;

/* Quickly check that the freed pointer matches the tag for the memory.
This gives a useful double-free detection.  */
if (__glibc_unlikely (mtag_enabled))
*(volatile char *)mem;

int err = errno;

p = mem2chunk (mem);

if (chunk_is_mmapped (p))                       /* release mmapped memory. */
{
/* See if the dynamic brk/mmap threshold needs adjusting.
Dumped fake mmapped chunks do not affect the threshold.  */
if (!mp_.no_dyn_threshold
&& chunksize_nomask (p) > mp_.mmap_threshold
&& chunksize_nomask (p) <= DEFAULT_MMAP_THRESHOLD_MAX)
{
mp_.mmap_threshold = chunksize (p);
mp_.trim_threshold = 2 * mp_.mmap_threshold;
LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,
mp_.mmap_threshold, mp_.trim_threshold);
}
munmap_chunk (p);
}
else
{
MAYBE_INIT_TCACHE ();

/* Mark the chunk as belonging to the library again.  */
(void)tag_region (chunk2mem (p), memsize (p));

ar_ptr = arena_for_chunk (p);
_int_free (ar_ptr, p, 0);
}

__set_errno (err);
}
libc_hidden_def (__libc_free)
```
</details>

## _int_free <a href="#int_free" id="int_free"></a>

### _int_free początek <a href="#int_free" id="int_free"></a>

Rozpoczyna się od kilku kontroli sprawdzających:

- że **wskaźnik** jest **wyrównany**, w przeciwnym razie błąd `free(): invalid pointer`
- że **rozmiar** nie jest mniejszy od minimum oraz że **rozmiar** jest również **wyrównany**, w przeciwnym razie błąd: `free(): invalid size`

<details>

<summary>_int_free początek</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4493C1-L4513C28

#define aligned_OK(m) (((unsigned long) (m) &MALLOC_ALIGN_MASK) == 0)

static void
_int_free (mstate av, mchunkptr p, int have_lock)
{
INTERNAL_SIZE_T size;        /* its size */
mfastbinptr *fb;             /* associated fastbin */

size = chunksize (p);

/* Little security check which won't hurt performance: the
allocator never wraps around at the end of the address space.
Therefore we can exclude some size values which might appear
here by accident or by "design" from some intruder.  */
if (__builtin_expect ((uintptr_t) p > (uintptr_t) -size, 0)
|| __builtin_expect (misaligned_chunk (p), 0))
malloc_printerr ("free(): invalid pointer");
/* We know that each chunk is at least MINSIZE bytes in size or a
multiple of MALLOC_ALIGNMENT.  */
if (__glibc_unlikely (size < MINSIZE || !aligned_OK (size)))
malloc_printerr ("free(): invalid size");

check_inuse_chunk(av, p);
```
</details>

### _int_free tcache <a href="#int_free" id="int_free"></a>

Najpierw spróbuje alokować ten chunk w powiązanym tcache. Jednak wcześniej wykonywane są pewne sprawdzenia. Przejdzie w pętli przez wszystkie chunks tcache o tym samym indeksie co zwalniany chunk i:

- Jeśli jest więcej wpisów niż `mp_.tcache_count`: `free(): too many chunks detected in tcache`
- Jeśli wpis nie jest wyrównany: free(): `unaligned chunk detected in tcache 2`
- Jeśli zwalniany chunk został już zwolniony i jest obecny jako chunk w tcache: `free(): double free detected in tcache 2`

Jeśli wszystko pójdzie dobrze, chunk zostaje dodany do tcache i funkcja zwraca.

<details>

<summary>_int_free tcache</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4515C1-L4554C7
#if USE_TCACHE
{
size_t tc_idx = csize2tidx (size);
if (tcache != NULL && tc_idx < mp_.tcache_bins)
{
/* Check to see if it's already in the tcache.  */
tcache_entry *e = (tcache_entry *) chunk2mem (p);

/* This test succeeds on double free.  However, we don't 100%
trust it (it also matches random payload data at a 1 in
2^<size_t> chance), so verify it's not an unlikely
coincidence before aborting.  */
if (__glibc_unlikely (e->key == tcache_key))
{
tcache_entry *tmp;
size_t cnt = 0;
LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
for (tmp = tcache->entries[tc_idx];
tmp;
tmp = REVEAL_PTR (tmp->next), ++cnt)
{
if (cnt >= mp_.tcache_count)
malloc_printerr ("free(): too many chunks detected in tcache");
if (__glibc_unlikely (!aligned_OK (tmp)))
malloc_printerr ("free(): unaligned chunk detected in tcache 2");
if (tmp == e)
malloc_printerr ("free(): double free detected in tcache 2");
/* If we get here, it was a coincidence.  We've wasted a
few cycles, but don't abort.  */
}
}

if (tcache->counts[tc_idx] < mp_.tcache_count)
{
tcache_put (p, tc_idx);
return;
}
}
}
#endif
```
</details>

### _int_free fast bin <a href="#int_free" id="int_free"></a>

Najpierw sprawdź, czy rozmiar jest odpowiedni dla fast bin oraz czy można go ustawić blisko top chunk.

Następnie dodaj zwolniony chunk na szczycie fast bin, wykonując kilka kontroli:

- Jeśli rozmiar chunka jest nieprawidłowy (za duży lub za mały), spowoduje to: `free(): invalid next size (fast)`
- Jeśli dodany chunk był już top of the fast bin: `double free or corruption (fasttop)`
- Jeśli rozmiar chunka na topie różni się od rozmiaru chunka, który dodajemy: `invalid fastbin entry (free)`

<details>

<summary>_int_free Fast Bin</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4556C2-L4631C4

/*
If eligible, place chunk on a fastbin so it can be found
and used quickly in malloc.
*/

if ((unsigned long)(size) <= (unsigned long)(get_max_fast ())

#if TRIM_FASTBINS
/*
If TRIM_FASTBINS set, don't place chunks
bordering top into fastbins
*/
&& (chunk_at_offset(p, size) != av->top)
#endif
) {

if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))
<= CHUNK_HDR_SZ, 0)
|| __builtin_expect (chunksize (chunk_at_offset (p, size))
>= av->system_mem, 0))
{
bool fail = true;
/* We might not have a lock at this point and concurrent modifications
of system_mem might result in a false positive.  Redo the test after
getting the lock.  */
if (!have_lock)
{
__libc_lock_lock (av->mutex);
fail = (chunksize_nomask (chunk_at_offset (p, size)) <= CHUNK_HDR_SZ
|| chunksize (chunk_at_offset (p, size)) >= av->system_mem);
__libc_lock_unlock (av->mutex);
}

if (fail)
malloc_printerr ("free(): invalid next size (fast)");
}

free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);

atomic_store_relaxed (&av->have_fastchunks, true);
unsigned int idx = fastbin_index(size);
fb = &fastbin (av, idx);

/* Atomically link P to its fastbin: P->FD = *FB; *FB = P;  */
mchunkptr old = *fb, old2;

if (SINGLE_THREAD_P)
{
/* Check that the top of the bin is not the record we are going to
add (i.e., double free).  */
if (__builtin_expect (old == p, 0))
malloc_printerr ("double free or corruption (fasttop)");
p->fd = PROTECT_PTR (&p->fd, old);
*fb = p;
}
else
do
{
/* Check that the top of the bin is not the record we are going to
add (i.e., double free).  */
if (__builtin_expect (old == p, 0))
malloc_printerr ("double free or corruption (fasttop)");
old2 = old;
p->fd = PROTECT_PTR (&p->fd, old);
}
while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))
!= old2);

/* Check that size of fastbin chunk at the top is the same as
size of the chunk that we are adding.  We can dereference OLD
only if we have the lock, otherwise it might have already been
allocated again.  */
if (have_lock && old != NULL
&& __builtin_expect (fastbin_index (chunksize (old)) != idx, 0))
malloc_printerr ("invalid fastbin entry (free)");
}
```
</details>

### _int_free finał <a href="#int_free" id="int_free"></a>

Jeśli chunk nie został jeszcze zaalokowany w żadnym binie, wywołaj `_int_free_merge_chunk`

<details>

<summary>_int_free finał</summary>
```c
/*
Consolidate other non-mmapped chunks as they arrive.
*/

else if (!chunk_is_mmapped(p)) {

/* If we're single-threaded, don't lock the arena.  */
if (SINGLE_THREAD_P)
have_lock = true;

if (!have_lock)
__libc_lock_lock (av->mutex);

_int_free_merge_chunk (av, p, size);

if (!have_lock)
__libc_lock_unlock (av->mutex);
}
/*
If the chunk was allocated via mmap, release via munmap().
*/

else {
munmap_chunk (p);
}
}
```
</details>

## _int_free_merge_chunk

Ta funkcja spróbuje scalić chunk P o rozmiarze SIZE bajtów ze swoimi sąsiadami. Umieści powstały chunk na liście unsorted bin.

Wykonywane są następujące sprawdzenia:

- Jeśli chunk jest top chunk: `double free or corruption (top)`
- Jeśli następny chunk znajduje się poza granicami arena: `double free or corruption (out)`
- Jeśli chunk nie jest oznaczony jako użyty (w `prev_inuse` z następującego chunk): `double free or corruption (!prev)`
- Jeśli następny chunk ma zbyt mały lub zbyt duży rozmiar: `free(): invalid next size (normal)`
- Jeśli poprzedni chunk nie jest w użyciu, funkcja spróbuje je scalić. Jednak jeśli `prev_size` różni się od rozmiaru wskazanego w poprzednim chunku: `corrupted size vs. prev_size while consolidating`

<details>

<summary>_int_free_merge_chunk code</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4660C1-L4702C2

/* Try to merge chunk P of SIZE bytes with its neighbors.  Put the
resulting chunk on the appropriate bin list.  P must not be on a
bin list yet, and it can be in use.  */
static void
_int_free_merge_chunk (mstate av, mchunkptr p, INTERNAL_SIZE_T size)
{
mchunkptr nextchunk = chunk_at_offset(p, size);

/* Lightweight tests: check whether the block is already the
top block.  */
if (__glibc_unlikely (p == av->top))
malloc_printerr ("double free or corruption (top)");
/* Or whether the next chunk is beyond the boundaries of the arena.  */
if (__builtin_expect (contiguous (av)
&& (char *) nextchunk
>= ((char *) av->top + chunksize(av->top)), 0))
malloc_printerr ("double free or corruption (out)");
/* Or whether the block is actually not marked used.  */
if (__glibc_unlikely (!prev_inuse(nextchunk)))
malloc_printerr ("double free or corruption (!prev)");

INTERNAL_SIZE_T nextsize = chunksize(nextchunk);
if (__builtin_expect (chunksize_nomask (nextchunk) <= CHUNK_HDR_SZ, 0)
|| __builtin_expect (nextsize >= av->system_mem, 0))
malloc_printerr ("free(): invalid next size (normal)");

free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);

/* Consolidate backward.  */
if (!prev_inuse(p))
{
INTERNAL_SIZE_T prevsize = prev_size (p);
size += prevsize;
p = chunk_at_offset(p, -((long) prevsize));
if (__glibc_unlikely (chunksize(p) != prevsize))
malloc_printerr ("corrupted size vs. prev_size while consolidating");
unlink_chunk (av, p);
}

/* Write the chunk header, maybe after merging with the following chunk.  */
size = _int_free_create_chunk (av, p, size, nextchunk, nextsize);
_int_free_maybe_consolidate (av, size);
}
```
</details>

---

## Notatki atakującego i ostatnie zmiany (2023–2025)

- Safe-Linking w tcache/fastbins: `free()` przechowuje wskaźnik `fd` jednowiązanych list używając makra `PROTECT_PTR(pos, ptr) = ((size_t)pos >> 12) ^ (size_t)ptr`. Oznacza to, że spreparowanie fałszywego następnego wskaźnika dla tcache poisoning wymaga od atakującego znajomości adresu na heapie (np. leak `chunk_addr`, a następnie użyć `chunk_addr >> 12` jako klucza XOR). Zobacz więcej szczegółów i PoCs na stronie tcache poniżej.
- Tcache double-free detection: Zanim wrzuci chunk do tcache, `free()` porównuje per-entry `e->key` z per-thread `tcache_key` i przeszukuje bin aż do `mp_.tcache_count` w poszukiwaniu duplikatów, kończąc działanie z komunikatem `free(): double free detected in tcache 2` jeśli znajdzie duplikat.
- Niedawna zmiana w glibc (2.42): tcache został rozszerzony, by akceptować znacznie większe chunki, kontrolowane przez nowy tunable `glibc.malloc.tcache_max_bytes`. `free()` będzie teraz próbować cachować zwolnione chunki aż do tego limitu bajtów (mmapped chunks nie są cached). To zmniejsza częstotliwość, z jaką zwolnienia trafiają do unsorted/small/large bins na nowoczesnych systemach.

### Szybkie przygotowanie safe-linked fd (dla tcache poisoning)
```py
# Given a leaked heap pointer to an entry located at &entry->next == POS
# compute the protected fd that points to TARGET
protected_fd = TARGET ^ (POS >> 12)
```
- Dla pełnego tcache poisoning walkthrough (i jego ograniczeń w ramach safe-linking), zobacz:

{{#ref}}
../tcache-bin-attack.md
{{#endref}}

### Zmuszanie free, aby trafić do unsorted/small bins podczas badań

Czasami chcesz całkowicie ominąć tcache w lokalnym laboratorium, aby zaobserwować klasyczne zachowanie `_int_free` (unsorted bin consolidation itp.). Możesz to zrobić za pomocą GLIBC_TUNABLES:
```bash
# Disable tcache completely
GLIBC_TUNABLES=glibc.malloc.tcache_count=0 ./vuln

# Pre-2.42: shrink the maximum cached request size to 0
GLIBC_TUNABLES=glibc.malloc.tcache_max=0 ./vuln

# 2.42+: cap the new large-cache threshold (bytes)
GLIBC_TUNABLES=glibc.malloc.tcache_max_bytes=0 ./vuln
```
Powiązana lektura w HackTricks:

- First-fit/unsorted behaviour and overlap tricks:

{{#ref}}
../use-after-free/first-fit.md
{{#endref}}

- Double-free primitives and modern checks:

{{#ref}}
../double-free.md
{{#endref}}

> Uwaga o hooks: Klasyczne techniki nadpisywania `__malloc_hook`/`__free_hook` nie są możliwe w nowoczesnym glibc (≥ 2.34). Jeśli nadal widzisz je w starszych opisach, dostosuj się do alternatywnych celów (IO_FILE, exit handlers, vtables, etc.). Po szczegóły sprawdź stronę o hooks w HackTricks.

{{#ref}}
../../arbitrary-write-2-exec/aw2exec-__malloc_hook.md
{{#endref}}

## Źródła

- GNU C Library – NEWS for 2.42 (allocator: larger tcache via tcache_max_bytes, mmapped chunks are not cached) <https://www.gnu.org/software/libc/NEWS.html#2.42>
- Wyjaśnienie i wewnętrzne mechanizmy Safe-Linking (Red Hat Developer, 2020) <https://developers.redhat.com/articles/2020/05/13/new-security-hardening-gnu-c-library>

{{#include ../../../banners/hacktricks-training.md}}
