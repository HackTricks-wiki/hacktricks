# free

{{#include ../../../banners/hacktricks-training.md}}

## Free İşlem Sıralaması Özeti <a href="#libc_free" id="libc_free"></a>

(Bu özet içinde kontroller açıklanmamıştır ve bazı durumlar kısalık amacıyla atlanmıştır)

1. Eğer adres null ise hiçbir şey yapma
2. Eğer chunk mmaped ise, munmap et ve bitir
3. `_int_free` çağır:
1. Mümkünse chunk'ı tcache'e ekle
2. Mümkünse chunk'ı fast bin'e ekle
3. Gerekirse chunk'ı birleştirmek için `_int_free_merge_chunk` çağır ve unsorted listeye ekle

> Note: glibc 2.42 ile başlayarak, tcache adımı çok daha büyük bir boyut eşiğine kadar chunk'ları da kabul edebilir (bkz. “Recent glibc changes” aşağıda). Bu, bir free'in tcache'e mi yoksa unsorted/small/large binlerine mi düştüğünü değiştirir.

## __libc_free <a href="#libc_free" id="libc_free"></a>

`Free` `__libc_free`'i çağırır.

- Eğer geçirilen adres Null (0) ise hiçbir şey yapma.
- Pointer tag'ini kontrol et
- Eğer chunk `mmaped` ise, `munmap` et ve hepsi bu
- Değilse, color'ı ekle ve üzerinde `_int_free` çağır

<details>

<summary>__lib_free code</summary>
```c
void
__libc_free (void *mem)
{
mstate ar_ptr;
mchunkptr p;                          /* chunk corresponding to mem */

if (mem == 0)                              /* free(0) has no effect */
return;

/* Quickly check that the freed pointer matches the tag for the memory.
This gives a useful double-free detection.  */
if (__glibc_unlikely (mtag_enabled))
*(volatile char *)mem;

int err = errno;

p = mem2chunk (mem);

if (chunk_is_mmapped (p))                       /* release mmapped memory. */
{
/* See if the dynamic brk/mmap threshold needs adjusting.
Dumped fake mmapped chunks do not affect the threshold.  */
if (!mp_.no_dyn_threshold
&& chunksize_nomask (p) > mp_.mmap_threshold
&& chunksize_nomask (p) <= DEFAULT_MMAP_THRESHOLD_MAX)
{
mp_.mmap_threshold = chunksize (p);
mp_.trim_threshold = 2 * mp_.mmap_threshold;
LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,
mp_.mmap_threshold, mp_.trim_threshold);
}
munmap_chunk (p);
}
else
{
MAYBE_INIT_TCACHE ();

/* Mark the chunk as belonging to the library again.  */
(void)tag_region (chunk2mem (p), memsize (p));

ar_ptr = arena_for_chunk (p);
_int_free (ar_ptr, p, 0);
}

__set_errno (err);
}
libc_hidden_def (__libc_free)
```
</details>

## _int_free <a href="#int_free" id="int_free"></a>

### _int_free start <a href="#int_free" id="int_free"></a>

Bazı kontrollerle başlar ve şu durumları doğrular:

- **pointer**'ın **aligned** olduğundan emin olur, aksi halde `free(): invalid pointer` hatası tetiklenir
- **size**'ın minimumdan küçük olmadığını ve ayrıca **size**'ın **aligned** olduğunu doğrular, aksi halde `free(): invalid size` hatası tetiklenir

<details>

<summary>_int_free start</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4493C1-L4513C28

#define aligned_OK(m) (((unsigned long) (m) &MALLOC_ALIGN_MASK) == 0)

static void
_int_free (mstate av, mchunkptr p, int have_lock)
{
INTERNAL_SIZE_T size;        /* its size */
mfastbinptr *fb;             /* associated fastbin */

size = chunksize (p);

/* Little security check which won't hurt performance: the
allocator never wraps around at the end of the address space.
Therefore we can exclude some size values which might appear
here by accident or by "design" from some intruder.  */
if (__builtin_expect ((uintptr_t) p > (uintptr_t) -size, 0)
|| __builtin_expect (misaligned_chunk (p), 0))
malloc_printerr ("free(): invalid pointer");
/* We know that each chunk is at least MINSIZE bytes in size or a
multiple of MALLOC_ALIGNMENT.  */
if (__glibc_unlikely (size < MINSIZE || !aligned_OK (size)))
malloc_printerr ("free(): invalid size");

check_inuse_chunk(av, p);
```
</details>

### _int_free tcache <a href="#int_free" id="int_free"></a>

Önce bu chunk'ı ilgili tcache içinde allocate etmeye çalışır. Ancak, bazı kontroller önceden gerçekleştirilir. Serbest bırakılan chunk ile aynı indeksteki tcache içindeki tüm chunk'lar üzerinde döner ve:

- Eğer `mp_.tcache_count`'ten daha fazla giriş varsa: `free(): too many chunks detected in tcache`
- Eğer giriş hizalı değilse: free(): `unaligned chunk detected in tcache 2`
- Eğer serbest bırakılan chunk zaten serbest bırakıldıysa ve tcache'de chunk olarak mevcutsa: `free(): double free detected in tcache 2`

Her şey yolunda giderse, chunk tcache'e eklenir ve fonksiyon döner.

<details>

<summary>_int_free tcache</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4515C1-L4554C7
#if USE_TCACHE
{
size_t tc_idx = csize2tidx (size);
if (tcache != NULL && tc_idx < mp_.tcache_bins)
{
/* Check to see if it's already in the tcache.  */
tcache_entry *e = (tcache_entry *) chunk2mem (p);

/* This test succeeds on double free.  However, we don't 100%
trust it (it also matches random payload data at a 1 in
2^<size_t> chance), so verify it's not an unlikely
coincidence before aborting.  */
if (__glibc_unlikely (e->key == tcache_key))
{
tcache_entry *tmp;
size_t cnt = 0;
LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
for (tmp = tcache->entries[tc_idx];
tmp;
tmp = REVEAL_PTR (tmp->next), ++cnt)
{
if (cnt >= mp_.tcache_count)
malloc_printerr ("free(): too many chunks detected in tcache");
if (__glibc_unlikely (!aligned_OK (tmp)))
malloc_printerr ("free(): unaligned chunk detected in tcache 2");
if (tmp == e)
malloc_printerr ("free(): double free detected in tcache 2");
/* If we get here, it was a coincidence.  We've wasted a
few cycles, but don't abort.  */
}
}

if (tcache->counts[tc_idx] < mp_.tcache_count)
{
tcache_put (p, tc_idx);
return;
}
}
}
#endif
```
</details>

### _int_free fast bin <a href="#int_free" id="int_free"></a>

Öncelikle boyutun fast bin için uygun olup olmadığını ve onu top chunk'a yakın şekilde ayarlamanın mümkün olup olmadığını kontrol edin.

Sonra, serbest bırakılan chunk'ı fast bin'in en üstüne ekleyin ve bazı kontroller yapın:

- Eğer chunk'ın boyutu geçersizse (çok büyük veya küçük): `free(): invalid next size (fast)`
- Eğer eklenen chunk zaten fast bin'in en üstündeyse: `double free or corruption (fasttop)`
- Eğer en üstteki chunk'ın boyutu eklemeye çalıştığımız chunk'ın boyutundan farklıysa: `invalid fastbin entry (free)`

<details>

<summary>_int_free Fast Bin</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4556C2-L4631C4

/*
If eligible, place chunk on a fastbin so it can be found
and used quickly in malloc.
*/

if ((unsigned long)(size) <= (unsigned long)(get_max_fast ())

#if TRIM_FASTBINS
/*
If TRIM_FASTBINS set, don't place chunks
bordering top into fastbins
*/
&& (chunk_at_offset(p, size) != av->top)
#endif
) {

if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))
<= CHUNK_HDR_SZ, 0)
|| __builtin_expect (chunksize (chunk_at_offset (p, size))
>= av->system_mem, 0))
{
bool fail = true;
/* We might not have a lock at this point and concurrent modifications
of system_mem might result in a false positive.  Redo the test after
getting the lock.  */
if (!have_lock)
{
__libc_lock_lock (av->mutex);
fail = (chunksize_nomask (chunk_at_offset (p, size)) <= CHUNK_HDR_SZ
|| chunksize (chunk_at_offset (p, size)) >= av->system_mem);
__libc_lock_unlock (av->mutex);
}

if (fail)
malloc_printerr ("free(): invalid next size (fast)");
}

free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);

atomic_store_relaxed (&av->have_fastchunks, true);
unsigned int idx = fastbin_index(size);
fb = &fastbin (av, idx);

/* Atomically link P to its fastbin: P->FD = *FB; *FB = P;  */
mchunkptr old = *fb, old2;

if (SINGLE_THREAD_P)
{
/* Check that the top of the bin is not the record we are going to
add (i.e., double free).  */
if (__builtin_expect (old == p, 0))
malloc_printerr ("double free or corruption (fasttop)");
p->fd = PROTECT_PTR (&p->fd, old);
*fb = p;
}
else
do
{
/* Check that the top of the bin is not the record we are going to
add (i.e., double free).  */
if (__builtin_expect (old == p, 0))
malloc_printerr ("double free or corruption (fasttop)");
old2 = old;
p->fd = PROTECT_PTR (&p->fd, old);
}
while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))
!= old2);

/* Check that size of fastbin chunk at the top is the same as
size of the chunk that we are adding.  We can dereference OLD
only if we have the lock, otherwise it might have already been
allocated again.  */
if (have_lock && old != NULL
&& __builtin_expect (fastbin_index (chunksize (old)) != idx, 0))
malloc_printerr ("invalid fastbin entry (free)");
}
```
</details>

### _int_free sonu <a href="#int_free" id="int_free"></a>

Eğer chunk henüz herhangi bir bin'de ayrılmamışsa, `_int_free_merge_chunk` çağrılır

<details>

<summary>_int_free sonu</summary>
```c
/*
Consolidate other non-mmapped chunks as they arrive.
*/

else if (!chunk_is_mmapped(p)) {

/* If we're single-threaded, don't lock the arena.  */
if (SINGLE_THREAD_P)
have_lock = true;

if (!have_lock)
__libc_lock_lock (av->mutex);

_int_free_merge_chunk (av, p, size);

if (!have_lock)
__libc_lock_unlock (av->mutex);
}
/*
If the chunk was allocated via mmap, release via munmap().
*/

else {
munmap_chunk (p);
}
}
```
</details>

## _int_free_merge_chunk

Bu fonksiyon, SIZE baytlık P chunk'ını komşularıyla birleştirmeye çalışır. Ortaya çıkan chunk unsorted bin listesine konur.

Bazı kontroller yapılır:

- Eğer chunk top chunk ise: `double free or corruption (top)`
- Eğer sonraki chunk arena sınırları dışındaysa: `double free or corruption (out)`
- Eğer chunk kullanılan olarak işaretlenmemişse (sonraki chunk içindeki `prev_inuse`): `double free or corruption (!prev)`
- Eğer sonraki chunk çok küçük veya çok büyük bir boyuta sahipse: `free(): invalid next size (normal)`
- Eğer önceki chunk kullanımda değilse, birleştirmeye çalışır. Ancak, `prev_size` önceki chunk'ta belirtilen boyuttan farklıysa: `corrupted size vs. prev_size while consolidating`

<details>

<summary>_int_free_merge_chunk code</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4660C1-L4702C2

/* Try to merge chunk P of SIZE bytes with its neighbors.  Put the
resulting chunk on the appropriate bin list.  P must not be on a
bin list yet, and it can be in use.  */
static void
_int_free_merge_chunk (mstate av, mchunkptr p, INTERNAL_SIZE_T size)
{
mchunkptr nextchunk = chunk_at_offset(p, size);

/* Lightweight tests: check whether the block is already the
top block.  */
if (__glibc_unlikely (p == av->top))
malloc_printerr ("double free or corruption (top)");
/* Or whether the next chunk is beyond the boundaries of the arena.  */
if (__builtin_expect (contiguous (av)
&& (char *) nextchunk
>= ((char *) av->top + chunksize(av->top)), 0))
malloc_printerr ("double free or corruption (out)");
/* Or whether the block is actually not marked used.  */
if (__glibc_unlikely (!prev_inuse(nextchunk)))
malloc_printerr ("double free or corruption (!prev)");

INTERNAL_SIZE_T nextsize = chunksize(nextchunk);
if (__builtin_expect (chunksize_nomask (nextchunk) <= CHUNK_HDR_SZ, 0)
|| __builtin_expect (nextsize >= av->system_mem, 0))
malloc_printerr ("free(): invalid next size (normal)");

free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);

/* Consolidate backward.  */
if (!prev_inuse(p))
{
INTERNAL_SIZE_T prevsize = prev_size (p);
size += prevsize;
p = chunk_at_offset(p, -((long) prevsize));
if (__glibc_unlikely (chunksize(p) != prevsize))
malloc_printerr ("corrupted size vs. prev_size while consolidating");
unlink_chunk (av, p);
}

/* Write the chunk header, maybe after merging with the following chunk.  */
size = _int_free_create_chunk (av, p, size, nextchunk, nextsize);
_int_free_maybe_consolidate (av, size);
}
```
</details>

---

## Saldırgan notları ve son değişiklikler (2023–2025)

- Safe-Linking in tcache/fastbins: `free()` stores the `fd` pointer of singly-linked lists using the macro `PROTECT_PTR(pos, ptr) = ((size_t)pos >> 12) ^ (size_t)ptr`. Bu, tcache zehirlemesi için sahte bir sonraki işaretçisi hazırlamanın saldırganın bir heap adresini bilmesini gerektirdiği anlamına gelir (ör. leak `chunk_addr`, sonra XOR anahtarı olarak `chunk_addr >> 12` kullanın). Daha fazla ayrıntı ve PoCs için aşağıdaki tcache sayfasına bakın.
- Tcache double-free detection: Bir chunk'ı tcache'e itmeden önce, `free()` her girişin `e->key`'ini per-thread `tcache_key` ile kontrol eder ve kopyaları aramak için `mp_.tcache_count` kadar bin'de gezerek çoğaltmaları arar; bulunduğunda `free(): double free detected in tcache 2` ile abort eder.
- Recent glibc change (2.42): tcache, yeni `glibc.malloc.tcache_max_bytes` ayarıyla kontrol edilen çok daha büyük chunk'ları kabul edecek şekilde büyüdü. `free()` artık freed edilmiş chunk'ları (mmapped chunk'lar cachelenmez) bu byte sınırına kadar cachelemeye çalışacaktır. Bu, modern sistemlerde free'ların unsorted/small/large bin'lere düşme sıklığını azaltır.

### Quick crafting of a safe-linked fd (for tcache poisoning)
```py
# Given a leaked heap pointer to an entry located at &entry->next == POS
# compute the protected fd that points to TARGET
protected_fd = TARGET ^ (POS >> 12)
```
- Tam bir tcache poisoning walkthrough (ve safe-linking altındaki sınırları) için bakınız:

{{#ref}}
../tcache-bin-attack.md
{{#endref}}

### Araştırma sırasında frees'in unsorted/small bins'e düşmesini zorlamak

Bazen yerel bir laboratuvarda klasik `_int_free` davranışını (unsorted bin consolidation, vb.) gözlemlemek için tcache'i tamamen devre dışı bırakmak istersiniz. Bunu GLIBC_TUNABLES ile yapabilirsiniz:
```bash
# Disable tcache completely
GLIBC_TUNABLES=glibc.malloc.tcache_count=0 ./vuln

# Pre-2.42: shrink the maximum cached request size to 0
GLIBC_TUNABLES=glibc.malloc.tcache_max=0 ./vuln

# 2.42+: cap the new large-cache threshold (bytes)
GLIBC_TUNABLES=glibc.malloc.tcache_max_bytes=0 ./vuln
```
HackTricks içinde ilgili okuma:

- First-fit/unsorted davranışı ve overlap hileleri:

{{#ref}}
../use-after-free/first-fit.md
{{#endref}}

- Double-free primitive'leri ve modern kontroller:

{{#ref}}
../double-free.md
{{#endref}}

> Hooks konusunda uyarı: Klasik `__malloc_hook`/`__free_hook` overwrite teknikleri modern glibc (≥ 2.34) üzerinde geçerli değil. Eğer eski yazılarda hâlâ görüyorsanız, alternatif hedeflere uyarlayın (IO_FILE, exit handlers, vtables, vb.). Arka plan için HackTricks'teki hooks sayfasına bakın.

{{#ref}}
../../arbitrary-write-2-exec/aw2exec-__malloc_hook.md
{{#endref}}

## Referanslar

- GNU C Library – 2.42 için NEWS (allocator: larger tcache via tcache_max_bytes, mmapped chunks are not cached) <https://www.gnu.org/software/libc/NEWS.html#2.42>
- Safe-Linking açıklaması ve iç yapısı (Red Hat Developer, 2020) <https://developers.redhat.com/articles/2020/05/13/new-security-hardening-gnu-c-library>

{{#include ../../../banners/hacktricks-training.md}}
