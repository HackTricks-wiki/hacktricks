# free

{{#include ../../../banners/hacktricks-training.md}}

## Free Reihenfolgeübersicht <a href="#libc_free" id="libc_free"></a>

(In dieser Zusammenfassung werden keine Checks erklärt und einige Fälle wurden der Kürze halber ausgelassen)

1. Wenn die Adresse null ist, nichts tun
2. Wenn der Chunk `mmaped` war, rufe `munmap` auf und fertig
3. Rufe `_int_free` auf:
   1. Falls möglich, füge den Chunk dem tcache hinzu
   2. Falls möglich, füge den Chunk dem fast bin hinzu
   3. Rufe `_int_free_merge_chunk` auf, um den Chunk bei Bedarf zu konsolidieren und füge ihn der unsorted list hinzu

> Hinweis: Ab glibc 2.42 kann der tcache-Schritt auch Chunks bis zu einer deutlich größeren Größen-Schwelle aufnehmen (siehe “Recent glibc changes” below). Dies ändert, wann ein free im tcache vs. unsorted/small/large bins landet.

## __libc_free <a href="#libc_free" id="libc_free"></a>

`Free` ruft `__libc_free` auf.

- Wenn die übergebene Adresse Null (0) ist, nichts tun.
- Pointer-Tag überprüfen
- Wenn der Chunk `mmaped` ist, rufe `munmap` auf und das war's
- Falls nicht, die Farbe hinzufügen und `_int_free` darauf aufrufen

<details>

<summary>__lib_free Code</summary>
```c
void
__libc_free (void *mem)
{
mstate ar_ptr;
mchunkptr p;                          /* chunk corresponding to mem */

if (mem == 0)                              /* free(0) has no effect */
return;

/* Quickly check that the freed pointer matches the tag for the memory.
This gives a useful double-free detection.  */
if (__glibc_unlikely (mtag_enabled))
*(volatile char *)mem;

int err = errno;

p = mem2chunk (mem);

if (chunk_is_mmapped (p))                       /* release mmapped memory. */
{
/* See if the dynamic brk/mmap threshold needs adjusting.
Dumped fake mmapped chunks do not affect the threshold.  */
if (!mp_.no_dyn_threshold
&& chunksize_nomask (p) > mp_.mmap_threshold
&& chunksize_nomask (p) <= DEFAULT_MMAP_THRESHOLD_MAX)
{
mp_.mmap_threshold = chunksize (p);
mp_.trim_threshold = 2 * mp_.mmap_threshold;
LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,
mp_.mmap_threshold, mp_.trim_threshold);
}
munmap_chunk (p);
}
else
{
MAYBE_INIT_TCACHE ();

/* Mark the chunk as belonging to the library again.  */
(void)tag_region (chunk2mem (p), memsize (p));

ar_ptr = arena_for_chunk (p);
_int_free (ar_ptr, p, 0);
}

__set_errno (err);
}
libc_hidden_def (__libc_free)
```
</details>

## _int_free <a href="#int_free" id="int_free"></a>

### _int_free start <a href="#int_free" id="int_free"></a>

Es beginnt mit einigen Prüfungen, die sicherstellen:

- der **Zeiger** ist **ausgerichtet,** oder löst den Fehler `free(): invalid pointer` aus
- die **Größe** ist nicht kleiner als das Minimum und die **Größe** ist ebenfalls **ausgerichtet,** oder löst den Fehler: `free(): invalid size` aus

<details>

<summary>_int_free start</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4493C1-L4513C28

#define aligned_OK(m) (((unsigned long) (m) &MALLOC_ALIGN_MASK) == 0)

static void
_int_free (mstate av, mchunkptr p, int have_lock)
{
INTERNAL_SIZE_T size;        /* its size */
mfastbinptr *fb;             /* associated fastbin */

size = chunksize (p);

/* Little security check which won't hurt performance: the
allocator never wraps around at the end of the address space.
Therefore we can exclude some size values which might appear
here by accident or by "design" from some intruder.  */
if (__builtin_expect ((uintptr_t) p > (uintptr_t) -size, 0)
|| __builtin_expect (misaligned_chunk (p), 0))
malloc_printerr ("free(): invalid pointer");
/* We know that each chunk is at least MINSIZE bytes in size or a
multiple of MALLOC_ALIGNMENT.  */
if (__glibc_unlikely (size < MINSIZE || !aligned_OK (size)))
malloc_printerr ("free(): invalid size");

check_inuse_chunk(av, p);
```
</details>

### _int_free tcache <a href="#int_free" id="int_free"></a>

Zuerst versucht es, diesen Chunk im zugehörigen tcache zu platzieren. Allerdings werden vorher einige Überprüfungen durchgeführt. Es durchläuft alle Chunks des tcache im selben Index wie der freigegebene Chunk und:

- Wenn mehr Einträge vorhanden sind als `mp_.tcache_count`: `free(): too many chunks detected in tcache`
- Wenn der Eintrag nicht ausgerichtet ist: free(): `unaligned chunk detected in tcache 2`
- Wenn der Chunk bereits freigegeben wurde und als Chunk im tcache vorhanden ist: `free(): double free detected in tcache 2`

Wenn alles gut läuft, wird der Chunk dem tcache hinzugefügt und die Funktion kehrt zurück.

<details>

<summary>_int_free tcache</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4515C1-L4554C7
#if USE_TCACHE
{
size_t tc_idx = csize2tidx (size);
if (tcache != NULL && tc_idx < mp_.tcache_bins)
{
/* Check to see if it's already in the tcache.  */
tcache_entry *e = (tcache_entry *) chunk2mem (p);

/* This test succeeds on double free.  However, we don't 100%
trust it (it also matches random payload data at a 1 in
2^<size_t> chance), so verify it's not an unlikely
coincidence before aborting.  */
if (__glibc_unlikely (e->key == tcache_key))
{
tcache_entry *tmp;
size_t cnt = 0;
LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
for (tmp = tcache->entries[tc_idx];
tmp;
tmp = REVEAL_PTR (tmp->next), ++cnt)
{
if (cnt >= mp_.tcache_count)
malloc_printerr ("free(): too many chunks detected in tcache");
if (__glibc_unlikely (!aligned_OK (tmp)))
malloc_printerr ("free(): unaligned chunk detected in tcache 2");
if (tmp == e)
malloc_printerr ("free(): double free detected in tcache 2");
/* If we get here, it was a coincidence.  We've wasted a
few cycles, but don't abort.  */
}
}

if (tcache->counts[tc_idx] < mp_.tcache_count)
{
tcache_put (p, tc_idx);
return;
}
}
}
#endif
```
</details>

### _int_free fast bin <a href="#int_free" id="int_free"></a>

Beginnen Sie damit, zu prüfen, ob die Größe für fast bin geeignet ist und ob es möglich ist, sie in die Nähe des top chunk zu setzen.

Fügen Sie dann den freigegebenen chunk oben in den fast bin ein und führen Sie dabei einige Prüfungen durch:

- Wenn die Größe des chunk ungültig ist (zu groß oder zu klein), wird ausgelöst: `free(): invalid next size (fast)`
- Wenn der hinzugefügte chunk bereits der top chunk des fast bin war: `double free or corruption (fasttop)`
- Wenn die Größe des chunks am top von der Größe des hinzuzufügenden chunks abweicht: `invalid fastbin entry (free)`

<details>

<summary>_int_free Fast Bin</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4556C2-L4631C4

/*
If eligible, place chunk on a fastbin so it can be found
and used quickly in malloc.
*/

if ((unsigned long)(size) <= (unsigned long)(get_max_fast ())

#if TRIM_FASTBINS
/*
If TRIM_FASTBINS set, don't place chunks
bordering top into fastbins
*/
&& (chunk_at_offset(p, size) != av->top)
#endif
) {

if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))
<= CHUNK_HDR_SZ, 0)
|| __builtin_expect (chunksize (chunk_at_offset (p, size))
>= av->system_mem, 0))
{
bool fail = true;
/* We might not have a lock at this point and concurrent modifications
of system_mem might result in a false positive.  Redo the test after
getting the lock.  */
if (!have_lock)
{
__libc_lock_lock (av->mutex);
fail = (chunksize_nomask (chunk_at_offset (p, size)) <= CHUNK_HDR_SZ
|| chunksize (chunk_at_offset (p, size)) >= av->system_mem);
__libc_lock_unlock (av->mutex);
}

if (fail)
malloc_printerr ("free(): invalid next size (fast)");
}

free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);

atomic_store_relaxed (&av->have_fastchunks, true);
unsigned int idx = fastbin_index(size);
fb = &fastbin (av, idx);

/* Atomically link P to its fastbin: P->FD = *FB; *FB = P;  */
mchunkptr old = *fb, old2;

if (SINGLE_THREAD_P)
{
/* Check that the top of the bin is not the record we are going to
add (i.e., double free).  */
if (__builtin_expect (old == p, 0))
malloc_printerr ("double free or corruption (fasttop)");
p->fd = PROTECT_PTR (&p->fd, old);
*fb = p;
}
else
do
{
/* Check that the top of the bin is not the record we are going to
add (i.e., double free).  */
if (__builtin_expect (old == p, 0))
malloc_printerr ("double free or corruption (fasttop)");
old2 = old;
p->fd = PROTECT_PTR (&p->fd, old);
}
while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))
!= old2);

/* Check that size of fastbin chunk at the top is the same as
size of the chunk that we are adding.  We can dereference OLD
only if we have the lock, otherwise it might have already been
allocated again.  */
if (have_lock && old != NULL
&& __builtin_expect (fastbin_index (chunksize (old)) != idx, 0))
malloc_printerr ("invalid fastbin entry (free)");
}
```
</details>

### _int_free Abschluss <a href="#int_free" id="int_free"></a>

Wenn der Chunk noch in keinem Bin alloziert wurde, rufe `_int_free_merge_chunk` auf

<details>

<summary>_int_free Abschluss</summary>
```c
/*
Consolidate other non-mmapped chunks as they arrive.
*/

else if (!chunk_is_mmapped(p)) {

/* If we're single-threaded, don't lock the arena.  */
if (SINGLE_THREAD_P)
have_lock = true;

if (!have_lock)
__libc_lock_lock (av->mutex);

_int_free_merge_chunk (av, p, size);

if (!have_lock)
__libc_lock_unlock (av->mutex);
}
/*
If the chunk was allocated via mmap, release via munmap().
*/

else {
munmap_chunk (p);
}
}
```
</details>

## _int_free_merge_chunk

Diese Funktion versucht, Chunk P der Größe SIZE Bytes mit seinen Nachbarn zusammenzuführen. Legt den resultierenden Chunk auf die unsorted bin list.

Es werden einige Überprüfungen durchgeführt:

- Wenn der chunk der top chunk ist: `double free or corruption (top)`
- Wenn der nächste chunk außerhalb der Grenzen der arena liegt: `double free or corruption (out)`
- Wenn der chunk nicht als in Gebrauch markiert ist (im `prev_inuse` des folgenden chunks): `double free or corruption (!prev)`
- Wenn der nächste chunk eine zu kleine oder zu große Größe hat: `free(): invalid next size (normal)`
- Wenn der vorherige chunk nicht in Gebrauch ist, wird versucht zu konsolidieren. Wenn jedoch prev_size von der im vorherigen chunk angegebenen Größe abweicht: `corrupted size vs. prev_size while consolidating`

<details>

<summary>_int_free_merge_chunk code</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4660C1-L4702C2

/* Try to merge chunk P of SIZE bytes with its neighbors.  Put the
resulting chunk on the appropriate bin list.  P must not be on a
bin list yet, and it can be in use.  */
static void
_int_free_merge_chunk (mstate av, mchunkptr p, INTERNAL_SIZE_T size)
{
mchunkptr nextchunk = chunk_at_offset(p, size);

/* Lightweight tests: check whether the block is already the
top block.  */
if (__glibc_unlikely (p == av->top))
malloc_printerr ("double free or corruption (top)");
/* Or whether the next chunk is beyond the boundaries of the arena.  */
if (__builtin_expect (contiguous (av)
&& (char *) nextchunk
>= ((char *) av->top + chunksize(av->top)), 0))
malloc_printerr ("double free or corruption (out)");
/* Or whether the block is actually not marked used.  */
if (__glibc_unlikely (!prev_inuse(nextchunk)))
malloc_printerr ("double free or corruption (!prev)");

INTERNAL_SIZE_T nextsize = chunksize(nextchunk);
if (__builtin_expect (chunksize_nomask (nextchunk) <= CHUNK_HDR_SZ, 0)
|| __builtin_expect (nextsize >= av->system_mem, 0))
malloc_printerr ("free(): invalid next size (normal)");

free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);

/* Consolidate backward.  */
if (!prev_inuse(p))
{
INTERNAL_SIZE_T prevsize = prev_size (p);
size += prevsize;
p = chunk_at_offset(p, -((long) prevsize));
if (__glibc_unlikely (chunksize(p) != prevsize))
malloc_printerr ("corrupted size vs. prev_size while consolidating");
unlink_chunk (av, p);
}

/* Write the chunk header, maybe after merging with the following chunk.  */
size = _int_free_create_chunk (av, p, size, nextchunk, nextsize);
_int_free_maybe_consolidate (av, size);
}
```
</details>

---

## Anmerkungen für Angreifer und jüngste Änderungen (2023–2025)

- Safe-Linking in tcache/fastbins: `free()` speichert den `fd` pointer von einfach verketteten Listen unter Verwendung des Makros `PROTECT_PTR(pos, ptr) = ((size_t)pos >> 12) ^ (size_t)ptr`. Das bedeutet, dass das Erstellen eines gefälschten next-Pointers für tcache poisoning vom Angreifer verlangt, eine Heap-Adresse zu kennen (z. B. leak `chunk_addr`, dann `chunk_addr >> 12` als XOR-Schlüssel zu verwenden). Weitere Details und PoCs siehe die tcache-Seite unten.
- Tcache double-free detection: Bevor ein Chunk in tcache geschoben wird, überprüft `free()` das pro-Eintrag `e->key` gegen das pro-Thread `tcache_key` und durchläuft das bin bis zu `mp_.tcache_count`, um Duplikate zu finden, und bricht mit `free(): double free detected in tcache 2` ab, wenn eines gefunden wird.
- Jüngste glibc-Änderung (2.42): Der tcache wurde erweitert, um deutlich größere Chunks zu akzeptieren, gesteuert durch das neue `glibc.malloc.tcache_max_bytes` tunable. `free()` versucht nun, freigegebene Chunks bis zu diesem Byte-Limit zu cachen (mmapped chunks werden nicht gecached). Das reduziert, wie oft frees auf modernen Systemen in unsorted/small/large bins fallen.

### Quick crafting of a safe-linked fd (for tcache poisoning)
```py
# Given a leaked heap pointer to an entry located at &entry->next == POS
# compute the protected fd that points to TARGET
protected_fd = TARGET ^ (POS >> 12)
```
- Für eine vollständige tcache poisoning walkthrough (und deren Grenzen unter safe-linking), siehe:

{{#ref}}
../tcache-bin-attack.md
{{#endref}}

### Frees dazu zwingen, während der Forschung unsorted/small bins zu treffen

Manchmal möchte man tcache in einem lokalen Labor vollständig vermeiden, um das klassische `_int_free`-Verhalten (unsorted bin consolidation, etc.) zu beobachten. Das kann man mit GLIBC_TUNABLES:
```bash
# Disable tcache completely
GLIBC_TUNABLES=glibc.malloc.tcache_count=0 ./vuln

# Pre-2.42: shrink the maximum cached request size to 0
GLIBC_TUNABLES=glibc.malloc.tcache_max=0 ./vuln

# 2.42+: cap the new large-cache threshold (bytes)
GLIBC_TUNABLES=glibc.malloc.tcache_max_bytes=0 ./vuln
```
Weiterführende Lektüre in HackTricks:

- First-fit/unsorted behaviour and overlap tricks:

{{#ref}}
../use-after-free/first-fit.md
{{#endref}}

- Double-free primitives and modern checks:

{{#ref}}
../double-free.md
{{#endref}}

> Hinweis zu hooks: Klassische `__malloc_hook`/`__free_hook` overwrite techniques sind in modernen glibc (≥ 2.34) nicht mehr praktikabel. Wenn du sie noch in älteren write-ups siehst, passe sie an alternative targets an (IO_FILE, exit handlers, vtables, etc.). Für Hintergrundinformationen siehe die Seite zu hooks in HackTricks.
>
> {{#ref}}
../../arbitrary-write-2-exec/aw2exec-__malloc_hook.md
{{#endref}}

## Referenzen

- GNU C Library – NEWS for 2.42 (allocator: larger tcache via tcache_max_bytes, mmapped chunks are not cached) <https://www.gnu.org/software/libc/NEWS.html#2.42>
- Safe-Linking explanation and internals (Red Hat Developer, 2020) <https://developers.redhat.com/articles/2020/05/13/new-security-hardening-gnu-c-library>

{{#include ../../../banners/hacktricks-training.md}}
