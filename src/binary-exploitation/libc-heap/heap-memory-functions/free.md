# free

{{#include ../../../banners/hacktricks-training.md}}

## Free の処理順の概要 <a href="#libc_free" id="libc_free"></a>

(この概要ではチェックは説明しておらず、いくつかのケースは簡略化のため省略されています)

1. アドレスが null の場合は何もしない
2. チャンクが mmaped の場合、munmap して終了
3. `_int_free` を呼ぶ:
1. 可能ならチャンクを tcache に追加する
2. 可能ならチャンクを fast bin に追加する
3. `_int_free_merge_chunk` を呼んでチャンクを統合（必要であれば）し、unsorted list に追加する

> Note: Starting with glibc 2.42, the tcache step can also take chunks up to a much larger size threshold (see “Recent glibc changes” below). This changes when a free lands in tcache vs. unsorted/small/large bins.

## __libc_free <a href="#libc_free" id="libc_free"></a>

`Free` は `__libc_free` を呼ぶ。

- 渡されたアドレスが Null (0) の場合は何もしない。
- ポインタタグをチェックする。
- チャンクが `mmaped` であれば `munmap` し、それでおしまい。
- そうでなければ、color を追加して `_int_free` を呼び出す。

<details>

<summary>__lib_free コード</summary>
```c
void
__libc_free (void *mem)
{
mstate ar_ptr;
mchunkptr p;                          /* chunk corresponding to mem */

if (mem == 0)                              /* free(0) has no effect */
return;

/* Quickly check that the freed pointer matches the tag for the memory.
This gives a useful double-free detection.  */
if (__glibc_unlikely (mtag_enabled))
*(volatile char *)mem;

int err = errno;

p = mem2chunk (mem);

if (chunk_is_mmapped (p))                       /* release mmapped memory. */
{
/* See if the dynamic brk/mmap threshold needs adjusting.
Dumped fake mmapped chunks do not affect the threshold.  */
if (!mp_.no_dyn_threshold
&& chunksize_nomask (p) > mp_.mmap_threshold
&& chunksize_nomask (p) <= DEFAULT_MMAP_THRESHOLD_MAX)
{
mp_.mmap_threshold = chunksize (p);
mp_.trim_threshold = 2 * mp_.mmap_threshold;
LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,
mp_.mmap_threshold, mp_.trim_threshold);
}
munmap_chunk (p);
}
else
{
MAYBE_INIT_TCACHE ();

/* Mark the chunk as belonging to the library again.  */
(void)tag_region (chunk2mem (p), memsize (p));

ar_ptr = arena_for_chunk (p);
_int_free (ar_ptr, p, 0);
}

__set_errno (err);
}
libc_hidden_def (__libc_free)
```
</details>

## _int_free <a href="#int_free" id="int_free"></a>

### _int_free 開始 <a href="#int_free" id="int_free"></a>

最初に次のチェックを行います:

- **pointer** が **aligned** であること（そうでないと `free(): invalid pointer` エラー）
- **size** が最小値以上であり、かつ **size** が **aligned** であること（満たさない場合は `free(): invalid size` エラー）

<details>

<summary>_int_free 開始</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4493C1-L4513C28

#define aligned_OK(m) (((unsigned long) (m) &MALLOC_ALIGN_MASK) == 0)

static void
_int_free (mstate av, mchunkptr p, int have_lock)
{
INTERNAL_SIZE_T size;        /* its size */
mfastbinptr *fb;             /* associated fastbin */

size = chunksize (p);

/* Little security check which won't hurt performance: the
allocator never wraps around at the end of the address space.
Therefore we can exclude some size values which might appear
here by accident or by "design" from some intruder.  */
if (__builtin_expect ((uintptr_t) p > (uintptr_t) -size, 0)
|| __builtin_expect (misaligned_chunk (p), 0))
malloc_printerr ("free(): invalid pointer");
/* We know that each chunk is at least MINSIZE bytes in size or a
multiple of MALLOC_ALIGNMENT.  */
if (__glibc_unlikely (size < MINSIZE || !aligned_OK (size)))
malloc_printerr ("free(): invalid size");

check_inuse_chunk(av, p);
```
</details>

### _int_free tcache <a href="#int_free" id="int_free"></a>

最初にこのチャンクを関連する tcache に割り当てようとします。ただし、事前にいくつかのチェックが実行されます。解放されたチャンクと同じインデックスにある tcache のすべてのチャンクを順に確認し、以下を行います:

- エントリ数が `mp_.tcache_count` より多い場合: `free(): too many chunks detected in tcache`
- エントリがアラインされていない場合: free(): `unaligned chunk detected in tcache 2`
- 解放されたチャンクが既に tcache にチャンクとして存在する場合: `free(): double free detected in tcache 2`

問題がなければ、チャンクは tcache に追加され、関数は戻ります。

<details>

<summary>_int_free tcache</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4515C1-L4554C7
#if USE_TCACHE
{
size_t tc_idx = csize2tidx (size);
if (tcache != NULL && tc_idx < mp_.tcache_bins)
{
/* Check to see if it's already in the tcache.  */
tcache_entry *e = (tcache_entry *) chunk2mem (p);

/* This test succeeds on double free.  However, we don't 100%
trust it (it also matches random payload data at a 1 in
2^<size_t> chance), so verify it's not an unlikely
coincidence before aborting.  */
if (__glibc_unlikely (e->key == tcache_key))
{
tcache_entry *tmp;
size_t cnt = 0;
LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
for (tmp = tcache->entries[tc_idx];
tmp;
tmp = REVEAL_PTR (tmp->next), ++cnt)
{
if (cnt >= mp_.tcache_count)
malloc_printerr ("free(): too many chunks detected in tcache");
if (__glibc_unlikely (!aligned_OK (tmp)))
malloc_printerr ("free(): unaligned chunk detected in tcache 2");
if (tmp == e)
malloc_printerr ("free(): double free detected in tcache 2");
/* If we get here, it was a coincidence.  We've wasted a
few cycles, but don't abort.  */
}
}

if (tcache->counts[tc_idx] < mp_.tcache_count)
{
tcache_put (p, tc_idx);
return;
}
}
}
#endif
```
</details>

### _int_free fast bin <a href="#int_free" id="int_free"></a>

まず、サイズが fast bin に適しているか、そして top chunk の近くに設定できるかを確認してください。

次に、いくつかのチェックを行いながら、freed chunk を fast bin のトップに追加します:

- chunk のサイズが無効（大きすぎる、または小さすぎる）場合、次が発生します: `free(): invalid next size (fast)`
- 追加しようとしている chunk がすでに fast bin のトップだった場合: `double free or corruption (fasttop)`
- top にある chunk のサイズが追加しようとしている chunk と異なる場合: `invalid fastbin entry (free)`

<details>

<summary>_int_free Fast Bin</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4556C2-L4631C4

/*
If eligible, place chunk on a fastbin so it can be found
and used quickly in malloc.
*/

if ((unsigned long)(size) <= (unsigned long)(get_max_fast ())

#if TRIM_FASTBINS
/*
If TRIM_FASTBINS set, don't place chunks
bordering top into fastbins
*/
&& (chunk_at_offset(p, size) != av->top)
#endif
) {

if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))
<= CHUNK_HDR_SZ, 0)
|| __builtin_expect (chunksize (chunk_at_offset (p, size))
>= av->system_mem, 0))
{
bool fail = true;
/* We might not have a lock at this point and concurrent modifications
of system_mem might result in a false positive.  Redo the test after
getting the lock.  */
if (!have_lock)
{
__libc_lock_lock (av->mutex);
fail = (chunksize_nomask (chunk_at_offset (p, size)) <= CHUNK_HDR_SZ
|| chunksize (chunk_at_offset (p, size)) >= av->system_mem);
__libc_lock_unlock (av->mutex);
}

if (fail)
malloc_printerr ("free(): invalid next size (fast)");
}

free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);

atomic_store_relaxed (&av->have_fastchunks, true);
unsigned int idx = fastbin_index(size);
fb = &fastbin (av, idx);

/* Atomically link P to its fastbin: P->FD = *FB; *FB = P;  */
mchunkptr old = *fb, old2;

if (SINGLE_THREAD_P)
{
/* Check that the top of the bin is not the record we are going to
add (i.e., double free).  */
if (__builtin_expect (old == p, 0))
malloc_printerr ("double free or corruption (fasttop)");
p->fd = PROTECT_PTR (&p->fd, old);
*fb = p;
}
else
do
{
/* Check that the top of the bin is not the record we are going to
add (i.e., double free).  */
if (__builtin_expect (old == p, 0))
malloc_printerr ("double free or corruption (fasttop)");
old2 = old;
p->fd = PROTECT_PTR (&p->fd, old);
}
while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))
!= old2);

/* Check that size of fastbin chunk at the top is the same as
size of the chunk that we are adding.  We can dereference OLD
only if we have the lock, otherwise it might have already been
allocated again.  */
if (have_lock && old != NULL
&& __builtin_expect (fastbin_index (chunksize (old)) != idx, 0))
malloc_printerr ("invalid fastbin entry (free)");
}
```
</details>

### _int_free 最終処理 <a href="#int_free" id="int_free"></a>

チャンクがまだどの bin にも割り当てられていない場合、`_int_free_merge_chunk` を呼び出す

<details>

<summary>_int_free 最終処理</summary>
```c
/*
Consolidate other non-mmapped chunks as they arrive.
*/

else if (!chunk_is_mmapped(p)) {

/* If we're single-threaded, don't lock the arena.  */
if (SINGLE_THREAD_P)
have_lock = true;

if (!have_lock)
__libc_lock_lock (av->mutex);

_int_free_merge_chunk (av, p, size);

if (!have_lock)
__libc_lock_unlock (av->mutex);
}
/*
If the chunk was allocated via mmap, release via munmap().
*/

else {
munmap_chunk (p);
}
}
```
</details>

## _int_free_merge_chunk

この関数は、SIZEバイトのチャンクPを隣接するチャンクとマージしようとします。結果のチャンクをunsorted binリストに置きます。

いくつかのチェックが行われます:

- If the chunk is the top chunk: `double free or corruption (top)`
- If the next chunk is outside of the boundaries of the arena: `double free or corruption (out)`
- If the chunk is not marked as used (in the `prev_inuse` from the following chunk): `double free or corruption (!prev)`
- If the next chunk has a too little size or too big: `free(): invalid next size (normal)`
- if the previous chunk is not in use, it will try to consolidate. But, if the prev_size differs from the size indicated in the previous chunk: `corrupted size vs. prev_size while consolidating`

<details>

<summary>_int_free_merge_chunk code</summary>
```c
// From https://github.com/bminor/glibc/blob/f942a732d37a96217ef828116ebe64a644db18d7/malloc/malloc.c#L4660C1-L4702C2

/* Try to merge chunk P of SIZE bytes with its neighbors.  Put the
resulting chunk on the appropriate bin list.  P must not be on a
bin list yet, and it can be in use.  */
static void
_int_free_merge_chunk (mstate av, mchunkptr p, INTERNAL_SIZE_T size)
{
mchunkptr nextchunk = chunk_at_offset(p, size);

/* Lightweight tests: check whether the block is already the
top block.  */
if (__glibc_unlikely (p == av->top))
malloc_printerr ("double free or corruption (top)");
/* Or whether the next chunk is beyond the boundaries of the arena.  */
if (__builtin_expect (contiguous (av)
&& (char *) nextchunk
>= ((char *) av->top + chunksize(av->top)), 0))
malloc_printerr ("double free or corruption (out)");
/* Or whether the block is actually not marked used.  */
if (__glibc_unlikely (!prev_inuse(nextchunk)))
malloc_printerr ("double free or corruption (!prev)");

INTERNAL_SIZE_T nextsize = chunksize(nextchunk);
if (__builtin_expect (chunksize_nomask (nextchunk) <= CHUNK_HDR_SZ, 0)
|| __builtin_expect (nextsize >= av->system_mem, 0))
malloc_printerr ("free(): invalid next size (normal)");

free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);

/* Consolidate backward.  */
if (!prev_inuse(p))
{
INTERNAL_SIZE_T prevsize = prev_size (p);
size += prevsize;
p = chunk_at_offset(p, -((long) prevsize));
if (__glibc_unlikely (chunksize(p) != prevsize))
malloc_printerr ("corrupted size vs. prev_size while consolidating");
unlink_chunk (av, p);
}

/* Write the chunk header, maybe after merging with the following chunk.  */
size = _int_free_create_chunk (av, p, size, nextchunk, nextsize);
_int_free_maybe_consolidate (av, size);
}
```
</details>

---

## Attacker notes and recent changes (2023–2025)

- Safe-Linking in tcache/fastbins: `free()` は単方向リンクリストの `fd` ポインタをマクロ `PROTECT_PTR(pos, ptr) = ((size_t)pos >> 12) ^ (size_t)ptr` を使って格納します。これは、tcache poisoning のために偽の next ポインタを作るには攻撃者がヒープアドレスを知っている必要があることを意味します（例: leak `chunk_addr`、その後 `chunk_addr >> 12` を XOR キーとして使用）。詳細と PoCs は下の tcache ページを参照してください。
- Tcache double-free detection: チャンクを tcache に入れる前に、`free()` はエントリごとの `e->key` をスレッド固有の `tcache_key` と比較し、重複を探すために `mp_.tcache_count` まで bin を辿ります。重複が見つかると `free(): double free detected in tcache 2` で中止します。
- Recent glibc change (2.42): tcache は新しい `glibc.malloc.tcache_max_bytes` チューナブルによって制御され、より大きなチャンクを受け入れるようになりました。`free()` はそのバイト制限まで解放されたチャンクをキャッシュしようとします（mmapped チャンクはキャッシュされません）。これにより、現代のシステムで free が unsorted/small/large bins に落ちる頻度が減ります。

### safe-linked fd の素早い作成 (for tcache poisoning)
```py
# Given a leaked heap pointer to an entry located at &entry->next == POS
# compute the protected fd that points to TARGET
protected_fd = TARGET ^ (POS >> 12)
```
- 完全な tcache poisoning の walkthrough（および safe-linking による制限）については、次を参照してください:

{{#ref}}
../tcache-bin-attack.md
{{#endref}}

### 研究時に frees を unsorted/small bins に当てる方法

ローカル環境で古典的な `_int_free` の振る舞い（unsorted bin consolidation など）を観察するため、tcache を完全に回避したい場合があります。これには GLIBC_TUNABLES を使います:
```bash
# Disable tcache completely
GLIBC_TUNABLES=glibc.malloc.tcache_count=0 ./vuln

# Pre-2.42: shrink the maximum cached request size to 0
GLIBC_TUNABLES=glibc.malloc.tcache_max=0 ./vuln

# 2.42+: cap the new large-cache threshold (bytes)
GLIBC_TUNABLES=glibc.malloc.tcache_max_bytes=0 ./vuln
```
HackTricks 内の関連資料：

- First-fit/unsorted の挙動と overlap tricks:

{{#ref}}
../use-after-free/first-fit.md
{{#endref}}

- Double-free のプリミティブとモダンなチェック:

{{#ref}}
../double-free.md
{{#endref}}

> hooks に関する注意事項: 古典的な `__malloc_hook`/`__free_hook` 上書きテクニックは、modern glibc (≥ 2.34) では有効ではありません。古い write-up でまだ見かける場合は、IO_FILE、exit handlers、vtables などの代替ターゲットに適応してください。背景は HackTricks の hooks に関するページを参照してください。

{{#ref}}
../../arbitrary-write-2-exec/aw2exec-__malloc_hook.md
{{#endref}}

## 参考文献

- GNU C Library – 2.42 の NEWS (allocator: larger tcache via tcache_max_bytes, mmapped chunks are not cached) <https://www.gnu.org/software/libc/NEWS.html#2.42>
- Safe-Linking の説明と内部 (Red Hat Developer, 2020) <https://developers.redhat.com/articles/2020/05/13/new-security-hardening-gnu-c-library>

{{#include ../../../banners/hacktricks-training.md}}
