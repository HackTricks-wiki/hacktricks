# Έλεγχοι Ασφαλείας Λειτουργιών Σωρού

{{#include ../../../banners/hacktricks-training.md}}

## unlink

Για περισσότερες πληροφορίες δείτε:

{{#ref}}
unlink.md
{{#endref}}

Αυτή είναι μια περίληψη των ελέγχων που πραγματοποιήθηκαν:

- Έλεγχος αν το υποδεικνυόμενο μέγεθος του κομματιού είναι το ίδιο με το `prev_size` που υποδεικνύεται στο επόμενο κομμάτι
- Μήνυμα σφάλματος: `corrupted size vs. prev_size`
- Έλεγχος επίσης ότι `P->fd->bk == P` και `P->bk->fw == P`
- Μήνυμα σφάλματος: `corrupted double-linked list`
- Αν το κομμάτι δεν είναι μικρό, έλεγχος ότι `P->fd_nextsize->bk_nextsize == P` και `P->bk_nextsize->fd_nextsize == P`
- Μήνυμα σφάλματος: `corrupted double-linked list (not small)`

## \_int_malloc

Για περισσότερες πληροφορίες δείτε:

{{#ref}}
malloc-and-sysmalloc.md
{{#endref}}

- **Έλεγχοι κατά την αναζήτηση γρήγορης λίστας:**
- Αν το κομμάτι είναι κακώς ευθυγραμμισμένο:
- Μήνυμα σφάλματος: `malloc(): unaligned fastbin chunk detected 2`
- Αν το επόμενο κομμάτι είναι κακώς ευθυγραμμισμένο:
- Μήνυμα σφάλματος: `malloc(): unaligned fastbin chunk detected`
- Αν το επιστρεφόμενο κομμάτι έχει μέγεθος που δεν είναι σωστό λόγω του δείκτη του στη γρήγορη λίστα:
- Μήνυμα σφάλματος: `malloc(): memory corruption (fast)`
- Αν οποιοδήποτε κομμάτι που χρησιμοποιείται για να γεμίσει το tcache είναι κακώς ευθυγραμμισμένο:
- Μήνυμα σφάλματος: `malloc(): unaligned fastbin chunk detected 3`
- **Έλεγχοι κατά την αναζήτηση μικρής λίστας:**
- Αν `victim->bk->fd != victim`:
- Μήνυμα σφάλματος: `malloc(): smallbin double linked list corrupted`
- **Έλεγχοι κατά την ενοποίηση** που πραγματοποιούνται για κάθε κομμάτι γρήγορης λίστας:&#x20;
- Αν το κομμάτι είναι κακώς ευθυγραμμισμένο ενεργοποιήστε:
- Μήνυμα σφάλματος: `malloc_consolidate(): unaligned fastbin chunk detected`
- Αν το κομμάτι έχει διαφορετικό μέγεθος από αυτό που θα έπρεπε λόγω του δείκτη του:
- Μήνυμα σφάλματος: `malloc_consolidate(): invalid chunk size`
- Αν το προηγούμενο κομμάτι δεν είναι σε χρήση και το προηγούμενο κομμάτι έχει μέγεθος διαφορετικό από αυτό που υποδεικνύεται από το prev_chunk:
- Μήνυμα σφάλματος: `corrupted size vs. prev_size in fastbins`
- **Έλεγχοι κατά την αναζήτηση αταξινόμητης λίστας**:
- Αν το μέγεθος του κομματιού είναι περίεργο (πολύ μικρό ή πολύ μεγάλο):&#x20;
- Μήνυμα σφάλματος: `malloc(): invalid size (unsorted)`
- Αν το μέγεθος του επόμενου κομματιού είναι περίεργο (πολύ μικρό ή πολύ μεγάλο):
- Μήνυμα σφάλματος: `malloc(): invalid next size (unsorted)`
- Αν το προηγούμενο μέγεθος που υποδεικνύεται από το επόμενο κομμάτι διαφέρει από το μέγεθος του κομματιού:
- Μήνυμα σφάλματος: `malloc(): mismatching next->prev_size (unsorted)`
- Αν όχι `victim->bck->fd == victim` ή όχι `victim->fd == av (arena)`:
- Μήνυμα σφάλματος: `malloc(): unsorted double linked list corrupted`
- Καθώς πάντα ελέγχουμε το τελευταίο, το fd του θα πρέπει πάντα να δείχνει στη δομή arena.
- Αν το επόμενο κομμάτι δεν υποδεικνύει ότι το προηγούμενο είναι σε χρήση:
- Μήνυμα σφάλματος: `malloc(): invalid next->prev_inuse (unsorted)`
- Αν `fwd->bk_nextsize->fd_nextsize != fwd`:
- Μήνυμα σφάλματος: `malloc(): largebin double linked list corrupted (nextsize)`
- Αν `fwd->bk->fd != fwd`:
- Μήνυμα σφάλματος: `malloc(): largebin double linked list corrupted (bk)`
- **Έλεγχοι κατά την αναζήτηση μεγάλης λίστας (κατά δείκτη):**
- `bck->fd-> bk != bck`:
- Μήνυμα σφάλματος: `malloc(): corrupted unsorted chunks`
- **Έλεγχοι κατά την αναζήτηση μεγάλης λίστας (επόμενος μεγαλύτερος):**
- `bck->fd-> bk != bck`:
- Μήνυμα σφάλματος: `malloc(): corrupted unsorted chunks2`
- **Έλεγχοι κατά τη χρήση του Top chunk:**
- `chunksize(av->top) > av->system_mem`:
- Μήνυμα σφάλματος: `malloc(): corrupted top size`

## `tcache_get_n`

- **Έλεγχοι στο `tcache_get_n`:**
- Αν το κομμάτι είναι κακώς ευθυγραμμισμένο:
- Μήνυμα σφάλματος: `malloc(): unaligned tcache chunk detected`

## `tcache_thread_shutdown`

- **Έλεγχοι στο `tcache_thread_shutdown`:**
- Αν το κομμάτι είναι κακώς ευθυγραμμισμένο:
- Μήνυμα σφάλματος: `tcache_thread_shutdown(): unaligned tcache chunk detected`

## `__libc_realloc`

- **Έλεγχοι στο `__libc_realloc`:**
- Αν ο παλιός δείκτης είναι κακώς ευθυγραμμισμένος ή το μέγεθος ήταν λανθασμένο:
- Μήνυμα σφάλματος: `realloc(): invalid pointer`

## `_int_free`

Για περισσότερες πληροφορίες δείτε:

{{#ref}}
free.md
{{#endref}}

- **Έλεγχοι κατά την αρχή του `_int_free`:**
- Ο δείκτης είναι ευθυγραμμισμένος:
- Μήνυμα σφάλματος: `free(): invalid pointer`
- Μέγεθος μεγαλύτερο από `MINSIZE` και το μέγεθος είναι επίσης ευθυγραμμισμένο:
- Μήνυμα σφάλματος: `free(): invalid size`
- **Έλεγχοι στο `_int_free` tcache:**
- Αν υπάρχουν περισσότερες καταχωρίσεις από το `mp_.tcache_count`:
- Μήνυμα σφάλματος: `free(): too many chunks detected in tcache`
- Αν η καταχώριση δεν είναι ευθυγραμμισμένη:
- Μήνυμα σφάλματος: `free(): unaligned chunk detected in tcache 2`
- Αν το ελευθερωμένο κομμάτι είχε ήδη ελευθερωθεί και είναι παρόν ως κομμάτι στο tcache:
- Μήνυμα σφάλματος: `free(): double free detected in tcache 2`
- **Έλεγχοι στο `_int_free` γρήγορη λίστα:**
- Αν το μέγεθος του κομματιού είναι μη έγκυρο (πολύ μεγάλο ή πολύ μικρό) ενεργοποιήστε:
- Μήνυμα σφάλματος: `free(): invalid next size (fast)`
- Αν το προστιθέμενο κομμάτι ήταν ήδη το κορυφαίο της γρήγορης λίστας:
- Μήνυμα σφάλματος: `double free or corruption (fasttop)`
- Αν το μέγεθος του κομματιού στην κορυφή έχει διαφορετικό μέγεθος από το κομμάτι που προσθέτουμε:
- Μήνυμα σφάλματος: `invalid fastbin entry (free)`

## **`_int_free_merge_chunk`**

- **Έλεγχοι στο `_int_free_merge_chunk`:**
- Αν το κομμάτι είναι το κορυφαίο κομμάτι:
- Μήνυμα σφάλματος: `double free or corruption (top)`
- Αν το επόμενο κομμάτι είναι εκτός των ορίων της αρένας:
- Μήνυμα σφάλματος: `double free or corruption (out)`
- Αν το κομμάτι δεν είναι σημειωμένο ως χρησιμοποιούμενο (στο prev_inuse από το επόμενο κομμάτι):
- Μήνυμα σφάλματος: `double free or corruption (!prev)`
- Αν το επόμενο κομμάτι έχει πολύ μικρό ή πολύ μεγάλο μέγεθος:
- Μήνυμα σφάλματος: `free(): invalid next size (normal)`
- Αν το προηγούμενο κομμάτι δεν είναι σε χρήση, θα προσπαθήσει να ενοποιήσει. Αλλά, αν το `prev_size` διαφέρει από το μέγεθος που υποδεικνύεται στο προηγούμενο κομμάτι:
- Μήνυμα σφάλματος: `corrupted size vs. prev_size while consolidating`

## **`_int_free_create_chunk`**

- **Έλεγχοι στο `_int_free_create_chunk`:**
- Προσθέτοντας ένα κομμάτι στην αταξινόμητη λίστα, ελέγξτε αν `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`:
- Μήνυμα σφάλματος: `free(): corrupted unsorted chunks`

## `do_check_malloc_state`

- **Έλεγχοι στο `do_check_malloc_state`:**
- Αν το κομμάτι γρήγορης λίστας είναι κακώς ευθυγραμμισμένο:
- Μήνυμα σφάλματος: `do_check_malloc_state(): unaligned fastbin chunk detected`

## `malloc_consolidate`

- **Έλεγχοι στο `malloc_consolidate`:**
- Αν το κομμάτι γρήγορης λίστας είναι κακώς ευθυγραμμισμένο:
- Μήνυμα σφάλματος: `malloc_consolidate(): unaligned fastbin chunk detected`
- Αν το μέγεθος του κομματιού γρήγορης λίστας είναι λανθασμένο:
- Μήνυμα σφάλματος: `malloc_consolidate(): invalid chunk size`

## `_int_realloc`

- **Έλεγχοι στο `_int_realloc`:**
- Το μέγεθος είναι πολύ μεγάλο ή πολύ μικρό:
- Μήνυμα σφάλματος: `realloc(): invalid old size`
- Το μέγεθος του επόμενου κομματιού είναι πολύ μεγάλο ή πολύ μικρό:
- Μήνυμα σφάλματος: `realloc(): invalid next size`

{{#include ../../../banners/hacktricks-training.md}}
