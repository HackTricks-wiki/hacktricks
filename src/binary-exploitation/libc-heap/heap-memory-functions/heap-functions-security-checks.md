# Heap Functions Security Checks

{{#include ../../../banners/hacktricks-training.md}}

## unlink

Para más información, consulta:

{{#ref}}
unlink.md
{{#endref}}

Este es un resumen de las comprobaciones realizadas:

- Verificar si el tamaño indicado del chunk es el mismo que el `prev_size` indicado en el siguiente chunk
- Mensaje de error: `corrupted size vs. prev_size`
- Verificar también que `P->fd->bk == P` y `P->bk->fw == P`
- Mensaje de error: `corrupted double-linked list`
- Si el chunk no es pequeño, verificar que `P->fd_nextsize->bk_nextsize == P` y `P->bk_nextsize->fd_nextsize == P`
- Mensaje de error: `corrupted double-linked list (not small)`

## \_int_malloc

Para más información, consulta:

{{#ref}}
malloc-and-sysmalloc.md
{{#endref}}

- **Comprobaciones durante la búsqueda en fast bin:**
- Si el chunk está desalineado:
- Mensaje de error: `malloc(): unaligned fastbin chunk detected 2`
- Si el chunk hacia adelante está desalineado:
- Mensaje de error: `malloc(): unaligned fastbin chunk detected`
- Si el chunk devuelto tiene un tamaño que no es correcto debido a su índice en el fast bin:
- Mensaje de error: `malloc(): memory corruption (fast)`
- Si algún chunk utilizado para llenar el tcache está desalineado:
- Mensaje de error: `malloc(): unaligned fastbin chunk detected 3`
- **Comprobaciones durante la búsqueda en small bin:**
- Si `victim->bk->fd != victim`:
- Mensaje de error: `malloc(): smallbin double linked list corrupted`
- **Comprobaciones durante la consolidación** realizadas para cada chunk de fast bin:
- Si el chunk está desalineado, activar:
- Mensaje de error: `malloc_consolidate(): unaligned fastbin chunk detected`
- Si el chunk tiene un tamaño diferente al que debería debido al índice en el que se encuentra:
- Mensaje de error: `malloc_consolidate(): invalid chunk size`
- Si el chunk anterior no está en uso y el chunk anterior tiene un tamaño diferente al indicado por prev_chunk:
- Mensaje de error: `corrupted size vs. prev_size in fastbins`
- **Comprobaciones durante la búsqueda en unsorted bin**:
- Si el tamaño del chunk es extraño (demasiado pequeño o demasiado grande):
- Mensaje de error: `malloc(): invalid size (unsorted)`
- Si el tamaño del siguiente chunk es extraño (demasiado pequeño o demasiado grande):
- Mensaje de error: `malloc(): invalid next size (unsorted)`
- Si el tamaño anterior indicado por el siguiente chunk difiere del tamaño del chunk:
- Mensaje de error: `malloc(): mismatching next->prev_size (unsorted)`
- Si no `victim->bck->fd == victim` o no `victim->fd == av (arena)`:
- Mensaje de error: `malloc(): unsorted double linked list corrupted`
- Como siempre estamos verificando el último, su fd debería estar apuntando siempre a la estructura de arena.
- Si el siguiente chunk no indica que el anterior está en uso:
- Mensaje de error: `malloc(): invalid next->prev_inuse (unsorted)`
- Si `fwd->bk_nextsize->fd_nextsize != fwd`:
- Mensaje de error: `malloc(): largebin double linked list corrupted (nextsize)`
- Si `fwd->bk->fd != fwd`:
- Mensaje de error: `malloc(): largebin double linked list corrupted (bk)`
- **Comprobaciones durante la búsqueda en large bin (por índice):**
- `bck->fd-> bk != bck`:
- Mensaje de error: `malloc(): corrupted unsorted chunks`
- **Comprobaciones durante la búsqueda en large bin (siguiente más grande):**
- `bck->fd-> bk != bck`:
- Mensaje de error: `malloc(): corrupted unsorted chunks2`
- **Comprobaciones durante el uso del Top chunk:**
- `chunksize(av->top) > av->system_mem`:
- Mensaje de error: `malloc(): corrupted top size`

## `tcache_get_n`

- **Comprobaciones en `tcache_get_n`:**
- Si el chunk está desalineado:
- Mensaje de error: `malloc(): unaligned tcache chunk detected`

## `tcache_thread_shutdown`

- **Comprobaciones en `tcache_thread_shutdown`:**
- Si el chunk está desalineado:
- Mensaje de error: `tcache_thread_shutdown(): unaligned tcache chunk detected`

## `__libc_realloc`

- **Comprobaciones en `__libc_realloc`:**
- Si el puntero antiguo está desalineado o el tamaño era incorrecto:
- Mensaje de error: `realloc(): invalid pointer`

## `_int_free`

Para más información, consulta:

{{#ref}}
free.md
{{#endref}}

- **Comprobaciones al inicio de `_int_free`:**
- El puntero está alineado:
- Mensaje de error: `free(): invalid pointer`
- Tamaño mayor que `MINSIZE` y tamaño también alineado:
- Mensaje de error: `free(): invalid size`
- **Comprobaciones en `_int_free` tcache:**
- Si hay más entradas que `mp_.tcache_count`:
- Mensaje de error: `free(): too many chunks detected in tcache`
- Si la entrada no está alineada:
- Mensaje de error: `free(): unaligned chunk detected in tcache 2`
- Si el chunk liberado ya fue liberado y está presente como chunk en el tcache:
- Mensaje de error: `free(): double free detected in tcache 2`
- **Comprobaciones en `_int_free` fast bin:**
- Si el tamaño del chunk es inválido (demasiado grande o pequeño) activar:
- Mensaje de error: `free(): invalid next size (fast)`
- Si el chunk agregado ya era el top del fast bin:
- Mensaje de error: `double free or corruption (fasttop)`
- Si el tamaño del chunk en la parte superior tiene un tamaño diferente al del chunk que estamos agregando:
- Mensaje de error: `invalid fastbin entry (free)`

## **`_int_free_merge_chunk`**

- **Comprobaciones en `_int_free_merge_chunk`:**
- Si el chunk es el top chunk:
- Mensaje de error: `double free or corruption (top)`
- Si el siguiente chunk está fuera de los límites de la arena:
- Mensaje de error: `double free or corruption (out)`
- Si el chunk no está marcado como usado (en el prev_inuse del siguiente chunk):
- Mensaje de error: `double free or corruption (!prev)`
- Si el siguiente chunk tiene un tamaño demasiado pequeño o demasiado grande:
- Mensaje de error: `free(): invalid next size (normal)`
- Si el chunk anterior no está en uso, intentará consolidar. Pero, si el `prev_size` difiere del tamaño indicado en el chunk anterior:
- Mensaje de error: `corrupted size vs. prev_size while consolidating`

## **`_int_free_create_chunk`**

- **Comprobaciones en `_int_free_create_chunk`:**
- Al agregar un chunk en el unsorted bin, verificar si `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`:
- Mensaje de error: `free(): corrupted unsorted chunks`

## `do_check_malloc_state`

- **Comprobaciones en `do_check_malloc_state`:**
- Si el chunk de fast bin está desalineado:
- Mensaje de error: `do_check_malloc_state(): unaligned fastbin chunk detected`

## `malloc_consolidate`

- **Comprobaciones en `malloc_consolidate`:**
- Si el chunk de fast bin está desalineado:
- Mensaje de error: `malloc_consolidate(): unaligned fastbin chunk detected`
- Si el tamaño del chunk de fast bin es incorrecto:
- Mensaje de error: `malloc_consolidate(): invalid chunk size`

## `_int_realloc`

- **Comprobaciones en `_int_realloc`:**
- El tamaño es demasiado grande o demasiado pequeño:
- Mensaje de error: `realloc(): invalid old size`
- El tamaño del siguiente chunk es demasiado grande o demasiado pequeño:
- Mensaje de error: `realloc(): invalid next size`

{{#include ../../../banners/hacktricks-training.md}}
