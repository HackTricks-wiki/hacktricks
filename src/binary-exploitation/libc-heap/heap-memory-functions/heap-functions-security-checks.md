# Controlli di Sicurezza delle Funzioni Heap

{{#include ../../../banners/hacktricks-training.md}}

## unlink

Per ulteriori informazioni controlla:

{{#ref}}
unlink.md
{{#endref}}

Questo è un riepilogo dei controlli effettuati:

- Controlla se la dimensione indicata del chunk è la stessa del `prev_size` indicato nel chunk successivo
- Messaggio di errore: `corrupted size vs. prev_size`
- Controlla anche che `P->fd->bk == P` e `P->bk->fw == P`
- Messaggio di errore: `corrupted double-linked list`
- Se il chunk non è piccolo, controlla che `P->fd_nextsize->bk_nextsize == P` e `P->bk_nextsize->fd_nextsize == P`
- Messaggio di errore: `corrupted double-linked list (not small)`

## \_int_malloc

Per ulteriori informazioni controlla:

{{#ref}}
malloc-and-sysmalloc.md
{{#endref}}

- **Controlli durante la ricerca nel fast bin:**
- Se il chunk è disallineato:
- Messaggio di errore: `malloc(): unaligned fastbin chunk detected 2`
- Se il chunk successivo è disallineato:
- Messaggio di errore: `malloc(): unaligned fastbin chunk detected`
- Se il chunk restituito ha una dimensione che non è corretta a causa del suo indice nel fast bin:
- Messaggio di errore: `malloc(): memory corruption (fast)`
- Se qualsiasi chunk utilizzato per riempire il tcache è disallineato:
- Messaggio di errore: `malloc(): unaligned fastbin chunk detected 3`
- **Controlli durante la ricerca nel small bin:**
- Se `victim->bk->fd != victim`:
- Messaggio di errore: `malloc(): smallbin double linked list corrupted`
- **Controlli durante la consolidazione** effettuati per ogni chunk del fast bin:
- Se il chunk è disallineato attiva:
- Messaggio di errore: `malloc_consolidate(): unaligned fastbin chunk detected`
- Se il chunk ha una dimensione diversa da quella che dovrebbe avere a causa dell'indice in cui si trova:
- Messaggio di errore: `malloc_consolidate(): invalid chunk size`
- Se il chunk precedente non è in uso e il chunk precedente ha una dimensione diversa da quella indicata da prev_chunk:
- Messaggio di errore: `corrupted size vs. prev_size in fastbins`
- **Controlli durante la ricerca nel unsorted bin**:
- Se la dimensione del chunk è strana (troppo piccola o troppo grande):
- Messaggio di errore: `malloc(): invalid size (unsorted)`
- Se la dimensione del chunk successivo è strana (troppo piccola o troppo grande):
- Messaggio di errore: `malloc(): invalid next size (unsorted)`
- Se la dimensione precedente indicata dal chunk successivo differisce dalla dimensione del chunk:
- Messaggio di errore: `malloc(): mismatching next->prev_size (unsorted)`
- Se non `victim->bck->fd == victim` o non `victim->fd == av (arena)`:
- Messaggio di errore: `malloc(): unsorted double linked list corrupted`
- Poiché stiamo sempre controllando l'ultimo, il suo fd dovrebbe sempre puntare alla struttura arena.
- Se il chunk successivo non indica che il precedente è in uso:
- Messaggio di errore: `malloc(): invalid next->prev_inuse (unsorted)`
- Se `fwd->bk_nextsize->fd_nextsize != fwd`:
- Messaggio di errore: `malloc(): largebin double linked list corrupted (nextsize)`
- Se `fwd->bk->fd != fwd`:
- Messaggio di errore: `malloc(): largebin double linked list corrupted (bk)`
- **Controlli durante la ricerca nel large bin (per indice):**
- `bck->fd-> bk != bck`:
- Messaggio di errore: `malloc(): corrupted unsorted chunks`
- **Controlli durante la ricerca nel large bin (prossimo più grande):**
- `bck->fd-> bk != bck`:
- Messaggio di errore: `malloc(): corrupted unsorted chunks2`
- **Controlli durante l'uso del Top chunk:**
- `chunksize(av->top) > av->system_mem`:
- Messaggio di errore: `malloc(): corrupted top size`

## `tcache_get_n`

- **Controlli in `tcache_get_n`:**
- Se il chunk è disallineato:
- Messaggio di errore: `malloc(): unaligned tcache chunk detected`

## `tcache_thread_shutdown`

- **Controlli in `tcache_thread_shutdown`:**
- Se il chunk è disallineato:
- Messaggio di errore: `tcache_thread_shutdown(): unaligned tcache chunk detected`

## `__libc_realloc`

- **Controlli in `__libc_realloc`:**
- Se il puntatore vecchio è disallineato o la dimensione era errata:
- Messaggio di errore: `realloc(): invalid pointer`

## `_int_free`

Per ulteriori informazioni controlla:

{{#ref}}
free.md
{{#endref}}

- **Controlli all'inizio di `_int_free`:**
- Il puntatore è allineato:
- Messaggio di errore: `free(): invalid pointer`
- Dimensione maggiore di `MINSIZE` e dimensione anche allineata:
- Messaggio di errore: `free(): invalid size`
- **Controlli in `_int_free` tcache:**
- Se ci sono più voci di `mp_.tcache_count`:
- Messaggio di errore: `free(): too many chunks detected in tcache`
- Se l'entry non è allineata:
- Messaggio di errore: `free(): unaligned chunk detected in tcache 2`
- Se il chunk liberato era già stato liberato ed è presente come chunk nel tcache:
- Messaggio di errore: `free(): double free detected in tcache 2`
- **Controlli in `_int_free` fast bin:**
- Se la dimensione del chunk è non valida (troppo grande o piccola) attiva:
- Messaggio di errore: `free(): invalid next size (fast)`
- Se il chunk aggiunto era già il top del fast bin:
- Messaggio di errore: `double free or corruption (fasttop)`
- Se la dimensione del chunk in cima ha una dimensione diversa da quella del chunk che stiamo aggiungendo:
- Messaggio di errore: `invalid fastbin entry (free)`

## **`_int_free_merge_chunk`**

- **Controlli in `_int_free_merge_chunk`:**
- Se il chunk è il top chunk:
- Messaggio di errore: `double free or corruption (top)`
- Se il chunk successivo è al di fuori dei confini dell'arena:
- Messaggio di errore: `double free or corruption (out)`
- Se il chunk non è contrassegnato come utilizzato (nel prev_inuse del chunk successivo):
- Messaggio di errore: `double free or corruption (!prev)`
- Se il chunk successivo ha una dimensione troppo piccola o troppo grande:
- Messaggio di errore: `free(): invalid next size (normal)`
- Se il chunk precedente non è in uso, cercherà di consolidare. Ma, se il `prev_size` differisce dalla dimensione indicata nel chunk precedente:
- Messaggio di errore: `corrupted size vs. prev_size while consolidating`

## **`_int_free_create_chunk`**

- **Controlli in `_int_free_create_chunk`:**
- Aggiungendo un chunk nel unsorted bin, controlla se `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`:
- Messaggio di errore: `free(): corrupted unsorted chunks`

## `do_check_malloc_state`

- **Controlli in `do_check_malloc_state`:**
- Se il fast bin chunk è disallineato:
- Messaggio di errore: `do_check_malloc_state(): unaligned fastbin chunk detected`

## `malloc_consolidate`

- **Controlli in `malloc_consolidate`:**
- Se il fast bin chunk è disallineato:
- Messaggio di errore: `malloc_consolidate(): unaligned fastbin chunk detected`
- Se la dimensione del fast bin chunk è errata:
- Messaggio di errore: `malloc_consolidate(): invalid chunk size`

## `_int_realloc`

- **Controlli in `_int_realloc`:**
- La dimensione è troppo grande o troppo piccola:
- Messaggio di errore: `realloc(): invalid old size`
- La dimensione del chunk successivo è troppo grande o troppo piccola:
- Messaggio di errore: `realloc(): invalid next size`

{{#include ../../../banners/hacktricks-training.md}}
