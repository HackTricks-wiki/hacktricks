# Vérifications de sécurité des fonctions de tas

{{#include ../../../banners/hacktricks-training.md}}

## unlink

Pour plus d'infos, consultez :

{{#ref}}
unlink.md
{{#endref}}

Voici un résumé des vérifications effectuées :

- Vérifiez si la taille indiquée du morceau est la même que le `prev_size` indiqué dans le morceau suivant
- Message d'erreur : `corrupted size vs. prev_size`
- Vérifiez également que `P->fd->bk == P` et `P->bk->fw == P`
- Message d'erreur : `corrupted double-linked list`
- Si le morceau n'est pas petit, vérifiez que `P->fd_nextsize->bk_nextsize == P` et `P->bk_nextsize->fd_nextsize == P`
- Message d'erreur : `corrupted double-linked list (not small)`

## \_int_malloc

Pour plus d'infos, consultez :

{{#ref}}
malloc-and-sysmalloc.md
{{#endref}}

- **Vérifications lors de la recherche dans le fast bin :**
- Si le morceau est mal aligné :
- Message d'erreur : `malloc(): unaligned fastbin chunk detected 2`
- Si le morceau suivant est mal aligné :
- Message d'erreur : `malloc(): unaligned fastbin chunk detected`
- Si le morceau retourné a une taille incorrecte à cause de son index dans le fast bin :
- Message d'erreur : `malloc(): memory corruption (fast)`
- Si un morceau utilisé pour remplir le tcache est mal aligné :
- Message d'erreur : `malloc(): unaligned fastbin chunk detected 3`
- **Vérifications lors de la recherche dans le small bin :**
- Si `victim->bk->fd != victim` :
- Message d'erreur : `malloc(): smallbin double linked list corrupted`
- **Vérifications lors de la consolidation** effectuées pour chaque morceau de fast bin :&#x20;
- Si le morceau est mal aligné, déclenchez :
- Message d'erreur : `malloc_consolidate(): unaligned fastbin chunk detected`
- Si le morceau a une taille différente de celle qu'il devrait avoir à cause de l'index dans lequel il se trouve :
- Message d'erreur : `malloc_consolidate(): invalid chunk size`
- Si le morceau précédent n'est pas utilisé et que le morceau précédent a une taille différente de celle indiquée par prev_chunk :
- Message d'erreur : `corrupted size vs. prev_size in fastbins`
- **Vérifications lors de la recherche dans le unsorted bin :**
- Si la taille du morceau est étrange (trop petite ou trop grande) :&#x20;
- Message d'erreur : `malloc(): invalid size (unsorted)`
- Si la taille du morceau suivant est étrange (trop petite ou trop grande) :
- Message d'erreur : `malloc(): invalid next size (unsorted)`
- Si la taille précédente indiquée par le morceau suivant diffère de la taille du morceau :
- Message d'erreur : `malloc(): mismatching next->prev_size (unsorted)`
- Si `victim->bck->fd != victim` ou si `victim->fd != av (arena)` :
- Message d'erreur : `malloc(): unsorted double linked list corrupted`
- Comme nous vérifions toujours le dernier, son fd devrait toujours pointer vers la structure arena.
- Si le morceau suivant n'indique pas que le précédent est utilisé :
- Message d'erreur : `malloc(): invalid next->prev_inuse (unsorted)`
- Si `fwd->bk_nextsize->fd_nextsize != fwd` :
- Message d'erreur : `malloc(): largebin double linked list corrupted (nextsize)`
- Si `fwd->bk->fd != fwd` :
- Message d'erreur : `malloc(): largebin double linked list corrupted (bk)`
- **Vérifications lors de la recherche dans le large bin (par index) :**
- `bck->fd-> bk != bck` :
- Message d'erreur : `malloc(): corrupted unsorted chunks`
- **Vérifications lors de la recherche dans le large bin (suivant plus grand) :**
- `bck->fd-> bk != bck` :
- Message d'erreur : `malloc(): corrupted unsorted chunks2`
- **Vérifications lors de l'utilisation du Top chunk :**
- `chunksize(av->top) > av->system_mem` :
- Message d'erreur : `malloc(): corrupted top size`

## `tcache_get_n`

- **Vérifications dans `tcache_get_n` :**
- Si le morceau est mal aligné :
- Message d'erreur : `malloc(): unaligned tcache chunk detected`

## `tcache_thread_shutdown`

- **Vérifications dans `tcache_thread_shutdown` :**
- Si le morceau est mal aligné :
- Message d'erreur : `tcache_thread_shutdown(): unaligned tcache chunk detected`

## `__libc_realloc`

- **Vérifications dans `__libc_realloc` :**
- Si l'ancien pointeur est mal aligné ou si la taille était incorrecte :
- Message d'erreur : `realloc(): invalid pointer`

## `_int_free`

Pour plus d'infos, consultez :

{{#ref}}
free.md
{{#endref}}

- **Vérifications au début de `_int_free` :**
- Le pointeur est aligné :
- Message d'erreur : `free(): invalid pointer`
- Taille supérieure à `MINSIZE` et taille également alignée :
- Message d'erreur : `free(): invalid size`
- **Vérifications dans `_int_free` tcache :**
- S'il y a plus d'entrées que `mp_.tcache_count` :
- Message d'erreur : `free(): too many chunks detected in tcache`
- Si l'entrée n'est pas alignée :
- Message d'erreur : `free(): unaligned chunk detected in tcache 2`
- Si le morceau libéré avait déjà été libéré et est présent comme morceau dans le tcache :
- Message d'erreur : `free(): double free detected in tcache 2`
- **Vérifications dans `_int_free` fast bin :**
- Si la taille du morceau est invalide (trop grande ou trop petite), déclenchez :
- Message d'erreur : `free(): invalid next size (fast)`
- Si le morceau ajouté était déjà le haut du fast bin :
- Message d'erreur : `double free or corruption (fasttop)`
- Si la taille du morceau en haut a une taille différente de celle du morceau que nous ajoutons :
- Message d'erreur : `invalid fastbin entry (free)`

## **`_int_free_merge_chunk`**

- **Vérifications dans `_int_free_merge_chunk` :**
- Si le morceau est le top chunk :
- Message d'erreur : `double free or corruption (top)`
- Si le morceau suivant est en dehors des limites de l'arène :
- Message d'erreur : `double free or corruption (out)`
- Si le morceau n'est pas marqué comme utilisé (dans le prev_inuse du morceau suivant) :
- Message d'erreur : `double free or corruption (!prev)`
- Si le morceau suivant a une taille trop petite ou trop grande :
- Message d'erreur : `free(): invalid next size (normal)`
- Si le morceau précédent n'est pas utilisé, il essaiera de consolider. Mais, si le `prev_size` diffère de la taille indiquée dans le morceau précédent :
- Message d'erreur : `corrupted size vs. prev_size while consolidating`

## **`_int_free_create_chunk`**

- **Vérifications dans `_int_free_create_chunk` :**
- En ajoutant un morceau dans le unsorted bin, vérifiez si `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` :
- Message d'erreur : `free(): corrupted unsorted chunks`

## `do_check_malloc_state`

- **Vérifications dans `do_check_malloc_state` :**
- Si le morceau de fast bin est mal aligné :
- Message d'erreur : `do_check_malloc_state(): unaligned fastbin chunk detected`

## `malloc_consolidate`

- **Vérifications dans `malloc_consolidate` :**
- Si le morceau de fast bin est mal aligné :
- Message d'erreur : `malloc_consolidate(): unaligned fastbin chunk detected`
- Si la taille du morceau de fast bin est incorrecte :
- Message d'erreur : `malloc_consolidate(): invalid chunk size`

## `_int_realloc`

- **Vérifications dans `_int_realloc` :**
- La taille est trop grande ou trop petite :
- Message d'erreur : `realloc(): invalid old size`
- La taille du morceau suivant est trop grande ou trop petite :
- Message d'erreur : `realloc(): invalid next size`

{{#include ../../../banners/hacktricks-training.md}}
