# Verificações de Segurança das Funções de Heap

{{#include ../../../banners/hacktricks-training.md}}

## unlink

Para mais informações, consulte:

{{#ref}}
unlink.md
{{#endref}}

Este é um resumo das verificações realizadas:

- Verifique se o tamanho indicado do chunk é o mesmo que o `prev_size` indicado no próximo chunk
- Mensagem de erro: `corrupted size vs. prev_size`
- Verifique também se `P->fd->bk == P` e `P->bk->fw == P`
- Mensagem de erro: `corrupted double-linked list`
- Se o chunk não for pequeno, verifique se `P->fd_nextsize->bk_nextsize == P` e `P->bk_nextsize->fd_nextsize == P`
- Mensagem de erro: `corrupted double-linked list (not small)`

## \_int_malloc

Para mais informações, consulte:

{{#ref}}
malloc-and-sysmalloc.md
{{#endref}}

- **Verificações durante a busca no fast bin:**
- Se o chunk estiver desalinhado:
- Mensagem de erro: `malloc(): unaligned fastbin chunk detected 2`
- Se o chunk seguinte estiver desalinhado:
- Mensagem de erro: `malloc(): unaligned fastbin chunk detected`
- Se o chunk retornado tiver um tamanho que não está correto por causa de seu índice no fast bin:
- Mensagem de erro: `malloc(): memory corruption (fast)`
- Se algum chunk usado para preencher o tcache estiver desalinhado:
- Mensagem de erro: `malloc(): unaligned fastbin chunk detected 3`
- **Verificações durante a busca no small bin:**
- Se `victim->bk->fd != victim`:
- Mensagem de erro: `malloc(): smallbin double linked list corrupted`
- **Verificações durante a consolidação** realizadas para cada chunk do fast bin:
- Se o chunk estiver desalinhado, acione:
- Mensagem de erro: `malloc_consolidate(): unaligned fastbin chunk detected`
- Se o chunk tiver um tamanho diferente do que deveria por causa do índice em que está:
- Mensagem de erro: `malloc_consolidate(): invalid chunk size`
- Se o chunk anterior não estiver em uso e o chunk anterior tiver um tamanho diferente do indicado por prev_chunk:
- Mensagem de erro: `corrupted size vs. prev_size in fastbins`
- **Verificações durante a busca no unsorted bin**:
- Se o tamanho do chunk for estranho (muito pequeno ou muito grande):
- Mensagem de erro: `malloc(): invalid size (unsorted)`
- Se o tamanho do próximo chunk for estranho (muito pequeno ou muito grande):
- Mensagem de erro: `malloc(): invalid next size (unsorted)`
- Se o tamanho anterior indicado pelo próximo chunk difere do tamanho do chunk:
- Mensagem de erro: `malloc(): mismatching next->prev_size (unsorted)`
- Se não `victim->bck->fd == victim` ou não `victim->fd == av (arena)`:
- Mensagem de erro: `malloc(): unsorted double linked list corrupted`
- Como estamos sempre verificando o último, seu fd deve sempre apontar para a estrutura da arena.
- Se o próximo chunk não indicar que o anterior está em uso:
- Mensagem de erro: `malloc(): invalid next->prev_inuse (unsorted)`
- Se `fwd->bk_nextsize->fd_nextsize != fwd`:
- Mensagem de erro: `malloc(): largebin double linked list corrupted (nextsize)`
- Se `fwd->bk->fd != fwd`:
- Mensagem de erro: `malloc(): largebin double linked list corrupted (bk)`
- **Verificações durante a busca no large bin (por índice):**
- `bck->fd-> bk != bck`:
- Mensagem de erro: `malloc(): corrupted unsorted chunks`
- **Verificações durante a busca no large bin (próximo maior):**
- `bck->fd-> bk != bck`:
- Mensagem de erro: `malloc(): corrupted unsorted chunks2`
- **Verificações durante o uso do Top chunk:**
- `chunksize(av->top) > av->system_mem`:
- Mensagem de erro: `malloc(): corrupted top size`

## `tcache_get_n`

- **Verificações em `tcache_get_n`:**
- Se o chunk estiver desalinhado:
- Mensagem de erro: `malloc(): unaligned tcache chunk detected`

## `tcache_thread_shutdown`

- **Verificações em `tcache_thread_shutdown`:**
- Se o chunk estiver desalinhado:
- Mensagem de erro: `tcache_thread_shutdown(): unaligned tcache chunk detected`

## `__libc_realloc`

- **Verificações em `__libc_realloc`:**
- Se o ponteiro antigo estiver desalinhado ou o tamanho estiver incorreto:
- Mensagem de erro: `realloc(): invalid pointer`

## `_int_free`

Para mais informações, consulte:

{{#ref}}
free.md
{{#endref}}

- **Verificações durante o início de `_int_free`:**
- O ponteiro está alinhado:
- Mensagem de erro: `free(): invalid pointer`
- Tamanho maior que `MINSIZE` e tamanho também alinhado:
- Mensagem de erro: `free(): invalid size`
- **Verificações em `_int_free` tcache:**
- Se houver mais entradas do que `mp_.tcache_count`:
- Mensagem de erro: `free(): too many chunks detected in tcache`
- Se a entrada não estiver alinhada:
- Mensagem de erro: `free(): unaligned chunk detected in tcache 2`
- Se o chunk liberado já foi liberado e está presente como chunk no tcache:
- Mensagem de erro: `free(): double free detected in tcache 2`
- **Verificações em `_int_free` fast bin:**
- Se o tamanho do chunk for inválido (muito grande ou pequeno), acione:
- Mensagem de erro: `free(): invalid next size (fast)`
- Se o chunk adicionado já era o topo do fast bin:
- Mensagem de erro: `double free or corruption (fasttop)`
- Se o tamanho do chunk no topo tiver um tamanho diferente do chunk que estamos adicionando:
- Mensagem de erro: `invalid fastbin entry (free)`

## **`_int_free_merge_chunk`**

- **Verificações em `_int_free_merge_chunk`:**
- Se o chunk for o top chunk:
- Mensagem de erro: `double free or corruption (top)`
- Se o próximo chunk estiver fora dos limites da arena:
- Mensagem de erro: `double free or corruption (out)`
- Se o chunk não estiver marcado como usado (no prev_inuse do chunk seguinte):
- Mensagem de erro: `double free or corruption (!prev)`
- Se o próximo chunk tiver um tamanho muito pequeno ou muito grande:
- Mensagem de erro: `free(): invalid next size (normal)`
- Se o chunk anterior não estiver em uso, ele tentará consolidar. Mas, se o `prev_size` diferir do tamanho indicado no chunk anterior:
- Mensagem de erro: `corrupted size vs. prev_size while consolidating`

## **`_int_free_create_chunk`**

- **Verificações em `_int_free_create_chunk`:**
- Adicionando um chunk no unsorted bin, verifique se `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`:
- Mensagem de erro: `free(): corrupted unsorted chunks`

## `do_check_malloc_state`

- **Verificações em `do_check_malloc_state`:**
- Se o chunk do fast bin estiver desalinhado:
- Mensagem de erro: `do_check_malloc_state(): unaligned fastbin chunk detected`

## `malloc_consolidate`

- **Verificações em `malloc_consolidate`:**
- Se o chunk do fast bin estiver desalinhado:
- Mensagem de erro: `malloc_consolidate(): unaligned fastbin chunk detected`
- Se o tamanho do chunk do fast bin estiver incorreto:
- Mensagem de erro: `malloc_consolidate(): invalid chunk size`

## `_int_realloc`

- **Verificações em `_int_realloc`:**
- Tamanho é muito grande ou muito pequeno:
- Mensagem de erro: `realloc(): invalid old size`
- Tamanho do próximo chunk é muito grande ou muito pequeno:
- Mensagem de erro: `realloc(): invalid next size`

{{#include ../../../banners/hacktricks-training.md}}
