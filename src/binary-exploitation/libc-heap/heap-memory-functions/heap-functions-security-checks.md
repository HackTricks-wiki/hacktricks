# Heap Functions Security Checks

{{#include ../../../banners/hacktricks-training.md}}

## unlink

Für weitere Informationen siehe:

{{#ref}}
unlink.md
{{#endref}}

Dies ist eine Zusammenfassung der durchgeführten Überprüfungen:

- Überprüfen, ob die angegebene Größe des Chunks mit der `prev_size` übereinstimmt, die im nächsten Chunk angegeben ist
- Fehlermeldung: `corrupted size vs. prev_size`
- Überprüfen Sie auch, dass `P->fd->bk == P` und `P->bk->fw == P`
- Fehlermeldung: `corrupted double-linked list`
- Wenn der Chunk nicht klein ist, überprüfen Sie, ob `P->fd_nextsize->bk_nextsize == P` und `P->bk_nextsize->fd_nextsize == P`
- Fehlermeldung: `corrupted double-linked list (not small)`

## \_int_malloc

Für weitere Informationen siehe:

{{#ref}}
malloc-and-sysmalloc.md
{{#endref}}

- **Überprüfungen während der schnellen Bin-Suche:**
- Wenn der Chunk nicht ausgerichtet ist:
- Fehlermeldung: `malloc(): unaligned fastbin chunk detected 2`
- Wenn der vorwärts gerichtete Chunk nicht ausgerichtet ist:
- Fehlermeldung: `malloc(): unaligned fastbin chunk detected`
- Wenn der zurückgegebene Chunk eine Größe hat, die aufgrund seines Index in der schnellen Bin nicht korrekt ist:
- Fehlermeldung: `malloc(): memory corruption (fast)`
- Wenn ein Chunk, der verwendet wird, um den tcache zu füllen, nicht ausgerichtet ist:
- Fehlermeldung: `malloc(): unaligned fastbin chunk detected 3`
- **Überprüfungen während der kleinen Bin-Suche:**
- Wenn `victim->bk->fd != victim`:
- Fehlermeldung: `malloc(): smallbin double linked list corrupted`
- **Überprüfungen während der Konsolidierung** für jeden schnellen Bin-Chunk:
- Wenn der Chunk nicht ausgerichtet ist, auslösen:
- Fehlermeldung: `malloc_consolidate(): unaligned fastbin chunk detected`
- Wenn der Chunk eine andere Größe hat als die, die er haben sollte, aufgrund des Index, in dem er sich befindet:
- Fehlermeldung: `malloc_consolidate(): invalid chunk size`
- Wenn der vorherige Chunk nicht in Gebrauch ist und der vorherige Chunk eine andere Größe hat als die, die von prev_chunk angegeben ist:
- Fehlermeldung: `corrupted size vs. prev_size in fastbins`
- **Überprüfungen während der unsortierten Bin-Suche**:
- Wenn die Chunk-Größe seltsam ist (zu klein oder zu groß):
- Fehlermeldung: `malloc(): invalid size (unsorted)`
- Wenn die Größe des nächsten Chunks seltsam ist (zu klein oder zu groß):
- Fehlermeldung: `malloc(): invalid next size (unsorted)`
- Wenn die vorherige Größe, die vom nächsten Chunk angegeben wird, von der Größe des Chunks abweicht:
- Fehlermeldung: `malloc(): mismatching next->prev_size (unsorted)`
- Wenn nicht `victim->bck->fd == victim` oder nicht `victim->fd == av (arena)`:
- Fehlermeldung: `malloc(): unsorted double linked list corrupted`
- Da wir immer den letzten überprüfen, sollte sein fd immer auf die Arena-Struktur zeigen.
- Wenn der nächste Chunk nicht angibt, dass der vorherige in Gebrauch ist:
- Fehlermeldung: `malloc(): invalid next->prev_inuse (unsorted)`
- Wenn `fwd->bk_nextsize->fd_nextsize != fwd`:
- Fehlermeldung: `malloc(): largebin double linked list corrupted (nextsize)`
- Wenn `fwd->bk->fd != fwd`:
- Fehlermeldung: `malloc(): largebin double linked list corrupted (bk)`
- **Überprüfungen während der großen Bin (nach Index) Suche:**
- `bck->fd-> bk != bck`:
- Fehlermeldung: `malloc(): corrupted unsorted chunks`
- **Überprüfungen während der großen Bin (nächste größere) Suche:**
- `bck->fd-> bk != bck`:
- Fehlermeldung: `malloc(): corrupted unsorted chunks2`
- **Überprüfungen während der Verwendung des Top-Chunks:**
- `chunksize(av->top) > av->system_mem`:
- Fehlermeldung: `malloc(): corrupted top size`

## `tcache_get_n`

- **Überprüfungen in `tcache_get_n`:**
- Wenn der Chunk nicht ausgerichtet ist:
- Fehlermeldung: `malloc(): unaligned tcache chunk detected`

## `tcache_thread_shutdown`

- **Überprüfungen in `tcache_thread_shutdown`:**
- Wenn der Chunk nicht ausgerichtet ist:
- Fehlermeldung: `tcache_thread_shutdown(): unaligned tcache chunk detected`

## `__libc_realloc`

- **Überprüfungen in `__libc_realloc`:**
- Wenn der alte Zeiger nicht ausgerichtet ist oder die Größe falsch war:
- Fehlermeldung: `realloc(): invalid pointer`

## `_int_free`

Für weitere Informationen siehe:

{{#ref}}
free.md
{{#endref}}

- **Überprüfungen zu Beginn von `_int_free`:**
- Zeiger ist ausgerichtet:
- Fehlermeldung: `free(): invalid pointer`
- Größe größer als `MINSIZE` und Größe ebenfalls ausgerichtet:
- Fehlermeldung: `free(): invalid size`
- **Überprüfungen in `_int_free` tcache:**
- Wenn es mehr Einträge als `mp_.tcache_count` gibt:
- Fehlermeldung: `free(): too many chunks detected in tcache`
- Wenn der Eintrag nicht ausgerichtet ist:
- Fehlermeldung: `free(): unaligned chunk detected in tcache 2`
- Wenn der freigegebene Chunk bereits freigegeben wurde und als Chunk im tcache vorhanden ist:
- Fehlermeldung: `free(): double free detected in tcache 2`
- **Überprüfungen in `_int_free` schnelle Bin:**
- Wenn die Größe des Chunks ungültig ist (zu groß oder zu klein), auslösen:
- Fehlermeldung: `free(): invalid next size (fast)`
- Wenn der hinzugefügte Chunk bereits der Top der schnellen Bin war:
- Fehlermeldung: `double free or corruption (fasttop)`
- Wenn die Größe des Chunks an der Spitze eine andere Größe hat als der Chunk, den wir hinzufügen:
- Fehlermeldung: `invalid fastbin entry (free)`

## **`_int_free_merge_chunk`**

- **Überprüfungen in `_int_free_merge_chunk`:**
- Wenn der Chunk der Top-Chunk ist:
- Fehlermeldung: `double free or corruption (top)`
- Wenn der nächste Chunk außerhalb der Grenzen der Arena liegt:
- Fehlermeldung: `double free or corruption (out)`
- Wenn der Chunk nicht als verwendet markiert ist (in der prev_inuse des folgenden Chunks):
- Fehlermeldung: `double free or corruption (!prev)`
- Wenn der nächste Chunk eine zu kleine oder zu große Größe hat:
- Fehlermeldung: `free(): invalid next size (normal)`
- Wenn der vorherige Chunk nicht in Gebrauch ist, wird versucht, zu konsolidieren. Wenn jedoch die `prev_size` von der Größe abweicht, die im vorherigen Chunk angegeben ist:
- Fehlermeldung: `corrupted size vs. prev_size while consolidating`

## **`_int_free_create_chunk`**

- **Überprüfungen in `_int_free_create_chunk`:**
- Hinzufügen eines Chunks in die unsortierte Bin, überprüfen, ob `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`:
- Fehlermeldung: `free(): corrupted unsorted chunks`

## `do_check_malloc_state`

- **Überprüfungen in `do_check_malloc_state`:**
- Wenn der schnelle Bin-Chunk nicht ausgerichtet ist:
- Fehlermeldung: `do_check_malloc_state(): unaligned fastbin chunk detected`

## `malloc_consolidate`

- **Überprüfungen in `malloc_consolidate`:**
- Wenn der schnelle Bin-Chunk nicht ausgerichtet ist:
- Fehlermeldung: `malloc_consolidate(): unaligned fastbin chunk detected`
- Wenn die Größe des schnellen Bin-Chunks falsch ist:
- Fehlermeldung: `malloc_consolidate(): invalid chunk size`

## `_int_realloc`

- **Überprüfungen in `_int_realloc`:**
- Größe ist zu groß oder zu klein:
- Fehlermeldung: `realloc(): invalid old size`
- Größe des nächsten Chunks ist zu groß oder zu klein:
- Fehlermeldung: `realloc(): invalid next size`

{{#include ../../../banners/hacktricks-training.md}}
