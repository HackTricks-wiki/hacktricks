# Kontrole bezpieczeństwa funkcji sterty

{{#include ../../../banners/hacktricks-training.md}}

## unlink

Aby uzyskać więcej informacji, sprawdź:

{{#ref}}
unlink.md
{{#endref}}

To jest podsumowanie przeprowadzonych kontroli:

- Sprawdź, czy wskazany rozmiar kawałka jest taki sam jak `prev_size` wskazany w następnym kawałku
- Komunikat o błędzie: `corrupted size vs. prev_size`
- Sprawdź również, czy `P->fd->bk == P` i `P->bk->fw == P`
- Komunikat o błędzie: `corrupted double-linked list`
- Jeśli kawałek nie jest mały, sprawdź, czy `P->fd_nextsize->bk_nextsize == P` i `P->bk_nextsize->fd_nextsize == P`
- Komunikat o błędzie: `corrupted double-linked list (not small)`

## \_int_malloc

Aby uzyskać więcej informacji, sprawdź:

{{#ref}}
malloc-and-sysmalloc.md
{{#endref}}

- **Kontrole podczas wyszukiwania szybkiego binu:**
- Jeśli kawałek jest źle wyrównany:
- Komunikat o błędzie: `malloc(): unaligned fastbin chunk detected 2`
- Jeśli kawałek do przodu jest źle wyrównany:
- Komunikat o błędzie: `malloc(): unaligned fastbin chunk detected`
- Jeśli zwrócony kawałek ma rozmiar, który nie jest poprawny z powodu jego indeksu w szybkim binie:
- Komunikat o błędzie: `malloc(): memory corruption (fast)`
- Jeśli jakikolwiek kawałek użyty do wypełnienia tcache jest źle wyrównany:
- Komunikat o błędzie: `malloc(): unaligned fastbin chunk detected 3`
- **Kontrole podczas wyszukiwania małego binu:**
- Jeśli `victim->bk->fd != victim`:
- Komunikat o błędzie: `malloc(): smallbin double linked list corrupted`
- **Kontrole podczas konsolidacji** przeprowadzane dla każdego kawałka szybkiego binu:
- Jeśli kawałek jest źle wyrównany, wyzwól:
- Komunikat o błędzie: `malloc_consolidate(): unaligned fastbin chunk detected`
- Jeśli kawałek ma inny rozmiar niż ten, który powinien mieć z powodu indeksu, w którym się znajduje:
- Komunikat o błędzie: `malloc_consolidate(): invalid chunk size`
- Jeśli poprzedni kawałek nie jest używany, a poprzedni kawałek ma rozmiar różny od tego wskazanego przez prev_chunk:
- Komunikat o błędzie: `corrupted size vs. prev_size in fastbins`
- **Kontrole podczas wyszukiwania nieposortowanego binu**:
- Jeśli rozmiar kawałka jest dziwny (za mały lub za duży):
- Komunikat o błędzie: `malloc(): invalid size (unsorted)`
- Jeśli rozmiar następnego kawałka jest dziwny (za mały lub za duży):
- Komunikat o błędzie: `malloc(): invalid next size (unsorted)`
- Jeśli rozmiar poprzedni wskazany przez następny kawałek różni się od rozmiaru kawałka:
- Komunikat o błędzie: `malloc(): mismatching next->prev_size (unsorted)`
- Jeśli nie `victim->bck->fd == victim` lub nie `victim->fd == av (arena)`:
- Komunikat o błędzie: `malloc(): unsorted double linked list corrupted`
- Ponieważ zawsze sprawdzamy ostatni, jego fd powinno zawsze wskazywać na strukturę areny.
- Jeśli następny kawałek nie wskazuje, że poprzedni jest używany:
- Komunikat o błędzie: `malloc(): invalid next->prev_inuse (unsorted)`
- Jeśli `fwd->bk_nextsize->fd_nextsize != fwd`:
- Komunikat o błędzie: `malloc(): largebin double linked list corrupted (nextsize)`
- Jeśli `fwd->bk->fd != fwd`:
- Komunikat o błędzie: `malloc(): largebin double linked list corrupted (bk)`
- **Kontrole podczas wyszukiwania dużego binu (według indeksu):**
- `bck->fd-> bk != bck`:
- Komunikat o błędzie: `malloc(): corrupted unsorted chunks`
- **Kontrole podczas wyszukiwania dużego binu (następny większy):**
- `bck->fd-> bk != bck`:
- Komunikat o błędzie: `malloc(): corrupted unsorted chunks2`
- **Kontrole podczas użycia Top chunk:**
- `chunksize(av->top) > av->system_mem`:
- Komunikat o błędzie: `malloc(): corrupted top size`

## `tcache_get_n`

- **Kontrole w `tcache_get_n`:**
- Jeśli kawałek jest źle wyrównany:
- Komunikat o błędzie: `malloc(): unaligned tcache chunk detected`

## `tcache_thread_shutdown`

- **Kontrole w `tcache_thread_shutdown`:**
- Jeśli kawałek jest źle wyrównany:
- Komunikat o błędzie: `tcache_thread_shutdown(): unaligned tcache chunk detected`

## `__libc_realloc`

- **Kontrole w `__libc_realloc`:**
- Jeśli stary wskaźnik jest źle wyrównany lub rozmiar był niepoprawny:
- Komunikat o błędzie: `realloc(): invalid pointer`

## `_int_free`

Aby uzyskać więcej informacji, sprawdź:

{{#ref}}
free.md
{{#endref}}

- **Kontrole na początku `_int_free`:**
- Wskaźnik jest wyrównany:
- Komunikat o błędzie: `free(): invalid pointer`
- Rozmiar większy niż `MINSIZE` i rozmiar również wyrównany:
- Komunikat o błędzie: `free(): invalid size`
- **Kontrole w `_int_free` tcache:**
- Jeśli jest więcej wpisów niż `mp_.tcache_count`:
- Komunikat o błędzie: `free(): too many chunks detected in tcache`
- Jeśli wpis nie jest wyrównany:
- Komunikat o błędzie: `free(): unaligned chunk detected in tcache 2`
- Jeśli zwolniony kawałek był już zwolniony i jest obecny jako kawałek w tcache:
- Komunikat o błędzie: `free(): double free detected in tcache 2`
- **Kontrole w `_int_free` szybkim binie:**
- Jeśli rozmiar kawałka jest nieprawidłowy (za duży lub za mały), wyzwól:
- Komunikat o błędzie: `free(): invalid next size (fast)`
- Jeśli dodany kawałek był już na szczycie szybkiego binu:
- Komunikat o błędzie: `double free or corruption (fasttop)`
- Jeśli rozmiar kawałka na szczycie ma inny rozmiar niż kawałek, który dodajemy:
- Komunikat o błędzie: `invalid fastbin entry (free)`

## **`_int_free_merge_chunk`**

- **Kontrole w `_int_free_merge_chunk`:**
- Jeśli kawałek jest kawałkiem szczytowym:
- Komunikat o błędzie: `double free or corruption (top)`
- Jeśli następny kawałek jest poza granicami areny:
- Komunikat o błędzie: `double free or corruption (out)`
- Jeśli kawałek nie jest oznaczony jako używany (w prev_inuse z następującego kawałka):
- Komunikat o błędzie: `double free or corruption (!prev)`
- Jeśli następny kawałek ma zbyt mały lub zbyt duży rozmiar:
- Komunikat o błędzie: `free(): invalid next size (normal)`
- Jeśli poprzedni kawałek nie jest używany, spróbuje skonsolidować. Ale jeśli `prev_size` różni się od rozmiaru wskazanego w poprzednim kawałku:
- Komunikat o błędzie: `corrupted size vs. prev_size while consolidating`

## **`_int_free_create_chunk`**

- **Kontrole w `_int_free_create_chunk`:**
- Dodając kawałek do nieposortowanego binu, sprawdź, czy `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`:
- Komunikat o błędzie: `free(): corrupted unsorted chunks`

## `do_check_malloc_state`

- **Kontrole w `do_check_malloc_state`:**
- Jeśli kawałek szybkiego binu jest źle wyrównany:
- Komunikat o błędzie: `do_check_malloc_state(): unaligned fastbin chunk detected`

## `malloc_consolidate`

- **Kontrole w `malloc_consolidate`:**
- Jeśli kawałek szybkiego binu jest źle wyrównany:
- Komunikat o błędzie: `malloc_consolidate(): unaligned fastbin chunk detected`
- Jeśli rozmiar kawałka szybkiego binu jest niepoprawny:
- Komunikat o błędzie: `malloc_consolidate(): invalid chunk size`

## `_int_realloc`

- **Kontrole w `_int_realloc`:**
- Rozmiar jest za duży lub za mały:
- Komunikat o błędzie: `realloc(): invalid old size`
- Rozmiar następnego kawałka jest za duży lub za mały:
- Komunikat o błędzie: `realloc(): invalid next size`

{{#include ../../../banners/hacktricks-training.md}}
