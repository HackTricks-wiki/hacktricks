# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## 基本信息

这是一个非常有趣的技术，通过 fake fastbins、the unsorted_bin attack 和 relative overwrites 可以在没有 leaks 的情况下实现 RCE。然而它已经 [**patched**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c)。

### 在2026年的适用性

- **glibc window:** 在 **2.23–2.28** 上可以可靠工作。在 **2.29** 上，额外的 `unsorted_chunks` 完整性检查使得 unsorted‑bin 写入变得不可靠，成功率急剧下降。从 **2.34** 开始移除了 `__malloc_hook/__free_hook`，使得原始目标不可用。仅在老的 libc（或保留这些 hooks 的自定义构建）或 CTF 挑战中使用它。
- **Tcache era (≥2.26):** Tcache 会吞掉你的 0x70 分配并阻断 fastbin/unsorted 原语。要么在任何分配之前禁用它（`setenv("GLIBC_TUNABLES","glibc.malloc.tcache_count=0",1);`），要么对每个 0x70 tcache bin 做 7 次 free 来耗尽它。
- **Safe-linking:** 它适用于 ≥2.32 的 tcache/fastbin，但 House of Roman 仅需要对已存在于 fd/bk 中的 libc 地址进行部分指针覆盖，所以 safe-linking 对防御方没有帮助（攻击者从不伪造新的指针）。真正的阻碍是 hook 的移除和 unsorted-bin 的检查。

### 代码

- 你可以在 [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c) 找到一个示例

### 目标

- 通过滥用相对指针实现 RCE

### 要求

- 编辑 fastbin 和 unsorted bin 指针
- 需要暴力破解 12 位随机性（约 0.02% 的成功概率）

## 攻击步骤

### 第1部分：Fastbin Chunk 指向 \_\_malloc_hook

创建多个 chunks：

- `fastbin_victim` (0x60, offset 0): 一个 UAF chunk，稍后用于编辑 heap 指针，使其指向 LibC 的值。
- `chunk2` (0x80, offset 0x70): 用于良好对齐
- `main_arena_use` (0x80, offset 0x100)
- `relative_offset_heap` (0x60, offset 0x190): 在 `main_arena_use` chunk 上的相对偏移

然后 `free(main_arena_use)`，这会将该 chunk 放入 unsorted 列表，并使 `fd` 和 `bk` 指针都获得指向 `main_arena + 0x68` 的指针。

现在分配一个新的 chunk `fake_libc_chunk(0x60)`，因为它将在 `fd` 和 `bk` 中包含指向 `main_arena + 0x68` 的指针。

然后释放 `relative_offset_heap` 和 `fastbin_victim`。
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- `fastbin_victim` 有一个 `fd` 指向 `relative_offset_heap`
- `relative_offset_heap` 是相对于 `fake_libc_chunk` 的一个偏移，后者包含一个指向 `main_arena + 0x68` 的指针
- 修改 `fastbin_victim.fd` 的最后一个字节会使 `fastbin_victim` 指向 `main_arena + 0x68`。

要完成上述操作，攻击者需要能够修改 `fastbin_victim` 的 fd 指针。

然后，`main_arena + 0x68` 并不那么有趣，所以我们把它修改为指向 **`__malloc_hook`**。

注意 `__memalign_hook` 通常以 `0x7f` 开头，前面是零，因此可以伪造为 `0x70` fast bin 中的一个值。因为地址的最后 4 位是 **随机**，所以有 `2^4=16` 种可能使该值指向我们感兴趣的地方。因此这里进行 BF attack，使得 chunk 末尾看起来像：**`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`.**

(For more info about the rest of the bytes check the explanation in the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)). If the brute force fails the program just crashes (restart until it works).

然后，执行 2 次 malloc 来移除最初的 2 个 fast bin chunk，再分配第三个以在 **`__malloc_hook`** 获取一个 chunk。
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### Part 2: Unsorted_bin attack

更多信息请参见：

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

但基本上它允许将 `main_arena + 0x68` 写入到 `chunk->bk` 指定的任意位置。对于此次攻击我们选择 `__malloc_hook`。在覆盖它之后，我们将使用 relative overwrite 将其指向一个 `one_gadget`。

为此，我们首先获取一个 chunk 并将其放入 **unsorted bin**：
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
Use an UAF in this chunk to point `unsorted_bin_ptr->bk` to the address of `__malloc_hook` (we brute forced this previously).

> [!CAUTION]
> 注意此攻击会破坏 unsorted bin（因此 small 和 large 也会受到影响）。所以我们现在只能 **use allocations from the fast bin now**（更复杂的程序可能会做其他分配并崩溃），并且为触发这个我们必须 **alloc the same size or the program will crash.**

So, to trigger the write of `main_arena + 0x68` in `__malloc_hook` we perform after setting `__malloc_hook` in `unsorted_bin_ptr->bk` we just need to do: **`malloc(0x80)`**

### 第 3 步：将 \_\_malloc_hook 设置为 system

在第一步中我们控制了包含 `__malloc_hook` 的 chunk（在变量 `malloc_hook_chunk` 中），在第二步我们设法在那里写入了 `main_arena + 0x68`。

现在，我们利用对 `malloc_hook_chunk` 的部分覆盖，使用我们写入的 libc 地址（`main_arena + 0x68`）来 **指向一个 `one_gadget` 地址**。

这时需要 **bruteforce 12 bits of randomness**（更多信息见 the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)）。

最后，一旦正确地址被覆盖，**调用 `malloc` 并触发 `one_gadget`**。

## 现代技巧与变体

- **Unsorted-bin check in 2.29+:** 如果必须在 2.29–2.33 上运行，在触发写入前同时破坏 `fd` **和** `bk` 以满足完整性检查；否则 `_int_malloc` 会中止。成功率很低，通常只有在 brute-force CTF 情况下可行。
- **Hook removal (2.34+):** 在 `__malloc_hook` 被移除的情况下，将该原语调整为落在任何可写的 GOT/全局变量上以供后续重用（例如在非-PIE 二进制中覆盖 `exit@GOT`），或 pivot 到 **House of Pie** 风格的 top‑chunk 劫持，控制 `top` 而不是 hook。
- **Any‑address fastbin alloc (2024 gist):** 最近的一篇 writeup 展示了重用相同的 grooming 来在 fastbin 上分配覆盖 `__free_hook` 或其他全局变量：先将 libc 指针放入 fastbin，然后在修复前重新指向它。这在 2.24–2.28 生效，但在 2.29 的完整性检查上仍然失败。

## 参考资料

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)
- [https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html](https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html)
- [https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc](https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc)

{{#include ../../banners/hacktricks-training.md}}
