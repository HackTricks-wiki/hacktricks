# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## 기본 정보

이 기법은 fake fastbins, unsorted_bin attack 및 relative overwrites를 통해 leaks 없이 RCE를 가능하게 한 매우 흥미로운 기술이었다. 그러나 [**patched**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c) 되었다.

### 2026에서의 적용성

- **glibc window:** **2.23–2.28**에서 신뢰성 있게 동작한다. **2.29**에서는 추가적인 `unsorted_chunks` 무결성 검사가 unsorted‑bin 쓰기를 불안정하게 만들어 성공률이 급락한다. **2.34**부터는 `__malloc_hook/__free_hook`가 제거되어 원래의 타깃이 사라졌다. 오래된 libc(또는 훅을 유지한 커스텀 빌드)나 구형 libc를 제공하는 CTF에서만 사용하라.
- **Tcache era (≥2.26):** Tcache는 0x70 할당들을 가로채 fastbin/unsorted 원시(primitives)를 멈추게 한다. 할당 이전에(`setenv("GLIBC_TUNABLES","glibc.malloc.tcache_count=0",1);`) 비활성화하거나 각 0x70 tcache bin을 7회의 free로 채워 비워라.
- **Safe-linking:** ≥2.32에서 tcache/fastbin에 적용되지만, House of Roman은 이미 `fd`/`bk`에 존재하는 libc 주소의 **partial pointer overwrite**만 필요로 하므로 safe-linking은 방어자에게 큰 도움이 되지 않는다(공격자는 새로운 포인터를 위조하지 않음). 실제로 큰 제약은 훅 제거와 unsorted-bin 검사이다.

### 코드

- 예제는 [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)에서 확인할 수 있다.

### 목표

- relative pointers를 악용한 RCE

### 요구사항

- fastbin 및 unsorted bin 포인터 수정
- 12 비트의 무작위성은 브루트포스로 찾아야 하며(성공 확률 0.02%) 운에 따라 달라진다

## 공격 단계

### Part 1: Fastbin 청크가 \_\_malloc_hook를 가리키게

몇 개의 청크를 생성한다:

- `fastbin_victim` (0x60, offset 0): 나중에 heap 포인터를 수정해 LibC 값을 가리키게 할 UAF 청크.
- `chunk2` (0x80, offset 0x70): 정렬을 위해
- `main_arena_use` (0x80, offset 0x100)
- `relative_offset_heap` (0x60, offset 0x190): `'main_arena_use'` 청크에 대한 상대적 오프셋

그런 다음 `free(main_arena_use)`를 호출하면 이 청크가 unsorted list에 들어가고 `fd` 및 `bk` 포인터 둘 다에 `main_arena + 0x68`에 대한 포인터가 들어간다.

그 후 `fake_libc_chunk(0x60)`를 할당한다 — 이 청크는 `fd`와 `bk`에 `main_arena + 0x68`에 대한 포인터를 담게 된다.

그런 다음 `relative_offset_heap`와 `fastbin_victim`을 free한다.
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- `fastbin_victim`의 `fd`는 `relative_offset_heap`를 가리킨다.
- `relative_offset_heap`는 `fake_libc_chunk`로부터의 오프셋이며, 해당 청크는 `main_arena + 0x68`에 대한 포인터를 포함한다.
- `fastbin_victim.fd`의 마지막 바이트를 변경하면 `fastbin_victim`가 `main_arena + 0x68`를 가리키게 된다.

이전 동작들을 위해 공격자는 `fastbin_victim`의 fd 포인터를 수정할 수 있어야 한다.

그런 다음, `main_arena + 0x68`는 그다지 흥미롭지 않으므로 포인터가 **`__malloc_hook`**를 가리키도록 수정하자.

참고로 `__memalign_hook`는 보통 `0x7f`로 시작하고 앞부분이 0으로 채워지기 때문에 `0x70` fast bin 안의 값으로 위조하는 것이 가능하다. 주소의 마지막 4비트가 **무작위**이기 때문에 값이 우리가 관심있는 위치를 가리키도록 끝날 수 있는 경우의 수는 `2^4=16`이다. 그래서 여기서 BF 공격을 수행하여 청크는 다음과 같이 끝난다: **`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`.**

(For more info about the rest of the bytes check the explanation in the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)). If the brute force fails the program just crashes (restart until it works).

그런 다음, 2번의 malloc이 수행되어 처음의 2개의 fast bin chunks를 제거하고 세 번째 할당을 통해 **`__malloc_hook`**에 청크를 얻는다.
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### 파트 2: Unsorted_bin attack

자세한 내용은 다음을 확인하세요:

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

하지만 기본적으로 이는 `chunk->bk`에 지정된 임의의 위치에 `main_arena + 0x68`를 쓸 수 있게 합니다. 공격에서는 `__malloc_hook`을 선택합니다. 이를 덮어쓴 뒤에는 relative overwrite를 사용해 `one_gadget`를 가리키게 합니다.

이를 위해 우리는 chunk를 얻어 **unsorted bin**에 넣는 것으로 시작합니다:
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
Use an UAF in this chunk to point `unsorted_bin_ptr->bk` to the address of `__malloc_hook` (we brute forced this previously).

> [!CAUTION]
> 이 공격은 unsorted bin을 손상시킵니다 (따라서 small과 large도 영향받습니다). 그래서 이제부터는 **fast bin에서의 할당만 사용할 수 있습니다** (더 복잡한 프로그램은 다른 할당을 수행해 크래시할 수 있습니다). 그리고 이를 트리거하려면 **같은 크기로 alloc해야 합니다. 그렇지 않으면 프로그램이 크래시합니다.**

So, to trigger the write of `main_arena + 0x68` in `__malloc_hook` we perform after setting `__malloc_hook` in `unsorted_bin_ptr->bk` we just need to do: **`malloc(0x80)`**

### 3단계: \_\_malloc_hook을 system으로 설정

In step one we controlled a chunk containing `__malloc_hook` (in the variable `malloc_hook_chunk`) and in the second step we managed to write `main_arena + 0x68` there.

이제 `malloc_hook_chunk`에서 부분 덮어쓰기(partial overwrite)를 악용하여 거기에 쓴 libc 주소(`main_arena + 0x68`)를 사용해 **`one_gadget` 주소를 가리키게** 만듭니다.

여기서 12비트 난수성을 **bruteforce**해야 합니다 (자세한 내용은 the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c) 참조).

마지막으로, 올바른 주소가 덮어써지면 **`malloc`을 호출하여 `one_gadget`을 트리거**합니다.

## 최신 팁 & 변형

- **Unsorted-bin check in 2.29+:** 2.29–2.33에서 실행해야 한다면, 쓰기를 트리거하기 전에 무결성 검사를 통과시키기 위해 `fd` **및** `bk`를 모두 손상시켜야 합니다; 그렇지 않으면 `_int_malloc`이 abort합니다. 성공률은 매우 낮아 보통 brute-force CTF 환경에서만 실용적입니다.
- **Hook removal (2.34+):** `__malloc_hook`이 제거된 경우, primitive를 나중에 재사용할 수 있는 쓰기 가능한 GOT/글로벌로 착지시키도록 적응시키거나(예: non-PIE 바이너리의 `exit@GOT` 덮어쓰기), 훅 대신 `top`을 제어하기 위해 **House of Pie** 스타일의 top‑chunk 하이재킹으로 피벗하세요.
- **Any‑address fastbin alloc (2024 gist):** 최근 글은 같은 grooming을 재사용해 먼저 fastbin에 libc 포인터를 착지시키고 fixup 전에 재지정함으로써 `__free_hook`이나 다른 글로벌 위로 fastbin 할당을 수행하는 방법을 보여줍니다. 이것은 2.24–2.28에서 동작하지만 2.29의 무결성 검사에서는 실패합니다.

## 참고자료

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)
- [https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html](https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html)
- [https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc](https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc)

{{#include ../../banners/hacktricks-training.md}}
