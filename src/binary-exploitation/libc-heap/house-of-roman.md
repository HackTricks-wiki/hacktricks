# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## Podstawowe informacje

This was a very interesting technique that allowed for RCE without leaks via fake fastbins, the unsorted_bin attack and relative overwrites. However it has been [**patched**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c).

### Przydatność w 2026

- **glibc window:** Works reliably on **2.23–2.28**. On **2.29** the additional `unsorted_chunks` integrity checks make the unsorted‑bin write unreliable, so success drops sharply. From **2.34** onward `__malloc_hook/__free_hook` were removed, making the original target unavailable. Use it only on old libc’s (or custom builds that keep the hooks) or for CTF challenges that ship an old libc.
- **Tcache era (≥2.26):** Tcache will eat your 0x70 allocations and stop the fastbin/unsorted primitives. Disable it (`setenv("GLIBC_TUNABLES","glibc.malloc.tcache_count=0",1);`) **before** any allocation or fill each 0x70 tcache bin with 7 frees to drain it.
- **Safe-linking:** It applies to tcache/fastbin in ≥2.32, but House of Roman only needs **partial pointer overwrite of a libc address already present in fd/bk**, so safe-linking does not help the defender here (the attacker never forges a fresh pointer). The real stopper is the hook removal and the unsorted-bin checks.

### Kod

- You can find an example in [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)

### Cel

- RCE by abusing relative pointers

### Wymagania

- Edit fastbin and unsorted bin pointers
- 12 bits of randomness must be brute forced (0.02% chance) of working

## Kroki ataku

### Część 1: Fastbin Chunk wskazuje na \_\_malloc_hook

Utwórz kilka chunków:

- `fastbin_victim` (0x60, offset 0): UAF chunk later to edit the heap pointer later to point to the LibC value.
- `chunk2` (0x80, offset 0x70): For good alignment
- `main_arena_use` (0x80, offset 0x100)
- `relative_offset_heap` (0x60, offset 0x190): relative offset on the 'main_arena_use' chunk

Then `free(main_arena_use)` which will place this chunk in the unsorted list and will get a pointer to `main_arena + 0x68` in both the `fd` and `bk` pointers.

Now it's allocated a new chunk `fake_libc_chunk(0x60)` because it'll contain the pointers to `main_arena + 0x68` in `fd` and `bk`.

Then `relative_offset_heap` and `fastbin_victim` are freed.
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- `fastbin_victim` ma `fd` wskazujący na `relative_offset_heap`
- `relative_offset_heap` jest przesunięciem względem `fake_libc_chunk`, który zawiera wskaźnik do `main_arena + 0x68`
- Zmiana ostatniego bajtu `fastbin_victim.fd` powoduje, że `fastbin_victim` wskazuje na `main_arena + 0x68`.

Do powyższych działań atakujący musi być w stanie zmodyfikować wskaźnik fd `fastbin_victim`.

Następnie, `main_arena + 0x68` nie jest aż tak interesujące, więc zmodyfikujmy je tak, aby wskaźnik wskazywał na **`__malloc_hook`**.

Zauważ, że `__memalign_hook` zazwyczaj zaczyna się od `0x7f` z zerami przed nim, więc można go sfałszować jako wartość w fast binie `0x70`. Ponieważ ostatnie 4 bity adresu są **random** istnieje `2^4=16` możliwości, by wartość wskazała tam, gdzie chcemy. Dlatego tu wykonywany jest atak BF, dzięki któremu chunk kończy się tak: **`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`.**

(For more info about the rest of the bytes check the explanation in the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)). Jeśli brute force się nie powiedzie, program po prostu crashuje (restart until it works).

Następnie wykonywane są 2 mallocs, aby usunąć 2 początkowe fast bin chunks, a trzeci jest alokowany, by uzyskać chunk w **`__malloc_hook`**.
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### Część 2: Unsorted_bin attack

Więcej informacji znajdziesz w:

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

W skrócie pozwala to zapisać `main_arena + 0x68` w dowolnej lokalizacji wskazanej przez `chunk->bk`. Do ataku wybieramy `__malloc_hook`. Następnie, po jego nadpisaniu, użyjemy relative overwrite, aby skierować go na `one_gadget`.

W tym celu zaczynamy od pobrania chunk i umieszczenia go w **unsorted bin**:
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
Użyj UAF w tym chunku, aby wskazać `unsorted_bin_ptr->bk` na adres `__malloc_hook` (we brute forced this previously).

> [!CAUTION]
> Note that this attack corrupts the unsorted bin (hence small and large too). So we can only **use allocations from the fast bin now** (a more complex program might do other allocations and crash), and to trigger this we must **alloc the same size or the program will crash.**

Tak więc, aby wywołać zapis `main_arena + 0x68` do `__malloc_hook`, po ustawieniu `__malloc_hook` w `unsorted_bin_ptr->bk` wystarczy wykonać: **`malloc(0x80)`**

### Krok 3: Ustaw \_\_malloc_hook na system

W kroku pierwszym kontrolowaliśmy chunk zawierający `__malloc_hook` (w zmiennej `malloc_hook_chunk`), a w drugim kroku udało nam się tam zapisać `main_arena + 0x68`.

Teraz nadużywamy partial overwrite w `malloc_hook_chunk`, aby użyć adresu libc, który tam zapisaliśmy (`main_arena + 0x68`), aby **wskazać na adres `one_gadget`**.

Tutaj trzeba **bruteforce 12 bits of randomness** (more info in the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)).

W końcu, gdy poprawny adres zostanie nadpisany, **wywołaj `malloc` i wyzwól `one_gadget`**.

## Nowoczesne wskazówki & warianty

- **Unsorted-bin check in 2.29+:** Jeśli musisz uruchomić na 2.29–2.33, skorumpuj zarówno `fd` **and** `bk`, aby spełnić kontrolę integralności przed wywołaniem zapisu; w przeciwnym razie `_int_malloc` aborts. Wskaźnik powodzenia jest bardzo niski i zwykle możliwy tylko w brute-force CTF settings.
- **Hook removal (2.34+):** With `__malloc_hook` gone, adapt the primitive to land on any writable GOT/global you can later reuse (e.g., overwrite `exit@GOT` in non-PIE binaries) or pivot to a **House of Pie** style top‑chunk hijack to control `top` instead of a hook.
- **Any‑address fastbin alloc (2024 gist):** A recent writeup shows reusing the same grooming to fastbin‑allocate over `__free_hook` or other globals by first landing a libc pointer in fastbin and then re‑pointing it before the fixup. This works on 2.24–2.28 but still dies on 2.29 integrity checks.

## Źródła

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)
- [https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html](https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html)
- [https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc](https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc)

{{#include ../../banners/hacktricks-training.md}}
