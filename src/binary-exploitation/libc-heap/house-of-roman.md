# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## Основна інформація

Це була дуже цікава техніка, що дозволяла отримати RCE без leaks через fake fastbins, unsorted_bin attack та relative overwrites. Проте вона була [**виправлена**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c).

### Застосовність у 2026

- **glibc window:** Працює надійно на **2.23–2.28**. На **2.29** додаткові перевірки цілісності `unsorted_chunks` роблять запис в unsorted‑bin ненадійним, тому ймовірність успіху різко падає. Починаючи з **2.34** `__malloc_hook/__free_hook` були видалені, що робить первинну ціль недоступною. Використовуйте тільки на старих libc (або кастомних збірках, що зберігають ці hooks) або для CTF-завдань, які постачають старий libc.
- **Tcache era (≥2.26):** Tcache "з'їсть" ваші алокації 0x70 і зупинить fastbin/unsorted primitives. Вимкніть його (`setenv("GLIBC_TUNABLES","glibc.malloc.tcache_count=0",1);`) **перед** будь‑якою алокацією або заповніть кожен 0x70 tcache bin сімома frees, щоб його спорожнити.
- **Safe-linking:** Застосовується до tcache/fastbin у версіях ≥2.32, але House of Roman потребує лише **partial pointer overwrite of a libc address already present in fd/bk**, тому safe-linking тут не допомагає захиснику (атакуючий ніколи не підробляє новий вказівник). Справжнім блокувальником є видалення hooks та перевірки unsorted-bin.

### Код

- You can find an example in [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)

### Мета

- RCE шляхом зловживання relative pointers

### Вимоги

- Edit fastbin and unsorted bin pointers
- 12 bits of randomness must be brute forced (0.02% chance) of working

## Кроки атаки

### Частина 1: Fastbin Chunk вказує на \_\_malloc_hook

Створіть кілька chunks:

- `fastbin_victim` (0x60, offset 0): UAF chunk, який пізніше буде використаний для редагування вказівника heap, щоб вказати на значення LibC.
- `chunk2` (0x80, offset 0x70): Для гарного вирівнювання
- `main_arena_use` (0x80, offset 0x100)
- `relative_offset_heap` (0x60, offset 0x190): relative offset на chunk'і `main_arena_use`

Потім виконайте `free(main_arena_use)`, що помістить цей chunk в unsorted list і запише в обидва поля `fd` і `bk` вказівник на `main_arena + 0x68`.

Тепер виділіть новий chunk `fake_libc_chunk(0x60)`, бо він буде містити вказівники на `main_arena + 0x68` в `fd` та `bk`.

Потім `relative_offset_heap` і `fastbin_victim` звільняються (freed).
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- `fastbin_victim` має `fd`, що вказує на `relative_offset_heap`
- `relative_offset_heap` — це зміщення від `fake_libc_chunk`, який містить вказівник на `main_arena + 0x68`
- Зміна останнього байта `fastbin_victim.fd` змушує `fastbin_victim` вказувати на `main_arena + 0x68`.

Для вищезгаданих дій атакувальник повинен мати можливість змінювати вказівник fd у `fastbin_victim`.

Потім, `main_arena + 0x68` не таке цікаве, тож змодифікуємо його, щоб вказівник вказував на **`__malloc_hook`**.

Зверніть увагу, що `__memalign_hook` зазвичай починається з `0x7f` і перед цим містить нулі, тому його можна підробити як значення в `0x70` fast bin. Оскільки останні 4 біти адреси є **випадковими**, існує `2^4=16` можливостей, куди в кінці вкаже значення, яке нас цікавить. Тому тут виконується BF attack, тож чанки закінчуються так: **`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`.**

(For more info about the rest of the bytes check the explanation in the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)). Якщо brute force не вдається, програма просто падає (перезапускайте, поки не спрацює).

Потім виконуються 2 mallocs, щоб видалити 2 початкові fast bin chunks, а третій виділяється, щоб отримати chunk у **`__malloc_hook`**.
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### Частина 2: Unsorted_bin attack

Більше інформації дивіться:

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

Але по суті це дозволяє записати `main_arena + 0x68` у будь-яке місце, вказане в `chunk->bk`. Для атаки ми обираємо `__malloc_hook`. Потім, після його перезапису, ми використаємо relative overwrite, щоб вказати на `one_gadget`.

Для цього ми спочатку виділяємо chunk і поміщаємо його в **unsorted bin**:
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
Use an UAF in this chunk to point `unsorted_bin_ptr->bk` to the address of `__malloc_hook` (we brute forced this previously).

> [!CAUTION]
> Зверніть увагу, що ця атака корумпує unsorted bin (а отже й small і large). Тому тепер ми можемо **використовувати лише виділення з fast bin** (складніша програма могла б виконати інші виділення та впасти), і щоб це спрацювало, ми маємо **робити alloc того самого розміру або програма впаде.**

So, to trigger the write of `main_arena + 0x68` in `__malloc_hook` we perform after setting `__malloc_hook` in `unsorted_bin_ptr->bk` we just need to do: **`malloc(0x80)`**

### Крок 3: Встановити \_\_malloc_hook на system

In step one we controlled a chunk containing `__malloc_hook` (in the variable `malloc_hook_chunk`) and in the second step we managed to write `main_arena + 0x68` there.

Now, we abuse a partial overwrite in `malloc_hook_chunk` to use the libc address we wrote there (`main_arena + 0x68`) to **point to a `one_gadget` address**.

Here is where it's needed to **bruteforce 12 bits of randomness** (more info in the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)).

Finally, once the correct address is overwritten, **call `malloc` and trigger the `one_gadget`**.

## Сучасні поради & варіанти

- **Unsorted-bin check in 2.29+:** Якщо потрібно виконувати на 2.29–2.33, корумпуйте обидва `fd` **і** `bk`, щоб задовольнити перевірку цілісності перед тригером запису; інакше `_int_malloc` завершує роботу. Рівень успіху дуже низький і зазвичай придатний лише для brute-force CTF.
- **Hook removal (2.34+):** Якщо `__malloc_hook` відсутній, адаптуйте примітив, щоб потрапити на будь-яку записувану GOT/глобальну адресу, яку згодом можна повторно використати (наприклад, перезаписати `exit@GOT` в non-PIE бінарях), або переключіться на топ-чанк‑хайджек у стилі **House of Pie**, щоб контролювати `top` замість hook.
- **Any‑address fastbin alloc (2024 gist):** Недавній розбір показує повторне використання того ж grooming для fastbin‑виділення поверх `__free_hook` або інших глобалів, спочатку поміщаючи libc-указівник у fastbin, а потім перепризначаючи його перед фіксацією. Це працює на 2.24–2.28, але все ще ламається через перевірки цілісності в 2.29.

## References

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)
- [https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html](https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html)
- [https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc](https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc)

{{#include ../../banners/hacktricks-training.md}}
