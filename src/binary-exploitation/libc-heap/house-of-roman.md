# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## 基本情報

これは fake fastbins、unsorted_bin attack、relative overwrites を介して leaks なしで RCE を引き起こせる非常に興味深い手法でした。ただし、[**patched**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c)されています。

### 2026年での適用性

- **glibc window:** **2.23–2.28** で安定して動作します。**2.29** では追加の `unsorted_chunks` 整合性チェックにより unsorted‑bin の書き込みが不安定になり成功率が大きく低下します。**2.34** 以降は `__malloc_hook/__free_hook` が削除され、元のターゲットが利用できなくなりました。古い libc（またはフックを残すカスタムビルド）、あるいは古い libc を同梱する CTF のみで使用してください。
- **Tcache era (≥2.26):** Tcache は 0x70 の割当てを吸い取り、fastbin/unsorted プリミティブを止めます。これを無効化するか（`setenv("GLIBC_TUNABLES","glibc.malloc.tcache_count=0",1);`）、0x70 tcache bin をそれぞれ 7 回の free で満たしてドレインしてください。無効化は割り当ての **前** に行ってください。
- **Safe-linking:** ≥2.32 の tcache/fastbin に適用されますが、House of Roman は既に `fd`/`bk` に存在する libc アドレスの **partial pointer overwrite of a libc address already present in fd/bk** のみを必要とするため、safe-linking は防御側にとって有利には働きません（攻撃者は新しいポインタを偽造しません）。本当の阻害要因はフックの削除と unsorted‑bin のチェックです。

### Code

- サンプルは [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c) にあります。

### 目的

- relative pointers を悪用して RCE

### 要件

- fastbin と unsorted bin のポインタを編集できること
- 12 ビットのランダム性をブルートフォースする必要があり（成功確率 0.02%）

## 攻撃手順

### パート1: Fastbin Chunk が __malloc_hook を指すように

いくつかのチャンクを作成します:

- `fastbin_victim` (0x60, offset 0): 後で UAF してヒープポインタを編集し、LibC の値を指させるチャンク。
- `chunk2` (0x80, offset 0x70): アラインメント確保用
- `main_arena_use` (0x80, offset 0x100)
- `relative_offset_heap` (0x60, offset 0x190): `main_arena_use` チャンク上の相対オフセット

その後 `free(main_arena_use)` を行うと、このチャンクは unsorted リストに入れられ、`fd` と `bk` の両方に `main_arena + 0x68` へのポインタが入ります。

次に、新しいチャンク `fake_libc_chunk(0x60)` を割り当てます。これは `fd` と `bk` に `main_arena + 0x68` へのポインタを含むためです。

その後 `relative_offset_heap` と `fastbin_victim` を free します。
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- `fastbin_victim` は `fd` が `relative_offset_heap` を指している
- `relative_offset_heap` は `fake_libc_chunk` からのオフセットで、`fake_libc_chunk` は `main_arena + 0x68` を指すポインタを含んでいる
- `fastbin_victim.fd` の末尾バイトを変更すると、`fastbin_victim` が `main_arena + 0x68` を指すようになる。

前述の操作には、攻撃者が `fastbin_victim` の fd ポインタを変更できる必要がある。

それでは、`main_arena + 0x68` はそれほど興味深くないので、ポインタが **`__malloc_hook`** を指すように変更しよう。

注意：`__memalign_hook` は通常 `0x7f` で始まり、その前はゼロなので、`0x70` fast bin の値として偽装することが可能である。アドレスの下位4ビットは **ランダム** なため、目的の場所を指す可能性は `2^4=16` 通りある。したがってここでは BF attack を行い、チャンクは次のように終わる：**`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`.**

(残りのバイトの詳細については [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c) の説明を参照してください)。If the brute force fails the program just crashes (restart until it works).

その後、2回の malloc を行って最初の2つの fast bin チャンクを取り除き、3回目の malloc で **`__malloc_hook`** にチャンクを取得する。
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### パート2: Unsorted_bin attack

For more info you can check:

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

基本的には、`chunk->bk`で指定された任意の場所に`main_arena + 0x68`を書き込めます。今回の攻撃では`__malloc_hook`を選びます。上書きした後はrelative overwriteを使って`one_gadget`を指すようにします。

そのために、まずchunkを取得して**unsorted bin**に入れます:
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
このチャンクでUAFを使い、`unsorted_bin_ptr->bk` を `__malloc_hook` のアドレスに向けます（これは以前にbrute forcedしました）。

> [!CAUTION]
> この攻撃はunsorted binを破損します（smallやlargeも同様に影響します）。したがって、今は**use allocations from the fast bin now** のみを使えます（より複雑なプログラムは他の割り当てを行いクラッシュする可能性があります）。また、これをトリガーするには **alloc the same size or the program will crash.**

したがって、`__malloc_hook` に `main_arena + 0x68` の書き込みをトリガーするには、`__malloc_hook` を `unsorted_bin_ptr->bk` に設定した後に単に **`malloc(0x80)`** を実行すれば良いです。

### Step 3: Set \_\_malloc_hook to system

ステップ1で、`__malloc_hook` を含むチャンク（変数名 `malloc_hook_chunk`）を制御しました。ステップ2では、そこに `main_arena + 0x68` を書き込むことに成功しました。

ここで、`malloc_hook_chunk` に対する部分上書きを悪用して、そこに書いたlibcアドレス（`main_arena + 0x68`）を使い、**one_gadgetのアドレスを指すように**します。

ここで12ビットのランダム性をbruteforceする必要があります（詳細は how2heap の [example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c) を参照）。

最後に、正しいアドレスに上書きできたら、`malloc` を呼び出して `one_gadget` をトリガーします。

## Modern tips & variants

- **Unsorted-bin check in 2.29+:** 2.29–2.33上で動かす必要がある場合、書き込みをトリガーする前に整合性チェックを満たすために `fd` と `bk` の両方を破損させてください；そうしないと `_int_malloc` が abort します。成功率は非常に低く、通常はbrute-forceのCTF環境でのみ現実的です。
- **Hook removal (2.34+):** `__malloc_hook` が無くなった環境では、プリミティブを調整して後で再利用できる任意の書き込み可能なGOT/グローバルに着地させる（例えば non-PIE バイナリで `exit@GOT` を上書きする）か、House of Pieスタイルのtop‑chunkハイジャックにピボットして hook の代わりに `top` を制御するようにしてください。
- **Any‑address fastbin alloc (2024 gist):** 最近の調査では、同じグルーミングを再利用して `__free_hook` などの上にfastbinで割り当てを行う手法が示されています。まずlibcポインタをfastbinに置き、その後fixup前に再指向する方法です。これは2.24–2.28で動作しますが、2.29の整合性チェックでは失敗します。

## References

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)
- [https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html](https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html)
- [https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc](https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc)

{{#include ../../banners/hacktricks-training.md}}
