# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## Informations de base

C'était une technique très intéressante qui permettait une RCE sans leaks via fake fastbins, l'attaque unsorted_bin et les relative overwrites. Cependant elle a été [**patched**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c).

### Applicabilité en 2026

- **glibc window:** Fonctionne de manière fiable sur **2.23–2.28**. Sur **2.29**, les vérifications d'intégrité supplémentaires de `unsorted_chunks` rendent l'écriture dans unsorted‑bin peu fiable, donc le taux de réussite chute fortement. À partir de **2.34**, `__malloc_hook/__free_hook` ont été retirés, rendant la cible originale indisponible. Ne l'utilisez que sur de vieilles libc (ou des builds personnalisés qui conservent les hooks) ou pour des challenges CTF qui fournissent une vieille libc.
- **Tcache era (≥2.26):** Tcache avalera vos allocations 0x70 et empêchera les primitives fastbin/unsorted. Désactivez-le (`setenv("GLIBC_TUNABLES","glibc.malloc.tcache_count=0",1);`) **avant** toute allocation ou remplissez chaque 0x70 tcache bin avec 7 frees pour le vider.
- **Safe-linking:** Il s'applique à tcache/fastbin dans ≥2.32, mais House of Roman n'a besoin que d'un écrasement partiel de pointeur d'une adresse libc déjà présente dans `fd`/`bk`, donc safe-linking n'aide pas le défenseur ici (l'attaquant ne forge jamais un pointeur neuf). Le véritable obstacle est la suppression des hooks et les vérifications de l'unsorted-bin.

### Code

- Un exemple se trouve dans [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)

### Objectif

- RCE en abusant de pointeurs relatifs

### Prérequis

- Modifier les pointeurs fastbin et unsorted bin
- 12 bits d'aléa doivent être brute-forcés (probabilité d'environ 0,02%) de réussite

## Étapes de l'attaque

### Partie 1 : Fastbin Chunk pointe vers \_\_malloc_hook

Créer plusieurs chunks :

- `fastbin_victim` (0x60, offset 0): Chunk UAF qui sera ensuite utilisé pour modifier le pointeur du heap afin qu'il pointe vers une valeur LibC.
- `chunk2` (0x80, offset 0x70): Pour un bon alignement
- `main_arena_use` (0x80, offset 0x100)
- `relative_offset_heap` (0x60, offset 0x190): offset relatif sur le chunk 'main_arena_use'

Ensuite `free(main_arena_use)` qui placera ce chunk dans la liste unsorted et obtiendra un pointeur vers `main_arena + 0x68` à la fois dans `fd` et `bk`.

On alloue maintenant un nouveau chunk `fake_libc_chunk(0x60)` car il contiendra les pointeurs vers `main_arena + 0x68` dans `fd` et `bk`.

Puis `relative_offset_heap` et `fastbin_victim` sont libérés.
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- `fastbin_victim` a un `fd` pointant vers `relative_offset_heap`
- `relative_offset_heap` est un offset de distance depuis `fake_libc_chunk`, qui contient un pointeur vers `main_arena + 0x68`
- Changer le dernier octet de `fastbin_victim.fd` fait pointer `fastbin_victim` vers `main_arena + 0x68`.

Pour ces actions, l'attaquant doit être capable de modifier le pointeur fd de `fastbin_victim`.

Ensuite, `main_arena + 0x68` n'est pas très intéressant, donc modifions-le pour que le pointeur pointe vers **`__malloc_hook`**.

Notez que `__memalign_hook` commence habituellement par `0x7f` et des zéros avant, il est donc possible de le forger comme une valeur dans le fast bin `0x70`. Comme les 4 derniers bits de l'adresse sont **aléatoires** il y a `2^4=16` possibilités pour que la valeur finisse par pointer là où nous voulons. Donc une attaque BF est effectuée ici de sorte que le chunk finit comme : **`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`.**

(For more info about the rest of the bytes check the explanation in the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)). If the brute force fails the program just crashes (restart until it works).

Ensuite, 2 mallocs sont effectués pour retirer les 2 chunks initiaux du fast bin et un troisième est alloué pour obtenir un chunk dans **`__malloc_hook`**.
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### Part 2: Unsorted_bin attack

For more info you can check:

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

Mais en pratique cela permet d'écrire `main_arena + 0x68` à n'importe quelle adresse indiquée dans `chunk->bk`. Pour l'attaque, nous choisissons `__malloc_hook`. Ensuite, après l'avoir écrasé, nous utiliserons un relative overwrite pour pointer vers un `one_gadget`.

Pour cela, nous commençons par obtenir un chunk et le placer dans le **unsorted bin**:
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
Use an UAF in this chunk to point `unsorted_bin_ptr->bk` to the address of `__malloc_hook` (we brute forced this previously).

> [!CAUTION]
> Note that this attack corrupts the unsorted bin (hence small and large too). So we can only **use allocations from the fast bin now** (a more complex program might do other allocations and crash), and to trigger this we must **alloc the same size or the program will crash.**

Ainsi, pour déclencher l'écriture de `main_arena + 0x68` dans `__malloc_hook`, après avoir placé `__malloc_hook` dans `unsorted_bin_ptr->bk` il suffit d'appeler : **`malloc(0x80)`**

### Étape 3 : Définir \_\_malloc_hook sur system

Dans la première étape nous contrôlions un chunk contenant `__malloc_hook` (dans la variable `malloc_hook_chunk`) et dans la deuxième étape nous avons réussi à y écrire `main_arena + 0x68`.

Nous exploitons maintenant un overwrite partiel dans `malloc_hook_chunk` pour utiliser l'adresse libc que nous y avons écrite (`main_arena + 0x68`) afin de **pointer vers une adresse `one_gadget`**.

C'est ici qu'il faut **bruteforcer 12 bits d'entropie** (plus d'infos dans l'[how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)).

Enfin, une fois la bonne adresse écrite, **appelez `malloc` et déclenchez le `one_gadget`**.

## Astuces modernes & variantes

- **Unsorted-bin check in 2.29+:** Si vous devez exécuter sur 2.29–2.33, corrompez à la fois `fd` **et** `bk` pour satisfaire le contrôle d'intégrité avant de déclencher l'écriture ; sinon `_int_malloc` appelle abort. Le taux de réussite est très faible et généralement viable uniquement dans des CTFs avec bruteforce.
- **Hook removal (2.34+):** Avec `__malloc_hook` supprimé, adaptez le primitive pour atterrir sur n'importe quel GOT/global writable que vous pouvez réutiliser ensuite (p. ex., overwrite `exit@GOT` dans des binaires non-PIE) ou pivotez vers un détournement du top-chunk de style **House of Pie** pour contrôler `top` au lieu d'un hook.
- **Any‑address fastbin alloc (2024 gist):** Un writeup récent montre la réutilisation du même grooming pour fastbin‑allouer par-dessus `__free_hook` ou d'autres globals en plaçant d'abord un pointeur libc dans un fastbin puis en le re‑pointant avant le fixup. Cela fonctionne sur 2.24–2.28 mais échoue encore à cause des contrôles d'intégrité en 2.29.

## Références

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)
- [https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html](https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html)
- [https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc](https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc)

{{#include ../../banners/hacktricks-training.md}}
