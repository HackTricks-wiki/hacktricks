# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

This was a very interesting technique that allowed for RCE without leaks via fake fastbins, the unsorted_bin attack and relative overwrites. However it has been [**patched**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c).

### Applicability in 2026

- **glibc window :** Fonctionne de manière fiable sur **2.23–2.28**. Sur **2.29** les contrôles d'intégrité additionnels des `unsorted_chunks` rendent l'écriture dans l'unsorted‑bin peu fiable, donc le taux de succès chute fortement. À partir de **2.34**, `__malloc_hook/__free_hook` ont été supprimés, rendant la cible originale indisponible. Ne l'utilisez que sur de vieilles libc (ou des builds personnalisés qui conservent les hooks) ou pour des challenges CTF fournissant une vieille libc.
- **Tcache era (≥2.26) :** Tcache va consommer vos allocations 0x70 et empêcher les primitives fastbin/unsorted. Désactivez-le (`setenv("GLIBC_TUNABLES","glibc.malloc.tcache_count=0",1);`) **avant** toute allocation ou remplissez chaque bin tcache 0x70 avec 7 frees pour le vider.
- **Safe-linking :** S'applique à tcache/fastbin en ≥2.32, mais House of Roman n'a besoin que d'un **écrasement partiel de pointeur d'une adresse libc déjà présente dans fd/bk**, donc safe-linking n'aide pas le défenseur ici (l'attaquant ne forge jamais un pointeur neuf). Le véritable obstacle est la suppression des hooks et les contrôles de l'unsorted-bin.

### Code

- You can find an example in [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)

### Goal

- RCE en abusant des pointeurs relatifs

### Requirements

- Edit fastbin and unsorted bin pointers
- 12 bits of randomness must be brute forced (0.02% chance) of working

## Attack Steps

### Partie 1: Fastbin Chunk points to __malloc_hook

Create several chunks:

- `fastbin_victim` (0x60, offset 0) : chunk UAF à exploiter plus tard pour modifier le pointeur heap afin qu'il pointe vers la valeur LibC.
- `chunk2` (0x80, offset 0x70) : pour un bon alignement
- `main_arena_use` (0x80, offset 0x100)
- `relative_offset_heap` (0x60, offset 0x190) : offset relatif sur le chunk 'main_arena_use'

Puis `free(main_arena_use)` qui placera ce chunk dans la liste unsorted et mettra un pointeur vers `main_arena + 0x68` à la fois dans les pointeurs `fd` et `bk`.

Maintenant on alloue un nouveau chunk `fake_libc_chunk(0x60)` car il contiendra les pointeurs vers `main_arena + 0x68` dans `fd` et `bk`.

Ensuite `relative_offset_heap` et `fastbin_victim` sont freed.
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- `fastbin_victim` a un `fd` pointant vers `relative_offset_heap`
- `relative_offset_heap` est un offset de distance depuis `fake_libc_chunk`, qui contient un pointeur vers `main_arena + 0x68`
- Changer le dernier octet de `fastbin_victim.fd` fait que `fastbin_victim` pointe vers `main_arena + 0x68`.

Pour les actions précédentes, l'attaquant doit être capable de modifier le pointeur fd de `fastbin_victim`.

Ensuite, `main_arena + 0x68` n'est pas très intéressant, donc modifions-le pour que le pointeur pointe vers **`__malloc_hook`**.

Notez que `__memalign_hook` commence généralement par `0x7f` avec des zéros avant, il est donc possible de le falsifier comme une valeur du fast bin `0x70`. Comme les 4 derniers bits de l'adresse sont **aléatoires**, il y a `2^4=16` possibilités pour que la valeur finisse par pointer vers l'endroit qui nous intéresse. Par conséquent, une BF attack est effectuée ici de sorte que le chunk se termine ainsi : **`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`.**

(For more info about the rest of the bytes check the explanation in the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)). Si le brute force échoue, le programme plante simplement (redémarrez jusqu'à ce que ça marche).

Ensuite, 2 mallocs sont effectués pour retirer les 2 chunks initiaux du fast bin et un troisième est alloué pour obtenir un chunk dans **`__malloc_hook`**.
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### Partie 2: Unsorted_bin attack

Pour plus d'informations, vous pouvez consulter :

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

Mais en gros, il permet d'écrire `main_arena + 0x68` à n'importe quelle adresse spécifiée dans `chunk->bk`. Pour l'attaque, nous choisissons `__malloc_hook`. Ensuite, après l'overwrite, nous utiliserons un relative overwrite pour pointer vers un `one_gadget`.

Pour cela, nous commençons par obtenir un chunk et le placer dans le **unsorted bin**:
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
Use an UAF dans ce chunk pour pointer `unsorted_bin_ptr->bk` vers l'adresse de `__malloc_hook` (nous avons brute-forcé cela précédemment).

> [!CAUTION]
> Notez que cette attaque corrompt l'unsorted bin (et donc aussi small et large). Ainsi, nous ne pouvons désormais **utiliser des allocations depuis le fast bin maintenant** (un programme plus complexe pourrait faire d'autres allocations et planter), et pour déclencher cela nous devons **alloc de la même taille sinon le programme plantera.**

Donc, pour déclencher l'écriture de `main_arena + 0x68` dans `__malloc_hook`, après avoir mis `__malloc_hook` dans `unsorted_bin_ptr->bk`, il suffit de faire : **`malloc(0x80)`**

### Étape 3 : Attribuer \_\_malloc_hook à system

Dans la première étape, nous contrôlions un chunk contenant `__malloc_hook` (dans la variable `malloc_hook_chunk`) et dans la deuxième étape nous avons réussi à y écrire `main_arena + 0x68`.

Maintenant, nous abusons d'un écrasement partiel dans `malloc_hook_chunk` pour utiliser l'adresse libc que nous y avons écrite (`main_arena + 0x68`) afin de **pointer vers une adresse `one_gadget`**.

C'est ici qu'il faut **bruteforcer 12 bits d'aléa** (more info in the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)).

Enfin, une fois la bonne adresse écrite, **appelez `malloc` et déclenchez le `one_gadget`**.

## Astuces modernes & variantes

- **Unsorted-bin check in 2.29+:** Si vous devez exécuter sur 2.29–2.33, corrompez à la fois `fd` **et** `bk` pour satisfaire la vérification d'intégrité avant de déclencher l'écriture ; sinon `_int_malloc` aborts. Le taux de réussite est très faible et généralement viable uniquement dans des scénarios CTF de brute-force.
- **Hook removal (2.34+):** Avec `__malloc_hook` supprimé, adaptez le primitive pour viser n'importe quelle GOT/global writable que vous pourrez réutiliser plus tard (par ex., écraser `exit@GOT` dans des binaires non-PIE) ou pivoter vers un détournement du top‑chunk de style **House of Pie** pour contrôler `top` au lieu d'un hook.
- **Any‑address fastbin alloc (2024 gist):** Un writeup récent montre la réutilisation du même grooming pour fastbin‑allouer par-dessus `__free_hook` ou d'autres globals en plaçant d'abord un pointeur libc dans le fastbin puis en le re‑pointant avant le fixup. Cela fonctionne sur 2.24–2.28 mais échoue encore sur les vérifications d'intégrité de 2.29.

## Références

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)
- [https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html](https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html)
- [https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc](https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc)

{{#include ../../banners/hacktricks-training.md}}
