# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

Dit was 'n baie interessante tegniek wat RCE sonder leaks via vals fastbins, die unsorted_bin aanval en relatiewe oorskrywings moontlik gemaak het. Dit is egter [**gepatch**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c).

### Kode

- Jy kan 'n voorbeeld vind in [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)

### Doel

- RCE deur relatiewe punte te misbruik

### Vereistes

- Wysig fastbin en unsorted bin punte
- 12 bits van ewekansigheid moet gebruteforced word (0.02% kans) om te werk

## Aanvalstappe

### Deel 1: Fastbin Chunk wys na \_\_malloc_hook

Skep verskeie chunks:

- `fastbin_victim` (0x60, offset 0): UAF chunk wat later die heap pointer sal wys na die LibC waarde.
- `chunk2` (0x80, offset 0x70): Vir goeie uitlijning
- `main_arena_use` (0x80, offset 0x100)
- `relative_offset_heap` (0x60, offset 0x190): relatiewe offset op die 'main_arena_use' chunk

Dan `free(main_arena_use)` wat hierdie chunk in die onsorted lys sal plaas en 'n pointer na `main_arena + 0x68` in beide die `fd` en `bk` punte sal kry.

Nou is dit 'n nuwe chunk `fake_libc_chunk(0x60)` toegeken omdat dit die punte na `main_arena + 0x68` in `fd` en `bk` sal bevat.

Dan word `relative_offset_heap` en `fastbin_victim` vrygestel.
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- `fastbin_victim` het 'n `fd` wat na `relative_offset_heap` wys
- `relative_offset_heap` is 'n offset van afstand vanaf `fake_libc_chunk`, wat 'n pointer na `main_arena + 0x68` bevat
- Deur net die laaste byte van `fastbin_victim.fd` te verander, is dit moontlik om `fastbin_victim points` na `main_arena + 0x68` te laat wys

Vir die vorige aksies moet die aanvaller in staat wees om die fd pointer van `fastbin_victim` te verander.

Dan is `main_arena + 0x68` nie so interessant nie, so laat ons dit verander sodat die pointer na **`__malloc_hook`** wys.

Let daarop dat `__memalign_hook` gewoonlik begin met `0x7f` en nulles voor dit, dan is dit moontlik om dit as 'n waarde in die `0x70` fast bin te vervals. Omdat die laaste 4 bits van die adres **random** is, is daar `2^4=16` moontlikhede vir die waarde om te eindig waar ons belangstel. So 'n BF-aanval word hier uitgevoer sodat die chunk eindig soos: **`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`.**

(Vir meer inligting oor die res van die bytes, kyk die verduideliking in die [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ voorbeeld](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)). As die BF nie werk nie, val die program net in duie (so begin weer totdat dit werk).

Dan word 2 mallocs uitgevoer om die 2 aanvanklike fast bin chunks te verwyder en 'n derde een word toegeken om 'n chunk in die **`__malloc_hook:`** te kry.
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### Deel 2: Unsorted_bin aanval

Vir meer inligting kan jy kyk na:

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

Maar basies laat dit jou toe om `main_arena + 0x68` na enige plek te skryf soos gespesifiseer in `chunk->bk`. En vir die aanval kies ons `__malloc_hook`. Dan, nadat ons dit oorgeskryf het, sal ons 'n relatiewe oorskrywing gebruik om na 'n `one_gadget` te wys.

Vir hierdie begin ons om 'n chunk te kry en dit in die **unsorted bin** te plaas:
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
Gebruik 'n UAF in hierdie stuk om `unsorted_bin_ptr->bk` na die adres van `__malloc_hook` te wys (ons het dit voorheen brute-force).

> [!CAUTION]
> Let daarop dat hierdie aanval die onsortering bin korrupteer (dus klein en groot ook). So ons kan slegs **toewysings van die vinnige bin gebruik** (n meer komplekse program mag ander toewysings doen en crash), en om dit te aktiveer moet ons **die selfde grootte toewys of die program sal crash.**

So, om die skrywe van `main_arena + 0x68` in `__malloc_hook` te aktiveer, voer ons na die instelling van `__malloc_hook` in `unsorted_bin_ptr->bk` net die volgende uit: **`malloc(0x80)`**

### Stap 3: Stel \_\_malloc_hook na system

In die eerste stap het ons 'n stuk beheer wat `__malloc_hook` bevat (in die veranderlike `malloc_hook_chunk`) en in die tweede stap het ons daarin geslaag om `main_arena + 0x68` te skryf.

Nou, ons misbruik 'n gedeeltelike oorskrywing in `malloc_hook_chunk` om die libc adres wat ons daar geskryf het (`main_arena + 0x68`) te gebruik om **na 'n `one_gadget` adres te wys**.

Hier is waar dit nodig is om **12 bits van ewekansigheid te brute-force** (meer inligting in die [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ voorbeeld](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)).

Laastens, sodra die korrekte adres oorgeskryf is, **roep `malloc` aan en aktiveer die `one_gadget`**.

## Verwysings

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)

{{#include ../../banners/hacktricks-training.md}}
