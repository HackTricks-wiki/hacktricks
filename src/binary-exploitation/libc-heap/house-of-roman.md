# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

Bu, sahte fastbinler, unsorted_bin saldırısı ve göreceli yazmalar aracılığıyla sızıntı olmadan RCE'ye izin veren çok ilginç bir teknikti. Ancak bu [**yamanmıştır**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c).

### Kod

- Bir örneği [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c) adresinde bulabilirsiniz.

### Hedef

- Göreceli işaretçileri kötüye kullanarak RCE

### Gereksinimler

- Fastbin ve unsorted bin işaretçilerini düzenleyin
- 12 bit rastgelelik zorla kırılmalıdır (çalışma olasılığı %0.02)

## Saldırı Adımları

### Bölüm 1: Fastbin Chunk \_\_malloc_hook'a işaret ediyor

Birçok chunk oluşturun:

- `fastbin_victim` (0x60, offset 0): Daha sonra heap işaretçisini LibC değerine işaret edecek şekilde düzenlemek için UAF chunk.
- `chunk2` (0x80, offset 0x70): İyi hizalama için
- `main_arena_use` (0x80, offset 0x100)
- `relative_offset_heap` (0x60, offset 0x190): 'main_arena_use' chunk'ındaki göreceli offset

Sonra `free(main_arena_use)` yapın, bu chunk'ı unsorted liste yerleştirecek ve hem `fd` hem de `bk` işaretçelerinde `main_arena + 0x68` adresine bir işaretçi alacaktır.

Artık `fd` ve `bk`'de `main_arena + 0x68` işaretçilerini içerecek yeni bir chunk `fake_libc_chunk(0x60)` tahsis edilmiştir.

Sonra `relative_offset_heap` ve `fastbin_victim` serbest bırakılır.
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- &#x20;`fastbin_victim` bir `fd`'ye sahiptir ve bu `relative_offset_heap`'e işaret eder.
- &#x20;`relative_offset_heap`, `main_arena + 0x68`'e işaret eden bir işaretçi içeren `fake_libc_chunk`'ten uzaklık ofsetidir.
- `fastbin_victim.fd`'nin son baytını değiştirmek, `fastbin_victim`'in `main_arena + 0x68`'e işaret etmesini sağlamak mümkündür.

Önceki eylemler için, saldırganın `fastbin_victim`'in fd işaretçisini değiştirebilme yeteneğine sahip olması gerekir.

Sonra, `main_arena + 0x68` o kadar ilginç değildir, bu yüzden işaretçiyi **`__malloc_hook`**'a işaret edecek şekilde değiştirelim.

`__memalign_hook` genellikle `0x7f` ile başlar ve öncesinde sıfırlar bulunur, bu nedenle bunu `0x70` hızlı bin içinde bir değer olarak sahteleyebiliriz. Adresin son 4 biti **rastgele** olduğundan, ilginç olduğumuz yere işaret edecek değerin 16 olasılığı vardır: `2^4=16`. Bu nedenle burada bir BF saldırısı gerçekleştirilir, böylece parça şu şekilde sona erer: **`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`.**

(Diğer baytlar hakkında daha fazla bilgi için [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ örneğine](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c) bakın). BF çalışmazsa program sadece çökebilir (bu yüzden çalışana kadar tekrar başlatın).

Sonra, 2 malloc işlemi gerçekleştirilir ve 2 başlangıç hızlı bin parçası kaldırılır ve **`__malloc_hook:`**'te bir parça almak için üçüncü bir malloc yapılır.
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### Bölüm 2: Unsorted_bin saldırısı

Daha fazla bilgi için kontrol edebilirsiniz:

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

Ama temelde, `chunk->bk` içinde belirtilen herhangi bir konuma `main_arena + 0x68` yazılmasına izin verir. Ve saldırı için `__malloc_hook` seçiyoruz. Sonra, onu geçersiz kıldıktan sonra, bir `one_gadget`'e işaret etmek için göreli bir geçersiz kılma kullanacağız.

Bunun için bir chunk alarak **unsorted bin**'e koymaya başlıyoruz:
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
Bir UAF kullanarak `unsorted_bin_ptr->bk`'yi `__malloc_hook` adresine işaret edecek şekilde ayarlayın (bunu daha önce brute force ile bulmuştuk).

> [!CAUTION]
> Bu saldırının unsorted bin'i bozduğunu (dolayısıyla küçük ve büyük olanları da) unutmayın. Bu nedenle, artık yalnızca **hızlı bin'den tahsisat kullanabiliriz** (daha karmaşık bir program başka tahsisatlar yapabilir ve çökebilir) ve bunu tetiklemek için **aynı boyutta tahsisat yapmalıyız, aksi takdirde program çöker.**

Böylece, `__malloc_hook`'de `main_arena + 0x68` yazımını tetiklemek için, `__malloc_hook`'u `unsorted_bin_ptr->bk`'de ayarladıktan sonra sadece şunu yapmamız gerekiyor: **`malloc(0x80)`**

### Adım 3: \_\_malloc_hook'u system olarak ayarlayın

Birinci adımda `__malloc_hook`'u içeren bir chunk'ı kontrol etmeyi başardık (değişken `malloc_hook_chunk` içinde) ve ikinci adımda burada `main_arena + 0x68` yazmayı başardık.

Şimdi, `malloc_hook_chunk`'te kısmi bir yazma işlemi suistimal ederek oraya yazdığımız libc adresini (`main_arena + 0x68`) **bir `one_gadget` adresine işaret etmek için** kullanıyoruz.

Burada **12 bit rastgeleliği brute force ile bulmak** gerekiyor (daha fazla bilgi için [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ örneği](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)).

Son olarak, doğru adres yazıldığında, **`malloc` çağırın ve `one_gadget`'i tetikleyin.**

## Referanslar

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)

{{#include ../../banners/hacktricks-training.md}}
