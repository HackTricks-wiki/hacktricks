# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

यह एक बहुत ही दिलचस्प तकनीक थी जिसने नकली फास्टबिन, अनसॉर्टेड_बिन हमले और सापेक्ष ओवरराइट के माध्यम से RCE की अनुमति दी। हालाँकि इसे [**पैच**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c) किया गया है।

### Code

- आप एक उदाहरण [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c) पर पा सकते हैं।

### Goal

- सापेक्ष पॉइंटर्स का दुरुपयोग करके RCE प्राप्त करना

### Requirements

- फास्टबिन और अनसॉर्टेड बिन पॉइंटर्स को संपादित करें
- 12 बिट की यादृच्छिकता को ब्रूट फोर्स किया जाना चाहिए (काम करने की 0.02% संभावना)

## Attack Steps

### Part 1: Fastbin Chunk points to \_\_malloc_hook

कई चंक्स बनाएं:

- `fastbin_victim` (0x60, ऑफसेट 0): UAF चंक जिसे बाद में हीप पॉइंटर को LibC मान की ओर इंगित करने के लिए संपादित किया जाएगा।
- `chunk2` (0x80, ऑफसेट 0x70): अच्छे संरेखण के लिए
- `main_arena_use` (0x80, ऑफसेट 0x100)
- `relative_offset_heap` (0x60, ऑफसेट 0x190): 'main_arena_use' चंक पर सापेक्ष ऑफसेट

फिर `free(main_arena_use)` करें जो इस चंक को अनसॉर्टेड सूची में रखेगा और `fd` और `bk` पॉइंटर्स में `main_arena + 0x68` का एक पॉइंटर प्राप्त करेगा।

अब एक नया चंक `fake_libc_chunk(0x60)` आवंटित किया गया है क्योंकि इसमें `fd` और `bk` में `main_arena + 0x68` के पॉइंटर्स होंगे।

फिर `relative_offset_heap` और `fastbin_victim` को मुक्त किया जाता है।
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- `fastbin_victim` का `fd` `relative_offset_heap` की ओर इशारा कर रहा है
- `relative_offset_heap` एक ऑफसेट है जो `fake_libc_chunk` से दूरी को दर्शाता है, जिसमें `main_arena + 0x68` की ओर एक पॉइंटर होता है
- केवल `fastbin_victim.fd` के अंतिम बाइट को बदलकर, `fastbin_victim` को `main_arena + 0x68` की ओर इशारा करना संभव है

पिछले कार्यों के लिए, हमलावर को `fastbin_victim` के fd पॉइंटर को संशोधित करने में सक्षम होना चाहिए।

फिर, `main_arena + 0x68` इतना दिलचस्प नहीं है, इसलिए इसे संशोधित करें ताकि पॉइंटर **`__malloc_hook`** की ओर इशारा करे।

ध्यान दें कि `__memalign_hook` आमतौर पर `0x7f` से शुरू होता है और इसके पहले शून्य होते हैं, फिर इसे `0x70` फास्ट बिन में एक मान के रूप में फेक करना संभव है। क्योंकि पते के अंतिम 4 बिट **यादृच्छिक** होते हैं, इसलिए मान के अंत में इशारा करने के लिए `2^4=16` संभावनाएँ होती हैं। इसलिए यहां एक BF हमला किया जाता है ताकि चंक इस तरह समाप्त हो: **`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`।**

(बाकी बाइट्स के बारे में अधिक जानकारी के लिए [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ उदाहरण](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c) में व्याख्या देखें)। यदि BF काम नहीं करता है, तो प्रोग्राम बस क्रैश हो जाता है (इसलिए तब तक फिर से शुरू करें जब तक यह काम न करे)।

फिर, 2 mallocs किए जाते हैं ताकि 2 प्रारंभिक फास्ट बिन चंक्स को हटाया जा सके और एक तीसरा आवंटित किया जाता है ताकि **`__malloc_hook:`** में एक चंक प्राप्त किया जा सके।
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### Part 2: Unsorted_bin हमला

अधिक जानकारी के लिए आप देख सकते हैं:

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

लेकिन मूल रूप से यह `chunk->bk` में निर्दिष्ट किसी भी स्थान पर `main_arena + 0x68` लिखने की अनुमति देता है। और हमले के लिए हम `__malloc_hook` चुनते हैं। फिर, इसे ओवरराइट करने के बाद हम एक सापेक्ष ओवरराइट का उपयोग करेंगे) एक `one_gadget` की ओर इशारा करने के लिए।

इसके लिए हम एक चंक प्राप्त करना शुरू करते हैं और इसे **unsorted bin** में डालते हैं:
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
इस भाग में UAF का उपयोग करें ताकि `unsorted_bin_ptr->bk` को `__malloc_hook` के पते पर इंगित किया जा सके (हमने इसे पहले ब्रूट फोर्स किया था)।

> [!CAUTION]
> ध्यान दें कि यह हमला असंरचित बिन को भ्रष्ट करता है (इसलिए छोटे और बड़े भी)। इसलिए हम केवल **अब तेज बिन से आवंटन का उपयोग कर सकते हैं** (एक अधिक जटिल प्रोग्राम अन्य आवंटन कर सकता है और क्रैश हो सकता है), और इसे ट्रिगर करने के लिए हमें **उसी आकार का आवंटन करना होगा या प्रोग्राम क्रैश हो जाएगा।**

तो, `__malloc_hook` में `main_arena + 0x68` के लिखने को ट्रिगर करने के लिए, हमें `__malloc_hook` को `unsorted_bin_ptr->bk` में सेट करने के बाद बस यह करना है: **`malloc(0x80)`**

### चरण 3: \_\_malloc_hook को सिस्टम पर सेट करें

पहले चरण में, हम `__malloc_hook` वाले एक भाग को नियंत्रित करने में सफल रहे (चर `malloc_hook_chunk` में) और दूसरे चरण में हम यहां `main_arena + 0x68` लिखने में सफल रहे।

अब, हम `malloc_hook_chunk` में आंशिक ओवरराइट का दुरुपयोग करते हैं ताकि हम वहां लिखे गए libc पते (`main_arena + 0x68`) का उपयोग करके **एक `one_gadget` पते** को इंगित कर सकें।

यहां **12 बिट की यादृच्छिकता को ब्रूटफोर्स करना आवश्यक है** (अधिक जानकारी के लिए [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ उदाहरण](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c) में)।

अंत में, एक बार सही पता ओवरराइट हो जाने पर, **`malloc` कॉल करें और `one_gadget` को ट्रिगर करें।**

## संदर्भ

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)

{{#include ../../banners/hacktricks-training.md}}
