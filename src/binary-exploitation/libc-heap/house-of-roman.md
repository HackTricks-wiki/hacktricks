# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

Dit was 'n baie interessante tegniek wat RCE moontlik gemaak het sonder leaks via fake fastbins, die unsorted_bin attack en relative overwrites. Dit is egter [**patched**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c).

### Toepasbaarheid in 2026

- **glibc window:** Werk betroubaar op **2.23–2.28**. Op **2.29** maak die bykomende `unsorted_chunks` integriteitskontroles die unsorted‑bin write onbetroubaar, so sukses val skerp. Vanaf **2.34** is `__malloc_hook/__free_hook` verwyder, wat die oorspronklike teiken onbruikbaar maak. Gebruik dit slegs op ou libc’s (of custom builds wat die hooks hou) of vir CTF-challenges wat 'n ou libc saamlewer.
- **Tcache era (≥2.26):** Tcache sal jou 0x70 allocations opbruik en die fastbin/unsorted primitives stop. Deaktiveer dit (`setenv("GLIBC_TUNABLES","glibc.malloc.tcache_count=0",1);`) **voor** enige allocation of vul elke 0x70 tcache bin met 7 frees om dit leeg te maak.
- **Safe-linking:** Dit geld vir tcache/fastbin in ≥2.32, maar House of Roman benodig slegs **partial pointer overwrite of a libc address already present in fd/bk**, so safe-linking help nie die verdediger hier nie (die aanvaller forge nooit 'n vars pointer nie). Die werklike stopmerker is die verwydering van die hooks en die unsorted-bin kontroles.

### Kode

- You can find an example in [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)

### Doel

- RCE deur relative pointers te misbruik

### Vereistes

- Edit fastbin and unsorted bin pointers
- 12 bits of randomness must be brute forced (0.02% chance) of working

## Aanvalsstappe

### Deel 1: Fastbin Chunk wys na \_\_malloc_hook

Skep verskeie chunks:

- `fastbin_victim` (0x60, offset 0): UAF chunk wat later gebruik word om die heap pointer te wysig en na die LibC-waarde te laat wys.
- `chunk2` (0x80, offset 0x70): Vir goeie uitlyning
- `main_arena_use` (0x80, offset 0x100)
- `relative_offset_heap` (0x60, offset 0x190): relatiewe offset op die 'main_arena_use' chunk

Dan `free(main_arena_use)` wat hierdie chunk in die unsorted list plaas en 'n pointer na `main_arena + 0x68` in sowel die `fd` as `bk` pointers kry.

Nou word 'n nuwe chunk `fake_libc_chunk(0x60)` toegeken omdat dit die pointers na `main_arena + 0x68` in `fd` en `bk` sal bevat.

Dan word `relative_offset_heap` en `fastbin_victim` gefree.
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- `fastbin_victim` het 'n `fd` wat na `relative_offset_heap` wys
- `relative_offset_heap` is 'n offset van afstand vanaf `fake_libc_chunk`, wat 'n pointer na `main_arena + 0x68` bevat
- Deur die laaste byte van `fastbin_victim.fd` te verander, wys `fastbin_victim` na `main_arena + 0x68`.

Die attacker moet in staat wees om die fd-pointer van `fastbin_victim` te wysig vir bogenoemde stappe.

Dan is `main_arena + 0x68` nie baie interessant nie, so laat ons dit aanpas sodat die pointer na **`__malloc_hook`** wys.

Let daarop dat `__memalign_hook` gewoonlik met `0x7f` begin en nulles daarvoor het, dus is dit moontlik om dit te vervals as 'n waarde in die `0x70` fast bin. Omdat die laaste 4 bite van die adres **random** is, is daar `2^4=16` moontlikhede vir die waarde om uiteindelik te wys waar ons belangstel. Daarom word 'n BF attack hier uitgevoer sodat die chunk eindig soos: **`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`.**

(For more info about the rest of the bytes check the explanation in the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)). If the brute force fails the program just crashes (restart until it works).

Dan word 2 mallocs uitgevoer om die 2 aanvanklike fast bin chunks te verwyder en 'n derde een word toegeken om 'n chunk in **`__malloc_hook`** te kry.
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### Deel 2: Unsorted_bin attack

Vir meer inligting kan jy kyk:

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

Maar basies stel dit in staat om `main_arena + 0x68` na enige ligging te skryf wat in `chunk->bk` gespesifiseer is. Vir die aanval kies ons `__malloc_hook`. Dan, nadat ons dit oorskryf het, sal ons 'n relative overwrite gebruik om na 'n `one_gadget` te wys.

Hiervoor begin ons 'n chunk kry en dit in die **unsorted bin** sit:
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
Use an UAF in this chunk to point `unsorted_bin_ptr->bk` to the address of `__malloc_hook` (we brute forced this previously).

> [!CAUTION]
> Let wel dat hierdie aanval die unsorted bin korrupteer (dus ook small en large). Daarom kan ons nou slegs **allokasies vanaf die fast bin gebruik** (’n meer komplekse program kan ander allokasies doen en crash), en om dit te trigger moet ons **dieselfde grootte allokeer anders crash die program.**

So, to trigger the write of `main_arena + 0x68` in `__malloc_hook` we perform after setting `__malloc_hook` in `unsorted_bin_ptr->bk` we just need to do: **`malloc(0x80)`**

### Stap 3: Stel \_\_malloc_hook to system

In stap een het ons ’n chunk beheer wat `__malloc_hook` bevat (in die veranderlike `malloc_hook_chunk`) en in die tweede stap het ons daarin `main_arena + 0x68` geskryf.

Nou misbruik ons ’n partial overwrite in `malloc_hook_chunk` om die libc‑adres wat ons daar geskryf het (`main_arena + 0x68`) te gebruik om na ’n `one_gadget` adres te wys.

Hier moet ons **12 bits willekeur bruut‑force** (meer info in die [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)).

Laastens, sodra die korrekte adres oorskryf is, **roep `malloc` aan en trigger die `one_gadget`**.

## Modern tips & variants

- **Unsorted-bin check in 2.29+:** As jy dit op 2.29–2.33 moet laat loop, korrupteer beide `fd` **en** `bk` om die integriteitskontrole tevrede te stel voordat jy die skryf trigger; anders abort `_int_malloc`. Sukseskoers is baie laag en dikwels net haalbaar in brute‑force CTF‑opsettings.
- **Hook removal (2.34+):** Met `__malloc_hook` weg, pas die primitive aan om op enige skrivende GOT/global te land wat jy later kan hergebruik (bv. oorskryf `exit@GOT` in non‑PIE binaries) of pivot na ’n **House of Pie** styl top‑chunk kaping om eerder `top` te beheer as ’n hook.
- **Any‑address fastbin alloc (2024 gist):** ’n Onlangse writeup wys hoe dieselfde grooming hergebruik word om fastbin‑te allokeer oor `__free_hook` of ander globals deur eers ’n libc‑pointer in fastbin te land en dit dan te herwys voor die fixup. Dit werk op 2.24–2.28 maar faal steeds op 2.29 se integriteitskontroles.

## References

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)
- [https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html](https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html)
- [https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc](https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc)

{{#include ../../banners/hacktricks-training.md}}
