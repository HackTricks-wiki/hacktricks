# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## Informações Básicas

Esta foi uma técnica muito interessante que permitia RCE sem leaks via fake fastbins, o ataque unsorted_bin e relative overwrites. No entanto ela foi [**patched**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c).

### Aplicabilidade em 2026

- **glibc window:** Funciona de forma confiável em **2.23–2.28**. Em **2.29** as verificações adicionais de integridade de `unsorted_chunks` tornam a escrita no unsorted‑bin não confiável, então a taxa de sucesso cai acentuadamente. A partir de **2.34** `__malloc_hook/__free_hook` foram removidos, tornando o alvo original indisponível. Use apenas em libc antigas (ou builds custom que mantenham os hooks) ou para desafios CTF que incluam uma libc antiga.
- **Tcache era (≥2.26):** O tcache vai consumir suas alocações 0x70 e bloquear os primitivos fastbin/unsorted. Desative-o (`setenv("GLIBC_TUNABLES","glibc.malloc.tcache_count=0",1);`) **antes** de qualquer alocação ou preencha cada bin tcache de 0x70 com 7 frees para drená-lo.
- **Safe-linking:** Aplica-se a tcache/fastbin em ≥2.32, mas House of Roman só precisa de um **partial pointer overwrite of a libc address already present in fd/bk**, então safe-linking não ajuda o defensor aqui (o atacante nunca forja um ponteiro novo). O verdadeiro impeditivo é a remoção dos hooks e as verificações do unsorted-bin.

### Code

- You can find an example in [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)

### Objetivo

- RCE abusando de relative pointers

### Requisitos

- Editar ponteiros fastbin e unsorted bin
- 12 bits de aleatoriedade devem ser bruteforcados (chance de 0,02% de sucesso)

## Etapas do Ataque

### Parte 1: Fastbin Chunk aponta para \_\_malloc_hook

Crie vários chunks:

- `fastbin_victim` (0x60, offset 0): Chunk UAF que depois será usado para editar o ponteiro do heap e fazê-lo apontar para o valor da libc.
- `chunk2` (0x80, offset 0x70): Para bom alinhamento
- `main_arena_use` (0x80, offset 0x100)
- `relative_offset_heap` (0x60, offset 0x190): offset relativo no chunk 'main_arena_use'

Então `free(main_arena_use)` que colocará esse chunk na lista unsorted e colocará um ponteiro para `main_arena + 0x68` tanto em `fd` quanto em `bk`.

Agora é alocado um novo chunk `fake_libc_chunk(0x60)` porque ele conterá os ponteiros para `main_arena + 0x68` em `fd` e `bk`.

Então `relative_offset_heap` e `fastbin_victim` são liberados.
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- `fastbin_victim` tem um `fd` apontando para `relative_offset_heap`
- `relative_offset_heap` é um offset de distância a partir de `fake_libc_chunk`, que contém um ponteiro para `main_arena + 0x68`
- Alterar o último byte de `fastbin_victim.fd` faz `fastbin_victim` apontar para `main_arena + 0x68`.

Para as ações anteriores, o atacante precisa ser capaz de modificar o ponteiro fd de `fastbin_victim`.

Então, `main_arena + 0x68` não é tão interessante, então vamos modificá-lo para que o ponteiro aponte para **`__malloc_hook`**.

Note que `__memalign_hook` geralmente começa com `0x7f` e zeros antes dele, então é possível forjá-lo como um valor no `0x70` fast bin. Como os últimos 4 bits do endereço são **aleatórios** há `2^4=16` possibilidades para o valor acabar apontando para onde nos interessamos. Então um BF attack é realizado aqui de modo que o chunk termine assim: **`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`.**

(Para mais info sobre o resto dos bytes confira a explicação em [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)). If the brute force fails the program just crashes (restart until it works).

Então, 2 mallocs são realizados para remover os 2 chunks iniciais do fast bin e um terceiro é alocado para obter um chunk em **`__malloc_hook`**.
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### Parte 2: Unsorted_bin attack

Para mais informações você pode conferir:

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

Mas basicamente ele permite escrever `main_arena + 0x68` em qualquer local especificado em `chunk->bk`. Para o ataque escolhemos `__malloc_hook`. Então, depois de sobrescrevê-lo usaremos uma sobrescrita relativa para apontar para um `one_gadget`.

Para isso começamos pegando um chunk e colocando-o no **unsorted bin**:
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
Use an UAF in this chunk to point `unsorted_bin_ptr->bk` to the address of `__malloc_hook` (we brute forced this previously).

> [!CAUTION]
> Note that this attack corrupts the unsorted bin (hence small and large too). So we can only **use allocations from the fast bin now** (a more complex program might do other allocations and crash), and to trigger this we must **alloc the same size or the program will crash.**

So, to trigger the write of `main_arena + 0x68` in `__malloc_hook` we perform after setting `__malloc_hook` in `unsorted_bin_ptr->bk` we just need to do: **`malloc(0x80)`**

### Passo 3: Set \_\_malloc_hook to system

No passo um controlamos um chunk contendo `__malloc_hook` (na variável `malloc_hook_chunk`) e no segundo passo conseguimos escrever `main_arena + 0x68` ali.

Agora, abusamos de um partial overwrite em `malloc_hook_chunk` para usar o endereço libc que escrevemos lá (`main_arena + 0x68`) para **point to a `one_gadget` address**.

Aqui é onde é necessário **bruteforce 12 bits of randomness** (mais info no [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)).

Finalmente, uma vez que o endereço correto foi sobrescrito, **call `malloc` and trigger the `one_gadget`**.

## Dicas modernas & variantes

- **Unsorted-bin check in 2.29+:** If you must run on 2.29–2.33, corrupt both `fd` **and** `bk` to satisfy the integrity check before triggering the write; otherwise `_int_malloc` aborts. Success rate is very low and usually only viable in brute-force CTF settings.
- **Hook removal (2.34+):** With `__malloc_hook` gone, adapt the primitive to land on any writable GOT/global you can later reuse (e.g., overwrite `exit@GOT` in non-PIE binaries) or pivot to a **House of Pie** style top‑chunk hijack to control `top` instead of a hook.
- **Any‑address fastbin alloc (2024 gist):** A recent writeup shows reusing the same grooming to fastbin‑allocate over `__free_hook` or other globals by first landing a libc pointer in fastbin and then re‑pointing it before the fixup. This works on 2.24–2.28 but still dies on 2.29 integrity checks.

## References

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)
- [https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html](https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html)
- [https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc](https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc)

{{#include ../../banners/hacktricks-training.md}}
