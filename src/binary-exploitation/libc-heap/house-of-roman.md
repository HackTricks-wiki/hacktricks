# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## Grundlegende Informationen

Dies war eine sehr interessante Technik, die RCE ohne leaks via fake fastbins, den unsorted_bin attack und relative overwrites ermöglichte. Allerdings wurde sie [**patched**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c).

### Anwendbarkeit in 2026

- **glibc window:** Funktioniert zuverlässig auf **2.23–2.28**. Auf **2.29** machen die zusätzlichen `unsorted_chunks` integrity checks den unsorted‑bin write unzuverlässig, sodass die Erfolgsrate stark sinkt. Ab **2.34** wurden `__malloc_hook/__free_hook` entfernt, wodurch das ursprüngliche Ziel nicht mehr verfügbar ist. Verwende es nur auf alten libc’s (oder custom builds, die die Hooks behalten) oder für CTF challenges, die eine alte libc mitliefern.
- **Tcache era (≥2.26):** Tcache wird deine 0x70 allocations aufbrauchen und die fastbin/unsorted primitives stoppen. Deaktiviere es (`setenv("GLIBC_TUNABLES","glibc.malloc.tcache_count=0",1);`) **before** any allocation oder fülle jede 0x70 tcache bin mit 7 frees, um sie zu leeren.
- **Safe-linking:** Es gilt für tcache/fastbin in ≥2.32, aber House of Roman benötigt nur **partial pointer overwrite of a libc address already present in fd/bk**, daher hilft safe-linking dem Verteidiger hier nicht (der Angreifer fälscht niemals einen neuen Pointer). Der wirkliche Stopper ist die Entfernung der Hooks und die unsorted‑bin checks.

### Code

- You can find an example in [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)

### Ziel

- RCE durch Ausnutzen von relative pointers

### Voraussetzungen

- Bearbeite fastbin- und unsorted‑bin‑Pointer
- 12 bits Zufälligkeit müssen brute forced werden (0,02% Erfolgschance)

## Angriffsschritte

### Teil 1: Fastbin Chunk points to __malloc_hook

Erstelle mehrere Chunks:

- `fastbin_victim` (0x60, offset 0): UAF chunk, später um den Heap-Pointer zu editieren, sodass er auf den LibC-Wert zeigt.
- `chunk2` (0x80, offset 0x70): Für korrekte Ausrichtung
- `main_arena_use` (0x80, offset 0x100)
- `relative_offset_heap` (0x60, offset 0x190): relativer Offset auf dem 'main_arena_use'-Chunk

Dann `free(main_arena_use)`, wodurch dieser Chunk in die unsorted-Liste gelegt wird und sowohl im `fd` als auch `bk` Pointer ein Zeiger auf `main_arena + 0x68` gesetzt wird.

Nun wird ein neuer Chunk `fake_libc_chunk(0x60)` alloziert, weil er die Pointer auf `main_arena + 0x68` in `fd` und `bk` enthalten wird.

Dann werden `relative_offset_heap` und `fastbin_victim` freed.
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- `fastbin_victim` hat ein `fd`, das auf `relative_offset_heap` zeigt
- `relative_offset_heap` ist ein Offset relativ zu `fake_libc_chunk`, welches einen Zeiger auf `main_arena + 0x68` enthält
- Durch Ändern des letzten Bytes von `fastbin_victim.fd` zeigt `fastbin_victim` auf `main_arena + 0x68`.

Für die vorherigen Aktionen muss der Angreifer in der Lage sein, den fd-Zeiger von `fastbin_victim` zu verändern.

Dann ist `main_arena + 0x68` nicht besonders interessant, also ändern wir ihn so, dass der Zeiger auf **`__malloc_hook`** zeigt.

Beachte, dass `__memalign_hook` gewöhnlich mit `0x7f` beginnt und davor Nullen stehen; daher ist es möglich, ihn als Wert im `0x70` fast bin zu fälschen. Da die letzten 4 Bits der Adresse **zufällig** sind, gibt es `2^4=16` Möglichkeiten, dass der Wert letztlich auf die gewünschte Stelle zeigt. Daher wird hier ein BF attack durchgeführt, sodass der Chunk wie folgt endet: **`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`.**

(For more info about the rest of the bytes check the explanation in the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)). If the brute force fails the program just crashes (restart until it works).

Dann werden 2 mallocs durchgeführt, um die 2 initialen fast bin Chunks zu entfernen, und ein dritter wird alloziert, um einen Chunk in **`__malloc_hook`** zu erhalten.
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### Teil 2: Unsorted_bin attack

For more info you can check:

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

Im Kern erlaubt es, `main_arena + 0x68` an jede in `chunk->bk` angegebene Adresse zu schreiben. Für den Angriff wählen wir `__malloc_hook`. Anschließend, nachdem wir es überschrieben haben, verwenden wir ein relative overwrite, um auf ein `one_gadget` zu zeigen.

Dafür nehmen wir zuerst einen chunk und legen ihn in die **unsorted bin**:
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
Use an UAF in this chunk to point `unsorted_bin_ptr->bk` to the address of `__malloc_hook` (we brute forced this previously).

> [!CAUTION]
> Beachte, dass dieser Angriff das unsorted bin (und damit auch small und large) korrumpiert. Daher können wir jetzt nur noch **use allocations from the fast bin now** (ein komplexeres Programm könnte andere Allocations durchführen und abstürzen), und zur Auslösung müssen wir **alloc die gleiche Größe oder das Programm stürzt ab.**

So, to trigger the write of `main_arena + 0x68` in `__malloc_hook` we perform after setting `__malloc_hook` in `unsorted_bin_ptr->bk` we just need to do: **`malloc(0x80)`**

### Schritt 3: Set \_\_malloc_hook to system

In Schritt 1 kontrollierten wir einen Chunk, der `__malloc_hook` enthielt (in der Variable `malloc_hook_chunk`), und in Schritt 2 schafften wir es, dort `main_arena + 0x68` hinzuschreiben.

Nun missbrauchen wir eine partielle Überschreibung in `malloc_hook_chunk`, um die libc-Adresse, die wir dort geschrieben haben (`main_arena + 0x68`), zu verwenden, um auf eine `one_gadget`-Adresse zu zeigen.

Hier ist es nötig, **bruteforce 12 bits of randomness** (mehr Infos im [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)).

Schließlich, sobald die richtige Adresse überschrieben ist, **rufe `malloc` auf und trigger den `one_gadget`**.

## Moderne Tipps & Varianten

- **Unsorted-bin check in 2.29+:** Wenn du auf 2.29–2.33 laufen musst, korrumpiere sowohl `fd` **als auch** `bk`, um die Integritätsprüfung vor dem Auslösen des Writes zu bestehen; andernfalls bricht `_int_malloc` ab. Die Erfolgsrate ist sehr gering und meist nur in brute-force CTF-Settings praktikabel.
- **Hook removal (2.34+):** Mit entferntem `__malloc_hook` passe die Primitive so an, dass sie auf ein beliebiges beschreibbares GOT/global landet, das du später wiederverwenden kannst (z. B. `exit@GOT` in non-PIE binaries überschreiben), oder pivot zu einem **House of Pie**-artigen top‑chunk Hijack, um `top` statt eines Hooks zu kontrollieren.
- **Any‑address fastbin alloc (2024 gist):** Ein aktueller Writeup zeigt, wie man dasselbe grooming wiederverwenden kann, um fastbin‑allocate über `__free_hook` oder andere Globals zu platzieren, indem man zuerst einen libc-Pointer im fastbin landen lässt und ihn vor dem Fixup umrichtet. Das funktioniert auf 2.24–2.28, scheitert jedoch an den Integritätschecks in 2.29.

## Referenzen

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)
- [https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html](https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html)
- [https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc](https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc)

{{#include ../../banners/hacktricks-training.md}}
