# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## 基本情報

これは fake fastbins、the unsorted_bin attack、および relative overwrites を利用して leak を伴わない RCE を実現する非常に興味深い手法でした。しかし [**修正済み**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c)。

### 2026年における適用性

- **glibc window:** 安定して動作するのは **2.23–2.28**。**2.29** では追加の `unsorted_chunks` 整合性チェックにより unsorted‑bin への書き込みが信頼できなくなり、成功率が大きく低下します。**2.34** 以降は `__malloc_hook/__free_hook` が削除され、元のターゲットは利用できなくなりました。古い libc（またはフックを残すカスタムビルド）に対して、あるいは古い libc を同梱する CTF チャレンジでのみ使用してください。
- **Tcache era (≥2.26):** Tcache は 0x70 サイズの割当を吸収して fastbin/unsorted のプリミティブを機能停止させます。割当の**前に** (`setenv("GLIBC_TUNABLES","glibc.malloc.tcache_count=0",1);`) 無効化するか、各 0x70 tcache bin を 7 回の free で埋めてドレインしてください。
- **Safe-linking:** これは ≥2.32 で tcache/fastbin に適用されますが、House of Roman は **partial pointer overwrite of a libc address already present in fd/bk** のみを必要とするため、safe-linking は防御側にとってここでは有効ではありません（攻撃者は新しいポインタを偽造しません）。真の阻止要因はフックの削除と unsorted‑bin のチェックです。

### コード

- 例は [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c) にあります

### 目標

- 相対ポインタを悪用して RCE を得る

### 要件

- fastbin と unsorted bin のポインタを編集できること
- 12 ビットのランダム性を総当たりで突破する必要がある（成功確率 0.02%）

## 攻撃手順

### パート1: Fastbin Chunk points to __malloc_hook

いくつかのチャンクを作成します:

- `fastbin_victim` (0x60, offset 0): 後で heap ポインタを編集して LibC の値を指すようにする UAF チャンク。
- `chunk2` (0x80, offset 0x70): アライメント調整用
- `main_arena_use` (0x80, offset 0x100)
- `relative_offset_heap` (0x60, offset 0x190): `main_arena_use` チャンク上の相対オフセット

次に `free(main_arena_use)` を実行すると、このチャンクは unsorted リストに入れられ、`fd` と `bk` の両方に `main_arena + 0x68` へのポインタが入ります。

その後、`fd` と `bk` に `main_arena + 0x68` へのポインタを含むために、新しいチャンク `fake_libc_chunk(0x60)` を割り当てます。

その後、`relative_offset_heap` と `fastbin_victim` を free します。
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- `fastbin_victim` は `fd` が `relative_offset_heap` を指している
- `relative_offset_heap` は `fake_libc_chunk` からの距離のオフセットで、`fake_libc_chunk` は `main_arena + 0x68` へのポインタを含んでいる
- `fastbin_victim.fd` の最後のバイトを変更すると `fastbin_victim` が `main_arena + 0x68` を指すようになる。

これらの操作を行うために、攻撃者は `fastbin_victim` の fd ポインタを変更できる必要がある。

`main_arena + 0x68` はそれほど面白くないので、ポインタが **`__malloc_hook`** を指すように修正しよう。

`__memalign_hook` は通常 `0x7f` で始まりその前はゼロなので、`0x70` fast bin の値として偽装することが可能である。アドレスの下位4ビットが **ランダム** なため、目的の場所を指すようになる値は `2^4=16` 通りある。そこでここでは BF attack が行われ、チャンクは次のように終わる： **`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`.**

(残りのバイトの詳細については [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c) の説明を確認してください)。brute force が失敗するとプログラムは単にクラッシュする（動作するまで再起動する）。

次に、最初の2つの fast bin チャンクを取り除くために 2 回 malloc を行い、3 回目の malloc で **`__malloc_hook`** にチャンクを割り当てる。
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### パート2: Unsorted_bin attack

詳細は以下を参照してください：

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

要するに、`chunk->bk`で指定された任意の場所に`main_arena + 0x68`を書き込むことができます。攻撃では`__malloc_hook`を選びます。  
それを上書きした後、relative overwrite を使って `one_gadget` を指すようにします。

このため、まずchunkを取得して**unsorted bin**に入れます：
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
Use an UAF in this chunk to point `unsorted_bin_ptr->bk` to the address of `__malloc_hook` (we brute forced this previously).

> [!CAUTION]
> この攻撃はunsorted bin（したがって small と large も）を破損させる点に注意。したがって現在は**fast bin からの割り当てのみ使用できる**（より複雑なプログラムは他の割り当てを行いクラッシュする可能性がある）。また、これをトリガーするためには**同じサイズを割り当てる必要があり、さもなければプログラムはクラッシュする。**

So, to trigger the write of `main_arena + 0x68` in `__malloc_hook` we perform after setting `__malloc_hook` in `unsorted_bin_ptr->bk` we just need to do: **`malloc(0x80)`**

### ステップ3: \_\_malloc_hook を system に設定

In step one we controlled a chunk containing `__malloc_hook` (in the variable `malloc_hook_chunk`) and in the second step we managed to write `main_arena + 0x68` there.

ステップ1では`__malloc_hook`を含むチャンク（変数`malloc_hook_chunk`）を制御し、ステップ2ではそこに`main_arena + 0x68`を書き込むことに成功した。

Now, we abuse a partial overwrite in `malloc_hook_chunk` to use the libc address we wrote there (`main_arena + 0x68`) to **point to a `one_gadget` address**.

ここで、`malloc_hook_chunk` の部分オーバーライトを悪用し、そこに書いた libc アドレス（`main_arena + 0x68`）を使って **`one_gadget` のアドレスを指すようにする**。

Here is where it's needed to **bruteforce 12 bits of randomness** (more info in the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)).

ここで **12ビットのランダム性をブルートフォースする** 必要がある（詳細は [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c) を参照）。

Finally, once the correct address is overwritten, **call `malloc` and trigger the `one_gadget`**.

最後に、正しいアドレスが上書きされたら、**`malloc` を呼び出して `one_gadget` をトリガーする**。

## モダンなヒントとバリアント

- **Unsorted-bin check in 2.29+:** もし2.29–2.33で実行する必要があるなら、書き込みをトリガーする前に整合性チェックを満たすために `fd` **と** `bk` の両方を汚染する必要がある。さもなければ `_int_malloc` が中断する。成功率は非常に低く、通常はブルートフォースCTF環境でのみ実用的。
- **Hook removal (2.34+):** `__malloc_hook` が無くなった場合、後で再利用できる任意の書き込み可能な GOT/グローバルを狙うようにプリミティブを適応する（例：non-PIE バイナリで `exit@GOT` を上書きする）、もしくは House of Pie スタイルの top‑chunk ハイジャックにピボットして hook の代わりに `top` を制御する。
- **Any‑address fastbin alloc (2024 gist):** 最近の writeup は、まず libc ポインタを fastbin に置き、fixup 前に再指向することで `__free_hook` や他のグローバル上に fastbin で割り当てを行う同じ grooming を再利用することを示している。これは 2.24–2.28 で動作するが、2.29 の整合性チェックではまだ失敗する。

## References

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)
- [https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html](https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html)
- [https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc](https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc)

{{#include ../../banners/hacktricks-training.md}}
