# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## Основна інформація

This was a very interesting technique that allowed for RCE without leaks via fake fastbins, the unsorted_bin attack and relative overwrites. However it has been [**patched**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c).

### Застосовність у 2026

- **glibc window:** Works reliably on **2.23–2.28**. On **2.29** the additional `unsorted_chunks` integrity checks make the unsorted‑bin write unreliable, so success drops sharply. From **2.34** onward `__malloc_hook/__free_hook` were removed, making the original target unavailable. Use it only on old libc’s (or custom builds that keep the hooks) or for CTF challenges that ship an old libc.
- **Tcache era (≥2.26):** Tcache will eat your 0x70 allocations and stop the fastbin/unsorted primitives. Disable it (`setenv("GLIBC_TUNABLES","glibc.malloc.tcache_count=0",1);`) **before** any allocation or fill each 0x70 tcache bin with 7 frees to drain it.
- **Safe-linking:** It applies to tcache/fastbin in ≥2.32, but House of Roman only needs **partial pointer overwrite of a libc address already present in fd/bk**, so safe-linking does not help the defender here (the attacker never forges a fresh pointer). The real stopper is the hook removal and the unsorted-bin checks.

### Код

- You can find an example in [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)

### Мета

- RCE by abusing relative pointers

### Вимоги

- Edit fastbin and unsorted bin pointers
- Потрібно перебрати 12 біт випадковості (ймовірність успіху ≈ 0.02%)

## Кроки атаки

### Частина 1: Fastbin Chunk вказує на \_\_malloc_hook

Створіть кілька чанків:

- `fastbin_victim` (0x60, offset 0): UAF chunk later to edit the heap pointer later to point to the LibC value.
- `chunk2` (0x80, offset 0x70): For good alignment
- `main_arena_use` (0x80, offset 0x100)
- `relative_offset_heap` (0x60, offset 0x190): relative offset on the 'main_arena_use' chunk

Потім `free(main_arena_use)`, що помістить цей chunk в unsorted list і запише в `fd` і `bk` вказівник на `main_arena + 0x68`.

Після цього виділяється новий chunk `fake_libc_chunk(0x60)`, оскільки він міститиме вказівники на `main_arena + 0x68` в `fd` і `bk`.

Потім `relative_offset_heap` і `fastbin_victim` звільняються.
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- `fastbin_victim` має `fd`, який вказує на `relative_offset_heap`
- `relative_offset_heap` — це зсув від `fake_libc_chunk`, який містить вказівник на `main_arena + 0x68`
- Зміна останнього байта `fastbin_victim.fd` змушує `fastbin_victim` вказувати на `main_arena + 0x68`.

Для виконання наведених дій атакуючий повинен мати можливість змінювати вказівник fd у `fastbin_victim`.

Далі, `main_arena + 0x68` не є настільки цікавим, тому модифікуємо його так, щоб вказівник вказував на **`__malloc_hook`**.

Зауважте, що `__memalign_hook` зазвичай починається з `0x7f` і перед ним йдуть нулі, тому його можна підробити як значення в `0x70` fast bin. Оскільки останні 4 біти адреси є **випадковими**, існує `2^4=16` можливих варіантів, щоб значення в кінці вказувало на потрібне місце. Тому тут виконується BF attack, щоб chunk закінчувався так: **`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`.**

(For more info about the rest of the bytes check the explanation in the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)). Якщо brute force провалюється, програма просто падає (перезапускайте, поки не спрацює).

Далі виконуються 2 mallocs, щоб видалити 2 початкові fast bin chunks, і виділяється третій, щоб отримати chunk у **`__malloc_hook`**.
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### Частина 2: Unsorted_bin attack

Для детальнішої інформації перегляньте:

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

Але, по суті, це дозволяє записати `main_arena + 0x68` у будь-яке місце, вказане в `chunk->bk`. Для атаки ми обираємо `__malloc_hook`. Потім, після його перезапису, ми використаємо relative overwrite, щоб вказати на `one_gadget`.

Для цього ми спочатку виділяємо chunk і поміщаємо його в **unsorted bin**:
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
Використайте UAF у цьому chunk, щоб вказати `unsorted_bin_ptr->bk` на адресу `__malloc_hook` (ми brute forced це раніше).

> [!CAUTION]
> Зверніть увагу, що ця атака пошкоджує unsorted bin (а отже й small і large). Тому тепер ми можемо **use allocations from the fast bin only** (більш складна програма може зробити інші allocations і впасти), і щоб це спрацювало ми повинні **alloc того ж самого розміру або програма впаде.**

Отже, щоб викликати запис `main_arena + 0x68` у `__malloc_hook`, після встановлення `__malloc_hook` у `unsorted_bin_ptr->bk` нам потрібно просто зробити: **`malloc(0x80)`**

### Step 3: Set \_\_malloc_hook to system

На першому етапі ми контролювали chunk, що містив `__malloc_hook` (у змінній `malloc_hook_chunk`), а на другому етапі нам вдалося записати туди `main_arena + 0x68`.

Тепер ми зловживаємо partial overwrite у `malloc_hook_chunk`, щоб використати адресу libc, яку ми там записали (`main_arena + 0x68`), щоб **вказати на адресу `one_gadget`**.

Саме тут потрібно **bruteforce 12 бітів рандомності** (більше інформації в [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)).

Нарешті, коли правильна адреса перезаписана, **викличте `malloc` і спровокуйте `one_gadget``**.

## Modern tips & variants

- **Unsorted-bin check in 2.29+:** Якщо потрібно запускати на 2.29–2.33, пошкодьте обидва `fd` **і** `bk`, щоб задовольнити перевірку цілісності перед викликом запису; інакше `_int_malloc` викличе abort. Шанс успіху дуже низький і зазвичай придатний лише в brute-force CTF умовах.
- **Hook removal (2.34+):** Коли `__malloc_hook` прибрано, адаптуйте примітив так, щоб потрапити на будь-який записуваний GOT/global, який ви зможете пізніше перевикористати (наприклад, перезаписати `exit@GOT` у non-PIE бінарях), або переключіться на House of Pie‑стиль захоплення top‑chunk, щоб контролювати `top` замість hook.
- **Any‑address fastbin alloc (2024 gist):** Останній writeup показує повторне використання того самого grooming для fastbin‑алокації поверх `__free_hook` або інших globals, спочатку посадивши libc pointer у fastbin, а потім перенаправивши його перед fixup. Це працює на 2.24–2.28, але все ще провалюється на перевірках цілісності 2.29.

## References

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)
- [https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html](https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html)
- [https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc](https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc)

{{#include ../../banners/hacktricks-training.md}}
