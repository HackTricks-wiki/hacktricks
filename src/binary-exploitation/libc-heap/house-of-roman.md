# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

Dit was 'n baie interessante tegniek wat RCE moontlik gemaak het sonder leaks via fake fastbins, die unsorted_bin attack en relative overwrites. However it has been [**patched**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c).

### Toepasbaarheid in 2026

- **glibc window:** Werk betroubaar op **2.23–2.28**. Op **2.29** maak die bykomende `unsorted_chunks` integriteitskontroles die unsorted‑bin skryf onbetroubaar, sodat sukses skerp daal. Vanaf **2.34** is `__malloc_hook/__free_hook` verwyder, wat die oorspronklike teiken onbruikbaar maak. Gebruik dit net op ou libc’s (of custom builds wat die hooks behou) of vir CTF challenges wat 'n ou libc saamlewer.
- **Tcache era (≥2.26):** Tcache sal jou 0x70 allocations opeet en die fastbin/unsorted primitives stop. Deaktiveer dit (`setenv("GLIBC_TUNABLES","glibc.malloc.tcache_count=0",1);`) **before** any allocation of vul elke 0x70 tcache bin met 7 frees om dit te dreineer.
- **Safe-linking:** Dit geld vir tcache/fastbin in ≥2.32, maar House of Roman benodig slegs **partial pointer overwrite of a libc address already present in fd/bk**, so safe-linking help nie die verdediger hier nie (die aanvaller never forges 'n fresh pointer nie). Die werklike stopper is die verwydering van die hooks en die unsorted-bin kontroles.

### Kode

- Jy kan 'n voorbeeld vind by [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)

### Doel

- RCE deur relative pointers te misbruik

### Vereistes

- Wysig fastbin- en unsorted bin pointers
- 12 bits van randomness moet deur brute force gekraak word (0.02% kans om te werk)

## Aanvalstappe

### Deel 1: Fastbin Chunk wys na \_\_malloc_hook

Skep verskeie chunks:

- `fastbin_victim` (0x60, offset 0): UAF chunk wat later gebruik word om die heap-pointer te wysig sodat dit na die LibC waarde wys.
- `chunk2` (0x80, offset 0x70): Vir goeie uitlyning
- `main_arena_use` (0x80, offset 0x100)
- `relative_offset_heap` (0x60, offset 0x190): relatiewe offset op die 'main_arena_use' chunk

Dan `free(main_arena_use)` wat hierdie chunk in die unsorted-lys plaas en 'n pointer na `main_arena + 0x68` in beide die `fd` en `bk` pointers sal kry.

Nou word 'n nuwe chunk `fake_libc_chunk(0x60)` toegeken omdat dit die pointers na `main_arena + 0x68` in `fd` en `bk` sal bevat.

Dan word `relative_offset_heap` en `fastbin_victim` vrygestel.
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- `fastbin_victim` het 'n `fd` wat na `relative_offset_heap` wys
- `relative_offset_heap` is 'n offset vanaf `fake_libc_chunk`, wat 'n pointer na `main_arena + 0x68` bevat
- Om die laaste byte van `fastbin_victim.fd` te verander laat `fastbin_victim` na `main_arena + 0x68` wys.

Vir die vorige stappe moet die aanvaller in staat wees om die fd-pointer van `fastbin_victim` te wysig.

Dan is `main_arena + 0x68` nie so interessant nie, so laat ons dit wysig sodat die pointer na **`__malloc_hook`** wys.

Let wel dat `__memalign_hook` gewoonlik met `0x7f` begin en voorafgaande nulles het, en daarom is dit moontlik om dit as 'n waarde in die `0x70` fast bin te valseer. Omdat die laaste 4 biti van die adres **random** is, is daar `2^4=16` moontlikhede dat die waarde eindig waar ons belangstel. So 'n BF attack word hier uitgevoer sodat die chunk eindig soos: **`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`.**

(For more info about the rest of the bytes check the explanation in the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)). If the brute force fails the program just crashes (restart until it works).

Dan word 2 mallocs uitgevoer om die 2 aanvanklike fast bin chunks te verwyder en 'n derde een word gealloceer om 'n chunk in **`__malloc_hook`** te kry.
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### Deel 2: Unsorted_bin attack

Vir meer info kan jy kyk:

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

Maar basies stel dit in staat om `main_arena + 0x68` na enige ligging te skryf wat in `chunk->bk` aangedui is. Vir die aanval kies ons `__malloc_hook`. Daarna, nadat ons dit oorskryf het, gebruik ons 'n relative overwrite om na 'n `one_gadget` te wys.

Hiervoor begin ons 'n chunk kry en dit in die **unsorted bin** plaas:
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
Use an UAF in this chunk to point `unsorted_bin_ptr->bk` to the address of `__malloc_hook` (we brute forced this previously).

> [!CAUTION]
> Note that this attack corrupts the unsorted bin (hence small and large too). So we can only **use allocations from the fast bin now** (a more complex program might do other allocations and crash), and to trigger this we must **alloc the same size or the program will crash.**

So, to trigger the write of `main_arena + 0x68` in `__malloc_hook` we perform after setting `__malloc_hook` in `unsorted_bin_ptr->bk` we just need to do: **`malloc(0x80)`**

### Stap 3: Stel \_\_malloc_hook to system

In stap een het ons beheer gehad oor 'n chunk wat `__malloc_hook` bevat (in die veranderlike `malloc_hook_chunk`) en in die tweede stap het ons daar met sukses `main_arena + 0x68` geskryf.

Nou misbruik ons 'n partial overwrite in `malloc_hook_chunk` om die libc-adres wat ons daar geskryf het (`main_arena + 0x68`) te gebruik om **na 'n `one_gadget` adres te wys**.

Hier is waar dit nodig is om **bruteforce 12 bits of randomness** (more info in the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)).

Laastens, sodra die korrekte adres oorskryf is, **roep `malloc` aan en trigger die `one_gadget`**.

## Moderne tips & variante

- **Unsorted-bin check in 2.29+:** As jy dit moet laat loop op 2.29–2.33, korrupteer beide `fd` **en** `bk` om die integriteitskontrole te bevredig voordat jy die skryf trigger; anders sal `_int_malloc` abort. Sukseskoers is baie laag en gewoonlik slegs lewensvatbaar in brute-force CTF settings.
- **Hook removal (2.34+):** Met `__malloc_hook` weg, pas die primitive aan om op enige writable GOT/global te land wat jy later kan hergebruik (e.g., overwrite `exit@GOT` in non-PIE binaries) of pivot na 'n **House of Pie** style top‑chunk hijack om `top` te beheer in plaas van 'n hook.
- **Any‑address fastbin alloc (2024 gist):** 'n Onlangse writeup wys hoe om dieselfde grooming te hergebruik om fastbin‑allocate oor `__free_hook` of ander globals te doen deur eers 'n libc pointer in fastbin te land en dit dan voor die fixup te her‑wys. Dit werk op 2.24–2.28 maar faal steeds op 2.29 integriteitskontroles.

## References

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)
- [https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html](https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html)
- [https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc](https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc)

{{#include ../../banners/hacktricks-training.md}}
