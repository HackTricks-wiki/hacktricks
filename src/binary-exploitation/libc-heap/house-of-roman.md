# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## Podstawowe informacje

Była to bardzo interesująca technika, która pozwalała na RCE bez leaks poprzez fake fastbins, the unsorted_bin attack i relative overwrites. Jednak została [**patched**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c).

### Zastosowalność w 2026

- **glibc window:** Działa niezawodnie na **2.23–2.28**. W **2.29** dodatkowe sprawdzenia integralności `unsorted_chunks` powodują, że zapis do unsorted‑bin staje się zawodny, więc prawdopodobieństwo powodzenia gwałtownie spada. Od **2.34** `__malloc_hook/__free_hook` zostały usunięte, co sprawia, że pierwotny cel jest niedostępny. Używaj tego tylko na starych libc (lub niestandardowych kompilacjach, które zachowują hooki) lub do zadań CTF, które dostarczają starą libc.
- **Tcache era (≥2.26):** Tcache pochłonie twoje alokacje 0x70 i zablokuje fastbin/unsorted primitives. Wyłącz go (`setenv("GLIBC_TUNABLES","glibc.malloc.tcache_count=0",1);`) **przed** jakąkolwiek alokacją lub wypełnij każdy 0x70 tcache bin 7 frees, aby go opróżnić.
- **Safe-linking:** Dotyczy tcache/fastbin w ≥2.32, ale House of Roman wymaga tylko **partial pointer overwrite of a libc address already present in fd/bk**, więc safe-linking nie pomaga obrońcy tutaj (atakujący nigdy nie podrabia nowego wskaźnika). Prawdziwą przeszkodą jest usunięcie hooków i sprawdzenia unsorted-bin.

### Code

- Przykład znajdziesz w [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)

### Cel

- RCE przez wykorzystanie relative pointers

### Wymagania

- Edytować wskaźniki fastbin i unsorted bin
- Trzeba bruteforcować 12 bitów losowości (0.02% szansy) na powodzenie

## Kroki ataku

### Część 1: Fastbin Chunk wskazuje na \_\_malloc_hook

Utwórz kilka chunków:

- `fastbin_victim` (0x60, offset 0): UAF chunk, później użyty do edycji heap pointer, aby wskazywał na wartość LibC.
- `chunk2` (0x80, offset 0x70): Dla dobrego wyrównania
- `main_arena_use` (0x80, offset 0x100)
- `relative_offset_heap` (0x60, offset 0x190): względny offset w 'main_arena_use' chunku

Następnie `free(main_arena_use)`, co umieści ten chunk na liście unsorted i spowoduje, że zarówno `fd`, jak i `bk` będą zawierać wskaźnik do `main_arena + 0x68`.

Następnie alokowany jest nowy chunk `fake_libc_chunk(0x60)`, ponieważ będzie zawierał wskaźniki do `main_arena + 0x68` w `fd` i `bk`.

Potem `relative_offset_heap` i `fastbin_victim` zostają zwolnione.
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- `fastbin_victim` ma `fd` wskazujący na `relative_offset_heap`
- `relative_offset_heap` jest offsetem odległości od `fake_libc_chunk`, który zawiera wskaźnik do `main_arena + 0x68`
- Zmiana ostatniego bajtu `fastbin_victim.fd` sprawia, że `fastbin_victim` wskazuje na `main_arena + 0x68`.

Aby wykonać powyższe działania, atakujący musi być w stanie zmodyfikować wskaźnik fd `fastbin_victim`.

Następnie `main_arena + 0x68` nie jest zbyt interesujący, więc zmodyfikujmy go tak, aby wskaźnik wskazywał na **`__malloc_hook`**.

Zauważ, że `__memalign_hook` zazwyczaj zaczyna się od `0x7f` i przed nim są zera, więc możliwe jest sfałszowanie go jako wartość w `0x70` fast bin. Ponieważ ostatnie 4 bity adresu są **random**, istnieje `2^4=16` możliwości, by wartość końcowo wskazywała tam, gdzie nas interesuje. Dlatego tutaj przeprowadza się BF attack, tak że chunk kończy się następująco: **`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`.**

(For more info about the rest of the bytes check the explanation in the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)). Jeśli brute force nie powiedzie się, program po prostu się zawiesi (restartuj aż zadziała).

Następnie wykonuje się 2 mallocs, aby usunąć 2 początkowe fast bin chunks, a trzeci jest zaalokowany, aby dostać chunk w **`__malloc_hook`**.
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### Part 2: Unsorted_bin attack

Po więcej informacji sprawdź:

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

Ale w praktyce pozwala zapisać `main_arena + 0x68` w dowolnym miejscu wskazanym przez `chunk->bk`. Dla ataku wybieramy `__malloc_hook`. Następnie, po jego nadpisaniu, użyjemy relative overwrite, aby wskazać na `one_gadget`.

W tym celu najpierw pobieramy chunk i umieszczamy go w **unsorted bin**:
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
Wykorzystaj UAF w tym chunku, aby ustawić `unsorted_bin_ptr->bk` na adres `__malloc_hook` (to wcześniej bruteforcowaliśmy).

> [!CAUTION]
> Zwróć uwagę, że ten atak uszkadza unsorted bin (a więc także small i large). Dlatego teraz możemy **używać jedynie alokacji z fast bin** (bardziej złożony program może wykonać inne alokacje i się zablokować), i aby to wywołać musimy **alokować tego samego rozmiaru, inaczej program się wykrzaczy.**

Zatem, aby spowodować zapis `main_arena + 0x68` do `__malloc_hook` po ustawieniu `__malloc_hook` w `unsorted_bin_ptr->bk` wystarczy wykonać: **`malloc(0x80)`**

### Step 3: Set \_\_malloc_hook to system

W kroku pierwszym kontrolowaliśmy chunk zawierający `__malloc_hook` (w zmiennej `malloc_hook_chunk`), a w kroku drugim udało nam się tam zapisać `main_arena + 0x68`.

Teraz wykorzystujemy częściowe nadpisanie w `malloc_hook_chunk`, aby użyć adresu libc tam zapisanego (`main_arena + 0x68`) do **wskazania na adres `one_gadget`**.

W tym miejscu trzeba **bruteforcować 12 bitów losowości** (więcej informacji w how2heap [example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)).

Wreszcie, gdy poprawny adres zostanie nadpisany, **wywołaj `malloc` i wyzwól `one_gadget`**.

## Nowoczesne wskazówki i warianty

- **Unsorted-bin check in 2.29+:** Jeśli musisz uruchomić na 2.29–2.33, skorumpuj zarówno `fd` **i** `bk`, aby spełnić sprawdzenie integralności przed wywołaniem zapisu; w przeciwnym razie `_int_malloc` abortuje. Współczynnik powodzenia jest bardzo niski i zwykle opłaca się tylko w ustawieniach CTF wymagających brute-force.
- **Hook removal (2.34+):** Gdy `__malloc_hook` zniknie, zaadaptuj prymityw tak, aby wylądował na dowolnym zapisywalnym GOT/globalu, którego później możesz użyć (np. nadpisanie `exit@GOT` w binariach non-PIE) lub przejdź do hijacku top-chunka w stylu **House of Pie**, aby kontrolować `top` zamiast hooka.
- **Any‑address fastbin alloc (2024 gist):** Ostatnia publikacja pokazuje ponowne wykorzystanie tego samego groomingu, aby fastbin‑alokować nad `__free_hook` lub innymi globalami, najpierw umieszczając wskaźnik libc w fastbin, a potem przestawiając go przed fixupem. Działa to na 2.24–2.28, ale nadal nie przechodzi sprawdzeń integralności w 2.29.

## Źródła

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)
- [https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html](https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html)
- [https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc](https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc)

{{#include ../../banners/hacktricks-training.md}}
