# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## बुनियादी जानकारी

यह एक बहुत ही दिलचस्प तकनीक थी जिसने fake fastbins, the unsorted_bin attack और relative overwrites के माध्यम से leaks के बिना RCE की अनुमति दी। हालांकि इसे [**patched**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c) कर दिया गया है।

### 2026 में प्रयोज्यता

- **glibc window:** यह भरोसेमंद रूप से **2.23–2.28** पर काम करता है। **2.29** पर अतिरिक्त `unsorted_chunks` integrity checks unsorted‑bin write को अविश्वसनीय बना देते हैं, इसलिए सफलता तेज़ी से घट जाती है। **2.34** से `__malloc_hook/__free_hook` हटा दिए गए हैं, जिससे मूल लक्ष्य उपलब्ध नहीं रहता। इसे केवल पुराने libc पर (या ऐसे custom builds जो hooks रखते हैं) या उन CTF challenges के लिए उपयोग करें जो पुराना libc साथ भेजते हैं।
- **Tcache era (≥2.26):** Tcache आपके 0x70 allocations को खा जाएगा और fastbin/unsorted primitives को रोक देगा। इसे अक्षम करें (`setenv("GLIBC_TUNABLES","glibc.malloc.tcache_count=0",1);`) **किसी भी allocation से पहले** या हर 0x70 tcache bin को 7 frees से भरकर उसे ड्रेन करें।
- **Safe-linking:** यह ≥2.32 में tcache/fastbin पर लागू होता है, लेकिन House of Roman को केवल **partial pointer overwrite of a libc address already present in fd/bk** की आवश्यकता होती है, इसलिए safe-linking यहाँ defender की मदद नहीं करता (attacker कभी नया pointer forge नहीं करता)। असली रोड़ा hooks हटाने और unsorted-bin checks हैं।

### कोड

- You can find an example in [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)

### लक्ष्य

- RCE by abusing relative pointers

### आवश्यकताएँ

- fastbin और unsorted bin pointers को संपादित करना
- 12 bits की randomness को brute force करना होगा (काम करने की संभावना 0.02%)

## आक्रमण के कदम

### भाग 1: Fastbin Chunk __malloc_hook की ओर इशारा करता है

कई chunks बनाएं:

- `fastbin_victim` (0x60, offset 0): बाद में UAF chunk जिससे heap pointer को LibC value की ओर एडिट किया जाएगा।
- `chunk2` (0x80, offset 0x70): अच्छे alignment के लिए
- `main_arena_use` (0x80, offset 0x100)
- `relative_offset_heap` (0x60, offset 0x190): 'main_arena_use' chunk पर relative offset

फिर `free(main_arena_use)` करें जो इस chunk को unsorted list में रखेगा और `fd` और `bk` दोनों में `main_arena + 0x68` का pointer प्राप्त करेगा।

अब एक नया chunk `fake_libc_chunk(0x60)` allocate किया जाता है क्योंकि यह `fd` और `bk` में `main_arena + 0x68` के pointers रखेगा।

फिर `relative_offset_heap` और `fastbin_victim` को free कर दिया जाता है।
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- `fastbin_victim` का `fd` `relative_offset_heap` की ओर इशारा करता है
- `relative_offset_heap` `fake_libc_chunk` से दूरी का offset है, जिसमें `main_arena + 0x68` की ओर एक pointer होता है
- `fastbin_victim.fd` के आखिरी बाइट को बदलने से `fastbin_victim` `main_arena + 0x68` की ओर पॉइंट करता है।

पिछले कदमों के लिए, attacker को `fastbin_victim` के fd pointer को modify करने में सक्षम होना चाहिए।

फिर, `main_arena + 0x68` काफी रोचक नहीं है, इसलिए इसे modify करके pointer को **`__malloc_hook`** की ओर इशारा करवाते हैं।

ध्यान दें कि `__memalign_hook` आमतौर पर `0x7f` से शुरू होता है और उसके पहले zeros होते हैं, इसलिए इसे `0x70` fast bin में एक वैल्यू के रूप में नकली बनाना संभव है। चूँकि एड्रेस के अंतिम 4 बिट्स **random** होते हैं, इसलिए उस वैल्यू के हमारे इच्छित स्थान पर अंत होने की `2^4=16` संभावनाएँ हैं। इसलिए यहाँ एक BF attack किया जाता है ताकि chunk इस तरह खत्म हो: **`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`.**

(बाकी बाइट्स के बारे में अधिक जानकारी के लिए [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c) में दिए गए explanation को देखें). If the brute force fails the program just crashes (restart until it works).

फिर, 2 mallocs किए जाते हैं ताकि शुरुआती 2 fast bin chunks हट जाएँ और तीसरा allocate किया जाता है ताकि **`__malloc_hook`** में एक chunk मिल सके।
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### भाग 2: Unsorted_bin attack

अधिक जानकारी के लिए आप देख सकते हैं:

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

लेकिन मूलतः यह `main_arena + 0x68` को `chunk->bk` में निर्दिष्ट किसी भी स्थान पर लिखने की अनुमति देता है। हम इस attack के लिए `__malloc_hook` चुनते हैं। फिर, उसे overwrite करने के बाद हम एक relative overwrite का उपयोग करके इसे `one_gadget` की ओर पॉइंट करेंगे।

इसके लिए हम एक chunk लेकर उसे **unsorted bin** में डालते हैं:
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
Use an UAF in this chunk to point `unsorted_bin_ptr->bk` to the address of `__malloc_hook` (we brute forced this previously).

> [!CAUTION]
> ध्यान दें कि यह attack unsorted bin को corrupt कर देता है (और इसलिए small और large भी)। इसलिए अब हम केवल **fast bin से allocations का उपयोग कर सकते हैं** (एक अधिक complex प्रोग्राम अन्य allocations कर सकता है और crash कर सकता है), और इसे trigger करने के लिए हमें **इसी size की alloc करनी होगी वरना प्रोग्राम crash हो जाएगा।**

So, to trigger the write of `main_arena + 0x68` in `__malloc_hook` we perform after setting `__malloc_hook` in `unsorted_bin_ptr->bk` we just need to do: **`malloc(0x80)`**

### Step 3: \_\_malloc_hook को system पर सेट करें

In step one we controlled a chunk containing `__malloc_hook` (in the variable `malloc_hook_chunk`) and in the second step we managed to write `main_arena + 0x68` there.

Now, we abuse a partial overwrite in `malloc_hook_chunk` to use the libc address we wrote there (`main_arena + 0x68`) to **point to a `one_gadget` address**.

Here is where it's needed to **bruteforce 12 bits of randomness** (more info in the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)).

Finally, once the correct address is overwritten, **call `malloc` and trigger the `one_gadget`**.

## आधुनिक सुझाव और वेरिएंट्स

- **Unsorted-bin check in 2.29+:** यदि आपको 2.29–2.33 पर चलाना है, तो write trigger करने से पहले integrity check संतुष्ट करने के लिए दोनों `fd` **और** `bk` को corrupt करें; अन्यथा `_int_malloc` abort कर देता है। सफलता दर बहुत कम है और आमतौर पर केवल brute-force CTF सेटिंग्स में ही व्यावहारिक है।
- **Hook removal (2.34+):** जब `__malloc_hook` हट गया है, तो primitive को किसी भी writable GOT/global पर ले जाने के लिए अनुकूलित करें जिसे आप बाद में पुन: उपयोग कर सकें (उदा., non-PIE binaries में `exit@GOT` को overwrite करना) या **House of Pie** शैली के top‑chunk hijack की ओर pivot करें ताकि hook की बजाय `top` को control किया जा सके।
- **Any‑address fastbin alloc (2024 gist):** एक हालिया writeup दिखाता है कि उसी grooming को reuse करके पहले libc pointer को fastbin में लैंड कराकर और फिर fixup से पहले उसे फिर से पॉइंट करके `__free_hook` या अन्य globals पर fastbin‑allocate किया जा सकता है। यह 2.24–2.28 पर काम करता है लेकिन 2.29 के integrity checks पर विफल हो जाता है।

## संदर्भ

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)
- [https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html](https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html)
- [https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc](https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc)

{{#include ../../banners/hacktricks-training.md}}
