# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## Informações Básicas

Esta foi uma técnica muito interessante que permitia RCE sem leaks via fake fastbins, o ataque unsorted_bin e sobrescritas relativas. No entanto, ela foi [**patched**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c).

### Aplicabilidade em 2026

- **glibc window:** Funciona de forma confiável em **2.23–2.28**. No **2.29** as verificações adicionais de integridade de `unsorted_chunks` tornam a escrita no unsorted‑bin pouco confiável, então a taxa de sucesso cai abruptamente. A partir do **2.34**, `__malloc_hook/__free_hook` foram removidos, tornando o alvo original indisponível. Use-o apenas em libc antigas (ou builds customizados que mantenham os hooks) ou para desafios CTF que incluam uma libc antiga.
- **Tcache era (≥2.26):** O Tcache vai consumir suas alocações 0x70 e impedir as primitivas fastbin/unsorted. Desative-o (`setenv("GLIBC_TUNABLES","glibc.malloc.tcache_count=0",1);`) **antes** de qualquer alocação ou encha cada bin tcache de 0x70 com 7 frees para drená-lo.
- **Safe-linking:** Aplica-se a tcache/fastbin em ≥2.32, mas House of Roman precisa apenas de uma sobrescrita parcial de ponteiro de um endereço libc já presente em fd/bk, então o safe-linking não ajuda o defensor aqui (o atacante nunca forja um ponteiro novo). O verdadeiro obstáculo é a remoção dos hooks e as verificações do unsorted‑bin.

### Code

- Você pode encontrar um exemplo em [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)

### Objetivo

- RCE por meio do abuso de ponteiros relativos

### Requisitos

- Editar ponteiros de fastbin e unsorted bin
- 12 bits de aleatoriedade precisam ser forçados por força bruta (chance de 0,02%) para funcionar

## Passos do Ataque

### Parte 1: Chunk de fastbin aponta para __malloc_hook

Crie vários chunks:

- `fastbin_victim` (0x60, offset 0): Chunk UAF que será usado depois para editar o ponteiro do heap de modo a apontar para o valor da LibC.
- `chunk2` (0x80, offset 0x70): Para bom alinhamento
- `main_arena_use` (0x80, offset 0x100)
- `relative_offset_heap` (0x60, offset 0x190): offset relativo no chunk 'main_arena_use'

Então faça `free(main_arena_use)`, o que colocará esse chunk na lista unsorted e fará com que `fd` e `bk` recebam um ponteiro para `main_arena + 0x68`.

Agora aloca-se um novo chunk `fake_libc_chunk(0x60)` porque ele conterá os ponteiros para `main_arena + 0x68` em `fd` e `bk`.

Depois `relative_offset_heap` e `fastbin_victim` são liberados.
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- `fastbin_victim` tem um `fd` apontando para `relative_offset_heap`
- `relative_offset_heap` é um offset de distância a partir de `fake_libc_chunk`, que contém um ponteiro para `main_arena + 0x68`
- Alterar o último byte de `fastbin_victim.fd` faz com que `fastbin_victim` aponte para `main_arena + 0x68`.

Para as ações anteriores, o atacante precisa ser capaz de modificar o ponteiro fd de `fastbin_victim`.

Então, `main_arena + 0x68` não é tão interessante, então vamos modificá-lo para que o ponteiro aponte para **`__malloc_hook`**.

Observe que `__memalign_hook` normalmente começa com `0x7f` e zeros antes, então é possível forjá-lo como um valor no fast bin de `0x70`. Como os últimos 4 bits do endereço são **aleatórios**, existem `2^4=16` possibilidades para o valor acabar apontando para onde nos interessa. Portanto, um BF attack é realizado aqui, de modo que o chunk termina assim: **`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`**.

(Para mais informações sobre o restante dos bytes verifique a explicação em [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)). Se o brute force falhar, o programa simplesmente trava (reinicie até funcionar).

Em seguida, são executados 2 mallocs para remover os 2 chunks iniciais do fast bin e um terceiro é alocado para obter um chunk em **`__malloc_hook`**.
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### Part 2: Unsorted_bin attack

Para mais informações você pode consultar:

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

Mas basicamente isso permite escrever `main_arena + 0x68` para qualquer localização especificada em `chunk->bk`. Para o ataque escolhemos `__malloc_hook`. Então, depois de sobrescrevê-lo, usaremos uma sobrescrita relativa para apontar para um `one_gadget`.

Para isso, começamos por obter um chunk e colocá-lo no **unsorted bin**:
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
Use an UAF in this chunk to point `unsorted_bin_ptr->bk` to the address of `__malloc_hook` (isso foi brute forced anteriormente).

> [!CAUTION]
> Note that this attack corrupts the unsorted bin (hence small and large too). So we can only **use allocations from the fast bin now** (a more complex program might do other allocations and crash), and to trigger this we must **alloc the same size or the program will crash.**

So, to trigger the write of `main_arena + 0x68` in `__malloc_hook` we perform after setting `__malloc_hook` in `unsorted_bin_ptr->bk` we just need to do: **`malloc(0x80)`**

### Passo 3: Definir \_\_malloc_hook para system

No passo um controlamos um chunk contendo `__malloc_hook` (na variável `malloc_hook_chunk`) e no segundo passo conseguimos escrever `main_arena + 0x68` ali.

Agora, abusamos de um partial overwrite em `malloc_hook_chunk` para usar o endereço libc que escrevemos ali (`main_arena + 0x68`) para **apontar para um endereço `one_gadget`**.

Aqui é onde é necessário bruteforce 12 bits of randomness (mais info no exemplo do how2heap).

Finalmente, uma vez que o endereço correto esteja sobrescrito, chame `malloc` e acione o `one_gadget`.

## Modern tips & variants

- **Unsorted-bin check in 2.29+:** If you must run on 2.29–2.33, corrupt both `fd` **and** `bk` to satisfy the integrity check before triggering the write; otherwise `_int_malloc` aborts. Success rate is very low and usually only viable in brute-force CTF settings.
- **Hook removal (2.34+):** With `__malloc_hook` gone, adapt the primitive to land on any writable GOT/global you can later reuse (e.g., overwrite `exit@GOT` in non-PIE binaries) or pivot to a **House of Pie** style top‑chunk hijack to control `top` instead of a hook.
- **Any‑address fastbin alloc (2024 gist):** A recent writeup shows reusing the same grooming to fastbin‑allocate over `__free_hook` or other globals by first landing a libc pointer in fastbin and then re‑pointing it before the fixup. This works on 2.24–2.28 but still dies on 2.29 integrity checks.

## Referências

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)
- [https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html](https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html)
- [https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc](https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc)

{{#include ../../banners/hacktricks-training.md}}
