# House of Roman

{{#include ../../banners/hacktricks-training.md}}

## Información básica

Esta fue una técnica muy interesante que permitía RCE sin leaks vía fake fastbins, el ataque unsorted_bin y relative overwrites. However it has been [**patched**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c).

### Aplicabilidad en 2026

- **Ventana de glibc:** Funciona de forma fiable en **2.23–2.28**. En **2.29** las comprobaciones de integridad adicionales de `unsorted_chunks` hacen que la escritura en unsorted‑bin sea poco fiable, por lo que la probabilidad de éxito cae drásticamente. Desde **2.34** en adelante se eliminaron `__malloc_hook/__free_hook`, haciendo que el objetivo original no esté disponible. Usarlo solo en libc antiguas (o builds personalizados que mantengan los hooks) o en challenges CTF que incluyan una libc antigua.
- **Era Tcache (≥2.26):** Tcache consumirá tus asignaciones 0x70 y detendrá los primitivos fastbin/unsorted. Desactívalo (`setenv("GLIBC_TUNABLES","glibc.malloc.tcache_count=0",1);`) **antes** de cualquier asignación o llena cada bin tcache de 0x70 con 7 frees para drenarlo.
- **Safe-linking:** Se aplica a tcache/fastbin en ≥2.32, pero House of Roman solo necesita **sobrescritura parcial de puntero de una dirección libc ya presente en fd/bk**, por lo que safe-linking no ayuda al defensor aquí (el atacante nunca forja un puntero nuevo). El verdadero obstáculo es la eliminación de los hooks y las comprobaciones del unsorted‑bin.

### Código

- Puedes encontrar un ejemplo en [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)

### Objetivo

- RCE abusando de punteros relativos

### Requisitos

- Editar punteros fastbin y unsorted bin
- Es necesario forzar por fuerza bruta 12 bits de aleatoriedad (0.02% de probabilidad) para que funcione

## Pasos del ataque

### Parte 1: Fastbin Chunk points to \_\_malloc_hook

Crear varios chunks:

- `fastbin_victim` (0x60, offset 0): UAF chunk que más tarde permitirá editar el puntero del heap para que apunte al valor en LibC.
- `chunk2` (0x80, offset 0x70): Para un buen alineado
- `main_arena_use` (0x80, offset 0x100)
- `relative_offset_heap` (0x60, offset 0x190): offset relativo en el chunk 'main_arena_use'

Luego `free(main_arena_use)` colocará este chunk en la lista unsorted y pondrá un puntero a `main_arena + 0x68` tanto en los punteros `fd` como `bk`.

Ahora se asigna un nuevo chunk `fake_libc_chunk(0x60)` porque contendrá los punteros a `main_arena + 0x68` en `fd` y `bk`.

Luego se liberan `relative_offset_heap` y `fastbin_victim`.
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
- `fastbin_victim` tiene un `fd` que apunta a `relative_offset_heap`
- `relative_offset_heap` es un offset de distancia desde `fake_libc_chunk`, que contiene un puntero a `main_arena + 0x68`
- Cambiar el último byte de `fastbin_victim.fd` hace que `fastbin_victim` apunte a `main_arena + 0x68`.

Para las acciones anteriores, el atacante necesita ser capaz de modificar el puntero fd de `fastbin_victim`.

Luego, `main_arena + 0x68` no es tan interesante, así que modifiquémoslo para que el puntero apunte a **`__malloc_hook`**.

Nota que `__memalign_hook` normalmente empieza con `0x7f` y ceros antes, por lo que es posible falsificarlo como un valor en el fast bin de `0x70`. Debido a que los últimos 4 bits de la dirección son **random** hay `2^4=16` posibilidades para que el valor termine apuntando donde nos interesa. Por eso se realiza aquí un BF attack de manera que el chunk queda así: **`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`.**

(For more info about the rest of the bytes check the explanation in the [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)). If the brute force fails the program just crashes (restart until it works).

Luego, se realizan 2 mallocs para eliminar los 2 chunks iniciales del fast bin y un tercero se asigna para obtener un chunk en **`__malloc_hook`**.
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### Parte 2: Unsorted_bin attack

Para más información puedes consultar:

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

Pero básicamente permite escribir `main_arena + 0x68` en cualquier ubicación especificada en `chunk->bk`. Para el ataque elegimos `__malloc_hook`. Luego, después de sobrescribirlo usaremos una sobrescritura relativa para apuntar a un `one_gadget`.

Para esto empezamos obteniendo un chunk y colocándolo en el **unsorted bin**:
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
Use an UAF in this chunk to point `unsorted_bin_ptr->bk` to the address of `__malloc_hook` (we brute forced this previously).

> [!CAUTION]
> Note that this attack corrupts the unsorted bin (hence small and large too). So we can only **use allocations from the fast bin now** (a more complex program might do other allocations and crash), and to trigger this we must **alloc the same size or the program will crash.**

So, to trigger the write of `main_arena + 0x68` in `__malloc_hook` we perform after setting `__malloc_hook` in `unsorted_bin_ptr->bk` we just need to do: **`malloc(0x80)`**

### Paso 3: Establecer \_\_malloc_hook a system

En el paso uno controlábamos un chunk que contenía `__malloc_hook` (en la variable `malloc_hook_chunk`) y en el segundo paso logramos escribir `main_arena + 0x68` ahí.

Ahora, abusamos de una sobrescritura parcial en `malloc_hook_chunk` para usar la dirección libc que escribimos allí (`main_arena + 0x68`) para **apuntar a una dirección de `one_gadget`**.

Aquí es donde es necesario **forzar por fuerza bruta 12 bits de aleatoriedad** (más info en el [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)[ example](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)).

Finalmente, una vez que la dirección correcta esté sobrescrita, **llama a `malloc` y dispara el `one_gadget`**.

## Consejos modernos & variantes

- **Unsorted-bin check in 2.29+:** Si debes ejecutar en 2.29–2.33, corrompe tanto `fd` **como** `bk` para satisfacer la verificación de integridad antes de desencadenar la escritura; de lo contrario `_int_malloc` aborta. La tasa de éxito es muy baja y generalmente solo viable en escenarios CTF de fuerza bruta.
- **Hook removal (2.34+):** Con `__malloc_hook` eliminado, adapta el primitivo para apuntar a cualquier GOT/global escribible que puedas reutilizar después (p.ej., sobrescribir `exit@GOT` en binarios sin PIE) o pivotar a un secuestro de top‑chunk estilo **House of Pie** para controlar `top` en lugar de un hook.
- **Any‑address fastbin alloc (2024 gist):** Un writeup reciente muestra reutilizar el mismo grooming para fastbin‑allocar sobre `__free_hook` u otros globals poniendo primero un puntero libc en fastbin y luego re‑apuntándolo antes del fixup. Esto funciona en 2.24–2.28 pero aún falla por las verificaciones de integridad de 2.29.

## Referencias

- [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_roman/)
- [https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html](https://halloween.synacktiv.com/publications/heap-tricks-never-get-old-insomnihack-teaser-2022.html)
- [https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc](https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc)

{{#include ../../banners/hacktricks-training.md}}
