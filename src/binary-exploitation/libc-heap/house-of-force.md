# House of Force

{{#include ../../banners/hacktricks-training.md}}

## Grundinformationen

### Code

- Diese Technik wurde gepatcht ([**hier**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c)) und erzeugt diesen Fehler: `malloc(): corrupted top size`
- Du kannst den [**Code von hier**](https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html) ausprobieren, um ihn zu testen, wenn du möchtest.

### Ziel

- Das Ziel dieses Angriffs ist es, einen Chunk an einer bestimmten Adresse zuzuweisen.

### Anforderungen

- Ein Überlauf, der es ermöglicht, die Größe des Top-Chunk-Headers zu überschreiben (z.B. -1).
- In der Lage sein, die Größe der Heap-Zuweisung zu kontrollieren.

### Angriff

Wenn ein Angreifer einen Chunk an der Adresse P zuweisen möchte, um einen Wert hier zu überschreiben. Er beginnt damit, die Größe des Top-Chunks mit `-1` zu überschreiben (vielleicht mit einem Überlauf). Dies stellt sicher, dass malloc mmap für keine Zuweisung verwenden wird, da der Top-Chunk immer genügend Platz haben wird.

Dann berechne den Abstand zwischen der Adresse des Top-Chunks und dem Zielbereich, der zugewiesen werden soll. Dies liegt daran, dass eine malloc mit dieser Größe durchgeführt wird, um den Top-Chunk an diese Position zu verschieben. So kann der Unterschied/die Größe leicht berechnet werden:
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
Daher wird die Größe von `target - old_top - 4*sizeof(long)` (die 4 longs sind wegen der Metadaten des oberen Chunks und des neuen Chunks bei der Zuweisung) zugewiesen, was den oberen Chunk an die Adresse verschiebt, die wir überschreiben möchten.\
Dann wird ein weiteres malloc durchgeführt, um einen Chunk an der Zieladresse zu erhalten.

### Referenzen & Weitere Beispiele

- [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/)
- [https://heap-exploitation.dhavalkapil.com/attacks/house_of_force](https://heap-exploitation.dhavalkapil.com/attacks/house_of_force)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c)
- [https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html](https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#hitcon-training-lab-11)
- Das Ziel dieses Szenarios ist ein ret2win, bei dem wir die Adresse einer Funktion ändern müssen, die durch die Adresse der ret2win-Funktion aufgerufen wird.
- Die Binärdatei hat einen Überlauf, der ausgenutzt werden kann, um die Größe des oberen Chunks zu ändern, die auf -1 oder p64(0xffffffffffffffff) geändert wird.
- Dann wird die Adresse zu dem Ort berechnet, an dem der Zeiger zum Überschreiben existiert, und die Differenz von der aktuellen Position des oberen Chunks dorthin wird mit `malloc` zugewiesen.
- Schließlich wird ein neuer Chunk zugewiesen, der dieses gewünschte Ziel enthält, das durch die ret2win-Funktion überschrieben wird.
- [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp)
- Im `Input your name:` gibt es eine anfängliche Schwachstelle, die es ermöglicht, eine Adresse aus dem Heap auszulesen.
- Dann ist es in der `Org:` und `Host:` Funktionalität möglich, die 64B des `s` Zeigers auszufüllen, wenn nach dem **org name** gefragt wird, der im Stack von der Adresse von v2 gefolgt wird, die dann von dem angegebenen **host name** gefolgt wird. Da strcpy dann den Inhalt von s in einen Chunk der Größe 64B kopiert, ist es möglich, **die Größe des oberen Chunks zu überschreiben** mit den Daten, die im **host name** eingegeben wurden.
- Jetzt, da ein beliebiges Schreiben möglich ist, wurde die GOT von `atoi` auf die Adresse von printf überschrieben. Es war dann möglich, die Adresse von `IO_2_1_stderr` _mit_ `%24$p` auszulesen. Und mit diesem libc-Leak war es möglich, die GOT von `atoi` erneut mit der Adresse von `system` zu überschreiben und sie mit `/bin/sh` aufzurufen.
- Eine alternative Methode [vorgeschlagen in diesem anderen Bericht](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#2016-bctf-bcloud) besteht darin, `free` mit `puts` zu überschreiben und dann die Adresse von `atoi@got` in den Zeiger einzufügen, der später freigegeben wird, sodass er ausgelesen wird, und mit diesem Leak erneut `atoi@got` mit `system` zu überschreiben und es mit `/bin/sh` aufzurufen.
- [https://guyinatuxedo.github.io/41-house_of_force/bkp16_cookbook/index.html](https://guyinatuxedo.github.io/41-house_of_force/bkp16_cookbook/index.html)
- Es gibt ein UAF, das es ermöglicht, einen Chunk, der freigegeben wurde, ohne den Zeiger zu löschen, wiederzuverwenden. Da es einige Lese-Methoden gibt, ist es möglich, eine libc-Adresse auszulesen, indem man einen Zeiger auf die Freifunktion in der GOT hier schreibt und dann die Lese-Funktion aufruft.
- Dann wurde House of Force verwendet (Missbrauch des UAF), um die Größe des verbleibenden Raums mit -1 zu überschreiben, einen Chunk groß genug zuzuweisen, um zum Free-Hook zu gelangen, und dann einen weiteren Chunk zuzuweisen, der den Free-Hook enthalten wird. Dann wird in den Hook die Adresse von `system` geschrieben, in einen Chunk `"/bin/sh"` geschrieben und schließlich der Chunk mit diesem String-Inhalt freigegeben.

{{#include ../../banners/hacktricks-training.md}}
