# House of Force

{{#include ../../banners/hacktricks-training.md}}

## Informazioni di Base

### Codice

- Questa tecnica è stata corretta ([**qui**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c)) e produce questo errore: `malloc(): corrupted top size`
- Puoi provare il [**codice da qui**](https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html) per testarlo se vuoi.

### Obiettivo

- L'obiettivo di questo attacco è essere in grado di allocare un chunk in un indirizzo specifico.

### Requisiti

- Un overflow che consenta di sovrascrivere la dimensione dell'intestazione del top chunk (ad es. -1).
- Essere in grado di controllare la dimensione dell'allocazione della heap.

### Attacco

Se un attaccante vuole allocare un chunk nell'indirizzo P per sovrascrivere un valore qui. Inizia sovrascrivendo la dimensione del top chunk con `-1` (forse con un overflow). Questo assicura che malloc non utilizzerà mmap per alcuna allocazione poiché il Top chunk avrà sempre abbastanza spazio.

Poi, calcola la distanza tra l'indirizzo del top chunk e lo spazio target da allocare. Questo perché verrà eseguita una malloc con quella dimensione per spostare il top chunk in quella posizione. Questo è come la differenza/dimensione può essere facilmente calcolata:
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
Pertanto, allocare una dimensione di `target - old_top - 4*sizeof(long)` (i 4 long sono dovuti ai metadati del top chunk e del nuovo chunk quando allocato) sposterà il top chunk all'indirizzo che vogliamo sovrascrivere.\
Poi, eseguire un altro malloc per ottenere un chunk all'indirizzo target.

### Riferimenti e Altri Esempi

- [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/)
- [https://heap-exploitation.dhavalkapil.com/attacks/house_of_force](https://heap-exploitation.dhavalkapil.com/attacks/house_of_force)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c)
- [https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html](https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#hitcon-training-lab-11)
- L'obiettivo di questo scenario è un ret2win dove dobbiamo modificare l'indirizzo di una funzione che verrà chiamata dall'indirizzo della funzione ret2win
- Il binario ha un overflow che può essere sfruttato per modificare la dimensione del top chunk, che viene modificata a -1 o p64(0xffffffffffffffff)
- Poi, viene calcolato l'indirizzo del luogo in cui esiste il puntatore da sovrascrivere, e la differenza dalla posizione attuale del top chunk a lì viene allocata con `malloc`
- Infine, viene allocato un nuovo chunk che conterrà questo target desiderato all'interno del quale viene sovrascritto dalla funzione ret2win
- [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x_tr_sl=es&\_x_tr_tl=en&\_x_tr_hl=en&\_x_tr_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp)
- Nel `Input your name:` c'è una vulnerabilità iniziale che consente di rivelare un indirizzo dalla heap
- Poi nella funzionalità `Org:` e `Host:` è possibile riempire i 64B del puntatore `s` quando viene chiesto il **nome dell'organizzazione**, che nello stack è seguito dall'indirizzo di v2, che è poi seguito dal **nome host** indicato. Poiché strcpy copierà i contenuti di s in un chunk di dimensione 64B, è possibile **sovrascrivere la dimensione del top chunk** con i dati inseriti nel **nome host**.
- Ora che la scrittura arbitraria è possibile, il GOT di `atoi` è stato sovrascritto con l'indirizzo di printf. È stato quindi possibile rivelare l'indirizzo di `IO_2_1_stderr` _con_ `%24$p`. E con questa leak di libc è stato possibile sovrascrivere di nuovo il GOT di `atoi` con l'indirizzo di `system` e chiamarlo passando come parametro `/bin/sh`
- Un metodo alternativo [proposto in questo altro writeup](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#2016-bctf-bcloud) è sovrascrivere `free` con `puts`, e poi aggiungere l'indirizzo di `atoi@got`, nel puntatore che sarà poi liberato in modo che venga rivelato e con questa leak sovrascrivere di nuovo `atoi@got` con `system` e chiamarlo con `/bin/sh`.
- [https://guyinatuxedo.github.io/41-house_of_force/bkp16_cookbook/index.html](https://guyinatuxedo.github.io/41-house_of_force/bkp16_cookbook/index.html)
- C'è un UAF che consente di riutilizzare un chunk che è stato liberato senza cancellare il puntatore. Poiché ci sono alcuni metodi di lettura, è possibile rivelare un indirizzo libc scrivendo un puntatore alla funzione free nel GOT qui e poi chiamando la funzione di lettura.
- Poi, House of force è stato utilizzato (sfruttando l'UAF) per sovrascrivere la dimensione dello spazio rimanente con un -1, allocare un chunk abbastanza grande per arrivare al free hook, e poi allocare un altro chunk che conterrà il free hook. Poi, scrivere nel hook l'indirizzo di `system`, scrivere in un chunk `"/bin/sh"` e infine liberare il chunk con quel contenuto di stringa.

{{#include ../../banners/hacktricks-training.md}}
