# House of Force

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

### Kode

- Hierdie tegniek is reggestel ([**hier**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c)) en produseer hierdie fout: `malloc(): corrupted top size`
- Jy kan die [**kode van hier**](https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html) probeer om dit te toets as jy wil.

### Doel

- Die doel van hierdie aanval is om 'n stuk in 'n spesifieke adres te kan toewys.

### Vereistes

- 'n Oorloop wat toelaat om die grootte van die top stuk kop te oorskry (bv. -1).
- In staat wees om die grootte van die heap toewysing te beheer.

### Aanval

As 'n aanvaller 'n stuk in die adres P wil toewys om 'n waarde hier te oorskry. Hy begin deur die top stuk grootte met `-1` te oorskry (miskien met 'n oorloop). Dit verseker dat malloc nie mmap vir enige toewysing sal gebruik nie, aangesien die Top stuk altyd genoeg ruimte sal hê.

Bereken dan die afstand tussen die adres van die top stuk en die teikenruimte om toe te wys. Dit is omdat 'n malloc met daardie grootte uitgevoer sal word om die top stuk na daardie posisie te skuif. Dit is hoe die verskil/grootte maklik bereken kan word:
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
Daarom, om 'n grootte van `target - old_top - 4*sizeof(long)` toe te ken (die 4 longs is weens die metadata van die top chunk en van die nuwe chunk wanneer dit toegeken word) sal die top chunk na die adres beweeg wat ons wil oorskryf.\
Doen dan nog 'n malloc om 'n chunk by die teikenadres te kry.

### Verwysings & Ander Voorbeelde

- [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/)
- [https://heap-exploitation.dhavalkapil.com/attacks/house_of_force](https://heap-exploitation.dhavalkapil.com/attacks/house_of_force)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c)
- [https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html](https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#hitcon-training-lab-11)
- Die doel van hierdie scenario is 'n ret2win waar ons die adres van 'n funksie moet verander wat deur die adres van die ret2win funksie aangeroep gaan word
- Die binêre het 'n oorgang wat misbruik kan word om die top chunk grootte te verander, wat verander word na -1 of p64(0xffffffffffffffff)
- Dan word die adres na die plek waar die pointer om oorgeskryf te word bestaan, bereken, en die verskil van die huidige posisie van die top chunk daarheen word met `malloc` toegeken
- Laastens word 'n nuwe chunk toegeken wat hierdie gewenste teiken binne sal bevat wat deur die ret2win funksie oorgeskryf word
- [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x_tr_sl=es&\_x_tr_tl=en&\_x_tr_hl=en&\_x_tr_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp)
- In die `Input your name:` is daar 'n aanvanklike kwesbaarheid wat toelaat om 'n adres van die heap te lek
- Dan in die `Org:` en `Host:` funksionaliteit is dit moontlik om die 64B van die `s` pointer te vul wanneer gevra word vir die **org naam**, wat in die stapel gevolg word deur die adres van v2, wat dan gevolg word deur die aangeduide **host naam**. Aangesien strcpy die inhoud van s na 'n chunk van grootte 64B gaan kopieer, is dit moontlik om **die grootte van die top chunk te oorskryf** met die data wat binne die **host naam** geplaas is.
- Nou dat arbitrêre skrywe moontlik is, is die `atoi`'s GOT oorgeskryf na die adres van printf. Dit was moontlik om die adres van `IO_2_1_stderr` _met_ `%24$p` te lek. En met hierdie libc lek was dit moontlik om `atoi`'s GOT weer te oorskryf met die adres na `system` en dit aan te roep met die parameter `/bin/sh`
- 'n Alternatiewe metode [voorstel in hierdie ander skrywe](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#2016-bctf-bcloud), is om `free` met `puts` te oorskryf, en dan die adres van `atoi@got` by te voeg, in die pointer wat later vrygestel sal word sodat dit gelek word en met hierdie lek weer `atoi@got` met `system` oorskryf en dit aanroep met `/bin/sh`.
- [https://guyinatuxedo.github.io/41-house_of_force/bkp16_cookbook/index.html](https://guyinatuxedo.github.io/41-house_of_force/bkp16_cookbook/index.html)
- Daar is 'n UAF wat toelaat om 'n chunk wat vrygestel is te hergebruik sonder om die pointer te skoon te maak. Omdat daar 'n paar leesmetodes is, is dit moontlik om 'n libc adres te lek deur 'n pointer na die vry funksie in die GOT hier te skryf en dan die lees funksie aan te roep.
- Dan is House of force gebruik (misbruik van die UAF) om die grootte van die oorblywende ruimte met 'n -1 oorgeskryf, 'n chunk groot genoeg toe te ken om by die vry haak te kom, en dan 'n ander chunk toe te ken wat die vry haak sal bevat. Skryf dan in die haak die adres van `system`, skryf in 'n chunk `"/bin/sh"` en vry die chunk met daardie stringinhoud.

{{#include ../../banners/hacktricks-training.md}}
