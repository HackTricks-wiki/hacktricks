# House of Force

{{#include ../../banners/hacktricks-training.md}}

## Podstawowe informacje

### Kod

- Ta technika została załatana ([**tutaj**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c)) i generuje ten błąd: `malloc(): corrupted top size`
- Możesz spróbować [**kodu stąd**](https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html), aby go przetestować, jeśli chcesz.

### Cel

- Celem tego ataku jest możliwość przydzielenia kawałka pamięci pod konkretnym adresem.

### Wymagania

- Przepełnienie, które pozwala na nadpisanie rozmiaru nagłówka górnego kawałka (np. -1).
- Możliwość kontrolowania rozmiaru przydzielania pamięci na stercie.

### Atak

Jeśli atakujący chce przydzielić kawałek pamięci pod adresem P, aby nadpisać wartość tutaj. Zaczyna od nadpisania rozmiaru górnego kawałka `-1` (może za pomocą przepełnienia). To zapewnia, że malloc nie będzie używał mmap do żadnego przydzielania, ponieważ górny kawałek zawsze będzie miał wystarczająco dużo miejsca.

Następnie oblicza odległość między adresem górnego kawałka a docelową przestrzenią do przydzielenia. Dzieje się tak, ponieważ malloc z tym rozmiarem zostanie wykonany w celu przeniesienia górnego kawałka na tę pozycję. W ten sposób różnica/rozmiar może być łatwo obliczona:
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
Zatem, przydzielenie rozmiaru `target - old_top - 4*sizeof(long)` (4 longi są potrzebne z powodu metadanych górnego kawałka i nowego kawałka podczas przydzielania) przeniesie górny kawałek do adresu, który chcemy nadpisać.\
Następnie, wykonaj kolejny malloc, aby uzyskać kawałek pod docelowym adresem.

### References & Other Examples

- [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/)
- [https://heap-exploitation.dhavalkapil.com/attacks/house_of_force](https://heap-exploitation.dhavalkapil.com/attacks/house_of_force)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c)
- [https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html](https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#hitcon-training-lab-11)
- Celem tego scenariusza jest ret2win, w którym musimy zmodyfikować adres funkcji, która ma być wywołana przez adres funkcji ret2win
- Program binarny ma przepełnienie, które można wykorzystać do modyfikacji rozmiaru górnego kawałka, który jest zmieniany na -1 lub p64(0xffffffffffffffff)
- Następnie oblicza się adres miejsca, w którym znajduje się wskaźnik do nadpisania, a różnica od bieżącej pozycji górnego kawałka do tego miejsca jest przydzielana za pomocą `malloc`
- Na koniec przydzielany jest nowy kawałek, który będzie zawierał ten pożądany cel, wewnątrz którego jest nadpisywany przez funkcję ret2win
- [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x_tr_sl=es&\_x_tr_tl=en&\_x_tr_hl=en&\_x_tr_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp)
- W `Input your name:` znajduje się początkowa luka, która pozwala na wyciek adresu z pamięci
- Następnie w funkcjonalności `Org:` i `Host:` możliwe jest wypełnienie 64B wskaźnika `s`, gdy zapytano o **nazwa organizacji**, która w stosie jest następnie śledzona przez adres v2, a następnie przez wskazaną **nazwę hosta**. Ponieważ następnie, strcpy będzie kopiować zawartość s do kawałka o rozmiarze 64B, możliwe jest **nadpisanie rozmiaru górnego kawałka** danymi umieszczonymi w **nazwie hosta**.
- Teraz, gdy możliwe jest dowolne zapisanie, GOT `atoi` został nadpisany adresem printf. Możliwe było wycieknięcie adresu `IO_2_1_stderr` _z_ `%24$p`. A z tym wyciekiem libc możliwe było ponowne nadpisanie GOT `atoi` adresem do `system` i wywołanie go, przekazując jako parametr `/bin/sh`
- Alternatywna metoda [proponowana w tym innym opisie](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#2016-bctf-bcloud) polega na nadpisaniu `free` z `puts`, a następnie dodaniu adresu `atoi@got` do wskaźnika, który później zostanie zwolniony, aby został wycieknięty, a z tym wyciekiem ponownie nadpisać `atoi@got` adresem `system` i wywołać go z `/bin/sh`.
- [https://guyinatuxedo.github.io/41-house_of_force/bkp16_cookbook/index.html](https://guyinatuxedo.github.io/41-house_of_force/bkp16_cookbook/index.html)
- Istnieje UAF, który pozwala na ponowne użycie kawałka, który został zwolniony bez wyczyszczenia wskaźnika. Ponieważ istnieją pewne metody odczytu, możliwe jest wycieknięcie adresu libc, zapisując wskaźnik do funkcji free w GOT tutaj, a następnie wywołując funkcję odczytu.
- Następnie, House of force został użyty (wykorzystując UAF) do nadpisania rozmiaru pozostałej przestrzeni na -1, przydzielenia kawałka wystarczająco dużego, aby dotrzeć do hooka free, a następnie przydzielenia kolejnego kawałka, który będzie zawierał hook free. Następnie, zapisz w hooku adres `system`, zapisz w kawałku `"/bin/sh"` i na koniec zwolnij kawałek z tą zawartością ciągu.

{{#include ../../banners/hacktricks-training.md}}
