# House of Force

{{#include ../../banners/hacktricks-training.md}}

## Informations de base

### Code

- Cette technique a été corrigée ([**ici**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c)) et produit cette erreur : `malloc(): corrupted top size`
- Vous pouvez essayer le [**code d'ici**](https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html) pour le tester si vous le souhaitez.

### Objectif

- L'objectif de cette attaque est de pouvoir allouer un chunk à une adresse spécifique.

### Exigences

- Un débordement qui permet d'écraser la taille de l'en-tête du chunk supérieur (par exemple -1).
- Être capable de contrôler la taille de l'allocation de la heap.

### Attaque

Si un attaquant veut allouer un chunk à l'adresse P pour écraser une valeur ici. Il commence par écraser la taille du chunk supérieur avec `-1` (peut-être avec un débordement). Cela garantit que malloc n'utilisera pas mmap pour toute allocation car le chunk supérieur aura toujours suffisamment d'espace.

Ensuite, calculez la distance entre l'adresse du chunk supérieur et l'espace cible à allouer. Cela est dû au fait qu'un malloc avec cette taille sera effectué afin de déplacer le chunk supérieur à cette position. Voici comment la différence/taille peut être facilement calculée :
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
Par conséquent, allouer une taille de `target - old_top - 4*sizeof(long)` (les 4 longs sont dus aux métadonnées du top chunk et du nouveau chunk lors de l'allocation) déplacera le top chunk à l'adresse que nous voulons écraser.\
Ensuite, effectuez un autre malloc pour obtenir un chunk à l'adresse cible.

### Références et autres exemples

- [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/)
- [https://heap-exploitation.dhavalkapil.com/attacks/house_of_force](https://heap-exploitation.dhavalkapil.com/attacks/house_of_force)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c)
- [https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html](https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#hitcon-training-lab-11)
- L'objectif de ce scénario est un ret2win où nous devons modifier l'adresse d'une fonction qui va être appelée par l'adresse de la fonction ret2win.
- Le binaire a un débordement qui peut être exploité pour modifier la taille du top chunk, qui est modifiée à -1 ou p64(0xffffffffffffffff).
- Ensuite, l'adresse de l'endroit où le pointeur à écraser existe est calculée, et la différence entre la position actuelle du top chunk et cet endroit est allouée avec `malloc`.
- Enfin, un nouveau chunk est alloué qui contiendra cette cible désirée à l'intérieur, qui est écrasée par la fonction ret2win.
- [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x_tr_sl=es&\_x_tr_tl=en&\_x_tr_hl=en&\_x_tr_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp)
- Dans le `Input your name:`, il y a une vulnérabilité initiale qui permet de divulguer une adresse de la heap.
- Ensuite, dans la fonctionnalité `Org:` et `Host:`, il est possible de remplir les 64B du pointeur `s` lorsqu'on demande le **nom de l'organisation**, qui dans la pile est suivi par l'adresse de v2, qui est ensuite suivi par le **nom d'hôte** indiqué. Comme ensuite, strcpy va copier le contenu de s dans un chunk de taille 64B, il est possible de **écraser la taille du top chunk** avec les données mises à l'intérieur du **nom d'hôte**.
- Maintenant que l'écriture arbitraire est possible, le GOT de `atoi` a été écrasé à l'adresse de printf. Il a alors été possible de divulguer l'adresse de `IO_2_1_stderr` _avec_ `%24$p`. Et avec cette fuite libc, il a été possible d'écraser à nouveau le GOT de `atoi` avec l'adresse de `system` et de l'appeler en passant comme paramètre `/bin/sh`.
- Une méthode alternative [proposée dans cet autre article](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#2016-bctf-bcloud) consiste à écraser `free` avec `puts`, puis à ajouter l'adresse de `atoi@got`, dans le pointeur qui sera ensuite libéré afin qu'il soit divulgué et avec cette fuite écraser à nouveau `atoi@got` avec `system` et l'appeler avec `/bin/sh`.
- [https://guyinatuxedo.github.io/41-house_of_force/bkp16_cookbook/index.html](https://guyinatuxedo.github.io/41-house_of_force/bkp16_cookbook/index.html)
- Il y a un UAF permettant de réutiliser un chunk qui a été libéré sans effacer le pointeur. En raison de certaines méthodes de lecture, il est possible de divulguer une adresse libc en écrivant un pointeur vers la fonction free dans le GOT ici, puis en appelant la fonction de lecture.
- Ensuite, la House of force a été utilisée (abusant de l'UAF) pour écraser la taille de l'espace restant avec un -1, allouer un chunk suffisamment grand pour atteindre le free hook, puis allouer un autre chunk qui contiendra le free hook. Ensuite, écrire dans le hook l'adresse de `system`, écrire dans un chunk `"/bin/sh"` et enfin libérer le chunk avec ce contenu de chaîne.

{{#include ../../banners/hacktricks-training.md}}
