# House of Force

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

### Code

- यह तकनीक पैच की गई थी ([**यहाँ**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c)) और यह त्रुटि उत्पन्न करती है: `malloc(): corrupted top size`
- आप इसे परीक्षण करने के लिए [**कोड यहाँ से**](https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html) आजमा सकते हैं यदि आप चाहें।

### Goal

- इस हमले का लक्ष्य एक विशिष्ट पते पर एक चंक आवंटित करने में सक्षम होना है।

### Requirements

- एक ओवरफ्लो जो शीर्ष चंक हेडर के आकार को ओवरराइट करने की अनुमति देता है (जैसे -1)।
- हीप आवंटन के आकार को नियंत्रित करने में सक्षम होना

### Attack

यदि एक हमलावर P पते पर एक चंक आवंटित करना चाहता है ताकि यहाँ एक मान को ओवरराइट किया जा सके। वह शीर्ष चंक के आकार को `-1` से ओवरराइट करके शुरू करता है (शायद एक ओवरफ्लो के साथ)। यह सुनिश्चित करता है कि malloc किसी भी आवंटन के लिए mmap का उपयोग नहीं करेगा क्योंकि शीर्ष चंक के पास हमेशा पर्याप्त स्थान होगा।

फिर, शीर्ष चंक के पते और आवंटित करने के लिए लक्षित स्थान के बीच की दूरी की गणना करें। इसका कारण यह है कि उस आकार के साथ एक malloc किया जाएगा ताकि शीर्ष चंक को उस स्थिति में स्थानांतरित किया जा सके। इस प्रकार अंतर/आकार को आसानी से गणना किया जा सकता है:
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
इसलिए, `target - old_top - 4*sizeof(long)` का आकार आवंटित करना (4 longs शीर्ष टुकड़े और नए टुकड़े के मेटाडेटा के कारण है जब आवंटित किया जाता है) शीर्ष टुकड़े को उस पते पर ले जाएगा जिसे हम ओवरराइट करना चाहते हैं।\
फिर, लक्ष्य पते पर एक टुकड़ा प्राप्त करने के लिए एक और malloc करें।

### संदर्भ और अन्य उदाहरण

- [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/)
- [https://heap-exploitation.dhavalkapil.com/attacks/house_of_force](https://heap-exploitation.dhavalkapil.com/attacks/house_of_force)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c)
- [https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html](https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#hitcon-training-lab-11)
- इस परिदृश्य का लक्ष्य एक ret2win है जहां हमें उस फ़ंक्शन के पते को संशोधित करने की आवश्यकता है जिसे ret2win फ़ंक्शन के पते द्वारा कॉल किया जाएगा
- बाइनरी में एक ओवरफ्लो है जिसका दुरुपयोग शीर्ष टुकड़े के आकार को संशोधित करने के लिए किया जा सकता है, जिसे -1 या p64(0xffffffffffffffff) में संशोधित किया गया है
- फिर, उस स्थान के लिए पता निकाला जाता है जहां ओवरराइट करने के लिए पॉइंटर मौजूद है, और वहां से शीर्ष टुकड़े की वर्तमान स्थिति के बीच का अंतर `malloc` के साथ आवंटित किया जाता है
- अंततः एक नया टुकड़ा आवंटित किया जाता है जिसमें यह इच्छित लक्ष्य होता है जिसे ret2win फ़ंक्शन द्वारा ओवरराइट किया जाता है
- [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x_tr_sl=es&\_x_tr_tl=en&\_x_tr_hl=en&\_x_tr_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp)
- `Input your name:` में एक प्रारंभिक भेद्यता है जो हीप से एक पता लीक करने की अनुमति देती है
- फिर `Org:` और `Host:` कार्यक्षमता में, **org name** के लिए पूछे जाने पर `s` पॉइंटर के 64B को भरना संभव है, जो स्टैक में v2 के पते के बाद आता है, जो फिर निर्दिष्ट **host name** के बाद आता है। चूंकि, strcpy `s` की सामग्री को 64B के आकार के टुकड़े में कॉपी करने जा रहा है, इसलिए **host name** के अंदर रखे गए डेटा के साथ **top chunk के आकार को ओवरराइट करना** संभव है।
- अब जब मनमाना लेखन संभव है, `atoi` का GOT printf के पते पर ओवरराइट किया गया। इसके साथ `%24$p` के साथ `IO_2_1_stderr` का पता लीक करना संभव था। और इस libc लीक के साथ `atoi` के GOT को फिर से `system` के पते के साथ ओवरराइट करना और इसे `/bin/sh` पास करते हुए कॉल करना संभव था
- एक वैकल्पिक विधि [इस अन्य लेख में प्रस्तावित](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#2016-bctf-bcloud) है, `free` को `puts` के साथ ओवरराइट करना, और फिर उस पॉइंटर में `atoi@got` का पता जोड़ना जिसे बाद में मुक्त किया जाएगा ताकि यह लीक हो जाए और इस लीक के साथ फिर से `atoi@got` को `system` के साथ ओवरराइट किया जाए और इसे `/bin/sh` के साथ कॉल किया जाए।
- [https://guyinatuxedo.github.io/41-house_of_force/bkp16_cookbook/index.html](https://guyinatuxedo.github.io/41-house_of_force/bkp16_cookbook/index.html)
- एक UAF है जो बिना पॉइंटर को साफ किए एक टुकड़े का पुन: उपयोग करने की अनुमति देता है। कुछ पढ़ने की विधियों के कारण, यह संभव है कि एक libc पता लीक किया जाए, यहाँ free फ़ंक्शन के लिए एक पॉइंटर लिखकर और फिर पढ़ने की फ़ंक्शन को कॉल करके।
- फिर, House of force का उपयोग किया गया (UAF का दुरुपयोग करते हुए) बाएं स्थान के आकार को -1 के साथ ओवरराइट करने के लिए, एक ऐसा टुकड़ा आवंटित करने के लिए जो मुक्त हुक तक पहुँचने के लिए पर्याप्त बड़ा हो, और फिर एक और टुकड़ा आवंटित करें जिसमें मुक्त हुक होगा। फिर, हुक में `system` का पता लिखें, एक टुकड़े में `"/bin/sh"` लिखें और अंततः उस स्ट्रिंग सामग्री के साथ टुकड़े को मुक्त करें।

{{#include ../../banners/hacktricks-training.md}}
