# House of Force

{{#include ../../banners/hacktricks-training.md}}

## Informações Básicas

### Código

- Esta técnica foi corrigida ([**aqui**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c)) e produz este erro: `malloc(): corrupted top size`
- Você pode tentar o [**código daqui**](https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html) para testá-lo se quiser.

### Objetivo

- O objetivo deste ataque é conseguir alocar um chunk em um endereço específico.

### Requisitos

- Um overflow que permita sobrescrever o tamanho do cabeçalho do top chunk (por exemplo, -1).
- Ser capaz de controlar o tamanho da alocação do heap.

### Ataque

Se um atacante quiser alocar um chunk no endereço P para sobrescrever um valor aqui. Ele começa sobrescrevendo o tamanho do top chunk com `-1` (talvez com um overflow). Isso garante que malloc não usará mmap para nenhuma alocação, já que o Top chunk sempre terá espaço suficiente.

Em seguida, calcule a distância entre o endereço do top chunk e o espaço alvo para alocar. Isso ocorre porque uma malloc com esse tamanho será realizada para mover o top chunk para essa posição. É assim que a diferença/tamanho pode ser facilmente calculada:
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
Portanto, alocar um tamanho de `target - old_top - 4*sizeof(long)` (os 4 longs são devido aos metadados do chunk superior e do novo chunk quando alocado) moverá o chunk superior para o endereço que queremos sobrescrever.\
Em seguida, faça outro malloc para obter um chunk no endereço alvo.

### Referências e Outros Exemplos

- [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/)
- [https://heap-exploitation.dhavalkapil.com/attacks/house_of_force](https://heap-exploitation.dhavalkapil.com/attacks/house_of_force)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c)
- [https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html](https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#hitcon-training-lab-11)
- O objetivo deste cenário é um ret2win onde precisamos modificar o endereço de uma função que será chamada pelo endereço da função ret2win
- O binário tem um overflow que pode ser explorado para modificar o tamanho do chunk superior, que é modificado para -1 ou p64(0xffffffffffffffff)
- Em seguida, calcula-se o endereço do lugar onde o ponteiro a ser sobrescrito existe, e a diferença da posição atual do chunk superior até lá é alocada com `malloc`
- Finalmente, um novo chunk é alocado que conterá este alvo desejado dentro do qual é sobrescrito pela função ret2win
- [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x_tr_sl=es&\_x_tr_tl=en&\_x_tr_hl=en&\_x_tr_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp)
- No `Input your name:` há uma vulnerabilidade inicial que permite vazar um endereço da heap
- Então, na funcionalidade `Org:` e `Host:`, é possível preencher os 64B do ponteiro `s` quando solicitado pelo **nome da org**, que na pilha é seguido pelo endereço de v2, que é então seguido pelo **nome do host** indicado. Como então, strcpy vai copiar o conteúdo de s para um chunk de tamanho 64B, é possível **sobrescrever o tamanho do chunk superior** com os dados colocados dentro do **nome do host**.
- Agora que a escrita arbitrária é possível, o GOT de `atoi` foi sobrescrito para o endereço de printf. então foi possível vazar o endereço de `IO_2_1_stderr` _com_ `%24$p`. E com esse vazamento de libc foi possível sobrescrever novamente o GOT de `atoi` com o endereço de `system` e chamá-lo passando como parâmetro `/bin/sh`
- Um método alternativo [proposto neste outro relatório](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#2016-bctf-bcloud) é sobrescrever `free` com `puts`, e então adicionar o endereço de `atoi@got`, no ponteiro que será posteriormente liberado para que seja vazado e com esse vazamento sobrescrever novamente `atoi@got` com `system` e chamá-lo com `/bin/sh`.
- [https://guyinatuxedo.github.io/41-house_of_force/bkp16_cookbook/index.html](https://guyinatuxedo.github.io/41-house_of_force/bkp16_cookbook/index.html)
- Há um UAF permitindo reutilizar um chunk que foi liberado sem limpar o ponteiro. Como existem alguns métodos de leitura, é possível vazar um endereço da libc escrevendo um ponteiro para a função free no GOT aqui e então chamando a função de leitura.
- Em seguida, a House of force foi usada (abusando do UAF) para sobrescrever o tamanho do espaço restante com um -1, alocar um chunk grande o suficiente para chegar ao free hook, e então alocar outro chunk que conterá o free hook. Então, escreva no hook o endereço de `system`, escreva em um chunk `"/bin/sh"` e finalmente libere o chunk com esse conteúdo de string.

{{#include ../../banners/hacktricks-training.md}}
