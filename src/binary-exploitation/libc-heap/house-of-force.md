# House of Force

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

### Kod

- Bu teknik yamanmıştır ([**burada**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c)) ve bu hatayı üretir: `malloc(): corrupted top size`
- İsterseniz bunu test etmek için [**buradaki kodu**](https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html) deneyebilirsiniz.

### Amaç

- Bu saldırının amacı, belirli bir adreste bir parça ayırabilmektir.

### Gereksinimler

- Üst parça başlığının boyutunu (örneğin -1) yazmayı sağlayan bir taşma.
- Yığın tahsisi boyutunu kontrol edebilme

### Saldırı

Eğer bir saldırgan, burada bir değeri yazmak için P adresinde bir parça ayırmak istiyorsa, üst parça boyutunu `-1` ile (belki bir taşma ile) yazmaya başlar. Bu, malloc'un herhangi bir tahsis için mmap kullanmayacağından emin olur çünkü Üst parça her zaman yeterli alana sahip olacaktır.

Sonra, üst parçanın adresi ile tahsis edilecek hedef alan arasındaki mesafeyi hesaplayın. Bunun nedeni, o boyutta bir malloc'un, üst parçayı o konuma taşımak için yapılacak olmasıdır. Farkın/boyutun nasıl kolayca hesaplanabileceği:
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
Bu nedenle, `target - old_top - 4*sizeof(long)` boyutunu ayırmak (4 long, üst parça ve yeni parça için meta veriler nedeniyle) üst parçayı üzerine yazmak istediğimiz adrese taşıyacaktır.\
Sonra, hedef adreste bir parça almak için başka bir malloc yapın.

### Referanslar ve Diğer Örnekler

- [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/)
- [https://heap-exploitation.dhavalkapil.com/attacks/house_of_force](https://heap-exploitation.dhavalkapil.com/attacks/house_of_force)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c)
- [https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html](https://guyinatuxedo.github.io/41-house_of_force/house_force_exp/index.html)
- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#hitcon-training-lab-11)
- Bu senaryonun amacı, ret2win fonksiyonunun adresi tarafından çağrılacak bir fonksiyonun adresini değiştirmektir.
- İkili, üst parça boyutunu değiştirmek için istismar edilebilecek bir taşma içeriyor, bu da -1 veya p64(0xffffffffffffffff) olarak değiştirilir.
- Sonra, üzerine yazılacak işaretçinin bulunduğu yere olan adres hesaplanır ve üst parçanın mevcut konumundan oraya olan fark `malloc` ile ayrılır.
- Son olarak, bu istenen hedefi içerecek yeni bir parça ayrılır ve bu, ret2win fonksiyonu tarafından üzerine yazılır.
- [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp)
- `Input your name:` kısmında, heap'ten bir adres sızdırmaya izin veren bir başlangıç zafiyeti vardır.
- Sonra `Org:` ve `Host:` işlevselliğinde, **org adı** istendiğinde `s` işaretçisinin 64B'sini doldurmak mümkündür; bu, yığında v2'nin adresiyle takip edilir ve ardından belirtilen **host adı** gelir. Bu nedenle, strcpy `s`'nin içeriğini 64B boyutundaki bir parçaya kopyalayacağından, **üst parçanın boyutunu** **host adı** içindeki verilerle **üzerine yazmak** mümkündür.
- Artık keyfi yazma mümkün olduğuna göre, `atoi`'nin GOT'u printf'in adresi ile üzerine yazıldı. Bu, `%24$p` ile `IO_2_1_stderr` adresini sızdırmak için mümkündü. Ve bu libc sızıntısıyla, `atoi`'nin GOT'unu tekrar `system` adresi ile üzerine yazmak ve parametre olarak `/bin/sh` geçmek mümkündü.
- [Bu diğer yazıda önerilen alternatif bir yöntem](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_force/#2016-bctf-bcloud), `free`'yi `puts` ile üzerine yazmak ve ardından daha sonra serbest bırakılacak işaretçiye `atoi@got` adresini eklemektir, böylece sızdırılır ve bu sızıntıyla tekrar `atoi@got`'u `system` ile üzerine yazmak ve `/bin/sh` ile çağırmaktır.
- [https://guyinatuxedo.github.io/41-house_of_force/bkp16_cookbook/index.html](https://guyinatuxedo.github.io/41-house_of_force/bkp16_cookbook/index.html)
- Temizlenmeden serbest bırakılan bir parçayı yeniden kullanmaya izin veren bir UAF vardır. Bazı okuma yöntemleri nedeniyle, burada GOT'taki serbest fonksiyonuna bir işaretçi yazarak bir libc adresini sızdırmak mümkündür ve ardından okuma fonksiyonu çağrılır.
- Sonra, UAF'yi istismar ederek üst alanın boyutunu -1 ile üzerine yazmak, serbest kancaya ulaşacak kadar büyük bir parça ayırmak ve ardından serbest kancayı içerecek başka bir parça ayırmak için House of force kullanıldı. Ardından, kancaya `system` adresini yazın, bir parçaya `"/bin/sh"` yazın ve son olarak bu dize içeriğiyle parçayı serbest bırakın.

{{#include ../../banners/hacktricks-training.md}}
