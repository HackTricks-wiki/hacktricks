# GNU obstack function-pointer hijack

{{#include ../../banners/hacktricks-training.md}}

## 개요

GNU obstacks는 할당자 상태를 두 개의 간접 호출 대상과 함께 포함합니다:

- `chunkfun` (offset `+0x38`) with signature `void *(*chunkfun)(void *, size_t)`
- `freefun` (offset `+0x40`) with signature `void (*freefun)(void *, void *)`
- `extra_arg`와 `use_extra_arg` 플래그는 `_obstack_newchunk`가 `chunkfun(new_size)` 또는 `chunkfun(extra_arg, new_size)` 중 어떤 형태로 호출될지 선택합니다

공격자가 애플리케이션 소유의 `struct obstack *` 또는 그 필드를 손상시킬 수 있다면, obstack이 다음 번 확장될 때(`next_free == chunk_limit`), `chunkfun`을 통한 간접 호출이 발생하여 코드 실행 프리미티브를 가능하게 합니다.

## Primitive: size_t 불일치 → 0-바이트 할당 → 포인터 OOB 쓰기

일반적인 버그 패턴은 **32-bit register**를 사용해 `sizeof(ptr) * count`를 계산하는 반면 논리적 길이는 64-bit `size_t`에 저장하는 것입니다.

- Example: `elements = obstack_alloc(obs, sizeof(void *) * size);` is compiled as `SHL EAX,0x3` for `size << 3`.
- `size = 0x20000000` 및 `sizeof(void *) = 8` 일 때, 32-bit에서 곱셈이 `0x0`으로 래핑되어 포인터 배열이 **0 바이트**가 되지만, 기록된 `size`는 여전히 `0x20000000`입니다.
- 이후 `elements[curr++] = ptr;` 쓰기는 인접한 힙 객체들에 **8-바이트 OOB 포인터 저장**을 수행하여 제어 가능한 객체 간 덮어쓰기 프리미티브를 제공합니다.

## Leaking libc via `obstack.chunkfun`

1. 두 힙 객체를 인접하게 배치합니다(예: 별개의 obstacks로 구성된 두 스택).
2. 객체 A의 포인터 배열 OOB 쓰기를 사용해 객체 B의 `elements` 포인터를 덮어써서, B에서의 `pop`/read가 객체 A의 obstack 내부 주소를 역참조하도록 만듭니다.
3. 오프셋 `0x38`에서 `chunkfun`(`malloc`이 기본값)을 읽어 libc 함수 포인터를 노출시키고, 그 다음 `libc_base = leak - malloc_offset`을 계산하여 다른 심볼(예: `system`, `"/bin/sh"`)을 유도합니다.

## Hijacking `chunkfun` with a fake obstack

피해자의 저장된 `struct obstack *`을 덮어써서 obstack 헤더를 흉내낸 공격자가 제어하는 데이터로 가리키게 만듭니다. 최소한 필요한 필드:

- `next_free == chunk_limit` — 다음 push에서 `_obstack_newchunk`를 강제하기 위해
- `chunkfun = system_addr`
- `extra_arg = binsh_addr`, `use_extra_arg = 1` — 두-인자 호출 형태 선택

그런 다음 피해자 obstack에서 할당을 트리거하여 간접 호출을 통해 `system("/bin/sh")`을 실행합니다.

Example fake obstack layout (glibc 2.42 offsets):
```python
fake  = b""
fake += p64(0x1000)          # chunk_size
fake += p64(heap_leak)       # chunk
fake += p64(heap_leak)       # object_base
fake += p64(heap_leak)       # next_free == chunk_limit
fake += p64(heap_leak)       # chunk_limit
fake += p64(0xF)             # alignment_mask
fake += p64(0)               # temp
fake += p64(system_addr)     # chunkfun
fake += p64(0)               # freefun
fake += p64(binsh_addr)      # extra_arg
fake += p64(1)               # use_extra_arg flag set
```
## 공격 절차

1. **Trigger size wrap**로 거대한 논리적 길이를 가진 0-byte pointer array를 생성합니다.
2. **Groom adjacency**하여 OOB pointer store가 obstack pointer를 포함하는 인접 객체에 도달하도록 조작합니다.
3. **Leak libc** — victim pointer를 neighbor obstack의 `chunkfun`으로 리다이렉트하고 function pointer를 읽습니다.
4. **Forge obstack** 데이터에 제어된 `chunkfun`/`extra_arg`를 넣고 `_obstack_newchunk`가 위조된 헤더에 오도록 강제하여 공격자가 선택한 function-pointer 호출을 발생시킵니다.

## References

- [Flagvent 2025 FV25.08 obstack exploit (0xdf)](https://0xdf.gitlab.io/flagvent2025/hard)

{{#include ../../banners/hacktricks-training.md}}
