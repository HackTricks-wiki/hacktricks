# GNU obstack function-pointer hijack

{{#include ../../banners/hacktricks-training.md}}

## Überblick

GNU obstacks betten den Allocator-Zustand zusammen mit zwei indirekten Aufrufzielen ein:

- `chunkfun` (offset `+0x38`) with signature `void *(*chunkfun)(void *, size_t)`
- `freefun` (offset `+0x40`) with signature `void (*freefun)(void *, void *)`
- `extra_arg` and a `use_extra_arg` flag select whether `_obstack_newchunk` calls `chunkfun(new_size)` or `chunkfun(extra_arg, new_size)`

Wenn ein Angreifer ein an die Anwendung gehörendes `struct obstack *` oder dessen Felder korrumpieren kann, löst das nächste Wachsen des obstack (wenn `next_free == chunk_limit`) einen indirekten Aufruf über `chunkfun` aus und ermöglicht Primitiven zur Codeausführung.

## Primitive: size_t desync → 0-byte allocation → pointer OOB write

Ein häufiges Bug-Muster ist die Verwendung eines **32-bit Registers** zur Berechnung von `sizeof(ptr) * count`, während die logische Länge in einem 64-bit `size_t` gespeichert wird.

- Beispiel: `elements = obstack_alloc(obs, sizeof(void *) * size);` is compiled as `SHL EAX,0x3` for `size << 3`.
- Bei `size = 0x20000000` und `sizeof(void *) = 8` überläuft die Multiplikation in 32-bit auf `0x0`, sodass das Pointer-Array **0 bytes** groß ist, aber das aufgezeichnete `size` weiterhin `0x20000000` bleibt.
- Anschließende `elements[curr++] = ptr;`-Schreibvorgänge führen zu **8-byte OOB pointer stores** in benachbarte Heap-Objekte und liefern ein kontrolliertes cross-object overwrite-Primitive.

## Leaking libc via `obstack.chunkfun`

1. Platziere zwei Heap-Objekte nebeneinander (z. B. zwei Stacks, die mit separaten obstacks gebaut wurden).
2. Nutze den pointer-array OOB write aus Objekt A, um den `elements`-Pointer von Objekt B so zu überschreiben, dass ein `pop`/Lesezugriff von B eine Adresse innerhalb von Objekt A's obstack dereferenziert.
3. Lese `chunkfun` (`malloc` by default) bei Offset `0x38`, um einen libc-Funktionspointer offenzulegen, berechne dann `libc_base = leak - malloc_offset` und leite andere Symbole ab (z. B. `system`, `"/bin/sh"`).

## Hijacking `chunkfun` with a fake obstack

Überschreibe das gespeicherte `struct obstack *` des Opfers so, dass es auf angreiferkontrollierte Daten zeigt, die den obstack-Header nachahmen. Minimal benötigte Felder:

- `next_free == chunk_limit` to force `_obstack_newchunk` on next push
- `chunkfun = system_addr`
- `extra_arg = binsh_addr`, `use_extra_arg = 1` to select the two-argument call form

Dann löse eine Allokation auf dem Opfer-obstack aus, um `system("/bin/sh")` über den indirekten Aufruf auszuführen.

Beispiel für ein gefälschtes obstack-Layout (glibc 2.42 offsets):
```python
fake  = b""
fake += p64(0x1000)          # chunk_size
fake += p64(heap_leak)       # chunk
fake += p64(heap_leak)       # object_base
fake += p64(heap_leak)       # next_free == chunk_limit
fake += p64(heap_leak)       # chunk_limit
fake += p64(0xF)             # alignment_mask
fake += p64(0)               # temp
fake += p64(system_addr)     # chunkfun
fake += p64(0)               # freefun
fake += p64(binsh_addr)      # extra_arg
fake += p64(1)               # use_extra_arg flag set
```
## Angriffsrezept

1. **Trigger size wrap** um ein 0-byte pointer array mit sehr großer logischer Länge zu erstellen.
2. **Groom adjacency** sodass ein OOB pointer store ein benachbartes Objekt erreicht, das einen obstack-Pointer enthält.
3. **Leak libc** indem ein victim-Pointer auf das benachbarte obstack’s `chunkfun` umgeleitet und der Function-Pointer ausgelesen wird.
4. **Forge obstack** Daten mit kontrolliertem `chunkfun`/`extra_arg` fälschen und `_obstack_newchunk` dazu zwingen, im gefälschten Header zu landen, wodurch ein Funktionszeigeraufruf nach Wahl des Angreifers ausgelöst wird.

## Referenzen

- [Flagvent 2025 FV25.08 obstack exploit (0xdf)](https://0xdf.gitlab.io/flagvent2025/hard)

{{#include ../../banners/hacktricks-training.md}}
