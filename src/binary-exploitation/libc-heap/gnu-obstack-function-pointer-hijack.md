# GNU obstack function-pointer hijack

{{#include ../../banners/hacktricks-training.md}}

## Aperçu

GNU obstacks embarquent l'état de l'allocateur ainsi que deux cibles d'appel indirect :

- `chunkfun` (offset `+0x38`) with signature `void *(*chunkfun)(void *, size_t)`
- `freefun` (offset `+0x40`) with signature `void (*freefun)(void *, void *)`
- `extra_arg` and a `use_extra_arg` flag select whether `_obstack_newchunk` calls `chunkfun(new_size)` or `chunkfun(extra_arg, new_size)`

Si un attaquant peut corrompre un `struct obstack *` appartenant à l'application ou ses champs, la prochaine croissance de l'obstack (lorsque `next_free == chunk_limit`) déclenche un appel indirect via `chunkfun`, permettant des primitives d'exécution de code.

## Primitive : size_t desync → allocation de 0 octet → écriture OOB de pointeur

Un motif de bug courant est d'utiliser un **registre 32 bits** pour calculer `sizeof(ptr) * count` tout en stockant la longueur logique dans un `size_t` 64 bits.

- Exemple : `elements = obstack_alloc(obs, sizeof(void *) * size);` is compiled as `SHL EAX,0x3` for `size << 3`.
- Avec `size = 0x20000000` et `sizeof(void *) = 8`, la multiplication déborde à `0x0` en 32 bits, donc le tableau de pointeurs fait **0 octets**, mais le `size` enregistré reste `0x20000000`.
- Les écritures suivantes `elements[curr++] = ptr;` effectuent des stockages de pointeur **OOB de 8 octets** dans des objets heap adjacents, fournissant une primitive d'écrasement contrôlé inter-objets.

## Leaking libc via `obstack.chunkfun`

1. Placez deux objets heap adjacents (par ex., deux stacks construits avec des obstacks séparés).
2. Utilisez l'écriture OOB du tableau de pointeurs de l'objet A pour écraser le pointeur `elements` de l'objet B de sorte qu'un `pop`/read depuis B déréférence une adresse à l'intérieur de l'obstack de A.
3. Lisez `chunkfun` (`malloc` par défaut) à l'offset `0x38` pour révéler un pointeur de fonction libc, puis calculez `libc_base = leak - malloc_offset` et déduisez d'autres symboles (par ex., `system`, `"/bin/sh"`).

## Hijacking `chunkfun` with a fake obstack

Écrasez le `struct obstack *` stocké de la victime pour qu'il pointe vers des données contrôlées par l'attaquant qui imitent l'en-tête de l'obstack. Champs minimaux nécessaires :

- `next_free == chunk_limit` pour forcer `_obstack_newchunk` au prochain push
- `chunkfun = system_addr`
- `extra_arg = binsh_addr`, `use_extra_arg = 1` pour sélectionner la forme d'appel à deux arguments

Puis déclenchez une allocation sur l'obstack de la victime pour exécuter `system("/bin/sh")` via l'appel indirect.

Exemple de layout d'obstack factice (offsets glibc 2.42):
```python
fake  = b""
fake += p64(0x1000)          # chunk_size
fake += p64(heap_leak)       # chunk
fake += p64(heap_leak)       # object_base
fake += p64(heap_leak)       # next_free == chunk_limit
fake += p64(heap_leak)       # chunk_limit
fake += p64(0xF)             # alignment_mask
fake += p64(0)               # temp
fake += p64(system_addr)     # chunkfun
fake += p64(0)               # freefun
fake += p64(binsh_addr)      # extra_arg
fake += p64(1)               # use_extra_arg flag set
```
## Recette d'attaque

1. **Trigger size wrap** pour créer un 0-byte pointer array avec une énorme longueur logique.
2. **Groom adjacency** pour qu'un OOB pointer store atteigne un objet voisin contenant un obstack pointer.
3. **Leak libc** en redirigeant un victim pointer vers le `chunkfun` de l'obstack voisin et en lisant le function pointer.
4. **Forge obstack** des données avec `chunkfun`/`extra_arg` contrôlés et forcer `_obstack_newchunk` à atterrir dans l'en-tête falsifié, produisant un appel de function-pointer au choix de l'attaquant.

## Références

- [Flagvent 2025 FV25.08 obstack exploit (0xdf)](https://0xdf.gitlab.io/flagvent2025/hard)

{{#include ../../banners/hacktricks-training.md}}
