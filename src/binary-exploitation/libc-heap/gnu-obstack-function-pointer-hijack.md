# GNU obstack function-pointer hijack

{{#include ../../banners/hacktricks-training.md}}

## Overview

Τα GNU obstacks ενσωματώνουν την κατάσταση του allocator μαζί με δύο στόχους έμμεσης κλήσης:

- `chunkfun` (offset `+0x38`) με υπογραφή `void *(*chunkfun)(void *, size_t)`
- `freefun` (offset `+0x40`) με υπογραφή `void (*freefun)(void *, void *)`
- Το `extra_arg` και ένα flag `use_extra_arg` επιλέγουν αν το `_obstack_newchunk` καλεί `chunkfun(new_size)` ή `chunkfun(extra_arg, new_size)`

Εάν ένας επιτιθέμενος μπορεί να αλλοιώσει ένα `struct obstack *` που ανήκει στην εφαρμογή ή τα πεδία του, η επόμενη επέκταση του obstack (όταν `next_free == chunk_limit`) ενεργοποιεί μια έμμεση κλήση μέσω του `chunkfun`, επιτρέποντας primitives εκτέλεσης κώδικα.

## Primitive: size_t desync → 0-byte allocation → pointer OOB write

Ένα συνηθισμένο μοτίβο σφάλματος είναι η χρήση ενός **32-bit register** για τον υπολογισμό `sizeof(ptr) * count` ενώ το λογικό μήκος αποθηκεύεται σε 64-bit `size_t`.

- Παράδειγμα: `elements = obstack_alloc(obs, sizeof(void *) * size);` μεταγλωττίζεται ως `SHL EAX,0x3` για `size << 3`.
- Με `size = 0x20000000` και `sizeof(void *) = 8`, ο πολλαπλασιασμός περιτυλίγεται σε `0x0` σε 32-bit, οπότε ο πίνακας δεικτών είναι **0 bytes**, αλλά το καταγεγραμμένο `size` παραμένει `0x20000000`.
- Τα επακόλουθα `elements[curr++] = ptr;` εκτελούν **8-byte OOB pointer stores** σε γειτονικά heap objects, παρέχοντας primitive για ελεγχόμενο cross-object overwrite.

## Leaking libc via `obstack.chunkfun`

1. Τοποθετήστε δύο heap objects γείτονες (π.χ. δύο stacks φτιαγμένα με ξεχωριστά obstacks).
2. Χρησιμοποιήστε το pointer-array OOB write από το object A για να αντικαταστήσετε τον pointer `elements` του object B έτσι ώστε ένα `pop`/read από το B να κάνει dereference μια διεύθυνση μέσα στο obstack του A.
3. Διαβάστε το `chunkfun` (`malloc` by default) στο offset `0x38` για να αποκαλύψετε έναν δείκτη συνάρτησης της libc, στη συνέχεια υπολογίστε `libc_base = leak - malloc_offset` και εξαχθούν άλλα σύμβολα (π.χ. `system`, `"/bin/sh"`).

## Hijacking `chunkfun` with a fake obstack

Αντικαταστήστε το αποθηκευμένο `struct obstack *` του θύματος ώστε να δείχνει σε δεδομένα υπό έλεγχο του επιτιθέμενου που μιμούνται το header του obstack. Τα ελάχιστα απαιτούμενα πεδία:

- `next_free == chunk_limit` για να αναγκαστεί το `_obstack_newchunk` στην επόμενη push
- `chunkfun = system_addr`
- `extra_arg = binsh_addr`, `use_extra_arg = 1` για να επιλεγεί η μορφή κλήσης με δύο ορίσματα

Στη συνέχεια ενεργοποιήστε μια allocation στο obstack του θύματος για να εκτελέσετε `system("/bin/sh")` μέσω της έμμεσης κλήσης.

Example fake obstack layout (glibc 2.42 offsets):
```python
fake  = b""
fake += p64(0x1000)          # chunk_size
fake += p64(heap_leak)       # chunk
fake += p64(heap_leak)       # object_base
fake += p64(heap_leak)       # next_free == chunk_limit
fake += p64(heap_leak)       # chunk_limit
fake += p64(0xF)             # alignment_mask
fake += p64(0)               # temp
fake += p64(system_addr)     # chunkfun
fake += p64(0)               # freefun
fake += p64(binsh_addr)      # extra_arg
fake += p64(1)               # use_extra_arg flag set
```
## Συνταγή επίθεσης

1. **Trigger size wrap** για να δημιουργήσει έναν 0-byte pointer array με μεγάλο λογικό μήκος.
2. **Groom adjacency** ώστε ένα OOB pointer store να φτάσει σε ένα γειτονικό αντικείμενο που περιέχει obstack pointer.
3. **Leak libc** ανακατευθύνοντας έναν victim pointer στο `chunkfun` του γειτονικού obstack και διαβάζοντας τον function pointer.
4. **Forge obstack** δεδομένα με ελεγχόμενο `chunkfun`/`extra_arg` και εξαναγκάζοντας το `_obstack_newchunk` να προσγειωθεί στην πλαστή κεφαλίδα, αποφέροντας μια κλήση function-pointer της επιλογής του attacker.

## Αναφορές

- [Flagvent 2025 FV25.08 obstack exploit (0xdf)](https://0xdf.gitlab.io/flagvent2025/hard)

{{#include ../../banners/hacktricks-training.md}}
