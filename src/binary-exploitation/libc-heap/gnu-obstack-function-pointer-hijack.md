# GNU obstack function-pointer hijack

{{#include ../../banners/hacktricks-training.md}}

## Oorsig

GNU obstacks embed allocator state together with two indirect call targets:

- `chunkfun` (offset `+0x38`) with signature `void *(*chunkfun)(void *, size_t)`
- `freefun` (offset `+0x40`) with signature `void (*freefun)(void *, void *)`
- `extra_arg` and a `use_extra_arg` flag kies of `_obstack_newchunk` `chunkfun(new_size)` of `chunkfun(extra_arg, new_size)` aanroep

As 'n aanvaller 'n toepassing-beheerde `struct obstack *` of sy velde kan korrupteer, sal die volgende vergroting van die obstack (wanneer `next_free == chunk_limit`) 'n indirekte oproep deur `chunkfun` aktiveer, wat kode-uitvoeringsprimitiewe moontlik maak.

## Primitief: size_t desync → 0-byte allocation → pointer OOB write

'n Algemene foutpatroon is om 'n **32-bit register** te gebruik om `sizeof(ptr) * count` te bereken terwyl die logiese lengte in 'n 64-bit `size_t` gestoor word.

- Voorbeeld: `elements = obstack_alloc(obs, sizeof(void *) * size);` word saamgestel as `SHL EAX,0x3` vir `size << 3`.
- Met `size = 0x20000000` en `sizeof(void *) = 8`, die vermenigvuldiging rol oor na `0x0` in 32-bit, so die pointer-array is **0 bytes**, maar die geregistreerde `size` bly `0x20000000`.
- Daarna verrig `elements[curr++] = ptr;` skrywes **8-byte OOB pointer stores** in aangrensende heap-objekte, wat 'n beheerde cross-object overwrite-primitief gee.

## Leaking libc via `obstack.chunkfun`

1. Plaas twee heap-objekte langs mekaar (bv., twee stacks gebou met aparte obstacks).
2. Gebruik die pointer-array OOB write van objek A om objek B se `elements` pointer te oorskryf sodat 'n `pop`/lees vanaf B 'n adres binne objek A se obstack dereferensieer.
3. Lees `chunkfun` (`malloc` by default) by offset `0x38` om 'n libc-funksie-pointer te openbaar, bereken dan `libc_base = leak - malloc_offset` en herlei ander simbole (bv., `system`, `"/bin/sh"`).

## Hijacking `chunkfun` with a fake obstack

Oorskryf 'n slagoffer se gestoor `struct obstack *` om na aanvaller-beheerde data te wys wat die obstack-header naboots. Minima-velde benodig:

- `next_free == chunk_limit` om `_obstack_newchunk` op die volgende push te forceer
- `chunkfun = system_addr`
- `extra_arg = binsh_addr`, `use_extra_arg = 1` om die twee-argument vorm te kies

Aktiveer dan 'n toewysing op die slagoffer-obstack om `system("/bin/sh")` uit te voer via die indirekte oproep.

Example fake obstack layout (glibc 2.42 offsets):
```python
fake  = b""
fake += p64(0x1000)          # chunk_size
fake += p64(heap_leak)       # chunk
fake += p64(heap_leak)       # object_base
fake += p64(heap_leak)       # next_free == chunk_limit
fake += p64(heap_leak)       # chunk_limit
fake += p64(0xF)             # alignment_mask
fake += p64(0)               # temp
fake += p64(system_addr)     # chunkfun
fake += p64(0)               # freefun
fake += p64(binsh_addr)      # extra_arg
fake += p64(1)               # use_extra_arg flag set
```
## Aanvalresep

1. **Trigger size wrap** om 'n 0-byte pointer array te skep met 'n enorme logiese lengte.
2. **Groom adjacency** sodat 'n OOB pointer store 'n buurvoorwerp bereik wat 'n obstack pointer bevat.
3. **Leak libc** deur 'n victim pointer te herlei na die buur obstack se `chunkfun` en die function pointer te lees.
4. **Forge obstack** data met beheerde `chunkfun`/`extra_arg` en dwing `_obstack_newchunk` om in die vervalste header te beland, wat 'n function-pointer call van die attacker se keuse oplewer.

## Verwysings

- [Flagvent 2025 FV25.08 obstack exploit (0xdf)](https://0xdf.gitlab.io/flagvent2025/hard)

{{#include ../../banners/hacktricks-training.md}}
