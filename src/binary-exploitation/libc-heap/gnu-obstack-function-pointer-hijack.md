# GNU obstack function-pointer hijack

{{#include ../../banners/hacktricks-training.md}}

## Visión general

GNU obstacks almacenan el estado del allocator junto con dos objetivos de llamada indirecta:

- `chunkfun` (offset `+0x38`) con la firma `void *(*chunkfun)(void *, size_t)`
- `freefun` (offset `+0x40`) con la firma `void (*freefun)(void *, void *)`
- `extra_arg` y una bandera `use_extra_arg` seleccionan si `_obstack_newchunk` llama a `chunkfun(new_size)` o a `chunkfun(extra_arg, new_size)`

Si un atacante puede corromper un `struct obstack *` perteneciente a la aplicación o sus campos, el siguiente crecimiento del obstack (cuando `next_free == chunk_limit`) desencadena una llamada indirecta a través de `chunkfun`, permitiendo primitivas de ejecución de código.

## Primitive: size_t desync → 0-byte allocation → pointer OOB write

Un patrón de bug común es usar un **registro de 32 bits** para calcular `sizeof(ptr) * count` mientras se almacena la longitud lógica en un `size_t` de 64 bits.

- Ejemplo: `elements = obstack_alloc(obs, sizeof(void *) * size);` se compila como `SHL EAX,0x3` para `size << 3`.
- Con `size = 0x20000000` y `sizeof(void *) = 8`, la multiplicación desborda a `0x0` en 32 bits, por lo que el array de punteros tiene **0 bytes**, pero el `size` registrado permanece `0x20000000`.
- Las escrituras posteriores `elements[curr++] = ptr;` realizan almacenamientos de punteros **OOB de 8 bytes** en objetos heap adyacentes, proporcionando una primitiva de sobreescritura cruzada controlada.

## Leaking libc via `obstack.chunkfun`

1. Coloca dos objetos heap adyacentes (p. ej., dos stacks construidos con obstacks separados).
2. Usa el write OOB del array de punteros desde el objeto A para sobrescribir el puntero `elements` del objeto B de modo que un `pop`/read desde B desreferencie una dirección dentro del obstack del objeto A.
3. Lee `chunkfun` (`malloc` por defecto) en el offset `0x38` para divulgar un puntero a función de libc, luego calcula `libc_base = leak - malloc_offset` y deriva otros símbolos (p. ej., `system`, `"/bin/sh"`).

## Hijacking `chunkfun` with a fake obstack

Sobrescribe el `struct obstack *` almacenado de la víctima para apuntar a datos controlados por el atacante que imitan el header del obstack. Campos mínimos necesarios:

- `next_free == chunk_limit` para forzar `_obstack_newchunk` en el siguiente push
- `chunkfun = system_addr`
- `extra_arg = binsh_addr`, `use_extra_arg = 1` para seleccionar la forma de llamada con dos argumentos

Luego provoca una asignación en el obstack de la víctima para ejecutar `system("/bin/sh")` a través de la llamada indirecta.

Ejemplo fake obstack layout (glibc 2.42 offsets):
```python
fake  = b""
fake += p64(0x1000)          # chunk_size
fake += p64(heap_leak)       # chunk
fake += p64(heap_leak)       # object_base
fake += p64(heap_leak)       # next_free == chunk_limit
fake += p64(heap_leak)       # chunk_limit
fake += p64(0xF)             # alignment_mask
fake += p64(0)               # temp
fake += p64(system_addr)     # chunkfun
fake += p64(0)               # freefun
fake += p64(binsh_addr)      # extra_arg
fake += p64(1)               # use_extra_arg flag set
```
## Receta de ataque

1. **Trigger size wrap** para crear un 0-byte pointer array con una enorme longitud lógica.
2. **Groom adjacency** para que un OOB pointer store alcance un objeto vecino que contiene un obstack pointer.
3. **Leak libc** redireccionando un victim pointer al `chunkfun` del obstack vecino y leyendo el puntero a función.
4. **Forge obstack** datos con `chunkfun`/`extra_arg` controlados y forzar `_obstack_newchunk` para que aterrice en el encabezado forjado, produciendo una llamada por puntero a función a elección del atacante.

## Referencias

- [Flagvent 2025 FV25.08 obstack exploit (0xdf)](https://0xdf.gitlab.io/flagvent2025/hard)

{{#include ../../banners/hacktricks-training.md}}
