# GNU obstack function-pointer hijack

{{#include ../../banners/hacktricks-training.md}}

## Genel Bakış

GNU obstacks, allocator durumunu iki dolaylı çağrı hedefi ile birlikte gömer:

- `chunkfun` (offset `+0x38`) imzası `void *(*chunkfun)(void *, size_t)`
- `freefun` (offset `+0x40`) imzası `void (*freefun)(void *, void *)`
- `extra_arg` ve `use_extra_arg` bayrağı, `_obstack_newchunk`'in `chunkfun(new_size)` mi yoksa `chunkfun(extra_arg, new_size)` mı çağıracağını seçer

Bir saldırgan, uygulamaya ait bir `struct obstack *` veya onun alanlarını bozabilirse, obstack'in bir sonraki büyümesi (when `next_free == chunk_limit`) `chunkfun` üzerinden dolaylı bir çağrıyı tetikler ve kod yürütme primitifleri sağlar.

## Primitive: size_t desync → 0-byte allocation → pointer OOB write

Yaygın bir hata deseni, `sizeof(ptr) * count` hesaplamak için **32-bit register** kullanırken mantıksal uzunluğu 64-bit `size_t` içinde saklamaktır.

- Örnek: `elements = obstack_alloc(obs, sizeof(void *) * size);` derlenirken `size << 3` için `SHL EAX,0x3` olarak üretilir.
- `size = 0x20000000` ve `sizeof(void *) = 8` olduğunda, çarpma 32-bit içinde `0x0` olarak sarılır; böylece pointer dizisi **0 byte** olur, fakat kaydedilen `size` `0x20000000` olarak kalır.
- Takip eden `elements[curr++] = ptr;` yazımları, bitişik heap objelerine **8-bayt OOB pointer store**lar yapar ve kontrollü cross-object overwrite primitifini sağlar.

## Leaking libc via `obstack.chunkfun`

1. İki heap objesini bitişik yerleştir (ör. ayrı obstacks ile oluşturulmuş iki stack).
2. Obje A'dan yapılan pointer-array OOB write ile obje B'nin `elements` pointer'ını ezerek B'den yapılan bir `pop`/okuma işleminin obje A içindeki bir adresi dereference etmesini sağla.
3. `chunkfun`'u (varsayılan olarak `malloc`) offset `0x38`'de oku; böylece bir libc function pointer'ı disclose ederek `libc_base = leak - malloc_offset` hesaplaması yap ve diğer sembolleri (ör. `system`, `"/bin/sh"`) türet.

## Hijacking `chunkfun` with a fake obstack

Bir mağdurun saklanan `struct obstack *`'ını, obstack başlığını taklit eden saldırgan kontrollü verilere işaret edecek şekilde ez.

Gerekli asgari alanlar:

- Sonraki push'ta `_obstack_newchunk`'i zorlamak için `next_free == chunk_limit`
- `chunkfun = system_addr`
- İki argümanlı çağrı formunu seçmek için `extra_arg = binsh_addr`, `use_extra_arg = 1`

Sonra mağdur obstack üzerinde bir allocation tetikle ki dolaylı çağrı aracılığıyla `system("/bin/sh")` çalışsın.

Örnek sahte obstack düzeni (glibc 2.42 offsets):
```python
fake  = b""
fake += p64(0x1000)          # chunk_size
fake += p64(heap_leak)       # chunk
fake += p64(heap_leak)       # object_base
fake += p64(heap_leak)       # next_free == chunk_limit
fake += p64(heap_leak)       # chunk_limit
fake += p64(0xF)             # alignment_mask
fake += p64(0)               # temp
fake += p64(system_addr)     # chunkfun
fake += p64(0)               # freefun
fake += p64(binsh_addr)      # extra_arg
fake += p64(1)               # use_extra_arg flag set
```
## Saldırı tarifi

1. **Trigger size wrap** ile büyük bir mantıksal uzunluğa sahip 0-byte pointer array oluşturun.
2. **Groom adjacency** ile bir OOB pointer store'ın obstack pointer içeren bitişik bir nesneye ulaşmasını sağlayın.
3. **Leak libc** — victim pointer'ı komşu obstack'in `chunkfun`'ına yönlendirip function pointer'ı okuyarak.
4. **Forge obstack** verisini kontrollü `chunkfun`/`extra_arg` ile sahteleyin ve `_obstack_newchunk`'ın sahte başlığa düşmesini zorlayın; bu, saldırganın seçtiği bir function-pointer çağrısını sağlar.

## Referanslar

- [Flagvent 2025 FV25.08 obstack exploit (0xdf)](https://0xdf.gitlab.io/flagvent2025/hard)

{{#include ../../banners/hacktricks-training.md}}
