# GNU obstack function-pointer hijack

{{#include ../../banners/hacktricks-training.md}}

## Огляд

GNU obstacks вбудовують стан аллокатора разом із двома непрямими цілями виклику:

- `chunkfun` (offset `+0x38`) із сигнатурою `void *(*chunkfun)(void *, size_t)`
- `freefun` (offset `+0x40`) із сигнатурою `void (*freefun)(void *, void *)`
- `extra_arg` та прапорець `use_extra_arg` обирають, чи викликає `_obstack_newchunk` `chunkfun(new_size)` чи `chunkfun(extra_arg, new_size)`

Якщо атакувальник може пошкодити `struct obstack *`, що належить застосунку, або його поля, наступне розширення obstack (коли `next_free == chunk_limit`) викликає непрямий виклик через `chunkfun`, що дозволяє примітиви виконання коду.

## Primitive: size_t desync → 0-byte allocation → pointer OOB write

Поширений шаблон багу — використання **32-бітного регістра** для обчислення `sizeof(ptr) * count`, тоді як логічна довжина зберігається в 64-бітному `size_t`.

- Приклад: `elements = obstack_alloc(obs, sizeof(void *) * size);` компілюється як `SHL EAX,0x3` для `size << 3`.
- При `size = 0x20000000` та `sizeof(void *) = 8` множення обертається до `0x0` у 32-бітному контексті, тому масив вказівників має **0 байт**, але задокументоване `size` залишається `0x20000000`.
- Подальші `elements[curr++] = ptr;` записи виконують **8-байтові OOB запису вказівників** в суміжні heap-об'єкти, даючи керований примітив перезапису між об'єктами.

## Leaking libc via `obstack.chunkfun`

1. Place two heap objects adjacent (e.g., two stacks built with separate obstacks).
2. Use the pointer-array OOB write from object A to overwrite object B’s `elements` pointer so that a `pop`/read from B dereferences an address inside object A’s obstack.
3. Read `chunkfun` (`malloc` by default) at offset `0x38` to disclose a libc function pointer, then compute `libc_base = leak - malloc_offset` and derive other symbols (e.g., `system`, `"/bin/sh"`).

## Hijacking `chunkfun` with a fake obstack

Overwrite a victim’s stored `struct obstack *` to point at attacker-controlled data that mimics the obstack header. Minimal fields needed:

- `next_free == chunk_limit` to force `_obstack_newchunk` on next push
- `chunkfun = system_addr`
- `extra_arg = binsh_addr`, `use_extra_arg = 1` to select the two-argument call form

Then trigger an allocation on the victim obstack to execute `system("/bin/sh")` through the indirect call.

Example fake obstack layout (glibc 2.42 offsets):
```python
fake  = b""
fake += p64(0x1000)          # chunk_size
fake += p64(heap_leak)       # chunk
fake += p64(heap_leak)       # object_base
fake += p64(heap_leak)       # next_free == chunk_limit
fake += p64(heap_leak)       # chunk_limit
fake += p64(0xF)             # alignment_mask
fake += p64(0)               # temp
fake += p64(system_addr)     # chunkfun
fake += p64(0)               # freefun
fake += p64(binsh_addr)      # extra_arg
fake += p64(1)               # use_extra_arg flag set
```
## Рецепт атаки

1. **Trigger size wrap** щоб створити 0-byte pointer array з дуже великою логічною довжиною.
2. **Groom adjacency** щоб OOB pointer store досягнув сусіднього об'єкта, що містить obstack pointer.
3. **Leak libc** перенаправивши victim pointer на `chunkfun` сусіднього obstack і прочитавши function pointer.
4. **Forge obstack** дані з контрольованими `chunkfun`/`extra_arg` і змусити `_obstack_newchunk` опинитися в підробленому заголовку, що призведе до виклику function-pointer за вибором атакуючого.

## Посилання

- [Flagvent 2025 FV25.08 obstack exploit (0xdf)](https://0xdf.gitlab.io/flagvent2025/hard)

{{#include ../../banners/hacktricks-training.md}}
