# GNU obstack function-pointer hijack

{{#include ../../banners/hacktricks-training.md}}

## Overview

GNU obstacks allocator स्थिति को obstack हेडर में एम्बेड करते हैं और दो indirect call targets भी रखते हैं:

- `chunkfun` (offset `+0x38`) signature के साथ `void *(*chunkfun)(void *, size_t)`
- `freefun` (offset `+0x40`) signature के साथ `void (*freefun)(void *, void *)`
- `extra_arg` और एक `use_extra_arg` flag यह चुनते हैं कि `_obstack_newchunk` `chunkfun(new_size)` कॉल करे या `chunkfun(extra_arg, new_size)`

यदि attacker किसी application-owned `struct obstack *` या उसके fields को corrupt कर सके, तो obstack की अगली growth (जब `next_free == chunk_limit`) पर `_obstack_newchunk` के माध्यम से `chunkfun` पर indirect call ट्रिगर होता है, जिससे code execution primitives संभव हो जाते हैं।

## Primitive: size_t desync → 0-byte allocation → pointer OOB write

एक आम बग पैटर्न है कि `sizeof(ptr) * count` की गणना के लिए **32-bit register** का उपयोग किया जाए जबकि logical length 64-bit `size_t` में स्टोर किया जाता है।

- उदाहरण: `elements = obstack_alloc(obs, sizeof(void *) * size);` को `size << 3` के लिए `SHL EAX,0x3` के रूप में compile किया जाता है।
- यदि `size = 0x20000000` और `sizeof(void *) = 8`, तो multiplication 32-bit में wrap होकर `0x0` बन जाता है, इसलिए pointer array **0 bytes** का होता है, पर रिकॉर्ड की गई `size` बनी रहती है `0x20000000`।
- बाद के `elements[curr++] = ptr;` लिखने से adjacent heap objects में **8-byte OOB pointer stores** होते हैं, जिससे controlled cross-object overwrite primitive मिलता है।

## Leaking libc via `obstack.chunkfun`

1. दो heap objects को adjacent रखें (उदाहरण के लिए, दो अलग obstacks से बने stacks)।
2. object A के pointer-array OOB write का उपयोग करके object B के `elements` pointer को overwrite करें ताकि B से किया गया एक `pop`/read object A के obstack के अंदर किसी address को dereference करे।
3. offset `0x38` पर `chunkfun` (`malloc` by default) पढ़कर एक libc function pointer का leak करें, फिर `libc_base = leak - malloc_offset` से libc_base निकालें और अन्य symbols निकालें (जैसे `system`, `"/bin/sh"`)।

## Hijacking `chunkfun` with a fake obstack

victim के stored `struct obstack *` को overwrite करके उसे attacker-controlled data की ओर पॉइंट कराएँ जो obstack header का नक़ल हो। आवश्यक न्यूनतम fields:

- `next_free == chunk_limit` ताकि next push पर `_obstack_newchunk` ज़बरदस्त हो
- `chunkfun = system_addr`
- `extra_arg = binsh_addr`, `use_extra_arg = 1` ताकि two-argument call form चुना जाए

फिर victim obstack पर एक allocation ट्रिगर करें ताकि indirect call के ज़रिए `system("/bin/sh")` execute हो।

Example fake obstack layout (glibc 2.42 offsets):
```python
fake  = b""
fake += p64(0x1000)          # chunk_size
fake += p64(heap_leak)       # chunk
fake += p64(heap_leak)       # object_base
fake += p64(heap_leak)       # next_free == chunk_limit
fake += p64(heap_leak)       # chunk_limit
fake += p64(0xF)             # alignment_mask
fake += p64(0)               # temp
fake += p64(system_addr)     # chunkfun
fake += p64(0)               # freefun
fake += p64(binsh_addr)      # extra_arg
fake += p64(1)               # use_extra_arg flag set
```
## हमले की विधि

1. **Trigger size wrap** ताकि एक 0-byte pointer array बनाई जा सके जिसकी तार्किक लंबाई बहुत बड़ी हो।
2. **Groom adjacency** ताकि एक OOB pointer store पास के ऑब्जेक्ट तक पहुँच जाए जिसमें obstack pointer मौजूद हो।
3. **Leak libc** — एक victim pointer को neighbor obstack के `chunkfun` पर redirect करके और function pointer पढ़कर libc leak करें।
4. **Forge obstack** — नियंत्रित `chunkfun`/`extra_arg` के साथ obstack डेटा बनाकर और `_obstack_newchunk` को मजबूर करके कि वह जाली हेडर में आए, attacker की पसंद का function-pointer call उत्पन्न करें।

## संदर्भ

- [Flagvent 2025 FV25.08 obstack exploit (0xdf)](https://0xdf.gitlab.io/flagvent2025/hard)

{{#include ../../banners/hacktricks-training.md}}
