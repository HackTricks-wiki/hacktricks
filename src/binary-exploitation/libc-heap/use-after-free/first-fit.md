# İlk Uygun

{{#include ../../../banners/hacktricks-training.md}}

## **İlk Uygun**

glibc kullanarak bir programda bellek serbest bıraktığınızda, bellek parçalarını yönetmek için farklı "kutular" kullanılır. İşte iki yaygın senaryonun basitleştirilmiş bir açıklaması: sıralanmamış kutular ve hızlı kutular.

### Sıralanmamış Kutular

Hızlı bir parça olmayan bir bellek parçasını serbest bıraktığınızda, bu sıralanmamış kutuya gider. Bu kutu, yeni serbest bırakılan parçaların ön tarafa (baş) eklendiği bir liste gibi davranır. Yeni bir bellek parçası talep ettiğinizde, allocator sıralanmamış kutuya arka taraftan (kuyruk) bakarak yeterince büyük bir parça bulmaya çalışır. Sıralanmamış kutudan bir parça, ihtiyaç duyduğunuzdan büyükse, bu parça bölünür; ön kısmı geri döner ve kalan kısım kutuda kalır.

Örnek:

- 300 bayt (`a`) ayırırsınız, ardından 250 bayt (`b`) ayırırsınız, `a`yı serbest bırakırsınız ve tekrar 250 bayt (`c`) talep edersiniz.
- `a`yı serbest bıraktığınızda, bu sıralanmamış kutuya gider.
- Eğer sonra tekrar 250 bayt talep ederseniz, allocator `a`yı kuyrukta bulur ve onu böler, talebinize uyan kısmı geri döner ve geri kalanını kutuda tutar.
- `c`, önceki `a`ya işaret edecek ve `a` ile doldurulacaktır.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins, küçük bellek parçaları için kullanılır. Sıralanmamış kutuların aksine, fastbins yeni parçaları başa ekler ve son giren ilk çıkar (LIFO) davranışı oluşturur. Küçük bir bellek parçası talep ettiğinizde, allocator fastbin'in başından alır.

Örnek:

- Dört adet 20 baytlık parça (`a`, `b`, `c`, `d`) ayırırsınız.
- Bunları herhangi bir sırayla serbest bıraktığınızda, serbest bırakılan parçalar fastbin'in başına eklenir.
- Daha sonra 20 baytlık bir parça talep ederseniz, allocator fastbin'in başından en son serbest bırakılan parçayı döndürecektir.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Diğer Referanslar & Örnekler

- [**https://heap-exploitation.dhavalkapil.com/attacks/first_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first_fit)
- [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
- ARM64. Kullanımdan sonra serbest bırakma: Bir kullanıcı nesnesi oluşturun, serbest bırakın, serbest bırakılan parçayı alan bir nesne oluşturun ve buna yazma izni verin, **öncekinden user->password konumunu üzerine yazarak**. Kullanıcıyı **şifre kontrolünü atlamak için yeniden kullanın**.
- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example)
- Program notlar oluşturulmasına izin verir. Bir not, bir malloc(8) içinde not bilgilerini (çağrılabilecek bir işlevin işaretçisi ile) ve notun içeriği ile başka bir malloc(\<size>) işaretçisini içerecektir.
- Saldırı, not bilgisi boyutundan daha büyük malloc içeriğine sahip 2 not (note0 ve note1) oluşturmak ve ardından bunları serbest bırakmak olacaktır, böylece hızlı kutuya (veya tcache) gireceklerdir.
- Ardından, içerik boyutu 8 olan başka bir not (note2) oluşturun. İçerik, parçanın yeniden kullanılacağı note1'de olacak, burada işlev işaretçisini kazanan işlevine işaret edecek şekilde değiştirebiliriz ve ardından note1'i Kullanımdan Sonra Serbest Bırakma ile yeni işlev işaretçisini çağırabiliriz.
- [**https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html)
- Bazı bellek ayırmak, istenen değeri yazmak, serbest bırakmak, yeniden ayırmak ve önceki veriler hala orada olduğu için, parçadaki yeni beklenen yapı ile ilgili olarak işlenmesi mümkün olacaktır, bu da değeri ayarlayıp bayrağı almayı mümkün kılar.
- [**https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html)
- Bu durumda, belirli bir parçanın içine 4 yazmak gereklidir, bu da tahsis edilen ilk parçadır (hepsini zorla serbest bıraktıktan sonra bile). Her yeni tahsis edilen parçanın dizideki numarası saklanır. Ardından, 4 parça (+ başlangıçta tahsis edilen) ayırın, sonuncusu içinde 4 bulunduracak, bunları serbest bırakın ve ilk parçanın yeniden tahsis edilmesini zorlayın, bu da içinde 4 bulunan son serbest bırakılan parçayı kullanacaktır.

{{#include /banners/hacktricks-training.md}}
