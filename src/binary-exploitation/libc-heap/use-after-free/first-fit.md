# İlk Uygun

{{#include ../../../banners/hacktricks-training.md}}

## **İlk Uygun**

glibc kullanarak bir programda bellek serbest bıraktığınızda, bellek parçalarını yönetmek için farklı "kutular" kullanılır. İşte iki yaygın senaryonun basitleştirilmiş bir açıklaması: sıralanmamış kutular ve hızlı kutular.

### Sıralanmamış Kutular

Hızlı bir parça olmayan bir bellek parçasını serbest bıraktığınızda, bu sıralanmamış kutuya gider. Bu kutu, yeni serbest bırakılan parçaların ön tarafa (baş) eklendiği bir liste gibi davranır. Yeni bir bellek parçası talep ettiğinizde, allocator sıralanmamış kutuya arka taraftan (kuyruk) bakarak yeterince büyük bir parça bulmaya çalışır. Sıralanmamış kutudan bir parça, ihtiyacınız olandan büyükse, bu parça bölünür; ön kısım geri döner ve kalan kısım kutuda kalır.

Örnek:

- 300 bayt (`a`) ayırırsınız, ardından 250 bayt (`b`), `a`yı serbest bırakırsınız ve tekrar 250 bayt (`c`) talep edersiniz.
- `a`yı serbest bıraktığınızda, bu sıralanmamış kutuya gider.
- Eğer sonra tekrar 250 bayt talep ederseniz, allocator `a`yı kuyrukta bulur ve onu böler, talebinize uyan kısmı geri döner ve geri kalanını kutuda tutar.
- `c`, önceki `a`ya işaret edecek ve `a` ile doldurulacaktır.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins, küçük bellek parçaları için kullanılır. Sıralanmamış kutuların aksine, fastbins yeni parçaları başa ekler, bu da son giren ilk çıkar (LIFO) davranışı oluşturur. Küçük bir bellek parçası talep ettiğinizde, ayırıcı fastbin'in başından alır.

Örnek:

- Dört adet 20 baytlık parça ayırırsınız (`a`, `b`, `c`, `d`).
- Onları herhangi bir sırayla serbest bıraktığınızda, serbest bırakılan parçalar fastbin'in başına eklenir.
- Daha sonra 20 baytlık bir parça talep ederseniz, ayırıcı fastbin'in başından en son serbest bırakılan parçayı döndürecektir.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Diğer Referanslar & Örnekler

- [**https://heap-exploitation.dhavalkapil.com/attacks/first_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first_fit)
- [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
- ARM64. Kullanımdan sonra serbest bırakma: Bir kullanıcı nesnesi oluşturun, serbest bırakın, serbest bırakılan parçayı alan bir nesne oluşturun ve buna yazma izni verin, **öncekinden user->password konumunu üzerine yazarak**. Kullanıcıyı yeniden kullanarak **şifre kontrolünü atlayın**.
- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example)
- Program notlar oluşturulmasına izin verir. Bir not, bir malloc(8) içinde not bilgilerini (çağrılabilecek bir işlevin işaretçisi ile) ve notun içeriği ile başka bir malloc(\<size>) işaretçisini içerecektir.
- Saldırı, not bilgisi boyutundan daha büyük malloc içeriklerine sahip 2 not (note0 ve note1) oluşturmak ve ardından bunları serbest bırakmak olacaktır, böylece hızlı kutuya (veya tcache) gireceklerdir.
- Ardından, içerik boyutu 8 olan başka bir not (note2) oluşturun. İçerik, işlev işaretçisini win işlevine işaret edecek şekilde değiştirebileceğimiz note1'de olacak ve ardından Kullanımdan Sonra Serbest Bırakma ile note1'i yeni işlev işaretçisini çağırmak için kullanın.
- [**https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html)
- Bazı bellek ayırmak, istenen değeri yazmak, serbest bırakmak, yeniden ayırmak ve önceki veriler hala orada olduğu için, parçadaki yeni beklenen yapı ile işlenmesi mümkün hale gelir, bu da değeri ayarlayıp bayrağı almayı sağlar.
- [**https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html)
- Bu durumda, belirli bir parçanın içine 4 yazmak gereklidir, bu da tahsis edilen ilk parçadır (hepsini zorla serbest bıraktıktan sonra bile). Her yeni tahsis edilen parçanın dizideki numarası saklanır. Ardından, 4 parça (+ başlangıçta tahsis edilen) ayırın, sonuncusu içinde 4 olacak, bunları serbest bırakın ve ilk parçanın yeniden tahsis edilmesini zorlayın, bu da içinde 4 olan son serbest bırakılan parçayı kullanacaktır.
