# First Fit

{{#include ../../../banners/hacktricks-training.md}}

## **First Fit**

当你在程序中使用 glibc 释放内存时，会使用不同的“桶”来管理内存块。以下是两种常见场景的简化解释：未排序桶和快速桶。

### Unsorted Bins

当你释放一个不是快速块的内存块时，它会进入未排序桶。这个桶就像一个列表，新释放的块被添加到前面（“头”）。当你请求一个新的内存块时，分配器从后面（“尾”）查看未排序桶，以找到一个足够大的块。如果未排序桶中的块大于你所需的大小，它会被拆分，前面的部分被返回，剩余的部分留在桶中。

示例：

- 你分配 300 字节（`a`），然后 250 字节（`b`），释放 `a` 并再次请求 250 字节（`c`）。
- 当你释放 `a` 时，它进入未排序桶。
- 如果你再次请求 250 字节，分配器在尾部找到 `a` 并将其拆分，返回适合你请求的部分，并将其余部分保留在桶中。
- `c` 将指向之前的 `a` 并填充 `a` 的内容。
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins用于小内存块。与未排序的bins不同，fastbins将新块添加到头部，创建后进先出（LIFO）行为。如果您请求一个小内存块，分配器将从fastbin的头部提取。

示例：

- 您分配四个20字节的块（`a`，`b`，`c`，`d`）。
- 当您以任何顺序释放它们时，释放的块会被添加到fastbin的头部。
- 如果您随后请求一个20字节的块，分配器将从fastbin的头部返回最近释放的块。
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## 其他参考资料与示例

- [**https://heap-exploitation.dhavalkapil.com/attacks/first_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first_fit)
- [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
- ARM64. 使用后释放：生成一个用户对象，释放它，生成一个获取已释放块的对象并允许写入，**覆盖之前的 user->password 位置**。重用用户以**绕过密码检查**
- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example)
- 该程序允许创建笔记。笔记将包含在 malloc(8) 中的笔记信息（带有可以调用的函数指针）和指向另一个 malloc(\<size>) 的指针，后者包含笔记的内容。
- 攻击将是创建 2 个笔记（note0 和 note1），其 malloc 内容大于笔记信息大小，然后释放它们以使其进入快速 bin（或 tcache）。
- 然后，创建另一个笔记（note2），内容大小为 8。内容将位于 note1 中，因为该块将被重用，我们可以修改函数指针以指向 win 函数，然后使用后释放 note1 来调用新的函数指针。
- [**https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html)
- 可以分配一些内存，写入所需值，释放它，重新分配它，由于之前的数据仍然存在，它将根据块中的新预期结构进行处理，从而可以设置值以获取标志。
- [**https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html)
- 在这种情况下，需要在特定块中写入 4，该块是第一个被分配的块（即使在强制释放所有块后）。在每个新分配的块中，其在数组索引中的编号被存储。然后，分配 4 个块（+ 最初分配的），最后一个块将包含 4，释放它们并强制重新分配第一个块，这将使用最后释放的块，即包含 4 的块。
