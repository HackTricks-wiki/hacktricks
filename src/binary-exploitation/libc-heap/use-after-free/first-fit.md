# First Fit

{{#include ../../../banners/hacktricks-training.md}}

## **First Fit**

Kada oslobodite memoriju u programu koristeÄ‡i glibc, razliÄiti "bins" se koriste za upravljanje delovima memorije. Evo pojednostavljenog objaÅ¡njenja dva uobiÄajena scenarija: neusortirani bins i fastbins.

### Neusortirani Bins

Kada oslobodite deo memorije koji nije brzi deo, on ide u neusortirani bin. Ovaj bin deluje kao lista gde se novi osloboÄ‘eni delovi dodaju na poÄetak (na "glavu"). Kada zatraÅ¾ite novi deo memorije, alokator gleda neusortirani bin od pozadi (na "rep") da pronaÄ‘e deo koji je dovoljno velik. Ako je deo iz neusortiranog bina veÄ‡i od onoga Å¡to vam treba, on se deli, pri Äemu se prednji deo vraÄ‡a, a preostali deo ostaje u binu.

Primer:

- Alocirate 300 bajtova (`a`), zatim 250 bajtova (`b`), zatim oslobodite `a` i ponovo zatraÅ¾ite 250 bajtova (`c`).
- Kada oslobodite `a`, on ide u neusortirani bin.
- Ako zatim ponovo zatraÅ¾ite 250 bajtova, alokator pronalazi `a` na repu i deli ga, vraÄ‡ajuÄ‡i deo koji odgovara vaÅ¡em zahtevu i zadrÅ¾avajuÄ‡i ostatak u binu.
- `c` Ä‡e pokazivati na prethodni `a` i biti ispunjen sadrÅ¾ajem `a`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins se koriste za male delove memorije. Za razliku od nesortiranih binova, fastbins dodaju nove delove na poÄetak, stvarajuÄ‡i ponaÅ¡anje poslednji ulaz-prvi izlaz (LIFO). Ako zatraÅ¾ite mali deo memorije, alokator Ä‡e uzeti iz vrha fastbina.

Example:
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
---
### ğŸ”¥ Savremena razmatranja glibc (tcache â‰¥ 2.26)

Od glibc 2.26 svaki nit Äuva svoj vlastiti **tcache** koji se pretraÅ¾uje *pre* nesortirane kante. Stoga Ä‡e se scenarij prvog pogodka **dostiÄ‡i samo ako**:

1. TraÅ¾ena veliÄina je **veÄ‡a od `tcache_max`** (0x420 na 64-bitnom sistemu po defaultu), *ili*
2. OdgovarajuÄ‡a tcache kanta je **veÄ‡ puna ili ruÄno ispraÅ¾njena** (alokacijom 7 elemenata i njihovim zadrÅ¾avanjem u upotrebi).

U pravim eksploatacijama obiÄno Ä‡ete dodati pomoÄ‡nu rutinu kao Å¡to je:
```c
// Drain the tcache for a given size
for(int i = 0; i < 7; i++) pool[i] = malloc(0x100);
for(int i = 0; i < 7; i++) free(pool[i]);
```
Once the tcache is exhausted, subsequent frees go to the unsorted bin and classic first-fit behaviour (tail search, head insertion) can be triggered again.

---
### ğŸš© Kreiranje UAF-a sa preklapajuÄ‡im delovima koristeÄ‡i first-fit

Fragment ispod (testiran na glibc 2.38) pokazuje kako se splitter u nesortiranom binu moÅ¾e iskoristiti za kreiranje 2 **preklapajuÄ‡a pokazivaÄa** â€“ moÄ‡ne primitivne operacije koja pretvara jedno oslobaÄ‘anje u pisanje nakon oslobaÄ‘anja.
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(){
setbuf(stdout, NULL);

/* 1. prepare 2 adjacent chunks and free the first one */
char *A = malloc(0x420);   // big enough to bypass tcache
char *B = malloc(0x420);
strcpy(A, "AAAA\n");
free(A);                   // A â†’ unsorted

/* 2. request a *smaller* size to force a split of A */
char *C = malloc(0x400);   // returns lower half of former A

/* 3. The remainder of A is still in the unsorted bin.
Another 0x400-byte malloc will now return the *same*
region pointed to by B â€“ creating a UAF/overlap. */
char *C2 = malloc(0x400);

printf("B  = %p\nC2 = %p (overlaps B)\n", B, C2);

// Arbitrary write in B is immediately visible via C2
memset(B, 'X', 0x10);
fwrite(C2, 1, 0x10, stdout);  // prints Xs
}
```
Exploitation recipe (common in recent CTFs):

1. **Isprazite** tcache za ciljani veliÄinu.
2. **Oslobodite** deo tako da zavrÅ¡i u nesortiranoj kanti.
3. **Alocirajte** malo manju veliÄinu â€“ alokator deli nesortirani deo.
4. **Alocirajte** ponovo â€“ preostali deo se preklapa sa postojeÄ‡im koriÅ¡Ä‡enim delom â†’ UAF.
5. PrepiÅ¡ite osetljive polja (pokazivaÄe funkcija, FILE vtable, itd.)

PraktiÄna primena moÅ¾e se naÄ‡i u 2024 HITCON Quals *Setjmp* izazovu gde se ova taÄno primitivna tehnika koristi za prebacivanje sa UAF na potpunu kontrolu nad `__free_hook`.{{#ref}}
../../../../references/2024_setjmp_firstfit.md
{{#endref}}

---
### ğŸ›¡ï¸  MoguÄ‡nosti zaÅ¡tite i uÄvrÅ¡Ä‡ivanja

* **Sigurno povezivanje (glibc â‰¥ 2.32)** Å¡titi samo jednostruko povezane *tcache*/**fastbin** liste. Nesortirane/male/velike kante i dalje Äuvaju sirove pokazivaÄe, tako da preklapanja zasnovana na prvom odgovoru ostaju moguÄ‡a ako moÅ¾ete dobiti curenje iz heap-a.
* **Enkripcija pokazivaÄa na heap i MTE** (ARM64) joÅ¡ uvek ne utiÄu na x86-64 glibc, ali oznake za uÄvrÅ¡Ä‡ivanje distribucije kao Å¡to su `GLIBC_TUNABLES=glibc.malloc.check=3` Ä‡e prekinuti rad na nekonzistentnim metapodacima i mogu prekinuti naivne PoC-ove.
* **Popunjavanje tcache prilikom oslobaÄ‘anja** (predloÅ¾eno 2024. za glibc 2.41) dodatno bi smanjilo koriÅ¡Ä‡enje nesortiranih; pratite buduÄ‡e verzije prilikom razvijanja generiÄkih eksploata.

---
## Ostale reference i primeri

- [**https://heap-exploitation.dhavalkapil.com/attacks/first_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first_fit)
- [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
- ARM64. Upotreba nakon oslobaÄ‘anja: GeneriÅ¡ite korisniÄki objekat, oslobodite ga, generiÅ¡ite objekat koji dobija osloboÄ‘eni deo i omoguÄ‡ite pisanje u njega, **prepisujuÄ‡i poziciju user->password** iz prethodnog. Ponovo upotrebite korisnika da **obiÄ‘ete proveru lozinke**
- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example)
- Program omoguÄ‡ava kreiranje beleÅ¡ki. BeleÅ¡ka Ä‡e imati informacije o beleÅ¡ci u malloc(8) (sa pokazivaÄem na funkciju koja bi mogla biti pozvana) i pokazivaÄ na drugi malloc(<size>) sa sadrÅ¾ajem beleÅ¡ke.
- Napad bi bio da se kreiraju 2 beleÅ¡ke (note0 i note1) sa veÄ‡im malloc sadrÅ¾ajem od veliÄine informacija o beleÅ¡ci i zatim ih osloboditi kako bi uÅ¡le u brzu kantu (ili tcache).
- Zatim, kreirajte joÅ¡ jednu beleÅ¡ku (note2) sa veliÄinom sadrÅ¾aja 8. SadrÅ¾aj Ä‡e biti u note1 jer Ä‡e se deo ponovo koristiti, gde bismo mogli da modifikujemo pokazivaÄ funkcije da upuÄ‡uje na win funkciju i zatim Upotreba-Nakon-OslobaÄ‘anja note1 da pozove novi pokazivaÄ funkcije.
- [**https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html)
- MoguÄ‡e je alocirati neku memoriju, napisati Å¾eljenu vrednost, osloboditi je, ponovo alocirati i poÅ¡to su prethodni podaci joÅ¡ uvek tu, biÄ‡e tretirani prema novoj oÄekivanoj strukturi u delu, Å¡to omoguÄ‡ava postavljanje vrednosti za dobijanje zastavice.
- [**https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html)
- U ovom sluÄaju potrebno je napisati 4 unutar specifiÄnog dela koji je prvi koji se alocira (Äak i nakon prisilnog oslobaÄ‘anja svih njih). Na svakom novom alociranom delu njegovo broj u indeksu niza se Äuva. Zatim, alocirajte 4 dela (+ inicijalno alocirani), poslednji Ä‡e imati 4 unutar njega, oslobodite ih i prisilite ponovnu alokaciju prvog, koji Ä‡e koristiti poslednji osloboÄ‘eni deo koji je onaj sa 4 unutar njega.
- 2024 HITCON Quals Setjmp izveÅ¡taj (Quarkslab) â€“ praktiÄan napad preklapanja prvog odgovora / nesortiranog dela: <https://ctftime.org/writeup/39355>
- Angstrom CTF 2024 *heapify* izveÅ¡taj â€“ zloupotreba deljenja nesortirane kante za curenje libc i dobijanje preklapanja: <https://hackmd.io/@aneii11/H1S2snV40>

{{#include ../../../banners/hacktricks-training.md}}
