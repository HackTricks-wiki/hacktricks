# First Fit

{{#include ../../../banners/hacktricks-training.md}}

## **First Fit**

Quando voc√™ libera mem√≥ria em um programa usando glibc, diferentes "bins" s√£o usados para gerenciar os blocos de mem√≥ria. Aqui est√° uma explica√ß√£o simplificada de dois cen√°rios comuns: bins n√£o ordenados e fastbins.

### Bins N√£o Ordenados

Quando voc√™ libera um bloco de mem√≥ria que n√£o √© um bloco r√°pido, ele vai para o bin n√£o ordenado. Este bin atua como uma lista onde novos blocos liberados s√£o adicionados √† frente (a "cabe√ßa"). Quando voc√™ solicita um novo bloco de mem√≥ria, o alocador olha para o bin n√£o ordenado de tr√°s para frente (a "cauda") para encontrar um bloco que seja grande o suficiente. Se um bloco do bin n√£o ordenado for maior do que o que voc√™ precisa, ele √© dividido, com a parte da frente sendo retornada e a parte restante permanecendo no bin.

Exemplo:

- Voc√™ aloca 300 bytes (`a`), depois 250 bytes (`b`), ent√£o libera `a` e solicita novamente 250 bytes (`c`).
- Quando voc√™ libera `a`, ele vai para o bin n√£o ordenado.
- Se voc√™ ent√£o solicitar 250 bytes novamente, o alocador encontra `a` na cauda e o divide, retornando a parte que atende ao seu pedido e mantendo o restante no bin.
- `c` apontar√° para o anterior `a` e ser√° preenchido com o conte√∫do de `a`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins s√£o usados para pequenos peda√ßos de mem√≥ria. Ao contr√°rio dos bins n√£o ordenados, fastbins adicionam novos peda√ßos ao in√≠cio, criando um comportamento de √∫ltimo a entrar, primeiro a sair (LIFO). Se voc√™ solicitar um pequeno peda√ßo de mem√≥ria, o alocador ir√° retirar do in√≠cio do fastbin.

Exemplo:
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
---
### üî• Considera√ß√µes modernas do glibc (tcache ‚â• 2.26)

Desde o glibc 2.26, cada thread mant√©m seu pr√≥prio **tcache** que √© consultado *antes* do bin n√£o ordenado. Portanto, um cen√°rio de first-fit **s√≥ ser√° alcan√ßado se**:

1. O tamanho solicitado √© **maior que `tcache_max`** (0x420 em 64 bits por padr√£o), *ou*
2. O bin correspondente do tcache est√° **j√° cheio ou esvaziado manualmente** (alocando 7 elementos e mantendo-os em uso).

Em exploits reais, voc√™ geralmente adicionar√° uma rotina auxiliar como:
```c
// Drain the tcache for a given size
for(int i = 0; i < 7; i++) pool[i] = malloc(0x100);
for(int i = 0; i < 7; i++) free(pool[i]);
```
Uma vez que o tcache est√° esgotado, libera√ß√µes subsequentes v√£o para o bin n√£o ordenado e o comportamento cl√°ssico de first-fit (busca na cauda, inser√ß√£o na cabe√ßa) pode ser acionado novamente.

---
### üö© Criando um UAF de chunk sobreposto com first-fit

O fragmento abaixo (testado no glibc 2.38) mostra como o divisor no bin n√£o ordenado pode ser abusado para criar 2 **ponteiros sobrepostos** ‚Äì um primitivo poderoso que converte uma √∫nica libera√ß√£o em uma escrita ap√≥s a libera√ß√£o.
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(){
setbuf(stdout, NULL);

/* 1. prepare 2 adjacent chunks and free the first one */
char *A = malloc(0x420);   // big enough to bypass tcache
char *B = malloc(0x420);
strcpy(A, "AAAA\n");
free(A);                   // A ‚Üí unsorted

/* 2. request a *smaller* size to force a split of A */
char *C = malloc(0x400);   // returns lower half of former A

/* 3. The remainder of A is still in the unsorted bin.
Another 0x400-byte malloc will now return the *same*
region pointed to by B ‚Äì creating a UAF/overlap. */
char *C2 = malloc(0x400);

printf("B  = %p\nC2 = %p (overlaps B)\n", B, C2);

// Arbitrary write in B is immediately visible via C2
memset(B, 'X', 0x10);
fwrite(C2, 1, 0x10, stdout);  // prints Xs
}
```
Receita de explora√ß√£o (comum em CTFs recentes):

1. **Drenar** o tcache para o tamanho alvo.
2. **Liberar** um chunk para que ele caia no bin n√£o ordenado.
3. **Alocar** um tamanho ligeiramente menor ‚Äì o alocador divide o chunk n√£o ordenado.
4. **Alocar** novamente ‚Äì a parte restante se sobrep√µe a um chunk existente em uso ‚Üí UAF.
5. Sobrescrever campos sens√≠veis (ponteiros de fun√ß√£o, vtable de FILE, etc.)

Uma aplica√ß√£o pr√°tica pode ser encontrada no desafio *Setjmp* das Quals HITCON 2024, onde este exato primitivo √© usado para pivotar de um UAF para controle total de `__free_hook`.{{#ref}}
../../../../references/2024_setjmp_firstfit.md
{{#endref}}

---
### üõ°Ô∏è  Mitiga√ß√µes & Fortalecimento

* **Safe-linking (glibc ‚â• 2.32)** protege apenas as listas *tcache*/**fastbin** encadeadas. Os bins n√£o ordenados/pequenos/grandes ainda armazenam ponteiros brutos, ent√£o sobreposi√ß√µes baseadas em first-fit permanecem vi√°veis se voc√™ conseguir obter um leak de heap.
* **Criptografia de ponteiro de heap & MTE** (ARM64) ainda n√£o afetam glibc x86-64, mas flags de endurecimento de distribui√ß√µes como `GLIBC_TUNABLES=glibc.malloc.check=3` abortar√£o em metadados inconsistentes e podem quebrar PoCs ing√™nuas.
* **Preenchendo tcache ao liberar** (proposto em 2024 para glibc 2.41) reduziria ainda mais o uso n√£o ordenado; monitore lan√ßamentos futuros ao desenvolver exploits gen√©ricos.

---
## Outras Refer√™ncias & Exemplos

- [**https://heap-exploitation.dhavalkapil.com/attacks/first_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first_fit)
- [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
- ARM64. Use after free: Gere um objeto de usu√°rio, libere-o, gere um objeto que obtenha o chunk liberado e permita escrever nele, **sobrescrevendo a posi√ß√£o de user->password** do anterior. Reutilize o usu√°rio para **burlar a verifica√ß√£o de senha**
- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example)
- O programa permite criar notas. Uma nota ter√° as informa√ß√µes da nota em um malloc(8) (com um ponteiro para uma fun√ß√£o que pode ser chamada) e um ponteiro para outro malloc(<size>) com o conte√∫do da nota.
- O ataque seria criar 2 notas (note0 e note1) com conte√∫dos malloc maiores do que o tamanho das informa√ß√µes da nota e, em seguida, liber√°-las para que entrem no fast bin (ou tcache).
- Em seguida, crie outra nota (note2) com tamanho de conte√∫do 8. O conte√∫do vai estar na note1, pois o chunk ser√° reutilizado, onde poder√≠amos modificar o ponteiro de fun√ß√£o para apontar para a fun√ß√£o win e ent√£o Use-After-Free a note1 para chamar o novo ponteiro de fun√ß√£o.
- [**https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html)
- √â poss√≠vel alocar alguma mem√≥ria, escrever o valor desejado, liber√°-la, realoc√°-la e, como os dados anteriores ainda est√£o l√°, ser√£o tratados de acordo com a nova estrutura esperada no chunk, tornando poss√≠vel definir o valor para obter a flag.
- [**https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html)
- Neste caso, √© necess√°rio escrever 4 dentro de um chunk espec√≠fico que √© o primeiro a ser alocado (mesmo ap√≥s for√ßar a libera√ß√£o de todos eles). Em cada novo chunk alocado, seu n√∫mero no √≠ndice do array √© armazenado. Ent√£o, aloque 4 chunks (+ o inicialmente alocado), o √∫ltimo ter√° 4 dentro dele, libere-os e force a realoca√ß√£o do primeiro, que usar√° o √∫ltimo chunk liberado, que √© o que tem 4 dentro dele.
- 2024 HITCON Quals Setjmp write-up (Quarkslab) ‚Äì ataque pr√°tico de sobreposi√ß√£o first-fit / unsorted-split: <https://ctftime.org/writeup/39355>
- Angstrom CTF 2024 *heapify* write-up ‚Äì abusando da divis√£o de bin n√£o ordenado para vazar libc e ganhar sobreposi√ß√£o: <https://hackmd.io/@aneii11/H1S2snV40>

{{#include ../../../banners/hacktricks-training.md}}
