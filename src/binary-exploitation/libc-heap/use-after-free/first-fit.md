# First Fit

{{#include ../../../banners/hacktricks-training.md}}

## **First Fit**

Kada oslobodite memoriju u programu koristeÄ‡i glibc, razliÄiti "bins" se koriste za upravljanje delovima memorije. Evo pojednostavljenog objaÅ¡njenja dva uobiÄajena scenarija: neusortirani bins i fastbins.

### Neusortirani Bins

Kada oslobodite deo memorije koji nije brzi deo, on ide u neusortirani bin. Ovaj bin deluje kao lista gde se novi osloboÄ‘eni delovi dodaju na poÄetak (na "glavu"). Kada zatraÅ¾ite novi deo memorije, alokator gleda neusortirani bin od pozadi (na "rep") da pronaÄ‘e deo koji je dovoljno velik. Ako je deo iz neusortiranog bina veÄ‡i od onoga Å¡to vam treba, on se deli, pri Äemu se prednji deo vraÄ‡a, a preostali deo ostaje u binu.

Primer:

- Alocirate 300 bajtova (`a`), zatim 250 bajtova (`b`), zatim oslobodite `a` i ponovo zatraÅ¾ite 250 bajtova (`c`).
- Kada oslobodite `a`, on ide u neusortirani bin.
- Ako zatim ponovo zatraÅ¾ite 250 bajtova, alokator pronalazi `a` na repu i deli ga, vraÄ‡ajuÄ‡i deo koji odgovara vaÅ¡em zahtevu i zadrÅ¾avajuÄ‡i ostatak u binu.
- `c` Ä‡e pokazivati na prethodni `a` i biÄ‡e ispunjen sadrÅ¾ajem `a`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins se koriste za male delove memorije. Za razliku od nesortiranih binova, fastbins dodaju nove delove na poÄetak, stvarajuÄ‡i ponaÅ¡anje poslednji ulaz-prvi izlaz (LIFO). Ako zatraÅ¾ite mali deo memorije, alokator Ä‡e uzeti iz vrha fastbina.

Example:
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
---
### ğŸ”¥ Savremena glibc razmatranja (tcache â‰¥ 2.26)

Od glibc 2.26 svaki nit Äuva svoj vlastiti **tcache** koji se pretraÅ¾uje *pre* nesortiranog bin-a. Stoga Ä‡e se scenarij prvog pogodka **dostiÄ‡i samo ako**:

1. TraÅ¾ena veliÄina je **veÄ‡a od `tcache_max`** (0x420 na 64-bitnom sistemu po defaultu), *ili*
2. OdgovarajuÄ‡i tcache bin je **veÄ‡ pun ili ruÄno ispraznjen** (alokacijom 7 elemenata i njihovim zadrÅ¾avanjem u upotrebi).

U pravim eksploatacijama obiÄno Ä‡ete dodati pomoÄ‡nu rutinu kao Å¡to je:
```c
// Drain the tcache for a given size
for(int i = 0; i < 7; i++) pool[i] = malloc(0x100);
for(int i = 0; i < 7; i++) free(pool[i]);
```
Jednom kada je tcache iscrpljen, naredni oslobaÄ‘anja idu u nesortiranu kantu i klasiÄno ponaÅ¡anje prvog odgovora (pretraga od repa, umetanje na glavu) moÅ¾e ponovo biti aktivirano.

---
### ğŸš© Kreiranje UAF-a sa preklapajuÄ‡im delovima koristeÄ‡i prvi odgovor

Fragment ispod (testiran na glibc 2.38) pokazuje kako se razdavaÄ u nesortiranoj kanti moÅ¾e zloupotrebiti da se kreiraju 2 **preklapajuÄ‡e pokazivaÄe** â€“ moÄ‡na primitiva koja pretvara jedno oslobaÄ‘anje u pisanje nakon oslobaÄ‘anja.
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(){
setbuf(stdout, NULL);

/* 1. prepare 2 adjacent chunks and free the first one */
char *A = malloc(0x420);   // big enough to bypass tcache
char *B = malloc(0x420);
strcpy(A, "AAAA\n");
free(A);                   // A â†’ unsorted

/* 2. request a *smaller* size to force a split of A */
char *C = malloc(0x400);   // returns lower half of former A

/* 3. The remainder of A is still in the unsorted bin.
Another 0x400-byte malloc will now return the *same*
region pointed to by B â€“ creating a UAF/overlap. */
char *C2 = malloc(0x400);

printf("B  = %p\nC2 = %p (overlaps B)\n", B, C2);

// Arbitrary write in B is immediately visible via C2
memset(B, 'X', 0x10);
fwrite(C2, 1, 0x10, stdout);  // prints Xs
}
```
Exploitation recipe (common in recent CTFs):

1. **Isprazite** tcache za ciljani veliÄinu.
2. **Oslobodite** deo tako da zavrÅ¡i u nesortiranoj kanti.
3. **Alocirajte** malo manju veliÄinu â€“ alokator deli nesortirani deo.
4. **Alocirajte** ponovo â€“ preostali deo se preklapa sa postojeÄ‡im koriÅ¡Ä‡enim delom â†’ UAF.
5. PrepiÅ¡ite osetljive polja (pokazivaÄe na funkcije, FILE vtable, itd.)

PraktiÄna primena moÅ¾e se naÄ‡i u 2024 HITCON Quals *Setjmp* izazovu gde se ova taÄno primitivna tehnika koristi za prebacivanje sa UAF na potpunu kontrolu nad `__free_hook`.

---
### ğŸ›¡ï¸  Mite i OjaÄavanje

* **Sigurno povezivanje (glibc â‰¥ 2.32)** Å¡titi samo jednostruko povezane *tcache*/**fastbin** liste. Nesortirane/male/velike kante i dalje Äuvaju sirove pokazivaÄe, tako da preklapanja zasnovana na prvom odgovarajuÄ‡em ostaju moguÄ‡a ako moÅ¾ete dobiti heap leak.
* **Enkripcija pokazivaÄa na heap i MTE** (ARM64) joÅ¡ uvek ne utiÄu na x86-64 glibc, ali oznake za ojaÄavanje distribucije kao Å¡to su `GLIBC_TUNABLES=glibc.malloc.check=3` Ä‡e prekinuti rad na nekonzistentnim metapodacima i mogu prekinuti naivne PoC-ove.
* **Popunjavanje tcache prilikom oslobaÄ‘anja** (predloÅ¾eno 2024. za glibc 2.41) dodatno bi smanjilo koriÅ¡Ä‡enje nesortiranih; pratite buduÄ‡e verzije prilikom razvijanja generiÄkih eksploata.

---
## Ostale Reference i Primeri

- [**https://heap-exploitation.dhavalkapil.com/attacks/first_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first_fit)
- [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
- ARM64. Use after free: GeneriÅ¡ite korisniÄki objekat, oslobodite ga, generiÅ¡ite objekat koji dobija osloboÄ‘eni deo i omoguÄ‡ite pisanje u njega, **prepisujuÄ‡i poziciju user->password** iz prethodnog. Ponovo upotrebite korisnika da **obiÄ‘ete proveru lozinke**
- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example)
- Program omoguÄ‡ava kreiranje beleÅ¡ki. BeleÅ¡ka Ä‡e imati informacije o beleÅ¡ci u malloc(8) (sa pokazivaÄem na funkciju koja bi mogla biti pozvana) i pokazivaÄ na drugi malloc(<size>) sa sadrÅ¾ajem beleÅ¡ke.
- Napad bi bio da se kreiraju 2 beleÅ¡ke (note0 i note1) sa veÄ‡im malloc sadrÅ¾ajem od veliÄine informacija o beleÅ¡ci i zatim ih osloboditi kako bi zavrÅ¡ile u fast bin (ili tcache).
- Zatim, kreirajte joÅ¡ jednu beleÅ¡ku (note2) sa veliÄinom sadrÅ¾aja 8. SadrÅ¾aj Ä‡e biti u note1 jer Ä‡e se deo ponovo koristiti, gde bismo mogli modifikovati pokazivaÄ na funkciju da pokazuje na win funkciju i zatim Use-After-Free note1 da pozove novi pokazivaÄ na funkciju.
- [**https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html)
- MoguÄ‡e je alocirati neku memoriju, napisati Å¾eljenu vrednost, osloboditi je, ponovo alocirati i poÅ¡to su prethodni podaci joÅ¡ uvek tu, biÄ‡e tretirani prema novoj oÄekivanoj strukturi u delu, Å¡to omoguÄ‡ava postavljanje vrednosti za dobijanje zastavice.
- [**https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html)
- U ovom sluÄaju potrebno je napisati 4 unutar specifiÄnog dela koji je prvi koji se alocira (Äak i nakon prisilnog oslobaÄ‘anja svih njih). Na svakom novom alociranom delu njegovo broj u indeksu niza se Äuva. Zatim, alocirajte 4 dela (+ inicijalno alocirani), poslednji Ä‡e imati 4 unutar njega, oslobodite ih i prisilite ponovnu alokaciju prvog, koji Ä‡e koristiti poslednji osloboÄ‘eni deo koji je onaj sa 4 unutar njega.
- 2024 HITCON Quals Setjmp write-up (Quarkslab) â€“ praktiÄan first-fit / nesortirano-preklapanje napad: <https://ctftime.org/writeup/39355>
- Angstrom CTF 2024 *heapify* write-up â€“ zloupotreba nesortiranog deljenja za curenje libc i dobijanje preklapanja: <https://hackmd.io/@aneii11/H1S2snV40>

{{#include ../../../banners/hacktricks-training.md}}
