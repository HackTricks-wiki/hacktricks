# First Fit

{{#include ../../../banners/hacktricks-training.md}}

## **First Fit**

Bir programda glibc kullanarak bellek serbest bÄ±raktÄ±ÄŸÄ±nÄ±zda, bellek parÃ§alarÄ±nÄ± yÃ¶netmek iÃ§in farklÄ± "kutular" kullanÄ±lÄ±r. Ä°ÅŸte iki yaygÄ±n senaryonun basitleÅŸtirilmiÅŸ bir aÃ§Ä±klamasÄ±: sÄ±ralanmamÄ±ÅŸ kutular ve hÄ±zlÄ± kutular.

### SÄ±ralanmamÄ±ÅŸ Kutular

HÄ±zlÄ± bir parÃ§a olmayan bir bellek parÃ§asÄ±nÄ± serbest bÄ±raktÄ±ÄŸÄ±nÄ±zda, bu sÄ±ralanmamÄ±ÅŸ kutuya gider. Bu kutu, yeni serbest bÄ±rakÄ±lan parÃ§alarÄ±n Ã¶n tarafa (baÅŸ) eklendiÄŸi bir liste gibi davranÄ±r. Yeni bir bellek parÃ§asÄ± talep ettiÄŸinizde, allocator sÄ±ralanmamÄ±ÅŸ kutuya arka taraftan (kuyruk) bakarak yeterince bÃ¼yÃ¼k bir parÃ§a bulur. EÄŸer sÄ±ralanmamÄ±ÅŸ kutudan bir parÃ§a, ihtiyacÄ±nÄ±z olandan bÃ¼yÃ¼kse, bu parÃ§a bÃ¶lÃ¼nÃ¼r; Ã¶n kÄ±sÄ±m geri dÃ¶ner ve kalan kÄ±sÄ±m kutuda kalÄ±r.

Ã–rnek:

- 300 bayt (`a`) ayÄ±rÄ±rsÄ±nÄ±z, sonra 250 bayt (`b`), ardÄ±ndan `a`yÄ± serbest bÄ±rakÄ±r ve tekrar 250 bayt (`c`) talep edersiniz.
- `a`yÄ± serbest bÄ±raktÄ±ÄŸÄ±nÄ±zda, bu sÄ±ralanmamÄ±ÅŸ kutuya gider.
- EÄŸer tekrar 250 bayt talep ederseniz, allocator `a`yÄ± kuyrukta bulur ve onu bÃ¶ler, talebinize uyan kÄ±smÄ± geri dÃ¶ner ve geri kalanÄ±nÄ± kutuda tutar.
- `c`, Ã¶nceki `a`ya iÅŸaret edecek ve `a`nÄ±n iÃ§eriÄŸi ile doldurulacaktÄ±r.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins, kÃ¼Ã§Ã¼k bellek parÃ§alarÄ± iÃ§in kullanÄ±lÄ±r. SÄ±ralanmamÄ±ÅŸ kutularÄ±n aksine, fastbins yeni parÃ§alarÄ± baÅŸa ekler ve son giren ilk Ã§Ä±kar (LIFO) davranÄ±ÅŸÄ± oluÅŸturur. KÃ¼Ã§Ã¼k bir bellek parÃ§asÄ± talep ederseniz, allocator fastbin'in baÅŸÄ±ndan alÄ±r.

Ã–rnek:
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
---
### ğŸ”¥ Modern glibc dikkate alÄ±ndÄ±ÄŸÄ±nda (tcache â‰¥ 2.26)

glibc 2.26'dan itibaren her bir thread kendi **tcache**'ini *unsorted bin*'den *Ã¶nce* sorgular. Bu nedenle bir first-fit senaryosu **yalnÄ±zca** aÅŸaÄŸÄ±daki durumlarda **ulaÅŸÄ±labilir**:

1. Ä°stenen boyut **`tcache_max`'dan daha bÃ¼yÃ¼kse** (64-bit'te varsayÄ±lan olarak 0x420), *veya*
2. Ä°lgili tcache bin **zaten dolu veya manuel olarak boÅŸaltÄ±lmÄ±ÅŸsa** (7 eleman tahsis edilip kullanÄ±lÄ±rken tutulduÄŸunda).

GerÃ§ek istismarlarÄ±nÄ±zda genellikle ÅŸu ÅŸekilde bir yardÄ±mcÄ± rutin ekleyeceksiniz:
```c
// Drain the tcache for a given size
for(int i = 0; i < 7; i++) pool[i] = malloc(0x100);
for(int i = 0; i < 7; i++) free(pool[i]);
```
Bir kez tcache tÃ¼kenirse, sonraki serbest bÄ±rakmalar sÄ±ralanmamÄ±ÅŸ kutuya gider ve klasik ilk uygun davranÄ±ÅŸ (kuyruk aramasÄ±, baÅŸa ekleme) tekrar tetiklenebilir.

---
### ğŸš© Ä°lk uygun ile Ã¼st Ã¼ste binen parÃ§a UAF oluÅŸturma

AÅŸaÄŸÄ±daki parÃ§a (glibc 2.38 Ã¼zerinde test edilmiÅŸtir) sÄ±ralanmamÄ±ÅŸ kutudaki bÃ¶lÃ¼cÃ¼nÃ¼n nasÄ±l kÃ¶tÃ¼ye kullanÄ±labileceÄŸini gÃ¶sterir ve 2 **Ã¼st Ã¼ste binen iÅŸaretÃ§i** oluÅŸturur - tek bir serbest bÄ±rakmayÄ± yazma-sonrasÄ± serbest bÄ±rakmaya dÃ¶nÃ¼ÅŸtÃ¼ren gÃ¼Ã§lÃ¼ bir ilke.
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(){
setbuf(stdout, NULL);

/* 1. prepare 2 adjacent chunks and free the first one */
char *A = malloc(0x420);   // big enough to bypass tcache
char *B = malloc(0x420);
strcpy(A, "AAAA\n");
free(A);                   // A â†’ unsorted

/* 2. request a *smaller* size to force a split of A */
char *C = malloc(0x400);   // returns lower half of former A

/* 3. The remainder of A is still in the unsorted bin.
Another 0x400-byte malloc will now return the *same*
region pointed to by B â€“ creating a UAF/overlap. */
char *C2 = malloc(0x400);

printf("B  = %p\nC2 = %p (overlaps B)\n", B, C2);

// Arbitrary write in B is immediately visible via C2
memset(B, 'X', 0x10);
fwrite(C2, 1, 0x10, stdout);  // prints Xs
}
```
Exploitation recipe (common in recent CTFs):

1. **Hedef boyut iÃ§in** tcache'i boÅŸaltÄ±n.
2. **Bir parÃ§a serbest bÄ±rakÄ±n** bÃ¶ylece sÄ±ralanmamÄ±ÅŸ kutuya dÃ¼ÅŸer.
3. **Biraz daha kÃ¼Ã§Ã¼k bir boyut ayÄ±rÄ±n** â€“ allocator sÄ±ralanmamÄ±ÅŸ parÃ§ayÄ± bÃ¶ler.
4. **Tekrar ayÄ±rÄ±n** â€“ kalan kÄ±sÄ±m mevcut bir kullanÄ±mda olan parÃ§a ile Ã¶rtÃ¼ÅŸÃ¼r â†’ UAF.
5. Hassas alanlarÄ± (fonksiyon iÅŸaretÃ§ileri, FILE vtable, vb.) Ã¼zerine yazÄ±n.

Pratik bir uygulama, bu tam ilkenin `__free_hook` Ã¼zerinde tam kontrol saÄŸlamak iÃ§in UAF'den geÃ§iÅŸ yapmak iÃ§in kullanÄ±ldÄ±ÄŸÄ± 2024 HITCON Quals *Setjmp* zorluÄŸunda bulunabilir.{{#ref}}
../../../../references/2024_setjmp_firstfit.md
{{#endref}}

---
### ğŸ›¡ï¸  Ã–nlemler & SertleÅŸtirme

* **GÃ¼venli baÄŸlantÄ± (glibc â‰¥ 2.32)** yalnÄ±zca tek baÄŸlÄ± *tcache*/**fastbin** listelerini korur. SÄ±ralanmamÄ±ÅŸ/kÃ¼Ã§Ã¼k/bÃ¼yÃ¼k kutular hala ham iÅŸaretÃ§ileri saklar, bu nedenle bir heap leak elde edebilirseniz, ilk uygun tabanlÄ± Ã¶rtÃ¼ÅŸmeler geÃ§erliliÄŸini korur.
* **Heap iÅŸaretÃ§i ÅŸifreleme & MTE** (ARM64) henÃ¼z x86-64 glibc'yi etkilemiyor, ancak `GLIBC_TUNABLES=glibc.malloc.check=3` gibi daÄŸÄ±tÄ±m sertleÅŸtirme bayraklarÄ± tutarsÄ±z meta verilerde abort yapar ve naif PoC'leri bozabilir.
* **Serbest bÄ±rakÄ±ldÄ±ÄŸÄ±nda tcache doldurma** (2024'te glibc 2.41 iÃ§in Ã¶nerildi) sÄ±ralanmamÄ±ÅŸ kullanÄ±mÄ± daha da azaltÄ±r; genel exploitler geliÅŸtirirken gelecekteki sÃ¼rÃ¼mleri izleyin.

---
## DiÄŸer Referanslar & Ã–rnekler

- [**https://heap-exploitation.dhavalkapil.com/attacks/first_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first_fit)
- [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
- ARM64. KullanÄ±mdan sonra: Bir kullanÄ±cÄ± nesnesi oluÅŸturun, serbest bÄ±rakÄ±n, serbest bÄ±rakÄ±lan parÃ§ayÄ± alan bir nesne oluÅŸturun ve buna yazma izni verin, **Ã¶nceki nesneden user->password konumunu Ã¼zerine yazÄ±n**. KullanÄ±cÄ±yÄ± **ÅŸifre kontrolÃ¼nÃ¼ atlamak iÃ§in yeniden kullanÄ±n**.
- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example)
- Program notlar oluÅŸturulmasÄ±na izin verir. Bir not, bir iÅŸlevi Ã§aÄŸÄ±rabilecek bir iÅŸlev iÅŸaretÃ§isine sahip bir malloc(8) iÃ§inde not bilgilerini ve notun iÃ§eriÄŸi ile baÅŸka bir malloc(<boyut>) iÃ§in bir iÅŸaretÃ§i iÃ§erecektir.
- SaldÄ±rÄ±, not bilgisi boyutundan daha bÃ¼yÃ¼k malloc iÃ§eriklerine sahip 2 not (note0 ve note1) oluÅŸturmak ve ardÄ±ndan bunlarÄ± serbest bÄ±rakmak olacaktÄ±r, bÃ¶ylece hÄ±zlÄ± kutuya (veya tcache'e) gireceklerdir.
- Daha sonra, iÃ§erik boyutu 8 olan baÅŸka bir not (note2) oluÅŸturun. Ä°Ã§erik, not1'de olacak Ã§Ã¼nkÃ¼ parÃ§a yeniden kullanÄ±lacak, burada iÅŸlev iÅŸaretÃ§isini kazanan iÅŸlevine iÅŸaret edecek ÅŸekilde deÄŸiÅŸtirebiliriz ve ardÄ±ndan Not1'i KullanÄ±mdan Sonra serbest bÄ±rakÄ±p yeni iÅŸlev iÅŸaretÃ§isini Ã§aÄŸÄ±rabiliriz.
- [**https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html)
- BazÄ± bellek ayÄ±rmak, istenen deÄŸeri yazmak, serbest bÄ±rakmak, yeniden ayÄ±rmak ve Ã¶nceki veriler hala orada olduÄŸundan, yeni beklenen yapÄ± ile parÃ§anÄ±n iÃ§inde iÅŸlenmesi mÃ¼mkÃ¼n hale gelir, bu da deÄŸeri ayarlamayÄ± veya bayraÄŸÄ± almayÄ± mÃ¼mkÃ¼n kÄ±lar.
- [**https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html)
- Bu durumda, belirli bir parÃ§anÄ±n iÃ§ine 4 yazmak gereklidir, bu da ilk tahsis edilen parÃ§adÄ±r (hepsini zorla serbest bÄ±raktÄ±ktan sonra bile). Her yeni tahsis edilen parÃ§anÄ±n dizideki numarasÄ± saklanÄ±r. ArdÄ±ndan, 4 parÃ§a (+ baÅŸlangÄ±Ã§ta tahsis edilen) ayÄ±rÄ±n, sonuncusu iÃ§inde 4 olacak, bunlarÄ± serbest bÄ±rakÄ±n ve ilk parÃ§anÄ±n yeniden tahsis edilmesini zorlayÄ±n, bu da son serbest bÄ±rakÄ±lan parÃ§ayÄ± kullanacaktÄ±r, bu da iÃ§inde 4 olan parÃ§adÄ±r.
- 2024 HITCON Quals Setjmp yazÄ±sÄ± (Quarkslab) â€“ pratik ilk uygun / sÄ±ralanmamÄ±ÅŸ-bÃ¶lme Ã¶rtÃ¼ÅŸme saldÄ±rÄ±sÄ±: <https://ctftime.org/writeup/39355>
- Angstrom CTF 2024 *heapify* yazÄ±sÄ± â€“ sÄ±ralanmamÄ±ÅŸ kutu bÃ¶lme istismar ederek libc'yi sÄ±zdÄ±rma ve Ã¶rtÃ¼ÅŸme saÄŸlama: <https://hackmd.io/@aneii11/H1S2snV40>

{{#include ../../../banners/hacktricks-training.md}}
