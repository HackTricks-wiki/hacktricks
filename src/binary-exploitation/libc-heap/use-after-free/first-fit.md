# First Fit

{{#include ../../../banners/hacktricks-training.md}}

## **First Fit**

рдЬрдм рдЖрдк glibc рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░рдХреЗ рдХрд┐рд╕реА рдкреНрд░реЛрдЧреНрд░рд╛рдо рдореЗрдВ рдореЗрдореЛрд░реА рдХреЛ рдлреНрд░реА рдХрд░рддреЗ рд╣реИрдВ, рддреЛ рдореЗрдореЛрд░реА рдХреЗ рдЯреБрдХрдбрд╝реЛрдВ рдХреЛ рдкреНрд░рдмрдВрдзрд┐рдд рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рд╡рд┐рднрд┐рдиреНрди "рдмрд┐рди" рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд┐рдпрд╛ рдЬрд╛рддрд╛ рд╣реИред рдпрд╣рд╛рдБ рджреЛ рд╕рд╛рдорд╛рдиреНрдп рдкрд░рд┐рджреГрд╢реНрдпреЛрдВ рдХрд╛ рдПрдХ рд╕рд░рд▓ рд╕реНрдкрд╖реНрдЯреАрдХрд░рдг рд╣реИ: рдЕрдирд╕реЙрд░реНрдЯреЗрдб рдмрд┐рди рдФрд░ рдлрд╛рд╕реНрдЯрдмрд┐рдиред

### Unsorted Bins

рдЬрдм рдЖрдк рдПрдХ рдореЗрдореЛрд░реА рдЯреБрдХрдбрд╝рд╛ рдлреНрд░реА рдХрд░рддреЗ рд╣реИрдВ рдЬреЛ рдПрдХ рдлрд╛рд╕реНрдЯ рдЯреБрдХрдбрд╝рд╛ рдирд╣реАрдВ рд╣реИ, рддреЛ рдпрд╣ рдЕрдирд╕реЙрд░реНрдЯреЗрдб рдмрд┐рди рдореЗрдВ рдЪрд▓рд╛ рдЬрд╛рддрд╛ рд╣реИред рдпрд╣ рдмрд┐рди рдПрдХ рд╕реВрдЪреА рдХреА рддрд░рд╣ рдХрд╛рд░реНрдп рдХрд░рддрд╛ рд╣реИ рдЬрд╣рд╛рдБ рдирдП рдлреНрд░реА рдХрд┐рдП рдЧрдП рдЯреБрдХрдбрд╝реЗ рд╕рд╛рдордиреЗ ( "рд╣реЗрдб") рдореЗрдВ рдЬреЛрдбрд╝реЗ рдЬрд╛рддреЗ рд╣реИрдВред рдЬрдм рдЖрдк рдореЗрдореЛрд░реА рдХрд╛ рдПрдХ рдирдпрд╛ рдЯреБрдХрдбрд╝рд╛ рдорд╛рдВрдЧрддреЗ рд╣реИрдВ, рддреЛ рдЖрд╡рдВрдЯрдХ рдЕрдирд╕реЙрд░реНрдЯреЗрдб рдмрд┐рди рдХреЛ рдкреАрдЫреЗ ( "рдЯреЗрд▓") рд╕реЗ рджреЗрдЦрддрд╛ рд╣реИ рддрд╛рдХрд┐ рдПрдХ рдРрд╕рд╛ рдЯреБрдХрдбрд╝рд╛ рдвреВрдВрдв рд╕рдХреЗ рдЬреЛ рдЖрдкрдХреЗ рд▓рд┐рдП рдкрд░реНрдпрд╛рдкреНрдд рдмрдбрд╝рд╛ рд╣реЛред рдпрджрд┐ рдЕрдирд╕реЙрд░реНрдЯреЗрдб рдмрд┐рди рд╕реЗ рдХреЛрдИ рдЯреБрдХрдбрд╝рд╛ рдЖрдкрдХреЗ рдЖрд╡рд╢реНрдпрдХ рдЖрдХрд╛рд░ рд╕реЗ рдмрдбрд╝рд╛ рд╣реИ, рддреЛ рдЗрд╕реЗ рд╡рд┐рднрд╛рдЬрд┐рдд рдХрд┐рдпрд╛ рдЬрд╛рддрд╛ рд╣реИ, рдЬрд┐рд╕рдореЗрдВ рд╕рд╛рдордиреЗ рдХрд╛ рднрд╛рдЧ рд╡рд╛рдкрд╕ рдХрд┐рдпрд╛ рдЬрд╛рддрд╛ рд╣реИ рдФрд░ рд╢реЗрд╖ рднрд╛рдЧ рдмрд┐рди рдореЗрдВ рд░рд╣рддрд╛ рд╣реИред

рдЙрджрд╛рд╣рд░рдг:

- рдЖрдк 300 рдмрд╛рдЗрдЯ (`a`) рдЖрд╡рдВрдЯрд┐рдд рдХрд░рддреЗ рд╣реИрдВ, рдлрд┐рд░ 250 рдмрд╛рдЗрдЯ (`b`), рдлрд┐рд░ `a` рдХреЛ рдлреНрд░реА рдХрд░рддреЗ рд╣реИрдВ рдФрд░ рдлрд┐рд░ рд╕реЗ 250 рдмрд╛рдЗрдЯ (`c`) рдорд╛рдВрдЧрддреЗ рд╣реИрдВред
- рдЬрдм рдЖрдк `a` рдХреЛ рдлреНрд░реА рдХрд░рддреЗ рд╣реИрдВ, рддреЛ рдпрд╣ рдЕрдирд╕реЙрд░реНрдЯреЗрдб рдмрд┐рди рдореЗрдВ рдЪрд▓рд╛ рдЬрд╛рддрд╛ рд╣реИред
- рдпрджрд┐ рдЖрдк рдлрд┐рд░ рд╕реЗ 250 рдмрд╛рдЗрдЯ рдорд╛рдВрдЧрддреЗ рд╣реИрдВ, рддреЛ рдЖрд╡рдВрдЯрдХ `a` рдХреЛ рдЯреЗрд▓ рдореЗрдВ рдкрд╛рддрд╛ рд╣реИ рдФрд░ рдЗрд╕реЗ рд╡рд┐рднрд╛рдЬрд┐рдд рдХрд░рддрд╛ рд╣реИ, рдЖрдкрдХреЗ рдЕрдиреБрд░реЛрдз рдХреЗ рдЕрдиреБрд╕рд╛рд░ рдлрд┐рдЯ рд╣реЛрдиреЗ рд╡рд╛рд▓рд╛ рднрд╛рдЧ рд╡рд╛рдкрд╕ рдХрд░рддрд╛ рд╣реИ рдФрд░ рдмрд╛рдХреА рдХреЛ рдмрд┐рди рдореЗрдВ рд░рдЦрддрд╛ рд╣реИред
- `c` рдкрд┐рдЫрд▓реЗ `a` рдХреА рдУрд░ рдЗрд╢рд╛рд░рд╛ рдХрд░реЗрдЧрд╛ рдФрд░ `a` рдХреА рд╕рд╛рдордЧреНрд░реА рд╕реЗ рднрд░рд╛ рд╣реЛрдЧрд╛ред
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins рдЫреЛрдЯреЗ рдореЗрдореЛрд░реА рдЯреБрдХрдбрд╝реЛрдВ рдХреЗ рд▓рд┐рдП рдЙрдкрдпреЛрдЧ рдХрд┐рдП рдЬрд╛рддреЗ рд╣реИрдВред рдЕрд╕рдВрд░рдЪрд┐рдд рдмрд┐рди рдХреЗ рд╡рд┐рдкрд░реАрдд, рдлрд╛рд╕реНрдЯрдмрд┐рди рдирдП рдЯреБрдХрдбрд╝реЛрдВ рдХреЛ рд╕рд┐рд░ рдореЗрдВ рдЬреЛрдбрд╝рддреЗ рд╣реИрдВ, рдЬрд┐рд╕рд╕реЗ рдЕрдВрддрд┐рдо-рдореЗрдВ-рдкреНрд░рдердо-рдирд┐рдХрд╛рд▓рдиреЗ (LIFO) рд╡реНрдпрд╡рд╣рд╛рд░ рдЙрддреНрдкрдиреНрди рд╣реЛрддрд╛ рд╣реИред рдпрджрд┐ рдЖрдк рдореЗрдореЛрд░реА рдХрд╛ рдПрдХ рдЫреЛрдЯрд╛ рдЯреБрдХрдбрд╝рд╛ рдорд╛рдВрдЧрддреЗ рд╣реИрдВ, рддреЛ рдЖрд╡рдВрдЯрдХ рдлрд╛рд╕реНрдЯрдмрд┐рди рдХреЗ рд╕рд┐рд░ рд╕реЗ рдЦреАрдВрдЪреЗрдЧрд╛ред

Example:
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
---
### ЁЯФе рдЖрдзреБрдирд┐рдХ glibc рд╡рд┐рдЪрд╛рд░ (tcache тЙе 2.26)

glibc 2.26 рд╕реЗ рд╣рд░ рдереНрд░реЗрдб рдЕрдкрдиреА **tcache** рд░рдЦрддрд╛ рд╣реИ рдЬрд┐рд╕реЗ *unsorted bin* рд╕реЗ *рдкрд╣рд▓реЗ* рдХреНрд╡реЗрд░реА рдХрд┐рдпрд╛ рдЬрд╛рддрд╛ рд╣реИред рдЗрд╕рд▓рд┐рдП рдПрдХ first-fit рдкрд░рд┐рджреГрд╢реНрдп **рддрдм рд╣реА рдкреНрд░рд╛рдкреНрдд рд╣реЛрдЧрд╛ рдпрджрд┐**:

1. рдЕрдиреБрд░реЛрдзрд┐рдд рдЖрдХрд╛рд░ **`tcache_max`** (рдбрд┐рдлрд╝реЙрд▓реНрдЯ рд░реВрдк рд╕реЗ 64-рдмрд┐рдЯ рдкрд░ 0x420) рд╕реЗ **рдмрдбрд╝рд╛ рд╣реИ**, *рдпрд╛*
2. рд╕рдВрдмрдВрдзрд┐рдд tcache рдмрд┐рди **рдкрд╣рд▓реЗ рд╕реЗ рд╣реА рднрд░рд╛ рд╣реБрдЖ рд╣реИ рдпрд╛ рдореИрдиреНрдпреБрдЕрд▓ рд░реВрдк рд╕реЗ рдЦрд╛рд▓реА рдХрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИ** (7 рддрддреНрд╡реЛрдВ рдХреЛ рдЖрд╡рдВрдЯрд┐рдд рдХрд░рдХреЗ рдФрд░ рдЙрдиреНрд╣реЗрдВ рдЙрдкрдпреЛрдЧ рдореЗрдВ рд░рдЦрдХрд░)ред

рд╡рд╛рд╕реНрддрд╡рд┐рдХ рд╣рдорд▓реЛрдВ рдореЗрдВ рдЖрдк рдЖрдорддреМрд░ рдкрд░ рдПрдХ рд╕рд╣рд╛рдпрдХ рд░реВрдЯреАрди рдЬреЛрдбрд╝реЗрдВрдЧреЗ рдЬреИрд╕реЗ:
```c
// Drain the tcache for a given size
for(int i = 0; i < 7; i++) pool[i] = malloc(0x100);
for(int i = 0; i < 7; i++) free(pool[i]);
```
рдПрдХ рдмрд╛рд░ рдЬрдм tcache рд╕рдорд╛рдкреНрдд рд╣реЛ рдЬрд╛рддрд╛ рд╣реИ, рддреЛ рдмрд╛рдж рдореЗрдВ рдХреА рдЧрдИ frees рдЕрдирд╕реЙрд░реНрдЯреЗрдб рдмрд┐рди рдореЗрдВ рдЬрд╛рддреА рд╣реИрдВ рдФрд░ рдХреНрд▓рд╛рд╕рд┐рдХ рдлрд░реНрд╕реНрдЯ-рдлрд┐рдЯ рд╡реНрдпрд╡рд╣рд╛рд░ (рдЯреЗрд▓ рд╕рд░реНрдЪ, рд╣реЗрдб рдЗрдВрд╕рд░реНрд╢рди) рдлрд┐рд░ рд╕реЗ рд╕рдХреНрд░рд┐рдп рдХрд┐рдпрд╛ рдЬрд╛ рд╕рдХрддрд╛ рд╣реИред

---
### ЁЯЪй рдкрд╣рд▓реЗ-рдлрд┐рдЯ рдХреЗ рд╕рд╛рде рдУрд╡рд░рд▓реИрдкрд┐рдВрдЧ-рдЪрдВрдХ UAF рдмрдирд╛рдирд╛

рдиреАрдЪреЗ рджрд┐рдпрд╛ рдЧрдпрд╛ рдЕрдВрд╢ (glibc 2.38 рдкрд░ рдкрд░реАрдХреНрд╖рдг рдХрд┐рдпрд╛ рдЧрдпрд╛) рджрд┐рдЦрд╛рддрд╛ рд╣реИ рдХрд┐ рдЕрдирд╕реЙрд░реНрдЯреЗрдб рдмрд┐рди рдореЗрдВ рд╕реНрдкреНрд▓рд┐рдЯрд░ рдХрд╛ рджреБрд░реБрдкрдпреЛрдЧ рдХреИрд╕реЗ рдХрд┐рдпрд╛ рдЬрд╛ рд╕рдХрддрд╛ рд╣реИ рддрд╛рдХрд┐ 2 **рдУрд╡рд░рд▓реИрдкрд┐рдВрдЧ рдкреЙрдЗрдВрдЯрд░реНрд╕** рдмрдирд╛рдП рдЬрд╛ рд╕рдХреЗрдВ - рдПрдХ рд╢рдХреНрддрд┐рд╢рд╛рд▓реА рдкреНрд░рд╛рдЗрдорд┐рдЯрд┐рд╡ рдЬреЛ рдПрдХрд▓ рдлреНрд░реА рдХреЛ рд░рд╛рдЗрдЯ-рдЖрдлреНрдЯрд░-рдлреНрд░реА рдореЗрдВ рдкрд░рд┐рд╡рд░реНрддрд┐рдд рдХрд░рддрд╛ рд╣реИред
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(){
setbuf(stdout, NULL);

/* 1. prepare 2 adjacent chunks and free the first one */
char *A = malloc(0x420);   // big enough to bypass tcache
char *B = malloc(0x420);
strcpy(A, "AAAA\n");
free(A);                   // A тЖТ unsorted

/* 2. request a *smaller* size to force a split of A */
char *C = malloc(0x400);   // returns lower half of former A

/* 3. The remainder of A is still in the unsorted bin.
Another 0x400-byte malloc will now return the *same*
region pointed to by B тАУ creating a UAF/overlap. */
char *C2 = malloc(0x400);

printf("B  = %p\nC2 = %p (overlaps B)\n", B, C2);

// Arbitrary write in B is immediately visible via C2
memset(B, 'X', 0x10);
fwrite(C2, 1, 0x10, stdout);  // prints Xs
}
```
Exploitation recipe (common in recent CTFs):

1. **Drain** the tcache for the target size.
2. **Free** a chunk so it lands in the unsorted bin.
3. **Allocate** a slightly smaller size тАУ the allocator splits the unsorted chunk.
4. **Allocate** again тАУ the leftover part overlaps with an existing in-use chunk тЖТ UAF.
5. Overwrite sensitive fields (function pointers, FILE vtable, etc.)

A practical application can be found in the 2024 HITCON Quals *Setjmp* challenge where this exact primitive is used to pivot from a UAF to full control of `__free_hook`.{{#ref}}
../../../../references/2024_setjmp_firstfit.md
{{#endref}}

---
### ЁЯЫбя╕П  Mitigations & Hardening

* **Safe-linking (glibc тЙе 2.32)** рдХреЗрд╡рд▓ рдПрдХрд▓-рд▓рд┐рдВрдХреНрдб *tcache*/**fastbin** рд╕реВрдЪрд┐рдпреЛрдВ рдХреА рд╕реБрд░рдХреНрд╖рд╛ рдХрд░рддрд╛ рд╣реИред  рдЕрд╕рдВрд░рдЪрд┐рдд/рдЫреЛрдЯреЗ/рдмрдбрд╝реЗ рдмрд┐рди рдЕрднреА рднреА рдХрдЪреНрдЪреЗ рдкреЙрдЗрдВрдЯрд░реНрд╕ рдХреЛ рд╕рдВрдЧреНрд░рд╣реАрдд рдХрд░рддреЗ рд╣реИрдВ, рдЗрд╕рд▓рд┐рдП рдкрд╣рд▓реЗ-рдлрд┐рдЯ рдЖрдзрд╛рд░рд┐рдд рдУрд╡рд░рд▓реИрдк рддрдм рднреА рд╕рдВрднрд╡ рд╣реИрдВ рдпрджрд┐ рдЖрдк рдПрдХ рд╣реАрдк рд▓реАрдХ рдкреНрд░рд╛рдкреНрдд рдХрд░ рд╕рдХрддреЗ рд╣реИрдВред
* **Heap pointer encryption & MTE** (ARM64) рдЕрднреА рддрдХ x86-64 glibc рдХреЛ рдкреНрд░рднрд╛рд╡рд┐рдд рдирд╣реАрдВ рдХрд░рддреЗ рд╣реИрдВ, рд▓реЗрдХрд┐рди рд╡рд┐рддрд░рдг рд╣рд╛рд░реНрдбрдирд┐рдВрдЧ рдлреНрд▓реИрдЧ рдЬреИрд╕реЗ `GLIBC_TUNABLES=glibc.malloc.check=3` рдЕрд╕рдВрдЧрдд рдореЗрдЯрд╛рдбреЗрдЯрд╛ рдкрд░ abort рдХрд░реЗрдВрдЧреЗ рдФрд░ na├пve PoCs рдХреЛ рддреЛрдбрд╝ рд╕рдХрддреЗ рд╣реИрдВред
* **Filling tcache on free** (2024 рдореЗрдВ glibc 2.41 рдХреЗ рд▓рд┐рдП рдкреНрд░рд╕реНрддрд╛рд╡рд┐рдд) рдЕрд╕рдВрд░рдЪрд┐рдд рдЙрдкрдпреЛрдЧ рдХреЛ рдФрд░ рдХрдо рдХрд░реЗрдЧрд╛; рд╕рд╛рдорд╛рдиреНрдп рдПрдХреНрд╕рдкреНрд▓реЙрдЗрдЯ рд╡рд┐рдХрд╕рд┐рдд рдХрд░рддреЗ рд╕рдордп рднрд╡рд┐рд╖реНрдп рдХреЗ рд░рд┐рд▓реАрдЬрд╝ рдХреА рдирд┐рдЧрд░рд╛рдиреА рдХрд░реЗрдВред

---
## Other References & Examples

- [**https://heap-exploitation.dhavalkapil.com/attacks/first_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first_fit)
- [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
- ARM64. Use after free: Generate an user object, free it, generate an object that gets the freed chunk and allow to write to it, **overwriting the position of user->password** from the previous one. Reuse the user to **bypass the password check**
- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example)
- The program allows to create notes. A note will have the note info in a malloc(8) (with a pointer to a function that could be called) and a pointer to another malloc(<size>) with the contents of the note.
- The attack would be to create 2 notes (note0 and note1) with bigger malloc contents than the note info size and then free them so they get into the fast bin (or tcache).
- Then, create another note (note2) with content size 8. The content is going to be in note1 as the chunk is going to be reused, were we could modify the function pointer to point to the win function and then Use-After-Free the note1 to call the new function pointer.
- [**https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html)
- It's possible to alloc some memory, write the desired value, free it, realloc it and as the previous data is still there, it will treated according the new expected struct in the chunk making possible to set the value ot get the flag.
- [**https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html)
- In this case it's needed to write 4 inside an specific chunk which is the first one being allocated (even after force freeing all of them). On each new allocated chunk it's number in the array index is stored. Then, allocate 4 chunks (+ the initialy allocated), the last one will have 4 inside of it, free them and force the reallocation of the first one, which will use the last chunk freed which is the one with 4 inside of it.
- 2024 HITCON Quals Setjmp write-up (Quarkslab) тАУ practical first-fit / unsorted-split overlap attack: <https://ctftime.org/writeup/39355>
- Angstrom CTF 2024 *heapify* write-up тАУ abusing unsorted-bin splitting to leak libc and gain overlap: <https://hackmd.io/@aneii11/H1S2snV40>

{{#include ../../../banners/hacktricks-training.md}}
