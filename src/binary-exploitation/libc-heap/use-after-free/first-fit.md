# First Fit

{{#include ../../../banners/hacktricks-training.md}}

## **First Fit**

Wanneer jy geheue in 'n program met glibc vrymaak, word verskillende "bins" gebruik om die geheue stukke te bestuur. Hier is 'n vereenvoudigde verduideliking van twee algemene scenario's: ongesorteerde bins en vinnige bins.

### Ongesorteerde Bins

Wanneer jy 'n geheue stuk vrymaak wat nie 'n vinnige stuk is nie, gaan dit na die ongesorteerde bin. Hierdie bin funksioneer soos 'n lys waar nuwe vrygemaakte stukke aan die voorkant (die "kop") bygevoeg word. Wanneer jy 'n nuwe stuk geheue aan vra, kyk die toewysingsprogram na die ongesorteerde bin vanaf die agterkant (die "stert") om 'n stuk te vind wat groot genoeg is. As 'n stuk uit die ongesorteerde bin groter is as wat jy nodig het, word dit gesplit, met die voorste deel wat teruggegee word en die oorblywende deel wat in die bin bly.

Voorbeeld:

- Jy toewys 300 bytes (`a`), dan 250 bytes (`b`), vrymaak `a` en vra weer 250 bytes (`c`).
- Wanneer jy `a` vrymaak, gaan dit na die ongesorteerde bin.
- As jy dan weer 250 bytes vra, vind die toewysingsprogram `a` by die stert en split dit, terwyl die deel wat by jou versoek pas, teruggegee word en die res in die bin bly.
- `c` sal na die vorige `a` wys en met die `a's` gevul wees.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins word gebruik vir klein geheue stukke. Anders as ongesorteerde bins, voeg fastbins nuwe stukke by die kop, wat 'n laaste-in-eerste-uit (LIFO) gedrag skep. As jy 'n klein stuk geheue aan vra, sal die toewysingsprogram van die fastbin se kop trek.

Voorbeeld:

- Jy toewys vier stukke van 20 bytes elk (`a`, `b`, `c`, `d`).
- Wanneer jy hulle in enige volgorde vrylaat, word die vrygestelde stukke by die fastbin se kop gevoeg.
- As jy dan 'n 20-byte stuk aan vra, sal die toewysingsprogram die mees onlangs vrygestelde stuk van die kop van die fastbin teruggee.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Ander Verwysings & Voorbeelde

- [**https://heap-exploitation.dhavalkapil.com/attacks/first_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first_fit)
- [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
- ARM64. Gebruik na vry: Genereer 'n gebruikersobjek, vry dit, genereer 'n objek wat die vrygestelde stuk ontvang en laat dit toe om na te skryf, **oorwrite die posisie van user->password** van die vorige een. Hergebruik die gebruiker om **die wagwoordkontrole te omseil**
- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example)
- Die program laat toe om notas te skep. 'n Nota sal die nota-inligting in 'n malloc(8) hê (met 'n pointeur na 'n funksie wat geroep kan word) en 'n pointeur na 'n ander malloc(\<size>) met die inhoud van die nota.
- Die aanval sou wees om 2 notas (nota0 en nota1) te skep met groter malloc-inhoud as die nota-inligting grootte en dan hulle vry te stel sodat hulle in die vinnige bin (of tcache) kom.
- Dan, skep 'n ander nota (nota2) met inhoudsgrootte 8. Die inhoud gaan in nota1 wees aangesien die stuk hergebruik gaan word, waar ons die funksiepointeur kan verander om na die wen-funksie te wys en dan Gebruik-Na-Vry die nota1 om die nuwe funksiepointeur aan te roep.
- [**https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html)
- Dit is moontlik om 'n bietjie geheue toe te ken, die verlangde waarde te skryf, dit vry te stel, dit weer toe te ken en aangesien die vorige data steeds daar is, sal dit behandel word volgens die nuwe verwagte struktuur in die stuk wat dit moontlik maak om die waarde te stel om die vlag te kry.
- [**https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html)
- In hierdie geval is dit nodig om 4 binne 'n spesifieke stuk te skryf wat die eerste een is wat toegeken word (selfs nadat al hulle gedwing vrygestel is). Op elke nuwe toegeken stuk word sy nommer in die array-indeks gestoor. Dan, ken 4 stukke toe (+ die aanvanklik toegeken), die laaste een sal 4 daarin hê, vry hulle en dwing die hertoekenning van die eerste een, wat die laaste vrygestelde stuk sal gebruik wat die een met 4 daarin is.
