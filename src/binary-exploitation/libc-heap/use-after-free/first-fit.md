# First Fit

{{#include ../../../banners/hacktricks-training.md}}

## **First Fit**

Kada oslobodite memoriju u programu koristeÄ‡i glibc, razliÄiti "bins" se koriste za upravljanje delovima memorije. Evo pojednostavljenog objaÅ¡njenja dva uobiÄajena scenarija: nesortirani bins i fastbins.

### Nesortirani Bins

Kada oslobodite deo memorije koji nije brzi deo, on ide u nesortirani bin. Ovaj bin deluje kao lista gde se novi osloboÄ‘eni delovi dodaju na poÄetak (na "glavu"). Kada zatraÅ¾ite novi deo memorije, alokator gleda nesortirani bin od pozadi (na "rep") da pronaÄ‘e deo koji je dovoljno velik. Ako je deo iz nesortiranog bina veÄ‡i od onoga Å¡to vam treba, on se deli, pri Äemu se prednji deo vraÄ‡a, a preostali deo ostaje u binu.

Primer:

- Alocirate 300 bajtova (`a`), zatim 250 bajtova (`b`), zatim oslobodite `a` i ponovo zatraÅ¾ite 250 bajtova (`c`).
- Kada oslobodite `a`, on ide u nesortirani bin.
- Ako zatim ponovo zatraÅ¾ite 250 bajtova, alokator pronalazi `a` na repu i deli ga, vraÄ‡ajuÄ‡i deo koji odgovara vaÅ¡em zahtevu i zadrÅ¾avajuÄ‡i ostatak u binu.
- `c` Ä‡e pokazivati na prethodni `a` i biti ispunjen sadrÅ¾ajem `a`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins se koriste za male delove memorije. Za razliku od nesortiranih binova, fastbins dodaju nove delove na poÄetak, stvarajuÄ‡i ponaÅ¡anje poslednji ulaz-prvi izlaz (LIFO). Ako zatraÅ¾ite mali deo memorije, alokator Ä‡e uzeti iz vrha fastbina.

Example:
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
---
### ğŸ”¥ Modern glibc razmatranja (tcache â‰¥ 2.26)

Od glibc 2.26 svaki nit Äuva svoj vlastiti **tcache** koji se pretraÅ¾uje *pre* nesortiranog bin-a. Stoga Ä‡e se scenarij prvog pogodka **dostiÄ‡i samo ako**:

1. TraÅ¾ena veliÄina je **veÄ‡a od `tcache_max`** (0x420 na 64-bitnom sistemu po defaultu), *ili*
2. OdgovarajuÄ‡i tcache bin je **veÄ‡ pun ili ruÄno ispraznjen** (alokacijom 7 elemenata i njihovim zadrÅ¾avanjem u upotrebi).

U pravim eksploatacijama obiÄno Ä‡ete dodati pomoÄ‡nu rutinu kao Å¡to je:
```c
// Drain the tcache for a given size
for(int i = 0; i < 7; i++) pool[i] = malloc(0x100);
for(int i = 0; i < 7; i++) free(pool[i]);
```
Once the tcache is exhausted, subsequent frees go to the unsorted bin and classic first-fit behaviour (tail search, head insertion) can be triggered again.

---
### ğŸš© Kreiranje UAF-a sa preklapajuÄ‡im delovima koristeÄ‡i first-fit

The fragment below (tested on glibc 2.38) shows how the splitter in the unsorted bin can be abused to create 2 **overlapping pointers** â€“ a powerful primitive that converts a single free into a write-after-free.
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(){
setbuf(stdout, NULL);

/* 1. prepare 2 adjacent chunks and free the first one */
char *A = malloc(0x420);   // big enough to bypass tcache
char *B = malloc(0x420);
strcpy(A, "AAAA\n");
free(A);                   // A â†’ unsorted

/* 2. request a *smaller* size to force a split of A */
char *C = malloc(0x400);   // returns lower half of former A

/* 3. The remainder of A is still in the unsorted bin.
Another 0x400-byte malloc will now return the *same*
region pointed to by B â€“ creating a UAF/overlap. */
char *C2 = malloc(0x400);

printf("B  = %p\nC2 = %p (overlaps B)\n", B, C2);

// Arbitrary write in B is immediately visible via C2
memset(B, 'X', 0x10);
fwrite(C2, 1, 0x10, stdout);  // prints Xs
}
```
Exploitation recipe (common in recent CTFs):

1. **Isprazite** tcache za ciljani veliÄinu.
2. **Oslobodite** deo tako da zavrÅ¡i u nesortiranoj kanti.
3. **Alocirajte** malo manju veliÄinu â€“ alokator deli nesortirani deo.
4. **Alocirajte** ponovo â€“ preostali deo se preklapa sa postojeÄ‡im koriÅ¡Ä‡enim delom â†’ UAF.
5. PrepiÅ¡ite osetljive polja (pokazivaÄe na funkcije, FILE vtable, itd.)

PraktiÄna primena moÅ¾e se naÄ‡i u 2024 HITCON Quals *Setjmp* izazovu gde se ova taÄno primitivna tehnika koristi za prebacivanje sa UAF na punu kontrolu nad `__free_hook`.{{#ref}}
../../../../references/2024_setjmp_firstfit.md
{{#endref}}

---
### ğŸ›¡ï¸  MoguÄ‡nosti zaÅ¡tite i uÄvrÅ¡Ä‡ivanja

* **Sigurno povezivanje (glibc â‰¥ 2.32)** Å¡titi samo jednostruko povezane *tcache*/**fastbin** liste. Nesortirane/male/velike kante i dalje Äuvaju sirove pokazivaÄe, tako da preklapanja zasnovana na prvom odgovoru ostaju moguÄ‡a ako moÅ¾ete dobiti heap leak.
* **Enkripcija pokazivaÄa na heap i MTE** (ARM64) joÅ¡ uvek ne utiÄu na x86-64 glibc, ali oznake za uÄvrÅ¡Ä‡ivanje distribucije kao Å¡to su `GLIBC_TUNABLES=glibc.malloc.check=3` Ä‡e prekinuti rad na nekonzistentnim metapodacima i mogu prekinuti naivne PoC-ove.
* **Popunjavanje tcache prilikom oslobaÄ‘anja** (predloÅ¾eno 2024. za glibc 2.41) dodatno bi smanjilo koriÅ¡Ä‡enje nesortiranih; pratite buduÄ‡e verzije prilikom razvijanja generiÄkih eksploata.

---
## Ostale reference i primeri

- [**https://heap-exploitation.dhavalkapil.com/attacks/first_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first_fit)
- [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
- ARM64. Use after free: GeneriÅ¡ite korisniÄki objekat, oslobodite ga, generiÅ¡ite objekat koji dobija osloboÄ‘eni deo i omoguÄ‡ite pisanje u njega, **prepisujuÄ‡i poziciju user->password** iz prethodnog. Ponovo koristite korisnika da **obiÄ‘ete proveru lozinke**
- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example)
- Program omoguÄ‡ava kreiranje beleÅ¡ki. BeleÅ¡ka Ä‡e imati informacije o beleÅ¡ci u malloc(8) (sa pokazivaÄem na funkciju koja bi mogla biti pozvana) i pokazivaÄ na drugi malloc(<size>) sa sadrÅ¾ajem beleÅ¡ke.
- Napad bi bio da se kreiraju 2 beleÅ¡ke (note0 i note1) sa veÄ‡im malloc sadrÅ¾ajem od veliÄine informacija o beleÅ¡ci i zatim ih osloboditi kako bi uÅ¡le u brzu kantu (ili tcache).
- Zatim, kreirajte joÅ¡ jednu beleÅ¡ku (note2) sa veliÄinom sadrÅ¾aja 8. SadrÅ¾aj Ä‡e biti u note1 jer Ä‡e se deo ponovo koristiti, gde bismo mogli modifikovati pokazivaÄ na funkciju da pokazuje na win funkciju i zatim Use-After-Free note1 da pozovemo novi pokazivaÄ na funkciju.
- [**https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html)
- MoguÄ‡e je alocirati neku memoriju, napisati Å¾eljenu vrednost, osloboditi je, ponovo alocirati i poÅ¡to su prethodni podaci joÅ¡ uvek tu, biÄ‡e tretirani prema novoj oÄekivanoj strukturi u delu, Å¡to omoguÄ‡ava postavljanje vrednosti za dobijanje zastavice.
- [**https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html)
- U ovom sluÄaju potrebno je napisati 4 unutar specifiÄnog dela koji je prvi koji se alocira (Äak i nakon prisilnog oslobaÄ‘anja svih njih). Na svakom novom alociranom delu, njegov broj u indeksu niza se Äuva. Zatim, alocirajte 4 dela (+ inicijalno alocirani), poslednji Ä‡e imati 4 unutar njega, oslobodite ih i prisilite ponovnu alokaciju prvog, koji Ä‡e koristiti poslednji osloboÄ‘eni deo koji je onaj sa 4 unutar njega.
- 2024 HITCON Quals Setjmp izveÅ¡taj (Quarkslab) â€“ praktiÄan napad preklapanja prvog odgovora / nesortiranog dela: <https://ctftime.org/writeup/39355>
- Angstrom CTF 2024 *heapify* izveÅ¡taj â€“ zloupotreba deljenja nesortirane kante za curenje libc i dobijanje preklapanja: <https://hackmd.io/@aneii11/H1S2snV40>

{{#include ../../../banners/hacktricks-training.md}}
