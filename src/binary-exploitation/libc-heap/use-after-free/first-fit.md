# First Fit

{{#include ../../../banners/hacktricks-training.md}}

## **First Fit**

Kiedy zwalniasz pamiÄ™Ä‡ w programie uÅ¼ywajÄ…c glibc, rÃ³Å¼ne "kosze" sÄ… uÅ¼ywane do zarzÄ…dzania kawaÅ‚kami pamiÄ™ci. Oto uproszczone wyjaÅ›nienie dwÃ³ch powszechnych scenariuszy: kosze nieposortowane i fastbins.

### Unsorted Bins

Kiedy zwalniasz kawaÅ‚ek pamiÄ™ci, ktÃ³ry nie jest szybkim kawaÅ‚kiem, trafia on do kosza nieposortowanego. Ten kosz dziaÅ‚a jak lista, gdzie nowe zwolnione kawaÅ‚ki sÄ… dodawane na poczÄ…tku (do "gÅ‚owy"). Kiedy Å¼Ä…dasz nowego kawaÅ‚ka pamiÄ™ci, alokator przeszukuje kosz nieposortowany od tyÅ‚u (do "ogona"), aby znaleÅºÄ‡ kawaÅ‚ek wystarczajÄ…co duÅ¼y. JeÅ›li kawaÅ‚ek z kosza nieposortowanego jest wiÄ™kszy niÅ¼ potrzebujesz, zostaje podzielony, przy czym przednia czÄ™Å›Ä‡ jest zwracana, a pozostaÅ‚a czÄ™Å›Ä‡ pozostaje w koszu.

PrzykÅ‚ad:

- Alokujesz 300 bajtÃ³w (`a`), nastÄ™pnie 250 bajtÃ³w (`b`), potem zwalniasz `a` i ponownie Å¼Ä…dasz 250 bajtÃ³w (`c`).
- Kiedy zwalniasz `a`, trafia on do kosza nieposortowanego.
- JeÅ›li nastÄ™pnie ponownie zaÅ¼Ä…dzasz 250 bajtÃ³w, alokator znajduje `a` na ogonie i dzieli go, zwracajÄ…c czÄ™Å›Ä‡, ktÃ³ra pasuje do twojego Å¼Ä…dania, a resztÄ™ pozostawiajÄ…c w koszu.
- `c` bÄ™dzie wskazywaÄ‡ na poprzednie `a` i bÄ™dzie wypeÅ‚nione zawartoÅ›ciÄ… `a`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins sÄ… uÅ¼ywane do maÅ‚ych kawaÅ‚kÃ³w pamiÄ™ci. W przeciwieÅ„stwie do nieposortowanych binÃ³w, fastbins dodajÄ… nowe kawaÅ‚ki na poczÄ…tek, tworzÄ…c zachowanie last-in-first-out (LIFO). JeÅ›li poprosisz o maÅ‚y kawaÅ‚ek pamiÄ™ci, alokator pobierze z gÅ‚owy fastbina.

Example:
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
---
### ğŸ”¥ Nowoczesne rozwaÅ¼ania dotyczÄ…ce glibc (tcache â‰¥ 2.26)

Od glibc 2.26 kaÅ¼dy wÄ…tek przechowuje wÅ‚asny **tcache**, ktÃ³ry jest sprawdzany *przed* nieposortowanym koszem. Dlatego scenariusz first-fit **zostanie osiÄ…gniÄ™ty tylko jeÅ›li**:

1. Å»Ä…dany rozmiar jest **wiÄ™kszy niÅ¼ `tcache_max`** (domyÅ›lnie 0x420 na 64-bit), *lub*
2. Odpowiedni kosz tcache jest **juÅ¼ peÅ‚ny lub oprÃ³Å¼niony rÄ™cznie** (poprzez przydzielenie 7 elementÃ³w i utrzymanie ich w uÅ¼yciu).

W rzeczywistych exploitach zazwyczaj dodasz pomocniczÄ… rutynÄ™ takÄ… jak:
```c
// Drain the tcache for a given size
for(int i = 0; i < 7; i++) pool[i] = malloc(0x100);
for(int i = 0; i < 7; i++) free(pool[i]);
```
Gdy tcache jest wyczerpany, kolejne zwolnienia trafiajÄ… do nieposortowanego kosza, a klasyczne zachowanie first-fit (przeszukiwanie ogona, wstawianie na gÅ‚owÄ™) moÅ¼e byÄ‡ ponownie wywoÅ‚ane.

---
### ğŸš© Tworzenie UAF z nakÅ‚adajÄ…cymi siÄ™ kawaÅ‚kami za pomocÄ… first-fit

Fragment poniÅ¼ej (testowany na glibc 2.38) pokazuje, jak splitter w nieposortowanym koszu moÅ¼e byÄ‡ wykorzystany do stworzenia 2 **nakÅ‚adajÄ…cych siÄ™ wskaÅºnikÃ³w** â€“ potÄ™Å¼nego prymitywu, ktÃ³ry przeksztaÅ‚ca pojedyncze zwolnienie w zapis-po-zwolnieniu.
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(){
setbuf(stdout, NULL);

/* 1. prepare 2 adjacent chunks and free the first one */
char *A = malloc(0x420);   // big enough to bypass tcache
char *B = malloc(0x420);
strcpy(A, "AAAA\n");
free(A);                   // A â†’ unsorted

/* 2. request a *smaller* size to force a split of A */
char *C = malloc(0x400);   // returns lower half of former A

/* 3. The remainder of A is still in the unsorted bin.
Another 0x400-byte malloc will now return the *same*
region pointed to by B â€“ creating a UAF/overlap. */
char *C2 = malloc(0x400);

printf("B  = %p\nC2 = %p (overlaps B)\n", B, C2);

// Arbitrary write in B is immediately visible via C2
memset(B, 'X', 0x10);
fwrite(C2, 1, 0x10, stdout);  // prints Xs
}
```
Przepis na eksploatacjÄ™ (czÄ™sto spotykany w ostatnich CTF):

1. **OprÃ³Å¼nij** tcache dla docelowego rozmiaru.
2. **Zwolnij** kawaÅ‚ek, aby trafiÅ‚ do nieposortowanego kosza.
3. **Przydziel** nieco mniejszy rozmiar â€“ alokator dzieli nieposortowany kawaÅ‚ek.
4. **Przydziel** ponownie â€“ pozostaÅ‚a czÄ™Å›Ä‡ nakÅ‚ada siÄ™ na istniejÄ…cy uÅ¼ywany kawaÅ‚ek â†’ UAF.
5. Nadpisz wraÅ¼liwe pola (wskaÅºniki do funkcji, vtable pliku itp.)

Praktyczne zastosowanie moÅ¼na znaleÅºÄ‡ w wyzwaniu *Setjmp* z 2024 HITCON Quals, gdzie ten dokÅ‚adny prymityw jest uÅ¼ywany do przejÅ›cia z UAF do peÅ‚nej kontroli nad `__free_hook`.

---
### ğŸ›¡ï¸  Åšrodki zaradcze i wzmocnienia

* **Bezpieczne linkowanie (glibc â‰¥ 2.32)** chroni tylko pojedynczo poÅ‚Ä…czone listy *tcache*/**fastbin**. Nieposortowane/maÅ‚e/duÅ¼e kosze nadal przechowujÄ… surowe wskaÅºniki, wiÄ™c nakÅ‚adanie siÄ™ oparte na pierwszym dopasowaniu pozostaje wykonalne, jeÅ›li moÅ¼esz uzyskaÄ‡ wyciek z pamiÄ™ci.
* **Szyfrowanie wskaÅºnikÃ³w do sterty i MTE** (ARM64) nie wpÅ‚ywa jeszcze na x86-64 glibc, ale flagi wzmocnienia dystrybucji, takie jak `GLIBC_TUNABLES=glibc.malloc.check=3`, przerwÄ… dziaÅ‚anie przy niespÃ³jnych metadanych i mogÄ… zÅ‚amaÄ‡ naiwne PoC.
* **WypeÅ‚nianie tcache przy zwolnieniu** (proponowane w 2024 dla glibc 2.41) dodatkowo zmniejszyÅ‚oby uÅ¼ycie nieposortowanego; monitoruj przyszÅ‚e wydania podczas opracowywania ogÃ³lnych exploitÃ³w.

---
## Inne odniesienia i przykÅ‚ady

- [**https://heap-exploitation.dhavalkapil.com/attacks/first_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first_fit)
- [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
- ARM64. UÅ¼ycie po zwolnieniu: Wygeneruj obiekt uÅ¼ytkownika, zwolnij go, wygeneruj obiekt, ktÃ³ry uzyskuje zwolniony kawaÅ‚ek i pozwÃ³l na zapis do niego, **nadpisujÄ…c pozycjÄ™ user->password** z poprzedniego. Ponownie uÅ¼yj uÅ¼ytkownika, aby **obejÅ›Ä‡ sprawdzanie hasÅ‚a**.
- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example)
- Program pozwala na tworzenie notatek. Notatka bÄ™dzie miaÅ‚a informacje o notatce w malloc(8) (z wskaÅºnikiem do funkcji, ktÃ³ra mogÅ‚aby byÄ‡ wywoÅ‚ana) oraz wskaÅºnik do innego malloc(<size>) z treÅ›ciÄ… notatki.
- Atak polegaÅ‚by na stworzeniu 2 notatek (note0 i note1) z wiÄ™kszÄ… zawartoÅ›ciÄ… malloc niÅ¼ rozmiar informacji o notatce, a nastÄ™pnie ich zwolnieniu, aby trafiÅ‚y do szybkiego kosza (lub tcache).
- NastÄ™pnie stwÃ³rz innÄ… notatkÄ™ (note2) o rozmiarze zawartoÅ›ci 8. ZawartoÅ›Ä‡ bÄ™dzie w note1, poniewaÅ¼ kawaÅ‚ek bÄ™dzie ponownie uÅ¼yty, gdzie moglibyÅ›my zmodyfikowaÄ‡ wskaÅºnik funkcji, aby wskazywaÅ‚ na funkcjÄ™ wygranej, a nastÄ™pnie uÅ¼yÄ‡ UAF na note1, aby wywoÅ‚aÄ‡ nowy wskaÅºnik funkcji.
- [**https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html)
- MoÅ¼liwe jest przydzielenie pamiÄ™ci, zapisanie poÅ¼Ä…danej wartoÅ›ci, zwolnienie jej, ponowne przydzielenie, a poniewaÅ¼ poprzednie dane wciÄ…Å¼ tam sÄ…, bÄ™dÄ… traktowane zgodnie z nowÄ… oczekiwanÄ… strukturÄ… w kawaÅ‚ku, co umoÅ¼liwia ustawienie wartoÅ›ci lub uzyskanie flagi.
- [**https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html)
- W tym przypadku trzeba zapisaÄ‡ 4 wewnÄ…trz konkretnego kawaÅ‚ka, ktÃ³ry jest pierwszym przydzielonym (nawet po wymuszeniu zwolnienia wszystkich). W kaÅ¼dym nowym przydzielonym kawaÅ‚ku jego numer w indeksie tablicy jest przechowywany. NastÄ™pnie przydziel 4 kawaÅ‚ki (+ poczÄ…tkowo przydzielony), ostatni bÄ™dzie miaÅ‚ 4 wewnÄ…trz, zwolnij je i wymuÅ› ponowne przydzielenie pierwszego, ktÃ³re uÅ¼yje ostatniego zwolnionego kawaÅ‚ka, ktÃ³ry jest tym z 4 wewnÄ…trz.
- 2024 HITCON Quals Setjmp write-up (Quarkslab) â€“ praktyczny atak na nakÅ‚adanie siÄ™ pierwszego dopasowania / nieposortowanego podziaÅ‚u: <https://ctftime.org/writeup/39355>
- Angstrom CTF 2024 *heapify* write-up â€“ naduÅ¼ywanie podziaÅ‚u nieposortowanego kosza w celu wycieku libc i uzyskania nakÅ‚adania siÄ™: <https://hackmd.io/@aneii11/H1S2snV40>

{{#include ../../../banners/hacktricks-training.md}}
