# First Fit

{{#include ../../../banners/hacktricks-training.md}}

## **First Fit**

Cuando liberas memoria en un programa usando glibc, se utilizan diferentes "bins" para gestionar los bloques de memoria. Aquí hay una explicación simplificada de dos escenarios comunes: bins no ordenados y fastbins.

### Bins No Ordenados

Cuando liberas un bloque de memoria que no es un bloque rápido, va al bin no ordenado. Este bin actúa como una lista donde los nuevos bloques liberados se añaden al frente (la "cabeza"). Cuando solicitas un nuevo bloque de memoria, el asignador mira el bin no ordenado desde la parte trasera (la "cola") para encontrar un bloque que sea lo suficientemente grande. Si un bloque del bin no ordenado es más grande de lo que necesitas, se divide, devolviendo la parte delantera y manteniendo la parte restante en el bin.

Ejemplo:

- Asignas 300 bytes (`a`), luego 250 bytes (`b`), liberas `a` y solicitas nuevamente 250 bytes (`c`).
- Cuando liberas `a`, va al bin no ordenado.
- Si luego solicitas 250 bytes nuevamente, el asignador encuentra `a` en la cola y lo divide, devolviendo la parte que se ajusta a tu solicitud y manteniendo el resto en el bin.
- `c` apuntará al anterior `a` y estará lleno con los `a's`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins se utilizan para pequeños fragmentos de memoria. A diferencia de los bins no ordenados, los fastbins añaden nuevos fragmentos a la cabeza, creando un comportamiento de último en entrar, primero en salir (LIFO). Si solicitas un pequeño fragmento de memoria, el asignador tomará de la cabeza del fastbin.

Ejemplo:

- Asignas cuatro fragmentos de 20 bytes cada uno (`a`, `b`, `c`, `d`).
- Cuando los liberas en cualquier orden, los fragmentos liberados se añaden a la cabeza del fastbin.
- Si luego solicitas un fragmento de 20 bytes, el asignador devolverá el fragmento liberado más recientemente de la cabeza del fastbin.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Otras Referencias y Ejemplos

- [**https://heap-exploitation.dhavalkapil.com/attacks/first_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first_fit)
- [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
- ARM64. Use after free: Generar un objeto de usuario, liberarlo, generar un objeto que obtenga el fragmento liberado y permitir escribir en él, **sobrescribiendo la posición de user->password** del anterior. Reutilizar el usuario para **eludir la verificación de contraseña**
- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example)
- El programa permite crear notas. Una nota tendrá la información de la nota en un malloc(8) (con un puntero a una función que podría ser llamada) y un puntero a otro malloc(\<size>) con el contenido de la nota.
- El ataque consistiría en crear 2 notas (note0 y note1) con contenidos de malloc más grandes que el tamaño de la información de la nota y luego liberarlas para que entren en el fast bin (o tcache).
- Luego, crear otra nota (note2) con un tamaño de contenido de 8. El contenido estará en note1 ya que el fragmento se va a reutilizar, donde podríamos modificar el puntero de función para apuntar a la función win y luego Use-After-Free la note1 para llamar al nuevo puntero de función.
- [**https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html)
- Es posible asignar algo de memoria, escribir el valor deseado, liberarlo, reallocarlo y como los datos anteriores aún están allí, se tratará de acuerdo con la nueva estructura esperada en el fragmento, lo que hace posible establecer el valor o obtener la bandera.
- [**https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html)
- En este caso, es necesario escribir 4 dentro de un fragmento específico que es el primero que se asigna (incluso después de forzar la liberación de todos ellos). En cada nuevo fragmento asignado, su número en el índice del array se almacena. Luego, asignar 4 fragmentos (+ el inicialmente asignado), el último tendrá 4 dentro de él, liberarlos y forzar la reasignación del primero, que utilizará el último fragmento liberado que es el que tiene 4 dentro de él.
