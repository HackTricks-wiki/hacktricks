# House of Einherjar

{{#include ../../banners/hacktricks-training.md}}

## Informations de base

### Code

- Vérifiez l'exemple de [https://github.com/shellphish/how2heap/blob/master/glibc_2.35/house_of_einherjar.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/house_of_einherjar.c)
- Ou celui de [https://guyinatuxedo.github.io/42-house_of_einherjar/house_einherjar_exp/index.html#house-of-einherjar-explanation](https://guyinatuxedo.github.io/42-house_of_einherjar/house_einherjar_exp/index.html#house-of-einherjar-explanation) (vous devrez peut-être remplir le tcache)

### Objectif

- L'objectif est d'allouer de la mémoire à presque n'importe quelle adresse spécifique.

### Exigences

- Créer un faux chunk lorsque nous voulons allouer un chunk :
- Définir des pointeurs pour pointer vers lui-même afin de contourner les vérifications de validité
- Débordement d'un octet avec un octet nul d'un chunk au suivant pour modifier le drapeau `PREV_INUSE`.
- Indiquer dans le `prev_size` du chunk abusé par un octet nul la différence entre lui-même et le faux chunk
- La taille du faux chunk doit également avoir été définie à la même taille pour contourner les vérifications de validité
- Pour construire ces chunks, vous aurez besoin d'une fuite de heap.

### Attaque

- Un faux chunk `A` est créé à l'intérieur d'un chunk contrôlé par l'attaquant pointant avec `fd` et `bk` vers le chunk original pour contourner les protections
- 2 autres chunks (`B` et `C`) sont alloués
- En abusant du débordement d'un octet dans le chunk `B`, le bit `prev in use` est nettoyé et les données `prev_size` sont écrasées avec la différence entre l'endroit où le chunk `C` est alloué et le faux chunk `A` généré précédemment
- Ce `prev_size` et la taille dans le faux chunk `A` doivent être les mêmes pour contourner les vérifications.
- Ensuite, le tcache est rempli
- Ensuite, `C` est libéré afin qu'il se consolide avec le faux chunk `A`
- Ensuite, un nouveau chunk `D` est créé qui commencera dans le faux chunk `A` et couvrira le chunk `B`
- La maison d'Einherjar se termine ici
- Cela peut être poursuivi avec une attaque de fast bin ou un empoisonnement de Tcache :
- Libérer `B` pour l'ajouter au fast bin / Tcache
- Le `fd` de `B` est écrasé, le faisant pointer vers l'adresse cible en abusant du chunk `D` (car il contient `B` à l'intérieur)&#x20;
- Ensuite, 2 mallocs sont effectués et le deuxième va **allouer l'adresse cible**

## Références et autres exemples

- [https://github.com/shellphish/how2heap/blob/master/glibc_2.35/house_of_einherjar.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/house_of_einherjar.c)
- **CTF** [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_einherjar/#2016-seccon-tinypad**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_einherjar/#2016-seccon-tinypad)
- Après avoir libéré des pointeurs, ils ne sont pas annulés, donc il est toujours possible d'accéder à leurs données. Par conséquent, un chunk est placé dans le bin non trié et les pointeurs qu'il contient sont divulgués (libc leak) et ensuite un nouveau heap est placé dans le bin non trié et une adresse de heap est divulguée à partir du pointeur qu'il obtient.
- [**baby-talk. DiceCTF 2024**](https://7rocky.github.io/en/ctf/other/dicectf/baby-talk/)
- Bug de débordement d'octet nul dans `strtok`.
- Utilisez la Maison d'Einherjar pour obtenir une situation de chunks qui se chevauchent et terminez avec un empoisonnement de Tcache pour obtenir une primitive d'écriture arbitraire.

{{#include ../../banners/hacktricks-training.md}}
