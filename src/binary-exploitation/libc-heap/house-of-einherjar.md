# House of Einherjar

{{#include ../../banners/hacktricks-training.md}}

## Informações Básicas

### Código

- Confira o exemplo em [https://github.com/shellphish/how2heap/blob/master/glibc_2.35/house_of_einherjar.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/house_of_einherjar.c)
- Ou o de [https://guyinatuxedo.github.io/42-house_of_einherjar/house_einherjar_exp/index.html#house-of-einherjar-explanation](https://guyinatuxedo.github.io/42-house_of_einherjar/house_einherjar_exp/index.html#house-of-einherjar-explanation) (você pode precisar preencher o tcache)

### Objetivo

- O objetivo é alocar memória em quase qualquer endereço específico.

### Requisitos

- Criar um chunk falso quando quisermos alocar um chunk:
- Definir ponteiros para apontar para si mesmos para contornar verificações de sanidade
- Overflow de um byte com um byte nulo de um chunk para o próximo para modificar a flag `PREV_INUSE`.
- Indicar no `prev_size` do chunk abusado off-by-null a diferença entre ele e o chunk falso
- O tamanho do chunk falso também deve ter sido definido com o mesmo tamanho para contornar verificações de sanidade
- Para construir esses chunks, você precisará de um leak de heap.

### Ataque

- Um chunk falso `A` é criado dentro de um chunk controlado pelo atacante apontando com `fd` e `bk` para o chunk original para contornar proteções
- 2 outros chunks (`B` e `C`) são alocados
- Abusando do off by one no `B`, o bit `prev in use` é limpo e os dados de `prev_size` são sobrescritos com a diferença entre o lugar onde o chunk `C` é alocado e o chunk falso `A` gerado anteriormente
- Este `prev_size` e o tamanho no chunk falso `A` devem ser os mesmos para contornar as verificações.
- Então, o tcache é preenchido
- Em seguida, `C` é liberado para que se consolide com o chunk falso `A`
- Então, um novo chunk `D` é criado que começará no chunk falso `A` e cobrindo o chunk `B`
- A casa de Einherjar termina aqui
- Isso pode ser continuado com um ataque de fast bin ou envenenamento de Tcache:
- Liberar `B` para adicioná-lo ao fast bin / Tcache
- O `fd` de `B` é sobrescrito fazendo-o apontar para o endereço alvo abusando do chunk `D` (já que contém `B` dentro)
- Em seguida, 2 mallocs são feitos e o segundo irá **alocar o endereço alvo**

## Referências e outros exemplos

- [https://github.com/shellphish/how2heap/blob/master/glibc_2.35/house_of_einherjar.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/house_of_einherjar.c)
- **CTF** [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_einherjar/#2016-seccon-tinypad**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_einherjar/#2016-seccon-tinypad)
- Após liberar ponteiros, eles não são anulados, então ainda é possível acessar seus dados. Portanto, um chunk é colocado no bin não ordenado e os ponteiros que contém são vazados (libc leak) e então um novo heap é colocado no bin não ordenado e um endereço de heap é vazado a partir do ponteiro que obtém.
- [**baby-talk. DiceCTF 2024**](https://7rocky.github.io/en/ctf/other/dicectf/baby-talk/)
- Bug de overflow de byte nulo em `strtok`.
- Use a Casa de Einherjar para obter uma situação de chunks sobrepostos e terminar com envenenamento de Tcache para obter um primitivo de escrita arbitrária.

{{#include ../../banners/hacktricks-training.md}}
