# VirtualBox Slirp NAT Packet Heap Exploitation

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- VirtualBox, yoğun şekilde değiştirilmiş bir Slirp fork'u içerir; paket tamponları (mbufs) inline metadata ve function-pointer callbacks (`pfFini`, `pfDtor`) içeren özel bir zone allocator içinde yaşar.
- Misafir, güvenilen `m->m_len` değerini saldırgan kontrollü bir IP header length ile yeniden yazabilir; bu sonraki tüm bounds kontrollerini yok eder ve hem infoleak hem de overwrite primitives sağlar.
- checksum `0` ve aşırı büyük `ip_len` içeren UDP paketlerini suistimal ederek, misafir mbuf tails'lerini ve komşu chunk'ların metadata'sını exfiltrate edip heap ve zone adreslerini öğrenebilir.
- Özenle hazırlanmış IP options sağlamak, `ip_stripoptions()`'un yerinde çok fazla veriyi `memcpy()` yapmaya zorlar; böylece saldırgan sonraki mbuf'un `struct item` başlığını overwrite edip `zone` alanını tamamen kontrol edilen verilere işaret ettirebilir.
- Bozulmuş mbuf'un free edilmesi, saldırgan tarafından sağlanan argümanlarla `zone->pfFini()`'yi tetikler; bunu `memcpy@plt`'e işaret ettirmek, non-PIE VirtualBox binary içindeki GOT girdilerine veya diğer kontrol verilerine yönlendirilebilecek arbitrary copy/write primitive sağlar.

## Paket ayırıcı yapısı

VirtualBox, her gelen Ethernet frame'ini `zone_clust` adlı arayüz-başı bir zone'dan ayırır. Her 0x800-byte'lık veri chunk'ının önünde bir inline header bulunur:
```c
struct item {
uint32_t magic;      // 0xdead0001
void    *zone;       // uma_zone_t pointer with callbacks
uint32_t ref_count;
LIST_ENTRY(item) list; // freelist / used list links
};
```
When an mbuf is freed the call stack `m_freem -> ... -> slirp_uma_free()` trusts the inline header:

1. `uma_zfree_arg()` recomputes `item = (struct item *)mem - 1` and *should* validate `item->zone`, but `Assert()` is compiled out in release builds.
2. `slirp_uma_free()` loads `zone = item->zone` and unconditionally executes `zone->pfFini(zone->pData, data_ptr, zone->size)` followed by `zone->pfDtor(...)`.

Therefore, any write-what-where into the mbuf header translates into a controlled indirect call during `free()`.

## Infoleak via `m->m_len` override

At the top of `ip_input()` VirtualBox added:
```c
if (m->m_len != RT_N2H_U16(ip->ip_len))
m->m_len = RT_N2H_U16(ip->ip_len);
```
Because the assignment happens **before** verifying the IP header, a guest can advertise any length up to 0xffff. The rest of the stack (ICMP, UDP, fragmentation handlers, etc.) assumes `m->m_len` is trustworthy and uses it to decide how many bytes to copy off the mbuf.

IP başlığını doğrulamadan **önce** atama yapıldığı için guest 0xffff'e kadar herhangi bir uzunluk beyan edebilir. Yığının geri kalanı (ICMP, UDP, fragmentation handlers, vb.) `m->m_len`'in güvenilir olduğunu varsayar ve mbuf'tan kaç bayt kopyalanacağına buna göre karar verir.

Use UDP packets with checksum `0` (meaning "no checksum"). The NAT fast-path forwards `m->m_len` bytes without inspecting payload integrity, so inflating `ip_len` causes Slirp to read past the real buffer and return heap residues to the guest or to a cooperating external helper beyond the NAT. Because the chunk size is 2048 bytes, the leak can include:

Checksum'u `0` olan UDP paketleri kullanın ("no checksum" anlamına gelir). NAT fast-path, payload bütünlüğünü incelemeden `m->m_len` baytını ilettiği için `ip_len`'i şişirmek Slirp'in gerçek buffer'ın ötesini okumasına ve heap residues'ı guest'e veya NAT ötesinde işbirlikçi bir yardımcıya geri vermesine neden olur. Chunk boyutu 2048 bayt olduğu için leak şunları içerebilir:

- The next mbuf's inline `struct item`, revealing the freelist order and the real `zone` pointer.
- Heap cookies such as `magic` fields, helping to craft valid-looking headers when performing corruptions later.

- Bir sonraki mbuf'un inline `struct item`'i; freelist sırasını ve gerçek `zone` işaretçisini açığa çıkarır.
- `magic` alanları gibi heap cookies; daha sonra yapılacak bozulmalarda geçerli görünümlü başlıklar hazırlamaya yardımcı olur.

## Overwriting neighbouring chunk headers with IP options

The same bogus length can be turned into an overwrite primitive by forcing the packet through `ip_stripoptions()` (triggered when the IP header has options and the payload is UDP/TCP). The helper computes a copy length from `m->m_len` and then calls `memcpy()` to slide the transport header over the stripped options:

Aynı sahte uzunluk, paketi `ip_stripoptions()` üzerinden geçirmekle (IP başlığı seçenek içerdiğinde ve payload UDP/TCP olduğunda tetiklenir) bir overwrite primitive'ine dönüştürülebilir. Helper, `m->m_len`'den bir kopyalama uzunluğu hesaplar ve ardından transport header'ı temizlenen seçeneklerin üzerine kaydırmak için `memcpy()` çağırır:

1. Supply a long `ip_len` so the computed move length extends past the current mbuf.
2. Include a small number of IP options so Slirp enters the stripping path.
3. When `memcpy()` runs, it reads from the following mbuf and writes over the current mbuf's payload and inline header, corrupting `magic`, `zone`, `ref_count`, etc.

1. Hesaplanan taşıma uzunluğunun mevcut mbuf'un ötesine uzanmasını sağlamak için uzun bir `ip_len` verin.
2. Slirp'in stripping path'ine girmesi için az sayıda IP option ekleyin.
3. `memcpy()` çalıştığında, bir sonraki mbuf'dan okur ve mevcut mbuf'un payload'u ile inline header'ı üzerine yazar; böylece `magic`, `zone`, `ref_count` vb. bozulur.

Because the allocator keeps packets from the same interface contiguous on the freelist, this overflow deterministically hits the next chunk after modest heap grooming.

Allocator, aynı arayüze ait paketleri freelist üzerinde bitişik tuttuğundan, bu overflow mütevazı bir heap grooming'den sonra deterministik olarak bir sonraki chunka isabet eder.

## Forging `uma_zone_t` to hijack `pfFini`

Once the adjacent `struct item` is corruptible, the exploit proceeds as follows:

Komşu `struct item` bozulabilir hale gelince, exploit şu şekilde ilerler:

1. Use leaked heap addresses to build a fake `uma_zone` structure inside a mbuf fully controlled by the guest. Populate:
- `pfFini` with the PLT entry of `memcpy()`.
- `pData` with the desired destination pointer (e.g. GOT entry, vtable slot, function pointer array).
- `size` with the number of bytes to copy.
- Optional: `pfDtor` as a second stage call (e.g. to invoke the newly-written function pointer).
2. Overwrite the target mbuf's `zone` field with the pointer to the fake structure; adjust `list` pointers so freelist bookkeeping remains consistent enough to avoid crashes.
3. Free the mbuf. `slirp_uma_free()` now executes `memcpy(dest=pData, src=item_data, n=size)` while the mbuf still contains guest-controlled data, yielding an arbitrary write.

1. Leaked heap adreslerini kullanarak guest tarafından tamamen kontrol edilen bir mbuf içinde sahte bir `uma_zone` yapısı oluşturun. Şunları doldurun:
- `pfFini`'yi `memcpy()`'nin PLT girdisi ile ayarlayın.
- `pData`'yı istenen hedef pointer ile ayarlayın (ör. GOT girdisi, vtable slotu, fonksiyon pointer dizisi).
- `size`'ı kopyalanacak bayt sayısı ile ayarlayın.
- Opsiyonel: ikinci aşama çağrısı için `pfDtor` (ör. yeni yazılan fonksiyon pointer'ını çalıştırmak için).
2. Hedef mbuf'un `zone` alanını sahte yapıya işaret eden pointer ile overwrite edin; freelist bookkeeping çöküşleri önleyecek kadar tutarlı kalacak şekilde `list` pointer'larını ayarlayın.
3. Mbuf'u free edin. `slirp_uma_free()` artık mbuf hala guest-kontrollü veri içerirken `memcpy(dest=pData, src=item_data, n=size)` çalıştırır ve bu da arbitrary write sağlar.

Because the Linux VirtualBox binary is non-PIE, PLT addresses for `memcpy` and `system` are fixed and can be used directly. The guest can also stash strings such as `/bin/sh` inside another mbuf that remains referenced when the hijacked call executes.

Linux VirtualBox binary'si non-PIE olduğu için `memcpy` ve `system` için PLT adresleri sabittir ve doğrudan kullanılabilir. Guest ayrıca `/bin/sh` gibi stringleri, kaçırılmış çağrı çalıştırıldığında referanslı kalan başka bir mbuf içine de saklayabilir.

## Heap grooming via fragmentation

Slirp's per-interface zone is 3072 chunks deep and initially carved as a contiguous array whose freelist is traversed from high addresses downward. Deterministic adjacency can be achieved by:

Slirp'in arayüz başına zone'u 3072 chunk derinliğindedir ve başlangıçta freelist'in yüksek adreslerden aşağı doğru dolaştığı bitişik bir dizi olarak ayrılmıştır. Deterministik adjacency şu yollarla sağlanabilir:

- Flooding the NAT with many `IP_MF` fragments of constant size so the reassembly code allocates predictable mbuf sequences.
- Recycling specific chunks by sending fragments that time out, forcing frees back into the freelist in LIFO order.
- Using knowledge of the freelist walk to place the future victim mbuf right after the mbuf that will carry the IP options overflow.

- Yeniden birleştirme kodunun öngörülebilir mbuf dizileri ayırması için sabit boyutlu çok sayıda `IP_MF` fragmanı ile NAT'ı flood etmek.
- Süresi dolan fragmentler göndererek belirli chunk'ları recycle etmek; bu, frees'ların LIFO sırayla freelist'e dönmesine zorlar.
- Freelists yürüyüşü bilgisini kullanarak, ilerideki hedef mbuf'u IP options overflow'unu taşıyacak mbuf'un hemen sonrasına yerleştirmek.

This grooming ensures the overflow hits the targeted `struct item` and that the fake `uma_zone` remains in-bounds of the leak primitive.

Bu grooming, overflow'un hedeflenen `struct item`'e isabet etmesini ve sahte `uma_zone`'un leak primitive sınırları içinde kalmasını garanti eder.

## From arbitrary write to host code execution

With the memcpy-on-free primitive:

1. Copy an attacker-controlled `/bin/sh` string and command buffer into a stable mbuf.
2. Use the primitive to overwrite a GOT entry or indirect callsite (e.g. a function pointer inside the NAT device state) with the PLT entry of `system()`.
3. Trigger the overwritten call. Because VirtualBox runs the NAT device inside the host process, the payload executes with the privileges of the user running VirtualBox, allowing a guest-to-host escape.

Alternative payloads include planting a miniature ROP chain in heap memory and copying its address into a frequently-invoked callback, or repointing `pfFini`/`pfDtor` themselves to chained gadgets for repeated writes.

memcpy-on-free primitive'i ile:

1. Saldırgan-kontrollü bir `/bin/sh` stringini ve komut buffer'ını kararlı bir mbuf içine kopyalayın.
2. Primitive'i kullanarak bir GOT girdisini veya dolaylı çağrı noktasını (ör. NAT device state içindeki bir fonksiyon pointer'ı) `system()`'ın PLT girdisi ile overwrite edin.
3. Overwrite edilmiş çağrıyı tetikleyin. VirtualBox NAT cihazını host süreci içinde çalıştırdığı için payload, VirtualBox'ı çalıştıran kullanıcının ayrıcalıklarıyla yürütülür ve bu da guest-to-host escape sağlar.

Alternatif payload'lar arasında heap belleğe küçük bir ROP zinciri yerleştirmek ve adresini sıkça çağrılan bir callback'e kopyalamak veya yinelemeli yazmalar için `pfFini`/`pfDtor`'u zincirlenmiş gadget'lara yönlendirmek bulunur.

## References

- [Thinking Outside The Box: Exploiting VirtualBox Slirp NAT Heap Corruption](https://projectzero.google/2025/12/thinking-outside-the-box.html)

{{#include ../../banners/hacktricks-training.md}}
