# VirtualBox Slirp NAT Packet Heap Exploitation

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- VirtualBox ships a heavily modified fork of Slirp whose packet buffers (mbufs) live in a custom zone allocator with inline metadata and function-pointer callbacks (`pfFini`, `pfDtor`).
- 来宾（guest）可以用攻击者控制的 IP 报头长度重写受信任的 `m->m_len`，这会破坏之后的所有边界检查，并产生 infoleak 和 overwrite primitives。
- 通过滥用校验和为 `0` 且过大的 `ip_len` 的 UDP 包，guest 可以将 mbuf 尾部和相邻 chunk 的元数据 exfiltrate 出来，以便获取 heap 和 zone 地址。
- 通过提供精心构造的 IP 选项，迫使 `ip_stripoptions()` 对数据就地 `memcpy()` 过多数据，从而攻击者可以覆盖下一个 mbuf 的 `struct item` 头并将其 `zone` 字段指向完全受控的数据。
- 释放被破坏的 mbuf 会触发 `zone->pfFini()` 并带有攻击者提供的参数；将其指向 `memcpy@plt` 可以得到任意的 copy/write primitive，进而可以定向写入 GOT 条目或非-PIE VirtualBox 二进制内的其他控制数据。

## Packet allocator anatomy

VirtualBox allocates every ingress Ethernet frame from a per-interface zone named `zone_clust`. Each 0x800-byte data chunk is preceded by an inline header:
```c
struct item {
uint32_t magic;      // 0xdead0001
void    *zone;       // uma_zone_t pointer with callbacks
uint32_t ref_count;
LIST_ENTRY(item) list; // freelist / used list links
};
```
当一个 mbuf 被释放时，调用栈 `m_freem -> ... -> slirp_uma_free()` 信任内联头：

1. `uma_zfree_arg()` 重新计算 `item = (struct item *)mem - 1` 并且 *should* 验证 `item->zone`，但 `Assert()` 在发布版本中被编译移除。
2. `slirp_uma_free()` 加载 `zone = item->zone` 并且无条件地执行 `zone->pfFini(zone->pData, data_ptr, zone->size)`，随后执行 `zone->pfDtor(...)`。

因此，任何对 mbuf 头部的 write-what-where 都会在 `free()` 期间转化为受控的间接调用。

## Infoleak 通过 `m->m_len` 覆盖

在 `ip_input()` 的顶部，VirtualBox 添加了：
```c
if (m->m_len != RT_N2H_U16(ip->ip_len))
m->m_len = RT_N2H_U16(ip->ip_len);
```
Because the assignment happens **在验证 IP 头之前**, 来宾可以宣告任意长度到 0xffff。栈的其余部分（ICMP、UDP、fragmentation handlers 等）假定 `m->m_len` 是可信的，并用它来决定从 mbuf 拷贝多少字节。

使用 checksum 为 `0` 的 UDP 包（表示“no checksum”）。NAT fast-path 会转发 `m->m_len` 字节而不检查 payload 完整性，因此膨胀 `ip_len` 会导致 Slirp 读取超出真实缓冲区并将 heap 残留返回给 guest 或 NAT 之外的配合外部 helper。因为 chunk 大小为 2048 字节，the leak can include:

- 下一个 mbuf 的 inline `struct item`，泄露 freelist 顺序和真实的 `zone` 指针。
- 堆 cookie（例如 `magic` 字段），在之后执行破坏时帮助构造看起来合法的头。

## Overwriting neighbouring chunk headers with IP options

相同的伪造长度可以通过强制数据包通过 `ip_stripoptions()`（当 IP 头有 options 且 payload 为 UDP/TCP 时触发）变成覆盖原语。helper 从 `m->m_len` 计算一个拷贝长度，然后调用 `memcpy()` 将 transport header 向前移动以覆盖被剥离的 options：

1. 提供一个很长的 `ip_len`，使得计算出的移动长度延伸过当前 mbuf。
2. 包含少量 IP options，让 Slirp 进入 stripping 路径。
3. 当 `memcpy()` 运行时，它会从后续 mbuf 读取并写入当前 mbuf 的 payload 和 inline header，破坏 `magic`、`zone`、`ref_count` 等。

因为 allocator 保持来自同一接口的包在 freelist 上是连续的，这个 overflow 在经过适度的堆 groom 后会确定性命中下一个 chunk。

## Forging `uma_zone_t` to hijack `pfFini`

一旦相邻的 `struct item` 可被破坏，利用流程如下：

1. 使用泄露的堆地址在一个完全由 guest 控制的 mbuf 内构建假 `uma_zone` 结构。填充：
   - `pfFini` 为 `memcpy()` 的 PLT 条目。
   - `pData` 为目标指针（例如 GOT 条目、vtable 槽、函数指针数组）。
   - `size` 为要拷贝的字节数。
   - 可选：将 `pfDtor` 作为第二阶段调用（例如调用新写入的函数指针）。
2. 将目标 mbuf 的 `zone` 字段覆盖为指向假结构的指针；调整 `list` 指针以使 freelist 记账保持足够一致以避免崩溃。
3. free 该 mbuf。现在 `slirp_uma_free()` 会执行 `memcpy(dest=pData, src=item_data, n=size)`，而当时 mbuf 仍包含 guest 可控数据，从而实现任意写。

因为 Linux VirtualBox 二进制为 non-PIE，`memcpy` 和 `system` 的 PLT 地址是固定的，可直接使用。guest 也可以把如 `/bin/sh` 的字符串藏在另一个在被劫持调用执行时仍被引用的 mbuf 中。

## Heap grooming via fragmentation

Slirp 的 per-interface zone 深度为 3072 个 chunk，最初作为连续数组分配，其 freelist 从高地址向下遍历。可通过以下方法实现确定性相邻：

- 向 NAT 洪泛许多大小恒定的 `IP_MF` fragments，使重组代码分配可预测的 mbuf 序列。
- 通过发送超时的碎片回收特定 chunk，迫使 frees 以 LIFO 顺序返回 freelist。
- 利用对 freelist 遍历的了解，将将来的受害者 mbuf 放在将承载 IP options overflow 的 mbuf 之后。

这种 grooming 确保 overflow 命中目标 `struct item`，并且假 `uma_zone` 保持在 leak 原语的可泄露范围内。

## From arbitrary write to host code execution

利用 memcpy-on-free 原语：

1. 将攻击者控制的 `/bin/sh` 字符串和命令缓冲区拷贝到一个稳定的 mbuf 中。
2. 使用原语覆盖 GOT 条目或间接调用点（例如 NAT 设备状态内的函数指针）为 `system()` 的 PLT 条目。
3. 触发被覆盖的调用。因为 VirtualBox 在主机进程内运行 NAT 设备，payload 将以运行 VirtualBox 的用户权限在主机上执行，从而实现 guest 到 host 的逃逸。

可选 payload 包括在堆内种植一个小型 ROP 链并将其地址拷贝到频繁调用的回调中，或将 `pfFini`/`pfDtor` 本身指向串联的 gadget 以实现重复写入。

## References

- [Thinking Outside The Box: Exploiting VirtualBox Slirp NAT Heap Corruption](https://projectzero.google/2025/12/thinking-outside-the-box.html)

{{#include ../../banners/hacktricks-training.md}}
