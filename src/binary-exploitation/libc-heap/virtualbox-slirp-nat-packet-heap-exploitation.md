# VirtualBox Slirp NAT Packet Heap Exploitation

{{#include ../../banners/hacktricks-training.md}}

## सार

- VirtualBox एक heavily modified fork of Slirp के साथ आता है जिसका packet buffers (mbufs) एक custom zone allocator में inline metadata और function-pointer callbacks (`pfFini`, `pfDtor`) के साथ रहते हैं।
- कोई guest trusted `m->m_len` को attacker-controlled IP header length से फिर से लिख सकता है, जो बाद की सभी bounds checks को नष्ट कर देता है और दोनों infoleak तथा overwrite primitives प्रदान करता है।
- checksum `0` वाले और oversized `ip_len` वाले UDP packets का दुरुपयोग करके, guest mbuf tails और पड़ोसी chunks के metadata को exfiltrate कर सकता है ताकि heap और zone addresses सीखी जा सकें।
- crafted IP options देने से `ip_stripoptions()` को in-place बहुत अधिक डेटा `memcpy()` करने के लिए मजबूर किया जा सकता है, जिससे attacker अगले mbuf के `struct item` हेडर को overwrite करके उसके `zone` फील्ड को पूरी तरह नियंत्रित डेटा की ओर पॉइंट कर सकता है।
- corrupted mbuf को free करने से `zone->pfFini()` attacker-supplied arguments के साथ trigger होता है; इसे `memcpy@plt` की ओर पॉइंट करने से एक arbitrary copy/write primitive मिलता है जिसे GOT entries या non-PIE VirtualBox binary के अंदर अन्य control data की ओर स्टियर किया जा सकता है।

## पैकेट एलोकेटर संरचना

VirtualBox प्रति-इंटरफ़ेस zone नामक `zone_clust` से हर ingress Ethernet frame को allocate करता है। प्रत्येक 0x800-байट डेटा chunk के पहले एक inline header होता है:
```c
struct item {
uint32_t magic;      // 0xdead0001
void    *zone;       // uma_zone_t pointer with callbacks
uint32_t ref_count;
LIST_ENTRY(item) list; // freelist / used list links
};
```
जब एक mbuf को free किया जाता है तो कॉल स्टैक `m_freem -> ... -> slirp_uma_free()` inline हेडर पर भरोसा करता है:

1. `uma_zfree_arg()` फिर से गणना करता है `item = (struct item *)mem - 1` और *चाहीए* कि वह `item->zone` को validate करे, पर `Assert()` release builds में compiled out होता है।
2. `slirp_uma_free()` लोड करता है `zone = item->zone` और बिना शर्त के चलाता है `zone->pfFini(zone->pData, data_ptr, zone->size)` जिसके बाद `zone->pfDtor(...)` चलता है।

इसलिए, mbuf हेडर में कोई भी write-what-where `free()` के दौरान एक नियंत्रित indirect call में परिवर्तित हो जाता है।

## Infoleak via `m->m_len` override

At the top of `ip_input()` VirtualBox added:
```c
if (m->m_len != RT_N2H_U16(ip->ip_len))
m->m_len = RT_N2H_U16(ip->ip_len);
```
Because the assignment happens **before** verifying the IP header, a guest can advertise any length up to 0xffff. The rest of the stack (ICMP, UDP, fragmentation handlers, etc.) assumes `m->m_len` is trustworthy and uses it to decide how many bytes to copy off the mbuf.

Use UDP packets with checksum `0` (meaning "no checksum"). The NAT fast-path forwards `m->m_len` bytes without inspecting payload integrity, so inflating `ip_len` causes Slirp to read past the real buffer and return heap residues to the guest or to a cooperating external helper beyond the NAT. Because the chunk size is 2048 bytes, the leak can include:

- The next mbuf's inline `struct item`, revealing the freelist order and the real `zone` pointer.
- Heap cookies such as `magic` fields, helping to craft valid-looking headers when performing corruptions later.

## Overwriting neighbouring chunk headers with IP options

The same bogus length can be turned into an overwrite primitive by forcing the packet through `ip_stripoptions()` (triggered when the IP header has options and the payload is UDP/TCP). The helper computes a copy length from `m->m_len` and then calls `memcpy()` to slide the transport header over the stripped options:

1. Supply a long `ip_len` so the computed move length extends past the current mbuf.
2. Include a small number of IP options so Slirp enters the stripping path.
3. When `memcpy()` runs, it reads from the following mbuf and writes over the current mbuf's payload and inline header, corrupting `magic`, `zone`, `ref_count`, etc.

Because the allocator keeps packets from the same interface contiguous on the freelist, this overflow deterministically hits the next chunk after modest heap grooming.

## Forging `uma_zone_t` to hijack `pfFini`

Once the adjacent `struct item` is corruptible, the exploit proceeds as follows:

1. Use leaked heap addresses to build a fake `uma_zone` structure inside a mbuf fully controlled by the guest. Populate:
- `pfFini` with the PLT entry of `memcpy()`.
- `pData` with the desired destination pointer (e.g. GOT entry, vtable slot, function pointer array).
- `size` with the number of bytes to copy.
- Optional: `pfDtor` as a second stage call (e.g. to invoke the newly-written function pointer).
2. Overwrite the target mbuf's `zone` field with the pointer to the fake structure; adjust `list` pointers so freelist bookkeeping remains consistent enough to avoid crashes.
3. Free the mbuf. `slirp_uma_free()` now executes `memcpy(dest=pData, src=item_data, n=size)` while the mbuf still contains guest-controlled data, yielding an arbitrary write.

Because the Linux VirtualBox binary is non-PIE, PLT addresses for `memcpy` and `system` are fixed and can be used directly. The guest can also stash strings such as `/bin/sh` inside another mbuf that remains referenced when the hijacked call executes.

## Heap grooming via fragmentation

Slirp's per-interface zone is 3072 chunks deep and initially carved as a contiguous array whose freelist is traversed from high addresses downward. Deterministic adjacency can be achieved by:

- Flooding the NAT with many `IP_MF` fragments of constant size so the reassembly code allocates predictable mbuf sequences.
- Recycling specific chunks by sending fragments that time out, forcing frees back into the freelist in LIFO order.
- Using knowledge of the freelist walk to place the future victim mbuf right after the mbuf that will carry the IP options overflow.

This grooming ensures the overflow hits the targeted `struct item` and that the fake `uma_zone` remains in-bounds of the leak primitive.

## From arbitrary write to host code execution

With the memcpy-on-free primitive:

1. Copy an attacker-controlled `/bin/sh` string and command buffer into a stable mbuf.
2. Use the primitive to overwrite a GOT entry or indirect callsite (e.g. a function pointer inside the NAT device state) with the PLT entry of `system()`.
3. Trigger the overwritten call. Because VirtualBox runs the NAT device inside the host process, the payload executes with the privileges of the user running VirtualBox, allowing a guest-to-host escape.

Alternative payloads include planting a miniature ROP chain in heap memory and copying its address into a frequently-invoked callback, or repointing `pfFini`/`pfDtor` themselves to chained gadgets for repeated writes.

## References

- [Thinking Outside The Box: Exploiting VirtualBox Slirp NAT Heap Corruption](https://projectzero.google/2025/12/thinking-outside-the-box.html)

{{#include ../../banners/hacktricks-training.md}}
