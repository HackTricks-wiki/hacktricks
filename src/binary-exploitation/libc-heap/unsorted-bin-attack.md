# Unsorted Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

Unsorted bin nedir hakkında daha fazla bilgi için bu sayfayı kontrol edin:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Unsorted listeler, `bk` adresine `unsorted_chunks (av)` adresini yazma yeteneğine sahiptir. Bu nedenle, bir saldırgan bir unsorted bin içindeki bir chunk'taki **`bk` pointer'ının adresini değiştirebilirse**, bu adresi **rastgele bir adrese yazma** yeteneğine sahip olabilir; bu da Glibc adreslerini sızdırmak veya bazı savunmaları aşmak için faydalı olabilir.

Temelde, bu saldırı **rastgele bir adreste büyük bir sayı ayarlamaya** olanak tanır. Bu büyük sayı, bir heap adresi veya bir Glibc adresi olabilir. Tipik bir hedef **`global_max_fast`**'tır; bu, daha büyük boyutlarda hızlı binler oluşturulmasına izin verir (ve unsorted bin saldırısından hızlı bin saldırısına geçiş yapar).

> [!TIP]
> [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle) adresindeki örneğe bakarak ve chunk boyutları olarak 0x400 ve 0x500 yerine 0x4000 ve 0x5000 kullanarak (Tcache'den kaçınmak için) **günümüzde** **`malloc(): unsorted double linked list corrupted`** hatasının tetiklendiğini görebilirsiniz.
>
> Bu nedenle, bu unsorted bin saldırısı artık (diğer kontrollerin yanı sıra) çift bağlı listeyi düzeltme yeteneğine sahip olmayı da gerektirir, böylece `victim->bk->fd == victim` veya `victim->fd == av (arena)` kontrolü geçerlidir; bu, yazmak istediğimiz adresin `fd` konumunda sahte chunk'ın adresine sahip olması ve sahte chunk'ın `fd`'sinin arenaya işaret etmesi gerektiği anlamına gelir.

> [!CAUTION]
> Bu saldırının unsorted bin'i bozduğunu unutmayın (bu nedenle küçük ve büyük de). Bu nedenle, artık yalnızca **hızlı binlerden tahsisat kullanabiliriz** (daha karmaşık bir program başka tahsisatlar yapabilir ve çökebilir) ve bunu tetiklemek için **aynı boyutta tahsisat yapmalıyız yoksa program çöker.**
>
> **`global_max_fast`**'ı geçersiz kılmak bu durumda yardımcı olabilir, çünkü hızlı binin diğer tüm tahsisatları yönetebileceğini varsayıyoruz, ta ki exploit tamamlanana kadar.

[**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin_attack/unsorted_explanation/index.html) tarafından sağlanan kod bunu çok iyi açıklıyor, ancak malloc'ları yeterince büyük bir bellek tahsis etmek için değiştirirseniz, böylece Tcache'de sona ermezseniz, daha önce bahsedilen hatanın bu tekniği engellediğini görebilirsiniz: **`malloc(): unsorted double linked list corrupted`**

## Unsorted Bin Infoleak Attack

Bu aslında çok temel bir kavramdır. Unsorted bin'deki chunk'lar pointer'lara sahip olacaktır. Unsorted bin'deki ilk chunk aslında **`fd`** ve **`bk`** bağlantılarına **ana arenanın (Glibc)** bir kısmına işaret edecektir.\
Bu nedenle, bir chunk'ı unsorted bin içine **yerleştirip okuyabilirseniz** (free'den sonra kullanma) veya **en az 1 pointer'ı geçersiz kılmadan tekrar tahsis edebilirseniz** ve ardından **okuyabilirseniz**, bir **Glibc bilgi sızıntısı** elde edebilirsiniz.

Bu yazımda kullanılan benzer bir [**saldırı**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html), 4 chunk yapısını (A, B, C ve D - D yalnızca üst chunk ile konsolidasyonu önlemek için) kötüye kullanmak için B'deki null byte taşmasını kullanarak C'nin B'nin kullanılmadığını belirtmesini sağladı. Ayrıca, B'deki `prev_size` verisi değiştirilerek boyut B'nin boyutu yerine A+B olarak ayarlandı.\
Sonra C serbest bırakıldı ve A+B ile konsolide edildi (ancak B hala kullanılıyordu). A boyutunda yeni bir chunk tahsis edildi ve ardından libc sızdırılan adresler B'ye yazıldı.

## Referanslar ve Diğer Örnekler

- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap)
- Amaç, 4869'dan büyük bir değerle bir global değişkeni geçersiz kılmak, böylece bayrağı almak mümkün olur ve PIE etkin değildir.
- Rastgele boyutlarda chunk'lar oluşturmak mümkündür ve istenen boyutta bir heap taşması vardır.
- Saldırı, 3 chunk oluşturarak başlar: taşmayı kötüye kullanmak için chunk0, taşma için chunk1 ve üst chunk'un önceki chunk'larla konsolide olmaması için chunk2.
- Sonra, chunk1 serbest bırakılır ve chunk0, chunk1'in `bk` pointer'ına taşma yapar: `bk = magic - 0x10`
- Sonra, chunk1 ile aynı boyutta chunk3 tahsis edilir, bu da unsorted bin saldırısını tetikleyecek ve global değişkenin değerini değiştirecektir, böylece bayrağı almak mümkün olacaktır.
- [**https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html)
- Birleştirme fonksiyonu, eğer geçirilen her iki indeks aynıysa, onu yeniden tahsis edeceği ve ardından serbest bırakacağı için savunmasızdır, ancak serbest bırakılan bölgeye bir pointer döndürür.
- Bu nedenle, **2 chunk oluşturulur**: **chunk0** kendisiyle birleştirilecek ve üst chunk ile konsolide olmasını önlemek için chunk1. Sonra, **chunk0 ile birleştirme fonksiyonu** iki kez çağrılır, bu da free'den sonra kullanma durumuna neden olur.
- Sonra, **`view`** fonksiyonu 2 indeks ile çağrılır (free'den sonra kullanılan chunk'ın indeksi), bu da **bir libc adresini sızdırır**.
- İkili, yalnızca **`global_max_fast`**'dan daha büyük boyutları malloc etmeye yönelik korumalara sahip olduğundan, hızlı bin kullanılmadığı için bir unsorted bin saldırısı kullanılacak ve global değişken `global_max_fast` geçersiz kılınacaktır.
- Sonra, 2 indeks ile edit fonksiyonu çağrılabilir (free'den sonra kullanılan pointer) ve `bk` pointer'ı `p64(global_max_fast-0x10)`'a işaret edecek şekilde geçersiz kılınır. Ardından, yeni bir chunk oluşturmak, daha önce tehlikeye atılmış serbest adresi (0x20) kullanacak ve **unsorted bin saldırısını tetikleyecek**; bu da `global_max_fast`'ı çok büyük bir değerle geçersiz kılacaktır, böylece artık hızlı binlerde chunk'lar oluşturmak mümkün olacaktır.
- Şimdi bir **hızlı bin saldırısı** gerçekleştirilir:
- Öncelikle, **`__free_hook`** konumunda **200 boyutunda hızlı chunk'larla çalışmanın mümkün olduğu keşfedilir**:
- <pre class="language-c"><code class="lang-c">gef➤  p &__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 <__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f <list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f <_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
- Eğer bu konumda 0x200 boyutunda bir hızlı chunk elde edebilirsek, çalıştırılacak bir fonksiyon pointer'ını geçersiz kılmak mümkün olacaktır.
- Bunun için, `0xfc` boyutunda yeni bir chunk oluşturulur ve birleştirilmiş fonksiyon iki kez çağrılır; bu şekilde, hızlı bin içinde `0xfc*2 = 0x1f8` boyutunda serbest bir chunk'a işaret eden bir pointer elde ederiz.
- Sonra, bu chunk'ta edit fonksiyonu çağrılarak bu hızlı binin **`fd`** adresi önceki **`__free_hook`** fonksiyonuna işaret edecek şekilde değiştirilir.
- Ardından, hızlı binin önceki işe yaramaz chunk'ını almak için `0x1f8` boyutunda bir chunk oluşturulur; böylece **`__free_hook`** içinde bir hızlı bin chunk'ı elde edilir ve bu, **`system`** fonksiyonunun adresi ile geçersiz kılınır.
- Ve nihayet, `/bin/sh\x00` dizesini içeren bir chunk serbest bırakılır ve delete fonksiyonu çağrılır; bu, **`__free_hook`** fonksiyonunu tetikler ve bu da sistemin `/bin/sh\x00` parametresi ile işaret etmesine neden olur.
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html)
- Unsorted bin'deki chunk'ları konsolide etmek ve bir libc bilgi sızıntısı elde etmek için 1B taşmasını kötüye kullanmanın ve ardından malloc hook'unu bir gadget adresi ile geçersiz kılmanın başka bir örneği.
- [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
- Sadece `0x100`'den büyük boyutlarda chunk'lar tahsis edebiliriz.
- Unsorted Bin saldırısı kullanarak `global_max_fast`'ı geçersiz kılmak (ASLR nedeniyle 1/16 kez çalışır, çünkü 12 bit değiştirmemiz gerekir, ancak 16 bit değiştirmemiz gerekir).
- Global bir chunk dizisini değiştirmek için hızlı bin saldırısı. Bu, GOT'u değiştirme ve bazı fonksiyonları `system`'a işaret etme yeteneği veren rastgele bir okuma/yazma ilkesidir.

{{#include ../../banners/hacktricks-training.md}}
