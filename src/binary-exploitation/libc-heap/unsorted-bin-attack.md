# Unsorted Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

Unsorted bin nedir hakkında daha fazla bilgi için bu sayfayı kontrol edin:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Unsorted listeler, `bk` adresine `unsorted_chunks (av)` adresini yazma yeteneğine sahiptir. Bu nedenle, bir saldırgan bir unsorted bin içindeki bir chunk'taki **`bk` işaretçisinin adresini değiştirebilirse**, bu adresi **rastgele bir adrese yazma** yeteneğine sahip olabilir; bu da Glibc adreslerini sızdırmak veya bazı savunmaları aşmak için faydalı olabilir.

Yani, temelde bu saldırı, **rastgele bir adreste büyük bir sayı ayarlamaya** olanak tanır. Bu büyük sayı, bir heap adresi veya bir Glibc adresi olabilir. Tipik bir hedef, daha büyük boyutlarda hızlı binler oluşturmak için **`global_max_fast`**'tır (ve bir unsorted bin saldırısından hızlı bin saldırısına geçiş yapar).

> [!TIP]
> [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle) adresinde sağlanan örneğe bakarak ve chunk boyutları için 0x400 yerine 0x4000 ve 0x500 yerine 0x5000 kullanarak (Tcache'den kaçınmak için) **günümüzde** **`malloc(): unsorted double linked list corrupted`** hatasının tetiklendiğini görebilirsiniz.
>
> Bu nedenle, bu unsorted bin saldırısı artık (diğer kontrollerin yanı sıra) çift bağlı listeyi düzeltme yeteneğine sahip olmayı da gerektiriyor, böylece `victim->bk->fd == victim` veya `victim->fd == av (arena)` kontrolü geçiliyor; bu, yazmak istediğimiz adresin `fd` konumunda sahte chunk'ın adresini içermesi ve sahte chunk'ın `fd`'sinin arenaya işaret etmesi gerektiği anlamına gelir.

> [!CAUTION]
> Bu saldırının unsorted bin'i bozduğunu unutmayın (bu nedenle küçük ve büyük de). Bu yüzden artık yalnızca **hızlı binlerden tahsisat kullanabiliriz** (daha karmaşık bir program başka tahsisatlar yapabilir ve çökebilir) ve bunu tetiklemek için **aynı boyutta tahsisat yapmalıyız yoksa program çöker.**
>
> **`global_max_fast`**'ı yazmak bu durumda yardımcı olabilir, çünkü hızlı binin tüm diğer tahsisatları exploit tamamlanana kadar yönetebileceğine güveniyoruz.

[**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin_attack/unsorted_explanation/index.html) tarafından sağlanan kod bunu çok iyi açıklıyor, ancak malloc'ları yeterince büyük bir bellek tahsis etmek için değiştirirseniz, böylece Tcache'de sona ermezseniz, daha önce bahsedilen hatanın bu tekniği engellediğini görebilirsiniz: **`malloc(): unsorted double linked list corrupted`**

## Unsorted Bin Infoleak Attack

Bu aslında çok temel bir kavramdır. Unsorted bin'deki chunk'lar işaretçilere sahip olacaktır. Unsorted bin'deki ilk chunk aslında **`fd`** ve **`bk`** bağlantılarına **ana arenanın (Glibc)** bir kısmına işaret eder.\
Bu nedenle, bir chunk'ı unsorted bin içine **yerleştirip okuyabilirseniz** (free sonrası kullanım) veya **en az 1 işaretçiyi yazmadan tekrar tahsis ederseniz** ve ardından **okuyabilirseniz**, bir **Glibc bilgi sızıntısı** elde edebilirsiniz.

Bu yazımda kullanılan benzer bir [**saldırı**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html), 4 chunk yapısını (A, B, C ve D - D yalnızca üst chunk ile konsolidasyonu önlemek için) kötüye kullanmak için B'deki bir null byte taşmasını kullanarak C'nin B'nin kullanılmadığını belirtmesini sağladı. Ayrıca, B'deki `prev_size` verisi değiştirilerek boyutun B'nin boyutu yerine A+B olması sağlandı.\
Sonra C serbest bırakıldı ve A+B ile konsolide edildi (ancak B hala kullanılıyordu). A boyutunda yeni bir chunk tahsis edildi ve ardından libc sızdırılan adresler B'ye yazıldı.

## Referanslar ve Diğer Örnekler

- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap)
- Amaç, 4869'dan büyük bir değerle bir global değişkeni yazmaktır, böylece bayrağı almak mümkün olur ve PIE etkin değildir.
- Rastgele boyutlarda chunk'lar oluşturmak mümkündür ve istenen boyutta bir heap taşması vardır.
- Saldırı, 3 chunk oluşturarak başlar: taşmayı kötüye kullanmak için chunk0, taşma yapılacak chunk1 ve üst chunk'un önceki chunk'larla konsolide olmaması için chunk2.
- Sonra, chunk1 serbest bırakılır ve chunk0, chunk1'in `bk` işaretçisinin işaret ettiği yere taşma yapar: `bk = magic - 0x10`
- Ardından, chunk1 ile aynı boyutta chunk3 tahsis edilir, bu da unsorted bin saldırısını tetikleyecek ve global değişkenin değerini değiştirecektir, böylece bayrağı almak mümkün olacaktır.
- [**https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html)
- Birleştirme işlevi, her iki indeksin aynı olması durumunda onu yeniden tahsis edeceği ve ardından serbest bırakacağı için savunmasızdır, ancak serbest bırakılan bölgeye bir işaretçi döndürür.
- Bu nedenle, **2 chunk oluşturulur**: **chunk0** kendisiyle birleştirilecek ve chunk1 üst chunk ile konsolide olmasını önlemek için. Ardından, **chunk0 ile birleştirme işlevi** iki kez çağrılır, bu da free sonrası kullanım durumunu tetikler.
- Sonra, **`view`** işlevi, free sonrası kullanım chunk'ının indeksi olan 2 ile çağrılır, bu da **bir libc adresini sızdırır**.
- İkili, yalnızca **`global_max_fast`**'dan daha büyük boyutları malloc etmeye yönelik korumalara sahip olduğundan, hızlı bin kullanılmadığı için bir unsorted bin saldırısı kullanılacak ve global değişken `global_max_fast` yazılacaktır.
- Ardından, 2 indeksi ile (free sonrası kullanım işaretçisi) edit işlevi çağrılabilir ve `bk` işaretçisi `p64(global_max_fast-0x10)`'a işaret edecek şekilde yazılabilir. Ardından, daha önce tehlikeye atılmış serbest adresi (0x20) kullanarak yeni bir chunk oluşturmak, **unsorted bin saldırısını tetikleyecek** ve `global_max_fast`'ı çok büyük bir değerle yazacaktır, bu da artık hızlı binlerde chunk oluşturmayı mümkün kılacaktır.
- Şimdi bir **hızlı bin saldırısı** gerçekleştirilir:
- Öncelikle, **`__free_hook`** konumunda hızlı **200 boyutunda chunk'larla çalışmanın mümkün olduğu keşfedilir**:
- <pre class="language-c"><code class="lang-c">gef➤  p &__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 <__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f <list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f <_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
- Bu konumda 0x200 boyutunda hızlı bir chunk elde edebilirsek, çalıştırılacak bir işlev işaretçisini yazmak mümkün olacaktır.
- Bunun için, `0xfc` boyutunda yeni bir chunk oluşturulur ve birleştirilmiş işlev bu işaretçi ile iki kez çağrılır, bu şekilde hızlı bin içinde `0xfc*2 = 0x1f8` boyutunda serbest bir chunk'a işaret eden bir işaretçi elde ederiz.
- Ardından, bu chunk'ta edit işlevi çağrılarak bu hızlı binin **`fd`** adresi önceki **`__free_hook`** işlevine işaret edecek şekilde değiştirilir.
- Ardından, hızlı binin önceki işe yaramaz chunk'ını almak için `0x1f8` boyutunda bir chunk oluşturulur, böylece **`__free_hook`** içinde hızlı bir bin chunk'ı elde etmek için `0x1f8` boyutunda başka bir chunk oluşturulur ve bu, **`system`** işlevinin adresi ile yazılır.
- Ve nihayetinde, `/bin/sh\x00` dizesini içeren bir chunk serbest bırakılır ve delete işlevi çağrılır, bu da **`__free_hook`** işlevini tetikler ve `/bin/sh\x00` parametresi ile system'a işaret eder.
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html)
- Unsorted bin'de chunk'ları konsolide etmek ve bir libc bilgi sızıntısı elde etmek için 1B taşmasını kötüye kullanmanın başka bir örneği ve ardından malloc hook'u bir gadget adresi ile yazmak için hızlı bin saldırısı gerçekleştirilir.
- [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
- Sadece `0x100`'den büyük boyutlarda chunk'lar tahsis edebiliriz.
- Unsorted Bin saldırısı kullanarak `global_max_fast`'ı yazmak (ASLR nedeniyle 1/16 kez çalışır, çünkü 12 bit değiştirmemiz gerekir, ancak 16 bit değiştirmemiz gerekir).
- Global bir chunk dizisini değiştirmek için hızlı bin saldırısı. Bu, GOT'u değiştirme ve bazı işlevleri `system`'a işaret etme yeteneği veren rastgele okuma/yazma ilkesidir.

{{#include ../../banners/hacktricks-training.md}}
