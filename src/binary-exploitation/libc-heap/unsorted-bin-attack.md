# Unsorted Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Kwa maelezo zaidi kuhusu nini kilichokuwa hakijapangwa angalia ukurasa huu:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Orodha zisizopangwa zinaweza kuandika anwani kwa `unsorted_chunks (av)` katika anwani ya `bk` ya kipande. Hivyo, ikiwa mshambuliaji anaweza **kubadilisha anwani ya kiashiria cha `bk`** katika kipande ndani ya orodha isiyopangwa, anaweza **kuandika anwani hiyo katika anwani yoyote** ambayo inaweza kusaidia kuvuja anwani za Glibc au kupita baadhi ya ulinzi.

Kwa hivyo, kimsingi, shambulio hili linaruhusu **kweka nambari kubwa katika anwani yoyote**. Nambari hii kubwa ni anwani, ambayo inaweza kuwa anwani ya heap au anwani ya Glibc. Lengo la kawaida ni **`global_max_fast`** ili kuruhusu kuunda bins za haraka zenye ukubwa mkubwa (na kupita kutoka shambulio la orodha isiyopangwa hadi shambulio la bin haraka).

> [!TIP]
> Kuangalia mfano uliopewa katika [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle) na kutumia 0x4000 na 0x5000 badala ya 0x400 na 0x500 kama ukubwa wa vipande (ili kuepuka Tcache) inawezekana kuona kwamba **sasa** kosa **`malloc(): unsorted double linked list corrupted`** linatokea.
>
> Hivyo, shambulio hili la orodha isiyopangwa sasa (pamoja na ukaguzi mwingine) pia linahitaji kuwa na uwezo wa kurekebisha orodha iliyo na viungo viwili ili hii ipitishwe `victim->bk->fd == victim` au si `victim->fd == av (arena)`, ambayo inamaanisha kwamba anwani tunayotaka kuandika lazima iwe na anwani ya kipande bandia katika nafasi yake ya `fd` na kwamba kipande bandia `fd` kinaelekeza kwenye arena.

> [!CAUTION]
> Kumbuka kwamba shambulio hili linaharibu orodha isiyopangwa (hivyo ndogo na kubwa pia). Hivyo tunaweza tu **kutumia allocations kutoka kwa bin haraka sasa** (programu ngumu zaidi inaweza kufanya allocations nyingine na kuanguka), na ili kuanzisha hili lazima **tuweke ukubwa sawa au programu itanguka.**
>
> Kumbuka kwamba kuandika **`global_max_fast`** kunaweza kusaidia katika kesi hii kwa kuamini kwamba bin haraka itakuwa na uwezo wa kushughulikia allocations zingine zote hadi exploit ikamilike.

Msimbo kutoka [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin_attack/unsorted_explanation/index.html) unaelezea vizuri sana, ingawa ikiwa unabadilisha mallocs ili kuallocate kumbukumbu kubwa ya kutosha ili usiishie katika Tcache unaweza kuona kwamba kosa lililotajwa hapo awali linaonekana likizuia mbinu hii: **`malloc(): unsorted double linked list corrupted`**

## Unsorted Bin Infoleak Attack

Hiki ni dhana ya msingi sana. Vipande katika orodha isiyopangwa vitakuwa na viashiria. Kipande cha kwanza katika orodha isiyopangwa kitakuwa na viungo vya **`fd`** na **`bk`** **vinavyoelekeza sehemu ya arena kuu (Glibc)**.\
Hivyo, ikiwa unaweza **kweka kipande ndani ya orodha isiyopangwa na kukisoma** (tumia baada ya bure) au **kuallocate tena bila kuandika angalau 1 ya viashiria** ili kisha **kusoma** hiyo, unaweza kuwa na **Glibc info leak**.

Shambulio linalofanana [**lililotumika katika andiko hili**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html), lilikuwa kutumia muundo wa vipande 4 (A, B, C na D - D ni tu kuzuia kuunganishwa na kipande cha juu) hivyo overflow ya byte sifuri katika B ilitumika kufanya C ionyeshe kwamba B haikuwa inatumika. Pia, katika B data ya `prev_size` ilibadilishwa hivyo ukubwa badala ya kuwa ukubwa wa B ilikuwa A+B.\
Kisha C ilifutwa, na kuunganishwa na A+B (lakini B bado ilikuwa inatumika). Kipande kipya cha ukubwa A kiliallocatishwa na kisha anwani za libc zilivuja zikaandikwa ndani ya B kutoka ambapo zilivuja.

## References & Other examples

- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap)
- Lengo ni kuandika juu ya variable ya kimataifa yenye thamani kubwa kuliko 4869 ili iwezekane kupata bendera na PIE haijawashwa.
- Inawezekana kuunda vipande vya ukubwa wowote na kuna overflow ya heap yenye ukubwa unaotakiwa.
- Shambulio linaanza kwa kuunda vipande 3: kipande0 ili kutumia overflow, kipande1 ili kujaa na kipande2 ili kipande cha juu kisijunganishwe na vipande vya awali.
- Kisha, kipande1 kinachukuliwa na kipande0 kinajaa ili kiashiria cha `bk` cha kipande1 kiwe: `bk = magic - 0x10`
- Kisha, kipande3 kinaundwa kwa ukubwa sawa na kipande1, ambacho kitachochea shambulio la orodha isiyopangwa na kubadilisha thamani ya variable ya kimataifa, na kufanya iwezekane kupata bendera.
- [**https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html)
- Kazi ya kuunganishwa ina udhaifu kwa sababu ikiwa viashiria vyote viwili vilivyopitishwa ni sawa itafanya realloc juu yake na kisha ifute lakini ikirudisha kiashiria kwa eneo hilo lililofutwa ambalo linaweza kutumika.
- Hivyo, **vipande 2 vinaundwa**: **kipande0** ambacho kitajumuishwa na mwenyewe na kipande1 ili kuzuia kuunganishwa na kipande cha juu. Kisha, **kazi ya kuunganishwa inaitwa na kipande0** mara mbili ambayo itasababisha matumizi baada ya bure.
- Kisha, kazi ya **`view`** inaitwa na index 2 (ambayo ni index ya kipande cha matumizi baada ya bure), ambayo itasababisha **kuvuja anwani ya libc**.
- Kwa kuwa binary ina kinga za kutumia tu malloc ukubwa mkubwa kuliko **`global_max_fast`** hivyo hakuna fastbin inatumika, shambulio la orodha isiyopangwa litatumika kuandika juu ya variable ya kimataifa `global_max_fast`.
- Kisha, inawezekana kuita kazi ya edit na index 2 (kiashiria cha matumizi baada ya bure) na kuandika juu ya kiashiria cha `bk` ili kiwe na `p64(global_max_fast-0x10)`. Kisha, kuunda kipande kipya kutatumia anwani ya bure iliyovunjika (0x20) itasababisha **kuanzisha shambulio la orodha isiyopangwa** kuandika juu ya `global_max_fast` ambayo ni thamani kubwa sana, ikiruhusu sasa kuunda vipande katika fast bins.
- Sasa shambulio la **fast bin** linafanywa:
- Kwanza kabisa inagundulika kwamba inawezekana kufanya kazi na fast **chunks za ukubwa 200** katika eneo la **`__free_hook`**:
- <pre class="language-c"><code class="lang-c">gef➤  p &__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 <__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f <list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f <_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
- Ikiwa tutafanikiwa kupata kipande cha haraka cha ukubwa 0x200 katika eneo hili, itakuwa inawezekana kuandika juu ya kiashiria cha kazi ambacho kitatekelezwa
- Kwa hili, kipande kipya cha ukubwa `0xfc` kinaundwa na kazi ya kuunganishwa inaitwa na kiashiria hicho mara mbili, kwa njia hii tunapata kiashiria kwa kipande kilichofutwa cha ukubwa `0xfc*2 = 0x1f8` katika fast bin.
- Kisha, kazi ya edit inaitwa katika kipande hiki kubadilisha anwani ya **`fd`** ya fast bin hii ili kuelekeza kwenye kazi ya awali ya **`__free_hook`**.
- Kisha, kipande chenye ukubwa `0x1f8` kinaundwa ili kupata kutoka fast bin kipande kisichokuwa na matumizi ili kipande kingine cha ukubwa `0x1f8` kiundwe ili kupata kipande cha haraka katika **`__free_hook`** ambacho kimeandikwa na anwani ya kazi ya **`system`**.
- Na hatimaye kipande kinachoshikilia mfuatano wa `/bin/sh\x00` kinafutwa kwa kuita kazi ya kufuta, ikichochea kazi ya **`__free_hook`** ambayo inaelekeza kwenye system na `/bin/sh\x00` kama parameter.
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html)
- Mfano mwingine wa kutumia overflow ya 1B kuunganisha vipande katika orodha isiyopangwa na kupata kuvuja kwa libc na kisha kufanya shambulio la fast bin ili kuandika juu ya malloc hook na anwani ya gadget moja
- [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
- Tunaweza tu kuallocate vipande vya ukubwa mkubwa kuliko `0x100`.
- Andika juu ya `global_max_fast` kwa kutumia shambulio la Orodha Isiyopangwa (inafanya kazi 1/16 kwa sababu ya ASLR, kwa sababu tunahitaji kubadilisha bits 12, lakini lazima tubadilishe bits 16).
- Shambulio la Fast Bin kubadilisha array ya kimataifa ya vipande. Hii inatoa primitive ya kusoma/kandika isiyo na mipaka, ambayo inaruhusu kubadilisha GOT na kuweka baadhi ya kazi kuelekeza kwenye `system`.

{{#include ../../banners/hacktricks-training.md}}
