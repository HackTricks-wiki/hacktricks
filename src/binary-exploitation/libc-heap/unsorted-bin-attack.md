# Unsorted Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## 基本信息

有关 unsorted bin 是什么的更多信息请查看此页面：


{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Unsorted 列表能够在 chunk 的 `bk` 地址写入 `unsorted_chunks (av)` 的地址。因此，如果攻击者能够**修改位于 unsorted bin 中的 chunk 的 `bk` 指针地址**，他就可能**把该地址写入任意地址**，这对于泄露 Glibc 地址或绕过某些防护很有用。

所以，基本上，这个攻击允许在任意地址**设置一个很大的数值**。这个大数值是一个地址，可以是堆地址或 Glibc 地址。传统的目标是 **`global_max_fast`**，以便允许创建更大尺寸的 fast bin（并从 unsorted bin 攻击转为 fast bin 攻击）。

- 现代注（glibc ≥ 2.39）：`global_max_fast` 变成了一个 8 位全局变量。盲目通过 unsorted-bin 写入指针到此处会破坏相邻的 libc 数据，并且不再可靠地提升 fastbin 限制。在针对 glibc 2.39+ 时，优先选择其他目标或其他原语。见下文“现代限制”并考虑在得到稳定原语后结合其他技术如 [large bin attack](large-bin-attack.md) 或 [fast bin attack](fast-bin-attack.md)。

> [!TIP]
> T> aking 查看由 [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle) 提供的示例，并把 chunk 大小从 0x400 和 0x500 改为 0x4000 和 0x5000（以避免 Tcache），可以看到 **现在** 会触发错误 **`malloc(): unsorted double linked list corrupted`**。
>
> 因此，这种 unsorted bin 攻击现在（以及由于其他检查）也要求能够修复双链表，从而绕过检查 `victim->bk->fd == victim` 或 `victim->fd == av (arena)`，这意味着我们想写入的地址的 `fd` 位置必须包含伪造 chunk 的地址，且该伪造 chunk 的 `fd` 指向 arena。

> [!CAUTION]
> 注意此攻击会破坏 unsorted bin（因此也会影响 small 和 large）。所以我们现在**只能使用来自 fast bin 的分配**（更复杂的程序可能做其他分配并崩溃），并且要触发利用我们必须**分配相同大小否则程序会崩溃。**
>
> 注意覆盖 **`global_max_fast`** 在这种情况下可能有帮助，假设 fast bin 能够处理所有其他分配直到利用完成。

来自 [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin_attack/unsorted_explanation/index.html) 的代码解释得很好，尽管如果你修改 mallocs 以分配足够大的内存从而不进入 Tcache，你可以看到前面提到的错误出现，阻止此技术：**`malloc(): unsorted double linked list corrupted`**

### 写入到底如何发生

- unsorted-bin 写入在 `free` 时触发，当被释放的 chunk 被插入到 unsorted 列表头部。
- 在插入过程中，分配器执行 `bck = unsorted_chunks(av); fwd = bck->fd; victim->bk = bck; victim->fd = fwd; fwd->bk = victim; bck->fd = victim;`
- 如果你能在调用 `free(victim)` 之前将 `victim->bk` 设置为 `(mchunkptr)(TARGET - 0x10)`，最后一句语句就会执行写入：`*(TARGET) = victim`。
- 随后，当分配器处理 unsorted bin 时，完整性检查会验证（在其他检查之外）`bck->fd == victim` 和 `victim->fd == unsorted_chunks(av)`，否则会中止并报 `malloc(): unsorted double linked list corrupted`。因为插入已经将 `victim` 写入 `bck->fd`（我们控制的 `TARGET`），如果写入成功，这些检查就可以被满足。

## 现代限制（glibc ≥ 2.33）

要在当前 glibc 上可靠地使用 unsorted‑bin 写入：

- Tcache 干扰：对于落入 tcache 的大小，free 会被转向 tcache 而不会触及 unsorted bin。要么
  - 使用 > MAX_TCACHE_SIZE（在 64 位默认为 ≥ 0x410）的大小请求，或者
  - 填满相应的 tcache bin（7 个条目），以使额外的 free 到达全局 bins，或者
  - 如果能控制环境，禁用 tcache（例如，设置 GLIBC_TUNABLES glibc.malloc.tcache_count=0）。
- 对 unsorted 列表的完整性检查：在下一次检查 unsorted bin 的分配路径上，glibc 会做（简化）检查：
  - `bck->fd == victim` 和 `victim->fd == unsorted_chunks(av)`；否则会中止并报 `malloc(): unsorted double linked list corrupted`。
  - 这意味着你目标的地址必须能容忍两次写入：第一次在 free 时为 `*(TARGET) = victim`；稍后当 chunk 被移除时为 `*(TARGET) = unsorted_chunks(av)`（分配器会把 `bck->fd` 重写回 bin 头）。选择那些只需要强制写入一个大的非零值就有用的目标。
- 现代利用中的典型稳定目标
  - 应用或全局状态将“较大”值视为标志/限制。
  - 间接原语（例如，为随后的一次 [fast bin attack]({{#ref}}fast-bin-attack.md{{#endref}}) 做设置，或为后续的 write‑what‑where 做准备）。
  - 避免在新版 glibc 上使用 `__malloc_hook`/`__free_hook`：它们在 2.34 中被移除。对于 ≥ 2.39 避免使用 `global_max_fast`（见下一注）。
- 关于近期 glibc 的 `global_max_fast`
  - 在 glibc 2.39+ 上，`global_max_fast` 是一个 8 位全局变量。把堆指针写入它（以扩大 fastbins）的经典技巧不再能可靠工作，并且很可能破坏相邻的分配器状态。优先考虑其他策略。

## 最小利用流程（现代 glibc）

目标：使用 unsorted‑bin 插入原语，实现一次将堆指针写入任意地址的单次任意写，且不导致崩溃。

- 布局/修整
  - 分配 A、B、C，大小足够大以绕过 tcache（例如 0x5000）。C 防止与 top chunk 合并。
- 破坏
  - 从 A 溢出到 B 的 chunk header，将 `B->bk = (mchunkptr)(TARGET - 0x10)` 设置好。
- 触发
  - `free(B)`。在插入时，分配器执行 `bck->fd = B`，因此 `*(TARGET) = B`。
- 后续
  - 如果你计划继续分配并且程序会使用 unsorted bin，预期分配器随后会把 `*(TARGET) = unsorted_chunks(av)`。这两个值通常都很大，可能足以改变那些只检查“是否为大值”的目标的大小/限制语义。

Pseudocode skeleton:
```c
// 64-bit glibc 2.35–2.38 style layout (tcache bypass via large sizes)
void *A = malloc(0x5000);
void *B = malloc(0x5000);
void *C = malloc(0x5000); // guard

// overflow from A into B’s metadata (prev_size/size/.../bk). You must control B->bk.
*(size_t *)((char*)B - 0x8) = (size_t)(TARGET - 0x10); // write fake bk

free(B); // triggers *(TARGET) = B (unsorted-bin insertion write)
```
> [!NOTE]
> • 如果不能通过 size 绕过 tcache，请在释放被破坏的 chunk 之前先把所选 size 的 tcache bin 填满（释放 7 次），这样此次 free 会进入 unsorted。
> • 如果程序在下次分配时由于 unsorted-bin 校验直接 abort，请重新检查在第一次写入后 `victim->fd` 是否仍等于 bin head，以及你的 `TARGET` 在第一次写入后是否保存了精确的 `victim` 指针。

## Unsorted Bin Infoleak Attack

这实际上是一个非常基础的概念。unsorted bin 中的 chunks 会包含指针。unsorted bin 中的第一个 chunk 的 **`fd`** 和 **`bk`** 链接实际上会指向 main arena (Glibc) 的某一部分。\
因此，如果你能把一个 chunk 放入 unsorted bin 并读取它（use after free），或者再次分配它且在重新分配时至少不覆盖其中一个指针以便随后读取，那么你就可以得到一个 **Glibc info leak**。

一个类似的[**attack used in this writeup**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html) 是滥用 4 个 chunk 的结构（A、B、C 和 D —— D 仅用于防止与 top chunk 合并），通过在 B 中发生 1 字节的 null byte overflow 让 C 表示 B 未被使用。同时在 B 中修改 `prev_size` 数据，使得 size 不再是 B 的大小而是 A+B。\
然后释放 C，使其与 A+B 合并（但 B 仍在使用）。之后分配一个大小为 A 的新 chunk，然后把泄露出的 libc 地址写入 B，从 B 中泄露出来。

## References & Other examples

- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap)  
  目标是用大于 4869 的值覆盖一个全局变量，从而可以拿到 flag（程序未启用 PIE）。  
  可以生成任意大小的 chunks，并存在目标大小的 heap overflow。  
  攻击从创建 3 个 chunks 开始：chunk0 用于滥用 overflow，chunk1 将被 overflow，chunk2 用于防止 top chunk 合并之前的 chunks。  
  之后释放 chunk1 并 overflow chunk0，使得 chunk1 的 `bk` 指向：`bk = magic - 0x10`。然后分配 chunk3（与 chunk1 大小相同），这会触发 unsorted bin attack 并修改全局变量的值，从而能拿到 flag。
- [**https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html)  
  merge 函数存在漏洞：如果传入的两个索引相同，它会在该块上做 realloc 然后 free，但返回一个指向已释放区域的指针，该指针可被利用。  
  因此创建了 2 个 chunks：**chunk0**（将与自身合并）和 chunk1（防止与 top chunk 合并）。然后对 chunk0 调用 merge 两次，导致 use after free。接着用 index 2 调用 `view`（即 use-after-free 的索引），这会泄露 libc 地址。由于二进制只能 malloc 大于 `global_max_fast` 的大小，因此不会使用 fastbin，转而使用 unsorted bin attack 去覆盖全局变量 `global_max_fast`。  
  然后可以对 index 2（use-after-free 指针）调用 edit，将 `bk` 指针改写为 `p64(global_max_fast-0x10)`。创建新 chunk 时会使用之前被污染的 free 地址（0x20），这会 **触发 unsorted bin attack** 覆盖 `global_max_fast` 为一个很大的值，从而允许创建 fast bin 的 chunks。  
  接下来执行 **fast bin attack**：  
  首先发现可以在 `__free_hook` 位置使用大小为 0x200 的 fast chunk：  
  <pre class="language-c"><code class="lang-c">gef➤  p &__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 <__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f <list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f <_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
  如果能在该位置获得一个大小为 0x200 的 fast chunk，就可以覆盖一个将被执行的函数指针。  
  为此，创建一个大小为 `0xfc` 的新 chunk，并对该指针调用 merge 两次，这样就得到一个大小为 `0xfc*2 = 0x1f8` 的已释放 chunk 放入 fast bin。然后对该 chunk 调用 edit，将该 fast bin 的 `fd` 指向先前的 `__free_hook`。随后分配一个大小为 `0x1f8` 的 chunk 从 fast bin 取回之前的 useless chunk，再分配另一个 `0x1f8` 的 chunk 以在 `__free_hook` 位置得到一个 fast bin chunk，并将其覆盖为 `system` 的地址。最后创建包含字符串 `/bin/sh\x00` 的 chunk 并释放（调用 delete），触发 `__free_hook`（现在指向 system），以 `/bin/sh\x00` 作为参数执行。
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html)  
  另一个示例：滥用 1B overflow 将 chunks 合并到 unsorted bin，从而获得 libc infoleak，接着进行 fast bin attack 覆盖 malloc hook 为 one gadget 地址。
- [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)  
  只能分配大于 `0x100` 的 chunks。  
  使用 Unsorted Bin attack 覆盖 `global_max_fast`（由于 ASLR，需要修改 12 位但实际必须修改 16 位，成功率约为 1/16）。  
  使用 Fast Bin attack 修改一个全局的 chunk 数组，从而得到任意读写原语，允许修改 GOT 并把某个函数指向 `system`。

## References

- Glibc malloc unsorted-bin integrity checks (example in 2.33 source): https://elixir.bootlin.com/glibc/glibc-2.33/source/malloc/malloc.c
- `global_max_fast` and related definitions in modern glibc (2.39): https://elixir.bootlin.com/glibc/glibc-2.39/source/malloc/malloc.c
{{#include ../../banners/hacktricks-training.md}}
