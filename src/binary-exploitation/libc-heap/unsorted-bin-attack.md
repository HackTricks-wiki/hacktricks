# Unsorted Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Informações Básicas

Para mais informações sobre o que é um unsorted bin, confira esta página:


{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Unsorted lists conseguem escrever o endereço de `unsorted_chunks (av)` no campo `bk` do chunk. Portanto, se um atacante puder **modificar o endereço do ponteiro `bk`** em um chunk dentro do unsorted bin, ele pode ser capaz de **escrever esse endereço em um endereço arbitrário**, o que pode ser útil para recuperar endereços do Glibc ou contornar alguma defesa.

Basicamente, esse ataque permite **colocar um número grande em um endereço arbitrário**. Esse número grande é um endereço, que pode ser um endereço do heap ou do Glibc. Um alvo tradicional era **`global_max_fast`** para permitir criar fast bins com tamanhos maiores (e passar de um unsorted bin attack para um fast bin attack).

- Observação moderna (glibc ≥ 2.39): `global_max_fast` tornou-se uma global de 8 bits. Escrever cegamente um ponteiro lá via unsorted-bin write irá corromper dados adjacentes do libc e não elevará de forma confiável o limite de fastbin. Prefira outros alvos ou primitivas ao atacar glibc 2.39+. Veja "Modern constraints" abaixo e considere combinar com outras técnicas como um [large bin attack](large-bin-attack.md) ou um [fast bin attack]({{#ref}}fast-bin-attack.md{{#endref}}) uma vez que tenha uma primitiva estável.

> [!TIP]
> T> Dando uma olhada no exemplo fornecido em [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle) e usando 0x4000 e 0x5000 em vez de 0x400 e 0x500 como tamanhos de chunk (para evitar Tcache) é possível ver que **hoje em dia** o erro **`malloc(): unsorted double linked list corrupted`** é disparado.
>
> Portanto, esse unsorted bin attack agora (entre outros cheques) também requer ser capaz de consertar a doubly linked list para que isso seja contornado `victim->bk->fd == victim` ou `victim->fd == av (arena)`, o que significa que o endereço onde queremos escrever deve ter o endereço do chunk falso em sua posição `fd` e que o `fd` do chunk falso aponte para a arena.

> [!CAUTION]
> Note que esse ataque corrompe o unsorted bin (portanto small e large também). Assim, agora só podemos **usar alocações do fast bin** (um programa mais complexo pode fazer outras alocações e travar), e para acionar isso devemos **alocar do mesmo tamanho ou o programa irá travar.**
>
> Note que sobrescrever **`global_max_fast`** pode ajudar nesse caso, confiando que o fast bin cuidará de todas as outras alocações até que o exploit seja completado.

O código do [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin_attack/unsorted_explanation/index.html) explica muito bem, embora se você modificar os mallocs para alocar memória grande o suficiente para não cair no Tcache você pode ver que o erro mencionado anteriormente aparece impedindo essa técnica: **`malloc(): unsorted double linked list corrupted`**

### Como a escrita realmente acontece

- The unsorted-bin write is triggered on `free` when the freed chunk is inserted at the head of the unsorted list.
- During insertion, the allocator performs `bck = unsorted_chunks(av); fwd = bck->fd; victim->bk = bck; victim->fd = fwd; fwd->bk = victim; bck->fd = victim;`
- If you can set `victim->bk` to `(mchunkptr)(TARGET - 0x10)` before calling `free(victim)`, the final statement will perform the write: `*(TARGET) = victim`.
- Later, when the allocator processes the unsorted bin, integrity checks will verify (among other things) that `bck->fd == victim` and `victim->fd == unsorted_chunks(av)` before unlinking. Because the insertion already wrote `victim` into `bck->fd` (our `TARGET`), these checks can be satisfied if the write succeeded.

## Restrições modernas (glibc ≥ 2.33)

Para usar unsorted‑bin writes de forma confiável no glibc atual:

- Interferência do Tcache: para tamanhos que caem no tcache, frees são desviados para lá e não tocarão o unsorted bin. Ou
  - faça requisições com tamanhos > MAX_TCACHE_SIZE (≥ 0x410 em 64‑bit por padrão), ou
  - preencha a bin correspondente do tcache (7 entradas) para que frees adicionais atinjam os bins globais, ou
  - se o ambiente for controlável, desative o tcache (por exemplo, GLIBC_TUNABLES glibc.malloc.tcache_count=0).
- Checagens de integridade na unsorted list: no próximo caminho de alocação que examina o unsorted bin, o glibc checa (simplificado):
  - `bck->fd == victim` e `victim->fd == unsorted_chunks(av)`; caso contrário ele aborta com `malloc(): unsorted double linked list corrupted`.
- Isso significa que o endereço que você mira deve tolerar duas escritas: primeiro `*(TARGET) = victim` em tempo de free; depois, enquanto o chunk é removido, `*(TARGET) = unsorted_chunks(av)` (o allocator reescreve `bck->fd` de volta para a cabeça do bin). Escolha alvos onde simplesmente forçar um valor grande não‑zero seja útil.
- Alvos típicos e estáveis em exploits modernos
  - Estado da aplicação ou variáveis globais que tratam valores "grandes" como flags/limites.
  - Primitivas indiretas (por exemplo, preparar para um subsequente [fast bin attack]({{#ref}}fast-bin-attack.md{{#endref}}) ou para pivotar uma escrita write‑what‑where posterior).
  - Evite `__malloc_hook`/`__free_hook` no glibc novo: eles foram removidos na 2.34. Evite `global_max_fast` em ≥ 2.39 (ver nota anterior).
- Sobre `global_max_fast` no glibc recente
  - No glibc 2.39+, `global_max_fast` é uma global de 8‑bits. O truque clássico de escrever um ponteiro de heap ali (para aumentar fastbins) não funciona limpo e provavelmente corromperá o estado do allocator adjacente. Prefira outras estratégias.

## Receita mínima de exploração (glibc moderno)

Objetivo: conseguir uma única escrita arbitrária de um ponteiro do heap para um endereço arbitrário usando a primitiva de inserção do unsorted‑bin, sem travar o programa.

- Layout/grooming
  - Allocate A, B, C with sizes large enough to bypass tcache (e.g., 0x5000). C prevents consolidation with the top chunk.
- Corrupção
  - Overflow from A into B’s chunk header to set `B->bk = (mchunkptr)(TARGET - 0x10)`.
- Gatilho
  - `free(B)`. At insertion time the allocator executes `bck->fd = B`, therefore `*(TARGET) = B`.
- Continuação
  - If you plan to continue allocating and the program uses the unsorted bin, expect the allocator to later set `*(TARGET) = unsorted_chunks(av)`. Both values are typically large and may be enough to change size/limit semantics in targets that only check for "big".

Pseudocode skeleton:
```c
// 64-bit glibc 2.35–2.38 style layout (tcache bypass via large sizes)
void *A = malloc(0x5000);
void *B = malloc(0x5000);
void *C = malloc(0x5000); // guard

// overflow from A into B’s metadata (prev_size/size/.../bk). You must control B->bk.
*(size_t *)((char*)B - 0x8) = (size_t)(TARGET - 0x10); // write fake bk

free(B); // triggers *(TARGET) = B (unsorted-bin insertion write)
```
> [!NOTE]
> • Se não conseguir contornar o tcache pelo tamanho, encha o tcache bin para o tamanho escolhido (7 frees) antes de dar free no chunk corrompido para que o free vá para unsorted.
> • Se o programa abortar imediatamente na próxima allocation devido às checagens do unsorted-bin, reanalise se `victim->fd` ainda é igual ao head do bin e se seu `TARGET` contém o ponteiro exato `victim` após a primeira escrita.

## Unsorted Bin Infoleak Attack

Este é, na verdade, um conceito bem básico. Os chunks no unsorted bin vão ter pointers. O primeiro chunk no unsorted bin terá de fato os links **`fd`** e **`bk`** **apontando para uma parte do main arena (Glibc)**.\
Portanto, se você conseguir **colocar um chunk dentro de um unsorted bin e lê‑lo** (use after free) ou **alocá‑lo novamente sem sobrescrever pelo menos 1 dos pointers** para então **lê‑lo**, você pode obter um **Glibc info leak**.

Um ataque semelhante [**usado neste writeup**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html) consistiu em abusar de uma estrutura de 4 chunks (A, B, C e D - D existe apenas para evitar consolidação com o top chunk) de modo que um null byte overflow em B foi usado para fazer C indicar que B estava unused. Além disso, em B o dado `prev_size` foi modificado de forma que o size, ao invés de ser o size de B, era A+B.\
Então C foi deallocado, e consolidado com A+B (mas B ainda estava in use). Um novo chunk de tamanho A foi alocado e então os endereços libc vazados foram escritos em B, de onde foram leakados.

## References & Other examples

- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap)
- O objetivo é sobrescrever uma variável global com um valor maior que 4869 para que seja possível obter a flag e o PIE não está habilitado.
- É possível gerar chunks de tamanhos arbitrários e existe um heap overflow com o tamanho desejado.
- O ataque começa criando 3 chunks: chunk0 para abusar do overflow, chunk1 para ser overflowed e chunk2 para que o top chunk não consolide os anteriores.
- Então, chunk1 é freed e chunk0 é overflowed até o ponteiro `bk` de chunk1 apontar para: `bk = magic - 0x10`
- Depois, chunk3 é alocado com o mesmo size que chunk1, o que irá disparar o unsorted bin attack e vai modificar o valor da variável global, possibilitando obter a flag.
- [**https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html)
- A função merge é vulnerável porque se ambos os índices passados forem o mesmo ela irá realloc sobre ele e então freeá‑lo, mas retornando um ponteiro para aquela região freed que pode ser usada.
- Portanto, **2 chunks são criados**: **chunk0** que será merged com ele mesmo e chunk1 para prevenir consolidação com o top chunk. Então, a função **merge** é chamada com chunk0 duas vezes o que causará um use after free.
- Depois, a função **`view`** é chamada com o índice 2 (que é o índice do chunk use after free), o que irá **leak um endereço libc**.
- Como o binário tem proteções para só mallocar sizes maiores que **`global_max_fast`** então nenhum fastbin é usado, um unsorted bin attack será usado para sobrescrever a variável global `global_max_fast`.
- Então, é possível chamar a função edit com o índice 2 (o ponteiro do use after free) e sobrescrever o ponteiro `bk` para apontar para `p64(global_max_fast-0x10)`. Então, criar um novo chunk irá usar o endereço previamente comprometido free (0x20) e **disparará o unsorted bin attack** sobrescrevendo o `global_max_fast` para um valor muito grande, permitindo agora criar chunks nos fast bins.
- Agora é realizado um **fast bin attack**:
- Primeiro de tudo descobre‑se que é possível trabalhar com fast **chunks de size 200** na localização de **`__free_hook`**:
- <pre class="language-c"><code class="lang-c">gef➤  p &__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 <__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f <list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f <_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
- Se conseguirmos obter um fast chunk de size 0x200 nessa localização, será possível sobrescrever um function pointer que será executado
- Para isso, um novo chunk de size `0xfc` é criado e a função merged é chamada com esse ponteiro duas vezes, assim obtemos um ponteiro para um chunk freed de size `0xfc*2 = 0x1f8` no fast bin.
- Depois, a função edit é chamada nesse chunk para modificar o endereço **`fd`** desse fast bin para apontar para o anterior function **`__free_hook`**.
- Em seguida, um chunk com size `0x1f8` é criado para recuperar do fast bin o chunk inútil anterior, então outro chunk de size `0x1f8` é criado para obter um fast bin chunk em **`__free_hook`** que é sobrescrito com o endereço da função **`system`**.
- E finalmente um chunk contendo a string `/bin/sh\x00` é freed chamando a função delete, disparando o **`__free_hook`** que aponta para system com `/bin/sh\x00` como parâmetro.
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html)
- Outro exemplo de abuso de um overflow de 1B para consolidar chunks no unsorted bin e obter um libc infoleak e então realizar um fast bin attack para sobrescrever malloc hook com um one gadget address
- [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
- Só podemos alocar chunks de size maior que `0x100`.
- Sobrescrever `global_max_fast` usando um Unsorted Bin attack (funciona 1/16 vezes devido ao ASLR, porque precisamos modificar 12 bits, mas devemos modificar 16 bits).
- Fast Bin attack para modificar um array global de chunks. Isso dá uma primitive de arbitrary read/write, o que permite modificar a GOT e apontar alguma função para `system`.

## References

- Glibc malloc unsorted-bin integrity checks (example in 2.33 source): https://elixir.bootlin.com/glibc/glibc-2.33/source/malloc/malloc.c
- `global_max_fast` and related definitions in modern glibc (2.39): https://elixir.bootlin.com/glibc/glibc-2.39/source/malloc/malloc.c
{{#include ../../banners/hacktricks-training.md}}
