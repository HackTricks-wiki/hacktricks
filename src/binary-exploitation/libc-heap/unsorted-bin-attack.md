# Unsorted Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## 基本情報

未整理ビンについての詳細は、このページを確認してください：

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

未整理リストは、チャンクの `bk` アドレスに `unsorted_chunks (av)` のアドレスを書き込むことができます。したがって、攻撃者が未整理ビン内のチャンクの `bk` ポインタのアドレスを**変更できる**場合、彼は**任意のアドレスにそのアドレスを書き込む**ことができ、これはGlibcのアドレスを漏洩させたり、いくつかの防御を回避するのに役立ちます。

基本的に、この攻撃は**任意のアドレスに大きな数を設定する**ことを可能にします。この大きな数はアドレスであり、ヒープアドレスまたはGlibcアドレスである可能性があります。典型的なターゲットは**`global_max_fast`**であり、これによりより大きなサイズのファストビンを作成できるようになります（未整理ビン攻撃からファストビン攻撃に移行することができます）。

> [!TIP]
> 提供された例を見て、[https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle)で0x4000と0x5000をチャンクサイズとして使用すると（Tcacheを避けるため）、**現在**エラー**`malloc(): unsorted double linked list corrupted`**がトリガーされることがわかります。
>
> したがって、この未整理ビン攻撃は、（他のチェックの中で）ダブルリンクリストを修正できる必要があり、`victim->bk->fd == victim`または`victim->fd == av (arena)`でないことが必要です。これは、書き込みたいアドレスがその`fd`位置にフェイクチャンクのアドレスを持ち、フェイクチャンクの`fd`がアリーナを指していることを意味します。

> [!CAUTION]
> この攻撃は未整理ビンを破損させることに注意してください（したがって小さなものと大きなものも）。したがって、**現在はファストビンからの割り当てのみを使用できます**（より複雑なプログラムは他の割り当てを行い、クラッシュする可能性があります）、これをトリガーするには、**同じサイズを割り当てる必要があります。さもなければプログラムはクラッシュします。**
>
> **`global_max_fast`**を上書きすることは、この場合に役立つかもしれません。ファストビンが他のすべての割り当てを処理できると信頼して、エクスプロイトが完了するまで。

[**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin_attack/unsorted_explanation/index.html)のコードは非常によく説明していますが、mallocを変更してメモリを十分に大きく割り当て、Tcacheに終わらないようにすると、前述のエラーが発生し、この技術を妨げることができます：**`malloc(): unsorted double linked list corrupted`**

## 未整理ビン情報漏洩攻撃

これは実際には非常に基本的な概念です。未整理ビン内のチャンクにはポインタが含まれます。未整理ビンの最初のチャンクは、実際には**`fd`**と**`bk`**リンクが**メインアリーナ（Glibc）の一部を指しています**。\
したがって、チャンクを未整理ビンに**入れて読み取る**（使用後の解放）か、**ポインタの少なくとも1つを上書きせずに再度割り当ててから**それを**読み取る**ことができれば、**Glibc情報漏洩**を得ることができます。

この[**書き込みで使用された攻撃**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html)は、4つのチャンク構造（A、B、C、D - Dはトップチャンクとの統合を防ぐためだけに存在します）を悪用するもので、Bでのヌルバイトオーバーフローを使用してCがBが未使用であることを示すようにしました。また、Bでは`prev_size`データが変更され、サイズがBのサイズではなくA+Bになりました。\
その後、Cが解放され、A+Bと統合されました（ただしBはまだ使用中でした）。サイズAの新しいチャンクが割り当てられ、その後、libcの漏洩アドレスがBに書き込まれ、そこから漏洩しました。

## 参考文献と他の例

- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap)
- 目標は、4869より大きな値でグローバル変数を上書きすることで、フラグを取得できるようにすることです。PIEは有効になっていません。
- 任意のサイズのチャンクを生成でき、希望のサイズでヒープオーバーフローがあります。
- 攻撃は3つのチャンクを作成することから始まります：チャンク0はオーバーフローを悪用し、チャンク1はオーバーフローされ、チャンク2はトップチャンクが前のものと統合しないようにします。
- 次に、チャンク1が解放され、チャンク0がチャンク1の`bk`ポインタを指すようにオーバーフローします：`bk = magic - 0x10`
- 次に、チャンク1と同じサイズのチャンク3が割り当てられ、これが未整理ビン攻撃をトリガーし、グローバル変数の値を変更し、フラグを取得できるようにします。
- [**https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html)
- マージ関数は脆弱であり、渡された両方のインデックスが同じであれば、それを再割り当てし、その後解放しますが、解放された領域へのポインタを返します。
- したがって、**2つのチャンクが作成されます**：**チャンク0**は自分自身とマージされ、チャンク1はトップチャンクとの統合を防ぎます。次に、**マージ関数がチャンク0**に対して2回呼び出され、使用後の解放が発生します。
- 次に、**`view`**関数がインデックス2（使用後の解放チャンクのインデックス）で呼び出され、**libcアドレスが漏洩します**。
- バイナリには**`global_max_fast`**より大きなサイズのみをmallocする保護があるため、ファストビンは使用されず、未整理ビン攻撃が使用されてグローバル変数`global_max_fast`を上書きします。
- 次に、インデックス2（使用後の解放ポインタ）で編集関数を呼び出し、`bk`ポインタを`p64(global_max_fast-0x10)`を指すように上書きします。次に、新しいチャンクを作成すると、以前に妥協された解放アドレス（0x20）が使用され、**未整理ビン攻撃がトリガーされ**、`global_max_fast`が非常に大きな値で上書きされ、ファストビンでチャンクを作成できるようになります。
- その後、**ファストビン攻撃**が実行されます：
- まず、**`__free_hook`**の場所でサイズ200のファストチャンクを操作できることが発見されます：
- <pre class="language-c"><code class="lang-c">gef➤  p &__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 <__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f <list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f <_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
- この場所でサイズ0x200のファストチャンクを取得できれば、実行される関数ポインタを上書きすることが可能になります。
- そのために、サイズ`0xfc`の新しいチャンクを作成し、そのポインタでマージ関数を2回呼び出します。これにより、ファストビン内のサイズ`0xfc*2 = 0x1f8`の解放されたチャンクへのポインタを取得します。
- 次に、このチャンクの編集関数が呼び出され、このファストビンの**`fd`**アドレスを前の**`__free_hook`**関数を指すように変更します。
- 次に、サイズ`0x1f8`のチャンクが作成され、ファストビンから以前の無駄なチャンクを取得し、別のサイズ`0x1f8`のチャンクが作成され、**`__free_hook`**内のファストビンチャンクが**`system`**関数のアドレスで上書きされます。
- 最後に、文字列`/bin/sh\x00`を含むチャンクが削除関数を呼び出して解放され、**`__free_hook`**関数がトリガーされ、`system`が`/bin/sh\x00`をパラメータとして指します。
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html)
- 1Bオーバーフローを悪用して未整理ビン内のチャンクを統合し、libc情報漏洩を取得し、その後ファストビン攻撃を実行してmallocフックをワンガジェットアドレスで上書きする別の例
- [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
- サイズ`0x100`より大きなチャンクのみを割り当てることができます。
- 未整理ビン攻撃を使用して`global_max_fast`を上書きします（ASLRのために1/16回機能します。12ビットを変更する必要がありますが、16ビットを変更する必要があります）。
- グローバルチャンク配列を変更するためのファストビン攻撃。これにより、任意の読み取り/書き込みプリミティブが得られ、GOTを変更していくつかの関数を`system`を指すように設定できます。

{{#include ../../banners/hacktricks-training.md}}
