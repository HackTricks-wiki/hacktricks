# Unsorted Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

Unsorted bin nedir hakkında daha fazla bilgi için bu sayfayı kontrol edin:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Unsorted listeler, `bk` adresine `unsorted_chunks (av)` adresini yazma yeteneğine sahiptir. Bu nedenle, bir saldırgan bir unsorted bin içindeki bir chunk'taki **`bk` işaretçisinin adresini değiştirebilirse**, bu adresi **rastgele bir adrese yazabilir** ki bu da Glibc adreslerini sızdırmak veya bazı savunmaları aşmak için faydalı olabilir.

Yani, temelde bu saldırı, **rastgele bir adreste büyük bir sayı ayarlamaya** olanak tanır. Bu büyük sayı, bir heap adresi veya bir Glibc adresi olabilir. Tipik bir hedef, daha büyük boyutlarda hızlı binler oluşturmak için **`global_max_fast`**'tır (ve bir unsorted bin saldırısından hızlı bin saldırısına geçiş yapar).

> [!TIP]
> Örnek için [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle) adresine bakarak 0x4000 ve 0x5000 kullanarak chunk boyutları olarak 0x400 ve 0x500 yerine (Tcache'den kaçınmak için) **günümüzde** **`malloc(): unsorted double linked list corrupted`** hatasının tetiklendiğini görebilirsiniz.
>
> Bu nedenle, bu unsorted bin saldırısı artık (diğer kontroller arasında) çift bağlı listeyi düzeltme yeteneğine de ihtiyaç duyar, böylece `victim->bk->fd == victim` veya `victim->fd == av (arena)` atlanır, bu da yazmak istediğimiz adresin `fd` konumunda sahte chunk'ın adresini bulundurması ve sahte chunk'ın `fd`'sinin arenaya işaret etmesi gerektiği anlamına gelir.

> [!CAUTION]
> Bu saldırının unsorted bin'i bozduğunu unutmayın (bu nedenle küçük ve büyük de). Bu nedenle, artık yalnızca **hızlı binlerden tahsisat kullanabiliriz** (daha karmaşık bir program başka tahsisatlar yapabilir ve çökebilir) ve bunu tetiklemek için **aynı boyutta tahsisat yapmalıyız yoksa program çöker.**
>
> **`global_max_fast`**'ı geçersiz kılmak bu durumda yardımcı olabilir, çünkü hızlı binin tüm diğer tahsisatları exploit tamamlanana kadar yönetebileceğini varsayıyoruz.

[**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin_attack/unsorted_explanation/index.html) tarafından verilen kod bunu çok iyi açıklıyor, ancak malloc'ları yeterince büyük bir bellek tahsis etmek için değiştirirseniz, böylece Tcache'de sona ermezseniz, daha önce bahsedilen hatanın bu tekniği engellediğini görebilirsiniz: **`malloc(): unsorted double linked list corrupted`**

## Unsorted Bin Infoleak Attack

Bu aslında çok temel bir kavramdır. Unsorted bin'deki chunk'lar işaretçilere sahip olacaktır. Unsorted bin'deki ilk chunk aslında **`fd`** ve **`bk`** bağlantılarına **ana arenanın (Glibc)** bir kısmına işaret edecektir.\
Bu nedenle, bir chunk'ı unsorted bin içine **yerleştirip okuyabilirseniz** (use after free) veya **en az 1 işaretçiyi geçersiz kılmadan tekrar tahsis ederseniz** ve ardından **okuyabilirseniz**, bir **Glibc bilgi sızıntısı** elde edebilirsiniz.

Bu yazımda kullanılan benzer bir [**saldırı**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html), 4 chunk yapısını (A, B, C ve D - D yalnızca üst chunk ile konsolidasyonu önlemek için) kötüye kullanmak için B'deki null byte taşmasını kullanarak C'nin B'nin kullanılmadığını belirtmesini sağladı. Ayrıca, B'deki `prev_size` verisi değiştirilerek boyut B'nin boyutu yerine A+B olarak ayarlandı.\
Sonra C serbest bırakıldı ve A+B ile konsolide edildi (ancak B hala kullanılıyordu). A boyutunda yeni bir chunk tahsis edildi ve ardından libc sızdırılan adresler B'ye yazıldı ve buradan sızdırıldı.

## Referanslar ve Diğer Örnekler

- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap)
- Amaç, 4869'dan büyük bir değerle bir global değişkeni geçersiz kılmak, böylece bayrağı almak mümkün olur ve PIE etkin değildir.
- Rastgele boyutlarda chunk'lar oluşturmak mümkündür ve istenen boyutta bir heap taşması vardır.
- Saldırı, 3 chunk oluşturarak başlar: taşmayı kötüye kullanmak için chunk0, taşma yapılacak chunk1 ve üst chunk'un önceki chunk'larla konsolide olmaması için chunk2.
- Sonra, chunk1 serbest bırakılır ve chunk0, chunk1'in `bk` işaretçisinin işaret ettiği yere taşar: `bk = magic - 0x10`
- Ardından, chunk1 ile aynı boyutta chunk3 tahsis edilir, bu da unsorted bin saldırısını tetikleyecek ve global değişkenin değerini değiştirecektir, böylece bayrağı almak mümkün olacaktır.
- [**https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html)
- Birleştirme işlevi, her iki geçirilen indeks aynı olduğunda onu yeniden tahsis edeceği ve ardından serbest bırakacağı için savunmasızdır, ancak serbest bırakılan bölgeye bir işaretçi döndürür.
- Bu nedenle, **2 chunk oluşturulur**: **chunk0** kendisiyle birleştirilecek ve üst chunk ile konsolide olmasını önlemek için chunk1. Ardından, **birleştirme işlevi chunk0 ile** iki kez çağrılır, bu da bir use after free durumuna neden olur.
- Sonra, **`view`** işlevi 2. indeksle (use after free chunk'ın indeksi) çağrılır, bu da **bir libc adresini sızdırır**.
- İkili, yalnızca **`global_max_fast`**'dan daha büyük boyutları malloc etmeye izin verecek şekilde korumalara sahip olduğundan, hızlı bin kullanılmadığı için bir unsorted bin saldırısı kullanılacak ve global değişken `global_max_fast` geçersiz kılınacaktır.
- Ardından, 2. indeksle (use after free işaretçisi) edit işlevi çağrılabilir ve `bk` işaretçisi `p64(global_max_fast-0x10)`'a işaret edecek şekilde geçersiz kılınır. Ardından, yeni bir chunk oluşturmak, daha önce tehlikeye atılmış serbest adresi (0x20) kullanacak ve **unsorted bin saldırısını tetikleyecek** ve `global_max_fast`'ı çok büyük bir değerle geçersiz kılacaktır, bu da artık hızlı binlerde chunk oluşturmayı mümkün kılacaktır.
- Şimdi bir **hızlı bin saldırısı** gerçekleştirilir:
- Öncelikle, **`__free_hook`** konumunda hızlı **200 boyutunda chunk'larla çalışmanın mümkün olduğu keşfedilir**:
- <pre class="language-c"><code class="lang-c">gef➤  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
- Bu konumda 0x200 boyutunda hızlı bir chunk elde edebilirsek, çalıştırılacak bir işlev işaretçisini geçersiz kılmak mümkün olacaktır.
- Bunun için, `0xfc` boyutunda yeni bir chunk oluşturulur ve birleştirilmiş işlev bu işaretçi ile iki kez çağrılır, bu şekilde hızlı bin içinde `0xfc*2 = 0x1f8` boyutunda serbest bir chunk'a işaret eden bir işaretçi elde ederiz.
- Ardından, bu chunk'taki edit işlevi çağrılarak bu hızlı binin **`fd`** adresi önceki **`__free_hook`** işlevine işaret edecek şekilde değiştirilir.
- Ardından, hızlı binin içinden önceki işe yaramaz chunk'ı almak için `0x1f8` boyutunda bir chunk oluşturulur, böylece **`__free_hook`** içinde bir hızlı bin chunk'ı elde etmek için `0x1f8` boyutunda başka bir chunk oluşturulur ve bu, **`system`** işlevinin adresi ile geçersiz kılınır.
- Ve nihayetinde, `/bin/sh\x00` dizesini içeren bir chunk serbest bırakılır ve delete işlevi çağrılır, bu da **`__free_hook`** işlevini tetikler ve bu işlev **`system`**'a `/bin/sh\x00` parametresi ile işaret eder.
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html)
- Unsorted Bin saldırısını kötüye kullanarak bir 1B taşmasını kullanarak libc bilgi sızıntısı elde etme ve ardından malloc hook'u bir gadget adresi ile geçersiz kılma örneği.
- [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
- Sadece `0x100`'den büyük boyutlarda chunk'lar tahsis edebiliriz.
- Unsorted Bin saldırısını kullanarak `global_max_fast`'ı geçersiz kılma (ASLR nedeniyle 1/16 kez çalışır, çünkü 12 bit değiştirmemiz gerekir, ancak 16 bit değiştirmeliyiz).
- Global bir chunk dizisini değiştirmek için hızlı bin saldırısı. Bu, GOT'u değiştirme ve bazı işlevleri `system`'a işaret etme yeteneği veren rastgele bir okuma/yazma ilkesidir.

{{#include ../../banners/hacktricks-training.md}}
