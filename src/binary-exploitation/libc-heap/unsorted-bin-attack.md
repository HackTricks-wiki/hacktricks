# Unsorted Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Osnovne informacije

Za više informacija o tome šta je unsorted bin pogledajte ovu stranicu:


{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Unsorted liste mogu da upišu adresu u `unsorted_chunks (av)` u `bk` adresu chunk‑a. Dakle, ako napadač može **izmeniti adresu `bk` pokazivača** u chunk‑u unutar unsorted bin, mogao bi biti u mogućnosti da **upiše tu adresu na proizvoljnu lokaciju**, što može pomoći da se leak Glibc adresa ili da se zaobiđu neke odbrane.

Dakle, u suštini, ovaj napad omogućava da se **postavi veliki broj na proizvoljnu adresu**. Taj veliki broj je adresa, koja može biti heap adresa ili Glibc adresa. Tradicionalni cilj je bio **`global_max_fast`** kako bi se omogućilo kreiranje fast bin‑ova sa većim veličinama (i prelazak iz unsorted bin napada u fast bin napad).

- Modern note (glibc ≥ 2.39): `global_max_fast` became an 8‑bit global. Blindly writing a pointer there via an unsorted-bin write will clobber adjacent libc data and will not reliably raise the fastbin limit anymore. Prefer other targets or other primitives when running against glibc 2.39+. See "Modern constraints" below and consider combining with other techniques like a [large bin attack](large-bin-attack.md) or a [fast bin attack](fast-bin-attack.md) once you have a stable primitive.

> [!TIP]
> T> Ako pogledate primer dat na [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle) i koristite 0x4000 i 0x5000 umesto 0x400 i 0x500 kao veličine chunk‑ova (da izbegnete Tcache), može se videti da se **sada** javlja greška **`malloc(): unsorted double linked list corrupted`**.
>
> Dakle, ovaj unsorted bin napad sada (pored drugih provera) takođe zahteva mogućnost da se ispravi dvostruko povezani spisak da bi se zaobišle provere `victim->bk->fd == victim` ili `victim->fd == av (arena)`, što znači da adresa na koju želimo da upišemo mora imati adresu lažnog chunk‑a u svojoj `fd` poziciji i da lažni chunk‑ov `fd` pokazuje na arena.

> [!CAUTION]
> Imajte na umu da ovaj napad korumpira unsorted bin (a time i small i large). Zato sada možemo da **koristimo samo alokacije iz fast bin‑a** (komplikovaniji program može uraditi druge alokacije i srušiti se), i da bismo ovo pokrenuli moramo **alokirati istu veličinu ili će program puknuti.**
>
> Takođe, prepisivanje **`global_max_fast`** može pomoći u ovom slučaju ukoliko se veruje da će fast bin uspeti da opsluži sve ostale alokacije dok exploit ne bude završen.

Kod od [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin_attack/unsorted_explanation/index.html) to vrlo dobro objašnjava, i ipak ako modifikujete malloc pozive da alociraju memoriju dovoljno veliku da ne završe u Tcache, možete videti da se ranije pomenuta greška pojavljuje i onemogućava ovu tehniku: **`malloc(): unsorted double linked list corrupted`**

### Kako se upis zapravo dešava

- Unsorted‑bin upis se aktivira pri `free` kada se oslobođeni chunk umetne na početak unsorted liste.
- Tokom umetanja, alokator izvršava `bck = unsorted_chunks(av); fwd = bck->fd; victim->bk = bck; victim->fd = fwd; fwd->bk = victim; bck->fd = victim;`
- Ako možete postaviti `victim->bk` na `(mchunkptr)(TARGET - 0x10)` pre nego što pozovete `free(victim)`, finalna naredba će izvršiti upis: `*(TARGET) = victim`.
- Kasnije, kada alokator procesuira unsorted bin, integritet provere će verificirati (između ostalog) da je `bck->fd == victim` i `victim->fd == unsorted_chunks(av)` pre nego što uradi unlink. Pošto je umetanje već upisalo `victim` u `bck->fd` (naš `TARGET`), ove provere mogu biti zadovoljene ako je upis uspeo.

## Savremena ograničenja (glibc ≥ 2.33)

Da biste pouzdano koristili unsorted‑bin upise na trenutnim glibc verzijama:

- Interferencija tcache‑a: za veličine koje spadaju u tcache, free pozivi se preusmeravaju tamo i neće dotaknuti unsorted bin. Ili:
  - pravite zahteve sa veličinama > MAX_TCACHE_SIZE (≥ 0x410 na 64‑bit po defaultu), ili
  - napunite odgovarajući tcache bin (7 unosa) tako da dodatni free‑ovi dospeju do globalnih binova, ili
  - ako je okruženje kontrolisano, onemogućite tcache (npr. GLIBC_TUNABLES glibc.malloc.tcache_count=0).
- Provere integriteta na unsorted listi: pri sledećem putu alokacije koji pregleda unsorted bin, glibc proverava (pojednostavljeno):
  - `bck->fd == victim` i `victim->fd == unsorted_chunks(av)`; u suprotnom abortira sa `malloc(): unsorted double linked list corrupted`.
- To znači da adresa koju ciljate mora podneti dva upisa: prvo `*(TARGET) = victim` u vreme free‑a; kasnije, dok se chunk uklanja, `*(TARGET) = unsorted_chunks(av)` (alokator ponovo upisuje `bck->fd` nazad na glavu binga). Birajte ciljeve gde jednostavno forsiranje velike nenultе vrednosti ima smisla.
- Tipični stabilni ciljevi u modernim exploitima:
  - Stanje aplikacije ili globalno stanje koje tretira "velike" vrednosti kao zastavice/limite.
  - Indirektni primitivи (npr. priprema za naknadni [fast bin attack]({{#ref}}fast-bin-attack.md{{#endref}}) ili da se pivotira kasniji write‑what‑where).
- Izbegavajte `__malloc_hook`/`__free_hook` na novom glibc: uklonjeni su u 2.34. Izbegavajte `global_max_fast` na ≥ 2.39 (vidi sledeću napomenu).
- O `global_max_fast` na novijim glibc:
  - Na glibc 2.39+, `global_max_fast` je 8‑bitna globalna promenljiva. Klasičan trik upisa heap pokazivača u nju (da bi se povećali fastbin‑i) više ne funkcioniše čisto i verovatno će korumpirati susedno stanje alokatora. Preferirajte druge strategije.

## Minimalni recept za eksploataciju (moderni glibc)

Cilj: postići jedan proizvoljan upis heap pokazivača na proizvoljnu adresu koristeći unsorted‑bin insertion primitiv, bez pada programa.

- Raspored / priprema
  - Alocirajte A, B, C sa veličinama dovoljno velikim da zaobiđu tcache (npr. 0x5000). C sprečava konsolidaciju sa top chunk‑om.
- Korupcija
  - Overflow iz A u B‑jev chunk header da se postavi `B->bk = (mchunkptr)(TARGET - 0x10)`.
- Okidač
  - `free(B)`. U vreme umetanja alokator izvršava `bck->fd = B`, dakle `*(TARGET) = B`.
- Nastavak
  - Ako planirate da nastavite sa alokacijama i program koristi unsorted bin, očekujte da će alokator kasnije postaviti `*(TARGET) = unsorted_chunks(av)`. Obe vrednosti su tipično velike i mogu biti dovoljne da promene semantiku veličine/limita u ciljevima koji samo proveravaju da li je vrednost "velika".

Pseudokod skelet:
```c
// 64-bit glibc 2.35–2.38 style layout (tcache bypass via large sizes)
void *A = malloc(0x5000);
void *B = malloc(0x5000);
void *C = malloc(0x5000); // guard

// overflow from A into B’s metadata (prev_size/size/.../bk). You must control B->bk.
*(size_t *)((char*)B - 0x8) = (size_t)(TARGET - 0x10); // write fake bk

free(B); // triggers *(TARGET) = B (unsorted-bin insertion write)
```
> [!NOTE]
> • Ako ne možete да заобиђете tcache помоћу величине, попуните tcache bin за изабрану величину (7 frees) пре него што ослободите corrupted chunk тако да free иде у unsorted.
> • Ако програм одмах abort-ује при следећој алокацији због unsorted-bin checks, поново проверите да ли `victim->fd` и даље једнако вреди као bin head и да ли ваш `TARGET` држи тачан `victim` pointer након првог write-а.

## Unsorted Bin Infoleak Attack

This is actually a very basic concept. The chunks in the unsorted bin are going to have pointers. The first chunk in the unsorted bin will actually have the **`fd`** and the **`bk`** links **pointing to a part of the main arena (Glibc)**.\
Therefore, if you can **put a chunk inside a unsorted bin and read it** (use after free) or **allocate it again without overwriting at least 1 of the pointers** to then **read** it, you can have a **Glibc info leak**.

A similar [**attack used in this writeup**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html), was to abuse a 4 chunks structure (A, B, C and D - D is only to prevent consolidation with top chunk) so a null byte overflow in B was used to make C indicate that B was unused. Also, in B the `prev_size` data was modified so the size instead of being the size of B was A+B.\
Then C was deallocated, and consolidated with A+B (but B was still in used). A new chunk of size A was allocated and then the libc leaked addresses was written into B from where they were leaked.

## References & Other examples

- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap)
- Cilj је prepisati globalnu promenljivu са вредношћу већом од 4869 тако да је могуће добити flag и PIE није омогућен.
- Moguće је генерисати chunke произвољних величина и постоји heap overflow тражене величине.
- Напад почиње креирањем 3 chunka: chunk0 за злоупотребу overflow-а, chunk1 који ће бити overflow-ован и chunk2 да top chunk не консолидује претходне.
- Затим је chunk1 freed и chunk0 је overflow-ован тако да `bk` pointer chunk1 показује на: `bk = magic - 0x10`
- Затим се алоцира chunk3 исте величине као chunk1, што ће покренути unsorted bin attack и измењити вредност глобалне променљиве, омогућавајући добијање flag-а.
- [**https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html)
- merge функција је ranjiva јер ако су оба prosleđena index-а иста, она ће uraditi realloc на њему па затим free-овати, али вратити pointer на тај freed region који се може искористити.
- Због тога се креирају **2 chunka**: **chunk0** који ће бити merged са собом и chunk1 да спречи консолидовање са top chunk-ом. Затим се **merge функција позива са chunk0** два пута што ће изазвати use after free.
- Затим се позива **`view`** функция са index-ом 2 (што је index use-after-free chunka), која ће **leak a libc address**.
- Како бинарани има заштите да malloc-ује само величине веће од **`global_max_fast`** па се не користи fastbin, користи се unsorted bin attack да препише глобалну променљиву `global_max_fast`.
- Затим је могуће позвати edit функцију са index-ом 2 (use-after-free pointer) и преписати `bk` pointer да показује на `p64(global_max_fast-0x10)`. Након тога, креирање новог chunka ће користити раније kompromitovan free address (0x20) и **trigger the unsorted bin attack**, преписујући `global_max_fast` великом вредношћу, што омогућава сада креирање chunk-ова у fast bin-овима.
- Now a **fast bin attack** is performed:
- Pre svega, откривено је да је могуће радити са fast **chunk-ovima величине 200** на локацији **`__free_hook`**:
- <pre class="language-c"><code class="lang-c">gef➤  p &__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 <__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f <list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f <_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
- Ако успемо да добијемо fast chunk величине 0x200 у овој локацији, биће могуће преписати функцијски показивач који ће бити извршен.
- За ово се креира нови chunk величине `0xfc` и merge функција се позива са тим pointer-ом два пута, на тај начин добијамо pointer на freed chunk величине `0xfc*2 = 0x1f8` у fast bin-у.
- Затим се на том chunку позива edit функција да модификује **`fd`** адресу овог fast bin-а тако да показује на претходни **`__free_hook`**.
- Затим се креира chunk величине `0x1f8` да би се из fast bin-а извукao претходни бескорисни chunk, па се још један chunk исте величине креира да би се добио fast bin chunk на месту **`__free_hook`** који се преписује адресом функције **`system`**.
- И на крају, chunk који садржи string `/bin/sh\x00` се free-ује позивом delete функције, што trigger-ује **`__free_hook`** функцију која сада показује на system са `/bin/sh\x00` као параметром.
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html)
- Joш један пример злоупотребе 1B overflow-а да се консолидују chunk-ови у unsorted bin и добије libc infoleak, а затим изврши fast bin attack да се overwrite-у malloc hook са one gadget адресом
- [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
- Можемо алоцирати само chunke величине веће од `0x100`.
- Препиши `global_max_fast` коришћењем Unsorted Bin attack (ради 1/16 пута због ASLR-а, јер треба модификовати 12 битова, али морамо модификовати 16).
- Fast Bin attack да модификује глобални низ chunk-ова. Ово даје арбитрарни read/write примитив, што омогућава модификацију GOT-а и подешавање неке функције да показује на `system`.

## References

- Glibc malloc unsorted-bin integrity checks (example in 2.33 source): https://elixir.bootlin.com/glibc/glibc-2.33/source/malloc/malloc.c
- `global_max_fast` and related definitions in modern glibc (2.39): https://elixir.bootlin.com/glibc/glibc-2.39/source/malloc/malloc.c
{{#include ../../banners/hacktricks-training.md}}
