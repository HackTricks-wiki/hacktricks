# Unsorted Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## बुनियादी जानकारी

Unsorted bin क्या है इसके बारे में अधिक जानकारी के लिए इस पृष्ठ को देखें:


{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Unsorted lists `unsorted_chunks (av)` के पते को chunk के `bk` एड्रेस में लिखने में सक्षम होती हैं। इसलिए, यदि एक attacker किसी chunk के अंदर unsorted bin में `bk` pointer का address बदल सके, तो वह उस address को arbitrary address में लिखने में सक्षम हो सकता है जो Glibc addresses को leak करने या कुछ defenses को bypass करने में मददगार हो सकता है।

संक्षेप में, यह attack arbitrary address पर एक बड़ा नंबर सेट करने की अनुमति देता है। यह बड़ा नंबर एक address होता है, जो heap address या Glibc address हो सकता है। पारंपरिक लक्ष्य अक्सर **`global_max_fast`** था ताकि fast bin बड़ाई जा सके (और unsorted bin attack से fast bin attack में परिवर्तित किया जा सके)।

- Modern note (glibc ≥ 2.39): `global_max_fast` अब एक 8‑bit global बन गया है। unsorted‑bin write के जरिए वहाँ pointer लिखने से आसपास के libc डेटा corrupt होंगे और fastbin limit को विश्वसनीय रूप से बढ़ाना अब संभव नहीं रहेगा। चल रहे संस्करणों पर अन्य targets या primitives चुनें। नीचे "Modern constraints" देखें और एक stable primitive मिलने पर इसे [large bin attack](large-bin-attack.md) या [fast bin attack](fast-bin-attack.md) जैसी अन्य techniques के साथ combine करने पर विचार करें।

> [!TIP]
> T> https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle पर दिए उदाहरण को देखकर और chunk sizes के लिए 0x400 और 0x500 की जगह 0x4000 और 0x5000 इस्तेमाल करने (ताकि Tcache से बचा जा सके) पर आप देखेंगे कि **आधुनिक समय में** error **`malloc(): unsorted double linked list corrupted`** trigger होती है।
>
> इसलिए, यह unsorted bin attack अब (अन्य checks के साथ) दो-तरफ़ा linked list को ठीक करने की आवश्यकता भी रखता है ताकि यह bypass किया जा सके — यानी `victim->bk->fd == victim` या `victim->fd == av (arena)` verify हो। इसका मतलब है कि जिस address में आप लिखना चाहते हैं उसके `fd` position में fake chunk का address होना चाहिए और fake chunk का `fd` arena की तरफ इशारा करना चाहिए।

> [!CAUTION]
> ध्यान दें कि यह attack unsorted bin (और इसी के कारण small और large भी) को corrupt करता है। इसलिए अब हम केवल fast bin से allocations का उपयोग कर सकते हैं (एक जटिल प्रोग्राम अन्य allocations करेगा और crash कर सकता है), और इसे ट्रिगर करने के लिए हमें वही size allocate करनी होगी वरना प्रोग्राम crash करेगा।
>
> यह भी ध्यान दें कि **`global_max_fast`** को overwrite करना इस केस में मदद कर सकता है, यह मानते हुए कि fast bin exploit पूरा होने तक बाकी allocations को संभाल लेगा।

यहां [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin_attack/unsorted_explanation/index.html) का कोड इसे बहुत अच्छे से समझाता है, हालांकि अगर आप mallocs को इतना बड़ा बदल दें कि वे Tcache में न पड़ें तो आप ऊपर बताए error को देखेंगे: **`malloc(): unsorted double linked list corrupted`**

### लिखाई असल में कैसे होती है

- Unsorted‑bin write `free` पर trigger होती है जब freed chunk unsorted list के head में insert किया जाता है।
- insertion के दौरान allocator यह करता है: `bck = unsorted_chunks(av); fwd = bck->fd; victim->bk = bck; victim->fd = fwd; fwd->bk = victim; bck->fd = victim;`
- अगर आप `free(victim)` कॉल करने से पहले `victim->bk` को `(mchunkptr)(TARGET - 0x10)` सेट कर सकें, तो अंतिम statement यह write करेगा: `*(TARGET) = victim`।
- बाद में, जब allocator unsorted bin को process करता है, तो integrity checks यह verify करेंगे (अन्य चीजों के साथ) कि `bck->fd == victim` और `victim->fd == unsorted_chunks(av)` unlink करने से पहले। क्योंकि insertion पहले ही `bck->fd` (हमारा `TARGET`) में `victim` लिख चुका होता है, ये checks तब सफल हो सकते हैं अगर write सफल रही।

## आधुनिक बाधाएँ (glibc ≥ 2.33)

वर्तमान glibc पर unsorted‑bin writes को भरोसेमंद रूप से उपयोग करने के लिए:

- Tcache हस्तक्षेप: उन sizes के लिए जो tcache में आते हैं, frees वहाँ divert हो जाते हैं और unsorted bin को नहीं छूते। या तो
  - requests को > MAX_TCACHE_SIZE (64‑bit पर डिफ़ॉल्ट ≥ 0x410) बनाएं, या
  - संबंधित tcache bin (7 entries) भर दें ताकि अतिरिक्त frees global bins तक पहुँचें, या
  - अगर environment controllable है तो tcache disable करें (जैसे GLIBC_TUNABLES glibc.malloc.tcache_count=0).
- unsorted list पर integrity checks: अगली allocation path जो unsorted bin की जाँच करती है, glibc check करता है (सरल रूप में):
  - `bck->fd == victim` और `victim->fd == unsorted_chunks(av)`; अन्यथा यह `malloc(): unsorted double linked list corrupted` के साथ abort कर देता है।
- इस बात का अर्थ है कि आपका target address दो writes सहन कर सके: पहले free‑time पर `*(TARGET) = victim`; बाद में जब chunk remove होगा तब allocator `*(TARGET) = unsorted_chunks(av)` करेगा (allocator `bck->fd` को फिर से bin head पर rewrite करता है)। ऐसे targets चुनें जहाँ केवल एक बड़ा non‑zero value थोपना उपयोगी हो।
- आधुनिक exploits में सामान्य और स्थिर targets
  - Application या global state जो "large" values को flags/limits की तरह treat करता है।
  - परोक्ष primitives (उदाहरण के लिए, बाद के लिए सेटअप करना जैसे [fast bin attack]({{#ref}}fast-bin-attack.md{{#endref}}) या किसी बाद वाले write‑what‑where को pivot करना)।
  - नए glibc पर `__malloc_hook`/`__free_hook` से बचें: ये 2.34 में हटाए जा चुके हैं। ≥ 2.39 पर `global_max_fast` से बचें (ऊपर नोट देखें)।
- हाल के glibc पर `global_max_fast` के बारे में
  - glibc 2.39+ पर `global_max_fast` एक 8‑bit global है। इसमें heap pointer लिखने की क्लासिक trick अब साफ़ रूप से काम नहीं करती और आस-पास के allocator state को corrupt करने की संभावना रहती है। अन्य रणनीतियाँ अपनाएँ।

## Minimal exploitation recipe (modern glibc)

Goal: unsorted‑bin insertion primitive का उपयोग करके एक heap pointer को arbitrary address पर एक single arbitrary write हासिल करना, बिना crash किए।

- Layout/grooming
  - A, B, C allocate करें जिनके sizes tcache को बायपास करने के लिए बड़े हों (उदाहरण के लिए 0x5000)। C top chunk के साथ consolidation को रोकेगा।
- Corruption
  - A से B के chunk header में overflow करके `B->bk = (mchunkptr)(TARGET - 0x10)` सेट करें।
- Trigger
  - `free(B)`। insertion के समय allocator `bck->fd = B` execute करता है, इसलिए `*(TARGET) = B` होगा।
- Continuation
  - अगर आप आगे allocations करने की योजना बना रहे हैं और प्रोग्राम unsorted bin का उपयोग करता है, तो उम्मीद रखें कि बाद में allocator `*(TARGET) = unsorted_chunks(av)` सेट कर देगा। दोनों मान आमतौर पर बड़े होते हैं और उन targets में size/limit semantics बदलने के लिए पर्याप्त हो सकते हैं जो केवल "big" की जाँच करते हैं।

Pseudocode skeleton:
```c
// 64-bit glibc 2.35–2.38 style layout (tcache bypass via large sizes)
void *A = malloc(0x5000);
void *B = malloc(0x5000);
void *C = malloc(0x5000); // guard

// overflow from A into B’s metadata (prev_size/size/.../bk). You must control B->bk.
*(size_t *)((char*)B - 0x8) = (size_t)(TARGET - 0x10); // write fake bk

free(B); // triggers *(TARGET) = B (unsorted-bin insertion write)
```
> [!NOTE]
> • यदि आप size से tcache को बाइपास नहीं कर पाते हैं, तो चुने गए आकार के लिए tcache bin को भरें (7 frees) पहले corrupted chunk को free करने से पहले ताकि free unsorted में जाए।
> • यदि अगली allocation पर unsorted-bin checks के कारण प्रोग्राम तुरंत abort कर देता है, तो फिर जांचें कि `victim->fd` अभी भी bin head के बराबर है और आपका `TARGET` पहले write के बाद ठीक वही `victim` pointer रखता है।

## Unsorted Bin Infoleak Attack

यह वास्तव में एक बहुत ही बुनियादी अवधारणा है। unsorted bin में जो chunks होते हैं उनमें pointers होते हैं। unsorted bin का पहला chunk वास्तव में **`fd`** और **`bk`** links रखेगा जो **main arena (Glibc)** के एक हिस्से की ओर इशारा करते हैं.\
इसलिए, यदि आप **एक chunk को unsorted bin में रखकर और उसे पढ़कर** (use after free) या **कम से कम 1 pointer को overwrite किए बिना उसे फिर से allocate करके** और फिर **पढ़कर** देख सकें, तो आप **Glibc info leak** प्राप्त कर सकते हैं।

A similar [**attack used in this writeup**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html), था 4 chunks संरचना (A, B, C और D - D केवल top chunk के साथ consolidation रोकने के लिए) का दुरुपयोग करना, इसलिए B में null byte overflow का इस्तेमाल करके C को यह दिखाने के लिए किया गया कि B unused है। साथ ही, B में `prev_size` डेटा को modify किया गया ताकि size B के आकार की बजाय A+B हो।\
फिर C को deallocate किया गया, और A+B के साथ consolidate किया गया (लेकिन B अभी भी इस्तेमाल में था)। A के आकार का नया chunk allocate किया गया और फिर libc leaked addresses को B में लिखा गया जहाँ से वे leak हुए थे।

## References & Other examples

- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap)
- लक्ष्य यह है कि एक global variable को 4869 से बड़ा मान देकर overwrite किया जाए ताकि flag प्राप्त करना संभव हो और PIE enabled न हो।
- किसी भी इच्छित आकार के chunks generate करना संभव है और वहाँ heap overflow मौजूद है जिसकी आकांक्षित size है।
- हमला 3 chunks बनाकर शुरू होता है: chunk0 overflow को abuse करने के लिए, chunk1 जिसे overflow किया जाएगा और chunk2 ताकि top chunk पिछले chunks को consolidate न करे।
- फिर, chunk1 को free किया जाता है और chunk0 को overflow किया जाता है ताकि chunk1 का `bk` pointer इस पर प्वाइंट करे: `bk = magic - 0x10`
- फिर, chunk3 को chunk1 के समान size के साथ allocate किया जाता है, जो unsorted bin attack को trigger करेगा और global variable का मान modify कर देगा, जिससे flag प्राप्त करना संभव हो जाएगा।
- [**https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html)
- merge function vulnerable है क्योंकि यदि दोनों पास किए गए indexes एक ही हों तो यह उस पर realloc करेगा और फिर उसे free कर देगा पर freed region का pointer return करेगा जिसे उपयोग किया जा सकता है।
- इसलिए, **2 chunks बनाए जाते हैं**: **chunk0** जिसे self के साथ merge किया जाएगा और chunk1 ताकि top chunk के साथ consolidation न हो। फिर, **merge function को chunk0 के साथ** दो बार कॉल किया जाता है जिससे use after free होगा।
- फिर, **`view`** function को index 2 के साथ कॉल किया जाता है (जो use after free chunk का index है), जो **libc address leak** करेगा।
- चूंकि binary में protections हैं जो केवल `global_max_fast` से बड़े sizes को malloc करने की अनुमति देते हैं इसलिए कोई fastbin इस्तेमाल नहीं होता, एक unsorted bin attack का उपयोग किया जाएगा ताकि global variable `global_max_fast` को overwrite किया जा सके।
- फिर, edit function को index 2 (use after free pointer) के साथ कॉल किया जा सकता है और `bk` pointer को overwrite करके `p64(global_max_fast-0x10)` की ओर प्वाइंट कराया जा सकता है। फिर, एक नया chunk बनाना पहले compromised free address (0x20) का उपयोग करेगा और यह **unsorted bin attack** को trigger करेगा जिससे `global_max_fast` overwrite हो जाएगा जिससे बहुत बड़ा मान बन जाएगा और अब fast bins में chunks बनाना संभव होगा।
- अब एक **fast bin attack** किया जाता है:
- सबसे पहले पता चलता है कि `__free_hook` location में fast **chunks of size 200** के साथ काम करना संभव है:
- <pre class="language-c"><code class="lang-c">gef➤  p &__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 <__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f <list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f <_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
- यदि हम इस location में size 0x200 का एक fast chunk प्राप्त करने में सफल होते हैं, तो यह एक function pointer को overwrite करने में सक्षम होगा जो execute होगा।
- इसके लिए, size `0xfc` का एक नया chunk बनाया जाता है और उस pointer के साथ merged function को दो बार कॉल किया जाता है, इस तरह हमें fast bin में size `0xfc*2 = 0x1f8` का freed chunk का pointer मिलता है।
- फिर, edit function को इस chunk में कॉल किया जाता है ताकि इस fast bin के **`fd`** address को पिछले **`__free_hook`** function की ओर point करने के लिए modify किया जा सके।
- फिर, size `0x1f8` का एक chunk बनाया जाता है ताकि fast bin से पिछला बेकार chunk निकाला जा सके, फिर एक और size `0x1f8` का chunk बनाया जाता है ताकि `__free_hook` में एक fast bin chunk मिल सके जिसे **`system`** function के address से overwrite किया जाता है।
- और अंत में `/bin/sh\x00` string वाला एक chunk free किया जाता है delete function को कॉल करके, जिससे **`__free_hook`** trigger होता है जो कि system की ओर point करता है और `/bin/sh\x00` को parameter के रूप में देता है।
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html)
- 1B overflow का दुरुपयोग करके chunks को unsorted bin में consolidate कर के libc infoleak हासिल करने और फिर malloc hook को one gadget address से overwrite करने के लिए fast bin attack करने का एक और उदाहरण।
- [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
- हम केवल `0x100` से बड़े आकार के chunks ही allocate कर सकते हैं।
- Unsorted Bin attack का उपयोग करके `global_max_fast` को overwrite करें (ASLR के कारण यह 1/16 बार काम करता है, क्योंकि हमें 12 बिट्स modify करने की जरूरत है, पर हमें 16 बिट्स modify करने होंगे)।
- Fast Bin attack से एक global array of chunks को modify किया जाता है। इससे एक arbitrary read/write primitive मिल जाता है, जो GOT को modify करने और किसी function को `system` की ओर point कराने की अनुमति देता है।

## References

- Glibc malloc unsorted-bin integrity checks (example in 2.33 source): https://elixir.bootlin.com/glibc/glibc-2.33/source/malloc/malloc.c
- `global_max_fast` and related definitions in modern glibc (2.39): https://elixir.bootlin.com/glibc/glibc-2.39/source/malloc/malloc.c
{{#include ../../banners/hacktricks-training.md}}
