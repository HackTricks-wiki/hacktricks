# Unsorted Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Unsorted bin이 무엇인지에 대한 더 많은 정보는 이 페이지를 확인하세요:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Unsorted 리스트는 chunk의 `bk` 주소에 `unsorted_chunks (av)`의 주소를 쓸 수 있습니다. 따라서 공격자가 unsorted bin 내의 chunk에서 **`bk` 포인터의 주소를 수정할 수 있다면**, 그는 **그 주소를 임의의 주소에 쓸 수 있게 되어** Glibc 주소를 유출하거나 일부 방어를 우회하는 데 도움이 될 수 있습니다.

기본적으로 이 공격은 **임의의 주소에 큰 숫자를 설정할 수 있게 해줍니다**. 이 큰 숫자는 주소로, 힙 주소나 Glibc 주소일 수 있습니다. 일반적인 목표는 **`global_max_fast`**로, 더 큰 크기의 fast bin을 생성할 수 있게 해줍니다(unsorted bin 공격에서 fast bin 공격으로 넘어갈 수 있습니다).

> [!TIP]
> [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle)에서 제공된 예제를 살펴보면, chunk 크기로 0x4000과 0x5000을 사용하고 Tcache를 피하기 위해 0x400과 0x500 대신 사용하면 **현재** 오류 **`malloc(): unsorted double linked list corrupted`**가 발생하는 것을 볼 수 있습니다.
>
> 따라서 이 unsorted bin 공격은 이제 (다른 체크와 함께) 연결 리스트를 수정할 수 있어야 하며, `victim->bk->fd == victim` 또는 `victim->fd == av (arena)`가 아닌 경우를 우회해야 합니다. 이는 우리가 쓰고자 하는 주소가 가짜 chunk의 `fd` 위치에 가짜 chunk의 주소를 가져야 하며, 가짜 chunk의 `fd`가 arena를 가리켜야 함을 의미합니다.

> [!CAUTION]
> 이 공격은 unsorted bin을 손상시킵니다(따라서 small과 large도 마찬가지입니다). 따라서 우리는 이제 **fast bin에서 할당만 사용할 수 있습니다**(더 복잡한 프로그램은 다른 할당을 수행하고 충돌할 수 있습니다), 이를 트리거하기 위해서는 **같은 크기를 할당해야 하며, 그렇지 않으면 프로그램이 충돌합니다.**
>
> **`global_max_fast`**를 덮어쓰는 것이 이 경우에 도움이 될 수 있으며, fast bin이 exploit이 완료될 때까지 다른 모든 할당을 처리할 수 있다고 믿는 것입니다.

[**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin_attack/unsorted_explanation/index.html)의 코드는 이를 매우 잘 설명하고 있으며, mallocs를 수정하여 Tcache에 끝나지 않도록 충분히 큰 메모리를 할당하면 앞서 언급한 오류가 발생하여 이 기술을 방지하는 것을 볼 수 있습니다: **`malloc(): unsorted double linked list corrupted`**

## Unsorted Bin Infoleak Attack

이것은 실제로 매우 기본적인 개념입니다. unsorted bin의 chunk는 포인터를 가질 것입니다. unsorted bin의 첫 번째 chunk는 실제로 **`fd`**와 **`bk`** 링크가 **주요 arena (Glibc)**의 일부를 가리키게 됩니다.\
따라서 **unsorted bin에 chunk를 넣고 읽거나** (use after free) **포인터 중 적어도 하나를 덮어쓰지 않고 다시 할당하여** **읽으면**, **Glibc 정보 유출**을 얻을 수 있습니다.

이 [**writeup에서 사용된 유사한 공격**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html)은 4개의 chunk 구조(A, B, C 및 D - D는 top chunk와의 통합을 방지하기 위해서만 사용됨)를 악용하여 B에서 null byte overflow를 사용하여 C가 B가 사용되지 않았음을 나타내도록 했습니다. 또한 B에서 `prev_size` 데이터를 수정하여 크기가 B의 크기 대신 A+B가 되도록 했습니다.\
그런 다음 C가 해제되고 A+B와 통합되었지만 B는 여전히 사용 중이었습니다. 크기 A의 새로운 chunk가 할당된 후 libc 유출 주소가 B에 기록되어 유출되었습니다.

## References & Other examples

- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap)
- 목표는 4869보다 큰 값으로 전역 변수를 덮어쓰는 것이며, 이를 통해 플래그를 얻을 수 있고 PIE는 활성화되지 않습니다.
- 임의의 크기의 chunk를 생성할 수 있으며 원하는 크기로 힙 오버플로우가 발생합니다.
- 공격은 3개의 chunk를 생성하는 것으로 시작됩니다: chunk0는 오버플로우를 악용하고, chunk1은 오버플로우되며, chunk2는 top chunk가 이전 chunk와 통합되지 않도록 합니다.
- 그런 다음 chunk1이 해제되고 chunk0가 chunk1의 `bk` 포인터를 가리키도록 오버플로우됩니다: `bk = magic - 0x10`
- 그런 다음 chunk1과 동일한 크기로 chunk3가 할당되어 unsorted bin 공격이 트리거되고 전역 변수를 수정하여 플래그를 얻을 수 있게 됩니다.
- [**https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html)
- merge 함수는 두 인덱스가 동일할 경우 재할당하고 해제한 후 해제된 영역에 대한 포인터를 반환하므로 취약합니다.
- 따라서 **2개의 chunk가 생성됩니다**: **chunk0**는 자기 자신과 병합되고 chunk1은 top chunk와의 통합을 방지합니다. 그런 다음 **merge 함수가 chunk0에 대해 두 번 호출되어** use after free가 발생합니다.
- 그런 다음 **`view`** 함수가 인덱스 2(사용 후 해제된 chunk의 인덱스)로 호출되어 **libc 주소를 유출**합니다.
- 바이너리가 **`global_max_fast`**보다 큰 크기만 malloc할 수 있도록 보호가 되어 있으므로 fastbin은 사용되지 않고, unsorted bin 공격이 전역 변수 `global_max_fast`를 덮어쓰는 데 사용됩니다.
- 그런 다음 인덱스 2(사용 후 해제된 포인터)로 edit 함수를 호출하고 `bk` 포인터를 `p64(global_max_fast-0x10)`을 가리키도록 덮어씁니다. 그런 다음 새로운 chunk를 생성하면 이전에 손상된 해제 주소(0x20)를 사용하여 **unsorted bin 공격**이 트리거되어 `global_max_fast`를 매우 큰 값으로 덮어쓰게 되어 이제 fast bins에서 chunk를 생성할 수 있게 됩니다.
- 이제 **fast bin 공격**이 수행됩니다:
- 우선 **`__free_hook`** 위치에서 크기 200의 fast **chunk**로 작업할 수 있다는 것이 발견됩니다:
- <pre class="language-c"><code class="lang-c">gef➤  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
- 이 위치에서 크기 0x200의 fast chunk를 얻으면 실행될 함수 포인터를 덮어쓸 수 있습니다.
- 이를 위해 크기 `0xfc`의 새로운 chunk가 생성되고 병합 함수가 그 포인터로 두 번 호출되어 fast bin에서 크기 `0xfc*2 = 0x1f8`의 해제된 chunk에 대한 포인터를 얻습니다.
- 그런 다음 이 chunk에서 edit 함수를 호출하여 이 fast bin의 **`fd`** 주소를 이전 **`__free_hook`** 함수로 가리키도록 수정합니다.
- 그런 다음 크기 `0x1f8`의 chunk가 생성되어 fast bin에서 이전의 쓸모없는 chunk를 가져오고, 또 다른 크기 `0x1f8`의 chunk가 생성되어 **`__free_hook`**에서 fast bin chunk를 가져오고, 이 chunk는 **`system`** 함수의 주소로 덮어씌워집니다.
- 마지막으로 문자열 `/bin/sh\x00`을 포함하는 chunk가 delete 함수를 호출하여 해제되어 **`__free_hook`** 함수가 호출되고, 이 함수는 `/bin/sh\x00`을 매개변수로 하여 system을 가리킵니다.
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html)
- 1B 오버플로우를 악용하여 unsorted bin에서 chunk를 통합하고 libc 정보 유출을 얻은 다음 fast bin 공격을 수행하여 malloc hook을 one gadget 주소로 덮어쓰는 또 다른 예입니다.
- [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
- 우리는 `0x100`보다 큰 크기의 chunk만 할당할 수 있습니다.
- Unsorted Bin 공격을 사용하여 `global_max_fast`를 덮어씁니다(ASLR로 인해 1/16의 확률로 작동하며, 12비트를 수정해야 하지만 16비트를 수정해야 합니다).
- 전역 chunk 배열을 수정하기 위한 Fast Bin 공격. 이는 임의의 읽기/쓰기를 가능하게 하여 GOT를 수정하고 일부 함수를 `system`을 가리키도록 설정할 수 있습니다.

{{#include ../../banners/hacktricks-training.md}}
