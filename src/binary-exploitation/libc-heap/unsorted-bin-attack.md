# Unsorted Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

Ne olduğunu daha fazla öğrenmek için unsorted bin hakkında şu sayfaya bakın:


{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Unsorted listleri, chunk'ın `bk` adresine `unsorted_chunks (av)` adresini yazabilirler. Bu nedenle, eğer bir saldırgan unsorted bin içindeki bir chunk'taki `bk` pointerının adresini **değiştirebiliyorsa**, o adresi **rastgele bir adrese yazabilme** imkanına sahip olabilir; bu, Glibc adreslerini leak etmek veya bazı korumaları atlatmak için faydalı olabilir.

Yani temelde bu atak, **rastgele bir adrese büyük bir sayı yazmayı** sağlar. Bu büyük sayı bir adrestir; heap adresi veya Glibc adresi olabilir. Geleneksel hedefler arasında fast bin boyutlarını artırmaya izin veren **`global_max_fast`** vardı (ve unsorted bin attack'tan fast bin attack'a geçişi sağlar).

- Modern not (glibc ≥ 2.39): `global_max_fast` 8‑bit bir global oldu. Oraya unsorted‑bin write ile körü körüne bir pointer yazmak, bitişik libc verilerini bozacak ve artık fastbin limitini güvenilir şekilde yükseltmeyecektir. glibc 2.39+ karşısında çalışırken diğer hedefleri veya primitifleri tercih edin. Aşağıdaki "Modern constraints" bölümüne bakın ve kararlı bir primitif elde ettiğinizde bunu bir [large bin attack](large-bin-attack.md) veya bir [fast bin attack](fast-bin-attack.md) gibi diğer tekniklerle birleştirmeyi düşünün.

> [!TIP]
> T>  [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle) adresindeki örneğe bakıldığında ve chunk boyutları olarak 0x400 ve 0x500 yerine 0x4000 ve 0x5000 kullanıldığında (Tcache'i önlemek için) **günümüzde** artık **`malloc(): unsorted double linked list corrupted`** hatasının tetiklendiği görülebilir.
>
> Bu nedenle, bu unsorted bin atakı artık (diğer kontrollerin yanında) çift bağlı listeyi düzeltme yeteneğini de gerektiriyor; aksi halde `victim->bk->fd == victim` veya `victim->fd == av (arena)` kontrolleri atlanamıyor. Bu da, yazmak istediğimiz adresin, fake chunk'ın adresini kendi `fd` pozisyonunda barındırması ve fake chunk `fd`'sinin arena'ya işaret etmesi gerektiği anlamına gelir.

> [!CAUTION]
> Bu atak unsorted bin'i (dolayısıyla small ve large'ı da) bozar. Bu yüzden artık yalnızca **fast bin**'den yapılan allocation'ları kullanabiliriz (daha karmaşık bir program başka allocation'lar yaparsa crash olabilir), ve bunu tetiklemek için **aynı boyutta allocation yapmalıyız yoksa program çöker.**
>
> Bu durumda **`global_max_fast`**'ı overwrite etmek, exploit tamamlanana kadar fast bin'in diğer allocation'ları karşılayabileceğine güvenerek yardımcı olabilir.

[**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin_attack/unsorted_explanation/index.html) tarafından yazılan kod bunu çok iyi açıklıyor; fakat malloc'ları Tcache'e düşmeyecek kadar büyük allocate edecek şekilde değiştirirseniz, daha önce bahsedilen hata ortaya çıkar: **`malloc(): unsorted double linked list corrupted`**

### Yazmanın gerçekte nasıl gerçekleştiği

- Unsorted‑bin yazma, freed chunk unsorted list'in başına eklenirken `free` sırasında tetiklenir.
- Ekleme sırasında allocator şunu yapar: `bck = unsorted_chunks(av); fwd = bck->fd; victim->bk = bck; victim->fd = fwd; fwd->bk = victim; bck->fd = victim;`
- Eğer `free(victim)` çağrısından önce `victim->bk`'yi `(mchunkptr)(TARGET - 0x10)` olarak ayarlayabilirseniz, son ifade şu yazmayı yapar: `*(TARGET) = victim`.
- Daha sonra allocator unsorted bin'i işlerken, unlink etmeden önce bütünlük kontrolleri (başka kontrollerin yanında) `bck->fd == victim` ve `victim->fd == unsorted_chunks(av)` doğrulamasını yapar. Çünkü ekleme zaten `bck->fd`'ye (bizim `TARGET`) `victim`'i yazmıştır, eğer yazma başarılı olduysa bu kontroller sağlanabilir.

## Modern kısıtlamalar (glibc ≥ 2.33)

Güncel glibc üzerinde unsorted‑bin write'ları güvenilir şekilde kullanmak için:

- Tcache müdahalesi: tcache'e düşen boyutlar için free'lar oraya yönlendirilir ve unsorted bin ile işlem yapmaz. Ya
  - istekleri MAX_TCACHE_SIZE'tan (> 64‑bit için genelde ≥ 0x410) büyük boyutlarla yapın, veya
  - ilgili tcache bin'ini (7 giriş) doldurun ki ek free'lar global bin'lere ulaşsın, veya
  - ortamı kontrol edebiliyorsanız tcache'i devre dışı bırakın (ör. GLIBC_TUNABLES glibc.malloc.tcache_count=0).
- Unsorted liste üzerindeki bütünlük kontrolleri: unsorted bin'i inceleyen sonraki allocation yolunda, glibc (basitleştirilmiş olarak) şunları kontrol eder:
  - `bck->fd == victim` ve `victim->fd == unsorted_chunks(av)`; aksi halde `malloc(): unsorted double linked list corrupted` ile abort eder.
- Bu, hedeflediğiniz adresin iki yazmayı tolere etmesi gerektiği anlamına gelir: önce free‑zamanında `*(TARGET) = victim`; daha sonra chunk kaldırılırken `*(TARGET) = unsorted_chunks(av)` (allocator `bck->fd`'yi tekrar bin başına yazar). Sadece büyük, sıfır olmayan bir değer zorlamak işe yarayacak hedefler seçin.
- Modern exploitlerde tipik olarak güvenli hedefler
  - Uygulama veya global durumda "büyük" değerleri bayrak/limit olarak işleyen alanlar.
  - Dolaylı primitifler (ör. sonrasında bir [fast bin attack]({{#ref}}fast-bin-attack.md{{#endref}}) için hazırlık yapmak veya daha sonra bir write‑what‑where pivotu).
  - Yeni glibc'de `__malloc_hook`/`__free_hook`'tan kaçının: bunlar 2.34'te kaldırıldı. `global_max_fast`'ı ≥ 2.39 üzerinde kullanmaktan kaçının (bir sonraki notu görün).
- `global_max_fast` hakkında (yeni glibc)
  - glibc 2.39+ üzerinde, `global_max_fast` 8‑bit bir global'dir. Klasik hile olan heap pointer'ını oraya yazmak (fastbinleri büyütmek için) artık düzgün çalışmıyor ve muhtemelen bitişik allocator durumunu bozuyor. Diğer stratejileri tercih edin.

## Minimal exploit tarifi (modern glibc)

Amaç: unsorted‑bin insertion primitifi kullanarak çökertmeden heap pointer'ını tek seferlik bir rastgele adrese yazdırmak.

- Düzen/grooming
  - Tcache'i atlatacak kadar büyük boyutlarda A, B, C allocate edin (ör. 0x5000). C, top chunk ile konsolidasyonu önler.
- Bozma
  - A'dan B'nin chunk header'ına overflow yaparak `B->bk = (mchunkptr)(TARGET - 0x10)` ayarlayın.
- Tetikleme
  - `free(B)`. Ekleme sırasında allocator `bck->fd = B` ifadesini çalıştırır, dolayısıyla `*(TARGET) = B`.
- Devam
  - Eğer allocation yapmaya devam edecekseniz ve program unsorted bin'i kullanıyorsa, allocator'ın daha sonra `*(TARGET) = unsorted_chunks(av)` yazacağını bekleyin. Her iki değer de tipik olarak büyük olup, sadece "büyük" olup olmadığına bakan hedeflerde boyut/limit semantiğini değiştirmek için yeterli olabilir.

Pseudocode skeleton:
```c
// 64-bit glibc 2.35–2.38 style layout (tcache bypass via large sizes)
void *A = malloc(0x5000);
void *B = malloc(0x5000);
void *C = malloc(0x5000); // guard

// overflow from A into B’s metadata (prev_size/size/.../bk). You must control B->bk.
*(size_t *)((char*)B - 0x8) = (size_t)(TARGET - 0x10); // write fake bk

free(B); // triggers *(TARGET) = B (unsorted-bin insertion write)
```
> [!NOTE]
> • Eğer size ile tcache'i atlatamıyorsanız, bozulan chunk'ı free etmeden önce seçilen boyut için tcache bin'ini doldurun (7 frees) ki free unsorted'a gitsin.
> • Eğer program bir sonraki allocation'da unsorted-bin kontrolleri nedeniyle hemen abort ediyorsa, `victim->fd`'nin hâlâ bin head'e eşit olduğunu ve ilk yazmadan sonra `TARGET`'in tam olarak `victim` pointer'ını tuttuğunu yeniden kontrol edin.

## Unsorted Bin Infoleak Attack

Bu aslında çok temel bir konsept. unsorted bin'deki chunk'ların pointer'ları olur. Unsorted bin'deki ilk chunk gerçekte **`fd`** ve **`bk`** link'lerini **main arena (Glibc)**'nin bir kısmına işaret edecek şekilde tutar.\
Dolayısıyla, eğer bir chunk'ı unsorted bin içine koyup okuyabiliyorsanız (use after free) veya en az bir pointer'ı ezmeden tekrar allocate edip sonra okuyabiliyorsanız, bir **Glibc info leak** elde edebilirsiniz.

Benzer bir [**attack used in this writeup**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html), 4 chunk'lık bir yapı (A, B, C ve D - D sadece top chunk ile consolidation'ı önlemek için) suiistimal edilerek yapılmış; B'deki 1 byte null overflow, C'nin B'nin unused olduğunu göstermesi için kullanılmış. Ayrıca B içinde `prev_size` verisi değiştirilmiş, böylece boyut B'nin boyutu yerine A+B olmuş.\
Sonra C free edilmiş ve A+B ile consolidate olmuş (B hâlâ in use). Boyutu A olan yeni bir chunk allocate edilmiş ve ardından libc leaked adresleri B'ye yazılmış, buradan leak edilmişler.

## Referanslar ve Diğer örnekler

- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap)
- Amaç, PIE etkin değilken global bir değişkeni 4869'dan büyük bir değerle overwrite etmek (flag alınabilir hale getirmek).
- İstenilen boyutta bir heap overflow ile arbitrary boyutlarda chunk üretmek mümkün.
- Saldırı chunk'lar oluşturmakla başlar: overflow için chunk0, overflow edilecek chunk1 ve top chunk'un önceki chunk'larla consolidate olmasını önlemek için chunk2.
- Ardından chunk1 free edilir ve chunk0, chunk1'in `bk` pointer'ına overflow edilir: `bk = magic - 0x10`
- Sonra chunk3, chunk1 ile aynı boyutta allocate edilir; bu unsorted bin attack'ı tetikleyecek ve global değişkenin değerini değiştirecek, böylece flag alınabilecek hale gelecek.
- [**https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html)
- merge fonksiyonu, eğer aynı index iki kez geçirilirse realloc yapıp sonra free ettiği ve freed bölgeye işaret eden bir pointer döndürdüğü için vuln.
- Bu sebeple, **2 chunk oluşturulur**: kendisiyle merge edilecek olan **chunk0** ve top chunk ile consolidate olmaması için chunk1. Sonra **merge** fonksiyonu chunk0 ile iki kez çağrılır ve bu use after free'e yol açar.
- Ardından **`view`** fonksiyonu index 2 ile çağrılır (use after free chunk'un index'i), bu da **libc adresi leak** eder.
- Binary, sadece `global_max_fast`'tan büyük boyutlarda malloc yapmaya izin veren korumalara sahip olduğundan fastbin kullanılmaz; bu yüzden `global_max_fast`'ı overwrite etmek için bir unsorted bin attack kullanılacak.
- Sonra, edit fonksiyonu index 2 (use after free pointer) ile çağrılıp `bk` pointer'ı `p64(global_max_fast-0x10)`'a overwrite edilir. Ardından yeni bir chunk oluşturmak, daha önce değiştirilmiş free adresini kullanacak (0x20) ve **unsorted bin attack'ı** tetikleyerek `global_max_fast`'ı çok büyük bir değere overwrite eder; böylece artık fast bin'lerde chunk oluşturmak mümkün olur.
- Şimdi bir **fast bin attack** gerçekleştirilir:
- Öncelikle `__free_hook` konumunda fast boyutlu chunk'larla çalışılabildiği keşfedilir:
- <pre class="language-c"><code class="lang-c">gef➤  p &__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 <__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f <list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f <_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
- Eğer bu konumda 0x200 boyutunda bir fast chunk elde edebilirsek, yürütülecek bir function pointer'ı overwrite etmek mümkün olacak.
- Bunun için `0xfc` boyutunda yeni bir chunk oluşturulur ve merged fonksiyonu bu pointer ile iki kez çağrılır; böylece fast bin'de `0xfc*2 = 0x1f8` boyutunda freed bir chunk pointer'ı elde edilir.
- Sonra edit fonksiyonu bu chunk'ta çağrılarak bu fast bin'in **`fd`** adresi önceki **`__free_hook`** fonksiyonuna işaret edecek şekilde değiştirilir.
- Ardından `0x1f8` boyutunda bir chunk oluşturulur, fast bin'den o işe yaramaz chunk alınır ve başka bir `0x1f8` chunk daha oluşturularak `__free_hook`'ta bir fast bin chunk elde edilir; burası `system` fonksiyonunun adresiyle overwrite edilir.
- Son olarak `/bin/sh\x00` içeren bir chunk delete fonksiyonu ile free edilerek `__free_hook` tetiklenir; `__free_hook` artık system'e işaret eder ve `/bin/sh\x00` parametresiyle çağrılır.
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html)
- 1 byte overflow kullanılarak unsorted bin'de chunk'ların consolidate edilmesiyle libc infoleak elde edilip ardından fast bin attack ile malloc hook'un one gadget adresiyle overwrite edilmesine dair başka bir örnek
- [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
- Sadece `0x100`'den büyük boyutlarda chunk allocate edilebiliyor.
- Unsorted Bin attack ile `global_max_fast` overwrite ediliyor (ASLR nedeniyle 1/16 oranında işe yarıyor; çünkü 12 bit'i değil 16 bit'i değiştirmek gerekiyor).
- Fast Bin attack ile global bir chunk dizisi modify ediliyor. Bu, arbitrary read/write primitive sağlar ve GOT'u değiştirip bazı fonksiyonları `system`'e yönlendirmeye izin verir.

## References

- Glibc malloc unsorted-bin integrity checks (example in 2.33 source): https://elixir.bootlin.com/glibc/glibc-2.33/source/malloc/malloc.c
- `global_max_fast` and related definitions in modern glibc (2.39): https://elixir.bootlin.com/glibc/glibc-2.39/source/malloc/malloc.c
{{#include ../../banners/hacktricks-training.md}}
