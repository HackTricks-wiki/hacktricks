# Ongeordende Bin Aanval

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

Vir meer inligting oor wat 'n ongeordende bin is, kyk na hierdie bladsy:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Ongeordende lyste kan die adres na `unsorted_chunks (av)` in die `bk` adres van die stuk skryf. Daarom, as 'n aanvaller die **adres van die `bk` pointer** in 'n stuk binne die ongeordende bin kan **wysig**, kan hy in staat wees om **daardie adres in 'n arbitrêre adres te skryf**, wat nuttig kan wees om 'n Glibc-adres te lek of om sekere verdediging te omseil.

So, basies, laat hierdie aanval toe om **'n groot getal op 'n arbitrêre adres in te stel**. Hierdie groot getal is 'n adres, wat 'n heap-adres of 'n Glibc-adres kan wees. 'n Tipiese teiken is **`global_max_fast`** om vinnige binne met groter groottes te skep (en om van 'n ongeordende bin aanval na 'n vinnige bin aanval oor te gaan).

> [!TIP]
> T> kyk na die voorbeeld wat gegee is in [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle) en gebruik 0x4000 en 0x5000 in plaas van 0x400 en 0x500 as stuk groottes (om Tcache te vermy) is dit moontlik om te sien dat **vandag** die fout **`malloc(): unsorted double linked list corrupted`** geaktiveer word.
>
> Daarom, hierdie ongeordende bin aanval vereis nou (benewens ander kontroles) ook om in staat te wees om die dubbele verknoping te herstel sodat dit `victim->bk->fd == victim` of nie `victim->fd == av (arena)` omseil nie, wat beteken dat die adres waar ons wil skryf die adres van die valse stuk in sy `fd` posisie moet hê en dat die valse stuk `fd` na die arena wys.

> [!CAUTION]
> Let daarop dat hierdie aanval die ongeordende bin korrupteer (dus klein en groot ook). So ons kan slegs **toewysings van die vinnige bin nou gebruik** ( 'n meer komplekse program mag ander toewysings doen en crash), en om dit te aktiveer moet ons **die dieselfde grootte toewys of die program sal crash.**
>
> Let daarop dat om **`global_max_fast`** te oorskry dalk in hierdie geval kan help, vertrouende dat die vinnige bin in staat sal wees om al die ander toewysings te hanteer totdat die uitbuiting voltooi is.

Die kode van [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin_attack/unsorted_explanation/index.html) verduidelik dit baie goed, alhoewel as jy die mallocs aanpas om genoeg geheue toe te ken sodat dit nie in 'n Tcache eindig nie, kan jy sien dat die voorheen genoemde fout voorkom wat hierdie tegniek voorkom: **`malloc(): unsorted double linked list corrupted`**

## Ongeordende Bin Inligtingslek Aanval

Dit is eintlik 'n baie basiese konsep. Die stukke in die ongeordende bin gaan wysers hê. Die eerste stuk in die ongeordende bin sal eintlik die **`fd`** en die **`bk`** skakels hê **wat na 'n deel van die hoof arena (Glibc)** wys.\
Daarom, as jy **'n stuk in 'n ongeordende bin kan plaas en dit kan lees** (gebruik na vry) of **dit weer kan toewys sonder om ten minste 1 van die wysers te oorskry** om dan **dit te lees**, kan jy 'n **Glibc inligtingslek** hê.

'n Soortgelyke [**aanval wat in hierdie skrywe gebruik is**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html), was om 'n 4 stukke struktuur (A, B, C en D - D is slegs om konsolidasie met die boonste stuk te voorkom) te misbruik, sodat 'n null byte oorgang in B gebruik is om C aan te dui dat B nie gebruik is nie. Ook, in B is die `prev_size` data gewysig sodat die grootte in plaas van die grootte van B A+B was.\
Toe is C vrygestel, en gekonsolideer met A+B (maar B was steeds in gebruik). 'n Nuwe stuk van grootte A is toegeken en toe is die libc gelekte adresse in B geskryf waarvandaan hulle gelek is.

## Verwysings & Ander voorbeelde

- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap)
- Die doel is om 'n globale veranderlike met 'n waarde groter as 4869 te oorskry sodat dit moontlik is om die vlag te kry en PIE is nie geaktiveer nie.
- Dit is moontlik om stukke van arbitrêre groottes te genereer en daar is 'n heap oorgang met die gewenste grootte.
- Die aanval begin deur 3 stukke te skep: chunk0 om die oorgang te misbruik, chunk1 om oorgestroom te word en chunk2 sodat die boonste stuk nie die vorige een konsolideer nie.
- Toe word chunk1 vrygestel en chunk0 word oorgestroom sodat die `bk` pointer van chunk1 na: `bk = magic - 0x10` wys.
- Toe word chunk3 toegeken met dieselfde grootte as chunk1, wat die ongeordende bin aanval sal aktiveer en die waarde van die globale veranderlike sal wysig, wat dit moontlik maak om die vlag te kry.
- [**https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html)
- Die samensmeltingsfunksie is kwesbaar omdat as beide indekse wat oorgedra word dieselfde is, dit op dit sal heraanskakel en dan vry sal stel, maar 'n pointer na daardie vrygestelde streek sal teruggee wat gebruik kan word.
- Daarom, **2 stukke word geskep**: **chunk0** wat met homself saamgevoeg sal word en chunk1 om te voorkom dat dit met die boonste stuk konsolideer. Toe, die **samensmeltingsfunksie word twee keer met chunk0** aangeroep wat 'n gebruik na vry sal veroorsaak.
- Toe, die **`view`** funksie word met indeks 2 (wat die indeks van die gebruik na vry stuk is) aangeroep, wat 'n **libc adres sal lek**.
- Aangesien die binêre beskermings het om slegs malloc groottes groter as **`global_max_fast`** te gebruik, word daar geen vinnige bin gebruik nie, 'n ongeordende bin aanval gaan gebruik word om die globale veranderlike `global_max_fast` te oorskry.
- Toe, dit is moontlik om die redigeer funksie met indeks 2 (die gebruik na vry pointer) aan te roep en die `bk` pointer te oorskry om na `p64(global_max_fast-0x10)` te wys. Toe, die skep van 'n nuwe stuk sal die voorheen gecompromitteerde vry adres (0x20) gebruik wat die **ongeordende bin aanval** sal aktiveer wat die `global_max_fast` oorskry met 'n baie groot waarde, wat dit nou moontlik maak om stukke in vinnige binne te skep.
- Nou word 'n **vinnige bin aanval** uitgevoer:
- Eerstens word ontdek dat dit moontlik is om met vinnige **stukke van grootte 200** in die **`__free_hook`** ligging te werk:
- <pre class="language-c"><code class="lang-c">gef➤  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
- As ons daarin slaag om 'n vinnige stuk van grootte 0x200 in hierdie ligging te kry, sal dit moontlik wees om 'n funksie pointer te oorskry wat uitgevoer sal word.
- Hiervoor word 'n nuwe stuk van grootte `0xfc` geskep en die samensmeltingsfunksie word twee keer met daardie pointer aangeroep, sodat ons 'n pointer na 'n vrygestelde stuk van grootte `0xfc*2 = 0x1f8` in die vinnige bin verkry.
- Toe, die redigeer funksie word in hierdie stuk aangeroep om die **`fd`** adres van hierdie vinnige bin te wys na die vorige **`__free_hook`** funksie.
- Toe, 'n stuk met grootte `0x1f8` word geskep om die vorige nuttelose stuk uit die vinnige bin te verkry, sodat 'n ander stuk van grootte `0x1f8` geskep word om 'n vinnige bin stuk in die **`__free_hook`** te kry wat oorgeskryf word met die adres van die **`system`** funksie.
- En uiteindelik word 'n stuk wat die string `/bin/sh\x00` bevat, vrygestel deur die verwyder funksie aan te roep, wat die **`__free_hook`** funksie aktiveer wat na system met `/bin/sh\x00` as parameter wys.
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html)
- Nog 'n voorbeeld van die misbruik van 'n 1B oorgang om stukke in die ongeordende bin te konsolideer en 'n libc inligtingslek te kry en dan 'n vinnige bin aanval uit te voer om die malloc hook met 'n een gadget adres te oorskry.
- [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
- Ons kan slegs stukke van grootte groter as `0x100` toewys.
- Oorskry `global_max_fast` met 'n Ongeordende Bin aanval (werk 1/16 keer as gevolg van ASLR, omdat ons 12 bits moet wysig, maar ons moet 16 bits wysig).
- Vinnige Bin aanval om 'n globale array van stukke te wysig. Dit bied 'n arbitrêre lees/schrijf primitief, wat toelaat om die GOT te wysig en sommige funksies na `system` te laat wys.

{{#include ../../banners/hacktricks-training.md}}
