# Attaque de la Bin Non Triée

{{#include ../../banners/hacktricks-training.md}}

## Informations de Base

Pour plus d'informations sur ce qu'est une bin non triée, consultez cette page :

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Les listes non triées peuvent écrire l'adresse de `unsorted_chunks (av)` dans l'adresse `bk` du chunk. Par conséquent, si un attaquant peut **modifier l'adresse du pointeur `bk`** dans un chunk à l'intérieur de la bin non triée, il pourrait être capable de **écrire cette adresse à une adresse arbitraire** ce qui pourrait être utile pour divulguer des adresses Glibc ou contourner certaines défenses.

Donc, fondamentalement, cette attaque permet de **définir un grand nombre à une adresse arbitraire**. Ce grand nombre est une adresse, qui pourrait être une adresse de tas ou une adresse Glibc. Une cible typique est **`global_max_fast`** pour permettre de créer des bins de fast bin avec des tailles plus grandes (et passer d'une attaque de bin non triée à une attaque de fast bin).

> [!TIP]
> J>etez un œil à l'exemple fourni dans [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle) et en utilisant 0x4000 et 0x5000 au lieu de 0x400 et 0x500 comme tailles de chunk (pour éviter Tcache), il est possible de voir que **de nos jours** l'erreur **`malloc(): unsorted double linked list corrupted`** est déclenchée.
>
> Par conséquent, cette attaque de bin non triée nécessite maintenant (entre autres vérifications) également d'être capable de corriger la liste doublement chaînée afin que cela soit contourné `victim->bk->fd == victim` ou non `victim->fd == av (arena)`, ce qui signifie que l'adresse où nous voulons écrire doit avoir l'adresse du faux chunk dans sa position `fd` et que le faux chunk `fd` pointe vers l'arène.

> [!CAUTION]
> Notez que cette attaque corrompt la bin non triée (d'où les petites et grandes aussi). Donc, nous ne pouvons utiliser que **des allocations à partir de la fast bin maintenant** (un programme plus complexe pourrait faire d'autres allocations et planter), et pour déclencher cela, nous devons **allouer la même taille ou le programme plantera.**
>
> Notez que la réécriture de **`global_max_fast`** pourrait aider dans ce cas en faisant confiance au fait que la fast bin sera capable de s'occuper de toutes les autres allocations jusqu'à ce que l'exploitation soit terminée.

Le code de [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin_attack/unsorted_explanation/index.html) l'explique très bien, bien que si vous modifiez les mallocs pour allouer une mémoire suffisamment grande pour ne pas se retrouver dans un Tcache, vous pouvez voir que l'erreur mentionnée précédemment apparaît empêchant cette technique : **`malloc(): unsorted double linked list corrupted`**

## Attaque de Divulgation d'Informations de Bin Non Triée

C'est en fait un concept très basique. Les chunks dans la bin non triée vont avoir des pointeurs. Le premier chunk dans la bin non triée aura en fait les liens **`fd`** et **`bk`** **pointant vers une partie de l'arène principale (Glibc)**.\
Par conséquent, si vous pouvez **mettre un chunk à l'intérieur d'une bin non triée et le lire** (utiliser après libération) ou **le réallouer sans écraser au moins 1 des pointeurs** pour ensuite **le lire**, vous pouvez avoir une **divulgation d'informations Glibc**.

Une [**attaque similaire utilisée dans ce rapport**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html) a été d'abuser d'une structure de 4 chunks (A, B, C et D - D est seulement pour empêcher la consolidation avec le chunk supérieur) donc un débordement de byte nul dans B a été utilisé pour faire indiquer à C que B était inutilisé. De plus, dans B, les données `prev_size` ont été modifiées pour que la taille au lieu d'être la taille de B soit A+B.\
Ensuite, C a été désalloué et consolidé avec A+B (mais B était toujours utilisé). Un nouveau chunk de taille A a été alloué et ensuite les adresses de libc divulguées ont été écrites dans B d'où elles ont été divulguées.

## Références & Autres exemples

- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap)
- L'objectif est de réécrire une variable globale avec une valeur supérieure à 4869 afin qu'il soit possible d'obtenir le drapeau et que PIE ne soit pas activé.
- Il est possible de générer des chunks de tailles arbitraires et il y a un débordement de tas avec la taille désirée.
- L'attaque commence par créer 3 chunks : chunk0 pour abuser du débordement, chunk1 pour être débordé et chunk2 pour que le chunk supérieur ne consolide pas les précédents.
- Ensuite, chunk1 est libéré et chunk0 est débordé pour que le pointeur `bk` de chunk1 pointe vers : `bk = magic - 0x10`
- Ensuite, chunk3 est alloué avec la même taille que chunk1, ce qui déclenchera l'attaque de bin non triée et modifiera la valeur de la variable globale, rendant possible d'obtenir le drapeau.
- [**https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html)
- La fonction de fusion est vulnérable car si les deux index passés sont le même, elle le réallouera et ensuite le libérera mais renverra un pointeur vers cette région libérée qui peut être utilisée.
- Par conséquent, **2 chunks sont créés** : **chunk0** qui sera fusionné avec lui-même et chunk1 pour empêcher la consolidation avec le chunk supérieur. Ensuite, la **fonction de fusion est appelée avec chunk0** deux fois, ce qui provoquera une utilisation après libération.
- Ensuite, la **fonction `view`** est appelée avec l'index 2 (qui est l'index du chunk utilisé après libération), ce qui **divulguera une adresse libc**.
- Comme le binaire a des protections pour n'allouer que des tailles supérieures à **`global_max_fast`**, aucune fastbin n'est utilisée, une attaque de bin non triée sera utilisée pour réécrire la variable globale `global_max_fast`.
- Ensuite, il est possible d'appeler la fonction d'édition avec l'index 2 (le pointeur utilisé après libération) et de réécrire le pointeur `bk` pour pointer vers `p64(global_max_fast-0x10)`. Ensuite, la création d'un nouveau chunk utilisera l'adresse libre compromise précédemment (0x20) qui **déclenchera l'attaque de bin non triée** en réécrivant le `global_max_fast` avec une valeur très grande, permettant maintenant de créer des chunks dans les fast bins.
- Maintenant, une **attaque de fast bin** est effectuée :
- Tout d'abord, il est découvert qu'il est possible de travailler avec des fast **chunks de taille 200** dans l'emplacement **`__free_hook`** :
- <pre class="language-c"><code class="lang-c">gef➤  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
- Si nous parvenons à obtenir un fast chunk de taille 0x200 à cet emplacement, il sera possible de réécrire un pointeur de fonction qui sera exécuté.
- Pour cela, un nouveau chunk de taille `0xfc` est créé et la fonction fusionnée est appelée avec ce pointeur deux fois, de cette façon nous obtenons un pointeur vers un chunk libéré de taille `0xfc*2 = 0x1f8` dans la fast bin.
- Ensuite, la fonction d'édition est appelée dans ce chunk pour modifier l'adresse **`fd`** de cette fast bin pour pointer vers la fonction **`__free_hook`** précédente.
- Ensuite, un chunk de taille `0x1f8` est créé pour récupérer de la fast bin le chunk inutile précédent afin qu'un autre chunk de taille `0x1f8` soit créé pour obtenir un chunk de fast bin dans le **`__free_hook`** qui est réécrit avec l'adresse de la fonction **`system`**.
- Et enfin, un chunk contenant la chaîne `/bin/sh\x00` est libéré en appelant la fonction de suppression, déclenchant la fonction **`__free_hook`** qui pointe vers system avec `/bin/sh\x00` comme paramètre.
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html)
- Un autre exemple d'abus d'un débordement de 1B pour consolider des chunks dans la bin non triée et obtenir une divulgation d'informations libc, puis effectuer une attaque de fast bin pour réécrire le malloc hook avec une adresse de gadget.
- [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
- Nous ne pouvons allouer que des chunks de taille supérieure à `0x100`.
- Réécrire `global_max_fast` en utilisant une attaque de bin non triée (fonctionne 1/16 fois en raison de l'ASLR, car nous devons modifier 12 bits, mais nous devons modifier 16 bits).
- Attaque de fast bin pour modifier un tableau global de chunks. Cela donne une primitive de lecture/écriture arbitraire, ce qui permet de modifier le GOT et de faire pointer certaines fonctions vers `system`.

{{#include ../../banners/hacktricks-training.md}}
