# Unsorted Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Για περισσότερες πληροφορίες σχετικά με το τι είναι ένα unsorted bin, ελέγξτε αυτή τη σελίδα:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Τα unsorted lists είναι ικανά να γράψουν τη διεύθυνση στο `unsorted_chunks (av)` στη διεύθυνση `bk` του chunk. Επομένως, αν ένας επιτιθέμενος μπορεί να **τροποποιήσει τη διεύθυνση του δείκτη `bk`** σε ένα chunk μέσα στο unsorted bin, θα μπορούσε να είναι σε θέση να **γράψει αυτή τη διεύθυνση σε μια αυθαίρετη διεύθυνση** που θα μπορούσε να είναι χρήσιμη για να διαρρεύσει διευθύνσεις Glibc ή να παρακάμψει κάποια άμυνα.

Έτσι, βασικά, αυτή η επίθεση επιτρέπει να **οριστεί ένας μεγάλος αριθμός σε μια αυθαίρετη διεύθυνση**. Αυτός ο μεγάλος αριθμός είναι μια διεύθυνση, η οποία θα μπορούσε να είναι μια διεύθυνση heap ή μια διεύθυνση Glibc. Ένας τυπικός στόχος είναι **`global_max_fast`** για να επιτρέψει τη δημιουργία fast bin bins με μεγαλύτερα μεγέθη (και να περάσει από μια επίθεση unsorted bin σε μια επίθεση fast bin).

> [!TIP]
> Ρ> ίχνοντας μια ματιά στο παράδειγμα που παρέχεται στο [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle) και χρησιμοποιώντας 0x4000 και 0x5000 αντί για 0x400 και 0x500 ως μεγέθη chunk (για να αποφευχθεί το Tcache), είναι δυνατόν να δούμε ότι **σήμερα** το σφάλμα **`malloc(): unsorted double linked list corrupted`** ενεργοποιείται.
>
> Επομένως, αυτή η επίθεση unsorted bin τώρα (μεταξύ άλλων ελέγχων) απαιτεί επίσης να είναι σε θέση να διορθώσει τη διπλή συνδεδεμένη λίστα ώστε να παρακαμφθεί `victim->bk->fd == victim` ή όχι `victim->fd == av (arena)`, που σημαίνει ότι η διεύθυνση όπου θέλουμε να γράψουμε πρέπει να έχει τη διεύθυνση του ψεύτικου chunk στη θέση `fd` της και ότι το ψεύτικο chunk `fd` δείχνει στην αρένα.

> [!CAUTION]
> Σημειώστε ότι αυτή η επίθεση διαφθείρει το unsorted bin (άρα και το μικρό και το μεγάλο). Έτσι, μπορούμε μόνο να **χρησιμοποιήσουμε allocations από το fast bin τώρα** (ένα πιο περίπλοκο πρόγραμμα μπορεί να κάνει άλλες allocations και να καταρρεύσει), και για να ενεργοποιηθεί αυτό πρέπει να **κατανεμηθεί το ίδιο μέγεθος ή το πρόγραμμα θα καταρρεύσει.**
>
> Σημειώστε ότι η επαναγραφή του **`global_max_fast`** μπορεί να βοηθήσει σε αυτή την περίπτωση, εμπιστευόμενοι ότι το fast bin θα είναι σε θέση να φροντίσει όλες τις άλλες allocations μέχρι να ολοκληρωθεί η εκμετάλλευση.

Ο κώδικας από τον [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin_attack/unsorted_explanation/index.html) το εξηγεί πολύ καλά, αν και αν τροποποιήσετε τις mallocs για να κατανεμηθεί μνήμη αρκετά μεγάλη ώστε να μην καταλήξει σε Tcache, μπορείτε να δείτε ότι το προηγουμένως αναφερόμενο σφάλμα εμφανίζεται, αποτρέποντας αυτή την τεχνική: **`malloc(): unsorted double linked list corrupted`**

## Unsorted Bin Infoleak Attack

Αυτό είναι στην πραγματικότητα μια πολύ βασική έννοια. Τα chunks στο unsorted bin θα έχουν δείκτες. Το πρώτο chunk στο unsorted bin θα έχει στην πραγματικότητα τους συνδέσμους **`fd`** και **`bk`** **να δείχνουν σε ένα μέρος της κύριας αρένας (Glibc)**.\
Επομένως, αν μπορείτε να **βάλτε ένα chunk μέσα σε ένα unsorted bin και να το διαβάσετε** (use after free) ή **να το κατανεμηθείτε ξανά χωρίς να επαναγράψετε τουλάχιστον 1 από τους δείκτες** για να **το διαβάσετε**, μπορείτε να έχετε μια **Glibc info leak**.

Μια παρόμοια [**επίθεση που χρησιμοποιήθηκε σε αυτή την αναφορά**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html), ήταν να καταχραστεί μια δομή 4 chunks (A, B, C και D - D είναι μόνο για να αποτρέψει τη συγχώνευση με το top chunk) έτσι ώστε μια overflow null byte στο B να χρησιμοποιηθεί για να κάνει το C να υποδείξει ότι το B ήταν ανενεργό. Επίσης, στο B τα δεδομένα `prev_size` τροποποιήθηκαν έτσι ώστε το μέγεθος αντί να είναι το μέγεθος του B να είναι A+B.\
Στη συνέχεια, το C απελευθερώθηκε και συγχωνεύθηκε με A+B (αλλά το B ήταν ακόμα σε χρήση). Ένα νέο chunk μεγέθους A κατανεμήθηκε και στη συνέχεια οι διευθύνσεις libc διαρρεύθηκαν στο B από όπου διαρρεύθηκαν.

## References & Other examples

- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap)
- Ο στόχος είναι να επαναγραφεί μια παγκόσμια μεταβλητή με μια τιμή μεγαλύτερη από 4869 ώστε να είναι δυνατή η λήψη της σημαίας και το PIE να μην είναι ενεργοποιημένο.
- Είναι δυνατόν να παραχθούν chunks αυθαίρετου μεγέθους και υπάρχει μια heap overflow με το επιθυμητό μέγεθος.
- Η επίθεση ξεκινά δημιουργώντας 3 chunks: chunk0 για να καταχραστεί την overflow, chunk1 για να υπερχειλιστεί και chunk2 ώστε το top chunk να μην συγχωνευθεί με τα προηγούμενα.
- Στη συνέχεια, το chunk1 απελευθερώνεται και το chunk0 υπερχειλίζεται ώστε ο δείκτης `bk` του chunk1 να δείχνει σε: `bk = magic - 0x10`
- Στη συνέχεια, το chunk3 κατανεμήθηκε με το ίδιο μέγεθος όπως το chunk1, το οποίο θα ενεργοποιήσει την επίθεση unsorted bin και θα τροποποιήσει την τιμή της παγκόσμιας μεταβλητής, καθιστώντας δυνατή τη λήψη της σημαίας.
- [**https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html)
- Η συνάρτηση merge είναι ευάλωτη επειδή αν και οι δύο δείκτες που περάστηκαν είναι ο ίδιος, θα επανακατανεμηθεί σε αυτόν και στη συνέχεια θα απελευθερωθεί, αλλά επιστρέφει έναν δείκτη σε αυτήν την απελευθερωμένη περιοχή που μπορεί να χρησιμοποιηθεί.
- Επομένως, **δημιουργούνται 2 chunks**: **chunk0** το οποίο θα συγχωνευθεί με τον εαυτό του και chunk1 για να αποτρέψει τη συγχώνευση με το top chunk. Στη συνέχεια, η **συνάρτηση merge καλείται με το chunk0** δύο φορές, γεγονός που θα προκαλέσει μια χρήση μετά την απελευθέρωση.
- Στη συνέχεια, η **συνάρτηση `view`** καλείται με δείκτη 2 (ο οποίος είναι ο δείκτης του chunk που χρησιμοποιήθηκε μετά την απελευθέρωση), το οποίο θα **διαρρεύσει μια διεύθυνση libc**.
- Καθώς το δυαδικό έχει προστασίες για να επιτρέπει μόνο malloc μεγέθη μεγαλύτερα από **`global_max_fast`**, δεν χρησιμοποιείται κανένα fastbin, μια επίθεση unsorted bin θα χρησιμοποιηθεί για να επαναγράψει την παγκόσμια μεταβλητή `global_max_fast`.
- Στη συνέχεια, είναι δυνατόν να καλέσετε τη συνάρτηση edit με τον δείκτη 2 (τον δείκτη του pointer που χρησιμοποιήθηκε μετά την απελευθέρωση) και να επαναγράψετε τον δείκτη `bk` ώστε να δείχνει σε `p64(global_max_fast-0x10)`. Στη συνέχεια, η δημιουργία ενός νέου chunk θα χρησιμοποιήσει τη προηγουμένως παραβιασμένη ελεύθερη διεύθυνση (0x20) θα **ενεργοποιήσει την επίθεση unsorted bin** επαναγράφοντας το `global_max_fast` με μια πολύ μεγάλη τιμή, επιτρέποντας τώρα τη δημιουργία chunks σε fast bins.
- Τώρα εκτελείται μια **επίθεση fast bin**:
- Πρώτα απ 'όλα, ανακαλύπτεται ότι είναι δυνατόν να εργαστείτε με γρήγορες **chunks μεγέθους 200** στη θέση **`__free_hook`**:
- <pre class="language-c"><code class="lang-c">gef➤  p &__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 <__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f <list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f <_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
- Αν καταφέρουμε να αποκτήσουμε ένα γρήγορο chunk μεγέθους 0x200 σε αυτή τη θέση, θα είναι δυνατόν να επαναγράψουμε έναν δείκτη συνάρτησης που θα εκτελείται
- Για αυτό, δημιουργείται ένα νέο chunk μεγέθους `0xfc` και η συγχωνευμένη συνάρτηση καλείται με αυτόν τον δείκτη δύο φορές, με αυτόν τον τρόπο αποκτούμε έναν δείκτη σε ένα ελεύθερο chunk μεγέθους `0xfc*2 = 0x1f8` στο fast bin.
- Στη συνέχεια, η συνάρτηση edit καλείται σε αυτό το chunk για να τροποποιήσει τη διεύθυνση **`fd`** αυτού του fast bin ώστε να δείχνει στην προηγούμενη συνάρτηση **`__free_hook`**.
- Στη συνέχεια, δημιουργείται ένα chunk μεγέθους `0x1f8` για να ανακτηθεί από το fast bin το προηγούμενο άχρηστο chunk, ώστε να δημιουργηθεί ένα άλλο chunk μεγέθους `0x1f8` για να αποκτήσουμε ένα fast bin chunk στη **`__free_hook`** το οποίο επαναγράφεται με τη διεύθυνση της συνάρτησης **`system`**.
- Και τελικά, ένα chunk που περιέχει τη συμβολοσειρά `/bin/sh\x00` απελευθερώνεται καλώντας τη συνάρτηση delete, ενεργοποιώντας τη συνάρτηση **`__free_hook`** που δείχνει στη συνάρτηση system με `/bin/sh\x00` ως παράμετρο.
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html)
- Ένα άλλο παράδειγμα κατάχρησης μιας overflow 1B για να συγχωνευθούν chunks στο unsorted bin και να αποκτηθεί μια libc infoleak και στη συνέχεια να εκτελεστεί μια επίθεση fast bin για να επαναγραφεί το malloc hook με μια διεύθυνση one gadget
- [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
- Μπορούμε μόνο να κατανεμηθούν chunks μεγέθους μεγαλύτερου από `0x100`.
- Επαναγράψτε το `global_max_fast` χρησιμοποιώντας μια επίθεση Unsorted Bin (λειτουργεί 1/16 φορές λόγω ASLR, επειδή πρέπει να τροποποιήσουμε 12 bits, αλλά πρέπει να τροποποιήσουμε 16 bits).
- Επίθεση Fast Bin για να τροποποιήσετε έναν παγκόσμιο πίνακα chunks. Αυτό δίνει μια αυθαίρετη αναγνωστική/γραφική πρωτοβουλία, η οποία επιτρέπει να τροποποιηθεί το GOT και να ρυθμιστεί κάποια συνάρτηση να δείχνει στη `system`.

{{#include ../../banners/hacktricks-training.md}}
