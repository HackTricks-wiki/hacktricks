# Unsorted Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

Unsorted bin nedir hakkında daha fazla bilgi için bu sayfayı kontrol edin:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Unsorted listeler, `bk` adresine `unsorted_chunks (av)` adresini yazma yeteneğine sahiptir. Bu nedenle, bir saldırgan bir unsorted bin içindeki bir chunk'taki **`bk` pointer'ının adresini değiştirebilirse**, bu adresi **rastgele bir adrese yazabilir** ki bu da Glibc adreslerini sızdırmak veya bazı savunmaları aşmak için faydalı olabilir.

Yani, temelde bu saldırı, **rastgele bir adreste büyük bir sayı ayarlamaya** olanak tanır. Bu büyük sayı, bir heap adresi veya bir Glibc adresi olabilir. Tipik bir hedef, daha büyük boyutlarda hızlı binler oluşturmak için **`global_max_fast`**'tır (ve bir unsorted bin saldırısından hızlı bin saldırısına geçiş yapar).

> [!TIP]
> [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle) adresinde verilen örneğe bakarak ve chunk boyutları için 0x400 ve 0x500 yerine 0x4000 ve 0x5000 kullanarak (Tcache'den kaçınmak için) **günümüzde** **`malloc(): unsorted double linked list corrupted`** hatasının tetiklendiğini görebilirsiniz.
>
> Bu nedenle, bu unsorted bin saldırısı artık (diğer kontrollerin yanı sıra) çift bağlı listeyi düzeltme yeteneğine sahip olmayı da gerektiriyor, böylece `victim->bk->fd == victim` veya `victim->fd == av (arena)` kontrolü geçiliyor, bu da yazmak istediğimiz adresin `fd` konumunda sahte chunk'ın adresini bulundurması ve sahte chunk'ın `fd`'sinin arenaya işaret etmesi gerektiği anlamına geliyor.

> [!CAUTION]
> Bu saldırının unsorted bin'i bozduğunu unutmayın (bu nedenle küçük ve büyük de). Bu nedenle, artık yalnızca **hızlı binlerden tahsisat kullanabiliriz** (daha karmaşık bir program başka tahsisatlar yapabilir ve çökebilir) ve bunu tetiklemek için **aynı boyutta tahsisat yapmalıyız yoksa program çöker.**
>
> **`global_max_fast`**'ı yazmak bu durumda yardımcı olabilir, çünkü hızlı binin tüm diğer tahsisatları exploit tamamlanana kadar yönetebileceğine güveniyoruz.

[**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin_attack/unsorted_explanation/index.html) tarafından verilen kod bunu çok iyi açıklıyor, ancak malloc'ları yeterince büyük bir bellek tahsis etmek için değiştirirseniz, böylece Tcache'de sona ermezseniz, daha önce bahsedilen hatanın bu tekniği engellediğini görebilirsiniz: **`malloc(): unsorted double linked list corrupted`**

## Unsorted Bin Infoleak Attack

Bu aslında çok temel bir kavramdır. Unsorted bin'deki chunk'lar pointer'lara sahip olacaktır. Unsorted bin'deki ilk chunk aslında **`fd`** ve **`bk`** bağlantılarına **ana arenanın (Glibc)** bir kısmına işaret edecektir.\
Bu nedenle, bir chunk'ı unsorted bin içine **yerleştirip okuyabilirseniz** (free'den sonra kullanma) veya **en az 1 pointer'ı yazmadan tekrar tahsis ederseniz** ve ardından **okuyabilirseniz**, bir **Glibc bilgi sızıntısı** elde edebilirsiniz.

Bu yazımda kullanılan benzer bir [**saldırı**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html), 4 chunk yapısını (A, B, C ve D - D yalnızca üst chunk ile konsolidasyonu önlemek için) kötüye kullanmak için B'de bir null byte overflow kullanarak C'nin B'nin kullanılmadığını belirtmesini sağladı. Ayrıca, B'de `prev_size` verisi değiştirilerek boyutun B'nin boyutu yerine A+B olması sağlandı.\
Sonra C serbest bırakıldı ve A+B ile konsolide edildi (ancak B hala kullanılıyordu). A boyutunda yeni bir chunk tahsis edildi ve ardından libc sızdırılan adresler B'ye yazıldı ve buradan sızdırıldı.

## Referanslar ve Diğer Örnekler

- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap)
- Amaç, 4869'dan büyük bir değerle bir global değişkeni yazmaktır, böylece bayrağı almak mümkün olur ve PIE etkin değildir.
- Rastgele boyutlarda chunk'lar oluşturmak mümkündür ve istenen boyutta bir heap overflow vardır.
- Saldırı, 3 chunk oluşturarak başlar: overflow'u kötüye kullanmak için chunk0, taşan chunk için chunk1 ve üst chunk'un önceki chunk'larla konsolide olmaması için chunk2.
- Sonra, chunk1 serbest bırakılır ve chunk0, chunk1'in `bk` pointer'ına taşar: `bk = magic - 0x10`
- Ardından, chunk1 ile aynı boyutta chunk3 tahsis edilir, bu da unsorted bin saldırısını tetikleyecek ve global değişkenin değerini değiştirecektir, böylece bayrağı almak mümkün olacaktır.
- [**https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html)
- Birleştirme fonksiyonu, eğer geçen her iki indeks aynıysa, onu yeniden tahsis eder ve ardından serbest bırakır, ancak serbest bırakılan bölgeye bir pointer döndürür.
- Bu nedenle, **2 chunk oluşturulur**: **chunk0** kendisiyle birleştirilecek ve üst chunk ile konsolide olmayı önlemek için chunk1. Ardından, **birleştirme fonksiyonu chunk0 ile** iki kez çağrılır, bu da free'den sonra kullanma durumuna neden olur.
- Sonra, **`view`** fonksiyonu, free'den sonra kullanılan chunk'ın indeksi olan 2 ile çağrılır, bu da **bir libc adresini sızdırır**.
- Binary, yalnızca **`global_max_fast`**'tan daha büyük boyutları malloc etmeye izin verdiğinden, hızlı bin kullanılmadığı için bir unsorted bin saldırısı kullanılacak ve global değişken `global_max_fast`'ı yazmak için kullanılacaktır.
- Ardından, 2 indeksi (free'den sonra kullanılan pointer) ile edit fonksiyonu çağrılabilir ve `bk` pointer'ı `p64(global_max_fast-0x10)`'a işaret edecek şekilde yazılabilir. Ardından, daha önce tehlikeye atılmış serbest adresi (0x20) kullanarak yeni bir chunk oluşturmak, **unsorted bin saldırısını tetikleyecek** ve `global_max_fast`'ı çok büyük bir değerle yazacaktır, bu da artık hızlı binlerde chunk'lar oluşturmayı mümkün kılacaktır.
- Şimdi bir **hızlı bin saldırısı** gerçekleştirilir:
- Öncelikle, **`__free_hook`** konumunda hızlı **200 boyutunda chunk'larla çalışmanın mümkün olduğu keşfedilir**:
- <pre class="language-c"><code class="lang-c">gef➤  p &__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 <__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f <list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f <_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
- Bu konumda 0x200 boyutunda hızlı bir chunk elde edebilirsek, çalıştırılacak bir fonksiyon pointer'ını yazmak mümkün olacaktır.
- Bunun için, `0xfc` boyutunda yeni bir chunk oluşturulur ve birleştirilmiş fonksiyon bu pointer ile iki kez çağrılır, bu şekilde hızlı bin içinde `0xfc*2 = 0x1f8` boyutunda serbest bir chunk'a işaret eden bir pointer elde ederiz.
- Ardından, bu chunk'ta edit fonksiyonu çağrılarak bu hızlı binin **`fd`** adresi önceki **`__free_hook`** fonksiyonuna işaret edecek şekilde değiştirilir.
- Ardından, hızlı bin'den önceki işe yaramaz chunk'ı almak için `0x1f8` boyutunda bir chunk oluşturulur, böylece **`__free_hook`** içinde hızlı bir chunk elde etmek için `0x1f8` boyutunda başka bir chunk oluşturulur ve bu, **`system`** fonksiyonunun adresi ile yazılır.
- Ve nihayet, `/bin/sh\x00` dizesini içeren bir chunk serbest bırakılır ve delete fonksiyonu çağrılır, bu da **`__free_hook`** fonksiyonunu tetikler ve `/bin/sh\x00` parametresi ile system'a işaret eder.
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html)
- Unsorted bin'de chunk'ları konsolide etmek ve bir libc bilgi sızıntısı elde etmek için 1B overflow'un kötüye kullanılması ve ardından malloc hook'u bir gadget adresi ile yazmak için hızlı bin saldırısı gerçekleştirilmesi.
- [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
- Sadece `0x100`'den büyük boyutlarda chunk'lar tahsis edebiliriz.
- Unsorted Bin saldırısı kullanarak `global_max_fast`'ı yazmak (ASLR nedeniyle 1/16 kez çalışır, çünkü 12 bit değiştirmemiz gerekir, ancak 16 bit değiştirmeliyiz).
- Global bir chunk dizisini değiştirmek için hızlı bin saldırısı. Bu, GOT'u değiştirme ve bazı fonksiyonları `system`'a işaret etme yeteneği veren rastgele okuma/yazma ilkesini sağlar.

{{#include ../../banners/hacktricks-training.md}}
