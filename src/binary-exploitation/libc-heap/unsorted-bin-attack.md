# Unsorted Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Podstawowe informacje

Aby uzyskać więcej informacji o tym, czym jest unsorted bin sprawdź tę stronę:


{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Unsorted lists mogą zapisać adres `unsorted_chunks (av)` w polu `bk` chunku. Dlatego, jeśli atakujący potrafi **zmodyfikować adres wskaźnika `bk`** w chunku znajdującym się w unsorted bin, może być w stanie **zapisać ten adres pod dowolnym adresem**, co może pomóc w leakowaniu adresów Glibc lub obejściu pewnych zabezpieczeń.

Tak więc w praktyce ten atak pozwala **ustawić dużą wartość pod dowolnym adresem**. Ta duża wartość to adres, który może być adresem heap lub Glibc. Tradycyjnym celem było **`global_max_fast`**, aby umożliwić tworzenie fast binów o większych rozmiarach (i przejście z unsorted bin attack do fast bin attack).

- Uwaga (glibc ≥ 2.39): `global_max_fast` stał się globalem 8‑bitowym. Bezmyślne zapisanie tam wskaźnika przez unsorted‑bin write nadpisze sąsiednie dane libc i nie podniesie niezawodnie limitu fastbin. Lepiej wybierać inne cele lub inne prymitywy przy atakowaniu glibc 2.39+. Zobacz "Modern constraints" poniżej i rozważ łączenie z innymi technikami, jak [large bin attack](large-bin-attack.md) lub [fast bin attack](fast-bin-attack.md), gdy masz stabilny prymityw.

> [!TIP]
> T> Przejrzenie przykładu podanego w [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle) i użycie 0x4000 oraz 0x5000 zamiast 0x400 i 0x500 jako rozmiarów chunków (aby uniknąć Tcache) pokazuje, że **dziś** wywoływany jest błąd **`malloc(): unsorted double linked list corrupted`**.
>
> W związku z tym ten unsorted bin attack obecnie (oprócz innych sprawdzeń) wymaga także naprawienia listy dwukierunkowej, żeby obejść `victim->bk->fd == victim` lub `victim->fd == av (arena)`, co oznacza, że adres, pod który chcemy zapisać, musi mieć adres fałszywego chunku w swoim polu `fd`, oraz że `fd` fałszywego chunku wskazuje na arena.

> [!CAUTION]
> Uwaga, ten atak korumpuje unsorted bin (a więc także small i large). Możemy więc teraz tylko **używać alokacji z fast bin** (bardziej złożony program może wykonywać inne alokacje i się zawiesić), i aby wywołać to musimy **alokować tę samą wielkość, w przeciwnym razie program się rozbije.**
>
> Nadpisanie **`global_max_fast`** może w tym przypadku pomóc, zakładając, że fast bin poradzi sobie ze wszystkimi innymi alokacjami do czasu zakończenia exploitu.

Kod od [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin_attack/unsorted_explanation/index.html) wyjaśnia to bardzo dobrze, chociaż jeśli zmodyfikujesz mallocy tak, by alokowały pamięć na tyle dużą, żeby nie kończyć w Tcache, można zobaczyć wspomniany wcześniej błąd zapobiegający tej technice: **`malloc(): unsorted double linked list corrupted`**

### Jak zapis faktycznie zachodzi

- Unsorted‑bin write jest wyzwalany przy `free`, gdy zwolniony chunk jest wstawiany na początek unsorted listy.
- Podczas wstawiania alokator wykonuje: `bck = unsorted_chunks(av); fwd = bck->fd; victim->bk = bck; victim->fd = fwd; fwd->bk = victim; bck->fd = victim;`
- Jeśli możesz ustawić `victim->bk` na `(mchunkptr)(TARGET - 0x10)` przed wywołaniem `free(victim)`, to ostatnie przypisanie wykona zapis: `*(TARGET) = victim`.
- Później, kiedy alokator przetwarza unsorted bin, sprawdzenia integralności potwierdzą (m.in.), że `bck->fd == victim` oraz `victim->fd == unsorted_chunks(av)` zanim wykona unlink. Ponieważ podczas wstawiania już zapisano `victim` w `bck->fd` (naszym `TARGET`), te sprawdzenia mogą zostać spełnione jeśli zapis się powiódł.

## Ograniczenia w nowych wersjach (glibc ≥ 2.33)

Aby używać unsorted‑bin writes niezawodnie na aktualnym glibc:

- Tcache interference: dla rozmiarów mieszczących się w tcache, free są przekierowywane tam i nie trafiają do unsorted bin. Można:
  - robić żądania o rozmiarach > MAX_TCACHE_SIZE (≥ 0x410 na 64‑bit domyślnie), lub
  - zapełnić odpowiadający bin tcache (7 wpisów), tak aby kolejne free trafiły do global bins, lub
  - jeśli środowisko jest kontrolowane, wyłączyć tcache (np. GLIBC_TUNABLES glibc.malloc.tcache_count=0).
- Sprawdzenia integralności na unsorted list: na ścieżce alokacji, która bada unsorted bin, glibc sprawdza (uproszczone):
  - `bck->fd == victim` oraz `victim->fd == unsorted_chunks(av)`; w przeciwnym razie przerywa działanie z `malloc(): unsorted double linked list corrupted`.
- To oznacza, że adres, który atakujesz, musi tolerować dwa zapisy: najpierw `*(TARGET) = victim` w czasie free; później, gdy chunk jest usuwany, `*(TARGET) = unsorted_chunks(av)` (alokator nadpisuje `bck->fd` z powrotem adresem głowy binu). Wybierz cele, gdzie wymuszenie dużej, niezerowej wartości jest użyteczne.
- Typowe stabilne cele we współczesnych exploitach:
  - stan aplikacji lub globalny stan traktujący "duże" wartości jako flagi/limity,
  - pośrednie prymitywy (np. przygotowanie do późniejszego [fast bin attack]({{#ref}}fast-bin-attack.md{{#endref}}) lub pivot dla kolejnego write‑what‑where).
- Unikaj `__malloc_hook`/`__free_hook` w nowych glibc: zostały usunięte w 2.34. Unikaj `global_max_fast` w wersjach ≥ 2.39 (zob. powyżej).

- O `global_max_fast` w nowszym glibc
  - W glibc 2.39+ `global_max_fast` jest globalem 8‑bitowym. Klasyczny trik zapisania wskaźnika heap tam (by powiększyć fastbins) już nie działa czysto i prawdopodobnie skazi sąsiedni stan alokatora. Lepiej stosować inne strategie.

## Minimalny przepis na eksploatację (nowoczesny glibc)

Cel: uzyskać pojedynczy arbitralny zapis wskaźnika heap na dowolny adres przy użyciu prymitywu wstawiania unsorted‑bin, bez wywoływania crasha.

- Layout/grooming
  - Alokuj A, B, C o rozmiarach wystarczająco dużych, by ominąć tcache (np. 0x5000). C zapobiega konsolidacji z top chunk.
- Corruption
  - Overflow z A do nagłówka chunku B, aby ustawić `B->bk = (mchunkptr)(TARGET - 0x10)`.
- Trigger
  - `free(B)`. W czasie wstawiania alokator wykona `bck->fd = B`, więc `*(TARGET) = B`.
- Kontynuacja
  - Jeśli planujesz kontynuować alokacje i program używa unsorted bin, spodziewaj się, że alokator później ustawi `*(TARGET) = unsorted_chunks(av)`. Obie wartości zwykle są duże i mogą wystarczyć do zmiany semantyki rozmiaru/limitów w celach, które tylko sprawdzają "duże".

Szkielet pseudokodu:
```c
// 64-bit glibc 2.35–2.38 style layout (tcache bypass via large sizes)
void *A = malloc(0x5000);
void *B = malloc(0x5000);
void *C = malloc(0x5000); // guard

// overflow from A into B’s metadata (prev_size/size/.../bk). You must control B->bk.
*(size_t *)((char*)B - 0x8) = (size_t)(TARGET - 0x10); // write fake bk

free(B); // triggers *(TARGET) = B (unsorted-bin insertion write)
```
> [!NOTE]
> • Jeśli nie możesz ominąć tcache za pomocą rozmiaru, zapełnij tcache bin dla wybranego rozmiaru (7 frees) przed zwolnieniem uszkodzonego chunku, aby free trafił do unsorted.
> • Jeśli program natychmiast przerywa wykonanie przy następnej alokacji z powodu unsorted-bin checks, sprawdź ponownie, czy `victim->fd` wciąż równa się bin head oraz czy twój `TARGET` zawiera dokładny pointer do `victim` po pierwszym zapisie.

## Unsorted Bin Infoleak Attack

To w istocie bardzo podstawowa koncepcja. Chunks w unsorted bin będą zawierać wskaźniki. Pierwszy chunk w unsorted bin będzie faktycznie miał linki **`fd`** i **`bk`** **wskazujące na część main arena (Glibc)**.\
W związku z tym, jeśli możesz **umieścić chunk w unsorted bin i go odczytać** (use after free) lub **alokować go ponownie bez nadpisania przynajmniej jednego z wskaźników**, a następnie go **odczytać**, możesz uzyskać **Glibc info leak**.

Podobny [**atak użyty w tym writeupie**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html) polegał na nadużyciu struktury 4 chunków (A, B, C i D — D służy tylko do zapobieżenia konsolidacji z top chunk), więc null byte overflow w B został użyty, by sprawić, że C będzie wskazywać, że B jest nieużywany. Dodatkowo w B pole `prev_size` zostało zmodyfikowane tak, że rozmiar zamiast być rozmiarem B był A+B.\
Następnie C został zwolniony i skonsolidowany z A+B (ale B nadal był używany). Przydzielono nowy chunk o rozmiarze A, a potem do B zapisano libc leaked addresses, skąd następnie je odczytano.

## Referencje i inne przykłady

- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap)
- Celem jest nadpisanie zmiennej globalnej wartością większą niż 4869, aby możliwe było zdobycie flagi i PIE nie jest włączone.
- Możliwe jest wygenerowanie chunków o dowolnych rozmiarach i istnieje heap overflow o żądanym rozmiarze.
- Atak zaczyna się od stworzenia 3 chunków: chunk0 do nadużycia overflow, chunk1 który ma być overflowowany oraz chunk2, aby top chunk nie skonsolidował poprzednich.
- Następnie chunk1 jest zwalniany, a chunk0 jest overflowowany tak, że `bk` wskazywane przez chunk1 pokazuje na: `bk = magic - 0x10`
- Potem alokowany jest chunk3 o tym samym rozmiarze co chunk1, co wywoła unsorted bin attack i zmodyfikuje wartość zmiennej globalnej, umożliwiając zdobycie flagi.
- [**https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html)
- Funkcja merge jest podatna, ponieważ jeśli oba przekazane indeksy są takie same, to następuje realloc na tym indeksie, a potem jego free, ale zwracany jest pointer do tej zwolnionej regionu, który można wykorzystać.
- W związku z tym **tworzone są 2 chunky**: **chunk0**, który zostanie scalony sam ze sobą, oraz chunk1 żeby zapobiec konsolidacji z top chunk. Następnie **merge function jest wywoływana dla chunk0** dwukrotnie, co spowoduje use after free.
- Potem wywoływana jest funkcja **`view`** z indeksem 2 (który odpowiada use after free chunkowi), co spowoduje **leak libc address**.
- Ponieważ binarka ma zabezpieczenia, które pozwalają mallocować tylko rozmiary większe niż **`global_max_fast`**, więc nie używa się fastbinów — zastosowany zostanie unsorted bin attack, aby nadpisać zmienną globalną `global_max_fast`.
- Następnie można wywołać funkcję edycji z indeksem 2 (pointer use after free) i nadpisać wskaźnik `bk`, aby wskazywał na `p64(global_max_fast-0x10)`. Potem stworzenie nowego chunku użyje wcześniej skompromitowanego adresu free (0x20) i **wywoła unsorted bin attack**, nadpisując `global_max_fast` na bardzo dużą wartość, co pozwoli teraz tworzyć chunki w fast binach.
- Teraz wykonywany jest **fast bin attack**:
- Najpierw odkryto, że można pracować z fast **chunkami o rozmiarze 200** w lokalizacji **`__free_hook`**:
- <pre class="language-c"><code class="lang-c">gef➤  p &__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 <__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f <list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f <_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
- Jeśli uda się uzyskać fast chunk o rozmiarze 0x200 w tej lokalizacji, będzie można nadpisać wskaźnik funkcji, który zostanie wykonany.
- W tym celu tworzony jest nowy chunk o rozmiarze `0xfc` i funkcja merge jest wywoływana z tym wskaźnikiem dwukrotnie — w ten sposób uzyskujemy pointer do zwolnionego chunku o rozmiarze `0xfc*2 = 0x1f8` w fast binie.
- Potem wywoływana jest funkcja edycji na tym chunku, aby zmodyfikować adres **`fd`** tego fast binu tak, aby wskazywał na poprzedni **`__free_hook`**.
- Następnie alokowany jest chunk o rozmiarze `0x1f8`, aby pobrać ze fast binu poprzedni nieużyteczny chunk, a potem kolejny chunk o rozmiarze `0x1f8`, aby otrzymać fast bin chunk w **`__free_hook`**, który jest nadpisywany adresem funkcji **`system`**.
- I w końcu chunk zawierający string `/bin/sh\x00` jest zwalniany przez wywołanie funkcji delete, wywołując **`__free_hook`**, które teraz wskazuje na system z `/bin/sh\x00` jako parametrem.
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html)
- Kolejny przykład nadużycia 1B overflow, aby skonsolidować chunki w unsorted bin i uzyskać libc infoleak, a następnie przeprowadzić fast bin attack w celu nadpisania malloc hook adresem one gadget.
- [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
- Możemy alokować tylko chunki o rozmiarze większym niż `0x100`.
- Nadpisanie `global_max_fast` przy użyciu Unsorted Bin attack (działa 1/16 razy z powodu ASLR, ponieważ trzeba zmodyfikować 12 bitów, ale trzeba zmodyfikować 16 bitów).
- Fast Bin attack, aby zmodyfikować globalną tablicę chunków. To daje arbitralny read/write primitive, co pozwala na modyfikację GOT i ustawienie pewnej funkcji, by wskazywała na `system`.

## References

- Glibc malloc unsorted-bin integrity checks (example in 2.33 source): https://elixir.bootlin.com/glibc/glibc-2.33/source/malloc/malloc.c
- `global_max_fast` and related definitions in modern glibc (2.39): https://elixir.bootlin.com/glibc/glibc-2.39/source/malloc/malloc.c
{{#include ../../banners/hacktricks-training.md}}
