# Unsorted Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

For more information about what is an unsorted bin check this page:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Unsorted सूचियाँ `unsorted_chunks (av)` के पते को चंक के `bk` पते में लिखने में सक्षम होती हैं। इसलिए, यदि एक हमलावर **चंक के `bk` पॉइंटर के पते को संशोधित कर सकता है** जो अनसॉर्टेड बिन के अंदर है, तो वह **उस पते को एक मनमाने पते पर लिखने में सक्षम हो सकता है** जो Glibc पते को लीक करने या कुछ रक्षा को बायपास करने में सहायक हो सकता है।

तो, मूल रूप से, यह हमला **एक मनमाने पते पर एक बड़ा नंबर सेट करने की अनुमति देता है**। यह बड़ा नंबर एक पता है, जो एक हीप पता या एक Glibc पता हो सकता है। एक सामान्य लक्ष्य **`global_max_fast`** है ताकि बड़े आकार के फास्ट बिन बिन बनाए जा सकें (और अनसॉर्टेड बिन हमले से फास्ट बिन हमले में जाया जा सके)।

> [!TIP]
> उदाहरण पर नज़र डालने के लिए [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#principle) पर जाएं और 0x4000 और 0x5000 का उपयोग करें 0x400 और 0x500 के बजाय चंक आकार के रूप में (Tcache से बचने के लिए) यह देखना संभव है कि **आजकल** त्रुटि **`malloc(): unsorted double linked list corrupted`** सक्रिय होती है।
>
> इसलिए, यह अनसॉर्टेड बिन हमला अब (अन्य जांचों के बीच) यह भी आवश्यक है कि डबल लिंक्ड लिस्ट को ठीक किया जा सके ताकि यह बायपास किया जा सके `victim->bk->fd == victim` या नहीं `victim->fd == av (arena)` का मतलब है कि जिस पते पर हम लिखना चाहते हैं, उसमें नकली चंक के `fd` स्थिति में पता होना चाहिए और नकली चंक `fd` एरेना की ओर इशारा कर रहा है।

> [!CAUTION]
> ध्यान दें कि यह हमला अनसॉर्टेड बिन को भ्रष्ट करता है (इसलिए छोटे और बड़े भी)। इसलिए हम केवल **अब फास्ट बिन से आवंटन का उपयोग कर सकते हैं** (एक अधिक जटिल प्रोग्राम अन्य आवंटन कर सकता है और क्रैश हो सकता है), और इसे सक्रिय करने के लिए हमें **समान आकार आवंटित करना चाहिए या प्रोग्राम क्रैश हो जाएगा।**
>
> ध्यान दें कि **`global_max_fast`** को ओवरराइट करना इस मामले में मदद कर सकता है यह मानते हुए कि फास्ट बिन सभी अन्य आवंटनों का ध्यान रख सकेगा जब तक कि शोषण पूरा नहीं हो जाता।

[**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin_attack/unsorted_explanation/index.html) से कोड इसे बहुत अच्छी तरह से समझाता है, हालांकि यदि आप mallocs को इस तरह से संशोधित करते हैं कि पर्याप्त बड़ा मेमोरी आवंटित करें ताकि Tcache में समाप्त न हो, तो आप देख सकते हैं कि पहले से उल्लेखित त्रुटि प्रकट होती है जो इस तकनीक को रोकती है: **`malloc(): unsorted double linked list corrupted`**

## Unsorted Bin Infoleak Attack

यह वास्तव में एक बहुत बुनियादी अवधारणा है। अनसॉर्टेड बिन में चंक के पास पॉइंटर्स होंगे। अनसॉर्टेड बिन में पहला चंक वास्तव में **`fd`** और **`bk`** लिंक को **मुख्य एरेना (Glibc)** के एक भाग की ओर इशारा करेगा।\
इसलिए, यदि आप **एक चंक को अनसॉर्टेड बिन में डाल सकते हैं और इसे पढ़ सकते हैं** (फ्री के बाद उपयोग) या **कम से कम 1 पॉइंटर को ओवरराइट किए बिना इसे फिर से आवंटित कर सकते हैं** ताकि फिर **इसे पढ़ सकें**, तो आप एक **Glibc जानकारी लीक** प्राप्त कर सकते हैं।

एक समान [**हमला जो इस लेख में उपयोग किया गया**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw18_alienVSsamurai/index.html), 4 चंक संरचना (A, B, C और D - D केवल शीर्ष चंक के साथ समेकन को रोकने के लिए है) का दुरुपयोग करने के लिए था, इसलिए B में एक शून्य बाइट ओवरफ्लो का उपयोग किया गया था ताकि C यह संकेत दे सके कि B अप्रयुक्त था। इसके अलावा, B में `prev_size` डेटा को संशोधित किया गया ताकि आकार B का आकार न होकर A+B हो।\
फिर C को डिएक्लेट किया गया, और A+B के साथ समेकित किया गया (लेकिन B अभी भी उपयोग में था)। आकार A का एक नया चंक आवंटित किया गया और फिर लीक किए गए libc पते B में लिखे गए जहां से उन्हें लीक किया गया।

## References & Other examples

- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap)
- लक्ष्य एक वैश्विक चर को 4869 से अधिक के मान के साथ ओवरराइट करना है ताकि यह संभव हो सके कि ध्वज प्राप्त किया जा सके और PIE सक्षम नहीं है।
- यह मनमाने आकार के चंक उत्पन्न करना संभव है और वांछित आकार के साथ एक हीप ओवरफ्लो है।
- हमला 3 चंक बनाने से शुरू होता है: चंक0 ओवरफ्लो का दुरुपयोग करने के लिए, चंक1 ओवरफ्लो होने के लिए और चंक2 ताकि शीर्ष चंक पिछले लोगों के साथ समेकित न हो।
- फिर, चंक1 को मुक्त किया जाता है और चंक0 को ओवरफ्लो किया जाता है ताकि चंक1 के `bk` पॉइंटर को इंगित किया जा सके: `bk = magic - 0x10`
- फिर, चंक3 को चंक1 के समान आकार के साथ आवंटित किया जाता है, जो अनसॉर्टेड बिन हमले को सक्रिय करेगा और वैश्विक चर के मान को संशोधित करेगा, जिससे ध्वज प्राप्त करना संभव होगा।
- [**https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html)
- मर्ज फ़ंक्शन कमजोर है क्योंकि यदि दोनों पास किए गए अनुक्रमांक समान हैं तो यह उस पर पुनः आवंटित करेगा और फिर इसे मुक्त करेगा लेकिन उस मुक्त क्षेत्र के लिए एक पॉइंटर लौटाएगा जिसका उपयोग किया जा सकता है।
- इसलिए, **2 चंक बनाए जाते हैं**: **चंक0** जो अपने साथ मर्ज किया जाएगा और चंक1 ताकि शीर्ष चंक के साथ समेकन को रोक सके। फिर, **चंक0 के साथ मर्ज फ़ंक्शन** को दो बार कॉल किया जाता है जो फ्री के बाद उपयोग का कारण बनेगा।
- फिर, **`view`** फ़ंक्शन को अनुक्रमांक 2 (जो फ्री के बाद उपयोग चंक का अनुक्रमांक है) के साथ कॉल किया जाता है, जो **एक libc पता लीक करेगा**।
- चूंकि बाइनरी में केवल **`global_max_fast`** से बड़े आकार के malloc की सुरक्षा है, इसलिए कोई फास्टबिन का उपयोग नहीं किया जाता है, एक अनसॉर्टेड बिन हमला वैश्विक चर `global_max_fast` को ओवरराइट करने के लिए उपयोग किया जाएगा।
- फिर, यह संभव है कि अनुक्रमांक 2 (फ्री के बाद उपयोग पॉइंटर) के साथ संपादित फ़ंक्शन को कॉल किया जाए और `bk` पॉइंटर को `p64(global_max_fast-0x10)` की ओर इशारा करने के लिए ओवरराइट किया जाए। फिर, एक नया चंक बनाने से पहले से समझौता किए गए मुक्त पते (0x20) का उपयोग किया जाएगा जो **अनसॉर्टेड बिन हमले को सक्रिय करेगा** `global_max_fast` को ओवरराइट करते हुए जो एक बहुत बड़ा मान है, जिससे अब फास्ट बिन में चंक बनाना संभव हो गया है।
- अब एक **फास्ट बिन हमला** किया जाता है:
- सबसे पहले यह पता चलता है कि **`__free_hook`** स्थान में फास्ट **चंक के आकार 200** के साथ काम करना संभव है:
- <pre class="language-c"><code class="lang-c">gef➤  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
- यदि हम इस स्थान पर आकार 0x200 का एक फास्ट चंक प्राप्त करने में सफल होते हैं, तो एक फ़ंक्शन पॉइंटर को ओवरराइट करना संभव होगा जिसे निष्पादित किया जाएगा।
- इसके लिए, आकार `0xfc` का एक नया चंक बनाया जाता है और मर्ज फ़ंक्शन को उस पॉइंटर के साथ दो बार कॉल किया जाता है, इस तरह हम फास्ट बिन में आकार `0xfc*2 = 0x1f8` के एक मुक्त चंक के लिए एक पॉइंटर प्राप्त करते हैं।
- फिर, इस चंक में संपादित फ़ंक्शन को कॉल किया जाता है ताकि इस फास्ट बिन के **`fd`** पते को पिछले **`__free_hook`** फ़ंक्शन की ओर इशारा करने के लिए संशोधित किया जा सके।
- फिर, आकार `0x1f8` का एक चंक बनाया जाता है ताकि फास्ट बिन से पिछले बेकार चंक को पुनः प्राप्त किया जा सके ताकि आकार `0x1f8` का एक और चंक बनाया जा सके ताकि **`__free_hook`** में एक फास्ट बिन चंक प्राप्त किया जा सके जिसे **`system`** फ़ंक्शन के पते के साथ ओवरराइट किया गया है।
- और अंत में, एक चंक जिसमें स्ट्रिंग `/bin/sh\x00` है, को डिलीट फ़ंक्शन को कॉल करके मुक्त किया जाता है, जो **`__free_hook`** फ़ंक्शन को सक्रिय करता है जो सिस्टम को `/bin/sh\x00` को पैरामीटर के रूप में इंगित करता है।
- **CTF** [**https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html**](https://guyinatuxedo.github.io/33-custom_misc_heap/csaw19_traveller/index.html)
- अनसॉर्टेड बिन में चंक्स को समेकित करने और libc जानकारी लीक प्राप्त करने के लिए 1B ओवरफ्लो का दुरुपयोग करने का एक और उदाहरण और फिर malloc हुक को एक गड़बड़ पते के साथ ओवरराइट करने के लिए फास्ट बिन हमले को करना।
- [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
- हम केवल `0x100` से बड़े आकार के चंक्स आवंटित कर सकते हैं।
- अनसॉर्टेड बिन हमले का उपयोग करके `global_max_fast` को ओवरराइट करें (ASLR के कारण 1/16 बार काम करता है, क्योंकि हमें 12 बिट्स को संशोधित करना है, लेकिन हमें 16 बिट्स को संशोधित करना होगा)।
- एक वैश्विक चंक्स के एरे को संशोधित करने के लिए फास्ट बिन हमला। यह एक मनमाना पढ़ने/लिखने की प्राइमिटिव देता है, जो GOT को संशोधित करने और कुछ फ़ंक्शन को `system` की ओर इशारा करने की अनुमति देता है।

{{#include ../../banners/hacktricks-training.md}}
