# Large Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Kwa maelezo zaidi kuhusu nini bin kubwa angalia ukurasa huu:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Inawezekana kupata mfano mzuri katika [**how2heap - large bin attack**](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/large_bin_attack.c).

Kimsingi hapa unaweza kuona jinsi, katika toleo la hivi karibuni "current" la glibc (2.35), halijakaguliwa: **`P->bk_nextsize`** ikiruhusu kubadilisha anwani isiyo ya kawaida kwa thamani ya kipande kikubwa cha bin ikiwa masharti fulani yamekamilika.

Katika mfano huo unaweza kupata masharti yafuatayo:

- Kipande kikubwa kimepewa
- Kipande kikubwa kidogo kuliko cha kwanza lakini katika index ile ile kimepewa
- Lazima kiwe kidogo hivyo katika bin lazima kiwe cha kwanza
- (Kipande cha kuzuia kuungana na kipande cha juu kinaundwa)
- Kisha, kipande cha kwanza kikubwa kinachukuliwa na kipande kipya kikubwa zaidi kinapewa -> Chunk1 kinaenda kwenye bin kubwa
- Kisha, kipande cha pili kikubwa kinachukuliwa
- Sasa, udhaifu: Mshambuliaji anaweza kubadilisha `chunk1->bk_nextsize` kuwa `[target-0x20]`
- Kisha, kipande kikubwa zaidi kuliko chunk 2 kinapewa, hivyo chunk2 inaingizwa kwenye bin kubwa ikifuta anwani `chunk1->bk_nextsize->fd_nextsize` kwa anwani ya chunk2

> [!TIP]
> Kuna hali nyingine zinazoweza kutokea, jambo ni kuongeza kwenye bin kubwa kipande ambacho ni **kidogo** kuliko kipande cha sasa X kilichomo kwenye bin, hivyo inahitaji kuingizwa kabla yake kwenye bin, na tunahitaji kuwa na uwezo wa kubadilisha **`bk_nextsize`** ya X kwani hapo ndipo anwani ya kipande kidogo itakapandikizwa.

Hii ndiyo code muhimu kutoka malloc. Maoni yameongezwa ili kuelewa vizuri jinsi anwani ilivyofutwa:
```c
/* if smaller than smallest, bypass loop below */
assert (chunk_main_arena (bck->bk));
if ((unsigned long) (size) < (unsigned long) chunksize_nomask (bck->bk))
{
fwd = bck; // fwd = p1
bck = bck->bk; // bck = p1->bk

victim->fd_nextsize = fwd->fd; // p2->fd_nextsize = p1->fd (Note that p1->fd is p1 as it's the only chunk)
victim->bk_nextsize = fwd->fd->bk_nextsize; // p2->bk_nextsize = p1->fd->bk_nextsize
fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim; // p1->fd->bk_nextsize->fd_nextsize = p2
}
```
Hii inaweza kutumika **kuandika upya `global_max_fast` variable ya global** ya libc ili kisha kutumia shambulio la fast bin na vipande vikubwa.

Unaweza kupata maelezo mengine mazuri kuhusu shambulio hili katika [**guyinatuxedo**](https://guyinatuxedo.github.io/32-largebin_attack/largebin_explanation0/index.html).

### Mifano mingine

- [**La casa de papel. HackOn CTF 2024**](https://7rocky.github.io/en/ctf/other/hackon-ctf/la-casa-de-papel/)
- Shambulio la large bin katika hali sawa na inavyoonekana katika [**how2heap**](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/large_bin_attack.c).
- Primitive ya kuandika ni ngumu zaidi, kwa sababu `global_max_fast` haina maana hapa.
- FSOP inahitajika kumaliza exploit.

{{#include ../../banners/hacktricks-training.md}}
