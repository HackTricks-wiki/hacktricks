# Large Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Per ulteriori informazioni su cosa sia un large bin, controlla questa pagina:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

È possibile trovare un ottimo esempio in [**how2heap - large bin attack**](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/large_bin_attack.c).

Fondamentalmente, qui puoi vedere come, nell'ultima versione "attuale" di glibc (2.35), non viene controllato: **`P->bk_nextsize`** consentendo di modificare un indirizzo arbitrario con il valore di un chunk di large bin se vengono soddisfatte determinate condizioni.

In quell'esempio puoi trovare le seguenti condizioni:

- Un grande chunk è allocato
- Un grande chunk più piccolo del primo ma nello stesso indice è allocato
- Deve essere più piccolo, quindi deve andare per primo nel bin
- (Un chunk per prevenire la fusione con il chunk superiore è creato)
- Poi, il primo grande chunk viene liberato e un nuovo chunk più grande di esso viene allocato -> Chunk1 va nel large bin
- Poi, il secondo grande chunk viene liberato
- Ora, la vulnerabilità: L'attaccante può modificare `chunk1->bk_nextsize` in `[target-0x20]`
- Poi, un chunk più grande del chunk 2 viene allocato, quindi chunk2 viene inserito nel large bin sovrascrivendo l'indirizzo `chunk1->bk_nextsize->fd_nextsize` con l'indirizzo di chunk2

> [!TIP]
> Ci sono altri scenari potenziali, la cosa è aggiungere al large bin un chunk che è **più piccolo** di un attuale chunk X nel bin, quindi deve essere inserito proprio prima di esso nel bin, e dobbiamo essere in grado di modificare **`bk_nextsize`** di X poiché è lì che verrà scritto l'indirizzo del chunk più piccolo.

Questo è il codice rilevante da malloc. Sono stati aggiunti commenti per comprendere meglio come l'indirizzo è stato sovrascritto:
```c
/* if smaller than smallest, bypass loop below */
assert (chunk_main_arena (bck->bk));
if ((unsigned long) (size) < (unsigned long) chunksize_nomask (bck->bk))
{
fwd = bck; // fwd = p1
bck = bck->bk; // bck = p1->bk

victim->fd_nextsize = fwd->fd; // p2->fd_nextsize = p1->fd (Note that p1->fd is p1 as it's the only chunk)
victim->bk_nextsize = fwd->fd->bk_nextsize; // p2->bk_nextsize = p1->fd->bk_nextsize
fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim; // p1->fd->bk_nextsize->fd_nextsize = p2
}
```
Questo potrebbe essere utilizzato per **sovrascrivere la variabile globale `global_max_fast`** di libc per poi sfruttare un attacco fast bin con chunk più grandi.

Puoi trovare un'altra ottima spiegazione di questo attacco in [**guyinatuxedo**](https://guyinatuxedo.github.io/32-largebin_attack/largebin_explanation0/index.html).

### Altri esempi

- [**La casa de papel. HackOn CTF 2024**](https://7rocky.github.io/en/ctf/other/hackon-ctf/la-casa-de-papel/)
- Attacco large bin nella stessa situazione in cui appare in [**how2heap**](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/large_bin_attack.c).
- La scrittura primitiva è più complessa, perché `global_max_fast` è inutile qui.
- FSOP è necessario per completare l'exploit.

{{#include ../../banners/hacktricks-training.md}}
