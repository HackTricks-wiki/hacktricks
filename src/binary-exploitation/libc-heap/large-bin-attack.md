# Large Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Grundinformationen

Für weitere Informationen darüber, was ein großer Bin ist, siehe diese Seite:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Ein großartiges Beispiel findet sich in [**how2heap - large bin attack**](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/large_bin_attack.c).

Im Grunde genommen sieht man hier, dass in der neuesten "aktuellen" Version von glibc (2.35) nicht überprüft wird: **`P->bk_nextsize`**, was es ermöglicht, eine beliebige Adresse mit dem Wert eines großen Bin-Chunks zu modifizieren, wenn bestimmte Bedingungen erfüllt sind.

In diesem Beispiel finden sich die folgenden Bedingungen:

- Ein großer Chunk wird zugewiesen
- Ein großer Chunk, der kleiner ist als der erste, aber im selben Index ist, wird zugewiesen
- Muss kleiner sein, damit er zuerst in den Bin geht
- (Ein Chunk wird erstellt, um das Zusammenführen mit dem oberen Chunk zu verhindern)
- Dann wird der erste große Chunk freigegeben und ein neuer Chunk, der größer ist als dieser, wird zugewiesen -> Chunk1 geht in den großen Bin
- Dann wird der zweite große Chunk freigegeben
- Jetzt die Verwundbarkeit: Der Angreifer kann `chunk1->bk_nextsize` auf `[target-0x20]` modifizieren
- Dann wird ein größerer Chunk als Chunk 2 zugewiesen, sodass Chunk2 in den großen Bin eingefügt wird und die Adresse `chunk1->bk_nextsize->fd_nextsize` mit der Adresse von Chunk2 überschreibt

> [!TIP]
> Es gibt andere potenzielle Szenarien, das Ziel ist es, einen Chunk, der **kleiner** ist als ein aktueller X Chunk im Bin, zum großen Bin hinzuzufügen, sodass er direkt davor im Bin eingefügt werden muss, und wir müssen in der Lage sein, X's **`bk_nextsize`** zu modifizieren, da dort die Adresse des kleineren Chunks geschrieben wird.

Dies ist der relevante Code von malloc. Kommentare wurden hinzugefügt, um besser zu verstehen, wie die Adresse überschrieben wurde:
```c
/* if smaller than smallest, bypass loop below */
assert (chunk_main_arena (bck->bk));
if ((unsigned long) (size) < (unsigned long) chunksize_nomask (bck->bk))
{
fwd = bck; // fwd = p1
bck = bck->bk; // bck = p1->bk

victim->fd_nextsize = fwd->fd; // p2->fd_nextsize = p1->fd (Note that p1->fd is p1 as it's the only chunk)
victim->bk_nextsize = fwd->fd->bk_nextsize; // p2->bk_nextsize = p1->fd->bk_nextsize
fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim; // p1->fd->bk_nextsize->fd_nextsize = p2
}
```
Dies könnte verwendet werden, um **die globale Variable `global_max_fast` von libc zu überschreiben**, um dann einen Fast-Bin-Angriff mit größeren Chunks auszunutzen.

Eine weitere großartige Erklärung dieses Angriffs finden Sie bei [**guyinatuxedo**](https://guyinatuxedo.github.io/32-largebin_attack/largebin_explanation0/index.html).

### Weitere Beispiele

- [**La casa de papel. HackOn CTF 2024**](https://7rocky.github.io/en/ctf/other/hackon-ctf/la-casa-de-papel/)
- Large Bin Angriff in der gleichen Situation, wie er in [**how2heap**](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/large_bin_attack.c) erscheint.
- Der Schreibprimitive ist komplexer, da `global_max_fast` hier nutzlos ist.
- FSOP wird benötigt, um den Exploit abzuschließen.

{{#include ../../banners/hacktricks-training.md}}
