# Large Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

एक बड़े बिन के बारे में अधिक जानकारी के लिए इस पृष्ठ को देखें:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

आप [**how2heap - large bin attack**](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/large_bin_attack.c) में एक शानदार उदाहरण देख सकते हैं।

बुनियादी रूप से, यहाँ आप देख सकते हैं कि glibc (2.35) के नवीनतम "वर्तमान" संस्करण में, यह जांचा नहीं जाता है: **`P->bk_nextsize`** जिससे एक बड़े बिन चंक के मान के साथ एक मनमाना पते को संशोधित करना संभव है यदि कुछ शर्तें पूरी होती हैं।

उस उदाहरण में आप निम्नलिखित शर्तें पा सकते हैं:

- एक बड़ा चंक आवंटित किया गया है
- पहले से छोटे एक बड़े चंक को उसी इंडेक्स में आवंटित किया गया है
- इसे बिन में पहले आना चाहिए
- (एक चंक शीर्ष चंक के साथ विलय को रोकने के लिए बनाया गया है)
- फिर, पहले बड़े चंक को मुक्त किया जाता है और इससे बड़ा एक नया चंक आवंटित किया जाता है -> Chunk1 बड़े बिन में जाता है
- फिर, दूसरे बड़े चंक को मुक्त किया जाता है
- अब, भेद्यता: हमलावर `chunk1->bk_nextsize` को `[target-0x20]` में संशोधित कर सकता है
- फिर, चंक 2 से बड़ा एक चंक आवंटित किया जाता है, इसलिए चंक2 बड़े बिन में डाला जाता है जो `chunk1->bk_nextsize->fd_nextsize` के पते को चंक2 के पते से ओवरराइट करता है

> [!TIP]
> अन्य संभावित परिदृश्य हैं, बात यह है कि बड़े बिन में एक चंक जोड़ना है जो बिन में वर्तमान X चंक से **छोटा** है, इसलिए इसे बिन में इसके ठीक पहले डाला जाना चाहिए, और हमें X के **`bk_nextsize`** को संशोधित करने में सक्षम होना चाहिए क्योंकि वहीं छोटे चंक का पता लिखा जाएगा।

यह malloc से संबंधित कोड है। समझने के लिए टिप्पणियाँ जोड़ी गई हैं कि पता कैसे ओवरराइट किया गया:
```c
/* if smaller than smallest, bypass loop below */
assert (chunk_main_arena (bck->bk));
if ((unsigned long) (size) < (unsigned long) chunksize_nomask (bck->bk))
{
fwd = bck; // fwd = p1
bck = bck->bk; // bck = p1->bk

victim->fd_nextsize = fwd->fd; // p2->fd_nextsize = p1->fd (Note that p1->fd is p1 as it's the only chunk)
victim->bk_nextsize = fwd->fd->bk_nextsize; // p2->bk_nextsize = p1->fd->bk_nextsize
fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim; // p1->fd->bk_nextsize->fd_nextsize = p2
}
```
यह **libc के `global_max_fast` वैश्विक चर** को ओवरराइट करने के लिए उपयोग किया जा सकता है ताकि बड़े टुकड़ों के साथ एक तेज़ बिन हमले का शोषण किया जा सके।

आप इस हमले का एक और शानदार विवरण [**guyinatuxedo**](https://guyinatuxedo.github.io/32-largebin_attack/largebin_explanation0/index.html) में पा सकते हैं।

### अन्य उदाहरण

- [**La casa de papel. HackOn CTF 2024**](https://7rocky.github.io/en/ctf/other/hackon-ctf/la-casa-de-papel/)
- उसी स्थिति में बड़े बिन हमले के बारे में [**how2heap**](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/large_bin_attack.c) में।
- लिखने की प्राइमिटिव अधिक जटिल है, क्योंकि `global_max_fast` यहाँ बेकार है।
- शोषण को समाप्त करने के लिए FSOP की आवश्यकता है।

{{#include ../../banners/hacktricks-training.md}}
