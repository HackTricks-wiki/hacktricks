# Large Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Для отримання додаткової інформації про те, що таке великий бін, перегляньте цю сторінку:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Можна знайти чудовий приклад у [**how2heap - large bin attack**](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/large_bin_attack.c).

В основному, тут ви можете побачити, як у останній "поточній" версії glibc (2.35) не перевіряється: **`P->bk_nextsize`**, що дозволяє змінювати довільну адресу значенням великого бін-чанка, якщо виконуються певні умови.

У цьому прикладі ви можете знайти такі умови:

- Виділено великий чанк
- Виділено великий чанк, менший за перший, але в тому ж індексі
- Повинен бути меншим, тому в біні він повинен йти першим
- (Створюється чанк, щоб запобігти злиттю з верхнім чанком)
- Потім перший великий чанк звільняється, і виділяється новий чанк, більший за нього -> Chunk1 потрапляє до великого біна
- Потім другий великий чанк звільняється
- Тепер вразливість: Зловмисник може змінити `chunk1->bk_nextsize` на `[target-0x20]`
- Потім виділяється більший чанк, ніж чанк 2, тому chunk2 вставляється у великий бін, перезаписуючи адресу `chunk1->bk_nextsize->fd_nextsize` адресою chunk2

> [!TIP]
> Є й інші потенційні сценарії, суть полягає в тому, щоб додати до великого біна чанк, який є **меншим** за поточний X чанк у біні, тому його потрібно вставити безпосередньо перед ним у біні, і ми повинні мати можливість змінити **`bk_nextsize`** X, оскільки саме туди буде записана адреса меншого чанка.

Це відповідний код з malloc. Коментарі були додані, щоб краще зрозуміти, як адреса була перезаписана:
```c
/* if smaller than smallest, bypass loop below */
assert (chunk_main_arena (bck->bk));
if ((unsigned long) (size) < (unsigned long) chunksize_nomask (bck->bk))
{
fwd = bck; // fwd = p1
bck = bck->bk; // bck = p1->bk

victim->fd_nextsize = fwd->fd; // p2->fd_nextsize = p1->fd (Note that p1->fd is p1 as it's the only chunk)
victim->bk_nextsize = fwd->fd->bk_nextsize; // p2->bk_nextsize = p1->fd->bk_nextsize
fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim; // p1->fd->bk_nextsize->fd_nextsize = p2
}
```
Це може бути використано для **перезапису глобальної змінної `global_max_fast`** libc, щоб потім експлуатувати атаку на швидкі контейнери з більшими частинами.

Ви можете знайти ще одне чудове пояснення цієї атаки в [**guyinatuxedo**](https://guyinatuxedo.github.io/32-largebin_attack/largebin_explanation0/index.html).

### Інші приклади

- [**La casa de papel. HackOn CTF 2024**](https://7rocky.github.io/en/ctf/other/hackon-ctf/la-casa-de-papel/)
- Атака на великий контейнер у тій же ситуації, як це з'являється в [**how2heap**](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/large_bin_attack.c).
- Примітив запису є більш складним, оскільки `global_max_fast` тут марний.
- FSOP потрібен для завершення експлуатації.

{{#include ../../banners/hacktricks-training.md}}
