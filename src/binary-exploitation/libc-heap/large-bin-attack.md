# Large Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

대형 빈에 대한 자세한 정보는 이 페이지를 확인하세요:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

[**how2heap - large bin attack**](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/large_bin_attack.c)에서 훌륭한 예제를 찾을 수 있습니다.

기본적으로 여기에서 glibc의 최신 "현재" 버전(2.35)에서 **`P->bk_nextsize`**가 확인되지 않아 특정 조건이 충족되면 대형 빈 청크의 값으로 임의의 주소를 수정할 수 있는 방법을 볼 수 있습니다.

그 예제에서 다음 조건을 찾을 수 있습니다:

- 대형 청크가 할당됨
- 첫 번째 청크보다 작지만 같은 인덱스에 있는 대형 청크가 할당됨
- 빈에서 먼저 가야 하므로 더 작아야 함
- (상단 청크와 병합을 방지하기 위한 청크가 생성됨)
- 그런 다음 첫 번째 대형 청크가 해제되고 그보다 큰 새 청크가 할당됨 -> Chunk1이 대형 빈으로 이동
- 그런 다음 두 번째 대형 청크가 해제됨
- 이제 취약점: 공격자는 `chunk1->bk_nextsize`를 `[target-0x20]`로 수정할 수 있음
- 그런 다음 청크 2보다 큰 청크가 할당되므로 청크 2가 대형 빈에 삽입되어 `chunk1->bk_nextsize->fd_nextsize`의 주소를 청크 2의 주소로 덮어씀

> [!TIP]
> 다른 잠재적인 시나리오가 있으며, 중요한 것은 대형 빈에 현재 빈의 X 청크보다 **작은** 청크를 추가하는 것입니다. 따라서 빈에서 X 바로 앞에 삽입되어야 하며, X의 **`bk_nextsize`**를 수정할 수 있어야 합니다. 그곳에 더 작은 청크의 주소가 기록될 것입니다.

이것은 malloc에서 관련된 코드입니다. 주소가 어떻게 덮어씌워졌는지 더 잘 이해할 수 있도록 주석이 추가되었습니다:
```c
/* if smaller than smallest, bypass loop below */
assert (chunk_main_arena (bck->bk));
if ((unsigned long) (size) < (unsigned long) chunksize_nomask (bck->bk))
{
fwd = bck; // fwd = p1
bck = bck->bk; // bck = p1->bk

victim->fd_nextsize = fwd->fd; // p2->fd_nextsize = p1->fd (Note that p1->fd is p1 as it's the only chunk)
victim->bk_nextsize = fwd->fd->bk_nextsize; // p2->bk_nextsize = p1->fd->bk_nextsize
fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim; // p1->fd->bk_nextsize->fd_nextsize = p2
}
```
이것은 **libc의 `global_max_fast` 전역 변수를 덮어쓰는 데 사용될 수 있으며**, 이후 더 큰 청크로 빠른 빈 공격을 악용할 수 있습니다.

이 공격에 대한 또 다른 훌륭한 설명은 [**guyinatuxedo**](https://guyinatuxedo.github.io/32-largebin_attack/largebin_explanation0/index.html)에서 찾을 수 있습니다.

### 다른 예시

- [**La casa de papel. HackOn CTF 2024**](https://7rocky.github.io/en/ctf/other/hackon-ctf/la-casa-de-papel/)
- [**how2heap**](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/large_bin_attack.c)에서 나타나는 것과 같은 상황에서의 대형 빈 공격.
- 쓰기 원시 작업은 더 복잡합니다. 왜냐하면 `global_max_fast`는 여기서 쓸모가 없기 때문입니다.
- 익스플로잇을 완료하려면 FSOP가 필요합니다.

{{#include ../../banners/hacktricks-training.md}}
