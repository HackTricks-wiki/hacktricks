# Groot Bin Aanval

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

Vir meer inligting oor wat 'n groot bin is, kyk na hierdie bladsy:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Dit is moontlik om 'n uitstekende voorbeeld te vind in [**how2heap - groot bin aanval**](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/large_bin_attack.c).

Basies kan jy hier sien hoe, in die nuutste "huidige" weergawe van glibc (2.35), dit nie nagegaan word nie: **`P->bk_nextsize`** wat dit moontlik maak om 'n arbitrêre adres te verander met die waarde van 'n groot bin stuk as sekere voorwaardes nagekom word.

In daardie voorbeeld kan jy die volgende voorwaardes vind:

- 'n Groot stuk word toegeken
- 'n Groot stuk kleiner as die eerste een, maar in dieselfde indeks, word toegeken
- Dit moet kleiner wees sodat dit eerste in die bin moet gaan
- (Een stuk om te voorkom dat dit met die boonste stuk saamgevoeg word, word geskep)
- Dan word die eerste groot stuk vrygestel en 'n nuwe stuk groter as dit word toegeken -> Stuk1 gaan na die groot bin
- Dan word die tweede groot stuk vrygestel
- Nou, die kwesbaarheid: Die aanvaller kan `chunk1->bk_nextsize` verander na `[target-0x20]`
- Dan word 'n groter stuk as stuk 2 toegeken, sodat stuk2 in die groot bin ingevoeg word wat die adres `chunk1->bk_nextsize->fd_nextsize` met die adres van stuk2 oorskryf

> [!TIP]
> Daar is ander potensiële scenario's, die ding is om 'n stuk wat **kleiner** is as 'n huidige X stuk in die bin by die groot bin te voeg, sodat dit net voor dit in die bin ingevoeg moet word, en ons moet in staat wees om X se **`bk_nextsize`** te verander, aangesien dit is waar die adres van die kleiner stuk geskryf sal word.

Dit is die relevante kode van malloc. Kommentaar is bygevoeg om beter te verstaan hoe die adres oorgeskryf is:
```c
/* if smaller than smallest, bypass loop below */
assert (chunk_main_arena (bck->bk));
if ((unsigned long) (size) < (unsigned long) chunksize_nomask (bck->bk))
{
fwd = bck; // fwd = p1
bck = bck->bk; // bck = p1->bk

victim->fd_nextsize = fwd->fd; // p2->fd_nextsize = p1->fd (Note that p1->fd is p1 as it's the only chunk)
victim->bk_nextsize = fwd->fd->bk_nextsize; // p2->bk_nextsize = p1->fd->bk_nextsize
fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim; // p1->fd->bk_nextsize->fd_nextsize = p2
}
```
Dit kan gebruik word om die **`global_max_fast` globale veranderlike** van libc te oorskry om dan 'n vinnige bin-aanval met groter stukke te ontgin.

Jy kan 'n ander uitstekende verduideliking van hierdie aanval vind in [**guyinatuxedo**](https://guyinatuxedo.github.io/32-largebin_attack/largebin_explanation0/index.html).

### Ander voorbeelde

- [**La casa de papel. HackOn CTF 2024**](https://7rocky.github.io/en/ctf/other/hackon-ctf/la-casa-de-papel/)
- Groot bin-aanval in dieselfde situasie soos dit verskyn in [**how2heap**](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/large_bin_attack.c).
- Die skryf primitief is meer kompleks, omdat `global_max_fast` hier nutteloos is.
- FSOP is nodig om die ontginning te voltooi.

{{#include ../../banners/hacktricks-training.md}}
