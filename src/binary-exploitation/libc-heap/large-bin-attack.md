# Large Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

Büyük bin nedir hakkında daha fazla bilgi için bu sayfayı kontrol edin:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

[**how2heap - large bin attack**](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/large_bin_attack.c) içinde harika bir örnek bulmak mümkündür.

Temelde burada, glibc'nin en son "güncel" sürümünde (2.35) kontrol edilmediğini görebilirsiniz: **`P->bk_nextsize`**, belirli koşullar sağlandığında büyük bir bin parçasının değeri ile rastgele bir adresi değiştirmeye olanak tanır.

Bu örnekte aşağıdaki koşulları bulabilirsiniz:

- Büyük bir parça tahsis edilir
- İlkinden daha küçük ama aynı indekste bir büyük parça tahsis edilir
- Bin içinde ilk gitmesi gerektiği için daha küçük olmalıdır
- (Üst parçayla birleştirmeyi önlemek için bir parça oluşturulur)
- Ardından, ilk büyük parça serbest bırakılır ve ondan daha büyük yeni bir parça tahsis edilir -> Chunk1 büyük bin'e gider
- Sonra, ikinci büyük parça serbest bırakılır
- Şimdi, zafiyet: Saldırgan `chunk1->bk_nextsize`'ı `[target-0x20]` olarak değiştirebilir
- Ardından, chunk 2'den daha büyük bir parça tahsis edilir, böylece chunk2 büyük bin'e eklenir ve `chunk1->bk_nextsize->fd_nextsize` adresini chunk2'nin adresi ile üzerine yazar

> [!TIP]
> Diğer potansiyel senaryolar vardır, mesele büyük bin'e mevcut bir X parçasından **daha küçük** bir parça eklemektir, böylece bin içinde onun hemen öncesine yerleştirilmesi gerekir ve X'in **`bk_nextsize`**'ını değiştirebilmemiz gerekir çünkü daha küçük parçanın adresi buraya yazılacaktır.

Bu malloc'tan ilgili kod. Adresin nasıl üzerine yazıldığını daha iyi anlamak için yorumlar eklenmiştir:
```c
/* if smaller than smallest, bypass loop below */
assert (chunk_main_arena (bck->bk));
if ((unsigned long) (size) < (unsigned long) chunksize_nomask (bck->bk))
{
fwd = bck; // fwd = p1
bck = bck->bk; // bck = p1->bk

victim->fd_nextsize = fwd->fd; // p2->fd_nextsize = p1->fd (Note that p1->fd is p1 as it's the only chunk)
victim->bk_nextsize = fwd->fd->bk_nextsize; // p2->bk_nextsize = p1->fd->bk_nextsize
fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim; // p1->fd->bk_nextsize->fd_nextsize = p2
}
```
Bu, **libc'nin `global_max_fast` global değişkenini** geçersiz kılmak için kullanılabilir, böylece daha büyük parçalarla hızlı bin saldırısını istismar edebilirsiniz.

Bu saldırının başka bir harika açıklamasını [**guyinatuxedo**](https://guyinatuxedo.github.io/32-largebin_attack/largebin_explanation0/index.html) adresinde bulabilirsiniz.

### Diğer örnekler

- [**La casa de papel. HackOn CTF 2024**](https://7rocky.github.io/en/ctf/other/hackon-ctf/la-casa-de-papel/)
- [**how2heap**](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/large_bin_attack.c) adresinde göründüğü gibi aynı durumda büyük bin saldırısı.
- Yazma primi daha karmaşıktır, çünkü `global_max_fast` burada işe yaramaz.
- İstismarı tamamlamak için FSOP gereklidir.

{{#include ../../banners/hacktricks-training.md}}
