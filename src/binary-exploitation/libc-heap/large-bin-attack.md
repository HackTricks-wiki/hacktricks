# Large Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Para mais informações sobre o que é um large bin, consulte esta página:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

É possível encontrar um ótimo exemplo em [**how2heap - large bin attack**](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/large_bin_attack.c).

Basicamente, aqui você pode ver como, na versão "atual" mais recente do glibc (2.35), não é verificado: **`P->bk_nextsize`**, permitindo modificar um endereço arbitrário com o valor de um chunk de large bin se certas condições forem atendidas.

Nesse exemplo, você pode encontrar as seguintes condições:

- Um chunk grande é alocado
- Um chunk grande menor que o primeiro, mas no mesmo índice, é alocado
- Deve ser menor, então no bin deve ir primeiro
- (Um chunk para evitar a fusão com o chunk superior é criado)
- Em seguida, o primeiro chunk grande é liberado e um novo chunk maior que ele é alocado -> Chunk1 vai para o large bin
- Então, o segundo chunk grande é liberado
- Agora, a vulnerabilidade: O atacante pode modificar `chunk1->bk_nextsize` para `[target-0x20]`
- Em seguida, um chunk maior que o chunk 2 é alocado, então chunk2 é inserido no large bin sobrescrevendo o endereço `chunk1->bk_nextsize->fd_nextsize` com o endereço de chunk2

> [!TIP]
> Existem outros cenários potenciais, a questão é adicionar ao large bin um chunk que seja **menor** que um chunk X atual no bin, então ele precisa ser inserido logo antes dele no bin, e precisamos ser capazes de modificar **`bk_nextsize`** de X, pois é lá que o endereço do chunk menor será escrito.

Este é o código relevante do malloc. Comentários foram adicionados para entender melhor como o endereço foi sobrescrito:
```c
/* if smaller than smallest, bypass loop below */
assert (chunk_main_arena (bck->bk));
if ((unsigned long) (size) < (unsigned long) chunksize_nomask (bck->bk))
{
fwd = bck; // fwd = p1
bck = bck->bk; // bck = p1->bk

victim->fd_nextsize = fwd->fd; // p2->fd_nextsize = p1->fd (Note that p1->fd is p1 as it's the only chunk)
victim->bk_nextsize = fwd->fd->bk_nextsize; // p2->bk_nextsize = p1->fd->bk_nextsize
fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim; // p1->fd->bk_nextsize->fd_nextsize = p2
}
```
Isso pode ser usado para **sobrescrever a variável global `global_max_fast`** da libc para então explorar um ataque de fast bin com chunks maiores.

Você pode encontrar outra ótima explicação deste ataque em [**guyinatuxedo**](https://guyinatuxedo.github.io/32-largebin_attack/largebin_explanation0/index.html).

### Outros exemplos

- [**La casa de papel. HackOn CTF 2024**](https://7rocky.github.io/en/ctf/other/hackon-ctf/la-casa-de-papel/)
- Ataque de large bin na mesma situação em que aparece em [**how2heap**](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/large_bin_attack.c).
- O primitive de escrita é mais complexo, porque `global_max_fast` é inútil aqui.
- FSOP é necessário para finalizar a exploração.

{{#include ../../banners/hacktricks-training.md}}
