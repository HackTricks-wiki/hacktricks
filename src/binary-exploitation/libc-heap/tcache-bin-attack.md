# Tcache Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Tcache बिन क्या है, इसके बारे में अधिक जानकारी के लिए इस पृष्ठ को देखें:


{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

सबसे पहले, ध्यान दें कि Tcache को Glibc संस्करण 2.26 में पेश किया गया था।

**Tcache हमला** (जिसे **Tcache विषाक्तता** के रूप में भी जाना जाता है) जो [**guyinatuxido पृष्ठ**](https://guyinatuxedo.github.io/29-tcache/tcache_explanation/index.html) में प्रस्तावित किया गया है, तेज बिन हमले के समान है जहाँ लक्ष्य मुक्त किए गए टुकड़े के अंदर बिन में अगले टुकड़े के लिए पॉइंटर को एक मनमाने पते पर ओवरराइट करना है ताकि बाद में उस विशेष पते को **आवंटित किया जा सके और संभावित रूप से पॉइंटर्स को ओवरराइट किया जा सके**।

हालांकि, आजकल, यदि आप उल्लेखित कोड चलाते हैं तो आपको त्रुटि मिलेगी: **`malloc(): unaligned tcache chunk detected`**। इसलिए, नए पॉइंटर में एक संरेखित पता (या बाइनरी को पर्याप्त बार चलाना ताकि लिखा गया पता वास्तव में संरेखित हो) के रूप में लिखना आवश्यक है।

### Tcache indexes attack

आमतौर पर, यह संभव है कि हीप की शुरुआत में एक टुकड़ा हो जिसमें **tcache के अंदर प्रति इंडेक्स टुकड़ों की मात्रा** और **प्रत्येक tcache इंडेक्स के हेड टुकड़े का पता** हो। यदि किसी कारणवश इस जानकारी को संशोधित करना संभव है, तो यह संभव होगा कि **कुछ इंडेक्स के हेड टुकड़े को एक इच्छित पते पर इंगित किया जाए** (जैसे `__malloc_hook`) ताकि फिर एक इंडेक्स के आकार का टुकड़ा आवंटित किया जा सके और इस मामले में `__malloc_hook` की सामग्री को ओवरराइट किया जा सके।

## Examples

- CTF [https://guyinatuxedo.github.io/29-tcache/dcquals19_babyheap/index.html](https://guyinatuxedo.github.io/29-tcache/dcquals19_babyheap/index.html)
- **Libc info leak**: यह tcaches को भरना संभव है, एक टुकड़ा असंरचित सूची में जोड़ना, tcache को खाली करना और **केवल पहले 8B को ओवरराइट करते हुए असंरचित बिन से टुकड़ा फिर से आवंटित करना**। 
- **Tcache attack**: बाइनरी एक 1B हीप ओवरफ्लो के लिए संवेदनशील है। इसका दुरुपयोग **आवंटित टुकड़े के आकार के हेडर** को बदलने के लिए किया जाएगा जिससे यह बड़ा हो जाएगा। फिर, इस टुकड़े को **मुक्त** किया जाएगा, इसे नकली आकार के टुकड़ों के tcache में जोड़ दिया जाएगा। फिर, हम नकली आकार के साथ एक टुकड़ा आवंटित करेंगे, और पिछले टुकड़े को **वापस किया जाएगा यह जानते हुए कि यह टुकड़ा वास्तव में छोटा था** और यह हमें **मेमोरी में अगले टुकड़े को ओवरराइट करने का अवसर प्रदान करता है**।\
हम इसका दुरुपयोग **अगले टुकड़े के FD पॉइंटर को ओवरराइट करने के लिए** करेंगे ताकि यह **`malloc_hook`** की ओर इंगित करे, ताकि फिर 2 पॉइंटर्स आवंटित करना संभव हो: पहले वह वैध पॉइंटर जिसे हमने अभी संशोधित किया, और फिर दूसरा आवंटन **`malloc_hook`** में एक टुकड़ा लौटाएगा जिसे **one gadget** लिखने के लिए दुरुपयोग किया जा सकता है।
- CTF [https://guyinatuxedo.github.io/29-tcache/plaid19_cpp/index.html](https://guyinatuxedo.github.io/29-tcache/plaid19_cpp/index.html)
- **Libc info leak**: यहाँ एक उपयोग के बाद मुक्त और एक डबल फ्री है। इस लेख में लेखक ने एक छोटे बिन में रखे गए टुकड़े के पते को पढ़कर libc का पता लीक किया (जैसे इसे असंरचित बिन से लीक करना लेकिन छोटे से)।
- **Tcache attack**: एक Tcache **डबल फ्री** के माध्यम से किया जाता है। एक ही टुकड़ा दो बार मुक्त किया जाता है, इसलिए Tcache के अंदर टुकड़ा अपने आप की ओर इंगित करेगा। फिर, इसे आवंटित किया जाता है, इसका FD पॉइंटर **फ्री हुक** की ओर इंगित करने के लिए संशोधित किया जाता है और फिर इसे फिर से आवंटित किया जाता है ताकि सूची में अगला टुकड़ा फ्री हुक में हो। फिर, इसे भी आवंटित किया जाता है और यहाँ `system` का पता लिखना संभव है ताकि जब एक malloc जिसमें `"/bin/sh"` हो मुक्त किया जाता है, तो हमें एक शेल मिल जाए।
- CTF [https://guyinatuxedo.github.io/44-more_tcache/csaw19_popping_caps0/index.html](https://guyinatuxedo.github.io/44-more_tcache/csaw19_popping_caps0/index.html)
- यहाँ मुख्य कमजोरी यह है कि किसी भी पते को हीप में `free` करने की क्षमता है, इसके ऑफसेट को इंगित करके।
- **Tcache indexes attack**: यह संभव है कि एक ऐसे आकार का टुकड़ा आवंटित और मुक्त किया जाए जो जब tcache टुकड़े के अंदर संग्रहीत किया जाता है (tcache बिन की जानकारी वाला टुकड़ा) तो **0x100 का मान उत्पन्न करेगा**। इसका कारण यह है कि tcache प्रत्येक बिन में टुकड़ों की मात्रा को विभिन्न बाइट्स में संग्रहीत करता है, इसलिए एक विशेष इंडेक्स में एक टुकड़ा 0x100 का मान उत्पन्न करता है।
- फिर, यह मान ऐसा दिखता है जैसे 0x100 का आकार का एक टुकड़ा है। इसे `free` करके दुरुपयोग करने की अनुमति देता है। यह **उस पते को 0x100 के आकार के टुकड़ों के इंडेक्स में जोड़ देगा**।
- फिर, **0x100** के आकार का एक टुकड़ा **आवंटित** करते समय, पिछले पते को एक टुकड़े के रूप में लौटाया जाएगा, जिससे अन्य tcache इंडेक्स को ओवरराइट करना संभव हो जाएगा।\
उदाहरण के लिए, malloc हुक का पता उनमें से एक में डालना और उस इंडेक्स के आकार का एक टुकड़ा आवंटित करना calloc हुक में एक टुकड़ा प्राप्त करने की अनुमति देगा, जो एक **one gadget** लिखने के लिए एक शेल प्राप्त करने की अनुमति देता है।
- CTF [https://guyinatuxedo.github.io/44-more_tcache/csaw19_popping_caps1/index.html](https://guyinatuxedo.github.io/44-more_tcache/csaw19_popping_caps1/index.html)
- पहले की तरह ही कमजोरी है लेकिन एक अतिरिक्त प्रतिबंध के साथ।
- **Tcache indexes attack**: पिछले वाले के समान हमला लेकिन **tcache जानकारी वाला टुकड़ा मुक्त करके** कम चरणों का उपयोग करके ताकि इसका पता उसके आकार के tcache इंडेक्स में जोड़ा जा सके ताकि उस आकार को आवंटित करना संभव हो और tcache टुकड़े की जानकारी को एक टुकड़े के रूप में प्राप्त किया जा सके, जो एक इंडेक्स के पते के रूप में फ्री हुक को जोड़ने की अनुमति देता है, इसे आवंटित करें, और उस पर एक **one gadget** लिखें।
- [**Math Door. HTB Cyber Apocalypse CTF 2023**](https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/math-door/)
- `fd` पॉइंटर में एक संख्या जोड़ने के लिए **Write After Free**।
- इस चुनौती में बहुत सारे **heap feng-shui** की आवश्यकता है। लेख में दिखाया गया है कि **Tcache** फ्री-लिस्ट के हेड को नियंत्रित करना कितना सुविधाजनक है।
- `stdout` (FSOP) के माध्यम से **Glibc leak**।
- मनमाने लिखने की प्राइमिटिव प्राप्त करने के लिए **Tcache poisoning**।

{{#include ../../banners/hacktricks-training.md}}
