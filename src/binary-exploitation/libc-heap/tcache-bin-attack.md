# Tcache Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Tcache बिन क्या है, इसके बारे में अधिक जानकारी के लिए इस पृष्ठ को देखें:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

सबसे पहले, ध्यान दें कि Tcache को Glibc संस्करण 2.26 में पेश किया गया था।

**Tcache हमला** (जिसे **Tcache विषाक्तता** के रूप में भी जाना जाता है) जो [**guyinatuxido पृष्ठ**](https://guyinatuxedo.github.io/29-tcache/tcache_explanation/index.html) में प्रस्तावित किया गया है, तेज बिन हमले के समान है जहाँ लक्ष्य मुक्त किए गए खंड के अंदर बिन में अगले खंड के लिए पॉइंटर को एक मनमाने पते पर ओवरराइट करना है ताकि बाद में उस विशेष पते को **आवंटित किया जा सके और संभावित रूप से पॉइंटर्स को ओवरराइट किया जा सके**।

हालांकि, आजकल, यदि आप उल्लेखित कोड चलाते हैं तो आपको त्रुटि मिलेगी: **`malloc(): unaligned tcache chunk detected`**। इसलिए, नए पॉइंटर में पते के रूप में एक संरेखित पता लिखना आवश्यक है (या बाइनरी को पर्याप्त बार चलाना ताकि लिखा गया पता वास्तव में संरेखित हो)।

### Tcache indexes attack

आमतौर पर, यह संभव है कि हीप की शुरुआत में एक खंड हो जिसमें **tcache के अंदर प्रति इंडेक्स खंडों की मात्रा** और **प्रत्येक tcache इंडेक्स के हेड खंड का पता** हो। यदि किसी कारण से इस जानकारी को संशोधित करना संभव है, तो यह संभव होगा कि **कुछ इंडेक्स के हेड खंड को एक इच्छित पते पर इंगित किया जाए** (जैसे `__malloc_hook`) ताकि फिर एक इंडेक्स के आकार का खंड आवंटित किया जा सके और इस मामले में `__malloc_hook` की सामग्री को ओवरराइट किया जा सके।

## Examples

- CTF [https://guyinatuxedo.github.io/29-tcache/dcquals19_babyheap/index.html](https://guyinatuxedo.github.io/29-tcache/dcquals19_babyheap/index.html)
- **Libc info leak**: यह tcaches को भरने, असंरचित सूची में एक खंड जोड़ने, tcache को खाली करने और **केवल पहले 8B को ओवरराइट करके असंरचित बिन से खंड को फिर से आवंटित करने** के लिए संभव है, जिससे **chunk से libc का दूसरा पता बरकरार रहता है ताकि हम इसे पढ़ सकें**।
- **Tcache attack**: बाइनरी एक 1B हीप ओवरफ्लो के लिए संवेदनशील है। इसका दुरुपयोग **आवंटित खंड के आकार के हेडर** को बदलने के लिए किया जाएगा जिससे यह बड़ा हो जाएगा। फिर, इस खंड को **मुक्त** किया जाएगा, इसे नकली आकार के खंडों के tcache में जोड़ दिया जाएगा। फिर, हम नकली आकार के साथ एक खंड आवंटित करेंगे, और पिछले खंड को **वापस किया जाएगा यह जानते हुए कि यह खंड वास्तव में छोटा था** और यह हमें **मेमोरी में अगले खंड को ओवरराइट करने का अवसर प्रदान करता है**।\
हम इसका दुरुपयोग करेंगे **अगले खंड के FD पॉइंटर को ओवरराइट करने के लिए** ताकि यह **`malloc_hook`** की ओर इंगित करे, ताकि फिर 2 पॉइंटर्स आवंटित करना संभव हो: पहले वैध पॉइंटर जिसे हमने अभी संशोधित किया, और फिर दूसरा आवंटन **`malloc_hook`** में एक खंड लौटाएगा जिसे **one gadget** लिखने के लिए दुरुपयोग किया जा सकता है।
- CTF [https://guyinatuxedo.github.io/29-tcache/plaid19_cpp/index.html](https://guyinatuxedo.github.io/29-tcache/plaid19_cpp/index.html)
- **Libc info leak**: यहाँ एक उपयोग के बाद मुक्त और एक डबल फ्री है। इस लेख में लेखक ने एक छोटे बिन में रखे गए खंड के पते को पढ़कर libc का पता लीक किया (जैसे असंरचित बिन से लीक करना लेकिन छोटे से)।
- **Tcache attack**: एक Tcache **डबल फ्री** के माध्यम से किया जाता है। एक ही खंड को दो बार मुक्त किया जाता है, इसलिए Tcache के अंदर खंड स्वयं की ओर इंगित करेगा। फिर, इसे आवंटित किया जाता है, इसका FD पॉइंटर **फ्री हुक** की ओर इंगित करने के लिए संशोधित किया जाता है और फिर इसे फिर से आवंटित किया जाता है ताकि सूची में अगला खंड फ्री हुक में हो। फिर, इसे भी आवंटित किया जाता है और यहाँ `system` का पता लिखना संभव है ताकि जब `"/bin/sh"` वाला malloc मुक्त किया जाए तो हमें एक शेल मिल सके।
- CTF [https://guyinatuxedo.github.io/44-more_tcache/csaw19_popping_caps0/index.html](https://guyinatuxedo.github.io/44-more_tcache/csaw19_popping_caps0/index.html)
- यहाँ मुख्य कमजोरी यह है कि आप हीप में किसी भी पते को उसके ऑफसेट को इंगित करके `free` कर सकते हैं।
- **Tcache indexes attack**: यह संभव है कि एक ऐसे आकार का खंड आवंटित और मुक्त किया जाए जो जब tcache खंड (tcache बिन की जानकारी वाला खंड) के अंदर संग्रहीत किया जाता है तो **0x100 का मान उत्पन्न करता है**। इसका कारण यह है कि tcache प्रत्येक बिन में खंडों की मात्रा को विभिन्न बाइट्स में संग्रहीत करता है, इसलिए एक विशिष्ट इंडेक्स में एक खंड 0x100 का मान उत्पन्न करता है।
- फिर, यह मान ऐसा दिखता है जैसे 0x100 का आकार का एक खंड है। इसे `free` करके दुरुपयोग करने की अनुमति देता है। यह **उस पते को tcache में 0x100 के आकार के खंडों के इंडेक्स में जोड़ देगा**।
- फिर, **0x100** के आकार का एक खंड **आवंटित** करते समय, पिछले पते को एक खंड के रूप में वापस किया जाएगा, जिससे अन्य tcache इंडेक्स को ओवरराइट करना संभव होगा।\
उदाहरण के लिए, malloc हुक का पता उनमें से एक में डालना और उस इंडेक्स के आकार का एक खंड आवंटित करना calloc हुक में एक खंड प्राप्त करने की अनुमति देगा, जो एक **one gadget** लिखने के लिए एक शेल प्राप्त करने की अनुमति देता है।
- CTF [https://guyinatuxedo.github.io/44-more_tcache/csaw19_popping_caps1/index.html](https://guyinatuxedo.github.io/44-more_tcache/csaw19_popping_caps1/index.html)
- पहले की तरह ही कमजोरी है लेकिन एक अतिरिक्त प्रतिबंध के साथ।
- **Tcache indexes attack**: पिछले वाले के समान हमला लेकिन **tcache जानकारी वाले खंड को मुक्त करके** कम चरणों का उपयोग करके ताकि इसका पता उसके आकार के tcache इंडेक्स में जोड़ा जा सके ताकि उस आकार को आवंटित करना संभव हो और tcache खंड की जानकारी को एक खंड के रूप में प्राप्त किया जा सके, जो एक इंडेक्स के पते के रूप में फ्री हुक को जोड़ने की अनुमति देता है, इसे आवंटित करें, और उस पर एक **one gadget** लिखें।
- [**Math Door. HTB Cyber Apocalypse CTF 2023**](https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/math-door/)
- **Write After Free** `fd` पॉइंटर में एक संख्या जोड़ने के लिए।
- इस चुनौती में बहुत सारे **heap feng-shui** की आवश्यकता है। लेख में दिखाया गया है कि **Tcache** फ्री-लिस्ट के हेड को नियंत्रित करना कितना उपयोगी है।
- `stdout` (FSOP) के माध्यम से **Glibc leak**।
- **Tcache poisoning** एक मनमाने लिखने की प्राइमिटिव प्राप्त करने के लिए।

{{#include ../../banners/hacktricks-training.md}}
