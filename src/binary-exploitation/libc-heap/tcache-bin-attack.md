# Tcache Bin Attack

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Для отримання додаткової інформації про те, що таке Tcache bin, перегляньте цю сторінку:

{{#ref}}
bins-and-memory-allocations.md
{{#endref}}

Перш за все, зверніть увагу, що Tcache був введений у версії Glibc 2.26.

**Tcache attack** (також відомий як **Tcache poisoning**), запропонований на [**сторінці guyinatuxido**](https://guyinatuxedo.github.io/29-tcache/tcache_explanation/index.html), дуже схожий на атаку швидкого бінга, де мета полягає в переписуванні вказівника на наступний шматок у біні всередині звільненого шматка на довільну адресу, щоб пізніше було можливим **виділити цю конкретну адресу і потенційно переписати вказівники**.

Однак, в даний час, якщо ви запустите згаданий код, ви отримаєте помилку: **`malloc(): unaligned tcache chunk detected`**. Тому потрібно записати в новий вказівник вирівняну адресу (або виконати бінарний файл достатню кількість разів, щоб записана адреса насправді була вирівняною).

### Tcache indexes attack

Зазвичай на початку купи можна знайти шматок, що містить **кількість шматків на індекс** всередині tcache та адресу **головного шматка кожного індексу tcache**. Якщо з якоїсь причини можливо змінити цю інформацію, буде можливим **зробити так, щоб головний шматок деякого індексу вказував на бажану адресу** (таку як `__malloc_hook`), щоб потім виділити шматок розміру індексу та переписати вміст `__malloc_hook` у цьому випадку.

## Examples

- CTF [https://guyinatuxedo.github.io/29-tcache/dcquals19_babyheap/index.html](https://guyinatuxedo.github.io/29-tcache/dcquals19_babyheap/index.html)
- **Libc info leak**: Можна заповнити tcache, додати шматок у неупорядкований список, очистити tcache і **знову виділити шматок з неупорядкованого біна**, переписуючи лише перші 8B, залишаючи **другу адресу до libc з шматка недоторканою, щоб ми могли її прочитати**.
- **Tcache attack**: Бінарний файл вразливий до переповнення купи на 1B. Це буде використано для зміни **заголовка розміру** виділеного шматка, роблячи його більшим. Потім цей шматок буде **звільнений**, додавши його до tcache шматків фальшивого розміру. Потім ми виділимо шматок з фальшивим розміром, і попередній шматок буде **повернуто, знаючи, що цей шматок насправді був меншим**, і це надає можливість **переписати наступний шматок у пам'яті**.\
Ми будемо зловживати цим, щоб **переписати вказівник FD наступного шматка**, щоб вказувати на **`malloc_hook`**, так що потім можливо виділити 2 вказівники: спочатку легітимний вказівник, який ми щойно змінили, а потім друге виділення поверне шматок у **`malloc_hook`**, який можна зловживати для запису **one gadget**.
- CTF [https://guyinatuxedo.github.io/29-tcache/plaid19_cpp/index.html](https://guyinatuxedo.github.io/29-tcache/plaid19_cpp/index.html)
- **Libc info leak**: Є використання після звільнення та подвійне звільнення. У цьому звіті автор злив адресу libc, читаючи адресу шматка, розміщеного в малому біні (як зливати її з неупорядкованого біна, але з малого).
- **Tcache attack**: Tcache виконується через **подвійне звільнення**. Один і той же шматок звільняється двічі, тому всередині Tcache шматок буде вказувати на себе. Потім він виділяється, його вказівник FD змінюється, щоб вказувати на **free hook**, а потім він знову виділяється, тому наступний шматок у списку буде в free hook. Потім це також виділяється, і можливо записати адресу `system` тут, тому, коли malloc, що містить `"/bin/sh"`, буде звільнено, ми отримаємо оболонку.
- CTF [https://guyinatuxedo.github.io/44-more_tcache/csaw19_popping_caps0/index.html](https://guyinatuxedo.github.io/44-more_tcache/csaw19_popping_caps0/index.html)
- Основна вразливість тут полягає в можливості `free` будь-якої адреси в купі, вказуючи її зсув.
- **Tcache indexes attack**: Можливо виділити та звільнити шматок розміру, який, коли зберігається всередині tcache chunk (шматок з інформацією про tcache bins), створить **адресу зі значенням 0x100**. Це тому, що tcache зберігає кількість шматків у кожному біні в різних байтах, отже, один шматок в одному конкретному індексі генерує значення 0x100.
- Тоді це значення виглядає так, ніби існує шматок розміру 0x100. Дозволяючи зловживати цим, звільняючи цю адресу. Це **додасть цю адресу до індексу шматків розміру 0x100 у tcache**.
- Потім, **виділяючи** шматок розміру **0x100**, попередня адреса буде повернута як шматок, що дозволяє переписати інші індекси tcache.\
Наприклад, помістивши адресу malloc hook в один з них і виділивши шматок розміру цього індексу, ми отримаємо шматок у calloc hook, що дозволяє записати one gadget для отримання оболонки.
- CTF [https://guyinatuxedo.github.io/44-more_tcache/csaw19_popping_caps1/index.html](https://guyinatuxedo.github.io/44-more_tcache/csaw19_popping_caps1/index.html)
- Та ж вразливість, що й раніше, з одним додатковим обмеженням.
- **Tcache indexes attack**: Схожа атака на попередню, але з меншим числом кроків, звільняючи шматок, що містить інформацію про tcache, так що його адреса додається до індексу tcache свого розміру, тому можливо виділити цей розмір і отримати інформацію про tcache chunk як шматок, що дозволяє додати free hook як адресу одного індексу, виділити його та записати one gadget на ньому.
- [**Math Door. HTB Cyber Apocalypse CTF 2023**](https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/math-door/)
- **Write After Free** для додавання числа до вказівника `fd`.
- Для цього виклику потрібно багато **heap feng-shui**. Звіт показує, як **контроль голови Tcache** списку вільних шматків є досить зручним.
- **Glibc leak** через `stdout` (FSOP).
- **Tcache poisoning** для отримання довільного запису.

{{#include ../../banners/hacktricks-training.md}}
