# House of Orange

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

### Kod

- Bir örneği [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_orange.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_orange.c) adresinde bulabilirsiniz.
- Sömürü tekniği bu [yamanın](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=stdlib/abort.c;h=117a507ff88d862445551f2c07abb6e45a716b75;hp=19882f3e3dc1ab830431506329c94dcf1d7cc252;hb=91e7cf982d0104f0e71770f5ae8e3faf352dea9f;hpb=0c25125780083cbba22ed627756548efe282d1a0) içinde düzeltildi, bu nedenle artık çalışmıyor (2.26'dan önce çalışıyordu).
- Daha fazla yorumla aynı örnek [https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html) adresinde.

### Hedef

- `malloc_printerr` fonksiyonunu kötüye kullanmak.

### Gereksinimler

- Üst parça boyutunu geçersiz kılmak.
- Libc ve heap sızıntıları.

### Arka Plan

[**Bu örnekten**](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)** bazı gerekli arka plan:**

Eski libc sürümlerinde, `malloc_printerr` fonksiyonu çağrıldığında, `_IO_list_all` içinde saklanan `_IO_FILE` yapılarına ait bir liste üzerinden **döngü yapar** ve aslında o yapıda bir talimat işaretçisini **çalıştırır**.\
Bu saldırı, **`_IO_list_all`** içine yazacağımız **sahte bir `_IO_FILE` yapısı** oluşturacaktır ve `malloc_printerr`'in çalışmasına neden olacaktır.\
Sonra, **`_IO_FILE`** yapılarına ait atlama tablosunda sakladığımız **herhangi bir adresi** çalıştıracaktır ve kod yürütmesi elde edeceğiz.

### Saldırı

Saldırı, **sıralanmamış kutu** içindeki **üst parçayı** elde etmeyi başarmakla başlar. Bu, `malloc`'ı mevcut üst parça boyutundan daha büyük ama **`mmp_.mmap_threshold`** (varsayılan 128K) değerinden daha küçük bir boyutla çağırarak elde edilir; aksi takdirde `mmap` tahsisi tetiklenir. Üst parça boyutu değiştirildiğinde, **üst parça + boyut**'un sayfa hizalı olduğundan ve üst parçanın **prev_inuse** bitinin her zaman ayarlandığından emin olmak önemlidir.

Sıralanmamış kutu içindeki üst parçayı elde etmek için, üst parçayı oluşturmak için bir parça tahsis edin, üst parça boyutunu (tahsis edilen parçada bir taşma ile) değiştirin, böylece **üst parça + boyut** sayfa hizalı ve **prev_inuse** bit ayarlanmış olsun. Ardından, yeni üst parça boyutundan daha büyük bir parça tahsis edin. `free`'in üst parçayı sıralanmamış kutuya almak için asla çağrılmadığını unutmayın.

Eski üst parça artık sıralanmamış kutuda. İçinde veri okuyabiliyorsak (muhtemelen taşmaya neden olan bir zafiyet nedeniyle), libc adreslerini sızdırmak ve **\_IO_list_all** adresini elde etmek mümkündür.

Sıralanmamış kutu saldırısı, taşmayı kötüye kullanarak `topChunk->bk->fwd = _IO_list_all - 0x10` yazılarak gerçekleştirilir. Yeni bir parça tahsis edildiğinde, eski üst parça bölünecek ve sıralanmamış kutuya bir işaretçi yazılacaktır.

Sonraki adım, eski üst parçanın boyutunu küçük bir kutuya sığacak şekilde küçültmektir; özellikle boyutunu **0x61** olarak ayarlamaktır. Bu iki amaca hizmet eder:

1. **Küçük Kutular 4'e Ekleme**: `malloc` sıralanmamış kutuyu taradığında ve bu parçayı gördüğünde, küçük boyutu nedeniyle onu küçük kutu 4'e eklemeye çalışacaktır. Bu, parçanın, **`_IO_list_all`** parçasının FD işaretçisinin bulunduğu küçük kutu 4 listesinin başına yerleşmesini sağlar; çünkü sıralanmamış kutu saldırısı aracılığıyla **`_IO_list_all`** içinde yakın bir adres yazdık.
2. **Malloc Kontrolünü Tetikleme**: Bu parça boyutu manipülasyonu, `malloc`'ın iç kontrolleri gerçekleştirmesine neden olacaktır. Yanlış ileri parça boyutunu kontrol ettiğinde, bu sıfır olacaktır ve bir hata tetikleyerek `malloc_printerr`'i çağırır.

Küçük kutunun manipülasyonu, parçanın ileri işaretçisini kontrol etmenizi sağlar. **\_IO_list_all** ile olan örtüşme, sahte bir **\_IO_FILE** yapısını oluşturmak için kullanılır. Yapı, libc'deki iç kontrolleri geçecek şekilde `_IO_write_base` ve `_IO_write_ptr` gibi anahtar alanları içerecek şekilde dikkatlice hazırlanır. Ayrıca, sahte yapının içinde, keyfi kodun (örneğin, `system` fonksiyonu) çalıştırılabileceği adrese ayarlanmış bir talimat işaretçisi bulunan bir atlama tablosu oluşturulur.

Tekniğin kalan kısmını özetlemek gerekirse:

- **Eski Üst Parçayı Küçültün**: Eski üst parçanın boyutunu **0x61** olarak ayarlayın, böylece küçük bir kutuya sığsın.
- **Sahte `_IO_FILE` Yapısını Kurun**: Eski üst parçayı sahte **\_IO_FILE** yapısıyla örtüştürün ve alanları uygun şekilde ayarlayarak yürütme akışını ele geçirin.

Sonraki adım, sıralanmamış kutuda bulunan eski üst parça ile örtüşen sahte bir **\_IO_FILE** yapısı oluşturmaktır. Bu yapının ilk baytları, çalıştırılacak bir komuta (örneğin, "/bin/sh") işaret eden bir işaretçi içerecek şekilde dikkatlice hazırlanır.

Sahte **\_IO_FILE** yapısındaki anahtar alanlar, libc'deki iç kontrolleri geçecek şekilde ayarlanır. Ayrıca, sahte yapının içinde, keyfi kodun çalıştırılabileceği adrese ayarlanmış bir talimat işaretçisi bulunan bir atlama tablosu oluşturulur. Genellikle bu, `system` fonksiyonunun adresi veya shell komutlarını çalıştırabilen başka bir fonksiyonun adresi olacaktır.

Saldırı, `malloc` çağrısının manipüle edilmiş **\_IO_FILE** yapısı aracılığıyla kodun çalıştırılmasını tetiklemesiyle sonuçlanır. Bu, genellikle bir shell'in başlatılması veya başka bir kötü niyetli yükün çalıştırılmasıyla sonuçlanan keyfi kod yürütmesine olanak tanır.

**Saldırının Özeti:**

1. **Üst parçayı ayarlayın**: Bir parça tahsis edin ve üst parça boyutunu değiştirin.
2. **Üst parçayı sıralanmamış kutuya zorlayın**: Daha büyük bir parça tahsis edin.
3. **Libc adreslerini sızdırın**: Zafiyeti kullanarak sıralanmamış kutudan okuyun.
4. **Sıralanmamış kutu saldırısını gerçekleştirin**: Taşma kullanarak **\_IO_list_all**'a yazın.
5. **Eski üst parçayı küçültün**: Boyutunu küçük bir kutuya sığacak şekilde ayarlayın.
6. **Sahte \_IO_FILE yapısını kurun**: Kontrol akışını ele geçirmek için sahte bir dosya yapısı oluşturun.
7. **Kod yürütmesini tetikleyin**: Saldırıyı gerçekleştirmek ve keyfi kodu çalıştırmak için bir parça tahsis edin.

Bu yaklaşım, kod yürütmesini elde etmek için heap yönetim mekanizmalarını, libc bilgi sızıntılarını ve heap taşmalarını sömürmektedir. Sahte **\_IO_FILE** yapısını dikkatlice oluşturarak ve doğru konuma yerleştirerek, saldırı standart bellek tahsis işlemleri sırasında kontrol akışını ele geçirebilir. Bu, keyfi kodun yürütülmesini sağlar ve potansiyel olarak bir shell veya diğer kötü niyetli faaliyetlerle sonuçlanabilir.

## Referanslar

- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_orange/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_orange/)
- [https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)

{{#include ../../banners/hacktricks-training.md}}
