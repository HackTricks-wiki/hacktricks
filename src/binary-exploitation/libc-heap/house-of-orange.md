# House of Orange

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

### Code

- Find an example in [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_orange.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_orange.c)
- The exploitation technique was fixed in this [patch](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=stdlib/abort.c;h=117a507ff88d862445551f2c07abb6e45a716b75;hp=19882f3e3dc1ab830431506329c94dcf1d7cc252;hb=91e7cf982d0104f0e71770f5ae8e3faf352dea9f;hpb=0c25125780083cbba22ed627756548efe282d1a0) so this is no longer working (working in earlier than 2.26)
- Same example **with more comments** in [https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)

### Goal

- Abuse `malloc_printerr` function

### Requirements

- Overwrite the top chunk size
- Libc and heap leaks

### Background

Some needed background from the comments from [**this example**](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)**:**

बात यह है कि, libc के पुराने संस्करणों में, जब `malloc_printerr` फ़ंक्शन को कॉल किया जाता था, तो यह **`_IO_list_all`** में संग्रहीत `_IO_FILE` संरचनाओं की एक सूची के माध्यम से **आवर्तन** करता था, और वास्तव में उस संरचना में एक निर्देशांक प्वाइंटर को **निष्पादित** करता था।\
यह हमला एक **नकली `_IO_FILE` संरचना** बनाएगा जिसे हम **`_IO_list_all`** में लिखेंगे, और `malloc_printerr` को चलाने का कारण बनेगा।\
फिर यह **कोई भी पता** निष्पादित करेगा जो हमने **`_IO_FILE`** संरचनाओं की जंप तालिका में संग्रहीत किया है, और हमें कोड निष्पादन मिलेगा।

### Attack

हमला **अनसॉर्टेड बिन** के अंदर **टॉप चंक** प्राप्त करने में सफल होने से शुरू होता है। यह `malloc` को एक आकार के साथ कॉल करके प्राप्त किया जाता है जो वर्तमान टॉप चंक आकार से बड़ा है लेकिन **`mmp_.mmap_threshold`** (डिफ़ॉल्ट 128K) से छोटा है, जो अन्यथा `mmap` आवंटन को ट्रिगर करेगा। जब भी टॉप चंक आकार को संशोधित किया जाता है, यह सुनिश्चित करना महत्वपूर्ण है कि **टॉप चंक + इसका आकार** पृष्ठ-संरेखित हो और कि टॉप चंक का **prev_inuse** बिट हमेशा सेट हो।

अनसॉर्टेड बिन के अंदर टॉप चंक प्राप्त करने के लिए, एक चंक आवंटित करें ताकि टॉप चंक बनाया जा सके, टॉप चंक आकार को बदलें (आवंटित चंक में ओवरफ्लो के साथ) ताकि **टॉप चंक + आकार** पृष्ठ-संरेखित हो और **prev_inuse** बिट सेट हो। फिर एक चंक आवंटित करें जो नए टॉप चंक आकार से बड़ा हो। ध्यान दें कि `free` को कभी भी अनसॉर्टेड बिन में टॉप चंक प्राप्त करने के लिए कॉल नहीं किया जाता है।

पुराना टॉप चंक अब अनसॉर्टेड बिन में है। मान लें कि हम इसके अंदर डेटा पढ़ सकते हैं (संभवतः एक भेद्यता के कारण जिसने ओवरफ्लो का कारण बना), तो इससे libc पते लीक करना और **\_IO_list_all** का पता प्राप्त करना संभव है।

एक अनसॉर्टेड बिन हमला ओवरफ्लो का दुरुपयोग करके किया जाता है ताकि `topChunk->bk->fwd = _IO_list_all - 0x10` लिखा जा सके। जब एक नया चंक आवंटित किया जाता है, तो पुराना टॉप चंक विभाजित हो जाएगा, और अनसॉर्टेड बिन के लिए एक प्वाइंटर **`_IO_list_all`** में लिखा जाएगा।

अगला कदम पुराने टॉप चंक के आकार को एक छोटे बिन में फिट करने के लिए कम करना है, विशेष रूप से इसके आकार को **0x61** पर सेट करना। इसका दो उद्देश्य हैं:

1. **छोटे बिन 4 में सम्मिलन**: जब `malloc` अनसॉर्टेड बिन के माध्यम से स्कैन करता है और इस चंक को देखता है, तो यह इसके छोटे आकार के कारण इसे छोटे बिन 4 में सम्मिलित करने की कोशिश करेगा। इससे चंक छोटे बिन 4 सूची के शीर्ष पर समाप्त हो जाएगा, जो **`_IO_list_all`** के चंक के FD प्वाइंटर का स्थान है क्योंकि हमने अनसॉर्टेड बिन हमले के माध्यम से **`_IO_list_all`** में एक निकट पता लिखा था।
2. **Malloc जांच को ट्रिगर करना**: इस चंक आकार के हेरफेर से `malloc` आंतरिक जांच करेगा। जब यह झूठे फॉरवर्ड चंक के आकार की जांच करता है, जो शून्य होगा, तो यह एक त्रुटि को ट्रिगर करता है और `malloc_printerr` को कॉल करता है।

छोटे बिन का हेरफेर आपको चंक के फॉरवर्ड प्वाइंटर को नियंत्रित करने की अनुमति देगा। **\_IO_list_all** के साथ ओवरलैप का उपयोग एक नकली **\_IO_FILE** संरचना को बनाने के लिए किया जाता है। संरचना को सावधानीपूर्वक तैयार किया गया है ताकि इसमें `_IO_write_base` और `_IO_write_ptr` जैसे प्रमुख फ़ील्ड शामिल हों, जिन्हें libc में आंतरिक जांच पास करने के लिए सेट किया गया है। इसके अतिरिक्त, नकली संरचना के भीतर एक जंप तालिका बनाई जाती है, जहां एक निर्देशांक प्वाइंटर को उस पते पर सेट किया जाता है जहां मनमाना कोड (जैसे, `system` फ़ंक्शन) निष्पादित किया जा सकता है।

तकनीक के शेष भाग का संक्षेप में वर्णन करें:

- **पुराने टॉप चंक को संकुचित करें**: छोटे बिन में फिट करने के लिए पुराने टॉप चंक के आकार को **0x61** पर समायोजित करें।
- **नकली `_IO_FILE` संरचना स्थापित करें**: पुराने टॉप चंक के साथ ओवरलैप करें और निष्पादन प्रवाह को हाईजैक करने के लिए फ़ील्ड को उपयुक्त रूप से सेट करें।

अगला कदम एक नकली **\_IO_FILE** संरचना को बनाना है जो वर्तमान में अनसॉर्टेड बिन में पुराने टॉप चंक के साथ ओवरलैप करती है। इस संरचना के पहले बाइट्स को सावधानीपूर्वक तैयार किया गया है ताकि एक कमांड (जैसे, "/bin/sh") के लिए एक प्वाइंटर शामिल किया जा सके जिसे निष्पादित किया जाएगा।

नकली **\_IO_FILE** संरचना में प्रमुख फ़ील्ड, जैसे `_IO_write_base` और `_IO_write_ptr`, को libc में आंतरिक जांच पास करने के लिए सेट किया गया है। इसके अतिरिक्त, नकली संरचना के भीतर एक जंप तालिका बनाई जाती है, जहां एक निर्देशांक प्वाइंटर को उस पते पर सेट किया जाता है जहां मनमाना कोड निष्पादित किया जा सकता है। आमतौर पर, यह `system` फ़ंक्शन का पता होगा या कोई अन्य फ़ंक्शन जो शेल कमांड निष्पादित कर सकता है।

हमला तब समाप्त होता है जब `malloc` को कॉल करने से हेरफेर की गई **\_IO_FILE** संरचना के माध्यम से कोड का निष्पादन होता है। यह प्रभावी रूप से मनमाने कोड निष्पादन की अनुमति देता है, जो आमतौर पर एक शेल के उत्पन्न होने या अन्य दुर्भावनापूर्ण पेलोड के निष्पादन का परिणाम होता है।

**हमले का सारांश:**

1. **टॉप चंक सेट करें**: एक चंक आवंटित करें और टॉप चंक आकार को संशोधित करें।
2. **टॉप चंक को अनसॉर्टेड बिन में मजबूर करें**: एक बड़ा चंक आवंटित करें।
3. **libc पते लीक करें**: अनसॉर्टेड बिन से पढ़ने के लिए भेद्यता का उपयोग करें।
4. **अनसॉर्टेड बिन हमला करें**: ओवरफ्लो का उपयोग करके **\_IO_list_all** में लिखें।
5. **पुराने टॉप चंक को संकुचित करें**: इसे छोटे बिन में फिट करने के लिए इसके आकार को समायोजित करें।
6. **नकली \_IO_FILE संरचना स्थापित करें**: नियंत्रण प्रवाह को हाईजैक करने के लिए एक नकली फ़ाइल संरचना बनाएं।
7. **कोड निष्पादन को ट्रिगर करें**: हमले को निष्पादित करने और मनमाने कोड को चलाने के लिए एक चंक आवंटित करें।

यह दृष्टिकोण हीप प्रबंधन तंत्र, libc जानकारी लीक, और हीप ओवरफ्लो का लाभ उठाता है ताकि `free` को सीधे कॉल किए बिना कोड निष्पादन प्राप्त किया जा सके। नकली **\_IO_FILE** संरचना को सावधानीपूर्वक तैयार करके और इसे सही स्थान पर रखकर, हमला मानक मेमोरी आवंटन संचालन के दौरान नियंत्रण प्रवाह को हाईजैक कर सकता है। यह मनमाने कोड के निष्पादन की अनुमति देता है, जो संभावित रूप से एक शेल या अन्य दुर्भावनापूर्ण गतिविधियों का परिणाम हो सकता है।

## References

- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_orange/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_orange/)
- [https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)

{{#include ../../banners/hacktricks-training.md}}
