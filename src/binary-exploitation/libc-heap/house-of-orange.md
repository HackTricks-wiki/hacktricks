# House of Orange

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

### Code

- Βρείτε ένα παράδειγμα στο [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_orange.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_orange.c)
- Η τεχνική εκμετάλλευσης διορθώθηκε σε αυτό το [patch](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=stdlib/abort.c;h=117a507ff88d862445551f2c07abb6e45a716b75;hp=19882f3e3dc1ab830431506329c94dcf1d7cc252;hb=91e7cf982d0104f0e71770f5ae8e3faf352dea9f;hpb=0c25125780083cbba22ed627756548efe282d1a0) οπότε αυτό δεν λειτουργεί πλέον (λειτουργεί σε εκδόσεις πριν από την 2.26)
- Το ίδιο παράδειγμα **με περισσότερα σχόλια** στο [https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)

### Goal

- Κατάχρηση της συνάρτησης `malloc_printerr`

### Requirements

- Επικαλύψτε το μέγεθος του κορυφαίου κομματιού
- Διαρροές libc και heap

### Background

Ορισμένα απαραίτητα υπόβαθρα από τα σχόλια από [**αυτό το παράδειγμα**](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)**:**

Το θέμα είναι ότι, σε παλαιότερες εκδόσεις της libc, όταν καλούνταν η συνάρτηση `malloc_printerr`, θα **επανεξετάσει μια λίστα από δομές `_IO_FILE` που αποθηκεύονται στο `_IO_list_all`**, και στην πραγματικότητα θα **εκτελέσει** έναν δείκτη εντολής σε αυτή τη δομή.\
Αυτή η επίθεση θα κατασκευάσει μια **ψεύτικη δομή `_IO_FILE`** που θα γράψουμε στο **`_IO_list_all`**, και θα προκαλέσει την εκτέλεση της `malloc_printerr`.\
Στη συνέχεια, θα **εκτελέσει οποιαδήποτε διεύθυνση** έχουμε αποθηκεύσει στον πίνακα άλματος των δομών **`_IO_FILE`**, και θα αποκτήσουμε εκτέλεση κώδικα.

### Attack

Η επίθεση ξεκινά με την επιτυχία να αποκτήσει το **κορυφαίο κομμάτι** μέσα στο **unsorted bin**. Αυτό επιτυγχάνεται καλώντας `malloc` με μέγεθος μεγαλύτερο από το τρέχον μέγεθος του κορυφαίου κομματιού αλλά μικρότερο από το **`mmp_.mmap_threshold`** (προεπιλογή είναι 128K), το οποίο διαφορετικά θα ενεργοποιούσε την κατανομή `mmap`. Όποτε το μέγεθος του κορυφαίου κομματιού τροποποιείται, είναι σημαντικό να διασφαλιστεί ότι το **κορυφαίο κομμάτι + το μέγεθός του** είναι ευθυγραμμισμένο με σελίδα και ότι το bit **prev_inuse** του κορυφαίου κομματιού είναι πάντα ρυθμισμένο.

Για να αποκτήσετε το κορυφαίο κομμάτι μέσα στο unsorted bin, εκχωρήστε ένα κομμάτι για να δημιουργήσετε το κορυφαίο κομμάτι, αλλάξτε το μέγεθος του κορυφαίου κομματιού (με μια υπερχείλιση στο εκχωρηθέν κομμάτι) έτσι ώστε το **κορυφαίο κομμάτι + μέγεθος** να είναι ευθυγραμμισμένο με σελίδα με το bit **prev_inuse** ρυθμισμένο. Στη συνέχεια, εκχωρήστε ένα κομμάτι μεγαλύτερο από το νέο μέγεθος του κορυφαίου κομματιού. Σημειώστε ότι η `free` δεν καλείται ποτέ για να αποκτήσει το κορυφαίο κομμάτι στο unsorted bin.

Το παλιό κορυφαίο κομμάτι είναι τώρα στο unsorted bin. Υποθέτοντας ότι μπορούμε να διαβάσουμε δεδομένα μέσα σε αυτό (πιθανώς λόγω μιας ευπάθειας που προκάλεσε επίσης την υπερχείλιση), είναι δυνατό να διαρρεύσουμε διευθύνσεις libc από αυτό και να αποκτήσουμε τη διεύθυνση του **\_IO_list_all**.

Μια επίθεση unsorted bin εκτελείται με την κατάχρηση της υπερχείλισης για να γράψει `topChunk->bk->fwd = _IO_list_all - 0x10`. Όταν εκχωρηθεί ένα νέο κομμάτι, το παλιό κορυφαίο κομμάτι θα χωριστεί, και ένας δείκτης στο unsorted bin θα γραφεί στο **`_IO_list_all`**.

Το επόμενο βήμα περιλαμβάνει τη μείωση του μεγέθους του παλιού κορυφαίου κομματιού για να χωρέσει σε ένα μικρό bin, ρυθμίζοντας συγκεκριμένα το μέγεθός του σε **0x61**. Αυτό εξυπηρετεί δύο σκοπούς:

1. **Εισαγωγή στο Small Bin 4**: Όταν η `malloc` σκανάρει το unsorted bin και δει αυτό το κομμάτι, θα προσπαθήσει να το εισαγάγει στο small bin 4 λόγω του μικρού του μεγέθους. Αυτό καθιστά το κομμάτι να καταλήξει στην κεφαλή της λίστας small bin 4, η οποία είναι η τοποθεσία του δείκτη FD του κομματιού του **`_IO_list_all`** καθώς γράψαμε μια κοντινή διεύθυνση στο **`_IO_list_all`** μέσω της επίθεσης unsorted bin.
2. **Προκαλώντας έναν Έλεγχο Malloc**: Αυτή η χειραγώγηση μεγέθους κομματιού θα προκαλέσει την `malloc` να εκτελέσει εσωτερικούς ελέγχους. Όταν ελέγχει το μέγεθος του ψευδούς κομματιού forward, το οποίο θα είναι μηδέν, προκαλεί ένα σφάλμα και καλεί την `malloc_printerr`.

Η χειραγώγηση του μικρού bin θα σας επιτρέψει να ελέγξετε τον δείκτη forward του κομματιού. Η επικάλυψη με **\_IO_list_all** χρησιμοποιείται για να κατασκευάσει μια ψεύτικη δομή **\_IO_FILE**. Η δομή είναι προσεκτικά κατασκευασμένη για να περιλαμβάνει βασικά πεδία όπως `_IO_write_base` και `_IO_write_ptr` ρυθμισμένα σε τιμές που περνούν τους εσωτερικούς ελέγχους στη libc. Επιπλέον, δημιουργείται ένας πίνακας άλματος μέσα στη ψεύτικη δομή, όπου ένας δείκτης εντολής ρυθμίζεται στη διεύθυνση όπου μπορεί να εκτελεστεί αυθαίρετος κώδικας (π.χ., η συνάρτηση `system`).

Για να συνοψίσουμε το υπόλοιπο της τεχνικής:

- **Μειώστε το Παλιό Κορυφαίο Κομμάτι**: Ρυθμίστε το μέγεθος του παλιού κορυφαίου κομματιού σε **0x61** για να χωρέσει σε ένα μικρό bin.
- **Ρυθμίστε τη Ψεύτικη Δομή `_IO_FILE`**: Επικαλύψτε το παλιό κορυφαίο κομμάτι με τη ψεύτικη δομή **\_IO_FILE** και ρυθμίστε τα πεδία κατάλληλα για να καταλάβετε τη ροή εκτέλεσης.

Το επόμενο βήμα περιλαμβάνει την κατασκευή μιας ψεύτικης δομής **\_IO_FILE** που επικαλύπτεται με το παλιό κορυφαίο κομμάτι που βρίσκεται αυτή τη στιγμή στο unsorted bin. Τα πρώτα bytes αυτής της δομής κατασκευάζονται προσεκτικά για να περιλαμβάνουν έναν δείκτη σε μια εντολή (π.χ., "/bin/sh") που θα εκτελείται.

Βασικά πεδία στη ψεύτικη δομή **\_IO_FILE**, όπως `_IO_write_base` και `_IO_write_ptr`, ρυθμίζονται σε τιμές που περνούν τους εσωτερικούς ελέγχους στη libc. Επιπλέον, δημιουργείται ένας πίνακας άλματος μέσα στη ψεύτικη δομή, όπου ένας δείκτης εντολής ρυθμίζεται στη διεύθυνση όπου μπορεί να εκτελεστεί αυθαίρετος κώδικας. Συνήθως, αυτή θα είναι η διεύθυνση της συνάρτησης `system` ή κάποια άλλη συνάρτηση που μπορεί να εκτελέσει εντολές shell.

Η επίθεση κορυφώνεται όταν μια κλήση στην `malloc` προκαλεί την εκτέλεση του κώδικα μέσω της χειραγωγημένης δομής **\_IO_FILE**. Αυτό επιτρέπει αποτελεσματικά την εκτέλεση αυθαίρετου κώδικα, συνήθως με αποτέλεσμα την εκκίνηση ενός shell ή την εκτέλεση άλλου κακόβουλου payload.

**Σύνοψη της Επίθεσης:**

1. **Ρυθμίστε το κορυφαίο κομμάτι**: Εκχωρήστε ένα κομμάτι και τροποποιήστε το μέγεθος του κορυφαίου κομματιού.
2. **Αναγκάστε το κορυφαίο κομμάτι στο unsorted bin**: Εκχωρήστε ένα μεγαλύτερο κομμάτι.
3. **Διαρρεύστε διευθύνσεις libc**: Χρησιμοποιήστε την ευπάθεια για να διαβάσετε από το unsorted bin.
4. **Εκτελέστε την επίθεση unsorted bin**: Γράψτε στο **\_IO_list_all** χρησιμοποιώντας μια υπερχείλιση.
5. **Μειώστε το παλιό κορυφαίο κομμάτι**: Ρυθμίστε το μέγεθός του για να χωρέσει σε ένα μικρό bin.
6. **Ρυθμίστε μια ψεύτικη δομή \_IO_FILE**: Κατασκευάστε μια ψεύτικη δομή αρχείου για να καταλάβετε τη ροή ελέγχου.
7. **Προκαλέστε εκτέλεση κώδικα**: Εκχωρήστε ένα κομμάτι για να εκτελέσετε την επίθεση και να τρέξετε αυθαίρετο κώδικα.

Αυτή η προσέγγιση εκμεταλλεύεται μηχανισμούς διαχείρισης heap, διαρροές πληροφοριών libc και υπερχείλιση heap για να επιτύχει εκτέλεση κώδικα χωρίς να καλεί άμεσα την `free`. Με την προσεκτική κατασκευή της ψεύτικης δομής **\_IO_FILE** και την τοποθέτησή της στη σωστή θέση, η επίθεση μπορεί να καταλάβει τη ροή ελέγχου κατά τη διάρκεια των τυπικών λειτουργιών κατανομής μνήμης. Αυτό επιτρέπει την εκτέλεση αυθαίρετου κώδικα, πιθανώς με αποτέλεσμα την εκκίνηση ενός shell ή άλλων κακόβουλων δραστηριοτήτων.

## References

- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_orange/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_orange/)
- [https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)

{{#include ../../banners/hacktricks-training.md}}
