# House of Orange

{{#include ../../banners/hacktricks-training.md}}

## Podstawowe informacje

### Kod

- Znajdź przykład w [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_orange.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_orange.c)
- Technika eksploatacji została naprawiona w tym [patchu](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=stdlib/abort.c;h=117a507ff88d862445551f2c07abb6e45a716b75;hp=19882f3e3dc1ab830431506329c94dcf1d7cc252;hb=91e7cf982d0104f0e71770f5ae8e3faf352dea9f;hpb=0c25125780083cbba22ed627756548efe282d1a0), więc to już nie działa (działa w wersjach wcześniejszych niż 2.26)
- Ten sam przykład **z większą ilością komentarzy** w [https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)

### Cel

- Wykorzystanie funkcji `malloc_printerr`

### Wymagania

- Nadpisanie rozmiaru górnego kawałka
- Wycieki libc i heap

### Tło

Nieco potrzebnego tła z komentarzy z [**tego przykładu**](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)**:**

Rzecz w tym, że w starszych wersjach libc, gdy wywoływana była funkcja `malloc_printerr`, **iterowała przez listę struktur `_IO_FILE` przechowywanych w `_IO_list_all`**, a faktycznie **wykonywała** wskaźnik instrukcji w tej strukturze.\
Ten atak sfałszuje **fałszywą strukturę `_IO_FILE`**, którą zapiszemy do **`_IO_list_all`**, i spowoduje uruchomienie `malloc_printerr`.\
Następnie **wykona dowolny adres**, który mamy zapisany w tabeli skoków struktur **`_IO_FILE`**, a my uzyskamy wykonanie kodu.

### Atak

Atak zaczyna się od uzyskania **górnego kawałka** wewnątrz **nieposortowanego binu**. Osiąga się to przez wywołanie `malloc` z rozmiarem większym niż aktualny rozmiar górnego kawałka, ale mniejszym niż **`mmp_.mmap_threshold`** (domyślnie 128K), co w przeciwnym razie spowodowałoby alokację `mmap`. Kiedy rozmiar górnego kawałka jest modyfikowany, ważne jest, aby upewnić się, że **górny kawałek + jego rozmiar** jest wyrównany do strony i że bit **prev_inuse** górnego kawałka jest zawsze ustawiony.

Aby uzyskać górny kawałek wewnątrz nieposortowanego binu, przydziel kawałek, aby utworzyć górny kawałek, zmień rozmiar górnego kawałka (z przepełnieniem w przydzielonym kawałku), aby **górny kawałek + rozmiar** był wyrównany do strony z ustawionym bitem **prev_inuse**. Następnie przydziel kawałek większy niż nowy rozmiar górnego kawałka. Zauważ, że `free` nigdy nie jest wywoływane, aby uzyskać górny kawałek do nieposortowanego binu.

Stary górny kawałek jest teraz w nieposortowanym binie. Zakładając, że możemy odczytać dane w nim (prawdopodobnie z powodu luki, która również spowodowała przepełnienie), możliwe jest wyciekanie adresów libc z niego i uzyskanie adresu **\_IO_list_all**.

Atak na nieposortowany bin jest przeprowadzany przez wykorzystanie przepełnienia do zapisania `topChunk->bk->fwd = _IO_list_all - 0x10`. Gdy nowy kawałek jest przydzielany, stary górny kawałek zostanie podzielony, a wskaźnik do nieposortowanego binu zostanie zapisany w **`_IO_list_all`**.

Kolejny krok polega na zmniejszeniu rozmiaru starego górnego kawałka, aby zmieścił się w małym binie, ustawiając jego rozmiar na **0x61**. Służy to dwóm celom:

1. **Wstawienie do Małego Binu 4**: Gdy `malloc` przeszukuje nieposortowany bin i widzi ten kawałek, spróbuje go wstawić do małego binu 4 z powodu jego małego rozmiaru. To sprawia, że kawałek trafia na początek listy małego binu 4, co jest lokalizacją wskaźnika FD kawałka **`_IO_list_all`**, ponieważ zapisaliśmy bliski adres w **`_IO_list_all`** za pomocą ataku na nieposortowany bin.
2. **Wywołanie Sprawdzenia Malloc**: Manipulacja rozmiarem tego kawałka spowoduje, że `malloc` przeprowadzi wewnętrzne kontrole. Gdy sprawdzi rozmiar fałszywego kawałka do przodu, który będzie zerowy, wywoła błąd i wywoła `malloc_printerr`.

Manipulacja małym binem pozwoli ci kontrolować wskaźnik do przodu kawałka. Nakładanie się na **\_IO_list_all** jest używane do sfałszowania fałszywej struktury **\_IO_FILE**. Struktura jest starannie skonstruowana, aby zawierała kluczowe pola, takie jak `_IO_write_base` i `_IO_write_ptr`, ustawione na wartości, które przechodzą wewnętrzne kontrole w libc. Dodatkowo, w fałszywej strukturze tworzona jest tabela skoków, w której wskaźnik instrukcji jest ustawiony na adres, w którym może być wykonany dowolny kod (np. funkcja `system`).

Aby podsumować pozostałą część techniki:

- **Zmniejsz Stary Górny Kawałek**: Dostosuj rozmiar starego górnego kawałka do **0x61**, aby zmieścił się w małym binie.
- **Ustaw Fałszywą Strukturę `_IO_FILE`**: Nakładaj stary górny kawałek na fałszywą strukturę **\_IO_FILE** i odpowiednio ustawiaj pola, aby przejąć kontrolę nad przepływem wykonania.

Kolejny krok polega na sfałszowaniu fałszywej struktury **\_IO_FILE**, która nakłada się na stary górny kawałek obecnie w nieposortowanym binie. Pierwsze bajty tej struktury są starannie skonstruowane, aby zawierały wskaźnik do polecenia (np. "/bin/sh"), które zostanie wykonane.

Kluczowe pola w fałszywej strukturze **\_IO_FILE**, takie jak `_IO_write_base` i `_IO_write_ptr`, są ustawione na wartości, które przechodzą wewnętrzne kontrole w libc. Dodatkowo, w fałszywej strukturze tworzona jest tabela skoków, w której wskaźnik instrukcji jest ustawiony na adres, w którym może być wykonany dowolny kod. Zazwyczaj byłby to adres funkcji `system` lub innej funkcji, która może wykonywać polecenia powłoki.

Atak kulminuje, gdy wywołanie `malloc` wyzwala wykonanie kodu przez manipulowaną strukturę **\_IO_FILE**. To skutecznie pozwala na wykonanie dowolnego kodu, co zazwyczaj skutkuje uruchomieniem powłoki lub innym złośliwym ładunkiem.

**Podsumowanie Ataku:**

1. **Ustaw górny kawałek**: Przydziel kawałek i zmodyfikuj rozmiar górnego kawałka.
2. **Wymuś górny kawałek do nieposortowanego binu**: Przydziel większy kawałek.
3. **Wycieki adresów libc**: Wykorzystaj lukę, aby odczytać z nieposortowanego binu.
4. **Wykonaj atak na nieposortowany bin**: Zapisz do **\_IO_list_all** za pomocą przepełnienia.
5. **Zmniejsz stary górny kawałek**: Dostosuj jego rozmiar, aby zmieścił się w małym binie.
6. **Ustaw fałszywą strukturę \_IO_FILE**: Sfałszuj fałszywą strukturę pliku, aby przejąć kontrolę nad przepływem.
7. **Wyzwól wykonanie kodu**: Przydziel kawałek, aby wykonać atak i uruchomić dowolny kod.

Podejście to wykorzystuje mechanizmy zarządzania pamięcią, wycieki informacji libc i przepełnienia heap, aby osiągnąć wykonanie kodu bez bezpośredniego wywoływania `free`. Poprzez staranne skonstruowanie fałszywej struktury **\_IO_FILE** i umieszczenie jej w odpowiedniej lokalizacji, atak może przejąć kontrolę nad przepływem podczas standardowych operacji alokacji pamięci. To umożliwia wykonanie dowolnego kodu, co potencjalnie skutkuje uruchomieniem powłoki lub innymi złośliwymi działaniami.

## Odniesienia

- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_orange/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_orange/)
- [https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)

{{#include ../../banners/hacktricks-training.md}}
