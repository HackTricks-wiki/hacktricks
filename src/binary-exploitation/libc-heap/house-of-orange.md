# House of Orange

{{#include ../../banners/hacktricks-training.md}}

## Informazioni di base

### Codice

- Trova un esempio in [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_orange.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_orange.c)
- La tecnica di sfruttamento è stata corretta in questa [patch](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=stdlib/abort.c;h=117a507ff88d862445551f2c07abb6e45a716b75;hp=19882f3e3dc1ab830431506329c94dcf1d7cc252;hb=91e7cf982d0104f0e71770f5ae8e3faf352dea9f;hpb=0c25125780083cbba22ed627756548efe282d1a0) quindi questo non funziona più (funzionante in versioni precedenti a 2.26)
- Stesso esempio **con più commenti** in [https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)

### Obiettivo

- Abusare della funzione `malloc_printerr`

### Requisiti

- Sovrascrivere la dimensione del top chunk
- Libc e heap leaks

### Contesto

Alcuni background necessari dai commenti di [**questo esempio**](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)**:**

Il fatto è che, nelle versioni più vecchie di libc, quando veniva chiamata la funzione `malloc_printerr`, essa **iterava attraverso un elenco di strutture `_IO_FILE` memorizzate in `_IO_list_all`**, ed effettivamente **eseguiva** un puntatore di istruzione in quella struttura.\
Questo attacco forgierà una **falsa struttura `_IO_FILE`** che scriveremo in **`_IO_list_all`**, e causerà l'esecuzione di `malloc_printerr`.\ 
Poi **eseguirà qualsiasi indirizzo** abbiamo memorizzato nella tabella dei salti delle strutture **`_IO_FILE`**, e otterremo l'esecuzione di codice.

### Attacco

L'attacco inizia riuscendo a ottenere il **top chunk** all'interno del **unsorted bin**. Questo si ottiene chiamando `malloc` con una dimensione maggiore della dimensione attuale del top chunk ma inferiore a **`mmp_.mmap_threshold`** (il valore predefinito è 128K), il che altrimenti attiverebbe l'allocazione `mmap`. Ogni volta che la dimensione del top chunk viene modificata, è importante assicurarsi che **top chunk + la sua dimensione** sia allineato alla pagina e che il bit **prev_inuse** del top chunk sia sempre impostato.

Per ottenere il top chunk all'interno dell'unsorted bin, allocare un chunk per creare il top chunk, cambiare la dimensione del top chunk (con un overflow nel chunk allocato) in modo che **top chunk + dimensione** sia allineato alla pagina con il bit **prev_inuse** impostato. Poi allocare un chunk più grande della nuova dimensione del top chunk. Nota che `free` non viene mai chiamato per portare il top chunk nell'unsorted bin.

Il vecchio top chunk è ora nell'unsorted bin. Supponendo di poter leggere i dati al suo interno (possibilmente a causa di una vulnerabilità che ha anche causato l'overflow), è possibile rivelare indirizzi libc da esso e ottenere l'indirizzo di **\_IO_list_all**.

Un attacco all'unsorted bin viene eseguito abusando dell'overflow per scrivere `topChunk->bk->fwd = _IO_list_all - 0x10`. Quando un nuovo chunk viene allocato, il vecchio top chunk verrà diviso e un puntatore all'unsorted bin verrà scritto in **`_IO_list_all`**.

Il passo successivo implica ridurre la dimensione del vecchio top chunk per adattarlo a un small bin, impostando specificamente la sua dimensione a **0x61**. Questo serve a due scopi:

1. **Inserimento nello Small Bin 4**: Quando `malloc` scansiona l'unsorted bin e vede questo chunk, cercherà di inserirlo nello small bin 4 a causa della sua piccola dimensione. Questo fa sì che il chunk si trovi all'inizio dell'elenco dello small bin 4, che è la posizione del puntatore FD del chunk di **`_IO_list_all`** poiché abbiamo scritto un indirizzo vicino in **`_IO_list_all`** tramite l'attacco all'unsorted bin.
2. **Attivazione di un Controllo di Malloc**: Questa manipolazione della dimensione del chunk causerà a `malloc` di eseguire controlli interni. Quando controlla la dimensione del falso chunk forward, che sarà zero, attiva un errore e chiama `malloc_printerr`.

La manipolazione dello small bin ti permetterà di controllare il puntatore forward del chunk. L'overlap con **\_IO_list_all** viene utilizzato per forgiare una falsa struttura **\_IO_FILE**. La struttura è accuratamente progettata per includere campi chiave come `_IO_write_base` e `_IO_write_ptr` impostati su valori che superano i controlli interni in libc. Inoltre, viene creata una tabella dei salti all'interno della falsa struttura, dove un puntatore di istruzione è impostato sull'indirizzo in cui può essere eseguito codice arbitrario (ad es., la funzione `system`).

Per riassumere la parte rimanente della tecnica:

- **Riduci il Vecchio Top Chunk**: Regola la dimensione del vecchio top chunk a **0x61** per adattarlo a un small bin.
- **Imposta la Falsa Struttura `_IO_FILE`**: Sovrapponi il vecchio top chunk con la falsa struttura **\_IO_FILE** e imposta i campi in modo appropriato per dirottare il flusso di esecuzione.

Il passo successivo implica forgiare una falsa struttura **\_IO_FILE** che si sovrappone al vecchio top chunk attualmente nell'unsorted bin. I primi byte di questa struttura sono progettati con attenzione per includere un puntatore a un comando (ad es., "/bin/sh") che verrà eseguito.

I campi chiave nella falsa struttura **\_IO_FILE**, come `_IO_write_base` e `_IO_write_ptr`, sono impostati su valori che superano i controlli interni in libc. Inoltre, viene creata una tabella dei salti all'interno della falsa struttura, dove un puntatore di istruzione è impostato sull'indirizzo in cui può essere eseguito codice arbitrario. Tipicamente, questo sarebbe l'indirizzo della funzione `system` o un'altra funzione che può eseguire comandi shell.

L'attacco culmina quando una chiamata a `malloc` attiva l'esecuzione del codice attraverso la manipolata struttura **\_IO_FILE**. Questo consente effettivamente l'esecuzione di codice arbitrario, risultando tipicamente in un shell che viene avviato o in un altro payload malevolo che viene eseguito.

**Riepilogo dell'Attacco:**

1. **Imposta il top chunk**: Allocare un chunk e modificare la dimensione del top chunk.
2. **Forza il top chunk nell'unsorted bin**: Allocare un chunk più grande.
3. **Rivela indirizzi libc**: Usa la vulnerabilità per leggere dall'unsorted bin.
4. **Esegui l'attacco all'unsorted bin**: Scrivi in **\_IO_list_all** usando un overflow.
5. **Riduci il vecchio top chunk**: Regola la sua dimensione per adattarlo a un small bin.
6. **Imposta una falsa struttura \_IO_FILE**: Forgiare una falsa struttura di file per dirottare il flusso di controllo.
7. **Attiva l'esecuzione del codice**: Allocare un chunk per eseguire l'attacco e far girare codice arbitrario.

Questo approccio sfrutta i meccanismi di gestione dell'heap, le perdite di informazioni libc e gli overflow dell'heap per ottenere l'esecuzione di codice senza chiamare direttamente `free`. Creando con attenzione la falsa struttura **\_IO_FILE** e posizionandola nel luogo giusto, l'attacco può dirottare il flusso di controllo durante le normali operazioni di allocazione della memoria. Questo consente l'esecuzione di codice arbitrario, potenzialmente risultando in una shell o altre attività malevole.

## Riferimenti

- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_orange/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_orange/)
- [https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)

{{#include ../../banners/hacktricks-training.md}}
