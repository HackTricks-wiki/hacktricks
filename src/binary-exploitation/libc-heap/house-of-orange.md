# House of Orange

{{#include ../../banners/hacktricks-training.md}}

## Grundinformationen

### Code

- Finden Sie ein Beispiel in [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_orange.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_orange.c)
- Die Exploitationstechnik wurde in diesem [Patch](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=stdlib/abort.c;h=117a507ff88d862445551f2c07abb6e45a716b75;hp=19882f3e3dc1ab830431506329c94dcf1d7cc252;hb=91e7cf982d0104f0e71770f5ae8e3faf352dea9f;hpb=0c25125780083cbba22ed627756548efe282d1a0) behoben, sodass dies nicht mehr funktioniert (funktioniert in Versionen vor 2.26)
- Dasselbe Beispiel **mit mehr Kommentaren** in [https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)

### Ziel

- Missbrauch der Funktion `malloc_printerr`

### Anforderungen

- Überschreiben der Größe des oberen Chunks
- Libc- und Heap-Leaks

### Hintergrund

Einige benötigte Hintergründe aus den Kommentaren zu [**diesem Beispiel**](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)**:**

Die Sache ist die, dass in älteren Versionen von libc, wenn die Funktion `malloc_printerr` aufgerufen wurde, sie **durch eine Liste von `_IO_FILE`-Strukturen, die in `_IO_list_all` gespeichert sind, iterierte** und tatsächlich einen Befehlszeiger in dieser Struktur **ausführte**.\
Dieser Angriff wird eine **falsche `_IO_FILE`-Struktur** fälschen, die wir in **`_IO_list_all`** schreiben werden, und `malloc_printerr` dazu bringen, ausgeführt zu werden.\
Dann wird es **jede Adresse ausführen**, die wir in der Sprungtabelle der **`_IO_FILE`**-Strukturen gespeichert haben, und wir werden Codeausführung erhalten.

### Angriff

Der Angriff beginnt damit, dass es gelingt, den **oberen Chunk** im **unsortierten Bin** zu erhalten. Dies wird erreicht, indem `malloc` mit einer Größe aufgerufen wird, die größer ist als die aktuelle Größe des oberen Chunks, aber kleiner als **`mmp_.mmap_threshold`** (Standard ist 128K), was andernfalls eine `mmap`-Zuweisung auslösen würde. Wann immer die Größe des oberen Chunks geändert wird, ist es wichtig sicherzustellen, dass der **obere Chunk + seine Größe** seitenaligned ist und dass das **prev_inuse**-Bit des oberen Chunks immer gesetzt ist.

Um den oberen Chunk im unsortierten Bin zu erhalten, wird ein Chunk zugewiesen, um den oberen Chunk zu erstellen, die Größe des oberen Chunks geändert (mit einem Überlauf im zugewiesenen Chunk), sodass **oberer Chunk + Größe** seitenaligned ist und das **prev_inuse**-Bit gesetzt ist. Dann wird ein Chunk größer als die neue Größe des oberen Chunks zugewiesen. Beachten Sie, dass `free` niemals aufgerufen wird, um den oberen Chunk in das unsortierte Bin zu bringen.

Der alte obere Chunk befindet sich jetzt im unsortierten Bin. Vorausgesetzt, wir können Daten darin lesen (möglicherweise aufgrund einer Schwachstelle, die auch den Überlauf verursacht hat), ist es möglich, libc-Adressen daraus zu leaken und die Adresse von **\_IO_list_all** zu erhalten.

Ein Angriff auf das unsortierte Bin wird durchgeführt, indem der Überlauf missbraucht wird, um `topChunk->bk->fwd = _IO_list_all - 0x10` zu schreiben. Wenn ein neuer Chunk zugewiesen wird, wird der alte obere Chunk aufgeteilt, und ein Zeiger auf das unsortierte Bin wird in **`_IO_list_all`** geschrieben.

Der nächste Schritt besteht darin, die Größe des alten oberen Chunks zu verkleinern, um in ein kleines Bin zu passen, indem seine Größe auf **0x61** gesetzt wird. Dies dient zwei Zwecken:

1. **Einfügen in Small Bin 4**: Wenn `malloc` das unsortierte Bin scannt und diesen Chunk sieht, wird es versuchen, ihn aufgrund seiner kleinen Größe in Small Bin 4 einzufügen. Dadurch landet der Chunk am Kopf der Small Bin 4-Liste, die der Standort des FD-Zeigers des Chunks von **`_IO_list_all`** ist, da wir eine nahe Adresse in **`_IO_list_all`** über den Angriff auf das unsortierte Bin geschrieben haben.
2. **Auslösen einer Malloc-Prüfung**: Diese Manipulation der Chunk-Größe wird dazu führen, dass `malloc` interne Prüfungen durchführt. Wenn es die Größe des falschen Vorwärtschunks überprüft, die null sein wird, löst es einen Fehler aus und ruft `malloc_printerr` auf.

Die Manipulation des kleinen Bins ermöglicht es Ihnen, den Vorwärtszeiger des Chunks zu steuern. Die Überlappung mit **\_IO_list_all** wird verwendet, um eine falsche **\_IO_FILE**-Struktur zu fälschen. Die Struktur wird sorgfältig erstellt, um wichtige Felder wie `_IO_write_base` und `_IO_write_ptr` zu enthalten, die auf Werte gesetzt sind, die interne Prüfungen in libc bestehen. Darüber hinaus wird innerhalb der gefälschten Struktur eine Sprungtabelle erstellt, in der ein Befehlszeiger auf die Adresse gesetzt wird, an der beliebiger Code (z. B. die Funktion `system`) ausgeführt werden kann.

Um den verbleibenden Teil der Technik zusammenzufassen:

- **Verkleinern des alten oberen Chunks**: Passen Sie die Größe des alten oberen Chunks auf **0x61** an, um ihn in ein kleines Bin zu bringen.
- **Einrichten der gefälschten `_IO_FILE`-Struktur**: Überlappen Sie den alten oberen Chunk mit der gefälschten **\_IO_FILE**-Struktur und setzen Sie die Felder entsprechend, um den Ausführungsfluss zu übernehmen.

Der nächste Schritt besteht darin, eine gefälschte **\_IO_FILE**-Struktur zu fälschen, die mit dem alten oberen Chunk überlappt, der sich derzeit im unsortierten Bin befindet. Die ersten Bytes dieser Struktur werden sorgfältig erstellt, um einen Zeiger auf einen Befehl (z. B. "/bin/sh") zu enthalten, der ausgeführt wird.

Wichtige Felder in der gefälschten **\_IO_FILE**-Struktur, wie `_IO_write_base` und `_IO_write_ptr`, werden auf Werte gesetzt, die interne Prüfungen in libc bestehen. Darüber hinaus wird innerhalb der gefälschten Struktur eine Sprungtabelle erstellt, in der ein Befehlszeiger auf die Adresse gesetzt wird, an der beliebiger Code ausgeführt werden kann. Typischerweise wäre dies die Adresse der Funktion `system` oder einer anderen Funktion, die Shell-Befehle ausführen kann.

Der Angriff kulminiert, wenn ein Aufruf an `malloc` die Ausführung des Codes durch die manipulierte **\_IO_FILE**-Struktur auslöst. Dies ermöglicht effektiv die Ausführung beliebigen Codes, was typischerweise dazu führt, dass eine Shell gestartet wird oder eine andere bösartige Nutzlast ausgeführt wird.

**Zusammenfassung des Angriffs:**

1. **Richten Sie den oberen Chunk ein**: Weisen Sie einen Chunk zu und ändern Sie die Größe des oberen Chunks.
2. **Zwingen Sie den oberen Chunk in das unsortierte Bin**: Weisen Sie einen größeren Chunk zu.
3. **Leaken Sie libc-Adressen**: Nutzen Sie die Schwachstelle, um aus dem unsortierten Bin zu lesen.
4. **Führen Sie den Angriff auf das unsortierte Bin durch**: Schreiben Sie in **\_IO_list_all** mit einem Überlauf.
5. **Verkleinern Sie den alten oberen Chunk**: Passen Sie seine Größe an, um in ein kleines Bin zu passen.
6. **Richten Sie eine gefälschte \_IO_FILE-Struktur ein**: Fälschen Sie eine gefälschte Dateistruktur, um den Kontrollfluss zu übernehmen.
7. **Triggern Sie die Codeausführung**: Weisen Sie einen Chunk zu, um den Angriff auszuführen und beliebigen Code auszuführen.

Dieser Ansatz nutzt Mechanismen des Heap-Managements, libc-Informationslecks und Heap-Überläufe aus, um die Codeausführung zu erreichen, ohne direkt `free` aufzurufen. Durch sorgfältiges Erstellen der gefälschten **\_IO_FILE**-Struktur und Platzieren an der richtigen Stelle kann der Angriff den Kontrollfluss während der Standard-Speicherzuweisungsoperationen übernehmen. Dies ermöglicht die Ausführung beliebigen Codes, was potenziell zu einer Shell oder anderen bösartigen Aktivitäten führen kann.

## Referenzen

- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_orange/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_orange/)
- [https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)

{{#include ../../banners/hacktricks-training.md}}
