# House of Orange

{{#include ../../banners/hacktricks-training.md}}

## Informações Básicas

### Código

- Encontre um exemplo em [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_orange.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_orange.c)
- A técnica de exploração foi corrigida neste [patch](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=stdlib/abort.c;h=117a507ff88d862445551f2c07abb6e45a716b75;hp=19882f3e3dc1ab830431506329c94dcf1d7cc252;hb=91e7cf982d0104f0e71770f5ae8e3faf352dea9f;hpb=0c25125780083cbba22ed627756548efe282d1a0) então isso não está mais funcionando (funcionando em versões anteriores a 2.26)
- Mesmo exemplo **com mais comentários** em [https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)

### Objetivo

- Abusar da função `malloc_printerr`

### Requisitos

- Sobrescrever o tamanho do chunk superior
- Vazamentos de libc e heap

### Contexto

Algumas informações de fundo necessárias dos comentários de [**este exemplo**](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)**:**

A questão é que, em versões mais antigas da libc, quando a função `malloc_printerr` era chamada, ela **iterava através de uma lista de structs `_IO_FILE` armazenadas em `_IO_list_all`**, e na verdade **executava** um ponteiro de instrução naquela struct.\
Este ataque irá forjar uma **struct `_IO_FILE` falsa** que escreveremos em **`_IO_list_all`**, e fará com que `malloc_printerr` seja executado.\
Então, ele **executará qualquer endereço** que tivermos armazenado na tabela de saltos das structs **`_IO_FILE`**, e teremos execução de código.

### Ataque

O ataque começa conseguindo obter o **chunk superior** dentro do **bin não ordenado**. Isso é alcançado chamando `malloc` com um tamanho maior que o tamanho atual do chunk superior, mas menor que **`mmp_.mmap_threshold`** (o padrão é 128K), que de outra forma acionaria a alocação `mmap`. Sempre que o tamanho do chunk superior é modificado, é importante garantir que o **chunk superior + seu tamanho** esteja alinhado à página e que o bit **prev_inuse** do chunk superior esteja sempre definido.

Para obter o chunk superior dentro do bin não ordenado, aloque um chunk para criar o chunk superior, mude o tamanho do chunk superior (com um estouro no chunk alocado) para que **chunk superior + tamanho** esteja alinhado à página com o bit **prev_inuse** definido. Em seguida, aloque um chunk maior que o novo tamanho do chunk superior. Note que `free` nunca é chamado para colocar o chunk superior no bin não ordenado.

O antigo chunk superior agora está no bin não ordenado. Supondo que possamos ler dados dentro dele (possivelmente devido a uma vulnerabilidade que também causou o estouro), é possível vazar endereços da libc a partir dele e obter o endereço de **\_IO_list_all**.

Um ataque ao bin não ordenado é realizado abusando do estouro para escrever `topChunk->bk->fwd = _IO_list_all - 0x10`. Quando um novo chunk é alocado, o antigo chunk superior será dividido, e um ponteiro para o bin não ordenado será escrito em **`_IO_list_all`**.

O próximo passo envolve reduzir o tamanho do antigo chunk superior para caber em um bin pequeno, especificamente definindo seu tamanho para **0x61**. Isso serve a dois propósitos:

1. **Inserção no Bin Pequeno 4**: Quando `malloc` escaneia o bin não ordenado e vê este chunk, ele tentará inseri-lo no bin pequeno 4 devido ao seu pequeno tamanho. Isso faz com que o chunk termine na cabeça da lista do bin pequeno 4, que é a localização do ponteiro FD do chunk de **`_IO_list_all`** já que escrevemos um endereço próximo em **`_IO_list_all`** através do ataque ao bin não ordenado.
2. **Acionando uma Verificação do Malloc**: Essa manipulação do tamanho do chunk fará com que `malloc` realize verificações internas. Quando ele verifica o tamanho do chunk falso para frente, que será zero, isso aciona um erro e chama `malloc_printerr`.

A manipulação do bin pequeno permitirá que você controle o ponteiro para frente do chunk. A sobreposição com **\_IO_list_all** é usada para forjar uma estrutura **\_IO_FILE** falsa. A estrutura é cuidadosamente elaborada para incluir campos-chave como `_IO_write_base` e `_IO_write_ptr` definidos para valores que passam nas verificações internas da libc. Além disso, uma tabela de saltos é criada dentro da estrutura falsa, onde um ponteiro de instrução é definido para o endereço onde o código arbitrário (por exemplo, a função `system`) pode ser executado.

Para resumir a parte restante da técnica:

- **Reduzir o Antigo Chunk Superior**: Ajustar o tamanho do antigo chunk superior para **0x61** para caber em um bin pequeno.
- **Configurar a Estrutura Falsa `_IO_FILE`**: Sobrepor o antigo chunk superior com a estrutura falsa **\_IO_FILE** e definir os campos adequadamente para sequestrar o fluxo de execução.

O próximo passo envolve forjar uma estrutura falsa **\_IO_FILE** que se sobrepõe ao antigo chunk superior atualmente no bin não ordenado. Os primeiros bytes dessa estrutura são elaborados cuidadosamente para incluir um ponteiro para um comando (por exemplo, "/bin/sh") que será executado.

Campos-chave na estrutura falsa **\_IO_FILE**, como `_IO_write_base` e `_IO_write_ptr`, são definidos para valores que passam nas verificações internas da libc. Além disso, uma tabela de saltos é criada dentro da estrutura falsa, onde um ponteiro de instrução é definido para o endereço onde o código arbitrário pode ser executado. Normalmente, este seria o endereço da função `system` ou outra função que pode executar comandos de shell.

O ataque culmina quando uma chamada para `malloc` aciona a execução do código através da estrutura manipulada **\_IO_FILE**. Isso efetivamente permite a execução de código arbitrário, resultando tipicamente em um shell sendo gerado ou outro payload malicioso sendo executado.

**Resumo do Ataque:**

1. **Configurar o chunk superior**: Alocar um chunk e modificar o tamanho do chunk superior.
2. **Forçar o chunk superior para o bin não ordenado**: Alocar um chunk maior.
3. **Vazar endereços da libc**: Usar a vulnerabilidade para ler do bin não ordenado.
4. **Realizar o ataque ao bin não ordenado**: Escrever em **\_IO_list_all** usando um estouro.
5. **Reduzir o antigo chunk superior**: Ajustar seu tamanho para caber em um bin pequeno.
6. **Configurar uma estrutura falsa \_IO_FILE**: Forjar uma estrutura de arquivo falsa para sequestrar o fluxo de controle.
7. **Acionar a execução de código**: Alocar um chunk para executar o ataque e rodar código arbitrário.

Essa abordagem explora mecanismos de gerenciamento de heap, vazamentos de informações da libc e estouros de heap para alcançar a execução de código sem chamar diretamente `free`. Ao elaborar cuidadosamente a estrutura falsa **\_IO_FILE** e colocá-la na localização correta, o ataque pode sequestrar o fluxo de controle durante operações padrão de alocação de memória. Isso permite a execução de código arbitrário, potencialmente resultando em um shell ou outras atividades maliciosas.

## Referências

- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_orange/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_orange/)
- [https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)

{{#include ../../banners/hacktricks-training.md}}
