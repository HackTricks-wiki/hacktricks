# House of Orange

{{#include ../../banners/hacktricks-training.md}}

## Osnovne informacije

### Kod

- Pronađite primer na [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_orange.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_orange.c)
- Tehnika eksploatacije je ispravljena u ovom [patchu](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=stdlib/abort.c;h=117a507ff88d862445551f2c07abb6e45a716b75;hp=19882f3e3dc1ab830431506329c94dcf1d7cc252;hb=91e7cf982d0104f0e71770f5ae8e3faf352dea9f;hpb=0c25125780083cbba22ed627756548efe282d1a0) tako da ovo više ne funkcioniše (radi u verzijama pre 2.26)
- Isti primer **sa više komentara** na [https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)

### Cilj

- Zloupotreba `malloc_printerr` funkcije

### Zahtevi

- Prepisivanje veličine gornjeg dela
- Libc i heap leakovi

### Pozadina

Neka potrebna pozadina iz komentara iz [**ovog primera**](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)**:**

Stvar je u tome da, u starijim verzijama libc, kada je pozvana `malloc_printerr` funkcija, ona bi **iterirala kroz listu `_IO_FILE` struktura smeštenih u `_IO_list_all`**, i zapravo **izvršila** pokazivač instrukcija u toj strukturi.\
Ovaj napad će falsifikovati **lažnu `_IO_FILE` strukturu** koju ćemo napisati u **`_IO_list_all`**, i izazvati `malloc_printerr` da se pokrene.\
Zatim će **izvršiti bilo koju adresu** koju imamo smeštenu u **`_IO_FILE`** tabeli skakanja, i dobićemo izvršenje koda.

### Napad

Napad počinje tako što se uspeva dobiti **gornji deo** unutar **nesortiranog bin-a**. To se postiže pozivanjem `malloc` sa veličinom većom od trenutne veličine gornjeg dela, ali manjom od **`mmp_.mmap_threshold`** (podrazumevano je 128K), što bi inače pokrenulo `mmap` alokaciju. Kada god se veličina gornjeg dela izmeni, važno je osigurati da je **gornji deo + njegova veličina** usklađena sa stranicom i da je **prev_inuse** bit gornjeg dela uvek postavljen.

Da biste dobili gornji deo unutar nesortiranog bin-a, alocirajte deo da biste stvorili gornji deo, promenite veličinu gornjeg dela (sa prelivanjem u alociranom delu) tako da **gornji deo + veličina** bude usklađen sa stranicom sa postavljenim **prev_inuse** bitom. Zatim alocirajte deo veći od nove veličine gornjeg dela. Imajte na umu da `free` nikada nije pozvan da bi se gornji deo stavio u nesortirani bin.

Stari gornji deo je sada u nesortiranom bin-u. Pretpostavljajući da možemo čitati podatke unutar njega (moguće zbog ranjivosti koja je takođe izazvala prelivanje), moguće je iscuriti libc adrese iz njega i dobiti adresu **\_IO_list_all**.

Napad nesortiranog bin-a se vrši zloupotrebom prelivanja da bi se napisalo `topChunk->bk->fwd = _IO_list_all - 0x10`. Kada se alocira novi deo, stari gornji deo će biti podeljen, a pokazivač na nesortirani bin će biti napisan u **`_IO_list_all`**.

Sledeći korak uključuje smanjenje veličine starog gornjeg dela da bi stao u mali bin, posebno postavljajući njegovu veličinu na **0x61**. Ovo ima dva cilja:

1. **Umetanje u Mali Bin 4**: Kada `malloc` skenira nesortirani bin i vidi ovaj deo, pokušaće da ga umetne u mali bin 4 zbog njegove male veličine. Ovo čini da deo završi na vrhu liste malog bin-a 4, što je lokacija FD pokazivača dela **`_IO_list_all`** jer smo napisali blisku adresu u **`_IO_list_all`** putem napada nesortiranog bin-a.
2. **Pokretanje Malloc Provere**: Ova manipulacija veličinom dela će izazvati `malloc` da izvrši interne provere. Kada proverava veličinu lažnog naprednog dela, koja će biti nula, izaziva grešku i poziva `malloc_printerr`.

Manipulacija malim bin-om će vam omogućiti da kontrolišete napredni pokazivač dela. Preklapanje sa **\_IO_list_all** se koristi za falsifikovanje lažne **\_IO_FILE** strukture. Struktura je pažljivo oblikovana da uključuje ključna polja kao što su `_IO_write_base` i `_IO_write_ptr` postavljena na vrednosti koje prolaze interne provere u libc. Pored toga, tabela skakanja se kreira unutar lažne strukture, gde je pokazivač instrukcija postavljen na adresu gde se može izvršiti proizvoljan kod (npr. funkcija `system`).

Da rezimiramo preostali deo tehnike:

- **Smanjite Stari Gornji Deo**: Prilagodite veličinu starog gornjeg dela na **0x61** da bi stao u mali bin.
- **Postavite Lažnu `_IO_FILE` Strukturu**: Preklopite stari gornji deo sa lažnom **\_IO_FILE** strukturom i postavite polja odgovarajuće da preuzmete tok izvršenja.

Sledeći korak uključuje falsifikovanje lažne **\_IO_FILE** strukture koja se preklapa sa starim gornjim delom trenutno u nesortiranom bin-u. Prvi bajtovi ove strukture su pažljivo oblikovani da uključuju pokazivač na komandu (npr. "/bin/sh") koja će biti izvršena.

Ključna polja u lažnoj **\_IO_FILE** strukturi, kao što su `_IO_write_base` i `_IO_write_ptr`, postavljena su na vrednosti koje prolaze interne provere u libc. Pored toga, tabela skakanja se kreira unutar lažne strukture, gde je pokazivač instrukcija postavljen na adresu gde se može izvršiti proizvoljan kod. Obično bi to bila adresa funkcije `system` ili druge funkcije koja može izvršiti shell komande.

Napad kulminira kada poziv na `malloc` pokrene izvršenje koda kroz manipuliranu **\_IO_FILE** strukturu. Ovo efikasno omogućava izvršenje proizvoljnog koda, obično rezultirajući pokretanjem shel-a ili izvršavanjem drugog zlonamernog tereta.

**Rezime Napada:**

1. **Postavite gornji deo**: Alocirajte deo i izmenite veličinu gornjeg dela.
2. **Primorajte gornji deo u nesortirani bin**: Alocirajte veći deo.
3. **Iscurite libc adrese**: Iskoristite ranjivost da čitate iz nesortiranog bin-a.
4. **Izvršite napad nesortiranog bin-a**: Napišite u **\_IO_list_all** koristeći prelivanje.
5. **Smanjite stari gornji deo**: Prilagodite njegovu veličinu da stane u mali bin.
6. **Postavite lažnu \_IO_FILE strukturu**: Falsifikujte lažnu strukturu datoteke da preuzmete tok izvršenja.
7. **Pokrenite izvršenje koda**: Alocirajte deo da izvršite napad i pokrenete proizvoljan kod.

Ovaj pristup koristi mehanizme upravljanja heap-om, iscurivanje informacija iz libc i prelivanja heap-a da bi se postiglo izvršenje koda bez direktnog pozivanja `free`. Pažljivim oblikovanjem lažne **\_IO_FILE** strukture i njenim postavljanjem na pravo mesto, napad može preuzeti tok izvršenja tokom standardnih operacija alokacije memorije. Ovo omogućava izvršenje proizvoljnog koda, potencijalno rezultirajući shell-om ili drugim zlonamernim aktivnostima.

## Reference

- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_orange/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_orange/)
- [https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)

{{#include ../../banners/hacktricks-training.md}}
