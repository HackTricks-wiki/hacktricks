# House of Orange

{{#include ../../banners/hacktricks-training.md}}

## Información Básica

### Código

- Encuentra un ejemplo en [https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_orange.c](https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_orange.c)
- La técnica de explotación fue corregida en este [patch](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=stdlib/abort.c;h=117a507ff88d862445551f2c07abb6e45a716b75;hp=19882f3e3dc1ab830431506329c94dcf1d7cc252;hb=91e7cf982d0104f0e71770f5ae8e3faf352dea9f;hpb=0c25125780083cbba22ed627756548efe282d1a0) así que esto ya no funciona (funcionando en versiones anteriores a 2.26)
- Mismo ejemplo **con más comentarios** en [https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)

### Objetivo

- Abusar de la función `malloc_printerr`

### Requisitos

- Sobrescribir el tamaño del chunk superior
- Fugas de libc y heap

### Antecedentes

Algunos antecedentes necesarios de los comentarios de [**este ejemplo**](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)**:**

La cuestión es que, en versiones anteriores de libc, cuando se llamaba a la función `malloc_printerr`, **iteraba a través de una lista de estructuras `_IO_FILE` almacenadas en `_IO_list_all`**, y realmente **ejecutaba** un puntero de instrucción en esa estructura.\
Este ataque forjará una **estructura `_IO_FILE` falsa** que escribiremos en **`_IO_list_all`**, y hará que `malloc_printerr` se ejecute.\
Luego **ejecutará cualquier dirección** que hayamos almacenado en la tabla de saltos de las estructuras **`_IO_FILE`**, y obtendremos ejecución de código.

### Ataque

El ataque comienza al lograr obtener el **chunk superior** dentro del **bin no ordenado**. Esto se logra llamando a `malloc` con un tamaño mayor que el tamaño actual del chunk superior pero menor que **`mmp_.mmap_threshold`** (el valor predeterminado es 128K), lo que de otro modo activaría la asignación `mmap`. Siempre que se modifique el tamaño del chunk superior, es importante asegurarse de que el **chunk superior + su tamaño** esté alineado a página y que el bit **prev_inuse** del chunk superior esté siempre establecido.

Para obtener el chunk superior dentro del bin no ordenado, asigna un chunk para crear el chunk superior, cambia el tamaño del chunk superior (con un desbordamiento en el chunk asignado) de modo que **chunk superior + tamaño** esté alineado a página con el bit **prev_inuse** establecido. Luego asigna un chunk más grande que el nuevo tamaño del chunk superior. Ten en cuenta que `free` nunca se llama para llevar el chunk superior al bin no ordenado.

El antiguo chunk superior ahora está en el bin no ordenado. Suponiendo que podemos leer datos dentro de él (posiblemente debido a una vulnerabilidad que también causó el desbordamiento), es posible filtrar direcciones de libc desde él y obtener la dirección de **\_IO_list_all**.

Se realiza un ataque de bin no ordenado abusando del desbordamiento para escribir `topChunk->bk->fwd = _IO_list_all - 0x10`. Cuando se asigna un nuevo chunk, el antiguo chunk superior se dividirá, y un puntero al bin no ordenado se escribirá en **`_IO_list_all`**.

El siguiente paso implica reducir el tamaño del antiguo chunk superior para que quepa en un bin pequeño, específicamente estableciendo su tamaño en **0x61**. Esto sirve para dos propósitos:

1. **Inserción en Small Bin 4**: Cuando `malloc` escanea el bin no ordenado y ve este chunk, intentará insertarlo en el bin pequeño 4 debido a su pequeño tamaño. Esto hace que el chunk termine en la cabeza de la lista del bin pequeño 4, que es la ubicación del puntero FD del chunk de **`_IO_list_all`** ya que escribimos una dirección cercana en **`_IO_list_all`** a través del ataque de bin no ordenado.
2. **Activar una Verificación de Malloc**: Esta manipulación del tamaño del chunk hará que `malloc` realice verificaciones internas. Cuando verifica el tamaño del chunk falso hacia adelante, que será cero, activa un error y llama a `malloc_printerr`.

La manipulación del bin pequeño te permitirá controlar el puntero hacia adelante del chunk. La superposición con **\_IO_list_all** se utiliza para forjar una estructura **\_IO_FILE** falsa. La estructura se elabora cuidadosamente para incluir campos clave como `_IO_write_base` y `_IO_write_ptr` establecidos en valores que pasan las verificaciones internas en libc. Además, se crea una tabla de saltos dentro de la estructura falsa, donde un puntero de instrucción se establece en la dirección donde se puede ejecutar código arbitrario (por ejemplo, la función `system`).

Para resumir la parte restante de la técnica:

- **Reducir el Antiguo Chunk Superior**: Ajustar el tamaño del antiguo chunk superior a **0x61** para que quepa en un bin pequeño.
- **Configurar la Estructura Falsa `_IO_FILE`**: Superponer el antiguo chunk superior con la estructura falsa **\_IO_FILE** y establecer los campos apropiadamente para secuestrar el flujo de ejecución.

El siguiente paso implica forjar una estructura falsa **\_IO_FILE** que se superponga con el antiguo chunk superior actualmente en el bin no ordenado. Los primeros bytes de esta estructura se elaboran cuidadosamente para incluir un puntero a un comando (por ejemplo, "/bin/sh") que se ejecutará.

Los campos clave en la estructura falsa **\_IO_FILE**, como `_IO_write_base` y `_IO_write_ptr`, se establecen en valores que pasan las verificaciones internas en libc. Además, se crea una tabla de saltos dentro de la estructura falsa, donde un puntero de instrucción se establece en la dirección donde se puede ejecutar código arbitrario. Típicamente, esta sería la dirección de la función `system` u otra función que pueda ejecutar comandos de shell.

El ataque culmina cuando una llamada a `malloc` activa la ejecución del código a través de la estructura manipulada **\_IO_FILE**. Esto permite efectivamente la ejecución de código arbitrario, lo que típicamente resulta en un shell que se genera o en otro payload malicioso que se ejecuta.

**Resumen del Ataque:**

1. **Configurar el chunk superior**: Asignar un chunk y modificar el tamaño del chunk superior.
2. **Forzar el chunk superior en el bin no ordenado**: Asignar un chunk más grande.
3. **Filtrar direcciones de libc**: Usar la vulnerabilidad para leer del bin no ordenado.
4. **Realizar el ataque de bin no ordenado**: Escribir en **\_IO_list_all** usando un desbordamiento.
5. **Reducir el antiguo chunk superior**: Ajustar su tamaño para que quepa en un bin pequeño.
6. **Configurar una estructura falsa \_IO_FILE**: Forjar una estructura de archivo falsa para secuestrar el flujo de control.
7. **Activar la ejecución de código**: Asignar un chunk para ejecutar el ataque y ejecutar código arbitrario.

Este enfoque explota mecanismos de gestión de heap, fugas de información de libc y desbordamientos de heap para lograr la ejecución de código sin llamar directamente a `free`. Al elaborar cuidadosamente la estructura falsa **\_IO_FILE** y colocarla en la ubicación correcta, el ataque puede secuestrar el flujo de control durante las operaciones estándar de asignación de memoria. Esto permite la ejecución de código arbitrario, lo que potencialmente resulta en un shell u otras actividades maliciosas.

## Referencias

- [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_orange/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house_of_orange/)
- [https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html](https://guyinatuxedo.github.io/43-house_of_orange/house_orange_exp/index.html)

{{#include ../../banners/hacktricks-training.md}}
