# Heap Overflow

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Heap overflow ni kama [**stack overflow**](../stack-overflow/index.html) lakini katika heap. Kimsingi inamaanisha kwamba nafasi fulani ilihifadhiwa katika heap kuhifadhi data fulani na **data iliyohifadhiwa ilikuwa kubwa kuliko nafasi iliyohifadhiwa.**

Katika stack overflows tunajua kwamba baadhi ya register kama vile pointer ya maagizo au stack frame zitarejeshwa kutoka kwenye stack na inaweza kuwa na uwezekano wa kutumia hii. Katika kesi ya heap overflows, **hakuna taarifa nyeti iliyohifadhiwa kwa kawaida** katika kipande cha heap ambacho kinaweza kujaa. Hata hivyo, inaweza kuwa taarifa nyeti au pointers, hivyo **umuhimu** wa udhaifu huu **unategemea** **ni data gani inaweza kuandikwa upya** na jinsi mshambuliaji anaweza kutumia hii.

> [!TIP]
> Ili kupata overflow offsets unaweza kutumia mifumo ile ile kama katika [**stack overflows**](../stack-overflow/index.html#finding-stack-overflows-offsets).

### Stack Overflows vs Heap Overflows

Katika stack overflows, mpangilio na data ambayo itakuwa katika stack wakati udhaifu unaweza kuamshwa ni wa kuaminika sana. Hii ni kwa sababu stack ni ya mstari, kila wakati ikiongezeka katika kumbukumbu inayopingana, katika **sehemu maalum za programu inayoendesha kumbukumbu ya stack kwa kawaida huhifadhi aina sawa ya data** na ina muundo maalum na pointers kadhaa mwishoni mwa sehemu ya stack inayotumiwa na kila kazi.

Hata hivyo, katika kesi ya heap overflow, kumbukumbu inayotumika si ya mstari bali **vipande vilivyotengwa kwa kawaida viko katika nafasi tofauti za kumbukumbu** (sio kando ya nyingine) kwa sababu ya **bins na maeneo** yanayotenganisha allocations kwa ukubwa na kwa sababu **kumbukumbu iliyotolewa awali inatumika** kabla ya kutenga vipande vipya. Ni **vigumu kujua kitu ambacho kitakuwa kinagongana na kile kilicho hatarini** kwa heap overflow. Hivyo, wakati heap overflow inapatikana, inahitajika kupata **njia ya kuaminika kufanya kitu kinachotakiwa kuwa karibu katika kumbukumbu** na kile kinachoweza kujaa.

Moja ya mbinu zinazotumika kwa hili ni **Heap Grooming** ambayo inatumika kwa mfano [**katika chapisho hili**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). Katika chapisho inaelezwa jinsi wakati katika kernel ya iOS wakati eneo linapokosa kumbukumbu ya kuhifadhi vipande vya kumbukumbu, linaipanua kwa ukurasa wa kernel, na ukurasa huu unagawanywa katika vipande vya ukubwa unaotarajiwa ambavyo vitatumika kwa mpangilio (hadi toleo la iOS 9.2, kisha vipande hivi vinatumika kwa njia ya nasibu ili kuleta ugumu katika unyakuzi wa mashambulizi haya).

Hivyo, katika chapisho kilichotangulia ambapo heap overflow inatokea, ili kulazimisha kipande kilichojazwa kuingia katika mpangilio wa mwathirika, **`kallocs` kadhaa zinapaswa kulazimishwa na nyuzi kadhaa ili kujaribu kuhakikisha kwamba vipande vyote vilivyotolewa vimejaa na kwamba ukurasa mpya umeundwa**.

Ili kulazimisha kujaza hili kwa vitu vya ukubwa maalum, **allocation ya nje ya mstari inayohusishwa na iOS mach port** ni mgombea bora. Kwa kubuni ukubwa wa ujumbe, inawezekana kubaini kwa usahihi ukubwa wa `kalloc` allocation na wakati mach port inayohusiana inaharibiwa, allocation inayohusiana itarejeshwa mara moja kwa `kfree`.

Kisha, baadhi ya hizi placeholders zinaweza **kuachiliwa**. **Orodha ya bure ya `kalloc.4096` inatoa vipengele kwa mpangilio wa mwisho-kuingia-wa-kwanza**, ambayo kimsingi inamaanisha kwamba ikiwa baadhi ya placeholders zitaachiliwa na unyakuzi unajaribu kutenga vitu kadhaa vya mwathirika wakati akijaribu kutenga kipande kilicho hatarini kujaa, kuna uwezekano kwamba kipande hiki kitafuatiwa na kipande cha mwathirika.

### Example libc

[**Katika ukurasa huu**](https://guyinatuxedo.github.io/27-edit_free_chunk/heap_consolidation_explanation/index.html) inawezekana kupata mfano wa msingi wa Heap overflow unaoonyesha jinsi ya kuandika upya prev in use bit ya kipande kinachofuata na nafasi ya prev size inawezekana **kuunganisha kipande kilichotumika** (kwa kulifanya kufikiri hakitumiki) na **kisha kukitenga tena** ikiwa na uwezo wa kuandika data inayotumiwa katika pointer tofauti pia.

Mfano mwingine kutoka [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap0/index.html) unaonyesha mfano wa msingi wa CTF ambapo **heap overflow** inaweza kutumika kuita kazi ya mshindi ili **kupata bendera**.

Katika mfano wa [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap1/index.html) inawezekana kuona jinsi ya kutumia overflow ya buffer inawezekana **kuandika upya katika kipande kilichokaribu anwani** ambapo **data isiyo na mpangilio kutoka kwa mtumiaji** itakuwa imeandikwa.

### Example ARM64

Katika ukurasa [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) unaweza kupata mfano wa heap overflow ambapo amri ambayo itatekelezwa inahifadhiwa katika kipande kinachofuata kutoka kwa kipande kilichojazwa. Hivyo, inawezekana kubadilisha amri inayotekelezwa kwa kuandika upya kwa unyakuzi rahisi kama:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Mifano Mingine

- [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
- Tunatumia udhaifu wa Integer Overflow kupata Heap Overflow.
- Tunaharibu viashiria vya kazi ndani ya `struct` ya kipande kilichozidi uwezo ili kuweka kazi kama `system` na kupata utekelezaji wa msimbo.

### Mfano wa Uhalisia: CVE-2025-40597 – Kutumia vibaya `__sprintf_chk`

Katika firmware ya SonicWall SMA100 10.2.1.15 moduli ya reverse-proxy `mod_httprp.so` inatenga kipande cha **0x80-byte** cha heap kisha inachanganya nyuzi kadhaa ndani yake kwa kutumia `__sprintf_chk`:
```c
char *buf = calloc(0x80, 1);
/* … */
__sprintf_chk(buf,               /* destination (0x80-byte chunk) */
-1,                /* <-- size argument   !!! */
0,                 /* flags */
"%s%s%s%s",      /* format */
"/", "https://", path, host);
```
`__sprintf_chk` ni sehemu ya **_FORTIFY_SOURCE**. Wakati inapata parameter ya **chaguo** `size` yenye **thamani chanya**, inathibitisha kwamba string inayotokana inafaa ndani ya buffer ya marudio. Kwa kupitisha **`-1` (0xFFFFFFFFFFFFFFFF)**, waendelezaji kwa ufanisi **walizima ukaguzi wa mipaka**, wakirudisha wito ulioimarishwa kuwa `sprintf` ya kawaida, isiyo salama.

Kutoa kichwa cha **`Host:`** chenye urefu kupita kiasi hivyo inaruhusu mshambuliaji **kuvuka kipande cha 0x80-byte na kuharibu metadata ya kipande kinachofuata cha heap** (tcache / fast-bin / small-bin kulingana na mtoaji). Crash inaweza kuzalishwa kwa:
```python
import requests, warnings
warnings.filterwarnings('ignore')
requests.get(
'https://TARGET/__api__/',
headers={'Host': 'A'*750},
verify=False
)
```
Practical exploitation would require **heap grooming** to place a controllable object right after the vulnerable chunk, but the root cause highlights two important takeaways:

1. **_FORTIFY_SOURCE si risasi ya fedha** – matumizi mabaya yanaweza kufuta ulinzi.
2. Daima pitisha **ukubwa sahihi wa buffer** kwa familia ya `_chk` (au, hata bora, tumia `snprintf`).

## References
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)

{{#include ../../banners/hacktricks-training.md}}
