# Heap Overflow

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Heap overflow एक [**stack overflow**](../stack-overflow/) की तरह है लेकिन heap में। मूल रूप से इसका मतलब है कि heap में कुछ डेटा स्टोर करने के लिए कुछ स्थान आरक्षित किया गया था और **स्टोर किया गया डेटा आरक्षित स्थान से बड़ा था।**

Stack overflows में हम जानते हैं कि कुछ रजिस्टर जैसे कि instruction pointer या stack frame को stack से पुनर्स्थापित किया जाएगा और इसे दुरुपयोग करना संभव हो सकता है। Heap overflows के मामले में, **डिफ़ॉल्ट रूप से heap chunk में कोई संवेदनशील जानकारी स्टोर नहीं की गई है** जिसे ओवरफ्लो किया जा सके। हालाँकि, यह संवेदनशील जानकारी या पॉइंटर्स हो सकती है, इसलिए इस भेद्यता की **गंभीरता** **इस पर निर्भर करती है कि** **कौन सा डेटा ओवरराइट किया जा सकता है** और एक हमलावर इसे कैसे दुरुपयोग कर सकता है।

> [!TIP]
> ओवरफ्लो ऑफसेट खोजने के लिए आप [**stack overflows**](../stack-overflow/index.html#finding-stack-overflows-offsets) में समान पैटर्न का उपयोग कर सकते हैं।

### Stack Overflows vs Heap Overflows

Stack overflows में उस समय stack में मौजूद डेटा और व्यवस्था जब भेद्यता को सक्रिय किया जा सकता है, काफी विश्वसनीय होती है। इसका कारण यह है कि stack रैखिक है, हमेशा टकराते हुए मेमोरी में बढ़ता है, **कार्यक्रम के चलने के विशिष्ट स्थानों पर stack मेमोरी आमतौर पर समान प्रकार के डेटा को स्टोर करती है** और इसमें प्रत्येक फ़ंक्शन द्वारा उपयोग किए जाने वाले stack भाग के अंत में कुछ पॉइंटर्स के साथ कुछ विशिष्ट संरचना होती है।

हालांकि, heap overflow के मामले में, उपयोग की गई मेमोरी रैखिक नहीं होती है बल्कि **आरक्षित चंक्स आमतौर पर मेमोरी के अलग-अलग स्थानों में होते हैं** (एक के बगल में नहीं) क्योंकि **bins और zones** आकार के अनुसार आवंटन को अलग करते हैं और क्योंकि **पिछली मुक्त मेमोरी का उपयोग किया जाता है** नए चंक्स को आवंटित करने से पहले। यह **जानना जटिल है कि कौन सा ऑब्जेक्ट उस ऑब्जेक्ट के साथ टकराने वाला है** जो heap overflow के लिए संवेदनशील है। इसलिए, जब एक heap overflow पाया जाता है, तो यह आवश्यक है कि **वांछित ऑब्जेक्ट को मेमोरी में अगले स्थान पर लाने का एक विश्वसनीय तरीका खोजा जाए** जो ओवरफ्लो किया जा सकता है।

इसका एक तकनीक **Heap Grooming** है जिसका उपयोग उदाहरण के लिए [**इस पोस्ट में**](https://azeria-labs.com/grooming-the-ios-kernel-heap/) किया गया है। पोस्ट में यह समझाया गया है कि जब iOS कर्नेल में एक ज़ोन में मेमोरी खत्म हो जाती है, तो यह इसे एक कर्नेल पृष्ठ द्वारा बढ़ाता है, और यह पृष्ठ अपेक्षित आकार के चंक्स में विभाजित होता है जो क्रम में उपयोग किए जाएंगे (iOS संस्करण 9.2 तक, फिर ये चंक्स इन हमलों के शोषण को कठिन बनाने के लिए यादृच्छिक तरीके से उपयोग किए जाते हैं)।

इसलिए, पिछले पोस्ट में जहां heap overflow हो रहा है, ओवरफ्लो किए गए ऑब्जेक्ट को एक पीड़ित क्रम के साथ टकराने के लिए मजबूर करने के लिए, कई **`kallocs` को कई थ्रेड्स द्वारा मजबूर किया जाता है ताकि यह सुनिश्चित किया जा सके कि सभी मुक्त चंक्स भरे हुए हैं और एक नया पृष्ठ बनाया गया है**।

विशिष्ट आकार के ऑब्जेक्ट के साथ इस भराई को मजबूर करने के लिए, **iOS mach port से संबंधित आउट-ऑफ-लाइन आवंटन** एक आदर्श उम्मीदवार है। संदेश के आकार को तैयार करके, `kalloc` आवंटन के आकार को सटीक रूप से निर्दिष्ट करना संभव है और जब संबंधित mach port नष्ट हो जाता है, तो संबंधित आवंटन तुरंत `kfree` पर वापस जारी किया जाएगा।

फिर, इनमें से कुछ प्लेसहोल्डर्स को **मुक्त** किया जा सकता है। **`kalloc.4096` मुक्त सूची तत्वों को अंतिम-में-प्रथम-निकालने के क्रम में जारी करती है**, जिसका मूल रूप से मतलब है कि यदि कुछ प्लेसहोल्डर्स को मुक्त किया जाता है और शोषण कई पीड़ित ऑब्जेक्ट्स को आवंटित करने की कोशिश करता है जबकि ओवरफ्लो के लिए संवेदनशील ऑब्जेक्ट को आवंटित करने की कोशिश करता है, तो यह संभावना है कि यह ऑब्जेक्ट एक पीड़ित ऑब्जेक्ट द्वारा अनुसरण किया जाएगा।

### Example libc

[**इस पृष्ठ में**](https://guyinatuxedo.github.io/27-edit_free_chunk/heap_consolidation_explanation/index.html) एक बुनियादी Heap overflow अनुकरण पाया जा सकता है जो दिखाता है कि अगले चंक के prev in use बिट और prev size की स्थिति को ओवरराइट करके **एक उपयोग किए गए चंक को समेकित करना** (इसे अप्रयुक्त समझाना) और **फिर से इसे आवंटित करना** संभव है जिससे यह डेटा ओवरराइट किया जा सके जो एक अलग पॉइंटर में भी उपयोग किया जा रहा है।

[**protostar heap 0**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap0/index.html) से एक और उदाहरण एक बहुत बुनियादी CTF का उदाहरण दिखाता है जहां एक **heap overflow** का दुरुपयोग करके विजेता फ़ंक्शन को **फ्लैग प्राप्त करने के लिए** कॉल किया जा सकता है।

[**protostar heap 1**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap1/index.html) उदाहरण में यह देखा जा सकता है कि एक बफर ओवरफ्लो का दुरुपयोग करके **एक निकट चंक में एक पता ओवरराइट करना** संभव है जहां **उपयोगकर्ता से मनमाना डेटा** लिखा जाएगा।

### Example ARM64

पृष्ठ [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) में आप एक heap overflow उदाहरण पा सकते हैं जहां एक कमांड जो निष्पादित होने वाली है, ओवरफ्लो किए गए चंक से अगले चंक में स्टोर की गई है। इसलिए, इसे एक आसान शोषण जैसे ओवरराइट करके निष्पादित कमांड को संशोधित करना संभव है:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### अन्य उदाहरण

- [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
- हम Heap Overflow प्राप्त करने के लिए एक Integer Overflow भेद्यता का उपयोग करते हैं।
- हम एक `struct` के अंदर एक फ़ंक्शन के लिए पॉइंटर्स को भ्रष्ट करते हैं जो ओवरफ्लो किए गए चंक में है ताकि `system` जैसे फ़ंक्शन को सेट किया जा सके और कोड निष्पादन प्राप्त किया जा सके।

{{#include ../../banners/hacktricks-training.md}}
