# Heap Overflow

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Heap overflow ni kama [**stack overflow**](../stack-overflow/index.html) lakini katika heap. Kimsingi inamaanisha kwamba nafasi fulani ilihifadhiwa katika heap kuhifadhi data fulani na **data iliyohifadhiwa ilikuwa kubwa kuliko nafasi iliyohifadhiwa.**

Katika stack overflows tunajua kwamba baadhi ya register kama vile pointer ya maagizo au stack frame zitarejeshwa kutoka kwenye stack na inaweza kuwa na uwezekano wa kutumia hii. Katika kesi ya heap overflows, **hakuna taarifa nyeti iliyohifadhiwa kwa chaguo katika chunk ya heap ambayo inaweza kujaa.** Hata hivyo, inaweza kuwa taarifa nyeti au pointers, hivyo **ukali** wa udhaifu huu **unategemea** **ni data gani inaweza kuandikwa upya** na jinsi mshambuliaji anaweza kutumia hii.

> [!TIP]
> Ili kupata overflow offsets unaweza kutumia mifumo sawa kama katika [**stack overflows**](../stack-overflow/index.html#finding-stack-overflows-offsets).

### Stack Overflows vs Heap Overflows

Katika stack overflows, mpangilio na data ambayo itakuwa katika stack wakati udhaifu unaweza kuchochewa ni wa kuaminika sana. Hii ni kwa sababu stack ni ya mstari, kila wakati ikiongezeka katika kumbukumbu inayopingana, katika **sehemu maalum za programu inayoendesha kumbukumbu ya stack kawaida huhifadhi aina sawa ya data** na ina muundo maalum na pointers kadhaa mwishoni mwa sehemu ya stack inayotumiwa na kila kazi.

Hata hivyo, katika kesi ya heap overflow, kumbukumbu inayotumika si ya mstari bali **chunks zilizotengwa kawaida ziko katika nafasi tofauti za kumbukumbu** (sio moja karibu na nyingine) kwa sababu ya **bins na maeneo** yanayogawanya allocations kwa ukubwa na kwa sababu **kumbukumbu iliyotolewa awali inatumika** kabla ya kutenga chunks mpya. Ni **ngumu kujua kitu ambacho kitakuwa kinagongana na kile kilicho hatarini** kwa heap overflow. Hivyo, wakati heap overflow inapatikana, inahitajika kupata **njia ya kuaminika kufanya kitu kinachotakiwa kuwa karibu katika kumbukumbu** na kile kinachoweza kujaa.

Moja ya mbinu zinazotumika kwa hili ni **Heap Grooming** ambayo inatumika kwa mfano [**katika chapisho hili**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). Katika chapisho inaelezwa jinsi wakati katika kernel ya iOS wakati eneo linapokosa kumbukumbu ya kuhifadhi chunks za kumbukumbu, linaipanua kwa ukurasa wa kernel, na ukurasa huu unagawanywa katika chunks za ukubwa unaotarajiwa ambazo zitatumika kwa mpangilio (hadi toleo la iOS 9.2, kisha chunks hizi zinatumika kwa njia ya nasibu ili kuleta ugumu katika unyakuzi wa mashambulizi haya).

Kwa hivyo, katika chapisho la awali ambapo heap overflow inatokea, ili kulazimisha kitu kilichojazwa kuungana na agizo la mwathirika, **`kallocs` kadhaa zinapaswa kulazimishwa na nyuzi kadhaa ili kujaribu kuhakikisha kwamba chunks zote za bure zimejaa na kwamba ukurasa mpya umeundwa**.

Ili kulazimisha kujaza hili kwa vitu vya ukubwa maalum, **allocation ya nje ya mstari inayohusishwa na iOS mach port** ni mgombea bora. Kwa kubuni ukubwa wa ujumbe, inawezekana kubaini kwa usahihi ukubwa wa `kalloc` allocation na wakati mach port inayohusiana inaharibiwa, allocation inayohusiana itarejeshwa mara moja kwa `kfree`.

Kisha, baadhi ya hizi placeholders zinaweza kuwa **zimeachiliwa**. **Orodha ya bure ya `kalloc.4096` inatoa vipengele kwa mpangilio wa mwisho-kuingia-wa-kwanza**, ambayo kimsingi inamaanisha kwamba ikiwa baadhi ya placeholders zimeachiliwa na unyakuzi unajaribu kutenga vitu kadhaa vya mwathirika wakati akijaribu kutenga kitu kilicho hatarini kujaa, kuna uwezekano kwamba kitu hiki kitafuatiwa na kitu cha mwathirika.

### Example libc

[**Katika ukurasa huu**](https://guyinatuxedo.github.io/27-edit_free_chunk/heap_consolidation_explanation/index.html) inawezekana kupata mfano wa msingi wa Heap overflow unaoonyesha jinsi ya kuandika upya prev in use bit ya chunk inayofuata na nafasi ya prev size inawezekana **kuunganisha chunk inayotumika** (kwa kumfanya aone kama haijatumika) na **kisha kuipatia tena** ikiwa na uwezo wa kuandika data inayotumika katika pointer tofauti pia.

Mfano mwingine kutoka [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap0/index.html) unaonyesha mfano wa msingi wa CTF ambapo **heap overflow** inaweza kutumika kuita kazi ya mshindi ili **kupata bendera**.

Katika mfano wa [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap1/index.html) inawezekana kuona jinsi ya kutumia overflow ya buffer inawezekana **kuandika upya katika chunk ya karibu anwani** ambapo **data ya kiholela kutoka kwa mtumiaji** itakuwa imeandikwa.

### Example ARM64

Katika ukurasa [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) unaweza kupata mfano wa heap overflow ambapo amri ambayo itatekelezwa inahifadhiwa katika chunk ifuatayo kutoka kwa chunk iliyojazwa. Hivyo, inawezekana kubadilisha amri inayotekelezwa kwa kuandika upya kwa unyakuzi rahisi kama:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Mifano Mingine

- [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
- Tunatumia udhaifu wa Integer Overflow kupata Heap Overflow.
- Tunaharibu viashiria vya kazi ndani ya `struct` ya kipande kilichozidi uwezo ili kuweka kazi kama `system` na kupata utekelezaji wa msimbo.

### Mfano wa Uhalisia: CVE-2025-40597 – Kutumia vibaya `__sprintf_chk`

Katika firmware ya SonicWall SMA100 10.2.1.15 moduli ya reverse-proxy `mod_httprp.so` inatenga kipande cha **0x80-byte** cha heap kisha inachanganya nyuzi kadhaa ndani yake kwa kutumia `__sprintf_chk`:
```c
char *buf = calloc(0x80, 1);
/* … */
__sprintf_chk(buf,               /* destination (0x80-byte chunk) */
-1,                /* <-- size argument   !!! */
0,                 /* flags */
"%s%s%s%s",      /* format */
"/", "https://", path, host);
```
`__sprintf_chk` ni sehemu ya **_FORTIFY_SOURCE**. Wakati inapata parameter ya **chaguo** `size` yenye **thamani chanya**, inathibitisha kwamba string inayotokana inafaa ndani ya buffer ya marudio. Kwa kupitisha **`-1` (0xFFFFFFFFFFFFFFFF)** waendelezaji kwa ufanisi **walizima ukaguzi wa mipaka**, wakirudisha wito ulioimarishwa kuwa `sprintf` ya kawaida, isiyo salama.

Kutoa kichwa cha **`Host:`** chenye urefu kupita kiasi hivyo inaruhusu mshambuliaji **kuvuka kipande cha 0x80-byte na kuharibu metadata ya kipande kinachofuata cha heap** (tcache / fast-bin / small-bin kulingana na mtoaji). Crash inaweza kuzalishwa kwa:
```python
import requests, warnings
warnings.filterwarnings('ignore')
requests.get(
'https://TARGET/__api__/',
headers={'Host': 'A'*750},
verify=False
)
```
Practical exploitation would require **heap grooming** to place a controllable object right after the vulnerable chunk, but the root cause highlights two important takeaways:

1. **_FORTIFY_SOURCE si risasi ya fedha** – matumizi mabaya yanaweza kufuta ulinzi.
2. Daima pitisha **ukubwa sahihi wa buffer** kwa familia ya `_chk` (au, hata bora, tumia `snprintf`).

## References
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)

{{#include ../../banners/hacktricks-training.md}}
