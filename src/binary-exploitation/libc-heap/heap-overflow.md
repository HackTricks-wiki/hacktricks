# Heap Overflow

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Heap overflow ni kama [**stack overflow**](../stack-overflow/index.html) lakini katika heap. Kimsingi inamaanisha kwamba nafasi fulani ilihifadhiwa katika heap kuhifadhi data fulani na **data iliyohifadhiwa ilikuwa kubwa kuliko nafasi iliyohifadhiwa.**

Katika stack overflows tunajua kwamba baadhi ya register kama vile pointer ya maagizo au stack frame zitarejeshwa kutoka kwenye stack na inaweza kuwa na uwezekano wa kutumia hii vibaya. Katika kesi ya heap overflows, **hakuna taarifa nyeti iliyohifadhiwa kwa chaguo-msingi** katika kipande cha heap ambacho kinaweza kujaa. Hata hivyo, inaweza kuwa taarifa nyeti au pointers, hivyo **umuhimu** wa udhaifu huu **unategemea** **ni data ipi inaweza kuandikwa upya** na jinsi mshambuliaji anaweza kutumia hii vibaya.

> [!TIP]
> Ili kupata overflow offsets unaweza kutumia mifumo sawa kama katika [**stack overflows**](../stack-overflow/index.html#finding-stack-overflows-offsets).

### Stack Overflows vs Heap Overflows

Katika stack overflows, kupanga na data ambayo itakuwa katika stack wakati udhaifu unaweza kuchochewa ni ya kuaminika sana. Hii ni kwa sababu stack ni ya mstari, kila wakati inakua katika kumbukumbu inayopingana, katika **sehemu maalum za programu inayoendesha kumbukumbu ya stack kawaida huhifadhi aina sawa ya data** na ina muundo maalum na pointers kadhaa mwishoni mwa sehemu ya stack inayotumiwa na kila kazi.

Hata hivyo, katika kesi ya heap overflow, kumbukumbu inayotumika si ya mstari bali **vipande vilivyotengwa kawaida viko katika nafasi tofauti za kumbukumbu** (sio kando ya nyingine) kwa sababu ya **bins na maeneo** yanayogawanya allocations kwa ukubwa na kwa sababu **kumbukumbu iliyotolewa awali inatumika** kabla ya kutenga vipande vipya. Ni **ngumu kujua kitu ambacho kitakuwa kinagongana na kile kilicho hatarini** kwa heap overflow. Hivyo, wakati heap overflow inapatikana, inahitajika kupata **njia ya kuaminika kufanya kitu kinachotakiwa kuwa karibu katika kumbukumbu** na kile kinachoweza kujaa.

Moja ya mbinu zinazotumika kwa hili ni **Heap Grooming** ambayo inatumika kwa mfano [**katika chapisho hili**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). Katika chapisho inaelezwa jinsi wakati katika kernel ya iOS wakati eneo linapokosa kumbukumbu ya kuhifadhi vipande vya kumbukumbu, linaipanua kwa ukurasa wa kernel, na ukurasa huu unagawanywa katika vipande vya ukubwa unaotarajiwa ambavyo vitatumika kwa mpangilio (hadi toleo la iOS 9.2, kisha vipande hivi vinatumika kwa njia ya nasibu ili kuleta ugumu katika unyakuzi wa mashambulizi haya).

Hivyo, katika chapisho la awali ambapo heap overflow inatokea, ili kulazimisha kipande kilichojazwa kuwa kinagongana na agizo la mwathirika, **`kallocs` kadhaa zinapaswa kulazimishwa na nyuzi kadhaa ili kujaribu kuhakikisha kwamba vipande vyote vilivyotolewa vimejaa na kwamba ukurasa mpya unaundwa**.

Ili kulazimisha kujaza hili kwa vitu vya ukubwa maalum, **allocation isiyo ya mstari inayohusishwa na iOS mach port** ni mgombea bora. Kwa kubuni ukubwa wa ujumbe, inawezekana kubaini kwa usahihi ukubwa wa `kalloc` allocation na wakati mach port inayohusiana inaharibiwa, allocation inayohusiana itarejeshwa mara moja kwa `kfree`.

Kisha, baadhi ya hizi placeholders zinaweza kuwa **zimeachiliwa**. **Orodha ya bure ya `kalloc.4096` inatoa vipengele kwa mpangilio wa mwisho-kuingia-wa-kwanza-kuondolewa**, ambayo kimsingi inamaanisha kwamba ikiwa baadhi ya placeholders zimeachiliwa na unyakuzi unajaribu kutenga vitu kadhaa vya mwathirika wakati akijaribu kutenga kipande kilicho hatarini kujaa, kuna uwezekano kwamba kipande hiki kitafuatiwa na kipande cha mwathirika.

### Example libc

[**Katika ukurasa huu**](https://guyinatuxedo.github.io/27-edit_free_chunk/heap_consolidation_explanation/index.html) inawezekana kupata mfano wa msingi wa Heap overflow unaoonyesha jinsi ya kuandika upya prev in use bit ya kipande kinachofuata na nafasi ya prev size inawezekana **kuunganisha kipande kilichotumika** (kwa kulifanya kufikiri hakijatumika) na **kisha kukitenga tena** ikiwa na uwezo wa kuandika data inayotumiwa katika pointer tofauti pia.

Mfano mwingine kutoka [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap0/index.html) unaonyesha mfano wa msingi wa CTF ambapo **heap overflow** inaweza kutumika vibaya kuita kazi ya mshindi ili **kupata bendera**.

Katika mfano wa [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap1/index.html) inawezekana kuona jinsi ya kutumia overflow ya buffer inaweza **kuandika upya katika kipande kilichokaribu anwani** ambapo **data ya mtumiaji isiyo na mipaka** itakuwa imeandikwa.

### Example ARM64

Katika ukurasa [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) unaweza kupata mfano wa heap overflow ambapo amri ambayo itatekelezwa inahifadhiwa katika kipande kinachofuata kutoka kwa kipande kilichojazwa. Hivyo, inawezekana kubadilisha amri inayotekelezwa kwa kuandika upya kwa unyakuzi rahisi kama:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Mifano mingine

- [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
- Tunatumia udhaifu wa Integer Overflow kupata Heap Overflow.
- Tunaharibu viashiria vya kazi ndani ya `struct` ya kipande kilichozidi uwezo ili kuweka kazi kama `system` na kupata utekelezaji wa msimbo.

{{#include ../../banners/hacktricks-training.md}}
