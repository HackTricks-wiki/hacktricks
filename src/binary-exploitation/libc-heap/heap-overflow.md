# Heap Overflow

{{#include ../../banners/hacktricks-training.md}}

## Grundinformationen

Ein Heap Overflow ist wie ein [**Stack Overflow**](../stack-overflow/), aber im Heap. Grundsätzlich bedeutet es, dass ein gewisser Speicher im Heap reserviert wurde, um einige Daten zu speichern, und **die gespeicherten Daten größer waren als der reservierte Speicher.**

Bei Stack Overflows wissen wir, dass einige Register wie der Befehlszeiger oder der Stack-Frame aus dem Stack wiederhergestellt werden und es möglich sein könnte, dies auszunutzen. Im Fall von Heap Overflows **gibt es standardmäßig keine sensiblen Informationen**, die im Heap-Chunk gespeichert sind, der überlaufen kann. Es könnten jedoch sensible Informationen oder Zeiger vorhanden sein, sodass die **Kritikalität** dieser Schwachstelle **abhängig** ist von **den Daten, die überschrieben werden könnten**, und wie ein Angreifer dies ausnutzen könnte.

> [!TIP]
> Um Überlauf-Offsets zu finden, können Sie die gleichen Muster wie bei [**Stack Overflows**](../stack-overflow/index.html#finding-stack-overflows-offsets) verwenden.

### Stack Overflows vs Heap Overflows

Bei Stack Overflows ist die Anordnung und die Daten, die zum Zeitpunkt des Auslösens der Schwachstelle im Stack vorhanden sind, ziemlich zuverlässig. Das liegt daran, dass der Stack linear ist, immer in kollidierendem Speicher zunimmt, an **bestimmten Stellen des Programmlaufs der Stack-Speicher normalerweise ähnliche Arten von Daten speichert** und eine spezifische Struktur mit einigen Zeigern am Ende des von jeder Funktion verwendeten Stack-Teils hat.

Im Fall eines Heap Overflows ist der verwendete Speicher jedoch nicht linear, sondern **zugewiesene Chunks befinden sich normalerweise an getrennten Speicherpositionen** (nicht nebeneinander), aufgrund von **Bins und Zonen**, die Zuweisungen nach Größe trennen, und weil **zuvor freigegebener Speicher verwendet wird**, bevor neue Chunks zugewiesen werden. Es ist **kompliziert zu wissen, welches Objekt mit dem anfälligen** für einen Heap Overflow kollidieren wird. Daher ist es notwendig, einen **zuverlässigen Weg zu finden, um das gewünschte Objekt im Speicher** neben dem überlaufbaren zu platzieren.

Eine der Techniken, die dafür verwendet werden, ist **Heap Grooming**, das beispielsweise [**in diesem Beitrag**](https://azeria-labs.com/grooming-the-ios-kernel-heap/) verwendet wird. In dem Beitrag wird erklärt, wie im iOS-Kernel, wenn eine Zone keinen Speicher mehr hat, um Chunks zu speichern, sie um eine Kernel-Seite erweitert wird, und diese Seite in Chunks der erwarteten Größen aufgeteilt wird, die in der Reihenfolge verwendet werden (bis zur iOS-Version 9.2, danach werden diese Chunks auf eine randomisierte Weise verwendet, um die Ausnutzung dieser Angriffe zu erschweren).

Daher wird in dem vorherigen Beitrag, in dem ein Heap Overflow auftritt, um das überlaufene Objekt dazu zu bringen, mit einem Opferobjekt zu kollidieren, mehrere **`kallocs` von mehreren Threads erzwungen, um sicherzustellen, dass alle freien Chunks gefüllt sind und dass eine neue Seite erstellt wird**.

Um dieses Füllen mit Objekten einer bestimmten Größe zu erzwingen, ist die **out-of-line Zuweisung, die mit einem iOS Mach-Port verbunden ist**, ein idealer Kandidat. Durch das Anpassen der Größe der Nachricht ist es möglich, die Größe der `kalloc`-Zuweisung genau anzugeben, und wenn der entsprechende Mach-Port zerstört wird, wird die entsprechende Zuweisung sofort wieder an `kfree` freigegeben.

Dann können einige dieser Platzhalter **freigegeben** werden. Die **`kalloc.4096`-Freiliste gibt Elemente in einer Last-in-First-out-Reihenfolge frei**, was im Grunde bedeutet, dass, wenn einige Platzhalter freigegeben werden und der Exploit versucht, mehrere Opferobjekte zuzuweisen, während er versucht, das anfällige Objekt für den Overflow zuzuweisen, es wahrscheinlich ist, dass dieses Objekt von einem Opferobjekt gefolgt wird.

### Beispiel libc

[**Auf dieser Seite**](https://guyinatuxedo.github.io/27-edit_free_chunk/heap_consolidation_explanation/index.html) ist es möglich, eine grundlegende Heap Overflow-Emulation zu finden, die zeigt, wie das Überschreiben des prev in use-Bits des nächsten Chunks und der Position der prev-Größe es ermöglicht, einen **verwendeten Chunk zu konsolidieren** (indem er denkt, er sei ungenutzt) und **dann erneut zuzuweisen**, wobei es möglich ist, Daten zu überschreiben, die auch in einem anderen Zeiger verwendet werden.

Ein weiteres Beispiel aus [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap0/index.html) zeigt ein sehr einfaches Beispiel eines CTF, bei dem ein **Heap Overflow** ausgenutzt werden kann, um die Gewinnerfunktion aufzurufen, um **die Flagge zu erhalten**.

Im [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap1/index.html) Beispiel ist es möglich zu sehen, wie durch das Ausnutzen eines Buffer Overflows es möglich ist, **in einem nahegelegenen Chunk eine Adresse zu überschreiben**, an die **willkürliche Daten des Benutzers** geschrieben werden sollen.

### Beispiel ARM64

Auf der Seite [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) finden Sie ein Heap Overflow-Beispiel, bei dem ein Befehl, der ausgeführt werden soll, im folgenden Chunk des überlaufenen Chunks gespeichert ist. Es ist also möglich, den ausgeführten Befehl zu ändern, indem man ihn mit einem einfachen Exploit wie folgendem überschreibt:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Weitere Beispiele

- [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
- Wir nutzen eine Integer Overflow-Sicherheitsanfälligkeit, um einen Heap Overflow zu erzeugen.
- Wir korrumpieren Zeiger auf eine Funktion innerhalb eines `struct` des überlaufenen Chunks, um eine Funktion wie `system` festzulegen und Codeausführung zu erhalten.

{{#include ../../banners/hacktricks-training.md}}
