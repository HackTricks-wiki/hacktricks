# Heap Overflow

{{#include ../../banners/hacktricks-training.md}}

## Grundinformationen

Ein Heap Overflow ist wie ein [**Stack Overflow**](../stack-overflow/index.html), aber im Heap. Grundsätzlich bedeutet es, dass ein gewisser Speicher im Heap reserviert wurde, um einige Daten zu speichern, und **die gespeicherten Daten größer waren als der reservierte Speicher.**

Bei Stack Overflows wissen wir, dass einige Register wie der Befehlszeiger oder der Stack-Frame aus dem Stack wiederhergestellt werden und es möglich sein könnte, dies auszunutzen. Im Fall von Heap Overflows **wird standardmäßig keine sensiblen Informationen** im Heap-Chunk gespeichert, das überlaufen werden kann. Es könnte jedoch sensible Informationen oder Zeiger geben, sodass die **Kritikalität** dieser Schwachstelle **abhängig** davon ist, **welche Daten überschrieben werden könnten** und wie ein Angreifer dies ausnutzen könnte.

> [!TIP]
> Um Überlauf-Offsets zu finden, können Sie die gleichen Muster wie bei [**Stack Overflows**](../stack-overflow/index.html#finding-stack-overflows-offsets) verwenden.

### Stack Overflows vs Heap Overflows

Bei Stack Overflows ist die Anordnung und die Daten, die zum Zeitpunkt des Auslösens der Schwachstelle im Stack vorhanden sind, ziemlich zuverlässig. Das liegt daran, dass der Stack linear ist, immer in kollidierendem Speicher zunimmt, an **bestimmten Stellen des Programmlaufs der Stack-Speicher normalerweise ähnliche Arten von Daten speichert** und eine spezifische Struktur mit einigen Zeigern am Ende des von jeder Funktion verwendeten Stack-Teils hat.

Im Fall eines Heap Overflows ist der verwendete Speicher jedoch nicht linear, sondern **zugewiesene Chunks befinden sich normalerweise an getrennten Speicherpositionen** (nicht nebeneinander), aufgrund von **Bins und Zonen**, die Zuweisungen nach Größe trennen, und weil **zuvor freigegebener Speicher verwendet wird**, bevor neue Chunks zugewiesen werden. Es ist **kompliziert zu wissen, welches Objekt mit dem anfälligen** für einen Heap Overflow kollidieren wird. Daher ist es notwendig, einen **zuverlässigen Weg zu finden, um das gewünschte Objekt im Speicher** neben dem überlaufbaren zu platzieren.

Eine der Techniken, die dafür verwendet wird, ist **Heap Grooming**, die beispielsweise [**in diesem Beitrag**](https://azeria-labs.com/grooming-the-ios-kernel-heap/) verwendet wird. In dem Beitrag wird erklärt, wie im iOS-Kernel, wenn eine Zone keinen Speicher mehr hat, um Chunks zu speichern, sie um eine Kernel-Seite erweitert wird, und diese Seite in Chunks der erwarteten Größen aufgeteilt wird, die in der Reihenfolge verwendet werden (bis zur iOS-Version 9.2, danach werden diese Chunks auf eine randomisierte Weise verwendet, um die Ausnutzung dieser Angriffe zu erschweren).

Daher wird in dem vorherigen Beitrag, in dem ein Heap Overflow auftritt, um das überlaufene Objekt dazu zu bringen, mit einem Opferobjekt zu kollidieren, mehrere **`kallocs` von mehreren Threads erzwungen, um sicherzustellen, dass alle freien Chunks gefüllt sind und dass eine neue Seite erstellt wird**.

Um dieses Füllen mit Objekten einer bestimmten Größe zu erzwingen, ist die **out-of-line Zuweisung, die mit einem iOS Mach-Port verbunden ist**, ein idealer Kandidat. Durch das Anpassen der Größe der Nachricht ist es möglich, die Größe der `kalloc`-Zuweisung genau anzugeben, und wenn der entsprechende Mach-Port zerstört wird, wird die entsprechende Zuweisung sofort wieder an `kfree` freigegeben.

Dann können einige dieser Platzhalter **freigegeben** werden. Die **`kalloc.4096`-Freiliste gibt Elemente in einer Last-In-First-Out-Reihenfolge frei**, was im Grunde bedeutet, dass, wenn einige Platzhalter freigegeben werden und der Exploit versucht, mehrere Opferobjekte zuzuweisen, während er versucht, das anfällige Objekt für den Overflow zuzuweisen, es wahrscheinlich ist, dass dieses Objekt von einem Opferobjekt gefolgt wird.

### Beispiel libc

[**Auf dieser Seite**](https://guyinatuxedo.github.io/27-edit_free_chunk/heap_consolidation_explanation/index.html) ist es möglich, eine grundlegende Heap Overflow-Emulation zu finden, die zeigt, wie das Überschreiben des prev in use-Bits des nächsten Chunks und der Position der prev-Größe es ermöglicht, einen **verwendeten Chunk zu konsolidieren** (indem er denkt, er sei ungenutzt) und **dann erneut zuzuweisen**, wodurch es möglich ist, Daten zu überschreiben, die in einem anderen Zeiger verwendet werden.

Ein weiteres Beispiel aus [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap0/index.html) zeigt ein sehr einfaches Beispiel eines CTF, bei dem ein **Heap Overflow** ausgenutzt werden kann, um die Gewinnerfunktion aufzurufen, um **die Flagge zu erhalten**.

Im [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap1/index.html) Beispiel ist es möglich zu sehen, wie durch das Ausnutzen eines Buffer Overflows es möglich ist, **in einem nahegelegenen Chunk eine Adresse zu überschreiben**, an die **willkürliche Daten des Benutzers** geschrieben werden sollen.

### Beispiel ARM64

Auf der Seite [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) finden Sie ein Beispiel für einen Heap Overflow, bei dem ein Befehl, der ausgeführt werden soll, im folgenden Chunk des überlaufenen Chunks gespeichert ist. Es ist also möglich, den ausgeführten Befehl zu ändern, indem man ihn mit einem einfachen Exploit wie folgt überschreibt:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Weitere Beispiele

- [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
- Wir nutzen eine Integer Overflow-Sicherheitsanfälligkeit, um einen Heap Overflow zu erzeugen.
- Wir korrumpieren Zeiger auf eine Funktion innerhalb einer `struct` des überlaufenen Chunks, um eine Funktion wie `system` festzulegen und Codeausführung zu erhalten.

### Beispiel aus der Praxis: CVE-2025-40597 – Missbrauch von `__sprintf_chk`

Im SonicWall SMA100 Firmware 10.2.1.15 allokiert das Reverse-Proxy-Modul `mod_httprp.so` einen **0x80-Byte** Heap-Chunks und fügt dann mehrere Strings mit `__sprintf_chk` zusammen:
```c
char *buf = calloc(0x80, 1);
/* … */
__sprintf_chk(buf,               /* destination (0x80-byte chunk) */
-1,                /* <-- size argument   !!! */
0,                 /* flags */
"%s%s%s%s",      /* format */
"/", "https://", path, host);
```
`__sprintf_chk` ist Teil von **_FORTIFY_SOURCE**. Wenn es einen **positiven** `size`-Parameter erhält, überprüft es, ob der resultierende String in den Zielpuffer passt. Durch das Übergeben von **`-1` (0xFFFFFFFFFFFFFFFF)** haben die Entwickler effektiv die **Grenzprüfung deaktiviert** und den gesicherten Aufruf wieder in ein klassisches, unsicheres `sprintf` umgewandelt.

Das Bereitstellen eines übermäßig langen **`Host:`**-Headers ermöglicht es einem Angreifer daher, **den 0x80-Byte-Chunck zu überlaufen und die Metadaten des folgenden Heap-Chunks zu überschreiben** (tcache / fast-bin / small-bin, je nach Allokator). Ein Absturz kann reproduziert werden mit:
```python
import requests, warnings
warnings.filterwarnings('ignore')
requests.get(
'https://TARGET/__api__/',
headers={'Host': 'A'*750},
verify=False
)
```
Praktische Ausnutzung würde **Heap Grooming** erfordern, um ein kontrollierbares Objekt direkt nach dem verwundbaren Chunk zu platzieren, aber die Hauptursache hebt zwei wichtige Erkenntnisse hervor:

1. **_FORTIFY_SOURCE ist kein Allheilmittel** – Missbrauch kann den Schutz zunichte machen.
2. Übergeben Sie immer die **korrekte Puffergröße** an die `_chk`-Familie (oder, noch besser, verwenden Sie `snprintf`).

## References
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)

{{#include ../../banners/hacktricks-training.md}}
