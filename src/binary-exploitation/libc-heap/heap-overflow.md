# Débordement de tas

{{#include ../../banners/hacktricks-training.md}}

## Informations de base

Un débordement de tas est comme un [**débordement de pile**](../stack-overflow/index.html) mais dans le tas. En gros, cela signifie qu'un espace a été réservé dans le tas pour stocker des données et que **les données stockées étaient plus grandes que l'espace réservé.**

Dans les débordements de pile, nous savons que certains registres comme le pointeur d'instruction ou le cadre de pile vont être restaurés à partir de la pile et qu'il pourrait être possible d'en abuser. Dans le cas des débordements de tas, il **n'y a pas d'informations sensibles stockées par défaut** dans le morceau de tas qui peut être débordé. Cependant, cela pourrait être des informations sensibles ou des pointeurs, donc la **criticité** de cette vulnérabilité **dépend** de **quelles données pourraient être écrasées** et de la manière dont un attaquant pourrait en abuser.

> [!TIP]
> Pour trouver les décalages de débordement, vous pouvez utiliser les mêmes motifs que dans les [**débordements de pile**](../stack-overflow/index.html#finding-stack-overflows-offsets).

### Débordements de pile vs Débordements de tas

Dans les débordements de pile, l'agencement et les données qui vont être présentes dans la pile au moment où la vulnérabilité peut être déclenchée sont assez fiables. Cela est dû au fait que la pile est linéaire, toujours croissante dans la mémoire en collision, dans **des endroits spécifiques de l'exécution du programme, la mémoire de la pile stocke généralement des données similaires** et elle a une structure spécifique avec des pointeurs à la fin de la partie de la pile utilisée par chaque fonction.

Cependant, dans le cas d'un débordement de tas, la mémoire utilisée n'est pas linéaire mais **les morceaux alloués sont généralement dans des positions séparées de la mémoire** (pas l'un à côté de l'autre) à cause des **bins et des zones** séparant les allocations par taille et parce que **la mémoire précédemment libérée est utilisée** avant d'allouer de nouveaux morceaux. Il est **compliqué de savoir quel objet va entrer en collision avec celui vulnérable** à un débordement de tas. Donc, lorsqu'un débordement de tas est trouvé, il est nécessaire de trouver un **moyen fiable de faire en sorte que l'objet désiré soit le suivant en mémoire** de celui qui peut être débordé.

Une des techniques utilisées pour cela est le **Heap Grooming** qui est utilisé par exemple [**dans ce post**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). Dans le post, il est expliqué comment, lorsque dans le noyau iOS, une zone manque de mémoire pour stocker des morceaux de mémoire, elle l'agrandit par une page de noyau, et cette page est divisée en morceaux des tailles attendues qui seraient utilisées dans l'ordre (jusqu'à la version iOS 9.2, puis ces morceaux sont utilisés de manière aléatoire pour compliquer l'exploitation de ces attaques).

Par conséquent, dans le post précédent où un débordement de tas se produit, afin de forcer l'objet débordé à entrer en collision avec un ordre de victime, plusieurs **`kallocs` sont forcés par plusieurs threads pour essayer de s'assurer que tous les morceaux libres sont remplis et qu'une nouvelle page est créée**.

Pour forcer ce remplissage avec des objets d'une taille spécifique, l'**allocation hors ligne associée à un port mach iOS** est un candidat idéal. En façonnant la taille du message, il est possible de spécifier exactement la taille de l'allocation `kalloc` et lorsque le port mach correspondant est détruit, l'allocation correspondante sera immédiatement libérée à `kfree`.

Ensuite, certains de ces espaces réservés peuvent être **libérés**. La **liste libre `kalloc.4096` libère des éléments dans un ordre dernier entré, premier sorti**, ce qui signifie essentiellement que si certains espaces réservés sont libérés et que l'exploit essaie d'allouer plusieurs objets victimes tout en essayant d'allouer l'objet vulnérable au débordement, il est probable que cet objet sera suivi par un objet victime.

### Exemple libc

[**Sur cette page**](https://guyinatuxedo.github.io/27-edit_free_chunk/heap_consolidation_explanation/index.html), il est possible de trouver une émulation de débordement de tas de base qui montre comment écraser le bit prev in use du morceau suivant et la position de la taille prev permet de **consolider un morceau utilisé** (en le faisant croire qu'il est inutilisé) et **ensuite de le réallouer** en étant capable d'écraser des données qui sont utilisées dans un autre pointeur également.

Un autre exemple de [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap0/index.html) montre un exemple très basique d'un CTF où un **débordement de tas** peut être abusé pour appeler la fonction gagnante pour **obtenir le drapeau**.

Dans l'exemple [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap1/index.html), il est possible de voir comment en abusant d'un débordement de tampon, il est possible d'**écraser dans un morceau voisin une adresse** où **des données arbitraires de l'utilisateur** vont être écrites.

### Exemple ARM64

Sur la page [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/), vous pouvez trouver un exemple de débordement de tas où une commande qui va être exécutée est stockée dans le morceau suivant du morceau débordé. Ainsi, il est possible de modifier la commande exécutée en l'écrasant avec un exploit simple tel que :
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Autres exemples

- [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
- Nous utilisons une vulnérabilité d'Integer Overflow pour obtenir un Heap Overflow.
- Nous corrompons des pointeurs vers une fonction à l'intérieur d'un `struct` du chunk débordé pour définir une fonction telle que `system` et obtenir l'exécution de code.

{{#include ../../banners/hacktricks-training.md}}
