# Heap Overflow

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

'n Heap overflow is soos 'n [**stack overflow**](../stack-overflow/index.html) maar in die heap. Basies beteken dit dat 'n sekere ruimte in die heap gereserveer is om data te stoor en **gestoorde data was groter as die gereserveerde ruimte.**

In stack overflows weet ons dat sommige registers soos die instruksie-aanwyser of die stack-raam herstel gaan word vanaf die stack en dit kan moontlik misbruik word. In die geval van heap overflows, daar **is geen sensitiewe inligting wat standaard in die heap chunk gestoor word** wat oorgestroom kan word nie. Dit kan egter sensitiewe inligting of aanwysers wees, so die **kritikaliteit** van hierdie kwesbaarheid **hang af** van **watter data oorgeskryf kan word** en hoe 'n aanvaller dit kan misbruik.

> [!TIP]
> Om overflow offsets te vind, kan jy dieselfde patrone gebruik as in [**stack overflows**](../stack-overflow/index.html#finding-stack-overflows-offsets).

### Stack Overflows vs Heap Overflows

In stack overflows is die rangskikking en data wat teenwoordig gaan wees in die stack op die oomblik dat die kwesbaarheid geaktiveer kan word redelik betroubaar. Dit is omdat die stack lineêr is, altyd toeneem in botsende geheue, in **spesifieke plekke van die program se uitvoering stoor die stack geheue gewoonlik soortgelyke tipe data** en dit het 'n spesifieke struktuur met sommige aanwysers aan die einde van die stack deel wat deur elke funksie gebruik word.

In die geval van 'n heap overflow, is die gebruikte geheue egter nie lineêr nie, maar **toegewyde chunks is gewoonlik in geskeide posisies van geheue** (nie een langs die ander nie) as gevolg van **bins en sone** wat toewysings volgens grootte skei en omdat **vorige vrygemaakte geheue gebruik word** voordat nuwe chunks toegewy word. Dit is **komplikasies om die objek te weet wat gaan bots met die een wat kwesbaar is** vir 'n heap overflow. So, wanneer 'n heap overflow gevind word, is dit nodig om 'n **betroubare manier te vind om die gewenste objek volgende in geheue te maak** van die een wat oorgestroom kan word.

Een van die tegnieke wat hiervoor gebruik word, is **Heap Grooming** wat byvoorbeeld [**in hierdie pos**](https://azeria-labs.com/grooming-the-ios-kernel-heap/) gebruik word. In die pos word verduidelik hoe wanneer in die iOS-kern wanneer 'n sone uit geheue vir die stoor van chunks van geheue loop, dit dit uitbrei met 'n kernbladsy, en hierdie bladsy word in chunks van die verwagte groottes gesplit, wat in volgorde gebruik sal word (tot iOS weergawe 9.2, dan word hierdie chunks op 'n randomiseerde manier gebruik om die uitbuiting van hierdie aanvalle te bemoeilik).

Daarom, in die vorige pos waar 'n heap overflow plaasvind, om die oorgestroomde objek te dwing om met 'n slagoffer volgorde te bots, word verskeie **`kallocs` deur verskeie drade gedwing om te probeer verseker dat al die vrye chunks gevul is en dat 'n nuwe bladsy geskep word**.

Om hierdie vul met objek van 'n spesifieke grootte te dwing, is die **out-of-line toewysing geassosieer met 'n iOS mach port** 'n ideale kandidaat. Deur die grootte van die boodskap te vervaardig, is dit moontlik om presies die grootte van `kalloc` toewysing te spesifiseer en wanneer die ooreenstemmende mach port vernietig word, sal die ooreenstemmende toewysing onmiddellik teruggegee word aan `kfree`.

Dan kan sommige van hierdie plekhouers **vrygestel** word. Die **`kalloc.4096` vrye lys stel elemente in 'n laaste-in-eerste-uit volgorde vry**, wat basies beteken dat as sommige plekhouers vrygestel word en die uitbuiting probeer om verskeie slagoffer objekte toe te wys terwyl dit probeer om die objek wat kwesbaar is vir overflow toe te wys, is dit waarskynlik dat hierdie objek gevolg sal word deur 'n slagoffer objek.

### Voorbeeld libc

[**Op hierdie bladsy**](https://guyinatuxedo.github.io/27-edit_free_chunk/heap_consolidation_explanation/index.html) is dit moontlik om 'n basiese Heap overflow emulering te vind wat wys hoe om die prev in gebruik bit van die volgende chunk te oorskryf en die posisie van die prev grootte, dit is moontlik om 'n **gebruikte chunk te konsolideer** (deur dit te laat dink dit is ongebruikte) en **dan dit weer toe te wys** terwyl dit in staat is om data wat in 'n ander aanwyser gebruik word, ook te oorskryf.

'n Ander voorbeeld van [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap0/index.html) wys 'n baie basiese voorbeeld van 'n CTF waar 'n **heap overflow** misbruik kan word om die wenner funksie aan te roep om **die vlag te kry**.

In die [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap1/index.html) voorbeeld is dit moontlik om te sien hoe om 'n buffer overflow te misbruik, dit is moontlik om **in 'n naby chunk 'n adres te oorskryf** waar **arbitraire data van die gebruiker** geskryf gaan word.

### Voorbeeld ARM64

Op die bladsy [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) kan jy 'n heap overflow voorbeeld vind waar 'n opdrag wat uitgevoer gaan word, in die volgende chunk van die oorgestroomde chunk gestoor word. So, dit is moontlik om die uitgevoerde opdrag te verander deur dit te oorskryf met 'n maklike uitbuiting soos:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Ander voorbeelde

- [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
- Ons gebruik 'n Integer Overflow kwesbaarheid om 'n Heap Overflow te verkry.
- Ons korrigeer pointers na 'n funksie binne 'n `struct` van die oorgeloopde stuk om 'n funksie soos `system` in te stel en kode-uitvoering te verkry.

### Werklike Voorbeeld: CVE-2025-40597 – Misbruik van `__sprintf_chk`

In SonicWall SMA100 firmware 10.2.1.15 allokeer die reverse-proxy module `mod_httprp.so` 'n **0x80-byte** heap stuk en voeg dan verskeie strings daarin saam met `__sprintf_chk`:
```c
char *buf = calloc(0x80, 1);
/* … */
__sprintf_chk(buf,               /* destination (0x80-byte chunk) */
-1,                /* <-- size argument   !!! */
0,                 /* flags */
"%s%s%s%s",      /* format */
"/", "https://", path, host);
```
`__sprintf_chk` is deel van **_FORTIFY_SOURCE**. Wanneer dit 'n **positiewe** `size` parameter ontvang, verifieer dit dat die resulterende string binne die bestemmingsbuffer pas. Deur **`-1` (0xFFFFFFFFFFFFFFFF)** te stuur, het die ontwikkelaars effektief die **grenskontrole gedeaktiveer**, wat die versterkte oproep terug na 'n klassieke, onveilige `sprintf` verander.

Die verskaffing van 'n te lang **`Host:`** kop laat 'n aanvaller dus toe om **die 0x80-byte stuk oor te vloei en die metadata van die volgende heap stuk te verwoes** (tcache / fast-bin / small-bin, afhangende van die toewysingsmeganisme). 'n Crash kan herproduseer word met:
```python
import requests, warnings
warnings.filterwarnings('ignore')
requests.get(
'https://TARGET/__api__/',
headers={'Host': 'A'*750},
verify=False
)
```
Praktiese eksploitatie sal **heap grooming** vereis om 'n beheerde objek reg na die kwesbare stuk te plaas, maar die wortel oorsaak beklemtoon twee belangrike afleidings:

1. **_FORTIFY_SOURCE is nie 'n silwer koeël nie** – misbruik kan die beskerming nietig maak.
2. Gee altyd die **korrekte buffer grootte** aan die `_chk` familie (of, selfs beter, gebruik `snprintf`).

## References
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)

{{#include ../../banners/hacktricks-training.md}}
