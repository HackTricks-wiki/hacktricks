# Heap Overflow

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Overflow ya heap ni kama [**stack overflow**](../stack-overflow/) lakini katika heap. Kimsingi inamaanisha kwamba nafasi fulani ilihifadhiwa katika heap kuhifadhi data fulani na **data iliyohifadhiwa ilikuwa kubwa kuliko nafasi iliyohifadhiwa.**

Katika stack overflows tunajua kwamba baadhi ya register kama vile pointer ya maagizo au frame ya stack zitarejeshwa kutoka kwenye stack na inaweza kuwa na uwezekano wa kutumia hii. Katika kesi ya heap overflows, **hakuna taarifa nyeti iliyohifadhiwa kwa chaguo-msingi** katika kipande cha heap ambacho kinaweza kujaa. Hata hivyo, inaweza kuwa taarifa nyeti au pointers, hivyo **umuhimu** wa udhaifu huu **unategemea** **ni data ipi inaweza kuandikwa upya** na jinsi mshambuliaji anaweza kutumia hii.

> [!TIP]
> Ili kupata offsets za overflow unaweza kutumia mifumo ile ile kama katika [**stack overflows**](../stack-overflow/#finding-stack-overflows-offsets).

### Stack Overflows vs Heap Overflows

Katika stack overflows, mpangilio na data ambayo itakuwa katika stack wakati udhaifu unaweza kuchochewa ni wa kuaminika sana. Hii ni kwa sababu stack ni ya mstari, kila wakati ikiongezeka katika kumbukumbu inayopingana, katika **sehemu maalum za programu inayoendesha kumbukumbu ya stack kawaida huhifadhi aina sawa ya data** na ina muundo maalum na pointers kadhaa mwishoni mwa sehemu ya stack inayotumiwa na kila kazi.

Hata hivyo, katika kesi ya overflow ya heap, kumbukumbu inayotumika si ya mstari bali **vipande vilivyotengwa kawaida viko katika nafasi tofauti za kumbukumbu** (sio kando ya nyingine) kwa sababu ya **bins na maeneo** yanayotenganisha allocations kwa ukubwa na kwa sababu **kumbukumbu iliyotolewa awali inatumika** kabla ya kutenga vipande vipya. Ni **ngumu kujua kitu ambacho kitakuwa kinagongana na kile kilicho hatarini** kwa overflow ya heap. Hivyo, wakati overflow ya heap inapatikana, inahitajika kupata **njia ya kuaminika kufanya kitu kinachotakiwa kuwa karibu katika kumbukumbu** na kile kinachoweza kujaa.

Moja ya mbinu zinazotumika kwa hili ni **Heap Grooming** ambayo inatumika kwa mfano [**katika chapisho hili**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). Katika chapisho inaelezwa jinsi wakati katika kernel ya iOS wakati eneo linapokosa kumbukumbu ya kuhifadhi vipande vya kumbukumbu, linaipanua kwa ukurasa wa kernel, na ukurasa huu unagawanywa katika vipande vya ukubwa unaotarajiwa ambavyo vitatumika kwa mpangilio (hadi toleo la iOS 9.2, kisha vipande hivi vinatumika kwa njia ya nasibu ili kuleta ugumu katika matumizi ya mashambulizi haya).

Kwa hivyo, katika chapisho la awali ambapo overflow ya heap inatokea, ili kulazimisha kitu kilichojazwa kuwa kinagongana na agizo la mwathirika, **`kallocs` kadhaa zinapaswa kulazimishwa na nyuzi kadhaa ili kujaribu kuhakikisha kwamba vipande vyote vilivyotolewa vimejaa na kwamba ukurasa mpya unaundwa**.

Ili kulazimisha kujaza hili kwa vitu vya ukubwa maalum, **allocation ya nje ya mstari inayohusishwa na mach port ya iOS** ni mgombea bora. Kwa kubuni ukubwa wa ujumbe, inawezekana kubaini kwa usahihi ukubwa wa `kalloc` allocation na wakati mach port inayohusiana inaharibiwa, allocation inayohusiana itarejeshwa mara moja kwa `kfree`.

Kisha, baadhi ya hizi placeholders zinaweza kuwa **zimeachiliwa**. Orodha ya bure ya **`kalloc.4096` inatoa vipengele kwa mpangilio wa mwisho-kuingia-wa-kwanza**, ambayo kimsingi inamaanisha kwamba ikiwa baadhi ya placeholders zimeachiliwa na jaribio la exploit linajaribu kutenga vitu kadhaa vya mwathirika wakati wa kujaribu kutenga kitu kilicho hatarini kujaa, kuna uwezekano kwamba kitu hiki kitafuatiwa na kitu cha mwathirika.

### Example libc

[**Katika ukurasa huu**](https://guyinatuxedo.github.io/27-edit_free_chunk/heap_consolidation_explanation/index.html) inawezekana kupata mfano wa msingi wa overflow ya heap unaoonyesha jinsi ya kuandika upya bit ya prev inatumika ya kipande kinachofuata na nafasi ya ukubwa wa prev inawezekana **kuunganisha kipande kilichotumika** (kwa kulifanya kufikiri hakitumiki) na **kisha kukitenga tena** ikiwa na uwezo wa kuandika data inayotumika katika pointer tofauti pia.

Mfano mwingine kutoka [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap0/index.html) unaonyesha mfano wa msingi wa CTF ambapo **overflow ya heap** inaweza kutumika kuita kazi ya mshindi ili **kupata bendera**.

Katika mfano wa [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap1/index.html) inawezekana kuona jinsi ya kutumia overflow ya buffer inawezekana **kuandika upya katika kipande kilichokaribu anwani** ambapo **data isiyo na mpangilio kutoka kwa mtumiaji** itakuwa imeandikwa.

### Example ARM64

Katika ukurasa [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) unaweza kupata mfano wa overflow ya heap ambapo amri ambayo itatekelezwa inahifadhiwa katika kipande kinachofuata kutoka kwa kipande kilichojazwa. Hivyo, inawezekana kubadilisha amri inayotekelezwa kwa kuandika upya kwa exploit rahisi kama:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Mifano mingine

- [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
- Tunatumia udhaifu wa Integer Overflow kupata Heap Overflow.
- Tunaharibu viashiria vya kazi ndani ya `struct` ya kipande kilichozidi uwezo ili kuweka kazi kama `system` na kupata utekelezaji wa msimbo.

{{#include ../../banners/hacktricks-training.md}}
