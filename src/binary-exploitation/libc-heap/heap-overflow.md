# Heap Overflow

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Ένα heap overflow είναι σαν ένα [**stack overflow**](../stack-overflow/index.html) αλλά στο heap. Βασικά σημαίνει ότι κάποιος χώρος έχει κρατηθεί στο heap για να αποθηκεύσει κάποια δεδομένα και **τα αποθηκευμένα δεδομένα ήταν μεγαλύτερα από τον κρατημένο χώρο.**

Στα stack overflows γνωρίζουμε ότι μερικοί καταχωρητές όπως ο δείκτης εντολών ή το stack frame θα αποκατασταθούν από το stack και θα μπορούσε να είναι δυνατό να γίνει κατάχρηση αυτού. Στην περίπτωση των heap overflows, **δεν υπάρχει καμία ευαίσθητη πληροφορία που να αποθηκεύεται από προεπιλογή** στο heap chunk που μπορεί να υπερχειλιστεί. Ωστόσο, θα μπορούσε να είναι ευαίσθητη πληροφορία ή δείκτες, οπότε η **κριτική σημασία** αυτής της ευπάθειας **εξαρτάται** από **ποια δεδομένα θα μπορούσαν να αντικατασταθούν** και πώς ένας επιτιθέμενος θα μπορούσε να εκμεταλλευτεί αυτό.

> [!TIP]
> Για να βρείτε τα offsets υπερχείλισης μπορείτε να χρησιμοποιήσετε τα ίδια μοτίβα όπως στα [**stack overflows**](../stack-overflow/index.html#finding-stack-overflows-offsets).

### Stack Overflows vs Heap Overflows

Στα stack overflows η διάταξη και τα δεδομένα που θα είναι παρόντα στο stack τη στιγμή που μπορεί να ενεργοποιηθεί η ευπάθεια είναι αρκετά αξιόπιστα. Αυτό συμβαίνει επειδή το stack είναι γραμμικό, πάντα αυξανόμενο σε συγκρουόμενη μνήμη, σε **συγκεκριμένες θέσεις της εκτέλεσης του προγράμματος η μνήμη του stack συνήθως αποθηκεύει παρόμοια είδη δεδομένων** και έχει κάποια συγκεκριμένη δομή με μερικούς δείκτες στο τέλος του τμήματος του stack που χρησιμοποιείται από κάθε συνάρτηση.

Ωστόσο, στην περίπτωση ενός heap overflow, η χρησιμοποιούμενη μνήμη δεν είναι γραμμική αλλά **οι κατανεμημένοι χώροι είναι συνήθως σε ξεχωριστές θέσεις μνήμης** (όχι ο ένας δίπλα στον άλλο) λόγω των **bins και zones** που διαχωρίζουν τις κατανομές κατά μέγεθος και επειδή **η προηγούμενη ελεύθερη μνήμη χρησιμοποιείται** πριν από την κατανομή νέων chunks. Είναι **περίπλοκο να γνωρίζουμε το αντικείμενο που θα συγκρούεται με αυτό που είναι ευάλωτο** σε ένα heap overflow. Έτσι, όταν βρεθεί ένα heap overflow, είναι απαραίτητο να βρεθεί ένας **αξιόπιστος τρόπος για να γίνει το επιθυμητό αντικείμενο το επόμενο στη μνήμη** από αυτό που μπορεί να υπερχειλιστεί.

Μία από τις τεχνικές που χρησιμοποιούνται για αυτό είναι το **Heap Grooming** το οποίο χρησιμοποιείται για παράδειγμα [**σε αυτή την ανάρτηση**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). Στην ανάρτηση εξηγείται πώς όταν στο iOS kernel μια ζώνη εξαντλείται από μνήμη για να αποθηκεύσει chunks μνήμης, επεκτείνεται κατά μία σελίδα kernel, και αυτή η σελίδα χωρίζεται σε chunks των αναμενόμενων μεγεθών που θα χρησιμοποιηθούν με σειρά (μέχρι την έκδοση iOS 9.2, τότε αυτά τα chunks χρησιμοποιούνται με τυχαίο τρόπο για να δυσκολέψουν την εκμετάλλευση αυτών των επιθέσεων).

Επομένως, στην προηγούμενη ανάρτηση όπου συμβαίνει ένα heap overflow, προκειμένου να αναγκαστεί το υπερχειλισμένο αντικείμενο να συγκρούεται με μια σειρά θύματος, αρκετές **`kallocs` αναγκάζονται από αρκετές νήματα για να προσπαθήσουν να διασφαλίσουν ότι όλα τα ελεύθερα chunks είναι γεμάτα και ότι δημιουργείται μια νέα σελίδα**.

Για να αναγκαστεί αυτή η γέμιση με αντικείμενα συγκεκριμένου μεγέθους, η **εκτός γραμμής κατανομή που σχετίζεται με ένα mach port του iOS** είναι ένας ιδανικός υποψήφιος. Με την κατασκευή του μεγέθους του μηνύματος, είναι δυνατό να καθοριστεί ακριβώς το μέγεθος της κατανομής `kalloc` και όταν το αντίστοιχο mach port καταστραφεί, η αντίστοιχη κατανομή θα απελευθερωθεί αμέσως πίσω στο `kfree`.

Στη συνέχεια, μερικοί από αυτούς τους χώρους μπορεί να είναι **ελεύθεροι**. Η **λίστα ελεύθερων `kalloc.4096` απελευθερώνει στοιχεία με σειρά τελευταίου εισερχόμενου πρώτου εξερχόμενου**, που σημαίνει βασικά ότι αν μερικοί χώροι είναι ελεύθεροι και η εκμετάλλευση προσπαθεί να κατανοήσει αρκετά αντικείμενα θύματα ενώ προσπαθεί να κατανοήσει το αντικείμενο που είναι ευάλωτο σε υπερχείλιση, είναι πιθανό ότι αυτό το αντικείμενο θα ακολουθείται από ένα αντικείμενο θύμα.

### Example libc

[**Σε αυτή τη σελίδα**](https://guyinatuxedo.github.io/27-edit_free_chunk/heap_consolidation_explanation/index.html) είναι δυνατό να βρείτε μια βασική προσομοίωση heap overflow που δείχνει πώς η αντικατάσταση του prev in use bit του επόμενου chunk και η θέση του prev size είναι δυνατό να **συγκεντρώσουν ένα χρησιμοποιούμενο chunk** (κάνοντάς το να νομίζει ότι είναι αχρησιμοποίητο) και **στη συνέχεια να το κατανοήσουν ξανά** έχοντας τη δυνατότητα να αντικαταστήσουν δεδομένα που χρησιμοποιούνται σε διαφορετικό δείκτη επίσης.

Ένα άλλο παράδειγμα από [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap0/index.html) δείχνει ένα πολύ βασικό παράδειγμα ενός CTF όπου ένα **heap overflow** μπορεί να εκμεταλλευτεί για να καλέσει τη συνάρτηση νικητή για **να πάρει τη σημαία**.

Στο παράδειγμα [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap1/index.html) είναι δυνατό να δείτε πώς με την κατάχρηση ενός buffer overflow είναι δυνατό να **αντικατασταθεί σε ένα κοντινό chunk μια διεύθυνση** όπου **θα γραφούν αυθαίρετα δεδομένα από τον χρήστη**.

### Example ARM64

Στη σελίδα [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) μπορείτε να βρείτε ένα παράδειγμα heap overflow όπου μια εντολή που πρόκειται να εκτελεστεί αποθηκεύεται στο επόμενο chunk από το υπερχειλισμένο chunk. Έτσι, είναι δυνατό να τροποποιηθεί η εκτελούμενη εντολή αντικαθιστώντας την με μια εύκολη εκμετάλλευση όπως:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Άλλα παραδείγματα

- [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
- Χρησιμοποιούμε μια ευπάθεια Integer Overflow για να αποκτήσουμε Heap Overflow.
- Διαφθείρουμε δείκτες σε μια συνάρτηση μέσα σε ένα `struct` του υπερχειλισμένου κομματιού για να ορίσουμε μια συνάρτηση όπως το `system` και να αποκτήσουμε εκτέλεση κώδικα.

### Παράδειγμα Πραγματικού Κόσμου: CVE-2025-40597 – Κακή χρήση του `__sprintf_chk`

Στο firmware 10.2.1.15 του SonicWall SMA100, το module reverse-proxy `mod_httprp.so` εκχωρεί ένα **0x80-byte** heap chunk και στη συνέχεια συγχωνεύει πολλές συμβολοσειρές σε αυτό με το `__sprintf_chk`:
```c
char *buf = calloc(0x80, 1);
/* … */
__sprintf_chk(buf,               /* destination (0x80-byte chunk) */
-1,                /* <-- size argument   !!! */
0,                 /* flags */
"%s%s%s%s",      /* format */
"/", "https://", path, host);
```
`__sprintf_chk` είναι μέρος του **_FORTIFY_SOURCE**. Όταν λαμβάνει μια **θετική** παράμετρο `size`, επαληθεύει ότι η προκύπτουσα συμβολοσειρά χωράει μέσα στο προορισμένο buffer. Με την παράδοση **`-1` (0xFFFFFFFFFFFFFFFF)** οι προγραμματιστές ουσιαστικά **απενεργοποίησαν τον έλεγχο ορίων**, μετατρέποντας την ενισχυμένη κλήση πίσω σε μια κλασική, μη ασφαλή `sprintf`.

Η παροχή μιας υπερβολικά μεγάλης **`Host:`** κεφαλίδας επιτρέπει επομένως σε έναν επιτιθέμενο να **υπερχείλει το chunk των 0x80 byte και να καταστρέψει τα μεταδεδομένα του επόμενου chunk της heap** (tcache / fast-bin / small-bin ανάλογα με τον αλγόριθμο κατανομής). Ένα crash μπορεί να αναπαραχθεί με:
```python
import requests, warnings
warnings.filterwarnings('ignore')
requests.get(
'https://TARGET/__api__/',
headers={'Host': 'A'*750},
verify=False
)
```
Η πρακτική εκμετάλλευση θα απαιτούσε **heap grooming** για να τοποθετήσει ένα ελεγχόμενο αντικείμενο αμέσως μετά το ευάλωτο κομμάτι, αλλά η ρίζα του προβλήματος επισημαίνει δύο σημαντικά διδάγματα:

1. **_FORTIFY_SOURCE δεν είναι πανάκεια** – η κακή χρήση μπορεί να αναιρέσει την προστασία.
2. Πάντα να περνάτε το **σωστό μέγεθος buffer** στην οικογένεια `_chk` (ή, ακόμα καλύτερα, να χρησιμοποιείτε `snprintf`).

## References
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)

{{#include ../../banners/hacktricks-training.md}}
