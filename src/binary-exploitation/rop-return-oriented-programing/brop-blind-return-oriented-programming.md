# BROP - Blind Return Oriented Programming

{{#include ../../banners/hacktricks-training.md}}

## 基本情報

この攻撃の目的は、**脆弱なバイナリに関する情報がなくてもバッファオーバーフローを介してROPを悪用できるようにすること**です。\
この攻撃は以下のシナリオに基づいています：

- スタックの脆弱性とそれをトリガーする方法の知識。
- クラッシュ後に再起動するサーバーアプリケーション。

## 攻撃

### **1. 脆弱なオフセットを見つける** サーバーの異常が検出されるまで1文字追加で送信する

### **2. カナリアをブルートフォース** して漏洩させる

### **3. スタック内の保存されたRBPとRIP** アドレスをブルートフォースして漏洩させる

これらのプロセスに関する詳細情報は、[こちら (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md)と[こちら (BF Addresses in the Stack)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md)で見つけることができます。

### **4. 停止ガジェットを見つける**

このガジェットは基本的に、ROPガジェットによって何か興味深いことが実行されたことを確認するためのもので、実行がクラッシュしなかったことを示します。通常、このガジェットは**実行を停止する**もので、特定のROPガジェットが実行されたことを確認するためにROPチェーンの最後に配置されます。

### **5. BROPガジェットを見つける**

この技術は[**ret2csu**](ret2csu.md)ガジェットを使用します。これは、いくつかの命令の途中でこのガジェットにアクセスすると、**`rsi`**と**`rdi`**を制御するガジェットが得られるためです：

<figure><img src="../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

これらがガジェットです：

- `pop rsi; pop r15; ret`
- `pop rdi; ret`

これらのガジェットを使用すると、関数を呼び出すための**2つの引数を制御する**ことが可能であることに注意してください。

また、ret2csuガジェットは**非常にユニークなシグネチャ**を持っているため、スタックから6つのレジスタをポップすることになります。したがって、次のようなチェーンを送信します：

`'A' * offset + canary + rbp + ADDR + 0xdead * 6 + STOP`

**STOPが実行される**場合、これは基本的に**スタックから6つのレジスタをポップするアドレス**が使用されたことを意味します。または、使用されたアドレスもSTOPアドレスであったことを意味します。

この最後のオプションを**排除するために**、次のような新しいチェーンが実行され、前のものが6つのレジスタをポップしたことを確認するためにSTOPガジェットを実行してはなりません：

`'A' * offset + canary + rbp + ADDR`

ret2csuガジェットのアドレスを知っていると、**`rsi`と`rdi`を制御するガジェットのアドレスを推測する**ことが可能です。

### 6. PLTを見つける

PLTテーブルは0x400000から、またはスタックからの**漏洩したRIPアドレス**から検索できます（**PIE**が使用されている場合）。テーブルの**エントリ**は**16B**（0x10B）で**区切られており**、1つの関数が呼び出されると、引数が正しくなくてもサーバーはクラッシュしません。また、**PLTのエントリのアドレス + 6Bもクラッシュしません**。これは最初に実行されるコードです。

したがって、次の動作を確認することでPLTテーブルを見つけることができます：

- `'A' * offset + canary + rbp + ADDR + STOP` -> クラッシュしない
- `'A' * offset + canary + rbp + (ADDR + 0x6) + STOP` -> クラッシュしない
- `'A' * offset + canary + rbp + (ADDR + 0x10) + STOP` -> クラッシュしない

### 7. strcmpを見つける

**`strcmp`**関数は、比較される文字列の長さをレジスタ**`rdx`**に設定します。**`rdx`**は**3番目の引数**であり、後でプログラムを漏洩させるために**0より大きくする必要があります**。

次のように、関数の最初の2つの引数を制御できる事実を利用して、PLT内の**`strcmp`**の位置を見つけることができます：

- strcmp(\<非読み取りアドレス>, \<非読み取りアドレス>) -> クラッシュ
- strcmp(\<非読み取りアドレス>, \<読み取りアドレス>) -> クラッシュ
- strcmp(\<読み取りアドレス>, \<非読み取りアドレス>) -> クラッシュ
- strcmp(\<読み取りアドレス>, \<読み取りアドレス>) -> クラッシュしない

これは、PLTテーブルの各エントリを呼び出すか、**PLTスローパス**を使用して確認できます。これは基本的に**PLTテーブルのエントリを呼び出し + 0xb**（**`dlresolve`**を呼び出す）し、スタックに**調査したいエントリ番号**（ゼロから始まる）を続けて、最初のエントリからすべてのPLTエントリをスキャンします：

- strcmp(\<非読み取りアドレス>, \<読み取りアドレス>) -> クラッシュ
- `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP` -> クラッシュする
- strcmp(\<読み取りアドレス>, \<非読み取りアドレス>) -> クラッシュ
- `b'A' * offset + canary + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`
- strcmp(\<読み取りアドレス>, \<読み取りアドレス>) -> クラッシュしない
- `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`

覚えておいてください：

- BROP + 0x7は**`pop RSI; pop R15; ret;`**を指します
- BROP + 0x9は**`pop RDI; ret;`**を指します
- PLT + 0xbは**dl_resolve**への呼び出しを指します。

`strcmp`を見つけることで、**`rdx`**を0より大きい値に設定することが可能です。

> [!TIP]
> 通常、`rdx`にはすでに0より大きい値が格納されているため、このステップは必要ないかもしれません。

### 8. Writeまたは同等のものを見つける

最後に、バイナリを漏洩させるためにデータを外部に送信するガジェットが必要です。そして、この時点で**2つの引数を制御し、`rdx`を0より大きく設定することが可能です。**

これに悪用できる一般的な関数は3つあります：

- `puts(data)`
- `dprintf(fd, data)`
- `write(fd, data, len(data))`

ただし、元の論文では**`write`**のみが言及されているため、これについて話しましょう：

現在の問題は、**PLT内のwrite関数がどこにあるか**がわからず、**データをソケットに送信するためのfd番号がわからない**ことです。

しかし、**PLTテーブルの位置はわかっており**、その**動作**に基づいてwriteを見つけることが可能です。また、サーバーとの**複数の接続**を作成し、**高いFD**を使用して、いくつかの接続と一致することを期待できます。

これらの関数を見つけるための動作シグネチャ：

- `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> データが印刷される場合、putsが見つかりました
- `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> データが印刷される場合、dprintfが見つかりました
- `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> データが印刷される場合、writeが見つかりました

## 自動エクスプロイト

- [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## 参考文献

- 元の論文：[https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
- [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)

{{#include ../../banners/hacktricks-training.md}}
