# BROP - Blind Return Oriented Programming

{{#include ../../banners/hacktricks-training.md}}

## Osnovne informacije

Cilj ovog napada je da se **zloupotrebi ROP putem prelivanja bafera bez ikakvih informacija o ranjivom binarnom fajlu**.\
Ovaj napad se zasniva na sledećem scenariju:

- Ranjivost na steku i znanje o tome kako je aktivirati.
- Serverska aplikacija koja se ponovo pokreće nakon pada.

## Napad

### **1. Pronađi ranjivi offset** slanjem jednog dodatnog karaktera dok se ne otkrije kvar servera

### **2. Brute-force canary** da se otkrije

### **3. Brute-force sačuvanih RBP i RIP** adresa na steku da se otkriju

Možete pronaći više informacija o ovim procesima [ovde (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) i [ovde (BF Adrese na steku)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md).

### **4. Pronađi stop gadget**

Ovaj gadget u suštini omogućava potvrdu da je nešto zanimljivo izvršeno putem ROP gadgeta jer izvršenje nije srušeno. Obično, ovaj gadget će biti nešto što **zaustavlja izvršenje** i nalazi se na kraju ROP lanca kada se traže ROP gadgeti da se potvrdi da je specifičan ROP gadget izvršen.

### **5. Pronađi BROP gadget**

Ova tehnika koristi [**ret2csu**](ret2csu.md) gadget. I to je zato što, ako pristupite ovom gadgetu usred nekih instrukcija, dobijate gadgete za kontrolu **`rsi`** i **`rdi`**:

<figure><img src="../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Ovo bi bili gadgeti:

- `pop rsi; pop r15; ret`
- `pop rdi; ret`

Primetite kako je sa tim gadgetima moguće **kontrolisati 2 argumenta** funkcije koju pozivamo.

Takođe, primetite da ret2csu gadget ima **veoma jedinstvenu potpis** jer će iz steka izvući 6 registara. Dakle, slanjem lanca poput:

`'A' * offset + canary + rbp + ADDR + 0xdead * 6 + STOP`

Ako je **STOP izvršen**, to u suštini znači da je korišćena **adresa koja izbacuje 6 registara** iz steka. Ili da je korišćena adresa koja je takođe STOP adresa.

Da bi se **uklonila ova poslednja opcija**, izvršava se novi lanac poput sledećeg i ne sme izvršiti STOP gadget da potvrdi da je prethodni izbacivao 6 registara:

`'A' * offset + canary + rbp + ADDR`

Poznavajući adresu ret2csu gadgeta, moguće je **izvesti adresu gadgeta za kontrolu `rsi` i `rdi`**.

### 6. Pronađi PLT

PLT tabela može se pretraživati od 0x400000 ili od **otkrivene RIP adrese** sa steka (ako se koristi **PIE**). **Unosi** tabele su **odvojeni po 16B** (0x10B), i kada se pozove jedna funkcija, server se ne sruši čak i ako argumenti nisu tačni. Takođe, provera adrese jednog unosa u **PLT + 6B takođe ne sruši** jer je to prvi kod koji se izvršava.

Stoga, moguće je pronaći PLT tabelu proverom sledećih ponašanja:

- `'A' * offset + canary + rbp + ADDR + STOP` -> nema rušenja
- `'A' * offset + canary + rbp + (ADDR + 0x6) + STOP` -> nema rušenja
- `'A' * offset + canary + rbp + (ADDR + 0x10) + STOP` -> nema rušenja

### 7. Pronalazak strcmp

Funkcija **`strcmp`** postavlja registar **`rdx`** na dužinu stringa koji se upoređuje. Imajte na umu da je **`rdx`** **treći argument** i potrebno je da bude **veći od 0** kako bismo kasnije koristili `write` da otkrijemo program.

Moguće je pronaći lokaciju **`strcmp`** u PLT-u na osnovu njenog ponašanja koristeći činjenicu da sada možemo kontrolisati prva 2 argumenta funkcija:

- strcmp(\<non read addr>, \<non read addr>) -> rušenje
- strcmp(\<non read addr>, \<read addr>) -> rušenje
- strcmp(\<read addr>, \<non read addr>) -> rušenje
- strcmp(\<read addr>, \<read addr>) -> nema rušenja

Moguće je proveriti ovo pozivajući svaki unos PLT tabele ili koristeći **PLT spor put** koji se u suštini sastoji od **pozivanja unosa u PLT tabeli + 0xb** (što poziva **`dlresolve`**) praćeno na steku **brojem unosa koji se želi proveriti** (počinjajući od nule) da skeniramo sve PLT unose od prvog:

- strcmp(\<non read addr>, \<read addr>) -> rušenje
- `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP` -> Rušiće
- strcmp(\<read addr>, \<non read addr>) -> rušenje
- `b'A' * offset + canary + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`
- strcmp(\<read addr>, \<read addr>) -> nema rušenja
- `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`

Zapamtite da:

- BROP + 0x7 ukazuje na **`pop RSI; pop R15; ret;`**
- BROP + 0x9 ukazuje na **`pop RDI; ret;`**
- PLT + 0xb ukazuje na poziv **dl_resolve**.

Nakon što se pronađe `strcmp`, moguće je postaviti **`rdx`** na vrednost veću od 0.

> [!TIP]
> Imajte na umu da obično `rdx` već sadrži vrednost veću od 0, tako da ovaj korak možda nije neophodan.

### 8. Pronalazak Write ili ekvivalentnog

Na kraju, potreban je gadget koji eksfiltrira podatke kako bi se eksfiltrirao binarni fajl. I u ovom trenutku moguće je **kontrolisati 2 argumenta i postaviti `rdx` veći od 0.**

Postoje 3 uobičajene funkcije koje bi mogle biti zloupotrebljene za ovo:

- `puts(data)`
- `dprintf(fd, data)`
- `write(fd, data, len(data)`

Međutim, originalni rad pominje samo **`write`**, pa hajde da pričamo o tome:

Trenutni problem je što ne znamo **gde se funkcija write nalazi unutar PLT-a** i ne znamo **fd broj da pošaljemo podatke našem soketu**.

Međutim, znamo **gde se nalazi PLT tabela** i moguće je pronaći write na osnovu njenog **ponašanja**. I možemo stvoriti **nekoliko veza** sa serverom i koristiti **visok FD** nadajući se da će se poklopiti sa nekim od naših veza.

Potpis ponašanja za pronalaženje tih funkcija:

- `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> Ako se podaci ispisuju, onda je pronađen puts
- `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> Ako se podaci ispisuju, onda je pronađen dprintf
- `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP` -> Ako se podaci ispisuju, onda je pronađen write

## Automatska eksploatacija

- [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## Reference

- Originalni rad: [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
- [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)

{{#include ../../banners/hacktricks-training.md}}
