# ROP - Return Oriented Programing

{{#include ../../banners/hacktricks-training.md}}

## **Osnovne Informacije**

**Return-Oriented Programming (ROP)** je napredna tehnika eksploatacije koja se koristi za zaobilaženje sigurnosnih mera kao što su **No-Execute (NX)** ili **Data Execution Prevention (DEP)**. Umesto da se injektuje i izvršava shellcode, napadač koristi delove koda koji su već prisutni u binarnom fajlu ili u učitanim bibliotekama, poznatim kao **"gadgets"**. Svaki gadget obično se završava sa `ret` instrukcijom i izvršava malu operaciju, kao što je premestanje podataka između registara ili izvođenje aritmetičkih operacija. Povezivanjem ovih gadgets, napadač može konstruisati payload za izvođenje proizvoljnih operacija, efikasno zaobilazeći NX/DEP zaštite.

### Kako ROP Funkcioniše

1. **Otimaње Kontrole Tok**: Prvo, napadač treba da otme kontrolu toka programa, obično iskorišćavanjem buffer overflow-a da bi prepisao sačuvanu adresu povratka na steku.
2. **Povezivanje Gadgets**: Napadač pažljivo bira i povezuje gadgets da bi izvršio željene radnje. Ovo može uključivati postavljanje argumenata za poziv funkcije, pozivanje funkcije (npr., `system("/bin/sh")`), i rukovanje svim potrebnim čišćenjem ili dodatnim operacijama.
3. **Izvršenje Payload-a**: Kada ranjiva funkcija vrati, umesto da se vrati na legitimnu lokaciju, počinje da izvršava lanac gadgets.

### Alati

Obično se gadgets mogu pronaći koristeći [**ROPgadget**](https://github.com/JonathanSalwan/ROPgadget), [**ropper**](https://github.com/sashs/Ropper) ili direktno iz **pwntools** ([ROP](https://docs.pwntools.com/en/stable/rop/rop.html)).

## ROP Lanac u x86 Primeru

### **x86 (32-bit) Konvencije Poziva**

- **cdecl**: Pozivatelj čisti stek. Argumenti funkcije se stavljaju na stek u obrnutom redosledu (s desna na levo). **Argumenti se stavljaju na stek s desna na levo.**
- **stdcall**: Slično cdecl, ali je pozvana funkcija odgovorna za čišćenje steka.

### **Pronalaženje Gadgets**

Prvo, pretpostavimo da smo identifikovali potrebne gadgets unutar binarnog fajla ili njegovih učitanih biblioteka. Gadgets koji nas zanimaju su:

- `pop eax; ret`: Ovaj gadget uzima gornju vrednost steka u `EAX` registar i zatim se vraća, omogućavajući nam kontrolu nad `EAX`.
- `pop ebx; ret`: Slično prethodnom, ali za `EBX` registar, omogućavajući kontrolu nad `EBX`.
- `mov [ebx], eax; ret`: Premesti vrednost u `EAX` na memorijsku lokaciju na koju pokazuje `EBX` i zatim se vraća. Ovo se često naziva **write-what-where gadget**.
- Pored toga, imamo adresu funkcije `system()` dostupnu.

### **ROP Lanac**

Koristeći **pwntools**, pripremamo stek za izvršenje ROP lanca na sledeći način sa ciljem da izvršimo `system('/bin/sh')`, obratite pažnju kako lanac počinje sa:

1. `ret` instrukcijom za svrhe usklađivanja (opciono)
2. Adresom funkcije `system` (pretpostavljajući da je ASLR onemogućen i poznat libc, više informacija u [**Ret2lib**](ret2lib/))
3. Mesto za adresu povratka iz `system()`
4. Adresom stringa `"/bin/sh"` (parametar za funkciju system)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadc0de

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## ROP Chain in x64 Example

### **x64 (64-bit) Calling conventions**

- Koristi **System V AMD64 ABI** konvenciju poziva na Unix-like sistemima, gde se **prvih šest celobrojnih ili pokazivačkih argumenata prenosi u registrima `RDI`, `RSI`, `RDX`, `RCX`, `R8`, i `R9`**. Dodatni argumenti se prenose na steku. Vraćena vrednost se smešta u `RAX`.
- **Windows x64** konvencija poziva koristi `RCX`, `RDX`, `R8`, i `R9` za prva četiri celobrojna ili pokazivačka argumenta, dok se dodatni argumenti prenose na steku. Vraćena vrednost se smešta u `RAX`.
- **Registri**: 64-bitni registri uključuju `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP`, i `R8` do `R15`.

#### **Finding Gadgets**

Za naše potrebe, fokusiraćemo se na gadgete koji će nam omogućiti da postavimo **RDI** registar (da prenesemo **"/bin/sh"** string kao argument za **system()**) i zatim pozovemo **system()** funkciju. Pretpostavićemo da smo identifikovali sledeće gadgete:

- **pop rdi; ret**: Uzimanje gornje vrednosti steka u **RDI** i zatim vraćanje. Neophodno za postavljanje našeg argumenta za **system()**.
- **ret**: Jednostavno vraćanje, korisno za poravnavanje steka u nekim scenarijima.

I znamo adresu **system()** funkcije.

### **ROP Chain**

Ispod je primer korišćenja **pwntools** za postavljanje i izvršavanje ROP lanca koji ima za cilj da izvrši **system('/bin/sh')** na **x64**:
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
U ovom primeru:

- Koristimo **`pop rdi; ret`** gadget da postavimo **`RDI`** na adresu **`"/bin/sh"`**.
- Direktno skačemo na **`system()`** nakon postavljanja **`RDI`**, sa adresom **system()** u lancu.
- **`ret_gadget`** se koristi za poravnavanje ako ciljno okruženje to zahteva, što je češće u **x64** da bi se osiguralo pravilno poravnavanje steka pre pozivanja funkcija.

### Poravnavanje Steka

**x86-64 ABI** osigurava da je **stek poravnat na 16 bajtova** kada se izvrši **call instrukcija**. **LIBC**, radi optimizacije performansi, **koristi SSE instrukcije** (kao što je **movaps**) koje zahtevaju ovo poravnavanje. Ako stek nije pravilno poravnat (što znači da **RSP** nije višekratnik 16), pozivi funkcijama kao što je **system** će propasti u **ROP lancu**. Da biste to ispravili, jednostavno dodajte **ret gadget** pre pozivanja **system** u vašem ROP lancu.

## Glavna razlika između x86 i x64

> [!TIP]
> Pošto **x64 koristi registre za prvih nekoliko argumenata,** često zahteva manje gadgeta nego x86 za jednostavne pozive funkcija, ali pronalaženje i povezivanje pravih gadgeta može biti složenije zbog povećanog broja registara i većeg adresnog prostora. Povećan broj registara i veći adresni prostor u **x64** arhitekturi pružaju i prilike i izazove za razvoj eksploatacija, posebno u kontekstu Programiranja Orijentisanog na Povratak (ROP).

## ROP lanac u ARM64 primeru

### **Osnovne informacije o ARM64 i konvencije pozivanja**

Proverite sledeću stranicu za ove informacije:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md
{{#endref}}

## Zaštite protiv ROP

- [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **&** [**PIE**](../common-binary-protections-and-bypasses/pie/): Ove zaštite otežavaju korišćenje ROP-a jer se adrese gadgeta menjaju između izvršavanja.
- [**Stack Canaries**](../common-binary-protections-and-bypasses/stack-canaries/): U slučaju BOF-a, potrebno je zaobići skladištenje stack canary da bi se prepisali povratni pokazivači za zloupotrebu ROP lanca.
- **Nedostatak Gadgeta**: Ako nema dovoljno gadgeta, neće biti moguće generisati ROP lanac.

## Tehnike zasnovane na ROP-u

Imajte na umu da je ROP samo tehnika za izvršavanje proizvoljnog koda. Na osnovu ROP-a razvijene su mnoge Ret2XXX tehnike:

- **Ret2lib**: Koristi ROP za pozivanje proizvoljnih funkcija iz učitane biblioteke sa proizvoljnim parametrima (obično nešto poput `system('/bin/sh')`.

{{#ref}}
ret2lib/
{{#endref}}

- **Ret2Syscall**: Koristi ROP za pripremu poziva na syscall, npr. `execve`, i izvršava proizvoljne komande.

{{#ref}}
rop-syscall-execv/
{{#endref}}

- **EBP2Ret & EBP Chaining**: Prvi će zloupotrebiti EBP umesto EIP da kontroliše tok, a drugi je sličan Ret2lib, ali u ovom slučaju tok se kontroliše uglavnom sa EBP adresama (iako je takođe potrebno kontrolisati EIP).

{{#ref}}
../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md
{{#endref}}

## Ostali primeri i reference

- [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)
- [https://guyinatuxedo.github.io/15-partial_overwrite/hacklu15_stackstuff/index.html](https://guyinatuxedo.github.io/15-partial_overwrite/hacklu15_stackstuff/index.html)
- 64 bita, Pie i nx omogućeni, bez canary, prepisivanje RIP-a sa `vsyscall` adresom sa jedinom svrhom da se vrati na sledeću adresu u steku koja će biti delimično prepisivanje adrese da bi se dobila deo funkcije koja otkriva zastavicu
- [https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/](https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/)
- arm64, bez ASLR, ROP gadget za izvršavanje steka i skakanje na shellcode u steku

{{#include ../../banners/hacktricks-training.md}}
