# Crypto in Malware / Reverse Engineering

{{#include ../../banners/hacktricks-training.md}}

이 하위 섹션은 바이너리 내부에서 crypto/compression이 보일 때 이를 빠르게 인식하는 데 도움이 됩니다.

## Identifying cryptographic / compression algorithms

### Technique-first heuristics

- 타이트한 루프에서 많은 shifts/rotates, XORs, 및 32-bit arithmetic.
- `.data`에 있는 lookup tables (S-boxes) 또는 런타임에 생성되는 테이블.
- `0x100` 반복 루프가 반복되는 경우 RC4를 암시할 수 있음.

### Windows crypto/compression APIs

#### CryptDeriveKey / CryptCreateHash

이 함수들이 사용되면 두 번째 매개변수는 `ALG_ID`입니다:

![](<../../images/image (156).png>)

테이블: https://learn.microsoft.com/en-us/windows/win32/seccrypto/alg-id

#### RtlCompressBuffer / RtlDecompressBuffer

종종 내장 Windows 압축(LZNT1, XPRESS 등)을 나타냅니다.

### Constants & tables

때때로 상수(또는 테이블의 첫 dword)를 온라인에서 검색하여 hash/cipher를 지문화할 수 있습니다.

![](<../../images/image (833).png>)

AES tables 예시:

![](<../../images/image (531).png>)

### RC4 recognition notes

RC4는 보통 다음으로 인식됩니다:

- 256 반복의 두 루프 (init + KSA)
- 그 다음 `% 256`을 사용하고 keystream을 데이터와 XOR하는 PRGA 루프

## Unpacking binaries

### Technique

Packers는 바이너리를 변형하여 static analysis가 오도되게 만듭니다 (junk code, encrypted sections, runtime unpacking). 목표는 다음 순간을 포착하는 것입니다:

- 메모리에 실제 코드를 할당/복호화한다
- 이를 executable로 표시한다
- 그 코드로 점프한다

### Identifying packed binaries

- 문자열이 거의 없거나(또는 packer 문자열만 있음)
- 많은 문자열에 xrefs가 없음 (commercial packers)
- packer-ID 도구 사용:
  - PEiD
  - Exeinfo PE

### Basic recommendations

- 분석을 아래에서부터 위로 시작하세요; unpackers는 종종 늦게 점프합니다.
- `JMP/CALL reg` 패턴이나 스택 트릭(`push addr; retn`)을 찾아보세요.
- `VirtualAlloc`/`VirtualProtect`에 브레이크포인트를 걸고 RWX 영역을 추적하세요.
- 점프 이후 갑작스러운 문자열 폭증은 unpacked code에 도달했음을 나타내는 경우가 많습니다.
- 메모리를 덤프하고 PE-bear 같은 도구로 헤더를 수정하세요.

{{#include ../../banners/hacktricks-training.md}}
