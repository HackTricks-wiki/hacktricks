# Pentesting RFID

{{#include ../../banners/hacktricks-training.md}}

## 소개

**Radio Frequency Identification (RFID)** 는 가장 널리 사용되는 단거리 무선 솔루션이다. 일반적으로 엔티티를 식별하는 정보를 저장하고 전송하는 데 사용된다.

RFID 태그는 **its own power source (active)**(예: 내장 배터리)에 의존할 수 있거나, 리더 안테나로부터 수신된 전파에서 **induced from the received radio waves** 를 사용해 전원을 공급받는 (**passive**) 방식일 수 있다.

### Classes

EPCglobal은 RFID 태그를 여섯 가지 범주로 나눈다. 각 범주의 태그는 이전 범주에 나열된 모든 기능을 포함하므로 하위 호환된다.

- **Class 0** 태그는 **passive** 태그로 **UHF** 대역에서 동작한다. 제조 공장에서 벤더가 **preprograms** 한다. 결과적으로 메모리에 저장된 정보를 **변경할 수 없다**.
- **Class 1** 태그는 **HF** 대역에서도 동작할 수 있다. 또한 생산 후 **한 번만 쓸 수 있다**. 많은 Class 1 태그는 수신한 명령의 **cyclic redundancy checks**(CRCs)를 처리할 수도 있다. CRC는 에러 검출을 위한 명령 끝부분의 몇 바이트다.
- **Class 2** 태그는 **여러 번 기록할 수 있다**.
- **Class 3** 태그는 현재 온도나 태그의 동작과 같은 환경 변수를 기록할 수 있는 **embedded sensors** 를 포함할 수 있다. 이러한 태그는 **semi-passive** 인데, 내장된 전원(예: 통합 **battery**)은 있지만 무선 **communication** 을 다른 태그나 리더와 **initiate** 할 수는 없다.
- **Class 4** 태그는 동일 클래스의 다른 태그와 통신을 시작할 수 있어 **active tags** 가 된다.
- **Class 5** 태그는 **power to other tags and communicate with all the previous tag** 클래스들과 통신할 수 있다. Class 5 태그는 **RFID readers** 로 동작할 수 있다.

### RFID 태그에 저장되는 정보

RFID 태그의 메모리는 보통 네 가지 종류의 데이터를 저장한다: 태그가 부착된 엔티티를 **identifies** 하는 **identification data**(이 데이터에는 은행 계좌와 같은 사용자 정의 필드 포함); 엔티티에 대한 추가 정보를 제공하는 **supplementary data**; 태그의 내부 **configuration** 에 사용되는 **control data**; 그리고 태그의 Unique Identifier(**UID**)와 생산, 타입, 벤더에 관한 정보를 포함하는 **manufacturer data**. 상업용 태그에서는 첫 두 종류의 데이터를 모두 찾을 수 있고, 마지막 두 종류는 태그 벤더에 따라 다를 수 있다.

ISO 표준은 태그가 속한 **kind of object** 를 나타내는 코드인 Application Family Identifier(**AFI**) 값을 명시한다. ISO에서 규정한 또 다른 중요한 레지스터로는 사용자 데이터의 **logical organization** 을 정의하는 Data Storage Format Identifier(**DSFID**)가 있다.

대부분의 RFID **security controls** 는 각 사용자 메모리 블록과 AFI 및 DSFID 값을 포함하는 특별 레지스터에 대한 **read** 또는 **write** 연산을 **restrict** 하는 메커니즘을 가지고 있다. 이러한 **lock mechanisms** 은 제어 메모리에 저장된 데이터를 사용하며 벤더가 사전 구성한 **default passwords** 를 가지고 있지만 태그 소유자가 **custom passwords** 를 구성할 수 있도록 허용한다.

### Low & High frequency tags 비교

<figure><img src="../../images/image (983).png" alt=""><figcaption></figcaption></figure>

## Low-Frequency RFID Tags (125kHz)

**Low-frequency tags** 는 보통 **high security** 를 요구하지 않는 시스템에서 자주 사용된다: 건물 출입, 인터폰 키, 헬스장 멤버십 카드 등. 더 긴 범위 때문에 유료 주차 시스템에 편리하게 쓰이기도 한다: 운전자가 카드나 태그를 리더에 가까이 대지 않아도 멀리서 트리거된다. 동시에 low-frequency 태그는 매우 원시적이고 낮은 데이터 전송 속도를 가진다. 따라서 잔액 관리나 암호화 같은 복잡한 양방향 데이터 전송을 구현하는 것은 불가능하다. Low-frequency 태그는 인증 수단 없이 짧은 ID만 전송한다.

이 장치들은 **passive RFID** 기술에 의존하며 **30 kHz ~ 300 kHz** 범위에서 동작하지만 보통은 **125 kHz ~ 134 kHz** 를 사용한다:

- **Long Range** — 낮은 주파수는 더 긴 범위를 의미한다. EM-Marin 및 HID 리더와 같이 약 1미터 거리까지 동작하는 제품들이 있다. 이러한 제품은 주차장에 자주 사용된다.
- **Primitive protocol** — 낮은 데이터 전송률 때문에 이 태그들은 짧은 ID만 전송할 수 있다. 대부분의 경우 데이터는 인증되지 않으며 어떠한 방식으로도 보호되지 않는다. 카드가 리더의 범위 안에 들어오면 단순히 ID를 전송하기 시작한다.
- **Low security** — 이 카드들은 프로토콜의 단순성 때문에 쉽게 복제되거나, 심지어 다른 사람의 주머니에서 읽힐 수도 있다.

**Popular 125 kHz protocols:**

- **EM-Marin** — EM4100, EM4102. CIS 지역에서 가장 인기 있는 프로토콜. 단순성과 안정성 때문에 약 1미터 거리에서 읽을 수 있다.
- **HID Prox II** — HID Global에서 도입한 low-frequency 프로토콜. 서구권에서 더 인기가 있다. 더 복잡하며 이 프로토콜 용 카드와 리더는 비교적 비싸다.
- **Indala** — Motorola가 도입했고 이후 HID가 인수한 매우 오래된 low-frequency 프로토콜. 이전 두 프로토콜에 비해 사용 빈도는 떨어지고 있다.

실제로는 더 많은 low-frequency 프로토콜이 존재하지만 모두 물리 계층에서 동일한 변조를 사용하며 위에 열거된 프로토콜들의 변형으로 볼 수 있다.

### 공격

이 태그들은 Flipper Zero로 **attack** 할 수 있다:


{{#ref}}
flipper-zero/fz-125khz-rfid.md
{{#endref}}

## High-Frequency RFID Tags (13.56 MHz)

**High-frequency tags** 는 cryptography, 대용량 양방향 데이터 전송, 인증 등이 필요할 때 리더-태그 간 더 복잡한 상호작용을 위해 사용된다.\
은행 카드, 대중교통, 기타 보안 패스에서 주로 볼 수 있다.

**High-frequency 13.56 MHz tags are a set of standards and protocols**. 이들은 보통 [NFC](https://nfc-forum.org/what-is-nfc/about-the-technology/) 라고 불리지만 항상 정확한 명칭은 아니다. 물리 및 논리 수준에서 사용되는 기본 프로토콜 세트는 ISO 14443 이다. 고수준 프로토콜과 대체 표준(예: ISO 19092)은 이것을 기반으로 한다. 많은 사람이 이 기술을 13.56 MHz 대역에서 동작하는 장치들을 가리키는 용어인 **Near Field Communication (NFC)** 으로 부른다.

<figure><img src="../../images/image (930).png" alt=""><figcaption></figcaption></figure>

간단히 말해, NFC의 아키텍처는 다음과 같다: 전송 프로토콜은 카드를 만드는 회사가 선택하고 낮은 수준의 ISO 14443에 기반해 구현된다. 예를 들어 NXP는 Mifare라는 자체 고수준 전송 프로토콜을 발명했다. 그러나 낮은 수준에서는 Mifare 카드는 ISO 14443-A 표준을 기반으로 한다.

Flipper는 낮은 수준의 ISO 14443 프로토콜뿐 아니라 Mifare Ultralight 데이터 전송 프로토콜과 은행 카드에서 사용되는 EMV와도 상호작용할 수 있다. 우리는 Mifare Classic 및 NFC NDEF에 대한 지원 추가 작업을 진행 중이다. NFC를 구성하는 프로토콜과 표준을 철저히 살펴보는 것은 별도의 글이 필요하며 추후 공개할 예정이다.

ISO 14443-A 표준을 기반으로 하는 모든 고주파 카드에는 고유한 칩 ID가 있다. 이는 네트워크 카드의 MAC 주소처럼 카드의 시리얼 번호 역할을 한다. **보통 UID는 4 또는 7 바이트 길이** 이지만 드물게 **최대 10 바이트** 까지 올 수 있다. UID는 비밀이 아니며 쉽게 읽을 수 있고, **때로는 카드 자체에 인쇄되어 있기도 하다**.

많은 출입 통제 시스템이 UID에 의존해 **authenticate and grant access** 한다. 때로는 RFID 태그가 **cryptography** 를 지원하더라도 이런 방식이 사용된다. 이러한 **misuse** 는 보안 측면에서 해당 시스템을 단순한 **125 kHz 카드** 수준으로 떨어뜨린다. Virtual cards(예: Apple Pay)는 동적 UID를 사용하여 전화 소유자가 결제 앱으로 문을 열지 못하도록 한다.

- **Low range** — 고주파 카드는 리더에 가깝게 배치해야 하도록 설계되어 있다. 이것은 무단 상호작용으로부터 카드를 보호하는 데 도움이 된다. 우리가 달성한 최대 읽기 범위는 약 15 cm였으며, 이는 맞춤형 고범위 리더를 사용했을 때였다.
- **Advanced protocols** — 최대 424 kbps의 데이터 전송 속도는 완전한 양방향 데이터 전송이 가능한 복잡한 프로토콜을 허용한다. 이는 결과적으로 **cryptography**, 데이터 전송 등 을 가능하게 한다.
- **High security** — 고주파 비접촉 카드들은 스마트 카드에 전혀 뒤지지 않는다. AES와 같은 강력한 암호 알고리즘을 지원하고 비대칭 암호화를 구현하는 카드들도 있다.

### 공격

이 태그들은 Flipper Zero로 **attack** 할 수 있다:


{{#ref}}
flipper-zero/fz-nfc.md
{{#endref}}

또는 **proxmark** 를 사용하여:


{{#ref}}
proxmark-3.md
{{#endref}}

### MiFare Classic offline stored-value tampering (broken Crypto1)

시스템이 MiFare Classic 카드에 직접 금전 잔액을 저장하는 경우, Classic은 NXP의 더 이상 사용되지 않는 Crypto1 암호를 사용하므로 종종 조작할 수 있다. Crypto1은 수년 전부터 깨져 있었고, sector keys 복구와 카드 메모리의 완전한 읽기/쓰기가 commodity 하드웨어(예: Proxmark3)로 가능하다.

End-to-end workflow (abstracted):

1) 원본 카드를 덤프하고 키를 복구한다
```bash
# Attempt all built-in Classic key recovery attacks and dump the card
hf mf autopwn
```
This typically recovers sector keys (A/B) and generates a full-card dump in the client dumps folder.

2) 값/무결성 필드 찾기 및 이해

- 원본 카드에 정상적인 top-ups를 수행하고 여러 번의 dumps(이전/이후)를 찍는다.
- 두 dumps의 diff를 수행하여 잔액과 무결성 필드를 나타내는 변경되는 블록/바이트를 식별한다.
- 많은 Classic 배포판은 네이티브 "value block" 인코딩을 사용하거나 자체 checksums(예: 잔액을 다른 필드와 상수로 XOR)을 구현한다. 잔액을 변경한 후에는 무결성 바이트를 재계산하고, 복제/보수된 모든 필드가 일관되도록 확인한다.

3) 수정된 dump를 쓰기 가능한 “Chinese magic” Classic 태그에 기록한다
```bash
# Load a modified binary dump onto a UID-changeable Classic tag
hf mf cload -f modified.bin
```
4) 원본 UID를 Clone하여 터미널이 카드를 인식하도록
```bash
# Set the UID on a UID-changeable tag (gen1a/gen2 magic)
hf mf csetuid -u <original_uid>
```
5) 단말기에서 사용

카드 내 잔액과 UID를 신뢰하는 리더는 조작된 카드를 수용한다. 현장 관찰 결과 많은 배포 환경에서 필드 폭을 기준으로 잔액을 한계값으로 제한하는 경우가 있다(예: 16-bit fixed-point).

Notes

- 시스템이 native Classic value blocks를 사용한다면 형식을 기억하라: value (4B) + ~value (4B) + value (4B) + block address + ~address. 모든 부분이 일치해야 한다.
- 간단한 체크섬을 사용하는 커스텀 포맷의 경우, differential analysis가 펌웨어를 리버스하지 않고 무결성 함수를 도출하는 가장 빠른 방법이다.
- block 0/UID 쓰기가 가능한 것은 UID 변경 가능한 태그("Chinese magic" gen1a/gen2)뿐이다. 일반 Classic 카드는 읽기 전용 UID를 가진다.

실습용 Proxmark3 명령어는 다음을 참조:

{{#ref}}
proxmark-3.md
{{#endref}}

### 휴대용 HID MaxiProx 125 kHz 모바일 클로너 제작

레드팀 활동 중 HID Prox® 배지를 수집하기 위해 **장거리**, **배터리 구동** 솔루션이 필요하다면 벽걸이형 **HID MaxiProx 5375** 리더를 배낭에 들어가는 독립형 클로너로 개조할 수 있다. 전체 기계적 및 전기적 실무 안내는 다음에서 확인할 수 있다:

{{#ref}}
maxiprox-mobile-cloner.md
{{#endref}}

---

## 참고자료

- [https://blog.flipperzero.one/rfid/](https://blog.flipperzero.one/rfid/)
- [Let's Clone a Cloner – Part 3 (TrustedSec)](https://trustedsec.com/blog/lets-clone-a-cloner-part-3-putting-it-all-together)
- [NXP statement on MIFARE Classic Crypto1](https://www.mifare.net/en/products/chip-card-ics/mifare-classic/security-statement-on-crypto1-implementations/)
- [MIFARE security overview (Wikipedia)](https://en.wikipedia.org/wiki/MIFARE#Security)
- [NFC card vulnerability exploitation in KioSoft Stored Value (SEC Consult)](https://sec-consult.com/vulnerability-lab/advisory/nfc-card-vulnerability-exploitation-leading-to-free-top-up-kiosoft-payment-solution/)

{{#include ../../banners/hacktricks-training.md}}
