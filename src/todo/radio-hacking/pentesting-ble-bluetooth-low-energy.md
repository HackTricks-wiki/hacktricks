# Pentesting BLE - Bluetooth Low Energy

{{#include ../../banners/hacktricks-training.md}}

## Introduction

Available since the Bluetooth 4.0 specification, BLE uses only 40 channels, covering the range of 2400 to 2483.5 MHz. In contrast, traditional Bluetooth uses 79 channels in that same range.

BLE devices communicate is by sending **advertising packets** (**beacons**), these packets broadcast the BLE device’s existence to other nearby devices. These beacons sometimes **send data**, too.

The listening device, also called a central device, can respond to an advertising packet with a **SCAN request** sent specifically to the advertising device. The **response** to that scan uses the same structure as the **advertising** packet with additional information that couldn’t fit on the initial advertising request, such as the full device name.

![](<../../images/image (152).png>)

The preamble byte synchronizes the frequency, whereas the four-byte access address is a **connection identifier**, which is used in scenarios where multiple devices are trying to establish connections on the same channels. Next, the Protocol Data Unit (**PDU**) contains the **advertising data**. There are several types of PDU; the most commonly used are ADV_NONCONN_IND and ADV_IND. Devices use the **ADV_NONCONN_IND** PDU type if they **don’t accept connections**, transmitting data only in the advertising packet. Devices use **ADV_IND** if they **allow connections** and **stop sending advertising** packets once a **connection** has been **established**.

### GATT

The **Generic Attribute Profile** (GATT) defines how the **device should format and transfer data**. When you’re analyzing a BLE device’s attack surface, you’ll often concentrate your attention on the GATT (or GATTs), because it’s how **device functionality gets triggered** and how data gets stored, grouped, and modified. The GATT lists a device’s characteristics, descriptors, and services in a table as either 16- or 32-bits values. A **characteristic** is a **data** value **sent** between the central device and peripheral. These characteristics can have **descriptors** that **provide additional information about them**. **Characteristics** are often **grouped** in **services** if they’re related to performing a particular action.

## Enumeration

```bash
hciconfig #Check config, check if UP or DOWN
# If DOWN try:
sudo modprobe -c bluetooth
sudo hciconfig hci0 down && sudo hciconfig hci0 up

# Spoof MAC
spooftooph -i hci0 -a 11:22:33:44:55:66
```

### GATTool

**GATTool** allows to **establish** a **connection** with another device, listing that device’s **characteristics**, and reading and writing its attributes.\
GATTTool can launch an interactive shell with the `-I` option:

```bash
gatttool -i hci0 -I
[ ][LE]> connect 24:62:AB:B1:A8:3E Attempting to connect to A4:CF:12:6C:B3:76 Connection successful
[A4:CF:12:6C:B3:76][LE]> characteristics
  handle: 0x0002, char properties: 0x20, char value handle:
  0x0003, uuid: 00002a05-0000-1000-8000-00805f9b34fb
  handle: 0x0015, char properties: 0x02, char value handle:
  0x0016, uuid: 00002a00-0000-1000-8000-00805f9b34fb
[...]

# Write data
gatttool -i <Bluetooth adapter interface> -b <MAC address of device> --char-write-req <characteristic handle> -n <value>
gatttool -b a4:cf:12:6c:b3:76 --char-write-req -a 0x002e -n $(echo -n "04dc54d9053b4307680a"|xxd -ps)

# Read data
gatttool -i <Bluetooth adapter interface> -b <MAC address of device> --char-read -a 0x16

# Read connecting with an authenticated encrypted connection
gatttool --sec-level=high -b a4:cf:12:6c:b3:76 --char-read -a 0x002c
```

### Bettercap

```bash
# Start listening for beacons
sudo bettercap --eval "ble.recon on"
# Wait some time
>> ble.show # Show discovered devices
>> ble.enum <mac addr> # This will show the service, characteristics and properties supported

# Write data in a characteristic
>> ble.write <MAC ADDR> <UUID> <HEX DATA>
>> ble.write <mac address of device> ff06 68656c6c6f # Write "hello" in ff06
```

## Traffic-led GATT Mapping via Android BTsnoop + Wireshark

When a companion Android app exists, you can capture its BLE control traffic for free and directly recover the exact handle and payload used to trigger actions.

- Enable Developer Options on Android. If needed, enable the Bluetooth HCI snoop log in Developer options.
- Connect the phone to your Linux host via USB and authorize ADB.
- Open Wireshark and select the phone’s Bluetooth HCI/BTsnoop capture interface. Start capture.
- In the vendor app, perform the action you care about (e.g., press “Alarm on”, then “off”).
- Filter writes in Wireshark with:

```text
_ws.col.info contains "Write Command"
```

Example: iSearching-compatible key-finders write a single byte to the Alert Level characteristic under Immediate Alert:

- Service UUID: 00001802-0000-1000-8000-00805f9b34fb (Immediate Alert)
- Characteristic UUID: 00002a06-0000-1000-8000-00805f9b34fb (Alert Level)
- Payloads: 0x01 = alarm on, 0x00 = alarm off
- Handles observed: 0x0b in Wireshark; some tools enumerate as ~0x000a (off-by-one view)

This gives you the exact handle and byte(s) to replay without needing the vendor app.

## APK-Assisted UUID Discovery (jadx)

If packet capture is noisy or ambiguous, quickly decompile the APK with jadx and search by feature keywords (e.g., “Alarm”). Trace UI onClick handlers that toggle the feature and look for BLE writes such as setValue(byte[]) being fed via a map lookup (e.g., bleWrireCharacterMap.get(key)). Often there is a single put() that inserts the static characteristic UUID. For these tags it resolves to 00002a06… (Alert Level), confirming what you saw on-wire.

Useful when you want to correlate app UI → characteristic UUIDs and expected payload format.

## Replaying Control from Linux

### Discover target and prepare adapter

```bash
sudo systemctl start bluetooth
sudo hcitool dev
sudo hcitool -i hci0 lescan   # find MAC, e.g., 5B:B1:7F:47:A7:00
```

Adapter notes: built-ins sometimes work; CSR USB dongles are reliable; many BT5.x USB dongles also work fine on modern Linux.

### Option A — gatttool (deprecated but still useful)

```bash
# Alarm ON
gatttool -i hci0 -b 5B:B1:7F:47:A7:00 --char-write-req --handle 0x0b --value 0x01
# Alarm OFF
gatttool -i hci0 -b 5B:B1:7F:47:A7:00 --char-write-req --handle 0x0b --value 0x00
```

Troubleshooting seen on Kali/Ubuntu:

- Connection refused (111) on connect or interactive mode hang. Rebooting or resetting the adapter often fixes flaky BLE connection state.
- Despite deprecation, gatttool can still reliably write when it connects.

### Option B — bluetoothctl (actively maintained)

```text
bluetoothctl
[bluetooth]# scan le
[bluetooth]# connect 5B:B1:7F:47:A7:00
[iTAG]# menu gatt
[iTAG]# list-attributes    # shows Immediate Alert (0x1802) and Alert Level (0x2a06)
[iTAG]# select-attribute 00002a06-0000-1000-8000-00805f9b34fb
[iTAG:/service0009/char000a]# write data=0x01   # start alarm
```

Notes:

- bluetoothctl may display the characteristic at handle 0x000a while Wireshark showed handle 0x0b. Toolchains list attributes slightly differently; use either UUID or handle per tool.
- You may see “Invalid value at index 0 Attempting to write …” yet the write still succeeds.
- Turning the alarm off with 0x00 can be less reliable in bluetoothctl than gatttool on some setups.

## Controlling Directly from Android (No Coding)

For quick manual testing, use LightBlue or nRF Connect:

- Scan → connect → open Immediate Alert (service 0x1802)
- Select Alert Level (characteristic 0x2a06)
- “Write new value” with 0x01 to beep and 0x00 to stop

This is simple, free, and highly reliable for manual checks.

## What to Test (Impact)

Many BLE products expose writable control characteristics without pairing/bonding or link encryption. That can enable unauthorized control or nuisance/DoS from anyone in RF range.

During assessments, verify whether:

- Pairing/bonding is required before control writes
- Link encryption is enforced
- Attribute-level permissions are required before writes to control characteristics

If not, an attacker nearby can replicate observed commands.

## Key Values and Identifiers (Example)

- Service UUID (Immediate Alert): 00001802-0000-1000-8000-00805f9b34fb
- Characteristic UUID (Alert Level): 00002a06-0000-1000-8000-00805f9b34fb
- Handles observed: 0x0b (Wireshark) vs ~0x000a (bluetoothctl)
- Payloads: 0x01 = alarm on; 0x00 = alarm off

## References

- [Start hacking Bluetooth Low Energy today! (part 1)](https://www.pentestpartners.com/security-blog/start-hacking-bluetooth-low-energy-today-part-1/)
- [Introduction to Bluetooth Low Energy](https://www.pentestpartners.com/security-blog/introduction-to-bluetooth-low-energy/)
- [How to root an Android device for analysis and vulnerability assessment](https://www.pentestpartners.com/security-blog/how-to-root-an-android-device-for-analysis-and-vulnerability-assessment/)
- [Arch Wiki: Bluetooth](https://wiki.archlinux.org/title/Bluetooth#Troubleshooting)

{{#include ../../banners/hacktricks-training.md}}