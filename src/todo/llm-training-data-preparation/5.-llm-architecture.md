# 5. LLM Architecture

## LLM Architecture

> [!TIP]
> 이 다섯 번째 단계의 목표는 매우 간단합니다: **전체 LLM의 아키텍처를 개발하는 것**입니다. 모든 것을 결합하고, 모든 레이어를 적용하며, 텍스트를 생성하거나 텍스트를 ID로 변환하고 다시 변환하는 모든 기능을 만듭니다.
>
> 이 아키텍처는 훈련 후 텍스트를 훈련하고 예측하는 데 사용됩니다.

LLM 아키텍처 예시는 [https://github.com/rasbt/LLMs-from-scratch/blob/main/ch04/01_main-chapter-code/ch04.ipynb](https://github.com/rasbt/LLMs-from-scratch/blob/main/ch04/01_main-chapter-code/ch04.ipynb)에서 확인할 수 있습니다:

높은 수준의 표현은 다음에서 관찰할 수 있습니다:

<figure><img src="../../images/image (3) (1) (1) (1).png" alt="" width="563"><figcaption><p><a href="https://camo.githubusercontent.com/6c8c392f72d5b9e86c94aeb9470beab435b888d24135926f1746eb88e0cc18fb/68747470733a2f2f73656261737469616e72617363686b612e636f6d2f696d616765732f4c4c4d732d66726f6d2d736372617463682d696d616765732f636830345f636f6d707265737365642f31332e776562703f31">https://camo.githubusercontent.com/6c8c392f72d5b9e86c94aeb9470beab435b888d24135926f1746eb88e0cc18fb/68747470733a2f2f73656261737469616e72617363686b612e636f6d2f696d616765732f4c4c4d732d66726f6d2d736372617463682d696d616765732f636830345f636f6d707265737365642f31332e776562703f31</a></p></figcaption></figure>

1. **Input (Tokenized Text)**: 프로세스는 토큰화된 텍스트로 시작되며, 이는 숫자 표현으로 변환됩니다.
2. **Token Embedding and Positional Embedding Layer**: 토큰화된 텍스트는 **토큰 임베딩** 레이어와 **위치 임베딩 레이어**를 통과하여, 시퀀스에서 토큰의 위치를 캡처합니다. 이는 단어 순서를 이해하는 데 중요합니다.
3. **Transformer Blocks**: 모델은 **12개의 트랜스포머 블록**을 포함하며, 각 블록은 여러 레이어로 구성됩니다. 이 블록은 다음 시퀀스를 반복합니다:
- **Masked Multi-Head Attention**: 모델이 입력 텍스트의 다양한 부분에 동시에 집중할 수 있게 합니다.
- **Layer Normalization**: 훈련을 안정화하고 개선하기 위한 정규화 단계입니다.
- **Feed Forward Layer**: 주의 레이어에서 정보를 처리하고 다음 토큰에 대한 예측을 수행하는 역할을 합니다.
- **Dropout Layers**: 이 레이어는 훈련 중 무작위로 유닛을 드롭하여 과적합을 방지합니다.
4. **Final Output Layer**: 모델은 **4x50,257 차원의 텐서**를 출력하며, 여기서 **50,257**은 어휘의 크기를 나타냅니다. 이 텐서의 각 행은 모델이 시퀀스에서 다음 단어를 예측하는 데 사용하는 벡터에 해당합니다.
5. **Goal**: 목표는 이러한 임베딩을 가져와 다시 텍스트로 변환하는 것입니다. 구체적으로, 출력의 마지막 행은 이 다이어그램에서 "forward"로 표시된 다음 단어를 생성하는 데 사용됩니다.

### Code representation
```python
import torch
import torch.nn as nn
import tiktoken

class GELU(nn.Module):
def __init__(self):
super().__init__()

def forward(self, x):
return 0.5 * x * (1 + torch.tanh(
torch.sqrt(torch.tensor(2.0 / torch.pi)) *
(x + 0.044715 * torch.pow(x, 3))
))

class FeedForward(nn.Module):
def __init__(self, cfg):
super().__init__()
self.layers = nn.Sequential(
nn.Linear(cfg["emb_dim"], 4 * cfg["emb_dim"]),
GELU(),
nn.Linear(4 * cfg["emb_dim"], cfg["emb_dim"]),
)

def forward(self, x):
return self.layers(x)

class MultiHeadAttention(nn.Module):
def __init__(self, d_in, d_out, context_length, dropout, num_heads, qkv_bias=False):
super().__init__()
assert d_out % num_heads == 0, "d_out must be divisible by num_heads"

self.d_out = d_out
self.num_heads = num_heads
self.head_dim = d_out // num_heads # Reduce the projection dim to match desired output dim

self.W_query = nn.Linear(d_in, d_out, bias=qkv_bias)
self.W_key = nn.Linear(d_in, d_out, bias=qkv_bias)
self.W_value = nn.Linear(d_in, d_out, bias=qkv_bias)
self.out_proj = nn.Linear(d_out, d_out)  # Linear layer to combine head outputs
self.dropout = nn.Dropout(dropout)
self.register_buffer('mask', torch.triu(torch.ones(context_length, context_length), diagonal=1))

def forward(self, x):
b, num_tokens, d_in = x.shape

keys = self.W_key(x) # Shape: (b, num_tokens, d_out)
queries = self.W_query(x)
values = self.W_value(x)

# We implicitly split the matrix by adding a `num_heads` dimension
# Unroll last dim: (b, num_tokens, d_out) -> (b, num_tokens, num_heads, head_dim)
keys = keys.view(b, num_tokens, self.num_heads, self.head_dim)
values = values.view(b, num_tokens, self.num_heads, self.head_dim)
queries = queries.view(b, num_tokens, self.num_heads, self.head_dim)

# Transpose: (b, num_tokens, num_heads, head_dim) -> (b, num_heads, num_tokens, head_dim)
keys = keys.transpose(1, 2)
queries = queries.transpose(1, 2)
values = values.transpose(1, 2)

# Compute scaled dot-product attention (aka self-attention) with a causal mask
attn_scores = queries @ keys.transpose(2, 3)  # Dot product for each head

# Original mask truncated to the number of tokens and converted to boolean
mask_bool = self.mask.bool()[:num_tokens, :num_tokens]

# Use the mask to fill attention scores
attn_scores.masked_fill_(mask_bool, -torch.inf)

attn_weights = torch.softmax(attn_scores / keys.shape[-1]**0.5, dim=-1)
attn_weights = self.dropout(attn_weights)

# Shape: (b, num_tokens, num_heads, head_dim)
context_vec = (attn_weights @ values).transpose(1, 2)

# Combine heads, where self.d_out = self.num_heads * self.head_dim
context_vec = context_vec.contiguous().view(b, num_tokens, self.d_out)
context_vec = self.out_proj(context_vec) # optional projection

return context_vec

class LayerNorm(nn.Module):
def __init__(self, emb_dim):
super().__init__()
self.eps = 1e-5
self.scale = nn.Parameter(torch.ones(emb_dim))
self.shift = nn.Parameter(torch.zeros(emb_dim))

def forward(self, x):
mean = x.mean(dim=-1, keepdim=True)
var = x.var(dim=-1, keepdim=True, unbiased=False)
norm_x = (x - mean) / torch.sqrt(var + self.eps)
return self.scale * norm_x + self.shift

class TransformerBlock(nn.Module):
def __init__(self, cfg):
super().__init__()
self.att = MultiHeadAttention(
d_in=cfg["emb_dim"],
d_out=cfg["emb_dim"],
context_length=cfg["context_length"],
num_heads=cfg["n_heads"],
dropout=cfg["drop_rate"],
qkv_bias=cfg["qkv_bias"])
self.ff = FeedForward(cfg)
self.norm1 = LayerNorm(cfg["emb_dim"])
self.norm2 = LayerNorm(cfg["emb_dim"])
self.drop_shortcut = nn.Dropout(cfg["drop_rate"])

def forward(self, x):
# Shortcut connection for attention block
shortcut = x
x = self.norm1(x)
x = self.att(x)  # Shape [batch_size, num_tokens, emb_size]
x = self.drop_shortcut(x)
x = x + shortcut  # Add the original input back

# Shortcut connection for feed forward block
shortcut = x
x = self.norm2(x)
x = self.ff(x)
x = self.drop_shortcut(x)
x = x + shortcut  # Add the original input back

return x


class GPTModel(nn.Module):
def __init__(self, cfg):
super().__init__()
self.tok_emb = nn.Embedding(cfg["vocab_size"], cfg["emb_dim"])
self.pos_emb = nn.Embedding(cfg["context_length"], cfg["emb_dim"])
self.drop_emb = nn.Dropout(cfg["drop_rate"])

self.trf_blocks = nn.Sequential(
*[TransformerBlock(cfg) for _ in range(cfg["n_layers"])])

self.final_norm = LayerNorm(cfg["emb_dim"])
self.out_head = nn.Linear(
cfg["emb_dim"], cfg["vocab_size"], bias=False
)

def forward(self, in_idx):
batch_size, seq_len = in_idx.shape
tok_embeds = self.tok_emb(in_idx)
pos_embeds = self.pos_emb(torch.arange(seq_len, device=in_idx.device))
x = tok_embeds + pos_embeds  # Shape [batch_size, num_tokens, emb_size]
x = self.drop_emb(x)
x = self.trf_blocks(x)
x = self.final_norm(x)
logits = self.out_head(x)
return logits

GPT_CONFIG_124M = {
"vocab_size": 50257,    # Vocabulary size
"context_length": 1024, # Context length
"emb_dim": 768,         # Embedding dimension
"n_heads": 12,          # Number of attention heads
"n_layers": 12,         # Number of layers
"drop_rate": 0.1,       # Dropout rate
"qkv_bias": False       # Query-Key-Value bias
}

torch.manual_seed(123)
model = GPTModel(GPT_CONFIG_124M)
out = model(batch)
print("Input batch:\n", batch)
print("\nOutput shape:", out.shape)
print(out)
```
### **GELU 활성화 함수**
```python
# From https://github.com/rasbt/LLMs-from-scratch/tree/main/ch04
class GELU(nn.Module):
def __init__(self):
super().__init__()

def forward(self, x):
return 0.5 * x * (1 + torch.tanh(
torch.sqrt(torch.tensor(2.0 / torch.pi)) *
(x + 0.044715 * torch.pow(x, 3))
))
```
#### **목적 및 기능**

- **GELU (가우시안 오류 선형 단위):** 모델에 비선형성을 도입하는 활성화 함수입니다.
- **부드러운 활성화:** 음수 입력을 0으로 만드는 ReLU와 달리, GELU는 입력을 출력으로 부드럽게 매핑하여 음수 입력에 대해 작은 비영 값도 허용합니다.
- **수학적 정의:**

<figure><img src="../../images/image (2) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

> [!NOTE]
> FeedForward 레이어 내의 선형 레이어 뒤에서 이 함수를 사용하는 목적은 선형 데이터를 비선형으로 변경하여 모델이 복잡하고 비선형적인 관계를 학습할 수 있도록 하는 것입니다.

### **FeedForward 신경망**

_행렬의 형태를 더 잘 이해하기 위해 주석으로 형태가 추가되었습니다:_
```python
# From https://github.com/rasbt/LLMs-from-scratch/tree/main/ch04
class FeedForward(nn.Module):
def __init__(self, cfg):
super().__init__()
self.layers = nn.Sequential(
nn.Linear(cfg["emb_dim"], 4 * cfg["emb_dim"]),
GELU(),
nn.Linear(4 * cfg["emb_dim"], cfg["emb_dim"]),
)

def forward(self, x):
# x shape: (batch_size, seq_len, emb_dim)

x = self.layers[0](x)# x shape: (batch_size, seq_len, 4 * emb_dim)
x = self.layers[1](x) # x shape remains: (batch_size, seq_len, 4 * emb_dim)
x = self.layers[2](x) # x shape: (batch_size, seq_len, emb_dim)
return x  # Output shape: (batch_size, seq_len, emb_dim)
```
#### **목적 및 기능**

- **위치별 FeedForward 네트워크:** 각 위치에 대해 별도로 동일하게 두 개의 완전 연결 네트워크를 적용합니다.
- **레이어 세부사항:**
- **첫 번째 선형 레이어:** 차원을 `emb_dim`에서 `4 * emb_dim`으로 확장합니다.
- **GELU 활성화:** 비선형성을 적용합니다.
- **두 번째 선형 레이어:** 차원을 다시 `emb_dim`으로 줄입니다.

> [!NOTE]
> 보시다시피, Feed Forward 네트워크는 3개의 레이어를 사용합니다. 첫 번째는 선형 레이어로, 선형 가중치(모델 내부에서 훈련할 매개변수)를 사용하여 차원을 4배로 곱합니다. 그런 다음, GELU 함수가 모든 차원에서 비선형 변화를 적용하여 더 풍부한 표현을 캡처하고, 마지막으로 또 다른 선형 레이어가 원래 차원 크기로 되돌립니다.

### **다중 헤드 주의 메커니즘**

이것은 이전 섹션에서 이미 설명되었습니다.

#### **목적 및 기능**

- **다중 헤드 자기 주의:** 모델이 토큰을 인코딩할 때 입력 시퀀스 내의 다양한 위치에 집중할 수 있게 합니다.
- **주요 구성 요소:**
- **쿼리, 키, 값:** 입력의 선형 프로젝션으로, 주의 점수를 계산하는 데 사용됩니다.
- **헤드:** 병렬로 실행되는 여러 주의 메커니즘(`num_heads`), 각 헤드는 축소된 차원(`head_dim`)을 가집니다.
- **주의 점수:** 쿼리와 키의 내적을 계산하여 스케일링 및 마스킹합니다.
- **마스킹:** 미래의 토큰에 주의를 기울이지 않도록 인과 마스크가 적용됩니다(자기 회귀 모델인 GPT와 같은 경우 중요).
- **주의 가중치:** 마스킹되고 스케일된 주의 점수의 소프트맥스입니다.
- **컨텍스트 벡터:** 주의 가중치에 따라 값의 가중 합입니다.
- **출력 프로젝션:** 모든 헤드의 출력을 결합하는 선형 레이어입니다.

> [!NOTE]
> 이 네트워크의 목표는 동일한 컨텍스트 내에서 토큰 간의 관계를 찾는 것입니다. 또한, 토큰은 과적합을 방지하기 위해 서로 다른 헤드로 나뉘지만, 각 헤드에서 발견된 최종 관계는 이 네트워크의 끝에서 결합됩니다.
>
> 또한, 훈련 중에 **인과 마스크**가 적용되어 나중의 토큰이 특정 토큰과의 관계를 찾을 때 고려되지 않으며, **과적합 방지**를 위해 일부 **드롭아웃**도 적용됩니다.

### **레이어** 정규화
```python
# From https://github.com/rasbt/LLMs-from-scratch/tree/main/ch04
class LayerNorm(nn.Module):
def __init__(self, emb_dim):
super().__init__()
self.eps = 1e-5 # Prevent division by zero during normalization.
self.scale = nn.Parameter(torch.ones(emb_dim))
self.shift = nn.Parameter(torch.zeros(emb_dim))

def forward(self, x):
mean = x.mean(dim=-1, keepdim=True)
var = x.var(dim=-1, keepdim=True, unbiased=False)
norm_x = (x - mean) / torch.sqrt(var + self.eps)
return self.scale * norm_x + self.shift
```
#### **목적 및 기능**

- **레이어 정규화:** 배치의 각 개별 예제에 대해 특성(임베딩 차원) 전반에 걸쳐 입력을 정규화하는 데 사용되는 기술입니다.
- **구성 요소:**
- **`eps`:** 정규화 중 0으로 나누는 것을 방지하기 위해 분산에 추가되는 작은 상수(`1e-5`).
- **`scale` 및 `shift`:** 모델이 정규화된 출력을 스케일하고 이동할 수 있도록 하는 학습 가능한 매개변수(`nn.Parameter`). 각각 1과 0으로 초기화됩니다.
- **정규화 과정:**
- **평균 계산(`mean`):** 임베딩 차원(`dim=-1`)에 걸쳐 입력 `x`의 평균을 계산하며, 브로드캐스팅을 위해 차원을 유지합니다(`keepdim=True`).
- **분산 계산(`var`):** 임베딩 차원에 걸쳐 `x`의 분산을 계산하며, 차원을 유지합니다. `unbiased=False` 매개변수는 분산이 편향 추정기를 사용하여 계산되도록 보장합니다(N으로 나누기 대신 N-1로 나누기), 이는 샘플이 아닌 특성에 대해 정규화할 때 적합합니다.
- **정규화(`norm_x`):** `x`에서 평균을 빼고 분산에 `eps`를 더한 값의 제곱근으로 나눕니다.
- **스케일 및 이동:** 정규화된 출력에 학습 가능한 `scale` 및 `shift` 매개변수를 적용합니다.

> [!NOTE]
> 목표는 동일한 토큰의 모든 차원에서 평균이 0이고 분산이 1이 되도록 하는 것입니다. 이는 **딥 뉴럴 네트워크의 훈련을 안정화**하기 위해 내부 공변량 이동을 줄이는 것을 목표로 하며, 이는 훈련 중 매개변수 업데이트로 인해 네트워크 활성화의 분포 변화와 관련이 있습니다.

### **트랜스포머 블록**

_행렬의 형태를 더 잘 이해하기 위해 주석으로 추가되었습니다:_
```python
# From https://github.com/rasbt/LLMs-from-scratch/tree/main/ch04

class TransformerBlock(nn.Module):
def __init__(self, cfg):
super().__init__()
self.att = MultiHeadAttention(
d_in=cfg["emb_dim"],
d_out=cfg["emb_dim"],
context_length=cfg["context_length"],
num_heads=cfg["n_heads"],
dropout=cfg["drop_rate"],
qkv_bias=cfg["qkv_bias"]
)
self.ff = FeedForward(cfg)
self.norm1 = LayerNorm(cfg["emb_dim"])
self.norm2 = LayerNorm(cfg["emb_dim"])
self.drop_shortcut = nn.Dropout(cfg["drop_rate"])

def forward(self, x):
# x shape: (batch_size, seq_len, emb_dim)

# Shortcut connection for attention block
shortcut = x  # shape: (batch_size, seq_len, emb_dim)
x = self.norm1(x)  # shape remains (batch_size, seq_len, emb_dim)
x = self.att(x)    # shape: (batch_size, seq_len, emb_dim)
x = self.drop_shortcut(x)  # shape remains (batch_size, seq_len, emb_dim)
x = x + shortcut   # shape: (batch_size, seq_len, emb_dim)

# Shortcut connection for feedforward block
shortcut = x       # shape: (batch_size, seq_len, emb_dim)
x = self.norm2(x)  # shape remains (batch_size, seq_len, emb_dim)
x = self.ff(x)     # shape: (batch_size, seq_len, emb_dim)
x = self.drop_shortcut(x)  # shape remains (batch_size, seq_len, emb_dim)
x = x + shortcut   # shape: (batch_size, seq_len, emb_dim)

return x  # Output shape: (batch_size, seq_len, emb_dim)

```
#### **목적 및 기능**

- **레이어 구성:** 다중 헤드 주의, 피드포워드 네트워크, 레이어 정규화 및 잔차 연결을 결합합니다.
- **레이어 정규화:** 안정적인 훈련을 위해 주의 및 피드포워드 레이어 전에 적용됩니다.
- **잔차 연결 (단축키):** 레이어의 입력을 출력에 추가하여 그래디언트 흐름을 개선하고 깊은 네트워크의 훈련을 가능하게 합니다.
- **드롭아웃:** 정규화를 위해 주의 및 피드포워드 레이어 후에 적용됩니다.

#### **단계별 기능**

1. **첫 번째 잔차 경로 (자기 주의):**
- **입력 (`shortcut`):** 잔차 연결을 위해 원래 입력을 저장합니다.
- **레이어 정규화 (`norm1`):** 입력을 정규화합니다.
- **다중 헤드 주의 (`att`):** 자기 주의를 적용합니다.
- **드롭아웃 (`drop_shortcut`):** 정규화를 위해 드롭아웃을 적용합니다.
- **잔차 추가 (`x + shortcut`):** 원래 입력과 결합합니다.
2. **두 번째 잔차 경로 (피드포워드):**
- **입력 (`shortcut`):** 다음 잔차 연결을 위해 업데이트된 입력을 저장합니다.
- **레이어 정규화 (`norm2`):** 입력을 정규화합니다.
- **피드포워드 네트워크 (`ff`):** 피드포워드 변환을 적용합니다.
- **드롭아웃 (`drop_shortcut`):** 드롭아웃을 적용합니다.
- **잔차 추가 (`x + shortcut`):** 첫 번째 잔차 경로의 입력과 결합합니다.

> [!NOTE]
> 변환기 블록은 모든 네트워크를 함께 그룹화하고 훈련 안정성과 결과를 개선하기 위해 일부 **정규화** 및 **드롭아웃**을 적용합니다.\
> 각 네트워크 사용 후 드롭아웃이 수행되고 정규화가 적용되는 방식을 주목하세요.
>
> 또한, **네트워크의 출력을 입력에 추가하는** 단축키를 사용합니다. 이는 초기 레이어가 마지막 레이어만큼 기여하도록 하여 소실 그래디언트 문제를 방지하는 데 도움이 됩니다.

### **GPTModel**

_행렬의 형태를 더 잘 이해하기 위해 주석으로 형태가 추가되었습니다:_
```python
# From https://github.com/rasbt/LLMs-from-scratch/tree/main/ch04
class GPTModel(nn.Module):
def __init__(self, cfg):
super().__init__()
self.tok_emb = nn.Embedding(cfg["vocab_size"], cfg["emb_dim"])
# shape: (vocab_size, emb_dim)

self.pos_emb = nn.Embedding(cfg["context_length"], cfg["emb_dim"])
# shape: (context_length, emb_dim)

self.drop_emb = nn.Dropout(cfg["drop_rate"])

self.trf_blocks = nn.Sequential(
*[TransformerBlock(cfg) for _ in range(cfg["n_layers"])]
)
# Stack of TransformerBlocks

self.final_norm = LayerNorm(cfg["emb_dim"])
self.out_head = nn.Linear(cfg["emb_dim"], cfg["vocab_size"], bias=False)
# shape: (emb_dim, vocab_size)

def forward(self, in_idx):
# in_idx shape: (batch_size, seq_len)
batch_size, seq_len = in_idx.shape

# Token embeddings
tok_embeds = self.tok_emb(in_idx)
# shape: (batch_size, seq_len, emb_dim)

# Positional embeddings
pos_indices = torch.arange(seq_len, device=in_idx.device)
# shape: (seq_len,)
pos_embeds = self.pos_emb(pos_indices)
# shape: (seq_len, emb_dim)

# Add token and positional embeddings
x = tok_embeds + pos_embeds  # Broadcasting over batch dimension
# x shape: (batch_size, seq_len, emb_dim)

x = self.drop_emb(x)  # Dropout applied
# x shape remains: (batch_size, seq_len, emb_dim)

x = self.trf_blocks(x)  # Pass through Transformer blocks
# x shape remains: (batch_size, seq_len, emb_dim)

x = self.final_norm(x)  # Final LayerNorm
# x shape remains: (batch_size, seq_len, emb_dim)

logits = self.out_head(x)  # Project to vocabulary size
# logits shape: (batch_size, seq_len, vocab_size)

return logits  # Output shape: (batch_size, seq_len, vocab_size)
```
#### **목적 및 기능**

- **임베딩 레이어:**
- **토큰 임베딩 (`tok_emb`):** 토큰 인덱스를 임베딩으로 변환합니다. 상기 참고, 이는 어휘의 각 토큰의 각 차원에 주어진 가중치입니다.
- **위치 임베딩 (`pos_emb`):** 임베딩에 위치 정보를 추가하여 토큰의 순서를 캡처합니다. 상기 참고, 이는 텍스트에서의 위치에 따라 토큰에 주어진 가중치입니다.
- **드롭아웃 (`drop_emb`):** 정규화를 위해 임베딩에 적용됩니다.
- **트랜스포머 블록 (`trf_blocks`):** 임베딩을 처리하기 위한 `n_layers` 트랜스포머 블록의 스택입니다.
- **최종 정규화 (`final_norm`):** 출력 레이어 이전의 레이어 정규화입니다.
- **출력 레이어 (`out_head`):** 최종 은닉 상태를 어휘 크기로 프로젝션하여 예측을 위한 로짓을 생성합니다.

> [!NOTE]
> 이 클래스의 목표는 **시퀀스에서 다음 토큰을 예측하기 위해** 언급된 모든 다른 네트워크를 사용하는 것입니다. 이는 텍스트 생성과 같은 작업에 기본적입니다.
>
> 얼마나 많은 트랜스포머 블록이 **지정된 대로 사용될 것인지** 주목하고, 각 트랜스포머 블록이 하나의 멀티 헤드 어텐션 네트워크, 하나의 피드 포워드 네트워크 및 여러 정규화를 사용하는지 주목하십시오. 따라서 12개의 트랜스포머 블록이 사용되면 이를 12로 곱합니다.
>
> 게다가, **정규화** 레이어가 **출력** 이전에 추가되고, 최종 선형 레이어가 끝에 적용되어 적절한 차원의 결과를 얻습니다. 각 최종 벡터가 사용된 어휘의 크기를 가지는 이유는 어휘 내의 가능한 각 토큰에 대한 확률을 얻으려 하기 때문입니다.

## 훈련할 매개변수 수

GPT 구조가 정의되면 훈련할 매개변수 수를 알아낼 수 있습니다:
```python
GPT_CONFIG_124M = {
"vocab_size": 50257,    # Vocabulary size
"context_length": 1024, # Context length
"emb_dim": 768,         # Embedding dimension
"n_heads": 12,          # Number of attention heads
"n_layers": 12,         # Number of layers
"drop_rate": 0.1,       # Dropout rate
"qkv_bias": False       # Query-Key-Value bias
}

model = GPTModel(GPT_CONFIG_124M)
total_params = sum(p.numel() for p in model.parameters())
print(f"Total number of parameters: {total_params:,}")
# Total number of parameters: 163,009,536
```
### **단계별 계산**

#### **1. 임베딩 레이어: 토큰 임베딩 및 위치 임베딩**

- **레이어:** `nn.Embedding(vocab_size, emb_dim)`
- **매개변수:** `vocab_size * emb_dim`
```python
token_embedding_params = 50257 * 768 = 38,597,376
```
- **Layer:** `nn.Embedding(context_length, emb_dim)`
- **Parameters:** `context_length * emb_dim`
```python
position_embedding_params = 1024 * 768 = 786,432
```
**총 임베딩 매개변수**
```python
embedding_params = token_embedding_params + position_embedding_params
embedding_params = 38,597,376 + 786,432 = 39,383,808
```
#### **2. Transformer Blocks**

12개의 트랜스포머 블록이 있으므로, 하나의 블록에 대한 매개변수를 계산한 후 12를 곱합니다.

**트랜스포머 블록당 매개변수**

**a. 다중 헤드 주의 (Multi-Head Attention)**

- **구성 요소:**
- **쿼리 선형 레이어 (`W_query`):** `nn.Linear(emb_dim, emb_dim, bias=False)`
- **키 선형 레이어 (`W_key`):** `nn.Linear(emb_dim, emb_dim, bias=False)`
- **값 선형 레이어 (`W_value`):** `nn.Linear(emb_dim, emb_dim, bias=False)`
- **출력 프로젝션 (`out_proj`):** `nn.Linear(emb_dim, emb_dim)`
- **계산:**

- **각각의 `W_query`, `W_key`, `W_value`:**

```python
qkv_params = emb_dim * emb_dim = 768 * 768 = 589,824
```

이러한 레이어가 세 개 있으므로:

```python
total_qkv_params = 3 * qkv_params = 3 * 589,824 = 1,769,472
```

- **출력 프로젝션 (`out_proj`):**

```python
out_proj_params = (emb_dim * emb_dim) + emb_dim = (768 * 768) + 768 = 589,824 + 768 = 590,592
```

- **총 다중 헤드 주의 매개변수:**

```python
mha_params = total_qkv_params + out_proj_params
mha_params = 1,769,472 + 590,592 = 2,360,064
```

**b. 피드포워드 네트워크 (FeedForward Network)**

- **구성 요소:**
- **첫 번째 선형 레이어:** `nn.Linear(emb_dim, 4 * emb_dim)`
- **두 번째 선형 레이어:** `nn.Linear(4 * emb_dim, emb_dim)`
- **계산:**

- **첫 번째 선형 레이어:**

```python
ff_first_layer_params = (emb_dim * 4 * emb_dim) + (4 * emb_dim)
ff_first_layer_params = (768 * 3072) + 3072 = 2,359,296 + 3,072 = 2,362,368
```

- **두 번째 선형 레이어:**

```python
ff_second_layer_params = (4 * emb_dim * emb_dim) + emb_dim
ff_second_layer_params = (3072 * 768) + 768 = 2,359,296 + 768 = 2,360,064
```

- **총 피드포워드 매개변수:**

```python
ff_params = ff_first_layer_params + ff_second_layer_params
ff_params = 2,362,368 + 2,360,064 = 4,722,432
```

**c. 레이어 정규화 (Layer Normalizations)**

- **구성 요소:**
- 블록당 두 개의 `LayerNorm` 인스턴스.
- 각 `LayerNorm`은 `2 * emb_dim` 매개변수(스케일 및 시프트)를 가집니다.
- **계산:**

```python
layer_norm_params_per_block = 2 * (2 * emb_dim) = 2 * 768 * 2 = 3,072
```

**d. 트랜스포머 블록당 총 매개변수**
```python
pythonCopy codeparams_per_block = mha_params + ff_params + layer_norm_params_per_block
params_per_block = 2,360,064 + 4,722,432 + 3,072 = 7,085,568
```
**모든 트랜스포머 블록의 총 매개변수**
```python
pythonCopy codetotal_transformer_blocks_params = params_per_block * n_layers
total_transformer_blocks_params = 7,085,568 * 12 = 85,026,816
```
#### **3. 최종 레이어**

**a. 최종 레이어 정규화**

- **매개변수:** `2 * emb_dim` (스케일 및 이동)
```python
pythonCopy codefinal_layer_norm_params = 2 * 768 = 1,536
```
**b. 출력 프로젝션 레이어 (`out_head`)**

- **레이어:** `nn.Linear(emb_dim, vocab_size, bias=False)`
- **파라미터:** `emb_dim * vocab_size`
```python
pythonCopy codeoutput_projection_params = 768 * 50257 = 38,597,376
```
#### **4. 모든 매개변수 요약**
```python
pythonCopy codetotal_params = (
embedding_params +
total_transformer_blocks_params +
final_layer_norm_params +
output_projection_params
)
total_params = (
39,383,808 +
85,026,816 +
1,536 +
38,597,376
)
total_params = 163,009,536
```
## 텍스트 생성

다음 토큰을 예측하는 모델이 있으면, 출력에서 마지막 토큰 값을 가져오기만 하면 됩니다(예측된 토큰의 값이 될 것이므로). 이는 **어휘의 각 항목에 대한 값**이 될 것이며, 그런 다음 `softmax` 함수를 사용하여 차원을 확률로 정규화하여 합이 1이 되도록 하고, 가장 큰 항목의 인덱스를 가져옵니다. 이 인덱스는 어휘 내의 단어의 인덱스가 됩니다.

코드 출처 [https://github.com/rasbt/LLMs-from-scratch/blob/main/ch04/01_main-chapter-code/ch04.ipynb](https://github.com/rasbt/LLMs-from-scratch/blob/main/ch04/01_main-chapter-code/ch04.ipynb):
```python
def generate_text_simple(model, idx, max_new_tokens, context_size):
# idx is (batch, n_tokens) array of indices in the current context
for _ in range(max_new_tokens):

# Crop current context if it exceeds the supported context size
# E.g., if LLM supports only 5 tokens, and the context size is 10
# then only the last 5 tokens are used as context
idx_cond = idx[:, -context_size:]

# Get the predictions
with torch.no_grad():
logits = model(idx_cond)

# Focus only on the last time step
# (batch, n_tokens, vocab_size) becomes (batch, vocab_size)
logits = logits[:, -1, :]

# Apply softmax to get probabilities
probas = torch.softmax(logits, dim=-1)  # (batch, vocab_size)

# Get the idx of the vocab entry with the highest probability value
idx_next = torch.argmax(probas, dim=-1, keepdim=True)  # (batch, 1)

# Append sampled index to the running sequence
idx = torch.cat((idx, idx_next), dim=1)  # (batch, n_tokens+1)

return idx


start_context = "Hello, I am"

encoded = tokenizer.encode(start_context)
print("encoded:", encoded)

encoded_tensor = torch.tensor(encoded).unsqueeze(0)
print("encoded_tensor.shape:", encoded_tensor.shape)

model.eval() # disable dropout

out = generate_text_simple(
model=model,
idx=encoded_tensor,
max_new_tokens=6,
context_size=GPT_CONFIG_124M["context_length"]
)

print("Output:", out)
print("Output length:", len(out[0]))
```
## References

- [https://www.manning.com/books/build-a-large-language-model-from-scratch](https://www.manning.com/books/build-a-large-language-model-from-scratch)
