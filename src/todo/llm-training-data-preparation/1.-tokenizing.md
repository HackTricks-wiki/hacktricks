# 1. Tokenización

## Tokenización

**Tokenización** es el proceso de descomponer datos, como texto, en piezas más pequeñas y manejables llamadas _tokens_. A cada token se le asigna un identificador numérico único (ID). Este es un paso fundamental en la preparación del texto para el procesamiento por modelos de aprendizaje automático, especialmente en el procesamiento del lenguaje natural (NLP).

> [!TIP]
> El objetivo de esta fase inicial es muy simple: **Dividir la entrada en tokens (ids) de una manera que tenga sentido**.

### **Cómo Funciona la Tokenización**

1. **Dividiendo el Texto:**
- **Tokenizador Básico:** Un tokenizador simple podría dividir el texto en palabras individuales y signos de puntuación, eliminando espacios.
- _Ejemplo:_\
Texto: `"¡Hola, mundo!"`\
Tokens: `["Hola", ",", "mundo", "!"]`
2. **Creando un Vocabulario:**
- Para convertir tokens en IDs numéricos, se crea un **vocabulario**. Este vocabulario lista todos los tokens únicos (palabras y símbolos) y asigna a cada uno un ID específico.
- **Tokens Especiales:** Estos son símbolos especiales añadidos al vocabulario para manejar varios escenarios:
- `[BOS]` (Inicio de Secuencia): Indica el comienzo de un texto.
- `[EOS]` (Fin de Secuencia): Indica el final de un texto.
- `[PAD]` (Relleno): Se utiliza para hacer que todas las secuencias en un lote tengan la misma longitud.
- `[UNK]` (Desconocido): Representa tokens que no están en el vocabulario.
- _Ejemplo:_\
Si `"Hola"` se asigna el ID `64`, `","` es `455`, `"mundo"` es `78`, y `"!"` es `467`, entonces:\
`"¡Hola, mundo!"` → `[64, 455, 78, 467]`
- **Manejo de Palabras Desconocidas:**\
Si una palabra como `"Adiós"` no está en el vocabulario, se reemplaza con `[UNK]`.\
`"¡Adiós, mundo!"` → `["[UNK]", ",", "mundo", "!"]` → `[987, 455, 78, 467]`\
&#xNAN;_(Asumiendo que `[UNK]` tiene el ID `987`)_

### **Métodos Avanzados de Tokenización**

Mientras que el tokenizador básico funciona bien para textos simples, tiene limitaciones, especialmente con vocabularios grandes y el manejo de palabras nuevas o raras. Los métodos avanzados de tokenización abordan estos problemas descomponiendo el texto en subunidades más pequeñas o optimizando el proceso de tokenización.

1. **Codificación de Pares de Bytes (BPE):**
- **Propósito:** Reduce el tamaño del vocabulario y maneja palabras raras o desconocidas descomponiéndolas en pares de bytes que ocurren con frecuencia.
- **Cómo Funciona:**
- Comienza con caracteres individuales como tokens.
- Fusiona iterativamente los pares de tokens más frecuentes en un solo token.
- Continúa hasta que no se puedan fusionar más pares frecuentes.
- **Beneficios:**
- Elimina la necesidad de un token `[UNK]` ya que todas las palabras pueden ser representadas combinando tokens de subpalabras existentes.
- Vocabulario más eficiente y flexible.
- _Ejemplo:_\
`"jugando"` podría ser tokenizado como `["jugar", "ando"]` si `"jugar"` y `"ando"` son subpalabras frecuentes.
2. **WordPiece:**
- **Usado Por:** Modelos como BERT.
- **Propósito:** Similar a BPE, descompone palabras en unidades de subpalabras para manejar palabras desconocidas y reducir el tamaño del vocabulario.
- **Cómo Funciona:**
- Comienza con un vocabulario base de caracteres individuales.
- Agrega iterativamente la subpalabra más frecuente que maximiza la probabilidad de los datos de entrenamiento.
- Utiliza un modelo probabilístico para decidir qué subpalabras fusionar.
- **Beneficios:**
- Equilibra entre tener un tamaño de vocabulario manejable y representar efectivamente las palabras.
- Maneja eficientemente palabras raras y compuestas.
- _Ejemplo:_\
`"descontento"` podría ser tokenizado como `["des", "contento"]` o `["des", "feliz", "tud"]` dependiendo del vocabulario.
3. **Modelo de Lenguaje Unigram:**
- **Usado Por:** Modelos como SentencePiece.
- **Propósito:** Utiliza un modelo probabilístico para determinar el conjunto más probable de tokens de subpalabras.
- **Cómo Funciona:**
- Comienza con un gran conjunto de tokens potenciales.
- Elimina iterativamente los tokens que menos mejoran la probabilidad del modelo de los datos de entrenamiento.
- Finaliza un vocabulario donde cada palabra es representada por las unidades de subpalabras más probables.
- **Beneficios:**
- Flexible y puede modelar el lenguaje de manera más natural.
- A menudo resulta en tokenizaciones más eficientes y compactas.
- _Ejemplo:_\
`"internacionalización"` podría ser tokenizado en subpalabras más pequeñas y significativas como `["internacional", "ización"]`.

## Ejemplo de Código

Entendamos esto mejor a partir de un ejemplo de código de [https://github.com/rasbt/LLMs-from-scratch/blob/main/ch02/01_main-chapter-code/ch02.ipynb](https://github.com/rasbt/LLMs-from-scratch/blob/main/ch02/01_main-chapter-code/ch02.ipynb):
```python
# Download a text to pre-train the model
import urllib.request
url = ("https://raw.githubusercontent.com/rasbt/LLMs-from-scratch/main/ch02/01_main-chapter-code/the-verdict.txt")
file_path = "the-verdict.txt"
urllib.request.urlretrieve(url, file_path)

with open("the-verdict.txt", "r", encoding="utf-8") as f:
raw_text = f.read()

# Tokenize the code using GPT2 tokenizer version
import tiktoken
token_ids = tiktoken.get_encoding("gpt2").encode(txt, allowed_special={"[EOS]"}) # Allow the user of the tag "[EOS]"

# Print first 50 tokens
print(token_ids[:50])
#[40, 367, 2885, 1464, 1807, 3619, 402, 271, 10899, 2138, 257, 7026, 15632, 438, 2016, 257, 922, 5891, 1576, 438, 568, 340, 373, 645, 1049, 5975, 284, 502, 284, 3285, 326, 11, 287, 262, 6001, 286, 465, 13476, 11, 339, 550, 5710, 465, 12036, 11, 6405, 257, 5527, 27075, 11]
```
## Referencias

- [https://www.manning.com/books/build-a-large-language-model-from-scratch](https://www.manning.com/books/build-a-large-language-model-from-scratch)
