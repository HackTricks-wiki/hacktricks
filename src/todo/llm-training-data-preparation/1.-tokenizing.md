# 1. トークナイジング

## トークナイジング

**トークナイジング**は、テキストなどのデータを小さく管理しやすい部分、すなわち_トークン_に分解するプロセスです。各トークンには一意の数値識別子（ID）が割り当てられます。これは、特に自然言語処理（NLP）において、機械学習モデルによる処理のためにテキストを準備する際の基本的なステップです。

> [!TIP]
> この初期段階の目標は非常にシンプルです：**入力を意味のある方法でトークン（ID）に分割すること**。

### **トークナイジングの仕組み**

1. **テキストの分割:**
- **基本トークナイザー:** シンプルなトークナイザーは、テキストを個々の単語や句読点に分割し、スペースを削除することがあります。
- _例:_\
テキスト: `"Hello, world!"`\
トークン: `["Hello", ",", "world", "!"]`
2. **語彙の作成:**
- トークンを数値IDに変換するために、**語彙**が作成されます。この語彙はすべてのユニークなトークン（単語や記号）をリストし、それぞれに特定のIDを割り当てます。
- **特別なトークン:** さまざまなシナリオに対処するために語彙に追加される特別な記号です：
- `[BOS]`（シーケンスの開始）：テキストの開始を示します。
- `[EOS]`（シーケンスの終了）：テキストの終了を示します。
- `[PAD]`（パディング）：バッチ内のすべてのシーケンスを同じ長さにするために使用されます。
- `[UNK]`（未知）：語彙にないトークンを表します。
- _例:_\
もし`"Hello"`がID `64`、`","`が`455`、`"world"`が`78`、`"!"`が`467`に割り当てられている場合：\
`"Hello, world!"` → `[64, 455, 78, 467]`
- **未知の単語の処理:**\
もし`"Bye"`のような単語が語彙にない場合、`[UNK]`に置き換えられます。\
`"Bye, world!"` → `["[UNK]", ",", "world", "!"]` → `[987, 455, 78, 467]`\
_(`[UNK]`がID `987`であると仮定)_

### **高度なトークナイジング手法**

基本的なトークナイザーはシンプルなテキストにはうまく機能しますが、大きな語彙や新しいまたは珍しい単語の処理には限界があります。高度なトークナイジング手法は、テキストを小さなサブユニットに分解したり、トークナイジングプロセスを最適化したりすることで、これらの問題に対処します。

1. **バイトペアエンコーディング（BPE）:**
- **目的:** 語彙のサイズを削減し、珍しいまたは未知の単語を頻繁に出現するバイトペアに分解することで処理します。
- **仕組み:**
- 個々の文字をトークンとして開始します。
- 最も頻繁に出現するトークンのペアを反復的に1つのトークンにマージします。
- これ以上頻繁なペアがマージできなくなるまで続けます。
- **利点:**
- すべての単語が既存のサブワードトークンを組み合わせることで表現できるため、`[UNK]`トークンの必要がなくなります。
- より効率的で柔軟な語彙。
- _例:_\
`"playing"`は、`"play"`と`"ing"`が頻繁なサブワードであれば、`["play", "ing"]`としてトークナイズされるかもしれません。
2. **WordPiece:**
- **使用モデル:** BERTのようなモデル。
- **目的:** BPEと同様に、未知の単語を処理し、語彙のサイズを削減するために単語をサブワードユニットに分解します。
- **仕組み:**
- 個々の文字の基本語彙から始まります。
- トレーニングデータの尤度を最大化する最も頻繁なサブワードを反復的に追加します。
- どのサブワードをマージするかを決定するために確率モデルを使用します。
- **利点:**
- 管理可能な語彙サイズと単語を効果的に表現することのバランスを取ります。
- 珍しい単語や複合語を効率的に処理します。
- _例:_\
`"unhappiness"`は、語彙に応じて`["un", "happiness"]`または`["un", "happy", "ness"]`としてトークナイズされるかもしれません。
3. **ユニグラム言語モデル:**
- **使用モデル:** SentencePieceのようなモデル。
- **目的:** 最も可能性の高いサブワードトークンのセットを決定するために確率モデルを使用します。
- **仕組み:**
- 潜在的なトークンの大きなセットから始まります。
- トレーニングデータのモデルの確率を最も改善しないトークンを反復的に削除します。
- 各単語が最も可能性の高いサブワードユニットで表現される語彙を最終化します。
- **利点:**
- 柔軟で、より自然に言語をモデル化できます。
- より効率的でコンパクトなトークナイジングを実現することが多いです。
- _例:_\
`"internationalization"`は、`["international", "ization"]`のような小さく意味のあるサブワードにトークナイズされるかもしれません。

## コード例

[https://github.com/rasbt/LLMs-from-scratch/blob/main/ch02/01_main-chapter-code/ch02.ipynb](https://github.com/rasbt/LLMs-from-scratch/blob/main/ch02/01_main-chapter-code/ch02.ipynb)からのコード例を通じて、これをよりよく理解しましょう。
```python
# Download a text to pre-train the model
import urllib.request
url = ("https://raw.githubusercontent.com/rasbt/LLMs-from-scratch/main/ch02/01_main-chapter-code/the-verdict.txt")
file_path = "the-verdict.txt"
urllib.request.urlretrieve(url, file_path)

with open("the-verdict.txt", "r", encoding="utf-8") as f:
raw_text = f.read()

# Tokenize the code using GPT2 tokenizer version
import tiktoken
token_ids = tiktoken.get_encoding("gpt2").encode(txt, allowed_special={"[EOS]"}) # Allow the user of the tag "[EOS]"

# Print first 50 tokens
print(token_ids[:50])
#[40, 367, 2885, 1464, 1807, 3619, 402, 271, 10899, 2138, 257, 7026, 15632, 438, 2016, 257, 922, 5891, 1576, 438, 568, 340, 373, 645, 1049, 5975, 284, 502, 284, 3285, 326, 11, 287, 262, 6001, 286, 465, 13476, 11, 339, 550, 5710, 465, 12036, 11, 6405, 257, 5527, 27075, 11]
```
## 参考文献

- [https://www.manning.com/books/build-a-large-language-model-from-scratch](https://www.manning.com/books/build-a-large-language-model-from-scratch)
