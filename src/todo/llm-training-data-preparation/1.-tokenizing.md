# 1. 토큰화

## 토큰화

**토큰화**는 텍스트와 같은 데이터를 더 작고 관리 가능한 조각인 _토큰_으로 나누는 과정입니다. 각 토큰은 고유한 숫자 식별자(ID)가 할당됩니다. 이는 기계 학습 모델, 특히 자연어 처리(NLP)를 위한 텍스트 준비의 기본 단계입니다.

> [!TIP]
> 이 초기 단계의 목표는 매우 간단합니다: **입력을 의미 있는 방식으로 토큰(IDs)으로 나누기**입니다.

### **토큰화 작동 방식**

1. **텍스트 분할:**
- **기본 토크나이저:** 간단한 토크나이저는 텍스트를 개별 단어와 구두점으로 나누고 공백을 제거할 수 있습니다.
- _예시:_\
텍스트: `"Hello, world!"`\
토큰: `["Hello", ",", "world", "!"]`
2. **어휘 생성:**
- 토큰을 숫자 ID로 변환하기 위해 **어휘**가 생성됩니다. 이 어휘는 모든 고유 토큰(단어 및 기호)을 나열하고 각 토큰에 특정 ID를 할당합니다.
- **특수 토큰:** 다양한 시나리오를 처리하기 위해 어휘에 추가된 특수 기호입니다:
- `[BOS]` (시퀀스 시작): 텍스트의 시작을 나타냅니다.
- `[EOS]` (시퀀스 끝): 텍스트의 끝을 나타냅니다.
- `[PAD]` (패딩): 배치의 모든 시퀀스를 동일한 길이로 만들기 위해 사용됩니다.
- `[UNK]` (알 수 없음): 어휘에 없는 토큰을 나타냅니다.
- _예시:_\
`"Hello"`가 ID `64`에 할당되고, `","`가 `455`, `"world"`가 `78`, `"!"`가 `467`이라면:\
`"Hello, world!"` → `[64, 455, 78, 467]`
- **알 수 없는 단어 처리:**\
`"Bye"`와 같은 단어가 어휘에 없으면 `[UNK]`로 대체됩니다.\
`"Bye, world!"` → `["[UNK]", ",", "world", "!"]` → `[987, 455, 78, 467]`\
&#xNAN;_(`[UNK]`의 ID가 `987`라고 가정)_

### **고급 토큰화 방법**

기본 토크나이저는 간단한 텍스트에 잘 작동하지만, 특히 큰 어휘와 새로운 또는 희귀한 단어를 처리하는 데 한계가 있습니다. 고급 토큰화 방법은 텍스트를 더 작은 하위 단위로 나누거나 토큰화 프로세스를 최적화하여 이러한 문제를 해결합니다.

1. **바이트 쌍 인코딩(BPE):**
- **목적:** 어휘의 크기를 줄이고 희귀하거나 알 수 없는 단어를 자주 발생하는 바이트 쌍으로 나누어 처리합니다.
- **작동 방식:**
- 개별 문자를 토큰으로 시작합니다.
- 가장 자주 발생하는 토큰 쌍을 반복적으로 병합하여 단일 토큰으로 만듭니다.
- 더 이상 병합할 수 있는 자주 발생하는 쌍이 없을 때까지 계속합니다.
- **장점:**
- 모든 단어가 기존 하위 단어 토큰을 결합하여 표현될 수 있으므로 `[UNK]` 토큰이 필요 없습니다.
- 더 효율적이고 유연한 어휘입니다.
- _예시:_\
`"playing"`은 `"play"`와 `"ing"`가 자주 발생하는 하위 단어라면 `["play", "ing"]`로 토큰화될 수 있습니다.
2. **WordPiece:**
- **사용 모델:** BERT와 같은 모델.
- **목적:** BPE와 유사하게, 알 수 없는 단어를 처리하고 어휘 크기를 줄이기 위해 단어를 하위 단위로 나눕니다.
- **작동 방식:**
- 개별 문자의 기본 어휘로 시작합니다.
- 훈련 데이터의 가능성을 극대화하는 가장 자주 발생하는 하위 단어를 반복적으로 추가합니다.
- 어떤 하위 단어를 병합할지 결정하기 위해 확률 모델을 사용합니다.
- **장점:**
- 관리 가능한 어휘 크기와 효과적인 단어 표현 간의 균형을 유지합니다.
- 희귀하고 복합적인 단어를 효율적으로 처리합니다.
- _예시:_\
`"unhappiness"`는 어휘에 따라 `["un", "happiness"]` 또는 `["un", "happy", "ness"]`로 토큰화될 수 있습니다.
3. **유니그램 언어 모델:**
- **사용 모델:** SentencePiece와 같은 모델.
- **목적:** 가장 가능성이 높은 하위 단어 토큰 집합을 결정하기 위해 확률 모델을 사용합니다.
- **작동 방식:**
- 잠재적인 토큰의 큰 집합으로 시작합니다.
- 훈련 데이터의 모델 확률을 가장 적게 개선하는 토큰을 반복적으로 제거합니다.
- 각 단어가 가장 가능성이 높은 하위 단위로 표현되는 어휘를 최종화합니다.
- **장점:**
- 유연하며 언어를 더 자연스럽게 모델링할 수 있습니다.
- 종종 더 효율적이고 간결한 토큰화를 제공합니다.
- _예시:_\
`"internationalization"`은 `["international", "ization"]`과 같은 더 작고 의미 있는 하위 단어로 토큰화될 수 있습니다.

## 코드 예시

[https://github.com/rasbt/LLMs-from-scratch/blob/main/ch02/01_main-chapter-code/ch02.ipynb](https://github.com/rasbt/LLMs-from-scratch/blob/main/ch02/01_main-chapter-code/ch02.ipynb)에서 코드 예시를 통해 이를 더 잘 이해해 봅시다.
```python
# Download a text to pre-train the model
import urllib.request
url = ("https://raw.githubusercontent.com/rasbt/LLMs-from-scratch/main/ch02/01_main-chapter-code/the-verdict.txt")
file_path = "the-verdict.txt"
urllib.request.urlretrieve(url, file_path)

with open("the-verdict.txt", "r", encoding="utf-8") as f:
raw_text = f.read()

# Tokenize the code using GPT2 tokenizer version
import tiktoken
token_ids = tiktoken.get_encoding("gpt2").encode(txt, allowed_special={"[EOS]"}) # Allow the user of the tag "[EOS]"

# Print first 50 tokens
print(token_ids[:50])
#[40, 367, 2885, 1464, 1807, 3619, 402, 271, 10899, 2138, 257, 7026, 15632, 438, 2016, 257, 922, 5891, 1576, 438, 568, 340, 373, 645, 1049, 5975, 284, 502, 284, 3285, 326, 11, 287, 262, 6001, 286, 465, 13476, 11, 339, 550, 5710, 465, 12036, 11, 6405, 257, 5527, 27075, 11]
```
## References

- [https://www.manning.com/books/build-a-large-language-model-from-scratch](https://www.manning.com/books/build-a-large-language-model-from-scratch)
