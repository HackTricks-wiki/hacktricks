# 7.0. LoRA सुधार फाइन-ट्यूनिंग में

## LoRA सुधार

> [!TIP]
> **LoRA का उपयोग बहुत सारी गणना को कम करता है** जो पहले से प्रशिक्षित मॉडलों को **फाइन ट्यून** करने के लिए आवश्यक है।

LoRA **बड़े मॉडलों** को प्रभावी ढंग से फाइन-ट्यून करना संभव बनाता है, केवल मॉडल के **छोटे हिस्से** को बदलकर। यह उन पैरामीटर की संख्या को कम करता है जिन्हें आपको प्रशिक्षित करने की आवश्यकता होती है, **मेमोरी** और **गणनात्मक संसाधनों** की बचत करता है। इसका कारण है:

1. **प्रशिक्षण योग्य पैरामीटर की संख्या को कम करता है**: मॉडल में पूरे वजन मैट्रिक्स को अपडेट करने के बजाय, LoRA वजन मैट्रिक्स को दो छोटे मैट्रिक्स (जिन्हें **A** और **B** कहा जाता है) में **विभाजित** करता है। इससे प्रशिक्षण **तेज़** हो जाता है और **कम मेमोरी** की आवश्यकता होती है क्योंकि कम पैरामीटर को अपडेट करने की आवश्यकता होती है।

1. इसका कारण यह है कि एक परत (मैट्रिक्स) के पूर्ण वजन अपडेट की गणना करने के बजाय, यह इसे 2 छोटे मैट्रिक्स के उत्पाद के रूप में अनुमानित करता है, अपडेट की गणना को कम करता है:\

<figure><img src="../../images/image (9) (1).png" alt=""><figcaption></figcaption></figure>

2. **मूल मॉडल के वजन को अपरिवर्तित रखता है**: LoRA आपको मूल मॉडल के वजन को समान रखने की अनुमति देता है, और केवल **नए छोटे मैट्रिक्स** (A और B) को अपडेट करता है। यह सहायक है क्योंकि इसका मतलब है कि मॉडल का मूल ज्ञान संरक्षित है, और आप केवल आवश्यक चीजों को समायोजित करते हैं।
3. **कुशल कार्य-विशिष्ट फाइन-ट्यूनिंग**: जब आप मॉडल को **नए कार्य** के लिए अनुकूलित करना चाहते हैं, तो आप केवल **छोटे LoRA मैट्रिक्स** (A और B) को प्रशिक्षित कर सकते हैं जबकि बाकी मॉडल को वैसा ही छोड़ सकते हैं। यह पूरे मॉडल को फिर से प्रशिक्षित करने की तुलना में **बहुत अधिक कुशल** है।
4. **स्टोरेज दक्षता**: फाइन-ट्यूनिंग के बाद, प्रत्येक कार्य के लिए **एक नया पूरा मॉडल** सहेजने के बजाय, आपको केवल **LoRA मैट्रिक्स** को स्टोर करने की आवश्यकता होती है, जो पूरे मॉडल की तुलना में बहुत छोटे होते हैं। इससे मॉडल को कई कार्यों के लिए अनुकूलित करना आसान हो जाता है बिना बहुत अधिक स्टोरेज का उपयोग किए।

फाइन-ट्यूनिंग के दौरान Linear के बजाय LoraLayers को लागू करने के लिए, यहां यह कोड प्रस्तावित किया गया है [https://github.com/rasbt/LLMs-from-scratch/blob/main/appendix-E/01_main-chapter-code/appendix-E.ipynb](https://github.com/rasbt/LLMs-from-scratch/blob/main/appendix-E/01_main-chapter-code/appendix-E.ipynb):
```python
import math

# Create the LoRA layer with the 2 matrices and the alpha
class LoRALayer(torch.nn.Module):
def __init__(self, in_dim, out_dim, rank, alpha):
super().__init__()
self.A = torch.nn.Parameter(torch.empty(in_dim, rank))
torch.nn.init.kaiming_uniform_(self.A, a=math.sqrt(5))  # similar to standard weight initialization
self.B = torch.nn.Parameter(torch.zeros(rank, out_dim))
self.alpha = alpha

def forward(self, x):
x = self.alpha * (x @ self.A @ self.B)
return x

# Combine it with the linear layer
class LinearWithLoRA(torch.nn.Module):
def __init__(self, linear, rank, alpha):
super().__init__()
self.linear = linear
self.lora = LoRALayer(
linear.in_features, linear.out_features, rank, alpha
)

def forward(self, x):
return self.linear(x) + self.lora(x)

# Replace linear layers with LoRA ones
def replace_linear_with_lora(model, rank, alpha):
for name, module in model.named_children():
if isinstance(module, torch.nn.Linear):
# Replace the Linear layer with LinearWithLoRA
setattr(model, name, LinearWithLoRA(module, rank, alpha))
else:
# Recursively apply the same function to child modules
replace_linear_with_lora(module, rank, alpha)
```
## संदर्भ

- [https://www.manning.com/books/build-a-large-language-model-from-scratch](https://www.manning.com/books/build-a-large-language-model-from-scratch)
