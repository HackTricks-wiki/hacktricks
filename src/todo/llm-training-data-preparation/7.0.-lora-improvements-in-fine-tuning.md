# 7.0. LoRA Verbeterings in fyn-afstemming

## LoRA Verbeterings

> [!TIP]
> Die gebruik van **LoRA verminder baie die berekening** wat nodig is om **fyn af te stem** reeds getrainde modelle.

LoRA maak dit moontlik om **groot modelle** doeltreffend fyn af te stem deur slegs 'n **klein deel** van die model te verander. Dit verminder die aantal parameters wat jy moet oplei, wat **geheue** en **berekeningshulpbronne** bespaar. Dit is omdat:

1. **Verminder die Aantal Opleibare Parameters**: In plaas daarvan om die hele gewigsmatris in die model op te dateer, **verdeel** LoRA die gewigsmatris in twee kleiner matrise (genoem **A** en **B**). Dit maak opleiding **vinniger** en vereis **minder geheue** omdat minder parameters opgedateer moet word.

1. Dit is omdat dit in plaas daarvan om die volledige gewigsopdatering van 'n laag (matris) te bereken, dit benader na 'n produk van 2 kleiner matrise wat die opdatering verminder om te bereken:\

<figure><img src="../../images/image (9) (1).png" alt=""><figcaption></figcaption></figure>

2. **Hou Oorspronklike Model Gewigte Onveranderd**: LoRA laat jou toe om die oorspronklike modelgewigte dieselfde te hou, en slegs die **nuwe klein matrise** (A en B) op te dateer. Dit is nuttig omdat dit beteken dat die model se oorspronklike kennis bewaar word, en jy net wat nodig is aanpas.
3. **Doeltreffende Taakspesifieke Fyn-afstemming**: Wanneer jy die model wil aanpas vir 'n **nuwe taak**, kan jy net die **klein LoRA matrise** (A en B) oplei terwyl jy die res van die model soos dit is laat. Dit is **baie doeltreffender** as om die hele model weer op te lei.
4. **Bergingseffektiwiteit**: Na fyn-afstemming, in plaas daarvan om 'n **heel nuwe model** vir elke taak te stoor, hoef jy slegs die **LoRA matrise** te stoor, wat baie klein is in vergelyking met die hele model. Dit maak dit makliker om die model aan te pas vir baie take sonder om te veel berging te gebruik.

Om LoraLayers in plaas van Linear eenhede tydens 'n fyn-afstemming te implementeer, word hierdie kode hier voorgestel [https://github.com/rasbt/LLMs-from-scratch/blob/main/appendix-E/01_main-chapter-code/appendix-E.ipynb](https://github.com/rasbt/LLMs-from-scratch/blob/main/appendix-E/01_main-chapter-code/appendix-E.ipynb):
```python
import math

# Create the LoRA layer with the 2 matrices and the alpha
class LoRALayer(torch.nn.Module):
def __init__(self, in_dim, out_dim, rank, alpha):
super().__init__()
self.A = torch.nn.Parameter(torch.empty(in_dim, rank))
torch.nn.init.kaiming_uniform_(self.A, a=math.sqrt(5))  # similar to standard weight initialization
self.B = torch.nn.Parameter(torch.zeros(rank, out_dim))
self.alpha = alpha

def forward(self, x):
x = self.alpha * (x @ self.A @ self.B)
return x

# Combine it with the linear layer
class LinearWithLoRA(torch.nn.Module):
def __init__(self, linear, rank, alpha):
super().__init__()
self.linear = linear
self.lora = LoRALayer(
linear.in_features, linear.out_features, rank, alpha
)

def forward(self, x):
return self.linear(x) + self.lora(x)

# Replace linear layers with LoRA ones
def replace_linear_with_lora(model, rank, alpha):
for name, module in model.named_children():
if isinstance(module, torch.nn.Linear):
# Replace the Linear layer with LinearWithLoRA
setattr(model, name, LinearWithLoRA(module, rank, alpha))
else:
# Recursively apply the same function to child modules
replace_linear_with_lora(module, rank, alpha)
```
## Verwysings

- [https://www.manning.com/books/build-a-large-language-model-from-scratch](https://www.manning.com/books/build-a-large-language-model-from-scratch)
