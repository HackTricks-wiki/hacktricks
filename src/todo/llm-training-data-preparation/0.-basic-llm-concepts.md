# 0. Basiese LLM Konsepte

## Vooropleiding

Vooropleiding is die grondslag fase in die ontwikkeling van 'n groot taalmodel (LLM) waar die model blootgestel word aan groot en diverse hoeveelhede teksdata. Gedurende hierdie fase, **leer die LLM die fundamentele strukture, patrone, en nuanses van taal**, insluitend grammatika, woordeskat, sintaksis, en kontekstuele verhoudings. Deur hierdie uitgebreide data te verwerk, verkry die model 'n breë begrip van taal en algemene wêreldkennis. Hierdie omvattende basis stel die LLM in staat om samehangende en kontekstueel relevante teks te genereer. Vervolgens kan hierdie vooropgeleide model fyn-afgestem word, waar dit verder opgelei word op gespesialiseerde datastelle om sy vermoëns aan te pas vir spesifieke take of domeine, wat sy prestasie en relevansie in geteikende toepassings verbeter.

## Hoof LLM komponente

Gewoonlik word 'n LLM gekarakteriseer deur die konfigurasie wat gebruik word om dit op te lei. Dit is die algemene komponente wanneer 'n LLM opgelei word:

- **Parameters**: Parameters is die **leerbare gewigte en vooroordele** in die neurale netwerk. Dit is die getalle wat die opleidingsproses aanpas om die verliesfunksie te minimaliseer en die model se prestasie op die taak te verbeter. LLMs gebruik gewoonlik miljoene parameters.
- **Kontekslengte**: Dit is die maksimum lengte van elke sin wat gebruik word om die LLM voor te oefen.
- **Inbeddimensie**: Die grootte van die vektor wat gebruik word om elke token of woord voor te stel. LLMs gebruik gewoonlik biljoene dimensies.
- **Verborge Dimensie**: Die grootte van die verborge lae in die neurale netwerk.
- **Aantal Lae (Diepte)**: Hoeveel lae die model het. LLMs gebruik gewoonlik tientalle lae.
- **Aantal Aandagkoppe**: In transformator modelle, dit is hoeveel aparte aandagmeganismes in elke laag gebruik word. LLMs gebruik gewoonlik tientalle koppe.
- **Dropout**: Dropout is iets soos die persentasie data wat verwyder word (waarskynlikhede word 0) tydens opleiding wat gebruik word om **oorpassing te voorkom.** LLMs gebruik gewoonlik tussen 0-20%.

Konfigurasie van die GPT-2 model:
```json
GPT_CONFIG_124M = {
"vocab_size": 50257,  // Vocabulary size of the BPE tokenizer
"context_length": 1024, // Context length
"emb_dim": 768,       // Embedding dimension
"n_heads": 12,        // Number of attention heads
"n_layers": 12,       // Number of layers
"drop_rate": 0.1,     // Dropout rate: 10%
"qkv_bias": False     // Query-Key-Value bias
}
```
## Tensors in PyTorch

In PyTorch, 'n **tensor** is 'n fundamentele datastruktuur wat dien as 'n multi-dimensionele array, wat konsepte soos skalar, vektore en matrikse veralgemeen na moontlik hoër dimensies. Tensors is die primêre manier waarop data voorgestel en gemanipuleer word in PyTorch, veral in die konteks van diep leer en neurale netwerke.

### Mathematical Concept of Tensors

- **Scalars**: Tensors van rang 0, wat 'n enkele getal voorstel (nul-dimensioneel). Soos: 5
- **Vectors**: Tensors van rang 1, wat 'n een-dimensionele array van getalle voorstel. Soos: \[5,1]
- **Matrices**: Tensors van rang 2, wat twee-dimensionele arrays met rye en kolomme voorstel. Soos: \[\[1,3], \[5,2]]
- **Higher-Rank Tensors**: Tensors van rang 3 of meer, wat data in hoër dimensies voorstel (bv. 3D tensors vir kleurbeelde).

### Tensors as Data Containers

From a computational perspective, tensors act as containers for multi-dimensional data, where each dimension can represent different features or aspects of the data. This makes tensors highly suitable for handling complex datasets in machine learning tasks.

### PyTorch Tensors vs. NumPy Arrays

While PyTorch tensors are similar to NumPy arrays in their ability to store and manipulate numerical data, they offer additional functionalities crucial for deep learning:

- **Automatic Differentiation**: PyTorch tensors support automatic calculation of gradients (autograd), which simplifies the process of computing derivatives required for training neural networks.
- **GPU Acceleration**: Tensors in PyTorch can be moved to and computed on GPUs, significantly speeding up large-scale computations.

### Creating Tensors in PyTorch

You can create tensors using the `torch.tensor` function:
```python
pythonCopy codeimport torch

# Scalar (0D tensor)
tensor0d = torch.tensor(1)

# Vector (1D tensor)
tensor1d = torch.tensor([1, 2, 3])

# Matrix (2D tensor)
tensor2d = torch.tensor([[1, 2],
[3, 4]])

# 3D Tensor
tensor3d = torch.tensor([[[1, 2], [3, 4]],
[[5, 6], [7, 8]]])
```
### Tensor Data Tipes

PyTorch tensors kan data van verskillende tipes stoor, soos heelgetalle en drijvende-komma getalle.

Jy kan 'n tensor se datatipe nagaan met die `.dtype` attribuut:
```python
tensor1d = torch.tensor([1, 2, 3])
print(tensor1d.dtype)  # Output: torch.int64
```
- Tensore wat van Python-heelgetalle geskep is, is van tipe `torch.int64`.
- Tensore wat van Python-vlottende getalle geskep is, is van tipe `torch.float32`.

Om 'n tensor se datatipe te verander, gebruik die `.to()` metode:
```python
float_tensor = tensor1d.to(torch.float32)
print(float_tensor.dtype)  # Output: torch.float32
```
### Algemene Tensor Operasies

PyTorch bied 'n verskeidenheid operasies om tensors te manipuleer:

- **Toegang tot Vorm**: Gebruik `.shape` om die dimensies van 'n tensor te kry.

```python
print(tensor2d.shape)  # Output: torch.Size([2, 2])
```

- **Hervorming van Tensors**: Gebruik `.reshape()` of `.view()` om die vorm te verander.

```python
reshaped = tensor2d.reshape(4, 1)
```

- **Transposering van Tensors**: Gebruik `.T` om 'n 2D tensor te transponer.

```python
transposed = tensor2d.T
```

- **Matriks Vermenigvuldiging**: Gebruik `.matmul()` of die `@` operator.

```python
result = tensor2d @ tensor2d.T
```

### Belangrikheid in Diep Leer

Tensors is noodsaaklik in PyTorch vir die bou en opleiding van neurale netwerke:

- Hulle stoor invoerdata, gewigte en vooroordele.
- Hulle fasiliteer operasies wat vereis word vir vorentoe en agtertoe passasies in opleidingsalgoritmes.
- Met autograd, stel tensors outomatiese berekening van gradiënte in staat, wat die optimaliseringsproses stroomlyn.

## Outomatiese Differensiasie

Outomatiese differensiasie (AD) is 'n berekeningstegniek wat gebruik word om **die afgeleides (gradiënte)** van funksies doeltreffend en akkuraat te evalueer. In die konteks van neurale netwerke, stel AD die berekening van gradiënte wat benodig word vir **optimaliseringsalgoritmes soos gradiëntafname** moontlik. PyTorch bied 'n outomatiese differensiasie enjin genaamd **autograd** wat hierdie proses vereenvoudig.

### Wiskundige Verklaring van Outomatiese Differensiasie

**1. Die Kettingreël**

In die hart van outomatiese differensiasie is die **kettingreël** van calculus. Die kettingreël stel dat as jy 'n samestelling van funksies het, die afgeleide van die saamgestelde funksie die produk van die afgeleides van die saamgestelde funksies is.

Wiskundig, as `y=f(u)` en `u=g(x)`, dan is die afgeleide van `y` ten opsigte van `x`:

<figure><img src="../../images/image (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**2. Berekening Grafiek**

In AD word berekeninge voorgestel as knope in 'n **berekening grafiek**, waar elke knoop ooreenstem met 'n operasie of 'n veranderlike. Deur hierdie grafiek te traverseer, kan ons afgeleides doeltreffend bereken.

3. Voorbeeld

Kom ons oorweeg 'n eenvoudige funksie:

<figure><img src="../../images/image (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Waar:

- `σ(z)` is die sigmoid funksie.
- `y=1.0` is die teikenetiket.
- `L` is die verlies.

Ons wil die gradiënt van die verlies `L` ten opsigte van die gewig `w` en vooroordeel `b` bereken.

**4. Berekening van Gradiënte Handmatig**

<figure><img src="../../images/image (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

**5. Numeriese Berekening**

<figure><img src="../../images/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Implementering van Outomatiese Differensiasie in PyTorch

Nou, kom ons kyk hoe PyTorch hierdie proses outomatiseer.
```python
pythonCopy codeimport torch
import torch.nn.functional as F

# Define input and target
x = torch.tensor([1.1])
y = torch.tensor([1.0])

# Initialize weights with requires_grad=True to track computations
w = torch.tensor([2.2], requires_grad=True)
b = torch.tensor([0.0], requires_grad=True)

# Forward pass
z = x * w + b
a = torch.sigmoid(z)
loss = F.binary_cross_entropy(a, y)

# Backward pass
loss.backward()

# Gradients
print("Gradient w.r.t w:", w.grad)
print("Gradient w.r.t b:", b.grad)
```
**Output:**
```css
cssCopy codeGradient w.r.t w: tensor([-0.0898])
Gradient w.r.t b: tensor([-0.0817])
```
## Terugpropagering in Groter Neurale Netwerke

### **1. Uitbreiding na Meervoudige Lae**

In groter neurale netwerke met meerdere lae, word die proses om gradiënte te bereken meer kompleks weens die verhoogde aantal parameters en operasies. Tog bly die fundamentele beginsels dieselfde:

- **Voorwaartse Deurloop:** Bereken die uitvoer van die netwerk deur insette deur elke laag te laat gaan.
- **Bereken Verlies:** Evalueer die verliesfunksie met behulp van die netwerk se uitvoer en die teikenetikette.
- **Achterwaartse Deurloop (Terugpropagering):** Bereken die gradiënte van die verlies ten opsigte van elke parameter in die netwerk deur die kettingreël herhaaldelik toe te pas van die uitvoerlaag terug na die insetlaag.

### **2. Terugpropagering Algoritme**

- **Stap 1:** Begin die netwerkparameters (gewigte en vooroordele).
- **Stap 2:** Vir elke opleidingsvoorbeeld, voer 'n voorwaartse deurloop uit om die uitvoer te bereken.
- **Stap 3:** Bereken die verlies.
- **Stap 4:** Bereken die gradiënte van die verlies ten opsigte van elke parameter met behulp van die kettingreël.
- **Stap 5:** Werk die parameters op met 'n optimalisering algoritme (bv. gradiëntafname).

### **3. Wiskundige Verteenwoordiging**

Oorweeg 'n eenvoudige neurale netwerk met een versteekte laag:

<figure><img src="../../images/image (5) (1).png" alt=""><figcaption></figcaption></figure>

### **4. PyTorch Implementasie**

PyTorch vereenvoudig hierdie proses met sy autograd enjin.
```python
import torch
import torch.nn as nn
import torch.optim as optim

# Define a simple neural network
class SimpleNet(nn.Module):
def __init__(self):
super(SimpleNet, self).__init__()
self.fc1 = nn.Linear(10, 5)  # Input layer to hidden layer
self.relu = nn.ReLU()
self.fc2 = nn.Linear(5, 1)   # Hidden layer to output layer
self.sigmoid = nn.Sigmoid()

def forward(self, x):
h = self.relu(self.fc1(x))
y_hat = self.sigmoid(self.fc2(h))
return y_hat

# Instantiate the network
net = SimpleNet()

# Define loss function and optimizer
criterion = nn.BCELoss()
optimizer = optim.SGD(net.parameters(), lr=0.01)

# Sample data
inputs = torch.randn(1, 10)
labels = torch.tensor([1.0])

# Training loop
optimizer.zero_grad()          # Clear gradients
outputs = net(inputs)          # Forward pass
loss = criterion(outputs, labels)  # Compute loss
loss.backward()                # Backward pass (compute gradients)
optimizer.step()               # Update parameters

# Accessing gradients
for name, param in net.named_parameters():
if param.requires_grad:
print(f"Gradient of {name}: {param.grad}")
```
In hierdie kode:

- **Voorwaartse Deurloop:** Bereken die uitsette van die netwerk.
- **Achterwaartse Deurloop:** `loss.backward()` bereken die gradiënte van die verlies ten opsigte van alle parameters.
- **Parameter Opdatering:** `optimizer.step()` werk die parameters op gebaseer op die berekende gradiënte.

### **5. Verstaan van die Achterwaartse Deurloop**

Tydens die agterwaartse deurloop:

- PyTorch traverseer die berekeningsgrafiek in omgekeerde volgorde.
- Vir elke operasie, pas dit die kettingreël toe om gradiënte te bereken.
- Gradiënte word opgelaai in die `.grad` eienskap van elke parameter tensor.

### **6. Voordele van Outomatiese Differensiasie**

- **Doeltreffendheid:** Vermy oorbodige berekeninge deur tussenresultate te hergebruik.
- **Nauwkeurigheid:** Verskaf presiese afgeleides tot masjienpresisie.
- **Gebruiksgemak:** Elimineer handmatige berekening van afgeleides.
