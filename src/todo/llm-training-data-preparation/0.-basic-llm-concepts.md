# 0. Conceitos Básicos de LLM

## Pré-treinamento

O pré-treinamento é a fase fundamental no desenvolvimento de um modelo de linguagem grande (LLM), onde o modelo é exposto a vastas e diversas quantidades de dados textuais. Durante esta etapa, **o LLM aprende as estruturas, padrões e nuances fundamentais da linguagem**, incluindo gramática, vocabulário, sintaxe e relações contextuais. Ao processar esses dados extensos, o modelo adquire uma ampla compreensão da linguagem e do conhecimento geral do mundo. Essa base abrangente permite que o LLM gere texto coerente e contextualmente relevante. Subsequentemente, esse modelo pré-treinado pode passar por um ajuste fino, onde é treinado ainda mais em conjuntos de dados especializados para adaptar suas capacidades a tarefas ou domínios específicos, melhorando seu desempenho e relevância em aplicações direcionadas.

## Principais componentes do LLM

Geralmente, um LLM é caracterizado pela configuração usada para treiná-lo. Estes são os componentes comuns ao treinar um LLM:

- **Parâmetros**: Parâmetros são os **pesos e viéses aprendíveis** na rede neural. Estes são os números que o processo de treinamento ajusta para minimizar a função de perda e melhorar o desempenho do modelo na tarefa. LLMs geralmente usam milhões de parâmetros.
- **Comprimento do Contexto**: Este é o comprimento máximo de cada frase usada para pré-treinar o LLM.
- **Dimensão de Embedding**: O tamanho do vetor usado para representar cada token ou palavra. LLMs geralmente usam bilhões de dimensões.
- **Dimensão Oculta**: O tamanho das camadas ocultas na rede neural.
- **Número de Camadas (Profundidade)**: Quantas camadas o modelo possui. LLMs geralmente usam dezenas de camadas.
- **Número de Cabeças de Atenção**: Em modelos transformer, este é o número de mecanismos de atenção separados usados em cada camada. LLMs geralmente usam dezenas de cabeças.
- **Dropout**: Dropout é algo como a porcentagem de dados que é removida (as probabilidades se tornam 0) durante o treinamento usado para **prevenir overfitting.** LLMs geralmente usam entre 0-20%.

Configuração do modelo GPT-2:
```json
GPT_CONFIG_124M = {
"vocab_size": 50257,  // Vocabulary size of the BPE tokenizer
"context_length": 1024, // Context length
"emb_dim": 768,       // Embedding dimension
"n_heads": 12,        // Number of attention heads
"n_layers": 12,       // Number of layers
"drop_rate": 0.1,     // Dropout rate: 10%
"qkv_bias": False     // Query-Key-Value bias
}
```
## Tensors em PyTorch

Em PyTorch, um **tensor** é uma estrutura de dados fundamental que serve como um array multidimensional, generalizando conceitos como escalares, vetores e matrizes para dimensões potencialmente mais altas. Tensors são a principal forma como os dados são representados e manipulados em PyTorch, especialmente no contexto de aprendizado profundo e redes neurais.

### Conceito Matemático de Tensors

- **Escalares**: Tensors de rank 0, representando um único número (zero-dimensional). Como: 5
- **Vetores**: Tensors de rank 1, representando um array unidimensional de números. Como: \[5,1]
- **Matrizes**: Tensors de rank 2, representando arrays bidimensionais com linhas e colunas. Como: \[\[1,3], \[5,2]]
- **Tensors de Rank Superior**: Tensors de rank 3 ou mais, representando dados em dimensões superiores (por exemplo, tensors 3D para imagens coloridas).

### Tensors como Contêineres de Dados

De uma perspectiva computacional, os tensors atuam como contêineres para dados multidimensionais, onde cada dimensão pode representar diferentes características ou aspectos dos dados. Isso torna os tensors altamente adequados para lidar com conjuntos de dados complexos em tarefas de aprendizado de máquina.

### Tensors PyTorch vs. Arrays NumPy

Embora os tensors PyTorch sejam semelhantes aos arrays NumPy em sua capacidade de armazenar e manipular dados numéricos, eles oferecem funcionalidades adicionais cruciais para aprendizado profundo:

- **Diferenciação Automática**: Tensors PyTorch suportam o cálculo automático de gradientes (autograd), o que simplifica o processo de computação de derivadas necessárias para treinar redes neurais.
- **Aceleração por GPU**: Tensors em PyTorch podem ser movidos e computados em GPUs, acelerando significativamente cálculos em larga escala.

### Criando Tensors em PyTorch

Você pode criar tensors usando a função `torch.tensor`:
```python
pythonCopy codeimport torch

# Scalar (0D tensor)
tensor0d = torch.tensor(1)

# Vector (1D tensor)
tensor1d = torch.tensor([1, 2, 3])

# Matrix (2D tensor)
tensor2d = torch.tensor([[1, 2],
[3, 4]])

# 3D Tensor
tensor3d = torch.tensor([[[1, 2], [3, 4]],
[[5, 6], [7, 8]]])
```
### Tipos de Dados de Tensor

Tensores PyTorch podem armazenar dados de vários tipos, como inteiros e números de ponto flutuante.&#x20;

Você pode verificar o tipo de dado de um tensor usando o atributo `.dtype`:
```python
tensor1d = torch.tensor([1, 2, 3])
print(tensor1d.dtype)  # Output: torch.int64
```
- Tensores criados a partir de inteiros Python são do tipo `torch.int64`.
- Tensores criados a partir de floats Python são do tipo `torch.float32`.

Para mudar o tipo de dados de um tensor, use o método `.to()`:
```python
float_tensor = tensor1d.to(torch.float32)
print(float_tensor.dtype)  # Output: torch.float32
```
### Operações Comuns de Tensor

PyTorch fornece uma variedade de operações para manipular tensores:

- **Acessando a Forma**: Use `.shape` para obter as dimensões de um tensor.

```python
print(tensor2d.shape)  # Saída: torch.Size([2, 2])
```

- **Redimensionando Tensores**: Use `.reshape()` ou `.view()` para mudar a forma.

```python
reshaped = tensor2d.reshape(4, 1)
```

- **Transpondo Tensores**: Use `.T` para transpor um tensor 2D.

```python
transposed = tensor2d.T
```

- **Multiplicação de Matrizes**: Use `.matmul()` ou o operador `@`.

```python
result = tensor2d @ tensor2d.T
```

### Importância no Aprendizado Profundo

Tensores são essenciais no PyTorch para construir e treinar redes neurais:

- Eles armazenam dados de entrada, pesos e viés.
- Facilitam operações necessárias para passes para frente e para trás em algoritmos de treinamento.
- Com autograd, tensores permitem o cálculo automático de gradientes, simplificando o processo de otimização.

## Diferenciação Automática

A diferenciação automática (AD) é uma técnica computacional usada para **avaliar as derivadas (gradientes)** de funções de forma eficiente e precisa. No contexto de redes neurais, a AD permite o cálculo de gradientes necessários para **algoritmos de otimização como o gradiente descendente**. O PyTorch fornece um mecanismo de diferenciação automática chamado **autograd** que simplifica esse processo.

### Explicação Matemática da Diferenciação Automática

**1. A Regra da Cadeia**

No cerne da diferenciação automática está a **regra da cadeia** do cálculo. A regra da cadeia afirma que se você tem uma composição de funções, a derivada da função composta é o produto das derivadas das funções compostas.

Matematicamente, se `y=f(u)` e `u=g(x)`, então a derivada de `y` em relação a `x` é:

<figure><img src="../../images/image (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**2. Grafo Computacional**

Na AD, os cálculos são representados como nós em um **grafo computacional**, onde cada nó corresponde a uma operação ou uma variável. Ao percorrer esse grafo, podemos calcular derivadas de forma eficiente.

3. Exemplo

Vamos considerar uma função simples:

<figure><img src="../../images/image (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Onde:

- `σ(z)` é a função sigmoide.
- `y=1.0` é o rótulo alvo.
- `L` é a perda.

Queremos calcular o gradiente da perda `L` em relação ao peso `w` e ao viés `b`.

**4. Calculando Gradientes Manualmente**

<figure><img src="../../images/image (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

**5. Cálculo Numérico**

<figure><img src="../../images/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Implementando Diferenciação Automática no PyTorch

Agora, vamos ver como o PyTorch automatiza esse processo.
```python
pythonCopy codeimport torch
import torch.nn.functional as F

# Define input and target
x = torch.tensor([1.1])
y = torch.tensor([1.0])

# Initialize weights with requires_grad=True to track computations
w = torch.tensor([2.2], requires_grad=True)
b = torch.tensor([0.0], requires_grad=True)

# Forward pass
z = x * w + b
a = torch.sigmoid(z)
loss = F.binary_cross_entropy(a, y)

# Backward pass
loss.backward()

# Gradients
print("Gradient w.r.t w:", w.grad)
print("Gradient w.r.t b:", b.grad)
```
**Saída:**
```css
cssCopy codeGradient w.r.t w: tensor([-0.0898])
Gradient w.r.t b: tensor([-0.0817])
```
## Retropropagação em Redes Neurais Maiores

### **1. Estendendo para Redes Multicamadas**

Em redes neurais maiores com múltiplas camadas, o processo de computação de gradientes se torna mais complexo devido ao aumento do número de parâmetros e operações. No entanto, os princípios fundamentais permanecem os mesmos:

- **Passagem Direta:** Calcule a saída da rede passando as entradas por cada camada.
- **Calcule a Perda:** Avalie a função de perda usando a saída da rede e os rótulos alvo.
- **Passagem Reversa (Retropropagação):** Calcule os gradientes da perda em relação a cada parâmetro na rede aplicando a regra da cadeia recursivamente da camada de saída de volta para a camada de entrada.

### **2. Algoritmo de Retropropagação**

- **Passo 1:** Inicialize os parâmetros da rede (pesos e viéses).
- **Passo 2:** Para cada exemplo de treinamento, realize uma passagem direta para calcular as saídas.
- **Passo 3:** Calcule a perda.
- **Passo 4:** Calcule os gradientes da perda em relação a cada parâmetro usando a regra da cadeia.
- **Passo 5:** Atualize os parâmetros usando um algoritmo de otimização (por exemplo, descida de gradiente).

### **3. Representação Matemática**

Considere uma rede neural simples com uma camada oculta:

<figure><img src="../../images/image (5) (1).png" alt=""><figcaption></figcaption></figure>

### **4. Implementação em PyTorch**

PyTorch simplifica esse processo com seu motor autograd.
```python
import torch
import torch.nn as nn
import torch.optim as optim

# Define a simple neural network
class SimpleNet(nn.Module):
def __init__(self):
super(SimpleNet, self).__init__()
self.fc1 = nn.Linear(10, 5)  # Input layer to hidden layer
self.relu = nn.ReLU()
self.fc2 = nn.Linear(5, 1)   # Hidden layer to output layer
self.sigmoid = nn.Sigmoid()

def forward(self, x):
h = self.relu(self.fc1(x))
y_hat = self.sigmoid(self.fc2(h))
return y_hat

# Instantiate the network
net = SimpleNet()

# Define loss function and optimizer
criterion = nn.BCELoss()
optimizer = optim.SGD(net.parameters(), lr=0.01)

# Sample data
inputs = torch.randn(1, 10)
labels = torch.tensor([1.0])

# Training loop
optimizer.zero_grad()          # Clear gradients
outputs = net(inputs)          # Forward pass
loss = criterion(outputs, labels)  # Compute loss
loss.backward()                # Backward pass (compute gradients)
optimizer.step()               # Update parameters

# Accessing gradients
for name, param in net.named_parameters():
if param.requires_grad:
print(f"Gradient of {name}: {param.grad}")
```
Neste código:

- **Forward Pass:** Computa as saídas da rede.
- **Backward Pass:** `loss.backward()` computa os gradientes da perda em relação a todos os parâmetros.
- **Parameter Update:** `optimizer.step()` atualiza os parâmetros com base nos gradientes computados.

### **5. Entendendo o Backward Pass**

Durante o backward pass:

- PyTorch percorre o grafo computacional em ordem reversa.
- Para cada operação, aplica a regra da cadeia para computar gradientes.
- Gradientes são acumulados no atributo `.grad` de cada tensor de parâmetro.

### **6. Vantagens da Diferenciação Automática**

- **Eficiência:** Evita cálculos redundantes reutilizando resultados intermediários.
- **Precisão:** Fornece derivadas exatas até a precisão da máquina.
- **Facilidade de Uso:** Elimina o cálculo manual de derivadas.
