# 3. Token Embeddings

## Token Embeddings

Na die tokenisering van teksdata, is die volgende kritieke stap in die voorbereiding van data vir die opleiding van groot taalmodelle (LLMs) soos GPT die skep van **token embeddings**. Token embeddings transformeer diskrete tokens (soos woorde of subwoorde) in deurlopende numeriese vektore wat die model kan verwerk en daaruit kan leer. Hierdie verduideliking breek token embeddings, hul inisialisering, gebruik, en die rol van posisionele embeddings in die verbetering van die model se begrip van tokenreekse af.

> [!TIP]
> Die doel van hierdie derde fase is baie eenvoudig: **Ken elkeen van die vorige tokens in die woordeskat 'n vektor van die verlangde dimensies toe om die model op te lei.** Elke woord in die woordeskat sal 'n punt in 'n ruimte van X dimensies wees.\
> Let daarop dat die posisie van elke woord in die ruimte aanvanklik net "random" geinisialiseer word en hierdie posisies is opleibare parameters (sal verbeter word tydens die opleiding).
>
> Boonop, tydens die token embedding **word 'n ander laag van embeddings geskep** wat (in hierdie geval) die **absolute posisie van die woord in die opleidingssin** verteenwoordig. Op hierdie manier sal 'n woord in verskillende posisies in die sin 'n ander voorstelling (betekenis) hê.

### **What Are Token Embeddings?**

**Token Embeddings** is numeriese verteenwoordigings van tokens in 'n deurlopende vektorruimte. Elke token in die woordeskat is geassosieer met 'n unieke vektor van vaste dimensies. Hierdie vektore vang semantiese en sintaktiese inligting oor die tokens vas, wat die model in staat stel om verhoudings en patrone in die data te verstaan.

- **Vocabulary Size:** Die totale aantal unieke tokens (bv. woorde, subwoorde) in die model se woordeskat.
- **Embedding Dimensions:** Die aantal numeriese waardes (dimensies) in elke token se vektor. Hoër dimensies kan meer genuanseerde inligting vasvang, maar vereis meer rekenaarhulpbronne.

**Example:**

- **Vocabulary Size:** 6 tokens \[1, 2, 3, 4, 5, 6]
- **Embedding Dimensions:** 3 (x, y, z)

### **Initializing Token Embeddings**

Aan die begin van die opleiding, word token embeddings tipies met klein random waardes geinisialiseer. Hierdie aanvanklike waardes word aangepas (fyngestem) tydens opleiding om die tokens se betekenisse beter te verteenwoordig op grond van die opleidingsdata.

**PyTorch Example:**
```python
import torch

# Set a random seed for reproducibility
torch.manual_seed(123)

# Create an embedding layer with 6 tokens and 3 dimensions
embedding_layer = torch.nn.Embedding(6, 3)

# Display the initial weights (embeddings)
print(embedding_layer.weight)
```
**Uitset:**
```lua
luaCopy codeParameter containing:
tensor([[ 0.3374, -0.1778, -0.1690],
[ 0.9178,  1.5810,  1.3010],
[ 1.2753, -0.2010, -0.1606],
[-0.4015,  0.9666, -1.1481],
[-1.1589,  0.3255, -0.6315],
[-2.8400, -0.7849, -1.4096]], requires_grad=True)
```
**Verklaring:**

- Elke ry kom ooreen met 'n token in die woordeskat.
- Elke kolom verteenwoordig 'n dimensie in die inbedingsvektor.
- Byvoorbeeld, die token op indeks `3` het 'n inbedingsvektor `[-0.4015, 0.9666, -1.1481]`.

**Toegang tot 'n Token se Inbeding:**
```python
# Retrieve the embedding for the token at index 3
token_index = torch.tensor([3])
print(embedding_layer(token_index))
```
**Uitset:**
```lua
tensor([[-0.4015,  0.9666, -1.1481]], grad_fn=<EmbeddingBackward0>)
```
**Interpretasie:**

- Die token by indeks `3` word verteenwoordig deur die vektor `[-0.4015, 0.9666, -1.1481]`.
- Hierdie waardes is opleidingsparameters wat die model tydens opleiding sal aanpas om die token se konteks en betekenis beter te verteenwoordig.

### **Hoe Token Embeddings Werk Tydens Opleiding**

Tydens opleiding word elke token in die invoerdata omgeskakel na sy ooreenstemmende embedding vektor. Hierdie vektore word dan in verskeie berekeninge binne die model gebruik, soos aandagmeganismes en neurale netwerklae.

**Voorbeeld Scenario:**

- **Batch Grootte:** 8 (aantal monsters wat gelyktydig verwerk word)
- **Max Volgorde Lengte:** 4 (aantal tokens per monster)
- **Embedding Dimensies:** 256

**Data Struktuur:**

- Elke batch word verteenwoordig as 'n 3D tensor met die vorm `(batch_size, max_length, embedding_dim)`.
- Vir ons voorbeeld sou die vorm wees `(8, 4, 256)`.

**Visualisering:**
```css
cssCopy codeBatch
┌─────────────┐
│ Sample 1    │
│ ┌─────┐     │
│ │Token│ → [x₁₁, x₁₂, ..., x₁₂₅₆]
│ │ 1   │     │
│ │...  │     │
│ │Token│     │
│ │ 4   │     │
│ └─────┘     │
│ Sample 2    │
│ ┌─────┐     │
│ │Token│ → [x₂₁, x₂₂, ..., x₂₂₅₆]
│ │ 1   │     │
│ │...  │     │
│ │Token│     │
│ │ 4   │     │
│ └─────┘     │
│ ...         │
│ Sample 8    │
│ ┌─────┐     │
│ │Token│ → [x₈₁, x₈₂, ..., x₈₂₅₆]
│ │ 1   │     │
│ │...  │     │
│ │Token│     │
│ │ 4   │     │
│ └─────┘     │
└─────────────┘
```
**Verklaring:**

- Elke token in die reeks word verteenwoordig deur 'n 256-dimensionele vektor.
- Die model verwerk hierdie embeddings om taalpatrone te leer en voorspellings te genereer.

## **Posisionele Embeddings: Voeg Konteks by Token Embeddings**

Terwyl token embeddings die betekenis van individuele tokens vasvang, kodeer hulle nie inherent die posisie van tokens binne 'n reeks nie. Om die volgorde van tokens te verstaan, is noodsaaklik vir taalbegrip. Dit is waar **posisionele embeddings** in die prentjie kom.

### **Waarom Posisionele Embeddings Benodig Word:**

- **Token Volgorde Maak Saak:** In sinne hang die betekenis dikwels af van die volgorde van woorde. Byvoorbeeld, "Die kat het op die mat gesit" teenoor "Die mat het op die kat gesit."
- **Embedding Beperking:** Sonder posisionele inligting behandel die model tokens as 'n "sak van woorde," terwyl hulle hul volgorde ignoreer.

### **Tipes van Posisionele Embeddings:**

1. **Absoluut Posisionele Embeddings:**
- Ken 'n unieke posisie vektor aan elke posisie in die reeks toe.
- **Voorbeeld:** Die eerste token in enige reeks het dieselfde posisionele embedding, die tweede token het 'n ander, en so aan.
- **Gebruik Deur:** OpenAI se GPT-modelle.
2. **Relatiewe Posisionele Embeddings:**
- Kodeer die relatiewe afstand tussen tokens eerder as hul absolute posisies.
- **Voorbeeld:** Dui aan hoe ver twee tokens van mekaar af is, ongeag hul absolute posisies in die reeks.
- **Gebruik Deur:** Modelle soos Transformer-XL en sommige variasies van BERT.

### **Hoe Posisionele Embeddings Geïntegreer Word:**

- **Dieselfde Dimensies:** Posisionele embeddings het dieselfde dimensionaliteit as token embeddings.
- **Byvoeging:** Hulle word by token embeddings gevoeg, wat token identiteit kombineer met posisionele inligting sonder om die algehele dimensionaliteit te verhoog.

**Voorbeeld van Byvoeging van Posisionele Embeddings:**

Neem aan 'n token embedding vektor is `[0.5, -0.2, 0.1]` en sy posisionele embedding vektor is `[0.1, 0.3, -0.1]`. Die gekombineerde embedding wat deur die model gebruik word, sou wees:
```css
Combined Embedding = Token Embedding + Positional Embedding
= [0.5 + 0.1, -0.2 + 0.3, 0.1 + (-0.1)]
= [0.6, 0.1, 0.0]
```
**Voordele van Posisionele Embeddings:**

- **Kontextuele Bewustheid:** Die model kan tussen tokens onderskei op grond van hul posisies.
- **Volgorde Begrip:** Stel die model in staat om grammatika, sintaksis en kontekstafhanklike betekenisse te verstaan.

## Kode Voorbeeld

Volg met die kode voorbeeld van [https://github.com/rasbt/LLMs-from-scratch/blob/main/ch02/01_main-chapter-code/ch02.ipynb](https://github.com/rasbt/LLMs-from-scratch/blob/main/ch02/01_main-chapter-code/ch02.ipynb):
```python
# Use previous code...

# Create dimensional emdeddings
"""
BPE uses a vocabulary of 50257 words
Let's supose we want to use 256 dimensions (instead of the millions used by LLMs)
"""

vocab_size = 50257
output_dim = 256
token_embedding_layer = torch.nn.Embedding(vocab_size, output_dim)

## Generate the dataloader like before
max_length = 4
dataloader = create_dataloader_v1(
raw_text, batch_size=8, max_length=max_length,
stride=max_length, shuffle=False
)
data_iter = iter(dataloader)
inputs, targets = next(data_iter)

# Apply embeddings
token_embeddings = token_embedding_layer(inputs)
print(token_embeddings.shape)
torch.Size([8, 4, 256]) # 8 x 4 x 256

# Generate absolute embeddings
context_length = max_length
pos_embedding_layer = torch.nn.Embedding(context_length, output_dim)

pos_embeddings = pos_embedding_layer(torch.arange(max_length))

input_embeddings = token_embeddings + pos_embeddings
print(input_embeddings.shape) # torch.Size([8, 4, 256])
```
## Verwysings

- [https://www.manning.com/books/build-a-large-language-model-from-scratch](https://www.manning.com/books/build-a-large-language-model-from-scratch)
