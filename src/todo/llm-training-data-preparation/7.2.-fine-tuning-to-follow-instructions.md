# 7.2. Ajuste Fino para Seguir Instruções

> [!TIP]
> O objetivo desta seção é mostrar como **ajustar finamente um modelo já pré-treinado para seguir instruções** em vez de apenas gerar texto, por exemplo, respondendo a tarefas como um chatbot.

## Conjunto de Dados

Para ajustar finamente um LLM para seguir instruções, é necessário ter um conjunto de dados com instruções e respostas para ajustar o LLM. Existem diferentes formatos para treinar um LLM a seguir instruções, por exemplo:

- O exemplo de estilo de prompt Apply Alpaca:
```csharp
Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
Calculate the area of a circle with a radius of 5 units.

### Response:
The area of a circle is calculated using the formula \( A = \pi r^2 \). Plugging in the radius of 5 units:

\( A = \pi (5)^2 = \pi \times 25 = 25\pi \) square units.
```
- Exemplo de Estilo de Prompt Phi-3:
```vbnet
<|User|>
Can you explain what gravity is in simple terms?

<|Assistant|>
Absolutely! Gravity is a force that pulls objects toward each other.
```
Treinar um LLM com esses tipos de conjuntos de dados em vez de apenas texto bruto ajuda o LLM a entender que ele precisa fornecer respostas específicas às perguntas que recebe.

Portanto, uma das primeiras coisas a fazer com um conjunto de dados que contém solicitações e respostas é modelar esses dados no formato de prompt desejado, como:
```python
# Code from https://github.com/rasbt/LLMs-from-scratch/blob/main/ch07/01_main-chapter-code/ch07.ipynb
def format_input(entry):
instruction_text = (
f"Below is an instruction that describes a task. "
f"Write a response that appropriately completes the request."
f"\n\n### Instruction:\n{entry['instruction']}"
)

input_text = f"\n\n### Input:\n{entry['input']}" if entry["input"] else ""

return instruction_text + input_text

model_input = format_input(data[50])

desired_response = f"\n\n### Response:\n{data[50]['output']}"

print(model_input + desired_response)
```
Então, como sempre, é necessário separar o conjunto de dados em conjuntos para treinamento, validação e teste.

## Batching & Data Loaders

Então, é necessário agrupar todas as entradas e saídas esperadas para o treinamento. Para isso, é necessário:

- Tokenizar os textos
- Preencher todas as amostras para o mesmo comprimento (geralmente o comprimento será tão grande quanto o comprimento do contexto usado para pré-treinar o LLM)
- Criar os tokens esperados deslocando 1 a entrada em uma função de colagem personalizada
- Substituir alguns tokens de preenchimento por -100 para excluí-los da perda de treinamento: Após o primeiro token `endoftext`, substituir todos os outros tokens `endoftext` por -100 (porque usar `cross_entropy(...,ignore_index=-100)` significa que ele ignorará alvos com -100)
- \[Opcional] Mascarar usando -100 também todos os tokens pertencentes à pergunta para que o LLM aprenda apenas a gerar a resposta. No estilo Apply Alpaca, isso significará mascarar tudo até `### Response:`

Com isso criado, é hora de criar os carregadores de dados para cada conjunto de dados (treinamento, validação e teste).

## Load pre-trained LLM & Fine tune & Loss Checking

É necessário carregar um LLM pré-treinado para ajustá-lo. Isso já foi discutido em outras páginas. Então, é possível usar a função de treinamento previamente utilizada para ajustar o LLM.

Durante o treinamento, também é possível ver como a perda de treinamento e a perda de validação variam durante as épocas para ver se a perda está sendo reduzida e se o overfitting está ocorrendo.\
Lembre-se de que o overfitting ocorre quando a perda de treinamento está sendo reduzida, mas a perda de validação não está sendo reduzida ou até mesmo aumentando. Para evitar isso, a coisa mais simples a fazer é parar o treinamento na época em que esse comportamento começa.

## Response Quality

Como este não é um ajuste fino de classificação onde é possível confiar mais nas variações de perda, também é importante verificar a qualidade das respostas no conjunto de teste. Portanto, é recomendado reunir as respostas geradas de todos os conjuntos de teste e **verificar sua qualidade manualmente** para ver se há respostas erradas (note que é possível que o LLM crie corretamente o formato e a sintaxe da frase de resposta, mas dê uma resposta completamente errada. A variação da perda não refletirá esse comportamento).\
Note que também é possível realizar essa revisão passando as respostas geradas e as respostas esperadas para **outros LLMs e pedir que avaliem as respostas**.

Outros testes a serem realizados para verificar a qualidade das respostas:

1. **Measuring Massive Multitask Language Understanding (**[**MMLU**](https://arxiv.org/abs/2009.03300)**):** MMLU avalia o conhecimento e as habilidades de resolução de problemas de um modelo em 57 disciplinas, incluindo humanidades, ciências e mais. Ele usa perguntas de múltipla escolha para avaliar a compreensão em vários níveis de dificuldade, desde o elementar até o profissional avançado.
2. [**LMSYS Chatbot Arena**](https://arena.lmsys.org): Esta plataforma permite que os usuários comparem respostas de diferentes chatbots lado a lado. Os usuários inserem um prompt, e vários chatbots geram respostas que podem ser comparadas diretamente.
3. [**AlpacaEval**](https://github.com/tatsu-lab/alpaca_eval)**:** AlpacaEval é uma estrutura de avaliação automatizada onde um LLM avançado como o GPT-4 avalia as respostas de outros modelos a vários prompts.
4. **General Language Understanding Evaluation (**[**GLUE**](https://gluebenchmark.com/)**):** GLUE é uma coleção de nove tarefas de compreensão de linguagem natural, incluindo análise de sentimento, implicação textual e resposta a perguntas.
5. [**SuperGLUE**](https://super.gluebenchmark.com/)**:** Construindo sobre o GLUE, o SuperGLUE inclui tarefas mais desafiadoras projetadas para serem difíceis para os modelos atuais.
6. **Beyond the Imitation Game Benchmark (**[**BIG-bench**](https://github.com/google/BIG-bench)**):** BIG-bench é um benchmark em larga escala com mais de 200 tarefas que testam as habilidades de um modelo em áreas como raciocínio, tradução e resposta a perguntas.
7. **Holistic Evaluation of Language Models (**[**HELM**](https://crfm.stanford.edu/helm/lite/latest/)**):** HELM fornece uma avaliação abrangente em várias métricas, como precisão, robustez e justiça.
8. [**OpenAI Evals**](https://github.com/openai/evals)**:** Uma estrutura de avaliação de código aberto da OpenAI que permite testar modelos de IA em tarefas personalizadas e padronizadas.
9. [**HumanEval**](https://github.com/openai/human-eval)**:** Uma coleção de problemas de programação usados para avaliar as habilidades de geração de código de modelos de linguagem.
10. **Stanford Question Answering Dataset (**[**SQuAD**](https://rajpurkar.github.io/SQuAD-explorer/)**):** SQuAD consiste em perguntas sobre artigos da Wikipedia, onde os modelos devem compreender o texto para responder com precisão.
11. [**TriviaQA**](https://nlp.cs.washington.edu/triviaqa/)**:** Um conjunto de dados em larga escala de perguntas e respostas de trivia, juntamente com documentos de evidência.

e muitos outros

## Follow instructions fine-tuning code

Você pode encontrar um exemplo do código para realizar esse ajuste fino em [https://github.com/rasbt/LLMs-from-scratch/blob/main/ch07/01_main-chapter-code/gpt_instruction_finetuning.py](https://github.com/rasbt/LLMs-from-scratch/blob/main/ch07/01_main-chapter-code/gpt_instruction_finetuning.py)

## References

- [https://www.manning.com/books/build-a-large-language-model-from-scratch](https://www.manning.com/books/build-a-large-language-model-from-scratch)
