# 7.2. Ajuste fino para seguir instrucciones

> [!TIP]
> El objetivo de esta sección es mostrar cómo **ajustar finamente un modelo ya preentrenado para seguir instrucciones** en lugar de solo generar texto, por ejemplo, respondiendo a tareas como un chatbot.

## Conjunto de datos

Para ajustar finamente un LLM para seguir instrucciones, es necesario tener un conjunto de datos con instrucciones y respuestas para ajustar el LLM. Hay diferentes formatos para entrenar un LLM en seguir instrucciones, por ejemplo:

- El estilo de prompt de Apply Alpaca:
```csharp
Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
Calculate the area of a circle with a radius of 5 units.

### Response:
The area of a circle is calculated using the formula \( A = \pi r^2 \). Plugging in the radius of 5 units:

\( A = \pi (5)^2 = \pi \times 25 = 25\pi \) square units.
```
- Ejemplo de Estilo de Prompt Phi-3:
```vbnet
<|User|>
Can you explain what gravity is in simple terms?

<|Assistant|>
Absolutely! Gravity is a force that pulls objects toward each other.
```
Entrenar un LLM con este tipo de conjuntos de datos en lugar de solo texto sin procesar ayuda al LLM a entender que necesita dar respuestas específicas a las preguntas que recibe.

Por lo tanto, una de las primeras cosas que se deben hacer con un conjunto de datos que contiene solicitudes y respuestas es modelar esa fecha en el formato de aviso deseado, como:
```python
# Code from https://github.com/rasbt/LLMs-from-scratch/blob/main/ch07/01_main-chapter-code/ch07.ipynb
def format_input(entry):
instruction_text = (
f"Below is an instruction that describes a task. "
f"Write a response that appropriately completes the request."
f"\n\n### Instruction:\n{entry['instruction']}"
)

input_text = f"\n\n### Input:\n{entry['input']}" if entry["input"] else ""

return instruction_text + input_text

model_input = format_input(data[50])

desired_response = f"\n\n### Response:\n{data[50]['output']}"

print(model_input + desired_response)
```
Luego, como siempre, es necesario separar el conjunto de datos en conjuntos para entrenamiento, validación y prueba.

## Batching & Data Loaders

Luego, es necesario agrupar todas las entradas y salidas esperadas para el entrenamiento. Para esto, es necesario:

- Tokenizar los textos
- Rellenar todas las muestras a la misma longitud (generalmente la longitud será tan grande como la longitud del contexto utilizado para pre-entrenar el LLM)
- Crear los tokens esperados desplazando 1 la entrada en una función de colación personalizada
- Reemplazar algunos tokens de relleno con -100 para excluirlos de la pérdida de entrenamiento: Después del primer token `endoftext`, sustituir todos los otros tokens `endoftext` por -100 (porque usar `cross_entropy(...,ignore_index=-100)` significa que ignorará los objetivos con -100)
- \[Opcional] Enmascarar usando -100 también todos los tokens que pertenecen a la pregunta para que el LLM aprenda solo a generar la respuesta. En el estilo de Apply Alpaca, esto significará enmascarar todo hasta `### Response:`

Con esto creado, es hora de crear los cargadores de datos para cada conjunto de datos (entrenamiento, validación y prueba).

## Load pre-trained LLM & Fine tune & Loss Checking

Es necesario cargar un LLM pre-entrenado para ajustarlo. Esto ya se discutió en otras páginas. Luego, es posible usar la función de entrenamiento utilizada anteriormente para ajustar el LLM.

Durante el entrenamiento también es posible ver cómo varía la pérdida de entrenamiento y la pérdida de validación durante las épocas para ver si la pérdida se está reduciendo y si está ocurriendo sobreajuste.\
Recuerda que el sobreajuste ocurre cuando la pérdida de entrenamiento se está reduciendo pero la pérdida de validación no se está reduciendo o incluso está aumentando. Para evitar esto, lo más sencillo es detener el entrenamiento en la época donde comienza este comportamiento.

## Response Quality

Como esto no es un ajuste fino de clasificación donde es posible confiar más en las variaciones de pérdida, también es importante verificar la calidad de las respuestas en el conjunto de prueba. Por lo tanto, se recomienda recopilar las respuestas generadas de todos los conjuntos de prueba y **verificar su calidad manualmente** para ver si hay respuestas incorrectas (ten en cuenta que es posible que el LLM cree correctamente el formato y la sintaxis de la oración de respuesta pero dé una respuesta completamente incorrecta. La variación de pérdida no reflejará este comportamiento).\
Ten en cuenta que también es posible realizar esta revisión pasando las respuestas generadas y las respuestas esperadas a **otros LLMs y pidiéndoles que evalúen las respuestas**.

Otra prueba para ejecutar para verificar la calidad de las respuestas:

1. **Measuring Massive Multitask Language Understanding (**[**MMLU**](https://arxiv.org/abs/2009.03300)**):** MMLU evalúa el conocimiento y las habilidades de resolución de problemas de un modelo en 57 materias, incluidas humanidades, ciencias y más. Utiliza preguntas de opción múltiple para evaluar la comprensión en varios niveles de dificultad, desde elemental hasta profesional avanzado.
2. [**LMSYS Chatbot Arena**](https://arena.lmsys.org): Esta plataforma permite a los usuarios comparar respuestas de diferentes chatbots lado a lado. Los usuarios ingresan un aviso, y múltiples chatbots generan respuestas que se pueden comparar directamente.
3. [**AlpacaEval**](https://github.com/tatsu-lab/alpaca_eval)**:** AlpacaEval es un marco de evaluación automatizado donde un LLM avanzado como GPT-4 evalúa las respuestas de otros modelos a varios avisos.
4. **General Language Understanding Evaluation (**[**GLUE**](https://gluebenchmark.com/)**):** GLUE es una colección de nueve tareas de comprensión del lenguaje natural, incluida el análisis de sentimientos, la implicación textual y la respuesta a preguntas.
5. [**SuperGLUE**](https://super.gluebenchmark.com/)**:** Basándose en GLUE, SuperGLUE incluye tareas más desafiantes diseñadas para ser difíciles para los modelos actuales.
6. **Beyond the Imitation Game Benchmark (**[**BIG-bench**](https://github.com/google/BIG-bench)**):** BIG-bench es un benchmark a gran escala con más de 200 tareas que ponen a prueba las habilidades de un modelo en áreas como razonamiento, traducción y respuesta a preguntas.
7. **Holistic Evaluation of Language Models (**[**HELM**](https://crfm.stanford.edu/helm/lite/latest/)**):** HELM proporciona una evaluación integral a través de varias métricas como precisión, robustez y equidad.
8. [**OpenAI Evals**](https://github.com/openai/evals)**:** Un marco de evaluación de código abierto de OpenAI que permite probar modelos de IA en tareas personalizadas y estandarizadas.
9. [**HumanEval**](https://github.com/openai/human-eval)**:** Una colección de problemas de programación utilizados para evaluar las habilidades de generación de código de los modelos de lenguaje.
10. **Stanford Question Answering Dataset (**[**SQuAD**](https://rajpurkar.github.io/SQuAD-explorer/)**):** SQuAD consiste en preguntas sobre artículos de Wikipedia, donde los modelos deben comprender el texto para responder con precisión.
11. [**TriviaQA**](https://nlp.cs.washington.edu/triviaqa/)**:** Un conjunto de datos a gran escala de preguntas y respuestas de trivia, junto con documentos de evidencia.

y muchos más

## Follow instructions fine-tuning code

Puedes encontrar un ejemplo del código para realizar este ajuste fino en [https://github.com/rasbt/LLMs-from-scratch/blob/main/ch07/01_main-chapter-code/gpt_instruction_finetuning.py](https://github.com/rasbt/LLMs-from-scratch/blob/main/ch07/01_main-chapter-code/gpt_instruction_finetuning.py)

## References

- [https://www.manning.com/books/build-a-large-language-model-from-scratch](https://www.manning.com/books/build-a-large-language-model-from-scratch)
