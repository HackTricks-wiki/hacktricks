# 7.2. Ajustement pour suivre les instructions

> [!TIP]
> L'objectif de cette section est de montrer comment **ajuster un modèle déjà pré-entraîné pour suivre des instructions** plutôt que de simplement générer du texte, par exemple, répondre à des tâches en tant que chatbot.

## Ensemble de données

Pour ajuster un LLM afin de suivre des instructions, il est nécessaire d'avoir un ensemble de données avec des instructions et des réponses pour affiner le LLM. Il existe différents formats pour entraîner un LLM à suivre des instructions, par exemple :

- L'exemple de style de prompt Apply Alpaca :
```csharp
Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
Calculate the area of a circle with a radius of 5 units.

### Response:
The area of a circle is calculated using the formula \( A = \pi r^2 \). Plugging in the radius of 5 units:

\( A = \pi (5)^2 = \pi \times 25 = 25\pi \) square units.
```
- Exemple de style de prompt Phi-3 :
```vbnet
<|User|>
Can you explain what gravity is in simple terms?

<|Assistant|>
Absolutely! Gravity is a force that pulls objects toward each other.
```
Former un LLM avec ce type de jeux de données au lieu de simplement du texte brut aide le LLM à comprendre qu'il doit donner des réponses spécifiques aux questions qu'il reçoit.

Par conséquent, l'une des premières choses à faire avec un ensemble de données contenant des demandes et des réponses est de modéliser ces données dans le format de prompt souhaité, comme :
```python
# Code from https://github.com/rasbt/LLMs-from-scratch/blob/main/ch07/01_main-chapter-code/ch07.ipynb
def format_input(entry):
instruction_text = (
f"Below is an instruction that describes a task. "
f"Write a response that appropriately completes the request."
f"\n\n### Instruction:\n{entry['instruction']}"
)

input_text = f"\n\n### Input:\n{entry['input']}" if entry["input"] else ""

return instruction_text + input_text

model_input = format_input(data[50])

desired_response = f"\n\n### Response:\n{data[50]['output']}"

print(model_input + desired_response)
```
Ensuite, comme toujours, il est nécessaire de séparer le jeu de données en ensembles pour l'entraînement, la validation et le test.

## Batching & Data Loaders

Ensuite, il est nécessaire de regrouper toutes les entrées et sorties attendues pour l'entraînement. Pour cela, il est nécessaire de :

- Tokeniser les textes
- Remplir tous les échantillons à la même longueur (généralement, la longueur sera aussi grande que la longueur de contexte utilisée pour pré-entraîner le LLM)
- Créer les tokens attendus en décalant l'entrée de 1 dans une fonction de collate personnalisée
- Remplacer certains tokens de remplissage par -100 pour les exclure de la perte d'entraînement : Après le premier token `endoftext`, substituer tous les autres tokens `endoftext` par -100 (car l'utilisation de `cross_entropy(...,ignore_index=-100)` signifie qu'il ignorera les cibles avec -100)
- \[Optionnel\] Masquer en utilisant -100 également tous les tokens appartenant à la question afin que le LLM apprenne uniquement à générer la réponse. Dans le style Apply Alpaca, cela signifiera masquer tout jusqu'à `### Response:`

Avec cela créé, il est temps de créer les chargeurs de données pour chaque jeu de données (entraînement, validation et test).

## Load pre-trained LLM & Fine tune & Loss Checking

Il est nécessaire de charger un LLM pré-entraîné pour le peaufiner. Cela a déjà été discuté dans d'autres pages. Ensuite, il est possible d'utiliser la fonction d'entraînement précédemment utilisée pour peaufiner le LLM.

Pendant l'entraînement, il est également possible de voir comment la perte d'entraînement et la perte de validation varient au cours des époques pour voir si la perte diminue et si le surapprentissage se produit.\
Rappelez-vous que le surapprentissage se produit lorsque la perte d'entraînement diminue mais que la perte de validation ne diminue pas ou augmente même. Pour éviter cela, la chose la plus simple à faire est d'arrêter l'entraînement à l'époque où ce comportement commence.

## Response Quality

Comme il ne s'agit pas d'un fine-tuning de classification où il est possible de faire davantage confiance aux variations de perte, il est également important de vérifier la qualité des réponses dans le jeu de test. Par conséquent, il est recommandé de rassembler les réponses générées de tous les jeux de test et **de vérifier leur qualité manuellement** pour voir s'il y a des réponses incorrectes (notez qu'il est possible pour le LLM de créer correctement le format et la syntaxe de la phrase de réponse mais de donner une réponse complètement incorrecte. La variation de perte ne reflétera pas ce comportement).\
Notez qu'il est également possible d'effectuer cette révision en passant les réponses générées et les réponses attendues à **d'autres LLMs et leur demander d'évaluer les réponses**.

Autre test à effectuer pour vérifier la qualité des réponses :

1. **Measuring Massive Multitask Language Understanding (**[**MMLU**](https://arxiv.org/abs/2009.03300)**):** MMLU évalue les connaissances et les capacités de résolution de problèmes d'un modèle à travers 57 sujets, y compris les sciences humaines, les sciences, et plus encore. Il utilise des questions à choix multiples pour évaluer la compréhension à divers niveaux de difficulté, de l'élémentaire au professionnel avancé.
2. [**LMSYS Chatbot Arena**](https://arena.lmsys.org): Cette plateforme permet aux utilisateurs de comparer les réponses de différents chatbots côte à côte. Les utilisateurs saisissent une invite, et plusieurs chatbots génèrent des réponses qui peuvent être directement comparées.
3. [**AlpacaEval**](https://github.com/tatsu-lab/alpaca_eval)**:** AlpacaEval est un cadre d'évaluation automatisé où un LLM avancé comme GPT-4 évalue les réponses d'autres modèles à diverses invites.
4. **General Language Understanding Evaluation (**[**GLUE**](https://gluebenchmark.com/)**):** GLUE est une collection de neuf tâches de compréhension du langage naturel, y compris l'analyse des sentiments, l'implication textuelle et la réponse à des questions.
5. [**SuperGLUE**](https://super.gluebenchmark.com/)**:** S'appuyant sur GLUE, SuperGLUE comprend des tâches plus difficiles conçues pour être difficiles pour les modèles actuels.
6. **Beyond the Imitation Game Benchmark (**[**BIG-bench**](https://github.com/google/BIG-bench)**):** BIG-bench est un benchmark à grande échelle avec plus de 200 tâches qui testent les capacités d'un modèle dans des domaines tels que le raisonnement, la traduction et la réponse à des questions.
7. **Holistic Evaluation of Language Models (**[**HELM**](https://crfm.stanford.edu/helm/lite/latest/)**):** HELM fournit une évaluation complète à travers divers indicateurs comme la précision, la robustesse et l'équité.
8. [**OpenAI Evals**](https://github.com/openai/evals)**:** Un cadre d'évaluation open-source par OpenAI qui permet de tester des modèles d'IA sur des tâches personnalisées et standardisées.
9. [**HumanEval**](https://github.com/openai/human-eval)**:** Une collection de problèmes de programmation utilisés pour évaluer les capacités de génération de code des modèles de langage.
10. **Stanford Question Answering Dataset (**[**SQuAD**](https://rajpurkar.github.io/SQuAD-explorer/)**):** SQuAD se compose de questions sur des articles de Wikipédia, où les modèles doivent comprendre le texte pour répondre avec précision.
11. [**TriviaQA**](https://nlp.cs.washington.edu/triviaqa/)**:** Un ensemble de données à grande échelle de questions et réponses trivia, ainsi que des documents de preuve.

et beaucoup beaucoup plus

## Follow instructions fine-tuning code

Vous pouvez trouver un exemple de code pour effectuer ce fine-tuning à [https://github.com/rasbt/LLMs-from-scratch/blob/main/ch07/01_main-chapter-code/gpt_instruction_finetuning.py](https://github.com/rasbt/LLMs-from-scratch/blob/main/ch07/01_main-chapter-code/gpt_instruction_finetuning.py)

## References

- [https://www.manning.com/books/build-a-large-language-model-from-scratch](https://www.manning.com/books/build-a-large-language-model-from-scratch)
