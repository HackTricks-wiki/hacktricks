# Криптографічні/Компресійні алгоритми

{{#include ../../banners/hacktricks-training.md}}

## Ідентифікація алгоритмів

Якщо при розборі коду ви бачите багато операцій зі зсувами вліво/вправо, xors та кількох арифметичних операцій, дуже ймовірно, що це реалізація криптографічного алгоритму. Тут показано кілька способів ідентифікувати використовуваний алгоритм без необхідності звертати кожен крок в зворотний інжиніринг.

### API-функції

**CryptDeriveKey**

Якщо ця функція використовується, ви можете дізнатися, який **алгоритм використовується**, перевіривши значення другого параметра:

![](<../../images/image (156).png>)

Перегляньте таблицю можливих алгоритмів і їхніх призначених значень: [https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id](https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id)

**RtlCompressBuffer/RtlDecompressBuffer**

Стискає та розпаковує заданий буфер даних.

**CryptAcquireContext**

Згідно з [документацією](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecontexta): функція **CryptAcquireContext** використовується для одержання дескриптора конкретного контейнера ключів у вибраному Cryptographic Service Provider (CSP). **Повернутий дескриптор використовується в викликах функцій CryptoAPI**, що працюють із вибраним CSP.

**CryptCreateHash**

Ініціює хешування потоку даних. Якщо ця функція використовується, ви можете дізнатися, який **алгоритм використовується**, перевіривши значення другого параметра:

![](<../../images/image (549).png>)

\
Перегляньте таблицю можливих алгоритмів і їхніх призначених значень: [https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id](https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id)

### Константи в коді

Іноді дуже легко ідентифікувати алгоритм завдяки використанню особливої та унікальної константи.

![](<../../images/image (833).png>)

Якщо пошукати в Google першу константу, отримаємо таке:

![](<../../images/image (529).png>)

Отже, можна припустити, що дизасембльована функція — **sha256 калькулятор.**\
Ви можете шукати будь-яку з інших констант і, ймовірно, отримаєте схожий результат.

### Інформація з секції .data

Якщо в коді немає значимих констант, він може завантажувати дані з секції .data.\
Ви можете отримати ці дані, **згрупувати перший dword** і пошукати його в Google, як ми робили раніше:

![](<../../images/image (531).png>)

У цьому випадку, якщо шукати **0xA56363C6**, можна знайти, що він пов’язаний з **таблицями алгоритму AES**.

## RC4 **(симетричне шифрування)**

### Характеристики

Складається з 3 основних частин:

- **Етап ініціалізації/**: Створює **таблицю значень від 0x00 до 0xFF** (256 байт, 0x100). Цю таблицю зазвичай називають **Substitution Box** (або SBox).
- **Етап перемішування**: Проходить по раніше створеній таблиці (цикл з 0x100 ітерацій) і модифікує кожне значення напіввипадковими байтами. Для генерації цих напіввипадкових байт використовується RC4 **key**. RC4 ключі можуть бути від 1 до 256 байт, проте зазвичай рекомендується більше 5 байт. Зазвичай RC4 ключі мають довжину 16 байт.
- **Етап XOR**: Нарешті, plaintext або ciphertext **XOR’иться зі значеннями, створеними раніше**. Функція для шифрування і дешифрування одна й та сама. Для цього виконується **цикл по створеним 256 байтам** стільки разів, скільки потрібно. Це зазвичай помітно в дизасемблінгу/декодованому коді як **%256 (mod 256)**.

> [!TIP]
> **Щоб ідентифікувати RC4 у дизасембльованому/декодованому коді, перевірте наявність 2 циклів розміру 0x100 (з використанням ключа), а потім XOR входу з 256 значеннями, створеними в цих двох циклах, ймовірно з використанням %256 (mod 256).**

### **Етап ініціалізації/Substitution Box:** (Зверніть увагу на число 256, використане як лічильник, і як у кожну позицію записано 0)

![](<../../images/image (584).png>)

### **Етап перемішування:**

![](<../../images/image (835).png>)

### **Етап XOR:**

![](<../../images/image (904).png>)

## AES **(симетричне шифрування)**

### **Характеристики**

- Використання **substitution boxes та lookup tables**
- AES можна відрізнити за використанням специфічних значень у lookup table (констант). _Зверніть увагу, що **константа** може бути **збережена** в бінарі **або створена**_ _**динамічно**._
- **Ключ шифрування** повинен бути кратним **16** (зазвичай 32B), і зазвичай використовується IV розміром 16B.

### SBox константи

![](<../../images/image (208).png>)

## Serpent **(симетричне шифрування)**

### Характеристики

- Рідко зустрічається в malwarе, але є приклади (Ursnif)
- Легко визначити, чи це Serpent, по довжині реалізації (надзвичайно довга функція)

### Ідентифікація

На наступному зображенні зверніть увагу, як використовується константа **0x9E3779B9** (зауважте, що ця константа також використовується іншими криптоалгоритмами, наприклад **TEA** - Tiny Encryption Algorithm).\
Також зверніть увагу на **розмір циклу** (**132**) і **кількість операцій XOR** в інструкціях дизасемблера та в прикладі коду:

![](<../../images/image (547).png>)

Як згадувалося раніше, такий код в будь-якому декомпіляторі виглядає як **дуже довга функція**, оскільки в ній **немає переходів**. Декомпільований код може виглядати так:

![](<../../images/image (513).png>)

Отже, можна ідентифікувати цей алгоритм, перевіривши **магічне число** та **початкові XOR-операції**, побачивши **дуже довгу функцію** і **порівнявши** деякі **інструкції** цієї довгої функції з реалізацією (наприклад, зсув вліво на 7 і ротацію вліво на 22).

## RSA **(асиметричне шифрування)**

### Характеристики

- Складніший за симетричні алгоритми
- Немає констант! (кастомні реалізації важко визначити)
- KANAL (crypto analyzer) не дає підказок для RSA, оскільки покладається на константи.

### Ідентифікація шляхом порівнянь

![](<../../images/image (1113).png>)

- В рядку 11 (зліва) є `+7) >> 3`, що таке саме, як у рядку 35 (справа): `+7) / 8`
- Рядок 12 (зліва) перевіряє `modulus_len < 0x040`, а в рядку 36 (справа) перевіряється `inputLen+11 > modulusLen`

## MD5 & SHA (хеші)

### Характеристики

- 3 функції: Init, Update, Final
- Схожі функції ініціалізації

### Ідентифікація

**Init**

Ви можете ідентифікувати обидва, перевіривши константи. Зверніть увагу, що sha_init має одну константу, якої немає в MD5:

![](<../../images/image (406).png>)

**MD5 Transform**

Зверніть увагу на використання більшої кількості констант

![](<../../images/image (253) (1) (1).png>)

## CRC (хеш)

- Менший і ефективніший, оскільки його функція — знаходження випадкових змін у даних
- Використовує lookup tables (тому можна ідентифікувати по константах)

### Ідентифікація

Перевірте **константи lookup table**:

![](<../../images/image (508).png>)

Алгоритм CRC виглядає так:

![](<../../images/image (391).png>)

## APLib (компресія)

### Характеристики

- Немає впізнаваних констант
- Ви можете спробувати реалізувати алгоритм на python і шукати подібні речі в інтернеті

### Ідентифікація

Граф досить великий:

![](<../../images/image (207) (2) (1).png>)

Перевірте **3 порівняння для розпізнавання**:

![](<../../images/image (430).png>)

## Помилки реалізації підписів на еліптичних кривих

### Перевірка діапазону скаляра EdDSA (модуляція HashEdDSA)

- FIPS 186-5 §7.8.2 вимагає, щоб перевіряльники HashEdDSA розбивали підпис `sig = R || s` і відхиляли будь-який скаляр з `s \geq n`, де `n` — порядок групи. Бібліотека `elliptic` пропустила цю перевірку межі, тому будь-який атакуючий, який знає дійсну пару `(msg, R || s)`, може сфальсифікувати альтернативні підписи `s' = s + k·n` і продовжувати перекодовувати `sig' = R || s'`.
- Рутинні перевірки використовують лише `s mod n`, отже всі `s'`, що конгруентні `s`, приймаються, хоча вони є різними байтовими рядками. Системи, що трактують підписи як канонічні токени (консенсус блокчейну, кеші повторів, ключі БД тощо), можуть бути десинхронізовані, оскільки суворі реалізації відхилятимуть `s'`.
- При аудиту іншого HashEdDSA-коду переконайтеся, що парсер валідуює як точку `R`, так і довжину скаляра; спробуйте додавати кратні `n` до відомого дійсного `s`, щоб підтвердити, що перевіряльник закриває доступ (fails closed).

### Обрізання ECDSA vs. хеші з провідними нуль-байтами

- Перевіряльники ECDSA повинні використовувати лише ліві `log2(n)` біт хешу повідомлення `H`. У `elliptic` хелпер для усікання обчислював `delta = (BN(msg).byteLength()*8) - bitlen(n)`; конструктор `BN` відкидає провідні нульові октети, тому будь-який хеш, що починається з ≥4 нульових байтів на кривих типу secp192r1 (порядок 192 біт), виглядав як 224 біти замість 256.
- Перевіряльник зсував вправо на 32 біти замість 64, в результаті утворювався `E`, що не відповідав значенню, яке використовував підписувач. Дійсні підписи на таких хешах тому невдалі з ймовірністю ≈`2^-32` для вхідних SHA-256.
- Проганяйте як «коректний» вектор, так і варіанти з провідними нулями (наприклад, кейс Wycheproof `ecdsa_secp192r1_sha256_test.json` `tc296`) проти цільової реалізації; якщо перевіряльник не погоджується з підписувачем, ви знайшли експлуатовану помилку усікання.

### Прогін векторів Wycheproof проти бібліотек
- Wycheproof постачає JSON-набори тестів, що кодують неправильно сформовані точки, модулярні скаляри, нетипові хеші та інші крайові випадки. Побудувати тестовий каркас навколо `elliptic` (або будь-якої криптобібліотеки) просто: завантажте JSON, десеріалізуйте кожен тест-кейс і стверджуйте, що реалізація відповідає очікуваному прапорцю `result`.
```javascript
for (const tc of ecdsaVectors.testGroups) {
const curve = new EC(tc.curve);
const pub = curve.keyFromPublic(tc.key, 'hex');
const ok = curve.verify(tc.msg, tc.sig, pub, 'hex', tc.msgSize);
assert.strictEqual(ok, tc.result === 'valid');
}
```
- Невдачі слід тріажувати, щоб відрізнити порушення специфікації від помилкових спрацьовувань. У двох наведених вище багах невдалі кейси Wycheproof одразу вказали на відсутні перевірки діапазону скалярів (EdDSA) та неправильну обрізку хешів (ECDSA).
- Інтегруйте harness у CI, щоб регресії в парсингу скалярів, обробці хешів або валідації координат запускали тести відразу після їх появи. Це особливо корисно для високорівневих мов (JS, Python, Go), де делікатні перетворення великих чисел (bignum) легко зробити неправильно.

## Посилання

- [Trail of Bits - We found cryptography bugs in the elliptic library using Wycheproof](https://blog.trailofbits.com/2025/11/18/we-found-cryptography-bugs-in-the-elliptic-library-using-wycheproof/)
- [Wycheproof Test Suite](https://github.com/C2SP/wycheproof)

{{#include ../../banners/hacktricks-training.md}}
