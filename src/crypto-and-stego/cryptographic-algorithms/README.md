# Криптографічні/Стиснення Алгоритми

## Криптографічні/Стиснення Алгоритми

{{#include ../../banners/hacktricks-training.md}}

## Визначення Алгоритмів

Якщо ви закінчуєте в коді **використовуючи зсуви вправо та вліво, XOR та кілька арифметичних операцій**, це, ймовірно, реалізація **криптографічного алгоритму**. Тут будуть показані деякі способи **визначити алгоритм, який використовується, не потребуючи реверсувати кожен крок**.

### API функції

**CryptDeriveKey**

Якщо ця функція використовується, ви можете дізнатися, який **алгоритм використовується**, перевіривши значення другого параметра:

![](<../../images/image (156).png>)

Перевірте тут таблицю можливих алгоритмів та їх призначених значень: [https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id](https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id)

**RtlCompressBuffer/RtlDecompressBuffer**

Стискає та розпаковує дані з даного буфера.

**CryptAcquireContext**

З [документації](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecontexta): Функція **CryptAcquireContext** використовується для отримання дескриптора до певного контейнера ключів у певному постачальнику криптографічних послуг (CSP). **Цей повернений дескриптор використовується в викликах функцій CryptoAPI**, які використовують вибраний CSP.

**CryptCreateHash**

Ініціює хешування потоку даних. Якщо ця функція використовується, ви можете дізнатися, який **алгоритм використовується**, перевіривши значення другого параметра:

![](<../../images/image (549).png>)

\
Перевірте тут таблицю можливих алгоритмів та їх призначених значень: [https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id](https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id)

### Константи коду

Іноді дуже легко визначити алгоритм завдяки тому, що він потребує використання спеціального та унікального значення.

![](<../../images/image (833).png>)

Якщо ви шукаєте першу константу в Google, ось що ви отримаєте:

![](<../../images/image (529).png>)

Отже, ви можете припустити, що декомпільована функція є **калькулятором sha256.**\
Ви можете шукати будь-яку з інших констант, і ви отримаєте (ймовірно) той же результат.

### інформація про дані

Якщо код не має жодної значної константи, він може **завантажувати інформацію з секції .data**.\
Ви можете отримати доступ до цих даних, **групуючи перший dword** і шукати його в Google, як ми робили в попередньому розділі:

![](<../../images/image (531).png>)

У цьому випадку, якщо ви шукаєте **0xA56363C6**, ви можете знайти, що це пов'язано з **таблицями алгоритму AES**.

## RC4 **(Симетричний Крипт)**

### Характеристики

Він складається з 3 основних частин:

- **Стадія ініціалізації/**: Створює **таблицю значень від 0x00 до 0xFF** (всього 256 байт, 0x100). Цю таблицю зазвичай називають **Substitution Box** (або SBox).
- **Стадія перемішування**: Буде **проходити через таблицю**, створену раніше (цикл 0x100 ітерацій, знову) модифікуючи кожне значення з **напіввипадковими** байтами. Для створення цих напіввипадкових байтів використовується **ключ RC4**. **Ключі RC4** можуть бути **від 1 до 256 байт в довжину**, однак зазвичай рекомендується, щоб вони були більше 5 байт. Зазвичай ключі RC4 мають довжину 16 байт.
- **Стадія XOR**: Нарешті, відкритий текст або шифротекст **XORed з значеннями, створеними раніше**. Функція для шифрування та дешифрування однакова. Для цього буде виконано **проходження через створені 256 байт** стільки разів, скільки необхідно. Це зазвичай розпізнається в декомпільованому коді з **%256 (mod 256)**.

> [!NOTE]
> **Щоб визначити RC4 у дизасембльованому/декомпільованому коді, ви можете перевірити 2 цикли розміру 0x100 (з використанням ключа), а потім XOR вхідних даних з 256 значеннями, створеними раніше в 2 циклах, ймовірно, використовуючи %256 (mod 256)**

### **Стадія ініціалізації/Substitution Box:** (Зверніть увагу на число 256, яке використовується як лічильник, і як 0 записується в кожному місці з 256 символів)

![](<../../images/image (584).png>)

### **Стадія перемішування:**

![](<../../images/image (835).png>)

### **Стадія XOR:**

![](<../../images/image (904).png>)

## **AES (Симетричний Крипт)**

### **Характеристики**

- Використання **боксів заміни та таблиць пошуку**
- Можливо **відрізнити AES завдяки використанню специфічних значень таблиць пошуку** (констант). _Зверніть увагу, що **константа** може бути **збережена** в бінарному **або створена** _**динамічно**._
- **Ключ шифрування** повинен бути **доступний** на **16** (зазвичай 32B) і зазвичай використовується **IV** довжиною 16B.

### Константи SBox

![](<../../images/image (208).png>)

## Serpent **(Симетричний Крипт)**

### Характеристики

- Рідко можна знайти деяке шкідливе ПЗ, яке його використовує, але є приклади (Ursnif)
- Легко визначити, чи є алгоритм Serpent, чи ні, на основі його довжини (надзвичайно довга функція)

### Визначення

На наступному зображенні зверніть увагу, як використовується константа **0x9E3779B9** (зверніть увагу, що ця константа також використовується іншими криптоалгоритмами, такими як **TEA** -Tiny Encryption Algorithm).\
Також зверніть увагу на **розмір циклу** (**132**) та **кількість операцій XOR** в **інструкціях дизасемблювання** та в **прикладі коду**:

![](<../../images/image (547).png>)

Як вже згадувалося, цей код можна візуалізувати в будь-якому декомпілері як **дуже довгу функцію**, оскільки в ній **немає стрибків**. Декомпільований код може виглядати наступним чином:

![](<../../images/image (513).png>)

Отже, можливо визначити цей алгоритм, перевіривши **магічне число** та **початкові XOR**, бачачи **дуже довгу функцію** та **порівнюючи** деякі **інструкції** довгої функції **з реалізацією** (наприклад, зсув вліво на 7 та обертання вліво на 22).

## RSA **(Асиметричний Крипт)**

### Характеристики

- Складніший, ніж симетричні алгоритми
- Немає констант! (кастомні реалізації важко визначити)
- KANAL (криптоаналізатор) не може показати підказки щодо RSA, оскільки покладається на константи.

### Визначення за допомогою порівнянь

![](<../../images/image (1113).png>)

- У рядку 11 (ліворуч) є `+7) >> 3`, що таке ж, як у рядку 35 (праворуч): `+7) / 8`
- Рядок 12 (ліворуч) перевіряє, чи `modulus_len < 0x040`, а в рядку 36 (праворуч) перевіряється, чи `inputLen+11 > modulusLen`

## MD5 & SHA (хеш)

### Характеристики

- 3 функції: Init, Update, Final
- Схожі ініціалізаційні функції

### Визначити

**Init**

Ви можете визначити обидва, перевіривши константи. Зверніть увагу, що sha_init має 1 константу, якої MD5 не має:

![](<../../images/image (406).png>)

**MD5 Transform**

Зверніть увагу на використання більшої кількості констант

![](<../../images/image (253) (1) (1).png>)

## CRC (хеш)

- Менший і більш ефективний, оскільки його функція полягає в знаходженні випадкових змін у даних
- Використовує таблиці пошуку (тому ви можете визначити константи)

### Визначити

Перевірте **константи таблиці пошуку**:

![](<../../images/image (508).png>)

Алгоритм хешування CRC виглядає так:

![](<../../images/image (391).png>)

## APLib (Стиснення)

### Характеристики

- Непізнавані константи
- Ви можете спробувати написати алгоритм на python і шукати подібні речі в Інтернеті

### Визначити

Графік досить великий:

![](<../../images/image (207) (2) (1).png>)

Перевірте **3 порівняння, щоб його розпізнати**:

![](<../../images/image (430).png>)

{{#include ../../banners/hacktricks-training.md}}
