# Κρυπτογραφικά/Αλγόριθμοι Συμπίεσης

{{#include ../../banners/hacktricks-training.md}}

## Αναγνώριση Αλγορίθμων

Αν καταλήξετε σε κώδικα **που χρησιμοποιεί shift δεξιά και αριστερά, XORs και διάφορες αριθμητικές πράξεις**, είναι πολύ πιθανό ότι πρόκειται για την υλοποίηση ενός **κρυπτογραφικού αλγορίθμου**. Εδώ θα παρουσιαστούν μερικοί τρόποι για να **εντοπίσετε ποιος αλγόριθμος χρησιμοποιείται χωρίς να χρειάζεται να αναστρέψετε κάθε βήμα**.

### Συναρτήσεις API

**CryptDeriveKey**

Εάν αυτή η συνάρτηση χρησιμοποιείται, μπορείτε να βρείτε ποιος **αλγόριθμος χρησιμοποιείται** ελέγχοντας την τιμή του δεύτερου παραμέτρου:

![](<../../images/image (156).png>)

Δείτε εδώ τον πίνακα με τους πιθανούς αλγόριθμους και τις αντιστοιχίες τιμών: [https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id](https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id)

**RtlCompressBuffer/RtlDecompressBuffer**

Συμπιέζει και αποσυμπιέζει ένα δοθέν buffer δεδομένων.

**CryptAcquireContext**

Από [the docs](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecontexta): Η συνάρτηση **CryptAcquireContext** χρησιμοποιείται για να αποκτήσει ένα handle σε ένα συγκεκριμένο key container μέσα σε έναν συγκεκριμένο cryptographic service provider (CSP). **Αυτό το επιστρεφόμενο handle χρησιμοποιείται σε κλήσεις προς συναρτήσεις CryptoAPI** που χρησιμοποιούν τον επιλεγμένο CSP.

**CryptCreateHash**

Ξεκινά το hashing μιας ροής δεδομένων. Εάν αυτή η συνάρτηση χρησιμοποιείται, μπορείτε να βρείτε ποιος **αλγόριθμος χρησιμοποιείται** ελέγχοντας την τιμή του δεύτερου παραμέτρου:

![](<../../images/image (549).png>)

\
Δείτε εδώ τον πίνακα με τους πιθανούς αλγόριθμους και τις αντιστοιχίες τιμών: [https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id](https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id)

### Σταθερές στον κώδικα

Μερικές φορές είναι πολύ εύκολο να αναγνωρίσεις έναν αλγόριθμο χάρη στο ότι χρειάζεται να χρησιμοποιήσει μια ειδική και μοναδική τιμή.

![](<../../images/image (833).png>)

Αν ψάξετε την πρώτη σταθερά στο Google, αυτό είναι που θα βρείτε:

![](<../../images/image (529).png>)

Συνεπώς, μπορείτε να υποθέσετε ότι η αποσυναρμολογημένη συνάρτηση είναι ένας **sha256 calculator.**\
Μπορείτε να αναζητήσετε οποιαδήποτε από τις άλλες σταθερές και πιθανότατα θα λάβετε το ίδιο αποτέλεσμα.

### Πληροφορίες δεδομένων

Εάν ο κώδικας δεν έχει κάποια σημαντική σταθερά, μπορεί να **φορτώνει πληροφορίες από την .data section**.\
Μπορείτε να αποκτήσετε πρόσβαση σε αυτά τα δεδομένα, **ομαδοποιήστε το πρώτο dword** και να το αναζητήσετε στο Google όπως κάναμε στην προηγούμενη ενότητα:

![](<../../images/image (531).png>)

Στη συγκεκριμένη περίπτωση, αν ψάξετε για **0xA56363C6** μπορείτε να βρείτε ότι σχετίζεται με τους **πίνακες του AES**.

## RC4 **(Συμμετρική Κρυπτογράφηση)**

### Χαρακτηριστικά

Αποτελείται από 3 κύρια μέρη:

- **Initialization stage/**: Δημιουργεί έναν **πίνακα τιμών από 0x00 έως 0xFF** (256 bytes συνολικά, 0x100). Αυτός ο πίνακας συνήθως ονομάζεται **Substitution Box** (ή SBox).
- **Scrambling stage**: Θα **περάσει επάνω από τον πίνακα** που δημιουργήθηκε πριν (βρόχος 0x100 επαναλήψεων, ξανά) τροποποιώντας κάθε τιμή με **ημι-τυχαία** bytes. Για να δημιουργηθούν αυτά τα ημι-τυχαία bytes, το RC4 **key** χρησιμοποιείται. Τα RC4 **keys** μπορούν να έχουν μήκος **μεταξύ 1 και 256 bytes**, ωστόσο συνήθως συνιστάται να είναι πάνω από 5 bytes. Συνήθως, τα RC4 keys έχουν μήκος 16 bytes.
- **XOR stage**: Τέλος, το plain-text ή cyphertext **XOR-άρεται με τις τιμές που δημιουργήθηκαν προηγουμένως**. Η λειτουργία για κρυπτογράφηση και αποκρυπτογράφηση είναι η ίδια. Για αυτό, θα γίνει ένας **βρόχος μέσα από τα δημιουργημένα 256 bytes** όσες φορές χρειαστεί. Αυτό συνήθως αναγνωρίζεται σε αποσυναρμολογημένο/απομεταγλωττισμένο κώδικα με **%256 (mod 256)**.

> [!TIP]
> **Για να εντοπίσετε RC4 σε disassembly/decompiled κώδικα μπορείτε να ελέγξετε για 2 βρόχους μεγέθους 0x100 (με χρήση key) και στη συνέχεια ένα XOR των εισερχόμενων δεδομένων με τις 256 τιμές που δημιουργήθηκαν στους 2 βρόχους, πιθανώς χρησιμοποιώντας %256 (mod 256)**

### **Initialization stage/Substitution Box:** (Σημειώστε τον αριθμό 256 που χρησιμοποιείται ως μετρητής και πώς γράφεται 0 σε κάθε θέση των 256 χαρακτήρων)

![](<../../images/image (584).png>)

### **Scrambling Stage:**

![](<../../images/image (835).png>)

### **XOR Stage:**

![](<../../images/image (904).png>)

## **AES (Συμμετρική Κρυπτογράφηση)**

### **Χαρακτηριστικά**

- Χρήση **substitution boxes και lookup tables**
- Είναι δυνατό να **διακρίνεται το AES χάρη στη χρήση συγκεκριμένων τιμών lookup table** (σταθερές). _Σημειώστε ότι η **σταθερά** μπορεί να **αποθηκεύεται** στο binary **ή να δημιουργείται** _**δυναμικά**._
- Το **encryption key** πρέπει να είναι **διαιρέσιμο** με **16** (συνήθως 32B) και συνήθως χρησιμοποιείται ένα **IV** 16B.

### SBox constants

![](<../../images/image (208).png>)

## Serpent **(Συμμετρική Κρυπτογράφηση)**

### Χαρακτηριστικά

- Σπάνια θα βρείτε malware που το χρησιμοποιεί, αλλά υπάρχουν παραδείγματα (Ursnif)
- Εύκολο να προσδιοριστεί αν ένας αλγόριθμος είναι Serpent ή όχι βάσει του μήκους του (εξαιρετικά μεγάλη συνάρτηση)

### Αναγνώριση

Στην παρακάτω εικόνα προσέξτε πώς χρησιμοποιείται η σταθερά **0x9E3779B9** (σημειώστε ότι αυτή η σταθερά χρησιμοποιείται και από άλλους crypto αλγορίθμους όπως ο **TEA** -Tiny Encryption Algorithm).\
Επίσης προσέξτε το **μέγεθος του βρόχου** (**132**) και τον **αριθμό των XOR operations** στις εντολές **disassembly** και στο **παράδειγμα κώδικα**:

![](<../../images/image (547).png>)

Όπως αναφέρθηκε προηγουμένως, αυτός ο κώδικας μπορεί να εμφανιστεί σε οποιονδήποτε decompiler ως μια **πολύ μεγάλη συνάρτηση** καθώς **δεν υπάρχουν jumps** μέσα σε αυτήν. Ο decompiled κώδικας μπορεί να μοιάζει με το ακόλουθο:

![](<../../images/image (513).png>)

Συνεπώς, είναι δυνατό να αναγνωρίσετε αυτόν τον αλγόριθμο ελέγχοντας τον **magic number** και τα **αρχικά XORs**, βλέποντας μια **πολύ μεγάλη συνάρτηση** και **συγκρίνοντας** μερικές **εντολές** της μεγάλης συνάρτησης **με μια υλοποίηση** (όπως το shift αριστερά κατά 7 και το rotate αριστερά κατά 22).

## RSA **(Ασύμμετρη Κρυπτογράφηση)**

### Χαρακτηριστικά

- Πιο πολύπλοκο από τους συμμετρικούς αλγορίθμους
- Δεν υπάρχουν σταθερές! (οι προσαρμοσμένες υλοποιήσεις είναι δύσκολο να προσδιοριστούν)
- KANAL (a crypto analyzer) αποτυγχάνει να δείξει ενδείξεις για RSA καθώς βασίζεται σε σταθερές.

### Αναγνώριση με συγκρίσεις

![](<../../images/image (1113).png>)

- Στην γραμμή 11 (αριστερά) υπάρχει `+7) >> 3` το οποίο είναι το ίδιο με τη γραμμή 35 (δεξιά): `+7) / 8`
- Η γραμμή 12 (αριστερά) ελέγχει αν `modulus_len < 0x040` και στη γραμμή 36 (δεξιά) ελέγχει αν `inputLen+11 > modulusLen`

## MD5 & SHA (hash)

### Χαρακτηριστικά

- 3 συναρτήσεις: Init, Update, Final
- Παρόμοιες συναρτήσεις αρχικοποίησης

### Αναγνώριση

**Init**

Μπορείτε να τα αναγνωρίσετε και τα δύο ελέγχοντας τις σταθερές. Σημειώστε ότι το sha_init έχει 1 σταθερά που το MD5 δεν έχει:

![](<../../images/image (406).png>)

**MD5 Transform**

Σημειώστε τη χρήση περισσότερων σταθερών

![](<../../images/image (253) (1) (1).png>)

## CRC (hash)

- Μικρότερο και πιο αποδοτικό καθώς η λειτουργία του είναι να εντοπίζει τυχαίες αλλαγές στα δεδομένα
- Χρησιμοποιεί lookup tables (οπότε μπορείτε να εντοπίσετε σταθερές)

### Αναγνώριση

Ελέγξτε τις **σταθερές των lookup tables**:

![](<../../images/image (508).png>)

Ένας CRC αλγόριθμος hash μοιάζει με:

![](<../../images/image (391).png>)

## APLib (Compression)

### Χαρακτηριστικά

- Δεν έχει αναγνωρίσιμες σταθερές
- Μπορείτε να δοκιμάσετε να γράψετε τον αλγόριθμο σε python και να ψάξετε για παρόμοια πράγματα online

### Αναγνώριση

Το γράφημα είναι αρκετά μεγάλο:

![](<../../images/image (207) (2) (1).png>)

Ελέγξτε **3 συγκρίσεις για να το αναγνωρίσετε**:

![](<../../images/image (430).png>)

## Σφάλματα υλοποίησης υπογραφών ελλειπτικών καμπυλών

### EdDSA scalar range enforcement (HashEdDSA malleability)

- Το FIPS 186-5 §7.8.2 απαιτεί από τους επαληθευτές HashEdDSA να χωρίζουν μια υπογραφή `sig = R || s` και να απορρίπτουν οποιονδήποτε scalar με `s \geq n`, όπου `n` είναι η τάξη της ομάδας. Η βιβλιοθήκη `elliptic` για JS παράλειψε αυτόν τον έλεγχο ορίου, έτσι οποιοσδήποτε επιτιθέμενος που γνωρίζει ένα έγκυρο ζεύγος `(msg, R || s)` μπορεί να κατασκευάσει εναλλακτικές υπογραφές `s' = s + k·n` και να συνεχίσει να κωδικοποιεί `sig' = R || s'`.
- Οι ρουτίνες επαλήθευσης χρησιμοποιούν μόνο `s mod n`, επομένως όλα τα `s'` συνεπή με το `s` γίνονται δεκτά ακόμη και αν είναι διαφορετικά byte strings. Συστήματα που χειρίζονται υπογραφές ως canonical tokens (blockchain consensus, replay caches, DB keys, κ.λπ.) μπορούν να αποσυγχρονιστούν επειδή αυστηρές υλοποιήσεις θα απορρίψουν τα `s'`.
- Όταν ελέγχετε άλλο κώδικα HashEdDSA, βεβαιωθείτε ότι ο parser επικυρώνει τόσο το σημείο `R` όσο και το μήκος του scalar· δοκιμάστε να προσθέσετε πολλαπλάσια του `n` σε ένα γνωστό-καλό `s` για να επιβεβαιώσετε ότι ο επαληθευτής αποτυγχάνει κλειστός.

### ECDSA truncation vs. leading-zero hashes

- Οι ECDSA επαληθευτές πρέπει να χρησιμοποιούν μόνο τα αριστερότερα `log2(n)` bits του hash μηνύματος `H`. Στο `elliptic`, ο βοηθός αποκοπής υπολόγιζε `delta = (BN(msg).byteLength()*8) - bitlen(n)`; ο constructor `BN` αφαιρεί τα αρχικά μηδενικά οκτέτα, επομένως οποιοδήποτε hash που αρχίζει με ≥4 μηδενικά bytes σε καμπύλες όπως secp192r1 (τάξη 192-bit) φαινόταν να έχει μόνο 224 bits αντί για 256.
- Ο επαληθευτής έκανε δεξιά-shift κατά 32 bits αντί για 64, παράγοντας ένα `E` που δεν ταιριάζει με την τιμή που χρησιμοποιεί ο υπογραφέας. Επομένως, έγκυρες υπογραφές σε αυτά τα hashes αποτυγχάνουν με πιθανότητα ≈`2^-32` για εισόδους SHA-256.
- Δώστε τόσο το “όλα καλά” vector όσο και παραλλαγές με αρχικά μηδενικά (π.χ. Wycheproof `ecdsa_secp192r1_sha256_test.json` περίπτωση `tc296`) σε μια στοχευμένη υλοποίηση· αν ο επαληθευτής διαφωνεί με τον υπογραφέα, έχετε βρει ένα εκμεταλλεύσιμο σφάλμα αποκοπής.

### Εφαρμογή των Wycheproof vectors εναντίον βιβλιοθηκών
- Το Wycheproof παρέχει JSON test sets που κωδικοποιούν κατεστραμμένα σημεία, malleable scalars, ασυνήθιστα hashes και άλλες περιπτώσεις άκρης. Η κατασκευή ενός harness γύρω από το `elliptic` (ή οποιαδήποτε crypto library) είναι απλή: φορτώστε το JSON, αποσειριοποιήστε κάθε test case, και επαληθεύστε ότι η υλοποίηση ταιριάζει με τη αναμενόμενη σημαία `result`.
```javascript
for (const tc of ecdsaVectors.testGroups) {
const curve = new EC(tc.curve);
const pub = curve.keyFromPublic(tc.key, 'hex');
const ok = curve.verify(tc.msg, tc.sig, pub, 'hex', tc.msgSize);
assert.strictEqual(ok, tc.result === 'valid');
}
```
- Οι αποτυχίες πρέπει να ταξινομούνται ώστε να διακρίνονται οι παραβιάσεις προδιαγραφών από τις false positives. Για τα δύο σφάλματα παραπάνω, οι αποτυχημένες περιπτώσεις Wycheproof υποδείκνυαν αμέσως missing scalar range checks (EdDSA) και incorrect hash truncation (ECDSA).
- Ενσωματώστε το harness στο CI ώστε regressions στην scalar parsing, hash handling ή coordinate validity να ενεργοποιούν tests μόλις εισαχθούν. Αυτό είναι ιδιαίτερα χρήσιμο για high-level languages (JS, Python, Go) όπου οι λεπτές μετατροπές bignum είναι εύκολο να γίνουν λάθος.

## Αναφορές

- [Trail of Bits - We found cryptography bugs in the elliptic library using Wycheproof](https://blog.trailofbits.com/2025/11/18/we-found-cryptography-bugs-in-the-elliptic-library-using-wycheproof/)
- [Wycheproof Test Suite](https://github.com/C2SP/wycheproof)

{{#include ../../banners/hacktricks-training.md}}
