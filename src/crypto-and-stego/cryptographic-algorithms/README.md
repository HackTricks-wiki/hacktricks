# Κρυπτογραφικοί/Αλγόριθμοι Συμπίεσης

{{#include ../../banners/hacktricks-training.md}}

## Αναγνώριση Αλγορίθμων

Αν βρεθείς σε κώδικα **που χρησιμοποιεί δεξιές/αριστερές μετατοπίσεις, XORs και διάφορες αριθμητικές πράξεις** είναι πολύ πιθανό ότι πρόκειται για υλοποίηση ενός **κρυπτογραφικού αλγορίθμου**. Εδώ θα παρουσιαστούν μερικοί τρόποι για να **εντοπίσετε ποιος αλγόριθμος χρησιμοποιείται χωρίς να χρειαστεί να κάνετε reverse κάθε βήμα**.

### API functions

**CryptDeriveKey**

Αν χρησιμοποιείται αυτή η συνάρτηση, μπορείτε να βρείτε ποιος **αλγόριθμος χρησιμοποιείται** ελέγχοντας την τιμή του δεύτερου παραμέτρου:

![](<../../images/image (156).png>)

Δείτε εδώ τον πίνακα των πιθανών αλγορίθμων και των αντιστοιχισμένων τιμών: [https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id](https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id)

**RtlCompressBuffer/RtlDecompressBuffer**

Συμπιέζει και αποσυμπιέζει ένα δοθέν buffer δεδομένων.

**CryptAcquireContext**

Από [the docs](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecontexta): Η συνάρτηση **CryptAcquireContext** χρησιμοποιείται για να αποκτήσει ένα handle σε ένα συγκεκριμένο key container εντός ενός συγκεκριμένου cryptographic service provider (CSP). **Αυτό το handle επιστρέφεται και χρησιμοποιείται σε κλήσεις προς συναρτήσεις CryptoAPI** που χρησιμοποιούν τον επιλεγμένο CSP.

**CryptCreateHash**

Ξεκινά το hashing μιας ροής δεδομένων. Αν χρησιμοποιείται αυτή η συνάρτηση, μπορείτε να βρείτε ποιος **αλγόριθμος χρησιμοποιείται** ελέγχοντας την τιμή του δεύτερου παραμέτρου:

![](<../../images/image (549).png>)

\
Δείτε εδώ τον πίνακα των πιθανών αλγορίθμων και των αντιστοιχισμένων τιμών: [https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id](https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id)

### Code constants

Μερικές φορές είναι πολύ εύκολο να αναγνωρίσεις έναν αλγόριθμο χάρη στο ότι χρειάζεται να χρησιμοποιήσει μια ειδική και μοναδική τιμή.

![](<../../images/image (833).png>)

Αν αναζητήσεις την πρώτη σταθερά στο Google αυτό είναι που θα βρεις:

![](<../../images/image (529).png>)

Επομένως, μπορείτε να υποθέσετε ότι η decompiled function είναι ένας **sha256 calculator.**\
Μπορείτε να ψάξετε οποιαδήποτε από τις άλλες σταθερές και πιθανότατα θα λάβετε το ίδιο αποτέλεσμα.

### Πληροφορίες δεδομένων

Αν ο κώδικας δεν έχει κάποια σημαντική σταθερά, μπορεί να **φορτώνει πληροφορία από το .data section**.\
Μπορείτε να προσπελάσετε αυτά τα δεδομένα, **ομαδοποιήστε το πρώτο dword** και να το αναζητήσετε στο Google όπως κάναμε στην προηγούμενη ενότητα:

![](<../../images/image (531).png>)

Σε αυτή την περίπτωση, αν ψάξετε για **0xA56363C6** θα βρείτε ότι σχετίζεται με τους **πίνακες του AES algorithm**.

## RC4 (Symmetric Crypt)

### Χαρακτηριστικά

Αποτελείται από 3 κύρια μέρη:

- **Initialization stage/**: Δημιουργεί έναν **πίνακα τιμών από 0x00 έως 0xFF** (256 bytes συνολικά, 0x100). Αυτός ο πίνακας συνήθως ονομάζεται **Substitution Box** (or SBox).
- **Scrambling stage**: Θα **διατρέξει τον πίνακα** που δημιουργήθηκε προηγουμένως (βρόχος 0x100 επαναλήψεων) τροποποιώντας κάθε τιμή με **ημι-τυχαία** bytes. Για να δημιουργηθούν αυτά τα ημι-τυχαία bytes, χρησιμοποιείται το **RC4 key**. Τα RC4 **keys** μπορούν να έχουν **μήκος από 1 έως 256 bytes**, ωστόσο συνιστάται συνήθως να είναι πάνω από 5 bytes. Συνηθισμένα, τα RC4 keys έχουν μήκος 16 bytes.
- **XOR stage**: Τέλος, το plain-text ή το cyphertext **XOR-εται με τις τιμές που δημιουργήθηκαν προηγουμένως**. Η συνάρτηση κρυπτογράφησης και αποκρυπτογράφησης είναι η ίδια. Για αυτό, θα εκτελεστεί **βρόχος πάνω στους 256 bytes** που δημιουργήθηκαν όσες φορές είναι απαραίτητο. Αυτό αναγνωρίζεται στην decompiled code με ένα **%256 (mod 256)**.

> [!TIP]
> **Για να αναγνωρίσετε RC4 σε μια disassembly/decompiled code μπορείτε να ελέγξετε για 2 βρόχους μεγέθους 0x100 (με χρήση key) και στη συνέχεια ένα XOR των εισερχόμενων δεδομένων με τις 256 τιμές που δημιουργήθηκαν στους δύο βρόχους, πιθανώς χρησιμοποιώντας %256 (mod 256)**

### **Initialization stage/Substitution Box:** (Σημειώστε τον αριθμό 256 που χρησιμοποιείται ως counter και πως ένα 0 γράφεται σε κάθε θέση των 256 χαρακτήρων)

![](<../../images/image (584).png>)

### **Scrambling Stage:**

![](<../../images/image (835).png>)

### **XOR Stage:**

![](<../../images/image (904).png>)

## AES (Symmetric Crypt)

### **Χαρακτηριστικά**

- Χρήση **substitution boxes και lookup tables**
- Είναι δυνατό να **διακρίνετε το AES χάρη στη χρήση συγκεκριμένων τιμών lookup table** (constants). _Σημειώστε ότι η **σταθερά** μπορεί να **αποθηκευτεί** στο binary **ή να δημιουργηθεί** _**dynamically**._
- Το **encryption key** πρέπει να είναι **διαιρέσιμο** με **16** (συνήθως 32B) και συνήθως χρησιμοποιείται **IV** 16B.

### SBox constants

![](<../../images/image (208).png>)

## Serpent (Symmetric Crypt)

### Χαρακτηριστικά

- Σπάνιο να βρει κανείς malware που το χρησιμοποιεί αλλά υπάρχουν παραδείγματα (Ursnif)
- Εύκολο να καθοριστεί αν ένας αλγόριθμος είναι Serpent βάσει του μήκους του (εξαιρετικά μεγάλη συνάρτηση)

### Αναγνώριση

Στην παρακάτω εικόνα παρατηρήστε πως χρησιμοποιείται η σταθερά **0x9E3779B9** (σημειώστε ότι αυτή η σταθερά χρησιμοποιείται και από άλλους crypto αλγορίθμους όπως το **TEA** -Tiny Encryption Algorithm).\
Επίσης προσέξτε το **μέγεθος του βρόχου** (**132**) και τον **αριθμό των XOR operations** στις **disassembly** εντολές και στο παράδειγμα **code**:

![](<../../images/image (547).png>)

Όπως αναφέρθηκε προηγουμένως, αυτός ο κώδικας μπορεί να φαίνεται σε οποιοδήποτε decompiler ως μια **πολύ μεγάλη συνάρτηση** αφού **δεν υπάρχουν jumps** μέσα σε αυτήν. Ο decompiled κώδικας μπορεί να μοιάζει ως εξής:

![](<../../images/image (513).png>)

Επομένως, είναι δυνατό να αναγνωριστεί αυτός ο αλγόριθμος ελέγχοντας τον **magic number** και τα **αρχικά XORs**, βλέποντας μια **πολύ μεγάλη συνάρτηση** και **συγκρίνοντας** μερικές **εντολές** της μεγάλης συνάρτησης **με μια υλοποίηση** (π.χ. shift left κατά 7 και rotate left κατά 22).

## RSA (Asymmetric Crypt)

### Χαρακτηριστικά

- Πιο πολύπλοκο από τους συμμετρικούς αλγορίθμους
- Δεν υπάρχουν constants! (custom implementations είναι δύσκολο να αναγνωριστούν)
- KANAL (a crypto analyzer) αποτυγχάνει να δείξει hints για RSA καθώς βασίζεται σε constants.

### Αναγνώριση με συγκρίσεις

![](<../../images/image (1113).png>)

- Στη γραμμή 11 (αριστερά) υπάρχει `+7) >> 3` που είναι το ίδιο με τη γραμμή 35 (δεξιά): `+7) / 8`
- Η γραμμή 12 (αριστερά) ελέγχει αν `modulus_len < 0x040` και στη γραμμή 36 (δεξιά) ελέγχει αν `inputLen+11 > modulusLen`

## MD5 & SHA (hash)

### Χαρακτηριστικά

- 3 functions: Init, Update, Final
- Παρόμοιες initialize συναρτήσεις

### Αναγνώριση

**Init**

Μπορείτε να αναγνωρίσετε και τους δύο ελέγχοντας τις σταθερές. Σημειώστε ότι το sha_init έχει 1 σταθερά που το MD5 δεν έχει:

![](<../../images/image (406).png>)

**MD5 Transform**

Σημειώστε τη χρήση περισσότερων constants

![](<../../images/image (253) (1) (1).png>)

## CRC (hash)

- Πιο μικρό και αποδοτικό αφού ο σκοπός του είναι να βρει τυχαίες/ακούσιες αλλαγές στα δεδομένα
- Χρησιμοποιεί lookup tables (οπότε μπορείτε να αναγνωρίσετε constants)

### Αναγνώριση

Ελέγξτε **lookup table constants**:

![](<../../images/image (508).png>)

Μια CRC hash συνάρτηση μοιάζει ως εξής:

![](<../../images/image (391).png>)

## APLib (Compression)

### Χαρακτηριστικά

- Δεν έχει αναγνωρίσιμες σταθερές
- Μπορείτε να δοκιμάσετε να γράψετε τον αλγόριθμο σε python και να αναζητήσετε παρόμοια πράγματα online

### Αναγνώριση

Το γράφημα είναι αρκετά μεγάλο:

![](<../../images/image (207) (2) (1).png>)

Ελέγξτε **3 συγκρίσεις για να το αναγνωρίσετε**:

![](<../../images/image (430).png>)

## Σφάλματα Υλοποίησης Υπογραφών Ελλειπτικών Καμπυλών

### EdDSA scalar range enforcement (HashEdDSA malleability)

- Το FIPS 186-5 §7.8.2 απαιτεί από τους verifiers του HashEdDSA να διαχωρίσουν μια υπογραφή `sig = R || s` και να απορρίψουν οποιονδήποτε scalar με `s \geq n`, όπου `n` είναι η τάξη της ομάδας. Η βιβλιοθήκη `elliptic` για JS παράλειψε αυτόν τον έλεγχο ορίων, έτσι οποιοσδήποτε επιτιθέμενος που γνωρίζει ένα έγκυρο ζευγάρι `(msg, R || s)` μπορεί να παραχαράξει εναλλακτικές υπογραφές `s' = s + k·n` και να επανακωδικοποιεί `sig' = R || s'`.
- Οι ρουτίνες επαλήθευσης καταναλώνουν μόνο `s mod n`, επομένως όλα τα `s'` που είναι συμβατά (congruent) με το `s` γίνονται αποδεκτά παρότι είναι διαφορετικοί byte strings. Συστήματα που αντιμετωπίζουν υπογραφές ως canonical tokens (blockchain consensus, replay caches, DB keys, κ.λπ.) μπορούν να αποσυντονιστούν επειδή αυστηρές υλοποιήσεις θα απορρίψουν τα `s'`.
- Όταν ελέγχετε άλλο HashEdDSA code, βεβαιωθείτε ότι ο parser επικυρώνει τόσο το σημείο `R` όσο και το μήκος του scalar· δοκιμάστε να προσαρτήσετε πολλαπλάσια του `n` σε ένα γνωστό-καλό `s` για να επιβεβαιώσετε ότι ο verifier αποτυγχάνει κλειστός (fails closed).

### ECDSA truncation vs. leading-zero hashes

- Οι ECDSA verifiers πρέπει να χρησιμοποιούν μόνο τα αριστερότερα `log2(n)` bits του message hash `H`. Στο `elliptic`, ο βοηθητικός κώδικας για truncation υπολόγισε `delta = (BN(msg).byteLength()*8) - bitlen(n)`; ο constructor `BN` απορρίπτει leading zero octets, οπότε οποιοδήποτε hash που αρχίζει με ≥4 μηδενικά bytes σε καμπύλες όπως secp192r1 (192-bit order) φαινόταν ότι έχει μόνο 224 bits αντί για 256.
- Ο verifier έκανε δεξιά μετατόπιση (right-shift) κατά 32 bits αντί για 64, παράγοντας ένα `E` που δεν ταιριάζει με την τιμή που χρησιμοποίησε ο signer. Έγκυρες υπογραφές για εκείνα τα hashes αποτυγχάνουν με πιθανότητα ≈`2^-32` για SHA-256 inputs.
- Δώστε τόσο το “all good” test vector όσο και παραλλαγές με leading-zero (π.χ., Wycheproof `ecdsa_secp192r1_sha256_test.json` case `tc296`) σε μια στοχευόμενη υλοποίηση· αν ο verifier διαφωνεί με τον signer, έχετε βρει ένα εκμεταλλεύσιμο truncation bug.

### Exercising Wycheproof vectors against libraries
- Το Wycheproof παρέχει JSON test sets που κωδικοποιούν malformed points, malleable scalars, ασυνήθη hashes και άλλες corner cases. Η κατασκευή ενός harness γύρω από την `elliptic` (ή οποιαδήποτε crypto library) είναι απλή: φορτώστε το JSON, απο-σειριοποιήστε κάθε test case, και επιβεβαιώστε ότι η υλοποίηση ταιριάζει με τη μεταβλητή `result` που αναμένεται.
```javascript
for (const tc of ecdsaVectors.testGroups) {
const curve = new EC(tc.curve);
const pub = curve.keyFromPublic(tc.key, 'hex');
const ok = curve.verify(tc.msg, tc.sig, pub, 'hex', tc.msgSize);
assert.strictEqual(ok, tc.result === 'valid');
}
```
- Οι αποτυχίες πρέπει να αξιολογούνται ώστε να διακριθούν οι παραβιάσεις προδιαγραφών από false positives. Για τα δύο παραπάνω bugs, οι αποτυχημένες Wycheproof περιπτώσεις υποδείκνυαν αμέσως έλλειψη ελέγχων εύρους scalar (EdDSA) και λανθασμένη περικοπή του hash (ECDSA).
- Ενσωματώστε το harness στο CI ώστε regressions στην ανάλυση scalar, στη διαχείριση του hash ή στην εγκυρότητα των συντεταγμένων να ενεργοποιούν tests μόλις εισαχθούν. Αυτό είναι ιδιαίτερα χρήσιμο για high-level languages (JS, Python, Go) όπου οι λεπτές μετατροπές bignum είναι εύκολο να γίνουν λάθος.

## Αναφορές

- [Trail of Bits - We found cryptography bugs in the elliptic library using Wycheproof](https://blog.trailofbits.com/2025/11/18/we-found-cryptography-bugs-in-the-elliptic-library-using-wycheproof/)
- [Wycheproof Test Suite](https://github.com/C2SP/wycheproof)

{{#include ../../banners/hacktricks-training.md}}
