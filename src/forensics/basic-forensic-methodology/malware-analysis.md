# 맬웨어 분석

{{#include ../../banners/hacktricks-training.md}}

## 포렌식 치트시트

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## 온라인 서비스

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## 오프라인 안티바이러스 및 탐지 도구

### Yara

#### 설치
```bash
sudo apt-get install -y yara
```
#### 규칙 준비

이 스크립트를 사용하여 github에서 모든 yara 악성코드 규칙을 다운로드하고 병합하세요: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
_**rules**_ 디렉토리를 만들고 실행하세요. 그러면 악성코드에 대한 모든 yara 규칙이 포함된 _**malware_rules.yar**_라는 파일이 생성됩니다.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### 스캔
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: 악성코드 확인 및 규칙 생성

You can use the tool [**YaraGen**](https://github.com/Neo23x0/yarGen) to generate yara rules from a binary. Check out these tutorials: [**Part 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Part 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Part 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### 설치
```
sudo apt-get install -y clamav
```
#### 스캔
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa**는 실행 파일에서 잠재적으로 악의적인 **기능**을 감지합니다: PE, ELF, .NET. 따라서 Att\&ck 전술이나 다음과 같은 의심스러운 기능을 찾습니다:

- OutputDebugString 오류 확인
- 서비스로 실행
- 프로세스 생성

[**Github repo**](https://github.com/mandiant/capa)에서 다운로드하세요.

### IOCs

IOC는 침해 지표(Indicator Of Compromise)를 의미합니다. IOC는 잠재적으로 원치 않는 소프트웨어나 확인된 **악성코드**를 식별하는 **조건의 집합**입니다. 블루 팀은 이러한 정의를 사용하여 **시스템**과 **네트워크**에서 이러한 종류의 악성 파일을 **검색**합니다.\
이러한 정의를 공유하는 것은 매우 유용합니다. 컴퓨터에서 악성코드가 식별되고 해당 악성코드에 대한 IOC가 생성되면, 다른 블루 팀이 이를 사용하여 악성코드를 더 빠르게 식별할 수 있습니다.

IOC를 생성하거나 수정하는 도구는 [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**입니다.**\
[**Redline**](https://www.fireeye.com/services/freeware/redline.html)과 같은 도구를 사용하여 **장치에서 정의된 IOC를 검색**할 수 있습니다.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki)는 간단한 침해 지표(Simple Indicators of Compromise)를 위한 스캐너입니다.\
탐지는 네 가지 탐지 방법을 기반으로 합니다:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/)는 공유 호스팅 환경에서 직면하는 위협을 중심으로 설계된 GNU GPLv2 라이센스 하에 출시된 리눅스용 악성코드 스캐너입니다. 이 도구는 네트워크 엣지 침입 탐지 시스템의 위협 데이터를 사용하여 공격에 적극적으로 사용되는 악성코드를 추출하고 탐지를 위한 서명을 생성합니다. 또한, 위협 데이터는 LMD 체크아웃 기능과 악성코드 커뮤니티 리소스에서 사용자 제출을 통해 파생됩니다.

### rkhunter

[**rkhunter**](http://rkhunter.sourceforge.net)와 같은 도구는 파일 시스템에서 가능한 **루트킷**과 악성코드를 확인하는 데 사용할 수 있습니다.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss)는 다양한 기술을 사용하여 실행 파일 내에서 난독화된 문자열을 찾으려고 시도하는 도구입니다.

### PEpper

[PEpper](https://github.com/Th3Hurrican3/PEpper)는 실행 파일 내의 일부 기본 사항(이진 데이터, 엔트로피, URL 및 IP, 일부 yara 규칙)을 확인합니다.

### PEstudio

[PEstudio](https://www.winitor.com/download)는 Windows 실행 파일에 대한 정보(수입, 수출, 헤더 등)를 얻을 수 있는 도구이며, 또한 바이러스 토탈을 확인하고 잠재적인 Att\&ck 기술을 찾습니다.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/)는 파일이 **암호화**되어 있는지 감지하고 **패커**를 찾는 도구입니다.

### NeoPI

[**NeoPI**](https://github.com/CiscoCXSecurity/NeoPI)는 텍스트/스크립트 파일 내에서 **난독화** 및 **암호화**된 콘텐츠를 감지하기 위해 다양한 **통계적 방법**을 사용하는 Python 스크립트입니다. NeoPI의 의도된 목적은 **숨겨진 웹 셸 코드**의 **탐지**를 돕는 것입니다.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder)는 **악성코드**/웹셸에서 자주 사용되는 **PHP** 함수를 사용하는 파일뿐만 아니라 **난독화**/**의심스러운 코드**를 감지하기 위해 최선을 다합니다.

### Apple Binary Signatures

일부 **악성코드 샘플**을 확인할 때는 항상 이진 파일의 **서명**을 확인해야 하며, 서명한 **개발자**가 이미 **악성코드**와 **관련**되어 있을 수 있습니다.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## 탐지 기술

### 파일 스태킹

웹 서버의 **파일**이 포함된 폴더가 **마지막으로 업데이트된 날짜**를 알고 있다면, **웹 서버의 모든 파일**이 **생성 및 수정된 날짜**를 **확인**하고, **의심스러운** 날짜가 있다면 해당 파일을 확인하세요.

### 기준선

폴더의 파일이 **수정되지 않아야 하는 경우**, 폴더의 **원본 파일**의 **해시**를 계산하고 **현재** 파일과 **비교**할 수 있습니다. 수정된 것은 **의심스러운** 것으로 간주됩니다.

### 통계 분석

정보가 로그에 저장될 때, 각 웹 서버의 파일이 얼마나 자주 접근되었는지와 같은 **통계를 확인**할 수 있으며, 웹 셸이 가장 많이 접근된 것 중 하나일 수 있습니다.

{{#include ../../banners/hacktricks-training.md}}
