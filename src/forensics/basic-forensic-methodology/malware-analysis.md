# Analiza złośliwego oprogramowania

{{#include ../../banners/hacktricks-training.md}}

## Arkusze oszustw w dziedzinie kryminalistyki

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Usługi online

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline narzędzia antywirusowe i detekcyjne

### Yara

#### Instalacja
```bash
sudo apt-get install -y yara
```
#### Przygotuj zasady

Użyj tego skryptu, aby pobrać i połączyć wszystkie zasady yara dotyczące złośliwego oprogramowania z github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Utwórz katalog _**rules**_ i uruchom go. To stworzy plik o nazwie _**malware_rules.yar**_, który zawiera wszystkie zasady yara dotyczące złośliwego oprogramowania.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Skanuj
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Sprawdź złośliwe oprogramowanie i utwórz reguły

Możesz użyć narzędzia [**YaraGen**](https://github.com/Neo23x0/yarGen) do generowania reguł yara z pliku binarnego. Sprawdź te samouczki: [**Część 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Część 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Część 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instalacja
```
sudo apt-get install -y clamav
```
#### Skanuj
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** wykrywa potencjalnie złośliwe **zdolności** w plikach wykonywalnych: PE, ELF, .NET. Zatem znajdzie takie rzeczy jak taktyki Att\&ck lub podejrzane zdolności, takie jak:

- sprawdzenie błędu OutputDebugString
- uruchomienie jako usługa
- utworzenie procesu

Pobierz to w [**repozytorium Github**](https://github.com/mandiant/capa).

### IOCs

IOC oznacza Wskaźnik Kompromitacji. IOC to zestaw **warunków, które identyfikują** potencjalnie niechciane oprogramowanie lub potwierdzone **złośliwe oprogramowanie**. Zespoły Blue używają tego rodzaju definicji do **wyszukiwania tego rodzaju złośliwych plików** w swoich **systemach** i **sieciach**.\
Dzielenie się tymi definicjami jest bardzo przydatne, ponieważ gdy złośliwe oprogramowanie zostanie zidentyfikowane na komputerze i utworzone zostanie IOC dla tego złośliwego oprogramowania, inne zespoły Blue mogą je wykorzystać do szybszej identyfikacji złośliwego oprogramowania.

Narzędziem do tworzenia lub modyfikowania IOC jest [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Możesz używać narzędzi takich jak [**Redline**](https://www.fireeye.com/services/freeware/redline.html) do **wyszukiwania zdefiniowanych IOC w urządzeniu**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) to skaner dla Prosty Wskaźników Kompromitacji.\
Wykrywanie opiera się na czterech metodach wykrywania:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) to skaner złośliwego oprogramowania dla systemu Linux wydany na licencji GNU GPLv2, zaprojektowany z myślą o zagrożeniach występujących w środowiskach współdzielonych. Wykorzystuje dane o zagrożeniach z systemów wykrywania intruzji na krawędzi sieci, aby wyodrębnić złośliwe oprogramowanie, które jest aktywnie wykorzystywane w atakach, i generuje sygnatury do wykrywania. Dodatkowo dane o zagrożeniach pochodzą również z zgłoszeń użytkowników z funkcji LMD checkout oraz zasobów społeczności złośliwego oprogramowania.

### rkhunter

Narzędzia takie jak [**rkhunter**](http://rkhunter.sourceforge.net) mogą być używane do sprawdzania systemu plików pod kątem możliwych **rootkitów** i złośliwego oprogramowania.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) to narzędzie, które spróbuje znaleźć zafałszowane ciągi w plikach wykonywalnych, używając różnych technik.

### PEpper

[PEpper](https://github.com/Th3Hurrican3/PEpper) sprawdza podstawowe informacje w pliku wykonywalnym (dane binarne, entropię, adresy URL i IP, niektóre reguły yara).

### PEstudio

[PEstudio](https://www.winitor.com/download) to narzędzie, które pozwala uzyskać informacje o plikach wykonywalnych systemu Windows, takie jak importy, eksporty, nagłówki, ale także sprawdzi virus total i znajdzie potencjalne techniki Att\&ck.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) to narzędzie do wykrywania, czy plik jest **szyfrowany** oraz do znajdowania **packerów**.

### NeoPI

[**NeoPI**](https://github.com/CiscoCXSecurity/NeoPI) to skrypt w Pythonie, który wykorzystuje różnorodne **metody statystyczne** do wykrywania **zafałszowanej** i **szyfrowanej** zawartości w plikach tekstowych/skryptowych. Celem NeoPI jest pomoc w **wykrywaniu ukrytego kodu web shell**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) robi wszystko, co w jego mocy, aby wykryć **zafałszowany**/**podejrzany kod**, a także pliki używające funkcji **PHP** często stosowanych w **malware**/webshellach.

### Apple Binary Signatures

Podczas sprawdzania niektórych **próbek malware** zawsze powinieneś **sprawdzić podpis** pliku binarnego, ponieważ **deweloper**, który go podpisał, może być już **powiązany** z **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Techniki wykrywania

### Stacking plików

Jeśli wiesz, że jakiś folder zawierający **pliki** serwera internetowego był **ostatnio aktualizowany w jakiejś dacie**. **Sprawdź** **datę** wszystkich **plików**, które w **serwerze internetowym zostały utworzone i zmodyfikowane**, a jeśli jakakolwiek data jest **podejrzana**, sprawdź ten plik.

### Bazowe wartości

Jeśli pliki w folderze **nie powinny były być modyfikowane**, możesz obliczyć **hash** **oryginalnych plików** folderu i **porównać** je z **aktualnymi**. Wszystko, co zostało zmodyfikowane, będzie **podejrzane**.

### Analiza statystyczna

Gdy informacje są zapisywane w logach, możesz **sprawdzić statystyki, takie jak ile razy każdy plik serwera internetowego był dostępny, ponieważ web shell może być jednym z najczęstszych**.

{{#include ../../banners/hacktricks-training.md}}
