# Malware-Analyse

{{#include ../../banners/hacktricks-training.md}}

## Forensik CheatSheets

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Online-Dienste

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Offline-Antivirus- und Erkennungstools

### Yara

#### Installieren
```bash
sudo apt-get install -y yara
```
#### Regeln vorbereiten

Verwenden Sie dieses Skript, um alle Yara-Malware-Regeln von GitHub herunterzuladen und zusammenzuführen: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Erstellen Sie das _**rules**_ Verzeichnis und führen Sie es aus. Dies erstellt eine Datei namens _**malware_rules.yar**_, die alle Yara-Regeln für Malware enthält.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Scannen
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Überprüfen Sie auf Malware und erstellen Sie Regeln

Sie können das Tool [**YaraGen**](https://github.com/Neo23x0/yarGen) verwenden, um Yara-Regeln aus einer Binärdatei zu generieren. Schauen Sie sich diese Tutorials an: [**Teil 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Teil 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Teil 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Installieren
```
sudo apt-get install -y clamav
```
#### Scannen
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** erkennt potenziell bösartige **Fähigkeiten** in ausführbaren Dateien: PE, ELF, .NET. Es wird Dinge wie Att\&ck-Taktiken oder verdächtige Fähigkeiten wie:

- Überprüfung auf OutputDebugString-Fehler
- als Dienst ausführen
- Prozess erstellen

Holen Sie es sich im [**Github-Repo**](https://github.com/mandiant/capa).

### IOCs

IOC bedeutet Indicator Of Compromise. Ein IOC ist eine Reihe von **Bedingungen, die** potenziell unerwünschte Software oder bestätigte **Malware** identifizieren. Blue Teams verwenden diese Art von Definition, um **nach dieser Art von bösartigen Dateien** in ihren **Systemen** und **Netzwerken** zu **suchen**.\
Diese Definitionen zu teilen ist sehr nützlich, da, wenn Malware auf einem Computer identifiziert wird und ein IOC für diese Malware erstellt wird, andere Blue Teams es verwenden können, um die Malware schneller zu identifizieren.

Ein Tool zum Erstellen oder Modifizieren von IOCs ist [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Sie können Tools wie [**Redline**](https://www.fireeye.com/services/freeware/redline.html) verwenden, um **nach definierten IOCs auf einem Gerät** zu **suchen**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) ist ein Scanner für einfache Indikatoren von Kompromittierungen.\
Die Erkennung basiert auf vier Erkennungsmethoden:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) ist ein Malware-Scanner für Linux, der unter der GNU GPLv2-Lizenz veröffentlicht wurde und auf die Bedrohungen in gemeinsam genutzten Hosting-Umgebungen ausgerichtet ist. Er verwendet Bedrohungsdaten von Netzwerkgrenzen-Intrusion-Detection-Systemen, um Malware zu extrahieren, die aktiv in Angriffen verwendet wird, und generiert Signaturen zur Erkennung. Darüber hinaus stammen Bedrohungsdaten auch aus Benutzereinsendungen mit der LMD-Checkout-Funktion und Ressourcen der Malware-Community.

### rkhunter

Tools wie [**rkhunter**](http://rkhunter.sourceforge.net) können verwendet werden, um das Dateisystem auf mögliche **Rootkits** und Malware zu überprüfen.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) ist ein Tool, das versucht, obfuskierte Strings in ausführbaren Dateien mit verschiedenen Techniken zu finden.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper) überprüft einige grundlegende Dinge in der ausführbaren Datei (binäre Daten, Entropie, URLs und IPs, einige Yara-Regeln).

### PEstudio

[PEstudio](https://www.winitor.com/download) ist ein Tool, das Informationen über Windows-Ausführungsdateien wie Importe, Exporte, Header bereitstellt, aber auch Virus Total überprüft und potenzielle Att\&ck-Techniken findet.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) ist ein Tool, um zu erkennen, ob eine Datei **verschlüsselt** ist und auch **Packers** zu finden.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI) ist ein Python-Skript, das eine Vielzahl von **statistischen Methoden** verwendet, um **obfuskierte** und **verschlüsselte** Inhalte in Text-/Skriptdateien zu erkennen. Der beabsichtigte Zweck von NeoPI ist es, bei der **Erkennung von verstecktem Webshell-Code** zu helfen.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) gibt sein Bestes, um **obfuskierte**/**verdächtige Codes** sowie Dateien zu erkennen, die häufig in **Malware**/Webshells verwendete **PHP**-Funktionen nutzen.

### Apple Binary Signatures

Beim Überprüfen einer **Malware-Probe** sollten Sie immer die **Signatur** der Binärdatei überprüfen, da der **Entwickler**, der sie signiert hat, möglicherweise bereits mit **Malware** **verbunden** ist.
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Erkennungstechniken

### Dateistapelung

Wenn Sie wissen, dass ein Ordner mit den **Dateien** eines Webservers **am letzten Datum aktualisiert wurde**. **Überprüfen** Sie das **Datum**, an dem alle **Dateien** im **Webserver erstellt und geändert** wurden, und wenn ein Datum **verdächtig** ist, überprüfen Sie diese Datei.

### Basislinien

Wenn die Dateien eines Ordners **nicht geändert worden sein sollten**, können Sie den **Hash** der **ursprünglichen Dateien** des Ordners berechnen und sie mit den **aktuellen** vergleichen. Alles, was geändert wurde, ist **verdächtig**.

### Statistische Analyse

Wenn die Informationen in Protokollen gespeichert sind, können Sie **Statistiken überprüfen, wie oft jede Datei eines Webservers aufgerufen wurde, da eine Web-Shell eine der häufigsten sein könnte**.

{{#include ../../banners/hacktricks-training.md}}
