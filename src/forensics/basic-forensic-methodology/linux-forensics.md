# Linux Forensics

{{#include ../../banners/hacktricks-training.md}}

## Початкове збирання інформації

### Основна інформація

По-перше, рекомендується мати **USB** з **добре відомими бінарними файлами та бібліотеками** (ви можете просто взяти ubuntu і скопіювати папки _/bin_, _/sbin_, _/lib,_ та _/lib64_), потім змонтуйте USB і змініть змінні середовища, щоб використовувати ці бінарні файли:
```bash
export PATH=/mnt/usb/bin:/mnt/usb/sbin
export LD_LIBRARY_PATH=/mnt/usb/lib:/mnt/usb/lib64
```
Як тільки ви налаштували систему на використання хороших і відомих бінарних файлів, ви можете почати **витягувати деяку базову інформацію**:
```bash
date #Date and time (Clock may be skewed, Might be at a different timezone)
uname -a #OS info
ifconfig -a || ip a #Network interfaces (promiscuous mode?)
ps -ef #Running processes
netstat -anp #Proccess and ports
lsof -V #Open files
netstat -rn; route #Routing table
df; mount #Free space and mounted devices
free #Meam and swap space
w #Who is connected
last -Faiwx #Logins
lsmod #What is loaded
cat /etc/passwd #Unexpected data?
cat /etc/shadow #Unexpected data?
find /directory -type f -mtime -1 -print #Find modified files during the last minute in the directory
```
#### Підозріла інформація

Під час отримання базової інформації слід перевірити на дивні речі, такі як:

- **Root процеси** зазвичай працюють з низькими PID, тому якщо ви знайдете root процес з великим PID, ви можете підозрювати
- Перевірте **зареєстровані логіни** користувачів без оболонки в `/etc/passwd`
- Перевірте наявність **хешів паролів** в `/etc/shadow` для користувачів без оболонки

### Дамп пам'яті

Щоб отримати пам'ять працюючої системи, рекомендується використовувати [**LiME**](https://github.com/504ensicsLabs/LiME).\
Щоб **скомпілювати** його, вам потрібно використовувати **той самий ядро**, яке використовує машина жертви.

> [!NOTE]
> Пам'ятайте, що ви **не можете встановити LiME або будь-що інше** на машині жертви, оскільки це призведе до кількох змін у ній

Отже, якщо у вас є ідентична версія Ubuntu, ви можете використовувати `apt-get install lime-forensics-dkms`\
В інших випадках вам потрібно завантажити [**LiME**](https://github.com/504ensicsLabs/LiME) з github і скомпілювати його з правильними заголовками ядра. Щоб **отримати точні заголовки ядра** машини жертви, ви можете просто **скопіювати каталог** `/lib/modules/<kernel version>` на вашу машину, а потім **скомпілювати** LiME, використовуючи їх:
```bash
make -C /lib/modules/<kernel version>/build M=$PWD
sudo insmod lime.ko "path=/home/sansforensics/Desktop/mem_dump.bin format=lime"
```
LiME підтримує 3 **формати**:

- Raw (кожен сегмент з'єднаний разом)
- Padded (той же, що й raw, але з нулями в правих бітах)
- Lime (рекомендований формат з метаданими)

LiME також може бути використаний для **відправки дампу через мережу** замість зберігання його в системі, використовуючи щось на зразок: `path=tcp:4444`

### Диск Imaging

#### Вимкнення

По-перше, вам потрібно буде **вимкнути систему**. Це не завжди можливо, оскільки іноді система буде виробничим сервером, який компанія не може дозволити собі вимкнути.\
Є **2 способи** вимкнення системи: **нормальне вимкнення** та **вимкнення "вийняти штекер"**. Перше дозволить **процесам завершитися як зазвичай** і **файловій системі** бути **синхронізованою**, але це також дозволить можливому **шкідливому ПЗ** **знищити докази**. Підхід "вийняти штекер" може призвести до **втрати деякої інформації** (не багато інформації буде втрачено, оскільки ми вже зробили зображення пам'яті) і **шкідливе ПЗ не матиме жодної можливості** щось з цим зробити. Тому, якщо ви **підозрюєте**, що може бути **шкідливе ПЗ**, просто виконайте **команду** **`sync`** в системі і вийміть штекер.

#### Зняття зображення диска

Важливо зазначити, що **перед підключенням вашого комп'ютера до чогось, що стосується справи**, вам потрібно бути впевненим, що він буде **підключений тільки для читання**, щоб уникнути зміни будь-якої інформації.
```bash
#Create a raw copy of the disk
dd if=<subject device> of=<image file> bs=512

#Raw copy with hashes along the way (more secure as it checks hashes while it's copying the data)
dcfldd if=<subject device> of=<image file> bs=512 hash=<algorithm> hashwindow=<chunk size> hashlog=<hash file>
dcfldd if=/dev/sdc of=/media/usb/pc.image hash=sha256 hashwindow=1M hashlog=/media/usb/pc.hashes
```
### Попередній аналіз образу диска

Імідж образу диска без додаткових даних.
```bash
#Find out if it's a disk image using "file" command
file disk.img
disk.img: Linux rev 1.0 ext4 filesystem data, UUID=59e7a736-9c90-4fab-ae35-1d6a28e5de27 (extents) (64bit) (large files) (huge files)

#Check which type of disk image it's
img_stat -t evidence.img
raw
#You can list supported types with
img_stat -i list
Supported image format types:
raw (Single or split raw file (dd))
aff (Advanced Forensic Format)
afd (AFF Multiple File)
afm (AFF with external metadata)
afflib (All AFFLIB image formats (including beta ones))
ewf (Expert Witness Format (EnCase))

#Data of the image
fsstat -i raw -f ext4 disk.img
FILE SYSTEM INFORMATION
--------------------------------------------
File System Type: Ext4
Volume Name:
Volume ID: 162850f203fd75afab4f1e4736a7e776

Last Written at: 2020-02-06 06:22:48 (UTC)
Last Checked at: 2020-02-06 06:15:09 (UTC)

Last Mounted at: 2020-02-06 06:15:18 (UTC)
Unmounted properly
Last mounted on: /mnt/disk0

Source OS: Linux
[...]

#ls inside the image
fls -i raw -f ext4 disk.img
d/d 11: lost+found
d/d 12: Documents
d/d 8193:       folder1
d/d 8194:       folder2
V/V 65537:      $OrphanFiles

#ls inside folder
fls -i raw -f ext4 disk.img 12
r/r 16: secret.txt

#cat file inside image
icat -i raw -f ext4 disk.img 16
ThisisTheMasterSecret
```
## Пошук відомого шкідливого ПЗ

### Модифіковані системні файли

Linux пропонує інструменти для забезпечення цілісності системних компонентів, що є критично важливим для виявлення потенційно проблемних файлів.

- **Системи на базі RedHat**: Використовуйте `rpm -Va` для всебічної перевірки.
- **Системи на базі Debian**: `dpkg --verify` для початкової перевірки, а потім `debsums | grep -v "OK$"` (після встановлення `debsums` за допомогою `apt-get install debsums`) для виявлення будь-яких проблем.

### Детектори шкідливого ПЗ/Rootkit

Прочитайте наступну сторінку, щоб дізнатися про інструменти, які можуть бути корисними для виявлення шкідливого ПЗ:

{{#ref}}
malware-analysis.md
{{#endref}}

## Пошук встановлених програм

Щоб ефективно шукати встановлені програми на системах Debian і RedHat, розгляньте можливість використання системних журналів і баз даних разом з ручними перевірками в загальних каталогах.

- Для Debian перевірте _**`/var/lib/dpkg/status`**_ і _**`/var/log/dpkg.log`**_ для отримання деталей про встановлення пакетів, використовуючи `grep` для фільтрації конкретної інформації.
- Користувачі RedHat можуть запитати базу даних RPM за допомогою `rpm -qa --root=/mntpath/var/lib/rpm`, щоб перерахувати встановлені пакети.

Щоб виявити програмне забезпечення, встановлене вручну або поза цими менеджерами пакетів, досліджуйте каталоги, такі як _**`/usr/local`**_, _**`/opt`**_, _**`/usr/sbin`**_, _**`/usr/bin`**_, _**`/bin`**_, і _**`/sbin`**_. Поєднайте списки каталогів з командами, специфічними для системи, щоб ідентифікувати виконувані файли, не пов'язані з відомими пакетами, що покращить ваш пошук усіх встановлених програм.
```bash
# Debian package and log details
cat /var/lib/dpkg/status | grep -E "Package:|Status:"
cat /var/log/dpkg.log | grep installed
# RedHat RPM database query
rpm -qa --root=/mntpath/var/lib/rpm
# Listing directories for manual installations
ls /usr/sbin /usr/bin /bin /sbin
# Identifying non-package executables (Debian)
find /sbin/ -exec dpkg -S {} \; | grep "no path found"
# Identifying non-package executables (RedHat)
find /sbin/ –exec rpm -qf {} \; | grep "is not"
# Find exacuable files
find / -type f -executable | grep <something>
```
## Відновлення видалених запущених бінарних файлів

Уявіть процес, який був виконаний з /tmp/exec і потім видалений. Можливо, його витягти.
```bash
cd /proc/3746/ #PID with the exec file deleted
head -1 maps #Get address of the file. It was 08048000-08049000
dd if=mem bs=1 skip=08048000 count=1000 of=/tmp/exec2 #Recorver it
```
## Перевірка місць автозапуску

### Заплановані завдання
```bash
cat /var/spool/cron/crontabs/*  \
/var/spool/cron/atjobs \
/var/spool/anacron \
/etc/cron* \
/etc/at* \
/etc/anacrontab \
/etc/incron.d/* \
/var/spool/incron/* \

#MacOS
ls -l /usr/lib/cron/tabs/ /Library/LaunchAgents/ /Library/LaunchDaemons/ ~/Library/LaunchAgents/
```
### Послуги

Шляхи, де шкідливе ПЗ може бути встановлено як служба:

- **/etc/inittab**: Викликає скрипти ініціалізації, такі як rc.sysinit, направляючи далі до скриптів запуску.
- **/etc/rc.d/** та **/etc/rc.boot/**: Містять скрипти для запуску служб, останній з яких знаходиться в старіших версіях Linux.
- **/etc/init.d/**: Використовується в певних версіях Linux, таких як Debian, для зберігання скриптів запуску.
- Служби також можуть бути активовані через **/etc/inetd.conf** або **/etc/xinetd/**, залежно від варіанту Linux.
- **/etc/systemd/system**: Директорія для скриптів менеджера системи та служб.
- **/etc/systemd/system/multi-user.target.wants/**: Містить посилання на служби, які повинні бути запущені в багатокористувацькому режимі.
- **/usr/local/etc/rc.d/**: Для користувацьких або сторонніх служб.
- **\~/.config/autostart/**: Для автоматичних програм запуску, специфічних для користувача, які можуть бути прихованим місцем для шкідливого ПЗ, націленого на користувача.
- **/lib/systemd/system/**: Стандартні файли одиниць системи, надані встановленими пакетами.

### Модулі ядра

Модулі ядра Linux, які часто використовуються шкідливим ПЗ як компоненти руткітів, завантажуються під час завантаження системи. Директорії та файли, критично важливі для цих модулів, включають:

- **/lib/modules/$(uname -r)**: Містить модулі для версії ядра, що працює.
- **/etc/modprobe.d**: Містить конфігураційні файли для контролю завантаження модулів.
- **/etc/modprobe** та **/etc/modprobe.conf**: Файли для глобальних налаштувань модулів.

### Інші місця автозапуску

Linux використовує різні файли для автоматичного виконання програм під час входу користувача, що потенційно може приховувати шкідливе ПЗ:

- **/etc/profile.d/**\*, **/etc/profile**, та **/etc/bash.bashrc**: Виконуються для будь-якого входу користувача.
- **\~/.bashrc**, **\~/.bash_profile**, **\~/.profile**, та **\~/.config/autostart**: Файли, специфічні для користувача, які виконуються під час їх входу.
- **/etc/rc.local**: Виконується після того, як всі системні служби були запущені, що позначає кінець переходу до багатокористувацького середовища.

## Перевірка журналів

Системи Linux відстежують активність користувачів та події системи через різні журнали. Ці журнали є важливими для виявлення несанкціонованого доступу, інфекцій шкідливим ПЗ та інших інцидентів безпеки. Ключові журнали включають:

- **/var/log/syslog** (Debian) або **/var/log/messages** (RedHat): Фіксують системні повідомлення та активність.
- **/var/log/auth.log** (Debian) або **/var/log/secure** (RedHat): Записують спроби аутентифікації, успішні та невдалі входи.
- Використовуйте `grep -iE "session opened for|accepted password|new session|not in sudoers" /var/log/auth.log`, щоб відфільтрувати відповідні події аутентифікації.
- **/var/log/boot.log**: Містить повідомлення про запуск системи.
- **/var/log/maillog** або **/var/log/mail.log**: Журнали активності поштового сервера, корисні для відстеження служб, пов'язаних з електронною поштою.
- **/var/log/kern.log**: Зберігає повідомлення ядра, включаючи помилки та попередження.
- **/var/log/dmesg**: Містить повідомлення драйверів пристроїв.
- **/var/log/faillog**: Записує невдалі спроби входу, що допомагає в розслідуванні порушень безпеки.
- **/var/log/cron**: Журнали виконання cron-завдань.
- **/var/log/daemon.log**: Відстежує активність фонових служб.
- **/var/log/btmp**: Документує невдалі спроби входу.
- **/var/log/httpd/**: Містить журнали помилок та доступу Apache HTTPD.
- **/var/log/mysqld.log** або **/var/log/mysql.log**: Журнали активності бази даних MySQL.
- **/var/log/xferlog**: Записує FTP-передачі файлів.
- **/var/log/**: Завжди перевіряйте на наявність несподіваних журналів тут.

> [!NOTE]
> Журнали системи Linux та підсистеми аудиту можуть бути вимкнені або видалені під час вторгнення або інциденту з шкідливим ПЗ. Оскільки журнали на системах Linux зазвичай містять деяку з найкорисніших інформацій про злочинні дії, зловмисники регулярно їх видаляють. Тому, перевіряючи доступні журнали, важливо шукати прогалини або записи в неправильному порядку, які можуть свідчити про видалення або підробку.

**Linux зберігає історію команд для кожного користувача**, що зберігається в:

- \~/.bash_history
- \~/.zsh_history
- \~/.zsh_sessions/\*
- \~/.python_history
- \~/.\*\_history

Крім того, команда `last -Faiwx` надає список входів користувачів. Перевірте його на наявність невідомих або несподіваних входів.

Перевірте файли, які можуть надати додаткові привілеї:

- Перегляньте `/etc/sudoers` на предмет непередбачених привілеїв користувачів, які могли бути надані.
- Перегляньте `/etc/sudoers.d/` на предмет непередбачених привілеїв користувачів, які могли бути надані.
- Перевірте `/etc/groups`, щоб виявити будь-які незвичайні членства в групах або дозволи.
- Перевірте `/etc/passwd`, щоб виявити будь-які незвичайні членства в групах або дозволи.

Деякі програми також генерують свої власні журнали:

- **SSH**: Перевірте _\~/.ssh/authorized_keys_ та _\~/.ssh/known_hosts_ на предмет несанкціонованих віддалених з'єднань.
- **Gnome Desktop**: Перегляньте _\~/.recently-used.xbel_ для нещодавно відкритих файлів через програми Gnome.
- **Firefox/Chrome**: Перевірте історію браузера та завантаження в _\~/.mozilla/firefox_ або _\~/.config/google-chrome_ на предмет підозрілої активності.
- **VIM**: Перегляньте _\~/.viminfo_ для деталей використання, таких як шляхи до відкритих файлів та історія пошуку.
- **Open Office**: Перевірте наявність нещодавнього доступу до документів, що може свідчити про компрометацію файлів.
- **FTP/SFTP**: Перегляньте журнали в _\~/.ftp_history_ або _\~/.sftp_history_ на предмет передач файлів, які можуть бути несанкціонованими.
- **MySQL**: Досліджуйте _\~/.mysql_history_ для виконаних запитів MySQL, що можуть вказувати на несанкціоновану активність бази даних.
- **Less**: Аналізуйте _\~/.lesshst_ для історії використання, включаючи переглянуті файли та виконані команди.
- **Git**: Перевірте _\~/.gitconfig_ та проект _.git/logs_ на предмет змін у репозиторіях.

### Журнали USB

[**usbrip**](https://github.com/snovvcrash/usbrip) - це невеликий програмний продукт, написаний на чистому Python 3, який аналізує журнали Linux (`/var/log/syslog*` або `/var/log/messages*` в залежності від дистрибутива) для створення таблиць історії подій USB.

Цікаво **знати всі USB, які використовувалися**, і це буде ще корисніше, якщо у вас є авторизований список USB для виявлення "порушень" (використання USB, які не входять до цього списку).

### Встановлення
```bash
pip3 install usbrip
usbrip ids download #Download USB ID database
```
### Приклади
```bash
usbrip events history #Get USB history of your curent linux machine
usbrip events history --pid 0002 --vid 0e0f --user kali #Search by pid OR vid OR user
#Search for vid and/or pid
usbrip ids download #Downlaod database
usbrip ids search --pid 0002 --vid 0e0f #Search for pid AND vid
```
Більше прикладів та інформації всередині github: [https://github.com/snovvcrash/usbrip](https://github.com/snovvcrash/usbrip)

## Перегляд облікових записів користувачів та активності входу

Перевірте _**/etc/passwd**_, _**/etc/shadow**_ та **журнали безпеки** на наявність незвичних імен або облікових записів, створених або використаних у близькій близькості до відомих несанкціонованих подій. Також перевірте можливі атаки грубої сили на sudo.\
Крім того, перевірте файли, такі як _**/etc/sudoers**_ та _**/etc/groups**_, на предмет несподіваних привілеїв, наданих користувачам.\
Нарешті, шукайте облікові записи з **без паролів** або **легко вгадуваними** паролями.

## Перевірка файлової системи

### Аналіз структур файлової системи в розслідуванні шкідливого ПЗ

Під час розслідування інцидентів з шкідливим ПЗ структура файлової системи є важливим джерелом інформації, що розкриває як послідовність подій, так і вміст шкідливого ПЗ. Однак автори шкідливого ПЗ розробляють техніки, щоб ускладнити цей аналіз, такі як зміна часових міток файлів або уникнення файлової системи для зберігання даних.

Щоб протидіяти цим антифорензічним методам, важливо:

- **Провести ретельний аналіз хронології** за допомогою інструментів, таких як **Autopsy** для візуалізації хронологій подій або **Sleuth Kit's** `mactime` для детальних даних хронології.
- **Дослідити несподівані скрипти** в $PATH системи, які можуть включати shell або PHP скрипти, що використовуються зловмисниками.
- **Перевірити `/dev` на наявність нетипових файлів**, оскільки він традиційно містить спеціальні файли, але може містити файли, пов'язані зі шкідливим ПЗ.
- **Шукати приховані файли або каталоги** з іменами, такими як ".. " (крапка крапка пробіл) або "..^G" (крапка крапка контроль-G), які можуть приховувати шкідливий вміст.
- **Визначити файли setuid root** за допомогою команди: `find / -user root -perm -04000 -print` Це знаходить файли з підвищеними привілеями, які можуть бути зловживані зловмисниками.
- **Переглянути часові мітки видалення** в таблицях inode, щоб виявити масові видалення файлів, що може вказувати на наявність rootkit або троянів.
- **Перевірити послідовні inode** на наявність сусідніх шкідливих файлів після виявлення одного, оскільки вони могли бути розміщені разом.
- **Перевірити загальні каталоги бінарних файлів** (_/bin_, _/sbin_) на наявність нещодавно змінених файлів, оскільки ці файли можуть бути змінені шкідливим ПЗ.
````bash
# List recent files in a directory:
ls -laR --sort=time /bin```

# Sort files in a directory by inode:
ls -lai /bin | sort -n```
````
> [!NOTE]
> Зверніть увагу, що **зловмисник** може **змінити** **час**, щоб **файли виглядали** **легітимними**, але він **не може** змінити **inode**. Якщо ви виявите, що **файл** вказує на те, що він був створений і змінений в **один і той же час** з іншими файлами в тій же папці, але **inode** є **неочікувано більшим**, то **часові мітки цього файлу були змінені**.

## Порівняння файлів різних версій файлової системи

### Резюме порівняння версій файлової системи

Щоб порівняти версії файлової системи та виявити зміни, ми використовуємо спрощені команди `git diff`:

- **Щоб знайти нові файли**, порівняйте дві директорії:
```bash
git diff --no-index --diff-filter=A path/to/old_version/ path/to/new_version/
```
- **Для зміненого контенту**, перерахувати зміни, ігноруючи конкретні рядки:
```bash
git diff --no-index --diff-filter=M path/to/old_version/ path/to/new_version/ | grep -E "^\+" | grep -v "Installed-Time"
```
- **Щоб виявити видалені файли**:
```bash
git diff --no-index --diff-filter=D path/to/old_version/ path/to/new_version/
```
- **Опції фільтрації** (`--diff-filter`) допомагають звузити до конкретних змін, таких як додані (`A`), видалені (`D`) або змінені (`M`) файли.
- `A`: Додані файли
- `C`: Скопійовані файли
- `D`: Видалені файли
- `M`: Змінені файли
- `R`: Перейменовані файли
- `T`: Зміни типу (наприклад, файл на символічне посилання)
- `U`: Невирішені файли
- `X`: Невідомі файли
- `B`: Пошкоджені файли

## Посилання

- [https://cdn.ttgtmedia.com/rms/security/Malware%20Forensics%20Field%20Guide%20for%20Linux%20Systems_Ch3.pdf](https://cdn.ttgtmedia.com/rms/security/Malware%20Forensics%20Field%20Guide%20for%20Linux%20Systems_Ch3.pdf)
- [https://www.plesk.com/blog/featured/linux-logs-explained/](https://www.plesk.com/blog/featured/linux-logs-explained/)
- [https://git-scm.com/docs/git-diff#Documentation/git-diff.txt---diff-filterACDMRTUXB82308203](https://git-scm.com/docs/git-diff#Documentation/git-diff.txt---diff-filterACDMRTUXB82308203)
- **Книга: Посібник з комп'ютерної криміналістики для Linux-систем: Посібники з цифрової криміналістики**

{{#include ../../banners/hacktricks-training.md}}
